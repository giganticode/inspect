te	2	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
te	8	public boolean initHeaderComponents ( ) { locationLabel = new JLabel ( "Project Location" ) ; locationLabel . setBounds ( 5 , 5 , 100 , 25 ) ; locationField = new JTextField ( ) ; locationField . setBounds ( 105 , 5 , 400 , 25 ) ; includeLabel = new JLabel ( "Include File type" ) ; includeLabel . setBounds ( 5 , 35 , 100 , 25 ) ; includeTextField = new JTextField ( ) ; includeTextField . setBounds ( 105 , 35 , 400 , 25 ) ; nonIncludeLabel = new JLabel ( "Non include" ) ; nonIncludeLabel . setBounds ( 5 , 65 , 100 , 25 ) ; nonIncludeTextField = new JTextField ( ) ; nonIncludeTextField . setBounds ( 105 , 65 , 400 , 25 ) ; configIncludeAndNonInclude ( ) ; openFileButton = new JButton ( "File.." ) ; openFileButton . setBounds ( 515 , 5 , 80 , 25 ) ; openFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileChooser = new JFileChooser ( new File ( "c:" ) ) ; int i = fileChooser . showOpenDialog ( header ) ; if ( i == JFileChooser . APPROVE_OPTION ) { locationField . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; configButton = new JButton ( "Config.." ) ; configButton . setBounds ( 515 , 45 , 80 , 25 ) ; configButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { configIncludeAndNonInclude ( ) ; } } ) ; loadButton = new JButton ( "Load" ) ; loadButton . setBounds ( 605 , 5 , 80 , 80 ) ; loadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( locationField . getText ( ) == null || locationField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "File cannot be null!" ) ; return ; } if ( includeTextField . getText ( ) == null || includeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Include cannot be null!" ) ; return ; } if ( nonIncludeTextField . getText ( ) == null || nonIncludeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Non-Include cannot be null!" ) ; return ; } if ( sourceCounter == null ) { sourceCounter = new SourceCounter ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) , includeTextField . getText ( ) , nonIncludeTextField . getText ( ) ) ; } else { sourceCounter . setFiles ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) ) ; sourceCounter . repaint ( ) ; } } } ) ; header . add ( locationLabel ) ; header . add ( locationField ) ; header . add ( includeLabel ) ; header . add ( includeTextField ) ; header . add ( nonIncludeLabel ) ; header . add ( nonIncludeTextField ) ; header . add ( openFileButton ) ; header . add ( configButton ) ; header . add ( loadButton ) ; return false ; }
te	4	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
te	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
te	6	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
te	8	public static Application parseApplicationDescription ( JSONObject topJson , boolean store ) throws DBException { try { JSONObject appJson ; appJson = topJson . getJSONObject ( "application" ) ; if ( ! appJson . has ( "USER_id" ) ) { appJson . put ( "USER_id" , ( User . getByName ( appJson . getString ( "USER_name" ) ) ) . getId ( ) ) ; } Application app = new Application ( appJson ) ; if ( store ) app . store ( ) ; LOG . debug ( "loading description for app:" + app . getDescription ( ) ) ; JSONArray modules = appJson . getJSONArray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { JSONObject m = modules . getJSONObject ( i ) ; m . put ( "APPLICATION_id" , app . getId ( ) ) ; Module module = new Module ( m ) ; if ( store ) module . store ( ) ; LOG . debug ( "parsed Module:" + module ) ; JSONArray components = m . getJSONArray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { JSONObject c = components . getJSONObject ( j ) ; c . put ( "MODULE_id" , "" + module . getId ( ) ) ; if ( ! c . has ( "RESOURCE_TYPE_id" ) ) { ResourceType rt = ResourceType . getByName ( c . getString ( "resource_type" ) ) ; c . put ( "RESOURCE_TYPE_id" , rt . getId ( ) ) ; } Component component = new Component ( c ) ; if ( store ) component . store ( ) ; LOG . debug ( "parsed component: " + component ) ; } } return app ; } catch ( JSONException ex ) { System . err . println ( "parsing not successfull" ) ; ex . printStackTrace ( ) ; } return null ; }
te	4	protected boolean isInGrabBar ( int mouseX , int mouseY ) { mouseY = Standards . W_HEIGHT - mouseY - 1 ; if ( ( mouseX > ScreenX ) && ( mouseX < ScreenX + Width ) ) { if ( ( mouseY > ScreenY ) && ( mouseY < ScreenY + GrabBarHeight ) ) { return true ; } } return false ; }
te	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
te	5	private static void loadVersionProperties ( ) { ClassLoader loader = ReleaseInfo . class . getClassLoader ( ) ; Properties info = new Properties ( ) ; InputStream stream = loader . getResourceAsStream ( PROPERTY_FILE ) ; if ( stream == null ) stream = loader . getResourceAsStream ( "/" + PROPERTY_FILE ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildVersion = info . getProperty ( "version" ) ; buildDate = info . getProperty ( "build.date" ) ; } catch ( IOException e ) { } } if ( buildVersion == null ) buildVersion = "unknown" ; if ( buildDate == null ) buildDate = "unknown" ; }
te	1	public static final < T extends Node < T >> void checkSameGraphs ( final Graph < T > g1 , final Graph < T > g2 ) { if ( g1 . getName ( ) . equals ( g2 . getName ( ) ) == false ) { throw new IllegalStateException ( "The two graphs are not same." ) ; } }
te	6	public Integer checkFields ( ) { if ( buttonGroup . getSelection ( ) == null ) { return null ; } else { final Enumeration < AbstractButton > elements = buttonGroup . getElements ( ) ; Integer num = null ; while ( elements . hasMoreElements ( ) ) { final JRadioButton button = ( JRadioButton ) elements . nextElement ( ) ; if ( button != null ) { if ( button . isSelected ( ) ) { num = Integer . parseInt ( button . getText ( ) . substring ( button . getText ( ) . lastIndexOf ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkFields ( num ) ) { return num ; } else { JOptionPane . showMessageDialog ( null , "***ERROR***: Incorrect search options" ) ; } } } return null ; }
te	4	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
te	5	public static void print ( JTextComponent textComponent ) throws TextComponentUtilException { InputStream is = null ; try { PrintService [ ] printServices = PrintServiceLookup . lookupPrintServices ( DocFlavor . INPUT_STREAM . AUTOSENSE , null ) ; if ( printServices . length > 0 ) { PrintRequestAttributeSet printRequestAttributeSet = new HashPrintRequestAttributeSet ( ) ; printRequestAttributeSet . add ( new JobName ( "JAligner" , null ) ) ; PrintService service = ServiceUI . printDialog ( null , 50 , 50 , printServices , PrintServiceLookup . lookupDefaultPrintService ( ) , DocFlavor . INPUT_STREAM . AUTOSENSE , printRequestAttributeSet ) ; if ( service != null ) { DocPrintJob printJob = service . createPrintJob ( ) ; PrintJobMointor printJobMointor = new PrintJobMointor ( printJob ) ; is = new ByteArrayInputStream ( textComponent . getText ( ) . getBytes ( ) ) ; DocumentName documentName = new DocumentName ( "JAligner" , null ) ; HashDocAttributeSet docAttributeSet = new HashDocAttributeSet ( ) ; docAttributeSet . add ( documentName ) ; Doc doc = new SimpleDoc ( is , DocFlavor . INPUT_STREAM . AUTOSENSE , docAttributeSet ) ; printJob . print ( doc , printRequestAttributeSet ) ; printJobMointor . waitForPrintJob ( ) ; } } else { throw new TextComponentUtilException ( "No print service found!" ) ; } } catch ( Exception e ) { throw new TextComponentUtilException ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Failed closing input stream: " + e . getMessage ( ) , e ) ; } } } }
te	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
te	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
te	1	public static String SQLdecrypted ( String decrypt ) { String decrypted = "" ; try { SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "DES" ) ; DESKeySpec keySpec = new DESKeySpec ( secretSalt . getBytes ( ) ) ; SecretKey key = keyFactory . generateSecret ( keySpec ) ; DesEncrypter encrypter = new DesEncrypter ( key ) ; decrypted = encrypter . decrypt ( decrypt ) ; } catch ( Exception e ) { Error_Frame . Error ( e . toString ( ) ) ; } return decrypted ; }
te	4	@ Override public boolean hasNext ( ) { if ( end ) { return false ; } if ( next != null ) { return true ; } peeked = true ; while ( iterator . hasNext ( ) ) { final T n = iterator . next ( ) ; if ( predicate . evaluate ( n ) ) { next = n ; return true ; } } end = true ; return false ; }
te	5	public static String toString ( float [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
te	0	public void setWeight ( int weight ) { this . weight = weight ; }
te	2	public void addThird ( Timeslot t ) { if ( t instanceof Lab ) { addThirdLab ( t ) ; } else if ( t instanceof Tutorial ) { addThirdTut ( t ) ; } }
te	9X	public int moveToMe ( MyStore < T > other ) { if ( other . size == 0 ) return 0 ; if ( this . size == 0 ) { this . moveAll ( other . size , other . head , this . tail , other ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return this . size ; } int initialMySize = this . size ; int initialOtherSize = other . size ; Container < T > thisOld = this . head ; Container < T > otherOld = other . head ; Container < T > thisCurrent = this . head . next ; Container < T > otherCurrent = other . head . next ; int otherRemaining = other . size ; int moved = 0 ; boolean done = false ; while ( true ) { int result = this . compare ( thisCurrent . el , otherCurrent . el ) ; if ( result == 0 ) { if ( otherCurrent . next != null ) { otherOld = otherCurrent ; otherCurrent = otherCurrent . next ; otherRemaining -- ; } else { done = true ; break ; } if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } else if ( result > 0 ) { otherOld . next = otherCurrent . next ; other . size -- ; thisOld . next = otherCurrent ; otherCurrent . next = thisCurrent ; this . size ++ ; moved ++ ; thisOld = otherCurrent ; if ( other . tail == otherCurrent ) { other . tail = otherOld ; } if ( otherOld . next != null ) { otherCurrent = otherOld . next ; otherRemaining -- ; } else { done = true ; break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } if ( ! done ) { this . moveAll ( otherRemaining , otherOld , thisCurrent , other ) ; moved += otherRemaining ; } assert ( this . size == initialMySize + moved ) ; assert ( other . size == initialOtherSize - moved ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return moved ; }
te	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
te	1	private static CC getCC ( ComponentWrapper comp , Map < ComponentWrapper , CC > ccMap ) { CC cc = ccMap . get ( comp ) ; return cc != null ? cc : new CC ( ) ; }
te	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
te	5	public MyPopulation ( int populationSize , int dataSize , IMyFitnessTestFunction < U > fitnessTester , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( populationSize < 4 ) { throw new Exception ( "population size should be 4 or greater" ) ; } if ( dataSize < MyIndividual . MIN_DATA_SIZE ) { throw new Exception ( "data size should be 4 or greater" ) ; } if ( fitnessTester == null ) { throw new Exception ( "fitnessTester function Cannot be null" ) ; } population = new ArrayList < > ( ) ; try { for ( int i = 0 ; i < populationSize ; i ++ ) { population . add ( new MyIndividual ( dataSize , true , 0.99 , true , fitnessTester , rFunc ) ) ; } } catch ( Exception e ) { System . err . println ( "ex in individual's constructor:" + e . getMessage ( ) ) ; } }
te	4	public void update ( final long newCurrent , final String optStatus ) { if ( this . upperLimit == - 1 ) { throw new IllegalArgumentException ( "This progress printer has not been initialized" ) ; } this . ownPos = newCurrent ; long sumOfSubProgresses = 0 ; this . currentPos = 0 ; for ( final ProgressPrinter subProgress : this . subProgress . keySet ( ) ) { double percentFinishedSubProgress = subProgress . getPercent ( ) / 100.0 ; long totalNumberStepsSubProgress = this . subProgress . get ( subProgress ) ; this . currentPos += ( percentFinishedSubProgress * totalNumberStepsSubProgress ) ; sumOfSubProgresses += totalNumberStepsSubProgress ; } final long remainingPart = this . upperLimit - sumOfSubProgresses ; if ( remainingPart < 0 ) { throw new IllegalArgumentException ( "Invalid part-sums of sub progresses" ) ; } this . currentPos += this . ownPos ; final float newPercent = this . currentPos > 0 ? ( ( float ) ( this . currentPos ) / this . upperLimit * 100.0f ) : 0.0f ; this . optStatus = optStatus ; this . % = newPercent ; this . fireChangeListener ( ) ; }
te	4	public void equipWeapon ( Survivor survivor , Weapon weapon ) throws CantEquipWeaponException { if ( ! this . survivors . contains ( survivor ) ) { throw new CantEquipWeaponException ( CantEquipWeaponException . notInTheTeam ( survivor ) ) ; } else if ( ! this . mainBase . getAvailableWeapons ( ) . contains ( weapon ) ) { throw new CantEquipWeaponException ( "Weapon must be one of those stored in base to equip" ) ; } else { Survivor owner = this . alreadyEquipped ( weapon ) ; if ( owner != null ) { throw new CantEquipWeaponException ( "Weapon is already equipped by " + owner . getName ( ) ) ; } else { Weapon oldWeapon = survivor . getWeapon ( ) ; this . mainBase . getAvailableWeapons ( ) . remove ( weapon ) ; survivor . setWeapon ( weapon ) ; if ( oldWeapon != null ) { this . mainBase . getAvailableWeapons ( ) . add ( oldWeapon ) ; } } } }
te	5	private LinkedList < String > extractKeywords ( String filename ) { LinkedList < String > keywords = new LinkedList < String > ( ) ; int posOfDot = filename . lastIndexOf ( . ) ; if ( posOfDot != - 1 ) { keywords . add ( filename . substring ( posOfDot ) ) ; filename = filename . substring ( 0 , posOfDot ) ; } filename = filename . replaceAll ( "[0-9]+" , " " ) . trim ( ) ; String [ ] splitCamelAndDelim = filename . split ( "((?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addAll ( Arrays . asList ( splitCamelAndDelim ) ) ; for ( Iterator < String > iter = keywords . iterator ( ) ; iter . hasNext ( ) ; ) { String item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . toUpperCase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
te	4	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
te	8	public final float getPixelUnitFactor ( boolean isHor ) { switch ( PlatformDefaults . getLogicalPixelBase ( ) ) { case PlatformDefaults . BASE_FONT_SIZE : Font font = c . getFont ( ) ; FontMetrics fm = c . getFontMetrics ( font != null ? font : SUBST_FONT ) ; Point . float p = FM_MAP . get ( fm ) ; if ( p == null ) { Rectangle2D r = fm . getStringBounds ( "X" , c . getGraphics ( ) ) ; p = new Point . float ( ( ( float ) r . getWidth ( ) ) / 6f , ( ( float ) r . getHeight ( ) ) / 13.27734375f ) ; FM_MAP . put ( fm , p ) ; } return isHor ? p . x : p . y ; case PlatformDefaults . BASE_SCALE_FACTOR : float s = isHor ? PlatformDefaults . getHorizontalScaleFactor ( ) : PlatformDefaults . getVerticalScaleFactor ( ) ; if ( s != null ) return s ; return ( isHor ? getHorizontalScreenDPI ( ) : getVerticalScreenDPI ( ) ) / ( float ) PlatformDefaults . getDefaultDPI ( ) ; default : return 1f ; } }
te	7	public void __doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = ( Context ) req . getSession ( ) . getAttribute ( Authtoken . TOKEN ) ; if ( ctx == null ) { ctx = new Context ( ) ; } String questionId = new String ( ) ; if ( req . getPathInfo ( ) != null ) { questionId = "/" + Question . RESOURCE_NAME + "/" + req . getPathInfo ( ) . replaceAll ( "/" , "" ) ; } if ( ! questionId . equals ( "" ) ) { Message request = new Message ( ctx ) ; request . put ( Question . ID , questionId ) ; Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; Message profileReq = new Message ( ctx ) ; Message profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , response . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; response . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; List < Map < String , String >> answers = new ArrayList < Map < String , String >> ( ) ; Message answerResp , voteResp ; for ( Map < String , String > ref : response . getReferences ( Question . ANSWERS ) ) { request = new Message ( ctx ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; answerResp = new Message ( ctx ) ; new AnswerService ( ) . doGet ( request , answerResp ) ; Map < String , String > answer = new HashMap < String , String > ( ) ; answer . put ( Answer . ID , answerResp . get ( Answer . ID ) ) ; answer . put ( Answer . CONTENT , answerResp . get ( Answer . CONTENT ) ) ; answer . put ( Answer . VOTES , answerResp . get ( Answer . VOTES ) ) ; answer . put ( Document . AUTHOR , answerResp . get ( Document . AUTHOR ) ) ; answer . put ( System . TIMESTAMP , answerResp . get ( System . TIMESTAMP ) ) ; profileReq = new Message ( ctx ) ; profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , answerResp . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; answer . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; if ( ctx != null ) { request = new Message ( ctx ) ; request . put ( Profile . ID , ctx . getLoggedInUserProfileId ( ) ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; voteResp = new Message ( ctx ) ; new VoteService ( ) . doGet ( request , voteResp ) ; if ( voteResp . containsField ( Vote . ID ) ) { answer . put ( Vote . ID , voteResp . get ( Vote . ID ) ) ; answer . put ( Vote . VOTE , voteResp . get ( Vote . VOTE ) ) ; } } answers . add ( answer ) ; } req . setAttribute ( Answer . RESOURCE_NAME , answers ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , Question . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "View Question" ) ; eventRequest . put ( Event . OBJECT , questionId ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_VIEW , req , resp ) ; } else { Message request = new Message ( ctx ) ; if ( req . getParameter ( QuestionSearchIndex . QUERY_STRING ) != null ) { request . put ( QuestionSearchIndex . QUERY_STRING , req . getParameter ( QuestionSearchIndex . QUERY_STRING ) ) ; } else { request . put ( QuestionSearchIndex . QUERY_STRING , "" ) ; } Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; response . put ( QuestionSearchIndex . QUERY_STRING , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , QuestionSearchIndex . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "Search Question" ) ; eventRequest . put ( Event . OBJECT , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_SEARCH_VIEW , req , resp ) ; } }
te	6	public void mouseClicked ( MouseEvent me ) { try { if ( me . getSource ( ) == jb_connexion ) { login = jtf_login . getText ( ) ; password = String . valueOf ( jpf_password . getPassword ( ) ) ; System . out . println ( "Email : " + login ) ; System . out . println ( "MotDePasse : " + password ) ; User u = null ; Connection co = bs . getConnection ( ) ; System . out . println ( "avant IF" ) ; if ( User . checkPresence ( bs , login , password ) ) { System . out . println ( "debut IF" ) ; u = User . findByLogs ( login , password , bs ) ; groupe = UserType . findById ( u . getId_ut ( ) , bs ) . getName_ut ( ) ; System . out . println ( "OK : " + groupe ) ; afficherMenuPrincipal ( ) ; setResizable ( true ) ; setExtendedState ( MAXIMIZED_BOTH ) ; } else { System . out . println ( "NON OK" ) ; } } if ( me . getSource ( ) == jb_mdp_oublie ) { if ( SwingUtilities . isLeftMouseButton ( me ) ) { } if ( SwingUtilities . isRightMouseButton ( me ) ) { } } } catch ( Exception e ) { System . out . println ( "Exception" ) ; e . printStackTrace ( ) ; } }
te	4	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
te	9X	public boolean isModifier ( DataHolder dataholderHandler , String word , String modifier , String tag ) { if ( this . checkedModifiers . containsKey ( word ) ) { if ( this . checkedModifiers . get ( word ) ) { return true ; } else { return false ; } } Set < String > nouns = new HashSet < String > ( Arrays . asList ( "s p n" . split ( " " ) ) ) ; List < Entry < WordPOSKey , WordPOSValue >> entries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , nouns ) ; if ( entries . size ( ) > 0 ) { this . checkedModifiers . put ( word , true ) ; return true ; } Set < String > bPOS = new HashSet < String > ( ) ; bPOS . add ( "b" ) ; List < Entry < WordPOSKey , WordPOSValue >> boundaries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , bPOS ) ; boolean c1 = ( boundaries . size ( ) > 0 ) ; boolean c2 = dataholderHandler . getModifierHolder ( ) . containsKey ( word ) ; if ( c1 && ! c2 ) { this . checkedModifiers . put ( word , false ) ; return false ; } if ( ! c1 && c2 ) { this . checkedModifiers . put ( word , true ) ; return true ; } int mCount = this . getMCount ( dataholderHandler , word ) ; String wCopy = "" + word ; if ( StringUtility . isMatchedNullSafe ( word , "_" ) ) { wCopy = wCopy . replaceAll ( "_" , " - " ) ; } int tCount = 0 ; String pattern = "(^| )" + wCopy + " " ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String oSentence = sentenceItem . getOriginalSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( oSentence , pattern ) ) { tCount ++ ; } } if ( tCount == 0 || tCount > 0.25 * mCount ) { this . checkedModifiers . put ( word , false ) ; return false ; } else { this . checkedModifiers . put ( word , true ) ; return true ; } }
te	6	public static String unescape ( String s ) { int len = s . length ( ) ; StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = s . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < len ) { int d = JSONTokener . dehexchar ( s . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( s . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } b . append ( c ) ; } return b . toString ( ) ; }
te	4	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
te	5	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = 1.0 ; } else if ( x [ i ] < ( a + b ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else func [ i ] = 0.0 ; } return func ; }
te	4	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
te	8	public static int searchInt ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchInt ( arr , low , mid - 1 , x ) ; else return searchInt ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchInt ( arr , mid + 1 , high , x ) ; else return searchInt ( arr , low , mid , x ) ; } }
te	6	public static ConsumptionModel getConsumptionModelForWashingMachine ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
te	5	@ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) servletRequest ; HttpServletResponse response = ( HttpServletResponse ) servletResponse ; User session = ( User ) request . getSession ( ) . getAttribute ( "user" ) ; String url = request . getRequestURI ( ) ; response . setHeader ( "Cache-Control" , "no-cache  no-store  must-revalidate" ) ; response . setHeader ( "Pragma" , "no-cache" ) ; response . setDateHeader ( "Expires" , 0 ) ; if ( session == null ) { if ( url . indexOf ( "/content/" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "/security/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } else { if ( url . indexOf ( "register.xhtml" ) >= 0 || url . indexOf ( "/login.xhtml" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexOf ( "logout.xhtml" ) >= 0 ) { request . getSession ( ) . removeAttribute ( "user" ) ; response . sendRedirect ( request . getContextPath ( ) + "/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } }
te	1	public < T > T getInstance ( class < T > c , String [ ] args ) throws Exception { AnnotatedConstructor ctor = ctors . get ( c ) ; AnnotatedCLI . ParsedCLI cli = parse ( args ) ; T obj ; if ( ctor != null ) { obj = ( T ) ctor . newInstance ( cli ) ; } else { obj = ( T ) c . newInstance ( ) ; } cli . inject ( obj ) ; return obj ; }
te	1	public void closeWriter ( ) { try { this . writer . flush ( ) ; this . writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	6	public static Integer valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof byte ) { return ( int ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( Integer ) o ; } else if ( o instanceof double ) { return ( int ) ( double ) ( double ) o ; } else if ( o instanceof float ) { return ( int ) ( float ) ( float ) o ; } else if ( o instanceof long ) { return ( int ) ( long ) ( long ) o ; } else { return null ; } }
te	6	private void initPanels ( ) { if ( attribs == null ) { attribs = new MyInternalFrame ( this , 1 ) ; jDesktopPane1 . add ( attribs , new Integer ( 10 ) ) ; } try { attribs . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } attribs . setVisible ( true ) ; if ( tools == null ) { tools = new MyInternalFrame ( this , 0 ) ; jDesktopPane1 . add ( tools , new Integer ( 10 ) ) ; } tools . setVisible ( true ) ; try { tools . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } if ( opers == null ) { opers = new MyInternalFrame ( this , 2 ) ; jDesktopPane1 . add ( opers , new Integer ( 10 ) ) ; } try { opers . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } opers . setVisible ( true ) ; }
te	5	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof EulerAngles ) { EulerAngles otherAngle = ( EulerAngles ) other ; if ( FloatingPointUtils . floatEqual ( otherAngle . psi , this . psi ) && FloatingPointUtils . floatEqual ( otherAngle . theta , this . theta ) && FloatingPointUtils . floatEqual ( otherAngle . phi , this . phi ) ) { return true ; } } return false ; }
te	3	private void processNumber ( Object value ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; if ( double . isNaN ( average ) ) { average = doubleValue ; min = doubleValue ; max = doubleValue ; sum = doubleValue ; } else { if ( doubleValue < min ) { min = doubleValue ; } if ( doubleValue > max ) { max = doubleValue ; } sum += doubleValue ; average = average + ( doubleValue - average ) / count ; } }
te	7	public void onEnable ( ) { Server = getServer ( ) ; log = Server . getLogger ( ) ; setPdfFile ( this . getDescription ( ) ) ; moveFiles ( ) ; setupPermissions ( ) ; questPlayerStorage = new iProperty ( "plugins/uQuest/uQuest_Players.txt" ) ; if ( new File ( "plugins/uQuest/uQuest_Quests.txt" ) . exists ( ) ) new QuestConverter ( ) ; if ( isUseDefaultUQuest ( ) ) { Cmd_uquest cmd_uquest = new Cmd_uquest ( this ) ; getCommand ( "uquest" ) . setExecutor ( cmd_uquest ) ; getCommand ( "quest" ) . setExecutor ( cmd_uquest ) ; try { getCommand ( "q" ) . setExecutor ( cmd_uquest ) ; } catch ( NullPointerException npe ) { useDefaultHelp = false ; } } setupEconomy ( ) ; Cmd_reloadquests cmd_reloadquests = new Cmd_reloadquests ( this ) ; getCommand ( "reloadquests" ) . setExecutor ( cmd_reloadquests ) ; Cmd_reloadquestconfig cmd_reloadquestconfig = new Cmd_reloadquestconfig ( this ) ; getCommand ( "reloadquestconfig" ) . setExecutor ( cmd_reloadquestconfig ) ; readConfig ( ) ; theQuestsLoadAllIntoArray ( ) ; if ( this . theQuests . isEmpty ( ) ) { System . err . println ( "\n\n\n" + pluginNameBracket ( ) + " You have an empty quest list!\n Disabling plugin.\n\n\n" ) ; Server . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( isUseSQLite ( ) == true ) { this . setDB ( new SqLiteKeyValStor < Quester > ( "questers" , "plugins/uQuest/uQuestQuesters" ) ) ; System . out . println ( pluginNameBracket ( ) + " Loaded with SQLite!" ) ; } if ( firstLoad == true && isUseSQLite ( ) == false ) { timerSavePlayers ( ) ; firstLoad = false ; System . out . println ( pluginNameBracket ( ) + " Loaded with Flatfile!" ) ; } registerEvents ( ) ; System . out . println ( pluginNameBracket ( ) + " v" + getPdfFile ( ) . getVersion ( ) + " enabled! With " + this . getQuestInteraction ( ) . getQuestTotal ( ) + " quests loaded!" ) ; }
te	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
te	8	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
te	9X	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
te	5	@ Override public void mousePressed ( MouseEvent me ) { int w = gridRenderer . getWidth ( ) / gridColumns ; int col = me . getX ( ) / w ; int h = gridRenderer . getHeight ( ) / gridRows ; int row = me . getY ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getButton ( ) == MouseEvent . BUTTON1 ) { if ( tilesRemaining > 0 ) { value ++ ; tilesRemaining -- ; } if ( tilesRemaining == 0 ) { saveAsButton . setEnabled ( true ) ; } } else if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( value > 0 ) { value -- ; tilesRemaining ++ ; saveAsButton . setEnabled ( false ) ; } } grid [ col ] [ row ] = value ; updateTilesRemainingLabel ( ) ; gridRenderer . repaint ( ) ; }
te	3	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
te	3	private static boolean iguales ( Nodo nodo1 , Nodo nodo2 ) { if ( nodo1 == null && nodo2 == null ) return true ; if ( nodo1 . equals ( nodo2 ) ) return iguales ( nodo1 . getSiguiente ( ) , nodo2 . getSiguiente ( ) ) ; return false ; }
te	2	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
te	2	private void botonEliminarUsuarioActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . tablaAdministracionUsuarios . getSelectedRow ( ) > - 1 ) { String codigo = ( String ) this . conectorTablaUsuarios . getValueAt ( this . tablaAdministracionUsuarios . getSelectedRow ( ) , 0 ) ; int respuesta = JOptionPane . showConfirmDialog ( this . botonEliminarUsuario , "\u00BFRealmente desea eliminar \n al usuario " + codigo + "?" , "Confirme eliminaci\u00F3n" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( respuesta == JOptionPane . YES_OPTION ) { Usuario u = this . modeloApp . obtenerUsuarioConCodigo ( codigo ) ; this . modeloApp . eliminarUsuario ( u ) ; this . conectorTablaUsuarios . cargarUsuarios ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Debe seleccionar un\nusuario de la tabla" , "Usuario no seleccionado" , JOptionPane . INFORMATION_MESSAGE ) ; } }
te	6	@ Override public byte [ ] toBytes ( Object value ) { String string = ( String ) value ; string = Normalizer . normalize ( string , Normalizer . Form . NFC ) ; if ( ! caseSensitive ) { string = string . toLowerCase ( locale ) ; } byte [ ] bytes = ENCODERS . get ( byteEncodeMode ) . toBytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new RuntimeException ( "Encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
te	2	protected void markCreatedNode ( Node newNode ) { if ( ! ( newNode instanceof ObjectNode ) ) return ; if ( ! containsAncestor ( createdNodes , newNode ) ) { Node . createdNodes . add ( newNode ) ; } }
te	2	@ NotNull @ Override public FileContent fileContentBefore ( ) { if ( filePathBefore . equals ( noFilePath ) ) return FileContent . none ; LogFileContentResult logFileContentResult = vcsRoot . get ( ) . logFileContent ( filePathBefore , revisionBefore ) ; return logFileContentResult . isSuccessful ( ) ? new FileContent ( logFileContentResult . text ( ) ) : FileContent . failedToLoad ; }
te	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isOpenV ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( toBottom [ idx ] ) { percolates = true ; } ufTop . union ( idx , theTOP ) ; } else { connectIfDestOpen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectIfDestOpen ( idx , row , col - 1 ) ; } if ( col < N ) { connectIfDestOpen ( idx , row , col + 1 ) ; } if ( row == N ) { if ( toTop [ idx ] ) { percolates = true ; } } else { connectIfDestOpen ( idx , row + 1 , col ) ; } } }
te	1	@ Test public void testGetArgument ( ) { initializeArguments ( ) ; InputDefinition definition = new InputDefinition ( ) ; definition . addArguments ( Arrays . asList ( ( InputArgument ) foo ) ) ; assertEquals ( "getArgument() returns a InputArgument by its name" , foo , definition . getArgument ( "foo" ) ) ; try { definition . getArgument ( "bar" ) ; fail ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" ) ; } catch ( Exception e ) { assertTrue ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" , e instanceof IllegalArgumentException ) ; assertEquals ( "The \"bar\" argument does not exist." , e . getMessage ( ) ) ; } }
te	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Station station = ( Station ) o ; if ( id != station . id ) return false ; if ( name != null ? ! name . equals ( station . name ) : station . name != null ) return false ; return true ; }
te	1	public static < T > FunctionExecutor < T > createGet ( final FeatureDefinition < ? extends Property < T >> propertyDefinition ) { return new FunctionExecutor < T > ( ) { @ Override public T invoke ( FunctionInvocation < T > invocation , Object ... arguments ) throws ExecutorInvocationException { invocation . next ( arguments ) ; return invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; } } ; }
te	9X	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
te	2	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
te	5	private void constructGUIControls ( ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager poseurStateManager = singleton . getStateManager ( ) ; canvasSplitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; appWindow = new AnimatedSpriteViewer ( ) ; PoseCanvasState zoomableCanvasState = poseurStateManager . getZoomableCanvasState ( ) ; zoomableCanvas = new PoseCanvas ( zoomableCanvasState ) ; zoomableCanvasState . setPoseCanvas ( zoomableCanvas ) ; zoomableCanvas . setBackground ( ZOOMABLE_CANVAS_COLOR ) ; northPanel = new JPanel ( ) ; northOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfRightCanvas = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; vertical = new JScrollPane ( southOfRightCanvas ) ; MediaTracker tracker = new MediaTracker ( this ) ; int idCounter = 0 ; fileToolbar = new JToolBar ( ) ; newButton = ( JButton ) initButton ( NEW_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , NEW_TOOLTIP ) ; openButton = ( JButton ) initButton ( OPEN_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , OPEN_TOOLTIP ) ; saveButton = ( JButton ) initButton ( SAVE_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_TOOLTIP ) ; saveAsButton = ( JButton ) initButton ( SAVE_AS_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_AS_TOOLTIP ) ; exportButton = ( JButton ) initButton ( EXPORT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXPORT_TOOLTIP ) ; exitButton = ( JButton ) initButton ( EXIT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXIT_TOOLTIP ) ; editToolbar = new JToolBar ( ) ; selectionButton = ( JButton ) initButton ( SELECTION_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , SELECT_TOOLTIP ) ; cutButton = ( JButton ) initButton ( CUT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , CUT_TOOLTIP ) ; copyButton = ( JButton ) initButton ( COPY_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , COPY_TOOLTIP ) ; pasteButton = ( JButton ) initButton ( PASTE_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , PASTE_TOOLTIP ) ; moveToBackButton = ( JButton ) initButton ( MOVE_TO_BACK_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_BACK_TOOLTIP ) ; moveToFrontButton = ( JButton ) initButton ( MOVE_TO_FRONT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_FRONT_TOOLTIP ) ; shapeToolbar = new JToolBar ( ) ; shapeButtonGroup = new ButtonGroup ( ) ; lineToggleButton = ( JToggleButton ) initButton ( LINE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , LINE_TOOLTIP ) ; rectToggleButton = ( JToggleButton ) initButton ( RECT_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , RECT_TOOLTIP ) ; ellipseToggleButton = ( JToggleButton ) initButton ( ELLIPSE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , ELLIPSE_TOOLTIP ) ; DefaultComboBoxModel lineThicknessModel = new DefaultComboBoxModel ( ) ; for ( int i = 0 ; i < NUM_STROKES_TO_CHOOSE_FROM ; i ++ ) { String imageFileName = STROKE_SELECTION_FILE_PREFIX + ( i + 1 ) + PNG_FILE_EXTENSION ; Image img = batchLoadImage ( imageFileName , tracker , idCounter ++ ) ; ImageIcon ii = new ImageIcon ( img ) ; lineThicknessModel . addElement ( ii ) ; } lineStrokeSelectionComboBox = new JComboBox ( lineThicknessModel ) ; zoomToolbar = new JToolBar ( ) ; zoomOutButton = ( JButton ) initButton ( ZOOM_OUT_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_OUT_TOOLTIP ) ; zoomInButton = ( JButton ) initButton ( ZOOM_IN_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_IN_TOOLTIP ) ; zoomLabel = new JLabel ( ) ; zoomLabel . setFont ( ZOOM_LABEL_FONT ) ; updateZoomLabel ( ) ; dimensionsButton = ( JButton ) initButton ( POSE_DIMENSIONS_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , CHANGE_POSE_DIMENSIONS_TOOLTIP ) ; colorSelectionToolbar = new JToolBar ( ) ; colorButtonGroup = new ButtonGroup ( ) ; outlineColorSelectionButton = ( ColorToggleButton ) initButton ( OUTLINE_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , OUTLINE_TOOLTIP ) ; outlineColorSelectionButton . setBackground ( Color . BLACK ) ; fillColorSelectionButton = ( ColorToggleButton ) initButton ( FILL_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , FILL_TOOLTIP ) ; fillColorSelectionButton . setBackground ( Color . WHITE ) ; outlineColorSelectionButton . setSelected ( true ) ; ColorPalletLoader cpl = new ColorPalletLoader ( ) ; ColorPalletState cps = new ColorPalletState ( ) ; cpl . initColorPallet ( COLOR_PALLET_SETTINGS_XML , cps ) ; colorPallet = new ColorPallet ( cps ) ; cps . setView ( colorPallet ) ; customColorSelectorButton = ( JButton ) initButton ( CUSTOM_COLOR_SELECTOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , JButton . class , null , CUSTOM_COLOR_TOOLTIP ) ; alphaLabel = new JLabel ( ALPHA_LABEL_TEXT ) ; alphaLabel . setFont ( ALPHA_LABEL_FONT ) ; alphaLabel . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider = new JSlider ( JSlider . HORIZONTAL , TRANSPARENT , OPAQUE , OPAQUE ) ; transparencySlider . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider . setMajorTickSpacing ( ALPHA_MAJOR_TICK_SPACING ) ; transparencySlider . setMinorTickSpacing ( ALPHA_MINOR_TICK_SPACING ) ; transparencySlider . setPaintLabels ( true ) ; transparencySlider . setPaintTicks ( true ) ; transparencySlider . setPaintTrack ( true ) ; transparencySlider . setToolTipText ( ALPHA_TOOLTIP ) ; transparencySlider . setSnapToTicks ( false ) ; labelPoses = appWindow . getLabelPoses ( ) ; try { imagePose = ImageIO . read ( new File ( EDITPOSE_IMAGE_FILE ) ) ; System . out . println ( "Image has read" ) ; picLabelPose = new JLabel ( new ImageIcon ( imagePose ) ) ; } catch ( IOException ex ) { System . out . println ( "Did not read Image" ) ; } jtbEdit = new JToolBar ( ) ; idCounter = 0 ; btnNewPose = ( JButton ) initButton ( NEWPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , NEWPOSE_TOOLTIP ) ; btnSavePose = ( JButton ) initButton ( SAVEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , SAVEPOSE_TOOLTIP ) ; btnOpenPose = ( JButton ) initButton ( OPENPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , OPENPOSE_TOOLTIP ) ; btnDeletePose = ( JButton ) initButton ( DELETEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DELETEPOSE_TOOLTIP ) ; btnDuplicatePose = ( JButton ) initButton ( DUPLICATEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DUPLICATEPOSE_TOOLTIP ) ; btnShiftLeftPose = ( JButton ) initButton ( SHIFTLEFT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , LEFTPOSE_TOOLTIP ) ; btnShifRighttPose = ( JButton ) initButton ( SHIFTRIGHT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , RIGHTPOSE_TOOLTIP ) ; btnSetDurationPose = ( JButton ) initButton ( DURATIONPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DURATIONPOSE_TOOLTIP ) ; northOfZoomableCanvasPanel = new JPanel ( ) ; northOfZoomableCanvasPanel . setLayout ( new BorderLayout ( ) ) ; try { if ( ! appWindow . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { this . setDisablePoseButton ( true ) ; } else { setDisablePoseButton ( false ) ; } } catch ( NullPointerException e ) { setDisablePoseButton ( false ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { Logger . getLogger ( PoseurGUI . class . getName ( ) ) . log ( Level . SEVERE , null , ie ) ; } }
te	7	private void populate ( ) { Random rand = Randomizer . getRandom ( ) ; field . clear ( ) ; int Number_of_foxes = 0 ; int Number_of_rabbits = 0 ; int Number_of_korenwolfs = 0 ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { if ( rand . nextDouble ( ) <= KORENWOLF_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Korenwolf korenwolf = new Korenwolf ( true , field , location ) ; actors . add ( korenwolf ) ; Number_of_korenwolfs ++ ; } else if ( rand . nextDouble ( ) <= FOX_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Fox fox = new Fox ( true , field , location ) ; actors . add ( fox ) ; Number_of_foxes ++ ; } else if ( rand . nextDouble ( ) <= RABBIT_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Rabbit rabbit = new Rabbit ( true , field , location ) ; actors . add ( rabbit ) ; Number_of_rabbits ++ ; } else if ( rand . nextDouble ( ) <= HUNTER_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Hunter hunter = new Hunter ( field , location ) ; actors . add ( hunter ) ; } else if ( rand . nextDouble ( ) <= 0.03 ) { Location location = new Location ( row , col ) ; Grass grass = new Grass ( field , location ) ; actors . add ( grass ) ; } } } Rabbit . PERFECT_NUMBER_OF_RABBITS = Number_of_rabbits ; Fox . PERFECT_NUMBER_OF_FOXES = Number_of_foxes ; Korenwolf . PERFECT_NUMBER_OF_KORENWOLFS = Number_of_korenwolfs ; }
te	2	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
te	9X	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
te	1	public boolean offerFirst ( E e ) { if ( contains ( e ) ) { return false ; } linkFirst ( e ) ; return true ; }
te	3	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
te	3	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
te	8	public ByteBuffer getBuffer ( String filePath ) { ByteBuffer buffer = fileMaps . get ( filePath ) ; if ( buffer == null ) { File requestedFile = new File ( filePath ) ; if ( requestedFile != null && requestedFile . exists ( ) ) { FileInputStream fileInput = null ; FileChannel fileChannel = null ; try { fileInput = new FileInputStream ( requestedFile ) ; fileChannel = fileInput . getChannel ( ) ; if ( fileChannel . size ( ) < ( 1024 * 1024 * 10 ) ) { MappedByteBuffer fileBuffer = fileChannel . map ( MapMode . READ_ONLY , 0 , fileChannel . size ( ) ) ; fileBuffer . load ( ) ; this . fileMaps . put ( filePath , fileBuffer ) ; buffer = fileBuffer . asReadOnlyBuffer ( ) ; } else { buffer = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fileInput != null ) { fileInput . close ( ) ; fileInput = null ; } if ( fileChannel != null ) { fileChannel . close ( ) ; fileChannel = null ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return buffer ; }
te	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
te	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
te	8	protected long skipBytes ( long bytes ) throws BasicPlayerException { long totalSkipped = 0 ; if ( m_dataSource instanceof File ) { int previousStatus = m_status ; m_status = SEEKING ; long skipped = 0 ; try { synchronized ( m_audioInputStream ) { notifyEvent ( BasicPlayerEvent . SEEKING , getEncodedStreamPosition ( ) , - 1 , null ) ; initAudioInputStream ( ) ; if ( m_audioInputStream != null ) { while ( totalSkipped < ( bytes - SKIP_INACCURACY_SIZE ) ) { skipped = m_audioInputStream . skip ( bytes - totalSkipped ) ; if ( skipped == 0 ) break ; totalSkipped = totalSkipped + skipped ; if ( totalSkipped == - 1 ) throw new BasicPlayerException ( BasicPlayerException . SKIPNOTSUPPORTED ) ; } } } notifyEvent ( BasicPlayerEvent . SEEKED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_status = OPENED ; if ( previousStatus == PLAYING ) startPlayback ( ) ; else if ( previousStatus == PAUSED ) { startPlayback ( ) ; pausePlayback ( ) ; } } catch ( IOException e ) { throw new BasicPlayerException ( e ) ; } } return totalSkipped ; }
te	6	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
te	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
te	3	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
te	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
te	5	@ Override public int compare ( Course course1 , Course course2 ) { if ( sortOrder == SortOrder . ASCENDING ) { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return - 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return - 1 ; } } }
te	5	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
te	7	@ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { if ( event . isCancelled ( ) ) { return ; } Player player = event . getPlayer ( ) ; if ( preChecks ( player , event . getTo ( ) ) ) { JumpPort port = JumpPorts . getPort ( event . getTo ( ) ) ; if ( checkInstant ( event ) ) { return ; } if ( checkJump ( event ) ) { return ; } if ( checkFall ( event ) ) { return ; } if ( ! ignoredPlayers . contains ( player . getName ( ) ) ) { player . sendMessage ( Lang . get ( "port.triggered" ) . replaceAll ( "%N" , port . getName ( ) ) . replaceAll ( "%D" , port . getDescription ( ) ) ) ; if ( port . getPrice ( ) > 0 ) { player . sendMessage ( Lang . get ( "port.price" ) . replaceAll ( "%P" , "" + port . getPrice ( ) ) ) ; } player . sendMessage ( Lang . get ( "port.triggers" ) ) ; ignoredPlayers . add ( player . getName ( ) ) ; } } }
te	6	public void addPoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
te	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
te	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
te	6	public static Player fromXml ( org . w3c . dom . Node playerRoot , MonteCarloPlayer player ) { NamedNodeMap attrs = playerRoot . getAttributes ( ) ; player . description = "" ; if ( attrs . getNamedItem ( "playout" ) != null ) { try { Field field = PlayoutStrategy . class . getField ( attrs . getNamedItem ( "playout" ) . getNodeValue ( ) ) ; player . playout = ( PlayoutStrategy ) field . get ( null ) ; player . description += String . format ( "playout=%s" , field . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "finalMove" ) != null ) { try { Field field = FinalNodeSelectionStrategy . class . getField ( attrs . getNamedItem ( "finalMove" ) . getNodeValue ( ) ) ; player . finalNode = ( FinalNodeSelectionStrategy ) field . get ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "maxTurnTime" ) != null ) { try { player . MAX_TURN_TIME = long . parseLong ( attrs . getNamedItem ( "maxTurnTime" ) . getNodeValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } player . description = String . format ( "playout=%s final=%s" , player . playout , player . finalNode ) ; return player ; }
te	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
te	3	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
te	1	public MerchantDeal getMerchantDeal ( int merchantDealId ) { MerchantDeal merchantDeal = null ; try { session = mySessionFactory . getCurrentSession ( ) ; merchantDeal = ( MerchantDeal ) session . get ( MerchantDeal . class , merchantDealId ) ; } catch ( Exception e ) { } return merchantDeal ; }
te	9X	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; int [ ] p2 ; int p3 ; double p4 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 5 } ; p3 = 10 ; p4 = 0.5D ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.0D ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 10 } ; p1 = new int [ ] { 10 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.4142135623730951D ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 11 , - 11 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 11 , - 11 } ; p2 = new int [ ] { 10 , 10 , 10 , 10 } ; p3 = 31 ; p4 = 0.3548387096774194D ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 100 } ; p1 = new int [ ] { 100 } ; p2 = new int [ ] { 1 } ; p3 = 10 ; p4 = 1.0D ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 1000000000 } ; p1 = new int [ ] { 1000000000 } ; p2 = new int [ ] { 1000000000 } ; p3 = 1000000000 ; p4 = 0.41421356237309503D ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 20 , - 20 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 20 , - 20 } ; p2 = new int [ ] { 50 , 50 , 50 , 50 } ; p3 = 100 ; p4 = 0.3D ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 , - 60 , - 62 , - 60 , 63 , - 97 } ; p1 = new int [ ] { - 72 , 67 , 61 , - 8 , - 32 , 89 } ; p2 = new int [ ] { 6 , 7 , 8 , 7 , 5 , 6 } ; p3 = 918 ; p4 = 0.9407071068962471D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 187730043 , 932334096 , 59236807 , - 602044448 , 441157147 , 569003535 , 563472630 , 493784941 , - 928345136 , - 198534684 , - 507361726 , - 486699261 , - 705601684 , - 671249417 , - 79879427 , 71698248 , 146683444 , 414416326 , 53196305 , - 666818573 , 178619454 , - 893182413 , 224302710 , 296990194 , - 885921154 , - 173521881 , - 493092068 , 900325848 , - 353242967 , - 631482448 , 112982750 , 553248219 , 264762102 , - 318102799 , - 836641673 , - 812311860 , - 73259832 , 609869565 , 650010687 , 155243096 , - 107417345 , 634247427 , - 841502473 , - 651719520 , - 958664893 , 480384188 , - 691415372 , 36346544 , 706329659 , 126652235 , 44403422 , - 263265167 , - 349491074 , 120258505 , 485027199 , - 240466308 , - 456782932 , 192953958 , - 261803363 , - 198063552 , 980391799 , 997148607 , 417112854 , - 333017353 , - 945493557 , 371446553 , 251150037 , - 960076588 , - 360362805 , - 305175580 , 208353048 , - 437834549 , - 420355623 , - 668454094 , 180494692 , 755143595 , 249998094 , 537726369 , 343336414 , 495586169 , 35446018 , 131243302 , 501744441 , 739753520 , - 876687692 , 560013605 , - 443087342 , 455209428 , 333669368 , 398118304 , - 695213876 , 527566904 , - 463103162 , - 317355625 , 641069703 , - 947785900 , - 532490870 , - 963111776 , - 727898154 , 748858912 } ; p1 = new int [ ] { 452827103 , 247175647 , 11753377 , - 611873763 , - 531081305 , 859586805 , - 868286674 , - 876539858 , 304963335 , 990345765 , - 859353631 , - 475065113 , - 574709927 , 131112520 , - 846074893 , 464742988 , - 41360301 , 899849149 , - 266820064 , - 251052777 , 226747686 , 876712903 , - 350309643 , 131456902 , - 799664596 , 453822371 , - 617483392 , 755895436 , - 72097080 , 199834107 , - 619495741 , - 922106677 , 229012084 , 419002428 , 38711443 , 293733516 , 633211140 , - 65526196 , - 776215532 , - 491310115 , - 23818472 , 792447417 , 726536324 , - 686011537 , - 140383515 , - 569321731 , - 402939093 , - 125768005 , - 18416939 , 127783325 , - 67341991 , - 322587512 , - 296995968 , - 536590267 , 437613161 , - 206640690 , - 825549222 , 102733497 , - 399947312 , 55751657 , 527107031 , - 152726436 , - 821534503 , 267030010 , - 528297582 , - 897079824 , - 521362885 , 1225411 , 460297398 , 596603062 , - 270748768 , 211858545 , - 654848212 , - 353416243 , 955853430 , - 447642704 , 739273996 , - 118039293 , 583896289 , - 253276293 , 632398992 , 560349797 , 222539806 , 677153439 , - 804423594 , - 285780470 , 782032960 , 23986706 , - 812231058 , 344193048 , 491603558 , 956077657 , - 97237599 , - 644202406 , - 311702606 , 645844112 , 47834815 , - 802896183 , 472801824 , 658244534 } ; p2 = new int [ ] { 4 , 7 , 4 , 4 , 5 , 1 , 8 , 4 , 5 , 7 , 8 , 3 , 5 , 5 , 9 , 5 , 8 , 5 , 6 , 7 , 7 , 8 , 10 , 6 , 10 , 6 , 3 , 4 , 5 , 1 , 5 , 8 , 9 , 8 , 2 , 3 , 1 , 9 , 8 , 5 , 8 , 6 , 9 , 2 , 2 , 9 , 9 , 2 , 6 , 4 , 8 , 2 , 4 , 9 , 7 , 5 , 5 , 2 , 1 , 9 , 2 , 5 , 6 , 10 , 4 , 9 , 4 , 4 , 10 , 1 , 10 , 9 , 8 , 10 , 2 , 2 , 9 , 10 , 3 , 4 , 6 , 10 , 5 , 1 , 9 , 3 , 5 , 5 , 4 , 5 , 5 , 5 , 1 , 10 , 6 , 7 , 1 , 1 , 10 , 2 } ; p3 = 1000000000 ; p4 = 0.999999094D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 196 , 450 , 79 , - 220 , - 916 , 991 , - 451 , 462 , - 58 , - 353 , - 500 , 783 , 816 , 511 } ; p1 = new int [ ] { 188 , 681 , - 234 , - 330 , - 14 , 991 , - 969 , 347 , - 458 , - 940 , 454 , - 28 , 767 , - 620 } ; p2 = new int [ ] { 64 , 31 , 60 , 49 , 65 , 100 , 1 , 98 , 33 , 66 , 52 , 45 , 69 , 2 } ; p3 = 1484 ; p4 = 0.22007657635156566D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
te	7	private String [ ] getStringArray ( JComponent comp ) { if ( comp instanceof JComboBox ) { JComboBox comboBox = ( JComboBox ) comp ; List < String > list = new ArrayList < String > ( ) ; if ( comboBox . getItemCount ( ) > 0 ) { for ( int i = 0 ; i < comboBox . getItemCount ( ) ; i ++ ) { if ( ! isEmpty ( comboBox . getItemAt ( i ) ) ) { add ( list , comboBox . getItemAt ( i ) ) ; } else if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toArray ( new String [ 1 ] ) ; } else { return null ; } } else { if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; return list . toArray ( new String [ 1 ] ) ; } } } return null ; }
te	7	@ Override public LinkedList < Individual > crossover ( int [ ] parents , Population pop ) { LinkedList < Individual > children = new LinkedList < Individual > ( ) ; Random r = new Random ( ) ; int r1 = r . nextInt ( parents . length ) ; int r2 = r . nextInt ( parents . length ) ; Individual p1 = pop . people [ parents [ r1 ] ] ; Individual p2 = pop . people [ parents [ r2 ] ] ; int dna1 [ ] [ ] = new int [ 9 ] [ 9 ] ; int dna2 [ ] [ ] = new int [ 9 ] [ 9 ] ; Sudoku parent1 = ( ( Sudoku ) p1 ) ; Sudoku parent2 = ( ( Sudoku ) p2 ) ; for ( int row = 0 ; row < 9 ; row ++ ) { int cut1 = r . nextInt ( 9 ) ; int cut2 = r . nextInt ( 9 ) ; if ( cut2 < cut1 ) { int temp = cut1 ; cut1 = cut2 ; cut2 = temp ; } for ( int col = 0 ; col < 9 ; col ++ ) { if ( col <= cut1 || col >= cut2 ) { dna1 [ row ] [ col ] = parent2 . rows [ row ] [ col ] ; dna2 [ row ] [ col ] = parent1 . rows [ row ] [ col ] ; } else { int a = parent1 . rows [ row ] [ col ] ; if ( ! contains ( a , dna2 [ row ] ) ) dna2 [ row ] [ col ] = a ; int b = parent2 . rows [ row ] [ col ] ; if ( ! contains ( b , dna1 [ row ] ) ) dna1 [ row ] [ col ] = b ; } } } children . add ( new Sudoku ( dna1 ) ) ; children . add ( new Sudoku ( dna2 ) ) ; return children ; }
te	7	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
te	1	protected String [ ] getFontStyleNames ( ) { if ( fontStyleNames == null ) { int i = 0 ; fontStyleNames = new String [ 4 ] ; fontStyleNames [ i ++ ] = ( "Plain" ) ; fontStyleNames [ i ++ ] = ( "Bold" ) ; fontStyleNames [ i ++ ] = ( "Italic" ) ; fontStyleNames [ i ++ ] = ( "BoldItalic" ) ; } return fontStyleNames ; }
te	3	private void initWindow ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . PAGE_AXIS ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; tabbedPanel = new JTabbedPane ( ) ; tabbedPanel . setPreferredSize ( new Dimension ( 500 , 800 ) ) ; connectionTabPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel . setLayout ( new BoxLayout ( userSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; userSettingsPanel . setBorder ( new TitledBorder ( "User Settings" ) ) ; userSettingsV1Panel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; usernameLabel = new JLabel ( "Username:" ) ; usernameText = new JTextField ( UserPreferences . PREF_USERNAME , 6 ) ; apiSecretLabel = new JLabel ( "API Secret:" ) ; apiSecretText = new JPasswordField ( UserPreferences . PREF_API_SECRET , 6 ) ; passwordLabel = new JLabel ( "Password:" ) ; passwordText = new JPasswordField ( UserPreferences . PREF_PASSWORD , 6 ) ; userSettingsV1Panel . add ( usernameLabel ) ; userSettingsV1Panel . add ( usernameText ) ; userSettingsV1Panel . add ( apiSecretLabel ) ; userSettingsV1Panel . add ( apiSecretText ) ; userSettingsV1Panel . add ( passwordLabel ) ; userSettingsV1Panel . add ( passwordText ) ; userTokenPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userTokenPanel . setPreferredSize ( new Dimension ( 443 , 40 ) ) ; userTokenLabel = new JLabel ( "Token:" ) ; userTokenText = new JTextField ( UserPreferences . PREF_USERTOKEN , 10 ) ; userTokenButton = new JButton ( "Get your token" ) ; userTokenButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { GetToken . browse ( ) ; } } ) ; userTokenPanel . add ( userTokenLabel ) ; userTokenPanel . add ( userTokenText ) ; userTokenPanel . add ( userTokenButton ) ; userSettingsPanel . add ( userTokenPanel ) ; proxySettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; proxyUseCheck = new JCheckBox ( "Use Proxy" , UserPreferences . PREF_USE_PROXY ) ; proxyUseCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( proxyUseCheck . isSelected ( ) ) { proxyAddressText . setEnabled ( true ) ; proxyPortText . setEnabled ( true ) ; } else { proxyAddressText . setEnabled ( false ) ; proxyPortText . setEnabled ( false ) ; } } } ) ; proxySettingsPanel . setBorder ( new TitledBorder ( "Proxy Settings" ) ) ; proxyAddressLabel = new JLabel ( "Proxy:" ) ; proxyAddressText = new JTextField ( UserPreferences . PREF_PROXY_ADDRESS , 15 ) ; proxyPortLabel = new JLabel ( "Port:" ) ; proxyPortText = new JTextField ( UserPreferences . PREF_PROXY_PORT , 3 ) ; proxySettingsPanel . add ( proxyUseCheck ) ; proxySettingsPanel . add ( proxyAddressLabel ) ; proxySettingsPanel . add ( proxyAddressText ) ; proxySettingsPanel . add ( proxyPortLabel ) ; proxySettingsPanel . add ( proxyPortText ) ; proxySettingsPanel . setPreferredSize ( new Dimension ( 455 , 60 ) ) ; serverSettingsPanel = new JPanel ( ) ; serverSettingsPanel . setLayout ( new BoxLayout ( serverSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; serverSettingsPanel . setBorder ( new TitledBorder ( "Server Settings" ) ) ; serverCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverCheckIntervalLabel = new JLabel ( "Server check interval (sec):" ) ; serverCheckIntervalText = new JTextField ( String . valueOf ( UserPreferences . PREF_SERVER_CHECK_INTERVAL ) , 3 ) ; autoCleanCheck = new JCheckBox ( "Delete empty folders (keeps account clean)" , UserPreferences . PREF_AUTO_CLEAN ) ; serverCheckPanel . add ( serverCheckIntervalLabel ) ; serverCheckPanel . add ( serverCheckIntervalText ) ; serverCheckPanel . add ( autoCleanCheck ) ; serverSortByPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverSortByLabel = new JLabel ( "Sort by default:" ) ; serverSortByCombo = new JComboBox < String > ( new String [ ] { "Name" , "Date" } ) ; serverSortByCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_SORT_BY ) ; serverSortByPanel . add ( serverSortByLabel ) ; serverSortByPanel . add ( serverSortByCombo ) ; serverFriendPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; loadSharedCheck = new JCheckBox ( "Load friends' files (this could take some time to load)" , UserPreferences . PREF_LOAD_SHARED ) ; serverFriendPanel . add ( loadSharedCheck ) ; serverSettingsPanel . add ( serverCheckPanel ) ; serverSettingsPanel . add ( serverSortByPanel ) ; serverSettingsPanel . add ( serverFriendPanel ) ; serverSettingsPanel . setPreferredSize ( new Dimension ( 455 , 120 ) ) ; connectionTabPanel . add ( userSettingsPanel ) ; connectionTabPanel . add ( proxySettingsPanel ) ; connectionTabPanel . add ( serverSettingsPanel ) ; tabbedPanel . addTab ( "Connection" , null , connectionTabPanel ) ; startupSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoConnectCheck = new JCheckBox ( "Connect on start automatically" , UserPreferences . PREF_AUTO_CONNECT ) ; startInTrayCheck = new JCheckBox ( "Start in system tray" , UserPreferences . PREF_START_IN_TRAY ) ; startupSettingsPanel . setBorder ( new TitledBorder ( "Startup Settings" ) ) ; startupSettingsPanel . add ( autoConnectCheck ) ; startupSettingsPanel . add ( startInTrayCheck ) ; tabbedPanel . addTab ( "Startup" , null , startupSettingsPanel ) ; downloadSettingsPanel = new JPanel ( ) ; downloadSettingsPanel . setLayout ( new BoxLayout ( downloadSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; downloadSettingsPanel . setBorder ( new TitledBorder ( "Download Settings" ) ) ; autoDownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoDownloadCheck = new JCheckBox ( "Download on connect" , UserPreferences . PREF_AUTO_DOWNLOAD ) ; autoDownloadPanel . add ( autoDownloadCheck ) ; downloadTargetPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadTargetLabel = new JLabel ( "Target:" ) ; downloadTargetText = new JTextField ( UserPreferences . PREF_DOWNLOAD_TARGET , 20 ) ; downloadTargetText . setEditable ( false ) ; fileChooserButton = new JButton ( "Browse" ) ; fileChooserButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( fileChooser . showOpenDialog ( preferencesScreen ) == JFileChooser . APPROVE_OPTION ) { downloadTargetText . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; fileChooser = new JFileChooser ( downloadTargetText . getText ( ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileChooser . setDialogTitle ( "Select download directory" ) ; fileChooser . setAcceptAllFileFilterUsed ( false ) ; downloadTargetPanel . add ( downloadTargetLabel ) ; downloadTargetPanel . add ( downloadTargetText ) ; downloadTargetPanel . add ( fileChooserButton ) ; downloadWhatPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadWhatLabel = new JLabel ( "Download:" ) ; everythingRadio = new JRadioButton ( "everything" ) ; selFoldersRadio = new JRadioButton ( "selected folders" ) ; selFoldersRadio . setToolTipText ( "Right clic folder -> Add to automatic download" ) ; downloadWhatGroup = new ButtonGroup ( ) ; downloadWhatGroup . add ( everythingRadio ) ; downloadWhatGroup . add ( selFoldersRadio ) ; downloadWhatPanel . add ( downloadWhatLabel ) ; downloadWhatPanel . add ( everythingRadio ) ; downloadWhatPanel . add ( selFoldersRadio ) ; downloadPartsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; maxParallelDownloadsLabel = new JLabel ( "Max parallel downloads:" ) ; maxParallelDownloadsText = new JTextField ( String . valueOf ( UserPreferences . PREF_MAX_DOWNLOADS ) , 2 ) ; downloadPartsLabel = new JLabel ( "Parts for each download:" ) ; downloadPartsText = new JTextField ( String . valueOf ( UserPreferences . PREF_DOWNLOAD_PART_COUNT ) , 2 ) ; downloadPartsPanel . add ( maxParallelDownloadsLabel ) ; downloadPartsPanel . add ( maxParallelDownloadsText ) ; downloadPartsPanel . add ( downloadPartsLabel ) ; downloadPartsPanel . add ( downloadPartsText ) ; fileSizeCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; fileSizeCheckCheck = new JCheckBox ( "Skip download if size of the file is smaller than (MB):" , UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeCheckCheck . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeDeleteCheck . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; } } ) ; fileSizeCheckText = new JTextField ( String . valueOf ( UserPreferences . PREF_FILE_SIZE_FOR_CHECK ) , 4 ) ; fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeCheckPanel . add ( fileSizeCheckCheck ) ; fileSizeCheckPanel . add ( fileSizeCheckText ) ; fileSizeDeletePanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; fileSizeDeleteCheck = new JCheckBox ( "Also delete it from server automatically" , UserPreferences . PREF_FILE_SIZE_DELETE ) ; fileSizeDeleteCheck . setEnabled ( UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeDeletePanel . add ( fileSizeDeleteCheck ) ; downloadSettingsPanel . add ( autoDownloadPanel ) ; downloadSettingsPanel . add ( downloadTargetPanel ) ; downloadSettingsPanel . add ( downloadWhatPanel ) ; downloadSettingsPanel . add ( downloadPartsPanel ) ; downloadSettingsPanel . add ( fileSizeCheckPanel ) ; downloadSettingsPanel . add ( fileSizeDeletePanel ) ; tabbedPanel . addTab ( "Download" , null , downloadSettingsPanel ) ; conflictSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; conflictSettingsPanel . setBorder ( new TitledBorder ( "Conflict Settings" ) ) ; redownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; redownloadCheck = new JCheckBox ( "Do not ask if file already downloaded. Apply following: " , UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { redownloadCombo . setEnabled ( redownloadCheck . isSelected ( ) ) ; } } ) ; redownloadCombo = new JComboBox < String > ( new String [ ] { "Download again" , "Skip" , "Skip and delete" } ) ; redownloadCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_DOWNLOAD_AGAIN ) ; redownloadCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadPanel . add ( redownloadCheck ) ; redownloadPanel . add ( redownloadCombo ) ; overwritePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCheck = new JCheckBox ( "Do not ask if file already exits on disc. Apply following: " , UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwriteCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { overwriteCombo . setEnabled ( overwriteCheck . isSelected ( ) ) ; } } ) ; overwriteComboPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCombo = new JComboBox < String > ( new String [ ] { "Overwrite" , "Skip" , "Skip and delete from server" , "Skip in case of same size" , "Skip in case of same size and delete from server" } ) ; overwriteCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_OVERWRITE ) ; overwriteCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwritePanel . add ( overwriteCheck ) ; overwriteComboPanel . add ( overwriteCombo ) ; conflictSettingsPanel . add ( redownloadPanel ) ; conflictSettingsPanel . add ( overwritePanel ) ; conflictSettingsPanel . add ( overwriteComboPanel ) ; tabbedPanel . addTab ( "Conflict" , null , conflictSettingsPanel ) ; buttonsPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; saveAndCloseButton = new JButton ( "Save & Close" ) ; saveAndCloseButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( saveSettings ( ) ) { preferencesScreen . setVisible ( false ) ; } } } ) ; closeButton = new JButton ( "Close" ) ; closeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { preferencesScreen . setVisible ( false ) ; } } ) ; buttonsPanel . add ( saveAndCloseButton ) ; buttonsPanel . add ( closeButton ) ; contentPanel . add ( tabbedPanel ) ; contentPanel . add ( buttonsPanel ) ; this . getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; this . setTitle ( "Preferences" ) ; this . setSize ( new Dimension ( 490 , 370 ) ) ; this . setResizable ( false ) ; }
te	9X	public final ExpressaoContext expressao ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; ExpressaoContext _localctx = new ExpressaoContext ( _ctx , _parentState , _p ) ; ExpressaoContext _prevctx = _localctx ; int _startState = 6 ; enterRecursionRule ( _localctx , RULE_expressao ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 54 ) ; switch ( _input . LA ( 1 ) ) { case int : { _localctx = new InteiroContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 47 ) ; match ( int ) ; } break ; case 16 : { _localctx = new LeiaContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 48 ) ; match ( 16 ) ; } break ; case ID : { _localctx = new IdContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 49 ) ; match ( ID ) ; } break ; case 10 : { _localctx = new ExpParContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 50 ) ; match ( 10 ) ; setState ( 51 ) ; expressao ( 0 ) ; setState ( 52 ) ; match ( 2 ) ; } break ; default : throw new NoViableAltException ( this ) ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 67 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 65 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 3 , _ctx ) ) { case 1 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 56 ) ; if ( ! ( 4 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "4 >= $_p" ) ; setState ( 57 ) ; match ( 7 ) ; setState ( 58 ) ; expressao ( 5 ) ; } break ; case 2 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 59 ) ; if ( ! ( 3 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "3 >= $_p" ) ; setState ( 60 ) ; match ( 6 ) ; setState ( 61 ) ; expressao ( 4 ) ; } break ; case 3 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 62 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 63 ) ; match ( 8 ) ; setState ( 64 ) ; expressao ( 3 ) ; } break ; } } } setState ( 69 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
te	9X	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
te	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
te	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
