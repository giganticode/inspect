tr	5	public void sortDyes ( ) { Vector < DyeParent > newDyes = new Vector < DyeParent > ( ) ; Vector < DyeParent > newLakks = new Vector < DyeParent > ( ) ; Vector < DyeParent > newMetals = new Vector < DyeParent > ( ) ; Vector < DyeParent > newFluos = new Vector < DyeParent > ( ) ; for ( int i = 0 ; i < PPC . calcObj . getAllDyeTypes ( ) . size ( ) ; i ++ ) { if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Dye . class ) { newDyes . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Lakk . class ) { newLakks . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Metal . class ) { newMetals . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } else if ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) . getClass ( ) == Fluo . class ) { newFluos . addElement ( PPC . calcObj . getAllDyeTypes ( ) . get ( i ) ) ; } } PPC . calcObj . getAllDyeTypes ( ) . removeAllElements ( ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newDyes ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newLakks ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newMetals ) ; PPC . calcObj . getAllDyeTypes ( ) . addAll ( newFluos ) ; }
tr	0	public AcademyFacadeDB ( ) { emf = Persistence . createEntityManagerFactory ( "ServerSidePU" ) ; em = emf . createEntityManager ( ) ; addToDatabase ( ) ; }
tr	3	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	2	private DefaultConstructorFactory getDefaultConstructorFactory ( ) { lock . lock ( ) ; try { DefaultConstructorFactory factory = null ; try { factory = new SunDefaultConstructorFactory ( ) ; } catch ( Exception e ) { } if ( factory == null ) factory = new NoDefaultConstructorFactory ( ) ; return factory ; } finally { lock . unlock ( ) ; } }
tr	7	protected boolean checkFaceConvexity ( Face face , double tol , PrintStream ps ) { double dist ; HalfEdge he = face . he0 ; do { face . checkConsistency ( ) ; dist = oppFaceDistance ( he ) ; if ( dist > tol ) { if ( ps != null ) { ps . println ( "Edge " + he . getVertexString ( ) + " non-convex by " + dist ) ; } return false ; } dist = oppFaceDistance ( he . opposite ) ; if ( dist > tol ) { if ( ps != null ) { ps . println ( "Opposite edge " + he . opposite . getVertexString ( ) + " non-convex by " + dist ) ; } return false ; } if ( he . next . oppositeFace ( ) == he . oppositeFace ( ) ) { if ( ps != null ) { ps . println ( "Redundant vertex " + he . head ( ) . index + " in face " + face . getVertexString ( ) ) ; } return false ; } he = he . next ; } while ( he != face . he0 ) ; return true ; }
tr	2	@ Override public void repaint ( ) { super . repaint ( ) ; if ( panels != null ) { for ( PanelMonitor panel : panels ) { panel . repaint ( ) ; } } }
tr	4	public static boolean checkBSTInOrderTraversal ( Node root ) { if ( root == null ) { return true ; } if ( ! checkBSTInOrderTraversal ( root . left ) ) { return false ; } if ( root . value < min ) { return false ; } min = root . value ; if ( ! checkBSTInOrderTraversal ( root . right ) ) { return false ; } return true ; }
tr	0	BeforePollingCycleEvent ( DirectoryPoller dp ) { super ( dp ) ; }
tr	0	public void addSpecialEntity ( String identifier , String entity ) { specialEntities . put ( entity . toLowerCase ( ) , identifier ) ; }
tr	5	@ Override public void enter ( BlockNode block , Deque < BlockNode > stack ) { ChangeNode previous = null ; Iterator < Node > nodes = block . - . iterator ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . next ( ) ; if ( n instanceof ChangeNode ) { ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) { previous = null ; continue ; } if ( previous != null && cn . type == previous . type ) { previous . change += cn . change ; nodes . remove ( ) ; } else { previous = cn ; } } else { previous = null ; } } }
tr	0	public int amount ( ) { return this . amount ; }
tr	4	private void refilter ( ) { filteredList . clear ( ) ; for ( PasswordEntry entry : group . getListEntry ( ) ) { if ( compare ( entry . getURL ( ) ) || compare ( entry . getTitle ( ) ) || compare ( entry . getNotes ( ) ) ) { filteredList . add ( entry ) ; } } }
tr	5	public static List < LineItem > transformLineItems ( Detail d ) { List < LineItem > items = d . getLineItem ( ) ; List < LineItem > aggrItems = new ArrayList < LineItem > ( ) ; for ( LineItem l : items ) { boolean duplicate = false ; if ( ! aggrItems . isEmpty ( ) ) { for ( int i = 0 ; i < aggrItems . size ( ) ; i ++ ) { LineItem curr = aggrItems . get ( i ) ; if ( curr . getItemCode ( ) . equals ( l . getItemCode ( ) ) ) { long quantity = curr . getQuantity ( ) . intValue ( ) ; quantity ++ ; curr . setQuantity ( BigDecimal . valueOf ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggrItems . add ( l ) ; } } return aggrItems ; }
tr	1	private static char [ ] reverse ( char [ ] a , int len ) { char [ ] b = new char [ len ] ; for ( int i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { b [ j ] = a [ i ] ; } return b ; }
tr	7	public void onEnable ( ) { Server = getServer ( ) ; log = Server . getLogger ( ) ; setPdfFile ( this . getDescription ( ) ) ; moveFiles ( ) ; setupPermissions ( ) ; questPlayerStorage = new iProperty ( "plugins/uQuest/uQuest_Players.txt" ) ; if ( new File ( "plugins/uQuest/uQuest_Quests.txt" ) . exists ( ) ) new QuestConverter ( ) ; if ( isUseDefaultUQuest ( ) ) { Cmd_uquest cmd_uquest = new Cmd_uquest ( this ) ; getCommand ( "uquest" ) . setExecutor ( cmd_uquest ) ; getCommand ( "quest" ) . setExecutor ( cmd_uquest ) ; try { getCommand ( "q" ) . setExecutor ( cmd_uquest ) ; } catch ( NullPointerException npe ) { useDefaultHelp = false ; } } setupEconomy ( ) ; Cmd_reloadquests cmd_reloadquests = new Cmd_reloadquests ( this ) ; getCommand ( "reloadquests" ) . setExecutor ( cmd_reloadquests ) ; Cmd_reloadquestconfig cmd_reloadquestconfig = new Cmd_reloadquestconfig ( this ) ; getCommand ( "reloadquestconfig" ) . setExecutor ( cmd_reloadquestconfig ) ; readConfig ( ) ; theQuestsLoadAllIntoArray ( ) ; if ( this . theQuests . isEmpty ( ) ) { System . err . println ( "\n\n\n" + pluginNameBracket ( ) + " You have an empty quest list!\n Disabling plugin.\n\n\n" ) ; Server . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( isUseSQLite ( ) == true ) { this . setDB ( new SqLiteKeyValStor < Quester > ( "questers" , "plugins/uQuest/uQuestQuesters" ) ) ; System . out . println ( pluginNameBracket ( ) + " Loaded with SQLite!" ) ; } if ( firstLoad == true && isUseSQLite ( ) == false ) { timerSavePlayers ( ) ; firstLoad = false ; System . out . println ( pluginNameBracket ( ) + " Loaded with Flatfile!" ) ; } registerEvents ( ) ; System . out . println ( pluginNameBracket ( ) + " v" + getPdfFile ( ) . getVersion ( ) + " enabled! With " + this . getQuestInteraction ( ) . getQuestTotal ( ) + " quests loaded!" ) ; }
tr	1	public Options < T > exclude ( String ... attributes ) { for ( String attribute : attributes ) { this . attributes . remove ( attribute ) ; } return this ; }
tr	2	private byte [ ] toBytes ( int v , int length ) { assert length % 4 == 0 ; assert length > 0 ; byte [ ] result = new byte [ length ] ; result [ 0 ] = ( byte ) ( v & FF ) ; result [ 1 ] = ( byte ) ( v >>> 8 & FF ) ; result [ 2 ] = ( byte ) ( v >>> 16 & FF ) ; result [ 3 ] = ( byte ) ( v >>> 24 & FF ) ; for ( int i = 4 ; i < length ; ) { int copyLength = i <= length / 2 ? i : length - i ; System . arraycopy ( result , 0 , result , i , copyLength ) ; i += copyLength ; } return result ; }
tr	8	public MDPData ( int numOfStates , int numOfActions , double [ ] rewards , double [ ] [ ] transitionArr , int [ ] numOfActionsOnEachState , double gamma ) { this . noOfActions = numOfActions ; this . noOfStates = numOfStates ; this . gamma = gamma ; HashMap < Integer , ArrayList < double >> tempTransitionMap = new HashMap < Integer , ArrayList < double >> ( ) ; ArrayList < double > temp ; for ( int i = 0 ; i < noOfActions ; i ++ ) { temp = new ArrayList < double > ( ) ; for ( int j = 0 ; j < noOfStates ; j ++ ) { temp . add ( transitionArr [ i ] [ j ] ) ; } tempTransitionMap . put ( i , temp ) ; } stateList = new ArrayList < StateData > ( ) ; StateData sd ; int actionCounter = 0 ; for ( int i = 0 ; i < getNoOfStates ( ) ; i ++ ) { sd = new StateData ( ) ; sd . setNoOfActions ( numOfActionsOnEachState [ i ] ) ; ActionData ad = null ; ArrayList < ActionData > actionList = new ArrayList < ActionData > ( ) ; for ( int j = 0 ; j < numOfActionsOnEachState [ i ] ; j ++ ) { ad = new ActionData ( numOfActionsOnEachState [ i ] ) ; ad . setReward ( rewards [ actionCounter ] ) ; ad . setTransitionFunc ( tempTransitionMap . get ( actionCounter ) ) ; actionList . add ( j , ad ) ; actionCounter ++ ; } sd . setActionList ( actionList ) ; stateList . add ( i , sd ) ; } state_action_mapping = new int [ getNoOfStates ( ) ] [ getNoOfActions ( ) ] ; int upto = 0 ; for ( int index = 0 ; index < getNoOfStates ( ) ; index ++ ) { int action = numOfActionsOnEachState [ index ] ; for ( int jndex = 0 ; jndex < getNoOfActions ( ) ; jndex ++ ) { if ( jndex >= upto && jndex < ( upto + action ) ) { state_action_mapping [ index ] [ jndex ] = 1 ; } } upto = upto + action ; } transitionMatrix = transitionArr ; init ( ) ; }
tr	1	@ Test public void acceptedTestAStar ( ) { Automaton a = new RegExp ( "a*" ) . toAutomaton ( ) ; String [ ] expected = { "" , "a" , "aa" , "aaa" , "aaaa" , "aaaaa" , "aaaaaa" , "aaaaaaa" , "aaaaaaaa" , "aaaaaaaaa" } ; int i = 0 ; for ( String s : AutomatonHelper . accepted ( a , 10 ) ) { assertEquals ( expected [ i ++ ] , s ) ; } }
tr	6	public T [ ] quicksort ( T [ ] array , int low , int high ) { int i = low ; int j = high ; T pivot = array [ low + ( high - low ) / 2 ] ; while ( i < j ) { while ( array [ i ] . compareTo ( pivot ) < 0 ) { i ++ ; } while ( array [ j ] . compareTo ( pivot ) > 0 ) { j -- ; } if ( i <= j ) { swap ( array , i , j ) ; i ++ ; j -- ; } } if ( low < j ) { quicksort ( array , low , j ) ; } if ( i < high ) { quicksort ( array , i , high ) ; } return array ; }
tr	9	public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setStroke ( new BasicStroke ( 6 ) ) ; BufferedImage bimg = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2img = ( Graphics2D ) bimg . getGraphics ( ) ; g2img . setColor ( Color . black ) ; g2img . fillRect ( 0 , 0 , bimg . getWidth ( ) , bimg . getHeight ( ) ) ; HexMech . setCorner ( corner ) ; for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( i , j , g2img ) ; } } if ( corner . x > 0 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x - 1 , j , g2img ) ; } } if ( corner . y > 0 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y - 1 , g2img ) ; } } if ( corner . x < LocationManager . getSize ( ) . x - 15 ) { for ( int j = corner . y ; j < corner . y + 10 ; j ++ ) { HexMech . drawHex ( corner . x + 15 , j , g2img ) ; } } if ( corner . y < LocationManager . getSize ( ) . y - 10 ) { for ( int i = corner . x ; i < corner . x + 15 ; i ++ ) { HexMech . drawHex ( i , corner . y + 10 , g2img ) ; } } for ( Point p : selectLocs ) { HexMech . selectHex ( p . x , p . y , g2img ) ; } HexMech . cursor ( cursorLoc . x , cursorLoc . y , g2img ) ; g2 . drawImage ( bimg , 0 , 0 , null ) ; }
tr	3	static Header fromString ( String stringHeader ) throws MalformedRequestException { String [ ] parts = stringHeader . split ( ": " ) ; if ( parts . length != 2 ) { throw new MalformedRequestException ( "unknown format of Header [" + stringHeader + "]" ) ; } for ( HTTPHeader m : HTTPHeader . values ( ) ) { if ( stringHeader . startsWith ( m . headerText ) ) { return new Header ( m , parts [ 1 ] ) ; } } return new Header ( HTTPHeader . UnknownHeader , parts [ 1 ] ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; IdentNode other = ( IdentNode ) obj ; if ( identName == null ) { if ( other . identName != null ) return false ; } else if ( ! identName . equals ( other . identName ) ) return false ; return true ; }
tr	6	public static Pattern times ( Pattern pattern , int n , boolean grammar ) { if ( n <= 0 ) throw new IllegalArgumentException ( "n <= 0" ) ; if ( n == 1 ) return pattern ; if ( ! grammar ) { if ( pattern . root . isNullable ( ) ) throw new IllegalArgumentException ( "Loop body may accept the empty string" ) ; SeqNode seqNode = new SeqNode ( pattern . root . copy ( ) , pattern . root . copy ( ) ) ; while ( n -- > 2 ) seqNode = new SeqNode ( pattern . root . copy ( ) , seqNode ) ; return new Pattern ( seqNode , pattern . refs ) ; } Pattern ref = ref ( "p" ) ; Pattern refs = seq ( ref , ref ) ; for ( int i = 2 ; i < n ; ++ i ) refs = seq ( refs , ref ) ; return grammar ( new Rule ( "c" , refs ) , new Rule ( "p" , pattern ) ) ; }
tr	7	private FeatureVector getdV2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dV2 = new FeatureVector ( M2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , - . ) ; } } } } return dV2 ; }
tr	2	public String join ( String separator ) throws JSONException { int len = length ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i += 1 ) { if ( i > 0 ) { sb . append ( separator ) ; } sb . append ( JSONObject . valueToString ( this . myArrayList . get ( i ) ) ) ; } return sb . toString ( ) ; }
tr	7	@ Override public boolean handleInputDown ( Vector3 pos ) { for ( ObjectController oc : controllers ) if ( oc . handleInputDown ( pos ) ) return true ; if ( shipsLocked ) return false ; if ( weaponDescription != null ) { ( ( UserInterfaceController ) weaponDescription . getController ( ) ) . executeCommand ( ) ; } for ( ObjectController oc : controllers ) { if ( oc instanceof ShipController ) { oc . deSelect ( ) ; System . out . println ( "Clicked at " + pos . toString ( ) + " Ship at " + oc . pollBounds ( ) . toString ( ) ) ; if ( oc . pollBounds ( ) . contains ( pos . x , pos . y ) ) { oc . select ( ) ; activeController = ( ShipController ) oc ; return true ; } } } return false ; }
tr	1	@ Test public void testAsync_resolve ( ) throws Exception { when . resolve ( 1 ) . < Integer > then ( ( x ) -> { assertEquals ( 1 , x . intValue ( ) ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } return null ; } ) . then ( done . onFulfilled , done . onRejected ) . ensure ( latch COLCOL countDown ) ; assertFalse ( done . fulfilled ( ) ) ; latch . await ( ) ; done . assertFulfilled ( ) ; }
tr	8	public static void main ( String [ ] args ) throws IOException , InterruptedException { File testDir = new File ( System . getProperty ( "java.class.path" ) + "/../tests/pa3_tests" ) ; int failures = 0 ; for ( File x : testDir . listFiles ( ) ) { if ( x . getName ( ) . endsWith ( "out" ) || x . getName ( ) . startsWith ( "." ) || x . getName ( ) . endsWith ( "mJAM" ) || x . getName ( ) . endsWith ( "asm" ) ) continue ; int returnCode = runTest ( x ) ; if ( x . getName ( ) . indexOf ( "pass" ) != - 1 ) { if ( returnCode == 0 ) { System . out . println ( x . getName ( ) + " processed successfully!" ) ; } else { failures ++ ; System . err . println ( x . getName ( ) + " failed to be processed!" ) ; } } else { if ( returnCode == 4 ) System . out . println ( x . getName ( ) + " failed successfully!" ) ; else { System . err . println ( x . getName ( ) + " did not fail properly!" ) ; failures ++ ; } } } System . out . println ( failures + " failures in all." ) ; }
tr	8	private static boolean isValidShuffleRecursiveDynamicProgramming ( String str1 , String str2 , String str3 , int i , int j , int k , Set < Triplet > cache ) { if ( cache . contains ( new Triplet ( i , j , k ) ) ) { return false ; } if ( k == str3 . length ( ) ) { return true ; } char c = str3 . charAt ( k ) ; if ( i < str1 . length ( ) && str1 . charAt ( i ) == c && isValidShuffleRecursiveDynamicProgramming ( str1 , str2 , str3 , i + 1 , j , k + 1 , cache ) ) { return true ; } if ( j < str1 . length ( ) && str2 . charAt ( j ) == c && isValidShuffleRecursiveDynamicProgramming ( str1 , str2 , str3 , i , j + 1 , k + 1 , cache ) ) { return true ; } cache . add ( new Triplet ( i , j , k ) ) ; return false ; }
tr	8	private void setCheckboxes ( int right , JCheckBox cr , JCheckBox cw , JCheckBox cx ) { switch ( right ) { case 0 : cx . setSelected ( false ) ; cw . setSelected ( false ) ; cr . setSelected ( false ) ; break ; case 1 : cx . setSelected ( true ) ; cw . setSelected ( false ) ; cr . setSelected ( false ) ; break ; case 2 : cx . setSelected ( false ) ; cw . setSelected ( true ) ; cr . setSelected ( false ) ; break ; case 3 : cx . setSelected ( true ) ; cw . setSelected ( true ) ; cr . setSelected ( false ) ; break ; case 4 : cx . setSelected ( false ) ; cw . setSelected ( false ) ; cr . setSelected ( true ) ; break ; case 5 : cx . setSelected ( true ) ; cw . setSelected ( false ) ; cr . setSelected ( true ) ; break ; case 6 : cx . setSelected ( false ) ; cw . setSelected ( true ) ; cr . setSelected ( true ) ; break ; case 7 : cx . setSelected ( true ) ; cw . setSelected ( true ) ; cr . setSelected ( true ) ; break ; } }
tr	9	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
tr	6	private void parsePacket ( String in ) { String [ ] parts ; String [ ] fields ; String name ; readFields . clear ( ) ; parts = in . split ( ":" , 2 ) ; if ( parts . length != 2 ) return ; if ( parts [ 0 ] . length ( ) == 0 ) return ; name = parts [ 0 ] . trim ( ) ; fields = parts [ 1 ] . split ( " " ) ; for ( String attr : fields ) { String [ ] attrParts ; attrParts = attr . split ( "=" ) ; if ( attrParts . length != 2 ) continue ; if ( attrParts [ 0 ] . length ( ) == 0 || attrParts [ 1 ] . length ( ) == 0 ) continue ; readFields . put ( attrParts [ 0 ] , attrParts [ 1 ] ) ; } decode ( name , readFields ) ; }
tr	8	public static String sendGet ( String url , HashMap < String , String > propertyMap ) { InputStreamReader inr = null ; try { System . out . println ( "get>>>" + url ) ; URL serverUrl = new URL ( url ) ; HttpURLConnection conn = ( HttpURLConnection ) serverUrl . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; conn . setDoOutput ( true ) ; if ( propertyMap != null ) { Set < String > keys = propertyMap . keySet ( ) ; Iterator < String > iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { String key = iterator . next ( ) ; conn . addRequestProperty ( key , propertyMap . get ( key ) ) ; } } conn . addRequestProperty ( "Cookie" , getCookie ( ) ) ; conn . addRequestProperty ( "Accept-Charset" , "UTF-8;" ) ; conn . addRequestProperty ( "User-Agent" , "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) AppleWebKit/537.36 (KHTML  like Gecko) Chrome/36.0.1985.125 Safari/537.36" ) ; HttpURLConnection . setFollowRedirects ( false ) ; conn . connect ( ) ; if ( conn . getHeaderFields ( ) . get ( "Set-Cookie" ) != null ) { for ( String s : conn . getHeaderFields ( ) . get ( "Set-Cookie" ) ) { addCookie ( new BotCookie ( s ) ) ; } } InputStream ins = conn . getInputStream ( ) ; inr = new InputStreamReader ( ins , "UTF-8" ) ; BufferedReader bfr = new BufferedReader ( inr ) ; String line = "" ; StringBuffer res = new StringBuffer ( ) ; do { res . append ( line ) ; line = bfr . readLine ( ) ; } while ( line != null ) ; return res . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } finally { if ( inr != null ) { try { inr . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { inr = null ; } } } }
tr	9	public void helper ( String s , int count ) { if ( count == 3 ) { if ( s . charAt ( 0 ) == 0 && s . length ( ) > 1 ) return ; if ( s . length ( ) > 3 ) { int hh = 0 ; while ( s . length ( ) - hh > 3 ) { if ( s . charAt ( hh ) != 0 ) return ; hh ++ ; } } if ( Integer . parseInt ( s ) > 255 ) return ; else { temp . add ( s ) ; String ss = "" ; for ( int i = 0 ; i < 4 ; i ++ ) { ss = ss + "." + temp . get ( i ) ; } ss = ss . substring ( 1 ) ; ret . add ( ss ) ; temp . remove ( temp . size ( ) - 1 ) ; } } else { for ( int i = 0 ; i < s . length ( ) - 3 + count ; i ++ ) { if ( Integer . parseInt ( s . substring ( 0 , i + 1 ) ) > 255 ) break ; temp . add ( s . substring ( 0 , i + 1 ) ) ; helper ( s . substring ( i + 1 , s . length ( ) ) , count + 1 ) ; temp . remove ( temp . size ( ) - 1 ) ; if ( s . charAt ( 0 ) == 0 ) break ; } } }
tr	9	public float scaledMinkowskiDistanceFrom ( Point p , Integer norm , float scale ) throws GeometryException { if ( this . dimensions <= 3 ) return this . minkowskiDistanceFrom ( p , norm ) ; if ( norm <= 0 ) throw new GeometryException ( "p must be positive in p-norm distance" ) ; if ( p == null ) throw new GeometryException ( "Point to count distance to was null" ) ; if ( scale == null ) throw new GeometryException ( "Null scale factor for dimensions > 3" ) ; if ( scale < 0.0f ) throw new GeometryException ( "Scaling factor can't be negative" ) ; if ( p . getDimensions ( ) != this . dimensions ) throw new GeometryException ( "Point dimensions not matching" ) ; float sum = 0.0f ; for ( int i = 0 ; i < ( ( this . dimensions > 3 ) ? 3 : this . dimensions ) ; i ++ ) sum += new float ( ( ( i < 3 ) ? 1.0f : scale ) * Math . pow ( Math . abs ( p . getCoords ( ) [ i ] . doubleValue ( ) - this . coords [ i ] . doubleValue ( ) ) , norm ) ) ; return new float ( Math . pow ( sum , 1.0f / norm ) ) ; }
tr	6	private static void Merge ( int [ ] data , int left , int center , int right ) { int [ ] tmpArr = new int [ data . length ] ; int mid = center + 1 ; int index = left ; int tmp = left ; while ( left <= center && mid <= right ) { if ( data [ left ] <= data [ mid ] ) { tmpArr [ index ++ ] = data [ left ++ ] ; } else { tmpArr [ index ++ ] = data [ mid ++ ] ; } } while ( mid <= right ) { tmpArr [ index ++ ] = data [ mid ++ ] ; } while ( left <= center ) { tmpArr [ index ++ ] = data [ left ++ ] ; } while ( tmp <= right ) { data [ tmp ] = tmpArr [ tmp ++ ] ; } }
tr	8	@ SuppressWarnings ( { "unchecked" } ) public static < J , K , V > Map < J , Map < K , V >> generateComplexMap ( class < J > jType , class < K > keyType , class < V > valueType ) { Random random = new Random ( 987654321 ) ; Map < J , Map < K , V >> complexMap = new HashMap < J , Map < K , V >> ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { J family = null ; if ( jType == String . class ) { family = ( J ) String . valueOf ( random . nextInt ( ) ) ; } else if ( jType == Integer . class ) { family = ( J ) Integer . valueOf ( random . nextInt ( ) ) ; } else if ( jType == long . class ) { family = ( J ) long . valueOf ( random . nextLong ( ) ) ; } else if ( jType == double . class ) { family = ( J ) double . valueOf ( random . nextDouble ( ) ) ; } else if ( jType == byte [ ] . class ) { byte [ ] bytes = Bytes . toBytes ( random . nextInt ( ) ) ; family = ( J ) bytes ; } else if ( jType == float . class ) { family = ( J ) float . valueOf ( random . nextFloat ( ) ) ; } else if ( jType == boolean . class ) { family = ( J ) boolean . valueOf ( random . nextBoolean ( ) ) ; } Map < K , V > map = generateMapField ( keyType , valueType ) ; complexMap . put ( family , map ) ; } return complexMap ; }
tr	8	private void setCharacterValue ( StringBuilder aCharacters ) throws SAXException { if ( "published" . equals ( currentElement ) ) { try { tweet . setPublished ( dateFormat . parse ( aCharacters . toString ( ) ) ) ; } catch ( ParseException anExc ) { throw new SAXException ( anExc ) ; } } else if ( ( "title" . equals ( currentElement ) ) && ( tweet != null ) ) { tweet . setTitle ( aCharacters . toString ( ) ) ; } else if ( "content" . equals ( currentElement ) ) { content . setValue ( aCharacters . toString ( ) ) ; } else if ( "twitter:lang" . equals ( currentElement ) ) { tweet . setLanguage ( aCharacters . toString ( ) ) ; } else if ( "name" . equals ( currentElement ) ) { author . setName ( aCharacters . toString ( ) ) ; } else if ( "uri" . equals ( currentElement ) ) { author . setUri ( aCharacters . toString ( ) ) ; } }
tr	4	private boolean r_e_ending ( ) { int v_1 ; B_e_found = false ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "e" ) ) ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } v_1 = limit - cursor ; if ( ! ( out_grouping_b ( g_v , 97 , 232 ) ) ) { return false ; } cursor = limit - v_1 ; slice_del ( ) ; B_e_found = true ; if ( ! r_undouble ( ) ) { return false ; } return true ; }
tr	9	public Card [ ] pickCards ( SelectCardOptions sco , Card [ ] allcards ) { GameQuery p = new GameQuery ( QueryType . GETCARD , QueryType . CARD ) . setObject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . CARD ) return null ; if ( p . o instanceof Card [ ] || p . o instanceof String [ ] ) { String [ ] selected ; if ( p . o instanceof Card [ ] ) { ArrayList < String > a = new ArrayList < String > ( ) ; for ( Card c : ( Card [ ] ) p . o ) a . add ( c . getName ( ) ) ; selected = a . toArray ( new String [ 0 ] ) ; } else selected = ( String [ ] ) p . o ; ArrayList < Card > ret = new ArrayList < Card > ( ) ; ArrayList < Card > all = new ArrayList < Card > ( Arrays . asList ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toArray ( new Card [ 0 ] ) ; } return null ; }
tr	9	private static void horizLeftRight ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int row = 0 ; row < 6 ; row ++ ) { for ( int col = 0 ; col < 4 ; col ++ ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 2 , row ) . getState ( ) == 0 ) ) { if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 1 ) ; } if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == player2Color ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } } } } }
tr	1	private List < DirFiles > getDirWithFiles ( String dirPath ) { List < DirFiles > ls = new ArrayList < AnalRunner . DirFiles > ( ) ; for ( File f : getDirList ( dirPath ) ) { DirFiles dirFiles = new DirFiles ( f . getName ( ) ) ; dirFiles . addFileList ( getFileList ( f . getAbsolutePath ( ) ) ) ; ls . add ( dirFiles ) ; } return ls ; }
tr	5	@ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) servletRequest ; HttpServletResponse response = ( HttpServletResponse ) servletResponse ; User session = ( User ) request . getSession ( ) . getAttribute ( "user" ) ; String url = request . getRequestURI ( ) ; response . setHeader ( "Cache-Control" , "no-cache  no-store  must-revalidate" ) ; response . setHeader ( "Pragma" , "no-cache" ) ; response . setDateHeader ( "Expires" , 0 ) ; if ( session == null ) { if ( url . indexOf ( "/content/" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "/security/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } else { if ( url . indexOf ( "register.xhtml" ) >= 0 || url . indexOf ( "/login.xhtml" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexOf ( "logout.xhtml" ) >= 0 ) { request . getSession ( ) . removeAttribute ( "user" ) ; response . sendRedirect ( request . getContextPath ( ) + "/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } }
tr	7	private void verificarSiHayNaveEnCasillero ( Casillero casillero , Disparo disparo ) { HashSet < Nave > naves = this . buscarNaves ( casillero , disparo . getRadio ( ) ) ; ArrayList < Coordenada > coordenadas = this . buscarCoordenadas ( casillero . getCoordenada ( ) , disparo . getRadio ( ) ) ; for ( Nave nave : naves ) { for ( Parte parte : nave . getPartes ( ) ) { if ( ! parte . estaDestruida ( ) && coordenadas . contains ( ( parte . getPosicion ( ) ) ) ) { disparo . accionarMina ( nave , parte ) ; if ( parte . estaDestruida ( ) ) { Imagen parteDaniada = null ; try { parteDaniada = new VistaParteDaniada ( new URL ( "file:./images/fuego.png" ) , parte ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } MapsModeloVista . getMapsModeloVista ( ) . agregarParte ( parte , parteDaniada ) ; DibujablesList . getDibujablesList ( ) . agregar ( parteDaniada ) ; } } } } }
tr	5	@ Override public void visit ( PlaceReinforcementCmd cmd ) { Country country = gameView . getCountry ( cmd . getCountry ( ) . getName ( ) ) ; Logger . logdebug ( "Got PlaceReinforcement command to " + country . getName ( ) + " (" + cmd . getTroops ( ) + ")" ) ; if ( clientHandler . getPlayer ( ) != gameView . getCurrentPlayer ( ) ) { Logger . logwarn ( clientHandler . getPlayer ( ) . getName ( ) + " is trying to place reinforcement in someone else's turn " + gameView . getCurrentPlayer ( ) . getName ( ) ) ; sendError ( ErrorCmd . ILLEGAL_ARGUMENT ) ; return ; } if ( cmd . getTroops ( ) < 0 || cmd . getTroops ( ) > gameView . getAvailableReinforcement ( ) ) { Logger . logwarn ( clientHandler . getPlayer ( ) . getName ( ) + " is trying to place " + cmd . getTroops ( ) + " reinforcement  available is " + gameView . getAvailableReinforcement ( ) ) ; sendError ( ErrorCmd . ILLEGAL_ARGUMENT ) ; return ; } if ( gameView . getCountry ( cmd . getCountry ( ) . getName ( ) ) . getOwner ( ) != clientHandler . getPlayer ( ) ) { Logger . logwarn ( clientHandler . getPlayer ( ) . getName ( ) + " is trying to place reinforcement to " + country . getName ( ) + " (" + country . getOwner ( ) . getName ( ) + ")" ) ; sendError ( ErrorCmd . ILLEGAL_ARGUMENT ) ; return ; } gameCtrl . setAvailableReinforcement ( gameView . getAvailableReinforcement ( ) - cmd . getTroops ( ) ) ; gameCtrl . addTroopsToCountry ( country , cmd . getTroops ( ) ) ; cmdSender . sendCmd ( new PlaceReinforcementCmd ( country , cmd . getTroops ( ) , gameView . getCurrentPlayer ( ) ) , null ) ; if ( gameView . getAvailableReinforcement ( ) == 0 ) { initNextPhase ( ) ; } }
tr	4	@ Override public final Element get ( int index ) { final int size = elements . size ( ) ; if ( index >= 0 ) { if ( index < size ) { return elements . get ( index ) ; } else { return null ; } } else { final int calculated = size + index ; if ( calculated >= 0 && calculated < size ) { return elements . get ( calculated ) ; } else { return null ; } } }
tr	7	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	4	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String scomplete = scan . nextLine ( ) ; while ( ! scomplete . equals ( "#" ) ) { String [ ] scompleteArray = scomplete . split ( " " ) ; String s1 = scompleteArray [ 0 ] ; String s2 = scompleteArray [ 1 ] ; int [ ] [ ] m = new int [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; dir [ ] [ ] direcciones = new dir [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; fill ( s2 , s1 , m , direcciones ) ; ArrayList < dir > res = trace ( m , direcciones , s2 , s1 ) ; int acarreo = 0 ; char last = a ; for ( int i = res . size ( ) - 1 ; i > - 1 ; i -- ) { if ( res . get ( i ) . pre . charAt ( 0 ) == I ) { acarreo ++ ; } res . get ( i ) . acarreo ( acarreo ) ; System . out . print ( res . get ( i ) . Stringify ( ) ) ; if ( res . get ( i ) . pre . charAt ( 0 ) == D ) { acarreo -- ; } } System . out . print ( "E\n" ) ; scomplete = scan . nextLine ( ) ; } }
tr	0	public void removeColumn ( String columnID ) { htColumns . remove ( columnID ) ; }
tr	3	static public void EliminacionGaussiana ( double a [ ] [ ] , double x [ ] , double b [ ] ) { int n = a . length ; for ( int k = 0 ; k <= n - 2 ; k ++ ) { for ( int i = k + 1 ; i <= ( n - 1 ) ; i ++ ) { b [ i ] -= a [ i ] [ k ] * b [ k ] / a [ k ] [ k ] ; for ( int j = n - 1 ; j >= k ; j -- ) a [ i ] [ j ] -= a [ i ] [ k ] * a [ k ] [ j ] / a [ k ] [ k ] ; } } }
tr	8	private void clipparPoligono ( Graphics g , double [ ] xPoints , double [ ] yPoints , boolean preenchido ) { System . out . println ( "Fazendo Clipping da pol\u00EDgono usando o algoritmo de Liang Barsky" ) ; ArrayList < double [ ] > segmentosX = new ArrayList < double [ ] > ( ) ; ArrayList < double [ ] > segmentosY = new ArrayList < double [ ] > ( ) ; for ( int i = 0 ; i < xPoints . length ; i ++ ) { if ( i != ( xPoints . length - 1 ) ) { double [ ] segmentoRetaX = { xPoints [ i ] , xPoints [ i + 1 ] } ; double [ ] segmentoRetaY = { yPoints [ i ] , yPoints [ i + 1 ] } ; segmentosX . add ( segmentoRetaX ) ; segmentosY . add ( segmentoRetaY ) ; } else { double [ ] segmentoRetaX = { xPoints [ i ] , xPoints [ 0 ] } ; double [ ] segmentoRetaY = { yPoints [ i ] , yPoints [ 0 ] } ; segmentosX . add ( segmentoRetaX ) ; segmentosY . add ( segmentoRetaY ) ; } } double [ ] [ ] pontos = null ; ArrayList < double > newX = new ArrayList < double > ( ) ; ArrayList < double > newY = new ArrayList < double > ( ) ; for ( int i = 0 ; i < segmentosX . size ( ) ; i ++ ) { TipoClipador lB = new LiangBarsky ( segmentosX . get ( i ) , segmentosY . get ( i ) , areaDesenhavel ) ; pontos = lB . cliparPoligono ( g , clipping ) ; if ( pontos != null ) { for ( int j = 0 ; j < pontos [ 0 ] . length ; j ++ ) { newX . add ( pontos [ 0 ] [ j ] ) ; newY . add ( pontos [ 1 ] [ j ] ) ; } int [ ] xPointsT = new int [ pontos [ 0 ] . length ] ; int [ ] yPointsT = new int [ pontos [ 1 ] . length ] ; for ( int j = 0 ; j < yPointsT . length ; j ++ ) { xPointsT [ j ] = ( int ) new Transformadora ( ) . transVPx ( pontos [ 0 ] [ j ] ) ; yPointsT [ j ] = ( int ) new Transformadora ( ) . transVPy ( pontos [ 1 ] [ j ] ) ; } g . drawPolygon ( xPointsT , yPointsT , pontos [ 0 ] . length ) ; } } int [ ] ptosX = new int [ newX . size ( ) * 2 ] ; int [ ] ptosY = new int [ newX . size ( ) * 2 ] ; for ( int i = 0 ; i < newX . size ( ) ; i ++ ) { ptosX [ i ] = ( int ) new Transformadora ( ) . transVPx ( newX . get ( i ) ) ; ptosY [ i ] = ( int ) new Transformadora ( ) . transVPy ( newY . get ( i ) ) ; } if ( preenchido ) { g . fillPolygon ( ptosX , ptosY , ptosX . length ) ; } }
tr	4	public void setValue ( Calendar date , String priceString ) { System . out . println ( "setValue  price = " + priceString ) ; System . out . println ( "number of = " + antal ) ; double price = double . parseDouble ( priceString ) ; if ( name . equals ( "Fortum" ) ) { if ( CurrencyUtil . getMultiplicator ( "EUR/SEK" ) != - 1 ) { price = price * CurrencyUtil . getMultiplicator ( "EUR/SEK" ) ; } else { return ; } } else if ( name . equals ( "Disney" ) ) { if ( CurrencyUtil . getMultiplicator ( "USD/SEK" ) != - 1 ) { price = price * CurrencyUtil . getMultiplicator ( "USD/SEK" ) ; } else { return ; } } value = antal * price ; System . out . println ( "Value is now " + value ) ; lastUppdateDate = date ; }
tr	5	private static int mixLightness ( int colour , int lightness , int drawType ) { if ( ( drawType & 2 ) == 2 ) { if ( lightness < 0 ) lightness = 0 ; else if ( lightness > 127 ) lightness = 127 ; lightness = 127 - lightness ; return lightness ; } lightness = lightness * ( colour & 7f ) >> 7 ; if ( lightness < 2 ) lightness = 2 ; else if ( lightness > 126 ) lightness = 126 ; return ( colour & ff80 ) + lightness ; }
tr	0	public void setFinalGrades ( boolean value ) { this . finalGrades = value ; }
tr	6	private void create ( InputStream input ) { if ( input != null ) { FileOutputStream output = null ; try { output = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ 8192 ] ; int length ; while ( ( length = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , length ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { input . close ( ) ; } catch ( Exception ignored ) { } try { if ( output != null ) output . close ( ) ; } catch ( Exception ignored ) { } } } }
tr	3	public EnterTeams ( MainGUI gui ) { initComponents ( ) ; this . gui = gui ; GraphicsEnvironment g = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = g . getScreenDevices ( ) ; int width = devices [ 0 ] . getDisplayMode ( ) . getWidth ( ) ; int height = devices [ 0 ] . getDisplayMode ( ) . getHeight ( ) ; int w = this . getSize ( ) . width ; int h = this . getSize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setLocation ( x , y ) ; numberOfMatchesField . setValue ( 1 ) ; matchField . setValue ( 1 ) ; saveMatchesButton . setEnabled ( false ) ; teamArray = new JTextField [ 6 ] ; teamArray [ 0 ] = redAllianceTeam1 ; teamArray [ 1 ] = redAllianceTeam2 ; teamArray [ 2 ] = redAllianceTeam3 ; teamArray [ 3 ] = blueAllianceTeam1 ; teamArray [ 4 ] = blueAllianceTeam2 ; teamArray [ 5 ] = blueAllianceTeam3 ; if ( ! "" . equals ( Competition . getCompetitionName ( ) ) || Competition . getCompetitionName ( ) != null ) { competitionNameField . setText ( Competition . getCompetitionName ( ) ) ; } if ( Competition . getNumberOfMatches ( ) != 0 ) { numberOfMatchesField . setValue ( Competition . getNumberOfMatches ( ) ) ; } DynamicArray teams = new DynamicArray ( 20 ) ; }
tr	6	@ Override public void mouseMoved ( MouseEvent arg0 ) { try { Point pointTmp = this . getMousePosition ( ) ; Point point2D = getPositionMouse ( pointTmp . x , pointTmp . y ) ; List < List < Integer >> map2D = ctrl . getMap2D ( ) ; ctrl . setPolygonMouse ( null ) ; if ( point2D . x >= 0 && point2D . y >= 0 && point2D . x < map2D . get ( 0 ) . size ( ) && point2D . y < map2D . size ( ) && map2D . get ( point2D . y ) . get ( point2D . x ) != 0 ) { hasMooved = true ; Polygon polygonMouseTmp = new Polygon ( ) ; polygonMouseTmp . setPoint2D ( point2D ) ; polygonMouseTmp . setPoint3D ( ctrl . convert2DTo3D ( point2D ) ) ; ctrl . setPolygonMouse ( polygonMouseTmp ) ; } repaint ( ) ; revalidate ( ) ; } catch ( Exception e ) { System . out . println ( "(WARNING) Exception in function mouseMoved in Class PanelGPS3D" ) ; } }
tr	3	@ Override public void mouseClicked ( MouseEvent e ) { JTable table = ( JTable ) e . getSource ( ) ; Point pt = e . getPoint ( ) ; int ccol = table . columnAtPoint ( pt ) ; if ( isURLColumn ( table , ccol ) ) { int crow = table . rowAtPoint ( pt ) ; URL url = ( URL ) table . getValueAt ( crow , ccol ) ; System . out . println ( url ) ; try { if ( Desktop . isDesktopSupported ( ) ) { Desktop . getDesktop ( ) . browse ( url . toURI ( ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }
tr	1	public String optString ( int index , String defaultValue ) { Object object = this . opt ( index ) ; return JSONObject . null . equals ( object ) ? defaultValue : object . toString ( ) ; }
tr	4	@ Override public void visit ( YTask t ) { visited . add ( t ) ; if ( phase == 1 ) { FSPAbstractTask c ; if ( t . canceledBy ( ) != null ) { c = new FSPCancelableTask ( t . name ( ) ) ; } else { c = new FSPTask ( t . name ( ) ) ; } c . container ( _current_net ) ; _current_net . components ( ) . put ( c . name ( ) , c ) ; _components . put ( t , c ) ; assert t . name ( ) == c . name ( ) ; process_gates ( t , c ) ; } else if ( phase == 2 ) { process_outgoing_links ( t ) ; } else if ( phase == 3 ) { process_cancel_regions ( t ) ; } else { } }
tr	8	private void draw ( Graphics2D g , Editable editable , String name , boolean drawLineBuffer , boolean drawPointBuffer ) { int n = editable . getNumberOfCoordinates ( ) ; if ( n == 0 ) { return ; } int height = getHeight ( ) - getInsets ( ) . top - getInsets ( ) . bottom ; if ( drawEpsilon ) { g . setColor ( colorEpsilon ) ; int halfHeight = heightEpsilonBar / 2 ; int ypos = height - offsetEpsilon - halfHeight ; g . drawLine ( offsetEpsilon , ypos , offsetEpsilon + epsilon , ypos ) ; g . drawLine ( offsetEpsilon , ypos - halfHeight , offsetEpsilon , ypos + halfHeight ) ; g . drawLine ( offsetEpsilon + epsilon , ypos - halfHeight , offsetEpsilon + epsilon , ypos + halfHeight ) ; } Coordinate last ; if ( drawPointBuffer ) { useAntialiasing ( g , true ) ; g . setColor ( colorBuffersPoints ) ; for ( int i = 0 ; i < n ; i ++ ) { Coordinate c = editable . getCoordinate ( i ) ; g . drawArc ( ( int ) Math . round ( c . getX ( ) - epsilon ) , ( int ) Math . round ( c . getY ( ) - epsilon ) , epsilon * 2 , epsilon * 2 , 0 , 360 ) ; } } if ( drawLineBuffer ) { GeometryFactory factory = new GeometryFactory ( ) ; useAntialiasing ( g , true ) ; g . setColor ( colorBuffersLines ) ; last = editable . getCoordinate ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; com . vividsolutions . jts . geom . Coordinate [ ] cs = new com . vividsolutions . jts . geom . Coordinate [ ] { new com . vividsolutions . jts . geom . Coordinate ( last . getX ( ) , last . getY ( ) ) , new com . vividsolutions . jts . geom . Coordinate ( current . getX ( ) , current . getY ( ) ) } ; LineString seg = factory . createLineString ( cs ) ; Geometry buffer = seg . buffer ( epsilon ) ; Area area = GeometryTransformator . toShape ( ( Polygon ) buffer , new IdentityCoordinateTransformer ( ) ) ; g . fill ( area ) ; last = current ; } } useAntialiasing ( g , true ) ; g . setColor ( colorLines ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; last = editable . getCoordinate ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; int x1 = ( int ) Math . round ( last . getX ( ) ) ; int y1 = ( int ) Math . round ( last . getY ( ) ) ; int x2 = ( int ) Math . round ( current . getX ( ) ) ; int y2 = ( int ) Math . round ( current . getY ( ) ) ; g . drawLine ( x1 , y1 , x2 , y2 ) ; last = current ; } useAntialiasing ( g , false ) ; g . setColor ( colorPoints ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Coordinate current = editable . getCoordinate ( i ) ; int x = ( int ) Math . round ( current . getX ( ) ) ; int y = ( int ) Math . round ( current . getY ( ) ) ; g . drawRect ( x - 2 , y - 2 , 4 , 4 ) ; } useAntialiasing ( g , true ) ; g . setColor ( colorLabels ) ; Coordinate first = editable . getFirstCoordinate ( ) ; g . drawString ( name , ( int ) Math . round ( first . getX ( ) ) - 2 , ( int ) Math . round ( first . getY ( ) ) - 4 ) ; }
tr	8	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
tr	2	@ Override public short next ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( "There are no more sound in this instrument!" ) ; if ( vol < 0 ) return currentPlay [ place ++ % singleCycle ] ; else { int ret = currentPlay [ place ++ % singleCycle ] * vol ; ret = ret / short . MAX_VALUE ; return ( short ) ret ; } }
tr	1	private String get_ct ( String str , int [ ] num_key , int start , int end , char [ ] keyed_alphabet , int add_index ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = start ; i < end ; i ++ ) { int p_loc = str . charAt ( i ) - A ; int ct_pos = ( p_loc + add_index + num_key [ i - start ] ) % 26 ; sb . append ( keyed_alphabet [ ct_pos ] ) ; } return sb . toString ( ) ; }
tr	1	public static ApplicationContext getContext ( ) { if ( applicationContext == null ) { applicationContext = new ApplicationContext ( ) ; } return applicationContext ; }
tr	2	public static void createTableCourseProtocols ( ) { try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "table CourseProtocols not created" ) ; dbConn . setAutoCommit ( false ) ; dbStmnt = dbConn . createStatement ( ) ; dbStmnt . executeUpdate ( "use phdStudent;" ) ; dbStmnt . executeUpdate ( "create table if not exists CourseProtocols" + "( id int auto_increment primary key " + "protoName varchar(255) not null);" ) ; dbConn . commit ( ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	0	public PanelRenderer ( JTable table , TableCellRenderer renderer , TableCellEditor editor ) { this . table = table ; baseRenderer = renderer ; baseEditor = editor ; panel = new JPanel ( ) ; panel . setLayout ( new GridBagLayout ( ) ) ; }
tr	8	@ Override protected void draw ( ) { super . draw ( ) ; StringRenderer . drawCenteredString ( "Select your icon:" , this . xSize / 2 , 42 , 26 , true , Color . WHITE ) ; int xStart = ( xSize / 2 ) - ( 34 * 4 ) ; boolean hasSelectedSomething = false ; for ( int i = 0 ; i < 8 ; i ++ ) { Monopoly . getInstance ( ) . getEngine ( ) . bindTexture ( "/textures/players.png" ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( ( xStart + 1 ) + ( i * 34 ) , 120 , i % 4 * 32 , i / 4 * 32 , 32 , 32 ) ; Monopoly . getInstance ( ) . getEngine ( ) . bindTexture ( "/textures/player_border.png" ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( xStart + i * 34 , 119 , 0 , i == index ? 34 : 0 , 34 , 34 ) ; final int x = MouseLoc . getX ( ) - this . xStart ; final int y = MouseLoc . getY ( ) - this . yStart ; if ( x >= xStart + i * 34 && x <= ( xStart + i * 34 ) + 34 && y >= 119 && y <= 119 + 34 ) { if ( Mouse . isButtonDown ( 0 ) ) { player . texture = new Point ( i % 4 * 32 , i / 4 * 32 ) ; parent . setPreviousGui ( ) ; } this . index = i ; hasSelectedSomething = true ; } } if ( ! hasSelectedSomething ) { this . index = - 1 ; } }
tr	2	public static WIBrowser getNewBrowser ( String urlStr ) { Requirements . notNull ( urlStr , "url" ) ; URL url = Utils . getURL ( urlStr ) ; if ( useEmbededSeleniumServer ) { if ( ! isSeleniumRunning ) { startEmbededSeleniumServer ( ) ; isSeleniumRunning = true ; } } URL baseUrl = Utils . getURL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , "" ) ; WIBrowser browser = new WIBrowser ( seleniumUrl . getHost ( ) , seleniumUrl . getPort ( ) , SELENIUM_BROWSER , baseUrl . toString ( ) ) ; browser . setTimeout ( SELENIUM_TIMEOUT ) ; browser . setShouldHighlightElement ( true ) ; browser . windowMaximize ( ) ; browser . open ( urlStr ) ; LocaleManager . autoDetect ( browser ) ; return browser ; }
tr	5	private void labelVertex ( Segment segment , long crossProduct , Path path ) { if ( crossProduct > 0 ) { if ( path . isInverted ) segment . end . type = Vertex . OUTIE ; else segment . end . type = Vertex . INNIE ; } else if ( crossProduct < 0 ) { if ( path . isInverted ) segment . end . type = Vertex . INNIE ; else segment . end . type = Vertex . OUTIE ; } else if ( segment . start . type != Vertex . NOT_SET ) segment . end . type = segment . start . type ; else segment . end . type = Vertex . INNIE ; }
tr	9	private void postPlugin ( final boolean isPing ) throws IOException { final PluginDescriptionFile description = plugin . getDescription ( ) ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , description . getVersion ( ) ) ; encodeDataPair ( data , "server" , Bukkit . getVersion ( ) ) ; encodeDataPair ( data , "players" , Integer . toString ( Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( plugin . getDescription ( ) . getName ( ) ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
tr	8	private void writeHeader ( ) throws IOException { row [ 0 ] = row [ 1 ] = row [ 2 ] = row [ 3 ] = "" ; int columnNumber = 4 ; for ( int i = 0 ; i < columns . get ( "" ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = "" ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( int i = 0 ; i < entry . getValue ( ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = entry . getKey ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; row [ 0 ] = "Point#" ; row [ 1 ] = "Experiment#" ; row [ 2 ] = "Year#" ; row [ 3 ] = "After subiteration" ; columnNumber = 4 ; for ( Column column : columns . get ( "" ) ) row [ columnNumber ++ ] = column . dynamicValueName ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( Column column : entry . getValue ( ) ) row [ columnNumber ++ ] = column . toString ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; }
tr	5	public void PrOkObteHabitacions ( String pob , Date dIni , Date dFi , int numOcup ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( dIni ) ; long dataIni = c . getTimeInMillis ( ) ; c . setTime ( dFi ) ; long dataFi = c . getTimeInMillis ( ) ; if ( ( dataFi < dataIni ) || dataFi - dataIni < 1000 ) { vista . mostraMissatge ( "Dates incorrectes" , 1 ) ; return ; } try { Set < DadesHotel > resultat = domini . buscarHabitacio ( pob , dIni , dFi , numOcup ) ; DadesReserva basicData = new DadesReserva ( ) ; basicData . pob = pob ; basicData . dIni = dIni ; basicData . dFi = dFi ; basicData . numOc = numOcup ; vista . mostraHabitacions ( basicData , resultat ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null && e . getMessage ( ) . equals ( "hotelsNoDisp" ) ) { vista . mostraMissatge ( "No hi ha hotels disponibles en aquesta poblaci\u00F3" , 1 ) ; } else e . printStackTrace ( ) ; } }
tr	2	@ Override public void action ( RuleContext _localctx , int ruleIndex , int actionIndex ) { switch ( ruleIndex ) { case 34 : WS_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; case 37 : COMMENTLIN_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; } }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	0	public Cliente ( ) { mascotas = new ArrayList ( ) ; }
tr	6	public void write ( SelectionKey key ) throws IOException { loggerNetworkClient . info ( "WRITE: " ) ; FileService fileService ; ByteBuffer wBuff = ByteBuffer . allocate ( NetworkInfo . BUF_SIZE ) ; SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; int toWrite ; synchronized ( key ) { while ( wbuf . size ( ) > 0 ) { byte [ ] bbuf = wbuf . get ( 0 ) ; wbuf . remove ( 0 ) ; if ( bbuf . length < NetworkInfo . BUF_SIZE ) { wBuff . clear ( ) ; wBuff . put ( bbuf ) ; wBuff . flip ( ) ; } else { toWrite = NetworkInfo . BUF_SIZE ; wBuff . clear ( ) ; wBuff . put ( bbuf , 0 , toWrite ) ; wBuff . flip ( ) ; } int numWritten = socketChannel . write ( wBuff ) ; loggerNetworkClient . info ( "I wrote " + numWritten + " bytes on the socket associated with the key" + key ) ; if ( this . dataToSend instanceof FileService ) { fileService = ( FileService ) dataToSend ; offset += numWritten ; network . med . acceptFileTransfer ( fileService . serviceName , 100 * offset / sizeToWrite ) ; } if ( numWritten < bbuf . length ) { byte [ ] newBuf = new byte [ bbuf . length - numWritten ] ; for ( int i = numWritten ; i < bbuf . length ; i ++ ) { newBuf [ i - numWritten ] = bbuf [ i ] ; } wbuf . add ( 0 , newBuf ) ; break ; } if ( wbuf . size ( ) == 0 ) { key . interestOps ( SelectionKey . OP_READ ) ; } } } }
tr	8	@ SuppressWarnings ( { "RedundantIfStatement" } ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Change change = ( Change ) o ; if ( type != change . type ) return false ; if ( ! filePath . equals ( change . filePath ) ) return false ; if ( ! filePathBefore . equals ( change . filePathBefore ) ) return false ; if ( ! revision . equals ( change . revision ) ) return false ; if ( ! revisionBefore . equals ( change . revisionBefore ) ) return false ; return true ; }
tr	9	private boolean processCommand ( StringTokenizer iData ) { char cmdSymbol = iData . nextToken ( ) . charAt ( 0 ) ; if ( ! Command . isValidCommand ( cmdSymbol ) ) { return false ; } Command cmd = Command . getCommand ( cmdSymbol ) ; switch ( cmd ) { case CREATE : int cols = Integer . parseInt ( iData . nextToken ( ) ) ; int rows = Integer . parseInt ( iData . nextToken ( ) ) ; doCreate ( rows , cols ) ; break ; case CLEAR : doClear ( ) ; break ; case COLOR : int c = Integer . parseInt ( iData . nextToken ( ) ) ; int r = Integer . parseInt ( iData . nextToken ( ) ) ; char colour = iData . nextToken ( ) . charAt ( 0 ) ; doColor ( r - 1 , c - 1 , colour ) ; break ; case VDRAW : c = Integer . parseInt ( iData . nextToken ( ) ) ; int r1 = Integer . parseInt ( iData . nextToken ( ) ) ; int r2 = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; if ( r1 > r2 ) { int t = r1 ; r1 = r2 ; r2 = t ; } doVerticalDraw ( c - 1 , r1 - 1 , r2 - 1 , colour ) ; break ; case HDRAW : int c1 = Integer . parseInt ( iData . nextToken ( ) ) ; int c2 = Integer . parseInt ( iData . nextToken ( ) ) ; r = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; if ( c1 > c2 ) { int t = c1 ; c1 = c2 ; c2 = t ; } doHorizontalDraw ( r - 1 , c1 - 1 , c2 - 1 , colour ) ; break ; case FILLRECT : c1 = Integer . parseInt ( iData . nextToken ( ) ) ; r1 = Integer . parseInt ( iData . nextToken ( ) ) ; c2 = Integer . parseInt ( iData . nextToken ( ) ) ; r2 = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; doFillRect ( r1 - 1 , c1 - 1 , r2 - 1 , c2 - 1 , colour ) ; break ; case FILLREG : c = Integer . parseInt ( iData . nextToken ( ) ) ; r = Integer . parseInt ( iData . nextToken ( ) ) ; colour = iData . nextToken ( ) . charAt ( 0 ) ; doFillRegion ( c - 1 , r - 1 , colour ) ; break ; case SAVE : StringBuilder name = new StringBuilder ( iData . nextToken ( ) ) ; while ( iData . hasMoreTokens ( ) ) { name . append ( iData . nextToken ( ) ) ; } doSave ( name . toString ( ) ) ; break ; case TERMINATE : { return true ; } } return false ; }
tr	7	public void run ( ) { final String methodName = "run" ; MqttToken token = null ; while ( running && ( in != null ) ) { try { log . fine ( className , methodName , "852" ) ; MqttWireMessage message = in . readMqttWireMessage ( ) ; if ( message instanceof MqttAck ) { token = tokenStore . getToken ( message ) ; if ( token != null ) { synchronized ( token ) { clientState . notifyReceivedAck ( ( MqttAck ) message ) ; } } else { throw new MqttException ( MqttException . REASON_CODE_UNEXPECTED_ERROR ) ; } } else { clientState . notifyReceivedMsg ( message ) ; } } catch ( MqttException ex ) { log . fine ( className , methodName , "856" , null , ex ) ; running = false ; clientComms . shutdownConnection ( token , ex ) ; } catch ( IOException ioe ) { log . fine ( className , methodName , "853" ) ; running = false ; if ( ! clientComms . isDisconnecting ( ) ) { clientComms . shutdownConnection ( token , new MqttException ( MqttException . REASON_CODE_CONNECTION_LOST , ioe ) ) ; } } } log . fine ( className , methodName , "854" ) ; }
tr	6	public static int [ ] randomize ( int num_choices ) { int [ ] rnd = new int [ 4 ] ; rnd [ 0 ] = ( int ) ( Math . random ( ) * num_choices ) ; do { rnd [ 1 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 1 ] == rnd [ 0 ] ) ; do { rnd [ 2 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 2 ] == rnd [ 0 ] || rnd [ 2 ] == rnd [ 1 ] ) ; do { rnd [ 3 ] = ( int ) ( Math . random ( ) * num_choices ) ; } while ( rnd [ 3 ] == rnd [ 0 ] || rnd [ 3 ] == rnd [ 1 ] || rnd [ 3 ] == rnd [ 2 ] ) ; return rnd ; }
tr	3	public List < List < Integer >> sort ( List < List < Integer >> listToSort ) { int listSize = listToSort . size ( ) ; boolean swapped ; do { swapped = false ; for ( int i = 0 ; i < listSize - 1 ; i ++ ) { int one = listToSort . get ( i ) . get ( 1 ) ; int two = listToSort . get ( i + 1 ) . get ( 1 ) ; if ( one < two ) { Collections . swap ( listToSort , i , i + 1 ) ; swapped = true ; } } } while ( swapped == true ) ; return listToSort ; }
tr	4	@ Override protected void checkPD ( ) { switch ( pd ) { case CLOCK6 : case CLOCK12 : sqNumWidth = 2 ; sqNumHeight = 3 ; break ; case CLOCK3 : case CLOCK9 : default : sqNumWidth = 3 ; sqNumHeight = 2 ; break ; } }
tr	9	public boolean isPunch ( ) { switch ( this ) { case BULLET_PUNCH : case COMET_PUNCH : case DIZZY_PUNCH : case DRAIN_PUNCH : case DYNAMICPUNCH : case FIRE_PUNCH : case FOCUS_PUNCH : case HAMMER_ARM : case ICE_PUNCH : case MACH_PUNCH : case MEGA_PUNCH : case METEOR_MASH : case SHADOW_PUNCH : case SKY_UPPERCUT : case THUNDERPUNCH : return true ; default : return false ; } }
tr	8	@ Override public void computePerformanceMeasures ( ) throws InternalErrorException { totalTimer . start ( ) ; BigRational [ ] X = new BigRational [ qnm . R ] ; BigRational [ ] [ ] Q = new BigRational [ qnm . M ] [ qnm . R ] ; if ( lastG [ 0 ] . isUndefined ( ) ) { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . M ; i ++ ) { for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) + i + 1 ] . isUndefined ( ) ) { Q [ i ] [ r ] = qnm . getDemandAsBigRational ( i , r ) . multiply ( lastG [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ i + 1 ] . isUndefined ( ) ) { Q [ i ] [ qnm . R - 1 ] = qnm . getDemandAsBigRational ( i , qnm . R - 1 ) . multiply ( prevG [ i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) ] . isUndefined ( ) ) { X [ r ] = lastG [ sz * ( r + 1 ) ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ 0 ] . isUndefined ( ) ) { X [ qnm . R - 1 ] = prevG [ 0 ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } totalTimer . pause ( ) ; qnm . setPerformanceMeasures ( Q , X ) ; }
tr	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
tr	8	private void calcLosses ( ) { Random rand = new Random ( ) ; int baseAonD = ( attackerFA - defenderFD ) ; int baseDonA = ( defenderFA - attackerFD ) ; int damAonD = ( int ) ( ( 2.5 * rand . nextDouble ( ) ) + ( ( ( double ) baseAonD ) / 50 ) * 1.2 * pow ( rand . nextDouble ( ) , .25 ) ) ; int damDonA = ( int ) ( ( 2.5 * rand . nextDouble ( ) ) + ( ( ( double ) baseDonA ) / 50 ) * 1.2 * pow ( rand . nextDouble ( ) , .25 ) ) ; if ( defenderBUA == 0 ) { damDonA = 0 ; } if ( damAonD < 0 ) { damAonD = 0 ; } if ( damDonA < 0 ) { damDonA = 0 ; } attacker . setHealth ( attackerHB - damDonA ) ; defender . setHealth ( defenderHB - damAonD ) ; if ( attackerHB - damDonA > 0 && defenderHB - damAonD > 0 ) { attacker . addExp ( 1 ) ; defender . addExp ( 1 ) ; } else if ( damAonD == 0 ) { defender . addExp ( 2 ) ; } else if ( defenderHB - damAonD <= 0 ) { attacker . addExp ( 2 ) ; } else if ( attackerHB - damDonA <= 0 ) { defender . addExp ( 1 ) ; } }
tr	5	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterEscreva ( this ) ; }
tr	6	@ SuppressWarnings ( "unchecked" ) private Set < WFF > makeCorrectDepthResults ( WFF source ) { HashSet < WFF > results = new HashSet < WFF > ( ) ; try { Logic logic = new ClassicalLogicS ( ) ; if ( source . getFormula ( ) . length ( ) < 1 ) { return results ; } ; formula = ( Formula ) logic . createExpression ( source . getFormula ( ) ) ; Formula result = ClassicalLogicS . Utilities . conjunctiveForm ( formula , true ) ; DefaultClausalFactory myFacts = new DefaultClausalFactory ( ) ; ClausalSet myClauses = myFacts . asClausalSet ( result ) ; PartitionListElement < Clause > reducedWFF = new PartitionListElement < Clause > ( ) ; for ( Clause cls : ( Set < Clause > ) myClauses ) { reducedWFF . add ( cls ) ; } int [ ] indices ; CombinationGenerator x = new CombinationGenerator ( reducedWFF . size ( ) , currentDepth ) ; StringBuffer combination ; HashSet < String > myWFF = new HashSet < String > ( ) ; while ( x . hasMore ( ) ) { combination = new StringBuffer ( ) ; indices = x . getNext ( ) ; for ( int i = 0 ; i < indices . length ; i ++ ) { combination . append ( reducedWFF . get ( indices [ i ] ) ) ; } String mynewWFF = combination . toString ( ) ; myWFF . add ( mynewWFF . replaceAll ( "\\]\\[" , "\\] \\[" ) ) ; } for ( String formString : myWFF ) { String newForm = formString ; newForm = newForm . replaceAll ( "\\[" , "(" ) ; newForm = newForm . replaceAll ( "\\] " , ") & " ) ; newForm = newForm . replaceAll ( "\\]" , ")" ) ; newForm = newForm . replaceAll ( " " , " |" ) ; results . add ( new WFF ( newForm ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return results ; }
tr	0	public Logger getLogger ( ) { return this . logger ; }
tr	9	private static double atan ( double xa , double xb , boolean leftPlane ) { boolean negate = false ; int idx ; if ( xa == 0.0 ) { return leftPlane ? copySign ( Math . PI , xa ) : xa ; } if ( xa < 0 ) { xa = - xa ; xb = - xb ; negate = true ; } if ( xa > 1.633123935319537E16 ) { return ( negate ^ leftPlane ) ? ( - Math . PI / 2.0 ) : ( Math . PI / 2.0 ) ; } if ( xa < 1.0 ) { idx = ( int ) ( ( ( - 1.7168146928204136 * xa * xa + 8.0 ) * xa ) + 0.5 ) ; } else { double temp = 1.0 / xa ; idx = ( int ) ( - ( ( - 1.7168146928204136 * temp * temp + 8.0 ) * temp ) + 13.07 ) ; } double epsA = xa - TANGENT_TABLE_A [ idx ] ; double epsB = - ( epsA - xa + TANGENT_TABLE_A [ idx ] ) ; epsB += xb - TANGENT_TABLE_B [ idx ] ; double temp = epsA + epsB ; epsB = - ( temp - epsA - epsB ) ; epsA = temp ; temp = xa * HEX_40000000 ; double ya = xa + temp - temp ; double yb = xb + xa - ya ; xa = ya ; xb += yb ; if ( idx == 0 ) { double denom = 1.0 / ( 1.0 + ( xa + xb ) * ( TANGENT_TABLE_A [ idx ] + TANGENT_TABLE_B [ idx ] ) ) ; ya = epsA * denom ; yb = epsB * denom ; } else { double temp2 = xa * TANGENT_TABLE_A [ idx ] ; double za = 1.0 + temp2 ; double zb = - ( za - 1.0 - temp2 ) ; temp2 = xb * TANGENT_TABLE_A [ idx ] + xa * TANGENT_TABLE_B [ idx ] ; temp = za + temp2 ; zb += - ( temp - za - temp2 ) ; za = temp ; zb += xb * TANGENT_TABLE_B [ idx ] ; ya = epsA / za ; temp = ya * HEX_40000000 ; final double yaa = ( ya + temp ) - temp ; final double yab = ya - yaa ; temp = za * HEX_40000000 ; final double zaa = ( za + temp ) - temp ; final double zab = za - zaa ; yb = ( epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab ) / za ; yb += - epsA * zb / za / za ; yb += epsB / za ; } epsA = ya ; epsB = yb ; double epsA2 = epsA * epsA ; yb = 0.07490822288864472 ; yb = yb * epsA2 + - 0.09088450866185192 ; yb = yb * epsA2 + 0.11111095942313305 ; yb = yb * epsA2 + - 0.1428571423679182 ; yb = yb * epsA2 + 0.19999999999923582 ; yb = yb * epsA2 + - 0.33333333333333287 ; yb = yb * epsA2 * epsA ; ya = epsA ; temp = ya + yb ; yb = - ( temp - ya - yb ) ; ya = temp ; yb += epsB / ( 1.0 + epsA * epsA ) ; double result ; double resultb ; double za = EIGHTHS [ idx ] + ya ; double zb = - ( za - EIGHTHS [ idx ] - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; result = za + zb ; resultb = - ( result - za - zb ) ; if ( leftPlane ) { final double pia = 1.5707963267948966 * 2.0 ; final double pib = 6.123233995736766E-17 * 2.0 ; za = pia - result ; zb = - ( za - pia + result ) ; zb += pib - resultb ; result = za + zb ; resultb = - ( result - za - zb ) ; } if ( negate ^ leftPlane ) { result = - result ; } return result ; }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	5	public Plugin ( String name ) { this . name = name ; this . propertyChange = new PropertyChangeSupport ( this ) ; if ( name . startsWith ( "serendipity_plugin" ) ) { setType ( PluginType . sidebar ) ; } else if ( name . startsWith ( "serendipity_event" ) ) { setType ( PluginType . event ) ; } else if ( name . equals ( "system" ) ) { setType ( PluginType . system ) ; } else { setType ( PluginType . template ) ; } intern = false ; if ( type . equals ( PluginType . system ) ) { intern = true ; } if ( name . equals ( "homepage" ) ) { System . out . println ( "contructor: hompage plugin type = " + getType ( ) ) ; } }
tr	5	public static double [ ] decode ( String geohash ) { StringBuilder buffer = new StringBuilder ( ) ; for ( char c : geohash . toCharArray ( ) ) { int i = lookup . get ( c ) + 32 ; buffer . append ( Integer . toString ( i , 2 ) . substring ( 1 ) ) ; } BitSet lonset = new BitSet ( ) ; BitSet latset = new BitSet ( ) ; int j = 0 ; for ( int i = 0 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; lonset . set ( j ++ , isSet ) ; } j = 0 ; for ( int i = 1 ; i < numbits * 2 ; i += 2 ) { boolean isSet = false ; if ( i < buffer . length ( ) ) isSet = buffer . charAt ( i ) == 1 ; latset . set ( j ++ , isSet ) ; } double lon = decode ( lonset , - 180 , 180 ) ; double lat = decode ( latset , - 90 , 90 ) ; return new double [ ] { lat , lon } ; }
tr	1	public static Integer castInt ( Object obj ) { try { return ( Integer ) obj ; } catch ( ClassCastException e ) { return 0 ; } }
tr	9	private boolean applyDistributiveLaw ( IExpressionContext context , ASTNode result ) { final TreeMatcher matcher = new TreeMatcher ( ) . ignoreChildOrder ( true ) . requireNodeToHaveParent ( true ) . unwrapAll ( ) . matchParent ( ) . matchAND ( ) . matchOR ( ) . buildOR ( ) . matchRightChild ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { final ASTNode unwrapped = unwrap ( matcher . parentMatch ( ) ) ; if ( unwrapped . isOR ( ) ) { return n . isAND ( ) ; } if ( unwrapped . isAND ( ) ) { return n . isOR ( ) ; } throw new RuntimeException ( "Unreachable code reached" ) ; } } ) . buildOR ( ) . matchExtra ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { return matcher . leftMatch ( ) . getNodeCount ( ) != matcher . rightMatch ( ) . getNodeCount ( ) ; } } ) . buildOR ( ) ; final MutatingNodeVisitor visitor = new MutatingNodeVisitor ( context ) { @ Override public void visit ( ASTNode node , IExpressionContext context , IIterationContext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final ASTNode matchedParent = matcher . parentMatch ( ) ; final ASTNode leftChild = matcher . leftMatch ( ) ; final ASTNode rightChild = matcher . rightMatch ( ) ; final ASTNode leftTerm ; final ASTNode rightTerm ; final ASTNode replacementTerm ; ASTNode unwrappedRight = unwrap ( rightChild ) ; if ( unwrap ( matchedParent ) . isAND ( ) && unwrappedRight . isOR ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . or ( leftTerm , rightTerm ) ; } else if ( unwrap ( matchedParent ) . isOR ( ) && unwrappedRight . isAND ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . and ( leftTerm , rightTerm ) ; } else { throw new RuntimeException ( "Unreachable code reached => " + matcher ) ; } ASTNode toReplace = matchedParent ; if ( ! toReplace . hasParent ( ) ) { if ( unwrap ( toReplace ) != toReplace ) { toReplace = unwrap ( toReplace ) ; } else { throw new RuntimeException ( "Unreachable code reached" ) ; } } debugPrintln ( "DISTRIBUTIVE LAW: Replacing " + matchedParent . toString ( false ) + " -> " + replacementTerm ) ; toReplace . replaceWith ( replacementTerm ) ; it . astMutated ( ) ; } } ; return applyInOrder ( result , visitor ) ; }
tr	9	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	1	public static boolean isValidPropertyState ( String state ) { try { parsePropertyState ( state ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
