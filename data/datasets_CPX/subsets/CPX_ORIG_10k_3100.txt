tr	7	public void brake ( double delta ) { if ( brakeFriction > 0 ) { if ( xa > 0 ) { xa = xa - ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } else if ( xa < 0 ) { xa = xa + ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } if ( xa <= 1 && xa >= - 1 ) { xa = 0.0 ; } } }
tr	0	private static void markEndTime ( ) { endTime = System . currentTimeMillis ( ) ; }
tr	2	private void tf5FocusLost ( java . awt . event . FocusEvent evt ) { int resposta ; resposta = Integer . parseInt ( tf5 . getText ( ) ) ; if ( resposta > 4 ) { resposta = 4 ; tf5 . setText ( Integer . toString ( 4 ) ) ; } if ( resposta < 0 ) { resposta = 0 ; tf5 . setText ( Integer . toString ( 0 ) ) ; } atualizaCognitivo ( 3 , resposta ) ; }
tr	7	public void set_safe ( final long i , final Object value ) { if ( value instanceof boolean ) { setBoolean_safe ( i , ( boolean ) value ) ; } else if ( value instanceof byte ) { setByte_safe ( i , ( byte ) value ) ; } else if ( value instanceof short ) { setShort_safe ( i , ( short ) value ) ; } else if ( value instanceof Integer ) { setInt_safe ( i , ( Integer ) value ) ; } else if ( value instanceof long ) { setLong_safe ( i , ( long ) value ) ; } else if ( value instanceof float ) { setFloat_safe ( i , ( float ) value ) ; } else if ( value instanceof double ) { setDouble_safe ( i , ( double ) value ) ; } else { throw new IllegalArgumentException ( "Unsupported type." ) ; } }
tr	5	public static byte [ ] readFileByBufferedInputStream ( File file ) throws Exception { FileInputStream fis = null ; BufferedInputStream bis = null ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { output . write ( buffer , 0 , bytesRead ) ; } } catch ( Exception ex ) { System . out . println ( "Error occurs during reading " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( bis != null ) bis . close ( ) ; if ( output != null ) output . close ( ) ; } return output . toByteArray ( ) ; }
tr	5	public String getString ( String key ) { for ( int i = messages . size ( ) - 1 ; i >= 0 ; i -- ) { Object messageContainer = messages . get ( i ) ; if ( messageContainer instanceof Properties && ( ( Properties ) messageContainer ) . containsKey ( key ) ) return ( ( Properties ) messageContainer ) . getProperty ( key ) ; if ( messageContainer instanceof ResourceBundle && containsKey ( ( ResourceBundle ) messageContainer , key ) ) return ( ( ResourceBundle ) messageContainer ) . getString ( key ) ; } return null ; }
tr	1	public void saveToFile ( ) throws IOException { try ( PrintWriter out = new PrintWriter ( new FileWriter ( this . name + ".hist" ) ) ) { out . println ( this . count ) ; out . println ( this . min ) ; out . println ( this . max ) ; for ( Integer b : bins ) out . println ( b ) ; } }
tr	1	public void setPlayingOrder ( Player player1 , Player player2 ) { double randomValue = Math . random ( ) ; if ( randomValue < 0.5 ) { this . currentPlayer = player1 ; this . otherPlayer = player2 ; } else { this . otherPlayer = player2 ; this . currentPlayer = player1 ; } }
tr	4	public boolean checkType ( Object obj ) { return ( ( obj instanceof java . lang . byte && ( ( byte ) obj ) . byteValue ( ) >= 0 ) || ( obj instanceof java . lang . short && ( ( short ) obj ) . shortValue ( ) >= 0 && ( ( short ) obj ) . shortValue ( ) <= 255 ) ) ; }
tr	7	private String getMPatternCode ( ) { int posIni = _position ; for ( ; ; ) { if ( _mumpsPattern . length ( ) <= _position ) { break ; } if ( isQuantifier ( _mumpsPattern . charAt ( _position ) ) || ( _mumpsPattern . charAt ( _position ) == ( ) || ( _mumpsPattern . charAt ( _position ) ==   ) || ( _mumpsPattern . charAt ( _position ) == ) ) ) { break ; } if ( ! patternAtomTranslateTable . containsKey ( _mumpsPattern . charAt ( _position ) ) ) { throw new IllegalArgumentException ( "Code Pattern inv\u00E1lido encontrado: " . concat ( _mumpsPattern . substring ( _position , _position + 1 ) ) . concat ( ". Na posi\u00E7\u00E3o: " . concat ( String . valueOf ( _position ) ) ) ) ; } _position ++ ; } return _mumpsPattern . substring ( posIni , _position ) ; }
tr	6	public void setControl ( MyEvent event , int key ) { switch ( event ) { case UP : up = key ; break ; case DOWN : down = key ; break ; case LEFT : left = key ; break ; case RIGHT : right = key ; break ; case BOMB : bomb = key ; break ; case SURREND : surrend = key ; break ; default : break ; } }
tr	9	public static void main ( String argv [ ] ) throws internal_error , java . io . IOException , java . lang . Exception { boolean did_output = false ; start_time = System . currentTimeMillis ( ) ; parse_args ( argv ) ; emit . set_lr_values ( lr_values ) ; if ( print_progress ) System . err . println ( "Opening files..." ) ; input_file = new BufferedInputStream ( System . in ) ; prelim_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Parsing specification from standard input..." ) ; parse_grammar_spec ( ) ; parse_end = System . currentTimeMillis ( ) ; if ( lexer . error_count == 0 ) { if ( print_progress ) System . err . println ( "Checking specification..." ) ; check_unused ( ) ; check_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Building parse tables..." ) ; build_parser ( ) ; build_end = System . currentTimeMillis ( ) ; if ( lexer . error_count != 0 ) { opt_dump_tables = false ; } else { if ( print_progress ) System . err . println ( "Writing parser..." ) ; open_files ( ) ; emit_parser ( ) ; did_output = true ; } } emit_end = System . currentTimeMillis ( ) ; if ( opt_dump_grammar ) dump_grammar ( ) ; if ( opt_dump_states ) dump_machine ( ) ; if ( opt_dump_tables ) dump_tables ( ) ; dump_end = System . currentTimeMillis ( ) ; if ( print_progress ) System . err . println ( "Closing files..." ) ; close_files ( ) ; if ( ! no_summary ) emit_summary ( did_output ) ; if ( lexer . error_count != 0 ) System . exit ( 100 ) ; }
tr	4	@ Override public void processDrawing ( ) { if ( rsAlreadyLoaded || loadingError || genericLoadingError ) { showErrorScreen ( ) ; return ; } drawCycle ++ ; if ( ! loggedIn ) drawLoginScreen ( false ) ; else drawGameScreen ( ) ; anInt1213 = 0 ; }
tr	9	public OBJModel ( String fileName ) { positions = new ArrayList < Vector3f > ( ) ; texCoords = new ArrayList < Vector2f > ( ) ; normals = new ArrayList < Vector3f > ( ) ; indices = new ArrayList < OBJIndex > ( ) ; hasTexCoords = false ; hasNormals = false ; BufferedReader meshReader = null ; try { meshReader = new BufferedReader ( new FileReader ( fileName ) ) ; String line ; while ( ( line = meshReader . readLine ( ) ) != null ) { String [ ] tokens = line . split ( " " ) ; tokens = Util . removeEmptyStrings ( tokens ) ; if ( tokens . length == 0 || tokens [ 0 ] . equals ( "#" ) ) continue ; else if ( tokens [ 0 ] . equals ( "v" ) ) { positions . add ( new Vector3f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) , float . valueOf ( tokens [ 3 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "vt" ) ) { texCoords . add ( new Vector2f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "vn" ) ) { normals . add ( new Vector3f ( float . valueOf ( tokens [ 1 ] ) , float . valueOf ( tokens [ 2 ] ) , float . valueOf ( tokens [ 3 ] ) ) ) ; } else if ( tokens [ 0 ] . equals ( "f" ) ) { for ( int i = 0 ; i < tokens . length - 3 ; i ++ ) { indices . add ( parseOBJIndex ( tokens [ 1 ] ) ) ; indices . add ( parseOBJIndex ( tokens [ 2 + i ] ) ) ; indices . add ( parseOBJIndex ( tokens [ 3 + i ] ) ) ; } } } meshReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	6	private void method130 ( int j , int k , int l , int i1 , int j1 , int k1 , int l1 , int i2 , int j2 ) { Class30_Sub1 class30_sub1 = null ; for ( Class30_Sub1 class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetFirst ( ) ; class30_sub1_1 != null ; class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetNext ( ) ) { if ( class30_sub1_1 . anInt1295 != l1 || class30_sub1_1 . anInt1297 != i2 || class30_sub1_1 . anInt1298 != j1 || class30_sub1_1 . anInt1296 != i1 ) continue ; class30_sub1 = class30_sub1_1 ; break ; } if ( class30_sub1 == null ) { class30_sub1 = new Class30_Sub1 ( ) ; class30_sub1 . anInt1295 = l1 ; class30_sub1 . anInt1296 = i1 ; class30_sub1 . anInt1297 = i2 ; class30_sub1 . anInt1298 = j1 ; method89 ( class30_sub1 ) ; aClass19_1179 . insertHead ( class30_sub1 ) ; } class30_sub1 . anInt1291 = k ; class30_sub1 . anInt1293 = k1 ; class30_sub1 . anInt1292 = l ; class30_sub1 . anInt1302 = j2 ; class30_sub1 . anInt1294 = j ; }
tr	2	@ Test public void testTwoDimensionalArrays ( ) { final int rows = 3 ; final int cols = 4 ; int count = 0 ; int [ ] [ ] matrix = new int [ rows ] [ cols ] ; for ( int row = 0 ; row < rows ; row ++ ) { for ( int col = 0 ; col < cols ; col ++ ) { matrix [ row ] [ col ] = count ++ ; } } assertEquals ( 11 , matrix [ 2 ] [ 3 ] ) ; assertEquals ( 6 , matrix [ 1 ] [ 2 ] ) ; }
tr	9	public void executeMethod ( Method parent , String [ ] args , T player , Object [ ] methodArgs , int level ) throws CommandException { String cmdName = args [ level ] ; Map < String , Method > map = commands . get ( parent ) ; Method method = map . get ( cmdName . toLowerCase ( ) ) ; if ( method == null ) { if ( parent == null ) { throw new UnhandledCommandException ( ) ; } else { throw new MissingNestedCommandException ( "Unknown command: " + cmdName , getNestedUsage ( args , level - 1 , parent , player ) ) ; } } checkPermission ( player , method ) ; int argsCount = args . length - 1 - level ; if ( method . isAnnotationPresent ( NestedCommand . class ) ) { if ( argsCount == 0 ) { throw new MissingNestedCommandException ( "Sub-command required." , getNestedUsage ( args , level , method , player ) ) ; } else { executeMethod ( method , args , player , methodArgs , level + 1 ) ; } } else if ( method . isAnnotationPresent ( CommandAlias . class ) ) { CommandAlias aCmd = method . getAnnotation ( CommandAlias . class ) ; executeMethod ( parent , aCmd . value ( ) , player , methodArgs , level ) ; } else { Command cmd = method . getAnnotation ( Command . class ) ; String [ ] newArgs = new String [ args . length - level ] ; System . arraycopy ( args , level , newArgs , 0 , args . length - level ) ; final Set < Character > valueFlags = new HashSet < Character > ( ) ; char [ ] flags = cmd . flags ( ) . toCharArray ( ) ; Set < Character > newFlags = new HashSet < Character > ( ) ; for ( int i = 0 ; i < flags . length ; ++ i ) { if ( flags . length > i + 1 && flags [ i + 1 ] == : ) { valueFlags . add ( flags [ i ] ) ; ++ i ; } newFlags . add ( flags [ i ] ) ; } CommandContext context = new CommandContext ( newArgs , valueFlags ) ; if ( context . argsLength ( ) < cmd . min ( ) ) { throw new CommandUsageException ( "Too few arguments." , getUsage ( args , level , cmd ) ) ; } if ( cmd . max ( ) != - 1 && context . argsLength ( ) > cmd . max ( ) ) { throw new CommandUsageException ( "Too many arguments." , getUsage ( args , level , cmd ) ) ; } if ( ! cmd . anyFlags ( ) ) { for ( char flag : context . getFlags ( ) ) { if ( ! newFlags . contains ( flag ) ) { throw new CommandUsageException ( "Unknown flag: " + flag , getUsage ( args , level , cmd ) ) ; } } } methodArgs [ 0 ] = context ; Object instance = instances . get ( method ) ; invokeMethod ( parent , args , player , method , instance , methodArgs , argsCount ) ; } }
tr	7	@ SuppressWarnings ( "unchecked" ) public static < T > Grammar < T > get ( class < T > class1 ) { if ( grammarMap . containsKey ( class1 ) ) { return ( Grammar < T > ) grammarMap . get ( class1 ) ; } try { Subclasses annotation_subclass = class1 . getAnnotation ( Subclasses . class ) ; if ( null != annotation_subclass ) { ChoiceGrammar < T > grammar = new ChoiceGrammar < T > ( class1 ) ; grammarMap . put ( class1 , grammar ) ; for ( class < ? > g : annotation_subclass . value ( ) ) { grammar . add ( ( Grammar < T > ) get ( g ) ) ; } return grammar ; } else { FieldSequenceGrammar < T > grammar = new FieldSequenceGrammar < T > ( class1 ) ; grammarMap . put ( class1 , grammar ) ; Field [ ] declaredFields = class1 . getDeclaredFields ( ) ; assert ( 0 < declaredFields . length ) ; for ( Field field : declaredFields ) { if ( 0 != ( field . getModifiers ( ) & Modifier . static ) ) { continue ; } grammar . add ( FieldGrammar . get ( field ) ) ; } return grammar ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
tr	1	public boolean isWrapperFor ( class < ? > iface ) throws SQLException { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
tr	0	public static JSONArray toJSONArray ( JSONArray names , String string ) throws JSONException { return toJSONArray ( names , new JSONTokener ( string ) ) ; }
tr	3	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { PrintWriter out = response . getWriter ( ) ; request . setCharacterEncoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setContentType ( "text/html;charset=UTF-8" ) ; search com = new search ( ) ; String id [ ] = request . getParameterValues ( "id" ) ; String docTellId [ ] = request . getParameterValues ( "docTellId" ) ; String docId [ ] = request . getParameterValues ( "docId" ) ; String docTellContent [ ] = request . getParameterValues ( "docTellContent" ) ; String excuteDate [ ] = request . getParameterValues ( "excuteDate" ) ; String excuteId [ ] = request . getParameterValues ( "excuteId" ) ; String docTellType [ ] = request . getParameterValues ( "docTellType" ) ; String stopDate [ ] = request . getParameterValues ( "stopDate" ) ; String patientId = request . getParameter ( "patientId" ) ; for ( int i = 0 ; i < docTellId . length ; i ++ ) { r = com . docTellFind ( id [ i ] ) ; if ( r ) { e = com . docTellUpdate ( id [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] ) ; } else { System . out . println ( docTellId [ i ] ) ; e = com . docTellInsert ( id [ i ] , docTellId [ i ] , docId [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] , patientId ) ; } } if ( e ) { response . sendRedirect ( request . getContextPath ( ) + "/wardManagement/patientList.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } }
tr	4	@ Override public void optionSelected ( int index , String option , PrintWriter out ) { if ( option . equals ( "Back" ) ) { appUI . setScreen ( source ) ; } else if ( option . equals ( "Edit name" ) ) { appUI . setScreen ( new EditActivityNameScreen ( appUI , this , activity ) ) ; } else if ( option . equals ( "Edit start date" ) ) { appUI . setScreen ( new EditActivityStartYearScreen ( appUI , this , activity ) ) ; } else if ( option . equals ( "Edit end date" ) ) { appUI . setScreen ( new EditActivityEndYearScreen ( appUI , this , activity ) ) ; } }
tr	9	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ ( int ) i ] ; } } } return out ; } }
tr	7	public JMenuBar createMenuBar ( ) { JMenuBar menuBar = new JMenuBar ( ) ; menuBar . putClientProperty ( "jgoodies.headerStyle" , "Both" ) ; JMenu componentsMenu = new JMenu ( "Components" ) ; componentsMenu . setMnemonic ( C ) ; menuBar . add ( componentsMenu ) ; for ( int i = 0 ; i < beans . length ; i ++ ) { Icon icon ; JMenuItem menuItem ; try { URL iconURL = beans [ i ] . getClass ( ) . getResource ( "images/" + beans [ i ] . getName ( ) + "Color16.gif" ) ; icon = new ImageIcon ( iconURL ) ; menuItem = new JMenuItem ( beans [ i ] . getName ( ) , icon ) ; } catch ( Exception e ) { System . out . println ( "JCalendarDemo.createMenuBar(): " + e ) ; menuItem = new JMenuItem ( beans [ i ] . getName ( ) ) ; } componentsMenu . add ( menuItem ) ; final JComponent bean = beans [ i ] ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { installBean ( bean ) ; } } ; menuItem . addActionListener ( actionListener ) ; } UIManager . LookAndFeelInfo [ ] lnfs = UIManager . getInstalledLookAndFeels ( ) ; ButtonGroup lnfGroup = new ButtonGroup ( ) ; JMenu lnfMenu = new JMenu ( "Look&Feel" ) ; lnfMenu . setMnemonic ( L ) ; menuBar . add ( lnfMenu ) ; for ( int i = 0 ; i < lnfs . length ; i ++ ) { if ( ! lnfs [ i ] . getName ( ) . equals ( "CDE/Motif" ) ) { JRadioButtonMenuItem rbmi = new JRadioButtonMenuItem ( lnfs [ i ] . getName ( ) ) ; lnfMenu . add ( rbmi ) ; rbmi . setSelected ( UIManager . getLookAndFeel ( ) . getName ( ) . equals ( lnfs [ i ] . getName ( ) ) ) ; rbmi . putClientProperty ( "lnf name" , lnfs [ i ] ) ; rbmi . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent ie ) { JRadioButtonMenuItem rbmi2 = ( JRadioButtonMenuItem ) ie . getSource ( ) ; if ( rbmi2 . isSelected ( ) ) { UIManager . LookAndFeelInfo info = ( UIManager . LookAndFeelInfo ) rbmi2 . getClientProperty ( "lnf name" ) ; try { UIManager . setLookAndFeel ( info . getClassName ( ) ) ; SwingUtilities . updateComponentTreeUI ( JCalendarDemo . this ) ; BasicSplitPaneDivider divider = ( ( BasicSplitPaneUI ) splitPane . getUI ( ) ) . getDivider ( ) ; if ( divider != null ) { divider . setBorder ( null ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( "Unable to set UI " + e . getMessage ( ) ) ; } } } } ) ; lnfGroup . add ( rbmi ) ; } } JMenu helpMenu = new JMenu ( "Help" ) ; helpMenu . setMnemonic ( H ) ; JMenuItem aboutItem = helpMenu . add ( new AboutAction ( this ) ) ; aboutItem . setMnemonic ( A ) ; aboutItem . setAccelerator ( KeyStroke . getKeyStroke ( A , java . awt . Event . CTRL_MASK ) ) ; menuBar . add ( helpMenu ) ; return menuBar ; }
tr	4	public Set < State > getAcceptStates ( ) { expandSingleton ( ) ; HashSet < State > accepts = new HashSet < State > ( ) ; HashSet < State > visited = new HashSet < State > ( ) ; LinkedList < State > worklist = new LinkedList < State > ( ) ; worklist . add ( initial ) ; visited . add ( initial ) ; while ( worklist . size ( ) > 0 ) { State s = worklist . removeFirst ( ) ; if ( s . accept ) accepts . add ( s ) ; for ( Transition t : s . transitions ) if ( ! visited . contains ( t . to ) ) { visited . add ( t . to ) ; worklist . add ( t . to ) ; } } return accepts ; }
tr	2	@ Test public void insertTest ( ) { final String type = "executeQueryTest" ; final Database connect = new Database ( "questions_test" ) ; final Hashtable < enum < ? > , Object > vals = new Hashtable < enum < ? > , Object > ( ) ; vals . put ( DatabaseAbstractQuestion . Column . TYPE , type ) ; vals . put ( DatabaseAbstractQuestion . Column . SHOW , "TRUE" ) ; connect . insert ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ; assertNotNull ( connect . select ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ) ; connect . delete ( DatabaseAbstractQuestion . TABLE_NAME , vals ) ; connect . disconnect ( ) ; }
tr	6	boolean completedExpenseFields ( ) { if ( event . getExpense ( ) . size ( ) == 0 ) { return false ; } for ( Expense expenseCheck : event . getExpense ( ) ) { if ( expenseCheck . getItemName ( ) . equals ( "" ) || expenseCheck . getQuantity ( ) == 0 || expenseCheck . getUnitCost ( ) == 0.0 || expenseCheck . getTotalCost ( ) == 0.0 ) return false ; } return true ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FormMenu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { } } ) ; }
tr	9	public FractOutPanel ( ) { zoomListeners = new Vector < IZoomListener > ( ) ; layerPane = new JLayeredPane ( ) ; drawPanel = new JPanel ( ) { @ Override public void paint ( Graphics g ) { g . setColor ( AppManager . getInstance ( ) . getUserPrefs ( ) . getBackgroundColor ( ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; if ( fractImage != null ) { g . drawImage ( fractImage , drawOffset . x , drawOffset . y , this ) ; } } } ; drawPanel . addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { mouseMoved = false ; mouseStartPoint = e . getPoint ( ) ; } public void mouseReleased ( MouseEvent e ) { if ( moveMode == MOVE_MODE_ZOOM ) { if ( mouseMoved ) { performRubberbandZoom ( rubberBand . getX ( ) , rubberBand . getY ( ) , rubberBand . getWidth ( ) , rubberBand . getHeight ( ) ) ; } else { performClickZoom ( e . getPoint ( ) . x , e . getPoint ( ) . y ) ; } rubberBand . setVisible ( false ) ; } if ( moveMode == MOVE_MODE_DRAG ) { if ( mouseStartPoint != null ) { int dx = e . getPoint ( ) . x - mouseStartPoint . x ; int dy = e . getPoint ( ) . y - mouseStartPoint . y ; if ( dx != 0 || dy != 0 ) { performDragPan ( dx , dy ) ; } } } drawOffset . x = 0 ; drawOffset . y = 0 ; mouseMoved = false ; } } ) ; drawPanel . addMouseMotionListener ( new MouseAdapter ( ) { public void mouseDragged ( MouseEvent e ) { mouseMoved = true ; if ( mouseStartPoint != null ) { if ( moveMode == MOVE_MODE_ZOOM ) { Dimension evtBound = new Dimension ( Math . abs ( e . getPoint ( ) . x - mouseStartPoint . x ) , Math . abs ( e . getPoint ( ) . y - mouseStartPoint . y ) ) ; int left = MathLib . minInt ( mouseStartPoint . x , e . getPoint ( ) . x ) ; int top = MathLib . minInt ( mouseStartPoint . y , e . getPoint ( ) . y ) ; rubberBand . setBounds ( left , top , evtBound . width , evtBound . height ) ; rubberBand . setVisible ( true ) ; } if ( moveMode == MOVE_MODE_DRAG ) { drawOffset . x = e . getPoint ( ) . x - mouseStartPoint . x ; drawOffset . y = e . getPoint ( ) . y - mouseStartPoint . y ; drawPanel . repaint ( ) ; } } } } ) ; rubberBand = new JPanel ( ) { @ Override public void paint ( Graphics g ) { g . setColor ( Color . BLACK ) ; g . drawRect ( 1 , 1 , this . getWidth ( ) - 1 , this . getHeight ( ) - 1 ) ; g . setColor ( Color . WHITE ) ; g . drawRect ( 0 , 0 , this . getWidth ( ) - 2 , this . getHeight ( ) - 2 ) ; } } ; rubberBand . setOpaque ( false ) ; rubberBand . setVisible ( false ) ; layerPane . add ( drawPanel , JLayeredPane . DEFAULT_LAYER ) ; layerPane . add ( rubberBand , JLayeredPane . DRAG_LAYER ) ; this . setViewportView ( layerPane ) ; }
tr	0	@ Before public void setUp ( ) { DB . setDataSource ( new SQLite ( ) ) ; }
tr	8	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	6	public static void drawCell ( Graphics g , Rectangle bounds , JTree tree , TreePath path , int row ) { boolean isRowSelected = tree . isRowSelected ( row ) ; DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; if ( node instanceof LeafNode ) { Color colorTmp = colorLeaf ; Color colorBorderTmp = colorLeafBorder ; if ( isRowSelected ) { colorTmp = colorLeafSel ; colorBorderTmp = colorLeafSelBorder ; } else if ( ( ( LeafNode ) node ) . getDownload ( ) != null && ( ( LeafNode ) node ) . getDownload ( ) . isPaused ( ) ) { colorTmp = colorLeafPause ; colorBorderTmp = colorLeafPauseBorder ; } else if ( ( ( LeafNode ) node ) . getDownload ( ) != null && ( ( LeafNode ) node ) . getDownload ( ) . isFaulty ( ) ) { colorTmp = colorLeafFaulty ; colorBorderTmp = colorLeafFaultyBorder ; } Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . setColor ( colorTmp ) ; g2 . fillRect ( tree . getVisibleRect ( ) . x + 4 , bounds . y + 2 , Math . round ( ( ( tree . getVisibleRect ( ) . width - 10 ) * ( ( LeafNode ) node ) . getDownPerc ( ) * 100 ) / 100 ) , bounds . height - 5 ) ; g2 . setColor ( colorBorderTmp ) ; g2 . drawRect ( tree . getVisibleRect ( ) . x + 4 , bounds . y + 2 , tree . getVisibleRect ( ) . width - 10 , bounds . height - 5 ) ; g2 . dispose ( ) ; } }
tr	8	public int [ ] [ ] makeTileMap ( ArrayList < GameEntity > entities ) { int width = 1 ; int height = 1 ; startX = entities . get ( 0 ) . getStartX ( ) ; startY = entities . get ( 0 ) . getStartY ( ) ; int tileSize = GlobalSettings . tileSize ; for ( int i = 1 ; i < entities . size ( ) ; i ++ ) { int entX = entities . get ( i ) . getStartX ( ) ; int entY = entities . get ( i ) . getStartY ( ) ; if ( entX < startX ) { if ( ( startX - entX ) / tileSize == 0 ) System . out . println ( "Zero added" ) ; width += ( ( startX - entX ) / tileSize ) ; startX = entX ; } if ( entY < startY ) { height += ( ( startY - entY ) / tileSize ) ; startY = entY ; } if ( entX > startX + width * tileSize ) { width += ( ( entX - ( startX + width * tileSize ) ) / tileSize ) ; } if ( entY > startY + height * tileSize ) { height += ( ( entY - ( startY + height * tileSize ) ) / tileSize ) ; } } height ++ ; width ++ ; int [ ] [ ] tileMap = new int [ height ] [ width ] ; System . out . println ( "Width :: " + width + " Height :: " + height ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { boolean block = entities . get ( i ) . isBlock ( ) ; if ( block ) { int xpos = ( entities . get ( i ) . getStartX ( ) - startX ) / tileSize ; int ypos = ( entities . get ( i ) . getStartY ( ) - startY ) / tileSize ; tileMap [ ypos ] [ xpos ] = 1 ; } } return tileMap ; }
tr	8	@ SuppressWarnings ( "unchecked" ) private void initialize ( ) { List < ObjectColumn < T >> columns = new LinkedList < ObjectColumn < T >> ( ) ; Field [ ] fields = type . getDeclaredFields ( ) ; for ( Field field : fields ) { for ( Annotation annotation : field . getDeclaredAnnotations ( ) ) { if ( annotation instanceof Column ) { Column _column = ( Column ) annotation ; ObjectColumn < T > column = new FieldColumn < T > ( _column , type , field ) ; columns . add ( column ) ; if ( _column . index ( ) >= 0 ) { column . setIndex ( _column . index ( ) ) ; } } } } Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { for ( Annotation annotation : method . getDeclaredAnnotations ( ) ) { if ( annotation instanceof Column ) { Column _column = ( Column ) annotation ; ObjectColumn < T > column = new MethodColumn < T > ( _column , type , method ) ; columns . add ( column ) ; if ( _column . index ( ) >= 0 ) { column . setIndex ( _column . index ( ) ) ; } } } } Collections . sort ( columns ) ; this . columns = columns . toArray ( new ObjectColumn [ columns . size ( ) ] ) ; }
tr	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && Region . plane != plane ) { gameScreenImageProducer . initDrawingArea ( ) ; fontPlain . drawCentredText ( "Loading - please wait." , 257 , 151 , 0 ) ; fontPlain . drawCentredText ( "Loading - please wait." , 256 , 150 , ffffff ) ; gameScreenImageProducer . drawGraphics ( 4 , super . gameGraphics , 4 ) ; loadingStage = 1 ; loadRegionTime = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int successful = initialiseRegionLoading ( ) ; if ( successful != 0 && System . currentTimeMillis ( ) - loadRegionTime > 360000 ) { signlink . reporterror ( enteredUsername + " glcfb " + serverSessionKey + " " + successful + " " + lowMemory + " " + caches [ 0 ] + " " + onDemandFetcher . immediateRequestCount ( ) + " " + plane + " " + regionX + " " + regionY ) ; loadRegionTime = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != lastRegionId ) { lastRegionId = plane ; renderMinimap ( plane ) ; } }
tr	7	public String getPopulationDetails ( Field field ) { StringBuffer buffer = new StringBuffer ( ) ; if ( ! countsValid ) { generateCounts ( field ) ; } for ( class key : counters . keySet ( ) ) { Counter info = counters . get ( key ) ; int stringLength = info . getName ( ) . length ( ) ; buffer . append ( info . getName ( ) . substring ( 10 , stringLength ) ) ; buffer . append ( ": " ) ; buffer . append ( info . getCount ( ) ) ; buffer . append (   ) ; if ( info . getName ( ) . equals ( "src.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Bear" ) ) { bearCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Grass" ) ) { grassCount = info . getCount ( ) ; } } return buffer . toString ( ) ; }
tr	9	public static BufferedImage rotate ( BufferedImage src , Rotation rotation , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( rotation == null ) throw new IllegalArgumentException ( "rotation cannot be null" ) ; if ( DEBUG ) log ( 0 , "Rotating Image [%s]..." , rotation ) ; int newWidth = src . getWidth ( ) ; int newHeight = src . getHeight ( ) ; AffineTransform tx = new AffineTransform ( ) ; switch ( rotation ) { case CW_90 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( newWidth , 0 ) ; tx . rotate ( Math . toRadians ( 90 ) ) ; break ; case CW_270 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( 0 , newHeight ) ; tx . rotate ( Math . toRadians ( - 90 ) ) ; break ; case CW_180 : tx . translate ( newWidth , newHeight ) ; tx . rotate ( Math . toRadians ( 180 ) ) ; break ; case FLIP_HORZ : tx . translate ( newWidth , 0 ) ; tx . scale ( - 1.0 , 1.0 ) ; break ; case FLIP_VERT : tx . translate ( 0 , newHeight ) ; tx . scale ( 1.0 , - 1.0 ) ; break ; } BufferedImage result = createOptimalImage ( src , newWidth , newHeight ) ; Graphics2D g2d = ( Graphics2D ) result . createGraphics ( ) ; g2d . drawImage ( src , tx , null ) ; g2d . dispose ( ) ; if ( DEBUG ) log ( 0 , "Rotation Applied in %d ms  result [width=%d  height=%d]" , System . currentTimeMillis ( ) - t , result . getWidth ( ) , result . getHeight ( ) ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	4	public taskRetablirPaquets ( Paquet f , int num ) { this . frere = f ; this . numeroMort = num ; for ( int i = 0 ; i < Global . NOMBRESOUSPAQUETS ; i ++ ) b [ i ] = ByteBuffer . allocate ( ( int ) ( Global . PAQUET_SIZE + 3 ) ) ; this . reconstruit = new Paquet ( frere . idMachine - frere . idInterne + numeroMort , frere . owner ) ; try { for ( int i = 0 ; i < Global . NOMBRESOUSPAQUETS ; i ++ ) { if ( i != numeroMort ) { clientSocket [ i ] = SocketChannel . open ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	0	public void testgeneroiNegNeg1 ( ) { Alilausegeneroija A = new Alilausegeneroija ( "not a and not b" ) ; Propositiotaulu taulu = new Propositiotaulu ( ) ; asetaTotuudetAB ( 0 , 0 , taulu ) ; assertEquals ( true , A . generoi ( taulu ) . totuus ( ) ) ; }
tr	7	private String getTextOpciones ( int i ) { int opcion = 0 ; if ( i == opcion ++ ) return "Juego..." ; if ( i == opcion ++ ) return "Graficos..." ; if ( i == opcion ++ ) return "Sonidos..." ; if ( i == opcion ++ ) return "Controles..." ; if ( i == opcion ++ ) return "Atajos del teclado..." ; if ( i == opcion ++ ) return "Directorios..." ; if ( i == opcion ++ ) return "Pantalla completa" ; return "Mostrar FPS" ; }
tr	8	private void initContent ( ) { setBounds ( 100 , 100 , 450 , 306 ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; contentPanel . setLayout ( null ) ; lblName = new JLabel ( "Name:" ) ; lblName . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblName . setBounds ( 21 , 22 , 86 , 20 ) ; contentPanel . add ( lblName ) ; lblLevel = new JLabel ( "Level:" ) ; lblLevel . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblLevel . setBounds ( 21 , 51 , 86 , 20 ) ; contentPanel . add ( lblLevel ) ; { lblCapacity = new JLabel ( "Capacity:" ) ; lblCapacity . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblCapacity . setBounds ( 21 , 82 , 86 , 20 ) ; contentPanel . add ( lblCapacity ) ; } { lblStudentAge = new JLabel ( "Student Age:" ) ; lblStudentAge . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblStudentAge . setBounds ( 21 , 113 , 86 , 20 ) ; contentPanel . add ( lblStudentAge ) ; } { lblTeacher = new JLabel ( "Teacher(s):" ) ; lblTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblTeacher . setBounds ( 21 , 144 , 86 , 20 ) ; contentPanel . add ( lblTeacher ) ; } { panel_1 = new JPanel ( ) ; panel_1 . setBorder ( new TitledBorder ( UIManager . getBorder ( "TitledBorder.border" ) , "Schedule" , TitledBorder . LEADING , TitledBorder . TOP , null , new Color ( 0 , 0 , 0 ) ) ) ; panel_1 . setBounds ( 277 , 6 , 155 , 158 ) ; contentPanel . add ( panel_1 ) ; panel_1 . setLayout ( null ) ; JButton btnAdd = new JButton ( "Add" ) ; btnAdd . setFocusTraversalKeysEnabled ( false ) ; btnAdd . setFocusable ( false ) ; btnAdd . setFocusPainted ( false ) ; btnAdd . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnAdd . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnAdd . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnAdd . setBounds ( 10 , 13 , 67 , 23 ) ; btnAdd . setIcon ( StaticRes . ADD16_ICON ) ; btnAdd . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ScheduleSelectDialog ssd ; try { Group_schedule group_schedule = new Group_schedule ( ) ; group_schedule . setGroup ( group . getId ( ) ) ; ssd = new ScheduleSelectDialog ( null , "Schedule for " + group . getName ( ) , ModalityType . DOCUMENT_MODAL , GroupsDialog . this , group_schedule ) ; ssd . setVisible ( true ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } ) ; panel_1 . add ( btnAdd ) ; DefaultListModel listModel = new DefaultListModel ( ) ; for ( Group_schedule obj : this . schedule_list ) { listModel . addElement ( obj ) ; } list = new JList ( listModel ) ; list . setVisibleRowCount ( 5 ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . setCellRenderer ( new ListCellRenderer ( ) { protected DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer ( ) ; @ Override public Component getListCellRendererComponent ( JList list , Object o , int i , boolean selected , boolean cellHasFocus ) { JLabel label = ( JLabel ) defaultRenderer . getListCellRendererComponent ( list , o , i , selected , cellHasFocus ) ; Group_schedule gschedule = ( Group_schedule ) o ; label . setText ( gschedule . getName ( ) ) ; return label ; } } ) ; list . setBounds ( 10 , 40 , 135 , 107 ) ; panel_1 . add ( list ) ; JButton btnRemove = new JButton ( "Remove" ) ; btnRemove . setBounds ( 78 , 13 , 67 , 23 ) ; btnRemove . setFocusTraversalKeysEnabled ( false ) ; btnRemove . setFocusable ( false ) ; btnRemove . setFocusPainted ( false ) ; btnRemove . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnRemove . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnRemove . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnRemove . setIcon ( StaticRes . DELETE16_ICON ) ; btnRemove . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { int index = list . getSelectedIndex ( ) ; Group_schedule gschedule = ( Group_schedule ) list . getSelectedValue ( ) ; if ( index >= 0 ) { ( ( DefaultListModel ) list . getModel ( ) ) . removeElement ( gschedule ) ; lblDispTeacher . setText ( getTeacher ( getTeacherFromList ( ) ) ) ; } } } ) ; panel_1 . add ( btnRemove ) ; } txtName = new JTextField ( ) ; txtName . setBounds ( 117 , 24 , 150 , 20 ) ; txtName . setText ( this . name ) ; contentPanel . add ( txtName ) ; txtName . setColumns ( 10 ) ; { txtCapacity = new JTextField ( ) ; txtCapacity . setColumns ( 10 ) ; txtCapacity . setText ( String . valueOf ( this . capacity ) ) ; txtCapacity . setBounds ( 117 , 84 , 150 , 20 ) ; txtCapacity . addKeyListener ( new KeyAdapter ( ) { public void keyTyped ( KeyEvent ke ) { char c = ke . getKeyChar ( ) ; if ( ! Character . isDigit ( c ) ) ke . consume ( ) ; } } ) ; contentPanel . add ( txtCapacity ) ; } LevelDAO lDAO = new LevelDAO ( db . connection ) ; cbLevel = new JComboBox ( ) ; if ( this . level_id < 1 ) { Level l = new Level ( ) ; l . setName ( "Select level" ) ; l . setId ( 0 ) ; cbLevel . addItem ( l ) ; } List < Level > levelList = lDAO . getLevelList ( ) ; for ( Level level : levelList ) { cbLevel . addItem ( level ) ; if ( level . getId ( ) == this . level_id ) { cbLevel . setSelectedItem ( level ) ; } } cbLevel . setRenderer ( new ComboBoxRenderer ( ) ) ; cbLevel . setBounds ( 117 , 53 , 150 , 20 ) ; contentPanel . add ( cbLevel ) ; cbStudentAge = new JComboBox ( ) ; cbStudentAge . setBounds ( 117 , 115 , 150 , 20 ) ; contentPanel . add ( cbStudentAge ) ; lblDispTeacher = new JLabel ( getTeacher ( getTeacherFromList ( ) ) ) ; lblDispTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblDispTeacher . setBounds ( 117 , 144 , 150 , 20 ) ; contentPanel . add ( lblDispTeacher ) ; { panel = new JPanel ( ) ; panel . setBorder ( UIManager . getBorder ( "MenuBar.border" ) ) ; FlowLayout flowLayout = ( FlowLayout ) panel . getLayout ( ) ; flowLayout . setAlignment ( FlowLayout . LEFT ) ; getContentPane ( ) . add ( panel , BorderLayout . NORTH ) ; { lblGroup = new JLabel ( "Group" ) ; lblGroup . setFont ( new Font ( "Tahoma" , Font . PLAIN , 18 ) ) ; lblGroup . setIcon ( StaticRes . GROUP48_ICON ) ; panel . add ( lblGroup ) ; } } { JPanel buttonPane = new JPanel ( ) ; buttonPane . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; getContentPane ( ) . add ( buttonPane , BorderLayout . SOUTH ) ; { JButton okButton = new JButton ( "OK" ) ; okButton . setIcon ( StaticRes . OK_ICON ) ; okButton . setActionCommand ( "OK" ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "OK Clicked!" ) ; if ( checkAndSaveGroup ( ) ) { dispose ( ) ; result . returnObject ( GroupsDialog . this . group ) ; } else { } } } ) ; buttonPane . add ( okButton ) ; getRootPane ( ) . setDefaultButton ( okButton ) ; } { JButton cancelButton = new JButton ( "Cancel" ) ; cancelButton . setActionCommand ( "Cancel" ) ; cancelButton . setIcon ( StaticRes . CANCEL_ICON ) ; cancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "Cancel Clicked!" ) ; dispose ( ) ; } } ) ; buttonPane . add ( cancelButton ) ; } } }
tr	5	public static Integer createOfficeObject ( Integer OFFICE_OBJECT_TYPE_ID ) { Integer id = getUniqueId ( ) ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , id ) ; ps . setString ( 2 , "" ) ; ps . setInt ( 3 , OFFICE_OBJECT_TYPE_ID ) ; ps . setInt ( 4 , OfficeObject . ALL_IS_OK ) ; ps . executeUpdate ( ) ; } catch ( MySQLIntegrityConstraintViolationException e ) { e . printStackTrace ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return id ; }
tr	8	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) { return true ; } if ( p == null && q != null ) { return false ; } if ( p != null && q == null ) { return false ; } return ( p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ) ; }
tr	0	public String getInputEncoding ( ) { return pp . getInputEncoding ( ) ; }
tr	2	public static void main ( String [ ] args ) { for ( int i = 1 ; i < 100 ; i ++ ) { if ( i % 2 > 0 ) { System . out . println ( i ) ; } } }
tr	8	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { StringBuilder s1 = new StringBuilder ( ) ; if ( ImportUtilities . getDeserializedRecords ( ) . isEmpty ( ) ) { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "You CAN NOT perform data analytics before deserialization!" + " Please to go back and serialize and deserialize the data!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } else { if ( jCheckBox1 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcPopIncreOnRegionPerYear ( ) ) ; } if ( jCheckBox2 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcMaxAndMinBirhPerStatePerYear ( ) ) ; } if ( jCheckBox3 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . clacMaxAndMinDeathPerStatePerYear ( ) ) ; } if ( jCheckBox4 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcNumOfStateWithPopIncre ( ) ) ; } if ( jCheckBox5 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcNumOfStateWithPopDesc ( ) ) ; } if ( jCheckBox6 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcStateWithMostEstiPopPerYear ( ) ) ; } if ( jCheckBox7 . isSelected ( ) ) { s1 . append ( DataAnalyticsUtilities . calcStateWithLeastEstiPopPerYear ( ) ) ; } jTextPane1 . setText ( s1 . toString ( ) ) ; jTextPane1 . getText ( ) ; } }
tr	3	@ Override public void resumeTransfer ( ) { if ( isActive ( ) ) { logger . log ( Level . SEVERE , "Can't resume an active transfer. Cancel it before" ) ; return ; } logger . log ( Level . INFO , "Resume transfer" ) ; if ( socket != null ) { logger . log ( Level . SEVERE , "Can't resume transfer if socket still exists" ) ; return ; } if ( targetFilestream == null ) { logger . log ( Level . SEVERE , "target filestream doesn't exist anymore!" ) ; transferState = TransferStatus . LocalIOError ; } refreshPartnersPort = true ; self = getCreateOwnThread ( ) ; self . start ( ) ; }
tr	1	public void set_wheelchair_boarding ( String in ) { try { _wheelchair_boarding = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
tr	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
tr	4	public void moveRight ( ) { if ( freezing || ! isGameOn ) { return ; } if ( ! checkMovable ( "RIGHT" ) ) { return ; } setCurrentTokens ( 0 ) ; for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] + 1 ; int y = currentTokens [ i ] [ 1 ] ; tokens [ y ] [ x ] . setType ( currentType ) ; currentTokens [ i ] [ 0 ] = x ; } setDirectingTokens ( ) ; refresh ( ) ; }
tr	1	public CharArraySource ( char [ ] data ) { this ( data , 0 , ( data != null ) ? data . length : - 1 ) ; }
tr	7	public void trace ( int depth ) { if ( Thread . currentThread ( ) != this ) { throw new ErrorException ( "trace() can be called only by the animator thread itself" ) ; } currentDepth = depth ; switch ( animatorState ) { case RUNNING : delay ( ) ; break ; case STOPPING : case STEPPING : breakpoint ( ) ; break ; case CALLING : if ( callDepth < currentDepth ) { delay ( ) ; } else { breakpoint ( ) ; } break ; case TERMINATING : terminate ( ) ; break ; } }
tr	1	private final void processItems ( final List < Step > items ) { for ( final Step item : items ) { item . process ( ) ; } }
tr	1	public long getElapsedMillis ( ) { if ( running ) { return System . currentTimeMillis ( ) - start ; } return stop - start ; }
tr	7	@ Override protected void handleMethodAttribute ( final String name , final byte [ ] data , final int offset , final long length , final ConstantPool constantPool ) { if ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Signature . equals ( name ) ) { parseSignature ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Deprecated . equals ( name ) ) { parseDeprecated ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_Synthetic . equals ( name ) ) { parseSynthetic ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Exceptions . equals ( name ) ) { parseExceptions ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Code . equals ( name ) ) { parseCode ( data , offset , constantPool ) ; } else { System . err . println ( "Unhandled method attribute: " + name ) ; } }
tr	7	@ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { if ( event . isCancelled ( ) ) { return ; } Player player = event . getPlayer ( ) ; if ( preChecks ( player , event . getTo ( ) ) ) { JumpPort port = JumpPorts . getPort ( event . getTo ( ) ) ; if ( checkInstant ( event ) ) { return ; } if ( checkJump ( event ) ) { return ; } if ( checkFall ( event ) ) { return ; } if ( ! ignoredPlayers . contains ( player . getName ( ) ) ) { player . sendMessage ( Lang . get ( "port.triggered" ) . replaceAll ( "%N" , port . getName ( ) ) . replaceAll ( "%D" , port . getDescription ( ) ) ) ; if ( port . getPrice ( ) > 0 ) { player . sendMessage ( Lang . get ( "port.price" ) . replaceAll ( "%P" , "" + port . getPrice ( ) ) ) ; } player . sendMessage ( Lang . get ( "port.triggers" ) ) ; ignoredPlayers . add ( player . getName ( ) ) ; } } }
tr	2	private void jbuttonGetArrivalsFromResNoActionPerformed ( java . awt . event . ActionEvent evt ) { if ( "" . equals ( jTextFieldresNo . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Wrong input" ) ; System . out . println ( jTextFieldresNo . getText ( ) ) ; } else { dflBooking . removeAllElements ( ) ; int resno = Integer . parseInt ( jTextFieldresNo . getText ( ) ) ; Booking arrival = con . findResNumber ( resno ) ; if ( arrival != null ) { dflBooking . addElement ( arrival ) ; } else { jLabelStatusBooking . setText ( "Could not find booking" ) ; } } }
tr	2	public Values < V > values ( ) { if ( values1 == null ) { values1 = new Values ( this ) ; values2 = new Values ( this ) ; } if ( ! values1 . valid ) { values1 . reset ( ) ; values1 . valid = true ; values2 . valid = false ; return values1 ; } values2 . reset ( ) ; values2 . valid = true ; values1 . valid = false ; return values2 ; }
tr	7	private int packSpecifiedFrames ( byte [ ] bytes , int offset , String onlyId , String notId ) throws NotSupportedException { Iterator < ID3v2FrameSet > setIterator = frameSets . values ( ) . iterator ( ) ; while ( setIterator . hasNext ( ) ) { ID3v2FrameSet frameSet = setIterator . next ( ) ; if ( ( onlyId == null || onlyId . equals ( frameSet . getId ( ) ) ) && ( notId == null || ! notId . equals ( frameSet . getId ( ) ) ) ) { Iterator < ID3v2Frame > frameIterator = frameSet . getFrames ( ) . iterator ( ) ; while ( frameIterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) frameIterator . next ( ) ; if ( frame . getDataLength ( ) > 0 ) { byte [ ] frameData = frame . toBytes ( ) ; BufferTools . copyIntoByteBuffer ( frameData , 0 , frameData . length , bytes , offset ) ; offset += frameData . length ; } } } } return offset ; }
tr	6	private static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	7	public class < ? > [ ] genericsTypes ( class < ? > superClazz ) { Type type = getGenericSupertype ( clazz , superClazz ) ; List < class < ? >> types = new LinkedList < class < ? >> ( ) ; if ( type instanceof ParameterizedType ) { Type [ ] paramTypes = ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) ; types . addAll ( evalTypesAsClasses ( paramTypes ) ) ; } else if ( type instanceof GenericArrayType ) { Type paramType = ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ; types . add ( evalTypesAsClasses ( paramType ) . get ( 0 ) ) ; } return types . toArray ( new class < ? > [ types . size ( ) ] ) ; }
tr	3	private int find ( Temporal point ) { int i ; for ( i = 0 ; i < this . points . size ( ) ; ++ i ) { if ( this . points . get ( i ) . getXCoord ( ) == point . getXCoord ( ) && this . points . get ( i ) . getYCoord ( ) == point . getYCoord ( ) ) return i ; } return - 1 ; }
tr	1	@ Override public void execute ( Map < String , Object > map , MainFrame frame ) { String origin = ( String ) map . get ( "Origin" ) ; frame . appendLog ( "Receiving lock request from " + origin ) ; int choice = JOptionPane . showConfirmDialog ( null , "Confirm Lock Request from " + origin + "?" ) ; Map < String , Object > reply = new HashMap < String , Object > ( ) ; Integer event = ( Integer ) map . get ( "Event" ) ; reply . put ( "Event" , event ) ; if ( choice == JOptionPane . YES_OPTION ) { reply . put ( "Reply" , true ) ; LocalInfo . setLocker ( origin ) ; } else { reply . put ( "Reply" , false ) ; } LocalSender . sendConfirmMsg ( Utilities . serialize ( reply ) ) ; }
tr	9	public static void securityGoalRefine ( RequirementGraph req_model , String type , int scope ) throws IOException , ScriptException { String expression_file = req_model . generateFormalExpressionToFile ( scope ) ; String security_model_file = InfoEnum . current_directory + "/dlv/models/security_model_" + req_model . getLayer ( ) . toLowerCase ( ) + ".dl " ; String refine_rule = "" ; if ( type . equals ( InfoEnum . RefinementDimension . ASSET . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_asset.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + expression_file ; } else if ( type . equals ( InfoEnum . RefinementDimension . SECURITY_PROPERTY . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_security_attribute.rule " + expression_file + " " + security_model_file ; } else if ( type . equals ( InfoEnum . RefinementDimension . INTERVAL . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_interval.rule " + expression_file ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > refined_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "and_refined_sec_goal" ) ) { s = s . replaceAll ( "and_refined_sec_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; s = s . replaceAll ( "\\_" , " " ) ; String [ ] sg = s . split ( " " ) ; SecurityGoal refined_goal = ( SecurityGoal ) req_model . findElementById ( sg [ 4 ] ) ; Element asset = null ; if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) || req_model . getLayer ( ) . equals ( InfoEnum . Layer . PHYSICAL . name ( ) ) ) { asset = req_model . findElementById ( sg [ 2 ] ) ; if ( asset == null ) { CommandPanel . logger . severe ( "Asset error" ) ; } } Element re = req_model . findElementById ( sg [ 3 ] ) ; SecurityGoal new_sg = null ; if ( re != null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , refined_goal . getLayer ( ) ) ; if ( asset != null ) { new_sg . setName ( ( new_sg . getImportance ( ) + " " + new_sg . getSecurityAttribute ( ) + " [" + asset . getName ( ) + "  " + new_sg . getInterval ( ) . getName ( ) + "]" ) . replaceAll ( "\\_" , " " ) ) ; } } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } new_sg . owner_text = refined_goal . owner_text ; if ( refined_goal . owner != null ) { refined_goal . owner . getOwnedElement ( ) . add ( new_sg ) ; new_sg . owner = refined_goal . owner ; } else { Actor fake_owner = new Actor ( refined_goal . owner_text , InfoEnum . RequirementElementType . ACTOR . name ( ) , refined_goal . getLayer ( ) ) ; fake_owner . setId ( refined_goal . owner_text ) ; new_sg . owner = fake_owner ; } req_model . getElements ( ) . add ( new_sg ) ; RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_sg , refined_goal ) ; req_model . getLinks ( ) . add ( new_and_refine ) ; refined_goal . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexOf ( refined_goal ) == - 1 ) { refined_elems . add ( refined_goal ) ; } } } } VisualizationFunctions . drawAndRefinement ( refined_elems ) ; }
tr	7	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
tr	1	@ Override public void step ( ) { for ( AgentModel m : agents . values ( ) ) { m . model . step ( ) ; } }
tr	7	public void connect ( TreeLinkNode root ) { if ( root == null || root . left == null || root . right == null ) { return ; } if ( root . left != null ) { root . left . next = root . right ; } if ( root . right != null && root . next != null ) { root . right . next = root . next . left == null ? null : root . next . left ; } connect ( root . left ) ; connect ( root . right ) ; }
tr	6	public Editor ( DefaultMutableTreeNode node , DefaultTreeModel model ) throws InvalidNodeRepresentationException { _node = node ; _model = model ; _children = new ArrayList < > ( ) ; if ( _node . getUserObject ( ) instanceof Song ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = ( Song ) node . getUserObject ( ) ; _playlist = null ; _artist = new JTextField ( _song . getArtist ( ) ) ; _title = new JTextField ( _song . getTitle ( ) ) ; _album = new JTextField ( _song . getAlbum ( ) ) ; _genre = new JTextField ( _song . getGenre ( ) ) ; _year = new JTextField ( _song . getYear ( ) ) ; _name = null ; JLabel artist = new JLabel ( "Artist:" ) ; JLabel title = new JLabel ( "Title:" ) ; JLabel album = new JLabel ( "Album:" ) ; JLabel genre = new JLabel ( "Genre:" ) ; JLabel year = new JLabel ( "Year:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( artist ) ; add ( _artist ) ; add ( title ) ; add ( _title ) ; add ( album ) ; add ( _album ) ; add ( genre ) ; add ( _genre ) ; add ( year ) ; add ( _year ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , artist , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _artist , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _artist , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . WEST , title , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . EAST , _title , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _title , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . WEST , album , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . EAST , _album , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _album , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . WEST , genre , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . EAST , _genre , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _genre , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . WEST , year , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . EAST , _year , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _year , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _year ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _year ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else if ( _node . getUserObject ( ) instanceof Playlist ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = null ; _playlist = ( Playlist ) node . getUserObject ( ) ; _artist = null ; _title = null ; _album = null ; _genre = null ; _year = null ; _name = new JTextField ( _playlist . getName ( ) ) ; JLabel name = new JLabel ( "Title:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( name ) ; add ( _name ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , name , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _name , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _name , 5 , SpringLayout . EAST , name ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _name ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _name ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else { throw new InvalidNodeRepresentationException ( "Node must represent a Song or Playlist" ) ; } }
tr	6	@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { super . startElement ( uri , localName , qName , attributes ) ; if ( qName . equals ( "question" ) ) { String type = attributes . getValue ( "type" ) ; String num = attributes . getValue ( "number" ) ; if ( type != null && num != null ) { int n = Integer . parseInt ( num ) ; if ( type . equals ( "multiple_choice" ) ) this . reader . setContentHandler ( new MultipleChoiceHandler ( this . reader , this , n ) ) ; else if ( type . equals ( "short_answer" ) ) this . reader . setContentHandler ( new ShortAnswerHandler ( this . reader , this , n ) ) ; else if ( type . equals ( "file_submission" ) ) this . reader . setContentHandler ( new FileSubmissionHandler ( this . reader , this , n ) ) ; } } }
tr	5	public void handle ( ActionEvent event ) { if ( event . getSource ( ) == create ) { try { AssetType type = this . type . getSelectionModel ( ) . getSelectedItem ( ) ; Path af = mp . mod . getAssetFolder ( ) ; Path p = af . resolve ( name . getText ( ) + "." + type . getFileExtension ( ) ) ; p = af . relativize ( p ) ; ModToolkit . log . info ( p . toString ( ) ) ; Asset a = Asset . createAsset ( p , type , af ) ; if ( a instanceof JsonAsset ) { JsonObject templ = main . data . getJsonTemplate ( type ) ; if ( templ != null ) { JsonAsset ja = ( JsonAsset ) a ; JsonObject jo = ja . getObject ( ) ; for ( Member m : templ ) { jo . add ( m . getName ( ) , m . getValue ( ) ) ; } } } a . save ( ) ; mp . mod . getAssets ( ) . add ( a ) ; mp . assets . list . getSelectionModel ( ) . select ( a ) ; } catch ( Throwable t ) { Util . handleError ( t , "An error occurred while creating an asset" , "Failed to create asset" ) ; } close ( ) ; } else { close ( ) ; } }
tr	4	public static void pruneCache ( ) { synchronized ( dirSyncObject ) { int limit = Globals . getCacheLimit ( ) ; while ( ! fileList . isEmpty ( ) && limit > 0 && directorySize > limit ) { File oldest = fileList . removeFirst ( ) ; removeFile ( oldest ) ; } if ( Main . craftGUI != null ) { Main . craftGUI . safeSetFileSize ( Integer . toString ( directorySize / 1024 / 1024 ) ) ; } } }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	8	public Integer Alfa ( Integer x , Integer y ) { int z = 0 ; if ( x == 0 && y == 0 ) { z = 1 ; } else if ( x == 0 && y == 1 ) { z = 0 ; } else if ( x == 1 && y == 0 ) { z = 2 ; } else if ( x == 1 && y == 1 ) { z = 1 ; } return z ; }
tr	0	public Type getType ( ) { return type ; }
tr	0	public String getL3DiscntAmt ( ) { return l3DiscntAmt ; }
tr	6	public void reorderList ( ListNode head ) { if ( head != null && head . next != null ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null && fast . next . next != null ) { System . out . println ( "pre " + slow . val + " " + fast . val ) ; slow = slow . next ; fast = fast . next . next ; System . out . println ( "after " + slow . val + " " + fast . val ) ; } ListNode second = slow . next ; slow . next = null ; second = reverseOrder ( second ) ; ListNode p1 = head ; ListNode p2 = second ; while ( p2 != null ) { ListNode temp1 = p1 . next ; ListNode temp2 = p2 . next ; p1 . next = p2 ; p2 . next = temp1 ; p1 = temp1 ; p2 = temp2 ; } } }
tr	9	public Map < String , Object > toConfigurationNode ( ) { Map < String , Object > output = new LinkedHashMap < String , Object > ( ) ; output . put ( "group" , group ) ; if ( subgroups != null && subgroups . size ( ) != 0 ) { output . put ( "subgroups" , subgroups ) ; } if ( permissions != null && permissions . size ( ) != 0 ) { Map < String , List < String >> tmp = new LinkedHashMap < String , List < String >> ( ) ; for ( String world : permissions . keySet ( ) ) { tmp . put ( world , internalFormatToFile ( permissions . get ( world ) ) ) ; } output . put ( "permissions" , tmp ) ; } if ( info != null && info . size ( ) != 0 ) { output . put ( "info" , info ) ; } if ( globalPermissions != null && globalPermissions . size ( ) != 0 ) { output . put ( "globalpermissions" , internalFormatToFile ( globalPermissions ) ) ; } return output ; }
tr	2	public List < NodeContainer < NodeTest >> getRightMostProducts ( int minRightValue ) { List < NodeContainer < NodeTest >> ret = new ArrayList < NodeContainer < NodeTest >> ( ) ; for ( NodeContainer < NodeTest > s : NodeRepository . getOrderedRightList ( ) ) if ( s . getRight ( ) > minRightValue ) ret . add ( s ) ; return ret ; }
tr	0	public void setUpvote ( boolean upvote ) { this . upvote = upvote ; }
tr	8	public static String readTimeInput ( ) { boolean tryAgain ; do { tryAgain = false ; timeInput = scan . nextLine ( ) ; for ( String time : timeInput . split ( " " ) ) { if ( ! time . contains ( ":" ) ) { System . out . print ( "Input is in wrong format! Try again: " ) ; tryAgain = true ; break ; } String [ ] time_hh_mm = time . split ( ":" ) ; if ( time_hh_mm . length > 2 ) { System . out . print ( "Input is in wrong format! Try again: " ) ; tryAgain = true ; } hour = Integer . parseInt ( time_hh_mm [ 0 ] ) ; minute = Integer . parseInt ( time_hh_mm [ 1 ] ) ; if ( hour < 0 || hour > 23 || minute < 0 || minute > 59 ) { System . out . print ( "The time input is invalid! Try again: " ) ; tryAgain = true ; break ; } } } while ( tryAgain ) ; return timeInput ; }
tr	6	@ SuppressWarnings ( "unchecked" ) public static void bencode ( Object o , OutputStream out ) throws IOException , IllegalArgumentException { if ( o instanceof BEValue ) { o = ( ( BEValue ) o ) . getValue ( ) ; } if ( o instanceof String ) { bencode ( ( String ) o , out ) ; } else if ( o instanceof byte [ ] ) { bencode ( ( byte [ ] ) o , out ) ; } else if ( o instanceof Number ) { bencode ( ( Number ) o , out ) ; } else if ( o instanceof List ) { bencode ( ( List < BEValue > ) o , out ) ; } else if ( o instanceof Map ) { bencode ( ( Map < String , BEValue > ) o , out ) ; } else { throw new IllegalArgumentException ( "Cannot bencode: " + o . getClass ( ) ) ; } }
tr	6	public boolean doSave ( boolean saveAs ) { File f = file ; if ( saveAs || file == null ) { f = getFile ( true ) ; if ( f == null ) return false ; String name = f . getName ( ) . toLowerCase ( ) ; if ( ! name . endsWith ( ".png" ) ) { if ( name . contains ( "." ) ) name = name . substring ( 0 , name . lastIndexOf ( . ) ) ; f = new File ( f . getParentFile ( ) , name + ".png" ) ; } } try { ImageIO . write ( canvas . getRenderImage ( ) , "PNG" , f ) ; file = f ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; }
tr	6	static int minPathLength ( int requiredLevel , int currentHeight , int currentWidth , int currentMinPath , int previousLevelMinPath , int currentPath , int [ ] [ ] triangle ) { if ( currentHeight + currentWidth == requiredLevel ) return Math . min ( currentPath , currentMinPath ) ; if ( currentPath + previousLevelMinPath > currentMinPath ) return currentMinPath ; int up = 20000 * SIZE ; int right = 20000 * SIZE ; int down = 20000 * SIZE ; int left = 20000 * SIZE ; if ( currentHeight > 0 ) up = minPathLength ( requiredLevel , currentHeight - 1 , currentWidth , currentMinPath , previousLevelMinPath , currentPath + triangle [ currentHeight - 1 ] [ currentWidth ] , triangle ) ; if ( currentWidth < triangle [ currentHeight ] . length - 1 ) right = minPathLength ( requiredLevel , currentHeight , currentWidth + 1 , currentMinPath , previousLevelMinPath , currentPath + triangle [ currentHeight ] [ currentWidth + 1 ] , triangle ) ; if ( currentHeight < triangle [ currentWidth ] . length - 1 ) down = minPathLength ( requiredLevel , currentHeight + 1 , currentWidth , currentMinPath , previousLevelMinPath , currentPath + triangle [ currentHeight + 1 ] [ currentWidth ] , triangle ) ; if ( currentWidth > 0 ) left = minPathLength ( requiredLevel , currentHeight , currentWidth - 1 , currentMinPath , previousLevelMinPath , currentPath + triangle [ currentHeight ] [ currentWidth - 1 ] , triangle ) ; return Math . min ( Math . min ( Math . min ( up , right ) , down ) , left ) ; }
tr	5	public static void main ( String [ ] args ) { Suitors mySuitors = new Suitors ( ) ; for ( int i = 0 ; i < 22 ; i ++ ) mySuitors . add ( ) ; Suitor theSuitor = mySuitors . head ; boolean done = false ; int count = 0 ; while ( ! done ) { if ( theSuitor . next . number == theSuitor . number ) done = true ; else { theSuitor = theSuitor . next . next . next ; mySuitors . remove ( theSuitor ) ; count ++ ; if ( count > 0 && count % 5 == 0 ) { mySuitors . display ( ) ; System . out . println ( ) ; } } } System . out . println ( "And the winner is..." ) ; mySuitors . display ( ) ; }
tr	2	boolean addPropagate ( Constraint c , int mark ) { List < Constraint > todo = new ArrayList < Constraint > ( ) ; todo . add ( c ) ; while ( todo . size ( ) > 0 ) { Constraint d = todo . remove ( todo . size ( ) - 1 ) ; if ( d . output ( ) . mark == mark ) { incrementalRemove ( c ) ; return false ; } d . recalculate ( ) ; addConstraintsConsumingTo ( d . output ( ) , todo ) ; } return true ; }
tr	9	public static String valueToString ( Object value ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof JSONString ) { Object object ; try { object = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "Bad value from toJSONString: " + object ) ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; }
tr	1	public void update ( AssignmentTypes instance ) { log . debug ( "updating " + entitySimpleName + " instance" ) ; try { super . update ( instance ) ; log . debug ( entitySimpleName + " update successful" ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " update failed" , re ) ; throw re ; } }
tr	9	private boolean doSGECheckings ( boolean reportSGECheckErrors ) { String hostname = Configuration . hostname ; boolean success = true ; try { if ( hostname . equals ( "localhost" ) || hostname . startsWith ( "127.0." ) ) { if ( reportSGECheckErrors ) { JOptionPane . showMessageDialog ( sif , "It is not supported for a Grid Engine installation that the local hostname\n" + "is \"localhost\" and/or the IP address is like \"127.0.x.x\"\n\n" + "The hostname of this computer is " + hostname + "\n\n" + "After you fix the hostname make sure to LOG OFF from the system\n" + "and then log back in and start the installer. This will update some\n " + "configurations in the system needed to prevent future errors for \n" + "installing SGE and Pipeline" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } success = false ; } if ( success ) { FileInputStream is = new FileInputStream ( "/etc/hosts" ) ; DataInputStream in = new DataInputStream ( is ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; int lineNo = 0 ; while ( ( strLine = br . readLine ( ) ) != null ) { lineNo ++ ; if ( strLine . contains ( hostname ) ) { if ( strLine . contains ( "localhost" ) || strLine . contains ( "127.0" ) ) { if ( reportSGECheckErrors ) { JOptionPane . showMessageDialog ( sif , "It is not supported for a Grid Engine installation that the local hostname\n" + "contains the hostname \"localhost\" and/or the IP address \"127.0.x.x\" of the\n" + "loopback interface.\n" + "The \"localhost\" hostname should be reserved for the loopback interface\n" + "(\"127.0.0.1\") and the real hostname should be assigned to one of the\n" + "physical or logical network interfaces of this machine.\n\n" + "Please edit your /etc/hosts file's line " + lineNo + " and try to check the checkbox again." , "Error" , JOptionPane . ERROR_MESSAGE ) ; } success = false ; break ; } } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return success ; }
tr	7	@ Override public void removeData ( SchoolClass cls ) { CSVFile clsFile = new CSVFile ( FN_CLASS ) ; List < String > clsLines = new ArrayList < String > ( ) ; clsFile . read ( clsLines ) ; boolean found = false ; boolean needRemoveCourse = true ; for ( String tmpStr : clsLines ) { if ( tmpStr . indexOf ( cls . getClassNumber ( ) ) >= 0 ) { clsLines . remove ( tmpStr ) ; found = true ; break ; } } if ( found ) { String data = "" ; for ( String tmpStr : clsLines ) { data += tmpStr ; if ( ! tmpStr . equals ( clsLines . get ( clsLines . size ( ) - 1 ) ) ) { data += "\n" ; } if ( tmpStr . indexOf ( cls . getCourse ( ) . getCourseID ( ) ) >= 0 ) { needRemoveCourse = false ; } } clsFile . write ( data ) ; } if ( needRemoveCourse ) { removeData ( cls . getCourse ( ) ) ; } }
tr	6	public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	3	public List < JSONObject > take ( int maxWaitMillis ) throws InterruptedException { List < JSONObject > result = new ArrayList < JSONObject > ( ) ; lock . lock ( ) ; try { if ( samples . size ( ) < batchSize ) { lessThenBatchSizeCondition . await ( maxWaitMillis , TimeUnit . MILLISECONDS ) ; } if ( samples . size ( ) == 0 ) { return result ; } int takedCount = samples . size ( ) < batchSize ? samples . size ( ) : batchSize ; result . addAll ( samples . subList ( 0 , takedCount ) ) ; samples . removeAll ( result ) ; return result ; } finally { lock . unlock ( ) ; } }
tr	1	protected void createWebSocketPingServer ( ) { RxHttpServer server = new RxHttpServer ( vertx . createHttpServer ( ) ) ; server . websocket ( ) . subscribe ( new Action1 < RxServerWebSocket > ( ) { public void call ( final RxServerWebSocket s ) { System . out . println ( "WebSocketServer:" + s . path ( ) ) ; s . asObservable ( ) . subscribe ( new Action1 < Buffer > ( ) { public void call ( Buffer b ) { System . out . println ( "WebSocketServer:received[" + b + "]" ) ; if ( "EOF" . equals ( b . toString ( ) ) ) { s . close ( ) ; } else { s . writeTextFrame ( b . toString ( ) ) ; } } } ) ; } } ) ; server . coreHttpServer ( ) . listen ( 8090 , "localhost" ) ; }
tr	9	public void initConvexe ( ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; next . convexe = new Convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { Classe classe = vectClasses . elementAt ( classes [ i ] ) ; if ( classe . envDessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getK ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . envDessinee ) { next . convexe . calculBarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	1	public String getString ( String name ) { if ( ! tags . containsKey ( name ) ) return "" ; return ( ( StringTag ) tags . get ( name ) ) . data ; }
tr	4	public List < SiteStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > statRows = resultset . getRows ( ) ; Map < long , SiteStatModel > siteStatModelMap = new HashMap < > ( ) ; for ( StatRow eachRow : statRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { SiteStatModel siteStatModel = new SiteStatModel ( ) ; siteStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; siteStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; siteStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; siteStatModel . setHour ( hour ) ; siteStatModel . setVideo ( 0 ) ; siteStatModel . setSite ( siteModel ) ; if ( siteStatModelMap . get ( hour . getMillis ( ) ) == null ) { siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } else { siteStatModelMap . remove ( hour . getMillis ( ) ) ; siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } } } List < SiteStatModel > siteStatModels = new ArrayList < > ( siteStatModelMap . values ( ) ) ; return siteStatModels ; }
tr	6	@ Override public int getChannelVolume ( int inputChannel , int outputChannel ) { if ( inputChannel < 0 || inputChannel >= channelVolumes . size ( ) ) throw new IndexOutOfBoundsException ( "Input channel must be in legal range!" ) ; if ( outputChannel >= channelCount ) throw new IndexOutOfBoundsException ( "Output channel must be in legal range!" ) ; if ( outputChannel < 0 ) { int [ ] v = channelVolumes . get ( inputChannel ) ; int max = v [ 0 ] ; for ( int i = 1 ; i < channelCount ; i ++ ) max = v [ i ] > max ? v [ i ] : max ; return max ; } else { return channelVolumes . get ( inputChannel ) [ outputChannel ] ; } }
tr	4	public void setAnswerIndex ( int index ) { if ( style != DROP_DOWN_QUESTION ) return ; if ( options != null && 0 <= index && index < options . length ) { this . answer = options [ index ] ; } }
tr	7	public static void main ( String [ ] args ) { int newport = 0 ; String log = "" ; if ( args . length > 0 ) { args [ 0 ] . trim ( ) ; try { newport = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { if ( ! args [ 0 ] . equalsIgnoreCase ( "-h" ) ) { System . out . println ( "server: Invalid argument" ) ; } else { System . out . println ( "Syntax: java Server [port-number]" ) ; } System . exit ( 0 ) ; } } else { newport = defaultPort ; } if ( newport < 1024 ) { System . out . println ( "server: Invalid port number! Using default port " + defaultPort ) ; newport = defaultPort ; } try { Server serv = new Server ( newport ) ; while ( true ) { serv . connection = serv . servSocket . accept ( ) ; serv . connection . setSoTimeout ( 60000 ) ; serv . in = new BufferedReader ( new InputStreamReader ( serv . connection . getInputStream ( ) ) ) ; String msg = serv . receive ( ) ; serv . addPlayer ( msg ) ; log = "server: Accepted new connection to client on port " + serv . connection . getPort ( ) + "\n" ; System . out . print ( log ) ; serv . log ( log , newport ) ; log = "server:received data from new player: " + msg + "\n" ; System . out . print ( log ) ; serv . log ( log , newport ) ; } } catch ( InterruptedIOException e ) { System . out . println ( "server: client not responding" ) ; } catch ( IOException e ) { System . out . println ( "server: error connecting to client" ) ; } }
tr	8	private boolean makeServiceNameUnique ( ServiceInfoImpl info ) { final String originalQualifiedName = info . getQualifiedName ( ) ; final long now = System . currentTimeMillis ( ) ; boolean collision ; do { collision = false ; for ( DNSCache . CacheNode j = cache . find ( info . getQualifiedName ( ) . toLowerCase ( ) ) ; j != null ; j = j . next ( ) ) { final DNSRecord a = ( DNSRecord ) j . getValue ( ) ; if ( ( a . type == DNSConstants . TYPE_SRV ) && ! a . isExpired ( now ) ) { final DNSRecord . Service s = ( DNSRecord . Service ) a ; if ( s . port != info . port || ! s . server . equals ( localHost . getName ( ) ) ) { logger . finer ( "makeServiceNameUnique() JmDNS.makeServiceNameUnique srv collision:" + a + " s.server=" + s . server + " " + localHost . getName ( ) + " equals:" + ( s . server . equals ( localHost . getName ( ) ) ) ) ; info . setName ( incrementName ( info . getName ( ) ) ) ; collision = true ; break ; } } } final Object selfService = services . get ( info . getQualifiedName ( ) . toLowerCase ( ) ) ; if ( selfService != null && selfService != info ) { info . setName ( incrementName ( info . getName ( ) ) ) ; collision = true ; } } while ( collision ) ; return ! ( originalQualifiedName . equals ( info . getQualifiedName ( ) ) ) ; }
