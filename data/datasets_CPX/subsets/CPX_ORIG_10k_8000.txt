va	0	public static URL getURL ( String filName ) { return staticSound . getClass ( ) . getResource ( filName ) ; }
va	4	protected static Method determineScalingMethod ( int targetWidth , int targetHeight , float ratio ) { int length = ( ratio <= 1 ? targetWidth : targetHeight ) ; Method result = Method . SPEED ; if ( length <= Scalr . THRESHOLD_QUALITY_BALANCED ) result = Method . QUALITY ; else if ( length <= Scalr . THRESHOLD_BALANCED_SPEED ) result = Method . BALANCED ; if ( DEBUG ) log ( 2 , "AUTOMATIC scaling method selected: %s" , result . name ( ) ) ; return result ; }
va	2	public Interpreter ( Statement AST , Type [ ] args ) { env = new Environment ( ) ; if ( args != null ) { Identifier id = new Identifier ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { id . bypass ( "$" + i ) ; env . add ( id , args [ i ] ) ; } } instr ( AST , env ) ; }
va	8	@ SuppressWarnings ( "SimplifiableIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; HgClone hgClone = ( HgClone ) o ; if ( pathToHg != null ? ! pathToHg . equals ( hgClone . pathToHg ) : hgClone . pathToHg != null ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( hgClone . repositoryUrl ) : hgClone . repositoryUrl != null ) return false ; return ! ( localPath != null ? ! localPath . equals ( hgClone . localPath ) : hgClone . localPath != null ) ; }
va	9	public static void main ( String [ ] args ) { Parser parser = new CSVParser ( "./banks/controlled.csv" ) ; DataSet dataSet = parser . parse ( ) ; int REPRESENTANTES = 3 ; List < Pattern > list = new LinkedList < Pattern > ( dataSet ) ; Collections . shuffle ( list ) ; Set < Pattern > randomSet = new HashSet < Pattern > ( list ) ; int index ; double d [ ] [ ] ; d = new double [ REPRESENTANTES ] [ ] ; index = 0 ; for ( Pattern p : randomSet ) { if ( p . getClassIndex ( ) == 0 && index < REPRESENTANTES ) { d [ index ++ ] = p . toDoubleVector ( ) ; } } double A [ ] [ ] = Matrix . trans ( d ) ; d = new double [ REPRESENTANTES ] [ ] ; index = 0 ; for ( Pattern p : randomSet ) { if ( p . getClassIndex ( ) == 1 && index < REPRESENTANTES ) { d [ index ++ ] = p . toDoubleVector ( ) ; } } double B [ ] [ ] = Matrix . trans ( d ) ; imprime ( A ) ; imprime ( B ) ; int incorrectos = 0 ; for ( Pattern p : dataSet ) { double s1 = test ( A , p . toDoubleVector ( ) ) ; double s2 = test ( B , p . toDoubleVector ( ) ) ; List < double > values = new ArrayList < double > ( ) ; values . add ( s1 ) ; values . add ( s2 ) ; double min = Collections . min ( values ) ; if ( min == s1 && p . getClassIndex ( ) == 0 ) System . out . println ( "Correcto" ) ; else if ( min == s2 && p . getClassIndex ( ) == 1 ) System . out . println ( "Correcto" ) ; else { System . out . println ( "Error // " + p . getClassIndex ( ) ) ; incorrectos ++ ; } System . out . println ( "====================================" ) ; } System . out . println ( ( 1 - incorrectos / ( double ) dataSet . size ( ) ) * 100 ) ; }
va	1	public NetworkSocket ( String ip , int port ) { try { socket = new Socket ( ip , port ) ; oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; bis = new BufferedInputStream ( socket . getInputStream ( ) ) ; ois = new ObjectInputStream ( bis ) ; } catch ( IOException e ) { System . err . println ( "Application Exception: Invalid network connection parameters." ) ; socket = null ; } }
va	8	public static List < List < Integer >> zigzagLevelOrder ( TreeNode root ) { List < List < Integer >> results = new ArrayList < List < Integer >> ( ) ; if ( root == null ) return results ; LinkedList < TreeNode > q = new LinkedList < TreeNode > ( ) ; q . add ( root ) ; boolean left = false ; while ( ! q . isEmpty ( ) ) { int size = q . size ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) { TreeNode n = q . poll ( ) ; result . add ( n . val ) ; if ( left ) { if ( n . right != null ) { q . add ( 0 , n . right ) ; } if ( n . left != null ) { q . add ( 0 , n . left ) ; } } else { if ( n . left != null ) { q . add ( 0 , n . left ) ; } if ( n . right != null ) { q . add ( 0 , n . right ) ; } } } results . add ( result ) ; left = ! left ; } return results ; }
va	3	@ SuppressWarnings ( "static-access" ) public IHMFilterKIValue ( Filter filter , JFrame frame ) { super ( filter , frame ) ; setLayout ( new BorderLayout ( ) ) ; Box bV = Box . createVerticalBox ( ) ; Box bH = Box . createHorizontalBox ( ) ; bH . add ( jButtonActivation ) ; bH . add ( Box . createHorizontalStrut ( 5 ) ) ; bH . add ( new JLabel ( filter . getS_name ( ) ) ) ; bH . add ( Box . createHorizontalGlue ( ) ) ; bH . setMaximumSize ( new Dimension ( 3000 , 16 ) ) ; bV . add ( bH ) ; JSeparator separator = IHMTools . getInstance ( ) . addHorizontalSeparator ( bV , 5 , 5 ) ; separator . setMaximumSize ( new Dimension ( 3000 , 16 ) ) ; listCheckBox = new ArrayList < JCheckBox > ( ) ; String [ ] tab_s_nameFilter = ( ( FilterKIValue ) filter ) . getTab_s_KIValue ( ) ; boolean [ ] tab_isSelected = ( ( FilterKIValue ) filter ) . getTab_isValueSelected ( ) ; if ( tab_s_nameFilter . length == tab_isSelected . length ) { for ( int i_idFilter = 0 ; i_idFilter < tab_s_nameFilter . length ; i_idFilter ++ ) { listCheckBox . add ( new JCheckBox ( tab_s_nameFilter [ i_idFilter ] , tab_isSelected [ i_idFilter ] ) ) ; } } else { System . err . println ( "IHMFilterKIValue.java - tab_s_nameFilter != tab_isSelected" ) ; } JPanel jPanel = new JPanel ( ) ; jPanel . setLayout ( new BoxLayout ( jPanel , BoxLayout . PAGE_AXIS ) ) ; JScrollPane jScrollPane = new JScrollPane ( jPanel ) ; for ( JCheckBox checkBoxToAdd : listCheckBox ) { Box bHTmp = Box . createHorizontalBox ( ) ; bHTmp . add ( checkBoxToAdd ) ; bHTmp . add ( Box . createHorizontalGlue ( ) ) ; jPanel . add ( bHTmp ) ; } bV . add ( jScrollPane ) ; jButtonCheckBoxSelection = IHMTools . getInstance ( ) . getNewButtonWithIcon_ActionListener_TextOnRight ( ConfigIcon . getInstance ( ) . CHECK , this , "Cocher tout" ) ; bH = Box . createHorizontalBox ( ) ; bH . add ( jButtonCheckBoxSelection ) ; bH . add ( Box . createHorizontalGlue ( ) ) ; bH . setMaximumSize ( new Dimension ( 3000 , 16 ) ) ; bV . add ( bH ) ; bV . add ( Box . createVerticalGlue ( ) ) ; bH = Box . createHorizontalBox ( ) ; bH . add ( Box . createHorizontalGlue ( ) ) ; bH . add ( jButtonCancel ) ; bH . add ( Box . createHorizontalStrut ( 15 ) ) ; bH . add ( jButtonValidate ) ; bH . add ( Box . createHorizontalGlue ( ) ) ; bH . setMaximumSize ( new Dimension ( 3000 , 16 ) ) ; bV . add ( bH ) ; add ( bV , BorderLayout . CENTER ) ; }
va	3	public static void main ( String [ ] args ) { String flacFile = args [ 0 ] ; int fromSeekPoint = Integer . parseInt ( args [ 1 ] ) ; int toSeekPoint = Integer . parseInt ( args [ 2 ] ) ; try { SeekTablePlayer player = new SeekTablePlayer ( ) ; player . play ( flacFile , fromSeekPoint , toSeekPoint ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( LineUnavailableException e ) { e . printStackTrace ( ) ; } System . exit ( 0 ) ; }
va	5	public int bestFit ( final long [ ] w ) { final BST bst = new BST ( ) ; bst . root = new TreeNode ( w [ 0 ] , null , null ) ; final int numOfWeights = w . length ; int binCount = 0 ; for ( int i = 0 ; i < numOfWeights ; i ++ ) { final long weight = w [ i ] ; long minDiff = 1 ; TreeNode node = bst . root ; TreeNode minNode = null ; while ( node != null ) { if ( node . value > weight ) { final long diff = node . value - weight ; if ( diff < minDiff ) { minDiff = diff ; minNode = node ; node = node . left ; } else { throw new RuntimeException ( "something is wrong. this shouldn't happen and there shouldn't be duplicates in binary search tree." ) ; } } else { node = node . right ; } } if ( minNode == null ) { binCount ++ ; final TreeNode newNode = new TreeNode ( 1 - weight , null , null ) ; bst . insert ( newNode . value ) ; } else { minNode . value -= weight ; bst . remove ( minNode . value ) ; bst . insert ( minNode . value ) ; } } return binCount ; }
va	3	@ Override public String serialize ( ) { Stack < String > playerNames = new Stack < String > ( ) ; Stack < String > playerColors = new Stack < String > ( ) ; for ( JavaPlayer player : players ) { playerNames . push ( player . getName ( ) ) ; playerColors . push ( player . getColor ( ) ) ; } String serializedHistory = actionHistory . empty ( ) ? "null" : Json . serializeArray ( this . actionHistory ) ; String serializedReplays = actionReplays . empty ( ) ? "null" : Json . serializeArray ( this . actionReplays ) ; return Json . jsonObject ( Json . jsonElements ( Json . jsonPair ( "playerNames" , Json . serializeArray ( playerNames ) ) , Json . jsonPair ( "playerColors" , Json . serializeArray ( playerColors ) ) , Json . jsonPair ( "actionHistory" , serializedHistory ) , Json . jsonPair ( "actionReplays" , serializedReplays ) , Json . jsonPair ( "gameState" , this . gameState . toString ( ) ) ) ) ; }
va	4	public PojoPerson [ ] joinInner ( PojoPerson [ ] arr1 , PojoPerson [ ] arr2 ) { PojoPerson [ ] temp = new PojoPerson [ length ( arr1 ) ] ; int i = 0 ; if ( arr1 != null ) for ( PojoPerson s : arr1 ) if ( contains ( arr2 , s ) && ! contains ( temp , s ) ) temp [ i ++ ] = s ; return Arrays . copyOf ( temp , i ) ; }
va	2	@ Override public void train ( ) { DataSet trainSet = getTrainSet ( ) ; int n = trainSet . getAttributes ( ) . size ( ) ; int m = trainSet . getClasses ( ) . getValues ( ) . size ( ) ; M = Matrix . fill ( m , n , 0d ) ; for ( Pattern instance : trainSet ) { for ( int i = 0 ; i < instance . size ( ) ; i ++ ) { double [ ] xM = instance . toDoubleVector ( ) ; double [ ] yM = Matrix . oneHotD ( m , instance . getClassIndex ( ) ) ; M = Matrix . sum ( M , Matrix . mult ( yM , xM ) ) ; } } }
va	1	public int optInt ( int index , int defaultValue ) { try { return getInt ( index ) ; } catch ( Exception e ) { return defaultValue ; } }
va	7	@ Override public void actionPerformed ( ActionEvent e ) { if ( FirstStartWizard . currentPanel + offset == 1 ) { FirstStartWizard . frame . setContentPane ( target . introPanel ( ) ) ; FirstStartWizard . frame . validate ( ) ; FirstStartWizard . currentPanel = 1 ; } else if ( FirstStartWizard . currentPanel + offset == 2 ) { FirstStartWizard . frame . setContentPane ( target . importPanel ( ) ) ; FirstStartWizard . frame . validate ( ) ; FirstStartWizard . currentPanel = 2 ; } else if ( FirstStartWizard . currentPanel + offset == 3 ) { FirstStartWizard . frame . setContentPane ( target . selectDirsPanel ( ) ) ; FirstStartWizard . frame . validate ( ) ; FirstStartWizard . currentPanel = 3 ; } else if ( FirstStartWizard . currentPanel + offset == 4 ) { FirstStartWizard . frame . setContentPane ( target . finishPanel ( ) ) ; FirstStartWizard . frame . validate ( ) ; FirstStartWizard . currentPanel = 4 ; } else if ( FirstStartWizard . currentPanel + offset == 12 ) { FirstStartWizard . frame . setContentPane ( target . selectOldDirPanel ( ) ) ; FirstStartWizard . frame . validate ( ) ; FirstStartWizard . currentPanel = 12 ; } if ( FirstStartWizard . currentPanel == 3 && FirstStartWizard . currentPanel + offset < 3 ) { Main . backupDirectory = null ; Main . liveDirectory = null ; } logger . debug ( "Moved to panel number " + FirstStartWizard . currentPanel ) ; }
va	7	public static void sort ( String f1 , String f2 ) throws FileNotFoundException , IOException { RandomAccessFile a = new RandomAccessFile ( f1 , "r" ) ; RandomAccessFile a2 = new RandomAccessFile ( f1 , "rw" ) ; RandomAccessFile b = new RandomAccessFile ( f2 , "rw" ) ; DataOutputStream dosb ; DataOutputStream dosa ; DataInputStream dis ; long length = a . length ( ) / 4 ; int bin ; long off ; long mem = Runtime . getRuntime ( ) . totalMemory ( ) ; int memdiv = 8192 ; for ( int i = 0 ; i < 31 ; i ++ ) { bin = 1 << i ; dosb = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( b . getFD ( ) ) , memdiv ) ) ; dosa = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( a2 . getFD ( ) ) , memdiv ) ) ; dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( a . getFD ( ) ) , memdiv ) ) ; for ( int j = 0 ; j < length ; j ++ ) { int temp = dis . readInt ( ) ; if ( ( temp & bin ) == 0 ) { dosa . writeInt ( temp ) ; } else { dosb . writeInt ( temp ) ; } } dosb . flush ( ) ; off = b . getFilePointer ( ) / 4 ; b . seek ( 0 ) ; dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( b . getFD ( ) ) , memdiv ) ) ; for ( long j = 0 ; j < off ; j ++ ) { dosa . writeInt ( dis . readInt ( ) ) ; } dosa . flush ( ) ; a . seek ( 0 ) ; a2 . seek ( 0 ) ; b . seek ( 0 ) ; } dosb = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( b . getFD ( ) ) , memdiv ) ) ; dosa = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( a2 . getFD ( ) ) , memdiv ) ) ; dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( a . getFD ( ) ) , memdiv ) ) ; for ( int j = 0 ; j < length ; j ++ ) { int temp = dis . readInt ( ) ; if ( temp > 0 ) { dosb . writeInt ( temp ) ; } else { dosa . writeInt ( temp ) ; } } dosb . flush ( ) ; off = b . getFilePointer ( ) / 4 ; b . seek ( 0 ) ; dis = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( b . getFD ( ) ) , memdiv ) ) ; for ( long j = 0 ; j < off ; j ++ ) { dosa . writeInt ( dis . readInt ( ) ) ; } dosa . flush ( ) ; a . seek ( 0 ) ; a2 . seek ( 0 ) ; b . seek ( 0 ) ; }
va	7	public boolean parseFormatDoc ( String strFormatDocURI ) { Preferences xsdPrefs = MarsPreferences . getMarsPrefs ( ) ; String strXSDFileDir = xsdPrefs . get ( "mars.dir.XSD" , System . getProperty ( "user.dir" ) ) ; File fXSD = new File ( strXSDFileDir ) ; Schema sFD ; try { sFD = xsdFactory . newSchema ( fXSD ) ; } catch ( Exception x ) { log . finest ( "An error occurred while trying to open the FormatDoc schema" ) ; log . throwing ( parentClassName , "parseFormatDoc" , x ) ; return false ; } if ( sFD != null ) { xmlFactory . setSchema ( sFD ) ; xmlFactory . setValidating ( true ) ; try { log . finest ( "Creating a new instance of SAXParser" ) ; SAXParser xmlDoc = xmlFactory . newSAXParser ( ) ; log . config ( "Creating an instance of File for the FormatDoc at " + strFormatDocURI ) ; File fFormatDocXML = new File ( strFormatDocURI ) ; log . finest ( "Starting to parse file " + fFormatDocXML . getName ( ) ) ; xmlDoc . parse ( fFormatDocXML , new FormatDocHandler ( ) ) ; log . log ( Level . CONFIG , "Storing FormatDoc under the system name of " + fFormatDocXML . getName ( ) , FormatDocStore . getTempFD ( ) ) ; FormatDocStore . tempToHashTable ( fFormatDocXML . getName ( ) ) ; MarsClient . getMarsWindow ( ) . addNewSystemWindow ( fFormatDocXML . getName ( ) ) ; } catch ( NullPointerException npX ) { log . finest ( "A null pointer error occurred because the FormatDocURI argument was not set" ) ; log . throwing ( parentClassName , "parseFormatDoc" , npX ) ; return false ; } catch ( SAXException saxX ) { log . finest ( "A SAX error occurred while trying to parse the FormatDoc. See the FormatDocHandler log for more information" ) ; log . throwing ( parentClassName , "parseFormatDoc" , saxX ) ; return false ; } catch ( IOException ioX ) { log . finest ( "An I/O error occurred while trying to read from the XML FormatDoc" ) ; log . throwing ( parentClassName , "parseFormatDoc" , ioX ) ; return false ; } catch ( ParserConfigurationException pcX ) { log . finest ( "A parser configuration error occurred while trying to create a new SAXParser instance from the SAXParserFactory" ) ; log . throwing ( parentClassName , "parseFormatDoc" , pcX ) ; return false ; } catch ( Exception x ) { log . finest ( "An general exception occurred" ) ; log . throwing ( parentClassName , "parseFormatDoc" , x ) ; return false ; } } else { log . severe ( "The schema for validating FormatDoc XML was null yet no errors were thrown." ) ; return false ; } log . finest ( "Parsed format doc with no problems" ) ; return true ; }
va	3	private void jComboBox2ItemStateChanged ( java . awt . event . ItemEvent evt ) { switch ( evt . getItem ( ) . toString ( ) . toLowerCase ( ) ) { case "gastos fijos" : { jComboBox3 . setModel ( new DefaultComboBoxModel ( FIXED_EXPENSE ) ) ; break ; } case "servicios" : { jComboBox3 . setModel ( new DefaultComboBoxModel ( SERVICES ) ) ; break ; } case "ocio y demas" : { jComboBox3 . setModel ( new DefaultComboBoxModel ( LEISURE ) ) ; break ; } } }
va	9	protected void setFromQhull ( double [ ] coords , int nump , boolean triangulate ) { String commandStr = "./qhull i" ; if ( triangulate ) { commandStr += " -Qt" ; } try { Process proc = Runtime . getRuntime ( ) . exec ( commandStr ) ; PrintStream ps = new PrintStream ( proc . getOutputStream ( ) ) ; StreamTokenizer stok = new StreamTokenizer ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; ps . println ( "3 " + nump ) ; for ( int i = 0 ; i < nump ; i ++ ) { ps . println ( coords [ i * 3 + 0 ] + " " + coords [ i * 3 + 1 ] + " " + coords [ i * 3 + 2 ] ) ; } ps . flush ( ) ; ps . close ( ) ; Vector indexList = new Vector ( 3 ) ; stok . eolIsSignificant ( true ) ; printQhullErrors ( proc ) ; do { stok . nextToken ( ) ; } while ( stok . sval == null || ! stok . sval . startsWith ( "MERGEexact" ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { stok . nextToken ( ) ; } if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting number of faces" ) ; System . exit ( 1 ) ; } int numf = ( int ) stok . nval ; stok . nextToken ( ) ; int [ ] [ ] faceIndices = new int [ numf ] [ ] ; for ( int i = 0 ; i < numf ; i ++ ) { indexList . clear ( ) ; while ( stok . nextToken ( ) != StreamTokenizer . TT_EOL ) { if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting face index" ) ; System . exit ( 1 ) ; } indexList . add ( 0 , new Integer ( ( int ) stok . nval ) ) ; } faceIndices [ i ] = new int [ indexList . size ( ) ] ; int k = 0 ; for ( Iterator it = indexList . iterator ( ) ; it . hasNext ( ) ; ) { faceIndices [ i ] [ k ++ ] = ( ( Integer ) it . next ( ) ) . intValue ( ) ; } } setHull ( coords , nump , faceIndices , numf ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
va	1	@ Override public boolean setSpeedFast ( ) { try { setAllPinsLow ( ) ; setPinHigh ( this . pin5Fast ) ; } catch ( Exception e ) { System . err . println ( "[!] Error setting speed fast! " + e . getMessage ( ) ) ; return false ; } return true ; }
va	2	public static String getEUsername ( Integer _int ) { Database db = dbconnect ( ) ; String query ; String txt = null ; try { query = ( "SELECT username FROM employee WHERE bDeleted = 0 AND EID = ?" ) ; db . prepare ( query ) ; db . bind_param ( 1 , _int . toString ( ) ) ; ResultSet rs = db . executeQuery ( ) ; while ( rs . next ( ) ) { txt = ( rs . getString ( 1 ) ) ; } db . close ( ) ; } catch ( SQLException e ) { Error_Frame . Error ( e . toString ( ) ) ; } return txt ; }
va	3	public static double abort ( String key ) { if ( key == null ) throw new RuntimeException ( "ElapsedTime key can't be null" ) ; ElapsedTimeInterval entry = mSampleSetManager . get ( key ) ; if ( entry == null || entry . mStartTime < 0 ) return 0.0 ; double sample = ( System . nanoTime ( ) - entry . mStartTime ) * MSEC_SCALE ; entry . mStartTime = - 1 ; entry . abort ( ) ; return sample ; }
va	4	@ Test public void maxUnderOneThousand ( ) { int max = 0 ; String result = "" ; for ( int i = 1000 ; i >= 0 && max != result . length ( ) + 1 ; i -- ) { if ( isPrime ( i ) ) { String currVal = patternFinder . find ( fractionToDecimal ( valueOf ( i ) ) , result . length ( ) , i ) ; if ( currVal . length ( ) > result . length ( ) ) { max = i ; result = currVal ; } } } assertThat ( max , is ( 983 ) ) ; }
va	4	@ Test public void Speed ( ) throws Exception { final AtomicInteger parallelism = new AtomicInteger ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { try { buildAndShuffleList ( 10000 , 1 ) ; } catch ( Exception e ) { } ; } final int listSize = 100000 ; for ( parallelism . set ( 1 ) ; parallelism . get ( ) < 10 ; parallelism . incrementAndGet ( ) ) { long t = Timer . time ( new Runnable ( ) { @ Override public void run ( ) { try { buildAndShuffleList ( listSize , parallelism . get ( ) ) ; } catch ( Exception e ) { } ; } } ) ; System . out . println ( "PARALLELISM LEVEL:" + parallelism . get ( ) + " TIME TO SORT: " + t ) ; } }
va	4	private void buttonSendActionPerformed ( java . awt . event . ActionEvent evt ) { CreditProgram crProg = crProgDAO . get ( String . valueOf ( сomboBoxCreditPrograms . getSelectedItem ( ) ) ) ; double creditSum = double . parseDouble ( textFieldSum . getText ( ) ) ; if ( ( creditSum <= 0 ) || ( creditSum < crProg . getMinAmount ( ) ) || creditSum > crProg . getMaxAmount ( ) ) { JOptionPane . showMessageDialog ( this , "\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043E\u0444\u043E\u0440\u043C\u0438\u0442\u044C \u043A\u0440\u0435\u0434\u0438\u0442 \u043D\u0430 \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u0443\u044E \u0441\u0443\u043C\u043C\u0443!" ) ; return ; } Credit credit = new Credit ( ) ; try { credit . setDate ( new Date ( ) ) ; credit . setSum ( creditSum ) ; credit . setStatus ( 0 ) ; credit . setClientId ( clientsId ) ; int crProgId = crProg . getId ( ) ; credit . setCreditProgramId ( crProgId ) ; creditDAO . add ( credit ) ; creditDAO . initTableModel ( creditTable , creditDAO . getCreditsByClientsId ( clientsId ) ) ; JOptionPane . showMessageDialog ( this , "\u0412\u0430\u0448\u0430 \u0437\u0430\u044F\u0432\u043A\u0430 \u043F\u0440\u0438\u043D\u044F\u0442\u0430!" ) ; } catch ( NumberFormatException exc ) { JOptionPane . showMessageDialog ( this , "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0434\u0430\u043D\u043D\u044B\u0445!" ) ; return ; } }
va	2	public static void main ( String [ ] args ) { for ( int i = 00 ; i <= FF ; i ++ ) { byte b = ( byte ) i ; int j = b < 0 ? 256 + b : b ; System . out . println ( "i = " + i + "\tb = " + j ) ; } }
va	8	public boolean step ( int time , boolean canFail ) { VirtualMachine [ ] allVms = vms . values ( ) . toArray ( new VirtualMachine [ vms . values ( ) . size ( ) ] ) ; boolean justFailed = false ; for ( VirtualMachine vm : allVms ) { vm . setRisk ( trec . getNodeRisk ( this ) ) ; vm . step ( ) ; if ( vm . isFinished ( ) ) { double previousLoad = getLoad ( ) ; remove ( vm ) ; assert getLoad ( ) < previousLoad ; } } if ( failure ) { failureTime ++ ; for ( VirtualMachine vm : allVms ) { vm . setStatus ( VirtualMachine . Status . FAILURE ) ; } if ( failureTime > RESTART_DURATION ) { for ( VirtualMachine vm : allVms ) { vm . setStatus ( VirtualMachine . Status . RESTARTING ) ; } failure = false ; probabilityOfFailure = 0 ; } } else if ( canFail ) { if ( probabilityOfFailure >= 1 ) { failure = true ; failureTime = 0 ; numberOfFailures ++ ; justFailed = true ; } else { probabilityOfFailure += 100 * ( 1 + ( double ) trec . getNodeRisk ( this ) ) / ( double ) Simulator . MAX_VM_DURATION ; } } return justFailed ; }
va	2	public void resetTabsContent ( ) { if ( mRestoreTabController != null ) mRestoreTabController . reset ( ) ; if ( mVisualizeTabController != null ) mVisualizeTabController . reset ( ) ; }
va	0	public static void main ( String [ ] args ) { String test = "a" ; int newLength = processStr ( test ) ; System . out . println ( newLength ) ; }
va	5	@ Override public double simulate ( ITracker it , IPointAwarder awarder , IEffortAwarder effort , int objectType ) { TrackerEnvironment env = null ; if ( effort != null ) { env = new TrackerEnvironment ( it , awarder , new ExplorationEffortAwarder ( ) ) ; } else { env = new TrackerEnvironment ( it , awarder ) ; } double score = 0 ; for ( int i = 0 ; i < 40 ; i ++ ) { switch ( objectType ) { case OBJECT_TYPE_VERTICAL : env . setFallingObject ( new VerticalFallingObject ( ) ) ; break ; case OBJECT_TYPE_SIDEWAYS : env . setFallingObject ( new SidewaysFallingObject ( ) ) ; break ; } score += env . run ( ) ; } if ( env . getEffortAwarder ( ) == null ) return score / 40.0 ; return score / 80.0 ; }
va	5	@ Override public void draw ( Graphics2D g ) { setMapPosition ( ) ; if ( jiggle ) { tracker ++ ; if ( tracker < 2 ) xmap += 4 ; else if ( tracker < 4 ) xmap -= 4 ; else { jiggle = false ; tracker = 0 ; } } if ( facingRight ) g . drawImage ( getAnimation ( ) . getImage ( ) , ( int ) ( ( xScreen + xmap ) - ( width / 2 ) ) , ( int ) ( ( yScreen + ymap ) - ( height / 2 ) ) , null ) ; else g . drawImage ( getAnimation ( ) . getImage ( ) , ( int ) ( ( ( xScreen + xmap ) - ( width / 2 ) ) + width ) , ( int ) ( ( yScreen + ymap ) - ( height / 2 ) ) , - width , height , null ) ; if ( getWorld ( ) . showBB ) { g . setColor ( Color . WHITE ) ; g . draw ( getRectangle ( ) ) ; } }
va	2	public ArrayList < EmployeeObject > readEmployees ( ) throws Exception { ArrayList < EmployeeObject > employees = new ArrayList < EmployeeObject > ( ) ; EmployeeObject employeeObject = null ; try { DBObject dbObject = new DBObject ( ) ; connect = dbObject . getConnection ( ) ; statement = connect . createStatement ( ) ; String sqlString = "SELECT " + FIELD_EMPLOYEE_ID + " " + FIELD_LOGIN_ID + " " + FIELD_LOGIN_PW + " " + FIELD_LOGIN_PW_QUESTION + " " + FIELD_LOGIN_PW_ANSWER + " " + FIELD_FIRST_NAME + " " + FIELD_LAST_NAME + " " + FIELD_EMAIL_ADDRESS + " " + FIELD_PHONE_COUNTRY_PFX + " " + FIELD_PHONE_LINE_NUMBER + " " + FIELD_PHONE_EXTENSION + " " + FIELD_MANAGER_IND + " " + FIELD_LAST_MOD_TS + " " + FIELD_LAST_MOD_USER + " " + "FROM " + TABLE_EMPLOYEE ; preparedStatement = connect . prepareStatement ( sqlString ) ; resultSet = preparedStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { employeeObject = new EmployeeObject ( ) ; employeeObject . setEmployeeId ( resultSet . getInt ( FIELD_EMPLOYEE_ID ) ) ; employeeObject . setLoginId ( resultSet . getString ( FIELD_LOGIN_ID ) ) ; employeeObject . setLoginPw ( resultSet . getString ( FIELD_LOGIN_PW ) ) ; employeeObject . setLoginPwQuestion ( resultSet . getInt ( FIELD_LOGIN_PW_QUESTION ) ) ; employeeObject . setLoginPwAnswer ( resultSet . getString ( FIELD_LOGIN_PW_ANSWER ) ) ; employeeObject . setFirstName ( resultSet . getString ( FIELD_FIRST_NAME ) ) ; employeeObject . setLastName ( resultSet . getString ( FIELD_LAST_NAME ) ) ; employeeObject . setEmailAddress ( resultSet . getString ( FIELD_EMAIL_ADDRESS ) ) ; employeeObject . setPhoneCountryPfx ( resultSet . getString ( FIELD_PHONE_COUNTRY_PFX ) ) ; employeeObject . setPhoneLineNumber ( resultSet . getString ( FIELD_PHONE_LINE_NUMBER ) ) ; employeeObject . setPhoneExtension ( resultSet . getString ( FIELD_PHONE_EXTENSION ) ) ; employeeObject . setManagerInd ( resultSet . getString ( FIELD_MANAGER_IND ) ) ; employees . add ( employeeObject ) ; } } catch ( Exception e ) { throw e ; } finally { close ( ) ; } return employees ; }
va	3	protected void copyGradOutput ( final int source , final int dest , final int layer ) { final int albd = this . structure . layers [ layer ] . arrayslbd ; final int aubd = this . structure . layers [ layer ] . arraysubd ; for ( int i = albd ; i <= aubd ; i ++ ) { final CellArray a = this . structure . arrays [ i ] ; if ( ( a . celltype != CellType . VALUE ) && ( a . layer != this . structure . outputlayer ) ) { DoubleTools . copy ( this . data . gradoutput [ source ] , a . cellslbd , this . data . gradoutput [ dest ] , a . cellslbd , a . cellsnum ) ; } } }
va	7	public void writeEnvironment ( StringBuilder code , Environment env ) { for ( Environment . EnvironmentEntry ent : env ) { if ( ent . loc . type != Location . LocationType . HeapLocation ) continue ; if ( ent . val . type instanceof ArrayType ) { ArrayType t = ( ArrayType ) ent . val . type ; int min = Math . min ( t . min , 0 ) ; int i = t . min ; for ( ; min <= t . max ; min ++ ) { String lb = ( min == 0 ? ent . loc . getLabel ( ) : spc ) ; String cmt = ( min == t . min ? "; " + ent . val . name : "" ) ; code . append ( lb + " DC " + getValue ( ent . defaultValue , min - i ) + cmt + "\n" ) ; } } else if ( ent . val . type instanceof FunctionType ) { continue ; } else { code . append ( ent . loc . getLabel ( ) + " DC " + getValue ( ent . defaultValue , 0 ) + "; " + ent . val . name + "\n" ) ; } } }
va	7	private void factor ( ) { Token t = popToken ( ) ; switch ( t . getTokenType ( ) ) { case SCONSTANT : case SSTRING : case SFALSE : case STRUE : break ; case SIDENTIFIER : pushToken ( t ) ; variable ( ) ; break ; case SLPAREN : expression ( ) ; expectToken ( TokenType . SRPAREN ) ; break ; case SNOT : factor ( ) ; break ; default : fail ( t ) ; } }
va	5	@ Override public void setTable ( final JTable table ) { JTable old = this . table ; if ( table != old ) { if ( ( old != null ) && ( old . getModel ( ) != null ) ) { old . getModel ( ) . removeTableModelListener ( this ) ; } if ( ( table != null ) && ( table . getModel ( ) != null ) ) { table . getModel ( ) . addTableModelListener ( this ) ; } } this . table = table ; firePropertyChange ( "table" , old , table ) ; }
va	2	public static void main ( String [ ] args ) { System . out . println ( "Testing Hash Table\n" ) ; HashTable hash = new HashTable ( 100 ) ; int [ ] lines = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int [ ] columns = { 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 } ; for ( int i = 0 ; i < lines . length ; i ++ ) { for ( int j = 0 ; j < columns . length ; j ++ ) { hash . put ( lines [ i ++ ] , columns [ j ] ) ; } } hash . put ( 1 , 1000 ) ; System . out . println ( hash . get ( 0 ) ) ; System . out . println ( hash . get ( 1 ) ) ; System . out . println ( "Filled size is " + hash . filledSize ) ; hash . put ( 31 , 1001 ) ; hash . put ( 22 , 1001 ) ; System . out . println ( hash . get ( 1 ) ) ; System . out . println ( hash . get ( 5 ) ) ; System . out . println ( "Filled size is " + hash . filledSize ) ; hash . print ( ) ; System . out . println ( "Removing element 5:" ) ; hash . remove ( 5 ) ; System . out . println ( "Filled size is " + hash . filledSize ) ; hash . print ( ) ; }
va	4	public final CC cell ( int ... colRowWidthHeight ) { switch ( colRowWidthHeight . length ) { default : throw new IllegalArgumentException ( "Illegal argument count: " + colRowWidthHeight . length ) ; case 4 : setSpanY ( colRowWidthHeight [ 3 ] ) ; case 3 : setSpanX ( colRowWidthHeight [ 2 ] ) ; case 2 : setCellY ( colRowWidthHeight [ 1 ] ) ; case 1 : setCellX ( colRowWidthHeight [ 0 ] ) ; } return this ; }
va	1	@ Override public void solve ( final IUpdateInfo uInfo ) { final DynamicBody bodyB = ( DynamicBody ) this . bodyB ; if ( bodyA . isStatic ( ) ) { final Vector3f dV = VectorPool . getVectorV3 ( false ) ; dV . setSubtract ( bodyB . getPosition ( ) , bodyA . getPosition ( ) ) ; final float currentDistance = dV . length ( ) ; dV . scale ( 1F / currentDistance ) ; final float relVel = bodyB . getLinearVelocity ( ) . . ( dV ) ; final float relDist = currentDistance - distance ; final float remove = relVel + relDist * uInfo . getInverseRate ( ) ; bodyB . getLinearVelocity ( ) . subtractScaled ( dV , remove ) ; VectorPool . release ( dV ) ; } else { final DynamicBody bodyA = ( DynamicBody ) this . bodyA ; final Vector3f dV = VectorPool . getVectorV3 ( false ) ; final Vector3f vV = VectorPool . getVectorV3 ( false ) ; dV . setSubtract ( bodyB . getPosition ( ) , bodyA . getPosition ( ) ) ; final float currentDistance = dV . length ( ) ; dV . scale ( 1F / currentDistance ) ; vV . setSubtract ( bodyB . getLinearVelocity ( ) , bodyA . getLinearVelocity ( ) ) ; final float relVel = vV . . ( dV ) ; final float relDist = currentDistance - distance ; final float remove = relVel + relDist * uInfo . getInverseRate ( ) ; dV . scale ( remove / ( bodyA . getInverseMass ( ) + bodyB . getInverseMass ( ) ) ) ; bodyB . getLinearVelocity ( ) . subtractScaled ( dV , bodyB . getInverseMass ( ) ) ; bodyA . getLinearVelocity ( ) . addScaled ( dV , bodyA . getInverseMass ( ) ) ; VectorPool . release ( dV ) ; VectorPool . release ( vV ) ; } }
va	0	public void setUniform ( String uniformName , BaseLight baseLight ) { setUniform ( uniformName + ".color" , baseLight . getColor ( ) ) ; setUniformf ( uniformName + ".intensity" , baseLight . getIntensity ( ) ) ; }
va	9	private void draw3dScreen ( ) { drawSplitPrivateChat ( ) ; if ( crossType == 1 ) { crosses [ crossIndex / 100 ] . drawImage ( crossX - 8 - 4 , crossY - 8 - 4 ) ; anInt1142 ++ ; if ( anInt1142 > 67 ) { anInt1142 = 0 ; outStream1 . createFrame ( 78 ) ; } } if ( crossType == 2 ) crosses [ 4 + crossIndex / 100 ] . drawImage ( crossX - 8 - 4 , crossY - 8 - 4 ) ; if ( anInt1018 != - 1 ) { method119 ( anInt945 , anInt1018 ) ; drawInterface ( 0 , 0 , RSInterface . interfaceCache [ anInt1018 ] , 0 ) ; } if ( openInterfaceID != - 1 ) { method119 ( anInt945 , openInterfaceID ) ; drawInterface ( 0 , 0 , RSInterface . interfaceCache [ openInterfaceID ] , 0 ) ; } method70 ( ) ; if ( ! menuOpen ) { processRightClick ( ) ; drawTooltip ( ) ; } else if ( menuScreenArea == 0 ) drawMenu ( ) ; if ( anInt1055 == 1 ) headIcons [ 1 ] . drawImage ( 472 , 296 ) ; if ( fpsOn ) { char c = ǻ ; int k = 20 ; int i1 = ffff00 ; if ( super . fps < 15 ) i1 = ff0000 ; aTextDrawingArea_1271 . method380 ( "Fps:" + super . fps , c , i1 , k ) ; k += 15 ; Runtime runtime = Runtime . getRuntime ( ) ; int j1 = ( int ) ( ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / 1024 ) ; i1 = ffff00 ; if ( j1 > 2000000 && lowMemory ) i1 = ff0000 ; aTextDrawingArea_1271 . method380 ( "Mem:" + j1 + "k" , c , ffff00 , k ) ; k += 15 ; } if ( anInt1104 != 0 ) { int j = anInt1104 / 50 ; int l = j / 60 ; j %= 60 ; if ( j < 10 ) aTextDrawingArea_1271 . method385 ( ffff00 , "System update in: " + l + ":0" + j , 329 , 4 ) ; else aTextDrawingArea_1271 . method385 ( ffff00 , "System update in: " + l + ":" + j , 329 , 4 ) ; anInt849 ++ ; if ( anInt849 > 75 ) { anInt849 = 0 ; outStream1 . createFrame ( 148 ) ; } } }
va	6	public boolean start ( ) { synchronized ( optOutLock ) { if ( isOptOut ( ) ) { return false ; } if ( taskId >= 0 ) { return true ; } taskId = plugin . getServer ( ) . getScheduler ( ) . scheduleAsyncRepeatingTask ( plugin , new Runnable ( ) { private boolean firstPost = true ; public void run ( ) { try { synchronized ( optOutLock ) { if ( isOptOut ( ) && taskId > 0 ) { plugin . getServer ( ) . getScheduler ( ) . cancelTask ( taskId ) ; taskId = - 1 ; for ( Graph graph : graphs ) { graph . onOptOut ( ) ; } } } postPlugin ( ! firstPost ) ; firstPost = false ; } catch ( IOException e ) { Bukkit . getLogger ( ) . log ( Level . INFO , "[Metrics] " + e . getMessage ( ) ) ; } } } , 0 , PING_INTERVAL * 1200 ) ; return true ; } }
va	2	private final void step2 ( ) { if ( ends ( "y" ) && vowelinstem ( ) ) b [ k ] = i ; }
va	4	public User getUser ( String username ) throws ServerException { User user = null ; try { String inputMessage ; output . writeObject ( Messages . GETUSER ) ; output . flush ( ) ; inputMessage = ( String ) input . readObject ( ) ; if ( ! inputMessage . equals ( Messages . OK ) ) throw new ServerException ( "Unexpected input " + inputMessage ) ; output . writeObject ( username ) ; output . flush ( ) ; user = ( User ) input . readObject ( ) ; if ( user == null ) throw new ServerException ( "Unexpected input: null user" ) ; inputMessage = ( String ) input . readObject ( ) ; if ( ! inputMessage . equals ( Messages . OK ) ) throw new ServerException ( "Unexpected input " + inputMessage ) ; System . out . println ( "USUARIO:D" ) ; } catch ( Exception e ) { throw new ServerException ( e . getMessage ( ) ) ; } return user ; }
va	0	public Baconian ( ) { Init_map ( ) ; }
va	2	protected Object [ ] pearParams ( Object [ ] args ) { Object [ ] nArgs = new Object [ args . length ] ; for ( int i = 0 ; i < nArgs . length ; i ++ ) { Object o = args [ i ] ; if ( o instanceof Date ) { Date d = ( Date ) o ; o = new java . sql . Timestamp ( d . getTime ( ) ) ; } nArgs [ i ] = o ; } return nArgs ; }
va	5	public ArrayList < Claim > getClaims ( Employee employee ) { ArrayList < Claim > claimList = new ArrayList < Claim > ( ) ; ArrayList < Claim . Status > matchingStatuses = new ArrayList < Claim . Status > ( ) ; switch ( employee . getDepartment ( ) ) { case CarDamage : matchingStatuses . add ( Claim . Status . UnRanked ) ; if ( employee . getRank ( ) == Employee . Rank . High ) { matchingStatuses . add ( Claim . Status . Ranked ) ; } break ; case Finance : matchingStatuses . add ( Claim . Status . Confirmed ) ; break ; default : return claimList ; } for ( Claim c : this . claimList . values ( ) ) { if ( matchingStatuses . contains ( c . getStatus ( ) ) ) { claimList . add ( c ) ; } } return claimList ; }
va	4	public Section getSectionAtTile ( int tileX , int tileZ ) { int chunkX = tileX >> 4 ; int chunkZ = tileZ >> 4 ; if ( chunkX < this . getMinChunkXBorder ( ) || chunkX > this . getMaxChunkXBorder ( ) ) { Settling . log . warning ( "Request for out of reach section." ) ; return null ; } if ( chunkZ < this . getMinChunkZBorder ( ) || chunkZ > this . getMaxChunkZBorder ( ) ) { Settling . log . warning ( "Request for out of reach section." ) ; return null ; } return this . getSection ( chunkX >> 4 , chunkZ >> 4 ) ; }
va	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Pair pair = ( Pair ) o ; if ( key != null ? ! key . equals ( pair . key ) : pair . key != null ) return false ; if ( value != null ? ! value . equals ( pair . value ) : pair . value != null ) return false ; return true ; }
va	8	public void predictLabels ( int [ ] heads , int [ ] deplbids , boolean addLoss ) { assert ( heads . length == len ) ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; int T = ntypes ; for ( int mod = 1 ; mod < len ; ++ mod ) { int head = heads [ mod ] ; int type = addLoss ? 0 : 1 ; double best = getLabelScore ( arcLis , heads , mod , type ) + ( addLoss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( int t = type + 1 ; t < T ; ++ t ) { double va = getLabelScore ( arcLis , heads , mod , t ) + ( addLoss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
va	6	@ Override public boolean ready ( ) throws IOException { ensureOpen ( ) ; if ( skipLF ) { if ( nextChar >= nChars && in . ready ( ) ) { fill ( ) ; } if ( nextChar < nChars ) { if ( cb [ nextChar ] == '' ) nextChar ++ ; skipLF = false ; } } return ( nextChar < nChars ) || in . ready ( ) ; }
va	7	private Node getNextToExpand ( ) { Integer bestCost = null ; Node next = null ; for ( int i = 0 ; i < nodes . length ; i ++ ) for ( int j = 0 ; j < nodes [ i ] . length ; j ++ ) { Node nd = nodes [ i ] [ j ] ; if ( nd != null && ! nd . isVisited ( ) ) { if ( nd . getCost ( ) == null ) continue ; if ( bestCost == null || bestCost > nd . getCost ( ) ) { bestCost = nd . getCost ( ) ; next = nd ; } } } return next ; }
va	1	public Method match ( Type [ ] args ) { List < Method > m = TypeUtils . searchMethod ( m_clazz , m_name , args ) ; if ( m == null ) { return null ; } return m . get ( 0 ) ; }
va	8	private Node put ( Key key , Value value , Node x ) { if ( x == null ) { return new Node ( key , value , 1 , RED ) ; } int cmp = key . compareTo ( x . key ) ; if ( cmp < 0 ) { x . left = put ( key , value , x . left ) ; } else if ( cmp > 0 ) { x . right = put ( key , value , x . right ) ; } else { x . value = value ; } if ( ! isRed ( x . left ) && isRed ( x . right ) ) { x = ronateLeft ( x ) ; } if ( isRed ( x . left ) && isRed ( x . left . left ) ) { x = ronateRight ( x ) ; } if ( isRed ( x . left ) & isRed ( x . right ) ) { x = flipColor ( x ) ; } return x ; }
va	8	@ Override public void onPaint ( DrawingInterface g , int width , int height ) { if ( img == null ) return ; setStretchFlag ( stretch ) ; g . gStretchBitmap ( getX ( ) , getY ( ) , Dim . W ( w , minX ) , Dim . H ( h , minY ) , img , Comm . STRETCH_HV ) ; if ( selectable && selectStarted && endX != 0 && endY != 0 ) { g . gSetColor ( Skin . BUTTON_ON , 128 ) ; g . gFillRectangle ( ( int ) Math . min ( startX , endX ) , ( int ) Math . min ( startY , endY ) , ( int ) Math . abs ( endX - startX ) , ( int ) ( Math . abs ( endY - startY ) ) ) ; g . gSetColor ( Colors . BLACK ) ; g . gDrawRectangle ( ( int ) Math . min ( startX , endX ) , ( int ) Math . min ( startY , endY ) , ( int ) Math . abs ( endX - startX ) , ( int ) ( Math . abs ( endY - startY ) ) ) ; } else if ( selectable && tempX != 0 && tempY != 0 ) { g . gSetColor ( Skin . BUTTON_ON , 128 ) ; g . gDrawLine ( getX ( ) , ( int ) tempY , getX ( ) + Dim . W ( w , minX ) , ( int ) tempY ) ; g . gDrawLine ( ( int ) tempX , getY ( ) , ( int ) tempX , getY ( ) + Dim . H ( h , minY ) ) ; } }
va	0	@ Override public void windowActivated ( WindowEvent e ) { return ; }
va	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
va	4	public boolean isFitxaCursCreated ( int nexp , String curs ) { boolean iscreated = false ; String any = curs . trim ( ) ; any = StringUtils . BeforeLast ( any , "-" ) ; String SQL1 = "SELECT * from `" + ICoreData . core_mysqlDBPrefix + "`.fitxa_alumne_curs where Exp_FK_ID=" + nexp + " AND " + "Any_academic='" + any + "'" ; try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; if ( rs1 != null && rs1 . next ( ) ) { iscreated = true ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( BeanDadesPersonals . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return iscreated ; }
va	2	static int ccw ( Point a , Point b , Point c , Point world ) { b = b . subtract ( a ) ; c = c . subtract ( a ) ; double d = world . . ( b . cross ( c ) ) ; if ( d > EPS ) return + 1 ; if ( d + EPS < 0 ) return - 1 ; return 0 ; }
va	7	public static void write ( MetadataObject entry , DataOutputStream stream ) throws IOException { int id = ( entry . getType ( ) << 5 | entry . getMask ( ) & 1F ) & FF ; stream . writeByte ( id ) ; switch ( entry . getType ( ) ) { case 0 : stream . writeByte ( ( byte ) entry . getData ( ) ) ; break ; case 1 : stream . writeShort ( ( short ) entry . getData ( ) ) ; break ; case 2 : stream . writeInt ( ( Integer ) entry . getData ( ) ) ; break ; case 3 : stream . writeFloat ( ( float ) entry . getData ( ) ) ; break ; case 4 : stream . writeUTF ( ( String ) entry . getData ( ) ) ; break ; case 5 : ItemStack itemstack = ( ItemStack ) entry . getData ( ) ; stream . writeShort ( itemstack . getId ( ) ) ; stream . writeByte ( itemstack . getCount ( ) ) ; stream . writeShort ( itemstack . getDamage ( ) ) ; case 6 : BlockPosition pos = ( BlockPosition ) entry . getData ( ) ; stream . writeInt ( pos . getX ( ) ) ; stream . writeInt ( pos . getY ( ) ) ; stream . writeInt ( pos . getZ ( ) ) ; default : throw new UnsupportedOperationException ( "Unknown metadata type: " + entry . getType ( ) ) ; } }
va	2	public static int addscaledsprite ( sprite s , int scaledsizex , int scaledsizey ) { int ref = - 1 ; String filelocation = s . getfilelocation ( ) ; URL locationurl = spritestore . class . getResource ( filelocation ) ; System . out . println ( "-----" ) ; System . out . println ( "SPRITESTORE ATTEMPTING TO SCALE AND LOAD IMAGE AT LOCATION:  " + locationurl ) ; Image tempimage ; try { tempimage = new ImageIcon ( locationurl ) . getImage ( ) ; tempimage = tempimage . getScaledInstance ( scaledsizex , scaledsizey , scalinghint ) ; ref = add ( tempimage ) ; if ( ref == - 1 ) { throw new Exception ( "FAILED TO ALLOC. IMAGE TO ARRAY" ) ; } System . out . println ( "SPRITESTORE SCALED AND STORED IMAGE SUCCESSFULLY AT REF:  " + ref ) ; } catch ( Exception e ) { System . out . println ( "SPRITESTORE FAILED TO SCALE AND/OR LOAD IMAGE:  " + e . getMessage ( ) ) ; ref = - 1 ; } System . out . println ( "-----" ) ; return ref ; }
va	8	private void processNetwork ( ) { if ( ! network . isValid ( ) ) parent . fail ( "Network lost" ) ; while ( network . hasInboundPackets ( ) ) { Packet packet = network . nextInboundPacket ( ) ; if ( packet instanceof WindowPacket ) { WindowPacket spp = ( WindowPacket ) packet ; temp . setLocation ( spp . x , spp . y ) ; World . worldCoordToScreenCoord ( temp , temp ) ; System . err . println ( "Force viewport " + spp . x + ":" + spp . y + " " + temp ) ; parent . setViewportLocation ( temp ) ; } else if ( packet instanceof WorldRegionPacket ) { WorldRegionPacket wrp = ( WorldRegionPacket ) packet ; int entries = wrp . entries ( ) ; if ( entries > 0 ) { int [ ] locations = new int [ entries ] ; byte [ ] tiles = new byte [ entries ] ; wrp . readUpdates ( locations , tiles ) ; world . writeTiles ( locations , tiles ) ; } } else if ( packet instanceof WorldUpdatesPacket ) { WorldUpdatesPacket wup = ( WorldUpdatesPacket ) packet ; world . writeTiles ( wup . locations , wup . tiles ) ; } else if ( packet instanceof EntitiesPacket ) { EntitiesPacket ep = ( EntitiesPacket ) packet ; world . updateEntities ( ep . data , ep . checkpoint ) ; } else if ( packet instanceof PlayerUpdatePacket ) { PlayerUpdatePacket pup = ( PlayerUpdatePacket ) packet ; values . read ( pup . data ) ; stone = values . get ( Constants . V_PLAYER_STONES ) ; iron = values . get ( Constants . V_PLAYER_IRON ) ; gold = values . get ( Constants . V_PLAYER_GOLD ) ; playerId = values . get ( Constants . V_PLAYER_ID ) ; } else throw new RuntimeException ( "Unknown packet: " + packet . packetId ( ) ) ; } World . screenCoordToWorldCoord ( parent . getViewportLocation ( ) , temp ) ; WindowPacket wp = new WindowPacket ( ( int ) temp . getX ( ) , ( int ) temp . getY ( ) ) ; network . send ( wp ) ; }
va	7	@ Override public ResultadoAvItem [ ] getresultadoAvItem ( String refeicao , String data ) { List < ResultadoAvItem > resultList = new ArrayList < ResultadoAvItem > ( ) ; Iterator < List < AvaliacaoItem >> avaliacoes = avItens . values ( ) . iterator ( ) ; List < AvaliacaoItem > avs = null ; while ( avaliacoes . hasNext ( ) ) { avs = avaliacoes . next ( ) ; if ( avs != null ) { ResultadoAvItem r = new ResultadoAvItem ( ) ; r . setItem ( avs . get ( 0 ) . getItem ( ) ) ; r . setData ( avs . get ( 0 ) . getData ( ) ) ; r . setRefeicao ( refeicao ) ; r . setDesgostaram ( 0 ) ; r . setGostaram ( 0 ) ; r . setIndiferente ( 0 ) ; for ( AvaliacaoItem avi : avs ) { if ( avi . getRefeicao ( ) . equals ( refeicao ) && avi . getDataFormatoAmericano ( ) . equals ( data ) ) { if ( avi . getNivelSatisfacao ( ) . toString ( ) . equals ( NivelSatisfacao . GOSTEI . toString ( ) ) ) { r . setGostaram ( r . getGostaram ( ) + 1 ) ; } else if ( avi . getNivelSatisfacao ( ) . toString ( ) . equals ( NivelSatisfacao . DESGOSTEI . toString ( ) ) ) { r . setDesgostaram ( r . getDesgostaram ( ) + 1 ) ; } else { r . setIndiferente ( r . getIndiferente ( ) + 1 ) ; } } } r . setTotalVotos ( r . getGostaram ( ) + r . getDesgostaram ( ) + r . getIndiferente ( ) ) ; resultList . add ( r ) ; } } return resultList . toArray ( new ResultadoAvItem [ resultList . size ( ) ] ) ; }
va	1	public static String getString ( String substr , int count ) { String str = "" ; for ( int i = 0 ; i < count ; i ++ ) { str += substr ; } return str ; }
va	4	public static int triangleBmin ( int x [ ] [ ] ) { int min = x [ 0 ] [ 0 ] ; for ( int i = 0 ; i < x . length ; i ++ ) { System . out . print ( "\n" ) ; for ( int j = 0 ; j < x [ i ] . length ; j ++ ) { if ( i >= j ) { System . out . print ( x [ i ] [ j ] + " " ) ; if ( min > x [ i ] [ j ] ) { min = x [ i ] [ j ] ; } } } } System . out . println ( ) ; return min ; }
va	3	public Game create ( GameType gameType ) { Game game = null ; Player player1 = null ; Player player2 = null ; if ( gameType == null ) { throw new IllegalArgumentException ( "MainCommands - create: gameType is null" ) ; } if ( gameType == GameType . ONE_PLAYER ) { game = new Game ( GameType . ONE_PLAYER ) ; player1 = new Player ( PlayerType . REGULAR_PLAYER , PLAYER_1_DEFAULT_MARKER ) ; player2 = new Player ( PlayerType . COMPUTER_PLAYER , PLAYER_2_DEFAULT_MARKER ) ; } else if ( gameType == GameType . TWO_PLAYER ) { game = new Game ( GameType . TWO_PLAYER ) ; player1 = new Player ( PlayerType . REGULAR_PLAYER , PLAYER_1_DEFAULT_MARKER ) ; player2 = new Player ( PlayerType . REGULAR_PLAYER , PLAYER_2_DEFAULT_MARKER ) ; } game . setPlayer1 ( player1 ) ; game . setPlayer2 ( player2 ) ; return game ; }
va	9	public static ServerConnections getServerConnections ( PropsUtils props , boolean askForServerHost ) { String serverUrl = props . getString ( PropsUtils . serverHost ) ; String oldServerUrl = serverUrl ; while ( true ) { if ( askForServerHost ) { serverUrl = JOptionPane . showInputDialog ( "SqueezeServerHost: " , serverUrl ) ; if ( serverUrl == null ) { return null ; } } askForServerHost = true ; SlimServer slimServer = null ; try { System . out . println ( "Trying to connect to " + serverUrl ) ; if ( serverUrl . indexOf ( : ) > 0 ) { String [ ] bits = serverUrl . split ( ":" ) ; if ( bits . length == 2 ) { slimServer = new SlimServer ( bits [ 0 ] , Integer . parseInt ( bits [ 1 ] ) ) ; } else if ( bits . length == 3 ) { slimServer = new SlimServer ( bits [ 0 ] , Integer . parseInt ( bits [ 1 ] ) , Integer . parseInt ( bits [ 2 ] ) ) ; } else { System . out . println ( "Bad url? [" + serverUrl + "]  expecting url:webport or url:cliport:webport" ) ; slimServer = new SlimServer ( serverUrl ) ; } } else { slimServer = new SlimServer ( serverUrl ) ; } CoverSource coverSource = new SlimCoverSource ( slimServer , noteImage , new CachedOnFileSystemCS ( ) ) ; if ( ! serverUrl . equals ( oldServerUrl ) ) { props . setString ( PropsUtils . serverHost , serverUrl ) ; props . save ( ) ; } return new ServerConnections ( slimServer , coverSource ) ; } catch ( SlimConnectionException e ) { JOptionPane . showMessageDialog ( null , "Failed to connect to [" + serverUrl + "] with " + e ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Failed to get covers from [" + serverUrl + "] with " + e ) ; } } }
va	6	protected boolean find_recovery_config ( boolean debug ) { Symbol error_token ; int act ; if ( debug ) debug_message ( "# Finding recovery state on stack" ) ; int right_pos = ( ( Symbol ) stack . peek ( ) ) . right ; int left_pos = ( ( Symbol ) stack . peek ( ) ) . left ; while ( ! shift_under_error ( ) ) { if ( debug ) debug_message ( "# Pop stack by one  state was # " + ( ( Symbol ) stack . peek ( ) ) . parse_state ) ; left_pos = ( ( Symbol ) stack . pop ( ) ) . left ; tos -- ; if ( stack . empty ( ) ) { if ( debug ) debug_message ( "# No recovery state found on stack" ) ; return false ; } } act = get_action ( ( ( Symbol ) stack . peek ( ) ) . parse_state , error_sym ( ) ) ; if ( debug ) { debug_message ( "# Recover state found (#" + ( ( Symbol ) stack . peek ( ) ) . parse_state + ")" ) ; debug_message ( "# Shifting on error to state #" + ( act - 1 ) ) ; } error_token = new Symbol ( error_sym ( ) , left_pos , right_pos ) ; error_token . parse_state = act - 1 ; error_token . used_by_parser = true ; stack . push ( error_token ) ; tos ++ ; return true ; }
va	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
va	3	private static void removeEmbed ( FramingContext state , String id ) { final Map < String , Object > embeds = state . embeds ; final Map < String , Object > embed = ( Map < String , Object > ) embeds . get ( id ) ; final Object parent = embed . get ( "parent" ) ; final String property = ( String ) embed . get ( "property" ) ; final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; subject . put ( "@id" , id ) ; if ( isArray ( parent ) ) { for ( int i = 0 ; i < ( ( List ) parent ) . size ( ) ; i ++ ) { if ( compareValues ( ( ( List ) parent ) . get ( i ) , subject ) ) { ( ( List ) parent ) . set ( i , subject ) ; break ; } } } else { removeValue ( ( ( Map < String , Object > ) parent ) , property , subject , ( ( Map < String , Object > ) parent ) . get ( property ) instanceof List ) ; addValue ( ( ( Map < String , Object > ) parent ) , property , subject , ( ( Map < String , Object > ) parent ) . get ( property ) instanceof List ) ; } removeDependents ( embeds , id ) ; }
va	8	@ Override public void mousePressed ( MouseEvent e ) { if ( selectedOC != null ) { if ( enteredIC != null ) { try { selectedOC . addConnected ( enteredIC ) ; selectedOC . setSelected ( false ) ; selectedOC = null ; enteredIC . setSelected ( false ) ; enteredIC = null ; repaint ( ) ; } catch ( ConnectException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) ) ; } } else { selectedOC . setSelected ( false ) ; selectedOC = null ; repaint ( ) ; } } else if ( e . isPopupTrigger ( ) ) { for ( Component ele : elements ) { if ( ele . contains ( e . getPoint ( ) ) ) { setSelected ( ele ) ; ele . showMenu ( e . getX ( ) , e . getY ( ) ) ; changed ( ) ; break ; } } } else { mxSave = e . getX ( ) ; mySave = e . getY ( ) ; Component tmp = null ; for ( Component ele : elements ) { if ( ele . isInside ( mxSave , mySave ) ) { tmp = ele ; break ; } } setSelected ( tmp ) ; repaint ( ) ; } }
va	6	protected void encodeNotation ( String nodeName , String systemid , String publicid ) throws IOException { current_octet |= FastInfosetConstants . NOTATION_IDENTIFICATION ; boolean encodesystemid = ( systemid != null ) && ! systemid . isEmpty ( ) ; boolean encodepublicid = ( publicid != null ) && ! publicid . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; encodeIdentifyingStringOrIndex ( nodeName , vocabulary . other_ncnames ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( systemid , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( publicid , vocabulary . other_uris ) ; } }
va	8	public static double findMedianSortedArrays ( int A [ ] , int B [ ] ) { int n = A . length ; int m = B . length ; if ( n > m ) return findMedianSortedArrays ( B , A ) ; int k = ( n + m - 1 ) / 2 ; int l = 0 , r = Math . min ( k , n ) ; while ( l < r ) { int midA = ( l + r ) / 2 ; int midB = k - midA ; System . out . println ( midA + " " + midB ) ; if ( A [ midA ] < B [ midB ] ) l = midA + 1 ; else r = midA ; } int a = Math . max ( l > 0 ? A [ l - 1 ] : Integer . MIN_VALUE , k - l >= 0 ? B [ k - l ] : Integer . MIN_VALUE ) ; if ( ( ( n + m ) & 1 ) == 1 ) return ( double ) a ; int b = Math . min ( l < n ? A [ l ] : Integer . MAX_VALUE , k - l + 1 < m ? B [ k - l + 1 ] : Integer . MAX_VALUE ) ; return ( a + b ) / 2.0 ; }
va	3	private String getMzmlFileName ( ) throws ValidationException { String text = this . mzmlTextField . getText ( ) . trim ( ) ; if ( text . trim ( ) . length ( ) > 0 ) { Path path = Paths . get ( text ) ; File f = path . toFile ( ) ; if ( f . exists ( ) && f . isFile ( ) ) { return path . toString ( ) ; } else { throw new ValidationException ( "Incorrect mzMl filename." , "BAD_FILENAME" ) ; } } else { throw new ValidationException ( "Incorrect mzMl filename." , "BAD_FILENAME" ) ; } }
va	6	public void basenotetoRight ( Piano piano ) { if ( this . isCurrentKeyTreble ( ) ) { if ( ( this . nbnotesupper == 7 & this . basetreble > - 20 ) | ( this . nbnotesupper == 4 & this . basetreble > - 35 ) | ( this . nbnotesupper == 3 & this . basetreble > - 40 ) | ( this . nbnotesupper == 2 & this . basetreble > - 45 ) | ( this . nbnotesupper == 1 & this . basetreble > - 50 ) ) { this . basetreble = this . basetreble - 5 ; } } else if ( this . isCurrentKeyBass ( ) ) { if ( ( this . nbnotesupper == 7 & this . basebass > - 20 ) | ( this . nbnotesupper == 4 & this . basebass > - 35 ) | ( this . nbnotesupper == 3 & this . basebass > - 40 ) | ( this . nbnotesupper == 2 & this . basebass > - 45 ) | ( this . nbnotesupper == 1 & this . basebass > - 50 ) ) { this . basebass = this . basebass - 5 ; } } else if ( this . isCurrentKeyBoth ( ) ) { if ( ( this . nbnotesupper == 7 & this . basebass > 15 ) | ( this . nbnotesupper == 4 & this . basebass > 0 ) | ( this . nbnotesupper == 3 & this . basebass > - 5 ) | ( this . nbnotesupper == 2 & this . basebass > - 10 ) | ( this . nbnotesupper == 1 & this . basebass > - 15 ) ) { this . basebass = this . basebass - 5 ; this . basetreble = this . basetreble - 5 ; } } }
va	8	public void startFrame ( ) { frame ++ ; if ( bgPix != null ) { int l = Math . max ( 0 , Math . min ( W , left ) ) ; int r = Math . max ( 0 , Math . min ( W , right ) ) ; int t = Math . max ( 0 , Math . min ( H , top ) ) ; int b = Math . max ( 0 , Math . min ( H , bottom ) ) ; for ( int y = 0 ; y < t ; y ++ ) copy ( bgPix , pix , xy2i ( 0 , y ) , W ) ; for ( int y = t ; y < b ; y ++ ) copy ( bgPix , pix , xy2i ( 0 , y ) , l ) ; for ( int y = t ; y < b ; y ++ ) copy ( bgPix , pix , xy2i ( r , y ) , W - r ) ; for ( int y = b ; y < H ; y ++ ) copy ( bgPix , pix , xy2i ( 0 , y ) , W ) ; } for ( int y = top ; y < bottom ; y ++ ) { int i = xy2i ( left , y ) ; for ( int x = left ; x < right ; x ++ ) { zbuffer [ i ] = bgZ ; pix [ i ] = bgPix == null ? bgColor : bgPix [ i ] ; i ++ ; } } nParticles = 0 ; }
va	7	private void showClientChildren ( final DefaultMutableTreeNode node ) { clientTree . setEnabled ( false ) ; progressBar . setVisible ( true ) ; progressBar . setIndeterminate ( true ) ; SwingWorker < void , File > worker = new SwingWorker < void , File > ( ) { @ Override public void doInBackground ( ) { System . out . println ( "I AM CRISTIANO RONALDO!" ) ; System . out . println ( "I AM messi!" ) ; System . out . println ( "MY HORSE DANCED ON MY CHAIR!" ) ; byte [ ] temp = { ( byte ) 3 } ; FilePlus file = ( FilePlus ) node . getUserObject ( ) ; if ( file . isDirectory ( ) ) { ArrayList < File > nodeChildren = null ; try { commandOut . write ( temp , 0 , 1 ) ; commandOut . flush ( ) ; writeStringOutStream ( dataOut , file . getAbsolutePath ( ) ) ; nodeChildren = new ArrayList < File > ( ) ; System . out . println ( "STROLL AROUND TOWN" ) ; int numFiles = objectReader . readInt ( ) ; System . out . println ( "GAS STATION" ) ; System . out . println ( "NUM FILES: " + numFiles ) ; for ( int i = 0 ; i < numFiles ; i ++ ) { nodeChildren . add ( ( File ) objectReader . readObject ( ) ) ; } for ( File clientFile : nodeChildren ) { if ( clientFile . isDirectory ( ) ) { publish ( clientFile ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } setClientTableData ( nodeChildren . toArray ( new File [ nodeChildren . size ( ) ] ) ) ; } return null ; } @ Override protected void process ( List < File > chunks ) { if ( chunks == null ) { return ; } node . removeAllChildren ( ) ; for ( File child : chunks ) { node . add ( new DefaultMutableTreeNode ( child ) ) ; } clientTreeModel . nodeStructureChanged ( node ) ; } @ Override protected void done ( ) { progressBar . setIndeterminate ( false ) ; progressBar . setVisible ( false ) ; clientTree . setEnabled ( true ) ; } } ; worker . execute ( ) ; }
va	6	public void connectGeneral ( TreeLinkNode root ) { LinkedList < TreeLinkNode > queue = new LinkedList < TreeLinkNode > ( ) ; if ( root == null ) return ; queue . offer ( root ) ; while ( ! queue . isEmpty ( ) ) { int size = queue . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { TreeLinkNode current = queue . poll ( ) ; if ( current . left != null ) queue . offer ( current . left ) ; if ( current . right != null ) queue . offer ( current . right ) ; if ( i != size - 1 ) current . next = queue . peek ( ) ; } } }
va	6	@ Override public void validate ( ) { if ( dailybdgt == null ) { addActionError ( "Please Enter Daily Budget" ) ; } if ( deliverytype == null ) { addActionError ( "Please Select Delivery Type" ) ; } if ( campaignname == null ) { addActionError ( "Please Enter Campaign Name" ) ; } if ( startdate == null ) { addActionError ( "Please Select Start Date" ) ; } if ( enddate == null ) { addActionError ( "Please Select End Date" ) ; } else { if ( startdate . after ( enddate ) ) { addActionError ( "Please Choose End date After Start Date " ) ; } } }
va	0	public String toString ( ) { return String . format ( "[%s] = [%s  %s  %s  %s  %s  %s  %s  %s]" , getPacketName ( ) , wallSignal . toString ( ) , cliffLeftSignal . toString ( ) , cliffFrontLeftSignal . toString ( ) , cliffFrontRightSignal . toString ( ) , cliffRightSignal . toString ( ) , cargoBayDigitalInputs . toString ( ) , cargoBayAnalogSignal . toString ( ) , chargingSourcesAvailable . toString ( ) ) ; }
va	8	public List < Integer > parts ( int n ) { int aTimesNPlusB = a_Times_n_Plus_b ( n ) ; for ( int a = 1 ; a < n + 1 || new ArrayList < Integer > ( ) . size ( ) == 2 ; a ++ ) { if ( a == 1 || isPrime ( a ) ) { if ( isPrime ( abs ( b ( n , aTimesNPlusB , a ) ) ) && allArePrimes ( a , b ( n , aTimesNPlusB , a ) , n ) ) { return asList ( a , b ( n , aTimesNPlusB , a ) ) ; } if ( isPrime ( abs ( b ( n , aTimesNPlusB , a / - 1 ) ) ) && allArePrimes ( a / - 1 , b ( n , aTimesNPlusB , a / - 1 ) , n ) ) { return asList ( a / - 1 , b ( n , aTimesNPlusB , a / - 1 ) ) ; } } } return new ArrayList < Integer > ( ) ; }
va	6	public void nestedEmphasis ( Node node ) { MutableObject o = new MutableObject ( ) ; Node next ; while ( node != null ) { next = node . next ; if ( ( node . tag == tt . tagB || node . tag == tt . tagI ) && node . parent != null && node . parent . tag == node . tag ) { o . setObject ( next ) ; discardContainer ( node , o ) ; next = ( Node ) o . getObject ( ) ; node = next ; continue ; } if ( node . content != null ) nestedEmphasis ( node . content ) ; node = next ; } }
va	2	public static void editSubject ( final Subject subject ) throws DatasetException { if ( subject == null ) { throw new IllegalArgumentException ( "Value of teacher parameter is null" ) ; } try { entityManager . getTransaction ( ) . begin ( ) ; entityManager . merge ( subject ) ; entityManager . getTransaction ( ) . commit ( ) ; LOGGER . debug ( String . format ( "Subject %s edited. " , subject ) ) ; } catch ( Exception e ) { LOGGER . error ( "Error editing subject: " , e ) ; throw new DatasetException ( "Error while editing a subject: " + e . getMessage ( ) ) ; } }
va	5	public List < RespondModel > loginUser ( @ WebParam ( name = "username" ) String username , @ WebParam ( name = "password" ) String password ) { RespondModel respondModel = new RespondModel ( ) ; List < RespondModel > infoList = new LinkedList < RespondModel > ( ) ; String loginMessages = AegirConstantsWebService . LOGINUSER_MESSAGES_SUCCESS ; String loginType = AegirConstantsWebService . LOGINUSER_TYPE_SUCCESS ; AuthenticationToken token = new UsernamePasswordToken ( username , password ) ; Subject currentUser = SecurityUtils . getSubject ( ) ; try { currentUser . login ( token ) ; } catch ( UnknownAccountException uae ) { logger . warn ( "\u6355\u83B7\u5F02\u5E38UnknownAccountException\uFF1A\u7528\u6237\u4E0D\u5B58\u5728   " + getClass ( ) ) ; loginType = AegirConstantsWebService . LOGINUSER_TYPE_ERROR ; loginMessages = AegirConstantsWebService . LOGINUSER_MESSAGES_NOUSER ; } catch ( IncorrectCredentialsException ice ) { logger . warn ( "\u6355\u83B7\u5F02\u5E38IncorrectCredentialsException\uFF1A\u5BC6\u7801\u4E0D\u6B63\u786E   " + getClass ( ) ) ; loginType = AegirConstantsWebService . LOGINUSER_TYPE_ERROR ; loginMessages = AegirConstantsWebService . LOGINUSER_MESSAGES_PASSWORDERROR ; } catch ( LockedAccountException lae ) { logger . warn ( "\u6355\u83B7\u5F02\u5E38LockedAccountException\uFF1A\u7528\u6237\u88AB\u9501\u5B9A   " + getClass ( ) ) ; loginType = AegirConstantsWebService . LOGINUSER_TYPE_ERROR ; loginMessages = AegirConstantsWebService . LOGINUSER_MESSAGES_NOUSER ; } catch ( AccountException aep ) { logger . warn ( "\u6355\u83B7\u5F02\u5E38AccountException\uFF1A\u7528\u6237\u540D\u4E0D\u80FD\u4E3A\u7A7A   " + getClass ( ) ) ; loginType = AegirConstantsWebService . LOGINUSER_TYPE_ERROR ; loginMessages = AegirConstantsWebService . LOGINUSER_MESSAGES_USERNOEMPYT ; } catch ( Exception e ) { logger . warn ( "\u5176\u5B83\u672A\u77E5\u9519\u8BEF   " + getClass ( ) ) ; loginType = AegirConstantsWebService . LOGINUSER_TYPE_ERROR ; loginMessages = e . getMessage ( ) . toString ( ) ; } respondModel . setRespondType ( loginType ) ; respondModel . setRespondMessage ( loginMessages ) ; infoList . add ( respondModel ) ; return infoList ; }
va	0	public static int randInt ( int min , int max ) { return ( rand . nextInt ( ( max - min ) + 1 ) + min ) ; }
va	7	public User addUser ( boolean newDB ) { String input = null ; if ( newDB ) { input = JOptionPane . showInputDialog ( new JFrame ( ) , "Could not find any User  please add a new one. Username: " , "Add User" , JOptionPane . PLAIN_MESSAGE ) ; if ( input == null ) System . exit ( 0 ) ; while ( input . equals ( "" ) ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "Cannot create LangDB without any user." , "Thats not how this works" , JOptionPane . ERROR_MESSAGE ) ; input = JOptionPane . showInputDialog ( new JFrame ( ) , "Username: " , "adding a new User" , JOptionPane . PLAIN_MESSAGE ) ; if ( input == null ) System . exit ( 0 ) ; } } else { input = JOptionPane . showInputDialog ( new JFrame ( ) , "Username: " , "Add User" , JOptionPane . PLAIN_MESSAGE ) ; if ( input == null ) return null ; while ( input . equals ( "" ) ) { input = JOptionPane . showInputDialog ( new JFrame ( ) , "Username: " , "Add User" , JOptionPane . PLAIN_MESSAGE ) ; if ( input == null ) return null ; } } return User . createNew ( con , input ) ; }
va	1	private static void testCase2 ( ) { Node tree1 = createTree3 ( ) ; Node tree2 = createTree4 ( ) ; int length1 = getHeight ( tree1 ) ; int length2 = getHeight ( tree2 ) ; if ( length1 < length2 ) { System . out . println ( contains ( tree2 , tree1 ) ) ; } else { System . out . println ( contains ( tree1 , tree2 ) ) ; } }
va	8	public boolean isBetween ( Coordinate A , Coordinate B ) { if ( A . row == B . row && A . row == this . row ) { if ( Math . min ( A . col , B . col ) <= this . col && this . col <= Math . max ( A . col , B . col ) ) return true ; } if ( A . col == B . col && A . col == this . col ) { if ( Math . min ( A . row , B . col ) <= this . row && this . row <= Math . max ( A . row , B . row ) ) return true ; } return false ; }
va	2	private void checkLoginInputPrams ( Context context , EditText mUsername , EditText mPassword ) { String username = mUsername . getText ( ) . toString ( ) ; if ( TextUtils . isEmpty ( username ) ) { Toast . makeText ( context , "\u8D26\u53F7\u5FC5\u987B\u586B\u5199" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } String password = mPassword . getText ( ) . toString ( ) ; if ( TextUtils . isEmpty ( password ) ) { Toast . makeText ( context , "\u5BC6\u7801\u5FC5\u987B\u586B\u5199" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } mProgress = showProgress ( context , "51\u6E38\u620F\u4E2D\u5FC3" , "\u767B\u5F55\u4E2D\u2026" , false , true ) ; doLoginAccount ( username , password ) ; }
va	2	public Runnable poll ( ActorID actorID ) { Runnable r = super . poll ( actorID ) ; if ( r == null && disposable ) { agent . unregister ( this ) ; } return r ; }
va	0	public int asInt ( ) { return level ; }
va	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(0|101|11(01)*(1|00)1|(100|11(01)*(1|00)0)(1|0(01)*(1|00)0)*0(01)*(1|00)1)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 25 ] ; int [ ] candidatesCount = new int [ 1 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 3 ; problemCount [ 1 ] = 6 ; problemCount [ 2 ] = 9 ; problemCount [ 3 ] = 12 ; problemCount [ 4 ] = 15 ; problemCount [ 5 ] = 18 ; problemCount [ 6 ] = 21 ; problemCount [ 7 ] = 24 ; problemCount [ 8 ] = 27 ; problemCount [ 9 ] = 30 ; problemCount [ 10 ] = 33 ; problemCount [ 11 ] = 36 ; problemCount [ 12 ] = 39 ; problemCount [ 13 ] = 42 ; problemCount [ 14 ] = 45 ; problemCount [ 15 ] = 48 ; problemCount [ 16 ] = 51 ; problemCount [ 17 ] = 54 ; problemCount [ 18 ] = 57 ; problemCount [ 19 ] = 60 ; problemCount [ 20 ] = 63 ; problemCount [ 21 ] = 66 ; problemCount [ 22 ] = 69 ; problemCount [ 23 ] = 72 ; problemCount [ 24 ] = 75 ; candidatesCount [ 0 ] = 100 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 2 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_PS_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n ] ; cc = candidatesCount [ 0 ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { GraphvizRenderer . renderGraph ( starter . getWinner ( ) . getObj ( ) , "winner.svg" ) ; solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
va	9	protected void serialize_set ( Set < ? > set , PrintWriter p , int level ) { if ( ! this . setliterals ) { serialize_tuple ( set , p , level ) ; return ; } if ( set . size ( ) > 0 ) { p . print ( "{" ) ; Collection < ? > output = set ; if ( this . indent ) { Set < ? > outputset = set ; try { outputset = new TreeSet < Object > ( set ) ; } catch ( ClassCastException x ) { } output = outputset ; } serialize_sequence_elements ( output , false , p , level + 1 ) ; if ( this . indent ) { for ( int i = 0 ; i < level ; ++ i ) p . print ( "  " ) ; } p . print ( "}" ) ; } else { serialize_tuple ( Collections . EMPTY_LIST , p , level + 1 ) ; } }
va	4	@ Override public boolean equivalent ( Type that ) { if ( ! ( that instanceof TypeList ) ) return false ; List < Type > olist = ( ( TypeList ) that ) . list ; if ( list . size ( ) != olist . size ( ) ) return false ; for ( int i = 0 ; i < list . size ( ) ; ++ i ) { if ( ! list . get ( i ) . equivalent ( olist . get ( i ) ) ) return false ; } return true ; }
va	1	@ Override public void fire ( HtmlDFA dfa , Transition transition , StringBuilder in ) throws Exception { String v = toAttributeValue ( in ) ; dfa . currentAttributes . put ( dfa . currentAttributeName , v ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( "Seen attribute named {} and valued {}" , new Object [ ] { dfa . currentAttributeName , v } ) ; } in . setLength ( 0 ) ; }
va	8	public boolean setParam ( String v ) { if ( v . equals ( "1" ) || v . equalsIgnoreCase ( "on" ) || v . equalsIgnoreCase ( "true" ) || v . equalsIgnoreCase ( "yes" ) ) value = true ; else if ( v . equals ( "0" ) || v . equalsIgnoreCase ( "off" ) || v . equalsIgnoreCase ( "false" ) || v . equalsIgnoreCase ( "no" ) ) value = false ; else return false ; return true ; }
va	5	public XbpadKeyPreset xgetCurrentPreset ( ) { if ( pointer == 1 ) { return container [ 0 ] ; } else if ( pointer == 2 ) { return container [ 1 ] ; } else if ( pointer == 3 ) { return container [ 2 ] ; } else if ( pointer == 4 ) { return container [ 3 ] ; } else if ( pointer == 5 ) { return container [ 4 ] ; } else { return container [ 0 ] ; } }
va	8	@ Override public void parse ( String input , List < KeyValueHandler > handlers ) { if ( empty ( input ) ) return ; String [ ] tokens = input . split ( delimiter ) ; for ( String token : tokens ) { String [ ] keyAndValue = token . split ( kvDelimiter ) ; switch ( keyAndValue . length ) { case 2 : if ( ! empty ( keyAndValue [ 0 ] ) ) { for ( KeyValueHandler handler : handlers ) handler . handle ( keyAndValue [ 0 ] , keyAndValue [ 1 ] ) ; } break ; case 1 : if ( ! empty ( keyAndValue [ 0 ] ) ) { for ( KeyValueHandler handler : handlers ) handler . handle ( keyAndValue [ 0 ] , "" ) ; } break ; default : break ; } } }
va	3	public boolean isQuiesced ( ) { if ( quiescing && completeQueue . size ( ) == 0 && messageQueue . size ( ) == 0 ) { return true ; } return false ; }
va	2	public boolean tieneBarcosNoDestruidos ( ) { for ( Nave nave : this . naves ) { if ( ! nave . estaDestruida ( ) ) return true ; } return false ; }
