te	0	public void setDiagId ( int diagId ) { this . diagId = diagId ; }
te	3	public Set < DadesHotel > getDisponibles ( Date dIni , Date dFi , Integer NumOcup ) throws Exception { Set < DadesHotel > res = null ; for ( Hotel h : hotels ) { DadesHotel result = new DadesHotel ( ) ; if ( h . estaDisp ( dIni , dFi , NumOcup , result ) ) { res . add ( result ) ; } } if ( res . isEmpty ( ) ) throw new Exception ( "hotelsNoDisp" ) ; return res ; }
te	1	public MergeSort ( int [ ] data ) { if ( data != null ) { this . arr = data ; } }
te	9	public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { Player player = null ; if ( sender instanceof Player ) { player = ( Player ) sender ; } if ( args . length == 0 ) { sender . sendMessage ( ChatColor . GOLD + " [ Experience Rewards ] " ) ; sender . sendMessage ( ChatColor . DARK_GREEN + "  /exp PlayerName # " + ChatColor . WHITE + "- Award a user # of exp points" ) ; sender . sendMessage ( ChatColor . DARK_GREEN + "  /levelup PlayerName # " + ChatColor . WHITE + "- Award a user # of exp levels" ) ; sender . sendMessage ( ChatColor . DARK_GREEN + "  /levelset PlayerName # " + ChatColor . WHITE + "- Set a users exp level" ) ; sender . sendMessage ( ChatColor . DARK_GREEN + "  /levelget PlayerName " + ChatColor . WHITE + "- View a users exp level" ) ; return true ; } else if ( args . length == 1 && Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; target . giveExp ( 10 ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " has been awarded 10xp " ) ; return true ; } else if ( args . length == 1 && Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + args [ 0 ] + ChatColor . WHITE + " is not online." ) ; return true ; } else if ( args . length == 2 && Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; int xp = Integer . parseInt ( args [ 1 ] ) ; target . giveExp ( xp ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " has been awarded " + ChatColor . DARK_GREEN + xp + "xp" ) ; if ( player == null ) { target . sendMessage ( ChatColor . WHITE + "You've been awarded " + ChatColor . DARK_GREEN + xp + "xp" + ChatColor . WHITE + " by " + ChatColor . DARK_GREEN + "Console" ) ; return true ; } else { target . sendMessage ( ChatColor . WHITE + "You've been awarded " + ChatColor . DARK_GREEN + xp + "xp" + ChatColor . WHITE + " by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } } else if ( args . length == 2 && Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + args [ 0 ] + ChatColor . WHITE + " is not online." ) ; return true ; } else if ( args . length > 2 ) { } return true ; }
te	0	public VarietyInformation . Inventory createVarietyInformationInventory ( ) { return new VarietyInformation . Inventory ( ) ; }
te	5	private static void onTreeSelected ( final int index ) { String id = userTrees . getTreeId ( index ) ; String assoId = userTrees . getTreeAssoId ( index ) ; if ( chooseParent ) { pearlContent ( currentTabId , currentUrl , currentTitle , null , id , NewTreeUI . newTreeTitle ) ; if ( ! WebContent . bookmarklet ) { Alerts . setButtonIcon ( false , true ) ; PopupControl . changeUI ( PopupUIs . TreeCreated ) ; } } else if ( goDirectly ) { if ( ! WebContent . onIpad ) { setSelectedTree ( id , assoId ) ; reveal ( id , assoId , currentTabId , currentUrl ) ; Alerts . closeWindow ( ) ; } else { isClosing = false ; setSelectedTree ( id , assoId ) ; TreeNode treeNode = trees . get ( index ) ; TreeListItem treeListItem = treeNode . getTreeListItem ( ) ; treeListItem . addStyleDependentName ( PopupElements . STYLE_SELECTED ) ; treeListItem . removeStyleDependentName ( PopupElements . STYLE_SELECTED_TIMER ) ; String hash = AppClient . buildRevealHash ( userTrees , id , assoId ) ; goBackToPT ( hash ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { Alerts . closeWindow ( ) ; } } ; t . schedule ( 1000 ) ; PopupControl . onViewCreated ( ) ; } } else { setSelectedTree ( id , assoId ) ; pearlContent ( currentTabId , currentUrl , currentTitle , id , null , null ) ; if ( ! WebContent . bookmarklet ) { Alerts . setButtonIcon ( false , true ) ; Alerts . closeWindow ( ) ; } } }
te	4	private BufferedImage getCurrentFrameBufferedImage ( ) { ImageStore imageStore = imageStoreProvider . getImageStore ( ) ; if ( imageStore != null ) { AnimationFrame frame = animationFrameSequenceInfoProvider . getSelectedAnimationFrame ( ) ; if ( frame != null ) { Image image = imageStore . getImage ( frame . getImage ( ) ) ; if ( image != null ) { if ( image instanceof BufferedImage ) { return ( BufferedImage ) image ; } } } } return null ; }
te	4	public void test ( ) { EvaluationManager evaluationManager = new EvaluationManager ( ) ; evaluationManager . setDataSet ( dataSet ) ; evaluationManager . setAlgorithm ( algorithm ) ; evaluationManager . setValidationMethod ( validationMethod ) ; evaluationManager . evaluate ( ) ; for ( EvaluationMetric metric : evaluationManager . getMetrics ( ) ) { if ( metric instanceof BasicsMetric ) { System . out . println ( "\nTPR" ) ; double [ ] tpr = ( ( BasicsMetric ) metric ) . getTpr ( ) ; for ( double s : tpr ) { System . out . printf ( "%.3f\n" , s ) ; } System . out . println ( "\nFPR" ) ; double [ ] fpr = ( ( BasicsMetric ) metric ) . getFpr ( ) ; for ( double s : fpr ) { System . out . printf ( "%.3f\n" , s ) ; } System . out . println ( "Accuracy: " + ( ( BasicsMetric ) metric ) . getPerformance ( ) * 100 ) ; } } }
te	7	private boolean formatCheck ( boolean isAudio ) { if ( isAudio == true ) { if ( sTimeT . getText ( ) . matches ( "[0-9]+" ) && tTimeT . getText ( ) . matches ( "[0-9]+" ) && outFileT . getText ( ) . endsWith ( ".mp3" ) ) { return true ; } else { return false ; } } else { if ( sTimeT . getText ( ) . matches ( "[0-9]+" ) && tTimeT . getText ( ) . matches ( "[0-9]+" ) && outFileT . getText ( ) . endsWith ( ".mp4" ) ) { return true ; } else { return false ; } } }
te	9	public void unmarshal ( Element metsHdr ) { super . unmarshal ( metsHdr ) ; DatatypeFactory dtf = MetsIO . getDataTypeFactory ( ) ; NamedNodeMap attrs = metsHdr . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; String name = attr . getName ( ) ; String value = attr . getNodeValue ( ) ; if ( name . equals ( "RECORDSTATUS" ) ) this . recordstatus = value ; if ( name . equals ( "CREATEDATE" ) ) this . createdate = dtf . newXMLGregorianCalendar ( value ) ; if ( name . equals ( "LASTMODDATE" ) ) this . lastmoddate = dtf . newXMLGregorianCalendar ( value ) ; if ( name . equals ( "ADMID" ) ) this . admid = MetsReader . parseIDREFAttr ( value ) ; } List < Element > children = DOMHelp . getChildElements ( metsHdr ) ; for ( Element child : children ) { String localName = child . getLocalName ( ) ; if ( localName . equals ( "agent" ) ) { Agent agent = new Agent ( ) ; agent . unmarshal ( child ) ; this . getAgent ( ) . add ( agent ) ; } if ( localName . equals ( "altRecordID" ) ) { RecordID aid = new RecordID ( ) ; aid . unmarshal ( child ) ; this . getAltRecordID ( ) . add ( aid ) ; } if ( localName . equals ( "metsDocumentID" ) ) { this . metsDocumentID = new RecordID ( ) ; this . metsDocumentID . unmarshal ( child ) ; } } }
te	0	@ Override public void get ( byte [ ] buffer ) { bt . copy ( struct , 0 , buffer , 0 , struct . length ) ; }
te	2	public JSONObject putOpt ( String key , Object value ) throws JSONException { if ( key != null && value != null ) { this . put ( key , value ) ; } return this ; }
te	0	public static void notNull ( Object object ) { notNull ( object , "[Assertion failed] - this argument is required; it must not be null" ) ; }
te	3	public static boolean isUnique ( String str ) { char [ ] arr = new char [ 256 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arr [ i ] = str . charAt ( i ) ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ j ] == str . charAt ( i ) ) return false ; } return true ; }
te	7	public static void AdjustSaturation ( BufferedWrapper bw , int adjustQuantity ) { Color newColor ; float [ ] hsbvals = new float [ 3 ] ; float saturation ; BufferedImage bi2 = new BufferedImage ( bw . img . getWidth ( ) , bw . img . getHeight ( ) , bw . img . getType ( ) ) ; for ( int x = 0 ; x < bw . img . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bw . img . getHeight ( ) ; y ++ ) { if ( bw . img . getRGB ( x , y ) == 0 ) continue ; newColor = new Color ( bw . img . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; saturation = adjustQuantity * .001f ; if ( saturation < - .9f ) { saturation = ( - .9f ) ; } if ( saturation > 1f ) { saturation = 1f ; } bi2 . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , ( hsbvals [ 1 ] + saturation < 0 ) ? 0 : ( hsbvals [ 1 ] + ( saturation ) > 1.0f ) ? 1.0f : hsbvals [ 1 ] + saturation , hsbvals [ 2 ] ) ) ; } } bw . img = bi2 ; }
te	3	public static Image getImage ( class < ? > clazz , String path ) { String key = clazz . getName ( ) + | + path ; Image image = m_imageMap . get ( key ) ; if ( image == null ) { try { image = getImage ( clazz . getResourceAsStream ( path ) ) ; m_imageMap . put ( key , image ) ; } catch ( Exception e ) { image = getMissingImage ( ) ; m_imageMap . put ( key , image ) ; } } return image ; }
te	5	@ Override public TableProvider create ( String dir ) throws IOException { if ( dir == null || dir . trim ( ) . equals ( "" ) ) { throw new IllegalArgumentException ( "Dir cannot be null" ) ; } File tableDirFile = new File ( dir ) ; if ( ! tableDirFile . exists ( ) ) { if ( ! tableDirFile . mkdirs ( ) ) { throw new IOException ( "Cannot create directory! " + tableDirFile . getCanonicalPath ( ) ) ; } } if ( ! tableDirFile . isDirectory ( ) ) { throw new IllegalArgumentException ( "Wrong dir " + dir ) ; } return new DataBaseTable ( dir ) ; }
te	4	public PostingsList removeList ( PostingsList toRemove ) { int [ ] toRemoveIds = new int [ toRemove . size ( ) ] ; toRemoveIds = toRemove . getIDs ( ) ; PostingsList result = new PostingsList ( ) ; Node current = head ; while ( current != null ) { boolean addToList = true ; for ( int i = 0 ; i < toRemoveIds . length ; i ++ ) { if ( toRemoveIds [ i ] == current . docID ( ) ) { addToList = false ; } } if ( addToList ) { result . addNode ( current ) ; } current = current . next ( ) ; } return result ; }
te	6	@ Override public void update ( ) { if ( onShootPrimary ) { if ( reloadingTimerPrimary < 0 ) { Ammo ammo ; for ( int i = 0 ; i < countAmmoPrimaryPerShoot ; i ++ ) { ammo = Ammo . getAmmo ( new Vector2f ( 0 , 0 ) , new Vector2f ( 0 , 0 ) , level , nameAmmoPrimary ) ; float shell_speed = ( float ) Math . sqrt ( 2 * kineticEnergyPrimary / ammo . getPhysicObject ( ) . getMass ( ) ) ; Vector2f shell_speed_vector = new Vector2f ( ( float ) ( Math . cos ( angle + randomizeFirePrimary * Math . random ( ) - randomizeFirePrimary / 2f ) * shell_speed ) , ( float ) Math . sin ( angle + randomizeFirePrimary * Math . random ( ) - randomizeFirePrimary / 2f ) * shell_speed ) ; Vector2f shell_position = new Vector2f ( position . x + MathUtil . newXTurn ( width + LENGTH_BETWEEN_SPAWN_AREA_AMMO_AND_WEAPON + ammo . getRadius ( ) , 0 , angle ) , position . y + MathUtil . newYTurn ( width + LENGTH_BETWEEN_SPAWN_AREA_AMMO_AND_WEAPON + ammo . getRadius ( ) , 0 , angle ) ) ; ammo . getPhysicObject ( ) . setSpeed ( shell_speed_vector ) ; ammo . getPhysicObject ( ) . setPosition ( shell_position ) ; ammo . getPhysicObject ( ) . setAngle ( angle ) ; level . getNotAddedGameObjects ( ) . add ( ammo ) ; } reloadingTimerPrimary = reloadTimePrimary ; } } if ( onShootAlternative ) { if ( reloadingTimerAlternative < 0 ) { Vector2f shell_position = new Vector2f ( position . x + MathUtil . newXTurn ( width + LENGTH_BETWEEN_SPAWN_AREA_AMMO_AND_WEAPON , 0 , angle ) , position . y + MathUtil . newYTurn ( width + LENGTH_BETWEEN_SPAWN_AREA_AMMO_AND_WEAPON , 0 , angle ) ) ; Ammo ammo ; for ( int i = 0 ; i < countAmmoAlternativePerShoot ; i ++ ) { ammo = Ammo . getAmmo ( shell_position , new Vector2f ( 0 , 0 ) , level , nameAmmoAlternative ) ; float shell_speed = ( float ) Math . sqrt ( 2 * kineticEnergyPrimary / ammo . getPhysicObject ( ) . getMass ( ) ) ; Vector2f shell_speed_vector = new Vector2f ( ( float ) ( Math . cos ( angle + randomizeFireAlternative * Math . random ( ) - randomizeFireAlternative / 2f ) * shell_speed ) , ( float ) Math . sin ( angle + randomizeFireAlternative * Math . random ( ) - randomizeFireAlternative / 2f ) * shell_speed ) ; ammo . getPhysicObject ( ) . setSpeed ( shell_speed_vector ) ; ammo . getPhysicObject ( ) . setAngle ( angle ) ; level . getNotAddedGameObjects ( ) . add ( ammo ) ; } reloadingTimerAlternative = reloadTimeAlternative ; } } onShootAlternative = false ; onShootPrimary = false ; reloadingTimerAlternative -- ; reloadingTimerPrimary -- ; }
te	3	private void btnExcluirActionPerformed ( java . awt . event . ActionEvent evt ) { if ( existeOrdemServicoSelecionada ( ) && super . exclusaoConfirmada ( ) ) { try { excluir ( ) ; } catch ( ValidacaoException ex ) { JOptionPane . showMessageDialog ( this , ex . getMessage ( ) , "Erro" , JOptionPane . ERROR_MESSAGE ) ; } } }
te	9	void parseList ( ) { if ( car instanceof Ident ) { Ident id = ( Ident ) car ; String idName = id . getName ( ) ; if ( idName . equals ( "quote" ) || idName . equals ( "'" ) ) { form = new Quote ( ( Cons ) cdr ) ; } else if ( idName . equals ( "lambda" ) ) { form = new Lambda ( ) ; } else if ( idName . equals ( "begin" ) ) { form = new Begin ( ) ; } else if ( idName . equals ( "if" ) ) { form = new if ( ) ; } else if ( idName . equals ( "let" ) ) { form = new Let ( ) ; } else if ( idName . equals ( "cond" ) ) { form = new Cond ( ) ; } else if ( idName . equals ( "define" ) ) { form = new Define ( ) ; } else if ( idName . equals ( "set!" ) ) { form = new Set ( this ) ; } else { form = new Regular ( this ) ; } } else if ( car instanceof IntLit ) { form = new Regular ( this ) ; } else if ( car instanceof StrLit ) { form = new Regular ( this ) ; } else if ( car instanceof BooleanLit ) { form = new Regular ( this ) ; } else if ( car instanceof Nil ) { form = new Regular ( this ) ; } else { form = new Regular ( this ) ; } }
te	4	public static void save ( Highscore [ ] highscores , OutputStream out ) throws IOException { PrintStream outp = new PrintStream ( out ) ; for ( int i = 0 ; i < highscores . length ; i ++ ) { outp . print ( highscores [ i ] . score ) ; outp . print ( 	 ) ; if ( highscores [ i ] . name . equals ( "" ) ) { outp . print ( "`" ) ; } else { outp . print ( highscores [ i ] . name ) ; } if ( highscores [ i ] . fields != null ) { for ( int j = 0 ; j < highscores [ i ] . fields . length ; j ++ ) { outp . print ( 	 ) ; outp . print ( highscores [ i ] . fields [ j ] ) ; } } outp . println ( ) ; } outp . flush ( ) ; }
te	6	public static void deleteDirectory ( File dir ) { if ( ! dir . exists ( ) ) return ; File [ ] subs = dir . listFiles ( ) ; if ( subs != null ) { for ( File f : dir . listFiles ( ) ) { if ( f . isFile ( ) ) { if ( ! f . delete ( ) ) { throw new IllegalStateException ( "delete file failed: " + f ) ; } } else { deleteDirectory ( f ) ; } } } if ( ! dir . delete ( ) ) { throw new IllegalStateException ( "delete directory failed: " + dir ) ; } }
te	7	private void checkLaserCollisionsWithSprites ( Laser laser ) { LinkedList < Sprite > oldSprites = map . getSprites ( ) ; LinkedList < Sprite > sprites = ( LinkedList < Sprite > ) oldSprites . clone ( ) ; for ( int i = 0 ; i < map . getAIShips ( ) . size ( ) ; i ++ ) { sprites . add ( map . getAIShips ( ) . get ( i ) ) ; } for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; if ( sprite instanceof Planet ) { Planet planet = ( Planet ) sprite ; if ( isCollision ( laser , planet ) ) collideLaserWithSprite ( laser , planet ) ; } else if ( sprite instanceof Ship ) { Ship ship = ( Ship ) sprite ; if ( isCollision ( laser , ship ) ) collideLaserWithSprite ( laser , ship ) ; } else if ( sprite instanceof Turret ) { Turret t = ( Turret ) sprite ; } } }
te	0	public Aaa getPrivateMethod ( ) { return privateMethod ; }
te	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof DecafParserListener ) ( ( DecafParserListener ) listener ) . enterMethod_decl ( this ) ; }
te	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } TransientProperty < ? > other = ( TransientProperty < ? > ) obj ; if ( object == null ) { if ( other . object != null ) { return false ; } } else if ( ! object . equals ( other . object ) ) { return false ; } return true ; }
te	0	@ JsonProperty ( "Associations" ) public ExecutionEnvironmentAssociations getAssociations ( ) { return Associations ; }
te	7	private void evalDefState ( ) { try { ArrayList < String > vars = new ArrayList < String > ( ) ; String type = ( String ) input1Box . getSelectedItem ( ) ; if ( type . equals ( "Single" ) ) { vars . add ( input3Box . getText ( ) . trim ( ) ) ; } else if ( type . equals ( "Multiple" ) ) { StringTokenizer tok = new StringTokenizer ( input3Box . getText ( ) . trim ( ) , " " , false ) ; while ( tok . hasMoreTokens ( ) ) { vars . add ( tok . nextToken ( ) ) ; } if ( vars . size ( ) < 2 ) { displayOutput ( "Invalid variable list " + input3Box . getText ( ) + "\n" ) ; return ; } } String name = input2Box . getText ( ) . trim ( ) ; if ( name . length ( ) == 0 || FunctionStore . getStore ( ) . hasFunction ( name ) ) { displayOutput ( "Invalid Function name." ) ; return ; } FunctionStore . getStore ( ) . storeFunction ( name , TokenizedFunctionFactory . createFunction ( expressionBox . getText ( ) , vars ) ) ; displayOutput ( "Function " + name + " stored with definition " + expressionBox . getText ( ) + "\n" ) ; } catch ( MalformedFunctionException e ) { displayOutput ( "Malformed expression: " + e . getMessage ( ) + "\n" ) ; } }
te	8	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnSearch ) { String spec = ( String ) boxSpecialty . getSelectedItem ( ) ; int count = table . getRowCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { model . removeRow ( 0 ) ; } model . fireTableRowsDeleted ( 0 , count ) ; ArrayList < Doctor > docList = parent . getHandler ( ) . getDoctorsBig ( ) ; int docNum = docList . size ( ) ; for ( Doctor d : docList ) { if ( d . getSpeciality ( ) . equals ( spec ) ) { ArrayList < Availability > availList = parent . getHandler ( ) . getDoctorAvailability ( d . getUsername ( ) ) ; for ( Availability a : availList ) { Object [ ] nextRow = { d . getfName ( ) + " " + d . getlName ( ) , d . getWorkphone ( ) , d . getRoomNo ( ) , a . getDay ( ) + " : " + a . getFrom ( ) + " - " + a . getTo ( ) , parent . getHandler ( ) . getDoctorRating ( d . getUsername ( ) ) } ; model . addRow ( nextRow ) ; } } } } else if ( e . getSource ( ) == btnRequestAppointment ) { String docName = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 0 ) ; Scanner scan = new Scanner ( docName ) ; String fName = scan . next ( ) ; String lName = scan . next ( ) ; String docUsername = parent . getHandler ( ) . getDoctorUsername ( fName , lName ) ; if ( parent . getHandler ( ) . getAppointmentsByPair ( docUsername , username ) . size ( ) == 0 ) { scan = new Scanner ( ( String ) table . getValueAt ( table . getSelectedRow ( ) , 3 ) ) ; scan . next ( ) ; scan . next ( ) ; String startTime = scan . next ( ) ; parent . getHandler ( ) . addNewAppointments ( docUsername , username , "2014-04-30" , startTime ) ; } else { } } else if ( e . getSource ( ) == btnBack ) { CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; parent . getContentPane ( ) . remove ( parent . getContentPane ( ) . getComponents ( ) . length - 1 ) ; cl . last ( parent . getContentPane ( ) ) ; } }
te	8	public boolean matches ( String value , String pattern ) { if ( pattern . length ( ) == 0 ) return pattern . length ( ) == 0 ; char mainChar = pattern . charAt ( 0 ) ; char altChar = mainChar == a ? b : a ; int size = value . length ( ) ; int countOfMain = countOf ( pattern , mainChar ) ; int countOfAlt = pattern . length ( ) - countOfMain ; int firstAlt = pattern . indexOf ( altChar ) ; int maxMainSize = size / countOfMain ; for ( int mainSize = 1 ; mainSize <= maxMainSize ; mainSize ++ ) { int remainingLength = size - mainSize * countOfMain ; String first = value . substring ( 0 , mainSize ) ; if ( countOfAlt == 0 || remainingLength % countOfAlt == 0 ) { int altIndex = firstAlt * mainSize ; int altSize = countOfAlt == 0 ? 0 : remainingLength / countOfAlt ; String second = countOfAlt == 0 ? "" : value . substring ( altIndex , altSize + altIndex ) ; String cand = buildFromPattern ( pattern , first , second ) ; if ( cand . equals ( value ) ) { System . out . printf ( "a was %s  b was %s\n" , first , second ) ; return true ; } } } return false ; }
te	2	public static double desviacion ( double [ ] vals ) { double mean = 0.0 ; for ( int i = 0 ; i < vals . length ; i ++ ) { mean += vals [ i ] ; } mean = mean / ( double ) vals . length ; double desv = 0.0 ; for ( int i = 0 ; i < vals . length ; i ++ ) { desv += Math . abs ( vals [ i ] - mean ) ; } desv = desv / ( double ) vals . length ; return desv ; }
te	5	public int countObjects ( String prefix , int cidmask , boolean suspended_obj ) { int nr_obj = 0 ; int firstidx = getFirstObjectIndex ( prefix ) ; int lastidx = getLastObjectIndex ( prefix ) ; for ( int i = firstidx ; i < lastidx ; i ++ ) { JGObject obj = ( JGObject ) objects . values [ i ] ; if ( cidmask == 0 || ( obj . colid & cidmask ) != 0 ) { if ( suspended_obj || ! obj . is_suspended ) { nr_obj ++ ; } } } return nr_obj ; }
te	6	public void fillPathAndMax ( int [ ] path , int [ ] tmax ) { for ( int i = 0 ; i < path . length ; i ++ ) { path [ i ] = - 1 ; tmax [ i ] = - 1 ; } for ( int idx = 0 ; idx <= pos ; idx ++ ) { int mdd = indices [ idx ] ; int value = values [ idx ] ; int child = ddmanager . getChild ( mdd , value ) ; MDDVariable var = ddmanager . getNodeVariable ( mdd ) ; int max = value ; int absolutemax = var . nbval - 1 ; while ( max < absolutemax ) { int nextvalue = max + 1 ; if ( ddmanager . getChild ( mdd , nextvalue ) != child ) { break ; } max = nextvalue ; } if ( max > value && max >= absolutemax ) { max = - 1 ; } int i = ddmanager . getVariableIndex ( var ) ; path [ i ] = values [ idx ] ; tmax [ i ] = max ; } }
te	6	public CE_Frame ( String choose ) { this . choose = choose ; try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CE_Frame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CE_Frame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CE_Frame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CE_Frame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } initComponents ( ) ; }
te	7	public static void back_propagate ( MMNode node ) { while ( node . getChildren ( ) . size ( ) != 0 ) { node = node . getChildren ( ) . get ( 0 ) ; } node = node . getParent ( ) ; while ( node != null ) { if ( node . getColor ( ) . equals ( MiniMax . color ) ) { double maxTmpQty = 0 ; for ( MMNode child : node . getChildren ( ) ) { if ( child . getQuality ( ) > maxTmpQty ) { maxTmpQty = child . getQuality ( ) ; } } node . quality = maxTmpQty ; } else { double minTmpQty = 1 ; for ( MMNode child : node . getChildren ( ) ) { if ( child . getQuality ( ) > minTmpQty ) { minTmpQty = child . getQuality ( ) ; } } node . quality = minTmpQty ; } node = node . getParent ( ) ; } }
te	6	public static String characterImpl ( Integer ... codes ) { if ( codes == null ) { return null ; } if ( codes . length == 1 && codes [ 0 ] == null ) { return null ; } final String [ ] chars = new String [ codes . length ] ; for ( int i = 0 ; i < codes . length ; i ++ ) { if ( codes [ i ] != null && codes [ i ] >= 0 ) { chars [ i ] = String . valueOf ( Character . toChars ( codes [ i ] ) [ 0 ] ) ; } } return generateString ( chars , null , true ) ; }
te	8	public boolean isColumnConvertible ( int col , DataTypes type ) { if ( ! isColumnIndex ( col ) ) throw new ArrayIndexOutOfBoundsException ( "col=" + col + " is not a valid column index in " + table_name ) ; if ( type == getColumnType ( col ) ) return false ; switch ( type ) { case NUMERIC : try { for ( int i = 0 ; i < table_rows ; i ++ ) if ( ! columns . get ( col ) . get ( i ) . isEmpty ( ) ) double . parseDouble ( columns . get ( col ) . get ( i ) . toString ( ) ) ; } catch ( NumberFormatException e ) { return false ; } break ; case CHARACTER : break ; case UNDEFINED : default : return false ; } return true ; }
te	0	public String getName ( ) { return name ; }
te	4	public String ElectionSetTurnHolder ( int newTurnHolder ) { synchronized ( peer ) { assert peer . isReady ( ) ; if ( peer . getTurnHolder ( ) . getOrd ( ) != newTurnHolder ) { System . out . println ( "Stavo ancora aspettando un word ack  ma \u00E8 cambiato il turno. Faccio come se l'avessi ricevuto  cancello lastWordTask." ) ; if ( peer . lastWordTask != null ) { peer . lastWordTask . cancel ( ) ; peer . lastWordTask = null ; } } System . out . println ( String . format ( "Ricevuto SetTurnHolder. Setto %d come turnHolder." , newTurnHolder ) ) ; gameTable . setTurnHolder ( peer . peers . get ( newTurnHolder ) . player ) ; if ( peer . firstPhaseElectionTask != null ) { peer . firstPhaseElectionTask . cancel ( ) ; peer . firstPhaseElectionTask = null ; } if ( peer . secondPhaseElectionTask != null ) { peer . secondPhaseElectionTask . cancel ( ) ; peer . secondPhaseElectionTask = null ; } peer . electionActive = false ; peer . rescheduleTurnHolderTimer ( ) ; } return "ok" ; }
te	1	private static String [ ] getImageFormatExtensions ( ) { String [ ] names = ImageIO . getReaderFormatNames ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = names [ i ] . toLowerCase ( ) ; } Arrays . sort ( names ) ; return names ; }
te	9	public static Object [ ] [ ] topScores ( String fileName , int scores ) throws IOException { sortScores ( fileName ) ; Scanner scan ; String [ ] usernames ; long [ ] wins , losses ; int fileLength = 0 , win = - 1 , lose = - 1 ; try { scan = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( "File not found: " + fileName ) ; FileWriter writeToFile = new FileWriter ( fileName ) ; writeToFile . write ( "//BEGIN\r\n" + "//END" ) ; writeToFile . close ( ) ; scan = new Scanner ( new File ( fileName ) ) ; } Object fileContents [ ] [ ] , fileLine = scan . nextLine ( ) ; while ( ! fileLine . equals ( "//END" ) ) { fileLine = scan . nextLine ( ) ; if ( ! fileLine . equals ( "//END" ) ) fileLength ++ ; } if ( fileLength == 0 ) return new String [ ] [ ] { { "There are no scores in the scoreboard!" , "Save yours and get 1st place ;3" , null } } ; usernames = new String [ fileLength ] ; wins = new long [ fileLength ] ; losses = new long [ fileLength ] ; scan = new Scanner ( new File ( fileName ) ) ; scan . next ( ) ; int i ; for ( i = 0 ; i < fileLength ; i ++ ) { try { usernames [ i ] = scan . next ( ) ; wins [ i ] = scan . nextLong ( ) ; losses [ i ] = scan . nextLong ( ) ; } catch ( InputMismatchException ex ) { System . err . println ( wins [ i ] + " " + losses [ i ] ) ; changeScore ( fileName , usernames [ i ] , ( wins [ i ] != 0 ? wins [ i ] : 0 ) , ( losses [ i ] != 0 ? losses [ i ] : 0 ) ) ; } } fileContents = new Object [ scores ] [ 3 ] ; for ( i = 0 ; i < fileLength && i < scores ; i ++ ) { fileContents [ i ] [ 0 ] = usernames [ i ] ; fileContents [ i ] [ 1 ] = wins [ i ] ; fileContents [ i ] [ 2 ] = losses [ i ] ; } return ( fileContents ) ; }
te	7	@ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( object == null || getClass ( ) != object . getClass ( ) ) return false ; ActionState that = ( ActionState ) object ; if ( action != null ? ! action . equals ( that . action ) : that . action != null ) return false ; if ( state != null ? ! state . equals ( that . state ) : that . state != null ) return false ; return true ; }
te	5	public static int diasMes ( int mes ) { int result ; switch ( mes ) { case 2 : result = 28 ; break ; case 4 : case 6 : case 9 : case 11 : result = 30 ; break ; default : result = 31 ; break ; } return result ; }
te	1	public Danhhieu merge ( Danhhieu detachedInstance ) { log . debug ( "merging Danhhieu instance" ) ; try { Danhhieu result = ( Danhhieu ) sessionFactory . getCurrentSession ( ) . merge ( detachedInstance ) ; log . debug ( "merge successful" ) ; return result ; } catch ( RuntimeException re ) { log . error ( "merge failed" , re ) ; throw re ; } }
te	9	@ Override public void show ( ) { if ( skin == null ) { skin = new Skin ( ) ; for ( int i = 0 ; i < 3 * 2 ; i ++ ) { skin . add ( "levelGroup" + i , getTextureAtlas ( ) . createSprite ( "levelGroup" + i ) ) ; } } if ( imageButtonStyle == null ) { imageButtonStyle = new Array < ImageButtonStyle > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { imageButtonStyle . add ( new ImageButtonStyle ( ) ) ; } for ( int i = 0 ; i < 3 ; i ++ ) { switch ( i ) { case 0 : imageButtonStyle . get ( i ) . imageUp = skin . newDrawable ( "levelGroup" + i ) ; imageButtonStyle . get ( i ) . imageDown = skin . newDrawable ( "levelGroup" + i + 1 ) ; break ; case 1 : imageButtonStyle . get ( i ) . imageUp = skin . newDrawable ( "levelGroup" + i + 1 ) ; imageButtonStyle . get ( i ) . imageDown = skin . newDrawable ( "levelGroup" + i + 2 ) ; break ; case 2 : imageButtonStyle . get ( i ) . imageUp = skin . newDrawable ( "levelGroup" + i + 2 ) ; imageButtonStyle . get ( i ) . imageDown = skin . newDrawable ( "levelGroup" + i + 3 ) ; break ; default : break ; } } } if ( imageButtons == null ) { imageButtons = new Array < ImageButton > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { imageButtons . add ( new ImageButton ( imageButtonStyle . get ( i ) ) ) ; imageButtons . get ( i ) . addListener ( new MainMenuButtonListener ( i , levelScreens . get ( i ) , game ) ) ; } } if ( unlocked == null ) { unlocked = new Array < boolean > ( ) ; } }
te	3	@ Override public void onEvent ( final BenchmarkEvent event , final long sequence , final boolean endOfBatch ) throws Exception { this . mergeQueue . put ( this . mergeStrategy . getMergeKey ( event ) , event . payload ) ; if ( endOfBatch ) { for ( final Payload payload : this . mergeQueue . values ( ) ) { this . task . execute ( System . nanoTime ( ) , payload ) ; } this . mergeQueue . clear ( ) ; if ( event . payload . lastEvent ) { notifyConsumedLastEvent ( ) ; } } }
te	6	public static boolean isSubTree ( Node t1 , Node t2 ) { if ( t2 == null && t1 == null ) { return true ; } if ( t2 == null || t1 == null ) { return false ; } if ( t2 . value != t1 . value ) { return false ; } return isSubTree ( t1 . left , t2 . left ) || isSubTree ( t1 . right , t2 . right ) ; }
te	4	public static void main ( String args [ ] ) { try { javax . swing . UIManager . setLookAndFeel ( javax . swing . UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } }
te	1	public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . out . println ( "Please supply filename of config to edit." ) ; } AppConfig appconf = new AppConfig ( args [ 0 ] , args [ 0 ] ) ; appconf . loadFromFile ( ) ; appconf . openGui ( ) ; appconf . waitUntilGuiClosed ( ) ; System . exit ( 0 ) ; }
te	5	public void setCustomColor ( Color color , byte part ) { switch ( part ) { case BORDER : custBord = color ; break ; case BOX : custBox = color ; break ; case BACK : custBack = color ; break ; case TEXT : custText = color ; break ; case TEXT_AREA : custTextArea = color ; break ; default : throw new IllegalArgumentException ( "I don't know the part number " + part ) ; } }
te	5	public static int compara ( InetAddress ip1 , InetAddress ip2 ) { byte [ ] a1 = ip1 . getAddress ( ) ; byte [ ] a2 = ip2 . getAddress ( ) ; if ( a1 . length != a2 . length ) return a1 . length > a2 . length ? 1 : - 1 ; for ( int i = 0 ; i < a1 . length ; i ++ ) if ( a1 [ i ] != a2 [ i ] ) return ( ( a1 [ i ] & 00ff ) > ( a2 [ i ] & 00ff ) ) ? 1 : - 1 ; return 0 ; }
te	8	private static int calcular_determinante ( int [ ] [ ] llave ) { if ( llave . length == 1 ) { return llave [ 0 ] [ 0 ] ; } else if ( llave . length == 2 ) { return ( llave [ 0 ] [ 0 ] * llave [ 1 ] [ 1 ] ) - ( llave [ 0 ] [ 1 ] * llave [ 1 ] [ 0 ] ) ; } else { int [ ] pos = new int [ llave . length ] ; int [ ] neg = new int [ llave . length ] ; for ( int i = 0 ; i < llave . length ; i ++ ) { pos [ i ] = 1 ; neg [ i ] = 1 ; } for ( int r = 0 ; r < llave . length ; r ++ ) { for ( int c = 0 ; c < llave [ r ] . length ; c ++ ) { int ppos = c - r + llave . length ; int npos = c + r - llave . length ; if ( ppos >= llave . length ) { ppos -= llave . length ; } if ( npos < 0 ) { npos += llave . length ; } pos [ ppos ] *= llave [ r ] [ c ] ; neg [ npos ] *= llave [ r ] [ c ] ; } } int spos = 0 , sneg = 0 ; for ( int i = 0 ; i < llave . length ; i ++ ) { spos += pos [ i ] ; sneg += neg [ i ] ; } return spos - sneg ; } }
te	9	public String toString ( ) { String s ; switch ( object ) { case KEY : s = "KEY" ; break ; case CUBE : s = "C" + level ; break ; case RESO : s = "R" + level ; break ; case XMP : s = "X" + level ; break ; case SHIELD : s = rareString ( "S" , "H" ) ; break ; case FORCE_AMP : s = rareString ( "F" , "A" ) ; break ; case HEAT_SINK : s = rareString ( "H" , "S" ) ; break ; case LINK_AMP : s = rareString ( "L" , "A" ) ; break ; case MULTI_HACK : s = rareString ( "M" , "H" ) ; break ; case TURRET : s = rareString ( "T" , "U" ) ; break ; default : s = object ; if ( level > 0 ) s += level ; } if ( quantity > 1 ) s += "x" + quantity ; return s ; }
te	4	public static void uniformCrossoverForPeriodAssignment ( Individual child , Individual parent1 , Individual parent2 , ProblemInstance problemInstance ) { int coin ; for ( int client = 0 ; client < problemInstance . customerCount ; client ++ ) { coin = Utility . randomIntInclusive ( 1 ) ; if ( coin == 0 ) { child . visitCombination [ client ] = parent1 . visitCombination [ client ] ; } else { child . visitCombination [ client ] = parent2 . visitCombination [ client ] ; } for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { if ( coin == 0 ) { child . periodAssignment [ period ] [ client ] = parent1 . periodAssignment [ period ] [ client ] ; } else { child . periodAssignment [ period ] [ client ] = parent2 . periodAssignment [ period ] [ client ] ; } } } }
te	9	public void handleCommand ( Message message ) { if ( ! conn . isConnected ( ) ) return ; String body = message . getBody ( ) ; if ( body . startsWith ( prefix ) ) { body = body . substring ( prefix . length ( ) ) ; } else { body = body . substring ( conn . getNick ( ) . length ( ) ) ; if ( body . matches ( "[:>]? .*" ) ) { body = body . substring ( 1 ) . trim ( ) ; } else { return ; } } String [ ] command = body . split ( " +" ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Handling command: " + Arrays . toString ( command ) ) ; } String from = message . getFrom ( ) ; int priv = getPrivLevel ( from ) ; switch ( command [ 0 ] ) { case "commands" : printCommands ( ) ; break ; case "help" : printHelp ( command [ 1 ] ) ; break ; default : CommandWrapper cw = plugins . getCommand ( command [ 0 ] ) ; if ( cw == null ) return ; Command c = ( Command ) cw . getPlugin ( ) ; if ( c . getPrivLevel ( ) <= priv ) { c . handleCommand ( new CommandMessageImpl ( message , this , body . substring ( command [ 0 ] . length ( ) ) ) ) ; } else if ( logger . isInfoEnabled ( ) ) { logger . info ( "User " + from + " (priv " + priv + ") tried to do '" + message . getBody ( ) + "' (priv " + c . getPrivLevel ( ) + ")" ) ; } break ; } }
te	1	private GPSFunctionalityVerfiedActivity getVerifyGPSActvity ( ) { if ( gpsFunctionalityVerfiedActiviy == null ) { gpsFunctionalityVerfiedActiviy = new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } return gpsFunctionalityVerfiedActiviy ; }
te	1	public void mouseMoved ( MouseEvent mouseEvent ) { if ( paintType == null ) return ; paintType . mouseMoved ( mouseEvent ) ; }
te	4	public String toString ( ) { switch ( type ) { case PARAMETER : return "parameter: " + content ; case SPACE : return "space" ; case CALL_NAME : return "call: " + content ; case : : return "colon" ; default : return "confnode: " + content ; } }
te	4	public static < P extends Player , Plugin extends PlayerPlugin < P >> List < P > showDialog ( Component component , List < Plugin > plugins ) { List < P > enabledPlayers = new ArrayList < > ( ) ; Map < String , List < P >> map = new HashMap < > ( ) ; for ( Plugin plugin : plugins ) { List < P > players = plugin . getPlayers ( ) ; List < P > list = map . get ( plugin . getName ( ) ) ; if ( list == null ) { list = new ArrayList < P > ( ) ; map . put ( plugin . getName ( ) , list ) ; } list . addAll ( players ) ; } JPanel allPluginsPanel = new JPanel ( ) ; allPluginsPanel . setLayout ( new BoxLayout ( allPluginsPanel , BoxLayout . Y_AXIS ) ) ; for ( String pluginName : map . keySet ( ) ) { PluginSelectionPanel panel = new PluginSelectionPanel ( ) ; panel . setPlugins ( pluginName , map . get ( pluginName ) , enabledPlayers ) ; allPluginsPanel . add ( panel ) ; } int option = JOptionPane . showConfirmDialog ( component , allPluginsPanel , "select players" , OK_CANCEL_OPTION , PLAIN_MESSAGE ) ; if ( option == OK_OPTION ) { return enabledPlayers ; } else { return null ; } }
te	6	@ Override public void startTask ( RXTXPort port ) throws TooManyListenersException { dialog . setVisible ( true ) ; super . startTask ( port ) ; port . enableReceiveTimeout ( 300 ) ; port . enableReceiveThreshold ( 3 ) ; OutputStream out = port . getOutputStream ( ) ; InputStream in = port . getInputStream ( ) ; try { int retries = 5 ; boolean statusOK = false ; while ( ( ! statusOK ) && retries > 0 ) { logger . log ( "\u0418\u0437\u043F\u0440\u0430\u0449\u0430\u043D\u0435 \u043D\u0430 Ping \u043A\u043E\u043C\u0430\u043D\u0434\u0430" , LogLevel . DEBUG ) ; out . write ( ProtocolConstants . MARK_DEBUG ) ; out . write ( ProtocolConstants . CMD_DEBUG_PING . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; int read = in . read ( buf ) ; String received = new String ( buf ) ; if ( read <= 0 ) logger . log ( "\u041D\u044F\u043C\u0430 \u043E\u0442\u0433\u043E\u0432\u043E\u0440 \u0441\u043B\u0435\u0434 300 ms. \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D \u043E\u043F\u0438\u0442" , LogLevel . DEBUG ) ; else if ( received . equalsIgnoreCase ( ProtocolConstants . CMD_DEBUG_PONG ) ) { logger . log ( "\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043E\u0442\u0433\u043E\u0432\u043E\u0440 Pong. \u041A\u0440\u0430\u0439 \u043D\u0430 \u0437\u0430\u0434\u0430\u0447\u0430\u0442\u0430" , LogLevel . SUCCESS ) ; statusOK = true ; } else logger . log ( "\u0412\u043C\u0435\u0441\u0442\u043E Pong \u0431\u0435\u0448\u0435 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E " + received + ". \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D \u043E\u043F\u0438\u0442" , LogLevel . DEBUG ) ; retries -- ; } if ( ! statusOK ) logger . log ( "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u044F\u0432\u0430\u043D\u0435 \u0441\u043B\u0435\u0434 5 \u043D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u0438 \u043E\u043F\u0438\u0442\u0430" , LogLevel . ERRORS ) ; } catch ( IOException e ) { logger . log ( "\u0412\u044A\u0437\u043D\u0438\u043A\u043D\u0430 \u0433\u0440\u0435\u0448\u043A\u0430 \u043F\u043E \u0432\u0440\u0435\u043C\u0435 \u043D\u0430 \u043A\u043E\u043C\u0443\u043D\u0438\u043A\u0430\u0446\u0438\u044F\u0442\u0430: " + e . getMessage ( ) , LogLevel . DEBUG ) ; e . printStackTrace ( ) ; } finally { taskComplete ( ) ; } }
te	0	public void setFilters ( List < BufferedImageOp > filters ) { this . filters = filters ; }
te	8	private static boolean = ( String name1 , String name2 ) { int nameLen = name1 . length ( ) ; if ( nameLen != name2 . length ( ) ) { return false ; } for ( int i = nameLen - 1 ; i >= 0 ; i -- ) { char c1 = name1 . charAt ( i ) ; char c2 = name2 . charAt ( i ) ; if ( c1 != c2 ) { if ( c1 >= A && c1 <= Z ) { c1 += 32 ; } if ( c2 >= A && c2 <= Z ) { c2 += 32 ; } if ( c1 != c2 ) { return false ; } } } return true ; }
te	4	private List < Set < DirectedGraphNode >> findFirstLevelBoundaryNodes ( ) { final List < Set < DirectedGraphNode >> ret = new ArrayList < > ( firstLevelRegions . size ( ) ) ; for ( final Set < DirectedGraphNode > region : firstLevelRegions ) { final Set < DirectedGraphNode > boundaryNodes = new HashSet < > ( ) ; label : for ( final DirectedGraphNode node : region ) { for ( final DirectedGraphNode parent : node . parents ( ) ) { if ( region . contains ( parent ) == false ) { boundaryNodes . add ( node ) ; continue label ; } } } ret . add ( boundaryNodes ) ; } return ret ; }
te	7	@ Override public Packet write ( DataOutputStream out , PassthroughConnection ptc , KillableThread thread , boolean serverToClient ) { int oldCounter = 0 ; if ( ptc != null ) { oldCounter = ptc . packetCounter ; } if ( ! setupFields ( ) ) { ptc . printLogMessage ( "Error creating field data storage for packet: " + packetId ) ; return null ; } int length = fields . length ; for ( int cnt = 0 ; cnt < length ; cnt ++ ) { if ( fields [ cnt ] . write ( out , ptc , null , serverToClient ) == null ) { return null ; } } if ( packetId != null && ptc != null ) { int newCounter = ptc . packetCounter ; ptc . packetCounters [ packetId & FF ] += newCounter - oldCounter ; } try { out . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } return this ; }
te	1	private void navigateObject ( JsonObject source , List < String > destination , Iterator < String > nav ) { if ( nav . hasNext ( ) ) { String key = nav . next ( ) ; navigate ( source . get ( key ) , destination , nav ) ; } else { addText ( destination , source . toString ( ) ) ; } }
te	1	private void zero ( ) throws JSONException { if ( probe ) { log ( 0 ) ; } write ( 0 , 1 ) ; }
te	7	private void parseGroupOfPictures ( ) throws MpegVideoDecodeException , IOException { Statistics . startLog ( PARSE_GOP_STRING ) ; if ( m_ioTool . getBits ( 32 ) != GOP_START_CODE ) { throw new MpegVideoDecodeException ( "GOP_START_CODE expected" ) ; } Debug . println ( Debug . INFO , "GOP_START_CODE" ) ; m_bDropFlag = m_ioTool . getBits ( 1 ) == 1 ; m_iHour = m_ioTool . getBits ( 5 ) ; m_iMinute = m_ioTool . getBits ( 6 ) ; m_ioTool . skipBits ( 1 ) ; m_iSecond = m_ioTool . getBits ( 6 ) ; m_iPictCount = m_ioTool . getBits ( 6 ) ; m_bClosedGroup = m_ioTool . getBits ( 1 ) == 1 ; m_bBrokenLink = m_ioTool . getBits ( 1 ) == 1 ; m_ioTool . nextStartCode ( ) ; if ( m_ioTool . nextBits ( EXT_START_CODE , 32 ) ) { while ( ! m_ioTool . nextBits ( 1 , 24 ) ) { m_ioTool . getBits ( 8 ) ; } throw new MpegVideoDecodeException ( "MPEG-2 not supported" ) ; } if ( m_ioTool . nextBits ( USER_START_CODE , 32 ) ) { while ( ! m_ioTool . nextBits ( 1 , 24 ) ) m_ioTool . getBits ( 8 ) ; } m_iFrameNrOffset = m_iFrameNr + 2 ; do { parsePicture ( ) ; m_avSync . schedule ( ) ; } while ( ( ! m_ioTool . isEOF ( ) ) && m_ioTool . nextBits ( PICTURE_START_CODE , 32 ) ) ; Statistics . endLog ( PARSE_GOP_STRING ) ; }
te	2	void invertPriorVertices ( Segment currentSegment ) { int stop = grownSegments . indexOf ( currentSegment ) ; for ( int i = 0 ; i < stop ; i ++ ) { Vertex vertex = ( ( Segment ) grownSegments . get ( i ) ) . end ; if ( vertex . type == Vertex . INNIE ) vertex . type = Vertex . OUTIE ; else vertex . type = Vertex . INNIE ; } }
te	4	public static String reverseWords ( String s ) { if ( s == null || s . length ( ) == 0 ) { return "" ; } String [ ] words = s . trim ( ) . split ( "\\s+" ) ; int wordCount = words . length ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = wordCount - 1 ; i > 0 ; i -- ) { sb . append ( words [ i ] + " " ) ; } if ( wordCount > 0 ) { sb . append ( words [ 0 ] ) ; } return sb . toString ( ) ; }
te	5	public FibonacciHeap union ( final FibonacciHeap heap1 , final FibonacciHeap heap2 ) { final FibonacciHeap heap = new FibonacciHeap ( ) ; if ( ( heap1 != null ) && ( heap2 != null ) ) { heap . min = heap1 . min ; if ( heap . min != null ) { if ( heap2 . min != null ) { heap . min . right . left = heap2 . min . left ; heap2 . min . left . right = heap . min . right ; heap . min . right = heap2 . min ; heap2 . min . left = heap . min ; if ( heap2 . min . cost < heap1 . min . cost ) { heap . min = heap2 . min ; } } } else { heap . min = heap2 . min ; } heap . n = heap1 . n + heap2 . n ; } return heap ; }
te	0	public boolean isfCommunity ( ) { return fCommunity ; }
te	6	public void write ( Kml kml ) throws KmlException { kml . println ( "<Style" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( iconStyle != null ) { iconStyle . write ( kml ) ; } if ( labelStyle != null ) { labelStyle . write ( kml ) ; } if ( lineStyle != null ) { lineStyle . write ( kml ) ; } if ( polyStyle != null ) { polyStyle . write ( kml ) ; } if ( ballonStyle != null ) { ballonStyle . write ( kml ) ; } if ( listStyle != null ) { listStyle . write ( kml ) ; } kml . println ( - 1 , "</Style>" ) ; }
te	1	private Document parseXML ( InputStream stream ) throws Exception { DocumentBuilderFactory objDocumentBuilderFactory = null ; DocumentBuilder objDocumentBuilder = null ; Document doc = null ; try { objDocumentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; objDocumentBuilder = objDocumentBuilderFactory . newDocumentBuilder ( ) ; doc = objDocumentBuilder . parse ( stream ) ; } catch ( Exception ex ) { throw ex ; } return doc ; }
te	5	public CardBag cardsToClaim ( Railway r , Color c ) { int n = r . length ; CardBag cards ; if ( c == wildcard_color ) { if ( ks [ wildcard_ordinal ] < n ) return null ; cards = new CardBag ( ) ; cards . add ( c , n ) ; } else { int k ; if ( c != r . color && r . color != wildcard_color ) k = 0 ; else k = Math . min ( count ( c ) , n ) ; if ( ks [ wildcard_ordinal ] < n - k ) return null ; cards = new CardBag ( ) ; cards . add ( c , k ) ; cards . add ( wildcard_color , n - k ) ; } return cards ; }
te	1	public final void Init ( ) throws IOException { Code = 0 ; Range = - 1 ; for ( int i = 0 ; i < 5 ; i ++ ) Code = ( Code << 8 | Stream . read ( ) ) ; }
te	9	public void update ( ) { Direction nextDirection = null ; if ( nextDirections . isEmpty ( ) ) { if ( goal != null ) { int dx = goal . xPos - this . xPos ; int dy = goal . yPos - this . yPos ; if ( Util . abs ( dx ) <= 1 && Util . abs ( dy ) <= 1 ) return ; if ( dx > 1 ) dx = 1 ; if ( dx < - 1 ) dx = - 1 ; if ( dy > 1 ) dy = 1 ; if ( dy < - 1 ) dy = - 1 ; nextDirections . add ( Direction . getDirection ( dx , dy ) ) ; } else return ; } nextDirection = nextDirections . get ( 0 ) ; timeTraveled += RTSComponent . MS_PER_TICK / ( getTravelTime ( ) * ( nextDirection . isDiagonal ( ) ? Math . sqrt ( 2 ) : 1.0 ) ) ; while ( timeTraveled > 1 ) { timeTraveled -= 1 ; if ( nextDirections . size ( ) == 1 ) { timeTraveled = 0 ; onStopMoving ( ) ; } xPos += nextDirection . getxOffset ( ) ; yPos += nextDirection . getyOffset ( ) ; if ( ! nextDirections . isEmpty ( ) ) nextDirections . remove ( 0 ) ; } }
te	2	void reset ( ) { if ( DO_CLEAN_DIRTY ) { final int recLimit = recCurveStack . length - 1 ; for ( int i = recLimit ; i >= 0 ; i -- ) { Arrays . fill ( recCurveStack [ i ] , 0f ) ; } Arrays . fill ( sides , Side . LEFT ) ; Arrays . fill ( curLeafCtrlPolyLengths , 0f ) ; Arrays . fill ( nextRoots , 0f ) ; Arrays . fill ( flatLeafCoefCache , 0f ) ; flatLeafCoefCache [ 2 ] = - 1f ; } }
te	9	public VerifyResponse softToken ( String phone_number , String soft_token_id , String verify_code , String bundle_id , String originating_ip , String session_id ) { String result = null ; try { TeleSignRequest tr = new TeleSignRequest ( API_MOBILE_URL , V2_VERIFY_TOKEN , "POST" , customer_id , secret_key , connectTimeout , readTimeout , httpsProtocol ) ; String body = "phone_number=" + URLEncoder . encode ( phone_number , "UTF-8" ) ; if ( null != soft_token_id ) { body += "&soft_token_id=" + URLEncoder . encode ( soft_token_id , "UTF-8" ) ; } if ( null != verify_code ) { body += "&verify_code=" + URLEncoder . encode ( verify_code , "UTF-8" ) ; } if ( null != bundle_id ) { body += "&bundle_id=" + URLEncoder . encode ( bundle_id , "UTF-8" ) ; } if ( null != originating_ip && ! originating_ip . isEmpty ( ) && IpValidator . isValidIpAddress ( originating_ip ) ) { body += "&originating_ip=" + URLEncoder . encode ( originating_ip , "UTF-8" ) ; } if ( null != session_id && ! session_id . isEmpty ( ) ) { body += "&session_id=" + URLEncoder . encode ( session_id , "UTF-8" ) ; } tr . setPostBody ( body ) ; result = tr . executeRequest ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while executing Verify soft token API: " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } VerifyResponse response = gson . fromJson ( result , VerifyResponse . class ) ; return response ; }
te	4	private ChessGame ( int ruleNum , DisplayState ViewState ) throws Exception { switch ( ruleNum ) { case ( 1 ) : Rules = new ChessVanillaRules ( ) ; break ; case ( 2 ) : Rules = new ChessGuelphGryphonRules ( ) ; break ; case ( 3 ) : Rules = new ChessDunsanyRules ( ) ; break ; default : System . out . println ( "An invalid rule set has been selected" ) ; throw new Exception ( "An invalid rule set has been selected" ) ; } if ( ViewState == DisplayState . Graphical ) { Display = new ChessVanillaGraphical ( ) ; } else { Display = new ChessVanillaTerminal ( ) ; } GameState = Rules . InitializeGameState ( Display ) ; Player1 = new ChessPlayerController ( 1 , GameState ) ; Player2 = new ChessPlayerController ( 2 , GameState ) ; turnPlayer = 1 ; }
te	5	public boolean verifyNoColision ( Schedule schedule ) { for ( Map < Field , Match > coincidentMatches : schedule . getSchedule ( ) . values ( ) ) { Set < Participant > activeParticipantList = new HashSet < Participant > ( ) ; for ( Match match : coincidentMatches . values ( ) ) { if ( match != null ) { if ( activeParticipantList . contains ( match . getParticipantA ( ) ) ) { System . out . println ( "Collision detected with participant " + match . getParticipantA ( ) + " at " + match . getStartDate ( ) ) ; return false ; } else { activeParticipantList . add ( match . getParticipantA ( ) ) ; } if ( activeParticipantList . contains ( match . getParticipantB ( ) ) ) { System . out . println ( "Collision detected with participant " + match . getParticipantB ( ) + " at " + match . getStartDate ( ) ) ; return false ; } else { activeParticipantList . add ( match . getParticipantB ( ) ) ; } } } } return true ; }
te	1	public static int hashCode ( boolean bool ) { return ( bool ? 1231 : 1237 ) ; }
te	5	@ Override public int compareTo ( Time o ) { if ( o == null ) { return - 1 ; } if ( hour < o . hour ) { return - 1 ; } else if ( hour > o . hour ) { return 1 ; } if ( minute < o . minute ) { return - 1 ; } else if ( minute > o . minute ) { return 1 ; } return 0 ; }
te	8	public void printModel ( Model pm , String sdfilename , boolean autostart , int line ) throws InterruptedException { if ( state . connecting ) { cons . appendText ( "Still connecting. Please wait until connecting is established." ) ; return ; } if ( ! state . connected ) { cons . appendText ( "Not connected" ) ; return ; } startline = 0 ; if ( sdfilename == null ) { cons . appendText ( "Add model to print queue" ) ; printQueue . addModel ( pm ) ; startline = line ; if ( state . debug ) cons . appendText ( "Filling print queue  Printing:" + state . printing ) ; } else if ( pm != null ) { printQueue . putAuto ( GCodeFactory . getGCode ( "M21" , - 21 ) ) ; printQueue . putAuto ( GCodeFactory . getGCode ( "M28 " + sdfilename , - 28 ) ) ; state . streaming = true ; GCode finishstream = GCodeFactory . getGCode ( "M29 " + sdfilename , - 29 ) ; if ( autostart ) { GCode selectfile = GCodeFactory . getGCode ( "M23 " + sdfilename , - 23 ) ; GCode printfile = GCodeFactory . getGCode ( "M24" , - 24 ) ; printQueue . addModel ( pm , finishstream , selectfile , printfile ) ; state . sdprint = true ; } else { printQueue . addModel ( pm , finishstream ) ; } if ( state . debug ) cons . appendText ( "Filling queue to stream  streaming:" + state . printing ) ; } else { printQueue . putAuto ( GCodeFactory . getGCode ( "M23 " + sdfilename , - 23 ) ) ; printQueue . putAuto ( GCodeFactory . getGCode ( "M24" , - 24 ) ) ; state . sdprint = true ; if ( state . debug ) cons . appendText ( "SD print  Printing:" + state . printing ) ; } setPrintMode ( true , false ) ; }
te	1	public boolean optBoolean ( String name , boolean fallback ) { Object object = opt ( name ) ; boolean result = JSON . toBoolean ( object ) ; return result != null ? result : fallback ; }
te	3	public void actionListener ( Action e ) { switch ( e . getActionType ( ) ) { case "start" : start ( white_player ) ; break ; case "quit" : unRegisterPlayer ( curPlayer . color ) ; end ( ) ; break ; case "move" : ActionMove mev = ( ActionMove ) e ; curPlayer . put ( board , mev . x , mev . y ) ; process ( ) ; break ; default : break ; } }
te	9	static Object less ( Object subtree , Object key , int khash ) { if ( subtree == null ) return null ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , khash ) ; int found = bin_srch_res & BIN_SEARCH_FOUND_MASK ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( found == BIN_SEARCH_FOUND ) { if ( eql ( key , ary [ idx ] ) ) return remove2 ( ary , idx ) ; else return subtree ; } else return subtree ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int nkhash = node . khash ; if ( khash == nkhash ) { if ( ! ( nkey instanceof EquivalentMap ) ) { if ( ! eql ( key , nkey ) ) return subtree ; else return join ( node . left , node . right ) ; } else return buildNode ( equivLess ( nkey , key ) , khash , null , node . left , node . right ) ; } else if ( khash < nkhash ) { Object new_left = less ( node . left , key , khash ) ; if ( new_left == node . left ) return subtree ; else return buildNode ( nkey , nkhash , node . value , new_left , node . right ) ; } else { Object new_right = less ( node . right , key , khash ) ; if ( new_right == node . right ) return subtree ; else return buildNode ( nkey , nkhash , node . value , node . left , new_right ) ; } } }
te	7	private void modifyPanelInit ( ) { modifyPanel = new JPanel ( ) ; generator . createRigidSpace ( modifyPanel , 15 ) ; final JTable allClients = new JTable ( allClientsModel . getTableModel ( 2 ) ) ; allClients . removeColumn ( allClients . getColumn ( "ID Number" ) ) ; allClients . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allClients . setFillsViewportHeight ( true ) ; allClients . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scroll = new JScrollPane ( allClients ) ; scroll . setMaximumSize ( new Dimension ( TableWidth , 300 ) ) ; modifyPanel . add ( scroll ) ; JLabel idLabel = generator . createLabel ( modifyPanel , "Please choose a row" , "" ) ; JLabel emailLabel = generator . createLabel ( modifyPanel , "Email" ) ; final JTextField emailInput = generator . createTextField ( modifyPanel , "" ) ; JLabel companyLabel = generator . createLabel ( modifyPanel , "Company" ) ; final JTextField companyInput = generator . createTextField ( modifyPanel , "" ) ; JLabel phoneLabel = generator . createLabel ( modifyPanel , "Phone Number (xxx-xxx-xxxx)" ) ; final JTextField phoneInput = generator . createTextField ( modifyPanel , "" ) ; JLabel addressLabel = generator . createLabel ( modifyPanel , "Address" ) ; final JTextField addressInput = generator . createTextField ( modifyPanel , "" ) ; final JLabel resultLabel = generator . createLabel ( modifyPanel , " " ) ; JButton updateButton = generator . createButton ( modifyPanel , "Update" , 5 ) ; JButton backButton = generator . createButton ( modifyPanel , "Back" , mainViewName , 5 ) ; modifyPanel . setLayout ( new BoxLayout ( modifyPanel , BoxLayout . Y_AXIS ) ) ; updateButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { boolean result = false ; int clientId = 0 ; ClientClass client ; if ( emailInput . getText ( ) . matches ( "" ) || companyInput . getText ( ) . matches ( "" ) || phoneInput . getText ( ) . matches ( "" ) || addressInput . getText ( ) . matches ( "" ) ) { resultLabel . setText ( "Please fill out the empty fields" ) ; return ; } if ( allClients . getSelectedRow ( ) == - 1 ) { resultLabel . setText ( "Please select a row  Please try again..." ) ; return ; } clientId = allClientsModel . getIDFromRow ( allClients . getSelectedRow ( ) ) ; client = ClientControllerClass . getInstance ( ) . getClient ( clientId ) ; client . setEmail ( emailInput . getText ( ) ) ; client . setCompany ( companyInput . getText ( ) ) ; client . setPhone ( phoneInput . getText ( ) ) ; client . setAddress ( addressInput . getText ( ) ) ; result = client . verifyInput ( ) ; if ( ! result ) { resultLabel . setText ( "Invalid Client Information  Please try again..." ) ; return ; } result = ClientControllerClass . getInstance ( ) . modifyClient ( client ) ; if ( result == true ) { resultLabel . setText ( "Client information successfully updated!" ) ; Object [ ] modifiedRow = { client . getClientId ( ) , client . getFirstName ( ) , client . getLastName ( ) , client . getCompany ( ) , client . getEmail ( ) , client . getPhone ( ) , client . getAddress ( ) } ; allClientsModel . modifyData ( modifiedRow , allClients . getSelectedRow ( ) ) ; emailInput . setText ( "" ) ; companyInput . setText ( "" ) ; phoneInput . setText ( "" ) ; addressInput . setText ( "" ) ; } else { resultLabel . setText ( "Error modifying client in the database  Please try again..." ) ; } } } ) ; ListSelectionModel rowSM = allClients . getSelectionModel ( ) ; rowSM . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { Object [ ] data = allClientsModel . getData ( allClients . getSelectedRow ( ) ) ; companyInput . setText ( ( String ) data [ 3 ] ) ; emailInput . setText ( ( String ) data [ 4 ] ) ; phoneInput . setText ( ( String ) data [ 5 ] ) ; addressInput . setText ( ( String ) data [ 6 ] ) ; } } ) ; }
te	5	public List < Set < String >> characterHeuristics ( ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.addHeuristicsNouns.characterHeuristics" ) ; Set < String > taxonNames = new HashSet < String > ( ) ; Set < String > nouns = new HashSet < String > ( ) ; Set < String > anouns = new HashSet < String > ( ) ; Set < String > pnouns = new HashSet < String > ( ) ; Set < String > descriptors = new HashSet < String > ( ) ; Map < String , boolean > descriptorMap = new HashMap < String , boolean > ( ) ; int sent_num = this . myDataHolder . getSentenceHolder ( ) . size ( ) ; for ( int i = 0 ; i < sent_num ; i ++ ) { SentenceStructure sent = this . myDataHolder . getSentenceHolder ( ) . get ( i ) ; String source = sent . getSource ( ) ; String sentence = sent . getSentence ( ) ; String originalSentence = sent . getOriginalSentence ( ) ; myLogger . trace ( "Source: " + source ) ; myLogger . trace ( "Sentence: " + sentence ) ; myLogger . trace ( "Original Sentence: " + originalSentence ) ; originalSentence = StringUtility . trimString ( originalSentence ) ; taxonNames = this . getTaxonNameNouns ( originalSentence ) ; sentence = sentence . replaceAll ( "<\\s*/?\\s*i\\s*>" , "" ) ; originalSentence = originalSentence . replaceAll ( "<\\s*/?\\s*i\\s*>" , "" ) ; this . myDataHolder . getSentenceHolder ( ) . get ( i ) . setSentence ( sentence ) ; Set < String > nouns0 = this . getNounsMecklesCartilage ( originalSentence ) ; nouns . addAll ( nouns0 ) ; sentence = sentence . replaceAll ( "#" , "" ) ; this . myDataHolder . getSentenceHolder ( ) . get ( i ) . setSentence ( sentence ) ; Set < String > nouns2 = this . getNounsRule2 ( originalSentence ) ; nouns . addAll ( nouns2 ) ; String copy = originalSentence ; Set < String > nouns_temp = this . getNounsRule3Helper ( copy ) ; Iterator < String > iter = nouns_temp . iterator ( ) ; while ( iter . hasNext ( ) ) { String token = iter . next ( ) ; if ( token . matches ( "^.*[A-Z].+$" ) && ( ! token . matches ( "^.*-\\w+ed$" ) ) ) { if ( token . matches ( "^[A-Z0-9]+$" ) ) { token = token . toLowerCase ( ) ; anouns . add ( token ) ; } else { token = token . toLowerCase ( ) ; pnouns . add ( token ) ; } nouns . add ( token ) ; } } Set < String > nouns1 = getNounsRule1 ( source , originalSentence , descriptorMap ) ; nouns . addAll ( nouns1 ) ; Set < String > nouns4 = this . getNounsRule4 ( originalSentence ) ; nouns . addAll ( nouns4 ) ; originalSentence = StringUtility . removePunctuation ( originalSentence , "-" ) ; descriptors . addAll ( this . getDescriptorsRule1 ( source , originalSentence , nouns ) ) ; descriptors . addAll ( this . getDescriptorsRule2 ( originalSentence , descriptorMap ) ) ; } nouns = this . filterOutDescriptors ( nouns , descriptors ) ; anouns = this . filterOutDescriptors ( anouns , descriptors ) ; pnouns = this . filterOutDescriptors ( pnouns , descriptors ) ; this . getDataHolder ( ) . add2HeuristicNounTable ( nouns , "organ" ) ; this . getDataHolder ( ) . add2HeuristicNounTable ( anouns , "acronyms" ) ; this . getDataHolder ( ) . add2HeuristicNounTable ( pnouns , "propernouns" ) ; this . getDataHolder ( ) . add2HeuristicNounTable ( taxonNames , "taxonnames" ) ; nouns . addAll ( anouns ) ; nouns . addAll ( pnouns ) ; nouns . addAll ( taxonNames ) ; List < Set < String >> results = new LinkedList < Set < String >> ( ) ; results . add ( nouns ) ; results . add ( descriptors ) ; return results ; }
te	3	public final ListQuery < T > each ( EachBlock < T > block ) { if ( isEmpty ( ) || block == null ) { return this ; } for ( T t : list ) { block . call ( t ) ; } return this ; }
te	6	public void addNeuron ( ArrayList < Connection > connects , Neuron neuron ) { if ( connects . isEmpty ( ) ) { mutate ( ) ; return ; } int connectionNum = rng . getInt ( connects . size ( ) , null , false ) ; Connection connection = connects . get ( connectionNum ) ; int cnt = 0 ; while ( connection . getGiveNeuron ( ) == connection . getRecieveNeuron ( ) ) { cnt ++ ; connectionNum = rng . getInt ( connects . size ( ) , null , false ) ; connection = connects . get ( connectionNum ) ; if ( cnt == 200 ) new CMDTester ( this ) ; } Neuron otherNeuron = null ; if ( connection . getGiveNeuron ( ) == neuron ) otherNeuron = connection . getRecieveNeuron ( ) ; else otherNeuron = connection . getGiveNeuron ( ) ; Neuron newNeuron = new Neuron_Add ( ) ; if ( usingSpeciation ) { newNeuron . setInitIn ( neuron . getInnovationNum ( ) ) ; newNeuron . setInitOut ( otherNeuron . getInnovationNum ( ) ) ; tracker . defineNeuron ( newNeuron ) ; } else newNeuron . setInnovationNum ( nodeCnt ++ ) ; if ( connection . getGiveNeuron ( ) == neuron ) { makeConnection ( neuron , newNeuron ) ; makeConnection ( newNeuron , otherNeuron ) ; } else { makeConnection ( otherNeuron , newNeuron ) ; makeConnection ( newNeuron , neuron ) ; } neurons . add ( newNeuron ) ; nodes . add ( newNeuron ) ; }
te	6	@ Override public void read ( InputStream in , String baseURI , ContentType ct , final StreamRDF output , Context context ) { try { Object jsonObject = JSONUtils . fromInputStream ( in ) ; JSONLDTripleCallback callback = new JSONLDTripleCallback ( ) { @ Override public Object call ( RDFDataset dataset ) { for ( String gn : dataset . keySet ( ) ) { Object x = dataset . get ( gn ) ; if ( "@default" . equals ( gn ) ) { @ SuppressWarnings ( "unchecked" ) List < Map < String , Object >> triples = ( List < Map < String , Object >> ) x ; for ( Map < String , Object > t : triples ) { Node s = createNode ( t , "subject" ) ; Node p = createNode ( t , "predicate" ) ; Node o = createNode ( t , "object" ) ; Triple triple = Triple . create ( s , p , o ) ; output . triple ( triple ) ; } } else { @ SuppressWarnings ( "unchecked" ) List < Map < String , Object >> quads = ( List < Map < String , Object >> ) x ; Node g = NodeFactory . createURI ( gn ) ; for ( Map < String , Object > q : quads ) { Node s = createNode ( q , "subject" ) ; Node p = createNode ( q , "subject" ) ; Node o = createNode ( q , "object" ) ; output . triple ( Triple . create ( s , p , o ) ) ; } } } return null ; } } ; JSONLD . toRDF ( jsonObject , callback ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( JSONLDProcessingError e ) { e . printStackTrace ( ) ; } }
te	1	private AbstractAction getCalorieAction ( ) { if ( calorieAction == null ) { calorieAction = new AbstractAction ( "Kalorien" , null ) { public void actionPerformed ( ActionEvent evt ) { String eweight = TF_Weight . getText ( ) ; String eduration = TF_duration . getText ( ) ; SportDiscipline ediscipline = ( SportDiscipline ) CB_Discipline . getSelectedItem ( ) ; Calculate . calconsumption ( eduration , ediscipline , eweight ) ; } } ; } return calorieAction ; }
te	4	public float time_total ( int i ) { if ( ! seekable || i >= links ) return ( - 1 ) ; if ( i < 0 ) { float acc = 0 ; for ( int j = 0 ; j < links ; j ++ ) { acc += time_total ( j ) ; } return ( acc ) ; } else { return ( ( float ) ( pcmlengths [ i ] ) / vi [ i ] . rate ) ; } }
te	2	private static void createFileHandlerManually ( ) { try { final File logFile = new File ( LOG_FILE_PATH ) ; if ( logFile . createNewFile ( ) ) { handler = new FileHandler ( LOG_FILE_PATH ) ; handler . setFormatter ( new SimpleFormatter ( ) ) ; } else { System . out . println ( "Unable to create the log file  check " + "directory permissions" ) ; } } catch ( IOException e ) { System . out . println ( "Unable to create the file handler for the " + "logger due to an I/O error: " + e . getMessage ( ) ) ; } }
te	9	public void move ( ) { if ( deadTime > 0 ) { for ( int i = 0 ; i < 8 ; i ++ ) { world . addSprite ( new Sparkle ( ( int ) ( x + Math . random ( ) * 8 - 4 ) + 4 , ( int ) ( y + Math . random ( ) * 8 - 4 ) + 2 , ( float ) Math . random ( ) * 2 - 1 - facing , ( float ) Math . random ( ) * 2 - 1 , 0 , 1 , 5 ) ) ; } spriteContext . removeSprite ( this ) ; return ; } if ( facing != 0 ) anim ++ ; float sideWaysSpeed = 8f ; if ( xa > 2 ) { facing = 1 ; } if ( xa < - 2 ) { facing = - 1 ; } xa = facing * sideWaysSpeed ; world . checkFireballCollide ( this ) ; xFlipPic = facing == - 1 ; runTime += ( Math . abs ( xa ) ) + 5 ; xPic = ( anim ) % 4 ; if ( ! move ( xa , 0 ) ) { die ( ) ; } onGround = false ; move ( 0 , ya ) ; if ( onGround ) ya = - 10 ; ya *= 0.95f ; if ( onGround ) { xa *= GROUND_INERTIA ; } else { xa *= AIR_INERTIA ; } if ( ! onGround ) { ya += 1.5 ; } }
te	5	public void defineField ( String fieldname , String guiname , String type ) { try { if ( fields . contains ( fieldname ) ) return ; if ( guiname == null ) guiname = fieldname ; fields . add ( fieldname ) ; fieldtypes . put ( fieldname , type ) ; fieldguinames . put ( fieldname , guiname ) ; addGuiComponent ( fieldname ) ; if ( cls != null ) { Field field = cls . getField ( fieldname ) ; setField ( fieldname , field . get ( obj ) , true ) ; } } catch ( NoSuchFieldException e ) { System . out . println ( "Cls:" + cls ) ; throw new JGameError ( "Field " + fieldname + " not found." ) ; } catch ( IllegalAccessException e ) { throw new JGameError ( "Field " + fieldname + " has access error." ) ; } }
te	1	private void doSelectGoal ( ) { if ( board . setGoal ( this . boardPosition ) ) { selectGoal = false ; board . setRobots ( currentPosition ) ; updateBoardGetRobots ( ) ; } }
te	6	private static boolean isLegalCharacter ( char c ) { return c >=   && c <=  || c ==   || c == '' || c == 	 || c == £ || c == € ; }
te	1	public static byte [ ] [ ] [ ] parseRanges ( String raw , String separator ) throws RuntimeException { String [ ] ranges = raw . split ( separator ) ; byte [ ] [ ] [ ] result = new byte [ ranges . length ] [ ] [ ] ; for ( int i = 0 ; i < ranges . length ; i ++ ) { result [ i ] = parseRange ( ranges [ i ] ) ; } return result ; }
