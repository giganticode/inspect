tr	8	public static void main ( String [ ] args ) { int n = 150 , max = 2349 , min = 0 ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int count = 0 ; count < n ; count ++ ) { int op = ( int ) ( Math . random ( ) * 4 ) ; int value = ( int ) ( Math . random ( ) * ( max - min ) ) ; if ( op == 0 ) { System . out . println ( "Add:\t " + value ) ; stack . push ( value ) ; } else if ( op == 1 ) System . out . println ( "Peek:\t " + stack . peek ( ) ) ; else if ( op == 2 ) { if ( stack . peek ( ) != null ) { System . out . println ( "Pop:\t " + stack . peek ( ) ) ; stack . pop ( ) ; } else System . out . println ( "Pop:\t failed [null]" ) ; } else if ( op == 3 ) { System . out . println ( "Length:\t " + stack . length ( ) ) ; } else if ( op == 4 ) { if ( stack . contains ( value ) ) System . out . println ( "Contains:\t " + value ) ; else System . out . println ( "!Contains:\t " + value ) ; } } System . out . println ( "\n\nThe resulting stack now looks like this:\n" + stack ) ; }
tr	5	public void addScoreValue ( int i ) { if ( this . currentTurn . isClosed ( ) || playerFinished ( ) ) { host . requestNextPlayerEvent ( ) ; return ; } if ( this . getRemainingScore ( ) - i < 0 ) { this . currentTurn . busted ( ) ; this . host . bust ( this ) ; return ; } this . currentTurn . addThrow ( i ) ; if ( playerFinished ( ) ) { this . host . firePlayerFinishedEvent ( ) ; } if ( this . currentTurn . hasRemainingThrows ( ) ) { checkFinishingPossibility ( ) ; } else { this . host . turnEnded ( ) ; } this . host . provideRemainingScore ( ) ; }
tr	4	public String toString ( ) { String s = "" ; try { s = String . format ( "{%s: id = %s  " , this . getClass ( ) . getSimpleName ( ) , this . getClass ( ) . getSuperclass ( ) . getDeclaredField ( "id" ) . get ( this ) ) ; Field [ ] fields = this . getClass ( ) . getDeclaredFields ( ) ; for ( Field f : fields ) { f . setAccessible ( true ) ; if ( f . getName ( ) . equals ( "serialVersionUID" ) ) continue ; if ( f . getName ( ) . equalsIgnoreCase ( "objects" ) ) continue ; s += String . format ( "%s = %s  " , f . getName ( ) , f . get ( this ) ) ; } s = s . substring ( 0 , s . lastIndexOf ( " " ) ) ; s += "}" ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return s ; }
tr	9	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) Math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) Math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
tr	0	public Citizen ( String surname , String name , String secondName ) { this ( new FullName ( surname , name , secondName ) ) ; }
tr	9	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
tr	7	public void paint ( Graphics g ) { if ( fm == null ) { fm = g . getFontMetrics ( font ) ; titleFm = g . getFontMetrics ( titleFont ) ; minSize . width = titleFm . stringWidth ( title ) ; minSize . height = 1 + TITLE_ABOVE_SPACE + titleFm . getHeight ( ) + TITLE_BELOW_SPACE ; for ( int i = 0 ; i < items . length ; i ++ ) { minSize . height += ITEM_ABOVE_SPACE ; if ( items [ i ] . equals ( "-" ) ) { minSize . height += DIVIDER_HEIGHT ; } else { minSize . height += fm . getHeight ( ) ; if ( fm . stringWidth ( items [ i ] ) > minSize . width ) minSize . width = fm . stringWidth ( items [ i ] ) ; } minSize . height += ITEM_BELOW_SPACE ; } minSize . width += ( MATTE_SIZE + 1 ) * 2 ; minSize . height ++ ; resize ( minSize ) ; repaint ( ) ; } else { g . setColor ( borderColor ) ; g . drawLine ( 0 , 0 , 0 , size ( ) . height - 1 ) ; g . drawLine ( 0 , 0 , size ( ) . width - 1 , 0 ) ; g . drawLine ( size ( ) . width - 1 , 0 , size ( ) . width - 1 , size ( ) . height - 1 ) ; g . drawLine ( 0 , size ( ) . height - 1 , size ( ) . width - 1 , size ( ) . height - 1 ) ; int y = 1 + TITLE_ABOVE_SPACE ; g . setFont ( titleFont ) ; g . setColor ( titleColor ) ; g . drawString ( title , size ( ) . width / 2 - titleFm . stringWidth ( title ) / 2 , y + titleFm . getAscent ( ) ) ; y += titleFm . getHeight ( ) + TITLE_BELOW_SPACE ; g . setFont ( font ) ; for ( int i = 0 ; i < items . length ; i ++ ) { if ( items [ i ] . equals ( "-" ) ) { g . setColor ( dividerColor ) ; g . drawLine ( 1 , y + ITEM_ABOVE_SPACE , size ( ) . width - 2 , y + ITEM_ABOVE_SPACE ) ; y += DIVIDER_HEIGHT ; } else { if ( selected == i ) { g . setColor ( selectedBgColor ) ; g . fillRect ( 1 , y , size ( ) . width - 2 , fm . getHeight ( ) + ITEM_ABOVE_SPACE + ITEM_BELOW_SPACE ) ; g . setColor ( selectedFgColor ) ; } else g . setColor ( fgColor ) ; g . drawString ( items [ i ] , 1 + MATTE_SIZE , y + ITEM_ABOVE_SPACE + fm . getAscent ( ) ) ; y += fm . getHeight ( ) ; } y += ITEM_ABOVE_SPACE + ITEM_BELOW_SPACE ; } } }
tr	8	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<LabelStyle" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isScaleDirty ) { change += "<scale>" + this . scale + "</scale>\n" ; this . isScaleDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</LabelStyle>\n" ; } setNotDirty ( ) ; return change ; }
tr	3	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
tr	8	public void update ( int [ ] [ ] c ) { Vector v = new Vector ( ) ; int high = 0 ; for ( int i = 0 ; i < DIGITS ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { if ( c [ i ] [ j ] > high ) { high = c [ i ] [ j ] ; v . clear ( ) ; v . add ( new int [ ] { i , j } ) ; } else { if ( c [ i ] [ j ] == high ) { v . add ( new int [ ] { i , j } ) ; } } } } if ( v . size ( ) > 0 ) { int index = ( int ) ( v . size ( ) * g . nextDouble ( ) ) ; int [ ] val = ( int [ ] ) v . get ( index ) ; int row = val [ 0 ] ; int column = val [ 1 ] ; int [ ] new_c = new int [ DIGITS ] ; int temp ; for ( int j = 0 ; j < DIGITS ; j ++ ) { temp = board [ row ] [ j ] ; board [ row ] [ j ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; int [ ] [ ] nc = conflicts ( board ) ; new_c [ j ] = cost ( nc ) ; temp = board [ row ] [ j ] ; board [ row ] [ j ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; } int low = 1000 ; v = new Vector ( ) ; for ( int j = 0 ; j < DIGITS ; j ++ ) { if ( new_c [ j ] < low ) { low = new_c [ j ] ; v . clear ( ) ; v . add ( new Integer ( j ) ) ; } } index = ( int ) ( v . size ( ) * g . nextDouble ( ) ) ; int k = ( ( Integer ) v . get ( index ) ) . intValue ( ) ; temp = board [ row ] [ k ] ; board [ row ] [ k ] = board [ row ] [ column ] ; board [ row ] [ column ] = temp ; } }
tr	4	@ Override public void keyPressed ( KeyEvent k ) { if ( k . getKeyCode ( ) == k . VK_ENTER ) { try { model . setY ( double . parseDouble ( yLocField . getText ( ) ) ) ; if ( model instanceof EditorGravitable ) { if ( ( ( EditorGravitable ) model ) . model instanceof PathGravitable ) { ( ( PathGravitable ) ( ( EditorGravitable ) model ) . model ) . start . y = ( int ) double . parseDouble ( yLocField . getText ( ) ) ; } } } catch ( Exception e ) { yLocField . setText ( "" + model . getY ( ) ) ; } EditorWindow . pane . drawUpdate ( ) ; } }
tr	2	public static void main ( String args [ ] ) { String [ ] words = new String [ 2 ] ; String [ ] more = new String [ 2 ] ; ArrayList < String > str = new ArrayList < String > ( ) ; String strng ; for ( int i = 0 ; i < words . length ; i ++ ) words [ i ] = "words" + i ; for ( int i = 0 ; i < more . length ; i ++ ) more [ i ] = "more" + i ; str = merge ( words , more ) ; System . out . println ( str ) ; strng = makeSentence ( words ) ; System . out . println ( words ) ; }
tr	6	@ Override public void run ( ) { if ( inRun ) { return ; } inRun = true ; actorColorMap . clear ( ) ; int xiteration = 0 ; while ( updating ) { try { Utils . sleep ( 1000 / TIMES_PER_SECOND ) ; if ( xiteration % TIMES_PER_SECOND == 0 ) { updateRates ( ) ; } if ( xiteration % ( 5 * TIMES_PER_SECOND ) == 0 ) { renderSnapshots ( ) ; } ImageView avMain = mainActorView ; BufferedImage bi = new BufferedImage ( avMain . getWidth ( ) , avMain . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics g = bi . getGraphics ( ) ; renderTo ( g , bi . getWidth ( ) , bi . getHeight ( ) ) ; avMain . setImage ( bi ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { mainActorView . repaint ( ) ; for ( int i = 0 ; i < subActorViews . length ; i ++ ) { subActorViews [ i ] . repaint ( ) ; } threadHistoryView . repaint ( ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } xiteration ++ ; } updateRates ( ) ; inRun = false ; }
tr	1	public PublicKey stringToPublicKey ( String data ) throws InvalidKeySpecException { try { PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( data . getBytes ( ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "RSA" ) ; return keyFactory . generatePublic ( keySpec ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } }
tr	8	private String subscribe ( String msg , iKPIC_subscribeHandler2 handler ) { deb_print ( "KpCore:subscribe method" ) ; int ret = 0 ; System . out . println ( "HERE!" ) ; if ( handler == null ) { this . KP_ERROR_ID = this . ERR_EVENT_HANDLER_NULL ; err_print ( "EVENT HANDLER IS NULL!!!" ) ; return null ; } deb_print ( "KpCore:SSAP:XML MESSAGE:\n" + msg ) ; deb_print ( "KpCore:SSAP:Open connection..." ) ; ret = openConnect ( ) ; if ( ret != this . ERR_Conected ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:connection error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Send message..." ) ; ret = send ( msg ) ; if ( ret != this . ERR_MsgSent ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:send error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Message Sent..." ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; msg = "" ; int charRead = 0 ; try { while ( ( charRead = in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { builder . append ( buffer , 0 , charRead ) ; msg = builder . toString ( ) ; if ( msg . contains ( "<SSAP_message>" ) && msg . contains ( "</SSAP_message>" ) ) { if ( this . xmlTools . isSubscriptionConfirmed ( msg ) ) { this . KP_ERROR_ID = this . ERR_Subscription_DONE ; System . out . println ( "1" ) ; kpSocket . setKeepAlive ( true ) ; Subscription s = new Subscription ( kpSocket , handler ) ; return msg ; } else { System . out . println ( "[90] UNKNOW MESSAGE:" + msg ) ; break ; } } } deb_print ( "KpCore:readByteXByteSIBmsg:READ LOOP TERMINATED" ) ; closeConnection ( ) ; } catch ( Exception e ) { err_print ( "KPICore:readByteXByteSIBmsg:Exception on EVENT HANDLER:RECEIVE:\n" + e ) ; this . KP_ERROR_ID = this . ERR_SOCKET_TIMEOUT ; } this . KP_ERROR_ID = this . ERR_Subscription_NOT_DONE ; deb_print ( "KpCore:SSAP:Message received:(" + msg + ")" ) ; return msg ; }
tr	1	public boolean isShareQuantityZero ( ) { boolean result ; if ( shareQuantity == 0 ) { result = true ; } else { result = false ; } return result ; }
tr	9	protected void addMolecule ( final String strPK , final String canonSmiles , final List < String > listNames , final Map < String , Object > mapProperties ) throws IOException , GenericRDKitException { if ( strPK == null ) { throw new IllegalArgumentException ( "Primary key must not be null." ) ; } if ( canonSmiles == null || canonSmiles . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Canonical SMILES must not be null or empty." ) ; } final IndexWriter writer = prepareWriter ( ) ; if ( writer != null ) { writer . deleteDocuments ( new TermQuery ( new Term ( FIELD_PK , strPK ) ) ) ; final BitSet fp = m_fingerprintFactory . createStructureFingerprint ( canonSmiles , true ) ; final Document doc = new Document ( ) ; doc . add ( new Field ( FIELD_PK , strPK , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; doc . add ( new Field ( FIELD_SMILES , canonSmiles , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; for ( int i = fp . nextSetBit ( 0 ) ; i >= 0 ; i = fp . nextSetBit ( i + 1 ) ) { doc . add ( new Field ( FIELD_FP , Integer . toString ( i ) , Store . NO , Index . NOT_ANALYZED_NO_NORMS , Field . TermVector . NO ) ) ; } if ( listNames != null ) { for ( final String name : listNames ) { doc . add ( new Field ( FIELD_NAME , name , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; } } if ( mapProperties != null ) { for ( final String key : mapProperties . keySet ( ) ) { final Object value = mapProperties . get ( key ) ; if ( value != null ) { final String strValue = value . toString ( ) ; doc . add ( new Field ( key , strValue , Store . YES , Index . NOT_ANALYZED_NO_NORMS ) ) ; } } } writer . addDocument ( doc ) ; onMoleculeAdded ( strPK , canonSmiles ) ; } else { throw new IOException ( "Index writer is unavailable." ) ; } }
tr	6	public boolean equals ( Grade g ) { if ( ! this . assignmentId . equals ( g . getAssignmentId ( ) ) ) { return false ; } else if ( ! this . comments . equals ( g . getComments ( ) ) ) { return false ; } else if ( this . courseId != g . getCourseId ( ) ) { return false ; } else if ( this . ptsEarn != g . getPointsEarned ( ) ) { return false ; } else if ( this . ptsPoss != g . getPointsPossible ( ) ) { return false ; } else if ( ! this . title . equals ( g . getTitle ( ) ) ) { return false ; } else { return true ; } }
tr	0	public NoDetallado ( String p ) { this . setPais ( p ) ; }
tr	6	protected Node parseRest ( boolean first ) { Token t = scanner . getNextToken ( ) ; Node exp = null ; if ( t == null ) { exp = null ; } else if ( t . getType ( ) == TokenType . ) ) { if ( first ) return nil ; else return null ; } else if ( t . getType ( ) == TokenType . . ) { t = scanner . getNextToken ( ) ; if ( t . getType ( ) != TokenType . ) ) { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , null ) ; if ( scanner . getNextToken ( ) . getType ( ) != TokenType . ) ) System . out . println ( "Invalid use of ." ) ; else ( ( Cons ) exp ) . setVararg ( ) ; } else { System . out . println ( "unexpected: ')'" ) ; exp = parseExp ( ) ; } } else { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , parseRest ( false ) ) ; } return exp ; }
tr	0	protected void project ( ) { mXMinus = mTrans . times ( mX ) ; mPMinus = mTrans . times ( mP ) . times ( mTrans . transpose ( ) ) . + ( mQ ) ; }
tr	2	public int moveFrame ( Frame frame , int currentIndexOfPreviousItem ) { Animation oldParent = frame . getParent ( ) ; if ( currentIndexOfPreviousItem == - 1 ) { oldParent . frames . remove ( frame ) ; frames . add ( 0 , frame ) ; parent . fireFrameMoved ( oldParent , frame ) ; return 0 ; } Frame previousFrame = getFrame ( currentIndexOfPreviousItem ) ; if ( previousFrame == frame ) return currentIndexOfPreviousItem ; else { oldParent . frames . remove ( frame ) ; int newIndexOfPreviousItem = getFrameIndex ( previousFrame ) ; frames . add ( newIndexOfPreviousItem + 1 , frame ) ; parent . fireFrameMoved ( oldParent , frame ) ; return newIndexOfPreviousItem + 1 ; } }
tr	8	public static String allScores ( String fileName ) throws IOException { Scanner scan ; String [ ] usernames ; long [ ] wins , losses ; int fileLength = 0 , win = - 1 , lose = - 1 ; try { scan = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( "File not found: " + fileName ) ; FileWriter writeToFile = new FileWriter ( fileName ) ; writeToFile . write ( "//BEGIN\r\n" + "//END" ) ; writeToFile . close ( ) ; scan = new Scanner ( new File ( fileName ) ) ; } String fileContents = "" , fileLine = scan . nextLine ( ) ; while ( ! fileLine . equals ( "//END" ) ) { fileLine = scan . nextLine ( ) ; if ( ! fileLine . equals ( "//END" ) ) fileLength ++ ; } if ( fileLength == 0 ) return "There are no scores in the scoreboard!\nSave yours and get 1st place ;3" ; usernames = new String [ fileLength ] ; wins = new long [ fileLength ] ; losses = new long [ fileLength ] ; scan = new Scanner ( new File ( fileName ) ) ; String spare = scan . next ( ) ; int i ; for ( i = 0 ; i < fileLength ; i ++ ) { try { usernames [ i ] = scan . next ( ) ; wins [ i ] = scan . nextLong ( ) ; losses [ i ] = scan . nextLong ( ) ; } catch ( InputMismatchException ex ) { changeScore ( fileName , usernames [ i ] , 0 , 0 ) ; } } usernames = readNames ( usernames ) ; fileContents = "Username\t Wins\t Losses\n" ; for ( i = 0 ; i < fileLength ; i ++ ) { fileContents += ( i + 1 + ": " + usernames [ i ] + ( usernames [ i ] . length ( ) < 5 ? "\t\t" : "\t " ) + wins [ i ] + "\t " + losses [ i ] + "\n" ) ; } return ( fileContents ) ; }
tr	4	public static void main ( String [ ] args ) { if ( args . length == 0 ) { printUsage ( ) ; return ; } if ( ! ApplicationHelper . SHOW_ERROR ) { System . err . close ( ) ; } if ( args [ 0 ] . equals ( "train" ) ) { train ( ) ; } else if ( args [ 0 ] . equals ( "eval" ) ) { evaluate ( Arrays . asList ( args ) ) ; } else { classify ( args ) ; } }
tr	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	8	public void connect ( TreeLinkNode root ) { TreeLinkNode cur = root ; while ( cur != null ) { TreeLinkNode next = null ; TreeLinkNode prev = null ; while ( cur != null ) { if ( next == null ) { if ( cur . left != null ) next = cur . left ; else next = cur . right ; } if ( cur . left != null ) { if ( prev != null ) prev . next = cur . left ; prev = cur . left ; } if ( cur . right != null ) { if ( prev != null ) prev . next = cur . right ; prev = cur . right ; } cur = cur . next ; } cur = next ; } }
tr	9	private void processMainScreenClick ( ) { if ( anInt1021 != 0 ) return ; if ( super . clickMode3 == 1 ) { int i = super . saveClickX - 25 - 530 ; int j = super . saveClickY - 8 ; if ( i >= 0 && j >= 0 && i < 146 && j < 151 ) { i -= 73 ; j -= 75 ; int k = minimapInt1 + minimapInt2 & 7ff ; int i1 = Texture . anIntArray1470 [ k ] ; int j1 = Texture . anIntArray1471 [ k ] ; i1 = i1 * ( minimapInt3 + 256 ) >> 8 ; j1 = j1 * ( minimapInt3 + 256 ) >> 8 ; int k1 = j * i1 + i * j1 >> 11 ; int l1 = j * j1 - i * i1 >> 11 ; int i2 = myPlayer . x + k1 >> 7 ; int j2 = myPlayer . y - l1 >> 7 ; boolean flag1 = doWalkTo ( 1 , 0 , 0 , 0 , myPlayer . smallY [ 0 ] , 0 , 0 , j2 , myPlayer . smallX [ 0 ] , true , i2 ) ; if ( flag1 ) { stream . writeWordBigEndian ( i ) ; stream . writeWordBigEndian ( j ) ; stream . writeWord ( minimapInt1 ) ; stream . writeWordBigEndian ( 57 ) ; stream . writeWordBigEndian ( minimapInt2 ) ; stream . writeWordBigEndian ( minimapInt3 ) ; stream . writeWordBigEndian ( 89 ) ; stream . writeWord ( myPlayer . x ) ; stream . writeWord ( myPlayer . y ) ; stream . writeWordBigEndian ( anInt1264 ) ; stream . writeWordBigEndian ( 63 ) ; } } anInt1117 ++ ; if ( anInt1117 > 1151 ) { anInt1117 = 0 ; stream . createFrame ( 246 ) ; stream . writeWordBigEndian ( 0 ) ; int l = stream . currentOffset ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) stream . writeWordBigEndian ( 101 ) ; stream . writeWordBigEndian ( 197 ) ; stream . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; stream . writeWordBigEndian ( ( int ) ( Math . random ( ) * 256D ) ) ; stream . writeWordBigEndian ( 67 ) ; stream . writeWord ( 14214 ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) stream . writeWord ( 29487 ) ; stream . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) stream . writeWordBigEndian ( 220 ) ; stream . writeWordBigEndian ( 180 ) ; stream . writeBytes ( stream . currentOffset - l ) ; } } }
tr	4	public int getElapsed ( ) { if ( getStart ( ) == null || getEnd ( ) == null || ! hasActuallyStarted ( ) || hasEnded ( ) ) { return - 1 ; } return Util . safeLongToInt ( Util . getDeltaT ( start , new GregCalPlus ( ) ) ) ; }
tr	1	@ Override public AttributeSet getAttributes ( ) { if ( refreshAttributes ) { attributes = createAttributes ( ) ; refreshAttributes = false ; refreshProperties = false ; } return attributes ; }
tr	7	private void setupLinks ( ) { final int rawlinksnum = this . links . size ( ) ; int [ ] rawlinks = new int [ rawlinksnum * Link . LINK_SIZE ] ; int idx = 0 ; for ( int i = 0 ; i < rawlinksnum ; i ++ ) { final int [ ] link = this . links . get ( i ) ; final int src = link [ 0 ] ; final int dst = link [ 1 ] ; final int widx = link [ 2 ] ; rawlinks [ idx ] = src ; idx ++ ; rawlinks [ idx ] = dst ; idx ++ ; rawlinks [ idx ] = widx ; idx ++ ; } Link . sortDstMaj ( rawlinks , Link . ORDER_ASC ) ; int [ ] links = Link . eliminateRedundantLinks ( rawlinks ) ; if ( links . length % Link . LINK_SIZE != 0 ) { throw new LinkArrayCorrupt ( ) ; } this . structure . links = links ; final int linksnum = links . length / Link . LINK_SIZE ; this . structure . linksnum = linksnum ; int woff = 1 ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = links [ idx + Link . IDX_SRC ] ; final int dst = links [ idx + Link . IDX_DST ] ; final int widx = links [ idx + Link . IDX_WEIGHT ] ; this . indeg [ dst ] ++ ; this . outdeg [ src ] ++ ; final int lsrc = this . layermap [ src ] ; final int ldst = this . layermap [ dst ] ; if ( lsrc >= ldst ) { this . structure . recurrent = true ; } if ( widx == WEIGHT_NEEDED ) { links [ idx + Link . IDX_WEIGHT ] = woff ; woff ++ ; } else if ( widx == Link . NOWEIGHT ) { links [ idx + Link . IDX_WEIGHT ] = 0 ; } idx += Link . LINK_SIZE ; } this . structure . weightsnum = ( woff - 1 ) ; int [ ] linksrev = links . clone ( ) ; Link . sortSrcMaj ( linksrev , Link . ORDER_ASC ) ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = linksrev [ idx + Link . IDX_SRC ] ; final int dst = linksrev [ idx + Link . IDX_DST ] ; linksrev [ idx + Link . IDX_DST ] = src ; linksrev [ idx + Link . IDX_SRC ] = dst ; idx += Link . LINK_SIZE ; } this . structure . linksrev = linksrev ; }
tr	1	public void mouseReleased ( MouseEvent e ) { GameAction gameAction = getMouseButtonAction ( e ) ; if ( gameAction != null ) { gameAction . release ( ) ; } }
tr	2	void setProgressBar ( double pos ) { progress_bar = pos ; if ( ! is_initialised && initpainter != null ) repaint ( 100 ) ; }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ArrayDescr other = ( ArrayDescr ) obj ; if ( basetype == null ) { if ( other . basetype != null ) return false ; } else if ( ! basetype . equals ( other . basetype ) ) return false ; if ( numberOfElements != other . numberOfElements ) return false ; return true ; }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } Ѕtring data = Ѕtring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	2	public String getColumnName ( int column ) { switch ( column ) { case 0 : return "Game" ; case 1 : return "\u21BB" ; default : return "" ; } }
tr	0	public Rect div ( double factor ) { return copy ( ) . div_ip ( factor ) ; }
tr	8	private void handlePhysicalInteract ( PlayerInteractEvent event ) { if ( event . isCancelled ( ) ) return ; Location l = event . getClickedBlock ( ) . getLocation ( ) ; l . setY ( l . getY ( ) - 2 ) ; if ( l . getBlock ( ) . getState ( ) instanceof Sign ) { Sign s = ( Sign ) l . getBlock ( ) . getState ( ) ; String [ ] msg = s . getLines ( ) ; boolean oo = false ; String ms = "" ; for ( String m : msg ) { if ( ! m . isEmpty ( ) && m . substring ( 0 , 1 ) . equals ( "/" ) ) { Bukkit . dispatchCommand ( event . getPlayer ( ) , m . substring ( 1 ) ) ; } else { if ( oo ) { ms += m + " " ; } } if ( m . toLowerCase ( ) . equals ( "[tell]" ) ) { oo = true ; } } if ( ! ms . isEmpty ( ) ) event . getPlayer ( ) . sendMessage ( ChatColor . DARK_AQUA + ChatColor . translateAlternateColorCodes ( "&" . charAt ( 0 ) , ms ) ) ; } }
tr	7	public void generateAggregatedReport ( ) { long start , end ; start = System . currentTimeMillis ( ) ; File reportFile = new File ( reportFileName ) ; PrintWriter reportOut = null ; boolean once = true ; try { reportOut = new PrintWriter ( reportFile ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } reportOut . println ( "Report Generation Time   " + timeStamp ) ; for ( int instanceNo = 0 ; instanceNo < instanceFiles . length ; instanceNo ++ ) { ProblemInstance problemInstance = createProblemInstance ( instanceFiles [ instanceNo ] , singleOutputFileName ) ; Scheme6 ga = new Scheme6 ( problemInstance ) ; if ( once ) { once = false ; reportOut . format ( "Number Of Generation  Population Size  Offspring Population Size  LoadPenalty  RouteTime Penalty\n" ) ; reportOut . format ( "%d  %d  %d  %f  %f\n" , ga . NUMBER_OF_GENERATION , ga . POPULATION_SIZE , ga . NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; reportOut . println ( ) ; reportOut . println ( ) ; reportOut . format ( "Instance Name  Min  Avg  Max  Feasible \n" ) ; } double min = FFFFFF ; double max = - 1 ; double sum = 0 ; double avg ; int feasibleCount = 0 ; for ( int i = 0 ; i < runSize ; i ++ ) { Individual sol = ga . run ( ) ; if ( sol . isFeasible == true ) { feasibleCount ++ ; } sum += sol . costWithPenalty ; if ( sol . costWithPenalty > max ) max = sol . costWithPenalty ; if ( sol . costWithPenalty < min ) min = sol . costWithPenalty ; } avg = sum / runSize ; reportOut . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; reportOut . flush ( ) ; System . out . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; } end = System . currentTimeMillis ( ) ; long duration = ( end - start ) / 1000 ; long minute = duration / 60 ; long seconds = duration % 60 ; reportOut . println ( "\nELAPSED TIME : " + minute + " minutes " + seconds + " seconds" ) ; reportOut . flush ( ) ; reportOut . close ( ) ; }
tr	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
tr	5	public Identifier AddUser ( User info ) { try { if ( info . getContact ( ) == null || info . getContact ( ) . getEmail ( ) == null || info . getFirstName ( ) == null || info . getLastName ( ) == null ) { return null ; } return Users . getInstance ( ) . create ( info ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { System . err . println ( "Failed to Add user. " + e . getMessage ( ) ) ; return null ; } }
tr	7	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case OTHER : description = "Other" ; break ; case ENTITY_INFORMATION_INTERACTION : description = "Entity Information/Interaction" ; break ; case WARFARE : description = "Warfare" ; break ; case LOGISTICS : description = "Logistics" ; break ; case RADIO_COMMUNICATION : description = "Radio Communication" ; break ; case SIMULATION_MANAGEMENT : description = "Simulation Management" ; break ; case DISTRIBUTED_EMISSION_REGENERATION : description = "Distributed Emission Regeneration" ; break ; } return description ; }
tr	3	@ Override public boolean rotateRight ( Token [ ] [ ] tokens , int [ ] [ ] currentTokens , int rotateCount ) { if ( rotateCount % 4 == 0 ) { x0 = currentTokens [ 0 ] [ 0 ] + 2 ; y0 = currentTokens [ 0 ] [ 1 ] - 1 ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] + 1 ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 2 ; } else if ( rotateCount % 4 == 1 ) { x0 = currentTokens [ 0 ] [ 0 ] - 2 ; y0 = currentTokens [ 0 ] [ 1 ] + 2 ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else if ( rotateCount % 4 == 2 ) { x0 = currentTokens [ 0 ] [ 0 ] + 1 ; y0 = currentTokens [ 0 ] [ 1 ] - 2 ; x1 = currentTokens [ 1 ] [ 0 ] ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] - 1 ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 2 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else { x0 = currentTokens [ 0 ] [ 0 ] - 1 ; y0 = currentTokens [ 0 ] [ 1 ] + 1 ; x1 = currentTokens [ 1 ] [ 0 ] ; y1 = currentTokens [ 1 ] [ 1 ] ; x2 = currentTokens [ 2 ] [ 0 ] + 1 ; y2 = currentTokens [ 2 ] [ 1 ] - 1 ; x3 = currentTokens [ 3 ] [ 0 ] + 2 ; y3 = currentTokens [ 3 ] [ 1 ] - 2 ; } return setCurrentTokens ( currentTokens ) ; }
tr	0	public void print ( String str , int style ) { synchronized ( outputLock ) { insert ( str , base , style ) ; base += str . length ( ) ; setCaretPosition ( base ) ; } }
tr	3	public void run ( ) { Update ( ) ; while ( ! mDisconnected ) { if ( System . currentTimeMillis ( ) > mTimer ) { System . out . println ( "disconnected" ) ; mDisconnected = true ; } try { Thread . sleep ( 100 ) ; } catch ( Exception e ) { } } }
tr	0	public void setWireframe ( boolean enabled ) { wireframeEnabled = enabled ; }
tr	6	public static void polcoe ( final double [ ] x , final double [ ] y , final double [ ] cof ) { int k , j , i , n = x . length ; double phi , ff , b ; double [ ] s = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) s [ i ] = cof [ i ] = 0.0 ; s [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { for ( j = n - 1 - i ; j < n - 1 ; j ++ ) s [ j ] -= x [ i ] * s [ j + 1 ] ; s [ n - 1 ] -= x [ i ] ; } for ( j = 0 ; j < n ; j ++ ) { phi = n ; for ( k = n - 1 ; k > 0 ; k -- ) phi = k * s [ k ] + x [ j ] * phi ; ff = y [ j ] / phi ; b = 1.0 ; for ( k = n - 1 ; k >= 0 ; k -- ) { cof [ k ] += b * ff ; b = s [ k ] + x [ j ] * b ; } } }
tr	2	public void mouseClicked ( BlockPoint bp ) { if ( CableBattle . stage . setProps ( bp , CableBattle . propsBar . getSelectType ( ) ) ) { CableBattle . getSound ( ) . playEffect ( SoundEffect . POP ) ; if ( CableBattle . stage . checkState ( ) ) { CableBattle . stage . win ( ) ; } } else { CableBattle . getSound ( ) . playEffect ( SoundEffect . DISABLED ) ; } }
tr	8	public int applyBonatoTest ( double [ ] variances ) { int i = signals . get ( 0 ) . size ( ) / 2 ; int onset = Integer . MAX_VALUE ; for ( int k = 0 ; k < sensorSize ; k ++ ) { bonatoSigns . get ( k ) . clear ( ) ; cumulativeSignsCounter [ k ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int j_k1 = signals . get ( k ) . get ( j * 2 ) ; int j_k2 = signals . get ( k ) . get ( ( j * 2 ) + 1 ) ; double g_j = Math . pow ( ( j_k1 + j_k2 ) , 2 ) / variances [ k ] ; if ( g_j > this . threshold_h ) { bonatoSigns . get ( k ) . add ( true ) ; cumulativeSignsCounter [ k ] ++ ; } else { bonatoSigns . get ( k ) . add ( false ) ; cumulativeSignsCounter [ k ] = 0 ; } } for ( int j = 0 ; j < sensorSize ; j ++ ) { if ( cumulativeSignsCounter [ j ] > threshold_m ) { System . out . println ( "onset" ) ; for ( int j2 = 0 ; j2 < i ; j2 ++ ) { if ( bonatoSigns . get ( k ) . get ( j2 ) ) { if ( j2 * 2 < onset ) { onset = j2 * 2 ; System . out . println ( "onset" ) ; } break ; } } } } } return onset ; }
tr	4	@ Override public void mouseClicked ( MouseEvent arg0 ) { if ( albumsScreen . editing ) { albumsScreen . editing = false ; albumsScreen . edit . setIcon ( new ImageIcon ( "resources/editUP.jpg" ) ) ; albumsScreen . edit . setPressedIcon ( new ImageIcon ( "resources/editDN.jpg" ) ) ; for ( AlbumInfo panel : albumsScreen . albumpanels ) { panel . changeName ( ) ; panel . showHideDeleteBtn ( ) ; panel . allowNameEditing ( ) ; } } try { photoScreen = new PhotosScreen ( this . album , this . albumsScreen . control , this . albumsScreen . backend , this , this . albumsScreen ) ; photoScreen . setVisible ( true ) ; photoScreen . setLocationRelativeTo ( null ) ; photoScreen . setResizable ( false ) ; this . albumsScreen . setVisible ( false ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	4	@ Override public void visit ( FSP_OrSplit g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| OR_SPLIT }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
tr	7	public void addOperator ( BinaryOperator operator ) { if ( ! functionContextStack . isEmpty ( ) ) { Integer sizeOperators = functionContextStack . peek ( ) . getSizeOperatorsForParameters ( ) ; if ( sizeOperators != null ) { while ( ! operatorStack . isEmpty ( ) && sizeOperators != operatorStack . size ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { final BinaryOperator binaryOperator = operatorStack . pop ( ) ; applyOperator ( binaryOperator ) ; } } } else { while ( ! operatorStack . isEmpty ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { applyOperator ( operatorStack . pop ( ) ) ; } } operatorStack . push ( operator ) ; }
tr	5	public Type get ( int index ) { if ( index >= length ) return new BooleanValue ( false ) ; else if ( index < 0 && Math . abs ( index ) <= length ) return elements [ length + index ] ; else if ( index < 0 && Math . abs ( index ) > length ) return new BooleanValue ( false ) ; return elements [ index ] ; }
tr	8	public boolean IsInverse ( GameDirection Direction ) { if ( this == GameDirection . UP && Direction == GameDirection . DOWN ) return true ; if ( this == GameDirection . DOWN && Direction == GameDirection . UP ) return true ; if ( this == GameDirection . LEFT && Direction == GameDirection . RIGHT ) return true ; if ( this == GameDirection . RIGHT && Direction == GameDirection . LEFT ) return true ; return false ; }
tr	4	public static String readln ( boolean inclusive ) throws IOException { if ( inclusive ) { return readln ( ) ; } char d ; String result = new String ( ) ; while ( ( d = ( char ) input . read ( ) ) != '' && d != '' && d != - 1 ) { result += d ; } return result ; }
tr	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
tr	1	private boolean test ( String text ) { try { Integer . parseInt ( text ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }
tr	9	public String longestPalindrome ( String s ) { if ( s == null ) return null ; char [ ] array = s . toCharArray ( ) ; int n = s . length ( ) ; int maxLen = 1 ; int beginIndex = 0 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { table [ i ] [ j ] = true ; continue ; } table [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( array [ i ] == array [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; maxLen = 2 ; beginIndex = i ; } } for ( int len = 3 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; if ( array [ i ] == array [ j ] && table [ i + 1 ] [ j - 1 ] ) { table [ i ] [ j ] = true ; beginIndex = i ; maxLen = len ; } } } return s . substring ( beginIndex , beginIndex + maxLen ) ; }
tr	9	private static void gaussian ( double src [ ] [ ] , double dst [ ] [ ] ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) dst [ i ] [ j ] = src [ i ] [ j ] ; for ( int i = 0 ; i < 4 ; i ++ ) index [ i ] = i ; for ( int i = 0 ; i < 4 ; i ++ ) { double c1 = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { double c0 = Math . abs ( dst [ i ] [ j ] ) ; if ( c0 > c1 ) c1 = c0 ; } c [ i ] = c1 ; } int k = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { double p1 = 0 ; for ( int i = j ; i < 4 ; i ++ ) { double p0 = Math . abs ( dst [ index [ i ] ] [ j ] ) ; p0 /= c [ index [ i ] ] ; if ( p0 > p1 ) { p1 = p0 ; k = i ; } } int itmp = index [ j ] ; index [ j ] = index [ k ] ; index [ k ] = itmp ; for ( int i = j + 1 ; i < 4 ; i ++ ) { double pj = dst [ index [ i ] ] [ j ] / dst [ index [ j ] ] [ j ] ; dst [ index [ i ] ] [ j ] = pj ; for ( int l = j + 1 ; l < 4 ; l ++ ) dst [ index [ i ] ] [ l ] -= pj * dst [ index [ j ] ] [ l ] ; } } }
tr	5	public boolean hasChanged ( ) { if ( parent != null && parent . hasChanged ( ) ) return true ; if ( ! pos . equals ( oldPos ) ) return true ; if ( ! rot . equals ( oldRot ) ) return true ; if ( ! scale . equals ( oldScale ) ) return true ; return false ; }
tr	5	@ Override public int [ ] select ( Population pop , int toSelect ) { int [ ] futureParents = new int [ toSelect ] ; futureParents [ 0 ] = 0 ; futureParents [ 1 ] = 1 ; int numOfParents = 2 ; double [ ] fitnessSegments = rankPopulation ( pop ) ; double entireSegment = fitnessSegments [ fitnessSegments . length - 1 ] ; while ( numOfParents < futureParents . length ) { double x = ( double ) ( Math . random ( ) * entireSegment ) ; if ( x <= fitnessSegments [ 0 ] ) { futureParents [ numOfParents ] = 0 ; numOfParents ++ ; } else for ( int i = 1 ; i < futureParents . length ; i ++ ) if ( x > fitnessSegments [ i - 1 ] && x <= fitnessSegments [ i ] ) { futureParents [ numOfParents ] = i ; numOfParents ++ ; } } return futureParents ; }
tr	1	public PluginMenuItemBuilder ( Map < String , Constructor < ? extends ICreature >> mc , ActionListener listener ) { menu = new JMenu ( ) ; this . constructors = mc ; this . listener = listener ; }
tr	9	public Object run ( ) throws Exception { return Util . getWorkingDirectory ( ) + File . separator + "bin" + File . separator ; }
tr	5	public void genCPrototype ( PW pw ) { pw . printIdent ( "" ) ; pw . print ( getType ( ) . getCName ( true ) ) ; pw . print ( " " ) ; if ( isIsStatic ( ) ) { pw . print ( "_static" ) ; } pw . print ( "_" + getClassDec ( ) . getName ( ) + "_" + getName ( ) ) ; pw . print ( "(" ) ; if ( ! isIsStatic ( ) ) pw . print ( "_class_" + getClassDec ( ) . getName ( ) + " *this" ) ; if ( getParamList ( ) != null && getParamList ( ) . getSize ( ) > 0 ) { if ( ! isIsStatic ( ) ) pw . print ( " " ) ; getParamList ( ) . genC ( pw ) ; } pw . println ( ");" ) ; }
tr	4	@ Override public boolean parseField ( String name , String value ) { if ( super . parseField ( name , value ) ) { return true ; } if ( name != null && value != null ) { PeripheralFieldHandler handler = EnumUtils . lookup ( PeripheralFieldHandler . class , name ) ; if ( handler != null ) { return handler . handle ( device , value ) ; } else { return false ; } } return false ; }
tr	0	public String getStr ( ) { return str ; }
tr	7	public static int getDistance ( String s , String t ) { if ( s == null ) { if ( t == null ) return 0 ; return t . length ( ) ; } if ( t == null ) return s . length ( ) ; if ( s . equals ( t ) ) return 0 ; char [ ] sArray = s . toCharArray ( ) ; char [ ] tArray = t . toCharArray ( ) ; int max = sArray . length > tArray . length ? tArray . length : sArray . length ; int distance = Math . abs ( sArray . length - tArray . length ) ; for ( int i = 0 ; i < max ; i ++ ) { if ( sArray [ i ] != tArray [ i ] ) { distance ++ ; } } return distance ; }
tr	8	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
tr	6	public Object clone ( ) throws CloneNotSupportedException { Feature result = ( Feature ) super . clone ( ) ; if ( result . lookAt != null ) { result . lookAt = ( LookAt ) this . lookAt . clone ( ) ; result . lookAt . setParent ( result ) ; } if ( result . timePrimitive != null ) { result . timePrimitive = ( TimePrimitive ) this . timePrimitive . clone ( ) ; result . timePrimitive . setParent ( result ) ; } if ( result . styleSelector != null ) { result . styleSelector = new ArrayList ( ) ; for ( Iterator iter = this . styleSelector . iterator ( ) ; iter . hasNext ( ) ; ) { StyleSelector element = ( StyleSelector ) iter . next ( ) ; StyleSelector elementClone = ( StyleSelector ) element . clone ( ) ; elementClone . setParent ( result ) ; result . styleSelector . add ( elementClone ) ; } } if ( result . region != null ) { result . region = ( Region ) this . region . clone ( ) ; result . region . setParent ( result ) ; } if ( result . metadata != null ) { result . metadata = ( Metadata ) this . metadata . clone ( ) ; result . metadata . setParent ( result ) ; } return result ; }
tr	6	private boolean skipComment ( ) throws IOException { char cc = _next ( ) ; if ( cc != * ) { putback ( cc ) ; return false ; } int lineno = getLine ( ) ; while ( ( cc = _next ( ) ) != EOF ) { if ( cc == * ) { cc = _next ( ) ; if ( cc == / ) return true ; if ( cc == * ) putback ( cc ) ; if ( cc == EOF ) break ; } } throw error ( "unclosed comment" , _lineno ) ; }
tr	6	public Geometry makePath ( double [ ] [ ] Pn , int nP ) { if ( nP == this . nP && same ( Pn , this . Pn ) ) return this ; if ( this . Pn == null || this . Pn . length != Pn . length ) this . Pn = new double [ Pn . length ] [ 3 ] ; for ( int n = 0 ; n < Pn . length ; n ++ ) for ( int k = 0 ; k < Pn [ n ] . length ; k ++ ) this . Pn [ n ] [ k ] = Pn [ n ] [ k ] ; return makePath ( resample ( Pn , nP ) ) ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	6	public void clear ( int mode ) { if ( mode == ClearAction . MODE_REGEX || mode == ClearAction . MODE_ALL ) { txt_RegExp . setText ( "" ) ; } if ( mode == ClearAction . MODE_SEARCH || mode == ClearAction . MODE_ALL ) { txt_SearchText . setText ( "" ) ; } if ( mode == ClearAction . MODE_RESULT || mode == ClearAction . MODE_ALL ) { txt_Result . setText ( "" ) ; } regex . reset ( ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tela other = ( Tela ) obj ; if ( modulo == null ) { if ( other . modulo != null ) return false ; } else if ( ! modulo . equals ( other . modulo ) ) return false ; if ( nome == null ) { if ( other . nome != null ) return false ; } else if ( ! nome . equals ( other . nome ) ) return false ; if ( nro == null ) { if ( other . nro != null ) return false ; } else if ( ! nro . equals ( other . nro ) ) return false ; return true ; }
tr	9	public PiecePanel ( tutFrame frame , int x ) { this . setLayout ( new BorderLayout ( ) ) ; this . setPreferredSize ( new Dimension ( PLAYERWIDTH , GRIDSIZE ) ) ; this . setBackground ( Color . DARK_GRAY . darker ( ) ) ; boardPanel = frame . boardPanel ; this . board = frame . board ; this . player = frame . players [ x ] ; this . frame = frame ; currentPiece = null ; Border bord1 , bord2 , finalborder ; bord1 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 5 , 0 , 0 , Color . BLUE ) , BorderFactory . createMatteBorder ( 5 , 0 , 0 , 0 , Color . RED ) ) ; bord2 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 0 , 5 , Color . YELLOW ) , BorderFactory . createMatteBorder ( 0 , 0 , 5 , 0 , Color . GREEN ) ) ; finalborder = new CompoundBorder ( bord1 , bord2 ) ; this . setBorder ( finalborder ) ; switch ( player . getColor ( ) ) { case b : color = "Blue" ; break ; case r : color = "Red" ; break ; case y : color = "Yellow" ; break ; case g : color = "Green" ; break ; } im = new Image [ 21 ] ; ImageIcon temp ; for ( int i = 0 ; i < 21 ; ++ i ) { try { temp = new ImageIcon ( getClass ( ) . getResource ( "/images/" + color + "/" + String . valueOf ( i ) + "S.png" ) ) ; im [ i ] = temp . getImage ( ) ; } catch ( Exception e ) { System . out . println ( "Stuff" ) ; System . exit ( 10 ) ; } } piecesPanel = new JPanel ( new FlowLayout ( ) ) ; piecesPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; pieces = new Piece [ 21 ] ; clickables = new JRadioButton [ 21 ] ; int w , h ; ImageIcon icon = null ; ButtonListener clicked = new ButtonListener ( ) ; for ( int i = 0 ; i < 21 ; ++ i ) { pieces [ i ] = player . getPiece ( i ) ; w = ( int ) ( 0.7 * ( pieces [ i ] . getWidth ( ) * SPACESIZE ) ) ; h = ( int ) ( 0.7 * ( pieces [ i ] . getHeight ( ) * SPACESIZE + 1 ) ) ; im [ i ] = im [ i ] . getScaledInstance ( w , h , BufferedImage . SCALE_DEFAULT ) ; icon = new ImageIcon ( im [ i ] ) ; clickables [ i ] = new JRadioButton ( icon ) ; clickables [ i ] . setOpaque ( false ) ; clickables [ i ] . addActionListener ( clicked ) ; piecesPanel . add ( clickables [ i ] ) ; } this . add ( piecesPanel ) ; rcButton = new JButton ( "<html><center>Rotate<p>Right(&gt)</center></html>" ) ; rccButton = new JButton ( "<html><center>Rotate<p>Left(&lt)</center></html>" ) ; flipButton = new JButton ( "Flip(^)" ) ; buttonPanel = new JPanel ( new GridLayout ( 1 , 3 ) ) ; buttonPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; buttonPanel . add ( rccButton , BorderLayout . SOUTH ) ; buttonPanel . add ( flipButton , BorderLayout . SOUTH ) ; buttonPanel . add ( rcButton , BorderLayout . SOUTH ) ; rcButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRC ( ) ; } } } ) ; rccButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRCC ( ) ; } } } ) ; flipButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragFlip ( ) ; } } } ) ; submitButton = new JButton ( "Submit Move!(ENTER)" ) ; submitButton . addActionListener ( new SubmitListener ( ) ) ; submitButton . setEnabled ( false ) ; JPanel two = new JPanel ( new GridLayout ( 2 , 1 ) ) ; two . setBackground ( Color . DARK_GRAY . darker ( ) ) ; two . add ( buttonPanel ) ; two . add ( submitButton ) ; this . add ( two , BorderLayout . SOUTH ) ; }
tr	1	public static void main ( String [ ] args ) { System . out . println ( "Primera matriz" ) ; int [ ] [ ] mat1 = leeMatriz ( ) ; System . out . println ( ) ; System . out . println ( "Segunda matriz" ) ; int [ ] [ ] mat2 = leeMatriz ( ) ; System . out . println ( ) ; int [ ] [ ] producto = null ; try { producto = matrizMul ( mat1 , mat2 ) ; } catch ( ArithmeticException ae ) { System . out . println ( ae . getMessage ( ) ) ; return ; } muestraMatriz ( producto ) ; }
tr	1	public static void input ( float delta ) { if ( nextScene != null ) { updateLoadScene ( ) ; } rootNode . input ( delta ) ; }
tr	0	public Response ( String responseText , int statusCode ) { this . responseText = responseText ; this . statusCode = statusCode ; created_on = TimeUtility . getNowByGMT ( ) . getTime ( ) ; }
tr	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! ( obj instanceof Person ) ) { return false ; } Person that = ( Person ) obj ; return ( Objects . equals ( this . name , that . name ) && this . age == that . age ) ; }
tr	0	public GameVector PlusX ( ) { ++ this . xIndex ; return this ; }
tr	4	public boolean updateBypreparedPreparedStatement ( String sql , List < Object > params ) throws SQLException { boolean flag = false ; int result = - 1 ; pstmt = connection . prepareStatement ( sql ) ; int index = 1 ; if ( params != null && ! params . isEmpty ( ) ) { for ( int i = 0 ; i < params . size ( ) ; i ++ ) { pstmt . setObject ( index ++ , params . get ( i ) ) ; } } result = pstmt . executeUpdate ( ) ; flag = result > 0 ? true : false ; return flag ; }
tr	0	java . lang . Integer getKey ( String value ) { java . lang . Integer key ; key = Integer . valueOf ( value ) ; return key ; }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	2	protected int lastDocId ( ArrayList < Integer > prevSkipInfo ) { if ( prevSkipInfo == null || prevSkipInfo . isEmpty ( ) ) return 0 ; else { return prevSkipInfo . get ( prevSkipInfo . size ( ) - 2 ) ; } }
tr	2	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
tr	4	private KeyFrame getKeyFrame ( int i ) { try { MapEvent me = events . poll ( ) ; if ( me != null ) { if ( nodes . containsKey ( me . getNext ( ) ) ) { if ( transport . containsKey ( me . getName ( ) ) ) { TransportAgentUi ui = transport . get ( me . getName ( ) ) ; return moveTransport ( me . getNext ( ) , me . getRoadPercent ( ) , ui , Duration . millis ( i * 1000 ) ) ; } else { } } else { } } else { Thread . sleep ( 1000 ) ; } } catch ( Throwable te ) { ExceptionUtils . handleException ( te ) ; } return getKeyFrame ( i ) ; }
tr	3	private Object getReferencedContent ( DependentDupReferenceContentDef cd , String dependData ) { Vector < Object > enteredVals = allEnteredReferencedVals . get ( cd . getTableDef ( ) . getName ( ) + "." + cd . getFieldDef ( ) . getName ( ) ) ; assert ( enteredVals != null ) ; if ( enteredVals == null ) { System . err . println ( "could not find key " + cd . getTableDef ( ) . getName ( ) + "." + cd . getFieldDef ( ) . getName ( ) + " in allEnteredReferencedVals. " + "Did you forget to set referenced=\"true\"?" ) ; logger . error ( "enteredVals == null!" ) ; } String key = ( ( DupReferenceContentDef ) cd ) . getDestTableDef ( ) . getName ( ) + "." + ( ( DupReferenceContentDef ) cd ) . getDestFieldDef ( ) . getName ( ) + "." + cd . getTableDef ( ) . getName ( ) + "." + cd . getFieldDef ( ) . getName ( ) ; int idx = DupReferenceContentDef . copyIndex . get ( key ) ; DupReferenceContentDef . copyIndex . put ( key , idx + 1 ) ; FieldDef dependRefField = cd . getDependReferenceFieldDef ( ) ; Vector < Object > tmp = allEnteredReferencedVals . get ( cd . getTableDef ( ) . getName ( ) + "." + dependRefField . getName ( ) ) ; Vector < Object > resultPool = new Vector < Object > ( ) ; Iterator < Object > it = tmp . iterator ( ) ; int i = 0 ; while ( it . hasNext ( ) ) { Object curr = it . next ( ) ; if ( curr . toString ( ) . equals ( dependData ) ) resultPool . add ( enteredVals . get ( i ) ) ; i ++ ; } return resultPool . get ( idx % resultPool . size ( ) ) ; }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	0	public void setCurrentIndex ( int currentIndex ) { this . currentIndex = currentIndex ; }
tr	7	private Message nextTypeMessage ( List < MessageType > list ) throws IOException { Message message = null ; String header ; int ret = Message . INVALID_MSG , messageLen ; do { header = reader . readLine ( ) ; if ( header == null ) return null ; header += "\n" ; messageLen = Message . validateHeader ( header , list ) ; if ( messageLen < 0 ) continue ; for ( int i = 0 ; i < messageLen ; i ++ ) { header += reader . readLine ( ) + "\n" ; } message = new Message ( header ) ; ret = message . matches ( ) ; if ( ( ret == Message . VALID_MSG ) && ! list . contains ( message . getType ( ) ) ) { ret = Message . INVALID_MSG ; } } while ( header != null && ret != Message . VALID_MSG ) ; return message ; }
tr	8	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	8	public ArrayList < Point > checkMove2 ( Stack < TTTBoard > boards , char player ) { ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; ArrayList < TTTBoard > tempArray = new ArrayList < TTTBoard > ( ) ; while ( ! boards . isEmpty ( ) ) { TTTBoard aBoard = boards . pop ( ) ; ArrayList < Point > spots = aBoard . getEmptySpots ( ) ; char turn = getChar ( spots . size ( ) ) ; ArrayList < TTTBoard > tempArray2 = new ArrayList < TTTBoard > ( ) ; for ( int i = 0 ; i < spots . size ( ) ; i ++ ) { TTTBoard board = new TTTBoard ( aBoard ) ; board . getBoard ( ) [ spots . get ( i ) . x ] [ spots . get ( i ) . y ] = turn ; if ( spots . size ( ) < 6 ) { if ( board . checkWin ( ) ) { if ( turn == player ) { winningSpots . add ( board . getStart ( ) ) ; break ; } else { break ; } } else { tempArray2 . add ( board ) ; } } else { tempArray . add ( board ) ; } } if ( tempArray2 . size ( ) == spots . size ( ) ) { tempArray . addAll ( tempArray2 ) ; } } if ( winningSpots . isEmpty ( ) && tempArray . get ( 0 ) . getEmptySpots ( ) . size ( ) != 0 ) { boards . addAll ( tempArray ) ; winningSpots = checkMove2 ( boards , player ) ; } return winningSpots ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmGrafico . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmGrafico . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmGrafico . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmGrafico . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new frmGrafico ( ) . setVisible ( true ) ; } } ) ; }
tr	6	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	8	@ Override public void widgetSelected ( SelectionEvent e ) { if ( e . getSource ( ) == add_button ) { String username = ua_uname_text . getText ( ) ; String name = ua_name_text . getText ( ) ; String pass = ua_pass_text . getText ( ) ; String confirm = ua_cpass_text . getText ( ) ; if ( pass . equals ( confirm ) ) { if ( Sanitizer . isCleanInput ( username ) && Sanitizer . isCleanInput ( name ) && Sanitizer . isCleanInput ( pass ) ) { ADD newuser = null ; try { newuser = new ADD ( username , name , Hash . getSHA256 ( pass . getBytes ( "UTF-8" ) ) , session . getName ( ) , session . getPassHash ( ) ) ; } catch ( UnsupportedEncodingException e2 ) { System . out . println ( "nope" ) ; e2 . printStackTrace ( ) ; } try { System . out . println ( portclient . exchange ( newuser ) ) ; } catch ( UserNotFoundException e1 ) { System . out . println ( "did not go through  sorry" ) ; e1 . printStackTrace ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Invalid Input(s)." ) ; messageBox . open ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Passwords do not match." ) ; messageBox . open ( ) ; } } else if ( e . getSource ( ) == clear_button ) { ua_uname_text . setText ( "" ) ; ua_name_text . setText ( "" ) ; ua_pass_text . setText ( "" ) ; ua_cpass_text . setText ( "" ) ; } }
tr	2	public List < String > listaProvincias ( ) { List < String > provincias = new ArrayList < > ( ) ; Configuration cfg = new Configuration ( ) . configure ( ) ; SessionFactory factory = cfg . buildSessionFactory ( ) ; Session session = factory . openSession ( ) ; try { Transaction tx = session . beginTransaction ( ) ; Pais pais = ( Pais ) session . load ( Pais . class , 1 ) ; for ( Iterator < Provincia > it = pais . getProvincias ( ) . iterator ( ) ; it . hasNext ( ) ; ) { provincias . add ( it . next ( ) . getNombre ( ) ) ; } tx . commit ( ) ; } catch ( HibernateException e ) { session . getTransaction ( ) . rollback ( ) ; System . out . println ( e . getMessage ( ) ) ; } finally { session . flush ( ) ; session . close ( ) ; } return provincias ; }
tr	4	public boolean checkTerminationForValueIteration ( double prevVal [ ] , double curVal [ ] ) { if ( prevVal == null ) { return false ; } double limit = epsilon * ( 1 - mdpData . getGamma ( ) ) / mdpData . getGamma ( ) ; for ( int i = 0 ; i < mdpData . getNoOfStates ( ) ; i ++ ) { double diff = curVal [ i ] - prevVal [ i ] ; if ( diff < 0 ) { diff = - 1 * diff ; } if ( diff >= limit ) { return false ; } } return true ; }
tr	2	public double [ ] getColumnAsDouble ( int column ) { double [ ] buffer = new double [ tableEntries . size ( ) ] ; for ( int loop = 0 ; loop < tableEntries . size ( ) ; loop ++ ) { try { buffer [ loop ] = tableEntries . get ( loop ) . getDouble ( column ) ; } catch ( Exception e ) { System . err . println ( "** ERROR ** : invalid entry on line " + loop + " = [" + "]" ) ; } } return buffer ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	9	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
