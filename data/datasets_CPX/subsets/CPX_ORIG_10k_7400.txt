va	1	public String save ( ) { try { lecturerService . saveLecturer ( lecturer ) ; } catch ( ConstraintViolationException e ) { addActionError ( getText ( "msg.error.lecturerConstraint" ) ) ; return INPUT ; } return SUCCESS ; }
va	0	public boolean getDefaultShared ( ) { return defaultShared ; }
va	0	public JSONWriter value ( double d ) throws JSONException { return this . value ( new double ( d ) ) ; }
va	8	private static void buildToc ( Node node , StringBuilder tocNcx , AtomicInteger counter , AtomicInteger playOrder , AtomicReference < String > lastHref , Map < String , Integer > playOrders ) { if ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equals ( "item" ) ) { String text = ( ( Element ) node ) . getAttribute ( "text" ) ; String href = ( ( Element ) node ) . getAttribute ( "ref" ) ; if ( href == null || href . isEmpty ( ) ) { href = lastHref . get ( ) ; } else { lastHref . set ( href ) ; } int order ; if ( playOrders . containsKey ( href ) ) { order = playOrders . get ( href ) ; } else { order = playOrder . getAndIncrement ( ) ; playOrders . put ( href , order ) ; } tocNcx . append ( "<navPoint id=\"id-" ) . append ( counter . get ( ) ) . append ( "\" playOrder=\"" ) . append ( order ) . append ( "\">\n" ) ; tocNcx . append ( "<navLabel><text>" ) . append ( text ) . append ( "</text></navLabel>\n" ) ; counter . incrementAndGet ( ) ; if ( href != null && ! href . isEmpty ( ) ) { tocNcx . append ( "<content src=\"OEBPS/" + href + "\"/>\n" ) ; lastHref . set ( href ) ; buildToc ( node . getFirstChild ( ) , tocNcx , counter , playOrder , lastHref , playOrders ) ; } else { tocNcx . append ( "<content src=\"OEBPS/" + lastHref . get ( ) + "\"/>\n" ) ; buildToc ( node . getFirstChild ( ) , tocNcx , counter , playOrder , lastHref , playOrders ) ; } tocNcx . append ( "</navPoint>\n" ) ; } else { buildToc ( node . getFirstChild ( ) , tocNcx , counter , playOrder , lastHref , playOrders ) ; } } buildToc ( node . getNextSibling ( ) , tocNcx , counter , playOrder , lastHref , playOrders ) ; } }
va	2	public JSONObject ( Object object , String names [ ] ) { this ( ) ; class c = object . getClass ( ) ; for ( int i = 0 ; i < names . length ; i += 1 ) { String name = names [ i ] ; try { this . putOpt ( name , c . getField ( name ) . get ( object ) ) ; } catch ( Exception ignore ) { } } }
va	1	public void destroy ( ) { persist ( PersistAction . DELETE , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "ProducerDeleted" ) ) ; if ( ! JsfUtil . isValidationFailed ( ) ) { selected = null ; items = null ; } }
va	1	public static void startRenderLoop ( ) { while ( ! Display . isCloseRequested ( ) ) { GL11 . glLoadIdentity ( ) ; GL11 . glClear ( GL11 . GL_COLOR_BUFFER_BIT ) ; GuiScreen . currentGui . drawGui ( ) ; Display . sync ( 60 ) ; Display . update ( ) ; } Display . destroy ( ) ; }
va	5	public double calculateProbability ( String s ) { int stringLength = s . length ( ) ; double probability = 1 ; for ( int i = 0 ; i < stringLength ; i ++ ) { Character character = s . charAt ( i ) ; switch ( character ) { case A : probability = probability * this . A . get ( i ) ; break ; case C : probability = probability * this . C . get ( i ) ; break ; case G : probability = probability * this . G . get ( i ) ; break ; case T : probability = probability * this . T . get ( i ) ; break ; } } return probability ; }
va	9	public int synthesis ( Packet op ) { Info vi = vd . vi ; opb . readinit ( op . packet_base , op . packet , op . bytes ) ; if ( opb . read ( 1 ) != 0 ) { return ( - 1 ) ; } int _mode = opb . read ( vd . modebits ) ; if ( _mode == - 1 ) return ( - 1 ) ; mode = _mode ; W = vi . mode_param [ mode ] . blockflag ; if ( W != 0 ) { lW = opb . read ( 1 ) ; nW = opb . read ( 1 ) ; if ( nW == - 1 ) return ( - 1 ) ; } else { lW = 0 ; nW = 0 ; } granulepos = op . granulepos ; sequence = op . packetno - 3 ; eofflag = op . e_o_s ; pcmend = vi . blocksizes [ W ] ; if ( pcm . length < vi . channels ) { pcm = new float [ vi . channels ] [ ] ; } for ( int i = 0 ; i < vi . channels ; i ++ ) { if ( pcm [ i ] == null || pcm [ i ] . length < pcmend ) { pcm [ i ] = new float [ pcmend ] ; } else { for ( int j = 0 ; j < pcmend ; j ++ ) { pcm [ i ] [ j ] = 0 ; } } } int type = vi . map_type [ vi . mode_param [ mode ] . mapping ] ; return ( FuncMapping . mapping_P [ type ] . inverse ( this , vd . mode [ mode ] ) ) ; }
va	7	private void closeRequest ( OnDemandData onDemandData ) { try { if ( socket == null ) { long l = System . currentTimeMillis ( ) ; if ( l - openSocketTime < 4000 ) return ; openSocketTime = l ; socket = clientInstance . openSocket ( 43594 + client . portOff ) ; inputStream = socket . getInputStream ( ) ; outputStream = socket . getOutputStream ( ) ; outputStream . write ( 15 ) ; for ( int j = 0 ; j < 8 ; j ++ ) inputStream . read ( ) ; loopCycle = 0 ; } ioBuffer [ 0 ] = ( byte ) onDemandData . dataType ; ioBuffer [ 1 ] = ( byte ) ( onDemandData . ID >> 8 ) ; ioBuffer [ 2 ] = ( byte ) onDemandData . ID ; if ( onDemandData . incomplete ) ioBuffer [ 3 ] = 2 ; else if ( ! clientInstance . loggedIn ) ioBuffer [ 3 ] = 1 ; else ioBuffer [ 3 ] = 0 ; outputStream . write ( ioBuffer , 0 , 4 ) ; writeLoopCycle = 0 ; anInt1349 = - 10000 ; return ; } catch ( IOException ioexception ) { } try { socket . close ( ) ; } catch ( Exception _ex ) { } socket = null ; inputStream = null ; outputStream = null ; expectedSize = 0 ; anInt1349 ++ ; }
va	9	private static boolean contains ( Node biggerTree , Node smallerTree ) { if ( biggerTree == null && smallerTree == null ) { return true ; } else if ( ( biggerTree == null && smallerTree != null ) || ( biggerTree != null && smallerTree == null ) ) { return false ; } if ( biggerTree . val == smallerTree . val ) { boolean a = contains ( biggerTree . left , smallerTree . left ) ; boolean b = contains ( biggerTree . right , smallerTree . right ) ; if ( a && b == true ) { return true ; } } boolean a = contains ( biggerTree . left , smallerTree ) ; boolean b = contains ( biggerTree . right , smallerTree ) ; return a || b ; }
va	3	public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode == null ) { throw new NullPointerException ( "Data to encode was null." ) ; } Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . ENCODE ) ; bos . write ( dataToEncode ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } }
va	3	private void initialise ( ) { int a , b , c , d , e , f , g , h ; a = b = c = d = e = f = g = h = 9e3779b9 ; for ( int i = 0 ; i < 4 ; i ++ ) { a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; } for ( int i = 0 ; i < SIZE ; i += 8 ) { a += results [ i ] ; b += results [ i + 1 ] ; c += results [ i + 2 ] ; d += results [ i + 3 ] ; e += results [ i + 4 ] ; f += results [ i + 5 ] ; g += results [ i + 6 ] ; h += results [ i + 7 ] ; a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; memory [ i ] = a ; memory [ i + 1 ] = b ; memory [ i + 2 ] = c ; memory [ i + 3 ] = d ; memory [ i + 4 ] = e ; memory [ i + 5 ] = f ; memory [ i + 6 ] = g ; memory [ i + 7 ] = h ; } for ( int i = 0 ; i < SIZE ; i += 8 ) { a += memory [ i ] ; b += memory [ i + 1 ] ; c += memory [ i + 2 ] ; d += memory [ i + 3 ] ; e += memory [ i + 4 ] ; f += memory [ i + 5 ] ; g += memory [ i + 6 ] ; h += memory [ i + 7 ] ; a ^= b << 11 ; d += a ; b += c ; b ^= c >>> 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e >>> 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g >>> 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a >>> 9 ; c += h ; a += b ; memory [ i ] = a ; memory [ i + 1 ] = b ; memory [ i + 2 ] = c ; memory [ i + 3 ] = d ; memory [ i + 4 ] = e ; memory [ i + 5 ] = f ; memory [ i + 6 ] = g ; memory [ i + 7 ] = h ; } isaac ( ) ; count = SIZE ; }
va	1	void Reset ( ) { lq = 0 ; ls = new int [ sys . TotalServer + 1 ] ; for ( int i = 1 ; i <= sys . TotalServer ; i ++ ) { ls [ i ] = 0 ; } }
va	9	public static String nomMes ( int mes ) { String result = "" ; switch ( mes ) { case 1 : result = "Enero" ; break ; case 2 : result = "Febrero" ; break ; case 3 : result = "Marzo" ; break ; case 4 : result = "Abril" ; break ; case 5 : result = "Mayo" ; break ; case 6 : result = "Junio" ; break ; case 7 : result = "Julio" ; break ; case 8 : result = "Agosto" ; break ; case 9 : result = "Septiembre" ; break ; case 10 : result = "Octubre" ; break ; case 11 : result = "Noviembre" ; break ; case 12 : result = "Diciembre" ; break ; } return result ; }
va	5	public String getMove ( ChessView Display , int playerID ) { Scanner scan = new Scanner ( System . in ) ; Scanner parse ; String input = "" ; String start = "" ; String end = "" ; boolean valid = false ; ChessVanillaTerminal t = new ChessVanillaTerminal ( ) ; while ( ! valid ) { try { input = scan . nextLine ( ) ; if ( ! input . equalsIgnoreCase ( "q" ) ) { parse = new Scanner ( input ) . useDelimiter ( "\\s" ) ; start = parse . next ( ) ; end = parse . next ( ) ; } valid = true ; } catch ( Exception e ) { System . out . println ( "Invalid input. Please try again." ) ; } } if ( ! input . equalsIgnoreCase ( "q" ) ) { if ( ! GameState . Move ( getPlayerID ( ) , start , end ) ) System . out . println ( "Invalid move." ) ; else ChessGame . getGame ( ) . endOfTurn ( getPlayerID ( ) ) ; } else System . out . println ( "Goodbye." ) ; return input ; }
va	1	public N add ( E content ) { N node = null ; try { node = this . classeNoeud . getDeclaredConstructor ( new class [ ] { this . classeElement } ) . newInstance ( content ) ; this . noeuds . put ( content , node ) ; } catch ( Exception e ) { System . err . println ( "Noaud non cr\uFFFD\uFFFD: " + content ) ; } return node ; }
va	3	private Integer getMaxUserId ( ) throws SQLException { Integer maxUserId = 0 ; Connection con = null ; try { con = services . createConnection ( ) ; PreparedStatement stmt = con . prepareStatement ( "select max(userId) from users;" ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) maxUserId = rs . getInt ( 1 ) ; stmt . close ( ) ; } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } finally { if ( con != null ) { con . close ( ) ; } } return maxUserId ; }
va	9	private static boolean isTriangle ( int num1 , int num2 , int num3 ) { if ( num1 == num2 || num2 == num3 || num3 == num1 ) { return false ; } if ( ( sameLeftDiagonal ( num1 , num2 ) && sameRightDiagonal ( num1 , num3 ) ) || ( sameLeftDiagonal ( num1 , num3 ) && sameRightDiagonal ( num1 , num2 ) ) ) { return true ; } else if ( ( sameLeftDiagonal ( num2 , num1 ) && sameRightDiagonal ( num2 , num3 ) ) || ( sameLeftDiagonal ( num2 , num3 ) && sameRightDiagonal ( num2 , num1 ) ) ) { return true ; } else if ( ( sameLeftDiagonal ( num3 , num1 ) && sameRightDiagonal ( num3 , num2 ) ) || ( sameLeftDiagonal ( num3 , num2 ) && sameRightDiagonal ( num3 , num1 ) ) ) { return true ; } else { return false ; } }
va	7	public void _verificarPermisos_MostrarVentana ( JFrame nameFormulario , JButton [ ] botonesArrayString ) { for ( int i = 0 ; i < permisosTabla . length ; i ++ ) { if ( permisosTabla [ i ] [ 0 ] . equals ( nameFormulario . getName ( ) ) ) { if ( permisosTabla [ i ] [ 1 ] . equals ( "1" ) ) { nameFormulario . setVisible ( true ) ; } else if ( permisosTabla [ i ] [ 1 ] . equals ( "2" ) ) { for ( int j = 0 ; j < botonesArrayString . length ; j ++ ) { botonesAccesoObservador [ i ] = botonesArrayString [ i ] ; } for ( int k = 0 ; k < botonesAccesoObservador . length ; k ++ ) { botonesAccesoObservador [ k ] . setEnabled ( false ) ; } nameFormulario . setVisible ( true ) ; } else if ( permisosTabla [ i ] [ 1 ] . equals ( "3" ) ) { mensajeWarning ( ) ; } } } }
va	7	private void executeReadWrite ( final long count , int keyLen , int valueLen ) throws IOException { final int defaultKeyLen = 8 ; final int defaultValueLen = 32 ; CacheConfig config = new CacheConfig ( ) ; config . setStorageMode ( storageMode ) ; cache = new BigCache < String > ( TEST_DIR , config ) ; List < String > keys = new ArrayList < String > ( ) ; String key = "" ; String value = "" ; if ( keyLen > 0 ) { key = TestUtil . randomString ( keyLen ) ; } else { key = TestUtil . randomString ( defaultKeyLen ) ; } if ( valueLen > 0 ) { value = TestUtil . randomString ( valueLen ) ; } else { value = TestUtil . randomString ( defaultValueLen ) ; } for ( int i = 0 ; i < count ; i ++ ) { cache . put ( key + i , TestUtil . getBytes ( value + i ) ) ; keys . add ( key + i ) ; } assertEquals ( cache . count ( ) , count ) ; for ( String k : keys ) { String v = new String ( cache . get ( k ) ) ; String index = k . substring ( keyLen > 0 ? keyLen : 8 ) ; assertEquals ( value + index , v ) ; } for ( String k : keys ) { cache . delete ( k ) ; } for ( String k : keys ) { assertNull ( cache . get ( k ) ) ; } }
va	6	public MMap ( MapSet map ) { currentMap = map ; switch ( currentMap ) { case MAP1 : buildMap1 ( ) ; break ; case MAP2 : buildMap2 ( ) ; break ; case MAP3 : buildMap3 ( ) ; break ; case MAP4 : buildMap4 ( ) ; break ; case MAP5 : buildMap5 ( ) ; break ; case MAP6 : buildMap6 ( ) ; break ; default : buildMap1 ( ) ; break ; } }
va	6	public void changeGameState ( final GameState state ) { super . changeGameState ( state ) ; switch ( state ) { case INITIALIZING : break ; case STARTING : soundManager . play ( BreakOutSoundKeys . GET_READY ) ; playingField . setupLevel ( ) ; camera . setMessage ( new InGameMessage ( "Get Ready!" , WHITE , 2000 ) ) ; break ; case LEVEL_CHANGE : camera . setMessage ( new InGameMessage ( "Great Job!" , WHITE , 2000 ) ) ; SharedGameData . getInstance ( ) . levelUp ( ) ; playingField . setupLevel ( ) ; break ; case LEVEL_RESET : soundManager . play ( BreakOutSoundKeys . GET_READY ) ; playingField . resetEntities ( ) ; camera . setMessage ( new InGameMessage ( "Get Ready!" , WHITE , 2000 ) ) ; break ; case OUT_OF_BOUNDS : soundManager . play ( BreakOutSoundKeys . OUT_OF_BOUNDS ) ; camera . setMessage ( new InGameMessage ( "Out Of Bounds" , WHITE , 1000 ) ) ; break ; case GAME_OVER : soundManager . play ( BreakOutSoundKeys . GAME_OVER ) ; camera . setMessage ( new InGameMessage ( "Game Over" , RED , Integer . MAX_VALUE ) ) ; break ; } }
va	2	public Type getType ( Identifier id ) { for ( int i = types . size ( ) - 1 ; i >= 0 ; i -- ) { Type rval = types . get ( i ) . get ( id ) ; if ( rval != null ) { return rval ; } } return null ; }
va	0	public AbstractResponse ( String url , boolean failed ) { this . urlString = url ; this . failed = failed ; }
va	3	public void write ( Object value ) { if ( columnCount != - 1 && currentColumnCount >= columnCount ) throw new RuntimeException ( "First line consisted of " + columnCount + " columns  but now trying to one more." ) ; if ( currentColumnCount ++ > 0 ) out . print ( " " ) ; out . print ( escape ( value . toString ( ) ) ) ; }
va	9	@ Override public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) static . game . endGame ( ) ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) upPressed = true ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_RIGHT ) rightPressed = true ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) downPressed = true ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_LEFT ) leftPressed = true ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_F12 ) { try { File f = new File ( "E:/Users/Lucas/Desktop/seeds.txt" ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( f ) ) ) ; Vector < String > v = new Vector < String > ( ) ; String line = "" ; while ( ( line = br . readLine ( ) ) != null ) v . add ( line ) ; br . close ( ) ; PrintWriter pw = new PrintWriter ( f ) ; for ( String s : v ) pw . println ( s ) ; pw . println ( static . mapSeed ) ; pw . flush ( ) ; pw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_F11 ) { static . game . startGame ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_F10 ) { static . drawStats = ! static . drawStats ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_MINUS ) { static . viewport . zoomOut ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_EQUALS ) { static . viewport . zoomIn ( ) ; } static . game . requestFocus ( ) ; }
va	7	private static Dimension parseDim ( final BufferedReader fileIn ) throws IllegalFormatException , IOException { int lineCounter = 0 ; String temp ; boolean dim = false ; while ( ( temp = fileIn . readLine ( ) ) != null ) { lineCounter ++ ; temp = removeComment ( temp ) . trim ( ) ; if ( ! temp . equals ( "" ) ) { if ( dim ) { int , = temp . indexOf (   ) ; if ( , < 0 ) throw new IllegalFormatException ( errorMsg ( lineCounter , DIM_ERROR ) ) ; int semicolon = temp . indexOf ( ; , , + 1 ) ; if ( semicolon < 0 ) throw new IllegalFormatException ( errorMsg ( lineCounter , DIM_ERROR ) ) ; int w = Integer . parseInt ( temp . substring ( 0 , , ) . trim ( ) ) ; int h = Integer . parseInt ( temp . substring ( , + 1 , semicolon ) . trim ( ) ) ; return new Dimension ( w , h ) ; } if ( temp . equals ( DIM ) ) dim = true ; } } if ( ! dim ) throw new IllegalFormatException ( DIM_NOT_FOUND ) ; throw new IllegalFormatException ( errorMsg ( lineCounter , DIM_ERROR ) ) ; }
va	2	@ Override public void flush ( ) { String message = toString ( ) ; if ( message . length ( ) == 0 ) { return ; } if ( isAppend ) { handleAppend ( message ) ; } else { handleInsert ( message ) ; } reset ( ) ; }
va	4	private static boolean isIgnoredMessage ( String methodName ) { if ( "getClassID" . equals ( methodName ) ) { return true ; } else if ( "getClass" . equals ( methodName ) ) { return true ; } else if ( "getLogger" . equals ( methodName ) ) { return true ; } else if ( "getLogName" . equals ( methodName ) ) { return true ; } else { return false ; } }
va	9	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 6 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "y" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : slice_from ( "a" ) ; break ; case 4 : slice_from ( "o" ) ; break ; case 5 : slice_from ( "u" ) ; break ; case 6 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
va	1	public static boolean isNumeric ( final String str ) { if ( str . length ( ) == 0 ) { return false ; } final NumberFormat formatter = NumberFormat . getInstance ( ) ; final ParsePosition pos = new ParsePosition ( 0 ) ; formatter . parse ( str , pos ) ; return str . length ( ) == pos . getIndex ( ) ; }
va	7	public ParseResults doMatch ( Parser parser , int start ) { ParseResults entry = getCachedResults ( parser , start ) ; if ( entry != null ) return entry ; entry = parser . createResults ( this , start ) ; cacheMatchResults ( entry ) ; _callStack . add ( entry ) ; if ( _inProgress ) return entry ; _inProgress = true ; while ( ! _callStack . isEmpty ( ) ) { entry = _callStack . remove ( 0 ) ; parser = entry . getMatcher ( ) ; start = entry . getPosition ( ) ; boolean otrace = _trace ; boolean traceFlag = _traceFlags . get ( parser ) ; if ( traceFlag != null ) _trace = traceFlag . booleanValue ( ) ; boolean trace = _trace ; if ( trace ) _tabs ++ ; if ( trace ) System . out . println ( tabs ( ) + "doMatch(" + parser . getLabel ( ) + " " + start + ")" ) ; try { parser . startMatching ( this , start , entry ) ; } finally { if ( trace ) { System . out . println ( tabs ( ) + "/doMatch" ) ; _tabs -- ; } _trace = otrace ; } } _inProgress = false ; return entry ; }
va	3	public static boolean projectYZ ( Vector3d a , Vector3d a_ , float d ) { float tanMax = 25 ; a_ . x = a . x ; if ( a . x >= d ) return false ; float tan ; float scale = ( d - a . x ) ; tan = a . y / ( d - a . x ) ; if ( tan * tan > tanMax ) return false ; else a_ . y = a . y / scale ; tan = a . z / ( d - a . x ) ; if ( tan * tan > tanMax ) return false ; else a_ . z = a . z / scale ; return true ; }
va	0	@ Override public Point convertGeoToPoint ( GeoPoint gp ) { return new Point ( ( gp . getLon ( ) - zeroLon ) * lengthOfOneDegree ( gp . getLat ( ) ) , gp . getLat ( ) * LAT_LENGTH , gp . getAccuracy ( ) ) ; }
va	8	public void paint ( Graphics g ) { Rectangle r = new Rectangle ( p1 ) ; r . add ( p2 ) ; if ( out != null ) { g . setColor ( out ) ; if ( canvas . renderMode != RenderMode . TILED ) g . drawRect ( r . x , r . y , r . width , r . height ) ; else { Dimension img = canvas . getImageSize ( ) ; for ( int dx = 0 ; r . x + r . width - dx >= 0 ; dx += img . width ) for ( int dy = 0 ; r . y + r . height - dy >= 0 ; dy += img . height ) g . drawRect ( r . x - dx , r . y - dy , r . width , r . height ) ; } } if ( in != null ) { g . setColor ( in ) ; if ( canvas . renderMode != RenderMode . TILED ) g . fillRect ( r . x + 1 , r . y + 1 , r . width - 1 , r . height - 1 ) ; else { Dimension img = canvas . getImageSize ( ) ; for ( int dx = 0 ; r . x + r . width - dx >= 0 ; dx += img . width ) for ( int dy = 0 ; r . y + r . height - dy >= 0 ; dy += img . height ) g . fillRect ( r . x - dx + 1 , r . y - dy + 1 , r . width - 1 , r . height - 1 ) ; } } }
va	3	@ Override public void insert ( E item ) { if ( isFull ( ) ) resize ( heapArray . length * RESIZE_FACTOR ) ; int hole = size ++ ; for ( ; hole > 0 && comparator . compare ( item , heapArray [ ( hole - 1 ) / NUM_CHILDREN ] ) < 0 ; hole = ( hole - 1 ) / NUM_CHILDREN ) { heapArray [ hole ] = heapArray [ ( hole - 1 ) / NUM_CHILDREN ] ; } heapArray [ hole ] = item ; }
va	9	public static String [ ] splitCSVWithQuoteEscape ( String line ) { SortedSet < Integer > commaIndicies = new TreeSet < Integer > ( ) ; Set < Integer > quoteIndicies = new HashSet < Integer > ( ) ; Map < Integer , Integer > priorQuotes = new HashMap < Integer , Integer > ( ) ; char [ ] array = line . toCharArray ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { switch ( array [ i ] ) { case   : commaIndicies . add ( i ) ; break ; case " : case ' : quoteIndicies . add ( i ) ; break ; } priorQuotes . put ( i , quoteIndicies . size ( ) ) ; } Iterator < Integer > it = commaIndicies . iterator ( ) ; while ( it . hasNext ( ) ) { Integer i = it . next ( ) ; if ( isOdd ( priorQuotes . get ( i ) ) ) { it . remove ( ) ; } } Integer [ ] commas = commaIndicies . toArray ( new Integer [ commaIndicies . size ( ) ] ) ; List < String > list = new LinkedList < String > ( ) ; if ( commas . length > 0 ) { list . add ( line . substring ( 0 , commas [ 0 ] ) ) ; } else { list . add ( line ) ; } for ( int i = 0 ; i < commas . length - 1 ; i ++ ) { list . add ( line . substring ( commas [ i ] + 1 , commas [ i + 1 ] ) ) ; } if ( commas . length > 0 ) { list . add ( line . substring ( commas [ commas . length - 1 ] + 1 ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; }
va	8	public String outWardrecordSearch ( String patientId ) { String patientName = "" ; String sex = "" ; String age = "" ; String national = "" ; String marriage = "" ; String job = "" ; String huAddress = "" ; String nowAddress = "" ; String jobAddress = "" ; String inDate = "" ; String patientStatus = "" ; String nowDisHis = "" ; String pastDisHis = "" ; String bodyHis = "" ; String famHis = "" ; String str = "select p.patient_name p.sex p.age p.national p.marriage p.job p.hu_address p.now_address p.job_address w.in_date pc.patient_status pc.now_dis_his pc.past_dis_his pc.body_his pc.fam_his from ward w  patient p patient_case pc where p.patient_id=pc.patient_id and w.patient_id=p.patient_id and p.patient_id='" + patientId + "';" ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { patientName = num . getString ( "patient_name" ) ; sex = num . getString ( "sex" ) ; if ( sex . equals ( "1" ) ) { sex = "\u7537" ; } else if ( sex . equals ( "2" ) ) { sex = "\u5973" ; } age = num . getString ( "age" ) ; national = num . getString ( "national" ) ; marriage = num . getString ( "marriage" ) ; job = num . getString ( "job" ) ; huAddress = num . getString ( "hu_address" ) ; nowAddress = num . getString ( "now_address" ) ; jobAddress = num . getString ( "job_address" ) ; inDate = num . getString ( "in_date" ) ; patientStatus = num . getString ( "patient_status" ) ; if ( num . getString ( "now_dis_his" ) != null ) { nowDisHis = num . getString ( "now_dis_his" ) ; } if ( num . getString ( "past_dis_his" ) != null ) { pastDisHis = num . getString ( "past_dis_his" ) ; } if ( num . getString ( "body_his" ) != null ) { bodyHis = num . getString ( "body_his" ) ; } if ( num . getString ( "fam_his" ) != null ) { famHis = num . getString ( "fam_his" ) ; } sb . append ( " <table style=\"margin:0 100px\"> <tr style=\"height:50px\"><td style=\"width:200px\">\u59D3\u540D\uFF1A" + patientName + "</td><td style=\"width:200px\">\u7C4D\u8D2F\uFF1A" + huAddress + "</td></tr> <tr style=\"height:50px\"><td>\u6027\u522B\uFF1A" + sex + "</td><td>\u73B0\u4F4F\u5740\uFF1A" + nowAddress + "</td></tr> <tr style=\"height:50px\"><td>\u5E74\u9F84\uFF1A" + age + "</td><td>\u5DE5\u4F5C\u5355\u4F4D\uFF1A" + jobAddress + "</td></tr> <tr style=\"height:50px\"><td>\u6C11\u65CF\uFF1A" + national + "</td><td>\u5165\u9662\u65F6\u95F4\uFF1A" + inDate + "</td></tr>  <tr style=\"height:50px\"><td>\u5A5A\u59FB\uFF1A" + marriage + "</td><td>\u804C\u4E1A\uFF1A" + job + "</td></tr> </table>" ) ; sb . append ( " <ul><b>\u4E3B\u8BC9</b>\uFF1A" + patientStatus + "</ul> <ul><b>\u73B0\u75C5\u53F2</b>\uFF1A" + nowDisHis + "</ul> <ul><b>\u65E2\u5F80\u53F2</b>\uFF1A" + pastDisHis + "</ul> <ul><b>\u4E2A\u4EBA\u53F2</b>\uFF1A" + bodyHis + "</ul> <ul><b>\u5BB6\u65CF\u53F2</b>\uFF1A" + famHis + "</ul>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
va	8	public void reload ( ) { if ( mapPanel . level != null ) { objectPanel . loadObjects ( ) ; for ( int n = 0 ; n < mapPanel . level . getNumOfLayers ( ) ; n ++ ) { try { mapPanel . level . getLayer ( n ) . setImgPath ( Data . getDataDirectory ( ) + "/data/gfx/tileset/" + tilesetName + "0.bmp" ) ; mapPanel . level . getLayer ( n ) . reloadImg ( ) ; } catch ( IOException ex ) { } } tilesetPanel . setImage ( 0 , mapPanel . level . getLayer ( 1 ) . getImg ( ) ) ; tilesetPanel . showLayer [ 0 ] = true ; tilesetPanel . defaultSettings ( ) ; for ( int n = 0 ; n < mapPanel . level . getNumOfLayers ( ) ; n ++ ) { BufferedImage defMapImg = new BufferedImage ( mapPanel . level . getLayer ( n ) . getWidth ( ) * 16 , mapPanel . level . getLayer ( n ) . getHeight ( ) * 16 , BufferedImage . TYPE_INT_ARGB ) ; mapPanel . setImage ( n , defMapImg ) ; mapPanel . showLayer [ n ] = true ; } try { mapPanel . level . reloadCollision ( ) ; } catch ( IOException ex ) { } tilesetPanel . revalidate ( ) ; mapPanel . revalidate ( ) ; for ( int n = 0 ; n < mapPanel . drawAreaLayers . size ( ) ; n ++ ) { int levelWidth = mapPanel . level . getLayer ( n ) . getWidth ( ) * 16 ; int levelHeight = mapPanel . level . getLayer ( n ) . getHeight ( ) * 16 ; for ( int i = 0 , x = 0 ; i < levelWidth ; i += 16 , x ++ ) { for ( int j = 0 , y = 0 ; j < levelHeight ; j += 16 , y ++ ) { int tile = mapPanel . level . getLayer ( n ) . getTile ( x , y ) ; mapPanel . paintTile ( n , tile , i , j , true ) ; } } } } }
va	9	public void updateMaterial ( ) { CourseMaterialDao dao = new CourseMaterialDao ( ) ; CourseMaterial cm = dao . read ( this . creator . getCourseUid ( ) . intValue ( ) ) ; if ( cm != null ) { cm . setCourseMaterialId ( ! Integer . toString ( this . courseMaterialId ) . isEmpty ( ) && this . courseMaterialId != cm . getCourseMaterialId ( ) ? this . courseMaterialId : cm . getCourseMaterialId ( ) ) ; cm . setTitle ( ! this . title . isEmpty ( ) && this . title != cm . getTitle ( ) ? this . title : cm . getTitle ( ) ) ; cm . setDescription ( ! this . description . isEmpty ( ) && this . description != cm . getDescription ( ) ? this . description : cm . getDescription ( ) ) ; cm . setCreator ( this . creator . getUser ( ) . getUid ( ) . isEmpty ( ) && this . creator != cm . getCreator ( ) ? this . creator : cm . getCreator ( ) ) ; cm . setMaterialFilename ( ! this . materialFilename . isEmpty ( ) && this . materialFilename != cm . getMaterialFilename ( ) ? this . materialFilename : cm . getMaterialFilename ( ) ) ; cm . setCourse ( this . course . getCourseId ( ) != Material . INVALID_COURSE_ID && this . course != cm . getCourse ( ) ? this . course : cm . getCourse ( ) ) ; dao . update ( cm ) ; } }
va	7	private static boolean isValidId ( char cc ) { return ( cc >= a && cc <= z ) || ( cc >= A && cc <= Z ) || cc == - || cc == _ || ( cc >= 0 && cc <= 9 ) ; }
va	3	@ Override public int loop ( ) { if ( ! outputList . isEmpty ( ) && wr != null ) { try { wr . write ( dFormat . format ( new Date ( ) ) + " " + scriptName + " " + outputList . get ( 0 ) + "\r\n" ) ; wr . flush ( ) ; outputList . remove ( 0 ) ; } catch ( IOException e ) { System . err . println ( "Error writing output to log" ) ; e . printStackTrace ( ) ; } } return 25 ; }
va	8	private void seleccionarArchivos ( ) { int resultado = selectorArchivo . showOpenDialog ( this ) ; if ( resultado == JFileChooser . CANCEL_OPTION ) return ; File archivo = selectorArchivo . getSelectedFile ( ) ; if ( archivo . isDirectory ( ) ) explorador = new ExploradorRecursivoArchivos ( EXTENSIONES_TODAS ) ; else { if ( esDeTipo ( EXTENSIONES_AUDIO , archivo . toString ( ) ) ) { if ( biblio . noEsta ( archivo . toString ( ) , BD_ARCHIVO ) ) { directorMedios . setArchivoMultimedia ( archivoAudio ) ; directorMedios . buildArchivo ( archivo . toString ( ) ) ; medio = directorMedios . getArchivo ( ) ; biblio . aniadirArchivo ( medio ) ; } else if ( DEBUG ) System . out . println ( "NO hago nada porque ya estas: " + archivo . toString ( ) ) ; } if ( esDeTipo ( EXTENSIONES_IMAGEN , archivo . getName ( ) ) ) { if ( biblio . noEsta ( archivo . getName ( ) , BD_ARCHIVO ) ) { directorMedios . setArchivoMultimedia ( archivoImagen ) ; directorMedios . buildArchivo ( archivo . getName ( ) ) ; medio = directorMedios . getArchivo ( ) ; biblio . aniadirArchivo ( medio ) ; } else if ( DEBUG ) System . out . println ( "NO hago nada porque ya estas: " + archivo . getName ( ) ) ; } } actualizarTabla ( ) ; }
va	4	private void setupRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; ch2 ^= ( int ) ( ( rNToGo == 1 ) ? 1 : 0 ) ; i2 ++ ; currentChar = ch2 ; currentState = RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } }
va	2	private void createWaves ( String [ ] classNames , int [ ] maxAmounts ) { for ( int i = 0 ; i < classNames . length ; i ++ ) { try { class < Wave > wave = ( class < Wave > ) class . forName ( "pixelshooter.wave." + classNames [ i ] ) ; Constructor < Wave > c = wave . getConstructor ( AndroidGame . class , LevelReader . class , int . class ) ; Wave w = c . newInstance ( this . game , this , maxAmounts [ i ] ) ; this . game . waves . add ( w ) ; } catch ( Exception e ) { this . game . dbgPrint ( e . toString ( ) ) ; } } }
va	7	public static String [ ] [ ] readHighScoreTable ( ) { AssertThatFileExists ( ) ; String [ ] [ ] highscoreTable = new String [ HIGHSCORE_TABLE_SIZE ] [ 4 ] ; try { inFile = new BufferedReader ( new FileReader ( FILE_PATH + FILE_NAME ) ) ; String line = inFile . readLine ( ) ; for ( int row = 0 ; row < highscoreTable . length && line != null ; row ++ ) { String [ ] values = line . split ( delimiter , - 1 ) ; highscoreTable [ row ] [ 0 ] = Integer . toString ( row + 1 ) ; highscoreTable [ row ] [ scoreCol ] = values [ scoreCol ] ; highscoreTable [ row ] [ nameCol ] = values [ nameCol ] ; highscoreTable [ row ] [ dateCol ] = values [ dateCol ] ; line = inFile . readLine ( ) ; } } catch ( FileNotFoundException ex ) { ex . printStackTrace ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } catch ( Exception e ) { } finally { try { if ( inFile != null ) inFile . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } return highscoreTable ; }
va	7	void popAll ( PathConsumer2D io ) { if ( DO_STATS ) { if ( numCurves > curveTypesUseMark ) { curveTypesUseMark = numCurves ; } if ( end > curvesUseMark ) { curvesUseMark = end ; } } final byte [ ] _curveTypes = curveTypes ; final float [ ] _curves = curves ; int nc = numCurves ; int e = end ; while ( nc != 0 ) { switch ( _curveTypes [ -- nc ] ) { case TYPE_LINETO : e -= 2 ; io . lineTo ( _curves [ e ] , _curves [ e + 1 ] ) ; continue ; case TYPE_QUADTO : e -= 4 ; io . quadTo ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] ) ; continue ; case TYPE_CUBICTO : e -= 6 ; io . curveTo ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] , _curves [ e + 4 ] , _curves [ e + 5 ] ) ; continue ; default : } } numCurves = 0 ; end = 0 ; }
va	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ParentClass that = ( ParentClass ) o ; if ( packageInt != that . packageInt ) return false ; if ( privateInt != that . privateInt ) return false ; if ( protectedInt != that . protectedInt ) return false ; if ( publicInt != that . publicInt ) return false ; return true ; }
va	5	public void run ( ) { Socket socket ; try { socket = server . accept ( ) ; } catch ( IOException e ) { System . out . println ( "Class Server died: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; return ; } newListener ( ) ; try { DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ; try { BufferedReader in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; String path = getPath ( in ) ; byte [ ] bytecodes = getBytes ( path ) ; try { out . writeBytes ( "HTTP/1.0 200 OK\r\n" ) ; out . writeBytes ( "Content-Length: " + bytecodes . length + "\r\n" ) ; out . writeBytes ( "Content-Type: application/java\r\n\r\n" ) ; out . write ( bytecodes ) ; out . flush ( ) ; } catch ( IOException ie ) { return ; } } catch ( Exception e ) { out . writeBytes ( "HTTP/1.0 400 " + e . getMessage ( ) + "\r\n" ) ; out . writeBytes ( "Content-Type: text/html\r\n\r\n" ) ; out . flush ( ) ; } } catch ( IOException ex ) { System . out . println ( "error writing response: " + ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } finally { try { socket . close ( ) ; } catch ( IOException e ) { } } }
va	6	@ Override public void mousePressed ( MouseEvent event ) { CarcassoneBoard board = CarcassoneBoard . getInstance ( ) ; TileDeck deck = TileDeck . getInstance ( ) ; if ( containsPoint ( deck , event ) ) { myClickedPanel = deck ; myTile = myClickedPanel . getTile ( ) ; } else if ( containsPoint ( CarcassoneBoard . getViewPort ( ) , event ) ) { Component component = board . getComponentAt ( translatePoint ( board , event ) ) ; if ( component instanceof TilePanel ) { myClickedPanel = ( TilePanel ) component ; myTile = myClickedPanel . getTile ( ) ; } } if ( myTile == null || myTile instanceof EmptyTile || ! myTile . isDNDEnabled ( ) ) { reset ( ) ; return ; } }
va	1	@ Override protected void handleIncomingPacket ( Packet packet , InetAddress fromIpAddress , int fromPortNumber ) throws IOException { logger . debug ( packet + " received" ) ; LoggingUtility . logMessage ( this . getNodeId ( ) , packet . getSrcNodeId ( ) , MessageType . RCV , packet . getType ( ) , packet . getSrcNodeId ( ) + ":" + packet . getValue ( ) ) ; this . sendAck ( fromIpAddress , fromPortNumber ) ; LoggingUtility . logMessage ( this . getNodeId ( ) , packet . getSrcNodeId ( ) , MessageType . SND , PacketType . ACK ) ; if ( packet . getGroup ( ) . equals ( PacketGroup . SENSOR_DATA ) ) { logger . debug ( packet + " accepted by listener" ) ; transceiver . handlePacket ( packet ) ; } else { logger . warn ( packet + "dropped by listener - wrong type" ) ; } }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; String p1 ; p0 = new String [ ] { "a" , "aa" , "bbb" } ; p1 = "both" ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = new String [ ] { "c" , "bb" , "aaa" } ; p1 = "lengths" ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = new String [ ] { "etdfgfh" , "aio" } ; p1 = "none" ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = new String [ ] { "aaa" , "z" } ; p1 = "lexicographically" ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = new String [ ] { "z" } ; p1 = "both" ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = new String [ ] { "abcdef" , "bcdef" , "cdef" , "def" , "ef" , "f" , "topcoder" } ; p1 = "lexicographically" ; all_right = KawigiEdit_RunTest ( 5 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	3	public boolean deleteBookingFromDB ( ArrayList < Integer > deleteBookingsList , Connection con ) { int rowsDeleted = 0 ; String SQLString1 = "DELETE FROM booking_details " + "WHERE booking_id = ?" ; String SQLString2 = "DELETE FROM bookings " + "WHERE booking_id = ?" ; PreparedStatement statement1 = null ; PreparedStatement statement2 = null ; try { statement1 = con . prepareStatement ( SQLString1 ) ; statement2 = con . prepareStatement ( SQLString2 ) ; for ( int i = 0 ; i < deleteBookingsList . size ( ) ; i ++ ) { log ( deleteBookingsList . get ( i ) , ActionType . DELETE , con ) ; statement1 . setInt ( 1 , deleteBookingsList . get ( i ) ) ; statement2 . setInt ( 1 , deleteBookingsList . get ( i ) ) ; statement1 . executeUpdate ( ) ; rowsDeleted += statement2 . executeUpdate ( ) ; } } catch ( SQLException e ) { System . out . println ( "Fail in BookingMapper.deleteBookingFromDB()" ) ; System . out . println ( e . getMessage ( ) ) ; } finally { try { statement1 . close ( ) ; } catch ( SQLException e ) { System . out . println ( "Fail in BookingMapper.deleteBookingFromDB()" ) ; System . out . println ( e . getMessage ( ) ) ; } } return rowsDeleted == deleteBookingsList . size ( ) ; }
va	9	public void loadConfiguration ( BufferedReader bufor ) { try { while ( ( linia = bufor . readLine ( ) ) != null ) { linia . toUpperCase ( ) ; znak = linia . charAt ( 0 ) ; if ( znak != # && znak != '' ) { index = linia . indexOf ( "=" ) ; parametr = linia . substring ( 0 , index ) ; wartosc = linia . substring ( index + 1 ) ; switch ( parametr ) { case "DEFAULT_SCREEN_HEIGHT" : DEFAULT_SCREEN_HEIGHT = Integer . parseInt ( wartosc ) ; break ; case "DEFAULT_SCREEN_WIDTH" : DEFAULT_SCREEN_WIDTH = Integer . parseInt ( wartosc ) ; break ; case "DEFAULT_STARTLOCX" : DEFAULT_STARTLOCX = Integer . parseInt ( wartosc ) ; break ; case "DEFAULT_STARTLOCY" : DEFAULT_STARTLOCY = Integer . parseInt ( wartosc ) ; break ; case "BACKGROUND_COLOR1" : BACKGROUND_COLOR1 = Integer . parseInt ( wartosc ) ; break ; case "BACKGROUND_COLOR2" : BACKGROUND_COLOR2 = Integer . parseInt ( wartosc ) ; break ; case "BACKGROUND_COLOR3" : BACKGROUND_COLOR3 = Integer . parseInt ( wartosc ) ; break ; case "JUMP_SPEED" : JUMP_SPEED = Integer . parseInt ( wartosc ) ; break ; case "FALLING_SPEED" : FALLING_SPEED = Integer . parseInt ( wartosc ) ; break ; case "SPEED" : SPEED = Integer . parseInt ( wartosc ) ; break ; case "LIFE_NUMBER" : LIFE_NUMBER = Integer . parseInt ( wartosc ) ; break ; } } } } catch ( IOException e ) { System . out . println ( "B\u0142\u0105d odczytu z pliku." ) ; } }
va	7	@ Override public YamlPermissionBase get ( PermissionType type , String name ) throws DataLoadFailedException { switch ( type ) { case USER : return getUser ( name ) ; case GROUP : return getGroup ( name ) ; case WORLD : return getWorld ( name ) ; case ENTITY : return getEntity ( name ) ; case OP : return getOP ( ) ; case CONSOLE : return getConsole ( ) ; case RCON : return getRcon ( ) ; default : return null ; } }
va	9	@ Override public int compareTo ( URLEntity other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = boolean . valueOf ( isSetUrl ( ) ) . compareTo ( other . isSetUrl ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetUrl ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . url , other . url ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetDisplayUrl ( ) ) . compareTo ( other . isSetDisplayUrl ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetDisplayUrl ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . displayUrl , other . displayUrl ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetExpandedUrl ( ) ) . compareTo ( other . isSetExpandedUrl ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetExpandedUrl ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . expandedUrl , other . expandedUrl ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetAccessedUrl ( ) ) . compareTo ( other . isSetAccessedUrl ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetAccessedUrl ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . accessedUrl , other . accessedUrl ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
va	2	public void setValueContributionsOfActions ( MDPData m ) { for ( int i = 0 ; i < noOfStates ; i ++ ) { StateData state = stateList . get ( i ) ; StateData mState = m . getStateList ( ) . get ( i ) ; int numOfActionsInState = state . getNoOfActions ( ) ; ArrayList < ActionData > actionList = state . getActionList ( ) ; ArrayList < ActionData > mActionList = mState . getActionList ( ) ; for ( int j = 0 ; j < numOfActionsInState ; j ++ ) { ActionData action = actionList . get ( j ) ; action . setValueContri ( mActionList . get ( j ) . getValueContri ( ) ) ; actionList . set ( j , action ) ; } state . setActionList ( actionList ) ; state . setValue ( mState . getValue ( ) ) ; stateList . set ( i , state ) ; } }
va	3	@ Override public boolean doAction ( ActionType type , Entity e ) { if ( type == ActionType . MOVE && e instanceof EntityEnemy ) { EntityEnemy enemy = ( EntityEnemy ) e ; int damage = AIController . calculateAttackPower ( enemy , this ) ; logMessage ( "The " + enemy . getName ( ) + " hits you for " + damage + " damage" ) ; this . doDamage ( damage ) ; if ( isDead ( ) ) { logMessage ( "You are DEAD!!" ) ; } } return false ; }
va	7	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , int p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" + " " + p1 ) ; System . out . println ( "]" ) ; MiniatureDachshund obj ; int answer ; obj = new MiniatureDachshund ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . maxMikan ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	7	public Object [ ] [ ] bacaDaftar ( ) { boolean adaKesalahan = false ; Connection cn = null ; Object [ ] [ ] daftarPembeli = new Object [ 0 ] [ 0 ] ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = ( Connection ) DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke" + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select kode_buku judul_buku from buku" ; sta = ( Statement ) cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; daftarPembeli = new Object [ rset . getRow ( ) ] [ 2 ] ; if ( rset . getRow ( ) > 0 ) { rset . first ( ) ; int i = 0 ; do { daftarPembeli [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getString ( "judul_buku" ) } ; i ++ ; } while ( rset . next ( ) ) ; } sta . close ( ) ; rset . close ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( null , "Tidak dapat membuka tabel buku\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } return daftarPembeli ; }
va	1	@ Override public void mousePressed ( MouseEvent e ) { int x = e . getX ( ) ; int y = e . getY ( ) ; ChessPosition pos = convertToChessPos ( x , y ) ; if ( pos == null ) return ; selectChessListener . onSelect ( new SelectChessEvent ( pos ) ) ; }
va	3	@ SuppressWarnings ( "unchecked" ) public static < T > T getNativeRequest ( ServletRequest request , class < T > requiredType ) { if ( requiredType != null ) { if ( requiredType . isInstance ( request ) ) { return ( T ) request ; } else if ( request instanceof ServletRequestWrapper ) { return getNativeRequest ( ( ( ServletRequestWrapper ) request ) . getRequest ( ) , requiredType ) ; } } return null ; }
va	8	public static void main ( String [ ] args ) throws IOException { String sourcePath = null ; String outputPath = null ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] . startsWith ( "-" ) && ! args [ i ] . equals ( "-" ) ) { switch ( args [ i ] ) { case "-o" : case "--output" : i ++ ; outputPath = args [ i ] ; break ; default : throw new RuntimeException ( "wtf" ) ; } } else { if ( sourcePath != null ) throw new RuntimeException ( "too many source files" ) ; sourcePath = args [ i ] ; } } if ( sourcePath == null ) throw new RuntimeException ( "no source files" ) ; if ( outputPath == null ) outputPath = "-" ; compile ( sourcePath , outputPath ) ; }
va	1	private void optionallyClearStats ( ) { System . out . println ( "Would you like to clear these stats? (N/y) " ) ; boolean shouldClearStats = userInput . getYesNo ( ) ; if ( shouldClearStats ) { StatsState . getStatsState ( ) . clearStatistics ( ) ; } }
va	9	public void swap ( DoubleLinkedList list , int x , int y ) { if ( x < 0 || x >= list . size ( ) || y < 0 || y >= list . size ( ) ) { throw new IllegalArgumentException ( "list is null or empty" ) ; } if ( y < x ) { swap ( list , y , x ) ; return ; } DoubleLinkedList swapped = new DoubleLinkedList ( ) ; for ( int i = 0 ; i < x ; ++ i ) { swapped . add ( list . get ( i ) ) ; } swapped . add ( list . get ( y ) ) ; for ( int i = x + 1 ; i < y ; ++ i ) { swapped . add ( list . get ( i ) ) ; } swapped . add ( list . get ( x ) ) ; for ( int i = y + 1 ; i < list . size ( ) ; ++ i ) { swapped . add ( list . get ( i ) ) ; } for ( int i = 0 ; i < swapped . size ( ) ; ++ i ) { list . remove ( ) ; } for ( int i = 0 ; i < swapped . size ( ) ; ++ i ) { list . add ( swapped . get ( i ) ) ; } }
va	8	public int [ ] arrange ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 3 ) { for ( int j = i + 1 ; j < nums . length ; j ++ ) { if ( nums [ j ] == 4 ) { nums [ j ] = nums [ i + 1 ] ; nums [ i + 1 ] = 4 ; } } } if ( nums [ i ] == 4 && nums [ i - 1 ] != 3 ) { for ( int j = i + 1 ; j < nums . length - 1 ; j ++ ) { if ( nums [ j ] == 3 ) { nums [ j ] = nums [ i + 1 ] ; nums [ i + 1 ] = 4 ; } } } } return nums ; }
va	8	public static Pair < Integer , Integer > linearCongruenceSystem ( final int count , final List < Integer > aInList , final List < Integer > bInList , final List < Integer > nInList ) { positiveCheck ( count ) ; listCheck ( count , aInList ) ; listCheck ( count , bInList ) ; listCheck ( count , nInList ) ; final List < Integer > aList = new ArrayList < > ( aInList ) ; final List < Integer > bList = new ArrayList < > ( bInList ) ; final List < Integer > nList = new ArrayList < > ( nInList ) ; for ( int i = 0 ; i < count ; ++ i ) { final int ai = aList . get ( i ) ; final int bi = bList . get ( i ) ; final int ni = nList . get ( i ) ; positiveCheck ( ni ) ; aList . set ( i , normalizeIntModulo ( ai , ni ) ) ; bList . set ( i , normalizeIntModulo ( bi , ni ) ) ; } final Pair < Integer , Integer > solution = new Pair < > ( ) ; for ( int i = 0 ; i < count ; ++ i ) { final Pair < Integer , Integer > partial = linearCongruence ( aList . get ( i ) , bList . get ( i ) , nList . get ( i ) ) ; if ( partial . isEmpty ( ) ) return new Pair < > ( ) ; if ( partial . equals ( new Pair < > ( 0 , 1 ) ) ) { if ( ( solution . isEmpty ( ) ) && ( Utils . lastForCycle ( i , count ) ) ) return new Pair < > ( 0 , 1 ) ; continue ; } final int partialX = partial . getFirst ( ) ; final int partialM = partial . getSecond ( ) ; if ( solution . isEmpty ( ) ) { solution . setFirst ( partialX ) ; solution . setSecond ( partialM ) ; } else { solution . setFirst ( solution . getFirst ( ) + solution . getSecond ( ) * partialX ) ; solution . setSecond ( solution . getSecond ( ) * partialM ) ; } if ( ! Utils . lastForCycle ( i , count ) ) { bList . set ( i + 1 , bList . get ( i + 1 ) - ( aList . get ( i + 1 ) * solution . getFirst ( ) ) ) ; aList . set ( i + 1 , aList . get ( i + 1 ) * solution . getSecond ( ) ) ; } } return solution ; }
va	6	private void jMenuItem5ActionPerformed ( java . awt . event . ActionEvent evt ) { FileFilter filter = new FileFilter ( ) { @ Override public boolean accept ( File file ) { String ext ; String s = file . getName ( ) ; int i = s . lastIndexOf ( . ) ; if ( file . isDirectory ( ) ) { return true ; } if ( i > 0 && i < s . length ( ) - 1 ) { ext = s . substring ( i + 1 ) . toLowerCase ( ) ; if ( ext . equals ( "jjmap" ) ) return true ; } return false ; } @ Override public String getDescription ( ) { return new String ( "JumpingJack maps (.*jjmap)" ) ; } } ; JFileChooser saveFile = new JFileChooser ( "Podaj lokalizacje" ) ; saveFile . setSize ( 600 , 500 ) ; saveFile . setFileFilter ( filter ) ; if ( saveFile . showOpenDialog ( null ) == JFileChooser . APPROVE_OPTION ) { try { currentMapCreator . openMap ( saveFile . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Scr . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } jMenuItem2 . setEnabled ( true ) ; } }
va	3	public static boolean isPrimeNumber ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
va	3	public Instruction getFPAddrStallingInst ( ) { Instruction inst = null ; ListIterator < FPAdder > itr = fpAdderList . listIterator ( ) ; for ( ; itr . hasNext ( ) ; ) { FPAdder fpAdr = itr . next ( ) ; Instruction in = fpAdr . getReservingInst ( ) ; if ( in != null ) { if ( in . getState ( ) . equals ( State . WRITE_COMP ) ) { return fpAdr . getReservingInst ( ) ; } } } return inst ; }
va	0	public void invokeOperation ( ) { System . out . println ( "Blokuje numer.... " + this . number ) ; }
va	8	public static String getBasePath ( ) { String userName = System . getProperty ( "user.name" ) ; String s = System . getProperty ( "file.separator" ) ; String osName = System . getProperty ( "os.name" ) ; String basePath ; if ( osName . equalsIgnoreCase ( "windows 7" ) ) { basePath = "C:" + s + "Users" + s + userName + s ; } else if ( osName . equalsIgnoreCase ( "windows 8" ) ) { basePath = "C:" + s + "Users" + s + userName + s ; } else if ( osName . equalsIgnoreCase ( "windows vista" ) ) { basePath = "C:" + s + "Users" + s + userName + s ; } else if ( osName . equalsIgnoreCase ( "windows xp" ) ) { basePath = "C:" + s + "Documents and Settings" + s + userName + s + "My Documents" + s ; } else if ( osName . equalsIgnoreCase ( "linux" ) ) { basePath = s + "home" + s + "" + userName . toLowerCase ( ) + s ; } else if ( osName . equalsIgnoreCase ( "mac os" ) || osName . equalsIgnoreCase ( "mac os x" ) ) { basePath = s + "Users" + s + userName . toLowerCase ( ) + s ; } else if ( osName . equalsIgnoreCase ( "solaris" ) ) { basePath = s + "home" + s + "" + userName . toLowerCase ( ) + s ; } else { System . err . println ( "Unable to determine operating system." ) ; basePath = null ; } return basePath ; }
va	1	private void RequestNameFieldFocusGained ( java . awt . event . FocusEvent evt ) { if ( DBWorker . id == 0 ) { RequestNameField . setText ( "" ) ; } }
va	0	@ Override public String toString ( ) { return "RoleSetupInfo [config=" + config + "  getName()=" + getName ( ) + "  getType()=" + getType ( ) + "  isConfigStale()=" + isConfigStale ( ) + "  getHostRef()=" + getHostRef ( ) + "  getServiceRef()=" + getServiceRef ( ) + "  getRoleState()=" + getRoleState ( ) + "  getHealthSummary()=" + getHealthSummary ( ) + "  getHealthChecks()=" + getHealthChecks ( ) + "  getHaStatus()=" + getHaStatus ( ) + "  getRoleUrl()=" + getRoleUrl ( ) + "  toString()=" + super . toString ( ) + "  getClass()=" + getClass ( ) + "  hashCode()=" + hashCode ( ) + "]" ; }
va	7	private String getscoreMineralDifference ( HashMap < String , int [ ] > otherScoreMinerals ) { String a = "" ; int scoreDiff = 0 ; int mineralDiff = 0 ; if ( ! otherScoreMinerals . keySet ( ) . equals ( playerScoreMinerals . keySet ( ) ) ) { for ( String s : otherScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } } for ( String k : otherScoreMinerals . keySet ( ) ) { if ( ! otherScoreMinerals . get ( k ) . equals ( playerScoreMinerals . get ( k ) ) ) { scoreDiff = ( playerScoreMinerals . get ( k ) [ 0 ] - otherScoreMinerals . get ( k ) [ 0 ] ) ; mineralDiff = ( playerScoreMinerals . get ( k ) [ 0 ] - otherScoreMinerals . get ( k ) [ 0 ] ) ; if ( scoreDiff != 0 ) a = a . concat ( k + "+score:" + scoreDiff + "\n" ) ; if ( mineralDiff != 0 ) a = a . concat ( k + "+mineral:" + mineralDiff + "\n" ) ; } } return a ; }
va	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Parameter other = ( Parameter ) obj ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( value == null ) { if ( other . value != null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
va	3	public byte [ ] getUserSalt ( String userName ) throws UserNotFoundException , IOException { try { if ( connection == null ) connect ( ) ; String query = "SELECT salt FROM User WHERE userName = '" + userName + "';" ; Statement stmt = ( Statement ) connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( query ) ; if ( rs . next ( ) ) { byte [ ] salt = rs . getBytes ( "salt" ) ; return salt ; } else throw new UserNotFoundException ( userName ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; throw new IOException ( "Problem getting user salt from DB." ) ; } }
va	8	@ Override @ SuppressWarnings ( "unchecked" ) protected void load ( ) { if ( ! credentialFile . exists ( ) || password == null || salt == null ) { return ; } FileInputStream fis = null ; CipherInputStream cis = null ; ObjectInputStream ois = null ; try { byte [ ] ivBytes = new byte [ 16 ] ; fis = new FileInputStream ( credentialFile ) ; fis . read ( ivBytes ) ; IvParameterSpec iv = new IvParameterSpec ( ivBytes ) ; SecretKeyFactory factory = SecretKeyFactory . getInstance ( "PBKDF2WithHmacSHA1" ) ; KeySpec spec = new PBEKeySpec ( password , salt , 1024 , 128 ) ; SecretKey tmp = factory . generateSecret ( spec ) ; SecretKey secret = new SecretKeySpec ( tmp . getEncoded ( ) , "AES" ) ; Cipher cipher = Cipher . getInstance ( "AES/CBC/PKCS5Padding" ) ; cipher . init ( Cipher . DECRYPT_MODE , secret , iv ) ; cis = new CipherInputStream ( fis , cipher ) ; ois = new ObjectInputStream ( cis ) ; tokens = ( Map < String , OAuth2Token > ) ois . readObject ( ) ; } catch ( GeneralSecurityException | IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; } finally { try { if ( ois != null ) { ois . close ( ) ; } if ( cis != null ) { cis . close ( ) ; } if ( fis != null ) { fis . close ( ) ; } } catch ( IOException e ) { } } }
va	7	public void run ( ) { Scanner scn = new Scanner ( System . in ) ; int testCount = scn . nextInt ( ) ; for ( int testItem = 1 ; testItem <= testCount ; testItem ++ ) { int numVertices = scn . nextInt ( ) ; int numEdges = scn . nextInt ( ) ; adjacencyMatrix = new int [ numVertices ] [ numVertices ] ; for ( int i = 0 ; i < numVertices ; i ++ ) { for ( int j = 0 ; j < numVertices ; j ++ ) { adjacencyMatrix [ i ] [ j ] = 0 ; } } for ( int edge = 0 ; edge < numEdges ; edge ++ ) { int s = scn . nextInt ( ) ; int d = scn . nextInt ( ) ; int w = scn . nextInt ( ) ; adjacencyMatrix [ s ] [ d ] = w ; } AllPairsShortestPath ( adjacencyMatrix ) ; System . out . printf ( "%d\n" , testItem ) ; for ( int i = 0 ; i < numVertices ; i ++ ) { for ( int j = 0 ; j < numVertices ; j ++ ) { if ( pathWeights [ i ] [ j ] == Integer . MAX_VALUE ) { System . out . print ( "NP " ) ; } else { System . out . printf ( "%d " , pathWeights [ i ] [ j ] ) ; } } System . out . println ( ) ; } } }
va	2	public boolean preventsSleep ( ) { switch ( this ) { case INSOMNIA : case VITAL_SPIRT : return true ; default : return false ; } }
va	0	public int getEndX ( ) { return endX ; }
va	3	public static int getMaximumSubarraySum ( int [ ] array ) { int max = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { int sum = 0 ; for ( int j = i ; j < array . length ; j ++ ) { sum += array [ j ] ; if ( sum > max ) { max = sum ; } } } return max ; }
va	0	@ Test ( expected = IllegalArgumentException . class ) public void shouldNotContainDoubleColonsMoreThanOnce ( ) { Ipv6 . parse ( "2001:db8::aaaa::0:1" ) ; }
va	3	@ Override public void actionPerformed ( ActionEvent e ) { try { int amount = Integer . parseInt ( txfDeposit . getText ( ) ) ; boolean koll = actualAccount . deposit ( amount ) ; if ( koll == true ) { txfAccountBalance . setText ( "" + actualAccount . getBalance ( ) ) ; AccountDatabaseManager . updateAccountBalance ( actualAccount . getOwnerName ( ) , actualAccount . getBalance ( ) ) ; JOptionPane . showMessageDialog ( null , "Du satt in " + amount + "\nDitt saldo \u00E4r nu: " + actualAccount . getBalance ( ) ) ; } else { JOptionPane . showMessageDialog ( null , "G\u00F6r ett nytt f\u00F6rs\u00F6k " ) ; } } catch ( NumberFormatException nfe ) { JOptionPane . showMessageDialog ( null , "Du m\u00E5ste ange ett tal" ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( null , "N\u00E5got gick fel" ) ; } txfDeposit . setText ( "" ) ; }
va	3	@ Override public void act ( ) { int y = getY ( ) ; if ( moveTop ) { y = y - steps ; if ( y < MIN_Y ) { moveTop = false ; } } else { y = y + steps ; if ( y > MAX_Y ) { moveTop = true ; } } setLocation ( getX ( ) , y ) ; }
va	2	@ Override public void start ( @ NotNull TaskExecutor executor , int port ) { try { ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { System . out . println ( "Socket is waiting for request" ) ; Socket socket = serverSocket . accept ( ) ; Task task = new EncodeDecodeTask ( socket , Context . getMsgEncoder ( ) ) ; System . out . println ( "Socket is executing request" ) ; executor . execute ( task ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	0	public MarkDisplay ( Mark mark ) { this . mark = mark ; this . bounds = new Rectangle ( mark . getPosition ( ) . getX ( ) , mark . getPosition ( ) . getY ( ) , SIZE , SIZE ) ; this . setBounds ( bounds ) ; }
va	8	private void checkLocation ( WorldLocation l ) { if ( ! checkedLocations . contains ( l ) ) { if ( l . getTile ( ) . canItemAlgorithmPass ( ) ) { newLocations . add ( l ) ; if ( possibleItems . contains ( l ) ) { itemLocations . add ( l ) ; } } else if ( l . getMetadata ( ) instanceof TileMetadataDoor ) { if ( ! ( ( TileMetadataDoor ) l . getMetadata ( ) ) . isLocked ( ) || unlockedDoors . contains ( ( ( TileMetadataDoor ) l . getMetadata ( ) ) . getKeyId ( ) ) ) { newLocations . add ( l ) ; if ( possibleItems . contains ( l ) ) { itemLocations . add ( l ) ; } } else if ( door == null ) { door = l ; } } } checkedLocations . add ( l ) ; }
va	2	@ Override public String toString ( ) { String netlist = nets . size ( ) + " " + gates . size ( ) ; nets . values ( ) ; for ( Net net : ( new TreeMap < String , Net > ( nets ) ) . values ( ) ) { netlist = netlist + "\n" + net ; } for ( Gate gate : gates ) { netlist = netlist + "\n" + gate ; } return netlist ; }
va	5	public boolean cast ( Sorcerer sorcerer , Trigger trigger , Event event ) { PlayerInteractEvent interactEvent = ( PlayerInteractEvent ) event ; interactEvent . setCancelled ( true ) ; if ( trigger . isBlockTriggered ( ) ) { Location target = interactEvent . getClickedBlock ( ) . getLocation ( ) . add ( 0.5 , 1 , 0.5 ) ; target . setPitch ( sorcerer . getPlayer ( ) . getLocation ( ) . getPitch ( ) ) ; target . setYaw ( sorcerer . getPlayer ( ) . getLocation ( ) . getYaw ( ) ) ; int cost = getCost ( sorcerer . getPlayer ( ) . getLocation ( ) , target ) ; if ( cost > sorcerer . getMana ( ) ) { sorcerer . getPlayer ( ) . sendMessage ( ChatColor . RED + "You do not have enough mana to teleport there" ) ; return false ; } target . getWorld ( ) . playEffect ( sorcerer . getPlayer ( ) . getEyeLocation ( ) , Effect . ENDER_SIGNAL , 0 ) ; if ( cost >= 900 ) { Merlin . getInstance ( ) . shatterGlass ( sorcerer , cost ) ; } sorcerer . getPlayer ( ) . teleport ( target ) ; sorcerer . takeMana ( cost ) ; addExp ( sorcerer , cost / 10 ) ; sorcerer . getMagicks ( ) . addExp ( Type . TELEPORTATION , cost / 10 ) ; target . getWorld ( ) . playEffect ( sorcerer . getPlayer ( ) . getEyeLocation ( ) , Effect . ENDER_SIGNAL , 0 ) ; return true ; } else { Location target = sorcerer . getPlayer ( ) . getTargetBlock ( transparentBlocks , 150 ) . getLocation ( ) . add ( 0.5 , 1 , 0.5 ) ; target . setPitch ( sorcerer . getPlayer ( ) . getLocation ( ) . getPitch ( ) ) ; target . setYaw ( sorcerer . getPlayer ( ) . getLocation ( ) . getYaw ( ) ) ; int cost = getCost ( sorcerer . getPlayer ( ) . getLocation ( ) , target ) ; if ( cost > sorcerer . getMana ( ) ) { sorcerer . getPlayer ( ) . sendMessage ( ChatColor . RED + "You do not have enough mana to teleport there" ) ; return false ; } target . getWorld ( ) . playEffect ( sorcerer . getPlayer ( ) . getEyeLocation ( ) , Effect . ENDER_SIGNAL , 0 ) ; if ( cost >= 900 ) { Merlin . getInstance ( ) . shatterGlass ( sorcerer , cost ) ; } sorcerer . getPlayer ( ) . teleport ( target ) ; sorcerer . takeMana ( cost ) ; addExp ( sorcerer , cost / 10 ) ; target . getWorld ( ) . playEffect ( sorcerer . getPlayer ( ) . getEyeLocation ( ) , Effect . ENDER_SIGNAL , 0 ) ; return true ; } }
va	2	public Context execute ( ) throws Exception { for ( Insert insert : inserts ) { insert . execute ( ) ; } for ( Loop loop : loops ) { loop . execute ( ) ; } return this ; }
va	8	public String getContentType ( ) { if ( ! isFile ( ) ) { throw new IllegalStateException ( "not a file" ) ; } String contentType ; String extensions = file . getName ( ) ; int index = extensions . lastIndexOf ( "." ) ; if ( - 1 == index ) { contentType = OCTET ; } else { extensions = extensions . substring ( extensions . lastIndexOf ( "." ) + 1 ) . toLowerCase ( ) ; if ( extensions . length ( ) == 3 ) { if ( "gif" . equals ( extensions ) ) { contentType = GIF ; } else if ( "png" . equals ( extensions ) ) { contentType = PNG ; } else if ( "jpg" . equals ( extensions ) ) { contentType = JPEG ; } else { contentType = OCTET ; } } else if ( extensions . length ( ) == 4 ) { if ( "jpeg" . equals ( extensions ) ) { contentType = JPEG ; } else { contentType = OCTET ; } } else { contentType = OCTET ; } } return contentType ; }
va	7	public void setDim ( int dim ) throws ConnectException { int maxDim = dim ; for ( InputConnector ic : inputs ) { if ( ic . isConnected ( ) ) { if ( dim != 0 && ic . getSource ( ) . getDim ( ) != dim ) throw new ConnectException ( ic . getSource ( ) , dim ) ; if ( maxDim < ic . getDim ( ) ) maxDim = ic . getDim ( ) ; } } if ( output . getDim ( ) != maxDim ) { output . setDim ( maxDim ) ; for ( InputConnector ic : output . getConnected ( ) ) { ic . getParent ( ) . setDim ( maxDim ) ; } } }
va	4	public void printBoard ( Game game ) { int rowEnd = game . getBoard ( ) . numRows ; int colEnd = game . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int y = 0 ; y < rowEnd ; y ++ ) { System . out . print ( "{ " ) ; for ( int x = 0 ; x < colEnd ; x ++ ) { System . out . printf ( "%1d " , game . getBoard ( ) . getGameGrid ( ) [ x ] [ y ] . getState ( ) ) ; if ( ! ( x == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( y == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
va	9	public String writeState ( StringToInt startx , StringToInt starty ) { String data = "" ; data += reference . getName ( ) + "\n" ; for ( int i = 0 ; i < bytes . size ( ) ; i ++ ) data += bytes . get ( i ) . getKey ( ) + " " + bytes . get ( i ) . getValue ( ) + "\n" ; if ( startx != null ) { data += startx . getKey ( ) + " " + startx . getValue ( ) + "\n" ; data += starty . getKey ( ) + " " + starty . getValue ( ) + "\n" ; } for ( int i = 0 ; i < ints . size ( ) ; i ++ ) data += ints . get ( i ) . getKey ( ) + " " + ints . get ( i ) . getValue ( ) + "\n" ; for ( int i = 0 ; i < doubles . size ( ) ; i ++ ) data += doubles . get ( i ) . getKey ( ) + " " + doubles . get ( i ) . getValue ( ) + "\n" ; for ( int i = 0 ; i < booleans . size ( ) ; i ++ ) data += booleans . get ( i ) . getKey ( ) + " " + booleans . get ( i ) . getValue ( ) + "\n" ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) data += strings . get ( i ) . getKey ( ) + " " + strings . get ( i ) . getValue ( ) + "\n" ; for ( int i = 0 ; i < colors . size ( ) ; i ++ ) { } for ( int i = 0 ; i < images . size ( ) ; i ++ ) { } for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { } data += "End\n" ; return data ; }
va	7	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Order other = ( Order ) obj ; if ( this . orderNum != other . orderNum && ( this . orderNum == null || ! this . orderNum . equals ( other . orderNum ) ) ) { return false ; } if ( this . orderId != other . orderId ) { return false ; } if ( this . orderSum != other . orderSum ) { return false ; } return true ; }
va	6	@ Override public void run ( ) { DocumentBuilderFactory docBuilderFactory ; DocumentBuilder docBuilder ; try { docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; docBuilder . setErrorHandler ( new ErrorHandler ( ) { @ Override public void warning ( SAXParseException e ) throws SAXException { } @ Override public void fatalError ( SAXParseException e ) throws SAXException { } @ Override public void error ( SAXParseException e ) throws SAXException { } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } int BUFFER_SIZE = 1000000 ; StringBuffer bufferedInput = new StringBuffer ( ) ; char [ ] buffer = new char [ BUFFER_SIZE ] ; stop = false ; BufferedReader in = new BufferedReader ( new InputStreamReader ( parser . getInputStream ( ) ) ) ; try { while ( ! stop ) { int nReaded = in . read ( buffer , 0 , BUFFER_SIZE ) ; if ( nReaded != - 1 ) { bufferedInput . append ( buffer , 0 , nReaded ) ; boolean errorParsing = false ; try { String d = "<INDI>" + bufferedInput + "</INDI>" ; d = d . replaceAll ( "\\<\\?xml version='...'\\?\\>" , "" ) ; d = d . replaceAll ( "\\<\\?xml version=\"...\"\\?\\>" , "" ) ; Document doc = docBuilder . parse ( new InputSource ( new StringReader ( d ) ) ) ; parser . parseXML ( doc ) ; } catch ( SAXException e ) { errorParsing = true ; } if ( ! errorParsing ) { bufferedInput . setLength ( 0 ) ; } } else { stop = true ; } } } catch ( IOException e ) { } parser . finishReader ( ) ; }
va	0	public InputStream getAsciiStream ( int columnIndex ) throws SQLException { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
va	9	@ Override public int getCount ( String strTabla , ArrayList < FilterBean > alFilter ) throws Exception { int intResult = 0 ; Statement oStatement ; try { oStatement = ( Statement ) oConexionMySQL . createStatement ( ) ; String strSQL = "SELECT count(*) FROM " + strTabla + " WHERE 1=1" ; if ( alFilter != null ) { Iterator iterator = alFilter . iterator ( ) ; while ( iterator . hasNext ( ) ) { FilterBean oFilterBean = ( FilterBean ) iterator . next ( ) ; switch ( oFilterBean . getFilterOperator ( ) ) { case "like" : strSQL += " AND " + oFilterBean . getFilter ( ) + " LIKE '%" + oFilterBean . getFilterValue ( ) + "%'" ; break ; case "notlike" : strSQL += " AND " + oFilterBean . getFilter ( ) + " NOT LIKE '%" + oFilterBean . getFilterValue ( ) + "%'" ; break ; case "equals" : strSQL += " AND " + oFilterBean . getFilter ( ) + " = '" + oFilterBean . getFilterValue ( ) + "'" ; break ; case "notequalto" : strSQL += " AND " + oFilterBean . getFilter ( ) + " <> '" + oFilterBean . getFilterValue ( ) + "'" ; break ; case "less" : strSQL += " AND " + oFilterBean . getFilter ( ) + " < " + oFilterBean . getFilterValue ( ) + "" ; break ; case "lessorequal" : strSQL += " AND " + oFilterBean . getFilter ( ) + " <= " + oFilterBean . getFilterValue ( ) + "" ; break ; case "greater" : strSQL += " AND " + oFilterBean . getFilter ( ) + " > " + oFilterBean . getFilterValue ( ) + "" ; break ; case "greaterorequal" : strSQL += " AND " + oFilterBean . getFilter ( ) + " >= " + oFilterBean . getFilterValue ( ) + "" ; break ; } } } ResultSet oResultSet = oStatement . executeQuery ( strSQL ) ; while ( oResultSet . next ( ) ) { intResult = oResultSet . getInt ( "COUNT(*)" ) ; } return intResult ; } catch ( SQLException e ) { throw new Exception ( "mysql.getCount: Error en la consulta: " + e . getMessage ( ) ) ; } }
