te	3	public static void input ( ) { Scanner kbd = new Scanner ( System . in ) ; String input , file ; int population ; double growth ; ObjectOutputStream outputStream ; System . out . println ( "Enter file to write to:" ) ; file = kbd . next ( ) ; try { outputStream = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; System . out . println ( "Please enter a species to add or 'done' to finish" ) ; input = kbd . next ( ) ; while ( ! ( input . toLowerCase ( ) . equals ( "done" ) ) ) { System . out . println ( "Please enter a population for " + input ) ; population = kbd . nextInt ( ) ; System . out . println ( "Please enter growth rate for " + input ) ; growth = kbd . nextDouble ( ) ; outputStream . writeObject ( new Species ( input , population , growth ) ) ; System . out . println ( "Please enter a species to add or 'done' to finish" ) ; input = kbd . next ( ) ; } outputStream . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "The file not found." ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } }
te	0	public String toString ( ) { return "Case coloree" ; }
te	7	public void run ( ) { int gr , - , ss , i ; int granules = owner . granules ; Synthesis filter = owner . filter ; float [ ] xr ; try { while ( alive ) { synchronized ( this ) { while ( pause ) wait ( ) ; pause = true ; } for ( gr = 0 ; gr < granules ; gr ++ ) { xr = curXR [ gr ] ; for ( ss = 0 ; ss < 18 ; ss += 2 ) { for ( i = ss , - = 0 ; - < 32 ; - ++ , i += 18 ) samples [ - ] = xr [ i ] ; filter . synthesisSubBand ( samples , ch ) ; for ( i = ss + 1 , - = 0 ; - < 32 ; - += 2 , i += 36 ) { samples [ - ] = xr [ i ] ; samples [ - + 1 ] = - xr [ i + 18 ] ; } filter . synthesisSubBand ( samples , ch ) ; } } owner . submitSynthesis ( ) ; } } catch ( InterruptedException e ) { } }
te	2	public Report ( ) { try { String driverName = "com.mysql.jdbc.Driver" ; class . forName ( driverName ) ; String serverName = "127.0.0.1" ; String mydatabase = "dentist" ; String url = "jdbc:mysql://" + serverName + "/" + mydatabase ; String username = "scan" ; String password = "scan" ; conn = DriverManager . getConnection ( url , username , password ) ; } catch ( SQLException ex ) { Logger . getLogger ( PatientReports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( PatientReports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	1	public static Object invokeGetter ( Object messageObject , Method method ) throws Exception { try { return method . invoke ( messageObject , null ) ; } catch ( IllegalAccessException e ) { throw new Exception ( "Cannot access method" ) ; } }
te	1	@ Override public void execute ( ) { while ( condicao . getValor ( ) ) { faca . execute ( ) ; } }
te	9	public static byte [ ] decode ( String s , int options ) throws java . io . IOException { if ( s == null ) { throw new NullPointerException ( "Input string was null." ) ; } byte [ ] bytes ; try { bytes = s . getBytes ( PREFERRED_ENCODING ) ; } catch ( java . io . UnsupportedEncodingException uee ) { bytes = s . getBytes ( ) ; } bytes = decode ( bytes , 0 , bytes . length , options ) ; boolean dontGunzip = ( options & DONT_GUNZIP ) != 0 ; if ( ( bytes != null ) && ( bytes . length >= 4 ) && ( ! dontGunzip ) ) { int head = ( ( int ) bytes [ 0 ] & ff ) | ( ( bytes [ 1 ] << 8 ) & ff00 ) ; if ( java . util . zip . GZIPInputStream . GZIP_MAGIC == head ) { java . io . ByteArrayInputStream bais = null ; java . util . zip . GZIPInputStream gzis = null ; java . io . ByteArrayOutputStream baos = null ; byte [ ] buffer = new byte [ 2048 ] ; int length = 0 ; try { baos = new java . io . ByteArrayOutputStream ( ) ; bais = new java . io . ByteArrayInputStream ( bytes ) ; gzis = new java . util . zip . GZIPInputStream ( bais ) ; while ( ( length = gzis . read ( buffer ) ) >= 0 ) { baos . write ( buffer , 0 , length ) ; } bytes = baos . toByteArray ( ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } finally { try { baos . close ( ) ; } catch ( Exception e ) { } try { gzis . close ( ) ; } catch ( Exception e ) { } try { bais . close ( ) ; } catch ( Exception e ) { } } } } return bytes ; }
te	2	private void nioSeqWrite ( String fileName , int size ) throws IOException { delFile ( fileName ) ; FileChannel fc = new RandomAccessFile ( fileName , "rw" ) . getChannel ( ) ; long start = System . currentTimeMillis ( ) ; final ByteBuffer ib = fc . map ( FileChannel . MapMode . READ_WRITE , 0 , 1024 * 1024 * size ) ; byte buf [ ] = new byte [ 1024 ] ; int count = 0 ; int total = 1024 * size ; while ( count < total ) { ib . put ( buf ) ; count ++ ; } AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { @ SuppressWarnings ( "restriction" ) public Object run ( ) { try { Method getCleanerMethod = ib . getClass ( ) . getMethod ( "cleaner" , new class [ 0 ] ) ; getCleanerMethod . setAccessible ( true ) ; sun . misc . Cleaner cleaner = ( sun . misc . Cleaner ) getCleanerMethod . invoke ( ib , new Object [ 0 ] ) ; cleaner . clean ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } } ) ; fc . close ( ) ; logger . info ( "nio seq write file " + size + "M cost: " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; }
te	0	public void setId ( String id ) { this . id = id ; }
te	3	public static < T > T getKeyForMin ( Map < T , ? extends Number > c ) { double min = double . MAX_VALUE ; T minKey = null ; for ( T key : c . keySet ( ) ) { Number v = c . get ( key ) ; if ( v . doubleValue ( ) < min ) { min = v . doubleValue ( ) ; minKey = key ; } } return minKey ; }
te	6	public int [ ] [ ] getData ( int x , int y , int width , int height ) { int [ ] [ ] data = new int [ width ] [ height ] ; for ( int a = getNumRows ( ) ; a -- > 0 ; ) { for ( int b = getNumCols ( ) ; b -- > 0 ; ) { if ( a + x >= 0 && b + y >= 0 && a + x < getNumRows ( ) && b + y < getNumCols ( ) ) { data [ a ] [ b ] = this . data [ getIndex ( a + x , b + y ) ] ; } } } return data ; }
te	6	public static Object passValue ( Object val , PropertyDescriptor propertyDescriptor ) { if ( val == null ) { return null ; } if ( isStandardClass ( val . getClass ( ) ) ) { return val ; } else { if ( val instanceof Map ) return DBObjectMapProxy . create ( ( Map ) val , propertyDescriptor ) ; else if ( val instanceof Iterable ) { return DBObjectIterableProxy . create ( ( Iterable ) val , propertyDescriptor ) ; } else if ( val . getClass ( ) . isArray ( ) ) return DBObjectArrayProxy . create ( ( Object [ ] ) val ) ; else if ( val . getClass ( ) . isEnum ( ) ) return ( ( enum ) val ) . name ( ) ; } return DBObjectProxy . create ( val ) ; }
te	1	@ Override public String apply ( String target ) { if ( position < target . length ( ) ) { String firsthalf = target . substring ( 0 , position ) ; String secondhalf = target . substring ( position + 1 ) ; return firsthalf + secondhalf ; } else return target ; }
te	9	@ Override public void run ( ) { while ( read && lastMessage == null ) { lastMessage = messageReader . getLastMessage ( ) ; } while ( read ) { Message message = messageReader . getLastMessage ( ) ; if ( message != null ) { if ( message . getTime ( ) == lastMessage . getTime ( ) && System . currentTimeMillis ( ) - lastMessage . getTime ( ) > 10000 ) { lastMessageTimer = false ; } else if ( message . getTime ( ) == lastMessage . getTime ( ) && System . currentTimeMillis ( ) - lastMessage . getTime ( ) > 3000 ) { lastMessageTimer = false ; } else { lastMessage = message ; heartRate = lastMessage . getHr ( ) ; lastMessageTimer = true ; } try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UnitForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UnitForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UnitForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UnitForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { UnitForm dialog = new UnitForm ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	3	private static void printFit ( Map < String , Type [ ] > fit ) { if ( fit == null ) { System . out . println ( "null" ) ; } else { for ( String key : fit . keySet ( ) ) { System . out . println ( key ) ; for ( Type t : fit . get ( key ) ) { System . out . println ( "\t" + t . getId ( ) ) ; } } } }
te	9	private void preescritoFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyChar ( ) != S && evt . getKeyChar ( ) != I && evt . getKeyChar ( ) != N && evt . getKeyChar ( ) != O && evt . getKeyChar ( ) != s && evt . getKeyChar ( ) != i && evt . getKeyChar ( ) != n && evt . getKeyChar ( ) != o && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( preescritoField . getText ( ) . length ( ) == 2 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Preescrito solo acepta Si o No" , "ADVERTENCIA" , WIDTH ) ; } }
te	7	public String generateQueryFromOWL ( ) { double priceLowerFilter = 0 ; double priceUpperFilter = Integer . MAX_VALUE ; String os = scenario . getOperatingSystemName ( ) ; String osFilter = "" ; String category = "Notebook" ; String typeFilter = "" ; String performance = scenario . getPerformance ( ) ; String performanceFilter = "" ; int diskSize = 0 ; String diskSizeFilter = "" ; if ( ! performance . isEmpty ( ) ) performanceFilter = " AND Kategorie LIKE \"%" + performance + "%\"" ; if ( ! os . isEmpty ( ) ) osFilter = " AND betriebssystem LIKE '%" + os + "%'" ; System . out . println ( category ) ; String [ ] diskSizeDefinition = OntologyRequest . getDiskSize ( scenario . getDiskSizeType ( ) ) ; diskSize = Integer . valueOf ( diskSizeDefinition [ 2 ] ) ; if ( diskSizeDefinition [ 1 ] . equals ( "minInclusive" ) ) { diskSizeFilter = " AND festplattengroesse >= " ; } else if ( diskSizeDefinition [ 1 ] . equals ( "maxInclusive" ) ) { diskSizeFilter = " AND festplattengroesse <= " ; } else if ( diskSizeDefinition [ 1 ] . equals ( "minExclusive" ) ) { diskSizeFilter = " AND festplattengroesse >= " ; } else if ( diskSizeDefinition [ 1 ] . equals ( "maxExclusive" ) ) { diskSizeFilter = " AND festplattengroesse <= " ; } diskSizeFilter += diskSize ; if ( scenario . getIsFastBootSSDRequested ( ) ) typeFilter = " AND (festplattentyp LIKE 'SSD' OR festplattentyp LIKE 'SSHD')" ; String [ ] bereich = OntologyRequest . getBudgetForCategory ( scenario . getBudgetOntologie ( ) , category ) ; category = category . toLowerCase ( ) ; priceLowerFilter = double . valueOf ( bereich [ 2 ] ) ; priceUpperFilter = double . valueOf ( bereich [ 4 ] ) ; String query = "SELECT * FROM " + category + " WHERE preis >= " + priceLowerFilter + " AND preis <= " + priceUpperFilter + osFilter + typeFilter + performanceFilter + diskSizeFilter ; return query ; }
te	9	public ListNode detectCycle ( ListNode head ) { if ( head == null || head . next == null ) { return null ; } ListNode slow = head ; ListNode fast = head ; while ( slow != null && fast != null ) { slow = slow . next ; fast = fast . next ; if ( fast != null ) { fast = fast . next ; } if ( slow == fast ) { break ; } } if ( slow == null || fast == null ) { return null ; } slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; }
te	1	protected String getCellAsString ( int col , int row ) { return getCell ( col , row ) ? "#" : "_" ; }
te	9	@ Override public void run ( ) { while ( true ) { try { OtherEndMessage mess = messages . pop ( ) ; if ( mess . message . startsWith ( ELobby . ADD_CLIENT . toString ( ) ) ) add ( ( Client ) mess . client ) ; else if ( mess . message . startsWith ( ELobby . REMOVE_CLIENT . toString ( ) ) ) remove ( ( Client ) mess . client ) ; else if ( mess . message . startsWith ( ELobby . CLIENT_NAME . toString ( ) ) ) mess . client . name = mess . message . substring ( ELobby . CLIENT_NAME . toString ( ) . length ( ) ) ; else if ( mess . message . startsWith ( ELobby . REQUEST_CLIENT_LIST . toString ( ) ) ) requestClientList ( ( Client ) mess . client ) ; else if ( mess . message . startsWith ( ELobby . REQUEST_SESSION_LIST . toString ( ) ) ) requestSessionList ( ( Client ) mess . client ) ; else if ( mess . message . startsWith ( ELobby . CREATE_SESSION . toString ( ) ) ) requestCreateGame ( ( Client ) mess . client ) ; else if ( mess . message . startsWith ( ELobby . CONNECT_TO_GAME . toString ( ) ) ) requestJoinGame ( ( Client ) mess . client , mess . message . substring ( ELobby . CONNECT_TO_GAME . toString ( ) . length ( ) ) ) ; } catch ( InterruptedException e ) { break ; } } for ( GameSessionHandler g : sessions ) g . interrupt ( ) ; try { for ( GameSessionHandler g : sessions ) g . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return ; } sessions . clear ( ) ; }
te	9	@ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { if ( response . isCommitted ( ) ) { return ; } String uri = request . getRequestURI ( ) ; String context = request . getContextPath ( ) ; if ( uri . endsWith ( "/favicon.ico" ) ) { uri = "/favicon.ico" ; } else if ( context != null && ! "/" . equals ( context ) ) { uri = uri . substring ( context . length ( ) ) ; } if ( ! uri . startsWith ( "/" ) ) { uri = "/" + uri ; } File file = new File ( rootDirectory , uri ) ; if ( ! file . exists ( ) ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } long lastModified = file . exists ( ) ? file . lastModified ( ) : start ; long since = request . getDateHeader ( "If-Modified-Since" ) ; if ( since >= lastModified ) { response . sendError ( HttpServletResponse . SC_NOT_MODIFIED ) ; return ; } byte [ ] data ; InputStream input = new FileInputStream ( file ) ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8192 ] ; int n = 0 ; while ( - 1 != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; } data = output . toByteArray ( ) ; } finally { input . close ( ) ; } response . setDateHeader ( "Last-Modified" , lastModified ) ; OutputStream output = response . getOutputStream ( ) ; output . write ( data ) ; output . flush ( ) ; }
te	2	public List < V > listValues ( ) { List < V > list = new ArrayList < V > ( ) ; if ( this . left != null ) { list . addAll ( this . left . listValues ( ) ) ; } list . add ( getValue ( ) ) ; if ( this . right != null ) { list . addAll ( this . right . listValues ( ) ) ; } return list ; }
te	1	public static final int bitsInBytes ( int numBits ) { if ( numBits < 0 ) throw new IllegalArgumentException ( "numBits < 0" ) ; return ( int ) ( ( numBits + ( byte . SIZE - 1 ) ) / byte . SIZE ) ; }
te	3	public final void svd ( double scale [ ] ) { for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) svdSrc [ 3 * i + j ] = get ( i , j ) ; if ( svdMath == null ) svdMath = new SVD ( ) ; svdMath . compute ( svdSrc , scale , svdRot ) ; }
te	1	@ Override public void decode ( ByteList messageBytes ) throws Exception { short objectType = messageBytes . getShort ( ) ; if ( objectType != this . getClassID ( ) ) { throw new Exception ( "Invalid byte array for Request message" ) ; } short objectLength = messageBytes . getShort ( ) ; messageBytes . setNewReadLimit ( objectLength ) ; super . decode ( messageBytes ) ; this . setPlayerID ( messageBytes . getInt ( ) ) ; messageBytes . restorePreviousReadLimit ( ) ; }
te	1	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx >= 0 ) delItem ( idx ) ; }
te	0	public Object [ ] Array ( ) { Object [ ] Array = { this . TID , this . customer_CID , this . employee_EID , this . CategoryID , this . StatusID , this . Topic , this . Problem , this . Note , this . Solution , this . created_on , this . last_update } ; return Array ; }
te	5	public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == # ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ; ) { break ; } else { throw syntaxError ( "Missing ';' in XML entity: &" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; }
te	3	private static String formatEdgeLabel ( String label ) { if ( label == null ) return "" ; StringBuilder builder = new StringBuilder ( ) ; for ( String element : label . split ( ";" ) ) { if ( builder . length ( ) > 0 ) builder . append ( "\\n" ) ; builder . append ( ensureTextIsValid ( element ) ) ; } return builder . toString ( ) ; }
te	1	@ Override public void setFont ( Font font , int row , int column ) { if ( isOutOfBounds ( row , column ) ) { return ; } this . font [ row ] [ column ] = font ; }
te	7	public static List < String > getExistingDirs ( List < String > dirs , int timeout ) { List < String > existentDirs = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; if ( dirs . isEmpty ( ) ) { return existentDirs ; } ExecutorService es = Executors . newFixedThreadPool ( dirs . size ( ) , new DaemonThreadFactory ( ) ) ; List < Callable < String >> threads = new ArrayList < > ( dirs . size ( ) ) ; for ( String curDir : dirs ) { threads . add ( new DirectoryExistsThread ( curDir ) ) ; } try { List < Future < String >> futures = ( timeout <= 0 ) ? es . invokeAll ( threads ) : es . invokeAll ( threads , timeout , TimeUnit . MILLISECONDS ) ; for ( Future < String > future : futures ) { if ( ! future . isCancelled ( ) && future . get ( ) != null ) { existentDirs . add ( future . get ( ) ) ; } } } catch ( InterruptedException | ExecutionException ex ) { } finally { es . shutdownNow ( ) ; } return existentDirs ; }
te	0	public int getRight ( ) { return Dispatch . get ( this , "Right" ) . changeType ( Variant . VariantInt ) . getInt ( ) ; }
te	7	public void solve ( char [ ] [ ] board ) { int x = board . length ; if ( x == 0 ) return ; int y = board [ 0 ] . length ; if ( x == 1 && y == 1 ) return ; boolean [ ] [ ] visited = new boolean [ x ] [ y ] ; for ( int i = 0 ; i < x ; i ++ ) { for ( int j = 0 ; j < y ; j ++ ) { if ( board [ i ] [ j ] == O ) { clearvisited ( visited ) ; if ( check ( board , i , j , visited ) ) { fill ( board , i , j ) ; } } } } }
te	7	public final JPoclASTParser . parameters_return parameters ( ) throws RecognitionException { JPoclASTParser . parameters_return retval = new JPoclASTParser . parameters_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token char_literal113 = null ; JPoclASTParser . bexpr0_return bexpr0112 = null ; JPoclASTParser . bexpr0_return bexpr0114 = null ; TypeTree char_literal113_tree = null ; RewriteRuleTokenStream stream_28 = new RewriteRuleTokenStream ( adaptor , "token 28" ) ; RewriteRuleSubtreeStream stream_bexpr0 = new RewriteRuleSubtreeStream ( adaptor , "rule bexpr0" ) ; try { { pushFollow ( FOLLOW_bexpr0_in_parameters1150 ) ; bexpr0112 = bexpr0 ( ) ; state . _fsp -- ; stream_bexpr0 . add ( bexpr0112 . getTree ( ) ) ; loop26 : do { int alt26 = 2 ; int LA26_0 = input . LA ( 1 ) ; if ( ( LA26_0 == 28 ) ) { alt26 = 1 ; } switch ( alt26 ) { case 1 : { char_literal113 = ( Token ) match ( input , 28 , FOLLOW_28_in_parameters1153 ) ; stream_28 . add ( char_literal113 ) ; pushFollow ( FOLLOW_bexpr0_in_parameters1155 ) ; bexpr0114 = bexpr0 ( ) ; state . _fsp -- ; stream_bexpr0 . add ( bexpr0114 . getTree ( ) ) ; } break ; default : break loop26 ; } } while ( true ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { if ( ! ( stream_bexpr0 . hasNext ( ) ) ) { throw new RewriteEarlyExitException ( ) ; } while ( stream_bexpr0 . hasNext ( ) ) { adaptor . addChild ( root_0 , stream_bexpr0 . nextTree ( ) ) ; } stream_bexpr0 . reset ( ) ; } retval . tree = root_0 ; } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
te	8	public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( "VALUE(" ) . append ( value ) . append ( ")" ) ; break ; case TYPE_LEFT_BRACE : sb . append ( "LEFT BRACE({)" ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( "RIGHT BRACE(})" ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( "LEFT SQUARE([)" ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( "RIGHT SQUARE(])" ) ; break ; case TYPE_COMMA : sb . append ( "COMMA( )" ) ; break ; case TYPE_COLON : sb . append ( "COLON(:)" ) ; break ; case TYPE_EOF : sb . append ( "END OF FILE" ) ; break ; } return sb . toString ( ) ; }
te	3	@ Override public OrderStatus getById ( long orderStatusId ) { Session session = null ; OrderStatus orderStatus = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; orderStatus = ( OrderStatus ) session . getNamedQuery ( "orderStatus.getById" ) . setParameter ( "id" , orderStatusId ) . uniqueResult ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return orderStatus ; }
te	6	public void put ( SortedArray elem ) { int [ ] idxes = new int [ elem . size ] ; int oldsize = size ; int newsize = size ; for ( int i = elem . size - 1 ; i >= 0 ; i -- ) { int idx = get ( elem . keys [ i ] ) ; if ( idx >= 0 ) { keys [ idx ] = elem . keys [ i ] ; values [ idx ] = elem . values [ i ] ; size = idx ; } else { size = - 1 - idx ; newsize ++ ; } idxes [ i ] = - 1 - idx ; } if ( newsize > capacity ) grow ( newsize - oldsize ) ; int oldi = oldsize - 1 ; int newi = newsize - 1 ; for ( int i = elem . size - 1 ; i >= 0 ; i -- ) { if ( idxes [ i ] < 0 ) continue ; while ( oldi >= idxes [ i ] ) { keys [ newi ] = keys [ oldi ] ; values [ newi -- ] = values [ oldi -- ] ; } keys [ newi ] = elem . keys [ i ] ; values [ newi -- ] = elem . values [ i ] ; } size = newsize ; }
te	7	public void setGender ( String gender ) { String g = stripNonAlpha ( gender ) ; if ( "m" . equals ( g ) ) { this . gender = "masc" ; } else if ( "f" . equals ( g ) ) { this . gender = "fem" ; } else if ( "n" . equals ( g ) ) { this . gender = "neut" ; } else if ( gender . equals ( "masc" ) || gender . equals ( "fem" ) || gender . equals ( "neut" ) ) { this . gender = gender ; } else if ( gender . isEmpty ( ) ) { this . gender = "" ; } else { throw new IllegalArgumentException ( "Unknown gender: " + g ) ; } setPos ( NOUN ) ; }
te	3	public static UnregisterRequest Create ( ByteList messageBytes ) throws Exception { UnregisterRequest result ; if ( messageBytes == null || messageBytes . getLength ( ) < 6 ) { throw new Exception ( "Invalid message byte array" ) ; } if ( messageBytes . peekShort ( ) != UnregisterRequest . getClassID ( ) ) { throw new Exception ( "Invalid message type" ) ; } else { result = new UnregisterRequest ( ) ; result . decode ( messageBytes ) ; } return result ; }
te	7	public KitsuneView ( SingleFrameApplication app ) { super ( app ) ; initComponents ( ) ; ResourceMap resourceMap = getResourceMap ( ) ; int messageTimeout = resourceMap . getInteger ( "StatusBar.messageTimeout" ) ; messageTimer = new Timer ( messageTimeout , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { statusMessageLabel . setText ( "" ) ; } } ) ; messageTimer . setRepeats ( false ) ; int busyAnimationRate = resourceMap . getInteger ( "StatusBar.busyAnimationRate" ) ; for ( int i = 0 ; i < busyIcons . length ; i ++ ) { busyIcons [ i ] = resourceMap . getIcon ( "StatusBar.busyIcons[" + i + "]" ) ; } busyIconTimer = new Timer ( busyAnimationRate , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { busyIconIndex = ( busyIconIndex + 1 ) % busyIcons . length ; statusAnimationLabel . setIcon ( busyIcons [ busyIconIndex ] ) ; } } ) ; idleIcon = resourceMap . getIcon ( "StatusBar.idleIcon" ) ; statusAnimationLabel . setIcon ( idleIcon ) ; progressBar . setVisible ( false ) ; TaskMonitor taskMonitor = new TaskMonitor ( getApplication ( ) . getContext ( ) ) ; taskMonitor . addPropertyChangeListener ( new java . beans . PropertyChangeListener ( ) { public void propertyChange ( java . beans . PropertyChangeEvent evt ) { String propertyName = evt . getPropertyName ( ) ; if ( "started" . equals ( propertyName ) ) { if ( ! busyIconTimer . isRunning ( ) ) { statusAnimationLabel . setIcon ( busyIcons [ 0 ] ) ; busyIconIndex = 0 ; busyIconTimer . start ( ) ; } progressBar . setVisible ( true ) ; progressBar . setIndeterminate ( true ) ; } else if ( "done" . equals ( propertyName ) ) { busyIconTimer . stop ( ) ; statusAnimationLabel . setIcon ( idleIcon ) ; progressBar . setVisible ( false ) ; progressBar . setValue ( 0 ) ; } else if ( "message" . equals ( propertyName ) ) { String text = ( String ) ( evt . getNewValue ( ) ) ; statusMessageLabel . setText ( ( text == null ) ? "" : text ) ; messageTimer . restart ( ) ; } else if ( "progress" . equals ( propertyName ) ) { int value = ( Integer ) ( evt . getNewValue ( ) ) ; progressBar . setVisible ( true ) ; progressBar . setIndeterminate ( false ) ; progressBar . setValue ( value ) ; } } } ) ; inspectorUpdaterTimer = new Timer ( 100 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Date now = new Date ( ) ; simRunTime += now . getTime ( ) - lastSimCheck ; lastSimCheck = now . getTime ( ) ; updateInspector ( ) ; inspectorUpdateSimRuntime ( ) ; } } ) ; simUpdaterTimer = new Timer ( 100 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { simulationUpdate ( ) ; } } ) ; this . loadedEnvironment = new Environment ( ) ; }
te	2	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
te	4	public static void output ( ) { for ( int [ ] position : alphabetized_index ) { char [ ] line = characters . get ( position [ LINE ] ) ; System . out . print ( new String ( line ) . substring ( position [ char ] ) ) ; List < String > words = new ArrayList < String > ( ) ; String buf = "" ; for ( int i = 0 ; i < position [ char ] ; i ++ ) { if ( line [ i ] ==   ) { words . add ( buf ) ; buf = "" ; } else { buf += line [ i ] ; } } for ( String s : words ) { System . out . printf ( " %s" , s ) ; } System . out . printf ( "\n" ) ; } }
te	3	@ Override public double getEquity ( HandRange range1 , HandRange range2 ) { List < Integer > values2 = range2 . getValues ( ) ; List < Integer > values1 = range1 . getValues ( ) ; int index = 0 ; int increment1 = values1 . size ( ) / INCREMENT_COUNT ; int increment2 = values1 . size ( ) / INCREMENT_COUNT ; double beatenValues = 0 ; for ( int i = 0 ; i < INCREMENT_COUNT ; i ++ ) { while ( index < INCREMENT_COUNT && values1 . get ( increment1 * i ) > values2 . get ( index * increment2 ) ) { index ++ ; } beatenValues += index ; } double averageBeatenValues = beatenValues / INCREMENT_COUNT ; double percentage = averageBeatenValues / INCREMENT_COUNT ; return percentage ; }
te	4	private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; }
te	7	public boolean isOnPF ( int marginx , int marginy ) { if ( ! getTileBBox ( temp_bbox_copy ) ) { temp_bbox_copy . x = ( int ) x ; temp_bbox_copy . y = ( int ) y ; temp_bbox_copy . width = 0 ; temp_bbox_copy . height = 0 ; } if ( ! pfwrapx ) { if ( temp_bbox_copy . x + temp_bbox_copy . width < - marginx ) return false ; if ( temp_bbox_copy . x > pfwidth + marginx ) return false ; } if ( ! pfwrapy ) { if ( temp_bbox_copy . y + temp_bbox_copy . height < - marginy ) return false ; if ( temp_bbox_copy . y > pfheight + marginy ) return false ; } return true ; }
te	3	@ Override public < T > T accept ( ParseTreeVisitor < ? extends T > visitor ) { if ( visitor instanceof DecafParserVisitor ) return ( ( DecafParserVisitor < ? extends T > ) visitor ) . visitExpr_MultiDiv ( this ) ; else return visitor . visitChildren ( this ) ; }
te	0	public PokeStats ( int level , Nature nature , int [ ] baseStats , int [ ] ivs , int [ ] evs ) { this . nature = nature ; this . baseStats = baseStats ; this . level = level ; hpIv = ivs [ MAX_HP ] ; atkIv = ivs [ ATK ] ; defIv = ivs [ DEF ] ; spAtkIv = ivs [ SPATK ] ; spDefIv = ivs [ SPDEF ] ; speIv = ivs [ SPE ] ; hpEv = evs [ MAX_HP ] ; atkEv = evs [ ATK ] ; defEv = evs [ DEF ] ; spAtkEv = evs [ SPATK ] ; spDefEv = evs [ SPDEF ] ; speEv = evs [ SPE ] ; int [ ] stats = PokemonMath . calcPokemon ( level , nature , baseStats , ivs , evs ) ; reCalcStats ( ) ; maxHp = stats [ MAX_HP ] ; currHp = maxHp ; atk = stats [ ATK ] ; def = stats [ DEF ] ; spAtk = stats [ SPATK ] ; spDef = stats [ SPDEF ] ; spe = stats [ SPE ] ; }
te	5	private void Comparar ( ) { String Usuario = txtUsuario . getText ( ) ; if ( txtClave . getText ( ) . equals ( String . valueOf ( jPContrasena . getPassword ( ) ) ) ) { JOptionPane . showMessageDialog ( this , "BIENVENIDO " + Usuario ) ; iniciarCarga ( ) ; iniciarSplash ( ) ; if ( Progreso . getValue ( ) == 100 ) { JOptionPane . showMessageDialog ( null , "Est\u00E1 accediendo al Men\u00FA Principal" ) ; if ( txtTipEm . getText ( ) . equals ( "Administrador" ) ) { InterfazAdministrador IrAdmin = new InterfazAdministrador ( ) ; IrAdmin . setVisible ( true ) ; dispose ( ) ; } else if ( txtTipEm . getText ( ) . equals ( "Tecnico" ) ) { InterfazTecnico Tecnico = new InterfazTecnico ( ) ; Tecnico . setVisible ( true ) ; dispose ( ) ; } else if ( txtTipEm . getText ( ) . equals ( "Vendedor" ) ) { InterfazVendedor Vendedor = new InterfazVendedor ( ) ; Vendedor . setVisible ( true ) ; dispose ( ) ; } } } else { JOptionPane . showMessageDialog ( this , "Usuario o Contase\u00F1a Incorrecta" , "Error" , JOptionPane . ERROR_MESSAGE ) ; txtUsuario . requestFocus ( ) ; } }
te	6	private void txtApellidoKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ( evt . getKeyChar ( ) < a || evt . getKeyChar ( ) > z ) && ( evt . getKeyChar ( ) < A || evt . getKeyChar ( ) > Z ) && ( evt . getKeyChar ( ) != KeyEvent . VK_SPACE ) ) { evt . consume ( ) ; } else { if ( txtApellido . getText ( ) . trim ( ) . length ( ) > 19 ) { evt . consume ( ) ; } } }
te	8	public boolean isInterleave2 ( String s1 , String s2 , String s3 ) { int len1 = s1 . length ( ) ; int len2 = s2 . length ( ) ; int len3 = s3 . length ( ) ; if ( len1 + len2 != len3 ) return false ; boolean [ ] dp = new boolean [ len2 + 1 ] ; dp [ 0 ] = true ; for ( int i = 1 ; i <= len2 ; i ++ ) { dp [ i ] = s2 . substring ( 0 , i ) . equals ( s3 . substring ( 0 , i ) ) ; } for ( int i = 1 ; i <= len1 ; i ++ ) { dp [ 0 ] = s1 . substring ( 0 , i ) . equals ( s3 . substring ( 0 , i ) ) ; for ( int j = 1 ; j <= len2 ; j ++ ) { if ( dp [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ) ) { dp [ j ] = true ; } else if ( dp [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) ) { dp [ j ] = true ; } else dp [ j ] = false ; } } return dp [ len2 ] ; }
te	0	@ Override public void reset ( ) { readingState = false ; this . currentFrame = null ; }
te	7	public int search ( int [ ] A , int target ) { int begin = 0 ; int end = A . length - 1 ; while ( begin <= end ) { int mid = begin + ( end - begin ) / 2 ; if ( A [ mid ] == target ) { return mid ; } if ( A [ begin ] <= A [ mid ] ) { if ( A [ begin ] <= target && target <= A [ mid ] ) { end = mid - 1 ; } else { begin = mid + 1 ; } } else { if ( A [ mid ] <= target && target <= A [ end ] ) { begin = mid + 1 ; } else { end = mid - 1 ; } } } return - 1 ; }
te	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Update" ; kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . targetHref != null ) { kml += "<targetHref>" + SpecialCaseFormatter . toKMLString ( this . targetHref ) + "</targetHref>\n" ; } if ( this . create != null ) { kml += this . create . toKML ( ) ; } if ( this . delete != null ) { kml += this . delete . toKML ( ) ; } for ( Iterator iter = this . change . iterator ( ) ; iter . hasNext ( ) ; ) { Change cur = ( Change ) iter . next ( ) ; kml += cur . toKML ( ) ; } if ( this . replace != null ) { kml += this . replace . toKML ( ) ; } if ( ! suppressEnclosingTags ) { kml += "</Update>\n" ; } return kml ; }
te	6	void limit ( ) { this . red = ( this . red > 0.0 ) ? ( ( this . red > 1.0 ) ? 1.0 : this . red ) : 0.0 ; this . green = ( this . green > 0.0 ) ? ( ( this . green > 1.0 ) ? 1.0 : this . green ) : 0.0 ; this . blue = ( this . blue > 0.0 ) ? ( ( this . blue > 1.0 ) ? 1.0 : this . blue ) : 0.0 ; }
te	1	@ Override public void handleTrickCardPlayed ( Trick trick , Player player , Card card ) { for ( GameHandler gh : gameHandlers ) { gh . handleTrickCardPlayed ( trick , player , card ) ; } }
te	6	public static Map < String , String > parseHashMap ( String mapDescriptionStr , String seprator ) { if ( isStringNullOrWhiteSpace ( mapDescriptionStr ) || mapDescriptionStr . length ( ) < 2 ) return null ; mapDescriptionStr = mapDescriptionStr . substring ( 1 , mapDescriptionStr . length ( ) - 1 ) ; if ( isStringNullOrWhiteSpace ( mapDescriptionStr ) ) return new LinkedHashMap < String , String > ( ) ; String [ ] kvs = mapDescriptionStr . split ( seprator ) ; Map < String , String > map = null ; for ( String kv : kvs ) { if ( map == null ) map = new LinkedHashMap < String , String > ( ) ; String [ ] split = kv . split ( "=" ) ; if ( split . length == 1 ) map . put ( split [ 0 ] , "" ) ; else map . put ( split [ 0 ] , split [ 1 ] ) ; } return map ; }
te	8	private static void expect ( DataInputStream stream , String str , boolean whole , boolean ignoreCase ) throws IOException { if ( ignoreCase && ! whole ) { str = str . toLowerCase ( ) ; } while ( true ) { String line = stream . readLine ( ) ; if ( line == null ) { throw new EOFException ( ) ; } if ( whole ? ( ignoreCase ? line . equalsIgnoreCase ( str ) : line . equals ( str ) ) : ( ( ignoreCase ? line . toLowerCase ( ) : line ) . indexOf ( str ) >= 0 ) ) { return ; } } }
te	9	@ Override public void onApplicationStartup ( ) { CoreEvents . registerProjectChangeListener ( new ProjectChangesListener ( sessionlog ) ) ; CoreEvents . registerEntryEventListener ( new SegmentChangedListener ( sessionlog ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { Field editUndoMenuItemField ; Field editRedoMenuItemField ; try { editUndoMenuItemField = MainWindowMenu . class . getDeclaredField ( "editUndoMenuItem" ) ; editRedoMenuItemField = MainWindowMenu . class . getDeclaredField ( "editRedoMenuItem" ) ; editUndoMenuItemField . setAccessible ( true ) ; editRedoMenuItemField . setAccessible ( true ) ; try { JMenuItem editUndoMenuItem ; JMenuItem editRedoMenuItem ; MainWindowMenu mmenu = ( MainWindowMenu ) ( ( MainWindow ) Core . getMainWindow ( ) ) . getMainMenu ( ) ; editUndoMenuItem = ( JMenuItem ) editUndoMenuItemField . get ( mmenu ) ; editRedoMenuItem = ( JMenuItem ) editRedoMenuItemField . get ( mmenu ) ; editUndoMenuItem . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { sessionlog . GetLog ( ) . Undo ( ) ; } } ) ; editRedoMenuItem . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { sessionlog . GetLog ( ) . Redo ( ) ; } } ) ; } catch ( IllegalAccessException iae ) { iae . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } catch ( NoSuchFieldException nsfe ) { nsfe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } Core . getGlossary ( ) . addMouseListener ( new PopupListener ( Core . getGlossary ( ) ) ) ; MatchesTextArea matcher = ( MatchesTextArea ) Core . getMatcher ( ) ; matcher . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent e ) { int activeMatch = IntrospectionTools . getActiveMatchIndex ( ) ; if ( sessionlog . GetLog ( ) . getCurrentTMProposals ( ) != activeMatch + 1 ) { sessionlog . GetLog ( ) . setCurrentTMProposals ( activeMatch + 1 ) ; } } @ Override public void insertUpdate ( DocumentEvent e ) { try { if ( ! e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyTMProposals ( false ) ; } catch ( BadLocationException ex ) { } } @ Override public void removeUpdate ( DocumentEvent e ) { try { if ( e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyTMProposals ( true ) ; } catch ( BadLocationException ex ) { } } } ) ; Core . getGlossary ( ) . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent e ) { } @ Override public void insertUpdate ( DocumentEvent e ) { try { if ( ! e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyGlossaryProposals ( false ) ; } catch ( BadLocationException ex ) { } } @ Override public void removeUpdate ( DocumentEvent e ) { try { if ( e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyGlossaryProposals ( true ) ; } catch ( BadLocationException ex ) { } } } ) ; Core . getMachineTranslatePane ( ) . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent e ) { } @ Override public void insertUpdate ( DocumentEvent e ) { try { if ( ! e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyMTProposals ( false ) ; } catch ( BadLocationException ex ) { } } @ Override public void removeUpdate ( DocumentEvent e ) { try { if ( e . getDocument ( ) . getText ( e . getDocument ( ) . getStartPosition ( ) . getOffset ( ) , e . getDocument ( ) . getEndPosition ( ) . getOffset ( ) ) . trim ( ) . isEmpty ( ) ) sessionlog . GetLog ( ) . setEmtpyMTProposals ( true ) ; } catch ( BadLocationException ex ) { } } } ) ; } } ) ; }
te	9	public Action testAction ( CmdOptions parser , Option action , String [ ] vactions ) { Action act = Action . DEV ; String actionValue = ( ( String ) parser . getOptionValue ( action ) ) ; ArrayList < String > actions = new ArrayList < String > ( Arrays . asList ( vactions ) ) ; if ( ! ( actions . contains ( actionValue ) ) ) { boolean first = true ; System . err . print ( "BAD USAGE. Action must be defined: {-a | --action} { " ) ; for ( String st : actions ) { if ( ! first ) System . err . print ( "| " ) ; System . err . print ( st + " " ) ; } System . err . println ( "}" ) ; System . exit ( 0 ) ; } if ( actionValue . equalsIgnoreCase ( "train" ) ) { act = Action . TRAIN ; } if ( actionValue . equalsIgnoreCase ( "dev" ) ) { act = Action . DEV ; } if ( actionValue . equalsIgnoreCase ( "test" ) ) { act = Action . TEST ; } if ( actionValue . equalsIgnoreCase ( "prob" ) ) { act = Action . PROB ; } if ( actionValue . equalsIgnoreCase ( "size" ) ) { act = Action . SIZE ; } if ( actionValue . equalsIgnoreCase ( "order" ) ) { act = Action . ORDER ; } if ( actionValue . equalsIgnoreCase ( "rank" ) ) { act = Action . RANK ; } return act ; }
te	4	public static String cleanQuotes ( final String s ) { String ret = s ; if ( ( ret . length ( ) > 0 ) && ret . substring ( 0 , 1 ) . equals ( "\"" ) ) { ret = ret . substring ( 1 ) ; } if ( ( ret . length ( ) > 1 ) && ret . substring ( ret . length ( ) - 1 ) . equals ( "\"" ) ) { ret = ret . substring ( 0 , ret . length ( ) - 1 ) ; } ret = ret . trim ( ) ; return ret ; }
te	2	public static String getFakeLatestVersion ( ) { try { File dir = new File ( getWorkingDirectory ( ) + File . separator + "bin" + File . separator ) ; File file = new File ( dir , "version" ) ; DataInputStream dis = new DataInputStream ( new FileInputStream ( file ) ) ; String version = dis . readUTF ( ) ; dis . close ( ) ; if ( version . equals ( "0" ) ) { return "1285241960000" ; } return version ; } catch ( IOException ex ) { } return "1285241960000" ; }
te	8	@ Override public Auction [ ] search ( String criteria ) { Predicate < Auction > cp = null ; ArrayList < Auction > theSearch = new ArrayList < Auction > ( ) ; Stack < Predicate < Auction >> predicateStack = new Stack < Predicate < Auction >> ( ) ; Stack < String > operatorStack = new Stack < String > ( ) ; Predicate < Auction > firstSearchString ; Predicate < Auction > secondSearchString ; for ( String stringSplit : criteria . split ( " " ) ) { if ( stringSplit . equalsIgnoreCase ( "AND" ) ) { operatorStack . add ( stringSplit . trim ( ) ) ; } else if ( stringSplit . equalsIgnoreCase ( "OR" ) ) { operatorStack . add ( stringSplit . trim ( ) ) ; while ( operatorStack . peek ( ) . equalsIgnoreCase ( "AND" ) && ! operatorStack . isEmpty ( ) ) { operatorStack . pop ( ) ; firstSearchString = predicateStack . pop ( ) ; secondSearchString = predicateStack . pop ( ) ; cp = new AndPredicate < Auction > ( firstSearchString , secondSearchString ) ; predicateStack . add ( cp ) ; } } else { predicateStack . add ( cp = new ContainsPredicate ( stringSplit . trim ( ) ) ) ; } } while ( ! operatorStack . isEmpty ( ) ) { firstSearchString = predicateStack . pop ( ) ; secondSearchString = predicateStack . pop ( ) ; if ( operatorStack . pop ( ) . equalsIgnoreCase ( "AND" ) ) { cp = new AndPredicate < Auction > ( firstSearchString , secondSearchString ) ; predicateStack . add ( cp ) ; } else { cp = new OrPredicate < Auction > ( firstSearchString , secondSearchString ) ; predicateStack . add ( cp ) ; } if ( operatorStack . isEmpty ( ) ) { predicateStack . pop ( ) ; } } theSearch . addAll ( CollectionUtils . filter ( searches . values ( ) , cp ) ) ; return theSearch . toArray ( new Auction [ theSearch . size ( ) ] ) ; }
te	4	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { if ( columnIndex == 0 ) { return programas . get ( rowIndex ) . getNombre ( ) ; } if ( columnIndex == 1 ) { return programas . get ( rowIndex ) . getCliente ( ) . getIdentificador ( ) ; } if ( columnIndex == 2 ) { return programas . get ( rowIndex ) . getCantidadPaginas ( ) ; } if ( columnIndex == 3 ) { return programas . get ( rowIndex ) . getPesoTotal ( ) ; } return null ; }
te	7	public HashMap < Request , Mapping > readMappings ( String mappingsFilename ) { HashMap < Request , Mapping > mappings = new HashMap < Request , Mapping > ( ) ; Scanner scanner = null ; try { scanner = new Scanner ( new File ( mappingsFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } while ( scanner . hasNextLine ( ) ) { String [ ] tokens = scanner . nextLine ( ) . trim ( ) . split ( " +" ) ; Request request = requests . get ( Integer . valueOf ( tokens [ 0 ] ) ) ; Mapping mapping = new Mapping ( ) ; mapping . deactiveResourcesHandling ( ) ; int linksAmmount = Integer . valueOf ( tokens [ 3 ] ) ; Collection < VirtualLink > virtualLinks = request . getVirtualLinks ( ) . values ( ) ; if ( linksAmmount != virtualLinks . size ( ) ) { throw new RuntimeException ( "Quantidade de enlaces n\u00E3o bate." ) ; } for ( VirtualLink virtualLink : virtualLinks ) { tokens = scanner . nextLine ( ) . trim ( ) . split ( " +" ) ; Integer [ ] physicalHostNodesIds = getUniqueIds ( tokens ) ; VirtualNode virtualSourceNode = ( VirtualNode ) virtualLink . getSourceNode ( ) ; VirtualNode virtualDestinyNode = ( VirtualNode ) virtualLink . getDestinyNode ( ) ; VirtualNode [ ] sourceAndDestinyNodes = { virtualSourceNode , virtualDestinyNode } ; for ( int i = 0 ; i < 2 ; i ++ ) { VirtualNode virtualNode = sourceAndDestinyNodes [ i ] ; if ( ! mapping . isNodeMapped ( sourceAndDestinyNodes [ i ] ) ) { PhysicalNode physicalHostNode = substrateNetwork . getHashNodes ( ) . get ( physicalHostNodesIds [ i ] ) ; mapping . addNodeMapping ( virtualNode , physicalHostNode ) ; } } ArrayList < PhysicalLink > hostLinks = new ArrayList < PhysicalLink > ( ) ; for ( int i = 0 ; i < tokens . length ; i = i + 2 ) { int sourceId , destinyId ; sourceId = Math . max ( Integer . valueOf ( tokens [ i ] ) , Integer . valueOf ( tokens [ i + 1 ] ) ) ; destinyId = Math . min ( Integer . valueOf ( tokens [ i ] ) , Integer . valueOf ( tokens [ i + 1 ] ) ) ; PhysicalLink hostLink = substrateNetwork . getHashLinks ( ) . get ( String . format ( "%s:%s" , sourceId , destinyId ) ) ; hostLinks . add ( hostLink ) ; } mapping . addLinkMapping ( virtualLink , hostLinks ) ; } mappings . put ( request , mapping ) ; } return mappings ; }
te	9	public void HuffmanBlockEncoder ( BufferedOutputStream outStream , int zigzag [ ] , int prec , int DCcode , int ACcode ) { int temp , temp2 , nbits , k , r , i ; if ( componentCount > 1 ) { NumOfDCTables = 2 ; NumOfACTables = 2 ; } else { NumOfDCTables = 1 ; NumOfACTables = 1 ; } temp = temp2 = zigzag [ 0 ] - prec ; if ( temp < 0 ) { temp = - temp ; temp2 -- ; } nbits = 0 ; while ( temp != 0 ) { nbits ++ ; temp >>= 1 ; } bufferIt ( outStream , ( ( int [ ] [ ] ) DC_matrix [ DCcode ] ) [ nbits ] [ 0 ] , ( ( int [ ] [ ] ) DC_matrix [ DCcode ] ) [ nbits ] [ 1 ] ) ; if ( nbits != 0 ) { bufferIt ( outStream , temp2 , nbits ) ; } r = 0 ; for ( k = 1 ; k < 64 ; k ++ ) { if ( ( temp = zigzag [ jpegNaturalOrder [ k ] ] ) == 0 ) { r ++ ; } else { while ( r > 15 ) { bufferIt ( outStream , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ F0 ] [ 0 ] , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ F0 ] [ 1 ] ) ; r -= 16 ; } temp2 = temp ; if ( temp < 0 ) { temp = - temp ; temp2 -- ; } nbits = 1 ; while ( ( temp >>= 1 ) != 0 ) { nbits ++ ; } i = ( r << 4 ) + nbits ; bufferIt ( outStream , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ i ] [ 0 ] , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ i ] [ 1 ] ) ; bufferIt ( outStream , temp2 , nbits ) ; r = 0 ; } } if ( r > 0 ) { bufferIt ( outStream , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ 0 ] [ 0 ] , ( ( int [ ] [ ] ) AC_matrix [ ACcode ] ) [ 0 ] [ 1 ] ) ; } }
te	1	public ArrayList < Album > listAlbums ( ) { if ( GuiView . control . getCurrentUser ( ) . getAlbumList ( ) . size ( ) != 0 ) { ArrayList < Album > albums = new ArrayList < Album > ( GuiView . control . getCurrentUser ( ) . getAlbumList ( ) . values ( ) ) ; return albums ; } return null ; }
te	3	@ Override public boolean rotateRight ( Token [ ] [ ] tokens , int [ ] [ ] currentTokens , int rotateCount ) { if ( rotateCount % 4 == 0 ) { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] + 2 ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else if ( rotateCount % 4 == 1 ) { x0 = currentTokens [ 0 ] [ 0 ] - 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else if ( rotateCount % 4 == 2 ) { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] - 2 ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else { x0 = currentTokens [ 0 ] [ 0 ] + 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } return setCurrentTokens ( currentTokens ) ; }
te	1	public void selectNone ( ) { for ( Mark mark : marks ) { mark . setSelected ( false ) ; } }
te	6	public boolean containsWait ( ) { if ( len < 4 ) return false ; for ( int i = 0 ; i < len - 3 ; i ++ ) { if ( array [ i ] == 119 && array [ i + 1 ] == 97 && array [ i + 2 ] == 105 && array [ i + 3 ] == 116 ) return true ; } return false ; }
te	5	@ Override public void run ( ) { if ( dataInputStream == null ) { try { dataInputStream = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } while ( socket . isConnected ( ) ) { try { if ( ( buff = dataInputStream . readUTF ( ) ) != null ) { consumer . consume ( buff ) ; } } catch ( IOException e ) { System . out . println ( "Connection was closed" ) ; removeConsumer ( consumer ) ; closeStreams ( ) ; wasClosed = true ; break ; } } }
te	0	@ Override public RedirectUrlBuilder query ( String query , String encoding ) { return builder . query ( query , encoding ) ; }
te	4	@ Override public int [ ] [ ] getShortTable ( ) { if ( shortTableOutdate == true ) { int count = 0 ; for ( int row = 0 ; row < 10 ; row ++ ) { for ( int col = 0 ; col < 9 ; col ++ ) { if ( table [ row ] [ col ] != 0 ) { shortTable [ count ] = new int [ ] { row , col , table [ row ] [ col ] } ; count ++ ; } } } } return this . shortTable ; }
te	0	public String getTranslationText ( ) { return "" ; }
te	0	public static double interpolate ( double last , double now , double dtime ) { return last + ( now - last ) * dtime ; }
te	1	private int screenCanMoveRight ( int distance ) { if ( ! scrollLocks [ 3 ] ) { return distance ; } else { return ZettaUtil . clamp ( distance , 0 , TILE_X * zone . getBlockSizeX ( ) - ( this . getScreenRoomX ( ) + SCREEN_BUFFER_SIZE_X ) ) ; } }
te	0	public InfoFrame ( String message ) { cp . add ( m_message ) ; cp . setLayout ( null ) ; m_message . setBounds ( 10 , 10 , 180 , 80 ) ; m_message . setEditable ( false ) ; m_message . setLineWrap ( true ) ; m_message . setText ( message ) ; setBounds ( 200 , 300 , 200 , 100 ) ; setAlwaysOnTop ( true ) ; }
te	1	private void addListenerLoop ( ) { for ( int i = 0 ; i < selectRecipePanel . currentLabels . size ( ) ; i ++ ) { addViewRecipeListener ( i ) ; } }
te	0	public JsonExportOptions getJsonExportOptions ( ) { return ( JsonExportOptions ) getDataWriter ( ) . getOptions ( ) ; }
te	4	public void manageDownloadReceived ( FishPacket fp ) { if ( fp . getHeader ( ) . getType ( ) == PacketType . FILENOLONGERAVAILABLE ) { System . out . println ( "File no longer available" ) ; } else if ( fp . getHeader ( ) . getType ( ) == PacketType . FILECONTENT ) { FileContent fc = ( FileContent ) fp . getPayload ( ) ; try { byte [ ] bytes = fc . getContent ( ) ; String downFold = getSettings ( ) . getDownloadFolder ( ) ; String fname = downFold + fc . getName ( ) ; File file = new File ( fname ) ; boolean created = file . createNewFile ( ) ; if ( ! created ) { System . out . println ( "File already exists." ) ; } else { FileOutputStream fos = new FileOutputStream ( file ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; bos . write ( bytes ) ; bos . flush ( ) ; bos . close ( ) ; downloadFolderContentChanged ( ) ; System . out . println ( "file created" ) ; } } catch ( IOException ex ) { Logger . getLogger ( ClientController . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { System . out . println ( "Unrecognized packet received as download" ) ; } }
te	0	public FileAsciiWriter ( String fileName , String encoding ) throws FileNotFoundException , UnsupportedEncodingException { this . fileName = fileName ; this . fileOutputStream = new FileOutputStream ( fileName ) ; this . outputStreamWriter = new OutputStreamWriter ( fileOutputStream , encoding ) ; this . bufferedWriter = new BufferedWriter ( outputStreamWriter ) ; }
te	5	public static void drawHorizontalLineAlpha ( int x , int y , int width , int colour , int alpha ) { if ( x < topY || x >= bottomY ) return ; if ( y < topX ) { width -= topX - y ; y = topX ; } if ( y + width > bottomX ) width = bottomX - y ; int opacity = 256 - alpha ; int r = ( colour >> 16 & ff ) * alpha ; int g = ( colour >> 8 & ff ) * alpha ; int b = ( colour & ff ) * alpha ; int pointer = y + x * DrawingArea . width ; for ( int column = 0 ; column < width ; column ++ ) { int rAlpha = ( pixels [ pointer + column ] >> 16 & ff ) * opacity ; int gAlpha = ( pixels [ pointer + column ] >> 8 & ff ) * opacity ; int bAlpha = ( pixels [ pointer + column ] & ff ) * opacity ; int packedRGB = ( ( r + rAlpha >> 8 ) << 16 ) + ( ( g + gAlpha >> 8 ) << 8 ) + ( b + bAlpha >> 8 ) ; pixels [ pointer + column ] = packedRGB ; } }
te	4	void onMouseButton ( int button , int action , int mods ) { switch ( action ) { case GLFW_PRESS : for ( MouseButtonEvent e : _mouseDown ) { e . run ( button , mods ) ; } break ; case GLFW_RELEASE : for ( MouseButtonEvent e : _mouseUp ) { e . run ( button , mods ) ; } break ; } }
te	7	@ Override public int toNumero ( ) { int n = x + y * 12 + ( y + 1 ) / 2 ; return n >= 0 && x >= 0 && y >= 0 && n < Plateau . nbTuiles && ( x < 12 || ( x < 13 && y % 2 == 0 ) ) ? n : - 1 ; }
te	6	private void DownloadFormButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String ID = ( String ) FormsList . getSelectedValue ( ) ; String [ ] test = ID . split ( " " ) ; Integer formID = Integer . parseInt ( test [ 0 ] ) ; DatabaseConnection db = new DatabaseConnection ( ) ; Connection conn = db . connectToDB ( ) ; InputStream inStream = null ; String title = "" ; String sql = "Select * From `HDForms` where ID = '" + formID + "'" ; ResultSet rs = db . getResults ( conn , sql ) ; try { if ( rs . next ( ) ) { inStream = rs . getBinaryStream ( "Content" ) ; title = rs . getString ( "Title" ) ; } } catch ( SQLException ex ) { Logger . getLogger ( AllForms . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } OutputStream outStream ; try { int read = 0 ; byte [ ] bytes = new byte [ 1024 ] ; String curDir = System . getProperty ( "user.dir" ) ; outStream = new FileOutputStream ( new File ( title + ".pdf" ) ) ; try { while ( ( read = inStream . read ( bytes ) ) != - 1 ) { outStream . write ( bytes , 0 , read ) ; } } catch ( IOException ex ) { Logger . getLogger ( AllForms . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { inStream . close ( ) ; outStream . flush ( ) ; outStream . close ( ) ; JOptionPane . showMessageDialog ( frame , "File downloaded to: " + curDir ) ; } catch ( IOException ex ) { Logger . getLogger ( AllForms . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( AllForms . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	8	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
te	1	private void fire ( String blankSubject , URI predicate , String blankObject ) { predicate = provnToProvo ( predicate ) ; for ( TriplesListener listener : _listeners ) { listener . triple ( blankSubject , predicate , blankObject ) ; } }
te	8	public int maxArea ( int [ ] height ) { int result = 0 ; if ( height == null || height . length == 0 ) { return 0 ; } int minHeightOfFarthestTowers = height [ 0 ] < height [ height . length - 1 ] ? height [ 0 ] : height [ height . length - 1 ] ; result = ( height . length - 1 ) * minHeightOfFarthestTowers ; int start = 0 ; int end = height . length - 1 ; if ( height [ 0 ] < height [ height . length - 1 ] ) start ++ ; else end -- ; while ( start < end ) { int currentArea = ( end - start ) * ( height [ start ] < height [ end ] ? height [ start ] : height [ end ] ) ; if ( height [ start ] < height [ end ] ) start ++ ; else end -- ; if ( currentArea > result ) result = currentArea ; } return result ; }
te	6	public static int dehexchar ( char c ) { if ( c >= 0 && c <= 9 ) { return c - 0 ; } if ( c >= A && c <= F ) { return c - ( A - 10 ) ; } if ( c >= a && c <= f ) { return c - ( a - 10 ) ; } return - 1 ; }
te	8	public Object nextValue ( ) throws JSONException { char c = nextClean ( ) ; String s ; switch ( c ) { case " : case ' : return nextString ( c ) ; case { : back ( ) ; return new JSONObject ( this ) ; case [ : case ( : back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = next ( ) ; } back ( ) ; s = sb . toString ( ) . trim ( ) ; if ( s . equals ( "" ) ) { throw syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( s ) ; }
te	9	public void collideCheck ( ) { if ( carried || dead || deadTime > 0 ) return ; float xMarioD = world . mario . x - x ; float yMarioD = world . mario . y - y ; float w = 16 ; if ( xMarioD > - 16 && xMarioD < 16 ) { if ( yMarioD > - height && yMarioD < world . mario . height ) { if ( world . mario . ya > 0 && yMarioD <= 0 && ( ! world . mario . onGround || ! world . mario . wasOnGround ) ) { world . mario . stomp ( this ) ; if ( facing != 0 ) { xa = 0 ; facing = 0 ; } else { facing = world . mario . facing ; } } else { if ( facing != 0 ) { world . mario . getHurt ( this ) ; } else { world . mario . kick ( this ) ; facing = world . mario . facing ; } } } } }
te	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
te	2	public ArrayList < ArrayList < double >> buildCommentsVector ( double [ ] [ ] matrix , int numOfComments ) { ArrayList < ArrayList < double >> commentsVectors = new ArrayList < ArrayList < double >> ( ) ; ArrayList < double > vector ; for ( int i = 0 ; i < numOfComments ; i ++ ) { vector = new ArrayList < double > ( ) ; for ( int j = 0 ; j < numOfWords ; j ++ ) vector . add ( ( double ) matrix [ j ] [ i ] ) ; vector . add ( ( double ) 1 ) ; commentsVectors . add ( vector ) ; } return commentsVectors ; }
te	4	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
te	1	public List < String > getVisitCount ( String ... eventList ) { List < String > result = new ArrayList < String > ( ) ; for ( int i = 0 ; i < eventList . length ; i ++ ) { result . add ( this . jedis . get ( KEY_EVENT_CLICK + eventList [ i ] ) ) ; } return result ; }
te	3	public TreeNode buildTree ( int [ ] preorder , int [ ] inorder ) { if ( preorder == null || inorder == null ) return null ; HashMap < Integer , Integer > inorderMap = new HashMap < > ( inorder . length ) ; for ( int i = 0 ; i < inorder . length ; i ++ ) { inorderMap . put ( inorder [ i ] , i ) ; } return buildTreeRecursive ( preorder , inorder , 0 , 0 , inorder . length , inorderMap ) ; }
te	0	public AckCode getAck ( ) { return ack ; }
te	7	public boolean wordBreak3 ( String s , Set < String > dict ) { if ( dict == null || dict . size ( ) == 0 ) return false ; if ( dict . contains ( s ) ) return true ; boolean res [ ] = new boolean [ s . length ( ) + 1 ] ; res [ 0 ] = true ; for ( int i = 0 ; i < dict . size ( ) ; i ++ ) { String tempStr = s . substring ( 0 , i + 1 ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( res [ j ] && dict . contains ( tempStr ) ) { res [ i + 1 ] = true ; break ; } tempStr = tempStr . substring ( 1 , tempStr . length ( ) ) ; } } return res [ s . length ( ) ] ; }
te	5	public static boolean canWriteLetterFromMagazine4 ( String letter , String magazine ) { HashMap < Character , MutableInt > magazineChars = new HashMap < Character , MutableInt > ( 512 ) ; char [ ] letterCharArray = letter . toCharArray ( ) ; char [ ] magazineCharArray = magazine . toCharArray ( ) ; for ( int i = 0 ; i < magazineCharArray . length ; i ++ ) { char chr = magazineCharArray [ i ] ; MutableInt currentCountForChar = magazineChars . get ( chr ) ; if ( currentCountForChar != null ) { currentCountForChar . increment ( ) ; } else { magazineChars . put ( chr , new MutableInt ( 1 ) ) ; } } for ( int i = 0 ; i < letterCharArray . length ; i ++ ) { char chr = letterCharArray [ i ] ; MutableInt currentCountForChar = magazineChars . get ( chr ) ; if ( currentCountForChar == null || currentCountForChar . decrement ( ) < 0 ) { return false ; } } return true ; }
te	0	public Game getGame ( ) { return this . game ; }
