tr	2	private static List < String > readStringSubKeys ( Preferences root , int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { List < String > results = new ArrayList < String > ( ) ; int [ ] handles = ( int [ ] ) regOpenKey . invoke ( root , new Object [ ] { new Integer ( hkey ) , toCstr ( key ) , new Integer ( KEY_READ ) } ) ; if ( handles [ 1 ] != REG_SUCCESS ) { return null ; } int [ ] info = ( int [ ] ) regQueryInfoKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; int count = info [ 0 ] ; int maxlen = info [ 3 ] ; for ( int index = 0 ; index < count ; index ++ ) { byte [ ] name = ( byte [ ] ) regEnumKeyEx . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) , new Integer ( index ) , new Integer ( maxlen + 1 ) } ) ; results . add ( new String ( name ) . trim ( ) ) ; } regCloseKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; return results ; }
tr	3	public void modifyCourse ( ClassInfo classInfo ) { ClassInfo cInfoData = getCourse ( classInfo . getClassNumber ( ) ) ; if ( cInfoData != null ) { if ( ! classInfo . getCourseName ( ) . equalsIgnoreCase ( cInfoData . getCourseName ( ) ) ) { Course crs = new Course ( ) ; crs . setCourseID ( classInfo . getCourseNumber ( ) ) ; crs . setCourseName ( classInfo . getCourseName ( ) ) ; saveDataModify ( crs ) ; } if ( ! classInfo . getCourseSection ( ) . equalsIgnoreCase ( cInfoData . getCourseSection ( ) ) ) { SchoolClass cls = new SchoolClass ( ) ; cls . setClassNumber ( classInfo . getClassNumber ( ) ) ; cls . setClassSection ( classInfo . getCourseSection ( ) ) ; saveDataModify ( cls ) ; } } }
tr	8	public int minimumTotal ( ArrayList < ArrayList < Integer >> triangle ) { int out = 0 ; int min ; if ( triangle == null || triangle . size ( ) == 0 ) return out ; int tLevel = triangle . size ( ) ; out = triangle . get ( 0 ) . get ( 0 ) ; ArrayList < Integer > candidate = new ArrayList < Integer > ( ) ; candidate . add ( out ) ; ArrayList < Integer > next ; for ( int level = 1 ; level < tLevel ; level ++ ) { next = new ArrayList < Integer > ( ) ; int k ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) k = triangle . get ( level ) . get ( 0 ) + candidate . get ( 0 ) ; else if ( i == level ) k = triangle . get ( level ) . get ( i ) + candidate . get ( i - 1 ) ; else { k = triangle . get ( level ) . get ( i ) ; k += Math . min ( candidate . get ( i - 1 ) , candidate . get ( i ) ) ; } next . add ( k ) ; } candidate . clear ( ) ; candidate = next ; } if ( candidate . size ( ) != 0 ) { min = candidate . get ( 0 ) ; for ( int c : candidate ) { min = Math . min ( min , c ) ; } out = min ; } return out ; }
tr	7	public void draw ( ) { if ( drawable ) { if ( currentspriteexists ( ) ) { if ( drawmode == 2 ) { mainscreen . screengraphics . drawImage ( image . get ( currentspritenumber ) . getimage ( ) , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , ( int ) ( x + spriteoffsetx + boundsx ) , ( int ) ( y + spriteoffsety + boundsy ) , ( int ) ( spriteoffsetx ) , ( int ) ( spriteoffsety ) , ( int ) ( spriteoffsetx + boundsx ) , ( int ) ( spriteoffsety + boundsy ) , null ) ; } else if ( drawmode == 3 ) { boolean drawsuccess = false ; try { Image tempimage = image . get ( currentspritenumber ) . getimage ( ) . getScaledInstance ( ( int ) ( getsizex ( ) ) , ( int ) ( getsizey ( ) ) , Image . SCALE_FAST ) ; do { drawsuccess = mainscreen . screengraphics . drawImage ( tempimage , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , null ) ; } while ( ! drawsuccess ) ; } catch ( Exception e ) { } } else { mainscreen . screengraphics . drawImage ( image . get ( currentspritenumber ) . getimage ( ) , ( int ) ( x + spriteoffsetx ) , ( int ) ( y + spriteoffsety ) , null ) ; } } else { mainscreen . screengraphics . setColor ( drawcolor ) ; mainscreen . screengraphics . drawRect ( ( int ) ( x ) , ( int ) ( y ) , ( int ) boundsx , ( int ) boundsy ) ; } } if ( debugbounds ) { mainscreen . screengraphics . setColor ( drawcolor ) ; mainscreen . screengraphics . drawRect ( ( int ) ( x ) , ( int ) ( y ) , ( int ) getsizex ( ) , ( int ) getsizey ( ) ) ; } }
tr	3	public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj instanceof Keyword ) { Keyword k = ( Keyword ) obj ; if ( k . toString ( ) . equals ( this . toString ( ) ) ) { return true ; } } return false ; }
tr	4	public void triangulate ( FaceList newFaces , double minArea ) { HalfEdge hedge ; if ( numVertices ( ) < 4 ) { return ; } Vertex v0 = he0 . head ( ) ; Face prevFace = null ; hedge = he0 . next ; HalfEdge oppPrev = hedge . opposite ; Face face0 = null ; for ( hedge = hedge . next ; hedge != he0 . prev ; hedge = hedge . next ) { Face face = createTriangle ( v0 , hedge . prev . head ( ) , hedge . head ( ) , minArea ) ; face . he0 . next . setOpposite ( oppPrev ) ; face . he0 . prev . setOpposite ( hedge . opposite ) ; oppPrev = face . he0 ; newFaces . add ( face ) ; if ( face0 == null ) { face0 = face ; } } hedge = new HalfEdge ( he0 . prev . prev . head ( ) , this ) ; hedge . setOpposite ( oppPrev ) ; hedge . prev = he0 ; hedge . prev . next = hedge ; hedge . next = he0 . prev ; hedge . next . prev = hedge ; computeNormalAndCentroid ( minArea ) ; checkConsistency ( ) ; for ( Face face = face0 ; face != null ; face = face . next ) { face . checkConsistency ( ) ; } }
tr	9	@ SuppressWarnings ( "ObjectEqualsNull" ) public static String valueToString ( Object value ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof JSONString ) { Object object ; try { object = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "Bad value from toJSONString: " + object ) ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; }
tr	7	public void prepare ( Dish dish ) { LinkedList < Material > materials = dish . getMaterials ( ) ; for ( Material tmp : materials ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) ) { storage . setAmount ( storage . getAmount ( ) - tmp . getAmount ( ) ) ; } } } LinkedList < Ingredient > ingredients = dish . getIngredients ( ) ; for ( Ingredient tmp : ingredients ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) && storage . getAmount ( ) > 0 ) { storage . setAmount ( storage . getAmount ( ) - 1 ) ; } } } nodifyObserver ( ) ; }
tr	5	private static int bcd ( char digit ) { if ( digit >= 0 && digit <= 9 ) { return digit - 0 ; } switch ( digit ) { case . : return 10 ; case - : return 11 ; case + : return 12 ; default : return 13 ; } }
tr	8	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
tr	9	private String createExporterIDQuery ( String exporterID , String colName ) { String [ ] splitString ; int lowerBound ; int upperBound ; int expNum ; if ( exporterID == null || colName == null || exporterID . equalsIgnoreCase ( "" ) || exporterID . equalsIgnoreCase ( "*" ) ) return "" ; if ( ( splitString = exporterID . split ( "-" ) ) . length > 1 ) { if ( splitString . length == 2 ) { try { lowerBound = Integer . parseInt ( splitString [ 0 ] ) ; if ( lowerBound > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } upperBound = Integer . parseInt ( splitString [ 1 ] ) ; if ( upperBound > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } catch ( NumberFormatException e ) { output += "<p>Entered exporter Id was invalid and therefore omitted.</p><br>" ; return "" ; } return colName + " BETWEEN " + lowerBound + " AND " + upperBound ; } else { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } else { splitString = exporterID . split ( " " ) ; for ( int i = 0 ; i < splitString . length ; i ++ ) { try { expNum = Integer . parseInt ( splitString [ i ] ) ; } catch ( NumberFormatException e ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } if ( expNum > 65535 ) { output += "<p>Entered exporter ID was invalid and therefore omitted.</p><br>" ; return "" ; } } if ( splitString . length > 0 ) { while ( exporterID . endsWith ( " " ) ) exporterID = exporterID . substring ( 0 , exporterID . length ( ) - 1 ) ; return colName + " IN (" + exporterID + ")" ; } else { return colName + "=" + exporterID ; } } }
tr	2	private Map < String , boolean > getWorldPermissions ( String world ) { HashMap < String , boolean > result = new HashMap < String , boolean > ( ) ; provider . checkConnection ( ) ; PreparedStatement prep = provider . prepGetUserPermissions ; try { prep . clearParameters ( ) ; prep . setInt ( 1 , ID ) ; prep . setString ( 2 , world ) ; ResultSet rs = prep . executeQuery ( ) ; while ( rs . next ( ) ) { result . put ( rs . getString ( 1 ) , rs . getBoolean ( 2 ) ) ; } rs . close ( ) ; } catch ( SQLException e ) { SQLPermissions . mysqlError ( e ) ; } return result ; }
tr	1	class < ? > [ ] groups ( ) default { } ;
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	9	public ArrayList < ArrayList < Integer >> zigzagLevelOrder ( TreeNode root ) { ArrayList < ArrayList < Integer >> out = new ArrayList < ArrayList < Integer >> ( ) ; if ( root == null ) return out ; ValPack p = new ValPack ( ) ; p . node = root ; p . level = 0 ; LinkedList < ValPack > nodeList = new LinkedList < ValPack > ( ) ; LinkedList < ValPack > list = new LinkedList < ValPack > ( ) ; nodeList . addLast ( p ) ; int curLevel = 0 ; while ( nodeList . size ( ) != 0 ) { p = nodeList . removeFirst ( ) ; if ( p . level != curLevel ) { ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; list = new LinkedList < ValPack > ( ) ; curLevel = p . level ; } list . addLast ( p ) ; if ( p . node . left != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . left ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } if ( p . node . right != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . right ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } } ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; return out ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadastroProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadastroProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadastroProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadastroProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( ) . setVisible ( true ) ; } } ) ; }
tr	8	@ Override public void marshal ( Element amdSec , Document doc ) { super . marshal ( amdSec , doc ) ; String metsNs = NS . METS . ns ( ) ; if ( this . techMD != null ) { for ( MdSec mds : this . techMD ) { Element techMD = doc . createElementNS ( metsNs , "mets:techMD" ) ; mds . marshal ( techMD , doc ) ; amdSec . appendChild ( techMD ) ; } } if ( this . rightsMD != null ) { for ( MdSec mds : this . rightsMD ) { Element rightsMD = doc . createElementNS ( metsNs , "mets:rightsMD" ) ; mds . marshal ( rightsMD , doc ) ; amdSec . appendChild ( rightsMD ) ; } } if ( this . sourceMD != null ) { for ( MdSec mds : this . sourceMD ) { Element sourceMD = doc . createElementNS ( metsNs , "mets:sourceMD" ) ; mds . marshal ( sourceMD , doc ) ; amdSec . appendChild ( sourceMD ) ; } } if ( this . digiprovMD != null ) { for ( MdSec mds : this . digiprovMD ) { Element digiprovMD = doc . createElementNS ( metsNs , "mets:digiprovMD" ) ; mds . marshal ( digiprovMD , doc ) ; amdSec . appendChild ( digiprovMD ) ; } } }
tr	6	public void findAllChildrenByName ( ArrayList < Tag > result , String name , boolean recursive ) { if ( result == null ) { result = new ArrayList < Tag > ( ) ; } if ( list != null ) { for ( Tag t : list ) { if ( t . getName ( ) != null ) { if ( t . getName ( ) . equals ( name ) ) { result . add ( t ) ; } } if ( recursive ) { t . findAllChildrenByName ( result , name , true ) ; } } } }
tr	0	public void setNeedsPass ( boolean needsPass ) { this . needsPass = needsPass ; }
tr	2	private void siirraNappula ( Point p ) { if ( ! peli . logiikka . loppu ( ) && Pelilauta . hiiriPaalla ( p ) ) { int kor = ykoordinaatti ( p . y ) ; int lev = xkoordinaatti ( p . x ) ; peli . siirto ( 7 - korMis , levMis , 7 - kor , lev ) ; } }
tr	0	@ Test public void testEmptyBag ( ) { Bag bag = new Bag ( ) ; DiscType expected = DiscType . PUTTAPPROACH ; DiscType actual = FrolfUtil . recommendDiscForBag ( bag ) . getDiscType ( ) ; System . out . println ( "" + bag . getLackingDiscType ( ) ) ; assertTrue ( "A putter was not recommended for an empty bag. Got: " + actual , expected == actual ) ; }
tr	7	@ Override public void visit ( Identifiable thing ) { if ( thing . isBullet ( ) ) { this . health -= player . getPower ( ) ; if ( health < 1 ) { this . dead = true ; this . panel . removeSprite ( this ) ; } } else if ( thing . isPlayer ( ) ) { GameDir toMove = GameDir . UP ; switch ( player . getDirection ( ) ) { case UP : toMove = GameDir . DOWN ; break ; case DOWN : toMove = GameDir . UP ; break ; case RIGHT : toMove = GameDir . LEFT ; break ; case LEFT : toMove = GameDir . RIGHT ; break ; } this . player . damage ( this . power , toMove ) ; } }
tr	0	public int process_id ( ) { return 2 ; }
tr	9	void copyAARow ( final int [ ] alphaRow , final int y , final int px0 , final int px1 ) { if ( DO_MONITORS ) { RendererContext . stats . mon_rdr_copyAARow . start ( ) ; } final int px_bbox1 = Math . min ( px1 , bboxX1 ) ; if ( DO_LOG_BOUNDS ) { MarlinUtils . logInfo ( "row = [" + px0 + " ... " + px_bbox1 + " (" + px1 + ") [ for y=" + y ) ; } final int row = y - bboxY0 ; rowAAx0 [ row ] = px0 ; rowAAx1 [ row ] = px_bbox1 ; final int len = px_bbox1 - px0 ; final int pos = rowAAChunkPos ; rowAAChunkIndex [ row ] = pos ; byte [ ] _rowAAChunk = rowAAChunk ; if ( _rowAAChunk . length < pos + len ) { if ( DO_STATS ) { RendererContext . stats . stat_array_marlincache_rowAAChunk . add ( pos + len ) ; } rowAAChunk = _rowAAChunk = rdrCtx . widenDirtyByteArray ( _rowAAChunk , pos , pos + len ) ; } if ( DO_STATS ) { RendererContext . stats . stat_cache_rowAA . add ( len ) ; } final int from = px0 - bboxX0 ; final int to = px_bbox1 - bboxX0 ; final int [ ] touchedLine = touchedTile ; final int _TILE_SIZE_LG = TILE_SIZE_LG ; final byte [ ] _ALPHA_MAP = ALPHA_MAP ; final int off = pos - from ; for ( int x = from , val = 0 ; x < to ; x ++ ) { val += alphaRow [ x ] ; if ( DO_AA_RANGE_CHECK ) { if ( val < 0 ) { System . out . println ( "Invalid coverage = " + val ) ; val = 0 ; } if ( val > MAX_AA_ALPHA ) { System . out . println ( "Invalid coverage = " + val ) ; val = MAX_AA_ALPHA ; } } _rowAAChunk [ x + off ] = _ALPHA_MAP [ val ] ; if ( val != 0 ) { touchedLine [ x >> _TILE_SIZE_LG ] += val ; } } rowAAChunkPos = pos + len ; int tx = from >> _TILE_SIZE_LG ; if ( tx < tileMin ) { tileMin = tx ; } tx = ( ( to - 1 ) >> _TILE_SIZE_LG ) + 1 ; if ( tx > tileMax ) { tileMax = tx ; } if ( DO_LOG_BOUNDS ) { MarlinUtils . logInfo ( "clear = [" + from + " ... " + to + "[" ) ; } IntArrayCache . fill ( alphaRow , from , px1 - bboxX0 , 0 ) ; if ( DO_MONITORS ) { RendererContext . stats . mon_rdr_copyAARow . stop ( ) ; } }
tr	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final AreaStats other = ( AreaStats ) obj ; if ( this . averageWeather != other . averageWeather ) { return false ; } return true ; }
tr	7	public void countXml ( XmlPullParser xpp ) throws XmlPullParserException , IOException { int holderForStartAndLength [ ] = new int [ 2 ] ; xpp . require ( XmlPullParser . START_DOCUMENT , null , null ) ; int eventType = xpp . next ( ) ; xpp . require ( XmlPullParser . START_TAG , null , null ) ; while ( eventType != XmlPullParser . END_DOCUMENT ) { if ( eventType == XmlPullParser . START_TAG ) { ++ countSTags ; countAttribs += xpp . getAttributeCount ( ) ; if ( verbose ) { System . err . println ( "START_TAG " + xpp . getName ( ) ) ; } } else if ( eventType == XmlPullParser . TEXT ) { xpp . getTextCharacters ( holderForStartAndLength ) ; int length = holderForStartAndLength [ 1 ] ; countChars += length ; if ( verbose ) { System . err . println ( "TEXT '" + printable ( xpp . getText ( ) ) + "'" ) ; } } else if ( eventType == XmlPullParser . END_TAG ) { if ( verbose ) { System . err . println ( "END_TAG " + xpp . getName ( ) ) ; } } eventType = xpp . next ( ) ; } }
tr	5	@ Override public final void instantiate ( ) { instanceId = generateInstanceId ( ) ; if ( this instanceof ParentTrait ) { ParentTrait parentThis = ( ParentTrait ) this ; for ( int i = 0 ; i < parentThis . getChildCount ( ) ; i ++ ) { if ( ! ( parentThis instanceof ReferenceTrait ) || ! ( ( ReferenceTrait ) parentThis ) . isBackReference ( i ) ) { GeneTrait childGene = parentThis . getChild ( i ) ; if ( childGene != null ) { childGene . instantiate ( ) ; } } } } }
tr	7	public Dimension preferredLayoutSize ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { if ( lastParentSize == null || ! parent . getSize ( ) . equals ( lastParentSize ) ) { for ( ComponentWrapper wrapper : ccMap . keySet ( ) ) { Component c = ( Component ) wrapper . getComponent ( ) ; if ( c instanceof JTextArea || c instanceof JEditorPane || ( c instanceof JComponent && boolean . true . equals ( ( ( JComponent ) c ) . getClientProperty ( "migLayout.dynamicAspectRatio" ) ) ) ) { layoutContainer ( parent ) ; break ; } } } lastParentSize = parent . getSize ( ) ; return getSizeImpl ( parent , LayoutUtil . PREF ) ; } }
tr	1	public File getScmFile ( ) { if ( this . isScmFile ( ) ) return this . scmFile ; return null ; }
tr	7	public static class < ? > getUserClass ( class < ? > clazz ) { if ( clazz != null && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass != null && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; }
tr	1	@ Override public String getCode ( ) { if ( ! uncheckedGenes . isEmpty ( ) ) { throw new IllegalStateException ( "Breeding operator forgot to repair mortal after modification. Unchecked internal tree structure might be invalid. Aborting. DEBUG: " + uncheckedGenes ) ; } return getRootGene ( ) . getCode ( new SourceCompositionTask ( ) ) ; }
tr	5	private void jmiBkpBDActionPerformed ( java . awt . event . ActionEvent evt ) { int resp ; resp = RealizarBackupMySQL . showOpenDialog ( this ) ; if ( resp == JFileChooser . APPROVE_OPTION ) { try { InterfazSCHCG metodo = ( InterfazSCHCG ) registry . lookup ( "conex" ) ; boolean todo_ok = metodo . GenerarBackupMySQL ( RealizarBackupMySQL . getSelectedFile ( ) . toString ( ) ) ; if ( todo_ok ) { JOptionPane . showMessageDialog ( this , "Informacion" , "Archivo generado" , JOptionPane . INFORMATION_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( this , "Error" , "Se produjo un error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( RemoteException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NotBoundException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else if ( resp == JFileChooser . CANCEL_OPTION ) { JOptionPane . showMessageDialog ( this , "Ha sido cancelada la generacion de restaurar" ) ; } }
tr	5	public void abrir ( ) throws Exception { if ( id . length ( ) > 0 && ! id . equals ( "0" ) ) { long cod = long . parseLong ( id ) ; if ( venda == null || ( venda != null && venda . getId ( ) != cod ) ) setVenda ( ejb . Open ( cod ) ) ; } }
tr	7	private void loginSubmitButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String userName = userNameText . getText ( ) ; String password = passwordText . getText ( ) ; boolean accountAvailable = false ; int accountID = 0 ; int permission = 0 ; String accountPassword = "" ; String firstName = "" ; String lastName = "" ; DatabaseConnection dbConnect = new DatabaseConnection ( ) ; Connection conn = dbConnect . connectToDB ( ) ; String sql = "SELECT COUNT(Username) as accountAvailable FROM `HD_Accounts` WHERE Username = '" + userName + "'" ; ResultSet rs = dbConnect . getResults ( conn , sql ) ; try { if ( rs . next ( ) ) { if ( rs . getInt ( "accountAvailable" ) == 1 ) { accountAvailable = true ; sql = "SELECT * FROM `HD_Accounts` where Username = '" + userName + "'" ; rs = dbConnect . getResults ( conn , sql ) ; while ( rs . next ( ) ) { accountID = rs . getInt ( "id" ) ; accountPassword = rs . getString ( "Password" ) ; firstName = rs . getString ( "FirstName" ) ; lastName = rs . getString ( "LastName" ) ; permission = rs . getInt ( "Permission" ) + 1 ; } } } } catch ( SQLException ex ) { Logger . getLogger ( HelpDeskMainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( ! accountAvailable && ! accountPassword . equals ( password ) ) { failure ++ ; if ( failure == 3 ) { this . dispose ( ) ; failureAlert . setVisible ( true ) ; } else { softFailureAlert . setVisible ( true ) ; userNameText . setText ( "" ) ; passwordText . setText ( "" ) ; } } else { this . dispose ( ) ; new LandingForm ( permission , accountID ) . setVisible ( true ) ; } }
tr	5	public static void connectHelper2 ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left != null && root . right != null ) { TreeLinkNode rootLeft = root . right . left ; TreeLinkNode rootRight = root . left . right ; while ( rootLeft != null && rootRight != null ) { rootRight . next = rootLeft ; rootRight = rootRight . right ; rootLeft = rootLeft . left ; } connectHelper2 ( root . left ) ; connectHelper2 ( root . right ) ; } }
tr	8	public static Application parseApplicationDescription ( JSONObject topJson , boolean store ) throws DBException { try { JSONObject appJson ; appJson = topJson . getJSONObject ( "application" ) ; if ( ! appJson . has ( "USER_id" ) ) { appJson . put ( "USER_id" , ( User . getByName ( appJson . getString ( "USER_name" ) ) ) . getId ( ) ) ; } Application app = new Application ( appJson ) ; if ( store ) app . store ( ) ; LOG . debug ( "loading description for app:" + app . getDescription ( ) ) ; JSONArray modules = appJson . getJSONArray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { JSONObject m = modules . getJSONObject ( i ) ; m . put ( "APPLICATION_id" , app . getId ( ) ) ; Module module = new Module ( m ) ; if ( store ) module . store ( ) ; LOG . debug ( "parsed Module:" + module ) ; JSONArray components = m . getJSONArray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { JSONObject c = components . getJSONObject ( j ) ; c . put ( "MODULE_id" , "" + module . getId ( ) ) ; if ( ! c . has ( "RESOURCE_TYPE_id" ) ) { ResourceType rt = ResourceType . getByName ( c . getString ( "resource_type" ) ) ; c . put ( "RESOURCE_TYPE_id" , rt . getId ( ) ) ; } Component component = new Component ( c ) ; if ( store ) component . store ( ) ; LOG . debug ( "parsed component: " + component ) ; } } return app ; } catch ( JSONException ex ) { System . err . println ( "parsing not successfull" ) ; ex . printStackTrace ( ) ; } return null ; }
tr	5	public void update ( Observable o , Object arg ) { if ( ! ( arg instanceof String ) ) { return ; } SpitfireMessage message = new SpitfireMessage ( ( String ) arg ) ; if ( ! message . isValid ( ) ) return ; if ( "RA" . equals ( message . getApplication ( ) ) || "RS" . equals ( message . getApplication ( ) ) ) { final VizNode thisNode = displayNode ( message . getSrcMac ( ) ) ; if ( "000000000000ffff" . equals ( message . getDstMac ( ) ) ) { thisNode . bcastEvent ( Color . green . getRGB ( ) , message . getPayloadLength ( ) , "" ) ; } else { final VizNode otherNode = displayNode ( message . getDstMac ( ) ) ; VizLink link = displayLink ( thisNode , otherNode , VizLink . LINK_BI ) ; thisNode . sendPacket ( link , Color . green . getRGB ( ) , message . getPayload ( ) . length ( ) , thisNode , otherNode ) ; } } }
tr	4	public void addIndex ( String table , String field ) { String field2 = field ; if ( field2 . endsWith ( "_" ) ) { field2 = field2 . substring ( 0 , field2 . length ( ) - 1 ) ; } try { Statement stmt = conn . createStatement ( ) ; if ( checkIndex ( table + "_" + field2 ) ) { if ( overwrite ) { stmt . execute ( "DROP INDEX " + table + "_" + field2 ) ; } else { System . out . println ( table + "_" + field2 + " exists.  Skipping." ) ; return ; } } String s = "CREATE INDEX " + table + "_" + field2 + " ON " + table + "(" + field + ");" ; long t1 = System . currentTimeMillis ( ) ; stmt . execute ( s ) ; long t2 = System . currentTimeMillis ( ) ; System . out . printf ( "\t%-50s%-30s%-15s%n" , table + "_" + field2 + " created." , new Date ( System . currentTimeMillis ( ) ) , "(" + TimeConvert . millisToString ( t2 - t1 ) + ")" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	9	private void parsePacket ( ) throws MpegDecodeException , IOException { Statistics . startLog ( PARSE_PACKET_STRING ) ; System . out . println ( "Parsing packet" ) ; if ( m_ioTool . getBits ( 24 ) != 1 ) { Debug . println ( Debug . ERROR , "Synchronization error in packet" ) ; throw new MpegDecodeException ( "Synchronization error in packet" ) ; } int streamId = m_ioTool . getBits ( 8 ) ; int pktLength = m_ioTool . getBits ( 16 ) ; if ( streamId != PRIVATE_STREAM2 ) { pktLength -= parseTimeStamps ( ) ; } if ( ( streamId & E0 ) == C0 ) { decodeAudio ( pktLength ) ; } else { if ( ( F0 & streamId ) == E0 ) { decodeVideo ( pktLength ) ; } else if ( ( F0 & streamId ) == F0 ) { ; } else { switch ( streamId ) { case RESERVED_STREAM : case PRIVATE_STREAM1 : case PADDING_STREAM : case PRIVATE_STREAM2 : break ; default : Debug . println ( Debug . ERROR , "Unknown Stream: " + streamId ) ; throw new MpegDecodeException ( "Unknown Stream: " + streamId ) ; } } } Statistics . endLog ( PARSE_PACKET_STRING ) ; }
tr	8	public Set < Light > getLights ( int [ ] [ ] board ) { lights = new HashSet < Light > ( ) ; objective = new HashMap < Integer , Tuple < Integer , Integer >> ( ) ; lightArr = new Light [ numLights ] ; sectors = getSectors ( ) ; for ( int i = 0 ; i < numLights ; i ++ ) { int x = 0 ; int y = 0 ; double theta = i * ( 360 / numLights ) + ( 360 / numLights ) / 2 ; log . trace ( "i" + i + " - theta:" + theta ) ; double slope = Math . tan ( Math . toRadians ( theta ) ) ; int xf = 1 ; int yf = 1 ; if ( theta > 90 && theta < 270 ) { xf = - 1 ; } if ( theta == 90 || theta == 270 ) { while ( Math . abs ( y ) < 50 ) { y ++ ; } } else { while ( Math . abs ( x ) < 30 && Math . abs ( y ) < 30 ) { x = x + xf ; y = ( int ) Math . floor ( slope * x ) ; y = ( int ) ( slope * x ) ; log . trace ( i + ":(x y):" + x + " " + y + "slope" + slope ) ; } } lastLight = new Point2D . double ( x + 50 , y + 50 ) ; MoveableLight l = new MoveableLight ( lastLight . getX ( ) , lastLight . getY ( ) , true ) ; log . trace ( "Positioned a light at (" + lastLight . getX ( ) + "  " + lastLight . getY ( ) + ")" ) ; lights . add ( l ) ; lightArr [ i ] = l ; objective . put ( i , null ) ; } return lights ; }
tr	2	@ Override public Validator < AbstractConverter > getValidator ( ) { return new Validator < AbstractConverter > ( ) { @ Override public Set < ConstraintViolation > validate ( AbstractConverter item ) { Set < ConstraintViolation > constraints = new HashSet < ConstraintViolation > ( ) ; Map < String , ConverterParameter > params = item . getParametersMap ( ) ; ConverterParameter param = params . get ( "colFileSizeInBytes" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the column with filesize in bytes data" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "colFileSizeConvert" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the output column" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } return constraints ; } } ; }
tr	4	public Tile cross ( Tile currentTile , Character crosser ) { if ( crosser == null || currentTile == null ) { throw new IllegalArgumentException ( "currentTile and crosser cannot be null" ) ; } if ( ! crosser . equals ( currentTile . getCharacter ( ) ) ) { throw new IllegalArgumentException ( "The given character must be on the given tile" ) ; } if ( ! canCross ( crosser ) ) { throw new IllegalArgumentException ( "The given character is not capable of crossing this edge" ) ; } Tile destination = getOtherTile ( currentTile ) ; currentTile . removeCharacter ( ) ; destination . addCharacter ( crosser ) ; return destination ; }
tr	1	public static String camelCaseName ( String name ) { return isEmpty ( name ) ? "" : Character . toLowerCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; }
tr	7	public static void avlToFile ( AVL avl , Path file , Path origin ) throws IOException { FileOutputStream fos = new FileOutputStream ( file . toFile ( ) ) ; avl . getGeometry ( ) . writeAVLData ( fos ) ; fos . close ( ) ; String fileMassPath = file . toString ( ) . replace ( ".avl" , ".mass" ) ; File fileMass = new File ( fileMassPath ) ; fos = new FileOutputStream ( fileMass ) ; avl . writeAVLMassData ( fos ) ; fos . close ( ) ; Path dest = file . getParent ( ) ; for ( Body body : avl . getGeometry ( ) . getBodies ( ) ) { if ( ! body . getBFILE ( ) . isEmpty ( ) && ! Files . exists ( dest . resolve ( body . getBFILE ( ) ) ) ) Files . copy ( origin . resolve ( body . getBFILE ( ) ) , dest . resolve ( body . getBFILE ( ) ) ) ; } for ( Surface surface : avl . getGeometry ( ) . getSurfaces ( ) ) { for ( Section section : surface . getSections ( ) ) { if ( ! section . getAFILE ( ) . isEmpty ( ) && ! Files . exists ( dest . resolve ( section . getAFILE ( ) ) ) ) Files . copy ( origin . resolve ( section . getAFILE ( ) ) , dest . resolve ( section . getAFILE ( ) ) ) ; } } }
tr	9	private static int method507 ( char ac [ ] , int j , char ac1 [ ] ) { if ( j == 0 ) return 2 ; for ( int k = j - 1 ; k >= 0 ; k -- ) { if ( ! method517 ( ac [ k ] ) ) break ; if ( ac [ k ] ==   || ac [ k ] == . ) return 3 ; } int l = 0 ; for ( int i1 = j - 1 ; i1 >= 0 ; i1 -- ) { if ( ! method517 ( ac1 [ i1 ] ) ) break ; if ( ac1 [ i1 ] == * ) l ++ ; } if ( l >= 3 ) return 4 ; return ! method517 ( ac [ j - 1 ] ) ? 0 : 1 ; }
tr	5	public void runScript ( InputStream stream ) throws JStrykerException , IllegalArgumentException { if ( stream == null ) { throw new IllegalArgumentException ( "Stream cannot be null." ) ; } try { List < String > commands = parse ( stream ) ; for ( String command : commands ) { Statement statement = null ; try { statement = connection . createStatement ( ) ; statement . execute ( command . toString ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( SQLException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	6	public String getPosition ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "line " ) . append ( lineNumber ) . append ( "  char " ) . append ( charNumber ) ; buffer . append ( ": ..." ) ; StringBuffer line = new StringBuffer ( ) ; int count = 0 ; int start = index ; while ( count ++ < charNumber ) { if ( start -- == 0 ) { start = BUFFER_SIZE - 1 ; } if ( ( history [ start ] == '' ) || ( start == index ) ) { break ; } line . append ( ( char ) history [ start ] ) ; } buffer . append ( line . reverse ( ) ) ; buffer . append ( " next char: " ) ; try { if ( ! eof ( ) ) { buffer . append ( "'" + ( char ) peek ( ) + "'" ) ; } else { buffer . append ( "EOF" ) ; } } catch ( IOException ioe ) { buffer . append ( "ERROR: " + ioe . getMessage ( ) ) ; } return buffer . toString ( ) ; }
tr	2	private static String jsonArray ( Object ... elements ) { if ( elements . length == 0 ) { return "[]" ; } StringBuilder result = new StringBuilder ( "[" + elements [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < elements . length ; i ++ ) { result . append ( " " ) ; result . append ( elements [ i ] . toString ( ) ) ; } result . append ( "]" ) ; return result . toString ( ) ; }
tr	0	@ Override public boolean setPacketFields ( Map < String , Object > in ) { return true ; }
tr	4	public ArrayList < Point > checkMove ( ArrayList < Point > spot , TTTBoard board , char turn ) { ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; Stack < TTTBoard > boards = new Stack < TTTBoard > ( ) ; for ( int i = 0 ; i < spot . size ( ) ; i ++ ) { TTTBoard aBoard = new TTTBoard ( board ) ; aBoard . getBoard ( ) [ spot . get ( i ) . x ] [ spot . get ( i ) . y ] = turn ; aBoard . setStart ( spot . get ( i ) ) ; if ( spot . size ( ) < 6 ) { if ( aBoard . checkWin ( ) ) { winningSpots . add ( spot . get ( i ) ) ; } else { boards . add ( aBoard ) ; } } else { boards . add ( aBoard ) ; } } if ( ! winningSpots . isEmpty ( ) ) { return winningSpots ; } else { winningSpots = checkMove2 ( boards , turn ) ; } return winningSpots ; }
tr	8	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final WorkPayment other = ( WorkPayment ) obj ; if ( this . payment != other . payment && ( this . payment == null || ! this . payment . equals ( other . payment ) ) ) { return false ; } if ( this . workType != other . workType && ( this . workType == null || ! this . workType . equals ( other . workType ) ) ) { return false ; } return true ; }
tr	0	public Sprite ( BufferedImage image , int frameHeight , int numberOfTiles , int frameDurations [ ] ) { animation = new Animation ( ) ; SpriteLoader . parseSprite ( image , frameHeight , numberOfTiles , frameDurations , animation ) ; }
tr	0	public void setPrpMoaTipo ( String prpMoaTipo ) { this . prpMoaTipo = prpMoaTipo ; }
tr	9	public AbstractHttpData ( String name , Charset charset , long size ) throws NullPointerException , IllegalArgumentException { if ( name == null ) { throw new NullPointerException ( "name" ) ; } name = name . trim ( ) ; if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "empty name" ) ; } for ( int i = 0 ; i < name . length ( ) ; i ++ ) { char c = name . charAt ( i ) ; if ( c > 127 ) { throw new IllegalArgumentException ( "name contains non-ascii character: " + name ) ; } switch ( c ) { case = : case   : case ; : case   : case 	 : case '' : case '' : case  : case 0b : throw new IllegalArgumentException ( "name contains one of the following prohibited characters: " + "= ; \\t\\r\\n\\v\\f: " + name ) ; } } this . name = name ; if ( charset != null ) { setCharset ( charset ) ; } definedSize = size ; }
tr	8	@ SuppressWarnings ( "deprecation" ) @ EventHandler public void click ( InventoryClickEvent event ) { Player player = ( Player ) event . getView ( ) . getPlayer ( ) ; OpenQuestLog oql = getOpenQuestLog ( player ) ; if ( oql == null ) return ; event . setCancelled ( true ) ; if ( event . getView ( ) != oql . getInventoryView ( ) ) { player . updateInventory ( ) ; return ; } if ( event . getCurrentItem ( ) == null ) { player . updateInventory ( ) ; return ; } Quest sel = oql . getSelected ( ) ; if ( sel == null ) { if ( event . getSlot ( ) == 27 ) { oql . setViewingCompleted ( ! oql . isViewingCompleted ( ) ) ; oql . update ( ) ; } else { int index = ( oql . getPage ( ) - 1 ) * 27 + event . getSlot ( ) ; Quest [ ] q = oql . isViewingCompleted ( ) ? oql . getCurrentCompletedList ( ) : oql . getCurrentQuestList ( ) ; if ( index < q . length ) { oql . setSelected ( q [ index ] ) ; oql . update ( ) ; } } } else if ( event . getSlot ( ) == 27 ) { oql . setSelected ( null ) ; oql . update ( ) ; } player . updateInventory ( ) ; }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( JOptionPane . showConfirmDialog ( frame , "Are you sure to close this window?" , "Really Closing?" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { btn . setEnabled ( true ) ; } }
tr	3	static float sqrt ( float n ) { float low = 0 , high = n ; float mid = ( low + high ) / 2 ; while ( Math . abs ( mid * mid - n ) > 0.00001 ) { if ( mid * mid < n ) low = mid ; else if ( mid * mid > n ) high = mid ; mid = ( low + high ) / 2 ; } return mid ; }
tr	1	public static String SQLdecrypted ( String decrypt ) { String decrypted = "" ; try { SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "DES" ) ; DESKeySpec keySpec = new DESKeySpec ( secretSalt . getBytes ( ) ) ; SecretKey key = keyFactory . generateSecret ( keySpec ) ; DesEncrypter encrypter = new DesEncrypter ( key ) ; decrypted = encrypter . decrypt ( decrypt ) ; } catch ( Exception e ) { Error_Frame . Error ( e . toString ( ) ) ; } return decrypted ; }
tr	9	public void update ( List < Zombie > targets ) { if ( this . isAlive ( ) ) { { synchronized ( this . particles ) { if ( ! this . particles . isEmpty ( ) ) { Iterator < Particle > it = this . particles . iterator ( ) ; while ( it . hasNext ( ) ) { Particle p = it . next ( ) ; p . update ( ) ; if ( ! p . isAlive ( ) || p . outOfBounds ( ) ) { it . remove ( ) ; continue ; } } } } } { if ( ! targets . isEmpty ( ) ) { double xD = 1000 ; double yD = 1000 ; double dist = Math . sqrt ( ( xD * xD ) + ( yD * yD ) ) ; if ( this . target != null ) { xD = this . target . x - this . x ; yD = this . target . y - this . y ; dist = Math . sqrt ( ( xD * xD ) + ( yD * yD ) ) ; } synchronized ( targets ) { Iterator < Zombie > it = targets . iterator ( ) ; while ( it . hasNext ( ) ) { Zombie z = it . next ( ) ; double xD2 = z . x - this . x ; double yD2 = z . y - this . y ; double dist2 = Math . sqrt ( ( xD2 * xD2 ) + ( yD2 * yD2 ) ) ; if ( ( ! z . isDead ( ) && ( dist2 < dist ) ) && ( dist2 <= Turret . ATTACK_RADIUS ) ) { this . target = z ; } } } if ( this . target != null ) { this . theta = Math . atan2 ( ( this . y - this . target . y ) , ( this . x - this . target . x ) ) - ( Math . PI / 2 ) ; } } } if ( ( this . target != null ) && ( this . target . isDead ( ) ) ) this . target = null ; if ( this . target != null ) this . fire ( ) ; } }
tr	8	public Object execute ( String sql , Object [ ] params , ResultSetExtractor extractor ) throws RemoteException { checkStarted ( ) ; PreparedStatement ps = null ; ResultSet rs = null ; try { ps = getConnection ( ) . prepareStatement ( sql ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; ++ i ) { Object o = params [ i ] ; if ( o == null ) ps . setNull ( ( i + 1 ) , Types . null ) ; else ps . setObject ( ( i + 1 ) , params [ i ] ) ; } } rs = ps . executeQuery ( ) ; return extractor . extract ( rs ) ; } catch ( SQLException e ) { Logger . error ( "error while executing sql statement" , e ) ; throw new RemoteException ( "error while executing sql statement: " + e . getMessage ( ) , e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Throwable t ) { Logger . error ( "error while closing resultset" , t ) ; } } if ( ps != null ) { try { ps . close ( ) ; } catch ( Throwable t2 ) { Logger . error ( "error while closing statement" , t2 ) ; } } } }
tr	5	public String loadApp ( String appClassname ) { String startingApp = null ; try { Log . d ( TAG , "Loading app " + appClassname ) ; startingApp = appClassname ; class < ? extends Object > appClass = ( class < ? extends Object > ) class . forName ( appClassname ) ; NetLoadableConsoleApp app = ( NetLoadableConsoleApp ) appClass . newInstance ( ) ; if ( mAppMap . containsKey ( app . loadablename ( ) ) ) throw new Exception ( "Class " + appClassname + " is using app name " + app . loadablename ( ) + " but that name is already in use by class " + mAppMap . get ( app . loadablename ( ) ) . getClass ( ) . getName ( ) ) ; String appLoadableName = app . loadablename ( ) ; mAppMap . put ( appLoadableName , app ) ; Log . i ( TAG , appClassname + " Loaded as " + appLoadableName ) ; return appLoadableName ; } catch ( ClassNotFoundException nfe ) { Log . e ( TAG , "Can't load " + startingApp + ": ClassNotFoundException (typo in config file?)" ) ; } catch ( Exception e ) { Log . e ( TAG , "Can't load " + startingApp + ": " + e . getClass ( ) . getName ( ) + " exception: " + e . getMessage ( ) ) ; } return null ; }
tr	8	@ Override public void run ( ) { isRunning = true ; while ( isRunning ) { if ( mediaPlayer != null ) { if ( ! warningPassed && passedTime > TIME_GREEN ) { warningPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "dong03.wav" ) ; } if ( ! finishPassed && passedTime > TIME_YELLOW ) { finishPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "end.wav" ) ; } } try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { repaint ( ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } Thread . yield ( ) ; } }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Service other = ( Service ) obj ; if ( clusterRef == null ) { if ( other . clusterRef != null ) return false ; } else if ( ! clusterRef . equals ( other . clusterRef ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( serviceState != other . serviceState ) return false ; if ( type != other . type ) return false ; return true ; }
tr	7	private Object readJSON ( ) throws JSONException { switch ( read ( 3 ) ) { case zipObject : return readObject ( ) ; case zipArrayString : return readArray ( true ) ; case zipArrayValue : return readArray ( false ) ; case zipEmptyObject : return new JSONObject ( ) ; case zipEmptyArray : return new JSONArray ( ) ; case zipTrue : return boolean . true ; case zipFalse : return boolean . false ; default : return JSONObject . null ; } }
tr	6	public void openFile ( String fileName ) { if ( m_bMpegPlaying ) { m_bKeepRunning = false ; } if ( m_inputStream != null ) { try { m_inputStream . close ( ) ; } catch ( IOException e ) { showDialog ( WARNING , e . getMessage ( ) ) ; } } if ( fileName != null ) { try { try { URL url = new URL ( fileName ) ; m_inputStream = new java . io . BufferedInputStream ( url . openStream ( ) ) ; } catch ( MalformedURLException e ) { m_inputStream = new java . io . BufferedInputStream ( new FileInputStream ( fileName ) ) ; } } catch ( IOException e ) { showDialog ( ERROR , e . getMessage ( ) ) ; } } else showDialog ( ERROR , "null FileName" ) ; }
tr	3	public Simulator ( ) throws InterruptedException { GUIManager . simulator = this ; phase = Phase . INIT ; Thread simulatorThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { Log . finer ( "maked Simulation Instance." ) ; setting ( ) ; int periodTime = Conf . CountPeriod ; long start , end , - , sleepTime ; while ( true ) { start = System . currentTimeMillis ( ) ; select ( ) ; end = System . currentTimeMillis ( ) ; - = end - start ; sleepTime = 1000 / periodTime - - ; try { Thread . sleep ( ( sleepTime >= 0 ? sleepTime : 0 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ) ; simulatorThread . start ( ) ; Log . finer ( "end of Simulation Instance." ) ; }
tr	3	public DepartmentDTO deptInfo ( int deptNo ) { String query = "select * from department where deptno = ?" ; PreparedStatement pstmt = null ; ResultSet rs = null ; DepartmentDTO deptDto = null ; try { pstmt = dbConn . getConn ( ) . prepareStatement ( query ) ; pstmt . setInt ( 1 , deptNo ) ; rs = pstmt . executeQuery ( ) ; rs . next ( ) ; deptDto = new DepartmentDTO ( rs . getInt ( 1 ) , rs . getString ( 2 ) , rs . getInt ( 3 ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "deleteDepartment(String) - \uBD80\uC11C \uC815\uBCF4 \uC0AD\uC81C \uC131\uACF5" ) ; } } catch ( SQLException ee ) { logger . error ( "deleteDepartment(String) - \uBD80\uC11C \uC0AD\uC81C \uC2E4\uD328!!" ) ; } finally { try { pstmt . close ( ) ; } catch ( SQLException e ) { } } return deptDto ; }
tr	2	private void tarkistaKirjautuminen ( ) { kayttajatunnus = kayttajatunnusField . getText ( ) ; salasana = ripoffPassword ( salasanaField . getPassword ( ) ) ; Kayttajatunnus kayttaja = Database . tarkastaKirjautuminen ( kayttajatunnus , salasana ) ; if ( kayttaja == null ) { fail ( ) ; } else { if ( kayttaja . getSalasana ( ) . equals ( salasana ) ) { kirjaudu ( kayttaja ) ; } else { fail ( ) ; } } }
tr	6	public static String classNamesToString ( Collection < class < ? >> classes ) { if ( CollectionUtils . isEmpty ( classes ) ) { return "[]" ; } StringBuilder sb = new StringBuilder ( "[" ) ; for ( Iterator < class < ? >> it = classes . iterator ( ) ; it . hasNext ( ) ; ) { class < ? > clazz = it . next ( ) ; sb . append ( clazz . getName ( ) ) ; if ( it . hasNext ( ) ) { sb . append ( "  " ) ; } } sb . append ( "]" ) ; return sb . toString ( ) ; }
tr	1	public void stopSliding ( ) { if ( slider != null ) { slider . restart ( ) ; slider . stop ( ) ; } count = 0 ; }
tr	5	public static Trajectory generate ( Config config , Strategy strategy , double start_vel , double start_heading , double goal_pos , double goal_vel , double goal_heading ) { if ( strategy == AutomaticStrategy ) { strategy = chooseStrategy ( start_vel , goal_vel , config . max_vel ) ; } Trajectory traj ; if ( strategy == StepStrategy ) { double impulse = ( goal_pos / config . max_vel ) / config . dt ; int time = ( int ) ( Math . floor ( impulse ) ) ; traj = secondOrderFilter ( 1 , 1 , config . dt , config . max_vel , config . max_vel , impulse , time , TrapezoidalIntegration ) ; } else if ( strategy == TrapezoidalStrategy ) { double start_discount = .5 * start_vel * start_vel / config . max_acc ; double end_discount = .5 * goal_vel * goal_vel / config . max_acc ; double adjusted_max_vel = Math . min ( config . max_vel , Math . sqrt ( config . max_acc * goal_pos - start_discount - end_discount ) ) ; double t_rampup = ( adjusted_max_vel - start_vel ) / config . max_acc ; double x_rampup = start_vel * t_rampup + .5 * config . max_acc * t_rampup * t_rampup ; double t_rampdown = ( adjusted_max_vel - goal_vel ) / config . max_acc ; double x_rampdown = adjusted_max_vel * t_rampdown - .5 * config . max_acc * t_rampdown * t_rampdown ; double x_cruise = goal_pos - x_rampdown - x_rampup ; int time = ( int ) ( ( t_rampup + t_rampdown + x_cruise / adjusted_max_vel ) / config . dt + .5 ) ; int f1_length = ( int ) Math . ceil ( ( adjusted_max_vel / config . max_acc ) / config . dt ) ; double impulse = ( goal_pos / adjusted_max_vel ) / config . dt - start_vel / config . max_acc / config . dt + start_discount + end_discount ; traj = secondOrderFilter ( f1_length , 1 , config . dt , start_vel , adjusted_max_vel , impulse , time , TrapezoidalIntegration ) ; } else if ( strategy == SCurvesStrategy ) { double adjusted_max_vel = Math . min ( config . max_vel , ( - config . max_acc * config . max_acc + Math . sqrt ( config . max_acc * config . max_acc * config . max_acc * config . max_acc + 4 * config . max_jerk * config . max_jerk * config . max_acc * goal_pos ) ) / ( 2 * config . max_jerk ) ) ; int f1_length = ( int ) Math . ceil ( ( adjusted_max_vel / config . max_acc ) / config . dt ) ; int f2_length = ( int ) Math . ceil ( ( config . max_acc / config . max_jerk ) / config . dt ) ; double impulse = ( goal_pos / adjusted_max_vel ) / config . dt ; int time = ( int ) ( Math . ceil ( f1_length + f2_length + impulse ) ) ; traj = secondOrderFilter ( f1_length , f2_length , config . dt , 0 , adjusted_max_vel , impulse , time , TrapezoidalIntegration ) ; } else { return null ; } double total_heading_change = goal_heading - start_heading ; for ( int i = 0 ; i < traj . getNumSegments ( ) ; ++ i ) { traj . segments_ [ i ] . heading = start_heading + total_heading_change * ( traj . segments_ [ i ] . pos ) / traj . segments_ [ traj . getNumSegments ( ) - 1 ] . pos ; } return traj ; }
tr	0	public void run ( ) { m$ . Cmd . do ( methodName ) ; }
tr	3	private void insert ( T value , BSTNode < T > node ) { if ( value . compareTo ( node . getData ( ) ) < 0 ) { if ( node . getLeft ( ) . isEmpty ( ) ) { node . getLeft ( ) . setParent ( node ) ; node . getLeft ( ) . setData ( value ) ; node . getLeft ( ) . setLeft ( new BSTNode < T > ( ) ) ; node . getLeft ( ) . setRight ( new BSTNode < T > ( ) ) ; } else { insert ( value , ( BSTNode < T > ) node . getLeft ( ) ) ; } } else { if ( node . getRight ( ) . isEmpty ( ) ) { node . getRight ( ) . setParent ( node ) ; node . getRight ( ) . setData ( value ) ; node . getRight ( ) . setLeft ( new BSTNode < T > ( ) ) ; node . getRight ( ) . setRight ( new BSTNode < T > ( ) ) ; } else { insert ( value , ( BSTNode < T > ) node . getRight ( ) ) ; } } }
tr	4	@ Override public void run ( ) { ArrayList < float > localCosts = new ArrayList < > ( ) ; for ( int i = this . threadID ; i < this . vGraph . getNodeCount ( ) ; i += this . numOfThreads ) { for ( int j = i + 1 ; j < this . vGraph . getNodeCount ( ) ; j ++ ) { float f = this . vGraph . calculateInnerDistanceForNodes ( i , j ) ; if ( ! f . isInfinite ( ) ) localCosts . add ( f ) ; } } try { this . vGraph . addCosts ( localCosts ) ; } catch ( GraphException gre ) { } }
tr	9	protected boolean fireAndHandleEvent ( WordTokenizer tokenizer , SpellCheckEvent event ) { fireSpellCheckEvent ( event ) ; String word = event . getInvalidWord ( ) ; switch ( event . getAction ( ) ) { case SpellCheckEvent . INITIAL : break ; case SpellCheckEvent . IGNORE : break ; case SpellCheckEvent . IGNOREALL : ignoreAll ( word ) ; break ; case SpellCheckEvent . REPLACE : tokenizer . replaceWord ( event . getReplaceWord ( ) ) ; break ; case SpellCheckEvent . REPLACEALL : String replaceAllWord = event . getReplaceWord ( ) ; if ( ! autoReplaceWords . containsKey ( word ) ) { autoReplaceWords . put ( word , replaceAllWord ) ; } tokenizer . replaceWord ( replaceAllWord ) ; break ; case SpellCheckEvent . ADDTODICT : String addWord = event . getReplaceWord ( ) ; if ( ! addWord . equals ( word ) ) tokenizer . replaceWord ( addWord ) ; userdictionary . addWord ( addWord ) ; break ; case SpellCheckEvent . CANCEL : return true ; default : throw new IllegalArgumentException ( "Unhandled case." ) ; } return false ; }
tr	9	protected static String calculateMD5ForSong ( final Song aSong , final FindDuplicateOption aOption , final HashCalculator aCalculator ) throws Exception { aCalculator . resetInit ( ) ; if ( aOption . isAlbum ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getAlbum ( ) ) ) ; } if ( aOption . isAlbumArtist ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getAlbumArtist ( ) ) ) ; } if ( aOption . isArtist ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getArtist ( ) ) ) ; } if ( aOption . isComposer ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getComposer ( ) ) ) ; } if ( aOption . isGenre ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getGenre ( ) ) ) ; } if ( aOption . isName ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getName ( ) ) ) ; } if ( aOption . isTitle ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getTitle ( ) ) ) ; } if ( aOption . isYear ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getYear ( ) ) ) ; } if ( aOption . isLength ( ) ) { aCalculator . updateHash ( String . valueOf ( aSong . getDurationMillis ( ) ) ) ; } return aCalculator . finalizeHash ( ) ; }
tr	0	public static ByteBuffer stringToBuffer ( int id ) { String s = Integer . valueOf ( id ) . toString ( ) ; return stringToBuffer ( s ) ; }
tr	6	public static void refresh_table ( Table table , String query ) throws SQLException { int col_count = table . getColumnCount ( ) ; Connection conn = Connection_pooling . cpds . getConnection ( ) ; Statement stmt = conn . createStatement ( ) ; int size = 0 ; ResultSet rst = stmt . executeQuery ( query ) ; if ( rst . last ( ) ) { size = rst . getRow ( ) ; rst . beforeFirst ( ) ; } String [ ] [ ] data = new String [ size ] [ col_count ] ; String tmp ; for ( int i = 0 ; rst . next ( ) ; i ++ ) { for ( int j = 0 ; j < col_count ; j ++ ) { tmp = rst . getString ( j + 1 ) ; data [ i ] [ j ] = tmp == null ? "" : tmp ; } } conn . close ( ) ; rst . close ( ) ; stmt . close ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { TableItem tableItem = new TableItem ( table , SWT . NONE ) ; tableItem . setText ( data [ i ] ) ; } TableColumn [ ] clmns = table . getColumns ( ) ; for ( int i = 0 ; i < clmns . length ; i ++ ) { clmns [ i ] . pack ( ) ; } add_sort_column ( table , data ) ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Station station = ( Station ) o ; if ( id != station . id ) return false ; if ( name != null ? ! name . equals ( station . name ) : station . name != null ) return false ; return true ; }
tr	2	public void render ( Graphics2D g ) { if ( item != null ) { item . render ( g ) ; g . setColor ( Color . WHITE ) ; Font origFont = g . getFont ( ) ; g . setFont ( origFont . deriveFont ( 15.0f ) . deriveFont ( Font . BOLD ) ) ; g . drawString ( count > 99 ? "99+" : Integer . toString ( count ) , 4 , Game . TILE_HEIGHT - 4 ) ; g . setFont ( origFont ) ; } }
tr	5	public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( "No file specified" ) ; System . exit ( rc ) ; } try ( FileReader input = new FileReader ( args [ 0 ] ) ) { Scanner scanner = new Scanner ( new BufferedReader ( input ) ) ; Parser parser = new Parser ( scanner ) ; package p = parser . parse ( ) ; IdTable table = new IdTable ( ) ; Analyzer analyzer = new Analyzer ( ) ; analyzer . visitPackage ( p , table ) ; if ( Reporter . error ) { System . exit ( rc ) ; } else { Encoder encoder = new Encoder ( ) ; encoder . visitPackage ( p , null ) ; int pos = args [ 0 ] . lastIndexOf ( ".java" ) ; String objectFileName = args [ 0 ] . substring ( 0 , pos ) + ".mJAM" ; ObjectFile objF = new ObjectFile ( objectFileName ) ; if ( objF . write ( ) ) { Reporter . emit ( "Object File Failed." ) ; } } System . exit ( 0 ) ; } catch ( FileNotFoundException e ) { Reporter . emit ( e . getMessage ( ) ) ; } catch ( IOException e ) { Reporter . emit ( e . getMessage ( ) ) ; } System . exit ( rc ) ; }
tr	3	public void addControllerMap ( String name , Map < String , ? extends Object > attribs ) { if ( getControllersMap ( ) != null ) { getControllersMap ( ) . put ( name , attribs ) ; } else { this . setControllersMap ( new HashMap < String , Map < String , ? extends Object >> ( ) ) ; this . getControllersMap ( ) . put ( name , attribs ) ; } }
tr	7	public ArrayList < UserProfile > fetchAllProfiles ( ) throws SQLConnectionException , SQLQueryException { ArrayList < UserProfile > profiles = new ArrayList < UserProfile > ( ) ; Statement st ; try { st = dbCon . createStatement ( ) ; } catch ( SQLException e ) { if ( dbCon != null ) try { dbCon . close ( ) ; } catch ( SQLException e2 ) { e2 . printStackTrace ( ) ; } throw new SQLConnectionException ( e ) ; } finally { } ResultSet rs ; try { rs = st . executeQuery ( "SELECT rowid  name FROM userprofile" ) ; } catch ( SQLException e ) { throw new SQLQueryException ( e ) ; } try { while ( rs . next ( ) ) { UserProfile up = new UserProfile ( rs . getInt ( "rowid" ) , rs . getString ( "name" ) ) ; profiles . add ( up ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } try { st . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return profiles ; }
tr	5	private void siftDown ( int index ) { final Node < T , P > target = ( Node < T , P > ) storage [ index ] ; final P PRIORITY = target . priority ; for ( ; ; ) { P minChildPriority = PRIORITY ; int minChildIndex = - 1 ; computeChildrenIndices ( index ) ; for ( int i : indices ) { if ( i == - 1 ) { break ; } P tentative = ( ( Node < T , P > ) storage [ i ] ) . priority ; if ( minChildPriority . compareTo ( tentative ) > 0 ) { minChildPriority = tentative ; minChildIndex = i ; } } if ( minChildIndex == - 1 ) { storage [ index ] = target ; target . index = index ; return ; } storage [ index ] = storage [ minChildIndex ] ; ( ( Node < T , P > ) storage [ index ] ) . index = index ; index = minChildIndex ; } }
tr	9	public static void main ( String [ ] args ) throws Exception { int e1TotalWins = 0 , totalDraws = 0 , e1TotalLoses = 0 , e1WinAsPlayer1 = 0 , e1DrawAsPlayer1 = 0 , e1LoseAsPlayer1 = 0 , e1WinAsPlayer2 = 0 , e1DrawAsPlayer2 = 0 , e1LoseAsPlayer2 = 0 , e2TotalWins = 0 , e2TotalLoses = 0 , e2WinAsPlayer1 = 0 , e2DrawAsPlayer1 = 0 , e2LoseAsPlayer1 = 0 , e2WinAsPlayer2 = 0 , e2DrawAsPlayer2 = 0 , e2LoseAsPlayer2 = 0 ; Board boardTest1 = null ; Board initialPositionTest1 = null ; Board [ ] boardCollectionTest1 = null ; int currentIndexTest1 = 0 ; int numberOfMoveTest1 = 0 ; Player [ ] playersTest1 = { new Player ( "BoltzmannH5" , "BoltzmannH5" , "w" , 100000 ) , new Player ( "Charles_2" , "Charles_2" , "b" , 0 ) } ; int totalNumberOfMovesTest1 = 46 ; try { FileInputStream fisTest1 = new FileInputStream ( "50_boards_3.sav" ) ; ObjectInputStream oisTest1 = new ObjectInputStream ( fisTest1 ) ; boardCollectionTest1 = ( Board [ ] ) oisTest1 . readObject ( ) ; } catch ( Exception e ) { System . err . println ( "Error" + e . getMessage ( ) ) ; } long startTime = 0 , endTime = 0 ; startTime = System . currentTimeMillis ( ) ; for ( int testIndex = 1 ; testIndex <= 100 ; ++ testIndex ) { System . out . println ( "Test1: " + testIndex + " / 100" ) ; currentIndexTest1 = 0 ; numberOfMoveTest1 = 0 ; Player tmp = playersTest1 [ 0 ] ; playersTest1 [ 0 ] = playersTest1 [ 1 ] ; playersTest1 [ 1 ] = tmp ; if ( testIndex % 2 == 1 ) { boardTest1 = boardCollectionTest1 [ ( Integer ) testIndex / 2 ] ; initialPositionTest1 = boardTest1 . duplicate ( ) ; } else { boardTest1 = initialPositionTest1 . duplicate ( ) ; } while ( numberOfMoveTest1 < totalNumberOfMovesTest1 ) { if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "BoltzmannH5" ) ) { Tuple < Integer , Integer > move ; MonteCarloH5Boltzmann mc = new MonteCarloH5Boltzmann ( boardTest1 . duplicate ( ) , playersTest1 [ currentIndexTest1 ] . getColor ( ) , numberOfMoveTest1 , totalNumberOfMovesTest1 ) ; move = mc . uct ( playersTest1 [ currentIndexTest1 ] . getSimulationNumber ( ) ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } else if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "Charles_2" ) ) { Tuple < Integer , Integer > move ; Charles_2 charles = new Charles_2 ( playersTest1 [ currentIndexTest1 ] . getColor ( ) , boardTest1 ) ; move = charles . getMove ( ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } } String gameOutcome = Rules . calculateScore ( boardTest1 ) ; BufferedWriter outputTest1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; outputTest1 . append ( "Match #" + testIndex ) ; outputTest1 . newLine ( ) ; outputTest1 . append ( "Player 1: " + playersTest1 [ 0 ] . getName ( ) + " Player 2: " + playersTest1 [ 1 ] . getName ( ) ) ; outputTest1 . newLine ( ) ; if ( gameOutcome . equals ( "0" ) ) { ++ totalDraws ; outputTest1 . append ( "Result: draw" ) ; outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1DrawAsPlayer1 ++ ; e2DrawAsPlayer2 ++ ; } else { e1DrawAsPlayer2 ++ ; e2DrawAsPlayer1 ++ ; } } else { if ( gameOutcome . equals ( playersTest1 [ 0 ] . getColor ( ) ) ) { outputTest1 . append ( "Result: " + playersTest1 [ 0 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer1 ++ ; e2LoseAsPlayer2 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer1 ++ ; e1LoseAsPlayer2 ++ ; } } else { outputTest1 . append ( "Result: " + playersTest1 [ 1 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 1 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer2 ++ ; e2LoseAsPlayer1 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer2 ++ ; e1LoseAsPlayer1 ++ ; } } outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; } } endTime = System . currentTimeMillis ( ) ; BufferedWriter output1Test1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "*Summary (100k) 3-point board (t=2.5)*" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Draw occurred: " + totalDraws ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 total wins: " + e2TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 total wins: " + e1TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Play time: " + ( endTime - startTime ) / 1000 + " seconds." ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #1 : " + e2WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #2 : " + e2WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #1 : " + e2DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #2 : " + e2DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #1 : " + e2LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #2 : " + e2LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #1 : " + e1WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #2 : " + e1WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #1 : " + e1DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #2 : " + e1DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #1 : " + e1LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #2 : " + e1LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . close ( ) ; }
tr	4	private void assignRoutesWithClosestDepotWithNeighbourCheckHeuristic ( ) { boolean [ ] clientMap = new boolean [ problemInstance . customerCount ] ; int assigned = 0 ; while ( assigned < problemInstance . customerCount ) { int clientNo = Utility . randomIntInclusive ( problemInstance . customerCount - 1 ) ; if ( clientMap [ clientNo ] ) continue ; clientMap [ clientNo ] = true ; assigned ++ ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { if ( periodAssignment [ period ] [ clientNo ] == false ) continue ; int depot = RouteUtilities . closestDepot ( clientNo ) ; insertClientToRouteThatMinimizesTheIncreaseInActualCost ( clientNo , depot , period ) ; } } }
tr	5	public boolean contains ( AABB aabb ) { final Vector3f h1 = getHalfsize ( ) ; final Vector3f h2 = aabb . getHalfsize ( ) ; final Vector3f p1 , p2 ; return h1 . x >= h2 . x && h1 . y >= h2 . y && h1 . z >= h2 . z && Math . abs ( ( p2 = aabb . getPosition ( ) ) . x - ( p1 = getPosition ( ) ) . x ) <= h1 . x - h2 . x && Math . abs ( p2 . y - p1 . y ) <= h1 . y - h2 . y && Math . abs ( p2 . z - p1 . z ) <= h1 . z - h2 . z ; }
tr	0	public JButton getButtonClose ( ) { return btnClose ; }
tr	3	public void add ( long tmpID , double tmpPrice , int tmpVol , Time tmpTime ) { OneData tmpData = new OneData ( tmpID , tmpPrice , tmpVol , tmpTime ) ; int len = getLength ( ) ; int indexInsert = 0 ; if ( len > 1 ) { indexInsert = getPosToInsert ( tmpPrice , 0 , len - 1 ) ; } else if ( len == 1 ) { if ( tmpPrice >= myList . get ( 0 ) . getPrice ( ) ) { indexInsert = 1 ; } } myList . add ( indexInsert , tmpData ) ; allID . add ( indexInsert , tmpID ) ; }
tr	9	public void verify ( Request . ParsedRequest parsedRequest , OAuthParams . OAuth1Params oAuth1Params ) throws MalformedRequest { if ( parsedRequest . scheme ( ) == null ) throwMalformedException ( SCHEME ) ; else if ( parsedRequest . host ( ) == null ) throwMalformedException ( HOST ) ; else if ( parsedRequest . port ( ) < 0 ) throwMalformedException ( PORT ) ; else if ( parsedRequest . verb ( ) == null ) throwMalformedException ( VERB ) ; else if ( parsedRequest . path ( ) == null ) throwMalformedException ( PATH ) ; else if ( oAuth1Params . signatureMethod ( ) == null || ! oAuth1Params . signatureMethod ( ) . equals ( OAuthParams . HMAC_SHA1 ) ) { throw new MalformedRequest ( UNSUPPORTED_METHOD + oAuth1Params . signatureMethod ( ) ) ; } else if ( oAuth1Params . version ( ) != null && ! oAuth1Params . version ( ) . equals ( OAuthParams . ONE_DOT_OH ) && ! oAuth1Params . version ( ) . toLowerCase ( ) . equals ( OAuthParams . ONE_DOT_OH_A ) ) { throw new MalformedRequest ( UNSUPPORTED_VERSION + oAuth1Params . version ( ) ) ; } else if ( oAuth1Params . token ( ) != null && ( oAuth1Params . token ( ) . indexOf (   ) > 0 || oAuth1Params . token ( ) . length ( ) > MaxTokenLength ) ) { throw new MalformedRequest ( MALFORMED_TOKEN + oAuth1Params . token ( ) ) ; } }
tr	4	public int getAction ( Game game , long dueTime ) { if ( key == KeyEvent . VK_UP ) return 0 ; if ( key == KeyEvent . VK_RIGHT ) return 1 ; if ( key == KeyEvent . VK_DOWN ) return 2 ; if ( key == KeyEvent . VK_LEFT ) return 3 ; return 4 ; }
tr	5	public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) System . exit ( 0 ) ; else if ( e . getKeyCode ( ) == KeyEvent . VK_UP ) { yacc = - acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) { yacc = acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) { xacc = acc ; } else if ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) { xacc = - acc ; } }
tr	7	public void give1 ( ) { while ( ! Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "50 000" ) ) { if ( Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "100 000" ) || Widgets . get ( 335 , 49 ) . getText ( ) . contains ( "150 000" ) ) { Widgets . get ( 335 , 9 ) . click ( true ) ; } Widgets . get ( 335 ) . getChild ( 53 ) . click ( true ) ; Time . sleep ( 1000 ) ; while ( Widgets . get ( 137 , 53 ) . isOnScreen ( ) ) { Time . sleep ( 1000 ) ; Widgets . get ( 335 ) . getChild ( 53 ) . click ( true ) ; } Keyboard . sendText ( "50000" , true ) ; Time . sleep ( 1000 ) ; } Widgets . get ( 335 , 18 ) . click ( true ) ; for ( ; ! Widgets . get ( 334 ) . getChild ( 8 ) . isOnScreen ( ) ; ) { Time . sleep ( 100 ) ; } Widgets . get ( 334 , 21 ) . click ( true ) ; for ( ; Widgets . get ( 335 ) . getChild ( 9 ) . isOnScreen ( ) || Widgets . get ( 334 ) . getChild ( 8 ) . isOnScreen ( ) ; ) { Time . sleep ( 100 ) ; } play = "" ; }
tr	4	public void move ( ) { m_x += m_velocityX ; m_y += m_velocityY ; if ( m_x < 0 ) { m_x = 0 ; m_velocityX = - m_velocityX ; } else if ( m_x > m_rightBound ) { m_x = m_rightBound ; m_velocityX = - m_velocityX ; } if ( m_y < 0 ) { m_y = 0 ; m_velocityY = - m_velocityY ; } else if ( m_y > m_bottomBound ) { m_y = m_bottomBound ; m_velocityY = - m_velocityY ; } }
tr	4	@ Override public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( other == null ) { return false ; } if ( other instanceof HourMinuteInDay ) { HourMinuteInDay otherDayTime = ( HourMinuteInDay ) other ; return ( this . hour == otherDayTime . hour && this . minute == otherDayTime . minute ) ; } else { return false ; } }
tr	0	public void setCAVVResultCode ( String value ) { this . cavvResultCode = value ; }
tr	0	public void showMessageBox ( String sender , String message , boolean option ) { }
tr	0	public MapMerge ( Genome genome , String name , String version , String jobID , int mapID ) { super ( genome , Genome . namespace , name , version , jobID ) ; this . mapID = mapID ; }
tr	2	public void reanudarSonidos ( ) { for ( Sonido sonido : sonidos ) { if ( sonido . isAlive ( ) ) sonido . play ( ) ; } }
tr	8	protected void addSnapshot ( String strSnapshot ) { boolean isDuplicate = false ; for ( int i = 0 ; i < mnuSnapshot . getItemCount ( ) ; i ++ ) { JMenuItem m = mnuSnapshot . getItem ( i ) ; if ( m == null ) continue ; if ( strSnapshot . equalsIgnoreCase ( m . getText ( ) ) == true ) { isDuplicate = true ; break ; } } if ( isDuplicate == true ) return ; String strSnapshotFilename = fileImport . getName ( ) + "-" + strSubjectID + "-" + strSnapshot + ".ss" ; try { DataOutputStream out = new DataOutputStream ( new FileOutputStream ( strSnapshotFilename ) ) ; Point2D point = getCanvas ( ) . getCamera ( ) . getViewBounds ( ) . getCenter2D ( ) ; double scale = getCanvas ( ) . getCamera ( ) . getViewScale ( ) ; out . writeDouble ( point . getX ( ) ) ; out . writeDouble ( point . getY ( ) ) ; out . writeDouble ( scale ) ; out . writeInt ( dustList . length ) ; for ( int i = 0 ; i < dustList . length ; i ++ ) { out . writeDouble ( dustList [ i ] . getGlobalBounds ( ) . x ) ; out . writeDouble ( dustList [ i ] . getGlobalBounds ( ) . y ) ; } out . writeInt ( magnetList . size ( ) ) ; for ( int i = 0 ; i < magnetList . size ( ) ; i ++ ) { Magnet m = ( Magnet ) magnetList . get ( i ) ; out . writeInt ( m . getVarIndex ( ) ) ; out . writeDouble ( m . getGlobalBounds ( ) . x ) ; out . writeDouble ( m . getGlobalBounds ( ) . y ) ; out . writeInt ( m . getMagnitude ( ) ) ; out . writeDouble ( m . getThreshold ( ) ) ; } controlWindow . saveSnapshot ( out ) ; out . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } JMenuItem mnuitemASnapshot = new JMenuItem ( strSnapshot ) ; mnuitemASnapshot . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JMenuItem m = ( JMenuItem ) e . getSource ( ) ; log . severe ( "Snapshot/Recover Snapshot [" + m . getText ( ) + "]" ) ; loadSnapshot ( m . getText ( ) ) ; } } ) ; mnuSnapshot . add ( mnuitemASnapshot ) ; }
