tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Schedule schedule = ( Schedule ) o ; if ( id != schedule . id ) return false ; if ( seqNumber != schedule . seqNumber ) return false ; return true ; }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_BitcoinAcct ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	9X	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
tr	4	public Tile cross ( Tile currentTile , Character crosser ) { if ( crosser == null || currentTile == null ) { throw new IllegalArgumentException ( "currentTile and crosser cannot be null" ) ; } if ( ! crosser . equals ( currentTile . getCharacter ( ) ) ) { throw new IllegalArgumentException ( "The given character must be on the given tile" ) ; } if ( ! canCross ( crosser ) ) { throw new IllegalArgumentException ( "The given character is not capable of crossing this edge" ) ; } Tile destination = getOtherTile ( currentTile ) ; currentTile . removeCharacter ( ) ; destination . addCharacter ( crosser ) ; return destination ; }
tr	6	private static RubixPermutation parseMove ( char m ) { switch ( m ) { case F : return RubixPermutation . FRONT ; case B : return RubixPermutation . BACK ; case L : return RubixPermutation . LEFT ; case R : return RubixPermutation . RIGHT ; case U : return RubixPermutation . UP ; case D : return RubixPermutation . DOWN ; default : return RubixPermutation . IDENTITY ; } }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	8	public SharingPanel ( int w , int h ) { super ( ) ; this . width = w ; this . height = h ; this . isSelected = false ; this . setBackground ( Constants . backColor ) ; this . setLayout ( null ) ; this . selectedInfo = "" ; bgImg = new JLabel ( new ImageIcon ( Constants . BackgroudPath . shareListBG . getPath ( ) ) ) ; bgImg . setBounds ( 0 , 0 , width , height ) ; shareTo = new ImageIcon [ 3 ] ; shareTo [ 0 ] = new ImageIcon ( Constants . IconPath . shareToIcon1 . getPath ( ) ) ; shareTo [ 1 ] = new ImageIcon ( Constants . IconPath . shareToIcon2 . getPath ( ) ) ; shareTo [ 2 ] = new ImageIcon ( Constants . IconPath . shareToIcon3 . getPath ( ) ) ; shareFrom = new ImageIcon [ 3 ] ; shareFrom [ 0 ] = new ImageIcon ( Constants . IconPath . shareFromIcon1 . getPath ( ) ) ; shareFrom [ 1 ] = new ImageIcon ( Constants . IconPath . shareFromIcon2 . getPath ( ) ) ; shareFrom [ 2 ] = new ImageIcon ( Constants . IconPath . shareFromIcon3 . getPath ( ) ) ; handler = new ActionHandler ( ) ; tableModel = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; tableModel . setColumnIdentifiers ( new String [ ] { "    User ID" , "    Directory" , "  Status" , "" , "" , "" } ) ; table = new JTable ( ) { public class getColumnClass ( int column ) { return getValueAt ( 0 , column ) . getClass ( ) ; } } ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . setRowHeight ( 30 ) ; table . setFont ( Constants . Font1 ) ; table . setModel ( tableModel ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 130 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 150 ) ; table . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 100 ) ; for ( int i = 3 ; i < 6 ; i ++ ) { table . getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMinWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMaxWidth ( 0 ) ; } table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) && ! editMode ) { isSelected = true ; selectedInfo = "" ; if ( table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareTo [ 0 ] ) || table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareFrom [ 0 ] ) ) { initialize ( ) ; if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Target" ) ) { selectedInfo = "Target" ; } else if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Requester" ) ) { selectedInfo = "Requester" ; } } changePanel ( ) ; } } } ) ; header = table . getTableHeader ( ) ; header . setFont ( Constants . Font2 ) ; header . setEnabled ( false ) ; renderer = new DefaultTableCellRenderer ( ) ; renderer . setHorizontalAlignment ( JLabel . CENTER ) ; renderer . setFont ( getFont ( ) . deriveFont ( 80f ) ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( renderer ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( renderer ) ; scroll = new JScrollPane ( table , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setBounds ( 200 , 200 , 400 , 250 ) ; btn = new JButton [ 4 ] ; btn [ 0 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . confirmBtn1 . getPath ( ) ) ) ; btn [ 0 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . confirmBtn2 . getPath ( ) ) ) ; btn [ 1 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . cancelBtn1 . getPath ( ) ) ) ; btn [ 1 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . cancelBtn2 . getPath ( ) ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) { btn [ i ] . setBounds ( 420 + ( i * 100 ) , 160 , 80 , 30 ) ; btn [ i ] . addActionListener ( handler ) ; } this . add ( scroll ) ; this . add ( bgImg ) ; }
tr	5	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	8	private void updateClaim ( boolean choice1 ) { switch ( claim . getStatus ( ) ) { case UnRanked : claim . rank ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ; JOptionPane . showMessageDialog ( form , "The claim has been ranked " + ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ) ; break ; case Ranked : claim . setStatus ( choice1 ? Claim . Status . Confirmed : Claim . Status . Declined ) ; if ( choice1 ) { String billingInfo = AutomaticCustomerEmulator . sendForm ( ) ; storage . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , billingInfo ) ; } else AutomaticCustomerEmulator . sendMail ( "Your claim was denied" ) ; JOptionPane . showMessageDialog ( form , "The claim has been " + ( choice1 ? "confirmed" : "declined" ) ) ; break ; default : return ; } storage . updateClaim ( claim ) ; if ( listener != null ) { listener . actionPerformed ( new ActionEvent ( this , 0 , null ) ) ; } }
tr	6	public int [ ] likertJakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	1	@ Test public void setFormat_shouldThrowAnException_whenTypeIsNotStringAndFormatIsTime ( ) throws Exception { SimpleTypeSchema schema = new SimpleTypeSchema ( ) ; schema . setType ( SimpleType . NUMBER ) ; try { schema . setFormat ( "time" ) ; fail ( "Expected an exception" ) ; } catch ( IllegalArgumentException e ) { } }
tr	1	public void executar ( AmbienteExecucao ambiente ) { try { comando . executar ( ambiente ) ; } catch ( IdentificadorJaDeclaradoException | IdentificadorNaoDeclaradoException e ) { e . printStackTrace ( ) ; } }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	4	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	8	@ Override protected void process ( ) { StringTokenizer t = new StringTokenizer ( fileL . getListString ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasMoreTokens ( ) ; files ++ ) { String s = t . nextToken ( ) ; String title = Print . titleString ( "--" , s ) ; if ( showAllFiles ) { Print . ln ( title ) ; title = null ; } int i = 0 ; try ( BufferedReader in = new BufferedReader ( new FileReader ( s ) ) ) { for ( int line = 1 ; ( s = in . readLine ( ) ) != null ; line ++ ) if ( fnameFilter . accept ( s ) ) { if ( title != null ) { Print . ln ( title ) ; title = null ; } Print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( IOException ioe ) { Sys . warning ( ioe . toString ( ) ) ; } if ( i > 0 || showAllFiles ) { Print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } Print . ln ( Print . separator ( "==========================" ) ) ; Print . ln ( "Totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	2	private DefaultConstructorFactory getDefaultConstructorFactory ( ) { lock . lock ( ) ; try { DefaultConstructorFactory factory = null ; try { factory = new SunDefaultConstructorFactory ( ) ; } catch ( Exception e ) { } if ( factory == null ) factory = new NoDefaultConstructorFactory ( ) ; return factory ; } finally { lock . unlock ( ) ; } }
tr	6	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	4	@ Override public void run ( ) { try { String hostname = NetBase . theNetBase ( ) . hostname ( ) ; if ( hostname != null ) { if ( hostname . isEmpty ( ) ) System . out . println ( "Host: root" ) ; else System . out . println ( "Host: '" + hostname + "'" ) ; } else System . out . println ( "Host: none" ) ; RPCService rpcService = ( RPCService ) NetBase . theNetBase ( ) . getService ( "rpc" ) ; if ( rpcService != null ) System . out . println ( "IP: " + IPFinder . localIP ( ) + "  Port: " + rpcService . localPort ( ) ) ; else System . out . println ( "No RPC service is running on this node." ) ; } catch ( Exception e ) { System . out . println ( "Caught exception: " + e . getMessage ( ) ) ; } }
tr	8	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p >= N && q >= N ) { return false ; } else if ( a >= M && b >= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	7	protected void prepare_sample_reading ( Header header , int allocation , int channel , float [ ] factor , int [ ] codelength , float [ ] c , float [ ] d ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) { groupingtable [ channel ] = table_cd_groupingtables [ allocation ] ; factor [ 0 ] = table_cd_factor [ allocation ] ; codelength [ 0 ] = table_cd_codelength [ allocation ] ; c [ 0 ] = table_cd_c [ allocation ] ; d [ 0 ] = table_cd_d [ allocation ] ; } else { if ( subbandnumber <= 2 ) { groupingtable [ channel ] = table_ab1_groupingtables [ allocation ] ; factor [ 0 ] = table_ab1_factor [ allocation ] ; codelength [ 0 ] = table_ab1_codelength [ allocation ] ; c [ 0 ] = table_ab1_c [ allocation ] ; d [ 0 ] = table_ab1_d [ allocation ] ; } else { groupingtable [ channel ] = table_ab234_groupingtables [ allocation ] ; if ( subbandnumber <= 10 ) { factor [ 0 ] = table_ab2_factor [ allocation ] ; codelength [ 0 ] = table_ab2_codelength [ allocation ] ; c [ 0 ] = table_ab2_c [ allocation ] ; d [ 0 ] = table_ab2_d [ allocation ] ; } else if ( subbandnumber <= 22 ) { factor [ 0 ] = table_ab3_factor [ allocation ] ; codelength [ 0 ] = table_ab3_codelength [ allocation ] ; c [ 0 ] = table_ab3_c [ allocation ] ; d [ 0 ] = table_ab3_d [ allocation ] ; } else { factor [ 0 ] = table_ab4_factor [ allocation ] ; codelength [ 0 ] = table_ab4_codelength [ allocation ] ; c [ 0 ] = table_ab4_c [ allocation ] ; d [ 0 ] = table_ab4_d [ allocation ] ; } } } }
tr	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
tr	6	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	9X	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
tr	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	9X	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	3	public NodeUnion ( Link [ ] links ) { if ( links == null || links . length < 2 || links . length > 4 ) { throw new IllegalArgumentException ( "Links size must be >=2 and <=4" ) ; } this . links = links ; }
tr	7	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	6	private void method130 ( int j , int k , int l , int i1 , int j1 , int k1 , int l1 , int i2 , int j2 ) { Class30_Sub1 class30_sub1 = null ; for ( Class30_Sub1 class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetFirst ( ) ; class30_sub1_1 != null ; class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetNext ( ) ) { if ( class30_sub1_1 . anInt1295 != l1 || class30_sub1_1 . anInt1297 != i2 || class30_sub1_1 . anInt1298 != j1 || class30_sub1_1 . anInt1296 != i1 ) continue ; class30_sub1 = class30_sub1_1 ; break ; } if ( class30_sub1 == null ) { class30_sub1 = new Class30_Sub1 ( ) ; class30_sub1 . anInt1295 = l1 ; class30_sub1 . anInt1296 = i1 ; class30_sub1 . anInt1297 = i2 ; class30_sub1 . anInt1298 = j1 ; method89 ( class30_sub1 ) ; aClass19_1179 . insertHead ( class30_sub1 ) ; } class30_sub1 . anInt1291 = k ; class30_sub1 . anInt1293 = k1 ; class30_sub1 . anInt1292 = l ; class30_sub1 . anInt1302 = j2 ; class30_sub1 . anInt1294 = j ; }
tr	9X	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	8	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	3	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	8	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	4	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
tr	0	public int process_id ( ) { return 2 ; }
tr	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
tr	4	private void addSegmentsFor ( Obstacle source , Obstacle target ) { if ( source . intersects ( target ) ) addAllSegmentsBetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addSegmentsTargetAboveSource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addSegmentsTargetAboveSource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addSegmentsTargetBesideSource ( source , target ) ; else addSegmentsTargetBesideSource ( target , source ) ; }
tr	8	private void createGame ( ) { gameName = fieldGameName . getText ( ) ; playerNameHost = fieldPlayerName . getText ( ) ; Enumeration < NetworkInterface > nets = null ; try { nets = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e1 ) { } Vector < String > l = new Vector < String > ( ) ; for ( NetworkInterface netint : Collections . list ( nets ) ) { Enumeration < InetAddress > inetAddresses = netint . getInetAddresses ( ) ; for ( InetAddress inetAddress : Collections . list ( inetAddresses ) ) { l . add ( netint . getDisplayName ( ) + " (" + inetAddress . toString ( ) . substring ( 1 ) + ")" ) ; } } Object selVal = JOptionPane . showInputDialog ( this , "Choose interface to bind" , "Input" , JOptionPane . INFORMATION_MESSAGE , null , l . toArray ( ) , l . elementAt ( 0 ) ) ; String ip = selVal . toString ( ) ; int beg = ip . lastIndexOf ( ( ) ; int end = ip . lastIndexOf ( ) ) ; String ipAddr = selVal . toString ( ) . substring ( beg + 1 , end ) ; try { addr = InetAddress . getByName ( ipAddr ) ; } catch ( UnknownHostException e1 ) { } if ( gameName == null || gameName . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each game needs a name" , "Game Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( playerNameHost == null || playerNameHost . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each player needs a name" , "Player Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } dispose ( ) ; s = new Server ( ipAddr ) ; adapter . connectToServer ( addr , playerNameHost ) ; hostFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; hostFrame . setTitle ( "Snake on Lan - Host Game" ) ; hostFrame . setVisible ( true ) ; hostFrame . setResizable ( false ) ; hostFrame . setLocationRelativeTo ( null ) ; StartSnakeGame . frame . dispose ( ) ; }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	7	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; xa = shell . facing * 2 ; ya = - 5 ; flyDeath = true ; if ( spriteTemplate != null ) spriteTemplate . isDead = true ; deadTime = 100 ; winged = false ; hPic = - hPic ; yPicO = - yPicO + 16 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	6	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf (   ) + 1 ; final int endOfTag = line . indexOf (   , startOfTag + 1 ) ; if ( startOfTag < 1 || endOfTag < 1 ) { return ; } final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { final double timeLong = double . parseDouble ( strTimeTag ) ; final Date timeTag = new Date ( ( long ) timeLong . doubleValue ( ) * 1000 ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVisualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	3	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	5	public void next ( boolean respectRandom ) { if ( ! randomOrder || ! respectRandom ) { index ++ ; if ( index >= record . getRecordCount ( ) ) { index = 0 ; } } else if ( respectRandom ) { index = rand . nextInt ( record . getRecordCount ( ) ) ; } currentRecord = record . getRecordNumber ( index , false ) ; if ( currentRecord . getExtra1 ( ) . indexOf ( "rem=s" ) >= 0 ) { next ( ) ; } }
tr	1	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
tr	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	8	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	3	private ArraySchema parseArraySchema ( JsonNode rawSchema , URL schemaLocation ) { ArraySchema result = new ArraySchema ( ) ; JsonNode rawItems = rawSchema . get ( "items" ) ; if ( rawItems != null ) { result . setItems ( parse ( rawItems , schemaLocation ) ) ; } JsonNode rawMinItems = rawSchema . get ( "minItems" ) ; if ( rawMinItems != null ) { result . setMinItems ( rawMinItems . intValue ( ) ) ; } JsonNode rawMaxItems = rawSchema . get ( "maxItems" ) ; if ( rawMaxItems != null ) { result . setMaxItems ( rawMaxItems . intValue ( ) ) ; } return result ; }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	9X	private static boolean isUnreserved ( char c ) { return ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || c == . || c == - || c == _ || c == ~ ; }
tr	5	public boolean isWallhugPosition ( int x , int y ) { if ( getFreeCount ( x , y ) != 2 ) return false ; else if ( isEmpty ( moveLeft ( x ) , y ) && isEmpty ( moveRight ( x ) , y ) ) return false ; else if ( isEmpty ( x , moveUp ( y ) ) && isEmpty ( x , moveDown ( y ) ) ) return false ; else return true ; }
tr	6	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	8	private void waitForAndConnectClients ( ) { boolean afterFirstPlayer ; try { ServerSocket serverSocket = new ServerSocket ( PORT ) ; Socket clientSocket = new Socket ( ) ; acceptConnections ( serverSocket , clientSocket ) ; } catch ( SocketTimeoutException ste ) { System . out . println ( "SocketTimeoutException occured in Server" ) ; boolean exitLoop = false ; if ( Server . numOfClients >= 2 ) { this . startupPG . broadcastMessage ( "sBegin" ) ; while ( exitLoop == false ) { if ( this . startupPG . arePlayersReadyToPlay ( ) == true ) { cGame45 . beginRound ( ) ; exitLoop = true ; } else { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { System . err . println ( "Server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { System . out . println ( "Timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( IOException ioe ) { System . out . println ( "IO Exception occured in Server" ) ; } catch ( SecurityException sc ) { System . out . println ( "SecurityExceptionException occured in Server" ) ; } catch ( IllegalBlockingModeException ibme ) { System . out . println ( "IllegalBlockingModeException occured in Server" ) ; } }
tr	9X	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
tr	6	private void readPolar ( ) throws IOException { long currTime ; while ( isRead ) { currTime = System . currentTimeMillis ( ) ; int msg = inputStream . read ( ) ; if ( msg == 254 ) { printMessage ( "\n" + System . currentTimeMillis ( ) + ": " ) ; polarMessageTmp = new PolarMessage ( System . currentTimeMillis ( ) ) ; } else if ( msg == - 1 ) { System . out . println ( "Roz\u0142\u0105czono" ) ; stopRead ( ) ; break ; } else if ( polarMessageTmp != null && polarMessageTmp . setNextValue ( msg ) ) { message = new PolarMessage ( System . currentTimeMillis ( ) ) ; message . setHr ( polarMessageTmp . getHr ( ) ) ; } if ( currTime - System . currentTimeMillis ( ) > 3000 ) { System . out . println ( "Zbyt d\u0142ugi czas oczekiwania" ) ; } printMessage ( " " + msg ) ; } }
tr	1	@ Override public BigDecimal evaluate ( String mathExpression ) throws EvaluationException { EvaluationContext context = new EvaluationContext ( mathExpression ) ; try { return run ( context ) ; } catch ( Exception ex ) { throw new EvaluationException ( ex . getMessage ( ) , context . getCurrentPosition ( ) ) ; } }
tr	8	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	9X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	6	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
