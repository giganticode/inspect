tr	3	@ Override public AuthorizationRequest authorize ( ) { if ( ready ) { ready = false ; if ( tokenRequest != null ) { try { tokenRequest . join ( THREAD_JOIN_TIMEOUT ) ; } catch ( InterruptedException e ) { } } tokenRequest = new Thread ( ) { @ Override public void run ( ) { obtainAccessToken ( ) ; } } ; } String queryString = URLEncodedUtils . format ( Utils . mapToList ( authorizeParams ) , "UTF-8" ) ; return new AuthorizationRequest ( authorizeServer + "?" + queryString ) ; }
tr	0	int newMark ( ) { return ++ currentMark ; }
tr	8	void endLayer ( Layer lay ) { timeaccel += lay . getTimeAccel ( ) ; distance += lay . getDistance ( ) ; traveldistance += lay . getTraveldistance ( ) ; if ( ! lay . isPrinted ( ) ) { notprintedLayers ++ ; } else { boundaries [ 0 ] = Math . max ( lay . getBoundaries ( ) [ 0 ] , boundaries [ 0 ] ) ; boundaries [ 1 ] = Math . min ( lay . getBoundaries ( ) [ 1 ] , boundaries [ 1 ] ) ; boundaries [ 2 ] = Math . max ( lay . getBoundaries ( ) [ 2 ] , boundaries [ 2 ] ) ; boundaries [ 3 ] = Math . min ( lay . getBoundaries ( ) [ 3 ] , boundaries [ 3 ] ) ; boundaries [ 4 ] = Math . max ( lay . getBoundaries ( ) [ 4 ] , boundaries [ 4 ] ) ; dimension [ 0 ] = Constants . round2digits ( boundaries [ 0 ] - boundaries [ 1 ] ) ; dimension [ 1 ] = Constants . round2digits ( boundaries [ 2 ] - boundaries [ 3 ] ) ; dimension [ 2 ] = Constants . round2digits ( boundaries [ 4 ] ) ; extrusion = extrusion + lay . getExtrusion ( ) ; avgLayerHeight = avgLayerHeight + lay . getLayerheight ( ) ; avgbedtemp = avgbedtemp + lay . getBedtemp ( ) ; avgextemp = avgextemp + lay . getExttemp ( ) ; } float sp = lay . getSpeed ( Speed . SPEED_ALL_AVG ) ; if ( sp != float . NaN && sp > 0 ) { avgspeed += ( sp * lay . getDistance ( ) ) ; } maxprintspeed = Math . max ( maxprintspeed , lay . getSpeed ( Speed . SPEED_PRINT_MAX ) ) ; if ( lay . getSpeed ( Speed . SPEED_PRINT_MIN ) != 0 ) { minprintspeed = Math . min ( minprintspeed , lay . getSpeed ( Speed . SPEED_PRINT_MIN ) ) ; } sp = lay . getSpeed ( Speed . SPEED_TRAVEL_AVG ) ; if ( sp != float . NaN && sp > 0 ) { avgtravelspeed += sp * lay . getTraveldistance ( ) ; } for ( Iterator < float > iterator = lay . getSpeedAnalysisT ( ) . keySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { float speedkey = iterator . next ( ) ; SpeedEntry timespeedlay = lay . getSpeedAnalysisT ( ) . get ( speedkey ) ; SpeedEntry speedsum = SpeedAnalysisT . get ( speedkey ) ; if ( speedsum != null ) { speedsum . addTime ( timespeedlay . getTime ( ) ) ; speedsum . addDistance ( timespeedlay . getDistance ( ) ) ; speedsum . setPrint ( timespeedlay . getType ( ) ) ; speedsum . addLayers ( lay . getNumber ( ) ) ; } else { SpeedEntry sped = new SpeedEntry ( speedkey , timespeedlay . getTime ( ) , lay . getNumber ( ) ) ; sped . addDistance ( timespeedlay . getDistance ( ) ) ; sped . setPrint ( timespeedlay . getType ( ) ) ; SpeedAnalysisT . put ( speedkey , sped ) ; } } unit = lay . getUnit ( ) ; }
tr	2	@ Override public String toString ( ) { String s = "Vertices: " + V + " Edges: " + E + "\n" ; for ( int i = 0 ; i < V ; i ++ ) { s += i + ": " ; for ( int w : adj ( i ) ) s += w + " " ; s += "\n" ; } return s ; }
tr	3	public Value get ( Node node , Key key ) { if ( node == null ) { return null ; } int cmp = key . compareTo ( node . key ) ; if ( cmp < 0 ) { return get ( node . left , key ) ; } else if ( cmp > 0 ) { return get ( node . right , key ) ; } else { return node . value ; } }
tr	2	public < K , V > ListenableAtomicMap < K , V > removeListenableAtomicMapNamed ( String name ) { return atomic ( ( ) -> { ListenableAtomicMap < ? , ? > map = ListenableAtomicMapsByName . remove ( name ) ; return ( ListenableAtomicMap < K , V > ) map ; } ) ; }
tr	9	public static int countDayInMonth ( long month ) { Date d = new Date ( month ) ; int monthIndex = d . getMonth ( ) ; int year = d . getYear ( ) ; switch ( monthIndex ) { case 0 : case 2 : case 4 : case 6 : case 7 : case 9 : case 11 : return 31 ; case 1 : return isLeapYear ( year ) ? 29 : 28 ; default : return 30 ; } }
tr	0	public Modele ( ) { this . joueurs = new ArrayList < Joueur > ( ) ; this . type = TypePartie . CLASSIQUE ; this . options = new Options ( ) ; this . indice_joueur_courant = 0 ; }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	7	protected void generateCode ( ) { List < Invalid > errors = validateData ( ) ; if ( ! errors . isEmpty ( ) ) { displayValidationErrorDialog ( true , errors ) ; return ; } JFileChooser save = new JFileChooser ( ) ; save . setAcceptAllFileFilterUsed ( false ) ; save . setFileFilter ( new FileNameExtensionFilter ( "JAR files" , "jar" ) ) ; int result = save . showSaveDialog ( this ) ; if ( result != JFileChooser . APPROVE_OPTION ) { return ; } File selected = save . getSelectedFile ( ) ; if ( ! selected . getName ( ) . toLowerCase ( ) . endsWith ( ".jar" ) ) { selected = new File ( selected . getAbsolutePath ( ) + ".jar" ) ; } final Map < Aspect , ProgressIndicator > boxes = new LinkedHashMap < > ( ) ; boxes . put ( Aspect . GENERAL , new ProgressIndicator ( "Generating general and shop code" ) ) ; boxes . put ( Aspect . LEVELS , new ProgressIndicator ( "Generating level code" ) ) ; boxes . put ( Aspect . TOWERS , new ProgressIndicator ( "Generating tower code" ) ) ; boxes . put ( Aspect . ENEMIES , new ProgressIndicator ( "Generating enemy code" ) ) ; boxes . put ( Aspect . PROJECTILES , new ProgressIndicator ( "Generating projectile code" ) ) ; boxes . put ( null , new ProgressIndicator ( "Compiling and packaging code" ) ) ; final JPanel pnlDialog = new JPanel ( new MigLayout ( ) ) ; JLabel lblTitle = new JLabel ( "Code generation in progress." ) ; JLabel lblSubtitle = new JLabel ( "Please wait..." ) ; lblTitle . setFont ( lblTitle . getFont ( ) . deriveFont ( 24f ) . deriveFont ( Font . BOLD ) ) ; lblSubtitle . setFont ( lblSubtitle . getFont ( ) . deriveFont ( 18f ) ) ; CC labels = new CC ( ) . growX ( ) . pushX ( ) . wrap ( ) ; pnlDialog . add ( lblTitle , labels ) ; pnlDialog . add ( lblSubtitle , labels ) ; pnlDialog . add ( new JSeparator ( JSeparator . HORIZONTAL ) , new CC ( ) . growX ( ) . pushX ( ) . spanX ( ) ) ; for ( ProgressIndicator indicator : boxes . values ( ) ) { indicator . addTo ( pnlDialog ) ; } JProgressBar pb = new JProgressBar ( ) ; pb . setIndeterminate ( true ) ; pnlDialog . add ( pb , new CC ( ) . newline ( ) . growX ( ) . pushX ( ) . spanX ( ) ) ; final JDialog dialog = new JDialog ( TowerDefGen . this , "Code Generation Progress" ) ; dialog . setContentPane ( pnlDialog ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( TowerDefGen . this ) ; dialog . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; dialog . setVisible ( true ) ; dialog . setModal ( true ) ; final File finalFile = selected ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { CodeGenerator . generateJar ( getDataObject ( ) , finalFile , new CodeProgress ( ) { private CodeGenerationState lastState = null ; @ Override public void progressUpdated ( CodeGenerationState newState ) { if ( lastState != null ) { boxes . get ( lastState . aspect ) . setState ( ProgressState . COMPLETED ) ; } lastState = newState ; boxes . get ( newState . aspect ) . setState ( ProgressState . IN_PROGRESS ) ; } } ) ; dialog . setVisible ( false ) ; dialog . dispose ( ) ; int ret = JOptionPane . showConfirmDialog ( TowerDefGen . this , "Your game has been exported. Would you like to launch it now?" , "Export Complete" , JOptionPane . YES_NO_OPTION ) ; if ( ret == JOptionPane . YES_OPTION ) { ProcessBuilder pb = new ProcessBuilder ( "java" , "-jar" , finalFile . getAbsolutePath ( ) ) ; try { pb . start ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ) . start ( ) ; }
tr	5	public static boolean canMove ( Direction dir , boolean selfAvoiding , RobotController rc ) { if ( selfAvoiding ) { MapLocation resultingLocation = rc . getLocation ( ) . add ( dir ) ; for ( int i = 0 ; i < snailTrail . size ( ) ; i ++ ) { MapLocation m = snailTrail . get ( i ) ; if ( ! m . equals ( rc . getLocation ( ) ) ) { if ( resultingLocation . isAdjacentTo ( m ) || resultingLocation . equals ( m ) ) { return false ; } } } } return rc . canMove ( dir ) ; }
tr	1	@ Override public MyDatabase getMysql ( ) { if ( client == null ) { return SgdBase . getMysql ( ) ; } else { return client . getMysql ( ) ; } }
tr	3	private boolean checkUserExists ( String user ) { Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "id " + user ) ; p . waitFor ( ) ; int exitValue = p . exitValue ( ) ; if ( exitValue != 0 ) { JOptionPane . showMessageDialog ( sif , "Invalid user - " + user + "\nPlease make sure the user exists in the system." , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null ) NativeCalls . releaseProcess ( p ) ; } return true ; }
tr	6	private static String printable ( char ch ) { if ( ch == '' ) { return "\\n" ; } else if ( ch == '' ) { return "\\r" ; } else if ( ch == 	 ) { return "\\t" ; } if ( ch > 127 || ch < 32 ) { StringBuffer buf = new StringBuffer ( "\\u" ) ; String hex = Integer . toHexString ( ( int ) ch ) ; for ( int i = 0 ; i < 4 - hex . length ( ) ; i ++ ) { buf . append ( 0 ) ; } buf . append ( hex ) ; return buf . toString ( ) ; } return "" + ch ; }
tr	1	public int GetSumOfFactorialsOfDigitsInNumber ( int candidate ) { String digits = Integer . toString ( candidate ) ; int toReturn = 0 ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { toReturn += FactorializeSmallNumber ( Integer . parseInt ( digits . substring ( i , i + 1 ) ) ) ; } return toReturn ; }
tr	8	private boolean recursiveDelete ( EncFSFile file , EncFSProgressListener progressListener ) throws IOException { boolean result = true ; if ( file . isDirectory ( ) ) { for ( EncFSFile subFile : file . listFiles ( ) ) { boolean subResult = recursiveDelete ( subFile , progressListener ) ; if ( ! subResult ) { result = false ; break ; } } if ( result ) { if ( progressListener != null ) { progressListener . setCurrentFile ( file . getPath ( ) ) ; } result = file . delete ( ) ; if ( progressListener != null ) { progressListener . postEvent ( EncFSProgressListener . FILE_PROCESS_EVENT ) ; } } } else { if ( progressListener != null ) { progressListener . setCurrentFile ( file . getPath ( ) ) ; } result = file . delete ( ) ; if ( progressListener != null ) { progressListener . postEvent ( EncFSProgressListener . FILE_PROCESS_EVENT ) ; } } return result ; }
tr	7	public String columnsToGraphviz ( Network network ) { beginHeader ( ) ; { int pos = 0 ; for ( ColumnNode column : network . columnNodes ( ) ) { addHead ( column . base , column . size , pos ) ; for ( Node node = column . base . top ; node != column . base ; node = node . top ) { addNode ( node , pos ) ; } pos ++ ; } for ( ColumnNode column : network . columnNodes ( ) ) { addEdge ( column . base , "B" , column . base . top , "L" ) ; for ( Node node = column . base . top ; node != column . base ; node = node . top ) { if ( getColumn ( node . left ) < getColumn ( node ) ) { addEdge ( node , "L" , node . left , "T" ) ; } if ( getColumn ( node ) < getColumn ( node . right ) ) { addEdge ( node , "R" , node . right , "B" ) ; } addEdge ( node , "T" , node . bottom , "R" ) ; if ( node . top != column . base ) { addEdge ( node , "B" , node . top , "L" ) ; } } } } endHeader ( ) ; return sb . toString ( ) ; }
tr	7	public static void addVertices ( ArrayList < ArrayList < Vertex >> master , ArrayList < Vertex > in , int id ) { if ( in == null || in . isEmpty ( ) ) { return ; } System . out . println ( "in addVertices..." ) ; while ( id >= master . size ( ) ) { System . out . println ( "adding to list..." ) ; master . add ( new ArrayList < Vertex > ( ) ) ; } if ( master . get ( id ) . isEmpty ( ) ) { master . get ( id ) . addAll ( in ) ; } else { Vertex mLast = master . get ( id ) . get ( master . size ( ) - 1 ) ; Vertex inFirst = in . get ( id ) ; Vertex inLast = in . get ( in . size ( ) - 1 ) ; if ( mLast . getDistance ( inFirst ) < _threshold ) { master . get ( id ) . addAll ( in ) ; } else if ( mLast . getDistance ( inLast ) < _threshold ) { for ( int v = in . size ( ) - 1 ; v >= 0 ; v -- ) { master . get ( id ) . add ( in . get ( v ) ) ; } } } }
tr	3	@ Override public void update ( Despesa e , Connection conn ) throws Exception { String sql = "UPDATE despesa SET viagem_fk=?  categoria_despesa_fk=?  comprovante=?  valor=?  nome_estabelecimento=?  data_compra=?  hora_compra=?  cnpj=?  descritivo=?  valor_real_autorizado=? WHERE id=?" ; PreparedStatement ps = conn . prepareStatement ( sql ) ; int i = 0 ; ps . setLong ( ++ i , e . getViagem ( ) . getId ( ) ) ; ps . setLong ( ++ i , e . getCategoriaDespesa ( ) . getId ( ) ) ; ps . setBytes ( ++ i , e . getComprovante ( ) ) ; ps . setDouble ( ++ i , e . getValor ( ) ) ; if ( e . getNomeEstabelecimento ( ) != null ) { ps . setDouble ( ++ i , e . getValor ( ) ) ; } else { ps . setNull ( ++ i , Types . VARCHAR ) ; } ps . setDate ( ++ i , e . getDataCompra ( ) ) ; ps . setTime ( ++ i , e . getHoraCompra ( ) ) ; if ( e . getCnpj ( ) != 0 ) { ps . setLong ( ++ i , e . getCnpj ( ) ) ; } else { ps . setNull ( ++ i , Types . BIGINT ) ; } if ( e . getDescritivo ( ) != null ) { ps . setString ( ++ i , e . getDescritivo ( ) ) ; } else { ps . setNull ( ++ i , Types . VARCHAR ) ; } ps . setLong ( ++ i , e . getValorRealAutorizado ( ) ) ; ps . execute ( ) ; ps . close ( ) ; }
tr	8	@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; int h = getHeight ( ) ; int w = getWidth ( ) ; GeneralUtilities . PaintAxes ( g2 , DISTANCE_FROM_PANEL , h , w ) ; if ( this . optimizedMzWindows . isEmpty ( ) ) { return ; } double minRT = this . optimizedMzWindows . get ( 0 ) . getStartRT ( ) ; double maxRT ; double starty = h - DISTANCE_FROM_PANEL - CST_DIST ; double endy = DISTANCE_FROM_PANEL + CST_DIST ; double endx = w - DISTANCE_FROM_PANEL - CST_DIST ; double startx = DISTANCE_FROM_PANEL + CST_DIST ; double yinterval = starty - endy ; double xinterval = endx - startx ; double minMz = double . MAX_VALUE ; double maxMz = double . MIN_VALUE ; List < double > splits ; Line2D line ; double stime , etime , y = 0 , prev_y = 0 , y_step ; double x , x0 , x1 ; maxRT = this . optimizedMzWindows . get ( this . optimizedMzWindows . size ( ) - 1 ) . getEndRT ( ) ; for ( RtMzWindows win : this . optimizedMzWindows ) { minMz = Math . min ( minMz , Collections . min ( win . getSplits ( ) ) ) ; maxMz = Math . max ( maxMz , Collections . max ( win . getSplits ( ) ) ) ; } double delta_y = yinterval / ( maxMz - minMz ) ; double delta_x = xinterval / ( maxRT - minRT ) ; double mz_s , mz_e ; HashMap < double , double > start_markers = new HashMap ( ) ; HashMap < double , double > end_markers = new HashMap ( ) ; g2 . setColor ( Color . blue ) ; for ( RtMzWindows win : this . optimizedMzWindows ) { stime = win . getStartRT ( ) ; etime = win . getEndRT ( ) ; for ( double d : win . getSplits ( ) ) { prev_y = y ; y = starty - ( d - minMz ) * delta_y ; x0 = startx + ( stime - minRT ) * delta_x ; x1 = startx + ( etime - minRT ) * delta_x ; line = new Line2D . double ( x0 , y , x1 , y ) ; g2 . draw ( line ) ; try { x = start_markers . put ( d , x0 ) ; } catch ( NullPointerException npe ) { x = double . MAX_VALUE ; } start_markers . put ( d , Math . min ( x , x0 ) ) ; try { x = end_markers . put ( d , x1 ) ; } catch ( NullPointerException npe ) { x = double . MIN_VALUE ; } end_markers . put ( d , Math . max ( x , x1 ) ) ; } } y_step = ( y - prev_y ) / 2 ; g2 . setColor ( Color . gray ) ; for ( RtMzWindows win : this . optimizedMzWindows ) { for ( double d : win . getSplits ( ) ) { y = starty - ( d - minMz ) * delta_y ; x0 = start_markers . get ( d ) ; x1 = end_markers . get ( d ) ; line = new Line2D . double ( x0 , y + y_step , x0 , y - y_step ) ; g2 . draw ( line ) ; line = new Line2D . double ( x1 , y + y_step , x1 , y - y_step ) ; g2 . draw ( line ) ; } } g2 . setColor ( Color . black ) ; g2 . drawString ( "Retention time (LC time)" , w / 4 , h - DISTANCE_FROM_PANEL / 2 ) ; AffineTransform fontAT = new AffineTransform ( ) ; Font theFont = g2 . getFont ( ) ; fontAT . rotate ( - java . lang . Math . PI / 2 ) ; Font theDerivedFont = theFont . deriveFont ( fontAT ) ; g2 . setFont ( theDerivedFont ) ; g2 . drawString ( "m/z" , DISTANCE_FROM_PANEL / 2 + 10 , h / 2 ) ; g2 . setFont ( theFont ) ; }
tr	1	@ AfterClass public static void tearDownClass ( ) throws Exception { if ( session != null ) { Comentari com = ( Comentari ) session . get ( Comentari . class , new ComentariId ( nomH , dniC , d ) ) ; session . delete ( com ) ; session . getTransaction ( ) . commit ( ) ; } }
tr	0	public List < AttdRecordInfo > getAttdRecord ( ClassInfo currentCourse , Date arDate ) { List < AttdRecordInfo > infoList = new ArrayList < AttdRecordInfo > ( ) ; dataAgent . getDataAttdRecord ( currentCourse , arDate , infoList ) ; return infoList ; }
tr	2	public void cargarComboDepto ( ) { int codigoEdificio = Integer . parseInt ( codEdificio . getText ( ) ) ; Lavanderia l = new Lavanderia ( ) ; ArrayList < String > listado = l . listarDeptos ( codigoEdificio ) ; if ( listado != null ) { for ( int i = 0 ; i < listado . size ( ) ; i ++ ) { numDepto . addItem ( listado . get ( i ) ) ; } } }
tr	1	public Object [ ] getData ( int index ) { Object [ ] data = new Object [ model . getColumnCount ( ) ] ; for ( int i = 0 ; i < model . getColumnCount ( ) ; i ++ ) { data [ i ] = model . getValueAt ( index , i ) ; } return data ; }
tr	9	private void scheduleRefreshPackets ( ByteBuffer addEntityBuffer ) { synchronized ( entities ) { for ( Entity one : entities ) { if ( playerListChanged && one . getId ( ) > - 1 ) { protocol . send ( addEntityBuffer , new AddEntity ( one ) ) ; if ( one instanceof Box && one . humanControl ( ) ) { protocol . send ( addEntityBuffer , new Update ( ( Box ) one ) ) ; if ( one instanceof Soldier ) { protocol . send ( addEntityBuffer , new Color ( one ) ) ; protocol . send ( addEntityBuffer , new Ammo ( ( Soldier ) one ) ) ; } } } if ( one instanceof Box ) { Box b = ( Box ) one ; if ( b . needsUpdate ( frame ) ) { prepareUpdateBuffer ( ) ; Packet updatePacket = new Update ( b ) ; protocol . send ( updateBuffer , updatePacket ) ; if ( b . freshMeat ( ) && b instanceof Soldier ) { protocol . send ( updateBuffer , new Color ( b ) ) ; protocol . send ( updateBuffer , new Ammo ( ( Soldier ) b ) ) ; } } } } } }
tr	5	public boolean equals ( Object obj ) { if ( obj instanceof Hand ) { Hand hand = ( Hand ) obj ; if ( hand . hand . size ( ) == this . hand . size ( ) && hand . numberOfCard == this . numberOfCard ) { for ( int i = 0 ; i < this . hand . size ( ) ; ++ i ) { if ( ! hand . hand . get ( i ) . equals ( this . hand . get ( i ) ) ) { return false ; } } return true ; } } return false ; }
tr	8	private void constructJson ( JSONObject json ) throws WeiboException { try { createdAt = parseDate ( json . getString ( "created_at" ) , "EEE MMM dd HH:mm:ss z yyyy" ) ; id = json . getString ( "id" ) ; mid = json . getString ( "mid" ) ; idstr = json . getLong ( "idstr" ) ; text = json . getString ( "text" ) ; if ( ! json . getString ( "source" ) . isEmpty ( ) ) { source = new Source ( json . getString ( "source" ) ) ; } inReplyToStatusId = getLong ( "in_reply_to_status_id" , json ) ; inReplyToUserId = getLong ( "in_reply_to_user_id" , json ) ; inReplyToScreenName = json . getString ( "in_reply_toS_screenName" ) ; favorited = getBoolean ( "favorited" , json ) ; truncated = getBoolean ( "truncated" , json ) ; thumbnailPic = json . getString ( "thumbnail_pic" ) ; bmiddlePic = json . getString ( "bmiddle_pic" ) ; originalPic = json . getString ( "original_pic" ) ; repostsCount = json . getInt ( "reposts_count" ) ; commentsCount = json . getInt ( "comments_count" ) ; annotations = json . getString ( "annotations" ) ; if ( ! json . isNull ( "user" ) ) user = new User ( json . getJSONObject ( "user" ) ) ; if ( ! json . isNull ( "retweeted_status" ) ) { retweetedStatus = new Status ( json . getJSONObject ( "retweeted_status" ) ) ; } mlevel = json . getInt ( "mlevel" ) ; geo = json . getString ( "geo" ) ; if ( geo != null && ! "" . equals ( geo ) && ! "null" . equals ( geo ) ) { getGeoInfo ( geo ) ; } if ( ! json . isNull ( "visible" ) ) { visible = new Visible ( json . getJSONObject ( "visible" ) ) ; } } catch ( JSONException je ) { throw new WeiboException ( je . getMessage ( ) + ":" + json . toString ( ) , je ) ; } }
tr	6	private void process_interpage_shared_properties ( ) throws Exception { Set < String > unique_urls = interpage_shared_properties . keySet ( ) ; for ( String url_1 : unique_urls ) { for ( String url_2 : unique_urls ) { if ( url_1 . equals ( url_2 ) == false ) { System . out . println ( "\n\n^^^^^^^^^ " + url_1 + " : " + url_2 + "\n" ) ; float url_similarity = score_mapset ( interpage_shared_properties . get ( url_1 ) , interpage_shared_properties . get ( url_2 ) ) ; if ( url_similarity > 12f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/high_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/medium_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/low_similarity> <" + url_2 + "> ." ) ; } } } } }
tr	4	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
tr	2	private int max ( T [ ] array , int leftIndex , int rightIndex ) { int maxIndex = leftIndex ; for ( int i = leftIndex + 1 ; i <= rightIndex ; i ++ ) { if ( array [ i ] . compareTo ( array [ maxIndex ] ) > 0 ) { maxIndex = i ; } } return maxIndex ; }
tr	9	private JSONArray readArray ( ) throws JSONException { JSONArray result = new JSONArray ( ) ; boolean hasTrailingSeparator = false ; while ( true ) { switch ( nextCleanInternal ( ) ) { case - 1 : throw syntaxError ( "Unterminated array" ) ; case ] : if ( hasTrailingSeparator ) { result . put ( null ) ; } return result ; case   : case ; : result . put ( null ) ; hasTrailingSeparator = true ; continue ; default : pos -- ; } result . put ( nextValue ( ) ) ; switch ( nextCleanInternal ( ) ) { case ] : return result ; case   : case ; : hasTrailingSeparator = true ; continue ; default : throw syntaxError ( "Unterminated array" ) ; } } }
tr	2	@ Override public String replace ( Matcher m , Page page ) { if ( ! m . group ( 1 ) . trim ( ) . startsWith ( "%" ) && m . group ( 1 ) . trim ( ) . length ( ) > 0 ) { System . err . println ( "Unhandled macro: " + m . group ( 1 ) . trim ( ) ) ; } return m . group ( ) ; }
tr	3	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex == - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
tr	6	public void print ( ) { for ( int i = 0 ; i < 9 ; ++ i ) { if ( i % 3 == 0 ) System . out . println ( "-----------------------------" ) ; for ( int j = 0 ; j < 9 ; ++ j ) { if ( j > 0 && j % 3 == 0 ) System . out . print ( "|" ) ; int v = get ( i , j ) ; if ( v > 0 ) { System . out . print ( " " + v + " " ) ; } else { System . out . print ( "   " ) ; } } System . out . println ( "" ) ; } System . out . println ( "-----------------------------" ) ; }
tr	9	public PiecePanel ( Frame frame , int x ) { this . setLayout ( new BorderLayout ( ) ) ; this . setPreferredSize ( new Dimension ( PLAYERWIDTH , GRIDSIZE ) ) ; this . setBackground ( Color . DARK_GRAY . darker ( ) ) ; boardPanel = frame . boardPanel ; this . board = frame . board ; this . player = frame . players [ x ] ; playerNum = x ; this . frame = frame ; currentPiece = null ; Border bord1 , bord2 , finalborder ; bord1 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 5 , 0 , 0 , Color . BLUE ) , BorderFactory . createMatteBorder ( 5 , 0 , 0 , 0 , Color . RED ) ) ; bord2 = new CompoundBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 0 , 5 , Color . YELLOW ) , BorderFactory . createMatteBorder ( 0 , 0 , 5 , 0 , Color . GREEN ) ) ; finalborder = new CompoundBorder ( bord1 , bord2 ) ; this . setBorder ( finalborder ) ; switch ( player . getColor ( ) ) { case b : color = "Blue" ; break ; case r : color = "Red" ; break ; case y : color = "Yellow" ; break ; case g : color = "Green" ; break ; } im = new Image [ 21 ] ; ImageIcon temp ; for ( int i = 0 ; i < 21 ; ++ i ) { try { temp = new ImageIcon ( getClass ( ) . getResource ( "/images/" + color + "/" + String . valueOf ( i ) + "S.png" ) ) ; im [ i ] = temp . getImage ( ) ; } catch ( Exception e ) { System . out . println ( "Stuff" ) ; System . exit ( 10 ) ; } } piecesPanel = new JPanel ( new FlowLayout ( ) ) ; piecesPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; pieces = new Piece [ 21 ] ; clickables = new JRadioButton [ 21 ] ; int w , h ; ImageIcon icon = null ; ButtonListener clicked = new ButtonListener ( ) ; for ( int i = 0 ; i < 21 ; ++ i ) { pieces [ i ] = player . getPiece ( i ) ; w = ( int ) ( 0.7 * ( pieces [ i ] . getWidth ( ) * SPACESIZE ) ) ; h = ( int ) ( 0.7 * ( pieces [ i ] . getHeight ( ) * SPACESIZE + 1 ) ) ; im [ i ] = im [ i ] . getScaledInstance ( w , h , BufferedImage . SCALE_DEFAULT ) ; icon = new ImageIcon ( im [ i ] ) ; clickables [ i ] = new JRadioButton ( icon ) ; clickables [ i ] . setOpaque ( false ) ; clickables [ i ] . addActionListener ( clicked ) ; piecesPanel . add ( clickables [ i ] ) ; } this . add ( piecesPanel ) ; rcButton = new JButton ( "<html><center>Rotate<p>Right(&gt)</center></html>" ) ; rcButton . setFocusable ( false ) ; rccButton = new JButton ( "<html><center>Rotate<p>Left(&lt)</center></html>" ) ; rccButton . setFocusable ( false ) ; flipButton = new JButton ( "Flip(^)" ) ; flipButton . setFocusable ( false ) ; buttonPanel = new JPanel ( new GridLayout ( 1 , 3 ) ) ; buttonPanel . setBackground ( Color . DARK_GRAY . darker ( ) ) ; buttonPanel . add ( rccButton , BorderLayout . SOUTH ) ; buttonPanel . add ( flipButton , BorderLayout . SOUTH ) ; buttonPanel . add ( rcButton , BorderLayout . SOUTH ) ; rcButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRC ( ) ; } } } ) ; rccButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragRCC ( ) ; } } } ) ; flipButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( currentPiece != null ) { currentPiece . ImageDragFlip ( ) ; } } } ) ; submitButton = new JButton ( "Submit Move!(ENTER)" ) ; submitButton . addActionListener ( new SubmitListener ( ) ) ; submitButton . setEnabled ( false ) ; submitButton . setFocusable ( false ) ; JPanel two = new JPanel ( new GridLayout ( 2 , 1 ) ) ; two . setBackground ( Color . DARK_GRAY . darker ( ) ) ; two . add ( buttonPanel ) ; two . add ( submitButton ) ; this . add ( two , BorderLayout . SOUTH ) ; }
tr	5	public final void valueChanged ( final ListSelectionEvent event ) { final String methodName = "valueChanged" ; ControllerLogger . entering ( CLASS_NAME , methodName ) ; if ( ! event . getValueIsAdjusting ( ) ) { if ( standAloneWindow == null ) { ControllerLogger . warning ( CLASS_NAME , methodName , "User has selected a main table's row but a reference " + "to the stand alone window does not exist" ) ; return ; } final JTable recordTable = standAloneWindow . getRecordTable ( ) ; final Record recordSelected = standAloneWindow . getRecordFromTable ( recordTable . getSelectedRow ( ) ) ; if ( recordSelected == null ) { standAloneWindow . enableBookRoomButton ( false ) ; } else if ( ( recordSelected . getOwner ( ) != null ) && ( ! "" . equals ( recordSelected . getOwner ( ) ) ) ) { standAloneWindow . enableBookRoomButton ( false ) ; } else { standAloneWindow . enableBookRoomButton ( true ) ; } } ControllerLogger . exiting ( CLASS_NAME , methodName ) ; }
tr	3	@ EventHandler ( priority = EventPriority . LOWEST ) public void lever ( PlayerInteractEvent event ) { Action action = event . getAction ( ) ; if ( action == Action . LEFT_CLICK_BLOCK || action == Action . RIGHT_CLICK_BLOCK ) { if ( event . getClickedBlock ( ) . getType ( ) == Material . LEVER ) { prevent ( event , event . getPlayer ( ) , "lever interact" ) ; } } }
tr	5	@ EventHandler ( priority = EventPriority . NORMAL ) public void onCreatureSpawn ( final CreatureSpawnEvent event ) { if ( plugin . getConfig ( ) . getBoolean ( "ENABLE_BLACKLIST" ) ) { World world = event . getLocation ( ) . getWorld ( ) ; if ( ! new File ( plugin . getDataFolder ( ) + File . separator + "mobblist" , world . getName ( ) + ".txt" ) . exists ( ) ) { plugin . createMobBlacklist ( world . getName ( ) ) ; plugin . getLogger ( ) . log ( Level . INFO , "MobBlacklist for " + world . getName ( ) + " has been created." ) ; } else { String [ ] mobList = plugin . getMobs ( world . getName ( ) ) ; for ( String creature : mobList ) { EntityType et = EntityType . fromName ( creature ) ; if ( et != null && et . equals ( event . getEntityType ( ) ) ) event . setCancelled ( true ) ; } } } }
tr	3	void getLatestVersions ( vslIndexView < String > cur , StringBuffer out ) throws vslInputException { if ( cur . getNextViews ( ) == null ) { if ( cur . isDelete ( ) ) { out . append ( " DELETED " ) ; } else { out . append ( " " ) . append ( cur . getData ( ) ) . append ( " " ) ; } } else { for ( vslIndexView < String > nv : cur . getNextViews ( ) ) { getLatestVersions ( nv , out ) ; } } }
tr	2	@ Override public boolean typeUser ( String strTabla , String strTablaCompare , String strCampo , String idTabla , int idUsuario ) throws Exception { int result = 0 ; Statement oStatement ; try { oStatement = ( Statement ) oConexionMySQL . createStatement ( ) ; String strSQL = "SELECT " + strCampo + " FROM " + strTabla + "   " + strTablaCompare + " WHERE " + idTabla + " = " + idUsuario ; ResultSet rs = oStatement . executeQuery ( strSQL ) ; while ( rs . next ( ) ) { result = rs . getInt ( strCampo ) ; } return ( result > 0 ) ; } catch ( SQLException e ) { throw new Exception ( "mysql.existsOne: Error en la consulta: " + e . getMessage ( ) ) ; } }
tr	9	private void _move ( double xxa , double yya , double zza ) { if ( removed ) return ; double xn = x + xxa ; double yn = y + yya ; double zn = z + zza ; if ( xn < 0 || yn < 0 || xn >= level . w * 16 || yn >= level . h * 16 || zn < 0 || zn > level . maxHeight ) { if ( zn < 0 ) z = 0 ; collide ( null , xxa , yya , zza ) ; return ; } List < Entity > entities = level . getEntities ( xn - xr , yn - yr , zn , xn + xr , yn + yr , zn + zh ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { Entity e = entities . get ( i ) ; if ( e == this ) continue ; if ( e . blocks ( this ) && blocks ( e ) ) { collide ( e , xxa , yya , zza ) ; return ; } } if ( level . wallBlocks ( xn - xr , yn - yr , zn , xn + xr , yn + yr , zn + zh ) ) { collide ( null , xxa , yya , zza ) ; return ; } x = xn ; y = yn ; z = zn ; return ; }
tr	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Rectangle that = ( Rectangle ) o ; if ( this . color . equals ( that . getColor ( ) ) && this . x . equals ( that . getX ( ) ) && this . y . equals ( that . getY ( ) ) && this . z . equals ( that . getZ ( ) ) ) { return true ; } return false ; }
tr	2	public boolean isNotAPoint ( Point new_point ) { return p1 != new_point && p2 != new_point && p3 != new_point ; }
tr	9	private Task [ ] parseHTML ( Task aTask ) { String filename = aTask . getFilename ( ) ; String folderPath = aTask . getFolderPath ( ) ; if ( ! JLogger . checkForSize ( filename , folderPath , org . Setup . FILE_SIZE_LIMIT_HTML ) ) { crawlerCTRL . println_Crawler ( "~~> \"" + filename + "\" has been deleted due to small size" ) ; JLogger jLogger = new JLogger ( ) ; try { jLogger . openHTMLLog ( aTask . getFolderPath ( ) + org . Setup . _S_ + "deleted.log" ) ; jLogger . burnHTMLLog ( "~~> \"" + filename + "\" deleted @ " + Timer . getTimeStamp ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { jLogger . closeHTMLLog ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return null ; } List < Task > outputTaskSet = new LinkedList < Task > ( ) ; JHtmlParser htmlParser = new JHtmlParser ( ) ; Task originalTask = htmlParser . parseHTML ( aTask ) ; originalTask . setType ( AtlasJob . J_EXPORT_HTML ) ; outputTaskSet . add ( originalTask ) ; Map < String , String > map = originalTask . getContentAll ( ) ; Task linkTask = null ; String url = "" ; Set < String > set = map . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; String mapValue = map . get ( key ) ; if ( mapValue == null || ! mapValue . contains ( "http://" ) ) continue ; String [ ] vals = mapValue . split ( "[;]" ) ; for ( int i = 0 ; i < vals . length ; i ++ ) { if ( vals [ i ] != null || vals [ i ] . length ( ) > 0 ) { url = vals [ i ] . trim ( ) ; String filename_PDF = url . substring ( url . lastIndexOf ( "/" ) + 1 , url . length ( ) ) ; String folderPath_PDF = folderPath + org . Setup . _S_ + "files" ; if ( ! filename_PDF . endsWith ( ".pdf" ) ) continue ; if ( url . startsWith ( "http://cdsweb.cern.ch" ) ) { linkTask = new AtlasTask ( originalTask . getId ( ) , originalTask . getJobId ( ) , AtlasJob . J_CRAWL ) ; linkTask . setUrl ( url ) ; linkTask . setFolderPath ( folderPath_PDF ) ; linkTask . setFilename ( filename_PDF ) ; linkTask . setExtension ( ".pdf" ) ; outputTaskSet . add ( linkTask ) ; } } } } Task [ ] tasks = ( Task [ ] ) outputTaskSet . toArray ( new Task [ outputTaskSet . size ( ) ] ) ; return tasks ; }
tr	9	private static void testInteger ( Map < Integer , Integer > m ) { m . clear ( ) ; try { m . add ( null , 1 ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } try { m . add ( 1 , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } begin ( "zero" ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; assertExpected ( "remove" , null , m . remove ( 1 ) ) ; end ( ) ; begin ( "one" ) ; begin ( "add" ) ; assertExpected ( "add" , null , m . add ( 1 , 2 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; begin ( "replace" ) ; assertExpected ( "add" , 2 , m . add ( 1 , 3 ) ) ; assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 3 , m . get ( 1 ) ) ; end ( ) ; begin ( "remove" ) ; assertExpected ( "remove" , 3 , m . remove ( 1 ) ) ; assertFalse ( "contains" , m . contains ( 1 ) ) ; assertTrue ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 0 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( 1 ) ) ; end ( ) ; end ( ) ; begin ( "add many" ) ; int size = 1000 ; m . clear ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "add " + i + " " + ( i + 1 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 1 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 1 , m . get ( i ) ) ; end ( ) ; begin ( "replace " + i + " " + ( i + 2 ) ) ; assertExpected ( "add" , i + 1 , m . add ( i , i + 2 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 2 , m . get ( i ) ) ; end ( ) ; begin ( "remove " + i + " " + ( i + 2 ) ) ; assertExpected ( "remove" , i + 2 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; begin ( "add again " + i + " " + ( i + 3 ) ) ; assertExpected ( "add" , null , m . add ( i , i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , i , m . size ( ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } end ( ) ; for ( int i = 1 ; i <= size ; ++ i ) { begin ( "check many " + i + " " + ( i + 3 ) ) ; assertTrue ( "contains" , m . contains ( i ) ) ; assertExpected ( "get" , i + 3 , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { begin ( "remove many asc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == size , m . empty ( ) ) ; assertExpected ( "size" , size - i , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } for ( int i = 1 ; i <= size ; ++ i ) { m . add ( i , i + 3 ) ; } for ( int i = size ; i >= 1 ; -- i ) { begin ( "remove many desc " + i + " " + ( i + 3 ) ) ; assertExpected ( "remove" , i + 3 , m . remove ( i ) ) ; assertFalse ( "contains" , m . contains ( i ) ) ; assertEqual ( "empty" , i == 1 , m . empty ( ) ) ; assertExpected ( "size" , i - 1 , m . size ( ) ) ; assertExpected ( "get" , null , m . get ( i ) ) ; end ( ) ; } begin ( "add one remove many" ) ; m . clear ( ) ; m . add ( 1 , 2 ) ; for ( int i = 1 ; i <= 50 ; ++ i ) { m . remove ( 2 ) ; } assertTrue ( "contains" , m . contains ( 1 ) ) ; assertFalse ( "empty" , m . empty ( ) ) ; assertExpected ( "size" , 1 , m . size ( ) ) ; assertExpected ( "get" , 2 , m . get ( 1 ) ) ; end ( ) ; }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	3	public Info ( java . awt . Frame parent ) throws InterruptedException { super ( parent , true ) ; initComponents ( ) ; a = new Methods ( ) . LFname ( query . GetKeyName ( ) ) ; data = query . Info ( 0 , false , a [ 1 ] , a [ 0 ] , true ) ; id . setText ( data [ 0 ] ) ; name . setText ( data [ 2 ] + "  " + data [ 1 ] ) ; gender . setText ( data [ 3 ] ) ; pos . setText ( data [ 4 ] ) ; birth . setText ( data [ 5 ] ) ; age . setText ( String . valueOf ( new Methods ( ) . DateToAge ( data [ 5 ] ) ) ) ; if ( data [ 6 ] . equals ( "" ) ) data [ 6 ] = "[no data]" ; cont . setText ( data [ 6 ] ) ; if ( data [ 7 ] . equals ( "" ) ) data [ 7 ] = "[no data]" ; addr . setText ( data [ 7 ] ) ; date . setText ( data [ 8 ] ) ; infoP . setVisible ( data [ 6 ] . equalsIgnoreCase ( "[no data]" ) || data [ 7 ] . equalsIgnoreCase ( "[no data]" ) ) ; }
tr	4	public static boolean intersects ( final IShape shape1 , final Vector3f vertex ) { simplex . clear ( ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , vertex , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS ) { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , vertex , v ) ; if ( v . . ( e . v ) > 0 ) { return false ; } if ( simplex . contains ( e . v ) ) break ; simplex . addElement ( ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } return true ; }
tr	2	public Battlefield ( ) { board = new Tile [ 10 ] [ 10 ] ; panel . setLayout ( new GridLayout ( row , col , 0 , 0 ) ) ; for ( int x = 0 ; x < row ; x ++ ) { for ( int y = 0 ; y < col ; y ++ ) { board [ x ] [ y ] = new Tile ( x , y , Tile . Status . WATER ) ; panel . add ( board [ x ] [ y ] ) ; } } }
tr	4	private int calcNumPattern ( int n , int r ) { if ( n == r ) return 1 ; else if ( n == 1 ) return 1 ; else if ( r == 1 ) return n ; if ( dp [ n ] [ r ] == 0 ) dp [ n ] [ r ] = ( calcNumPattern ( n - 1 , r - 1 ) + calcNumPattern ( n - 1 , r ) ) % NUM_MOD ; return dp [ n ] [ r ] ; }
tr	7	private void check ( long time ) { int i = 0 ; for ( long o : lastRecentDays ) { if ( o > daysThreashold * ONE_HOUR ) { if ( ++ i > 4 ) { if ( lastStatus != Status . Worker ) { this . listener . onAddWorker ( time , imsi , lastStatus ) ; lastStatus = Status . Worker ; } } } } if ( lastInside ) { if ( lastStatus != Status . Worker ) { this . listener . onAddTourist ( time , imsi , lastStatus ) ; lastStatus = Status . Tourist ; } } else { if ( lastStatus != Status . Worker ) { this . listener . onAddNormal ( time , imsi , lastStatus ) ; lastStatus = Status . Normal ; } } }
tr	3	@ Override protected List < Extractor > getExtractors ( ) { List < Extractor > ret = new ArrayList < > ( ) ; boolean stop = false ; for ( Element resultContainer : getResultContainers ( ) ) { if ( ! checkName ( resultContainer ) ) { stop = true ; continue ; } String url = getUrl ( resultContainer ) ; try { ret . add ( new WhitepagesPersonLoader ( url ) ) ; } catch ( MalformedURLException ignored ) { } } stopPaging . set ( stop ) ; return ret ; }
tr	3	public static final void closeWindow ( ) { if ( clickListener != null ) { clickListener . removeHandler ( ) ; } if ( keyPressListener != null ) { keyPressListener . removeHandler ( ) ; } if ( blurListener != null ) { blurListener . removeHandler ( ) ; } Alerts . closeWindow ( ) ; }
tr	4	private static void makePartitionTable ( ) { try { String content ; File partitionTable = new File ( Disk . transDisk + "/" + String . format ( "%05d" , Disk . partitionTableAddress ) + ".txt" ) ; if ( ! partitionTable . exists ( ) ) { System . out . println ( "Partition Table Not found" ) ; } content = "11111\t" + String . format ( "%05d" , 1 ) + "\t" + String . format ( "%05d" , 10 ) ; FileWriter fw = new FileWriter ( partitionTable . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( content ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { final String fsBitmapAddress = "5678\n9" ; Block superBlock = new Block ( Disk . transDisk + "/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "rw" ) ; String content = Disk . noOfBlocks + "\n" + fsBitmapAddress ; superBlock . write ( content . getBytes ( ) ) ; superBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	4	protected Object extractUnmarshalResult ( List < Map < String , Object >> models ) { if ( getClassType ( ) != null ) { List < Object > answer = new ArrayList < Object > ( ) ; for ( Map < String , Object > entry : models ) { Object data = entry . get ( getClassType ( ) . getName ( ) ) ; if ( data != null ) { answer . add ( data ) ; } } if ( answer . size ( ) == 1 ) { return answer . get ( 0 ) ; } else { return answer ; } } else { return models ; } }
tr	0	public FunctionalRequirement ( BigDecimal idFunctionalRequirement ) { this . idFunctionalRequirement = idFunctionalRequirement ; }
tr	9	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	9	public static String toString ( JSONArray ja ) throws JSONException { Object e ; int i ; JSONObject jo ; String k ; Iterator keys ; int length ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String v ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; e = ja . opt ( 1 ) ; if ( e instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) e ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { k = keys . next ( ) . toString ( ) ; XML . noSpace ( k ) ; v = jo . optString ( k ) ; if ( v != null ) { sb . append (   ) ; sb . append ( XML . escape ( k ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( v ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { e = ja . get ( i ) ; i += 1 ; if ( e != null ) { if ( e instanceof String ) { sb . append ( XML . escape ( e . toString ( ) ) ) ; } else if ( e instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) e ) ) ; } else if ( e instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) e ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	7	public Color ( int red , int green , int blue ) { this . red = red > 255 ? 255 : red < 0 ? 0 : red ; this . green = green > 255 ? 255 : green < 0 ? 0 : green ; this . blue = blue > 255 ? 255 : blue < 0 ? 0 : blue ; final String s = _names . get ( this ) ; if ( s != null ) { _name = s ; } else { final StringBuffer sb = new StringBuffer ( ) . append ( # ) ; encode ( sb , this . red ) ; encode ( sb , this . green ) ; encode ( sb , this . blue ) ; _name = sb . toString ( ) ; } }
tr	5	protected void setRequest ( CloudRequest request ) { if ( request != null ) { method = request . getMethod ( ) ; uriTemplate = request . getUri ( ) ; requestHeaders = new HashMap < > ( ) ; if ( request . getHeaders ( ) != null ) { requestHeaders . putAll ( request . getHeaders ( ) ) ; } requestParams = new HashMap < > ( ) ; if ( request . getParams ( ) != null ) { requestParams . putAll ( request . getParams ( ) ) ; } responseMapping = new HashMap < > ( ) ; if ( request . getMapping ( ) != null ) { responseMapping . putAll ( request . getMapping ( ) ) ; } if ( ! Utils . isNullOrEmpty ( request . getAuthorizationParam ( ) ) ) { enableAuthorizationParam ( request . getAuthorizationParam ( ) ) ; } else { enableAuthorizationHeader ( ) ; } } else { method = HttpMethod . GET ; uriTemplate = null ; responseMapping = new HashMap < > ( ) ; requestHeaders = new HashMap < > ( ) ; requestParams = new HashMap < > ( ) ; } }
tr	4	public void loadSprite ( String poseFileName ) { XMLUtilities xmlUtil = new XMLUtilities ( ) ; try { Document doc = xmlUtil . loadXMLDocument ( poseFileName , POSE_SCHEMA ) ; int poseWidth = xmlUtil . getIntData ( doc , POSE_WIDTH_NODE ) ; int poseHeight = xmlUtil . getIntData ( doc , POSE_HEIGHT_NODE ) ; PoseurPose tempPose = new PoseurPose ( poseWidth , poseHeight ) ; LinkedList < PoseurShape > shapesList = tempPose . getShapesList ( ) ; NodeList shapeNodes = doc . getElementsByTagName ( POSEUR_SHAPE_NODE ) ; for ( int i = 0 ; i < shapeNodes . getLength ( ) ; i ++ ) { Node node = shapeNodes . item ( i ) ; PoseurShape shapeToAdd ; Node geometryNode = xmlUtil . getChildNodeWithName ( node , GEOMETRY_NODE ) ; NamedNodeMap attributes = geometryNode . getAttributes ( ) ; String shapeTypeText = attributes . getNamedItem ( SHAPE_TYPE_ATTRIBUTE ) . getTextContent ( ) ; PoseurShapeType shapeType = PoseurShapeType . valueOf ( shapeTypeText ) ; if ( shapeType == PoseurShapeType . RECTANGLE ) { double x = double . parseDouble ( attributes . getNamedItem ( X_ATTRIBUTE ) . getTextContent ( ) ) ; double y = double . parseDouble ( attributes . getNamedItem ( Y_ATTRIBUTE ) . getTextContent ( ) ) ; double width = double . parseDouble ( attributes . getNamedItem ( WIDTH_ATTRIBUTE ) . getTextContent ( ) ) ; double height = double . parseDouble ( attributes . getNamedItem ( HEIGHT_ATTRIBUTE ) . getTextContent ( ) ) ; Rectangle2D . double geometry = new Rectangle2D . double ( x , y , width , height ) ; shapeToAdd = new PoseurRectangle ( geometry ) ; } else if ( shapeType == PoseurShapeType . ELLIPSE ) { double x = double . parseDouble ( attributes . getNamedItem ( X_ATTRIBUTE ) . getTextContent ( ) ) ; double y = double . parseDouble ( attributes . getNamedItem ( Y_ATTRIBUTE ) . getTextContent ( ) ) ; double width = double . parseDouble ( attributes . getNamedItem ( WIDTH_ATTRIBUTE ) . getTextContent ( ) ) ; double height = double . parseDouble ( attributes . getNamedItem ( HEIGHT_ATTRIBUTE ) . getTextContent ( ) ) ; Ellipse2D . double geometry = new Ellipse2D . double ( x , y , width , height ) ; shapeToAdd = new PoseurEllipse ( geometry ) ; } else { double x1 = double . parseDouble ( attributes . getNamedItem ( X1_ATTRIBUTE ) . getTextContent ( ) ) ; double y1 = double . parseDouble ( attributes . getNamedItem ( Y1_ATTRIBUTE ) . getTextContent ( ) ) ; double x2 = double . parseDouble ( attributes . getNamedItem ( X2_ATTRIBUTE ) . getTextContent ( ) ) ; double y2 = double . parseDouble ( attributes . getNamedItem ( Y2_ATTRIBUTE ) . getTextContent ( ) ) ; Line2D . double geometry = new Line2D . double ( x1 , y1 , x2 , y2 ) ; shapeToAdd = new PoseurLine ( geometry ) ; } Node outlineNode = xmlUtil . getChildNodeWithName ( node , OUTLINE_THICKNESS_NODE ) ; int outlineThickness = Integer . parseInt ( outlineNode . getTextContent ( ) ) ; BasicStroke outlineStroke = new BasicStroke ( outlineThickness ) ; Node alphaNode = xmlUtil . getChildNodeWithName ( node , ALPHA_NODE ) ; int alpha = Integer . parseInt ( alphaNode . getTextContent ( ) ) ; shapeToAdd . setAlpha ( alpha ) ; shapeToAdd . setOutlineThickness ( outlineStroke ) ; shapesList . add ( shapeToAdd ) ; } Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager stateManager = singleton . getStateManager ( ) ; PoseurPose actualPose = stateManager . getPose ( ) ; actualPose . loadPoseData ( tempPose ) ; PoseurGUI gui = singleton . getGUI ( ) ; JOptionPane . showMessageDialog ( gui , POSE_LOADED_TEXT , POSE_LOADED_TITLE_TEXT , JOptionPane . INFORMATION_MESSAGE ) ; singleton . getStateManager ( ) . setState ( PoseurState . SELECT_SHAPE_STATE ) ; } catch ( InvalidXMLFileFormatException | DOMException | HeadlessException ex ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurGUI gui = singleton . getGUI ( ) ; JOptionPane . showMessageDialog ( gui , POSE_LOADING_ERROR_TEXT , POSE_LOADING_ERROR_TITLE_TEXT , JOptionPane . ERROR_MESSAGE ) ; } }
tr	1	public static void print ( int level , String message ) { if ( level <= LEVEL ) { System . out . println ( String . format ( " debug [%d] - %s" , level , message ) ) ; } }
tr	9	private void readPixels ( BufferedImage img ) { height = img . getHeight ( ) ; width = img . getWidth ( ) ; packedPixels = new int [ width * height ] ; PixelGrabber pixelgrabber = new PixelGrabber ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , packedPixels , 0 , img . getWidth ( ) ) ; try { pixelgrabber . grabPixels ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( ) ; } ByteBuffer unpackedPixels = ByteBuffer . allocateDirect ( packedPixels . length * 4 ) ; int powerof2 = 64 ; while ( powerof2 < Math . max ( width , height ) ) powerof2 *= 2 ; texels = new int [ powerof2 * powerof2 ] ; for ( int row = img . getHeight ( ) - 1 ; row >= 0 ; row -- ) for ( int col = 0 ; col < img . getWidth ( ) ; col ++ ) { int packedPixel = packedPixels [ row * img . getWidth ( ) + col ] ; texels [ row * powerof2 + col ] = packedPixel ; unpackedPixels . put ( ( byte ) ( packedPixel >> 24 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel >> 16 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel >> 8 & ff ) ) ; unpackedPixels . put ( ( byte ) ( packedPixel & ff ) ) ; } if ( powerof2 != width && powerof2 != height ) { uclamp = ( double ) width / powerof2 ; vclamp = ( double ) height / powerof2 ; int packed [ ] = new int [ powerof2 * powerof2 ] ; ByteBuffer unpacked = ByteBuffer . allocateDirect ( packed . length * 4 ) ; for ( int x = 0 ; x < powerof2 ; x ++ ) for ( int y = 0 ; y < powerof2 ; y ++ ) if ( x < width && y < height ) packed [ x + y * powerof2 ] = packedPixels [ x + y * width ] ; else if ( x >= width ) packed [ x + y * powerof2 ] = packed [ width - 1 + y * powerof2 ] ; else if ( y >= height ) packed [ x + y * powerof2 ] = packed [ x + ( height - 1 ) * powerof2 ] ; for ( int row = powerof2 - 1 ; row >= 0 ; row -- ) for ( int col = 0 ; col < powerof2 ; col ++ ) { int packedPixel = packed [ row * powerof2 + col ] ; unpacked . put ( ( byte ) ( packedPixel >> 24 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel >> 16 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel >> 8 & ff ) ) ; unpacked . put ( ( byte ) ( packedPixel & ff ) ) ; } packedPixels = packed ; unpackedPixels = unpacked ; } height = powerof2 ; width = powerof2 ; bytebuff = unpackedPixels ; }
tr	3	private void checkConvexCut ( Point [ ] points , Point a , Point n ) { Point [ ] [ ] hullp = convexCut ( convexHull ( points ) , a , n ) ; System . out . println ( Arrays . deepToString ( hullp ) ) ; assertTrue ( isConvex ( hullp ) ) ; for ( Point p : points ) { int type = isInConvex ( p , hullp ) ; double d = a . subtract ( p ) . . ( n ) ; if ( approxEquals ( d , 0 ) ) assertTrue ( type == 2 ) ; else if ( d > 0 ) assertTrue ( type != 0 ) ; else assertTrue ( type == 0 ) ; } }
tr	3	public List < double > toOrderedList ( ) { List < double > distr = new ArrayList < double > ( ) ; for ( int i = 0 ; i < this . getRows ( ) ; i ++ ) { for ( int j = 0 ; j < this . getColumns ( ) ; j ++ ) { if ( ! this . isSparse ( i , j ) ) distr . add ( this . getSimilarity ( i , j ) ) ; } } Collections . sort ( distr ) ; return distr ; }
tr	7	public void addItem ( Item item , int amount ) { System . out . println ( "added " + amount + " of " + item + " to " + owner ) ; if ( item . isStackable ( ) ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( objectType [ i ] . id == item . id && objectType [ i ] . subID == item . subID && objectNumber [ i ] < 999 ) { objectNumber [ i ] = objectNumber [ i ] + amount ; return ; } } } for ( int i = 0 ; i < size ; i ++ ) { if ( objectType [ i ] . id == 0 ) { objectType [ i ] = item ; objectNumber [ i ] = amount ; return ; } } System . out . println ( "warning  inventory is full" ) ; }
tr	7	private Component buildComponent ( Configuration configuration , ConfiguredComponent configuredComponent ) throws ConfigurationException { try { ConfiguredComponent rootComponent = null ; String className = configuredComponent . getClassName ( ) ; if ( className == null ) { rootComponent = configuration . getComponent ( configuredComponent . getName ( ) ) ; className = rootComponent . getClassName ( ) ; } class componentClass = class . forName ( className ) ; Component component = ( Component ) componentClass . newInstance ( ) ; if ( rootComponent != null ) { for ( String name : rootComponent . getProperties ( ) . keySet ( ) ) { setProperty ( component , name , VariableResolver . resolve ( configuration , rootComponent . getProperties ( ) . get ( name ) ) ) ; } } Map < String , String > properties = configuredComponent . getProperties ( ) ; for ( String name : properties . keySet ( ) ) { setProperty ( component , name , VariableResolver . resolve ( configuration , properties . get ( name ) ) ) ; } component . initialise ( configuration ) ; component . setLocation ( configuredComponent . getName ( ) ) ; return component ; } catch ( ClassNotFoundException e ) { throw new ConfigurationException ( "Cannot instantiate " + configuredComponent . getClassName ( ) ) ; } catch ( IllegalAccessException e ) { throw new ConfigurationException ( "Cannot instantiate " + configuredComponent . getClassName ( ) ) ; } catch ( InstantiationException e ) { throw new ConfigurationException ( "Cannot instantiate " + configuredComponent . getClassName ( ) ) ; } }
tr	6	public static boolean isInside ( final IColumnVector < float > x , final IColumnVector < float > y , final IColumnVector < float > z , final IColumnVector < float > p ) { if ( x == null ) { throw new NullPointerException ( "'x' must not be 'null'" ) ; } if ( y == null ) { throw new NullPointerException ( "'y' must not be 'null'" ) ; } if ( z == null ) { throw new NullPointerException ( "'z' must not be 'null'" ) ; } if ( p == null ) { throw new NullPointerException ( "'p' must not be 'null'" ) ; } IColumnVector < float > v1 = new ColumnVector ( y . get ( 0 , 0 ) - x . get ( 0 , 0 ) , y . get ( 1 , 0 ) - x . get ( 1 , 0 ) ) ; IColumnVector < float > v2 = new ColumnVector ( z . get ( 0 , 0 ) - x . get ( 0 , 0 ) , z . get ( 1 , 0 ) - x . get ( 1 , 0 ) ) ; double determinate = v1 . get ( 0 , 0 ) * v2 . get ( 1 , 0 ) - v2 . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) ; IColumnVector < float > tmp = new ColumnVector ( p . get ( 0 , 0 ) - x . get ( 0 , 0 ) , p . get ( 1 , 0 ) - x . get ( 1 , 0 ) ) ; double lambda = ( tmp . get ( 0 , 0 ) * v2 . get ( 1 , 0 ) - v2 . get ( 0 , 0 ) * tmp . get ( 1 , 0 ) ) / determinate ; double mue = ( v1 . get ( 0 , 0 ) * tmp . get ( 1 , 0 ) - tmp . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) ) / determinate ; return ( lambda > 0 && mue > 0 && ( lambda + mue ) < 1 ) ; }
tr	0	public void valueChanged ( ListSelectionEvent e ) { }
tr	6	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	0	public Iterator < ChannelUser > iterChannelUsers ( ) { return users . iterator ( ) ; }
tr	5	private static void loadVersionProperties ( ) { ClassLoader loader = ReleaseInfo . class . getClassLoader ( ) ; Properties info = new Properties ( ) ; InputStream stream = loader . getResourceAsStream ( PROPERTY_FILE ) ; if ( stream == null ) stream = loader . getResourceAsStream ( "/" + PROPERTY_FILE ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildVersion = info . getProperty ( "version" ) ; buildDate = info . getProperty ( "build.date" ) ; } catch ( IOException e ) { } } if ( buildVersion == null ) buildVersion = "unknown" ; if ( buildDate == null ) buildDate = "unknown" ; }
tr	9	public void setZeroes ( int [ ] [ ] matrix ) { boolean firstRowZero = false ; boolean firstColumnZero = false ; for ( int i = 0 ; i < matrix . length ; i ++ ) { if ( matrix [ i ] [ 0 ] == 0 ) { firstColumnZero = true ; break ; } } for ( int i = 0 ; i < matrix [ 0 ] . length ; i ++ ) { if ( matrix [ 0 ] [ i ] == 0 ) { firstRowZero = true ; break ; } } for ( int i = 1 ; i < matrix . length ; i ++ ) { for ( int j = 1 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] == 0 ) { matrix [ i ] [ 0 ] = 0 ; matrix [ 0 ] [ j ] = 0 ; } } } for ( int i = 1 ; i < matrix . length ; i ++ ) { for ( int j = 1 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ 0 ] == 0 || matrix [ 0 ] [ j ] == 0 ) { matrix [ i ] [ j ] = 0 ; } } } if ( firstColumnZero ) { for ( int i = 0 ; i < matrix . length ; i ++ ) { matrix [ i ] [ 0 ] = 0 ; } } if ( firstRowZero ) { for ( int i = 0 ; i < matrix [ 0 ] . length ; i ++ ) { matrix [ 0 ] [ i ] = 0 ; } } }
tr	9	public double search ( double [ ] m ) { int n = m . length ; int correction = n % 2 == 0 ? 1 : 0 ; double min , max ; min = max = m [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( m [ i ] < min ) min = m [ i ] ; if ( m [ i ] > max ) max = m [ i ] ; } long leftOutRange = 0 ; long rightOutRange = 0 ; Histogram histogram = new Histogram ( ) ; while ( true ) { loopCount ++ ; histogram . init ( min , max ) ; for ( int i = 0 ; i < n ; i ++ ) { histogram . add ( m [ i ] ) ; } long countInRanges = histogram . totalCount - histogram . others ; if ( countInRanges == 1 ) { return histogram . latestInRange ; } long incCount = 0 ; for ( int i = 0 ; i < histogram . rangeCount ; i ++ ) { long rangeCount = histogram . counts [ i ] ; incCount += rangeCount ; long rightOutCurrentRange = ( countInRanges + rightOutRange ) - incCount ; if ( incCount + leftOutRange >= rightOutCurrentRange - correction ) { min = i == 0 ? histogram . start : histogram . ranges [ i - 1 ] ; max = histogram . ranges [ i ] ; if ( histogram . almostSame ( min , max ) ) { return min ; } leftOutRange += ( incCount - rangeCount ) ; rightOutRange = rightOutCurrentRange ; break ; } } } }
tr	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; UndirectedGraphNode node = this ; List < UndirectedGraphNode > set = new ArrayList < > ( ) ; LinkedList < UndirectedGraphNode > unvisited = new LinkedList < > ( ) ; unvisited . add ( node ) ; while ( ! unvisited . isEmpty ( ) ) { UndirectedGraphNode current = unvisited . pop ( ) ; set . add ( current ) ; for ( UndirectedGraphNode n : current . neighbors ) { if ( n != null && ! set . contains ( n ) ) { unvisited . add ( n ) ; } } } Collections . sort ( set , new Comparator < UndirectedGraphNode > ( ) { @ Override public int compare ( UndirectedGraphNode o1 , UndirectedGraphNode o2 ) { return o1 . label - o2 . label ; } } ) ; for ( UndirectedGraphNode n : set ) { sb . append ( n . label ) . append ( ":" ) ; for ( UndirectedGraphNode neighbor : n . neighbors ) { sb . append ( neighbor . label ) . append ( " " ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; sb . append ( "#" ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
tr	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	8	public boolean equals ( get_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . is_set_success ( ) ; boolean that_present_success = true && that . is_set_success ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
tr	9	public void postInstall ( ) { String plUser = Configuration . getConfig ( Configuration . CONFIG_PIPELINE_USER ) ; String startServer = Configuration . getConfig ( Configuration . START_PIPELINE_SERVER ) ; String configureServer = Configuration . getConfig ( Configuration . CONFIGURE_PIPELINE_SERVER ) ; String startClient = Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT ) ; boolean needsServerStart = startServer != null ? boolean . parseBoolean ( startServer ) : false ; boolean needsConfigureServer = configureServer != null ? boolean . parseBoolean ( configureServer ) : false ; boolean needsClientStart = startClient != null ? boolean . parseBoolean ( startClient ) : false ; if ( needsClientStart || needsConfigureServer || needsServerStart ) { StringBuilder cmd = new StringBuilder ( System . getProperty ( "user.dir" ) ) ; cmd . append ( "/install_files/postInstall.sh " ) ; cmd . append ( plUser ) ; cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . CONFIG_PIPELINE_LOCATION ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsServerStart ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsConfigureServer ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsClientStart ) ) ; if ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) != null ) { cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) ) ; } Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( cmd . toString ( ) ) ; if ( ! needsConfigureServer ) { StreamReader isr = new StreamReader ( p . getInputStream ( ) , 1 ) ; StreamReader esr = new StreamReader ( p . getErrorStream ( ) , 2 ) ; isr . start ( ) ; esr . start ( ) ; p . waitFor ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null && ! needsConfigureServer ) NativeCalls . releaseProcess ( p ) ; if ( needsConfigureServer ) Configuration . setConfig ( Configuration . CONFIGURE_PIPELINE_SERVER , "false" ) ; } } }
tr	7	public void createLatinSquare ( ) { List < Integer > seed = new ArrayList < > ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) seed . add ( i ) ; Collections . shuffle ( seed ) ; Integer corner = seed . get ( 0 ) ; for ( int c = 0 ; c < maxValue ; c ++ ) { Point p = new Point ( c + 1 , 1 ) ; try { Cell cell = cells . get ( p ) ; cell . setValue ( seed . get ( c ) ) ; } catch ( CellContentException e ) { System . err . println ( "Shouldn't happen " + e ) ; } } seed . clear ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) { if ( i != corner ) { seed . add ( i ) ; } } Collections . shuffle ( seed ) ; for ( int r = 1 ; r < maxValue ; r ++ ) { Point p = new Point ( 1 , r + 1 ) ; try { Cell cell = cells . get ( p ) ; cell . setValue ( seed . get ( r - 1 ) ) ; } catch ( CellContentException e ) { System . err . println ( "Shouldn't happen " + e ) ; } } solveBruteForce ( ) ; }
tr	0	public Sprite ( int i , int j ) { pixels = new int [ i * j ] ; width = maxWidth = i ; height = maxHeight = j ; offsetX = offsetY = 0 ; }
tr	3	public boolean mouseUp ( int x , int y ) { if ( selected >= 0 && isWithin ( selected , x , y ) ) { Signal s = signal [ selected ] ; if ( s . size ( ) == 0 ) s . setState ( ! s . getState ( ) ) ; else s . select ( ( s . getSelected ( ) + 1 ) % s . size ( ) ) ; return true ; } return false ; }
tr	8	public Sprite ( StreamLoader streamLoader , String s , int i ) { Stream stream = new Stream ( streamLoader . getDataForName ( s + ".dat" ) ) ; Stream stream_1 = new Stream ( streamLoader . getDataForName ( "index.dat" ) ) ; stream_1 . currentOffset = stream . readUnsignedWord ( ) ; anInt1444 = stream_1 . readUnsignedWord ( ) ; anInt1445 = stream_1 . readUnsignedWord ( ) ; int j = stream_1 . readUnsignedByte ( ) ; int ai [ ] = new int [ j ] ; for ( int k = 0 ; k < j - 1 ; k ++ ) { ai [ k + 1 ] = stream_1 . read3Bytes ( ) ; if ( ai [ k + 1 ] == 0 ) ai [ k + 1 ] = 1 ; } for ( int l = 0 ; l < i ; l ++ ) { stream_1 . currentOffset += 2 ; stream . currentOffset += stream_1 . readUnsignedWord ( ) * stream_1 . readUnsignedWord ( ) ; stream_1 . currentOffset ++ ; } anInt1442 = stream_1 . readUnsignedByte ( ) ; anInt1443 = stream_1 . readUnsignedByte ( ) ; myWidth = stream_1 . readUnsignedWord ( ) ; myHeight = stream_1 . readUnsignedWord ( ) ; int i1 = stream_1 . readUnsignedByte ( ) ; int j1 = myWidth * myHeight ; myPixels = new int [ j1 ] ; if ( i1 == 0 ) { for ( int k1 = 0 ; k1 < j1 ; k1 ++ ) myPixels [ k1 ] = ai [ stream . readUnsignedByte ( ) ] ; setTransparency ( 255 , 0 , 255 ) ; return ; } if ( i1 == 1 ) { for ( int l1 = 0 ; l1 < myWidth ; l1 ++ ) { for ( int i2 = 0 ; i2 < myHeight ; i2 ++ ) myPixels [ l1 + i2 * myWidth ] = ai [ stream . readUnsignedByte ( ) ] ; } } setTransparency ( 255 , 0 , 255 ) ; }
tr	7	@ Override public String convertParameterToPrint ( final Object paramValue ) { final String printedParam ; if ( paramValue == null ) { printedParam = "NULL" ; } else if ( paramValue instanceof String ) { printedParam = "'" + ( String ) paramValue + "'" ; } else if ( paramValue instanceof Integer ) { printedParam = ( ( Integer ) paramValue ) . toString ( ) ; } else if ( paramValue instanceof long ) { printedParam = ( ( long ) paramValue ) . toString ( ) ; } else if ( paramValue instanceof Date ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss.SSS" ) ; printedParam = "'" + format . format ( ( Date ) paramValue ) + "'" ; } else if ( paramValue instanceof QueryTypeGmtTimeInMillis ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss.SSS" ) ; printedParam = "'" + format . format ( new Date ( ( ( QueryTypeGmtTimeInMillis ) paramValue ) . getMillis ( ) ) ) + "'" ; } else if ( paramValue instanceof QueryTypeGmtTimeInNanos ) { long gmtTimeInNanos = ( ( QueryTypeGmtTimeInNanos ) paramValue ) . getNanos ( ) ; long gmtTimeInMillis = TimeUnit . MILLISECONDS . convert ( gmtTimeInNanos , TimeUnit . NANOSECONDS ) ; long onlyNanos = ( gmtTimeInNanos - TimeUnit . NANOSECONDS . convert ( gmtTimeInMillis , TimeUnit . MILLISECONDS ) ) ; SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss.SSS" ) ; printedParam = "'" + format . format ( new Date ( gmtTimeInMillis ) ) + " " + onlyNanos + "'" ; } else { printedParam = "!!!'" + paramValue . toString ( ) + "'!!!" ; } return printedParam ; }
tr	1	public int confBlok ( Sudoku s ) { int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) sum += confBlok ( i , s ) ; return sum ; }
tr	8	@ Override public void mouseClicked ( int button , int x , int y , int clickcount ) { System . out . println ( "clicked in a window  x:" + x + " y:" + y ) ; boolean found = false ; for ( GUIObject obj : objects . values ( ) ) { if ( ! obj . isInput ( ) ) continue ; if ( x >= obj . getRealX ( ) && x < obj . getRealX ( ) + obj . getRealWidth ( ) ) { if ( y >= obj . getRealY ( ) && y < obj . getRealY ( ) + obj . getRealHeight ( ) ) { found = true ; System . out . println ( "Clicked " + obj . getName ( ) ) ; obj . mouseClicked ( button , x - obj . getRealX ( ) , y - obj . getRealY ( ) , clickcount ) ; break ; } } } if ( ! found ) { if ( selected != null ) { selected . setSelected ( false ) ; selected = null ; } } }
tr	7	protected void addPointToHull ( Vertex eyeVtx ) { horizon . clear ( ) ; unclaimed . clear ( ) ; if ( debug ) { System . out . println ( "Adding point: " + eyeVtx . pnt . toString ( ) ) ; System . out . println ( " which is " + eyeVtx . face . distanceToPlane ( eyeVtx . pnt ) + " above face " + eyeVtx . face . getVertexString ( ) ) ; } removePointFromFace ( eyeVtx , eyeVtx . face ) ; calculateHorizon ( eyeVtx . pnt , null , eyeVtx . face , horizon ) ; newFaces . clear ( ) ; addNewFaces ( newFaces , eyeVtx , horizon ) ; for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . VISIBLE ) { while ( doAdjacentMerge ( face , NONCONVEX_WRT_LARGER_FACE ) ) ; } } for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . NON_CONVEX ) { face . mark = Face . VISIBLE ; while ( doAdjacentMerge ( face , NONCONVEX ) ) ; } } resolveUnclaimedPoints ( newFaces ) ; }
tr	2	public void create ( Announcements transientInstance ) { log . debug ( "creating " + entitySimpleName + " instance" ) ; try { super . create ( transientInstance ) ; log . debug ( "creating " + entitySimpleName + " successful" ) ; } catch ( EntityAlreadyExistsException ex ) { log . debug ( "creating " + entitySimpleName + " failed: " + ex . getMessage ( ) ) ; } catch ( RuntimeException re ) { log . error ( "creating " + entitySimpleName + " failed" , re ) ; throw re ; } }
tr	2	public static void sleep ( long timeToSleep ) { if ( timeToSleep <= 0 ) return ; try { Thread . sleep ( timeToSleep ) ; } catch ( InterruptedException e ) { } }
tr	5	private boolean jj_3R_15 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_1 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_20 ( ) ) { jj_scanpos = xsp ; if ( jj_3_3 ( ) ) { jj_scanpos = xsp ; if ( jj_3_4 ( ) ) { jj_scanpos = xsp ; if ( jj_3_5 ( ) ) return true ; } } } } return false ; }
tr	8	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	9	@ Override public float [ ] getFloatData ( float [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { float [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new float [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) Utilities . UNSAFE . getInt ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ ( int ) i ] ; } } } return out ; } }
tr	5	public boolean canAppend ( WriteCommand command ) throws IOException { switch ( command . opItem . op ) { case OpItem . OP_DEL : if ( command . opItem . number != this . number ) { return false ; } break ; case OpItem . OP_ADD : if ( this . dataFile . getLength ( ) + command . data . length >= JournalStore . FILE_SIZE ) { return false ; } if ( this . dataSize + command . data . length >= DataFileAppender . this . maxWriteBatchSize ) { return false ; } break ; default : throw new RuntimeException ( "Unknow op type " + command . opItem ) ; } return true ; }
tr	9	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	4	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append ( '' ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
tr	3	public static ShellFiredReply Create ( ByteList messageBytes ) throws Exception { ShellFiredReply result ; if ( messageBytes == null || messageBytes . getLength ( ) < 6 ) { throw new Exception ( "Invalid message byte array" ) ; } if ( messageBytes . peekShort ( ) != ShellFiredReply . getClassID ( ) ) { throw new Exception ( "Invalid message type" ) ; } else { result = new ShellFiredReply ( ) ; result . decode ( messageBytes ) ; } return result ; }
tr	9	@ Override public void addUser ( String login , String password , Role role , String email , String phone ) throws DAOException { final String filename = Constants . ResourcePath + ConstantsXML . USERS_FILE_NAME ; Scanner sc = null ; synchronized ( CSVUserDAO . class ) { try { boolean found = false ; sc = new Scanner ( new FileReader ( filename ) ) ; while ( sc . hasNext ( ) ) { String [ ] str = sc . nextLine ( ) . split ( CSV_SPLITTER ) ; if ( str [ LOGIN_NUM ] . equals ( login ) ) { found = true ; break ; } } if ( found ) { throw new DAOException ( Constants . INVALID_NAME ) ; } } catch ( DAOException e ) { throw new DAOException ( e ) ; } catch ( FileNotFoundException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; throw new DAOException ( Constants . INTERNAL_ERROR ) ; } finally { if ( sc != null ) { sc . close ( ) ; } } PrintWriter writer = null ; try { User user = new User ( login , password , email , phone , role , ++ maxId ) ; writer = new PrintWriter ( new FileWriter ( filename , true ) ) ; writer . println ( user ) ; } catch ( Exception e ) { throw new DAOException ( e ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } }
tr	6	public static String getCommonPrefix ( Automaton a ) { if ( a . isSingleton ( ) ) return a . singleton ; StringBuilder b = new StringBuilder ( ) ; HashSet < State > visited = new HashSet < State > ( ) ; State s = a . initial ; boolean done ; do { done = true ; visited . add ( s ) ; if ( ! s . accept && s . transitions . size ( ) == 1 ) { Transition t = s . transitions . iterator ( ) . next ( ) ; if ( t . min == t . max && ! visited . contains ( t . to ) ) { b . append ( t . min ) ; s = t . to ; done = false ; } } } while ( ! done ) ; return b . toString ( ) ; }
tr	8	public void read ( org . apache . thrift . protocol . TProtocol iprot , Location struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . double ) { struct . latitude = iprot . readDouble ( ) ; struct . setLatitudeIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . double ) { struct . longitude = iprot . readDouble ( ) ; struct . setLongitudeIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; if ( ! struct . isSetLatitude ( ) ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'latitude' was not found in serialized data! Struct: " + toString ( ) ) ; } if ( ! struct . isSetLongitude ( ) ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'longitude' was not found in serialized data! Struct: " + toString ( ) ) ; } struct . validate ( ) ; }
tr	2	public Object unserialize ( String s ) throws IOException { return ( s == null || s . length ( ) == 0 ) ? null : new Integer ( s ) ; }
