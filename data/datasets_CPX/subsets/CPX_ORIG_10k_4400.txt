tr	1	public void push ( int x ) { if ( i < maks ) { stack [ i ] = x ; i ++ ; System . out . println ( x + " berhasil ditambahkan ke Stack" ) ; } else { System . out . println ( "Stack Penuh!" ) ; } }
tr	8	@ Override protected void doAction ( int option ) { switch ( option ) { case 1 : listAllPlaylists ( ) ; pause ( ) ; break ; case 2 : allSongsInPlaylist ( ) ; break ; case 3 : addPlaylist ( ) ; break ; case 4 : removePlaylist ( ) ; break ; case 5 : ReorderPlaylist ( ) ; break ; case 6 : addSongPlaylist ( ) ; break ; case 7 : removeSongPlaylist ( ) ; break ; case EXIT_VALUE : doActionExit ( ) ; } }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	4	public int readArrayLength ( ) throws IOException , UBJFormatException { byte type = checkType ( "ARRAY" , ARRAY_COMPACT , ARRAY ) ; int count = 0 ; switch ( type ) { case ARRAY_COMPACT : count = read ( ) ; if ( count == 255 ) count = - 1 ; break ; case ARRAY : count = readInt32Impl ( ) ; break ; } if ( count < 0 ) throw new UBJFormatException ( pos , "Encountered a negative (invalid) length of [" + count + "] specified for the ARRAY value at stream position " + pos + ". Length must be >= 0." ) ; return count ; }
tr	4	public static byte [ ] decodeFromFile ( String filename ) throws java . io . IOException { byte [ ] decodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = null ; int length = 0 ; int numBytes = 0 ; if ( file . length ( ) > Integer . MAX_VALUE ) { throw new java . io . IOException ( "File is too big for this convenience method (" + file . length ( ) + " bytes)." ) ; } buffer = new byte [ ( int ) file . length ( ) ] ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . DECODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) { length += numBytes ; } decodedData = new byte [ length ] ; System . arraycopy ( buffer , 0 , decodedData , 0 , length ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return decodedData ; }
tr	3	@ Override public Object handle ( List < ? extends Object > parameters ) { Object arg = parameters . get ( 0 ) ; if ( arg instanceof double ) return Math . round ( ( double ) arg ) ; if ( arg instanceof long ) return Math . round ( ( long ) arg ) ; return null ; }
tr	6	static public String numberToString ( Number n ) throws JSONException { if ( n == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( n ) ; String s = n . toString ( ) ; if ( s . indexOf ( . ) > 0 && s . indexOf ( e ) < 0 && s . indexOf ( E ) < 0 ) { while ( s . endsWith ( "0" ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } if ( s . endsWith ( "." ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } } return s ; }
tr	1	public static byte [ ] encodeBytesToBytes ( byte [ ] source ) { byte [ ] encoded = null ; try { encoded = encodeBytesToBytes ( source , 0 , source . length , Base64 . NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { assert false : "IOExceptions only come from GZipping  which is turned off: " + ex . getMessage ( ) ; } return encoded ; }
tr	6	private void notifyConnections ( MapEvent < ? extends Serializable > event ) { if ( isRunning && conns != null ) { Iterator < MapServerConnection > it = conns . iterator ( ) ; while ( it . hasNext ( ) ) { MapServerConnection conn = it . next ( ) ; try { if ( conn != event . getSource ( ) ) { conn . onMapEvent ( event ) ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; conn . close ( ) ; it . remove ( ) ; } } } }
tr	7	public static QuestionCalculation decode ( String encodedQuestionCalculation ) throws DecodeException { QuestionCalculation res ; if ( encodedQuestionCalculation . substring ( 0 , 19 ) . compareTo ( "#QuestionCalculaion" ) == 0 ) { res = new QuestionCalculation ( ) ; int i = 19 ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Integer > tmp_opd = decodeOperands ( encodedQuestionCalculation . substring ( 20 , i ) ) ; res . setOperands ( tmp_opd ) ; i ++ ; int beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Character > tmp_opt = decodeOperators ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_opt . size ( ) == tmp_opt . size ( ) + 1 : "incorrect size of operators table" ; res . setOperators ( tmp_opt ) ; i ++ ; beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } int tmp_lth = Integer . valueOf ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_lth < 0 : "negative length" ; res . setLength ( tmp_lth ) ; i ++ ; encodedQuestionCalculation = encodedQuestionCalculation . substring ( i ) ; Question . decode ( res , encodedQuestionCalculation ) ; } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	3	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	4	protected EncodedString decodeEncodedCharacterStringOnThirdbit ( ) throws IOException , FastInfosetException { switch ( current_octet & FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_MASK_DISCRIMINANT ) { case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF8_DISCRIMINANT : encodedStringBuffer . setUTF8 ( decodeUTF8inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF16_DISCRIMINANT : encodedStringBuffer . setUTF16 ( decodeUTF16inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALGORITHM_DISCRIMINANT : int index = decodeOctetInteger ( 5 ) ; Algorithm algo = vocabulary . algorithms . get ( index ) ; encodedStringBuffer . setAlgorithm ( index , algo , decodeNonEmptyOctetStringOnFifthBit ( ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALPHABET_DISCRIMINANT : int index2 = decodeOctetInteger ( 5 ) ; Algorithm algo2 = vocabulary . alphabets . get ( index2 ) ; encodedStringBuffer . setAlphabet ( index2 , algo2 , algo2 . fromByteArray ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; } throw new FastInfosetException ( ) ; }
tr	2	private int getTrapNumber ( GameState preCapture , GameState postCapture , int arimaaPieceType , boolean firstPiece ) { long preBB = preCapture . piece_bb [ arimaaPieceType ] ; int indexOfCap = Util . FirstOne ( preBB ) ; preBB ^= ( 1 << indexOfCap ) ; if ( firstPiece ) assert ( preBB == 0 ) ; if ( ! firstPiece ) { int indexOfCap2 = Util . FirstOne ( preBB ) ; return nearestTrap ( indexOfCap2 ) ; } return nearestTrap ( indexOfCap ) ; }
tr	5	public static void main ( String [ ] args ) { int numberOfBooks = 0 ; try { List < ABook > bList ; BookDatabaseAccess theBookDB = new BookDatabaseAccess ( ) ; bList = theBookDB . LoadBookList ( ) ; numberOfBooks = bList . size ( ) ; printTheList ( "Just loaded list" , bList ) ; ABook newBook = new ABook ( ) ; newBook . setIDCode ( ++ numberOfBooks ) ; newBook . setAuthor ( "Fowler  Martin" ) ; newBook . setTitle ( "UML Distilled" ) ; newBook . setSubject ( "Computer Fantasy" ) ; theBookDB . insertNewBook ( newBook ) ; bList = theBookDB . LoadBookList ( ) ; numberOfBooks = bList . size ( ) ; printTheList ( "Inserted new Record" , bList ) ; int bookNum ; for ( ABook a : bList ) { if ( a . getSubject ( ) . equals ( "Computer Fantasy" ) ) { bookNum = a . getIDCode ( ) ; ABook updateBook = new ABook ( bookNum , " " , " " , "Romance" ) ; theBookDB . updateBook ( updateBook ) ; } } bList = theBookDB . LoadBookList ( ) ; numberOfBooks = bList . size ( ) ; printTheList ( "Updated Category" , bList ) ; theBookDB . deleteBooks ( 23 ) ; bList = theBookDB . LoadBookList ( ) ; numberOfBooks = bList . size ( ) ; printTheList ( "Deleted Where IDCOde >= 23 " , bList ) ; } catch ( SQLException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
tr	8	public List < List < String >> findLadders ( String start , String end , Set < String > dict ) { Queue < List < String >> paths = new LinkedList < List < String >> ( ) ; List < List < String >> results = new ArrayList < List < String >> ( ) ; int level = 0 ; int wordsInCurrentLevel , wordsInNextLevel ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( start ) ; paths . add ( list ) ; dict . remove ( start ) ; wordsInCurrentLevel = 1 ; wordsInNextLevel = 0 ; level = 0 ; while ( ! paths . isEmpty ( ) ) { while ( wordsInCurrentLevel > 0 ) { List < String > p = paths . poll ( ) ; String w = p . get ( p . size ( ) - 1 ) ; wordsInCurrentLevel -- ; if ( w . equals ( end ) ) { p . add ( w ) ; results . add ( p ) ; } for ( int i = 0 ; i < w . length ( ) ; i ++ ) { char [ ] chars = w . toCharArray ( ) ; for ( char c = a ; c <= z ; c ++ ) { chars [ i ] = c ; String variant = new String ( chars ) ; if ( dict . contains ( variant ) ) { ArrayList < String > newPath = new ArrayList < String > ( p ) ; newPath . add ( variant ) ; paths . add ( newPath ) ; wordsInNextLevel ++ ; } } } } if ( ! results . isEmpty ( ) ) { return results ; } level ++ ; wordsInCurrentLevel = wordsInNextLevel ; wordsInNextLevel = 0 ; for ( List < String > l : paths ) { String w = l . get ( l . size ( ) - 1 ) ; dict . remove ( w ) ; } System . out . println ( "Level " + Integer . toString ( level ) + "  " + Integer . toString ( wordsInCurrentLevel ) ) ; } return results ; }
tr	9	public ModelEnvelope ( BufferedReader reader , boolean server ) throws IOException { modelBuff = new HashMap < String , TransferableModel > ( ) ; this . server = server ; String line = reader . readLine ( ) ; if ( line == null ) throw new EOFException ( "Expected envelope header got EOF" ) ; if ( ! line . equals ( ENVELOPE_HEADER ) ) throw new IOException ( "Expected envelope header  found " + line ) ; int numModels = Integer . parseInt ( reader . readLine ( ) ) ; countModels = Integer . parseInt ( reader . readLine ( ) ) ; TransferableModel [ ] list = new TransferableModel [ numModels ] ; newFlags = new boolean [ countModels ] ; try { for ( int i = 0 ; i < numModels ; i ++ ) { String name = reader . readLine ( ) , umid = reader . readLine ( ) ; list [ i ] = createModel ( name , reader , server ) ; if ( ! umid . equals ( "" ) ) { modelBuff . put ( umid , list [ i ] ) ; } } } catch ( IOException e ) { while ( ! reader . readLine ( ) . equals ( ENVELOPE_FOOTER ) ) ; throw new IOException ( "Exception reading model" , e ) ; } if ( ! ( line = reader . readLine ( ) ) . equals ( ENVELOPE_FOOTER ) ) { throw new IOException ( "Expected envelope footer line  got " + line ) ; } for ( int i = 0 ; i < list . length ; i ++ ) { list [ i ] . registerSubModels ( this ) ; if ( ( numModels - i ) <= countModels ) newFlags [ countModels - ( numModels - i ) ] = ModelCacher . containsKey ( list [ i ] . getUMID ( ) ) ; list [ i ] = ModelCacher . cache ( list [ i ] ) ; } models = new Stack < TransferableModel > ( ) ; modelUMIDs = new HashSet < String > ( ) ; for ( int i = list . length - 1 ; i >= list . length - countModels ; i -- ) { models . push ( list [ i ] ) ; modelUMIDs . add ( list [ i ] . getUMID ( ) ) ; } }
tr	0	@ XmlElementDecl ( namespace = "" , name = "xRequest" ) public JAXBElement < BigInteger > createXRequest ( BigInteger value ) { return new JAXBElement < BigInteger > ( _XRequest_QNAME , BigInteger . class , null , value ) ; }
tr	2	public static boolean isPrime ( long n ) { log ( "Checking " + n ) ; boolean isPrime = n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; if ( isPrime ) log ( "Prime found " + n ) ; return isPrime ; }
tr	7	static public String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String s = double . toString ( d ) ; if ( s . indexOf ( . ) > 0 && s . indexOf ( e ) < 0 && s . indexOf ( E ) < 0 ) { while ( s . endsWith ( "0" ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } if ( s . endsWith ( "." ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } } return s ; }
tr	4	@ Override public void toStringBuilder ( StringBuilder sb ) { DateFormat df = AbstractConnection . defaultDateTimeFormat ; sb . append ( getId ( ) + "\r\n" ) ; sb . append ( getName ( ) + "\r\n" ) ; if ( getDescription ( ) != null ) sb . append ( getDescription ( ) . trim ( ) + "\r\n" ) ; sb . append ( "\u0000\r\n" ) ; sb . append ( df . format ( getTimeFrom ( ) . getTime ( ) ) + "\r\n" ) ; sb . append ( df . format ( getTimeTo ( ) . getTime ( ) ) + "\r\n" ) ; sb . append ( getLocation ( ) + "\r\n" ) ; sb . append ( getOwner ( ) . getUMID ( ) + "\r\n" ) ; if ( getRoom ( ) != null ) sb . append ( getRoom ( ) . getUMID ( ) ) ; sb . append ( "\r\n" ) ; if ( getId ( ) != - 1 ) { sb . append ( getInvitations ( ) . size ( ) + "\r\n" ) ; for ( InvitationModel i : getInvitations ( ) ) sb . append ( i . getUMID ( ) + "\r\n" ) ; } else { sb . append ( "0\r\n" ) ; } }
tr	0	@ XmlElementDecl ( namespace = "http://api.soap.mytxtbuddy.com/" , name = "countGroups" ) public JAXBElement < CountGroups > createCountGroups ( CountGroups value ) { return new JAXBElement < CountGroups > ( _CountGroups_QNAME , CountGroups . class , null , value ) ; }
tr	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
tr	6	@ SuppressWarnings ( "unchecked" ) public < T > T get ( String modelName ) { try { modelName = modelName . substring ( 0 , 1 ) . toUpperCase ( ) + modelName . substring ( 1 ) ; Object model = modelInstances . get ( modelName ) ; if ( model == null ) { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; class < ? > modelClass = ClassUtils . forName ( modelPackage + "." + modelName ) ; Properties sqls = new Properties ( ) ; sqls . load ( classLoader . getResourceAsStream ( modelDirectory + "/" + modelName + modelExtension ) ) ; Properties caches = new Properties ( ) ; InputStream in = classLoader . getResourceAsStream ( modelDirectory + "/" + modelName + cacheExtension ) ; if ( in != null ) { caches . load ( in ) ; } model = Proxy . newProxyInstance ( classLoader , new class < ? > [ ] { modelClass } , new SqlInvocationHandler ( datasource , sqls , caches ) ) ; modelInstances . put ( modelName , model ) ; } return ( T ) model ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
tr	9	public Tariff getTariffForDate ( Date start , Date end ) { int price = 0 ; if ( BedTariff . size ( ) > 0 && ( start . after ( BedTariff . get ( 0 ) . getStartDate ( ) ) || start . equals ( BedTariff . get ( 0 ) . getStartDate ( ) ) ) ) { for ( Tariff tr : BedTariff ) { if ( tr . getEndDate ( ) != null && start . after ( tr . getEndDate ( ) ) ) { continue ; } if ( tr . getEndDate ( ) == null || end . before ( tr . getEndDate ( ) ) || end . equals ( tr . getEndDate ( ) ) ) { if ( start . after ( tr . getStartDate ( ) ) || start . equals ( tr . getStartDate ( ) ) ) { price += ( tr . getPrice ( ) * GenericUtility . getDiffDays ( end , start ) ) ; } else { price += ( tr . getPrice ( ) * GenericUtility . getDiffDays ( end , tr . getStartDate ( ) ) ) ; } return new Tariff ( new Integer ( price ) , start , end ) ; } else { if ( start . after ( tr . getStartDate ( ) ) ) { price += ( ( GenericUtility . getDiffDays ( tr . getEndDate ( ) , start ) + 1 ) * tr . getPrice ( ) ) ; } else { price += ( ( GenericUtility . getDiffDays ( tr . getEndDate ( ) , tr . getStartDate ( ) ) + 1 ) * tr . getPrice ( ) ) ; } } } } return null ; }
tr	8	private void drawMenu ( ) { int offsetX = menuOffsetX ; int offsetY = menuOffsetY ; int width = menuWidth ; int height = menuHeight ; int colour = 5d5447 ; DrawingArea . drawFilledRectangle ( offsetX , offsetY , width , height , colour ) ; DrawingArea . drawFilledRectangle ( offsetX + 1 , offsetY + 1 , width - 2 , 16 , 0 ) ; DrawingArea . drawUnfilledRectangle ( offsetX + 1 , width - 2 , height - 19 , 0 , offsetY + 18 ) ; fontBold . drawText ( "Choose Option" , offsetX + 3 , offsetY + 14 , colour ) ; int x = super . mouseX ; int y = super . mouseY ; if ( menuScreenArea == 0 ) { x -= 4 ; y -= 4 ; } if ( menuScreenArea == 1 ) { x -= 553 ; y -= 205 ; } if ( menuScreenArea == 2 ) { x -= 17 ; y -= 357 ; } for ( int action = 0 ; action < menuActionRow ; action ++ ) { int actionY = offsetY + 31 + ( menuActionRow - 1 - action ) * 15 ; int actionColour = ffffff ; if ( x > offsetX && x < offsetX + width && y > actionY - 13 && y < actionY + 3 ) actionColour = ffff00 ; fontBold . drawTextWithPotentialShadow ( menuActionName [ action ] , offsetX + 3 , actionY , actionColour , true ) ; } }
tr	2	public static void pipe ( InputStream is , OutputStream out , byte [ ] buf ) throws IOException { for ( ; ; ) { int amt = is . read ( buf ) ; if ( amt < 0 ) { break ; } out . write ( buf , 0 , amt ) ; } }
tr	5	public static void addEntry ( Map < String , String > data , String tag ) { JsonObjectBuilder copyInto = null ; JsonObjectBuilder returnedObject = null ; JsonObjectBuilder mainBuilder = Json . createObjectBuilder ( ) ; try { copyInto = Json . createObjectBuilder ( ) ; FileReader fr = new FileReader ( DaemonMainController . getDatabasePath ( ) ) ; JsonReader reader = Json . createReader ( fr ) ; JsonStructure jsonst = reader . read ( ) ; switch ( jsonst . getValueType ( ) ) { case OBJECT : JsonObject obj = ( JsonObject ) jsonst ; for ( String name : obj . keySet ( ) ) { returnedObject = rewriteJson ( copyInto , jsonst , null ) ; mainBuilder . add ( name , returnedObject . build ( ) ) ; } default : break ; } } catch ( FileNotFoundException e ) { } catch ( javax . json . stream . JsonParsingException e ) { e . printStackTrace ( ) ; } JsonObjectBuilder obj = Json . createObjectBuilder ( ) ; JsonObject object = mapToJsonObject ( data . keySet ( ) . iterator ( ) , obj , data ) ; mainBuilder . add ( tag , object ) ; try { FileWriter fl = new FileWriter ( DaemonMainController . getDatabasePath ( ) ) ; JsonWriter jWriter = Json . createWriter ( fl ) ; jWriter . writeObject ( mainBuilder . build ( ) ) ; fl . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } nextID ++ ; }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	4	synchronized public void update ( ) { if ( isBaked ) { if ( ! wasBaked ) bake ( ) ; for ( int n = 0 ; n < nGeometries ; n ++ ) { bones [ n ] . getMatrix ( ) . copy ( references [ n ] ) ; for ( Geometry g = getGeometry ( n ) ; g != null ; g = g . getParent ( ) ) bones [ n ] . getMatrix ( ) . postMultiply ( g . getMatrix ( ) ) ; bones [ n ] . globalMatrix . copy ( bones [ n ] . getMatrix ( ) ) ; } } else { unsetBones ( ) ; updateSurface ( ) ; } wasBaked = isBaked ; }
tr	1	public CertificatesPane ( ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; for ( int i = 0 ; i < labels . length ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; add ( new JLabel ( labels [ i ] + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; pathFields [ i ] = new JTextField ( 40 ) ; pathFields [ i ] . setFont ( MainGUI . FONT ) ; pathFields [ i ] . setInputVerifier ( pathInputVerifier ) ; pathFields [ i ] . getCaret ( ) . addChangeListener ( new CaretChangeListener ( pathFields [ i ] , pathInputVerifier ) ) ; components . add ( pathFields [ i ] ) ; add ( pathFields [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Choose file..." ) ; button . setActionCommand ( "choose" + i ) ; button . addActionListener ( this ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcert" + i ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Default" ) ; button . setActionCommand ( "restorecert" + i ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } setBorder ( BorderFactory . createTitledBorder ( "Certificates" ) ) ; }
tr	1	private void EjecutarSentenciaMySQL ( String entrada_SentenciaSQL ) { try { SentenciaSQL . execute ( entrada_SentenciaSQL ) ; } catch ( SQLException ex ) { System . out . println ( ex . getErrorCode ( ) ) ; JOptionPane . showMessageDialog ( null , "Problema al crear la Base de Datos o las Tablas" ) ; } }
tr	1	public CheckCreditForm ( int clientId ) { this . clientId = clientId ; initComponents ( ) ; locateForm ( ) ; if ( clientId != 0 ) { creditDAO . initTableModel ( creditTable , creditDAO . getCreditsByClientsId ( clientId ) ) ; } else { creditDAO . initTableModel ( creditTable , creditDAO . listAll ( ) ) ; } setPopupMenu ( creditTable ) ; }
tr	4	public static void patch ( int addr , int displacement ) { if ( addr < 0 || addr >= CT ) { System . out . println ( "patch:  address of instruction to be patched is out of range" ) ; return ; } if ( displacement < 0 || displacement > CT ) { System . out . println ( "patch:  target address of patch is out of range" ) ; return ; } Machine . code [ addr ] . d = displacement ; return ; }
tr	4	public boolean updateDb102b ( ) { String UPDATE_1 = "ALTER TABLE SATION_DATA ADD COLUMN HAM_USER VARCHAR(255)" ; String UPDATE_2 = "ALTER TABLE SATION_DATA ADD COLUMN HAM_PASS VARCHAR(255)" ; String UPDATE_3 = "UPDATE CURRENT_VERSION SET VERSION = '" + APP_VERSION_102 + "'" ; boolean withErrors = false ; try { getDbConnection ( ) . createStatement ( ) . execute ( UPDATE_1 ) ; } catch ( Exception e ) { log . error ( "Error" , e ) ; withErrors = true ; } try { getDbConnection ( ) . createStatement ( ) . execute ( UPDATE_2 ) ; } catch ( Exception e ) { log . error ( "Error" , e ) ; withErrors = true ; } try { getDbConnection ( ) . createStatement ( ) . execute ( UPDATE_3 ) ; } catch ( Exception e ) { log . error ( "Error" , e ) ; withErrors = true ; } if ( withErrors ) { log . error ( "Databse updated with errors please start with an empty database!" ) ; } return true ; }
tr	1	public static boolean isRotatedString ( String base , String rotated ) { if ( base . length ( ) != rotated . length ( ) ) { return false ; } String concatenated = rotated . concat ( rotated ) ; return concatenated . indexOf ( base ) != - 1 ; }
tr	8	public static Node parseDocument ( Lexer lexer ) { Node node , document , html ; Node doctype = null ; TagTable tt = lexer . configuration . tt ; document = lexer . newNode ( ) ; document . type = Node . RootNode ; while ( true ) { node = lexer . getToken ( Lexer . IgnoreWhitespace ) ; if ( node == null ) break ; if ( Node . insertMisc ( document , node ) ) continue ; if ( node . type == Node . DocTypeTag ) { if ( doctype == null ) { Node . insertNodeAtEnd ( document , node ) ; doctype = node ; } else Report . warning ( lexer , document , node , Report . DISCARDING_UNEXPECTED ) ; continue ; } if ( node . type == Node . EndTag ) { Report . warning ( lexer , document , node , Report . DISCARDING_UNEXPECTED ) ; continue ; } if ( node . type != Node . StartTag || node . tag != tt . tagHtml ) { lexer . ungetToken ( ) ; html = lexer . inferredTag ( "html" ) ; } else html = node ; Node . insertNodeAtEnd ( document , html ) ; getParseHTML ( ) . parse ( lexer , html , ( short ) 0 ) ; break ; } return document ; }
tr	1	public SessionFactory getSessionFactory ( ) { try { return ( SessionFactory ) new InitialContext ( ) . lookup ( "SessionFactory" ) ; } catch ( Exception e ) { log . error ( "Could not locate SessionFactory in JNDI" , e ) ; throw new IllegalStateException ( "Could not locate SessionFactory in JNDI" ) ; } }
tr	8	@ Override public void onAnalog ( String name , float isPressed , float tpf ) { float pos = isPressed / tpf ; if ( name . equals ( "Accelerate Vehicle" ) ) { if ( car != null ) { car . throttlePressed ( pos ) ; } } if ( name . equals ( "Brake Vehicle" ) ) { if ( car != null ) { car . brakePressed ( pos ) ; } } if ( name . equals ( "Steer Left" ) ) { if ( car != null ) { car . steer ( pos , tpf ) ; } } if ( name . equals ( "Steer Right" ) ) { if ( car != null ) { car . steer ( - pos , tpf ) ; } } }
tr	3	public JSONArray put ( int index , Object value ) throws JSONException { JSONObject . testValidity ( value ) ; if ( index < 0 ) { throw new JSONException ( "JSONArray[" + index + "] not found." ) ; } if ( index < length ( ) ) { this . myArrayList . set ( index , value ) ; } else { while ( index != length ( ) ) { put ( JSONObject . null ) ; } put ( value ) ; } return this ; }
tr	7	@ Override public boolean done ( ArrayList < Node > nw , int fab ) { int a = ( ( BeaconFAB ) nw . get ( 0 ) . getFAB ( fab ) ) . A ; Set < Integer > armies = new HashSet < Integer > ( ) ; int min = Integer . MAX_VALUE ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( Node N : nw ) { armies . add ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A ) ; sw = ( ( BeaconFAB ) N . getFAB ( fab ) ) . D ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A != a ) { res = false ; } } return res ; }
tr	7	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	6	private static void parseTransitionEndPoint ( Transition . EndPoint endPoint , String expr ) { String label = encryptStereotypeDelimiters ( expr ) ; Styles . Decoration decoration = Styles . Decoration . None ; if ( expr . contains ( "<>" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "<>" , "" ) ; } else if ( expr . contains ( "++" ) ) { decoration = Styles . Decoration . Composition ; label = label . replace ( "++" , "" ) ; } else if ( expr . contains ( "+" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "+" , "" ) ; } else if ( expr . contains ( "<" ) || expr . contains ( ">" ) ) { decoration = Styles . Decoration . -> ; label = label . replace ( "<" , "" ) . replace ( ">" , "" ) ; } else if ( expr . contains ( "^" ) ) { decoration = Styles . Decoration . Inheritance ; label = label . replace ( "^" , "" ) ; } label = decryptStereotypeDelimiters ( label ) ; endPoint . usingDecoration ( decoration ) . usingLabel ( label . trim ( ) ) ; }
tr	7	private Bed getBed ( CommandLine cmd ) { Bed bed = null ; if ( cmd . hasOption ( "hostel_id" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "bed_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setNumber ( new Integer ( cmd . getOptionValue ( "bed_number" ) ) ) ; } if ( cmd . hasOption ( "room_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setRoomNo ( new Integer ( cmd . getOptionValue ( "room_number" ) ) ) ; } if ( bed != null ) bed . setTariff ( null ) ; return bed ; }
tr	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	9	static boolean readMessage ( DynamicObjectInputStream ips ) { Message receive = null ; String date = null ; String name = "Client" ; String message = null ; Field [ ] fields ; Method [ ] methods ; class < ? > someClass ; try { Object fromServ = ips . readObject ( ) ; if ( fromServ instanceof Message ) receive = ( Message ) fromServ ; } catch ( IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; } date = new String ( sdf . format ( receive . getCreationTime ( ) , new StringBuffer ( ) , new FieldPosition ( 0 ) ) ) ; if ( receive instanceof NewMessageType ) { ips . addClass ( ( ( NewMessageType ) receive ) . getName ( ) , ( ( NewMessageType ) receive ) . getClassData ( ) ) ; message = new String ( "New class " + ( ( NewMessageType ) receive ) . getName ( ) + " loaded." ) ; System . out . println ( date + " [" + name + "] " + message ) ; } else { if ( receive instanceof RelayMessage ) { message = ( ( RelayMessage ) receive ) . getMessage ( ) ; name = ( ( RelayMessage ) receive ) . getFrom ( ) ; System . out . println ( date + " [" + name + "] " + message ) ; } else { if ( receive instanceof StatusMessage ) { message = ( ( StatusMessage ) receive ) . getMessage ( ) ; name = "Server" ; System . out . println ( date + " [" + name + "] " + message ) ; } else { someClass = receive . getClass ( ) ; fields = someClass . getDeclaredFields ( ) ; methods = someClass . getDeclaredMethods ( ) ; message = new String ( someClass . getSimpleName ( ) + ":" ) ; try { for ( int i = 0 ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; f . setAccessible ( true ) ; message = message . concat ( new String ( " " + f . getName ( ) + "(" + f . get ( receive ) . toString ( ) + ")" ) ) ; if ( i != fields . length - 1 ) { message = message . concat ( " " ) ; } } System . out . println ( date + " [" + name + "] " + message ) ; for ( Method m : methods ) { if ( m . getParameterTypes ( ) . length == 0 && m . isAnnotationPresent ( Execute . class ) ) { m . invoke ( receive ) ; } } } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } } date = message = null ; name = "Client" ; return true ; }
tr	7	@ Override public void processCommand ( String ... args ) throws SystemCommandException { String matriculation = args [ 0 ] ; String result = "" ; Student student = facade . selectStudent ( matriculation ) ; if ( student != null ) { result += "Matriculation:\t" + student . getMatriculation ( ) + "\n" + "Name:\t" + student . getSurname ( ) + "  " + student . getForename ( ) + "\n" + "Programme:\t" + student . getProgramme ( ) + "\n" ; Internship internship = student . getInternship ( ) ; if ( internship != null ) { result += "Status:\t" + internship . getStatus ( ) + "\n" + "Manager:\t" + internship . getManager ( ) + "\n" + "Email:\t" + internship . getManagerEmail ( ) + "\n" ; } Role role = internship . getRole ( ) ; if ( role != null ) result += "Role\t:" + role . getTitle ( ) + "\n" + "Begin:\t" + formatDate ( role . getStart ( ) ) + "\n" + "End:\t" + formatDate ( role . getEnd ( ) ) + "\n" + "Salary:\t" + role . getSalary ( ) + "\n" + "Location\t:" + role . getLocation ( ) + "\n" ; Employer employer = internship . getEmployer ( ) ; if ( employer != null ) result += "Employer:\t" + employer . getName ( ) ; Visit visit = internship . getVisit ( ) ; if ( visit != null ) { Visitor visitor = visit . getVisitor ( ) ; if ( visitor != null ) result += "Visitor:\t" + visitor . getName ( ) + "\n" ; UoGGrade grade = visit . getGrade ( ) ; if ( grade != null ) { result += "Grade:\t" + grade + "\n" ; result += "Description:\t" + visit . getDescription ( ) + "\n" ; } } } dialogue . sendMessage ( result ) ; }
tr	5	public static < C > String getStateDecoration ( State < C > state , boolean requireAdditionDecoration , String additionalDecoration ) { StringBuilder b = new StringBuilder ( ) ; b . append ( "shape=\"record\"  label=\"{" ) . append ( state . getName ( ) ) . append ( ( requireAdditionDecoration ) ? String . format ( "|%s|{" , additionalDecoration ) : "|{" ) ; String sep = "" ; for ( Action < C > a : state . getActions ( ) ) { b . append ( sep ) . append ( a . getType ( ) ) ; sep = "|" ; } b . append ( "}}\"" ) ; int mod = state . getModifier ( ) ; b . append ( "  style=\"filled" ) ; if ( ( mod & ITimedAutomata . INITIAL ) > 0 ) b . append ( " diagonals" ) ; if ( ( mod & ITimedAutomata . URGENT ) > 0 ) b . append ( " bold" ) ; b . append ( "\"" ) ; if ( ( mod & ITimedAutomata . TERMINATE ) > 0 ) b . append ( "  color=\"red\"" ) ; b . append ( "  fillcolor=\"white\"" ) ; return b . toString ( ) ; }
tr	9	public static int maxProfit4 ( int [ ] prices ) { if ( prices . length < 2 ) { return 0 ; } int [ ] left = new int [ prices . length ] ; int [ ] right = new int [ prices . length ] ; int min = prices [ 0 ] ; int max = prices [ prices . length - 1 ] ; left [ 0 ] = 0 ; right [ prices . length - 1 ] = 0 ; for ( int i = 1 ; i < prices . length ; i ++ ) { if ( prices [ i ] < min ) min = prices [ i ] ; left [ i ] = prices [ i ] - min > left [ i - 1 ] ? prices [ i ] - min : left [ i - 1 ] ; } for ( int i = prices . length - 2 ; i >= 0 ; i -- ) { if ( prices [ i ] > max ) max = prices [ i ] ; right [ i ] = max - prices [ i ] > right [ i + 1 ] ? max - prices [ i ] : right [ i + 1 ] ; } int total = 0 ; for ( int i = 0 ; i < prices . length ; i ++ ) { total = left [ i ] + right [ i ] > total ? left [ i ] + right [ i ] : total ; } return total ; }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	3	< C > NodeFactory < C > getSimpleNodeBuilder ( final String namespace , class < C > dummy ) { final NodeFactory < C > factory = new ReflectNodeFactory < > ( new AutoQualifiedClassLoader ( namespace , _classLoader ) ) ; return new SimpleNodeFactory < C > ( ) { public Predicate < C > newPredicate ( String type , String attr ) { if ( factory . newPredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newPredicate ( type , attr ) ; } @ Override public Action < C > newAction ( String type , String attr ) { if ( factory . newAction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newAction ( type , attr ) ; } private void ok ( String name ) { if ( VERBOSE ) System . out . printf ( "Class '%s' loaded\n" , name ) ; } private void error ( String name ) { System . err . printf ( "Class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
tr	0	public boolean stop ( ) { return stop_native ( pointer ) ; }
tr	7	public synchronized void update ( ) { Tile . WATER . update ( ) ; for ( int i = 0 ; i < mobs . size ( ) ; i ++ ) { if ( ! mobs . get ( i ) . isRemoved ( ) && mobs . get ( i ) != null ) { mobs . get ( i ) . update ( ) ; } else { mobs . remove ( i ) ; } } for ( int i = 0 ; i < particles . size ( ) ; i ++ ) { if ( ! particles . get ( i ) . isRemoved ( ) ) { particles . get ( i ) . update ( ) ; } else { particles . remove ( i ) ; } } for ( int i = 0 ; i < projectiles . size ( ) ; i ++ ) { if ( ! projectiles . get ( i ) . isRemoved ( ) ) { projectiles . get ( i ) . update ( ) ; } else { projectiles . remove ( i ) ; } } }
tr	2	public static Strategy getStrategy ( String strategyName ) { if ( "average" . equals ( strategyName ) ) { return new AverageStrategy ( ) ; } else if ( "vacancyRate" . equals ( strategyName ) ) { return new VacancyRateStrategy ( ) ; } else { return new DefaultStrategy ( ) ; } }
tr	4	private List < Word > getCandidates ( Word word , Map < Character , Character > l2lEncrypt ) { List < Word > candidates = new LinkedList < Word > ( ) ; Map < Integer , List < Word >> wordsMap = dict . get ( word . getLength ( ) ) ; if ( wordsMap == null ) { return candidates ; } List < Word > words = wordsMap . get ( word . getNbrSimilarLetters ( ) ) ; if ( words == null ) { return candidates ; } for ( Word w : words ) { if ( w . equals ( word , l2lEncrypt ) ) { candidates . add ( w ) ; } } return candidates ; }
tr	9	private boolean checkBackDiagonal ( int j , int i , ConnectFourPiece [ ] [ ] m_Pieces ) { boolean gameWon = false ; int secondPieceDDiagonalColoumn = i - 1 ; int thirdPieceDDiagonalColoumn = i - 2 ; int fourthPieceDDiagonalColoumn = i - 3 ; int secondPieceDDiagonalRow = j + 1 ; int thirdPieceDDiagonalRow = j + 2 ; int fourthPieceDDiagonalRow = j + 3 ; if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == RED_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; } else if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == YELLOW_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; } gameWon = true ; } } } return gameWon ; }
tr	3	private static void initializeIs ( byte [ ] [ ] constraint_matrix , int S , int B ) { for ( int row = 0 ; row < S ; row ++ ) { for ( int col = 0 ; col < S ; col ++ ) { if ( col != row ) continue ; else constraint_matrix [ row ] [ col + B ] = 1 ; } } }
tr	8	public boolean baca ( String no_beli ) { boolean adaKesalahan = false ; Connection cn = null ; this . no_beli = no_beli ; listKwitansi = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select * from kwitansi where no_beli='" + no_beli + "'" ; sta = cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; listKwitansi = new Object [ rset . getRow ( ) ] [ 4 ] ; rset . first ( ) ; int i = 0 ; do { if ( ! rset . getString ( "kode_buku" ) . equals ( "" ) ) { listKwitansi [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getInt ( "jumlah" ) , rset . getInt ( "harga" ) } ; } i ++ ; } while ( rset . next ( ) ) ; sta . close ( ) ; rset . close ( ) ; if ( listKwitansi . length > 0 ) { adaKesalahan = false ; } } catch ( Exception ex ) { adaKesalahan = true ; } } } return ! adaKesalahan ; }
tr	4	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
tr	7	public double calculate ( Accession a1 , Accession a2 ) { double value = getMemoizedValue ( a1 . getId ( ) , a2 . getId ( ) ) ; if ( value != MISSING_VAL ) { return value ; } ListIterator < List < double >> m1Itr = a1 . getSSRValues ( ) . listIterator ( ) ; ListIterator < List < double >> m2Itr = a2 . getSSRValues ( ) . listIterator ( ) ; double markerCnt = 0 ; double sumMarkerSqDiff = 0 ; while ( m1Itr . hasNext ( ) && m2Itr . hasNext ( ) ) { ListIterator < double > a1Itr = m1Itr . next ( ) . listIterator ( ) ; ListIterator < double > a2Itr = m2Itr . next ( ) . listIterator ( ) ; double markerSqDiff = 0 ; while ( a1Itr . hasNext ( ) && a2Itr . hasNext ( ) ) { double Pxla = a1Itr . next ( ) ; double Pyla = a2Itr . next ( ) ; if ( Pxla != null && Pyla != null ) { double sqrtDiff = Math . sqrt ( Pxla ) - Math . sqrt ( Pyla ) ; markerSqDiff += ( sqrtDiff ) * ( sqrtDiff ) ; } } sumMarkerSqDiff += markerSqDiff ; markerCnt ++ ; } value = 1.0 / ( Math . sqrt ( 2.0 * markerCnt ) ) * Math . sqrt ( sumMarkerSqDiff ) ; setMemoizedValue ( a1 . getId ( ) , a2 . getId ( ) , value ) ; return value ; }
tr	2	@ Override public String evaluatePolicy ( float max_risk , TransferredFile policyFileToTransfer , TransferredFile dbSQLDumpFileToTransfer , String table_name ) { Random generator = new Random ( System . currentTimeMillis ( ) ) ; long gid = generator . nextLong ( ) ; if ( gid < 0 ) gid = gid * ( - 1 ) ; TempFiles tf = new TempFiles ( ) ; File dbDumpTempFile = null ; File policyTempFile = null ; try { dbDumpTempFile = tf . createTempFile ( dbSQLDumpFileToTransfer ) ; policyTempFile = tf . createTempFile ( policyFileToTransfer ) ; dbDumpTempFile . deleteOnExit ( ) ; policyTempFile . deleteOnExit ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } dba_factory . evaluatePolicy ( policyTempFile , dbDumpTempFile , null , gid , table_name , false ) ; return "ID: --" + gid + "--" ; }
tr	9	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	5	public void createIndex ( ) { Segmenter seg = new Segmenter ( ) ; WordsFilter filter = new WordsFilter ( ) ; List < CoreLabel > words ; ResultSet resultSet = null ; String query = "select distinct indexid from dblpcitation union select distinct citationid from dblpcitation;" ; ResultSet rs = sqLconnection . Query ( query ) ; try { String insert = "insert into TermInfos(term indexid pos) values(? ? ?)" ; int count = 0 ; PreparedStatement statement = sqLconnection . conn . prepareStatement ( insert ) ; while ( rs . next ( ) ) { int index = rs . getInt ( "indexid" ) ; query = "select title abstract from dblpbase where indexid=" + index ; resultSet = sqLconnection . Query ( query ) ; resultSet . next ( ) ; String content = resultSet . getString ( "title" ) ; content += " " + resultSet . getString ( "abstract" ) ; words = seg . TokenAPI ( content ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { String word = words . get ( i ) . toString ( ) . toLowerCase ( ) ; if ( ! filter . result ( word ) . equals ( "" ) ) { statement . setString ( 1 , word ) ; statement . setInt ( 2 , index ) ; statement . setInt ( 3 , i ) ; statement . addBatch ( ) ; } } if ( count % 10000 == 0 ) { System . out . println ( "current number: " + count ) ; statement . executeBatch ( ) ; statement . clearBatch ( ) ; resultSet = null ; words . clear ( ) ; query = null ; } count ++ ; } statement . executeBatch ( ) ; sqLconnection . disconnectMySQL ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	1	private int numberOfDigits ( int n ) { Preconditions . checkArgument ( n > 0 ) ; int count = 0 ; while ( n > 0 ) { n /= 10 ; count ++ ; } return count ; }
tr	0	public void setDateTimeValue ( Date dateTimeValue ) { this . dateTimeValue = dateTimeValue ; }
tr	1	private static void log ( String message ) { if ( DEBUG ) { log . debug ( message ) ; } }
tr	6	public static void loadDatabase ( ) { try { Path dbPath = Paths . get ( DaemonMainController . getDatabasePath ( ) ) ; System . out . println ( "[INFO]  Loading database from file at " + dbPath . toString ( ) ) ; File d = new File ( DaemonMainController . getDatabasePath ( ) ) ; if ( ! d . exists ( ) || ! d . isFile ( ) ) throw new FileNotFoundException ( ) ; byte [ ] rawDb = Files . readAllBytes ( dbPath ) ; String db = new String ( rawDb , Charset . defaultCharset ( ) ) ; Map < String , Object > tracks = dooooom . jmpd . data . JsonParser . stringToMap ( db ) ; ArrayList < Map < String , String >> data = ( ArrayList < Map < String , String >> ) tracks . get ( "data" ) ; ArrayList < Track > savedLibrary = new ArrayList < Track > ( ) ; for ( Map < String , String > m : data ) { savedLibrary . add ( new Track ( m ) ) ; } library = savedLibrary ; } catch ( FileNotFoundException e ) { System . out . println ( "[INFO]  No database file found. Attempting to create a new one." ) ; updateDatabase ( ) ; } catch ( IOException e ) { } catch ( JsonParsingException e ) { System . out . println ( "[ERROR]  Database file did not parse correctly. Possibly corrupt." ) ; updateDatabase ( ) ; } }
tr	3	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; g . drawImage ( backgroundImage , 0 , 0 , null ) ; g . drawImage ( st . getFlag ( ) . getTexture ( ) , ( int ) GameObject . boxToSwingX ( ( st . getFlag ( ) . getPos ( ) ) . x ) , ( int ) GameObject . boxToSwingY ( ( st . getFlag ( ) . getPos ( ) ) . y ) , null ) ; if ( st . haveLauncher ( ) != null ) g . drawImage ( st . haveLauncher ( ) . getTexture ( ) , ( int ) GameObject . boxToSwingX ( ( st . haveLauncher ( ) . getPos ( ) ) . x ) , ( int ) GameObject . boxToSwingY ( ( st . haveLauncher ( ) . getPos ( ) ) . y ) , null ) ; Graphics2D g2 = ( ( Graphics2D ) g ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; for ( GameObject obj : st . getWorldController ( ) . getObjects ( ) ) { g2 . setPaint ( obj . getColour ( ) ) ; g2 . fill ( obj . gShape ( ) ) ; } if ( shp != null ) { g2 . setPaint ( Color . RED ) ; g2 . fill ( shp ) ; } }
tr	4	public boolean playersInScourge ( int [ ] pl ) { boolean found = false ; for ( int p : pl ) { found = false ; for ( int s : scourge ) { if ( s == p ) { found = true ; } } if ( ! found ) { return false ; } } return true ; }
tr	4	@ Override public String print ( ) { StringBuilder printed = new StringBuilder ( ) ; Line selectedLine = this . getSelectedLine ( ) ; TextIntro intro = this . document . getTextIntro ( ) ; for ( int i = 0 ; i < intro . getLineNb ( ) ; i ++ ) { if ( intro . getLine ( i ) . equals ( selectedLine ) ) { printed . append ( new StringBuilder ( intro . getLine ( i ) . toString ( ) ) . insert ( this . getSelectedCharacterNb ( ) , "[" ) . insert ( this . getSelectedLine ( ) . length ( ) == this . getSelectedCharacterNb ( ) ? this . getSelectedCharacterNb ( ) + 1 : this . getSelectedCharacterNb ( ) + 2 , "]" ) + "\n" ) ; } else { printed . append ( intro . getLine ( i ) . toString ( ) + "\n" ) ; } } for ( int i = 0 ; i < this . document . getSubSectionNb ( ) ; i ++ ) { printed . append ( this . printSection ( this . document . getSubSection ( i ) , 1 ) ) ; } return printed . toString ( ) ; }
tr	4	public void cliqueFinTour ( ) { if ( joueurEnCours . getPeuple ( ) . getTerritoiresOccupes ( ) . isEmpty ( ) ) { new WinWarn ( "Veuillez tout d'abord prendre au moins un territoire" ) ; } else if ( ( etape == 0 || etape == 1 ) && Game . getInstance ( ) . askConf ( "Confirmer la fin du tour ?" ) ) { redeploiement ( ) ; } }
tr	3	@ Override public void actionPerformed ( ActionEvent e ) { Centralizator cen = Centralizator . getInstance ( ) ; Object o = e . getSource ( ) ; if ( ( ( JButton ) o ) . equals ( ad_rem ) ) { dispose ( ) ; new SecretarAdElevClasa ( secretar ) ; } else if ( ( ( JButton ) o ) . equals ( mod ) ) { dispose ( ) ; new SecretarModOClasa ( secretar ) ; } else if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen2 = Centralizator . getInstance ( ) ; cen2 . saveCentralizator ( ) ; new SecretarModClase ( secretar ) ; } }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	7	public final boolean nextBoolean ( final float probability ) { int y ; if ( probability < 0.0f || probability > 1.0f ) throw new IllegalArgumentException ( "probability must be between 0.0 and 1.0 inclusive." ) ; if ( probability == 0.0f ) return false ; else if ( probability == 1.0f ) return true ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; return ( y >>> 8 ) / ( ( float ) ( 1 << 24 ) ) < probability ; }
tr	0	public Decoder getFastInfosetDecoder ( ) { return ( Decoder ) getXMLReader ( ) ; }
tr	0	private void prepararNOAplicarCategoriaANDProductoANDMarcaANDDiaOferta ( ) { List < DiaSemana > diaSemana = new ArrayList < DiaSemana > ( ) ; diaSemana . add ( DiaSemana . HOY ) ; ofertas . add ( new OfertaCategoria ( new CategoriaProducto ( CATEGORIA3 ) , 0.0 ) ) ; ofertas . add ( new OfertaDia ( 0.0 , diaSemana ) ) ; ofertas . add ( new OfertaMarca ( new MarcaProducto ( MARCA3 ) , 0.0 ) ) ; ofertas . add ( new OfertaProducto ( regProd3 , 0.0 ) ) ; porcentajeDescuento = 50.0 ; oferta = new OfertaCompuestaAND ( ofertas , porcentajeDescuento ) ; productos . add ( new Producto ( regProd3 ) ) ; }
tr	1	public SWIGTYPE_p_std__mapT_std__string_std__string_t getThe_map ( ) { long cPtr = otapiJNI . StringMap_the_map_get ( swigCPtr , this ) ; return ( cPtr == 0 ) ? null : new SWIGTYPE_p_std__mapT_std__string_std__string_t ( cPtr , false ) ; }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	2	@ SuppressWarnings ( "unchecked" ) public List < CourseSection > readAll ( CourseSection instance ) { log . debug ( "readAll " + entitySimpleName ) ; List < CourseSection > result = null ; try { result = ( List < CourseSection > ) super . readAll ( entityFullName , instance ) ; log . debug ( entitySimpleName + " readAll successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " readAll successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " readAll failed" , re ) ; throw re ; } return result ; }
tr	3	public void add ( Category category ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . save ( category ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	9	public boolean isMatch ( String s , String p ) { if ( p . length ( ) == 0 ) { return s . length ( ) == 0 ; } if ( p . length ( ) == 1 ) { return ( s . length ( ) == 1 ) && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ; } if ( p . charAt ( 1 ) != * ) { if ( s . length ( ) < 1 ) { return false ; } else { return ( s . charAt ( 0 ) == p . charAt ( 0 ) || p . charAt ( 0 ) == . ) && isMatch ( s . substring ( 1 ) , p . substring ( 1 ) ) ; } } while ( s . length ( ) > 0 && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ) { if ( isMatch ( s , p . substring ( 2 ) ) ) { return true ; } s = s . substring ( 1 ) ; } return isMatch ( s , p . substring ( 2 ) ) ; }
tr	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	3	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	5	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	2	public void appendAll ( String msg ) { if ( singleNode ) { pNode . write ( msg , true ) ; } else { for ( File f : pNodes ) { f . write ( msg , true ) ; } } }
tr	0	public Table ( ) { }
tr	3	private int [ ] getRecipeData ( ) { int [ ] r = new int [ 4 ] ; int counter = 0 ; for ( int y = 0 ; y < craftingArea . length ; y ++ ) { for ( int x = 0 ; x < craftingArea [ 0 ] . length ; x ++ ) { if ( craftingArea [ x ] [ y ] . getContent ( ) != null ) { r [ counter ] = craftingArea [ x ] [ y ] . getContent ( ) . getType ( ) . getId ( ) ; } else { r [ counter ] = - 1 ; } counter ++ ; } } return r ; }
tr	1	private void endBlock ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new TextString ( s ) ) ; } container = null ; }
tr	5	@ Test public void testlimitNunberOfItems ( ) throws IOException { storageManager = new StorageManager ( testDir , 1024 * 1024 , 2 , storageMode , size ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 0 == storageManager . getUsed ( ) ) ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; int limit = 1000 ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = storageManager . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; } assertTrue ( 1000 * testBytes . length == storageManager . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = storageManager . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( 1000 * testBytes . length == storageManager . getUsed ( ) ) ; String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = storageManager . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == storageManager . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( 1000 * smallTestBytes . length == storageManager . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = storageManager . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == storageManager . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( 1000 * testBytes . length == storageManager . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = storageManager . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == storageManager . getUsed ( ) ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; storageManager . free ( ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; }
tr	6	public List < Jogada > geraJogadasPossiveis ( TipoCorJogador corJogador ) throws CasaOcupadaException , JogadaInvalidaException { List < Jogada > possiveisJogadas = new ArrayList < Jogada > ( ) ; List < Jogada > jogadasPeca = new ArrayList < Jogada > ( ) ; for ( int coluna = COLUNAINFERIOR ; coluna <= COLUNASUPERIOR ; coluna ++ ) for ( int linha = LINHAINFERIOR ; linha <= LINHASUPERIOR ; linha ++ ) if ( this . estaAliado ( corJogador , new Posicao ( coluna , linha ) ) ) { Peca peca = this . espiarPeca ( new Posicao ( coluna , linha ) ) ; jogadasPeca = peca . jogadasPeca ( new Posicao ( coluna , linha ) , this ) ; for ( Jogada jogada : jogadasPeca ) possiveisJogadas . add ( jogada ) ; } if ( this . ehRoqueMenor ( corJogador ) == true ) possiveisJogadas . add ( new Jogada ( TipoJogada . ROQUE_MENOR ) ) ; if ( this . ehRoqueMaior ( corJogador ) == true ) possiveisJogadas . add ( new Jogada ( TipoJogada . ROQUE_MAIOR ) ) ; return possiveisJogadas ; }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	7	public long binarySearch ( long startIndex , long endIndex , byte [ ] struct ) { if ( startIndex < 0 || startIndex > endIndex || endIndex > col . size ( ) ) { throw new IllegalArgumentException ( "Illegal input  collection size: [" + col . size ( ) + "]  " + "startIndex: [" + startIndex + "]  endIndex: [" + endIndex + "]" ) ; } if ( null == struct ) throw new IllegalArgumentException ( "Provided struct is null" ) ; int compres ; long lo = startIndex ; long hi = endIndex - 1 ; while ( lo <= hi ) { long mid = ( lo + hi ) >>> 1 ; compres = comp . compare ( mid , struct ) ; if ( compres < 0 ) { lo = mid + 1 ; } else if ( compres > 0 ) { hi = mid - 1 ; } else { return mid ; } } return ~ lo ; }
tr	2	private static void store ( String name , Automaton a ) { String dir = System . getProperty ( "dk.brics.automaton.datatypes" ) ; if ( dir == null ) dir = "build" ; try { a . store ( ( new FileOutputStream ( dir + "/" + name + ".aut" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	public BudgetUser getUser ( String nameUser ) throws Exception { EntityManager em = getEntityManager ( ) ; BudgetUser actBU = new BudgetUser ( ) ; String consulta = String . format ( "Select * from NVELASQUEZ.BUDGETUSER tbUser where tbUser.USERNAME = '" + nameUser + "'" ) ; try { Query q = em . createNativeQuery ( consulta , BudgetUser . class ) ; actBU = ( BudgetUser ) q . getSingleResult ( ) ; UserJpaController d = new UserJpaController ( emf ) ; } catch ( Exception e ) { throw new Exception ( Constant . NON_EXISTS_ERROR_MSG ) ; } finally { em . close ( ) ; } return actBU ; }
tr	9	public void action ( ) { MessageTemplate partsMT = MessageTemplate . and ( MessageTemplate . MatchPerformative ( ACLMessage . REQUEST ) , MessageTemplate . MatchOntology ( "Check Part List" ) ) ; ACLMessage partsMsg = myAgent . receive ( partsMT ) ; if ( partsMsg != null ) { try { @ SuppressWarnings ( "unchecked" ) HashMap < String , Integer > available = ( HashMap < String , Integer > ) partsMsg . getContentObject ( ) ; Iterator < Entry < String , Integer >> i = missingParts . entrySet ( ) . iterator ( ) ; ArrayList < String > partsToRemove = new ArrayList < String > ( ) ; while ( i . hasNext ( ) ) { Entry < String , Integer > me = ( Entry < String , Integer > ) i . next ( ) ; String part = me . getKey ( ) ; if ( available . containsKey ( part ) ) { if ( me . getValue ( ) > available . get ( part ) ) { int x = me . getValue ( ) - available . get ( part ) ; missingParts . put ( part , x ) ; } else if ( me . getValue ( ) <= available . get ( part ) ) { partsToRemove . add ( part ) ; missingParts . put ( part , 0 ) ; } } } for ( int k = 0 ; k < partsToRemove . size ( ) ; k ++ ) { if ( missingParts . containsKey ( partsToRemove . get ( k ) ) ) { missingParts . remove ( partsToRemove . get ( k ) ) ; } } if ( missingParts . isEmpty ( ) ) { System . out . println ( myAgent . getLocalName ( ) + " [parts status]: fulfill  no additional shelf needed.\n" ) ; ACLMessage compMsg = new ACLMessage ( ACLMessage . CONFIRM ) ; compMsg . setOntology ( "Final shelf" ) ; compMsg . addReceiver ( new AID ( assignedPicker , AID . ISLOCALNAME ) ) ; send ( compMsg ) ; } else { System . out . println ( myAgent . getLocalName ( ) + " [parts status]: " + missingParts . size ( ) + " parts missing; need a new shelf.\n" ) ; ACLMessage order = new ACLMessage ( ACLMessage . REQUEST ) ; order . setOntology ( "requestParts" ) ; try { order . setContentObject ( missingParts ) ; } catch ( IOException e ) { } order . addReceiver ( new AID ( assignedPicker , AID . ISLOCALNAME ) ) ; send ( order ) ; } } catch ( UnreadableException e ) { e . printStackTrace ( ) ; } } else { block ( ) ; } }
tr	7	@ Override public ServerPacket getResponse ( ) { if ( data . length != 4 ) return new BadPacket ( ) ; byte flavor1 = data [ 1 ] ; byte flavor2 = data [ 2 ] ; byte rating = data [ 3 ] ; try { if ( flavor1 == flavor2 ) return new ErrorMessagePacket ( "Flavors are the same." ) ; if ( rating < 0 || rating > 5 ) return new ErrorMessagePacket ( "Rating must be from 0 to 5." ) ; Map < Integer , String > flavors = CookOutAppServer . getDatabase ( ) . getFlavors ( ) ; if ( flavors . get ( Integer . valueOf ( flavor1 ) ) == null || flavors . get ( Integer . valueOf ( flavor2 ) ) == null ) return new ErrorMessagePacket ( "Flavors don't exist." ) ; CookOutAppServer . getDatabase ( ) . rateCombo ( new ComboRating ( flavor1 , flavor2 , 1 , rating ) ) ; } catch ( SQLException e ) { return new ErrorMessagePacket ( "Server SQL error" ) ; } return new OKPacket ( ) ; }
tr	8	@ Override public LayoutManager convertLayoutElement ( Element elm ) { double [ ] [ ] args = new double [ 2 ] [ 0 ] ; if ( elm . hasAttribute ( "cols" ) ) { String cols = elm . getAttribute ( "cols" ) . toLowerCase ( ) . trim ( ) ; cols = cols . replaceAll ( "(tablelayout\\.)?fill" , String . valueOf ( TableLayout . FILL ) ) ; cols = cols . replaceAll ( "(tablelayout\\.)?preferred" , String . valueOf ( TableLayout . PREFERRED ) ) ; if ( cols . matches ( "\\{.*\\}" ) ) { cols = cols . substring ( 1 , cols . length ( ) - 1 ) ; } String [ ] x ; if ( cols . matches ( numberRegex + "(\\s* \\s*" + numberRegex + ")*" ) ) { x = cols . split ( "\\s* \\s*" ) ; } else { x = cols . split ( "\\s+" ) ; } args [ 0 ] = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { args [ 0 ] [ i ] = double . valueOf ( x [ i ] ) ; } } if ( elm . hasAttribute ( "rows" ) ) { String rows = elm . getAttribute ( "rows" ) . toLowerCase ( ) . trim ( ) ; rows = rows . replaceAll ( "(tablelayout\\.)?fill" , String . valueOf ( TableLayout . FILL ) ) ; rows = rows . replaceAll ( "(tablelayout\\.)?preferred" , String . valueOf ( TableLayout . PREFERRED ) ) ; if ( rows . matches ( "\\{.*\\}" ) ) { rows = rows . substring ( 1 , rows . length ( ) - 1 ) ; } String [ ] y ; if ( rows . matches ( numberRegex + "(\\s* \\s*" + numberRegex + ")*" ) ) { y = rows . split ( "\\s* \\s*" ) ; } else { y = rows . split ( "\\s+" ) ; } args [ 1 ] = new double [ y . length ] ; for ( int i = 0 ; i < y . length ; i ++ ) { args [ 1 ] [ i ] = double . valueOf ( y [ i ] ) ; } } return new TableLayout ( args ) ; }
tr	9	public void checkCollisionsWithEnemies ( ArrayList < Enemy > list , Level1State state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getKilledByTop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getPlayerState ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
tr	7	private JSONWriter append ( String s ) throws JSONException { if ( s == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( s ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
