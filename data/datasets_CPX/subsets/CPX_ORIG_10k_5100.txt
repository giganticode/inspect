tr	4	public void move ( int dx , int dy ) { dy = dy * - 1 ; if ( ScreenX + dx > 0 && ScreenX + Width + dx < 800 ) { ScreenX += dx ; } if ( ScreenY + dy > 0 && ScreenY + dy + getTotalHeight ( ) < Standards . W_HEIGHT ) { ScreenY += dy ; } }
tr	6	public static int removeString ( String a , int index1 , String b , int index2 ) { if ( a == null || b == null ) { return - 1 ; } if ( a . length ( ) <= b . length ( ) ) { return - 1 ; } if ( index2 == b . length ( ) ) return 1 ; int totalCount = 0 ; char tmp = b . charAt ( index2 ) ; for ( int i = index1 ; i < a . length ( ) ; i ++ ) { if ( tmp == a . charAt ( i ) ) totalCount = totalCount + removeString ( a , i , b , index2 + 1 ) ; } return totalCount ; }
tr	6	private void modificarActionPerformed ( java . awt . event . ActionEvent evt ) { String carnet = f_carne . getText ( ) . toString ( ) ; String fecha = f_fecha . getText ( ) . toString ( ) ; Hora inicio = new Hora ( f_inicio . getText ( ) . toString ( ) . trim ( ) ) ; boolean validos = false ; while ( ! validos ) { if ( Hora . validarFormato ( inicio . getCadena ( ) ) ) { inicio = new Hora ( f_inicio . getText ( ) . toString ( ) ) ; } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese una hora en formato militar" ) ; notificacion . setVisible ( true ) ; } if ( ! Hora . validarFormatoFecha ( fecha ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ingrese la fecha en el formato indicado" ) ; notificacion . setVisible ( true ) ; } if ( B_A_estudiante . validaCarnet ( carnet ) ) { if ( null == B_A_estudiante . consultarEstudiante ( carnet ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ese estudiante no existe" ) ; notificacion . setVisible ( true ) ; } } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese un carnet valido" ) ; notificacion . setVisible ( true ) ; } B_A_horas labor = B_A_horas . consultarLabor ( carnet . trim ( ) , fecha . trim ( ) , inicio ) ; if ( null != labor ) { validos = true ; Modificar_observaciones ventana = new Modificar_observaciones ( labor ) ; ventana . setVisible ( true ) ; this . setVisible ( false ) ; break ; } else { Notificacion notificacion = new Notificacion ( this , true , "Esa labor no existe" ) ; notificacion . setVisible ( true ) ; break ; } } }
tr	4	void ApplyKongAlgo ( boolean stepbystep , int pausetime ) { for ( int i = 0 ; i < polypoints . size ( ) - 1 ; i ++ ) for ( int j = 0 ; j < polypoints . size ( ) - 1 ; j ++ ) { if ( i == j ) continue ; if ( isIntersect ( polypoints . get ( i ) , polypoints . get ( i + 1 ) , polypoints . get ( j ) , polypoints . get ( j + 1 ) ) ) { JOptionPane . showMessageDialog ( null , "Polygon is not simple!" ) ; return ; } } KongAlgo ka = new KongAlgo ( polypoints , this ) ; ka . runKong ( stepbystep , pausetime ) ; triangles = ka . getTriangles ( ) ; Graphics g = this . getGraphics ( ) ; g . setColor ( Color . BLACK ) ; this . drawPolygon ( polypoints ) ; System . out . println ( "DONE" ) ; repaint ( ) ; }
tr	8	public static int uniquePaths2 ( int m , int n ) { int [ ] [ ] pathMatrix = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 && j == 0 ) { pathMatrix [ 0 ] [ 0 ] = 1 ; } else if ( i == 0 && j != 0 ) { pathMatrix [ i ] [ j ] = pathMatrix [ i ] [ j - 1 ] ; } else if ( j == 0 && i != 0 ) { pathMatrix [ i ] [ j ] = pathMatrix [ i - 1 ] [ j ] ; } else { pathMatrix [ i ] [ j ] = pathMatrix [ i - 1 ] [ j ] + pathMatrix [ i ] [ j - 1 ] ; } } } return pathMatrix [ m - 1 ] [ n - 1 ] ; }
tr	4	public double evaluteTheStrategy ( ) { double sellSum = 0 ; double buySum = 0 ; int count = 0 ; int NumberOfSell = this . getNumberOfSell ( ) ; for ( GeneratedSignal gs : genSigList ) { if ( gs . getType ( ) . equals ( "sell" ) ) { sellSum += gs . getPrice ( ) ; } else if ( gs . getType ( ) . equals ( "buy" ) && count < NumberOfSell ) { buySum += gs . getPrice ( ) ; count ++ ; } } return ( sellSum - buySum ) ; }
tr	3	public void updateUser ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	3	@ SuppressWarnings ( "unchecked" ) public static Map < String , Object > parseMap ( String json ) { ObjectMapper mapper = new ObjectMapper ( ) ; JsonFactory factory = mapper . getFactory ( ) ; JsonParser jp = null ; Map < String , Object > result = null ; try { jp = factory . createParser ( json ) ; result = jp . readValueAs ( HashMap . class ) ; } catch ( JsonParseException e ) { _logger . error ( "JsonParseException: " + e . getMessage ( ) ) ; } catch ( JsonProcessingException e ) { _logger . error ( "JsonProcessingException: " + e . getMessage ( ) ) ; } catch ( IOException e ) { _logger . error ( "IOException: " + e . getMessage ( ) ) ; } return result ; }
tr	6	public void keyTyped ( KeyEvent e ) { if ( curIndex < 0 ) curIndex = 0 ; if ( curIndex > currentText . length ( ) ) curIndex = currentText . length ( ) - 1 ; currentText = new StringBuffer ( currentText ) . replace ( curIndex , curIndex + 1 , "" ) . toString ( ) ; switch ( e . getKeyChar ( ) ) { case KeyEvent . VK_BACK_SPACE : if ( curIndex > 0 ) { removeChar ( curIndex - 1 ) ; } curIndex -- ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; case KeyEvent . VK_LEFT : removeChar ( curIndex ) ; curIndex -- ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; case KeyEvent . VK_RIGHT : removeChar ( curIndex ) ; curIndex ++ ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; default : addChar ( e . getKeyChar ( ) , curIndex ) ; curIndex ++ ; addChar ( "*" . charAt ( 0 ) , curIndex ) ; break ; } }
tr	6	public void init ( ) { renderer = new Renderer ( ) ; startTime = getCurrentTime ( ) ; world = renderer . getWorld ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) matrix [ i ] = new Matrix ( ) ; identity ( ) ; renderable . initialize ( ) ; if ( world != null && world . child != null ) for ( int n = 0 ; n < world . child . length ; n ++ ) if ( world . child [ n ] != null && world . child [ n ] . material != null ) mat = world . child [ n ] . material ; }
tr	8	public static List < File > getFilesFromDir ( String directory , List < String > exclusionPattern ) { if ( directory == null || directory . equals ( "" ) ) { return null ; } File directoryToScan = new File ( directory ) ; File [ ] dirList = directoryToScan . listFiles ( ) ; List < File > fixedSizeResult = Arrays . asList ( dirList ) ; List < File > result = new ArrayList < > ( fixedSizeResult ) ; for ( File potentialDir : dirList ) { if ( potentialDir . isDirectory ( ) ) { result . addAll ( getFilesFromDir ( potentialDir . getAbsolutePath ( ) , exclusionPattern ) ) ; } } List < Integer > fileToRemove = new ArrayList < > ( ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { for ( int j = 0 ; j < exclusionPattern . size ( ) ; j ++ ) { if ( result . get ( i ) . getAbsolutePath ( ) . indexOf ( exclusionPattern . get ( j ) ) > 0 ) { fileToRemove . add ( i ) ; j = exclusionPattern . size ( ) ; } } } for ( int i = fileToRemove . size ( ) - 1 ; i >= 0 ; i -- ) { result . remove ( fileToRemove . get ( i ) . intValue ( ) ) ; } return result ; }
tr	7	static public Point [ ] find2CirclesIntersections ( final Point c1 , final double r1 , final Point c2 , final double r2 ) { if ( r1 < 0 || r2 < 0 ) return null ; Point [ ] result = null ; if ( r1 == 0 || r2 == 0 ) { result = new Point [ 2 ] ; if ( r1 == 0 ) result [ 0 ] = new Point ( c1 . getX ( ) , c1 . getY ( ) ) ; else result [ 0 ] = new Point ( c2 . getX ( ) , c2 . getY ( ) ) ; result [ 1 ] = result [ 0 ] ; return result ; } double d = distance ( c1 , c2 ) ; double cosAlpha = 0.5 * ( d * d - r2 * r2 + r1 * r1 ) / d / r1 ; double theta = Math . atan2 ( c2 . getY ( ) - c1 . getY ( ) , c2 . getX ( ) - c1 . getX ( ) ) ; if ( cosAlpha < 1 ) { double alpha = Math . acos ( cosAlpha ) ; result = new Point [ 2 ] ; result [ 0 ] = new Point ( c1 . getX ( ) + r1 * Math . cos ( theta + alpha ) , c1 . getY ( ) + r1 * Math . sin ( theta + alpha ) ) ; result [ 1 ] = new Point ( c1 . getX ( ) + r1 * Math . cos ( theta - alpha ) , c1 . getY ( ) + r1 * Math . sin ( theta - alpha ) ) ; } else if ( ( r1 + r2 ) / d > 0.85 ) { result = new Point [ 2 ] ; result [ 0 ] = new Point ( c1 . getX ( ) + ( c2 . getX ( ) - c1 . getX ( ) ) * r1 / d , c1 . getY ( ) + ( c2 . getY ( ) - c1 . getY ( ) ) * r1 / d ) ; result [ 1 ] = result [ 0 ] ; } return result ; }
tr	4	@ Override public String solve ( case aCase ) { String template = "11%s11%s11%s11%s11" ; final List < String > coins = Lists . newArrayList ( ) ; for ( int i = 0 ; i < aCase . nbits - 10 ; i ++ ) { for ( int j = 0 ; j < aCase . nbits - 10 - i ; j ++ ) { for ( int k = 0 ; k < aCase . nbits - 10 - i - j ; k ++ ) { int l = aCase . nbits - 10 - i - j - k ; String output = String . format ( template , zeroStr ( i ) , zeroStr ( j ) , zeroStr ( k ) , zeroStr ( l ) ) ; coins . add ( output + " 3 2 5 2 7 2 3 2 11" ) ; aCase . jcoins -- ; if ( aCase . jcoins == 0 ) { return stringList ( coins ) ; } } } } throw new RuntimeException ( "Need moar jamcoins" ) ; }
tr	6	private ID3v2CommentFrameData extractCommentFrameData ( String id , boolean itunes ) { ID3v2FrameSet frameSet = frameSets . get ( id ) ; if ( frameSet != null ) { Iterator < ID3v2Frame > iterator = frameSet . getFrames ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) iterator . next ( ) ; ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; if ( itunes && ITUNES_COMMENT_DESCRIPTION . equals ( frameData . getDescription ( ) . toString ( ) ) ) { return frameData ; } else if ( ! itunes ) { return frameData ; } } catch ( InvalidDataException e ) { } } } return null ; }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	8	public int threeSumClosest ( int [ ] num , int target ) { Arrays . sort ( num ) ; int n = num . length ; if ( n < 3 ) { int sum = 0 ; for ( int i : num ) { sum += i ; } return sum ; } int closest = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { closest += num [ i ] ; } for ( int i = 0 ; i <= n - 3 ; i ++ ) { int a = num [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c == target ) { return target ; } else if ( a + b + c > target ) { end -- ; } else { start ++ ; } if ( Math . abs ( a + b + c - target ) < Math . abs ( closest - target ) ) { closest = a + b + c ; } } } return closest ; }
tr	6	public static void openFile ( File file ) { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) ) ; if ( ( OSDetector . isWindows ( ) ) && ( file . isFile ( ) ) ) { int exitCode = runWindows ( file ) ; if ( exitCode == 0 ) { return ; } else { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) + " failed with windows method. (fall back to default action)" ) ; } } if ( ! Desktop . isDesktopSupported ( ) ) { throw new UnsupportedOperationException ( "Desktop is not supported (fatal)" ) ; } Desktop desktop = Desktop . getDesktop ( ) ; if ( ! desktop . isSupported ( Desktop . Action . OPEN ) ) { throw new UnsupportedOperationException ( "Desktop doesn't support the OPEN action (fatal)" ) ; } try { URI uri = file . getCanonicalFile ( ) . toURI ( ) ; desktop . open ( new File ( uri ) ) ; } catch ( IOException e ) { Debug . printException ( e ) ; } }
tr	9	@ Override public Identifier addBooking ( Booking info ) throws DataBaseReadWriteException , InvalidParameterException { Identifier id ; if ( info == null || info . getHostelId ( ) == null || ! Hostels . containsKey ( info . getHostelId ( ) ) || info . getBedIds ( ) == null || info . getBedReservations ( ) == null || info . getBedReservations ( ) . isEmpty ( ) || info . getUserId ( ) == null || ! Users . containsKey ( info . getUserId ( ) ) ) { throw new InvalidParameterException ( "Invalid Booking details" ) ; } for ( Identifier key : info . getBedIds ( ) ) { if ( ! Beds . containsKey ( key ) ) { throw new InvalidParameterException ( "Invalid Bed Ids" ) ; } } id = new Identifier ( ( BookingIdCount ++ ) . toString ( ) ) ; Bookings . put ( id , new Booking ( info ) ) ; return id ; }
tr	8	private void executeCommand ( final String text ) { final InputStream procInput ; new Thread ( new Runnable ( ) { public void run ( ) { try { temp_files_to_clean_up . add ( buffer_file . getCanonicalPath ( ) ) ; PrintWriter out = new PrintWriter ( new FileOutputStream ( buffer_file ) ) ; if ( jTextPane1 . getSelectedText ( ) != null && jTextPane1 . getSelectedText ( ) . length ( ) > 0 ) { out . write ( jTextPane1 . getSelectedText ( ) ) ; } else { out . write ( jTextPane1 . getText ( ) ) ; } out . close ( ) ; String env [ ] = getenv ( 1 ) ; env [ 0 ] = "BUF=" + buffer_file . getCanonicalPath ( ) ; String output = exec ( text , env ) ; ThirdIdea . this . shell_output_area . setText ( shell_output_area . getText ( ) + output ) ; ThirdIdea . this . shell_output_area . getCaret ( ) . setVisible ( true ) ; ThirdIdea . this . shell_output_area . setCaretPosition ( shell_output_area . getText ( ) . length ( ) - 1 ) ; } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { if ( jTextPane1 . getSelectedText ( ) != null && jTextPane1 . getSelectedText ( ) . length ( ) > 0 ) { jTextPane1 . replaceSelection ( readWholeFile ( buffer_file ) ) ; } else { ThirdIdea . this . jTextPane1 . setText ( readWholeFile ( buffer_file ) ) ; } } } private String readWholeFile ( File file ) { InputStream in = null ; String ret = "" ; try { in = new FileInputStream ( file ) ; int file_size = Integer . MAX_VALUE ; if ( file . length ( ) < Integer . MAX_VALUE ) { file_size = ( int ) file . length ( ) ; } byte [ ] buf = new byte [ file_size ] ; in . read ( buf ) ; ret = new String ( buf ) ; } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { try { in . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } return ret ; } } ) . start ( ) ; }
tr	9	private QuerySet < T > range ( String query ) { QuerySet < T > querySet = null ; try { if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { query = query . replace ( "__range" , "" ) ; query = query . replace ( "  " , " " ) ; query = query . replaceAll ( "['\\[\\]]" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; if ( queryComponents != null && queryComponents . length > 0 ) { querySet = new QuerySet < T > ( ) ; querySet . entity ( this . entity ) ; String fieldName = queryComponents [ 0 ] ; String [ ] fieldValues = queryComponents [ 1 ] . split ( " " ) ; Field field = null ; if ( fieldName . trim ( ) . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { for ( int fieldValue = Integer . parseInt ( fieldValues [ 0 ] ) ; fieldValue <= Integer . parseInt ( fieldValues [ 1 ] ) ; fieldValue ++ ) { if ( field . get ( model ) . equals ( fieldValue ) ) { querySet . add ( model ) ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return querySet ; }
tr	5	private void lastNameTextFieldKeyTyped ( java . awt . event . KeyEvent evt ) { lastNameLabel . setForeground ( Color . black ) ; int strLength = lastNameTextField . getText ( ) . length ( ) ; char c = evt . getKeyChar ( ) ; if ( strLength == 30 || ! ( Character . isAlphabetic ( c ) || c == KeyEvent . VK_BACK_SPACE || c == KeyEvent . VK_DELETE || c == KeyEvent . VK_SPACE ) ) { getToolkit ( ) . beep ( ) ; evt . consume ( ) ; } }
tr	0	public boolean containsFamily ( String family ) { return families . contains ( family ) ; }
tr	1	@ Override public Hotel get ( String nom ) throws Exception { Session session = null ; Hotel hotel = null ; try { session = HibernateUtil . getSessionFactory ( ) . getCurrentSession ( ) ; session . beginTransaction ( ) ; hotel = ( Hotel ) session . get ( Hotel . class , nom ) ; } catch ( RuntimeException e ) { session . getTransaction ( ) . rollback ( ) ; throw new Exception ( "hotelNoExisteix" ) ; } return hotel ; }
tr	5	private void updateNPCs ( Stream stream , int i ) { anInt839 = 0 ; anInt893 = 0 ; method139 ( stream ) ; method46 ( i , stream ) ; method86 ( stream ) ; for ( int k = 0 ; k < anInt839 ; k ++ ) { int l = anIntArray840 [ k ] ; if ( npcArray [ l ] . anInt1537 != loopCycle ) { npcArray [ l ] . desc = null ; npcArray [ l ] = null ; } } if ( stream . currentOffset != i ) { signlink . reporterror ( myUsername + " size mismatch in getnpcpos - pos:" + stream . currentOffset + " psize:" + i ) ; throw new RuntimeException ( "eek" ) ; } for ( int i1 = 0 ; i1 < npcCount ; i1 ++ ) if ( npcArray [ npcIndices [ i1 ] ] == null ) { signlink . reporterror ( myUsername + " null entry in npc list - pos:" + i1 + " size:" + npcCount ) ; throw new RuntimeException ( "eek" ) ; } }
tr	5	private final static boolean stringAt ( String string , int start , int length , String [ ] list ) { if ( ( start < 0 ) || ( start >= string . length ( ) ) || list . length == 0 ) return false ; String substr = string . substring ( start , start + length ) ; for ( int i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] . equals ( substr ) ) return true ; } return false ; }
tr	2	public Totals ( String [ ] measures , Map < String , List < CustomAggregateFactory < T >>> aggregateFactories ) { this . aggregates = new HashMap < String , Aggregate < T >> ( ) ; for ( String measure : measures ) { aggregates . put ( measure , new Aggregate < T > ( aggregateFactories . containsKey ( measure ) ? aggregateFactories . get ( measure ) : null ) ) ; } }
tr	6	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == menuitems [ 3 ] ) { int res = JOptionPane . showConfirmDialog ( null , "Do you really want to exit?" , "Confirm Exit" , JOptionPane . OK_CANCEL_OPTION ) ; if ( res == JOptionPane . OK_OPTION ) System . exit ( 0 ) ; } else if ( e . getSource ( ) == menuitems [ 2 ] ) { try { String url = "http://games.brothersoft.com" ; Desktop . getDesktop ( ) . browse ( java . net . URI . create ( url ) ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( frame , "System error  cannot open desktop browser.!" , "Fatal error!" , JOptionPane . ERROR_MESSAGE ) ; } } else if ( e . getSource ( ) == menuitems [ 1 ] ) { JOptionPane . showMessageDialog ( frame , "The Game of Loyalty v1.0\nCreated by bosz.frank_07\nAll rights reserved.\nfb.com/bosz.frank07" , "About Game of Loyalty.." , JOptionPane . INFORMATION_MESSAGE , new icon ( icon ) ) ; } else if ( e . getSource ( ) == menuitems [ 0 ] ) { guiX . removeAll ( ) ; guiX . moves = 0 ; Arbiter . isWin = false ; guiX . initialize ( ) ; guiX . revalidate ( ) ; guiX . repaint ( ) ; tab . setSelectedComponent ( guiX ) ; } }
tr	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : case B : case C : System . out . println ( "Passes" ) ; break ; case D : case F : System . out . println ( "Fail" ) ; break ; default : System . out . println ( "Invalid" ) ; break ; } }
tr	9	private void checkInputParameters ( final String posInput , final String sizeInput , final String timeInput , final String bandInput ) { final List < Info > infos = new ArrayList < Info > ( ) ; final Map < String , String > validationMap = new HashMap < String , String > ( ) ; validationMap . put ( SimpleSpectralAccessProtocolLibrary . POS , posInput ) ; validationMap . put ( SimpleSpectralAccessProtocolLibrary . SIZE , sizeInput ) ; validationMap . put ( SimpleSpectralAccessProtocolLibrary . TIME , timeInput ) ; validationMap . put ( SimpleSpectralAccessProtocolLibrary . BAND , bandInput ) ; Validation validation = new InputsValidation ( validationMap ) ; validation = new NotNullAndNotEmptyValidation ( validation , SimpleSpectralAccessProtocolLibrary . POS ) ; validation = new NotNullAndNotEmptyValidation ( validation , SimpleSpectralAccessProtocolLibrary . SIZE ) ; if ( timeInput != null ) { validation = new TimeValidation ( validation , SimpleSpectralAccessProtocolLibrary . TIME , timeInput ) ; } if ( bandInput != null ) { validation = new NumberArrayValidation ( validation , SimpleSpectralAccessProtocolLibrary . BAND , " " ) ; } if ( validation . validate ( ) . isValid ( ) ) { validation = new SpatialGeoValidation ( validation , SimpleSpectralAccessProtocolLibrary . POS , 0 , 1 , new double [ ] { 0.0 , 360.0 } , new double [ ] { - 90.0 , 90.0 } ) ; validation = new NumberValidation ( validation , SimpleSpectralAccessProtocolLibrary . SIZE , true ) ; } StatusValidation status = validation . validate ( ) ; if ( status . isValid ( ) ) { final String pos = validation . getMap ( ) . get ( SimpleSpectralAccessProtocolLibrary . POS ) ; final String [ ] arrayPos = pos . split ( " " ) ; this . ra = double . valueOf ( arrayPos [ 0 ] ) ; this . dec = double . valueOf ( arrayPos [ 1 ] ) ; final String size = validation . getMap ( ) . get ( SimpleSpectralAccessProtocolLibrary . SIZE ) ; final String [ ] arraySize = size . split ( " " ) ; if ( arraySize . length == 1 ) { this . size = new double [ 1 ] ; this . size [ 0 ] = double . valueOf ( arraySize [ 0 ] ) ; } else { this . size = new double [ 2 ] ; this . size [ 0 ] = double . valueOf ( arraySize [ 0 ] ) ; this . size [ 1 ] = double . valueOf ( arraySize [ 1 ] ) ; } if ( timeInput != null ) { final String time = timeInput ; final String [ ] arrayTime = time . split ( " " ) ; if ( arrayTime . length == 1 ) { this . time = new String [ 1 ] ; this . time [ 0 ] = arrayTime [ 0 ] ; } else { this . time = new String [ 2 ] ; this . time [ 0 ] = arrayTime [ 0 ] ; this . time [ 1 ] = arrayTime [ 1 ] ; } } if ( bandInput != null ) { final String band = bandInput ; final String [ ] arrayBand = band . split ( " " ) ; if ( arrayBand . length == 1 ) { this . band = new double [ 1 ] ; this . band [ 0 ] = double . valueOf ( arrayBand [ 0 ] ) ; } else { this . band = new double [ 2 ] ; this . band [ 0 ] = double . valueOf ( arrayBand [ 0 ] ) ; this . band [ 1 ] = double . valueOf ( arrayBand [ 1 ] ) ; } } } else { Info info = new Info ( ) ; info . setName ( "QUERY_STATUS" ) ; info . setValueAttribute ( "ERROR" ) ; infos . add ( info ) ; final Map < String , String > errors = status . getMessages ( ) ; final Set < Map . Entry < String , String >> entries = errors . entrySet ( ) ; for ( Map . Entry < String , String > entry : entries ) { info = new Info ( ) ; info . setID ( entry . getKey ( ) ) ; info . setName ( "Error in " + entry . getKey ( ) ) ; info . setValueAttribute ( "Error in input " + entry . getKey ( ) + ": " + entry . getValue ( ) ) ; infos . add ( info ) ; LOG . log ( Level . FINEST , "{0}: {1}" , new Object [ ] { entry . getKey ( ) , entry . getValue ( ) } ) ; } } if ( ! infos . isEmpty ( ) ) { this . dataModel . put ( "infos" , infos ) ; } }
tr	7	private void putResize ( int key , V value ) { if ( key == 0 ) { zeroValue = value ; hasZeroValue = true ; return ; } int index1 = key & mask ; int key1 = keyTable [ index1 ] ; if ( key1 == EMPTY ) { keyTable [ index1 ] = key ; valueTable [ index1 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return ; } int index2 = hash2 ( key ) ; int key2 = keyTable [ index2 ] ; if ( key2 == EMPTY ) { keyTable [ index2 ] = key ; valueTable [ index2 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return ; } int index3 = hash3 ( key ) ; int key3 = keyTable [ index3 ] ; if ( key3 == EMPTY ) { keyTable [ index3 ] = key ; valueTable [ index3 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return ; } push ( key , value , index1 , key1 , index2 , key2 , index3 , key3 ) ; }
tr	8	@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) public static void staticMerge ( List < String > files , JZSequenceFile file , Comparator comparator ) { final Comparator tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { JZSequenceFile infile = new JZSequenceFile ( JZFile . JZFileSystem , files . get ( i ) , 0 , 0 ) ; inFiles . add ( infile ) ; JZSequenceFile . Reader < Object , List < Object >> reader = new JZSequenceFile . Reader < Object , List < Object >> ( infile ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } JZSequenceFile . Writer < Object , List < Object >> writer = new JZSequenceFile . Writer < Object , List < Object >> ( file ) ; List < Object > list = new ArrayList < Object > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; Object preKey = ( Object ) firstEntry [ 0 ] ; JZSequenceFile . Reader < Object , List < Object >> reader = ( JZSequenceFile . Reader < Object , List < Object >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; Object key = ( Object ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < Object , List < Object >> ) entry [ 1 ] ; List < Object > value = ( List < Object > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writer . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < Object > ( value ) ; } if ( reader . nextKeyValue ( ) ) { Object newKey = ( Object ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writer . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } writer . close ( ) ; }
tr	9	public String nextString ( char quote ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case 0 : case '' : case '' : throw syntaxError ( "Unterminated string" ) ; case \ : c = next ( ) ; switch ( c ) { case b : sb . append (  ) ; break ; case t : sb . append ( 	 ) ; break ; case n : sb . append ( '' ) ; break ; case f : sb . append (  ) ; break ; case r : sb . append ( '' ) ; break ; case u : sb . append ( ( char ) Integer . parseInt ( next ( 4 ) , 16 ) ) ; break ; case x : sb . append ( ( char ) Integer . parseInt ( next ( 2 ) , 16 ) ) ; break ; default : sb . append ( c ) ; } break ; default : if ( c == quote ) { return sb . toString ( ) ; } sb . append ( c ) ; } } }
tr	2	public static String hashcode ( String message ) { String hash = null ; try { MessageDigest cript = MessageDigest . getInstance ( "SHA-1" ) ; cript . reset ( ) ; cript . update ( message . getBytes ( "utf8" ) ) ; hash = new BigInteger ( 1 , cript . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return hash ; }
tr	5	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof EulerAngles ) { EulerAngles otherAngle = ( EulerAngles ) other ; if ( FloatingPointUtils . floatEqual ( otherAngle . psi , this . psi ) && FloatingPointUtils . floatEqual ( otherAngle . theta , this . theta ) && FloatingPointUtils . floatEqual ( otherAngle . phi , this . phi ) ) { return true ; } } return false ; }
tr	3	public int size ( ) { return 1 + ( left == null ? 0 : left . size ( ) ) + ( center == null ? 0 : center . size ( ) ) + ( right == null ? 0 : right . size ( ) ) ; }
tr	8	public static void main ( String [ ] args ) { int port = 4444 ; Queue < String > arguments = new LinkedList < String > ( Arrays . asList ( args ) ) ; try { while ( ! arguments . isEmpty ( ) ) { String flag = arguments . remove ( ) ; try { if ( flag . equals ( "--port" ) ) { port = Integer . parseInt ( arguments . remove ( ) ) ; if ( port < 0 || port > 65535 ) { throw new IllegalArgumentException ( "port " + port + " out of range" ) ; } } else { throw new IllegalArgumentException ( "unknown option: \"" + flag + "\"" ) ; } } catch ( NoSuchElementException nsee ) { throw new IllegalArgumentException ( "missing argument for " + flag ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( "unable to parse number for " + flag ) ; } } } catch ( IllegalArgumentException iae ) { System . err . println ( iae . getMessage ( ) ) ; System . err . println ( "usage: WhiteboardServer [--port PORT]" ) ; return ; } try { runWhiteboardServer ( port ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	6	public void addPriceStep ( double startPrice , double endPrice , double fixedPrice , double variablePricePercent ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; fixedPrice = round ( fixedPrice ) ; variablePricePercent = round ( variablePricePercent ) ; PriceStep newStep = new PriceSteps . PriceStep ( startPrice , endPrice , fixedPrice , variablePricePercent ) ; if ( startPrice < 0 || endPrice < 0 || fixedPrice < 0 || variablePricePercent < 0 ) { throw new PriceStepNegativeArgumentException ( ) ; } for ( PriceStep storedStep : priceSteps ) { if ( newStep . overlaps ( storedStep ) ) throw new PriceStepIntervalCollisionException ( ) ; } this . priceSteps . add ( newStep ) ; }
tr	3	private void notifyClientsDeviceRemoved ( String [ ] deviceNames ) { for ( int h = 0 ; h < deviceNames . length ; h ++ ) { String deviceName = deviceNames [ h ] ; String message = "<delProperty device=\"" + deviceName + "\" />" ; ArrayList < INDIDeviceListener > list = this . getClientsListeningToDevice ( deviceName ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { INDIDeviceListener c = list . get ( i ) ; c . sendXMLMessage ( message ) ; } ArrayList < INDIDeviceListener > list2 = this . getClientsListeningToSingleProperties ( deviceName ) ; for ( int i = 0 ; i < list2 . size ( ) ; i ++ ) { INDIDeviceListener c = list2 . get ( i ) ; c . sendXMLMessage ( message ) ; } } }
tr	4	private Constant simplifySub ( AbstractBinaryOperator binaryOperator , AbstractMutableFormula left , AbstractMutableFormula right ) { if ( binaryOperator instanceof SubOperator && left instanceof Variable && right instanceof Variable && ( ( Variable ) left ) . getName ( ) . equals ( ( ( Variable ) right ) . getName ( ) ) ) { return new Constant ( 0 ) ; } return null ; }
tr	8	@ Override public DataUnit fromStream ( DataUnit du , Protocol p , ReadableByteChannel channel ) throws IOException { List < Element > elements = new LinkedList < > ( du . getUnit ( ) . getBody ( ) . getElements ( ) ) ; Deque < HeterogeneousContainer > containerPerLevel = new ArrayDeque < > ( ) ; containerPerLevel . offerFirst ( du ) ; Deque < Integer > elementsPerLevel = new ArrayDeque < > ( ) ; elementsPerLevel . offerFirst ( elements . size ( ) ) ; ListIterator < Element > it = elements . listIterator ( ) ; while ( it . hasNext ( ) ) { Element e = it . next ( ) ; HeterogeneousContainer data = containerPerLevel . peekFirst ( ) ; int elementsLeft = elementsPerLevel . peekFirst ( ) ; elementsLeft = elementsPerLevel . pollFirst ( ) ; elementsLeft -- ; elementsPerLevel . offerFirst ( elementsLeft ) ; if ( elementsLeft <= 0 ) { containerPerLevel . pollFirst ( ) ; elementsPerLevel . pollFirst ( ) ; } if ( e . getType ( ) != null ) { Object value = ep . read ( e , channel ) ; data . addPrimitiveValue ( e . getId ( ) , e . getType ( ) , value ) ; } else { ComplexType ct = getComplexType ( e . getClassification ( ) , p , du . getUnit ( ) ) ; int occurrences = 1 ; if ( ElementUtil . hasPrecedingLengthField ( e ) ) { int width = ElementUtil . getPrecedingLengthFieldWidth ( e ) ; AtomProcessor < long > ap = AtomProcessorFactory . getProcessor ( Primitive . INTEGER ) ; occurrences = ap . interpret ( IoUtil . readBytes ( width , channel ) , IntegerEncoding . UNSIGNED ) . intValue ( ) ; } else if ( ElementUtil . hasFixedLength ( e ) ) occurrences = ElementUtil . getFixedLength ( e ) ; int elementsAdded = addElements ( e , ct , occurrences , it ) ; if ( elementsAdded > 0 ) { List < Composition > compositions = new ArrayList < > ( occurrences ) ; for ( int i = 0 ; i < occurrences ; i ++ ) { Composition c = new Composition ( ) ; c . setId ( e . getId ( ) ) ; compositions . add ( c ) ; data . addComplexObject ( e . getId ( ) , c ) ; } Collections . reverse ( compositions ) ; for ( Composition c : compositions ) { containerPerLevel . offerFirst ( c ) ; elementsPerLevel . offerFirst ( ct . getElements ( ) . size ( ) ) ; } } } } return du ; }
tr	3	protected void setAdditionalDescription ( ) { if ( requiredAdjacentSquareThatAreUs > 0 ) { addAdditionalNameDetails ( "  N" + requiredAdjacentSquareThatAreUs ) ; addAdditionalDescritionDetails ( " with " + requiredAdjacentSquareThatAreUs + " of us as a neigbour" ) ; } if ( numberToFind >= 0 ) { addAdditionalNameDetails ( "  #" + numberToFind ) ; addAdditionalDescritionDetails ( " find " + numberToFind ) ; } if ( rulePlayerIndex >= 0 ) { String playerName = gameStatus . players [ rulePlayerIndex ] . getName ( ) ; addAdditionalNameDetails ( "  " + playerName ) ; addAdditionalDescritionDetails ( " only " + playerName ) ; } addConfigDescriptor ( "rastau=" + requiredAdjacentSquareThatAreUs ) ; addConfigDescriptor ( "ntf=" + numberToFind ) ; addConfigDescriptor ( "pi=" + rulePlayerIndex ) ; }
tr	1	public RecordArticleStatAllTimeModel save ( RecordArticleStatAllTimeModel model ) { if ( model . getId ( ) != null ) { return updateRecordArticleStatAllTime ( model ) ; } else { return addRecordArticleStatAllTimeModel ( model ) ; } }
tr	5	private static void method340 ( int i , int j , int k , int l , int i1 ) { if ( k < topY || k >= bottomY ) return ; if ( i1 < topX ) { j -= topX - i1 ; i1 = topX ; } if ( i1 + j > bottomX ) j = bottomX - i1 ; int j1 = 256 - l ; int k1 = ( i >> 16 & ff ) * l ; int l1 = ( i >> 8 & ff ) * l ; int i2 = ( i & ff ) * l ; int i3 = i1 + k * width ; for ( int j3 = 0 ; j3 < j ; j3 ++ ) { int j2 = ( pixels [ i3 ] >> 16 & ff ) * j1 ; int k2 = ( pixels [ i3 ] >> 8 & ff ) * j1 ; int l2 = ( pixels [ i3 ] & ff ) * j1 ; int k3 = ( ( k1 + j2 >> 8 ) << 16 ) + ( ( l1 + k2 >> 8 ) << 8 ) + ( i2 + l2 >> 8 ) ; pixels [ i3 ++ ] = k3 ; } }
tr	0	public void testApp ( ) { assertTrue ( true ) ; }
tr	3	void destroyMe ( ) { app . clock . removeObserver ( this ) ; for ( int i = 0 ; i < clouds . size ( ) ; i ++ ) { Cloud cloud = clouds . elementAt ( i ) ; if ( cloud . age < cloud . t_nose + cloud . t_mature ) { if ( cloud . age > cloud . t_nose ) cloud . t_mature = ( int ) cloud . age - cloud . t_nose ; else cloud . t_mature = 0 ; } } }
tr	5	private void showdownPlayerControls ( ArrayList < PokerHandEvaluation > playerEvaluation , boolean show ) { for ( int i = 0 ; i < playerEvaluation . size ( ) ; i ++ ) { String rankDescription = playerEvaluation . get ( i ) . getRankDescription ( ) ; if ( i == 0 ) { lblFirstPlayerHandResult . setVisible ( show ) ; lblFirstPlayerHandResultInfo . setVisible ( show ) ; lblFirstPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i == 1 ) { lblSecondPlayerHandResult . setVisible ( show ) ; lblSecondPlayerHandResultInfo . setVisible ( show ) ; lblSecondPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i == 2 ) { lblThirdPlayerHandResult . setVisible ( show ) ; lblThirdPlayerHandResultInfo . setVisible ( show ) ; lblThirdPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i == 3 ) { lblFourthPlayerHandResult . setVisible ( show ) ; lblFourthPlayerHandResultInfo . setVisible ( show ) ; lblFourthPlayerHandResultInfo . setText ( rankDescription ) ; } } lblWinner . setVisible ( show ) ; lblWinnerInfo . setVisible ( show ) ; pnlWinner . setVisible ( show ) ; lblPot . setVisible ( show ) ; lblPotInfo . setVisible ( show ) ; }
tr	7	public void actionPerformed ( ActionEvent e ) { String action = e . getActionCommand ( ) ; if ( action . equals ( "Next" ) ) { SlideShow . this . counter ++ ; if ( SlideShow . this . counter == SlideShow . this . numberPhotos ) SlideShow . this . counter = 0 ; SlideShow . this . slideArea . remove ( picture ) ; SlideShow . this . slideArea . remove ( SlideShow . this . nextBtn ) ; SlideShow . this . picture = SlideShow . this . photosEffect . get ( SlideShow . this . counter ) ; SlideShow . this . slideArea . add ( picture ) ; SlideShow . this . slideArea . add ( SlideShow . this . nextBtn ) ; if ( SlideShow . this . photos != null ) { SlideShow . this . photoNameLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getFilename ( ) ) ; SlideShow . this . captionLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getCaption ( ) ) ; SlideShow . this . dateLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getStringDate ( ) ) ; } else { SlideShow . this . photoNameLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getFilename ( ) ) ; SlideShow . this . captionLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getCaption ( ) ) ; SlideShow . this . dateLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getStringDate ( ) ) ; } SlideShow . this . repaint ( ) ; } if ( action . equals ( "Previous" ) ) { SlideShow . this . counter -- ; if ( SlideShow . this . counter == - 1 ) SlideShow . this . counter = SlideShow . this . numberPhotos - 1 ; SlideShow . this . slideArea . remove ( picture ) ; SlideShow . this . slideArea . remove ( SlideShow . this . nextBtn ) ; SlideShow . this . picture = SlideShow . this . photosEffect . get ( SlideShow . this . counter ) ; SlideShow . this . slideArea . add ( picture ) ; SlideShow . this . slideArea . add ( SlideShow . this . nextBtn ) ; if ( SlideShow . this . photos != null ) { SlideShow . this . photoNameLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getFilename ( ) ) ; SlideShow . this . captionLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getCaption ( ) ) ; SlideShow . this . dateLbl . setText ( SlideShow . this . photosSlide . get ( SlideShow . this . counter ) . photo . getStringDate ( ) ) ; } else { SlideShow . this . photoNameLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getFilename ( ) ) ; SlideShow . this . captionLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getCaption ( ) ) ; SlideShow . this . dateLbl . setText ( SlideShow . this . photosSlideSearchResult . get ( SlideShow . this . counter ) . getStringDate ( ) ) ; } SlideShow . this . slideArea . repaint ( ) ; SlideShow . this . slideArea . revalidate ( ) ; } if ( action . equals ( "Back" ) ) { SlideShow . this . photosScreen . setVisible ( true ) ; SlideShow . this . setVisible ( false ) ; } }
tr	9	public static Integer getIntegerFromSubString ( String target , String prefix , String suffix ) { if ( target == null ) return null ; Integer retVal = null ; try { String tmp = target ; if ( prefix != null && target . contains ( prefix ) ) { int sz = prefix . length ( ) ; int in = target . indexOf ( prefix ) ; tmp = target . substring ( in + sz ) ; } if ( tmp != null && suffix != null && target . contains ( suffix ) ) { int suf = tmp . indexOf ( suffix ) ; if ( suf <= 0 && suffix . equals ( " " ) ) suf = tmp . length ( ) ; tmp = tmp . substring ( 0 , suf ) ; retVal = IntUtils . getIntegerFromString ( tmp . trim ( ) ) ; } } catch ( Exception e ) { LOGGER . log ( Level . INFO , "Not a big deal that we couldn't find an int from substring...going to return null" , e ) ; retVal = null ; } return retVal ; }
tr	4	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { credit = new Credit ( ) ; cdaoi = new CreditDAOImpl ( conn ) ; Currency currency = new CurrencyDAOImpl ( conn ) . findByName ( jComboBox2 . getSelectedItem ( ) . toString ( ) ) ; Bank bank = new BankDAOImpl ( conn ) . findByName ( jComboBox1 . getSelectedItem ( ) . toString ( ) ) ; client = TestProject . getClient ( ) ; if ( jTextField3 . getText ( ) . equals ( "" ) || jTextField6 . getText ( ) . equals ( "" ) || jDateChooser1 . getDate ( ) == null ) { JOptionPane . showMessageDialog ( null , "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0430\u044E\u0449\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0435!" ) ; } else { setValuesToNewCredit ( bank , currency ) ; cdaoi . insert ( credit ) ; JOptionPane . showMessageDialog ( null , "\u041A\u0440\u0435\u0434\u0438\u0442 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D!" ) ; testProject . Update_Table_Credit ( ) ; close ( ) ; } } catch ( NumberFormatException | HeadlessException | SQLException ex ) { Logger . getLogger ( AddCredit_frame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	public Method getSelectedMethod ( ) { if ( optRaw . isSelected ( ) ) return Method . RAW ; if ( optSameOrder . isSelected ( ) ) return Method . SAME_ORDER ; if ( optKnownFirst . isSelected ( ) ) return Method . KNOWN_FIRST ; return Method . NONE_SELECTED ; }
tr	1	private boolean whenToken ( TokenType t ) { if ( testToken ( t ) ) { data . pop ( ) ; return true ; } else { return false ; } }
tr	9	public List < File > buildFont ( String internalName , FileGarbage garbage ) throws IOException { File tempDir = File . createTempFile ( "fonts" , ".tmp" ) ; tempDir . delete ( ) ; tempDir . mkdirs ( ) ; garbage . addFile ( tempDir , true ) ; File binDir = new File ( "bin" ) ; File binFile = new File ( binDir , "otftotfm" ) ; File encFile = new File ( "resources/T1-WGL4.enc" ) ; File glyphFile = new File ( "resources/glyphlist.txt" ) ; File inputFile = new File ( tempDir , mSourceFile . getName ( ) . replace (   , _ ) ) ; File mapFile = new File ( tempDir , internalName + ".map" ) ; NativeFiles . copy ( mSourceFile , inputFile ) ; List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( binFile . getAbsolutePath ( ) ) ; cmd . add ( "--no-updmap" ) ; cmd . add ( "--encoding=" + encFile . getAbsolutePath ( ) ) ; cmd . add ( "--glyphlist=" + glyphFile . getAbsolutePath ( ) ) ; cmd . add ( "-fkern" ) ; cmd . add ( "-fliga" ) ; cmd . add ( "--map-file=" + mapFile . getAbsolutePath ( ) ) ; if ( mExtend != 1.0 ) { cmd . add ( "--extend=" + mExtend ) ; } if ( mSlant != 0.0 ) { cmd . add ( "--slant=" + mSlant ) ; } if ( mSmallcaps ) { cmd . add ( "-fsmcp" ) ; } if ( mOldStyle ) { cmd . add ( "-fonum" ) ; } cmd . add ( inputFile . getName ( ) ) ; cmd . add ( internalName ) ; try { TranslatorUtil . exec ( cmd , binDir , tempDir , false , false ) ; } catch ( InterruptedException ex ) { InterruptedIOException e = new InterruptedIOException ( ) ; e . initCause ( ex ) ; throw e ; } catch ( IOException ex ) { FontFormat format = FontFormat . forFile ( mSourceFile ) ; if ( format == FontFormat . TTF ) { return tryTtfTranslator ( internalName , garbage ) ; } } File [ ] files = tempDir . listFiles ( ) ; List < File > ret = new ArrayList < File > ( ) ; for ( File f : files ) { if ( f . isFile ( ) && ! f . isHidden ( ) ) { FontFormat format = FontFormat . forFile ( f ) ; if ( format == FontFormat . OTF ) { continue ; } ret . add ( f ) ; } } return ret ; }
tr	8	public void addLookup ( char ch ) { Character c = new Character ( ch ) ; NodePtr tmp ; Iterator < NodePtr > iter = lookups . listIterator ( 0 ) ; while ( iter . hasNext ( ) ) { tmp = iter . next ( ) ; if ( ! tmp . addChar ( ch ) ) { if ( tmp . getNode ( ) . getEnd ( ) ) { candidates . remove ( tmp ) ; candidates . put ( tmp , tmp . getString ( ) ) ; } if ( candidates . containsKey ( tmp ) ) { System . out . println ( candidates . get ( tmp ) ) ; candidates . remove ( tmp ) ; } iter . remove ( ) ; } else { if ( tmp . getNode ( ) . getEnd ( ) ) { if ( ! candidates . containsKey ( tmp ) ) { candidates . remove ( tmp ) ; candidates . put ( tmp , tmp . getString ( ) ) ; } } } } TrieNode node = children . get ( c ) ; if ( node != null ) { tmp = new NodePtr ( ch ) ; tmp . setNode ( node ) ; if ( node . getEnd ( ) ) { candidates . put ( tmp , tmp . getString ( ) ) ; } lookups . add ( tmp ) ; } }
tr	1	public Set < String > keySet ( ) { if ( mode == Mode . Map ) { return map . keySet ( ) ; } throw new PerlHashTypeException ( "Not a map" ) ; }
tr	8	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; while ( scan . hasNext ( ) ) { int n = scan . nextInt ( ) ; String binaryN = Integer . toBinaryString ( n ) ; while ( binaryN . length ( ) < 32 ) binaryN = 0 + binaryN ; String [ ] cadN = new String [ 4 ] ; cadN [ 0 ] = binaryN . substring ( 0 , 8 ) ; cadN [ 1 ] = binaryN . substring ( 8 , 16 ) ; cadN [ 2 ] = binaryN . substring ( 16 , 24 ) ; cadN [ 3 ] = binaryN . substring ( 24 , 32 ) ; String aux = cadN [ 3 ] ; cadN [ 3 ] = cadN [ 0 ] ; cadN [ 0 ] = aux ; aux = cadN [ 2 ] ; cadN [ 2 ] = cadN [ 1 ] ; cadN [ 1 ] = aux ; String Sres = cadN [ 0 ] + cadN [ 1 ] + cadN [ 2 ] + cadN [ 3 ] ; int res = 0 ; int conf = 32 ; String Nres = "" ; if ( Sres . charAt ( 0 ) == 1 ) { for ( int i = 1 ; i < 32 ; i ++ ) { if ( Sres . charAt ( 32 - i ) == 1 ) { conf = 32 - i ; break ; } } for ( int i = 0 ; i < conf ; i ++ ) { Nres += Sres . charAt ( i ) == 1 ? 0 : 1 ; } for ( int i = conf ; i < 32 ; i ++ ) { Nres += Sres . charAt ( i ) ; } System . out . println ( n + " converts to -" + Integer . parseInt ( Nres , 2 ) ) ; } else { res = Integer . parseInt ( Sres , 2 ) ; System . out . println ( n + " converts to " + res ) ; } } }
tr	3	@ Override public void tick ( Input input , double delta ) { if ( this . dummy . getCommands ( ) . isEmpty ( ) ) { double ran = Math . random ( ) ; if ( ran >= 0.5 ) { } else { this . dummy . wait ( Math . random ( ) * 0.4 ) ; } ran = Math . random ( ) ; if ( ran >= 0.2 ) { this . dummy . getCommands ( ) . add ( new JumpCommand ( this . dummy ) ) ; } } }
tr	9	private void processFields ( List data , Importable importable , ImportObjectMeta . ImportObjectSheet sheet ) throws InvocationTargetException , IllegalAccessException , InstantiationException { List < String > fields = sheet . getFieldPaths ( ) ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { List row = ( List ) data . get ( i ) ; for ( int j = 0 ; j < fields . size ( ) ; j ++ ) { Cell cell = ( Cell ) row . get ( j + 1 ) ; String fieldName = fields . get ( j ) ; if ( fieldName . indexOf ( "Date" ) >= 0 ) { Util . setDottedFieldValue ( fields . get ( j ) , importable , cell . getDateCellValue ( ) ) ; } else if ( fieldName . indexOf ( "amount" ) >= 0 ) { Util . setDottedFieldValue ( fields . get ( j ) , importable , new long ( ( long ) cell . getNumericCellValue ( ) ) ) ; } else if ( fieldName . indexOf ( "review" ) >= 0 || fieldName . indexOf ( "vip" ) >= 0 || fieldName . indexOf ( "application" ) >= 0 || fieldName . indexOf ( "certificates" ) >= 0 || fieldName . indexOf ( "pdcNotClear" ) >= 0 ) { cell . setCellType ( Cell . CELL_TYPE_BOOLEAN ) ; Util . setDottedFieldValue ( fields . get ( j ) , importable , cell . getBooleanCellValue ( ) ) ; } else if ( fieldName . indexOf ( "historyRecord" ) >= 0 ) { cell . setCellType ( Cell . CELL_TYPE_STRING ) ; String comment = cell . getStringCellValue ( ) ; if ( ! Util . nullOrEmptyOrBlank ( comment ) ) { HistoryRecord record = new HistoryRecord ( ) ; record . setComment ( comment ) ; Util . setDottedFieldValue ( fields . get ( j ) , importable , record ) ; } } else { cell . setCellType ( Cell . CELL_TYPE_STRING ) ; Util . setDottedFieldValue ( fields . get ( j ) , importable , cell . getStringCellValue ( ) ) ; } } if ( ! Util . nullOrEmptyOrBlank ( sheet . getFieldPathGetter ( ) ) ) { Object obj = Util . getDottedFieldValue ( sheet . getFieldPathGetter ( ) , importable ) ; Util . setDottedFieldValue ( sheet . getFieldPathSetter ( ) , importable , obj , false ) ; Util . setDottedFieldValue ( sheet . getFieldPathGetter ( ) , importable , null , false ) ; } } }
tr	6	public void newInetAddress ( InetAddress address ) { if ( ! ( address instanceof java . net . Inet4Address ) ) return ; if ( ! mPreferredAddresses . isEmpty ( ) && mPreferredAddresses . get ( 0 ) . isSiteLocalAddress ( ) && ! address . isSiteLocalAddress ( ) ) mPreferredAddresses . clear ( ) ; if ( mPreferredAddresses . isEmpty ( ) || ( address . isSiteLocalAddress ( ) == mPreferredAddresses . get ( 0 ) . isSiteLocalAddress ( ) ) ) mPreferredAddresses . add ( address ) ; }
tr	8	@ Override public void keyPressed ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_UP : this . editor . getCursor ( ) . selectLineUp ( ) ; break ; case KeyEvent . VK_DOWN : this . editor . getCursor ( ) . selectLineDown ( ) ; break ; case KeyEvent . VK_LEFT : this . editor . getCursor ( ) . movePositionLeft ( ) ; break ; case KeyEvent . VK_RIGHT : this . editor . getCursor ( ) . movePositionRight ( ) ; break ; case KeyEvent . VK_DELETE : if ( this . editor . getCursor ( ) . getCurrentPosition ( ) < this . editor . getCursor ( ) . getCurrentLine ( ) . length ( ) ) this . editor . getSelectedLine ( ) . deleteCharAt ( this . editor . getSelectedCharacterNb ( ) ) ; break ; case KeyEvent . VK_BACK_SPACE : if ( this . editor . getCursor ( ) . getCurrentPosition ( ) > 0 ) { this . editor . getSelectedLine ( ) . deleteCharAt ( this . editor . getSelectedCharacterNb ( ) - 1 ) ; this . editor . getCursor ( ) . movePositionLeft ( ) ; } break ; } view . getDocument ( ) . setText ( this . editor . print ( ) ) ; }
tr	4	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } int [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || obj . getClass ( ) != this . getClass ( ) ) { return false ; } WordPOSKey myWordPOSKey = ( WordPOSKey ) obj ; boolean case1 = ( this . word == null ) ? myWordPOSKey . getWord ( ) == null : this . word . equals ( myWordPOSKey . getWord ( ) ) ; boolean case2 = ( this . pos == null ) ? myWordPOSKey . getPOS ( ) == null : this . pos . equals ( myWordPOSKey . getPOS ( ) ) ; return ( case1 && case2 ) ; }
tr	8	public static void main ( String [ ] args ) throws Throwable { class stemClass = class . forName ( "net.sf.snowball.ext." + args [ 0 ] + "Stemmer" ) ; SnowballProgram stemmer = ( SnowballProgram ) stemClass . newInstance ( ) ; Method stemMethod = stemClass . getMethod ( "stem" , new class [ 0 ] ) ; Reader reader ; reader = new InputStreamReader ( new FileInputStream ( args [ 1 ] ) ) ; reader = new BufferedReader ( reader ) ; StringBuffer input = new StringBuffer ( ) ; OutputStream outstream ; if ( args . length > 2 && args [ 2 ] . equals ( "-o" ) ) { outstream = new FileOutputStream ( args [ 3 ] ) ; } else if ( args . length == 2 ) { System . err . println ( "Usage: TestApp <input file> [-o <output file>]" ) ; return ; } else { outstream = System . out ; } Writer output = new OutputStreamWriter ( outstream ) ; output = new BufferedWriter ( output ) ; int repeat = 1 ; if ( args . length > 4 ) { repeat = Integer . parseInt ( args [ 4 ] ) ; } Object [ ] emptyArgs = new Object [ 0 ] ; int character ; while ( ( character = reader . read ( ) ) != - 1 ) { char ch = ( char ) character ; if ( Character . isWhitespace ( ( char ) ch ) ) { if ( input . length ( ) > 0 ) { stemmer . setCurrent ( input . toString ( ) ) ; for ( int i = repeat ; i != 0 ; i -- ) { stemMethod . invoke ( stemmer , emptyArgs ) ; } output . write ( stemmer . getCurrent ( ) ) ; output . write ( '' ) ; input . delete ( 0 , input . length ( ) ) ; } } else { input . append ( Character . toLowerCase ( ch ) ) ; } } output . flush ( ) ; }
tr	2	public static String decodeURIComponent ( String s ) { if ( s == null ) { return null ; } String result = null ; try { result = URLDecoder . decode ( s , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { result = s ; } return result ; }
tr	6	@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( "scrapeInterval" ) ) { inScrapeInterval = true ; } else if ( qName . equals ( "general" ) ) { inGeneral = true ; } else if ( qName . equals ( "subtitles" ) ) { inSubs = true ; } else if ( qName . equals ( "filters" ) ) { inFil = true ; } else if ( qName . equals ( "tvdb" ) ) { inTVDB = true ; } else if ( qName . equals ( "languages" ) ) { inLang = true ; } }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	5	public static List < class > getLinksClasses ( class cls , Predicate < class > isLinkPredicate ) { List < class > classes = new ArrayList < class > ( ) ; if ( isLinkPredicate . evaluate ( cls ) ) { classes . add ( cls ) ; } for ( PropertyDescriptor desc : PropertyUtils . getPropertyDescriptors ( cls ) ) { class type = desc . getPropertyType ( ) ; if ( List . class . isAssignableFrom ( type ) ) { try { Field fld = cls . getDeclaredField ( desc . getName ( ) ) ; type = typeExtractor ( fld ) ; } catch ( Exception e ) { int temp = 6 ; } } if ( isLinkPredicate . evaluate ( type ) ) { classes . addAll ( getLinksClasses ( type , isLinkPredicate ) ) ; } } return classes ; }
tr	5	public String getLatestTransmissionAttempt ( ) { if ( transmissionAttempts == 0 ) { return "no attempt yet" ; } switch ( transmissionAttempts ) { case 1 : return "first attempt" ; case 2 : return "second attempt" ; case 3 : return "third attempt" ; case 4 : return "fourth attempt" ; default : return "attempt #" + transmissionAttempts ; } }
tr	2	public final Vector getOptionValues ( Option option ) { Vector result = new Vector ( ) ; while ( true ) { Object o = getOptionValue ( option , null ) ; if ( o == null ) { return result ; } else { result . addElement ( o ) ; } } }
tr	9	private List < String > collectInclude ( ) { List < String > list = new ArrayList < String > ( ) ; if ( javaChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JAVA ) ; } if ( txtChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_TXT ) ; } if ( jtlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JTL ) ; } if ( cvsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CVS ) ; } if ( datChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_DAT ) ; } if ( htmlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_HTML ) ; } if ( jspChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JSP ) ; } if ( cssChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CSS ) ; } if ( jsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JS ) ; } String udp = includeField . getText ( ) ; if ( udp == null || udp . isEmpty ( ) || udp . equals ( INCLUDE_RECOMMAND_STRING ) ) { } else { for ( String temp : udp . split ( ";" ) ) { list . add ( temp ) ; } } return list ; }
tr	4	protected int findMacroBlock ( int position ) throws BTFMatrixErrorException { if ( position < 0 ) throw new BTFMatrixErrorException ( "Trying to find macro block containing index: " + position ) ; int block = 0 ; for ( int i = 1 ; i < macro_blocks . length ; i ++ ) { if ( position >= ( macro_blocks [ i ] . getStartingRow ( ) ) ) { block ++ ; } } if ( block >= macro_blocks . length ) throw new BTFMatrixErrorException ( "Ran out of macro blocks! position = " + position ) ; return block ; }
tr	8	public static void main ( String [ ] args ) throws Exception { CommandLine cmd = null ; String host = ClientApp . DEFAULT_HOST ; int port = ClientApp . DEFAULT_PORT ; cmd = ClientApp . parseArgs ( args ) ; if ( cmd != null ) { if ( cmd . hasOption ( "host" ) ) { host = cmd . getOptionValue ( "host" ) ; } if ( cmd . hasOption ( "port" ) ) { port = Integer . parseInt ( cmd . getOptionValue ( "port" ) ) ; } boolean connected = ClientApp . connectToServer ( host , port ) ; if ( ! connected ) { System . out . println ( "Error connecting to RMI. Please see stack trace" ) ; } else { Scanner in = new Scanner ( System . in ) ; IView view = new ConsoleView ( in , System . out ) ; if ( cmd . hasOption ( "gui" ) ) { view = new GraphicView ( ) ; } Client client = new Client ( ClientApp . server , view ) ; boolean exported = ClientApp . exportClient ( client ) ; if ( ! exported ) { System . out . println ( "Error exporting client to RMI. Please see stack trace" ) ; } else { client . connect ( ) ; if ( cmd . hasOption ( "gui" ) ) { ( ( GraphicView ) view ) . setVisible ( true ) ; } while ( ! client . isGameFinished ( ) ) { Thread . sleep ( 2000 ) ; } } } } }
tr	6	@ Test public void testMap ( ) throws Exception { GenericListEntity entity = new GenericListEntity ( ) ; entity . set_id ( "z1" ) ; entity . setMap ( new HashMap < TestEnumEntity , AbstractAncestorEntity > ( ) ) ; entity . getMap ( ) . put ( TestEnumEntity . FOUR , new AncestorEntity ( "id1" , "base1" ) ) ; entity . getMap ( ) . put ( TestEnumEntity . FIVE , new Descendant1Entity ( "id2" , "base2" , "aaaa" ) ) ; entity . getMap ( ) . put ( TestEnumEntity . SIX , new Descendant2Entity ( "id3" , "base3" , "bbbb" ) ) ; Mongo m = new Mongo ( "localhost" , 27017 ) ; DB db = m . getDB ( "mydb1" ) ; DBCollection coll = db . getCollection ( "testCollection" ) ; coll . drop ( ) ; DBObject dbObject = Converter . toDBObject ( entity ) ; coll . save ( dbObject ) ; DBObject newDbObject = coll . findOne ( ) ; GenericListEntity newEntity = Converter . toObject ( GenericListEntity . class , newDbObject ) ; assertNotNull ( newEntity ) ; assertNotNull ( newEntity . getMap ( ) ) ; assertEquals ( 3 , newEntity . getMap ( ) . size ( ) ) ; boolean aFound = false , d1Found = false , d2Found = false ; for ( TestEnumEntity k : newEntity . getMap ( ) . keySet ( ) ) { Object o = newEntity . getMap ( ) . get ( k ) ; System . out . println ( o . getClass ( ) . getName ( ) ) ; if ( o instanceof Descendant1Entity ) { d1Found = true ; Descendant1Entity d1 = ( Descendant1Entity ) o ; assertEquals ( "aaaa" , d1 . getS1 ( ) ) ; assertEquals ( "id2" , d1 . get_id ( ) ) ; assertEquals ( "base2" , d1 . getBaseField ( ) ) ; assertEquals ( "entity1" , d1 . abstractMethod ( ) ) ; } else if ( o instanceof Descendant2Entity ) { d2Found = true ; Descendant2Entity d2 = ( Descendant2Entity ) o ; assertEquals ( "bbbb" , d2 . getS2 ( ) ) ; assertEquals ( "id3" , d2 . get_id ( ) ) ; assertEquals ( "base3" , d2 . getBaseField ( ) ) ; assertEquals ( "entity2" , d2 . abstractMethod ( ) ) ; } else if ( o instanceof AncestorEntity ) { aFound = true ; AncestorEntity aa = ( AncestorEntity ) o ; assertEquals ( "id1" , aa . get_id ( ) ) ; assertEquals ( "base1" , aa . getBaseField ( ) ) ; assertEquals ( "ancestor" , aa . abstractMethod ( ) ) ; } } assertTrue ( aFound && d1Found && d2Found ) ; newEntity . getMap ( ) . remove ( TestEnumEntity . FOUR ) ; newEntity . getMap ( ) . put ( TestEnumEntity . SIX , new Descendant2Entity ( "blah" , "blah" , "blah" ) ) ; coll . update ( idQuery ( newEntity ) , Converter . toDBObject ( newEntity ) ) ; newDbObject = coll . findOne ( ) ; newEntity = Converter . toObject ( GenericListEntity . class , newDbObject ) ; assertNotNull ( newEntity ) ; assertNotNull ( newEntity . getMap ( ) ) ; assertEquals ( 2 , newEntity . getMap ( ) . size ( ) ) ; assertTrue ( newEntity . getMap ( ) . get ( TestEnumEntity . SIX ) instanceof Descendant2Entity ) ; Descendant2Entity d2 = ( Descendant2Entity ) newEntity . getMap ( ) . get ( TestEnumEntity . SIX ) ; assertEquals ( "blah" , d2 . getS2 ( ) ) ; assertEquals ( "blah" , d2 . get_id ( ) ) ; assertEquals ( "blah" , d2 . getBaseField ( ) ) ; assertEquals ( "entity2" , d2 . abstractMethod ( ) ) ; assertTrue ( newEntity . getMap ( ) . get ( TestEnumEntity . FIVE ) instanceof Descendant1Entity ) ; Descendant1Entity d1 = ( Descendant1Entity ) newEntity . getMap ( ) . get ( TestEnumEntity . FIVE ) ; assertEquals ( "aaaa" , d1 . getS1 ( ) ) ; assertEquals ( "id2" , d1 . get_id ( ) ) ; assertEquals ( "base2" , d1 . getBaseField ( ) ) ; assertEquals ( "entity1" , d1 . abstractMethod ( ) ) ; }
tr	0	public static String Message_GetUsageCredits ( String THE_MESSAGE ) { return otapiJNI . OTAPI_Basic_Message_GetUsageCredits ( THE_MESSAGE ) ; }
tr	0	@ FuncInfo ( name = "LOG10" , group = "Math Transform" , flags = 0 , nbInput = 1 , nbOptInput = 0 , nbOutput = 1 ) public RetCode log10 ( int startIdx , int endIdx , @ InputParameterInfo ( paramName = "inReal" , flags = 0 , type = InputParameterType . TA_Input_Real ) double inReal [ ] , MInteger outBegIdx , MInteger outNBElement , @ OutputParameterInfo ( paramName = "outReal" , flags = 1 , type = OutputParameterType . TA_Output_Real ) double outReal [ ] ) { return super . log10 ( startIdx , endIdx , inReal , outBegIdx , outNBElement , outReal ) ; }
tr	3	public Object getValueAt ( int rowIndex , int columnIndex ) { SentItem sentItem = sentItems . get ( rowIndex ) ; switch ( columnIndex ) { case 0 : return sentItem . getKontak ( ) . getNama ( ) ; case 1 : return sentItem . getDestinationNumber ( ) ; case 2 : return sentItem . getTextDecoded ( ) ; default : return null ; } }
tr	3	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) . equals ( bShowDatePanel ) ) { if ( popup == null ) { showPopup ( ) ; } else { hidePopup ( ) ; } } else if ( arg0 . getSource ( ) . equals ( datePanel ) ) { hidePopup ( ) ; } }
tr	7	public ComboLock ( Collection < ReadWriteLock > constituentLocks ) { final List < Lock > readLocks = new ArrayList < Lock > ( constituentLocks . size ( ) ) ; final List < Lock > writeLocks = new ArrayList < Lock > ( constituentLocks . size ( ) ) ; for ( ReadWriteLock constituentLock : constituentLocks ) { readLocks . add ( constituentLock . readLock ( ) ) ; writeLocks . add ( constituentLock . writeLock ( ) ) ; } comboReadLock = new Lock ( ) { @ Override public void lock ( ) { for ( Lock readLock : readLocks ) { readLock . lock ( ) ; } } @ Override public void lockInterruptibly ( ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } @ Override public boolean tryLock ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public boolean tryLock ( long time , TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } @ Override public void unlock ( ) { for ( Lock readLock : readLocks ) { readLock . unlock ( ) ; } } @ Override public Condition newCondition ( ) { throw new UnsupportedOperationException ( ) ; } } ; comboWriteLock = new Lock ( ) { @ Override public void lock ( ) { throw new UnsupportedOperationException ( ) ; } @ Override public void lockInterruptibly ( ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } @ Override public boolean tryLock ( ) { boolean acquired = true ; for ( Lock writeLock : writeLocks ) { acquired = writeLock . tryLock ( ) ; if ( ! acquired ) { comboWriteLock_acquireFail . set ( writeLock ) ; break ; } } return acquired ; } @ Override public boolean tryLock ( long time , TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } @ Override public void unlock ( ) { Lock failedLock = comboWriteLock_acquireFail . get ( ) ; for ( Lock writeLock : writeLocks ) { if ( writeLock == failedLock ) { break ; } writeLock . unlock ( ) ; } comboWriteLock_acquireFail . remove ( ) ; } @ Override public Condition newCondition ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
tr	2	public void setStationData ( String call , String locator , String qrzUser , String qrzPass , double lat , double lon , String hamUser , String hamPass ) throws SQLException { Connection con = getDbConnection ( ) ; String query0 = "DELETE FROM SATION_DATA" ; con . prepareCall ( query0 ) . execute ( ) ; String query = "INSERT INTO SATION_DATA (CALL_ID LOCATOR LONGITUDE LATITUDE QRZ_USER QRZ_PASS HAM_USER HAM_PASS) VALUES (? ? ? ? ? ? ? ?)" ; java . sql . PreparedStatement stm = con . prepareStatement ( query ) ; int index = 1 ; stm . setString ( index ++ , call ) ; stm . setString ( index ++ , locator ) ; stm . setDouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setDouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setString ( index ++ , qrzUser ) ; stm . setString ( index ++ , qrzPass ) ; stm . setString ( index ++ , hamUser ) ; stm . setString ( index ++ , hamPass ) ; stm . execute ( ) ; }
tr	6	public MyStoreable ( Table table , List < ? > newValues ) { if ( newValues == null ) { throw new IndexOutOfBoundsException ( "list of values cannot be null" ) ; } if ( newValues . size ( ) != table . getColumnsCount ( ) ) { throw new IndexOutOfBoundsException ( "invalid number of values" ) ; } for ( int i = 0 ; i < newValues . size ( ) ; ++ i ) { Object value = castTypes ( table . getColumnType ( i ) , newValues . get ( i ) ) ; if ( value != null && value . getClass ( ) != table . getColumnType ( i ) ) { throw new ColumnFormatException ( newValues . get ( i ) . toString ( ) + " must be " + table . getColumnType ( i ) + " but it is " + newValues . get ( i ) . getClass ( ) ) ; } types . add ( table . getColumnType ( i ) ) ; values . add ( value ) ; } }
tr	7	private void preencherCampos ( ) { ArrayList < String > telefones ; ArrayList < Premiacao > premiacoes ; jTextFieldAltura . setText ( double . toString ( piloto . getAltura ( ) ) ) ; jTextFieldBairro . setText ( piloto . getEndereco ( ) . getBairro ( ) ) ; jTextFieldCategoriaPeso . setText ( double . toString ( piloto . getPeso ( ) ) ) ; jTextFieldCep . setText ( piloto . getEndereco ( ) . getCep ( ) ) ; jTextFieldCidade . setText ( piloto . getEndereco ( ) . getCidade ( ) ) ; jTextFieldComplemento . setText ( piloto . getEndereco ( ) . getComplemento ( ) ) ; jTextFieldCpf . setText ( piloto . getCpf ( ) ) ; if ( piloto . getDataNascimento ( ) == null ) { jTextFieldDataNascimento . setText ( null ) ; } else { jTextFieldDataNascimento . setText ( dateFormat . format ( piloto . getDataNascimento ( ) ) ) ; } jComboBoxEstado . setSelectedItem ( piloto . getEndereco ( ) . getEstado ( ) ) ; jTextFieldLogradouro . setText ( piloto . getEndereco ( ) . getLogradouro ( ) ) ; jTextFieldNome . setText ( piloto . getNome ( ) ) ; jTextFieldNomeMae . setText ( piloto . getNomeMae ( ) ) ; jTextFieldNomePai . setText ( piloto . getNomePai ( ) ) ; jTextFieldNumero . setText ( piloto . getEndereco ( ) . getNumero ( ) . toString ( ) ) ; jTextFieldPais . setText ( piloto . getEndereco ( ) . getPais ( ) ) ; jTextFieldPeso . setText ( double . toString ( piloto . getPeso ( ) ) ) ; jTextFieldRg . setText ( piloto . getRg ( ) ) ; telefonesListModel . clear ( ) ; telefones = piloto . getTelefones ( ) ; for ( String t : telefones ) { telefonesListModel . addElement ( t ) ; } premiacaoListModel . clear ( ) ; premiacoes = piloto . getPremiacoes ( ) ; for ( Premiacao p : premiacoes ) { premiacaoListModel . addElement ( p ) ; } switch ( piloto . getSexo ( ) ) { case SEXO_MASCULINO_VALOR : jComboBoxSexo . setSelectedIndex ( SEXO_MASCULINO_INDICE ) ; break ; case SEXO_FEMININO_VALOR : jComboBoxSexo . setSelectedIndex ( SEXO_FEMININO_INDICE ) ; break ; } switch ( piloto . getCategoria ( ) ) { case CATEGORIA_AMADOR_VALOR : jComboBoxCategoria . setSelectedIndex ( CATEGORIA_AMADOR_INDICE ) ; break ; case CATEGORIA_PROFISSIONAL_VALOR : jComboBoxCategoria . setSelectedIndex ( CATEGORIA_PROFISSIONAL_INDICE ) ; break ; } this . atualizarCategoriaPeso ( ) ; }
tr	6	public String nextTo ( String delimiters ) { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	4	public final BlockContext block ( ) throws RecognitionException { BlockContext _localctx = new BlockContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 10 , RULE_block ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 94 ) ; match ( { ) ; setState ( 98 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( _la == TIPO ) { { { setState ( 95 ) ; var_decl ( ) ; } } setState ( 100 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 104 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( ( ( ( _la ) & ~ 3f ) == 0 && ( ( 1 << _la ) & ( ( 1 << if ) | ( 1 << for ) | ( 1 << return ) | ( 1 << break ) | ( 1 << continue ) | ( 1 << CALLOUT ) | ( 1 << { ) | ( 1 << ID ) ) ) != 0 ) ) { { { setState ( 101 ) ; statement ( ) ; } } setState ( 106 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 107 ) ; match ( } ) ; linea ++ ; arbol . add ( "Bloque " + linea ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	9	long parseKeys ( ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( mTraceFileName ) , "US-ASCII" ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( ex . getMessage ( ) ) ; } long offset = 0 ; int mode = PARSE_VERSION ; String line = null ; while ( true ) { line = in . readLine ( ) ; if ( line == null ) { throw new IOException ( "Key section does not have an *end marker" ) ; } offset += line . length ( ) + 1 ; if ( line . startsWith ( "*" ) ) { if ( line . equals ( "*version" ) ) { mode = PARSE_VERSION ; continue ; } if ( line . equals ( "*threads" ) ) { mode = PARSE_THREADS ; continue ; } if ( line . equals ( "*methods" ) ) { mode = PARSE_METHODS ; continue ; } if ( line . equals ( "*end" ) ) { break ; } } switch ( mode ) { case PARSE_VERSION : mVersionNumber = Integer . decode ( line ) ; mode = PARSE_OPTIONS ; break ; case PARSE_THREADS : parseThread ( line ) ; break ; case PARSE_METHODS : parseMethod ( line ) ; break ; case PARSE_OPTIONS : parseOption ( line ) ; break ; } } if ( mClockSource == null ) { mClockSource = ClockSource . THREAD_CPU ; } return offset ; }
tr	7	public void run ( ) { final String methodName = "run" ; MqttWireMessage message = null ; while ( running && ( out != null ) ) { try { message = clientState . get ( ) ; if ( message != null ) { log . fine ( className , methodName , "802" , new Object [ ] { message . getKey ( ) , message } ) ; if ( message instanceof MqttAck ) { out . write ( message ) ; out . flush ( ) ; } else { MqttToken token = tokenStore . getToken ( message ) ; if ( token != null ) { synchronized ( token ) { out . write ( message ) ; out . flush ( ) ; clientState . notifySent ( message ) ; } } } } else { log . fine ( className , methodName , "803" ) ; running = false ; } } catch ( MqttException me ) { handleRunException ( message , me ) ; } catch ( Exception ex ) { handleRunException ( message , ex ) ; } } log . fine ( className , methodName , "805" ) ; }
tr	0	public String getDLDateOfBirth ( ) { return dlDateOfBirth ; }
tr	7	public boolean equals ( Object obj ) { if ( obj == null || getClass ( ) != obj . getClass ( ) ) return false ; Note other = ( Note ) obj ; if ( endTime != other . endTime ) return false ; if ( ! pitch . equals ( other . pitch ) ) return false ; if ( startTime != other . startTime ) return false ; if ( ! track . equals ( other . track ) ) return false ; if ( velocity != other . velocity ) return false ; return true ; }
tr	9	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; v_1 = cursor ; lab0 : do { if ( ! r_prelude ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { if ( ! r_mark_regions ( ) ) { break lab1 ; } } while ( false ) ; cursor = v_2 ; limit_backward = cursor ; cursor = limit ; v_3 = limit - cursor ; lab2 : do { if ( ! r_attached_pronoun ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; v_4 = limit - cursor ; lab3 : do { lab4 : do { v_5 = limit - cursor ; lab5 : do { if ( ! r_standard_suffix ( ) ) { break lab5 ; } break lab4 ; } while ( false ) ; cursor = limit - v_5 ; if ( ! r_verb_suffix ( ) ) { break lab3 ; } } while ( false ) ; } while ( false ) ; cursor = limit - v_4 ; v_6 = limit - cursor ; lab6 : do { if ( ! r_vowel_suffix ( ) ) { break lab6 ; } } while ( false ) ; cursor = limit - v_6 ; cursor = limit_backward ; v_7 = cursor ; lab7 : do { if ( ! r_postlude ( ) ) { break lab7 ; } } while ( false ) ; cursor = v_7 ; return true ; }
tr	2	public void insertAtEnd ( int element ) { SNode newNode = new SNode ( ) ; newNode . data = element ; if ( HEADER == null ) { HEADER = newNode ; newNode . next = HEADER ; } else { SNode current = HEADER ; while ( current . next != HEADER ) current = current . next ; current . next = newNode ; newNode . next = HEADER ; } }
tr	1	public boolean hasArgName ( ) { return argName != null && argName . length ( ) > 0 ; }
tr	8	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . ipAddress != null ) { sb . append ( prefix ) . append ( "ipAddress=" ) . append ( NVPUtil . encodeUrl ( this . ipAddress ) ) ; sb . append ( "&" ) ; } if ( this . deviceId != null ) { sb . append ( prefix ) . append ( "deviceId=" ) . append ( NVPUtil . encodeUrl ( this . deviceId ) ) ; sb . append ( "&" ) ; } if ( this . applicationId != null ) { sb . append ( prefix ) . append ( "applicationId=" ) . append ( NVPUtil . encodeUrl ( this . applicationId ) ) ; sb . append ( "&" ) ; } if ( this . model != null ) { sb . append ( prefix ) . append ( "model=" ) . append ( NVPUtil . encodeUrl ( this . model ) ) ; sb . append ( "&" ) ; } if ( this . geoLocation != null ) { sb . append ( prefix ) . append ( "geoLocation=" ) . append ( NVPUtil . encodeUrl ( this . geoLocation ) ) ; sb . append ( "&" ) ; } if ( this . customerType != null ) { sb . append ( prefix ) . append ( "customerType=" ) . append ( NVPUtil . encodeUrl ( this . customerType ) ) ; sb . append ( "&" ) ; } if ( this . partnerName != null ) { sb . append ( prefix ) . append ( "partnerName=" ) . append ( NVPUtil . encodeUrl ( this . partnerName ) ) ; sb . append ( "&" ) ; } if ( this . customerId != null ) { sb . append ( prefix ) . append ( "customerId=" ) . append ( NVPUtil . encodeUrl ( this . customerId ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	7	public static String extractTitleFrom ( String filePath ) { String title = null ; try { Mp3File mp3File = new Mp3File ( filePath ) ; if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; title = id3v2Tag . getTitle ( ) ; } else if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; title = id3v1Tag . getTitle ( ) ; } } catch ( UnsupportedTagException e ) { e . printStackTrace ( ) ; } catch ( InvalidDataException e ) { System . out . print ( "Invalid Data" ) ; return " - Unknown Title" ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( title == null ) { int lastSlash = filePath . lastIndexOf ( \ ) ; if ( filePath . lastIndexOf ( / ) > lastSlash ) lastSlash = filePath . lastIndexOf ( / ) ; title = filePath . substring ( lastSlash + 1 ) . replaceAll ( "\\.mp3$" , "" ) ; } return title ; }
tr	1	public ActionDialog ( SkyQuestUtility util , JComponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new JButton ( "Save" ) ; cancel = new JButton ( "Cancel" ) ; amodel = new DefaultListModel < ActionType > ( ) ; atypes = new JList < ActionType > ( amodel ) ; for ( ActionType a : QuestManager . getInstance ( ) . getRegisteredActionTypes ( ) ) amodel . addElement ( a ) ; setLayout ( new BorderLayout ( ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; JPanel ap = new JPanel ( ) ; ap . setLayout ( new BorderLayout ( ) ) ; ap . add ( "Center" , atypes ) ; ap . add ( "North" , new JLabel ( "Type" ) ) ; add ( "South" , buttons ) ; cancel . addActionListener ( this ) ; save . addActionListener ( this ) ; }
tr	9	private int getPlayerSize ( int index ) { int iPlayerFactorIndex = 0 ; if ( index == 0 ) iPlayerFactorIndex = getRegister ( NUSIZ0 ) & 07 ; else if ( index == 1 ) iPlayerFactorIndex = getRegister ( NUSIZ1 ) & 07 ; else return 1 ; switch ( iPlayerFactorIndex ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 6 : return PLAYER_SINGLE_SIZE ; case 5 : return PLAYER_DOUBLE_SIZE ; case 7 : return PLAYER_QUAD_SIZE ; } return 1 ; }
tr	0	@ JsonProperty ( "Owner" ) public String getOwner ( ) { return Owner ; }
tr	1	@ Override public int compareTo ( Correo c ) { String remitente = c . getRemitente ( ) ; Date fecha = c . getFecha ( ) ; if ( this . remitente . equalsIgnoreCase ( remitente ) ) return this . fecha . compareTo ( fecha ) ; else return this . remitente . compareToIgnoreCase ( remitente ) ; }
tr	6	public static void searchHosts ( final int port , final ProgressListener listener ) { new Thread ( ) { @ Override public void run ( ) { boolean cancel = false ; try { String baseHost = Network . getAddress ( ) . substring ( 0 , Network . getAddress ( ) . lastIndexOf ( "." ) + 1 ) ; for ( int i = 1 ; i < 254 && ! cancel ; i ++ ) { int p = ( int ) ( ( i / 254.0 ) * 100 ) ; if ( InetAddress . getByName ( baseHost + i ) . isReachable ( 1500 ) ) { if ( ! listener . percentChanged ( p , baseHost + i ) ) cancel = true ; } else { if ( ! listener . percentChanged ( p ) ) cancel = true ; } } } catch ( Exception e ) { Logger . get ( ) . err ( e , this ) ; } finally { listener . progressDone ( ! cancel , this ) ; } } } . start ( ) ; }
tr	8	public List < DimensionWrapper > getDimensionHierarchy ( String indicatorName , String keyFamilyId ) { if ( hierarchicalCodelists == null || hierarchicalCodelists . size ( ) <= 0 ) { return null ; } Dimension indDim = getIndicatorOrDataElementDimension ( keyFamilyId ) ; CodeList codelist = getCodeList ( indDim . getCodelistRef ( ) ) ; Code code = codelist . getCodeByDescription ( indicatorName ) ; if ( code == null ) { return null ; } HierarchicalCodelist hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES ) ; if ( hierarchicalCodelist == null ) { hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES_BACKWARDS_COMPATIBLE ) ; } Hierarchy hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY ) ; if ( hierarchy == null ) { hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY_BACKWARDS_COMPATIBLE ) ; if ( hierarchy == null ) { return null ; } } CodeRef codeRef = hierarchy . findCodeRef ( hierarchicalCodelist . getCodeListAlias ( indDim . getCodelistRef ( ) ) , code . getValue ( ) ) ; if ( codeRef == null ) { return null ; } List < DimensionWrapper > dimensionHierarchy ; if ( codeRef != null ) { dimensionHierarchy = constructDimensionHierarchy ( codeRef ) ; } else { dimensionHierarchy = new ArrayList < DimensionWrapper > ( ) ; } return dimensionHierarchy ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new RelVendasPorVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	4	private static HttpURLConnection getConnectionFromAPI ( MethodMap methodMap , ArgMap argMap ) throws URISyntaxException , IOException , OpenStatesException { HttpURLConnection con = null ; StringBuilder method = new StringBuilder ( "/" ) ; for ( String key : methodMap ) { method . append ( key ) ; method . append ( / ) ; } StringBuilder terms = new StringBuilder ( ) ; if ( argMap != null ) { for ( String key : argMap . keySet ( ) ) { String value = argMap . get ( key ) ; if ( value == null ) continue ; terms . append ( & ) ; terms . append ( key ) ; terms . append ( = ) ; terms . append ( value ) ; } } URI uri = new URI ( "http" , null , apiServer , - 1 , method . toString ( ) , "apikey=" + apiKey + terms . toString ( ) , null ) ; logger . fine ( uri . toString ( ) ) ; con = ( HttpURLConnection ) uri . toURL ( ) . openConnection ( ) ; con . setRequestMethod ( "GET" ) ; con . setRequestProperty ( "Accept" , "text/json  application/json" ) ; con . connect ( ) ; return con ; }
tr	8	@ Override public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { if ( value . getClass ( ) . getName ( ) . contains ( "PageNames" ) ) { ( ( PageNames ) value ) . setPageName ( ( String ) selectBox . getSelectedItem ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "PictureNames" ) ) { ( ( PictureNames ) value ) . setSelectedPictureIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "SoundNames" ) ) { ( ( SoundNames ) value ) . setSelectedSoundIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ButtonFunctionType" ) ) { ( ( ButtonFunctionType ) value ) . setButtonFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ValueFormatType" ) ) { ( ( ValueFormatType ) value ) . setValueFormat ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedFunctionType" ) ) { ( ( LedFunctionType ) value ) . setLedFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedVisibleType" ) ) { ( ( LedVisibleType ) value ) . setLedVisible ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } } }
