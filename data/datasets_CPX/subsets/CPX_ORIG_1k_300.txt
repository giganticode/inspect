tr	4	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	1	public void renderLow ( Parameters params ) { if ( renderer == null ) { throw new IllegalStateException ( "renderer not set" ) ; } image = newImage ( ) ; showImage ( image ) ; int width = image . getWidth ( null ) ; int height = image . getHeight ( null ) ; params . adjustAspect ( width , height ) ; setParameters ( params ) ; imageComponent . setCursor ( waitCursor ) ; renderThread = new Thread ( new RenderRunner ( image , params , renderer ) ) ; renderThread . start ( ) ; }
tr	1	private int insert ( final BeanMissatge bean ) { String SQL1 = "INSERT INTO sig_missatgeria (idEntrevista destinatari idMateria materia actitud notes feina comentaris dataContestat idMensajeProfesor) " + " VALUES(? ? ? ? ? ? ? ? ? ?)" ; Object [ ] objs = new Object [ ] { bean . idEntrevista , bean . destinatari_abrev , bean . idMateria , bean . materia , bean . actitud , bean . notes , bean . feina , bean . comentari , bean . dataContestat , bean . idMensajeProfesor } ; int nup = client . getMysql ( ) . preparedUpdateID ( SQL1 , objs ) ; if ( nup > 0 ) { bean . setId ( nup ) ; } return nup ; }
tr	3	@ Override public int storeProject ( String name , String description ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newProjectId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (name  description)" ) . append ( " VALUES " ) . append ( "('" + name + "'  '" + description + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newProjectId = rs . getInt ( 1 ) ; } rs . getStatement ( ) . close ( ) ; rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newProjectId ; }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	8	public static void release ( Object ... releasables ) { for ( Object obj : releasables ) { if ( obj != null ) { try { if ( obj instanceof ServerSocket ) { ( ( ServerSocket ) obj ) . close ( ) ; } else if ( obj instanceof Socket ) { ( ( Socket ) obj ) . close ( ) ; } else if ( obj instanceof Process ) { ( ( Process ) obj ) . destroy ( ) ; } else if ( obj instanceof Closeable ) { ( ( Closeable ) obj ) . close ( ) ; } else { throw new IllegalArgumentException ( "This method does not not how to release objects of type " + obj . getClass ( ) ) ; } } catch ( IOException ex ) { } catch ( RuntimeException ex ) { } } } }
tr	7	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	7	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	9X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	1	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
tr	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
tr	3	public int getPort ( ) { String num = getString ( "Port" ) ; if ( num == null || num . equals ( "" ) ) { return DEFAULT_PORT ; } try { return Integer . parseInt ( num , 10 ) ; } catch ( NumberFormatException ex ) { logger . warning ( "Bad value for listening port (" + num + ")" ) ; throw new IllegalStateException ( "Bad value for listening port (" + num + ")" , ex ) ; } }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	5	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	0	public String getMateria ( ) { return materia ; }
tr	5	@ Override public int hashCode ( ) { int result = iduser ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( lastName != null ? lastName . hashCode ( ) : 0 ) ; result = 31 * result + ( email != null ? email . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( activateKey != null ? activateKey . hashCode ( ) : 0 ) ; return result ; }
tr	4	@ Override public void processDrawing ( ) { if ( rsAlreadyLoaded || loadingError || genericLoadingError ) { showErrorScreen ( ) ; return ; } drawCycle ++ ; if ( ! loggedIn ) drawLoginScreen ( false ) ; else drawGameScreen ( ) ; anInt1213 = 0 ; }
tr	3	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	9X	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	7	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	3	public void add ( T item ) { Node node = new Node ( item ) ; if ( current == null ) { node . next = head ; node . prev = null ; if ( head != null ) head . prev = node ; head = node ; } else { node . next = current . next ; node . prev = current ; if ( current . next != null ) current . next . prev = node ; current . next = node ; } ++ idx ; current = node ; ++ size ; }
tr	6	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new BSTNode ( data ) ; return ; } BSTNode currentNode = overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new BSTNode ( data ) ; return ; } currentNode = currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new BSTNode ( data ) ; return ; } currentNode = currentNode . right ; } } }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	5	public static void main ( String [ ] args ) { r1 = new Thread ( ) { public void run ( ) { while ( i < 100 ) { if ( i % 10 == 0 ) { if ( r2 . isAlive ( ) ) r2 . notify ( ) ; else r2 . run ( ) ; } i ++ ; } r1 . interrupt ( ) ; r2 . interrupt ( ) ; } } ; r2 = new Thread ( ) { public void run ( ) { System . out . println ( i ) ; try { if ( r2 . isAlive ( ) ) { r2 . wait ( ) ; r1 . notify ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; r1 . run ( ) ; }
tr	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
tr	2	public void update ( ) { super . update ( ) ; if ( this . isClicked ( ) && ( Timer . getTime ( ) - this . lastClick ) > 200 ) { this . state = ! this . state ; this . lastClick = Timer . getTime ( ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new RelVendasPorVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	5	public boolean getRGBPixels ( int x , int y , int width , int height , int [ ] pixels ) { if ( getRGBPixelsMethod != null ) try { if ( getRGBPixelsMethodType == 0 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 1 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { new Rectangle ( x , y , width , height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 2 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , new Rectangle ( x , y , width , height ) , pixels } ) ; else getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; return true ; } catch ( Exception ex ) { } int [ ] tmp = getRGBPixels ( new Rectangle ( x , y , width , height ) ) ; System . arraycopy ( tmp , 0 , pixels , 0 , width * height ) ; return false ; }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	3	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPath ) return this . equals ( ( ASPath ) o ) ; return false ; }
tr	5	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	9X	@ Override public void actionPerformed ( ActionEvent ae ) { if ( ae . getActionCommand ( ) . compareTo ( "comboBoxChanged" ) == 0 ) { if ( ae . getSource ( ) == combo_url ) { loadUrlData ( ) ; } else if ( ae . getSource ( ) == combo_grantType ) { if ( combo_grantType . getSelectedIndex ( ) == AUTHORIZATION_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . AUTHORIZATION_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == PASSWORD_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . PASWORD_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == CLIENT_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) ; setupPanels ( ) ; } } } else if ( ae . getActionCommand ( ) . compareTo ( ABOUT_MENUITEM ) == 0 ) { JOptionPane . showMessageDialog ( applicationFrame , "OAuthTestClient\nAn OAuth 2.0 Test Application\nWritten by Ronnie Mitra.\n\nhttps://github.com/mitraman/OAuthTestClient    \n\n" , "About OAuthTestClient" , JOptionPane . QUESTION_MESSAGE ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SETTINGS_MENUITEM ) == 0 ) { SettingsDialog settingsDialog = new SettingsDialog ( applicationFrame ) ; settingsDialog . setVisible ( true ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SAVE_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( "./OAuthTestClient.cfg" ) ; if ( fileChooser . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . saveProperties ( file ) ; } } else if ( ae . getActionCommand ( ) . compareTo ( LOAD_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( ) ; if ( fileChooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . loadProperties ( file ) ; } } else { System . out . println ( ae . getActionCommand ( ) + " " + ae . getID ( ) ) ; } }
tr	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
tr	4	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	1	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new Application ( ) ) ; app . setDisplayMode ( SCREEN_WIDTH , SCREEN_HEIGHT , false ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	7	public static String extractTitleFrom ( String filePath ) { String title = null ; try { Mp3File mp3File = new Mp3File ( filePath ) ; if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; title = id3v2Tag . getTitle ( ) ; } else if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; title = id3v1Tag . getTitle ( ) ; } } catch ( UnsupportedTagException e ) { e . printStackTrace ( ) ; } catch ( InvalidDataException e ) { System . out . print ( "Invalid Data" ) ; return " - Unknown Title" ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( title == null ) { int lastSlash = filePath . lastIndexOf ( \ ) ; if ( filePath . lastIndexOf ( / ) > lastSlash ) lastSlash = filePath . lastIndexOf ( / ) ; title = filePath . substring ( lastSlash + 1 ) . replaceAll ( "\\.mp3$" , "" ) ; } return title ; }
tr	7	@ Override protected void handleMethodAttribute ( final String name , final byte [ ] data , final int offset , final long length , final ConstantPool constantPool ) { if ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Signature . equals ( name ) ) { parseSignature ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Deprecated . equals ( name ) ) { parseDeprecated ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_Synthetic . equals ( name ) ) { parseSynthetic ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Exceptions . equals ( name ) ) { parseExceptions ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Code . equals ( name ) ) { parseCode ( data , offset , constantPool ) ; } else { System . err . println ( "Unhandled method attribute: " + name ) ; } }
tr	6	public int [ ] getActions ( Game game , long timeDue ) { int pacmanLoc = game . getCurPacManLoc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostRequiresAction ( i ) ) { if ( isCrowded ( game ) && ! closeToMsPacMan ( game , game . getCurGhostLoc ( i ) ) ) dirs [ i ] = getRetreatActions ( game , i ) ; else if ( game . getEdibleTime ( i ) > 0 || closeToPower ( game ) ) dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , false , Game . DM . PATH ) ; else dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , true , Game . DM . PATH ) ; } } return dirs ; }
tr	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	9X	public int getConfig ( int uid , int x , int y , int z ) { Ground tile = groundArray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallObject != null && tile . wallObject . uid == uid ) return tile . wallObject . objConf & ff ; if ( tile . wallDecoration != null && tile . wallDecoration . uid == uid ) return tile . wallDecoration . objConf & ff ; if ( tile . groundDecoration != null && tile . groundDecoration . uid == uid ) return tile . groundDecoration . objConf & ff ; for ( int e = 0 ; e < tile . entityCount ; e ++ ) if ( tile . interactiveObjects [ e ] . uid == uid ) return tile . interactiveObjects [ e ] . objConf & ff ; return - 1 ; }
tr	4	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	9X	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	7	private String getMPatternCode ( ) { int posIni = _position ; for ( ; ; ) { if ( _mumpsPattern . length ( ) <= _position ) { break ; } if ( isQuantifier ( _mumpsPattern . charAt ( _position ) ) || ( _mumpsPattern . charAt ( _position ) == ( ) || ( _mumpsPattern . charAt ( _position ) ==   ) || ( _mumpsPattern . charAt ( _position ) == ) ) ) { break ; } if ( ! patternAtomTranslateTable . containsKey ( _mumpsPattern . charAt ( _position ) ) ) { throw new IllegalArgumentException ( "Code Pattern inv\u00E1lido encontrado: " . concat ( _mumpsPattern . substring ( _position , _position + 1 ) ) . concat ( ". Na posi\u00E7\u00E3o: " . concat ( String . valueOf ( _position ) ) ) ) ; } _position ++ ; } return _mumpsPattern . substring ( posIni , _position ) ; }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	6	public void doService ( ) { Message message = parser . nextMessage ( ) ; while ( message != null ) { switch ( message . getType ( ) ) { case CONNECT : writer . println ( "ALREADY CONNECTED!" ) ; writer . flush ( ) ; break ; case DISCONNECT : server . broadcaster . remove ( connection ) ; break ; case TEXTMSG_CLIENT : broadcastMessage ( message ) ; break ; case IMAGE_CLIENT : server . setImage ( ImageUtils . decodeImage ( message . getMatcher ( ) . group ( 1 ) ) ) ; broadcastMessage ( message ) ; break ; default : AbstractTool tool = AbstractTool . getTool ( message . getType ( ) ) ; if ( tool != null ) { server . updateImage ( tool , message ) ; broadcastMessage ( message ) ; } break ; } message = parser . nextMessage ( ) ; } }
tr	5	public boolean move ( Direction direction , StringBuffer output ) throws EndGameException { boolean hasMoved = false ; if ( myPosition . isCrossable ( direction ) ) { if ( myPosition . hasCharacter ( direction ) ) { Character defender = myPosition . getCharacter ( direction ) ; if ( attack ( defender ) ) { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You attacked and killed " + defender + ". You moved " + direction ) ; hasMoved = true ; } else { if ( isDead ( ) ) throw new EndGameException ( "Player has died. GAME OVER!" ) ; output . append ( "You attacked: \n" + defender . toString ( ) + "\n" + this . toString ( ) ) ; } } else { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You moved " + direction + "." ) ; hasMoved = true ; } } else { output . append ( checkIfLockedExit ( direction ) ) ; } if ( hasMoved ) { notifyPositionChanged ( direction . getOppositeDirection ( ) ) ; } return hasMoved ; }
tr	6	protected Shape createTriangle ( float fx , float fy , float tx , float ty , boolean rot ) { int size = 15 ; float dx = tx - fx ; float dy = ty - fy ; float D = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float z = ( dx <= 0 ) ? fx - D : fx + D ; float mid = ( dx <= 0 ) ? fx - D / 2 : fx + D / 2 ; float dec = ( dx <= 0 ) ? size : - size ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy + size / 2 ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; if ( rot ) { gp . moveTo ( mid + dec , fy - size / 2 ) ; gp . curveTo ( mid , fy - size , mid , fy + size , mid + dec , fy + size / 2 ) ; } double alpha = ( dx > 0 ) ? Math . asin ( dy / D ) : - Math . asin ( dy / D ) ; return alpha != 0 ? gp . createTransformedShape ( AffineTransform . getRotateInstance ( alpha , fx , fy ) ) : gp ; }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	5	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
tr	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	5	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	8	public static Mineral find ( int remoteId ) { switch ( remoteId ) { case 34 : return Tritanium ; case 35 : return Pyerite ; case 36 : return Mexallon ; case 37 : return Isogen ; case 38 : return Nocxium ; case 39 : return Zydrine ; case 40 : return Megacyte ; case 11399 : return Morphite ; default : { throw new RuntimeException ( "Id does not represent mineral" ) ; } } }
tr	7	public synchronized void tick ( ) { handleEvents ( ) ; updateWorkers ( ) ; for ( Sponsor sponsor : new ArrayList < Sponsor > ( sponsors ) ) { if ( sponsor . getMSLeft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } Random r = new Random ( ) ; if ( sponsors . size ( ) < MAX_SPONSORS && r . nextInt ( ( int ) ( 1500 / Math . log ( getRenown ( ) + 2 ) ) ) == 0 ) { addSponsor ( ) ; } if ( getRenown ( ) <= 0 ) { showWindow ( null , new GameOverWindow ( ) ) ; } if ( r . nextInt ( DIFFICULTY ) == 0 ) { setRenown ( getRenown ( ) - 1 ) ; } if ( firstTick ) showWindow ( null , new HelpWindow ( ) ) ; firstTick = false ; }
tr	3	public int maximum ( Node root ) { int root_val , left_val , right_val , max = Integer . MIN_VALUE ; if ( root != null ) { root_val = root . key ; left_val = maximum ( root . left ) ; right_val = maximum ( root . right ) ; if ( left_val > right_val ) max = left_val ; else max = - right_val ; if ( root_val > max ) max = root_val ; } return max ; }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
tr	9X	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	3	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	9X	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	7	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	2	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	9X	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	9X	String formatOption ( OptionMetadata metadata , CommandLineConfiguration config ) { String formattedOption = null ; if ( metadata . isParameterAccepted ( ) ) { boolean isParamRequired = ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . isRequired ( ) ) ; String paramDelim = StringUtil . formatDelimValue ( config . getCommandLineProperties ( ) . getOptionParameterDelim ( ) ) ; String paramUsageStr = "" ; if ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . getParameterType ( ) != ParameterType . NONE ) { String paramName = "" ; if ( metadata . getParameterMetadata ( ) . getParameterType ( ) == ParameterType . CUSTOM ) { paramName = metadata . getParameterMetadata ( ) . getIdentifier ( ) ; } else { paramName = metadata . getParameterMetadata ( ) . getParameterType ( ) . name ( ) ; } paramUsageStr = String . format ( ( isParamRequired ) ? "%s<%s>" : "[%s<%s>]" , paramDelim , paramName ) ; if ( metadata . isMultiValued ( ) ) { paramUsageStr += "..." ; } } String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) , paramUsageStr ) ; } else { formattedOption = String . format ( "%s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , paramUsageStr ) ; } } else { String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) ) ; } else { formattedOption = String . format ( "%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) ) ; } } return formattedOption ; }
tr	3	public void switchFullscreen ( ) { if ( fullscreen == false ) { throw new IllegalStateException ( "This window not supports fullscreen mode!" ) ; } if ( state == WindowState . WINDOW ) { Rectangle rc = this . getBounds ( ) ; boolean resizable = this . isResizable ( ) ; this . properties = new FrameProperties ( getX ( ) , getY ( ) , ( int ) rc . getWidth ( ) , ( int ) rc . getHeight ( ) , resizable ) ; } if ( device . getFullScreenWindow ( ) == null ) { FrameProperties properties = new FrameProperties ( 0 , 0 , getFullWidth ( ) , getFullHeight ( ) , false ) ; this . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; this . state = WindowState . FULLSCREEN ; properties . append ( this ) ; device . setFullScreenWindow ( this ) ; updateDisplay ( ) ; return ; } device . setFullScreenWindow ( null ) ; this . setExtendedState ( JFrame . NORMAL ) ; this . state = WindowState . WINDOW ; properties . append ( this ) ; updateDisplay ( ) ; }
tr	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( declaration == null ) ? 0 : declaration . hashCode ( ) ) ; result = prime * result + ( ( ident == null ) ? 0 : ident . hashCode ( ) ) ; result = prime * result + ( ( statementSequence == null ) ? 0 : statementSequence . hashCode ( ) ) ; return result ; }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } tring data = tring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	5	@ Override public String toString ( ) { switch ( this ) { case uneEtoile : return "\u2605" ; case deuxEtoiles : return "\u2605\u2605" ; case troisEtoiles : return "\u2605\u2605\u2605" ; case quatreEtoiles : return "\u2605\u2605\u2605\u2605" ; case cinqEtoiles : return "\u2605\u2605\u2605\u2605\u2605" ; } return null ; }
tr	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	2	private boolean isValidUserInput ( final String hostname , final String port ) { final String methodName = "isValidUserInput" ; ControllerLogger . entering ( CLASS_NAME , methodName , hostname , port ) ; try { if ( GUIUtils . isEmptyValue ( hostname ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_HOSTNAME_MESSAGE ) ; return false ; } if ( ! GUIUtils . isPortNumberValid ( port ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_PORT_NUMBER_MESSAGE ) ; return false ; } return true ; } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	4	public static boolean intersects ( final IShape shape1 , final Vector3f vertex ) { simplex . clear ( ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , vertex , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS ) { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , vertex , v ) ; if ( v . . ( e . v ) > 0 ) { return false ; } if ( simplex . contains ( e . v ) ) break ; simplex . addElement ( ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } return true ; }
tr	5	public static Pair < Integer , Integer > linearCongruence ( int a , int b , final int n ) { positiveCheck ( n ) ; a = normalizeIntModulo ( a , n ) ; b = normalizeIntModulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new Pair < > ( 0 , 1 ) ; final int numberOfSolutions = gcd ( a , n ) ; if ( b % numberOfSolutions != 0 ) return new Pair < > ( ) ; int bezoutCoefficientA ; if ( a > n ) bezoutCoefficientA = bezout ( a , n ) . get ( 1 ) ; else bezoutCoefficientA = bezout ( n , a ) . get ( 2 ) ; final int shiftedModulus = n / numberOfSolutions ; int x = ( bezoutCoefficientA * b ) / numberOfSolutions ; x = normalizeIntModulo ( x , shiftedModulus ) ; return new Pair < > ( x , shiftedModulus ) ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ComplexNumber that = ( ComplexNumber ) o ; if ( double . compare ( that . im , im ) != 0 ) return false ; if ( double . compare ( that . re , re ) != 0 ) return false ; return true ; }
tr	7	public List < CodeList > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < CodeList > codeLists = new ArrayList < CodeList > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeList" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { CodeList cl = processCodeList ( se , eventReader ) ; codeLists . add ( cl ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeLists" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { endTagReached = true ; } break ; } } return codeLists ; }
tr	9X	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
