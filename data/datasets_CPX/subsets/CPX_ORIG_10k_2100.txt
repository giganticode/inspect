tr	6	public TokenizerProperty startsWithSequenceCommentOrString ( DataProvider dataProvider ) throws TokenizerException , NullPointerException { if ( dataProvider . getLength ( ) > 0 ) { int len = dataProvider . getLength ( ) ; char startChar = getStartChar ( dataProvider . getCharAt ( 0 ) ) ; PropertyList list = getList ( startChar ) ; while ( list != null ) { TokenizerProperty prop = list . _property ; String image = prop . getImages ( ) [ 0 ] ; int imageLen = image . length ( ) ; if ( _useExactLength && imageLen < len ) { break ; } else if ( imageLen <= len && comparePrefix ( image , dataProvider , 1 ) == 0 ) { return prop ; } list = list . _next ; } } return null ; }
tr	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
tr	4	public static boolean canWriteLetterFromMagazine5 ( String letter , String magazine ) { int [ ] magazineCharCounts = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { magazineCharCounts [ i ] = 0 ; } char [ ] letterCharArray = letter . toCharArray ( ) ; char [ ] magazineCharArray = magazine . toCharArray ( ) ; for ( int i = 0 ; i < magazineCharArray . length ; i ++ ) { char chr = magazineCharArray [ i ] ; magazineCharCounts [ chr - a ] ++ ; } for ( int i = 0 ; i < letterCharArray . length ; i ++ ) { char chr = letterCharArray [ i ] ; if ( -- magazineCharCounts [ chr - a ] < 0 ) return false ; } return true ; }
tr	7	public void setSelectedOC ( OutputConnector selectedOC , Component comp ) { if ( this . selectedOC != null ) this . selectedOC . setSelected ( true ) ; this . selectedOC = selectedOC ; this . selectedOC . setSelected ( true ) ; connectables = new ArrayList < InputConnector > ( ) ; for ( Component e : getElements ( ) ) { if ( e == comp ) continue ; if ( e instanceof InputStub ) continue ; for ( Connector c : e . getConnectors ( ) ) { if ( c instanceof InputConnector ) if ( ! ( ( InputConnector ) c ) . isConnected ( ) ) connectables . add ( ( InputConnector ) c ) ; } } }
tr	0	public DashedVerticalLine dashedVerticalLineInstance ( ) { LineObject lineObject = new LineObject ( ) ; DashedVerticalLine dashedVerticalLine = lineObject . dashedVerticalLineInstance ( ) ; objectsInstance ( ) . add ( lineObject ) ; return dashedVerticalLine ; }
tr	6	public static boolean setupTables ( ) throws SQLException { boolean retVal = false ; if ( ! ( dbm . isTable ( "titles" ) || dbm . isTable ( "players" ) ) ) { try { dbm . query ( "CREATE TABLE IF NOT EXISTS titles (titleid VARCHAR(20) PRIMARY KEY  titlename VARCHAR(20));" ) ; dbm . query ( "CREATE TABLE IF NOT EXISTS players (playerid Integer PRIMARY KEY AUTO_INCREMENT  playername VARCHAR(20)  titleid VARCHAR(20));" ) ; dbm . query ( "ALTER TABLE players ADD CONSTRAINT FK_TITLES_ID FOREIGN KEY (titleid) REFERENCES titles(titleid);" ) ; retVal = true ; } catch ( SQLException ex ) { dbm . writeError ( "Error creating tables for DonorTitles database.\n" + ex . getMessage ( ) , true ) ; ex . printStackTrace ( ) ; try { if ( dbm . isTable ( "titles" ) ) { dbm . query ( "DROP TABLE titles;" ) ; } if ( dbm . isTable ( "players" ) ) { dbm . query ( "DROP TABLE players;" ) ; } } catch ( SQLException exs ) { throw new SQLException ( "Error dropping tables." , exs ) ; } } } return retVal ; }
tr	7	public static BufferedImage getImage ( Card card ) { int rowNumber ; int colNumber ; if ( card . getSuit ( ) . equals ( Suit . CLUBS ) ) { rowNumber = 0 ; } else if ( card . getSuit ( ) . equals ( Suit . DIAMONDS ) ) { rowNumber = 1 ; } else if ( card . getSuit ( ) . equals ( Suit . HEARTS ) ) { rowNumber = 2 ; } else if ( card . getSuit ( ) . equals ( Suit . SPADES ) ) { rowNumber = 3 ; } else { rowNumber = 4 ; } if ( card . getCardValue ( ) . equals ( CardValue . ACE ) ) { colNumber = 0 ; } else if ( card . getCardValue ( ) . equals ( CardValue . JOKER ) ) { if ( card . getSuit ( ) . equals ( Suit . BLACK ) ) { colNumber = 0 ; } else { colNumber = 1 ; } } else { colNumber = card . getCardValue ( ) . getValue ( ) ; } return ImageCard . getInstance ( ) . image . getSubimage ( colNumber * ImageCard . getInstance ( ) . getCardWidth ( ) , rowNumber * ImageCard . getInstance ( ) . getCardHeight ( ) , ImageCard . getInstance ( ) . getCardWidth ( ) , ImageCard . getInstance ( ) . getCardHeight ( ) ) ; }
tr	9	public void render_fow ( VGraphics g , Point pcm ) { g . setTexture ( "fow/full.png" ) ; i ++ ; for ( int x = pcm . x / 64 ; x < 30 + pcm . x / 64 ; x ++ ) { for ( int y = - 10 + pcm . y / 64 ; y < 20 + pcm . y / 64 ; y ++ ) { int h = 20 ; int z = t ( point ( x , y ) ) * h ; VPoint test = VConvert . to2DPoint ( x * 64 + - pcm . x / 2 , y * 64 + 32 - pcm . y / 2 , z ) ; if ( x == 0 || x == 511 || y == 0 || y == 511 ) { g . setColor ( new Color ( 235 , 0 , 0 ) ) ; } else if ( tf ( point ( x , y ) ) > 0 ) { g . setColor ( new Color ( 235 , 235 , 235 ) ) ; } else { g . setColor ( new Color ( 135 , 135 , 135 ) ) ; } VPoint p = VConvert . to2DPoint ( x * 64 - pcm . x , y * 64 - pcm . y , z ) ; if ( tf ( point ( x , y ) ) <= 1 ) { if ( tf ( point ( x , y ) ) == 0 ) { g . setColor ( new Color ( 255 , 255 , 255 , 75 ) ) ; } else { g . setColor ( new Color ( 255 , 255 , 255 , 15 ) ) ; } g . drawRect ( ( int ) p . x , ( int ) p . y , 255 , 255 , i ) ; g . drawRect ( ( int ) p . x , ( int ) p . y , 255 , 255 , - i ) ; } } } }
tr	4	private static void createBlocks ( List < File > blockFiles , String fileName ) { try { int [ ] numbers = new int [ ARRAY_SIZE ] ; BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; String line = null ; int j = 0 ; while ( ( line = reader . readLine ( ) ) != null ) { numbers [ j ] = Integer . parseInt ( line ) ; j ++ ; if ( j == ARRAY_SIZE ) { quickSort ( numbers , 0 , j - 1 ) ; blockFiles . add ( writeBlock ( numbers , j - 1 ) ) ; j = 0 ; } } if ( j > 0 ) { quickSort ( numbers , 0 , j - 1 ) ; blockFiles . add ( writeBlock ( numbers , j - 1 ) ) ; } reader . close ( ) ; } catch ( Exception IOException ) { System . err . println ( "Error reading file" ) ; IOException . printStackTrace ( ) ; } }
tr	7	public boolean attack ( Square toSquare , short amount ) { Logger . debug ( gameStatus . currentPlayerIndex + ")Attack!" ) ; short defUnits = toSquare . getUnits ( ) ; short attackUnits = amount ; if ( attackUnits > units ) attackUnits = units ; short baseDefenceUnits = ( short ) gameStatus . config . getInt ( Config . KEY . BASE_DEFENCE_UNITS . getKey ( ) ) ; if ( defUnits == attackUnits ) { owner . modifyTotalUnits ( ( short ) - ( attackUnits - 1 ) ) ; toSquare . owner . modifyTotalUnits ( ( short ) - ( attackUnits - 1 ) ) ; units = 1 ; toSquare . units = 1 ; } else if ( defUnits == 0 ) { toSquare . playerLoses ( ) ; units -= amount ; toSquare . units = amount ; owner . modifySquares ( 1 ) ; toSquare . owner = owner ; } else { if ( defUnits < attackUnits ) { toSquare . playerLoses ( ) ; owner . modifySquares ( 1 ) ; owner . modifyTotalUnits ( ( short ) - ( defUnits - baseDefenceUnits ) ) ; toSquare . owner = owner ; toSquare . units = ( short ) ( attackUnits - ( defUnits - baseDefenceUnits ) ) ; units -= attackUnits ; short maxUnits = ( short ) gameStatus . config . getInt ( Config . KEY . MAX_UNITS . getKey ( ) ) ; if ( toSquare . units > maxUnits ) { units += ( toSquare . units - maxUnits ) ; toSquare . units = maxUnits ; } } else { short maxUnits = ( short ) gameStatus . config . getInt ( Config . KEY . MAX_UNITS . getKey ( ) ) ; if ( attackUnits == 1 && defUnits == maxUnits ) { Logger . debug ( "Can't move 1 unit from " + this . coordinate + " to " + toSquare . coordinate + " as destination is maxed out" ) ; return false ; } owner . modifyTotalUnits ( ( short ) - attackUnits ) ; toSquare . owner . modifyTotalUnits ( ( short ) - ( attackUnits - baseDefenceUnits ) ) ; units -= attackUnits ; toSquare . units -= ( short ) ( attackUnits - baseDefenceUnits ) ; } } return true ; }
tr	8	private static void showExhaustiveGraphInCanvas ( RequirementGraph req_model , int visualization ) throws ScriptException { for ( SecurityGoal sg : req_model . getSg_elem ( ) ) { String element_id = AppleScript . drawArbitraryRequirementElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "All" , InfoEnum . reverse_req_elem_type_map . get ( InfoEnum . RequirementElementType . SOFTGOAL . name ( ) ) , InfoEnum . NORMAL_SIZE , "{500 500}" , "0" , sg . getName ( ) , "0" , "1" ) ; sg . setId ( element_id ) ; if ( sg . isCriticality ( ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Red" , "Simple" ) ; } else if ( sg . applicability == true ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "3" , "Green" , "All" ) ; } else if ( visualization != InfoEnum . INITIAL_VIEW && sg . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Blue" , "Simple" ) ; } } for ( RequirementLink rl : req_model . getSg_links ( ) ) { String link_id = AppleScript . drawExhaustiveRefinementLink ( rl ) ; rl . setId ( link_id ) ; AppleScript . changeAttributeOfLink ( InfoEnum . esg_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "1" , "none" , "All" ) ; if ( visualization != InfoEnum . INITIAL_VIEW && rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfLink ( InfoEnum . esg_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "3" , "Blue" , "Simple" ) ; } } }
tr	4	public void checkHills ( int x , int y ) { if ( map [ x ] [ y ] == Level . HILL_TOP_LEFT || map [ x ] [ y ] == Level . HILL_TOP_LEFT_IN ) { numHills ++ ; difficulty ++ ; if ( this . type != Type . HILL && numHills > getCurrentTypeCount ( ) ) { this . type = Type . HILL ; } } }
tr	9	public Iterator < String > keysThatMatch ( String pattern ) { if ( pattern == null ) { throw new IllegalArgumentException ( ) ; } Queue < String > results = new ArrayList < String > ( size ) ; if ( root == null ) { return results . queued ( ) ; } Stack < Node < V >> nodes = new ArrayList < Node < V >> ( ) ; Stack < String > keys = new ArrayList < String > ( ) ; nodes . push ( root ) ; keys . push ( "" ) ; while ( ! nodes . empty ( ) ) { Node < V > node = nodes . pop ( ) ; String key = keys . pop ( ) ; if ( key . length ( ) == pattern . length ( ) ) { if ( node . value != null ) { results . enqueue ( key ) ; } continue ; } char c = pattern . charAt ( key . length ( ) ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } if ( c == * ) { for ( char i = ALPHABET_SIZE - 1 ; i >= 0 ; -- i ) { if ( node . next [ i ] != null ) { nodes . push ( node . next [ i ] ) ; keys . push ( key + i ) ; } } } else if ( node . next [ c ] != null ) { nodes . push ( node . next [ c ] ) ; keys . push ( key + c ) ; } } return results . queued ( ) ; }
tr	7	public boolean initializeDb ( ) { try { if ( ! isdabaseInitialized ( ) ) { getDbConnection ( ) . createStatement ( ) . execute ( createString1 ) ; getDbConnection ( ) . createStatement ( ) . execute ( createString2 ) ; updateDb101b ( ) ; updateDb102b ( ) ; initStationData ( ) ; return true ; } if ( ! updatedTo ( APP_VERSION_101 ) && ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb101b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } if ( ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb102b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } } catch ( SQLException e ) { log . error ( "Error" , e ) ; } return false ; }
tr	0	public String getSrcText ( ) { return "" ; }
tr	0	@ BeforeMethod public void setUpMethod ( ) throws Exception { }
tr	2	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	8	public void draw ( Graphics2D g2d ) { Stroke oldStroke = g2d . getStroke ( ) ; { double x = ( Globals . W_WIDTH / 2 ) - ( WeaponsLoadout . BAR_WIDTH / 2 ) ; double y = Globals . W_HEIGHT - ( WeaponsLoadout . BAR_HEIGHT + 15 ) ; Rectangle2D . double rect = new Rectangle2D . double ( x , y , WeaponsLoadout . BAR_WIDTH , WeaponsLoadout . BAR_HEIGHT ) ; g2d . setColor ( Color . GRAY ) ; g2d . fill ( rect ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( rect ) ; } { String [ ] weaponNames = { Globals . HANDGUN . getName ( ) , Globals . ASSAULT_RIFLE . getName ( ) , Globals . SHOTGUN . getName ( ) , Globals . FLAMETHROWER . getName ( ) , Globals . GRENADE . getName ( ) , Globals . LANDMINE . getName ( ) , Globals . FLARE . getName ( ) , Globals . LASERWIRE . getName ( ) , Globals . TURRETWEAPON . getName ( ) , Globals . TELEPORTER . getName ( ) } ; for ( int s = 0 ; s < 10 ; s ++ ) { int slot = s * 48 ; int spacing = ( s + 1 ) * 4 ; double size = 48 ; double x = ( ( Globals . W_WIDTH / 2 ) - ( WeaponsLoadout . BAR_WIDTH / 2 ) ) + ( slot + spacing ) ; double y = ( Globals . W_HEIGHT - ( WeaponsLoadout . BAR_HEIGHT + 15 ) ) + 4 ; Rectangle2D . double rect = new Rectangle2D . double ( x , y , size , size ) ; g2d . setStroke ( oldStroke ) ; g2d . setColor ( Color . LIGHT_GRAY ) ; g2d . fill ( rect ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( rect ) ; { BufferedImage image = null ; HashMap < String , Weapon > weaponsMap = player . getWeaponsMap ( ) ; int w = s + 1 ; Weapon weapon = null ; for ( int i = 1 ; i <= 10 ; i ++ ) { if ( ( w == i ) && weaponsMap . containsKey ( weaponNames [ i - 1 ] ) ) { weapon = weaponsMap . get ( weaponNames [ i - 1 ] ) ; image = weapon . getImage ( ) ; break ; } } if ( image != null ) g2d . drawImage ( image , ( int ) x , ( int ) y , null ) ; { if ( ( weapon != null ) && player . hasWeapon ( weapon . getName ( ) ) ) { g2d . setColor ( new Color ( 0 , 0 , 0 , 200 ) ) ; double width = weapon . getCooldownPercentage ( ) * 48 ; Rectangle2D . double coolBox = new Rectangle2D . double ( x , y , width , 48 ) ; g2d . fill ( coolBox ) ; } } } if ( this . currentWeaponName . equals ( weaponNames [ s ] ) ) { x += 3 ; y += 3 ; size = 42 ; Rectangle2D . double border = new Rectangle2D . double ( x , y , size , size ) ; g2d . setColor ( Color . WHITE ) ; g2d . setStroke ( new BasicStroke ( 3.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 10.0f , new float [ ] { 10.0f } , 0.0f ) ) ; g2d . draw ( border ) ; } } } g2d . setStroke ( oldStroke ) ; }
tr	0	public void procFile ( String filepath , String restart ) { this . lastItem = restart ; copyTable ( filepath ) ; }
tr	2	public HiddenNeuron ( double gain , double timeConstant , double bias , double selfWeight , double ... sensorWeights ) { this . gain = gain ; this . timeConstant = timeConstant ; this . bias = bias ; this . selfWeight = selfWeight ; this . connections = new ArrayList < Object [ ] > ( ) ; if ( sensorWeights . length != 5 ) try { throw new Exception ( "Wrong amount of weights passed to constructor!" ) ; } catch ( Exception ex ) { Logger . getLogger ( HiddenNeuron . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; ex . printStackTrace ( ) ; } this . sensorWeights = sensorWeights ; }
tr	0	public boolean isDataFlavorSupported ( DataFlavor flavor ) { return false ; }
tr	0	public BigRational ( ) { this ( BigDecimal . ZERO ) ; }
tr	1	private void processDash ( ) { setAngle ( getAngle ( ) + dashSpeed ) ; dashSpeed -= ( dashSpeed * 0.1 ) + Math . signum ( dashSpeed ) * 0.1 ; if ( Math . abs ( dashSpeed ) < 0.1 ) { dashSpeed = 0 ; } }
tr	1	@ Override public String getText ( ) { LocalDate startDate = project . getStartDate ( ) ; String text = "New start week year" ; if ( startDate != null ) { text = String . format ( "Old start week year: %d%n%s" , startDate . getWeekyear ( ) , text ) ; } return text ; }
tr	3	private void initialize ( ) { frmSimulationhelper = new JFrame ( ) ; frmSimulationhelper . setTitle ( "Simulation" ) ; frmSimulationhelper . setBounds ( 100 , 100 , 669 , 890 ) ; frmSimulationhelper . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frmSimulationhelper . getContentPane ( ) . setLayout ( new MigLayout ( "" , "[289.00px][144px grow][193.00px]" , "[675.00px grow]" ) ) ; JDesktopPane desktopPane = new JDesktopPane ( ) ; desktopPane . setBackground ( Color . LIGHT_GRAY ) ; frmSimulationhelper . getContentPane ( ) . add ( desktopPane , "cell 0 0 grow" ) ; desktopPane . setLayout ( new MigLayout ( "" , "[140px grow]" , "[12px][24px][25px][25px][15px][][][19px][][][][][][][][][][][][][][][][][][][][][][][][][][][][][grow][grow][grow][]" ) ) ; JLabel lblFlaschenautomat = new JLabel ( "Flaschenautomat" ) ; desktopPane . add ( lblFlaschenautomat , "cell 0 0 alignx center aligny center" ) ; String [ ] comboStrings = new String [ FlaschenType . values ( ) . length ] ; comboStrings [ 0 ] = FlaschenType . CodeNichtValide . toString ( ) ; comboStrings [ 1 ] = FlaschenType . CodeUnlesbar . toString ( ) ; comboStrings [ 2 ] = FlaschenType . Mehrweg . toString ( ) ; comboStrings [ 3 ] = FlaschenType . PET . toString ( ) ; comboBox = new JComboBox ( comboStrings ) ; desktopPane . add ( comboBox , "cell 0 1 growx aligny center" ) ; tglbtnEingangslichtschranke = new JToggleButton ( "Eingangslichtschranke" ) ; tglbtnEingangslichtschranke . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . Eingangslichtschranke . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; JButton btnFlascheeinlegen = new JButton ( "FlascheEinlegen" ) ; btnFlascheeinlegen . setHorizontalAlignment ( SwingConstants . LEFT ) ; btnFlascheeinlegen . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { } } ) ; btnFlascheeinlegen . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { String Flasche = comboBox . getSelectedItem ( ) . toString ( ) ; DieFassade . simFlascheEinlegen ( FlaschenType . valueOf ( Flasche ) ) ; } } ) ; desktopPane . add ( btnFlascheeinlegen , "flowx cell 0 2 alignx left" ) ; tglbtnEingangslichtschranke . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnEingangslichtschranke , "flowx cell 0 4" ) ; tglbtnJustierlichtschranke = new JToggleButton ( "Justierlichtschranke" ) ; tglbtnJustierlichtschranke . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . Justierlichtschranke . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnJustierlichtschranke . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnJustierlichtschranke , "flowx cell 0 5" ) ; tglbtnAusgangslichtschranke = new JToggleButton ( "Ausgangslichtschranke" ) ; tglbtnAusgangslichtschranke . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . Ausgangslichtschranke . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnAusgangslichtschranke . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnAusgangslichtschranke , "flowx cell 0 6" ) ; tglbtnEingangAuswahlklappe = new JToggleButton ( "Eingangslichtschranke Auswahlklappe" ) ; tglbtnEingangAuswahlklappe . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnEingangAuswahlklappe . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnEingangAuswahlklappe , "flowx cell 0 11" ) ; ButtonGroup groupL1 = new ButtonGroup ( ) ; ButtonGroup groupL2 = new ButtonGroup ( ) ; ButtonGroup groupL3 = new ButtonGroup ( ) ; tglbtnLichtschrankepet = new JToggleButton ( "LichtschrankePET" ) ; tglbtnLichtschrankepet . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . UebergabelichtschrankePET . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnLichtschrankepet . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnLichtschrankepet , "flowx cell 0 12" ) ; tglbtnLichtschrankemehrweg = new JToggleButton ( "LichtschrankeMehrweg" ) ; tglbtnLichtschrankemehrweg . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnLichtschrankemehrweg . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnLichtschrankemehrweg , "flowx cell 0 13" ) ; tglbtnLeuchte = new JToggleButton ( "Leuchte" ) ; tglbtnLeuchte . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . Leuchte . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnLeuchte . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnLeuchte , "cell 0 17" ) ; tglbtnTrte = new JToggleButton ( "Tr\u00F6te" ) ; tglbtnTrte . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . Troete . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; tglbtnTrte . setHorizontalAlignment ( SwingConstants . LEFT ) ; desktopPane . add ( tglbtnTrte , "cell 0 19" ) ; pVorderesLaufband = new JPanel ( ) ; desktopPane . add ( pVorderesLaufband , "cell 0 20 growx aligny top" ) ; pVorderesLaufband . setLayout ( new GridLayout ( 5 , 0 , 0 , 0 ) ) ; lblVordereslaufband = new JLabel ( "Vorderes-Laufband" ) ; pVorderesLaufband . add ( lblVordereslaufband ) ; chckbxVorderesGesperrt = new JCheckBox ( "gesperrt" ) ; chckbxVorderesGesperrt . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; if ( abstractButton . getModel ( ) . isSelected ( ) ) { rdbtnVorderesStop . setEnabled ( false ) ; rdbtnVorderesVorwaerts . setEnabled ( false ) ; rdbtnVorderesRueckwaerts . setEnabled ( false ) ; HWaccess . write ( Automat . Adressen . LaufbandEingang . ordinal ( ) , - 1 ) ; } else { rdbtnVorderesStop . setEnabled ( true ) ; rdbtnVorderesVorwaerts . setEnabled ( true ) ; rdbtnVorderesRueckwaerts . setEnabled ( true ) ; HWaccess . write ( Automat . Adressen . LaufbandEingang . ordinal ( ) , 0 ) ; } } } ) ; pVorderesLaufband . add ( chckbxVorderesGesperrt ) ; rdbtnVorderesStop = new JRadioButton ( "stop" ) ; rdbtnVorderesStop . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandEingang . ordinal ( ) , 0 ) ; } } ) ; pVorderesLaufband . add ( rdbtnVorderesStop ) ; rdbtnVorderesVorwaerts = new JRadioButton ( "vorw\u00E4rts" ) ; rdbtnVorderesVorwaerts . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandEingang . ordinal ( ) , 1 ) ; } } ) ; pVorderesLaufband . add ( rdbtnVorderesVorwaerts ) ; rdbtnVorderesRueckwaerts = new JRadioButton ( "r\u00FCckw\u00E4rts" ) ; rdbtnVorderesRueckwaerts . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandEingang . ordinal ( ) , 2 ) ; } } ) ; pVorderesLaufband . add ( rdbtnVorderesRueckwaerts ) ; groupL1 . add ( rdbtnVorderesStop ) ; groupL1 . add ( rdbtnVorderesVorwaerts ) ; groupL1 . add ( rdbtnVorderesRueckwaerts ) ; pDrehLaufband = new JPanel ( ) ; desktopPane . add ( pDrehLaufband , "cell 0 21 growx aligny top" ) ; pDrehLaufband . setLayout ( new GridLayout ( 5 , 0 , 0 , 0 ) ) ; lableDreh = new JLabel ( "Dreh-Laufband" ) ; pDrehLaufband . add ( lableDreh ) ; chckbxDrehGesperrt = new JCheckBox ( "gesperrt" ) ; chckbxDrehGesperrt . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; if ( abstractButton . getModel ( ) . isSelected ( ) ) { rdbtnDrehStop . setEnabled ( false ) ; rdbtnDrehRechts . setEnabled ( false ) ; rdbtnDrehLinks . setEnabled ( false ) ; HWaccess . write ( Automat . Adressen . LaufbandDrehen . ordinal ( ) , - 1 ) ; } else { rdbtnDrehStop . setEnabled ( true ) ; rdbtnDrehRechts . setEnabled ( true ) ; rdbtnDrehLinks . setEnabled ( true ) ; HWaccess . write ( Automat . Adressen . LaufbandDrehen . ordinal ( ) , 0 ) ; } } } ) ; pDrehLaufband . add ( chckbxDrehGesperrt ) ; rdbtnDrehStop = new JRadioButton ( "stop" ) ; rdbtnDrehStop . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandDrehen . ordinal ( ) , 0 ) ; } } ) ; pDrehLaufband . add ( rdbtnDrehStop ) ; rdbtnDrehRechts = new JRadioButton ( "drehe rechts" ) ; rdbtnDrehRechts . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandDrehen . ordinal ( ) , 1 ) ; } } ) ; pDrehLaufband . add ( rdbtnDrehRechts ) ; rdbtnDrehLinks = new JRadioButton ( "drehe links" ) ; rdbtnDrehLinks . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandDrehen . ordinal ( ) , 2 ) ; } } ) ; pDrehLaufband . add ( rdbtnDrehLinks ) ; groupL2 . add ( rdbtnDrehStop ) ; groupL2 . add ( rdbtnDrehRechts ) ; groupL2 . add ( rdbtnDrehLinks ) ; JScrollPane scrollPane = new JScrollPane ( ) ; frmSimulationhelper . getContentPane ( ) . add ( scrollPane , "cell 1 0 2 1 grow" ) ; txtrMonitoring = new JTextArea ( ) ; scrollPane . setViewportView ( txtrMonitoring ) ; DefaultCaret ^ = ( DefaultCaret ) txtrMonitoring . getCaret ( ) ; ^ . setUpdatePolicy ( DefaultCaret . ALWAYS_UPDATE ) ; frmSimulationhelper . setLocation ( 490 , 30 ) ; pHinteresLaufband = new JPanel ( ) ; desktopPane . add ( pHinteresLaufband , "cell 0 23 grow" ) ; pHinteresLaufband . setLayout ( new GridLayout ( 0 , 1 , 0 , 0 ) ) ; lblHintereslaufband = new JLabel ( "Hinteres-Laufband" ) ; pHinteresLaufband . add ( lblHintereslaufband ) ; chckbxHinteresGesperrt = new JCheckBox ( "gesperrt" ) ; chckbxHinteresGesperrt . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; if ( abstractButton . getModel ( ) . isSelected ( ) ) { rdbtnHinteresStop . setEnabled ( false ) ; rdbtnHinteresVorwaerts . setEnabled ( false ) ; rdbtnHinteresRueckwaerts . setEnabled ( false ) ; HWaccess . write ( Automat . Adressen . LaufbandAusgang . ordinal ( ) , - 1 ) ; } else { rdbtnHinteresStop . setEnabled ( true ) ; rdbtnHinteresVorwaerts . setEnabled ( true ) ; rdbtnHinteresRueckwaerts . setEnabled ( true ) ; HWaccess . write ( Automat . Adressen . LaufbandAusgang . ordinal ( ) , 0 ) ; } } } ) ; pHinteresLaufband . add ( chckbxHinteresGesperrt ) ; rdbtnHinteresStop = new JRadioButton ( "stop" ) ; rdbtnHinteresStop . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandAusgang . ordinal ( ) , 0 ) ; } } ) ; pHinteresLaufband . add ( rdbtnHinteresStop ) ; rdbtnHinteresVorwaerts = new JRadioButton ( "vorw\u00E4rts" ) ; rdbtnHinteresVorwaerts . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandAusgang . ordinal ( ) , 1 ) ; } } ) ; pHinteresLaufband . add ( rdbtnHinteresVorwaerts ) ; rdbtnHinteresRueckwaerts = new JRadioButton ( "r\u00FCckw\u00E4rts" ) ; rdbtnHinteresRueckwaerts . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { HWaccess . write ( Automat . Adressen . LaufbandAusgang . ordinal ( ) , 2 ) ; } } ) ; pHinteresLaufband . add ( rdbtnHinteresRueckwaerts ) ; groupL3 . add ( rdbtnHinteresStop ) ; groupL3 . add ( rdbtnHinteresVorwaerts ) ; groupL3 . add ( rdbtnHinteresRueckwaerts ) ; pEndbehaelter = new JPanel ( ) ; desktopPane . add ( pEndbehaelter , "cell 0 28 grow" ) ; pEndbehaelter . setLayout ( new GridLayout ( 0 , 1 , 0 , 0 ) ) ; lblEndbehaelter = new JLabel ( "Endbeh\uFFFDlter" ) ; pEndbehaelter . add ( lblEndbehaelter ) ; tglbtnPetBehlter = new JToggleButton ( "PET" ) ; tglbtnPetBehlter . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . FuellstandPET . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; pEndbehaelter . add ( tglbtnPetBehlter ) ; tglbtnMehrwegBehlter = new JToggleButton ( "Mehrweg" ) ; tglbtnMehrwegBehlter . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { AbstractButton abstractButton = ( AbstractButton ) actionEvent . getSource ( ) ; HWaccess . write ( Automat . Adressen . FuellstandMehrweg . ordinal ( ) , abstractButton . getModel ( ) . isSelected ( ) ) ; } } ) ; pEndbehaelter . add ( tglbtnMehrwegBehlter ) ; eingangP = new JPanel ( ) ; desktopPane . add ( eingangP , "cell 0 4" ) ; justierP = new JPanel ( ) ; desktopPane . add ( justierP , "cell 0 5" ) ; ausgangP = new JPanel ( ) ; desktopPane . add ( ausgangP , "cell 0 6" ) ; klappeEingangP = new JPanel ( ) ; desktopPane . add ( klappeEingangP , "cell 0 11" ) ; petP = new JPanel ( ) ; desktopPane . add ( petP , "cell 0 12" ) ; mehrP = new JPanel ( ) ; desktopPane . add ( mehrP , "cell 0 13" ) ; btnSimulation = new JButton ( "Simulation" ) ; btnSimulation . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { String Flasche = comboBox . getSelectedItem ( ) . toString ( ) ; DieFassade . simAblauf ( FlaschenType . valueOf ( Flasche ) ) ; } } ) ; desktopPane . add ( btnSimulation , "cell 0 2" ) ; }
tr	4	private static int [ ] leeVector ( String mensaje , int longitud ) { int [ ] vector = new int [ longitud ] ; boolean valido = false ; while ( ! valido ) { System . out . print ( mensaje ) ; try { for ( int i = 0 ; i < longitud ; i ++ ) vector [ i ] = Coin . nextInt ( ) ; if ( Coin . hasNextLine ( ) ) Coin . nextLine ( ) ; valido = true ; } catch ( Exception ex ) { Coin . nextLine ( ) ; } } return vector ; }
tr	7	private void updateCommandCard ( ) { switch ( interactionState ) { case mapScrolling : case menu : case placeTower : case scrolling : case zooming : displayEmptyCommandCard ( ) ; break ; case normal : displayBuyCommandCard ( ) ; break ; case selected : displayTowerCommandCard ( ) ; break ; } }
tr	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	7	private void regConfirmActionPerformed ( java . awt . event . ActionEvent evt ) { String patientId = regPatientId . getText ( ) ; String patientName = regPatientName . getText ( ) ; String patientAge = regPatientAge . getText ( ) ; System . out . println ( patientAge == null ) ; boolean gender = false ; if ( maleButton . isSelected ( ) ) { gender = false ; } else if ( femaleButton . isSelected ( ) ) { gender = true ; } if ( patientId != "" && patientName != "" && patientAge != "" ) { try { short age = 0 ; age = short . parseShort ( patientAge ) ; NewPatient np = new NewPatient ( patientName , age , gender ) ; out . writeObject ( np ) ; out . flush ( ) ; regWindow . setVisible ( false ) ; completeWindow . setVisible ( true ) ; } catch ( IOException ex ) { Logger . getLogger ( RegisterJFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NumberFormatException e ) { ErrorInfo . setVisible ( true ) ; } } else { ErrorInfo . setVisible ( true ) ; } }
tr	3	@ Override public void tick ( ) { counter ++ ; if ( counter == tickDivider ) { counter = 0 ; if ( enemyUnits . size ( ) > 0 ) { Slime slime = new Slime ( ) ; rune . modifySlime ( slime ) ; for ( EnemyUnit enemy : enemyUnits ) { enemy . gotSlowed ( slime ) ; } } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	5	public void getFlower ( ) { if ( deathTime > 0 || world . paused ) return ; if ( ! fire ) { world . paused = true ; powerUpTime = 3 * 6 ; world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_POWER_UP ] , this , 1 , 1 , 1 ) ; world . mario . setLarge ( true , true ) ; if ( world . recorder != null ) { if ( large ) { world . recorder . endLargeRecord ( ) ; } else { world . recorder . endLittleRecord ( ) ; } world . recorder . startFireRecord ( ) ; } } else { Mario . getCoin ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_GET_COIN ] , this , 1 , 1 , 1 ) ; } }
tr	1	private String convertStreamToString ( InputStream istream ) throws IOException { BufferedReader breader = new BufferedReader ( new InputStreamReader ( istream ) ) ; StringBuilder responseString = new StringBuilder ( ) ; String line = "" ; while ( ( line = breader . readLine ( ) ) != null ) { responseString . append ( line ) ; } breader . close ( ) ; return responseString . toString ( ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final JellyTots other = ( JellyTots ) obj ; if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { return false ; } if ( ( this . date == null ) ? ( other . date != null ) : ! this . date . equals ( other . date ) ) { return false ; } return true ; }
tr	3	public void createClusterMembershipList ( Set < Integer > nodes , String map , String clusters , String output ) { try { Map < Integer , Integer > M = readMap ( map , false ) ; String line ; String [ ] parts ; BufferedReader in = new BufferedReader ( new FileReader ( clusters ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( output ) ) ; int node ; while ( ( line = in . readLine ( ) ) != null ) { parts = line . split ( " " ) ; node = M . get ( Integer . parseInt ( parts [ 0 ] . trim ( ) ) ) ; if ( nodes . contains ( node ) ) { out . write ( node + " " + parts [ 1 ] . trim ( ) + "\n" ) ; } } out . flush ( ) ; out . close ( ) ; in . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( LinkSetAnalyser . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	private Response httpsMultPart ( String fileParamName , String url , PostParameter [ ] params , File file , boolean authenticated ) throws TBlogException { PostMethod post = new PostMethod ( url ) ; org . apache . commons . httpclient . HttpClient client = new org . apache . commons . httpclient . HttpClient ( ) ; Part [ ] parts = null ; if ( params == null ) { parts = new Part [ 1 ] ; } else { parts = new Part [ params . length + 1 ] ; } if ( params != null ) { int i = 0 ; for ( PostParameter entry : params ) { parts [ i ++ ] = new StringPart ( entry . getName ( ) , ( String ) entry . getValue ( ) ) ; } } FilePart filePart ; try { filePart = new FilePart ( fileParamName , file . getName ( ) , file , new MimetypesFileTypeMap ( ) . getContentType ( file ) , "UTF-8" ) ; filePart . setTransferEncoding ( "binary" ) ; parts [ parts . length - 1 ] = filePart ; post . setRequestEntity ( new MultipartRequestEntity ( parts , post . getParams ( ) ) ) ; if ( authenticated ) { post . addRequestHeader ( "Authorization" , "OAuth2 " + this . oauth2AccessToken ) ; } client . executeMethod ( post ) ; Response response = new Response ( ) ; response . setResponseAsString ( post . getResponseBodyAsString ( ) ) ; response . setStatusCode ( post . getStatusCode ( ) ) ; return response ; } catch ( Exception ex ) { throw new TBlogException ( ex . getMessage ( ) , ex , - 1 ) ; } finally { post . releaseConnection ( ) ; client = null ; } }
tr	9	private void readValues ( Buffer stream , int i ) { do { int opcode = stream . getUnsignedByte ( ) ; if ( opcode == 0 ) return ; if ( opcode == 1 ) stream . getUnsignedByte ( ) ; else if ( opcode == 2 ) stream . getUnsignedByte ( ) ; else if ( opcode == 3 ) anIntArray703 [ anInt702 ++ ] = i ; else if ( opcode == 4 ) { } else if ( opcode == 5 ) type = stream . getUnsignedLEShort ( ) ; else if ( opcode == 6 ) { } else if ( opcode == 7 ) stream . getInt ( ) ; else if ( opcode == 8 ) aBoolean713 = true ; else if ( opcode == 10 ) stream . getString ( ) ; else if ( opcode == 11 ) aBoolean713 = true ; else if ( opcode == 12 ) stream . getInt ( ) ; else if ( opcode == 13 ) { } else System . out . println ( "Error unrecognised config code: " + opcode ) ; } while ( true ) ; }
tr	7	@ Override public boolean combine ( AExecutionItem itemToAdd ) { if ( itemToAdd != null && itemToAdd . getClass ( ) == PreparedStatementExecutionItem . class ) { if ( this . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! this . query . toUpperCase ( ) . contains ( ";SELECT" ) ) { PreparedStatementExecutionItem otherItem = ( PreparedStatementExecutionItem ) itemToAdd ; if ( otherItem . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! otherItem . query . toUpperCase ( ) . contains ( ";SELECT" ) && otherItem . query . toLowerCase ( ) . equals ( query . toLowerCase ( ) ) ) { this . executionItems . add ( otherItem ) ; return true ; } } } return false ; }
tr	3	private void checkHighlight ( ) { Set < Integer > activeSet = myNextTurtleList . getActiveIDs ( ) ; DecoratedTurtleDrawer highlight = new HighlightActiveTurtleDrawer ( ) ; for ( int i = 0 ; i < myNextTurtleList . size ( ) ; i ++ ) { myTurtleDrawers . set ( i , myTurtleDrawers . get ( i ) . removeReference ( highlight ) ) ; if ( activeSet . contains ( i ) && isHighlighted ) { toggleDecorator ( highlight , i ) ; } } }
tr	2	public void createRestartFile ( String header , int dateIndex , int depthIndex ) { File infile = new File ( header ) ; String outputName = outputFolder + "/" + sdf . format ( releaseDates [ dateIndex ] ) + "_" + mindepths [ depthIndex ] + "-" + maxdepths [ depthIndex ] + ".prm" ; File outfile = new File ( restartFile ) ; try { copyFileUsingStream ( infile , outfile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( outfile , true ) ) ; ) { bw . write ( "(java " + prms + " -jar " + jarfile + " " + outputName + " " + configurationFile + " " + source + " > " + logdir + "/" + prefix + dateIndex + "D" + depthIndex + ".log)&\n" ) ; bw . write ( cronString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public static void main ( String [ ] args ) { SystemSetting_CLI cli = new SystemSetting_CLI ( ) ; cli . show ( ) ; }
tr	1	public static < R , T > R reduce ( Collection < T > c , Function2 < R , T > f , R z ) { for ( T e : c ) { z = f . apply ( z , e ) ; } return z ; }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	6	private void returnStatement_rest ( ) throws Exception { Instruction r = null ; if ( scan . sym == Token . ident || scan . sym == Token . num || scan . sym == Token . openparen || scan . sym == Token . call ) { if ( inMain ) { throw new Exception ( "Attempt to return value from __MAIN__" ) ; } r = new Ret ( expression ( ) ) ; } else { r = inMain ? new End ( ) : new Ret ( ) ; } currentBB . addInstruction ( r ) ; }
tr	0	public static String readLine ( String prompt ) { printPrompt ( prompt ) ; return readLine ( ) ; }
tr	3	public ArrayList < ArrayList < Integer >> combinationSum ( int [ ] candidates , int target ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; if ( candidates == null || candidates . length == 0 || target < 0 ) { return result ; } Arrays . sort ( candidates ) ; int start = 0 ; ArrayList < Integer > current = new ArrayList < Integer > ( ) ; buildResult ( candidates , start , current , target , result ) ; return result ; }
tr	9	@ Override public Activity getActivity ( Place place ) { if ( place instanceof HomePlace ) { return new ShowCaseListActivity ( clientFactory ) ; } if ( place instanceof UIPlace ) { return new UIActivity ( clientFactory ) ; } if ( place instanceof AboutPlace ) { return new AboutActivity ( clientFactory ) ; } if ( place instanceof TestPhoneGapPlace ) { return new TestPhoneGapActivity ( clientFactory ) ; } if ( place instanceof ElementsPlace ) { return new ElementsActivity ( clientFactory ) ; } if ( place instanceof FormsPlace ) { return new FormsActivity ( clientFactory ) ; } if ( place instanceof CarouselPlace ) { return new CarouselActivity ( clientFactory ) ; } if ( place instanceof VerifyGPSPlace ) { return new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } if ( place instanceof VerifyCompassPlace ) { return new CompassFunctionalityVerfiedActivity ( clientFactory ) ; } return new ShowCaseListActivity ( clientFactory ) ; }
tr	9	public ListNode rotateRight ( ListNode head , int n ) { int length = 0 ; if ( head == null ) { return null ; } if ( n == 0 ) { return head ; } ListNode currentNode = head ; while ( currentNode != null ) { length ++ ; currentNode = currentNode . next ; } n = n % length ; if ( length == 1 || n == 0 ) { return head ; } int count = 0 ; currentNode = head ; while ( count != n ) { count ++ ; currentNode = currentNode . next ; } currentNode = currentNode . next ; ListNode temp = head ; ListNode tempLast = null ; while ( currentNode != null ) { if ( currentNode . next == null ) { tempLast = currentNode ; } temp = temp . next ; currentNode = currentNode . next ; } currentNode = temp . next ; temp . next = null ; if ( tempLast == null ) { tempLast = currentNode ; while ( tempLast . next != null ) { tempLast = tempLast . next ; } } tempLast . next = head ; head = currentNode ; return head ; }
tr	1	public void set_transfer_type ( String in ) { try { _transfer_type = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
tr	6	public void setFields ( Materie m , Node node ) { NodeList childNodes = node . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node cNode = childNodes . item ( i ) ; if ( cNode instanceof Element ) { String content = cNode . getLastChild ( ) . getTextContent ( ) . trim ( ) ; switch ( cNode . getNodeName ( ) ) { case "nume" : m . setNume ( content ) ; break ; case "ore" : m . setNrOre ( Integer . parseInt ( content ) ) ; break ; case "teza" : if ( content . equals ( "true" ) ) m . setTeza ( true ) ; else { m . setTeza ( false ) ; } } } } }
tr	2	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) != null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Token:" ) ; sb . append ( "\n  type: " ) ; sb . append ( type . toString ( ) ) ; if ( accessToken != null ) { sb . append ( "\n  access token: " ) ; sb . append ( accessToken ) ; } if ( refreshToken != null ) { sb . append ( "\n  refresh token: " ) ; sb . append ( refreshToken ) ; } if ( keyId != null ) { sb . append ( "\n  kid: " ) ; sb . append ( keyId ) ; } if ( macKey != null ) { sb . append ( "\n  mac key: " ) ; sb . append ( macKey ) ; } if ( macAlgorithm != null ) { sb . append ( "\n  mac algorithm: " ) ; sb . append ( macAlgorithm ) ; } if ( expiresIn != - 1 ) { sb . append ( "\n  expires in: " ) ; sb . append ( expiresIn ) ; } return sb . toString ( ) ; }
tr	9	public static int testPublic ( int testNum ) { String inputFilename = String . format ( "tests/test%02d.crx" , testNum ) ; String outputFilename = String . format ( "tests/test%02d.rea" , testNum ) ; String expectedFilename = String . format ( "tests/test%02d.out" , testNum ) ; String astFilename = String . format ( "tests/test%02d.ast" , testNum ) ; Scanner s = null ; try { s = new Scanner ( new FileReader ( inputFilename ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return NOT_ACCESSABLE ; } Parser p = new Parser ( s ) ; ast . Command syntaxTree = p . parse ( ) ; try { PrintStream outputStream = new PrintStream ( outputFilename ) ; PrintStream astStream = new PrintStream ( astFilename ) ; if ( p . hasError ( ) ) { outputStream . println ( "Error parsing file." ) ; outputStream . println ( p . errorReport ( ) ) ; outputStream . close ( ) ; astStream . println ( "Error parsing file." ) ; astStream . println ( p . errorReport ( ) ) ; astStream . close ( ) ; } else { PrettyPrinter pretty = new PrettyPrinter ( ) ; syntaxTree . accept ( pretty ) ; astStream . println ( pretty . toString ( ) ) ; astStream . close ( ) ; types . TypeChecker tc = new types . TypeChecker ( ) ; tc . check ( syntaxTree ) ; if ( tc . hasError ( ) ) { outputStream . println ( "Error type-checking file." ) ; outputStream . println ( tc . errorReport ( ) ) ; outputStream . close ( ) ; } else { outputStream . println ( "Crux Program has no type errors." ) ; } } } catch ( IOException e ) { System . err . println ( "Error opening output file: \"" + outputFilename + "\"" ) ; e . printStackTrace ( ) ; return IO_ERROR ; } BufferedReader bufferedexpected ; BufferedReader bufferedoutput ; String lineExpected ; String lineOutput ; try { bufferedexpected = new BufferedReader ( new FileReader ( expectedFilename ) ) ; bufferedoutput = new BufferedReader ( new FileReader ( outputFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return IO_ERROR ; } int result = PASS ; try { while ( ( lineExpected = bufferedexpected . readLine ( ) ) != null ) { lineOutput = bufferedoutput . readLine ( ) ; if ( lineOutput == null ) { result = FAIL ; break ; } lineExpected = lineExpected . replaceAll ( "\\s+$" , "" ) ; lineOutput = lineOutput . replaceAll ( "\\s+$" , "" ) ; if ( ! lineExpected . equals ( lineOutput ) ) { result = FAIL ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; result = IO_ERROR ; } try { bufferedoutput . close ( ) ; bufferedexpected . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; }
tr	8	public static Mineral find ( int remoteId ) { switch ( remoteId ) { case 34 : return Tritanium ; case 35 : return Pyerite ; case 36 : return Mexallon ; case 37 : return Isogen ; case 38 : return Nocxium ; case 39 : return Zydrine ; case 40 : return Megacyte ; case 11399 : return Morphite ; default : { throw new RuntimeException ( "Id does not represent mineral" ) ; } } }
tr	1	private Particle createLandmineParticle ( double theta , Point2D . double pos ) { Particle p = new Particle ( theta , 0.0 , 0.0 , ( Landmine . PARTICLE_LIFE / ( int ) Globals . SLEEP_TIME ) , pos , new Dimension ( 24 , 24 ) , Images . LANDMINE_PARTICLE ) { @ Override public void update ( ) { if ( this . isAlive ( ) ) this . life -- ; } @ Override public void draw ( Graphics2D g2d ) { double x = this . pos . x - ( this . size . width / 2 ) ; double y = this . pos . y - ( this . size . height / 2 ) ; g2d . drawImage ( this . image , ( int ) x , ( int ) y , null ) ; } } ; return p ; }
tr	2	@ Override public boolean remove ( Object o ) { Node < E > position = head ; for ( int i = 0 ; i < size ; i ++ ) { position = position . getNextNode ( ) ; if ( position . getValue ( ) == o ) { this . remove ( i ) ; return true ; } } return false ; }
tr	1	public double mediaDia ( String mesInt , int dia ) { double result = 0.0 ; ArrayList < SensorInt > datosDia = datosDia ( mesInt , dia ) ; for ( SensorInt d : datosDia ) { result += d . getPorcentajeCO2 ( ) / 24 ; } return result ; }
tr	9	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; char c = x . nextClean ( ) ; char q ; if ( c == [ ) { q = ] ; } else if ( c == ( ) { q = ) ; } else { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } c = x . nextClean ( ) ; switch ( c ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : case ) : if ( q != c ) { throw x . syntaxError ( "Expected a '" + new Character ( q ) + "'" ) ; } return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } }
tr	4	public void draw ( PrimitiveShape shape , Frustum frustum ) { if ( frustum . intersects ( this ) ) { if ( children != null ) { for ( byte i = 0 ; i < SUBDIVISIONS ; i ++ ) { children [ i ] . draw ( shape , frustum ) ; } } if ( enabled ) { shape . addAABB ( this ) ; } } }
tr	4	public int getLastID ( String table , String nameID ) { int n = 0 ; try { con = DriverManager . getConnection ( url , user , password ) ; Statement stmt ; stmt = con . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; ResultSet rs = stmt . executeQuery ( "select * from " + table + " order by " + nameID ) ; rs . last ( ) ; rs . getInt ( 1 ) ; n = rs . getInt ( 1 ) ; } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } finally { try { if ( pst != null ) { pst . close ( ) ; } if ( con != null ) { con . close ( ) ; } } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } return n ; }
tr	6	@ Override public void run ( ) { try { socket = new ServerSocket ( listeningPort ) ; } catch ( IOException e ) { System . err . println ( "Could not listen on port: " + listeningPort + " (maybe busy)" ) ; return ; } System . err . println ( "Listening to port " + listeningPort ) ; System . err . flush ( ) ; mainThreadRunning = true ; while ( mainThreadRunning ) { Socket clientSocket ; try { clientSocket = socket . accept ( ) ; } catch ( IOException e ) { System . err . println ( "Server has stopped listening to new Client connections" ) ; mainThreadRunning = false ; return ; } if ( clientSocket != null ) { if ( acceptClient ( clientSocket ) ) { INDIClient client = new INDIClient ( clientSocket , this ) ; clients . add ( client ) ; connectionWithClientEstablished ( client ) ; } else { try { clientSocket . close ( ) ; } catch ( IOException e ) { } } } } }
tr	0	public OAuth2 ( AuthorizationCallback authCallback , OAuth2Settings settings ) { this ( authCallback , settings , null ) ; }
tr	5	public static String newMetaClass ( class < ? > clazz , String metaPackageName ) { String className = classNameHelper ( clazz ) ; StringBuilder b = new StringBuilder ( ) ; b . append ( "// generated in " ) . append ( ClassMetaUtil . class . getCanonicalName ( ) ) . append ( "\n" ) ; b . append ( "package " ) . append ( packageNameHelper ( clazz , metaPackageName ) ) . append ( ";\n" ) ; b . append ( "public class " ) . append ( className ) ; class < ? > superClazz = clazz . getSuperclass ( ) ; if ( ! superClazz . equals ( Object . class ) ) { b . append ( " extends " ) . append ( packageNameHelper ( superClazz , metaPackageName ) ) . append ( "." ) . append ( superClazz . getSimpleName ( ) ) . append ( "_" ) ; } b . append ( " {\n" ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( Modifier . isStatic ( f . getModifiers ( ) ) ) continue ; b . append ( "public static String " ) . append ( f . getName ( ) ) . append ( " = " ) . append ( "\"" ) . append ( fieldNameHelper ( f ) ) . append ( "\";\n" ) ; } b . append ( "}" ) ; return b . toString ( ) ; }
tr	2	public static String upper ( String text ) { String s = "" ; if ( text != null && ! text . isEmpty ( ) ) { s = text . toUpperCase ( ) ; } return s ; }
tr	5	private void ftpDoubleClick ( MouseEvent e ) throws IOException { JTable target = ( JTable ) e . getSource ( ) ; int row = target . getSelectedRow ( ) ; final String dirName = ( String ) ftpTable . getValueAt ( row , 1 ) ; new Thread ( ) { @ Override public void run ( ) { try { ftpPath = serverConnect . pwd ( ) ; if ( dirName . equals ( ".." ) ) { if ( ftpPath . equals ( "/" ) ) { ftpFiles = serverConnect . list ( ) ; setFtpTableData ( ftpFiles ) ; } else { if ( ftpPath . lastIndexOf ( "/" ) == 0 ) { serverConnect . cwd ( "/" ) ; ftpFiles = serverConnect . list ( ) ; setFtpTableData ( ftpFiles ) ; } else { ftpPath = ftpPath . substring ( 0 , ftpPath . lastIndexOf ( "/" ) ) ; serverConnect . cwd ( ftpPath ) ; ftpFiles = serverConnect . list ( ) ; setFtpTableData ( ftpFiles ) ; } } } else { if ( ftpPath . equals ( "/" ) ) ftpPath = ftpPath + dirName ; else ftpPath = ftpPath + "/" + dirName ; serverConnect . cwd ( ftpPath ) ; ftpFiles = serverConnect . list ( ) ; setFtpTableData ( ftpFiles ) ; } } catch ( IOException | ConnectionException e ) { throwException ( e ) ; } } } . start ( ) ; }
tr	8	private void bfs ( State s ) { s . id = - 1 ; Loc f = map . finish ; int counter = 0 ; LinkedList < Node > frontier = new LinkedList < Node > ( ) ; Set < State > explored = new HashSet < State > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( s , null , 0 ) ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state , f ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } System . out . println ( "found goal!" ) ; System . out . println ( "moves: " + solution . size ( ) ) ; mSolutions . addAll ( solution ) ; return ; } explored . add ( current . state ) ; if ( counter % 5000 == 0 ) { System . out . print ( "\n" ) ; } ; if ( counter % 50 == 0 ) { System . out . print ( "." ) ; } ; ArrayList < State > possibles = getMovesCorrectlyPlease ( current . state ) ; for ( int i = 0 ; i < possibles . size ( ) ; i ++ ) { State possib = possibles . get ( i ) ; if ( ! explored . contains ( possib ) ) { frontier . addLast ( new Node ( possib , current , current . distance + 1 ) ) ; } } counter ++ ; } if ( solution . isEmpty ( ) ) { System . out . println ( "FAILED TO FIND SOLUTION" ) ; } }
tr	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
tr	4	public void editFile ( int fileInodeNum ) throws PermissionDeniedException , FileNotFoundException { Inode fileInode = new Inode ( fileInodeNum ) ; if ( Directory . isReadable ( fileInode ) ) { if ( fileInode . getFileType ( ) == r ) { File tempFile = null ; String content = fileInode . getFileContent ( ) ; try { tempFile = new File ( Disk . tmpFolder . toString ( ) + "/" + fileInodeNum + ".txt" ) ; if ( tempFile . exists ( ) ) { tempFile . delete ( ) ; tempFile . createNewFile ( ) ; } tempFile . deleteOnExit ( ) ; RandomAccessFile tempRF = new RandomAccessFile ( tempFile , "rw" ) ; tempRF . writeBytes ( content ) ; Desktop . getDesktop ( ) . open ( tempFile ) ; tempRF . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else throw new PermissionDeniedException ( ) ; }
tr	1	private void addButtonActionPerformed ( java . awt . event . ActionEvent evt ) { try { DbUtil . addCat ( jTextField1 . getText ( ) , Integer . parseInt ( jTextField2 . getText ( ) ) ) ; jTextField1 . setText ( "" ) ; jTextField2 . setText ( "" ) ; list1 . removeAll ( ) ; onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Cat . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	8	@ Override public void close ( ) throws IOException { if ( os != null ) { try { os . flush ( ) ; os . close ( ) ; os = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fs != null ) { try { fs . close ( ) ; fs = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( is != null ) { try { is . close ( ) ; is = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fi != null ) { try { fi . close ( ) ; fi = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } connectionInStatus = false ; connectionOutStatus = false ; }
tr	5	public void clicked ( Vec2f gamePosition ) { Vec2i mapPosition = new Vec2i ( ( int ) ( gamePosition . x / SQUARE_SIZE ) , ( int ) ( gamePosition . y / SQUARE_SIZE ) ) ; if ( isPlayerUnit ( mapPosition ) ) { Unit unit = units . get ( mapPosition ) ; unit . select ( ) ; if ( selected != null && ! selected . equals ( unit ) ) { selected . unselect ( ) ; } selected = unit ; } else { if ( selected != null && isPassable ( mapPosition ) ) { getPathTo ( selected , mapPosition ) ; } } }
tr	3	public int contarAmigos ( String correo ) { ControlVentanas . configArchivoAmigos ( correo ) ; ControlVentanas . crearRandom ( ) ; int cont = 0 ; try { long puntero = 0 ; ControlVentanas . registros . seek ( puntero ) ; while ( ControlVentanas . registros . getFilePointer ( ) < ControlVentanas . registros . length ( ) ) { ControlVentanas . registros . seek ( puntero ) ; String c = ControlVentanas . registros . readUTF ( ) ; ControlVentanas . registros . readBoolean ( ) ; ControlVentanas . registros . readBoolean ( ) ; puntero = ControlVentanas . registros . getFilePointer ( ) ; if ( ControlVentanas . verificarCuentaActiva ( c ) ) cont ++ ; } ControlVentanas . registros . close ( ) ; } catch ( IOException ex ) { System . out . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } return cont ; }
tr	0	@ AfterClass public static void tearDownClass ( ) throws Exception { }
tr	1	@ Override public boolean equals ( Object obj ) { if ( obj instanceof GRGProteinNode ) { GRGProteinNode other = ( GRGProteinNode ) obj ; return this . node . equals ( other . node ) ; } else { return false ; } }
tr	2	protected void criarMetaObjeto ( ) { framePai . dispose ( ) ; switch ( listaSemiPontos . size ( ) ) { case 1 : this . criarPonto ( ) ; break ; case 2 : this . criarReta ( ) ; break ; default : this . criarPoligono ( ) ; } }
tr	4	private static Object [ ] subseq ( Object [ ] ary , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == ary . length ) return ary ; else { int len = hi - lo ; Object [ ] a = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) a [ i ] = ary [ i + lo ] ; return a ; } }
tr	9	@ Override public void buttonA ( boolean pressed ) { if ( enabled ) { if ( ses2 != null ) { setFlagsFalse ( ) ; if ( future != null ) { future . cancel ( true ) ; } } if ( pressed == true ) { aFlag = true ; dllProc . dll_keyPressed ( container . xgetCurrentPreset ( ) . xgetAAssignedKeyCode ( ) ) ; if ( container . xgetCurrentPreset ( ) . isArepetitionEnabled ( ) ) { keyTask = new KeyboardTask ( ) ; future = ses2 . scheduleAtFixedRate ( keyTask , container . xgetCurrentPreset ( ) . xgetAInitialDelay ( ) , container . xgetCurrentPreset ( ) . xgetARepeatDelay ( ) , TimeUnit . MILLISECONDS ) ; } } else if ( pressed == false ) { aFlag = false ; if ( ses2 != null ) { if ( future != null ) { future . cancel ( true ) ; } } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetAAssignedKeyCode ( ) ) ; } } else { if ( future != null ) { future . cancel ( true ) ; } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetAAssignedKeyCode ( ) ) ; } }
tr	2	public synchronized void produce ( ) { try { if ( product != 0 ) { wait ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } product = 1 ; System . out . println ( "Producer produce : " + product ) ; notifyAll ( ) ; }
tr	9	private void updateTimeslot ( ) { final int [ ] selectedIndices = subjectList . getSelectedIndices ( ) ; for ( final int index : selectedIndices ) { final Subject subject = subjectListModel . getSubjectAt ( index ) ; timeslot . addSubject ( subject ) ; if ( clazz instanceof Schoolclass ) { if ( timeslot . getTeachers ( ) . size ( ) > 0 ) { for ( Teacher teacher : timeslot . getTeachers ( ) ) { try { Timeslot timeslotTeacher = Data . getDayTableForWeekday ( weekday , teacher ) . getTimeslot ( position ) ; timeslotTeacher . addSubject ( subject ) ; TimetableManager . updateTimeslot ( timeslotTeacher ) ; } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } } if ( clazz instanceof Teacher ) { if ( timeslot . getSchoolclasses ( ) . size ( ) > 0 ) { for ( Schoolclass schoolclass : timeslot . getSchoolclasses ( ) ) { try { Timeslot timeslotSchoolclass = Data . getDayTableForWeekday ( weekday , schoolclass ) . getTimeslot ( position ) ; timeslotSchoolclass . addSubject ( subject ) ; TimetableManager . updateTimeslot ( timeslotSchoolclass ) ; } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } } try { TimetableManager . updateTimeslot ( timeslot ) ; } catch ( DatasetException ex ) { LOGGER . error ( "Exception while updating timeslot " + timeslot , ex ) ; ErrorHandler . criticalDatasetError ( ) ; } } }
tr	4	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	6	@ Override public void onPaint ( DrawingInterface g , int width , int height ) { if ( state == STATE_TEMP_ONCE || state == STATE_TEMP_ALWAYS ) { g . gSetColor ( Skin . LINE ) ; g . gDrawLine ( Dim . X ( 6 ) , Dim . Y ( 53 ) , Dim . X ( 6 ) + Dim . W ( 88 ) , Dim . Y ( 53 ) ) ; } else if ( ( state == STATE_PICK_COLORS || state == STATE_DETECT_COLORS ) && digitInput . colors != null ) { int i = 0 ; for ( Integer col : digitInput . colors ) { i += 4 ; g . gSetColor ( col ) ; g . gFillRectangle ( Dim . X ( 5 + i ) , img . getY ( ) + Dim . H ( img . h + 3 ) , Dim . W ( 3 ) , Dim . H ( 5 ) ) ; } } }
tr	8	private boolean r_perfective_gerund ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 9 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	9	public static Method getMostSpecificMethod ( Method method , class < ? > targetClass ) { if ( method != null && isOverridable ( method , targetClass ) && targetClass != null && ! targetClass . equals ( method . getDeclaringClass ( ) ) ) { try { if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { try { return targetClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException ex ) { return method ; } } else { Method specificMethod = ReflectionUtils . findMethod ( targetClass , method . getName ( ) , method . getParameterTypes ( ) ) ; return ( specificMethod != null ? specificMethod : method ) ; } } catch ( SecurityException ex ) { } } return method ; }
tr	6	public static Map < String , boolean > getAllChildren ( final String node , final Set < String > playerPermArray ) { final LinkedList < String > stack = new LinkedList < String > ( ) ; final Map < String , boolean > alreadyVisited = new HashMap < String , boolean > ( ) ; stack . push ( node ) ; alreadyVisited . put ( node , true ) ; while ( ! stack . isEmpty ( ) ) { final String now = stack . pop ( ) ; final Map < String , boolean > children = AdminPerms . getChildren ( now ) ; if ( children != null && ! playerPermArray . contains ( "-" + now ) ) { for ( final String childName : children . keySet ( ) ) { if ( ! alreadyVisited . containsKey ( childName ) ) { stack . push ( childName ) ; alreadyVisited . put ( childName , children . get ( childName ) ) ; } } } } alreadyVisited . remove ( node ) ; if ( ! alreadyVisited . isEmpty ( ) ) { return alreadyVisited ; } return null ; }
tr	3	public Giocatore getPlayer ( String nomeGiocatore ) { if ( exists ( nomeGiocatore ) ) { Iterator < Giocatore > itGiocatori = iterator ( ) ; Giocatore tempGiocatore = null ; while ( itGiocatori . hasNext ( ) ) { tempGiocatore = itGiocatori . next ( ) ; if ( tempGiocatore . getNome ( ) . equals ( nomeGiocatore ) ) break ; } return tempGiocatore ; } else return null ; }
tr	3	public static Card getBestTrickLeadCard ( GameState gameState , StrategicRoundState strategicRoundState ) { String myId = gameState . id ; RuleSet ruleSet = gameState . ruleSet ; boolean oughtOughtLead = strategicRoundState . getMyHand ( ) . contains ( new Card ( "0/0" ) ) ; boolean oughtOughtPlayed = oughtOughtLead ; Suit trump = strategicRoundState . getTrump ( ) ; AnnotatedHand annotatedHand = strategicRoundState . getAnnotatedHand ( ) ; Collections . sort ( annotatedHand , new IntrinsicOrderCardComparator ( trump , ruleSet , oughtOughtLead , oughtOughtPlayed ) ) ; for ( Suit s : Suit . getAllSuits ( ) ) { List < AnnotatedCard > allPlayableCards = annotatedHand . getAllWinnableCards ( s , trump , oughtOughtLead , oughtOughtPlayed , ruleSet ) ; if ( allPlayableCards . size ( ) > 0 ) { AnnotatedCard bestPlayableCard = allPlayableCards . get ( allPlayableCards . size ( ) - 1 ) ; if ( bestPlayableCard . isInPlayersHand ( myId ) ) { return bestPlayableCard ; } } } Hand < Card > myHand = annotatedHand . getAllCardsInPlayersHand ( myId ) ; Collections . sort ( myHand , new PointIOCardComparator ( trump , gameState . ruleSet , oughtOughtLead , oughtOughtPlayed ) ) ; return myHand . get ( 0 ) ; }
tr	5	public void addScope ( class < ? extends Annotation > annotationType , Scope scope ) { if ( annotationType == null ) { throw new IllegalArgumentException ( "annotationType" ) ; } if ( scope == null ) { throw new IllegalArgumentException ( "scope" ) ; } Scope put = scopes . putIfAbsent ( annotationType , scope ) ; if ( put != null && put != scope ) { throw new RuntimeException ( ) ; } class < Scope > type = ( class < Scope > ) scope . getClass ( ) ; addInstance ( type , null , scope ) ; }
tr	7	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	5	@ Override public void run ( ) { while ( beatWork ) { heartRate = messageResource . getHR ( ) ; if ( heartRate != 0 ) { int sleep = 1000 / heartRate ; try { Thread . sleep ( 40 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 1 ) ; try { Thread . sleep ( 20 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 0 ) ; } else { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
tr	7	public static int [ ] getPrimes ( int max ) { int [ ] primes = new int [ max + 1 ] ; for ( int i = 2 ; i <= max ; i ++ ) { primes [ i ] = i ; } int total = max - 1 ; for ( int i = 2 ; i <= Math . sqrt ( max ) ; i ++ ) { for ( int j = i ; j <= max ; ) { j += i ; if ( j <= max && primes [ j ] > 0 ) { primes [ j ] = 0 ; total -- ; } } } int [ ] totalprimes = new int [ total ] ; int temp = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > 0 ) { totalprimes [ temp ] = primes [ i ] ; temp ++ ; } } return totalprimes ; }
tr	3	@ Override protected void generateXML ( BufferedWriter out ) throws IOException { for ( int i = 0 ; i < this . answers . size ( ) ; i ++ ) { out . write ( "\t\t<choice" ) ; if ( i == this . correctAnswer ) out . write ( " correct=\"true\"" ) ; if ( i == this . selectedAnswer ) out . write ( " selected=\"true\"" ) ; out . write ( ">" ) ; out . write ( this . answers . get ( i ) ) ; out . write ( "</choice>\n" ) ; out . flush ( ) ; } }
tr	6	public int largestRectangleArea2 ( int [ ] height ) { if ( height == null || height . length == 0 ) return 0 ; int max = 0 ; int i = 0 ; while ( i < height . length ) { int k = i ; while ( k < height . length - 1 ) { if ( height [ k ] > height [ k + 1 ] ) { break ; } k ++ ; } i = k ; int lowest = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { lowest = Math . min ( lowest , height [ j ] ) ; int val = ( i - j + 1 ) * lowest ; max = Math . max ( max , val ) ; } i ++ ; } return max ; }
tr	7	private void updatePlayerList ( Buffer stream , int count ) { while ( stream . bitPosition + 10 < count * 8 ) { int pId = stream . readBits ( 11 ) ; if ( pId == 2047 ) break ; if ( players [ pId ] == null ) { players [ pId ] = new Player ( ) ; if ( playerAppearanceData [ pId ] != null ) players [ pId ] . updatePlayerAppearance ( playerAppearanceData [ pId ] ) ; } localPlayers [ localPlayerCount ++ ] = pId ; Player player = players [ pId ] ; player . lastUpdateTick = tick ; int observed = stream . readBits ( 1 ) ; if ( observed == 1 ) playersObserved [ playersObservedCount ++ ] = pId ; int teleported = stream . readBits ( 1 ) ; int x = stream . readBits ( 5 ) ; if ( x > 15 ) x -= 32 ; int y = stream . readBits ( 5 ) ; if ( y > 15 ) y -= 32 ; player . setPos ( localPlayer . waypointX [ 0 ] + y , localPlayer . waypointY [ 0 ] + x , teleported == 1 ) ; } stream . finishBitAccess ( ) ; }
tr	4	public void render ( Graphics g ) { i ++ ; if ( i >= 15 ) { animationStep ++ ; animationStep %= 3 ; image = sheet . getSprite ( "boss_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 8 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
tr	3	public static < K , V > OrderedMap < K , V > sort ( final Map < K , V > map , final Comparator < Map . Entry < K , V >> comparator ) { if ( map == null ) return new OrderedMap < > ( ) ; final List < Map . Entry < K , V >> listEntries = new LinkedList < Map . Entry < K , V >> ( map . entrySet ( ) ) ; if ( comparator != null ) Collections . sort ( listEntries , comparator ) ; final OrderedMap < K , V > newOrderedMap = new OrderedMap < K , V > ( ) ; for ( final Map . Entry < K , V > entry : listEntries ) newOrderedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; return newOrderedMap ; }
tr	9	public Point getConnectionPoint ( Point ep ) { Point A = new Point ( position . x , position . y ) ; Point B = new Point ( position . x + getWidth ( ) , position . y ) ; Point C = new Point ( position . x , position . y + getHeight ( ) ) ; Point D = new Point ( position . x + getWidth ( ) , position . y + getHeight ( ) ) ; double distAB = new Line2D . float ( A , B ) . ptLineDist ( ep ) ; double distBD = new Line2D . float ( B , D ) . ptLineDist ( ep ) ; double distDC = new Line2D . float ( D , C ) . ptLineDist ( ep ) ; double distAC = new Line2D . float ( A , C ) . ptLineDist ( ep ) ; if ( distAB < distBD && distAB < distDC && distAB < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , position . y ) ; } else if ( distBD < distAB && distBD < distDC && distBD < distAC ) { return new Point ( ( position . x + getWidth ( ) ) , ( position . y + getHeight ( ) ) ) ; } else if ( distDC < distAB && distDC < distBD && distDC < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , ( position . y + getHeight ( ) ) ) ; } else if ( distAC < distAB && distAC < distBD && distAC < distDC ) { return new Point ( position . x , ( position . y + getHeight ( ) ) / 2 ) ; } else { return null ; } }
tr	4	@ Override public void actionPerformed ( ActionEvent e ) { if ( comboPlayerType . getSelectedIndex ( ) > 0 ) { textPlayerName . setText ( comboPlayerType . getSelectedItem ( ) . toString ( ) ) ; textPlayerName . setEditable ( false ) ; if ( comboPlayerType . getSelectedIndex ( ) == 1 || comboPlayerType . getSelectedIndex ( ) == 2 || comboPlayerType . getSelectedIndex ( ) == 4 ) { this . simulationNumber = Integer . parseInt ( JOptionPane . showInputDialog ( "Enter simulation number per move" ) ) ; } } else { textPlayerName . setEditable ( true ) ; textPlayerName . setText ( this . defaultPlayerName ) ; } }
tr	0	public Parler ( String message ) { this ( 0 , message ) ; }
tr	3	public void setContent ( ChannelBuffer content ) { if ( content == null ) { content = ChannelBuffers . EMPTY_BUFFER ; } if ( content . readable ( ) && isChunked ( ) ) { throw new IllegalArgumentException ( "non-empty content disallowed if this.chunked == true" ) ; } this . content = content ; }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
