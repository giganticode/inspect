te	2	public void run ( ) { try { while ( true ) { Thread . sleep ( 20 ) ; progress . setMaximum ( sim . getTotalTime ( ) ) ; progress . setValue ( sim . getTime ( ) ) ; } } catch ( InterruptedException ie ) { } }
te	4	public static void main ( String [ ] args ) { int a = 0 ; int b = 1 ; int c = 1 ; long d = 0 ; long e = 1 ; long f = 1 ; int count = 1 ; while ( true ) { count ++ ; c = ( a + b ) % 1000000000 ; a = b ; b = c ; f = d + e ; d = e ; e = f ; if ( f > 1000000000000000000 ) { d /= 10 ; e /= 10 ; } if ( pandigital ( f ) && pandigital ( c ) ) { break ; } } System . out . println ( count ) ; }
te	8	public boolean isValidBet ( Bet bet , Player player ) { int indexPlayer = findIndexPlayer ( player ) ; if ( bet != null && indexPlayer != - 1 ) { for ( int i = 0 ; i < indexPlayer ; ++ i ) { if ( this . players [ i ] != null && this . players [ i ] . getOriginalBet ( ) != null ) { if ( this . players [ i ] . getOriginalBet ( ) . getNbRounds ( ) > bet . getNbRounds ( ) ) { return false ; } else if ( this . players [ i ] . getOriginalBet ( ) . getNbRounds ( ) == bet . getNbRounds ( ) ) { if ( this . players [ i ] . getOriginalBet ( ) . getSuit ( ) . getValue ( ) >= bet . getSuit ( ) . getValue ( ) ) { return false ; } } } } } return true ; }
te	7	@ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( ! ( o instanceof Pair ) ) return false ; Pair < ? , ? > pairo = ( Pair < ? , ? > ) o ; return this . left . equals ( pairo . getLeft ( ) ) && this . right . equals ( pairo . getRight ( ) ) ; }
te	8	@ Test public void testPertenece1 ( ) { boolean expected = true ; boolean actual = arbolito . pertenece ( 8 ) && arbolito . pertenece ( 3 ) && arbolito . pertenece ( 6 ) && arbolito . pertenece ( 1 ) && arbolito . pertenece ( 10 ) && arbolito . pertenece ( 4 ) && arbolito . pertenece ( 7 ) && arbolito . pertenece ( 14 ) && arbolito . pertenece ( 13 ) ; assertEquals ( expected , actual ) ; }
te	6	public static void drawString ( String string , float x , float y , float z , float scale , boolean centered ) { texture . bind ( ) ; if ( string . length ( ) == 0 ) return ; scale /= 1000 ; x -= ( Main . WIDTH / 2 + 350 ) * scale ; y -= ( Main . HEIGHT + 260 ) * scale ; float currentXOffset = 0 ; float currentYOffset = 0 ; float centeredOffset = 0 ; if ( centered ) { float temp = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) temp += glyphs . get ( string . charAt ( i ) ) . getWidth ( ) * scale + spacingX * scale ; centeredOffset = - temp / 2 ; } for ( int i = 0 ; i < string . length ( ) ; i ++ ) { char character = string . charAt ( i ) ; if ( character == '' ) { currentYOffset -= glyphHeight * scale + spacingY ; centeredOffset = 0 ; continue ; } if ( ! glyphs . containsKey ( character ) ) continue ; Glyph glyph = glyphs . get ( character ) ; glyph . render ( x + currentXOffset + centeredOffset , y + currentYOffset , z , scale ) ; currentXOffset += glyph . getWidth ( ) * scale + spacingX * scale ; } }
te	5	private static byte method513 ( char c ) { if ( c >= a && c <= z ) return ( byte ) ( ( c - 97 ) + 1 ) ; if ( c == ' ) return 28 ; if ( c >= 0 && c <= 9 ) return ( byte ) ( ( c - 48 ) + 29 ) ; else return 27 ; }
te	0	public DualWedgeB ( final Material [ ] materials , final int orientation ) { super ( materials , true , true , true , true , true , true ) ; this . orientation = orientation ; }
te	4	private static void initBitmap ( int [ ] freeBlockBitmapNo ) { try { for ( int j = 0 ; j < 4 ; j ++ ) { Block bitMapBlock = new Block ( freeBlockBitmapNo [ j ] , "r" ) ; byte ip ; for ( int i = 0 ; i < bitMapBlock . length ( ) ; i ++ ) { ip = bitMapBlock . readByte ( ) ; FreeSpaceMgnt . freeBlockBitmap [ j * Disk . maxBlockSize + i ] = ( byte ) ( ip - 48 ) ; } bitMapBlock . close ( ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	9	@ SuppressWarnings ( "unchecked" ) public Variant invoke ( String methodName , Variant targetParameters [ ] ) { Variant mVariantToBeReturned = null ; if ( mTargetObject == null ) { if ( IUnknown . isDebugEnabled ( ) ) { IUnknown . debug ( "InvocationProxy: received notification (" + methodName + ") with no target set" ) ; } return null ; } class targetClass = mTargetObject . getClass ( ) ; if ( methodName == null ) { throw new IllegalArgumentException ( "InvocationProxy: missing method name" ) ; } if ( targetParameters == null ) { throw new IllegalArgumentException ( "InvocationProxy: missing Variant parameters" ) ; } try { if ( IUnknown . isDebugEnabled ( ) ) { IUnknown . debug ( "InvocationProxy: trying to invoke " + methodName + " on " + mTargetObject ) ; } Method targetMethod ; targetMethod = targetClass . getMethod ( methodName , new class [ ] { Variant [ ] . class } ) ; if ( targetMethod != null ) { Object mReturnedByInvocation = null ; mReturnedByInvocation = targetMethod . invoke ( mTargetObject , new Object [ ] { targetParameters } ) ; if ( mReturnedByInvocation == null ) { mVariantToBeReturned = null ; } else if ( ! ( mReturnedByInvocation instanceof Variant ) ) { throw new IllegalArgumentException ( "InvocationProxy: invokation of target method returned " + "non-null non-variant object: " + mReturnedByInvocation ) ; } else { mVariantToBeReturned = ( Variant ) mReturnedByInvocation ; } } } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { if ( IUnknown . isDebugEnabled ( ) ) { IUnknown . debug ( "InvocationProxy: listener (" + mTargetObject + ") doesn't implement " + methodName ) ; } } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; throw e ; } catch ( IllegalAccessException e ) { if ( IUnknown . isDebugEnabled ( ) ) { IUnknown . debug ( "InvocationProxy: probably tried to access public method on non public class" + methodName ) ; } e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } return mVariantToBeReturned ; }
te	5	Move rootAlphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL2 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
te	8	private void addStep ( double startPrice , double endPrice , double fixedPrice , double variablePricePercent ) { if ( billingServerSecure == null ) { System . out . println ( "ERROR: You are currently not logged in" ) ; } else if ( endPrice != 0 && startPrice >= endPrice ) { System . out . println ( "ERROR: Negative or empty interval range" ) ; } else { try { billingServerSecure . createPriceStep ( startPrice , endPrice , fixedPrice , variablePricePercent ) ; System . out . println ( "Step [" + startPrice + " " + ( endPrice == 0 ? "INFINITY" : endPrice ) + "] successfully added" ) ; } catch ( RemoteException ex ) { if ( ex . getCause ( ) != null ) { Throwable t = ex . getCause ( ) ; if ( t instanceof PriceStepIntervalCollisionException ) { System . out . println ( "ERROR: PriceStep overlaps with existing PriceStep" ) ; } else if ( t instanceof PriceStepNegativeArgumentException ) { System . out . println ( "ERROR: Only positive arguments allowed" ) ; } else { logger . error ( "Billing Server Remote Exception" ) ; } } else { logger . error ( "Billing Server Remote Exception" ) ; } } } }
te	8	protected void onUpdateResultDetails ( final String strPK ) { if ( strPK == null ) { m_lbDetailsSmiles . setText ( "Select a result item to show details." ) ; m_lbDetailsStructureGif . setIcon ( null ) ; m_lbDetailsStructureGif . setText ( null ) ; m_strLastSelectedPK = null ; } else if ( ! strPK . equals ( m_strLastSelectedPK ) ) { m_strLastSelectedPK = strPK ; boolean bNoInformation = false ; m_lbDetailsStructureGif . setText ( null ) ; try { final Document doc = m_index . searchMoleculeByPK ( strPK ) ; if ( doc != null ) { final String strSmiles = doc . get ( ChemicalIndex . FIELD_SMILES ) ; if ( strSmiles != null && ! strSmiles . trim ( ) . isEmpty ( ) ) { final Dimension dim = m_lbDetailsSmiles . getParent ( ) . getSize ( ) ; final Icon iconStructure = getSmilesIcon ( strSmiles , dim . width - 50 , dim . height - 50 ) ; m_lbDetailsSmiles . setText ( strSmiles ) ; m_lbDetailsSmiles . setToolTipText ( strSmiles ) ; m_lbDetailsStructureGif . setIcon ( iconStructure ) ; if ( iconStructure == null ) { m_lbDetailsStructureGif . setText ( "Unable to render SMILES" ) ; } } else { bNoInformation = true ; } } else { bNoInformation = true ; } } catch ( final Exception exc ) { LOGGER . fine ( "No information available for PK " + strPK ) ; bNoInformation = true ; } if ( bNoInformation ) { m_lbDetailsSmiles . setText ( "No information available." ) ; m_lbDetailsStructureGif . setIcon ( null ) ; } } }
te	3	public static void main ( String [ ] args ) { ExecutorService es = Executors . newCachedThreadPool ( ) ; final IDLockManager lm = new IDLockManager ( ) ; final String [ ] ids = new String [ ] { "a" , "b" , "c" } ; for ( int i = 0 ; i < 20 ; i ++ ) { final int x = i ; Runnable task = new Runnable ( ) { public void run ( ) { int count = 0 ; while ( true ) { count ++ ; try { String id = ids [ r . nextInt ( ids . length ) ] ; lm . lockID ( id ) ; try { Thread . sleep ( r . nextInt ( 300 ) ) ; } finally { lm . unlockID ( id ) ; debug ( "******************* " + x + "/" + count , id ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; es . submit ( task ) ; } }
te	6	public ArrayList < double > run ( ) { for ( int i = 0 ; i < connections . size ( ) ; i ++ ) { if ( connections . get ( i ) . getGiveNeuron ( ) == null ) System . out . println ( "Error 1:: NeuralNetwork 368" ) ; if ( connections . get ( i ) . getRecieveNeuron ( ) == null ) System . out . println ( "Error 2:: NeuralNetwork 369" ) ; if ( connections . get ( i ) . getGiveNeuron ( ) . equals ( connections . get ( i ) . getRecieveNeuron ( ) ) ) { System . out . println ( "Recurrent connection found. Removing. :: NeuralNetwork 361" ) ; connections . remove ( connections . get ( i ) ) ; } } ArrayList < OutputNeuron > outputNs = findOutputs ( ) ; ArrayList < InputNeuron > inpuNs = findInputs ( ) ; ArrayList < double > results = new ArrayList < > ( ) ; for ( int i = 0 ; i < inpuNs . size ( ) ; i ++ ) inputs . set ( i , 1.0 ) ; for ( int i = 0 ; i < outputNs . size ( ) ; i ++ ) { outputNs . get ( i ) . evaluate ( ) ; results . add ( outputNs . get ( i ) . getOutput ( ) ) ; } nextGeneration ( ) ; return results ; }
te	4	private void init ( ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JPanel tmp = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; JButton btn = new JButton ( "  GO!  " ) ; tmp . add ( txt ) ; tmp . add ( btn ) ; btn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { loadPage ( txt . getText ( ) ) ; } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } } ) ; txt . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { loadPage ( txt . getText ( ) ) ; } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } } ) ; JTabbedPane tab = new JTabbedPane ( JTabbedPane . TOP ) ; tab . addTab ( "SwingBox" , new JScrollPane ( swingbox ) ) ; tab . addTab ( "CSSBox" , contentScroll ) ; tab . addTab ( "JEditorPane + HTMLEditorKit" , new JScrollPane ( editorkit ) ) ; panel . add ( tmp , BorderLayout . NORTH ) ; panel . add ( tab , BorderLayout . CENTER ) ; setContentPane ( panel ) ; swingbox . addHyperlinkListener ( new BrowserComparisonHyperlinkHandler ( this ) ) ; swingbox . addGeneralEventListener ( new GeneralEventListener ( ) { private long time ; @ Override public void generalEventUpdate ( GeneralEvent e ) { if ( e . event_type == EventType . page_loading_begin ) { time = System . currentTimeMillis ( ) ; } else if ( e . event_type == EventType . page_loading_end ) { System . out . println ( "SwingBox: page loaded in: " + ( System . currentTimeMillis ( ) - time ) + " ms" ) ; } } } ) ; editorkit . setEditorKit ( new HTMLEditorKit ( ) ) ; editorkit . setEditable ( false ) ; editorkit . addHyperlinkListener ( new HyperlinkListener ( ) { @ Override public void hyperlinkUpdate ( HyperlinkEvent e ) { } } ) ; contentScroll . setViewportView ( cssbox ) ; contentScroll . addComponentListener ( new java . awt . event . ComponentAdapter ( ) { @ Override public void componentResized ( java . awt . event . ComponentEvent e ) { if ( cssbox != null && cssbox instanceof BrowserCanvas ) { ( ( BrowserCanvas ) cssbox ) . createLayout ( contentScroll . getSize ( ) ) ; contentScroll . repaint ( ) ; } } } ) ; setResizable ( true ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setPreferredSize ( new Dimension ( 1200 , 1000 ) ) ; setTitle ( "Demo" ) ; pack ( ) ; setLocationRelativeTo ( null ) ; setVisible ( true ) ; }
te	7	public void processMsg ( ) { switch ( state_ ) { case RFBSTATE_PROTOCOL_VERSION : processVersionMsg ( ) ; break ; case RFBSTATE_SECURITY_TYPES : processSecurityTypesMsg ( ) ; break ; case RFBSTATE_SECURITY : processSecurityMsg ( ) ; break ; case RFBSTATE_SECURITY_RESULT : processSecurityResultMsg ( ) ; break ; case RFBSTATE_INITIALISATION : processInitMsg ( ) ; break ; case RFBSTATE_NORMAL : reader_ . readMsg ( ) ; break ; case RFBSTATE_UNINITIALISED : throw new Exception ( "CConnection.processMsg: not initialised yet?" ) ; default : throw new Exception ( "CConnection.processMsg: invalid state" ) ; } }
te	4	public void checkGameInitializing ( ) { if ( this . playerOne != null && this . playerTwo != null && this . battlefieldPlayerOne != null && this . battlefieldPlayerTwo != null ) { this . setGameReady ( ) ; } }
te	6	public Invite [ ] findByDynamicSelect ( String sql , Object [ ] sqlParams ) throws InviteDaoException { final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; final String SQL = sql ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL ) ; } stmt = conn . prepareStatement ( SQL ) ; stmt . setMaxRows ( maxRows ) ; for ( int i = 0 ; sqlParams != null && i < sqlParams . length ; i ++ ) { stmt . setObject ( i + 1 , sqlParams [ i ] ) ; } rs = stmt . executeQuery ( ) ; return fetchMultiResults ( rs ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( rs ) ; ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
te	6	@ Override public int hashCode ( ) { int result = popProveedorId != null ? popProveedorId . hashCode ( ) : 0 ; result = 31 * result + ( popNitProveedor != null ? popNitProveedor . hashCode ( ) : 0 ) ; result = 31 * result + ( popNombreProveedor != null ? popNombreProveedor . hashCode ( ) : 0 ) ; result = 31 * result + ( popUsuario != null ? popUsuario . hashCode ( ) : 0 ) ; result = 31 * result + ( popTerminal != null ? popTerminal . hashCode ( ) : 0 ) ; result = 31 * result + ( popFecmod != null ? popFecmod . hashCode ( ) : 0 ) ; return result ; }
te	1	public void setYUVtoRGB ( YUVtoRGB yuv2rgb ) { if ( yuv2rgb == null ) throw new NullPointerException ( ) ; m_videoDecoder . setYUVtoRGB ( yuv2rgb ) ; }
te	1	public Node vet ( int cell ) { Node node = get ( cell ) ; if ( node == null ) { node = new Node ( ) ; set ( cell , node ) ; } return node ; }
te	8	public static String findParameterValue ( Map < String , ? > parameters , String name ) { Object value = parameters . get ( name ) ; if ( value instanceof String [ ] ) { String [ ] values = ( String [ ] ) value ; return ( values . length > 0 ? values [ 0 ] : null ) ; } else if ( value != null ) { return value . toString ( ) ; } String prefix = name + "_" ; for ( String paramName : parameters . keySet ( ) ) { if ( paramName . startsWith ( prefix ) ) { for ( String suffix : SUBMIT_IMAGE_SUFFIXES ) { if ( paramName . endsWith ( suffix ) ) { return paramName . substring ( prefix . length ( ) , paramName . length ( ) - suffix . length ( ) ) ; } } return paramName . substring ( prefix . length ( ) ) ; } } return null ; }
te	5	public boolean checkValidity ( BeanConceptos bean ) { boolean valid = true ; if ( bean . nombre . trim ( ) . equals ( "" ) ) { return false ; } String SQL1 = "SELECT * FROM " + client . getPlusDbName ( ) + "sgd_conceptos WHERE idProfesores=" + bean . idProfesores + " AND idClase=" + bean . idClase + " AND nombreConcepto=? AND id<>" + bean . id ; try { PreparedStatement st = client . getPlusDb ( ) . createPreparedStatement ( SQL1 ) ; ResultSet rs1 = client . getPlusDb ( ) . getPreparedResultSet ( new Object [ ] { bean . nombre } , st ) ; if ( rs1 != null && rs1 . next ( ) ) { valid = false ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Conceptos . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return valid ; }
te	5	public void update ( FriendshStatusPk pk , FriendshStatus dto ) throws FriendshStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getFriendshStatus ( ) ) ; stmt . setString ( 2 , pk . getFriendshStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
te	9	public static TestInfo parseTestInfo ( JSONObject jsonObject ) { TestInfo testInfo = new TestInfo ( ) ; try { testInfo . setId ( jsonObject . getString ( "test_id" ) ) ; testInfo . setName ( jsonObject . getString ( "test_name" ) ) ; TestStatus status = null ; if ( jsonObject . has ( "status" ) ) { status = jsonObject . getString ( "status" ) . equals ( "Running" ) ? TestStatus . Running : TestStatus . NotRunning ; testInfo . setStatus ( status ) ; } testInfo . setError ( jsonObject . getString ( "error" ) . equals ( "null" ) ? null : jsonObject . getString ( "error" ) ) ; if ( jsonObject . has ( "options" ) ) { JSONObject responseOptions = jsonObject . getJSONObject ( "options" ) ; if ( responseOptions != null ) { int numberOfEngines = getEngines ( responseOptions ) ; int numberOfUsers = ( Integer ) responseOptions . get ( "USERS" ) ; testInfo . setNumberOfUsers ( ( numberOfUsers / ( numberOfEngines > 0 ? numberOfEngines : 1 ) ) * ( numberOfEngines + 1 ) ) ; testInfo . setType ( responseOptions . getString ( "TEST_TYPE" ) ) ; testInfo . setLocation ( responseOptions . getString ( "LOCATION" ) ) ; if ( responseOptions . getBoolean ( "OVERRIDE" ) ) { Overrides overrides = new Overrides ( responseOptions . getInt ( "OVERRIDE_DURATION" ) , responseOptions . getInt ( "OVERRIDE_ITERATIONS" ) , responseOptions . getInt ( "OVERRIDE_RAMP_UP" ) , responseOptions . getInt ( "OVERRIDE_THREADS" ) ) ; testInfo . setOverrides ( overrides ) ; } } } } catch ( JSONException je ) { BmLog . error ( "Error while creating TestInfo from JSON: " + je + "\n" + jsonObject . toString ( ) ) ; } catch ( ClassCastException cce ) { BmLog . error ( "Error while creating TestInfo from JSON: " + cce + "\n" + jsonObject . toString ( ) ) ; } catch ( ArithmeticException ae ) { BmLog . error ( "Error while creating TestInfo from JSON: " + ae + "\n" + jsonObject . toString ( ) ) ; } return testInfo ; }
te	8	public void cetakLaporan ( String pembeli , String telepon ) { boolean adaKesalahan = false ; Connection cn = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatement = "" ; try { Statement statement = cn . createStatement ( ) ; SQLStatement = "SELECT buku.`kode_buku` AS buku_kode_buku  " + "buku.`judul_buku` AS buku_judul_buku  " + "buku.`penerbit` AS buku_penerbit  " + "kwitansi.`no_beli` AS kwitansi_no_beli  " + "kwitansi.`kode_buku` AS kwitansi_kode_buku  " + "kwitansi.`Jumlah` AS kwitansi_Jumlah " + "kwitansi.`harga` AS kwitansi_harga  " + "(kwitansi.`harga`*kwitansi.`jumlah`) AS kwitansi_totalharga  " + "pembeli.`no_beli` AS pembeli_no_beli  " + "pembeli.`nama` AS pembeli_nama  " + "pembeli.`alamat` AS pembeli_alamat  " + "pembeli.`tlp` AS pembeli_tlp " + "FROM " + "`buku` buku INNER JOIN `kwitansi` kwitansi ON buku.`kode_buku` = kwitansi.`kode_buku` " + "INNER JOIN `pembeli` pembeli ON kwitansi.`no_beli` = pembeli.`no_beli` " ; if ( ! pembeli . equals ( " " ) ) { SQLStatement = SQLStatement + "where pembeli.`nama` like '%" + pembeli + "%'" ; if ( ! telepon . equals ( "" ) ) { SQLStatement = SQLStatement + " and pembeli.`tlp` like '%" + telepon + "%'" ; } } else { if ( ! telepon . equals ( "" ) ) { SQLStatement = SQLStatement + " where pembeli.`tlp`='" + telepon + "'" ; } } SQLStatement = SQLStatement + " ORDER BY " + "pembeli.`alamat` ASC  " + "pembeli.`tlp` ASC  " + "pembeli.`nama` ASC" ; JasperDesign disain = JRXmlLoader . load ( new File ( "" ) . getAbsolutePath ( ) + "/src/reports/KwitansiReport.jrxml" ) ; JasperReport nilaiLaporan = JasperCompileManager . compileReport ( disain ) ; ResultSet resultSet = statement . executeQuery ( SQLStatement ) ; JRResultSetDataSource resultSetDataSource = new JRResultSetDataSource ( resultSet ) ; JasperPrint cetak = JasperFillManager . fillReport ( nilaiLaporan , new HashMap ( ) , resultSetDataSource ) ; JasperViewer . viewReport ( cetak , false ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( null , "Gagal mencetak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } }
te	0	public Item rename ( String newname ) throws Exception { Request req = new Request ( "files?method=rename" ) ; Map < String , Object > params = req . getParams ( ) ; params . put ( "id" , id ) ; params . put ( "name" , newname ) ; return bind ( getResults ( req ) . get ( 0 ) , Item . class ) ; }
te	2	public boolean isOptOut ( ) { synchronized ( optOutLock ) { try { configuration . load ( getConfigFile ( ) ) ; } catch ( IOException ex ) { Bukkit . getLogger ( ) . log ( Level . INFO , "[Metrics] " + ex . getMessage ( ) ) ; return true ; } catch ( InvalidConfigurationException ex ) { Bukkit . getLogger ( ) . log ( Level . INFO , "[Metrics] " + ex . getMessage ( ) ) ; return true ; } return configuration . getBoolean ( "opt-out" , false ) ; } }
te	1	private JLabel getL_duration ( ) { if ( L_duration == null ) { L_duration = new JLabel ( ) ; L_duration . setText ( "Dauer in Stunden:" ) ; L_duration . setPreferredSize ( new java . awt . Dimension ( 121 , 19 ) ) ; } return L_duration ; }
te	3	public void swap ( ) { Random random = new Random ( ) ; int a = random . nextInt ( work . size ( ) ) ; while ( work . get ( a ) == FF ) { a = random . nextInt ( work . size ( ) ) ; System . out . println ( "a: FF found" ) ; } int b = random . nextInt ( work . size ( ) ) ; while ( work . get ( b ) == FF && a == b ) { b = random . nextInt ( work . size ( ) ) ; System . out . println ( "b: FF found" ) ; } byte value = work . get ( a ) ; work . set ( a , work . get ( b ) ) ; work . set ( b , value ) ; System . out . println ( "Swap Position a: " + a + " b: " + b ) ; }
te	4	private void addToList ( class < ? > c , Listener l ) { if ( map . containsKey ( c ) ) { if ( map . get ( c ) != null ) { if ( ! map . get ( c ) . contains ( l ) ) { map . get ( c ) . add ( l ) ; } } } }
te	0	@ Test public void incrementingNumbers ( ) { assertMapped ( ( Integer x ) -> x + 2 , asList ( 1 , 2 , 3 ) , asList ( 3 , 4 , 5 ) ) ; }
te	5	public List < Serie > getSerieBaseInfoByName ( String name ) throws ParserConfigurationException , SAXException , IOException { List < Serie > result = new ArrayList < Serie > ( ) ; URL getSeriesByNameUrl = new URL ( String . format ( Constants . GETSERIESBYNAME_URL , name ) . replace ( " " , "+" ) ) ; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; Document document = documentBuilder . parse ( getSeriesByNameUrl . openStream ( ) ) ; Element rootElement = document . getDocumentElement ( ) ; NodeList nodes = rootElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; if ( node . getNodeName ( ) . equals ( "Series" ) ) { Serie serie = new Serie ( ) ; NodeList childNodes = node . getChildNodes ( ) ; for ( int j = 0 ; j < childNodes . getLength ( ) ; ++ j ) { Node childNode = childNodes . item ( j ) ; if ( childNode . getNodeName ( ) . equals ( "seriesid" ) ) { serie . setId ( Integer . parseInt ( childNode . getTextContent ( ) ) ) ; } else if ( childNode . getNodeName ( ) . equals ( "SeriesName" ) ) { serie . setName ( childNode . getTextContent ( ) ) ; } } result . add ( serie ) ; } } return result ; }
te	1	private void botaoRemoverActionPerformed ( java . awt . event . ActionEvent evt ) { ProdutoDAO dao = new ProdutoDAO ( ) ; int resposta = JOptionPane . showConfirmDialog ( null , "Voce tem certeza que deseja excluir o produto selecionado?" , "?" , JOptionPane . YES_NO_OPTION ) ; if ( resposta == 0 ) { long id = long . valueOf ( ( String ) tabelaProduto . getModel ( ) . getValueAt ( tabelaProduto . getSelectedRow ( ) , 0 ) ) ; dao . remove ( dao . getProdutoById ( id ) ) ; } }
te	0	private IdentNode constIdent ( ) { IdentNode fu = new IdentNode ( read ( ID , "identifier" ) . text ( ) + "" ) ; return fu ; }
te	4	@ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } return ( super . equals ( o ) && target . equals ( ( ( SymbolicReference ) o ) . target ) ) ; }
te	4	public LUP_Decomposition ( CoMoMBasis basis , Position position , BigRational [ ] [ ] A , boolean in_place ) throws InconsistentLinearSystemException { this . basis = basis ; this . position = position ; size = A . length ; if ( in_place ) { A_prime = A ; } else { A_prime = new BigRational [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { A_prime [ i ] [ j ] = A [ i ] [ j ] . copy ( ) ; } } } P = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { P [ i ] = i ; } decompose ( ) ; }
te	2	@ Override public void visitCompilationUnit ( CompilationUnitTree cut , void p ) { String sPackageName = cut . getPackageName ( ) . toString ( ) ; jpClass . setPackageName ( sPackageName ) ; debug ( "Package name: " + sPackageName ) ; for ( Tree t : cut . getTypeDecls ( ) ) { if ( t instanceof ClassTree ) { ClassTree ct = ( ClassTree ) t ; ct . accept ( this , null ) ; } } return super . visitCompilationUnit ( cut , p ) ; }
te	0	public void reloadLevel ( ) { grav . clear ( ) ; loadProperties ( grav , GameProperties . fromString ( curLevel ) ) ; starttime = System . currentTimeMillis ( ) ; topBar . reset ( ) ; resetPlayer ( ) ; tries = 1 ; topBar . updateTries ( ) ; }
te	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
te	0	public void paintFullMap ( Graphics g , int i , int j , int width , int height ) { paintFullMap ( g , i , j , width , height , 0 , 0 ) ; }
te	8	public BuscarItem ( ) { setLayout ( new GridLayout ( 2 , 2 ) ) ; aceptarBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Inventario . setStatusBarText ( "Se dispone a buscar una cadena!!!" ) ; IServidorInventario servidor = ConexionServidor . getServidor ( ) ; String buscar = buscarFdl . getText ( ) ; String cadena ; int iguales = 0 ; int contenidas = 0 ; int fila = 0 ; int columna = 0 ; try { Vector productos = servidor . getAllItems ( ConexionServidor . getIdentificadorUnico ( ) , Inventario . getOrdenamientoDatos ( ) ) ; for ( int i = 0 ; i < productos . size ( ) ; i ++ ) { Vector detalles = ( Vector ) productos . elementAt ( i ) ; for ( int j = 0 ; j < detalles . size ( ) ; j ++ ) { cadena = ( String ) detalles . elementAt ( j ) ; cadena += "" ; if ( cadena . equalsIgnoreCase ( buscar ) ) { iguales ++ ; if ( fila == 0 && columna == 0 ) { fila = i ; columna = j ; } } else if ( cadena . contains ( buscar ) ) contenidas ++ ; } } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } dispose ( ) ; MainPanelBuilder . setSeleccion ( fila , columna ) ; JOptionPane . showMessageDialog ( null , "Cadenas iguales: " + iguales + "\n" + "Cadenas contenidas: " + contenidas , "Resultados de la busqueda" , JOptionPane . INFORMATION_MESSAGE ) ; } } ) ; cancelarBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Inventario . setStatusBarText ( "Accion Cancelada!!!" ) ; dispose ( ) ; } } ) ; add ( buscarLbl ) ; add ( buscarFdl ) ; add ( aceptarBtn ) ; add ( cancelarBtn ) ; buscarFdl . addKeyListener ( this ) ; if ( ConexionServidor . estaConectado ( ) ) { setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setSize ( 250 , 80 ) ; setTitle ( "Buscar una cadena" ) ; setLocation ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width / 2 - 125 , Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / 2 - 40 ) ; setResizable ( false ) ; setModal ( true ) ; setAlwaysOnTop ( true ) ; setVisible ( true ) ; } else { Inventario . setStatusBarText ( "No esta conectado al servidor!!!" ) ; dispose ( ) ; } }
te	5	@ Override public Type visitPackage ( package prog , IdTable table ) { top = table ; try { for ( String pd : predefined ) { Scanner scanner = new Scanner ( pd , true ) ; Parser parser = new Parser ( scanner ) ; ClassDecl cd = parser . parseClassDeclaration ( ) ; addDeclarations ( cd , table ) ; cd . visit ( this , table ) ; } } catch ( IOException e ) { Reporter . emit ( "System Predefinitions Error!" ) ; System . exit ( Compiler . rc ) ; } for ( ClassDecl cd : prog . classDeclList ) { addDeclarations ( cd , table ) ; } for ( ClassDecl cd : prog . classDeclList ) { cd . visit ( this , table ) ; } if ( main == null ) { Reporter . emit ( "Main method undeclared." ) ; } return null ; }
te	3	public void show ( ) { System . out . println ( "------------------------------------------------" ) ; System . out . println ( "| Sale Revenue Report By Month For Current Year |" ) ; System . out . println ( "------------------------------------------------" ) ; System . out . println ( ) ; for ( int month : salesBL . getMonthsOfCurrentYear ( ) ) { System . out . println ( "Month" ) ; System . out . println ( "=====" ) ; System . out . println ( getMonth ( month ) ) ; for ( Cineplex cp : salesBL . getCineplexes ( month ) ) { System . out . println ( "Cineplex\t\tMovie" ) ; System . out . println ( "--------\t\t-----" ) ; System . out . print ( cp . getCineplexName ( ) ) ; for ( Movie m : salesBL . getMoviesByCineplex ( month , cp ) ) { indiTakings = salesBL . getindiTakings ( month , m ) ; System . out . println ( "\t\t\t" + m . getTitle ( ) ) ; cineplexTakings += indiTakings ; } System . out . println ( ) ; } System . out . println ( "Individual takings: $" + Math . round ( cineplexTakings * 100.0 ) / 100.0 ) ; aggTakings += cineplexTakings ; cineplexTakings = 0.0f ; indiTakings = 0.0f ; System . out . println ( ) ; } System . out . println ( "________________________________________________________________" ) ; System . out . println ( "Aggregate takings: $" + Math . round ( aggTakings * 100.0 ) / 100.0 ) ; aggTakings = 0.0f ; }
te	3	public boolean delete ( SaploText saploText ) throws SaploClientException { verifyCollection ( saploText ) ; verifyId ( saploText ) ; JSONObject params = new JSONObject ( ) ; try { params . put ( "collection_id" , saploText . getCollection ( ) . getId ( ) ) ; if ( saploText . getId ( ) > 0 ) params . put ( "text_id" , saploText . getId ( ) ) ; if ( ! ClientUtil . NULL_STRING . equals ( saploText . getExtId ( ) ) ) params . put ( "ext_text_id" , saploText . getExtId ( ) ) ; } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } JSONRPCRequestObject request = new JSONRPCRequestObject ( client . getNextId ( ) , "text.delete" , params ) ; JSONObject result = ( JSONObject ) client . sendAndReceiveAndParseResponse ( request ) ; return result . optBoolean ( "success" , false ) ; }
te	0	public void mouseExited ( MouseEvent e ) { }
te	4	protected BufferedImage renderTrendLine ( int trendValue , int maxTrendValue ) { BufferedImage bi = new BufferedImage ( METER_WIDTH , METER_HEIGHT , BufferedImage . TYPE_INT_ARGB ) ; int width = bi . getWidth ( ) ; int halfWidth = width / 2 ; int height = bi . getHeight ( ) ; Graphics2D g2d = ( Graphics2D ) bi . getGraphics ( ) ; g2d . setColor ( Color . LIGHT_GRAY . brighter ( ) ) ; g2d . fillRect ( 0 , 0 , width , height ) ; int atv = Math . abs ( trendValue ) ; Color c = Color . GREEN ; if ( atv > maxTrendValue / 3 ) { c = Color . YELLOW ; if ( atv > maxTrendValue * 2 / 3 ) { c = Color . ORANGE ; } if ( atv > maxTrendValue ) { c = Color . RED ; } } g2d . setColor ( c ) ; int tlv = Math . min ( atv , maxTrendValue ) ; int xl = halfWidth * tlv / maxTrendValue ; int textX = 0 ; if ( trendValue < 0 ) { g2d . fillRect ( halfWidth - xl , 0 , xl , height ) ; textX = halfWidth + 5 ; } else { g2d . fillRect ( halfWidth , 0 , xl , height ) ; textX = 5 ; } g2d . setColor ( Color . BLACK ) ; g2d . setFont ( new Font ( "monospace" , Font . BOLD , 24 ) ) ; g2d . drawString ( String . format ( "%d" , trendValue ) , textX , height / 2 ) ; g2d . setStroke ( new BasicStroke ( 2 ) ) ; g2d . drawLine ( halfWidth , 1 , halfWidth , height - 2 ) ; g2d . setColor ( Color . DARK_GRAY ) ; g2d . drawRect ( 1 , 1 , width - 1 , height - 2 ) ; return bi ; }
te	1	public ArrayList < Calificacion > retCalificacionesDe ( String nom ) { ArrayList < Calificacion > ret = new ArrayList < Calificacion > ( ) ; for ( Hotel h : this . retHotelesConNombre ( nom ) ) { ret . addAll ( h . getCalificaciones ( ) ) ; } return ret ; }
te	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; T2Impl < ? , ? > other = ( T2Impl < ? , ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
te	3	private static byte [ ] changeBase2 ( byte [ ] src , int dstPower , int srcPower ) { double tmpResultSize = ( src . length * ( double ) srcPower ) / dstPower ; int resultSize = ( int ) Math . ceil ( tmpResultSize ) ; byte [ ] result = new byte [ resultSize ] ; int dstIdx = 0 ; long mask = ( 1 << dstPower ) - 1 ; int workingBits = 0 ; BigInteger buffer = BigInteger . valueOf ( 0 ) ; for ( byte aSrc : src ) { int unsignedIntValue = aSrc & ff ; buffer = buffer . or ( BigInteger . valueOf ( unsignedIntValue ) . shiftLeft ( workingBits ) ) ; workingBits += srcPower ; while ( workingBits > dstPower ) { result [ dstIdx ++ ] = buffer . and ( BigInteger . valueOf ( mask ) ) . byteValue ( ) ; buffer = buffer . shiftRight ( dstPower ) ; workingBits -= dstPower ; } } if ( workingBits > 0 ) { result [ dstIdx ++ ] = buffer . and ( BigInteger . valueOf ( mask ) ) . byteValue ( ) ; } return result ; }
te	3	public int getIndex ( String uri , String localName ) { if ( uri . length ( ) != 0 ) return - 1 ; for ( int i = 0 ; i < attrList . length ; i ++ ) { if ( attrList [ i ] . getKey ( ) . equals ( localName ) ) { return i ; } } return - 1 ; }
te	1	public static String getCurrentTree ( String ptUrl ) { int anchor = getAnchorStart ( ptUrl ) ; String param = parseAnchorParam ( ptUrl , anchor , "N-s=1_" ) ; if ( param != null ) { return param ; } return parseAnchorParam ( ptUrl , anchor , "N-f=1_" ) ; }
te	3	public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof CodeWord ) ) return false ; final CodeWord codeWord = ( CodeWord ) o ; if ( ! word . equals ( codeWord . word ) ) return false ; return true ; }
te	1	@ Override public int hashCode ( ) { int hash = 7 ; hash = 13 * hash + ( this . schema != null ? this . schema . hashCode ( ) : 0 ) ; return hash ; }
te	3	public void saveMuted ( ) { final FileConfiguration config = plugin . getConfig ( ) ; final File CONFIGURATION_FILE = Configuration . Paths . SETTINGS_FILE ; final boolean exists = CONFIGURATION_FILE . exists ( ) ; if ( exists ) { try { config . load ( CONFIGURATION_FILE ) ; } catch ( final Exception e ) { IRC . debug ( e ) ; } config . set ( "IRC.MUTED" , Variables . muted ) ; } else { IRC . debug ( "No file found  can not save muted users!" , Variables . debug ) ; return ; } try { config . save ( CONFIGURATION_FILE ) ; } catch ( final IOException e ) { IRC . debug ( e ) ; } }
te	7	public GameData getData ( ) { GameData gd = new GameData ( ) ; gd . setMP ( MagicPower . getMP ( ) ) ; gd . setGem ( gem ) ; gd . setCounter ( counter ) ; List < Enemy > enemyList = new ArrayList < Enemy > ( ) ; for ( Tile t : map ) { if ( t instanceof Road ) { Road r = ( Road ) t ; for ( Enemy e : r . getEnemies ( ) ) { enemyList . add ( e ) ; } } } for ( Enemy e : enemyList ) { int [ ] pos = new int [ 2 ] ; pos [ 0 ] = map . indexOf ( e . getRoad ( ) ) / size ; pos [ 1 ] = map . indexOf ( e . getRoad ( ) ) % size ; gd . addEnemy ( pos , e ) ; } for ( Tower t : towers ) { int [ ] pos = new int [ 2 ] ; pos [ 0 ] = map . indexOf ( t . getField ( ) ) / size ; pos [ 1 ] = map . indexOf ( t . getField ( ) ) % size ; gd . addTower ( pos , t ) ; } for ( Tile t : map ) { if ( t instanceof Swamp ) { int [ ] pos = new int [ 2 ] ; pos [ 0 ] = map . indexOf ( t ) / size ; pos [ 1 ] = map . indexOf ( t ) % size ; gd . addSwamp ( pos , ( Swamp ) t ) ; } } return gd ; }
te	3	private synchronized String getMinSensorValue ( ) { if ( sensorValuesMap . isEmpty ( ) ) { return "" ; } Integer minValue = Integer . MAX_VALUE ; for ( Integer curInt : sensorValuesMap . values ( ) ) { if ( curInt < minValue ) { minValue = curInt ; } } return Integer . toString ( minValue ) ; }
te	4	public void setFont ( Font font ) { if ( days != null ) { for ( int i = 0 ; i < 49 ; i ++ ) { days [ i ] . setFont ( font ) ; } } if ( weeks != null ) { for ( int i = 0 ; i < 7 ; i ++ ) { weeks [ i ] . setFont ( font ) ; } } }
te	9	public Map < Money , Integer > subtractMoney ( GuiGame gui , int amount , boolean force ) { final Map < Money , Integer > subtracted = new HashMap < Money , Integer > ( ) ; if ( amount > this . getMoneyAmount ( ) ) { gui . setIngameGui ( new GuiNotEnoughMoney ( gui , this . player , amount ) ) ; if ( force ) { this . player . setBankrupt ( ) ; } return Collections . emptyMap ( ) ; } else { final Map < Money , Integer > copy = new HashMap < Money , Integer > ( this . ownedMoney ) ; for ( int i = 6 ; i >= 0 ; i -- ) { final Money type = Money . values ( ) [ i ] ; while ( this . ownedMoney . get ( type ) != 0 && type . amount <= amount && amount / ( float ) type . amount > 0.1 && amount != 0 ) { final int value = this . ownedMoney . get ( type ) - 1 ; this . ownedMoney . put ( type , value ) ; amount -= type . amount ; if ( ! subtracted . containsKey ( type ) ) { subtracted . put ( type , 1 ) ; } else { final int j = subtracted . get ( type ) ; subtracted . put ( type , j + 1 ) ; } } if ( amount == 0 ) { break ; } } if ( amount != 0 ) { this . ownedMoney = copy ; this . subtractMoneyNext ( amount , 1 ) ; } if ( amount != 0 ) { if ( force ) { this . player . setBankrupt ( ) ; } return Collections . emptyMap ( ) ; } else { return subtracted ; } } }
te	8	static void build_key_square ( char [ ] [ ] square , String key ) { boolean [ ] filled = new boolean [ 26 ] ; String key_u = key . toUpperCase ( ) ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < key_u . length ( ) ; i ++ ) { char cur_c = key_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } int order = cur_c - A ; if ( ! filled [ order ] ) { square [ cur_row ] [ cur_col ] = cur_c ; filled [ order ] = true ; } else { continue ; } if ( cur_row == 4 ) { cur_row = 0 ; cur_col ++ ; } else { cur_row ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { char cur_c = ( char ) ( A + i ) ; if ( cur_c == J ) continue ; if ( ! filled [ i ] ) { square [ cur_row ] [ cur_col ] = cur_c ; filled [ i ] = true ; } else { continue ; } if ( cur_row == 4 ) { cur_row = 0 ; cur_col ++ ; } else { cur_row ++ ; } } }
te	8	public int OpenForWrite ( String Filename , int SamplingRate , short BitsPerSample , short NumChannels ) { if ( ( Filename == null ) || ( BitsPerSample != 8 && BitsPerSample != 16 ) || NumChannels < 1 || NumChannels > 2 ) { return DDC_INVALID_CALL ; } wave_format . data . Config ( SamplingRate , BitsPerSample , NumChannels ) ; int retcode = Open ( Filename , RFM_WRITE ) ; if ( retcode == DDC_SUCCESS ) { byte [ ] theWave = { ( byte ) W , ( byte ) A , ( byte ) V , ( byte ) E } ; retcode = Write ( theWave , 4 ) ; if ( retcode == DDC_SUCCESS ) { retcode = Write ( wave_format . header , 8 ) ; retcode = Write ( wave_format . data . wFormatTag , 2 ) ; retcode = Write ( wave_format . data . nChannels , 2 ) ; retcode = Write ( wave_format . data . nSamplesPerSec , 4 ) ; retcode = Write ( wave_format . data . nAvgBytesPerSec , 4 ) ; retcode = Write ( wave_format . data . nBlockAlign , 2 ) ; retcode = Write ( wave_format . data . nBitsPerSample , 2 ) ; if ( retcode == DDC_SUCCESS ) { pcm_data_offset = CurrentFilePosition ( ) ; retcode = Write ( pcm_data , 8 ) ; } } } return retcode ; }
te	2	ListNode move ( ListNode head , int moveBy ) { while ( head != null && moveBy -- > 0 ) head = head . next ; return head ; }
te	0	public A ( String str ) { System . out . println ( str ) ; }
te	0	@ Test public void testFolderReset ( ) { Folder folder = new FolderMock ( null ) ; sm . fail ( folder ) ; sm . fail ( folder ) ; sm . fail ( folder ) ; assert . assertFalse ( sm . canProcess ( folder ) ) ; sm . reset ( folder ) ; sm . fail ( folder ) ; sm . fail ( folder ) ; assert . assertTrue ( sm . canProcess ( folder ) ) ; }
te	1	@ Override public void insert ( T value ) { if ( root . isEmpty ( ) ) { root . setData ( value ) ; root . setParent ( new BSTNode < T > ( ) ) ; root . setLeft ( new BSTNode < T > ( ) ) ; root . setRight ( new BSTNode < T > ( ) ) ; } else { insert ( value , root ) ; } }
te	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . addElement ( null ) ; } else { x . back ( ) ; this . myArrayList . addElement ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } }
te	6	public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( "Unclosed CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ] && sb . charAt ( i + 1 ) == ] && sb . charAt ( i + 2 ) == > ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
te	2	public void displayPrimalCoefficients ( ) { System . out . println ( "The primal coefficient matrix is as follows: " ) ; for ( int i = 0 ; i < mdpData . getNoOfActions ( ) ; i ++ ) { for ( int j = 0 ; j < mdpData . getNoOfStates ( ) ; j ++ ) { System . out . print ( primalCoefficients [ i ] [ j ] + " " ) ; } System . out . println ( ) ; } }
te	5	@ Override public boolean addUser ( ) { if ( connection == null || loginInfo == null || biographicalInfo == null || billingInfo == null ) { return false ; } DateFormat dateFormat = new SimpleDateFormat ( DateUtil . DATE_FORMAT ) ; boolean result = false ; try ( PreparedStatement stmt = connection . prepareStatement ( INSERT_USER_SQL ) ) { stmt . setString ( 1 , loginInfo . getUsername ( ) ) ; stmt . setString ( 2 , loginInfo . getPassword ( ) ) ; stmt . setString ( 3 , biographicalInfo . getFirstName ( ) ) ; stmt . setString ( 4 , biographicalInfo . getLastName ( ) ) ; stmt . setString ( 5 , dateFormat . format ( biographicalInfo . getBirthDate ( ) ) ) ; stmt . setString ( 6 , billingInfo . getAccountNumber ( ) ) ; stmt . setString ( 7 , billingInfo . getCreditCardType ( ) . toString ( ) ) ; stmt . executeUpdate ( ) ; result = true ; } catch ( SQLException ex ) { logger . error ( "Error while adding user" , ex ) ; } return result ; }
te	4	Log ( XmlLog log ) { this . id = log . getId ( ) ; this . owner = log . getOwner ( ) ; this . description = log . getDescription ( ) ; this . level = log . getLevel ( ) ; this . createdDate = log . getCreatedDate ( ) ; this . modifiedDate = log . getModifiedDate ( ) ; this . version = log . getVersion ( ) ; Map < String , Tag > newTags = new HashMap < String , Tag > ( ) ; for ( XmlTag tag : log . getXmlTags ( ) ) { newTags . put ( tag . getName ( ) , new Tag ( tag ) ) ; } this . tags = Collections . unmodifiableMap ( newTags ) ; Map < String , Logbook > newLogbooks = new HashMap < String , Logbook > ( ) ; for ( XmlLogbook logbook : log . getXmlLogbooks ( ) ) { newLogbooks . put ( logbook . getName ( ) , new Logbook ( logbook ) ) ; } this . logbooks = Collections . unmodifiableMap ( newLogbooks ) ; Map < String , Attachment > newAttachments = new HashMap < String , Attachment > ( ) ; for ( XmlAttachment attachment : log . getXmlAttachments ( ) . getAttachments ( ) ) { newAttachments . put ( attachment . getFileName ( ) , new Attachment ( attachment ) ) ; } this . attachments = Collections . unmodifiableMap ( newAttachments ) ; Multimap < String , Property > newProperties = HashMultimap . create ( ) ; for ( XmlProperty property : log . getXmlProperties ( ) ) { newProperties . put ( property . getName ( ) , new Property ( property ) ) ; } this . properties = newProperties ; }
te	7	private java . util . Calendar findNextDimecres ( int nweeks ) { java . util . Date utilDate = m_cal . getTime ( ) ; Calendar m_cal2 = Calendar . getInstance ( ) ; m_cal2 . setTime ( utilDate ) ; m_cal2 . set ( Calendar . HOUR_OF_DAY , 0 ) ; m_cal2 . set ( Calendar . MINUTE , 0 ) ; m_cal2 . set ( Calendar . SECOND , 0 ) ; m_cal2 . set ( Calendar . MILLISECOND , 0 ) ; switch ( intDiaSetmana ) { case 1 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 2 + nweeks * 7 ) ; break ; case 2 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 7 + nweeks * 7 ) ; break ; case 3 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 7 + nweeks * 7 ) ; break ; case 4 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 6 + nweeks * 7 ) ; break ; case 5 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 5 + nweeks * 7 ) ; break ; case 6 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 4 + nweeks * 7 ) ; break ; case 7 : m_cal2 . add ( Calendar . DAY_OF_MONTH , 3 + nweeks * 7 ) ; break ; } return m_cal2 ; }
te	3	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
te	3	@ Override public String getCode ( SourceCompositionTask task ) { StringBuilder string = new StringBuilder ( ) ; if ( objectType != null ) { string . append ( object . getCode ( task ) ) . append ( "." ) ; } string . append ( methodName ) . append ( "(" ) ; for ( int i = 0 ; i < childGenes . size ( ) ; i ++ ) { if ( i > 0 ) { string . append ( " " ) ; } string . append ( childGenes . get ( i ) . getCode ( task ) ) ; } string . append ( ")" ) ; return string . toString ( ) ; }
te	1	public void agregarFila ( ) { Object [ ] [ ] nuevaTabla = new Object [ this . getRowCount ( ) + 1 ] [ 3 ] ; int i = 0 ; while ( i < this . getRowCount ( ) ) { nuevaTabla [ i ] [ 0 ] = this . filasColumnasTabla [ i ] [ 0 ] ; nuevaTabla [ i ] [ 1 ] = this . filasColumnasTabla [ i ] [ 1 ] ; nuevaTabla [ i ] [ 2 ] = this . filasColumnasTabla [ i ] [ 2 ] ; i ++ ; } this . filasColumnasTabla = nuevaTabla ; this . tablaModificada ( ) ; }
te	2	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( ( name == null ) ? 0 : name . hashCode ( ) ) ; return result ; }
te	4	public int [ ] solution ( String dnaSequence , int [ ] queryStarts , int [ ] queryEnds ) { final int nbQueries = queryStarts . length ; final int [ ] results = new int [ nbQueries ] ; final int [ ] [ ] nucleotideCount = getCumulativeNucleotideCount ( dnaSequence ) ; final int nbNucleotideTypes = 4 ; for ( int i = 0 ; i < nbQueries ; i ++ ) { final int startIndex = queryStarts [ i ] ; final int endIndex = queryEnds [ i ] + 1 ; final int [ ] nucleotideStartCount = nucleotideCount [ startIndex ] ; final int [ ] nucleotideEndCount = nucleotideCount [ endIndex ] ; for ( int j = 0 ; j < nbNucleotideTypes ; j ++ ) { if ( j == 3 ) { results [ i ] = 4 ; } else if ( nucleotideStartCount [ j ] < nucleotideEndCount [ j ] ) { results [ i ] = j + 1 ; break ; } } } return results ; }
te	6	public boolean getBoolean ( String key ) throws JSONException { Object object = get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
te	4	private void loadProperties ( String source , InputStream in ) throws IOException { Properties loadedProperties = new Properties ( ) ; try { loadedProperties . load ( in ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; for ( Entry < Object , Object > entry : loadedProperties . entrySet ( ) ) { String key = ( String ) entry . getKey ( ) ; if ( properties . get ( key ) == null ) { properties . put ( key , ( String ) entry . getValue ( ) ) ; } } System . out . println ( String . format ( "Loaded service provider properties file for service " + "%s from %s: %s" , serviceClass . getName ( ) , source , properties . toString ( ) ) ) ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ioe ) { } } }
te	8	private String printSection ( Section section , int lvl ) { Line selectedLine = this . getSelectedLine ( ) ; StringBuilder printed = new StringBuilder ( ) ; for ( int i = 0 ; i < lvl ; i ++ ) { printed . append ( "*" ) ; } if ( section . getTitle ( ) . getLine ( ) . equals ( selectedLine ) ) { printed . append ( new StringBuilder ( section . getTitle ( ) . getLine ( ) . toString ( ) ) . insert ( this . getSelectedCharacterNb ( ) , "[" ) . insert ( selectedLine . length ( ) == this . getSelectedCharacterNb ( ) ? this . getSelectedCharacterNb ( ) + 1 : this . getSelectedCharacterNb ( ) + 2 , "]" ) ) ; } else printed . append ( section . getTitle ( ) . getLine ( ) . toString ( ) ) ; if ( section . isVisible ( ) ) { printed . append ( "\n" ) ; TextIntro intro = section . getTextIntro ( ) ; for ( int i = 0 ; i < intro . getLineNb ( ) ; i ++ ) { if ( intro . getLine ( i ) . equals ( selectedLine ) ) { printed . append ( new StringBuilder ( intro . getLine ( i ) . toString ( ) ) . insert ( this . getSelectedCharacterNb ( ) , "[" ) . insert ( selectedLine . length ( ) == this . getSelectedCharacterNb ( ) ? this . getSelectedCharacterNb ( ) + 1 : this . getSelectedCharacterNb ( ) + 2 , "]" ) ) . append ( "\n" ) ; } else { printed . append ( intro . getLine ( i ) . toString ( ) + "\n" ) ; } } for ( int i = 0 ; i < section . getSubSectionNb ( ) ; i ++ ) { printed . append ( this . printSection ( section . getSubSection ( i ) , lvl + 1 ) ) ; } } else { printed . append ( "... \n" ) ; } return printed . toString ( ) ; }
te	2	public void testDoesNotBlowUp ( ) { ROT2TestThread threads [ ] = new ROT2TestThread [ 4 ] ; for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] = new ROT2TestThread ( "thread-" + i , 3000 ) ; } for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] . start ( ) ; } }
te	5	private void parsePacket ( final byte [ ] data , final Inet4Address address , final short port ) { final String message = new String ( data ) . trim ( ) ; final Packet . Type type = Packet . Type . getType ( message . substring ( 0 , 2 ) ) ; Packet packet = null ; switch ( type ) { default : case INVALID : break ; case LOGIN : packet = new Packet00Login ( data ) ; GameLog . info ( "[" + address . getHostAddress ( ) + ":" + port + "] " + ( ( Packet00Login ) packet ) . getUsername ( ) + " has connected..." , false ) ; EntityPlayerMP player = new EntityPlayerMP ( Guis . world , ( ( Packet00Login ) packet ) . getUsername ( ) , address , port ) ; addConnection ( player , ( Packet00Login ) packet ) ; break ; case DISCONNECT : packet = new Packet01Disconnect ( data ) ; System . out . println ( "[" + address . getHostAddress ( ) + ":" + port + "] " + ( ( Packet01Disconnect ) packet ) . getUsername ( ) + " has left..." ) ; removeConnection ( ( Packet01Disconnect ) packet ) ; break ; case MOVE : packet = new Packet02Move ( data ) ; Guis . world . moveEntity ( ( Packet02Move ) packet ) ; break ; case TILE : packet = new Packet03Tile ( data ) ; parseTilePacket ( ( Packet03Tile ) packet ) ; } }
te	2	private String allJs ( ) { LinkedList < String > col = new LinkedList < > ( ) ; P2 < File , String > collect = ( file , path ) -> { if ( file . getName ( ) . endsWith ( ".js" ) ) { if ( StringUtil . isEmpty ( path ) ) { col . add ( "/" + file . getName ( ) ) ; } else { col . add ( "/" + path . replaceAll ( "\\\\" , "/" ) + "/" + file . getName ( ) ) ; } } } ; FileUtil . eachFile ( new File ( webLoc + "/spa" ) , collect ) ; return Cols . join ( ( Iterable < String > ) Cols . yield ( col , s -> "<script src=\"/spa" + s + "?v=" + version + "\"></script>" ) , "" ) ; }
te	6	@ Override public void run ( ) { List < Action > actions ; long startTime = System . currentTimeMillis ( ) , estimatedTime , timeToWait = 100 ; while ( true && ! sim . isEnded ( ) ) { actions = sim . prepareUpdate ( ) ; estimatedTime = System . currentTimeMillis ( ) - startTime ; System . out . println ( "### time = " + estimatedTime + " ms" ) ; try { timeToWait = 100 - estimatedTime ; Thread . sleep ( timeToWait < 0 ? 0 : timeToWait ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } startTime = System . currentTimeMillis ( ) ; synchronized ( sim ) { sim . applyUpdate ( actions ) ; simPanel . repaint ( ) ; } while ( sim . isPaused ( ) ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } }
te	7	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == < ) { return XML . < ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == < || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } }
te	2	public Vec3f set ( int i , float val ) { switch ( i ) { case 0 : x = val ; return this ; case 1 : y = val ; return this ; default : z = val ; return this ; } }
te	5	private void loginBtnMouseClicked ( java . awt . event . MouseEvent evt ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( Constants . USER_NO , this . userNO . getText ( ) ) ; map . put ( Constants . USER_PWD , String . valueOf ( this . userPwd . getPassword ( ) ) ) ; map . put ( Constants . USER_STATUS , this . status . getSelectedIndex ( ) + 1 ) ; Map < String , Object > userMap = new UserDao ( ) . login ( map ) ; Alert dialog ; dialog = new Alert ( this , true , map ) ; if ( null == userMap || Constants . NUM_ZERO == userMap . size ( ) ) { dialog . getLabel ( ) . setText ( "\u767B\u5F55\u5931\u8D25" ) ; dialog . setUseFor ( Constants . LOGIN_FAIL ) ; dialog . setVisible ( true ) ; } else { boolean flg = false ; try { new Client ( ) . setUserNO ( String . valueOf ( map . get ( Constants . USER_NO ) ) ) . service ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; log . error ( "\u8FDE\u63A5\u670D\u52A1\u5668\u51FA\u9519" ) ; serverError ( ) ; flg = true ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; log . error ( "\u8FDE\u63A5\u670D\u52A1\u5668\u51FA\u9519" ) ; if ( ! flg ) { serverError ( ) ; } return ; } dialog . getLabel ( ) . setText ( "\u767B\u5F55\u6210\u529F" ) ; dialog . setUseFor ( Constants . LOGIN_OK ) ; dialog . setVisible ( true ) ; this . dispose ( ) ; } }
te	1	public List < GitlabCommit > getCommits ( GitlabMergeRequest mergeRequest , Pagination pagination ) throws IOException { Integer projectId = mergeRequest . getSourceProjectId ( ) ; if ( projectId == null ) { projectId = mergeRequest . getProjectId ( ) ; } Query query = new Query ( ) . append ( "ref_name" , mergeRequest . getSourceBranch ( ) ) ; query . mergeWith ( pagination . asQuery ( ) ) ; String tailUrl = GitlabProject . URL + "/" + projectId + "/repository" + GitlabCommit . URL + query . toString ( ) ; GitlabCommit [ ] commits = retrieve ( ) . to ( tailUrl , GitlabCommit [ ] . class ) ; return Arrays . asList ( commits ) ; }
te	7	public static ArrayList < Contrato > getListaContratosFiltro ( int estado , int filtro , long id , String nombre ) { String sql = "" ; switch ( filtro ) { case FILTRO_ID_DUENIO : sql = String . format ( "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = %d and " + "c.duenio = d.codigo and d.id = %d " + "order by t.placa  a.placa;" , estado , id ) ; break ; case FILTRO_ID_HABITANTE : sql = String . format ( "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d  habitante h " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = %d and " + "c.codigo = h.contrato and h.cliente = d.codigo and d.codigo and d.id = %d " + "order by t.placa  a.placa;" , estado , id ) ; break ; case FILTRO_ID_RESPONSABLE : sql = String . format ( "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = %d and " + "c.responsable = d.codigo and d.id = %d " + "order by t.placa  a.placa;" , estado , id ) ; break ; case FILTRO_NOMBRE_DUENIO : sql = "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = " + estado + " and " + "c.duenio = d.codigo and (concat(d.nombre  ' '  d.apellido) like '%" + nombre + "%') " + "order by t.placa  a.placa;" ; break ; case FILTRO_NOMBRE_HABITANTE : sql = "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d  habitante h " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = " + estado + " and " + "c.codigo = h.contrato and h.cliente = d.codigo and d.codigo and (concat(d.nombre  ' '  d.apellido) like '%" + nombre + "%') " + "order by t.placa  a.placa;" ; break ; case FILTRO_NOMBRE_RESPONSABLE : sql = "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = " + estado + " and " + "c.responsable = d.codigo and (concat(d.nombre  ' '  d.apellido) like '%" + nombre + "%') " + "order by t.placa  a.placa;" ; break ; case FILTRO_ID_APARTAMENTO : sql = "select c.codigo c.apartamento c.duenio c.responsable c.fechainicio c.estado c.fechatermino " + "from contrato c  apartamento a  torre t  cliente d " + "where c.apartamento = a.codigo and a.torre = t.codigo and c.estado = " + estado + " and " + "c.responsable = d.codigo and a.placa ='" + nombre + "'" + "order by t.placa  a.placa;" ; break ; } Conexion < Contrato > c = new Conexion < > ( ) ; c . seleccionarRegistros ( sql , Contrato . class ) ; ArrayList < Contrato > lista = c . seleccionarRegistros ( sql , Contrato . class ) ; return lista ; }
te	8	@ Override public void close ( ) throws IOException { if ( os != null ) { try { os . flush ( ) ; os . close ( ) ; os = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fWriter != null ) { try { fWriter . close ( ) ; fWriter = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( is != null ) { try { is . close ( ) ; is = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( fReader != null ) { try { fReader . close ( ) ; fReader = null ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } connectionInStatus = false ; connectionOutStatus = false ; }
te	1	private void saveWorkspaceAs ( ) throws JSONException , URISyntaxException , IOException { SavedData . setLastSavedWorkspace ( FileUtil . writeJsonToUserSpecifiedFile ( getContentPane ( ) , workspace . getJson ( ) ) ) ; try { SavedData . save ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } }
te	8	public void requireSanity ( State s ) { boolean sane = true ; if ( s . players ( ) . length != players . length ) { System . err . println ( "inconsistent belief: number of players changed" ) ; sane = false ; } if ( ! s . deck . containsAll ( known_deck_cards ) ) { CardBag surplus = known_deck_cards . clone ( ) ; surplus . removeAll ( s . deck ) ; System . err . println ( "inconsistent belief: known_deck_cards " + known_deck_cards + " contains cards " + surplus + " that are not in the deck " + s . deck ) ; sane = false ; } for ( int i = 0 ; i < players . length ; i ++ ) { if ( ! s . playerState ( i ) . hand . containsAll ( players [ i ] . known_cards ) ) { System . err . println ( "inconsistent belief: for player " + s . playerState ( i ) . name + "  known_cards " + players [ i ] . known_cards + " contains cards that are not in the hand " + s . playerState ( i ) . hand ) ; sane = false ; } } int total_card_count = 0 ; total_card_count = cards_of_unknown_location . size ( ) ; total_card_count += known_deck_cards . size ( ) ; total_card_count += s . open_deck . size ( ) ; total_card_count += s . discarded . size ( ) ; for ( int i = 0 ; i < players . length ; i ++ ) total_card_count += players [ i ] . known_cards . size ( ) ; if ( total_card_count != State . INITIAL_DECK . size ( ) ) { System . err . println ( "inconsistent belief: " + total_card_count + " cards in the game  should be " + State . INITIAL_DECK . size ( ) ) ; sane = false ; } if ( ! sane ) { System . err . println ( "events that led to this belief (most recent event last):" ) ; for ( Event e : events ) System . err . println ( "  " + e ) ; throw new RuntimeException ( "inconsistent belief" ) ; } }
te	9	public boolean verifySquenceOfBST ( int [ ] squence , int start , int end ) { if ( squence == null || end < start ) { throw new NullPointerException ( "Input is null." ) ; } int root = squence [ end ] ; int i = start ; for ( ; i < end ; i ++ ) { if ( squence [ i ] > root ) { break ; } } int j = i ; for ( ; j < end ; j ++ ) { if ( squence [ j ] < root ) return false ; } boolean left = true ; if ( i > start ) { left = verifySquenceOfBST ( squence , start , i - 1 ) ; } boolean right = true ; if ( i < end - 1 ) { right = verifySquenceOfBST ( squence , i , end - 1 ) ; } return ( left && right ) ; }
te	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
te	8	@ Override public int compareTo ( final Goal other ) { final int thisColor = ( this . robotNumber < 0 ? Integer . MAX_VALUE : this . robotNumber ) ; final int otherColor = ( other . robotNumber < 0 ? Integer . MAX_VALUE : other . robotNumber ) ; if ( thisColor < otherColor ) { return - 1 ; } else if ( thisColor > otherColor ) { return 1 ; } else { if ( this . shape < other . shape ) { return - 1 ; } else if ( this . shape > other . shape ) { return 1 ; } else { if ( this . position < other . position ) { return - 1 ; } else if ( this . position > other . position ) { return 1 ; } else { return 0 ; } } } }
te	7	static int getProxyPort ( final AppleServer server ) { String host = server != null ? server . getProxyHost ( ) : null ; if ( host != null && host . length ( ) > 0 ) { return server . getProxyPort ( ) ; } else { host = System . getProperty ( LOCAL_PROXY_HOST_PROPERTY ) ; if ( host != null && host . length ( ) > 0 ) { return Integer . parseInt ( System . getProperty ( LOCAL_PROXY_PORT_PROPERTY ) ) ; } else { host = System . getProperty ( JVM_PROXY_HOST_PROPERTY ) ; if ( host != null && host . length ( ) > 0 ) { return Integer . parseInt ( System . getProperty ( JVM_PROXY_PORT_PROPERTY ) ) ; } else { return 0 ; } } } }
te	1	public ApnsServiceBuilder withDelegate ( ApnsDelegate delegate ) { this . delegate = delegate == null ? ApnsDelegate . EMPTY : delegate ; return this ; }
te	6	private void subscribe ( ) { if ( checkExistenceInUniversityDB == true ) { System . out . println ( "Complet." ) ; if ( studentJRadioButton . isSelected ( ) ) { newStudent = new Student ( ) ; newStudent . setFirstName ( firstNameJTextField . getText ( ) ) ; newStudent . setLastName ( lastNameJTextField . getText ( ) ) ; newStudent . setEmail ( emailJTextField . getText ( ) ) ; isStudentVariable = true ; } else if ( facultyJRadioButton . isSelected ( ) ) { newFaculty = new Faculty ( ) ; newFaculty . setFirstName ( firstNameJTextField . getText ( ) ) ; newFaculty . setLastName ( lastNameJTextField . getText ( ) ) ; newFaculty . setEmail ( emailJTextField . getText ( ) ) ; isStudentVariable = false ; } String query = "INSERT INTO members(Name Surname Email IsStudent) VALUES (? ? ? ?) " ; try { pst = connection . prepareStatement ( query ) ; studentOrFacultyObjectDecision ( ) ; pst . execute ( ) ; String memberIdQuery = "SELECT MemberId FROM members WHERE Name=? AND Surname=? AND Email=? AND" + " IsStudent=?" ; pst = connection . prepareStatement ( memberIdQuery ) ; studentOrFacultyObjectDecision ( ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) JOptionPane . showMessageDialog ( null , "New Member successfully registered!\n" + "------------\nMember Information\n" + "Member id:" + rs . getString ( "MemberId" ) , "Well done" , JOptionPane . INFORMATION_MESSAGE ) ; clearJTextFields ( ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } } else { JOptionPane . showMessageDialog ( null , "Please " + "retry giving the correct input data.\n" + "If problem continues  maybe the applicant is not allowed to" + "become a member." , "Input Error Occured" , JOptionPane . ERROR_MESSAGE ) ; } }
te	5	public void gameUpdated ( GameUpdateType type ) { switch ( type ) { case GAMEOVER : System . out . println ( "" + engine . getCurrentRound ( ) + " " + engine . getBoard ( ) . mosquitosCaught + " " + engine . getConfig ( ) . getNumLights ( ) + " " + engine . getConfig ( ) . getNumMosquitos ( ) + " " + engine . getConfig ( ) . getSelectedBoard ( ) . getName ( ) + " " + engine . getConfig ( ) . getPlayerClass ( ) . getName ( ) ) ; break ; case MOVEPROCESSED : if ( longMode ) System . out . println ( "" + engine . getCurrentRound ( ) + " " + engine . getBoard ( ) . mosquitosCaught + " " + engine . getConfig ( ) . getNumLights ( ) + " " + engine . getConfig ( ) . getNumMosquitos ( ) + " " + engine . getConfig ( ) . getSelectedBoard ( ) . getName ( ) + " " + engine . getConfig ( ) . getPlayerClass ( ) . getName ( ) ) ; break ; case STARTING : System . out . println ( "Time Num_Caught Num_Lights Num_Mosquitos Board_Name Player_Name" ) ; break ; case MOUSEMOVED : default : } }
te	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<NetworkLink" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isRefreshVisibilityDirty ) { change += "<refreshVisibility>" + this . refreshVisibility + "</refreshVisibility>\n" ; this . isRefreshVisibilityDirty = false ; } if ( this . isFlyToViewDirty ) { change += "<flyToView>" + this . flyToView + "</flyToView>\n" ; this . isFlyToViewDirty = false ; } if ( this . link != null && this . link . isDirty ( ) ) { change += this . link . toUpdateKML ( ) ; } if ( this . url != null && this . url . isDirty ( ) ) { change += this . url . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</NetworkLink>\n" ; } setNotDirty ( ) ; return change ; }
