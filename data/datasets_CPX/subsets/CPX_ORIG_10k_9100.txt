te	5	public static void main ( String [ ] argv ) throws Exception { if ( argv . length != 1 ) { System . err . println ( "usage: Glue2Pojo <json file>" ) ; System . exit ( 1 ) ; } System . out . printf ( "reading file %s%n" , argv [ 0 ] ) ; byte [ ] doc = Files . readAllBytes ( Paths . get ( argv [ 0 ] ) ) ; System . out . println ( "parsing" ) ; ObjectMapper mapper = new ObjectMapper ( ) ; Glue2 glue2 = mapper . readValue ( doc , Glue2 . class ) ; if ( glue2 . getComputingActivity ( ) . size ( ) > 0 ) { System . out . printf ( "found %d computing activities%n" , glue2 . getComputingActivity ( ) . size ( ) ) ; } if ( glue2 . getComputingShare ( ) . size ( ) > 0 ) { System . out . printf ( "found %d computing shares%n" , glue2 . getComputingShare ( ) . size ( ) ) ; } if ( glue2 . getExecutionEnvironment ( ) . size ( ) > 0 ) { System . out . printf ( "found %d execution environments%n" , glue2 . getExecutionEnvironment ( ) . size ( ) ) ; } if ( glue2 . getApplicationEnvironment ( ) . size ( ) > 0 ) { System . out . printf ( "found %d application environments%n" , glue2 . getApplicationEnvironment ( ) . size ( ) ) ; } }
te	9	public static Hand evaluate ( List < Card > sourceCards ) { final Holder < Hand > handHolder = new Holder < Hand > ( ) ; final HandCombinationSink handCombinationSink = new HandCombinationSink ( ) { @ Override public void setBestHand ( Hand hand ) { assert handHolder . value == null ; handHolder . value = hand ; } } ; do { if ( maybeStraightFlush ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeFourOfAKind ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeFullHouse ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeFlush ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeStraight ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeThreeOfAKind ( sourceCards , handCombinationSink ) ) { break ; } if ( maybeTwoPairs ( sourceCards , handCombinationSink ) ) { break ; } if ( maybePair ( sourceCards , handCombinationSink ) ) { break ; } highCard ( sourceCards , handCombinationSink ) ; } while ( false ) ; assert handHolder . value != null ; return handHolder . value ; }
te	0	List < Object > getObjects ( URI predicate ) { List < Object > objects = new LinkedList < > ( ) ; objects . addAll ( getURIObjects ( predicate ) ) ; objects . addAll ( getBlankObjects ( predicate ) ) ; objects . addAll ( getLiteralObjects ( predicate ) ) ; return objects ; }
te	0	public ReportPublish ( Publish publish , int totalImpressions , int totalClicks , BigDecimal totalCost , Set < ReportrDaily > reportrDailies ) { this . publish = publish ; this . totalImpressions = totalImpressions ; this . totalClicks = totalClicks ; this . totalCost = totalCost ; this . reportrDailies = reportrDailies ; }
te	5	public boolean sameChecksum ( long [ ] compareChecksums ) { if ( compareChecksums != null && compareChecksums . length == 2 && hasChecksums ( ) && ( compareChecksums [ 0 ] != checksums [ 0 ] || compareChecksums [ 1 ] != checksums [ 1 ] ) ) { return false ; } return true ; }
te	2	private void initPanelDBarComponents ( ) { kPxy = new XKPanel [ 18 ] [ 2 ] ; for ( int i = 0 ; i < 18 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) kPxy [ i ] [ j ] = new XKPanel ( i , j ) . init ( c ) ; }
te	2	public static void OutputtoCytoscapeFile ( String path ) { for ( Entry < String , Map < String , Integer >> entry : extractionHash . entrySet ( ) ) { Map < String , Integer > curAdjMap = entry . getValue ( ) ; for ( Entry < String , Integer > subEntry : curAdjMap . entrySet ( ) ) { IOOperator . getInstance ( ) . writeToFileUTF8 ( path , entry . getKey ( ) + "\t" + subEntry . getKey ( ) + "\t" + subEntry . getValue ( ) + "\n" , true ) ; } } }
te	6	public boolean canSerialize ( class clazz , class jsonClazz ) { return ( ! clazz . isArray ( ) && ! clazz . isPrimitive ( ) && ! clazz . isInterface ( ) && ( bridge . isReference ( clazz ) || bridge . isCallableReference ( clazz ) ) && ( jsonClazz == null || jsonClazz == JSONObject . class ) ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Home2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Home2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Home2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Home2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Home2 ( ) . setVisible ( true ) ; } } ) ; }
te	4	public boolean isWalkable ( int wx , int wy ) { if ( wx < walkWidth && wy < walkHeight && wx >= 0 && wy >= 0 ) { return walkable [ wx + walkWidth * wy ] ; } else { return false ; } }
te	6	public void download ( InputStream ihx ) throws IOException { byte scratch [ ] = new byte [ 2 ] ; Vector v = new Vector ( ) ; for ( ; ; ) { int temp , len , xsum ; FirmwareRecord r = new FirmwareRecord ( ) ; do { temp = ihx . read ( ) ; } while ( temp != : && Character . isWhitespace ( ( char ) temp ) ) ; if ( temp == 0 ) break ; len = getByte ( ihx , scratch ) ; xsum = len ; r . data = new byte [ len ] ; r . addr = getByte ( ihx , scratch ) ; xsum += r . addr ; temp = getByte ( ihx , scratch ) ; xsum += temp ; r . addr += temp << 8 ; xsum += getByte ( ihx , scratch ) ; for ( int i = 0 ; i < len ; i ++ ) r . data [ i ] = getByte ( ihx , scratch ) ; xsum += getByte ( ihx , scratch ) ; if ( ( xsum & ff ) != 0 ) throw new IOException ( "corrupt hex input file" ) ; v . addElement ( r ) ; } download ( v ) ; }
te	6	private void showMove ( final Move step , final boolean doPrint ) { if ( doPrint ) { this . appendSolutionText ( ( step . stepNumber + 1 ) + ": " , null ) ; final Font font = this . jtextSolution . getFont ( ) ; final String -> ; switch ( step . direction ) { case Board . EAST : -> = getRightwardsArrow ( font ) ; break ; case Board . WEST : -> = getLeftwardsArrow ( font ) ; break ; case Board . NORTH : -> = getUpwardsArrow ( font ) ; break ; case Board . SOUTH : -> = getDownwardsArrow ( font ) ; break ; default : -> = "?" ; break ; } this . appendSolutionText ( " " + -> + " " , COL_ROBOT [ step . robotNumber ] ) ; this . appendSolutionText ( " " + Board . getColorLongL10N ( step . robotNumber ) + " " + step . strDirectionL10Nlong ( ) + ( this . computedSolutionList . get ( this . computedSolutionIndex ) . isRebound ( step ) ? " " + L10N . getString ( "txt.Rebound.text" ) : "" ) + "\n" , null ) ; } this . refreshButtons ( ) ; this . refreshBoard ( step ) ; }
te	5	public ProducerGUI ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 572 , 232 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JPanel panel = new JPanel ( ) ; panel . setBounds ( 0 , 0 , 570 , 203 ) ; contentPane . add ( panel ) ; panel . setLayout ( null ) ; JLabel lblAddNewProducer = new JLabel ( "Add new Producer" ) ; lblAddNewProducer . setFont ( new Font ( "Dialog" , Font . BOLD , 16 ) ) ; lblAddNewProducer . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblAddNewProducer . setBounds ( 194 , 12 , 175 , 15 ) ; panel . add ( lblAddNewProducer ) ; JLabel name = new JLabel ( "Name:" ) ; name . setBounds ( 22 , 46 , 70 , 15 ) ; panel . add ( name ) ; txt_P_name = new JTextField ( ) ; txt_P_name . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "name" , txt_P_name . getText ( ) , nameID , currentID ) ; } } ) ; txt_P_name . setBounds ( 150 , 44 , 255 , 19 ) ; panel . add ( txt_P_name ) ; txt_P_name . setColumns ( 10 ) ; txt_P_address = new JTextField ( ) ; txt_P_address . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "address" , txt_P_address . getText ( ) , nameID , currentID ) ; } } ) ; txt_P_address . setColumns ( 10 ) ; txt_P_address . setBounds ( 150 , 75 , 255 , 19 ) ; panel . add ( txt_P_address ) ; JLabel address = new JLabel ( "Address:" ) ; address . setBounds ( 22 , 77 , 70 , 15 ) ; panel . add ( address ) ; txt_P_loc = new JTextField ( ) ; txt_P_loc . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "location" , txt_P_loc . getText ( ) , nameID , currentID ) ; } } ) ; txt_P_loc . setColumns ( 10 ) ; txt_P_loc . setBounds ( 150 , 106 , 255 , 19 ) ; panel . add ( txt_P_loc ) ; JLabel location = new JLabel ( "Location" ) ; location . setBounds ( 22 , 108 , 70 , 15 ) ; panel . add ( location ) ; JButton btn_P_first = new JButton ( "<<" ) ; btn_P_first . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { result = query . query ( nameTBL , 1 , nameID ) ; insertValues ( result ) ; currentID = 1 ; } } ) ; btn_P_first . setBounds ( 27 , 150 , 54 , 25 ) ; panel . add ( btn_P_first ) ; JButton btn_P_back = new JButton ( "<" ) ; btn_P_back . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentID > 1 ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_P_back . setBounds ( 81 , 150 , 54 , 25 ) ; panel . add ( btn_P_back ) ; JButton btn_P_forward = new JButton ( ">" ) ; btn_P_forward . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID ++ ; if ( currentID > 0 && currentID <= maxID ) { result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null ) { currentID ++ ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_P_forward . setBounds ( 133 , 150 , 54 , 25 ) ; panel . add ( btn_P_forward ) ; JButton btn_P_last = new JButton ( ">>" ) ; btn_P_last . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { maxID = query . maxID ( nameTBL , nameID ) ; currentID = maxID ; result = query . query ( nameTBL , maxID , nameID ) ; insertValues ( result ) ; } } ) ; btn_P_last . setBounds ( 188 , 150 , 54 , 25 ) ; panel . add ( btn_P_last ) ; JButton btn_P_new = new JButton ( "New" ) ; btn_P_new . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID = maxID + 1 ; frameProdGui . txt_P_name . setText ( "" ) ; frameProdGui . txt_P_name . requestFocusInWindow ( ) ; frameProdGui . txt_P_loc . setText ( "" ) ; frameProdGui . txt_P_address . setText ( "" ) ; } } ) ; btn_P_new . setBounds ( 243 , 150 , 70 , 25 ) ; panel . add ( btn_P_new ) ; JButton btn_P_save = new JButton ( "Save" ) ; btn_P_save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { newValues [ 0 ] = "" + txt_P_name . getText ( ) ; newValues [ 1 ] = "" + txt_P_address . getText ( ) ; newValues [ 2 ] = "" + txt_P_loc . getText ( ) ; insert . insert ( nameTBL , nameTxtF , newValues ) ; maxID = query . maxID ( nameTBL , nameID ) ; } } ) ; btn_P_save . setBounds ( 311 , 150 , 68 , 25 ) ; panel . add ( btn_P_save ) ; JButton btn_P_del = new JButton ( "Del" ) ; btn_P_del . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { delete . delete ( nameTBL , nameID , currentID ) ; } } ) ; btn_P_del . setBounds ( 381 , 150 , 70 , 25 ) ; panel . add ( btn_P_del ) ; setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; }
te	2	public void randomize ( ) { Random r = pop . getRandom ( ) ; for ( int i = str . size ( ) - 1 ; i >= 0 ; i -- ) { if ( r . nextInt ( ) < 0 ) str . clear ( i ) ; else str . set ( i ) ; } evalNecessary = true ; }
te	1	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { processRequest ( request , response ) ; } catch ( Exception ex ) { Logger . getLogger ( ControlJson . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	4	public static ComboBoxModel getAllParameters ( ) { if ( parameterModel == null ) { checkParameterList ( ) ; parameterModel = new DefaultComboBoxModel ( ) ; for ( String v : parameters . keySet ( ) ) { if ( v . equals ( "Neighbore" ) || v . equals ( "Datapoint" ) ) continue ; parameterModel . addElement ( v ) ; } } System . out . println ( parameterModel . getSize ( ) ) ; return parameterModel ; }
te	1	@ Override public boolean equals ( Object object ) { if ( object instanceof AtomChar ) { return ( ( AtomChar ) object ) . value == value ; } else { return false ; } }
te	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || ! ( o instanceof TypeKey ) ) { return false ; } else { TypeKey other = ( TypeKey ) o ; if ( this . getTypeCode ( ) != null && other . getTypeCode ( ) != null && this . getTypeCode ( ) . trim ( ) . equalsIgnoreCase ( other . getTypeCode ( ) . trim ( ) ) ) { return true ; } else { return false ; } } }
te	5	void checkBounds ( ) { if ( buzzThis != null ) { Vector3d t = new Vector3d ( buzzThis . p . x , buzzThis . p . y + TURN_RADIUS , 0 ) ; if ( p . x > buzzThis . p . x + RANGE || p . x < buzzThis . p . x - RANGE ) { moveManager . setTargetPoint ( t ) ; } if ( p . y > buzzThis . p . y + RANGE || p . y < buzzThis . p . y - RANGE ) { moveManager . setTargetPoint ( t ) ; } } }
te	0	public final boolean isOverride ( ) { return ( flags & ACC_OVERRIDE ) == ACC_OVERRIDE ; }
te	6	public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; String str = cin . next ( ) ; int n = str . length ( ) ; int n1 = 0 , n2 = 0 ; int max = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > max && 3 * i <= n + 2 ) { max = i ; } } n1 = max ; n2 = n + 2 - 2 * max ; for ( int i = 0 ; i < n1 - 1 ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; for ( int j = 1 ; j < n2 - 1 ; j ++ ) { System . out . print ( " " ) ; } System . out . println ( str . charAt ( n - i - 1 ) ) ; } for ( int i = 0 ; i != n2 ; i ++ ) { System . out . print ( str . charAt ( n1 + i - 1 ) ) ; } }
te	5	public void startNewGame ( ) { createTime = new Date ( ) ; int count = 0 ; for ( ItalianDeckSuit suit : ItalianDeckCard . ItalianDeckSuit . values ( ) ) { for ( ItalianDeckRank rank : ItalianDeckCard . ItalianDeckRank . values ( ) ) { deck [ count ++ ] = new ItalianDeckCard ( suit , rank ) ; } } for ( int i = 0 ; i < deck . length ; i ++ ) { ItalianDeckCard card = deck [ i ] ; int random = ( int ) ( Math . random ( ) * 40 ) ; deck [ i ] = deck [ random ] ; deck [ random ] = card ; } this . life = drawCard ( ) ; hasStarted = true ; for ( int i = 0 ; i < playerHands . length ; i ++ ) { ItalianDeckCard [ ] temp = new ItalianDeckCard [ 3 ] ; for ( int j = 0 ; j < temp . length ; j ++ ) { temp [ j ] = drawCard ( ) ; } playerHands [ i ] = temp ; } }
te	4	private static int bruteForce ( int [ ] ints , int [ ] toVerify ) { HashSet < Integer > set = new HashSet < Integer > ( 10000 ) ; for ( int next2Verify : toVerify ) { for ( int i = 0 ; i < ints . length ; i ++ ) { for ( int j = i + 1 ; j < ints . length ; j ++ ) { if ( ( ints [ i ] + ints [ j ] == next2Verify ) ) { set . add ( next2Verify ) ; } } } } return set . size ( ) ; }
te	6	public void list2BQ ( Node node ) { while ( node != null ) { if ( node . content != null ) list2BQ ( node . content ) ; if ( node . tag != null && node . tag . parser == ParserImpl . getParseList ( ) && node . hasOneChild ( ) && node . content . implicit ) { stripOnlyChild ( node ) ; node . element = tt . tagBlockquote . name ; node . tag = tt . tagBlockquote ; node . implicit = true ; } node = node . next ; } }
te	7	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { LoginForm form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; if ( ! form . isPresent ( ) ) { return "e_login.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { return "e_login.jsp" ; } Transaction . begin ( ) ; EmployeeBean employee = employeeDAO . login ( form . getUserName ( ) , form . getPassword ( ) ) ; if ( employee == null ) { errors . add ( "User Name not found" ) ; Transaction . commit ( ) ; return "e_login.jsp" ; } HttpSession session = request . getSession ( ) ; session . setMaxInactiveInterval ( 600 ) ; session . setAttribute ( "employee" , employee ) ; Transaction . commit ( ) ; return "e_customermanage.jsp" ; } catch ( RollbackException e ) { errors . add ( e . getMessage ( ) ) ; return "e_login.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "e_login.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_login.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
te	4	private static State atLeast ( String x , int n , Collection < State > initials , boolean zeros ) { State s = new State ( ) ; if ( x . length ( ) == n ) s . setAccept ( true ) ; else { if ( zeros ) initials . add ( s ) ; char c = x . charAt ( n ) ; s . addTransition ( new Transition ( c , atLeast ( x , n + 1 , initials , zeros && c == 0 ) ) ) ; if ( c < 9 ) s . addTransition ( new Transition ( ( char ) ( c + 1 ) , 9 , anyOfRightLength ( x , n + 1 ) ) ) ; } return s ; }
te	8	public CustomTable ( String tableName , BeanContainer < ? , ? > beans ) { VerticalLayout layout = new VerticalLayout ( ) ; final Table table = new Table ( tableName , beans ) ; table . setColumnReorderingAllowed ( true ) ; table . setEditable ( true ) ; table . setSelectable ( true ) ; table . setContainerDataSource ( beans ) ; layout . addComponent ( table ) ; table . setSizeUndefined ( ) ; layout . setSizeUndefined ( ) ; setCompositionRoot ( layout ) ; final HashMap < Object , HashMap < Object , Field >> fields = new HashMap < Object , HashMap < Object , Field >> ( ) ; table . setTableFieldFactory ( new DefaultFieldFactory ( ) { private static final long serialVersionUID = - 5741977060384915110 ; public Field createField ( Container container , final Object itemId , final Object propertyId , Component uiContext ) { String typeId = container . getType ( propertyId ) . toString ( ) ; if ( typeId . equals ( String . class . toString ( ) ) | typeId . equals ( long . class . toString ( ) ) ) { final TextField tf = new TextField ( ) ; tf . setImmediate ( true ) ; HashMap < Object , Field > itemMap = fields . get ( itemId ) ; if ( itemMap == null ) { itemMap = new HashMap < Object , Field > ( ) ; fields . put ( itemId , itemMap ) ; } itemMap . put ( propertyId , tf ) ; tf . setReadOnly ( true ) ; tf . addListener ( new FocusListener ( ) { private static final long serialVersionUID = 1006388127259206641 ; public void focus ( FocusEvent event ) { HashMap < Object , Field > itemMap = fields . get ( itemId ) ; for ( Field f : itemMap . values ( ) ) f . setReadOnly ( false ) ; table . select ( itemId ) ; } } ) ; tf . addListener ( new BlurListener ( ) { private static final long serialVersionUID = - 4497552765206819985 ; public void blur ( BlurEvent event ) { HashMap < Object , Field > itemMap = fields . get ( itemId ) ; for ( Field f : itemMap . values ( ) ) f . setReadOnly ( true ) ; } } ) ; return tf ; } if ( typeId . equals ( CarrierStatus . class . toString ( ) ) ) { Select select = new Select ( ) ; for ( CarrierStatus cs : CarrierStatus . values ( ) ) { select . addItem ( cs . getHumanReadble ( ) ) ; } System . out . println ( container . getItem ( itemId ) ) ; select . setValue ( propertyId ) ; return select ; } return super . createField ( container , itemId , propertyId , uiContext ) ; } } ) ; }
te	6	@ Override public ArrayList < ImagePart > scan ( ArrayList < byte > data ) { ArrayList < ImagePart > parts = new ArrayList < ImagePart > ( ) ; int i = 0 ; while ( i < data . size ( ) ) { JPEGPart part = Part . getPart ( data . get ( i + 1 ) ) . getPartInstance ( i , data , false ) ; parts . add ( part ) ; i += part . getLength ( ) ; System . out . println ( part . getInfo ( ) ) ; if ( part . getPart ( ) == Part . SOS ) { part = Part . getPart ( ( byte ) 00 ) . getPartInstance ( i , data , true ) ; parts . add ( part ) ; while ( part . getPart ( ) != Part . EOI ) { if ( data . get ( i ) == - 1 && data . get ( i + 1 ) != 0 ) { part . setLength ( i - part . getPos ( ) - 1 ) ; System . out . println ( part . getInfo ( ) ) ; part = Part . getPart ( data . get ( i + 1 ) ) . getPartInstance ( i , data , false ) ; parts . add ( part ) ; i += part . getLength ( ) ; if ( part . getPart ( ) != Part . EOI ) { part = Part . getPart ( ( byte ) 00 ) . getPartInstance ( i , data , true ) ; parts . add ( part ) ; System . out . println ( part . getInfo ( ) ) ; } System . out . println ( part . getInfo ( ) ) ; } else { i ++ ; } } } } return parts ; }
te	9	@ Override public void takeTurn ( ) { if ( Game . player . currentLocation == World . prisonCell || Game . player . currentLocation == World . prisonHallway ) { if ( position == 2 ) { System . out . println ( "The guard peers into the cell " + " checking that the door is secured  then continues on." ) ; if ( ! this . cellDoor . locked ) { System . out . println ( "The door swings open." ) ; System . out . println ( "You have been caught." ) ; Game . hasLost = true ; } else if ( Game . player . currentLocation == World . prisonHallway ) { System . out . println ( "The guard is confused by your absence." ) ; Game . hasWon = true ; } } else if ( position == 5 || position == - 1 ) { System . out . println ( "The guard turns around." ) ; delta *= - 1 ; if ( Game . player . currentLocation == World . prisonHallway ) { System . out . println ( "You step out of your cell in full view of the guard." ) ; System . out . println ( "You have been caught." ) ; Game . hasLost = true ; } } else if ( Math . abs ( position + delta - 2 ) > Math . abs ( position - 2 ) ) { System . out . println ( "The guard walks away from your cell." ) ; if ( Game . player . currentLocation == World . prisonHallway ) { System . out . println ( "You escape silently into the shadows." ) ; Game . hasWon = true ; } } else { System . out . println ( "The guard walks toward your cell." ) ; if ( Game . player . currentLocation == World . prisonHallway ) { System . out . println ( "You step out of your cell in full view of the guard." ) ; System . out . println ( "You have been caught." ) ; Game . hasLost = true ; } } position += delta ; } else { return ; } }
te	7	private byte [ ] getMessage ( String deviceToken , final Payload payload , final int identifier , final PushedNotification message ) throws IOException , Exception { logger . debug ( "Building Raw message from deviceToken and payload" ) ; final byte [ ] deviceTokenAsBytes = new byte [ deviceToken . length ( ) / 2 ] ; deviceToken = deviceToken . toUpperCase ( ) ; int j = 0 ; try { for ( int i = 0 ; i < deviceToken . length ( ) ; i += 2 ) { final String t = deviceToken . substring ( i , i + 2 ) ; final int tmp = Integer . parseInt ( t , 16 ) ; deviceTokenAsBytes [ j ++ ] = ( byte ) tmp ; } } catch ( final NumberFormatException e1 ) { throw new InvalidDeviceTokenFormatException ( deviceToken , e1 . getMessage ( ) ) ; } preconfigurePayload ( payload , identifier , deviceToken ) ; final byte [ ] payloadAsBytes = payload . getPayloadAsBytes ( ) ; final int size = ( byte . SIZE / byte . SIZE ) + ( Character . SIZE / byte . SIZE ) + deviceTokenAsBytes . length + ( Character . SIZE / byte . SIZE ) + payloadAsBytes . length ; final ByteArrayOutputStream bao = new ByteArrayOutputStream ( size ) ; if ( useEnhancedNotificationFormat ) { final byte b = 1 ; bao . write ( b ) ; } else { final byte b = 0 ; bao . write ( b ) ; } if ( useEnhancedNotificationFormat ) { bao . write ( intTo4ByteArray ( identifier ) ) ; message . setIdentifier ( identifier ) ; final int requestedExpiry = payload . getExpiry ( ) ; if ( requestedExpiry <= 0 ) { bao . write ( intTo4ByteArray ( requestedExpiry ) ) ; message . setExpiry ( 0 ) ; } else { final long ctime = System . currentTimeMillis ( ) ; final long ttl = requestedExpiry * 1000 ; final long expiryDateInSeconds = ( ( ctime + ttl ) / 1000 ) ; bao . write ( intTo4ByteArray ( expiryDateInSeconds . intValue ( ) ) ) ; message . setExpiry ( ctime + ttl ) ; } } final int tl = deviceTokenAsBytes . length ; bao . write ( intTo2ByteArray ( tl ) ) ; bao . write ( deviceTokenAsBytes ) ; final int pl = payloadAsBytes . length ; bao . write ( intTo2ByteArray ( pl ) ) ; bao . write ( payloadAsBytes ) ; bao . flush ( ) ; final byte [ ] bytes = bao . toByteArray ( ) ; if ( heavyDebugMode ) { try { final FileOutputStream outf = new FileOutputStream ( "apns-message.bytes" ) ; outf . write ( bytes ) ; outf . close ( ) ; } catch ( final Exception e ) { } } logger . debug ( "Built raw message ID " + identifier + " of total length " + bytes . length ) ; return bytes ; }
te	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RecordSelectorNode other = ( RecordSelectorNode ) obj ; if ( selector == null ) { if ( other . selector != null ) return false ; } else if ( ! selector . equals ( other . selector ) ) return false ; if ( subject == null ) { if ( other . subject != null ) return false ; } else if ( ! subject . equals ( other . subject ) ) return false ; return true ; }
te	9	public void parse ( ) throws IOException { int intValue ; State state = initialState ; StateCharMap scm = stateCharMaps . get ( state ) ; final StringBuilder sb = new StringBuilder ( ) ; enteredState ( state , sb ) ; while ( ( intValue = in . read ( ) ) != - 1 ) { final char charValue = ( char ) intValue ; if ( charValue == '' ) { line ++ ; column = 1 ; } else { column ++ ; } final Transition transition = scm . getFor ( charValue ) ; sb . append ( charValue ) ; if ( LOGGER . isTraceEnabled ( ) ) { LOGGER . trace ( "{}:{}  Char={}  Buffer: {}" , new Object [ ] { pos ( ) , state , charValue , sb } ) ; } if ( transition != null ) { try { if ( LOGGER . isTraceEnabled ( ) ) { LOGGER . trace ( "{}:{}  Match: {}  to: {}" , new Object [ ] { pos ( ) , state , charValue , transition . to ( ) } ) ; } transition . fire ( this , sb ) ; if ( transition . from ( ) != transition . to ( ) ) { leftState ( state , sb ) ; enteredState ( transition . to ( ) , sb ) ; } state = transition . to ( ) ; { State myForced = forcedState ; if ( myForced != null ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( "Forced to state {} when state {} would be the transitions choice" , new Object [ ] { myForced , state } ) ; } state = myForced ; forcedState = null ; } } scm = stateCharMaps . get ( state ) ; if ( scm == null ) { throw new IllegalStateException ( "SCM for " + state + " not found" ) ; } } catch ( Exception ex ) { throw new IOException ( ex ) ; } } } if ( scm . getEofTransition ( ) != null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "Executing EOF transition" ) ; try { scm . getEofTransition ( ) . fire ( this , sb ) ; } catch ( Exception ex ) { throw new IOException ( ex ) ; } } }
te	0	public static void removeConnection ( String identifier ) { htConnections . remove ( identifier ) ; }
te	5	private int down ( int row , int col , int depthRemaining , int valueSoFar ) { if ( depthRemaining == 0 ) { return valueSoFar ; } if ( row < 0 || col < 0 || row >= height || col >= width ) { return 0 ; } int current = grid [ row ] [ col ] ; int newValue = valueSoFar * current ; int newDepth = depthRemaining - 1 ; return down ( row + 1 , col , newDepth , newValue ) ; }
te	9	private void endRound ( boolean didWeLose ) { if ( didWeLose == true ) { try { FileWriter writer = new FileWriter ( "lib/TextFiles/Score.txt" ) ; writer . write ( "Your score was " + Score + "!" ) ; writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( SimonButton button : buttons ) { button . setEnabled ( false ) ; button . removeActionListeners ( ) ; System . out . println ( "set buttons enabled false" ) ; } System . out . println ( "You lost! Press start to begin again." ) ; new SimonGameOver ( ) ; placeInSequence = 0 ; Random randomGen = new Random ( System . currentTimeMillis ( ) ) ; int randomNum = randomGen . nextInt ( 4 ) ; int randomNum2 = ( int ) ( Math . random ( ) * 3.9999999 ) ; computerButtonPresses = new ArrayList < Integer > ( ) ; computerButtonPresses . add ( randomNum2 ) ; currentButton = computerButtonPresses . get ( 0 ) ; startButtonLocation . add ( startButton ) ; startButtonLocation . revalidate ( ) ; startButtonLocation . repaint ( ) ; } else if ( didWeLose == false ) { if ( ! roundPassed ) { roundPassed = true ; placeInSequence = 0 ; currentButton = computerButtonPresses . get ( 0 ) ; go ( ) ; } else { System . out . println ( "Success! Onto the next round!" ) ; Score ++ ; score . setText ( "Score: " + Score + "  " ) ; try { File myFile = new File ( "lib/TextFiles/HighScoreProLevel.txt" ) ; FileReader fileReader = new FileReader ( myFile ) ; BufferedReader reader = new BufferedReader ( fileReader ) ; String line ; String l = null ; while ( ( line = reader . readLine ( ) ) != null ) { l = line ; } String [ ] HighestScore = l . split ( ": " ) ; String s = null ; for ( String token : HighestScore ) { s = token ; } highScore = Integer . parseInt ( String . valueOf ( s ) ) ; reader . close ( ) ; if ( highScore < Score ) { try { FileWriter writer = new FileWriter ( "lib/TextFiles/HighScoreProLevel.txt" ) ; writer . write ( "Highest Score: " + Score ) ; writer . close ( ) ; score . setForeground ( Color . RED ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } catch ( IOException ex ) { try { FileWriter writer = new FileWriter ( "lib/TextFiles/HighScoreProLevel.txt" ) ; writer . write ( "Highest Score: " + Score ) ; writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } Random randomGen = new Random ( System . currentTimeMillis ( ) ) ; int randomNum = randomGen . nextInt ( 4 ) ; int randomNum2 = ( int ) ( Math . random ( ) * 3.9999999 ) ; computerButtonPresses . add ( randomNum2 ) ; placeInSequence = 0 ; currentButton = computerButtonPresses . get ( 0 ) ; go ( ) ; } } }
te	1	static byte [ ] getPieceTypesForPlayer ( int player , byte [ ] pieceTypesToCopy ) { byte [ ] pieceTypes = new byte [ pieceTypesToCopy . length / 2 ] ; for ( int i = player ; i < pieceTypesToCopy . length ; i += 2 ) pieceTypes [ i / 2 ] = pieceTypesToCopy [ i ] ; return pieceTypes ; }
te	2	public DefaultSSLWebSocketServerFactory ( SSLContext sslContext , ExecutorService exec ) { if ( sslContext == null || exec == null ) throw new IllegalArgumentException ( ) ; this . sslcontext = sslContext ; this . exec = exec ; }
te	6	private void update ( ) { options = Opts . updateEnabledOptions ( options ) ; changeInfo ( ) ; allowOnChange = false ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( currentIndex + i >= options . length ) { lists [ i ] . visible = false ; labels [ i ] . visible = false ; } else { lists [ i ] . visible = true ; labels [ i ] . visible = true ; if ( options [ currentIndex + i ] . ask == Opts . Option . ASK_ONCE ) options [ currentIndex + i ] . set ( options [ currentIndex + i ] . opts . size ( ) - 2 ) ; else if ( options [ currentIndex + i ] . ask == Opts . Option . ASK_ALWAYS ) options [ currentIndex + i ] . set ( options [ currentIndex + i ] . opts . size ( ) - 1 ) ; if ( options [ currentIndex + i ] . ask > 0 ) options [ currentIndex + i ] . ask = 0 ; labels [ i ] . enabled = options [ currentIndex + i ] . enabled ; lists [ i ] . enabled = options [ currentIndex + i ] . enabled ; labels [ i ] . text = options [ currentIndex + i ] . name ; lists [ i ] . id = options [ currentIndex + i ] . ID ( ) + "" ; lists [ i ] . clearOptions ( ) ; for ( String [ ] opt : options [ currentIndex + i ] . opts ) { lists [ i ] . addOptionWithLang ( opt ) ; } lists [ i ] . setSelectedIndex ( options [ currentIndex + i ] . selected ) ; } } options = Opts . updateEnabledOptions ( options ) ; allowOnChange = true ; Main . main . canvas . paint ( ) ; }
te	3	private boolean setGameType ( int gameType ) { boolean conGame ; if ( gameType == OTHELLO || gameType == CONNECT || gameType == TICTACTOE ) { m_Game = gameType ; conGame = true ; } else { conGame = false ; } return conGame ; }
te	6	public boolean baca ( String kode_buku ) { boolean adaKesalahan = false ; Connection cn = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = ( Connection ) DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke" + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { String SQLStatemen = "select * from buku where kode_buku='" + kode_buku + "'" ; Statement sta = ( Statement ) cn . createStatement ( ) ; ResultSet rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; if ( rset . getRow ( ) > 0 ) { this . kodeBuku = rset . getString ( "kode_buku" ) ; this . judulBuku = rset . getString ( "judul_buku" ) ; this . Penerbit = rset . getString ( "penerbit" ) ; sta . close ( ) ; rset . close ( ) ; } else { sta . close ( ) ; rset . close ( ) ; adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Kode Buku\"" + kode_buku + "\" tidak ditemukan" , "Informasi" , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Tidak dapat membuka tabel buku\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } return ! adaKesalahan ; }
te	9	public static String drawRequirementElement ( RequirementElement target , RequirementElement reference , String direction ) { String layer = target . getLayer ( ) ; double x = 0 , y = 0 ; String position = "" ; if ( direction . equals ( "up" ) ) { x = reference . origin_x ; y = reference . origin_y - 200 ; } else if ( direction . equals ( "down" ) ) { x = reference . origin_x ; y = reference . origin_y + 200 ; } else if ( direction . equals ( "left" ) ) { x = reference . origin_x - 200 ; y = reference . origin_y ; } else if ( direction . equals ( "right" ) ) { x = reference . origin_x + 200 ; y = reference . origin_y ; } else { } position = "{" + x + " " + y + "}" ; target . origin_x = x ; target . origin_y = y ; String shape = InfoEnum . reverse_req_elem_type_map . get ( target . getType ( ) ) ; String name = target . getName ( ) ; String corner_radius = "0" ; String stroke_pattern = "0" ; String thickness = "1" ; if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . DOMAIN_ASSUMPTION . name ( ) ) ) { corner_radius = "5" ; } else if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { name = "(S)\n" + name ; } else if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_MECHANISM . name ( ) ) ) { name = "(S)\n" + name ; } else if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) ) ) { stroke_pattern = "2" ; thickness = "2" ; } int size_type = 0 ; if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . ACTOR . name ( ) ) ) { size_type = InfoEnum . ACTOR_SIZE ; } else if ( target . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { size_type = InfoEnum . POINT_SIZE ; } return drawArbitraryRequirementElement ( InfoEnum . REQ_TARGET_CANVAS , layer , shape , size_type , position , corner_radius , name , stroke_pattern , thickness ) ; }
te	9	public void printDatabase ( ) { System . out . println ( "??Album:" + _albums . size ( ) ) ; for ( int i = 0 ; i < _albums . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _albums . get ( i ) . toString ( ) ) ; } System . out . println ( "??Album_Track:" + _albumTracks . size ( ) ) ; for ( int i = 0 ; i < _albumTracks . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _albumTracks . get ( i ) . toString ( ) ) ; } System . out . println ( "??Artist:" + _artists . size ( ) ) ; for ( int i = 0 ; i < _artists . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + "|?" + _artists . get ( i ) ) ; } System . out . println ( "??Artist_Track:" + _artistTracks . size ( ) ) ; for ( int i = 0 ; i < _artistTracks . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _artistTracks . get ( i ) . toString ( ) ) ; } System . out . println ( "??Playlist:" + _playlists . size ( ) ) ; for ( int i = 0 ; i < _playlists . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + "|?" + _playlists . get ( i ) ) ; } System . out . println ( "??Playlist_Track:" + _playlistTracks . size ( ) ) ; for ( int i = 0 ; i < _playlistTracks . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _playlistTracks . get ( i ) . toString ( ) ) ; } System . out . println ( "??Track:" + _tracks . size ( ) ) ; for ( int i = 0 ; i < _tracks . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _tracks . get ( i ) . toString ( ) ) ; } System . out . println ( "??Genre:" + _genres . size ( ) ) ; for ( int i = 0 ; i < _genres . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + "|?" + _genres . get ( i ) ) ; } System . out . println ( "??Genre_Track:" + _genreTracks . size ( ) ) ; for ( int i = 0 ; i < _genreTracks . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _genreTracks . get ( i ) . toString ( ) ) ; } System . out . println ( "??Artist_Album:" + _artistAlbums . size ( ) ) ; for ( int i = 0 ; i < _artistAlbums . size ( ) ; ++ i ) { System . out . println ( "\t?" + i + _artistAlbums . get ( i ) . toString ( ) ) ; } }
te	1	public boolean isPassengerAlreadyRegistered ( OrderDTO order ) { log . debug ( "Start method isPassengerAlreadyRegistered(...)" ) ; EntityManager entityManager = entityManagerFactory . createEntityManager ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < Integer > passenger = entityManager . createQuery ( "select p.id from Passenger p  Ticket t " + "where p.firstName = ?1 and p.secondName = ?2 and p.dateOfBirth = ?3 and " + "p.id = t.passenger.id and t.train.number = ?4" ) . setParameter ( 1 , order . getFirstName ( ) ) . setParameter ( 2 , order . getSecondName ( ) ) . setParameter ( 3 , order . getDateOfBirth ( ) ) . setParameter ( 4 , order . getTrainNumber ( ) ) . getResultList ( ) ; entityManager . getTransaction ( ) . commit ( ) ; if ( passenger . isEmpty ( ) ) { log . debug ( "Required passenger hasn't been found." ) ; log . debug ( "Finish method isPassengerAlreadyRegistered(...)" ) ; return false ; } else { log . debug ( "Required passenger found." ) ; log . debug ( "Finish method isPassengerAlreadyRegistered(...)" ) ; return true ; } }
te	2	public void select ( ) { Iterator < Enemy > iterator = bot . enemies . values ( ) . iterator ( ) ; int maxTime = Integer . MIN_VALUE ; Enemy selected = null ; while ( iterator . hasNext ( ) ) { Enemy e = iterator . next ( ) ; if ( maxTime < e . timeScanned ) { selected = e ; maxTime = e . timeScanned ; } } bot . enemy = selected ; }
te	6	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int times = 1 ; while ( n != 0 ) { System . out . println ( "Case " + times + ":" ) ; long numbers [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { numbers [ i ] = scan . nextLong ( ) ; } long base = numbers [ 0 ] ; int cont = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( numbers [ i ] == ( numbers [ i - 1 ] + 1 ) ) { cont ++ ; } else { if ( cont == 0 ) { System . out . println ( "0" + numbers [ i - 1 ] ) ; } else { System . out . println ( "0" + numbers [ i - cont - 1 ] + "-" + diff ( numbers [ i - cont - 1 ] + "" , cont ) ) ; cont = 0 ; } } } if ( cont == 0 ) { System . out . println ( "0" + numbers [ n - 1 ] ) ; } else { System . out . println ( "0" + numbers [ n - cont - 1 ] + "-" + diff ( numbers [ n - cont - 1 ] + "" , cont ) ) ; } n = scan . nextInt ( ) ; System . out . println ( ) ; times ++ ; } }
te	1	public Move getLastMove ( ) { if ( this . movesList . size ( ) > 0 ) { return this . movesList . get ( this . movesList . size ( ) - 1 ) ; } else { return null ; } }
te	3	void displayRule ( String s ) { StringWriter swu = new StringWriter ( ) ; StringWriter swd = new StringWriter ( ) ; StringWriter swl = new StringWriter ( ) ; for ( int i = 0 , u = 0 , d = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '' ) { u = 0 ; d = 0 ; swu . append (   ) ; swd . append (   ) ; swl . append ( * ) ; continue ; } else { u = ( u + 1 ) % 10 ; } if ( u != 0 ) { swu . append ( String . valueOf ( u ) . charAt ( 0 ) ) ; swd . append (   ) ; swl . append (   ) ; } else { swu . append ( String . valueOf ( u ) . charAt ( 0 ) ) ; d += 1 ; swd . append ( String . valueOf ( d ) . charAt ( 0 ) ) ; swl . append (   ) ; } } }
te	0	public void setValorVenta ( double valorVenta ) { this . valorVenta = valorVenta ; }
te	1	@ Override protected void crearDisparo ( ) { this . disparo = new TripleConRetardo ( ) ; System . out . println ( "SE CREO EL DISPARO t con retardo" ) ; this . mouseListener . setDisparo ( this . disparo ) ; try { this . mouseListener . setUrlImagen ( new URL ( "file:./images/disparos/tripleConRetardo.PNG" ) ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } }
te	8	@ Override public boolean canSwitch ( MoveWithPP switchOption , Team opponent ) { if ( opponent . getActivePokemon ( ) . getAbility ( ) . preventsSwitching ( activePokemon ) ) { return false ; } Move switchTo = switchOption . getMove ( ) ; Pokemon pokeToSwitchIn = null ; switch ( switchTo ) { case SWITCH_1 : pokeToSwitchIn = party . get ( 0 ) ; break ; case SWITCH_2 : pokeToSwitchIn = party . get ( 1 ) ; break ; case SWITCH_3 : pokeToSwitchIn = party . get ( 2 ) ; break ; case SWITCH_4 : pokeToSwitchIn = party . get ( 3 ) ; break ; case SWITCH_5 : pokeToSwitchIn = party . get ( 4 ) ; break ; case SWITCH_6 : pokeToSwitchIn = party . get ( 5 ) ; break ; default : break ; } if ( ! pokeToSwitchIn . hasFainted ( ) ) { return true ; } else { return false ; } }
te	9	public static void Accordian ( ArrayList < Stack < String >> list ) { int i ; for ( i = 0 ; i < total ; i ++ ) { if ( i >= 3 && ( list . get ( i - 3 ) . peek ( ) . charAt ( 0 ) == list . get ( i ) . peek ( ) . charAt ( 0 ) || list . get ( i - 3 ) . peek ( ) . charAt ( 1 ) == list . get ( i ) . peek ( ) . charAt ( 1 ) ) ) { list . get ( i - 3 ) . push ( list . get ( i ) . pop ( ) ) ; if ( list . get ( i ) . isEmpty ( ) ) { total -- ; list . remove ( i ) ; } i = i - 4 ; } else if ( i >= 1 && ( list . get ( i - 1 ) . peek ( ) . charAt ( 0 ) == list . get ( i ) . peek ( ) . charAt ( 0 ) || list . get ( i - 1 ) . peek ( ) . charAt ( 1 ) == list . get ( i ) . peek ( ) . charAt ( 1 ) ) ) { list . get ( i - 1 ) . push ( list . get ( i ) . pop ( ) ) ; if ( list . get ( i ) . isEmpty ( ) ) { total -- ; list . remove ( i ) ; } i = i - 2 ; } } }
te	7	public void run ( ) { init ( ) ; double nsPerFrame = 1000000000D / 60D ; double unprocessedTime = 0 ; double maxSkipFrame = 10 ; long lastTime = System . nanoTime ( ) ; long lastFrameTime = System . currentTimeMillis ( ) ; int frames = 0 ; int ticks = 0 ; while ( running ) { long now = System . nanoTime ( ) ; double passedTime = ( now - lastTime ) / nsPerFrame ; lastTime = now ; if ( passedTime < - maxSkipFrame ) passedTime = - maxSkipFrame ; if ( passedTime > maxSkipFrame ) passedTime = maxSkipFrame ; unprocessedTime += passedTime ; boolean render = true ; while ( unprocessedTime > 1 ) { unprocessedTime -= 1 ; mouse = input . updateMouseStatus ( SCALE ) ; EntityListCache . reset ( ) ; tick ( ) ; ticks ++ ; render = true ; } if ( render ) { EntityListCache . reset ( ) ; render ( screenBitmap ) ; frames ++ ; } if ( System . currentTimeMillis ( ) - lastFrameTime > 1000 ) { lastFrameTime += 1000 ; System . out . println ( "fps: " + frames + "  ticks: " + ticks ) ; ticks = 0 ; frames = 0 ; } try { Thread . sleep ( 2 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } swap ( ) ; } }
te	5	public static void error ( Exception ex , boolean printStackTrace ) { if ( level == SILENT ) { return ; } String err ; if ( showTime ) { err = ex . toString ( ) ; } else { err = getDate ( ) + ERROR_STR + ex . toString ( ) ; ; } if ( logFile != null ) { try { writeToLogFile ( err ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . err . println ( err ) ; } if ( printStackTrace ) { ex . printStackTrace ( ) ; } }
te	2	public Doubly < E > removeTail ( ) { if ( this . isEmpty ( ) ) { return this ; } if ( this . size ( ) == 1 ) { this . resetList ( ) ; } else { Node < E > newTail = this . tail . getPrev ( ) ; Node < E > oldTail = this . tail ; newTail . setNext ( null ) ; oldTail . setPrev ( null ) ; this . tail = newTail ; } this . length -- ; return this ; }
te	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { this . put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
te	3	public boolean disassemble ( ) { ObjectFile objectFile = new ObjectFile ( objectFileName ) ; if ( objectFile . read ( ) ) { System . out . println ( "Disassembler: unable to read object file" + objectFileName ) ; return true ; } if ( objectFileName . endsWith ( ".mJAM" ) ) asmName = objectFileName . substring ( 0 , objectFileName . length ( ) - 5 ) + ".asm" ; else asmName = objectFileName + ".asm" ; disassembleProgram ( asmName ) ; if ( error ) { System . out . println ( "Disassembler: unable to write asm file" + asmName ) ; return true ; } return false ; }
te	3	public EncryptableObject decrypt ( Key key ) throws Exception { String Algrithem ; if ( key instanceof PrivateKey ) { Algrithem = "RSA" ; } else { Algrithem = "AES" ; } if ( encrypted == null ) { System . out . println ( "NULL" ) ; return null ; } Cipher decrypt = Cipher . getInstance ( Algrithem ) ; decrypt . init ( Cipher . DECRYPT_MODE , key ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( encrypted ) ; CipherInputStream cin = new CipherInputStream ( bais , decrypt ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 2048 ] ; int read = 0 ; while ( ( read = cin . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; out . flush ( ) ; } out . close ( ) ; cin . close ( ) ; bais . close ( ) ; return EncryptableObject . fromByteArray ( out . toByteArray ( ) ) ; }
te	6	@ Override public boolean equals ( Object obj ) { if ( null == obj ) { return false ; } if ( this == obj ) { return true ; } if ( obj instanceof PostParameter ) { PostParameter that = ( PostParameter ) obj ; if ( file != null ? ! file . equals ( that . file ) : that . file != null ) return false ; return this . name . equals ( that . name ) && this . value . equals ( that . value ) ; } return false ; }
te	2	private PatrolLocation getAvailablePatrolTile ( ) { int w = bwapi . getMap ( ) . getWalkWidth ( ) ; int h = bwapi . getMap ( ) . getWalkHeight ( ) ; PatrolLocation patrolLocation = new PatrolLocation ( r . nextInt ( w ) * 8 , r . nextInt ( h ) * 8 ) ; int count = 0 ; while ( ! patrolLocations . contains ( patrolLocation ) && ++ count < 500 ) { patrolLocation = new PatrolLocation ( r . nextInt ( w ) * 8 , r . nextInt ( h ) * 8 ) ; System . out . println ( String . format ( "location %s  was it already seen? %s" , patrolLocation , patrolLocations . contains ( patrolLocation ) ) ) ; return patrolLocation ; } patrolLocations . add ( patrolLocation ) ; return null ; }
te	8	public boolean turnTowards ( double angle ) { while ( dir < - Math . PI ) dir += Math . PI * 2 ; while ( dir >= Math . PI ) dir -= Math . PI * 2 ; while ( angle < - Math . PI ) angle += Math . PI * 2 ; while ( angle >= Math . PI ) angle -= Math . PI * 2 ; double angleDiff = angle - dir ; while ( angleDiff < - Math . PI ) angleDiff += Math . PI * 2 ; while ( angleDiff >= Math . PI ) angleDiff -= Math . PI * 2 ; double turnSpeed = 0.2 ; double near = 1.0 ; boolean wasAimed = angleDiff * angleDiff < near * near ; if ( angleDiff < - turnSpeed ) angleDiff = - turnSpeed ; if ( angleDiff > + turnSpeed ) angleDiff = + turnSpeed ; dir += angleDiff ; return wasAimed ; }
te	8	public boolean setKey ( String key , GroupedReader fin ) throws IOException { if ( key . equals ( "name" ) ) { String what = fin . readGroup ( ) ; setName ( what ) ; return true ; } else if ( key . equals ( "initial" ) ) { String what = fin . readGroup ( ) ; if ( what . equals ( "yes" ) ) setInitial ( true ) ; return true ; } else if ( key . equals ( "final" ) ) { String what = fin . readGroup ( ) ; if ( what . equals ( "yes" ) ) setFinal ( true ) ; return true ; } else if ( key . equals ( "coord" ) ) { String value = fin . readGroup ( ) ; int sep = value . indexOf (   ) ; if ( sep < 0 ) { throw new IOException ( "Missing argument" ) ; } try { x = Integer . parseInt ( value . substring ( 0 , sep ) ) ; y = Integer . parseInt ( value . substring ( sep + 1 ) ) ; } catch ( NumberFormatException e ) { throw new IOException ( "Nonnumeric argument" ) ; } return true ; } else { return super . setKey ( key , fin ) ; } }
te	3	public void write ( Kml kml ) throws KmlException { kml . println ( "<Location" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( latitude != null ) kml . println ( "<latitude>" + latitude + "</latitude>" ) ; if ( longitude != null ) kml . println ( "<longitude>" + longitude + "</longitude>" ) ; if ( altitude != null ) kml . println ( "<altitude>" + altitude + "</altitude>" ) ; kml . println ( - 1 , "</Location>" ) ; }
te	7	private Object readJSON ( ) throws JSONException { switch ( read ( 3 ) ) { case zipObject : return readObject ( ) ; case zipArrayString : return readArray ( true ) ; case zipArrayValue : return readArray ( false ) ; case zipEmptyObject : return new JSONObject ( ) ; case zipEmptyArray : return new JSONArray ( ) ; case zipTrue : return boolean . true ; case zipFalse : return boolean . false ; default : return JSONObject . null ; } }
te	6	@ Deprecated public DataTypes getType ( ) { DataTypes type = null ; if ( binaryOperators . contains ( getOperation ( ) ) ) { return DataTypes . boolean ; } if ( stringOperators . contains ( getOperation ( ) ) ) { return DataTypes . STRING ; } if ( left ( ) instanceof NumberAST ) { type = ( ( NumberAST ) left ( ) ) . getType ( ) ; } if ( right ( ) instanceof NumberAST ) { type = ( ( NumberAST ) right ( ) ) . getType ( ) ; } if ( left ( ) instanceof BinOP ) { type = ( ( BinOP ) left ( ) ) . getType ( ) ; } if ( right ( ) instanceof BinOP ) { type = ( ( BinOP ) right ( ) ) . getType ( ) ; } return type ; }
te	9	public static void main ( String [ ] args ) { int menu = 0 ; ListaProduto lp = new ListaProduto ( ) ; Scanner tec = new Scanner ( System . in ) ; System . out . println ( "zomboCom 3.0!" ) ; do { System . out . println ( "\nSelecione:" ) ; System . out . println ( "0 - Hora de dar Tchau!" ) ; System . out . println ( "1 - Adicionar um produto" ) ; System . out . println ( "2 - Procurar pela letra inicial" ) ; System . out . println ( "3 - Total de produtos" ) ; System . out . println ( "4 - Retornar descricao menor que " ) ; menu = tec . nextInt ( ) ; switch ( menu ) { case 1 : Produto p = new Produto ( ) ; System . out . print ( "Digite o codigo: " ) ; while ( ! p . setCodigo ( tec . nextInt ( ) ) ) System . out . println ( "Falha: Codigo deve ser maior que 99! Por favor digite novamente:" ) ; tec . nextLine ( ) ; System . out . print ( "Digite a descricao: " ) ; while ( ! p . setDescricao ( tec . nextLine ( ) ) ) System . out . println ( "Falha: Descricao deve ter mais de 5 caracteres! Por favor digite novamente:" ) ; System . out . print ( "Digite o estado: " ) ; while ( ! p . setSiglaEstado ( tec . next ( ) ) ) System . out . println ( "Falha: Estado nao encontrado!" ) ; System . out . print ( "Digite o valor: " ) ; while ( ! p . setValor ( tec . nextDouble ( ) ) ) System . out . println ( "Falha: Valor deve ser maior ou igual a 0! Por favor digite novamente:" ) ; lp . addProduto ( p ) ; break ; case 2 : System . out . println ( "Digite uma letra:" ) ; System . out . println ( lp . procurarInicial ( tec . next ( ) ) ) ; break ; case 3 : System . out . println ( "Total de produtos: " + lp . totalDeProdutos ( ) ) ; break ; case 4 : System . out . println ( "Producto com menor descricao do que: " ) ; System . out . println ( lp . descricaoMenor ( tec . nextInt ( ) ) ) ; break ; default : System . out . println ( "\nEscolha uma op\uFFFD\uFFFD\uFFFD\uFFFDo v\uFFFD\uFFFDlida!\n" ) ; break ; } } while ( menu != 0 ) ; tec . close ( ) ; }
te	6	@ Override public short [ ] next ( ) { short [ ] sound = new short [ channelCount ] ; for ( int i = 0 ; i < sources . size ( ) ; i ++ ) { SoundSource source = sources . get ( i ) ; if ( source != null && source . hasNext ( ) ) { short [ ] s = source . next ( ) ; super . performEffects ( i , s ) ; super . performVolumeMix ( i , s ) ; for ( int j = 0 ; j < channelCount ; j ++ ) { int t = sound [ j ] + s [ j ] ; if ( t > short . MAX_VALUE ) sound [ j ] = short . MAX_VALUE ; else if ( t < - short . MAX_VALUE ) sound [ j ] = - short . MAX_VALUE ; else sound [ j ] += s [ j ] ; } } } super . performMasterEffectAndVolumeMix ( sound ) ; return sound ; }
te	8	public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case USER_ID : return isSetUserId ( ) ; case NAME : return isSetName ( ) ; case SCREEN_NAME : return isSetScreen_name ( ) ; case LOCATION : return isSetLocation ( ) ; case CREATED_AT : return isSetCreatedAt ( ) ; case DESCRIPTION : return isSetDescription ( ) ; case IS_VERIFIED : return isSetIsVerified ( ) ; } throw new IllegalStateException ( ) ; }
te	2	void add ( ) { Set < String > stmts = new HashSet < String > ( ) ; stmts . add ( "Bird rdfs:subClassOf Animal" ) ; try { System . out . println ( name + " starts to add stmts..." ) ; for ( int i = 0 ; i < 50 ; i ++ ) { stmts . add ( "fish" + i + " rdf:type Animal" ) ; stmts . add ( "fish" + i + " weight 18.0" ) ; stmts . add ( "fish" + i + " eats seaweed" ) ; stmts . add ( "sparrow" + i + " rdf:type Bird" ) ; stmts . add ( "sparrow" + i + " weight 18.0" ) ; stmts . add ( "sparrow" + i + " eats grass" ) ; oro . add ( stmts ) ; stmts . clear ( ) ; } System . out . println ( name + " done with stmts adding." ) ; } catch ( IllegalStatementException e ) { fail ( ) ; } }
te	7	public boolean checkConstraint ( ) { int count1 = 0 ; int count2 = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str . charAt ( i ) >= 1 && str . charAt ( i ) <= 9 ) count1 ++ ; else if ( str . charAt ( i ) >= a && str . charAt ( i ) <= z ) count2 ++ ; } if ( count1 >= 1 && count2 >= 1 ) return true ; return false ; }
te	4	public void test_setAutoCommit_commit_rollback_close ( ) { Connection conn = null ; try { conn = getConnection ( ) ; assertTrue ( conn . getAutoCommit ( ) ) ; conn . setAutoCommit ( false ) ; assertFalse ( conn . getAutoCommit ( ) ) ; conn . commit ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Connectino threw the exception: conn=" + conn , e ) ; } finally { if ( conn != null ) { try { conn . rollback ( ) ; } catch ( SQLException ignored ) { } try { assertFalse ( conn . isClosed ( ) ) ; conn . close ( ) ; assertTrue ( conn . isClosed ( ) ) ; } catch ( SQLException ignored ) { } } } }
te	0	@ Test public void KyselynLuominenToimii ( ) { Kysely kysely = sailio . luoKysely ( "testikysely" ) ; assertEquals ( "testikysely" , kysely . getNimi ( ) ) ; }
te	2	public boolean contientClient ( int id ) { Client client ; for ( int i = 0 , l = clients . size ( ) ; i < l ; i ++ ) { client = clients . get ( i ) ; if ( client . getConnecteId ( ) == id ) { return true ; } } return false ; }
te	5	Object findEquiv ( Object subtree , Object elt ) { if ( subtree == null ) return NO_ELEMENT ; else if ( ! ( subtree instanceof Node ) ) { int bin_srch_res = binarySearch ( ( Object [ ] ) subtree , elt ) ; int found = bin_srch_res & BIN_SEARCH_FOUND_MASK ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( found == BIN_SEARCH_FOUND ) return ( ( Object [ ] ) subtree ) [ idx ] ; else return NO_ELEMENT ; } else { Node node = ( Node ) subtree ; Object nelt = node . element ; int comp_res = compare ( elt , nelt ) ; if ( comp_res == 0 ) return nelt ; else if ( comp_res < 0 ) return findEquiv ( node . left , elt ) ; else return findEquiv ( node . right , elt ) ; } }
te	0	protected final String fsp_name ( ) { return "CONDITION" ; }
te	0	public void setTolerance ( double tolerance ) { this . tolerance = tolerance ; }
te	1	public static void message ( String text ) { LogFile . write ( text ) ; if ( show_thinking ) { System . out . println ( text ) ; } }
te	2	public int hashCode ( ) { int hashCode = 0 ; for ( Specie s : lhs ) { hashCode += s . hashCode ( ) ; } for ( Specie s : rhs ) { hashCode -= s . hashCode ( ) ; } return hashCode ; }
te	7	private List < List < String >> product ( Map < Integer , List < String >> values ) { TreeMap < Integer , List < String >> sortValues = new TreeMap < Integer , List < String >> ( values ) ; List < List < String >> product = new ArrayList < List < String >> ( ) ; Map < Integer , Integer > index = new HashMap < Integer , Integer > ( ) ; int idx = 0 ; int idxSize = 0 ; do { idxSize = 0 ; List < String > v = new ArrayList < String > ( ) ; for ( int ii = 1 ; ii <= sortValues . lastKey ( ) ; ii ++ ) { List < String > l = values . get ( ii ) ; if ( l == null ) { v . add ( "" ) ; ++ idxSize ; continue ; } if ( l . size ( ) >= idx + 1 ) { v . add ( l . get ( idx ) ) ; index . put ( ii , idx ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Value: {}  pos: {}  at: {}" , new Object [ ] { l . get ( idx ) , ii , idx } ) ; } } else { v . add ( l . get ( 0 ) ) ; index . put ( ii , 0 ) ; ++ idxSize ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Value: {}  pos: {}  at index: {}" , new Object [ ] { l . get ( 0 ) , ii , 0 } ) ; } } } if ( idxSize != sortValues . lastKey ( ) ) { product . add ( v ) ; } ++ idx ; } while ( idxSize != sortValues . lastKey ( ) ) ; return product ; }
te	3	public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . out . println ( "Please provide only one parameter - a suitable property file" ) ; return ; } @ SuppressWarnings ( "unused" ) Sensor sensor = null ; try { sensor = SensorUtility . getSensorInstance ( args [ 0 ] ) ; } catch ( NodeInitializationException e ) { System . out . println ( e . getMessage ( ) ) ; return ; } Scanner in = new Scanner ( System . in ) ; String str = "" ; while ( ! "exit" . equals ( str ) ) { str = in . next ( ) ; } in . close ( ) ; System . out . println ( "Done" ) ; System . exit ( 0 ) ; }
te	1	public String toString ( ) { return this . mode == d ? this . writer . toString ( ) : null ; }
te	2	public Map < String , PlayerData > getPoliceData ( ) { Map < String , PlayerData > polices = new HashMap < String , PlayerData > ( ) ; for ( Map . Entry < String , PlayerData > entry : playerData . entrySet ( ) ) { if ( entry . getKey ( ) != thiefID ) { polices . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return polices ; }
te	3	public static int compare ( String s , String s1 ) { if ( ( s . length ( ) - s1 . length ( ) ) != 0 ) { return s . length ( ) - s1 . length ( ) ; } byte b [ ] = s . getBytes ( ) ; byte b1 [ ] = s1 . getBytes ( ) ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( ( b [ i ] - b1 [ i ] ) != 0 ) { return b [ i ] - b1 [ i ] ; } } return 0 ; }
te	4	protected MultiLabelOutput makePredictionInternal ( Instance instance ) throws Exception { double p_0 = 0.0 ; if ( dataTransformation . getNumberOfAllZeros ( ) > 0 ) { Instance transformedZeroInstance = dataTransformation . transformToZeroInstance ( instance ) ; p_0 = allZeros . distributionForInstance ( transformedZeroInstance ) [ transformedZeroInstance . classAttribute ( ) . indexOfValue ( "0" ) ] ; } Instance transformedInstance = dataTransformation . transformInstance ( instance ) ; double [ ] [ ] probabilities = new double [ dataTransformation . getMaxLabels ( ) ] [ numLabels ] ; double [ ] marginals = new double [ numLabels ] ; for ( int i = 0 ; i < numLabels ; i ++ ) { double [ ] distribution = ensemble [ i ] . distributionForInstance ( transformedInstance ) ; for ( int j = 0 ; j < distribution . length ; j ++ ) { int label = Integer . parseInt ( transformedInstance . attribute ( this . labelIndices [ i ] ) . value ( j ) ) ; if ( label != 0 ) { probabilities [ label - 1 ] [ i ] = ( 1 - p_0 ) * distribution [ j ] ; marginals [ i ] = ( 1 - p_0 ) * distribution [ j ] ; } } } FMeasure f = new FMeasure ( ) ; f . initialize ( numLabels , dataTransformation . getMaxLabels ( ) , probabilities , p_0 ) ; f . computeFMeasureMaximizer ( ) ; MultiLabelOutput prediction = f . computePrediction ( ) ; return prediction ; }
te	6	public Point GetLineIntersection ( Segment Line1 , Segment Line2 ) { Point result = new Point ( ) ; double x4_x3 = ( Line2 . end . x - Line2 . start . x ) ; double x2_x1 = ( Line1 . end . x - Line1 . start . x ) ; double y4_y3 = ( Line2 . end . y - Line2 . start . y ) ; double y2_y1 = ( Line1 . end . y - Line1 . start . y ) ; double x1_x3 = ( Line1 . start . x - Line2 . start . x ) ; double y1_y3 = ( Line1 . start . y - Line2 . start . y ) ; double dem = ( y4_y3 * x2_x1 ) - ( x4_x3 * y2_y1 ) ; double Ua = ( ( x4_x3 * y1_y3 ) - ( y4_y3 * x1_x3 ) ) / dem ; double Ub = ( ( x2_x1 * y1_y3 ) - ( y2_y1 * x1_x3 ) ) / dem ; if ( Ua < 0 || Ua > 1 || Ub < 0 || Ub > 1 ) { return null ; } result . x = Line1 . start . x + Ua * ( x2_x1 ) ; result . y = Line1 . start . y + Ua * ( y2_y1 ) ; if ( double . isNaN ( result . x ) || double . isNaN ( result . y ) ) { return null ; } return result ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmLiga . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmLiga . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmLiga . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmLiga . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new frmLiga ( ) . setVisible ( true ) ; } } ) ; }
te	3	private void diePhaseProcessing ( Habitat habitat ) throws Throwable { for ( IndividualsGroupState group : habitat . getGroupsStates ( ) . values ( ) ) { int dead = 0 ; for ( int i = 0 ; i < group . strength ; i ++ ) if ( Math . random ( ) > group . getSurvival ( ) ) dead ++ ; group . strength -= dead ; } notifySubscribers ( IterationSubStep . DIEING ) ; }
te	8	@ Override public boolean evaluate ( Robot robot ) { switch ( type ) { case = : return ( ( NumericalEvaluatable ) argOne ) . evaluate ( robot ) == ( ( NumericalEvaluatable ) argTwo ) . evaluate ( robot ) ; case > : return ( ( NumericalEvaluatable ) argOne ) . evaluate ( robot ) > ( ( NumericalEvaluatable ) argTwo ) . evaluate ( robot ) ; case < : return ( ( NumericalEvaluatable ) argOne ) . evaluate ( robot ) < ( ( NumericalEvaluatable ) argTwo ) . evaluate ( robot ) ; case AND : return ( ( BooleanEvaluatable ) argOne ) . evaluate ( robot ) && ( ( BooleanEvaluatable ) argTwo ) . evaluate ( robot ) ; case OR : return ( ( BooleanEvaluatable ) argOne ) . evaluate ( robot ) || ( ( BooleanEvaluatable ) argTwo ) . evaluate ( robot ) ; case NOT : return ! ( ( BooleanEvaluatable ) argOne ) . evaluate ( robot ) ; } throw new ParserFailureException ( "Could not determine condition type" ) ; }
te	7	@ Override public void input ( float delta ) { super . input ( delta ) ; if ( Input . getKeyDown ( Input . KEY_F3 ) || Input . getButtonDown ( 5 ) ) { if ( playing ) { monkey . pause ( ) ; } else { monkey . play ( ) ; } playing = ! playing ; } if ( Input . getKeyDown ( Input . KEY_F4 ) ) { if ( isWater ) { getRootNode ( ) . removeChild ( water ) ; } else { getRootNode ( ) . addChild ( water ) ; } isWater = ! isWater ; } if ( Input . getKeyDown ( Input . KEY_F5 ) ) { if ( isMoving ) { monkeyModel . removeComponent ( move ) ; } else { monkeyModel . addComponent ( move ) ; } isMoving = ! isMoving ; } }
te	5	public static boolean areTheSame ( final boolean [ ] [ ] maskA , final boolean [ ] [ ] maskB ) { int rowsA = maskRows ( maskA ) ; int rowsB = maskRows ( maskB ) ; if ( rowsA == rowsB ) { int colsA = maskCols ( maskA ) ; int colsB = maskCols ( maskB ) ; if ( colsA == colsB ) { for ( int i = 0 ; i < rowsA ; ++ i ) { for ( int j = 0 ; j < colsB ; ++ j ) { if ( maskA [ i ] [ j ] != maskB [ i ] [ j ] ) { return false ; } } } return true ; } } return false ; }
te	6	private void closeStreams ( ) { if ( dataInputStream != null ) { try { dataInputStream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( output != null ) { try { output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
te	8	public void decodeVideoPacket ( int pktLength , long pts ) throws MpegVideoDecodeException { Statistics . startLog ( DECODE_VIDEO_STRING ) ; m_lPTS = pts ; try { if ( ! m_bRunMode ) m_ioTool . nextStartCode ( ) ; do { if ( ! m_bRunMode ) { parseSequenceHeader ( ) ; Statistics . endLog ( DECODE_VIDEO_STRING ) ; return ; } if ( m_PelBuffer == null ) { setDim ( m_iMbWidth * 16 , m_iMbHeight * 16 , m_iWidth , m_iHeight ) ; m_PelBuffer = new int [ 3 ] [ 3 ] [ m_iMbWidth * 16 * m_iMbHeight * 16 ] ; m_iPixelPerLumLine = m_iMbWidth << 4 ; m_iPixelPerColLine = m_iMbWidth << 3 ; m_iLumYincr = m_iPixelPerLumLine - 8 ; m_iColYincr = m_iPixelPerColLine - 8 ; m_forward . init ( m_iPixelPerLumLine , m_iPixelPerColLine , m_iPixelPerLumLine - 16 , m_iColYincr ) ; m_backward . init ( m_iPixelPerLumLine , m_iPixelPerColLine , m_iPixelPerLumLine - 16 , m_iColYincr ) ; } while ( ( ! m_ioTool . isEOF ( ) ) && m_ioTool . nextBits ( GOP_START_CODE , 32 ) ) parseGroupOfPictures ( ) ; } while ( ( ! m_ioTool . isEOF ( ) ) && m_ioTool . nextBits ( SEQ_START_CODE , 32 ) ) ; } catch ( IOException e ) { throw new MpegVideoDecodeException ( e . getMessage ( ) ) ; } finally { m_frameMgr . close ( ) ; } Statistics . endLog ( DECODE_VIDEO_STRING ) ; }
te	5	public static float interpolateValue ( float x , List < float > xcoord , List < float > ycoord ) { if ( x < xcoord . get ( 0 ) || x > xcoord . get ( xcoord . size ( ) - 1 ) ) { return - 1 ; } int i = 0 ; while ( i < xcoord . size ( ) && x > xcoord . get ( i ) ) { i += 1 ; } if ( i == 0 ) { return ycoord . get ( 0 ) ; } return interpolateVal ( x , xcoord . get ( i - 1 ) , xcoord . get ( i ) , ycoord . get ( i - 1 ) , ycoord . get ( i ) ) ; }
te	2	public static void printAllRecentGames ( long id ) { try { JSONArray games = getAllRecentGames ( id ) . getJSONArray ( "games" ) ; String name = Summoner . getSummonerName ( id ) ; System . out . println ( "Recent Games for " + name + ":\n" ) ; for ( int i = 0 ; i < games . length ( ) ; i ++ ) { JSONObject game = games . getJSONObject ( i ) ; printGame ( game ) ; System . out . println ( "\n=========================================================\n" ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } }
te	8	public void method558 ( int i , int j ) { if ( i < 0 || i > versions . length || j < 0 || j > versions [ i ] . length ) return ; if ( versions [ i ] [ j ] == 0 ) return ; synchronized ( nodeSubList ) { for ( OnDemandData onDemandData = ( OnDemandData ) nodeSubList . reverseGetFirst ( ) ; onDemandData != null ; onDemandData = ( OnDemandData ) nodeSubList . reverseGetNext ( ) ) if ( onDemandData . dataType == i && onDemandData . ID == j ) return ; OnDemandData onDemandData_1 = new OnDemandData ( ) ; onDemandData_1 . dataType = i ; onDemandData_1 . ID = j ; onDemandData_1 . incomplete = true ; synchronized ( aClass19_1370 ) { aClass19_1370 . insertHead ( onDemandData_1 ) ; } nodeSubList . insertHead ( onDemandData_1 ) ; } }
te	1	public boolean setId ( long id ) { if ( stat . qidPath != 0 ) return false ; stat . qidPath = id ; return true ; }
te	3	public boolean disconnect ( Connection connection ) { boolean success = true ; for ( ServiceHandlerDefinition handler_def : handler_definitions_ ) { if ( handler_def . getRequestType ( ) == Request . RequestType . Publish ) { if ( ! connection . unsubscribe ( handler_def . getRequestPath ( ) ) ) { success = false ; } } } return success ; }
te	9	private Integer processData ( int index ) { if ( index == - 1 ) return floatingparts ; if ( p . size ( ) > 0 ) if ( ! indexed . contains ( index ) ) { indexed . add ( index ) ; for ( int s = 0 ; s < ( p . get ( index ) . size ( ) - 1 ) ; s ++ ) { Line2D l1 = new Line2D . double ( p . get ( index ) . get ( s ) [ 0 ] , p . get ( index ) . get ( s ) [ 1 ] , p . get ( index ) . get ( s + 1 ) [ 0 ] , p . get ( index ) . get ( s + 1 ) [ 1 ] ) ; for ( int z = 0 ; z < p . size ( ) ; z ++ ) { if ( z != index ) for ( int q = 0 ; q < ( p . get ( z ) . size ( ) - 1 ) ; q ++ ) { Line2D l2 = new Line2D . double ( p . get ( z ) . get ( q ) [ 0 ] , p . get ( z ) . get ( q ) [ 1 ] , p . get ( z ) . get ( q + 1 ) [ 0 ] , p . get ( z ) . get ( q + 1 ) [ 1 ] ) ; if ( l1 . intersectsLine ( l2 ) ) { if ( ! indexed . contains ( z ) ) { queue . add ( z ) ; } } } } } } if ( queue . size ( ) > 0 ) processData ( queue . remove ( queue . size ( ) - 1 ) ) ; else { floatingparts ++ ; processData ( nextToDo ( indexed , p . size ( ) ) ) ; } return floatingparts ; }
te	6	public boolean doesMatch ( char ch1 , char ch2 ) { if ( ch1 == ( && ch2 == ) ) return true ; else if ( ch1 == { && ch2 == } ) return true ; else if ( ch1 == [ && ch2 == ] ) return true ; else return false ; }
te	1	void setMinLength ( int minLength ) { if ( type != SimpleType . STRING ) { throw new IllegalArgumentException ( "minLength can only be used for type: String" ) ; } this . minLength = minLength ; }
te	1	public boolean equals ( Object o ) { if ( ! ( o instanceof RecordDescr ) ) return false ; RecordDescr d = ( RecordDescr ) o ; return this . recSymbolTable . equals ( d . fields ( ) ) ; }
