te	9	private void countGrams ( String training ) { StringTokenizer sparser = new StringTokenizer ( training ) ; String tokenized = " " ; while ( sparser . hasMoreTokens ( ) ) { tokenized = tokenized + sparser . nextToken ( ) . toLowerCase ( ) + " " ; } string = tokenized ; int count = 0 ; LinkedList < Character > temp2 = new LinkedList < Character > ( ) ; LinkedList < Character > temp3 = new LinkedList < Character > ( ) ; for ( char one : tokenized . toCharArray ( ) ) { temp2 . add ( one ) ; temp3 . add ( one ) ; } while ( true ) { count ++ ; if ( temp2 . size ( ) < 2 && temp3 . size ( ) < 3 ) { break ; } if ( count % 2 == 0 && temp2 . size ( ) >= 2 ) { bigramTotal ++ ; String two = "" + temp2 . get ( 0 ) + temp2 . get ( 1 ) ; if ( ! bigrams . containsKey ( two ) ) { bigrams . put ( two , 1 ) ; } else { int c = bigrams . get ( two ) ; bigrams . put ( two , ++ c ) ; } temp2 . removeFirst ( ) ; } if ( count % 3 == 0 && temp3 . size ( ) >= 3 ) { trigramTotal ++ ; String three = "" + temp3 . get ( 0 ) + temp3 . get ( 1 ) + temp3 . get ( 2 ) ; if ( ! trigrams . containsKey ( three ) ) { trigrams . put ( three , 1 ) ; } else { int c = trigrams . get ( three ) ; trigrams . put ( three , ++ c ) ; } temp3 . removeFirst ( ) ; } } System . out . println ( trigrams ) ; System . out . println ( bigrams ) ; }
te	1	@ Override public String visit ( PlusExpressionNode node ) { String temp = getNextTemporary ( ) ; try { dataManager . addNewTemporaryVariable ( temp ) ; } catch ( MemoryOutOfBoundsException e ) { e . printStackTrace ( ) ; } String left = node . acceptVisitorLeftHand ( this ) ; String right = node . acceptVisitorRightHand ( this ) ; Addition3AC addition = new Addition3AC ( lineNumber , dataManager ) ; addition . setParameters ( temp , left , right ) ; lineNumber += addition . getEmittedSize ( ) ; addition . emitCode ( ) ; return temp ; }
te	6	public float [ ] toRGB ( float [ ] data ) { float [ ] dest = new float [ 3 ] ; data [ 0 ] *= 255 ; data [ 1 ] *= 255 ; data [ 2 ] *= 255 ; dest [ 0 ] = ( float ) data [ 0 ] + ( float ) 1.402 * ( ( float ) data [ 2 ] - ( float ) 128 ) ; dest [ 1 ] = ( float ) data [ 0 ] - ( float ) 0.34414 * ( ( float ) data [ 1 ] - ( float ) 128 ) - ( float ) 0.71414 * ( ( float ) data [ 2 ] - ( float ) 128 ) ; dest [ 2 ] = ( float ) data [ 0 ] + ( float ) 1.772 * ( ( float ) data [ 1 ] - ( float ) 128 ) ; dest [ 0 ] /= 255 ; dest [ 1 ] /= 255 ; dest [ 2 ] /= 255 ; if ( dest [ 0 ] < ( float ) 0 ) dest [ 0 ] = 0 ; if ( dest [ 1 ] < ( float ) 0 ) dest [ 1 ] = 0 ; if ( dest [ 2 ] < ( float ) 0 ) dest [ 2 ] = 0 ; if ( dest [ 0 ] > ( float ) 1 ) dest [ 0 ] = 1 ; if ( dest [ 1 ] > ( float ) 1 ) dest [ 1 ] = 1 ; if ( dest [ 2 ] > ( float ) 1 ) dest [ 2 ] = 1 ; return ( dest ) ; }
te	1	public String [ ] splitStringAtIndex ( int i , String text ) { String [ ] newString = { "" } ; int index = 0 ; int j = 0 ; while ( index < text . length ( ) ) { newString [ j ] = text . substring ( index , Math . min ( index + i , text . length ( ) ) ) ; j += 1 ; } return newString ; }
te	4	public static boolean isPrime ( long n ) { if ( n == 2 ) { return true ; } if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
te	5	@ Override public boolean equals ( Object obj ) { if ( obj instanceof SimpleDTO ) { SimpleDTO that = ( SimpleDTO ) obj ; return = ( this . objectLong , that . objectLong ) && this . primitiveLong == that . primitiveLong && = ( this . string , that . string ) && this . primitiveBool == that . primitiveBool && = ( this . objectBool , that . objectBool ) ; } return false ; }
te	3	public char nextClean ( ) throws JSONException { for ( ; ; ) { char c = this . next ( ) ; if ( c == 0 || c >   ) { return c ; } } }
te	4	public Roomba ( Emulator emulator ) { this . emulator = emulator ; try { this . serial = new SerialIO ( RoombaConfig . IO_PORT ) ; if ( DEBUG ) System . out . println ( "Roomba startup" ) ; } catch ( NoSuchPortException e ) { System . out . println ( "Port not found" ) ; } catch ( PortInUseException e ) { System . out . println ( "Port in use" ) ; } catch ( IOException e ) { } waitFor ( 5000 ) ; start ( ) ; waitFor ( 1000 ) ; selectMode ( RoombaConfig . ROOMBA_MODE_SAFE ) ; waitFor ( 1000 ) ; }
te	7	private static void loadStreamCostTable ( final String filename , final byte [ ] costTable ) { InputStream is = PuzzleConfiguration . class . getResourceAsStream ( filename ) ; DataInputStream dis = null ; try { if ( is == null ) { is = new FileInputStream ( filename ) ; } dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; int i = 0 ; while ( true ) { costTable [ i ++ ] = dis . readByte ( ) ; } } catch ( final EOFException eofe ) { } catch ( final FileNotFoundException fnfe ) { System . err . println ( "Error: Cannot find file " + filename + "." ) ; System . exit ( 1 ) ; } catch ( final IOException ioe ) { System . err . println ( "Error: Cannot read from file " + filename + "." ) ; System . exit ( 1 ) ; } finally { try { if ( dis != null ) { dis . close ( ) ; } } catch ( final IOException ioe ) { } } }
te	7	public boolean equals ( SpamSumSignature other ) { if ( this . blockSize != other . blockSize ) return false ; if ( this . hash1 . length != other . hash1 . length ) return false ; if ( this . hash2 . length != other . hash2 . length ) return false ; for ( int idx = 0 ; idx < hash1 . length ; idx ++ ) { if ( this . hash1 [ idx ] != other . hash1 [ idx ] ) return false ; } for ( int idx = 0 ; idx < hash2 . length ; idx ++ ) { if ( this . hash2 [ idx ] != other . hash2 [ idx ] ) return false ; } return true ; }
te	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { NodeDouble < E > tmp = getIndex ( index ) ; tmp . getPrev ( ) . setNext ( tmp . getNext ( ) ) ; tmp . getNext ( ) . setPrev ( tmp . getPrev ( ) ) ; _lenght -- ; } }
te	5	public int getGhostTarget ( int whichGhost , int [ ] targets , boolean nearest ) { int target = - 1 ; double min = Integer . MAX_VALUE ; double max = - Integer . MAX_VALUE ; for ( int i = 0 ; i < targets . length ; i ++ ) { double dist = getGhostPathDistance ( whichGhost , targets [ i ] ) ; if ( nearest && dist < min ) { min = dist ; target = targets [ i ] ; } if ( ! nearest && dist > max ) { max = dist ; target = targets [ i ] ; } } return target ; }
te	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } CompraDao oCompraDAO = new CompraDao ( ) ; int pages = oCompraDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "CompraGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
te	2	public static String quote ( String data ) { if ( data == null ) { return "\"\"" ; } try { JSONStringer stringer = new JSONStringer ( ) ; stringer . open ( JSONStringer . Scope . null , "" ) ; stringer . value ( data ) ; stringer . close ( JSONStringer . Scope . null , JSONStringer . Scope . null , "" ) ; return stringer . toString ( ) ; } catch ( JSONException e ) { throw new AssertionError ( ) ; } }
te	4	protected boolean isBLOBAccepted ( String deviceName , String propertyName ) { DevicePropertyBLOBEnableTuple aux = getBLOBEnableRule ( deviceName , propertyName ) ; if ( aux != null ) { if ( aux . getBLOBEnable ( ) == BLOBEnables . NEVER ) { return false ; } else { return true ; } } aux = getBLOBEnableRule ( deviceName ) ; if ( aux == null ) { return false ; } if ( aux . getBLOBEnable ( ) == BLOBEnables . NEVER ) { return false ; } return true ; }
te	9	private int Quiesce ( int ply , int depth , int alpha , int beta , GameState gs ) throws AbortSearchException { assert ( gs . getStepsRemaining ( ) == 4 ) ; q_nodes_searched ++ ; goal_calls ++ ; if ( goal . test ( gs ) ) { goal_hits ++ ; return SCORE_MATE ; } int score = eval . Evaluate ( gs , false ) ; if ( depth <= 0 ) { return score ; } if ( show_alphabeta_search_trace ) { SearchTrace ( ply , "QStand pat score: " + score ) ; } if ( score > alpha ) { if ( score >= beta ) { return score ; } alpha = score ; } GameState new_gs = gs_stack [ ply ] ; MoveList moves = move_list_stack [ ply ] ; moves . clear ( ) ; captures . genCaptures ( gs , moves , true ) ; moves . sort ( ) ; ArimaaMove best_move = null ; for ( ArimaaMove move : moves ) { new_gs . play ( move , gs ) ; if ( show_alphabeta_search_trace ) { SearchTrace ( ply , - 1 , alpha , beta , move ) ; } if ( new_gs . isGameOver ( ) ) { score = new_gs . getGameResult ( ) ; } else { int new_ply = ply + move . steps ; score = - Quiesce ( new_ply , depth - 1 , - beta , - alpha , new_gs ) ; } if ( score > alpha ) { if ( score >= beta ) { return score ; } alpha = score ; } } return alpha ; }
te	2	@ Override public void setValueAt ( Object value , int row , int col ) { switch ( col ) { case 0 : dataVector . get ( row ) . setName ( value . toString ( ) ) ; break ; case 1 : dataVector . get ( row ) . setPrice ( double . parseDouble ( value . toString ( ) ) ) ; break ; default : break ; } fireTableCellUpdated ( row , col ) ; PPCDB . refreshMaterials ( PPC . calcObj . getMaterials ( ) ) ; }
te	4	public static void dotprintMatrix ( BigRational [ ] [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { for ( int j = 0 ; j < A [ 0 ] . length ; j ++ ) { if ( A [ i ] [ j ] . isUndefined ( ) ) { System . out . print ( "*" ) ; } if ( A [ i ] [ j ] . equals ( BigRational . ZERO ) ) { System . out . format ( "%2s " , "." ) ; } else { System . out . format ( "%2s " , A [ i ] [ j ] . toString ( ) ) ; } } System . out . println ( ) ; } System . out . println ( ) ; }
te	4	public static byte [ ] computeChainIv ( EncFSVolume volume , String volumePath ) { byte [ ] chainIv = new byte [ 8 ] ; StringTokenizer st = new StringTokenizer ( volumePath , EncFSVolume . PATH_SEPARATOR ) ; while ( st . hasMoreTokens ( ) ) { String curPath = st . nextToken ( ) ; if ( ( curPath . length ( ) > 0 ) && ( ! curPath . equals ( EncFSVolume . PATH_SEPARATOR ) ) ) { byte [ ] encodeBytes ; if ( volume . getConfig ( ) . getFilenameAlgorithm ( ) == EncFSFilenameEncryptionAlgorithm . BLOCK ) { encodeBytes = EncFSCrypto . getBytesForBlockAlgorithm ( curPath ) ; } else { encodeBytes = curPath . getBytes ( ) ; } EncFSCrypto . mac64 ( volume . getMAC ( ) , encodeBytes , chainIv ) ; } } return chainIv ; }
te	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj instanceof BigClass ) { return false ; } final BigClass other = ( BigClass ) obj ; if ( this . a != other . a ) { return false ; } if ( this . b != other . b ) { return false ; } if ( ! Objects . equals ( this . c , other . c ) ) { return false ; } return true ; }
te	3	static Object tryMethod ( Object o , String name , Object [ ] args ) { try { Method met = JREEngine . getMethod ( o . getClass ( ) , name , args ) ; if ( met == null ) return null ; return met . invoke ( o , args ) ; } catch ( InvocationTargetException ex ) { Throwable ex_t = ex . getTargetException ( ) ; ex_t . printStackTrace ( ) ; return null ; } catch ( IllegalAccessException ex ) { System . err . println ( "Unexpected exception:" ) ; ex . printStackTrace ( ) ; return null ; } }
te	0	public void setDirSpeed ( int xdir , int ydir , double xspeed , double yspeed ) { this . xdir = xdir ; this . ydir = ydir ; this . xspeed = xspeed ; this . yspeed = yspeed ; }
te	0	public void display ( ) { dllist . printDLList ( ) ; }
te	5	synchronized public boolean action ( Event event , Object arg ) { if ( event . target == okButton || event . target == server ) { ok = true ; endDialog ( ) ; } else if ( event . target == cancelButton ) { ok = false ; endDialog ( ) ; } else if ( event . target == optionsButton ) { options . showDialog ( ) ; } else if ( event . target == aboutButton ) { about . showDialog ( ) ; } return true ; }
te	9	public ArrayList < Interval > insert ( ArrayList < Interval > intervals , Interval newInterval ) { ArrayList < Interval > ret = new ArrayList < Interval > ( ) ; Interval cur , n = newInterval ; int start = n . start , end = n . end ; boolean firsttime = true ; if ( intervals . size ( ) == 0 ) { ret . add ( n ) ; return ret ; } for ( int i = 0 ; i < intervals . size ( ) ; i ++ ) { cur = intervals . get ( i ) ; if ( cur . end < start ) { ret . add ( cur ) ; } else { if ( cur . start <= n . start ) { if ( cur . end <= n . end ) { n . start = cur . start ; continue ; } if ( cur . end > n . end ) { return intervals ; } } else if ( cur . start > n . start && cur . start <= n . end ) { if ( cur . end < n . end ) { continue ; } if ( cur . end > n . end ) { n . end = cur . end ; continue ; } } else if ( cur . start > n . end ) { if ( firsttime ) { firsttime = false ; ret . add ( n ) ; } ret . add ( cur ) ; } } } if ( firsttime ) { firsttime = false ; ret . add ( n ) ; } return ret ; }
te	5	protected void load ( ) throws IOException { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( getDictionaryStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { final int length = line . length ( ) ; if ( length >= MIN_LENGTH && length <= MAX_LENGTH ) { words . add ( line ) ; } } System . err . printf ( "%s words loaded\n" , words . size ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
te	6	@ Override public boolean execute ( final CommandSender sender , final String [ ] split ) { if ( sender instanceof Player ) { if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) != null ) { if ( ! MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( ( Player ) sender , this ) ) { sender . sendMessage ( "[IRC] You don't have permission to preform that command." ) ; return true ; } } else { sender . sendMessage ( "[IRC] PEX not detected  unable to run any IRC commands." ) ; return true ; } } if ( split . length < 4 ) { sender . sendMessage ( "Invalid usage!" ) ; sender . sendMessage ( "Proper usage: irc pm [user] [message]" ) ; return true ; } else { if ( ! first . contains ( split [ 2 ] ) ) { MonsterIRC . getHandleManager ( ) . getIRCHandler ( ) . sendMessage ( split [ 2 ] , "You have revieved a private message from MonsterIRC!" ) ; MonsterIRC . getHandleManager ( ) . getIRCHandler ( ) . sendMessage ( split [ 2 ] , "To reply type \"" + sender . getName ( ) + ":\" (message)" ) ; first . add ( split [ 2 ] ) ; } final StringBuffer result = new StringBuffer ( ) ; result . append ( "[MC] " + sender . getName ( ) + ": " ) ; for ( int i = 3 ; i < split . length ; i ++ ) { result . append ( split [ i ] ) ; result . append ( " " ) ; } MonsterIRC . getHandleManager ( ) . getIRCHandler ( ) . sendMessage ( split [ 2 ] , result . toString ( ) ) ; sender . sendMessage ( ColorUtils . LIGHT_GRAY . getMinecraftColor ( ) + "([IRC] to " + split [ 2 ] + "): " + result . toString ( ) . substring ( 7 + sender . getName ( ) . length ( ) ) ) ; Variables . reply . put ( ( Player ) sender , split [ 2 ] ) ; return true ; } }
te	4	protected void checkCompat ( PipeDef [ ] runtimeIns , PipeDef [ ] runtimeOuts , CachedCall c ) { for ( int i = 0 ; i < inSize ( ) ; i ++ ) { Pipe reqType = getIn ( i ) . getInternalPipe ( ) ; if ( reqType . isImplicit ( ) ) reqType = getIn ( i ) . getImplicitReference ( c ) . getRuntimePipe ( c ) ; else continue ; Pipe . checkCompat ( runtimeIns [ i ] . getRuntimePipe ( c ) , reqType , c . getLine ( ) ) ; } for ( int i = 0 ; i < outSize ( ) ; i ++ ) { Pipe reqType = getOut ( i ) . getInternalPipe ( ) ; if ( reqType . isImplicit ( ) ) reqType = getOut ( i ) . getImplicitReference ( c ) . getRuntimePipe ( c ) ; else continue ; Pipe . checkCompat ( reqType , runtimeOuts [ i ] . getRuntimePipe ( c ) , c . getLine ( ) ) ; } }
te	8	public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { int m = obstacleGrid . length ; int n = obstacleGrid [ 0 ] . length ; int [ ] [ ] dp = new int [ m ] [ n ] ; dp [ 0 ] [ 0 ] = obstacleGrid [ 0 ] [ 0 ] == 1 ? 0 : 1 ; for ( int i = 1 ; i < m ; i ++ ) { dp [ i ] [ 0 ] = obstacleGrid [ i ] [ 0 ] == 1 ? 0 : dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = obstacleGrid [ 0 ] [ i ] == 1 ? 0 : dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ i ] [ j ] = obstacleGrid [ i ] [ j ] == 1 ? 0 : dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m - 1 ] [ n - 1 ] ; }
te	3	public LowSideDriver ( boolean driver0 , boolean driver1 , boolean driver2 ) { byte comm = 00 ; if ( driver0 ) { comm = ( byte ) ( comm | 01 ) ; } if ( driver1 ) { comm = ( byte ) ( comm | 02 ) ; } if ( driver2 ) { comm = ( byte ) ( comm | 04 ) ; } setCommand ( new byte [ ] { ( byte ) OpCode . LOW_SIDE_DRIVER . op ( ) , comm } ) ; }
te	5	@ Override public void drawText ( int x , int y , Text text ) { MapFont font = text . getFont ( ) ; String stripped = text . getStrippedText ( ) ; if ( ! font . isValid ( stripped ) ) { Debug . log ( DebugType . IMMEDIATE , "Attempted to draw invalid text: '%s'." , stripped ) ; return ; } int xOffset = x ; int spacing = text . getSpacing ( ) ; int height = font . getHeight ( text ) ; for ( int c = 0 ; c < stripped . length ( ) ; c ++ ) { char character = stripped . charAt ( c ) ; MapColor color = text . colorAt ( c ) ; FontCharacter fontChar = font . getFontCharacter ( character ) ; int fontWidth = fontChar . getWidth ( ) ; int fontHeight = fontChar . getHeight ( ) ; int yOffset = height - fontHeight ; for ( int i = 0 ; i < fontWidth ; i ++ ) { for ( int j = 0 ; j < fontHeight ; j ++ ) { if ( fontChar . hasPixel ( i , j ) ) { setPixel ( xOffset + i , y + j + yOffset , color ) ; } } } xOffset += fontWidth + spacing ; } }
te	3	public int saveUserWeight ( UserWeight uw ) throws SQLException , SQLQueryException { PreparedStatement pst = null ; ResultSet generatedKeys = null ; if ( uw . getId ( ) == 0 ) { pst = dbCon . prepareStatement ( "INSERT INTO weight ('uid'  'date'  'weight') values (?  ?  ?) ;" ) ; pst . setInt ( 1 , uw . getUserId ( ) ) ; pst . setLong ( 2 , uw . getDate ( ) . getTimeInMillis ( ) ) ; pst . setDouble ( 3 , uw . getWeight ( ) ) ; int affectedRows = pst . executeUpdate ( ) ; if ( affectedRows == 0 ) { throw new SQLQueryException ( "Creating Weight failed  no rows affected." ) ; } generatedKeys = pst . getGeneratedKeys ( ) ; if ( generatedKeys . next ( ) ) { uw . setId ( ( int ) generatedKeys . getLong ( 1 ) ) ; System . out . print ( "new Weight rwoId " + uw . getId ( ) ) ; generatedKeys . close ( ) ; pst . close ( ) ; } else { throw new SQLException ( "Creating Weight failed  no generated key obtained." ) ; } } else { pst = dbCon . prepareStatement ( "UPDATE weight SET 'uid' = ?  'date' = ?   'weight' = ? WHERE rowid = ? ;" ) ; pst . setInt ( 1 , uw . getUserId ( ) ) ; pst . setLong ( 2 , uw . getDate ( ) . getTimeInMillis ( ) ) ; pst . setDouble ( 3 , uw . getWeight ( ) ) ; pst . setInt ( 4 , uw . getId ( ) ) ; pst . execute ( ) ; pst . close ( ) ; } return uw . getId ( ) ; }
te	9	public static void sendMenu ( final Player sender ) { sender . sendMessage ( ColorUtils . DARK_BLUE . getMinecraftColor ( ) + "----- [" + ColorUtils . WHITE . getMinecraftColor ( ) + "MonsterIRC Help" + ColorUtils . DARK_BLUE . getMinecraftColor ( ) + "]-----" ) ; if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Connect ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc connect " ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Disconnect ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc disconnect" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new ReloadConfig ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc reload" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Join ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc join" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (channel)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Leave ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc leave" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (channel)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Ban ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc ban" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (user)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Mute ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc mute" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (user)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Unmute ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc unmute" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (user)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Nick ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc nick" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (nick)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new Say ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc say" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (message)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new PrivateMessage ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc pm" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (user) (message)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new PrivateMessage ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc r" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (message)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new PrivateMessage ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc raw" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (message)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new PrivateMessage ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc names" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (channel)" ) ; } if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( sender , new PrivateMessage ( ) ) ) { sender . sendMessage ( ColorUtils . GREEN . getMinecraftColor ( ) + "/irc whois" + ColorUtils . DARK_GRAY . getMinecraftColor ( ) + " (name)" ) ; } sender . sendMessage ( ColorUtils . YELLOW . getMinecraftColor ( ) + "For more info on a certian command type" + ColorUtils . WHITE . getMinecraftColor ( ) + "/irc help (command)" ) ; }
te	9	public void tick ( ) { walkblock ( ) ; if ( timeoutuntildamage > 0 ) { timeoutuntildamage -= 1 ; } if ( ! getWalkBlock ( ) ) { int [ ] direction = Distance . getDirection ( x , y , Realm . player . x , Realm . player . y ) ; if ( ! ( Collision . check ( new Position ( x , y ) , direction [ 0 ] ) ) ) { switch ( direction [ 0 ] ) { case 0 : aiUp ( ) ; case 1 : aiRight ( ) ; case 2 : aiDown ( ) ; case 3 : aiLeft ( ) ; } } else if ( ! ( Collision . check ( new Position ( x , y ) , direction [ 1 ] ) ) ) { switch ( direction [ 1 ] ) { case 0 : aiUp ( ) ; case 1 : aiRight ( ) ; case 2 : aiDown ( ) ; case 3 : aiLeft ( ) ; } } else { setWalkBlock ( 120 ) ; } } }
te	4	public static void removeIntToAllEntities ( String name , GrandView reference ) { ArrayList < GameEntity > entities = reference . getLevel ( ) . getEntities ( ) ; ArrayList < SavedEntityState > saved = reference . getConfigs ( ) ; for ( int i = 0 ; i < saved . size ( ) ; i ++ ) saved . get ( i ) . getInts ( ) . remove ( name ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { EntityState state = entities . get ( i ) . getState ( ) ; for ( int f = 0 ; f < state . getInts ( ) . size ( ) ; f ++ ) if ( state . getInts ( ) . get ( f ) . getKey ( ) . equals ( name ) ) state . getInts ( ) . remove ( f -- ) ; } }
te	7	public Scenery ( ) { for ( int x = 0 ; x < Realm . WORLD_WIDTH ; x ++ ) { for ( int y = 0 ; y < Realm . WORLD_HEIGHT ; y ++ ) { if ( Realm . world . getTile ( x , y ) == Tile . GRASS ) { int seed = iRandom . nextInt ( 30 ) ; if ( seed < 3 ) { if ( seed == 0 ) scenobjects [ x ] [ y ] = GameObject . RED_FLOWER ; else if ( seed == 1 ) scenobjects [ x ] [ y ] = GameObject . YELLOW_FLOWER ; else if ( seed == 2 ) scenobjects [ x ] [ y ] = GameObject . GRASS_NOISE ; } } } } scenobjects [ 7 ] [ 1 ] = GameObject . BRICK_WALL_0 ; scenobjects [ 7 ] [ 5 ] = GameObject . BRICK_WALL_2 ; scenobjects [ 8 ] [ 1 ] = GameObject . BRICK_WALL_0 ; scenobjects [ 9 ] [ 1 ] = GameObject . BRICK_WALL_0 ; scenobjects [ 9 ] [ 5 ] = GameObject . BRICK_WALL_2 ; scenobjects [ 10 ] [ 1 ] = GameObject . BRICK_WALL ; scenobjects [ 10 ] [ 2 ] = GameObject . BRICK_WALL_1 ; scenobjects [ 10 ] [ 3 ] = GameObject . BRICK_WALL_1 ; scenobjects [ 10 ] [ 4 ] = GameObject . BRICK_WALL_1 ; scenobjects [ 10 ] [ 5 ] = GameObject . BRICK_WALL ; scenobjects [ 6 ] [ 1 ] = GameObject . BRICK_WALL ; scenobjects [ 6 ] [ 2 ] = GameObject . BRICK_WALL_3 ; scenobjects [ 6 ] [ 3 ] = GameObject . BRICK_WALL_3 ; scenobjects [ 6 ] [ 4 ] = GameObject . BRICK_WALL_3 ; scenobjects [ 6 ] [ 5 ] = GameObject . BRICK_WALL ; }
te	6	public void setAllCode ( List < String > pos , String stackCount ) { try { Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; Element things = rootNode . getChild ( "things" ) ; Iterator < Element > c = things . getDescendants ( new ElementFilter ( "pos" ) ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( pos . contains ( e . getText ( ) ) ) { Element eP = e . getParentElement ( ) ; if ( eP . hasAttributes ( ) ) { if ( eP . getAttributeValue ( "Class" ) . equalsIgnoreCase ( "ThingResource" ) ) { eP . getChild ( "stackCount" ) . setText ( stackCount ) ; continue ; } } } } Notification . createInfoNotification ( "Updated all resources stack size to " + stackCount , 3000 ) ; XMLOutputter xmlOutput = new XMLOutputter ( ) ; FileOutputStream fos = new FileOutputStream ( xmlFile ) ; xmlOutput . setFormat ( Format . getRawFormat ( ) ) ; xmlOutput . output ( doc , fos ) ; fos . close ( ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
te	3	public void stacking ( Object ... variables ) { if ( stack == null ) { stack = new StackNode ( ) ; } currentStackLevel ++ ; Node node = null ; for ( Object variableName : variables ) { node = findNode ( variableName . toString ( ) ) ; if ( node != null ) { node . setStackLevel ( currentStackLevel ) ; stack . push ( node ) ; kill ( node ) ; } } }
te	4	public static String readResult ( ) { String result = "" ; String line ; try { BufferedReader reader = null ; try { File file = new File ( "pbest" ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; line = reader . readLine ( ) ; while ( line != null ) { result += line + "\n" ; line = reader . readLine ( ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } } catch ( IOException e ) { } catch ( NumberFormatException e ) { } return result ; }
te	2	protected void sendReport ( Packet packet ) throws WrongPacketSizeException , IOException , InterruptedException { logger . debug ( "Sending report thorugh unicast left " + packet ) ; InetAddress currentLeftChannelIP = InetAddress . getByName ( this . leftChannels [ 0 ] . getIpAddress ( ) ) ; sendPacket ( leftSocket , packet , currentLeftChannelIP , this . leftChannels [ 0 ] . getPortNumber ( ) ) ; if ( packet . getGroup ( ) . equals ( PacketGroup . SENSOR_DATA ) ) { LoggingUtility . logMessage ( this . getNodeId ( ) , this . leftChannels [ 0 ] . getId ( ) , MessageType . SND , packet . getType ( ) , packet . getSrcNodeId ( ) + ":" + packet . getValue ( ) ) ; } else if ( packet . getGroup ( ) . equals ( PacketGroup . QUERY ) ) { LoggingUtility . logMessage ( this . getNodeId ( ) , this . leftChannels [ 0 ] . getId ( ) , MessageType . SND , packet . getType ( ) , packet . getValue ( ) ) ; } else { logger . warn ( "Wrong type of packet to be sent" ) ; } }
te	4	protected boolean isOutOfBounds ( int row , int column ) { if ( ( row < 0 ) || ( rowSize <= row ) || ( column < 0 ) || ( columnSize <= column ) ) { return true ; } return false ; }
te	4	public void AddFileToShare ( String path , String dspName , String meta , int ttl ) throws IOException , IllegalArgumentException { File file = new File ( path ) ; if ( ! file . exists ( ) ) throw new IllegalArgumentException ( "path does not exist!" ) ; if ( ! file . isFile ( ) ) throw new IllegalArgumentException ( "path is not a file!" ) ; if ( ttl < 0 && ttl != Share . TTL_INFINITY ) throw new IllegalArgumentException ( "TTL is invalid" ) ; new AddFileToShareAsync ( path , dspName , meta , file , ttl ) . start ( ) ; }
te	9	@ Action public void addPuzles ( ) { ConstraintPuzzleCollectionPanel selectedPanel = SudokuApplication . getApplication ( ) . getApplicationView ( ) . getSelectedCollectionPanel ( ) ; if ( selectedPanel == null ) { return ; } ConstraintPuzzleCollection selectedCollection = selectedPanel . getCollection ( ) ; if ( selectedCollection != null ) { int numberOfPuzzlesToAdd ; try { numberOfPuzzlesToAdd = Integer . parseInt ( numberOfPuzzlesTextField . getText ( ) ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Number Of Puzzles must be numeric." , "Non-Numeric Data" , JOptionPane . ERROR_MESSAGE ) ; numberOfPuzzlesTextField . selectAll ( ) ; numberOfPuzzlesTextField . requestFocus ( ) ; return ; } int maximumNumberOfFailuresInARow = 25 ; int numberOfPuzzlesGenerated = 0 ; int numberOfSuccessiveFailures = 0 ; while ( numberOfPuzzlesGenerated < numberOfPuzzlesToAdd ) { if ( numberOfSuccessiveFailures == maximumNumberOfFailuresInARow ) { JOptionPane . showMessageDialog ( this , "Unable to generate puzzles." , "We've Failed Too Much  Man!" , JOptionPane . ERROR_MESSAGE ) ; return ; } else { ConstraintPuzzle newPuzzleSolution = null ; try { newPuzzleSolution = ( ConstraintPuzzle ) selectedCollection . getPuzzleClass ( ) . newInstance ( ) ; } catch ( Exception e ) { } newPuzzleSolution . setSize ( 9 ) ; newPuzzleSolution . setRuleset ( selectedCollection . getRuleset ( ) ) ; newPuzzleSolution . solveWithBacktracking ( true ) ; ConstraintPuzzle newPuzzle ; if ( difficultyComboBox . getSelectedItem ( ) . toString ( ) . equals ( "Easy" ) ) { newPuzzle = newPuzzleSolution . getNewStartState ( Difficulty . EASY ) ; } else if ( difficultyComboBox . getSelectedItem ( ) . toString ( ) . equals ( "Medium" ) ) { newPuzzle = newPuzzleSolution . getNewStartState ( Difficulty . MEDIUM ) ; } else { newPuzzle = newPuzzleSolution . getNewStartState ( Difficulty . HARD ) ; } if ( newPuzzle == null ) { numberOfSuccessiveFailures ++ ; System . out . println ( "Failed." ) ; } else { numberOfPuzzlesGenerated ++ ; selectedCollection . addPuzzle ( newPuzzle ) ; numberOfSuccessiveFailures = 0 ; } } } selectedPanel . syncPanels ( ) ; selectedPanel . repaint ( ) ; SudokuApplication . getApplication ( ) . getApplicationView ( ) . saveSelectedPuzzleCollection ( ) ; close ( ) ; } else { System . out . println ( "GUI Error: AddPuzzlesDialog" ) ; } }
te	2	public float length ( ) { final float length2 = . ( ) ; if ( length2 != 0 && Math . abs ( length2 - 1 ) > Tolerance . null ) { return ( float ) Math . sqrt ( length2 ) ; } return length2 ; }
te	2	private void initCommunication ( ) { webEngine . getLoadWorker ( ) . stateProperty ( ) . addListener ( new ChangeListener < Worker . State > ( ) { @ Override public void changed ( final ObservableValue < ? extends Worker . State > observableValue , final Worker . State oldState , final Worker . State newState ) { if ( newState == Worker . State . SUCCEEDED ) { doc = ( JSObject ) webEngine . executeScript ( "window" ) ; doc . setMember ( "app" , Controller . this ) ; ready = true ; fadeIn ( lockMapButton ) ; } } } ) ; webEngine . setCreatePopupHandler ( new Callback < PopupFeatures , WebEngine > ( ) { @ Override public WebEngine call ( PopupFeatures config ) { smallView . setFontScale ( 0.8 ) ; webViewGroup . getChildren ( ) . add ( smallView ) ; return smallView . getEngine ( ) ; } } ) ; webEngine . setConfirmHandler ( new Callback < String , boolean > ( ) { @ Override public boolean call ( String s ) { return true ; } } ) ; webEngine . setOnAlert ( new EventHandler < WebEvent < String >> ( ) { @ Override public void handle ( WebEvent < String > stringWebEvent ) { } } ) ; }
te	9	public String getCombination ( ) { if ( result != null ) { return result ; } String tmprank ; if ( isRoyalFlush ( ) ) { result = "9" ; return result ; } tmprank = getStraightFlush ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "8" + tmprank ; return result ; } tmprank = getQuad ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "7" + tmprank ; return result ; } tmprank = getFullHouse ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "6" + tmprank ; return result ; } tmprank = getFlush ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "5" + tmprank ; return result ; } tmprank = getStraight ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "4" + tmprank ; return result ; } tmprank = getThreeOfAKind ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "3" + tmprank ; return result ; } tmprank = getTwoPair ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "2" + tmprank ; return result ; } tmprank = getOnePair ( ) ; if ( ! tmprank . equals ( "0" ) ) { result = "1" + tmprank ; return result ; } result = "0" + getHighCard ( ) ; return result ; }
te	4	private void removeNodeWithOneChild ( Node u ) { Node n = ( u . right == null ) ? u . left : u . right ; if ( n . isRed ) n . isRed = false ; if ( u == root ) { root = n ; u . left = null ; u . right = null ; } else { if ( u . parent . left == u ) u . parent . left = n ; else u . parent . right = n ; n . parent = u . parent ; } u . parent = null ; }
te	4	public < T extends Comparable < T >> JTreeNode < T > findParentNode ( JTreeNode < T > node , JTreeNode < T > parentNode , T value ) { JTreeNode < T > tempNode = null ; if ( node == null ) return null ; if ( node . isEqual ( value ) ) { tempNode = parentNode ; } else { if ( tempNode == null ) tempNode = findParentNode ( node . getLeftNode ( ) , node , value ) ; if ( tempNode == null ) tempNode = findParentNode ( node . getRightNode ( ) , node , value ) ; } return tempNode ; }
te	3	public static JSONObject getChampByName ( JSONArray champs , String name ) { try { for ( int i = 0 ; i < champs . length ( ) ; i ++ ) { JSONObject jo = champs . getJSONObject ( i ) ; if ( jo . getString ( "name" ) . equalsIgnoreCase ( name ) ) { return jo ; } } } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; }
te	9	@ Override public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { SearchCustomerName form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; if ( ! form . isPresent ( ) ) { return "e_searchtoviewtrans.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { return "e_customermanage.jsp" ; } Transaction . begin ( ) ; int customer_id = customerDAO . getCustomerId ( form . getUsername ( ) ) ; CustomerBean cb = customerDAO . read ( customer_id ) ; if ( customer_id == - 1 ) { errors . add ( "Invalid User Name" ) ; Transaction . commit ( ) ; return "e_searchtoviewtrans.jsp" ; } TransactionBean [ ] tbarray = transactionDAO . getTransactionByCustomerId ( customer_id ) ; ArrayList < TempTransaction > al = new ArrayList < TempTransaction > ( ) ; TransactionBean tb = new TransactionBean ( ) ; if ( tbarray != null ) { for ( int i = 0 ; i < tbarray . length ; i ++ ) { TempTransaction tt = new TempTransaction ( ) ; int fundid = transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getFund_id ( ) ; tt . setAmount ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getAmount ( ) ) ; tt . setShares ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getShares ( ) ) ; tt . setCustomer_id ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getCustomer_id ( ) ) ; if ( ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getExecute_date ( ) == null ) ) { tt . setExecute_date ( "Pending" ) ; } else { tt . setExecute_date ( ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getExecute_date ( ) ) ) ; } tt . setFund_id ( ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getFund_id ( ) ) ) ; tt . setTransaction_id ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getTransaction_id ( ) ) ; tt . setTransaction_type ( ( transactionDAO . getTransactionByCustomerId ( customer_id ) [ i ] . getTransaction_type ( ) ) ) ; if ( tt . getFund_id ( ) == 0 ) { tt . setName ( "-" ) ; tt . setSymbol ( "-" ) ; } else { tt . setName ( fundDAO . getFundByFundId ( fundid ) . getName ( ) ) ; tt . setSymbol ( fundDAO . getFundByFundId ( fundid ) . getSymbol ( ) ) ; } al . add ( tt ) ; } } request . setAttribute ( "temptransactions" , al ) ; request . setAttribute ( "searcheduser" , cb ) ; Transaction . commit ( ) ; return "e_viewTransactionHistory.jsp" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_viewTransactionHistory.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "e_viewTransactionHistory.jsp" ; } catch ( NumberFormatException e ) { System . out . print ( "catched" ) ; errors . add ( "Input Amount is too large" ) ; return "e_viewTransactionHistory.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_viewTransactionHistory.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
te	1	public List < String > useString ( String attribute ) { List < String > parts = ElementParser . parseDelimitedString ( attribute ,   , false ) ; List < String > result = new ArrayList < String > ( parts . size ( ) ) ; StringValueCreator valueCreator = new StringValueCreator ( ) ; for ( String part : parts ) { result . add ( valueCreator . createValue ( part ) ) ; } return result ; }
te	9	public void mutate ( ) { double sum = 0 ; for ( HiffIndividual i : population . getPopulation ( ) ) { sum += i . fitness ( ) ; } double r = rng . nextDouble ( ) * sum ; double left = 0 ; double right ; for ( HiffIndividual individual : population . getPopulation ( ) ) { double f = individual . fitness ( ) ; right = left + f ; if ( r < right && r > left ) { int possition = Math . abs ( rng . nextInt ( ) ) % individual . getSize ( ) ; HiffIndividual mutant = new HiffIndividual ( individual ) ; for ( int i = 0 ; i < mutant . getSize ( ) ; ++ i ) { mutant . set ( i , i % 2 ) ; } possition = 0 ; double min = population . getIndividual ( 0 ) . fitness ( ) ; double fitnessStore ; for ( int i = 1 ; i < population . getSize ( ) ; ++ i ) { fitnessStore = population . getIndividual ( i ) . fitness ( ) ; if ( fitnessStore < min ) { min = fitnessStore ; possition = i ; } } double parentSum = 0 ; for ( int i = 0 ; i < population . getSize ( ) ; ++ i ) { parentSum += population . getIndividual ( i ) . fitness ( ) ; } double childrenSum = parentSum ; childrenSum = childrenSum - min + mutant . fitness ( ) ; if ( mutant . fitness ( ) > min ) { population . setIndividual ( possition , mutant ) ; } if ( childrenSum > parentSum ) { reward = 1 ; } else if ( childrenSum == parentSum ) { reward = 0.5 ; } else { reward = 0 ; } break ; } else { left = right ; } } }
te	6	public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( "Unclosed CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ] && sb . charAt ( i + 1 ) == ] && sb . charAt ( i + 2 ) == > ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
te	7	@ Override public void run ( ) { while ( ! shell . isDisposed ( ) && Uiswt . getInstance ( ) . isBusiness ) { try { Thread . sleep ( 1000 ) ; Random random = new Random ( ) ; int t1 = Math . abs ( random . nextInt ( ) % 20 ) ; if ( t1 < 5 && t1 > 0 ) { if ( Menu . getInstance ( ) . getAvailableDishs ( ) . size ( ) > 0 ) { Customer customer = new Customer ( t1 ) ; new Thread ( customer ) . start ( ) ; flag = true ; } else if ( flag ) { flag = false ; Uiswt . getInstance ( ) . openMessageBox ( "\u73B0\u5728\u6CA1\u6709\u83DC\u4E86" ) ; } else { MessageQueue . getInstance ( ) . addMessage ( "\u6CA1\u6709\u83DC\u4E86\uFF0C\u5BA2\u4EBA\u4E0D\u4F1A\u6765\u4E86" ) ; System . out . println ( "\u6CA1\u6709\u83DC\u4E86\uFF0C\u5BA2\u4EBA\u4E0D\u4F1A\u6765\u4E86" ) ; } } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
te	7	public int minDistance ( String word1 , String word2 ) { int len1 = word1 . length ( ) ; int len2 = word2 . length ( ) ; if ( len1 == 0 ) { return len2 ; } if ( len2 == 0 ) { return len1 ; } int [ ] [ ] distance = new int [ len1 + 1 ] [ len2 + 1 ] ; distance [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= len1 ; i ++ ) { distance [ i ] [ 0 ] = i ; } for ( int j = 1 ; j <= len2 ; j ++ ) { distance [ 0 ] [ j ] = j ; } for ( int i = 1 ; i <= len1 ; i ++ ) { for ( int j = 1 ; j <= len2 ; j ++ ) { if ( word1 . charAt ( i - 1 ) == word2 . charAt ( j - 1 ) ) { distance [ i ] [ j ] = distance [ i - 1 ] [ j - 1 ] ; } else { distance [ i ] [ j ] = Math . min ( distance [ i - 1 ] [ j - 1 ] , Math . min ( distance [ i ] [ j - 1 ] , distance [ i - 1 ] [ j ] ) ) + 1 ; } } } return distance [ len1 ] [ len2 ] ; }
te	2	public int getWidth ( Text text ) { String string = text . getStrippedText ( ) ; int width = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { width += characters . get ( string . charAt ( i ) ) . width ; if ( i != string . length ( ) - 1 ) { width += text . getSpacing ( ) ; } } return width ; }
te	5	void minHeapify ( int a [ ] , int i ) { int l = 2 * i ; int r = 2 * i + 1 ; int smallest = i ; if ( l < a . length && a [ l ] < a [ smallest ] ) smallest = l ; if ( r < a . length && a [ r ] < a [ smallest ] ) smallest = r ; if ( smallest != i ) { int tmp = a [ i ] ; a [ i ] = a [ smallest ] ; a [ smallest ] = tmp ; minHeapify ( a , smallest ) ; } }
te	3	public void run ( ) { while ( running ) { try { Socket con = socket . accept ( ) ; DataInputStream in = new DataInputStream ( new BufferedInputStream ( con . getInputStream ( ) ) ) ; SLPMessage msg = SLPMessage . parse ( con . getInetAddress ( ) , con . getPort ( ) , in , true ) ; ReplyMessage reply = handleMessage ( msg ) ; if ( reply != null ) { SLPCore . platform . logTraceMessage ( "SEND REPLY (" + reply . address + ":" + reply . port + ") " + reply ) ; DataOutputStream out = new DataOutputStream ( con . getOutputStream ( ) ) ; reply . writeTo ( out ) ; out . close ( ) ; } in . close ( ) ; con . close ( ) ; } catch ( Exception ioe ) { SLPCore . platform . logError ( "Exception in TCP receiver thread" , ioe ) ; } } }
te	8	public void Analyze ( double [ ] data ) { int length = data . length ; n_max = 0 ; double [ ] cumSum = getCumulative_Sum ( data ) ; x_density [ 0 ] = 0 ; delta = 0 ; for ( int i = 1 ; i < n_density ; i ++ ) { double yy = ( double ) i * 1. / ( ( double ) n_density ) ; int ind = find_Index ( cumSum , yy ) ; x_density [ i ] = find_interpol_x ( cumSum , ind , yy ) ; delta = delta + x_density [ i ] - x_density [ i - 1 ] ; } delta = delta / ( double ) n_density ; clust_list = new ArrayList < ArrayList < double >> ( ) ; ArrayList < double > cur_clust = new ArrayList < > ( ) ; boolean keep_cluster = true ; for ( int i = 1 ; i < n_density ; i ++ ) { if ( keep_cluster == false ) { cur_clust . clear ( ) ; } if ( ( x_density [ i ] - x_density [ i - 1 ] ) < 0.2 * delta ) { cur_clust . add ( ( double ) x_density [ i ] ) ; keep_cluster = true ; } else { keep_cluster = false ; if ( cur_clust . size ( ) > 0 ) { ArrayList < double > tmp = new ArrayList < double > ( cur_clust ) ; System . out . println ( "adding to cluster cur_clust_size() = " + cur_clust . size ( ) ) ; clust_list . add ( ( ArrayList < double > ) tmp ) ; } } } System . out . println ( "clust_lsut.size = " + clust_list . size ( ) + "\n" ) ; if ( clust_list . size ( ) > 0 ) { for ( int i = 0 ; i < clust_list . size ( ) ; i ++ ) { ArrayList < double > new_clust = clust_list . get ( i ) ; System . out . println ( "clust size = " + new_clust . size ( ) ) ; double summ = 0 ; for ( int j = 0 ; j < new_clust . size ( ) ; j ++ ) { summ = summ + new_clust . get ( j ) ; } summ = summ / ( ( double ) new_clust . size ( ) ) ; System . out . println ( "Center of " + i + "-th peak is " + summ ) ; } } }
te	9	private boolean postMortem ( int integer ) { int [ ] bits = new int [ this . domain ] ; Symbol symbol = this . symbols [ integer ] ; if ( symbol . integer != integer ) { return false ; } int i = 0 ; while ( true ) { Symbol back = symbol . back ; if ( back == null ) { break ; } if ( back . zero == symbol ) { bits [ i ] = 0 ; } else if ( back . one == symbol ) { bits [ i ] = 1 ; } else { return false ; } i += 1 ; symbol = back ; } if ( symbol != this . table ) { return false ; } this . width = 0 ; symbol = this . table ; while ( symbol . integer == none ) { i -= 1 ; symbol = bits [ i ] != 0 ? symbol . one : symbol . zero ; } return symbol . integer == integer && i == 0 ; }
te	6	public static void main ( String [ ] args ) throws IOException { File file = new File ( "E:\\referance\\htmlparse.html" ) ; InputStreamReader isr = new InputStreamReader ( new FileInputStream ( file ) , Charset . forName ( "utf-8" ) ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuilder sb = new StringBuilder ( ) ; String temp = null ; while ( ( temp = br . readLine ( ) ) != null ) { sb . append ( temp ) ; } System . out . println ( sb ) ; String beginRegex = "<div class=\"MIB_feed_c\">\\W*?<p class=\"sms\"" ; String endRegex = "<div id=\"_comment_list_miniblog.*?\"></div>\\W*?</div>" ; AnsjPaser ansjHtml = new AnsjPaser ( beginRegex , endRegex , sb . toString ( ) , AnsjPaser . TEXTTEGEX ) ; beginRegex = "<p class=\"sms\" mid=\"\\d*?\" type=\"\\d*?\">" ; endRegex = "</p>" ; AnsjPaser ansjContent = new AnsjPaser ( beginRegex , endRegex ) . addFilterRegex ( "<.*?>" ) ; beginRegex = "onclick=\"GB_SUDA._S_uaTrack\\('weibo_transmit' 'time_origin'\\);\"><strong date=\"" ; endRegex = "\">" ; AnsjPaser ansjPubTime = new AnsjPaser ( beginRegex , endRegex ) ; beginRegex = "<strong lang=\"CL1006\">\u6765\u81EA</strong><cite><a.*?>" ; endRegex = "</a>" ; AnsjPaser ansjFrom = new AnsjPaser ( beginRegex , endRegex ) ; beginRegex = "<strong lang=\"CD0023\" pop=\"true\">\u8F6C\u53D1</strong><strong id=\"num_\\d*?\" rid=\"\\d*?\" type=\"rttCount\">\\(" ; endRegex = "\\)</strong>" ; AnsjPaser ansjRepeat = new AnsjPaser ( beginRegex , endRegex ) ; beginRegex = "<strong lang=\"CL1004\">\u8BC4\u8BBA</strong><strong rid=\"\\d*?\" type=\"commtCount\">\\(" ; endRegex = "\\)</strong>" ; AnsjPaser ansjComment = new AnsjPaser ( beginRegex , endRegex ) ; while ( ansjHtml . hasNext ( ) ) { String c1 = ansjHtml . getNext ( ) ; System . out . println ( "=========================================================================" ) ; System . out . println ( "\u65F6\u95F4:" + ansjPubTime . reset ( c1 ) . getText ( ) ) ; System . out . println ( "\u6765\u6E90:" + ansjFrom . reset ( c1 ) . getText ( ) ) ; String str = ansjRepeat . reset ( c1 ) . getText ( ) ; System . out . println ( "\u8F6C\u53D1:" + ( ( str == null || "" . equals ( str ) ) ? "0" : str ) ) ; str = ansjComment . reset ( c1 ) . getText ( ) ; System . out . println ( "\u8BC4\u8BBA:" + ( ( str == null || "" . equals ( str ) ) ? "0" : str ) ) ; System . out . println ( "\u6B63\u6587:" + ansjContent . reset ( c1 ) . getText ( ) . trim ( ) ) ; } }
te	2	@ Override public void update ( ) { this . backButton . update ( ) ; this . background . update ( ) ; if ( this . backButton . isClicked ( ) ) { Game . getInstance ( ) . loadScene ( SCENE_MENU ) ; } if ( Keyboard . isPressed ( KeyEvent . VK_R ) ) { this . showRaccoon = true ; } this . creditsCollection . update ( ) ; this . title . update ( ) ; }
te	8	public double expectedFScore ( double [ ] p , int n , double beta ) { int nInsts = p . length ; if ( n == 0 ) { double degenerateF1 = 1 ; for ( int i = 0 ; i < nInsts ; i ++ ) { degenerateF1 *= ( 1 - p [ i ] ) ; } return degenerateF1 ; } double [ ] poly1 = new double [ nInsts + 2 ] ; poly1 [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 2 ; j > 0 ; j -- ) poly1 [ j ] = ( 1 - p [ i ] ) * poly1 [ j ] + p [ i ] * poly1 [ j - 1 ] ; } double [ ] poly2 = new double [ nInsts + 2 ] ; poly2 [ 1 ] = 1 ; for ( int i = 0 ; i < nInsts - n ; i ++ ) { for ( int j = i + 2 ; j > 0 ; j -- ) poly2 [ j ] = ( 1 - p [ n + i ] ) * poly2 [ j ] + p [ n + i ] * poly2 [ j - 1 ] ; } double E = 0 ; for ( int TP = 0 ; TP <= n ; TP ++ ) { for ( int FN = 0 ; FN <= nInsts - n ; FN ++ ) { E += Math . abs ( poly1 [ 1 + TP ] * poly2 [ 1 + FN ] ) * ( 1 + beta ) * TP / ( n + beta * ( TP + FN ) ) ; } } return E ; }
te	9	private void parseData ( byte [ ] data , InetAddress address , int port ) { String message = new String ( data ) . trim ( ) ; PacketType type = Packet . getPacketType ( message . substring ( 0 , 2 ) ) ; Packet packet = null ; switch ( type ) { case INVALID : break ; case LOGIN : packet = new Packet00Login ( data ) ; handleLogin ( ( Packet00Login ) packet , address , port ) ; break ; case DISCONNECT : packet = new Packet01Disconnect ( data ) ; System . out . println ( ( ( Packet01Disconnect ) packet ) . getUsername ( ) + " [" + address . getHostAddress ( ) + ":" + port + "] disconnected!" ) ; game . getLevel ( ) . removePlayerMP ( ( ( Packet01Disconnect ) packet ) . getUsername ( ) ) ; break ; case MOVE : packet = new Packet02Move ( data ) ; handleMove ( ( Packet02Move ) packet ) ; break ; case PROJECTILE : packet = new Packet03Projectile ( data ) ; addProjectile ( ( Packet03Projectile ) packet ) ; break ; case TILES : packet = new Packet04Tiles ( data ) ; game . getLevel ( ) . setTiles ( ( ( Packet04Tiles ) packet ) . getTiles ( ) ) ; break ; case ADD_NPC : packet = new Packet05AddNPC ( data ) ; addNPC ( ( Packet05AddNPC ) packet ) ; break ; case INVISIBLE : packet = new Packet06ToggleInvisible ( data ) ; handleInvisibility ( ( Packet06ToggleInvisible ) packet ) ; break ; case RESPAWN : packet = new Packet07Respawn ( data ) ; respawn ( ( Packet07Respawn ) packet , address , port ) ; default : break ; } }
te	0	public Node ( K item , Node < K > prev , Node < K > next ) { this . item = item ; this . prev = prev ; this . next = next ; }
te	3	public Command matchNext ( String nextCommand ) { if ( ! isTerminating ) { for ( int i = 0 ; i < nextCommands . size ( ) ; i ++ ) { if ( nextCommands . get ( i ) . getText ( ) . equalsIgnoreCase ( nextCommand ) ) { return nextCommands . get ( i ) ; } } return null ; } return null ; }
te	1	@ BeforeClass public static void setUpClass ( ) throws Exception { try { session = HibernateUtil . getSessionFactory ( ) . getCurrentSession ( ) ; session . beginTransaction ( ) ; Poblacio pob = new Poblacio ( "Gratallops" ) ; } catch ( RuntimeException e ) { session . getTransaction ( ) . rollback ( ) ; e . printStackTrace ( ) ; } }
te	0	public void write ( org . apache . thrift . protocol . TProtocol oprot ) throws org . apache . thrift . TException { schemes . get ( oprot . getScheme ( ) ) . getScheme ( ) . write ( oprot , this ) ; }
te	8	public void setKeysStructure ( ArrayList < LangFileElement > enFileStructure ) { ArrayList < LangFileElement > elementsToRemove = new ArrayList < > ( ) ; for ( LangFileElement lfe : fileStructure ) { if ( lfe . getType ( ) != LangFileElement . HEADER && lfe . getType ( ) != LangFileElement . STATEMENT ) { elementsToRemove . add ( lfe ) ; } } for ( LangFileElement lfe : elementsToRemove ) { fileStructure . remove ( lfe ) ; } for ( LangFileElement lfe : enFileStructure ) { if ( lfe . getType ( ) != LangFileElement . HEADER ) { fileStructure . add ( lfe ) ; if ( lfe . getType ( ) == LangFileElement . KEY && ! definitions . containsKey ( lfe . getLine ( ) ) ) { definitions . put ( lfe . getLine ( ) , "" ) ; } } } }
te	6	public Body ( Translate position , RotateOrder rotOrder , Translate pivot , Rotate rotX , Rotate rotY , Rotate rotZ , Scale scale ) { this . m_position = position ; setPivot ( pivot ) ; this . m_rotX = rotX ; this . m_rotY = rotY ; this . m_rotZ = rotZ ; super . getTransforms ( ) . addAll ( position , pivot ) ; this . m_rotationOrder = rotOrder ; switch ( rotOrder ) { case XYZ : super . getTransforms ( ) . addAll ( rotX , rotY , rotZ ) ; break ; case XZY : super . getTransforms ( ) . addAll ( rotX , rotZ , rotY ) ; break ; case YXZ : super . getTransforms ( ) . addAll ( rotY , rotX , rotZ ) ; break ; case YZX : super . getTransforms ( ) . addAll ( rotY , rotZ , rotX ) ; break ; case ZXY : super . getTransforms ( ) . addAll ( rotZ , rotX , rotY ) ; break ; case ZYX : super . getTransforms ( ) . addAll ( rotZ , rotY , rotX ) ; break ; default : break ; } this . m_scale = scale ; super . getTransforms ( ) . addAll ( scale , this . m_inversePivot ) ; }
te	8	@ Override public void setParameterValue ( PreparedStatement ps , int parameterIndex , Object parameterValue ) throws SQLException { if ( parameterValue instanceof String ) ps . setString ( parameterIndex , ( String ) parameterValue ) ; else if ( parameterValue instanceof Integer ) ps . setInt ( parameterIndex , ( ( Integer ) parameterValue ) . intValue ( ) ) ; else if ( parameterValue instanceof BigDecimal ) ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; else if ( parameterValue instanceof double ) ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Timestamp ) ps . setTimestamp ( parameterIndex , ( java . sql . Timestamp ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Time ) ps . setTime ( parameterIndex , ( java . sql . Time ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Date ) ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; else if ( parameterValue instanceof java . util . Date ) { long time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new java . sql . Timestamp ( time ) ) ; } else ps . setObject ( parameterIndex , parameterValue ) ; }
te	9	Seleccion sentenciaIF ( Tokens2 [ ] allTokens , int cont ) { contador = cont ; this . allTokens = allTokens ; token = this . getToken ( ) ; if ( token . equals ( "if" ) ) { token = this . getToken ( ) ; if ( token . equals ( "(" ) ) { token = this . getToken ( ) ; while ( ! token . equals ( ")" ) && contador < allTokens . length ) { sentIf . setExpresion ( sentIf . getExpresion ( ) + token ) ; token = this . getToken ( ) ; } if ( contador >= allTokens . length ) { sentIf . setExpresion ( "Error" ) ; return sentIf ; } else { if ( token . equals ( ")" ) ) { token = this . getToken ( ) ; while ( ! token . equals ( "fi" ) && ! token . equals ( "else" ) ) { sentIf . setBloque1 ( sentIf . getBloque1 ( ) + token ) ; token = this . getToken ( ) ; } if ( token . equals ( "fi" ) ) { return sentIf ; } else { if ( contador >= allTokens . length ) { sentIf . setExpresion ( "Error" ) ; return sentIf ; } else { if ( token . equals ( "else" ) ) { token = this . getToken ( ) ; while ( ! token . equals ( "if" ) && contador < this . allTokens . length ) { sentIf . setBloque2 ( sentIf . getBloque2 ( ) + token ) ; token = this . getToken ( ) ; } if ( token . equals ( "fi" ) ) { return sentIf ; } else { if ( contador >= this . allTokens . length ) { sentIf . setExpresion ( "Error" ) ; return sentIf ; } } } } } } } } } return sentIf ; }
te	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
te	4	public boolean isGlobal ( Object value ) { if ( globalObjects . containsKey ( value ) ) return true ; for ( class < ? > g : globalClasses ) { if ( g . isInstance ( value ) ) return true ; } return classHasGlobalMarker ( value . getClass ( ) ) ; }
te	8	public void fileDialogAction ( MyFileDialog f , int action ) { if ( action == MyFileDialog . OKAY ) { if ( f . getMode ( ) == MyFileDialog . LOAD ) { WindowRegistry . saveCursors ( ) ; WindowRegistry . setAllCursors ( WAIT_CURSOR ) ; try { if ( f . isURL ( ) ) new SynthWindow ( f . getURL ( ) ) . show ( ) ; else new SynthWindow ( f . getF ( ) ) . show ( ) ; } catch ( Exception e ) { new ExceptionDialog ( this , e ) . show ( ) ; } finally { WindowRegistry . restoreCursors ( ) ; } } else { OutputStream fout = null ; WindowRegistry . saveCursors ( ) ; WindowRegistry . setAllCursors ( WAIT_CURSOR ) ; try { fout = f . getOutputStream ( ) ; fout = new FileOutputStream ( f . getF ( ) ) ; synthCanvas . save ( fout ) ; if ( f . isURL ( ) ) { url = f . getURL ( ) ; file = null ; name = url . toString ( ) ; } else { file = f . getF ( ) ; url = null ; name = file . toString ( ) ; } setTitle ( ) ; saveMenuItem . enable ( ) ; } catch ( Exception e ) { new ExceptionDialog ( this , e ) . show ( ) ; } finally { try { if ( fout != null ) fout . close ( ) ; } catch ( IOException e ) { } WindowRegistry . restoreCursors ( ) ; } } } }
te	2	public static AbstractInanimateEntity getInEnt ( int uniqueID ) { if ( uniqueID <= inent . size ( ) && inent . get ( uniqueID ) != null ) { return inent . get ( uniqueID ) ; } else { System . out . println ( "Tried to access an ID not bound to an InEnt" ) ; System . out . println ( String . valueOf ( uniqueID ) ) ; return inent . get ( 0 ) ; } }
te	5	private static boolean method311 ( int i , int j , int k ) { int l = j * anInt460 + k * anInt461 >> 16 ; int i1 = j * anInt461 - k * anInt460 >> 16 ; int j1 = i * anInt458 + i1 * anInt459 >> 16 ; int k1 = i * anInt459 - i1 * anInt458 >> 16 ; if ( j1 < 50 || j1 > 3500 ) return false ; int l1 = anInt493 + ( l << 9 ) / j1 ; int i2 = anInt494 + ( k1 << 9 ) / j1 ; return l1 >= anInt495 && l1 <= anInt497 && i2 >= anInt496 && i2 <= anInt498 ; }
te	3	public void flip ( int fromIndex , int toIndex ) { checkRange ( fromIndex , toIndex ) ; if ( fromIndex == toIndex ) return ; int startWordIndex = wordIndex ( fromIndex ) ; int endWordIndex = wordIndex ( toIndex - 1 ) ; expandTo ( endWordIndex ) ; long firstWordMask = WORD_MASK << fromIndex ; long lastWordMask = WORD_MASK >>> - toIndex ; if ( startWordIndex == endWordIndex ) { words [ startWordIndex ] ^= ( firstWordMask & lastWordMask ) ; } else { words [ startWordIndex ] ^= firstWordMask ; for ( int i = startWordIndex + 1 ; i < endWordIndex ; i ++ ) words [ i ] ^= WORD_MASK ; words [ endWordIndex ] ^= lastWordMask ; } recalculateWordsInUse ( ) ; checkInvariants ( ) ; }
te	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
te	8	public void calcula ( ) { Calendar calendario = new GregorianCalendar ( ) ; Date fechaHoraActual = new Date ( ) ; calendario . setTime ( fechaHoraActual ) ; ampm = calendario . get ( Calendar . AM_PM ) == Calendar . AM ? "AM" : "PM" ; if ( ampm . equals ( "PM" ) ) { int h = calendario . get ( Calendar . HOUR_OF_DAY ) - 12 ; hora = h > 9 ? "" + h : "0" + h ; if ( hora . equals ( "00" ) ) { hora = "12" ; } else { hora = h > 9 ? "" + h : "0" + h ; } } else { hora = calendario . get ( Calendar . HOUR_OF_DAY ) > 9 ? "" + calendario . get ( Calendar . HOUR_OF_DAY ) : "0" + calendario . get ( Calendar . HOUR_OF_DAY ) ; } minutos = calendario . get ( Calendar . MINUTE ) > 9 ? "" + calendario . get ( Calendar . MINUTE ) : "0" + calendario . get ( Calendar . MINUTE ) ; segundos = calendario . get ( Calendar . SECOND ) > 9 ? "" + calendario . get ( Calendar . SECOND ) : "0" + calendario . get ( Calendar . SECOND ) ; ao = jYearChooser1 . getYear ( ) ; mes = jMonthChooser1 . getMonth ( ) ; jDayChooser1 . setMonth ( mes ) ; this . jDayChooser1 . setYear ( ao ) ; }
te	8	public void teardownAll ( ) { this . shuttingDown = true ; this . sqsListener . interrupt ( ) ; this . gridManager . interrupt ( ) ; sqsClient . deleteQueue ( new DeleteQueueRequest ( dispatchQueue ) ) ; sqsClient . deleteQueue ( new DeleteQueueRequest ( returnQueue ) ) ; System . out . println ( "Deleted SQS queues" ) ; boolean success = ( new File ( Constants . DUMPFILELOC ) ) . delete ( ) ; if ( success ) { System . out . println ( "Deleted unitsOnServer" ) ; } else { System . err . println ( "Problem deleting unitsOnServer" ) ; } DescribeInstancesRequest describeInstancesRequest = new DescribeInstancesRequest ( ) ; describeInstancesRequest . withFilters ( new Filter ( "image-id" ) . withValues ( Constants . imageID ) ) ; System . out . println ( "Getting list of active cumulus drones" ) ; List < String > instanceIds = new ArrayList < String > ( ) ; try { AmazonEC2 ec2 = new AmazonEC2Client ( this . credentials ) ; DescribeInstancesResult describeInstancesResult = ec2 . describeInstances ( describeInstancesRequest ) ; List < Reservation > reservations = describeInstancesResult . getReservations ( ) ; if ( reservations != null && reservations . size ( ) != 0 ) { for ( Reservation reservation : reservations ) { List < Instance > instances = reservation . getInstances ( ) ; if ( instances != null ) { for ( Instance instance : instances ) { instanceIds . add ( instance . getInstanceId ( ) ) ; } } } System . out . println ( "Terminate instances" ) ; TerminateInstancesRequest terminateRequest = new TerminateInstancesRequest ( instanceIds ) ; ec2 . terminateInstances ( terminateRequest ) ; } } catch ( AmazonServiceException e ) { System . err . println ( "Error terminating instances" ) ; System . err . println ( "Caught Exception: " + e . getMessage ( ) ) ; System . err . println ( "Reponse Status Code: " + e . getStatusCode ( ) ) ; System . err . println ( "Error Code: " + e . getErrorCode ( ) ) ; System . err . println ( "Request ID: " + e . getRequestId ( ) ) ; } catch ( Exception e ) { System . err . println ( e ) ; System . err . println ( "Did not exit cleanly" ) ; } System . out . println ( "Killed all cumulus drones" ) ; }
te	9	@ Override public < T > int deleteByLogic ( class < T > pojoType , Object ... args ) throws DataAccessException { int r = 0 ; Map < String , List < Object [ ] >> sqlAndArgsList = new HashMap < String , List < Object [ ] >> ( ) ; try { for ( Object arg : args ) { SqlDelGenerator sqlGenerator = new SqlDelGenerator ( pojoType , arg , false ) ; String sql = sqlGenerator . getSql ( ) ; if ( sqlAndArgsList . containsKey ( sql ) ) { sqlAndArgsList . get ( sql ) . add ( sqlGenerator . getArgs ( ) ) ; } else { List < Object [ ] > argsList = new ArrayList < Object [ ] > ( ) ; argsList . add ( sqlGenerator . getArgs ( ) ) ; sqlAndArgsList . put ( sql , argsList ) ; } } } catch ( IllegalArgumentException e ) { logger . error ( "init delete sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init delete sql error!" , e ) ; } catch ( IllegalAccessException e ) { logger . error ( "init delete sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init delete sql error!" , e ) ; } catch ( NoSuchFieldException e ) { logger . error ( "init delete sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init delete sql error!" , e ) ; } catch ( SecurityException e ) { logger . error ( "init delete sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init delete sql error!" , e ) ; } catch ( SQLException e ) { logger . error ( "init delete sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init delete sql error!" , e ) ; } catch ( InstantiationException e ) { throw new DataAccessException ( "init delete sql error!" , e ) ; } for ( String sql : sqlAndArgsList . keySet ( ) ) { int [ ] ii = batchUpdate ( sql , sqlAndArgsList . get ( sql ) ) ; for ( int i : ii ) { r += i ; } } return r ; }
te	3	public static String toString ( String _data ) { String data = _data ; if ( data != null ) { data = data . trim ( ) ; } if ( "" . equals ( data ) || "null" . equals ( data ) ) { return null ; } return data ; }
te	0	public String getModificat ( ) { return modificat ; }
te	9	private boolean doAdjacentMerge ( Face face , int mergeType ) { HalfEdge hedge = face . he0 ; boolean convex = true ; do { Face oppFace = hedge . oppositeFace ( ) ; boolean merge = false ; double dist1 , dist2 ; if ( mergeType == NONCONVEX ) { if ( oppFaceDistance ( hedge ) > - tolerance || oppFaceDistance ( hedge . opposite ) > - tolerance ) { merge = true ; } } else { if ( face . area > oppFace . area ) { if ( ( dist1 = oppFaceDistance ( hedge ) ) > - tolerance ) { merge = true ; } else if ( oppFaceDistance ( hedge . opposite ) > - tolerance ) { convex = false ; } } else { if ( oppFaceDistance ( hedge . opposite ) > - tolerance ) { merge = true ; } else if ( oppFaceDistance ( hedge ) > - tolerance ) { convex = false ; } } } if ( merge ) { if ( debug ) { System . out . println ( "  merging " + face . getVertexString ( ) + "  and  " + oppFace . getVertexString ( ) ) ; } int numd = face . mergeAdjacentFace ( hedge , discardedFaces ) ; for ( int i = 0 ; i < numd ; i ++ ) { deleteFacePoints ( discardedFaces [ i ] , face ) ; } if ( debug ) { System . out . println ( "  result: " + face . getVertexString ( ) ) ; } return true ; } hedge = hedge . next ; } while ( hedge != face . he0 ) ; if ( ! convex ) { face . mark = Face . NON_CONVEX ; } return false ; }
te	1	public List < Produto > getListagem ( ) { if ( listagem == null ) atualizaListagem ( ) ; return listagem ; }
te	9	public static void trimTrailingSpace ( Lexer lexer , Node element , Node last ) { byte c ; TagTable tt = lexer . configuration . tt ; if ( last != null && last . type == Node . TextNode && last . end > last . start ) { c = lexer . lexbuf [ last . end - 1 ] ; if ( c == 160 || c == ( byte )   ) { if ( element . tag == tt . tagTd || element . tag == tt . tagTh ) { if ( last . end > last . start + 1 ) last . end -= 1 ; } else { last . end -= 1 ; if ( ( ( element . tag . model & Dict . CM_INLINE ) != 0 ) && ! ( ( element . tag . model & Dict . CM_FIELD ) != 0 ) ) lexer . insertspace = true ; if ( last . start == last . end ) trimEmptyElement ( lexer , last ) ; } } } }
te	0	public void add ( Location loc , T occupant ) { getGrid ( ) . put ( loc , occupant ) ; repaint ( ) ; }
te	3	@ Override public String getKey ( ) { ID3v2TextFrameData frameData = extractTextFrameData ( obseleteFormat ? ID_KEY_OBSELETE : ID_KEY ) ; if ( frameData == null || frameData . getText ( ) == null ) { return null ; } return frameData . getText ( ) . toString ( ) ; }
te	7	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
te	2	private static void printShortestPath ( List < Integer > shortestPath ) { if ( shortestPath == null ) { System . out . println ( "Shortest path doesnt exist" ) ; return ; } String outputString = "" ; for ( Integer i : shortestPath ) { outputString += i + "->" ; } System . out . println ( outputString . substring ( 0 , outputString . length ( ) - 2 ) ) ; }
te	4	public static Packet construct ( byte id ) throws UnknownPacketException { class < ? extends Packet > cls = get ( id ) ; Packet packet ; try { packet = ( Packet ) cls . newInstance ( ) ; } catch ( InstantiationException e ) { throw new UnknownPacketException ( e ) ; } catch ( IllegalAccessException e ) { throw new UnknownPacketException ( e ) ; } if ( id != packet . getId ( ) ) { throw new RuntimeException ( "Packet ID does not match read ID for " + packet . getClass ( ) . getCanonicalName ( ) + "; packet says " + packet . getId ( ) + "; actual is " + id ) ; } return packet ; }
te	3	protected static void clearObjects ( ) { if ( IUnknown . isDebugEnabled ( ) ) { IUnknown . debug ( "ROT: " + objects . size ( ) + " objects to clear in this thread's ROT " ) ; } for ( PointerWeakReference reference : objects . keySet ( ) ) { IUnknown value = ( IUnknown ) reference . get ( ) ; if ( value != null ) { value . safeRelease ( ) ; } } objects . clear ( ) ; }
te	2	public static List < String > readStringSubKeys ( int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( hkey == HKEY_LOCAL_MACHINE ) { return readStringSubKeys ( systemRoot , hkey , key ) ; } else if ( hkey == HKEY_CURRENT_USER ) { return readStringSubKeys ( userRoot , hkey , key ) ; } else { throw new IllegalArgumentException ( "hkey=" + hkey ) ; } }
te	5	private void setClosestCities ( ) { closestCities . clear ( ) ; for ( final Ship mine : ClientGame . getMyShips ( ) ) { List < City > temp = ClientGame . getAllCities ( ) ; temp . removeAll ( ClientGame . getMyCities ( ) ) ; Coordinate [ ] arr = new Coordinate [ temp . size ( ) ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = temp . get ( i ) . getLocation ( ) ; Arrays . sort ( arr , new Comparator < Coordinate > ( ) { @ Override public int compare ( Coordinate a , Coordinate b ) { double temp = mine . distanceFromCoord ( a ) - mine . distanceFromCoord ( b ) ; if ( temp < 0 ) return - 1 ; if ( temp > 0 ) return 1 ; return 0 ; } } ) ; List < Coordinate > coords = new LinkedList < Coordinate > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) coords . add ( arr [ i ] ) ; closestCities . put ( mine , coords ) ; } }
te	6	@ Override public void run ( ) { String msg = "!auction-ended " + getHighestBidder ( ) . getName ( ) + " " + printHighestAmount ( ) + " " + getDescribtion ( ) ; try { if ( userManagement . getUserByName ( owner . getName ( ) ) . isOnline ( ) ) { } else { userManagement . getUserByName ( owner . getName ( ) ) . storeNotification ( msg ) ; } if ( ! getHighestBidder ( ) . getName ( ) . equals ( "none" ) ) { if ( userManagement . getUserByName ( getHighestBidder ( ) . getName ( ) ) . isOnline ( ) ) { } else { userManagement . getUserByName ( getHighestBidder ( ) . getName ( ) ) . storeNotification ( msg ) ; } Timestamp logoutTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; long timestamp = logoutTimestamp . getTime ( ) ; try { mClientHandler . processEvent ( new BidEvent ( BidEvent . BID_WON , timestamp , getHighestBidder ( ) . getName ( ) , id , hightestAmount ) ) ; } catch ( WrongEventTypeException e ) { } CommunicationProtocol . billAuction ( getHighestBidder ( ) . getName ( ) , id , hightestAmount ) ; } Timestamp logoutTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; long timestamp = logoutTimestamp . getTime ( ) ; try { mClientHandler . processEvent ( new AuctionEvent ( AuctionEvent . AUCTION_ENDED , timestamp , this . id , durationSec , highestBidder . getName ( ) ) ) ; } catch ( WrongEventTypeException e ) { } synchronized ( userManagement . syncAuctionList ) { userManagement . syncAuctionList . remove ( this ) ; } } catch ( IOException e ) { System . out . println ( "Didn't send Notification." ) ; } }
te	1	public void setCodigoUsuario ( String codigoUsuario ) { if ( this . estado . permiteModicifacion ( ) ) { this . codigoUsuario = codigoUsuario ; } }
te	9	public static void deleteUserInfo ( UserPacket user ) { File file = new File ( loggedUsersFile ) ; File tmpFile = new File ( loggedUsersFile + ".tmp" ) ; BufferedReader br = null ; PrintWriter pw = null ; String line ; if ( ! file . isFile ( ) ) { Server . loggerServer . info ( "File doesn't exist" ) ; return ; } try { br = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e2 ) { Server . loggerServer . error ( "File " + loggedUsersFile + "wasn't found" ) ; e2 . printStackTrace ( ) ; } try { pw = new PrintWriter ( new FileWriter ( tmpFile ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { if ( ! tmpFile . exists ( ) ) tmpFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { while ( null != ( line = br . readLine ( ) ) ) { String username = line . split ( "\\s+" ) [ 0 ] ; if ( ! username . equals ( user . username ) ) { pw . write ( line + "\n" ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } pw . close ( ) ; try { br . close ( ) ; } catch ( IOException e ) { Server . loggerServer . error ( "Error closing read buffer" ) ; e . printStackTrace ( ) ; } if ( ! file . delete ( ) ) { Server . loggerServer . error ( "Error deleting the old file" ) ; } if ( tmpFile . renameTo ( file ) ) { Server . loggerServer . error ( "Could not rename file" ) ; } }
te	2	public boolean pickup ( List < Node > neighborhood , double density ) { if ( rand . nextDouble ( ) <= pickupProbability ( density ) && neighborhood . size ( ) > 1 ) { Node toPickUp = Utilities . mostUnique ( neighborhood ) ; lastError = toPickUp . getError ( ) ; holding = toPickUp ; color = colorHolding ; return true ; } return false ; }
te	9	public Menu ( Menu parent , Player player , int index , String text , Piece piece , Board board ) { _parent = parent ; _player = player ; _index = index ; _text = text ; _pieces . add ( piece ) ; _options = new ArrayList < Object > ( ) ; _selector = new TargetSelector ( ) ; if ( text . equals ( "Produce" ) ) { ProductionBuilding building = ( ProductionBuilding ) piece ; String [ ] unitList = building . get_produceableUnits ( ) ; for ( int i = 0 ; i < unitList . length ; i ++ ) { _options . add ( unitList [ i ] ) ; _selectionList . add ( new Selection ( i + 1 , unitList [ i ] ) ) ; } } else if ( text . equals ( "Move" ) ) { Unit unit = ( Unit ) piece ; ArrayList < Node > moves = board . get_moves ( unit ) ; for ( int i = 0 ; i < moves . size ( ) ; i ++ ) { Node n = moves . get ( i ) ; _options . add ( new Position ( n . get_x ( ) , n . get_y ( ) ) ) ; _selectionList . add ( new Selection ( i + 1 , n . toString ( ) ) ) ; } } else if ( text . equals ( "Attack" ) ) { AttackingUnit unit = ( AttackingUnit ) piece ; ArrayList < Position > attackPositions = board . findPositions ( unit . get_position ( ) , unit . get_weapon ( ) . get_minRange ( ) , unit . get_weapon ( ) . get_maxRange ( ) ) ; int i = 1 ; for ( Position p : attackPositions ) { Unit board_unit = board . get_unit ( p ) ; if ( board_unit != null && board_unit . get_owner ( ) != player ) { _options . add ( board_unit ) ; _selectionList . add ( new Selection ( i ++ , board_unit . toString ( ) ) ) ; } } } else if ( text . equals ( "Load" ) ) { } else if ( text . equals ( "Unload" ) ) { } }
