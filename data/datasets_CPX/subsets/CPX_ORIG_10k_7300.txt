va	2	@ Override public IndexedDataObject get ( String a , String b , int version ) { if ( table . get ( Hash . get ( a , b ) ) . size ( ) > version && version >= 0 ) return table . get ( Hash . get ( a , b ) ) . get ( version ) ; else return null ; }
va	8	private void scan ( final JarFile jar ) throws IOException { for ( final JarEntry entry : Collections . list ( jar . entries ( ) ) ) { if ( ! entry . isDirectory ( ) && entry . getName ( ) . endsWith ( ".class" ) ) { String path = entry . getName ( ) ; boolean mustScan = false ; for ( Search < ? > scan : allWork ) { if ( scan . packagePrefix == null || path . startsWith ( scan . packagePrefix ) ) { mustScan = true ; break ; } } if ( ! mustScan ) { continue ; } start ( new Callable < void > ( ) { @ Override public void call ( ) throws Exception { InputStream in = jar . getInputStream ( entry ) ; try { analyze ( new ClassReader ( in ) ) ; } finally { in . close ( ) ; } return null ; } } ) ; } } }
va	2	@ Override public void Consultar ( ) throws SQLException { try { Conexion . GetInstancia ( ) . Conectar ( ) ; ResultSet rs = Conexion . GetInstancia ( ) . EjecutarConsulta ( "" ) ; while ( rs . next ( ) ) { ObProducto . setNom_Producto ( rs . getString ( "" ) ) ; ObProducto . setDes_Producto ( rs . getString ( "" ) ) ; ObProducto . setEst_Producto ( rs . getString ( "" ) ) ; ObProducto . setStock_Producto ( rs . getString ( "" ) ) ; ObProducto . setPVP_Producto ( rs . getDouble ( "" ) ) ; ObProducto . setMar_Producto ( rs . getString ( "" ) ) ; ObProducto . setTam_Producto ( rs . getString ( "" ) ) ; } } catch ( SQLException ex ) { throw ex ; } finally { Conexion . GetInstancia ( ) . Desconectar ( ) ; } }
va	5	public static ArrayList < Neuron > mergeByDepth ( ArrayList < Neuron > one , ArrayList < Neuron > two ) { ArrayList < Neuron > list = new ArrayList < > ( ) ; while ( ! one . isEmpty ( ) && ! two . isEmpty ( ) ) { if ( one . get ( 0 ) . getDepth ( ) < two . get ( 0 ) . getDepth ( ) ) list . add ( one . remove ( 0 ) ) ; else list . add ( two . remove ( 0 ) ) ; } while ( ! one . isEmpty ( ) ) list . add ( one . remove ( 0 ) ) ; while ( ! two . isEmpty ( ) ) list . add ( two . remove ( 0 ) ) ; return list ; }
va	5	private dbMngST ( ) { System . out . println ( "dbMngST.CTOR()>>" ) ; String userName = "root" ; String password = "eranadi822" ; String url = "jdbc:mysql://localhost:3306/MBank_DB" ; try { System . out . println ( "Trying To Load MySQL Driver...." ) ; class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; System . out . println ( "Succesfully Loaded MySQL Driver!" ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } try { System . out . println ( "Trying To Connect To MySQL DB...." ) ; con = DriverManager . getConnection ( url , userName , password ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } if ( con != null ) { System . out . println ( "*******************************************" ) ; System . out . println ( "A Connection To MySQL Has Been Established" ) ; System . out . println ( "*******************************************" ) ; } }
va	2	private CreaturePluginFactory ( double inMaxSpeed ) { try { pluginLoader = new PluginLoader ( pluginDir , ICreature . class ) ; } catch ( MalformedURLException ex ) { } maxSpeed = inMaxSpeed ; constructorMap = new HashMap < String , Constructor < ? extends ICreature >> ( ) ; load ( ) ; }
va	3	public boolean checkValue ( ) { try { double f = double . parseDouble ( this . getText ( ) . replaceAll ( " " , "" ) ) ; if ( f < vmin || f > vmax ) throw new OutOfRangeException ( name + " is out of range " + vmin + " to " + vmax ) ; this . setNormal ( ) ; return true ; } catch ( Exception e ) { this . setError ( ) ; System . out . println ( e ) ; return false ; } }
va	0	@ Test public void testGetModifierAndTagForCase2 ( ) { POSBasedAnnotator myTester = this . markupByPOSFactory ( ) ; String modifier = "large interlocking" ; int start = 2 ; int end = 3 ; List < String > words = new ArrayList < String > ( ) ; words . addAll ( Arrays . asList ( "large interlocking <N>plates</N> <B>with</B> pronounced crescentic <N>margins</N>" . split ( " " ) ) ) ; List < String > target = new LinkedList < String > ( ) ; target . add ( "large interlocking" ) ; target . add ( "<N>plates</N>" ) ; assertEquals ( "getModifierAndTagForCase1" , target , myTester . getModifierAndTagForCase2 ( modifier , start , end , words ) ) ; }
va	6	protected void createSubbands ( ) { int i ; if ( mode == Header . SINGLE_CHANNEL ) for ( i = 0 ; i < num_subbands ; ++ i ) subbands [ i ] = new SubbandLayer1 ( i ) ; else if ( mode == Header . JOINT_STEREO ) { for ( i = 0 ; i < header . intensity_stereo_bound ( ) ; ++ i ) subbands [ i ] = new SubbandLayer1Stereo ( i ) ; for ( ; i < num_subbands ; ++ i ) subbands [ i ] = new SubbandLayer1IntensityStereo ( i ) ; } else { for ( i = 0 ; i < num_subbands ; ++ i ) subbands [ i ] = new SubbandLayer1Stereo ( i ) ; } }
va	0	@ Test public void testPlayerLightGrenadeOnRightDown ( ) throws InvalidActionException { new MoveRightDown ( ) . doAction ( playerLightGrenade , gridLightGrenade ) ; assertEquals ( - 1 , playerLightGrenade . getRemainingTurns ( ) ) ; }
va	8	public static ArrayList < ArrayList < String >> createListFromString ( String s ) { ArrayList < ArrayList < String >> newlists = new ArrayList < ArrayList < String >> ( ) ; int length = 1 ; while ( length < s . length ( ) ) { if ( ! s . substring ( length - 1 , length ) . equals ( s . substring ( length , length + 1 ) ) ) { break ; } length ++ ; } if ( length == s . length ( ) ) { ArrayList < ArrayList < String >> newlists1 = new ArrayList < ArrayList < String >> ( ) ; newlists1 = createListFromSameLetterString ( s , newlists , s . length ( ) ) ; return newlists1 ; } int start = 0 ; int end = s . length ( ) - 1 ; while ( start <= end ) { ArrayList < String > newList = new ArrayList < String > ( ) ; if ( newlists . size ( ) != 0 ) { if ( newlists . size ( ) > 0 ) { int disL = start - 1 ; int disR = end + 1 ; while ( disL > 0 ) { String lastEdge = newlists . get ( newlists . size ( ) - 1 ) . get ( disL - 1 ) ; newList . add ( lastEdge ) ; disL -- ; } newList . add ( s . substring ( start - 1 , start ) ) ; newList . add ( s . substring ( start , end + 1 ) ) ; newList . add ( s . substring ( start - 1 , start ) ) ; disL = start - 1 ; while ( disL > 0 ) { String lastEdge = newlists . get ( newlists . size ( ) - 1 ) . get ( disL - 1 ) ; newList . add ( lastEdge ) ; disL -- ; } newlists . add ( newList ) ; } } else { newList . add ( s . substring ( start , end + 1 ) ) ; newlists . add ( newList ) ; } start ++ ; end -- ; } return newlists ; }
va	4	public static void draw ( Graphics g , BlockPoint bp , MouseState ms , MapProps mp , JPanel panel ) { switch ( mp . props . type ) { case PIG : { PigClip pigsties = new PigClip ( bp ) ; PigClip c = new PigClip ( mp . state , bp , mp . range . w , mp . range . h ) ; Image img = CableBattle . cb . resource . getPropsImage ( mp . props . type ) ; if ( img == null ) { return ; } g . drawImage ( img , pigsties . dleft , pigsties . dtop , pigsties . dleft + BlockPanel . WIDTH , pigsties . dtop + BlockPanel . HEIGHT , pigsties . left , pigsties . top , pigsties . right , pigsties . bottom , panel ) ; g . drawImage ( img , c . dleft , c . dtop , c . dleft + BlockPanel . WIDTH , c . dtop + BlockPanel . HEIGHT , c . left , c . top , c . right , c . bottom , panel ) ; } break ; case CABLE : { CableClip c = new CableClip ( mp . state ) ; Image img = CableBattle . cb . resource . getPropsImage ( mp . props . type ) ; if ( img == null ) { return ; } g . drawImage ( img , bp . left ( ) , bp . top ( ) , bp . left ( ) + BlockPanel . WIDTH , bp . top ( ) + BlockPanel . HEIGHT , c . left , c . top , c . right , c . bottom , null ) ; } break ; default : draw ( g , bp . left ( ) , bp . top ( ) , ms , mp . props . type , panel ) ; break ; } }
va	4	private boolean optionsHasAnyOf ( OptionSet options , Collection < OptionSpec < ? >> specs ) { for ( OptionSpec < ? > each : specs ) { if ( options . has ( each ) ) return true ; } return false ; }
va	9	public static String method525 ( int i , Stream stream ) { int j = 0 ; int k = - 1 ; for ( int l = 0 ; l < i ; l ++ ) { int i1 = stream . readUnsignedByte ( ) ; int j1 = i1 >> 4 & f ; if ( k == - 1 ) { if ( j1 < 13 ) aCharArray631 [ j ++ ] = validChars [ j1 ] ; else k = j1 ; } else { aCharArray631 [ j ++ ] = validChars [ ( ( k << 4 ) + j1 ) - 195 ] ; k = - 1 ; } j1 = i1 & f ; if ( k == - 1 ) { if ( j1 < 13 ) aCharArray631 [ j ++ ] = validChars [ j1 ] ; else k = j1 ; } else { aCharArray631 [ j ++ ] = validChars [ ( ( k << 4 ) + j1 ) - 195 ] ; k = - 1 ; } } boolean flag1 = true ; for ( int k1 = 0 ; k1 < j ; k1 ++ ) { char c = aCharArray631 [ k1 ] ; if ( flag1 && c >= a && c <= z ) { aCharArray631 [ k1 ] += ï¿  ; flag1 = false ; } if ( c == . || c == ! || c == ? ) flag1 = true ; } return new String ( aCharArray631 , 0 , j ) ; }
va	0	public int size ( ) { return tasks . size ( ) ; }
va	1	public void addNewRcm ( String loc , int id , double wei , double cashh ) throws SQLException { Connection conn = connnect . connect ( ) ; ResultSet res = sql . getRCMCount ( conn ) ; int count = 0 ; while ( res . next ( ) ) { count = res . getInt ( "count" ) ; } sqlInsert . addNewRCM ( conn , count + 1 , loc , wei , cashh ) ; sqlInsert . addItemToRCM ( conn , count + 1 , id ) ; conn . close ( ) ; }
va	9	public Ranker create ( RankerType ranker ) { switch ( ranker ) { case CONJUNCTIVE : return new RankerConjunctive ( indexer ) ; case FAVORITE : case COSINE : return new CosineRanker ( indexer ) ; case QL : return new QLRanker ( indexer ) ; case PHRASE : return new PhraseRanker ( indexer ) ; case LINEAR : return new LinearRanker ( indexer ) ; case NUMVIEWS : return new NumViewsRanker ( indexer ) ; case FULLSCAN : case NONE : return new SimpleRanker ( indexer ) ; default : } throw new IllegalArgumentException ( "Unrecognized ranker type:  " + ranker ) ; }
va	4	public void attackBuilding ( Unit attacker , Building toBeAttacked , boolean aiMove ) { if ( aiMove || Teams . comparePlayers ( this . getOwner ( ) , game . getCurrentPlayer ( ) ) ) { HashSet < Player > tmp = Teams . getTeamFriends ( Teams . getTeamOfPlayer ( owner ) ) ; if ( attacker . getAttacked ( ) == true ) { game . mapPanel . Notify ( "A unit can only attack once per turn!" ) ; } else if ( tmp . contains ( toBeAttacked . getOwner ( ) ) ) { game . mapPanel . Notify ( "You cannot attack allied units!" ) ; } else { moveToCell ( this , this . getCell ( ) , moveToAttack ( toBeAttacked . getCell ( ) ) , true ) ; toBeAttacked . attacked ( attacker ) ; attacked = true ; } } else { game . mapPanel . Notify ( "You can only attack buildings with your units!" ) ; } }
va	9	public void decode ( List < Datum > data , List < Datum > dataWithMultiplePrevLabels ) { List < String > words = new ArrayList < String > ( ) ; for ( Datum datum : data ) { words . add ( datum . word ) ; } int [ ] [ ] backpointers = new int [ data . size ( ) ] [ numLabels ( ) ] ; double [ ] [ ] scores = new double [ data . size ( ) ] [ numLabels ( ) ] ; int prevLabel = labelIndex . indexOf ( data . get ( 0 ) . previousLabel ) ; double [ ] localScores = computeScores ( data . get ( 0 ) . features ) ; int position = 0 ; for ( int currLabel = 0 ; currLabel < localScores . length ; currLabel ++ ) { backpointers [ position ] [ currLabel ] = prevLabel ; scores [ position ] [ currLabel ] = localScores [ currLabel ] ; } for ( position = 1 ; position < data . size ( ) ; position ++ ) { int i = position * numLabels ( ) - 1 ; for ( int j = 0 ; j < numLabels ( ) ; j ++ ) { Datum datum = dataWithMultiplePrevLabels . get ( i + j ) ; String previousLabel = datum . previousLabel ; prevLabel = labelIndex . indexOf ( previousLabel ) ; localScores = computeScores ( datum . features ) ; for ( int currLabel = 0 ; currLabel < localScores . length ; currLabel ++ ) { double score = localScores [ currLabel ] + scores [ position - 1 ] [ prevLabel ] ; if ( prevLabel == 0 || score > scores [ position ] [ currLabel ] ) { backpointers [ position ] [ currLabel ] = prevLabel ; scores [ position ] [ currLabel ] = score ; } } } } int bestLabel = 0 ; double bestScore = scores [ data . size ( ) - 1 ] [ 0 ] ; for ( int label = 1 ; label < scores [ data . size ( ) - 1 ] . length ; label ++ ) { if ( scores [ data . size ( ) - 1 ] [ label ] > bestScore ) { bestLabel = label ; bestScore = scores [ data . size ( ) - 1 ] [ label ] ; } } for ( position = data . size ( ) - 1 ; position >= 0 ; position -- ) { Datum datum = data . get ( position ) ; datum . guessLabel = ( String ) labelIndex . get ( bestLabel ) ; bestLabel = backpointers [ position ] [ bestLabel ] ; } }
va	2	public long getServerTime ( ) throws ParserConfigurationException , SAXException , IOException { URL timeUrl = new URL ( Constants . TIME_URL ) ; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; Document document = documentBuilder . parse ( timeUrl . openStream ( ) ) ; Element rootElement = document . getDocumentElement ( ) ; NodeList nodes = rootElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; if ( node . getNodeName ( ) . equals ( "Time" ) ) { return long . parseLong ( node . getTextContent ( ) ) ; } } return - 1 ; }
va	3	Query getOrCreateSubQuery ( MainQuery mainQuery , String newId , String ... subIds ) { int count = countSub . get ( ) ; Query oldOne = null ; oldOne = subQueries . get ( newId ) ; if ( count == countSub . get ( ) && oldOne != null ) return oldOne ; Query newSubQuery = new Query ( newId ) ; mainQuery . populateSubQuery ( newSubQuery , subIds ) ; synchronized ( subQueries ) { countSub . incrementAndGet ( ) ; oldOne = subQueries . get ( newId ) ; if ( oldOne != null ) return oldOne ; subQueries . put ( newId , newSubQuery ) ; return newSubQuery ; } }
va	4	public void networkToFile ( String fileName ) { File outFile = new File ( fileName ) ; String weightList ; double [ ] weight ; try { FileWriter fw = new FileWriter ( outFile ) ; PrintWriter pw = new PrintWriter ( fw ) ; int networkSize = neuronList . length ; for ( int i = 0 ; i < networkSize ; i ++ ) { weightList = "" ; weight = neuronList [ i ] . getWeight ( ) ; for ( int j = 0 ; j < weight . length ; j ++ ) { weightList += weight [ j ] ; if ( j < weight . length - 1 ) { weightList += "\t" ; } } pw . println ( weightList ) ; } fw . close ( ) ; } catch ( IOException e ) { System . out . println ( "File can not be read!. Error: " + e ) ; } }
va	0	public Mantenimiento ( ) { initComponents ( ) ; this . objFI = new FachadaInterfaz ( ) ; this . setMaximumSize ( this . getPreferredSize ( ) ) ; objFI . addObserver ( this ) ; tableItems . getTableHeader ( ) . setReorderingAllowed ( false ) ; tableItems . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; }
va	1	static private void test ( NeuralNetwork network , List < Sample > samples ) { double error = 0 ; for ( Sample sample : samples ) { network . getInput ( ) . setValues ( sample . input ) ; network . forwardPropagate ( ) ; double diff = sample . output [ 0 ] - network . getOutput ( ) . getValue ( 0 ) ; error += diff * diff ; } System . out . println ( "Error: " + error ) ; }
va	5	@ Override public boolean lue ( String syote ) { int sulut = 0 ; for ( int i = 0 ; i < syote . length ( ) ; i ++ ) { if ( syote . substring ( i , i + 1 ) . contentEquals ( "(" ) ) { sulut ++ ; } else if ( syote . substring ( i , i + 1 ) . contentEquals ( ")" ) ) { sulut -- ; } if ( sulut < 0 ) { return false ; } } if ( sulut == 0 ) { return true ; } return false ; }
va	6	static java . util . Date parseDate ( String formatted ) { if ( formatted == null || formatted . trim ( ) . equals ( "" ) ) { return null ; } try { DatatypeFactory factory = DatatypeFactory . newInstance ( ) ; XMLGregorianCalendar calendar = factory . newXMLGregorianCalendar ( formatted ) ; return calendar . toGregorianCalendar ( ) . getTime ( ) ; } catch ( Exception e ) { Matcher matcher = PATTERN_DD_MM_YYYY . matcher ( formatted ) ; if ( matcher . find ( ) ) { String yyyy = matcher . group ( 3 ) ; String mm = matcher . group ( 2 ) ; String dd = matcher . group ( 1 ) ; String hh = defaultIfEmpty ( matcher . group ( 4 ) , "0" ) ; String min = defaultIfEmpty ( matcher . group ( 5 ) , "0" ) ; String ss = defaultIfEmpty ( matcher . group ( 6 ) , "0" ) ; String ms = defaultIfEmpty ( matcher . group ( 7 ) , "0" ) ; return getDate ( Integer . parseInt ( yyyy ) , Integer . parseInt ( mm ) , Integer . parseInt ( dd ) , Integer . parseInt ( hh ) , Integer . parseInt ( min ) , Integer . parseInt ( ss ) , Integer . parseInt ( ms ) ) ; } else { Matcher matcher2 = PATTERN_YYYY_MM_DD . matcher ( formatted ) ; if ( matcher2 . find ( ) ) { String yyyy = matcher2 . group ( 1 ) ; String mm = defaultIfEmpty ( matcher2 . group ( 2 ) , "1" ) ; String dd = defaultIfEmpty ( matcher2 . group ( 3 ) , "1" ) ; String hh = defaultIfEmpty ( matcher2 . group ( 4 ) , "0" ) ; String min = defaultIfEmpty ( matcher2 . group ( 5 ) , "0" ) ; String ss = defaultIfEmpty ( matcher2 . group ( 6 ) , "0" ) ; String ms = defaultIfEmpty ( matcher2 . group ( 7 ) , "0" ) ; return getDate ( Integer . parseInt ( yyyy ) , Integer . parseInt ( mm ) , Integer . parseInt ( dd ) , Integer . parseInt ( hh ) , Integer . parseInt ( min ) , Integer . parseInt ( ss ) , Integer . parseInt ( ms ) ) ; } else { try { return new Date ( long . parseLong ( formatted ) ) ; } catch ( NumberFormatException ignore ) { return null ; } } } } }
va	0	public List < AuthorModel > getAuthorsByName ( String name ) throws WebshopAppException { return authorRepository . getAuthorsByName ( name ) ; }
va	2	public String selectDepartId ( String username ) { String str = "SELECT t.depart_id FROM `user` t where t.user_id='" + username + "'" ; String departId = "" ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet nu = pstmt . executeQuery ( str ) ; while ( nu . next ( ) ) { departId = nu . getString ( "depart_id" ) ; } dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return departId ; }
va	3	protected int extractGenreNumber ( String genreValue ) throws NumberFormatException { String value = genreValue . trim ( ) ; if ( value . length ( ) > 0 ) { if ( value . charAt ( 0 ) == ( ) { int pos = value . indexOf ( ) ) ; if ( pos > 0 ) { return Integer . parseInt ( value . substring ( 1 , pos ) ) ; } } } return Integer . parseInt ( value ) ; }
va	4	private void updateLasers ( ) { Iterator l = map . getLasers ( ) ; Laser laser ; Object player ; double x1 , y1 , x2 , y2 ; while ( l . hasNext ( ) ) { laser = ( Laser ) l . next ( ) ; player = laser . getParent ( ) ; if ( player instanceof Ship ) { x1 = ( float ) ( ( Ship ) player ) . getNose ( ) . noseX ; y1 = ( float ) ( ( Ship ) player ) . getNose ( ) . noseY ; double mouseX = inputManager . getMouseX ( ) ; double mouseY = inputManager . getMouseY ( ) ; x2 = ( ( Ship ) player ) . getX ( ) - ( screen . getWidth ( ) / 2 - mouseX ) + ( 32 ) ; y2 = ( ( Ship ) player ) . getY ( ) - ( screen . getHeight ( ) / 2 - mouseY ) + ( 32 ) ; double elapsedLaserTime = System . currentTimeMillis ( ) - laser . getLastUpdate ( ) ; double powerDiff = Laser . getPowerDifference ( laser , elapsedLaserTime ) ; double newTotalPower = ( ( Ship ) player ) . getTotalPower ( ) - powerDiff ; if ( newTotalPower < 3 ) newTotalPower = 3 ; ( ( Ship ) player ) . setTotalPower ( newTotalPower ) ; } else { Object target = ( ( Turret ) player ) . getTarget ( ) ; if ( target instanceof Ship ) { Ship s = ( Ship ) target ; x2 = s . getX ( ) + s . getWidth ( ) / 2 ; y2 = s . getY ( ) + s . getHeight ( ) / 2 ; } else { Sprite p = ( Sprite ) target ; x2 = p . getX ( ) + p . getWidth ( ) / 2 ; y2 = p . getY ( ) + p . getHeight ( ) / 2 ; } x1 = ( float ) ( ( Turret ) player ) . getX ( ) ; y1 = ( float ) ( ( Turret ) player ) . getY ( ) ; } laser . setLastUpdate ( System . currentTimeMillis ( ) ) ; laser . getLine ( ) . setLine ( x1 , y1 , x2 , y2 ) ; checkLaserCollisions ( laser ) ; } }
va	7	private void setQueryFactors ( ) { for ( int i = 0 ; i < queryFactors . length ; i ++ ) { for ( final Integer f : concernedClusters [ i ] ) { final boolean isFirstOrSmallerTable = queryFactors [ i ] == null || queryFactors [ i ] . getValues ( ) . length ( ) > nodePotentials [ f ] . getValues ( ) . length ( ) ; if ( isFirstOrSmallerTable ) { queryFactors [ i ] = nodePotentials [ f ] ; } } } queryFactorReverseMapping = new int [ nodePotentials . length ] [ ] ; for ( int i = 0 ; i < nodePotentials . length ; i ++ ) { List < Integer > queryVars = new ArrayList < Integer > ( ) ; for ( int var : nodePotentials [ i ] . getDimensionIDs ( ) ) { if ( queryFactors [ var ] == nodePotentials [ i ] ) { queryVars . add ( var ) ; } } queryFactorReverseMapping [ i ] = ArrayUtils . toIntArray ( queryVars ) ; } }
va	2	private void setColPixel ( int nr ) { Statistics . startLog ( SET_COL_PIXEL_STRING ) ; int pixelPerColLine = m_iPixelPerColLine ; int pos = pixelPerColLine * ( m_iMbRow << 3 ) + ( m_iMbCol << 3 ) ; int dctRecon [ ] = m_dctRecon ; int pel [ ] = ( nr == 4 ) ? m_PelBuffer [ m_akIdx ] [ 2 ] : m_PelBuffer [ m_akIdx ] [ 1 ] ; for ( int j = 0 ; j < 64 ; j += 8 ) { pel [ pos ] = dctRecon [ j ] ; pel [ pos + 1 ] = dctRecon [ j + 1 ] ; pel [ pos + 2 ] = dctRecon [ j + 2 ] ; pel [ pos + 3 ] = dctRecon [ j + 3 ] ; pel [ pos + 4 ] = dctRecon [ j + 4 ] ; pel [ pos + 5 ] = dctRecon [ j + 5 ] ; pel [ pos + 6 ] = dctRecon [ j + 6 ] ; pel [ pos + 7 ] = dctRecon [ j + 7 ] ; pos += pixelPerColLine ; } Statistics . endLog ( SET_COL_PIXEL_STRING ) ; }
va	8	private void pivot ( int p , int q ) { for ( int i = 0 ; i < N ; i ++ ) { double alpha = a [ i ] [ q ] / a [ p ] [ q ] ; for ( int j = 0 ; j <= N + N ; j ++ ) { if ( i != p && j != q ) a [ i ] [ j ] -= alpha * a [ p ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) if ( i != p ) a [ i ] [ q ] = 0.0 ; for ( int j = 0 ; j <= N + N ; j ++ ) if ( j != q ) a [ p ] [ j ] /= a [ p ] [ q ] ; a [ p ] [ q ] = 1.0 ; }
va	2	private int countCategories ( ) { try ( Connection conn = DevDBConfig . getConnection ( ) ) { try ( Statement stmt = conn . createStatement ( ) ) { String sql = "SELECT COUNT(*) FROM categories" ; try ( ResultSet rs = stmt . executeQuery ( sql ) ) { if ( rs . next ( ) ) { return rs . getInt ( 1 ) ; } } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return 0 ; }
va	1	public void processEvent ( AWTEvent e ) { if ( e . getID ( ) == Event . WINDOW_DESTROY ) { dispose ( ) ; } else { super . processEvent ( e ) ; } }
va	1	public void set_location_type ( String in ) { try { _location_type = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
va	9	public static Type fromChar ( char c , Step previousStep ) { switch ( c ) { case 1 : return REGULAR ; case 2 : return FREEZE_START ; case 3 : if ( previousStep != null && previousStep . getType ( ) == HOLDING || previousStep . getType ( ) == FREEZE_START ) { return FREEZE_END ; } return ROLL_END ; case 4 : return ROLL_START ; case M : return MINE ; case L : return LIFT ; case F : return FAKE ; default : if ( previousStep != null ) { switch ( previousStep . getType ( ) ) { case FREEZE_START : case HOLDING : return HOLDING ; case ROLL_START : case ROLLING : return ROLLING ; default : return NONE ; } } else { return NONE ; } } }
va	6	private static int subString ( String n , String h ) { if ( n == null || h == null ) { return - 1 ; } char [ ] needle = n . toCharArray ( ) ; char [ ] haystack = h . toCharArray ( ) ; for ( int i = 0 ; i < haystack . length ; i ++ ) { int j = 0 ; for ( j = 0 ; j < needle . length ; j ++ ) { if ( needle [ j ] != haystack [ i + j ] ) { break ; } } if ( j == needle . length ) { return i ; } } return - 1 ; }
va	5	private void backtrack ( List < Word > words , Map < Character , Character > decryptDict , Map < Character , Character > encryptDict , int wordIndex ) { if ( wordIndex >= words . size ( ) ) { processSolution ( decryptDict ) ; return ; } Map < Character , Character > l2lDecrypt = new HashMap < Character , Character > ( decryptDict ) ; Word word = words . get ( wordIndex ) ; String origText = word . getText ( ) ; StringBuilder text = new StringBuilder ( ) ; for ( int i = 0 ; i < origText . length ( ) ; ++ i ) { text . append ( decryptDict . get ( origText . charAt ( i ) ) ) ; } word . setTextWithoutParsing ( text . toString ( ) ) ; List < Word > candidates = getCandidates ( word , encryptDict ) ; word . setTextWithoutParsing ( origText ) ; for ( Word candidate : candidates ) { String cndText = candidate . getText ( ) ; Map < Character , Character > l2lEncrypt = new HashMap < Character , Character > ( encryptDict ) ; for ( int i = 0 ; i < origText . length ( ) ; i ++ ) { l2lDecrypt . put ( origText . charAt ( i ) , cndText . charAt ( i ) ) ; l2lEncrypt . put ( cndText . charAt ( i ) , origText . charAt ( i ) ) ; } backtrack ( words , l2lDecrypt , l2lEncrypt , wordIndex + 1 ) ; if ( backtrackFinished ) { return ; } } }
va	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Chan chan = ( Chan ) o ; if ( name != null ? ! name . equals ( chan . name ) : chan . name != null ) return false ; return true ; }
va	1	private void moveToTarget ( GameCharacter mob ) { if ( mob . getPosition ( ) . distanceTo ( target . getPosition ( ) ) > operationalRange ) return ; path = new PathFinder ( target . getPosition ( ) , operationalRange , target . getPositionOnMap ( ) . getMap ( ) ) ; mob . move ( path . findNextMove ( mob . getPosition ( ) ) ) ; }
va	4	public LargeNumber ( String value ) { if ( value == null ) throw new IllegalArgumentException ( ) ; try { new BigInteger ( value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( value ) ; } value = StringReverse . reverse ( value ) ; for ( int i = 0 ; i < value . length ( ) ; i += SmallNumber . LENGTH ) { int j = i + SmallNumber . LENGTH ; if ( j > value . length ( ) ) { j = value . length ( ) ; } String digitStr = value . substring ( i , j ) ; digits . add ( new SmallNumber ( StringReverse . reverse ( digitStr ) ) ) ; } }
va	1	@ Override public void onMouseWheelMoved ( MouseWheelEvent e ) { int rotation = e . getWheelRotation ( ) ; if ( rotation < 0 ) { viewport . zoomIn ( - rotation * ZOOM_FACTOR ) ; } else { viewport . zoomOut ( rotation * ZOOM_FACTOR ) ; } }
va	7	private Object canonicalize ( Object input ) throws JSONException { if ( input instanceof JSONArray ) { JSONArray array = ( JSONArray ) input ; List < Object > result = new ArrayList < Object > ( ) ; for ( int i = 0 ; i < array . length ( ) ; i ++ ) { result . add ( canonicalize ( array . opt ( i ) ) ) ; } return result ; } else if ( input instanceof JSONObject ) { JSONObject object = ( JSONObject ) input ; Map < String , Object > result = new HashMap < String , Object > ( ) ; for ( Iterator < ? > i = object . keys ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; result . put ( key , canonicalize ( object . get ( key ) ) ) ; } return result ; } else if ( input == null || input . equals ( JSONObject . null ) ) { return JSONObject . null ; } else { return input ; } }
va	2	public static void main ( String [ ] args ) { int [ ] array = { 1 , 2 , 3 , 4 , 5 } ; System . out . println ( "Effects of passing reference to entire array:\n" + "The values of the original array are:" ) ; for ( int value : array ) System . out . printf ( " %d" , value ) ; modifyArray ( array ) ; System . out . println ( "\n\nThe values of the modified array are:" ) ; for ( int value : array ) System . out . printf ( " %d" , value ) ; System . out . printf ( "\n\nEffects of passing array element value:\n" + "array[3] before modifyElement: %d\n" , array [ 3 ] ) ; modifyElement ( array [ 3 ] ) ; System . out . printf ( "array[3] after modifyElement: %d\n" , array [ 3 ] ) ; }
va	4	private String buildCommand ( ) { StringBuffer cmd = new StringBuffer ( ) ; cmd . append ( PREDEFINED_CMD ) ; if ( getFixFor ( ) != null ) { cmd . append ( String . format ( "fixfor:%s" , getFixFor ( ) ) ) ; } if ( getProject ( ) != null ) { cmd . append ( String . format ( " AND project:%s" , getProject ( ) ) ) ; } if ( getArea ( ) != null ) { cmd . append ( String . format ( " AND area:%s" , getArea ( ) ) ) ; } if ( getCols ( ) != null ) { cmd . append ( String . format ( "&cols=%s" , getCols ( ) ) ) ; } return cmd . toString ( ) ; }
va	0	@ Test public void testEncode ( ) { short value = ( short ) 127 ; byte [ ] data = datatype . encode ( value ) ; assertTrue ( data . length == 1 ) ; assertTrue ( data [ 0 ] == 127 ) ; value ++ ; data = datatype . encode ( value ) ; assertTrue ( data . length == 1 ) ; assertTrue ( data [ 0 ] == - 128 ) ; value = - 128 ; data = datatype . encode ( value ) ; assertTrue ( data . length == 1 ) ; assertTrue ( data [ 0 ] == - 128 ) ; value -- ; data = datatype . encode ( value ) ; assertTrue ( data . length == 1 ) ; assertTrue ( data [ 0 ] == 127 ) ; }
va	8	private static int decode4to3 ( byte [ ] source , int srcOffset , byte [ ] destination , int destOffset , int options ) { if ( source == null ) { throw new NullPointerException ( "Source array was null." ) ; } if ( destination == null ) { throw new NullPointerException ( "Destination array was null." ) ; } if ( srcOffset < 0 || srcOffset + 3 >= source . length ) { throw new IllegalArgumentException ( String . format ( "Source array with length %d cannot have offset of %d and still process four bytes." , source . length , srcOffset ) ) ; } if ( destOffset < 0 || destOffset + 2 >= destination . length ) { throw new IllegalArgumentException ( String . format ( "Destination array with length %d cannot have offset of %d and still store three bytes." , destination . length , destOffset ) ) ; } byte [ ] DECODABET = getDecodabet ( options ) ; if ( source [ srcOffset + 2 ] == EQUALS_SIGN ) { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & FF ) << 18 ) | ( ( DECODABET [ source [ srcOffset + 1 ] ] & FF ) << 12 ) ; destination [ destOffset ] = ( byte ) ( outBuff >>> 16 ) ; return 1 ; } else if ( source [ srcOffset + 3 ] == EQUALS_SIGN ) { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & FF ) << 18 ) | ( ( DECODABET [ source [ srcOffset + 1 ] ] & FF ) << 12 ) | ( ( DECODABET [ source [ srcOffset + 2 ] ] & FF ) << 6 ) ; destination [ destOffset ] = ( byte ) ( outBuff >>> 16 ) ; destination [ destOffset + 1 ] = ( byte ) ( outBuff >>> 8 ) ; return 2 ; } else { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & FF ) << 18 ) | ( ( DECODABET [ source [ srcOffset + 1 ] ] & FF ) << 12 ) | ( ( DECODABET [ source [ srcOffset + 2 ] ] & FF ) << 6 ) | ( ( DECODABET [ source [ srcOffset + 3 ] ] & FF ) ) ; destination [ destOffset ] = ( byte ) ( outBuff >> 16 ) ; destination [ destOffset + 1 ] = ( byte ) ( outBuff >> 8 ) ; destination [ destOffset + 2 ] = ( byte ) ( outBuff ) ; return 3 ; } }
va	9	private boolean areSiblingsSelected ( TreePath path ) { TreePath parent = path . getParentPath ( ) ; if ( parent == null ) { return true ; } Object node = path . getLastPathComponent ( ) ; Object parentNode = parent . getLastPathComponent ( ) ; int childCount = model . getChildCount ( parentNode ) ; boolean isParameters = false ; boolean isDescription = false ; for ( int i = 0 ; i < childCount ; i ++ ) { Object childNode = model . getChild ( parentNode , i ) ; if ( childNode == node ) { continue ; } if ( childCount == 2 ) { if ( childNode . toString ( ) . equals ( "parameters" ) && model . isLeaf ( childNode ) ) { isParameters = true ; } if ( childNode . toString ( ) . equals ( "description" ) && model . isLeaf ( childNode ) ) { isDescription = true ; } } if ( ! isPathSelected ( parent . pathByAddingChild ( childNode ) ) && ! isParameters && ! isDescription ) { return false ; } } return true ; }
va	3	private void doLogin ( ) { final String user = username . getText ( ) ; String pass = new String ( passwordField . getPassword ( ) ) ; try { client . sendLoginMessage ( user , pass ) ; } catch ( JMSException e1 ) { e1 . printStackTrace ( ) ; } ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof LoginMessage ) ) return ; LoginMessage lm = ( LoginMessage ) m ; if ( lm . getLoginStatus ( ) ) { System . out . println ( "Login Successful! Joining main lobby..." ) ; clientName = user ; GUI gui = new GUI ( client ) ; gui . setClientName ( clientName ) ; gui . setVisible ( true ) ; dispose ( ) ; } else { JOptionPane . showMessageDialog ( null , "Login failed! Wrong username/password or user already logged in." ) ; username . setText ( "" ) ; passwordField . setText ( "" ) ; username . requestFocus ( ) ; } } } ) ; }
va	2	public VizRPL ( final String path , final int delay , final String propertyFile ) { super ( "tinyRPL Vizualizer" ) ; VizProperties . getInstance ( ) . setPath ( propertyFile ) ; try { VizProperties . getInstance ( ) . load ( ) ; } catch ( Exception ex ) { System . err . println ( "Could not read property file" ) ; } final int [ ] pixels = new int [ 16 * 16 ] ; final Image image = Toolkit . getDefaultToolkit ( ) . createImage ( new MemoryImageSource ( 16 , 16 , pixels , 0 , 16 ) ) ; final Cursor transparentCursor = Toolkit . getDefaultToolkit ( ) . createCustomCursor ( image , new Point ( 0 , 0 ) , "invisibleCursor" ) ; setCursor ( transparentCursor ) ; final Dimension dim = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; setUndecorated ( true ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setSize ( dim . width , dim . height ) ; setVisible ( true ) ; getContentPane ( ) . setBackground ( Color . black ) ; final VizPanel panel = new VizPanel ( getWidth ( ) , getHeight ( ) ) ; panel . init ( ) ; this . add ( panel ) ; try { final LogObserver lproc = new LogObserver ( path , delay ) ; lproc . addObserver ( new InitVizParser ( panel ) ) ; lproc . addObserver ( new TimestampParser ( panel ) ) ; lproc . addObserver ( new DataPacketParser ( panel ) ) ; lproc . addObserver ( new DIOPacketParser ( panel ) ) ; lproc . addObserver ( new DISPacketParser ( panel ) ) ; lproc . addObserver ( new DAOPacketParser ( panel ) ) ; final Thread thr = new Thread ( lproc ) ; thr . start ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
va	3	public JSONObject ( Map map ) { this . map = new HashMap ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; Object value = e . getValue ( ) ; if ( value != null ) { this . map . put ( e . getKey ( ) , wrap ( value ) ) ; } } } }
va	3	@ Override public String getInfo ( ) { String ret = "Name: " + getPart ( ) . name ( ) + "(0x" + String . format ( "%02X" , getPart ( ) . getValue ( ) ) + ")" + "\n Length: " + getLength ( ) + ":0x" + String . format ( "%04X" , getLength ( ) ) + "\n Table ID: " + id + "\n Table Class: " ; if ( 0 == tableClass ) { ret += "DC table" ; } else { ret += "AC table" ; } ret += "\n length count pairs \n" ; for ( int i = 0 ; i < table . getLengths ( ) . length ; i ++ ) { ret += " " + ( i + 1 ) + ":" + table . getLengths ( ) [ i ] ; } ret += "\n Symbol:Huffman Values:\n" ; for ( int i = 0 ; i < table . getValues ( ) . length ; i ++ ) { ret += " 0x" + String . format ( "%02X" , ( table . getValues ( ) [ i ] & FF ) ) ; } return ret ; }
va	7	String toString ( int indentFactor , int indent ) throws JSONException { int i ; int length = this . length ( ) ; if ( length == 0 ) { return "{}" ; } Iterator keys = this . keys ( ) ; int newindent = indent + indentFactor ; Object object ; StringBuffer sb = new StringBuffer ( "{" ) ; if ( length == 1 ) { object = keys . next ( ) ; sb . append ( quote ( object . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( object ) , indentFactor , indent ) ) ; } else { while ( keys . hasNext ( ) ) { object = keys . next ( ) ; if ( sb . length ( ) > 1 ) { sb . append ( " \n" ) ; } else { sb . append ( '' ) ; } for ( i = 0 ; i < newindent ; i += 1 ) { sb . append (   ) ; } sb . append ( quote ( object . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( object ) , indentFactor , newindent ) ) ; } if ( sb . length ( ) > 1 ) { sb . append ( '' ) ; for ( i = 0 ; i < indent ; i += 1 ) { sb . append (   ) ; } } } sb . append ( } ) ; return sb . toString ( ) ; }
va	4	@ Override public void addColumn ( final Object columnName , final Vector columnData ) { if ( columnName == null ) { throw new IllegalArgumentException ( "addColumn() - null parameter" ) ; } columnIdentifiers . addElement ( columnName ) ; int index = 0 ; final Enumeration enumeration = dataVector . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { Object value ; if ( ( columnData != null ) && ( index < columnData . size ( ) ) ) { value = columnData . elementAt ( index ) ; } else { value = null ; } ( ( Vector ) enumeration . nextElement ( ) ) . addElement ( value ) ; index ++ ; } cellAtt . addColumn ( ) ; fireTableStructureChanged ( ) ; }
va	7	@ Override public void call ( JITContext c ) throws IOException { for ( Node n : block . - ) { switch ( n . type ) { case LOOP : BlockNode bn = ( BlockNode ) n ; JITBlock block = new InterpretedJITBlock ( bn ) ; block . call ( c ) ; break ; case VALUE : ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) c . mem [ c . ptr ] = ( byte ) cn . change ; else c . mem [ c . ptr ] += cn . change ; break ; case POINTER : cn = ( ChangeNode ) n ; c . ptr += cn . change ; break ; case INPUT : c . mem [ c . ptr ] = ( byte ) System . in . read ( ) ; break ; case OUTPUT : System . out . write ( c . mem [ c . ptr ] ) ; break ; default : throw new RuntimeException ( "unexpected node type: " + n . type ) ; } } }
va	2	public boolean teclaPresionada ( ) { for ( EstadoTecla estado : teclas . values ( ) ) { if ( estado == EstadoTecla . PRESIONADA ) return true ; } return false ; }
va	2	public ArrayList < QuizResult > retrieveTodaysQuizResults ( int quizID ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet rs = connection . performQuery ( "SELECT * FROM quiz_results WHERE quizID=" + quizID + " AND date_taken >= DATE(NOW()) order by date_taken desc" ) ; ArrayList < QuizResult > results ; try { results = new ArrayList < QuizResult > ( ) ; while ( rs . next ( ) ) { int userID = rs . getInt ( "userID" ) ; int score = rs . getInt ( "score" ) ; Date taken = rs . getDate ( "date_taken" ) ; int completionTime = rs . getInt ( "completion_time" ) ; results . add ( new QuizResult ( quizID , userID , score , completionTime , taken ) ) ; } Collections . sort ( results , new ScoreComparator ( ) ) ; return results ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }
va	4	private static void method493 ( Stream stream , char ac [ ] [ ] , byte abyte0 [ ] [ ] [ ] ) { for ( int j = 0 ; j < ac . length ; j ++ ) { char ac1 [ ] = new char [ stream . readUnsignedByte ( ) ] ; for ( int k = 0 ; k < ac1 . length ; k ++ ) ac1 [ k ] = ( char ) stream . readUnsignedByte ( ) ; ac [ j ] = ac1 ; byte abyte1 [ ] [ ] = new byte [ stream . readUnsignedByte ( ) ] [ 2 ] ; for ( int l = 0 ; l < abyte1 . length ; l ++ ) { abyte1 [ l ] [ 0 ] = ( byte ) stream . readUnsignedByte ( ) ; abyte1 [ l ] [ 1 ] = ( byte ) stream . readUnsignedByte ( ) ; } if ( abyte1 . length > 0 ) abyte0 [ j ] = abyte1 ; } }
va	2	public static < K , V > Map . Entry < K , V > soloEntry ( Map < K , V > m ) { if ( ( m != null ) && m . size ( ) == 1 ) { return m . entrySet ( ) . iterator ( ) . next ( ) ; } throw new IllegalArgumentException ( String . format ( "expected a map of one entry  got %s" , m ) ) ; }
va	9	private void renderNPCs ( boolean flag ) { for ( int n = 0 ; n < npcCount ; n ++ ) { NPC npc = npcs [ npcIds [ n ] ] ; int hash = 20000000 + ( npcIds [ n ] << 14 ) ; if ( npc == null || ! npc . isVisible ( ) || npc . npcDefinition . visible != flag ) continue ; int npcWidth = npc . x >> 7 ; int npcHeight = npc . y >> 7 ; if ( npcWidth < 0 || npcWidth >= 104 || npcHeight < 0 || npcHeight >= 104 ) continue ; if ( npc . boundaryDimension == 1 && ( npc . x & 7f ) == 64 && ( npc . y & 7f ) == 64 ) { if ( tileRenderCount [ npcWidth ] [ npcHeight ] == renderCount ) continue ; tileRenderCount [ npcWidth ] [ npcHeight ] = renderCount ; } if ( ! npc . npcDefinition . clickable ) hash += 80000000 ; worldController . addEntityA ( plane , npc . x , npc . y , getFloorDrawHeight ( plane , npc . y , npc . x ) , npc . currentRotation , npc , hash , ( npc . boundaryDimension - 1 ) * 64 + 60 , npc . dynamic ) ; } }
va	5	public List < String > getStockpileList ( ) { List < String > stockPiles = new ArrayList < String > ( ) ; try { Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "li" ) ) ; stockPiles . add ( "" ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . hasAttributes ( ) ) { if ( e . getAttributeValue ( "Class" ) . equalsIgnoreCase ( "Zone_Stockpile" ) ) { stockPiles . add ( e . getChildText ( "zoneName" ) ) ; } } } return stockPiles ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } return stockPiles ; }
va	1	@ Test public void testtest ( ) { System . out . println ( "hellllooooo" ) ; ClassLoader cl = ClassLoader . getSystemClassLoader ( ) ; URL [ ] urls = ( ( URLClassLoader ) cl ) . getURLs ( ) ; for ( URL url : urls ) { System . out . println ( url . getFile ( ) ) ; } }
va	7	final public CreateTableCommand . AttributeDescriptor AttrDecl ( ) throws ParseException { String name ; Attribute . Type type ; int length = - 1 ; Exp constraint = null ; name = Identifier ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case KW_INT : jj_consume_token ( KW_INT ) ; type = Attribute . Type . int ; break ; case KW_CHAR : jj_consume_token ( KW_CHAR ) ; jj_consume_token ( 52 ) ; jj_consume_token ( INT_LITERAL ) ; length = Integer . parseInt ( token . image ) ; jj_consume_token ( 53 ) ; type = Attribute . Type . char ; break ; case KW_DECIMAL : jj_consume_token ( KW_DECIMAL ) ; type = Attribute . Type . DECIMAL ; break ; default : jj_la1 [ 9 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case KW_CHECK : jj_consume_token ( KW_CHECK ) ; jj_consume_token ( 52 ) ; constraint = Expression ( ) ; jj_consume_token ( 53 ) ; break ; default : jj_la1 [ 10 ] = jj_gen ; ; } { if ( true ) return new CreateTableCommand . AttributeDescriptor ( name , type , length , constraint ) ; } throw new Error ( "Missing return statement in function" ) ; }
va	4	public JSONObject toJSONObject ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 || length ( ) == 0 ) { return null ; } JSONObject jo = new JSONObject ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { jo . put ( names . getString ( i ) , this . opt ( i ) ) ; } return jo ; }
va	8	public void displayTree ( ) { Stack globalStack = new Stack ( ) ; globalStack . push ( root ) ; int nBlanks = 32 ; boolean isRowEmpty = false ; while ( isRowEmpty == false ) { Stack localStack = new Stack ( ) ; isRowEmpty = true ; for ( int j = 0 ; j < nBlanks ; j ++ ) { System . out . print ( " " ) ; } while ( globalStack . isEmpty ( ) == false ) { Node temp = ( Node ) globalStack . pop ( ) ; if ( temp != null ) { System . out . print ( temp . iData ) ; localStack . push ( temp . leftChild ) ; localStack . push ( temp . rightChild ) ; if ( temp . leftChild != null || temp . rightChild != null ) { isRowEmpty = false ; } } else { System . out . print ( "--" ) ; localStack . push ( null ) ; localStack . push ( null ) ; } for ( int j = 0 ; j < nBlanks * 2 - 2 ; j ++ ) { System . out . print ( " " ) ; } } System . out . println ( ) ; nBlanks /= 2 ; while ( localStack . isEmpty ( ) == false ) { globalStack . push ( localStack . pop ( ) ) ; } System . out . println ( "............................................................................." ) ; } }
va	8	@ Override public boolean isBuffered ( ) { if ( Constants . GCDEF . G0 . equals ( gcode ) || Constants . GCDEF . G1 . equals ( gcode ) || Constants . GCDEF . G2 . equals ( gcode ) || Constants . GCDEF . M106 . equals ( gcode ) || Constants . GCDEF . M107 . equals ( gcode ) || Constants . GCDEF . G30 . equals ( gcode ) || Constants . GCDEF . G31 . equals ( gcode ) || Constants . GCDEF . G32 . equals ( gcode ) ) { return true ; } return false ; }
va	6	public final long nextLong ( ) { int y ; int z ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } z = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; mti = 0 ; } z = mt [ mti ++ ] ; z ^= z >>> 11 ; z ^= ( z << 7 ) & TEMPERING_MASK_B ; z ^= ( z << 15 ) & TEMPERING_MASK_C ; z ^= ( z >>> 18 ) ; return ( ( ( long ) y ) << 32 ) + ( long ) z ; }
va	4	public void setValue ( int value ) throws CellContentException { if ( readOnly ) { throw new CellContentException ( this . toString ( ) + " is read only" ) ; } else if ( value > limit ) { throw new CellContentException ( "Value " + value + " larger than " + limit ) ; } else { for ( Constraint u : belongsTo ) { u . checkUpdate ( value ) ; } for ( Constraint u : belongsTo ) { u . update ( this . value , value ) ; } this . value = value ; } }
va	8	public LinkedList < DiffFile > diff ( int r1 , int r2 , String path ) throws IOException { if ( path . endsWith ( "\\" ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } LinkedList < DiffFile > ret = new LinkedList < > ( ) ; String cmd = "cmd.exe /c d: & cd \"" + folder + "\" & svn diff --summarize -r " + r1 + ":" + r2 + ( path != null ? ( " " + path ) : "" ) ; System . out . println ( "processing: " + cmd ) ; Process p = Runtime . getRuntime ( ) . exec ( cmd ) ; try { int i = p . waitFor ( ) ; System . out . println ( "process state: " + i ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; return null ; } BufferedReader reader = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { System . out . println ( ">> " + line ) ; String fileName = line . substring ( 8 ) ; String atts = line . substring ( 0 , 8 ) ; DiffFile . Status status = null ; if ( atts . contains ( "A" ) ) { status = DiffFile . Status . ADDED ; } else if ( atts . contains ( "D" ) ) { status = DiffFile . Status . DELETED ; } else if ( atts . contains ( "M" ) ) { status = DiffFile . Status . MODIFIED ; } if ( status != null ) { ret . addLast ( new DiffFile ( fileName , status ) ) ; System . out . println ( ret . getLast ( ) . toString ( ) ) ; } else { System . err . println ( "unknown status for file \"" + fileName + "\"" ) ; } line = reader . readLine ( ) ; } System . out . println ( "processing finished" ) ; return ret ; }
va	8	private void method393 ( int ai [ ] , byte abyte0 [ ] , int i , int j , int k , int l , int i1 , int j1 , int k1 ) { int l1 = - ( l >> 2 ) ; l = - ( l & 3 ) ; for ( int i2 = - i1 ; i2 < 0 ; i2 ++ ) { for ( int j2 = l1 ; j2 < 0 ; j2 ++ ) { if ( abyte0 [ j ++ ] != 0 ) ai [ k ++ ] = i ; else k ++ ; if ( abyte0 [ j ++ ] != 0 ) ai [ k ++ ] = i ; else k ++ ; if ( abyte0 [ j ++ ] != 0 ) ai [ k ++ ] = i ; else k ++ ; if ( abyte0 [ j ++ ] != 0 ) ai [ k ++ ] = i ; else k ++ ; } for ( int k2 = l ; k2 < 0 ; k2 ++ ) if ( abyte0 [ j ++ ] != 0 ) ai [ k ++ ] = i ; else k ++ ; k += j1 ; j += k1 ; } }
va	0	public Customer ( String firstname , String lastname , String login , String password , String email , Address address ) { this . firstname = firstname ; this . lastname = lastname ; this . login = login ; this . password = password ; this . dateOfBirth = new Date ( ) ; }
va	9	public void method469 ( ) { if ( anIntArray1655 != null ) { int ai [ ] = new int [ 256 ] ; int j = 0 ; for ( int l = 0 ; l < anInt1626 ; l ++ ) { int j1 = anIntArray1655 [ l ] ; ai [ j1 ] ++ ; if ( j1 > j ) j = j1 ; } anIntArrayArray1657 = new int [ j + 1 ] [ ] ; for ( int k1 = 0 ; k1 <= j ; k1 ++ ) { anIntArrayArray1657 [ k1 ] = new int [ ai [ k1 ] ] ; ai [ k1 ] = 0 ; } for ( int j2 = 0 ; j2 < anInt1626 ; j2 ++ ) { int l2 = anIntArray1655 [ j2 ] ; anIntArrayArray1657 [ l2 ] [ ai [ l2 ] ++ ] = j2 ; } anIntArray1655 = null ; } if ( anIntArray1656 != null ) { int ai1 [ ] = new int [ 256 ] ; int k = 0 ; for ( int i1 = 0 ; i1 < anInt1630 ; i1 ++ ) { int l1 = anIntArray1656 [ i1 ] ; ai1 [ l1 ] ++ ; if ( l1 > k ) k = l1 ; } anIntArrayArray1658 = new int [ k + 1 ] [ ] ; for ( int i2 = 0 ; i2 <= k ; i2 ++ ) { anIntArrayArray1658 [ i2 ] = new int [ ai1 [ i2 ] ] ; ai1 [ i2 ] = 0 ; } for ( int k2 = 0 ; k2 < anInt1630 ; k2 ++ ) { int i3 = anIntArray1656 [ k2 ] ; anIntArrayArray1658 [ i3 ] [ ai1 [ i3 ] ++ ] = k2 ; } anIntArray1656 = null ; } }
va	5	private void chooseAGunMenu ( ) { for ( int i = PresidentialRescue . KEY_1 ; i <= PresidentialRescue . KEY_5 ; i ++ ) { int newBulletId = i - 48 ; if ( e . getKey ( i ) && ( ( e . cheatsEnabled ) || ( e . stage ) / 2 + 1 >= newBulletId ) ) { if ( bulletId == newBulletId ) break ; setGun ( i - 48 ) ; } } }
va	2	public static synchronized JPanel getInstance ( ) { if ( groupTable == null ) { createTable ( ) ; } if ( groupPanel == null ) { createPanel ( ) ; } return groupPanel ; }
va	5	private void processWrite ( SelectionKey key ) throws IOException { WritableByteChannel ch = ( WritableByteChannel ) key . channel ( ) ; synchronized ( writeBuf ) { writeBuf . flip ( ) ; int bytesOp = 0 , bytesTotal = 0 ; while ( writeBuf . hasRemaining ( ) && ( bytesOp = ch . write ( writeBuf ) ) > 0 ) bytesTotal += bytesOp ; bytesOut . addAndGet ( bytesTotal ) ; bytesSent . addAndGet ( bytesTotal ) ; if ( writeBuf . remaining ( ) == 0 ) { key . interestOps ( key . interestOps ( ) ^ SelectionKey . OP_WRITE ) ; } if ( bytesTotal > 0 ) writeBuf . notify ( ) ; else if ( bytesOp == - 1 ) { log . info ( "peer closed write channel" ) ; ch . close ( ) ; } writeBuf . compact ( ) ; } }
va	7	private static void convexHull ( Punto [ ] puntos , int n ) { int ymin = puntos [ 0 ] . y , min = 0 ; for ( int i = 1 ; i < puntos . length ; i ++ ) { int y = puntos [ i ] . y ; if ( y < ymin || ( ymin == y && puntos [ i ] . x < puntos [ min ] . x ) ) { ymin = puntos [ i ] . y ; min = i ; } } swap ( puntos [ 0 ] , puntos [ min ] ) ; p0 = puntos [ 0 ] ; Comp c = new Comp ( ) ; Arrays . sort ( puntos , c ) ; Deque < Punto > stack = new ArrayDeque < Punto > ( ) ; stack . push ( puntos [ 0 ] ) ; stack . push ( puntos [ 1 ] ) ; stack . push ( puntos [ 2 ] ) ; for ( int i = 3 ; i < n ; i ++ ) { while ( orientation ( nextToTop ( stack ) , stack . peek ( ) , puntos [ i ] ) != 2 ) { stack . pop ( ) ; } stack . push ( puntos [ i ] ) ; } while ( ! stack . isEmpty ( ) ) { System . out . println ( stack . peek ( ) . x + " " + stack . peek ( ) . y ) ; stack . pop ( ) ; } }
va	0	public ImageProcessingDialog ( ImageProcessingMainForm parentFrame , String [ ] selectedString ) { initComponents ( ) ; setLocationRelativeTo ( parentFrame ) ; setResizable ( false ) ; this . parentFrame = parentFrame ; this . selectedString = selectedString ; setTextFields ( ) ; }
va	3	public double [ ] Z ( double [ ] [ ] M , double [ ] xM ) { int m1rows = M . length ; int m1cols = M [ 0 ] . length ; double [ ] result = new double [ m1rows ] ; for ( int i = 0 ; i < m1rows ; i ++ ) { double _min = 2 ; for ( int k = 0 ; k < m1cols ; k ++ ) { double b = ( double ) Beta ( M [ i ] [ k ] . intValue ( ) , xM [ k ] . intValue ( ) ) ; _min = b < _min ? b : _min ; } result [ i ] = _min ; } return result ; }
va	1	public JComboBox getCmbResolutionOptions ( ) { if ( cmbResolutionOptions == null ) { cmbResolutionOptions = new JComboBox ( ) ; cmbResolutionOptions . setModel ( new DefaultComboBoxModel ( new String [ ] { Messages . getString ( "GeoLogMain.options.QRZ" ) , Messages . getString ( "GeoLogMain.options.HAMQTH" ) , Messages . getString ( "GeoLogMain.options.FIELD" ) , Messages . getString ( "GeoLogMain.options.CACHE" ) } ) ) ; cmbResolutionOptions . setBounds ( new Rectangle ( 170 , 206 , 218 , 27 ) ) ; cmbResolutionOptions . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; } return cmbResolutionOptions ; }
va	8	public static String getConstraintString ( AC ac , boolean asAPI , boolean isCols ) { StringBuffer sb = new StringBuffer ( 32 ) ; DimConstraint [ ] dims = ac . getConstaints ( ) ; BoundSize defGap = isCols ? PlatformDefaults . getGridGapX ( ) : PlatformDefaults . getGridGapY ( ) ; for ( int i = 0 ; i < dims . length ; i ++ ) { DimConstraint dc = dims [ i ] ; addRowDimConstraintString ( dc , sb , asAPI ) ; if ( i < dims . length - 1 ) { BoundSize gap = dc . getGapAfter ( ) ; if ( gap == defGap || gap == null ) gap = dims [ i + 1 ] . getGapBefore ( ) ; if ( gap != null ) { String gapStr = getBS ( gap ) ; if ( asAPI ) { sb . append ( ".gap(\"" ) . append ( gapStr ) . append ( "\")" ) ; } else { sb . append ( gapStr ) ; } } else { if ( asAPI ) sb . append ( ".gap()" ) ; } } } return sb . toString ( ) ; }
va	7	public static void main ( String [ ] args ) { int portNum ; if ( args . length < 1 ) { System . out . println ( "Using default port:9371" ) ; portNum = 9371 ; } else { System . out . println ( "Configuring to use port: " + args [ 0 ] ) ; portNum = Integer . parseInt ( args [ 0 ] ) ; } if ( args . length < 2 ) { System . out . println ( "Using default Test database connection" ) ; DatabaseSubsystem . configurationTestDBAccess ( ) ; } else if ( args [ 1 ] . equals ( "-p" ) ) { System . out . println ( "Using specified Production database connection" ) ; DatabaseSubsystem . configurationProductionDBAccess ( ) ; } else { System . out . println ( "Using default Test database connection" ) ; DatabaseSubsystem . configurationTestDBAccess ( ) ; } if ( ! Message . configure ( getMessageXSD ( ) ) ) { System . exit ( 0 ) ; } if ( ! DatabaseSubsystem . connect ( ) ) { System . out . println ( "Error  cannot connect to the database" ) ; System . exit ( 0 ) ; } Server server = new Server ( new DefaultProtocolHandler ( ) , portNum ) ; try { server . bind ( ) ; } catch ( IOException ioe ) { System . err . println ( "Unable to launch server:" + ioe . getMessage ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( "Server awaiting client connections" ) ; try { server . process ( ) ; System . out . println ( "Server shutting down." ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } }
va	6	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
va	3	public ChampionList ( FilterListModel listModel , CustomCellRenderer cellRenderer ) { setModel ( listModel ) ; setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; setLayoutOrientation ( JList . HORIZONTAL_WRAP ) ; setVisibleRowCount ( - 1 ) ; setBackground ( Color . BLACK ) ; setCellRenderer ( cellRenderer ) ; Champion firstEntry = Initialiser . getChampionList ( ) . first ( ) ; if ( firstEntry != null ) setPrototypeCellValue ( firstEntry ) ; for ( MouseListener m : getMouseListeners ( ) ) { removeMouseListener ( m ) ; } for ( MouseMotionListener m : getMouseMotionListeners ( ) ) { removeMouseMotionListener ( m ) ; } addMouseListener ( mouseListener ) ; addMouseMotionListener ( mouseListener ) ; }
va	5	void init ( int n ) { bitrev = new int [ n / 4 ] ; trig = new float [ n + n / 4 ] ; int n2 = n >>> 1 ; log2n = ( int ) Math . rint ( Math . log ( n ) / Math . log ( 2 ) ) ; this . n = n ; int AE = 0 ; int AO = 1 ; int BE = AE + n / 2 ; int BO = BE + 1 ; int CE = BE + n / 2 ; int CO = CE + 1 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { trig [ AE + i * 2 ] = ( float ) Math . cos ( ( Math . PI / n ) * ( 4 * i ) ) ; trig [ AO + i * 2 ] = ( float ) - Math . sin ( ( Math . PI / n ) * ( 4 * i ) ) ; trig [ BE + i * 2 ] = ( float ) Math . cos ( ( Math . PI / ( 2 * n ) ) * ( 2 * i + 1 ) ) ; trig [ BO + i * 2 ] = ( float ) Math . sin ( ( Math . PI / ( 2 * n ) ) * ( 2 * i + 1 ) ) ; } for ( int i = 0 ; i < n / 8 ; i ++ ) { trig [ CE + i * 2 ] = ( float ) Math . cos ( ( Math . PI / n ) * ( 4 * i + 2 ) ) ; trig [ CO + i * 2 ] = ( float ) - Math . sin ( ( Math . PI / n ) * ( 4 * i + 2 ) ) ; } { int mask = ( 1 << ( log2n - 1 ) ) - 1 ; int msb = 1 << ( log2n - 2 ) ; for ( int i = 0 ; i < n / 8 ; i ++ ) { int acc = 0 ; for ( int j = 0 ; msb >>> j != 0 ; j ++ ) if ( ( ( msb >>> j ) & i ) != 0 ) acc |= 1 << j ; bitrev [ i * 2 ] = ( ( ~ acc ) & mask ) ; bitrev [ i * 2 + 1 ] = acc ; } } scale = 4.f / n ; }
va	2	public static void doGameInfo ( final Context context ) { if ( ! Util . getGameEName ( context ) . equals ( "gc" ) ) { Util . ShowTips ( context , "\u5DF2\u521D\u59CB\u5316" ) ; return ; } Handler handler = new Handler ( ) { @ Override public void handleMessage ( Message msg ) { if ( msg . what == NetConfig . TAG_CALLBACK_SUCCESS ) { GameInfo gameInfo = ( GameInfo ) msg . obj ; Util . saveGameEName ( context , gameInfo . getGame_ename ( ) ) ; Util . ShowTips ( context , "\u521D\u59CB\u5316\u6210\u529F" ) ; } else { Util . ShowTips ( context , "\u521D\u59CB\u5316\u5931\u8D25" ) ; } } } ; NetConnectService . doGameInfo ( context , handler ) ; }
va	1	private void playPlaceSound ( ) { if ( isMute ) { return ; } placeSound . setFramePosition ( 0 ) ; placeSound . start ( ) ; }
va	4	private int GetBlockLenth ( String BlockText ) { int nBlockLineCount = 0 ; try { if ( ( "" == BlockText ) || ( null == BlockText ) ) { return 0 ; } BufferedReader br = new BufferedReader ( new StringReader ( BlockText ) ) ; while ( br . readLine ( ) != null ) { nBlockLineCount ++ ; } return nBlockLineCount ; } catch ( IOException e ) { e . printStackTrace ( ) ; return 0 ; } }
va	2	public void addShip ( Ship ship ) { if ( balance >= ship . getShipType ( ) . getCost ( ) ) { shipsList . add ( ship ) ; incrementBalance ( - ship . getShipType ( ) . getCost ( ) ) ; grossValue += ship . getShipType ( ) . getCost ( ) * 0.8f ; for ( Map . Entry < Planet , PlanetStatistics > entry : getCurrentStats ( ) . getPlanetStatsMap ( ) . entrySet ( ) ) entry . getValue ( ) . getShipsMap ( ) . put ( ship , new float [ ] { 0f , 0f } ) ; } }
va	8	protected boolean sharedCorner ( final int x , final int y , final char c ) { if ( validSpot ( x + 1 , y + 1 ) && ( c == map [ x + 1 ] [ y + 1 ] ) ) return true ; if ( validSpot ( x + 1 , y - 1 ) && ( c == map [ x + 1 ] [ y - 1 ] ) ) return true ; if ( validSpot ( x - 1 , y + 1 ) && ( c == map [ x - 1 ] [ y + 1 ] ) ) return true ; if ( validSpot ( x - 1 , y - 1 ) && ( c == map [ x - 1 ] [ y - 1 ] ) ) return true ; return false ; }
va	2	public void restoreTo ( int pointIndex ) { if ( pointIndex >= 0 && pointIndex < historyPoints . size ( ) ) { currentPoint = pointIndex ; obj . restore ( historyPoints . get ( currentPoint ) ) ; } }
va	9	@ Override public synchronized void initFromFile ( ) { if ( ! fileVoli . exists ( ) ) { try { fileVoli . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( ! fileIdVoli . exists ( ) ) { try { fileIdVoli . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { voliIn = new FileInputStream ( fileVoli ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } try { ObjectInputStream objInputStream = new ObjectInputStream ( voliIn ) ; listaVoli = ( ArrayList < Volo > ) objInputStream . readObject ( ) ; objInputStream . close ( ) ; } catch ( EOFException e ) { System . out . println ( "file voli vuoto" ) ; } catch ( ClassNotFoundException e1 ) { e1 . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { idVoliIn = new FileInputStream ( fileIdVoli ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } try { ObjectInputStream obj = new ObjectInputStream ( idVoliIn ) ; idVoli = ( int ) obj . readObject ( ) ; obj . close ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( EOFException e ) { System . out . println ( "file Id voli vuoto" ) ; idVoli = 0 ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Collections . sort ( listaVoli ) ; int index = 0 ; for ( Volo i : listaVoli ) { i . setId ( index ) ; index ++ ; } this . idVoli = index ; Agenzia . saveToFile ( fileVoli , listaVoli ) ; Agenzia . saveToFile ( fileIdVoli , this . idVoli ) ; }
va	9	void chooseMethod ( int mark ) { if ( v1 . mark == mark ) { direction = ( v2 . mark != mark && Strength . stronger ( strength , v2 . walkStrength ) ) ? FORWARD : NONE ; } if ( v2 . mark == mark ) { direction = ( v1 . mark != mark && Strength . stronger ( strength , v1 . walkStrength ) ) ? BACKWARD : NONE ; } if ( Strength . weaker ( v1 . walkStrength , v2 . walkStrength ) ) { direction = Strength . stronger ( strength , v1 . walkStrength ) ? BACKWARD : NONE ; } else { direction = Strength . stronger ( strength , v2 . walkStrength ) ? FORWARD : BACKWARD ; } }
va	6	void addNode ( Node node ) { setNodeReachable ( node ) ; EdgeList list = node . incoming ; Edge e ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { e = list . getEdge ( i ) ; if ( ! isNodeReachable ( e . source ) ) { if ( ! isCandidate ( e ) ) { setCandidate ( e ) ; candidates . add ( e ) ; } } else candidates . remove ( e ) ; } list = node . outgoing ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { e = list . getEdge ( i ) ; if ( ! isNodeReachable ( e . target ) ) { if ( ! isCandidate ( e ) ) { setCandidate ( e ) ; candidates . add ( e ) ; } } else candidates . remove ( e ) ; } members . add ( node ) ; }
va	1	@ Override public int hashCode ( ) { return id != null ? id . hashCode ( ) : 0 ; }
va	0	protected TaskTrackerServices ( TaskTracker taskTracker ) throws RemoteException { this . taskTrackerReference = taskTracker ; }
va	2	boolean isWorkingDayOfMonth ( String dayOfMonthExpression ) { DayMonthInYear dayOfMonth = DayMonthInYear . valueOf ( dayOfMonthExpression ) ; for ( DayOfMonthException exception : exceptions . values ( ) ) { if ( exception . includes ( dayOfMonth ) ) { return false ; } } return true ; }
va	8	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) . equals ( mat ) ) { String selected = mat . getText ( ) ; Materie materie_noua = null ; for ( Materie m : Centralizator . getInstance ( ) . getMaterii ( ) ) { if ( m . getNume ( ) . equals ( selected ) ) { materie_noua = m ; return ; } } if ( materie_noua == null ) { mesaj . setText ( "Materia nu exista in baza de date a liceului; verificati inca o data" ) ; return ; } secretar . modifyMateriePentruProfesor ( selectedProfesor , materie_noua ) ; } else if ( e . getSource ( ) . equals ( adaugaMaterie ) ) { if ( ! mat . getText ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Profesorul are deja materie; stergeti materia mai intai" ) ; return ; } dispose ( ) ; new SecretarAddMaterie ( secretar , selectedProfesor ) ; } else if ( e . getSource ( ) . equals ( stergeMaterie ) ) { secretar . removeMateriePentruProfesor ( selectedProfesor ) ; mat . setText ( "" ) ; } else if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen2 = Centralizator . getInstance ( ) ; cen2 . saveCentralizator ( ) ; new SecretarMeniu ( secretar ) ; } }
va	6	public static boolean isReady ( int slot ) { if ( getSlotType ( slot ) == ActionSlotType . NOTHING ) return false ; WidgetChild rchild = getReloadChild ( slot ) , ichild = getItemChild ( slot ) ; return rchild != null && rchild . validate ( ) && ! rchild . visible ( ) && ichild != null && ichild . validate ( ) && ichild . getTextColor ( ) == ITEM_AVAILABLE_TEXT_COLOR ; }
va	7	public HttpClient createHttpClient ( ClientConfiguration paramClientConfiguration ) { BasicHttpParams localBasicHttpParams = new BasicHttpParams ( ) ; HttpProtocolParams . setUserAgent ( localBasicHttpParams , paramClientConfiguration . getUserAgent ( ) ) ; HttpProtocolParams . setVersion ( localBasicHttpParams , HttpVersion . HTTP_1_1 ) ; HttpConnectionParams . setConnectionTimeout ( localBasicHttpParams , paramClientConfiguration . getConnectionTimeout ( ) ) ; HttpConnectionParams . setSoTimeout ( localBasicHttpParams , paramClientConfiguration . getSocketTimeout ( ) ) ; HttpConnectionParams . setStaleCheckingEnabled ( localBasicHttpParams , true ) ; HttpConnectionParams . setTcpNoDelay ( localBasicHttpParams , true ) ; int i = paramClientConfiguration . getSocketBufferSizeHints ( ) [ 0 ] ; int j = paramClientConfiguration . getSocketBufferSizeHints ( ) [ 1 ] ; if ( ( i > 0 ) || ( j > 0 ) ) { HttpConnectionParams . setSocketBufferSize ( localBasicHttpParams , Math . max ( i , j ) ) ; } SchemeRegistry localSchemeRegistry = new SchemeRegistry ( ) ; localSchemeRegistry . register ( new Scheme ( "http" , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; try { KeyStore localKeyStore = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; localKeyStore . load ( null , null ) ; localSchemeRegistry . register ( new Scheme ( "https" , new TrustAllSSLSocketFactory ( localKeyStore ) , 443 ) ) ; } catch ( Exception localException ) { throw new BCSClientException ( "Can not enable ssl." , localException ) ; } ConnManagerParams . setMaxTotalConnections ( localBasicHttpParams , paramClientConfiguration . getMaxConnections ( ) ) ; ConnManagerParams . setMaxConnectionsPerRoute ( localBasicHttpParams , new ConnPerRouteBean ( paramClientConfiguration . getMaxConnectionsPerRoute ( ) ) ) ; ThreadSafeClientConnManager localThreadSafeClientConnManager = new ThreadSafeClientConnManager ( localBasicHttpParams , localSchemeRegistry ) ; DefaultHttpClient localDefaultHttpClient = new DefaultHttpClient ( localThreadSafeClientConnManager , localBasicHttpParams ) ; String str1 = paramClientConfiguration . getProxyHost ( ) ; int k = paramClientConfiguration . getProxyPort ( ) ; if ( ( str1 != null ) && ( k > 0 ) ) { HttpHost localHttpHost = new HttpHost ( str1 , k ) ; localDefaultHttpClient . getParams ( ) . setParameter ( "http.route.default-proxy" , localHttpHost ) ; String str2 = paramClientConfiguration . getProxyUsername ( ) ; String str3 = paramClientConfiguration . getProxyPassword ( ) ; String str4 = paramClientConfiguration . getProxyDomain ( ) ; String str5 = paramClientConfiguration . getProxyWorkstation ( ) ; if ( ( str2 != null ) && ( str3 != null ) ) { localDefaultHttpClient . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( str1 , k ) , new NTCredentials ( str2 , str3 , str5 , str4 ) ) ; } } return localDefaultHttpClient ; }
