va	7	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue ) { if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) == Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
va	4	public void propertyChange ( PropertyChangeEvent e ) { boolean update = false ; String prop = e . getPropertyName ( ) ; if ( JFileChooser . DIRECTORY_CHANGED_PROPERTY . equals ( prop ) ) { file = null ; update = true ; } else if ( JFileChooser . SELECTED_FILE_CHANGED_PROPERTY . equals ( prop ) ) { file = ( File ) e . getNewValue ( ) ; update = true ; } if ( update ) { thumbnail = null ; if ( isShowing ( ) ) { loadImage ( ) ; repaint ( ) ; } } }
va	1	@ Override public void writeAnalysis ( MorphologyAnalysis analysis ) { final String record = String . format ( "%s (\"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\");%n" , INSERT_ANALYSIS , analysis . getForm ( ) , analysis . getLemma ( ) , analysis . getGrammaticalCase ( ) , analysis . getDegree ( ) , analysis . getGender ( ) , analysis . getMood ( ) , analysis . getNumber ( ) , analysis . getPerson ( ) , analysis . getPos ( ) , analysis . getTense ( ) , analysis . getVoice ( ) ) ; try { morphologyWriter . write ( record ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
va	0	public Integer getBuycount ( ) { return buycount ; }
va	6	public synchronized void forward ( int gameID , String data ) { try { StringTokenizer ST = new StringTokenizer ( data ) ; String player = ST . nextToken ( ) ; String name = ST . nextToken ( ) ; String msg = data . substring ( name . length ( ) + player . length ( ) + 2 ) ; int target = Integer . parseInt ( player ) ; for ( int i = 0 ; i < games . size ( ) ; i ++ ) { Game game = ( Game ) games . elementAt ( i ) ; if ( game . getNameOfTheGame ( ) . equals ( name ) && gameID == game . getGameID ( ) ) { if ( target != - 1 ) { ServerThread recipient = ( ( ServerThread ) game . getPlayers ( ) . elementAt ( target ) ) ; recipient . send ( "1" + msg ) ; } else { if ( msg . equals ( "go" ) ) { game . start ( ) ; } } } } } catch ( NoSuchElementException e ) { String log = "server: corrupt message in method forward!\n" ; System . out . print ( log ) ; log ( log , port ) ; } }
va	9	public void run ( ) { long now = 0 , prev = 0 , dt = 0 ; for ( ; ; ) { for ( Integer integer : toDelete ) { for ( System system : systems ) { system . removeEntity ( integer ) ; } } toDelete . clear ( ) ; prev = java . lang . System . currentTimeMillis ( ) ; for ( System logicSystem : logicSystems ) { logicSystem . update ( dt ) ; } for ( System prerenderSystem : prerenderSystems ) { prerenderSystem . update ( dt ) ; } for ( System renderSystem : renderSystems ) { renderSystem . update ( dt ) ; } for ( System postRenderSystem : postRenderSystems ) { postRenderSystem . update ( dt ) ; } now = java . lang . System . currentTimeMillis ( ) ; java . lang . System . out . printf ( "Loop time: %d ms \r" , java . lang . System . currentTimeMillis ( ) - prev ) ; try { if ( frameTime - ( now - prev ) > 0 ) Thread . sleep ( frameTime - ( now - prev ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } dt = now - prev ; } }
va	6	private static int partition ( int [ ] a , int lo , int hi ) { int i = lo ; int j = hi + 1 ; int v = a [ lo ] ; while ( true ) { while ( less ( a [ ++ i ] , v ) ) if ( i == hi ) break ; while ( less ( v , a [ -- j ] ) ) if ( j == lo ) break ; if ( i >= j ) break ; exch ( a , i , j ) ; } exch ( a , lo , j ) ; return j ; }
va	2	public Vector3f setNorm ( Vector3f vector , float l ) { final float length2 = vector . . ( ) ; if ( length2 != 0 ) { if ( Math . abs ( length2 - 1 ) > Tolerance . null ) { return setScale ( vector , l / ( float ) Math . sqrt ( length2 ) ) ; } else { return setScale ( vector , l ) ; } } return set ( vector ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Totales_estudiantes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Totales_estudiantes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Totales_estudiantes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Totales_estudiantes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { Totales_estudiantes dialog = new Totales_estudiantes ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	9	private static BufferedImage checkCorners ( BufferedImage c , World w , int x , int y ) { if ( true ) return c ; @ SuppressWarnings ( "unused" ) int ter = w . terrainAt ( x , y ) ; int upleft = w . terrainAt ( x - 1 , y - 1 ) ; int upright = w . terrainAt ( x + 1 , y - 1 ) ; int downleft = w . terrainAt ( x - 1 , y + 1 ) ; int downright = w . terrainAt ( x + 1 , y + 1 ) ; int water = static . TERRAIN_WATER ; int shore = static . TERRAIN_SHORE ; Graphics2D g = c . createGraphics ( ) ; if ( ter == water ) { if ( upleft == water ) g . drawImage ( waterCorner [ 0 ] [ 0 ] , 0 , 0 , null ) ; if ( upright == water ) g . drawImage ( waterCorner [ 1 ] [ 0 ] , 8 , 0 , null ) ; if ( downleft == water ) g . drawImage ( waterCorner [ 0 ] [ 1 ] , 0 , 8 , null ) ; if ( downright == water ) g . drawImage ( waterCorner [ 1 ] [ 1 ] , 8 , 8 , null ) ; return c ; } else if ( ter == shore ) { if ( upleft == shore ) g . drawImage ( shoreCorner [ 0 ] [ 0 ] , 0 , 0 , null ) ; if ( upright == shore ) g . drawImage ( shoreCorner [ 1 ] [ 0 ] , 8 , 0 , null ) ; if ( downleft == shore ) g . drawImage ( shoreCorner [ 0 ] [ 1 ] , 0 , 8 , null ) ; if ( downright == shore ) g . drawImage ( shoreCorner [ 1 ] [ 1 ] , 8 , 8 , null ) ; return c ; } else return c ; }
va	8	public int parse ( String str ) { if ( str == null ) return - 1 ; clear ( ) ; int n = 0 ; for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { int lp = str . indexOf ( ( , n ) ; int rp = str . indexOf ( ) , n ) ; if ( lp < 0 || rp < 0 ) return - 1 ; if ( rp > lp + 1 ) { String events [ ] = str . substring ( lp + 1 , rp ) . split ( " " ) ; for ( int i = 0 ; i < events . length ; i ++ ) { String e = events [ i ] ; int = = e . indexOf ( = ) ; int f = Integer . parseInt ( e . substring ( 0 , = ) ) ; int v = Integer . parseInt ( e . substring ( = + 1 , e . length ( ) ) ) ; setFrameData ( f , s , v ) ; } } n = rp + 1 ; } if ( str . length ( ) > n ) { String pauses [ ] = str . substring ( n + 1 , str . length ( ) ) . split ( " " ) ; for ( int j = 0 ; j < pauses . length ; j ++ ) pauseData [ Integer . parseInt ( pauses [ j ] ) ] = true ; } return 0 ; }
va	6	protected void generateContacts ( ) { CollisionContact c ; Movable a = null ; for ( GameEntity e : entities ) { if ( ! ( e instanceof Movable ) ) continue ; a = ( Movable ) e ; for ( GameEntity b : a . neighbours ) { if ( a . equals ( b ) ) continue ; if ( ! a . isEnemy ( b ) ) continue ; c = generateContact ( a , b ) ; if ( c != null ) { contacts . add ( c ) ; } } } }
va	1	private static void stringsTestWithComparators ( Sorter sorter ) { System . out . println ( "ComparableString tests with comparators" ) ; System . out . println ( "using StringLengthComparator" ) ; List < ComparableString > list = new ArrayList < ComparableString > ( ) ; List < long > results = new ArrayList < long > ( ) ; Comparator < ComparableString > comparator = new StringLengthComparator ( ) ; fillListStrings ( list , 10 , 10 ) ; System . out . println ( "Checking correctness" ) ; System . out . println ( "Source list: " ) ; printList ( list , false ) ; results . add ( getTime ( list , sorter , comparator ) ) ; System . out . println ( "Sorted list: " ) ; printList ( list , false ) ; System . out . println ( "Executing bigger test:" ) ; fillListStrings ( list , 100 , 10 ) ; results . add ( getTime ( list , sorter , comparator ) ) ; fillListStrings ( list , 1000 , 10 ) ; results . add ( getTime ( list , sorter , comparator ) ) ; fillListStrings ( list , 10000 , 10 ) ; results . add ( getTime ( list , sorter , comparator ) ) ; System . out . println ( "10 \t\t100  \t\t1000\t\t10000" ) ; for ( long res : results ) { System . out . print ( res + "ms\t\t" ) ; } System . out . println ( ) ; }
va	8	public void insert ( Comparable in ) { if ( smallest == null || in . compareTo ( smallest ) < 0 ) { smallest = in ; } RBNode insertedNode = createNode ( in ) ; if ( root == null ) { insertedNode . color = NodeColor . RED ; insertedNode . left = null ; insertedNode . right = null ; insertedNode . parent = null ; root = insertedNode ; } else { RBNode n = root ; while ( true ) { compResult = insertedNode . compareTo ( n ) ; if ( compResult == 0 ) { System . out . println ( "Duplicate Node error" ) ; System . out . println ( n + " and " + insertedNode ) ; return ; } else if ( compResult < 0 ) { if ( n . left == null ) { insertedNode . color = NodeColor . RED ; insertedNode . left = null ; insertedNode . right = null ; insertedNode . parent = null ; n . left = insertedNode ; break ; } else { n = n . left ; } } else { assert compResult > 0 ; if ( n . right == null ) { insertedNode . color = NodeColor . RED ; insertedNode . left = null ; insertedNode . right = null ; insertedNode . parent = null ; n . right = insertedNode ; break ; } else { n = n . right ; } } } insertedNode . parent = n ; } insertCase1 ( insertedNode ) ; size ++ ; }
va	5	public static < AnyType extends Comparable < ? super AnyType >> void shellsort ( AnyType [ ] a ) { int j ; for ( int gap = a . length / 2 ; gap > 0 ; gap /= 2 ) for ( int i = gap ; i < a . length ; i ++ ) { AnyType tmp = a [ i ] ; for ( j = i ; j >= gap && tmp . compareTo ( a [ j - gap ] ) < 0 ; j -= gap ) a [ j ] = a [ j - gap ] ; a [ j ] = tmp ; } }
va	9	@ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( localName . equals ( "way" ) ) { currentWay = new OSMWay ( long . parseLong ( attributes . getValue ( "id" ) ) ) ; } else if ( currentWay != null && localName . equals ( "nd" ) ) { currentWay . nodes . add ( nodes . get ( long . parseLong ( attributes . getValue ( "ref" ) ) ) ) ; } else if ( currentWay != null && localName . equals ( "tag" ) ) { if ( attributes . getValue ( "k" ) . equals ( "oneway" ) ) { if ( attributes . getValue ( "v" ) . equals ( "yes" ) || attributes . getValue ( "v" ) . equals ( "true" ) ) { currentWay . oneway = true ; } else if ( attributes . getValue ( "v" ) . equals ( "no" ) || attributes . getValue ( "v" ) . equals ( "false" ) ) { currentWay . oneway = false ; } else { System . err . println ( "Unhandled oneway attribute: " + attributes . getValue ( "v" ) + " way id: " + currentWay . getId ( ) ) ; } } else if ( attributes . getValue ( "k" ) . equals ( "junction" ) ) { if ( attributes . getValue ( "v" ) . equals ( "roundabout" ) ) { currentWay . oneway = true ; } } } }
va	3	public String findAttackDomainByID ( String id ) { String result = null ; for ( LinkedList < String > domain_list : all ) { for ( String attack_id : domain_list ) { if ( attack_id . equals ( id ) ) { result = domain_list . getFirst ( ) ; return domain_target_mapping . get ( result ) ; } } } return null ; }
va	9	static Object removePreserve ( ActiveContext ctx , Object input , Options opts ) { if ( isArray ( input ) ) { final List < Object > output = new ArrayList < Object > ( ) ; for ( final Object i : ( List < Object > ) input ) { final Object result = removePreserve ( ctx , i , opts ) ; if ( result != null ) { output . add ( result ) ; } } input = output ; } else if ( isObject ( input ) ) { if ( ( ( Map < String , Object > ) input ) . containsKey ( "@preserve" ) ) { if ( "@null" . equals ( ( ( Map < String , Object > ) input ) . get ( "@preserve" ) ) ) { return null ; } return ( ( Map < String , Object > ) input ) . get ( "@preserve" ) ; } if ( isValue ( input ) ) { return input ; } if ( isList ( input ) ) { ( ( Map < String , Object > ) input ) . put ( "@list" , removePreserve ( ctx , ( ( Map < String , Object > ) input ) . get ( "@list" ) , opts ) ) ; return input ; } for ( final String prop : ( ( Map < String , Object > ) input ) . keySet ( ) ) { Object result = removePreserve ( ctx , ( ( Map < String , Object > ) input ) . get ( prop ) , opts ) ; final String container = ( String ) ctx . getContextValue ( prop , "@container" ) ; if ( opts . compactArrays && isArray ( result ) && ( ( List < Object > ) result ) . size ( ) == 1 && container == null ) { result = ( ( List < Object > ) result ) . get ( 0 ) ; } ( ( Map < String , Object > ) input ) . put ( prop , result ) ; } } return input ; }
va	6	public int getCostSavings ( int numberOfEmployees ) { int counter = 0 ; int savings = 0 ; while ( counter < numberOfEmployees ) { if ( ratingEmployeeMap . size ( ) > 0 ) { TreeSet < Integer > treeset = ( TreeSet ) ratingEmployeeMap . remove ( ratingEmployeeMap . firstKey ( ) ) . descendingSet ( ) ; if ( treeset != null && treeset . size ( ) > 0 ) { for ( int salary : treeset ) { if ( counter < numberOfEmployees ) { savings = savings + salary ; } else { return savings ; } counter ++ ; } } } else { return savings ; } } return savings ; }
va	5	private void checkClick ( ) { if ( click ) { if ( getItemName ( ) != "Items.Item" ) { if ( SwingUtilities . getAncestorNamed ( "playerMainInventory" , this ) != null ) { if ( MainClass . isStoreOpen ( ) ) { sellItem ( ) ; } else { useItem ( ) ; } } else if ( SwingUtilities . getAncestorNamed ( "storeMainInventory" , this ) != null ) { buyItem ( ) ; } click = false ; } } }
va	4	public void setDestinations ( String [ ] destinations ) throws Exception { ArrayList < Integer > dests = new ArrayList < Integer > ( ) ; int proteinId ; for ( String proteinName : destinations ) { proteinId = nomenclature . NametoID ( proteinName . trim ( ) ) ; if ( proteinId != - 1 ) dests . add ( proteinId ) ; } srcGraph . dests = new int [ dests . size ( ) ] ; srcGraph . subGraph . clear ( ) ; for ( int i = 0 ; i < dests . size ( ) ; i ++ ) srcGraph . dests [ i ] = dests . get ( i ) ; destGraph . srces = new int [ dests . size ( ) ] ; for ( int i = 0 ; i < dests . size ( ) ; i ++ ) destGraph . srces [ i ] = dests . get ( i ) ; }
va	3	private void checkForWorldChangerConsumptionForSnake ( Snake snake ) { int x = snake . getHead ( ) . getX ( ) ; int y = snake . getHead ( ) . getY ( ) ; WorldChanger usedWorldChanger = null ; for ( WorldChanger worldChanger : getWorldChangers ( ) ) { Piece piece = ( Piece ) worldChanger ; if ( piece . isAtCoordinates ( x , y ) ) { worldChanger . modifyWorld ( this ) ; usedWorldChanger = worldChanger ; } } if ( usedWorldChanger != null ) { getWorldChangers ( ) . remove ( usedWorldChanger ) ; controller . snakeHasConsumedAWorldChanger ( snake , usedWorldChanger ) ; } }
va	2	private void Initialize ( ) { expandedList = new PriorityQueue < Cell > ( new CellComparator ( ) ) ; for ( int i = 0 ; i < map . getCells ( ) . length ; i ++ ) { for ( int j = 0 ; j < map . getCells ( ) [ 0 ] . length ; j ++ ) { map . getCells ( ) [ i ] [ j ] . g = map . getCells ( ) [ i ] [ j ] . rhs = Integer . MAX_VALUE ; } } map . getStartCell ( ) . rhs = 0 ; map . getStartCell ( ) . key = new Key ( map . getHeuristic ( map . getStartCell ( ) ) , 0 ) ; expandedList . add ( map . getStartCell ( ) ) ; }
va	5	public int trimRight ( ) { while ( len != 0 ) { char c = ( char ) array [ len - 1 ] ; if ( c == 32 || c == 10 || c == 13 || c == 9 ) { len -- ; } else { return len ; } } return len ; }
va	7	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p != null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p != null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev != null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
va	3	@ Test public void doTest ( ) { System . out . println ( check ( 26 , 65 ) ) ; for ( int i = 10 ; i <= 99 ; i ++ ) { for ( int j = i + 1 ; j <= 99 ; j ++ ) { if ( check ( i , j ) ) { System . out . println ( i + "/" + j ) ; } } } }
va	2	@ Override public boolean isReached ( ) { boolean result = true ; for ( IStopCondition condition : conditions ) result = result && condition . isReached ( ) ; return result ; }
va	9	@ Override public boolean [ ] getBooleanData ( boolean [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { boolean [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new boolean [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { long v = Utilities . UNSAFE . getLong ( ptr + sizeof * i ) ; out [ idx ++ ] = v != 0 ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] != 0 ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { long v = data [ ( int ) i ] ; out [ idx ++ ] = v != 0 ; } } } return out ; } }
va	0	public void setName ( String name ) { this . name = name ; }
va	2	public Task getTask ( String name ) { for ( int i = 0 ; i < taskCount ; i ++ ) { if ( tasks [ i ] . getName ( ) == name ) { return tasks [ i ] ; } } return null ; }
va	2	public void addInOrder ( Object ... objects ) { for ( int i = 1 ; i < objects . length ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { add ( objects [ j ] , objects [ i ] ) ; } } }
va	8	private void onClickLogin ( ) { MySession sess = ( MySession ) getSession ( ) ; String username = _openidname . getModelObjectAsString ( ) ; SelectOption op = ( SelectOption ) _openidprovider . getModelObject ( ) ; String consumer = op . getCode ( ) ; System . out . println ( "username " + username ) ; System . out . println ( "consumer " + consumer ) ; int userid = - 1 ; while ( userid == - 1 ) { SelectFromLoginUser sql = new SelectFromLoginUser ( username , consumer ) ; List userlist = DBUtil . selectFromDb ( sql ) ; if ( userlist . isEmpty ( ) ) { InsertLoginUser sqlins = new InsertLoginUser ( username , consumer ) ; int sqlinscnt = DBUtil . updateDb ( sqlins ) ; if ( sqlinscnt != 1 ) { throw new RuntimeException ( "\u30E6\u30FC\u30B6\u30FC\u306E\u8FFD\u52A0\u306B\u5931\u6557" ) ; } } else { if ( userlist . size ( ) != 1 ) { throw new RuntimeException ( "\u30E6\u30FC\u30B6\u30FC\u304C\u8907\u6570\u898B\u3064\u304B\u3063\u305F\uFF01" ) ; } SelectFromLoginUser ret = ( SelectFromLoginUser ) userlist . get ( 0 ) ; userid = ret . getUserId ( ) ; } } try { String fowardurl = "" ; if ( op == SELECT_HATENA ) { fowardurl = op . getCode ( ) + username ; } sess . setSaveUserInfo ( userid , username , consumer ) ; ConsumerManager manager = ConsumerManagerWrapper . getInstance ( ) ; List discoveries = manager . discover ( fowardurl ) ; if ( discoveries == null ) { error ( "\u30B3\u30F3\u30B7\u30E5\u30FC\u30DE\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093" ) ; return ; } DiscoveryInformation discovered = manager . associate ( discoveries ) ; sess . setDescoveryInformation ( discovered ) ; String returnURL = RequestUtils . toAbsolutePath ( "verify" ) ; AuthRequest authReq = null ; authReq = manager . authenticate ( discovered , returnURL ) ; if ( authReq != null ) { getRequestCycle ( ) . setRequestTarget ( new RedirectRequestTarget ( authReq . getDestinationUrl ( true ) ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( "\u30ED\u30B0\u30A4\u30F3\u30DC\u30BF\u30F3\u4E2D\u306E\u5931\u6557" ) ; } }
va	3	public String userTypeToString ( ) { switch ( this . userType ) { case CLIENTE : { return new String ( "Cliente" ) ; } case OPERATORE : { return new String ( "Operatore" ) ; } case ADMIN : { return new String ( "Admin" ) ; } default : return null ; } }
va	8	@ Test public void testFibonacci ( ) { Permutations test = new Permutations ( ) ; List < String > list = new ArrayList < String > ( ) ; list = test . permutations ( "abcd" ) ; assertEquals ( "'abcd' should have returned 24 permutations" , 24 , list . size ( ) ) ; for ( String word : list ) { try { ABCD . valueOf ( word ) ; } catch ( IllegalArgumentException ex ) { fail ( "The permutation " + word + " is not valid" ) ; } } list = test . permutations ( "abc" ) ; assertEquals ( "'abc' should have returned 6 permutations" , 6 , list . size ( ) ) ; for ( String word : list ) { try { ABC . valueOf ( word ) ; } catch ( IllegalArgumentException ex ) { fail ( "The permutation " + word + " is not valid" ) ; } } list = test . permutations ( "ab" ) ; assertEquals ( "'ab' should have returned 2 permutations" , 2 , list . size ( ) ) ; for ( String word : list ) { try { AB . valueOf ( word ) ; } catch ( IllegalArgumentException ex ) { fail ( "The permutation  " + word + "  is not valid" ) ; } } list = test . permutations ( "a" ) ; assertEquals ( "'a' should have returned 1 permutation" , 1 , list . size ( ) ) ; for ( String word : list ) { try { A . valueOf ( word ) ; } catch ( IllegalArgumentException ex ) { fail ( "The permutation " + word + " is not valid" ) ; } } list = test . permutations ( "" ) ; assertEquals ( "'' should have returned 0 permutations" , 0 , list . size ( ) ) ; list = test . permutations ( "abcdefghi" ) ; assertEquals ( "'abcdefgh' should have returned 362880 permutations" , 362880 , list . size ( ) ) ; }
va	3	public DigitalOutputCommand ( boolean pin20 , boolean pin7 , boolean pin19 ) { byte pin = 00 ; if ( pin19 ) { pin = ( byte ) ( pin | 01 ) ; } if ( pin7 ) { pin = ( byte ) ( pin | 02 ) ; } if ( pin20 ) { pin = ( byte ) ( pin | 04 ) ; } setCommand ( new byte [ ] { ( byte ) OpCode . DIGITAL_OUTPUT . op ( ) , pin } ) ; }
va	0	@ Override public void onBulletMiss ( BulletMissEvent e ) { }
va	0	public void setOutGoingConnections ( Map < Neuron , List < Connection >> outGoingConnections ) { this . outGoingConnections = outGoingConnections ; }
va	8	private void deleteCase5 ( RBNode n ) { if ( n == n . parent . left && nodeColor ( n . sibling ( ) ) == NodeColor . BLACK && nodeColor ( n . sibling ( ) . left ) == NodeColor . RED && nodeColor ( n . sibling ( ) . right ) == NodeColor . BLACK ) { n . sibling ( ) . color = NodeColor . RED ; n . sibling ( ) . left . color = NodeColor . BLACK ; rotateRight ( n . sibling ( ) ) ; } else if ( n == n . parent . right && nodeColor ( n . sibling ( ) ) == NodeColor . BLACK && nodeColor ( n . sibling ( ) . right ) == NodeColor . RED && nodeColor ( n . sibling ( ) . left ) == NodeColor . BLACK ) { n . sibling ( ) . color = NodeColor . RED ; n . sibling ( ) . right . color = NodeColor . BLACK ; rotateLeft ( n . sibling ( ) ) ; } deleteCase6 ( n ) ; }
va	6	private boolean r_other_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_2 , 5 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; switch ( among_var ) { case 0 : limit_backward = v_2 ; return false ; case 1 : slice_del ( ) ; break ; case 2 : slice_from ( "l\u00F6s" ) ; break ; case 3 : slice_from ( "full" ) ; break ; } limit_backward = v_2 ; return true ; }
va	7	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; NumbersChallenge obj ; int answer ; obj = new NumbersChallenge ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . MinNumber ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	4	public void addSubnode ( Node newSubnode ) { if ( subnode == null ) { subnode = newSubnode ; } else { Node previous = findPrevious ( subnode , newSubnode ) ; if ( previous . isFirstSubnode ( ) && previous . isAfter ( newSubnode ) ) { subnode = newSubnode ; newSubnode . next = previous ; newSubnode . previous = null ; previous . previous = newSubnode ; } else { newSubnode . next = previous . next ; previous . next = newSubnode ; newSubnode . previous = previous ; if ( newSubnode . next != null ) { newSubnode . next . previous = newSubnode ; } } } newSubnode . parent = this ; }
va	6	public Automaton getAutomaton ( String name ) { if ( ( enable_unicodeblocks && Datatypes . isUnicodeBlockName ( name ) ) || ( enable_unicodecategories && Datatypes . isUnicodeCategoryName ( name ) ) || ( enable_xml && Datatypes . isXMLName ( name ) ) ) return Datatypes . get ( name ) ; return null ; }
va	5	public String getFullName ( String typeName ) { try { class < ? > c = class . forName ( typeName . replaceAll ( "\\:\\:" , "." ) ) ; return c . getName ( ) . replaceAll ( "\\." , "::" ) ; } catch ( ClassNotFoundException e ) { for ( package p : package . getPackages ( ) ) { try { class < ? > c = class . forName ( ( p . getName ( ) + "." + typeName ) . replaceAll ( "\\:\\:" , "." ) ) ; return c . getName ( ) . replaceAll ( "\\." , "::" ) ; } catch ( Throwable ee ) { } } return typeName ; } }
va	4	@ Override protected void doBatchWeightsUpdate ( ) { List < ILayer > layers = this . network . getLayers ( ) ; for ( int i = this . network . getLayersNum ( ) - 1 ; i > 0 ; i -- ) for ( INeuron neuron : layers . get ( i ) . getNeurons ( ) ) if ( neuron instanceof IInputtedNeuron ) for ( ISynapse synapse : ( ( IInputtedNeuron ) neuron ) . getInputConnections ( ) ) { synapse . incrementWeight ( synapse . getWeightChange ( ) ) ; synapse . setWeightChange ( 0 ) ; } }
va	8	public static String getRelativeDate ( Calendar date ) { Calendar now = Calendar . getInstance ( ) ; long diff = now . getTimeInMillis ( ) - date . getTimeInMillis ( ) ; if ( diff > 0 ) { if ( diff < 2 * SECOND ) return "just now" ; else if ( diff < MINUTE ) return ( diff / SECOND ) + " seconds ago" ; else if ( diff < 2 * MINUTE ) return "a minute ago" ; else if ( diff < HOUR ) return ( diff / MINUTE ) + " minutes ago" ; else if ( diff < 2 * HOUR ) return "an hour ago" ; else if ( diff < DAY ) return ( diff / HOUR ) + " hours ago" ; else if ( diff < 2 * DAY ) return "yesterday" ; else return ( diff / DAY ) + " days ago" ; } else { return "" ; } }
va	8	private void jButton1MouseClicked ( java . awt . event . MouseEvent evt ) { jList1 . updateUI ( ) ; if ( jList1 . getSelectedIndex ( ) >= 0 ) { Field f = Game . fields . get ( fieldsR . get ( jList1 . getSelectedIndex ( ) ) ) ; if ( f . getClass ( ) == Brewery . class ) { Brewery brew = ( ( Brewery ) f ) ; if ( brew . Mortgage ) { brew . Mortgage = false ; Game . players . get ( brew . Owner ) . ChangeMoney ( - ( brew . Price / 2 ) ) ; } else { brew . Mortgage = true ; Game . players . get ( brew . Owner ) . ChangeMoney ( ( brew . Price / 2 ) ) ; } } else if ( f . getClass ( ) == Street . class ) { Street street = ( ( Street ) f ) ; if ( street . Mortgage ) { street . Mortgage = false ; Game . players . get ( street . Owner ) . ChangeMoney ( - ( street . Price / 2 ) ) ; } else { if ( street . Houses == 0 ) { street . Mortgage = true ; Game . players . get ( street . Owner ) . ChangeMoney ( ( street . Price / 2 ) ) ; } else { JOptionPane . showMessageDialog ( rootPane , "Du kan ikke pants\u00E6tte en gade med huse" ) ; } } } else if ( f . getClass ( ) == ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) f ) ; if ( sl . Mortgage ) { sl . Mortgage = false ; Game . players . get ( sl . Owner ) . ChangeMoney ( - ( sl . Price / 2 ) ) ; } else { sl . Mortgage = true ; Game . players . get ( sl . Owner ) . ChangeMoney ( ( sl . Price / 2 ) ) ; } } Game . gameboard . refreshGameControl ( ) ; this . dispose ( ) ; } }
va	3	public static boolean hiiriPaalla ( Point p ) { return p . x >= X + REUNUS && p . x <= X + LEV - REUNUS && p . y >= Y + REUNUS && p . y <= Y + KOR - REUNUS ; }
va	9	public void remove ( JTreeNode < T > root ) { if ( root . getLeftNode ( ) != null && root . getRightNode ( ) != null ) { JTreeNode < T > newRoot = root . getRightNode ( ) ; JTreeNode < T > newRootLeftLeaf = root . getLeftNode ( ) ; JTreeNode < T > findLeftLeaf = newRoot . getLeftNode ( ) ; if ( findLeftLeaf == null ) { newRoot . setLeftNode ( newRootLeftLeaf ) ; } else { while ( findLeftLeaf . getLeftNode ( ) != null ) { findLeftLeaf = findLeftLeaf . getLeftNode ( ) ; } findLeftLeaf . setLeftNode ( newRootLeftLeaf ) ; } removeFromTree ( root , newRoot ) ; } else if ( root . getLeftNode ( ) != null && root . getRightNode ( ) == null ) { JTreeNode < T > newRoot = root . getLeftNode ( ) ; removeFromTree ( root , newRoot ) ; } else if ( root . getLeftNode ( ) == null && root . getRightNode ( ) != null ) { JTreeNode < T > newRoot = root . getRightNode ( ) ; removeFromTree ( root , newRoot ) ; } else if ( root . getLeftNode ( ) == null && root . getRightNode ( ) == null ) { removeFromTree ( root , null ) ; } }
va	7	public boolean remove ( Object key , Object value ) { final Node node = data . get ( key ) ; if ( ( node == null ) || ( value == null ) ) { return false ; } WeightedValue < V > weightedValue = node . get ( ) ; for ( ; ; ) { if ( weightedValue . contains ( value ) ) { if ( node . tryToRetire ( weightedValue ) ) { if ( data . remove ( key , node ) ) { afterCompletion ( new RemovalTask ( node ) ) ; return true ; } } else { weightedValue = node . get ( ) ; if ( weightedValue . isAlive ( ) ) { continue ; } } } return false ; } }
va	5	@ Override public void run ( ) { progressbar . setValue ( p ) ; }
va	5	private RecordTicks getRecordBySpeed ( List < Record > friction , double speed ) { RecordTicks r = new RecordTicks ( ) ; bufferRecord . speed = speed ; int i = Collections . binarySearch ( friction , bufferRecord , speedComparator ) ; if ( i < 0 ) { i = abs ( i + 1 ) ; int k_0 = i - 1 ; int k_1 = i ; if ( k_0 < 0 ) { k_0 = 0 ; } if ( k_1 == friction . size ( ) ) { k_1 = k_0 ; } Record r_0 = friction . get ( k_0 ) ; Record r_1 = friction . get ( k_1 ) ; double part = ( speed - r_0 . speed ) / ( r_1 . speed - r_0 . speed ) ; if ( k_0 == k_1 ) part = 0 ; r . record = new Record ( r_0 . distance + part * ( r_1 . distance - r_0 . distance ) , speed ) ; r . tick = k_0 + part ; } else { if ( i == friction . size ( ) ) throw new RuntimeException ( ) ; r . record = friction . get ( i ) ; r . tick = i ; } return r ; }
va	6	private void savePressed ( ) { System . out . println ( "name form " + tfName . getText ( ) + " " + tfFormula . getText ( ) ) ; if ( funct == null ) { try { new UserFunction ( tfName . getText ( ) , tfFormula . getText ( ) ) ; System . out . println ( "Save successful" ) ; panel . display ( "Save successful for: " + tfName . getText ( ) , true ) ; panel . updateMenuBar ( ) ; panel . hideFunctionPanel ( ) ; } catch ( Exception e ) { if ( panel != null ) panel . error ( e . getMessage ( ) , true ) ; e . printStackTrace ( ) ; } } else { try { UserFunction . getFunctions ( ) . remove ( funct ) ; if ( ! tfName . getText ( ) . isEmpty ( ) ) { new UserFunction ( tfName . getText ( ) , tfFormula . getText ( ) ) ; panel . display ( "Save successful for: " + tfName . getText ( ) , true ) ; } else panel . display ( "Successfully deleted: " + funct . getName ( ) , true ) ; System . out . println ( "Save successful" ) ; panel . updateMenuBar ( ) ; panel . hideFunctionPanel ( ) ; } catch ( Exception e ) { if ( panel != null ) panel . error ( e . getMessage ( ) , true ) ; e . printStackTrace ( ) ; } } System . out . println ( UserFunction . getFunctions ( ) ) ; }
va	7	private static void assignClientToVehicle ( Individual child , Individual parent1 , Individual parent2 , int [ ] assignedVehicle , int [ ] numberOfCustomerServed , int period ) { for ( int client = 0 ; client < problemInstance . customerCount ; client ++ ) { if ( child . periodAssignment [ period ] [ client ] == false ) continue ; int vehicle1 = RouteUtilities . assignedVehicle ( parent1 , client , period , problemInstance ) ; int vehicle2 = RouteUtilities . assignedVehicle ( parent2 , client , period , problemInstance ) ; int chosenVehicle = 500000 ; if ( vehicle1 == - 1 && vehicle2 == - 1 ) System . out . println ( "ERROR!!!! NEVER SHOULD HAPPEN!!!!!!!!!! in varied edge recombination op...." ) ; else if ( vehicle1 == - 1 ) chosenVehicle = vehicle2 ; else if ( vehicle2 == - 1 ) chosenVehicle = vehicle1 ; else { int coin = Utility . randomIntInclusive ( 1 ) ; if ( coin == 0 ) chosenVehicle = vehicle1 ; else chosenVehicle = vehicle2 ; } assignedVehicle [ client ] = chosenVehicle ; numberOfCustomerServed [ chosenVehicle ] ++ ; } }
va	7	@ Override protected Object doInBackground ( ) throws Exception { AccessTokenClient tokenClient = new AccessTokenClient ( ) ; String response = "" ; OAuthPropertyBean pBean = OAuthPropertyBean . getInstance ( ) ; try { if ( grantType == OAuthPropertyBean . AUTHORIZATION_GRANT ) { response = tokenClient . getAccessTokenByAuthorizationGrant ( pBean . getAccessURL ( ) , pBean . getClientId ( ) , pBean . getClientSecret ( ) , pBean . getAuthorizationCode ( ) , pBean . getRedirectUri ( ) , pBean . getScope ( ) ) ; } else if ( grantType == OAuthPropertyBean . PASWORD_GRANT ) { response = tokenClient . getAccessTokenByResourceCreds ( pBean . getAccessURL ( ) , pBean . getClientId ( ) , pBean . getClientSecret ( ) , pBean . getResUsername ( ) , pBean . getResPassword ( ) , pBean . getScope ( ) ) ; } else if ( grantType == OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) { response = tokenClient . getAccessTokenByClientCreds ( pBean . getAccessURL ( ) , pBean . getClientId ( ) , pBean . getClientSecret ( ) , pBean . getScope ( ) ) ; } else if ( grantType == OAuthPropertyBean . REFRESH_GRANT ) { response = tokenClient . refreshAccessToken ( pBean . getAccessURL ( ) , pBean . getClientId ( ) , pBean . getClientSecret ( ) , pBean . getRefreshToken ( ) , pBean . getRedirectUri ( ) , pBean . getScope ( ) ) ; } else { throw new Exception ( "Unknown grantType" ) ; } MessageLog . getInstance ( ) . addMessage ( response ) ; JSONObject jsonObj = new JSONObject ( response . toString ( ) ) ; String accessToken = jsonObj . getString ( "access_token" ) ; OAuthPropertyBean . getInstance ( ) . setAccessToken ( accessToken ) ; if ( jsonObj . has ( "refresh_token" ) ) { String refreshToken = jsonObj . getString ( "refresh_token" ) ; OAuthPropertyBean . getInstance ( ) . setRefreshToken ( refreshToken ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; MessageLog . getInstance ( ) . addMessage ( ioe . getMessage ( ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; MessageLog . getInstance ( ) . addMessage ( e . getMessage ( ) ) ; } return null ; }
va	1	@ Override public long adaptResultSet ( final ResultSet rs ) throws SQLException { if ( rs . next ( ) ) { final long result = ( long ) rs . getObject ( 1 ) ; return result ; } return null ; }
va	1	public MusicInfo ( String songName , String albumName , String singerName ) { if ( Logger . getDebugValue ( ) == 4 ) { System . out . println ( "Music Info parameterized constructor is called" ) ; } this . songName = songName ; this . albumName = albumName ; this . singerName = singerName ; }
va	2	@ Test public final void testdeleteDirectives ( ) { Block blhttp = null ; List < Block > myBlocks = null ; try { Block bl = orc . getRootBlock ( ) ; myBlocks = bl . getBlocks ( ) ; blhttp = myBlocks . get ( myBlocks . size ( ) - 1 ) ; List < Directive > myDirective = blhttp . getDirectives ( ) ; List < Parameter > pa = myDirective . get ( 0 ) . getParameters ( ) ; for ( int i = 0 ; i < pa . size ( ) ; i ++ ) { System . out . println ( pa . get ( i ) + ":" + pa . get ( i ) . toString ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
va	2	private void ping ( ) { synchronized ( CONNECTION_LOCK ) { if ( isConnected ) { try { long latency = getLatency ( ) ; sendPacket ( Packet . createPingPacket ( clientId , latency ) ) ; logger . finest ( "Pinging server [" + latency + "ms]" ) ; } catch ( CouldNotSendPacketException e ) { logger . finest ( "Could not ping server: " + e . getMessage ( ) ) ; } } } }
va	2	private void setCameraPosition ( int x , int y , int z , int horizontal , int vertical ) { int verticalDifference = 2048 - vertical & 7ff ; int horizontalDifference = 2048 - horizontal & 7ff ; int offsetX = 0 ; int offsetZ = 0 ; int offsetY = 600 + vertical * 3 ; if ( verticalDifference != 0 ) { int sine = Model . SINE [ verticalDifference ] ; int cos = Model . COSINE [ verticalDifference ] ; int tmp = offsetZ * cos - offsetY * sine >> 16 ; offsetY = offsetZ * sine + offsetY * cos >> 16 ; offsetZ = tmp ; } if ( horizontalDifference != 0 ) { int sin = Model . SINE [ horizontalDifference ] ; int cos = Model . COSINE [ horizontalDifference ] ; int tmp = offsetY * sin + offsetX * cos >> 16 ; offsetY = offsetY * cos - offsetX * sin >> 16 ; offsetX = tmp ; } cameraPositionX = x - offsetX ; cameraPositionZ = z - offsetZ ; cameraPositionY = y - offsetY ; cameraVerticalRotation = vertical ; cameraHorizontalRotation = horizontal ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( TelaProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( TelaProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( TelaProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( TelaProdutos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new TelaProdutos ( ) . setVisible ( true ) ; } } ) ; }
va	9	public GetNounsAfterPtnReturnValue getNounsAfterPtn ( DataHolder dataholderHandler , String sentence , int startWordIndex ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.getNounsAfterPattern" ) ; myLogger . trace ( String . format ( "enter (%s  %d)" , sentence , startWordIndex ) ) ; String bWord = "" ; List < String > nouns = new ArrayList < String > ( ) ; List < String > nounPtn = new ArrayList < String > ( ) ; List < String > tempWords = new ArrayList < String > ( ) ; tempWords . addAll ( tokenizeText ( sentence , "firstseg" ) ) ; List < String > words = StringUtility . stringArraySplice ( tempWords , startWordIndex , tempWords . size ( ) ) ; myLogger . trace ( "words: " + words ) ; String ptn = this . getPOSptn ( dataholderHandler , words ) ; myLogger . trace ( "ptn: " + ptn ) ; if ( ptn != null ) { Matcher m1 = StringUtility . createMatcher ( ptn , "^([psn]+)" ) ; Matcher m2 = StringUtility . createMatcher ( ptn , "^(\\?+)" ) ; boolean case1 = false ; boolean case2 = false ; int end = - 1 ; if ( m1 . find ( ) ) { case1 = true ; end = m1 . end ( 1 ) ; } if ( m2 . find ( ) ) { case2 = true ; end = m2 . end ( 1 ) ; } if ( case1 || case2 ) { myLogger . trace ( "end: " + end ) ; if ( end < words . size ( ) ) { bWord = words . get ( end ) ; } List < String > nWords = new ArrayList < String > ( ) ; nWords . addAll ( StringUtility . stringArraySplice ( words , 0 , end ) ) ; for ( int i = 0 ; i < nWords . size ( ) ; i ++ ) { String p = ptn . substring ( i , i + 1 ) ; p = StringUtils . equals ( p , "?" ) ? this . myWordFormUtility . checkWN ( nWords . get ( i ) , "pos" ) : p ; if ( StringUtility . createMatcher ( p , "^[psn]+$" ) . find ( ) ) { nouns . add ( nWords . get ( i ) ) ; nounPtn . add ( p ) ; } else { bWord = nWords . get ( i ) ; break ; } } } } GetNounsAfterPtnReturnValue returnValue = new GetNounsAfterPtnReturnValue ( nouns , nounPtn , bWord ) ; myLogger . trace ( "return " + returnValue ) ; return ( returnValue ) ; }
va	4	@ Override public void mouseClicked ( MouseEvent e ) { if ( rectangles != null ) for ( Rectangle r : rectangles . keySet ( ) ) { if ( r . contains ( e . getPoint ( ) ) ) { final JDialog jD = new JDialog ( ) ; jD . setTitle ( "Students in Session:" ) ; JPanel jP = new JPanel ( ) ; jP . setLayout ( new BoxLayout ( jP , BoxLayout . Y_AXIS ) ) ; String result = rectangles . get ( r ) . toString ( ) ; JLabel jL = new JLabel ( result ) ; jP . add ( jL ) ; for ( Student s : rectangles . get ( r ) . getAssigned ( ) ) { result = s . toString ( ) ; jL = new JLabel ( result ) ; jP . add ( jL ) ; } jD . add ( jP ) ; JButton exit = new JButton ( "Exit" ) ; exit . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { jD . setVisible ( false ) ; jD . dispose ( ) ; } } ) ; jP . add ( exit ) ; jD . pack ( ) ; jD . setVisible ( true ) ; break ; } } }
va	0	public String getUsernameRaw ( ) { return usernameRaw ; }
va	4	public void Set_text ( String ByWhat , String element , String text_to_insert , String Jenkins_job ) { if ( ByWhat . equals ( "xp" ) ) { Print_out ( "================== going to type text into-  " + element + " by xpath ..." ) ; driver . findElement ( By . xpath ( element ) ) . clear ( ) ; driver . findElement ( By . xpath ( element ) ) . sendKeys ( text_to_insert ) ; Print_out ( "Success ..." ) ; } else if ( ByWhat . equals ( "id" ) ) { Print_out ( "================== going to type text into- " + element + " by id ..." ) ; driver . findElement ( By . id ( element ) ) . clear ( ) ; driver . findElement ( By . id ( element ) ) . sendKeys ( text_to_insert ) ; Print_out ( "Success ..." ) ; } else if ( ByWhat . equals ( "text" ) ) { Print_out ( "================== going to type text into- " + element + " by link text ..." ) ; driver . findElement ( By . linkText ( element ) ) . clear ( ) ; driver . findElement ( By . linkText ( element ) ) . sendKeys ( text_to_insert ) ; Print_out ( "Success ..." ) ; } else if ( ByWhat . equals ( "css" ) ) { Print_out ( "================== going to type text into- " + element + " by css ..." ) ; driver . findElement ( By . cssSelector ( element ) ) . clear ( ) ; driver . findElement ( By . cssSelector ( element ) ) . sendKeys ( text_to_insert ) ; Print_out ( "Success ..." ) ; } else { Get_screenshot ( Jenkins_job ) ; Print_out ( "" ) ; fail ( "-ERROR!:< " + element + "> DO NOT EXISTS!" ) ; } }
va	1	public List < Integer > stringToList ( String sequence ) { List < Integer > list = new ArrayList ( ) ; StringTokenizer stringTokenizer = new StringTokenizer ( sequence ) ; while ( stringTokenizer . hasMoreElements ( ) ) { String mass = ( String ) stringTokenizer . nextElement ( ) ; list . add ( Integer . valueOf ( mass ) ) ; } return list ; }
va	8	private static int step ( int dir , int rows , int cols , int [ ] dx , int [ ] dy , int [ ] xy , int [ ] [ ] m ) { dir ++ ; if ( dir > 3 ) { dir = 0 ; } final int xc = xy [ 0 ] ; final int yc = xy [ 1 ] ; int x = xc + dx [ dir ] ; int y = yc + dy [ dir ] ; int turns = 0 ; while ( ( x < 0 || x >= rows || y < 0 || y >= cols || m [ x ] [ y ] > 0 ) && turns < 4 ) { turns ++ ; dir -- ; if ( dir < 0 ) { dir = 3 ; } x = xc + dx [ dir ] ; y = yc + dy [ dir ] ; } xy [ 0 ] = x ; xy [ 1 ] = y ; return dir ; }
va	6	public static < E > FunctionExecutor < void > createRemove ( final FeatureDefinition < ? extends Property < ? extends Collection < E >>> propertyDefinition ) { return new FunctionExecutor < void > ( ) { @ Override public void invoke ( FunctionInvocation < void > invocation , Object ... arguments ) throws ExecutorInvocationException { for ( Object element : arguments ) { boolean changed = invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) . remove ( element ) ; if ( changed && element instanceof ChildFeatureHolder ) { ( ( ChildFeatureHolder < ? > ) element ) . setParent ( null ) ; } } return invocation . next ( arguments ) ; } } ; }
va	4	private void initComparePage ( ) { prefComparePathTable . removeAll ( ) ; updateTableSize ( prefComparePathTable ) ; ImageRegistry reg = StartupPlugin . getDefault ( ) . getImageRegistry ( ) ; nodeMap = new TreeMap < String , IEclipsePreferences [ ] > ( ) ; CommonPrefEPFResources prefFiles = StartupPlugin . getDefault ( ) . getCommonPrefFiles ( null ) ; int fileNo = 0 ; int noOfFiles = prefFiles . length ( ) ; for ( Iterator < CommonPrefEPFResource > iter = prefFiles . iterator ( ) ; iter . hasNext ( ) ; ) { CommonPrefEPFResource pf = ( CommonPrefEPFResource ) iter . next ( ) ; TableItem item = new TableItem ( prefComparePathTable , SWT . default ) ; item . setText ( 0 , ( new Integer ( fileNo + 1 ) ) . toString ( ) + ") " + pf . getResourceName ( ) ) ; item . setText ( 1 , ( pf . isForce ( ) ? "force" : "init" ) ) ; if ( pf . exists ( ) ) item . setImage ( reg . get ( StartupPlugin . PREF_FILE_EXIST_IMG ) ) ; else item . setImage ( reg . get ( StartupPlugin . PREF_FILE_NOEXIST_IMG ) ) ; IExportedPreferences prefs = CommonPrefsHelper . readPreferences ( pf ) ; if ( prefs != null ) CommonPrefsHelper . sortPreferences ( prefs , fileNo , noOfFiles , nodeMap ) ; fileNo ++ ; } this . updateCompareTree ( ) ; isComparePageInvalid = false ; }
va	6	public SessionList userList ( ) throws ServerException { SessionList list = null ; try { String inputMessage ; output . writeObject ( Messages . CONTACTLIST ) ; output . flush ( ) ; inputMessage = ( String ) input . readObject ( ) ; if ( ! inputMessage . equals ( Messages . OK ) ) throw new ServerException ( "Unexpected input " + inputMessage ) ; inputMessage = ( String ) input . readObject ( ) ; if ( ! inputMessage . equals ( Messages . BEGINLIST ) ) throw new ServerException ( "Unexpected input " + inputMessage ) ; list = ( SessionList ) input . readObject ( ) ; if ( list == null ) throw new ServerException ( "Unexpected input: null list" ) ; inputMessage = ( String ) input . readObject ( ) ; if ( ! inputMessage . equals ( Messages . OK ) ) throw new ServerException ( "Unexpected input " + inputMessage ) ; } catch ( IOException e ) { throw new ServerException ( e . getMessage ( ) ) ; } catch ( ClassNotFoundException e ) { throw new ServerException ( e . getMessage ( ) ) ; } return list ; }
va	7	public static HashMap < Field , ArrayList < Object >> isConflict ( TaskDispenser td ) { ArrayList < Agent > agents = td . agents ; HashMap < Field , ArrayList < Object >> objectHashMap = new HashMap < Field , ArrayList < Object >> ( ) ; ArrayList < Box > handledBoxes = new ArrayList < Box > ( ) ; for ( Agent a : agents ) { Field agentAt = a . atField ; addObjectToHashMap ( objectHashMap , agentAt , a ) ; Command c = null ; try { c = a . taskQueue . peek ( ) . commandQueue . peek ( ) ; } catch ( Exception e ) { continue ; } if ( c != null ) { Field neighbourField = agentAt . neighbors [ c . dir1 . ordinal ( ) ] ; addObjectToHashMap ( objectHashMap , neighbourField , a ) ; if ( c . cmd . equals ( "Pull" ) ) { Field boxAtField = agentAt . neighbors [ c . dir2 . ordinal ( ) ] ; handledBoxes . add ( ( Box ) boxAtField . object ) ; addObjectToHashMap ( objectHashMap , boxAtField , a ) ; } else if ( c . cmd . equals ( "Push" ) ) { handledBoxes . add ( ( Box ) agentAt . neighbors [ c . dir1 . ordinal ( ) ] . object ) ; Field boxAtField = agentAt . neighbors [ c . dir1 . ordinal ( ) ] . neighbors [ c . dir2 . ordinal ( ) ] ; addObjectToHashMap ( objectHashMap , boxAtField , a ) ; } } } for ( Box b : td . boxes ) { if ( ! handledBoxes . contains ( b ) ) { addObjectToHashMap ( objectHashMap , b . atField , b ) ; } } return objectHashMap ; }
va	4	private synchronized boolean creaPrimoDinosauro ( String token ) throws InvalidTokenException { Giocatore tempGiocatore = getPlayerByToken ( token ) ; if ( tempGiocatore . getRazza ( ) . getTipo ( ) . equals ( c ) ) { if ( tempGiocatore . getRazza ( ) . add ( new Carnivoro ( CommonUtils . getNewRandomCoord ( getMappa ( ) . getLatoDellaMappa ( ) ) ) ) ) { return true ; } } else if ( tempGiocatore . getRazza ( ) . getTipo ( ) . equals ( e ) ) { if ( tempGiocatore . getRazza ( ) . add ( new Erbivoro ( CommonUtils . getNewRandomCoord ( getMappa ( ) . getLatoDellaMappa ( ) ) ) ) ) { return true ; } } return false ; }
va	3	public String uncompressData ( byte [ ] blist , InputStream in ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( extractHeaderBlock ( blist ) ) ; try { byte [ ] buf = new byte [ 1024 ] ; while ( in . available ( ) > 0 ) { int nRead = in . read ( buf ) ; if ( nRead < 0 ) break ; byte [ ] buf2 = new byte [ nRead ] ; System . arraycopy ( buf , 0 , buf2 , 0 , nRead ) ; sb . append ( new String ( buf2 ) ) ; } } catch ( IOException ex ) { Logger . getLogger ( HttpResponse . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return sb . toString ( ) ; }
va	4	void menuLoad_actionPerformed ( ActionEvent e ) { JFileChooser fc = new JFileChooser ( ( currentLibraryFile == null ) ? "." : currentLibraryFile . getAbsolutePath ( ) ) ; fc . setPreferredSize ( new Dimension ( 500 , 700 ) ) ; int ret = fc . showOpenDialog ( FractalShapeMaker . viewer ) ; if ( ret == JFileChooser . CANCEL_OPTION ) return ; if ( ret == JFileChooser . APPROVE_OPTION ) { System . out . println ( "load file = " + fc . getSelectedFile ( ) ) ; try { library . load ( fc . getSelectedFile ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; JOptionPane . showMessageDialog ( FractalShapeMaker . viewer , "Error on load\nException = " + ex ) ; } setLibraryFile ( fc . getSelectedFile ( ) ) ; updateLibrary ( ) ; selectLibraryItem ( libraryViewerList . get ( 0 ) ) ; } }
va	5	private AuthCert dniE ( ) { AuthCert myAuth = null ; JOptionPane . showConfirmDialog ( null , "Introduce un DNI electr\u00F3nico y espera..." , "A la espera de DniE" , JOptionPane . DEFAULT_OPTION , JOptionPane . INFORMATION_MESSAGE , new ImageIcon ( "/img/dnie.png" ) ) ; Provider p = new DnieProvider ( ) ; boolean isdni = false ; Security . addProvider ( p ) ; KeyStore ks = null ; try { ks = KeyStore . getInstance ( "DNI" ) ; ks . load ( null , null ) ; isdni = true ; } catch ( KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException e ) { lblDniError . setText ( "No ha introducido un DniE v\u00E1lido" ) ; lblWrongDNIE . setText ( "No ha introducido un DniE v\u00E1lido" ) ; return myAuth ; } if ( isdni == true ) { X509Certificate authCertCompleto = null ; try { KeyStore . Entry entry = ks . getEntry ( "CertAutenticacion" , null ) ; KeyStore . PrivateKeyEntry pkEntry = ( KeyStore . PrivateKeyEntry ) entry ; authCertCompleto = ( X509Certificate ) pkEntry . getCertificate ( ) ; } catch ( KeyStoreException | NoSuchAlgorithmException | UnrecoverableEntryException | es . gob . jmulticard . ui . passwordcallback . CancelledOperationException e ) { isdni = false ; lblDniError . setText ( "Operaci\u00F3n cancelada introduciendo la clave del DniE" ) ; lblWrongDNIE . setText ( "Operaci\u00F3n cancelada introduciendo la clave del DniE" ) ; return myAuth ; } if ( isdni == true ) { try { authCertCompleto . checkValidity ( ) ; myAuth = new AuthCert ( authCertCompleto ) ; return myAuth ; } catch ( CertificateExpiredException | CertificateNotYetValidException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; isdni = false ; lblDniError . setText ( "Error desconocido" ) ; lblWrongDNIE . setText ( "Error desconocido" ) ; return myAuth ; } } } lblDniError . setText ( "Error desconocido" ) ; lblWrongDNIE . setText ( "Error desconocido" ) ; return myAuth ; }
va	2	public Attributes ( byte [ ] record , int attrLen , int attrPos , int attrBytes ) throws Exception { if ( attrBytes != 2 && attrBytes != 4 ) throw new AttributeException ( String . format ( "Attributes needs attrBytes 2 or 4 (not %d" , attrBytes ) ) ; decode ( record , attrLen , attrPos , attrBytes ) ; }
va	5	public static int designs ( int maxHeight , int minWidth , int totalHeight , int totalWidth ) { int count = 0 ; int i = 1 ; while ( true ) { if ( totalHeight / ( i + 1 ) <= maxHeight ) if ( totalWidth / i >= minWidth ) { if ( totalHeight % ( i + 1 ) == 0 && totalWidth % i == 0 ) count ++ ; } else { break ; } i ++ ; } return count ; }
va	0	@ Override public void keyReleased ( KeyEvent arg0 ) { }
va	1	public Query appendIf ( final String name , final Integer value ) throws UnsupportedEncodingException { if ( value != null ) { append ( name , value . toString ( ) ) ; } return this ; }
va	0	public void setSexe ( String sexe ) { this . sexe = sexe ; }
va	5	public void target ( ) { double myX = bot . getX ( ) ; double myY = bot . getY ( ) ; double absoluteBearing = bot . getHeadingRadians ( ) + bot . enemy . bearingRadians ; double enemyX = bot . getX ( ) + bot . enemy . distance * Math . sin ( absoluteBearing ) ; double enemyY = bot . getY ( ) + bot . enemy . distance * Math . cos ( absoluteBearing ) ; double enemyHeading = bot . enemy . headingRadians ; double enemyVelocity = bot . enemy . velocity ; double deltaTime = 0 ; double battleFieldHeight = bot . getBattleFieldHeight ( ) , battleFieldWidth = bot . getBattleFieldWidth ( ) ; double predictedX = enemyX , predictedY = enemyY ; while ( ( ++ deltaTime ) * ( 20.0 - 3.0 * bot . bulletPower ) < Point2D . double . distance ( myX , myY , predictedX , predictedY ) ) { predictedX += Math . sin ( enemyHeading ) * enemyVelocity ; predictedY += Math . cos ( enemyHeading ) * enemyVelocity ; if ( predictedX < 18.0 || predictedY < 18.0 || predictedX > battleFieldWidth - 18.0 || predictedY > battleFieldHeight - 18.0 ) { predictedX = Math . min ( Math . max ( 18.0 , predictedX ) , battleFieldWidth - 18.0 ) ; predictedY = Math . min ( Math . max ( 18.0 , predictedY ) , battleFieldHeight - 18.0 ) ; break ; } } double theta = Utils . normalAbsoluteAngle ( Math . atan2 ( predictedX - bot . getX ( ) , predictedY - bot . getY ( ) ) ) ; bot . setTurnRadarRightRadians ( Utils . normalRelativeAngle ( absoluteBearing - bot . getRadarHeadingRadians ( ) ) ) ; bot . setTurnGunRightRadians ( Utils . normalRelativeAngle ( theta - bot . getGunHeadingRadians ( ) ) ) ; }
va	6	public boolean postMortem ( PostMortem pm ) { MapKeep that = ( MapKeep ) pm ; if ( this . length != that . length ) { JSONzip . log ( this . length + " <> " + that . length ) ; return false ; } for ( int i = 0 ; i < this . length ; i += 1 ) { boolean b ; if ( this . list [ i ] instanceof Kim ) { b = ( ( Kim ) this . list [ i ] ) . equals ( that . list [ i ] ) ; } else { Object o = this . list [ i ] ; Object q = that . list [ i ] ; if ( o instanceof Number ) { o = o . toString ( ) ; } if ( q instanceof Number ) { q = q . toString ( ) ; } b = o . equals ( q ) ; } if ( ! b ) { JSONzip . log ( "\n[" + i + "]\n " + this . list [ i ] + "\n " + that . list [ i ] + "\n " + this . uses [ i ] + "\n " + that . uses [ i ] ) ; return false ; } } return true ; }
va	6	@ SuppressWarnings ( "unchecked" ) public < T > Serializer < ? super T > getSerializerForClass ( class < T > clazz ) { if ( clazz . isArray ( ) ) { return ARRAY_SERIALIZER ; } else if ( serializerClassMap . containsKey ( clazz ) ) { return serializerClassMap . get ( clazz ) ; } else if ( ! clazz . isEnum ( ) && clazz . getSuperclass ( ) != null && clazz . getSuperclass ( ) != Object . class ) { return getSerializerForClass ( clazz . getSuperclass ( ) ) ; } throw new IllegalArgumentException ( "Type not supported " + clazz . getName ( ) ) ; }
va	2	public void bufferedContent ( ) { if ( this . isBuffered . compareAndSet ( false , true ) ) { this . currentByteBuffer = null ; this . currentBufferQueue = new ConcurrentLinkedQueue < ByteBuffer > ( ) ; ByteBuffer headerBuffer = processBuffered ( this . header ) ; ByteBuffer bodyBuffer = processBuffered ( headerBuffer , this . body ) ; if ( bodyBuffer != null ) { this . currentBufferQueue . add ( bodyBuffer ) ; } } }
va	8	public Point ( String arg ) { int degre_lat = 0 , minute_lat = 0 , sec_lat = 0 , dix_sec_lat = 0 , cent_sec_lat = 0 ; int degre_long = 0 , minute_long = 0 , sec_long = 0 , dix_sec_long = 0 , cent_sec_long = 0 ; String direction_lat = "" , direction_long ; Scanner s = new Scanner ( arg ) ; s . findInLine ( Point . regexp_point + "$" ) ; MatchResult result = s . match ( ) ; degre_lat = Integer . parseInt ( result . group ( 1 ) ) ; if ( result . group ( 2 ) != null ) { minute_lat = Integer . parseInt ( result . group ( 2 ) ) ; if ( result . group ( 3 ) != null ) { sec_lat = Integer . parseInt ( result . group ( 3 ) ) ; if ( result . group ( 4 ) != null ) { dix_sec_lat = Integer . parseInt ( result . group ( 4 ) ) ; if ( result . group ( 5 ) != null ) { cent_sec_lat = Integer . parseInt ( result . group ( 5 ) ) ; } } } } direction_lat = result . group ( 6 ) ; degre_long = Integer . parseInt ( result . group ( 7 ) ) ; if ( result . group ( 8 ) != null ) { minute_long = Integer . parseInt ( result . group ( 8 ) ) ; if ( result . group ( 9 ) != null ) { sec_long = Integer . parseInt ( result . group ( 9 ) ) ; if ( result . group ( 10 ) != null ) { dix_sec_long = Integer . parseInt ( result . group ( 10 ) ) ; if ( result . group ( 5 ) != null ) { cent_sec_long = Integer . parseInt ( result . group ( 11 ) ) ; } } } } direction_long = result . group ( 12 ) ; s . close ( ) ; this . longitude = new Longitude ( degre_long , minute_long , sec_long , dix_sec_long , cent_sec_long , direction_long ) ; this . latitude = new Latitude ( degre_lat , minute_lat , sec_lat , dix_sec_lat , cent_sec_lat , direction_lat ) ; }
va	8	private ArrayList < Loc > getMoves ( Loc r ) { ArrayList < Loc > sts = new ArrayList < Loc > ( ) ; Loc up = new Loc ( r . x , r . y - 1 ) ; Loc down = new Loc ( r . x , r . y + 1 ) ; Loc left = new Loc ( r . x - 1 , r . y ) ; Loc right = new Loc ( r . x + 1 , r . y ) ; if ( r . y > 0 && ! map . isCollision ( up ) ) { sts . add ( up ) ; } if ( r . y < map . gridSize - 1 && ! map . isCollision ( down ) ) { sts . add ( down ) ; } if ( r . x > 0 && ! map . isCollision ( left ) ) { sts . add ( left ) ; } if ( r . x < map . gridSize - 1 && ! map . isCollision ( right ) ) { sts . add ( right ) ; } return sts ; }
va	9	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { NanoPost np ; byte [ ] parentHash = EncryptionProvider . EMPTY_HASH_SHA256 ; String parentHashStr = edParentHash . getText ( ) ; if ( ! parentHashStr . trim ( ) . isEmpty ( ) ) { if ( ( parentHashStr . length ( ) == EncryptionProvider . SHA_256_HASH_SIZE_BYTES * 2 ) && parentHashStr . matches ( "[a-f0-9]+" ) ) { parentHash = ByteUtils . stringToBytes ( parentHashStr ) ; } } if ( ! edAttachFile . getText ( ) . isEmpty ( ) ) { File attachFile = new File ( edAttachFile . getText ( ) ) ; if ( ! attachFile . exists ( ) ) { JOptionPane . showMessageDialog ( this , "Selected attach file does not exist" , "Error" , JOptionPane . ERROR_MESSAGE ) ; return ; } np = NanoPostFactory . createNanoPost ( txtPostText . getText ( ) , parentHash , attachFile ) ; } else { np = NanoPostFactory . createNanoPost ( txtPostText . getText ( ) , parentHash , null ) ; } File containerFile ; if ( rbRandomContainer . isSelected ( ) ) { containerFile = this . getRandomContainerPNG ( ) ; if ( containerFile == null ) { JOptionPane . showMessageDialog ( this , "There is no any PNG file in folder " + MainClass . CONTAINERS_DIR , "Error" , JOptionPane . ERROR_MESSAGE ) ; return ; } } else { containerFile = new File ( edContainerFile . getText ( ) ) ; } if ( ! containerFile . exists ( ) ) { JOptionPane . showMessageDialog ( this , "Selected container file does not exists." , "Error" , JOptionPane . ERROR_MESSAGE ) ; return ; } File outputFile = null ; NanoPost nanoPost = null ; try { outputFile = new File ( MainClass . OUTBOX_DIR + System . getProperty ( "file.separator" ) + System . currentTimeMillis ( ) + ".png" ) ; ImageUtils . encodeIntoImage ( containerFile , outputFile , np . getAsBytes ( ) , edBoardCode . getText ( ) ) ; byte [ ] dataBytes = ImageUtils . tryToDecodeSteganoImage ( ByteUtils . readBytesFromFile ( outputFile ) , edBoardCode . getText ( ) ) ; nanoPost = NanoPostFactory . getNanoPostFromBytes ( dataBytes , true ) ; nanoPost . setSourceImageData ( ByteUtils . readBytesFromFile ( outputFile ) ) ; nanoPost . saveToFile ( true ) ; nanoPost . clearAllBinaryData ( ) ; nanoPost = null ; dataBytes = null ; } catch ( MalformedNanoPostException | IOException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException ex ) { JOptionPane . showMessageDialog ( null , ex . getLocalizedMessage ( ) , "An error occured" , JOptionPane . ERROR_MESSAGE ) ; } finally { outputFile . delete ( ) ; } }
va	9	private void validateType ( String key , JsonValue val , Type wanted ) { boolean valid = true ; if ( val . isString ( ) && wanted != Type . STRING ) valid = false ; else if ( val . isNumber ( ) && ( wanted != Type . INTEGER || wanted != Type . double ) ) valid = false ; else if ( val . isObject ( ) && wanted != Type . OBJECT ) valid = false ; else if ( val . isArray ( ) && wanted != Type . ARRAY ) valid = false ; if ( ! valid ) throw new IllegalArgumentException ( "Key" + ( key == null ? "" : " \"" + key + "\"" ) + " is not of type " + wanted . name ( ) ) ; }
va	4	@ Override public void ProcessCommand ( class < ? extends ISneekCommand > Command ) { if ( Command == SneekCommand . EXIT . GetCommand ( ) ) this . StopServer ( ) ; if ( Command == SneekCommand . START . GetCommand ( ) ) this . PrintLine ( "'start' is a server-only command" , Color . red ) ; if ( Command == SneekCommand . RESET . GetCommand ( ) ) this . PrintLine ( "'reset' is a server-only command" , Color . red ) ; }
va	2	@ Override public short getShort ( long i ) { if ( ptr != 0 ) { return ( short ) ( Utilities . UNSAFE . getDouble ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( short ) data [ 0 ] ; } else { return ( short ) data [ ( int ) i ] ; } } }
va	5	private void scheduleSchemaForProcessing ( URL schemaLocation ) { if ( cache . hasSchema ( schemaLocation ) ) { return ; } for ( ProcessingEntry it : schemasToCompile ) { if ( it . schemaLocation . toString ( ) . equals ( schemaLocation . toString ( ) ) ) { return ; } } try { JsonParser parser = jsonFactory . createJsonParser ( schemaLocation ) ; try { JsonNode rawSchema = parser . readValueAsTree ( ) ; schemasToCompile . add ( new ProcessingEntry ( schemaLocation , rawSchema ) ) ; } finally { parser . close ( ) ; } } catch ( JsonParseException jpe ) { throw new IllegalArgumentException ( "The schema at location " + schemaLocation . toString ( ) + " contains invalid JSON" , jpe ) ; } catch ( IOException ioe ) { throw new IllegalArgumentException ( "Could not retrieve schema from " + schemaLocation . toString ( ) , ioe ) ; } }
va	3	public String hurt ( int value ) { String s ; int damage ; if ( armor != null ) { damage = value - ( armor . getValue ( ) * defence ) ; } else { damage = value ; } if ( damage <= 0 ) { damage = 0 ; s = "nothing happend" ; } else { s = damage + " damage taken by " + name ; } health = health - damage ; if ( health <= 0 ) { health = 0 ; s = s + "\n" + name + " has died" ; } return s ; }
va	1	public boolean setGroup ( String newGroup ) { if ( Group . existGroup ( newGroup ) ) { group = newGroup . toLowerCase ( ) ; dirty = true ; return true ; } return false ; }
va	7	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == convert ) { try { Converter . convertFile ( inFileName . getText ( ) , outFileName . getText ( ) , encodingIn . getSelectedItem ( ) . toString ( ) , encodingOut . getSelectedItem ( ) . toString ( ) , bom . isSelected ( ) , convertChars . getSelectedItem ( ) . equals ( "Simplified to Traditional" ) , convertChars . getSelectedItem ( ) . equals ( "Traditional to Simplified" ) ) ; status . setText ( "Success: " + inFileName . getText ( ) + " -> " + outFileName . getText ( ) ) ; } catch ( IOException ex ) { showError ( ex . getMessage ( ) ) ; } } else if ( e . getSource ( ) == chooseIn ) { File f = CharApp . getInstance ( ) . selectFile ( "txt" , "Text files" , false , false ) ; if ( f != null ) { inFileName . setText ( f . getAbsolutePath ( ) ) ; } } else if ( e . getSource ( ) == chooseOut ) { File f = CharApp . getInstance ( ) . selectFile ( "txt" , "Text files" , false , true ) ; if ( f != null ) { outFileName . setText ( f . getAbsolutePath ( ) ) ; } } else if ( e . getSource ( ) == encodingOut ) { bom . setEnabled ( encodingOut . getSelectedItem ( ) == "UTF-8" ) ; } }
va	6	public void move ( ) { if ( deadTime > 0 ) { deadTime -- ; if ( deadTime == 0 ) { deadTime = 1 ; for ( int i = 0 ; i < 8 ; i ++ ) { world . addSprite ( new Sparkle ( ( int ) ( x + Math . random ( ) * 16 - 8 ) + 4 , ( int ) ( y - Math . random ( ) * 8 ) + 4 , ( float ) ( Math . random ( ) * 2 - 1 ) , ( float ) Math . random ( ) * - 1 , 0 , 1 , 5 ) ) ; } spriteContext . removeSprite ( this ) ; } x += xa ; y += ya ; ya *= 0.95 ; ya += 1 ; return ; } tick ++ ; if ( y >= yStart ) { y = yStart ; int xd = ( int ) ( Math . abs ( world . mario . x - x ) ) ; jumpTime ++ ; if ( jumpTime > 40 && xd > 24 ) { ya = - 8 ; } else { ya = 0 ; } } else { jumpTime = 0 ; } y += ya ; ya *= 0.9 ; ya += 0.1f ; xPic = ( ( tick / 2 ) & 1 ) * 2 + ( ( tick / 6 ) & 1 ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ReturnItem . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ReturnItem . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ReturnItem . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ReturnItem . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ReturnItem ( ) . setVisible ( true ) ; } } ) ; }
va	6	public static BColor color ( String hexCol ) { if ( hexCol == null || hexCol . isEmpty ( ) ) { return null ; } int [ ] rgba = new int [ ] { 0 , 0 , 0 , 255 } ; if ( hexCol . startsWith ( "#" ) ) { hexCol = hexCol . substring ( 1 ) ; } int anzahl ; if ( hexCol . length ( ) % 3 == 0 ) { anzahl = 3 ; } else if ( hexCol . length ( ) % 4 == 0 ) { anzahl = 4 ; } else { throw new ColorFormatException ( "Invalid color format: " + hexCol ) ; } for ( int i = 0 ; i < anzahl ; i ++ ) { rgba [ i ] = Integer . parseInt ( hexCol . substring ( 0 , 2 ) , 16 ) ; hexCol = hexCol . substring ( 2 ) ; } return new BColor ( rgba [ 0 ] , rgba [ 1 ] , rgba [ 2 ] , rgba [ 3 ] ) ; }
va	0	public Material ( ReflectanceCoefficient kAmbient , ReflectanceCoefficient kDiffuse , ReflectanceCoefficient kSpecular , BufferedImage texture ) { this . color = DEFAULT_COLOR ; this . kAmbient = kAmbient ; this . kDiffuse = kDiffuse ; this . kSpecular = kSpecular ; this . texture = texture ; }
va	4	@ Override public void processFailureOfSnake ( Player player , GameController controller ) { if ( player == null ) { Player playerTwo = controller . getPlayerTwo ( ) ; Player playerOne = controller . getPlayerOne ( ) ; applyPenaltyToPlayer ( playerOne ) ; applyPenaltyToPlayer ( playerTwo ) ; if ( playerOne . getLifesLeft ( ) <= 0 || playerTwo . getLifesLeft ( ) <= 0 ) { controller . updatePlayerScoreLabel ( ) ; controller . endGame ( ) ; } } else { applyPenaltyToPlayer ( player ) ; if ( player . getLifesLeft ( ) <= 0 ) { controller . updatePlayerScoreLabel ( ) ; controller . endGame ( ) ; } } controller . updatePlayerScoreLabel ( ) ; }
va	8	@ Override public void run ( ) { System . out . println ( "Starting statistics run" ) ; long time = System . currentTimeMillis ( ) ; List < Individual > indv = new ArrayList < Individual > ( ) ; for ( int k = 0 ; k < INDIVIDUALS ; k ++ ) { System . out . println ( "Evolving tracker " + ( k + 1 ) ) ; List < Individual > pop = problem . createPopulation ( POPULATION ) ; for ( int j = 0 ; j < GENERATIONS ; j ++ ) { if ( j % 10 == 0 ) System . out . println ( "Ping from generation " + j + " evolving tracker " + ( k + 1 ) ) ; try { pop = evo . runGeneration ( pop ) ; Map m = evo . getStatistics ( ) . get ( evo . getStatistics ( ) . size ( ) - 1 ) ; double max = double . parseDouble ( m . get ( "maxFitness" ) . toString ( ) ) ; if ( max == 1.0 ) { System . out . println ( "Fitness of 1.0 reached after " + j + " generations" ) ; break ; } } catch ( Exception e ) { } } List < Map > stats = evo . getStatistics ( ) ; Individual temp = ( Individual ) stats . get ( stats . size ( ) - 1 ) . get ( "bestIndividual" ) ; indv . add ( temp ) ; try { System . out . println ( "Tracker number " + k + " evolved a fitness of " + temp . fitness ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } long time2 = System . currentTimeMillis ( ) - time ; System . out . println ( "Run time so far: " + ( ( time2 / 1000 ) / 60 ) + " minutes and " + ( ( time2 / 1000 ) % 60 ) + " seconds" ) ; } double totalScore = 0 ; System . out . println ( "Running " + SIMULATIONRUNS + " simulations per tracker" ) ; int c = 0 ; for ( Individual iIndividual : indv ) { System . out . println ( "Simulating tracker " + c ++ ) ; double score = 0 ; for ( int i = 0 ; i < SIMULATIONRUNS ; i ++ ) { ITracker tr = ( ITracker ) iIndividual . phenotype ( ) ; Simulation sim = new Simulation ( ) ; CtrnnProblem ct = ( CtrnnProblem ) problem ; score += sim . simulate ( tr , new HitAwarder ( ) , null , ct . getObjectType ( ) ) ; } totalScore += score / SIMULATIONRUNS ; } double percentScore = totalScore / indv . size ( ) ; System . out . println ( "Total score of " + INDIVIDUALS + " individuals after " + SIMULATIONRUNS + " Simualtions :\n" + percentScore ) ; time -= System . currentTimeMillis ( ) ; System . out . println ( "Total run time: " + ( ( - time / 1000 ) / 60 ) + " minutes and " + ( ( - time / 1000 ) % 60 ) + " seconds" ) ; }
va	5	private static void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( "[" ) ; } if ( option . getOpt ( ) != null ) { buff . append ( "-" ) . append ( option . getOpt ( ) ) ; } else { buff . append ( "--" ) . append ( option . getLongOpt ( ) ) ; } if ( option . hasArg ( ) && option . hasArgName ( ) ) { buff . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } if ( ! required ) { buff . append ( "]" ) ; } }
