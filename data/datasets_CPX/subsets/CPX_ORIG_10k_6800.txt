va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DicView . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DicView . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DicView . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DicView . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { } } ) ; }
va	1	public boolean remove ( Object entry ) { if ( contains ( entry ) ) { SubMap . this . remove ( ( ( Entry < K , V > ) entry ) . getKey ( ) ) ; return true ; } else { return false ; } }
va	2	public int confCol ( int col , Sudoku s ) { boolean checkList [ ] = { false , false , false , false , false , false , false , false , false } ; int num ; int conf = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { num = Math . abs ( s . rows [ i ] [ col ] ) ; if ( checkList [ num - 1 ] ) conf ++ ; else checkList [ num - 1 ] = true ; } return conf ; }
va	6	public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int tc = Integer . parseInt ( in . readLine ( ) ) ; while ( tc -- > 0 ) { String a = in . readLine ( ) ; String b = in . readLine ( ) ; BigInteger [ ] [ ] res = new BigInteger [ a . length ( ) + 1 ] [ b . length ( ) + 1 ] ; for ( int i = 0 ; i <= a . length ( ) ; i ++ ) { for ( int j = 0 ; j < b . length ( ) ; j ++ ) res [ i ] [ j ] = BigInteger . ZERO ; res [ i ] [ b . length ( ) ] = BigInteger . ONE ; } for ( int i = a . length ( ) - 1 ; i >= 0 ; i -- ) for ( int j = b . length ( ) - 1 ; j >= 0 ; j -- ) { res [ i ] [ j ] = res [ i + 1 ] [ j ] ; if ( a . charAt ( i ) == b . charAt ( j ) ) res [ i ] [ j ] = res [ i ] [ j ] . add ( res [ i + 1 ] [ j + 1 ] ) ; } System . out . println ( res [ 0 ] [ 0 ] ) ; } }
va	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
va	5	private void bConfirmarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( "" . equals ( txtCodigo . getText ( ) ) ) { if ( JOptionPane . showConfirmDialog ( this , "Confirma o cadastro?" ) == JOptionPane . YES_OPTION ) { String sql = "insert into curso (cur_descricao  cur_qtdemodulos) values ('@1' '@2')" ; sql = sql . replace ( "@1" , txtNome . getText ( ) ) ; sql = sql . replace ( "@2" , txtQtdModulo . getText ( ) ) ; if ( ! banco . Banco . con . manipular ( sql ) ) { JOptionPane . showMessageDialog ( this , "Problemas ao cadastrar" ) ; } else { alteraModo ( e ) ; } } } else if ( JOptionPane . showConfirmDialog ( this , "Confirma a altera\u00E7\u00E3o?" ) == JOptionPane . YES_OPTION ) { String sql = "update curso set cur_descricao='@1' cur_qtdemodulos='@2' where cur_codigo = @5" ; sql = sql . replace ( "@1" , txtNome . getText ( ) ) ; sql = sql . replace ( "@2" , txtQtdModulo . getText ( ) ) ; sql = sql . replace ( "@5" , txtCodigo . getText ( ) ) ; if ( ! banco . Banco . con . manipular ( sql ) ) { JOptionPane . showMessageDialog ( this , "Problemas ao atualizar" ) ; } else { alteraModo ( e ) ; } } }
va	8	public void averageParametersSyn ( int T ) { backup = params ; double [ ] avgParams = new double [ size ] ; for ( int i = 0 ; i < size ; ++ i ) { avgParams [ i ] = ( params [ i ] * ( T + 1 ) - total [ i ] ) / T ; } params = avgParams ; backupL = paramsL ; double [ ] avgParamsL = new double [ sizeL ] ; for ( int i = 0 ; i < sizeL ; ++ i ) { avgParamsL [ i ] = ( paramsL [ i ] * ( T + 1 ) - totalL [ i ] ) / T ; } paramsL = avgParamsL ; backupU = U ; double [ ] [ ] avgU = new double [ rank ] [ N ] ; for ( int i = 0 ; i < rank ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) { avgU [ i ] [ j ] = ( U [ i ] [ j ] * ( T + 1 ) - totalU [ i ] [ j ] ) / T ; } U = avgU ; backupV = V ; double [ ] [ ] avgV = new double [ rank ] [ M ] ; for ( int i = 0 ; i < rank ; ++ i ) for ( int j = 0 ; j < M ; ++ j ) { avgV [ i ] [ j ] = ( V [ i ] [ j ] * ( T + 1 ) - totalV [ i ] [ j ] ) / T ; } V = avgV ; backupW = W ; double [ ] [ ] avgW = new double [ rank ] [ D ] ; for ( int i = 0 ; i < rank ; ++ i ) for ( int j = 0 ; j < D ; ++ j ) { avgW [ i ] [ j ] = ( W [ i ] [ j ] * ( T + 1 ) - totalW [ i ] [ j ] ) / T ; } W = avgW ; }
va	7	public List < List < String >> get ( String fieldNames ) { List < List < String >> fieldsValues = null ; if ( fieldNames != null && ! fieldNames . trim ( ) . isEmpty ( ) ) { fieldsValues = new ArrayList < List < String >> ( ) ; String [ ] fields = null ; if ( fieldNames . matches ( "^(\\w+)$" ) ) { fields = new String [ ] { fieldNames } ; } else if ( fieldNames . matches ( "^[\\w+ \\s+\\w+]+$" ) ) { fields = fieldNames . split ( " \\s+" ) ; } else { } for ( T model : this ) { List < String > fieldValue = new ArrayList < String > ( ) ; for ( String field : fields ) { if ( model . get ( field ) != null ) { fieldValue . add ( ( model . get ( field ) ) . toString ( ) ) ; } else { fieldValue . add ( ( String ) model . get ( field ) ) ; } } fieldsValues . add ( fieldValue ) ; } } return fieldsValues ; }
va	5	public static void main ( String [ ] args ) { if ( args . length != 2 ) { System . out . println ( "useage:" ) ; System . out . println ( "\tCompiler.jar input.ts output.cas" ) ; return ; } try { List < Token > ts = Lexer . read ( args [ 0 ] ) ; if ( ! Parser . parse ( ts ) ) { System . out . println ( "NG" ) ; return ; } if ( ! Checker . parse ( ts ) ) { System . out . print ( "NG" ) ; return ; } PascalLike pl = jp . angeworm . ensyuD . compiler . Parser . parse ( ts ) ; String code = jp . angeworm . ensyuD . compiler . Compile . compile ( pl ) ; write ( args [ 1 ] , code ) ; } catch ( IOException e ) { System . err . println ( "no input file " + args [ 0 ] + "." ) ; System . out . println ( e . getLocalizedMessage ( ) ) ; } catch ( RuntimeException e ) { System . out . println ( "NG" ) ; System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } }
va	4	@ Override public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( object == null || object . getClass ( ) != this . getClass ( ) ) { return false ; } VGoverriddenPoint2D smth = ( VGoverriddenPoint2D ) object ; return smth . x == x && smth . y == y ; }
va	4	protected void createBuffers ( SSLSession session ) { int appBufferMax = session . getApplicationBufferSize ( ) ; int netBufferMax = session . getPacketBufferSize ( ) ; if ( inData == null ) { inData = ByteBuffer . allocate ( appBufferMax ) ; outCrypt = ByteBuffer . allocate ( netBufferMax ) ; inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } else { if ( inData . capacity ( ) != appBufferMax ) inData = ByteBuffer . allocate ( appBufferMax ) ; if ( outCrypt . capacity ( ) != netBufferMax ) outCrypt = ByteBuffer . allocate ( netBufferMax ) ; if ( inCrypt . capacity ( ) != netBufferMax ) inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } inData . rewind ( ) ; inData . flip ( ) ; inCrypt . rewind ( ) ; inCrypt . flip ( ) ; outCrypt . rewind ( ) ; outCrypt . flip ( ) ; }
va	3	public int obtemIndexSelecLocalizacao ( ) { try { DBLocalizacao dbLocalizacao = new DBLocalizacao ( ) ; dbLocalizacao . select ( "*" , " order by idlocalizacao asc" ) ; int idBD = 0 ; int cont = 1 ; while ( dbLocalizacao . getResultSet ( ) . next ( ) ) { if ( cont == ComboBoxLocalizacao . getSelectedIndex ( ) ) { idBD = dbLocalizacao . getResultSet ( ) . getInt ( "idlocalizacao" ) ; } cont ++ ; } return idBD ; } catch ( Exception erro ) { } return 0 ; }
va	2	private int getSelectedCount ( ) { int selectedCount = 0 ; List < INDIElement > list = getElementsAsList ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { INDISwitchElement el = ( INDISwitchElement ) list . get ( i ) ; if ( el . getValue ( ) == SwitchStatus . ON ) { selectedCount ++ ; } } return selectedCount ; }
va	5	private static < T > String makePrimitiveStrings ( String className , T value ) { StringBuilder result = new StringBuilder ( ) ; if ( className . equals ( "java.lang.Short" ) ) return result + value . toString ( ) + "S" ; else if ( className . equals ( "java.lang.Long" ) ) return result + value . toString ( ) + "L" ; else if ( className . equals ( "java.lang.Float" ) ) return result + value . toString ( ) + "F" ; else if ( className . equals ( "java.math.BigInteger" ) ) return result + value . toString ( ) + "BigInteger" ; else if ( className . equals ( "java.math.BigDecimal" ) ) return result + value . toString ( ) + "BigDecimal" ; else return result + value . toString ( ) ; }
va	6	public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( getOptions ( ) . hasOption ( str ) && str . startsWith ( "-" ) ) { iter . previous ( ) ; break ; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( opt . getValues ( ) == null && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( opt ) ; } }
va	3	public int size ( ) { int size = 0 ; for ( int layerIndex = 0 ; layerIndex < layers . size ( ) - 1 ; layerIndex ++ ) { Layer layer = layers . get ( layerIndex ) ; for ( Neuron neuron : layer . getNeurons ( ) ) { if ( layer . getOutGoingConnections ( ) != null ) size += layer . getOutGoingConnections ( ) . get ( neuron ) . size ( ) ; } } return size ; }
va	2	public int getArrayIndex ( String f , String [ ] sa ) { for ( int i = 0 ; i < sa . length ; i ++ ) { if ( sa [ i ] . equals ( f ) ) return i ; } return 0 ; }
va	0	public VeterinariaTest ( ) { veterinaria = new Veterinaria ( ) ; }
va	7	private static void calc ( ) { String [ ] classes = { "happiness" , "like" , "anger" , "fear" , "sadness" , "disgust" , "surprise" } ; Iterator < String > itWords = setWords . iterator ( ) ; int count = 0 ; try { OutputStreamWriter w2 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramhappiness.csv" ) , "UTF-8" ) ; OutputStreamWriter w3 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramlike.csv" ) , "UTF-8" ) ; OutputStreamWriter w4 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramanger.csv" ) , "UTF-8" ) ; OutputStreamWriter w5 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramfear.csv" ) , "UTF-8" ) ; OutputStreamWriter w6 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramsadness.csv" ) , "UTF-8" ) ; OutputStreamWriter w7 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramdisgust.csv" ) , "UTF-8" ) ; OutputStreamWriter w8 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/classCHI/bigramsurprise.csv" ) , "UTF-8" ) ; Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( "happiness" , "" ) ; map . put ( "like" , "" ) ; map . put ( "anger" , "" ) ; map . put ( "fear" , "" ) ; map . put ( "sadness" , "" ) ; map . put ( "disgust" , "" ) ; map . put ( "surprise" , "" ) ; while ( itWords . hasNext ( ) ) { String word = itWords . next ( ) ; System . out . println ( ++ count + ":" + word + "of" + setWords . size ( ) ) ; String classs = "" ; for ( int i = 0 ; i < classes . length ; i ++ ) { classs = classes [ i ] ; int a = 0 , b = 0 , c = 0 , d = 0 ; Iterator < String > it = setSentences . iterator ( ) ; while ( it . hasNext ( ) ) { String [ ] its = it . next ( ) . split ( "\t" ) ; if ( its [ 0 ] . contains ( classs ) ) { if ( its [ 1 ] . contains ( word ) ) { a ++ ; } else { c ++ ; } } else { if ( its [ 1 ] . contains ( word ) ) { b ++ ; } else { d ++ ; } } } double chi = 1.0 * ( a * d - b * c ) * ( a * d - b * c ) / ( ( a + b ) * ( c + d ) ) ; map . put ( classs , map . get ( classs ) + word + " " + chi + "\r\n" ) ; } } w2 . write ( map . get ( "happiness" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w3 . write ( map . get ( "like" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w4 . write ( map . get ( "anger" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w5 . write ( map . get ( "fear" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w6 . write ( map . get ( "sadness" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w7 . write ( map . get ( "disgust" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w8 . write ( map . get ( "surprise" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; System . out . println ( setSentences . size ( ) ) ; w2 . close ( ) ; w3 . close ( ) ; w4 . close ( ) ; w5 . close ( ) ; w6 . close ( ) ; w7 . close ( ) ; w8 . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	4	static public void ver ( int i , int j , int salto ) { if ( salto == 0 ) System . out . print ( "a(" + i + " " + j + ") = " ) ; else if ( salto == 1 ) System . out . print ( " a(" + i + " " + j + ") " ) ; else if ( salto == 2 ) System . out . print ( " * a(" + i + " " + j + ") " ) ; else if ( salto == 3 ) System . out . print ( " - a(" + i + " " + j + ") " ) ; else System . out . print ( ") / a(" + i + " " + j + ") " ) ; }
va	7	private RequirementLink parseSecurityGoalLinkInfo ( List < String > factors ) { Element source = findElementById ( factors . get ( 4 ) ) ; Element target = findElementById ( factors . get ( 5 ) ) ; if ( target == null || source == null ) { return null ; } RequirementLink new_link = new RequirementLink ( ) ; new_link . setId ( factors . get ( 1 ) ) ; new_link . setSource ( source ) ; new_link . setTarget ( target ) ; source . getOutLinks ( ) . add ( new_link ) ; target . getInLinks ( ) . add ( new_link ) ; if ( ( factors . get ( 2 ) . equals ( "SharpArrow" ) || factors . get ( 2 ) . equals ( "StickArrow" ) || factors . get ( 2 ) . equals ( "Arrow" ) ) & ! new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . REFINE . name ( ) ) ; new_link . getTarget ( ) . refine_links . add ( new_link ) ; } else if ( factors . get ( 2 ) . equals ( "SharpArrow" ) & new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE_ARROW . name ( ) ) ; new_link . setRemark ( InfoEnum . LinkRemark . REDUNDANT . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "NoHead" ) & factors . get ( 6 ) . equals ( "NoLabel" ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) ) ; } else { CommandPanel . logger . severe ( "Unknown links cannot be imported" ) ; } return new_link ; }
va	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Lobby . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Lobby . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Lobby . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Lobby . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } final AnimatedJabriscaJPanel board = new GameBoard ( ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { ( ( JabriscaJPanel ) board ) . setVisible ( true ) ; } } ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } board . animate ( "MoveCardAnimation" , "boardGame_myCard1" , "boardGame_player1Card" ) ; board . animate ( "MoveCardAnimation" , "boardGame_myCard2" , "boardGame_player2Card" ) ; board . animate ( "MoveCardAnimation" , "boardGame_myCard3" , "boardGame_player3Card" ) ; }
va	5	public static String round ( double value , int scale ) { String digit [ ] = String . valueOf ( value ) . split ( "\\." ) ; int length = digit . length ; if ( length <= 1 ) { StringBuilder build = new StringBuilder ( digit [ 0 ] ) . append ( "." ) ; for ( int i = 0 ; i < scale ; i ++ ) { build . append ( "0" ) ; } return build . toString ( ) ; } else if ( digit . length == 2 && ( length = digit [ 1 ] . length ( ) ) < scale ) { StringBuilder build = new StringBuilder ( digit [ 0 ] ) . append ( "." ) . append ( digit [ 1 ] ) ; scale = scale - length ; for ( int i = 0 ; i < scale ; i ++ ) { build . append ( "0" ) ; } return build . toString ( ) ; } return BigDecimal . valueOf ( value ) . setScale ( scale , BigDecimal . ROUND_HALF_UP ) . toString ( ) ; }
va	4	@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; if ( this . escenario == null ) return ; g . setColor ( BgColor ) ; g . fillRect ( 0 , 0 , this . getWidth ( ) , this . getHeight ( ) ) ; for ( int f = 0 ; f < this . escenario . getAlto ( ) ; f ++ ) { for ( int c = 0 ; c < this . escenario . getAncho ( ) ; c ++ ) { Bloque bloque = this . escenario . getBloque ( f , c ) ; if ( bloque . getTipo ( ) == TipoBloque . VACIO ) continue ; int x = c * TamanoCelda ; int y = f * TamanoCelda ; g . setColor ( bloque . getColor ( ) ) ; g . fillRect ( x , y , TamanoCelda , TamanoCelda ) ; g . setColor ( Color . BLACK ) ; g . drawRect ( x , y , TamanoCelda , TamanoCelda ) ; } } }
va	6	public String navigate ( String direction ) { Room nextRoom = null ; try { if ( direction . matches ( "NORD" ) ) nextRoom = room . north ( ) ; else if ( direction . matches ( "SUD" ) ) nextRoom = room . south ( ) ; else if ( direction . matches ( "EST" ) ) nextRoom = room . east ( ) ; else if ( direction . matches ( "OUEST" ) ) nextRoom = room . west ( ) ; } catch ( RoomNotAccessibleException e ) { return e . getMessage ( ) ; } if ( nextRoom != null ) { room = nextRoom ; return room . look ( ) ; } else return "Vous ne pouvez pas aller dans cette direction." ; }
va	5	@ Override public boolean include ( javax . swing . RowFilter . Entry < ? extends ModelPrenotazioni , ? extends Integer > entry ) { ModelPrenotazioni model = entry . getModel ( ) ; if ( model == null ) System . out . println ( "modello prenotazione vuoto" ) ; System . out . println ( "entry identifier:" + entry . getIdentifier ( ) ) ; Prenotazione prenotazione = ( Prenotazione ) model . getItem ( entry . getIdentifier ( ) ) ; if ( prenotazione != null && prenotazione . cliente . getId ( ) == this . userId ) return true ; System . out . println ( "oggetto prenotazione vuoto" ) ; return false ; }
va	8	public static void doWithFields ( class < ? > clazz , FieldCallback fc , FieldFilter ff ) throws IllegalArgumentException { class < ? > targetClass = clazz ; do { Field [ ] fields = targetClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . doWith ( field ) ; } catch ( IllegalAccessException ex ) { throw new IllegalStateException ( "Shouldn't be illegal to access field '" + field . getName ( ) + "': " + ex ) ; } } targetClass = targetClass . getSuperclass ( ) ; } while ( targetClass != null && targetClass != Object . class ) ; }
va	4	private void NioServerCreation ( ) { factory = new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( ) , Executors . newCachedThreadPool ( ) ) ; bootstrap = new ServerBootstrap ( factory ) ; bootstrap . setPipelineFactory ( pipelineFactory ) ; bootstrapSsl = new ServerBootstrap ( factory ) ; bootstrapSsl . setPipelineFactory ( sslPipelineFactory ) ; ServerBootstrap selectedBootstrap ; for ( Listen listen : configService . getConfig ( ) . getListens ( ) . getListen ( ) ) { selectedBootstrap = bootstrap ; if ( listen . isSsl ( ) ) { selectedBootstrap = bootstrapSsl ; } if ( StringUtils . isNotEmpty ( listen . getInterface ( ) ) && ! "*" . equals ( listen . getInterface ( ) ) ) { selectedBootstrap . bind ( new InetSocketAddress ( listen . getInterface ( ) , listen . getPort ( ) ) ) ; logger . info ( ">> Gircos listening on port " + listen . getPort ( ) + " [interface=" + listen . getInterface ( ) + "] [ssl=" + listen . isSsl ( ) + "]" ) ; } else { selectedBootstrap . bind ( new InetSocketAddress ( listen . getPort ( ) ) ) ; logger . info ( ">> Gircos listening on port " + listen . getPort ( ) + " [interface=all] [ssl=" + listen . isSsl ( ) + "]" ) ; } } }
va	0	@ SuppressWarnings ( "rawtypes" ) public static ArrayList getEnemys ( ) { return MovingEntitys ; }
va	7	@ Override public void onCommand ( SMTPSession session ) throws SMTPException { if ( ! session . checkCommandOrder ( ) ) { throw new SMTPException ( "503 send HELO or ehlo first" ) ; } session . resetState ( ) ; String senderAddress = StringUtil . getAddressFromArgument ( session . getCurRemainCommandStr ( ) ) ; String remainCommand = StringUtil . getRemainCommand ( session . getCurRemainCommandStr ( ) ) ; if ( remainCommand == null || ! remainCommand . toUpperCase ( ) . equals ( "FROM" ) || senderAddress == null ) { throw new SMTPException ( "501 Syntax error in parameters or arguments" ) ; } if ( ! CheckUtil . isCorrectPath ( senderAddress ) ) { throw new SMTPException ( "501 Syntax error in parameters or arguments" ) ; } senderAddress = senderAddress . substring ( 1 , senderAddress . length ( ) - 1 ) ; emailName = StringUtil . getEmailName ( senderAddress ) ; emailDomain = StringUtil . getEmailDomain ( senderAddress ) ; if ( ! emailName . equals ( session . getUserName ( ) ) ) { throw new SMTPException ( "553 mail from must equal authorized user" ) ; } if ( CheckUtil . isSameDomain ( emailDomain , session . getDomainList ( ) ) ) { session . setLastCommandName ( ) ; responseStr = "250 Sender <" + senderAddress + "> OK" ; session . sendResponse ( responseStr ) ; } else { session . getLogger ( ) . info ( "\u53D1\u4EF6\u4EBA\u4E0E\u670D\u52A1\u5668\u5728\u4E0D\u540C\u4E00\u4E2A\u57DF" ) ; throw new SMTPException ( "553 mail from must equal authorized user" ) ; } }
va	6	private static class < ? > determineType ( Collection < Object > parameters ) { class < ? > typeIn ; typeIn = Object . class ; int i = 0 ; for ( Object p : parameters ) { class < ? > clazz = p . getClass ( ) ; if ( i == 0 ) typeIn = clazz ; if ( ! clazz . equals ( typeIn ) ) { typeIn = Object . class ; break ; } } return typeIn ; }
va	1	@ Override public void run ( ) { if ( ServerUpdateChecker . Instance ( ) . GetResult ( ) ) new ServerUpdateFrame ( ) ; }
va	8	private void test ( BinaryTreeNode < Integer , String > tree , Order order , ImplType implType , String expected ) { Visitor visitor = new Visitor ( ) ; if ( implType == ImplType . RECUSRIVE ) { TreeTraverse < Integer , String > treeTraverse = new TreeTraverse < > ( tree ) ; if ( order == Order . PREORDER ) { treeTraverse . preorderTraverse ( visitor ) ; } else if ( order == Order . INORDER ) { treeTraverse . inorderTraverse ( visitor ) ; } else if ( order == Order . POSTORDER ) { treeTraverse . postorderTraverse ( visitor ) ; } } else if ( implType == ImplType . ITERATIVE ) { IterativeTreeTraverse < Integer , String > treeTraverse = new IterativeTreeTraverse < > ( tree ) ; if ( order == Order . PREORDER ) { treeTraverse . preorderTraverse ( visitor ) ; } else if ( order == Order . INORDER ) { treeTraverse . inorderTraverse ( visitor ) ; } else if ( order == Order . POSTORDER ) { treeTraverse . postorderTraverse ( visitor ) ; } } String actual = visitor . getTraceString ( ) ; assert . assertEquals ( expected , actual ) ; }
va	8	public void keyPress ( int keyCode ) { if ( keyCode == KeyEvent . VK_SPACE ) { running = ! running ; if ( running ) { start ( ) ; } CharProps . getProperties ( ) . setProperty ( "reminder.start" , "" + running ) ; CharProps . storeProps ( ) ; } else if ( keyCode == KeyEvent . VK_R ) { randomOrder = ! randomOrder ; CharProps . getProperties ( ) . setProperty ( "reminder.random" , "" + randomOrder ) ; CharProps . storeProps ( ) ; } else if ( keyCode == KeyEvent . VK_LEFT ) { prev ( false ) ; } else if ( keyCode == KeyEvent . VK_RIGHT ) { next ( false ) ; } else if ( keyCode == KeyEvent . VK_BACK_SPACE ) { prev ( ) ; } else if ( keyCode == KeyEvent . VK_S ) { currentRecord . setExtra1 ( "rem=s" + currentRecord . getExtra1 ( ) ) ; next ( true ) ; } else if ( keyCode == KeyEvent . VK_HOME ) { currentRecord = record . getRecordNumber ( 0 , false ) ; index = 0 ; } refresh ( ) ; }
va	9	private void setNextTokens ( int nextType , int [ ] [ ] nextTokensPosition , TokenNext [ ] [ ] nextTokens ) { switch ( nextType ) { case 1 : setPositionForCase1 ( nextTokensPosition , 0 ) ; break ; case 2 : setPositionForCase2 ( nextTokensPosition , 0 ) ; break ; case 3 : setPositionForCase3 ( nextTokensPosition , 0 ) ; break ; case 4 : setPositionForCase4 ( nextTokensPosition , 0 ) ; break ; case 5 : setPositionForCase5 ( nextTokensPosition , 0 ) ; break ; case 6 : setPositionForCase6 ( nextTokensPosition , 0 ) ; break ; default : setPositionForCase7 ( nextTokensPosition , 0 ) ; } for ( int i = 0 ; i < nextTokens . length ; i ++ ) { for ( int j = 0 ; j < nextTokens [ i ] . length ; j ++ ) { nextTokens [ i ] [ j ] . setType ( 0 ) ; } } for ( int i = 0 ; i < nextTokensPosition . length ; i ++ ) { int x = nextTokensPosition [ i ] [ 0 ] ; int y = nextTokensPosition [ i ] [ 1 ] ; nextTokens [ y ] [ x ] . setType ( nextType ) ; } }
va	3	public void addDialPanel ( final String remoteChannel , final String localChannel ) { if ( remoteChannel != null && localChannel != null ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { String remoteNumber = remoteChannel . substring ( 0 , remoteChannel . indexOf ( "-" ) ) ; JPanel panel = new JPanel ( ) ; panel . add ( HangupButton ( remoteChannel ) ) ; label1 . setPreferredSize ( new Dimension ( 200 , 70 ) ) ; label1 . setFont ( timeFont ) ; label1 . setAlignmentX ( CENTER_ALIGNMENT ) ; addPanel ( remoteNumber , label1 , panel ) ; if ( startTimerFlag == false ) { StartCallTime ( ) ; startTimerFlag = true ; } setSize ( new Dimension ( 400 , 600 ) ) ; } } ) ; } else { removeFromList ( this ) ; setVisible ( false ) ; dispose ( ) ; } }
va	9	public void run ( ) { for ( int k = 0 ; k < T ; ++ k ) { for ( ; ; ) { for ( int i = 0 ; i < T ; ++ i ) visx [ i ] = false ; for ( int i = 0 ; i < T ; ++ i ) visy [ i ] = false ; if ( findPath ( k ) ) break ; double minVal = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) for ( int j = 0 ; j < T ; ++ j ) if ( ! visy [ j ] ) { double va = x [ i ] + y [ j ] - f [ i * T + j ] ; minVal = minVal > va ? va : minVal ; } Utils . assert ( minVal > 0.0 && minVal != double . POSITIVE_INFINITY ) ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) x [ i ] -= minVal ; for ( int i = 0 ; i < T ; ++ i ) if ( visy [ i ] ) y [ i ] += minVal ; } } }
va	8	private boolean IsJobConfValid ( JobConf jobConf ) { if ( jobConf . getInputPath ( ) == null ) return false ; if ( jobConf . getOutputPath ( ) == null ) return false ; if ( jobConf . getMapperClassName ( ) == null ) return false ; if ( jobConf . getReducerClassName ( ) == null ) return false ; if ( jobConf . getPartitionerClassName ( ) == null ) return false ; if ( jobConf . getInputFormatClassName ( ) == null ) return false ; if ( jobConf . getOutputFormatClassName ( ) == null ) return false ; if ( jobConf . getReducerNum ( ) == 0 ) return false ; return true ; }
va	9	public void actionPerformed ( java . awt . event . ActionEvent actionEvent ) { topx1 += 2 ; topy1 = 0 ; topx2 += 2 ; topy2 = 0 ; bottomx1 ++ ; bottomy1 = panelHeight ; bottomx2 ++ ; bottomy2 = panelHeight ; int moveAmount = 11 ; int moveAmount2 = 6 ; if ( vertx1 > panelLength || vertx2 > panelLength ) { movingForward = false ; vertx1 -= moveAmount ; vertx2 -= moveAmount ; } else if ( vertx1 < 0 || vertx2 < 0 ) { movingForward = true ; vertx1 += moveAmount ; vertx2 += moveAmount ; } else if ( movingForward ) { vertx1 += moveAmount ; vertx2 += moveAmount ; } else { vertx1 -= moveAmount ; vertx2 -= moveAmount ; } if ( vert2x1 > panelLength || vert2x2 > panelLength ) { movingForward2 = false ; vert2x1 -= moveAmount2 ; vert2x2 -= moveAmount2 ; } else if ( vert2x1 < 0 || vert2x2 < 0 ) { movingForward2 = true ; vert2x1 += moveAmount2 ; vert2x2 += moveAmount2 ; } else if ( movingForward2 ) { vert2x1 += moveAmount2 ; vert2x2 += moveAmount2 ; } else { vert2x1 -= moveAmount2 ; vert2x2 -= moveAmount2 ; } repaint ( ) ; }
va	8	public void endRound ( ) { int winnersInd = 0 ; numberOfRounds ++ ; cardsPlayedInRound = 0 ; ItalianDeckCard winnersCard = currentStack [ winnersInd ] ; int score = 0 ; for ( int i = 0 ; i < currentStack . length ; i ++ ) { int comp = BriscaCardComparator . compare ( winnersCard , currentStack [ i ] , this . life . getSuit ( ) ) ; if ( comp > 0 ) { winnersCard = currentStack [ i ] ; winnersInd = i ; } else if ( comp == 0 ) { } score += currentStack [ i ] . getRank ( ) . getValue ( ) ; } int count = 0 ; for ( ItalianDeckCard card : playerStacks [ winnersInd ] ) { if ( card == null ) break ; count ++ ; } for ( ItalianDeckCard card : currentStack ) playerStacks [ winnersInd ] [ count ++ ] = card ; players [ winnersInd ] . addScore ( score ) ; for ( int i = 0 ; i < turns . length ; i ++ ) { int value = ( i + winnersInd ) % 4 + 1 ; turns [ i ] = value ; } isRoundOver = false ; if ( numberOfRounds == MAX_NUMBER_OF_ROUNDS ) { isGameOver = true ; } }
va	2	public boolean setInfo ( String node , String data ) { if ( info == null ) { info = new HashMap < String , String > ( ) ; } if ( data == null ) { info . remove ( node ) ; dirty ( ) ; return true ; } info . put ( node , data ) ; dirty ( ) ; return true ; }
va	7	@ Override public boolean equals ( Object object ) { if ( object == null || object . getClass ( ) != getClass ( ) ) return false ; Fraction other = ( Fraction ) object ; if ( this . intNumerator == other . intNumerator && this . rootNumerator == other . rootNumerator && this . numMultiplier == other . numMultiplier && this . intDenom == other . intDenom && this . rootDenom == other . rootDenom ) return true ; return false ; }
va	2	protected void childClosing ( ) { setClosable ( wasCloseable ) ; getGlassPane ( ) . setVisible ( false ) ; if ( focusOwner != null ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { moveToFront ( ) ; setSelected ( true ) ; focusOwner . grabFocus ( ) ; } catch ( PropertyVetoException ex ) { Logger . getLogger ( ModalityInternalFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; focusOwner . grabFocus ( ) ; } getGlassPane ( ) . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; setChildFrame ( null ) ; }
va	6	private void initialize ( ) { frmCarPurchase = new JFrame ( ) ; frmCarPurchase . setTitle ( "Car Purchase" ) ; frmCarPurchase . setBounds ( 100 , 100 , 600 , 400 ) ; frmCarPurchase . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frmCarPurchase . getContentPane ( ) . setLayout ( new CardLayout ( 0 , 0 ) ) ; final JPanel panelStep1 = new JPanel ( ) ; frmCarPurchase . getContentPane ( ) . add ( panelStep1 , "name_93955994796721" ) ; panelStep1 . setLayout ( null ) ; panelStep1 . setVisible ( true ) ; final JPanel panelStep2 = new JPanel ( ) ; frmCarPurchase . getContentPane ( ) . add ( panelStep2 , "name_93958192370748" ) ; panelStep2 . setLayout ( null ) ; panelStep2 . setVisible ( false ) ; final JPanel panelStep3 = new JPanel ( ) ; frmCarPurchase . getContentPane ( ) . add ( panelStep3 , "name_93960816529787" ) ; panelStep3 . setLayout ( null ) ; panelStep3 . setVisible ( false ) ; final JPanel panelResults = new JPanel ( ) ; frmCarPurchase . getContentPane ( ) . add ( panelResults , "name_95310782296790" ) ; panelResults . setLayout ( null ) ; panelResults . setVisible ( false ) ; JLabel lblDescription = new JLabel ( "Select general car features:" ) ; lblDescription . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lblDescription . setBounds ( 10 , 11 , 157 , 14 ) ; panelStep1 . add ( lblDescription ) ; JLabel lblCategory = new JLabel ( "Category (Select up to 3 categories):" ) ; lblCategory . setBounds ( 10 , 46 , 217 , 14 ) ; panelStep1 . add ( lblCategory ) ; cmbBx_Criterion1 = new JComboBox ( ) ; cmbBx_Criterion1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBx_Criterion1 . getSelectedIndex ( ) != 0 ) { String criterion1 = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; c1 = carCriterionParse ( criterion1 ) ; } } } ) ; cmbBx_Criterion1 . setModel ( new DefaultComboBoxModel ( CarCriterion . values ( ) ) ) ; cmbBx_Criterion1 . setSelectedIndex ( 1 ) ; cmbBx_Criterion1 . setBounds ( 96 , 71 , 114 , 20 ) ; panelStep1 . add ( cmbBx_Criterion1 ) ; cmbBx_Criterion2 = new JComboBox ( ) ; cmbBx_Criterion2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBx_Criterion2 . getSelectedIndex ( ) != 0 ) { String criterion2 = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; c2 = carCriterionParse ( criterion2 ) ; } } } ) ; cmbBx_Criterion2 . setModel ( new DefaultComboBoxModel ( CarCriterion . values ( ) ) ) ; cmbBx_Criterion2 . setBounds ( 96 , 102 , 114 , 20 ) ; panelStep1 . add ( cmbBx_Criterion2 ) ; cmbBx_Criterion3 = new JComboBox ( ) ; cmbBx_Criterion3 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBx_Criterion2 . getSelectedIndex ( ) != 0 ) { String criterion3 = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; c3 = carCriterionParse ( criterion3 ) ; } } } ) ; cmbBx_Criterion3 . setModel ( new DefaultComboBoxModel ( CarCriterion . values ( ) ) ) ; cmbBx_Criterion3 . setBounds ( 96 , 135 , 114 , 20 ) ; panelStep1 . add ( cmbBx_Criterion3 ) ; JLabel lblCarType = new JLabel ( "Car type:" ) ; lblCarType . setBounds ( 10 , 176 , 54 , 14 ) ; panelStep1 . add ( lblCarType ) ; cmbBx_DomainType = new JComboBox ( ) ; cmbBx_DomainType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String carDomainType = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; d1 = carDomainTypeParse ( carDomainType ) ; } } ) ; cmbBx_DomainType . setModel ( new DefaultComboBoxModel ( CarDomainType . values ( ) ) ) ; cmbBx_DomainType . setBounds ( 96 , 198 , 114 , 20 ) ; panelStep1 . add ( cmbBx_DomainType ) ; JLabel lblBudget = new JLabel ( "Budget: " ) ; lblBudget . setBounds ( 314 , 46 , 72 , 14 ) ; panelStep1 . add ( lblBudget ) ; final ActionListener actionlistener = new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { String budget = new String ( "" + ( ( JRadioButton ) event . getSource ( ) ) . getText ( ) ) ; minBudget = minValueParse ( budget ) ; maxBudget = maxValueParse ( budget ) ; } } ; rdbtnLowCost = new JRadioButton ( "1000 - 50000" ) ; rdbtnLowCost . setBounds ( 372 , 70 , 120 , 23 ) ; rdbtnLowCost . addActionListener ( actionlistener ) ; panelStep1 . add ( rdbtnLowCost ) ; rdbtnAverageCost = new JRadioButton ( "50000 - 120000" ) ; rdbtnAverageCost . setBounds ( 372 , 101 , 120 , 23 ) ; rdbtnAverageCost . addActionListener ( actionlistener ) ; panelStep1 . add ( rdbtnAverageCost ) ; rdbtnExpensive = new JRadioButton ( "120000 - 200000" ) ; rdbtnExpensive . setBounds ( 372 , 132 , 120 , 23 ) ; rdbtnExpensive . addActionListener ( actionlistener ) ; panelStep1 . add ( rdbtnExpensive ) ; group = new ButtonGroup ( ) ; group . add ( rdbtnLowCost ) ; group . add ( rdbtnAverageCost ) ; group . add ( rdbtnExpensive ) ; final JProgressBar progressBar = new JProgressBar ( ) ; progressBar . setValue ( 33 ) ; progressBar . setBounds ( 10 , 337 , 200 , 14 ) ; panelStep1 . add ( progressBar ) ; final JButton btnNext = new JButton ( "Next" ) ; btnNext . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Step1UserRequest userRequest = new Step1UserRequest ( c1 , c2 , c3 , d1 , minBudget , maxBudget ) ; List1 = handleGUIStep1UserRequest ( userRequest , Cars ) ; ListSorterByEvalution ( List1 ) ; model = new CarTableModel ( List1 ) ; table . setModel ( model ) ; panelStep2 . setVisible ( true ) ; panelStep1 . setVisible ( false ) ; } } ) ; btnNext . setBounds ( 420 , 328 , 72 , 23 ) ; panelStep1 . add ( btnNext ) ; final JButton btnFinish = new JButton ( "Finish" ) ; btnFinish . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Step1UserRequest userRequest = new Step1UserRequest ( c1 , c2 , c3 , d1 , minBudget , maxBudget ) ; List1 = handleGUIStep1UserRequest ( userRequest , Cars ) ; ListSorterByEvalution ( List1 ) ; model = new CarTableModel ( List1 ) ; table . setModel ( model ) ; panelResults . setVisible ( true ) ; panelStep1 . setVisible ( false ) ; } } ) ; btnFinish . setBounds ( 502 , 328 , 72 , 23 ) ; panelStep1 . add ( btnFinish ) ; JLabel lblDescription_1 = new JLabel ( "Select more specific car features:" ) ; lblDescription_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lblDescription_1 . setBounds ( 10 , 11 , 182 , 14 ) ; panelStep2 . add ( lblDescription_1 ) ; JLabel lblAverageBurning = new JLabel ( "Average burning cost per 100 km:" ) ; lblAverageBurning . setBounds ( 10 , 49 , 200 , 14 ) ; panelStep2 . add ( lblAverageBurning ) ; final ActionListener actionlistener2 = new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { String averageBurning = new String ( "" + ( ( JRadioButton ) event . getSource ( ) ) . getText ( ) ) ; minBurning = minValueParse ( averageBurning ) ; maxBurning = maxValueParse ( averageBurning ) ; } } ; rdbtnLowBurn = new JRadioButton ( "0.1 - 60" ) ; rdbtnLowBurn . setBounds ( 67 , 80 , 109 , 23 ) ; rdbtnLowBurn . addActionListener ( actionlistener2 ) ; panelStep2 . add ( rdbtnLowBurn ) ; rdbtnAverageBurn = new JRadioButton ( "60 - 100" ) ; rdbtnAverageBurn . setBounds ( 67 , 106 , 109 , 23 ) ; rdbtnAverageBurn . addActionListener ( actionlistener2 ) ; panelStep2 . add ( rdbtnAverageBurn ) ; rdbtnHighBurn = new JRadioButton ( "100 - 200" ) ; rdbtnHighBurn . setBounds ( 67 , 132 , 109 , 23 ) ; rdbtnHighBurn . addActionListener ( actionlistener2 ) ; panelStep2 . add ( rdbtnHighBurn ) ; group2 = new ButtonGroup ( ) ; group2 . add ( rdbtnLowBurn ) ; group2 . add ( rdbtnAverageBurn ) ; group2 . add ( rdbtnHighBurn ) ; JLabel lblCarSize = new JLabel ( "Car size:" ) ; lblCarSize . setBounds ( 10 , 186 , 56 , 14 ) ; panelStep2 . add ( lblCarSize ) ; cmbBxCarType = new JComboBox ( ) ; cmbBxCarType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBxCarType . getSelectedIndex ( ) != 0 ) { String carType = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; ct = carSizeParse ( carType ) ; } } } ) ; cmbBxCarType . setModel ( new DefaultComboBoxModel ( CarType . values ( ) ) ) ; cmbBxCarType . setBounds ( 44 , 216 , 132 , 20 ) ; panelStep2 . add ( cmbBxCarType ) ; JLabel lblCarHistory = new JLabel ( "Car history(km):" ) ; lblCarHistory . setBounds ( 277 , 49 , 102 , 14 ) ; panelStep2 . add ( lblCarHistory ) ; final ActionListener actionlistener3 = new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { String carHistory = new String ( "" + ( ( JRadioButton ) event . getSource ( ) ) . getText ( ) ) ; minKm = minValueParse ( carHistory ) ; maxKm = maxValueParse ( carHistory ) ; } } ; final JRadioButton rdbtnNew = new JRadioButton ( "0 - 15000" ) ; rdbtnNew . setBounds ( 312 , 80 , 109 , 23 ) ; rdbtnNew . addActionListener ( actionlistener3 ) ; panelStep2 . add ( rdbtnNew ) ; final JRadioButton rdbtnUsedModerately = new JRadioButton ( "15000 - 100000" ) ; rdbtnUsedModerately . setBounds ( 312 , 106 , 122 , 23 ) ; rdbtnUsedModerately . addActionListener ( actionlistener3 ) ; panelStep2 . add ( rdbtnUsedModerately ) ; final JRadioButton rdbtnUsedAlot = new JRadioButton ( "100000 - 500000" ) ; rdbtnUsedAlot . setBounds ( 312 , 132 , 122 , 23 ) ; rdbtnUsedAlot . addActionListener ( actionlistener3 ) ; panelStep2 . add ( rdbtnUsedAlot ) ; group3 = new ButtonGroup ( ) ; group3 . add ( rdbtnNew ) ; group3 . add ( rdbtnUsedModerately ) ; group3 . add ( rdbtnUsedAlot ) ; JLabel lblEngineCapacity = new JLabel ( "Engine capacity & fuel type:" ) ; lblEngineCapacity . setBounds ( 274 , 186 , 160 , 14 ) ; panelStep2 . add ( lblEngineCapacity ) ; final ActionListener actionlistener4 = new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { String engineCapacity = new String ( "" + ( ( JRadioButton ) event . getSource ( ) ) . getText ( ) ) ; minCapacity = minValueParse ( engineCapacity ) ; maxCapacity = maxValueParse ( engineCapacity ) ; } } ; final JRadioButton rdbtnLowCapacity = new JRadioButton ( "0.5 - 1.4" ) ; rdbtnLowCapacity . setBounds ( 277 , 215 , 85 , 23 ) ; rdbtnLowCapacity . addActionListener ( actionlistener4 ) ; panelStep2 . add ( rdbtnLowCapacity ) ; final JRadioButton rdbtnAvegCapacity = new JRadioButton ( "1.5 - 3.0" ) ; rdbtnAvegCapacity . setBounds ( 277 , 248 , 85 , 23 ) ; rdbtnAvegCapacity . addActionListener ( actionlistener4 ) ; panelStep2 . add ( rdbtnAvegCapacity ) ; final JRadioButton rdbtnHighCapacity = new JRadioButton ( "3.0 - 10.0" ) ; rdbtnHighCapacity . setBounds ( 277 , 284 , 85 , 23 ) ; rdbtnHighCapacity . addActionListener ( actionlistener4 ) ; panelStep2 . add ( rdbtnHighCapacity ) ; group4 = new ButtonGroup ( ) ; group4 . add ( rdbtnLowCapacity ) ; group4 . add ( rdbtnAvegCapacity ) ; group4 . add ( rdbtnHighCapacity ) ; cmbBxFuelType = new JComboBox ( ) ; cmbBxFuelType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBxFuelType . getSelectedIndex ( ) != 0 ) { String fuelType = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; fuelTp = fuelTypeParse ( fuelType ) ; } } } ) ; cmbBxFuelType . setModel ( new DefaultComboBoxModel ( FuelType . values ( ) ) ) ; cmbBxFuelType . setBounds ( 420 , 216 , 96 , 20 ) ; panelStep2 . add ( cmbBxFuelType ) ; final JProgressBar progressBar_1 = new JProgressBar ( ) ; progressBar_1 . setValue ( 66 ) ; progressBar_1 . setBounds ( 10 , 337 , 200 , 14 ) ; panelStep2 . add ( progressBar_1 ) ; final JButton btnBack = new JButton ( "Back" ) ; btnBack . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { panelStep1 . setVisible ( true ) ; panelStep2 . setVisible ( false ) ; } } ) ; btnBack . setBounds ( 337 , 328 , 72 , 23 ) ; panelStep2 . add ( btnBack ) ; final JButton btnNext_1 = new JButton ( "Next" ) ; btnNext_1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Step2UserRequest userRequest2 = new Step2UserRequest ( minBurning , maxBurning , ct , minKm , maxKm , minCapacity , maxCapacity , fuelTp ) ; List2 = handleGUIStep2UserRequest ( userRequest2 , List1 ) ; ListSorterByEvalution ( List2 ) ; model = new CarTableModel ( List2 ) ; table . setModel ( model ) ; panelStep3 . setVisible ( true ) ; panelStep2 . setVisible ( false ) ; } } ) ; btnNext_1 . setBounds ( 420 , 328 , 72 , 23 ) ; panelStep2 . add ( btnNext_1 ) ; final JButton btnFinish_1 = new JButton ( "Finish" ) ; btnFinish_1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Step2UserRequest userRequest2 = new Step2UserRequest ( minBurning , maxBurning , ct , minKm , maxKm , minCapacity , maxCapacity , fuelTp ) ; List2 = handleGUIStep2UserRequest ( userRequest2 , List1 ) ; ListSorterByEvalution ( List2 ) ; model = new CarTableModel ( List2 ) ; table . setModel ( model ) ; panelResults . setVisible ( true ) ; panelStep2 . setVisible ( false ) ; } } ) ; btnFinish_1 . setBounds ( 502 , 328 , 72 , 23 ) ; panelStep2 . add ( btnFinish_1 ) ; JLabel lblDescription_2 = new JLabel ( "Select concrete car features:" ) ; lblDescription_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lblDescription_2 . setBounds ( 10 , 11 , 160 , 14 ) ; panelStep3 . add ( lblDescription_2 ) ; JLabel lblCarSpecialFeatures = new JLabel ( "Special features:" ) ; lblCarSpecialFeatures . setBounds ( 10 , 49 , 107 , 14 ) ; panelStep3 . add ( lblCarSpecialFeatures ) ; SelectionManager manager = new SelectionManager ( ) ; MultiRenderer renderer = new MultiRenderer ( manager ) ; cmbBxCarFeature = new JComboBox ( ) ; cmbBxCarFeature . setModel ( new DefaultComboBoxModel ( CarFeature . values ( ) ) ) ; cmbBxCarFeature . setBounds ( 77 , 75 , 175 , 20 ) ; cmbBxCarFeature . addActionListener ( manager ) ; cmbBxCarFeature . setRenderer ( renderer ) ; panelStep3 . add ( cmbBxCarFeature ) ; JLabel lblCarBrand = new JLabel ( "Car brand:" ) ; lblCarBrand . setBounds ( 10 , 138 , 81 , 14 ) ; panelStep3 . add ( lblCarBrand ) ; cmbBxCarBrand = new JComboBox ( ) ; cmbBxCarBrand . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( cmbBxCarBrand . getSelectedIndex ( ) != 0 ) { String carBrand = new String ( "" + ( ( JComboBox ) e . getSource ( ) ) . getSelectedItem ( ) ) ; cb = carBrandParse ( carBrand ) ; } } } ) ; cmbBxCarBrand . setModel ( new DefaultComboBoxModel ( CarBrand . values ( ) ) ) ; cmbBxCarBrand . setBounds ( 77 , 164 , 133 , 20 ) ; panelStep3 . add ( cmbBxCarBrand ) ; final ActionListener actionlistener5 = new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { String YoProd = new String ( "" + ( ( JRadioButton ) event . getSource ( ) ) . getText ( ) ) ; minYear = minValueParse ( YoProd ) ; maxYear = maxValueParse ( YoProd ) ; } } ; JLabel lblYearOfProduction = new JLabel ( "Year of production:" ) ; lblYearOfProduction . setBounds ( 367 , 49 , 125 , 14 ) ; panelStep3 . add ( lblYearOfProduction ) ; final JRadioButton rdbtnAncient = new JRadioButton ( "1960 - 1980" ) ; rdbtnAncient . setBounds ( 441 , 74 , 109 , 23 ) ; rdbtnAncient . addActionListener ( actionlistener5 ) ; panelStep3 . add ( rdbtnAncient ) ; final JRadioButton rdbtnOld = new JRadioButton ( "1981 - 2000" ) ; rdbtnOld . setBounds ( 441 , 103 , 109 , 23 ) ; rdbtnOld . addActionListener ( actionlistener5 ) ; panelStep3 . add ( rdbtnOld ) ; final JRadioButton rdbtnNewCar = new JRadioButton ( "2001 - 2014" ) ; rdbtnNewCar . setBounds ( 441 , 134 , 109 , 23 ) ; rdbtnNewCar . addActionListener ( actionlistener5 ) ; panelStep3 . add ( rdbtnNewCar ) ; group5 = new ButtonGroup ( ) ; group5 . add ( rdbtnAncient ) ; group5 . add ( rdbtnOld ) ; group5 . add ( rdbtnNewCar ) ; final JProgressBar progressBar_2 = new JProgressBar ( ) ; progressBar_2 . setValue ( 99 ) ; progressBar_2 . setBounds ( 10 , 337 , 200 , 14 ) ; panelStep3 . add ( progressBar_2 ) ; final JButton btnBack_1 = new JButton ( "Back" ) ; btnBack_1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { panelStep2 . setVisible ( true ) ; panelStep3 . setVisible ( false ) ; } } ) ; btnBack_1 . setBounds ( 420 , 328 , 72 , 23 ) ; panelStep3 . add ( btnBack_1 ) ; final JButton btnFinish_2 = new JButton ( "Finish" ) ; btnFinish_2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Step3UserRequest userRequest3 = new Step3UserRequest ( features , cb , minYear , maxYear ) ; List3 = handleGUIStep3UserRequest ( userRequest3 , List2 ) ; ListSorterByEvalution ( List3 ) ; model = new CarTableModel ( List3 ) ; table . setModel ( model ) ; panelResults . setVisible ( true ) ; panelStep3 . setVisible ( false ) ; } } ) ; btnFinish_2 . setBounds ( 502 , 328 , 72 , 23 ) ; panelStep3 . add ( btnFinish_2 ) ; JLabel lblCarSuggestions = new JLabel ( "Car suggestions" ) ; lblCarSuggestions . setForeground ( new Color ( 0 , 128 , 0 ) ) ; lblCarSuggestions . setFont ( new Font ( "Tahoma" , Font . BOLD , 13 ) ) ; lblCarSuggestions . setBounds ( 228 , 23 , 104 , 16 ) ; panelResults . add ( lblCarSuggestions ) ; table = new JTable ( ) ; System . out . println ( model ) ; table . setModel ( model ) ; table . setShowGrid ( false ) ; table . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; table . setRowSelectionAllowed ( false ) ; table . setBackground ( new Color ( 144 , 238 , 144 ) ) ; table . setBounds ( 78 , 50 , 425 , 267 ) ; JScrollPane scrollPane = new JScrollPane ( table ) ; scrollPane . setLocation ( 70 , 50 ) ; scrollPane . setSize ( 450 , 260 ) ; panelResults . add ( scrollPane ) ; final JButton btnStartOver = new JButton ( "Start over" ) ; btnStartOver . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { clearVariables ( ) ; clearGuiSelections ( ) ; Cars = database . getCars ( ) ; panelStep1 . setVisible ( true ) ; panelResults . setVisible ( false ) ; } } ) ; btnStartOver . setBounds ( 478 , 328 , 96 , 23 ) ; panelResults . add ( btnStartOver ) ; }
va	9	private boolean r_mark_regions ( ) { int v_1 ; int v_2 ; I_p1 = limit ; v_1 = cursor ; { int c = cursor + 3 ; if ( 0 > c || c > limit ) { return false ; } cursor = c ; } I_x = cursor ; cursor = v_1 ; golab0 : while ( true ) { v_2 = cursor ; lab1 : do { if ( ! ( in_grouping ( g_v , 97 , 248 ) ) ) { break lab1 ; } cursor = v_2 ; break golab0 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { return false ; } cursor ++ ; } golab2 : while ( true ) { lab3 : do { if ( ! ( out_grouping ( g_v , 97 , 248 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor >= limit ) { return false ; } cursor ++ ; } I_p1 = cursor ; lab4 : do { if ( ! ( I_p1 < I_x ) ) { break lab4 ; } I_p1 = I_x ; } while ( false ) ; return true ; }
va	3	@ Override public String getFromNative ( long i ) { short strLen = stringLengths . getShort ( i ) ; if ( strLen < 0 ) return null ; long offset = sizeof * i * maxStringLength * CHARSET_SIZE ; for ( int j = 0 ; j < strLen ; j ++ ) { byteArray [ j ] = Utilities . UNSAFE . getByte ( ptr + offset + sizeof * j ) ; } try { return new String ( byteArray , 0 , strLen , CHARSET ) ; } catch ( UnsupportedEncodingException ex ) { return null ; } }
va	1	static public IconCache zam18_retinaSupport ( HttpCache hc ) { if ( SystemHelp . isRetina ( ) ) { return new IconCache ( hc , 18 , 2 , "http://wow.zamimg.com/images/wow/icons/medium/$.jpg|dir=36" ) ; } else { return zam18 ( hc ) ; } }
va	9	public static String valueToString ( Object value ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } if ( value instanceof JSONString ) { Object object ; try { object = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "Bad value from toJSONString: " + object ) ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( ) ; } return quote ( value . toString ( ) ) ; }
va	7	public void iniciar ( ) { JPanel panel = new JPanel ( ) ; getContentPane ( ) . add ( panel ) ; panel . setLayout ( null ) ; JLabel vermelho = new JLabel ( "Vermelho:" ) ; vermelho . setBounds ( 5 , 0 , 80 , 30 ) ; vermelho . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel amarelo = new JLabel ( "Laranja:" ) ; amarelo . setBounds ( 5 , 80 , 80 , 30 ) ; amarelo . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel verde = new JLabel ( "Verde: " ) ; verde . setBounds ( 5 , 160 , 80 , 30 ) ; verde . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho ) ; panel . add ( amarelo ) ; panel . add ( verde ) ; final JLabel vermelho1 = new JLabel ( "0" ) ; vermelho1 . setBounds ( 80 , 0 , 80 , 30 ) ; vermelho1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo1 = new JLabel ( "0" ) ; amarelo1 . setBounds ( 80 , 80 , 80 , 30 ) ; amarelo1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde1 = new JLabel ( "0" ) ; verde1 . setBounds ( 80 , 160 , 80 , 30 ) ; verde1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho1 ) ; panel . add ( amarelo1 ) ; panel . add ( verde1 ) ; final JLabel vermelho2 = new JLabel ( "0" ) ; vermelho2 . setBounds ( 120 , 0 , 80 , 30 ) ; vermelho2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo2 = new JLabel ( "0" ) ; amarelo2 . setBounds ( 120 , 80 , 80 , 30 ) ; amarelo2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde2 = new JLabel ( "0" ) ; verde2 . setBounds ( 120 , 160 , 80 , 30 ) ; verde2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho2 ) ; panel . add ( amarelo2 ) ; panel . add ( verde2 ) ; final JLabel vermelho3 = new JLabel ( "0" ) ; vermelho3 . setBounds ( 160 , 0 , 80 , 30 ) ; vermelho3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo3 = new JLabel ( "0" ) ; amarelo3 . setBounds ( 160 , 80 , 80 , 30 ) ; amarelo3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde3 = new JLabel ( "0" ) ; verde3 . setBounds ( 160 , 160 , 80 , 30 ) ; verde3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho3 ) ; panel . add ( amarelo3 ) ; panel . add ( verde3 ) ; final JLabel vermelho4 = new JLabel ( "0" ) ; vermelho4 . setBounds ( 200 , 0 , 80 , 30 ) ; vermelho4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo4 = new JLabel ( "0" ) ; amarelo4 . setBounds ( 200 , 80 , 80 , 30 ) ; amarelo4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde4 = new JLabel ( "0" ) ; verde4 . setBounds ( 200 , 160 , 80 , 30 ) ; verde4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho4 ) ; panel . add ( amarelo4 ) ; panel . add ( verde4 ) ; final JLabel vermelho5 = new JLabel ( "0" ) ; vermelho5 . setBounds ( 240 , 0 , 80 , 30 ) ; vermelho5 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo5 = new JLabel ( "0" ) ; amarelo5 . setBounds ( 240 , 80 , 80 , 30 ) ; amarelo5 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde5 = new JLabel ( "0" ) ; verde5 . setBounds ( 240 , 160 , 80 , 30 ) ; verde5 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho5 ) ; panel . add ( amarelo5 ) ; panel . add ( verde5 ) ; final JLabel vermelho6 = new JLabel ( "0" ) ; vermelho6 . setBounds ( 280 , 0 , 80 , 30 ) ; vermelho6 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo6 = new JLabel ( "0" ) ; amarelo6 . setBounds ( 280 , 80 , 80 , 30 ) ; amarelo6 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde6 = new JLabel ( "0" ) ; verde6 . setBounds ( 280 , 160 , 80 , 30 ) ; verde6 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho6 ) ; panel . add ( amarelo6 ) ; panel . add ( verde6 ) ; final JLabel vermelho7 = new JLabel ( "0" ) ; vermelho7 . setBounds ( 320 , 0 , 80 , 30 ) ; vermelho7 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo7 = new JLabel ( "0" ) ; amarelo7 . setBounds ( 320 , 80 , 80 , 30 ) ; amarelo7 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde7 = new JLabel ( "0" ) ; verde7 . setBounds ( 320 , 160 , 80 , 30 ) ; verde7 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho7 ) ; panel . add ( amarelo7 ) ; panel . add ( verde7 ) ; final JLabel vermelho8 = new JLabel ( "0" ) ; vermelho8 . setBounds ( 360 , 0 , 80 , 30 ) ; vermelho8 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo8 = new JLabel ( "0" ) ; amarelo8 . setBounds ( 360 , 80 , 80 , 30 ) ; amarelo8 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde8 = new JLabel ( "0" ) ; verde8 . setBounds ( 360 , 160 , 80 , 30 ) ; verde8 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho8 ) ; panel . add ( amarelo8 ) ; panel . add ( verde8 ) ; setTitle ( "Semaforos" ) ; setSize ( 400 , 400 ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; Semaforo semaforo1 = new Semaforo ( ) ; semaforo1 . setRedText ( vermelho1 ) ; semaforo1 . setOrangeText ( amarelo1 ) ; semaforo1 . setGreenText ( verde1 ) ; semaforo1 . setStatus ( 0 ) ; semaforo1 . start ( ) ; Semaforo semaforo2 = new Semaforo ( ) ; semaforo2 . setRedText ( vermelho2 ) ; semaforo2 . setOrangeText ( amarelo2 ) ; semaforo2 . setGreenText ( verde2 ) ; semaforo2 . setStatus ( 2 ) ; semaforo2 . start ( ) ; Semaforo semaforo3 = new Semaforo ( ) ; semaforo3 . setRedText ( vermelho3 ) ; semaforo3 . setOrangeText ( amarelo3 ) ; semaforo3 . setGreenText ( verde3 ) ; semaforo3 . setStatus ( 0 ) ; semaforo3 . start ( ) ; Semaforo semaforo4 = new Semaforo ( ) ; semaforo4 . setRedText ( vermelho4 ) ; semaforo4 . setOrangeText ( amarelo4 ) ; semaforo4 . setGreenText ( verde4 ) ; semaforo4 . setStatus ( 2 ) ; semaforo4 . start ( ) ; Semaforo semaforo5 = new Semaforo ( ) ; semaforo5 . setRedText ( vermelho5 ) ; semaforo5 . setOrangeText ( amarelo5 ) ; semaforo5 . setGreenText ( verde5 ) ; semaforo5 . setStatus ( 0 ) ; semaforo5 . start ( ) ; Semaforo semaforo6 = new Semaforo ( ) ; semaforo6 . setRedText ( vermelho6 ) ; semaforo6 . setOrangeText ( amarelo6 ) ; semaforo6 . setGreenText ( verde6 ) ; semaforo6 . setStatus ( 2 ) ; semaforo6 . start ( ) ; Semaforo semaforo7 = new Semaforo ( ) ; semaforo7 . setRedText ( vermelho7 ) ; semaforo7 . setOrangeText ( amarelo7 ) ; semaforo7 . setGreenText ( verde7 ) ; semaforo7 . setStatus ( 0 ) ; semaforo7 . start ( ) ; Semaforo semaforo8 = new Semaforo ( ) ; semaforo8 . setRedText ( vermelho8 ) ; semaforo8 . setOrangeText ( amarelo8 ) ; semaforo8 . setGreenText ( verde8 ) ; semaforo8 . setStatus ( 2 ) ; semaforo8 . start ( ) ; long secondLast = 0 ; int currentSign = 2 ; while ( true ) { long secondNow = System . currentTimeMillis ( ) / 1000 ; if ( secondNow - secondLast >= 10 ) { switch ( currentSign ) { case 1 : case 4 : semaforo2 . change ( ) ; semaforo4 . change ( ) ; semaforo5 . change ( ) ; semaforo7 . change ( ) ; break ; case 2 : case 3 : semaforo1 . change ( ) ; semaforo3 . change ( ) ; semaforo6 . change ( ) ; semaforo8 . change ( ) ; break ; default : break ; } secondLast = secondNow ; currentSign ++ ; if ( currentSign == 5 ) currentSign = 1 ; } } }
va	1	public String saveEvent ( ) { System . out . println ( ) ; System . out . println ( ) ; System . out . println ( ) ; System . out . println ( id ) ; System . out . println ( ) ; System . out . println ( ) ; if ( id == 0 ) { Date date = new Date ( ) ; DateFormat dateFormat = new SimpleDateFormat ( "yyyy/MM/dd HH:mm" ) ; dateFormat . format ( date ) ; event . setDate ( new Timestamp ( date . getTime ( ) ) ) ; getTopicsService ( ) . getEventDAO ( ) . save ( event ) ; } else { String content = event . getInfo ( ) ; String theme = event . getHeader ( ) ; event = getTopicsService ( ) . getEventDAO ( ) . find ( id ) ; event . setInfo ( content ) ; event . setHeader ( theme ) ; event . setIdevent ( id ) ; getTopicsService ( ) . getEventDAO ( ) . update ( event ) ; } return "/content/events/events.xhtml?faces-redirect=true" ; }
va	7	public int compute ( int direction , float f ) { if ( direction == 0 ) { float f1 = unity [ 0 ] + ( unity [ 1 ] - unity [ 0 ] ) * f ; f1 *= 0.003051758F ; _invUnity = ( float ) Math . pow ( 0.10000000000000001D , f1 / 20F ) ; invUnity = ( int ) ( _invUnity * 65536F ) ; } if ( pairCount [ direction ] == 0 ) return 0 ; float _mag = adaptMagnitude ( direction , 0 , f ) ; _coefficient [ direction ] [ 0 ] = - 2F * _mag * ( float ) Math . cos ( adaptPhase ( f , 0 , direction ) ) ; _coefficient [ direction ] [ 1 ] = _mag * _mag ; for ( int pair = 1 ; pair < pairCount [ direction ] ; pair ++ ) { float mag = adaptMagnitude ( direction , pair , f ) ; float phase = - 2F * mag * ( float ) Math . cos ( adaptPhase ( f , pair , direction ) ) ; float coeff = mag * mag ; _coefficient [ direction ] [ pair * 2 + 1 ] = _coefficient [ direction ] [ pair * 2 - 1 ] * coeff ; _coefficient [ direction ] [ pair * 2 ] = _coefficient [ direction ] [ pair * 2 - 1 ] * phase + _coefficient [ direction ] [ pair * 2 - 2 ] * coeff ; for ( int j1 = pair * 2 - 1 ; j1 >= 2 ; j1 -- ) _coefficient [ direction ] [ j1 ] += _coefficient [ direction ] [ j1 - 1 ] * phase + _coefficient [ direction ] [ j1 - 2 ] * coeff ; _coefficient [ direction ] [ 1 ] += _coefficient [ direction ] [ 0 ] * phase + coeff ; _coefficient [ direction ] [ 0 ] += phase ; } if ( direction == 0 ) { for ( int pair = 0 ; pair < pairCount [ 0 ] * 2 ; pair ++ ) _coefficient [ 0 ] [ pair ] *= _invUnity ; } for ( int pair = 0 ; pair < pairCount [ direction ] * 2 ; pair ++ ) coefficient [ direction ] [ pair ] = ( int ) ( _coefficient [ direction ] [ pair ] * 65536F ) ; return pairCount [ direction ] * 2 ; }
va	0	public ClearQuizServlet ( ) { super ( ) ; }
va	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
va	4	@ Override public void run ( ) { int tries = 0 ; synchronized ( downloading ) { while ( downloading . size ( ) < MAX_NUM_DOWNLOADS && queue . size ( ) > 0 && tries ++ < MAX_NUM_DOWNLOADS * 2 ) { String curr = queue . get ( 0 ) ; queue . remove ( curr ) ; System . out . println ( "download " + curr ) ; ITransferProgress transfer = buschtrommel . DownloadFile ( curr , curr ) ; if ( transfer != null ) downloading . put ( curr , transfer ) ; } } }
va	6	public void checkForWin ( ) { if ( this . playerScore >= this . maxScore || this . computerScore >= this . maxScore ) { this . gameOn = false ; this . stopTimers ( ) ; if ( this . playerScore >= this . maxScore ) { if ( this . level < this . maxLevel ) { this . initNextLevel ( ) ; } else { this . gameOver = true ; this . gameWin = true ; } } else if ( this . computerScore >= this . maxScore ) { if ( -- this . lives > 0 ) { this . initLevel ( ) ; } else { this . gameOver = true ; this . gameWin = false ; } } } }
va	7	@ Test public void testNavigateShowAscending ( ) { for ( int i = 1 ; i <= MockFileSystem . NUM_SEASONS ; i ++ ) { for ( int j = 1 ; j <= MockFileSystem . NUM_EPISODES ; j ++ ) { int season = ( j == MockFileSystem . NUM_EPISODES ) ? i + 1 : i ; int expEp = ( j == MockFileSystem . NUM_EPISODES ) ? 1 : j + 1 ; EpisodeMatch toNavigate = new EpisodeMatch ( "Scrubs" , i , j ) ; EpisodeMatch expResult = new EpisodeMatch ( season , expEp ) ; EpisodeMatch result = episode . navigate ( toNavigate , EpisodeNavigator . Pointer . NEXT ) ; if ( result == null && i == MockFileSystem . NUM_SEASONS && j == MockFileSystem . NUM_EPISODES ) { return ; } System . out . println ( "Navigating: " + toNavigate + " : to : " + expResult ) ; assertEquals ( expResult . getSeason ( ) , result . getSeason ( ) ) ; assertEquals ( expResult . getEpisodes ( ) , result . getEpisodes ( ) ) ; } } }
va	7	public void connect ( TreeLinkNode root ) { if ( null == root ) return ; TreeLinkNode temp = root . next ; while ( temp != null ) { if ( temp . left != null ) { temp = temp . left ; break ; } if ( temp . right != null ) { temp = temp . right ; break ; } temp = temp . next ; } if ( root . right != null ) { root . right . next = temp ; } if ( root . left != null ) { root . left . next = root . right == null ? temp : root . right ; } connect ( root . right ) ; connect ( root . left ) ; }
va	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( email == null ) ? 0 : email . hashCode ( ) ) ; result = prime * result + ( ( firstName == null ) ? 0 : firstName . hashCode ( ) ) ; result = prime * result + ( ( lastName == null ) ? 0 : lastName . hashCode ( ) ) ; return result ; }
va	5	@ Override public Message send ( Message msg , int timeout ) throws edu . concordia . dpis . commons . TimeoutException { String response = null ; DatagramSocket aSocket = null ; try { aSocket = new DatagramSocket ( ) ; byte [ ] m = MessageTransformer . serializeMessage ( msg ) ; InetAddress aHost = InetAddress . getByName ( msg . getToAddress ( ) . getHost ( ) ) ; DatagramPacket request = new DatagramPacket ( m , m . length , aHost , msg . getToAddress ( ) . getPort ( ) ) ; aSocket . send ( request ) ; if ( msg . isReplyToThisMessage ( ) ) { byte [ ] buffer = new byte [ 1000 ] ; DatagramPacket reply = new DatagramPacket ( buffer , buffer . length ) ; aSocket . setSoTimeout ( timeout ) ; try { aSocket . receive ( reply ) ; } catch ( SocketTimeoutException timeoutException ) { System . out . println ( "UDP Client could not recieve reply within " + timeout + "ms" ) ; throw new TimeoutException ( ) ; } response = new String ( Arrays . copyOfRange ( reply . getData ( ) , 0 , reply . getLength ( ) ) ) ; } } catch ( SocketException e ) { System . out . println ( "Socket: " + e . getMessage ( ) ) ; } catch ( IOException e ) { System . out . println ( "IO: " + e . getMessage ( ) ) ; } finally { if ( aSocket != null ) { aSocket . close ( ) ; } } final Message retMessage = new ReliableMessage ( response , msg . getToAddress ( ) . getHost ( ) , msg . getToAddress ( ) . getPort ( ) ) ; return retMessage ; }
va	1	public Dimension resizeImage ( int height , int width ) { int heightTemp = height ; int widthTemp = width ; double thumbRatio = ( double ) widthTemp / ( double ) heightTemp ; double imageRatio = ( double ) originalWidth / ( double ) originalHeight ; if ( thumbRatio < imageRatio ) { heightTemp = ( int ) ( widthTemp / imageRatio ) ; } else { widthTemp = ( int ) ( heightTemp * imageRatio ) ; } BufferedImage thumbImage = new BufferedImage ( widthTemp , heightTemp , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( imgOriginal , 0 , 0 , widthTemp , heightTemp , null ) ; imgResized = Toolkit . getDefaultToolkit ( ) . createImage ( thumbImage . getSource ( ) ) ; graphics2D . dispose ( ) ; invalidate ( ) ; repaint ( ) ; Dimension d = new Dimension ( ) ; d . width = widthTemp ; d . height = heightTemp ; return d ; }
va	1	public QuestionPanel ( HashMap < String , String > text , int fontsize ) { this . setBackground ( MainController . BACKGROUND ) ; this . setLayout ( new BorderLayout ( ) ) ; questionLabel = new WrappedLabel ( text . get ( "frage" ) , fontsize ) ; questionLabel . setForeground ( MainController . FOREGROUND ) ; if ( ! questionLabel . getText ( ) . equals ( "" ) ) this . add ( BorderLayout . NORTH , questionLabel ) ; this . add ( BorderLayout . CENTER , pnlEmpty ) ; this . media = null ; }
va	0	private static Gravitable pathFromString ( String objstring ) { objstring = objstring . replace ( "(" , "" ) . replace ( ")" , "" ) ; int mass = Integer . parseInt ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; double vel = double . parseDouble ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; double x1 = double . parseDouble ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; double y1 = double . parseDouble ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; double x2 = double . parseDouble ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; double y2 = double . parseDouble ( objstring . substring ( 0 , objstring . indexOf ( " " ) ) ) ; objstring = objstring . substring ( objstring . indexOf ( " " ) + 1 ) ; Color color = colorFromString ( objstring . substring ( 0 , objstring . indexOf ( "]" ) ) ) ; PathGravitable g ; g = new PathGravitable ( new Point ( ( int ) x1 , ( int ) y1 ) , new Point ( ( int ) x2 , ( int ) y2 ) , mass , vel ) ; g . setColor ( color ) ; return g ; }
va	9	@ Deprecated private void startEventHandlerThread ( Socket socket , BufferedReader in , PrintWriter out ) { final iKPIC_subscribeHandler f_eh = this . eh ; final Socket ft_kpSocket = socket ; final PrintWriter ft_out = out ; final BufferedReader ft_in = in ; eventThread = new Thread ( ) { public void run ( ) { SSAP_XMLTools xmlTools = new SSAP_XMLTools ( null , null , null ) ; String msg_event = "" ; String restOfTheMessage = "" ; deb_print ( "\n[EVENT HANDLER THREAD STARTED]___________________________________" ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; int charRead = 0 ; try { while ( ( ( charRead = ft_in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) || ( ! restOfTheMessage . isEmpty ( ) ) ) { if ( ! restOfTheMessage . equals ( "" ) ) { builder . append ( restOfTheMessage ) ; restOfTheMessage = "" ; } if ( charRead != - 1 ) { builder . append ( buffer , 0 , charRead ) ; } msg_event = builder . toString ( ) ; if ( msg_event . contains ( "<SSAP_message>" ) && msg_event . contains ( "</SSAP_message>" ) ) { restOfTheMessage = msg_event . substring ( msg_event . indexOf ( "</SSAP_message>" ) + 15 ) ; msg_event = msg_event . substring ( 0 , msg_event . indexOf ( "</SSAP_message>" ) + 15 ) ; deb_print ( "KpCore:EventHandlerThread:is this a UnSubscriptionConfirmed message?" ) ; if ( xmlTools . isUnSubscriptionConfirmed ( msg_event ) ) { deb_print ( "KpCore:EventHandlerThread:YES  UnSubscription Confirmed!\n" + "EVENT HANDLER THREAD:stop" ) ; f_eh . kpic_SIBEventHandler ( msg_event ) ; return ; } else { deb_print ( "KpCore:EventHandlerThread:NO  thiss is not a UnSubscriptionConfirmed" ) ; } deb_print ( "KpCore:EventHandlerThread:passing the event message passed to event handler...:" + msg_event . replace ( "\n" , "" ) ) ; f_eh . kpic_SIBEventHandler ( msg_event ) ; deb_print ( "KpCore:EventHandlerThread:event message passed to event handler" ) ; if ( restOfTheMessage . contains ( "<SSAP_message>" ) && restOfTheMessage . contains ( "</SSAP_message>" ) ) { deb_print ( "KpCore:EventHandlerThread:YES  UnSubscription Confirmed!\n" + "EVENT HANDLER THREAD:stop" ) ; String test = restOfTheMessage . substring ( 0 , restOfTheMessage . indexOf ( "</SSAP_message>" ) + 15 ) ; if ( xmlTools . isUnSubscriptionConfirmed ( test ) ) { return ; } } buffer = new char [ buffsize ] ; charRead = 0 ; msg_event = "" ; builder = new StringBuilder ( ) ; } } try { ft_out . close ( ) ; ft_in . close ( ) ; ft_kpSocket . close ( ) ; } catch ( Exception e ) { err_print ( "KpCore:startEventHandlerThread:closing connection:Exception:\n" + e ) ; e . printStackTrace ( ) ; } } catch ( Exception e ) { err_print ( "KpCore:startEventHandlerThread:reading:Exception:\n" + e ) ; e . printStackTrace ( ) ; } } } ; eventThread . start ( ) ; }
va	9	public final void block ( ) throws RecognitionException { Scope_stack . push ( new Scope_scope ( ) ) ; ( ( Scope_scope ) Scope_stack . peek ( ) ) . env = new HashMap < > ( ) ; ( ( Scope_scope ) Scope_stack . peek ( ) ) . functionEnv = new HashMap < > ( ) ; ( ( Scope_scope ) Scope_stack . peek ( ) ) . structEnv = new HashMap < > ( ) ; ( ( Scope_scope ) Scope_stack . peek ( ) ) . isFunctionBlock = false ; try { { match ( input , BLOCK , FOLLOW_BLOCK_in_block243 ) ; match ( input , Token . DOWN , null ) ; int cnt3 = 0 ; loop3 : do { int alt3 = 2 ; int LA3_0 = input . LA ( 1 ) ; if ( ( ( LA3_0 >= ASSIGN && LA3_0 <= BLOCK ) || ( LA3_0 >= ECHO && LA3_0 <= FUNCDECL ) || LA3_0 == 40 || ( LA3_0 >= 42 && LA3_0 <= 43 ) || LA3_0 == 45 ) ) { alt3 = 1 ; } switch ( alt3 ) { case 1 : { pushFollow ( FOLLOW_stat_in_block245 ) ; stat ( ) ; state . _fsp -- ; } break ; default : if ( cnt3 >= 1 ) break loop3 ; EarlyExitException eee = new EarlyExitException ( 3 , input ) ; throw eee ; } cnt3 ++ ; } while ( true ) ; match ( input , Token . UP , null ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; } finally { Scope_stack . pop ( ) ; } return ; }
va	0	protected RejectPageBuilder reject ( String viewName ) { return WebPageUtils . reject ( viewName ) ; }
va	3	public JSONObject putOnce ( String key , Object value ) throws JSONException { if ( key != null && value != null ) { if ( this . opt ( key ) != null ) { throw new JSONException ( "Duplicate key \"" + key + "\"" ) ; } this . put ( key , value ) ; } return this ; }
va	0	public static void main ( String args [ ] ) { String invoer = "3 4 5 + *" ; PostFixCalculator pf = new PostFixCalculator ( invoer ) ; System . out . println ( "uitvoer is : " + pf . getResultaat ( ) ) ; }
va	0	LazyRMQTreap reverseRange ( int l , int r ) { NodePair ab = split ( this , l ) ; NodePair bc = split ( ab . r , r - l ) ; bc . l . rev ^= true ; return merge ( ab . l , merge ( bc . l , bc . r ) ) ; }
va	2	public static < T > T [ ] to1D ( class < T > type , T [ ] [ ] arr ) { @ SuppressWarnings ( "unchecked" ) T [ ] singleDim = ( T [ ] ) Array . newInstance ( type , arr . length * arr [ 0 ] . length ) ; for ( int a = arr . length ; a -- > 0 ; ) { for ( int b = arr [ 0 ] . length ; b -- > 0 ; ) { singleDim [ a * arr [ 0 ] . length + b ] = arr [ a ] [ b ] ; } } return singleDim ; }
va	8	@ Override public Map < String , String > validateForCreate ( Map < String , Object > properties ) throws Exception { Connection conn = ConnectionManager . getInstance ( ) . getConnection ( ) ; Map < String , String > erros = new HashMap < String , String > ( ) ; if ( properties != null ) { long viagemFk = ( long ) properties . get ( "viagem_fk" ) ; if ( viagemFk == null ) { erros . put ( "viagem_fk" , "Campo obrigat\u00F3rio!" ) ; } long categoriaFk = ( long ) properties . get ( "categoria_fk" ) ; if ( viagemFk == null ) { erros . put ( "categoria_fk" , "Campo obrigat\u00F3rio!" ) ; } byte [ ] comprovate = ( byte [ ] ) properties . get ( "comprovate" ) ; if ( comprovate == null ) { erros . put ( "comprovate" , "Campo obrigat\u00F3rio!" ) ; } int valor = ( int ) properties . get ( "valor" ) ; if ( valor == 0 ) { erros . put ( "valor" , "Campo obrigat\u00F3rio!" ) ; } Date dataCompra = ( Date ) properties . get ( "data_compra" ) ; if ( dataCompra == null ) { erros . put ( "data_compra" , "Campo obrigat\u00F3rio!" ) ; } Time horaCompra = ( Time ) properties . get ( "hora_compra" ) ; if ( horaCompra == null ) { erros . put ( "hora_compra" , "Campo obrigat\u00F3rio!" ) ; } int valorRealAutorizado = ( int ) properties . get ( "valor_autorizado" ) ; if ( valorRealAutorizado == 0 ) { erros . put ( "valor_autorizado" , "Campo obrigat\u00F3rio!" ) ; } } return erros ; }
va	3	private static boolean existe ( String val , String [ ] args ) { for ( String arg : args ) { if ( val == null ? arg == null : val . equals ( arg ) ) { return true ; } } return false ; }
va	1	public static Complex complex ( Complex x ) { if ( x == null ) System . out . println ( "moo" ) ; return complex ( x . real , x . imag ) ; }
va	9	int [ ] getComponentGaps ( ContainerWrapper parent , ComponentWrapper comp , BoundSize adjGap , ComponentWrapper adjacentComp , String tag , int refSize , int adjacentSide , boolean isLTR ) { BoundSize gap = adjacentSide < 2 ? gapBefore : gapAfter ; boolean hasGap = gap != null && gap . getGapPush ( ) ; if ( ( gap == null || gap . isUnset ( ) ) && ( adjGap == null || adjGap . isUnset ( ) ) && comp != null ) gap = PlatformDefaults . getDefaultComponentGap ( comp , adjacentComp , adjacentSide + 1 , tag , isLTR ) ; if ( gap == null ) return hasGap ? new int [ ] { 0 , 0 , LayoutUtil . NOT_SET } : null ; int [ ] ret = new int [ 3 ] ; for ( int i = LayoutUtil . MIN ; i <= LayoutUtil . MAX ; i ++ ) { UnitValue uv = gap . getSize ( i ) ; ret [ i ] = uv != null ? uv . getPixels ( refSize , parent , null ) : LayoutUtil . NOT_SET ; } return ret ; }
va	1	public static void getStable ( ) { double time1 = 0 ; double time2 = 0 ; do { Helpers . startTimer ( ) ; kdtree . windowQuery ( false , 1 ) ; time1 = Helpers . endTimer ( false ) ; Helpers . startTimer ( ) ; kdtree . windowQuery ( false , 1 ) ; time2 = Helpers . endTimer ( false ) ; } while ( ! Helpers . withinThreePercent ( time1 , time2 ) ) ; }
va	0	protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; RenderingHints hints = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHints ( hints ) ; g2 . setColor ( new Color ( 70 , 130 , 180 ) ) ; g2 . fill ( m_areaFill ) ; super . paintComponent ( g2 ) ; }
va	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof InstanceList ) ) { return false ; } InstanceList < ? > other = ( InstanceList < ? > ) obj ; if ( clazz == null ) { if ( other . clazz != null ) { return false ; } } else if ( ! clazz . equals ( other . clazz ) ) { return false ; } return true ; }
va	7	public void UpdateKillerMoves ( int ply , GameState gs , ArimaaMove move , boolean isCaptureMove ) { if ( ! killer_move1 [ ply ] . equals ( move ) && ! isCaptureMove && move . steps <= 2 ) { killer_move2 [ ply ] . copy ( killer_move1 [ ply ] ) ; killer_move1 [ ply ] . copy ( move ) ; } if ( gs . getStepsRemaining ( ) == 4 ) { int count = 0 ; int cur_killer = random . nextInt ( 3 ) ; cur_killer = 0 ; temp_gsk . copy ( gs ) ; while ( count <= 4 ) { ArimaaMove hash_move = hash_table . ProbeHashMove ( temp_gsk . getPositionHash ( ) ) ; if ( hash_move == null ) { break ; } killer_turn [ ply ] [ cur_killer ] [ count ] . copy ( hash_move ) ; temp_gsk . play ( hash_move , temp_gsk ) ; if ( temp_gsk . getStepsRemaining ( ) == 4 ) { break ; } count ++ ; } killer_turn_length [ ply ] [ cur_killer ] = count ; } }
va	3	@ Override public void insert ( IndexedDataObject dataObject ) { String hash = dataObject . getHash ( ) ; if ( table . containsKey ( hash ) ) { ArrayList < IndexedDataObject > temp = table . get ( hash ) ; IndexedDataObject idoTemp = null ; temp . add ( dataObject ) ; for ( int a = temp . size ( ) - 1 ; a > 0 ; a -- ) { if ( temp . get ( a ) . getVersion ( ) > temp . get ( a - 1 ) . getVersion ( ) ) { idoTemp = temp . get ( a - 1 ) ; temp . set ( a - 1 , temp . get ( a ) ) ; temp . set ( a , idoTemp ) ; } else { break ; } } } else { table . put ( hash , new ArrayList < IndexedDataObject > ( ) ) ; table . get ( hash ) . add ( dataObject ) ; } }
va	1	private void postOrder ( T [ ] array , BSTNode < T > node ) { if ( ! node . isEmpty ( ) ) { postOrder ( array , ( BSTNode < T > ) node . getLeft ( ) ) ; postOrder ( array , ( BSTNode < T > ) node . getRight ( ) ) ; array [ index ++ ] = node . getData ( ) ; } }
va	5	public static DictionaryValue copyOf ( final DictionaryValue value ) { if ( value == null ) { return null ; } else { final Map < String , Value < ? >> mv = new HashMap < String , Value < ? >> ( ) ; for ( final Map . Entry < String , Value < ? >> me : value . getValue ( ) . entrySet ( ) ) { mv . put ( me . getKey ( ) , copyOf ( me . getValue ( ) ) ) ; } return new DictionaryValue ( mv ) ; } }
va	5	public static ItemDefinition getDefinition ( int id ) { for ( int i = 0 ; i < 10 ; i ++ ) if ( cache [ i ] . id == id ) return cache [ i ] ; cacheIndex = ( cacheIndex + 1 ) % 10 ; ItemDefinition definition = cache [ cacheIndex ] ; stream . position = streamOffsets [ id ] ; definition . id = id ; definition . setDefaults ( ) ; definition . readValues ( stream ) ; if ( definition . noteTemplateId != - 1 ) definition . toNote ( ) ; if ( ! membersWorld && definition . membersObject ) { definition . name = "Members Object" ; definition . description = "Login to a members' server to use this object." . getBytes ( ) ; definition . groundActions = null ; definition . actions = null ; definition . teamId = 0 ; } return definition ; }
va	4	public int getDistanceToWall ( ) { switch ( dir ) { case DIR_NORTH : return y ; case DIR_SOUTH : return 11 - y ; case DIR_WEST : return x ; case DIR_EAST : return 11 - x ; } return 0 ; }
va	8	public PortIdentifier ( String path ) { StringTokenizer tokens = new StringTokenizer ( path , "-" ) ; if ( ! tokens . hasMoreTokens ( ) || ! "usb" . equals ( tokens . nextToken ( ) ) || ! tokens . hasMoreTokens ( ) ) throw new IllegalArgumentException ( path ) ; busId = tokens . nextToken ( ) ; if ( ! tokens . hasMoreTokens ( ) ) { port = new short [ 0 ] ; return ; } String route = tokens . nextToken ( ) ; int i ; short scratch [ ] = new short [ 5 ] ; tokens = new StringTokenizer ( route , "." ) ; for ( i = 0 ; i < scratch . length && tokens . hasMoreTokens ( ) ; i ++ ) { String temp = tokens . nextToken ( ) ; scratch [ i ] = short . parseShort ( temp ) ; } if ( tokens . hasMoreTokens ( ) ) throw new IllegalArgumentException ( ) ; if ( i == 5 ) port = scratch ; else { port = new short [ i ] ; System . arraycopy ( scratch , 0 , port , 0 , i ) ; } }
va	5	@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { map . putAll ( m ) ; Iterator < ? extends V > itr = m . values ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { V v = itr . next ( ) ; list . addHead ( v ) ; } while ( map . size ( ) > cacheSize ) list . removeTail ( ) ; }
va	0	public void setPressed ( final boolean value ) { pressedProperty . set ( value ) ; }
va	3	@ Override public AnomalyScore calculateAnomaly ( IForecastResult < double > forecast , ITimeSeriesPoint < double > current ) { if ( forecast . getForecast ( ) . getPoints ( ) . size ( ) == 0 ) return null ; double nextpredicted = forecast . getForecast ( ) . getPoints ( ) . get ( 0 ) . getValue ( ) ; if ( null == nextpredicted ) return null ; double measuredValue = 0.0 ; if ( current . getValue ( ) instanceof double ) { measuredValue = ( double ) current . getValue ( ) ; } double difference = nextpredicted - measuredValue ; double sum = nextpredicted + measuredValue ; difference = Math . abs ( difference / sum ) ; return new AnomalyScore ( difference ) ; }
va	7	private int insertCssClass ( int delta , String path , int index , boolean forTotals , boolean closeAttribute , String ... additionalCssClasses ) { index ++ ; int lastIndexOf = path . lastIndexOf ( - ) ; String parentClass = forTotals ? ( lastIndexOf == - 1 ? "" : path . substring ( 0 , lastIndexOf ) ) : path ; insert ( delta , "class='" , path , "-" , index , ( parentClass . length ( ) == 0 ? "" : " " ) , parentClass ) ; if ( additionalCssClasses != null ) { for ( String cssClass : additionalCssClasses ) { if ( cssClass != null ) { insert ( delta , " " , cssClass ) ; } } } if ( closeAttribute ) { insert ( delta , "'" ) ; } return index ; }
va	9	public static TextLabel createTextLabel ( String name , Color backgroundColor , Rectangle < Integer > requestedBounds , LayoutEngine layoutEngine , HorizontalAlignment horizontalAlignment , VerticalAlignment verticalAlignment , Texture texture , Rectangle < double > textureCoordinates , String textValue , Font font , Integer textWidth , Integer textHeight , KeyboardEventListener keyboardEventListener ) { if ( null == backgroundColor || null == requestedBounds || null == layoutEngine || null == horizontalAlignment || null == verticalAlignment || null == textValue || null == font || null == textWidth || null == textHeight ) { } TextLabelTemplate textLabelTemplate = ServiceManager . getInstance ( ) . getGUIDataObjectContainer ( ) . getTemplate ( TextLabel . class ) ; TextLabel rc = null ; if ( null != textLabelTemplate ) { rc = new TextLabel ( textLabelTemplate ) ; } else { rc = new TextLabel ( ) ; } setComponentValues ( rc , name , layoutEngine , horizontalAlignment , verticalAlignment , requestedBounds , keyboardEventListener ) ; setPanelValues ( rc , backgroundColor , texture , textureCoordinates ) ; setTextLabelValues ( rc , textValue , font , textWidth , textHeight ) ; return rc ; }
va	4	public static boolean isEnChar ( Character ch ) { if ( ( ch >= A && ch <= Z ) || ( ch >= a && ch <= z ) ) { return true ; } else { return false ; } }
va	9	public void sendOrderOfPlayers ( String ip , int port ) { int positionOfPlayer = 0 ; String [ ] tempRight = null , tempLeft = null , playerNamesArr = new String [ playersArr . length ] ; String buffer = "sORDER" ; for ( int playerIndex = 0 ; playerIndex < playersArr . length ; playerIndex ++ ) { if ( ( playersArr [ playerIndex ] != null ) && ( playersArr [ playerIndex ] . matches ( ip , port ) ) ) { playerNamesArr [ playerIndex ] = "" ; positionOfPlayer = playerIndex ; } else if ( ( playersArr [ playerIndex ] == null ) ) { playerNamesArr [ playerIndex ] = " no_one" ; } else playerNamesArr [ playerIndex ] = " " + playersArr [ playerIndex ] . getNickName ( ) ; } if ( positionOfPlayer == playersArr . length - 1 ) { tempLeft = new String [ playersArr . length - 1 ] ; for ( int leftIndex = 0 ; leftIndex < tempLeft . length ; leftIndex ++ ) tempLeft [ leftIndex ] = playerNamesArr [ leftIndex ] ; buffer = buildOrderString ( buffer , tempLeft ) ; } else if ( positionOfPlayer == 0 ) { tempRight = new String [ playersArr . length - 1 ] ; for ( int rightIndex = 0 ; rightIndex < tempRight . length ; rightIndex ++ ) tempRight [ rightIndex ] = playerNamesArr [ rightIndex + 1 ] ; buffer = buildOrderString ( buffer , tempRight ) ; } else { tempRight = new String [ playersArr . length - positionOfPlayer - 1 ] ; tempLeft = new String [ positionOfPlayer ] ; for ( int i = 0 ; i < tempLeft . length ; i ++ ) tempLeft [ i ] = playerNamesArr [ i ] ; int rStartIndex = positionOfPlayer + 1 ; for ( int i = 0 ; i < tempRight . length ; rStartIndex ++ , i ++ ) tempRight [ i ] = playerNamesArr [ rStartIndex ] ; buffer = buildOrderString ( buffer , tempRight ) ; buffer = buildOrderString ( buffer , tempLeft ) ; } privateMessage ( buffer , ip , port ) ; }
va	8	public void run ( ) { Scanner in = new Scanner ( System . in ) ; int caseCount = Integer . parseInt ( in . nextLine ( ) ) ; int loopCount = 0 ; while ( caseCount - loopCount > 0 ) { String line = in . nextLine ( ) ; Scanner sc = new Scanner ( line ) ; int vertexCount = sc . nextInt ( ) ; int edgeCount = sc . nextInt ( ) ; adjacencyList = new ArrayList < ArrayList < edge >> ( ) ; adjacencyEdges = new ArrayList < HashSet < Integer >> ( ) ; for ( int n = 0 ; n < vertexCount ; n ++ ) { adjacencyList . add ( new ArrayList < edge > ( ) ) ; adjacencyEdges . add ( new HashSet < Integer > ( ) ) ; } while ( edgeCount -- > 0 ) { line = in . nextLine ( ) ; sc = new Scanner ( line ) ; int source = sc . nextInt ( ) ; int dest = sc . nextInt ( ) ; edge edge1 = new edge ( dest , 0 ) ; edge edge2 = new edge ( source , 0 ) ; if ( ! adjacencyEdges . get ( source ) . contains ( edge1 . hashCode ( ) ) ) { adjacencyEdges . get ( source ) . add ( edge1 . hashCode ( ) ) ; adjacencyList . get ( source ) . add ( edge1 ) ; } if ( ! adjacencyEdges . get ( dest ) . contains ( edge2 . hashCode ( ) ) ) { adjacencyEdges . get ( dest ) . add ( edge2 . hashCode ( ) ) ; adjacencyList . get ( dest ) . add ( edge2 ) ; } } System . out . printf ( "%d\n" , ++ loopCount ) ; for ( int i = 0 ; i < vertexCount ; i ++ ) { System . out . printf ( "%d: " , i ) ; ArrayList < edge > edges = adjacencyList . get ( i ) ; Collections . sort ( edges ) ; for ( int node = 0 ; node < edges . size ( ) ; node ++ ) { if ( node + 1 == edges . size ( ) ) { System . out . print ( edges . get ( node ) . vertex ) ; } else { System . out . printf ( "%d  " , edges . get ( node ) . vertex ) ; } } System . out . println ( ) ; } } }
va	3	public static double variance ( Collection < ? extends Number > c ) { if ( c . size ( ) < 2 ) { return 0 ; } double mean = mean ( c ) ; double sum = 0 ; for ( Number n : c ) { sum += Math . pow ( n . doubleValue ( ) - mean , 2 ) ; } return sum / ( c . size ( ) - 1.0 ) ; }
va	2	static void stop ( ExecutorService executor ) { try { System . out . println ( "attempt to shutdown executor" ) ; executor . shutdown ( ) ; executor . awaitTermination ( 5 , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { System . err . println ( "termination interrupted" ) ; } finally { if ( ! executor . isTerminated ( ) ) { System . err . println ( "killing non-finished tasks" ) ; } executor . shutdownNow ( ) ; System . out . println ( "shutdown finished" ) ; } }
va	3	public LearningData ( String fileName ) { File file = new File ( fileName ) ; String [ ] tempTable ; double [ ] tempList ; int rows = 0 ; try { FileReader fr = new FileReader ( file ) ; BufferedReader input = new BufferedReader ( fr ) ; String line ; System . out . println ( "Data from: \"" + fileName + "\" are importing..." ) ; while ( ( line = input . readLine ( ) ) != null ) { rows ++ ; tempTable = line . split ( Controller . getConfig ( ) . getDelimiter ( ) ) ; int tableLenght = tempTable . length ; tempList = new double [ tableLenght ] ; for ( int i = 0 ; i < tableLenght ; i ++ ) { tempList [ i ] = double . valueOf ( tempTable [ i ] ) ; } dataList . add ( tempList ) ; } fr . close ( ) ; System . out . println ( rows + " rows was imported" ) ; } catch ( IOException e ) { System . out . println ( "File can not be read!. Error: " + e ) ; } }
va	3	public String finalizeModifier ( DataHolder dataholderHandler , String modifier , String tag , String sentence ) { String fModifier = "" ; modifier = modifier . replaceAll ( "\\[.*?\\]" , "" ) ; modifier = StringUtility . trimString ( modifier ) ; if ( StringUtility . isMatchedNullSafe ( modifier , "\\w" ) ) { List < String > mWords = new ArrayList < String > ( Arrays . asList ( modifier . split ( "\\s+" ) ) ) ; Collections . reverse ( mWords ) ; for ( String mWord : mWords ) { boolean isModifier = this . isModifier ( dataholderHandler , mWord , modifier , tag ) ; if ( isModifier ) { fModifier = mWord + " " + fModifier ; } else { break ; } } fModifier = fModifier . replaceAll ( "\\s+" , "" ) ; } return fModifier ; }
va	4	private void directoryProcess ( File file ) throws InterruptedException { File list [ ] = file . listFiles ( ) ; if ( list != null ) { for ( int i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] . isDirectory ( ) ) { directoryProcess ( list [ i ] ) ; } else { fileProcess ( list [ i ] ) ; } } } if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } }
va	5	boolean block_follow ( int token ) { switch ( token ) { case TK_ELSE : case TK_ELSEIF : case TK_END : case TK_UNTIL : case TK_EOS : return true ; default : return false ; } }
va	2	private void addButtonActionPerformed ( java . awt . event . ActionEvent evt ) { try { TemplatePanel panel = new TemplatePanel ( null ) ; ValidationPanel validationPanel = new ValidationPanel ( panel . getValidationGroup ( ) ) ; validationPanel . setInnerComponent ( panel ) ; if ( validationPanel . showOkCancelDialog ( "\u0412\u043D\u0435\u0441\u0442\u0438 \u0432 \u0441\u043F\u0440\u0430\u0432\u043E\u0447\u043D\u0438\u043A" ) ) { controller . createPartner ( panel . getPartner ( ) ) ; } } catch ( SQLException ex ) { Exceptions . printStackTrace ( ex ) ; } }
va	1	private < T > ClassStats < T > statsFor ( class < T > type ) { @ SuppressWarnings ( "unchecked" ) ClassCollector < T > cc = ( ClassCollector < T > ) classColl . get ( type ) ; return cc == null ? null : env . classStatsFor ( cc ) ; }
va	2	protected boolean followsInReader ( InputStream is , String text ) throws IOException { for ( int pos = 0 ; pos < text . length ( ) ; pos ++ ) { if ( is . read ( ) != text . codePointAt ( pos ) ) { return false ; } } return true ; }
