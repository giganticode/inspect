tr	0	@ Override public int hashCode ( ) { int result = this . x ; result = 1000003 * result + this . y ; result = 1000003 * result + this . position ; result = 1000003 * result + this . robotNumber ; result = 1000003 * result + this . shape ; return result ; }
tr	9	private void writeValue ( Object value ) throws JSONException { if ( value instanceof Number ) { String string = JSONObject . numberToString ( ( Number ) value ) ; int integer = this . values . find ( string ) ; if ( integer != none ) { write ( 2 , 2 ) ; writeAndTick ( integer , this . values ) ; return ; } if ( value instanceof Integer || value instanceof long ) { long longer = ( ( Number ) value ) . longValue ( ) ; if ( longer >= 0 && longer < int14 ) { write ( 0 , 2 ) ; if ( longer < int4 ) { zero ( ) ; write ( ( int ) longer , 4 ) ; return ; } one ( ) ; if ( longer < int7 ) { zero ( ) ; write ( ( int ) longer , 7 ) ; return ; } one ( ) ; write ( ( int ) longer , 14 ) ; return ; } } write ( 1 , 2 ) ; for ( int i = 0 ; i < string . length ( ) ; i += 1 ) { write ( bcd ( string . charAt ( i ) ) , 4 ) ; } write ( endOfNumber , 4 ) ; this . values . register ( string ) ; } else { write ( 3 , 2 ) ; writeJSON ( value ) ; } }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	5	private CarCriterion carCriterionParse ( String a ) { if ( a . equals ( CarCriterion . COMFORT . toString ( ) ) ) { return CarCriterion . COMFORT ; } else if ( a . equals ( CarCriterion . ECONOMY . toString ( ) ) ) { return CarCriterion . ECONOMY ; } else if ( a . equals ( CarCriterion . HANDLING . toString ( ) ) ) { return CarCriterion . HANDLING ; } else if ( a . equals ( CarCriterion . PERFORMANCE . toString ( ) ) ) { return CarCriterion . PERFORMANCE ; } else if ( a . equals ( CarCriterion . QUALITY . toString ( ) ) ) { return CarCriterion . QUALITY ; } else { return null ; } }
tr	2	public static int getSeqVal ( String sql ) { try { PreparedStatement stat = connection . prepareStatement ( sql ) ; ResultSet re = stat . executeQuery ( ) ; if ( re . next ( ) ) { return re . getInt ( 1 ) ; } else { return - 1 ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return - 1 ; }
tr	0	@ Override public String toString ( ) { return "Dominio.Ausencia[ id=" + id + " ]" ; }
tr	4	private void refreshButtons ( ) { if ( null == this . computedSolutionList ) { this . jcomboSelectSolution . setEnabled ( false ) ; this . jbutSolutionHint . setEnabled ( false ) ; this . jbutNextMove . setEnabled ( false ) ; this . jbutPrevMove . setEnabled ( false ) ; this . jbutAllMoves . setEnabled ( false ) ; this . jbutNoMoves . setEnabled ( false ) ; } else { if ( this . computedSolutionList . get ( this . computedSolutionIndex ) . size ( ) > 0 ) { this . jcomboSelectSolution . setEnabled ( ( this . computedSolutionList . size ( ) > 1 ) ) ; this . jbutSolutionHint . setEnabled ( true ) ; } this . jbutNextMove . setEnabled ( true ) ; this . jbutPrevMove . setEnabled ( true ) ; this . jbutAllMoves . setEnabled ( true ) ; this . jbutNoMoves . setEnabled ( true ) ; if ( this . moves . size ( ) == this . computedSolutionList . get ( this . computedSolutionIndex ) . size ( ) ) { this . jbutNextMove . setEnabled ( false ) ; this . jbutAllMoves . setEnabled ( false ) ; } if ( this . moves . isEmpty ( ) ) { this . jbutPrevMove . setEnabled ( false ) ; this . jbutNoMoves . setEnabled ( false ) ; } } }
tr	8	public static Highscore [ ] load ( InputStream in ) throws IOException { Vector highscores = new Vector ( 20 , 40 ) ; InputStreamReader inr = new InputStreamReader ( in ) ; String line ; while ( ( line = jgame . impl . EngineLogic . readline ( inr ) ) != null ) { Vector fields = new Vector ( 5 , 10 ) ; Vector tokens = jgame . impl . EngineLogic . tokenizeString ( line , 	 ) ; for ( Enumeration e = tokens . elements ( ) ; e . hasMoreElements ( ) ; ) { String tok = ( String ) e . nextElement ( ) ; if ( tok . equals ( "`" ) ) tok = "" ; fields . addElement ( tok ) ; } Highscore hs = null ; if ( fields . size ( ) == 1 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , "" ) ; } if ( fields . size ( ) >= 2 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , ( String ) fields . elementAt ( 1 ) ) ; } if ( fields . size ( ) >= 3 ) { hs . fields = new String [ fields . size ( ) - 2 ] ; for ( int i = 2 ; i < fields . size ( ) ; i ++ ) { hs . fields [ i - 2 ] = ( String ) fields . elementAt ( i ) ; } } highscores . addElement ( hs ) ; } Highscore [ ] ret = new Highscore [ highscores . size ( ) ] ; for ( int i = 0 ; i < highscores . size ( ) ; i ++ ) { ret [ i ] = ( Highscore ) highscores . elementAt ( i ) ; } return ret ; }
tr	4	@ Override public void mouseClicked ( MouseEvent arg0 ) { long now = System . currentTimeMillis ( ) ; long delta = now - timestamp ; timestamp = now ; if ( delta < 500 && ! secondClick ) { NotificationModel clickedNotification = ( NotificationModel ) list . getSelectedValue ( ) ; if ( unread . contains ( clickedNotification ) ) { unread . remove ( clickedNotification ) ; clickedNotification . setRead ( true ) ; read . add ( clickedNotification ) ; pcs . firePropertyChange ( NOTIFICATION_READ , null , clickedNotification ) ; try { clickedNotification . store ( ) ; } catch ( IOException e ) { System . err . println ( "ERROR: Exception happened while trying to store a notification as read" ) ; e . printStackTrace ( ) ; } } else { pcs . firePropertyChange ( NOTIFICATION_OLD_READ , null , clickedNotification ) ; } secondClick = true ; } else { secondClick = false ; } }
tr	6	public boolean isSubsetSum ( int [ ] nums , int sum ) { boolean [ ] [ ] cache = new boolean [ nums . length + 1 ] [ sum + 1 ] ; Arrays . sort ( nums ) ; System . out . println ( ) ; for ( int i = 1 ; i <= nums . length && nums [ i - 1 ] <= sum ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( cache [ i - 1 ] [ j ] == true ) { cache [ i ] [ j ] = true ; } else if ( nums [ i - 1 ] == j ) { cache [ i ] [ j ] = true ; } else if ( j > nums [ i - 1 ] ) { int remainder = j - nums [ i - 1 ] ; cache [ i ] [ j ] = cache [ i - 1 ] [ remainder ] ; } } } print2dArray ( cache , nums , sum ) ; return cache [ nums . length ] [ sum ] ; }
tr	6	public static boolean clicked ( int button ) { if ( button == MouseEvent . BUTTON1 ) return m1 && ! oldm1 ; else if ( button == MouseEvent . BUTTON2 ) return m2 && ! oldm2 ; else if ( button == MouseEvent . BUTTON3 ) return m3 && ! oldm3 ; else return false ; }
tr	1	public static Object getBean ( String patternName ) { try { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = dFactory . newDocumentBuilder ( ) ; Document document ; document = builder . parse ( new File ( "config.xml" ) ) ; String findClassName = patternName + "ClassName" ; NodeList nl = document . getElementsByTagName ( findClassName ) ; Node classNode = nl . item ( 0 ) . getFirstChild ( ) ; String cName = classNode . getNodeValue ( ) ; System . out . println ( cName ) ; String className = "com.seven." + patternName . toLowerCase ( ) + "." + cName ; class c = class . forName ( className ) ; Object object = c . newInstance ( ) ; return object ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	4	public void bloquearBoton ( ) { if ( this . tipoBarco == A ) { this . main . desactivarBotonUbicar ( 2 ) ; } else if ( this . tipoBarco == B ) { this . main . desactivarBotonUbicar ( 3 ) ; } else if ( this . tipoBarco == C ) { this . main . desactivarBotonUbicar ( 4 ) ; } else if ( this . tipoBarco == D ) { this . main . desactivarBotonUbicar ( 5 ) ; } }
tr	7	public boolean hasEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null || vTo == null ) { return false ; } for ( Vertex v2 : vFrom . adjacent ) { if ( v2 . vertex == vj ) { return true ; } } return false ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_BitcoinAcct ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	1	public static final < T extends Node < T >> void checkSameGraphs ( final Graph < T > g1 , final Graph < T > g2 ) { if ( g1 . getName ( ) . equals ( g2 . getName ( ) ) == false ) { throw new IllegalStateException ( "The two graphs are not same." ) ; } }
tr	2	private Viability initiateViability ( File habitatFolder ) throws IOException , InterruptedException { File viabilityCSV = new File ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY ) ; if ( ! viabilityCSV . exists ( ) || ! viabilityCSV . isFile ( ) ) throw new FileDoesntExist ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY , "but file with parameters of viability is strongly required" ) ; String fileContent = getFullFileContent ( viabilityCSV ) ; String preparedContent = preparer . getPreparedContent ( fileContent , ViabilityReader . INPUT_AREA ) ; saver . saveForCurrentPoint ( habitatFolder . getName ( ) , VIABILITY , preparedContent ) ; return new ViabilityReader ( preparedContent ) . getViability ( ) ; }
tr	4	private void resizeTable ( ) { int newLen ; int i = 0 ; while ( primes [ i ] <= table . length ) i ++ ; newLen = primes [ i ] ; int oldItems = numItems ; DataCount < E > [ ] oldTable = table ; E [ ] oldKeyArr = keyArr ; table = ( DataCount < E > [ ] ) new DataCount [ newLen ] ; keyArr = ( E [ ] ) new Object [ newLen ] ; numItems = 0 ; for ( i = 0 ; i < oldItems ; i ++ ) { E nextData = oldKeyArr [ i ] ; int hashFind = hasherH . hash ( nextData ) % oldTable . length ; while ( comparator . compare ( oldTable [ hashFind ] . data , nextData ) != 0 ) { hashFind = ( hashFind + hasherG . hash ( nextData ) ) % oldTable . length ; } E data = oldTable [ hashFind ] . data ; incCount ( data ) ; int hashCode = hasherH . hash ( data ) % table . length ; while ( comparator . compare ( table [ hashCode ] . data , data ) != 0 ) { hashCode = ( hashCode + hasherG . hash ( data ) ) % table . length ; } table [ hashCode ] . count = oldTable [ hashFind ] . count ; } }
tr	1	public void updateStatus ( ) { Log . finer ( Log . start ( new Throwable ( ) ) ) ; Electricity needsE = getNeedElectricity ( ) ; Log . fine ( "Culculate Electricty needing Electronics:" + needsE ) ; Electricity productE = dBoad . productElectorictiy ( ) ; Log . fine ( "Product Electricty:" + productE ) ; Electricity subE = productE . - ( needsE ) ; Log . fine ( "Cluculate Electricty Product-Needs:" + subE ) ; if ( subE . getWat ( ) < 0 ) { Electricity requestE = new Electricity ( ( int ) ( subE . getWat ( ) * - 1 ) ) ; buyElectricty ( requestE ) ; Log . fine ( "Buy the Electricity:" + requestE ) ; } else { sellElectricty ( subE ) ; Log . fine ( "Sell the Electricity:" + subE ) ; } updateMoney ( ) ; Log . finer ( Log . finish ( new Throwable ( ) ) ) ; }
tr	7	public CardCertificatesPane ( boolean ca , ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; String label = null ; baseIndex = ca ? 0 : 3 ; clearButtons = new JButton [ 3 ] ; viewButtons = new JButton [ 3 ] ; certNames = new JTextField [ 3 ] ; if ( ! ca ) { verifyButtons = new JButton [ 3 ] ; verifyFlags = new JTextField [ 3 ] ; } totalCerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalCerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; if ( ca ) { label = "CA Cert" ; } else { label = ulabels [ i ] + " Cert" ; } add ( new JLabel ( label + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; button = new JButton ( "Get from Card" ) ; button . setActionCommand ( "cardgetcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Load..." ) ; button . setActionCommand ( "loadcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certNames [ i ] = new JTextField ( 30 ) ; certNames [ i ] . setFont ( MainGUI . FONT ) ; certNames [ i ] . setEditable ( false ) ; components . add ( certNames [ i ] ) ; add ( certNames [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Clear" ) ; button . setActionCommand ( "clearcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; clearButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcardcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; viewButtons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new JButton ( "Verify" ) ; button . setActionCommand ( "verifycert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; verifyButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyFlags [ i ] = new JTextField ( 6 ) ; verifyFlags [ i ] . setFont ( MainGUI . FONT ) ; verifyFlags [ i ] . setEditable ( false ) ; components . add ( verifyFlags [ i ] ) ; add ( verifyFlags [ i ] , c ) ; } c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } updateCertsStatus ( ) ; setBorder ( BorderFactory . createTitledBorder ( ( ca ? "CA" : "User" ) + " Certificates" ) ) ; }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	8	public DescribeServiceCertificatesResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DescribeServiceCertificatesResult describeServiceCertificatesResult = new DescribeServiceCertificatesResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return describeServiceCertificatesResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "serviceCertificates/item" , targetDepth ) ) { describeServiceCertificatesResult . getServiceCertificates ( ) . add ( ServiceCertificateStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return describeServiceCertificatesResult ; } } } }
tr	0	public ToolsJP getToolsJP ( ) { return toolsJP ; }
tr	8	public void displayEmployee ( int index ) { Employee employee = Staff . getInstance ( ) . getEmployees ( ) . get ( index ) ; view . getFullNameTextField ( ) . setText ( employee . getFullName ( ) ) ; view . getBirthdayTextField ( ) . setText ( Staff . getDateFormat ( ) . format ( employee . getBirthday ( ) ) ) ; if ( employee . getSex ( ) . equals ( Sex . MALE ) ) { view . getSexradioMale ( ) . setSelected ( true ) ; } else { view . getSexradioFemale ( ) . setSelected ( true ) ; } String latestEmail = employee . getLatestEmail ( ) ; if ( latestEmail != null ) { view . getEmailAddressTextField ( ) . setText ( latestEmail ) ; } TelephoneNumber latestPhoneNumber = employee . getLatestPhoneNumber ( ) ; if ( latestPhoneNumber != null ) { view . getCellPhoneNumberTextField ( ) . setText ( latestPhoneNumber . getPhoneNumber ( ) ) ; } view . getNoIdentityCardTextField ( ) . setText ( employee . getIdentityCard ( ) . getCardNum ( ) ) ; view . getIssueDateText ( ) . setText ( Staff . getDateFormat ( ) . format ( employee . getIdentityCard ( ) . getIssuedDate ( ) ) ) ; view . getIssuePlaceTextField ( ) . setText ( employee . getIdentityCard ( ) . getIssuedPlace ( ) ) ; view . getPermanentAddressTexField ( ) . setText ( employee . getPermanentAddress ( ) ) ; Address latestTempAddress = employee . getLatestTempAddress ( ) ; if ( latestTempAddress != null ) { view . getCurrentAddressTextField ( ) . setText ( latestTempAddress . getName ( ) ) ; } BankAccount latestAccount = employee . getLatestAccount ( ) ; if ( latestAccount != null ) { view . getAccountNoTextField ( ) . setText ( latestAccount . getAccountNo ( ) ) ; view . getNameOfBankTextField ( ) . setText ( ( latestAccount . getBankName ( ) ) ) ; } view . getEducationComboBox ( ) . setSelectedItem ( employee . getEducation ( ) ) ; Diploma latestDiploma = employee . getLatestDiploma ( ) ; if ( latestDiploma != null ) { view . getDiplomaTextField ( ) . setText ( latestDiploma . getName ( ) ) ; } Certificate latestLangCertificate = employee . getLatestLangCertificate ( ) ; if ( latestLangCertificate != null ) { view . getForeignLanguageTextField ( ) . setText ( latestLangCertificate . getName ( ) ) ; } Certificate latestITCertificate = employee . getLatestITCertificate ( ) ; if ( latestITCertificate != null ) { view . getCertificateOfITcombobox ( ) . setSelectedItem ( latestITCertificate . getName ( ) ) ; } isUpdate = true ; this . index = index ; setVisible ( true ) ; }
tr	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	2	public void append ( Color fg , Color bg , String text ) { try { StyledDocument doc = ( StyledDocument ) getDocument ( ) ; Style style = doc . addStyle ( "StyleName" , null ) ; if ( bg != null ) StyleConstants . setBackground ( style , bg ) ; StyleConstants . setForeground ( style , fg ) ; doc . insertString ( doc . getLength ( ) , text , style ) ; } catch ( BadLocationException ignored ) { } }
tr	2	public Dienbienluong findById ( java . lang . Integer id ) { log . debug ( "getting Dienbienluong instance with id: " + id ) ; try { Dienbienluong instance = ( Dienbienluong ) sessionFactory . getCurrentSession ( ) . get ( "edu.hust.k54.persistence.Dienbienluong" , id ) ; if ( instance == null ) { log . debug ( "get successful  no instance found" ) ; } else { log . debug ( "get successful  instance found" ) ; } return instance ; } catch ( RuntimeException re ) { log . error ( "get failed" , re ) ; throw re ; } }
tr	0	public byte getNotSettable ( ) { return notSettable ; }
tr	5	Call exit ( MethodData method , ArrayList < TraceAction > trace ) { Call call = top ( ) ; if ( call . mCaller == null ) { return null ; } if ( call . getMethodData ( ) != method ) { String error = "Method exit (" + method . getName ( ) + ") does not match current method (" + call . getMethodData ( ) . getName ( ) + ")" ; throw new RuntimeException ( error ) ; } mStack . remove ( mStack . size ( ) - 1 ) ; if ( trace != null ) { trace . add ( new TraceAction ( TraceAction . ACTION_EXIT , call ) ) ; } Integer num = mStackMethods . get ( method ) ; if ( num != null ) { if ( num == 1 ) { mStackMethods . remove ( method ) ; } else { mStackMethods . put ( method , num - 1 ) ; } } return call ; }
tr	6	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
tr	4	private boolean isTranEnabled ( ArrayList < Automaton > disTA , HashMap < Integer , Set < Guard >> guard , ArrayList < State > state ) { if ( guard != null ) { for ( int i = 0 ; i < disTA . size ( ) ; i ++ ) { if ( guard . get ( i ) != null ) { Zone zone = state . get ( i ) . getZone ( ) ; zone = zone . and ( guard . get ( i ) , disTA . get ( i ) . getClocks ( ) ) ; if ( zone . getZoneDataStruct ( ) [ 0 ] [ 0 ] [ 0 ] == - 1 ) return false ; } } } return true ; }
tr	5	public boolean move ( Direction direction , StringBuffer output ) throws EndGameException { boolean hasMoved = false ; if ( myPosition . isCrossable ( direction ) ) { if ( myPosition . hasCharacter ( direction ) ) { Character defender = myPosition . getCharacter ( direction ) ; if ( attack ( defender ) ) { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You attacked and killed " + defender + ". You moved " + direction ) ; hasMoved = true ; } else { if ( isDead ( ) ) throw new EndGameException ( "Player has died. GAME OVER!" ) ; output . append ( "You attacked: \n" + defender . toString ( ) + "\n" + this . toString ( ) ) ; } } else { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You moved " + direction + "." ) ; hasMoved = true ; } } else { output . append ( checkIfLockedExit ( direction ) ) ; } if ( hasMoved ) { notifyPositionChanged ( direction . getOppositeDirection ( ) ) ; } return hasMoved ; }
tr	1	void configure ( ImageAnalyzerFactory mediator ) throws TesseractException { mediator . handle . setPageSegMode ( psm ) ; for ( String name : properties . keySet ( ) ) { String value = properties . get ( name ) ; mediator . handle . setVariable ( name , value ) ; } }
tr	3	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
tr	9	private List < List < String >> find ( String end , Set < String > dict , List < List < String >> nowLists ) { List < List < String >> ansLists = new ArrayList < List < String >> ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; if ( checkValid ( nowStr , end ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( end ) ; ansLists . add ( temp ) ; } } if ( ansLists . size ( ) > 0 ) return ansLists ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : almostList ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; ansLists . add ( temp ) ; } } } if ( ansLists . size ( ) > 0 ) return find ( end , dict , ansLists ) ; List < String > removeList = new ArrayList < String > ( ) ; for ( List < String > subList : nowLists ) { String nowStr = subList . get ( subList . size ( ) - 1 ) ; for ( String s : dict ) { if ( checkValid ( nowStr , s ) ) { List < String > temp = new ArrayList < String > ( subList ) ; temp . add ( s ) ; removeList . add ( s ) ; ansLists . add ( temp ) ; } } } for ( String s : removeList ) { dict . remove ( s ) ; } if ( ansLists . size ( ) == 0 ) return ansLists ; return find ( end , dict , ansLists ) ; }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	4	@ Override public int compareTo ( Object o ) { ArtistTrack other = ( ArtistTrack ) o ; if ( _artistID < other . _artistID ) return - 1 ; else if ( _artistID > other . _artistID ) return 1 ; else if ( _trackID < other . _trackID ) return - 1 ; else if ( _trackID > other . _trackID ) return 1 ; else return 0 ; }
tr	5	private String stripBackspaces ( String s ) { byte [ ] data = null ; try { data = s . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } byte [ ] newData = new byte [ data . length ] ; int i , writeIndex ; for ( i = 0 , writeIndex = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == ( byte ) 8 ) { if ( writeIndex > 0 ) { writeIndex -- ; } } else { newData [ writeIndex ++ ] = data [ i ] ; } } try { return new String ( newData , 0 , writeIndex , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; return null ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( ) . setVisible ( true ) ; } } ) ; }
tr	2	public void filterMax ( final boolean [ ] nonmatches , final int index , final double comparison ) { if ( ! double . isNaN ( comparison ) ) { final double [ ] values = this . maxFields [ index ] ; for ( int i = 0 ; i < this . size ; i ++ ) { nonmatches [ i ] |= ( values [ i ] > comparison ) ; } } }
tr	6	public void actionPerformed ( ActionEvent ae ) { Automaton aut = Automaton . makeEmpty ( ) ; Iterator < String > lines = Util . readLinesFromString ( regTextPane . getText ( ) ) ; while ( lines . hasNext ( ) ) { try { String s = lines . next ( ) ; RegExp re = new RegExp ( s ) ; Automaton a = re . toAutomaton ( ) ; aut = aut . union ( a ) ; } catch ( IllegalArgumentException e ) { } aut . minimize ( ) ; } if ( aut . isEmpty ( ) || aut . isEmptyString ( ) ) { ErrorFrame . spawnError ( "Your regular expression" + " does not match any string." ) ; } else if ( ! Util . isPossible4chanAutomaton ( aut ) ) { ErrorFrame . spawnError ( "Your regular expression does not " + "match any 4chan trip codes" ) ; } else { this . setEnabled ( false ) ; int threads = 0 ; try { String val = ( String ) coreDropDown . getSelectedItem ( ) ; threads = Integer . parseInt ( val ) ; } catch ( NumberFormatException nfe ) { threads = 8 ; } stopAction . setEnabled ( true ) ; RunAutomaton ra = new RunAutomaton ( aut ) ; HashDispatcher . dispatch ( ra , threads ) ; updateTps ( ) ; } }
tr	3	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getOpenChar ( ) ) ; if ( elements != null ) { for ( INode elt : elements ) { sb . append ( elt . toString ( ) ) ; sb . append ( " " ) ; } } if ( elements . size ( ) > 1 ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; sb . append ( getCloseChar ( ) ) ; return sb . toString ( ) ; }
tr	6	@ Override public void paintNode ( Graphics2D g2d , ScRegion region ) { g2d . setStroke ( ScGraphStyles . getFrameStroke ( ) ) ; g2d . setColor ( this . getStrokeColor ( ) ) ; GeneralPath path = new GeneralPath ( GeneralPath . WIND_NON_ZERO ) ; path . moveTo ( ( int ) region . getX ( ) , ( int ) ( region . getY ( ) + region . getHeight ( ) ) ) ; path . lineTo ( ( int ) ( region . getX ( ) + region . getWidth ( ) ) , ( int ) ( region . getY ( ) + region . getHeight ( ) ) ) ; path . lineTo ( ( int ) ( region . getX ( ) + region . getWidth ( ) ) , ( int ) region . getY ( ) ) ; path . lineTo ( ( int ) ( region . getX ( ) ) , ( int ) region . getY ( ) ) ; path . closePath ( ) ; g2d . draw ( path ) ; FontMetrics metrics = g2d . getFontMetrics ( ScGraphStyles . getAxisFont ( ) ) ; g2d . setFont ( ScGraphStyles . getAxisFont ( ) ) ; double textHeight = metrics . getHeight ( ) ; double yPositionFixed = region . getNormalizedY ( 1.0 ) ; int xloop = 0 ; for ( double xc : this . axisPair . getAxisX ( ) . getAxisTicks ( ) ) { double xcr = this . axisPair . getAxisX ( ) . getRelative ( xc ) ; if ( xcr >= 0 && xcr <= 1.0 ) { double xcA = region . getNormalizedX ( xcr ) ; g2d . drawLine ( ( int ) xcA , ( int ) yPositionFixed , ( int ) xcA , ( int ) yPositionFixed - 10 ) ; String text = this . axisPair . getAxisX ( ) . getAxisTicksString ( ) . get ( xloop ) ; double width = metrics . stringWidth ( text ) ; g2d . drawString ( text , ( int ) ( xcA - width / 2.0 ) , ( int ) ( yPositionFixed + textHeight * 1.2 ) ) ; } xloop ++ ; } double xPositionFixed = region . getNormalizedX ( 0.0 ) ; int yloop = 0 ; for ( double yc : this . axisPair . getAxisY ( ) . getAxisTicks ( ) ) { double ycr = this . axisPair . getAxisY ( ) . getRelative ( yc ) ; if ( ycr >= 0 && ycr <= 1.0 ) { double ycA = region . getNormalizedY ( 1.0 - ycr ) ; g2d . drawLine ( ( int ) xPositionFixed , ( int ) ycA , ( int ) xPositionFixed + 10 , ( int ) ycA ) ; String text = this . axisPair . getAxisY ( ) . getAxisTicksString ( ) . get ( yloop ) ; double width = metrics . stringWidth ( text ) ; g2d . drawString ( text , ( int ) ( xPositionFixed - width - 10.0 ) , ( int ) ( ycA + 0.5 * textHeight / 2.0 ) ) ; } yloop ++ ; } String xtitle = this . axisPair . getAxisX ( ) . getTitle ( ) ; double xmiddle = this . axisPair . getAxisX ( ) . getMiddle ( ) ; double xcoord = region . getNormalizedX ( this . axisPair . getAxisX ( ) . getRelative ( xmiddle ) ) ; double xtitleWidth = metrics . stringWidth ( xtitle ) ; g2d . drawString ( xtitle , ( int ) ( xcoord - xtitleWidth / 2.0 ) , ( int ) ( yPositionFixed + 4.5 * textHeight / 2.0 ) ) ; }
tr	6	@ Override public void run ( ) { while ( true ) { try { Logger . log ( "Please enter\"5\" to view a map of registered DataNodes" + "\n Please enter \"6\" to view running jobs" ) ; choice = br . readLine ( ) ; if ( choice == "" || choice == null ) { throw new Exception ( "Blank input not allowed." ) ; } switch ( choice ) { case ( "5" ) : NameNode . instance . displayDataNodes ( ) ; break ; case ( "6" ) : NameNode . instance . jtThread . displayRunningJobs ( ) ; break ; default : throw new Exception ( "Invalid Input detected: " + choice ) ; } } catch ( Exception e ) { Logger . log ( e . getMessage ( ) ) ; } } }
tr	6	public int maxLength ( int R , int G , int B ) { int [ ] rgb = { R , G , B } ; if ( rgb [ 0 ] < rgb [ 1 ] ) { if ( rgb [ 2 ] < rgb [ 0 ] ) swap ( rgb , 0 , 2 ) ; } else { if ( rgb [ 1 ] < rgb [ 2 ] ) swap ( rgb , 0 , 1 ) ; else swap ( rgb , 0 , 2 ) ; } if ( rgb [ 2 ] < rgb [ 1 ] ) swap ( rgb , 1 , 2 ) ; int result ; if ( rgb [ 1 ] > rgb [ 2 ] ) result = 2 * rgb [ 2 ] + 1 ; else if ( rgb [ 1 ] < rgb [ 2 ] ) result = 2 * rgb [ 1 ] + 1 ; else result = rgb [ 1 ] + rgb [ 2 ] ; return result ; }
tr	2	public Engine ( Ship parent , int engineNum ) { this . parent = parent ; this . engineNum = engineNum ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; int totalPoints = parent . speed + ( parent . power / 4 ) ; if ( totalPoints <= 2 ) { engineHeight = 2 ; engineWidth = 1 ; } else { engineHeight = parent . map ( totalPoints , 1 , 1250 , 2 , 24 ) ; engineWidth = parent . map ( totalPoints , 1 , 1250 , 2 , 6 ) ; } engineHeight *= Ship . PIXEL_PER_UNIT ; engineWidth *= Ship . PIXEL_PER_UNIT ; if ( engineNum == 0 ) { eAtt = parent . body . e1Att ; } else { eAtt = parent . body . e2Att ; } engine = new ArrayList < Point2D . double > ( ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; }
tr	7	public static void printB ( String str ) { double num = double . parseDouble ( str ) ; if ( num == 0 ) System . out . println ( "0" ) ; else { int left = ( int ) num ; double right = num - left ; StringBuilder sb = new StringBuilder ( ) ; while ( left > 0 ) { sb . insert ( 0 , left % 2 ) ; left /= 2 ; } if ( right > 0 ) { sb . append ( "." ) ; int count = 0 ; while ( count < 32 ) { if ( right * 2 > 1 ) { sb . append ( 1 ) ; right = right * 2 - 1 ; } else if ( right * 2 == 1 ) { sb . append ( 1 ) ; break ; } else { sb . append ( 0 ) ; right *= 2 ; } count ++ ; } if ( count == 32 ) { System . out . println ( "ERROR" ) ; return ; } } System . out . println ( sb ) ; } }
tr	2	public static void writeFile ( String pathName , List < Command > list ) { File f = new File ( pathName ) ; ObjectOutputStream oout = null ; try { oout = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( f ) ) ) ; oout . writeObject ( list ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { oout . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	6	private String getPage ( int page , Map < String , Object > map ) { int factor = 5 ; int index = ( page - 1 ) * factor ; int listSize = map . size ( ) ; if ( index > listSize ) { return "" ; } int upper = index + factor ; if ( upper >= listSize ) { upper = listSize ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( ChatColor . RED ) . append ( plugin . getName ( ) ) . append ( "\n" ) . append ( ChatColor . RESET ) ; sb . append ( "Page " ) . append ( page ) . append ( "/" ) . append ( ( int ) Math . ceil ( ( double ) listSize / ( double ) factor ) ) ; sb . append ( "\n" ) . append ( ChatColor . RESET ) ; String [ ] list = map . keySet ( ) . toArray ( new String [ listSize ] ) ; Arrays . sort ( list ) ; for ( int i = index ; i < upper ; i ++ ) { Object test = map . get ( list [ i ] ) ; if ( test != null ) { if ( test instanceof SubCommand ) { SubCommand db = ( SubCommand ) map . get ( list [ i ] ) ; sb . append ( db . getHelp ( ) [ 0 ] ) . append ( " - " ) . append ( db . getHelp ( ) [ 1 ] ) ; } if ( i != upper - 1 ) { sb . append ( "\n" ) ; } } } sb . append ( '' ) . append ( ChatColor . YELLOW ) . append ( "Use /ttp help <command> to get help for a specific command" ) ; return sb . toString ( ) ; }
tr	6	private RequirementElement parseAttackElementInfo ( List < String > factors ) { RequirementElement new_elem = new RequirementElement ( ) ; if ( factors . get ( 2 ) . equals ( "Circle" ) && ! factors . get ( 3 ) . equals ( "empty" ) ) { new_elem = new NewAntiGoal ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; new_elem . setType ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ; String sg_name = factors . get ( 3 ) ; new_elem . setName ( sg_name . trim ( ) ) ; ( ( NewAntiGoal ) new_elem ) . extractInfoFromName ( ) ; } else if ( checkCircle ( factors . get ( 7 ) ) ) { } else { new_elem = new RequirementElement ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; if ( factors . get ( 2 ) . equals ( "Hexagon" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . TASK . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "Rectangle" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . DOMAIN_ASSUMPTION . name ( ) ) ; } else if ( factors . get ( 3 ) . equals ( "empty" ) & factors . get ( 2 ) . equals ( "Circle" ) & factors . get ( 10 ) . equals ( "0" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ; } else { } new_elem . setName ( factors . get ( 3 ) ) ; } String [ ] temp2 = factors . get ( 11 ) . split ( " " ) ; new_elem . origin_x = double . parseDouble ( temp2 [ 0 ] . replace ( " " , "." ) ) ; new_elem . origin_y = double . parseDouble ( temp2 [ 1 ] . replace ( " " , "." ) ) ; return new_elem ; }
tr	7	public static String timeToString3 ( Date date ) { if ( date == null ) return "\u65E0" ; long milliSecond = System . currentTimeMillis ( ) - date . getTime ( ) ; int ss = 1000 ; int mi = ss * 60 ; int hh = mi * 60 ; long day = hh * 24 ; long month = day * 30 ; long year = month * 12 ; long years = ( milliSecond ) / year ; long months = ( long ) ( ( milliSecond - years * year ) / month ) ; long days = ( milliSecond - years * year - months * month ) / day ; long hour = ( long ) ( ( milliSecond - years * year - months * month - days * day ) / hh ) ; long minute = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh ) / mi ) ; long second = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh - minute * mi ) / ss ) ; String result = "" ; if ( years != 0 ) { result += years + "\u5E74\u524D" ; } else if ( months != 0 ) { result += months + "\u6708\u524D" ; } else if ( days != 0 ) { result += days + "\u5929\u524D" ; } else if ( hour != 0 ) { result += hour + "\u5C0F\u65F6\u524D" ; } else if ( minute != 0 ) { result += minute + "\u5206\u949F\u524D" ; } else if ( second != 0 ) { result += second + "\u79D2\u524D" ; } return result ; }
tr	6	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
tr	5	@ Override public void move ( int where ) { if ( false == enabled ) return ; int x = 0 , y = 0 ; if ( ( where & FRONT ) != 0 ) y = 1 ; if ( ( where & BACK ) != 0 ) y = - 1 ; if ( ( where & RIGHT ) != 0 ) x = 1 ; if ( ( where & LEFT ) != 0 ) x = - 1 ; this . change_angle = x ; this . change_speed = y ; this . flags = where ; immediateUpdate = true ; }
tr	7	@ Override public void actionPerformed ( ActionEvent e ) { Labyrinthe laby = new Labyrinthe ( tab ) ; if ( this != null ) { JFileChooser filechooser = new JFileChooser ( "." ) { public void approveSelection ( ) { fileSelected = getSelectedFile ( ) ; if ( fileSelected . exists ( ) ) { int result = JOptionPane . showConfirmDialog ( this , "Ecraser le fichier?" , "Confirmation" , JOptionPane . YES_NO_CANCEL_OPTION ) ; switch ( result ) { case JOptionPane . YES_OPTION : super . approveSelection ( ) ; return ; default : super . cancelSelection ( ) ; } } else super . approveSelection ( ) ; } } ; if ( filechooser . showSaveDialog ( null ) == JFileChooser . APPROVE_OPTION ) { for ( int i = 0 ; i < tab . length ; i ++ ) { for ( int j = 0 ; j < tab [ i ] . length ; j ++ ) { System . out . println ( "Valeur du tableau " + tab [ i ] [ j ] . etat ) ; } } } } else { JOptionPane . showMessageDialog ( InterfaceEditeur . this , "veuillez creer un nouveau labyrinthe ou charger un labyrinthe existant" , "Erreur" , JOptionPane . ERROR_MESSAGE ) ; } try { laby . addToFile ( laby , fileSelected ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } getContentPane ( ) . revalidate ( ) ; }
tr	4	@ Override public void input ( float delta ) { float movAmt = speed * delta ; if ( Input . getKey ( leftKey ) ) move ( getTransform ( ) . getRot ( ) . getLeft ( ) , movAmt ) ; if ( Input . getKey ( rightKey ) ) move ( getTransform ( ) . getRot ( ) . getRight ( ) , movAmt ) ; if ( Input . getKey ( downKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , - movAmt ) ; else if ( Input . getKey ( upKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , movAmt ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! this . getClass ( ) . equals ( obj . getClass ( ) ) ) { return false ; } Struct3 < ? , ? , ? > t = ( Struct3 < ? , ? , ? > ) obj ; return Calc . areObjectsEqual ( a , t . a ) && Calc . areObjectsEqual ( b , t . b ) && Calc . areObjectsEqual ( c , t . c ) ; }
tr	4	private Point getNextGoal ( ) { if ( dir == 0 ) { goal . y = Math . abs ( goal . x ) ; dir = 1 ; } else if ( dir == 1 ) { goal . x = Math . abs ( goal . y ) + Config . BUG_SPIRAL ; dir = 2 ; } else if ( dir == 2 ) { goal . y = - goal . x ; dir = 3 ; } else if ( dir == 3 ) { goal . x = goal . y ; dir = 0 ; } System . out . println ( "Next goal: " + goal . x + " : " + goal . y ) ; return goal ; }
tr	4	public static int maxProfit ( int [ ] prices ) { if ( prices . length == 0 ) return 0 ; int [ ] maxdiff = new int [ prices . length ] ; int max = prices [ prices . length - 1 ] ; maxdiff [ prices . length - 1 ] = 0 ; for ( int i = prices . length - 1 ; i > 0 ; i -- ) { max = Math . max ( max , prices [ i ] ) ; maxdiff [ i - 1 ] = Math . max ( maxdiff [ i ] , max - prices [ i ] ) ; } int min = prices [ 0 ] ; int summax = 0 ; for ( int i = 0 ; i < prices . length ; i ++ ) { if ( prices [ i ] < min ) min = prices [ i ] ; summax = Math . max ( prices [ i ] - min + maxdiff [ i ] , summax ) ; } return summax ; }
tr	9	@ Override public void drawGui ( ) { if ( this . drawButton ) { final String type = this . disabled ? "disabled" : this . isMouseInArea ( ) ? Mouse . isButtonDown ( 0 ) ? "in" : "glow" : "out" ; Monopoly . getInstance ( ) . getEngine ( ) . bindTexture ( "/textures/button_" + type + "_new.png" ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x , this . y , 0 , 0 , 5 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + this . w - 5 , this . y , 59 , 0 , 5 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x , this . y + this . h - 5 , 0 , 59 , 5 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + this . w - 5 , this . y + this . h - 5 , 59 , 59 , 5 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + 5 , this . y , 6 , 0 , this . w - 10 , 5 , 52 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x , this . y + 5 , 0 , 6 , 5 , this . h - 10 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + this . w - 5 , this . y + 5 , 59 , 5 , 5 , this . h - 10 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + 5 , this . y + this . h - 5 , 5 , 59 , this . w - 10 , 5 , 52 , 5 ) ; Monopoly . getInstance ( ) . getEngine ( ) . drawTexturedRectangle ( this . x + 5 , this . y + 5 , 6 , 6 , this . w - 10 , this . h - 10 , 52 , 52 ) ; StringRenderer . drawCenteredString ( this . text , this . x + this . w - this . w / 2 , this . y / 2 + ( this . y + this . h ) / 2 + ( this . isMouseInArea ( ) && Mouse . isButtonDown ( 0 ) && ! this . disabled ? - 1 : - 2 ) - this . size / 2 , this . size , true , Color . WHITE ) ; } if ( Mouse . isButtonDown ( 0 ) && this . isMouseInArea ( ) && ! this . disabled ) { this . parent . onButtonPressed ( this ) ; this . lastState = true ; } else if ( this . lastState && this . isMouseInArea ( ) && ! this . disabled ) { this . parent . onButtonReleased ( this ) ; this . lastState = false ; } }
tr	9	public static int heading ( double longFrom , double latFrom , double longTo , double latTo ) { double latDiff = latTo - latFrom ; double longDiff = longTo - longFrom ; latDiff *= 110828.28 ; longDiff *= 97862.52 ; double angle ; int quadrant ; if ( longDiff == 0 ) angle = 0 ; else { if ( latDiff < 0 && longDiff < 0 ) quadrant = 3 ; else if ( latDiff < 0 && longDiff > 0 ) quadrant = 2 ; else if ( latDiff >= 0 && longDiff < 0 ) quadrant = 4 ; else quadrant = 1 ; latDiff = Math . abs ( latDiff ) ; longDiff = Math . abs ( longDiff ) ; angle = Math . atan ( latDiff / longDiff ) ; angle *= 180 / ( Math . PI ) ; switch ( quadrant ) { case 1 : angle = 90 - angle ; break ; case 2 : angle = 90 + angle ; break ; case 3 : angle = 270 - angle ; break ; case 4 : angle = 270 + angle ; break ; } } return ( int ) angle ; }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	5	@ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws IOException { UserService userService = UserServiceFactory . getUserService ( ) ; User user = userService . getCurrentUser ( ) ; String guestbookName = request . getParameter ( "guestbookName" ) ; String emailDeclared = request . getParameter ( "email" ) ; String nameDeclared = request . getParameter ( "name" ) ; if ( guestbookName == null ) { guestbookName = "default" ; } if ( emailDeclared == null ) { emailDeclared = user . getEmail ( ) ; } if ( nameDeclared == null ) { nameDeclared = user . getNickname ( ) ; } Key guestbookKey = KeyFactory . createKey ( "Guestbook" , guestbookName ) ; String content = request . getParameter ( "message" ) ; if ( content == null ) { content = "Greetings!" ; } if ( user != null ) { Entity greeting = new Entity ( "Greeting" , guestbookKey ) ; Date date = new Date ( ) ; greeting . setProperty ( "user" , user ) ; greeting . setProperty ( "date" , date ) ; greeting . setProperty ( "userId" , user . getUserId ( ) ) ; greeting . setProperty ( "federatedId" , user . getFederatedIdentity ( ) ) ; greeting . setProperty ( "domain" , user . getAuthDomain ( ) ) ; greeting . setProperty ( "content" , content ) ; greeting . setProperty ( "nameDeclared" , nameDeclared ) ; greeting . setProperty ( "emailDeclared" , emailDeclared ) ; DatastoreService ds = DatastoreServiceFactory . getDatastoreService ( ) ; ds . put ( greeting ) ; } else { log . info ( "Anonymous: " + content ) ; } response . sendRedirect ( "/guest.jsp?guestbookName=" + guestbookName ) ; }
tr	3	@ Override public void run ( ) { gui . setEnabled ( false ) ; keypanel . dualP . showMinorCard ( ) ; final byte [ ] m = getMaster ( keypanel . dualP ) ; if ( m != null ) { Sleep . ms ( delay [ 0 ] ) ; if ( ! gui . isPasswordOnly ( ) ) { playList ( ) ; if ( meta . getSeparator ( ) == null ) { JOptionPane . showMessageDialog ( keypanel . dualP , "Click OK to type password" ) ; Sleep . ms ( delay [ 0 ] ) ; } else Sleep . ms ( delay [ 1 ] ) ; } final char [ ] pw = meta . generatePassword ( m ) ; Arrays . fill ( m , ( byte ) 0 ) ; play ( KeyAction . compile ( pw ) , true ) ; Arrays . fill ( pw , ( char ) 0 ) ; } keypanel . dualP . showMajorCard ( ) ; gui . setEnabled ( true ) ; }
tr	2	@ Override public void mouseReleased ( MouseEvent e ) { if ( e . getModifiers ( ) == 16 ) { fillEditor ( ) ; getParent ( ) . invalidate ( ) ; } else if ( e . getModifiers ( ) == 4 ) { showTimeoutColor = false ; repaint ( ) ; } }
tr	5	static String getDefaultLibPath ( final typeOS os ) { if ( os . equals ( typeOS . WINDOWS ) ) { try { String value = WinRegistryReadOnly . readString ( WinRegistryReadOnly . HKEY_LOCAL_MACHINE , "SOFTWARE\\Open-Transactions" , "Path" ) ; if ( null == value ) { return "" ; } Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . INFO , "Found OT path in registry:{0}" , value ) ; return value ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InvocationTargetException ex ) { Logger . getLogger ( Tools . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } return "" ; }
tr	8	public void setActivePanel ( final PanelType type ) { if ( this . frame != null ) { this . frame . dispose ( ) ; } switch ( type ) { case START : this . frame = new PlainPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case CLUBS : this . frame = new ClubPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case GYM : this . frame = new GymPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG : this . frame = new GamePanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG_DIR : this . frame = new AllGamesPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case TEAMS : this . frame = new TeamPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case RANKING : this . frame = new RankingPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; } this . sfb . setWeights ( new int [ ] { 30 , 70 } ) ; }
tr	9	private void findRecipes ( ) { listModel . clear ( ) ; TreeMap < Integer , SortedSet < Recipe >> recipeMap = new TreeMap < > ( ) ; Set < Ingredient > matchingIngredients = new HashSet < > ( customIngredients ) ; for ( CheckBoxWithIngredient cb : checkBoxes ) { if ( cb . isChecked ( ) ) { matchingIngredients . add ( cb . getIngredient ( ) ) ; } } for ( Recipe recipe : allRecipes ) { Set < Ingredient > recipeIngredients = new HashSet < > ( ) ; for ( RecipeSection section : recipe . getSections ( ) ) { for ( RecipeIngredient rIngredient : section . getIngredients ( ) ) { Ingredient ingredient = rIngredient . getIngredient ( ) ; if ( ! ingredient . isCommon ( ) ) { recipeIngredients . add ( ingredient ) ; } } } recipeIngredients . removeAll ( matchingIngredients ) ; int numberOfMissingIngredients = recipeIngredients . size ( ) ; if ( recipeMap . get ( numberOfMissingIngredients ) == null ) { recipeMap . put ( numberOfMissingIngredients , new TreeSet < Recipe > ( ) ) ; } recipeMap . get ( numberOfMissingIngredients ) . add ( recipe ) ; } for ( int i : recipeMap . keySet ( ) ) { for ( Recipe recipe : recipeMap . get ( i ) ) { listModel . addElement ( recipe ) ; } } int leastMissingIngredients = recipeMap . firstKey ( ) ; Recipe bestRecipe = recipeMap . get ( leastMissingIngredients ) . first ( ) ; String message = "The best matching recipe is '" + bestRecipe + "' which is missing " + leastMissingIngredients + " ingredient" ; if ( leastMissingIngredients != 1 ) { message = message + "s" ; } JOptionPane . showMessageDialog ( panel , message , "Best matching recipe" , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	8	public boolean equals ( consultar_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
tr	1	static int modInverse ( int a , int mod ) { int [ ] xy = new int [ 2 ] ; if ( extgcd ( a , mod , xy ) != 1 ) throw new ArithmeticException ( "no inverse exsits" ) ; return ( mod + xy [ 0 ] % mod ) % mod ; }
tr	9	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
tr	3	public static void init ( ) { if ( colors != null ) return ; maxColors = COLOR_RECORDS ; colors = new Color [ maxColors * COLOR_LEVELS ] ; final int [ ] def = { 255 , 255 , 255 , 192 , 192 , 192 , 128 , 128 , 128 , 64 , 64 , 64 , 0 , 0 , 0 , 255 , 0 , 0 , 255 , 175 , 175 , 255 , 200 , 0 , 255 , 255 , 0 , 0 , 255 , 0 , 255 , 0 , 255 , 0 , 255 , 255 , 0 , 0 , 255 , 99 , 66 , 33 , 33 , 99 , ff , 00 , 88 , 00 , } ; for ( int i = 0 ; i < def . length ; i += 3 ) { add ( i / 3 , def [ i + 0 ] , def [ i + 1 ] , def [ i + 2 ] ) ; } final int [ ] trans = { BLUE , RED , RED , DARKGREEN , DARKGREEN , BLUE , GRAY , RED , GRAY , DARKGREEN , } ; for ( int i = 0 , j = BLUERED ; i < trans . length ; i += 2 , j ++ ) { int s = trans [ i + 0 ] * 3 ; int d = trans [ i + 1 ] * 3 ; addTransition ( j , def [ s + 0 ] , def [ s + 1 ] , def [ s + 2 ] , def [ d + 0 ] , def [ d + 1 ] , def [ d + 2 ] ) ; } }
tr	3	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPath ) return this . equals ( ( ASPath ) o ) ; return false ; }
tr	4	private void reHeapify ( ArrayList < Step > steps ) { int size = heapValues . length - 1 ; int child = 2 ; while ( child <= size ) { if ( ( child < size ) && ( heapValues [ child ] < heapValues [ child + 1 ] ) ) child ++ ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapCompareStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; if ( heapValues [ child / 2 ] > heapValues [ child ] ) break ; byte temp = heapValues [ child / 2 ] ; heapValues [ child / 2 ] = heapValues [ child ] ; heapValues [ child ] = temp ; arrayValues [ child / 2 ] = heapValues [ child / 2 ] ; arrayValues [ child ] = heapValues [ child ] ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapSwapStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; child *= 2 ; } }
tr	1	private FormalParametersNode formalParameters ( ) { List < FPSectionNode > fpsections = new ArrayList < FPSectionNode > ( ) ; FPSectionNode fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; while ( test ( SEMICOLON ) ) { read ( SEMICOLON , ";" ) ; fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; } return new FormalParametersNode ( fpsections ) ; }
tr	3	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new ArrayList < Plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getModule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerDe ( this . vecteur_vitesse ) ; this . plots . add ( new Plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
tr	0	@ Override protected double getDefault ( ) { return 0d ; }
tr	6	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
tr	5	protected Influence makeInfluence ( PhysicalInfluence i ) { if ( i . target ( ) == null ) return null ; if ( i instanceof MovementInfluence ) return this . makeInfluence ( ( MovementInfluence ) i ) ; if ( i instanceof CollideInfluence ) return this . makeInfluence ( ( CollideInfluence ) i ) ; if ( i instanceof ChangeBodyPropertyInfluence ) return this . makeInfluence ( ( ChangeBodyPropertyInfluence ) i ) ; if ( i instanceof DeathInfluence ) return this . makeInfluence ( ( DeathInfluence ) i ) ; return null ; }
tr	7	public EigenvalueDecomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . getArray ( ) ; n = Arg . getColumnDimension ( ) ; V = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = true ; for ( int j = 0 ; ( j < n ) & issymmetric ; j ++ ) { for ( int i = 0 ; ( i < n ) & issymmetric ; i ++ ) { issymmetric = ( A [ i ] [ j ] == A [ j ] [ i ] ) ; } } if ( issymmetric ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { V [ i ] [ j ] = A [ i ] [ j ] ; } } tred2 ( ) ; tql2 ( ) ; } else { H = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { H [ i ] [ j ] = A [ i ] [ j ] ; } } orthes ( ) ; hqr2 ( ) ; } }
tr	2	public static void test ( String s ) { String - ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { for ( int i = 1 ; i <= s . length ( ) - c ; i ++ ) { - = s . substring ( c , c + i ) ; System . out . println ( - ) ; } } }
tr	3	public void setRows ( int newRows ) { if ( newRows < 0 ) throw new IllegalArgumentException ( "number of rows cannot be negative" ) ; if ( newRows == 0 && cols == 0 ) throw new IllegalArgumentException ( "number of columns is already 0" ) ; this . rows = newRows ; }
tr	5	protected void scrollUp ( final int firstScrollLine , final int lastScrollLine , final int lines ) { if ( firstScrollLine < 0 ) { throw new IllegalArgumentException ( "First scroll line cannot be less than zero!" ) ; } if ( lastScrollLine >= getHeight ( ) ) { throw new IllegalArgumentException ( "Last scroll line cannot be greater than terminal height!" ) ; } if ( lastScrollLine < firstScrollLine ) { throw new IllegalArgumentException ( "Scroll region cannot be negative!" ) ; } if ( lines < 1 ) { throw new IllegalArgumentException ( "Invalid number of lines!" ) ; } int region = ( lastScrollLine - firstScrollLine + 1 ) ; int n = Math . min ( lines , region ) ; int width = getWidth ( ) ; int srcPos = ( n + firstScrollLine ) * width ; int destPos = firstScrollLine * width ; int lastPos = ( lastScrollLine + 1 ) * width ; int length = lastPos - srcPos ; if ( length > 0 ) { System . arraycopy ( m_buffer , srcPos , m_buffer , destPos , length ) ; } Arrays . fill ( m_buffer , destPos + length , srcPos + length , new TextCell (   , getAttributes ( ) ) ) ; m_heatMap . set ( destPos , lastPos ) ; }
tr	5	public static void main ( String [ ] args ) { final int limit = 100000 ; final int iterations = 100 ; final String format = "%g seconds" ; List < long > numbers = Stream . iterate ( 1 , number -> number + 1 ) . limit ( limit ) . collect ( Collectors . < long > toList ( ) ) ; { System . out . println ( "//" + "START:HABITUAL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { long primesCount = 0 ; for ( long number : numbers ) { if ( isPrime ( number ) ) { primesCount += 1 ; } } } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:HABITUAL_OUTPUT" ) ; } { System . out . println ( "//" + "START:LAMBDA_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . stream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:LAMBDA_OUTPUT" ) ; } { System . out . println ( "//" + "START:PARALLEL_OUTPUT" ) ; double time = 0 ; for ( int i = 0 ; i < iterations ; i ++ ) { time += timeIt ( ( ) -> { final long primesCount = numbers . parallelStream ( ) . filter ( number -> isPrime ( number ) ) . count ( ) ; } ) ; } System . out . println ( String . format ( format , time / iterations ) ) ; System . out . println ( "//" + "END:PARALLEL_OUTPUT" ) ; } }
tr	1	public void paint ( Graphics g ) { super . paint ( g ) ; if ( enabled ) return ; g . setColor ( new Color ( 180 , 180 , 180 , 120 ) ) ; g . fillRect ( 0 , 0 , 174 , 34 ) ; }
tr	0	public byte getRegisteredDelivery ( ) { return byte . parseByte ( "0" + registeredDelivery . getText ( ) , 10 ) ; }
tr	6	public static ConsumptionModel getConsumptionModelForWashingMachine ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	5	public static int countABC ( String str ) { int zmCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( ( c >= a && c <= z ) || ( c >= A && c <= Z ) ) zmCount ++ ; } return zmCount ; }
tr	3	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; if ( level != 1 ) { jPanel1 . setEnabled ( false ) ; jButton2 . setEnabled ( false ) ; jButton3 . setEnabled ( false ) ; jButton4 . setEnabled ( false ) ; jButton6 . setEnabled ( false ) ; } double catNumeber = DbUtil . loadCategories ( ) . length ; int rows = ( int ) Math . ceil ( catNumeber / 5 ) ; jPanel2 . setLayout ( new GridLayout ( rows , 5 , 4 , 4 ) ) ; jPanel3 . setVisible ( false ) ; String array [ ] [ ] = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < catNumeber ; i ++ ) { final JButton btn = new JButton ( String . valueOf ( array [ i ] [ 1 ] ) ) ; JPanel buttonPane = new JPanel ( ) ; btn . setName ( String . valueOf ( array [ i ] [ 0 ] ) ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae2 ) { jPanel2 . setVisible ( false ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; try { loadItems ( btn . getName ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; buttonPane . add ( btn ) ; jPanel2 . add ( buttonPane ) ; } add ( jPanel2 ) ; pack ( ) ; setVisible ( true ) ; }
tr	8	private boolean syotteenTarkistus ( String siirto ) { return siirto . length ( ) == 4 && siirto . charAt ( 0 ) >= a && siirto . charAt ( 0 ) <= h && siirto . charAt ( 2 ) >= a && siirto . charAt ( 2 ) <= h && siirto . charAt ( 1 ) >= 1 && siirto . charAt ( 1 ) <= 8 && siirto . charAt ( 3 ) >= 1 && siirto . charAt ( 3 ) <= 8 ; }
tr	8	Vector < Integer > getNeighboringIndexes ( int index ) { Vector < Integer > result = new Vector < Integer > ( 6 ) ; int row = getRow ( index ) ; int col = getColumn ( index ) ; int offset = getOffset ( row ) ; if ( row < numRows - 1 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row + 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row + 1 , col + offset ) ) ; } } if ( col > 0 ) { result . add ( getIndex ( row , col - 1 ) ) ; } if ( col < numColumns - 1 ) { result . add ( getIndex ( row , col + 1 ) ) ; } if ( row > 0 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row - 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row - 1 , col + offset ) ) ; } } result . trimToSize ( ) ; return result ; }
tr	4	@ Override Pizza createPizza ( String type ) { Pizza pizza = null ; ChicagoPizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory ( ) ; if ( type . equals ( "cheese" ) ) { pizza = new ChicagoStyleCheesePizza ( ingredientFactory ) ; } else if ( type . equals ( "pepperoni" ) ) { pizza = new ChicagoStylePepperoniPizza ( ingredientFactory ) ; } else if ( type . equals ( "clam" ) ) { pizza = new ChicagoStyleClamPizza ( ingredientFactory ) ; } else if ( type . equals ( "veggie" ) ) { pizza = new ChicagoStyleVegglePizza ( ingredientFactory ) ; } return pizza ; }
tr	6	public static void display ( MapInfo mapInfo ) { StdDraw . setXscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setYscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setPenColor ( StdDraw . RED ) ; StdDraw . setPenColor ( StdDraw . BLACK ) ; for ( int row = 1 ; row < mapInfo . getMapSize ( ) - 1 ; row ++ ) { for ( int column = 1 ; column < mapInfo . getMapSize ( ) - 1 ; column ++ ) { if ( mapInfo . getCell ( row , column ) . isSouth ( ) ) StdDraw . line ( row + 1 , column , row + 1 , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isNorth ( ) ) StdDraw . line ( row , column , row , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isWest ( ) ) StdDraw . line ( row , column , row + 1 , column ) ; if ( mapInfo . getCell ( row , column ) . isEast ( ) ) StdDraw . line ( row , column + 1 , row + 1 , column + 1 ) ; } } StdDraw . show ( 1000 ) ; }
tr	9	public float getProjection ( Vector v ) throws GeometryException { if ( v . getDimensions ( ) < 3 && this . getDimensions ( ) > 3 || v . getDimensions ( ) > 3 && this . getDimensions ( ) < 3 || ( v . getDimensions ( ) < 3 && this . getDimensions ( ) < 3 && this . getDimensions ( ) != v . getDimensions ( ) ) ) throw new GeometryException ( "Vector projections require vectors of same dimensionality" ) ; float dp = 0.0f ; for ( int i = 0 ; i < ( ( this . getDimensions ( ) > 3 ) ? 3 : this . getDimensions ( ) ) ; i ++ ) dp += v . getCoordinate ( i ) * this . getCoordinate ( i ) ; return dp / this . getMeasure ( ) ; }
tr	5	public MyPopulation ( int populationSize , int dataSize , IMyFitnessTestFunction < U > fitnessTester , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( populationSize < 4 ) { throw new Exception ( "population size should be 4 or greater" ) ; } if ( dataSize < MyIndividual . MIN_DATA_SIZE ) { throw new Exception ( "data size should be 4 or greater" ) ; } if ( fitnessTester == null ) { throw new Exception ( "fitnessTester function Cannot be null" ) ; } population = new ArrayList < > ( ) ; try { for ( int i = 0 ; i < populationSize ; i ++ ) { population . add ( new MyIndividual ( dataSize , true , 0.99 , true , fitnessTester , rFunc ) ) ; } } catch ( Exception e ) { System . err . println ( "ex in individual's constructor:" + e . getMessage ( ) ) ; } }
tr	2	@ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof abort_result ) return this . equals ( ( abort_result ) that ) ; return false ; }
tr	1	private void beforeShade ( Light light , ColorRGB color ) { for ( TracerInterceptor interceptor : interceptors ) { interceptor . beforeShade ( light , color ) ; } }
tr	7	public static void main ( String args [ ] ) { Scanner obj1 = new Scanner ( System . in ) ; System . out . print ( "" ) ; int test = obj1 . nextInt ( ) ; while ( test -- > 0 ) { int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; ++ i ) { arr [ i ] = obj1 . nextInt ( ) ; } int t = arr [ 0 ] ; int m = 1 ; while ( arr [ 0 ] >= 0 ) { m *= 10 ; arr [ 0 ] -- ; } int min = arr [ 1 ] ; int index = 1 ; for ( int i = 2 ; i < 10 ; ++ i ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( t < min ) { System . out . println ( m ) ; } else { while ( min >= 0 ) { System . out . print ( index ) ; min -- ; } System . out . println ( ) ; } } }
tr	8	public Policy getPolicy ( CommandLine cmd ) { Policy policy = null ; if ( cmd . hasOption ( "checkIn" ) || cmd . hasOption ( "checkOut" ) || cmd . hasOption ( "alchohol" ) || cmd . hasOption ( "smoke" ) || cmd . hasOption ( "cancellation_deadline" ) || cmd . hasOption ( "cancellation_penalty" ) ) { policy = new Policy ( ) ; policy . setCheckInTime ( cmd . getOptionValue ( "checkIn" ) ) ; policy . setCheckOutTime ( cmd . getOptionValue ( "checkOut" ) ) ; policy . setAlcoholPolicy ( cmd . getOptionValue ( "alchohol" ) ) ; policy . setSmokingPolicy ( cmd . getOptionValue ( "smoke" ) ) ; if ( cmd . hasOption ( "cancellation_deadline" ) ) { policy . setCancellationDeadLine ( Integer . parseInt ( cmd . getOptionValue ( "cancellation_deadline" ) ) ) ; } if ( cmd . hasOption ( "cancellation_penalty" ) ) { policy . setCancellationPenalty ( Integer . parseInt ( cmd . getOptionValue ( "cancellation_penalty" ) ) ) ; } } return policy ; }
tr	3	@ Override protected void processMouseEvent ( MouseEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { if ( e . getX ( ) >= XLEN || e . getY ( ) >= YLEN ) return ; point p = new point ( ( double ) e . getX ( ) / XLEN , ( double ) e . getY ( ) / YLEN , current_value ) ; point_list . addElement ( p ) ; draw_point ( p ) ; } }
