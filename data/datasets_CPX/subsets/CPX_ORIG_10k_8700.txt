te	2	public boolean validParam ( DBMS toCheck ) { if ( dbTypes . contains ( DBMS . Other ) ) return true ; if ( dbTypes . contains ( toCheck ) ) return true ; return false ; }
te	2	private void fillExpendingChart ( ) { List < PieSlice > slices = new ArrayList < > ( ) ; double fixedExpendingTotal = ejc . getExpendigsTotal ( 1 ) ; double servicesExpendingTotal = ejc . getExpendigsTotal ( 2 ) ; double leisureExpendingTotal = ejc . getExpendigsTotal ( 3 ) ; slices . add ( new PieSlice ( FIXED_EXPENSE_COLOR , fixedExpendingTotal , "Total de gastos fijos" ) ) ; slices . add ( new PieSlice ( SERVICES_COLOR , servicesExpendingTotal , "Total de gastos por servicios" ) ) ; slices . add ( new PieSlice ( LEISURE_COLOR , leisureExpendingTotal , "Total de gastos por ocio y demas" ) ) ; PieChart pieChart = new PieChart ( slices ) ; resumeExPanel . add ( pieChart , BorderLayout . CENTER ) ; List < Object [ ] > objs = ejc . getExpendingTotalByDay ( ) ; double [ ] exps = new double [ objs . size ( ) + 1 ] ; for ( int i = 0 ; i < objs . size ( ) ; i ++ ) { Object [ ] obj = objs . get ( i ) ; if ( i == 0 ) { exps [ i ] = ( double ) obj [ 0 ] ; exps [ i + 1 ] = ( double ) obj [ 0 ] ; } else { exps [ i + 1 ] = exps [ i - 1 ] + ( double ) obj [ 0 ] ; } } flowPanel . add ( new LineChart ( exps ) , BorderLayout . CENTER ) ; }
te	3	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf ( TIME_TAG_START ) + TIME_TAG_START . length ( ) ; if ( startOfTag > TIME_TAG_START . length ( ) ) { final int endOfTag = line . indexOf ( TIME_TAG_END , startOfTag ) ; final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { Date timeTag = dataFormatter . parse ( strTimeTag ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVizualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }
te	0	public List < Trends > getTrendsDaily ( ) throws WeiboException { return Trends . constructTrendsList ( client . get ( WeiboConfig . getValue ( "baseURL" ) + "trends/daily.json" ) ) ; }
te	0	public package ( byte [ ] buf ) { this . Len = buf . length + 4 ; this . ReqestId = TypeConvert . byte2int ( buf , 0 ) ; this . Message = new byte [ buf . length - 4 ] ; System . arraycopy ( buf , 4 , this . Message , 0 , this . Message . length ) ; this . SequenceId = TypeConvert . byte2int ( buf , 4 ) ; this . timestamp = ( new java . util . Date ( ) ) . getTime ( ) ; }
te	2	public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] ) { s = s . concat ( "1" ) ; } else { s = s . concat ( "0" ) ; } } return s ; }
te	9	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; final int length = this . length ( ) ; Iterator keys = this . keys ( ) ; writer . write ( { ) ; if ( length == 1 ) { Object key = keys . next ( ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , newindent ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , newindent ) ; commanate = keys . hasNext ( ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , indent ) ; } writer . write ( } ) ; return writer ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } }
te	8	public static void mouseMoved ( MouseEvent mouseEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleMouse ) { if ( comp . shouldHandleMouse ( ) ) comp . mouseMoved ( mouseEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceMouse ( ) ) component . mouseMoved ( mouseEvent ) ; } else if ( comp . forceMouse ( ) ) comp . mouseMoved ( mouseEvent ) ; } } }
te	6	@ Test public void testWithShort ( ) throws InterruptedException { int mb = 1024 * 1024 ; Runtime runtime = Runtime . getRuntime ( ) ; System . out . println ( "Used Memory:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; int x = 30000 ; int y = 30000 ; SimilarityMatrix m ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . double ) ; System . out . println ( "Double:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } m = null ; System . gc ( ) ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . double , true ) ; System . out . println ( "Double:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } m = null ; System . gc ( ) ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . float ) ; System . out . println ( "Float:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } m = null ; System . gc ( ) ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . float , true ) ; System . out . println ( "Float symm:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } m = null ; System . gc ( ) ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . short ) ; System . out . println ( "Short:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } m = null ; System . gc ( ) ; try { m = new SimilarityMatrix ( x , y , NUMBER_PRECISION . short , true ) ; System . out . println ( "Short symm:" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / mb ) ; } catch ( Throwable t ) { System . out . println ( "failed" ) ; } }
te	6	public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
te	4	public static Color getTeamColor ( Teams team ) { if ( team == Teams . BLUE ) { return Color . BLUE ; } else if ( team == Teams . GREEN ) { return Color . GREEN ; } else if ( team == Teams . ORANGE ) { return Color . ORANGE ; } else if ( team == Teams . RED ) { return Color . RED ; } else { return null ; } }
te	7	private Method findMethod ( String name , String [ ] prevName ) { for ( Method method : this . getClass ( ) . getMethods ( ) ) { boolean nameEquals = false ; for ( String prev : prevName ) { if ( ( prev + name ) . equals ( method . getName ( ) ) ) { nameEquals = true ; break ; } } if ( ! nameEquals ) { continue ; } int modifier = method . getModifiers ( ) ; if ( Modifier . isAbstract ( modifier ) ) { continue ; } if ( ! Modifier . isPublic ( modifier ) ) { continue ; } if ( Modifier . isStatic ( modifier ) ) { continue ; } return method ; } throw new RuntimeException ( "method no find '" + name + "'" ) ; }
te	7	public boolean isPalindrome ( String s ) { s = s . toLowerCase ( ) ; int i = 0 , start = - 1 , end = - 1 ; boolean flag = true ; ArrayList < Character > sn = new ArrayList < Character > ( ) ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) >= a && s . charAt ( i ) <= z ) || ( s . charAt ( i ) >= 0 && s . charAt ( i ) <= 9 ) ) { sn . add ( s . charAt ( i ) ) ; } } for ( i = 0 ; i < sn . size ( ) / 2 && flag ; i ++ ) { flag = ( sn . get ( i ) == sn . get ( sn . size ( ) - 1 - i ) ) ; } return flag ; }
te	9	public void randommovement ( ) { if ( anim > 59 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 200 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
te	3	@ Override public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . compareTo ( OAuthPropertyBean . ACCESS_TOKEN ) == 0 ) { tf_accessToken . setText ( ( String ) evt . getNewValue ( ) ) ; } else if ( evt . getPropertyName ( ) . compareTo ( OAuthPropertyBean . REFRESH_TOKEN ) == 0 ) { String newValue = ( String ) evt . getNewValue ( ) ; if ( newValue . compareTo ( tf_refreshToken . getText ( ) ) != 0 ) tf_refreshToken . setText ( ( String ) evt . getNewValue ( ) ) ; } }
te	7	public void createAlphabets ( String file ) throws IOException { createDictionaries ( file ) ; if ( options . wordVectorFile != null ) loadWordVectors ( options . wordVectorFile ) ; long start = System . currentTimeMillis ( ) ; System . out . print ( "Creating Alphabet ... " ) ; HashSet < String > posTagSet = new HashSet < String > ( ) ; HashSet < String > cposTagSet = new HashSet < String > ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; DependencyInstance inst = reader . nextInstance ( ) ; int cnt = 0 ; Evaluator eval = new Evaluator ( options , this ) ; while ( inst != null ) { for ( int i = 0 ; i < inst . length ; ++ i ) { if ( inst . postags != null ) posTagSet . add ( inst . postags [ i ] ) ; if ( inst . cpostags != null ) cposTagSet . add ( inst . cpostags [ i ] ) ; } inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; eval . add ( inst , inst , false ) ; synFactory . initFeatureAlphabets ( inst ) ; smnFactory . initFeatureAlphabets ( inst ) ; inst = reader . nextInstance ( ) ; cnt ++ ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; } System . out . printf ( "[%d ms]%n" , System . currentTimeMillis ( ) - start ) ; closeAlphabets ( ) ; reader . close ( ) ; System . out . printf ( "Path items: %d (%d bits)%n" , smnFactory . pathcodeAlphabet . size ( ) , Utils . log2 ( smnFactory . pathcodeAlphabet . size ( ) + 1 ) ) ; System . out . printf ( "Num of CONLL fine POS tags: %d%n" , posTagSet . size ( ) ) ; System . out . printf ( "Num of CONLL coarse POS tags: %d%n" , cposTagSet . size ( ) ) ; System . out . printf ( "Num of labels: %d%n" , types . length ) ; System . out . printf ( "Num of Syntactic Features: %d %d%n" , synFactory . numWordFeats , synFactory . numArcFeats ) ; System . out . printf ( "Num of Semantic Features: %d %d %d %d%n" , smnFactory . numLinkFeats , smnFactory . numWordFeats , smnFactory . numPathFeats , smnFactory . numContextFeats ) ; eval . dumpArgStats ( ) ; }
te	9	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jPopupMenu1 = new javax . swing . JPopupMenu ( ) ; jMenuItem6 = new javax . swing . JMenuItem ( ) ; jMenuItem7 = new javax . swing . JMenuItem ( ) ; sendButton = new javax . swing . JButton ( ) ; jScrollPane3 = new javax . swing . JScrollPane ( ) ; userList = new javax . swing . JList ( ) ; userListLabel = new javax . swing . JLabel ( ) ; inputTextField = new javax . swing . JTextField ( ) ; typeHereLabel = new javax . swing . JLabel ( ) ; jMenuBar1 = new javax . swing . JMenuBar ( ) ; chatRoomMenu = new javax . swing . JMenu ( ) ; newChatRoomItem = new javax . swing . JMenuItem ( ) ; jMenuItem8 = new javax . swing . JMenuItem ( ) ; tabbedPane = new JTabbedPane ( JTabbedPane . TOP ) ; jMenuItem6 . setText ( "Add Friend" ) ; jMenuItem6 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem6ActionPerformed ( evt ) ; } } ) ; jPopupMenu1 . add ( jMenuItem6 ) ; jMenuItem7 . setText ( "Private Message" ) ; jMenuItem7 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem7ActionPerformed ( evt ) ; } } ) ; jPopupMenu1 . add ( jMenuItem7 ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; sendButton . setText ( "Send" ) ; sendButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { sendButtonActionPerformed ( evt ) ; } } ) ; try { client . sendUserListMessage ( ) ; } catch ( JMSException exception ) { throw new RuntimeException ( exception ) ; } ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof UserListMessage ) ) return ; final UserListMessage ulm = ( UserListMessage ) m ; userList . setModel ( new javax . swing . AbstractListModel ( ) { List < String > strings = ulm . getOnlineUsers ( ) ; public int getSize ( ) { return strings . size ( ) ; } public Object getElementAt ( int i ) { return strings . get ( i ) ; } } ) ; } } ) ; userList . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mousePressed ( java . awt . event . MouseEvent evt ) { userListMousePressed ( evt ) ; } } ) ; jScrollPane3 . setViewportView ( userList ) ; userListLabel . setText ( "Online Users" ) ; inputTextField . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyPressed ( java . awt . event . KeyEvent evt ) { inputTextFieldKeyPressed ( evt ) ; } } ) ; typeHereLabel . setText ( "Type Here: " ) ; chatRoomMenu . setText ( "Options" ) ; newChatRoomItem . setText ( "New Chatroom" ) ; newChatRoomItem . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem1ActionPerformed ( evt ) ; } } ) ; jMenuItem8 . setText ( "Log out" ) ; jMenuItem8 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItem8ActionPerformed ( evt ) ; } } ) ; chatRoomMenu . add ( newChatRoomItem ) ; chatRoomMenu . add ( jMenuItem8 ) ; jMenuBar1 . add ( chatRoomMenu ) ; setJMenuBar ( jMenuBar1 ) ; JScrollPane scrollPane = new JScrollPane ( ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( inputTextField , GroupLayout . PREFERRED_SIZE , 338 , GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( ComponentPlacement . UNRELATED ) . addComponent ( sendButton , GroupLayout . PREFERRED_SIZE , 94 , GroupLayout . PREFERRED_SIZE ) ) . addComponent ( typeHereLabel ) . addComponent ( tabbedPane , GroupLayout . PREFERRED_SIZE , 445 , GroupLayout . PREFERRED_SIZE ) ) . addGap ( 17 ) . addGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addComponent ( userListLabel ) . addComponent ( jScrollPane3 , GroupLayout . DEFAULT_SIZE , 120 , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addComponent ( tabbedPane , GroupLayout . PREFERRED_SIZE , 332 , GroupLayout . PREFERRED_SIZE ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( userListLabel ) . addGroup ( layout . createParallelGroup ( Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 324 ) . addComponent ( typeHereLabel ) . addGap ( 6 ) . addGroup ( layout . createParallelGroup ( Alignment . BASELINE ) . addComponent ( sendButton , GroupLayout . PREFERRED_SIZE , 32 , GroupLayout . PREFERRED_SIZE ) . addComponent ( inputTextField , GroupLayout . PREFERRED_SIZE , 32 , GroupLayout . PREFERRED_SIZE ) ) ) . addGroup ( layout . createSequentialGroup ( ) . addPreferredGap ( ComponentPlacement . RELATED ) . addComponent ( jScrollPane3 , GroupLayout . DEFAULT_SIZE , 372 , short . MAX_VALUE ) ) ) ) ) . addContainerGap ( ) ) ) ; tabbedPane . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( "Main Lobby" . equals ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ) { try { client . sendUserListMessage ( ) ; client . setChatRoom ( null ) ; } catch ( JMSException e1 ) { throw new RuntimeException ( e1 ) ; } } else { try { client . sendChatRoomUserListMessage ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ; client . setChatRoom ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ; } catch ( JMSException e1 ) { throw new RuntimeException ( e1 ) ; } } } } ) ; final JTextArea textArea = new JTextArea ( ) ; scrollPane . setViewportView ( textArea ) ; textArea . setEditable ( false ) ; tabbedPane . addTab ( "Main Lobby" , null , scrollPane , null ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatTextMessage ) ) return ; final ChatTextMessage ulm = ( ChatTextMessage ) m ; textArea . append ( "[" + ulm . getUsername ( ) + "]: " + ulm . getText ( ) + "\n" ) ; } } ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof UpdateUserListMessage ) ) return ; if ( "Main Lobby" . equals ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ) { try { client . sendUserListMessage ( ) ; } catch ( JMSException e1 ) { throw new RuntimeException ( e1 ) ; } } else { try { client . sendChatRoomUserListMessage ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ; } catch ( JMSException e1 ) { throw new RuntimeException ( e1 ) ; } } ChatClientApplicationGUI . removeServerMessageListener ( this ) ; } } ) ; getContentPane ( ) . setLayout ( layout ) ; pack ( ) ; }
te	1	@ Override public void recvLogOut ( String userName ) { List < String > userServices = user . getUserServiceList ( ) ; HashMap < String , String > usersForService ; for ( String service : userServices ) { usersForService = user . getMatchingUsers ( ) . get ( service ) ; usersForService . remove ( userName ) ; } }
te	8	private boolean canMoveToPosition ( Player player , Grid grid , Position pos ) { if ( pos . getxCoordinate ( ) < 0 || pos . getyCoordinate ( ) < 0 || pos . getxCoordinate ( ) >= grid . getHorLength ( ) || pos . getyCoordinate ( ) >= grid . getVerLength ( ) ) return false ; List < Element > elements = grid . getElementsOnPosition ( pos ) ; for ( Element element : elements ) { if ( ! element . isHoverable ( ) ) return false ; if ( element instanceof Player ) { if ( ( ( Player ) element ) . getLightTrail ( ) . getPositions ( ) . contains ( pos ) ) return false ; } } return true ; }
te	3	private boolean promptForDuplicateState ( String i ) { String spriteTypeName = null ; String selectedState = null ; PoseurGUI gui = Poseur . getPoseur ( ) . getGUI ( ) ; AnimatedSpriteViewer view = gui . getAnimametedViewerPanel ( ) ; try { spriteTypeName = view . getJlist ( ) . getSelectedValue ( ) . toString ( ) ; selectedState = view . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; if ( view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "NULL" ) || view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { throw new NullPointerException ( ) ; } } catch ( NullPointerException e ) { JOptionPane . showMessageDialog ( view , "You did not select either state or sprite type" ) ; return false ; } currentSpriteName = spriteTypeName ; currentFileName = spriteTypeName + SPRITE_FILE_EXTENSION ; currentFile = new File ( SPRITES_PATH + currentFileName ) ; String path = "./data/sprite_types/" + spriteTypeName ; File currentFile3 = new File ( path + "/" + currentFileName ) ; spriteIO . duplicateState ( path + "/" + currentFileName , i ) ; saved = true ; String appName = gui . getAppName ( ) ; gui . setTitle ( appName + APP_NAME_FILE_NAME_SEPARATOR + currentFile ) ; Poseur singleton = Poseur . getPoseur ( ) ; return false ; }
te	9	private static void vertical ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int col = 0 ; col < 7 ; col ++ ) { for ( int row = 5 ; row > 2 ; row -- ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col , row - 1 ) . getState ( ) && player1Color == b . getGameGridCircle ( col , row - 2 ) . getState ( ) && ( b . getGameGridCircle ( col , row - 3 ) . getState ( ) == 0 ) ) { xIndex = col ; yIndex = row - 3 ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col , row - 1 ) . getState ( ) && player2Color == b . getGameGridCircle ( col , row - 2 ) . getState ( ) && ( b . getGameGridCircle ( col , row - 3 ) . getState ( ) == 0 ) ) { xIndex = col ; yIndex = row - 3 ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col , row - 1 ) . getState ( ) && ( b . getGameGridCircle ( col , row - 2 ) . getState ( ) == 0 ) ) { xIndex = col ; yIndex = row - 2 ; IntPair location = new IntPair ( xIndex , yIndex ) ; movesToMake . add ( new Tuple ( location , 1 ) ) ; } } } }
te	8	public static Output < Map < String , Object >> createOutput ( OutputStream out , OutputFormat format , String [ ] columnOrder ) throws IOException { JsonGenerator jsonGenerator ; switch ( format ) { case PRETTY : jsonGenerator = FACTORY . createJsonGenerator ( out , JsonEncoding . UTF8 ) ; jsonGenerator . useDefaultPrettyPrinter ( ) ; return new JsonOutput ( jsonGenerator , JsonOutput . MAPPER ) ; case LINE : jsonGenerator = FACTORY . createJsonGenerator ( out , JsonEncoding . UTF8 ) ; jsonGenerator . setPrettyPrinter ( new LinePrettyPrinter ( ) ) ; return new JsonOutput ( jsonGenerator , JsonOutput . MAPPER ) ; case CSV : if ( columnOrder != null ) { return new DelimitedOutput ( out , " " ) . setColumnOrdering ( Arrays . asList ( columnOrder ) ) ; } return new DelimitedOutput ( out , " " ) ; case TAB : if ( columnOrder != null ) { return new DelimitedOutput ( out , "\t" ) . setColumnOrdering ( Arrays . asList ( columnOrder ) ) ; } return new DelimitedOutput ( out , "\t" ) ; case WIKI : if ( columnOrder != null ) { return new DelimitedOutput ( out , "|" , "|" , "|" ) . setColumnOrdering ( Arrays . asList ( columnOrder ) ) ; } return new DelimitedOutput ( out , "|" , "|" , "|" ) ; } throw new IllegalArgumentException ( String . format ( "unknown output format %s" , format ) ) ; }
te	7	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == saveFile ) { int choice = fileChooser . showSaveDialog ( PrintWindow . this ) ; if ( choice == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; String filename = file . getPath ( ) + ".txt" ; BufferedWriter bfWrite = null ; try { bfWrite = new BufferedWriter ( new FileWriter ( filename ) ) ; bfWrite . write ( textArea . getText ( ) ) ; } catch ( IOException x ) { } finally { try { if ( bfWrite != null ) { bfWrite . close ( ) ; } } catch ( IOException x ) { } } } } if ( e . getSource ( ) == printFile ) { try { textArea . print ( ) ; } catch ( PrinterException x ) { } } }
te	2	public boolean isModifierContainsStructure ( DataHolder dataholderHandler , String modifier ) { boolean res = false ; String [ ] words = modifier . split ( "\\s+" ) ; for ( String word : words ) { Set < String > POSTags = new HashSet < String > ( ) ; POSTags . add ( "p" ) ; POSTags . add ( "s" ) ; Set < String > PSWords = dataholderHandler . getWordsFromWordPOSByPOSs ( POSTags ) ; if ( PSWords . contains ( word ) ) { res = true ; break ; } } return res ; }
te	8	public static void main ( String [ ] args ) { int port = 4444 ; Queue < String > arguments = new LinkedList < String > ( Arrays . asList ( args ) ) ; try { while ( ! arguments . isEmpty ( ) ) { String flag = arguments . remove ( ) ; try { if ( flag . equals ( "--port" ) ) { port = Integer . parseInt ( arguments . remove ( ) ) ; if ( port < 0 || port > 65535 ) { throw new IllegalArgumentException ( "port " + port + " out of range" ) ; } } else { throw new IllegalArgumentException ( "unknown option: \"" + flag + "\"" ) ; } } catch ( NoSuchElementException nsee ) { throw new IllegalArgumentException ( "missing argument for " + flag ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( "unable to parse number for " + flag ) ; } } } catch ( IllegalArgumentException iae ) { System . err . println ( iae . getMessage ( ) ) ; System . err . println ( "usage: Server [--port PORT]" ) ; return ; } try { Server server = new Server ( 4444 ) ; server . serve ( ) ; } catch ( IOException e ) { System . out . println ( "Error in starting server." ) ; e . printStackTrace ( ) ; } }
te	0	public synchronized void addNotification ( Notification notification ) { this . aNotification . add ( notification ) ; this . notifyAll ( ) ; }
te	0	@ Override public void toucher ( int value ) { toucherDmg = true ; setVie ( getVie ( ) - value ) ; }
te	8	public double getDouble ( String key ) throws JSONException { Object o = get ( key ) ; if ( o instanceof byte ) { return ( double ) ( ( byte ) o ) . byteValue ( ) ; } else if ( o instanceof short ) { return ( double ) ( ( short ) o ) . shortValue ( ) ; } else if ( o instanceof Integer ) { return ( double ) ( ( Integer ) o ) . intValue ( ) ; } else if ( o instanceof long ) { return ( double ) ( ( long ) o ) . longValue ( ) ; } else if ( o instanceof float ) { return ( double ) ( ( float ) o ) . floatValue ( ) ; } else if ( o instanceof double ) { return ( ( double ) o ) . doubleValue ( ) ; } else if ( o instanceof String ) { try { return double . valueOf ( ( String ) o ) . doubleValue ( ) ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a number." ) ; } } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a number." ) ; }
te	8	public static void main ( String [ ] args ) { int note , oct ; int [ ] t = { 50 , 10 , 25 } ; Instrument instr = new WaveInstrument ( t ) ; InstrumentBox box = new SingleInstrumentBox ( 2 ) ; box . attachInstrument ( instr ) ; Track track = new SimpleTrack ( 2 ) ; for ( int i = 0 ; i < 100 ; i ++ ) { String noteStr ; note = ( int ) ( Math . random ( ) * 7 ) ; oct = ( int ) ( Math . random ( ) * 4 ) + 3 ; switch ( note ) { case 0 : noteStr = "C" ; break ; case 1 : noteStr = "D" ; break ; case 2 : noteStr = "E" ; break ; case 3 : noteStr = "F" ; break ; case 4 : noteStr = "G" ; break ; case 5 : noteStr = "A" ; break ; case 6 : noteStr = "B" ; break ; default : noteStr = "C" ; } Note no = new StdNote ( StdNoteCore . valueOf ( noteStr + oct ) ) ; no . setVolume ( ( int ) ( Math . random ( ) * short . MAX_VALUE ) / 2 + 100 ) ; box . removeAllSoundEffects ( ) ; box . attachSoundEffect ( new LinearFadeOutEffect ( 2 , 440 , ( int ) ( Math . random ( ) * 44100 ) + 4410 ) ) ; box . play ( no ) ; track . insertSound ( box , no , i * 12525 , 88200 ) ; } Converter c = new SimpleSoundSourceConverter ( track ) ; Player pl = new SimplePlayer ( ) ; pl . setSource ( c ) ; pl . play ( ) ; }
te	5	public void testFetchAllGroups ( ) { Group [ ] groups ; try { groups = ga . fetchAllGroups ( ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; assertTrue ( groups [ i ] . getUsers ( ) . length > 0 ) ; if ( i == 0 ) { for ( int j = 0 ; j < groups [ i ] . getUsers ( ) . length ; j ++ ) { assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getId ( ) == ( j + 1 ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getFirstName ( ) . equals ( testusers [ j ] . getFirstName ( ) ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getLastName ( ) . equals ( testusers [ j ] . getLastName ( ) ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getUserName ( ) . equals ( testusers [ j ] . getUserName ( ) ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getEmail ( ) . equals ( testusers [ j ] . getEmail ( ) ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getPw ( ) . equals ( "" ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getIsActive ( ) == testusers [ j ] . getIsActive ( ) ) ; assertTrue ( groups [ i ] . getUsers ( ) [ j ] . getIsAdmin ( ) == testusers [ j ] . getIsAdmin ( ) ) ; } } } groups = ga . fetchAllGroups ( false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; assertTrue ( groups [ i ] . getUsers ( ) . length == 0 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	9	public String analyzeXML ( ) { File fout = new File ( "" ) ; String xml = "" ; try { switch ( type ) { case "layout" : fout = File . createTempFile ( "output" , ".xml" ) ; break ; case "paging" : fout = File . createTempFile ( "output" , ".xml" ) ; break ; case "ocr" : fout = File . createTempFile ( "output" , ".txt" ) ; break ; } } catch ( IOException e ) { ErrorMessage . show ( "Exceptie la crearea fisierului temporar de output:" + e . getMessage ( ) ) ; } fout . deleteOnExit ( ) ; this . output = fout . getAbsolutePath ( ) ; switch ( type ) { case "layout" : xml = this . createAnalyzerInputXML ( ) ; break ; case "paging" : xml = this . createAnalyzerInputXML ( ) ; break ; case "ocr" : xml = this . createOCRInputXML ( ) ; break ; } File fin = new File ( "" ) ; try { fin = File . createTempFile ( "input" , ".xml" ) ; } catch ( IOException e ) { ErrorMessage . show ( "Exceptie la crearea fisierului temporar de input:" + e . getMessage ( ) ) ; } fin . deleteOnExit ( ) ; try { FileWriter fstream = new FileWriter ( fin . getAbsolutePath ( ) ) ; BufferedWriter in = new BufferedWriter ( fstream ) ; in . write ( xml ) ; in . close ( ) ; } catch ( Exception e ) { ErrorMessage . show ( "Exceptie la scrierea in fisierul temporar de input:" + e . getMessage ( ) ) ; } try { ProcessBuilder pb = new ProcessBuilder ( Config . execs + "\\" + this . name , fin . getAbsolutePath ( ) ) ; pb . directory ( new File ( Config . execs ) ) ; Process p = pb . start ( ) ; p . waitFor ( ) ; p . destroy ( ) ; } catch ( Exception e ) { ErrorMessage . show ( "Exceptie la rularea analizatorului:" + e . getMessage ( ) ) ; } return this . output ; }
te	0	public Set < Individual > getIndividuals ( ) { return new EntityFilter < Individual > ( onto . listIndividuals ( ) . toSet ( ) , this ) ; }
te	5	public static ArrayList < Properties > loadPropertyFiles ( final String folderName ) { final File folder = new File ( folderName ) ; if ( ! folder . exists ( ) ) { throw new RuntimeException ( "The folder named <" + folderName + "> does not exist." ) ; } if ( ! folder . isDirectory ( ) ) { throw new RuntimeException ( "The folder named <" + folderName + "> is not a folder." ) ; } String [ ] files = folder . list ( new FilenameFilter ( ) { @ Override public boolean accept ( final File dir , final String name ) { if ( name . endsWith ( ".properties" ) ) { return true ; } return false ; } } ) ; if ( files . length == 0 ) { throw new RuntimeException ( "There are no properties files in the folder named <" + folderName + ">." ) ; } final ArrayList < Properties > props = new ArrayList < Properties > ( ) ; for ( final String filename : files ) { props . add ( FileUtilities . loadPropertiesFile ( folderName + File . separator + filename ) ) ; } return props ; }
te	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; HgSettings that = ( HgSettings ) o ; return failFast == that . failFast && hgPath . equals ( that . hgPath ) && defaultFileCharset . equals ( that . defaultFileCharset ) ; }
te	7	private void load ( File fileName ) throws IOException { FileRead fp = new FileRead ( fileName ) ; if ( fp != null ) { LevelLayer curElem = null ; while ( fp . hasNext ( ) ) { switch ( fp . getNext ( ) ) { case "COLLISION" : collision = new Collision ( fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "LAYER" : curElem = new LevelLayer ( this ) ; layers . push ( curElem ) ; curElem . load ( Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "IMG" : curElem . load ( Data . getDataDirectory ( ) + "/data/gfx/tileset/" + fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) ) ; curElem . load ( fp ) ; break ; case "OBJECTS" : loadObjects ( fp ) ; break ; default : break ; } } if ( layers . size ( ) == 0 ) { throw new IOException ( "No level layers found in:\n" + fileName + "\nPerhaps it is not a valid level file?" ) ; } } fp . close ( ) ; }
te	5	public void run ( String from , String to , DepHandler handler ) throws IOException { try { ClassHeaderReader header = new ClassHeaderReader ( ) ; Map < String , String > classes = new HashMap < String , String > ( ) ; ClassPathIterator cp = new ClassPathIterator ( curDir , to , null ) ; try { while ( cp . hasNext ( ) ) { ClassPathEntry entry = cp . next ( ) ; InputStream in = entry . openStream ( ) ; try { header . read ( in ) ; classes . put ( header . getClassName ( ) , entry . getSource ( ) ) ; } catch ( Exception e ) { System . err . println ( "Error reading " + entry . getName ( ) + ": " + e . getMessage ( ) ) ; } finally { in . close ( ) ; } } } finally { cp . close ( ) ; } handler . handleStart ( ) ; cp = new ClassPathIterator ( curDir , from , null ) ; try { while ( cp . hasNext ( ) ) { ClassPathEntry entry = cp . next ( ) ; InputStream in = entry . openStream ( ) ; try { new ClassReader ( in ) . accept ( new DepFindVisitor ( classes , entry . getSource ( ) , handler ) , ClassReader . SKIP_DEBUG | ClassReader . EXPAND_FRAMES ) ; } catch ( Exception e ) { System . err . println ( "Error reading " + entry . getName ( ) + ": " + e . getMessage ( ) ) ; } finally { in . close ( ) ; } } } finally { cp . close ( ) ; } handler . handleEnd ( ) ; } catch ( RuntimeIOException e ) { throw ( IOException ) e . getCause ( ) ; } }
te	8	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
te	1	public ChatHistoryArch ( ) { _imp = getImplementation ( ) ; if ( _imp != null ) { _imp . setArch ( this ) ; } else { System . exit ( 1 ) ; } }
te	3	@ Test public void testData ( ) { assert . assertTrue ( sender . isAlive ( ) ) ; Packet packet = new Packet ( ID , PacketType . DAT , "10" ) ; sender . addToBuffer ( packet ) ; try { Thread . sleep ( SLEEPVAL / 2 ) ; } catch ( InterruptedException e ) { assert . fail ( ) ; e . printStackTrace ( ) ; } try { sender . passAck ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { Thread . sleep ( SLEEPVAL / 4 ) ; } catch ( InterruptedException e ) { assert . fail ( ) ; e . printStackTrace ( ) ; } assert . assertEquals ( State . WAITING , sender . getState ( ) ) ; assert . assertEquals ( 1 , sender . getSuccessfulSends ( ) ) ; }
te	0	public Email ( int id , String endereco ) { this . id = id ; this . endereco = endereco ; }
te	5	private static Map < String , String > hideCommonHeaders ( Map < String , String > origHeaders ) { Map < String , String > selectedHeaders = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > entry : origHeaders . entrySet ( ) ) { String headerName = entry . getKey ( ) . toLowerCase ( ) ; if ( "accept" . equals ( headerName ) && entry . getValue ( ) . contains ( "*" ) ) { continue ; } if ( ! COMMON_HEADERS . contains ( headerName ) ) { selectedHeaders . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return selectedHeaders . size ( ) == 0 ? null : selectedHeaders ; }
te	9	private boolean r_step_0 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_1 , 16 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : slice_from ( "a" ) ; break ; case 3 : slice_from ( "e" ) ; break ; case 4 : slice_from ( "i" ) ; break ; case 5 : { v_1 = limit - cursor ; lab0 : do { if ( ! ( eq_s_b ( 2 , "ab" ) ) ) { break lab0 ; } return false ; } while ( false ) ; cursor = limit - v_1 ; } slice_from ( "i" ) ; break ; case 6 : slice_from ( "at" ) ; break ; case 7 : slice_from ( "a\u0163i" ) ; break ; } return true ; }
te	0	public void resetVariableList ( ) { repaintVariableList ( new ArrayList < Variable > ( ) ) ; }
te	5	public < T > int selectIndex ( T [ ] items , Comparator < T > comp , int kthLowest , int size ) { if ( size < 1 ) { throw new GdxRuntimeException ( "cannot select from empty array (size < 1)" ) ; } else if ( kthLowest > size ) { throw new GdxRuntimeException ( "Kth rank is larger than size. k: " + kthLowest + "  size: " + size ) ; } int idx ; if ( kthLowest == 1 ) { idx = fastMin ( items , comp , size ) ; } else if ( kthLowest == size ) { idx = fastMax ( items , comp , size ) ; } else { if ( quickSelect == null ) { quickSelect = new QuickSelect ( ) ; } idx = quickSelect . select ( items , comp , kthLowest , size ) ; } return idx ; }
te	3	@ SuppressWarnings ( "unchecked" ) public static < K , V , C extends Collection < V > , CIMPL extends C > Map < K , C > mapToValueCollection ( Iterable < V > values , String property , class < CIMPL > collectionType ) { Map < K , C > byKey = new HashMap < K , C > ( ) ; PropertyPathExpression query = new PropertyPathExpression ( property ) ; for ( V value : values ) { K key = ( K ) query . invoke ( value ) ; C valuesForKey = byKey . get ( key ) ; if ( valuesForKey == null ) { try { valuesForKey = collectionType . newInstance ( ) ; } catch ( Exception ex ) { throw new IllegalStateException ( "error instantiating collection type: " + collectionType , ex ) ; } byKey . put ( key , valuesForKey ) ; } valuesForKey . add ( value ) ; } return byKey ; }
te	1	public Community ( byte [ ] buffer ) { community = new byte [ buffer . length ] ; for ( int i = 0 ; i < buffer . length ; i ++ ) community [ i ] = buffer [ i ] ; }
te	2	private static String popUri ( String input ) { String result = null ; if ( input . charAt ( 0 ) == < ) { int pos = input . indexOf ( ">" ) ; if ( pos > 0 ) { result = input . substring ( 0 , pos + 1 ) ; } else { result = null ; } } return result ; }
te	6	private String compare ( String leftHandSide , String rightHandSide ) { if ( leftHandSide . equals ( INTEGER ) ) { if ( rightHandSide . equals ( INTEGER ) ) { return INTEGER ; } else if ( rightHandSide . equals ( REAL ) ) { return REAL ; } else { SemanticWarningList . addWarning ( SemanticWarning . makeNewWarning ( "Unknown type for variable '" + rightHandSide + "'. Undeclared variable." ) ) ; } } else if ( leftHandSide . equals ( REAL ) ) { if ( rightHandSide . equals ( INTEGER ) || rightHandSide . equals ( REAL ) ) { return REAL ; } else { SemanticWarningList . addWarning ( SemanticWarning . makeNewWarning ( "Unknown type for variable '" + rightHandSide + "'. Undeclared variable." ) ) ; } } else { SemanticWarningList . addWarning ( SemanticWarning . makeNewWarning ( "Unknown type for variable '" + leftHandSide + "'. Undeclared variable." ) ) ; } return EMPTY ; }
te	3	public static int timeToMinutes ( String in ) { int mins ; if ( in . length ( ) == 8 && in . charAt ( 2 ) == : && in . charAt ( 5 ) == : ) { mins = ( in . charAt ( 0 ) & F ) * 600 + ( in . charAt ( 1 ) & F ) * 60 + ( in . charAt ( 3 ) & F ) * 10 + ( in . charAt ( 4 ) & F ) ; } else { mins = 0 ; } return mins ; }
te	9	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
te	4	private void loadDatabase ( ) { ClassLoader currentClassLoader = null ; Field cacheField = null ; boolean cacheValue = true ; try { currentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; cacheField = URLConnection . class . getDeclaredField ( "defaultUseCaches" ) ; cacheField . setAccessible ( true ) ; cacheValue = cacheField . getBoolean ( null ) ; cacheField . setBoolean ( null , false ) ; ebeanServer = EbeanServerFactory . create ( serverConfig ) ; } catch ( Exception ex ) { throw new RuntimeException ( "Failed to create a new instance of the EbeanServer" , ex ) ; } finally { if ( currentClassLoader != null ) { Thread . currentThread ( ) . setContextClassLoader ( currentClassLoader ) ; } try { if ( cacheField != null ) { cacheField . setBoolean ( null , cacheValue ) ; } } catch ( Exception e ) { System . out . println ( "Failed to revert the \"defaultUseCaches\"-field back to its original value  URLConnection-caching remains disabled." ) ; } } }
te	3	public void remove ( SortedArray elem ) { int lowidx = size ; int oldsize = size ; for ( int i = elem . size - 1 ; i >= 0 ; i -- ) { int idx = get ( elem . keys [ i ] ) ; if ( idx >= 0 ) { values [ idx ] = null ; lowidx = idx ; size = idx ; } else { size = - 1 - idx ; } } size = oldsize ; if ( lowidx < size ) removeNullValues ( lowidx ) ; }
te	0	@ Before public void setup ( ) { this . recommendationsDao = new RecommendationsDAO ( ) ; User user = new User ( "" , "" ) ; user . setId ( 1 ) ; first = new UserInfo ( user ) ; user . setId ( 2 ) ; second = new UserInfo ( user ) ; user . setId ( 3 ) ; third = new UserInfo ( user ) ; }
te	1	public String requestEquationType ( ) { Object choice = JOptionPane . showInputDialog ( null , Text . GraphType . DIALOG_PROMPT , Text . GraphType . DIALOG_TITLE , JOptionPane . PLAIN_MESSAGE , null , AVAILABLE_GRAPH_TYPES , AVAILABLE_GRAPH_TYPES [ 0 ] ) ; if ( choice == null ) { return null ; } else { return ( String ) choice ; } }
te	4	public static void fullConnect ( ILayer fromLayer , ILayer toLayer ) { for ( INeuron presynaptical : fromLayer . getNeurons ( ) ) if ( presynaptical instanceof IOutputtedNeuron ) for ( INeuron postsynaptical : toLayer . getNeurons ( ) ) if ( postsynaptical instanceof IInputtedNeuron ) createSynapse ( ( IOutputtedNeuron ) presynaptical , ( IInputtedNeuron ) postsynaptical ) ; }
te	3	public void go ( ) { while ( this . priorityQ . hasMore ( ) ) { GraphNode n = this . priorityQ . remove ( ) ; for ( Edge e : n . getOutGoingEdges ( ) ) { GraphNode adjNode = e . getNode ( ) ; Integer newPossiblePathCost = e . getCost ( ) + n . getDistance ( ) ; if ( newPossiblePathCost < adjNode . getDistance ( ) ) { adjNode . setDistance ( newPossiblePathCost ) ; this . priorityQ . updateGraphNodeDistance ( adjNode ) ; } } } }
te	0	public EventUndoListener ( Console console , Entry entry ) { this . console = console ; this . entry = entry ; }
te	3	public H2D projectionYZ ( ) { String name = "Y-Z Projection" ; int yNum = yAxis . getNBins ( ) + 1 ; double yMin = yAxis . min ( ) ; double yMax = yAxis . max ( ) ; int zNum = zAxis . getNBins ( ) + 1 ; double zMin = zAxis . min ( ) ; double zMax = zAxis . max ( ) ; H2D projYZ = new H2D ( name , yNum , yMin , yMax , zNum , zMin , zMax ) ; double height = 0.0 ; for ( int y = 0 ; y <= yAxis . getNBins ( ) ; y ++ ) { height = 0.0 ; for ( int z = 0 ; z <= zAxis . getNBins ( ) ; z ++ ) { height = 0.0 ; for ( int x = 0 ; x <= xAxis . getNBins ( ) ; x ++ ) { height += this . getBinContent ( x , y , z ) ; } projYZ . setBinContent ( y , z , height ) ; } } return projYZ ; }
te	4	private String getConfig ( ) { FileInputStream fis = null ; ObjectInputStream in = null ; String line = "" ; File file = new File ( getDIR ( ) ) ; if ( file . exists ( ) ) { try { fis = new FileInputStream ( file ) ; in = new ObjectInputStream ( fis ) ; line = encrypt ( ( String ) in . readObject ( ) ) ; fis . close ( ) ; in . close ( ) ; System . out . println ( "\nDone!!" ) ; } catch ( FileNotFoundException ex ) { JOptionPane . showMessageDialog ( null , "error in getConfig in Methods class  FileNotFoundException: " + ex ) ; } catch ( IOException ex ) { JOptionPane . showMessageDialog ( null , "error in getConfig in Methods class  IOException: " + ex ) ; } catch ( ClassNotFoundException ex ) { JOptionPane . showMessageDialog ( null , "error in getConfig in Methods class  ClassNotFoundException: " + ex ) ; } } else { System . out . println ( "\nThe file does not exist!" ) ; } return decrypt ( line ) ; }
te	7	private static void test2_1 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine cell key\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 4 , ">> You can't find a cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_1 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_1 passed" ) ; } } else { System . out . println ( "test2_1 failed: error" ) ; } } }
te	7	public void refreshMaskImage ( int width , int height , int cornerX , int cornerY , boolean useMask ) { maskImage = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = maskImage . createGraphics ( ) ; if ( useMask ) { g . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_SPEED ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_SPEED ) ; g . setRenderingHint ( RenderingHints . KEY_COLOR_RENDERING , RenderingHints . VALUE_COLOR_RENDER_SPEED ) ; g . setRenderingHint ( RenderingHints . KEY_DITHERING , RenderingHints . VALUE_DITHER_DISABLE ) ; for ( int i = 0 ; i < lights . size ( ) ; i ++ ) { Lighting l = lights . get ( i ) ; if ( l . isOn ( ) ) { int thisMinX = ( int ) ( l . getCenterX ( ) - l . getRadius ( ) - cornerX ) ; int thisMaxX = ( int ) ( l . getCenterX ( ) + l . getRadius ( ) - cornerX ) ; int thisMinY = ( int ) ( l . getCenterY ( ) - l . getRadius ( ) - cornerY ) ; int thisMaxY = ( int ) ( l . getCenterY ( ) + l . getRadius ( ) - cornerY ) ; if ( thisMaxX >= 0 && thisMinX <= maskImage . getWidth ( ) && thisMaxY >= 0 && thisMinY < maskImage . getWidth ( ) ) { Color [ ] colours = { new Color ( 0 , 0 , 0 , l . getIntensity ( ) ) , new Color ( 0 , 0 , 0 , 0 ) } ; g . setPaint ( new RadialGradientPaint ( l . getCenterX ( ) - cornerX , l . getCenterY ( ) - cornerY , l . getRadius ( ) , maskFractions , colours ) ) ; g . fillRect ( ( int ) ( l . getCenterX ( ) - l . getRadius ( ) - cornerX ) , ( int ) ( l . getCenterY ( ) - l . getRadius ( ) - cornerY ) , ( int ) ( l . getRadius ( ) * 2 ) , ( int ) ( l . getRadius ( ) * 2 ) ) ; } } } lookupOp . filter ( maskImage , maskImage ) ; } }
te	7	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == < ) { return XML . < ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == < || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } }
te	5	public static void add ( ArrayList < Track > newSongs ) { boolean lastTrackCase = false ; if ( newSongs == null ) return ; if ( playQueueTracks . size ( ) != 0 ) { if ( currentTrack . equals ( playQueueTracks . get ( playQueueTracks . size ( ) - 1 ) ) ) { lastTrackCase = true ; } } playQueueTracks . addAll ( newSongs ) ; if ( playQueueTracks . equals ( newSongs ) ) setCurrentTrack ( playQueueTracks . get ( 0 ) ) ; if ( lastTrackCase ) { int currentIndex = playQueueTracks . indexOf ( currentTrack ) ; setNextTrack ( playQueueTracks . get ( getNextTrackIndex ( currentIndex ) ) ) ; currentPlayback . setOnEndOfMedia ( new Runnable ( ) { @ Override public void run ( ) { setCurrentTrack ( nextTrack ) ; play ( ) ; } } ) ; } }
te	4	protected static void writeToXML ( String name , ArrayList < Question > questions ) throws IOException { if ( name == null || name . length ( ) <= 0 ) throw new IOException ( ) ; if ( ! name . contains ( ".xml" ) ) name += ".xml" ; BufferedWriter out = new BufferedWriter ( new FileWriter ( name ) ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; out . write ( "<assignment>\n" ) ; for ( int i = 0 ; i < questions . size ( ) ; i ++ ) questions . get ( i ) . generateXML ( out , i + 1 ) ; out . write ( "</assignment>" ) ; out . flush ( ) ; out . close ( ) ; }
te	6	public Kaavio puraVastauksetKaavioksi ( String tiedostoNimi ) { Kaavio kaavio = new Kaavio ( ) ; BufferedReader br = null ; String line = "" ; String valiMerkki = " " ; try { br = new BufferedReader ( new FileReader ( tiedostoNimi ) ) ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] vastaukset = line . split ( valiMerkki ) ; Noodi testiNoodi = new Noodi ( Integer . parseInt ( vastaukset [ 0 ] ) ) ; Noodi lahde = kaavio . lisaaNoodi ( testiNoodi ) ; for ( int i = 1 ; i < vastaukset . length ; i ++ ) { try { Noodi testiKohde = new Noodi ( Integer . parseInt ( vastaukset [ i ] ) ) ; Noodi kohde = kaavio . lisaaNoodi ( testiKohde ) ; kaavio . lisaaLinkki ( lahde , kohde ) ; } catch ( NumberFormatException e ) { System . out . println ( "Vastaus v\u00E4\u00E4r\u00E4ss\u00E4 muodossa!" ) ; } } } } catch ( Exception e ) { e . printStackTrace ( System . out ) ; System . out . println ( "Tiedostoa ei ole olemassa!" ) ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( System . out ) ; } } } return kaavio ; }
te	3	public int readBulk ( int ep , byte buf [ ] , int off , int length ) { int result = 0 ; while ( length > 0 ) { int this_transfer = Math . min ( length , 4096 ) ; int temp = readBulk ( fd , ep , buf , off , this_transfer ) ; if ( temp < 0 ) return temp ; off += temp ; length -= temp ; result += temp ; if ( temp < this_transfer ) break ; } return result ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( LendingsAdministration . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( LendingsAdministration . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( LendingsAdministration . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LendingsAdministration . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new LendingsAdministration ( ) . setVisible ( true ) ; } } ) ; }
te	5	public void mouseEntered ( MouseEvent arg0 ) { setBorder ( bigBord ) ; double coutAttaque = Partie . getInstance ( ) . coutAttaque ( territoire ) ; List < Element > elements = territoire . getElements ( ) ; String txt = "" ; String occupantName ; Peuple occupant = this . territoire . getOccupant ( ) ; int nbUnite = this . territoire . getNbUnite ( ) ; if ( occupant != null ) { occupantName = occupant . getNom ( ) + " (" + occupant . getJoueur ( ) . getNom ( ) + ")" ; } else if ( nbUnite > 0 ) { occupantName = "Th\u00E9sard" ; } else { occupantName = "Aucun" ; } txt += "Occupant : " + occupantName + "\n\n" ; txt += "Nombre d'unit\u00E9...... " + nbUnite + "\n" ; if ( double . isInfinite ( coutAttaque ) ) { txt += "Co\u00FBt de l'attaque... Imprenable !\n\n" ; } else { txt += "Co\u00FBt de l'attaque... " + Math . round ( coutAttaque ) + " unit\u00E9(s)\n\n" ; } txt += "El\u00E9ments contenus :\n" ; if ( elements . isEmpty ( ) ) { txt += "\tAucun." ; } else { Iterator < Element > it = elements . iterator ( ) ; while ( it . hasNext ( ) ) { txt += "\t" + it . next ( ) . getNom ( ) + "\n" ; } } Game . getInstance ( ) . showInfo ( txt ) ; }
te	9	private void createNewGeneration ( int generation , final List < Chromosome > population ) throws Exception { double ussage1 = population . get ( 0 ) . getUsedArea ( ) * 100 / ( truckSizeX * truckSizeY ) ; double fittness1 = population . get ( 0 ) . getFittnessValue ( ) ; double ussage2 = 0 ; double fittness2 = 0 ; GenerationModifier modifiers [ ] = new GenerationModifier [ ] { new GenerationModifier ( Messages . getString ( "GeneticEngine.8" ) , ( populationSize / 10 ) / threadCount ) { @ Override void modify ( final List < Chromosome > population ) { population . add ( createRandomChromosome ( null , null ) ) ; } } , new GenerationModifier ( Messages . getString ( "GeneticEngine.13" ) , ( populationSize * 4 / 3 ) / threadCount ) { @ Override void modify ( final List < Chromosome > population ) { int parent1 = rnd . nextInt ( populationSize ) ; int parent2 = rnd . nextInt ( populationSize - 1 ) ; if ( parent2 == parent1 ) { parent2 ++ ; } population . addAll ( mate ( population . get ( parent1 ) , population . get ( parent2 ) ) ) ; } } , new GenerationModifier ( Messages . getString ( "GeneticEngine.18" ) , ( populationSize * 4 / 3 ) / threadCount ) { @ Override void modify ( final List < Chromosome > population ) { int parent1 = rnd . nextInt ( populationSize ) ; population . addAll ( optimize ( population . get ( parent1 ) , preferences . getEngineOptimizationDepth ( ) ) ) ; } } , new GenerationModifier ( Messages . getString ( "GeneticEngine.23" ) , ( populationSize * 4 / 3 ) / threadCount ) { @ Override void modify ( final List < Chromosome > population ) { int parent1 = rnd . nextInt ( populationSize ) ; population . addAll ( randomize ( population . get ( parent1 ) ) ) ; } } , } ; final List < Object > waitList = Collections . synchronizedList ( new ArrayList < Object > ( ) ) ; final Thread computationThread = Thread . currentThread ( ) ; for ( int m = 0 ; m < modifiers . length ; m ++ ) { final GenerationModifier modifier = modifiers [ m ] ; Thread . interrupted ( ) ; sysout ( modifier . label ) ; for ( int i = 0 ; i < threadCount ; i ++ ) { new Thread ( ) { @ Override public void run ( ) { waitList . add ( this ) ; for ( int n = 0 ; n < modifier . size ; n ++ ) { modifier . modify ( population ) ; } waitList . remove ( this ) ; computationThread . interrupt ( ) ; } } . start ( ) ; } do { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } while ( waitList . size ( ) > 0 ) ; sortPopulation ( population ) ; ussage2 = population . get ( 0 ) . getUsedArea ( ) * 100 / ( truckSizeX * truckSizeY ) ; fittness2 = population . get ( 0 ) . getFittnessValue ( ) ; if ( ussage2 > ussage1 ) { sysout ( Messages . getString ( "GeneticEngine.9" ) + preferences . getDecimalFormatter ( ) . format ( ussage1 ) + Messages . getString ( "GeneticEngine.10" ) + preferences . getDecimalFormatter ( ) . format ( ussage2 ) + Messages . getString ( "GeneticEngine.11" ) ) ; } else if ( fittness2 > fittness1 ) { sysout ( Messages . getString ( "GeneticEngine.12" ) ) ; } ussage1 = ussage2 ; fittness1 = fittness2 ; if ( stopRequests . size ( ) > 0 ) return ; } populationSize = ( int ) ( preferences . getEnginePopulationSize ( ) * Math . pow ( ( 1 + preferences . getEnginePopulationGrowth ( ) / 100.0 ) , generation ) ) ; while ( population . size ( ) > populationSize ) { population . remove ( population . size ( ) - 1 ) ; } }
te	2	private boolean getIsAdminFromCmbIndex ( int cmbCategoryIndex ) { switch ( cmbCategoryIndex ) { case 0 : return false ; case 1 : return true ; } return false ; }
te	8	public double pow ( double x , int n ) { if ( x == 0.0 ) { if ( n == 0 ) return 1.0 ; return x ; } if ( n == 0 ) { return 1.0 ; } if ( n > 0 ) { if ( n == 1 ) { return x ; } if ( n % 2 == 0 ) { double tmp = pow ( x , n >> 1 ) ; return tmp * tmp ; } else { return x * pow ( x , n - 1 ) ; } } else { if ( n == - 1 ) { return 1.0 / x ; } if ( n % 2 == 0 ) { double tmp = pow ( x , n / 2 ) ; return tmp * tmp ; } else { return ( 1.0 / x ) * pow ( x , ( n + 1 ) ) ; } } }
te	4	@ Override public void escalonarSe ( Escalonamento tipo ) { double sX = 1 , sY = 1 ; double cX = this . centro ( ) . getXD ( ) ; double cY = this . centro ( ) . getYD ( ) ; switch ( tipo ) { case AUMENTAR : sX = 1.1 ; sY = 1.1 ; break ; case DIMINUIR : sX = 0.9 ; sY = 0.9 ; break ; } for ( CoordenadasHomogeneas c : listaCoord ) { double x = c . getXD ( ) ; double y = c . getYD ( ) ; c . setX ( ( ( - cX * sX ) + cX ) + ( sX * x ) ) ; c . setY ( ( ( - cY * sY ) + cY ) + ( sY * y ) ) ; } double cXwin = this . centroWin ( ) . getXD ( ) ; double cYwin = this . centroWin ( ) . getYD ( ) ; for ( CoordenadasHomogeneas cN : listaCoordWin ) { double x = cN . getXD ( ) ; double y = cN . getYD ( ) ; cN . setX ( ( ( - cXwin * sX ) + cXwin ) + ( sX * x ) ) ; cN . setY ( ( ( - cYwin * sY ) + cYwin ) + ( sY * y ) ) ; } }
te	9	public boolean canSendNextPacket ( ) { if ( timeStampNow - lastZeroWindow > getTimeOutMicros ( ) && lastZeroWindow != 0 && maxWindow == 0 ) { log . debug ( "setting window to one packet size. current window is:" + currentWindow ) ; maxWindow = MAX_PACKET_SIZE ; } boolean windowNotFull = ! isWondowFull ( ) ; boolean burstFull = false ; if ( windowNotFull ) { burstFull = isBurstFull ( ) ; } if ( ! burstFull && windowNotFull ) { currentBurstSend ++ ; } if ( burstFull ) { currentBurstSend = 0 ; } return SEND_IN_BURST ? ( ! burstFull && windowNotFull ) : windowNotFull ; }
te	9	private static String hasDefinedToString ( Object o ) { Method tsm = null ; class < ? > c = o . getClass ( ) ; class < ? > cs = c . getSuperclass ( ) ; while ( c != null ) { try { tsm = c . getDeclaredMethod ( "toString" , new class [ ] { } ) ; } catch ( NoSuchMethodException e ) { } if ( tsm != null ) { try { class < ? > defclass = tsm . getDeclaringClass ( ) ; if ( defclass . getName ( ) . equals ( "java.lang.Object" ) || defclass . getName ( ) . equals ( "java.util.AbstractCollection" ) ) return "" ; else { Reflector . ensureIsAccessible ( tsm ) ; return ( String ) tsm . invoke ( o , new Object [ ] { } ) ; } } catch ( IllegalAccessException e ) { System . out . println ( "IllegalAccessException:" + e . getMessage ( ) ) ; System . out . println ( "Incorrectly invoked toString method in the class:" + o . getClass ( ) . getName ( ) + "\n" ) ; } catch ( InvocationTargetException e ) { System . out . println ( "InvocationTargetException:" + e . getMessage ( ) ) ; System . out . println ( "Incorrectly invoked toString method in the class:" + o . getClass ( ) . getName ( ) + "\n" ) ; } } else { c = cs ; cs = c . getSuperclass ( ) ; } } return "" ; }
te	2	private static void getTrainData ( File dataFile , int num_games , File gameIds ) { DisconnectedGameData myGameData = new DisconnectedGameData ( num_games , null , false ) ; SVMTrain trainingModel = new SVMTrain ( dataFile ) ; Utilities . printInfo ( "Created the SVM model" ) ; trainingModel . train ( myGameData ) ; Utilities . printInfo ( "Just finished creating the training file!" ) ; try { BufferedWriter writer = new BufferedWriter ( new FileWriter ( gameIds . getAbsoluteFile ( ) ) ) ; ArrayList < Integer > ids = myGameData . getCurrentGameId ( ) ; for ( Integer id : ids ) { writer . write ( id + "\n" ) ; } writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } myGameData . close ( ) ; }
te	4	@ Override public void propertyChange ( PropertyChangeEvent evt ) { switch ( evt . getPropertyName ( ) ) { case "Animal Count" : { Object o = evt . getNewValue ( ) ; if ( o instanceof Integer ) { setCount ( ( Integer ) o ) ; } break ; } case "Animal Species" : { Object o = evt . getNewValue ( ) ; if ( o instanceof String ) { setAnimalName ( ( String ) o ) ; } break ; } } }
te	8	public Shape [ ] getForceArrows ( ) { float xSum = pos . x ; float ySum = pos . y ; float zSum = 0 ; float rXSum = pos . x ; float rYSum = pos . y ; float rZSum = 0 ; float temp ; Shape [ ] shapes = new Shape [ 2 ] ; for ( Force f : forces ) { temp = ( f . getValue ( ) > 0 ? - 5 : + 5 ) * ( ( int ) Math . log ( Math . abs ( f . getValue ( ) ) ) ) ; switch ( f . getAxis ( ) ) { case ( "Y" ) : ySum -= temp ; break ; case ( "X" ) : xSum += temp ; break ; case ( "Z" ) : zSum += temp ; break ; case ( "RX" ) : rXSum += temp ; break ; case ( "RY" ) : rYSum += temp ; break ; case ( "RZ" ) : rZSum += temp ; break ; default : break ; } } shapes [ 0 ] = createArrow ( xSum , ySum , pos . x , pos . y , false ) ; shapes [ 1 ] = createArrow ( rXSum , rYSum , pos . x , pos . y , true ) ; return shapes ; }
te	9	private boolean runStandardCommand ( String com ) { if ( com . equals ( "start" ) ) { mm . start ( ) ; } else if ( com . equals ( "armsUp" ) ) { mm . armsUp ( ) ; } else if ( com . equals ( "armsDown" ) ) { mm . armsDown ( ) ; } else if ( com . equals ( "stand" ) ) { mm . stand ( ) ; } else if ( com . equals ( "sit" ) ) { mm . sit ( ) ; } else if ( com . equals ( "walk" ) ) { mm . walk ( ) ; } else if ( com . equals ( "turn" ) ) { mm . turn ( ) ; } else if ( com . equals ( "cntReset" ) ) { mm . zero ( ) ; } else if ( com . equals ( "cntDec" ) ) { mm . decrement ( ) ; } else if ( com . equals ( "cntInc" ) ) { mm . increment ( ) ; } else return false ; return true ; }
te	3	public < T > T getAttributeValue ( String name , T defaultValue , class < T > type ) { Parameter parameter = getAttribute ( name ) ; if ( parameter == null ) return defaultValue ; if ( parameter . isCollection ( ) ) throw new IllegalArgumentException ( "Duplicate attribute: " + name ) ; Object value = parameter . getValue ( ) ; if ( value == null ) return defaultValue ; return type . cast ( value ) ; }
te	5	private void sort ( ) { if ( sorting || sortOrder == SortOrder . UNSORTED ) { return ; } sorting = true ; List < E > elements = new ArrayList < E > ( getSize ( ) ) ; for ( int i = 0 ; i < getSize ( ) ; i ++ ) { elements . add ( getElementAt ( i ) ) ; } Collections . sort ( elements , comparator ) ; if ( sortOrder == SortOrder . ASCENDING ) { Collections . reverse ( elements ) ; } clear ( ) ; for ( E element : elements ) { add ( 0 , element ) ; } sorting = false ; }
te	4	public void setFasePoints ( int faseNumber , String value ) { properties . setProperty ( encode ( "fase" + faseNumber ) , encode ( value ) ) ; int pointAux = 0 ; for ( int i = 1 ; i <= Universal . quantidadeFases ; i ++ ) { if ( properties . getProperty ( encode ( "fase" + i ) ) == null ) { break ; } else { pointAux += Integer . parseInt ( decode ( properties . getProperty ( encode ( "fase" + i ) ) ) ) ; } } properties . setProperty ( encode ( "total" ) , encode ( pointAux + "" ) ) ; String levelAux = "" ; if ( pointAux < 400 ) { levelAux = "Iniciante" ; } else if ( pointAux < 600 ) { levelAux = "Regular" ; } else { levelAux = "Expert" ; } properties . setProperty ( encode ( "level" ) , encode ( levelAux ) ) ; store ( ) ; }
te	0	public int getKeyId ( ) { return keyId ; }
te	8	public static void securityGoalSimplification ( RequirementGraph req_model , ActorAssociationGraph actor_model , int scope ) throws IOException , ScriptException { String req_model_file = req_model . generateFormalExpressionToFile ( scope ) ; String actor_model_file = InfoEnum . current_directory + "/dlv/models/actor_association_model.dl " ; if ( actor_model . getElements ( ) . size ( ) != 0 ) { actor_model_file = actor_model . generateFormalExpressionToFile ( ) ; } String inference_rule = "" ; if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_bus.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/business_process_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_app.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . PHYSICAL . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_phy.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/deployment_model.dl " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( inference_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { CommandPanel . logger . info ( s ) ; if ( s . startsWith ( "is_critical" ) ) { s = s . replaceAll ( "is\\_critical\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setCriticality ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "5" , "none" , "none" ) ; } else if ( s . startsWith ( "non_deterministic" ) ) { s = s . replaceAll ( "non\\_deterministic\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setNon_deterministic ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "3" , "none" , "none" ) ; } } } input . close ( ) ; }
te	8	public int [ ] getAvailable ( ) { int [ ] unavailable = getUnavailableSpots ( ) ; int [ ] available = new int [ maxSpots ] ; for ( int i = 0 ; i < maxSpots ; i ++ ) { available [ i ] = i + 1 ; } for ( int i = 0 ; i < unavailable . length ; i ++ ) { for ( int j = 0 ; j < maxSpots ; j ++ ) { if ( available [ j ] == unavailable [ i ] ) { available [ j ] = 0 ; } } } int counter = 0 ; for ( int i = 0 ; i < maxSpots ; i ++ ) { if ( available [ i ] != 0 ) { counter ++ ; } } int [ ] tempAvail = new int [ counter ] ; int tempCounter = 0 ; for ( int i = 0 ; i < counter ; i ++ ) { if ( available [ i ] != 0 ) { tempAvail [ tempCounter ++ ] = available [ i ] ; } } return tempAvail ; }
te	8	public static double [ ] [ ] benchmarkJLargeArraysByteSequentual ( long [ ] sizes , int [ ] nthreads , int iters , String file ) { double [ ] [ ] results = new double [ nthreads . length ] [ sizes . length ] ; long k ; System . out . println ( "Benchmarking JLargeArrays (bytes  sequentual)" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { int nt = nthreads [ th ] ; Thread [ ] threads = new Thread [ nt ] ; System . out . println ( "\tNumber of threads = " + nt ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { System . out . print ( "\tSize = " + sizes [ i ] ) ; final ByteLargeArray a = new ByteLargeArray ( sizes [ i ] ) ; double t = System . nanoTime ( ) ; for ( int it = 0 ; it < iters ; it ++ ) { k = sizes [ i ] / nt ; for ( int j = 0 ; j < nt ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nt - 1 ) ? sizes [ i ] : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { a . setByte ( k , ( byte ) 1 ) ; a . setByte ( k , ( byte ) ( a . getByte ( k ) + 1 ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nt ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } results [ th ] [ i ] = ( System . nanoTime ( ) - t ) / 1000000000.0 / ( double ) iters ; System . out . println ( " : " + String . format ( "%.7f sec" , results [ th ] [ i ] ) ) ; } } writeToFile ( sizes , nthreads , results , file ) ; return results ; }
te	2	private static ArrayList < String > getLaunchParams ( Map params ) throws URISyntaxException { ArrayList < String > launchParams = new ArrayList < String > ( ) ; String pathToJar = MinecraftLauncher . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . toURI ( ) . getPath ( ) ; Integer memory = 1024 ; if ( params . containsKey ( OptionsPanel . MEMORY_KEY ) ) { memory = ( Integer ) params . get ( OptionsPanel . MEMORY_KEY ) ; } float heapSizeMegs = ( float ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 1024 / 1024 ) ; launchParams . add ( "javaw" ) ; launchParams . add ( "-Xms512m" ) ; if ( memory <= 0 ) { memory = 1024 ; } MessageFormat memoryFormat = new MessageFormat ( "-Xmx{0}m" ) ; launchParams . add ( memoryFormat . format ( new Object [ ] { memory . toString ( ) } ) ) ; launchParams . add ( "-Dsun.java2d.noddraw=true" ) ; launchParams . add ( "-Dsun.java2d.d3d=false" ) ; launchParams . add ( "-Dsun.java2d.opengl=false" ) ; launchParams . add ( "-Dsun.java2d.pmoffscreen=false" ) ; launchParams . add ( "-classpath" ) ; launchParams . add ( pathToJar ) ; launchParams . add ( "net.minecraft.LauncherFrame" ) ; return launchParams ; }
te	4	public String getCName ( boolean withPointer ) { if ( this instanceof VoidType ) return "void * " ; if ( this instanceof IntType ) return "int" ; if ( this instanceof StringType ) return "char * " ; String str = "_class_" + name ; if ( withPointer ) str += " *" ; return str ; }
te	9	private final void interruptableRun ( ) { if ( channel == null ) { return ; } try { String host ; int port ; if ( proxyAddress != null ) { host = proxyAddress . getHostName ( ) ; port = proxyAddress . getPort ( ) ; } else { host = uri . getHost ( ) ; port = getPort ( ) ; } channel . connect ( new InetSocketAddress ( host , port ) ) ; conn . channel = wrappedchannel = createProxyChannel ( wsfactory . wrapChannel ( channel , null , host , port ) ) ; timeout = 0 ; sendHandshake ( ) ; readthread = new Thread ( new WebsocketWriteThread ( ) ) ; readthread . start ( ) ; } catch ( ClosedByInterruptException e ) { onWebsocketError ( null , e ) ; return ; } catch ( Exception e ) { onWebsocketError ( conn , e ) ; conn . closeConnection ( CloseFrame . NEVER_CONNECTED , e . getMessage ( ) ) ; return ; } ByteBuffer buff = ByteBuffer . allocate ( WebSocketImpl . RCVBUF ) ; try { while ( channel . isOpen ( ) ) { if ( SocketChannelIOHelper . read ( buff , this . conn , wrappedchannel ) ) { conn . decode ( buff ) ; } else { conn . eot ( ) ; } if ( wrappedchannel instanceof WrappedByteChannel ) { WrappedByteChannel w = ( WrappedByteChannel ) wrappedchannel ; if ( w . isNeedRead ( ) ) { while ( SocketChannelIOHelper . readMore ( buff , conn , w ) ) { conn . decode ( buff ) ; } conn . decode ( buff ) ; } } } } catch ( CancelledKeyException e ) { conn . eot ( ) ; } catch ( IOException e ) { conn . eot ( ) ; } catch ( RuntimeException e ) { onError ( e ) ; conn . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; } }
te	3	public final int [ ] getVisualPadding ( ) { if ( vp && c instanceof JTabbedPane ) { if ( UIManager . getLookAndFeel ( ) . getClass ( ) . getName ( ) . endsWith ( "WindowsLookAndFeel" ) ) return new int [ ] { - 1 , 0 , 2 , 2 } ; } return null ; }
te	1	public void remove ( ) { if ( isAlive ( ) ) eng . removeObject ( this ) ; is_alive = false ; }
te	5	public V get ( int key ) { if ( key == 0 ) { if ( ! hasZeroValue ) { return null ; } return zeroValue ; } int index = key & mask ; if ( keyTable [ index ] != key ) { index = hash2 ( key ) ; if ( keyTable [ index ] != key ) { index = hash3 ( key ) ; if ( keyTable [ index ] != key ) { return getStash ( key , null ) ; } } } return valueTable [ index ] ; }
te	9	protected static void emit_action_code ( PrintWriter out , production start_prod ) throws internal_error { production prod ; long start_time = System . currentTimeMillis ( ) ; out . println ( ) ; out . println ( "/** Cup generated class to encapsulate user supplied action code.*/" ) ; out . println ( "class " + pre ( "actions" ) + " {" ) ; if ( action_code != null ) { out . println ( ) ; out . println ( action_code ) ; } out . println ( "  private final " + parser_class_name + " parser;" ) ; out . println ( ) ; out . println ( "  /** Constructor */" ) ; out . println ( "  " + pre ( "actions" ) + "(" + parser_class_name + " parser) {" ) ; out . println ( "    this.parser = parser;" ) ; out . println ( "  }" ) ; out . println ( ) ; out . println ( "  /** Method with the actual generated action code. */" ) ; out . println ( "  public final java_cup.runtime.Symbol " + pre ( "do_action" ) + "(" ) ; out . println ( "    int                        " + pre ( "act_num " ) ) ; out . println ( "    java_cup.runtime.lr_parser " + pre ( "parser " ) ) ; out . println ( "    java.util.Stack            " + pre ( "stack " ) ) ; out . println ( "    int                        " + pre ( "top)" ) ) ; out . println ( "    throws java.lang.Exception" ) ; out . println ( "    {" ) ; out . println ( "      /* Symbol object for return from actions */" ) ; out . println ( "      java_cup.runtime.Symbol " + pre ( "result" ) + ";" ) ; out . println ( ) ; out . println ( "      /* select the action based on the action number */" ) ; out . println ( "      switch (" + pre ( "act_num" ) + ")" ) ; out . println ( "        {" ) ; for ( Enumeration p = production . all ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; out . println ( "          /*. . . . . . . . . . . . . . . . . . . .*/" ) ; out . println ( "          case " + prod . index ( ) + ": // " + prod . to_simple_string ( ) ) ; out . println ( "            {" ) ; out . println ( "              " + prod . lhs ( ) . the_symbol ( ) . stack_type ( ) + " RESULT = null;" ) ; for ( int i = 0 ; i < prod . rhs_length ( ) ; i ++ ) { if ( ! ( prod . rhs ( i ) instanceof symbol_part ) ) continue ; symbol s = ( ( symbol_part ) prod . rhs ( i ) ) . the_symbol ( ) ; if ( ! ( s instanceof non_terminal ) ) continue ; if ( ( ( non_terminal ) s ) . is_embedded_action == false ) continue ; int index = prod . rhs_length ( ) - i - 1 ; out . println ( "              " + "// propagate RESULT from " + s . name ( ) ) ; out . println ( "              " + "if ( " + "((java_cup.runtime.Symbol) " + emit . pre ( "stack" ) + ".elementAt(" + emit . pre ( "top" ) + "-" + index + ")).value != null )" ) ; out . println ( "                " + "RESULT = " + "(" + prod . lhs ( ) . the_symbol ( ) . stack_type ( ) + ") " + "((java_cup.runtime.Symbol) " + emit . pre ( "stack" ) + ".elementAt(" + emit . pre ( "top" ) + "-" + index + ")).value;" ) ; } if ( prod . action ( ) != null && prod . action ( ) . code_string ( ) != null && ! prod . action ( ) . equals ( "" ) ) out . println ( prod . action ( ) . code_string ( ) ) ; if ( emit . lr_values ( ) ) { int loffset ; String leftstring , rightstring ; int roffset = 0 ; rightstring = "((java_cup.runtime.Symbol)" + emit . pre ( "stack" ) + ".elementAt(" + emit . pre ( "top" ) + "-" + roffset + ")).right" ; if ( prod . rhs_length ( ) == 0 ) leftstring = rightstring ; else { loffset = prod . rhs_length ( ) - 1 ; leftstring = "((java_cup.runtime.Symbol)" + emit . pre ( "stack" ) + ".elementAt(" + emit . pre ( "top" ) + "-" + loffset + ")).left" ; } out . println ( "              " + pre ( "result" ) + " = new java_cup.runtime.Symbol(" + prod . lhs ( ) . the_symbol ( ) . index ( ) + "/*" + prod . lhs ( ) . the_symbol ( ) . name ( ) + "*/" + "  " + leftstring + "  " + rightstring + "  RESULT);" ) ; } else { out . println ( "              " + pre ( "result" ) + " = new java_cup.runtime.Symbol(" + prod . lhs ( ) . the_symbol ( ) . index ( ) + "/*" + prod . lhs ( ) . the_symbol ( ) . name ( ) + "*/" + "  RESULT);" ) ; } out . println ( "            }" ) ; if ( prod == start_prod ) { out . println ( "          /* ACCEPT */" ) ; out . println ( "          " + pre ( "parser" ) + ".done_parsing();" ) ; } out . println ( "          return " + pre ( "result" ) + ";" ) ; out . println ( ) ; } out . println ( "          /* . . . . . .*/" ) ; out . println ( "          default:" ) ; out . println ( "            throw new Exception(" ) ; out . println ( "               \"Invalid action number found in " + "internal parse table\");" ) ; out . println ( ) ; out . println ( "        }" ) ; out . println ( "    }" ) ; out . println ( "}" ) ; out . println ( ) ; action_code_time = System . currentTimeMillis ( ) - start_time ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FishMainFrame ( ) . setVisible ( true ) ; } } ) ; }
te	3	public double Percentile ( int index , double p ) { if ( dist . containsKey ( index ) ) { Map < Integer , Integer > m = dist . get ( index ) ; List < Integer > s = General . asSortedList ( m . keySet ( ) ) ; DescriptiveStatistics DS = new DescriptiveStatistics ( ) ; for ( int i : s ) { for ( int j = 0 ; j < m . get ( i ) ; j ++ ) { DS . addValue ( i ) ; } } return DS . getPercentile ( p ) ; } else { System . out . println ( "Index not found." ) ; } return - 1 ; }
te	1	public void handleRequest ( ) throws IOException { try { _socket . setSoTimeout ( 200 ) ; Request request = new RequestImpl ( _socket . getInputStream ( ) ) ; ResponseFactory factory = new ResponseFactory ( ) ; OutputStream stream = _socket . getOutputStream ( ) ; Response response = factory . buildResponse ( request , _subsystems ) ; response . writeResponse ( stream ) ; } catch ( IOException e ) { throw e ; } finally { _socket . close ( ) ; } }
te	9	private void correctRenderOffset ( ) { boolean xl = ( renderOffset . x < renderMinOffset . x ) ; boolean xh = ( renderOffset . x > renderMaxOffset . x ) ; if ( xl && xh ) { renderOffset . x = ( renderMinOffset . x + renderMaxOffset . x ) / 2f ; } else { if ( xl ) renderOffset . x = renderMinOffset . x ; if ( xh ) renderOffset . x = renderMaxOffset . x ; } boolean yl = ( renderOffset . y < renderMinOffset . y ) ; boolean yh = ( renderOffset . y > renderMaxOffset . y ) ; if ( yl && yh ) { renderOffset . y = ( renderMinOffset . y + renderMaxOffset . y ) / 2f ; } else { if ( yl ) renderOffset . y = renderMinOffset . y ; if ( yh ) renderOffset . y = renderMaxOffset . y ; } if ( ( interactionState == InteractionState . scrolling ) && ( ( xl && xh ) || ( yl && yh ) ) ) initiateScrollDragging ( ) ; }
te	3	public void Imprimir ( ) { for ( int f = 0 ; f < 4 ; f ++ ) { for ( int c = 0 ; c < 4 ; c ++ ) { if ( f == c ) { System . out . println ( x + " " ) ; } else { System . out . println ( ) ; } } } }
te	0	public LinkedList < Command > getCommands ( String boardName ) { return boards . get ( boardName ) . getCommands ( ) ; }
te	3	public static boolean checkDataNodes ( List < String > live_DataNodes ) { if ( live_DataNodes . size ( ) != list_DataNode . size ( ) ) { return false ; } else { for ( String name : live_DataNodes ) { if ( ! list_DataNode . containsKey ( name ) ) { return false ; } } } return true ; }
te	5	public void printMatrixColckWisely ( int [ ] [ ] num , int columns , int rows ) { if ( num == null || columns <= 0 || rows <= 0 ) { return ; } int start = 0 ; while ( columns > start * 2 && rows > start * 2 ) { printMatrixInCircle ( num , columns , rows , start ) ; start ++ ; } }
