tr	8	public void renderHead ( IHeaderResponse response ) { MySession sess = ( MySession ) getSession ( ) ; Board bd = sess . getBoard ( ) ; PlayerInfo nextplayer = sess . getTurn ( ) ; if ( bd . getGameStatus ( ) == GameStatus . GAMING ) { int [ ] putcandidatelist = bd . getPutCandidateList ( nextplayer . getStoneType ( ) ) ; if ( nextplayer . getPlayerType ( ) == PlayerInfo . TYPE_COM ) { boolean pass = false ; if ( putcandidatelist . length == 0 ) { pass = true ; } response . renderOnDomReadyJavascript ( "javascript:disableAll();setTimeout('callComTurn(" + pass + ")' 500);" ) ; } else { if ( putcandidatelist . length == 0 ) { response . renderOnDomReadyJavascript ( "javascript:disableAll();setTimeout('callHumanPass()' 500);" ) ; } } } else { if ( bd . getGameStatus ( ) == GameStatus . GAMEOVER_DRAW ) { response . renderOnDomReadyJavascript ( "javascript:drawGame();" ) ; } if ( bd . getGameStatus ( ) == GameStatus . GAMEOVER_1WIN ) { if ( sess . getPlayer1 ( ) . getPlayerType ( ) == PlayerInfo . TYPE_HUMAN ) { response . renderOnDomReadyJavascript ( "javascript:youWin();" ) ; } else { response . renderOnDomReadyJavascript ( "javascript:com1Win();" ) ; } } if ( bd . getGameStatus ( ) == GameStatus . GAMEOVER_2WIN ) { response . renderOnDomReadyJavascript ( "javascript:youLoose();" ) ; } } }
tr	3	public static Shell Create ( ByteList messageBytes ) throws Exception { Shell result ; if ( messageBytes == null || messageBytes . getLength ( ) < 6 ) { throw new Exception ( "Invalid message byte array" ) ; } if ( messageBytes . peekInt ( ) != Shell . getClassID ( ) ) { throw new Exception ( "Invalid message type" ) ; } else { result = new Shell ( ) ; result . decode ( messageBytes ) ; } return result ; }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	5	@ Override public void actionPerformed ( ActionEvent arg0 ) { String s = ( String ) categories . getSelectedItem ( ) ; DetailsPanelController pc = DetailsPanelController . getInstance ( ) ; if ( s . equals ( "" ) ) { if ( pc . getCurrentTask ( ) != null ) { pc . getCurrentTask ( ) . setCategory ( new Category ( "" , tl . getColor ( "black" ) ) ) ; pc . updateTask ( pc . getCurrentTask ( ) ) ; } } else { for ( Category c : PanicController . getInstance ( ) . getCategories ( ) ) { if ( c . getName ( ) . equals ( s ) ) { if ( pc . getCurrentTask ( ) != null ) { pc . getCurrentTask ( ) . setCategory ( c ) ; pc . updateTask ( pc . getCurrentTask ( ) ) ; } break ; } } } }
tr	1	@ Test public void testGetArgument ( ) { initializeArguments ( ) ; InputDefinition definition = new InputDefinition ( ) ; definition . addArguments ( Arrays . asList ( ( InputArgument ) foo ) ) ; assertEquals ( "getArgument() returns a InputArgument by its name" , foo , definition . getArgument ( "foo" ) ) ; try { definition . getArgument ( "bar" ) ; fail ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" ) ; } catch ( Exception e ) { assertTrue ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" , e instanceof IllegalArgumentException ) ; assertEquals ( "The \"bar\" argument does not exist." , e . getMessage ( ) ) ; } }
tr	2	private static void print ( int [ ] array , String string ) { System . out . println ( string + ":" ) ; for ( int j = 0 ; j < array . length ; j ++ ) { System . out . print ( array [ j ] ) ; if ( j < array . length - 1 ) System . out . print ( "  " ) ; } System . out . println ( ) ; }
tr	5	public static boolean checkValidity ( BeanConceptos bean , IClient client ) { boolean valid = true ; if ( bean . nombre . trim ( ) . equals ( "" ) ) { return false ; } String dbName = client . getCurrentDBPrefix ( ) + client . getAnyAcademic ( ) + "plus" ; String SQL1 = "SELECT * FROM " + client . getPlusDbName ( ) + "sgd_conceptos WHERE idProfesores=" + bean . idProfesores + " AND idClase=" + bean . idClase + " AND nombreConcepto=? AND id<>" + bean . id ; try { PreparedStatement st = client . getPlusDb ( ) . createPreparedStatement ( SQL1 ) ; ResultSet rs1 = client . getPlusDb ( ) . getPreparedResultSet ( new Object [ ] { bean . nombre } , st ) ; if ( rs1 != null && rs1 . next ( ) ) { valid = false ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Conceptos . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return valid ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	8	@ Override public Cursor < C > start ( final ContextProvider < C > context ) { return new Cursor < C > ( ) { State < C > _current ; int _currentTime ; Predicate < C > _lastValidPredicate ; @ Override public ITimedAutomata < C > getAutomata ( ) { return TimedAutomata . this ; } @ Override final public boolean next ( ContextProvider < C > provider ) { C ctx = context . getContext ( ) ; boolean allexpired = true ; State < C > timeoutTarget = null ; for ( Transition trans : _transitions . get ( _current ) ) { int timeout = trans . timeout ; if ( timeout == TIMEOUT ) timeoutTarget = trans . state ; else if ( _currentTime < timeout || timeout == INFINITY ) { allexpired = false ; if ( trans . predicate . isValid ( ctx ) ) { _lastValidPredicate = trans . predicate ; setState ( trans . state , ctx ) ; } } } _currentTime ++ ; if ( allexpired && timeoutTarget != null ) setState ( timeoutTarget , ctx ) ; return ( _current . getModifier ( ) & TERMINATE ) > 0 ; } @ Override public Predicate < C > getLastValidPredicate ( ) { return _lastValidPredicate ; } final public void setState ( State < C > target , C context ) { if ( _current == target ) { target . eachAction ( context ) ; } else { _current . postAction ( context ) ; _current = target ; _currentTime = 0 ; _current . preAction ( context ) ; } } } ; }
tr	6	public void update ( final float x , final float y , final float z ) { minx = ( ( x < minx ) ? x : minx ) ; maxx = ( ( x > maxx ) ? x : maxx ) ; miny = ( ( y < miny ) ? y : miny ) ; maxy = ( ( y > maxy ) ? y : maxy ) ; minz = ( ( z < minz ) ? z : minz ) ; maxz = ( ( z > maxz ) ? z : maxz ) ; }
tr	5	public void addLine ( ) { if ( buffer . size ( ) > 0 ) { FingerPrint fing = new FingerPrint ( lines . size ( ) + 1 ) ; fing . words = buffer . size ( ) ; for ( String wd : buffer ) { int vc = countVowels ( wd ) ; int sz = wd . length ( ) ; char [ ] ca = wd . toLowerCase ( ) . toCharArray ( ) ; for ( char c : ca ) { fing . bag . add ( c ) ; } fing . chars += sz ; fing . vowels += vc ; fing . cons += ( sz - vc ) ; fing . stop += ( StopWords . spanish ( wd ) ) ? 1 : 0 ; fing . articles += ( StopWords . spanish_articles ( wd ) ) ? 1 : 0 ; } lines . add ( fing ) ; buffer . clear ( ) ; } }
tr	3	public boolean hasNext ( ) { return curNode != null && curIndex < curNode . keys . size ( ) && ( high == null || comp . compare ( curNode . keys . get ( curIndex ) , high ) < 0 ) ; }
tr	1	static Map < String , String > parseDigestParameters ( String query ) { Matcher matcher = PARAMETER_PATTERN . matcher ( query ) ; Map < String , String > map = new HashMap < String , String > ( ) ; while ( matcher . find ( ) ) { String key = matcher . group ( 1 ) ; String value = matcher . group ( 2 ) ; map . put ( key , value ) ; } return map ; }
tr	2	public void enterEditMode ( ) { if ( titleEditable && ! editMode ) { editField . setText ( titleLabel . getText ( ) ) ; remove ( titleLabel ) ; add ( editField ) ; repaint ( ) ; editField . requestFocus ( ) ; editField . setSelectionStart ( 0 ) ; editField . setSelectionEnd ( editField . getText ( ) . length ( ) ) ; editMode = true ; } }
tr	7	public String getPreparedContent ( String content , String inputArea ) throws InvalidInput { currentInputArea = inputArea ; String withComputed = content ; if ( content . contains ( "#[" ) ) withComputed = replaceComputed ( content ) ; String withEnumerated = withComputed ; if ( content . contains ( "#{" ) || content . contains ( "{#" ) || content . contains ( "#}" ) ) withEnumerated = replaceEnumerated ( withComputed ) ; if ( withEnumerated . contains ( "#{" ) || withEnumerated . contains ( "{#" ) || withEnumerated . contains ( "#}" ) ) Logger . warning ( "Looks like You want to have changeable values in \"" + currentInputArea + "\". " + "If it's true You use wrong syntax." ) ; return withEnumerated ; }
tr	7	public void update ( ) { tryattack ( ) ; xa = 0 ; ya = 0 ; if ( ! attacking ) { randommovement ( ) ; } if ( anim < 40 ) anim ++ ; else { anim = 0 ; } if ( xa != 0 || ya != 0 ) { walking = true ; move ( xa , ya ) ; } else { walking = false ; } if ( hit ) { if ( anim2 < 40 ) anim2 ++ ; else { anim2 = 0 ; hit = false ; OverHead = "" ; } } if ( checkattack ) { checkattack = false ; checkattack ( this ) ; } }
tr	5	public String checkDataEntry ( ) { if ( efastAnalysisPanel1 . parameterScreen . directoryChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) . equals ( "" ) || efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . parametersModel . contains ( "None Entered" ) ) { return "No parameters have been selected" ; } else { try { Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) ) ; Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Number of curves and parameter samples must be integers" ; } } }
tr	5	public static synchronized void stop ( final boolean crash , final Exception e ) { if ( ! running ) { return ; } GameLog . info ( "Stopping Game..." , false ) ; WorldUtil . save ( Guis . world ) ; if ( ! crash || ( e == null ) ) { exit ( 0 ) ; } else if ( crash & ( e == null ) ) { GameLog . warn ( "I don't know why I crashed  but I crashed." ) ; exit ( 1 ) ; } else if ( e != null ) { GameLog . warn ( e . getMessage ( ) ) ; exit ( 1 ) ; } }
tr	1	private void initHashForEntryTest ( ) { this . jedis . del ( KEY_HASH_ENTRY_TEST ) ; for ( int i = 0 ; i < INIT_HASH_ENTRY ; i ++ ) { this . jedis . hset ( KEY_HASH_ENTRY_TEST , "field1" + ( i + 1 ) , "test value" + i ) ; } }
tr	5	@ Override public Object visit ( ASTattr_stmt node , Object data ) { commonProcessing ( node , this ) ; if ( node . jjtGetValue ( ) . equals ( "node" ) ) { for ( int i = 0 ; i < node . jjtGetNumChildren ( ) ; i ++ ) { Node child = node . jjtGetChild ( i ) ; if ( child instanceof ASTattr_list ) { String childNodeShape = ( String ) child . jjtAccept ( this , data ) ; if ( childNodeShape . equals ( "doublecircle" ) || childNodeShape . equals ( "box" ) ) this . accept = true ; else this . accept = false ; } else { child . jjtAccept ( this , data ) ; } } } else node . childrenAccept ( this , data ) ; return null ; }
tr	5	public static void madMethod ( ) throws AuthorizationException , BusinessRuleViolation , DuplicateEntityViolation , SearchException , SystemError { double seed = Math . random ( ) ; if ( seed < 0.15 ) { throw new AuthorizationException ( Type . ACCESS_DENIED , new Exception ( "User crab not allowed" ) ) ; } else if ( seed < 0.3 ) { throw new DuplicateEntityViolation ( "Duplicate issue" , new NamedEntity ( ) ) ; } else if ( seed < 0.45 ) { throw new BusinessRuleViolation ( "Holy crab" , BusinessRule . FEE_TOO_SMALL , new NamedEntity ( ) ) ; } else if ( seed < 0.6 ) { throw new SearchException ( "Holy moly query" ) ; } else if ( seed < 0.75 ) { throw new SystemError ( "Gosh" , new Exception ( "Crab error" ) , visitorChallenge . exception . SystemError . Type . TRANSIENT_INSTANCE ) ; } System . out . println ( "Yupee" ) ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	0	public static void main ( String [ ] args ) throws Exception { Predicate < String > predicate = ( s ) -> s . length ( ) > 0 ; predicate . test ( "foo" ) ; predicate . negate ( ) . test ( "foo" ) ; Predicate < boolean > nonNull = Objects COLCOL nonNull ; Predicate < boolean > isNull = Objects COLCOL isNull ; Predicate < String > isEmpty = String COLCOL isEmpty ; Predicate < String > isNotEmpty = isEmpty . negate ( ) ; Function < String , Integer > toInteger = Integer COLCOL valueOf ; Function < String , String > backToString = toInteger . andThen ( String COLCOL valueOf ) ; backToString . apply ( "123" ) ; Supplier < Person > personSupplier = Person COLCOL new ; personSupplier . get ( ) ; Consumer < Person > greeter = ( p ) -> System . out . println ( "Hello  " + p . firstName ) ; greeter . accept ( new Person ( "Luke" , "Skywalker" ) ) ; Comparator < Person > comparator = ( p1 , p2 ) -> p1 . firstName . compareTo ( p2 . firstName ) ; Person p1 = new Person ( "John" , "Doe" ) ; Person p2 = new Person ( "Alice" , "Wonderland" ) ; comparator . compare ( p1 , p2 ) ; comparator . reversed ( ) . compare ( p1 , p2 ) ; Runnable runnable = ( ) -> System . out . println ( UUID . randomUUID ( ) ) ; runnable . run ( ) ; Callable < UUID > callable = UUID COLCOL randomUUID ; callable . call ( ) ; }
tr	4	public EpisodeMatch matchElementOrThrow ( Path path , MatchElement requiredMatch ) throws MatchElementNotFoundException { EpisodeMatch e = match ( path ) ; if ( e == null ) { return null ; } switch ( requiredMatch ) { case SHOW : assertHasShow ( e , path ) ; break ; case SEASON : assertHasSeason ( e , path ) ; break ; case ALL : assertHasShow ( e , path ) ; assertHasSeason ( e , path ) ; } return e ; }
tr	7	@ Override public void run ( ) { BufferedReader stdIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String userInput ; try { while ( ( ( userInput = stdIn . readLine ( ) ) != null ) && exit == false ) { if ( userInput . equals ( "!exit" ) ) { exit = true ; stdIn . close ( ) ; AuctionServer_ServerSocket . shutdown ( ) ; Main_AuctionServer . auctionServerExecutionService . shutdown ( ) ; try { if ( ! Main_AuctionServer . auctionServerExecutionService . awaitTermination ( 3 , TimeUnit . SECONDS ) ) { Main_AuctionServer . auctionServerExecutionService . shutdownNow ( ) ; if ( ! Main_AuctionServer . auctionServerExecutionService . awaitTermination ( 3 , TimeUnit . SECONDS ) ) System . err . println ( "Pool did not terminate" ) ; } } catch ( InterruptedException ie ) { Main_AuctionServer . auctionServerExecutionService . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } break ; } } } catch ( IOException e ) { System . out . println ( "Error: Failed to read from stdIn!" ) ; } }
tr	9	private void run ( ) { printHelp ( ) ; boolean quit = false ; while ( ! quit ) { String [ ] input = prompt ( ) ; input [ 0 ] = input [ 0 ] . trim ( ) . toLowerCase ( ) ; if ( input == null || input . length == 0 ) { continue ; } switch ( input [ 0 ] ) { case "ohje" : printHelp ( ) ; break ; case "lopeta" : quit = true ; break ; case "lataa" : load ( input ) ; break ; case "tallenna" : save ( input ) ; break ; case "uusi" : newFile ( ) ; break ; case "lisaa" : createCard ( ) ; break ; case "poista" : delete ( input ) ; break ; case "muokkaa" : edit ( input ) ; break ; case "etsi" : quickSearch ( input ) ; break ; case "tarkkahaku" : search ( ) ; break ; case "jarjesta" : orderData ( input ) ; break ; case "kaikki" : showAll ( ) ; break ; default : System . out . println ( "Syntaksivirhe" ) ; break ; } } }
tr	3	public static void main ( String [ ] args ) { SalariedEmployee salariedEmployee = new SalariedEmployee ( "John" , "Smith" , "111-11-1111" , 800.00 ) ; HourlyEmployee hourlyEmployee = new HourlyEmployee ( "Karen" , "Price" , "222-22-2222" , 16.75 , 40 ) ; CommissionEmployee commissionEmployee = new CommissionEmployee ( "Sue" , "Jones" , "333-33-3333" , 10000 , .06 ) ; BasePlusCommissionEmployee basePlusCommissionEmployee = new BasePlusCommissionEmployee ( "Bob" , "Lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; System . out . println ( "Employees processed individually:\n" ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , salariedEmployee , "earned" , salariedEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyEmployee , "earned" , hourlyEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , commissionEmployee , "earned" , commissionEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , basePlusCommissionEmployee , "earned" , basePlusCommissionEmployee . earnings ( ) ) ; Employee [ ] employees = new Employee [ 4 ] ; employees [ 0 ] = salariedEmployee ; employees [ 1 ] = hourlyEmployee ; employees [ 2 ] = commissionEmployee ; employees [ 3 ] = basePlusCommissionEmployee ; System . out . println ( "Employees processed polymorphically:\n" ) ; for ( Employee currentEmployee : employees ) { System . out . println ( currentEmployee ) ; if ( currentEmployee instanceof BasePlusCommissionEmployee ) { BasePlusCommissionEmployee employee = ( BasePlusCommissionEmployee ) currentEmployee ; employee . setBaseSalary ( 1.10 * employee . getBaseSalary ( ) ) ; System . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getBaseSalary ( ) ) ; } System . out . printf ( "earned $% .2f\n\n" , currentEmployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) System . out . printf ( "Employee %d is a %s\n" , j , employees [ j ] . getClass ( ) . getName ( ) ) ; }
tr	1	protected ASTNode maybeWrapInTerm ( ASTNode node ) { if ( node . getNodeCount ( ) == 1 ) { return node ; } return new TermNode ( node ) ; }
tr	3	@ Override public String toString ( ) { StringBuilder w = new StringBuilder ( ) ; w . append ( "[\n" ) ; int ioff = 0 ; int toff = 0 ; final int num = Math . max ( this . inputlength , this . targetlength ) ; for ( int i = 0 ; i < num ; i ++ ) { String sinput = "" ; String starget = "" ; if ( i < this . inputlength ) { sinput = DoubleTools . asString ( this . input , ioff , this . inputsize , 5 ) ; } if ( i < this . targetlength ) { starget = DoubleTools . asString ( this . target , toff , this . targetsize , 5 ) ; } w . append ( "\t[" + sinput + "] -> " + "[" + starget + "]\n" ) ; ioff += this . inputsize ; toff += this . targetsize ; } w . append ( "]\n" ) ; return w . toString ( ) ; }
tr	9	public static boolean process ( Connection dbConnection , FileTypeProcessReturnInfo returnVal , java . io . File source , java . io . File workingDir , List < ImageFormat > formats , ImageMagickFormat inputFormat , ImageMagickFormat outputFormat , File file , FileType outputFileType ) { BigInteger totalSize = BigInteger . ZERO ; for ( ImageFormat f : formats ) { logger . debug ( "Executing ImageMagick to process image file for source file with width " + f . w + " and height " + f . h + "." ) ; int exitVal = ImageProcessorHelper . renderImage ( inputFormat , outputFormat , source , f . outputFile , workingDir , f . w , f . h ) ; if ( exitVal != 0 ) { logger . warn ( "ImageMagick finished processing image but returned error code " + exitVal + "." ) ; returnVal . msg = "Error processing image." ; return false ; } totalSize . add ( new BigInteger ( "" + f . outputFile . length ( ) ) ) ; if ( FileHelper . isOverQuota ( totalSize ) ) { returnVal . msg = "Ran out of space." ; return false ; } } DbHelper . updateStatus ( dbConnection , file . getId ( ) , "Finalizing." , null ) ; ArrayList < OutputFile > outputFiles = new ArrayList < OutputFile > ( ) ; try { for ( ImageFormat f : formats ) { long size = f . outputFile . length ( ) ; logger . debug ( "Creating file record for render with height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO files (in_use created_at updated_at size file_type_id source_file_id heartbeat process_state) VALUES(0 ? ? ? ? ? ? 1)" , Statement . RETURN_GENERATED_KEYS ) ; s . setTimestamp ( 1 , currentTimestamp ) ; s . setTimestamp ( 2 , currentTimestamp ) ; s . setLong ( 3 , size ) ; s . setInt ( 4 , outputFileType . getObj ( ) . getId ( ) ) ; s . setInt ( 5 , file . getId ( ) ) ; s . setTimestamp ( 6 , currentTimestamp ) ; if ( s . executeUpdate ( ) != 1 ) { s . close ( ) ; logger . warn ( "Error occurred when creating database entry for a file." ) ; return false ; } ResultSet generatedKeys = s . getGeneratedKeys ( ) ; generatedKeys . next ( ) ; int id = generatedKeys . getInt ( 1 ) ; s . close ( ) ; File newFile = new File ( id , null , size , outputFileType . getObj ( ) ) ; logger . debug ( "File record created with id " + id + " for image render with width " + f . w + " and height " + f . h + " belonging to source file with id " + file . getId ( ) + "." ) ; if ( ! returnVal . registerNewFile ( newFile ) ) { logger . warn ( "Error trying to register newly created file." ) ; return false ; } ImageMagickFileInfo info = ImageMagickHelper . getFileInfo ( inputFormat , f . outputFile , workingDir ) ; if ( info == null ) { logger . warn ( "Error retrieving info for file rendered from source file with id " + file . getId ( ) + "." ) ; return false ; } outputFiles . add ( new OutputFile ( id , info . getW ( ) , info . getH ( ) ) ) ; logger . info ( "Moving output file with id " + id + " to web app..." ) ; if ( ! FileHelper . moveToWebApp ( f . outputFile , id ) ) { logger . error ( "Error trying to move output file with id " + id + " to web app." ) ; return false ; } logger . info ( "Output file with id " + id + " moved to web app." ) ; } } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to register files in database." ) ) ; } try { logger . debug ( "Creating entries in image_files table..." ) ; for ( OutputFile o : outputFiles ) { Timestamp currentTimestamp = new Timestamp ( System . currentTimeMillis ( ) ) ; PreparedStatement s = dbConnection . prepareStatement ( "INSERT INTO image_files (width height created_at updated_at file_id) VALUES (? ? ? ? ?)" ) ; s . setInt ( 1 , o . w ) ; s . setInt ( 2 , o . h ) ; s . setTimestamp ( 3 , currentTimestamp ) ; s . setTimestamp ( 4 , currentTimestamp ) ; s . setInt ( 5 , o . id ) ; int result = s . executeUpdate ( ) ; s . close ( ) ; if ( result != 1 ) { logger . debug ( "Error registering file with id " + o . id + " in image_files table." ) ; return false ; } logger . debug ( "Created entry in image_files table for file with id " + o . id + "." ) ; } logger . debug ( "Created entries in image_files table." ) ; } catch ( SQLException e ) { throw ( new RuntimeException ( "Error trying to create entries in image_files." ) ) ; } return true ; }
tr	8	public static boolean createExcel ( OutputStream os , String [ ] name , String [ ] [ ] datas ) { try { WritableWorkbook workbook = Workbook . createWorkbook ( os ) ; WritableSheet sheet = workbook . createSheet ( "Sheet1" , 0 ) ; WritableFont color = new WritableFont ( WritableFont . ARIAL ) ; color . setColour ( Colour . BLACK ) ; WritableCellFormat colorFormat = new WritableCellFormat ( color ) ; for ( int i = 0 ; i < name . length ; i ++ ) { Label columnname = new Label ( i , 0 , name [ i ] , colorFormat ) ; sheet . setColumnView ( i , 28 ) ; sheet . addCell ( columnname ) ; } WritableFont format = new WritableFont ( WritableFont . ARIAL ) ; format . setColour ( Colour . GRAY_50 ) ; WritableCellFormat Format = new WritableCellFormat ( format ) ; for ( int i = 0 ; i < datas . length ; i ++ ) { boolean Flag = false ; for ( int j = datas [ 1 ] . length - 1 ; j < datas [ 1 ] . length ; j ++ ) { if ( "1" . equals ( datas [ i ] [ j ] ) ) Flag = true ; else Flag = false ; } if ( Flag ) { for ( int j = 0 ; j < datas [ 1 ] . length - 1 ; j ++ ) { Label columnname = new Label ( j , i + 1 , datas [ i ] [ j ] , colorFormat ) ; sheet . addCell ( columnname ) ; } } else { for ( int j = 0 ; j < datas [ 1 ] . length - 1 ; j ++ ) { Label columnname = new Label ( j , i + 1 , datas [ i ] [ j ] , Format ) ; sheet . addCell ( columnname ) ; } } } workbook . write ( ) ; workbook . close ( ) ; os . flush ( ) ; os . close ( ) ; return true ; } catch ( Exception e ) { return false ; } }
tr	6	@ Override public void propertyChange ( final PropertyChangeEvent event ) { final String prop = event . getPropertyName ( ) ; if ( isVisible ( ) && event . getSource ( ) == contentPane && ( JOptionPane . VALUE_PROPERTY . equals ( prop ) || JOptionPane . INPUT_VALUE_PROPERTY . equals ( prop ) ) ) { final Object value = contentPane . getValue ( ) ; if ( value == JOptionPane . UNINITIALIZED_VALUE ) { return ; } contentPane . setValue ( JOptionPane . UNINITIALIZED_VALUE ) ; if ( value . equals ( MSG_OK ) ) { updateTimeslot ( ) ; } clearAndHide ( ) ; } }
tr	1	public static double dotProduct ( FeatureVector _x , double [ ] _y ) { double sum = 0 ; for ( int i = 0 ; i < _x . size ; ++ i ) sum += _x . va [ i ] * _y [ _x . x [ i ] ] ; return sum ; }
tr	1	@ Override public void setDataVector ( Vector newData , Vector columnNames ) { if ( newData == null ) { throw new IllegalArgumentException ( "setDataVector1() - Null parameter" ) ; } super . setDataVector ( dataVector , columnNames ) ; dataVector = newData ; attributiveModel = new DefaultCellAttribute ( dataVector . size ( ) , columnIdentifiers . size ( ) ) ; newRowsAdded ( new TableModelEvent ( this , 0 , getRowCount ( ) - 1 , TableModelEvent . ALL_COLUMNS , TableModelEvent . INSERT ) ) ; }
tr	9	private void processMainScreenClick ( ) { if ( minimapState != 0 ) return ; if ( super . clickMode3 == 1 ) { int i = super . saveClickX - 25 - 550 ; int j = super . saveClickY - 5 - 4 ; if ( i >= 0 && j >= 0 && i < 146 && j < 151 ) { i -= 73 ; j -= 75 ; int k = viewRotation + minimapRotation & 7ff ; int i1 = Texture . anIntArray1470 [ k ] ; int j1 = Texture . anIntArray1471 [ k ] ; i1 = i1 * ( minimapZoom + 256 ) >> 8 ; j1 = j1 * ( minimapZoom + 256 ) >> 8 ; int k1 = j * i1 + i * j1 >> 11 ; int l1 = j * j1 - i * i1 >> 11 ; int i2 = myPlayer . x + k1 >> 7 ; int j2 = myPlayer . y - l1 >> 7 ; boolean flag1 = doWalkTo ( 1 , 0 , 0 , 0 , myPlayer . smallY [ 0 ] , 0 , 0 , j2 , myPlayer . smallX [ 0 ] , true , i2 ) ; if ( flag1 ) { outStream1 . put ( i ) ; outStream1 . put ( j ) ; outStream1 . writeWord ( viewRotation ) ; outStream1 . put ( 57 ) ; outStream1 . put ( minimapRotation ) ; outStream1 . put ( minimapZoom ) ; outStream1 . put ( 89 ) ; outStream1 . writeWord ( myPlayer . x ) ; outStream1 . writeWord ( myPlayer . y ) ; outStream1 . put ( anInt1264 ) ; outStream1 . put ( 63 ) ; } } anInt1117 ++ ; if ( anInt1117 > 1151 ) { anInt1117 = 0 ; outStream1 . createFrame ( 246 ) ; outStream1 . put ( 0 ) ; int l = outStream1 . offset ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . put ( 101 ) ; outStream1 . put ( 197 ) ; outStream1 . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; outStream1 . put ( ( int ) ( Math . random ( ) * 256D ) ) ; outStream1 . put ( 67 ) ; outStream1 . writeWord ( 14214 ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . writeWord ( 29487 ) ; outStream1 . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) outStream1 . put ( 220 ) ; outStream1 . put ( 180 ) ; outStream1 . writeBytes ( outStream1 . offset - l ) ; } } }
tr	0	public boolean isEmpty ( ) { return this . first == null ; }
tr	0	public TaskID ( JobID jobID , TaskType taskType , int taskID , int taskAttemptID ) { this . jobID = jobID ; this . taskType = taskType ; this . taskID = taskID ; this . taskAttemptID = taskAttemptID ; this . ID = createID ( jobID , taskType , taskID , taskAttemptID ) ; }
tr	9	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	2	public static void insertarOrdenado ( int numero , int [ ] v ) { int [ ] resultado = new int [ v . length + 1 ] ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] >= numero ) { } } }
tr	4	public void onSessionStatusChanged ( O2GSessionStatusCode status ) { System . out . println ( "Status: " + status . toString ( ) ) ; switch ( status ) { case TRADING_SESSION_REQUESTED : if ( mSessionID . isEmpty ( ) ) { System . out . println ( "Argument for trading session ID is missing" ) ; } else { mSession . setTradingSession ( mSessionID , mPin ) ; } break ; case CONNECTED : mConnected = true ; mDisconnected = false ; mSemaphore . release ( ) ; break ; case DISCONNECTED : mConnected = false ; mDisconnected = true ; mSemaphore . release ( ) ; break ; } }
tr	0	public Dimension getSize ( ) { return this . size ; }
tr	9	public final ExpressaoContext expressao ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; ExpressaoContext _localctx = new ExpressaoContext ( _ctx , _parentState , _p ) ; ExpressaoContext _prevctx = _localctx ; int _startState = 6 ; enterRecursionRule ( _localctx , RULE_expressao ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 54 ) ; switch ( _input . LA ( 1 ) ) { case int : { _localctx = new InteiroContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 47 ) ; match ( int ) ; } break ; case 16 : { _localctx = new LeiaContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 48 ) ; match ( 16 ) ; } break ; case ID : { _localctx = new IdContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 49 ) ; match ( ID ) ; } break ; case 10 : { _localctx = new ExpParContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 50 ) ; match ( 10 ) ; setState ( 51 ) ; expressao ( 0 ) ; setState ( 52 ) ; match ( 2 ) ; } break ; default : throw new NoViableAltException ( this ) ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 67 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 65 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 3 , _ctx ) ) { case 1 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 56 ) ; if ( ! ( 4 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "4 >= $_p" ) ; setState ( 57 ) ; match ( 7 ) ; setState ( 58 ) ; expressao ( 5 ) ; } break ; case 2 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 59 ) ; if ( ! ( 3 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "3 >= $_p" ) ; setState ( 60 ) ; match ( 6 ) ; setState ( 61 ) ; expressao ( 4 ) ; } break ; case 3 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 62 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 63 ) ; match ( 8 ) ; setState ( 64 ) ; expressao ( 3 ) ; } break ; } } } setState ( 69 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
tr	8	public static void findLongestSubPalindramic ( String s ) { char [ ] arr = s . toCharArray ( ) ; int begin = - 1 ; int end ; int temp_begin ; int maxLength = - 1 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < table . length ; i ++ ) { table [ i ] [ i ] = true ; } for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; begin = i ; maxLength = 2 ; } } for ( int len = 2 ; len < arr . length ; len ++ ) { for ( int i = 0 ; i < arr . length - len + 1 ; i ++ ) { int j = len + i - 1 ; if ( table [ i + 1 ] [ j - 1 ] && ( arr [ i ] == arr [ j ] ) ) { table [ i ] [ j ] = true ; if ( j - i + 1 > maxLength ) { begin = i ; maxLength = maxLength + 2 ; } } } } System . out . println ( "begin:" + begin + "  length:" + maxLength ) ; }
tr	6	private void comparePackageParts ( TIPP p1 , TIPP p2 ) throws Exception { Collection < TIPPSection > s1 = p1 . getSections ( ) ; Collection < TIPPSection > s2 = p2 . getSections ( ) ; assertNotNull ( s1 ) ; assertNotNull ( s2 ) ; for ( TIPPSection s : s1 ) { TIPPSectionType type = s . getType ( ) ; List < ? extends TIPPFile > o1 = s . getFileResources ( ) ; TIPPSection _s = p2 . getSection ( type ) ; assertEquals ( s , _s ) ; List < ? extends TIPPFile > o2 = _s . getFileResources ( ) ; assertNotNull ( o1 ) ; assertNotNull ( o2 ) ; assertEquals ( o1 , o2 ) ; Iterator < ? extends TIPPFile > fit1 = o1 . iterator ( ) ; Iterator < ? extends TIPPFile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasNext ( ) ) { TIPPFile f1 = fit1 . next ( ) ; assertTrue ( fit2 . hasNext ( ) ) ; TIPPFile f2 = fit2 . next ( ) ; assertEquals ( f1 , f2 ) ; try ( InputStream is1 = p1 . getFile ( f1 ) ; InputStream is2 = p2 . getFile ( f2 ) ) { verifyBytes ( is1 , is2 ) ; } } } }
tr	8	private void buildMenu ( ) { jmbMenu = new JMenuBar ( ) ; JMenu jmFile = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.file" , "File" ) ) ; JMenuItem jmiConnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.connect" , "Connect" ) ) ; JMenuItem jmiDisconnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.disconnect" , "Disconnect" ) ) ; JMenuItem jmiOpen = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.openExisting" , "Open Existing" ) ) ; JMenuItem jmiRemove = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.remove" , "Remove Existing" ) ) ; JMenuItem jmiPrint = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.print" , "Print" ) ) ; JMenuItem jmiSave = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.save" , "Save As CSV" ) ) ; JMenuItem jmiExit = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.exit" , "Exit" ) ) ; jmFile . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.file.acc" , "f" ) ) . charAt ( 0 ) ) ; jmiConnect . addActionListener ( new File_New ( ) ) ; jmiDisconnect . addActionListener ( new File_Disconnect ( ) ) ; jmiOpen . addActionListener ( new File_Open ( this ) ) ; jmiRemove . addActionListener ( new File_Remove ( ) ) ; jmiPrint . addActionListener ( new File_Print ( ) ) ; jmiSave . addActionListener ( new File_Save ( ) ) ; jmiExit . addActionListener ( new File_Exit ( ) ) ; jmFile . add ( jmiConnect ) ; jmFile . add ( jmiDisconnect ) ; jmFile . add ( jmiOpen ) ; jmFile . add ( jmiRemove ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiPrint ) ; jmFile . add ( jmiSave ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiExit ) ; JMenu jmView = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.view" , "View" ) ) ; JMenuItem jmiConnections = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connections" ) ) ; JMenuItem jmiClients = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connected Clients" ) ) ; jmView . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.view.acc" , "v" ) ) . charAt ( 0 ) ) ; jmiConnections . addActionListener ( new View_Connections ( ) ) ; jmiClients . addActionListener ( new View_Clients ( ) ) ; jmView . add ( jmiConnections ) ; jmView . add ( jmiClients ) ; JMenu jmPrefs = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.preferences" , "Preferences" ) ) ; JMenu jmLnF = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.lnf" , "Look and Feel" ) ) ; JMenu jmLocale = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.locale" , "Locale" ) ) ; JMenu jmLogging = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.logging" , "Logging" ) ) ; JMenuItem jmiXSDDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.XSDDir" , "Set Schema Location" ) ) ; JMenuItem jmiLogDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.LogsDir" , "Set Log Directory" ) ) ; jmPrefs . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.preferences.acc" , "p" ) ) . charAt ( 0 ) ) ; UIManager . LookAndFeelInfo [ ] lafThisSystem = UIManager . getInstalledLookAndFeels ( ) ; ButtonGroup bgLnF = new ButtonGroup ( ) ; for ( int i = 0 ; i < lafThisSystem . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lafThisSystem [ i ] . getName ( ) ) ; jrbMI . addActionListener ( new Prefs_LnF ( lafThisSystem [ i ] . getClassName ( ) , this , mrbGui . getRBLocale ( ) ) ) ; if ( lafThisSystem [ i ] . getClassName ( ) . equals ( pGui . get ( "mars.lnf" , "javax.swing.plaf.metal.MetalLookAndFeel" ) ) ) { jrbMI . setSelected ( true ) ; } bgLnF . add ( jrbMI ) ; jmLnF . add ( jrbMI ) ; } String strNumOfLangs = mrbGui . getRBString ( "mars.locales.numberOfLocales" , "Unknown" ) ; Vector vecLangs = new Vector ( ) ; if ( strNumOfLangs . equals ( "Unknown" ) ) { vecLangs . add ( new String [ ] { "US English" , "en_US" } ) ; } else { Integer intLangAmount = new Integer ( strNumOfLangs ) ; for ( int i = 1 ; i <= intLangAmount . intValue ( ) ; i ++ ) { vecLangs . add ( new String [ ] { mrbGui . getRBString ( "mars.locales." + i , "US English" ) , mrbGui . getRBString ( "mars.locales.code." + i , "en_US" ) } ) ; } } String savedLocale = new String ( pGui . get ( "mars.locale.lang" , "en" ) + "_" + pGui . get ( "mars.locale.country" , "US" ) ) ; ButtonGroup bgLocale = new ButtonGroup ( ) ; for ( int i = 0 ; i < vecLangs . size ( ) ; i ++ ) { String [ ] lang = ( String [ ] ) vecLangs . get ( i ) ; JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lang [ 0 ] , new ImageIcon ( "images/" + lang [ 1 ] + ".png" ) ) ; jrbMI . addActionListener ( new Prefs_Locale ( lang [ 1 ] ) ) ; if ( lang [ 1 ] . equals ( savedLocale ) ) { jrbMI . setSelected ( true ) ; } bgLocale . add ( jrbMI ) ; jmLocale . add ( jrbMI ) ; } String [ ] strLog = new String [ ] { "Severe" , "Warning" , "Info" , "Config" , "Fine" , "Finer" , "Finest" , "All" , "Off" } ; ButtonGroup bgLogs = new ButtonGroup ( ) ; for ( int i = 0 ; i < strLog . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( strLog [ i ] ) ; jrbMI . addActionListener ( new Prefs_Logging ( strLog [ i ] ) ) ; if ( pGui . get ( "mars.logLevel" , "All" ) . equals ( strLog [ i ] ) ) { jrbMI . setSelected ( true ) ; } bgLogs . add ( jrbMI ) ; jmLogging . add ( jrbMI ) ; } jmiXSDDir . addActionListener ( new Prefs_SetDir ( "XSD" , this ) ) ; jmiLogDir . addActionListener ( new Prefs_SetDir ( "Log" , this ) ) ; jmPrefs . add ( jmLnF ) ; jmPrefs . add ( jmLocale ) ; jmPrefs . add ( jmLogging ) ; jmPrefs . add ( jmiXSDDir ) ; jmPrefs . add ( jmiLogDir ) ; JMenu jmWindow = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.window" , "Window" ) ) ; JMenuItem jmiTile = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.tile" , "Tile All" ) ) ; JMenuItem jmiCascade = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.cascade" , "Cascade" ) ) ; JMenuItem jmiMinimise = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.minimise" , "Minimise" ) ) ; jmWindow . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.window.acc" , "w" ) ) . charAt ( 0 ) ) ; jmiTile . addActionListener ( new Window_Tile ( ) ) ; jmiCascade . addActionListener ( new Window_Cascade ( ) ) ; jmiMinimise . addActionListener ( new Window_Minimise ( ) ) ; jmWindow . add ( jmiTile ) ; jmWindow . add ( jmiCascade ) ; jmWindow . add ( jmiMinimise ) ; JMenu jmHelp = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.help" , "Help" ) ) ; JMenuItem jmiAbout = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.about" , "About" ) ) ; JMenuItem jmiLicense = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.license" , "License" ) ) ; jmHelp . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.help.acc" , "h" ) ) . charAt ( 0 ) ) ; jmiAbout . addActionListener ( new Help_About ( ) ) ; jmiLicense . addActionListener ( new Help_License ( ) ) ; jmHelp . add ( jmiAbout ) ; jmHelp . add ( jmiLicense ) ; jmbMenu . add ( jmFile ) ; jmbMenu . add ( jmView ) ; jmbMenu . add ( jmPrefs ) ; jmbMenu . add ( jmWindow ) ; jmbMenu . add ( jmHelp ) ; }
tr	1	@ Override public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { Object item = value ; if ( item instanceof TipoIngreso ) { item = ( ( TipoIngreso ) item ) . getNombre ( ) ; } return super . getListCellRendererComponent ( list , item , index , isSelected , cellHasFocus ) ; }
tr	5	JavaExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mFonts = fonts ; mNoExampleButton = new JButton ( "Export Fonts" ) ; mExampleButton = new JButton ( "Export Fonts + Example Code" ) ; mCancelButton = new JButton ( "Cancel" ) ; mNoExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( false ) ; } } ) ; mExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( true ) ; } } ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; Font font = new Font ( "Verdana" , Font . BOLD , 18 ) ; for ( JButton b : new JButton [ ] { mNoExampleButton , mExampleButton , mCancelButton } ) { b . setFont ( font ) ; add ( b ) ; } setLayout ( new Layout ( ) ) ; mDialog = new JDialog ( ( Window ) parent , "Export Options" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 450 , 280 ) ; mDialog . setResizable ( false ) ; mDialog . setLocationRelativeTo ( parent ) ; mDialog . setVisible ( true ) ; }
tr	2	public void update ( String tabela , String colunasValores , int idParametro ) { PreparedStatement pstmt = null ; try { String query = "UPDATE " + tabela + " SET " + colunasValores + " WHERE registro_patrimonial = " + idParametro + "" ; if ( statement . executeUpdate ( query ) == 0 ) { JOptionPane . showMessageDialog ( null , "Erro  ocorreu algum problema ao tentar atualizar dados!" ) ; } else { } } catch ( SQLException sqlException ) { JOptionPane . showMessageDialog ( null , "Exce\u00E7\u00E3o SQL  " + sqlException . getMessage ( ) ) ; } }
tr	2	@ Test public void mustanSotilaanAskeltenMaaraLiikesuuntaanOikein ( ) { for ( Liikesuunta l : MustaSotilas . values ( ) ) { int [ ] [ ] s = l . suunnat ( ) ; assertEquals ( "Siirrot eiv\u00E4t ole kaksiulotteisia. HMM outoa!" , 2 , s . length ) ; assertEquals ( "Askeleita v\u00E4\u00E4r\u00E4 m\u00E4\u00E4r\u00E4 samaan suuntaan" + l , l . toString ( ) . equals ( "ALAS" ) ? 2 : 1 , s [ 0 ] . length ) ; } }
tr	8	public boolean Login ( ) throws ClassNotFoundException , SQLException { HttpSession ses ; ses = request . getSession ( false ) ; if ( ses == null || ses . getAttribute ( "username" ) == null ) { System . out . println ( "New Session Created" ) ; String username = request . getParameter ( "username" ) ; String password = request . getParameter ( "password" ) ; if ( username != null && password != null && ! username . equals ( "" ) && ! password . equals ( "" ) ) { PreparedStatement pstmt ; Connection conn = global . getConnection ( ) ; pstmt = ( PreparedStatement ) conn . prepareStatement ( "select * from student where student_id=? and password=MD5(?)" ) ; pstmt . setString ( 1 , username ) ; pstmt . setString ( 2 , password ) ; ResultSet rset = pstmt . executeQuery ( ) ; int count = 0 ; String uname = "" ; while ( rset . next ( ) ) { uname = rset . getString ( "student_id" ) ; count ++ ; } conn . close ( ) ; if ( count != 1 ) { return false ; } else { ses = request . getSession ( true ) ; ses . setAttribute ( "username" , uname ) ; return true ; } } else { return false ; } } else { return true ; } }
tr	4	public boolean boundaryCheck ( Point point ) { if ( ( point . x > 0 ) && point . x < width ) { if ( ( point . y > 0 ) && point . y < height ) { return true ; } } return false ; }
tr	2	public static BasicSingleton getInstance ( ) { if ( instance == null ) { synchronized ( BasicSingleton . class ) { if ( instance == null ) { instance = new BasicSingleton ( ) ; instance . increment ( ) ; } } } return instance ; }
tr	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	6	private boolean isPredictableResult ( ) { boolean commSet = true ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( this . communityCards [ i ] == null ) { commSet = false ; break ; } } if ( commSet ) { boolean correctPlayerTypes = false ; for ( PlayerProfile profile : this . profiles ) { if ( profile . getHandType ( ) != HandType . EXACTCARDS ) { correctPlayerTypes = true ; break ; } } if ( ! correctPlayerTypes ) { return true ; } } return false ; }
tr	2	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unset_success ( ) ; } else { set_success ( ( Integer ) value ) ; } break ; } }
tr	3	private static < T > void removeDuplicatesBuffer ( Node < T > list ) { if ( list == null ) { throw new IllegalArgumentException ( ) ; } Set < T > unique = new HashSet < T > ( ) ; unique . add ( list . getData ( ) ) ; while ( list . getNext ( ) != null ) { Node < T > current = list ; while ( unique . contains ( current . getNext ( ) . getData ( ) ) ) { current = current . getNext ( ) ; } unique . add ( current . getNext ( ) . getData ( ) ) ; list . setNext ( current . getNext ( ) ) ; list = list . getNext ( ) ; } }
tr	5	void setViewOffset ( int xofs , int yofs ) { if ( bg_defined == null ) return ; this . xofs = xofs ; this . yofs = yofs ; int oldtilexofs = tilexofs ; int oldtileyofs = tileyofs ; tilexofs = divFloor ( xofs , tilex ) - 1 ; tileyofs = divFloor ( yofs , tiley ) - 1 ; xofs_scaled = scaleXPos ( xofs , false ) ; yofs_scaled = scaleYPos ( yofs , false ) ; calcPFWrapCenter ( ) ; int maxtilexofs = Math . max ( tilexofs , oldtilexofs ) ; int maxtileyofs = Math . max ( tileyofs , oldtileyofs ) ; int mintilexofs = Math . min ( tilexofs , oldtilexofs ) ; int mintileyofs = Math . min ( tileyofs , oldtileyofs ) ; for ( int yi = mintileyofs ; yi < maxtileyofs ; yi ++ ) { for ( int xi = 0 ; xi < viewnrtilesx + 3 ; xi ++ ) { bg_defined [ xi ] [ moduloFloor ( yi , viewnrtilesy + 3 ) ] = false ; } } for ( int xi = mintilexofs ; xi < maxtilexofs ; xi ++ ) { for ( int yi = 0 ; yi < viewnrtilesy + 3 ; yi ++ ) { bg_defined [ moduloFloor ( xi , viewnrtilesx + 3 ) ] [ yi ] = false ; } } }
tr	5	public boolean inclusion ( Zone z ) { for ( int i = 0 ; i <= clockCount ; i ++ ) { for ( int j = 0 ; j <= clockCount ; j ++ ) { if ( zoneDataStruct [ i ] [ j ] [ 0 ] > z . getZoneDataStruct ( ) [ i ] [ j ] [ 0 ] ) return false ; if ( zoneDataStruct [ i ] [ j ] [ 0 ] == z . getZoneDataStruct ( ) [ i ] [ j ] [ 0 ] ) { if ( zoneDataStruct [ i ] [ j ] [ 1 ] > z . getZoneDataStruct ( ) [ i ] [ j ] [ 1 ] ) return false ; } } } return true ; }
tr	2	public void calLongestSnakeSequence ( ) { int n = A . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { } } }
tr	1	private AggregateRequest getAddMessage ( HTTPMessage msg , String addendum , boolean shouldMoveTo , TextBlob blob ) { AggregateRequest agg = new AggregateRequest ( ) ; AddRequest add = getAdd ( msg , addendum , shouldMoveTo ) ; add . setBlob ( blob ) ; agg . addRequest ( add ) ; HighlightRequest high = getHighlight ( ) ; if ( high != null ) { agg . addRequest ( high ) ; } return agg ; }
tr	1	public boolean offerFirst ( E e ) { if ( contains ( e ) ) { return false ; } linkFirst ( e ) ; return true ; }
tr	0	public void setfFirst ( int fFirst ) { this . fFirst = fFirst ; }
tr	0	@ Override public List < Apontamento > obterPorOrdemServico ( int ordemServicoId ) { return session . createQuery ( "from Apontamento where OrdemServicoId = :ordemServicoId" ) . setString ( "ordemServicoId" , String . valueOf ( ordemServicoId ) ) . list ( ) ; }
tr	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	0	public void setUserPhoto ( String userPhoto ) { this . userPhoto = userPhoto ; }
tr	4	public FrizzleFeatherGene ( String genotype ) { this . genotype = genotype ; switch ( genotype ) { case "FF" : phenotype = "Normal" ; break ; case "Ff" : case "fF" : phenotype = "Frizzle" ; break ; case "ff" : phenotype = "Curly" ; break ; default : } }
tr	9	public void setSnapToEdges ( final Component comp , final int dist ) { java . awt . event . ComponentListener snap = new java . awt . event . ComponentAdapter ( ) { @ Override public void componentMoved ( java . awt . event . ComponentEvent evt ) { Rectangle b = comp . getBounds ( ) , p = ( comp . getParent ( ) == null ? ge . getMaximumWindowBounds ( ) : comp . getParent ( ) . getBounds ( ) ) ; int bX = ( int ) b . getX ( ) , bY = ( int ) b . getY ( ) , bW = ( int ) b . getWidth ( ) , bH = ( int ) b . getHeight ( ) , pX = ( int ) p . getX ( ) , pY = ( int ) p . getY ( ) , pW = ( int ) p . getWidth ( ) , pH = ( int ) p . getHeight ( ) ; comp . setBounds ( ( bX <= dist + pX && bX >= pX - dist ) ? pX : ( bX + bW >= pW - dist && bX + bW <= pW + dist ? pW - bW : bX ) , ( bY <= dist + pY && bY >= pY - dist ) ? pY : ( bY + bH >= pH - dist && bY + bH <= pH + dist ? pH - bH : bY ) , bW , bH ) ; } } ; if ( dist != 0 ) { comp . addComponentListener ( snap ) ; } else { comp . removeComponentListener ( snap ) ; } }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	1	@ Override public void commit ( ) { if ( currentTransaction != null ) currentTransaction . commit ( ) ; }
tr	0	@ Override public void init ( Headquater hq ) { super . init ( hq ) ; sp = InsightShortestPath . require ( hq ) ; }
tr	4	private int AttemptDelete ( LinkedList < PlayerReinforcement > toDelete ) { boolean attemptRecovery = false ; try { getDatabase ( ) . delete ( toDelete ) ; } catch ( Exception ex ) { attemptRecovery = true ; Citadel . warning ( "DB mass delete failure: " + ex . toString ( ) ) ; } if ( ! attemptRecovery ) { return toDelete . size ( ) ; } ++ counterAttemptedDbDeleteRecoveries ; int successfulDeletes = 0 ; EbeanServer db = getDatabase ( ) ; for ( PlayerReinforcement pr : toDelete ) { try { db . delete ( pr ) ; ++ successfulDeletes ; } catch ( Exception ex ) { ++ counterDbDeleteFailures ; Citadel . severe ( "Attempted DB Delete recovery failed for: " + pr . toString ( ) ) ; Citadel . printStackTrace ( ex ) ; } } return successfulDeletes ; }
tr	9	@ SuppressWarnings ( "unchecked" ) private void addDirectory ( File directory , Map < String , Object > mapping ) { File [ ] files = directory . listFiles ( ) ; if ( files == null || files . length == 0 ) { return ; } for ( File file : files ) { if ( file . isHidden ( ) ) { continue ; } String name = file . getName ( ) ; if ( name . length ( ) == 0 ) { continue ; } String var = null ; if ( file . isFile ( ) ) { int index = name . lastIndexOf ( . ) ; if ( index > 0 ) { name = name . substring ( 0 , index ) ; } } if ( name . startsWith ( "${" ) ) { int index = name . indexOf ( } ) ; if ( index > 0 ) { var = name . substring ( 2 , index ) ; name = "$" ; } } Map < String , Object > map = ( Map < String , Object > ) mapping . get ( name ) ; if ( map == null ) { map = new HashMap < String , Object > ( ) ; mapping . put ( name , map ) ; } if ( var != null && var . length ( ) > 0 ) { map . put ( "." , var ) ; } if ( file . isDirectory ( ) ) { addDirectory ( file , map ) ; } } }
tr	1	public static String collectionToCommaDelimitedString ( Collection < ? > coll ) { return collectionToDelimitedString ( coll , " " ) ; }
tr	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 30 ; i ++ ) { for ( int j = 33 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 32 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 46 ; i <= 55 ; i ++ ) { for ( int j = 35 ; j <= 57 ; j ++ ) mapa [ j ] [ i ] = true ; } }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	9	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ 2000000 ] ; for ( int i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; int a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primeList . add ( a ) ; break ; } } long sum = 0 ; for ( int i = 0 ; i < primeList . size ( ) - 1 ; i ++ ) sum += lowestMultiple ( primeList . get ( i ) , primeList . get ( i + 1 ) ) ; System . out . println ( sum ) ; }
tr	4	public void setTurnedUpCard ( String cardID ) { char suit = cardID . charAt ( 1 ) ; switch ( suit ) { case d : { gameMessages . update ( "The trump suit for the round is DIAMONDS" ) ; } break ; case h : { gameMessages . update ( "The trump suit for the round is HEARTS" ) ; } break ; case s : { gameMessages . update ( "The trump suit for the round is SPADES" ) ; } break ; case c : { gameMessages . update ( "The trump suit for the round is CLUBS" ) ; } break ; } gameScreen . setTurnedUpCard ( cardID ) ; }
tr	1	public List < T > getList ( T [ ] x ) { List < T > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < x . length ; ++ i ) { l . add ( x [ i ] ) ; } return l ; }
tr	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	7	@ Test public void testEj2_e ( ) { final int max = 10 ; final Grafo grafo = new Grafo ( max ) ; for ( int i = 0 ; i < max ; i ++ ) grafo . agregarCiudad ( CIUDADES . get ( i ) ) ; final List < Vuelo > todosVuelos = new ArrayList < Vuelo > ( ) ; final Vuelo vuelo1 = new Vuelo ( CIUDADES . get ( 1 ) , CIUDADES . get ( 3 ) , 100 ) ; final Vuelo vuelo2 = new Vuelo ( CIUDADES . get ( 0 ) , CIUDADES . get ( 4 ) , 365 ) ; final Vuelo vuelo3 = new Vuelo ( CIUDADES . get ( 2 ) , CIUDADES . get ( 8 ) , 104 ) ; final Vuelo vuelo4 = new Vuelo ( CIUDADES . get ( 9 ) , CIUDADES . get ( 4 ) , 225 ) ; final Vuelo vuelo5 = new Vuelo ( CIUDADES . get ( 5 ) , CIUDADES . get ( 6 ) , 489 ) ; final Vuelo vuelo6 = new Vuelo ( CIUDADES . get ( 2 ) , CIUDADES . get ( 0 ) , 214 ) ; final Vuelo vuelo7 = new Vuelo ( CIUDADES . get ( 7 ) , CIUDADES . get ( 5 ) , 229 ) ; final Vuelo vuelo8 = new Vuelo ( CIUDADES . get ( 3 ) , CIUDADES . get ( 4 ) , 199 ) ; final Vuelo vuelo9 = new Vuelo ( CIUDADES . get ( 9 ) , CIUDADES . get ( 1 ) , 364 ) ; final int idCiudadAQuitar = 2 ; todosVuelos . add ( vuelo1 ) ; todosVuelos . add ( vuelo2 ) ; todosVuelos . add ( vuelo3 ) ; todosVuelos . add ( vuelo4 ) ; todosVuelos . add ( vuelo5 ) ; todosVuelos . add ( vuelo6 ) ; todosVuelos . add ( vuelo7 ) ; todosVuelos . add ( vuelo8 ) ; todosVuelos . add ( vuelo9 ) ; for ( int x = 0 ; x < todosVuelos . size ( ) ; x ++ ) grafo . agregarVuelo ( todosVuelos . get ( x ) ) ; List < Vuelo > esperadoVuelos = new ArrayList < Vuelo > ( ) ; for ( int x = 0 ; x < todosVuelos . size ( ) ; x ++ ) { Vuelo v = todosVuelos . get ( x ) ; if ( ! ( v . getCiudad1 ( ) . getIdentificador ( ) == idCiudadAQuitar || v . getCiudad2 ( ) . getIdentificador ( ) == idCiudadAQuitar ) ) { esperadoVuelos . add ( v ) ; } } grafo . eliminarCiudad ( CIUDADES . get ( idCiudadAQuitar - 1 ) ) ; final List < Ciudad > esperado = new ArrayList < Ciudad > ( ) ; for ( int x = 0 ; x < max ; x ++ ) if ( x != idCiudadAQuitar - 1 ) esperado . add ( CIUDADES . get ( x ) ) ; final List < Ciudad > actual = grafo . getCiudades ( ) ; assertEquals ( esperado , actual ) ; }
tr	5	private static String decimalToBinary ( double d ) { if ( d >= 1 || d <= 0 ) { return "ERROR" ; } StringBuilder result = new StringBuilder ( "0." ) ; while ( d > 0 ) { if ( result . length ( ) > 32 ) { return "ERROR" ; } double multiplied = d * 2 ; if ( multiplied >= 1 ) { result . append ( "1" ) ; d = multiplied - 1 ; } else { result . append ( "0" ) ; d = multiplied ; } } return result . toString ( ) ; }
tr	4	public static Map < String , List < String >> getAbbreviations ( Collection < String > names ) { Map < String , List < String >> abbrevs = new LinkedHashMap < String , List < String >> ( ) ; for ( String name : names ) { for ( int len = name . length ( ) - 1 ; len > 0 ; -- len ) { String abbrev = name . substring ( 0 , len ) ; if ( ! abbrevs . containsKey ( abbrev ) ) { abbrevs . put ( abbrev , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } else { abbrevs . get ( abbrev ) . add ( name ) ; } } } for ( String name : names ) { abbrevs . put ( name , new ArrayList < String > ( Arrays . asList ( name ) ) ) ; } return abbrevs ; }
tr	6	public void processDocument ( XmlPullParser xpp ) throws XmlPullParserException , IOException { int eventType = xpp . getEventType ( ) ; do { if ( eventType == XmlPullParser . START_DOCUMENT ) { System . out . println ( "Start document" ) ; } else if ( eventType == XmlPullParser . END_DOCUMENT ) { System . out . println ( "End document" ) ; } else if ( eventType == XmlPullParser . START_TAG ) { processStartElement ( xpp ) ; } else if ( eventType == XmlPullParser . END_TAG ) { processEndElement ( xpp ) ; } else if ( eventType == XmlPullParser . TEXT ) { processText ( xpp ) ; } eventType = xpp . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; }
tr	0	public JsonRegistry add ( Map < String , Object > json ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( file , true ) ) ; JsonGenerator jgen = JsonOutput . FACTORY . createJsonGenerator ( writer ) ; JsonOutput . MAPPER . writeValue ( jgen , json ) ; jgen . writeRawValue ( "\n" ) ; jgen . flush ( ) ; jgen . close ( ) ; writer . close ( ) ; return this ; }
tr	1	void addObject ( JGObject obj ) { int idx = objects . get ( obj . getName ( ) ) ; if ( idx >= 0 ) { JGObject old_obj = ( JGObject ) objects . values [ idx ] ; old_obj . removeDone ( ) ; old_obj . remove ( ) ; } objects . put ( obj . getName ( ) , obj ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RepeatStatementNode other = ( RepeatStatementNode ) obj ; if ( exp1 == null ) { if ( other . exp1 != null ) return false ; } else if ( ! exp1 . equals ( other . exp1 ) ) return false ; if ( stateSeq1 == null ) { if ( other . stateSeq1 != null ) return false ; } else if ( ! stateSeq1 . equals ( other . stateSeq1 ) ) return false ; return true ; }
tr	1	public synchronized boolean method234 ( int i , byte abyte0 [ ] , int j ) { boolean flag = method235 ( true , j , i , abyte0 ) ; if ( ! flag ) flag = method235 ( false , j , i , abyte0 ) ; return flag ; }
tr	0	private CcsContext load ( String name ) throws IOException { ImportResolver resolver = new ImportResolver ( ) { @ Override public InputStream resolve ( String uri ) { return getClass ( ) . getResourceAsStream ( "/" + uri ) ; } } ; return new CcsDomain ( ) . loadCcsStream ( resolver . resolve ( name ) , name , resolver ) . build ( ) ; }
tr	3	public int delete ( ) { if ( this . id < 0 ) { return - 1 ; } String SQL1 = "DELETE FROM faltasalumnos WHERE id=" + this . id + " LIMIT 1;" ; int nup = getSgd ( ) . executeUpdate ( SQL1 ) ; if ( nup > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "FaltasAlumnos" ) ; log . setDatos ( "id=" + this . id + ";" ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } if ( nup > 0 ) { SQL1 = "INSERT INTO faltasalumnos_deleted (idFaltasAlumnos  fechaModificado) " + " VALUES('" + getId ( ) + "' NOW())" ; nup += getSgd ( ) . executeUpdate ( SQL1 ) ; } this . id = - 1 ; return nup ; }
tr	6	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
tr	8	public static IntPair calculateMove ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { for ( Tuple item : movesToMake ) { if ( item . getWeight ( ) == 2 ) { AIDebuggingOutput . println ( "I'm smart  so I'm winning at " + item . getLocation ( ) . getX ( ) + " " + item . getLocation ( ) . getY ( ) ) ; return item . getLocation ( ) ; } } for ( Tuple item : movesToBlock ) { if ( item . getWeight ( ) == 2 ) { AIDebuggingOutput . println ( "I'm smart  so I'm blocking you at " + item . getLocation ( ) . getX ( ) + " " + item . getLocation ( ) . getY ( ) ) ; return item . getLocation ( ) ; } } Random rand = new Random ( ) ; int xIndex = rand . nextInt ( 7 ) ; int yIndex = 0 ; while ( b . getGameGridCircle ( xIndex , yIndex ) . getState ( ) != 0 ) { xIndex = ( xIndex + 1 ) % 7 ; } while ( ( yIndex != Board . numRows - 1 ) && ( b . getGameGridCircle ( xIndex , yIndex + 1 ) . getState ( ) == 0 ) ) { yIndex ++ ; if ( yIndex == Board . numRows - 1 ) { break ; } } AIDebuggingOutput . println ( "Hmm  I'm not sure so I'm guessing " + xIndex + " " + yIndex ) ; return new IntPair ( xIndex , yIndex ) ; }
tr	3	@ Override public void setInitialized ( short mask , float value ) { switch ( mask ) { case Constants . F_MASK : f = value ; break ; case Constants . X_MASK : x = value ; break ; case Constants . Y_MASK : y = value ; break ; default : break ; } }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } ClienteDao oClienteDAO = new ClienteDao ( ) ; int pages = oClienteDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "ClienteGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	6	private void removeEdges ( String vertexName ) { Vertex v = vertexMap . get ( vertexName ) ; for ( int i = 0 ; i < v . adj . size ( ) ; i ++ ) { Vertex u = v . adj . get ( i ) . dest ; int index = 0 ; for ( Edge e : u . adjEntering ) { if ( e . src . name . equals ( v . name ) ) { break ; } index ++ ; } u . adjEntering . remove ( index ) ; } for ( int i = 0 ; i < v . adjEntering . size ( ) ; i ++ ) { Vertex u = v . adjEntering . get ( i ) . src ; int index = 0 ; for ( Edge e : u . adj ) { if ( e . dest . name . equals ( v . name ) ) { break ; } index ++ ; } u . adj . remove ( index ) ; } v . adj . clear ( ) ; v . adjEntering . clear ( ) ; }
tr	2	public static boolean isSupported ( String protoName ) { for ( String s : pNames ) { if ( s . equals ( protoName ) ) return true ; } return false ; }
tr	7	private void loadFileData ( File modFile ) { try { Document doc = builder . build ( modFile ) ; Element rootNode = doc . getRootElement ( ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "ThingDef" ) ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . hasAttributes ( ) ) { if ( e . getAttribute ( "ParentName" ) == null ) { continue ; } if ( e . getAttributeValue ( "ParentName" ) . equals ( "BaseGun" ) || e . getAttributeValue ( "ParentName" ) . equals ( "BaseEquipment" ) ) { app . getWeaponHandler ( ) . createNewWeapon ( e . getChildText ( "label" ) , e . getChildText ( "defName" ) ) ; } } } } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
tr	0	@ ChattingAnnotation ( feature = "History" , type = "method" ) public String retriveChatHistory ( String sender ) { return _imp . retriveChatHistory ( sender ) ; }
tr	9	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	5	@ Override public void run ( ) { logger . info ( "Starting announce thread for " + torrent . getName ( ) + " to " + torrent . getAnnounceUrl ( ) + "..." ) ; this . interval = 5 ; this . initial = true ; while ( ! this . stop ) { this . announce ( this . initial ? AnnounceEvent . STARTED : AnnounceEvent . NONE ) ; try { logger . trace ( "Sending next announce in " + this . interval + " seconds." ) ; Thread . sleep ( this . interval * 1000 ) ; } catch ( InterruptedException ie ) { } } if ( ! this . forceStop ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ie ) { } this . announce ( AnnounceEvent . STOPPED , true ) ; } }
