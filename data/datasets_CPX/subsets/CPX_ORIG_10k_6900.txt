va	0	public int getDelay ( ) { return delay ; }
va	9	public Object getValueAt ( int row , int column ) { File file = files [ row ] ; switch ( column ) { case 0 : return fileSystemView . getSystemIcon ( file ) ; case 1 : return fileSystemView . getSystemDisplayName ( file ) ; case 2 : return file . getPath ( ) ; case 3 : return file . length ( ) ; case 4 : return file . lastModified ( ) ; case 5 : return file . canRead ( ) ; case 6 : return file . canWrite ( ) ; case 7 : return file . canExecute ( ) ; case 8 : return file . isDirectory ( ) ; case 9 : return file . isFile ( ) ; default : System . err . println ( "Logic Error" ) ; } return "" ; }
va	1	protected void clickEvent ( BIOSwitch c ) { if ( ! c . isEnabled ( ) ) { return ; } c . setSelected ( ! c . isSelected ( ) ) ; }
va	8	public static Pipe instantiatePipe ( String name , Datatype t , int lineN ) { switch ( t ) { case Bool : return new BoolPipe ( name ) ; case double : return new DoublePipe ( name ) ; case I16 : return new I16Pipe ( name ) ; case I32 : return new I32Pipe ( name ) ; case I64 : return new I64Pipe ( name ) ; case I8 : return new I8Pipe ( name ) ; case Single : return new SinglePipe ( name ) ; case String : return new StringPipe ( name ) ; default : ParseError . throwIf ( true , lineN , "Could not instantiate type " + t ) ; return null ; } }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ScopeDefinitionInteraction ) ) { return false ; } ScopeDefinitionInteraction other = ( ScopeDefinitionInteraction ) object ; if ( ( this . idScopeDefInteraction == null && other . idScopeDefInteraction != null ) || ( this . idScopeDefInteraction != null && ! this . idScopeDefInteraction . equals ( other . idScopeDefInteraction ) ) ) { return false ; } return true ; }
va	9	static void doubleQuickSort ( double a [ ] , int index [ ] , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; double mid ; if ( hi0 > lo0 ) { mid = a [ ( lo0 + hi0 ) / 2 ] ; while ( lo <= hi ) { while ( ( lo < hi0 ) && ( a [ lo ] < mid ) ) { ++ lo ; } while ( ( hi > lo0 ) && ( a [ hi ] > mid ) ) { -- hi ; } if ( lo <= hi ) { swap ( a , index , lo , hi ) ; ++ lo ; -- hi ; } } if ( lo0 < hi ) { doubleQuickSort ( a , index , lo0 , hi ) ; } if ( lo < hi0 ) { doubleQuickSort ( a , index , lo , hi0 ) ; } } }
va	4	public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . register ( new GameObject ( ) { private static final long serialVersionUID = 1 ; @ Override public void instantiate ( ) { setPosition ( new Vec2i ( 40 , 40 ) ) ; setImage ( "./src/GameBasics/bomb.png" ) ; addKeyListener ( new KeyListener ( ) { @ Override public void keyTyped ( KeyEvent e ) { } @ Override public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == 87 ) setPosition ( Vec2i . adder ( getPosition ( ) , new Vec2i ( 0 , - 1 ) ) ) ; if ( e . getKeyCode ( ) == 83 ) setPosition ( Vec2i . adder ( getPosition ( ) , new Vec2i ( 0 , 1 ) ) ) ; if ( e . getKeyCode ( ) == 65 ) setPosition ( Vec2i . adder ( getPosition ( ) , new Vec2i ( - 1 , 0 ) ) ) ; if ( e . getKeyCode ( ) == 68 ) setPosition ( Vec2i . adder ( getPosition ( ) , new Vec2i ( 1 , 0 ) ) ) ; repaint ( ) ; } @ Override public void keyReleased ( KeyEvent e ) { } } ) ; repaint ( ) ; } } ) ; }
va	1	public static Poseur getPoseur ( ) { if ( singleton == null ) { singleton = new Poseur ( ) ; } return singleton ; }
va	1	public void guardarArchivoLocal ( ) { try { FileOutputStream fileOut = new FileOutputStream ( "configLocal.txt" ) ; ObjectOutputStream out = new ObjectOutputStream ( fileOut ) ; out . writeObject ( configLocal ) ; out . close ( ) ; fileOut . close ( ) ; System . out . printf ( "Serialized data is saved in configLocal.txt" ) ; } catch ( IOException i ) { i . printStackTrace ( ) ; } }
va	5	@ Override public Symbol invoke ( Symbol self , Parser p ) throws ParseException { switch ( self . token . type ( ) ) { case ID : self . type = self . proto . type ; self . lval = instance ; break ; case char : self . type = new PlainOldTypeResolver ( Type . charType ) ; break ; case GolemLexer . int : self . type = new PlainOldTypeResolver ( Type . intType ) ; break ; case float : self . type = new PlainOldTypeResolver ( Type . floatType ) ; break ; case STRING : self . type = new PlainOldTypeResolver ( Type . javalangStringType ) ; break ; default : self . type = new PlainOldTypeResolver ( Type . errorType ) ; break ; } self . rval = instance ; return self ; }
va	8	public static void main ( String [ ] args ) { QuadraticProbingHashTable < String > H = new QuadraticProbingHashTable < > ( ) ; long startTime = System . currentTimeMillis ( ) ; final int NUMS = 2000000 ; final int GAP = 37 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) H . insert ( "" + i ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) if ( H . insert ( "" + i ) ) System . out . println ( "OOPS!!! " + i ) ; for ( int i = 1 ; i < NUMS ; i += 2 ) H . remove ( "" + i ) ; for ( int i = 2 ; i < NUMS ; i += 2 ) if ( ! H . contains ( "" + i ) ) System . out . println ( "Find fails " + i ) ; for ( int i = 1 ; i < NUMS ; i += 2 ) { if ( H . contains ( "" + i ) ) System . out . println ( "OOPS!!! " + i ) ; } long endTime = System . currentTimeMillis ( ) ; System . out . println ( "Elapsed time: " + ( endTime - startTime ) ) ; System . out . println ( "H size is: " + H . size ( ) ) ; System . out . println ( "Array size is: " + H . capacity ( ) ) ; }
va	7	public static void applySpikeDamage ( Team team ) { int spikeCount = team . getSpikesCount ( ) ; Pokemon poke = team . getActivePokemon ( ) ; if ( team . hasSpikes ( ) && ! poke . getAbility ( ) . equals ( Ability . LEVITATE ) && ! poke . isType ( Type . FLYING ) && ! poke . getAbility ( ) . equals ( Ability . MAGIC_GUARD ) ) { if ( spikeCount == 1 ) { PokemonMath . applyFractionalDamage ( poke , PokemonMath . ONE_EIGHTH ) ; } else if ( spikeCount == 2 ) { PokemonMath . applyFractionalDamage ( poke , PokemonMath . ONE_SIXTH ) ; } else if ( spikeCount == 3 ) { PokemonMath . applyFractionalDamage ( poke , PokemonMath . ONE_QUARTER ) ; } } }
va	2	public static Deletion dd ( Deletion d1 , Deletion d2 ) { StateVector vec = d1 . getStateVec ( ) ; int p1 = d1 . getPos ( ) , p2 = d2 . getPos ( ) ; if ( p1 < p2 ) return d1 ; else if ( p1 > p2 ) return new Deletion ( vec , p1 - 1 ) ; else return null ; }
va	7	private List < Organisation > processDataConsumers ( StartElement se , XMLEventReader eventReader ) throws XMLStreamException , ExternalRefrenceNotFoundException { List < Organisation > dataConsumers = new ArrayList < Organisation > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "DataConsumer" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { Organisation o = processOrganisation ( se , eventReader , "DataConsumer" ) ; dataConsumers . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "DataConsumers" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { endTagReached = true ; } } } return dataConsumers ; }
va	1	MainExceptions ( ) { try { System . out . println ( divideByZero ( ) ) ; } catch ( Exception e ) { System . out . println ( "not  devide 0" ) ; } }
va	9	public String readToPattern ( String pattern ) throws IOException { StringBuffer buffer = new StringBuffer ( ) ; int ch = pattern . charAt ( 0 ) ; int length = pattern . length ( ) ; while ( true ) { int next = peek ( ) ; if ( next == - 1 ) { if ( buffer . length ( ) > 0 ) { return buffer . toString ( ) ; } return null ; } if ( next == ch ) { if ( length == 1 ) { if ( buffer . length ( ) > 0 ) { return buffer . toString ( ) ; } return null ; } else { int [ ] peekBuffer = new int [ length ] ; peek ( peekBuffer ) ; boolean match = true ; for ( int i = 1 ; i < length ; i ++ ) { if ( peekBuffer [ i ] != pattern . charAt ( i ) ) { match = false ; break ; } } if ( match ) { if ( buffer . length ( ) > 0 ) { return buffer . toString ( ) ; } return null ; } } } buffer . append ( ( char ) read ( ) ) ; } }
va	9	public boolean validateSeatNumbers ( ShowTime showTime , String [ ] seats ) { Seat seat = null ; boolean [ ] [ ] coupleSeatTracker = new boolean [ 3 ] [ 8 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { coupleSeatTracker [ i ] [ j ] = false ; } } Cinema cinema = showTime . getCinema ( ) ; for ( String s : seats ) { String seatRow = s . charAt ( 0 ) + "" ; int seatNo = Integer . parseInt ( s . substring ( 1 , s . length ( ) ) ) ; for ( Seat _seat : cinema . getSeats ( ) ) { if ( _seat . getSeatNo ( ) == seatNo && _seat . getSeatRow ( ) . equals ( seatRow ) ) { seat = _seat ; break ; } } if ( seat == null ) { return false ; } else if ( seat . isOccupiedAt ( showTime ) ) { return false ; } else if ( seatRow . equals ( "A" ) || seatRow . equals ( "B" ) ) { coupleSeatTracker [ seatRow . charAt ( 0 ) - A ] [ seatNo - 1 ] = true ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 8 ; j += 2 ) { if ( coupleSeatTracker [ i ] [ j ] == ! coupleSeatTracker [ i ] [ j + 1 ] ) { return false ; } } } return true ; }
va	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : case B : case C : System . out . println ( "Passes" ) ; break ; case D : case F : System . out . println ( "Fail" ) ; break ; default : System . out . println ( "Invalid" ) ; break ; } }
va	3	public PeerId ( String string ) { if ( string == null ) { throw new NullPointerException ( ) ; } if ( string . length ( ) != 20 ) { throw new IllegalArgumentException ( ) ; } this . bytes = string . getBytes ( ISO_8859_1 ) ; this . string = string ; this . hash = Arrays . hashCode ( bytes ) ; try { urlEncodedString = URLEncoder . encode ( string , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } }
va	9	public LUdcmp ( final double [ ] [ ] a ) throws NRException { n = ( nrows ( a ) ) ; lu = doub_mat ( a ) ; aref = doub_mat ( a ) ; indx = int_vec ( n ) ; final double TINY = 1.0e-40 ; int i , imax = 0 , j , k ; double big , temp ; final double [ ] vv = doub_vec ( n ) ; d = 1.0 ; for ( i = 0 ; i < n ; i ++ ) { big = 0.0 ; for ( j = 0 ; j < n ; j ++ ) if ( ( temp = abs ( lu [ i ] [ j ] ) ) > big ) big = temp ; if ( big == 0.0 ) throw new NRException ( "Singular matrix in LUdcmp" ) ; vv [ i ] = 1.0 / big ; } for ( k = 0 ; k < n ; k ++ ) { big = 0.0 ; for ( i = k ; i < n ; i ++ ) { temp = vv [ i ] * abs ( lu [ i ] [ k ] ) ; if ( temp > big ) { big = temp ; imax = i ; } } if ( k != imax ) { for ( j = 0 ; j < n ; j ++ ) { temp = lu [ imax ] [ j ] ; lu [ imax ] [ j ] = lu [ k ] [ j ] ; lu [ k ] [ j ] = temp ; } d = - d ; vv [ imax ] = vv [ k ] ; } indx [ k ] = imax ; if ( lu [ k ] [ k ] == 0.0 ) lu [ k ] [ k ] = TINY ; for ( i = k + 1 ; i < n ; i ++ ) { temp = lu [ i ] [ k ] /= lu [ k ] [ k ] ; for ( j = k + 1 ; j < n ; j ++ ) lu [ i ] [ j ] -= temp * lu [ k ] [ j ] ; } } }
va	0	public SearchResult getSearchResult ( final Document document ) { final Map < String , double > projectedScores = this . indexMap . projectScores ( document . getScoreValues ( ) ) ; return new SearchResult ( document . getId ( ) , document . getPayload ( ) , projectedScores ) ; }
va	8	public Handle open ( Credential cr , int mode ) { Handle hdl = super . open ( cr , mode ) ; if ( hdl . rc != Handle . RC_OK ) return hdl ; String fMode = "r" ; if ( hdl . forWrite ) fMode = "rw" ; java . io . File f = new java . io . File ( fileName ) ; if ( ( hdl . forRead && ! f . canRead ( ) ) || ( hdl . forWrite && ! f . canWrite ( ) ) ) { inUse -- ; hdl . rc = Handle . RC_NO_PERMISSION ; return hdl ; } DiskHandle dHdl = new DiskHandle ( ) ; dHdl . forRead = hdl . forRead ; dHdl . forWrite = hdl . forWrite ; try { dHdl . rc = Handle . RC_OK ; dHdl . file = new RandomAccessFile ( f , fMode ) ; if ( ( mode & Permissions . OTRUNC ) != 0 ) dHdl . file . setLength ( 0 ) ; fileSize = dHdl . file . length ( ) ; } catch ( Exception e ) { hdl . rc = Handle . RC_NO_SUCH_FILE ; inUse -- ; return hdl ; } return dHdl ; }
va	1	public static void example7 ( ) { WorldSet myWorld = new WorldSet ( ) ; myWorld . addFormula ( a . e . EMPTY_FORMULA ) ; DefaultRule rule1 = new DefaultRule ( ) ; rule1 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule1 . setJustificatoin ( "C" ) ; rule1 . setConsequence ( "~D" ) ; DefaultRule rule2 = new DefaultRule ( ) ; rule2 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule2 . setJustificatoin ( "D" ) ; rule2 . setConsequence ( "~E" ) ; DefaultRule rule3 = new DefaultRule ( ) ; rule3 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule3 . setJustificatoin ( "E" ) ; rule3 . setConsequence ( "~F" ) ; RuleSet myRules = new RuleSet ( ) ; myRules . addRule ( rule1 ) ; myRules . addRule ( rule2 ) ; myRules . addRule ( rule3 ) ; DefaultReasoner loader = new DefaultReasoner ( myWorld , myRules ) ; HashSet < String > extensions = loader . getPossibleScenarios ( ) ; a . e . println ( "Given the world: \n\t" + myWorld . toString ( ) + "\n And the rules \n\t" + myRules . toString ( ) ) ; a . e . println ( "Possible Extensions" ) ; for ( String c : extensions ) { a . e . println ( "\t Ext: Th(W U (" + c + "))" ) ; } }
va	6	public boolean removePermission ( String world , String permission ) { if ( world == null ) { if ( globalPermissions != null && globalPermissions . containsKey ( permission ) ) { globalPermissions . remove ( permission ) ; dirty = true ; return true ; } return false ; } if ( permissions == null ) { return false ; } Map < String , boolean > permArray = permissions . get ( Config . getRealWorld ( world ) . toLowerCase ( ) ) ; if ( permArray == null ) { permArray = new LinkedHashMap < String , boolean > ( ) ; permissions . put ( Config . getRealWorld ( world ) . toLowerCase ( ) , permArray ) ; } if ( permArray . containsKey ( permission ) ) { permArray . remove ( permission ) ; dirty = true ; return true ; } return false ; }
va	3	private boolean esConsistente ( Nodo nodo ) { if ( nodo == null || nodo . siguiente == null ) return true ; else { if ( nodo . siguiente . dato > nodo . dato ) return esConsistente ( nodo . siguiente ) ; else return false ; } }
va	1	protected byte [ ] getVariableHeader ( ) throws MqttException { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; dos . writeShort ( msgId ) ; dos . flush ( ) ; return baos . toByteArray ( ) ; } catch ( IOException ex ) { throw new MqttException ( ex ) ; } }
va	7	public ArithmeticalOperator createOperator ( char operation , ArithmeticalOperator right , ArithmeticalOperator left ) { ArithmeticalOperator operator = null ; switch ( operation ) { case SyntaxArithmeticReader . + : operator = new OperatorPlus ( left , right ) ; break ; case SyntaxArithmeticReader . MINUS : operator = new OperatorMinus ( left , right ) ; break ; case SyntaxArithmeticReader . MULTIPLY : operator = new OperatorMultiply ( left , right ) ; break ; case SyntaxArithmeticReader . DIVIDE : operator = new OperatorDivide ( left , right ) ; break ; case SyntaxArithmeticReader . EXPONENT : operator = new OperatorPower ( left , right ) ; break ; case SyntaxArithmeticReader . ROOT : operator = new OperatorRoot ( left , right ) ; break ; default : break ; } if ( operator == null ) { throw new BadSintaxException ( "Error: no se conoce el caracter \"" + operation + "\"" ) ; } return operator ; }
va	9	public static void copyFile ( File source , File target , boolean isReadOnly ) throws Exception { if ( ! source . exists ( ) ) { throw new Exception ( "File not found: " + source ) ; } if ( source . equals ( target ) ) { throw new Exception ( "Cannot copy file to itself: " + source ) ; } if ( ! source . canRead ( ) ) { throw new Exception ( "Cannot read file: " + source ) ; } File parent = target . getParentFile ( ) ; if ( ! parent . exists ( ) ) { throw new Exception ( "Directory not found: " + parent ) ; } if ( ! parent . canWrite ( ) ) { throw new Exception ( "Cannot create file: " + target ) ; } if ( target . exists ( ) ) { target . delete ( ) ; } try { createFile ( target ) ; FileInputStream in = new FileInputStream ( source ) ; try { FileOutputStream out = new FileOutputStream ( target ) ; try { copyData ( in , out ) ; } finally { if ( out != null ) { out . close ( ) ; } } } finally { if ( in != null ) { in . close ( ) ; } } } catch ( Exception e ) { throw new Exception ( "Copying file failed: " + source + " => " + target , e ) ; } if ( source . length ( ) != target . length ( ) ) { throw new Exception ( "Source and target file have different length!" ) ; } if ( ! target . exists ( ) ) { throw new Exception ( "Copying file failed: " + source + " => " + target ) ; } if ( isReadOnly ) { target . setReadOnly ( ) ; } }
va	7	public static void setupmidi ( ) { try { theSequencer = MidiSystem . getSequencer ( true ) ; try { theSequencer . addMetaEventListener ( new MetaEventListener ( ) { public void meta ( MetaMessage msg ) { if ( msg . getType ( ) == metaEndTrack ) { endSequence ( true ) ; } if ( msg . getType ( ) == metaCuePoint ) { byte [ ] bmsg = msg . getData ( ) ; String smsg = new String ( bmsg ) ; if ( smsg . startsWith ( "on:" ) ) { int note = Integer . parseInt ( smsg . substring ( 3 ) ) ; kbPanel . setSeqNote ( note , true ) ; } if ( smsg . startsWith ( "off:" ) ) { int note = Integer . parseInt ( smsg . substring ( 4 ) ) ; kbPanel . setSeqNote ( note , false ) ; } } } } ) ; } catch ( Exception ea ) { } theSequencer . open ( ) ; } catch ( Exception e ) { displayerror ( "Dang! Couldn't get a sequencer!  " + e . toString ( ) ) ; } ArrayList < String > thePrograms = kbPanel . getPrograms ( ) ; for ( String program : thePrograms ) { jProgram . addItem ( program ) ; } jProgram . setSelectedIndex ( defaultprogram ) ; kbPanel . setProgram ( defaultprogram ) ; changeLiveTuning ( ) ; }
va	3	private void reprocessRequirementElement ( RequirementElement elem ) { if ( elem . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { elem . setRemark ( InfoEnum . ElementRemark . REFINEUM . name ( ) ) ; if ( elem . getOutLinks ( ) . size ( ) != 1 ) { CommandPanel . logger . severe ( "and_refine link processing error" ) ; } else { RequirementElement target = elem . getOutLinks ( ) . getFirst ( ) . getTarget ( ) ; for ( RequirementLink l : elem . getInLinks ( ) ) { l . setTarget ( target ) ; target . and_refine_links . add ( l ) ; } } return ; } }
va	4	public Material setAmbient ( double r , double g , double b ) { if ( r != ambient [ 0 ] || g != ambient [ 1 ] || b != ambient [ 2 ] || isSrcUpdate ( ) ) { ambient [ 0 ] = r ; ambient [ 1 ] = g ; ambient [ 2 ] = b ; recache ( ) ; } return this ; }
va	4	public String getApiInfo ( ) throws IOException , HTTPException { HttpURLConnection con = null ; con = ( HttpURLConnection ) this . sc . getURL ( "/api/info/" ) . openConnection ( ) ; con . setRequestMethod ( ServerConnector . GET ) ; con . setRequestProperty ( "Accept-Encoding" , "gzip" ) ; con . setDoInput ( true ) ; InputStream is = null ; StringBuilder sb = new StringBuilder ( ) ; try { con . connect ( ) ; if ( con . getResponseCode ( ) != 200 ) { throw new HTTPException ( con . getResponseCode ( ) , ServerConnector . HTTP_UNKNOWN ) ; } is = new GZIPInputStream ( con . getInputStream ( ) ) ; int c ; while ( ( c = is . read ( ) ) != - 1 ) { sb . append ( ( char ) c ) ; } } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ignore ) { } con . disconnect ( ) ; } return sb . toString ( ) ; }
va	0	public GrainBillTM ( ) { myData = new ArrayList < FermentableAdditionType . Addition > ( ) ; }
va	9	@ Override public void run ( ) throws Exception { try { BufferedReader console = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ConfigManager config = NetBase . theNetBase ( ) . config ( ) ; String server = config . getProperty ( "net.server.ip" ) ; if ( server == null ) { System . out . print ( "Enter a host ip  or exit to exit: " ) ; server = console . readLine ( ) ; if ( server == null ) return ; if ( server . equals ( "exit" ) ) return ; } int basePort = config . getAsInt ( "dataxferraw.server.baseport" , - 1 ) ; if ( basePort == - 1 ) { System . out . print ( "Enter port number  or empty line to exit: " ) ; String portStr = console . readLine ( ) ; if ( portStr == null || portStr . trim ( ) . isEmpty ( ) ) return ; basePort = Integer . parseInt ( portStr ) ; } int socketTimeout = config . getAsInt ( "net.timeout.socket" , - 1 ) ; if ( socketTimeout < 0 ) { System . out . print ( "Enter socket timeout (in msec.): " ) ; String timeoutStr = console . readLine ( ) ; socketTimeout = Integer . parseInt ( timeoutStr ) ; } System . out . print ( "Enter number of trials: " ) ; String trialStr = console . readLine ( ) ; int nTrials = Integer . parseInt ( trialStr ) ; for ( int index = 0 ; index < DataXferRawService . NPORTS ; index ++ ) { TransferRate . clear ( ) ; int port = basePort + index ; int xferLength = DataXferRawService . XFERSIZE [ index ] ; System . out . println ( "\n" + xferLength + " bytes" ) ; TransferRateInterval tcpStats = DataXferRate ( DataXferServiceBase . HEADER_STR , server , port , socketTimeout , xferLength , nTrials ) ; System . out . println ( "\nTCP: xfer rate = " + String . format ( "%9.0f" , tcpStats . mean ( ) * 1000.0 ) + " bytes/sec." ) ; System . out . println ( "TCP: failure rate = " + String . format ( "%5.1f" , tcpStats . failureRate ( ) ) + " [" + tcpStats . nAborted ( ) + "/" + tcpStats . nTrials ( ) + "]" ) ; } } catch ( Exception e ) { System . out . println ( "Unanticipated exception: " + e . getMessage ( ) ) ; } }
va	5	public Tile ( int x , int y , int typeInt ) { tileX = x * 40 ; tileY = y * 40 ; type = typeInt ; tileBoundary = new Rectangle ( 0 , 0 , 0 , 0 ) ; if ( type == DIRT ) { tileImage = ( ( AssetImage ) Assets . instance ( ) . get ( AssetType . TILE_DIRT ) ) . getImage ( ) ; } else if ( type == GROUND ) { tileImage = ( ( AssetImage ) Assets . instance ( ) . get ( AssetType . TILE_GRASS_TOP ) ) . getImage ( ) ; } else if ( type == LEFT_GROUND ) { tileImage = ( ( AssetImage ) Assets . instance ( ) . get ( AssetType . TILE_GRASS_LEFT ) ) . getImage ( ) ; } else if ( type == RIGHT_GROUND ) { tileImage = ( ( AssetImage ) Assets . instance ( ) . get ( AssetType . TILE_GRASS_RIGHT ) ) . getImage ( ) ; } else if ( type == CEILING ) { tileImage = ( ( AssetImage ) Assets . instance ( ) . get ( AssetType . TILE_GRASS_BOT ) ) . getImage ( ) ; } else { type = 0 ; } }
va	2	public AStarPathFinder ( MapDataProvider map ) { assert map != null ; this . map = map ; Dimension size = map . getSize ( ) ; nodes = new Node [ size . width ] [ size . height ] ; for ( int y = 0 ; y < size . height ; y ++ ) { for ( int x = 0 ; x < size . width ; x ++ ) { nodes [ x ] [ y ] = new Node ( x , y ) ; } } }
va	5	int fillNextSeq ( int curUnfit , ArrayList < HtWt > nextSeq ) { boolean flag = true ; int nextUnfit = curUnfit ; LinkedList < HtWt > ns = new LinkedList < HtWt > ( ) ; ns . add ( items . get ( curUnfit ) ) ; int nextWeight = items . get ( curUnfit ) . weight ; for ( int i = curUnfit - 1 ; i >= 0 ; i -- ) { if ( items . get ( i ) . weight < nextWeight ) { ns . addFirst ( items . get ( i ) ) ; nextWeight = items . get ( i ) . weight ; } } int prevWeight = items . get ( curUnfit ) . weight ; for ( int j = curUnfit + 1 ; j < items . size ( ) ; j ++ ) { if ( items . get ( j ) . weight > prevWeight ) { ns . add ( items . get ( j ) ) ; prevWeight = items . get ( j ) . weight ; } else if ( flag == true ) { nextUnfit = j ; System . out . println ( "unfit:" + items . get ( j ) . weight ) ; flag = false ; } } nextSeq . addAll ( ns ) ; return nextUnfit ; }
va	6	public boolean getBoolean ( int index ) throws JSONException { Object o = get ( index ) ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a Boolean." ) ; }
va	3	private Properties NewProperties ( String params ) { Properties userServiceSearch = new Properties ( ) ; if ( params != null && ! params . equals ( "" ) ) { String serviceInfo [ ] = params . split ( "\\&" ) ; for ( int i = 0 ; i < serviceInfo . length ; i ++ ) { String param [ ] = serviceInfo [ i ] . split ( "=" ) ; int name = 0 , value = 1 ; userServiceSearch . setProperty ( param [ name ] , param [ value ] ) ; } } return userServiceSearch ; }
va	1	public static byte [ ] hexStringToBytes ( String hex ) { int len = hex . length ( ) ; byte [ ] bytes = new byte [ ( len + 1 ) / 3 ] ; for ( int i = 0 ; i < len ; i += 3 ) { bytes [ i / 3 ] = ( byte ) ( ( Character . digit ( hex . charAt ( i ) , 16 ) << 4 ) + Character . digit ( hex . charAt ( i + 1 ) , 16 ) ) ; } return bytes ; }
va	4	public int numTrees ( int n , int m , int result ) { if ( m == 0 ) { return 0 ; } if ( m == 1 ) { return 1 ; } if ( m == 2 ) { return 2 ; } while ( m > 2 ) { -- m ; } return result ; }
va	3	public void get ( final int questionNumber ) { final Database connect = new Database ( _databaseName ) ; final Hashtable < enum < ? > , Object > vals = new Hashtable < enum < ? > , Object > ( ) ; vals . put ( Column . QUESTION_NUMBER , "" + questionNumber ) ; final ResultSet rs = connect . select ( TABLE_NAME , vals ) ; try { _type = Type . valueOf ( rs . getString ( Column . TYPE . toString ( ) ) ) ; _show = boolean . parseBoolean ( rs . getString ( Column . SHOW . toString ( ) ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } connect . disconnect ( ) ; final DatabaseStatistics ds = new DatabaseStatistics ( _databaseName ) ; _statistics = ds . get ( questionNumber ) ; final DatabaseLocation dl = new DatabaseLocation ( _databaseName ) ; _location = dl . get ( questionNumber ) ; }
va	4	private void setupForDragging ( MouseEvent me ) { source . addMouseMotionListener ( this ) ; potentialDrag = true ; if ( destinationComponent != null ) { destination = destinationComponent ; } else if ( destinationClass == null ) { destination = source ; } else { destination = SwingUtilities . getAncestorOfClass ( destinationClass , source ) ; } pressed = me . getLocationOnScreen ( ) ; location = destination . getLocation ( ) ; if ( changeCursor ) { originalCursor = source . getCursor ( ) ; source . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; } if ( destination instanceof JComponent ) { JComponent jc = ( JComponent ) destination ; autoscrolls = jc . getAutoscrolls ( ) ; jc . setAutoscrolls ( false ) ; } }
va	1	public static void compare ( Map < String , ArrayList < String >> pChecksumSetA , Map < String , ArrayList < String >> pChecksumSetB , File pReportFile ) throws IOException { checksumSetA = pChecksumSetA ; checksumSetB = pChecksumSetB ; if ( pReportFile != null ) { printWriter = new PrintWriter ( new FileWriter ( pReportFile ) ) ; } else { printWriter = null ; } out ( "Entries in Set 1: " + checksumSetA . keySet ( ) . size ( ) ) ; out ( "Entries in Set 2: " + checksumSetB . keySet ( ) . size ( ) ) ; diff ( new File ( "Set 1" ) , new File ( "Set 1" ) ) ; cleanup ( ) ; }
va	6	private boolean isPandigitalForN ( int number , int n ) { Preconditions . checkArgument ( number > 0 ) ; Preconditions . checkArgument ( n > 0 ) ; int [ ] table = new int [ n ] ; for ( char c : Integer . toString ( number ) . toCharArray ( ) ) { int digit = c - 0 ; if ( digit == 0 ) { return false ; } if ( digit > table . length ) { return false ; } table [ digit - 1 ] ++ ; if ( table [ digit - 1 ] > 1 ) { return false ; } } for ( int i = 0 ; i < table . length ; i ++ ) { if ( table [ i ] != 1 ) { return false ; } } return true ; }
va	0	private float angleBetween ( Vector3f origin , Vector3f point ) { float angle ; System . out . println ( "Distance: " + ( point . subtract ( origin ) ) ) ; System . out . println ( "Adjacent: " + ( origin . x - point . x ) ) ; angle = FastMath . acos ( ( origin . x - point . x ) / ( point . subtract ( origin ) ) . length ( ) ) ; return angle ; }
va	3	@ Override protected void onButtonReleased ( GuiButton button ) { super . onButtonReleased ( button ) ; if ( button . id == 0 ) { GuiScreen . setGui ( new GuiMenu ( ) ) ; } else if ( button . id == 1 ) { this . parent . setIngameGui ( new GuiSaveGame ( this . parent ) ) ; } else if ( button . id == 2 ) { this . parent . setPreviousGui ( ) ; } }
va	8	final public BinaryExp CmpOp_postfix ( ) throws ParseException { Token op ; Exp right ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SYM_LESS : jj_consume_token ( SYM_LESS ) ; break ; case SYM_LESSEQUAL : jj_consume_token ( SYM_LESSEQUAL ) ; break ; case SYM_EQUAL : jj_consume_token ( SYM_EQUAL ) ; break ; case SYM_EXCLEQUAL : jj_consume_token ( SYM_EXCLEQUAL ) ; break ; case SYM_MORE : jj_consume_token ( SYM_MORE ) ; break ; case SYM_MOREEQUAL : jj_consume_token ( SYM_MOREEQUAL ) ; break ; default : jj_la1 [ 25 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } op = token ; Exp . appendToGlobalExpString ( token . image ) ; right = AddOp ( ) ; { if ( true ) return new BinaryExp ( null , op , right ) ; } throw new Error ( "Missing return statement in function" ) ; }
va	4	public static void main ( String [ ] args ) throws InterruptedException { ExecutorService exec = Executors . newCachedThreadPool ( ) ; final CyclicBarrier barrier = new CyclicBarrier ( 4 , new Runnable ( ) { public void run ( ) { System . out . println ( "\u597D\u4E86\uFF0C\u5927\u5BB6\u53EF\u4EE5\u53BB\u5403\u996D\u4E86\u2026\u2026" ) ; } } ) ; System . out . println ( "\u8981\u5403\u996D\uFF0C\u5FC5\u987B\u6240\u6709\u4EBA\u90FD\u5230\u7EC8\u70B9\uFF0CoK?" ) ; System . out . println ( "\u4E0D\u653E\u5F03\u4E0D\u629B\u5F03\uFF01" ) ; for ( int i = 0 ; i < 4 ; i ++ ) { exec . execute ( new Runnable ( ) { public void run ( ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + ":Go" ) ; try { Thread . sleep ( ( long ) ( 2000 * Math . random ( ) ) ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( Thread . currentThread ( ) . getName ( ) + ":\u6211\u5230\u7EC8\u70B9\u4E86" ) ; try { barrier . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } System . out . println ( Thread . currentThread ( ) . getName ( ) + ":\u7EC8\u4E8E\u53EF\u4EE5\u5403\u996D\u5566\uFF01" ) ; } } ) ; } exec . shutdown ( ) ; }
va	8	@ Override public void run ( ) { boolean keepRunning = true ; Robot robot = null ; try { robot = new Robot ( ) ; } catch ( AWTException e1 ) { e1 . printStackTrace ( ) ; } try { while ( keepRunning ) { System . out . println ( "LOVE IS ON ME!" ) ; int messageType , x , y , keyCode ; if ( in == null ) { System . out . println ( "BUILDINGS BUILDINGS BUILDINGS" ) ; System . exit ( 0 ) ; } messageType = in . readInt ( ) ; switch ( messageType ) { case MouseEvent . MOUSE_PRESSED : int button = in . readInt ( ) ; x = in . readInt ( ) ; y = in . readInt ( ) ; System . out . println ( "Mouse button " + button + " press at " + x + " " + y ) ; robot . mouseMove ( x , y ) ; robot . mousePress ( convertButtonCode ( button ) ) ; break ; case MouseEvent . MOUSE_RELEASED : button = in . readInt ( ) ; x = in . readInt ( ) ; y = in . readInt ( ) ; System . out . println ( "Mouse button " + button + " release at " + x + " " + y ) ; robot . mouseMove ( x , y ) ; robot . mouseRelease ( convertButtonCode ( button ) ) ; break ; case ( MouseEvent . MOUSE_LAST + 1 ) : keyCode = in . readInt ( ) ; System . out . println ( "Key " + keyCode + " pressed" ) ; robot . keyPress ( keyCode ) ; break ; case ( MouseEvent . MOUSE_LAST + 2 ) : keyCode = in . readInt ( ) ; System . out . println ( "Key " + keyCode + " released" ) ; robot . keyRelease ( keyCode ) ; break ; default : System . out . println ( "Unknown remote control code " + messageType ) ; } } } catch ( IOException e ) { } }
va	2	@ Test public void testIsPlayerLogged ( ) { aggiungiDueUtenti ( ) ; try { assertTrue ( logicaTest . isPlayerLogged ( testingToken ) ) ; assertTrue ( logicaTest . isPlayerLogged ( testingToken2 ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } try { assertFalse ( logicaTest . isPlayerLogged ( "zzz" ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } }
va	7	public static SMTPCommandHandler getCommandHandler ( String command ) { if ( command == null ) { return null ; } SMTPCommandHandler ch = null ; String commandClass = command . toUpperCase ( ) + "Command" ; try { class c = class . forName ( "server.smtp.command." + commandClass ) ; Constructor < ? > cons [ ] = c . getConstructors ( ) ; ch = ( SMTPCommandHandler ) cons [ 0 ] . newInstance ( null ) ; } catch ( ClassNotFoundException e ) { } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } return ch ; }
va	4	public List < String > parseBuffer ( ByteBuffer buffer ) { String req = remainsOfMyBuffer ; if ( buffer != null ) req += charset . decode ( buffer ) . toString ( ) . replaceAll ( "\r\n|\r" , "\n" ) ; List < String > res = new ArrayList < String > ( ) ; if ( req . startsWith ( "help" ) ) { res . add ( "help" ) ; remainsOfMyBuffer = req . substring ( 5 ) ; return res ; } int i = req . indexOf ( MESSAGE_TERMINATOR ) ; if ( i >= 0 ) { String rawReq = req . substring ( 0 , i ) ; res = Arrays . asList ( rawReq . split ( "\n" ) ) ; if ( req . length ( ) > i ) remainsOfMyBuffer = req . substring ( i + MESSAGE_TERMINATOR . length ( ) ) . replaceAll ( "\n$" , "" ) ; return res ; } remainsOfMyBuffer = req ; return null ; }
va	3	public static ClassType createFunctionType ( Methods methods , ArrayClassLoader cl ) throws ClassNotFoundException { ClassType clazz = new ClassType ( "_" + methods . getName ( ) ) ; clazz . setSuper ( "java.lang.Object" ) ; clazz . setModifiers ( Access . public ) ; Field self = clazz . addField ( "self" , methods . getClazz ( ) ) ; for ( gnu . bytecode . Method m : methods . get ( ) ) { String params = "" ; List < Type > types = Arrays . asList ( m . getParameterTypes ( ) ) ; if ( types . size ( ) != 0 ) params = Lambda . joinFrom ( types , "" ) . getSignature ( ) ; Method mm = clazz . addMethod ( methods . getName ( ) , "(" + params + ")" + m . getReturnType ( ) . getSignature ( ) , Access . public ) ; CodeAttr code = mm . startCode ( ) ; code . pushScope ( ) ; code . emitGetField ( self ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) code . emitLoad ( code . addLocal ( types . get ( i ) . getRealType ( ) ) ) ; code . emitInvoke ( m ) ; code . emitReturn ( ) ; code . popScope ( ) ; } byte [ ] classFile = clazz . writeToArray ( ) ; cl . addClass ( "_" + methods . getName ( ) , classFile ) ; ClassType ct = ( ClassType ) ClassType . make ( cl . loadClass ( "_" + methods . getName ( ) , true ) ) ; ClassTypeWriter . print ( clazz , System . out , 0 ) ; return ct ; }
va	2	@ Override public String toString ( ) { if ( values . size ( ) == 0 ) { return field + " in []" ; } StringBuilder result = new StringBuilder ( ) ; result . append ( field ) ; result . append ( " in [" ) ; for ( SMValue value : values ) { result . append ( value . toString ( ) ) ; result . append ( "  " ) ; } return result . substring ( 0 , result . length ( ) - 2 ) + "]" ; }
va	0	public String getRstReceived ( ) { return rstReceived ; }
va	0	public JSONObject ( ) { this . map = new HashMap ( ) ; }
va	3	private Envelope getMessage ( ) { byte [ ] messageByteArray = new byte [ Communicator . getMaxPacketSize ( ) ] ; DatagramPacket packet = new DatagramPacket ( messageByteArray , messageByteArray . length ) ; Message message = null ; try { this . getLogger ( ) . debug ( "getMessage:\n\t starting to try to get message" ) ; socket . setSoTimeout ( Communicator . getReceiveTimeoutInterval ( ) ) ; socket . receive ( packet ) ; this . getLogger ( ) . debug ( "getMessage:\n\t got message successfully" ) ; message = MessageConstructor . constructMessage ( packet . getData ( ) ) ; return Envelope . createIncomingEnvelope ( message , ( InetSocketAddress ) packet . getSocketAddress ( ) ) ; } catch ( SocketTimeoutException e ) { this . getLogger ( ) . debug ( "getMessage socket timed out:\n\t SocketTimeoutException" ) ; } catch ( IOException e ) { System . err . println ( "Error getting message  IOException" ) ; this . getLogger ( ) . error ( "ERROR GETTING MESSAGE:\n\tIOEXCEPTION" ) ; e . printStackTrace ( ) ; } catch ( Exception e ) { System . err . println ( "Error getting message  General Exception" ) ; this . getLogger ( ) . error ( "ERROR GETTING MESSAGE:\n\t General Exception" ) ; e . printStackTrace ( ) ; } return null ; }
va	5	private void informaDadosPartida ( ) { Menu menuDados = new MenuDadosPartida ( ) ; boolean retornarMenu = false ; do { List < DadosPartida > listaPartidasConcluidas = manipuladorPartidas . criarListaPartidasConcluidas ( ) ; ItemMenu itemEscolhido = menuDados . insistirPorEntradaValida ( cli . getIo ( ) ) ; switch ( itemEscolhido . getNome ( ) ) { case "PARTIDAS" : Collections . sort ( listaPartidasConcluidas ) ; exibirPartidasConcluidas ( listaPartidasConcluidas ) ; break ; case "JOGADORES" : DadosPessoa dp = new DadosPessoa ( ) ; List < DadosPessoa > dadosPessoas = dp . geraListaDadosPessoa ( listaPartidasConcluidas ) ; Collections . sort ( dadosPessoas ) ; exibirJogadores ( dadosPessoas ) ; break ; case "APAGAR" : manipuladorPartidas . apagarTodasPartidas ( ) ; break ; case "RETORNAR" : retornarMenu = true ; break ; } } while ( ! retornarMenu ) ; }
va	0	public void setIdProfesor ( String idProfesor ) { this . idProfesor = idProfesor ; }
va	2	public void removeProfile ( long myID ) { ProfileInformation tobedeleted = getProfileInformation ( ( int ) myID ) ; removeObject ( tobedeleted ) ; for ( ResultSet p : connector . browseClass ( ResultSet . class ) ) { if ( p . getId ( ) == myID ) { removeObject ( p ) ; removeObject ( p . getDocument ( ) ) ; } } }
va	6	public static void main ( String [ ] args ) { if ( launcher == null ) { try { launcher = new Launcher ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } } try { String command = "start" ; if ( args . length > 0 ) { command = args [ args . length - 1 ] ; } if ( command . equals ( "start" ) ) { launcher . start ( ) ; } else if ( command . equals ( "stop" ) ) { launcher . stop ( ) ; } else { LOG . log ( Level . WARNING , "Bootstrap: command \"" + command + "\" does not exist." ) ; } } catch ( Throwable t ) { t . printStackTrace ( ) ; } }
va	7	public static void addNewRow ( JTable table , Container controlsContainer ) throws Exception { Object [ ] row = new Object [ controlsContainer . getComponentCount ( ) ] ; Component comp ; String item = null ; Object objItem ; JTextField textField ; JComboBox comboBox ; for ( int i = 0 ; i < controlsContainer . getComponentCount ( ) ; i ++ ) { comp = controlsContainer . getComponent ( i ) ; if ( comp instanceof JTextField ) { textField = ( JTextField ) comp ; row [ i ] = textField . getText ( ) ; textField . setText ( EMPTY ) ; } else if ( comp instanceof JComboBox ) { comboBox = ( JComboBox ) comp ; objItem = comboBox . getSelectedItem ( ) ; if ( objItem instanceof StringBuffer ) { item = objItem . toString ( ) ; } else if ( objItem instanceof String ) { item = ( String ) objItem ; } if ( item != null ) { if ( item . indexOf ( DELIMETER ) > - 1 ) { row = new Object [ 2 ] ; row [ 0 ] = item . substring ( 0 , item . indexOf ( DELIMETER ) ) ; row [ 1 ] = item . substring ( item . indexOf ( DELIMETER ) + DELIMETER . length ( ) ) ; } else { row [ i ] = item ; } comboBox . removeItem ( item ) ; } else { return ; } } } addRow ( table , row ) ; controlsContainer . getComponent ( 0 ) . requestFocus ( ) ; }
va	2	private void acreditacionesActionPerformed ( java . awt . event . ActionEvent evt ) { String carnet = f_carne . getText ( ) . toString ( ) ; if ( B_A_estudiante . validaCarnet ( carnet ) ) { if ( null != B_A_estudiante . consultarEstudiante ( carnet ) ) { Consulta_acreditaciones ventana = new Consulta_acreditaciones ( B_A_estudiante . consultarEstudiante ( carnet ) ) ; ventana . setVisible ( true ) ; this . setVisible ( false ) ; } else { Notificacion notificacion = new Notificacion ( this , true , "Ese estudiante no existe" ) ; notificacion . setVisible ( true ) ; } } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese un carnet valido" ) ; notificacion . setVisible ( true ) ; } }
va	1	public void clear ( ) { loaded = null ; loadedtype = null ; if ( oe != null ) { remove ( oe ) ; oe = null ; invalidate ( ) ; SwingUtilities . updateComponentTreeUI ( this ) ; } }
va	4	private void paintCell ( Graphics g , Rectangle cellRect , int row , int column ) { int spacingHeight = table . getRowMargin ( ) ; int spacingWidth = table . getColumnModel ( ) . getColumnMargin ( ) ; Color c = g . getColor ( ) ; g . setColor ( table . getGridColor ( ) ) ; g . drawRect ( cellRect . x , cellRect . y , cellRect . width - 1 , cellRect . height - 1 ) ; g . setColor ( c ) ; cellRect . setBounds ( cellRect . x + spacingWidth / 2 , cellRect . y + spacingHeight / 2 , cellRect . width - spacingWidth , cellRect . height - spacingHeight ) ; if ( table . isEditing ( ) && table . getEditingRow ( ) == row && table . getEditingColumn ( ) == column ) { Component component = table . getEditorComponent ( ) ; component . setBounds ( cellRect ) ; component . validate ( ) ; } else { TableCellRenderer renderer = table . getCellRenderer ( row , column ) ; Component component = table . prepareRenderer ( renderer , row , column ) ; if ( component . getParent ( ) == null ) { rendererPane . add ( component ) ; } rendererPane . paintComponent ( g , component , table , cellRect . x , cellRect . y , cellRect . width , cellRect . height , true ) ; } }
va	9	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; double a1 = this . paramsMF [ 0 ] , c1 = this . paramsMF [ 1 ] , a2 = this . paramsMF [ 2 ] , c2 = this . paramsMF [ 3 ] ; boolean subnormal = ( c1 > c2 ) ; int n = x . length ; double [ ] func = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( subnormal ) { if ( x [ i ] < c2 ) { func [ i ] = Math . exp ( Math . pow ( ( x [ i ] - c1 ) , 2 ) / ( - 2 * Math . pow ( a1 , 2 ) ) ) ; } else if ( x [ i ] <= c1 || x [ i ] . equals ( c2 ) ) { func [ i ] = Math . exp ( Math . pow ( ( x [ i ] - c1 ) , 2 ) / ( - 2 * Math . pow ( a1 , 2 ) ) ) * Math . exp ( Math . pow ( ( x [ i ] - c2 ) , 2 ) / ( - 2 * Math . pow ( a2 , 2 ) ) ) ; } else if ( x [ i ] > c1 ) { func [ i ] = Math . exp ( Math . pow ( ( x [ i ] - c2 ) , 2 ) / ( - 2 * Math . pow ( a2 , 2 ) ) ) ; } } else { if ( x [ i ] < c1 ) { func [ i ] = Math . exp ( Math . pow ( ( x [ i ] - c1 ) , 2 ) / ( - 2 * Math . pow ( a1 , 2 ) ) ) ; } else if ( x [ i ] <= c2 || x [ i ] . equals ( c1 ) ) { func [ i ] = new double ( 1 ) ; } else if ( x [ i ] > c2 ) { func [ i ] = Math . exp ( Math . pow ( ( x [ i ] - c2 ) , 2 ) / ( - 2 * Math . pow ( a2 , 2 ) ) ) ; } } } ; return func ; }
va	0	public String getDesc ( ) { return description ; }
va	0	public void removeChangeListener ( ChangeListener l ) { other . removeChangeListener ( l ) ; }
va	9	public static String existedAndRead ( String fqns ) { Hashtable mapPackages = new Hashtable ( ) ; Hashtable mapClasses = new Hashtable ( ) ; for ( StringTokenizer st = new StringTokenizer ( fqns , " " ) ; st . hasMoreTokens ( ) ; ) { String fqn = st . nextToken ( ) ; try { class clazz = class . forName ( fqn ) ; putClassInfo ( mapClasses , clazz ) ; } catch ( Exception ex ) { String binaryName = fqn ; boolean found = false ; while ( true ) { try { int lastDotPos = binaryName . lastIndexOf ( . ) ; if ( lastDotPos == - 1 ) break ; binaryName = binaryName . substring ( 0 , lastDotPos ) + $ + binaryName . substring ( lastDotPos + 1 , binaryName . length ( ) ) ; class clazz = class . forName ( binaryName ) ; putClassInfo ( mapClasses , clazz ) ; found = true ; break ; } catch ( Exception e ) { } } if ( ! found ) putPackageInfo ( mapPackages , fqn ) ; } } if ( mapPackages . size ( ) > 0 || mapClasses . size ( ) > 0 ) { StringBuffer sb = new StringBuffer ( 4096 ) ; sb . append ( "{" ) ; for ( Enumeration e = mapPackages . keys ( ) ; e . hasMoreElements ( ) ; ) { String s = ( String ) e . nextElement ( ) ; sb . append ( "'" ) . append ( s . replace ( $ , . ) ) . append ( "':" ) . append ( mapPackages . get ( s ) ) . append ( " " ) ; } for ( Enumeration e = mapClasses . keys ( ) ; e . hasMoreElements ( ) ; ) { String s = ( String ) e . nextElement ( ) ; sb . append ( "'" ) . append ( s . replace ( $ , . ) ) . append ( "':" ) . append ( mapClasses . get ( s ) ) . append ( " " ) ; } sb . append ( "}" ) ; return sb . toString ( ) ; } else return "" ; }
va	4	public static final double [ ] vec_minus ( final double [ ] a , final double [ ] b ) throws NRException { if ( a == null || b == null || a . length != b . length ) throw new NRException ( "a == null || b == null || a.length != b.length" ) ; final double [ ] r = new double [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) r [ i ] = a [ i ] - b [ i ] ; return r ; }
va	0	public THashMap < String , String > getSpecialEntities ( ) { return specialEntities ; }
va	5	public void addTrade ( double trade ) { if ( ( arrayIsFull == false ) && counting == SIZE_OF_ARRAY ) { arrayIsFull = true ; } if ( counting == SIZE_OF_ARRAY ) { counting = 0 ; } tenArray [ counting ] = trade ; counting ++ ; if ( arrayIsFull ) { lastAverage = average ; average = 0 ; for ( int i = 0 ; i < SIZE_OF_ARRAY ; i ++ ) { average += tenArray [ i ] ; } average = average / 10 ; averageChange = ( average - lastAverage ) / lastAverage ; } }
va	3	public String reverseWords ( String s ) { if ( s == null ) return null ; StringBuilder sb = new StringBuilder ( ) ; String [ ] parts = s . trim ( ) . split ( " +" ) ; for ( int i = parts . length - 1 ; i >= 0 ; i -- ) { sb . append ( parts [ i ] ) . append ( " " ) ; } if ( sb . length ( ) > 0 ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; }
va	0	@ Override public boolean completesValidShape ( int x , int y ) { return true ; }
va	6	@ Override public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , false , row , hasFocus ) ; Object valueData = value ; if ( valueData instanceof Animation ) { if ( expanded || leaf ) setIcon ( AnimationManager . animationIcon ) ; else setIcon ( AnimationManager . animationCollapsedIcon ) ; } else if ( valueData instanceof Frame ) { setIcon ( AnimationManager . frameIcon ) ; } else if ( valueData instanceof EditorData ) { setText ( "Animations" ) ; } if ( value == animationTree . getSelectedNode ( ) ) setForeground ( Color . BLUE ) ; else setForeground ( Color . BLACK ) ; return this ; }
va	6	public void each ( String input , Output < Map < String , Object >> mapOutput ) throws IOException { if ( regex != null ) { Matcher matcher = regex . matcher ( input ) ; if ( matcher . matches ( ) ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; for ( int i = 1 ; i <= matcher . groupCount ( ) ; i ++ ) { putValue ( map , i - 1 , matcher . group ( i ) ) ; } if ( ! map . isEmpty ( ) ) { mapOutput . output ( map ) ; } } } else { String [ ] values = input . split ( delimiter ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i ++ ) { putValue ( map , i , values [ i ] ) ; } mapOutput . output ( map ) ; } } }
va	6	@ Override public int awardPoints ( boolean [ ] sv , int objectSize ) { if ( objectSize > thresh ) { for ( boolean b : sv ) { if ( b ) return 0 ; } return 1 ; } else { int c = 0 ; for ( boolean b : sv ) { if ( b ) c ++ ; } return c == objectSize ? 1 : 0 ; } }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof DeliveryPacket ) ) { return false ; } DeliveryPacket other = ( DeliveryPacket ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
va	2	@ Test public void inorderBothNull ( ) { try { AVLTree < Integer , Integer > b = new AVLTree < Integer , Integer > ( ) ; b . inorder ( null , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } }
va	1	@ Override void pushForIterator ( Stack < Object > stack ) { for ( int i = 0 ; i < keys . size ( ) ; i ++ ) { stack . push ( children . get ( children . size ( ) - 1 - i ) ) ; stack . push ( keys . get ( keys . size ( ) - 1 - i ) ) ; } stack . push ( children . get ( 0 ) ) ; }
va	0	public void setPortNumber ( int portNumber ) { this . portNumber = portNumber ; this . initializeSocket ( ) ; }
va	5	public List < List < String >> formatHeaderCells ( ) { int maxHeaderHeight = 0 ; for ( Column column : columns ) { maxHeaderHeight = Math . max ( maxHeaderHeight , Column . getMaxRowHeight ( column . getWidth ( ) , column . getTitle ( ) ) ) ; } List < List < String >> headerLines = new ArrayList < List < String >> ( ) ; for ( int j = 0 ; j < maxHeaderHeight ; j ++ ) { headerLines . add ( new ArrayList < String > ( ) ) ; } for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { Column column = columns . get ( i ) ; AlignType align = getTextTableExportOptions ( ) . getHeaderAlignment ( ) ; if ( align == null ) { align = column . getAlign ( ) ; } List < String > cells = Column . align ( column . getWidth ( ) , maxHeaderHeight , align , column . getTitle ( ) ) ; for ( int j = 0 ; j < maxHeaderHeight ; j ++ ) { headerLines . get ( j ) . add ( cells . get ( j ) ) ; } } return headerLines ; }
va	0	private SET_NumericVariable ( NumericVariable variable , NumericExpression expression ) { this . variable = variable ; this . expression = expression ; }
va	9	public void update2 ( IUpdateInfo uInfo ) { CollisionDetection . checkBroadphase ( this , updateList , collisionTree , uInfo ) ; Collection < Manifold > c = Manifold . manifolds . values ( ) ; for ( Manifold m : c ) { for ( int i = 0 ; i < m . size ( ) ; i ++ ) { ElasticContact e = ElasticContactSolver . addContact ( m . getBodyA ( ) , ( DynamicBody ) m . getBodyB ( ) , m . getContact ( i ) ) ; } } ElasticContactSolver . run ( uInfo ) ; SpeculativeContactSolver . run ( uInfo ) ; for ( final DynamicBody dynBody : updateList ) { dynBody . prepareUpdatePosition ( uInfo ) ; dynBody . generateSweptBounds ( uInfo ) ; } for ( final Constraint contraint : constraintList ) { contraint . solve ( uInfo ) ; } for ( final DynamicBody dynBody : updateList ) { dynBody . updatePosition ( uInfo ) ; dynBody . updateBounds ( ) ; final IShape shape = dynBody . getShape ( ) ; if ( shape . hasChanged ( ) ) { collisionTree . hasMoved ( shape . getAABB ( ) ) ; } } collisionTree . optimize ( ) ; Manifold . update ( ) ; if ( uInfo . isPreRendering ( ) ) { activeCamera . prepareUpdatePosition ( uInfo ) ; if ( activeCamera instanceof TrackingCamera ) { final TrackingCamera sc = ( TrackingCamera ) activeCamera ; if ( sc . followBody != null ) { CollisionDetection . rayCasting ( sc , collisionTree ) ; } } activeCamera . updatePosition ( uInfo ) ; activeLight . updatePosition ( uInfo ) ; } }
va	5	public Writer write ( Writer writer ) throws JSONException { try { boolean commanate = false ; Iterator keys = this . keys ( ) ; writer . write ( { ) ; while ( keys . hasNext ( ) ) { if ( commanate ) { writer . write (   ) ; } Object key = keys . next ( ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; Object value = this . map . get ( key ) ; if ( value instanceof JSONObject ) { ( ( JSONObject ) value ) . write ( writer ) ; } else if ( value instanceof JSONArray ) { ( ( JSONArray ) value ) . write ( writer ) ; } else { writer . write ( valueToString ( value ) ) ; } commanate = true ; } writer . write ( } ) ; return writer ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } }
va	3	public void apply ( PermissionBase base , CommandSender sender , World world ) { List < String > permissions = base . getPermissions ( world == null ? null : world . getName ( ) ) ; PermissionAttachment att = sender . addAttachment ( plugin ) ; for ( String perm : permissions ) { att . setPermission ( perm . startsWith ( "-" ) ? perm . substring ( 1 ) : perm , ! perm . startsWith ( "-" ) ) ; } }
va	9	public byte compose8bit ( int t ) { byte rtn = ( byte ) 0 ; switch ( bitNumber ) { case 0 : rtn = ( byte ) ( ( ( t >> 5 & t ) - ( t >> 5 ) + ( t >> 5 & t ) ) + ( t * ( ( t >> 14 ) & 14 ) ) ) ; break ; case 1 : rtn = ( byte ) ( ( t >> 5 ) | ( t << 4 ) | ( ( t & 1023 ) ^ 1981 ) | ( ( t - 67 ) >> 4 ) ) ; break ; case 2 : rtn = ( byte ) ( ( ( t * ( t >> 8 | t >> 9 ) & 46 & t >> 8 ) ) ^ ( t & t >> 13 | t >> 6 ) ) ; break ; case 3 : rtn = ( byte ) ( ( t >> ( t & 7 ) ) | ( t << ( t & 42 ) ) | ( t >> 7 ) | ( t << 5 ) ) ; break ; case 4 : rtn = ( byte ) ( ( t >> 6 | t << 1 ) + ( t >> 5 | t << 3 | t >> 3 ) | t >> 2 | t << 1 ) ; break ; case 5 : rtn = ( byte ) ( ( t >> 6 | t | t >> ( t >> 16 ) ) * 10 + ( ( t >> 11 ) & 7 ) ) ; break ; case 6 : rtn = ( byte ) ( ( t / 8 ) >> ( t >> 9 ) * t / ( ( t >> 14 & 3 ) + 4 ) ) ; break ; case 7 : rtn = ( byte ) ( t * ( 42 & t >> 10 ) ) ; break ; case 8 : rtn = ( byte ) ( ( t * t * t / t ) % 123 ) ; break ; default : rtn = ( byte ) ( ( t * t * t * t ) % 123 ) ; break ; } return rtn ; }
va	4	private static int getLevel ( int num ) { if ( num == 1 ) { return 1 ; } for ( int i = 2 ; i < MAX ; i ++ ) { if ( num >= getLeft ( i ) && num <= getRight ( i ) ) { return i ; } } return - 1 ; }
va	7	static private int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 40 : return jjStopAtPos ( 0 , 12 ) ; case 41 : return jjStopAtPos ( 0 , 13 ) ; case 42 : return jjStopAtPos ( 0 , 7 ) ; case 43 : return jjStopAtPos ( 0 , 5 ) ; case 45 : return jjStopAtPos ( 0 , 6 ) ; case 47 : return jjStopAtPos ( 0 , 8 ) ; case 59 : return jjStopAtPos ( 0 , 11 ) ; default : return jjMoveNfa_0 ( 0 , 0 ) ; } }
va	7	@ Override public void tableChanged ( final TableModelEvent e ) { if ( getAutoResizingEnabled ( ) ) { if ( e . getType ( ) == TableModelEvent . DELETE ) { resizeAllColumns ( ) ; } else { for ( int col = 0 ; col < table . getColumnCount ( ) ; col ++ ) { TableColumn column = table . getColumnModel ( ) . getColumn ( col ) ; if ( canResize ( column ) ) { int width = column . getPreferredWidth ( ) ; for ( int row = e . getFirstRow ( ) ; ( row <= e . getLastRow ( ) ) && ( row < table . getRowCount ( ) ) && ( row != - 1 ) ; row ++ ) { TableCellRenderer renderer = table . getCellRenderer ( row , col ) ; Component comp = renderer . getTableCellRendererComponent ( table , table . getValueAt ( row , col ) , false , false , row , col ) ; width = Math . max ( width , comp . getPreferredSize ( ) . width + table . getColumnModel ( ) . getColumnMargin ( ) ) ; } column . setPreferredWidth ( width ) ; } } } } }
va	6	public BlockOrientation getOrientation ( ) { IntBuffer orientationBuf = IntBuffer . allocate ( 1 ) ; IntBuffer writingDirectionBuf = IntBuffer . allocate ( 1 ) ; IntBuffer textlineOrderBuf = IntBuffer . allocate ( 1 ) ; FloatBuffer deskewAngleBuf = FloatBuffer . allocate ( 1 ) ; iterator . getOrientation ( orientationBuf , writingDirectionBuf , textlineOrderBuf , deskewAngleBuf ) ; int value = orientationBuf . get ( ) ; Orientation orientation = Orientation . UP ; for ( Orientation o : Orientation . values ( ) ) { if ( value == o . value ) { orientation = o ; break ; } } value = writingDirectionBuf . get ( ) ; WritingDirection direction = WritingDirection . LEFT_TO_RIGHT ; for ( WritingDirection d : WritingDirection . values ( ) ) { if ( value == d . value ) { direction = d ; break ; } } value = textlineOrderBuf . get ( ) ; TextlineOrder order = TextlineOrder . TOP_TO_BOTTOM ; for ( TextlineOrder o : TextlineOrder . values ( ) ) { if ( value == o . value ) { order = o ; break ; } } return new BlockOrientation ( orientation , direction , order , deskewAngleBuf . get ( ) ) ; }
va	1	public int setData ( byte [ ] newData ) { if ( newData == null ) { return - 1 ; } return setData ( newData , 0 , newData . length ) ; }
va	2	protected FieldOrMethodAccess parseMethodCallOrVarAccess ( ) throws ParsingException { Token first = lexer . token ( ) ; System . out . println ( "pMCOVA: first = " + first ) ; FieldOrMethodAccess access ; if ( lexer . token ( ) == Token . ( ) { List < Expression > parameters = parseParameterList ( ) ; access = new MethodAccess ( first , parameters ) ; } else { access = new FieldAccess ( first ) ; lexer . nextToken ( ) ; } if ( lexer . token ( ) == Token . . ) { access . setNext ( parseMethodCallOrVarAccess ( ) ) ; } System . out . println ( "pMCOVA: token = " + lexer . token ( ) ) ; return access ; }
va	5	public static void main ( String [ ] args ) { int numbers = 3 ; int count = 1 ; int prev = 1 ; boolean up = true ; for ( int i = 0 ; i < numbers + ( numbers - 1 ) * ( numbers ) ; i ++ ) { if ( prev <= count ) { System . out . print ( prev ) ; prev ++ ; } if ( prev > count ) { System . out . println ( ) ; prev = 1 ; if ( count >= numbers ) { up = false ; } if ( up ) { count ++ ; } else { count -- ; } } } }
va	8	@ Override public String toString ( ) { ResourceType type = Helpers . getType ( resource ) ; String result = "{" ; result += "\"name\":\"" + Helpers . getLabel ( resource , languageCode ) + "\" " ; result += "\"id\":\"" + Helpers . getId ( resource ) + "\" " ; result += "\"type\":\"" + type . toString ( ) . toLowerCase ( ) + "\" " ; result += "\"sameAs\":[" ; if ( type == ResourceType . class ) { result += listOntResource ( resource . asClass ( ) . listEquivalentClasses ( ) . filterDrop ( new Filter < OntClass > ( ) { @ Override public boolean accept ( OntClass c ) { if ( c . isAnon ( ) || c . getURI ( ) . equalsIgnoreCase ( resource . getURI ( ) ) ) return true ; return false ; } } ) , true ) ; } else if ( type == ResourceType . INSTANCE ) { result += listOntResource ( resource . asIndividual ( ) . listSameAs ( ) . filterDrop ( new Filter ( ) { @ Override public boolean accept ( Object c ) { if ( ( ( OntResource ) c ) . isAnon ( ) || ( ( OntResource ) c ) . getURI ( ) . equalsIgnoreCase ( resource . getURI ( ) ) ) return true ; return false ; } } ) , true ) ; } result += "] " ; result += "\"attributes\": [" ; if ( type == ResourceType . class ) { result += "{" ; result += "\"name\":\"Parents\" " ; result += "\"id\":\"superClasses\" " ; result += "\"values\":[" ; result += listOntResource ( resource . asClass ( ) . listSuperClasses ( true ) ) ; result += "]" ; result += "} {" ; result += "\"name\":\"Children\" " ; result += "\"id\":\"subClasses\" " ; result += "\"values\":[" ; result += listOntResource ( resource . asClass ( ) . listSubClasses ( true ) ) ; result += "]" ; result += "} {" ; result += "\"name\":\"Instances\" " ; result += "\"id\":\"instances\" " ; result += "\"values\":[" ; result += listOntResource ( resource . asClass ( ) . listInstances ( true ) ) ; result += "]" ; result += "}" ; } else if ( type == ResourceType . INSTANCE ) { result += "{" ; result += "\"name\":\"Classes\" " ; result += "\"id\":\"classes\" " ; result += "\"values\":[" ; result += listOntResource ( resource . asIndividual ( ) . listOntClasses ( true ) ) ; result += "]" ; result += "} " ; result += listLinks ( resource . listProperties ( ) ) ; result = result . substring ( 0 , result . length ( ) - 1 ) ; } result += "]" ; result += "}" ; return result ; }
va	4	protected void definirEtat ( String e ) { this . etat = e ; if ( this . etat . equalsIgnoreCase ( "locked" ) ) { label = new JLabel ( new ImageIcon ( "./images/s-locked.png" ) ) ; panel_case . add ( label ) ; } if ( this . etat . equalsIgnoreCase ( "exit" ) ) { label = new JLabel ( new ImageIcon ( "./images/s-exit.png" ) ) ; panel_case . add ( label ) ; } if ( this . etat . equalsIgnoreCase ( "submerged" ) ) { label = new JLabel ( new ImageIcon ( "./images/s-submerged.png" ) ) ; panel_case . add ( label ) ; } if ( this . etat . equalsIgnoreCase ( "dark" ) ) { label = new JLabel ( new ImageIcon ( "./images/s-dark.png" ) ) ; panel_case . add ( label ) ; } panel_case . validate ( ) ; panel_case . repaint ( ) ; }
va	8	public void adjustRGB ( int adjustmentR , int adjustmentG , int adjustmentB ) { for ( int pixel = 0 ; pixel < pixels . length ; pixel ++ ) { int originalColour = pixels [ pixel ] ; if ( originalColour != 0 ) { int red = originalColour >> 16 & ff ; red += adjustmentR ; if ( red < 1 ) red = 1 ; else if ( red > 255 ) red = 255 ; int green = originalColour >> 8 & ff ; green += adjustmentG ; if ( green < 1 ) green = 1 ; else if ( green > 255 ) green = 255 ; int blue = originalColour & ff ; blue += adjustmentB ; if ( blue < 1 ) blue = 1 ; else if ( blue > 255 ) blue = 255 ; pixels [ pixel ] = ( red << 16 ) + ( green << 8 ) + blue ; } } }
va	0	@ Override public void keyTyped ( final KeyEvent arg0 ) { }
va	4	private Token currentToken ( ) { if ( tokens . isEmpty ( ) ) { try { if ( scanner . eof ( ) ) { return null ; } parseNextTokens ( ) ; } catch ( IOException e ) { throw new ParseException ( e . getMessage ( ) , scanner . currentParseOffset ( ) , e ) ; } if ( tokens . isEmpty ( ) ) { return null ; } } return tokens . get ( 0 ) ; }
