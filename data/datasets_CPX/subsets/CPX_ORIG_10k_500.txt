tr	1	public AsynchronousCursor ( int batchSize , Factory < T > factory ) { this . strategy = new AdaptiveStrategy < T > ( Math . round ( ( batchSize - 1 ) / 2 ) , batchSize , factory ) ; queue = new ArrayBlockingQueue < T > ( batchSize * 2 ) ; worker = new Worker ( ) ; new Thread ( worker ) . start ( ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
tr	2	public PluginLoader ( ) throws FileNotFoundException { pluginDirectory = new File ( "plugins/" ) ; if ( ! pluginDirectory . exists ( ) ) { throw new FileNotFoundException ( "Unable to find the plugins directory" ) ; } if ( ! pluginDirectory . isDirectory ( ) ) { throw new FileNotFoundException ( "Unable to find the plugins directory" ) ; } }
tr	8	private static boolean longestWordFromOtherWords2 ( HashMap < String , boolean > wordMap , boolean isOriginal , String word ) { String substring1 ; String substring2 ; if ( word == null || word . length ( ) == 0 ) { return false ; } else if ( wordMap . containsKey ( word ) && ! isOriginal ) { return wordMap . get ( word ) ; } else { int i ; for ( i = 1 ; i < word . length ( ) ; i ++ ) { substring1 = word . substring ( 0 , i ) ; substring2 = word . substring ( i ) ; if ( wordMap . containsKey ( substring1 ) && wordMap . get ( substring1 ) == true && longestWordFromOtherWords2 ( wordMap , false , substring2 ) ) { return true ; } } wordMap . put ( word , false ) ; return false ; } }
tr	5	private static List < File > execTtc2Ttf ( File file , FileGarbage kill ) throws IOException { File dir = File . createTempFile ( "fontdir" , ".tmp" ) ; dir . delete ( ) ; dir . mkdirs ( ) ; kill . addFile ( dir , true ) ; File tempFile = new File ( dir , file . getName ( ) + ".tmp" ) ; kill . addFile ( tempFile , true ) ; NativeFiles . copy ( file , tempFile ) ; File execFile = new File ( "bin/ttc2ttf" ) ; String [ ] cmd = new String [ ] { execFile . getAbsolutePath ( ) , "-0" , tempFile . getName ( ) } ; try { Process proc = Runtime . getRuntime ( ) . exec ( cmd , null , dir ) ; int err = proc . waitFor ( ) ; if ( err != 0 ) throw new IOException ( "Failed to convert TTC to TTF: " + err ) ; } catch ( InterruptedException ex ) { throw new InterruptedIOException ( ex . getMessage ( ) ) ; } List < File > ret = new ArrayList < File > ( ) ; File [ ] files = dir . listFiles ( ) ; if ( files == null ) return ret ; for ( File f : files ) { if ( f . getName ( ) . equals ( tempFile . getName ( ) ) ) continue ; ret . add ( f ) ; kill . addFile ( f , true ) ; } return ret ; }
tr	8	public static int [ ] mergeSort ( int [ ] dataA , int [ ] dataB ) { int [ ] data = new int [ dataA . length + dataB . length ] ; int i = 0 ; int j = 0 ; int x = 0 ; while ( i < dataA . length ) { if ( j < dataB . length ) { if ( dataA [ i ] <= dataB [ j ] ) { data [ x ++ ] = dataA [ i ++ ] ; } else { while ( j < dataB . length && dataA [ i ] > dataB [ j ] ) { data [ x ++ ] = dataB [ j ++ ] ; } } } else { data [ x ++ ] = dataA [ i ++ ] ; } if ( i == dataA . length && j < dataB . length ) { while ( j < dataB . length ) { data [ x ++ ] = dataB [ j ++ ] ; } } } return data ; }
tr	8	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; if ( this . overlayXY != null && this . overlayXY . isDirty ( ) ) { this . overlayXY . setRecursiveNotDirty ( ) ; } if ( this . screenXY != null && this . screenXY . isDirty ( ) ) { this . screenXY . setRecursiveNotDirty ( ) ; } if ( this . rotationXY != null && this . rotationXY . isDirty ( ) ) { this . rotationXY . setRecursiveNotDirty ( ) ; } if ( this . size != null && this . size . isDirty ( ) ) { this . size . setRecursiveNotDirty ( ) ; } this . isRotationDirty = false ; }
tr	2	@ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { final Component c = super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; if ( dataholder . getResult ( ) . get ( row ) . getSignificance ( ) == EdasomindSignificance . HIGH ) { c . setForeground ( Color . WHITE ) ; c . setBackground ( Color . RED ) ; } else if ( dataholder . getResult ( ) . get ( row ) . getSignificance ( ) == EdasomindSignificance . MEDIUM ) { c . setForeground ( Color . black ) ; c . setBackground ( Color . ORANGE ) ; } else { c . setBackground ( Color . GREEN ) ; c . setForeground ( Color . black ) ; } return c ; }
tr	2	public static ServiceRank codeOf ( Object code ) { if ( code == null ) { return null ; } if ( code instanceof ServiceRank ) { return ( ServiceRank ) code ; } return _codeValueMap . get ( code . toString ( ) . toLowerCase ( ) ) ; }
tr	9	@ Test public void testDoMuoviDinosauro ( ) { aggiungiDueUtenti ( ) ; try { assertTrue ( logicaTest . doCreaRazza ( testingToken , "miaRazza1" , e ) ) ; assertTrue ( logicaTest . doAccessoPartita ( testingToken ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( NomeRazzaOccupatoException e ) { fail ( ) ; } catch ( InterruptedException e ) { fail ( ) ; } catch ( TroppiGiocatoriException e ) { fail ( ) ; } catch ( RazzaNonCreataException e ) { fail ( ) ; } Iterator < Dinosauro > itDino = null ; try { itDino = logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . iterator ( ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } assertNotNull ( itDino ) ; assertTrue ( itDino . hasNext ( ) ) ; Dinosauro tmpDino = itDino . next ( ) ; assertNotNull ( tmpDino ) ; String tmpId = tmpDino . getIdDinosauro ( ) ; assertNotNull ( tmpId ) ; assertEquals ( tmpId , tmpDino . getIdDinosauro ( ) ) ; tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; try { logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . cresciDinosauro ( tmpId ) ; logicaTest . getPlayerByToken ( testingToken ) . getRazza ( ) . aggiornaRazza ( ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { fail ( ) ; } tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; String ret = null ; try { do { ret = logicaTest . doMuoviDinosauro ( testingToken , tmpId , new Coord ( tmpDino . getCoord ( ) . getX ( ) + CommonUtils . getNewRandomIntValue ( 3 ) , tmpDino . getCoord ( ) . getY ( ) + CommonUtils . getNewRandomIntValue ( 3 ) ) ) ; System . out . println ( "ret: " + ret ) ; assertNotNull ( ret ) ; } while ( ret . equals ( "destinazioneNonValida" ) ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { System . out . println ( "GenericDinosauroException incontrata! " + e . getMessage ( ) ) ; fail ( ) ; } try { tmpDino = logicaTest . getPlayerByIdDinosauro ( tmpId ) . getRazza ( ) . getDinosauroById ( tmpId ) ; tmpDino . setEnergiaAttuale ( tmpDino . getEnergiaMax ( ) ) ; ret = logicaTest . doMuoviDinosauro ( testingToken , tmpId , new Coord ( tmpDino . getCoord ( ) . getX ( ) + 1 , tmpDino . getCoord ( ) . getY ( ) + 1 ) ) ; assertNotNull ( ret ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } catch ( GenericDinosauroException e ) { System . out . println ( "[testDoMuoviDinosauro] Eccezione GenericDinosauroException gestita correttamente \"" + e . getMessage ( ) + "\"" ) ; } }
tr	4	@ Override public void keyPressed ( KeyEvent e ) { int curKeys = e . getKeyCode ( ) ; if ( location == "Map" && movable == true ) { p . setKeyPress ( curKeys ) ; } if ( location == "Encounter" && movable == true ) { enc . setKeyPress ( curKeys ) ; clicked = true ; } }
tr	7	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	6	@ Override public BufferedImage getHoldEndBackgroundImage ( Type type , Orientation orientation , Timing timing ) { switch ( type ) { case FREEZE_START : case HOLDING : case FREEZE_END : return freezeEnd ; case ROLL_START : case ROLLING : case ROLL_END : return rollEnd ; default : return empty ; } }
tr	4	@ Override public void updateSheetPosition ( ) { int row = 0 ; switch ( direction ) { case UP : row = 0 ; break ; case RIGHT : row = 1 ; break ; case DOWN : row = 2 ; break ; case LEFT : row = 3 ; break ; } int column = currentFrame ; sheetPosition = new Vec2i ( column , row ) ; }
tr	3	protected int readStringHeaderImpl ( ) throws IOException , UBJFormatException { byte type = checkType ( "STRING" , STRING_COMPACT , STRING ) ; int length = 0 ; switch ( type ) { case STRING_COMPACT : length = read ( ) ; break ; case STRING : length = readInt32Impl ( ) ; break ; } if ( length < 0 ) throw new UBJFormatException ( pos , "Encountered a negative (invalid) length of [" + length + "] specified for the STRING value at stream position " + pos + ". Length must be >= 0." ) ; return length ; }
tr	1	public int step ( int state , char c ) { if ( classmap == null ) return transitions [ state * points . length + getCharClass ( c ) ] ; else return transitions [ state * points . length + classmap [ c - Character . MIN_VALUE ] ] ; }
tr	3	private void updateArea ( int x0 , int y0 , int w , int h ) { g . setBackground ( transparent ) ; g . clearRect ( x0 , y0 , w , h ) ; int xTileStart = ( x0 + xCam ) / 16 ; int yTileStart = ( y0 + yCam ) / 16 ; int xTileEnd = ( x0 + xCam + w ) / 16 ; int yTileEnd = ( y0 + yCam + h ) / 16 ; for ( int x = xTileStart ; x <= xTileEnd ; x ++ ) { for ( int y = yTileStart ; y <= yTileEnd ; y ++ ) { int b = level . getBlock ( x , y ) & ff ; if ( ( ( Level . TILE_BEHAVIORS [ b ] ) & Level . BIT_ANIMATED ) == 0 ) { g . drawImage ( Art . level [ b % 16 ] [ b / 16 ] , ( x << 4 ) - xCam , ( y << 4 ) - yCam , null ) ; } } } }
tr	8	@ Override public boolean mouseClicked ( int mouseButton , int mouseX , int mouseY ) { if ( ! this . enabled || mouseButton != 0 ) { return false ; } if ( mouseX >= this . posX && mouseX <= this . posX + this . width && mouseY >= this . posY && mouseY <= this . posY + this . height ) { if ( mouseX < this . posX + this . width - 20 ) { int index = ( mouseY - this . posY ) / 20 + this . scroll ; if ( index > this . elements . size ( ) - 1 ) { return false ; } this . selectedIndex = index ; } else { } return true ; } return false ; }
tr	9	private static void method377 ( int ai [ ] , int i , int j , int l , int i1 ) { int k ; if ( aBoolean1462 ) { if ( i1 > DrawingArea . centerX ) i1 = DrawingArea . centerX ; if ( l < 0 ) l = 0 ; } if ( l >= i1 ) return ; i += l ; k = i1 - l >> 2 ; if ( anInt1465 == 0 ) { while ( -- k >= 0 ) { ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; ai [ i ++ ] = j ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j ; return ; } int j1 = anInt1465 ; int k1 = 256 - anInt1465 ; j = ( ( j & ff00ff ) * k1 >> 8 & ff00ff ) + ( ( j & ff00 ) * k1 >> 8 & ff00 ) ; while ( -- k >= 0 ) { ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; } for ( k = i1 - l & 3 ; -- k >= 0 ; ) ai [ i ++ ] = j + ( ( ai [ i ] & ff00ff ) * j1 >> 8 & ff00ff ) + ( ( ai [ i ] & ff00 ) * j1 >> 8 & ff00 ) ; }
tr	7	public BasicRelation identifySubClassRelationship ( BloomsTree sourceTree , BloomsTree targetTree ) { double rStrength = 0.0D ; double maxStrength = 0.0D ; BasicRelation rel = null ; if ( sourceTree != null && targetTree != null ) { for ( int i = 0 ; i < sourceTree . getRoot ( ) . getChildCount ( ) ; i ++ ) { BloomsNode sourceNode = ( BloomsNode ) sourceTree . getRoot ( ) . getChildAt ( i ) ; for ( int k = 0 ; k < targetTree . getRoot ( ) . getChildCount ( ) ; k ++ ) { BloomsNode targetNode = ( BloomsNode ) targetTree . getRoot ( ) . getChildAt ( k ) ; HashMap commonNodeMap = sourceNode . commonNodes ( targetNode ) ; if ( commonNodeMap . size ( ) > 0 ) { ScoreCalculator score = new ScoreCalculator ( commonNodeMap , sourceNode . getTreeSize ( ) ) ; rStrength = score . computeRelationshipStrength ( ) . doubleValue ( ) ; if ( rStrength > 0.0D && rStrength >= maxStrength ) { maxStrength = rStrength ; rel = createRelationshipObject ( "<" ) ; } } else { rStrength = 0.0D ; } } } } setRelationshipStrength ( new double ( maxStrength ) ) ; return rel ; }
tr	0	@ Inject public Example ( String helloworld ) { }
tr	9	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnSelectDate ) { int index = dateOfVisitcomboBox . getSelectedIndex ( ) ; currVisit = visits . get ( index ) ; prescs = parent . getHandler ( ) . getVisitPrescriptions ( visits . get ( index ) . getPatUsername ( ) , visits . get ( index ) . getDocUsername ( ) , visits . get ( index ) . getDateOfVisit ( ) ) ; model . removeAllElements ( ) ; for ( Prescription p : prescs ) { model . addElement ( p . getMedicineName ( ) ) ; } } else if ( e . getSource ( ) == btnSelect ) { String medName = ( String ) medList . getSelectedValue ( ) ; Prescription pres = new Prescription ( ) ; for ( Prescription p : prescs ) { if ( p . getMedicineName ( ) . equals ( medName ) ) { pres = p ; break ; } } int duration = pres . getDuration ( ) ; Integer monthsD = duration / 30 ; Integer daysD = duration % 30 ; Integer dosage = pres . getDosage ( ) ; medNameTextField . setText ( medName ) ; dosageTextField . setText ( dosage . toString ( ) ) ; monthsTextField . setText ( monthsD . toString ( ) ) ; daysTextField . setText ( daysD . toString ( ) ) ; Doctor doc = parent . getHandler ( ) . getDoctor ( currVisit . getDocUsername ( ) ) ; String name = "Dr. " + doc . getfName ( ) + " " + doc . getlName ( ) ; consultingDoctorTextField . setText ( name ) ; } else if ( e . getSource ( ) == btnAddToCart ) { int durationz = Integer . parseInt ( monthsTextField . getText ( ) ) * 30 + Integer . parseInt ( daysTextField . getText ( ) ) ; Prescription prescription = new Prescription ( username , consultingDoctorTextField . getText ( ) , ( String ) dateOfVisitcomboBox . getSelectedItem ( ) , medNameTextField . getText ( ) , Integer . parseInt ( dosageTextField . getText ( ) ) , durationz , "" , "No" ) ; cart . add ( prescription ) ; model2 . addElement ( prescription . getMedicineName ( ) ) ; } else if ( e . getSource ( ) == btnCheckout ) { if ( ! cart . isEmpty ( ) ) { PaymentInfoPanel pip = new PaymentInfoPanel ( parent , username , cart ) ; parent . getContentPane ( ) . add ( pip ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else { JOptionPane . showMessageDialog ( null , "Cart is Empty." ) ; } } else if ( e . getSource ( ) == btnBack ) { CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; parent . getContentPane ( ) . remove ( parent . getContentPane ( ) . getComponents ( ) . length - 1 ) ; cl . last ( parent . getContentPane ( ) ) ; } }
tr	7	private static void getParametersFromFile ( modelparameters ldaparameters , String parameterFile ) { ArrayList < String > paramLines = new ArrayList < String > ( ) ; FileUtil . readLines ( parameterFile , paramLines ) ; for ( String line : paramLines ) { String [ ] lineParts = line . split ( "\t" ) ; switch ( parameters . valueOf ( lineParts [ 0 ] ) ) { case alpha : ldaparameters . alpha = float . valueOf ( lineParts [ 1 ] ) ; break ; case beta : ldaparameters . beta = float . valueOf ( lineParts [ 1 ] ) ; break ; case topicNum : ldaparameters . topicNum = Integer . valueOf ( lineParts [ 1 ] ) ; break ; case iteration : ldaparameters . iteration = Integer . valueOf ( lineParts [ 1 ] ) ; break ; case saveStep : ldaparameters . saveStep = Integer . valueOf ( lineParts [ 1 ] ) ; break ; case beginSaveIters : ldaparameters . beginSaveIters = Integer . valueOf ( lineParts [ 1 ] ) ; break ; } } }
tr	0	public void setTutorsInfo ( ArrayList < PareTutor > tutorsInfo ) { this . tutorsInfo = tutorsInfo ; }
tr	8	@ Transactional public void allocateSeats ( Event event ) { if ( event . isSeatAllocated ( ) ) { return ; } List < EventRegistration > allUnallocatedForeignRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , false ) ; List < EventRegistration > allUnallocatedIndianRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , true ) ; List < EventRegistration > allUnallocatedRegistrations = new ArrayList < EventRegistration > ( ) ; allUnallocatedRegistrations . addAll ( allUnallocatedForeignRegistrations ) ; allUnallocatedRegistrations . addAll ( allUnallocatedIndianRegistrations ) ; List < RowMeta > rowMetas = eventDAO . getAllEmptyRowMetas ( event ) ; int regsCount = 0 ; int regsSize = allUnallocatedRegistrations . size ( ) ; for ( RowMeta rowMeta : rowMetas ) { if ( regsCount >= regsSize ) { break ; } int seatCounter = 0 ; boolean [ ] seatFlags = markAllocatedSeats ( event , rowMeta ) ; boolean isRowFull = false ; for ( int i = 0 ; i < seatFlags . length ; i ++ ) { if ( regsCount >= regsSize ) { break ; } seatCounter = seatCounter + 1 ; if ( ! seatFlags [ i ] ) { EventRegistration registration = allUnallocatedRegistrations . get ( regsCount ) ; ParticipantSeat seat = createSeat ( registration , rowMeta . getRowName ( ) , seatCounter ) ; participantDAO . saveOrUpdate ( seat ) ; seatFlags [ i ] = true ; regsCount ++ ; } if ( seatFlags . length == seatCounter ) { isRowFull = true ; } } if ( isRowFull ) { rowMeta . setRowFull ( true ) ; eventDAO . saveOrUpdate ( rowMeta ) ; } } event . setSeatAllocated ( true ) ; eventDAO . saveOrUpdate ( event ) ; }
tr	7	public static void main ( String [ ] args ) throws IOException , InterruptedException { File testDir = new File ( System . getProperty ( "java.class.path" ) + "/../tests/pa2_tests" ) ; int failures = 0 ; for ( File x : testDir . listFiles ( ) ) { if ( x . getName ( ) . endsWith ( "out" ) || x . getName ( ) . startsWith ( "." ) ) continue ; ReturnInfo info = runTest ( x ) ; int returnCode = info . returnCode ; String ast = info . ast ; if ( x . getName ( ) . indexOf ( "pass" ) != - 1 ) { if ( returnCode == 0 ) { String actualAST = getAST ( new FileInputStream ( x . getPath ( ) + ".out" ) ) ; if ( actualAST . equals ( ast ) ) System . out . println ( x . getName ( ) + " parsed successfully and has a correct AST!" ) ; else { System . err . println ( x . getName ( ) + " parsed successfully but has an incorrect AST!" ) ; failures ++ ; } } else { failures ++ ; System . err . println ( x . getName ( ) + " failed to be parsed!" ) ; } } else { if ( returnCode == 4 ) System . out . println ( x . getName ( ) + " failed successfully!" ) ; else { System . err . println ( x . getName ( ) + " did not fail properly!" ) ; failures ++ ; } } } System . out . println ( failures + " failures in all." ) ; }
tr	0	private void clearAddTaxPanel ( ) { addTaxNameField . setText ( "" ) ; addTaxRateField . setText ( "" ) ; }
tr	6	public ArrayList < ForecastObject > requestForecast ( ) { URL url ; HttpURLConnection conn ; BufferedReader rd ; String line ; String result = "" ; try { url = new URL ( "http://api.openweathermap.org/data/2.5/forecast/daily?lat=55.681589&lon=12.529092&cnt=14&mode=json&units=metric" ) ; conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; rd = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; while ( ( line = rd . readLine ( ) ) != null ) { result += line ; } rd . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { JSONParser jsonParser = new JSONParser ( ) ; JSONObject jsonObject = ( JSONObject ) jsonParser . parse ( result ) ; JSONArray list = ( JSONArray ) jsonObject . get ( "list" ) ; Iterator i = list . iterator ( ) ; while ( i . hasNext ( ) ) { JSONObject innerObj = ( JSONObject ) i . next ( ) ; Date date = new Date ( ( long ) innerObj . get ( "dt" ) * 1000 ) ; String string_date = date . toString ( ) ; JSONObject temp = ( JSONObject ) innerObj . get ( "temp" ) ; double celsius = ( double ) temp . get ( "day" ) ; String temperatur = String . valueOf ( celsius ) ; JSONArray subList = ( JSONArray ) innerObj . get ( "weather" ) ; Iterator y = subList . iterator ( ) ; while ( y . hasNext ( ) ) { JSONObject childObj = ( JSONObject ) y . next ( ) ; weatherDescription = ( String ) childObj . get ( "description" ) ; } forecastList . add ( new ForecastObject ( string_date , temperatur , weatherDescription ) ) ; } } catch ( ParseException ex ) { ex . printStackTrace ( ) ; } catch ( NullPointerException ex ) { ex . printStackTrace ( ) ; } return forecastList ; }
tr	1	private void tFLoginKeyPressed ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { jPFSenha . requestFocusInWindow ( ) ; } }
tr	1	private JTextField getTextFieldServersIP ( ) { if ( textFieldServersIP == null ) { textFieldServersIP = new JTextField ( ) ; textFieldServersIP . setText ( "192.168.1.181" ) ; textFieldServersIP . setBounds ( 33 , 125 , 118 , 23 ) ; textFieldServersIP . setColumns ( 10 ) ; } return textFieldServersIP ; }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	7	static public < T extends TypeT > Assoc < T > assoc ( class < T > cls , ToIntFunction < T > key , String suffix ) { T [ ] sorted = indexed ( cls ) ; int n = sorted . length ; Arrays . sort ( sorted , ( a , b ) -> Integer . compare ( key . applyAsInt ( a ) , key . applyAsInt ( b ) ) ) ; int [ ] keys = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { keys [ i ] = key . applyAsInt ( sorted [ i ] ) ; } String desc = cls . getSimpleName ( ) + " " + suffix ; for ( int i = 1 ; i < n ; i ++ ) { if ( keys [ i - 1 ] == keys [ i ] ) { throw new IllegalArgumentException ( cls + " Collision: " + keys [ i ] ) ; } } int keyOffset = keys [ 0 ] ; int span = 1 + keys [ n - 1 ] - keyOffset ; if ( span == n ) { return new Dense < > ( desc , sorted , keyOffset ) ; } else if ( span <= 2 * n && span > 0 ) { int [ ] where = new int [ span ] ; Arrays . fill ( where , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { where [ keys [ i ] - keyOffset ] = i ; } return new Sparse < > ( desc , sorted , keyOffset , where ) ; } else { return new Search < > ( desc , sorted , keys ) ; } }
tr	0	private void enqueueCommands ( String command ) { queue . offer ( command ) ; }
tr	3	public Coordinate getCoordinates ( ) { if ( lat != null && lon != null ) { return new Coordinate ( lon , lat ) ; } else if ( grid != null ) { return LocatorUtil . loc2degminsec ( grid ) ; } else { return null ; } }
tr	8	public Object getValueAt ( int row , int column ) { row = this . currentPage * this . PAGE_SIZE + row ; if ( column < 30 ) { return 100000 * column + row ; } else if ( column < 60 ) { return row * 2.333333 ; } else if ( column < 90 ) { if ( row % 2 == 0 ) return boolean . true ; return boolean . false ; } else if ( column < 120 ) { return "row " + ( ( MAX_PAGE + 1 ) * this . PAGE_SIZE - row ) + "  column=" + column ; } else if ( column < 150 ) { return "irow " + ( ( MAX_PAGE + 1 ) * this . PAGE_SIZE - row ) ; } else if ( column < 180 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . roll ( Calendar . DAY_OF_YEAR , row ) ; return calendar . getTime ( ) ; } else if ( column < 210 ) { return row * 10 + 900000000000000000 ; } return null ; }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	5	@ Override public void draw ( SpriteBatch batch ) { if ( object . isVisible ( ) ) { graphics . draw ( batch ) ; } if ( animate ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = explosionAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - 1f ) , ( animPos . y - 1f ) , 2 , 2 ) ; if ( explosionAnimation . isAnimationFinished ( stateTime ) ) { animate = false ; WorldObject . removelist . add ( object ) ; } } else if ( animateMiss ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = splashAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - .5f ) , ( animPos . y - .5f ) , 1 , 1 ) ; if ( splashAnimation . isAnimationFinished ( stateTime ) ) { animateMiss = false ; WorldObject . removelist . add ( object ) ; } } }
tr	7	public short [ ] play ( int frames ) { short [ ] returnSound ; if ( currentFrame == 0 ) if ( isInstrumentBox ( ) ) { InstrumentBox t = ( InstrumentBox ) sound ; t . play ( note ) ; } else reset ( ) ; if ( sound . hasNext ( ) ) { returnSound = sound . next ( frames ) ; if ( returnSound . length < frames * channelCount ) { short [ ] r = new short [ frames ] ; for ( int i = 0 ; i < returnSound . length ; i ++ ) r [ i ] = returnSound [ i ] ; } } else returnSound = new short [ frames * channelCount ] ; if ( frames > getLength ( ) - currentFrame ) { short [ ] r = new short [ ( getLength ( ) * channelCount ) - currentFrame ] ; for ( int i = 0 ; i < r . length ; i ++ ) r [ i ] = returnSound [ i ] ; returnSound = r ; } currentFrame += returnSound . length / channelCount ; return returnSound ; }
tr	8	public static boolean dragToSlot ( final Ability a , final int slot ) { int id = getAbilityId ( slot ) ; return ( a != null && checkIndex ( slot ) ) && ( ( id > 0 && id == a . getAbilityId ( ) ) || ( setLocked ( false ) && a . show ( ) && makeReadyForInteract ( ) && dragBetween ( a . getChild ( ) , getMainChild ( slot ) ) && new TimedCondition ( 2000 ) { @ Override public boolean isDone ( ) { return getAbilityId ( slot ) == a . getAbilityId ( ) ; } } . waitStop ( ) ) ) ; }
tr	7	public void performMove ( int x , int y , int m , int playerNr , boolean check ) { switch ( m ) { case MOVE_LEFT : x = moveLeft ( x ) ; break ; case MOVE_RIGHT : x = moveRight ( x ) ; break ; case MOVE_UP : y = moveUp ( y ) ; break ; case MOVE_DOWN : y = moveDown ( y ) ; break ; } if ( check ) { if ( isValidPosition ( x , y ) ) if ( isEmpty ( x , y ) ) placePlayerWall ( x , y , playerNr ) ; else throw new IllegalStateException ( String . format ( "move position of P%d contains a wall (%d  %d) %s" , playerNr , x , y , m ) ) ; else throw new IllegalStateException ( String . format ( "invalid position after move to (%d  %d) %s" , x , y , m ) ) ; } else placePlayerWall ( x , y , playerNr ) ; }
tr	4	public Rectangle2D getDrawableArea ( Unit unit ) { double w = paperWidth . getValue ( unit ) ; double x = 0 ; if ( leftMargin != null ) { x = leftMargin . getValue ( unit ) ; w -= x ; } if ( rightMargin != null ) { w -= rightMargin . getValue ( unit ) ; } double h = paperHeight . getValue ( unit ) ; double y = 0 ; if ( topMargin != null ) { y = topMargin . getValue ( unit ) ; h -= y ; } if ( bottomMargin != null ) { h -= bottomMargin . getValue ( unit ) ; } return new Rectangle2D . double ( x , y , w , h ) ; }
tr	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
tr	2	public ArrayList ListaTodos ( ) { ArrayList listaCartao = new ArrayList < > ( ) ; String sql = "SELECT * FROM CARTOES ORDER BY CARTAO_ID" ; try { Connection con = Conectar . getInstance ( ) . conect ( ) ; preparar = con . prepareStatement ( sql ) ; ResultSet resultado = preparar . executeQuery ( ) ; while ( resultado . next ( ) ) { listaCartao . add ( new Object [ ] { resultado . getLong ( "cartao_id" ) , resultado . getLong ( "saldo_cartao" ) } ) ; } preparar . close ( ) ; } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , ex . getMessage ( ) ) ; } return listaCartao ; }
tr	4	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || ! ( obj instanceof AccessibleField ) ) { return false ; } final AccessibleField other = ( AccessibleField ) obj ; return this . name . equals ( other . name ) && this . type . equals ( other . type ) ; }
tr	7	public ArrayList < BeanOutbox > getOutbox ( String codigo ) { ArrayList < BeanOutbox > list = new ArrayList < BeanOutbox > ( ) ; String SQL1 = "SELECT * from mensajes where idProfesores='" + codigo + "' order by fecha desc" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int idmensaje = rs1 . getInt ( "id" ) ; BeanOutbox bean = new BeanOutbox ( ) ; bean . setId ( idmensaje ) ; String destina = "" ; String SQL2 = "Select prof.nombre from mensajesprofesores as menp inner" + " join profesores as prof on prof.id=menp.idProfesores where " + "menp.idMensajes='" + idmensaje + "'" ; Statement st2 = getSgd ( ) . createStatement ( ) ; ResultSet rs2 = getSgd ( ) . getResultSet ( SQL2 , st2 ) ; int count = 0 ; while ( rs2 != null && rs2 . next ( ) ) { destina += rs2 . getString ( "nombre" ) + "; " ; count += 1 ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } bean . setDestinatarios ( destina ) ; bean . setDestinatariosCount ( count ) ; bean . setFechaEnviado ( rs1 . getDate ( "fecha" ) ) ; String txt = rs1 . getString ( "texto" ) ; bean . setTexto ( txt ) ; bean . setAttachments ( loadAttachments ( idmensaje ) ) ; list . add ( bean ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( MensajesCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return list ; }
tr	5	private void checkConnection ( ) { if ( isConnected ( ) ) return ; if ( getServerName ( ) == null || getServerPort ( ) == null ) { return ; } InetAddress addr = null ; try { addr = InetAddress . getByName ( getServerName ( ) . getServerName ( ) ) ; } catch ( UnknownHostException e ) { Logger . getLogger ( getClass ( ) ) . error ( "Host nao encontrado! " + getServerName ( ) ) ; return ; } SocketAddress sockaddr = new InetSocketAddress ( addr , getServerPort ( ) . getServerPort ( ) ) ; java . net . Socket rawSocket = new java . net . Socket ( ) ; try { Logger . getLogger ( getClass ( ) ) . info ( "Conectando a " + getServerName ( ) + ":" + getServerPort ( ) + "..." ) ; rawSocket . connect ( sockaddr ) ; Logger . getLogger ( getClass ( ) ) . info ( "Conectado a " + getServerName ( ) + ":" + getServerPort ( ) ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( "Erro na conexao a " + getServerName ( ) + ":" + getServerPort ( ) + " " + e . getMessage ( ) , e ) ; return ; } setSocket ( socketFactory . createSocket ( rawSocket ) ) ; getSocket ( ) . addObserver ( this ) ; new Thread ( getSocket ( ) , "Server " + rawSocket . getInetAddress ( ) . getHostName ( ) ) . start ( ) ; }
tr	3	private void initApplicationHome ( ) { String applicationHome = System . getProperty ( "application.home" ) ; if ( applicationHome != null ) { return ; } File bootstrapJar = new File ( System . getProperty ( "user.dir" ) , "bootstrap.jar" ) ; if ( bootstrapJar . exists ( ) ) { try { File parentDir = new File ( System . getProperty ( "user.dir" ) , ".." ) ; System . setProperty ( "application.home" , parentDir . getCanonicalPath ( ) ) ; } catch ( Exception e ) { System . setProperty ( "application.home" , System . getProperty ( "user.dir" ) ) ; } } else { System . setProperty ( "application.home" , System . getProperty ( "user.dir" ) ) ; } applicationHome = System . getProperty ( "application.home" ) ; }
tr	3	public JSONWriter array ( ) throws JSONException { if ( this . mode == i || this . mode == o || this . mode == a ) { this . push ( null ) ; this . append ( "[" ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced array." ) ; }
tr	0	public String getLocunit ( ) { return locunit ; }
tr	2	private void renderTypeListWithCommas ( DorpType [ ] types ) { if ( types . length == 0 ) return ; renderType ( types [ 0 ] ) ; for ( int i = 1 ; i < types . length ; i ++ ) { result . append ( "  " ) ; renderType ( types [ i ] ) ; } }
tr	0	@ Override public GameCharacterObject setVy ( float vy ) { this . vy = vy ; return this ; }
tr	6	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	0	public byte [ ] getZippedFileBytes ( String path ) throws IOException { byte [ ] uncompressedBytes = getFileBytes ( path ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; GZIPOutputStream zippedStream = new GZIPOutputStream ( output ) ; zippedStream . write ( uncompressedBytes ) ; byte [ ] compressedBytes = new byte [ output . size ( ) ] ; zippedStream . write ( compressedBytes ) ; return compressedBytes ; }
tr	1	public int getBlankPosition ( ) { return mPosition < HORIZONTAL_BLANK ? mPosition : HORIZONTAL_BLANK - 1 ; }
tr	8	private void readValues ( Stream stream ) { do { int i = stream . readUnsignedByte ( ) ; boolean dummy ; if ( i == 0 ) return ; else if ( i == 1 ) { anInt390 = stream . read3Bytes ( ) ; rgbToHsl ( anInt390 ) ; } else if ( i == 2 ) anInt391 = stream . readUnsignedByte ( ) ; else if ( i == 3 ) dummy = true ; else if ( i == 5 ) aBoolean393 = false ; else if ( i == 6 ) stream . readString ( ) ; else if ( i == 7 ) { int j = hue ; int k = saturation ; int l = lightness ; int i1 = anInt397 ; int j1 = stream . read3Bytes ( ) ; rgbToHsl ( j1 ) ; hue = j ; saturation = k ; lightness = l ; anInt397 = i1 ; anInt398 = i1 ; } else { System . out . println ( "Error unrecognised config code: " + i ) ; } } while ( true ) ; }
tr	6	public double [ ] makeMeantoneRatios ( double x ) { double [ ] data = new double [ 12 ] ; double ratio = 1.0 ; int n = 0 ; for ( int i = 0 ; i <= 6 ; i ++ ) { data [ n ] = ratio ; n += 7 ; if ( n >= 12 ) n -= 12 ; ratio = ratio * x ; if ( ratio > 2.0 ) ratio /= 2.0 ; } ratio = 1.0 ; n = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { data [ n ] = ratio ; n -= 7 ; if ( n < 0 ) n += 12 ; ratio = ratio / x ; if ( ratio < 1.0 ) ratio *= 2.0 ; } return ( data ) ; }
tr	5	public boolean makeGuess ( String kb , String guess , String observation ) { if ( CURRENT_GUESS ++ > MAX_GUESSES ) return false ; String possible_answer = "(" + kb + ")" ; if ( guess != null && guess . length ( ) > 0 ) { possible_answer += "& (" + guess + ")" ; } WFF observationWFF = new WFF ( observation ) ; WFF answerWFF = new WFF ( possible_answer ) ; boolean result = false ; if ( answerWFF . issat ( ) ) result = answerWFF . entails ( observationWFF ) ; if ( _VERBOSE ) System . out . println ( possible_answer + " isSat? " + result ) ; return result ; }
tr	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
tr	9	void append ( DNSIncoming that ) { if ( this . isQuery ( ) && this . isTruncated ( ) && that . isQuery ( ) ) { if ( that . numQuestions > 0 ) { if ( Collections . EMPTY_LIST . equals ( this . questions ) ) this . questions = Collections . synchronizedList ( new ArrayList ( that . numQuestions ) ) ; this . questions . addAll ( that . questions ) ; this . numQuestions += that . numQuestions ; } if ( Collections . EMPTY_LIST . equals ( answers ) ) { answers = Collections . synchronizedList ( new ArrayList ( ) ) ; } if ( that . numAnswers > 0 ) { this . answers . addAll ( this . numAnswers , that . answers . subList ( 0 , that . numAnswers ) ) ; this . numAnswers += that . numAnswers ; } if ( that . numAuthorities > 0 ) { this . answers . addAll ( this . numAnswers + this . numAuthorities , that . answers . subList ( that . numAnswers , that . numAnswers + that . numAuthorities ) ) ; this . numAuthorities += that . numAuthorities ; } if ( that . numAdditionals > 0 ) { this . answers . addAll ( that . answers . subList ( that . numAnswers + that . numAuthorities , that . numAnswers + that . numAuthorities + that . numAdditionals ) ) ; this . numAdditionals += that . numAdditionals ; } } else { throw new IllegalArgumentException ( ) ; } }
tr	0	public static void main ( String [ ] args ) throws IOException { SGIPServerIOHandler handler = new SGIPServerIOHandler ( ) ; SocketAcceptor acceptor = new SocketAcceptor ( ) ; acceptor . getFilterChain ( ) . addLast ( "protocol" , new ProtocolCodecFilter ( new BindCodecFactory ( false ) ) ) ; acceptor . bind ( new InetSocketAddress ( PORT ) , handler ) ; System . out . println ( "server is listenig at port " + PORT ) ; }
tr	9	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	3	public String topoligicalSort ( ) { int orig_nVerts = numNodes ; while ( numNodes > 0 ) { int currentVertex = noSuccessors ( ) ; if ( currentVertex == - 1 ) { return "ERROR: Graph has cycles" ; } sortedArray [ numNodes - 1 ] = NodeList [ currentVertex ] . label ; System . out . println ( "sortedArray[numNodes - 1] : " + sortedArray [ numNodes - 1 ] ) ; deleteVertex ( currentVertex ) ; } String display = "Topologically sorted order: " + "\n" ; for ( int j = 0 ; j < orig_nVerts ; j ++ ) display += sortedArray [ j ] ; return display ; }
tr	8	public boolean restartLevel ( ) { GameState state = StateUtil . getGameState ( proxy ) ; if ( state == GameState . WON || state == GameState . LOST ) { proxy . send ( new ProxyClickMessage ( 420 , 380 ) ) ; System . out . println ( " restart the level " ) ; try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } else if ( state == GameState . PLAYING ) { proxy . send ( new ProxyClickMessage ( 100 , 39 ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } try { Thread . sleep ( 4000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "Zooming out" ) ; for ( int k = 0 ; k < 15 ; k ++ ) { proxy . send ( new ProxyMouseWheelMessage ( - 1 ) ) ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } return true ; }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<BalloonStyle" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . color != null && this . isColorDirty ) { change += "<color>" + SpecialCaseFormatter . toKMLString ( this . color ) + "</color>\n" ; this . isColorDirty = false ; } if ( this . bgColor != null && this . isBgColorDirty ) { change += "<bgColor>" + SpecialCaseFormatter . toKMLString ( this . bgColor ) + "</bgColor>\n" ; this . isBgColorDirty = false ; } if ( this . textColor != null && this . isTextColorDirty ) { change += "<textColor>" + SpecialCaseFormatter . toKMLString ( this . textColor ) + "</textColor>\n" ; this . isTextColorDirty = false ; } if ( this . text != null && this . isTextDirty ) { change += "<text>" + SpecialCaseFormatter . toKMLString ( this . text ) + "</text>\n" ; this . isTextDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</BalloonStyle>\n" ; } setNotDirty ( ) ; return change ; }
tr	9	public final void keyReleased ( KeyEvent keyevent ) { idleTime = 0 ; int i = keyevent . getKeyCode ( ) ; char c = keyevent . getKeyChar ( ) ; if ( c <  ) c =  ; if ( i == 37 ) c =  ; if ( i == 39 ) c =  ; if ( i == 38 ) c =  ; if ( i == 40 ) c =  ; if ( i == 17 ) c =  ; if ( i == 8 ) c =  ; if ( i == 127 ) c =  ; if ( i == 9 ) c = 	 ; if ( i == 10 ) c = '' ; if ( c > 0 && c <  ) keyArray [ c ] = 0 ; }
tr	3	@ Override public boolean addItemToInventory ( Item item ) { if ( isRoomInInventory ( ) ) { for ( int i = 0 ; i < getInventorySize ( ) ; i ++ ) { if ( getItemInSlot ( i ) == null ) { setItemInSlot ( i , item ) ; break ; } } return true ; } else { return false ; } }
tr	7	private String genericString ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int c = 0 ; c < value . length ( ) ; c ++ ) { Character ch = value . charAt ( c ) ; if ( ch == '' ) { buffer . append ( "\\r" ) ; } else if ( ch == '' ) { buffer . append ( "\\n" ) ; } else if ( ch == " ) { buffer . append ( "\\\"" ) ; } else if ( ch == \ ) { buffer . append ( "\\\\" ) ; } else if ( 32 <= ch && ch <= 126 ) { buffer . append ( ch ) ; } else { buffer . append ( "\\x" + String . format ( "%02x" , Math . abs ( ( int ) ch ) ) ) ; } } return buffer . toString ( ) ; }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	8	@ Override public void run ( ) { enabled = true ; while ( enabled ) { try { Object o = Client . this . inputStream . readObject ( ) ; if ( ! enabled ) { NetServer . this . logger . log ( "object from client " + Client . this . getIp ( ) + " received but listening disabled" , ConsoleLogger . Type . INFO ) ; return ; } if ( o instanceof Message ) { NetServer . this . logger . log ( "received " + ( ( Message ) o ) . toString ( ) + " from " + Client . this . toString ( ) , ConsoleLogger . Type . DEBUG ) ; if ( o . equals ( Message . DISCONNECT ) ) { NetServer . this . disconnectClient ( Client . this ) ; } NetServer . this . messageReceived ( Client . this , ( Message ) o ) ; } else { NetServer . this . logger . log ( "non message type received from " + Client . this . toString ( ) , ConsoleLogger . Type . WARNING ) ; } } catch ( ClassNotFoundException | IOException ex ) { if ( ! enabled && ex instanceof SocketException && ex . getMessage ( ) . equalsIgnoreCase ( "socket closed" ) ) { NetServer . this . logger . log ( "listening from " + Client . this . toString ( ) + " stopped" , ConsoleLogger . Type . INFO ) ; return ; } else { NetServer . this . logger . log ( "error during reading object from " + Client . this . getIp ( ) , ConsoleLogger . Type . ERROR ) ; ex . printStackTrace ( System . err ) ; } } } }
tr	7	private static AccessibleObjectCandidate betterSignature ( AccessibleObjectCandidate methodCandidate , AccessibleObjectCandidate methodCandidate1 ) { final class [ ] parameters = methodCandidate . getParameterTypes ( ) ; final class [ ] parameters1 = methodCandidate1 . getParameterTypes ( ) ; int c = 0 , c1 = 0 ; for ( int i = 0 ; i < parameters . length ; i ++ ) { final class parameterClass = parameters [ i ] ; final class parameterClass1 = parameters1 [ i ] ; if ( parameterClass != parameterClass1 ) { if ( parameterClass . isPrimitive ( ) && parameterClass1 . isPrimitive ( ) ) { if ( ( ( Integer ) primitiveRankings . get ( parameterClass . getName ( ) ) ) . intValue ( ) < ( ( Integer ) primitiveRankings . get ( parameterClass1 . getName ( ) ) ) . intValue ( ) ) { c ++ ; } else { c1 ++ ; } } else if ( parameterClass . isAssignableFrom ( parameterClass1 ) ) { c1 ++ ; } else { c ++ ; } } } if ( c1 > c ) { return methodCandidate1 ; } return methodCandidate ; }
tr	9	static Object get ( Object subtree , Object key , int khash ) { if ( subtree == null ) return NO_ELEMENT ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , khash ) ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( ( bin_srch_res & BIN_SEARCH_FOUND_MASK ) == BIN_SEARCH_FOUND && eql ( key , ary [ idx ] ) ) return ary [ idx + ( ary . length >> 1 ) ] ; else return NO_ELEMENT ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int nkhash = node . khash ; if ( khash == nkhash ) { if ( nkey instanceof EquivalentMap ) { ArrayList < Entry > al = ( ( EquivalentMap ) nkey ) . contents ; for ( int i = 0 , len = al . size ( ) ; i < len ; ++ i ) { Entry ent = al . get ( i ) ; if ( eql ( key , ent . key ) ) return ent . value ; } return NO_ELEMENT ; } else if ( eql ( key , nkey ) ) return node . value ; else return NO_ELEMENT ; } else if ( khash < nkhash ) return get ( node . left , key , khash ) ; else return get ( node . right , key , khash ) ; } }
tr	2	public static int safeLongToInt ( long l ) { if ( l < Integer . MIN_VALUE || l > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( l + " cannot be cast to int without changing its value." ) ; } return ( int ) l ; }
tr	9	public ShortUrl getNext ( ) throws InvalidShortUrlException , ShortUrlOverflow { String currentString = m_shortUrlString ; String finalString = null ; int index = MAX_NUMBER_OF_DIGITS - 1 ; do { char currentChar = currentString . charAt ( index ) ; char incrementedAlphaNumber =  ; int currentNumber = ( int ) currentChar ; if ( ( ( currentNumber >= ( int ) 0 && currentNumber < ( int ) 9 ) ) || ( currentNumber >= ( int ) A && currentNumber < ( int ) Z ) ) { currentNumber = currentNumber + 1 ; incrementedAlphaNumber = ( char ) currentNumber ; } else if ( currentNumber == ( int ) 9 ) { incrementedAlphaNumber = A ; } else if ( currentNumber == ( int ) Z ) { StringBuilder s = new StringBuilder ( currentString ) ; s . setCharAt ( index , 0 ) ; currentString = s . toString ( ) ; index = index - 1 ; } if (  != incrementedAlphaNumber ) { StringBuilder string = new StringBuilder ( ) ; string . append ( currentString . substring ( 0 , index ) ) ; string . append ( incrementedAlphaNumber ) ; string . append ( currentString . substring ( index + 1 ) ) ; finalString = string . toString ( ) ; } if ( index < 0 ) { throw new ShortUrlOverflow ( "Unable to generate next Url due to overflow." ) ; } } while ( finalString == null ) ; ShortUrl url = new ShortUrl ( finalString ) ; return url ; }
tr	0	public static LatLonFormat fromValue ( String v ) { return valueOf ( v ) ; }
tr	5	public void setTileArrays2 ( int tilePairs2 ) { try { int o = ( tilePairs2 - 1 ) ; arrTiles2 = new int [ o + 1 ] ; for ( int e : arrTiles1 ) { arrTiles2 [ o ] = e ; o -- ; } if ( debug ) { String arr2 = "" ; for ( int f : arrTiles2 ) { arr2 = arr2 + " " + f ; } jtMatchStatus . append ( "\n setTileArrays2: " + arr2 . substring ( 1 ) ) ; } } catch ( Exception x ) { if ( debug ) { jtMatchStatus . append ( "\n setTileArrays2: " + x . toString ( ) ) ; } } }
tr	3	public String cargarArchivo ( File file ) { try { BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; StringBuilder entrada = new StringBuilder ( ) ; String linea ; while ( ( linea = br . readLine ( ) ) != null ) { entrada . append ( linea ) ; if ( br . ready ( ) ) entrada . append ( System . lineSeparator ( ) ) ; } return entrada . toString ( ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } return null ; }
tr	7	protected boolean testEquals ( Object that ) { boolean res = true ; Map < String , Object > fields1 = getMineAndParentFields ( ForEquals . class , this ) ; Map < String , Object > fields2 = getMineAndParentFields ( ForEquals . class , that ) ; if ( ! isEmpty ( fields1 ) && fields2 . size ( ) >= fields1 . size ( ) ) { for ( String key : fields1 . keySet ( ) ) { Object v1 = fields1 . get ( key ) ; Object v2 = fields2 . get ( key ) ; if ( v1 != null ) { if ( v2 != null ) { res &= v1 . equals ( v2 ) ; } else { res = false ; } } else { if ( v2 != null ) { res = false ; } else { } } if ( ! res ) { break ; } } } else { res = super . equals ( that ) ; } return res ; }
tr	2	private void checkCrossings ( final Player player , final Location from , final Location to ) { Message entered = null ; final Set < Region > regions = new HashSet < Region > ( ) ; regions . addAll ( this . catalog . cached ( from . getWorld ( ) , from . getBlockX ( ) >> 4 , from . getBlockZ ( ) >> 4 ) ) ; if ( ! BoundaryAlerter . sameChunk ( from , to ) ) regions . addAll ( this . catalog . cached ( to . getWorld ( ) , to . getBlockX ( ) >> 4 , to . getBlockZ ( ) >> 4 ) ) ; entered = this . checkRegions ( player , from , to , regions , entered ) ; if ( entered != null ) Main . courier . submit ( new Individual ( player ) , entered ) ; }
tr	1	public static void main ( String [ ] args ) { File dictionary = new File ( "dictionary.txt" ) ; try { List < List < String >> anagrams = getAnagramsHT ( dictionary ) ; System . out . println ( anagrams . toString ( ) ) ; } catch ( IOException e ) { System . err . println ( "IO EXCEPTION ENCOUNTERED!!" ) ; e . printStackTrace ( ) ; } }
tr	3	public static void benchmark ( ) throws Exception { int N = 100000 ; String [ ] methodsToCompare = { "canWriteLetterFromMagazine1" , "canWriteLetterFromMagazine2" , "canWriteLetterFromMagazine3" , "canWriteLetterFromMagazine4" , "canWriteLetterFromMagazine5" , "canWriteLetterFromMagazine6" , "canWriteLetterFromMagazine7" } ; String magazine = cleanInput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; String letter = cleanInput ( "hogs are swine" ) ; for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.twelve.Problem12_09" ) ; Method method = clazz . getDeclaredMethod ( methodName , String . class , String . class ) ; long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean retVal = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retVal == false ) throw new Exception ( "wrong result!" ) ; } long endTime = System . nanoTime ( ) ; System . out . println ( "Elapsed time for " + methodName + ": " + ( endTime - startTime ) / 1000000000.0 + " seconds" ) ; } }
tr	9	private String getIdActivities ( final ArrayList < BeanConceptos > listConceptos , final int idConcepto ) { String condition = " AND ac.id IN  (" ; String allConceptos = "" ; if ( idConcepto == - 1 ) { for ( int i = 1 ; i < listConceptos . size ( ) ; i ++ ) { allConceptos += listConceptos . get ( i ) . id + " " ; } if ( ! allConceptos . equals ( "" ) ) { allConceptos = " (" + StringUtils . BeforeLast ( allConceptos , " " ) + ")" ; condition = " AND ac.id NOT IN  (" ; } else { allConceptos = " (-1) " ; condition = "" ; } } String SQL1 = "SELECT idActividad FROM " + client . getPlusDbName ( ) + "sgd_conceptosactividades where idConcepto=" + idConcepto ; if ( idConcepto == - 1 ) { SQL1 = "SELECT idActividad FROM " + client . getPlusDbName ( ) + "sgd_conceptosactividades where idConcepto IN " + allConceptos ; } String extracond = "" ; try { Statement st = client . getPlusDb ( ) . createStatement ( ) ; ResultSet rs1 = client . getPlusDb ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { extracond += rs1 . getInt ( "idActividad" ) + " " ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ActividadesCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( ! extracond . equals ( "" ) ) { condition += StringUtils . BeforeLast ( extracond , " " ) + ") " ; } else { condition = "" ; if ( idConcepto > 0 ) condition += "-1) " ; } return condition ; }
tr	4	public Hand < Card > getAllCardsInOthersHands ( String playerId ) { Hand < Card > hand = new Hand < Card > ( ) ; int size = this . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { AnnotatedCard c = this . get ( i ) ; if ( ! c . getLabel ( ) . equals ( "p_" + playerId ) && ( c . getLabel ( ) . startsWith ( "p_" ) || c . getLabel ( ) . startsWith ( "u_" ) ) ) { hand . add ( c ) ; } } return hand ; }
tr	8	public static void main ( String [ ] args ) { int grade ; grade = Integer . parseInt ( args [ 0 ] ) ; if ( grade <= 100 && grade >= 85 ) System . out . println ( "HD" ) ; else if ( grade <= 84 && grade >= 75 ) System . out . println ( "D" ) ; else if ( grade <= 74 && grade >= 65 ) System . out . println ( "C" ) ; else if ( grade <= 64 && grade >= 50 ) System . out . println ( "P" ) ; else System . out . println ( "F" ) ; }
tr	7	public List < CodeList > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < CodeList > codeLists = new ArrayList < CodeList > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeList" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { CodeList cl = processCodeList ( se , eventReader ) ; codeLists . add ( cl ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeLists" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { endTagReached = true ; } break ; } } return codeLists ; }
tr	5	private int [ ] setDistancePriority ( int xdiff , int ydiff ) { int priority [ ] = { - 1 , - 1 , - 1 , - 1 } ; if ( ( Math . abs ( xdiff ) > ( Math . abs ( ydiff ) ) ) ) { if ( ( xdiff ) > 0 ) { priority [ 0 ] = 180 ; priority [ 3 ] = 0 ; } else { priority [ 0 ] = 0 ; priority [ 3 ] = 180 ; } if ( ( ydiff ) > 0 ) { priority [ 1 ] = 90 ; priority [ 2 ] = 270 ; } else { priority [ 1 ] = 270 ; priority [ 2 ] = 90 ; } } else { if ( ( ydiff ) > 0 ) { priority [ 0 ] = 90 ; priority [ 3 ] = 270 ; } else { priority [ 0 ] = 270 ; priority [ 3 ] = 90 ; } if ( ( xdiff ) > 0 ) { priority [ 1 ] = 180 ; priority [ 2 ] = 0 ; } else { priority [ 1 ] = 0 ; priority [ 2 ] = 180 ; } } return priority ; }
tr	1	@ Test public void setFormat_shouldThrowAnException_whenTypeIsNotStringAndFormatIsTime ( ) throws Exception { SimpleTypeSchema schema = new SimpleTypeSchema ( ) ; schema . setType ( SimpleType . NUMBER ) ; try { schema . setFormat ( "time" ) ; fail ( "Expected an exception" ) ; } catch ( IllegalArgumentException e ) { } }
tr	3	@ Override public Connection getConnection ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { return connection ; } else { connection = DriverManager . getConnection ( "jdbc:hsqldb:file:" + db + ";shutdown=true" , user , pass ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return connection ; }
tr	9	public void setVoisins ( ) { ArrayList < Neuron > voisins ; for ( int col = 0 ; col < colNumber ; col ++ ) { for ( int row = 0 ; row < rowNumber ; row ++ ) { voisins = new ArrayList < Neuron > ( ) ; if ( col < colNumber - 1 ) { voisins . add ( neurons . get ( row ) . get ( col + 1 ) ) ; } if ( col > 0 ) { voisins . add ( neurons . get ( row ) . get ( col - 1 ) ) ; } if ( row == 0 && neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row + 1 ) . get ( col ) ) ; } else if ( row == neurons . size ( ) - 1 && neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row - 1 ) . get ( col ) ) ; } else if ( neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row + 1 ) . get ( col ) ) ; voisins . add ( neurons . get ( row - 1 ) . get ( col ) ) ; } neurons . get ( row ) . get ( col ) . setNeighbors ( voisins ) ; } } }
tr	2	public void update ( float deltaTimeElapsedMs ) { speedX = bg1 . getSpeedX ( ) * 5 ; tileX += Util . factorByElapsedTimeMs ( speedX , deltaTimeElapsedMs ) ; tileBoundary . setBounds ( tileX , tileY , 40 , 40 ) ; if ( tileBoundary . intersects ( Player . perimeter ) && type != 0 ) { checkHorizontalCollision ( ) ; checkVerticalCollision ( ) ; } }
tr	2	public static void printList ( final List < ? > list ) { for ( final Object i : list ) System . out . println ( i ) ; }
tr	3	@ Override public boolean exists ( ) { return x >= 0 && y >= 0 && x < xlimit && y < ylimit ; }
tr	3	private Slot getSelectedSlot ( ) { Point p = Mouse . getPoint ( ) ; for ( int x = 0 ; x < this . craftingArea . length ; x ++ ) { for ( int y = 0 ; y < this . craftingArea [ 0 ] . length ; y ++ ) { if ( craftingArea [ x ] [ y ] . getBounds ( ) . contains ( p ) ) { return craftingArea [ x ] [ y ] ; } } } return null ; }
tr	7	private Model method206 ( int i , int j ) { Model model = ( Model ) aMRUNodes_264 . insertFromCache ( ( i << 16 ) + j ) ; if ( model != null ) return model ; if ( i == 1 ) model = Model . method462 ( j ) ; if ( i == 2 ) model = EntityDef . forID ( j ) . method160 ( ) ; if ( i == 3 ) model = client . myPlayer . method453 ( ) ; if ( i == 4 ) model = ItemDef . forID ( j ) . method202 ( 50 ) ; if ( i == 5 ) model = null ; if ( model != null ) aMRUNodes_264 . removeFromCache ( model , ( i << 16 ) + j ) ; return model ; }
tr	4	public LevelButton ( String level ) { super ( ) ; gp = GameProperties . parseMeta ( level ) ; setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; setLayout ( new GridBagLayout ( ) ) ; Font font = DataManager . loadFont ( "text.ttf" ) . deriveFont ( ( float ) 20 ) ; name = new JLabel ( gp . name ) ; name . setFont ( font . deriveFont ( ( float ) 20 ) ) ; name . setForeground ( current ) ; time = new JLabel ( "No Time" ) ; time . setForeground ( current ) ; time . setFont ( font . deriveFont ( ( float ) 20 ) ) ; if ( GameState . isCompleted ( gp . pack , gp . index ) ) time . setText ( timeFrom ( GameState . getTime ( gp . pack , gp . index ) ) ) ; ImageIcon i = null ; if ( ! GameState . isPlayable ( gp . pack , gp . index ) ) i = new ImageIcon ( DataManager . loadImage ( "locked.png" ) ) ; else if ( ! GameState . isCompleted ( gp . pack , gp . index ) ) i = new ImageIcon ( DataManager . loadImage ( "none.png" ) ) ; else if ( ! GameState . isSuccess ( gp . pack , gp . index ) ) i = new ImageIcon ( DataManager . loadImage ( "time.png" ) ) ; else i = new ImageIcon ( DataManager . loadImage ( "success.png" ) ) ; JLabel icon = new JLabel ( i ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . fill = gbc . HORIZONTAL ; gbc . gridx = 0 ; gbc . gridy = 0 ; gbc . weightx = 1 ; add ( name , gbc ) ; gbc . gridx ++ ; add ( time , gbc ) ; gbc . gridx ++ ; gbc . weightx = 0 ; gbc . fill = gbc . NONE ; add ( icon , gbc ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; }
tr	1	public void printPreorder ( BinarySearchTree tree , Node root ) { List < Node > preorder = tree . getPreorder ( root ) ; System . out . print ( "Preorder:\t" ) ; for ( int i = 0 ; i < preorder . size ( ) ; i ++ ) { System . out . print ( preorder . get ( i ) . getData ( ) + " " ) ; } System . out . println ( ) ; }
tr	2	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	2	@ Override public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( ( other instanceof DomainAssociations ) == false ) { return false ; } DomainAssociations rhs = ( ( DomainAssociations ) other ) ; return new EqualsBuilder ( ) . append ( ContactID , rhs . ContactID ) . append ( LocationID , rhs . LocationID ) . append ( additionalProperties , rhs . additionalProperties ) . isEquals ( ) ; }
tr	4	static void createNewPearltree ( Panel panel , boolean active ) { final Label item = createLabel ( ) ; final FlowPanel description = new FlowPanel ( ) ; item . setText ( "a new pearltree" ) ; if ( WebContent . onIpad ) { description . setStylePrimaryName ( PRIMARY_STYLE_NEWPEARLTREE ) ; panel . add ( description ) ; HTML newPearltreeBox = PopupElements . createHtml ( ) ; newPearltreeBox . setStylePrimaryName ( PopupElements . PRIMARY_STYLE_AVATARBOX ) ; newPearltreeBox . addStyleDependentName ( PopupElements . STYLE_SPECIAL_PADDING ) ; newPearltreeBox . setHTML ( NEW_PEARLTREE ) ; description . add ( newPearltreeBox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! WebContent . onIpad ) { item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_BOLD ) ; item . addStyleDependentName ( STYLE_PADDING ) ; } item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_ITEM ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { if ( WebContent . onIpad ) { description . addStyleDependentName ( STYLE_SELECTED_TIMER ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { DOM . removeElementAttribute ( TreeListUI . panelInside . getElement ( ) , "id" ) ; PopupControl . changeUI ( PopupUIs . NewTree ) ; } } ; t . schedule ( 120 ) ; } else { PopupControl . changeUI ( PopupUIs . NewTree ) ; } } } ) ; } else { item . addStyleDependentName ( STYLE_INACTIVE ) ; } }
tr	6	public boolean dropLink ( String name ) throws GlobalException , NoDataException { try { conectar ( user , pass , ip , port , db ) ; } catch ( ClassNotFoundException ex ) { throw new GlobalException ( "No se ha localizado el Driver" ) ; } catch ( SQLException e ) { throw new NoDataException ( "La base de datos no se encuentra disponible" ) ; } ResultSet rs = null ; Statement stmt = null ; try { stmt = conexion . createStatement ( ) ; String ss = "DROP DATABASE LINK " + name ; System . out . println ( ss ) ; rs = stmt . executeQuery ( ss ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; throw new GlobalException ( "Sentencia no valida" ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( stmt != null ) { stmt . close ( ) ; } desconectar ( ) ; return true ; } catch ( SQLException e ) { throw new GlobalException ( "Estatutos invalidos o nulos" ) ; } } }
tr	0	public static long getTime ( ) { return System . nanoTime ( ) ; }
tr	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
