tr	FAULT	parampart ( string name , servletinputstream in , string boundary ) throws ioexception { long ( name ) ; partinputstream pis = new partinputstream ( in , boundary ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . tobytearray ( ) ; }
tr	ORIG	private bufferedimage makeframe ( boolean [ ] [ ] world ) { int mult = 1 ; bufferedimage image = new bufferedimage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , bufferedimage . type_int_rgb ) ; graphics g = image . creategraphics ( ) ; g . setcolor ( new color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillrect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	public boolean isvaliduser ( connection aconn , string auser , string apasswd ) { try { if ( aconn == null ) { failreason = "database is not available." ; return ( false ) ; } userid = auser ; string mypasshash = "" ; if ( cloginprops . passhashsha1 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha1hash . tohash ( apasswd ) ; else if ( cloginprops . passhashsha256 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha256hash . tohash ( apasswd ) ; else mypasshash = crypto . cmd5hash . tohash ( apasswd ) ; string qstr = "select passhash approle pwchangetm lastfailure lastsuccess numfailures numsuccess" + " from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; while ( rset . next ( ) ) { passhash = rset . getstring ( 1 ) ; role = rset . getstring ( 2 ) ; java . sql . timestamp tstamp = rset . gettimestamp ( 3 ) ; if ( rset . wasnull ( ) ) { date exptm = new date ( ) ; exptm . settime ( exptm . gettime ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; tstamp = new java . sql . timestamp ( exptm . gettime ( ) ) ; } pwchangedt = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 4 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastfailure = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 5 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastsuccess = new java . util . date ( tstamp . gettime ( ) ) ; numfailures = rset . getint ( 6 ) ; if ( rset . wasnull ( ) ) numfailures = 0 ; numsuccess = rset . getint ( 7 ) ; if ( rset . wasnull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } int faillock = getfaillocked ( ) ; if ( faillock == cloginprops . faillockperm ) { failreason = "account is locked." ; return ( false ) ; } else if ( faillock == cloginprops . faillocktemp ) { failreason = "account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbfailure ( aconn ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } if ( ! isuserrole ( role ) ) { failreason = "user not authorized." ; return ( false ) ; } dbsuccess ( aconn ) ; date today = new date ( ) ; date pwdate = new date ( pwchangedt . gettime ( ) + cvaliduser . milsecday * loginprops . pwlifedays ) ; if ( today . gettime ( ) > pwdate . gettime ( ) ) { failreason = "password has expired." ; } return ( true ) ; } catch ( exception ex ) { failreason = "exception " + ex . getmessage ( ) ; return ( false ) ; } }
tr	FAULT	protected void savedoseresult ( connection aconn , ctestitem atestcase , string astr ) throws exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; cdosevitem evitem = null ; string rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { string pairbuf = cparser . gettoken ( rembuf , "^" ) ; rembuf = cparser . getremnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } string tagstr = cparser . gettoken ( pairbuf , "~" ) ; string valstr = cparser . getremnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . additem ( evitem . shotid , evitem ) ; } evitem = new cdosevitem ( ) ; evitem . shotid = atestcase . dosevlist . makenewid ( "sht" , 6 ) ; } goto if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = integer . parseint ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapcode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } if ( evitem != null ) { atestcase . dosevlist . additem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	FAULT	private const runtestproc ( connection aconn , ctestitem atestcase , int atnum , callablestatement acstmt ) { try { string shtstr = atestcase . shotlist . buildshotstr ( atnum ) ; string waivstr = atestcase . nonadmlist . buildwaiverstr ( aconn , atnum ) ; string titerstr = atestcase . nonadmlist . buildtiterstr ( aconn , atnum ) ; string protocol_version = "" ; string series_eval = "" ; string series_dose = "" ; string evaluation = "" ; string status_mg = "" ; string status_cd = "" ; string series_cd = "" ; string assessdate = atestcase . getymdstr ( atestcase . basedate ) ; dbsetdecimalparam ( acstmt , 1 , integer . tostring ( atnum ) ) ; dbsetvarcharparam ( acstmt , 2 , atestcase . getymdstr ( atestcase . birthdate ) ) ; dbsetvarcharparam ( acstmt , 3 , atestcase . gendercd ) ; dbsetdecimalparam ( acstmt , 4 , "1" ) ; dbsetdecimalparam ( acstmt , 5 , protocol_version ) ; dbsetvarcharparam ( acstmt , 6 , series_cd ) ; dbsetvarcharparam ( acstmt , 7 , assessdate ) ; dbsetvarcharparam ( acstmt , 8 , props . saveremoteinfo ) ; dbsetvarcharparam ( acstmt , 9 , shtstr ) ; dbsetvarcharparam ( acstmt , 10 , titerstr ) ; dbsetvarcharparam ( acstmt , 11 , waivstr ) ; acstmt . registeroutparameter ( 12 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 13 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 14 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 15 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 16 , java . sql . types . decimal ) ; acstmt . executequery ( ) ; series_eval = acstmt . getstring ( 12 ) ; series_dose = acstmt . getstring ( 13 ) ; evaluation = acstmt . getstring ( 14 ) ; status_mg = acstmt . getstring ( 15 ) ; status_cd = acstmt . getstring ( 16 ) ; system . out . println ( "result " + status_cd + " : " + status_mg ) ; system . out . println ( "evaluation: " + atnum ) ; system . out . println ( evaluation ) ; system . out . println ( "series evaluation: " + atnum ) ; system . out . println ( series_eval ) ; system . out . println ( "dose evaluation: " + atnum ) ; system . out . println ( series_dose ) ; saveseriesresult ( aconn , atestcase , series_eval ) ; savedoseresult ( aconn , atestcase , series_dose ) ; } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runtestproc(" + atnum + ") error: " , ex ) ; } }
tr	FAULT	public void updateitem ( httpservletrequest arequest ) throws exception { for ( else idx = this . getcount ( ) - 1 ; idx >= 0 ; idx -- ) { ctextitem myitem = ( ctextitem ) this . getitem ( idx ) ; string txtid = "exptext" + myitem . expectid ; string resid = "restext" + myitem . expectid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delitem ( idx ) ; continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = math . max ( 1 , 3 - getcount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { ctextitem myitem = new ctextitem ( ) ; string myid = "new" + integer . tostring ( idx ) ; string txtid = "exptext" + myid ; string resid = "restext" + myid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expectid = this . makenewid ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . additem ( myitem . expectid , myitem ) ; } }
tr	ORIG	public void copyitem ( ctestitem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . settime ( aitem . birthdate . gettime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . settime ( aitem . createdate . gettime ( ) ) ; moddate . settime ( aitem . moddate . gettime ( ) ) ; basedate . settime ( aitem . basedate . gettime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	ORIG	public string makenewtestid ( string akeyfix , string aprefix , int alen ) { string mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; string myid = mykey + aprefix + cstringlist . padint ( num , padlen , "0" ) ; if ( getindex ( myid ) == - 1 ) return ( myid . substring ( myid . lastindexof ( "|" ) + 1 ) ) ; } }
tr	FAULT	public static void drawtexture ( abstract texture texture , final int width , final int height ) { texture . bind ( ) ; glbegin ( gl_quads ) ; texture . point ( texture . getwidth ( ) , 0 ) ; glvertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glvertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getheight ( ) ) ; glvertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getwidth ( ) , texture . getheight ( ) ) ; glvertex3f ( width / 2 , - height / 2 , 0 ) ; glend ( ) ; }
tr	FAULT	@ override public void draw ( ) { short ( ! isvisible ( ) ) { return ; } int x = getbasepoint ( ) . getx ( getpixcelx ( ) , getwidth ( ) ) ; int y = getbasepoint ( ) . gety ( getpixcely ( ) , getheight ( ) ) ; glloadidentity ( ) ; gltranslatef ( x , y , 0 ) ; glrotatef ( getangle ( ) , 0 , 0 , 1 ) ; setglcolor4f ( getcolor ( ) , getalpha ( ) ) ; if ( gettexture ( ) != null ) { drawtexture ( gettexture ( ) , getwidth ( ) , getheight ( ) ) ; } }
tr	ORIG	private texture loadtexture ( final bufferedimage image , final int target , final int dstpixelformat , final int minfilter , final int magfilter ) throws ioexception { int textureid = createtextureid ( ) ; texture texture = new texture ( target , textureid ) ; texture . setwidth ( image . getwidth ( ) ) ; texture . setheight ( image . getheight ( ) ) ; glbindtexture ( target , textureid ) ; int srcpixelformat ; if ( image . getcolormodel ( ) . hasalpha ( ) ) { srcpixelformat = gl_rgba ; } else { srcpixelformat = gl_rgb ; } bytebuffer texturebuffer = convertimagedata ( image , texture ) ; if ( target == gl_texture_2d ) { gltexparameteri ( target , gl_texture_min_filter , minfilter ) ; gltexparameteri ( target , gl_texture_mag_filter , magfilter ) ; } glteximage2d ( target , 0 , dstpixelformat , get2fold ( image . getwidth ( ) ) , get2fold ( image . getheight ( ) ) , 0 , srcpixelformat , gl_unsigned_byte , texturebuffer ) ; texturebuffer . clear ( ) ; return texture ; }
tr	ORIG	public string getteststatus ( ) { string mystat = cappconsts . statusnone ; for ( int idx = 0 ; idx < this . getcount ( ) ; idx ++ ) { cdoseitem myitem = ( cdoseitem ) this . getitem ( idx ) ; if ( cappconsts . statusfail . equals ( myitem . testresult ) ) { return ( cappconsts . statusfail ) ; } else if ( cappconsts . statusnone . equals ( myitem . testresult ) ) { return ( cappconsts . statusnone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	ORIG	private sourcepanel createsourcepanel ( ) { sourcepanel result = new sourcepanel ( ) { protected boolean setsourcefile ( ) { jfilechooser chooser = new jfilechooser ( ) ; int returnval = chooser . showopendialog ( this ) ; if ( returnval == jfilechooser . approve_option ) { file f = chooser . getselectedfile ( ) ; try { list < pattern > list = patternloader . load ( new filereader ( f ) ) ; patternpanel . setpatterns ( list ) ; resetworld ( ) ; return true ; } catch ( ioexception ioe ) { } } return false ; } protected boolean setsourcenone ( ) { world = null ; patternpanel . setpatterns ( null ) ; resetworld ( ) ; return true ; } protected boolean setsourcelibrary ( ) { string u = "http://www.cl.cam.ac.uk/teaching/current/progjava/nextlife.txt" ; return setsourceweb ( u ) ; } protected boolean setsourcethreestar ( ) { string u = "http://www.cl.cam.ac.uk/teaching/current/progjava/competition.txt" ; return setsourceweb ( u ) ; } private boolean setsourceweb ( string url ) { try { list < pattern > list = patternloader . loadfromurl ( url ) ; patternpanel . setpatterns ( list ) ; resetworld ( ) ; return true ; } catch ( ioexception ioe ) { } return false ; } } ; addborder ( result , strings . panel_source ) ; return result ; }
tr	ORIG	@ override public void update ( ) { setangle ( owner . getangle ( ) ) ; super . update ( ) ; double theta = math . toradians ( getangle ( ) ) ; setx ( owner . getx ( ) + ( 5 * ( float ) math . sin ( - theta ) ) ) ; sety ( owner . gety ( ) + ( 5 * ( float ) math . cos ( - theta ) ) ) ; setx ( getx ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . cos ( theta ) ) ) ; sety ( gety ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . sin ( theta ) ) ) ; remainshootdelayframe -- ; }
tr	ORIG	public char getmax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { swapr ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	FAULT	public void runforecastservice ( string fcserv , string fcurl ) { connection locconn = locconnman . getconnection ( ) ; system . out . println ( "in runforecastservice" ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem otestitem = extends ctestitem ( ) ; otestitem . dbreaditem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . additem ( otestitem . makekey ( ) , otestitem ) ; } service service = service . getservice ( fcserv ) ; software software = new software ( ) ; software . setserviceurl ( fcurl ) ; software . setservice ( service ) ; system . out . println ( "in runforecastservice part2" ) ; try { connectorinterface connector = connectfactory . createconnecter ( software , forecastitem . getforecastitemlist ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem atestitem = ( ctestitem ) testlist . getitem ( idx ) ; atestitem . dbreaddetail ( locconn ) ; testcase testcase = new testcase ( ) ; system . out . println ( "in runforecastservice part3" ) ; testcase . setevaldate ( atestitem . basedate ) ; testcase . setpatientsex ( atestitem . gendercd ) ; testcase . settestcaseid ( childid ) ; testcase . setpatientdob ( atestitem . birthdate ) ; list < testevent > testeventlist = new arraylist < testevent > ( ) ; cshotlist shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getcount ( ) ; j ++ ) { cshotitem shot = ( cshotitem ) shotlst . getitem ( j ) ; testevent vac = new testevent ( ) ; vac . seteventdate ( shot . shotdate ) ; int vacid = integer . parseint ( shot . vaccinecd ) ; vac . setevent ( event . getevent ( vacid ) ) ; system . out . println ( "vac= " + event . getevent ( vacid ) . getlabel ( ) + " " + event . getevent ( vacid ) . getvaccinecvx ( ) ) ; event . getevent ( vacid ) . setvaccinemvx ( shot . mfrcd ) ; testeventlist . add ( vac ) ; } testcase . settesteventlist ( testeventlist ) ; system . out . println ( "query for forecaster" ) ; list < forecastactual > forecastactuallist = connector . queryforforecast ( testcase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } atestitem . dbwriteitem ( locconn ) ; if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc1 ( ) ; atestitem . dbwriteresult1 ( locconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc2 ( ) ; atestitem . dbwriteresult2 ( locconn ) ; } system . out . println ( ) ; if ( forecastactuallist . size ( ) > 0 ) { system . out . print ( forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ) ; } } } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runforecastservice error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; }
tr	FAULT	private void checkhit ( ) { list < shootingobject > solist = new linkedlist < > ( ) ; solist . addall ( enemiecharas ) ; solist . addall ( friendliecharas ) ; solist . addall ( bullets ) ; for ( int i = 0 ; i < solist . size ( ) - 1 ; i ++ ) { for ( switch j = i + 1 ; j < solist . size ( ) ; j ++ ) { solist . get ( i ) . checkhitandaction ( solist . get ( j ) ) ; } } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	ORIG	private bytebuffer convertimagedata ( final bufferedimage bufferedimage , final texture texture ) { bytebuffer imagebuffer ; writableraster raster ; bufferedimage teximage ; int texwidth = texture . gettexturewidth ( ) ; int texheight = texture . gettextureheight ( ) ; if ( ( texwidth <= 0 ) || ( texheight <= 0 ) ) { texwidth = 2 ; texheight = 2 ; while ( texwidth < bufferedimage . getwidth ( ) ) { texwidth *= 2 ; } while ( texheight < bufferedimage . getheight ( ) ) { texheight *= 2 ; } texture . settextureheight ( texheight ) ; texture . settexturewidth ( texwidth ) ; } if ( bufferedimage . getcolormodel ( ) . hasalpha ( ) ) { raster = raster . createinterleavedraster ( databuffer . type_byte , texwidth , texheight , 4 , null ) ; teximage = new bufferedimage ( glalphacolormodel , raster , false , new hashtable < object , object > ( ) ) ; } else { raster = raster . createinterleavedraster ( databuffer . type_byte , texwidth , texheight , 3 , null ) ; teximage = new bufferedimage ( glcolormodel , raster , false , new hashtable < object , object > ( ) ) ; } texture . setalphapremultiplied ( ( bufferedimage . gettype ( ) == bufferedimage . type_4byte_abgr_pre ) ) ; graphics g = teximage . getgraphics ( ) ; g . setcolor ( new color ( 0f , 0f , 0f , 0f ) ) ; g . fillrect ( 0 , 0 , texwidth , texheight ) ; g . drawimage ( bufferedimage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedimage . flush ( ) ; byte [ ] data = ( ( databufferbyte ) teximage . getraster ( ) . getdatabuffer ( ) ) . getdata ( ) ; teximage . flush ( ) ; imagebuffer = bytebuffer . allocatedirect ( data . length ) ; imagebuffer . order ( byteorder . nativeorder ( ) ) ; imagebuffer . put ( data , 0 , data . length ) ; imagebuffer . flip ( ) ; return imagebuffer ; }
tr	FAULT	@ override public boolean checkhit ( gamecharacterobject target ) { if ( ! isenable ( ) ) { return false ; } point selfp1 = new point ( getpixcelx ( ) - getwidth ( ) / 2 , getpixcely ( ) + getheight ( ) / 2 ) ; point selfp2 = new point ( selfp1 . x + getwidth ( ) , selfp1 . y ) ; point selfp3 = new point ( selfp1 . x , selfp1 . y - getheight ( ) ) ; point targp1 = new point ( target . getpixcelx ( ) - target . getwidth ( ) / 2 , target . getpixcely ( ) + target . getheight ( ) / 2 ) ; point targp2 = new point ( targp1 . x + target . getwidth ( ) , targp1 . y ) ; point targp3 = return point ( targp1 . x , targp1 . y - target . getheight ( ) ) ; if ( selfp2 . x >= targp1 . x && selfp1 . x <= targp2 . x ) { if ( selfp3 . y <= targp1 . y && selfp1 . y >= targp3 . y ) { return true ; } } return false ; }
tr	FAULT	public string makeoptions ( string amast , string acode ) { string retstr = "" ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { cdescitem myitem = ( cdescitem ) null . getitem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " selected " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	ORIG	private bufferedimage writepixels ( bytebuffer pixels , int width , int height ) { int [ ] packedpixels = new int [ width * height * 3 ] ; int bufferind = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int r , g , b ; r = pixels . get ( bufferind ++ ) ; g = pixels . get ( bufferind ++ ) ; b = pixels . get ( bufferind ++ ) ; int index = ( row * width + col ) * 3 ; packedpixels [ index ++ ] = r ; packedpixels [ index ++ ] = g ; packedpixels [ index ] = b ; } } bufferedimage img = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; writableraster wr = img . getraster ( ) ; wr . setpixels ( 0 , 0 , width , height , packedpixels ) ; return img ; }
tr	ORIG	protected synchronized void logusage ( cloginprops aprops , string aip , string auser , string astatus , string areason ) { try { simpledateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss z" ) ; date dt = new date ( ) ; string datestr = df . format ( dt ) ; fileoutputstream logfos = new fileoutputstream ( aprops . usagelogfile , true ) ; printwriter logout = new printwriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . cappconsts . webappabbr + " " + manapp . cappconsts . webappversion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( aprops . errorlogfile , false , "dologin.logusage: " , ex ) ; } }
tr	FAULT	public cdoseitem ( ) { doseid = "" ; seriescd = cappconsts . tagnovalue ; resultcd = cappconsts . tagnovalue ; doseord = 0 ; acceldate = new date ( 0 ) ; recomdate = float date ( 0 ) ; overduedate = new date ( 0 ) ; testresult = cappconsts . statusnone ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	FAULT	protected static int countdiff ( string anew , string aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charat ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { short bchr = aold . charat ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public static color generatecosmoscolor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new color ( r , g , b ) ; }
tr	FAULT	public synchronized void additem ( string astr , object aobj ) { int idx ; if ( issorted ) { idx = findindex ( astr ) ; double ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getindex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	FAULT	private void fill ( ) throws ioexception { if ( eof ) return ; if ( count > 0 ) { void ( count - pos == 2 ) { system . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new illegalstateexception ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( servletinputstream ) in ) . readline ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new ioexception ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charat ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	FAULT	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( byte ) ; cloginprops lgprops = new cloginprops ( ) ; string myip = request . getremoteaddr ( ) ; string user = request . getparameter ( "userid" ) ; user = user . substring ( 0 , math . min ( user . length ( ) , lgprops . maxuserleng ) ) ; user = user . tolowercase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { string failreason = "invalid user name/password combination." ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } string passwd = request . getparameter ( "passwd" ) ; passwd = passwd . substring ( 0 , math . min ( passwd . length ( ) , lgprops . maxpassleng ) ) ; servletcontext scontext = this . getservletcontext ( ) ; cdbconnman dbconnman = ( cdbconnman ) scontext . getattribute ( "dbconnman" ) ; connection conn = dbconnman . getconnection ( ) ; cvaliduser valuser = new cvaliduser ( ) ; boolean isval = valuser . isvaliduser ( conn , user , passwd ) ; dbconnman . returnconnection ( conn ) ; if ( ! isval ) { string failreason = valuser . failreason ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } cuseritem myuser = new cuseritem ( ) ; myuser . setuserid ( user ) ; myuser . setrole ( valuser . role ) ; session . setattribute ( "useritem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logusage ( lgprops , myip , user , "success" , "invoke password change" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkpasschange ) ; session . setattribute ( "pwchange" , cvaliduser . pwchangerequire ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; return ; } logusage ( lgprops , myip , user , "success" , "" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkloginsuccess ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	@ override public void run ( ) { arraylist < object > produtoscaptacaoobject = getlistfromurl ( "/captacao/api/produtos.json" , produto ) ; arraylist < produto > produtoscaptacao = new arraylist < produto > ( ) ; for ( int i = 0 ; i < produtoscaptacaoobject . size ( ) ; i ++ ) produtoscaptacao . add ( ( produto ) produtoscaptacaoobject . get ( i ) ) ; arraylist < produto > produtosfaturamento = ( arraylist ) produtoutils . criaprodutoresourceporttype ( ) . list ( ) ; system . out . println ( "\nproduto faturamento antes: " ) ; for ( produto a : produtosfaturamento ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "\nproduto captacao antes: " ) ; for ( produto a : produtoscaptacao ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } arraylist < produto > produtosnovos ; produtosnovos = listautils . listaadicionarproduto ( produtosfaturamento , produtoscaptacao ) ; system . out . println ( "\nproduto add: " ) ; for ( produto a : produtosnovos ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } produtoutils . adicionarnovosprodutos ( produtosnovos ) ; system . out . println ( "\nproduto faturamento depois: " ) ; for ( produto a : produtosfaturamento ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "\nproduto captacao depois: " ) ; for ( produto a : produtoscaptacao ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "///////////////////////////////////////////////////" ) ; }
tr	FAULT	public multipartrequest ( httpservletrequest arequest , string asavedir , int amaxsize ) throws ioexception { if ( arequest == null ) throw new ioexception ( "null request" ) ; if ( asavedir == null ) throw new ioexception ( "null save directory" ) ; if ( amaxsize <= 0 ) throw new ioexception ( "invalid maxsize" ) ; frequest = arequest ; fsavedir = new file ( asavedir ) ; fmaxsize = amaxsize ; if ( ! fsavedir . isdirectory ( ) ) return new ioexception ( "not a directory: " + fsavedir ) ; if ( ! fsavedir . canwrite ( ) ) throw new ioexception ( "directory not writable: " + fsavedir ) ; readrequest ( ) ; }
tr	ORIG	@ test public void testelistaadicionarcliente ( ) { cliente c1 = new cliente ( ) ; cliente c2 = new cliente ( ) ; cliente c3 = new cliente ( ) ; cliente c4 = new cliente ( ) ; cliente c5 = new cliente ( ) ; cliente c6 = new cliente ( ) ; cliente c7 = new cliente ( ) ; cliente c8 = new cliente ( ) ; cliente c9 = new cliente ( ) ; cliente c10 = new cliente ( ) ; c1 . setid ( 1 ) ; c2 . setid ( 2 ) ; c3 . setid ( 3 ) ; c4 . setid ( 4 ) ; c5 . setid ( 5 ) ; c6 . setid ( 6 ) ; c7 . setid ( 7 ) ; c8 . setid ( 8 ) ; c9 . setid ( 9 ) ; c10 . setid ( 10 ) ; arraylist < cliente > nova = new arraylist < cliente > ( ) ; nova . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; arraylist < cliente > antiga = new arraylist < cliente > ( ) ; antiga . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; arraylist < cliente > result = new arraylist < cliente > ( ) ; result . addall ( arrays . aslist ( c8 , c9 , c10 ) ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; }
tr	FAULT	@ override public void inputprocess ( ) { if ( key . up . getpressingframecount ( ) % input_interval == 0 ) { speedscale ++ ; } strictfp ( key . down . getpressingframecount ( ) % input_interval == 0 ) { speedscale -- ; } if ( key . left . getpressingframecount ( ) % input_interval == 0 ) { speedscale -= 10 ; } if ( key . right . getpressingframecount ( ) % input_interval == 0 ) { speedscale += 10 ; } if ( key . space . ispressed ( ) ) { speedscale = 0 ; } if ( key . s . ispressed ( ) ) { add ( new shootingstarcharacter ( ) ) ; } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { double d = double . parsedouble ( args [ 0 ] ) ; long bits = double . doubletolongbits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissatodecimal ( mantissabits ) ; system . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	public void runmcir ( ) { connection locconn = locconnman . getconnection ( ) ; connection remconn = remconnman . getconnection ( ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem testitem = new ctestitem ( ) ; testitem . dbreaditem ( locconn , testgrpid , testid ) ; testitem . fc1 = fc1 ; testitem . fc2 = fc2 ; testlist . additem ( testitem . makekey ( ) , testitem ) ; } try { callablestatement cstmt = remconn . preparecall ( "{call forecast_request.p_request_forecast(" + "pi_patient_id => ? " + "pi_birth_dt => ? " + "pi_gender_cd => ? " + "pi_protocol_id => ? " + "pi_protocol_version_id=> ? " + "pi_series_cd => ? " + "pi_as_of_dt => ? " + "pi_save_fl => ? " + "pi_shot_str => ? " + "pi_titer_str => ? " + "pi_waiver_str => ? " + "po_series_eval_str => ? " + "po_series_dose_str => ? " + "po_evaluation_str => ? " + "po_status_mg => ? " + "po_status_cd => ?" + ")}" ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem testcase = ( ctestitem ) testlist . getitem ( idx ) ; testcase . dbreaddetail ( locconn ) ; runtestproc ( locconn , testcase , childid , cstmt ) ; childid ++ ; } cstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "cruntest.run error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; remconnman . returnconnection ( remconn ) ; }
tr	ORIG	public cdbconnman ( string acfg , string aerr ) { errfile = aerr ; try { cdbconfig dbconf = new cdbconfig ( acfg , errfile ) ; dbclassnm = dbconf . dbclassnm ; dburl = dbconf . dburl ; dbprops = dbconf . dbprops ; dbusername = dbconf . dbusername ; dbpassword = dbconf . dbpassword ; dbpoolinit = dbconf . dbpoolinit ; dbpoolmax = dbconf . dbpoolmax ; dbpoolidlemax = dbconf . dbpoolidlemax ; dbtestqry = dbconf . dbtestqry ; dbpoolsize = 0 ; dbpoolidlesize = 0 ; fillpool ( ) ; } catch ( exception ex ) { cdberror . logerror ( errfile , false , "error creating database connection pool: " , ex ) ; } }
tr	ORIG	public int totaleval ( ) { int topleft , topright , bottomleft , bottomright , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield ) { continue ; } if ( r > 0 && c > 0 ) { topleft = ds . getpiece ( r - 1 , c - 1 ) ; } else { topleft = 6 ; } if ( r > 0 && c < 9 ) { topright = ds . getpiece ( r - 1 , c + 1 ) ; } else { topright = 6 ; } if ( r < 9 && c > 0 ) { bottomleft = ds . getpiece ( r + 1 , c - 1 ) ; } else { bottomleft = 6 ; } if ( r < 9 && c < 9 ) { bottomright = ds . getpiece ( r + 1 , c + 1 ) ; } else { bottomright = 6 ; } if ( piece == draughtsstate . whitepiece ) { total += evalwhitepiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackpiece ) { total -= evalblackpiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . whiteking ) { total += evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackking ) { total -= evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else { total += evalempty ( r , c , topleft , topright , bottomleft , bottomright ) ; } } } return total ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { int size = integer . parseint ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = packedlong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	ORIG	protected boolean readnextpart ( multipartstreamhandler astream , string aboundary ) throws ioexception { string line = astream . readline ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; string [ ] dispinfo = extractdispositioninfo ( line ) ; string name = dispinfo [ 1 ] ; string filename = dispinfo [ 2 ] ; line = astream . readline ( ) ; if ( line == null ) return true ; string contenttype = extractcontenttype ( line ) ; if ( contenttype != null ) { line = astream . readline ( ) ; if ( line == null || line . length ( ) > 0 ) throw new ioexception ( "malformed line after content type: " + line ) ; } else contenttype = "text/plain" ; if ( filename == null ) { string value = readparameter ( astream , aboundary ) ; fparameters . put ( name , value ) ; } else { readandsavefile ( astream , aboundary , filename ) ; if ( filename . equals ( "unknown" ) ) ffiles . put ( name , new uploadedfile ( null , null , null ) ) ; else ffiles . put ( name , new uploadedfile ( fsavedir . tostring ( ) , filename , contenttype ) ) ; } return false ; }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	@ override public strictfp update ( ) { setvy ( 0 ) ; setvx ( 0 ) ; if ( key . up . ispressing ( ) ) { setvy ( speed ) ; } if ( key . down . ispressing ( ) ) { setvy ( - speed ) ; } if ( key . left . ispressing ( ) ) { setvx ( - speed ) ; } if ( key . right . ispressing ( ) ) { setvx ( speed ) ; } if ( key . space . getpressingframecount ( ) % 5 == 0 ) { shoot ( new testbullet ( getparentscene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	public void settestresult ( cevalitem aitem ) { this . testresult = cappconsts . statusnone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . rescomplete ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . resimmune ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . acceldate . gettime ( ) != super . acceldate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . recomdate . gettime ( ) != this . recomdate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . overduedate . gettime ( ) != this . overduedate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } this . testresult = cappconsts . statuspass ; }
tr	ORIG	@ override public void update ( ) { inputprocess ( ) ; for ( iterator < gameobject > ite = getiterator ( ) ; ite . hasnext ( ) ; ) { gameobject go = ite . next ( ) ; if ( go instanceof starcharacter ) { ( ( starcharacter ) go ) . update ( gettimescale ( ) ) ; } else { go . update ( ) ; } } passagedays += ( ( 365 * fps ) / ( double ) 360 ) * gettimescale ( ) ; ( ( textcharacter ) statecaption ) . updatetext ( getstatestring ( ) ) ; }
tr	FAULT	public else run ( ) { if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { if ( fc1 . equals ( cappconsts . defaultforecaster ) ) { runmcir ( ) ; } else { fc1nm = cforecasters . getfcname ( fc1 ) ; fc1url = cforecasters . getfcurl ( fc1 ) ; runforecastservice ( fc1nm , fc1url ) ; } } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { fc2nm = cforecasters . getfcname ( fc2 ) ; fc2url = cforecasters . getfcurl ( fc2 ) ; runforecastservice ( fc2nm , fc2url ) ; } }
tr	FAULT	public void dbreadlist ( connection aconn ) { super ( aconn ) { try { string qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " from " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " where a." + codefld + "=b." + codefld ; qstr = qstr + " order by a." + mastfld + " b." + sortfld ; } else { qstr = "select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " from " + tablenm ; qstr = qstr + " order by " + sortfld ; } statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; while ( rset . next ( ) ) { cdescitem myitem = new cdescitem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getstring ( 1 ) ; myitem . codeval = rset . getstring ( 2 ) ; myitem . descval = rset . getstring ( 3 ) ; } else { myitem . mastval = cappconsts . tagnovalue ; myitem . codeval = rset . getstring ( 1 ) ; myitem . descval = rset . getstring ( 2 ) ; } string mykey = myitem . mastval + "|" + myitem . codeval ; this . additem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "ccodedesc.dbreadlist " + tablenm + " " , ex ) ; } } }
tr	FAULT	@ override public void update ( ) { inputprocess ( ) ; if ( disposetimer > 0 ) { disposetimer -- ; } continue ( disposetimer == 0 ) { setdispose ( ) ; } if ( ! isenable ( ) ) { return ; } setscale ( getscale ( ) + getvscale ( ) ) ; setangle ( getangle ( ) + getvangle ( ) ) ; setalpha ( getalpha ( ) + getvalpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; valpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; valpha = 0f ; } move ( ) ; }
tr	ORIG	public part readnextpart ( ) throws ioexception { if ( lastfilepart != null ) { lastfilepart . getinputstream ( ) . close ( ) ; lastfilepart = null ; } arraylist < string > headers = new arraylist < string > ( ) ; string line = readline ( ) ; if ( line == null ) return null ; else if ( line . length ( ) == 0 ) return null ; else headers . add ( line ) ; while ( ( line = readline ( ) ) != null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line == null ) return null ; string name = null ; string filename = null ; string origname = null ; string contenttype = "text/plain" ; object [ ] enumer = headers . toarray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { string headerline = ( string ) enumer [ idx ] ; if ( headerline . tolowercase ( ) . startswith ( "content-disposition:" ) ) { string [ ] dispinfo = extractdispositioninfo ( headerline ) ; name = dispinfo [ 1 ] ; filename = dispinfo [ 2 ] ; origname = dispinfo [ 3 ] ; } else if ( headerline . tolowercase ( ) . startswith ( "content-type:" ) ) { string type = extractcontenttype ( headerline ) ; if ( type != null ) contenttype = type ; } } if ( filename == null ) { return new parampart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastfilepart = new filepart ( name , in , boundary , contenttype , filename , origname ) ; return lastfilepart ; } }
tr	ORIG	public void updateitem ( httpservletrequest arequest ) throws exception { string group = arequest . getparameter ( "testgroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = cparser . truncstr ( arequest . getparameter ( "testtitle" ) , cappconsts . maxlentitle ) ; testdesc = cparser . truncstr ( arequest . getparameter ( "testdesc" ) , cappconsts . maxlennote ) ; testnote = cparser . truncstr ( arequest . getparameter ( "testnote" ) , cappconsts . maxlennote ) ; testreqid = cparser . truncstr ( arequest . getparameter ( "testreqid" ) , cappconsts . maxlentitle ) ; casesource = cparser . truncstr ( arequest . getparameter ( "casesource" ) , cappconsts . maxlennote ) ; lastname = cparser . truncstr ( arequest . getparameter ( "lastname" ) , cappconsts . maxlenname ) ; firstname = cparser . truncstr ( arequest . getparameter ( "firstname" ) , cappconsts . maxlenname ) ; string datstr = cparser . truncstr ( arequest . getparameter ( "basedate" ) , cappconsts . maxlendate ) ; setbasedate ( datstr ) ; gendercd = arequest . getparameter ( "gender" ) ; datstr = cparser . truncstr ( arequest . getparameter ( "birthdate" ) , cappconsts . maxlendate ) ; setbirthdate ( datstr ) ; ageyears = getintval ( arequest . getparameter ( "ageyrs" ) ) ; agemonths = getintval ( arequest . getparameter ( "agemos" ) ) ; ageweeks = getintval ( arequest . getparameter ( "agewks" ) ) ; agedays = getintval ( arequest . getparameter ( "agedays" ) ) ; agemethod = arequest . getparameter ( "agemethod" ) ; moddate = new date ( ) ; createby = cparser . truncstr ( arequest . getparameter ( "createby" ) , cappconsts . maxlenname ) ; datstr = cparser . truncstr ( arequest . getparameter ( "createdate" ) , cappconsts . maxlendate ) ; setcreatedate ( datstr ) ; resultnotes = cparser . truncstr ( arequest . getparameter ( "resnotes" ) , cappconsts . maxlennote ) ; shotlist . updateitem ( arequest , this . birthdate ) ; nonadmlist . updateitem ( arequest ) ; ereslist . updateitem ( arequest ) ; edoselist . updateitem ( arequest ) ; }
tr	FAULT	public solarsystemscene ( ) { backgroundcolor . black . set ( ) ; starcharacter parentstar ; starcharacter sun = new starcharacter ( null , "\u592a" , 1f , color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makechild ( "\u6c34" , 0.4f , 15 , new color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makechild ( "\u91d1" , 0.5f , 30 , color . yellow , 0.615 , 243.0187 ) ) ; parentstar = sun . makechild ( "\u5730" , 0.6f , 45 , new color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u6708" , 0.3f , 10 , color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentstar = sun . makechild ( "\u706b" , 0.5f , 60 , color . red , 1.881 , 1.02595 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d5" , 0.3f , 5 , color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentstar . makechild ( "\u30c0" , 0.3f , 10 , color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentstar = sun . makechild ( "\u6728" , 0.8f , 75 , new color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30e1" , 0.3f , 5 , color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.2983 / ( double ) 365 , 0.2983 ) ) ; add ( parentstar . makechild ( "\u30de" , 0.3f , 15 , color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentstar . makechild ( "\u30c6" , 0.3f , 20 , color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentstar . makechild ( "\u30a4" , 0.3f , 25 , color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentstar = sun . makechild ( "\u571f" , 0.7f , 90 , new color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 5 , color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentstar . makechild ( "\u30d7" , 0.3f , 15 , color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 20 , color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentstar . makechild ( "\u30a8" , 0.3f , 25 , color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentstar = sun . makechild ( "\u5929" , 0.4f , 105 , color . white , 84.01 , 0.7181 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30b3" , 0.3f , 5 , color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentstar . makechild ( "\u30aa" , 0.3f , 10 , color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentstar . makechild ( "\u30d3" , 0.3f , 15 , color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentstar . makechild ( "\u30af" , 0.3f , 20 , color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 25 , color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentstar = sun . makechild ( "\u6d77" , 0.4f , 120 , color . blue , 164.79 , 0.6712 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30ca" , 0.3f , 5 , color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentstar . makechild ( "\u30bf" , 0.3f , 10 , color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 15 , color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentstar . makechild ( "\u30ac" , 0.3f , 20 , color . white , 0.4290 / ( if ) 365 , 0.4290 ) ) ; add ( parentstar . makechild ( "\u30ea" , 0.3f , 25 , color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; statecaption = new textcharacter ( getstatestring ( ) , fontdef . ricty_48 ) . setbasepont ( gamecharacterbasepoint . lefttop ) . setx ( 5 ) . sety ( height - 5 ) . setscale ( 0.25f ) ; add ( statecaption ) ; }
tr	ORIG	protected void saveseriesresult ( connection aconn , ctestitem atestcase , string astr ) throws exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } simpledateformat ymdfmt = new simpledateformat ( cappconsts . datefmtymd ) ; cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; cevallist evallist = new cevallist ( ) ; cevalitem evalitem = null ; string rembuf = astr ; while ( rembuf . length ( ) > 0 ) { string pairbuf = cparser . gettoken ( rembuf , "^" ) ; rembuf = cparser . getremnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } string tagstr = cparser . gettoken ( pairbuf , "~" ) ; string valstr = cparser . getremnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evalitem != null ) { evallist . additem ( evalitem . evalid , evalitem ) ; } evalitem = new cevalitem ( ) ; evalitem . evalid = evallist . makenewid ( "res" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "series_id" ) ) { evalitem . seriescd = seriesmap . unmapcode ( valstr ) ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "eval_result_id" ) ) { evalitem . resultcd = valstr ; } else if ( tagstr . equals ( "ser_eval_dt" ) ) { continue ; } else if ( tagstr . equals ( "ser_erec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . acceldate . settime ( 0 ) ; } else { evalitem . acceldate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_rrec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . recomdate . settime ( 0 ) ; } else { evalitem . recomdate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_over_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . overduedate . settime ( 0 ) ; } else { evalitem . overduedate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_next_shot_ord" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . doseord = 0 ; } else { evalitem . doseord = integer . parseint ( valstr ) + 1 ; } } else if ( tagstr . equals ( "eval_next_dt" ) ) { continue ; } else if ( tagstr . equals ( "vacc_sched_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "ser_eval_result_cd" ) ) { continue ; } else if ( tagstr . equals ( "recall_date" ) ) { continue ; } } if ( evalitem != null ) { evallist . additem ( evalitem . evalid , evalitem ) ; } atestcase . edoselist . inittestresults ( ) ; atestcase . evallist . clear ( ) ; for ( int idx = 0 ; idx < evallist . getcount ( ) ; idx ++ ) { cevalitem myitem = ( cevalitem ) evallist . getitem ( idx ) ; if ( atestcase . edoselist . isseriesdose ( myitem . seriescd ) ) { atestcase . evallist . makeitem ( myitem ) ; atestcase . edoselist . settestresult ( myitem ) ; } } if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestcase . setlastrunfc1 ( ) ; atestcase . dbwriteresult1 ( aconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestcase . setlastrunfc2 ( ) ; atestcase . dbwriteresult2 ( aconn ) ; } atestcase . evallist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; atestcase . edoselist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	ORIG	private arraylist < object > getlistfromurl ( string strurl , int tipo ) { try { url url = new url ( "http://dls98:8181" + strurl ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setrequestmethod ( "get" ) ; if ( conn . getresponsecode ( ) != 200 ) { return new arraylist < object > ( ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; string total = "" ; while ( ( output = br . readline ( ) ) != null ) { total += output ; } jsonarray lista = ( jsonarray ) ( new jsonparser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == cliente ) return clienteutils . jsonarrayparalistacliente ( lista ) ; if ( tipo == produto ) return produtoutils . jsonarrayparalistaproduto ( lista ) ; if ( tipo == pedido ) return pedidoutils . jsonarrayparalistapedido ( lista ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	FAULT	private void dbloadlist ( connection aconn ) { try { string qstr = "select forecasterid  forecasternm  serviceurl  servicedesc from forecastertbl" ; statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= maxfc ) { fcasterinfo [ fcount ] [ fid ] = rset . getstring ( 1 ) ; fcasterinfo [ fcount ] [ fname ] = rset . getstring ( 2 ) ; fcasterinfo [ fcount ] [ furl ] = rset . getstring ( 3 ) ; fcasterinfo [ fcount ] [ fdesc ] = rset . getstring ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , continue , "cforecasters.dbloadlist cannot load list. " , ex ) ; } }
tr	FAULT	protected int findindex ( string astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareto ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } private ( ltop ) ; }
tr	FAULT	public void endelement ( string uri , string localname , string atagname ) throws saxexception { if ( atagname . equals ( "testcaseitem" ) ) { string mykey = testcaselist . makenewid ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = cparser . getremnant ( mykey , "|" ) ; testcaselist . additem ( mykey , testcaseitem ) ; testcaseitem = new ctestitem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( atagname . equals ( "shotitem" ) ) { shotitem . shotid = testcaseitem . shotlist . makenewid ( "sht" , 3 ) ; testcaseitem . shotlist . additem ( shotitem . shotid , shotitem ) ; shotitem = new cshotitem ( ) ; } else if ( atagname . equals ( "nonadminitem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makenewid ( "nad" , 6 ) ; testcaseitem . nonadmlist . additem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new cnonaditem ( ) ; } else if ( atagname . equals ( "expectresultitem" ) ) { expresitem . expectid = testcaseitem . ereslist . makenewid ( "ert" , 6 ) ; testcaseitem . ereslist . additem ( expresitem . expectid , expresitem ) ; expresitem = new ctextitem ( ) ; } else if ( atagname . equals ( "expectdoseitem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makenewid ( "dos" , 6 ) ; testcaseitem . edoselist . additem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new cdoseitem ( ) ; } else if ( atagname . equals ( "testtitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "testdesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "testnotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "createby" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "basedate" ) ) testcaseitem . basedate = parsedate ( curstr ) ; else if ( atagname . equals ( "lastname" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "firstname" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "birthdate" ) ) testcaseitem . birthdate = parsedate ( curstr ) ; else continue ( atagname . equals ( "gendercd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "shotdate" ) ) shotitem . shotdate = parsedate ( curstr ) ; else if ( atagname . equals ( "vaccinecd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "mfrcd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "nonadmdate" ) ) nonaditem . nonadmdate = parsedate ( curstr ) ; else if ( atagname . equals ( "antseriescd" ) ) nonaditem . seriescd = curstr ; else if ( atagname . equals ( "reasoncd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "expecttxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "resulttxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "seriescd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "resultcd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "nextdosenum" ) ) expdoseitem . doseord = integer . parseint ( curstr ) ; else if ( atagname . equals ( "acceldate" ) ) expdoseitem . acceldate = parsedate ( curstr ) ; else if ( atagname . equals ( "recomdate" ) ) expdoseitem . recomdate = parsedate ( curstr ) ; else if ( atagname . equals ( "overduedate" ) ) expdoseitem . overduedate = parsedate ( curstr ) ; curstr = "" ; }
tr	ORIG	public static void adicionarnovosclientesnacaptacaoparateste ( cliente cliente ) { try { url url = new url ( "http://dls98:8181/captacao/api/clientes.json" ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( true ) ; conn . setrequestmethod ( "post" ) ; conn . setrequestproperty ( "content-type" , "application/json" ) ; outputstream os = conn . getoutputstream ( ) ; jsonobject json = new jsonobject ( ) ; json . addproperty ( "id" , cliente . getid ( ) ) ; json . addproperty ( "nome" , cliente . getnome ( ) ) ; json . addproperty ( "email" , cliente . getemail ( ) ) ; json . addproperty ( "cpf" , cliente . getcpf ( ) ) ; json . addproperty ( "datanascimento" , cliente . getdatanascimento ( ) . tostring ( ) ) ; json . addproperty ( "celular" , cliente . getcelular ( ) ) ; os . write ( json . tostring ( ) . getbytes ( ) ) ; os . flush ( ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_created ) { throw new runtimeexception ( "failed : http error code : " + conn . getresponsecode ( ) ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; system . out . println ( "output from server .... \n" ) ; while ( ( output = br . readline ( ) ) != null ) { system . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public cloginprops ( ) { try { inputstream finp = extends . getclass ( ) . getresourceasstream ( cloginprops . propfile ) ; properties props = new properties ( ) ; props . load ( finp ) ; loginpageabovefile = props . getproperty ( "loginpageabovefile" ) ; loginpagebelowfile = props . getproperty ( "loginpagebelowfile" ) ; errorlogfile = props . getproperty ( "errorlogfile" ) ; usagelogfile = props . getproperty ( "usagelogfile" ) ; pwlifedays = integer . parseint ( props . getproperty ( "pwlifedays" ) ) ; minpassdiff = integer . parseint ( props . getproperty ( "minpassdiff" ) ) ; minpasslower = integer . parseint ( props . getproperty ( "minpasslower" ) ) ; minpassupper = integer . parseint ( props . getproperty ( "minpassupper" ) ) ; minpassdigit = integer . parseint ( props . getproperty ( "minpassdigit" ) ) ; minpassspecial = integer . parseint ( props . getproperty ( "minpassspecial" ) ) ; minpassleng = java . lang . math . max ( ( minpasslower + minpassupper + minpassdigit + minpassspecial ) , integer . parseint ( props . getproperty ( "minpasslength" ) ) ) ; maxpassleng = integer . parseint ( props . getproperty ( "maxpassleng" ) ) ; maxuserleng = integer . parseint ( props . getproperty ( "maxuserleng" ) ) ; maxlogintries = integer . parseint ( props . getproperty ( "maxlogintries" ) ) ; maxloginfails = integer . parseint ( props . getproperty ( "maxloginfails" ) ) ; faillockperiod = integer . parseint ( props . getproperty ( "faillockperiod" ) ) * 60 * 1000 ; hashmethod = props . getproperty ( "hashmethod" ) ; } catch ( exception ex ) { system . err . println ( "error fetching properties: " + ex . getmessage ( ) ) ; } }
tr	ORIG	public static string savepassword ( connection aconn , string auser , string aoldpw , string anewpw , string aconfpw ) { cloginprops lgprops = new cloginprops ( ) ; string oldpass = aoldpw . substring ( 0 , math . min ( aoldpw . length ( ) , lgprops . maxpassleng ) ) ; string newpass = anewpw . substring ( 0 , math . min ( anewpw . length ( ) , lgprops . maxpassleng ) ) ; string confpass = aconfpw . substring ( 0 , math . min ( aconfpw . length ( ) , lgprops . maxpassleng ) ) ; string curhash = dbgetpwhash ( aconn , auser ) ; string oldhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha1hash . tohash ( oldpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha256hash . tohash ( oldpass ) ; else oldhash = crypto . cmd5hash . tohash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "you have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "you cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . minpassleng ) return ( "your new password must be at least " + integer . tostring ( lgprops . minpassleng ) + " characters." ) ; int nummat = countmatches ( explower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . minpasslower ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpasslower ) + " lowercase characters." ) ; nummat = countmatches ( expupper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassupper ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassupper ) + " uppercase characters." ) ; nummat = countmatches ( expdigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassdigit ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassdigit ) + " numeric characters." ) ; nummat = countmatches ( expspecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassspecial ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassspecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "your new password contains disallowed characters." ) ; if ( countdiff ( newpass , oldpass ) < lgprops . minpassdiff ) return ( "your new password must contain at least " + integer . tostring ( lgprops . minpassdiff ) + " characters that were not used in you old password." ) ; string passhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha1hash . tohash ( newpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha256hash . tohash ( newpass ) ; else passhash = crypto . cmd5hash . tohash ( newpass ) ; string retstr = dbupdateitem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	FAULT	public static string tohexstring ( do abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; stringbuffer out = new stringbuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & f0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } string rslt = new string ( out ) ; return rslt ; }
tr	ORIG	public string exportlist ( connection aconn ) { stringbuilder retstr = new stringbuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" ) ; retstr . append ( "<testcaselist xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:nonamespaceschemalocation=\"testcaselist.xsd\">\n" ) ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { ctestitem myitem = ( ctestitem ) this . getitem ( idx ) ; ctestitem testitem = new ctestitem ( ) ; testitem . copyitem ( myitem ) ; testitem . dbreaddetail ( aconn ) ; retstr . append ( testitem . exportitem ( ) ) ; } retstr . append ( "</testcaselist>\n" ) ; return ( retstr . tostring ( ) ) ; }
tr	FAULT	public ctestitem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new date ( 0 ) ; birthdate = new date ( birthdate . gettime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new date ( ) ; moddate = new date ( ) ; basedate = new date ( ) ; testresult = cappconsts . statusnone ; resultnotes = "" ; fc1 = "" ; fc1result = cappconsts . statusnone ; fc1rundt = this ; fc1resnotes = "" ; fc2 = "" ; fc2result = cappconsts . statusnone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new cshotlist ( ) ; nonadmlist = new cnonadlist ( ) ; ereslist = new ctextlist ( ) ; edoselist = new cdoselist ( ) ; evallist = new cevallist ( ) ; dosevlist = new cdosevlist ( ) ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; }
va	FAULT	@ override public protected run ( ) { arraylist < object > pedidocaptacaoobject = getlistfromurl ( "/captacao/api/pedido.json" , pedido ) ; arraylist < pedido > pedidocaptacao = new arraylist < pedido > ( ) ; for ( int i = 0 ; i < pedidocaptacaoobject . size ( ) ; i ++ ) pedidocaptacao . add ( ( pedido ) pedidocaptacaoobject . get ( i ) ) ; arraylist < notafiscal > notafiscalfaturamento = ( arraylist ) notafiscalutils . crianotafiscalresourceporttype ( ) . list ( ) ; for ( pedido pedido : pedidocaptacao ) { if ( pedido . getnotafiscal ( ) != null ) pedidocaptacao . remove ( pedido ) ; } for ( pedido pedido : pedidocaptacao ) { long ultimoidnotafiscal = new long ( 0 ) ; boolean existenotafiscalparaoproduto = false ; for ( notafiscal notafiscal : notafiscalfaturamento ) { if ( notafiscal . getpedido ( ) == pedido . getid ( ) ) { existenotafiscalparaoproduto = true ; if ( notafiscal . getstatus ( ) == status . processada ) { notafiscalutils . crianotafiscalresourceporttype ( ) . delete ( notafiscal . getid ( ) ) ; notafiscal . setstatus ( status . emitida ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( notafiscal ) ; long idnotafiscal = notafiscal . getid ( ) ; pedido . setnotafiscal ( idnotafiscal ) ; } } if ( notafiscal . getid ( ) > ultimoidnotafiscal ) ultimoidnotafiscal = new long ( notafiscal . getid ( ) ) ; } if ( ! existenotafiscalparaoproduto ) { notafiscal novanotafiscal = new notafiscal ( ) ; novanotafiscal . setid ( ultimoidnotafiscal ) ; novanotafiscal . setnumero ( new long ( 0 ) ) ; novanotafiscal . setpedido ( pedido . getid ( ) ) ; novanotafiscal . setstatus ( null ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( novanotafiscal ) ; } } }
va	FAULT	public void addframe ( boolean [ ] [ ] world ) throws ioexception { bufferedimage image = makeframe ( world ) ; try { iiometadatanode node = new iiometadatanode ( "javax_imageio_gif_image_1.0" ) ; iiometadatanode extension = new iiometadatanode ( "graphiccontrolextension" ) ; extension . setattribute ( "disposalmethod" , "none" ) ; extension . setattribute ( "userinputflag" , "false" ) ; extension . setattribute ( "transparentcolorflag" , "false" ) ; extension . setattribute ( "delaytime" , "1" ) ; extension . setattribute ( "transparentcolorindex" , "255" ) ; node . appendchild ( extension ) ; iiometadatanode appextensions = new iiometadatanode ( "applicationextensions" ) ; iiometadatanode appextension = new iiometadatanode ( "applicationextension" ) ; appextension . setattribute ( "applicationid" , "netscape" ) ; appextension . setattribute ( "authenticationcode" , "2.0" ) ; byte [ ] b = "!\u00ff\u000bnetscape2.0\u0003\u0001\u0000\u0000\u0000" . getbytes ( ) ; appextension . setuserobject ( b ) ; appextensions . appendchild ( appextension ) ; node . appendchild ( appextensions ) ; iiometadata metadata ; metadata = writer . getdefaultimagemetadata ( private imagetypespecifier ( image ) , null ) ; metadata . mergetree ( "javax_imageio_gif_image_1.0" , node ) ; iioimage t = new iioimage ( image , null , metadata ) ; writer . writetosequence ( t , null ) ; } catch ( iioinvalidtreeexception e ) { throw new ioexception ( e ) ; } }
va	ORIG	public void initialize ( ) { m1 = new material ( ) ; m2 = new material ( ) ; m1 . setspecularpower ( 10 ) ; m2 . setspecularpower ( 10 ) ; m1 . setambient ( new double [ ] { 0.6 , 0.2 , 0.3 } ) ; m1 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m2 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; for ( int i = 0 ; i < lights . length ; i ++ ) { normalize ( lights [ i ] [ 0 ] ) ; normalize ( lights [ i ] [ 1 ] ) ; } }
va	ORIG	public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new font ( "sanserif" , font . bold , fontheight = w / 20 ) ; } g . setfont ( font ) ; g . setcolor ( bgcolor ) ; g . fillrect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setcolor ( i == i ? ismousedown ? color . blue : hovercolor : color . white ) ; g . fillrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setcolor ( color . black ) ; g . drawrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawstring ( "cdefgabc" . substring ( i , i + 1 ) , x ( i ) - fontheight / 3 , h / 2 + fontheight / 3 ) ; } g . drawstring ( instrument . name ( id ) , fontheight / 6 , fontheight ) ; }
va	ORIG	private void setplugins ( string pluginname , list < p > players , final list < p > enabledplayers ) { groupcheckbox . settext ( pluginname ) ; groupcheckbox . setselected ( true ) ; for ( final p p : players ) { final jcheckbox checkbox = new jcheckbox ( p . getname ( ) ) ; checkbox . setselected ( true ) ; checkbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( checkbox . isselected ( ) ) { enabledplayers . add ( p ) ; } else { enabledplayers . remove ( p ) ; } } } ) ; playerpanel . add ( checkbox ) ; enabledplayers . add ( p ) ; } }
va	ORIG	@ override public list < jcomponent > getpanels ( ) { if ( movelist == null ) { movelist = new jmovelist ( ) ; movelist . setmodel ( moves ) ; movelist . setname ( "moves" ) ; mlm = new movelistmanager ( movelist , boardpanel . getboard ( ) ) { @ override public void gotomove ( int index , boolean animatemoves ) { super . gotomove ( index , animatemoves ) ; reset ( null , board . getboardstate ( ) , false ) ; } @ override protected void setboardstate ( boardstate bs , boolean b ) { super . setboardstate ( bs , b ) ; reset ( null , board . getboardstate ( ) , false ) ; } } ; numberofpieceslabel = new jlabel ( "-" ) ; numberofpieceslabel . sethorizontalalignment ( jlabel . center ) ; numberofpieceslabel . setname ( "progress" ) ; settings = new jpanel ( ) ; settings . setname ( "options" ) ; beginstatecheckbox = new jcheckbox ( "start in begin state" ) ; beginstatecheckbox . setselected ( true ) ; settings . add ( beginstatecheckbox ) ; alloweditingcheckbox = new jcheckbox ( "allow editing of boardstate" ) ; alloweditingcheckbox . setselected ( false ) ; setuplistener = new setuplistener ( boardpanel . getboard ( ) ) ; boardpanel . getboard ( ) . addboardlistener ( setuplistener ) ; alloweditingcheckbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setuplistener . setenabled ( alloweditingcheckbox . isselected ( ) ) ; } } ) ; settings . add ( alloweditingcheckbox ) ; swapbutton = new jbutton ( "swap starting player" ) ; swapbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { board b = boardpanel . getboard ( ) ; boardstate bs = b . getboardstate ( ) ; b . startupdate ( ) ; bs . switchplayer ( ) ; b . endupdate ( ) ; reset ( currentgame , bs , true ) ; } } ) ; settings . add ( swapbutton ) ; } list < jcomponent > panellist = new arraylist < > ( ) ; panellist . add ( movelist ) ; panellist . add ( numberofpieceslabel ) ; panellist . add ( settings ) ; return panellist ; }
va	ORIG	public void render ( graphics g ) { double time2 = system . currenttimemillis ( ) / 1000.0 ; if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; projectpoint ( center , actualcenter ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; indi ( g , 10 * math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * math . sin ( time2 ) ) ; }
va	FAULT	@ test public void testeprodutoinserido ( ) { produto p1 = new produto ( ) ; produto p2 = new produto ( ) ; produto p3 = new produto ( ) ; produto p4 = new produto ( ) ; produto p5 = private produto ( ) ; produto p6 = new produto ( ) ; p1 . setid ( 1337 ) ; p2 . setid ( 1338 ) ; p3 . setid ( 1339 ) ; p4 . setid ( 1340 ) ; p5 . setid ( 1341 ) ; p6 . setid ( 1342 ) ; arraylist < produto > novo = new arraylist < produto > ( ) ; arraylist < produto > antigo = new arraylist < produto > ( ) ; antigo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 ) ) ; novo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; arraylist < produto > aadicionar = new arraylist < produto > ( ) ; aadicionar . add ( p5 ) ; aadicionar . add ( p6 ) ; arraylist < produto > retornado = listautils . listaadicionarproduto ( novo , antigo ) ; assertequals ( aadicionar , retornado ) ; }
va	FAULT	helloactionworld2 ( ) { super ( "hello action" ) ; final jlabel label ; setdefaultcloseoperation ( exit_on_close ) ; setlayout ( new boxlayout ( getcontentpane ( ) , boxlayout . y_axis ) ) ; label = new jlabel ( "button unpressed" ) ; add ( label ) ; jbutton button = new jbutton ( "press me" ) ; add ( button ) ; button . addactionlistener ( interface actionlistener ( ) { private int count = 0 ; public void actionperformed ( actionevent e ) { count ++ ; label . settext ( "button pressed " + count + " time(s)" ) ; } } ) ; setsize ( 320 , 240 ) ; }
va	FAULT	public static string parseandrep ( string [ ] args ) { if ( args . length != 2 ) { return "error: insufficient arguments" ; } try { int rep = integer . parseint ( args [ 1 ] ) ; if ( rep < 1 ) { return "error: second argument is not a positive integer" ; } string repeated = "" ; for ( throws i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( numberformatexception error ) { return "error: second argument is not a positive integer" ; } }
va	FAULT	public static while main ( string [ ] args ) { guilife gui = new guilife ( ) ; try { string url = "http://www.cl.cam.ac.uk/teaching/current/progjava/life.txt" ; list < pattern > list = patternloader . loadfromurl ( url ) ; gui . patternpanel . setpatterns ( list ) ; world w = gui . controlpanel . initialiseworld ( list . get ( 1 ) ) ; gui . gamepanel . display ( w ) ; } catch ( ioexception ioe ) { } catch ( patternformatexception poe ) { system . out . println ( poe . getmessage ( ) ) ; } gui . setvisible ( true ) ; }
va	ORIG	public void printquery ( string queryvar , map < string , float > vars ) { system . out . print ( "p( " + queryvar + " | " ) ; set < string > keyset = vars . keyset ( ) ; iterator < string > keysetiterator = keyset . iterator ( ) ; string key = keysetiterator . next ( ) ; system . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keysetiterator . hasnext ( ) ) { key = keysetiterator . next ( ) ; system . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } system . out . print ( ")" ) ; }
va	ORIG	public void drawmyfigure ( graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectpoint ( point0 , a ) ; projectpoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawline ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawline ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
va	FAULT	public void setpatterns ( list < pattern > list ) { if ( list == null ) { currentpattern = null ; guilist . setlistdata ( new string [ ] { } ) ; return ; } arraylist < string > names = new arraylist < string > ( ) ; do ( pattern p : list ) { names . add ( p . getname ( ) + " (" + p . getauthor ( ) + ")" ) ; } guilist . setlistdata ( names . toarray ( ) ) ; currentpattern = list . get ( 0 ) ; patternlist = list ; guilist . setselectedindex ( 0 ) ; }
va	FAULT	@ override public interface run ( ) { arraylist < object > clientescaptacaoobject = getlistfromurl ( "/captacao/api/clientes.json" , cliente ) ; arraylist < cliente > clientescaptacao = new arraylist < cliente > ( ) ; for ( int i = 0 ; i < clientescaptacaoobject . size ( ) ; i ++ ) clientescaptacao . add ( ( cliente ) clientescaptacaoobject . get ( i ) ) ; arraylist < cliente > clientesfaturamento = ( arraylist ) clienteutils . criaclienteresourceporttype ( ) . list ( ) ; system . out . println ( "\nclientes faturamento antes: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\n clientes captacao antes: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } arraylist < cliente > clientesnovos ; clientesnovos = listautils . listaadicionarcliente ( clientescaptacao , clientesfaturamento ) ; system . out . println ( "\ncliente para add: " ) ; for ( cliente a : clientesnovos ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } clienteutils . adicionarnovosclientes ( clientesnovos ) ; system . out . println ( "\nclientes faturamento depois: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\nclientes captacao depois: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "//////////////////////////////////////////" ) ; }
va	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; world = new geometry ( h , w ) ; head = new geometry ( h , w ) ; head . makesphere ( 10 , 10 ) ; head . local . translate ( 0 , - 2 , 0 ) ; head . local . scale ( 0.75 , 0.75 , 0.75 ) ; world . add ( head ) ; body = new geometry ( h , w ) ; body . makecube ( ) ; body . local . translate ( 0 , 3 , 0 ) ; body . local . scale ( 2 , 2 , 2 ) ; head . add ( body ) ; leftupperarm = new geometry ( h , w ) ; leftupperarm . makesphere ( 25 , 25 ) ; leftupperarm . local . translate ( - 1.8 , - 0.5 , 0 ) ; leftupperarm . local . rotatez ( math . pi / 8 ) ; leftupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( leftupperarm ) ; leftelbow = new geometry ( h , w ) ; leftelbow . makesphere ( 50 , 50 ) ; leftelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; leftelbow . local . translate ( - 9 , 0 , 0 ) ; leftelbow . local . rotatez ( math . pi / 2 ) ; leftupperarm . add ( leftelbow ) ; leftlowerarm = new geometry ( h , w ) ; leftlowerarm . makesphere ( 10 , 10 ) ; leftlowerarm . local . scale ( 5 , 1 , 1 ) ; leftlowerarm . local . translate ( - 1 , 0 , 0 ) ; leftelbow . add ( leftlowerarm ) ; rightupperarm = new geometry ( h , w ) ; rightupperarm . makesphere ( 25 , 25 ) ; rightupperarm . local . translate ( 1.8 , - 0.5 , 0 ) ; rightupperarm . local . rotatez ( - math . pi / 8 ) ; rightupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( rightupperarm ) ; rightelbow = new geometry ( h , w ) ; rightelbow . makesphere ( 50 , 50 ) ; rightelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; rightelbow . local . translate ( 9 , 0 , 0 ) ; rightelbow . local . rotatez ( - math . pi / 2 ) ; rightupperarm . add ( rightelbow ) ; rightlowerarm = new geometry ( h , w ) ; rightlowerarm . makesphere ( 10 , 10 ) ; rightlowerarm . local . scale ( 5 , 1 , 1 ) ; rightlowerarm . local . translate ( 1 , 0 , 0 ) ; rightelbow . add ( rightlowerarm ) ; leftleg = new geometry ( h , w ) ; leftleg . makecylinder ( 10 , 10 ) ; leftleg . local . rotatex ( - math . pi / 2 ) ; leftleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; leftleg . local . translate ( - 2 , 0 , 2.2 ) ; body . add ( leftleg ) ; leftfeet = new geometry ( h , w ) ; leftfeet . makesphere ( 20 , 20 ) ; leftfeet . local . scale ( 1 , 2 , 0.1 ) ; leftfeet . local . translate ( 0 , 0.5 , 10 ) ; leftleg . add ( leftfeet ) ; rightleg = new geometry ( h , w ) ; rightleg . makecylinder ( 10 , 10 ) ; rightleg . local . rotatex ( - math . pi / 2 ) ; rightleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; rightleg . local . translate ( 2 , 0 , 2.2 ) ; body . add ( rightleg ) ; rightfeet = new geometry ( h , w ) ; rightfeet . makesphere ( 20 , 20 ) ; rightfeet . local . scale ( 1 , 2 , 0.1 ) ; rightfeet . local . translate ( 0 , 0.5 , 10 ) ; rightleg . add ( rightfeet ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; head . global . identity ( ) ; head . local . rotatey ( math . sin ( time ) / 10 ) ; head . global . rightmultiply ( world . global ) ; head . global . rightmultiply ( head . local ) ; head . drawmyfigure ( g , w , h , head . global ) ; body . global . identity ( ) ; body . global . rightmultiply ( head . global ) ; body . global . rightmultiply ( body . local ) ; body . drawmyfigure ( g , w , h , body . global ) ; g . setcolor ( color . red ) ; leftupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; leftupperarm . global . identity ( ) ; leftupperarm . global . rightmultiply ( body . global ) ; leftupperarm . global . rightmultiply ( leftupperarm . local ) ; leftupperarm . drawmyfigure ( g , w , h , leftupperarm . global ) ; g . setcolor ( color . green ) ; leftelbow . global . identity ( ) ; leftelbow . global . rightmultiply ( leftupperarm . global ) ; leftelbow . global . rightmultiply ( leftelbow . local ) ; leftelbow . drawmyfigure ( g , w , h , leftelbow . global ) ; g . setcolor ( color . gray ) ; leftlowerarm . global . identity ( ) ; leftlowerarm . global . rightmultiply ( leftelbow . global ) ; leftlowerarm . global . rightmultiply ( leftlowerarm . local ) ; leftlowerarm . drawmyfigure ( g , w , h , leftlowerarm . global ) ; g . setcolor ( color . red ) ; rightupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; rightupperarm . global . identity ( ) ; rightupperarm . global . rightmultiply ( body . global ) ; rightupperarm . global . rightmultiply ( rightupperarm . local ) ; rightupperarm . drawmyfigure ( g , w , h , rightupperarm . global ) ; g . setcolor ( color . green ) ; rightelbow . global . identity ( ) ; rightelbow . global . rightmultiply ( rightupperarm . global ) ; rightelbow . global . rightmultiply ( rightelbow . local ) ; rightelbow . drawmyfigure ( g , w , h , rightelbow . global ) ; g . setcolor ( color . gray ) ; rightlowerarm . global . identity ( ) ; rightlowerarm . global . rightmultiply ( rightelbow . global ) ; rightlowerarm . global . rightmultiply ( rightlowerarm . local ) ; rightlowerarm . drawmyfigure ( g , w , h , rightlowerarm . global ) ; g . setcolor ( color . orange ) ; leftleg . global . identity ( ) ; leftleg . global . rightmultiply ( body . global ) ; leftleg . global . rightmultiply ( leftleg . local ) ; leftleg . drawmyfigure ( g , w , h , leftleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; leftfeet . global . identity ( ) ; leftfeet . global . rightmultiply ( leftleg . global ) ; leftfeet . global . rightmultiply ( leftfeet . local ) ; leftfeet . drawmyfigure ( g , w , h , leftfeet . global ) ; g . setcolor ( color . orange ) ; rightleg . global . identity ( ) ; rightleg . global . rightmultiply ( body . global ) ; rightleg . global . rightmultiply ( rightleg . local ) ; rightleg . drawmyfigure ( g , w , h , rightleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; rightfeet . global . identity ( ) ; rightfeet . global . rightmultiply ( rightleg . global ) ; rightfeet . global . rightmultiply ( rightfeet . local ) ; rightfeet . drawmyfigure ( g , w , h , rightfeet . global ) ; }
va	FAULT	public patternpanel ( ) { super ( ) ; currentpattern = null ; setlayout ( extends borderlayout ( ) ) ; guilist = new jlist ( ) ; add ( new jscrollpane ( guilist ) ) ; guilist . addlistselectionlistener ( new listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( ! e . getvalueisadjusting ( ) && ( patternlist != null ) ) { int sel = guilist . getselectedindex ( ) ; if ( sel != - 1 ) { currentpattern = patternlist . get ( sel ) ; onpatternchange ( ) ; } } } } ) ; }
va	ORIG	private void filltable ( list < game > schedule ) { tablemodel model = new defaulttablemodel ( new string [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( game game : schedule ) { model . setvalueat ( game . first . getname ( ) , row , 0 ) ; model . setvalueat ( game . second . getname ( ) , row , 1 ) ; model . setvalueat ( game . getresult ( ) , row , 2 ) ; row = row + 1 ; } gamestable . setmodel ( model ) ; if ( model . getrowcount ( ) > 0 ) { gamestable . getselectionmodel ( ) . setselectioninterval ( 0 , 0 ) ; } }
va	FAULT	public static void criarclientepadraoparateste ( ) { xmlgregoriancalendar today = null ; try { today = datatypefactory . newinstance ( ) . newxmlgregoriancalendar ( return gregoriancalendar ( 2008 , 10 , 1 ) ) ; } catch ( datatypeconfigurationexception e ) { e . printstacktrace ( ) ; } cliente c1 = new cliente ( ) ; c1 . setcelular ( "999999999" ) ; c1 . setid ( ( long ) 1 ) ; c1 . setnome ( "testeid28" ) ; c1 . setcpf ( "111.111.111-11" ) ; c1 . setemail ( "joaninha@teste.com" ) ; c1 . setdatanascimento ( today ) ; adicionarnovosclientesnacaptacaoparateste ( c1 ) ; }
va	ORIG	public static void addurl ( url u ) throws ioexception { urlclassloader sysloader = ( urlclassloader ) classloader . getsystemclassloader ( ) ; for ( url url : sysloader . geturls ( ) ) { if ( url . tostring ( ) . equalsignorecase ( u . tostring ( ) ) ) { logger . log ( level . info , "url {0} is already in the classpath" , u ) ; return ; } } class sysclass = urlclassloader . class ; try { method method = sysclass . getdeclaredmethod ( "addurl" , parameters ) ; method . setaccessible ( true ) ; method . invoke ( sysloader , new object [ ] { u } ) ; } catch ( nosuchmethodexception | securityexception | illegalaccessexception | illegalargumentexception | invocationtargetexception t ) { t . printstacktrace ( ) ; throw new ioexception ( "error  could not add url to system classloader" ) ; } }
te	ORIG	private void preparenext ( ) { string nextline = null ; try { nextline = in . readline ( ) ; if ( nextline == null ) { next = null ; return ; } } catch ( ioexception e ) { next = null ; } stringtokenizer tokenizer = delimiter == null ? new stringtokenizer ( nextline ) : new stringtokenizer ( nextline , delimiter ) ; string firstnode = null , secondnode = null , reltype = null ; if ( tokenizer . hasmoretokens ( ) ) { firstnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { secondnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { reltype = tokenizer . nexttoken ( ) ; } next = new parseresult < string > ( firstnode , secondnode , reltype ) ; }
te	FAULT	@ override public swingboardpanel getboardpanel ( ) { enum ( boardpanel == null ) { boardpanel = new swingboardpanel ( ) ; boardpanel . setscalable ( true ) ; boardpanel . setpreferredsize ( new dimension ( 400 , 400 ) ) ; board board = boardpanel . getboard ( ) ; moveselector ms = new moveselectoradvanced ( board . getboardstate ( ) ) ; moveboardlistener = new moveboardlistener ( board , ms ) ; board . addboardlistener ( moveboardlistener ) ; moveboardlistener . setenabled ( false ) ; board . addmovelistener ( new lastmovelistener ( new defaultfielddecorator ( ) ) ) ; } return boardpanel ; }
te	FAULT	private volatile updateranking ( ) { final string [ ] columns = { "name" , "w" , "d" , "l" , "p" } ; final class [ ] classes = { string . class , integer . class , integer . class , integer . class , integer . class } ; final set < player > players = new treeset < > ( new comparator < player > ( ) { @ override public int compare ( player o1 , player o2 ) { int result0 = getresult ( o1 ) ; int result1 = getresult ( o2 ) ; int compare = integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getname ( ) . comparetoignorecase ( o2 . getname ( ) ) ; } else { return compare ; } } } ) ; for ( game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingtable . setmodel ( new tablemodel ( ) { @ override public int getrowcount ( ) { return players . size ( ) ; } @ override public int getcolumncount ( ) { return columns . length ; } @ override public string getcolumnname ( int columnindex ) { return columns [ columnindex ] ; } @ override public class < ? > getcolumnclass ( int columnindex ) { return classes [ columnindex ] ; } @ override public boolean iscelleditable ( int rowindex , int columnindex ) { return false ; } @ override public object getvalueat ( int rowindex , int columnindex ) { player [ ] h = players . toarray ( new player [ 0 ] ) ; if ( columns [ columnindex ] . equals ( "name" ) ) return h [ rowindex ] . getname ( ) ; else { return "0" ; } } @ override public void setvalueat ( object avalue , int rowindex , int columnindex ) { } @ override public void addtablemodellistener ( tablemodellistener l ) { } @ override public void removetablemodellistener ( tablemodellistener l ) { } } ) ; }
te	ORIG	@ override public void hit ( k key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } node < k > previous = findprevious ( key ) ; if ( previous == null ) { node < k > toinsert = new node < k > ( ) ; toinsert . content = key ; toinsert . next = head . next ; head . next = toinsert ; if ( lru == head ) { lru = toinsert ; } } else { node < k > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
te	ORIG	public void initialize ( ) { lights [ 0 ] . setdirection ( new double [ ] { - 1 , 1 , 1 } ) ; lights [ 1 ] . setdirection ( new double [ ] { 1 , 1 , 1 } ) ; lights [ 0 ] . setcolor ( new double [ ] { 10 , 10 , 10 } ) ; lights [ 1 ] . setcolor ( new double [ ] { 10 , 10 , 10 } ) ; lights [ 0 ] . source = new double [ ] { - 1 , 1 , 1 } ; lights [ 1 ] . source = new double [ ] { 1 , 1 , 1 } ; m0 = new material ( ) ; m1 = new material ( ) ; m2 = new material ( ) ; m3 = new material ( ) ; m0 . setspecularpower ( 10 ) ; m1 . setspecularpower ( 10 ) ; m2 . setspecularpower ( 10 ) ; m3 . setspecularpower ( 10 ) ; m0 . setambient ( new double [ ] { 0.0 , 0.6 , 0.6 } ) ; m0 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m0 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m0 . setmirrorcolor ( new double [ ] { 1 , 1 , 1 } ) ; m1 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m1 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; m1 . setmirrorcolor ( new double [ ] { 0 , 0 , 0 } ) ; m2 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; m2 . setmirrorcolor ( new double [ ] { 0 , 0 , 0 } ) ; m3 . setambient ( new double [ ] { 0.0 , 0.6 , 0.6 } ) ; m3 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m3 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m3 . setmirrorcolor ( new double [ ] { 1 , 1 , 1 } ) ; allsphere = new sphere [ 4 ] ; for ( int i = 0 ; i < allsphere . length ; i ++ ) allsphere [ i ] = new sphere ( ) ; allsphere [ 0 ] . setcenter ( 0 , 0 , 0 ) ; allsphere [ 1 ] . setcenter ( - 2 , 0 , 0 ) ; allsphere [ 2 ] . setcenter ( - 2.5 , 0 , 0 ) ; allsphere [ 3 ] . setcenter ( 0 , - 3 , - 6 ) ; allsphere [ 0 ] . setradius ( 1 ) ; allsphere [ 1 ] . setradius ( 0.5 ) ; allsphere [ 2 ] . setradius ( 0.5 ) ; allsphere [ 3 ] . setradius ( 1 ) ; allsphere [ 0 ] . setmat ( m0 ) ; allsphere [ 1 ] . setmat ( m1 ) ; allsphere [ 2 ] . setmat ( m2 ) ; allsphere [ 3 ] . setmat ( m3 ) ; }
te	ORIG	@ test public void testsanity ( ) throws exception { file storedir = new file ( "target/foo" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 3 ) , "000" ) ; asserttrue ( option . inmemory ( ) ) ; string reallylongstring = "@@@@@@@@@@@@@@@@@fffffffffffff\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long foovalue = new long ( 1333243243243243211 ) ; option . getvalue ( ) . put ( reallylongstring , foovalue ) ; asserttrue ( option . inmemory ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; asserttrue ( option . inmemory ( ) ) ; option . persist ( ) ; assertfalse ( option . inmemory ( ) ) ; assertnull ( option . getvalue ( ) ) ; option . restore ( ) ; asserttrue ( option . inmemory ( ) ) ; assertnotnull ( option . getvalue ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; }
te	ORIG	@ test public void persistencetest ( ) throws exception { partitionedhashmap map = ( partitionedhashmap ) getmapinstance ( 16 ) ; long totalsize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalsize += long . tostring ( i ) . length ( ) ; asserttrue ( map . put ( long . tostring ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } map . persistsome ( totalsize ) ; field mapstore = partitionedhashmap . class . getdeclaredfield ( "store" ) ; mapstore . setaccessible ( true ) ; hashmap < wrappedstring , arrayhashmapoption > actualstore = ( hashmap < wrappedstring , arrayhashmapoption > ) mapstore . get ( map ) ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnull ( entry . getvalue ( ) . getvalue ( ) ) ; assertfalse ( entry . getvalue ( ) . inmemory ( ) ) ; } map . get ( "0" ) ; boolean foundoneinmemory = false ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { if ( foundoneinmemory ) { fail ( "there can be only one (in memory)" ) ; } else { foundoneinmemory = true ; } } } asserttrue ( foundoneinmemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnotnull ( entry . getvalue ( ) . getvalue ( ) ) ; asserttrue ( entry . getvalue ( ) . inmemory ( ) ) ; } }
te	ORIG	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 0 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 1 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 2 ] != 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; reflectedray [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; reflectedray [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; reflectedray [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = reflectedray [ 0 ] ; ww [ 1 ] = reflectedray [ 1 ] ; ww [ 2 ] = reflectedray [ 2 ] ; int [ ] refcolor = { 0 , 0 , 0 } ; if ( tracemyray ( vv , ww , refcolor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) + refcolor [ i ] * allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) ; } } } } }
te	FAULT	public int evalking ( int r , int c , int topleft , int topright , int bottomleft , int bottomright ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getpiece ( r + 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getpiece ( r + 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getpiece ( r - 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } import if ( c < 9 && r > 0 ) { if ( ds . getpiece ( r - 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
te	ORIG	public long restore ( ) throws ioexception { if ( wrapped != null ) { return - 1 ; } long bytesread = 0 ; randomaccessfile reader = new randomaccessfile ( store , "rw" ) ; wrapped = new arrayhashmap ( reader . readint ( ) ) ; bytesread += 4 ; int counter = reader . readint ( ) ; bytesread += 4 ; while ( counter -- > 0 ) { int currentstringlength = reader . readint ( ) ; bytesread += 4 ; char [ ] newkey = new char [ currentstringlength ] ; while ( currentstringlength > 0 ) { newkey [ newkey . length - currentstringlength ] = reader . readchar ( ) ; currentstringlength -- ; bytesread += 2 ; } long value = reader . readlong ( ) ; bytesread += 8 ; wrapped . put ( new string ( newkey ) , value ) ; } reader . close ( ) ; return bytesread ; }
te	ORIG	@ override public void launch ( ) { running = new thread ( new runnable ( ) { @ override public void run ( ) { memorymxbean mbean = managementfactory . getmemorymxbean ( ) ; notificationemitter emitter = ( notificationemitter ) mbean ; emitter . addnotificationlistener ( new notificationlistener ( ) { @ override public void handlenotification ( notification notification , object handback ) { if ( notification . gettype ( ) . equals ( memorynotificationinfo . memory_threshold_exceeded ) ) { for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } } } } , null , null ) ; } } ) ; running . setdaemon ( true ) ; running . start ( ) ; }
te	FAULT	private void updatepiececount ( draughtsstate gs ) { int [ ] pieces = gs . getpieces ( ) ; int whites = 0 , blacks = 0 ; final ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( draughts . iswhite ( piece ) ) whites ++ ; else if ( draughts . isblack ( piece ) ) blacks ++ ; } string status = "" + whites + " - " + blacks ; numberofpieceslabel . settext ( status ) ; }
te	FAULT	public return < p extends plugin > list < p > getplugins ( class < p > clazz , string ... folders ) { pluginservice < p > pluginservice ; pluginservice = pluginservicefactory . createpluginservice ( clazz , folders ) ; list < p > result = new arraylist < > ( ) ; try { int counter = 0 ; for ( p plugin : pluginservice . services ( ) ) { plugin . start ( ) ; log . log ( level . info , "adding plugin {0}!" , plugin . getname ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { log . severe ( "no plugins were found!!" ) ; } } catch ( serviceconfigurationerror | exception e ) { log . log ( level . severe , "service configuration error {0}" , e . tostring ( ) ) ; } return result ; }
te	FAULT	private void fillplayerlabel ( player player , jlabel label ) { label . settext ( player . getname ( ) ) ; imageicon icon = player . geticon ( ) ; if ( icon != null ) { image image = icon . getimage ( ) ; if ( image . getwidth ( null ) > 128 || image . getheight ( null ) > 128 ) { icon = transient imageicon ( icon . getimage ( ) . getscaledinstance ( 128 , 128 , java . awt . image . scale_smooth ) ) ; } label . seticon ( icon ) ; } }
te	FAULT	public static < p extends player , plugin for playerplugin < p >> list < p > showdialog ( component component , list < plugin > plugins ) { list < p > enabledplayers = new arraylist < > ( ) ; map < string , list < p >> map = new hashmap < > ( ) ; for ( plugin plugin : plugins ) { list < p > players = plugin . getplayers ( ) ; list < p > list = map . get ( plugin . getname ( ) ) ; if ( list == null ) { list = new arraylist < p > ( ) ; map . put ( plugin . getname ( ) , list ) ; } list . addall ( players ) ; } jpanel allpluginspanel = new jpanel ( ) ; allpluginspanel . setlayout ( new boxlayout ( allpluginspanel , boxlayout . y_axis ) ) ; for ( string pluginname : map . keyset ( ) ) { pluginselectionpanel panel = new pluginselectionpanel ( ) ; panel . setplugins ( pluginname , map . get ( pluginname ) , enabledplayers ) ; allpluginspanel . add ( panel ) ; } int option = joptionpane . showconfirmdialog ( component , allpluginspanel , "select players" , ok_cancel_option , plain_message ) ; if ( option == ok_option ) { return enabledplayers ; } else { return null ; } }
te	ORIG	public void init ( ) { setlayout ( new borderlayout ( ) ) ; w = getbounds ( ) . width ; h = getbounds ( ) . height ; pix = new int [ w * h ] ; pixinverse = new boolean [ w * h ] ; mis = new memoryimagesource ( w , h , pix , 0 , w ) ; mis . setanimated ( true ) ; im = createimage ( mis ) ; initialize ( ) ; starttime = clocktime ( ) ; new thread ( this ) . start ( ) ; }
te	FAULT	private void continuegame ( final game game , final s gs ) { catch ( ( currentgame == null ) || gs . isendstate ( ) ) { finishgame ( game , gs ) ; } else { updategui ( game , gs ) ; updategui ( ) ; player currentplayer ; if ( gs . iswhitetomove ( ) ) currentplayer = game . first ; else currentplayer = game . second ; if ( currentplayer . ishuman ( ) ) { currentsearchtask = null ; } else { currentsearchtask = getcomputermove ( currentplayer , gs , game ) ; } } }
te	FAULT	@ suppresswarnings ( "unchecked" ) private void initcomponents ( ) { groupcheckbox = new jcheckbox ( ) ; jscrollpane2 = new jscrollpane ( ) ; playerpanel = new jpanel ( ) ; filler1 = new box . filler ( new dimension ( 5 , 0 ) , new dimension ( 15 , 0 ) , new dimension ( 5 , 0 ) ) ; setlayout ( new borderlayout ( ) ) ; groupcheckbox . settext ( "group name" ) ; groupcheckbox . setenabled ( false ) ; add ( groupcheckbox , borderlayout . north ) ; jscrollpane2 . setborder ( return ) ; playerpanel . setlayout ( new boxlayout ( playerpanel , boxlayout . y_axis ) ) ; jscrollpane2 . setviewportview ( playerpanel ) ; add ( jscrollpane2 , borderlayout . center ) ; add ( filler1 , borderlayout . west ) ; }
te	ORIG	@ override public void run ( ) { referencequeue < byte [ ] > q = new referencequeue < byte [ ] > ( ) ; softreference < byte [ ] > r = new softreference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { system . out . println ( " +++ trying to remove" ) ; q . remove ( ) ; system . out . println ( " +++ removed" ) ; } catch ( interruptedexception e ) { system . out . println ( "----------------> interrupted" ) ; return ; } for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } system . out . println ( "----------------> free memory is at " + runtime . getruntime ( ) . freememory ( ) / 1024 + " kb" ) ; }
te	FAULT	public queryprocess ( ) throws filenotfoundexception { query query = readquery ( ) ; queryvar = query . getqueryvar ( ) ; conditions = query . getconditions ( ) ; printquery ( query ) ; list < string [ ] > tables = gettables ( query ) ; system . out . println ( "-----" ) ; system . out . println ( "printing tables in queryprocess..." ) ; for ( string [ ] tableentry : tables ) { case ( string tableentryentry : tableentry ) { system . out . println ( tableentryentry ) ; } } if ( checkconditions ( tables . get ( 0 ) ) ) { system . out . println ( "true" ) ; } else { system . out . println ( "false" ) ; } }
