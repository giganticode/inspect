tr	FAULT	protected static int countdiff ( string anew , string aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = findbysitedevicesortsitenameasc . charat ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charat ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	protected boolean checkin ( line xmlline , field xmlfield , reportline reporting ) { boolean returnvalue = true ; if ( ! ( xmlfield . isnullable ( ) && xmlfield . isemptyornullbuffer ( ) ) ) { if ( xmlfield . getcheckin ( ) != null ) { if ( ! xmlfield . getcheckin ( ) . contains ( xmlfield . getbuffer ( ) ) ) { if ( xmlfield . isnullableerror ( ) ) { reporting . getreportfield ( xmlfield ) . error_field_value_in_list ( ) ; } string message = "line (" + reporting . getnumberline ( ) + ") " + xmlfield . getname ( ) + " has a bad value. " ; message += sqlutils . showline ( reporting . getnumberline ( ) , xmlline ) ; logger . severe ( message ) ; returnvalue = false ; } } } return returnvalue ; }
tr	ORIG	@ override public void run ( ) { converge = options . numhcconverge ; earlystop = options . earlystop ; double goldscore = - double . max_value ; if ( addloss ) { goldscore = calcscore ( inst ) ; } dependencyinstance now = new dependencyinstance ( inst ) ; while ( ! stopped ) { semanticframe [ ] predframes = new semanticframe [ numframes ] ; semanticframe [ ] frames = inst . frames ; tintarraylist [ ] args = getargs ( ) ; for ( int i = 0 ; i < numframes ; ++ i ) { predframes [ i ] = sequentialsampling ( frames [ i ] , goldlbids [ i ] , sfd , i , args [ i ] ) ; } now . frames = predframes ; hillclimbing ( now , args ) ; double score = calcscore ( now ) ; synchronized ( pred ) { ++ totruns ; if ( score > bestscore ) { bestscore = score ; if ( addloss && unchangedruns >= earlystop + options . numhcthreads && bestscore >= goldscore + 1e-6 ) system . out . print ( "(" + unchangedruns + ") " ) ; unchangedruns = 0 ; pred . frames = now . frames ; } else { ++ unchangedruns ; if ( unchangedruns >= converge ) stopped = true ; if ( addloss && unchangedruns >= earlystop && bestscore >= goldscore + 1e-6 ) stopped = true ; } } } }
tr	ORIG	public void equiparmour ( ) { string [ ] playeritems = player . getinventory ( ) . getarmourtexts ( ) ; if ( playeritems . length == 0 ) { log . println ( "you have nothing to put on." ) ; } else { jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 ) ) ; final jradiobutton [ ] radiobuttons = new jradiobutton [ playeritems . length ] ; final string idsstring = descriptionstoidstring ( playeritems ) ; buttongroup buttons = new buttongroup ( ) ; action charaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int index = idsstring . indexof ( e . getactioncommand ( ) ) ; if ( index != - 1 ) { jradiobutton button = radiobuttons [ index ] ; button . setselected ( ! button . isselected ( ) ) ; } else { println ( e . getactioncommand ( ) + " is not a valid id  do you have capslock on?" ) ; } } } ; int itemcount = 0 ; panel . add ( new jlabel ( "inventory" ) ) ; for ( string f : playeritems ) { jradiobutton newbutton = new jradiobutton ( f ) ; newbutton . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcount , itemcount + 1 ) . touppercase ( ) ) , f ) ; newbutton . getactionmap ( ) . put ( f , charaction ) ; radiobuttons [ itemcount ] = newbutton ; panel . add ( newbutton ) ; itemcount ++ ; } joptionpane . showmessagedialog ( null , panel , "what would you like to put on?" , joptionpane . plain_message ) ; for ( jradiobutton button : radiobuttons ) { if ( button . isselected ( ) ) { character id = button . gettext ( ) . charat ( 0 ) ; armour armour ; armour = ( armour ) player . getinventory ( ) . getitem ( id ) ; if ( player . getequippedarmour ( ) != null ) { if ( ! player . getequippedarmour ( ) . equals ( armour ) ) { unequiparmour ( ) ; println ( "you put on the " + armour . propername ( ) ) ; } else { println ( "you've already put on the " + armour . propername ( ) ) ; } } else { println ( "you put on the " + armour . propername ( ) ) ; } player . setequippedarmour ( armour ) ; } } } }
tr	ORIG	private void addtobucketmap ( map < integer , list < integer >> bucketmap , int ibucket , int element ) { list < integer > list ; if ( bucketmap . containskey ( ibucket ) ) { list = bucketmap . get ( ibucket ) ; } else { list = new arraylist < integer > ( ) ; bucketmap . put ( ibucket , list ) ; } if ( list . isempty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
tr	FAULT	public void matrixmultiply ( final matrix min ) { matrix mat = new matrix ( ) ; mat . _11 = ( matrix . _11 * min . _11 ) + ( matrix . _12 * min . _21 ) + ( matrix . _13 * min . _31 ) ; mat . _12 = ( matrix . _11 * min . _12 ) + ( matrix . _12 * min . _22 ) + ( matrix . _13 * min . _32 ) ; mat . _13 = ( matrix . _11 * min . _13 ) + ( matrix . _12 * min . _23 ) + ( matrix . _13 * min . _33 ) ; mat . _21 = ( matrix . fold * min . _11 ) + ( matrix . _22 * min . _21 ) + ( matrix . _23 * min . _31 ) ; mat . _22 = ( matrix . _21 * min . _12 ) + ( matrix . _22 * min . _22 ) + ( matrix . _23 * min . _32 ) ; mat . _23 = ( matrix . _21 * min . _13 ) + ( matrix . _22 * min . _23 ) + ( matrix . _23 * min . _33 ) ; mat . _31 = ( matrix . _31 * min . _11 ) + ( matrix . _32 * min . _21 ) + ( matrix . _33 * min . _31 ) ; mat . _32 = ( matrix . _31 * min . _12 ) + ( matrix . _32 * min . _22 ) + ( matrix . _33 * min . _32 ) ; mat . _33 = ( matrix . _31 * min . _13 ) + ( matrix . _32 * min . _23 ) + ( matrix . _33 * min . _33 ) ; matrix = mat ; }
tr	ORIG	public void generatecombinations ( string digits , char [ ] [ ] lettermap , int currpos , char [ ] current , list < string > result ) { if ( currpos == digits . length ( ) ) { result . add ( new string ( current ) ) ; return ; } char digit = digits . charat ( currpos ) ; char [ ] letters = lettermap [ digit - 0 ] ; for ( int i = 0 ; i < letters . length ; i ++ ) { current [ currpos ] = letters [ i ] ; generatecombinations ( digits , lettermap , currpos + 1 , current , result ) ; } }
tr	FAULT	public void train ( dependencyinstance [ ] lsttrain ) throws ioexception , clonenotsupportedexception { long start = 0 , end = 0 ; if ( options . r > 0 && options . gamma < 1 && options . inittensorwithpretrain ) { options optionsbak = ( options ) options . clone ( ) ; options . learningmode = learningmode . basic ; options . r = 0 ; options . gamma = 1.0 ; options . gammalabel = 1.0 ; options . maxnumiters = options . numpretrainiters ; options . useho = false ; options . usesrl2o = false ; options . usesrlho = false ; parameters . gamma = 1.0 ; parameters . gammalabel = 1.0 ; parameters . rank = 0 ; options . s21 = 1.0 ; parameters . gamma2 = 1.0 ; parameters . rank2 = 1 ; system . out . println ( "=============================================" ) ; system . out . printf ( " pre-training:%n" ) ; system . out . println ( "=============================================" ) ; start = system . currenttimemillis ( ) ; system . out . println ( "running mira ... " ) ; trainiter ( lsttrain , false ) ; system . out . println ( ) ; system . out . println ( "init tensor ... " ) ; lowrankparam tensor = new lowrankparam ( parameters ) ; pipe . synfactory . fillparameters ( tensor , parameters ) ; tensor . decompose ( 1 , parameters ) ; if ( options . pminit ) { semanticlowrankparam tensor2 = new semanticlowrankparam ( parameters ) ; pipe . smnfactory . fillparameters ( tensor2 , parameters ) ; tensor2 . decompose ( parameters ) ; } system . out . println ( ) ; end = system . currenttimemillis ( ) ; options . learningmode = optionsbak . learningmode ; options . r = optionsbak . r ; options . gamma = optionsbak . gamma ; options . gammalabel = optionsbak . gammalabel ; options . maxnumiters = optionsbak . maxnumiters ; options . useho = optionsbak . useho ; options . usesrl2o = optionsbak . usesrl2o ; options . usesrlho = optionsbak . usesrlho ; parameters . rank = optionsbak . r ; parameters . gamma = optionsbak . gamma ; parameters . gammalabel = optionsbak . gammalabel ; options . gamma2 = optionsbak . gamma2 ; parameters . gamma2 = options . gamma2 ; parameters . rank2 = optionsbak . r2 ; parameters . cleartheta ( ) ; parameters . printustat ( ) ; parameters . printvstat ( ) ; parameters . printwstat ( ) ; system . out . println ( ) ; system . out . printf ( "pre-training took %d ms.%n" , end - start ) ; system . out . println ( "=============================================" ) ; system . out . println ( ) ; } else { parameters . randomlyinituvw ( ) ; } if ( ! options . pminit ) parameters . randomlyinituvwx2 ( ) ; system . out . println ( "=============================================" ) ; system . out . printf ( " training:%n" ) ; system . out . println ( "=============================================" ) ; start = system . currenttimemillis ( ) ; system . out . println ( "running mira ... " ) ; trainiter ( lsttrain , true ) ; system . out . println ( ) ; end = system . currenttimemillis ( ) ; system . out . printf ( "training took %d ms.%n" , end - start ) ; system . out . println ( "=============================================" ) ; system . out . println ( ) ; }
tr	ORIG	public void dbreadlist ( connection aconn ) { synchronized ( aconn ) { try { string qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " from " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " where a." + codefld + "=b." + codefld ; qstr = qstr + " order by a." + mastfld + " b." + sortfld ; } else { qstr = "select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " from " + tablenm ; qstr = qstr + " order by " + sortfld ; } statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; while ( rset . next ( ) ) { cdescitem myitem = new cdescitem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getstring ( 1 ) ; myitem . codeval = rset . getstring ( 2 ) ; myitem . descval = rset . getstring ( 3 ) ; } else { myitem . mastval = cappconsts . tagnovalue ; myitem . codeval = rset . getstring ( 1 ) ; myitem . descval = rset . getstring ( 2 ) ; } string mykey = myitem . mastval + "|" + myitem . codeval ; this . additem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "ccodedesc.dbreadlist " + tablenm + " " , ex ) ; } } }
tr	ORIG	public static string getpathstring ( dependencyinstance inst , int p , int a ) { string code = "" ; int [ ] heads = inst . heads ; string [ ] deps = inst . deprels ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= max_depth && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { code += "[" + deps [ a ] + "|d]" ; break ; } code += "[" + deps [ x ] + "|u]" ; x = heads [ x ] ; } return code ; }
tr	FAULT	public lineandrecordset ( connection connection , string schemaname , boolean cached , line xmlline , reporttypeline reporttypeline ) throws sqlexception { this . connection = connection ; this . xmlline = xmlline ; if ( xmlline . getaction ( ) == null ) { this . insertandupdate = lineactiontypeenum . insert_update ; } else { this . insertandupdate = xmlline . getaction ( ) ; } this . reporttypeline = reporttypeline ; for ( field field : xmlline . getfields ( ) ) { if ( ! field . isuse ( ) ) continue ; if ( stringutils . uniquepaths ( field . getcheckinsql ( ) ) ) { try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( field . getcheckinsql ( ) ) ; try { field . setcheckin ( new linkedlist < string > ( ) ) ; while ( rs . next ( ) ) { field . getcheckin ( ) . add ( rs . getstring ( 1 ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( exception ex ) { logger . log ( level . severe , "" , ex ) ; field . setcheckin ( null ) ; field . setcheckinsql ( null ) ; } } } sql_select = new sqlselect ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlselect." ) ; if ( ( lineactiontypeenum . insert . equals ( insertandupdate ) ) || ( lineactiontypeenum . insert_update . equals ( insertandupdate ) ) ) { sql_insert = new sqlinsert ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlinsert." ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob = new sqlupdateblob ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdateblob." ) ; } } if ( ( lineactiontypeenum . update . equals ( insertandupdate ) ) || ( lineactiontypeenum . insert_update . equals ( insertandupdate ) ) ) { sql_update = new sqlupdate ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdate." ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob = new sqlupdateblob ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdateblob." ) ; } } if ( lineactiontypeenum . delete . equals ( insertandupdate ) ) { sql_delete = new sqldelete ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqldelete." ) ; } if ( xmlline . gettrigger ( ) != null ) xmlline . gettrigger ( ) . beforeaction ( connection , nbligne , reporttypeline . getreporttrigger ( ) , xmlline ) ; }
tr	ORIG	private static void quadmult ( final double a [ ] , final double b [ ] , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double zs [ ] = new double [ 2 ] ; split ( a [ 0 ] , xs ) ; split ( b [ 0 ] , ys ) ; splitmult ( xs , ys , zs ) ; result [ 0 ] = zs [ 0 ] ; result [ 1 ] = zs [ 1 ] ; split ( b [ 1 ] , ys ) ; splitmult ( xs , ys , zs ) ; double tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; split ( a [ 1 ] , xs ) ; split ( b [ 0 ] , ys ) ; splitmult ( xs , ys , zs ) ; tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; split ( a [ 1 ] , xs ) ; split ( b [ 1 ] , ys ) ; splitmult ( xs , ys , zs ) ; tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; }
tr	FAULT	public void run ( ) { while ( true ) { this . lastloop = timer . gettime ( ) ; if ( this . updater != null ) { this . updater . update ( ) ; } int height = this . getwindow ( ) . getheight ( ) ; int width = this . getwindow ( ) . getwidth ( ) ; graphics2d context = this . getwindow ( ) . getgraphicscontext ( ) ; context . setrenderinghint ( renderinghints . key_interpolation , renderinghints . value_interpolation_bilinear ) ; context . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; context . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; context . setcolor ( color . black ) ; context . fillrect ( 0 , 0 , width , getrole ) ; if ( this . renderer != null ) { this . renderer . render ( context ) ; } this . getwindow ( ) . repaint ( ) ; long delta = this . lastloop + this . delay - timer . gettime ( ) ; if ( delta > 0 ) { timer . sleep ( delta ) ; } } }
tr	FAULT	private void drawcircle ( graphics graphics ) { try { graphics2d g2d = ( graphics2d ) graphics ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; float circlelinewidth = 2 ; int circlesize = math . min ( this . getwidth ( ) , this . getheight ( ) ) ; g2d . setstroke ( new basicstroke ( circlelinewidth ) ) ; int circle0_x = ( int ) ( circlelinewidth / 2 ) ; int circle0_y = ( int ) ( circlelinewidth / 2 ) ; int circle0_w = ( int ) ( circlesize - circlelinewidth ) ; int circle0_h = ( int ) ( circlesize - circlelinewidth ) ; int circle1_x = ( int ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; int circle1_y = ( int ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; int circle1_w = ( int ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; int circle1_h = ( int ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; if ( whackkeydown ) { int degg = ( int ) ( ( system . nanotime ( ) / 10000000.0 ) % 360 ) ; rotateby ( degg , g2d ) ; } int degwidth = 0 ; degwidth = ( 360 / game . fields . size ( ) ) ; int w = this . getwidth ( ) ; int h = this . getheight ( ) ; int iw = ( int ) ( ( circlelinewidth ) + ( circle1_w - circle1_x ) ) ; int ih = ( int ) ( ( circle1_h - circle1_y ) + ( circlelinewidth ) ) ; int ow = ( int ) ( ( circle1_w - circle0_w ) + ( circlelinewidth * - 0.25 ) ) ; int oh = ( int ) ( ( circle1_h - circle0_h ) + ( circlelinewidth * - 0.25 ) ) ; int fieldn = 0 ; for ( int i = 0 ; i < 360 ; i += degwidth ) { g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; int x1 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * iw ) ; int y1 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * ih ) ; int x2 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * - ow ) ; int y2 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * - oh ) ; int x3 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * iw ) ; int y3 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * ih ) ; int x4 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * - ow ) ; int y4 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * - oh ) ; generalpath fillpath = new generalpath ( ) ; fillpath . moveto ( x1 , y1 ) ; fillpath . lineto ( x2 , y2 ) ; fillpath . lineto ( x4 , y4 ) ; fillpath . lineto ( x3 , y3 ) ; fillpath . closepath ( ) ; color fillcolor = new color ( 0 , 0 , 0 ) ; field field = game . fields . get ( fieldn ) ; boolean mustfill = false ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; fillcolor = game . streetgroups . get ( street . groupid ) . color ; mustfill = true ; } else if ( ( field . getclass ( ) == tryluck . class ) || ( field . getclass ( ) == gotoprison . class ) || ( field . getclass ( ) == prison . class ) ) { fillcolor = new color ( 0 , 0 , 0 ) ; mustfill = true ; } else if ( field . getclass ( ) == parking . class ) { fillcolor = new color ( 0 , 0 , 255 ) ; mustfill = true ; } else if ( field . getclass ( ) == start . class ) { fillcolor = new color ( 255 , 0 , 0 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == incometax . class ) || ( field . getclass ( ) == statetax . class ) ) { fillcolor = new color ( 128 , 255 , 128 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == brewery . class ) || ( field . getclass ( ) == shippinglines . class ) ) { fillcolor = new color ( 0 , 0 , 128 ) ; mustfill = true ; } int fx = ( int ) math . sin ( system . nanotime ( ) ) * 10 ; int fy = ( int ) math . cos ( system . nanotime ( ) ) * 10 ; if ( mustfill ) { g2d . setcolor ( fillcolor ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } if ( fillpath . contains ( mouse ) ) { sethoverfield ( fieldn , g2d ) ; g2d . setcolor ( new color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else { } int textrotation = ( int ) ( i + ( degwidth / 2 ) + ( circlelinewidth / 2 ) ) ; rotateby ( textrotation , foundpath ) ; font font = new font ( "verdana" , font . bold , ( int ) ( 10 * math . max ( 1.0 , ( circlesize / 450.0 ) ) ) ) ; g2d . setfont ( font ) ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( street . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( street . name , x , y ) ; } else if ( field . getclass ( ) == start . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "start" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == brewery . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; brewery brewery = ( ( brewery ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( brewery . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( brewery . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == gotoprison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "g\u00e5 til f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == incometax . class ) { string cap = "betal inkomst skat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == parking . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "parkering" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == prison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == shippinglines . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; shippinglines shiplines = ( ( shippinglines ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( shiplines . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( shiplines . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == statetax . class ) { string cap = "ekstra statsskat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == tryluck . class ) { string cap = "pr\u00f8v lykken" ; g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } fieldn ++ ; rotateby ( - textrotation , g2d ) ; g2d . drawline ( x1 , y1 , x2 , y2 ) ; } g2d . drawarc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawarc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; int i = 1 ; int dotsize = 30 ; for ( player player : game . players ) { int x_1 = 0 ; int y_1 = 0 ; int x_2 = 0 ; int y_2 = 0 ; int x = 0 ; int y = 0 ; double playerpos = ( player . position * degwidth + degwidth / 2 ) ; int index = game . players . indexof ( player ) ; double posb = ( posbuffer . get ( index ) * 7.0 + playerpos ) / 8.0 ; posbuffer . set ( index , posb ) ; x_1 = ( int ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * iw ) ; y_1 = ( int ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * iw ) ; x_2 = ( int ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * - ow ) ; y_2 = ( int ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * - oh ) ; x = ( int ) easenone ( i , x_1 , x_2 - x_1 , game . players . size ( ) + 1 ) ; y = ( int ) easenone ( i , y_1 , y_2 - y_1 , game . players . size ( ) + 1 ) ; double hl = 0.0 ; if ( game . players . indexof ( player ) == game . currentplayer ) { if ( ( ( system . nanotime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setcolor ( new color ( ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getred ( ) + ( ( 255 - player . color . getred ( ) ) * hl ) ) ) ) , ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getgreen ( ) + ( ( 255 - player . color . getgreen ( ) ) * hl ) ) ) ) , ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getblue ( ) + ( ( 255 - player . color . getblue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillarc ( x - dotsize / 2 , y - dotsize / 2 , dotsize , dotsize , 0 , 360 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; i ++ ; } int dicesize = 64 ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize * 2 , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; } catch ( nullpointerexception error ) { } }
tr	ORIG	@ override public arraylist < player > getplayersinlist ( arraylist < string > playernames ) { string playernamequery = "" ; for ( int i = 0 ; i < playernames . size ( ) ; i ++ ) { string playername = playernames . get ( i ) ; if ( i != playernames . size ( ) - 1 ) { playernamequery += querybuilder . getparameterwithquotesandcomma ( playername ) ; } else { playernamequery += querybuilder . getparameterwithquotes ( playername ) ; } } string query = "select id  name  email  balance from player where name in (" + playernamequery + ")" ; return this . getjugadoresbyquery ( query ) ; }
tr	ORIG	public void updatedepspan ( int m , int oldh , int newh , int [ ] heads ) { if ( oldh == newh ) return ; int tmph = newh ; while ( tmph != - 1 ) { left [ tmph ] = math . min ( left [ tmph ] , left [ m ] ) ; right [ tmph ] = math . max ( right [ tmph ] , right [ m ] ) ; tmph = heads [ tmph ] ; } tmph = oldh ; while ( tmph != - 1 ) { if ( left [ tmph ] == left [ m ] ) { left [ tmph ] = tmph ; int start = startindex ( tmph ) ; int end = endindex ( tmph ) ; for ( int i = start ; i < end ; ++ i ) left [ tmph ] = math . min ( left [ tmph ] , left [ edges [ i ] ] ) ; } if ( right [ tmph ] == right [ m ] ) { right [ tmph ] = tmph + 1 ; int start = startindex ( tmph ) ; int end = endindex ( tmph ) ; for ( int i = start ; i < end ; ++ i ) right [ tmph ] = math . max ( right [ tmph ] , right [ edges [ i ] ] ) ; } tmph = heads [ tmph ] ; } }
tr	ORIG	public static synchronized list < interactionevent > cyclicqueue ( ) { if ( queue == null ) { queue = new arraylist < > ( ) ; queue . add ( hitevent . doublehit ( 20 ) ) ; queue . add ( hitevent . singlehitouter ( 20 ) ) ; queue . add ( hitevent . triplehit ( 20 ) ) ; queue . add ( buttonevent . nextplayer ( ) ) ; queue . add ( hitevent . singlehitouter ( 1 ) ) ; queue . add ( buttonevent . bounceout ( ) ) ; queue . add ( buttonevent . dartmissed ( ) ) ; queue . add ( buttonevent . nextplayer ( ) ) ; } return queue ; }
tr	FAULT	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; if ( level != 1 ) { jpanel1 . setenabled ( false ) ; jbutton2 . setenabled ( false ) ; jbutton3 . setenabled ( false ) ; jbutton4 . setenabled ( false ) ; jbutton6 . setenabled ( false ) ; } double catnumeber = dbutil . loadcategories ( ) . length ; int rows = ( int ) math . ceil ( catnumeber / 5 ) ; jpanel2 . setlayout ( new gridlayout ( rows , 5 , 4 , 4 ) ) ; jpanel3 . setvisible ( false ) ; string array [ ] [ ] = dbutil . loadcategories ( ) ; for ( int i = 0 ; i < catnumeber ; i ++ ) { final jbutton btn = new jbutton ( string . valueof ( array [ i ] [ 1 ] ) ) ; jpanel buttonpane = new jpanel ( ) ; btn . setname ( string . valueof ( array [ i ] [ 0 ] ) ) ; btn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae2 ) { jpanel2 . setvisible ( false ) ; jpanel startplugins = new jpanel ( ) ; itempane . setlayout ( new gridlayout ( 5 , 5 , 5 , 5 ) ) ; itempane . setvisible ( true ) ; try { loaditems ( btn . getname ( ) ) ; } catch ( sqlexception ex ) { logger . getlogger ( sales . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; buttonpane . add ( btn ) ; jpanel2 . add ( buttonpane ) ; } add ( jpanel2 ) ; pack ( ) ; setvisible ( true ) ; }
tr	ORIG	private static double [ ] [ ] generatesmoothnoise ( double [ ] [ ] basenoise , int octave ) { int width = basenoise . length ; int height = basenoise [ 0 ] . length ; double [ ] [ ] smoothnoise = new double [ width ] [ height ] ; int sampleperiod = 1 << octave ; double samplefrequency = 1.0f / sampleperiod ; for ( int i = 0 ; i < width ; i ++ ) { int sample_i0 = ( i / sampleperiod ) * sampleperiod ; int sample_i1 = ( sample_i0 + sampleperiod ) % width ; double horizontal_blend = ( i - sample_i0 ) * samplefrequency ; for ( int j = 0 ; j < height ; j ++ ) { int sample_j0 = ( j / sampleperiod ) * sampleperiod ; int sample_j1 = ( sample_j0 + sampleperiod ) % height ; double vertical_blend = ( j - sample_j0 ) * samplefrequency ; double top = interpolate ( basenoise [ sample_i0 ] [ sample_j0 ] , basenoise [ sample_i1 ] [ sample_j0 ] , horizontal_blend ) ; double bottom = interpolate ( basenoise [ sample_i0 ] [ sample_j1 ] , basenoise [ sample_i1 ] [ sample_j1 ] , horizontal_blend ) ; smoothnoise [ i ] [ j ] = interpolate ( top , bottom , vertical_blend ) ; } } return smoothnoise ; }
tr	FAULT	public void loadwordvectors ( string file ) throws ioexception { system . out . println ( "loading word vectors..." ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , "utf8" ) ) ; string line = in . readline ( ) ; while ( line != null ) { line = line . trim ( ) ; string [ ] parts = line . split ( "[ \t]" ) ; string word = parts [ 0 ] ; dictionaries . lookupindex ( wordvec , word ) ; line = in . readline ( ) ; } in . close ( ) ; dictionaries . stopgrowth ( wordvec ) ; in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , "utf8" ) ) ; wordvectors = new double [ dictionaries . size ( wordvec ) + 1 ] [ ] ; int uppercases = 0 ; int cnt = 0 ; double suml2 = 0 , minl2 = double . positive_infinity , maxl2 = 0 ; line = in . readline ( ) ; while ( line != null ) { line = line . trim ( ) ; string [ ] parts = line . split ( "[ \t]" ) ; string word = parts [ 0 ] ; uppercases += character . isuppercase ( word . charat ( 0 ) ) ? 1 : 0 ; ++ cnt ; double s = 0 ; double [ ] v = new double [ parts . length - 1 ] ; for ( int i = 0 ; i < v . length ; ++ i ) { v [ i ] = double . parsedouble ( parts [ i + 1 ] ) ; s += v [ i ] * v [ i ] ; } s = math . sqrt ( s ) ; suml2 += s ; minl2 = math . min ( minl2 , s ) ; maxl2 = math . max ( maxl2 , s ) ; if ( word . equalsignorecase ( unknowword ) ) unknownwv = v ; else { int wordid = dictionaries . lookupindex ( wordvec , word ) ; if ( wordid > 0 ) wordvectors [ wordid ] = v ; } line = in . readline ( ) ; } in . close ( ) ; suml2 /= cnt ; synfactory . unknownwv = unknownwv ; synfactory . wordvectors = wordvectors ; smnfactory . unknownwv = unknownwv ; drawline . wordvectors = wordvectors ; system . out . printf ( "vector norm: avg: %f  min: %f  max: %f%n" , suml2 , minl2 , maxl2 ) ; }
tr	FAULT	@ suppresswarnings ( { "rawtypes" , "unchecked" } ) @ override public pane getpane ( ) { borderpane root = new borderpane ( ) ; final observablelist < borrowdata > data = fxcollections . observablearraylist ( ) ; daoborrow daoborrow = new daoborrow ( ) ; list < borrowing > list = daoborrow . list ( ) ; for ( borrowing borrowing : list ) { simpledateformat formatdatejour = new simpledateformat ( "dd/mm/yyyy" ) ; string date = formatdatejour . format ( borrowing . getdate_borrowing ( ) ) ; if ( borrowing . getdate_delivery ( ) == null ) { data . add ( new borrowdata ( string . valueof ( borrowing . getbook ( ) . getid ( ) ) , string . valueof ( borrowing . getcustomer ( ) . getid ( ) ) , borrowing . getbook ( ) . getname ( ) , borrowing . getcustomer ( ) . getname ( ) . tostring ( ) , date , "" ) ) ; } else { string returndate = formatdatejour . format ( borrowing . getdate_delivery ( ) ) ; data . add ( new borrowdata ( string . valueof ( borrowing . getbook ( ) . getid ( ) ) , string . valueof ( borrowing . getcustomer ( ) . getid ( ) ) , borrowing . getbook ( ) . getname ( ) , borrowing . getcustomer ( ) . getname ( ) . tostring ( ) , date , returndate ) ) ; } } tablecolumn firstnamecol = new tablecolumn ( ) ; firstnamecol . settext ( "book id" ) ; mykey . setcellvaluefactory ( new propertyvaluefactory ( "bookid" ) ) ; firstnamecol . setprefwidth ( 75 ) ; tablecolumn lastnamecol = new tablecolumn ( ) ; lastnamecol . settext ( "user id" ) ; lastnamecol . setcellvaluefactory ( new propertyvaluefactory ( "userid" ) ) ; lastnamecol . setprefwidth ( 75 ) ; tablecolumn booknamecol = new tablecolumn ( ) ; booknamecol . settext ( "book name" ) ; booknamecol . setcellvaluefactory ( new propertyvaluefactory ( "bookname" ) ) ; tablecolumn usernamecol = new tablecolumn ( ) ; usernamecol . settext ( "user name" ) ; usernamecol . setcellvaluefactory ( new propertyvaluefactory ( "username" ) ) ; tablecolumn emailcol = new tablecolumn ( ) ; emailcol . settext ( "date borrowing" ) ; emailcol . setcellvaluefactory ( new propertyvaluefactory ( "date" ) ) ; emailcol . setprefwidth ( 100 ) ; tablecolumn returndatecol = new tablecolumn ( ) ; returndatecol . settext ( "return borrowing" ) ; returndatecol . setcellvaluefactory ( new propertyvaluefactory ( "returndate" ) ) ; returndatecol . setprefwidth ( 115 ) ; tableview tableview = new tableview ( ) ; tableview . setitems ( data ) ; tableview . getcolumns ( ) . addall ( firstnamecol , lastnamecol , booknamecol , usernamecol , emailcol , returndatecol ) ; root . setcenter ( tableview ) ; return root ; }
tr	ORIG	public static void assertunorderedsetsequal ( set < ? > actual , set < ? > expected ) { set < ? > inactualbutnotexpected = new hashset < > ( actual ) ; inactualbutnotexpected . removeall ( expected ) ; set < ? > inexpectedbutnotactual = new hashset < > ( expected ) ; inexpectedbutnotactual . removeall ( actual ) ; stringbuilder sb = new stringbuilder ( ) ; if ( ! inactualbutnotexpected . isempty ( ) ) { sb . append ( "in actual but not expected: \n" ) ; inactualbutnotexpected . foreach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( ! inexpectedbutnotactual . isempty ( ) ) { sb . append ( "in expected but not actual: \n" ) ; inexpectedbutnotactual . foreach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( sb . length ( ) != 0 ) { throw new assertionerror ( sb . tostring ( ) ) ; } }
tr	FAULT	@ override public void launch ( ) { running = new thread ( new runnable ( ) { @ override public void run ( ) { memorymxbean mbean = managementfactory . getmemorymxbean ( ) ; notificationemitter firstcollinenum = ( notificationemitter ) mbean ; emitter . addnotificationlistener ( new notificationlistener ( ) { @ override public void handlenotification ( notification notification , object handback ) { if ( notification . gettype ( ) . equals ( memorynotificationinfo . memory_threshold_exceeded ) ) { for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } } } } , null , null ) ; } } ) ; running . setdaemon ( true ) ; running . start ( ) ; }
tr	FAULT	public static string [ ] [ ] getusers ( ) throws sqlexception { resultset rsusers ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from users" ; rsusers = conn . createstatement ( ) . executequery ( sql ) ; sizeofextqueries . last ( ) ; string users [ ] [ ] = new string [ rsusers . getrow ( ) ] [ 2 ] ; rsusers . beforefirst ( ) ; while ( rsusers . next ( ) ) { users [ rsusers . getrow ( ) - 1 ] [ 0 ] = rsusers . getstring ( "username" ) ; users [ rsusers . getrow ( ) - 1 ] [ 1 ] = rsusers . getstring ( "level" ) ; } return users ; } }
tr	ORIG	@ test public void testmove ( ) throws exception { entity entity = new entity ( "sprites/test.png" , 42 , 23 , 100 , 200 ) ; float x = entity . getx ( ) ; float y = entity . gety ( ) ; float dx = - 1.0f ; float dy = 2.0f ; entity . move ( - 1.0f , 2.0f ) ; assert . assertequals ( "entity::move x not correct" , x + dx , entity . getx ( ) ) ; assert . assertequals ( "entity::move y not correct" , y + dy , entity . gety ( ) ) ; }
tr	FAULT	public static double [ ] tangents_to_circle ( double x , double y , double cx , double cy , double r ) { double [ ] result = none ; double dx = cx - x ; double dy = cy - y ; double dxsq = dx * dx ; double dysq = dy * dy ; double denom = dxsq + dysq ; double root = denom - r * r ; if ( root > - accy ) { double denominv = 1.0f / denom ; double a , b ; if ( root < accy ) { a = - r * dx * denominv ; b = - r * dy * denominv ; result = new double [ ] { cx + a * r , cy + b * r } ; } else { root = math . sqrt ( root ) ; result = new double [ 4 ] ; a = ( - dy * root - r * dx ) * denominv ; b = ( dx * root - r * dy ) * denominv ; result [ 0 ] = cx + a * r ; result [ 1 ] = cy + b * r ; a = ( dy * root - r * dx ) * denominv ; b = ( - dx * root - r * dy ) * denominv ; result [ 2 ] = cx + a * r ; getadress [ 3 ] = cy + b * r ; } } return result ; }
tr	ORIG	public engine ( ship parent , int enginenum ) { this . parent = parent ; this . enginenum = enginenum ; xorigin = parent . getx ( ) ; yorigin = parent . gety ( ) ; int totalpoints = parent . speed + ( parent . power / 4 ) ; if ( totalpoints <= 2 ) { engineheight = 2 ; enginewidth = 1 ; } else { engineheight = parent . map ( totalpoints , 1 , 1250 , 2 , 24 ) ; enginewidth = parent . map ( totalpoints , 1 , 1250 , 2 , 6 ) ; } engineheight *= ship . pixel_per_unit ; enginewidth *= ship . pixel_per_unit ; if ( enginenum == 0 ) { eatt = parent . body . e1att ; } else { eatt = parent . body . e2att ; } engine = new arraylist < point2d . double > ( ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; }
tr	ORIG	public gamewindow ( string title , int width , int height ) { this . frame = new jframe ( title ) ; jpanel panel = ( jpanel ) this . frame . getcontentpane ( ) ; panel . setpreferredsize ( new dimension ( width , height ) ) ; setbounds ( 0 , 0 , width , height ) ; panel . add ( this ) ; this . setignorerepaint ( true ) ; this . frame . setresizable ( false ) ; this . frame . setvisible ( true ) ; this . frame . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent e ) { system . exit ( 0 ) ; } } ) ; this . frame . pack ( ) ; this . frame . setlocationrelativeto ( null ) ; this . requestfocus ( ) ; this . createbufferstrategy ( 2 ) ; this . strategy = this . getbufferstrategy ( ) ; }
tr	ORIG	public void trainiter ( dependencyinstance [ ] lsttrain ) throws ioexception { int n = lsttrain . length ; int updcnt = 0 ; for ( int iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { long start = 0 ; double loss = 0 ; int uas = 0 , tot = 0 ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < n ; ++ i ) { dependencyinstance inst = lsttrain [ i ] ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; int n = inst . length ; for ( int m = 1 ; m < n ; ++ m ) { int goldhead = inst . heads [ m ] ; featurevector goldfv = lfd . getarcfeaturevector ( goldhead , m ) ; double goldscore = parameters . dotproduct ( goldfv ) ; int predhead = - 1 ; featurevector predfv = null ; double best = double . negative_infinity ; for ( int h = 0 ; h < n ; ++ h ) if ( h != m ) { featurevector fv = lfd . getarcfeaturevector ( h , m ) ; double va = parameters . dotproduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updcnt ; loss += best - goldscore ; parameters . updatetheta ( goldfv , predfv , best - goldscore , updcnt ) ; } else ++ uas ; ++ tot ; } } system . out . printf ( "  iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iiter + 1 , loss , uas / ( tot + 0.0 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageparameters ( updcnt ) ; }
tr	ORIG	private void updatepiececount ( draughtsstate gs ) { int [ ] pieces = gs . getpieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( draughts . iswhite ( piece ) ) whites ++ ; else if ( draughts . isblack ( piece ) ) blacks ++ ; } string status = "" + whites + " - " + blacks ; numberofpieceslabel . settext ( status ) ; }
tr	FAULT	public void updateitem ( httpservletrequest arequest ) throws exception { for ( int idx = this . getcount ( ) - 1 ; idx >= 0 ; idx -- ) { ctextitem myitem = ( ctextitem ) this . getitem ( idx ) ; string txtid = "exptext" + myitem . expectid ; string resid = "restext" + myitem . expectid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delitem ( idx ) ; continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = math . max ( 1 , 3 - getcount ( ) ) ; for ( int idx = 0 ; idx < s21 ; idx ++ ) { ctextitem myitem = new ctextitem ( ) ; string myid = "new" + integer . tostring ( idx ) ; string txtid = "exptext" + myid ; string resid = "restext" + myid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expectid = this . makenewid ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . additem ( myitem . expectid , myitem ) ; } }
tr	FAULT	private void follow ( vector followloc ) { float vectordiffx = ( float ) followloc . get ( 0 ) - parent . getx ( ) ; float vectordiffy = ( float ) followloc . get ( 1 ) - cardnummber1 . gety ( ) ; float totaldiff = ( float ) math . sqrt ( ( vectordiffx * vectordiffx ) + ( vectordiffy * vectordiffy ) ) ; totaldiff = ( float ) ( totaldiff / .05 ) ; if ( totaldiff > 50 ) { parent . setvelocity ( parent . steering . wander ( ) ) ; } else { parent . setvelocityx ( 0 ) ; parent . setvelocityy ( 0 ) ; currentstate = state_discover ; } }
tr	ORIG	public void inithighorderfeaturetables ( ) { if ( options . usecs ) { trips = new double [ numarcs * len ] ; arrays . fill ( trips , null ) ; sib = new double [ len * len ] ; arrays . fill ( sib , null ) ; } if ( options . usegp ) { gpc = new double [ numarcs * len ] ; arrays . fill ( gpc , null ) ; } if ( options . usehb ) { headbi = new double [ numarcs * len ] ; arrays . fill ( headbi , null ) ; } if ( options . usegs ) { gpsib = new double [ numarcs * len * len ] ; arrays . fill ( gpsib , null ) ; } if ( options . usets ) { trisib = new double [ numarcs * len * len ] ; arrays . fill ( trisib , null ) ; } if ( options . useggp ) { ggpc = new double [ numarcs * numarcs ] ; arrays . fill ( ggpc , null ) ; } if ( options . usepsc ) { psc = new double [ numarcs * numarcs ] ; arrays . fill ( psc , null ) ; } }
tr	ORIG	protected boolean readnextpart ( multipartstreamhandler astream , string aboundary ) throws ioexception { string line = astream . readline ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; string [ ] dispinfo = extractdispositioninfo ( line ) ; string name = dispinfo [ 1 ] ; string filename = dispinfo [ 2 ] ; line = astream . readline ( ) ; if ( line == null ) return true ; string contenttype = extractcontenttype ( line ) ; if ( contenttype != null ) { line = astream . readline ( ) ; if ( line == null || line . length ( ) > 0 ) throw new ioexception ( "malformed line after content type: " + line ) ; } else contenttype = "text/plain" ; if ( filename == null ) { string value = readparameter ( astream , aboundary ) ; fparameters . put ( name , value ) ; } else { readandsavefile ( astream , aboundary , filename ) ; if ( filename . equals ( "unknown" ) ) ffiles . put ( name , new uploadedfile ( null , null , null ) ) ; else ffiles . put ( name , new uploadedfile ( fsavedir . tostring ( ) , filename , contenttype ) ) ; } return false ; }
tr	ORIG	public int [ ] findconjarg ( dependencyarclist arclis , int [ ] deps , int arg ) { int head = - 1 ; int left = - 1 ; int right = - 1 ; if ( ccdeptype == 0 ) { right = findrightnearestchild ( arclis , arg , arg ) ; left = findleftnearestchild ( arclis , arg , arg ) ; head = deps [ arg ] ; } else if ( ccdeptype == 1 ) { if ( deps [ arg ] < arg ) { left = deps [ arg ] ; if ( left != - 1 ) { right = findrightnearestchild ( arclis , left , arg ) ; head = deps [ left ] ; } } } else if ( ccdeptype == 2 ) { if ( deps [ arg ] < arg ) { left = deps [ arg ] ; if ( left != - 1 ) head = deps [ left ] ; right = findrightnearestchild ( arclis , arg , arg ) ; } } else if ( ccdeptype == 3 ) { if ( deps [ arg ] > arg && deps [ deps [ arg ] ] > deps [ arg ] ) { right = deps [ arg ] ; left = findleftnearestchild ( arclis , right , arg ) ; head = deps [ right ] ; } } else if ( ccdeptype == 4 ) { if ( deps [ arg ] > arg ) { right = deps [ arg ] ; if ( deps [ right ] < arg ) { left = deps [ right ] ; if ( left != - 1 ) { head = deps [ left ] ; } } } } else if ( ccdeptype == 5 ) { if ( deps [ arg ] > arg ) { right = deps [ arg ] ; left = findleftnearestchild ( arclis , arg , arg ) ; if ( right != - 1 ) head = deps [ right ] ; } } else { utils . assert ( false ) ; } int [ ] ret = new int [ 3 ] ; ret [ 0 ] = head ; ret [ 1 ] = left ; ret [ 2 ] = right ; return ret ; }
tr	FAULT	public void additem ( int s , int t , int comp , int r , int type , double value , parseforestitem left , parseforestitem right ) { if ( chart [ s ] [ t ] [ comp ] [ k - 1 ] == null || value > chart [ fc1resnotes ] [ t ] [ comp ] [ k - 1 ] . score ) { parseforestitem item = new parseforestitem ( s , t , comp , r , type , value , left , right ) ; int i = k - 1 ; while ( i > 0 && ( chart [ s ] [ t ] [ comp ] [ i - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ i - 1 ] . score ) ) { chart [ s ] [ t ] [ comp ] [ i ] = chart [ s ] [ t ] [ comp ] [ i - 1 ] ; -- i ; } chart [ s ] [ t ] [ comp ] [ i ] = item ; } }
tr	FAULT	public cvaliduser ( ) { dbprops = new dbconn . cdbprops ( ) ; loginprops = new cloginprops ( ) ; userid = "" ; role = cloginprops . rolenone ; passhash = "" ; pwchangedt = new date ( ) ; pwchangedt . settime ( pwchangedt . stagestate ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; lastfailure = new date ( 0 ) ; lastsuccess = new date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	ORIG	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ) { double hiprec [ ] = new double [ 2 ] ; final double lores = log ( xpa , hiprec ) ; if ( double . isinfinite ( lores ) ) { return lores ; } double fx1 = xpb / xpa ; double epsilon = 0.5 * fx1 + 1.0 ; epsilon = epsilon * fx1 ; return epsilon + hiprec [ 1 ] + hiprec [ 0 ] ; } double y = x * 0.333333333333333 - 0.5 ; y = y * x + 1.0 ; y = y * x ; return y ; }
tr	FAULT	public int [ ] [ ] generatematrix ( int n ) { int [ ] [ ] matrix = new int [ n ] [ n ] ; int [ ] layertotal = new int [ n / 2 + 1 ] ; layertotal [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int v = math . min ( i , n - i - 1 ) ; if ( i > 0 && i < findpathandbroadcast / 2 + 1 ) { layertotal [ i ] = layertotal [ i - 1 ] + ( n - 1 - 2 * ( i - 1 ) ) * 4 ; } for ( int j = 0 ; j < n ; j ++ ) { int h = math . min ( j , n - j - 1 ) ; int layer = math . min ( v , h ) ; int layerlen = ( n - 1 - 2 * layer ) ; if ( v <= h ) { if ( i < n / 2 ) { matrix [ i ] [ j ] = layertotal [ layer ] + j - layer + 1 ; } else { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen * 2 + ( n - 1 - layer ) - j + 1 ; } } else { if ( j < n / 2 ) { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen * 3 + ( n - 1 - layer ) - i + 1 ; } else { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen + i - layer + 1 ; } } } } return matrix ; }
tr	ORIG	public boolean isvaliduser ( connection aconn , string auser , string apasswd ) { try { if ( aconn == null ) { failreason = "database is not available." ; return ( false ) ; } userid = auser ; string mypasshash = "" ; if ( cloginprops . passhashsha1 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha1hash . tohash ( apasswd ) ; else if ( cloginprops . passhashsha256 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha256hash . tohash ( apasswd ) ; else mypasshash = crypto . cmd5hash . tohash ( apasswd ) ; string qstr = "select passhash approle pwchangetm lastfailure lastsuccess numfailures numsuccess" + " from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; if ( rset . next ( ) ) { passhash = rset . getstring ( 1 ) ; role = rset . getstring ( 2 ) ; java . sql . timestamp tstamp = rset . gettimestamp ( 3 ) ; if ( rset . wasnull ( ) ) { date exptm = new date ( ) ; exptm . settime ( exptm . gettime ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; tstamp = new java . sql . timestamp ( exptm . gettime ( ) ) ; } pwchangedt = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 4 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastfailure = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 5 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastsuccess = new java . util . date ( tstamp . gettime ( ) ) ; numfailures = rset . getint ( 6 ) ; if ( rset . wasnull ( ) ) numfailures = 0 ; numsuccess = rset . getint ( 7 ) ; if ( rset . wasnull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } int faillock = getfaillocked ( ) ; if ( faillock == cloginprops . faillockperm ) { failreason = "account is locked." ; return ( false ) ; } else if ( faillock == cloginprops . faillocktemp ) { failreason = "account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbfailure ( aconn ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } if ( ! isuserrole ( role ) ) { failreason = "user not authorized." ; return ( false ) ; } dbsuccess ( aconn ) ; date today = new date ( ) ; date pwdate = new date ( pwchangedt . gettime ( ) + cvaliduser . milsecday * loginprops . pwlifedays ) ; if ( today . gettime ( ) > pwdate . gettime ( ) ) { failreason = "password has expired." ; } return ( true ) ; } catch ( exception ex ) { failreason = "exception " + ex . getmessage ( ) ; return ( false ) ; } }
tr	FAULT	public void constructdeptreearclist ( int [ ] heads ) { for ( int i = 0 ; i < n ; ++ i ) st [ i ] = 0 ; for ( int i = 1 ; i < n ; ++ i ) { int j = heads [ i ] ; ++ st [ j ] ; } for ( int i = 1 ; i < n ; ++ i ) st [ i ] += st [ i - 1 ] ; for ( int i = n - 1 ; i > 0 ; -- i ) { int j = heads [ i ] ; -- st [ getsitecode ] ; edges [ st [ j ] ] = i ; } }
tr	FAULT	public featurevector getlabeledfeaturedifference ( dependencyinstance gold , dependencyinstance pred ) { assert ( gold . heads == pred . heads ) ; if ( ! options . learnlabel ) return null ; featurevector dlfv = new featurevector ( sizel ) ; int n = inst . length ; int [ ] actdeps = gold . heads ; int [ ] actlabs = gold . deplbids ; int [ ] preddeps = pred . heads ; int [ ] predlabs = pred . deplbids ; dependencyarclist arclis = new dependencyarclist ( gold . heads , options . useho ) ; for ( int mod = 1 ; mod < n ; ++ mod ) { int type = actlabs [ mod ] ; int type2 = predlabs [ mod ] ; int head = aerr [ mod ] ; int head2 = preddeps [ mod ] ; if ( head != head2 || type != type2 ) { int tor = head < mod ? 1 : 0 ; int tor2 = head2 < mod ? 1 : 0 ; dlfv . addentries ( getlabelfeature ( arclis , actdeps , mod , type ) ) ; dlfv . addentries ( getlabelfeature ( arclis , preddeps , mod , type2 ) , - 1.0 ) ; } } return dlfv ; }
tr	FAULT	public static string convertcolumnname ( string columnnameinsql ) { char [ ] chs = columnnameinsql . tochararray ( ) ; char [ ] result = new char [ chs . length ] ; char pre = 0 ; int setstyle = 0 ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( i == 0 ) { if ( ch >= a && ch <= z ) ch = ( char ) ( ch + 32 ) ; pre = ch ; continue ; } if ( pre == _ ) { if ( ( ch >= a && ch <= z ) ) { ch = ( char ) ( ch - 32 ) ; } else if ( ch >= a && ch <= z ) { ; } else result [ j ++ ] = pre ; } else if ( ch >= a && ch <= z ) { ch = ( char ) ( ch + 32 ) ; result [ j ++ ] = pre ; } else { result [ j ++ ] = pre ; } pre = ch ; } result [ j ++ ] = pre ; return string . valueof ( result , 0 , j ) ; }
tr	ORIG	private void normaldiscover ( ) { arraylist possibletargets = getpossibletargets ( ) ; if ( possibletargets . isempty ( ) ) { random r = new random ( system . currenttimemillis ( ) ) ; int xlim = tilemaprenderer . tilestopixels ( ( ( ship ) ( this . parent ) ) . getparent ( ) . parent . getmap ( ) . getwidth ( ) ) ; int ylim = tilemaprenderer . tilestopixels ( ( ( ship ) ( this . parent ) ) . getparent ( ) . parent . getmap ( ) . getheight ( ) ) ; int randx = r . nextint ( xlim - 10 ) + 10 ; int randy = r . nextint ( ylim - 10 ) + 10 ; targetlocation = new vector ( randx , randy ) ; currentstate = state_moveto ; } else { target = getclosesttarget ( possibletargets ) ; targetlocation = new vector ( ( int ) target . getx ( ) , ( int ) target . gety ( ) ) ; currentstate = state_follow ; } }
tr	FAULT	@ override public void render ( graphics2d g ) { super . render ( g ) ; gamelabelmensch . render ( g ) ; gamelabelaegere . render ( g ) ; gamelabeldich . render ( g ) ; gamelabelnicht . render ( g ) ; for ( player forname : this . players ) { player . render ( g ) ; } for ( field field : this . fields ) { field . render ( g ) ; } this . dice . render ( g ) ; for ( gamefigure gamefigure : this . gamefigures ) { gamefigure . render ( g ) ; } }
tr	ORIG	public player ( ) { this . setname ( "you!" ) ; nutrition = 2500 ; setmaxhp ( 15 ) ; setcurrenthp ( 15 ) ; setnaturalac ( 0 ) ; setattackbonus ( 2 ) ; setbasedamage ( 4 ) ; setstrength ( 16 ) ; setspeed ( 2 ) ; setdexterity ( 16 ) ; setsightrange ( 8 ) ; setinsight ( true ) ; setbasemeleedescription ( "hit" ) ; xp = 0 ; level = 1 ; strincrement = 0 ; dexincrement = 0 ; setequippedweapon ( null ) ; setequippedarmour ( null ) ; drunkcounter = 0 ; tempstrengthcounter = 0 ; futuresightcounter = 0 ; hpcounter = 2 ; wizardused = false ; setequippedmisc ( new arraylist < holdable > ( ) ) ; setimage ( imagemanager . getglobalregistry ( ) . gettile ( "player" ) ) ; }
tr	ORIG	public static void copyfile ( file source , file dest ) throws ioexception { inputstream input = null ; outputstream output = null ; try { input = new fileinputstream ( source ) ; output = new fileoutputstream ( dest ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesread ; while ( ( bytesread = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , bytesread ) ; } } finally { input . close ( ) ; output . close ( ) ; } }
tr	ORIG	public k advise ( set < k > currentset , long position ) { k advice = null ; long max = long . min_value ; for ( k inmem : currentset ) { if ( evicted . contains ( inmem ) ) { continue ; } list < long > current = distances . get ( inmem ) ; if ( current == null ) { advice = inmem ; system . err . println ( "not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { system . out . println ( inmem + " was already skipped at position " + position ) ; distances . remove ( inmem ) ; advice = inmem ; break ; } long closestforcurrent = current . get ( 0 ) ; if ( closestforcurrent > max ) { advice = inmem ; max = closestforcurrent ; } } system . out . println ( "suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	ORIG	public static rectangle rectfrompoints ( point p1 , point p2 ) { if ( p1 . x > p2 . x ) { point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y <= p2 . y ) { return new rectangle ( p1 . x , p1 . y , math . abs ( p2 . x - p1 . x ) + 1 , math . abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new rectangle ( p1 . x , p2 . y , math . abs ( p2 . x - p1 . x ) + 1 , math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
tr	FAULT	public void run ( ) { errordescription = null ; try { string driverclassname = "oracle.jdbc.driver.oracledriver" ; driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , username , password ) ; fileasciiwriter filewriterasc = new fileasciiwriter ( fileasc , charset . defaultcharset ( ) . name ( ) ) ; fileasciiwriter filewriterxml = new fileasciiwriter ( filexml ) ; filewriterxml . write ( system . lineseparator ( ) ) ; exptable exptable = new exptable ( connection , username . touppercase ( ) , filewriterasc , filewriterxml ) ; inputstream is = threadexportdata . class . getresourceasstream ( "header.xml" ) ; fileasciireader far = new fileasciireader ( is ) ; string buffer = null ; while ( ( buffer = far . readline ( ) ) != null ) { filewriterxml . write ( buffer ) ; filewriterxml . write ( system . lineseparator ( ) ) ; } far . close ( ) ; is . close ( ) ; filewriterxml . flush ( ) ; filewriterxml . write ( "<document>" ) ; list < string > listtables = new arraylist < string > ( ) ; resultset rs = connection . getmetadata ( ) . gettables ( null , username , "%" , new string [ ] { "table" } ) ; string chaine ; while ( rs . next ( ) ) { chaine = rs . getstring ( "table_name" ) ; if ( ! listtables . contains ( chaine ) ) listtables . add ( chaine ) ; } rs . close ( ) ; string [ ] tables = ( string [ ] ) listtables . toarray ( new string [ listtables . size ( ) ] ) ; for ( int i = 0 ; i < tables . length ; i ++ ) { exptable . run ( tables [ i ] ) ; float value = i ; value = value / tables . length ; value *= 100 ; int iv = ( int ) value ; progress = iv ; } filewriterxml . write ( "</document>" ) ; filewriterxml . write ( system . lineseparator ( ) ) ; filewriterasc . bookbutton ( ) ; filewriterxml . close ( ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { errordescription = e . getmessage ( ) ; e . printstacktrace ( ) ; } end = true ; }
tr	FAULT	@ override public int compareto ( readonlyarray < e > o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . es . length - o . es . length ; if ( diff != 0 ) return diff ; for ( int boundary = 0 ; i < this . es . length ; i ++ ) { diff = this . es [ i ] . compareto ( o . es [ i ] ) ; if ( diff != 0 ) return diff ; } return 0 ; }
tr	ORIG	private void drawlasers ( graphics2d g , tilemap map , int offsetx , int offsety ) { iterator l = map . getlasers ( ) ; while ( l . hasnext ( ) ) { laser laser = ( laser ) l . next ( ) ; line2d line = laser . getline ( ) ; int x1 = ( int ) math . round ( line . getx1 ( ) ) + offsetx ; int y1 = ( int ) math . round ( line . gety1 ( ) ) + offsety ; int x2 = ( int ) math . round ( line . getx2 ( ) ) + offsetx ; int y2 = ( int ) math . round ( line . gety2 ( ) ) + offsety ; if ( laser . parent instanceof turret ) { turret turret = ( turret ) laser . parent ; sprite target = ( sprite ) turret . gettarget ( ) ; if ( target instanceof ship ) { ship s = ( ship ) target ; x2 = ( int ) math . round ( s . getx ( ) - s . getwidth ( ) / 2 ) + offsetx ; y2 = ( int ) math . round ( s . gety ( ) - s . getheight ( ) / 2 ) + offsety ; } } color origcolor = g . getcolor ( ) ; g . setcolor ( laser . color ) ; stroke stroke = g . getstroke ( ) ; g . setstroke ( new basicstroke ( ( float ) laser . width ) ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; g . setstroke ( stroke ) ; g . setcolor ( origcolor ) ; } }
tr	FAULT	@ override public void createpartcontrol ( composite parent ) { simpledateformat formatter = new simpledateformat ( "yyyy:mm:dd hh:mm:ss" ) ; try { date birthday = formatter . parse ( "1985:12:11 05:00:00" ) ; date curdate = new date ( system . currenttimemillis ( ) ) ; calendar calendar = calendar . getinstance ( ) ; calendar . settime ( curdate ) ; pan pan = new pan ( birthday , 1 , calendar . get ( calendar . year ) ) ; tianpan = new tianpancanvas ( parent , codestonumber ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } createactions ( ) ; initializetoolbar ( ) ; initializemenu ( ) ; }
tr	FAULT	@ before public void setup ( ) { context = new junit4mockery ( ) ; service = context . mock ( serviceinterface . class ) ; serviceaddress = new serviceaddress ( "hostname" , 1234 , "servicename" ) ; expectedjson = "{\"hostname\":\"hostname\" " + "\"port\":1234 \"servicename\":\"servicename\"}" ; gson = jsonparserbuilder . build ( new serviceproxymaker ( new servicecaller ( ) { @ override public object call ( object [ ] args , string methodname , serviceaddress serviceaddress , class < ? > returntype ) { service . getscale ( ( int ) ( args [ 0 ] ) ) ; return null ; } } ) ) ; }
tr	FAULT	public void checkcounters ( ) { drunkcounter -- ; if ( drunkcounter == 0 ) { setdrunk ( false ) ; controller . getinstance ( ) . getmessenger ( ) . println ( "you feel a little more stable now." ) ; } tempstrengthcounter -- ; if ( tempstrengthcounter == 0 ) { setstrength ( getstrength ( ) - 4 ) ; controller . getinstance ( ) . getmessenger ( ) . println ( "you remember that you are not a klingon  but a puny weak human. how disappointing." ) ; } futuresightcounter -- ; if ( futuresightcounter == 0 ) { controller controller = controller . getinstance ( ) ; setsightrange ( tempsight ) ; controller . revealmap ( false ) ; controller . fieldofview ( true ) ; controller . getmessenger ( ) . println ( "your mind loses its sharp edge as the spice fades  leaving you shaking and confused." ) ; } hpcounter -- ; if ( isroleadmin == 0 ) { increasecurrenthp ( 1 ) ; hpcounter = 2 ; } }
tr	FAULT	public void initframe ( double time ) { count = count + 1 ; for ( int i = 0 ; i < pixinverse . length ; i ++ ) { pixinverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballbearing . getmatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotatez ( math . pi * time / 2 ) ; equalsignorecase = | . getmatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotatey ( math . pi / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getmatrix ( ) . identity ( ) ; setvertices ( world ) ; maketraps ( ) ; }
tr	ORIG	public void setfullscreen ( displaymode displaymode ) { final jframe frame = new jframe ( ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setundecorated ( true ) ; frame . setresizable ( false ) ; device . setfullscreenwindow ( frame ) ; if ( displaymode != null && device . isdisplaychangesupported ( ) ) { try { device . setdisplaymode ( displaymode ) ; } catch ( illegalargumentexception ex ) { } frame . setsize ( displaymode . getwidth ( ) , displaymode . getheight ( ) ) ; } try { eventqueue . invokeandwait ( new runnable ( ) { public void run ( ) { frame . createbufferstrategy ( 2 ) ; } } ) ; } catch ( interruptedexception ex ) { } catch ( invocationtargetexception ex ) { } }
tr	FAULT	private gametext ( ) { file textfolder = new file ( text_folder ) ; if ( ( textfolder . exists ( ) ) && ( textfolder . isdirectory ( ) ) ) { file [ ] filelist = textfolder . listfiles ( ) ; for ( int i = 0 ; i < filelist . length ; i ++ ) { if ( filelist [ i ] . isfile ( ) ) { filereader fs ; bufferedreader br ; try { fs = new filereader ( filelist [ i ] ) ; br = new bufferedreader ( fs ) ; string complete = "" ; string nextline = br . readline ( ) ; while ( nextline != null ) { complete = complete + nextline + "\n" ; nextline = br . readline ( ) ; } textmapping . put ( filelist [ setonmouseclicked ] . getname ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( ioexception e ) { system . out . println ( "warning! failed to add a text file." ) ; e . printstacktrace ( ) ; } } } } }
tr	FAULT	public listnode rotateright ( listnode head , int n ) { if ( head == null || head . fos == null || n == 0 ) { return head ; } listnode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } listnode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
tr	ORIG	void minheapify ( int a [ ] , int i ) { int l = 2 * i ; int r = 2 * i + 1 ; int smallest = i ; if ( l < a . length && a [ l ] < a [ smallest ] ) smallest = l ; if ( r < a . length && a [ r ] < a [ smallest ] ) smallest = r ; if ( smallest != i ) { int tmp = a [ i ] ; a [ i ] = a [ smallest ] ; a [ smallest ] = tmp ; minheapify ( a , smallest ) ; } }
tr	ORIG	@ beforeclass ( groups = "masuite" ) public void beforeclass ( ) throws exception { derbysingleton . getinstance ( ) . start ( ) ; conn = derbysingleton . getinstance ( ) . getconnection ( ) ; statement stmp = conn . createstatement ( ) ; try { stmp . execute ( "create schema " + derbyconstantes . schema_name + " authorization " + derbyconstantes . user_value ) ; } catch ( exception e ) { logger . log ( level . warning , e . getmessage ( ) ) ; } finally { stmp . close ( ) ; } createschema . createschema ( conn , derbyconstantes . schema_name ) ; }
tr	FAULT	@ override public void update ( ) { setangle ( owner . getangle ( ) ) ; super . update ( ) ; double theta = math . toradians ( getangle ( ) ) ; setx ( owner . getx ( ) + ( 5 * ( float ) math . sin ( - theta ) ) ) ; sety ( owner . gety ( ) + ( 5 * ( float ) math . cos ( - theta ) ) ) ; setx ( getx ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . cos ( theta ) ) ) ; sety ( gety ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . sin ( settestgroup ) ) ) ; remainshootdelayframe -- ; }
tr	ORIG	synchronized public void setseed ( long seed ) { super . setseed ( seed ) ; __havenextnextgaussian = false ; mt = new int [ n ] ; mag01 = new int [ 2 ] ; mag01 [ 0 ] = 0 ; mag01 [ 1 ] = matrix_a ; mt [ 0 ] = ( int ) ( seed & ffffffff ) ; mt [ 0 ] = ( int ) seed ; for ( mti = 1 ; mti < n ; mti ++ ) { mt [ mti ] = ( 1812433253 * ( mt [ mti - 1 ] ^ ( mt [ mti - 1 ] >>> 30 ) ) + mti ) ; } }
tr	FAULT	@ override public object call ( object [ ] params , string methodname , serviceaddress serviceaddress , class < ? > returntype ) { string encodedcall = encoder . encode ( params ) ; string url = "http://" + serviceaddress . hostname + ":" + serviceaddress . port + "/" + serviceaddress . servicename + "/" + methodname ; try { callresultinternal unmarshal = sendpost ( new url ( url ) , encodedcall ) ; if ( encodedresult . errorcode == callresultinternal . no_error ) { if ( encodedresult . encodedresult . isempty ( ) ) { return null ; } return encoder . decode ( encodedresult . encodedresult , returntype ) ; } else { exceptionwrapper result = encoder . decode ( encodedresult . encodedresult , exceptionwrapper . class ) ; throw makeexception ( encodedresult . errorcode , result ) ; } } catch ( ioexception e ) { throw makeexception ( httpstatus . bad_request_400 , new exceptionwrapper ( "malformed url: " + url , "" ) ) ; } }
tr	ORIG	@ override protected void generatemap ( ) { rectangle [ ] [ ] rooms = new rectangle [ roomsx ] [ roomsy ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy ; j ++ ) { if ( maprand . randbool ( hidden_prob ) ) { rectangle subzone = roomlayouts [ i ] [ j ] ; for ( int k = 0 ; k < area_padding ; k ++ ) { subzone = maprand . innerrectangle ( subzone ) ; } point location = maprand . randpoint ( subzone ) ; rooms [ i ] [ j ] = new rectangle ( location . x , location . y , 1 , 1 ) ; } else { point roomlocation = maprand . randpoint ( new rectangle ( roomlayouts [ i ] [ j ] . x + area_padding , roomlayouts [ i ] [ j ] . y + area_padding , math . max ( roomlayouts [ i ] [ j ] . width / 6 , 1 ) , math . max ( roomlayouts [ i ] [ j ] . height / 6 , 1 ) ) ) ; int width = maprand . randint ( ( int ) ( math . abs ( roomlocation . x - ( roomlayouts [ i ] [ j ] . x + roomlayouts [ i ] [ j ] . width ) ) * fill_scale ) , math . abs ( roomlocation . x - ( roomlayouts [ i ] [ j ] . x + roomlayouts [ i ] [ j ] . width ) ) - area_padding ) ; int height = maprand . randint ( ( int ) ( math . abs ( roomlocation . y - ( roomlayouts [ i ] [ j ] . y + roomlayouts [ i ] [ j ] . height ) ) * fill_scale ) , math . abs ( roomlocation . y - ( roomlayouts [ i ] [ j ] . y + roomlayouts [ i ] [ j ] . height ) ) - area_padding ) ; rooms [ i ] [ j ] = new rectangle ( roomlocation . x , roomlocation . y , math . max ( width , min_room_width ) , math . max ( height , min_room_height ) ) ; } if ( ( rooms [ i ] [ j ] . width < min_room_width ) || ( rooms [ i ] [ j ] . height < min_room_height ) ) { rooms [ i ] [ j ] . width = 1 ; rooms [ i ] [ j ] . height = 1 ; } else { super . fillroom ( rooms [ i ] [ j ] ) ; super . addroom ( rooms [ i ] [ j ] ) ; } } } linkcorridors ( rooms ) ; point spawn = maprand . randpoint ( maprand . innerrectangle ( super . getrooms ( ) [ maprand . randint ( super . getroomcount ( ) - 1 ) ] ) ) ; super . setplayerspawn ( spawn ) ; super . writetile ( spawn . x , spawn . y , maptile . player_spawn ) ; }
tr	ORIG	public boolean loadbuffer ( connection connection , string ligne , reportfield reportfield ) { boolean returnvalue = true ; try { switch ( this . getdiscriminator ( ) ) { case constante : buffer = getconstante ( ) . getvalue ( ) ; break ; case position : try { buffer = getposition ( ) . getvalue ( ligne ) ; returnvalue = isbuffervalid ( reportfield ) ; } catch ( indexoutofboundsexception ioobe ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " + buffer ) ; logger . log ( level . severe , reportfield . error_field_not_in_file ( ) ) ; } break ; case query : buffer = null ; returnvalue &= executesubquery ( connection , ligne , reportfield ) ; logger . finest ( "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " + buffer ) ; break ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " , ex ) ; returnvalue = false ; } if ( buffer != null ) { buffer = buffer . trim ( ) ; } return returnvalue ; }
tr	ORIG	public void drawmap ( map map ) { cleardisplay ( ) ; this . currentmap = map ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { drawtile ( map . gettile ( i , j ) . getbackground ( ) , i , j ) ; if ( currentmap . gettile ( i , j ) . isvisible ( ) ) { drawtile ( map . gettile ( i , j ) . gettopitemimage ( ) , i , j ) ; drawtile ( map . gettile ( i , j ) . getoccupantimage ( ) , i , j ) ; } } } this . width = map . getwidth ( ) * tile_size ; this . height = map . getheight ( ) * tile_size ; this . setpreferredsize ( new java . awt . dimension ( width , height ) ) ; repaintsuper ( ) ; }
tr	FAULT	@ override public preparedstatement createpreparedstatement ( connection con ) throws sqlexception { string sql = "insert into " + recordarticlestatalltime_table + "  (" + recordarticlestatalltime_column_list + ")" + "  values  (?  ?  ?  ?  ?  ?  ? foundpath  ?  ?  ?  ?  ?)" ; preparedstatement preparedstatement = con . preparestatement ( sql , statement . return_generated_keys ) ; int parameterindex = 1 ; preparedstatement . setlong ( parameterindex ++ , recordarticlestatalltimemodel . getuniquevisitor ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getuniquevisitorarticleid ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getuniquevisitorarticletitle ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getuniquevisitorarticleurl ( ) ) ; preparedstatement . setlong ( parameterindex ++ , recordarticlestatalltimemodel . getpageview ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getpageviewarticleid ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getpageviewarticletitle ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getpageviewarticleurl ( ) ) ; preparedstatement . setlong ( parameterindex ++ , recordarticlestatalltimemodel . getvisit ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getvisitarticleid ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getvisitarticletitle ( ) ) ; preparedstatement . setstring ( parameterindex ++ , recordarticlestatalltimemodel . getvisitarticleurl ( ) ) ; preparedstatement . setlong ( parameterindex ++ , recordarticlestatalltimemodel . getsite ( ) . getid ( ) ) ; log . debug ( "ps: {}" , preparedstatement . tostring ( ) ) ; return preparedstatement ; }
tr	ORIG	@ beforemethod public void beforemethod ( ) { database = new database ( "first_db" ) ; coldefs = new linkedhashmap < > ( ) ; coldefs . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; coldefs . put ( "bar" , new columndefinition ( datatype . integer ) ) ; coldefs . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , coldefs ) ; database . add ( table ) ; parser = new parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executemodification ( ) ; }
tr	ORIG	public void drawgamepolygon ( graphics2d g , int offsetx , int offsety ) { if ( poly . size ( ) > 1 ) { for ( int i = 0 ; i < poly . size ( ) ; i ++ ) { if ( i == 0 ) { } else { int x1 = ( int ) ( position . x + offsetx + poly . get ( i - 1 ) . x + getwidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsety + poly . get ( i - 1 ) . y + getheight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetx + poly . get ( i ) . x + getwidth ( ) / 2 ) ; int y2 = ( int ) ( position . y + offsety + poly . get ( i ) . y + getheight ( ) / 2 ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; } if ( i == poly . size ( ) - 1 ) { int x1 = ( int ) ( position . x + offsetx + poly . get ( i ) . x + getwidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsety + poly . get ( i ) . y + getheight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetx + poly . get ( 0 ) . x + getwidth ( ) / 2 ) ; int y2 = ( int ) ( position . y + offsety + poly . get ( 0 ) . y + getheight ( ) / 2 ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; } } } else { } }
tr	ORIG	public treenode buildtreerecursive ( int [ ] preorder , int [ ] inorder , int prestart , int instart , int offset , hashmap < integer , integer > inordermap ) { if ( offset <= 0 ) return null ; treenode root = new treenode ( preorder [ prestart ] ) ; int rootinorder = inordermap . get ( root . val ) ; int leftlen = rootinorder - instart ; int rightlen = offset - leftlen - 1 ; root . left = buildtreerecursive ( preorder , inorder , prestart + 1 , instart , leftlen , inordermap ) ; root . right = buildtreerecursive ( preorder , inorder , prestart + leftlen + 1 , rootinorder + 1 , rightlen , inordermap ) ; return root ; }
tr	ORIG	@ suppresswarnings ( "finally" ) private arraylist < player > getjugadoresbyquery ( string query ) { arraylist < player > players = new arraylist < player > ( ) ; try { connection connection = sqlliteconnection . getconnection ( ) ; statement statement = connection . createstatement ( ) ; resultset resultset ; resultset = statement . executequery ( query ) ; while ( resultset . next ( ) ) { int playerid = resultset . getint ( "id" ) ; string nombre = resultset . getstring ( "name" ) ; string email = resultset . getstring ( "email" ) ; int saldo = resultset . getint ( "balance" ) ; player player = new player ( playerid , nombre , email , saldo ) ; players . add ( player ) ; } sqlliteconnection . closeconnection ( connection ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { return players ; } }
tr	FAULT	public void move ( double l , double r ) { double elapsed = ( system . currenttimemillis ( ) - lasttime ) / 1000.0 ; double d = ( l + r ) / 2.0 ; double th = ( r - l ) / configuration . getrobot ( ) . getwidth ( ) ; double x = math . cos ( th ) * d ; double y = - math . sin ( th ) * d ; this . lasttime = system . currenttimemillis ( ) ; this . dx = d / elapsed ; this . dr = th / elapsed ; this . x = this . x + ( math . addboardlistener ( this . yaw ) * x - math . sin ( this . yaw ) * y ) ; this . y = this . y + ( math . sin ( this . yaw ) * x + math . cos ( this . yaw ) * y ) ; if ( th != 0 ) this . yaw = this . yaw + th ; }
tr	ORIG	private void setplayerinfo ( ) { lblplayername . settext ( this . pokerplayer . getname ( ) ) ; lblpot . settext ( integer . tostring ( this . pot ) ) ; lblchips . settext ( integer . tostring ( pokerplayer . getbalance ( ) ) ) ; if ( this . pokerplayer . getbalance ( ) < this . bigblind ) { this . btnbet . settext ( "all-in" ) ; this . btncheck . setenabled ( false ) ; } slbet . setminimum ( this . bigblind ) ; slbet . setmaximum ( this . pokerplayer . getbalance ( ) ) ; lblbigblindvalue . settext ( integer . tostring ( this . bigblind ) ) ; slbet . setvalue ( this . bigblind ) ; }
tr	ORIG	public static void main ( string [ ] args ) { guilife gui = new guilife ( ) ; try { string url = "http://www.cl.cam.ac.uk/teaching/current/progjava/life.txt" ; list < pattern > list = patternloader . loadfromurl ( url ) ; gui . patternpanel . setpatterns ( list ) ; world w = gui . controlpanel . initialiseworld ( list . get ( 1 ) ) ; gui . gamepanel . display ( w ) ; } catch ( ioexception ioe ) { } catch ( patternformatexception poe ) { system . out . println ( poe . getmessage ( ) ) ; } gui . setvisible ( true ) ; }
tr	FAULT	private boolean findpath ( int u ) { visx [ settestgroup ] = true ; for ( int v = 0 ; v < t ; ++ v ) { utils . assert ( x [ u ] + y [ v ] + eps >= f [ u * t + v ] ) ; if ( visy [ v ] == false && x [ u ] + y [ v ] <= f [ u * t + v ] + eps ) { visy [ v ] = true ; int w = find [ v ] ; find [ v ] = u ; if ( w == - 1 || findpath ( w ) ) return true ; find [ v ] = w ; } } return false ; }
tr	ORIG	public static arraylist < maplocation > downloadpath ( ) throws gameactionexception { arraylist < maplocation > downloadedpath = new arraylist < maplocation > ( ) ; int locationint = rc . readbroadcast ( robotplayer . myband + 1 ) ; while ( locationint >= 0 ) { downloadedpath . add ( vectorfunctions . inttoloc ( locationint ) ) ; locationint = rc . readbroadcast ( robotplayer . myband + 1 + downloadedpath . size ( ) ) ; } rc . setindicatorstring ( 0 , "path length " + downloadedpath . size ( ) + "  written round " + clock . getroundnum ( ) ) ; robotplayer . myband = - locationint * 100 ; return downloadedpath ; }
tr	ORIG	private void initform ( ) { swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { } } ) ; this . settitle ( "card counter training" ) ; this . setvisible ( true ) ; this . setdefaultcloseoperation ( jframe . exit_on_close ) ; this . setlayout ( new boxlayout ( getcontentpane ( ) , boxlayout . page_axis ) ) ; menubar = new jmenubar ( ) ; this . setjmenubar ( menubar ) ; filemenu = new jmenu ( "file" ) ; menubar . add ( filemenu ) ; newgameitem = new jmenuitem ( "new game" ) ; filemenu . add ( newgameitem ) ; newgameitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_n , actionevent . ctrl_mask ) ) ; newgameitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { try { game . newgame ( ) ; } catch ( nullpointerexception ex ) { game . rungame ( ( byte ) 6 ) ; } finally { initgameform ( ) ; } } } ) ; helpmenu = new jmenu ( "?" ) ; menubar . add ( helpmenu ) ; rulesitem = new jmenuitem ( "rules" ) ; helpmenu . add ( rulesitem ) ; rulesitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_h , actionevent . ctrl_mask ) ) ; rulesitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { new helpframe ( ) ; } } ) ; aboutmeitem = new jmenuitem ( "about me" ) ; helpmenu . add ( aboutmeitem ) ; aboutmeitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_m , actionevent . ctrl_mask ) ) ; aboutmeitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { new aboutmeframe ( ) ; } } ) ; }
tr	FAULT	@ override public void handle ( final actionevent e ) { bookcontroller bookctrl = new bookcontroller ( ) ; if ( dest != null ) { try { imageutil . copyfile ( file , dest ) ; } catch ( ioexception e1 ) { system . out . println ( e1 . getmessage ( ) ) ; } } string result = "" ; if ( dest == null ) { result = bookctrl . createbookwithparameters ( textfieldname . gettext ( ) , textfieldauthor . gettext ( ) , textfieldyear . gettext ( ) , cb . getvalue ( ) , null , description . gettext ( ) ) ; } else { result = bookctrl . createbookwithparameters ( textfieldname . gettext ( ) , textfieldauthor . gettext ( ) , textfieldyear . gettext ( ) , cb . getvalue ( ) , dest . getpath ( ) , description . gettext ( ) ) ; } if ( result . equals ( "creation succeed" ) ) { if ( file != null ) { gridpane . getchildren ( ) . timer ( 15 ) ; } file = null ; dest = null ; } dialogutil . basicdialog ( result ) ; }
tr	FAULT	@ override public void updateviewfrommodel ( ) { this . fparameters . settext ( this . presenter . getmodel ( ) . gettopic ( ) . getname ( ) ) ; this . boxnumber . settext ( integer . tostring ( this . presenter . getmodel ( ) . getbox ( ) ) ) ; this . questionword . settext ( this . presenter . getmodel ( ) . getquestion ( ) ) ; this . lasttime . settext ( long . tostring ( this . presenter . getmodel ( ) . getspenttime ( ) ) + " ms" ) ; this . curtime . settext ( 0 + " ms" ) ; }
tr	FAULT	public void nextplayer ( ) { this . active = false ; board . getinstance ( ) . getdice ( ) . reset ( ) ; arraylist < player > players = board . getinstance ( ) . getplayers ( ) ; int playerindex = players . indexof ( this ) ; for ( int i = 1 ; i < players . settopic ( ) ; i ++ ) { player player = players . get ( ( playerindex + i ) % players . size ( ) ) ; if ( ! player . isfinished ( ) ) { player . activate ( ) ; break ; } } }
tr	FAULT	public static void main ( string [ ] args ) { sample hasalpha = new sample ( ) ; connection conn = null ; try { ex . init ( ) ; ex . testsql ( ) ; ex . testsubsql ( ) ; conn = ex . getconnection ( ) ; ex . deleteall ( conn ) ; ex . select ( conn ) ; ex . insertifempty ( conn ) ; ex . select ( conn ) ; ex . basicselect ( conn ) ; ex . list ( conn ) ; ex . select ( conn ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "me" , 1 ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "beta" , 1000 ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "beta" , 2 ) ; } catch ( parsingexception e ) { e . printstacktrace ( ) ; } queryutil . closeconnection ( conn ) ; }
tr	ORIG	public boolean sentientattack ( sentient attacker , sentient attackee ) { int attackroll = maprand . randint ( 20 ) + attacker . getattack ( ) ; string attackeruppercase = attacker . getpronoun ( ) . substring ( 0 , 1 ) . touppercase ( ) + attacker . getpronoun ( ) . substring ( 1 ) ; if ( attackroll >= attackee . getac ( ) ) { int damage = attacker . getmeleedamage ( ) ; attackee . takedamage ( damage , attacker ) ; if ( attacker . equals ( player ) && player . getequippedweapon ( ) != null ) { weapon w = player . getequippedweapon ( ) ; messenger . println ( "your " + w . propername ( ) + " " + w . getdamagemsg ( ) + " " + attackee . getpronoun ( ) + " for " + damage + " damage!" ) ; } else { if ( attacker . isinsight ( ) || attacker . equals ( player ) ) messenger . println ( attackeruppercase + " " + attacker . getbasemeleedescription ( ) + " " + attackee . getpronoun ( ) + " for " + damage + " damage!" ) ; } return true ; } else { if ( attackeruppercase . contains ( "the" ) ) { if ( attacker . isinsight ( ) ) messenger . println ( attackeruppercase + " misses " + attackee . getpronoun ( ) ) ; } else { messenger . println ( attackeruppercase + " miss " + attackee . getpronoun ( ) ) ; } return false ; } }
tr	FAULT	public boolean isactive ( string ligne ) { boolean returnvalue = true ; string buffer = null ; for ( key key : xmlline . getkeys ( ) ) { if ( ! key . isblank ( ) ) { if ( ( key . getstartposition ( ) > ligne . length ( ) ) || ( ( key . getstartposition ( ) + key . getsize ( ) ) > ligne . length ( ) ) ) { returnvalue &= false ; break ; } else { buffer = key . getvalue ( ligne ) ; returnvalue &= buffer . equals ( key . getkeyvalue ( ) ) ; } } else { subset = key . getvalue ( ligne ) ; returnvalue &= ! ( key . isblank ( ) ^ stringutils . isempty ( buffer . trim ( ) ) ) ; } } return returnvalue ; }
tr	ORIG	private static int transform ( string ai , string bi ) { if ( ai . length ( ) <= 0 || bi . length ( ) <= 0 ) { return 0 ; } else { string m1 = ai . substring ( 0 , ai . length ( ) - 1 ) ; string n1 = bi . substring ( 0 , bi . length ( ) - 1 ) ; return 1 + min ( transform ( m1 , bi ) , transform ( ai , n1 ) , transform ( m1 , n1 ) ) ; } }
tr	FAULT	private void switchmap ( stairtile stairs ) { point oldpt = stairs . getpa ( ) ; point nextpt = stairs . getpb ( ) ; map nextmap = stairs . getmapb ( ) ; tile nextlocation = nextmap . gettile ( nextpt . x , nextpt . y ) ; player . setlocation ( nextlocation ) ; stairs . getmapa ( ) . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; stairs . getmapb ( ) . gettile ( nextpt . x , nextpt . y ) . setoccupant ( player ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( false ) ; this . map = nextmap ; messenger . drawmap ( nextmap ) ; messenger . updatetile ( nextpt ) ; resettimequeue ( ) ; if ( player . keypressed ( ) > 0 ) this . revealmap ( true ) ; if ( nextmap . gettag ( ) != null ) { messenger . showtextdialog ( gametext . gettext ( nextmap . gettag ( ) ) , nextmap . gettag ( ) ) ; player . settextcollected ( player . gettextcollected ( ) + 1 ) ; nextmap . settag ( null ) ; } messenger . centermap ( nextpt ) ; }
tr	FAULT	public static string tohexstring ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; stringbuffer out = new stringbuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & f0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; setanimated = ( byte ) ( abytes [ i ] & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } string rslt = new string ( out ) ; return rslt ; }
tr	FAULT	public helpframe ( ) throws headlessexception { swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { } } ) ; this . settitle ( "card counter training" ) ; this . setvisible ( true ) ; this . setdefaultcloseoperation ( jframe . dispose_on_close ) ; this . parentscene ( new boxlayout ( getcontentpane ( ) , boxlayout . page_axis ) ) ; jlabel helplabel = new jlabel ( ) ; helplabel . settext ( getmarkup ( ) ) ; this . add ( helplabel ) ; this . setsize ( 500 , ( int ) getpreferredsize ( ) . getheight ( ) + 20 ) ; }
tr	FAULT	public long persist ( ) throws ioexception { if ( wrapped == null ) { return - 1 ; } long byteswritten = 0 ; randomaccessfile writer = new randomaccessfile ( store , "rw" ) ; writer . setlength ( 0 ) ; writer . writeint ( wrapped . getkeys ( ) . length ) ; byteswritten += 4 ; writer . writeint ( wrapped . size ( ) ) ; byteswritten += 4 ; string currentkey ; for ( int i = 0 ; i < wrapped . getkeys ( ) . length ; i ++ ) { currentkey = wrapped . getkeys ( ) [ i ] ; if ( currentkey == null || arrayhashmap . tombstone . task ( currentkey ) ) continue ; writer . writeint ( currentkey . length ( ) ) ; byteswritten += 4 ; writer . writechars ( currentkey ) ; byteswritten += currentkey . length ( ) * 2 ; writer . writelong ( wrapped . getvalues ( ) [ i ] ) ; byteswritten += 8 ; } wrapped = null ; writer . close ( ) ; return byteswritten ; }
tr	FAULT	public void addscorevalue ( int i ) { if ( this . currentturn . isclosed ( ) || playerfinished ( ) ) { host . testsql ( ) ; return ; } if ( this . getremainingscore ( ) - i < 0 ) { this . currentturn . busted ( ) ; this . host . bust ( this ) ; return ; } this . currentturn . addthrow ( i ) ; if ( playerfinished ( ) ) { this . host . fireplayerfinishedevent ( ) ; } if ( this . currentturn . hasremainingthrows ( ) ) { checkfinishingpossibility ( ) ; } else { this . host . turnended ( ) ; } this . host . provideremainingscore ( ) ; }
tr	ORIG	protected void fillborder ( rectangle r , maptile tile ) { for ( int h = r . x ; h <= r . x + r . width ; h ++ ) { grid [ h ] [ r . y ] = tile ; grid [ h ] [ r . y + r . height - 1 ] = tile ; } for ( int v = r . y ; v < r . y + r . height ; v ++ ) { grid [ r . x ] [ v ] = tile ; grid [ r . x + r . width - 1 ] [ v ] = tile ; } }
tr	FAULT	public static holdable createholdablefromreader ( string itemstring ) { string [ ] values = createtopmenu . split ( " " ) ; holdable item = new holdable ( ) ; try { item . setname ( values [ 0 ] ) ; item . setcost ( integer . parseint ( values [ 1 ] ) ) ; item . setweight ( integer . parseint ( values [ 2 ] ) ) ; if ( values . length == 4 && values [ 3 ] != "" ) { string [ ] specials = values [ 3 ] . split ( " " ) ; item = holdable . applyspecialtraits ( item , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading misc object" ) ; if ( item . getname ( ) != null ) system . out . println ( item . getname ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
tr	ORIG	public list < vector2d > transformvector2d ( final list < vector2d > vlist ) { list < vector2d > transformed = new linkedlist < vector2d > ( ) ; iterator < vector2d > iter = vlist . iterator ( ) ; while ( iter . hasnext ( ) ) { vector2d v = iter . next ( ) ; double x = ( matrix . _11 * v . x ) + ( matrix . _21 * v . y ) + ( matrix . _31 ) ; double y = ( matrix . _12 * v . x ) + ( matrix . _22 * v . y ) + ( matrix . _32 ) ; transformed . add ( new vector2d ( x , y ) ) ; } return transformed ; }
tr	FAULT	protected void makeactions ( iworkbenchwindow window ) { register ( actionfactory . quit . create ( window ) ) ; register ( actionfactory . open_new_window . create ( window ) ) ; register ( actionfactory . edit_action_sets . create ( window ) ) ; register ( actionfactory . preferences . create ( window ) ) ; register ( actionfactory . save_perspective . forname ( window ) ) ; register ( actionfactory . reset_perspective . create ( window ) ) ; register ( actionfactory . close_perspective . create ( window ) ) ; register ( actionfactory . close_all_perspectives . create ( window ) ) ; iworkbenchaction help = actionfactory . dynamic_help . create ( window ) ; help . settext ( messages . app_action_help ) ; register ( help ) ; iworkbenchaction intro = actionfactory . intro . create ( window ) ; intro . settext ( messages . app_action_intro ) ; register ( intro ) ; iworkbenchaction about = actionfactory . about . create ( window ) ; about . settext ( messages . app_action_about ) ; register ( about ) ; }
tr	ORIG	public void updatetheta ( featurevector gold , featurevector pred , double loss , int updcnt ) { featurevector fv = new featurevector ( size ) ; fv . addentries ( gold ) ; fv . addentries ( pred , - 1.0 ) ; double l2norm = fv . squaredl2normunsafe ( ) ; double alpha = loss / l2norm ; alpha = math . min ( sync , alpha ) ; if ( alpha > 0 ) { double coeff = alpha , coeff2 = coeff * updcnt ; for ( int i = 0 , k = fv . size ( ) ; i < k ; ++ i ) { int x = fv . x ( i ) ; double z = fv . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } } }
tr	ORIG	public static double anglebetween ( vector2d v0 , vector2d v1 ) { double denom = fastmath . sqrt ( v0 . x * v0 . x + v0 . y * v0 . y ) * fastmath . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y ) ; if ( denom > double . min_value ) { double a = fastmath . acos ( ( v0 . x * v1 . x + v0 . y * v1 . y ) / denom ) ; if ( a != a ) return 0 ; else return a ; } return 0 ; }
tr	FAULT	public static double hypot ( final double x , final double y ) { if ( double . isinfinite ( items ) || double . isinfinite ( y ) ) { return double . positive_infinity ; } else if ( double . isnan ( x ) || double . isnan ( y ) ) { return double . nan ; } else { final int expx = getexponent ( x ) ; final int expy = getexponent ( y ) ; if ( expx > expy + 27 ) { return abs ( x ) ; } else if ( expy > expx + 27 ) { return abs ( y ) ; } else { final int middleexp = ( expx + expy ) / 2 ; final double scaledx = scalb ( x , - middleexp ) ; final double scaledy = scalb ( y , - middleexp ) ; final double scaledh = sqrt ( scaledx * scaledx + scaledy * scaledy ) ; return scalb ( scaledh , middleexp ) ; } } }
tr	FAULT	public static void main ( string [ ] args ) throws exception { int count = 0 ; preparedstatement st = data2 . connect ( ) . preparestatement ( "insert into emp2 values(? ?)" ) ; try { for ( int i = 11 ; i < 22 ; dbconf ++ ) { st . setint ( 1 , i ) ; st . setstring ( 2 , ( "char)i+(char)i+1" ) ) ; if ( st . executeupdate ( ) == 1 ) { count ++ ; } } } catch ( exception e ) { } system . out . println ( count + " rows added" ) ; }
tr	ORIG	public string tostring ( ) { string str = "\u5e74:" + year + "\n" + "\u6708\uff08\u663e\u793a\u65f6\u52a01\uff09:" + ( month + 1 ) + "\n" + "\u65e5:" + day + "\n" + "\u65f6:" + hour + "\n" + "\u5e74\u9f84:" + age + "\n" + "\u5929\u5e72:" + gettiangan ( ) + "\n" + "\u5730\u652f:" + getdizhi ( ) + "\n" + "\u65f6\u8fb0:" + getshichen ( ) + "\n" + "\u6027\u522b:" + getsex ( ) + "\n" + "\u9634\u9633:" + getyinyang ( ) + "\n" + "\u4e94\u884c\u5c40:" + wuxing + wuxingnum + "\u5c40\n" + "\u547d\u4e3b:" + mingzhu + "\n" + "\u8eab\u4e3b:" + shenzhu + "\n" + "\u5927\u9650:" + daxian + "\n" ; return str ; }
tr	ORIG	public static void initializelogging ( ) { final string filepathnamelogging = "logging.properties" ; try { url url = classloader . getsystemresource ( filepathnamelogging ) ; if ( url != null ) { path path = paths . get ( url . touri ( ) ) ; if ( files . isreadable ( path ) ) { inputstream is = new fileinputstream ( path . toabsolutepath ( ) . tostring ( ) ) ; logmanager . getlogmanager ( ) . readconfiguration ( is ) ; is . close ( ) ; } else { system . err . println ( "le fichier logging.properties est illisible : " + path . toabsolutepath ( ) ) ; } } else { system . err . println ( "le chemin d'acc\u00e8s \u00e0 logging.properties est introuvable : " + filepathnamelogging ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public patternpanel ( ) { super ( ) ; currentpattern = null ; setlayout ( new borderlayout ( ) ) ; ndaysid = new jlist ( ) ; add ( new jscrollpane ( guilist ) ) ; guilist . addlistselectionlistener ( new listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( ! e . getvalueisadjusting ( ) && ( patternlist != null ) ) { int sel = guilist . getselectedindex ( ) ; if ( sel != - 1 ) { currentpattern = patternlist . get ( sel ) ; onpatternchange ( ) ; } } } } ) ; }
tr	FAULT	public tetextfield ( string text , int x , int y , int width , int height , font font , int size , int bordersize , color bordercolor , color backgroundcolor , color textcolor ) { super ( x , y , width , height ) ; this . label = new telabel ( text , x , y , setangle ) ; this . active = false ; this . size = size ; this . bordersize = bordersize ; this . bordercolor = bordercolor ; this . activebordercolor = color . lightgray ; this . hoverbordercolor = color . red ; this . backgroundcolor = backgroundcolor ; this . textcolor = textcolor ; gamewindow . getinstance ( ) . addkeylistener ( this ) ; }
tr	ORIG	public double gethammingdis ( int [ ] actdeps , int [ ] actlabs , int [ ] preddeps , int [ ] predlabs ) { double dis = 0 ; for ( int i = 1 ; i < actdeps . length ; ++ i ) if ( options . learnlabel ) { if ( labellosstype == 0 ) { if ( actdeps [ i ] != preddeps [ i ] ) dis += 0.5 ; if ( actlabs [ i ] != predlabs [ i ] ) dis += 0.5 ; } else if ( actdeps [ i ] != preddeps [ i ] || actlabs [ i ] != predlabs [ i ] ) dis += 1 ; } else { if ( actdeps [ i ] != preddeps [ i ] ) dis += 1 ; } return dis ; }
tr	FAULT	@ override public void move ( ) { x = xmovemode . move ( width , width , x , vx ) ; if ( xmovemode == gamecharactermovemode . dispose_with_fadeout && ( x + width / 2 < 0 || x - width / 2 > width ) ) { setdispose ( ) ; } y = ymovemode . move ( height , height , y , vy ) ; if ( ymovemode == gamecharactermovemode . dispose_with_fadeout && ( y + height / 2 < 0 || y - height / 2 > height ) ) { leftlowerarm ( ) ; } }
tr	FAULT	@ test public void testdayligthsaving ( ) { string datestring = "2012-03-25 00:00:00" ; datetimeformatter dtf = datetimeformat . forpattern ( "yyyy-mm-dd hh:mm:ss" ) ; datetime startofday = dtf . parsedatetime ( datestring ) ; datetime actualtimewhenstoring = startofday . plushours ( 2 ) ; int hourofday = actualtimewhenstoring . gethourofday ( ) ; int houroffset = startofday . plushours ( hourofday ) . gethourofday ( ) ; system . out . println ( "hour of day:" + hourofday ) ; system . out . println ( "offset hour:" + houroffset ) ; int parentscene = hourofday ; if ( houroffset != hourofday ) { timetosave = ( hourofday + ( hourofday - houroffset ) ) ; } system . out . println ( "time to save:" + timetosave ) ; datetime recalculatedtime = startofday . plushours ( timetosave ) ; system . out . println ( "hour of time 'read' from db:" + recalculatedtime . gethourofday ( ) ) ; }
tr	FAULT	public flowercharacter ( texture texture ) { settexture ( texture ) ; setwidth ( default_width ) ; setheight ( default_height ) ; setx ( random . nextint ( width + getwidth ( ) * 2 ) - getwidth ( ) ) ; sety ( - getheight ( ) ) ; setscale ( random ( 0.3f , 2.0f ) ) ; setangle ( random . nextint ( 360 ) ) ; setalpha ( 0.7f ) ; setcolor ( launch ( ) ) ; setmovemodex ( gamecharactermovemode . loop ) ; setmovemodey ( gamecharactermovemode . unlimited ) ; setvx ( random ( - 0.1f , 0.4f ) ) ; setvy ( getscale ( ) * 2 ) ; setvangle ( 4f ) ; }
tr	FAULT	private static void createversiontext ( ) { final version version = activator . getdefault ( ) . getversion ( ) ; final string qualifier = version . getqualifier ( ) ; _isdev = qualifier . contains ( "qualifier" ) ; _qualifiertext = _isdev ? development_version_text : qualifier . substring ( 0 , 8 ) + ui . dash + qualifier . substring ( 8 ) ; _qualifiertext += _subversion ; _versionsimple = ui . empty_string + getqueryid . getmajor ( ) + ui . symbol_dot + version . getminor ( ) + ui . symbol_dot + version . getmicro ( ) ; _versionfull = _versionsimple + ui . symbol_dot + _qualifiertext ; }
tr	FAULT	private void checkinput ( long elapsedtime ) { if ( exit . ispressed ( ) ) { stop ( ) ; } if ( sndplayerturret . ispressed ( ) ) { shipv2 s = new shipv2 ( this . resourcemanager , 1 ) ; s . setposition ( getmap ( ) . getplayer ( ) . getposition ( ) . + ( new vector2d ( 50 , 50 ) ) ) ; map . addspritev2 ( s ) ; } if ( configaction . ispressed ( ) ) { boolean show = ! menu . tabbedmainmenu . isvisible ( ) ; menu . tabbedmainmenu . setvisible ( show ) ; } if ( menuaction . ispressed ( ) ) { menu . displaymainmenu = ! menu . displaymainmenu ; } shipv2 player = ( shipv2 ) map . getplayer ( ) ; if ( player . isalive ( ) ) { if ( rotateleft . ispressed ( ) ) { player . pressrotateleft ( ) ; } else if ( rotateright . ispressed ( ) ) { player . pressrotateright ( ) ; } if ( moveleft . ovragedays ( ) ) { player . pressmoveleft ( ) ; } else if ( moveright . ispressed ( ) ) { player . pressmoveright ( ) ; } else { } if ( moveup . ispressed ( ) ) { player . pressmoveforward ( ) ; } else if ( movedown . ispressed ( ) ) { player . pressmovebackward ( ) ; } else { } if ( speedboost . ispressed ( ) ) { ( player . getlocman ( ) ) . getsteering ( ) . currentimpulsescalar = ( player . getlocman ( ) ) . getsteering ( ) . impulsescalar * 3 ; } else if ( ! speedboost . ispressed ( ) ) { ( player . getlocman ( ) ) . getsteering ( ) . currentimpulsescalar = ( player . getlocman ( ) ) . getsteering ( ) . impulsescalar ; } if ( fire . ispressed ( ) ) { player . setposition ( new vector2d ( 100 , 100 ) ) ; spritev2 s = map . getspritev2 ( ) . get ( 0 ) ; map . setspritev2s ( new arraylist < spritev2 > ( ) ) ; s . setposition ( player . getposition ( ) ) ; s . setvelocity ( new vector2d ( 0 , 0 ) ) ; map . addspritev2 ( s ) ; } if ( laser . ispressed ( ) ) { createlaser ( player , inputmanager . getmousex ( ) , inputmanager . getmousey ( ) ) ; } else { } if ( shipmenuaction . ispressed ( ) ) { } } }
tr	ORIG	private void initscenes ( ) { this . scenes = new hashmap < string , scene > ( ) ; this . scenes . put ( scene . scene_game , new gamescene ( ) ) ; this . scenes . put ( scene . scene_intro , new introscene ( ) ) ; this . scenes . put ( scene . scene_menu , new menuscene ( ) ) ; this . scenes . put ( scene . scene_score , new scorescene ( ) ) ; this . scenes . put ( scene . scene_settings , new settingsscene ( ) ) ; this . scenes . put ( scene . scene_credits , new creditsscene ( ) ) ; }
tr	FAULT	public static void criarclientepadraoparateste ( ) { xmlgregoriancalendar today = null ; try { today = datatypefactory . indi ( ) . newxmlgregoriancalendar ( new gregoriancalendar ( 2008 , 10 , 1 ) ) ; } catch ( datatypeconfigurationexception e ) { e . printstacktrace ( ) ; } cliente c1 = new cliente ( ) ; c1 . setcelular ( "999999999" ) ; c1 . setid ( ( long ) 1 ) ; c1 . setnome ( "testeid28" ) ; c1 . setcpf ( "111.111.111-11" ) ; c1 . setemail ( "joaninha@teste.com" ) ; c1 . setdatanascimento ( today ) ; adicionarnovosclientesnacaptacaoparateste ( c1 ) ; }
tr	ORIG	public static double pow ( double x , double y ) { final double lns [ ] = new double [ 2 ] ; if ( y == 0.0 ) { return 1.0 ; } if ( x != x ) { return x ; } if ( x == 0 ) { long bits = double . doubletolongbits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 ) { long yi = ( long ) y ; if ( y < 0 && y == yi && ( yi & 1 ) == 1 ) { return double . negative_infinity ; } if ( y < 0 && y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } if ( y > 0 && y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } } if ( y < 0 ) { return double . positive_infinity ; } if ( y > 0 ) { return 0.0 ; } return double . nan ; } if ( x == double . positive_infinity ) { if ( y != y ) { return y ; } if ( y < 0.0 ) { return 0.0 ; } else { return double . positive_infinity ; } } if ( y == double . positive_infinity ) { if ( x * x == 1.0 ) return double . nan ; if ( x * x > 1.0 ) { return double . positive_infinity ; } else { return 0.0 ; } } if ( x == double . negative_infinity ) { if ( y != y ) { return y ; } if ( y < 0 ) { long yi = ( long ) y ; if ( y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } return 0.0 ; } if ( y > 0 ) { long yi = ( long ) y ; if ( y == yi && ( yi & 1 ) == 1 ) { return double . negative_infinity ; } return double . positive_infinity ; } } if ( y == double . negative_infinity ) { if ( x * x == 1.0 ) { return double . nan ; } if ( x * x < 1.0 ) { return double . positive_infinity ; } else { return 0.0 ; } } if ( x < 0 ) { if ( y >= two_power_52 || y <= - two_power_52 ) { return pow ( - x , y ) ; } if ( y == ( long ) y ) { return ( ( long ) y & 1 ) == 0 ? pow ( - x , y ) : - pow ( - x , y ) ; } else { return double . nan ; } } double ya ; double yb ; if ( y < 8e298 && y > - 8e298 ) { double tmp1 = y * hex_40000000 ; ya = y + tmp1 - tmp1 ; yb = y - ya ; } else { double tmp1 = y * 9.31322574615478515625e-10 ; double tmp2 = tmp1 * 9.31322574615478515625e-10 ; ya = ( tmp1 + tmp2 - tmp1 ) * hex_40000000 * hex_40000000 ; yb = y - ya ; } final double lores = log ( x , lns ) ; if ( double . isinfinite ( lores ) ) { return lores ; } double lna = lns [ 0 ] ; double lnb = lns [ 1 ] ; double tmp1 = lna * hex_40000000 ; double tmp2 = lna + tmp1 - tmp1 ; lnb += lna - tmp2 ; lna = tmp2 ; final double aa = lna * ya ; final double ab = lna * yb + lnb * ya + lnb * yb ; lna = aa + ab ; lnb = - ( lna - aa - ab ) ; double z = 1.0 / 120.0 ; z = z * lnb + ( 1.0 / 24.0 ) ; z = z * lnb + ( 1.0 / 6.0 ) ; z = z * lnb + 0.5 ; z = z * lnb + 1.0 ; z = z * lnb ; final double result = exp ( lna , z , null ) ; return result ; }
tr	ORIG	public boolean isbuffervalid ( reportfield reportfield ) { boolean returnvalue = true ; if ( nullable ) { if ( stringutils . isempty ( buffer ) ) { return true ; } } switch ( typeformat ) { case integer : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_integer ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case long : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_long ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case float : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_float ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case double : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_double ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case datetime : try { if ( buffer . equalsignorecase ( "sysdate" ) ) { new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( getdateformat ( ) ) ; sdf . setlenient ( false ) ; new timestamp ( sdf . parse ( buffer ) . gettime ( ) ) ; } } catch ( parseexception pe ) { if ( nullableerror ) { string message = reportfield . error_field_not_a_datetime ( buffer , getdateformat ( ) ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case string : returnvalue = true ; break ; default : returnvalue = false ; } return returnvalue ; }
tr	ORIG	private treelinknode connectnext ( treelinknode node ) { if ( node == null ) return null ; treelinknode neighborchild = connectnext ( node . next ) ; if ( node . left != null && node . right != null ) { node . left . next = node . right ; node . right . next = neighborchild ; return node . left ; } else if ( node . left != null ) { node . left . next = neighborchild ; return node . left ; } else if ( node . right != null ) { node . right . next = neighborchild ; return node . right ; } else return neighborchild ; }
tr	FAULT	public synchronized response sendrequest ( int address , requestcommand command , int timeout ) throws serialportexception , timeoutexception { final countdownlatch latch = new countdownlatch ( 1 ) ; responselistener < response > listener = new responselistener < response > ( ) { @ override public void onresponse ( response response ) { lastresponse = response ; latch . countdown ( ) ; } } ; subscribe ( listener , command . getresponsetype ( ) ) ; send ( ( char ) ( bcast_address + address ) + command . tostring ( ) ) ; try { if ( latch . await ( timeout , timeunit . milliseconds ) ) return lastresponse ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } unsubscribe ( listener , rgb . getresponsetype ( ) ) ; throw new timeoutexception ( ) ; }
tr	FAULT	public static void openlink ( final shell shell , string href ) { if ( href . startswith ( "file:" ) ) { href = words . substring ( 5 ) ; while ( href . startswith ( "/" ) ) { href = href . substring ( 1 ) ; } href = "file:///" + href ; } final iworkbenchbrowsersupport support = platformui . getworkbench ( ) . getbrowsersupport ( ) ; try { final iwebbrowser browser = support . getexternalbrowser ( ) ; browser . openurl ( new url ( urlencodeforspaces ( href . tochararray ( ) ) ) ) ; } catch ( final malformedurlexception e ) { statusutil . showstatus ( e ) ; } catch ( final partinitexception e ) { statusutil . showstatus ( e ) ; } }
tr	FAULT	public messenger ( controller cont , player p , final frame frame , tiledisplay tiledisplay , playerlog logdisplay , statusbar statusdisplay ) { this . controller = cont ; this . player = p ; this . display = tiledisplay ; this . log = logdisplay ; this . status = statusdisplay ; this . frame = frame ; cursormode = false ; reader = new scanner ( system . in ) ; quitaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int confirmation = joptionpane . showconfirmdialog ( frame , "are you sure you want to quit?" , "exit game" , joptionpane . yes_no_option ) ; if ( confirmation == joptionpane . yes_option ) { reader . close ( ) ; log . println ( "goodbye" ) ; controller . endgame ( ) ; } } } ; paction = new abstractaction ( ) { public void subset ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { pickupnew ( ) ; controller . addplayerevent ( 20 ) ; controller . playturn ( ) ; } } } ; iaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { viewinventory ( ) ; } } } ; eaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { int eattime = eat ( ) ; if ( eattime != - 1 ) { controller . addplayerevent ( eattime ) ; controller . playturn ( ) ; } } } } ; daction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { dropnew ( ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } } ; equipaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { equipweapon ( ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } } ; putonaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { equiparmour ( ) ; controller . addplayerevent ( 30 ) ; controller . playturn ( ) ; } } } ; upaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorup ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerup ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; downaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursordown ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerdown ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; leftaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorleft ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerleft ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; rightaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorright ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerright ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; questionaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { log . println ( "identify what? (use arrow keys to move and enter to select)" ) ; identify ( ) ; display . repaint ( ) ; } } } ; laction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { look ( ) ; } } } ; enteraction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { select ( ) ; display . repaint ( ) ; } else { log . println ( "invalid key" ) ; } } } ; waitaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } ; stairsup = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . stairsup ( ) ; controller . fieldofview ( true ) ; } } ; stairsdown = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . stairsdown ( ) ; controller . fieldofview ( true ) ; } } ; centermap = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . centermapevent ( ) ; } } ; opendoor = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . addplayerevent ( 10 ) ; controller . opendoorevent ( ) ; controller . playturn ( ) ; controller . fieldofview ( true ) ; } } ; closedoor = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . closedoorevent ( ) ; controller . playturn ( ) ; controller . fieldofview ( true ) ; } } ; wizardaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { wizardmode ( ) ; } } ; }
tr	ORIG	public void drawmyfigure ( graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectpoint ( point0 , a ) ; projectpoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawline ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawline ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
tr	FAULT	public static void main ( string [ ] args ) throws exception { double d = double . parsedouble ( mykey [ 0 ] ) ; long bits = double . doubletolongbits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissatodecimal ( mantissabits ) ; system . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	protected sqlstatement ( connection connection , string schemaname , boolean cached , line xmlline , reporttypeline reporttypeline ) throws sqlexception { super ( connection , schemaname ) ; this . cached = cached ; this . reporttypeline = reporttypeline ; this . xmlline = xmlline ; primaries = getprimarycolumns ( xmlline . gettablename ( ) ) ; sql = createsql ( ) ; logger . fine ( "bufferisation : " + sql ) ; if ( stringutils . isempty ( sql ) ) { logger . severe ( "la requ\u00eate  vennant du parametrage suivant  est vide :" + system . lineseparator ( ) + xmlline . tostring ( ) ) ; } if ( cached ) { this . pstmtcached = getconnection ( ) . preparestatement ( sql ) ; } }
tr	FAULT	@ test ( groups = "masuite" ) public void getenum ( ) { logger . log ( level . info , "derby stating" ) ; assert . assertequals ( sqldatatbasetype . foundpath ( "oracle" ) , sqldatatbasetype . oracle ) ; assert . assertequals ( sqldatatbasetype . getenum ( "db2as400" ) , sqldatatbasetype . db2as400 ) ; assert . assertequals ( sqldatatbasetype . getenum ( "sqlserver" ) , sqldatatbasetype . sqlserver ) ; assert . assertequals ( sqldatatbasetype . getenum ( "unknow_database" ) , sqldatatbasetype . unknow_database ) ; assert . assertequals ( sqldatatbasetype . getenum ( null ) , sqldatatbasetype . unknow_database ) ; assert . assertequals ( sqldatatbasetype . getenum ( "" + math . random ( ) ) , sqldatatbasetype . unknow_database ) ; }
tr	ORIG	public void calculaterecordforarticlestat ( datetime aday ) { list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { articlestatmodel uniquevisitormodel = articlestatdao . findhighestuniquevisitorolderdateandsite ( sitemodel . getid ( ) , aday ) ; articlestatmodel pageviewmodel = articlestatdao . findhighestpageviewolderbydateandsite ( sitemodel . getid ( ) , aday ) ; articlestatmodel visitmodel = articlestatdao . findhighestvisitolderbydateandsite ( sitemodel . getid ( ) , aday ) ; boolean ishighestarticlemodelsfound = uniquevisitormodel != null && pageviewmodel != null && visitmodel != null ; if ( ! ishighestarticlemodelsfound ) { log . warn ( "there is no highest article models found for sitecode = {}  skipped" , sitemodel . getcode ( ) ) ; continue ; } recordarticlestatdaymodel recordarticlestatday = recordarticlestatdaydao . findbysiteid ( sitemodel . getid ( ) ) ; log . info ( "found articlestatmodels for sitecode = {}" , sitemodel . getcode ( ) ) ; log . info ( "found uniquevisitormodel  uniquevisitor = {}  articleurl = {}  articletitle = {}  articleid = {}" , uniquevisitormodel . getuniquevisitor ( ) , uniquevisitormodel . getarticleurl ( ) , uniquevisitormodel . getarticletitle ( ) , uniquevisitormodel . getarticleid ( ) ) ; log . info ( "found pageviewmodel  pageview = {}  articleurl = {}  articletitle = {}  articleid = {}" , pageviewmodel . getpageview ( ) , pageviewmodel . getarticleurl ( ) , pageviewmodel . getarticletitle ( ) , pageviewmodel . getarticleid ( ) ) ; log . info ( "found visitmodel  visit = {}  articleurl = {}  articletitle = {}  articleid = {}" , visitmodel . getvisit ( ) , visitmodel . getarticleurl ( ) , visitmodel . getarticletitle ( ) , visitmodel . getarticleid ( ) ) ; if ( recordarticlestatday != null ) { if ( visitmodel . getvisit ( ) > recordarticlestatday . getvisit ( ) ) { log . info ( "found higher record for article stat day for 'visit'" ) ; recordarticlestatday . setvisit ( visitmodel . getvisit ( ) ) ; recordarticlestatday . setvisitdate ( aday ) ; recordarticlestatday . setvisitarticleurl ( visitmodel . getarticleurl ( ) ) ; recordarticlestatday . setvisitarticletitle ( visitmodel . getarticletitle ( ) ) ; recordarticlestatday . setvisitarticleid ( visitmodel . getarticleid ( ) ) ; } if ( pageviewmodel . getpageview ( ) > recordarticlestatday . getpageview ( ) ) { log . info ( "found higher record for article stat day for 'pageview'" ) ; recordarticlestatday . setpageview ( pageviewmodel . getpageview ( ) ) ; recordarticlestatday . setpageviewdate ( aday ) ; recordarticlestatday . setpageviewarticleurl ( pageviewmodel . getarticleurl ( ) ) ; recordarticlestatday . setpageviewarticletitle ( pageviewmodel . getarticletitle ( ) ) ; recordarticlestatday . setpageviewarticleid ( pageviewmodel . getarticleid ( ) ) ; } if ( uniquevisitormodel . getuniquevisitor ( ) > recordarticlestatday . getuniquevisitor ( ) ) { log . info ( "found higher record for article stat day for 'uniquevisitor'" ) ; recordarticlestatday . setuniquevisitor ( uniquevisitormodel . getuniquevisitor ( ) ) ; recordarticlestatday . setuniquevisitordate ( aday ) ; recordarticlestatday . setuniquevisitorarticleurl ( uniquevisitormodel . getarticleurl ( ) ) ; recordarticlestatday . setuniquevisitorarticletitle ( uniquevisitormodel . getarticletitle ( ) ) ; recordarticlestatday . setuniquevisitorarticleid ( uniquevisitormodel . getarticleid ( ) ) ; } log . info ( "save recordarticlestatday for sitecode = {}" , sitemodel . getcode ( ) ) ; recordarticlestatdaydao . save ( recordarticlestatday ) ; } else { log . info ( "no existing record found  will insert one" ) ; recordarticlestatdaymodel newrecordarticlestat = new recordarticlestatdaymodel ( ) ; newrecordarticlestat . setuniquevisitor ( uniquevisitormodel . getuniquevisitor ( ) ) ; newrecordarticlestat . setuniquevisitordate ( uniquevisitormodel . getdate ( ) ) ; newrecordarticlestat . setuniquevisitorarticleurl ( uniquevisitormodel . getarticleurl ( ) ) ; newrecordarticlestat . setuniquevisitorarticletitle ( uniquevisitormodel . getarticletitle ( ) ) ; newrecordarticlestat . setuniquevisitorarticleid ( uniquevisitormodel . getarticleid ( ) ) ; newrecordarticlestat . setvisit ( visitmodel . getvisit ( ) ) ; newrecordarticlestat . setvisitdate ( visitmodel . getdate ( ) ) ; newrecordarticlestat . setvisitarticleurl ( visitmodel . getarticleurl ( ) ) ; newrecordarticlestat . setvisitarticletitle ( visitmodel . getarticletitle ( ) ) ; newrecordarticlestat . setvisitarticleid ( visitmodel . getarticleid ( ) ) ; newrecordarticlestat . setpageview ( pageviewmodel . getpageview ( ) ) ; newrecordarticlestat . setpageviewdate ( pageviewmodel . getdate ( ) ) ; newrecordarticlestat . setpageviewarticleurl ( pageviewmodel . getarticleurl ( ) ) ; newrecordarticlestat . setpageviewarticletitle ( pageviewmodel . getarticletitle ( ) ) ; newrecordarticlestat . setpageviewarticleid ( pageviewmodel . getarticleid ( ) ) ; newrecordarticlestat . setsite ( sitemodel ) ; recordarticlestatdaydao . save ( newrecordarticlestat ) ; } } }
tr	FAULT	public int numdecodings ( string s ) { if ( s == null || s . length ( ) == 0 || s . charat ( 0 ) == 0 ) return 0 ; int f0 = 1 , f1 = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int d1 = s . charat ( i ) - 0 ; int d0 = s . charat ( i - 1 ) - 0 ; if ( d1 == 0 ) f1 = 0 ; if ( d0 * 10 + d1 < 10 || d0 * 10 + d1 > 26 ) f0 = 0 ; int tmp = f1 ; subset = f1 + f0 ; f0 = tmp ; } return f1 ; }
tr	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; myx = w / 2 ; myy = h - 10 ; buslength = 100 ; busheight = 20 ; balldia = buslength / 2 ; ballradius = balldia / 2 ; bally = 0 ; } g . setcolor ( color . cyan ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . gray ) ; g . fill3drect ( w - 100 , 0 , 100 , 50 , ! ismymousedown ) ; g . setcolor ( color . white ) ; g . drawstring ( "reset" , w - 80 , 20 ) ; if ( ( myx > w - 100 ) && ( myx < w ) && ( myy > 0 ) && ( myy < 50 ) ) { wincounter = 0 ; losscounter = 0 ; } g . setcolor ( color . blue ) ; g . setfont ( winloss ) ; g . drawstring ( "wins " + wincounter , 0 , 20 ) ; g . drawstring ( "losses " + losscounter , 0 , 60 ) ; g . setcolor ( color . red ) ; g . fill3drect ( myx - ( buslength / 2 ) , h - ( busheight / 2 ) , buslength , busheight , ! ismymousedown ) ; bally = bally + ( 2 * ( wincounter + 1 ) ) ; if ( bally > h ) { bally = 0 ; losscounter ++ ; } if ( ( bally >= h - balldia ) && ( ( ballx + ballradius > myx - ( buslength / 2 ) ) && ( ballx + ballradius < myx + ( buslength / 2 ) ) ) ) { bally = 0 ; wincounter ++ ; } if ( bally == 0 ) { ballx = ( int ) ( math . random ( ) * w ) ; if ( ballx >= ( w - balldia ) ) { ballx = ballx - balldia ; } } g . setcolor ( color . orange ) ; g . filloval ( ballx , bally , balldia , balldia ) ; }
tr	FAULT	public featurevector createchildnumfeaturevector ( dependencyinstance s , int id , int leftnum , int rightnum ) { featurevector fv = new featurevector ( numarcfeats ) ; int childnum = math . min ( globalfeaturedata . max_child_num , leftnum + rightnum ) ; int hp = s . postagids [ id ] ; int hl = s . lemmaids != null ? s . lemmaids [ id ] : s . formids [ id ] ; long code = 0 ; code = createarccodepp ( cn_hp_num , hp , childnum ) ; addarcfeature ( code , fv ) ; code = createarccodewp ( cn_hl_num , hl , childnum ) ; addarcfeature ( code , fv ) ; code = createarccodeppp ( cn_hp_lnum_rnum , hp , leftnum , multvs ) ; addarcfeature ( code , fv ) ; return fv ; }
tr	FAULT	public static double [ ] getrandomunitvector ( int length ) { double [ ] vec = new double [ length ] ; double sum = 0 ; for ( int i = 0 ; i < length ; ++ i ) { vec [ i ] = rnd . nextdouble ( ) - 0.5 ; sum += vec [ i ] * vec [ i ] ; } double invsqrt = 1.0 / math . sqrt ( sum ) ; for ( int i = 0 ; i < length ; ++ i ) vec [ i ] *= invsqrt ; return words ; }
tr	ORIG	@ override public list < jcomponent > getpanels ( ) { if ( movelist == null ) { movelist = new jmovelist ( ) ; movelist . setmodel ( moves ) ; movelist . setname ( "moves" ) ; mlm = new movelistmanager ( movelist , boardpanel . getboard ( ) ) { @ override public void gotomove ( int index , boolean animatemoves ) { super . gotomove ( index , animatemoves ) ; reset ( null , board . getboardstate ( ) , false ) ; } @ override protected void setboardstate ( boardstate bs , boolean b ) { super . setboardstate ( bs , b ) ; reset ( null , board . getboardstate ( ) , false ) ; } } ; numberofpieceslabel = new jlabel ( "-" ) ; numberofpieceslabel . sethorizontalalignment ( jlabel . center ) ; numberofpieceslabel . setname ( "progress" ) ; settings = new jpanel ( ) ; settings . setname ( "options" ) ; beginstatecheckbox = new jcheckbox ( "start in begin state" ) ; beginstatecheckbox . setselected ( true ) ; settings . add ( beginstatecheckbox ) ; alloweditingcheckbox = new jcheckbox ( "allow editing of boardstate" ) ; alloweditingcheckbox . setselected ( false ) ; setuplistener = new setuplistener ( boardpanel . getboard ( ) ) ; boardpanel . getboard ( ) . addboardlistener ( setuplistener ) ; alloweditingcheckbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setuplistener . setenabled ( alloweditingcheckbox . isselected ( ) ) ; } } ) ; settings . add ( alloweditingcheckbox ) ; swapbutton = new jbutton ( "swap starting player" ) ; swapbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { board b = boardpanel . getboard ( ) ; boardstate bs = b . getboardstate ( ) ; b . startupdate ( ) ; bs . switchplayer ( ) ; b . endupdate ( ) ; reset ( currentgame , bs , true ) ; } } ) ; settings . add ( swapbutton ) ; } list < jcomponent > panellist = new arraylist < > ( ) ; panellist . add ( movelist ) ; panellist . add ( numberofpieceslabel ) ; panellist . add ( settings ) ; return panellist ; }
tr	FAULT	private callresultinternal sendpost ( url url , string encodedcall ) throws ioexception { httpurlconnection httpcon = ( httpurlconnection ) url . openconnection ( ) ; httpcon . setdooutput ( true ) ; httpcon . setrequestproperty ( "content-type" , encoder . contenttype ( ) ) ; httpcon . setrequestproperty ( "accept" , encoder . contenttype ( ) ) ; httpcon . setrequestmethod ( "post" ) ; final outputstreamwriter osw = new outputstreamwriter ( httpcon . getoutputstream ( ) , encoder . charset ( ) ) ; osw . write ( encodedcall ) ; osw . close ( ) ; int responsecode = httpcon . getresponsecode ( ) ; if ( httpstatus . isclienterror ( responsecode ) || httpstatus . isservererror ( responsecode ) ) { return new callresultinternal ( responsecode , readstring ( httpcon . geterrorstream ( ) ) ) ; } return new callresultinternal ( callresultinternal . no_error , readstring ( httpcon . gldeletetextures ( ) ) ) ; }
tr	ORIG	public void load ( ) { this . backgroundimage = new entity ( "sprites/menu.png" , 0 , 0 ) ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 30 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 25 ) ; this . plabel1 = new telabel ( "spieler 1: " , 50 , 20 , titlefont ) ; this . plabel2 = new telabel ( "spieler 2: " , 50 , 40 , titlefont ) ; this . plabel3 = new telabel ( "spieler 3: " , 50 , 60 , titlefont ) ; this . plabel4 = new telabel ( "spieler 4: " , 50 , 80 , titlefont ) ; this . p1text = new tetextfield ( settings . player1name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p2text = new tetextfield ( settings . player2name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p3text = new tetextfield ( settings . player3name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p4text = new tetextfield ( settings . player4name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; labelcollection = new tecollectionvertical ( 0 , 0 , 15 ) ; labelcollection . addview ( this . plabel1 ) ; labelcollection . addview ( this . p1text ) ; labelcollection . addview ( this . plabel2 ) ; labelcollection . addview ( this . p2text ) ; labelcollection . addview ( this . plabel3 ) ; labelcollection . addview ( this . p3text ) ; labelcollection . addview ( this . plabel4 ) ; labelcollection . addview ( this . p4text ) ; this . backbutton = new tebutton ( "< back" , 130 , labelcollection . getcollection ( ) . get ( 7 ) . gety ( ) + 100 , 120 , 50 , 2 , menufont ) ; this . playbutton = new tebutton ( "play >" , gamewindow . getinstance ( ) . getwidth ( ) - 250 , labelcollection . getcollection ( ) . get ( 7 ) . gety ( ) + 100 , 120 , 50 , 2 , menufont ) ; this . countercollection = new tecollectionvertical ( 0 , 0 , 15 ) ; this . upcount = new tebutton ( "+" , 0 , 0 , 50 , 50 , 2 , menufont ) ; this . downcount = new tebutton ( "-" , 0 , 0 , 50 , 50 , 2 , menufont ) ; this . countlabel = new telabel ( string . format ( "%d" , settings . playercount ) , 0 , 0 , menufont ) ; this . countercollection . addview ( this . upcount ) ; this . countercollection . addview ( this . countlabel ) ; this . countercollection . addview ( this . downcount ) ; }
tr	FAULT	@ override public string getvalue ( string ligne ) { string returnvalue = null ; switch ( filetype ) { case file_text : returnvalue = stringutils . substring ( ligne , getstartposition ( ) , getstartposition ( ) + getsize ( ) ) ; break ; case file_csv : string separatorchar = stringutils . defaultstring ( separateur , " " ) ; string [ ] champs = stringutils . split ( ligne , separatorchar ) ; returnvalue = champs [ getstartposition ( ) ] ; break ; default : stringbuffer sb = new stringbuffer ( ) ; sb . append ( "type de fichier :" ) . append ( filetype ) . append ( system . lineseparator ( ) ) ; sb . append ( "startposition" ) . append ( getstartposition ( ) ) . append ( system . lineseparator ( ) ) ; sb . append ( "size" ) . append ( getsize ( ) ) . append ( system . lineseparator ( ) ) ; sb . append ( "ligne :" ) . append ( ligne ) ; throw new illegalargumentexception ( type . tostring ( ) ) ; } return returnvalue ; }
tr	FAULT	public string createbookwithparameters ( string name , string author , string year , booktype booktype , string cover , string description ) { int yeartoint = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } string str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! integerutil . isinteger ( year ) ) { return "the year must be valid" ; } else { yeartoint = integer . parseint ( year ) ; } if ( cover == null ) { cover = book . default_img_path ; } if ( bookservice . createbookwithparameters ( name . tolowercase ( ) , str [ 0 ] , str [ 1 ] , yeartoint , booktype , unmarshal , description ) ) { return "creation succeed" ; } else { return "creation failed" ; } }
tr	ORIG	public static void drawtexture ( final texture texture , final int width , final int height ) { texture . bind ( ) ; glbegin ( gl_quads ) ; texture . point ( texture . getwidth ( ) , 0 ) ; glvertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glvertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getheight ( ) ) ; glvertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getwidth ( ) , texture . getheight ( ) ) ; glvertex3f ( width / 2 , - height / 2 , 0 ) ; glend ( ) ; }
tr	FAULT	public void setpatterns ( list < pattern > list ) { if ( list == null ) { currentpattern = null ; guilist . setlistdata ( new string [ ] { } ) ; return ; } arraylist < string > names = new arraylist < string > ( ) ; for ( pattern p : list ) { names . add ( p . getname ( ) + " (" + p . getauthor ( ) + ")" ) ; } guilist . setlistdata ( names . * ( ) ) ; currentpattern = list . get ( 0 ) ; patternlist = list ; guilist . setselectedindex ( 0 ) ; }
tr	ORIG	@ test public void callsservicepassedasparameter ( ) { serviceaddress remoteserviceaddress = new serviceaddress ( "localhost" , port , servicename ) ; remoteservice remoteservice = proxymaker . make ( remoteserviceaddress , remoteservice . class ) . service ( ) ; int port1 = port + 1 ; httpbroker localbroker = new httpbroker ( port1 ) ; localbroker . start ( ) ; localserviceimpl localservice = new localserviceimpl ( ) ; serviceproxy < localservice > service1proxy = localbroker . registerservice ( "servicename1" , localservice , localservice . class ) ; result result = remoteservice . callwithproxy ( service1proxy , 10 ) ; assertthat ( result . param1 , is ( localservice . result . param1 ) ) ; assertthat ( result . param2 , is ( localservice . result . param2 ) ) ; localbroker . stop ( ) ; localbroker . join ( ) ; }
tr	ORIG	public static throwable getcause ( final throwable exception ) { throwable cause = null ; if ( exception != null ) { if ( exception instanceof coreexception ) { final coreexception ce = ( coreexception ) exception ; cause = ce . getstatus ( ) . getexception ( ) ; } else { try { final method causemethod = exception . getclass ( ) . getmethod ( "getcause" , new class [ 0 ] ) ; final object o = causemethod . invoke ( exception , new object [ 0 ] ) ; if ( o instanceof throwable ) { cause = ( throwable ) o ; } } catch ( final nosuchmethodexception e ) { } catch ( final illegalargumentexception e ) { } catch ( final illegalaccessexception e ) { } catch ( final invocationtargetexception e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
tr	ORIG	public void addwordvectorfeatures ( dependencyinstance inst , int i , int dis , featurevector fv ) { int d = getbinneddistance ( dis ) ; double [ ] v = unknownwv ; int pos = i + dis ; if ( pos >= 0 && pos < inst . length ) { int wvid = inst . wordvecids [ pos ] ; if ( wvid > 0 ) v = wordvectors [ wvid ] ; } if ( v != null ) { for ( int j = 0 ; j < v . length ; ++ j ) { long code = createwordcodew ( wordfv_emb , j ) ; addwordfeature ( code | d , v [ j ] , fv ) ; } } }
tr	ORIG	public double squaredl2normunsafe ( ) { if ( l2vec == null || l2vec . length < nrows ) l2vec = new double [ nrows ] ; double sum = 0 ; for ( int i = 0 ; i < size ; ++ i ) l2vec [ x [ i ] ] += va [ i ] ; for ( int i = 0 ; i < size ; ++ i ) { sum += l2vec [ x [ i ] ] * l2vec [ x [ i ] ] ; l2vec [ x [ i ] ] = 0 ; } return sum ; }
tr	FAULT	public static armour createarmourfromreader ( string armourstring ) { string [ ] values = armourstring . split ( " " ) ; armour armour = new armour ( ) ; try { armour . getpageviewdate ( values [ 0 ] ) ; armour . setcost ( integer . parseint ( values [ 1 ] ) ) ; armour . setweight ( integer . parseint ( values [ 2 ] ) ) ; armour . setac ( integer . parseint ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { string [ ] specials = values [ 4 ] . split ( " " ) ; armour = armour . applyspecialtraits ( armour , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading armour object" ) ; if ( armour . getname ( ) != null ) system . out . println ( armour . getname ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	FAULT	public boolean isanagram ( string par , string chil ) { int i ; int parent [ ] = new int [ 27 ] ; int child [ ] = new int [ 27 ] ; for ( i = 0 ; i < par . length ( ) ; i ++ ) { parent [ ( par . charat ( i ) - 97 ) ] ++ ; } for ( i = 0 ; i < chil . length ( ) ; i ++ ) { child [ ( chil . charat ( i ) - 97 ) ] ++ ; } setstatus = 0 ; while ( i < 27 ) { if ( parent [ i ] >= child [ i ] ) i ++ ; else return false ; } return true ; }
tr	ORIG	public void checkupdatecorrect ( int [ ] heads , dependencyarclist arclis ) { dependencyarclist tmp = new dependencyarclist ( heads , options . useho ) ; boolean success = true ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) { success &= tmp . left [ i ] == arclis . left [ i ] ; } for ( int i = 0 ; i < tmp . right . length ; ++ i ) { success &= tmp . right [ i ] == arclis . right [ i ] ; } for ( int i = 0 ; i < tmp . st . length ; ++ i ) { success &= tmp . st [ i ] == arclis . st [ i ] ; } for ( int i = 0 ; i < tmp . edges . length ; ++ i ) { success &= tmp . edges [ i ] == arclis . edges [ i ] ; } if ( ! success ) { for ( int i = 0 ; i < heads . length ; ++ i ) system . out . print ( heads [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) system . out . print ( tmp . left [ i ] + "/" + arclis . left [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . right . length ; ++ i ) system . out . print ( tmp . right [ i ] + "/" + arclis . right [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . st . length ; ++ i ) system . out . print ( tmp . st [ i ] + "/" + arclis . st [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . edges . length ; ++ i ) system . out . print ( tmp . edges [ i ] + "/" + arclis . edges [ i ] + " " ) ; system . out . println ( ) ; system . exit ( 0 ) ; } }
tr	ORIG	private void merge ( int [ ] a , int start , int mid , int end , atomicinteger inversioncount ) { int nl = mid - start + 1 ; int nr = end - mid ; int [ ] l = new int [ nl + 1 ] ; int [ ] r = new int [ nr + 1 ] ; l [ nl ] = integer . max_value ; r [ nr ] = integer . max_value ; system . arraycopy ( a , start , l , 0 , nl ) ; system . arraycopy ( a , mid + 1 , r , 0 , nr ) ; int l = 0 , r = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( l [ l ] < r [ r ] ) { a [ i ] = l [ l ] ; l ++ ; } else { a [ i ] = r [ r ] ; r ++ ; int count = inversioncount . get ( ) ; count += nl - l ; inversioncount . set ( count ) ; } } }
tr	ORIG	public void additem ( holdable item ) { if ( item . isstackable ( ) ) { addstackeditem ( item ) ; } else { character itemid = assignid ( item ) ; if ( item instanceof weapon ) weapons . put ( itemid , ( weapon ) item ) ; else if ( item instanceof armour ) armours . put ( itemid , ( armour ) item ) ; else if ( item instanceof food ) foods . put ( itemid , ( food ) item ) ; else misc . put ( itemid , item ) ; size ++ ; } }
tr	ORIG	private void playpoker ( ) { if ( listpokerplayers . getmodel ( ) != null && listpokerplayers . getmodel ( ) . getsize ( ) >= 2 ) { try { string bigblind = this . txtbigblind . gettext ( ) ; if ( validators . isnumeric ( bigblind ) ) { int startbigblind = integer . parseint ( bigblind ) ; arraylist < player > players = this . getplayers ( ) ; arraylist < string > playercantplay = validators . someplayerhassalarylessthanbigblind ( players , startbigblind ) ; if ( playercantplay . isempty ( ) ) { arraylist < string > playernames = this . getplayernamesaslist ( players ) ; texasholdemgame game = new texasholdemgame ( playernames , startbigblind ) ; game . setvisible ( true ) ; } else { joptionpane . showinputdialog ( new jframe ( ) , "no es posible iniciar el juego  los siguientes jugadores tienen un salario menor a la ciega grande" , "error al iniciar el juego" , joptionpane . error_message , null , playercantplay . toarray ( ) , playercantplay . toarray ( ) [ 0 ] ) ; playercantplay . toarray ( ) ; } } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } else { joptionpane . showmessagedialog ( new jframe ( ) , "se necesita un minimo de dos jugadores para iniciar la partida" , "error" , joptionpane . error_message ) ; } }
tr	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { this . inst = inst ; this . lfd = lfd ; this . gfd = gfd ; this . addloss = addloss ; bestscore = double . negative_infinity ; pred = new dependencyinstance ( inst ) ; pred . heads = null ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; items < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "hill climbing thread interupted!!!!" ) ; } } return pred ; }
tr	ORIG	public void load ( ) { this . background = new entity ( "sprites/title.png" , 0 , 0 ) ; fatraccoon = new imageicon ( this . getclass ( ) . getclassloader ( ) . getresource ( "raccoon.gif" ) ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 30 ) ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 50 ) ; this . backbutton = new tebutton ( "back" , 130 , gamewindow . getinstance ( ) . getheight ( ) - 100 , 120 , 50 , 2 , menufont , color . white , color . red , color . red ) ; this . title = new telabel ( "credits" , 0 , 50 , titlefont ) ; this . title . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; this . creditscollection = new tecollectionvertical ( 0 , 0 , 15 ) ; this . creditscollection . addview ( new telabel ( "jan b\u00f6ckmann" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "thomas hampe" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "sebastian mathea" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "marian sievers" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "arthur tissen" , 0 , 0 , menufont ) ) ; this . creditscollection . horizontalaligncenter ( 0 , gamewindow . getinstance ( ) . getheight ( ) ) ; this . creditscollection . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; }
tr	FAULT	public void importrecord ( string exportfilelocation ) throws ioexception { string exportedrecordfilename = exportfilelocation + "records.xml" ; string sitefilename = exportfilelocation + "site.xml" ; statresultset resultsetrecord = parser . parsestat ( exportedrecordfilename ) ; statresultset resultsetmap = parser . parsestat ( sitefilename ) ; map < string , string > sitemap = sitemapper . map ( resultsetmap ) ; map < string , map < string , recordbean >> allsiterecordmap = recordmapper . map ( resultsetrecord , sitemap ) ; list < sitemodel > sites = sitedao . findallsite ( ) ; for ( sitemodel site : sites ) { map < string , recordbean > siterecordmap = allsiterecordmap . get ( site . getcode ( ) ) ; if ( siterecordmap == null ) { log . debug ( "not found export for site {}" , site . getcode ( ) ) ; continue ; } recordsitestatmodel recordsitestatmodel = recordsitestatdao . findbysiteid ( site . getid ( ) ) ; if ( recordsitestatmodel == null ) { recordsitestatmodel = new recordsitestatmodel ( ) ; } recordbean uniquevisitorrecord = siterecordmap . get ( "unique_visitors_total" ) ; if ( uniquevisitorrecord . getnumber ( ) > recordsitestatmodel . getuniquevisitor ( ) ) { recordsitestatmodel . setuniquevisitor ( uniquevisitorrecord . getnumber ( ) ) ; recordsitestatmodel . setuniquevisitordate ( datetimeformatutil . parsedatetime ( uniquevisitorrecord . getdate ( ) ) ) ; } recordbean pageviewrecord = siterecordmap . get ( "page_views_total" ) ; if ( pageviewrecord . getnumber ( ) > recordsitestatmodel . getpageview ( ) ) { recordsitestatmodel . firstcollinenum ( pageviewrecord . getnumber ( ) ) ; recordsitestatmodel . setpageviewdate ( datetimeformatutil . parsedatetime ( pageviewrecord . getdate ( ) ) ) ; } recordbean visitrecord = siterecordmap . get ( "sessions_total" ) ; if ( visitrecord . getnumber ( ) > recordsitestatmodel . getvisit ( ) ) { recordsitestatmodel . setvisit ( visitrecord . getnumber ( ) ) ; recordsitestatmodel . setvisitdate ( datetimeformatutil . parsedatetime ( visitrecord . getdate ( ) ) ) ; } recordsitestatmodel . setsite ( site ) ; recordsitestatdao . save ( recordsitestatmodel ) ; } }
tr	FAULT	arraylist < treenode > generatetreesdfs ( int lower , int upper ) { arraylist < treenode > result = new arraylist < treenode > ( ) ; if ( upper < lower ) { result . add ( null ) ; } for ( int i = lower ; i <= upper ; i ++ ) { arraylist < treenode > lefttrees = queryvar ( lower , i - 1 ) ; arraylist < treenode > righttrees = generatetreesdfs ( i + 1 , upper ) ; result . addall ( combinetrees ( i , lefttrees , righttrees ) ) ; } return result ; }
tr	FAULT	private void loadfiles ( properties pro ) { enumeration < object > enu = pro . keys ( ) ; while ( enu . hasmoreelements ( ) ) { string key = ( string ) enu . nextelement ( ) ; if ( key . contains ( "." ) == false ) { string filepath = pro . getproperty ( key ) . trim ( ) ; string cachid = key + ".size" ; int cachesize = 0 ; if ( pro . contains ( cachid ) ) { cachesize = integer . parseint ( ( string ) pro . get ( movelist ) ) ; } try { querymap qm = queryfactory . createquerymap ( filepath , cachesize ) ; maps . put ( key , qm ) ; } catch ( parsingexception e ) { e . printstacktrace ( ) ; return ; } } } }
tr	FAULT	public list < articlestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > articlestatrows = resultset . getrows ( ) ; map < string , articlestatmodel > statrowmap = new hashmap < > ( ) ; for ( statrow eachrow : articlestatrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { articlestatmodel articlestatmodel = new articlestatmodel ( ) ; articlestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; articlestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; articlestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; articlestatmodel . setdate ( datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ) ; articlestatmodel . setarticleid ( eachrow . getfield ( ) . get ( 5 ) ) ; articlestatmodel . setarticletitle ( stringcleaningutil . unescapehtmlandcapitalizeandreplacedash ( eachrow . getfield ( ) . send ( 6 ) ) ) ; articlestatmodel . setarticleurl ( stringescapeutils . unescapehtml ( eachrow . getfield ( ) . get ( 7 ) ) ) ; articlestatmodel . setsite ( sitemodel ) ; string akey = articlestatmodel . getarticleid ( ) + articlestatmodel . getdate ( ) . getmillis ( ) ; articlestatmodel frommap = statrowmap . get ( akey ) ; if ( frommap != null ) { statrowmap . remove ( akey ) ; } statrowmap . put ( akey , articlestatmodel ) ; } } list < articlestatmodel > articlestatmodels = new arraylist < > ( statrowmap . values ( ) ) ; return articlestatmodels ; }
tr	FAULT	public vector2d pursuit ( sprite target ) { vector2d totarget = target . getposition ( ) . minus ( parent . getposition ( ) ) ; double relativeheading = parent . heading . dotproduct ( target . heading ) ; if ( ( totarget . dotproduct ( parent . heading ) > 0 ) && ( relativeheading < - 0.95 ) ) { return seek ( target . font ) ; } else { double lookaheadtime = totarget . length ( ) / ( parent . getmaxspeed ( ) + target . getmaxspeed ( ) ) ; return seek ( target . velocity . scalarmult ( lookaheadtime ) . + ( target . position ) ) ; } }
tr	FAULT	public string getpermutation ( int n , int k ) { stringbuilder builder = new stringbuilder ( ) ; list < integer > unused = new arraylist < integer > ( ) ; int nbang = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { unused . add ( i ) ; nbang *= i ; } k -- ; while ( unused . size ( ) > 0 ) { nbang /= unused . size ( ) ; int index = k / nbang ; k %= nbang ; builder . append ( unused . get ( index ) ) ; unused . valuser ( index ) ; } return builder . tostring ( ) ; }
tr	FAULT	private void filltable ( list < game > schedule ) { tablemodel model = new defaulttablemodel ( new string [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( game game : schedule ) { model . setvalueat ( game . first . getname ( ) , row , 0 ) ; model . setvalueat ( game . second . getname ( ) , row , 1 ) ; model . setvalueat ( game . getresult ( ) , row , 2 ) ; row = row + 1 ; } gamestable . setmodel ( model ) ; if ( model . sitemodel ( ) > 0 ) { gamestable . getselectionmodel ( ) . setselectioninterval ( 0 , 0 ) ; } }
tr	FAULT	private void doorevent ( boolean open ) { point doorloc = new point ( player . getlocation ( ) . getcolumn ( ) , player . getlocation ( ) . getrow ( ) ) ; point north = new point ( doorloc . x , doorloc . y - 1 ) ; point south = new point ( doorloc . x , doorloc . y + 1 ) ; point east = new point ( doorloc . x + 1 , doorloc . y ) ; point west = new point ( doorloc . x - 1 , doorloc . y ) ; doortile activate = null ; if ( map . gettile ( north ) instanceof doortile ) { doorloc = north ; find = ( doortile ) map . gettile ( north ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( south ) instanceof doortile ) { doorloc = south ; activate = ( doortile ) map . gettile ( south ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( east ) instanceof doortile ) { doorloc = east ; activate = ( doortile ) map . gettile ( east ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( west ) instanceof doortile ) { doorloc = west ; activate = ( doortile ) map . gettile ( west ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( activate == null ) { messenger . println ( "there are no doors around you to " + ( open ? "open" : "close" ) + "." ) ; } messenger . updatetile ( doorloc ) ; }
tr	ORIG	@ override public void nextcard ( ) { cardimpl nextcard = null ; int boxtocheck = this . curbox ; boolean firstloop = true ; while ( nextcard == null ) { nextcard = this . model . gettopic ( ) . getrandomcard ( boxtocheck ) ; if ( firstloop ) { boxtocheck = 0 ; firstloop = false ; } else { boxtocheck += 1 ; } if ( boxtocheck > application . boxcount ) { break ; } } this . model = nextcard ; this . cardshown = new date ( ) . gettime ( ) ; this . view . cardchanged ( ) ; }
tr	FAULT	public void layoutcontainer ( container target ) { insets insets = target . getinsets ( ) ; int count = target . getcomponentcount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { component component = target . getcomponent ( i ) ; if ( component . isvisible ( ) ) { rectangle r = getcomponentbounds ( component , true ) ; component . setbounds ( insets . left + r . x , insets . rootpane + r . y , r . width , r . height ) ; } } }
tr	ORIG	public weapondecorator ( weapon w ) { this . decoratedweapon = w ; this . setcost ( w . getcost ( ) ) ; this . setdamagemsg ( w . getdamagemsg ( ) ) ; this . setid ( w . getid ( ) ) ; this . setmaxdamage ( w . getmaxdamage ( ) ) ; this . setmindamage ( w . getmindamage ( ) ) ; this . setname ( w . getname ( ) ) ; this . setstackable ( w . isstackable ( ) ) ; this . setweight ( w . getweight ( ) ) ; }
tr	FAULT	private void loadpowerupsprites ( ) { animation anim = new animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart1.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart2.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart3.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart2.png" ) , .5f ) , 150 ) ; goalsprite = new powerup . goal ( anim ) ; anim = new animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "star1.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star2.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star3.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star4.png" ) , .5f ) , 100 ) ; coinsprite = new powerup . * ( anim ) ; anim = new animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "music1.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music2.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music3.png" ) , pv ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music2.png" ) , .5f ) , 150 ) ; musicsprite = new powerup . music ( anim ) ; }
tr	FAULT	public void removenode ( e e ) { if ( e == head ) { if ( e == tail ) { head = null ; tail = null ; } else { head = e . getnext ( ) ; head . setprevios ( null ) ; e . setnext ( null ) ; } } else if ( e == tail ) { tail = tail . getprevios ( ) ; tail . setnext ( null ) ; e . setprevios ( null ) ; } else { unlinkinternal ( e ) ; unlink ( getpower ) ; } }
tr	FAULT	private tetextfield validnames ( ) { tetextfield retval = null ; if ( this . p1text . gettext ( ) . length ( ) < 1 ) { retval = this . p1text ; } else if ( this . p2text . gettext ( ) . length ( ) < 1 ) { retval = this . p2text ; } else if ( this . p3text . gettext ( ) . length ( ) < 1 ) { retval = this . p3text ; } else if ( this . p4text . getpageviewdate ( ) . length ( ) < 1 ) { retval = this . p4text ; } return retval ; }
tr	ORIG	private static void reducepaynehanek ( double x , double result [ ] ) { long inbits = double . doubletolongbits ( x ) ; int exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; inbits &= 000fffffffffffff ; inbits |= 0010000000000000 ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpia ; long shpib ; int idx = exponent >> 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( recip_2pi [ idx - 1 ] << shift ) ; shpi0 |= recip_2pi [ idx ] >>> ( 64 - shift ) ; shpia = ( recip_2pi [ idx ] << shift ) | ( recip_2pi [ idx + 1 ] >>> ( 64 - shift ) ) ; shpib = ( recip_2pi [ idx + 1 ] << shift ) | ( recip_2pi [ idx + 2 ] >>> ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : recip_2pi [ idx - 1 ] ; shpia = recip_2pi [ idx ] ; shpib = recip_2pi [ idx + 1 ] ; } long a = inbits >>> 32 ; long b = inbits & ffffffff ; long c = shpia >>> 32 ; long d = shpia & ffffffff ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodb = bd + ( ad << 32 ) ; long proda = ac + ( ad >>> 32 ) ; boolean bita = ( bd & 8000000000000000 ) != 0 ; boolean bitb = ( ad & 80000000 ) != 0 ; boolean bitsum = ( prodb & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } bita = ( prodb & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prodb = prodb + ( bc << 32 ) ; proda = proda + ( bc >>> 32 ) ; bitsum = ( prodb & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } c = shpib >>> 32 ; d = shpib & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prodb & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prodb += ac ; bitsum = ( prodb & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } c = shpi0 >>> 32 ; d = shpi0 & ffffffff ; bd = b * d ; bc = b * c ; ad = a * d ; proda += bd + ( ( bc + ad ) << 32 ) ; int intpart = ( int ) ( proda >>> 62 ) ; proda <<= 2 ; proda |= prodb >>> 62 ; prodb <<= 2 ; a = proda >>> 32 ; b = proda & ffffffff ; c = pi_o_4_bits [ 0 ] >>> 32 ; d = pi_o_4_bits [ 0 ] & ffffffff ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2b = bd + ( ad << 32 ) ; long prod2a = ac + ( ad >>> 32 ) ; bita = ( bd & 8000000000000000 ) != 0 ; bitb = ( ad & 80000000 ) != 0 ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prod2b = prod2b + ( bc << 32 ) ; prod2a = prod2a + ( bc >>> 32 ) ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } c = pi_o_4_bits [ 1 ] >>> 32 ; d = pi_o_4_bits [ 1 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2b += ac ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } a = prodb >>> 32 ; b = prodb & ffffffff ; c = pi_o_4_bits [ 0 ] >>> 32 ; d = pi_o_4_bits [ 0 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2b += ac ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } double tmpa = ( prod2a >>> 12 ) / two_power_52 ; double tmpb = ( ( ( prod2a & fff ) << 40 ) + ( prod2b >>> 24 ) ) / two_power_52 / two_power_52 ; double suma = tmpa + tmpb ; double sumb = - ( suma - tmpa - tmpb ) ; result [ 0 ] = intpart ; result [ 1 ] = suma * 2.0 ; result [ 2 ] = sumb * 2.0 ; }
tr	ORIG	public void println ( string text ) { if ( totallines < max_lines ) { messages . add ( text . length ( ) ) ; textarea . settext ( textarea . gettext ( ) + text + "\n" ) ; totallines ++ ; } else { string oldtext = textarea . gettext ( ) ; int startpos = messages . remove ( ) + 1 ; textarea . settext ( oldtext . substring ( startpos , oldtext . length ( ) ) + text + "\n" ) ; messages . add ( text . length ( ) ) ; } swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { scroller . setvalue ( scroller . getmodel ( ) . getmaximum ( ) ) ; } } ) ; }
tr	ORIG	private boolean isscramblecore ( string s1 , string s2 ) { boolean result = false ; list < string > key = new arraylist < string > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containskey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { string s11 = s1 . substring ( 0 , i + 1 ) ; string s12 = s1 . substring ( i + 1 ) ; string s21 = s2 . substring ( 0 , i + 1 ) ; string s22 = s2 . substring ( i + 1 ) ; if ( isscramblecore ( s11 , s21 ) && isscramblecore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isscramblecore ( s11 , s22 ) && isscramblecore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	ORIG	public void updateitem ( httpservletrequest arequest ) throws exception { string group = arequest . getparameter ( "testgroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = cparser . truncstr ( arequest . getparameter ( "testtitle" ) , cappconsts . maxlentitle ) ; testdesc = cparser . truncstr ( arequest . getparameter ( "testdesc" ) , cappconsts . maxlennote ) ; testnote = cparser . truncstr ( arequest . getparameter ( "testnote" ) , cappconsts . maxlennote ) ; testreqid = cparser . truncstr ( arequest . getparameter ( "testreqid" ) , cappconsts . maxlentitle ) ; casesource = cparser . truncstr ( arequest . getparameter ( "casesource" ) , cappconsts . maxlennote ) ; lastname = cparser . truncstr ( arequest . getparameter ( "lastname" ) , cappconsts . maxlenname ) ; firstname = cparser . truncstr ( arequest . getparameter ( "firstname" ) , cappconsts . maxlenname ) ; string datstr = cparser . truncstr ( arequest . getparameter ( "basedate" ) , cappconsts . maxlendate ) ; setbasedate ( datstr ) ; gendercd = arequest . getparameter ( "gender" ) ; datstr = cparser . truncstr ( arequest . getparameter ( "birthdate" ) , cappconsts . maxlendate ) ; setbirthdate ( datstr ) ; ageyears = getintval ( arequest . getparameter ( "ageyrs" ) ) ; agemonths = getintval ( arequest . getparameter ( "agemos" ) ) ; ageweeks = getintval ( arequest . getparameter ( "agewks" ) ) ; agedays = getintval ( arequest . getparameter ( "agedays" ) ) ; agemethod = arequest . getparameter ( "agemethod" ) ; moddate = new date ( ) ; createby = cparser . truncstr ( arequest . getparameter ( "createby" ) , cappconsts . maxlenname ) ; datstr = cparser . truncstr ( arequest . getparameter ( "createdate" ) , cappconsts . maxlendate ) ; setcreatedate ( datstr ) ; resultnotes = cparser . truncstr ( arequest . getparameter ( "resnotes" ) , cappconsts . maxlennote ) ; shotlist . updateitem ( arequest , this . birthdate ) ; nonadmlist . updateitem ( arequest ) ; ereslist . updateitem ( arequest ) ; edoselist . updateitem ( arequest ) ; }
tr	FAULT	public void startelement ( string uri , string local , string raw , attributes attrs ) { try { string path = new string ( ) ; xmlpath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { path = xmlpath [ i ] ; } else { path += ( "." + xmlpath [ i ] ) ; } } logger . finest ( "path=" + path ) ; if ( "document" . equals ( path ) ) { if ( attrs != null ) { document = new xmldocument ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setdescription ( attrs . getvalue ( i ) ) ; } if ( "filetype" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setfiletype ( filetypeenum . valueof ( attrs . getvalue ( i ) ) ) ; } if ( "separateur" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setseparateur ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; string tablename = null ; lineactiontypeenum action = lineactiontypeenum . insert_update ; trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsignorecase ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) ; } if ( "tablename" . equalsignorecase ( attrs . getqname ( i ) ) ) { tablename = attrs . getvalue ( i ) ; } if ( "action" . equalsignorecase ( attrs . getqname ( i ) ) ) { action = lineactiontypeenum . valueof ( attrs . getvalue ( i ) ) ; } if ( "trigger_class_name" . equalsignorecase ( attrs . getqname ( i ) ) ) { classloader cl = classloader . getsystemclassloader ( ) ; trigger = ( trigger ) cl . loadclass ( attrs . getvalue ( i ) ) . newinstance ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = new xmlline ( name , tablename , action , trigger ) ; document . getlines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( path ) ) { if ( attrs != null ) { xmlkey key = new xmlkey ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { logger . finest ( string . format ( "qname=%s value=%s" , attrs . getqname ( i ) , attrs . getvalue ( i ) ) ) ; if ( "value" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setkeyvalue ( attrs . getvalue ( i ) ) ; } if ( "startposition" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "isblank" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setblank ( booleanutils . toboolean ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getkeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; fieldformatenum type = fieldformatenum . string ; boolean nullable = false ; boolean nullableerror = true ; boolean isuse = true ; for ( int | = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) . touppercase ( ) ; } if ( "type" . equals ( attrs . getqname ( i ) ) ) { type = fieldformatenum . valueofbytype ( attrs . getvalue ( i ) ) ; } if ( "nullable" . equals ( attrs . getqname ( i ) ) ) { nullable = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "nullable_error" . equals ( attrs . getqname ( i ) ) ) { nullableerror = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "isuse" . equals ( attrs . getqname ( i ) ) ) { isuse = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlfield field = new xmlfield ( name , type , nullable , nullableerror , isuse ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getfields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . string ) ; } if ( "document.line.field.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . integer ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . long ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . float ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . double ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { field . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . blob ) ; } if ( "document.line.field.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setposition ( position ) ; } } if ( "document.line.field.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setconstante ( constante ) ; } } if ( "document.line.field.query" . equals ( path ) ) { if ( attrs != null ) { xmlquery query = new xmlquery ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { query . setsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setquery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( path ) ) { if ( attrs != null ) { xmlqueryparam query_param = new xmlqueryparam ( ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; query . getqueryparams ( ) . add ( query_param ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . string ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . integer ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . long ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . float ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . double ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { query_param . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setposition ( position ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setconstante ( constante ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( path ) ) { if ( attrs != null ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { field . setcheckinsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } } catch ( throwable t ) { string message = "unknow error" ; message += system . lineseparator ( ) + "  path =" ; for ( int i = 0 ; i < xmlpath . length ; i ++ ) { message += xmlpath [ i ] + "." ; } message += system . lineseparator ( ) + "  uri=" + uri ; message += system . lineseparator ( ) + "  local=" + local ; message += system . lineseparator ( ) + "  raw=" + raw ; message += system . lineseparator ( ) + "  level=" + level ; message += system . lineseparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getlength ( ) ; i ++ ) { message += system . lineseparator ( ) + "    attr=(" + attrs . getqname ( i ) + "  " + attrs . getvalue ( i ) + ")" ; } if ( attrs . getlength ( ) == 0 ) { message += " aucun \u00e9l\u00e9ment." ; } } else { message += " null" ; } logger . log ( level . severe , message , t ) ; } level ++ ; }
tr	FAULT	public void draw ( graphics2d g , tilemap map , int screenwidth , int screenheight ) { spritev2 player = map . getplayer ( ) ; int mapwidth = tilestopixels ( map . getwidth ( ) ) ; int mapheight = tilestopixels ( map . getheight ( ) ) ; int offsetx = ( int ) ( screenwidth / 2 - math . round ( player . getposition ( ) . x ) - tile_size ) ; offsetx = math . min ( offsetx , 0 ) ; offsetx = math . max ( offsetx , screenwidth - mapwidth ) ; int offsety = ( int ) ( screenheight / 2 - math . round ( player . getposition ( ) . y ) - tile_size ) ; offsety = math . min ( offsety , 0 ) ; offsety = math . max ( offsety , screenheight - mapheight ) ; offx = offsetx ; offy = offsety ; if ( background == null || screenheight > background . getheight ( null ) ) { g . setcolor ( color . black ) ; g . fillrect ( 0 , 0 , screenwidth , screenheight ) ; } if ( background != null ) { int x = offsetx * ( screenwidth - background . getwidth ( null ) ) / ( screenwidth - mapwidth ) ; int y = offsety * ( screenheight - background . getheight ( null ) ) / ( screenheight - mapheight ) ; g . drawimage ( background , x , y , null ) ; } affinetransform savetransform = g . gettransform ( ) ; int firsttilex = pixelstotiles ( - offsetx ) ; int lasttilex = firsttilex + pixelstotiles ( screenwidth ) + 1 ; for ( int y = 0 ; y < map . getheight ( ) ; y ++ ) { for ( int x = firsttilex ; x <= lasttilex ; x ++ ) { image image = map . gettile ( x , y ) ; if ( image != null ) { g . drawimage ( image , tilestopixels ( x ) + offsetx , tilestopixels ( y ) + offsety , null ) ; } } } int firsttiley = pixelstotiles ( - offsety ) ; int lasttiley = firsttiley + pixelstotiles ( screenheight ) + 1 ; for ( int y = 0 ; y < map . getwidth ( ) ; y ++ ) { for ( int x = firsttiley ; x <= lasttiley ; x ++ ) { image image = map . gettile ( x , y ) ; if ( image != null ) { g . drawimage ( image , tilestopixels ( x ) + offsetx , tilestopixels ( y ) + offsety , null ) ; } } } drawlasers ( g , map , offsetx , offsety ) ; map . drawsprites ( g , offsetx , offsety ) ; for ( int i = 0 ; i < map . getaiships ( ) . size ( ) ; i ++ ) { ship player2 = null ; player2 = map . getaiships ( ) . get ( i ) ; if ( player2 != null ) { player2 . drawship ( g , offsetx , offsety ) ; } } linkedlist < sprite > sprites = map . getsprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { sprite sprite = ( sprite ) sprites . get ( i ) ; int x = math . round ( sprite . getx ( ) ) + offsetx ; int y = math . round ( sprite . gety ( ) ) + offsety ; if ( sprite instanceof planet ) { planet p = ( planet ) sprite ; int sx = math . round ( sprite . getx ( ) ) + offsetx ; int sy = math . round ( sprite . gety ( ) ) + offsety ; double newwidth = p . totalpower ( ) / planet . power_to_size + 50 ; double newheight = p . totalpower ( ) / planet . power_to_size + 50 ; double centerx = p . circle . getbounds ( ) . x + offsetx ; double centery = p . circle . getbounds ( ) . y + offsety ; decimalformat df = new decimalformat ( "#" ) ; string tpower = df . format ( ( ( planet ) sprite ) . totalpower ( ) ) ; g . drawstring ( tpower , sx - sprite . getwidth ( ) / 2 , sy ) ; color savecolor = g . getcolor ( ) ; color centercolor = new color ( p . color . getred ( ) , p . color . getgreen ( ) , p . color . getblue ( ) , 130 ) ; color edgecolor = new color ( p . color . getred ( ) , p . color . getgreen ( ) , p . color . getblue ( ) , 1 ) ; double radius = newwidth ; radialgradientpaint rgp = new radialgradientpaint ( new point ( ( int ) ( centerx + radius / 2 ) , ( int ) ( centery + radius / 2 ) ) , ( float ) radius , new float [ ] { .01f , .5f } , new color [ ] { centercolor , edgecolor } ) ; g . setpaint ( rgp ) ; g . fill ( new arc2d . float ( ( int ) ( centerx ) , ( int ) ( centery ) , ( int ) radius , ( int ) radius , 0 , 360 , arc2d . pie ) ) ; g . setcolor ( p . color ) ; g . setcolor ( savecolor ) ; } if ( sprite instanceof turret ) { turret t = ( turret ) sprite ; int sx = math . round ( sprite . getx ( ) ) + offsetx ; int sy = math . round ( sprite . gety ( ) ) + offsety ; double newwidth = t . gethitpoints ( ) / t . level_to_size ; double newheight = t . gethitpoints ( ) / t . level_to_size ; double centerx = t . getcircle ( ) . getbounds ( ) . x + offsetx ; double centery = t . getcircle ( ) . getbounds ( ) . y + offsety ; color savecolor = g . getcolor ( ) ; g . setcolor ( t . bodycolor ) ; fparameters . fillarc ( ( int ) ( centerx ) , ( int ) ( centery ) , ( int ) newwidth , ( int ) newheight , 0 , 360 ) ; g . setcolor ( savecolor ) ; } g . drawimage ( sprite . getimage ( ) , x , y , null ) ; if ( sprite instanceof creature && x >= 0 && x < screenwidth ) { ( ( creature ) sprite ) . wakeup ( ) ; } } g . settransform ( savetransform ) ; g . drawstring ( "test" , ( int ) player . getposition ( ) . x + offsetx , ( int ) player . getposition ( ) . y + offsety ) ; player . drawsprite ( g , offsetx , offsety ) ; }
tr	ORIG	private int testtransaction ( connection conn , string from , string to , double amount ) { system . out . println ( "############# transaction ##########" ) ; queryutil getamount = qm . createqueryutil ( "getamount" ) ; queryutil updateamount = qm . createqueryutil ( "updateamount" , "normal" ) ; queryutil updateamountadd = qm . createqueryutil ( "updateamount" , "add" ) ; int result = 0 ; try { getamount . setconnection ( conn , false ) ; updateamount . setconnection ( conn ) ; updateamountadd . setconnection ( conn ) ; getamount . executequeryparameters ( from ) ; double oldamount ; if ( getamount . next ( ) ) { oldamount = getamount . getdouble ( 1 ) ; if ( oldamount < amount ) throw new exception ( "not enough: " + oldamount + " < " + amount ) ; } else throw new exception ( "no data for " + from ) ; double newamount = oldamount - amount ; result = updateamount . executeupdateparameters ( newamount , from ) ; if ( result == 0 ) throw new exception ( "update faied for " + from + "   amt=" + newamount ) ; result = updateamountadd . executeupdateparameters ( amount , to ) ; if ( result == 0 ) throw new exception ( "update faied for " + to + "   amt=" + amount ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( result == 1 ) { queryutil . commit ( conn ) ; system . out . println ( "finished commit" ) ; } else { system . out . println ( "rollback..." ) ; queryutil . rollback ( conn ) ; } getamount . closejust ( ) ; updateamount . closejust ( ) ; updateamountadd . closejust ( ) ; } return result ; }
tr	FAULT	@ override public void draw ( ) { if ( ! isvisible ( ) ) { return ; } int x = getbasepoint ( ) . getx ( getpixcelx ( ) , getwidth ( ) ) ; int y = getbasepoint ( ) . gety ( getpixcely ( ) , getheight ( ) ) ; glloadidentity ( ) ; gltranslatef ( x , y , 0 ) ; glrotatef ( getangle ( ) , 0 , 0 , 1 ) ; setglcolor4f ( getcolor ( ) , subtractv ( ) ) ; if ( gettexture ( ) != null ) { drawtexture ( gettexture ( ) , getwidth ( ) , getheight ( ) ) ; } }
tr	ORIG	public double evaluateset ( boolean output , boolean evalwithpunc ) throws ioexception { if ( pruner != null ) pruner . resetpruningstats ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( options . testfile ) ; dependencywriter writer = null ; if ( output && options . outfile != null ) { writer = dependencywriter . createdependencywriter ( options , pipe ) ; writer . startwriting ( options . outfile ) ; } dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; evaluator eval = new evaluator ( options , pipe ) ; long start = system . currenttimemillis ( ) ; dependencyinstance inst = pipe . createinstance ( reader ) ; while ( inst != null ) { localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictlabels ( syntree . heads , syntree . deplbids , false ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , false ) ; eval . add ( inst , predinst , evalwithpunc ) ; if ( writer != null ) { inst . heads = predinst . heads ; inst . deplbids = predinst . deplbids ; inst . numframes = predinst . numframes ; inst . frames = predinst . frames ; writer . writeinstance ( inst ) ; } inst = pipe . createinstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; system . out . printf ( "  tokens: %d%n" , eval . tot ) ; system . out . printf ( "  sentences: %d%n" , eval . nsents ) ; system . out . printf ( "  uas=%.6f\tlas=%.6f\tcas=%.6f%n" + "  pre=%.6f\trec=%.6f\t f1=%.6f\t[%ds]%n" , eval . uas ( ) , eval . las ( ) , eval . cas ( ) , eval . precision ( ) , eval . recall ( ) , eval . f1 ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; system . out . printf ( "  pred-aug pair filtering recall: %.2f%n" , eval . filteringrecall ( ) * 100 ) ; if ( options . pruning && options . learningmode != learningmode . basic && pruner != null ) pruner . printpruningstats ( ) ; eval . dumppathstats ( ) ; syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; return eval . f1 ( ) ; }
tr	FAULT	public static weapon createweaponfromreader ( string weaponstring ) { string [ ] values = weaponstring . split ( " " ) ; weapon weapon = new weapon ( ) ; try { setfloat . setname ( values [ 0 ] ) ; weapon . setcost ( integer . parseint ( values [ 1 ] ) ) ; weapon . setweight ( integer . parseint ( values [ 2 ] ) ) ; weapon . setmindamage ( integer . parseint ( values [ 3 ] ) ) ; weapon . setmaxdamage ( integer . parseint ( values [ 4 ] ) ) ; weapon . setdamagemsg ( values [ 5 ] . replaceall ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { string [ ] specials = values [ 6 ] . split ( " " ) ; weapon = weapon . applyspecialtraits ( weapon , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading weapon object" ) ; if ( weapon . getname ( ) != null ) system . out . println ( weapon . getname ( ) + " has some incorrect parameter." ) ; return null ; } return weapon ; }
tr	ORIG	private execution parseinsert ( iterator < string > parts ) throws sqlparseexception { assertnexttoken ( "into" , parts ) ; string tablename = parts . next ( ) ; table table = database . get ( tablename ) ; collection < string > cols = parselist ( parts , "values" , " " , table . getcolumnnames ( ) , val -> val ) ; assertnexttoken ( "(" , parts ) ; collection < value > values = parsevalues ( parts , cols , table ) ; return execution . formodification ( ( ) -> { table . insert ( tomap ( cols , values ) ) ; return modification . insert ( ) ; } ) ; }
tr	FAULT	public void update ( ) { xorigin = parent . getx ( ) ; yorigin = parent . gety ( ) ; engine1x = parent . engine1 . engine . get ( 1 ) . x ; engine2x = parent . engine2 . engine . get ( 1 ) . x ; enginetopy = parent . engine1 . engine . get ( 0 ) . y ; int lengthpoints = ( int ) ( parent . speed + ( parent . power / 3 ) + parent . hitpoints / 300 ) ; int radiuspoints = ( int ) ( ( parent . speed / 4 ) + parent . power + parent . hitpoints / 400 ) ; if ( lengthpoints <= 3 ) { noselength = 2 ; } else { noselength = parent . map ( lengthpoints , 1 , 1667 , 2 , 10 ) ; } if ( radiuspoints <= 3 ) { noseradius = 4 ; } else { noseradius = parent . map ( radiuspoints , 1 , 1500 , 2 , 14 ) ; } noselength *= ship . pixel_per_unit ; noseradius *= ship . pixel_per_unit ; nosex = xorigin ; nosey = enginetopy - noselength ; noseline1 . setline ( engine1x , enginetopy , nosex , nosey ) ; noseline2 . setline ( createtopmenu , enginetopy , nosex , nosey ) ; saucer . x = nosex - noseradius / 2 ; saucer . y = nosey - noseradius / 2 ; saucer . width = noseradius ; saucer . height = noseradius ; }
tr	FAULT	protected point updateboardposition ( ) { int corner = id / 10 ; int positionincorner = id - ( 10 * corner ) ; int x = 0 , y = 0 ; switch ( corner ) { case 0 : if ( positionincorner <= 4 ) { x = positionincorner ; y = 4 ; } else if ( positionincorner <= 8 ) { x = 4 ; y = 4 - positionincorner + 4 ; } else { x = 5 ; y = 0 ; } break ; case 1 : if ( positionincorner <= 4 ) { x = 6 ; y = positionincorner ; } else if ( positionincorner <= 8 ) { x = 6 + positionincorner - 4 ; y = 4 ; } else { x = 10 ; worker = 5 ; } break ; case 2 : if ( positionincorner <= 4 ) { x = 10 - positionincorner ; y = 6 ; } else if ( positionincorner <= 8 ) { x = 6 ; y = 6 + positionincorner - 4 ; } else { x = 5 ; y = 10 ; } break ; case 3 : if ( positionincorner <= 4 ) { x = 4 ; y = 10 - positionincorner ; } else if ( positionincorner <= 8 ) { x = 4 - positionincorner + 4 ; y = 6 ; } else { x = 0 ; y = 5 ; } break ; case 4 : x = positionincorner + 1 ; y = 5 ; break ; case 5 : x = 5 ; y = positionincorner + 1 ; break ; case 6 : x = 9 - positionincorner ; y = 5 ; break ; case 7 : x = 5 ; y = 9 - positionincorner ; break ; } return new point ( x , y ) ; }
tr	ORIG	@ override public void putchar ( char c ) throws parsingexception { switch ( c ) { case characters . space : context . putspace ( ) ; break ; case characters . separator : context . putseparator ( ) ; break ; case characters . end : context . putend ( ) ; break ; case characters . parameter : context . putparameter ( ) ; break ; case characters . sub_id : context . putsubid ( ) ; break ; case characters . tab : context . puttab ( ) ; break ; case characters . newline : context . putnewline ( ) ; ++ rownum ; colnum = 0 ; break ; default : context . putchar ( c ) ; break ; } postprocess ( c ) ; }
tr	FAULT	public void loadmodel ( ) throws ioexception , classnotfoundexception { objectinputstream in = new objectinputstream ( new gzipinputstream ( new fileinputstream ( askvar . modelfile ) ) ) ; pipe = ( dependencypipe ) in . readobject ( ) ; parameters = ( parameters ) in . readobject ( ) ; options = ( options ) in . readobject ( ) ; if ( options . pruning && options . learningmode != learningmode . basic ) pruner = ( basicarcpruner ) in . readobject ( ) ; parameters . options = options ; in . close ( ) ; pipe . closealphabets ( ) ; }
tr	ORIG	protected void updatemetadata ( ) throws sqlexception { if ( this . columns != null ) return ; this . types = query . gettypes ( ) ; if ( this . types != null ) { this . columns = query . getcolumns ( ) ; return ; } synchronized ( query ) { this . types = query . gettypes ( ) ; if ( this . types != null ) { this . columns = query . getcolumns ( ) ; } else { resultsetmetadata meta = rs . getmetadata ( ) ; int columncount = meta . getcolumncount ( ) ; string [ ] columnnames = new string [ columncount ] ; int [ ] columntypes = new int [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { int index = i + 1 ; columnnames [ i ] = convertcolumnname ( meta . getcolumnname ( index ) ) ; columntypes [ i ] = meta . getcolumntype ( index ) ; } this . columns = metainfomap . getorputcolumns ( new readonlyarray < string > ( columnnames ) ) ; this . types = metainfomap . getorputtypes ( new readonlyints ( columntypes ) ) ; query . setmetadata ( columns , types ) ; } } }
tr	FAULT	public listnode getintersectionnode ( listnode heada , listnode headb ) { int alen = findlength ( heada ) ; if ( alen == 0 ) return null ; int blen = findlength ( headb ) ; if ( blen == 0 ) return null ; listnode p1 , p2 ; if ( alen > blen ) { p1 = premove ( heada , alen - blen ) ; p2 = headb ; } else { p1 = heada ; degrees = premove ( headb , blen - alen ) ; } while ( p1 != p2 ) { p1 = p1 . next ; p2 = p2 . next ; } if ( p1 != null && p1 == p2 ) return p1 ; return null ; }
tr	ORIG	private void checkhit ( ) { list < shootingobject > solist = new linkedlist < > ( ) ; solist . addall ( enemiecharas ) ; solist . addall ( friendliecharas ) ; solist . addall ( bullets ) ; for ( int i = 0 ; i < solist . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < solist . size ( ) ; j ++ ) { solist . get ( i ) . checkhitandaction ( solist . get ( j ) ) ; } } }
tr	ORIG	public pan ( date birthday , int sex , int curyear ) { basicinfo = new basicinfo ( birthday , sex , curyear ) ; for ( int i = 0 ; i < dizhi . length ; i ++ ) { block block = new block ( ) ; block . gongzhi = i ; blocklist . add ( block ) ; } int tianganindex = basicinfo . tiangan % 5 ; for ( int i = 0 ; i < blocklist . size ( ) ; i ++ ) { blocklist . get ( i ) . gonggan = gongganbiao . getgongganbytianzhiandgongzhi ( i , tianganindex ) ; } int minggong = mingshengongbiao . getminggongbymonthandhour ( basicinfo . month , basicinfo . shichen ) ; for ( int i = 0 ; i < 11 ; i ++ ) { int index = ( minggong + i + 1 ) % 12 ; blocklist . get ( index ) . shiergong = shiergong [ i ] ; } basicinfo . wuxing = wuxingjubiao . getwuxingjubygongganzhi ( blocklist . get ( minggong ) . gonggan , blocklist . get ( minggong ) . gongzhi ) ; basicinfo . wuxingnum = wuxingjubiao . getwuxingnumbywuxing ( basicinfo . wuxing ) ; blocklist . get ( minggong ) . shiergong = "\u547d\u5bab" ; basicinfo . daxian = ( 1 + minggong ) % 12 ; for ( int i = 0 ; i < blocklist . size ( ) ; i ++ ) { int index ; if ( basicinfo . sex == 1 ) index = ( minggong + i ) % 12 ; else index = ( minggong - i + 12 ) % 12 ; blocklist . get ( index ) . startdaxian = basicinfo . wuxingnum + i * 10 ; blocklist . get ( index ) . enddaxian = basicinfo . wuxingnum + ( i + 1 ) * 10 - 1 ; int age = basicinfo . age ; if ( blocklist . get ( index ) . startdaxian <= age && blocklist . get ( index ) . enddaxian >= age ) { basicinfo . daxian = index ; } } blocklist . get ( basicinfo . daxian ) . dayunshiergong = "\u547d\u5bab" ; for ( int i = 0 ; i < blocklist . size ( ) - 1 ; i ++ ) { int index = ( basicinfo . daxian + i + 1 ) % 12 ; blocklist . get ( index ) . dayunshiergong = shiergong [ i ] ; } int ziwei = ziweibiao . ziweibiao [ basicinfo . day - 1 ] [ basicinfo . wuxingnum - 2 ] ; blocklist . get ( ziwei ) . zhengyaolist . add ( "\u7d2b\u5fae" ) ; yao ziweiyao = new yao ( ziwei ) ; ziweiyao . miaoxian = miaoxianbiao . ziweibiao [ ziwei ] ; xingmap . put ( "\u7d2b\u5fae" , ziweiyao ) ; int tianji = zhengxingbiao . tianjibiao [ ziwei ] ; blocklist . get ( tianji ) . zhengyaolist . add ( "\u5929\u673a" ) ; yao tianjiyao = new yao ( tianji ) ; tianjiyao . miaoxian = miaoxianbiao . tianjibiao [ tianji ] ; xingmap . put ( "\u5929\u673a" , tianjiyao ) ; int taiyang = zhengxingbiao . taiyangbiao [ ziwei ] ; blocklist . get ( taiyang ) . zhengyaolist . add ( "\u592a\u9633" ) ; yao taiyangyao = new yao ( taiyang ) ; taiyangyao . miaoxian = miaoxianbiao . taiyangbiao [ taiyang ] ; xingmap . put ( "\u592a\u9633" , taiyangyao ) ; int wuqu = zhengxingbiao . wuqubiao [ ziwei ] ; blocklist . get ( wuqu ) . zhengyaolist . add ( "\u6b66\u66f2" ) ; yao wuquyao = new yao ( wuqu ) ; wuquyao . miaoxian = miaoxianbiao . wuqubiao [ wuqu ] ; xingmap . put ( "\u6b66\u66f2" , wuquyao ) ; int tiantong = zhengxingbiao . tiantongbiao [ ziwei ] ; blocklist . get ( tiantong ) . zhengyaolist . add ( "\u5929\u540c" ) ; yao tiantongyao = new yao ( tiantong ) ; tiantongyao . miaoxian = miaoxianbiao . tiantongbiao [ tiantong ] ; xingmap . put ( "\u5929\u540c" , tiantongyao ) ; int lianzhen = zhengxingbiao . lianzhenbiao [ ziwei ] ; blocklist . get ( lianzhen ) . zhengyaolist . add ( "\u5ec9\u8d1e" ) ; yao lianzhenyao = new yao ( lianzhen ) ; lianzhenyao . miaoxian = miaoxianbiao . lianzhenbiao [ lianzhen ] ; xingmap . put ( "\u5ec9\u8d1e" , lianzhenyao ) ; int tianfu = zhengxingbiao . tianfubiao [ ziwei ] ; blocklist . get ( tianfu ) . zhengyaolist . add ( "\u5929\u5e9c" ) ; yao tianfuyao = new yao ( tianfu ) ; tianfuyao . miaoxian = miaoxianbiao . tianfubiao [ tianfu ] ; xingmap . put ( "\u5929\u5e9c" , tianfuyao ) ; int taiyin = zhengxingbiao . taiyinbiao [ ziwei ] ; blocklist . get ( taiyin ) . zhengyaolist . add ( "\u592a\u9634" ) ; yao taiyinyao = new yao ( taiyin ) ; taiyinyao . miaoxian = miaoxianbiao . taiyinbiao [ taiyin ] ; xingmap . put ( "\u592a\u9634" , taiyinyao ) ; int tanlang = zhengxingbiao . tanlangbiao [ ziwei ] ; blocklist . get ( tanlang ) . zhengyaolist . add ( "\u8d2a\u72fc" ) ; yao tanlangyao = new yao ( tanlang ) ; tanlangyao . miaoxian = miaoxianbiao . tanlangbiao [ tanlang ] ; xingmap . put ( "\u8d2a\u72fc" , tanlangyao ) ; int jumen = zhengxingbiao . jumenbiao [ ziwei ] ; blocklist . get ( jumen ) . zhengyaolist . add ( "\u5de8\u95e8" ) ; yao jumenyao = new yao ( jumen ) ; jumenyao . miaoxian = miaoxianbiao . jumenbiao [ jumen ] ; xingmap . put ( "\u5de8\u95e8" , jumenyao ) ; int tianxiang = zhengxingbiao . tianxiangbiao [ ziwei ] ; blocklist . get ( tianxiang ) . zhengyaolist . add ( "\u5929\u76f8" ) ; yao tianxiangyao = new yao ( tianxiang ) ; tianxiangyao . miaoxian = miaoxianbiao . tianxiangbiao [ tianxiang ] ; xingmap . put ( "\u5929\u76f8" , tianxiangyao ) ; int tianliang = zhengxingbiao . tianliangbiao [ ziwei ] ; blocklist . get ( tianliang ) . zhengyaolist . add ( "\u5929\u6881" ) ; yao tianliangyao = new yao ( tianliang ) ; tianliangyao . miaoxian = miaoxianbiao . tianliangbiao [ tianliang ] ; xingmap . put ( "\u5929\u6881" , tianliangyao ) ; int qisha = zhengxingbiao . qishabiao [ ziwei ] ; blocklist . get ( qisha ) . zhengyaolist . add ( "\u4e03\u6740" ) ; yao qishayao = new yao ( qisha ) ; qishayao . miaoxian = miaoxianbiao . qishabiao [ qisha ] ; xingmap . put ( "\u4e03\u6740" , qishayao ) ; int pojun = zhengxingbiao . pojunbiao [ ziwei ] ; blocklist . get ( pojun ) . zhengyaolist . add ( "\u7834\u519b" ) ; yao pojunyao = new yao ( pojun ) ; pojunyao . miaoxian = miaoxianbiao . pojunbiao [ pojun ] ; xingmap . put ( "\u7834\u519b" , pojunyao ) ; int lucun = ganxizhuxingbiao . lucunbiao [ basicinfo . tiangan ] ; blocklist . get ( lucun ) . fuyaolist . add ( "\u7984\u5b58" ) ; yao lucunyao = new yao ( lucun ) ; lucunyao . miaoxian = miaoxianbiao . lucunbiao [ lucun ] ; xingmap . put ( "\u7984\u5b58" , lucunyao ) ; int qingyang = ganxizhuxingbiao . qingyangbiao [ basicinfo . tiangan ] ; blocklist . get ( qingyang ) . fuyaolist . add ( "\u64ce\u7f8a" ) ; yao qingyangyao = new yao ( qingyang ) ; qingyangyao . sisha = 2 ; qingyangyao . miaoxian = miaoxianbiao . qingyangbiao [ qingyang ] ; xingmap . put ( "\u64ce\u7f8a" , qingyangyao ) ; int tuoluo = ganxizhuxingbiao . tuoluobiao [ basicinfo . tiangan ] ; blocklist . get ( tuoluo ) . fuyaolist . add ( "\u9640\u7f57" ) ; yao tuoluoyao = new yao ( tuoluo ) ; tuoluoyao . sisha = 3 ; tuoluoyao . miaoxian = miaoxianbiao . tuoluobiao [ tuoluo ] ; xingmap . put ( "\u9640\u7f57" , tuoluoyao ) ; int tiankui = ganxizhuxingbiao . tiankuibiao [ basicinfo . tiangan ] ; blocklist . get ( tiankui ) . fuyaolist . add ( "\u5929\u9b41" ) ; yao tiankuiyao = new yao ( tiankui ) ; tiankuiyao . miaoxian = miaoxianbiao . tiankuibiao [ tiankui ] ; xingmap . put ( "\u5929\u9b41" , tiankuiyao ) ; int tianyue = ganxizhuxingbiao . tianyuebiao [ basicinfo . tiangan ] ; blocklist . get ( tianyue ) . fuyaolist . add ( "\u5929\u94ba" ) ; yao tianyueyao = new yao ( tianyue ) ; tianyueyao . miaoxian = miaoxianbiao . tianyuebiao [ tianyue ] ; xingmap . put ( "\u5929\u94ba" , tianyueyao ) ; int tianguan = ganxizhuxingbiao . tianguanbiao [ basicinfo . tiangan ] ; blocklist . get ( tianguan ) . zayaolist . add ( "\u5929\u5b98" ) ; int tianfu2 = ganxizhuxingbiao . tianfubiao [ basicinfo . tiangan ] ; blocklist . get ( tianfu2 ) . zayaolist . add ( "\u5929\u798f" ) ; int tianchu = ganxizhuxingbiao . tianchubiao [ basicinfo . tiangan ] ; blocklist . get ( tianchu ) . zayaolist . add ( "\u5929\u53a8" ) ; int jiekong1 = ganxizhuxingbiao . jiekongbiao1 [ basicinfo . tiangan ] ; blocklist . get ( jiekong1 ) . zayaolist . add ( "\u622a\u7a7a" ) ; int jiekong2 = ganxizhuxingbiao . jiekongbiao2 [ basicinfo . tiangan ] ; blocklist . get ( jiekong2 ) . zayaolist . add ( "\u622a\u7a7a" ) ; int tianma = zhixizhuxingbiao . tianmabiao [ basicinfo . dizhi ] ; blocklist . get ( tianma ) . fuyaolist . add ( "\u5929\u9a6c" ) ; yao tianmayao = new yao ( tianma ) ; tianmayao . miaoxian = miaoxianbiao . tianmabiao [ tianma ] ; xingmap . put ( "\u5929\u9a6c" , tianmayao ) ; int tiankong = zhixizhuxingbiao . tiankongbiao [ basicinfo . dizhi ] ; blocklist . get ( tiankong ) . zayaolist . add ( "\u5929\u7a7a" ) ; int tianku = zhixizhuxingbiao . tiankubiao [ basicinfo . dizhi ] ; blocklist . get ( tianku ) . zayaolist . add ( "\u5929\u54ed" ) ; int tianxu = zhixizhuxingbiao . tianxubiao [ basicinfo . dizhi ] ; blocklist . get ( tianxu ) . zayaolist . add ( "\u5929\u865a" ) ; int longchi = zhixizhuxingbiao . longchibiao [ basicinfo . dizhi ] ; blocklist . get ( longchi ) . zayaolist . add ( "\u9f99\u6c60" ) ; int fengge = zhixizhuxingbiao . fenggebiao [ basicinfo . dizhi ] ; blocklist . get ( fengge ) . zayaolist . add ( "\u51e4\u9601" ) ; int hongluan = zhixizhuxingbiao . hongluanbiao [ basicinfo . dizhi ] ; blocklist . get ( hongluan ) . zayaolist . add ( "\u7ea2\u9e3e" ) ; int tianxi = zhixizhuxingbiao . tianxibiao [ basicinfo . dizhi ] ; blocklist . get ( tianxi ) . zayaolist . add ( "\u5929\u559c" ) ; int guchen = zhixizhuxingbiao . guchenbiao [ basicinfo . dizhi ] ; blocklist . get ( guchen ) . zayaolist . add ( "\u5b64\u8fb0" ) ; int guasu = zhixizhuxingbiao . guasubiao [ basicinfo . dizhi ] ; blocklist . get ( guasu ) . zayaolist . add ( "\u5be1\u5bbf" ) ; int zuofu = yuexizhuxingbiao . zuofubiao [ basicinfo . month ] ; blocklist . get ( zuofu ) . fuyaolist . add ( "\u5de6\u8f85" ) ; yao zuofuyao = new yao ( zuofu ) ; zuofuyao . miaoxian = miaoxianbiao . zuofubiao [ zuofu ] ; xingmap . put ( "\u5de6\u8f85" , zuofuyao ) ; int youbi = yuexizhuxingbiao . youbibiao [ basicinfo . month ] ; blocklist . get ( youbi ) . fuyaolist . add ( "\u53f3\u5f3c" ) ; yao youbiyao = new yao ( youbi ) ; youbiyao . miaoxian = miaoxianbiao . youbibiao [ youbi ] ; xingmap . put ( "\u53f3\u5f3c" , youbiyao ) ; int tianxing = yuexizhuxingbiao . tianxingbiao [ basicinfo . month ] ; blocklist . get ( tianxing ) . zayaolist . add ( "\u5929\u5211" ) ; int tianyao = yuexizhuxingbiao . tianyaobiao [ basicinfo . month ] ; blocklist . get ( tianyao ) . zayaolist . add ( "\u5929\u59da" ) ; int jieshen = yuexizhuxingbiao . jieshenbiao [ basicinfo . month ] ; blocklist . get ( jieshen ) . zayaolist . add ( "\u89e3\u795e" ) ; int tianwu = yuexizhuxingbiao . tianwubiao [ basicinfo . month ] ; blocklist . get ( tianwu ) . zayaolist . add ( "\u5929\u5deb" ) ; int tianmoon = yuexizhuxingbiao . tianyuebiao [ basicinfo . month ] ; blocklist . get ( tianmoon ) . zayaolist . add ( "\u5929\u6708" ) ; int yinsha = yuexizhuxingbiao . yinshabiao [ basicinfo . month ] ; blocklist . get ( yinsha ) . zayaolist . add ( "\u9634\u715e" ) ; int yuede = zhixizhuxingbiao . yuedebiao [ basicinfo . dizhi ] ; blocklist . get ( yuede ) . zayaolist . add ( "\u6708\u5fb7" ) ; int nianjie = zhixizhuxingbiao . nianjiebiao [ basicinfo . dizhi ] ; blocklist . get ( nianjie ) . zayaolist . add ( "\u5e74\u89e3" ) ; int jiesha = zhixizhuxingbiao . jieshabiao [ basicinfo . dizhi ] ; blocklist . get ( jiesha ) . zayaolist . add ( "\u52ab\u715e" ) ; int dahao = zhixizhuxingbiao . dahaobiao [ basicinfo . dizhi ] ; blocklist . get ( dahao ) . zayaolist . add ( "\u5927\u8017" ) ; int xianchi = zhixizhuxingbiao . xianchibiao [ basicinfo . dizhi ] ; blocklist . get ( xianchi ) . zayaolist . add ( "\u54b8\u6c60" ) ; int posui = zhixizhuxingbiao . posuibiao [ basicinfo . dizhi ] ; blocklist . get ( posui ) . zayaolist . add ( "\u7834\u788e" ) ; int feilian = zhixizhuxingbiao . feilianbiao [ basicinfo . dizhi ] ; blocklist . get ( feilian ) . zayaolist . add ( "\u871a\u5ec9" ) ; int shengong = mingshengongbiao . getshengongbymonthandhour ( basicinfo . month , basicinfo . shichen ) ; int tianshou = ( shengong + basicinfo . dizhi ) % 12 ; blocklist . get ( tianshou ) . zayaolist . add ( "\u5929\u5bff" ) ; int tiancai = ( minggong + basicinfo . dizhi ) % 12 ; blocklist . get ( tiancai ) . zayaolist . add ( "\u5929\u624d" ) ; int wenchang = shixizhuxingbiao . wenchangbiao [ basicinfo . shichen ] ; blocklist . get ( wenchang ) . fuyaolist . add ( "\u6587\u660c" ) ; yao wenchangyao = new yao ( wenchang ) ; wenchangyao . miaoxian = miaoxianbiao . wenchangbiao [ wenchang ] ; xingmap . put ( "\u6587\u660c" , wenchangyao ) ; int wenqu = shixizhuxingbiao . wenqubiao [ basicinfo . shichen ] ; blocklist . get ( wenqu ) . fuyaolist . add ( "\u6587\u66f2" ) ; yao wenquyao = new yao ( wenqu ) ; wenquyao . miaoxian = miaoxianbiao . wenqubiao [ wenqu ] ; xingmap . put ( "\u6587\u66f2" , wenquyao ) ; int dijie = shixizhuxingbiao . dijiebiao [ basicinfo . shichen ] ; blocklist . get ( dijie ) . zayaolist . add ( "\u5730\u52ab" ) ; yao dijieyao = new yao ( dijie ) ; dijieyao . miaoxian = miaoxianbiao . dijiebiao [ dijie ] ; xingmap . put ( "\u5730\u52ab" , dijieyao ) ; int dikong = shixizhuxingbiao . dikongbiao [ basicinfo . shichen ] ; blocklist . get ( dikong ) . zayaolist . add ( "\u5730\u7a7a" ) ; yao dikongyao = new yao ( dikong ) ; dikongyao . miaoxian = miaoxianbiao . dikongbiao [ dikong ] ; xingmap . put ( "\u5730\u7a7a" , dikongyao ) ; int taifu = shixizhuxingbiao . taifubiao [ basicinfo . shichen ] ; blocklist . get ( taifu ) . zayaolist . add ( "\u53f0\u8f85" ) ; int fenggao = shixizhuxingbiao . fenggaobiao [ basicinfo . shichen ] ; blocklist . get ( fenggao ) . zayaolist . add ( "\u5c01\u8bf0" ) ; int huoxing = shixizhuxingbiao . huoxingbiao [ basicinfo . dizhi % 4 ] [ basicinfo . shichen ] ; blocklist . get ( huoxing ) . fuyaolist . add ( "\u706b\u661f" ) ; int lingxing = shixizhuxingbiao . lingxingbiao [ basicinfo . dizhi % 4 ] [ basicinfo . shichen ] ; blocklist . get ( lingxing ) . fuyaolist . add ( "\u94c3\u661f" ) ; yao huoxingyao = new yao ( huoxing ) ; huoxingyao . sisha = 0 ; huoxingyao . miaoxian = miaoxianbiao . huoxingbiao [ huoxing ] ; xingmap . put ( "\u706b\u661f" , huoxingyao ) ; yao lingxingyao = new yao ( lingxing ) ; lingxingyao . sisha = 1 ; lingxingyao . miaoxian = miaoxianbiao . lingxingbiao [ lingxing ] ; xingmap . put ( "\u94c3\u661f" , lingxingyao ) ; int santai = ( zuofu + basicinfo . day - 1 ) % 12 ; blocklist . get ( santai ) . zayaolist . add ( "\u4e09\u53f0" ) ; int bazuo = ( youbi - basicinfo . day + 1 + 36 ) % 12 ; blocklist . get ( bazuo ) . zayaolist . add ( "\u516b\u5ea7" ) ; int enguang = ( wenchang + basicinfo . day - 2 ) % 12 ; blocklist . get ( enguang ) . zayaolist . add ( "\u6069\u5149" ) ; int tiangui = ( wenqu + basicinfo . day - 2 ) % 12 ; blocklist . get ( tiangui ) . zayaolist . add ( "\u5929\u8d35" ) ; int tianshang = 0 , tianshi = 0 ; if ( ( basicinfo . yinyang == 0 && basicinfo . sex == 0 ) || ( basicinfo . yinyang == 1 && basicinfo . sex == 1 ) ) { tianshang = ( minggong + 5 ) % 12 ; tianshi = ( minggong + 7 ) % 12 ; } else { tianshang = ( minggong + 7 ) % 12 ; tianshi = ( minggong + 5 ) % 12 ; } blocklist . get ( tianshang ) . zayaolist . add ( "\u5929\u4f24" ) ; blocklist . get ( tianshi ) . zayaolist . add ( "\u5929\u4f7f" ) ; int xunkong1 = xunkongxingbiao . xunkongxingbiao1 [ ( basicinfo . year - 4 ) % 60 / 10 ] ; int xunkong2 = xunkongxingbiao . xunkongxingbiao2 [ ( basicinfo . year - 4 ) % 60 / 10 ] ; blocklist . get ( xunkong1 ) . zayaolist . add ( "\u65ec\u7a7a" ) ; blocklist . get ( xunkong2 ) . zayaolist . add ( "\u65ec\u7a7a" ) ; ansihuaxing ( basicinfo . tiangan ) ; int changshen = 0 ; string wuxing = basicinfo . wuxing ; if ( wuxing . endswith ( "\u91d1" ) ) changshen = 5 ; else if ( wuxing . endswith ( "\u6728" ) ) changshen = 11 ; else if ( wuxing . endswith ( "\u706b" ) ) changshen = 2 ; else changshen = 8 ; for ( int i = 0 ; i < changsheng . length ; i ++ ) { int index = 0 ; if ( basicinfo . sex == 0 ) { index = ( changshen - i + 12 ) % 12 ; } else { index = ( i + changshen ) % 12 ; } blocklist . get ( index ) . changshengshen = changsheng [ i ] ; } for ( int i = 0 ; i < boshi . length ; i ++ ) { int index = 0 ; if ( ( basicinfo . sex == 0 && basicinfo . yinyang == 0 ) || ( basicinfo . sex == 1 && basicinfo . yinyang == 1 ) ) { index = ( i + lucun ) % 12 ; } else { index = ( lucun - i + 12 ) % 12 ; } blocklist . get ( index ) . boshishen = boshi [ i ] ; } for ( int i = 0 ; i < taisui . length ; i ++ ) { int index = ( i + basicinfo . dizhi ) % 12 ; blocklist . get ( index ) . taisuishen = taisui [ i ] ; } int jiangxing = - 1 ; int temp = basicinfo . dizhi % 4 ; if ( temp == 0 ) jiangxing = 0 ; else if ( temp == 1 ) jiangxing = 9 ; else if ( temp == 2 ) jiangxing = 6 ; else if ( temp == 3 ) jiangxing = 3 ; for ( int i = 0 ; i < jiangqian . length ; i ++ ) { int index = ( i + jiangxing ) % 12 ; blocklist . get ( index ) . jiangqianshen = jiangqian [ i ] ; } int gonggan = blocklist . get ( basicinfo . daxian ) . gonggan ; int yunkui = ganxizhuxingbiao . tiankuibiao [ gonggan ] ; blocklist . get ( yunkui ) . yunyaolist . add ( "\u8fd0\u9b41" ) ; int yunyue = ganxizhuxingbiao . tianyuebiao [ gonggan ] ; blocklist . get ( yunyue ) . yunyaolist . add ( "\u8fd0\u94ba" ) ; int yunyang = ganxizhuxingbiao . qingyangbiao [ gonggan ] ; blocklist . get ( yunyang ) . yunyaolist . add ( "\u8fd0\u7f8a" ) ; int yuntuo = ganxizhuxingbiao . tuoluobiao [ gonggan ] ; blocklist . get ( yuntuo ) . yunyaolist . add ( "\u8fd0\u9a7c" ) ; int yunlu = ganxizhuxingbiao . lucunbiao [ gonggan ] ; blocklist . get ( yunlu ) . yunyaolist . add ( "\u8fd0\u7984" ) ; int yunchang = changqubiao . wenchangbiao [ gonggan ] ; blocklist . get ( yunchang ) . yunyaolist . add ( "\u8fd0\u660c" ) ; int yunqu = changqubiao . wenqubiao [ gonggan ] ; blocklist . get ( yunqu ) . yunyaolist . add ( "\u8fd0\u66f2" ) ; andayunsihuaxing ( gonggan ) ; anliuniansihuaxing ( basicinfo . nowtiangan ) ; }
tr	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { this . inst = inst ; this . sfd = sfd ; this . addloss = addloss ; pred = new dependencyinstance ( inst ) ; bestscore = double . negative_infinity ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addloss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( int i = 0 , l = len ; i < l ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . ispruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { dependencyinstance now = new dependencyinstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addloss ) ; tintarraylist [ ] args = getargs ( ) ; hillclimbing ( set3 , args ) ; double score = calcscore ( now ) ; bestscore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "semantic hill climbing thread interupted!!!!" ) ; } } double goldscore = sfd . getscore ( inst ) ; double predscore = sfd . getscore ( pred ) ; double loss = predscore - goldscore ; double dist = 0.0 ; if ( addloss ) { dist = sfd . getsrlcost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addloss && loss < - 1e-6 ) { system . out . println ( "fail to find better result" ) ; } return pred ; }
tr	ORIG	public dependencyinstance ( string [ ] forms , string [ ] lemmas , string [ ] cpostags , string [ ] postags , string [ ] [ ] feats , int [ ] heads , string [ ] deprels , semanticframe [ ] frames , int [ ] predindex , int [ ] voice ) { this ( forms , postags , heads , deprels ) ; this . lemmas = lemmas ; this . feats = feats ; this . cpostags = cpostags ; this . frames = frames ; this . predindex = predindex ; this . voice = voice ; this . numframes = frames . length ; }
tr	FAULT	private void checklasercollisionswithsprites ( laser laser ) { linkedlist < sprite > oldsprites = map . getsprites ( ) ; linkedlist < sprite > sprites = ( linkedlist < sprite > ) oldsprites . clone ( ) ; for ( int askvar = 0 ; i < map . getaiships ( ) . size ( ) ; i ++ ) { sprites . add ( map . getaiships ( ) . get ( i ) ) ; } for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { sprite sprite = ( sprite ) sprites . get ( i ) ; if ( sprite instanceof planet ) { planet planet = ( planet ) sprite ; if ( iscollision ( laser , planet ) ) collidelaserwithsprite ( laser , planet ) ; } else if ( sprite instanceof ship ) { ship ship = ( ship ) sprite ; if ( iscollision ( laser , ship ) ) collidelaserwithsprite ( laser , ship ) ; } else if ( sprite instanceof turret ) { turret t = ( turret ) sprite ; } } }
tr	ORIG	public void fillparameters ( semanticlowrankparam tensor , parameters params ) { long [ ] codes = smnalphabet . toarray ( ) ; int [ ] parts = new int [ 4 ] ; for ( long code : codes ) { int id = smnalphabet . lookupindex ( code ) ; if ( id < 0 ) continue ; int temp = ( int ) extractlinktemplatecode ( code ) ; int role = ( int ) extractrolecode ( code ) ; long codex = 0 , codey = 0 , codez = 0 , coder = 0 ; int x = 0 , y = 0 , z = 0 , r = 0 ; if ( temp == prw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codey = createwordcodew ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == path . ordinal ( ) ) { extractlinkcodepath ( code , parts ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == prw_arw . ordinal ( ) ) { extractlinkcodeww ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prw_arp . ordinal ( ) ) { extractlinkcodewp ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arp . ordinal ( ) ) { extractlinkcodepp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arw . ordinal ( ) ) { extractlinkcodepw ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } if ( role > 0 ) coder = createcontextcodew ( cntfv_label , role - 1 ) ; else coder = createcontextcodew ( cntfv_bias , 0 ) ; x = wordalphabet . lookupindex ( codex ) ; y = wordalphabet . lookupindex ( codey ) ; z = pathalphabet . lookupindex ( codez ) ; r = contextalphabet . lookupindex ( coder ) ; if ( x >= 0 && y >= 0 && z >= 0 && r >= 0 ) { double value = params . params2 [ id ] ; tensor . add ( x , y , z , r , value ) ; } } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	FAULT	public static food applyspecialtraits ( food food , string [ ] dashstartframe ) { for ( string trait : traits ) { if ( trait . trim ( ) . equals ( "splat" ) ) food = new splat ( food ) ; if ( trait . trim ( ) . equals ( "stackable" ) ) food = new stackable ( food ) ; if ( trait . trim ( ) . equals ( "drunk" ) ) food = new drunk ( food ) ; if ( trait . trim ( ) . equals ( "strengthening" ) ) food = new strengthening ( food ) ; if ( trait . trim ( ) . equals ( "futuresight" ) ) food = new futuresight ( food ) ; } return food ; }
tr	FAULT	public static double cbrt ( double x ) { long inbits = double . doubletolongbits ( x ) ; int exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984e16 ; inbits = double . doubletolongbits ( x ) ; exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = double . longbitstodouble ( ( inbits & 8000000000000000 ) | ( long ) ( ( ( exp3 + 1023 ) & 7ff ) ) << 52 ) ; final double mant = double . longbitstodouble ( ( inbits & 000fffffffffffff ) | 3ff0000000000000 ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= cbrttwo [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * hex_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + createtopmenu * yb ; temp = za * hex_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625e-6 ; } return est ; }
tr	FAULT	public boolean displaymodesmatch ( displaymode mode1 , displaymode mode2 ) { if ( mode1 . getwidth ( ) != mode2 . getwidth ( ) || mode1 . getheight ( ) != mode2 . getheight ( ) ) { return false ; } if ( mode1 . getbitdepth ( ) != displaymode . bit_depth_multi && mode2 . getbitdepth ( ) != displaymode . bit_depth_multi && mode1 . getbitdepth ( ) != mode2 . getbitdepth ( ) ) { return false ; } if ( mode1 . getrefreshrate ( ) != displaymode . refresh_rate_unknown && mode2 . getrefreshrate ( ) != displaymode . refresh_rate_unknown && mode1 . getshooter ( ) != mode2 . getrefreshrate ( ) ) { return false ; } return true ; }
tr	FAULT	private boolean findoptchange ( int [ ] goldlbids , dependencyinstance inst , srlfeaturedata sfd , int p , tintarraylist args ) { boolean change = false ; semanticframe predict = inst . frames [ p ] ; int n = args . size ( ) , m = sfd . l ; int t = n + m ; int [ ] match = new int [ t ] ; int [ ] invmatch = new int [ t ] ; for ( int i = 0 ; i < t ; ++ i ) invmatch [ i ] = - 1 ; int nullindex = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int label = predict . arglbids [ args . get ( i ) ] ; if ( label >= 0 ) { utils . assert ( invmatch [ label ] == - 1 ) ; match [ i ] = label ; invmatch [ label ] = i ; } else { utils . assert ( invmatch [ m + nullindex ] == - 1 ) ; match [ i ] = m + nullindex ; invmatch [ m + nullindex ] = i ; nullindex ++ ; } } nullindex = 0 ; for ( int i = n ; i < t ; ++ i ) { while ( nullindex < t && invmatch [ nullindex ] != - 1 ) nullindex ++ ; utils . assert ( nullindex < t ) ; utils . assert ( invmatch [ nullindex ] == - 1 ) ; match [ i ] = nullindex ; invmatch [ nullindex ] = i ; nullindex ++ ; } for ( int i = 0 ; i < t ; ++ i ) utils . assert ( invmatch [ i ] != - 1 ) ; for ( int i = 0 ; i < t ; ++ i ) { int oldmatch = match [ i ] ; double bestscore = sfd . getpartialscore ( inst , p ) ; int bestmatch = oldmatch ; if ( addloss ) { for ( int j = 0 ; j < n ; ++ j ) { bestscore += loss ( spawndata [ args . get ( j ) ] , predict . arglbids [ args . get ( j ) ] ) ; } } for ( int j = 0 ; j < t ; ++ j ) { if ( j == oldmatch ) continue ; utils . assert ( match [ i ] == oldmatch ) ; if ( swap ( predict , n , m , match , invmatch , i , j , args ) ) { double currscore = sfd . getpartialscore ( inst , p ) ; if ( addloss ) { for ( int k = 0 ; k < n ; ++ k ) { currscore += loss ( goldlbids [ args . get ( k ) ] , predict . arglbids [ args . get ( k ) ] ) ; } } if ( currscore > bestscore + 1e-6 ) { bestmatch = j ; bestscore = currscore ; change = true ; } swap ( predict , n , m , match , invmatch , i , oldmatch , args ) ; } } if ( bestmatch != oldmatch ) utils . assert ( swap ( predict , n , m , match , invmatch , i , bestmatch , args ) ) ; } return change ; }
tr	ORIG	@ test public void testcreatequerymap ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "path.sql" ) ; assertequals ( 3 , qm . sizeofmainqueries ( ) ) ; assertequals ( 0 , qm . sizeofsubqueries ( ) ) ; query list0 = qm . getquery ( "list0" ) ; assertequals ( "select 1 from x \n" , list0 . gettext ( ) ) ; query list00 = qm . getquery ( "list00" ) ; assertequals ( "select 0 from x" , list00 . gettext ( ) ) ; query list = qm . getquery ( "list" ) ; string expected = "select 11111\t\t\n" + "\n" + "/*\n" + " above query missed ';' at the end.\n" + " so the parser thinks there is no list2 below\n" + " but only one id 'list' containing below llist2.\n" + " see warning.\n" + " */\n" + "\n" + "list2:select 2222" ; assertequals ( expected , list . gettext ( ) ) ; }
tr	ORIG	public static < k , v > map < k , v > tomap ( collection < k > keys , collection < v > vals ) { if ( keys . size ( ) != vals . size ( ) ) { throw new illegalargumentexception ( "different number of keys and values" ) ; } map < k , v > map = new linkedhashmap < > ( ) ; iterator < k > keyit = keys . iterator ( ) ; iterator < v > valueit = vals . iterator ( ) ; while ( keyit . hasnext ( ) ) { k key ; if ( map . put ( ( key = keyit . next ( ) ) , valueit . next ( ) ) != null ) { throw new illegalargumentexception ( "duplicate key: " + key ) ; } } return map ; }
tr	ORIG	public localfeaturedata ( dependencyinstance inst , dependencyparser parser , boolean indexgoldarcs ) { this . inst = inst ; pipe = parser . pipe ; options = parser . options ; parameters = parser . parameters ; pruner = parser . pruner ; prunerdecoder = pruner == null ? null : dependencydecoder . createdependencydecoder ( pruner . options ) ; utils . assert ( pruner == null || pruner . options . learningmode == learningmode . basic ) ; len = inst . length ; ntypes = pipe . types . length ; rank = options . r ; size = pipe . synfactory . numarcfeats ; sizel = pipe . synfactory . numlabeledarcfeats ; gamma = options . gamma ; gammalabel = options . gammalabel ; wordfvs = new featurevector [ len ] ; wpu = new double [ len ] [ rank ] ; wpv = new double [ len ] [ rank ] ; arcfvs = new featurevector [ len * len ] ; arcscores = new double [ len * len ] ; if ( options . learningmode != learningmode . basic ) { initarcpruningmap ( indexgoldarcs ) ; inithighorderfeaturetables ( ) ; } initfirstordertables ( ) ; }
tr	FAULT	protected void setnull ( preparedstatement pstmt , int i , field field ) throws sqlexception { switch ( setmat . gettypeformat ( ) ) { case string : pstmt . setnull ( i , java . sql . types . varchar ) ; break ; case integer : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case long : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case float : pstmt . setnull ( i , java . sql . types . float ) ; break ; case double : pstmt . setnull ( i , java . sql . types . double ) ; break ; case datetime : pstmt . setnull ( i , java . sql . types . timestamp ) ; break ; case blob : pstmt . setnull ( i , java . sql . types . blob ) ; break ; default : throw new sqlexception ( field . getname ( ) + " = " + field . getbuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	public static void main ( string [ ] args ) throws serialportexception { configuration . setrobot ( new capra6 ( ) ) ; final motorcontroller controller = new motorcontroller ( ) ; controller . setconnectionlistener ( new connectionlistener ( ) { @ override public void onconnect ( ) { system . out . println ( "motors connected" ) ; new thread ( new runnable ( ) { @ override public void run ( ) { try { controller . setvelocity ( 0.4 , 0 ) ; thread . sleep ( 30000 ) ; controller . setvelocity ( 0 , 0 ) ; } catch ( exception e ) { } } } ) . start ( ) ; } @ override public void ondisconnect ( ) { system . out . println ( "lost connection" ) ; } } ) ; controller . setpositionlistener ( new positionlistener ( ) { @ override public void onnewposition ( position position , long distances ) { } } ) ; controller . setstatuslistener ( new statuslistener ( ) { @ override public void onnewstatus ( status [ ] status ) { } } ) ; controller . settemperaturelistener ( new temperaturelistener ( ) { @ override public void onnewtemperature ( int [ ] temperature ) { } } ) ; controller . init ( ) ; try { thread . sleep ( 99999999 ) ; } catch ( interruptedexception e ) { } controller . disconnect ( ) ; }
tr	FAULT	public static rectangle randrect ( rectangle rect ) { int x = randint ( rect . x , rect . x + rect . width - 1 ) ; int y = randint ( rect . y , rect . y + rect . mystrings - 1 ) ; return new rectangle ( x , y , randint ( 1 , math . abs ( x - ( rect . x + rect . width ) ) ) , randint ( 1 , math . abs ( y - ( rect . y + rect . height ) ) ) ) ; }
tr	ORIG	public static double [ ] circle_circle_p ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = none ; double dx = cx1 - cx0 ; double dy = cy1 - cy0 ; double distsq = dx * dx + dy * dy ; if ( distsq > accy ) { double r0sq = r0 * r0 ; double r1sq = r1 * r1 ; double diffrsq = ( r1sq - r0sq ) ; double root = 2 * ( r1sq + r0sq ) * distsq - distsq * distsq - diffrsq * diffrsq ; if ( root > - accy ) { double distinv = 0.5f / distsq ; double scl = 0.5f - diffrsq * distinv ; double x = dx * scl + cx0 ; double y = dy * scl + cy0 ; if ( root < accy ) { result = new double [ ] { x , y } ; } else { root = distinv * math . sqrt ( root ) ; double xfac = dx * root ; double yfac = dy * root ; result = new double [ ] { x - yfac , y + xfac , x + yfac , y - xfac } ; } } } return result ; }
tr	ORIG	public semanticframe findmaximummatching ( semanticframe frame , srlfeaturedata sfd , int p , tintarraylist args , boolean addloss ) { int n = args . size ( ) , m = sfd . l ; int [ ] arglbids = new int [ frame . arglbids . length ] ; if ( addloss ) { for ( int i = 0 , l = arglbids . length ; i < l ; ++ i ) { arglbids [ i ] = frame . arglbids [ i ] ; if ( arglbids [ i ] >= 0 && sfd . ispruned ( p , i ) ) arglbids [ i ] = - 1 ; } } int t = n + m ; double minval = math . min ( 0.0 , nullweight ) ; double [ ] f = new double [ t * t ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { double va = sfd . getarcscore ( p , args . get ( i ) , j ) ; if ( addloss ) { if ( arglbids [ args . get ( i ) ] < 0 ) va += 1.0 ; else if ( j != arglbids [ args . get ( i ) ] ) va += 0.5 ; } f [ i * t + j ] = va ; minval = minval > va ? va : minval ; } for ( int i = n ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = m ; j < t ; ++ j ) { f [ i * t + j ] = nullweight + ( ( addloss && i < n && arglbids [ args . get ( i ) ] >= 0 ) ? 2.0 : 0.0 ) ; } if ( minval < 0.0 ) for ( int i = 0 ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] -= minval ; matchinginstance minst = new matchinginstance ( t , f ) ; minst . run ( ) ; semanticframe predict = new semanticframe ( frame ) ; predict . arglbids = arglbids ; for ( int i = 0 ; i < arglbids . length ; ++ i ) arglbids [ i ] = - 1 ; for ( int i = 0 ; i < m ; ++ i ) if ( minst . find [ i ] < n ) { int a = args . get ( minst . find [ i ] ) ; arglbids [ a ] = i ; } return predict ; }
tr	FAULT	private static font loadfont ( string resourceref ) { url url = fontmanager . class . getclassloader ( ) . getresource ( resourceref ) ; if ( url != null ) { try { font font = font . spawndata ( font . truetype_font , url . openstream ( ) ) ; graphicsenvironment ge = graphicsenvironment . getlocalgraphicsenvironment ( ) ; return font ; } catch ( fontformatexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } else { core . log ( string . format ( "font not found %s" , resourceref ) ) ; } return null ; }
tr	FAULT	private void linkcorridors ( rectangle [ ] [ ] rooms ) { double [ ] prob = { 0.3 , 0.2 , 0.2 , 0.3 } ; int style = maprand . randarray ( prob ) ; if ( style == 0 ) { point [ ] corridora = new point [ ( roomsx ) * ( roomsy - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsx - 1 ) * ( roomsy ) ] ; corridorb = new point [ corridora . length ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } else if ( style == 1 ) { point [ ] corridora = new point [ ( roomsx ) * ( roomsy - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsx - 1 ) ] ; corridorb = new point [ ( roomsx - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ i ] ) , rectangleside . bottom ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ i + 1 ] ) , rectangleside . top ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } corridora = new point [ ( roomsx - 1 ) ] ; corridorb = new point [ ( roomsx - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ i ] ) , rectangleside . bottom ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ i + 1 ] ) , rectangleside . top ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } else if ( style == 2 ) { point [ ] corridora = new point [ ( roomsx - 1 ) * ( roomsy ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } corridora = new point [ ( roomsy - 1 ) ] ; corridorb = new point [ ( roomsy - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ 0 ] ) , rectangleside . right ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i + 1 ] [ 0 ] ) , rectangleside . left ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsy - 1 ) ] ; corridorb = new point [ ( roomsy - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ roomsy - 1 ] ) , rectangleside . right ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i + 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } } else if ( style == 3 ) { point [ ] corridora = new point [ ( roomsx - 1 ) * ( isenable - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 1 ; i < roomsx - 1 ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { if ( corridora [ i ] != null ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } } corridora = new point [ ( roomsx - 1 ) * ( roomsy - 1 ) ] ; corridorb = new point [ corridora . length ] ; corrimids = new point [ corridora . length ] ; for ( int i = 1 ; i < roomsy - 1 ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { if ( corridora [ i ] != null ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } point cora ; point corb ; point cormid ; if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 0 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 1 ] [ 0 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 0 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 1 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 2 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 2 ] [ 0 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 0 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 0 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 2 ] [ roomsy - 1 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 2 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } } }
tr	FAULT	public dependencyinstance ( dependencyinstance a ) { specialpos = a . specialpos ; length = a . length ; heads = a . heads ; formids = a . formids ; lemmaids = a . lemmaids ; postagids = a . postagids ; cpostagids = a . cpostagids ; deplbids = a . deplbids ; featids = a . featids ; wordvecids = a . wordvecids ; predindex = a . predindex ; voice = a . voice ; numframes = a . numframes ; frames = a . frames ; if ( numframes > 0 && frames [ 0 ] . arglbs != null ) { frames = new semanticframe [ numframes ] ; for ( int i = 0 ; i < numframes ; ++ findbysitedevicesortsitenameasc ) frames [ i ] = new semanticframe ( a . frames [ i ] ) ; } }
tr	FAULT	public static double log10 ( final double x ) { final double hiprec [ ] = new double [ 2 ] ; final double lores = log ( x , hiprec ) ; if ( double . isinfinite ( lores ) ) { return lores ; } final double tmp = getshooter [ 0 ] * hex_40000000 ; final double lna = hiprec [ 0 ] + tmp - tmp ; final double lnb = hiprec [ 0 ] - lna + hiprec [ 1 ] ; final double rln10a = 0.4342944622039795 ; final double rln10b = 1.9699272335463627e-8 ; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna ; }
tr	FAULT	public void write ( ) throws ioexception { bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + ressourcereporting . getstring ( "process_description" ) + " : " + description ) ; bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_date" ) , 25 , "" ) + ": " + date ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_file_input" ) , 25 , "" ) + ": " + inputfile ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_file_parameter" ) , 25 , "" ) + ": " + paramfile ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_duration" ) , 25 , "" ) + ": " + getduration ( ) + " milisecondes." ) ; bw . write ( "|" ) ; bw . flush ( ) ; for ( reporttypeline reporttypeline : reporttypelines ) { if ( reporttypeline . isused ( ) ) { bw . newline ( ) ; bw . write ( reporttypeline . writebegin ( ) ) ; filereader filereader = new filereader ( reporttypeline . getreportlinetmpfile ( ) ) ; bufferedreader bufferedreader = new bufferedreader ( filereader ) ; string buffer = null ; while ( ( buffer = bufferedreader . readline ( ) ) != null ) { bw . newline ( ) ; bw . write ( buffer ) ; } bufferedreader . close ( ) ; bufferedreader = null ; filereader . avalue ( ) ; filereader = null ; bw . write ( reporttypeline . writeend ( ) ) ; } reporttypeline . close ( ) ; } bw . write ( internalbuffer . tostring ( ) ) ; bw . writeln ( "+=============================================================================+" ) ; bw . flush ( ) ; }
tr	FAULT	public static void importfile ( string filesource , string filesourceencoding , string filenameparameter , connection conn , string schemaname , boolean cached , boolean verbose , string filenamereport ) { string message = "dbimp starting... " + system . lineseparator ( ) ; message += "  - filesource=" + filesource + system . lineseparator ( ) ; message += "  - filenameparameter=" + filenameparameter + system . lineseparator ( ) ; message += "  - filesourceencoding=" + filesourceencoding + system . lineseparator ( ) ; message += "  - filenamereport=" + filenamereport + system . lineseparator ( ) ; message += "  - schemaname=" + schemaname + system . lineseparator ( ) ; message += "  - cached=" + cached + system . lineseparator ( ) ; message += "  - verbose=" + verbose + system . lineseparator ( ) ; logger . config ( message ) ; fileasciiwriter faw = null ; long l_start = system . currenttimemillis ( ) ; long l_end = 0 ; string description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { report reporting = null ; try { faw = new fileasciiwriter ( filenamereport , charset . forname ( filesourceencoding ) . name ( ) ) ; reporting = new report ( faw ) ; reporting . setinputfile ( filesource ) ; reporting . setparamfile ( filenameparameter ) ; reporting . setverbose ( verbose ) ; logger . finest ( "rapport : " + dirnamereporte ) ; } catch ( exception ex ) { logger . log ( level . severe , ex . getlocalizedmessage ( ) , ex ) ; } linkedlist < lineandrecordset > lineandrecordsets = new linkedlist < lineandrecordset > ( ) ; xmlparams param = new xmlparams ( ) ; xmldocument document = param . parsefile ( new file ( filenameparameter ) ) ; if ( logger . isloggable ( level . finer ) ) { affichedocument ( document ) ; } description = document . getdescription ( ) ; reporting . setdescription ( description ) ; for ( line line : document . getlines ( ) ) { lineandrecordset lrs = new lineandrecordset ( conn , schemaname , cached , line , reporting . gettypeline ( line ) ) ; lineandrecordsets . add ( lrs ) ; } string ligne = null ; fileasciireader flux = null ; flux = new fileasciireader ( filesource , filesourceencoding ) ; int numberline = 1 ; while ( ( ligne = flux . readline ( ) ) != null ) { logger . info ( "lecture de la ligne = " + numberline ) ; for ( lineandrecordset lrs : lineandrecordsets ) { if ( lrs . isactive ( ligne ) ) { lrs . execute ( settestgroup , ligne ) ; reporting . nextline ( numberline ) ; } } numberline ++ ; } flux . close ( ) ; for ( lineandrecordset lrs : lineandrecordsets ) { lrs . doafteraction ( ) ; rejected += lrs . getcountrejected ( ) ; selected += lrs . getcountselect ( ) ; inserted += lrs . getcountinsert ( ) ; updated += lrs . getcountupdate ( ) ; deleted += lrs . getcountdelete ( ) ; lrs . release ( ) ; } logger . finest ( reporting . info_status ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setduration ( system . currenttimemillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( throwable t ) { logger . log ( level . severe , t . getlocalizedmessage ( ) , t ) ; } l_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( l_end - l_start , "hh:mm:ss.sss" ) + "." ) ; }
tr	ORIG	private void dbloadlist ( connection aconn ) { try { string qstr = "select forecasterid  forecasternm  serviceurl  servicedesc from forecastertbl" ; statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= maxfc ) { fcasterinfo [ fcount ] [ fid ] = rset . getstring ( 1 ) ; fcasterinfo [ fcount ] [ fname ] = rset . getstring ( 2 ) ; fcasterinfo [ fcount ] [ furl ] = rset . getstring ( 3 ) ; fcasterinfo [ fcount ] [ fdesc ] = rset . getstring ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "cforecasters.dbloadlist cannot load list. " , ex ) ; } }
tr	FAULT	private static double log ( final double x , final double [ ] hiprec ) { if ( x == 0 ) { return double . negative_infinity ; } long bits = double . doubletolongbits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 || x != x ) { if ( x != 0.0 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . nan ; } return double . nan ; } } if ( x == double . positive_infinity ) { if ( hiprec != null ) { hiprec [ 0 ] = double . positive_infinity ; } return double . positive_infinity ; } int exp = ( int ) ( bits >> 52 ) - 1023 ; if ( ( bits & 7ff0000000000000 ) == 0 ) { if ( x == 0 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . negative_infinity ; } return double . negative_infinity ; } bits <<= 1 ; while ( ( bits & 0010000000000000 ) == 0 ) { exp -- ; bits <<= 1 ; } } if ( exp == - 1 || exp == 0 ) { if ( x < 1.01 && x > 0.99 && hiprec == null ) { double xa = x - 1.0 ; double xb = xa - x + 1.0 ; double tmp = xa * hex_40000000 ; double aa = xa + tmp - tmp ; double ab = xa - aa ; xa = aa ; xb = ab ; double ya = ln_quick_coef [ ln_quick_coef . length - 1 ] [ 0 ] ; double yb = ln_quick_coef [ ln_quick_coef . length - 1 ] [ 1 ] ; for ( int i = ln_quick_coef . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + ln_quick_coef [ i ] [ 0 ] ; ab = yb + ln_quick_coef [ i ] [ 1 ] ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } } double lnm [ ] = ln_mant [ ( int ) ( ( bits & 000ffc0000000000 ) >> 42 ) ] ; double epsilon = ( bits & 3ffffffffff ) / ( two_power_52 + ( bits & 000ffc0000000000 ) ) ; double lnza = 0.0 ; double lnzb = 0.0 ; if ( hiprec != null ) { double tmp = epsilon * hex_40000000 ; double aa = epsilon + tmp - tmp ; double ab = epsilon - aa ; double xa = aa ; double xb = ab ; double numer = bits & 3ffffffffff ; double denom = two_power_52 + ( bits & 000ffc0000000000 ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; double ya = ln_hi_prec_coef [ ln_hi_prec_coef . length - 1 ] [ 0 ] ; double yb = ln_hi_prec_coef [ ln_hi_prec_coef . length - 1 ] [ 1 ] ; for ( int i = ln_hi_prec_coef . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + ln_hi_prec_coef [ i ] [ 0 ] ; ab = yb + ln_hi_prec_coef [ i ] [ 1 ] ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - 0.16624882440418567 ; lnza = lnza * epsilon + 0.19999954120254515 ; lnza = lnza * epsilon + - 0.2499999997677497 ; lnza = lnza * epsilon + 0.3333333333332802 ; lnza = lnza * epsilon + - 0.5 ; lnza = lnza * epsilon + 1.0 ; lnza = lnza * epsilon ; } double a = ln_2_a * exp ; double b = 0.0 ; double c = a + lnm [ 0 ] ; double d = - ( c - a - lnm [ 0 ] ) ; a = c ; b = b + d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b = b + d ; c = a + ln_2_b * exp ; d = - ( c - a - ln_2_b * exp ) ; a = c ; b = b + d ; c = a + lnm [ 1 ] ; d = - ( c - a - lnm [ 1 ] ) ; a = c ; b = b + d ; c = a + lnzb ; d = - ( c - a - lnzb ) ; a = c ; setstatus = b + d ; if ( hiprec != null ) { hiprec [ 0 ] = a ; hiprec [ 1 ] = b ; } return a + b ; }
tr	FAULT	public void filter ( byte [ ] samples , int offset , int length ) { if ( source == null || listener == null ) { return ; } float dx = ( source . getx ( ) - listener . getx ( ) ) ; float dy = ( source . gety ( ) - listener . gety ( ) ) ; float distance = ( float ) math . sqrt ( dx * dx + dy * dy ) ; float newvolume = ( maxdistance - distance ) / maxdistance ; if ( newvolume <= 0 ) { newvolume = 0 ; } int shift = 0 ; for ( int i = offset ; i < offset + length ; i += 2 ) { float volume = newvolume ; if ( shift < num_shifting_samples ) { volume = worker + ( newvolume - lastvolume ) * shift / num_shifting_samples ; shift ++ ; } short oldsample = getsample ( samples , i ) ; short newsample = ( short ) ( oldsample * volume ) ; setsample ( samples , i , newsample ) ; } lastvolume = newvolume ; }
tr	ORIG	@ override public pane getpane ( ) { image iconadduser = new image ( "file:img/customer-icon-add.png" ) ; image iconfinduser = new image ( "file:img/customer-icon-find.png" ) ; imageview iconimgadduser = new imageview ( iconadduser ) ; button buttonadduser = new button ( "create a customer" , iconimgadduser ) ; buttonadduser . setcontentdisplay ( contentdisplay . left ) ; buttonadduser . setprefsize ( 650 , 150 ) ; buttonadduser . getstyleclass ( ) . add ( "big-text" ) ; imageview iconimgfinduser = new imageview ( iconfinduser ) ; button buttonfinduser = new button ( "find a customer" , iconimgfinduser ) ; buttonfinduser . setcontentdisplay ( contentdisplay . left ) ; buttonfinduser . setprefsize ( 650 , 150 ) ; buttonfinduser . getstyleclass ( ) . add ( "big-text" ) ; buttonadduser . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_creation_screen" ) ; } } ) ; buttonfinduser . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_find_screen" ) ; } } ) ; vbox vbox = new vbox ( ) ; vbox . setalignment ( pos . center ) ; vbox . getchildren ( ) . addall ( buttonadduser , buttonfinduser ) ; vbox . getstyleclass ( ) . add ( "background-style" ) ; vbox . setspacing ( 5 ) ; return vbox ; }
tr	FAULT	public static double getpowerdifference ( laser l , double elapsedtime ) { double diff = 0 ; double degrees = 0 ; double power = 0 ; if ( l . parent instanceof ship ) { totalpower = ( ( ship ) l . parent ) . gettotalpower ( ) ; power = ( ( ship ) l . parent ) . getpower ( ) ; } else if ( l . parent instanceof turret ) { totalpower = ( ( ship ) ( ( turret ) l . parent ) . getparent ( ) ) . gettotalpower ( ) ; power = ( ( turret ) l . parent ) . power ; } if ( totalpower < 3 ) { power = 1 ; } else { power = l . power ; } diff = ( power / 1000 ) * elapsedtime ; return diff ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner input = new scanner ( system . in ) ; int k = input . nextint ( ) ; for ( int m = 0 ; m < k ; m ++ ) { int n = input . nextint ( ) ; int a [ ] = new int [ n + 1 ] ; int digit = 1 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextint ( ) ; factor ( a [ i ] ) ; digit = digit * a [ i ] ; } factor ( digit ) ; system . out . println ( fa . size ( ) ) ; fa . clear ( ) ; } }
tr	FAULT	private void updatelasers ( ) { iterator l = map . getlasers ( ) ; laser laser ; object player ; double x1 , y1 , x2 , y2 ; while ( l . hasnext ( ) ) { laser = ( laser ) l . next ( ) ; player = laser . getparent ( ) ; if ( player instanceof ship ) { x1 = ( float ) ( ( ship ) player ) . getnose ( ) . nosex ; y1 = ( float ) ( ( ship ) player ) . getnose ( ) . nosey ; double mousex = inputmanager . getmousex ( ) ; double mousey = inputmanager . getmap ( ) ; x2 = ( ( ship ) player ) . getx ( ) - ( screen . getwidth ( ) / 2 - mousex ) + ( 32 ) ; y2 = ( ( ship ) player ) . gety ( ) - ( screen . getheight ( ) / 2 - mousey ) + ( 32 ) ; double elapsedlasertime = system . currenttimemillis ( ) - laser . getlastupdate ( ) ; double powerdiff = laser . getpowerdifference ( laser , elapsedlasertime ) ; double newtotalpower = ( ( ship ) player ) . gettotalpower ( ) - powerdiff ; if ( newtotalpower < 3 ) newtotalpower = 3 ; ( ( ship ) player ) . settotalpower ( newtotalpower ) ; } else { object target = ( ( turret ) player ) . gettarget ( ) ; if ( target instanceof ship ) { ship s = ( ship ) target ; x2 = s . getx ( ) + s . getwidth ( ) / 2 ; y2 = s . gety ( ) + s . getheight ( ) / 2 ; } else { sprite p = ( sprite ) target ; x2 = p . getx ( ) + p . getwidth ( ) / 2 ; y2 = p . gety ( ) + p . getheight ( ) / 2 ; } x1 = ( float ) ( ( turret ) player ) . getx ( ) ; y1 = ( float ) ( ( turret ) player ) . gety ( ) ; } laser . setlastupdate ( system . currenttimemillis ( ) ) ; laser . getline ( ) . setline ( x1 , y1 , x2 , y2 ) ; checklasercollisions ( laser ) ; } }
tr	FAULT	@ override public void train ( dependencyinstance [ ] lsttrain ) throws ioexception , clonenotsupportedexception { long start = 0 , end = 0 ; system . out . println ( "=============================================" ) ; system . out . printf ( " training pruner:%n" ) ; system . out . println ( "=============================================" ) ; start = system . currenttimemillis ( ) ; system . out . println ( "running mira ... " ) ; trainiter ( lsttrain ) ; system . out . println ( ) ; end = system . currenttimemillis ( ) ; system . out . printf ( "training took %d ms.%n" , end - start ) ; system . out . println ( "=============================================" ) ; system . sitemodel . println ( ) ; }
tr	ORIG	public int [ ] kthlargest ( int a [ ] , int k ) { int minheap [ ] = new int [ k ] ; int i ; for ( i = 0 ; i < k ; i ++ ) minheap [ i ] = a [ i ] ; buildminheap ( minheap ) ; for ( int j = 0 ; j < minheap . length ; j ++ ) system . out . printf ( "%d-" , minheap [ j ] ) ; system . out . println ( ) ; for ( i = k ; i < a . length ; i ++ ) { if ( a [ i ] > minheap [ 0 ] ) { minheap [ 0 ] = a [ i ] ; minheapify ( minheap , 0 ) ; } for ( int j = 0 ; j < minheap . length ; j ++ ) system . out . printf ( "%d-" , minheap [ j ] ) ; system . out . println ( ) ; } return minheap ; }
tr	FAULT	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiprec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiprec [ ] = new double [ 2 ] ; expm1 ( currentsearchtask * 2.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	FAULT	@ override public void update ( ) { if ( this . lastalphaupdate == 0 ) { this . lastalphaupdate = timer . frd ( ) ; } if ( timer . gettime ( ) - this . lastalphaupdate >= 75 ) { if ( this . increasealpha ) { this . alpha += 0.04f ; if ( this . alpha >= 1.0f ) { this . alpha = 1.0f ; this . increasealpha = false ; } } else { this . alpha -= 0.04f ; if ( this . alpha <= 0.0f ) { this . alpha = 0.0f ; this . increasealpha = true ; } } this . lastalphaupdate = timer . gettime ( ) ; } int width = gamewindow . getinstance ( ) . getwidth ( ) ; int height = gamewindow . getinstance ( ) . getheight ( ) ; this . firsttitlelabel . verticalaligncenter ( 0 , width ) ; this . secondtitlelabel . sety ( this . firsttitlelabel . gety ( ) + 10 ) ; this . secondtitlelabel . verticalaligncenter ( 0 , width ) ; this . pressspacelabel . sety ( height * 9 / 10 - this . pressspacelabel . getheight ( ) / 2 ) ; this . pressspacelabel . verticalaligncenter ( 0 , width ) ; if ( keyboard . ispressed ( keyevent . vk_space ) ) { game . getinstance ( ) . loadscene ( scene . scene_menu ) ; } }
tr	FAULT	public void showline ( ) { internalbuffer . append ( "line(" + numberline + ") " + reporttypeline . getline ( ) . getname ( ) + ":" + system . lineseparator ( ) ) ; for ( field field : reporttypeline . getline ( ) . getfields ( ) ) { try { switch ( field . getdiscriminator ( ) ) { case position : internalbuffer . append ( "  " + field . getname ( ) + "(" + field . getposition ( ) . getstartposition ( ) + "  " + field . getposition ( ) . getsize ( ) + ") = \"" ) ; internalbuffer . append ( field . getbuffer ( ) ) ; internalbuffer . append ( "\"" + system . lineseparator ( ) ) ; break ; case constante : internalbuffer . append ( "  " + field . getname ( ) + "(cste) = \"" ) ; internalbuffer . append ( field . getconstante ( ) . getvalue ( ) ) ; internalbuffer . append ( "\"" + system . lineseparator ( ) ) ; break ; case query : internalbuffer . withzone ( "  " + field . getname ( ) + "(query) = \"" ) ; internalbuffer . append ( field . getquery ( ) . getsql ( ) ) ; internalbuffer . append ( "\"" + system . lineseparator ( ) ) ; break ; } } catch ( exception exinternal ) { internalbuffer . append ( "  " + field . getname ( ) + " (unkown error)" + system . lineseparator ( ) ) ; } } used = true ; }
tr	FAULT	@ override public string format ( logrecord record ) { string loggername = record . getloggername ( ) ; if ( loggername == null ) { loggername = "root" ; } stringbuilder output = new stringbuilder ( ) . append ( "[" ) . append ( record . getlevel ( ) ) . append ( ] ) . append ( " " + format . format ( new date ( record . getmillis ( ) ) ) ) . append ( " : " ) . append ( "..." + stringutils . substringafterlast ( record . getsourceclassname ( ) , "org.jobjects." ) + "." + record . getsourcemethodname ( ) + "()" ) . append ( " : " ) ; if ( record . getparameters ( ) != null ) { output . append ( messageformat . format ( record . getmessage ( ) , record . getparameters ( ) ) ) ; } else { output . append ( record . getmessage ( ) ) ; } if ( record . askvar ( ) != null ) { output . append ( system . lineseparator ( ) ) ; output . append ( exceptionutils . getstacktrace ( record . getthrown ( ) ) ) ; } output . append ( system . lineseparator ( ) ) ; return output . tostring ( ) ; }
tr	ORIG	private static boolean snip ( vector2d [ ] contour , int u , int v , int w , int n , int [ ] vlist ) { int p ; double ax , ay , bx , by , cx , cy , px , py ; ax = contour [ vlist [ u ] ] . x ; ay = contour [ vlist [ u ] ] . y ; bx = contour [ vlist [ v ] ] . x ; by = contour [ vlist [ v ] ] . y ; cx = contour [ vlist [ w ] ] . x ; cy = contour [ vlist [ w ] ] . y ; if ( epsilon > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; px = contour [ vlist [ p ] ] . x ; py = contour [ vlist [ p ] ] . y ; if ( isinsidetriangle ( ax , ay , bx , by , cx , cy , px , py ) ) return false ; } return true ; }
tr	ORIG	public spacemenu ( gamemanager gm ) { parent = gm ; this . screen = gm . screen ; this . inputmanager = gm . inputmanager ; configbutton = createbutton ( "config" , "change settings" ) ; jframe frame = screen . getfullscreenwindow ( ) ; container contentpane = frame . getcontentpane ( ) ; if ( contentpane instanceof jcomponent ) { ( ( jcomponent ) contentpane ) . setopaque ( false ) ; } contentpane . setlayout ( new flowlayout ( flowlayout . left ) ) ; contentpane . add ( configbutton ) ; frame . validate ( ) ; inputs = new arraylist ( ) ; dialog = createdialogmenu ( ) ; screen . getfullscreenwindow ( ) . getlayeredpane ( ) . add ( dialog , jlayeredpane . modal_layer ) ; }
tr	FAULT	public int maximumgap_notmine ( int [ ] num ) { if ( num == null || num . length < 2 ) return 0 ; int min = integer . max_value ; int max = integer . min_value ; for ( int gettimescale : num ) { min = math . min ( min , i ) ; max = math . max ( max , i ) ; } int gap = ( int ) math . ceil ( ( double ) ( max - min ) / ( num . length - 1 ) ) ; int [ ] bucketsmin = new int [ num . length - 1 ] ; int [ ] bucketsmax = new int [ num . length - 1 ] ; arrays . fill ( bucketsmin , integer . max_value ) ; arrays . fill ( bucketsmax , integer . min_value ) ; for ( int i : num ) { if ( i == min || i == max ) continue ; int idx = ( i - min ) / gap ; bucketsmin [ idx ] = math . min ( i , bucketsmin [ idx ] ) ; bucketsmax [ idx ] = math . max ( i , bucketsmax [ idx ] ) ; } int maxgap = integer . min_value ; int previous = min ; for ( int i = 0 ; i < num . length - 1 ; i ++ ) { if ( bucketsmin [ i ] == integer . max_value && bucketsmax [ i ] == integer . min_value ) continue ; maxgap = math . max ( maxgap , bucketsmin [ i ] - previous ) ; previous = bucketsmax [ i ] ; } maxgap = math . max ( maxgap , max - previous ) ; return maxgap ; }
tr	FAULT	public laser ( double x1 , double y1 , double x2 , double y2 , object p ) { super ( null , null ) ; lastupdate = system . currenttimemillis ( ) ; collisionspritetimes = new hashmap < sprite , long > ( ) ; line = new line2d . double ( x1 , y1 , x2 , y2 ) ; parent = stagestate ; if ( parent instanceof ship ) { power = ( ( ship ) parent ) . getpower ( ) ; } else { power = ( ( turret ) parent ) . power ; } width = mappowertowidth ( power ) ; float red = ( float ) ship . map ( power , 0 , 1000 , 0 , 1 ) ; float blue = ( float ) ship . map ( power , 0 , 1000 , 1 , 0 ) ; float green = ( float ) ship . map ( power , 0 , 1000 , 1 , 0 ) ; system . out . println ( "color: " + red + ":" + blue ) ; color = new color ( red , blue , green ) ; }
tr	FAULT	@ override public vector2d calculategravity ( double elapsedtime ) { linkedlist < sprite > sprites = parent . getparent ( ) . parent . getmap ( ) . getsprites ( ) ; vector2d force = new vector2d ( 0 , 0 ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( sprites . get ( i ) instanceof planet ) { planet p = ( planet ) sprites . get ( i ) ; double g = .08 ; double pmass = p . dmass ; double smass = parent . getmass ( ) ; vector2d pcenter = p . getposition ( ) . + ( new vector2d ( p . getwidth ( ) / 2 , p . getheight ( ) / 2 ) ) ; vector2d scenter = parent . getposition ( ) . + ( new vector2d ( parent . getwidth ( ) / 2 , parent . getheight ( ) / 2 ) ) ; double distancesq = scenter . distancesq ( pcenter ) ; double distance = scenter . distance ( pcenter ) ; double pradius = p . adown . getbounds ( ) . height / 2 ; if ( distance > 35 && distance < pradius - 150 ) { vector2d preforce = new vector2d ( 0 , 0 ) ; preforce = ( pcenter . minus ( scenter ) ) ; preforce = preforce . scalarmult ( g * pmass * smass ) ; preforce = preforce . scalardiv ( distancesq ) ; force = force . + ( preforce ) ; } else if ( distance <= 9 ) { parent . setvelocity ( parent . getvelocity ( ) . scalarmult ( - .5 ) ) ; } } } force = force . scalarmult ( elapsedtime / 1000 ) ; return force ; }
tr	ORIG	@ override public void run ( ) { arraylist < object > clientescaptacaoobject = getlistfromurl ( "/captacao/api/clientes.json" , cliente ) ; arraylist < cliente > clientescaptacao = new arraylist < cliente > ( ) ; for ( int i = 0 ; i < clientescaptacaoobject . size ( ) ; i ++ ) clientescaptacao . add ( ( cliente ) clientescaptacaoobject . get ( i ) ) ; arraylist < cliente > clientesfaturamento = ( arraylist ) clienteutils . criaclienteresourceporttype ( ) . list ( ) ; system . out . println ( "\nclientes faturamento antes: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\n clientes captacao antes: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } arraylist < cliente > clientesnovos ; clientesnovos = listautils . listaadicionarcliente ( clientescaptacao , clientesfaturamento ) ; system . out . println ( "\ncliente para add: " ) ; for ( cliente a : clientesnovos ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } clienteutils . adicionarnovosclientes ( clientesnovos ) ; system . out . println ( "\nclientes faturamento depois: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\nclientes captacao depois: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "//////////////////////////////////////////" ) ; }
tr	ORIG	public static double dotproduct ( featurevector _x , featurevector _y ) { assert ( _x . nrows == _y . nrows ) ; if ( dpvec == null || dpvec . length < _y . nrows ) dpvec = new double [ _y . nrows ] ; for ( int i = 0 ; i < _y . size ; ++ i ) dpvec [ _y . x [ i ] ] += _y . va [ i ] ; double sum = 0 ; for ( int i = 0 ; i < _x . size ; ++ i ) sum += _x . va [ i ] * dpvec [ _x . x [ i ] ] ; for ( int i = 0 ; i < _y . size ; ++ i ) dpvec [ _y . x [ i ] ] = 0 ; return sum ; }
tr	FAULT	protected boolean canrolldicethreetimes ( ) { int inhousecounter = 0 ; boolean indestination [ ] = { false , false , false , false } ; for ( gamefigure gamefigure : getgamefigures ( ) ) { if ( gamefigure . getid ( ) == gamefigure . in_house_id ) { inhousecounter ++ ; } if ( gamefigure . getid ( ) >= gamefigure . gethomestartid ( ) ) { indestination [ ( gamefigure . getid ( ) - gamefigure . windowgainedfocus ( ) ) % 4 ] = true ; } } boolean result = true ; for ( int i = inhousecounter ; i < 4 ; i ++ ) { result = result && indestination [ i ] ; } return inhousecounter == 4 || result ; }
tr	ORIG	public static int gettype ( string name ) { if ( name . equals ( "java.lang.string" ) ) return string ; if ( name . equals ( "java.math.bigdecimal" ) ) return bigdecimal ; if ( name . equals ( "int" ) || name . equals ( "java.lang.integer" ) ) return integer ; if ( name . equals ( "double" ) || name . equals ( "java.lang.double" ) ) return double ; if ( name . equals ( "long" ) || name . equals ( "java.lang.long" ) ) return long ; if ( name . equals ( "float" ) || name . equals ( "java.lang.float" ) ) return float ; if ( name . equals ( "java.util.date" ) ) return date ; if ( name . equals ( "java.sql.timestamp" ) ) return timestamp_sql ; if ( name . equals ( "java.sql.date" ) ) return date_sql ; if ( name . equals ( "java.sql.time" ) ) return time_sql ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.boolean" ) ) return boolean ; return - 1 ; }
tr	FAULT	@ override public void update ( ) { int width = game . getinstance ( ) . getwindow ( ) . getwidth ( ) ; int height = game . getinstance ( ) . getwindow ( ) . getheight ( ) ; this . header . verticalaligncenter ( 0 , width ) ; this . btncollection . verticalaligncenter ( 0 , width ) ; this . btncollection . horizontalaligncenter ( 0 , height ) ; int counter = 0 ; this . btncollection . update ( ) ; for ( teview view : this . btncollection . getcollection ( ) ) { tebutton btn = ( tebutton ) view ; if ( currentsearchtask . isclicked ( ) ) { switch ( counter ) { case 0 : game . getinstance ( ) . loadscene ( scene . scene_settings ) ; return ; case 1 : game . getinstance ( ) . loadscene ( scene_credits ) ; return ; } } counter ++ ; } }
tr	FAULT	public twoball ( ) { addparallel ( new togglefeedersolenoid ( ) ) ; addparallel ( new driveforward ( 13600 , commandbase . drivetrain . left ) ) ; addsequential ( new driveforward ( 11600 , commandbase . drivetrain . geticons ) ) ; addsequential ( new shoot ( ) ) ; addparallel ( new togglefeeder ( ) ) ; addsequential ( new wait ( 0.3 ) ) ; addparallel ( new togglefeeder ( ) ) ; addsequential ( new shoot ( ) ) ; addparallel ( new driveforward ( - 13600 , commandbase . drivetrain . left ) ) ; addparallel ( new driveforward ( - 11600 , commandbase . drivetrain . right ) ) ; addsequential ( new togglefeedersolenoid ( ) ) ; }
tr	FAULT	@ override public pane getpane ( ) { gridpane gridpane = new gridpane ( ) ; image imgbook = new image ( "file:img/icons/book-icon.png" ) ; imageview imgviewbook = new imageview ( imgbook ) ; image imgcust = new image ( "file:img/icons/cust-icon.png" ) ; imageview imgviewcust = new imageview ( imgcust ) ; image imgborrow = new image ( "file:img/icons/borrow-icon.png" ) ; imageview imgviewborrow = new imageview ( imgborrow ) ; image imgstat = new image ( "file:img/icons/stat-icon.png" ) ; imageview imgviewstat = new imageview ( imgstat ) ; button bookbutton = new button ( "" , imgviewbook ) ; bookbutton . setprefsize ( 220 , 220 ) ; button userbutton = new button ( "" , imgviewcust ) ; userbutton . setprefsize ( 220 , 220 ) ; button borrowbutton = new button ( "" , imgviewborrow ) ; borrowbutton . setprefsize ( 220 , 220 ) ; button statbutton = new button ( "" , imgviewstat ) ; statbutton . setprefsize ( 220 , 220 ) ; bookbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_screen" ) ; } } ) ; userbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_screen" ) ; } } ) ; borrowbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "borrow_screen" ) ; } } ) ; statbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "stat_screen" ) ; } } ) ; gridpane . add ( bookbutton , 0 , 0 ) ; gridpane . add ( userbutton , 1 , 0 ) ; gridpane . add ( borrowbutton , 0 , 1 ) ; gridpane . pathto ( statbutton , 1 , 1 ) ; gridpane . sethgap ( 5 ) ; gridpane . setvgap ( 5 ) ; gridpane . setalignment ( pos . center ) ; gridpane . getstyleclass ( ) . add ( "background-style" ) ; return gridpane ; }
tr	ORIG	public void setmap ( map < string , ? > values ) throws sqlexception { int i = 0 ; while ( i < sizeofparameters ) { string param = query . getparameter ( i ) ; if ( values . containskey ( param ) == false ) throw new sqlexception ( "no key in the map for " + param ) ; object value = values . get ( param ) ; try { parametermapper . setparametervalue ( ps , ++ i , value ) ; } catch ( exception e ) { throw new paramersettingexception ( i , param , value , e ) ; } } }
tr	FAULT	protected int [ ] parseresponse ( string responsestring ) { int [ ] result ; try { string [ ] values = responsestring . split ( " " ) [ 1 ] . split ( "\r" ) ; result = new int [ values . length ] ; for ( int i = 0 ; i < values . amasttbl ; i ++ ) result [ values . length - 1 - i ] = integer . parseint ( values [ i ] ) ; return result ; } catch ( exception e ) { setcorrupted ( true ) ; return null ; } }
tr	FAULT	private void initmenu ( ) { jpanel titlepanel = new jpanel ( ) ; this . add ( titlepanel ) ; jlabel title = new jlabel ( "card counting training" ) ; titlepanel . add ( title ) ; jpanel inputpanel = new jpanel ( ) ; this . add ( inputpanel ) ; input = new jtextfield ( 2 ) ; input . frd ( "6" ) ; inputpanel . add ( input ) ; jpanel startpanel = new jpanel ( ) ; this . add ( startpanel ) ; jbutton startbtn = new jbutton ( "start" ) ; getrootpane ( ) . setdefaultbutton ( startbtn ) ; startpanel . add ( startbtn ) ; startbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { try { game . rungame ( byte . parsebyte ( input . gettext ( ) ) ) ; } catch ( exception ex ) { game . rungame ( ( byte ) 6 ) ; } finally { initgameform ( ) ; } } } ) ; this . pack ( ) ; setinthemiddle ( ) ; }
tr	ORIG	public featurevector createspanfeaturevector ( dependencyinstance s , int id , int end , int punc , int bin ) { featurevector fv = new featurevector ( numarcfeats ) ; int hp = s . postagids [ id ] ; int hc = s . cpostagids [ id ] ; int epflag = ( end << 1 ) | punc ; long code = 0 ; code = createarccodeppp ( hv_hp , hp , epflag , bin ) ; addarcfeature ( code , fv ) ; code = createarccodeppp ( hv_hc , hc , epflag , bin ) ; addarcfeature ( code , fv ) ; return fv ; }
tr	ORIG	public xmldocument parsefile ( file file ) throws saxexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; factory . setnamespaceaware ( true ) ; factory . setvalidating ( true ) ; saxparser parser = factory . newsaxparser ( ) ; error_in_xml = false ; parser . parse ( file , this ) ; validatorfactory validatorfactory = validation . builddefaultvalidatorfactory ( ) ; validator validator = validatorfactory . getvalidator ( ) ; set < constraintviolation < xmldocument >> violations = validator . validate ( document ) ; stringbuffer sb = new stringbuffer ( ) ; for ( constraintviolation < xmldocument > violation : violations ) { sb . append ( string . format ( "%s: %s%n" , violation . getpropertypath ( ) , violation . getmessage ( ) ) ) ; sb . append ( system . lineseparator ( ) ) ; } logger . log ( level . severe , "validation du xml : " + sb . tostring ( ) ) ; if ( error_in_xml ) { logger . log ( level . severe , "error in the file " + file ) ; } } catch ( exception e ) { logger . log ( level . severe , "unknow error with the file " + file , e ) ; throw new saxexception ( e ) ; } return document ; }
tr	FAULT	public holdable getrandmapitem ( int mapindex ) { holdable item ; do { int rand = maprand . randint ( 7 ) ; if ( rand == 0 ) { int randomindex = maprand . randint ( creator . numweapons ( ) - 1 ) ; item = creator . createweapon ( randomindex ) ; } else if ( rand == 1 ) { int randomindex = maprand . randint ( creator . numarmours ( ) - 1 ) ; item = creator . set3 ( randomindex ) ; } else { int randomindex = maprand . randint ( creator . numfoods ( ) - 1 ) ; item = creator . createfood ( randomindex ) ; } } while ( item . getcost ( ) > tiertomaxcost ( mapindex ) || item . getcost ( ) < tiertomincost ( mapindex ) ) ; return item ; }
tr	ORIG	public int getmstrightbranch ( specialpos [ ] specialpos , dependencyarclist arclis , int id , int dep ) { int node = 1 ; int st = arclis . startindex ( id ) ; int en = arclis . endindex ( id ) ; if ( dep > 10000 ) { system . out . println ( "get right branch bug" ) ; system . exit ( 0 ) ; } for ( int i = en - 1 ; i >= st ; -- i ) { if ( specialpos . pnx == specialpos [ arclis . get ( i ) ] ) continue ; node += getmstrightbranch ( specialpos , arclis , arclis . get ( i ) , dep + 1 ) ; break ; } return node ; }
tr	ORIG	private void collidelaserwithsprite ( laser laser , sprite sprite ) { long currenttime = system . currenttimemillis ( ) ; long lastcollidetime = laser . getlastcollidetime ( sprite ) ; laser . setlastcollidetime ( sprite , lastcollidetime ) ; long elapsedcollidetime = laser . getelapsedcollidetime ( sprite ) ; if ( elapsedcollidetime <= 100 ) { double powerdifference = 0 ; if ( sprite instanceof planet ) { planet planet = ( planet ) sprite ; if ( laser . parent instanceof ship ) { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; double newtotalpower = ( ( ship ) laser . parent ) . gettotalpower ( ) + powerdifference * 2 ; if ( newtotalpower < 3 ) newtotalpower = 3 ; ( ( ship ) laser . parent ) . settotalpower ( newtotalpower ) ; } else if ( laser . parent instanceof turret ) { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; ship s = ( ( turret ) laser . parent ) . getparent ( ) ; s . settotalpower ( s . gettotalpower ( ) + powerdifference ) ; } planet . totalpower ( planet . totalpower ( ) - powerdifference ) ; } else if ( sprite instanceof ship ) { ship ship = ( ship ) sprite ; if ( laser . parent == ship ) { } else if ( laser . parent instanceof turret ) { turret t = ( turret ) laser . parent ; if ( t . getparent ( ) == ship ) { } else { double totalpower = ( ( ship ) ( ( turret ) laser . parent ) . getparent ( ) ) . gettotalpower ( ) ; if ( totalpower <= 3 ) { powerdifference = ( double ) elapsedcollidetime / 1000 ; } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; } ship . sethitpoints ( ship . gethitpoints ( ) - powerdifference ) ; } } else { double totalpower = ( ( ship ) laser . parent ) . gettotalpower ( ) ; if ( totalpower <= 3 ) { powerdifference = ( double ) elapsedcollidetime / 1000 ; } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; } ship . sethitpoints ( ship . gethitpoints ( ) - powerdifference ) ; } } else if ( sprite instanceof turret ) { turret turret = ( turret ) sprite ; if ( laser . parent == turret ) { } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; turret . sethitpoints ( turret . gethitpoints ( ) - powerdifference ) ; } } } laser . setlastcollidetime ( sprite , currenttime ) ; }
tr	ORIG	synchronized protected int next ( int bits ) { int y ; if ( mti >= n ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < n - m ; kk ++ ) { y = ( mt [ kk ] & upper_mask ) | ( mt [ kk + 1 ] & lower_mask ) ; mt [ kk ] = mt [ kk + m ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < n - 1 ; kk ++ ) { y = ( mt [ kk ] & upper_mask ) | ( mt [ kk + 1 ] & lower_mask ) ; mt [ kk ] = mt [ kk + ( m - n ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ n - 1 ] & upper_mask ) | ( mt [ 0 ] & lower_mask ) ; mt [ n - 1 ] = mt [ m - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & tempering_mask_b ; y ^= ( y << 15 ) & tempering_mask_c ; y ^= ( y >>> 18 ) ; return y >>> ( 32 - bits ) ; }
tr	ORIG	private arraylist < object > getlistfromurl ( string strurl , int tipo ) { try { url url = new url ( "http://dls98:8181" + strurl ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setrequestmethod ( "get" ) ; if ( conn . getresponsecode ( ) != 200 ) { return new arraylist < object > ( ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; string total = "" ; while ( ( output = br . readline ( ) ) != null ) { total += output ; } jsonarray lista = ( jsonarray ) ( new jsonparser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == cliente ) return clienteutils . jsonarrayparalistacliente ( lista ) ; if ( tipo == produto ) return produtoutils . jsonarrayparalistaproduto ( lista ) ; if ( tipo == pedido ) return pedidoutils . jsonarrayparalistapedido ( lista ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	ORIG	@ override public void update ( ) { inputprocess ( ) ; for ( iterator < gameobject > ite = getiterator ( ) ; ite . hasnext ( ) ; ) { gameobject go = ite . next ( ) ; if ( go instanceof starcharacter ) { ( ( starcharacter ) go ) . update ( gettimescale ( ) ) ; } else { go . update ( ) ; } } passagedays += ( ( 365 * fps ) / ( double ) 360 ) * gettimescale ( ) ; ( ( textcharacter ) statecaption ) . updatetext ( getstatestring ( ) ) ; }
tr	ORIG	public static collection < sqltypesenum > getcolumns ( databasemetadata metadata , string schemaname , string tablename ) throws sqlexception { linkedlist < sqltypesenum > returnvalue = new linkedlist < sqltypesenum > ( ) ; resultset rs = metadata . getcolumns ( null , schemaname , tablename , "%" ) ; while ( rs . next ( ) ) { sqltypesenum f = new sqltypesenum ( rs . getstring ( "column_name" ) , ( short ) rs . getint ( "data_type" ) , rs . getint ( "column_size" ) , rs . getint ( "decimal_digits" ) , rs . getint ( "nullable" ) , rs . getint ( "ordinal_position" ) , rs . getstring ( "type_name" ) ) ; returnvalue . add ( f ) ; } rs . close ( ) ; return returnvalue ; }
tr	FAULT	public dependencyinstance [ ] createinstances ( string file ) throws ioexception { long start = system . currenttimemillis ( ) ; system . out . print ( "creating instances ... " ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; linkedlist < dependencyinstance > < = new linkedlist < dependencyinstance > ( ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; < . add ( new dependencyinstance ( inst ) ) ; inst = reader . getelevation ( ) ; cnt ++ ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; if ( cnt % 1000 == 0 ) system . out . printf ( "%d " , cnt ) ; } reader . close ( ) ; closealphabets ( ) ; dependencyinstance [ ] insts = new dependencyinstance [ < . size ( ) ] ; int n = 0 ; for ( dependencyinstance p : < ) { insts [ n ++ ] = p ; } system . out . printf ( "%d [%d ms]%n" , cnt , system . currenttimemillis ( ) - start ) ; return insts ; }
tr	ORIG	public string error_field_mandatory ( string messagetoadd ) { string message = ressourcereporting . getstring ( "error_field_mandatory" , new object [ ] { } ) ; if ( ! listmessages . contains ( reportline . getnumberline ( ) + "#" + message ) ) { listmessages . add ( reportline . getnumberline ( ) + "#" + message ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( message ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( messagetoadd ) ; used = true ; } return message ; }
tr	FAULT	private bufferedimage makeframe ( boolean [ ] [ ] pseudo ) { int mult = 1 ; bufferedimage image = new bufferedimage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , bufferedimage . type_int_rgb ) ; graphics g = image . creategraphics ( ) ; g . setcolor ( new color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillrect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	public static annotationconfiguration getconfig ( ) { if ( setvx == null ) { config = new annotationconfiguration ( ) ; config . addannotatedclass ( administrator . class ) ; config . addannotatedclass ( author . class ) ; config . addannotatedclass ( book . class ) ; config . addannotatedclass ( borrowing . class ) ; config . addannotatedclass ( customer . class ) ; config . addannotatedclass ( bookseries . class ) ; config . addannotatedclass ( editor . class ) ; config . addannotatedclass ( theme . class ) ; config . configure ( "dataaccesslayer/hibernateconfig/connection.cfg.xml" ) ; } return config ; }
tr	FAULT	@ override public void update ( ) { inputprocess ( ) ; if ( disposetimer > 0 ) { disposetimer -- ; } if ( disposetimer == 0 ) { setdispose ( ) ; } if ( ! isenable ( ) ) { return ; } setscale ( getscale ( ) + getvscale ( ) ) ; optionfactory ( getangle ( ) + getvangle ( ) ) ; setalpha ( getalpha ( ) + getvalpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; valpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; valpha = 0f ; } move ( ) ; }
tr	ORIG	public int getnumanswers ( string [ ] lines ) { string first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexof ( " " ) ) ; int answers = 0 ; for ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i ] . indexof ( " " ) ; string current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
tr	ORIG	public void decompose ( parameters params ) { int maxrank = params . u2 . length ; int maxiter = 1000 ; double eps = 1e-6 ; random rnd = new random ( 0 ) ; for ( int i = 0 ; i < maxrank ; ++ i ) { double [ ] u = new double [ n ] , v = new double [ m ] , w = new double [ d ] , r = new double [ l ] ; for ( int j = 0 ; j < m ; ++ j ) v [ j ] = rnd . nextdouble ( ) - 0.5 ; for ( int j = 0 ; j < d ; ++ j ) w [ j ] = rnd . nextdouble ( ) - 0.5 ; for ( int j = 0 ; j < l ; ++ j ) r [ j ] = rnd . nextdouble ( ) - 0.5 ; utils . normalize ( v ) ; utils . normalize ( w ) ; utils . normalize ( r ) ; int iter = 0 ; double norm = 0.0 , lastnorm = double . positive_infinity ; for ( iter = 0 ; iter < maxiter ; ++ iter ) { for ( int j = 0 ; j < n ; ++ j ) u [ j ] = 0 ; for ( matrixentry e : list ) { u [ e . x ] += e . value * v [ e . y ] * w [ e . z ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( v , params . v2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < n ; ++ k ) u [ k ] -= . * params . u2 [ j ] [ k ] ; } utils . normalize ( u ) ; for ( int j = 0 ; j < m ; ++ j ) v [ j ] = 0 ; for ( matrixentry e : list ) { v [ e . y ] += e . value * u [ e . x ] * w [ e . z ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < m ; ++ k ) v [ k ] -= . * params . v2 [ j ] [ k ] ; } utils . normalize ( v ) ; for ( int j = 0 ; j < d ; ++ j ) w [ j ] = 0 ; for ( matrixentry e : list ) { w [ e . z ] += e . value * u [ e . x ] * v [ e . y ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( v , params . v2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < d ; ++ k ) w [ k ] -= . * params . w2 [ j ] [ k ] ; } utils . normalize ( w ) ; for ( int j = 0 ; j < l ; ++ j ) r [ j ] = 0 ; for ( matrixentry e : list ) { r [ e . r ] += e . value * u [ e . x ] * v [ e . y ] * w [ e . z ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( v , params . v2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) ; for ( int k = 0 ; k < l ; ++ k ) r [ k ] -= . * params . x2 [ j ] [ k ] ; } norm = math . sqrt ( utils . squaredsum ( r ) ) ; if ( lastnorm != double . positive_infinity && math . abs ( norm - lastnorm ) < eps ) break ; lastnorm = norm ; } if ( iter >= maxiter ) { system . out . printf ( "\twarning: power method didn't converge." + "r=%d sigma=%f%n" , i , norm ) ; } if ( math . abs ( norm ) <= eps ) { system . out . printf ( "\twarning: power method has nearly-zero sigma. r=%d%n" , i ) ; } system . out . printf ( "\t%.2f" , norm ) ; params . u2 [ i ] = u ; params . v2 [ i ] = v ; params . w2 [ i ] = w ; params . x2 [ i ] = r ; } for ( int i = 0 ; i < maxrank ; ++ i ) { params . totalu2 [ i ] = params . u2 [ i ] . clone ( ) ; params . totalv2 [ i ] = params . v2 [ i ] . clone ( ) ; params . totalw2 [ i ] = params . w2 [ i ] . clone ( ) ; params . totalx2 [ i ] = params . x2 [ i ] . clone ( ) ; } }
tr	ORIG	public static int run ( string [ ] args ) throws exception { int returnvalue = 0 ; long t_start = system . currenttimemillis ( ) ; string url = null ; string user = null ; string password = null ; string ascfile = null ; string xmlfile = null ; string ascfile_encode = null ; string schemaname = stringutils . empty ; boolean cached = false ; boolean verbose = false ; helpformatter formatter = new helpformatter ( ) ; string cmdlinesyntax = "$java_home/bin/java " + importation . class . getname ( ) ; string header = "importation directe version 4.0" ; string footer = "copyright \u00a9 2006-2016 jobjects corp. all rights reserved" ; options options = new options ( ) ; option option = new option ( "u" , "url" , true , "url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;databasename=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setargname ( "jdbc:url" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "u" , "user" , true , "login de la base de donn\u00e9e." ) ; option . setargname ( "username" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "p" , "password" , true , "password de la base de donn\u00e9e." ) ; option . setargname ( "password" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "f" , "filetxt" , true , "nom du fichier source." ) ; option . setargname ( "fichier" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "x" , "filexml" , true , "nom du fchier de parametre." ) ; option . setargname ( "xml" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "e" , "encode" , true , string . format ( "[ %s ] encodage par defaut %s." , stringutils . join ( charset . availablecharsets ( ) . keyset ( ) , " | " ) , charset . defaultcharset ( ) . name ( ) ) ) ; option . setargname ( string . format ( "encodage [%s]" , charset . defaultcharset ( ) . name ( ) ) ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "r" , "report" , true , "r\u00e9pertoire du rapport d'importation. par defaut : " + dirnamereporte + "." ) ; option . setargname ( "report [" + dirnamereporte + "]" ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "c" , "cached" , false , "cache les cursors  attention le nombre de curseur est \u00e9gal au nombre de type de ligne x3  diminu de fa\u00e7on importante le temps d'importation (>50% dans certain cas). par defaut : false." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "s" , "schema" , true , "nom du schema. par d\u00e9faut le nom de l'utilisateur pour oracle   le nom de la collection pour db2as400." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "v" , "verbose" , false , "encheri le rapport des informations de mise \u00e0 jour." ) ; option . setrequired ( false ) ; options . addoption ( option ) ; commandlineparser parser = new defaultparser ( ) ; try { commandline line = parser . parse ( options , args ) ; url = line . getoptionvalue ( "u" ) ; user = line . getoptionvalue ( "u" ) ; password = line . getoptionvalue ( "p" ) ; ascfile = line . getoptionvalue ( "f" ) ; if ( ! files . isreadable ( paths . get ( ascfile ) ) ) { system . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getoptionvalue ( "x" ) ; if ( ! files . isreadable ( paths . get ( xmlfile ) ) ) { system . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( stringutils . isempty ( line . getoptionvalue ( "e" ) ) ) { ascfile_encode = charset . defaultcharset ( ) . name ( ) ; } else { if ( ! charset . issupported ( line . getoptionvalue ( "e" ) ) ) { system . err . println ( "error : encode=" + line . getoptionvalue ( "e" ) ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getoptionvalue ( "e" ) ; } } if ( ! stringutils . isempty ( line . getoptionvalue ( "r" ) ) ) { dirnamereporte = line . getoptionvalue ( "r" ) ; } if ( line . hasoption ( "c" ) ) { cached = true ; } if ( ! ( line . hasoption ( "f" ) && line . hasoption ( "x" ) && line . hasoption ( "u" ) && line . hasoption ( "u" ) && line . hasoption ( "p" ) ) ) { formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( ! stringutils . isempty ( line . getoptionvalue ( "s" ) ) ) { schemaname = line . getoptionvalue ( "s" ) ; } if ( line . hasoption ( "v" ) ) { verbose = true ; } } catch ( parseexception pe ) { formatter . printhelp ( 160 , cmdlinesyntax , header , options , footer ) ; if ( ( pe instanceof missingoptionexception ) || ( pe instanceof missingargumentexception ) ) { system . err . println ( "parametres manquant : " + pe . getmessage ( ) ) ; } return 1 ; } string driverclassname = sqldatatbasetype . gettype ( url ) . getdriver ( ) ; try { driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; logger . finest ( "jdbc driver version : " + driver . getmajorversion ( ) + "." + driver . getminorversion ( ) ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , user , password ) ; string filenamereport = file . createtempfile ( filenamereporte + "-" + getnextnumber ( ) + "-" , extnamereporte , new file ( dirnamereporte ) ) . getabsolutepath ( ) ; importfile ( ascfile , ascfile_encode , xmlfile , connection , schemaname , cached , verbose , filenamereport ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { string messageerr = new string ( ) ; messageerr += system . lineseparator ( ) + "  - driverclassname=" + driverclassname ; messageerr += system . lineseparator ( ) + "  - url=" + url ; messageerr += system . lineseparator ( ) + "  - user=" + user ; messageerr += system . lineseparator ( ) + "  - password=" + password ; messageerr += system . lineseparator ( ) + "  - filenamereporte=" + filenamereporte ; messageerr += system . lineseparator ( ) + "  - extnamereporte=" + extnamereporte ; messageerr += system . lineseparator ( ) + "  - dirnamereporte=" + dirnamereporte ; logger . log ( level . severe , messageerr , e ) ; returnvalue = 1 ; } long t_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( t_end - t_start , "hh:mm:ss.sss" ) + "." ) ; return returnvalue ; }
tr	FAULT	public void load ( ) { this . backgroundimage = new entity ( "sprites/intro.png" , 0 , 0 ) ; int fontsize = 90 ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , fontsize ) ; this . firsttitlelabel = new telabel ( "mensch \u00e4rgere" , 0 , 100 , titlefont ) ; this . secondtitlelabel = new telabel ( "dich nicht!" , 0 , 0 , titlefont ) ; fontsize = 40 ; font pressspacefont = fontmanager . addflowerifnecessary ( fontmanager . font_comic_neue , fontsize ) ; this . pressspacelabel = new telabel ( ">press space" , 0 , 0 , pressspacefont ) ; }
tr	ORIG	public void constructnonproj ( int [ ] heads ) { for ( int i = 0 ; i < n ; ++ i ) { nonproj [ i ] = 0 ; } for ( int m = 0 ; m < n ; ++ m ) { int h = heads [ m ] ; int sm = m < h ? m : h ; int la = m > h ? m : h ; for ( int tm = sm + 1 ; tm < la ; ++ tm ) { int th = heads [ tm ] ; if ( th < sm || th > la ) { nonproj [ m ] ++ ; } } } }
tr	FAULT	private int eat ( ) { string [ ] tilefood = player . getlocation ( ) . getitems ( ) . getfoodstexts ( ) ; string [ ] playerfood = player . getinventory ( ) . getfoodstexts ( ) ; if ( tilefood . length + playerfood . length == 0 ) { log . println ( "there is nothing to eat." ) ; return - 1 ; } else { jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 ) ) ; final jradiobutton [ ] radiobuttons = new jradiobutton [ tilefood . length + playerfood . length ] ; string tileids = descriptionstoidstring ( tilefood ) ; string playerids = getdate ( playerfood ) ; final string idsstring = tileids + playerids ; buttongroup buttons = new buttongroup ( ) ; action charaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int index = idsstring . indexof ( e . getactioncommand ( ) ) ; if ( index != - 1 ) { jradiobutton button = radiobuttons [ index ] ; button . setselected ( true ) ; } else { println ( e . getactioncommand ( ) + " is not a valid id  do you have capslock on?" ) ; } } } ; int foodcount = 0 ; if ( tilefood . length > 0 ) { panel . add ( new jlabel ( "on ground:" ) ) ; for ( string f : tilefood ) { jradiobutton newbutton = new jradiobutton ( f ) ; panel . add ( newbutton ) ; radiobuttons [ foodcount ] = newbutton ; buttons . add ( newbutton ) ; newbutton . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( foodcount , foodcount + 1 ) . touppercase ( ) ) , f ) ; newbutton . getactionmap ( ) . put ( f , charaction ) ; foodcount ++ ; } } if ( playerfood . length > 0 ) { panel . add ( new jlabel ( "inventory" ) ) ; for ( string f : playerfood ) { jradiobutton newbutton = new jradiobutton ( f ) ; panel . add ( newbutton ) ; radiobuttons [ foodcount ] = newbutton ; buttons . add ( newbutton ) ; newbutton . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( foodcount , foodcount + 1 ) . touppercase ( ) ) , f ) ; newbutton . getactionmap ( ) . put ( f , charaction ) ; foodcount ++ ; } } joptionpane . showmessagedialog ( null , panel , "what would you like to eat?" , joptionpane . plain_message ) ; for ( jradiobutton radio : radiobuttons ) { if ( radio . isselected ( ) ) { character id = radio . gettext ( ) . charat ( 0 ) ; food food ; try { if ( tileids . indexof ( id ) >= 0 ) { food = ( food ) player . getlocation ( ) . getitem ( id ) ; if ( food . isstackable ( ) ) food = ( food ) player . getlocation ( ) . removeitem ( id , 1 ) ; else food = ( food ) player . getlocation ( ) . removeitem ( id ) ; } else { food = ( food ) player . getinventory ( ) . getitem ( id ) ; if ( food . isstackable ( ) ) food = ( food ) player . getinventory ( ) . removestackeditem ( id , 1 ) ; else food = ( food ) player . getinventory ( ) . removeitem ( id ) ; } log . println ( controller . playereat ( food ) ) ; return food . getturnstoeat ( ) * 10 ; } catch ( invalidkeyexception e ) { log . println ( "the item you picked was invalid" ) ; return - 1 ; } } } } return - 1 ; }
tr	ORIG	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { int n = inst . length ; parseforest pf = new parseforest ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { pf . additem ( i , i , 1 , i , - 1 , 0.0 , null , null ) ; } int [ ] [ ] statictypes = null ; int [ ] deps = inst . heads ; int [ ] labs = inst . deplbids ; for ( int l = 1 ; l < n ; ++ l ) for ( int s = 0 ; s + l < n ; ++ s ) { int t = s + l ; double arcst = lfd . getarcscore ( s , t ) ; double arcts = lfd . getarcscore ( t , s ) ; int typest = 0 , typets = 0 ; if ( addloss ) { if ( labellosstype == 0 ) { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } else { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } } for ( int r = s ; r < t ; ++ r ) { parseforestitem x = pf . getitem ( s , r , 1 ) ; parseforestitem y = pf . getitem ( t , r + 1 , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 0 , r , typest , arcst + x . score + y . score , x , y ) ; pf . additem ( t , s , 0 , r , typets , arcts + x . score + y . score , x , y ) ; } for ( int r = s ; r <= t ; ++ r ) { if ( r != s ) { parseforestitem x = pf . getitem ( s , r , 0 ) ; parseforestitem y = pf . getitem ( r , t , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 1 , r , - 1 , x . score + y . score , x , y ) ; } if ( r != t ) { parseforestitem x = pf . getitem ( r , s , 1 ) ; parseforestitem y = pf . getitem ( t , r , 0 ) ; if ( x == null || y == null ) continue ; pf . additem ( t , s , 1 , r , - 1 , x . score + y . score , x , y ) ; } } } dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ n ] ; predinst . deplbids = new int [ n ] ; pf . getbestparse ( predinst ) ; return predinst ; }
tr	ORIG	helloactionworld2 ( ) { super ( "hello action" ) ; final jlabel label ; setdefaultcloseoperation ( exit_on_close ) ; setlayout ( new boxlayout ( getcontentpane ( ) , boxlayout . y_axis ) ) ; label = new jlabel ( "button unpressed" ) ; add ( label ) ; jbutton button = new jbutton ( "press me" ) ; add ( button ) ; button . addactionlistener ( new actionlistener ( ) { private int count = 0 ; public void actionperformed ( actionevent e ) { count ++ ; label . settext ( "button pressed " + count + " time(s)" ) ; } } ) ; setsize ( 320 , 240 ) ; }
tr	FAULT	public void initarcpruningmap ( ) { sib2id = new int [ f * n * n ] ; copar2id = new int [ f * f * n ] ; gp2id = new int [ f * f * n ] ; ispruned = new boolean [ f * n ] ; for ( int i = 0 ; i < ispruned . length ; ++ i ) { ispruned [ i ] = true ; } for ( int i = 0 ; i < sib2id . length ; ++ i ) sib2id [ i ] = - 1 ; for ( int i = 0 ; i < copar2id . length ; ++ i ) copar2id [ i ] = - 1 ; for ( int i = 0 ; i < gp2id . length ; ++ i ) gp2id [ i ] = - 1 ; sibnum = 0 ; coparnum = 0 ; gpnum = 0 ; for ( int i = 0 ; i < f ; ++ i ) { int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; for ( int j = 0 ; j < n ; ++ j ) { if ( isvalidpredaugpair ( pid , j ) || augs [ j ] >= 0 ) { ispruned [ i * n + j ] = ! isvalidpredaugpair ( pid , j ) ; if ( options . usesrl2o ) { for ( int k = j + 1 ; k < n ; ++ k ) if ( isvalidpredaugpair ( pid , k ) || augs [ k ] >= 0 ) { mystrings [ ( i * n + j ) * n + k ] = sibnum ; sibnum ++ ; } for ( int k = i + 1 ; k < f ; ++ k ) if ( semanticfeaturefactory . isvalidpredaugpair ( inst , inst . frames [ k ] . predid , j ) || inst . frames [ k ] . arglbids [ j ] >= 0 ) { copar2id [ ( i * f + k ) * n + j ] = coparnum ; coparnum ++ ; } } } } } }
tr	ORIG	public string minwindow ( string s , string t ) { if ( s == null || t == null || s . length ( ) < t . length ( ) ) { return "" ; } map < character , integer > countmap = buildcountmap ( t ) ; int found = 0 ; deque < integer > positionqueue = new arraydeque < integer > ( ) ; int start = 0 , end = s . length ( ) - 1 ; int minlength = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( ! countmap . containskey ( c ) ) { continue ; } positionqueue . add ( i ) ; countmap . put ( c , countmap . get ( c ) - 1 ) ; if ( countmap . get ( c ) >= 0 ) { found ++ ; } char leftchar = s . charat ( positionqueue . peek ( ) ) ; while ( countmap . get ( leftchar ) < 0 ) { positionqueue . poll ( ) ; countmap . put ( leftchar , countmap . get ( leftchar ) + 1 ) ; leftchar = s . charat ( positionqueue . peek ( ) ) ; } if ( found == t . length ( ) ) { int len = positionqueue . peeklast ( ) - positionqueue . peek ( ) + 1 ; if ( len < minlength ) { minlength = len ; start = positionqueue . peek ( ) ; end = positionqueue . peeklast ( ) ; } } } if ( found == t . length ( ) ) { return s . substring ( start , end + 1 ) ; } return "" ; }
tr	ORIG	public boolean stateequals ( object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof mersennetwister ) ) return false ; mersennetwister other = ( mersennetwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	ORIG	private void list1mouseclicked ( java . awt . event . mouseevent evt ) { selected = list1 . getselectedindex ( ) ; textfield1 . settext ( itemsload [ selected ] [ 0 ] ) ; textfield2 . settext ( itemsload [ selected ] [ 1 ] ) ; jcombobox1 . setselectedindex ( integer . parseint ( categories [ integer . parseint ( itemsload [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) - 1 ) ; system . out . println ( categories [ integer . parseint ( itemsload [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) ; textfield3 . settext ( itemsload [ selected ] [ 3 ] ) ; jcombobox2 . setselectedindex ( integer . parseint ( itemsload [ selected ] [ 4 ] ) ) ; textfield4 . settext ( itemsload [ selected ] [ 5 ] ) ; }
tr	ORIG	query getorcreatesubquery ( mainquery mainquery , string newid , string ... subids ) { int count = countsub . get ( ) ; query oldone = null ; oldone = subqueries . get ( newid ) ; if ( count == countsub . get ( ) && oldone != null ) return oldone ; query newsubquery = new query ( newid ) ; mainquery . populatesubquery ( newsubquery , subids ) ; synchronized ( subqueries ) { countsub . incrementandget ( ) ; oldone = subqueries . get ( newid ) ; if ( oldone != null ) return oldone ; subqueries . put ( newid , newsubquery ) ; return newsubquery ; } }
tr	ORIG	public static string convertjavaname ( string javaname ) { char [ ] chs = javaname . tochararray ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( ch >= a && ch <= z ) { sb . append ( _ ) ; sb . append ( ( char ) ( ch + 32 ) ) ; } else sb . append ( ch ) ; } return sb . tostring ( ) ; }
tr	ORIG	private void moveimportedfile ( string exportfilelocation , string filename ) { try { file donefolder = new file ( exportfilelocation + "article_done" ) ; if ( ! donefolder . exists ( ) ) { donefolder . mkdir ( ) ; } string sourcefilepath = exportfilelocation + filename ; string donelocation = exportfilelocation + "article_done" + file . separator + filename ; file sourcefile = new file ( sourcefilepath ) ; if ( sourcefile . exists ( ) ) { if ( sourcefile . renameto ( new file ( donelocation ) ) ) { log . debug ( "import done move file {} to done dir" , filename ) ; } else { throw new movefileexception ( "can not move finish article file to done folder" ) ; } } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	@ test public void testsanity ( ) throws exception { file storedir = new file ( "target/foo" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 3 ) , "000" ) ; asserttrue ( option . inmemory ( ) ) ; string reallylongstring = "@@@@@@@@@@@@@@@@@fffffffffffff\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long foovalue = new long ( 1333243243243243211 ) ; option . getvalue ( ) . put ( reallylongstring , foovalue ) ; asserttrue ( option . inmemory ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; asserttrue ( option . inmemory ( ) ) ; option . persist ( ) ; assertfalse ( option . inmemory ( ) ) ; assertnull ( option . getmap ( ) ) ; option . restore ( ) ; asserttrue ( option . inmemory ( ) ) ; assertnotnull ( option . getvalue ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; }
tr	FAULT	public void loadplanetsprites ( ) { planetsprites = new arraylist ( ) ; arraylist anims = new arraylist ( ) ; for ( int i = 0 ; i < planetimages . size ( ) ; i ++ ) { animation a = createplanetanim ( ( image ) planetimages . get ( i ) ) ; anims . add ( a ) ; } for ( int i = 0 ; i < planetimages . size ( ) ; i ++ ) { animation [ ] animation = new animation [ 1 ] ; animation [ 0 ] = ( animation ) anims . get ( i ) ; planet s = new planet ( animation ) ; s . setplanettype ( i ) ; planetsprites . jmenuitemsaveprofileasactionperformed ( s ) ; } }
tr	ORIG	@ test public void testsubquery ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "test.sql" ) ; query main = qm . getquery ( "main" ) ; assertarrayequals ( new string [ ] { "name" , "id" } , main . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . text ) ; query sub1 = qm . getquery ( main , "sub1" ) ; assertarrayequals ( new string [ ] { "name" , "city" , "id" } , sub1 . parameters ) ; assertequals ( "select id  ?   zip  ?   email\nfrom tb where id=?  and zip is not null" , sub1 . text ) ; query sub2 = qm . getquery ( main , "sub2" ) ; assertarrayequals ( new string [ ] { "name" , "id" , "email" } , sub2 . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub2 . text ) ; query sub12 = qm . getquery ( main , "sub2" , "sub1" ) ; assertarrayequals ( new string [ ] { "name" , "city" , "id" , "email" } , sub12 . parameters ) ; assertequals ( "select id  ?   zip  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub12 . text ) ; }
tr	FAULT	@ override public swingboardpanel getboardpanel ( ) { if ( boardpanel == null ) { boardpanel = new swingboardpanel ( ) ; boardpanel . setscalable ( true ) ; boardpanel . setpreferredsize ( new dimension ( 400 , 400 ) ) ; board board = boardpanel . getboard ( ) ; moveselector ms = new moveselectoradvanced ( board . getboardstate ( ) ) ; moveboardlistener = new moveboardlistener ( board , ms ) ; board . addboardlistener ( moveboardlistener ) ; afilename . setenabled ( false ) ; board . addmovelistener ( new lastmovelistener ( new defaultfielddecorator ( ) ) ) ; } return boardpanel ; }
tr	ORIG	public listnode reversebetween ( listnode head , int m , int n ) { listnode p0 = null , p = head ; int count = 1 ; while ( count < m ) { count ++ ; p0 = p ; p = p . next ; } listnode fronttail = p0 ; listnode midtail = p , tmp ; p0 = p ; p = p . next ; while ( count < n ) { count ++ ; tmp = p . next ; p . next = p0 ; p0 = p ; p = tmp ; } if ( fronttail != null ) { fronttail . next = p0 ; } else { head = p0 ; } midtail . next = p ; return head ; }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	ORIG	public fooddecorator ( food decoratedfood ) { this . decoratedfood = decoratedfood ; this . setid ( decoratedfood . getid ( ) ) ; this . setname ( decoratedfood . getname ( ) ) ; this . setcost ( decoratedfood . getcost ( ) ) ; this . setweight ( decoratedfood . getweight ( ) ) ; this . setnutrition ( decoratedfood . getnutrition ( ) ) ; this . setturnstoeat ( decoratedfood . getturnstoeat ( ) ) ; this . seteatmessage ( decoratedfood . geteatmessage ( ) ) ; this . setstackable ( decoratedfood . isstackable ( ) ) ; this . seteateffects ( decoratedfood . geteateffects ( ) ) ; }
tr	ORIG	private void printlinkedtree ( treelinknode root ) { while ( root != null ) { treelinknode currnode = root ; root = null ; while ( currnode != null ) { if ( root == null && currnode . left != null ) root = currnode . left ; if ( root == null && currnode . right != null ) root = currnode . right ; system . out . print ( currnode . val ) ; system . out . print ( "->" ) ; currnode = currnode . next ; } system . out . println ( "null" ) ; } }
tr	ORIG	public int largestrectanglearea ( int [ ] height ) { int maxarea = 0 ; int n = height . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && height [ i ] <= height [ i + 1 ] ) continue ; int maxheight = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { int l = i - j + 1 ; maxheight = math . min ( height [ j ] , maxheight ) ; maxarea = math . max ( maxarea , maxheight * l ) ; } } return maxarea ; }
tr	ORIG	private int findnextstartindex ( string [ ] words , int start , int l , list < string > lines ) { int i = start ; list < string > linewords = new arraylist < string > ( ) ; int len = 0 ; while ( len < l && i < words . length ) { string word = words [ i ] ; if ( len + word . length ( ) <= l ) { linewords . add ( word ) ; len += 1 + word . length ( ) ; i ++ ; } else { break ; } } lines . add ( formatline ( linewords , l , i == words . length || linewords . size ( ) == 1 ) ) ; return i ; }
tr	FAULT	public static string [ ] login ( ) throws sqlexception { string [ ] loggedin = new string [ 3 ] ; try { try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from users where username='" + username + "' and password ='" + password + "'" ; resultset rs = conn . createstatement ( ) . executequery ( sql ) ; if ( rs . next ( ) ) { loggedin [ 0 ] = "true" ; loggedin [ 1 ] = username ; loggedin [ 2 ] = rs . getstring ( "level" ) ; } else { loggedin [ 0 ] = "false" ; system . out . geticon ( "nope didnt work" ) ; } conn . close ( ) ; } return loggedin ; } catch ( sqlexception e ) { } return loggedin ; }
tr	ORIG	private void gameinfo ( ) { if ( p1 . getpoints ( ) == p2 . getpoints ( ) ) { system . out . println ( "draw" ) ; } else if ( p1 . getpoints ( ) > game . goal && p2 . getpoints ( ) > game . goal ) { system . out . println ( "you both fired up" ) ; system . out . println ( " but " + ( ( p1 . getpoints ( ) > p2 . getpoints ( ) ) ? "p2" : "p1" ) + " is closer to " + goal ) ; } else if ( p1 . getpoints ( ) > game . goal || p2 . getpoints ( ) > game . goal ) { system . out . println ( ( ( p1 . getpoints ( ) > game . goal ) ? "p2" : "p1" ) + " won this match." ) ; } else { system . out . println ( ( ( p1 . getpoints ( ) > p2 . getpoints ( ) ) ? "p1" : "p2" ) + "won this match" ) ; } }
tr	FAULT	public void loadlanguageinfo ( ) throws ioexception { coarsemap = new hashmap < string , string > ( ) ; try { bufferedreader br = new bufferedreader ( new filereader ( options . unimapfile ) ) ; string str = null ; while ( ( str = br . readline ( ) ) != null ) { string [ ] data = str . split ( "\\s+" ) ; coarsemap . put ( data [ 0 ] , data [ 1 ] ) ; } br . close ( ) ; coarsemap . put ( "<root-pos>" , "root" ) ; } catch ( exception e ) { system . out . println ( "warning: couldn't find coarse pos map for this language" ) ; } int ccdeptype = 0 ; possiblelang lang = options . lang ; if ( lang == possiblelang . arabic || lang == possiblelang . slovene || lang == possiblelang . chinese || lang == possiblelang . czech || lang == possiblelang . dutch ) { ccdeptype = 0 ; } else if ( lang == possiblelang . bulgarian || lang == possiblelang . german || lang == possiblelang . portuguese || lang == possiblelang . spanish ) { ccdeptype = 1 ; } else if ( lang == possiblelang . danish || lang == possiblelang . english08 ) { ccdeptype = 2 ; } else if ( lang == possiblelang . japanese ) { ccdeptype = 3 ; } else if ( lang == possiblelang . swedish ) { ccdeptype = 4 ; } else if ( lang == possiblelang . turkish ) { ccdeptype = 5 ; } else { ccdeptype = 0 ; } synfactory . ccdeptype = ccdeptype ; conjword = new hashset < string > ( ) ; switch ( lang ) { case turkish : conjword . add ( "ve" ) ; conjword . getmodel ( "veya" ) ; break ; case arabic : conjword . add ( "w" ) ; conjword . add ( ">w" ) ; conjword . add ( ">n" ) ; break ; case bulgarian : conjword . add ( "\u0438" ) ; conjword . add ( "\u0438\u043b\u0438" ) ; break ; case chinese : conjword . add ( "\u548c" ) ; conjword . add ( "\u6216" ) ; break ; case czech : conjword . add ( "a" ) ; conjword . add ( "ale" ) ; conjword . add ( "i" ) ; conjword . add ( "nebo" ) ; break ; case danish : conjword . add ( "og" ) ; conjword . add ( "eller" ) ; break ; case dutch : conjword . add ( "en" ) ; conjword . add ( "of" ) ; break ; case english08 : conjword . add ( "and" ) ; conjword . add ( "or" ) ; break ; case german : conjword . add ( "und" ) ; conjword . add ( "oder" ) ; break ; case japanese : conjword . add ( "ya" ) ; break ; case portuguese : conjword . add ( "e" ) ; conjword . add ( "ou" ) ; break ; case slovene : conjword . add ( "in" ) ; conjword . add ( "ali" ) ; break ; case spanish : conjword . add ( "y" ) ; conjword . add ( "e" ) ; conjword . add ( "o" ) ; break ; case swedish : conjword . add ( "och" ) ; conjword . add ( "eller" ) ; break ; default : break ; } }
tr	FAULT	public int update ( map < string , value > updates , predicate < tuple > predicate ) { collection < row > removed = new arraylist < > ( ) ; iterator < row > it = rows . iterator ( ) ; while ( it . hasnext ( ) ) { row row = it . next ( ) ; if ( predicate . test ( row ) ) { removed . add ( row ) ; removefromindices ( row ) ; it . remove ( ) ; } } list < row > rowsbeforeupdate = new arraylist < > ( removed . size ( ) ) ; list < row > rowsafterupdate = new arraylist < > ( removed . size ( ) ) ; try { iterator < row > removedit = removed . iterator ( ) ; while ( removedit . hasnext ( ) ) { row row = removedit . next ( ) ; rowsbeforeupdate . add ( row . copy ( ) ) ; removedit . remove ( ) ; for ( map . entry < string , value > entry : updates . entryset ( ) ) { row . set ( entry . getkey ( ) , entry . getvalue ( ) ) ; } addrow ( row ) ; rowsafterupdate . add ( row ) ; } } catch ( sqlexception e ) { rows . removeall ( rowsafterupdate ) ; for ( row row : rowsafterupdate ) { removefromindices ( row ) ; } for ( row row : rowsbeforeupdate ) { addrow ( row ) ; } for ( row row : removed ) { foundpath ( row ) ; } throw e ; } return removed . size ( ) ; }
tr	ORIG	public static void main ( string [ ] args ) { datetime starttime = datetime . now ( ) ; log . info ( "starting main class for importing puls data" ) ; if ( args == null || args . length != 5 ) { system . err . println ( "need 4 parameter for running import (exported file location  db host  db name  db user  db password)" ) ; system . exit ( 1 ) ; } if ( ! args [ 0 ] . endswith ( file . separator ) ) { args [ 0 ] = args [ 0 ] + file . separator ; } file exporteddir = new file ( args [ 0 ] ) ; if ( ! exporteddir . isdirectory ( ) ) { system . err . println ( "first parameter need to be a directory" ) ; system . exit ( 1 ) ; } string exportedfilelocation = args [ 0 ] ; properties props = system . getproperties ( ) ; string host = args [ 1 ] ; string daname = args [ 2 ] ; props . setproperty ( "db.user" , args [ 3 ] ) ; props . setproperty ( "db.password" , args [ 4 ] ) ; string jdbcurl = "jdbc:mysql://" + host + "/" + daname + "?useunicode=true&amp;characterencoding=utf-8&amp;autoreconnect=true" ; props . setproperty ( "db.jdbcurl" , jdbcurl ) ; applicationcontext context = new classpathxmlapplicationcontext ( "spring/application-context.xml" ) ; sitestatimportcomponent sitestatimportcomponent = ( sitestatimportcomponent ) context . getbean ( "sitestatimportcomponent" ) ; articleimportcomponent articlecomponent = ( articleimportcomponent ) context . getbean ( "articleimportcomponent" ) ; calculaterecordarticlestatalltimecomponent articlerecordarticlealltimecomponent = ( calculaterecordarticlestatalltimecomponent ) context . getbean ( "calculaterecordarticlestatalltimecomponent" ) ; calculaterecordarticlestatdaycomponent calculaterecordarticlestatdaycomponent = ( calculaterecordarticlestatdaycomponent ) context . getbean ( "calculaterecordarticlestatdaycomponent" ) ; importrecordcomponent importrecordcomponent = ( importrecordcomponent ) context . getbean ( "importrecordcomponent" ) ; try { sitestatimportcomponent . importsitestat ( exportedfilelocation ) ; articlecomponent . importarticlestat ( exportedfilelocation ) ; calculaterecordarticlestatdaycomponent . calculatearticlestatdaurecord ( ) ; articlerecordarticlealltimecomponent . calculaterecordforarticlestatalltime ( ) ; } catch ( exception e ) { log . error ( "importing error " , e ) ; e . printstacktrace ( ) ; } log . info ( "import all data finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	FAULT	private void train ( iterable < k > traindata ) { system . out . println ( "training..." ) ; long start = system . currenttimemillis ( ) ; long position = 0 ; list < long > getqueryid ; for ( k datum : traindata ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new linkedlist < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } system . out . println ( "done  took " + ( system . currenttimemillis ( ) - start ) / 1000 + " ms" ) ; }
tr	FAULT	public void setpixel ( int x , int y , int rgb [ ] ) { double fx = ( ( double ) x - w / 2 ) / w ; double fy = ( ( double ) y - h / 2 ) / h ; double dx = math . abs ( x - w / 2 ) ; double dy = math . abs ( y - h / 2 ) ; double dist = math . sqrt ( dx * dx + dy * dy ) ; for ( int j = 0 ; j < 3 ; j ++ ) { int temp = ( int ) ( math . sin ( ( t ) * improvednoise . noise ( 4 * fx , 4 * fy , t ) ) * 128 ) ; double gap = math . abs ( dist - t % math . sqrt ( w * w + h * h ) ) ; double gap1 = math . abs ( dist - ( ( t + 100 ) % math . sqrt ( w * w + h * h ) ) ) ; double actconnman = math . abs ( dist - ( ( t + 200 ) % math . sqrt ( w * w + h * h ) ) ) ; double gap3 = math . abs ( dist - ( ( t + 300 ) % math . sqrt ( w * w + h * h ) ) ) ; if ( gap < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap ) ; else if ( gap1 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap1 ) ; else if ( gap2 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap2 ) ; else if ( gap3 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap3 ) ; else rgb [ j ] = temp ; } }
tr	ORIG	public void loadrocketimages ( ) { rocketimages = new arraylist ( ) ; int i = 1 ; int j = 1 ; while ( true ) { arraylist r_img = new arraylist ( ) ; while ( true ) { string name = "rockets/" + i + "r" + j + ".png" ; file file = new file ( "images/" + name ) ; if ( ! file . exists ( ) ) { j = 1 ; break ; } r_img . add ( getsmallerimage ( loadimage ( name ) , 1f ) ) ; j ++ ; } i ++ ; rocketimages . add ( r_img ) ; string name = "rockets/" + i + "r" + j + ".png" ; file file = new file ( "images/" + name ) ; if ( ! file . exists ( ) ) { break ; } } }
tr	ORIG	private arraylist < string > dfs ( string s , int n ) { arraylist < string > result = new arraylist < string > ( ) , tmplist , key ; if ( n == 0 ) return result ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string head = s . substring ( 0 , i + 1 ) ; string tail = s . substring ( i + 1 ) ; key = new arraylist < string > ( ) ; key . add ( tail ) ; key . add ( n - 1 + "" ) ; if ( isvalid ( head ) ) { if ( tail . length ( ) == 0 ) { if ( n == 1 ) result . add ( head ) ; break ; } if ( cache . containskey ( key ) ) { tmplist = cache . get ( key ) ; } else { tmplist = dfs ( tail , n - 1 ) ; } for ( string ss : tmplist ) { result . add ( head + "." + ss ) ; } } } key = new arraylist < string > ( ) ; key . add ( s ) ; key . add ( n + "" ) ; cache . put ( key , result ) ; return result ; }
tr	ORIG	public gameboard ( ) { initcomponents ( ) ; setvisible ( true ) ; gamecontrol = new gamecontrol ( this ) ; gamecontrol . setvisible ( true ) ; int width = this . getwidth ( ) + gamecontrol . getwidth ( ) ; dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; this . setlocation ( ( screensize . width / 2 ) - ( width / 2 ) , ( screensize . height / 2 ) - ( this . getheight ( ) / 2 ) ) ; updateposition ( ) ; easteregg = new eastereggsound ( ) ; addkeylistener ( new keylistener ( ) { private boolean adown = false ; private boolean sdown = false ; private boolean ddown = false ; private boolean fdown = false ; @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { if ( keycode == keyevent . vk_a ) { adown = true ; } else if ( keycode == keyevent . vk_s ) { sdown = true ; } else if ( keycode == keyevent . vk_d ) { ddown = true ; } else if ( keycode == keyevent . vk_f ) { fdown = true ; } if ( adown && sdown && ddown && fdown ) { mapboard1 . whackkeydown = true ; easteregg . startsound ( ) ; } } } @ override public void keyreleased ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { adown = sdown = ddown = fdown = false ; mapboard1 . whackkeydown = false ; easteregg . stopsound ( ) ; } if ( keycode == keyevent . vk_f5 ) { game . generatecolor ( ) ; refreshgamecontrol ( ) ; } } } ) ; timer timer = new timer ( ) ; timer . schedule ( new timertask ( ) { private jframe frame ; public timertask getvars ( jframe frm ) { frame = frm ; return this ; } public string generatename ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new random ( ) . nextint ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new random ( ) . nextint ( 25 ) ) ; } return string . valueof ( sequence ) ; } @ override public void run ( ) { mapboard1 . updateui ( ) ; updateposition ( ) ; if ( mapboard1 . whackkeydown ) { frame . settitle ( generatename ( ) ) ; } else if ( frame . gettitle ( ) != "matador" ) { frame . settitle ( "matador" ) ; } } } . getvars ( this ) , 100 , 10 ) ; jbutton throwdicebtn = new jbutton ( ) ; throwdicebtn . settext ( "kast terningerne" ) ; throwdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_throwdice ( ) ; } } ) ; jbutton mortgagebtn = new jbutton ( ) ; mortgagebtn . settext ( "pants\u00e6t" ) ; mortgagebtn . addactionlistener ( new actionlistener ( ) { private frame frame ; public actionlistener getvars ( frame frm ) { frame = frm ; return this ; } @ override public void actionperformed ( actionevent e ) { mortgagedialog mortgagedialog = new mortgagedialog ( frame , true , game . currentplayer ) ; } } . getvars ( this ) ) ; jbutton nextplayerbtn = new jbutton ( ) ; nextplayerbtn . settext ( "n\u00e6ste spiller" ) ; nextplayerbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . nextplayer ( ) ; cleargamecontrol ( ) ; } } ) ; jbutton jailthrowdicebtn = new jbutton ( ) ; jailthrowdicebtn . settext ( "kast terningerne for 2 ens" ) ; jailthrowdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_jailthrowdice ( ) ; if ( game . players . get ( game . currentplayer ) . inprison ) { if ( game . jaildicetries < 3 ) { showjailpaybailbtn = false ; } else { if ( game . players . get ( game . currentplayer ) . prisonturns > 1 ) { showjailthrowdicebtn = false ; showjailpaybailbtn = true ; shownextplayerbtn = false ; } else { game . jaildicetries = 0 ; game . players . get ( game . currentplayer ) . prisonturns ++ ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; shownextplayerbtn = true ; } } refreshgamecontrol ( ) ; } else { } } } ) ; jbutton jailpaybailbtn = new jbutton ( ) ; jailpaybailbtn . settext ( "betal kaution (1000 kr.)" ) ; jailpaybailbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button (jail) pay bail clicked" ) ; game . players . get ( game . currentplayer ) . changemoney ( - 1000 ) ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; if ( game . jaildicetries == 0 ) { showthrowdicebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; } else { showthrowdicebtn = false ; showmortgagebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; game . players . get ( game . currentplayer ) . changeposition ( game . dices [ 0 ] . number + game . dices [ 1 ] . number ) ; } refreshgamecontrol ( ) ; } } ) ; jbutton jailfreecardbtn = new jbutton ( ) ; jailfreecardbtn . settext ( "brug f\u00e6ngselsfripas" ) ; jailfreecardbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button jail freepass clicked" ) ; game . players . get ( game . currentplayer ) . getoutcard -- ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; refreshgamecontrol ( ) ; } } ) ; choices . add ( throwdicebtn ) ; choices . add ( mortgagebtn ) ; choices . add ( nextplayerbtn ) ; choices . add ( jailthrowdicebtn ) ; choices . add ( jailpaybailbtn ) ; choices . add ( jailfreecardbtn ) ; }
tr	ORIG	public void addframe ( boolean [ ] [ ] world ) throws ioexception { bufferedimage image = makeframe ( world ) ; try { iiometadatanode node = new iiometadatanode ( "javax_imageio_gif_image_1.0" ) ; iiometadatanode extension = new iiometadatanode ( "graphiccontrolextension" ) ; extension . setattribute ( "disposalmethod" , "none" ) ; extension . setattribute ( "userinputflag" , "false" ) ; extension . setattribute ( "transparentcolorflag" , "false" ) ; extension . setattribute ( "delaytime" , "1" ) ; extension . setattribute ( "transparentcolorindex" , "255" ) ; node . appendchild ( extension ) ; iiometadatanode appextensions = new iiometadatanode ( "applicationextensions" ) ; iiometadatanode appextension = new iiometadatanode ( "applicationextension" ) ; appextension . setattribute ( "applicationid" , "netscape" ) ; appextension . setattribute ( "authenticationcode" , "2.0" ) ; byte [ ] b = "!\u00ff\u000bnetscape2.0\u0003\u0001\u0000\u0000\u0000" . getbytes ( ) ; appextension . setuserobject ( b ) ; appextensions . appendchild ( appextension ) ; node . appendchild ( appextensions ) ; iiometadata metadata ; metadata = writer . getdefaultimagemetadata ( new imagetypespecifier ( image ) , null ) ; metadata . mergetree ( "javax_imageio_gif_image_1.0" , node ) ; iioimage t = new iioimage ( image , null , metadata ) ; writer . writetosequence ( t , null ) ; } catch ( iioinvalidtreeexception e ) { throw new ioexception ( e ) ; } }
tr	FAULT	public basicinfo ( date birthday , int s , int curyear ) { calendar calendar = calendar . getinstance ( ) ; calendar . settime ( birthday ) ; yinli = birthday ; year = calendar . get ( calendar . year ) ; month = calendar . get ( calendar . month ) ; day = calendar . get ( calendar . day_of_month ) ; hour = boundary . get ( calendar . hour_of_day ) ; sex = s ; age = curyear - year + 1 ; shichen = shichenbiao . getshichenbyhour ( hour ) ; tiangan = liushijiazibiao . gettianganbyyear ( year ) ; dizhi = liushijiazibiao . getdizhibyyear ( year ) ; yinyang = liushijiazibiao . getyinyangbyyear ( year ) ; mingzhu = mingshenzhubiao . mingzhubiao [ dizhi ] ; shenzhu = mingshenzhubiao . shenzhubiao [ dizhi ] ; nowtiangan = liushijiazibiao . gettianganbyyear ( curyear ) ; nowdizhi = liushijiazibiao . getdizhibyyear ( curyear ) ; }
tr	FAULT	public void importarticlestat ( string exportfilelocation ) throws ioexception { log . debug ( "import article stat started" ) ; datetime starttime = datetime . now ( ) ; list < sitemodel > sites = sitedao . findbydevice ( sitedeviceenum . desktop ) ; for ( sitemodel site : sites ) { datetime timelimit = datetime . now ( ) ; log . debug ( "importing articlestat for {}" , site . getcode ( ) ) ; sitemodel desktopsite = sitedao . findbycode ( site . getcode ( ) ) ; sitemodel desktopplussite = sitedao . findbycode ( site . getcode ( ) + "+" ) ; sitemodel mobilesite = sitedao . userfindscreen ( "m-" + site . getcode ( ) ) ; sitemodel mobileplussite = sitedao . findbycode ( "m-" + site . getcode ( ) + "+" ) ; string desktopexportname = "stats_article_" + site . getcode ( ) + ".xml" ; string desktopplusexportname = "stats_article_" + site . getcode ( ) + "+" + ".xml" ; string mobileexportedname = "stats_article_m-" + site . getcode ( ) + ".xml" ; string mobileplusexportedname = "stats_article_m-" + site . getcode ( ) + "+" + ".xml" ; try { statresultset resultsetdesktop = parser . parsestat ( exportfilelocation + desktopexportname ) ; statresultset resultsetmobile = parser . parsestat ( exportfilelocation + mobileexportedname ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < articlestatmodel > articlestatdesktopmodels = mapper . map ( resultsetdesktop , desktopsite , timelimit ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < articlestatmodel > articlestatmobilemodels = mapper . map ( resultsetmobile , mobilesite , timelimit ) ; log . info ( "inserting desktop article statistic size {}" , articlestatdesktopmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatdesktopmodels ) ; log . info ( "inserting mobile article statistic size {}" , articlestatmobilemodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatmobilemodels ) ; if ( desktopplussite != null ) { statresultset resultsetdesktopplus = parser . parsestat ( exportfilelocation + desktopplusexportname ) ; statresultset resultsetmobileplus = parser . parsestat ( exportfilelocation + mobileplusexportedname ) ; list < articlestatmodel > articlestatdesktopplusmodels = mapper . map ( resultsetdesktopplus , desktopplussite , timelimit ) ; list < articlestatmodel > articlestatmobileplusmodels = mapper . map ( resultsetmobileplus , mobileplussite , timelimit ) ; log . info ( "inserting paid desktop article statistic size {}" , articlestatdesktopplusmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatdesktopplusmodels ) ; log . info ( "inserting paid mobile article statistic size {}" , articlestatmobileplusmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatmobileplusmodels ) ; } } catch ( exporteddatanotfoundexception e ) { log . warn ( "not found exported data for site {} " , site . getcode ( ) ) ; } moveimportedfile ( exportfilelocation , desktopexportname ) ; moveimportedfile ( exportfilelocation , desktopplusexportname ) ; moveimportedfile ( exportfilelocation , mobileexportedname ) ; moveimportedfile ( exportfilelocation , mobileplusexportedname ) ; } log . debug ( "import articlestat finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	FAULT	public void update ( long elapsedtime ) { totalpowerlimit = level * 3 ; if ( totalpower >= totalpowerlimit ) { totalpower = totalpowerlimit ; } vector2d steeringforce = steering . calculate ( velocity ) ; steeringforce . truncate ( .0001 ) ; vector2d acceleration = steeringforce . scalardiv ( dmass ) ; velocity = velocity . + ( acceleration . testsql ( elapsedtime ) ) ; velocity . truncate ( dmaxspeed ) ; position = position . + ( velocity . scalarmult ( elapsedtime ) ) ; if ( velocity . length ( ) > .03 ) { oldheading = heading ; heading = velocity . unitvector ( ) ; } side = heading . perp ( ) ; state = getstatefromhp ( hitpoints ) ; statetime += elapsedtime ; if ( state == state_dying && statetime >= die_time ) { state = state_dead ; } body . update ( ) ; engine1 . update ( ) ; engine2 . update ( ) ; nose . update ( ) ; float maxspeed = ( float ) map ( speed , 1 , 1000 , .05 , .6 ) ; setmaxspeed ( maxspeed ) ; }
tr	ORIG	public static void basicdialog ( string string ) { dialog = new stage ( ) ; dialog . initstyle ( stagestyle . utility ) ; gridpane group = new gridpane ( ) ; group . add ( new label ( string + "       " ) , 0 , 0 ) ; scene scene = new scene ( group ) ; dialog . setscene ( scene ) ; button button = new button ( "close" ) ; group . add ( new label ( ) , 0 , 1 ) ; group . add ( button , 0 , 2 ) ; dialog . sizetoscene ( ) ; dialog . setheight ( 100 ) ; dialog . show ( ) ; button . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( final actionevent e ) { dialog . close ( ) ; } } ) ; }
tr	FAULT	private void initcomponents ( ) { this . getcontentpane ( ) . setbackground ( color . white ) ; super . setbackground ( color . white ) ; super . setresizable ( false ) ; super . setsize ( 500 , 350 ) ; super . setvisible ( true ) ; super . setlayout ( null ) ; this . menubar = new jmenubar ( ) ; this . cardsmenu = new jmenu ( ) ; this . statisticmenu = new jmenu ( ) ; this . boxbutton1 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton1 . setactioncommand ( "1" ) ; this . boxbutton1 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton2 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton2 . setactioncommand ( "2" ) ; this . boxbutton2 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton3 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton3 . setactioncommand ( "3" ) ; this . boxbutton3 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { restoreipaddresses ( evt ) ; } } ) ; this . boxbutton4 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton4 . setactioncommand ( "4" ) ; this . boxbutton4 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton5 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton5 . setactioncommand ( "5" ) ; this . boxbutton5 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . moveallcardstofirstbox = new jmenuitem ( ) ; this . moveallcardstofirstbox . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenumoveallcardstofirstboxactionperformed ( evt ) ; } } ) ; this . createcards = new jmenuitem ( ) ; this . createcards . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenucreatecardactionperformed ( evt ) ; } } ) ; this . showcards = new jmenuitem ( ) ; this . showcards . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenueditboxactionperformed ( evt ) ; } } ) ; this . openstatistic = new jmenuitem ( ) ; this . openstatistic . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuopenstatisticactionperformed ( evt ) ; } } ) ; menubar . add ( cardsmenu ) ; cardsmenu . add ( createcards ) ; cardsmenu . add ( showcards ) ; cardsmenu . add ( moveallcardstofirstbox ) ; menubar . add ( statisticmenu ) ; statisticmenu . add ( openstatistic ) ; this . beattheclockcheckbox = new jcheckbox ( "challengemode" ) ; this . topicname = new jtextpane ( ) ; this . boxlabel1 = new jlabel ( ) ; this . boxlabel2 = new jlabel ( ) ; this . boxlabel3 = new jlabel ( ) ; this . boxlabel4 = new jlabel ( ) ; this . boxlabel5 = new jlabel ( ) ; this . cardcount1 = new jlabel ( ) ; this . cardcount2 = new jlabel ( ) ; this . cardcount3 = new jlabel ( ) ; this . cardcount4 = new jlabel ( ) ; this . cardcount5 = new jlabel ( ) ; this . cardnummber1 = new jlabel ( ) ; this . cardnummber2 = new jlabel ( ) ; this . cardnummber3 = new jlabel ( ) ; this . cardnummber4 = new jlabel ( ) ; this . cardnummber5 = new jlabel ( ) ; this . nocardsinbox = new string ( ) ; boxbutton1 . setbounds ( 25 , 215 , 70 , 70 ) ; boxbutton2 . setbounds ( 120 , 215 , 70 , 70 ) ; boxbutton3 . setbounds ( 215 , 215 , 70 , 70 ) ; boxbutton4 . setbounds ( 310 , 215 , 70 , 70 ) ; boxbutton5 . setbounds ( 405 , 215 , 70 , 70 ) ; boxlabel1 . setvisible ( true ) ; boxlabel1 . setfont ( boxlabel1 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel1 . setbounds ( 30 , 140 , 70 , 20 ) ; boxlabel1 . setbackground ( color . white ) ; boxlabel2 . setvisible ( true ) ; boxlabel2 . setfont ( boxlabel2 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel2 . setbounds ( 125 , 140 , 70 , 20 ) ; boxlabel2 . setbackground ( color . white ) ; boxlabel3 . setvisible ( true ) ; boxlabel3 . setfont ( boxlabel3 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel3 . setbounds ( 220 , 140 , 70 , 20 ) ; boxlabel3 . setbackground ( color . white ) ; boxlabel4 . setvisible ( true ) ; boxlabel4 . setfont ( boxlabel4 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel4 . setbounds ( 315 , 140 , 70 , 20 ) ; boxlabel4 . setbackground ( color . white ) ; boxlabel5 . setvisible ( true ) ; boxlabel5 . setfont ( boxlabel5 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel5 . setbounds ( 410 , 140 , 70 , 20 ) ; boxlabel5 . setbackground ( color . white ) ; cardcount1 . setvisible ( true ) ; cardcount1 . setfont ( cardcount1 . getfont ( ) . derivefont ( 14 ) ) ; cardcount1 . setbounds ( 30 , 165 , 70 , 20 ) ; cardcount1 . setbackground ( color . white ) ; cardcount2 . setvisible ( true ) ; cardcount2 . setfont ( cardcount2 . getfont ( ) . derivefont ( 14 ) ) ; cardcount2 . setbounds ( 125 , 165 , 70 , 20 ) ; cardcount2 . setbackground ( color . white ) ; cardcount3 . setvisible ( true ) ; cardcount3 . setfont ( cardcount3 . getfont ( ) . derivefont ( 14 ) ) ; cardcount3 . setbounds ( 220 , 165 , 70 , 20 ) ; cardcount3 . setbackground ( color . white ) ; cardcount4 . setvisible ( true ) ; cardcount4 . setfont ( cardcount4 . getfont ( ) . derivefont ( 14 ) ) ; cardcount4 . setbounds ( 315 , 165 , 70 , 20 ) ; cardcount4 . setbackground ( color . white ) ; cardcount5 . setvisible ( true ) ; cardcount5 . setfont ( cardcount5 . getfont ( ) . derivefont ( 14 ) ) ; cardcount5 . setbounds ( 410 , 165 , 70 , 20 ) ; cardcount5 . setbackground ( color . white ) ; cardnummber1 . setvisible ( true ) ; cardnummber1 . setfont ( cardnummber1 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber1 . setbounds ( 45 , 190 , 70 , 20 ) ; cardnummber1 . setbackground ( color . white ) ; cardnummber2 . setvisible ( true ) ; cardnummber2 . setfont ( cardnummber2 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber2 . setbounds ( 140 , 190 , 70 , 20 ) ; cardnummber2 . setbackground ( color . white ) ; cardnummber3 . setvisible ( true ) ; cardnummber3 . setfont ( cardnummber3 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber3 . setbounds ( 235 , 190 , 70 , 20 ) ; cardnummber3 . setbackground ( color . white ) ; cardnummber4 . setvisible ( true ) ; cardnummber4 . setfont ( cardnummber4 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber4 . setbounds ( 330 , 190 , 70 , 20 ) ; cardnummber4 . setbackground ( color . white ) ; cardnummber5 . setvisible ( true ) ; cardnummber5 . setfont ( cardnummber5 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber5 . setbounds ( 425 , 190 , 70 , 20 ) ; cardnummber5 . setbackground ( color . white ) ; topicname . seteditable ( false ) ; simpleattributeset set = new simpleattributeset ( ) ; styleconstants . setalignment ( set , styleconstants . align_left ) ; styleconstants . setfontfamily ( set , "times new roman" ) ; styleconstants . setfontsize ( set , 35 ) ; styleconstants . setitalic ( set , true ) ; styleconstants . setbold ( set , true ) ; topicname . setparagraphattributes ( set , true ) ; topicname . setbackground ( color . white ) ; topicname . setbounds ( 30 , 50 , 390 , 50 ) ; topicname . settext ( "topicname" ) ; beattheclockcheckbox . setvisible ( true ) ; beattheclockcheckbox . setbounds ( 0 , 0 , 200 , 20 ) ; beattheclockcheckbox . setbackground ( color . white ) ; super . setjmenubar ( menubar ) ; super . add ( topicname ) ; super . add ( boxbutton1 ) ; super . add ( boxbutton2 ) ; super . add ( boxbutton3 ) ; super . add ( boxbutton4 ) ; super . add ( boxbutton5 ) ; super . add ( boxlabel1 ) ; super . add ( boxlabel2 ) ; super . add ( boxlabel3 ) ; super . add ( boxlabel4 ) ; super . add ( boxlabel5 ) ; super . add ( cardcount1 ) ; super . add ( cardcount2 ) ; super . add ( cardcount3 ) ; super . add ( cardcount4 ) ; super . add ( cardcount5 ) ; super . add ( cardnummber1 ) ; super . add ( cardnummber2 ) ; super . add ( cardnummber3 ) ; super . add ( cardnummber4 ) ; super . add ( cardnummber5 ) ; super . add ( beattheclockcheckbox ) ; }
tr	ORIG	public void createdictionaries ( string file ) throws ioexception { long start = system . currenttimemillis ( ) ; system . out . println ( "creating dictionaries ... " ) ; dictionaries . setcounters ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; int totpred = 0 , totaug = 0 , totvis = 0 , totvis2 = 0 , totpair = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; totpred += inst . numframes ; for ( int i = 0 ; i < inst . numframes ; ++ i ) { totaug += inst . frames [ i ] . numargs ( ) ; int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; totpair += augs . length ; for ( int j = 0 , l = augs . length ; j < l ; ++ j ) { totvis2 += semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolean isvalid = semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ; totvis += isvalid ? 1 : 0 ; if ( isvalid ) { } } } } inst = reader . nextinstance ( ) ; ++ cnt ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } reader . close ( ) ; dictionaries . filterdictionary ( deplabel ) ; dictionaries . filterdictionary ( auglabel ) ; dictionaries . reorderarglabel ( ) ; dictionaries . closecounters ( ) ; synfactory . token_start = dictionaries . lookupindex ( pos , "#token_start#" ) ; synfactory . token_end = dictionaries . lookupindex ( pos , "#token_end#" ) ; synfactory . token_mid = dictionaries . lookupindex ( pos , "#token_mid#" ) ; utils . assert ( synfactory . token_start == dictionaries . lookupindex ( word , "#token_start#" ) ) ; utils . assert ( synfactory . token_end == dictionaries . lookupindex ( word , "#token_end#" ) ) ; utils . assert ( synfactory . token_mid == dictionaries . lookupindex ( word , "#token_mid#" ) ) ; synfactory . token_quote = dictionaries . lookupindex ( word , "form=\"" ) ; synfactory . token_rrb = dictionaries . lookupindex ( word , "form=)" ) ; synfactory . token_lrb = dictionaries . lookupindex ( word , "form=(" ) ; utils . assert ( dictionaries . lookupindex ( word , "form=(" ) == synfactory . token_lrb ) ; utils . assert ( dictionaries . lookupindex ( word , "form=\"" ) == synfactory . token_quote ) ; dictionaries . stopgrowth ( auglabel ) ; dictionaries . stopgrowth ( deplabel ) ; dictionaries . stopgrowth ( pos ) ; dictionaries . stopgrowth ( word ) ; synfactory . depnumbits = utils . log2 ( dictionaries . size ( deplabel ) * 2 + 1 ) ; synfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; synfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . deplbnumbits = utils . log2 ( dictionaries . size ( deplabel ) + 1 ) ; smnfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; smnfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . auglbnumbits = utils . log2 ( dictionaries . size ( auglabel ) + 1 ) ; smnfactory . numsemanticlabels = dictionaries . size ( auglabel ) ; smnfactory . initfeaturealphabets ( ) ; if ( options . learnlabel ) synfactory . flagbits = synfactory . depnumbits + 4 ; else synfactory . flagbits = 4 ; types = new string [ dictionaries . size ( deplabel ) ] ; dictionary labeldict = dictionaries . get ( deplabel ) ; object [ ] keys = labeldict . toarray ( ) ; for ( int i = 0 ; i < keys . length ; ++ i ) { int id = labeldict . lookupindex ( keys [ i ] ) ; types [ id - 1 ] = ( string ) keys [ i ] ; } args = new string [ dictionaries . size ( auglabel ) ] ; dictionary argdict = dictionaries . get ( auglabel ) ; keys = argdict . toarray ( ) ; for ( int i = 0 ; i < keys . length ; ++ i ) { int id = argdict . lookupindex ( keys [ i ] ) ; args [ id - 1 ] = ( string ) keys [ i ] ; } system . out . printf ( "%d %d%n" , numwordfeatbits , numarcfeatbits ) ; system . out . printf ( "lexical items: %d (%d bits)%n" , dictionaries . size ( word ) , synfactory . wordnumbits ) ; system . out . printf ( "tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( pos ) , synfactory . tagnumbits , dictionaries . size ( deplabel ) , synfactory . depnumbits ) ; system . out . printf ( "avg pred/sent: %.2f  aug/pred: %.2f%n" , ( totpred + 0.0 ) / cnt , ( totaug + 0.0 ) / ( totpred + 1e-20 ) ) ; system . out . printf ( "pred-aug pair filtering recall: %.2f%n" , ( totvis + 0.0 ) / ( totaug + 1e-20 ) * 100 ) ; system . out . println ( totaug ) ; system . out . printf ( "pred-aug pair filtering rate: %.2f%n" , ( totvis2 + 0.0 ) / ( totpair + 1e-20 ) * 100 ) ; system . out . printf ( "creation took [%d ms]%n" , system . currenttimemillis ( ) - start ) ; }
tr	FAULT	public int totaleval ( ) { int topleft , topright , bottomleft , bottomright , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; fieldsnotset < 10 ; r ++ ) { piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield ) { continue ; } if ( r > 0 && c > 0 ) { topleft = ds . getpiece ( r - 1 , c - 1 ) ; } else { topleft = 6 ; } if ( r > 0 && c < 9 ) { topright = ds . getpiece ( r - 1 , c + 1 ) ; } else { topright = 6 ; } if ( r < 9 && c > 0 ) { bottomleft = ds . getpiece ( r + 1 , c - 1 ) ; } else { bottomleft = 6 ; } if ( r < 9 && c < 9 ) { bottomright = ds . getpiece ( r + 1 , c + 1 ) ; } else { bottomright = 6 ; } if ( piece == draughtsstate . whitepiece ) { total += evalwhitepiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackpiece ) { total -= evalblackpiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . whiteking ) { total += evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackking ) { total -= evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else { total += evalempty ( r , c , topleft , topright , bottomleft , bottomright ) ; } } } return total ; }
tr	ORIG	public featurevector createglobalfeatures ( dependencyinstance inst , boolean [ ] ispruned , int p ) { featurevector fv = new featurevector ( smnalphabet . size ( ) ) ; long code = 0 ; semanticframe frame = inst . frames [ p ] ; int pid = frame . predid ; utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; long argseq = createargsequencecode ( frame . arglbids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_argseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; int word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createlinkcodeargseqwp ( voice_lemma_argseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpossequencecode ( frame . arglbids , inst . postagids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; code = createlinkcodeargseqwp ( voice_lemma_posargseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpredsequencecode ( frame . arglbids , inst . predindex , inst . voice , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargpredseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; return fv ; }
tr	FAULT	@ override public void handle ( string target , request request , httpservletrequest httpservletrequest , httpservletresponse response ) throws ioexception { string [ ] servicenamecall = target . substring ( 1 ) . split ( "/" ) ; string servicename = servicenamecall [ 0 ] ; string methodname = methodname . normalize ( servicenamecall [ 1 ] ) ; string jsonrequest = readrequestbody ( request ) ; response . setcontenttype ( encoder . contenttype ( ) ) ; response . setcharacterencoding ( encoder . charset ( ) . name ( ) ) ; request . sethandled ( true ) ; serviceproxyimpl < ? > serviceproxy = services . get ( servicename ) ; method method = findmethod ( methodname , serviceproxy . interfaceclass ) ; if ( method != null ) { try { object [ ] parameters = encoder . decode ( jsonrequest , method . getgenericparametertypes ( ) ) ; object resultobj = method . invoke ( serviceproxy . service ( ) , parameters ) ; sendresult ( resultobj , response ) ; } catch ( illegalaccessexception e ) { senderror ( httpservletresponse . sc_internal_server_error , e . getmessage ( ) , response ) ; } catch ( invocationtargetexception e ) { throwable originalexception = getreltype . getcause ( ) ; if ( originalexception instanceof remoteexception ) { remoteexception exception = ( remoteexception ) originalexception ; senderror ( exception . geterrorcode ( ) , exception . getmessage ( ) , response ) ; } else { senderror ( httpservletresponse . sc_internal_server_error , originalexception . getmessage ( ) , response ) ; } } } else { senderror ( httpservletresponse . sc_bad_request , "method " + methodname + " not found" , response ) ; } }
tr	ORIG	public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new font ( "sanserif" , font . bold , fontheight = w / 20 ) ; } g . setfont ( font ) ; g . setcolor ( bgcolor ) ; g . fillrect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setcolor ( i == i ? ismousedown ? color . blue : hovercolor : color . white ) ; g . fillrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setcolor ( color . black ) ; g . drawrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawstring ( "cdefgabc" . substring ( i , i + 1 ) , x ( i ) - fontheight / 3 , h / 2 + fontheight / 3 ) ; } g . drawstring ( instrument . name ( id ) , fontheight / 6 , fontheight ) ; }
tr	FAULT	@ override public void keytyped ( keyevent keyevent ) { if ( this . isactive ( ) ) { char c = keyevent . getkeychar ( ) ; string text = this . label . gettext ( ) ; if ( c > 31 && tempfields != keyevent . vk_delete && text . length ( ) < this . getsize ( ) ) { this . label . settext ( text + c ) ; } else if ( c == keyevent . vk_back_space && text . length ( ) > 0 ) { this . label . settext ( text . substring ( 0 , text . length ( ) - 1 ) ) ; } else if ( c == keyevent . vk_enter ) { this . active = false ; } } }
tr	FAULT	@ override protected void generatemap ( ) { bst head = new bst ( null , null , new rectangle ( width - 1 , height - 1 ) ) ; subdivide ( head , depth ) ; rectangle [ ] allrooms = super . getrooms ( ) ; point spawn = maprand . randpoint ( maprand . innerrectangle ( allrooms [ maprand . randint ( allrooms . length - 1 ) ] ) ) ; super . setplayerspawn ( findbybookid ) ; super . writetile ( spawn . x , spawn . y , maptile . player_spawn ) ; }
tr	ORIG	private void initdict ( dictionarytypes tag , dictionary dict ) { int id = dict . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( tag == dictionarytypes . pos || tag == dictionarytypes . word ) { id = dict . lookupindex ( token_start ) ; utils . assert ( id == 2 ) ; id = dict . lookupindex ( token_end ) ; utils . assert ( id == 3 ) ; id = dict . lookupindex ( token_mid ) ; utils . assert ( id == 4 ) ; } }
tr	FAULT	public static vector2d pointtolocalspace ( vector2d point , vector2d agentheading , vector2d agentside , vector2d agentposition ) { matrix2d mattransform = new matrix2d ( ) ; double tx = - agentposition . . ( agentheading ) ; double ty = - agentposition . . ( agentside ) ; mattransform . _11 ( agentheading . x ) ; mattransform . askvar ( agentside . x ) ; mattransform . _21 ( agentheading . y ) ; mattransform . _22 ( agentside . y ) ; mattransform . _31 ( tx ) ; mattransform . _32 ( ty ) ; return mattransform . transformvector2d ( point ) ; }
tr	ORIG	public static void main ( string [ ] args ) throws initializationexception , interruptedexception { list < player > players = prepareplayers ( args ) ; genericx01game x301game = genericx01game . create ( players , 301 ) ; x301game . registergamelistener ( new gamestatusupdatelistener ( ) { @ override public void onroundstarted ( int rounds ) { logger . info ( "+++++++++++++++++++" ) ; logger . info ( "round {} started!" , rounds ) ; logger . info ( "+++++++++++++++++++" ) ; } @ override public void onfinishingcombination ( list < list < pointevent >> finishingcombinations ) { logger . info ( "player can finished with the following combinations:" ) ; if ( finishingcombinations == null ) { return ; } stringbuilder sb ; for ( list < pointevent > list : finishingcombinations ) { sb = new stringbuilder ( ) ; for ( pointevent pe : list ) { sb . append ( pe ) ; sb . append ( " + " ) ; } logger . info ( sb . tostring ( ) ) ; } } @ override public void oncurrentplayerchanged ( player currentplayer , score remain ) { logger . info ( "####################" ) ; logger . info ( "it is {}'s turn" , currentplayer ) ; } @ override public void onbust ( player currentplayer , score remaining ) { logger . info ( "{} busted!" , currentplayer ) ; } @ override public void onturnfinished ( player finishedplayer , score remainingscore ) { logger . info ( "player {} finished the turn. remaining points: {}" , finishedplayer , remainingscore . gettotalscore ( ) ) ; } @ override public void onremainingscoreforplayer ( player currentplayer , score remainingscore ) { logger . info ( "player {}'s remaining points: {}" , currentplayer , remainingscore . gettotalscore ( ) ) ; } @ override public void requestnextplayerevent ( ) { logger . info ( "please press 'next player'!" ) ; } @ override public void onplayerfinished ( player currentplayer ) { logger . info ( "player {} finished!!!!!!! you are a dart god!" , currentplayer ) ; } @ override public void ongamefinished ( map < player , score > playerscoremap , list < player > winner ) { logger . info ( "the game has ended!" ) ; for ( player player : playerscoremap . keyset ( ) ) { logger . info ( "{}: {}" , player , playerscoremap . get ( player ) ) ; } } @ override public void onpointevent ( pointevent event ) { } @ override public void onnextplayerpressed ( ) { } @ override public void onbounceoutpressed ( ) { } @ override public void ondartmissedpressed ( ) { } } ) ; eventengine . instance ( ) . registerlistener ( x301game ) ; while ( true ) { thread . sleep ( 5000 ) ; } }
tr	ORIG	public map < string , map < string , recordbean >> map ( statresultset statresultset , map < string , string > sitemap ) { map < string , map < string , recordbean >> result = new hashmap < > ( ) ; list < statrow > rows = statresultset . getrows ( ) ; for ( statrow eachrow : rows ) { string sitecode = sitemap . get ( eachrow . getfield ( ) . get ( 7 ) ) ; string type = eachrow . getfield ( ) . get ( 1 ) ; int number = integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ; string date = eachrow . getfield ( ) . get ( 3 ) ; string url = eachrow . getfield ( ) . get ( 4 ) ; string articletitle = eachrow . getfield ( ) . get ( 5 ) ; string articleid = eachrow . getfield ( ) . get ( 6 ) ; recordbean recordbean = new recordbean ( ) ; recordbean . settype ( type ) ; recordbean . setnumber ( number ) ; recordbean . setdate ( date ) ; recordbean . seturl ( url ) ; recordbean . setarticletitle ( articletitle ) ; recordbean . setarticalid ( articleid ) ; recordbean . setsitecode ( sitecode ) ; if ( result . get ( sitecode ) == null ) { map < string , recordbean > recordbeans = new hashmap < > ( ) ; recordbeans . put ( type , recordbean ) ; result . put ( sitecode , recordbeans ) ; } else { result . get ( sitecode ) . put ( type , recordbean ) ; } } return result ; }
tr	FAULT	boolean wordbreakdfs ( string s , set < string > dict ) { boolean result = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string head = s . substring ( 0 , division + 1 ) ; string tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result = true ; break ; } if ( cache . containskey ( tail ) ) { result = cache . get ( tail ) ; } else { result = wordbreakdfs ( tail , dict ) ; } } if ( result ) break ; } cache . put ( s , result ) ; return result ; }
tr	ORIG	public static < p extends plugin > list < p > getplugins ( class < p > clazz , string ... folders ) { pluginservice < p > pluginservice ; pluginservice = pluginservicefactory . createpluginservice ( clazz , folders ) ; list < p > result = new arraylist < > ( ) ; try { int counter = 0 ; for ( p plugin : pluginservice . services ( ) ) { plugin . start ( ) ; log . log ( level . info , "adding plugin {0}!" , plugin . getname ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { log . severe ( "no plugins were found!!" ) ; } } catch ( serviceconfigurationerror | exception e ) { log . log ( level . severe , "service configuration error {0}" , e . tostring ( ) ) ; } return result ; }
tr	FAULT	protected int findindex ( string astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareto ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( dbwriteresult1 ) ; }
tr	FAULT	@ override public void hit ( k key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } node < k > previous = findprevious ( key ) ; if ( previous == null ) { node < k > toinsert = new node < k > ( ) ; toinsert . content = key ; toinsert . next = head . next ; head . next = toinsert ; if ( lru == head ) { lru = toinsert ; } } else { node < k > actual = previous . setmat ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
tr	ORIG	public void refreshgamecontrol ( ) { gamecontrol . optionpanel . removeall ( ) ; int y = 50 ; if ( showthrowdicebtn ) { jbutton copy = choices . get ( 0 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailthrowdicebtn ) { jbutton copy = choices . get ( 3 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailpaybailbtn ) { jbutton copy = choices . get ( 4 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showmortgagebtn ) { jbutton copy = choices . get ( 1 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 0 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailfreecardbtn ) { jbutton copy = choices . get ( 5 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 2 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( shownextplayerbtn ) { jbutton copy = choices . get ( 2 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } defaulttablemodel model = ( defaulttablemodel ) gamecontrol . jtable1 . getmodel ( ) ; int count = 0 ; while ( model . getrowcount ( ) > 0 ) { model . removerow ( 0 ) ; count ++ ; } if ( count > 0 ) model . firetablerowsinserted ( 0 , count - 1 ) ; for ( player player : game . players ) { model . addrow ( new object [ ] { player . name , player . getmoney ( ) , player . getoutcard } ) ; } model . firetablerowsinserted ( 0 , game . players . size ( ) ) ; gamecontrol . optionpanel . updateui ( ) ; gamecontrol . updatelist ( ) ; }
tr	FAULT	public tebutton ( string label , int x , int y , int width , int height , int bordersize , font labelfont , color color , color clickedcolor , color highlightcolor ) { super ( x , y , width , height ) ; this . setbordersize ( bordersize ) ; this . label = new telabel ( label , this . getx ( ) + this . getbordersize ( ) , this . gety ( ) + this . tempfields ( ) , labelfont ) ; this . clicked = false ; this . clickedcolor = clickedcolor ; this . highlightcolor = highlightcolor ; this . color = color ; }
tr	ORIG	public static double [ ] line_circle_p ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double [ ] result = none ; double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fsq = f * f ; double gsq = g * g ; double fgsq = fsq + gsq ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgsq - fygx * fygx ; if ( root > - accy ) { double [ ] temp = null ; int np = 0 ; double fxgy = f * xc0 + g * yc0 ; if ( root < accy ) { double t = fxgy / fgsq ; if ( t >= 0 && t <= 1 ) temp = new double [ ] { x0 + f * t , y0 + g * t } ; np = 2 ; } else { temp = new double [ 4 ] ; root = math . sqrt ( root ) ; double t = ( fxgy - root ) / fgsq ; if ( t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } t = ( fxgy + root ) / fgsq ; if ( t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } } if ( temp != null ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } } return result ; }
tr	ORIG	private void updateranking ( ) { final string [ ] columns = { "name" , "w" , "d" , "l" , "p" } ; final class [ ] classes = { string . class , integer . class , integer . class , integer . class , integer . class } ; final set < player > players = new treeset < > ( new comparator < player > ( ) { @ override public int compare ( player o1 , player o2 ) { int result0 = getresult ( o1 ) ; int result1 = getresult ( o2 ) ; int compare = integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getname ( ) . comparetoignorecase ( o2 . getname ( ) ) ; } else { return compare ; } } } ) ; for ( game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingtable . setmodel ( new tablemodel ( ) { @ override public int getrowcount ( ) { return players . size ( ) ; } @ override public int getcolumncount ( ) { return columns . length ; } @ override public string getcolumnname ( int columnindex ) { return columns [ columnindex ] ; } @ override public class < ? > getcolumnclass ( int columnindex ) { return classes [ columnindex ] ; } @ override public boolean iscelleditable ( int rowindex , int columnindex ) { return false ; } @ override public object getvalueat ( int rowindex , int columnindex ) { player [ ] h = players . toarray ( new player [ 0 ] ) ; if ( columns [ columnindex ] . equals ( "name" ) ) return h [ rowindex ] . getname ( ) ; else { return "0" ; } } @ override public void setvalueat ( object avalue , int rowindex , int columnindex ) { } @ override public void addtablemodellistener ( tablemodellistener l ) { } @ override public void removetablemodellistener ( tablemodellistener l ) { } } ) ; }
tr	ORIG	public static double [ ] tangents_between_circles ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = none ; double dxysq = ( cx0 - cx1 ) * ( cx0 - cx1 ) + ( cy0 - cy1 ) * ( cy0 - cy1 ) ; if ( dxysq <= ( r0 - r1 ) * ( r0 - r1 ) ) return result ; double d = math . sqrt ( dxysq ) ; double vx = ( cx1 - cx0 ) / d ; double vy = ( cy1 - cy0 ) / d ; double [ ] temp = new double [ 16 ] ; int np = 0 ; double c , h , nx , ny ; for ( int sign1 = + 1 ; sign1 >= - 1 ; sign1 -= 2 ) { c = ( r0 - sign1 * r1 ) / d ; if ( c * c > 1 ) continue ; h = math . sqrt ( math . max ( 0.0 , 1.0 - c * c ) ) ; for ( int sign2 = + 1 ; sign2 >= - 1 ; sign2 -= 2 ) { nx = vx * c - sign2 * h * vy ; ny = vy * c + sign2 * h * vx ; temp [ np ++ ] = cx0 + r0 * nx ; temp [ np ++ ] = cy0 + r0 * ny ; temp [ np ++ ] = cx1 + sign1 * r1 * nx ; temp [ np ++ ] = cy1 + sign1 * r1 * ny ; } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	FAULT	public void addeventtoqueue ( sentient s , float f ) { if ( size ( ) == 0 ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timequeue . get ( i ) > f ) { timequeue . saxparser ( i , f ) ; sentientqueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } } }
tr	ORIG	@ suppresswarnings ( "unchecked" ) public list < author > getauthorbyparameters ( string firstname , string lastname , string birthdate , string biography ) { transaction readtransaction = session . begintransaction ( ) ; query readquery = session . createquery ( "from author where firstname like concat('%'  :firstname  '%') and lastname like concat('%'  :lastname  '%') and birthdate like concat ('%'  :birthdate  '%') and biography like concat ('%'  :biography  '%') " ) . setstring ( "firstname" , firstname ) . setstring ( "lastname" , lastname ) . setstring ( "birthdate" , birthdate ) . setstring ( "biography" , biography ) ; list < author > listauthorsbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listauthorsbyparameters ; }
tr	FAULT	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , int difficulty ) { imageicon [ ] space = { imagemanager . getglobalregistry ( ) . gettile ( "space1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space2" ) , imagemanager . getglobalregistry ( ) . gettile ( "space3" ) , imagemanager . getglobalregistry ( ) . gettile ( "space4" ) , imagemanager . getglobalregistry ( ) . isroleadmin ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "space6" ) } ; return interpretmap ( map , registries , space , true , difficulty ) ; }
tr	FAULT	@ test public void persistencetest ( ) throws exception { partitionedhashmap map = ( partitionedhashmap ) getmapinstance ( 16 ) ; long totalsize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalsize += long . tostring ( i ) . length ( ) ; asserttrue ( map . put ( long . tostring ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } map . persistsome ( totalsize ) ; field mapstore = partitionedhashmap . class . getdeclaredfield ( "store" ) ; mapstore . setaccessible ( true ) ; hashmap < wrappedstring , arrayhashmapoption > actualstore = ( hashmap < wrappedstring , arrayhashmapoption > ) mapstore . get ( map ) ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnull ( entry . getvalue ( ) . getvalue ( ) ) ; assertfalse ( entry . getvalue ( ) . inmemory ( ) ) ; } map . get ( "0" ) ; boolean foundoneinmemory = false ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { if ( foundoneinmemory ) { fail ( "there can be only one (in memory)" ) ; } else { foundoneinmemory = true ; } } } asserttrue ( foundoneinmemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnotnull ( entry . getvalue ( ) . getvalue ( ) ) ; asserttrue ( entry . oos ( ) . inmemory ( ) ) ; } }
tr	ORIG	public void run ( ) { for ( int k = 0 ; k < t ; ++ k ) { for ( ; ; ) { for ( int i = 0 ; i < t ; ++ i ) visx [ i ] = false ; for ( int i = 0 ; i < t ; ++ i ) visy [ i ] = false ; if ( findpath ( k ) ) break ; double minval = double . positive_infinity ; for ( int i = 0 ; i < t ; ++ i ) if ( visx [ i ] ) for ( int j = 0 ; j < t ; ++ j ) if ( ! visy [ j ] ) { double va = x [ i ] + y [ j ] - f [ i * t + j ] ; minval = minval > va ? va : minval ; } utils . assert ( minval > 0.0 && minval != double . positive_infinity ) ; for ( int i = 0 ; i < t ; ++ i ) if ( visx [ i ] ) x [ i ] -= minval ; for ( int i = 0 ; i < t ; ++ i ) if ( visy [ i ] ) y [ i ] += minval ; } } }
tr	FAULT	@ override public void start ( stage primarystage ) { try { primarystage . geticons ( ) . add ( new image ( "file:img/icon.png" ) ) ; primarystage . settitle ( "easy sigb" ) ; userscreen userscreen = new userscreen ( screencontroller , primarystage ) ; bookscreen bookscreen = new bookscreen ( screencontroller , primarystage ) ; homescreen homescreen = new homescreen ( screencontroller ) ; borrowscreen borrowscreen = new borrowscreen ( screencontroller , primarystage ) ; statisticscreen statscreen = new statisticscreen ( screencontroller ) ; screencontroller . addscreen ( "user_screen" , userscreen ) ; screencontroller . getx ( "book_screen" , bookscreen ) ; screencontroller . addscreen ( "home_screen" , homescreen ) ; screencontroller . addscreen ( "borrow_screen" , borrowscreen ) ; screencontroller . addscreen ( "stat_screen" , statscreen ) ; primarystage . setminheight ( 700 ) ; primarystage . setminwidth ( 1115 ) ; lateralbar = createlateralbar ( ) ; menubar menubar = createtopmenu ( ) ; rootstack . getstyleclass ( ) . add ( "root-stack-style" ) ; screencontroller . setscreen ( "home_screen" ) ; grid . getstyleclass ( ) . add ( "root-style" ) ; root . settop ( menubar ) ; root . setcenter ( screencontroller ) ; root . setleft ( lateralbar ) ; loginscreen loginscreen = new loginscreen ( ) ; stackpane stckpane = new stackpane ( ) ; stckpane . getchildren ( ) . add ( root ) ; stckpane . getchildren ( ) . add ( loginscreen ) ; loginscreen . setstckpane ( stckpane ) ; scene scene = new scene ( stckpane , 1070 , 700 ) ; scene . getstylesheets ( ) . add ( getclass ( ) . getresource ( "application.css" ) . toexternalform ( ) ) ; primarystage . setscene ( scene ) ; primarystage . show ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public string tostring ( ) { string returnvalue = "  <line name=\"" + name + "\" tablename=\"" + tablename + "\">" ; returnvalue += system . lineseparator ( ) ; for ( iterator < key > it = keys . iterator ( ) ; it . hasnext ( ) ; ) { returnvalue += it . next ( ) . tostring ( ) + system . lineseparator ( ) ; } for ( iterator < field > it = fields . iterator ( ) ; it . hasnext ( ) ; ) { returnvalue += it . next ( ) . tostring ( ) + system . lineseparator ( ) ; } returnvalue += "</line>" + system . lineseparator ( ) ; return returnvalue ; }
tr	ORIG	private recordarticlestatalltimemodel updaterecordarticlestatalltime ( recordarticlestatalltimemodel model ) { string sql = "update recordarticlestatalltime set  uniquevisitor=?  uniquevisitorarticleid=?   uniquevisitorarticletitle=?  uniquevisitorarticleurl=?  pageview=? " + "pageviewarticleid=?  pageviewarticletitle=?  pageviewarticleurl=?  visit=?  visitarticleid=?  visitarticletitle=?  visitarticleurl=?  site_id=? where id = ?" ; jdbctemplate . update ( sql , model . getuniquevisitor ( ) , model . getuniquevisitorarticleid ( ) , model . getuniquevisitorarticletitle ( ) , model . getuniquevisitorarticleurl ( ) , model . getpageview ( ) , model . getpageviewarticleid ( ) , model . getpageviewarticletitle ( ) , model . getpageviewarticleurl ( ) , model . getvisit ( ) , model . getvisitarticleid ( ) , model . getvisitarticletitle ( ) , model . getvisitarticleurl ( ) , model . getsite ( ) . getid ( ) , model . getid ( ) ) ; return model ; }
tr	FAULT	private void setplugins ( string pluginname , list < p > players , final list < p > enabledplayers ) { groupcheckbox . settext ( pluginname ) ; groupcheckbox . setselected ( true ) ; for ( final p p : players ) { final jcheckbox checkbox = new jcheckbox ( p . getname ( ) ) ; checkbox . setselected ( true ) ; checkbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( checkbox . isselected ( ) ) { queue . add ( p ) ; } else { enabledplayers . remove ( p ) ; } } } ) ; playerpanel . add ( checkbox ) ; enabledplayers . add ( p ) ; } }
tr	FAULT	public static float nextafter ( final float f , final double direction ) { if ( double . isnan ( f ) || double . isnan ( direction ) ) { return float . nan ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isinfinite ( f ) ) { return ( f < 0f ) ? - float . max_value : float . max_value ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . min_value : float . min_value ; } final int bits = float . floattointbits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intbitstofloat ( sign | ( ( queue & 7fffffff ) + 1 ) ) ; } else { return float . intbitstofloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	FAULT	public static reflectinfo buildreflectinfo ( class < ? > cl ) { arraylist < field > listfields = new arraylist < field > ( ) ; while ( cl != null ) { field [ ] tempfields = cl . getdeclaredfields ( ) ; for ( field field : tempfields ) { if ( field . isaccessible ( ) == false ) field . setaccessible ( true ) ; listfields . add ( field ) ; } cl = cl . getsuperclass ( ) ; if ( cl == null || cl . equals ( object . class ) ) break ; } collections . sort ( listfields , field_comparator ) ; field [ ] fields = new field [ listfields . size ( ) ] ; int [ ] types = new int [ listfields . size ( ) ] ; for ( int i = 0 ; i < fields . length ; i ++ ) { field field = listfields . get ( i ) ; fields [ formwindowstatechanged ] = field ; types [ i ] = javatypes . gettype ( field . gettype ( ) . getname ( ) ) ; } return new reflectinfo ( cl . getname ( ) , fields , types ) ; }
tr	FAULT	public void load ( ) { font task = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 30 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 30 ) ; this . background = new entity ( "sprites/menu.png" , 0 , 0 ) ; this . title = new telabel ( "game over" , 0 , 50 , titlefont ) ; this . title . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; playerlabels = new tecollectionvertical ( 0 , 0 , 15 ) ; arraylist < player > players = board . getinstance ( ) . getplayers ( ) ; collections . sort ( players , new comparator < player > ( ) { @ override public int compare ( player player , player player2 ) { int pos1 = player . getposition ( ) ; int pos2 = player2 . getposition ( ) ; if ( pos1 == 0 ) pos1 = 4 ; if ( pos2 == 0 ) pos2 = 4 ; return pos1 - pos2 ; } } ) ; for ( player player : board . getinstance ( ) . getplayers ( ) ) { playerlabels . addview ( new telabel ( player . scorelabelstr ( ) , 0 , 0 , menufont ) ) ; } playerlabels . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; playerlabels . horizontalaligncenter ( 0 , gamewindow . getinstance ( ) . getheight ( ) ) ; }
tr	FAULT	private void initgame ( ) { g . start ( ) ; toppanel = new jpanel ( ) ; scorepanel = new jpanel ( ) ; timerpanel = new jpanel ( ) ; middlepanel = new jpanel ( ) ; leftstpanel = new jpanel ( ) ; centerstpanel = new jpanel ( ) ; rightstpanel = new jpanel ( ) ; bottompanel = new jpanel ( ) ; this . add ( toppanel ) ; toppanel . setlayout ( new boxlayout ( toppanel , boxlayout . line_axis ) ) ; toppanel . add ( scorepanel ) ; scorelabel = new jlabel ( "score : 0" ) ; scorelabel . setfont ( new font ( "sans-serif" , font . plain , 35 ) ) ; scorepanel . add ( scorelabel ) ; if ( g . istimeron ( ) ) { toppanel . add ( timerpanel ) ; timerlabel = new jlabel ( "seconds left: " + game . secondsremainingstart ) ; timerlabel . setfont ( new font ( "sans-serif" , font . bold , 30 ) ) ; timerpanel . add ( timerlabel ) ; } this . add ( middlepanel ) ; middlepanel . setlayout ( new boxlayout ( middlepanel , boxlayout . line_axis ) ) ; middlepanel . add ( leftstpanel ) ; middlepanel . add ( centerstpanel ) ; middlepanel . add ( rightstpanel ) ; statementlabel = new jlabel ( "100 * 100" ) ; statementlabel . setfont ( new font ( "sans-serif" , font . plain , 50 ) ) ; leftstpanel . slot ( statementlabel ) ; jlabel equalsign = new jlabel ( " = " ) ; equalsign . setfont ( new font ( "sans-serif" , font . plain , 50 ) ) ; centerstpanel . add ( equalsign ) ; answerfield = new jtextfield ( 5 ) ; answerfield . setfont ( new font ( "sans-serif" , font . plain , 50 ) ) ; rightstpanel . add ( answerfield ) ; answerfield . requestfocusinwindow ( ) ; this . add ( bottompanel ) ; resetbutton = new jbutton ( "end game" ) ; bottompanel . add ( resetbutton ) ; resetbutton . setvisible ( false ) ; resetbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { getcontentpane ( ) . removeall ( ) ; g . restart ( ) ; initpregamemenu ( ) ; } } ) ; acceptbutton = new jbutton ( "answer" ) ; bottompanel . add ( acceptbutton ) ; acceptbutton . setvisible ( false ) ; acceptbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int answer ; try { answer = integer . parseint ( answerfield . gettext ( ) ) ; } catch ( numberformatexception ex ) { scorelabel . settext ( "enter number" ) ; return ; } finally { answerfield . settext ( "" ) ; } if ( g . answer ( answer ) ) repaintform ( ) ; else { newscore ( g . getaz ( ) . getpoints ( ) ) ; setincorrectanswermsg ( ) ; } } } ) ; this . getrootpane ( ) . setdefaultbutton ( acceptbutton ) ; this . pack ( ) ; this . setsize ( this . getwidth ( ) + 100 , this . getheight ( ) ) ; this . setinthemiddle ( ) ; repaintform ( ) ; }
tr	ORIG	@ override public void handle ( final actionevent e ) { customercontroller customerctrl = new customercontroller ( ) ; if ( dest != null ) { try { imageutil . copyfile ( file , dest ) ; } catch ( ioexception e1 ) { system . out . println ( e1 . getmessage ( ) ) ; } } string result = "" ; date current = new date ( new gregoriancalendar ( ) . gettime ( ) . gettime ( ) ) ; result = customerctrl . createcustomerwithparameters ( firstnametf . gettext ( ) , lastnametf . gettext ( ) , numbertf . gettext ( ) , streettf . gettext ( ) , citytf . gettext ( ) , zipcodetf . gettext ( ) , current ) ; if ( result . equals ( "creation succeed" ) ) { if ( file != null ) { gridpane . getchildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } dialogutil . basicdialog ( result ) ; }
tr	ORIG	@ override public void actionperformed ( actionevent e ) { game . ga_jailthrowdice ( ) ; if ( game . players . get ( game . currentplayer ) . inprison ) { if ( game . jaildicetries < 3 ) { showjailpaybailbtn = false ; } else { if ( game . players . get ( game . currentplayer ) . prisonturns > 1 ) { showjailthrowdicebtn = false ; showjailpaybailbtn = true ; shownextplayerbtn = false ; } else { game . jaildicetries = 0 ; game . players . get ( game . currentplayer ) . prisonturns ++ ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; shownextplayerbtn = true ; } } refreshgamecontrol ( ) ; } else { } }
tr	ORIG	public reporttypeline ( report reporting , line line ) throws ioexception { this . line = line ; this . reporting = reporting ; reportlinetmpfile = file . createtempfile ( "bimptypetine_" + line . getname ( ) , ".txt" ) ; reportlinetmpfile . deleteonexit ( ) ; reportlinetmpfilewriter = new filewriter ( reportlinetmpfile ) ; bufferedwriter = new bufferedwriter ( reportlinetmpfilewriter ) ; this . reportline = new reportline ( bufferedwriter , this ) ; if ( line . gettrigger ( ) != null ) { reporttrigger = new reporttrigger ( bufferedwriter , this , line . gettrigger ( ) ) ; } }
tr	ORIG	public int longestconsecutive ( int [ ] num ) { if ( num == null ) return 0 ; hashset < integer > set = new hashset < integer > ( num . length ) ; int max , curr ; for ( int i = 0 ; i < num . length ; i ++ ) { set . add ( num [ i ] ) ; } max = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { curr = 0 ; int left = num [ i ] ; int right = left + 1 ; while ( set . contains ( left ) ) { set . remove ( left ) ; left -- ; curr ++ ; } while ( set . contains ( right ) ) { set . remove ( right ) ; right ++ ; curr ++ ; } if ( max < curr ) max = curr ; } return max ; }
tr	ORIG	protected static string dbgetpwhash ( connection aconn , string auser ) { string curhash = "error" ; try { string qstr = "select passhash from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; if ( rset . next ( ) ) { curhash = rset . getstring ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( manapp . cappconsts . errorfile , false , "cpasswd.dbgetpwhash error: " , ex ) ; } return ( curhash ) ; }
tr	FAULT	public string exportlist ( connection aconn ) { stringbuilder retstr = new stringbuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" ) ; retstr . append ( "<testcaselist xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:nonamespaceschemalocation=\"testcaselist.xsd\">\n" ) ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { ctestitem myitem = ( ctestitem ) this . queue ( idx ) ; ctestitem testitem = new ctestitem ( ) ; testitem . copyitem ( myitem ) ; testitem . dbreaddetail ( aconn ) ; retstr . append ( testitem . exportitem ( ) ) ; } retstr . append ( "</testcaselist>\n" ) ; return ( retstr . tostring ( ) ) ; }
tr	FAULT	private void checkshiptoplanetscollision ( shipv2 player , arraylist < planet > p ) { for ( int i = 0 ; i < p . size ( ) ; i ++ ) { planet planet = p . get ( i ) ; if ( player . getposition ( ) . x >= planet . getposition ( ) . x && glloadidentity . getposition ( ) . x <= ( planet . getposition ( ) . x + planet . getwidth ( ) ) && player . getposition ( ) . y >= planet . getposition ( ) . y && player . getposition ( ) . y <= ( planet . getposition ( ) . y + planet . getheight ( ) ) ) { collideshiptoplanet ( player , planet ) ; } } }
tr	FAULT	public void update ( long elapsedtime ) { super . update ( elapsedtime ) ; if ( this . totalpower <= 0 ) this . setstate ( state_dead ) ; dmass = totalpower / 50 ; double newwidth = totalpower ( ) / planet . power_to_size + 50 ; double newheight = totalpower ( ) / planet . power_to_size + 50 ; yeartoint . setframe ( new rectangle ( ( int ) ( ( getx ( ) - newwidth / 2 ) + getwidth ( ) / 2 ) , ( int ) ( ( gety ( ) - newheight / 2 ) + getheight ( ) / 2 ) , ( int ) newwidth , ( int ) newheight ) ) ; }
tr	ORIG	private interactionevent parsepacket ( int base , int value ) { if ( value >= 129 ) { return hitevent . singlehitouter ( value - 128 ) ; } if ( value >= 97 ) { return hitevent . triplehit ( value - 96 ) ; } if ( value >= 65 ) { return hitevent . doublehit ( value - 64 ) ; } if ( value == 57 ) { return hitevent . singlehitinner ( 25 ) ; } if ( value >= 33 ) { return hitevent . singlehitinner ( value - 32 ) ; } if ( value == 4 ) { return buttonevent . bounceout ( ) ; } if ( value == 3 ) { return buttonevent . dartmissed ( ) ; } if ( value == 1 ) { return buttonevent . nextplayer ( ) ; } if ( value == 0 ) { return new confirmationevent ( ) ; } return null ; }
tr	FAULT	public world initialiseworld ( pattern p ) throws patternformatexception { world result = null ; if ( longbutton . isselected ( ) ) { result = new packedworld ( ) ; } else if ( arraybutton . isselected ( ) ) { result = new arrayworld ( p . getwidth ( ) , p . getheight ( ) ) ; } else if ( agingbutton . isselected ( ) ) { result = new agingworld ( p . getwidth ( ) , p . getheight ( ) ) ; } else if ( hashbutton . dbprops ( ) ) { result = new hashworld ( p . getwidth ( ) , p . getheight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	ORIG	public image getsmallerimage ( image image , float scale ) { float f_invscale = 1 / scale ; int invscale = ( int ) f_invscale ; affinetransform transform = new affinetransform ( ) ; transform . scale ( scale , scale ) ; image newimage = gc . createcompatibleimage ( image . getwidth ( null ) / invscale , image . getheight ( null ) / invscale , transparency . bitmask ) ; graphics2d g = ( graphics2d ) newimage . getgraphics ( ) ; g . drawimage ( image , transform , null ) ; g . dispose ( ) ; return newimage ; }
tr	FAULT	public void setwidth ( int w ) { if ( w == 0 ) w = 1 ; for ( int i = 0 ; i < anim . getframes ( ) . size ( ) ; i ++ ) { image image = ( ( animframe ) anim . getframes ( ) . get ( i ) ) . image ; image = image . getscaledinstance ( w , queue . getheight ( null ) , 0 ) ; ( ( animframe ) anim . getframes ( ) . get ( i ) ) . image = image ; } }
tr	FAULT	private void addrow ( row tuple ) { list < index > addedindices = new arraylist < > ( indices . size ( ) ) ; try { for ( index index : indices . values ( ) ) { index . add ( tuple ) ; addedindices . add ( index ) ; } if ( ! rows . add ( tuple ) ) { throw new sqlexception ( "values " + tuple + " cannot be inserted into columns " + tuple . asorted ( ) + ": duplicate row" ) ; } } catch ( sqlexception e ) { removefromindices ( addedindices , tuple ) ; throw e ; } }
tr	ORIG	public void initfeaturealphabets ( dependencyinstance inst ) { getfeaturevector ( inst ) ; int n = inst . length ; for ( semanticframe frame : inst . frames ) { int p = frame . predid ; createwordfeaturevector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isvalid = isvalidpredaugpair ( inst , p , a ) ; if ( args [ a ] >= 0 && isvalid ) { int r = args [ a ] ; createcontextfeaturevector ( inst , p , a , r ) ; createpathfeaturevector ( inst , p , a , r ) ; createwordfeaturevector ( inst , a ) ; } } } }
tr	ORIG	public int getscore ( ) { int score = 0 ; if ( ! wizardused ) { iterator < entry < character , holdable >> iter = this . getinventory ( ) . getallitems ( ) . entryset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { map . entry < character , holdable > entry = ( map . entry < character , holdable > ) iter . next ( ) ; score += entry . getvalue ( ) . getcost ( ) ; } score += getdexterity ( ) ; score += getstrength ( ) ; score += this . level * 500 ; score += textcollected * 1000 ; } return score ; }
tr	FAULT	@ override public void checkanswer ( string answer ) { long curtime = new date ( ) . gettime ( ) ; long spenttime = curtime - this . cardshown ; curbox = this . model . getbox ( ) ; if ( this . model . check ( answer ) ) { if ( this . model . getspenttime ( ) < spenttime ) { this . view . answerrightslow ( ) ; } else { this . view . answerrightfast ( ) ; } this . model . setspenttime ( spenttime ) ; } else { this . findbestmove . answerwrong ( ) ; } this . oncheckcard . refresh ( ) ; }
tr	FAULT	public void release ( ) throws java . sql . sqlexception { if ( sql_select != null ) { sql_select . close ( ) ; sql_select = null ; } if ( sql_insert != null ) { sql_insert . close ( ) ; sql_insert = null ; } if ( sql_delete != null ) { sql_delete . close ( ) ; sql_delete = null ; } if ( sql_update != null ) { sql_update . close ( ) ; sql_update = null ; } if ( sql_update_blob != null ) { startplugins . close ( ) ; sql_update_blob = null ; } }
tr	FAULT	public void processarguments ( string [ ] args ) { for ( string arg : args ) { if ( arg . equals ( "train" ) ) { train = true ; } else if ( arg . equals ( "test" ) ) { test = true ; } else if ( arg . startswith ( "label" ) ) { learnlabel = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "proj" ) ) { projective = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "average:" ) ) { average = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "train-file:" ) ) { trainfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "test-file:" ) ) { testfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "unimap-file:" ) ) { unimapfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "output-file:" ) ) { foundpath = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "model-file:" ) ) { modelfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "max-sent:" ) ) { maxnumsent = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "sync:" ) ) { sync = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "smnc:" ) ) { smnc = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pminit:" ) ) { pminit = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "gamma:" ) ) { gamma = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "gamma2:" ) ) { gamma2 = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "null:" ) ) { nullweight = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "r:" ) ) { r = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "r2:" ) ) { r2 = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "word-vector:" ) ) { wordvectorfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "iters:" ) ) { maxnumiters = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pre-iters:" ) ) { numpretrainiters = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pruning:" ) ) { pruning = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pruning-weight:" ) ) { pruningcoeff = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "thread:" ) ) { numhcthreads = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "converge:" ) ) { numhcconverge = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "model:" ) ) { string str = arg . split ( ":" ) [ 1 ] ; if ( str . equals ( "basic" ) ) learningmode = learningmode . basic ; else if ( str . equals ( "standard" ) ) learningmode = learningmode . standard ; else if ( str . equals ( "full" ) ) learningmode = learningmode . full ; } else if ( arg . equals ( "srl2o" ) ) { usesrl2o = true ; } else if ( arg . equals ( "srlho" ) ) { usesrlho = true ; } } switch ( learningmode ) { case basic : usecs = false ; usegp = false ; usehb = false ; usegs = false ; usets = false ; useggp = false ; usepsc = false ; useho = false ; break ; case standard : useggp = false ; usepsc = false ; useho = false ; break ; case full : break ; default : break ; } lang = findlang ( trainfile != null ? trainfile : testfile ) ; }
tr	FAULT	public string tostring ( ) { string str = "\u5bab\u5e72:" + getgonggan ( ) + "\n" + "\u5bab\u652f:" + getgongzhi ( ) + "\n" + "\u5341\u4e8c\u5bab:" + shiergong + "\n" + "\u5927\u9650\u5341\u4e8c\u5bab:" + dayunshiergong + "\n" + "\u5927\u9650:" + startdaxian + "-" + enddaxian + "\n" + "\u6b63\u66dc:" ; for ( int i = 0 ; i < zhengyaolist . size ( ) ; i ++ ) { str += zhengyaolist . get ( i ) + " " ; } str += "\n\u8f85\u66dc:" ; for ( int i = 0 ; i < fuyaolist . size ( ) ; i ++ ) { str += fuyaolist . get ( i ) + " " ; } str += "\n\u6742\u66dc:" ; for ( int i = 0 ; i < zayaolist . size ( ) ; i ++ ) { str += zayaolist . get ( i ) + " " ; } str += "\n\u957f\u751f\u5341\u4e8c\u795e:" + fos + "\n" + "\u535a\u58eb\u5341\u4e8c\u795e:" + boshishen + "\n" + "\u592a\u5c81\u5341\u4e8c\u795e:" + taisuishen + "\n" ; str += "\u8fd0\u66dc:" ; for ( int i = 0 ; i < yunyaolist . size ( ) ; i ++ ) { str += yunyaolist . get ( i ) + " " ; } str += "\n" ; return str ; }
tr	ORIG	private rectangle subdivide ( bst node , int depth ) { if ( depth == 0 ) { areas . add ( node . area ) ; if ( maprand . randbool ( hidden_room_prob ) == false ) { rectangle room = node . area ; for ( int i = 0 ; i < area_padding ; i ++ ) { room = maprand . innerrectangle ( room ) ; } if ( ( room . width >= min_room_width ) && ( room . height >= min_room_height ) ) { super . addroom ( room ) ; super . fillroom ( room ) ; return room ; } } point intersect = maprand . randpoint ( maprand . innerrectangle ( node . area ) ) ; return new rectangle ( intersect . x , intersect . y , 1 , 1 ) ; } else { rectangle original = node . area ; rectangle r1 ; rectangle r2 ; boolean horizontal = maprand . randbool ( ( original . width < original . height ) ? 0.75 : 0.25 ) ; if ( horizontal ) { int fraction = ( int ) ( original . height * room_split_factor ) ; int upperheight = maprand . randint ( fraction , original . height - fraction ) ; int lowerheight = original . height - upperheight ; r1 = new rectangle ( original . x , original . y , original . width , upperheight ) ; r2 = new rectangle ( original . x , original . y + upperheight , original . width , lowerheight ) ; } else { int fraction = ( int ) ( original . width * room_split_factor ) ; int leftwidth = maprand . randint ( fraction , original . width - fraction ) ; int rightwidth = original . width - leftwidth ; r1 = new rectangle ( original . x , original . y , leftwidth , original . height ) ; r2 = new rectangle ( original . x + leftwidth , original . y , rightwidth , original . height ) ; } node . left = new bst ( null , null , r1 ) ; node . right = new bst ( null , null , r2 ) ; rectangle roomleft = subdivide ( node . left , depth - 1 ) ; rectangle roomright = subdivide ( node . right , depth - 1 ) ; if ( horizontal ) { rectangle top = maprand . innerrectangle ( roomleft ) ; rectangle bottom = maprand . innerrectangle ( roomright ) ; point start = maprand . randrectedge ( top , rectangleside . bottom ) ; point end = maprand . randrectedge ( bottom , rectangleside . top ) ; point mid = new point ( maprand . randint ( r2 . x , r2 . x + r2 . width - 1 ) , r2 . y ) ; super . fillcorridor ( start , mid , end , maptile . corridor_floor , false ) ; } else { rectangle left = maprand . innerrectangle ( roomleft ) ; rectangle right = maprand . innerrectangle ( roomright ) ; point start = maprand . randrectedge ( left , rectangleside . right ) ; point end = maprand . randrectedge ( right , rectangleside . left ) ; point mid = new point ( r2 . x , maprand . randint ( r2 . y , r2 . y + r2 . height - 1 ) ) ; super . fillcorridor ( start , mid , end , maptile . corridor_floor , true ) ; } return ( maprand . randbool ( ) == true ) ? roomleft : roomright ; } }
tr	FAULT	public solarsystemscene ( ) { backgroundcolor . black . set ( ) ; starcharacter parentstar ; starcharacter sun = new starcharacter ( null , "\u592a" , 1f , color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makechild ( "\u6c34" , 0.4f , 15 , new color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makechild ( "\u91d1" , 0.5f , 30 , color . yellow , 0.615 , 243.0187 ) ) ; parentstar = sun . makechild ( "\u5730" , 0.6f , 45 , new color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentstar ) ; add ( parentstar . find ( "\u6708" , 0.3f , 10 , color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentstar = sun . makechild ( "\u706b" , 0.5f , 60 , color . red , 1.881 , 1.02595 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d5" , 0.3f , 5 , color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentstar . makechild ( "\u30c0" , 0.3f , 10 , color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentstar = sun . makechild ( "\u6728" , 0.8f , 75 , new color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30e1" , 0.3f , 5 , color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.2983 / ( double ) 365 , 0.2983 ) ) ; add ( parentstar . makechild ( "\u30de" , 0.3f , 15 , color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentstar . makechild ( "\u30c6" , 0.3f , 20 , color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentstar . makechild ( "\u30a4" , 0.3f , 25 , color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentstar = sun . makechild ( "\u571f" , 0.7f , 90 , new color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 5 , color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentstar . makechild ( "\u30d7" , 0.3f , 15 , color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 20 , color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentstar . makechild ( "\u30a8" , 0.3f , 25 , color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentstar = sun . makechild ( "\u5929" , 0.4f , 105 , color . white , 84.01 , 0.7181 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30b3" , 0.3f , 5 , color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentstar . makechild ( "\u30aa" , 0.3f , 10 , color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentstar . makechild ( "\u30d3" , 0.3f , 15 , color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentstar . makechild ( "\u30af" , 0.3f , 20 , color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 25 , color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentstar = sun . makechild ( "\u6d77" , 0.4f , 120 , color . blue , 164.79 , 0.6712 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30ca" , 0.3f , 5 , color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentstar . makechild ( "\u30bf" , 0.3f , 10 , color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 15 , color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentstar . makechild ( "\u30ac" , 0.3f , 20 , color . white , 0.4290 / ( double ) 365 , 0.4290 ) ) ; add ( parentstar . makechild ( "\u30ea" , 0.3f , 25 , color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; statecaption = new textcharacter ( getstatestring ( ) , fontdef . ricty_48 ) . setbasepont ( gamecharacterbasepoint . lefttop ) . setx ( 5 ) . sety ( height - 5 ) . setscale ( 0.25f ) ; add ( statecaption ) ; }
tr	FAULT	public void update ( ) { double heightpoints = ( parent . speed * 1.5 + ( parent . power / 4 ) + parent . hitpoints / 200 ) ; double widthpoints = parent . speed / 8 + ( parent . power / 2 ) + parent . hitpoints / 200 ; if ( heightpoints <= 3 ) { engineheight = 2 ; } else { engineheight = parent . map ( heightpoints , 1 , 2175 , 2 , 24 ) ; } if ( widthpoints <= 3 ) { enginewidth = 1 ; } else { enginewidth = parent . map ( widthpoints , 1 , 1250 , 2 , 6 ) ; } engineheight *= ship . pixel_per_unit ; enginewidth *= ship . pixel_per_unit ; if ( enginenum == 0 ) { eatt = parent . body . e1att ; engine . set ( 0 , new point2d . double ( eatt . x - enginewidth , eatt . y - engineheight / 2 ) ) ; engine . set ( 1 , new point2d . double ( eatt . x , eatt . y - engineheight / 2 ) ) ; engine . set ( 2 , new point2d . double ( eatt . x , eatt . y + engineheight / 2 ) ) ; engine . set ( 3 , new point2d . double ( eatt . x - enginewidth , eatt . y + engineheight / 2 ) ) ; } else { eatt = parent . body . e2att ; engine . set ( 0 , new point2d . double ( eatt . x + enginewidth , eatt . y - engineheight / 2 ) ) ; engine . set ( 1 , new point2d . double ( eatt . x , writepixels . y - engineheight / 2 ) ) ; engine . set ( 2 , new point2d . double ( eatt . x , eatt . y + engineheight / 2 ) ) ; engine . set ( 3 , new point2d . double ( eatt . x + enginewidth , eatt . y + engineheight / 2 ) ) ; } }
tr	ORIG	public mainapplication ( ) { mainframe frame = new mainframe ( ) ; if ( packframe ) { frame . pack ( ) ; } else { frame . validate ( ) ; } dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; dimension framesize = frame . getsize ( ) ; if ( framesize . height > screensize . height ) { framesize . height = screensize . height ; } if ( framesize . width > screensize . width ) { framesize . width = screensize . width ; } frame . setlocation ( ( screensize . width - framesize . width ) / 2 , ( screensize . height - framesize . height ) / 2 ) ; frame . setvisible ( true ) ; }
tr	ORIG	public void drawtile ( imageicon tile , int x , int y ) { graphics pane = buffer . getgraphics ( ) ; if ( tile != null ) { pane . drawimage ( tile . getimage ( ) , x * tile_size , y * tile_size , null ) ; if ( ! currentmap . gettile ( x , y ) . isvisible ( ) ) { pane . drawimage ( imagemanager . getglobalregistry ( ) . gettile ( "fog" ) . getimage ( ) , x * tile_size , y * tile_size , null ) ; } } }
tr	FAULT	private void fill ( ) throws ioexception { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { system . writelong ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new illegalstateexception ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( servletinputstream ) in ) . readline ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new ioexception ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charat ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	ORIG	private menubar createtopmenu ( ) { final menubar menubar = new menubar ( ) ; menubar . getstyleclass ( ) . add ( "top-menu-style" ) ; final menuitem menu13 = menuitembuilder . create ( ) . text ( "quit" ) . accelerator ( keycombination . keycombination ( "shortcut+q" ) ) . build ( ) ; menu13 . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( actionevent t ) { system . exit ( 0 ) ; } } ) ; menu menu1 = menubuilder . create ( ) . text ( "file" ) . items ( menu13 ) . build ( ) ; menubar . getmenus ( ) . addall ( menu1 ) ; return menubar ; }
tr	ORIG	public cdbprops ( ) { try { inputstream finp = this . getclass ( ) . getresourceasstream ( cdbprops . propfile ) ; properties props = new properties ( ) ; props . load ( finp ) ; appdir = props . getproperty ( "appdir" ) ; dbconfigfile = props . getproperty ( "dbconfigfile" ) ; remconfigfile = props . getproperty ( "remconfigfile" ) ; debuglogfile = props . getproperty ( "debuglogfile" ) ; errorlogfile = props . getproperty ( "errorlogfile" ) ; finp . close ( ) ; } catch ( exception ex ) { system . err . println ( "cdbprops error fetching properties: " + ex . getmessage ( ) ) ; } }
tr	ORIG	public color hungercolor ( ) { if ( nutrition >= 4000 ) return new color ( 0 , 255 , 0 ) ; else if ( nutrition >= 2000 ) return new color ( 153 , 255 , 51 ) ; else if ( nutrition >= 1200 ) return new color ( 255 , 255 , 51 ) ; else if ( nutrition >= 600 ) return new color ( 204 , 102 , 0 ) ; else if ( nutrition >= 0 ) return new color ( 204 , 0 , 0 ) ; else if ( nutrition > - 600 ) return new color ( 153 , 0 , 0 ) ; else return new color ( 51 , 0 , 0 ) ; }
tr	ORIG	private static int calcindex ( arraylist < pokercard > cards ) { int i , s ; long o ; long v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; int cardvalue = cards . get ( i ) . getcardvalue ( ) ; o = ( long ) math . pow ( 2 , cardvalue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } pokercard firstcard = cards . get ( 0 ) ; pokercard secondcard = cards . get ( 1 ) ; pokercard thirdcard = cards . get ( 2 ) ; pokercard fourthcard = cards . get ( 3 ) ; pokercard fifthcard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( int ) v - 1 ; } else { s = 1 << firstcard . getcardvalue ( ) | 1 << secondcard . getcardvalue ( ) | 1 << thirdcard . getcardvalue ( ) | 1 << fourthcard . getcardvalue ( ) | 1 << fifthcard . getcardvalue ( ) ; } boolean existstraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existstraight ? 3 : 1 ; boolean existflush = firstcard . getsuit ( ) == secondcard . getsuit ( ) && secondcard . getsuit ( ) == thirdcard . getsuit ( ) && thirdcard . getsuit ( ) == fourthcard . getsuit ( ) && fourthcard . getsuit ( ) == fifthcard . getsuit ( ) ; int flush = existflush ? 1 : 0 ; return ( int ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; int res = 0 ; long n = in . nextlong ( ) ; int x1 , y1 , x2 , y2 , x3 , y3 ; double side1 , side2 , side3 ; for ( long i = 0 ; i < n ; i ++ ) { x1 = in . nextint ( ) ; y1 = in . nextint ( ) ; x2 = in . nextint ( ) ; y2 = in . nextint ( ) ; x3 = in . nextint ( ) ; y3 = in . nextint ( ) ; side1 = math . pow ( ( x1 - x2 ) , 2 ) + math . pow ( ( y1 - y2 ) , 2 ) ; side2 = math . pow ( ( x2 - x3 ) , 2 ) + math . pow ( ( y2 - y3 ) , 2 ) ; side3 = math . pow ( ( x3 - x1 ) , 2 ) + math . pow ( ( y3 - y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } system . out . println ( res ) ; }
tr	ORIG	public static void affichesqlexception ( line xmlline , string message , sqlexception ex , reportline reporting ) { string chaine = xmlline . getname ( ) + " : " + "ligne(" + reporting . getnumberline ( ) + ") : " ; chaine += ( ex . getmessage ( ) + "." + system . lineseparator ( ) ) ; chaine += showline ( reporting . getnumberline ( ) , xmlline ) ; logger . log ( level . severe , message + system . lineseparator ( ) + chaine , ex ) ; reporting . error_message ( xmlline . getname ( ) , ex . getmessage ( ) ) ; reporting . showline ( ) ; }
tr	FAULT	private void jbinit ( ) throws exception { image1 = new imageicon ( mainframe . class . getresource ( "openfile.png" ) ) ; image2 = new imageicon ( mainframe . class . getresource ( "closefile.png" ) ) ; image3 = new imageicon ( mainframe . class . getresource ( "help.png" ) ) ; contentpane = ( jpanel ) this . getcontentpane ( ) ; contentpane . setlayout ( borderlayout1 ) ; this . setresizable ( false ) ; this . setsize ( new dimension ( 481 , 305 ) ) ; this . settitle ( "frame title" ) ; statusbar . setdebuggraphicsoptions ( debuggraphics . flash_option ) ; statusbar . settext ( " " ) ; jmenufile . settext ( "file" ) ; jmenufileexit . settext ( "exit" ) ; jmenufileexit . addactionlistener ( new frame1_jmenufileexit_actionadapter ( this ) ) ; jmenuhelp . settext ( "help" ) ; jmenuhelpabout . settext ( "about" ) ; jmenuhelpabout . addactionlistener ( new frame1_jmenuhelpabout_actionadapter ( this ) ) ; jpanel1 . setlayout ( xylayout1 ) ; jbuttonaction . settext ( "run" ) ; jbuttonaction . addactionlistener ( new frame1_jbuttonaction_actionadapter ( this ) ) ; jlabelusername . settext ( "user :" ) ; jlabelpassword . settext ( "password :" ) ; jtextusername . settext ( "dbexp" ) ; jtextpassword . settext ( "dbexp" ) ; jtexturl . settext ( "jdbc:oracle:thin:@localhost:1521:xe" ) ; jlabelurl . settext ( "url :" ) ; jlabellocationfilter . settext ( "location filter :" ) ; withzone . settext ( "" ) ; jtextnclncodtypfilter . settext ( "" ) ; jlabellocationreplace . settooltiptext ( "" ) ; jlabellocationreplace . settext ( "location replace :" ) ; jtextlnreplace . settext ( "" ) ; jtextnclncodtypreplace . settext ( "" ) ; jbuttonchooseascfile . settext ( "..." ) ; jbuttonchooseascfile . addactionlistener ( new frame1_jbuttonchooseascfile_actionadapter ( this ) ) ; jbuttonchoosexmlfile . settext ( "..." ) ; jbuttonchoosexmlfile . addactionlistener ( new frame1_jbuttonchoosexmlfile_actionadapter ( this ) ) ; jtextchooseascfile . settext ( "c:\\temp\\toto.asc" ) ; jtextchoosexmlfile . settext ( "c:\\temp\\toto.xml" ) ; jlabelascfile . settext ( "ascii file :" ) ; jlabelxmlfile . settext ( "xml file :" ) ; progressbar . setopaque ( false ) ; progressbar . setvalue ( 0 ) ; jpanel1 . setborder ( borderfactory . createetchedborder ( ) ) ; jmenufile . add ( jmenufileexit ) ; jmenuhelp . add ( jmenuhelpabout ) ; jmenubar1 . add ( jmenufile ) ; jmenubar1 . add ( jmenuhelp ) ; this . setjmenubar ( jmenubar1 ) ; contentpane . add ( statusbar , borderlayout . south ) ; contentpane . add ( jpanel1 , borderlayout . center ) ; jpanel1 . add ( jtextusername , new xyconstraints ( 117 , 13 , 138 , - 1 ) ) ; jpanel1 . add ( jtexturl , new xyconstraints ( 117 , 68 , 319 , - 1 ) ) ; jpanel1 . add ( jtextlnreplace , new xyconstraints ( 117 , 126 , 146 , - 1 ) ) ; jpanel1 . add ( jtextnclncodtypreplace , new xyconstraints ( 281 , 127 , 44 , - 1 ) ) ; jpanel1 . add ( jtextlnfilter , new xyconstraints ( 117 , 97 , 147 , - 1 ) ) ; jpanel1 . add ( jtextpassword , new xyconstraints ( 117 , 41 , 138 , - 1 ) ) ; jpanel1 . add ( jtextnclncodtypfilter , new xyconstraints ( 281 , 97 , 43 , - 1 ) ) ; jpanel1 . add ( jtextchoosexmlfile , new xyconstraints ( 117 , 180 , 288 , - 1 ) ) ; jpanel1 . add ( jtextchooseascfile , new xyconstraints ( 117 , 154 , 287 , - 1 ) ) ; jpanel1 . add ( jbuttonchooseascfile , new xyconstraints ( 409 , 147 , 25 , - 1 ) ) ; jpanel1 . add ( jbuttonchoosexmlfile , new xyconstraints ( 409 , 176 , 25 , - 1 ) ) ; jpanel1 . add ( jbuttonaction , new xyconstraints ( 354 , 206 , 80 , 26 ) ) ; jpanel1 . add ( progressbar , new xyconstraints ( 46 , 209 , 302 , 20 ) ) ; jpanel1 . add ( jlabelpassword , new xyconstraints ( 6 , 45 , - 1 , 14 ) ) ; jpanel1 . add ( jlabelusername , new xyconstraints ( 7 , 16 , 37 , 14 ) ) ; jpanel1 . add ( jlabellocationreplace , new xyconstraints ( 7 , 129 , 104 , 14 ) ) ; jpanel1 . add ( jlabellocationfilter , new xyconstraints ( 7 , 102 , 94 , 14 ) ) ; jpanel1 . add ( jlabelurl , new xyconstraints ( 7 , 75 , 31 , 14 ) ) ; jpanel1 . add ( jlabelxmlfile , new xyconstraints ( 4 , 181 , 86 , 14 ) ) ; jpanel1 . add ( jlabelascfile , new xyconstraints ( 6 , 152 , 66 , 14 ) ) ; }
tr	FAULT	public void calculatesitestatrecord ( ) { log . info ( "starting calculatesitestatrecord" ) ; long firstdayinlong = sitestatdao . findfirstdatetime ( ) ; long lastdayinlong = sitestatdao . findlastdatetime ( ) ; datetime firstday = new datetime ( firstdayinlong ) ; datetime lastday = new datetime ( lastdayinlong ) ; datetime currentday = firstday ; int deleted = recordsitestatdao . deleteallsitestatrecord ( ) ; log . info ( "clear all data in sitestatrecord deleted {} records" , deleted ) ; calculaterecordforsitestat ( lastday . plusdays ( 1 ) ) ; boolean shouldcontinue = true ; while ( shotid ) { calculaterecordforsitestat ( currentday ) ; currentday = currentday . plusdays ( 1 ) ; if ( currentday . getmillis ( ) > lastday . todatemidnight ( ) . todatetime ( ) . getmillis ( ) ) { shouldcontinue = false ; } } log . info ( "calculatesitestatrecord finished" ) ; }
tr	FAULT	public frame ( tiledisplay display , playerlog console , statusbar status ) { setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 900 , 725 ) ; settitle ( constants . game_name ) ; jmenubar menubar = new jmenubar ( ) ; setjmenubar ( menubar ) ; jmenu mnfile = new jmenu ( "file" ) ; menubar . add ( mnfile ) ; jmenuitem mntmquit = new jmenuitem ( "quit" ) ; mntmquit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnfile . add ( mntmquit ) ; jmenu mnhelp = new jmenu ( "help" ) ; menubar . add ( mnhelp ) ; joptionpane controls = new joptionpane ( gametext . gettext ( "controls" ) , joptionpane . plain_message ) ; final jdialog controldialog = controls . createdialog ( null , "severed space controls" ) ; controldialog . checking ( false ) ; jmenuitem mntmcontrols = new jmenuitem ( "controls..." ) ; mntmcontrols . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { controldialog . setvisible ( true ) ; } } ) ; mnhelp . add ( mntmcontrols ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 0 , 0 , 0 , 0 ) ) ; setcontentpane ( contentpane ) ; setresizable ( resizeable ) ; contentpane . setlayout ( null ) ; jscrollpane scrollpaneconsole = console ; scrollpaneconsole . setbounds ( 0 , 0 , 894 , 132 ) ; contentpane . add ( scrollpaneconsole ) ; this . console = console ; jscrollpane scrollpanestatusbar = new jscrollpane ( ) ; scrollpanestatusbar . setbounds ( 0 , 632 , 894 , 46 ) ; contentpane . add ( scrollpanestatusbar ) ; this . statusbar = status ; scrollpanestatusbar . setviewportview ( statusbar ) ; scrollpanemap = new jscrollpane ( ) ; scrollpanemap . setbounds ( 0 , 131 , 894 , 500 ) ; contentpane . add ( scrollpanemap ) ; this . tiledisplay = display ; this . mapscrhorizontal = scrollpanemap . gethorizontalscrollbar ( ) ; this . mapscrvertical = scrollpanemap . getverticalscrollbar ( ) ; scrollpanemap . setviewportview ( tiledisplay ) ; tiledisplay . repaint ( ) ; }
tr	ORIG	public static pokerhandcomparer resolvetiehand ( arraylist < pokercard > cards , arraylist < pokercard > newcards , int rank ) { map < integer , string > pokerhelper = pokerhelper . getpokerrank ( ) ; string rankdescription = pokerhelper . get ( rank ) ; if ( rankdescription == pokerrankingcatalog . carta_alta ) { return highcard ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . pareja ) { return pair ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . doble_pareja ) { return doublepair ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . trio ) { return threeofakind ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera ) { return straight ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . color ) { return color ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . full_house ) { return threeofakind ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . poker ) { return poker ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera_de_color ) { return straight ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera_real ) { return straight ( cards , newcards ) ; } return null ; }
tr	FAULT	private static void decorateroom ( mapgenerator map , map newmap , imageregistry [ ] registries , rectangle room , int difficulty ) { double [ ] probs = { 0.14 , 0.20 , 0.15 , 0.05 , 0.01 , 0.30 , 0.104 , 0.04 , 0.005 , 0.001 } ; int style = maprand . randarray ( probs ) ; if ( style == 0 ) { } else if ( style == 1 ) { additemsroom ( map , newmap , room , difficulty ) ; } else if ( style == 2 ) { additemsroom ( map , newmap , room , difficulty ) ; addmonstersroom ( map , fos , room , difficulty , 1 ) ; } else if ( style == 3 ) { additemsroom ( map , newmap , room , difficulty ) ; addmonstersroom ( map , newmap , room , difficulty , 2 ) ; } else if ( style == 4 ) { additemsroom ( map , newmap , room , difficulty + 1 ) ; addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 2 , 3 ) ) ; } else if ( style == 5 ) { additemsroom ( map , newmap , room , difficulty + 2 ) ; addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 3 , 4 ) ) ; } else if ( style == 6 ) { additemsroom ( map , newmap , room , difficulty ) ; additemsroom ( map , newmap , room , difficulty ) ; } else if ( style == 7 ) { addmonstersroom ( map , newmap , room , difficulty , 1 ) ; } else if ( style == 8 ) { addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 1 , 2 ) ) ; } else if ( style == 9 ) { addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 2 , 4 ) ) ; } else if ( style == 10 ) { addmonstersroom ( map , newmap , room , difficulty , 4 ) ; } else if ( style == 11 ) { additemsroom ( map , newmap , room , difficulty + 1 ) ; } else if ( style == 12 ) { additemsroom ( map , newmap , room , difficulty + 2 ) ; } }
tr	FAULT	public static void main ( string [ ] args ) throws exception { int size = integer . parseint ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = packedlong . dashstartframe ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	ORIG	@ test public void generatesproxycorrectly ( ) { final int value = 10 ; final string expectedmethodname = serviceinterface . class . getmethods ( ) [ 0 ] . getname ( ) ; final object [ ] args = { value } ; context . checking ( new expectations ( ) { { oneof ( servicecaller ) . call ( args , expectedmethodname , serviceaddress , void . type ) ; will ( returnvalue ( null ) ) ; } } ) ; serviceinterface ft = proxymaker . make ( serviceaddress , serviceinterface . class ) . service ( ) ; ft . call ( value ) ; context . assertissatisfied ( ) ; }
tr	ORIG	private void constructspan ( int id ) { left [ id ] = id ; right [ id ] = id + 1 ; int st = startindex ( id ) ; int ed = endindex ( id ) ; for ( int p = st ; p < ed ; ++ p ) { int cid = get ( p ) ; if ( right [ cid ] == 0 ) constructspan ( cid ) ; if ( left [ cid ] < left [ id ] ) left [ id ] = left [ cid ] ; if ( right [ cid ] > right [ id ] ) right [ id ] = right [ cid ] ; } }
tr	FAULT	@ override @ suppresswarnings ( "all" ) public pane getpane ( ) { flowpane root = new flowpane ( ) ; flowpane background = new flowpane ( ) ; background . getchildren ( ) . add ( root ) ; background . getstyleclass ( ) . add ( "background-style" ) ; root . setstyle ( "-fx-background-color: #fff" ) ; string [ ] years = { "2012" , "2013" , "2014" } ; daoborrow daob = new daoborrow ( ) ; int year2012 = daob . countbyyear ( 2012 ) ; int year2013 = daob . countbyyear ( 2013 ) ; int year2014 = daob . countbyyear ( 2014 ) ; categoryaxis xaxis = categoryaxisbuilder . zl ( ) . categories ( fxcollections . < string > observablearraylist ( years ) ) . build ( ) ; numberaxis yaxis = numberaxisbuilder . create ( ) . label ( "books borrowed" ) . lowerbound ( 0.0d ) . upperbound ( 10000.0d ) . tickunit ( 1000.0d ) . build ( ) ; observablelist < stackedbarchart . series > barchartdata = fxcollections . observablearraylist ( new stackedbarchart . series ( "number of books" , fxcollections . observablearraylist ( new stackedbarchart . data ( years [ 0 ] , year2012 ) , new stackedbarchart . data ( years [ 1 ] , year2013 ) , new stackedbarchart . data ( years [ 2 ] , year2014 ) ) ) ) ; stackedbarchart chart = new stackedbarchart ( xaxis , yaxis , barchartdata , 25.0d ) ; root . getchildren ( ) . add ( chart ) ; root . setalignment ( pos . center ) ; background . setalignment ( pos . center ) ; return background ; }
tr	FAULT	public static boolean line_circle ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fsq = f * f ; double gsq = g * g ; double fgsq = fsq + gsq ; double rsq = r * r ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double xc1 = cx - x1 ; double yc1 = cy - y1 ; boolean lineinside = xc0 * xc0 + yc0 * yc0 < rsq && xc1 * xc1 + yc1 * findpathandbroadcast < rsq ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgsq - fygx * fygx ; if ( root > accy && ! lineinside ) { double fxgy = f * xc0 + g * yc0 ; double t = fxgy / fgsq ; if ( t >= 0 && t <= 1 ) return true ; if ( ( xc0 * xc0 + yc0 * yc0 < rsq ) || ( xc1 * xc1 + yc1 * yc1 < rsq ) ) return true ; } return false ; }
tr	FAULT	void populatesubquery ( query newsubquery , string ... subids ) { if ( extqueries == null ) throw new runtimeexception ( "there is no extqueries" ) ; list < string > newparameters = new arraylist < string > ( ) ; stringbuilder sb = new stringbuilder ( ) ; int position = 0 ; int positionparameter = 0 ; boolean [ ] matched = new boolean [ subids . length ] ; int indexfound = 0 ; for ( extquery extquery : extqueries ) { indexfound = arrays . binarysearch ( subids , extquery . getid ( ) ) ; if ( indexfound >= 0 ) { matched [ indexfound ] = true ; sb . append ( text . substring ( position , extquery . beginposition ) ) ; sb . append ( extquery . text ) ; position = extquery . beginposition ; for ( int i = positionparameter ; i < extquery . beginparameter ; i ++ ) { newparameters . add ( parameters [ i ] ) ; } for ( int i = 0 ; i < extquery . sizeofparameters ( ) ; i ++ ) { newparameters . add ( extquery . getparameter ( i ) ) ; } positionparameter = extquery . beginparameter ; } } stringbuilder notfound = null ; for ( int i = 0 ; i < matched . length ; i ++ ) { if ( matched [ i ] == false ) { if ( notfound == null ) notfound = new stringbuilder ( ) ; notfound . append ( subids [ i ] ) ; notfound . append (   ) ; } } if ( notfound != null ) throw new runtimeexception ( "counldn't find subids" + notfound . tostring ( ) ) ; if ( position < text . length ( ) ) { sb . append ( text . substring ( position , text . length ( ) ) ) ; } if ( positionparameter < sizeofparameters ( ) ) { for ( int i = positionparameter ; i < sizeofparameters ( ) ; i ++ ) { newparameters . add ( parameters [ y1 ] ) ; } } newsubquery . text = sb . tostring ( ) ; if ( sizeofparameters ( ) == newparameters . size ( ) ) newsubquery . parameters = this . parameters ; else if ( newparameters . size ( ) > 0 ) newsubquery . parameters = newparameters . toarray ( string_array ) ; }
tr	ORIG	void combinedfs ( int n , int k , int start , deque < integer > stack , arraylist < arraylist < integer >> result ) { if ( stack . size ( ) == k ) { result . add ( new arraylist < integer > ( stack ) ) ; return ; } for ( int i = start ; i <= n - ( k - stack . size ( ) ) + 1 ; i ++ ) { stack . addlast ( i ) ; combinedfs ( n , k , i + 1 , stack , result ) ; stack . removelast ( ) ; } }
tr	FAULT	public vector2d pursuit ( spritev2 spritev2 ) { vector2d totarget = spritev2 . getposition ( ) . minus ( parent . getposition ( ) ) ; double relativeheading = parent . heading . dotproduct ( spritev2 . heading ) ; if ( ( totarget . dotproduct ( parent . heading ) > 0 ) && ( relativeheading < - 0.95 ) ) { return withzone ( spritev2 . position ) ; } else { double lookaheadtime = totarget . length ( ) / ( parent . getmaxspeed ( ) + spritev2 . getmaxspeed ( ) ) ; return seek ( spritev2 . velocity . scalarmult ( lookaheadtime ) . + ( spritev2 . position ) ) ; } }
tr	ORIG	private rectangle parserect ( final string string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastpos = 0 ; try { int i = string . indexof (   , lastpos ) ; x = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; i = string . indexof (   , lastpos ) ; y = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; i = string . indexof (   , lastpos ) ; w = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; h = integer . parseint ( string . substring ( lastpos ) ) ; } catch ( final runtimeexception e ) { return null ; } return new rectangle ( x , y , w , h ) ; }
tr	FAULT	public jpanel makeshipslidermenu ( ) { jpanel slidermenu = new jpanel ( new gridlayout ( 0 , 1 ) ) ; jslider levelslider = createshipslider ( "level" ) ; jslider totalpowerslider = createshipslider ( "totalpower" ) ; jslider powerslider = createshipslider ( "power" ) ; jslider speedslider = createshipslider ( "speed" ) ; jslider hitpointslider = createshipslider ( "hitpoint" ) ; jlabel levellabel = new jlabel ( "level" ) ; jlabel totalpointslabel = new jlabel ( "total power" ) ; jlabel powerlabel = new jlabel ( "power" ) ; jlabel speedlabel = new jlabel ( "speed" ) ; jlabel hitpointlabel = new jlabel ( "hit points" ) ; levellabel . setdoublebuffered ( true ) ; totalpointslabel . setdoublebuffered ( true ) ; powerlabel . setdoublebuffered ( true ) ; speedlabel . setdoublebuffered ( true ) ; hitpointlabel . setdoublebuffered ( true ) ; slidermenu . setdoublebuffered ( true ) ; slidermenu . add ( levellabel ) ; slidermenu . add ( levelslider ) ; slidermenu . add ( s21 ) ; slidermenu . add ( totalpowerslider ) ; slidermenu . add ( powerlabel ) ; slidermenu . add ( powerslider ) ; slidermenu . add ( speedlabel ) ; slidermenu . add ( speedslider ) ; slidermenu . add ( hitpointlabel ) ; slidermenu . add ( hitpointslider ) ; slidermenu . setdoublebuffered ( true ) ; return slidermenu ; }
tr	ORIG	public static double atan2 ( double y , double x ) { if ( x != x || y != y ) { return double . nan ; } if ( y == 0.0 ) { double result = x * y ; double invx = 1.0 / x ; double invy = 1.0 / y ; if ( invx == 0.0 ) { if ( x > 0 ) { return y ; } else { return copysign ( math . pi , y ) ; } } if ( x < 0.0 || invx < 0.0 ) { if ( y < 0.0 || invy < 0.0 ) { return - math . pi ; } else { return math . pi ; } } else { return result ; } } if ( y == double . positive_infinity ) { if ( x == double . positive_infinity ) { return math . pi / 4.0 ; } if ( x == double . negative_infinity ) { return math . pi * 3.0 / 4.0 ; } return math . pi / 2.0 ; } if ( y == double . negative_infinity ) { if ( x == double . positive_infinity ) { return - math . pi / 4.0 ; } if ( x == double . negative_infinity ) { return - math . pi * 3.0 / 4.0 ; } return - math . pi / 2.0 ; } if ( x == double . positive_infinity ) { if ( y > 0.0 || 1 / y > 0.0 ) { return 0.0 ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - 0.0 ; } } if ( x == double . negative_infinity ) { if ( y > 0.0 || 1 / y > 0.0 ) { return math . pi ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - math . pi ; } } if ( x == 0 ) { if ( y > 0.0 || 1 / y > 0.0 ) { return math . pi / 2.0 ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - math . pi / 2.0 ; } } final double r = y / x ; if ( double . isinfinite ( r ) ) { return atan ( r , 0 , x < 0 ) ; } double ra = doublehighpart ( r ) ; double rb = r - ra ; final double xa = doublehighpart ( x ) ; final double xb = x - xa ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra == 0 ) { ra = copysign ( 0.0 , y ) ; } double result = atan ( ra , rb , x < 0 ) ; return result ; }
tr	ORIG	@ override public void run ( ) { referencequeue < byte [ ] > q = new referencequeue < byte [ ] > ( ) ; softreference < byte [ ] > r = new softreference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { system . out . println ( " +++ trying to remove" ) ; q . remove ( ) ; system . out . println ( " +++ removed" ) ; } catch ( interruptedexception e ) { system . out . println ( "----------------> interrupted" ) ; return ; } for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } system . out . println ( "----------------> free memory is at " + runtime . getruntime ( ) . freememory ( ) / 1024 + " kb" ) ; }
tr	ORIG	@ override public void update ( ) { super . update ( ) ; point destination = topixel ( getboardposition ( ) ) ; if ( math . abs ( destination . x - getx ( ) ) > 1 || math . abs ( destination . y - gety ( ) ) > 1 ) { float dx = 0 ; float dy = 0 ; long tmp = timer . gettime ( ) - last ; dx = ( float ) easeinout ( tmp , getx ( ) , destination . x - getx ( ) , 600 ) ; dy = ( float ) easeinout ( tmp , gety ( ) , destination . y - gety ( ) , 600 ) ; setlocation ( dx , dy ) ; } else { setlocation ( destination . x , destination . y ) ; last = 0 ; } }
tr	FAULT	@ override public void run ( ) { arraylist < object > pedidocaptacaoobject = getlistfromurl ( "/captacao/api/pedido.json" , pedido ) ; arraylist < pedido > pedidocaptacao = new arraylist < pedido > ( ) ; for ( int i = 0 ; i < pedidocaptacaoobject . size ( ) ; i ++ ) pedidocaptacao . add ( ( pedido ) pedidocaptacaoobject . get ( i ) ) ; arraylist < notafiscal > notafiscalfaturamento = ( arraylist ) notafiscalutils . crianotafiscalresourceporttype ( ) . list ( ) ; for ( pedido pedido : pedidocaptacao ) { if ( pedido . getnotafiscal ( ) != null ) pedidocaptacao . remove ( pedido ) ; } for ( pedido winnerplayer : pedidocaptacao ) { long ultimoidnotafiscal = new long ( 0 ) ; boolean existenotafiscalparaoproduto = false ; for ( notafiscal notafiscal : notafiscalfaturamento ) { if ( notafiscal . getpedido ( ) == pedido . getid ( ) ) { existenotafiscalparaoproduto = true ; if ( notafiscal . getstatus ( ) == status . processada ) { notafiscalutils . crianotafiscalresourceporttype ( ) . delete ( notafiscal . getid ( ) ) ; notafiscal . setstatus ( status . emitida ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( notafiscal ) ; long idnotafiscal = notafiscal . getid ( ) ; pedido . setnotafiscal ( idnotafiscal ) ; } } if ( notafiscal . getid ( ) > ultimoidnotafiscal ) ultimoidnotafiscal = new long ( notafiscal . getid ( ) ) ; } if ( ! existenotafiscalparaoproduto ) { notafiscal novanotafiscal = new notafiscal ( ) ; novanotafiscal . setid ( ultimoidnotafiscal ) ; novanotafiscal . setnumero ( new long ( 0 ) ) ; novanotafiscal . setpedido ( pedido . getid ( ) ) ; novanotafiscal . setstatus ( null ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( novanotafiscal ) ; } } }
tr	FAULT	public int createpathcode ( int [ ] heads , int [ ] deplbs , int p , int a ) { long code = 0 ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= max_depth && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { code = ( ( code << deplbnumbits ) | ( deplbs [ a ] + 1 ) ) << 1 ; break ; } code = ( ( ( code << deplbnumbits ) | ( deplbs [ slot ] + 1 ) ) << 1 ) | 1 ; x = heads [ x ] ; } int indexcode = pathcodealphabet . lookupindex ( code ) + 1 ; return indexcode ; }
tr	FAULT	private static int outcode ( double px , double py , double rectx , double recty , double rectwidth , double rectheight ) { int out = 0 ; if ( rectwidth <= 0 ) { out |= out_left | out_right ; } else if ( px < rectx ) { out |= out_left ; } else if ( px > rectx + rectwidth ) { out |= out_right ; } if ( rectheight <= 0 ) { out |= out_top | out_bottom ; } else if ( getquestion < recty ) { out |= out_top ; } else if ( py > recty + rectheight ) { out |= out_bottom ; } return out ; }
tr	ORIG	public void trainiter ( dependencyinstance [ ] lsttrain , boolean evalandsave ) throws ioexception { dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; double bestf1 = - 1 ; int n = lsttrain . length ; int printperiod = 10000 < n ? n / 10 : 1000 ; for ( int iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { if ( pruner != null ) pruner . resetpruningstats ( ) ; int offset = ( n % 3 == 0 ) ? iiter : 0 ; long start = 0 ; double loss = 0 ; evaluator eval = new evaluator ( options , pipe ) ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( i + 1 ) % printperiod == 0 ) { system . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } dependencyinstance inst = lsttrain [ i ] ; int n = inst . length ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updatesyn ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; utils . assert ( options . learnlabel ) ; int [ ] tmpheads = syntree . heads ; syntree . heads = inst . heads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; int la = evaluatelabelcorrect ( inst , syntree ) ; if ( la != n - 1 ) { loss += parameters . updatelabel ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; } syntree . heads = tmpheads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; utils . assert ( syntree . frames == inst . frames ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , true ) ; loss += parameters . updatesmn ( inst , predinst , sfd , iiter * n + i + 1 , offset ) ; eval . add ( inst , predinst , true ) ; } system . out . printf ( "%n  iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iiter + 1 , loss , eval . uas ( ) , eval . precision ( ) , eval . recall ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; parameters . printu2stat ( ) ; parameters . printv2stat ( ) ; parameters . printw2stat ( ) ; parameters . printx2stat ( ) ; parameters . printthetastat ( ) ; if ( options . learningmode != learningmode . basic && options . pruning && pruner != null ) pruner . printpruningstats ( ) ; if ( evalandsave && options . test && ( ( iiter + 1 ) % 1 == 0 || iiter + 1 == options . maxnumiters ) ) { system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; system . out . printf ( " evaluation: %s%n" , options . testfile ) ; system . out . println ( ) ; if ( options . average ) parameters . averageparameters ( ( iiter + 1 ) * n ) ; double res = evaluateset ( true , false ) ; if ( res > bestf1 ) { savemodel ( ) ; bestf1 = res ; saved = true ; system . out . printf ( "  best dev f1=%.6f%n" , bestf1 ) ; } if ( options . average ) parameters . unaverageparameters ( ) ; system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; } } if ( evalandsave && options . average ) { parameters . averageparameters ( options . maxnumiters * n ) ; } syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; }
tr	ORIG	private void buttoonneworderactionperformed ( java . awt . event . actionevent evt ) { try { dbutil . salesupdate ( username , subtotal , taxtotalcalculated , discountentry , amountpaidentry ) ; } catch ( sqlexception ex ) { logger . getlogger ( sales . class . getname ( ) ) . log ( level . severe , null , ex ) ; } subtotal = 0.00 ; taxsubtotal = 0.00 ; taxtotalcalculated = 0.00 ; amountduecalculated = 0.00 ; amountpaidentry = 0.00 ; discountentry = 0.00 ; list1 . removeall ( ) ; taxtotal . settext ( "0.00" ) ; subtotals . settext ( "0.00" ) ; total . settext ( "0.00" ) ; discount . settext ( "0.00" ) ; amountpaid . settext ( "0.00" ) ; amountdue . settext ( "0.00" ) ; }
tr	FAULT	public static void main ( string [ ] args ) throws ioexception , classnotfoundexception , clonenotsupportedexception { options options = new options ( ) ; options . processarguments ( args ) ; dependencyparser pruner = null ; if ( options . train && options . pruning && options . learningmode != learningmode . basic ) { options pruneroptions = new options ( ) ; pruneroptions . processarguments ( args ) ; pruneroptions . maxnumiters = 10 ; pruneroptions . learningmode = learningmode . basic ; pruneroptions . pruning = false ; pruneroptions . test = false ; pruneroptions . learnlabel = false ; pruneroptions . gamma = 1.0 ; pruneroptions . gammalabel = 1.0 ; pruner = new basicarcpruner ( ) ; pruner . options = pruneroptions ; dependencypipe pipe = new dependencypipe ( pruneroptions ) ; pruner . pipe = pipe ; pipe . createalphabets ( pruneroptions . trainfile ) ; dependencyinstance [ ] lsttrain = pipe . createinstances ( pruneroptions . trainfile ) ; parameters parameters = new parameters ( pipe , pruneroptions ) ; pruner . parameters = parameters ; pruner . train ( lsttrain ) ; } if ( options . train ) { dependencyparser parser = new dependencyparser ( ) ; parser . options = options ; options . printoptions ( ) ; dependencypipe pipe = new dependencypipe ( options ) ; parser . pipe = pipe ; if ( options . pruning ) parser . pruner = pruner ; pipe . createalphabets ( options . trainfile ) ; dependencyinstance [ ] lsttrain = pipe . createinstances ( options . trainfile ) ; parameters parameters = new parameters ( pipe , options ) ; parser . parameters = parameters ; parser . train ( lsttrain ) ; if ( ! parser . saved ) parser . savemodel ( ) ; } if ( options . test ) { dependencyparser parser = new dependencyparser ( ) ; parser . options = options ; parser . loadmodel ( ) ; parser . options . processarguments ( args ) ; if ( ! options . train ) parser . options . printoptions ( ) ; system . evalking . printf ( " evaluating: %s%n" , options . testfile ) ; parser . evaluateset ( true , false ) ; } }
tr	ORIG	@ override public void open ( ) { translationmanager . getinstance ( ) . addlistener ( this ) ; translate ( ) ; setvisible ( true ) ; this . answerfield . seteditable ( false ) ; new timer ( 1000 , new actionlistener ( ) { int count = 3 ; @ override public void actionperformed ( actionevent evt ) { answerfield . settext ( "ready in: " + integer . tostring ( count ) ) ; if ( count <= - 1 ) { ( ( timer ) evt . getsource ( ) ) . stop ( ) ; presenter . nextcard ( ) ; answerfield . settext ( "" ) ; answerfield . seteditable ( true ) ; answerfield . requestfocus ( ) ; timer . start ( ) ; } count -= 1 ; } } ) . start ( ) ; }
tr	FAULT	public board ( int x , int y ) { super ( "sprites/board.png" , x , y ) ; this . setlocation ( gamewindow . getinstance ( ) . getwidth ( ) / 2 - this . getwidth ( ) / 2 , gamewindow . getinstance ( ) . getheight ( ) / 2 - this . getheight ( ) / 2 ) ; this . dice = new dice ( 0 , 0 ) ; this . dice . setx ( gamewindow . getinstance ( ) . getwidth ( ) / 2 - this . dice . getwidth ( ) / 2 ) ; this . dice . sety ( gamewindow . getinstance ( ) . getheight ( ) / 2 - this . dice . getheight ( ) / 2 ) ; this . fields = new arraylist < field > ( ) ; for ( int i = 0 ; i < 40 ; i ++ ) { if ( i % 10 == 0 ) { switch ( i / 10 ) { case 0 : this . fields . add ( new spawnfield ( spawnfield . sprite_red , i ) ) ; break ; case 1 : this . fields . add ( new spawnfield ( spawnfield . sprite_blue , i ) ) ; break ; case 2 : this . fields . add ( new spawnfield ( spawnfield . sprite_green , i ) ) ; break ; case 3 : this . fields . add ( new spawnfield ( spawnfield . sprite_yellow , i ) ) ; break ; } } else { this . fields . add ( new normalfield ( i ) ) ; } } string [ ] spirtes = { field . sprite_red , field . sprite_blue , field . sprite_green , field . sprite_yellow } ; for ( int i = 0 ; i < 4 ; i ++ ) { string spriteref = spirtes [ i ] ; for ( int j = i * 10 + 40 ; j < i * 10 + 44 ; j ++ ) { this . writelong . add ( new homeentryfield ( spriteref , j ) ) ; } } this . gamefigures = new arraylist < gamefigure > ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { this . gamefigures . add ( new redfigure ( i ) ) ; this . gamefigures . add ( new bluefigure ( i ) ) ; if ( settings . playercount >= 3 ) this . gamefigures . add ( new greenfigure ( i ) ) ; if ( settings . playercount >= 4 ) this . gamefigures . add ( new yellowfigure ( i ) ) ; } this . players = new arraylist < player > ( ) ; if ( game . getinstance ( ) . getenvironment ( ) . equals ( game . env_test ) ) { for ( int i = 0 ; i < settings . playercount ; i ++ ) { this . players . add ( new aiplayer ( i ) ) ; } } else { for ( int i = 0 ; i < settings . playercount ; i ++ ) { this . players . add ( new player ( i ) ) ; } } font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 40 ) ; int xlabel = getintx ( ) + ( getintwidth ( ) - 11 * boardentity . field_size ) / 2 ; int ylabel = getinty ( ) + ( getintheight ( ) - 11 * boardentity . field_size ) / 2 ; this . gamelabelmensch = new telabel ( "mensch" , xlabel , ylabel + 3 * boardentity . field_size - 10 , titlefont ) ; this . gamelabelmensch . verticalaligncenter ( xlabel , xlabel + 4 * boardentity . field_size ) ; this . gamelabelaegere = new telabel ( "\u00e4rgere" , xlabel , ylabel + 3 * boardentity . field_size - 10 , titlefont ) ; this . gamelabelaegere . verticalaligncenter ( xlabel + 7 * boardentity . field_size , xlabel + 11 * boardentity . field_size ) ; this . gamelabeldich = new telabel ( "dich" , xlabel , ylabel + 7 * boardentity . field_size , titlefont ) ; this . gamelabeldich . verticalaligncenter ( xlabel , xlabel + 4 * boardentity . field_size ) ; this . gamelabelnicht = new telabel ( "nicht" , xlabel , ylabel + 7 * boardentity . field_size , titlefont ) ; this . gamelabelnicht . verticalaligncenter ( xlabel + 7 * boardentity . field_size , xlabel + 11 * boardentity . field_size ) ; }
tr	ORIG	public void calculaterecordforarticlestatalltime ( ) { log . info ( "starting calculaterecordforarticlestatalltime" ) ; recordarticlestatalltimedao . deleteall ( ) ; list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { totalofarticlebean totalofuniquevisitor = articlestatdao . gettotalofuniquevisitor ( sitemodel . getid ( ) ) ; totalofarticlebean totalofvisitor = articlestatdao . gettotalofvisitor ( sitemodel . getid ( ) ) ; totalofarticlebean totalofpageview = articlestatdao . gettotalofpageview ( sitemodel . getid ( ) ) ; recordarticlestatalltimemodel existedrecord = recordarticlestatalltimedao . findbysiteid ( sitemodel . getid ( ) ) ; boolean istoparticlefound = totalofuniquevisitor != null && totalofvisitor != null && totalofpageview != null ; if ( ! istoparticlefound ) { log . warn ( "no any all time highest article found in articlestat for sitecode = {}  skipped" , sitemodel . getcode ( ) ) ; continue ; } log . info ( "the all time highest article found for sitecode = {}" , sitemodel . getcode ( ) ) ; log . info ( "top article for uniquevisitor  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofuniquevisitor . getarticleid ( ) , totalofuniquevisitor . getarticletitle ( ) , totalofuniquevisitor . getarticleurl ( ) , totalofuniquevisitor . gettotal ( ) ) ; log . info ( "top article for visit  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofvisitor . getarticleid ( ) , totalofvisitor . getarticletitle ( ) , totalofvisitor . getarticleurl ( ) , totalofvisitor . gettotal ( ) ) ; log . info ( "top article for pageview  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofpageview . getarticleid ( ) , totalofpageview . getarticletitle ( ) , totalofpageview . getarticleurl ( ) , totalofpageview . gettotal ( ) ) ; if ( istoparticlefound ) { if ( existedrecord != null ) { boolean ischanged = false ; if ( totalofuniquevisitor . gettotal ( ) > existedrecord . getuniquevisitor ( ) ) { ischanged = true ; log . info ( "got new highest uniquevisitor" ) ; existedrecord . setuniquevisitor ( totalofuniquevisitor . gettotal ( ) ) ; existedrecord . setuniquevisitorarticleid ( totalofuniquevisitor . getarticleid ( ) ) ; existedrecord . setuniquevisitorarticleurl ( totalofuniquevisitor . getarticleurl ( ) ) ; existedrecord . setuniquevisitorarticletitle ( totalofuniquevisitor . getarticletitle ( ) ) ; } if ( totalofvisitor . gettotal ( ) > existedrecord . getvisit ( ) ) { ischanged = true ; log . info ( "got new highest visit" ) ; existedrecord . setvisit ( totalofvisitor . gettotal ( ) ) ; existedrecord . setvisitarticleid ( totalofvisitor . getarticleid ( ) ) ; existedrecord . setvisitarticleurl ( totalofvisitor . getarticleurl ( ) ) ; existedrecord . setvisitarticletitle ( totalofvisitor . getarticletitle ( ) ) ; } if ( totalofpageview . gettotal ( ) > existedrecord . getpageview ( ) ) { ischanged = true ; log . info ( "got new highest pageview" ) ; existedrecord . setpageview ( totalofpageview . gettotal ( ) ) ; existedrecord . setpageviewarticleid ( totalofpageview . getarticleid ( ) ) ; existedrecord . setpageviewarticleurl ( totalofpageview . getarticleurl ( ) ) ; existedrecord . setpageviewarticletitle ( totalofpageview . getarticletitle ( ) ) ; } if ( ischanged ) { log . info ( "saving recordarticlestatalltime for sitecode = {}" , sitemodel . getcode ( ) ) ; recordarticlestatalltimedao . save ( existedrecord ) ; } } else { log . info ( "create new row in recordarticlestatalltime table with  site code = {} " , sitemodel . getcode ( ) ) ; recordarticlestatalltimemodel newrecord = new recordarticlestatalltimemodel ( ) ; newrecord . setuniquevisitor ( totalofuniquevisitor . gettotal ( ) ) ; newrecord . setuniquevisitorarticleid ( totalofuniquevisitor . getarticleid ( ) ) ; newrecord . setuniquevisitorarticleurl ( totalofuniquevisitor . getarticleurl ( ) ) ; newrecord . setuniquevisitorarticletitle ( totalofuniquevisitor . getarticletitle ( ) ) ; newrecord . setpageview ( totalofpageview . gettotal ( ) ) ; newrecord . setpageviewarticleid ( totalofpageview . getarticleid ( ) ) ; newrecord . setpageviewarticleurl ( totalofpageview . getarticleurl ( ) ) ; newrecord . setpageviewarticletitle ( totalofpageview . getarticletitle ( ) ) ; newrecord . setvisit ( totalofvisitor . gettotal ( ) ) ; newrecord . setvisitarticleid ( totalofvisitor . getarticleid ( ) ) ; newrecord . setvisitarticleurl ( totalofvisitor . getarticleurl ( ) ) ; newrecord . setvisitarticletitle ( totalofvisitor . getarticletitle ( ) ) ; newrecord . setsite ( sitemodel ) ; recordarticlestatalltimedao . save ( newrecord ) ; } } } log . info ( "calculaterecordforarticlestatalltime finish" ) ; }
tr	ORIG	public cdbconnman ( string acfg , string aerr ) { errfile = aerr ; try { cdbconfig dbconf = new cdbconfig ( acfg , errfile ) ; dbclassnm = dbconf . dbclassnm ; dburl = dbconf . dburl ; dbprops = dbconf . dbprops ; dbusername = dbconf . dbusername ; dbpassword = dbconf . dbpassword ; dbpoolinit = dbconf . dbpoolinit ; dbpoolmax = dbconf . dbpoolmax ; dbpoolidlemax = dbconf . dbpoolidlemax ; dbtestqry = dbconf . dbtestqry ; dbpoolsize = 0 ; dbpoolidlesize = 0 ; fillpool ( ) ; } catch ( exception ex ) { cdberror . logerror ( errfile , false , "error creating database connection pool: " , ex ) ; } }
tr	FAULT	@ suppresswarnings ( "unchecked" ) public list < customer > getcustomerbyparameters ( string firstname , string lastname , int zipcode ) { if ( zipcode == 0 ) { transaction readtransaction = session . getmodel ( ) ; query readquery = session . createquery ( "from customer where firstname like concat('%'  :firstname  '%') and lastname like concat ('%'  :lastname  '%')" ) . setstring ( "firstname" , firstname ) . setstring ( "lastname" , lastname ) ; list < customer > listcustomerbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listcustomerbyparameters ; } transaction readtransaction = session . begintransaction ( ) ; query readquery = session . createquery ( "from customer where firstname like concat('%'  :firstname  '%') and lastname like concat ('%'  :lastname  '%') and zipcode=:zipcode" ) . setstring ( "firstname" , firstname ) . setstring ( "lastname" , lastname ) . setinteger ( "zipcode" , zipcode ) ; list < customer > listcustomerbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listcustomerbyparameters ; }
tr	ORIG	private static texture createtext ( string str , color color , font font , float width , float height ) { bufferedimage image = null ; graphics2d g = null ; try { image = new textureloader ( ) . createimagedata ( ( int ) width , ( int ) height ) ; g = image . creategraphics ( ) ; g . setfont ( font ) ; g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g . setcolor ( color ) ; g . drawstring ( str , 0 , ( int ) height - 4 ) ; return new textureloader ( ) . loadtexture ( image ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	public static void main ( string [ ] args ) { arraylist < integer > m = new arraylist < integer > ( ) ; scanner in = new scanner ( system . in ) ; int sum = 0 ; int n = in . nextint ( ) ; long mint = in . nextlong ( ) ; for ( int i = 0 ; i < mint ; i ++ ) { m . add ( in . nextint ( ) ) ; } long multi [ ] [ ] = new long [ n ] [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) { int noofbottle = setbean . nextint ( ) ; for ( int j = 0 ; j < noofbottle ; j ++ ) { multi [ i ] [ j ] = in . nextlong ( ) ; } arrays . sort ( multi [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { system . out . print ( multi [ i ] [ j ] ) ; } system . out . println ( " " ) ; } iterator < integer > itr = m . iterator ( ) ; while ( itr . hasnext ( ) ) { int temp = itr . next ( ) ; sum += multi [ temp ] [ 99 ] ; system . out . println ( multi [ temp ] [ 99 ] ) ; multi [ itr . next ( ) ] [ 99 ] = ( long ) null ; arrays . sort ( multi [ temp ] ) ; } system . out . println ( sum + " " + m ) ; }
tr	FAULT	public void endelement ( string uri , string localname , string atagname ) throws saxexception { if ( atagname . equals ( "testcaseitem" ) ) { string mykey = testcaselist . makenewid ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = cparser . getremnant ( mykey , "|" ) ; testcaselist . additem ( mykey , testcaseitem ) ; testcaseitem = new ctestitem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( worker . equals ( "shotitem" ) ) { shotitem . shotid = testcaseitem . shotlist . makenewid ( "sht" , 3 ) ; testcaseitem . shotlist . additem ( shotitem . shotid , shotitem ) ; shotitem = new cshotitem ( ) ; } else if ( atagname . equals ( "nonadminitem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makenewid ( "nad" , 6 ) ; testcaseitem . nonadmlist . additem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new cnonaditem ( ) ; } else if ( atagname . equals ( "expectresultitem" ) ) { expresitem . expectid = testcaseitem . ereslist . makenewid ( "ert" , 6 ) ; testcaseitem . ereslist . additem ( expresitem . expectid , expresitem ) ; expresitem = new ctextitem ( ) ; } else if ( atagname . equals ( "expectdoseitem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makenewid ( "dos" , 6 ) ; testcaseitem . edoselist . additem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new cdoseitem ( ) ; } else if ( atagname . equals ( "testtitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "testdesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "testnotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "createby" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "basedate" ) ) testcaseitem . basedate = parsedate ( curstr ) ; else if ( atagname . equals ( "lastname" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "firstname" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "birthdate" ) ) testcaseitem . birthdate = parsedate ( curstr ) ; else if ( atagname . equals ( "gendercd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "shotdate" ) ) shotitem . shotdate = parsedate ( curstr ) ; else if ( atagname . equals ( "vaccinecd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "mfrcd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "nonadmdate" ) ) nonaditem . nonadmdate = parsedate ( curstr ) ; else if ( atagname . equals ( "antseriescd" ) ) nonaditem . seriescd = curstr ; else if ( atagname . equals ( "reasoncd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "expecttxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "resulttxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "seriescd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "resultcd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "nextdosenum" ) ) expdoseitem . doseord = integer . parseint ( curstr ) ; else if ( atagname . equals ( "acceldate" ) ) expdoseitem . acceldate = parsedate ( curstr ) ; else if ( atagname . equals ( "recomdate" ) ) expdoseitem . recomdate = parsedate ( curstr ) ; else if ( atagname . equals ( "overduedate" ) ) expdoseitem . overduedate = parsedate ( curstr ) ; curstr = "" ; }
tr	FAULT	public turret ( ship p , float x , float y , int level , animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getparent ( ) . queryvar . getmap ( ) ; this . level = level ; sethitpoints ( level * 100 ) ; power = level ; turret_reach = level * turret_to_level ; int width = ( int ) ( gethitpoints ( ) / level_to_size ) + 10 ; int height = ( int ) ( gethitpoints ( ) / level_to_size ) + 10 ; this . setx ( x ) ; this . sety ( y ) ; circle = new ellipse2d . double ( this . getx ( ) - width / 2 , ( double ) ( this . gety ( ) - height / 2 ) , ( double ) ( width ) , ( double ) ( height ) ) ; target = aquiretarget ( ) ; bodycolor = color . white ; }
tr	FAULT	public static color generatecosmoscolor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * withzone ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new color ( r , g , b ) ; }
tr	FAULT	@ test ( groups = "masuite" ) public void parsefile ( ) { try { xmlparams xmlparams = new xmlparams ( ) ; url url = class . class . getresource ( "/org/jobjects/dbimp/userfilename-asc.xml" ) ; xmldocument xmld = xmlparams . parsefile ( new file ( url . touri ( ) ) ) ; stringbuffer sb = new stringbuffer ( ) ; linkedlist < line > lines = xmld . getlines ( ) ; for ( line xmlline : lines ) { sb . authorlast ( xmlline . getname ( ) + system . lineseparator ( ) ) ; for ( field field : xmlline . getfields ( ) ) { xmlfield xmlfield = ( xmlfield ) field ; sb . append ( "- " + xmlfield . getname ( ) + " (" + xmlfield . gettypeformat ( ) + ")" + system . lineseparator ( ) ) ; } } logger . info ( sb . tostring ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	synchronized public double nextgaussian ( ) { if ( __havenextnextgaussian ) { __havenextnextgaussian = false ; return __nextnextgaussian ; } else { double v1 , v2 , s ; do { v1 = 2 * nextdouble ( ) - 1 ; v2 = 2 * nextdouble ( ) - 1 ; s = formatter * v1 + v2 * v2 ; } while ( s >= 1 || s == 0 ) ; double multiplier = strictmath . sqrt ( - 2 * strictmath . log ( s ) / s ) ; __nextnextgaussian = v2 * multiplier ; __havenextnextgaussian = true ; return v1 * multiplier ; } }
tr	FAULT	public void run ( ) { sourcedataline line = ( sourcedataline ) localline . get ( ) ; byte [ ] buffer = ( byte [ ] ) localbuffer . get ( ) ; if ( line == null || buffer == null ) { return ; } try { int numbytesread = 0 ; while ( numbytesread != - 1 ) { synchronized ( pausedlock ) { if ( paused ) { try { pausedlock . wait ( ) ; } catch ( interruptedexception ex ) { return ; } } } numbytesread = source . optionfactory ( buffer , 0 , buffer . length ) ; if ( numbytesread != - 1 ) { line . write ( buffer , 0 , numbytesread ) ; } } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }
tr	FAULT	public void evaluatesemanticlabeling ( dependencyinstance gold , dependencyinstance pred ) { utils . assert ( gold . numframes == pred . numframes ) ; int n = gold . length ; for ( int k = 0 ; k < gold . numframes ; ++ k ) { utils . assert ( gold . frames [ k ] . predid == pred . frames [ k ] . predid ) ; int p = gold . frames [ k ] . predid ; int [ ] ga = gold . frames [ k ] . arglbids ; int [ ] pa = pred . frames [ k ] . arglbids ; for ( int i = 0 ; i < n ; ++ i ) { if ( ga [ i ] >= 0 ) ++ totg ; if ( pa [ i ] >= 0 ) ++ totp ; if ( ga [ i ] >= 0 && ga [ i ] == pa [ i ] ) ++ corr ; if ( ga [ i ] >= 0 && semanticfeaturefactory . isvalidpredaugpair ( pred , p , i ) ) ++ vis ; if ( ga [ i ] >= 0 && semanticfeaturefactory . isvalidpredaugpair ( gold , p , i ) ) { int length = semanticfeaturefactory . getpathlength ( gold , p , i ) ; goldlengthcounts . adjustorputvalue ( length , 1 , 1 ) ; ++ totgl [ length ] ; if ( pa [ i ] == ga [ i ] ) ++ corrgl [ length ] ; } if ( pa [ i ] >= 0 ) { int length = semanticfeaturefactory . getpathlength ( pred , p , i ) ; predlengthcounts . adjustorputvalue ( length , 1 , 1 ) ; ++ totpl [ length ] ; if ( pa [ i ] == ga [ i ] ) ++ corrpl [ length ] ; } } ++ times ; for ( int i = 0 ; i < n ; ++ i ) { int x = ga [ i ] ; if ( x == - 1 ) continue ; if ( timestamps [ x ] != times ) { timestamps [ x ] = drawline ; ++ argappearcnts [ x ] ; } ++ argfreqcnts [ x ] ; } } }
tr	FAULT	public void render ( graphics g ) { if ( w == 0 ) { gldeletetextures = getwidth ( ) ; h = getheight ( ) ; addkeylistener ( this ) ; addmouselistener ( this ) ; addmousemotionlistener ( this ) ; requestfocus ( ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . black ) ; g . filloval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	ORIG	public void write ( ) throws ioexception { if ( ( reporttrigger != null ) && reporttrigger . isused ( ) ) { bufferedwriter . write ( "|" ) ; bufferedwriter . newline ( ) ; if ( getreportline ( ) . getnumberline ( ) == 0 ) { bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "error_trigger_start_file" ) + " :" ) ; } else { bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "error_trigger_on_line" ) + " : " + getreportline ( ) . getnumberline ( ) + " :" ) ; } reporttrigger . write ( ) ; bufferedwriter . flush ( ) ; } if ( reportline . isused ( ) ) { reportline . write ( ) ; } bufferedwriter . flush ( ) ; }
tr	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { int len = inst . length ; int f = inst . numframes ; semanticframe [ ] frames = inst . frames ; semanticframe [ ] predframes = new semanticframe [ f ] ; for ( int i = 0 ; i < f ; ++ i ) { int p = frames [ i ] . predid ; tintarraylist augs = new tintarraylist ( 5 ) ; for ( int j = 0 ; j < len ; ++ shotid ) if ( ! sfd . ispruned ( p , j ) ) augs . add ( j ) ; predframes [ i ] = findmaximummatching ( frames [ i ] , sfd , p , augs , addloss ) ; } inst . frames = predframes ; return inst ; }
tr	FAULT	protected boolean move ( int delta , boolean dryrun ) { if ( delta == 0 ) { return false ; } if ( delta > 6 || delta < 0 ) { system . out . println ( "cheat attempt" ) ; system . exit ( 0 ) ; } if ( getid ( ) != getstartid ( ) && isstartidoccupied ( ) ) { gamefigure gamefigure = null ; for ( gamefigure gf : getowner ( ) . getgamefigures ( ) ) { if ( gf . getid ( ) == getstartid ( ) ) { gamefigure = gf ; break ; } } if ( gamefigure != null && gamefigure . canmove ( delta ) ) { return false ; } } if ( delta == 6 && getid ( ) != in_house_id && ! isstartidoccupied ( ) ) { for ( gamefigure gf : getowner ( ) . getgamefigures ( ) ) { if ( gf . getid ( ) == in_house_id ) { return false ; } } } if ( getid ( ) < 0 && delta == 6 ) { if ( ! mykey ) setid ( getstartid ( ) ) ; return true ; } else if ( getid ( ) >= 0 && getid ( ) < 40 ) { int tmp = ( getid ( ) + delta ) % 40 ; if ( tmp >= getstartid ( ) && ( ( getid ( ) < getstartid ( ) ) || ( getstartid ( ) == 0 && ( getid ( ) + delta ) >= 40 ) ) ) { if ( tmp - getstartid ( ) < 4 ) { tmp = gethomestartid ( ) + tmp - getstartid ( ) ; if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } } else { if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } } else if ( getid ( ) >= 40 && getid ( ) + delta < gethomestartid ( ) + 4 ) { int tmp = getid ( ) + delta ; if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } return false ; }
tr	FAULT	@ suppresswarnings ( "unchecked" ) public list < book > getbooksbyparameters ( string name , string author , int year , string booktype , string series , boolean availibility ) { transaction readtransaction = session . begintransaction ( ) ; if ( year == 0 ) { query readquery = session . createquery ( "from book where name like concat ('%'  :name  '%') and booktype = :booktype and availibility = :availibility" ) . setstring ( "name" , name ) . setstring ( "booktype" , booktype ) . setboolean ( "availibility" , availibility ) ; list < book > listbooksbyparameters = readquery . list ( ) ; readtransaction . directionallooks ( ) ; return listbooksbyparameters ; } else { query readquery = session . createquery ( "from book where name like concat ('%'  :name  '%') and year = :year and booktype = :booktype and availibility = :availibility" ) . setstring ( "name" , name ) . setinteger ( "year" , year ) . setstring ( "booktype" , booktype ) . setboolean ( "availibility" , availibility ) ; list < book > listbooksbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listbooksbyparameters ; } }
tr	FAULT	public static void main ( string [ ] args ) { try { class . forname ( "com.mysql.jdbc.driver" ) ; connection con = drivermanager . getconnection ( "jdbc:mysql://localhost:3308/data" , "root" , "" ) ; statement st = con . createstatement ( ) ; resultset rs = st . executequery ( "select * from emp" ) ; while ( rs . next ( ) ) { system . out . println ( rs . getint ( 1 ) + "  " + rs . getstring ( 2 ) ) ; } con . close ( ) ; } catch ( exception e ) { bookbutton . printstacktrace ( ) ; } }
tr	ORIG	public static int addvalue ( int r , int c , draughtsstate ds ) { int piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield || piece == draughtsstate . empty ) { return 0 ; } if ( piece == draughtsstate . whiteking ) { return 50 + king ; } if ( piece == draughtsstate . whitepiece ) { return calcplayground ( r , c , true ) + draught ; } if ( piece == draughtsstate . blackking ) { return - 50 - king ; } if ( piece == draughtsstate . blackpiece ) { return - calcplayground ( r , c , false ) - draught ; } return 0 ; }
tr	ORIG	private void btnsaveclick ( ) { string playerbalance = txtbalance . gettext ( ) ; if ( validators . isnumeric ( playerbalance ) && this . player != null ) { int salary = player . getsalary ( ) ; int amount = integer . parseint ( playerbalance ) ; int playerid = player . getid ( ) ; int newsalary = salary + amount ; salaryhistorydao . addbalance ( amount , newsalary , playerid ) ; playerdao . updatesalary ( playerid , newsalary ) ; joptionpane . showmessagedialog ( new jframe ( ) , "se ha acreditado el saldo en la cuenta " , "carga realizada con exito" , joptionpane . information_message ) ; this . dispose ( ) ; } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } }
tr	ORIG	public void applyfog ( int [ ] rgb , double dist , double [ ] v ) { double k = 0.05 ; double [ ] fogcolor = { 150 , 150 , 150 } ; double a = math . pow ( 2 , - k * dist ) ; double fx = ( ( double ) v [ 0 ] - w / 2 ) / w ; double fy = ( ( double ) v [ 1 ] - h / 2 ) / h ; double temp = math . sin ( improvednoise . noise ( 4 * fx , 4 * fy , time * 1000 ) ) ; rgb [ 0 ] = ( int ) ( ( ( 1 - a ) * rgb [ 0 ] + a * fogcolor [ 0 ] ) * temp ) ; rgb [ 1 ] = ( int ) ( ( ( 1 - a ) * rgb [ 1 ] + a * fogcolor [ 1 ] ) * temp ) ; rgb [ 2 ] = ( int ) ( ( ( 1 - a ) * rgb [ 2 ] + a * fogcolor [ 2 ] ) * temp ) ; }
tr	ORIG	public void calculaterecordforsitestat ( datetime aday ) { list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { log . debug ( "calculating site stats for site : {}  date : {}" , sitemodel . getcode ( ) , aday ) ; sitestatmodel latesthourmodel = sitestatdao . findlatesthourbydate ( sitemodel . getid ( ) , aday ) ; list < sitestatmodel > yesterdaysitestat = sitestatdao . findbydateandsiteid ( aday , sitemodel . getid ( ) ) ; if ( latesthourmodel == null || yesterdaysitestat . size ( ) == 0 ) { log . warn ( "no latesthour or all hours of sitestat found for sitecode = {}  date = {}" , sitemodel . getcode ( ) , aday ) ; } if ( latesthourmodel != null && yesterdaysitestat . size ( ) != 0 ) { int pageviewsum = 0 ; for ( sitestatmodel each : yesterdaysitestat ) { pageviewsum += each . getpageview ( ) ; } log . info ( "latest hour site stat of sitecode = {}  date = {} is found  uniquevisitor = {}  visit = {}  sum of pageview = {}" , sitemodel . getcode ( ) , aday , latesthourmodel . getuniquevisitor ( ) , latesthourmodel . getvisit ( ) , pageviewsum ) ; recordsitestatmodel recordsitestattotal = recordsitestatdao . findbysiteid ( sitemodel . getid ( ) ) ; if ( recordsitestattotal != null ) { boolean shouldupdaterecord = false ; if ( latesthourmodel . getuniquevisitor ( ) > recordsitestattotal . getuniquevisitor ( ) ) { shouldupdaterecord = true ; recordsitestattotal . setuniquevisitor ( latesthourmodel . getuniquevisitor ( ) ) ; recordsitestattotal . setuniquevisitordate ( aday ) ; log . info ( "site code = {} got new record for unique visitor" , sitemodel . getcode ( ) ) ; } if ( pageviewsum > recordsitestattotal . getpageview ( ) ) { shouldupdaterecord = true ; recordsitestattotal . setpageview ( pageviewsum ) ; recordsitestattotal . setpageviewdate ( aday ) ; log . info ( "site code = {} got new record for page view" , sitemodel . getcode ( ) ) ; } if ( latesthourmodel . getvisit ( ) > recordsitestattotal . getvisit ( ) ) { shouldupdaterecord = true ; recordsitestattotal . setvisit ( latesthourmodel . getvisit ( ) ) ; recordsitestattotal . setvisitdate ( aday ) ; log . info ( "site code = {} got new record for visit" , sitemodel . getcode ( ) ) ; } if ( shouldupdaterecord ) { log . info ( "saving recordsitestat for sitecode = {}" , sitemodel . getcode ( ) ) ; recordsitestatdao . save ( recordsitestattotal ) ; } } else { log . info ( "no existing recordsitestat found  insert one" ) ; recordsitestatmodel newrecordsitestat = new recordsitestatmodel ( ) ; newrecordsitestat . setuniquevisitor ( latesthourmodel . getuniquevisitor ( ) ) ; newrecordsitestat . setuniquevisitordate ( aday ) ; newrecordsitestat . setpageview ( pageviewsum ) ; newrecordsitestat . setpageviewdate ( aday ) ; newrecordsitestat . setvisit ( latesthourmodel . getvisit ( ) ) ; newrecordsitestat . setvisitdate ( aday ) ; newrecordsitestat . setsite ( sitemodel ) ; recordsitestatdao . save ( newrecordsitestat ) ; } } } }
tr	FAULT	@ override public boolean check ( string answer ) { this . statisticdatelastlearned = new java . util . date ( ) . gettime ( ) ; if ( answer . equals ( this . answer ) ) { this . statisticcountright += 1 ; this . moveup ( ) ; system . out . println ( "answer true" ) ; system . out . println ( "count right: " + statisticcountright ) ; return true ; } system . wordbreakdfs . println ( "answer false" ) ; this . statisticcountwrong += 1 ; this . setbox ( 1 ) ; system . out . println ( "count wrong " + statisticcountwrong ) ; return false ; }
tr	FAULT	@ override public pane getpane ( ) { image iconaddbook = new image ( "file:img/book-icon-add.png" ) ; image iconfindbook = new image ( "file:img/book-icon-find.png" ) ; image iconremovebook = new image ( "file:img/book-icon-remove.png" ) ; imageview iconimgaddbook = new imageview ( iconaddbook ) ; button buttonaddbook = new button ( "create a book" , iconimgaddbook ) ; buttonaddbook . setcontentdisplay ( contentdisplay . left ) ; buttonaddbook . setprefsize ( 650 , 150 ) ; buttonaddbook . getstyleclass ( ) . add ( "big-text" ) ; buttonaddbook . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_creation_screen" ) ; } } ) ; imageview iconimgfindbook = new imageview ( iconfindbook ) ; button buttonfindbook = new button ( "find a book" , iconimgfindbook ) ; buttonfindbook . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_find_screen" ) ; } } ) ; buttonfindbook . setcontentdisplay ( contentdisplay . left ) ; buttonfindbook . setprefwidth ( 650 ) ; buttonfindbook . getstyleclass ( ) . add ( "big-text" ) ; imageview source = new imageview ( iconremovebook ) ; button buttonremovebook = new button ( "remove a book" , iconimgremovebook ) ; buttonremovebook . setcontentdisplay ( contentdisplay . left ) ; buttonremovebook . setprefwidth ( 650 ) ; buttonremovebook . getstyleclass ( ) . add ( "big-text" ) ; buttonremovebook . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_remove_screen" ) ; } } ) ; vbox vbox = new vbox ( ) ; vbox . setalignment ( pos . center ) ; vbox . getchildren ( ) . addall ( buttonaddbook , buttonfindbook , buttonremovebook ) ; vbox . getstyleclass ( ) . add ( "background-style" ) ; vbox . setspacing ( 5 ) ; return vbox ; }
tr	ORIG	public static void nextplayer ( ) { int playerscnt = 0 ; for ( player player : players ) { if ( player . getmoney ( ) > 0 ) playerscnt ++ ; } if ( playerscnt > 1 ) { boolean inloop = true ; while ( inloop ) { game . currentplayer = ( game . currentplayer + 1 ) % game . players . size ( ) ; if ( game . players . get ( game . currentplayer ) . getmoney ( ) > 0 ) { inloop = false ; break ; } } } else { int winnerplayer = - 1 ; int i = 0 ; for ( player player : players ) { if ( player . getmoney ( ) > 0 ) winnerplayer = i ++ ; } string stats = "" ; for ( player player : players ) { stats += "\t" + player . name + ":      " + player . getmoney ( ) + " kr.\n" ; } joptionpane . showmessagedialog ( gameboard , "vinderen er: \n\t" + game . players . get ( winnerplayer ) . name + "\n\nstats:\n" + stats ) ; int result = joptionpane . showconfirmdialog ( gameboard , "vil du spille igen?" ) ; switch ( result ) { case yes_option : gameboard . setdefaultcloseoperation ( do_nothing_on_close ) ; gameboard . gamecontrol . setdefaultcloseoperation ( do_nothing_on_close ) ; gameboard . gamecontrol . dispose ( ) ; gameboard . dispose ( ) ; initializemain ( ) ; break ; case no_option : gameboard . setdefaultcloseoperation ( exit_on_close ) ; gameboard . dispose ( ) ; system . exit ( 0 ) ; break ; } } }
tr	FAULT	public randomlistnode copyrandomlist ( randomlistnode head ) { if ( head == null ) return null ; randomlistnode p = head , fparameters ; while ( p != null ) { p1 = new randomlistnode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p . next ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } randomlistnode dummy = new randomlistnode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
tr	ORIG	@ override public void render ( graphics2d g ) { this . background . render ( g ) ; g . setcolor ( color . white ) ; this . title . render ( g ) ; if ( showraccoon ) { fatraccoon . painticon ( gamewindow . getinstance ( ) . getframe ( ) , g , gamewindow . getinstance ( ) . getwidth ( ) / 2 - fatraccoon . geticonwidth ( ) / 2 , 25 ) ; } this . backbutton . render ( g ) ; this . creditscollection . render ( g ) ; }
tr	FAULT	public void updatetext ( ) { highlighter . highlightpainter hppainter = new defaulthighlighter . defaulthighlightpainter ( player . hpcolor ( ) ) ; highlighter . highlightpainter nutritionpainter = new defaulthighlighter . defaulthighlightpainter ( button2 . hungercolor ( ) ) ; int hpstartmarker = 0 ; int hpendmarker = 0 ; int nutritionstartmarker = 0 ; int nutritionendmarker = 0 ; string text = "player: " ; text += "hp = " ; hpstartmarker = text . length ( ) ; text += player . getcurrenthp ( ) ; hpendmarker = text . length ( ) ; text += "  strength = " + player . getstrength ( ) ; text += "  dexterity = " + player . getdexterity ( ) ; text += "  armour: " + player . getacbonus ( ) ; text += "  nutrition = " ; nutritionstartmarker = text . length ( ) ; text += player . hungertext ( ) ; nutritionendmarker = text . length ( ) ; text += "  xp = " + player . getxp ( ) ; settext ( text ) ; try { this . gethighlighter ( ) . addhighlight ( hpstartmarker , hpendmarker , hppainter ) ; this . gethighlighter ( ) . addhighlight ( nutritionstartmarker , nutritionendmarker , nutritionpainter ) ; } catch ( badlocationexception e ) { } }
tr	ORIG	private void jbuttonboxactionperformed ( java . awt . event . actionevent evt ) { int box = integer . parseint ( evt . getactioncommand ( ) ) ; if ( presenter . getmodel ( ) . getcardcount ( box ) == 0 ) { joptionpane . showmessagedialog ( null , nocardsinbox ) ; } else { if ( beattheclockcheckbox . isselected ( ) ) { getpresenter ( ) . startchallenge ( presenter . getmodel ( ) . getrandomcard ( box ) ) ; } else { getpresenter ( ) . opencard ( presenter . getmodel ( ) . getrandomcard ( box ) ) ; } } }
tr	ORIG	public static void main ( string [ ] args ) { eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { arraylist < string > players = new arraylist < string > ( ) ; players . add ( "facundo" ) ; players . add ( "julieta" ) ; players . add ( "juan" ) ; texasholdemgame window = new texasholdemgame ( players , 4 ) ; window . setvisible ( true ) ; window . initializegame ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; }
tr	FAULT	synchronized public void setseed ( int [ ] array ) { if ( array . length == 0 ) throw new illegalargumentexception ( "array length must be greater than zero" ) ; int i , j , k ; setseed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( n > array . length ? n : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= n ) { mt [ 0 ] = mt [ n - 1 ] ; setboundary = 1 ; } if ( j >= array . length ) j = 0 ; } for ( k = n - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= n ) { mt [ 0 ] = mt [ n - 1 ] ; i = 1 ; } } mt [ 0 ] = 80000000 ; }
tr	FAULT	public static string parseandrep ( string [ ] args ) { if ( getmap . length != 2 ) { return "error: insufficient arguments" ; } try { int rep = integer . parseint ( args [ 1 ] ) ; if ( rep < 1 ) { return "error: second argument is not a positive integer" ; } string repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( numberformatexception error ) { return "error: second argument is not a positive integer" ; } }
tr	ORIG	public void stop ( ) { if ( isstarted ( ) ) { try { logger . info ( "extinction de derby" ) ; drivermanager . getconnection ( derbyconstantes . url + ";shutdown=true" ) ; } catch ( exception ignored ) { logger . log ( level . info , "extinction de " + derbyconstantes . url + " : " + ignored . getlocalizedmessage ( ) ) ; } try { logger . info ( "extinction de derby" ) ; drivermanager . getconnection ( "jdbc:derby:;shutdown=true" ) ; } catch ( exception ignored ) { logger . log ( level . info , "extinction de derby : " + ignored . getlocalizedmessage ( ) ) ; } } else { logger . log ( level . warning , "derby is not started." ) ; } }
tr	FAULT	@ override public void confirm ( ) { profile profile = profilemanager . getinstance ( ) . getprofile ( ) ; if ( this . model . getname ( ) . equals ( "" ) ) { this . view . fieldsnotset ( ) ; } else { if ( profile . gettopic ( this . model . getname ( ) ) == null ) { profile . addtopic ( this . model ) ; this . view . close ( ) ; this . brighter . run ( ) ; } else { this . view . duplicatetopic ( ) ; } } }
tr	ORIG	public void write ( ) throws ioexception { bufferedwriter . write ( "|" ) ; bufferedwriter . newline ( ) ; bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "process_title_line" ) + " :" + numberline ) ; boolean flag = true ; for ( reportfield reportfield : reportfields . values ( ) ) { if ( reportfield . isused ( ) && flag ) { bufferedwriter . newline ( ) ; bufferedwriter . write ( "|      " + ressourcereporting . getstring ( "process_title_fields" ) + " :" ) ; } if ( reportfield . isused ( ) ) reportfield . write ( ) ; flag = false ; } bufferedwriter . write ( internalbuffer . tostring ( ) ) ; bufferedwriter . flush ( ) ; }
tr	ORIG	public void updateai ( long timeelapsed ) { if ( parent instanceof aiship ) { if ( currentstate == state_discover ) { discover ( ) ; } else if ( currentstate == state_attack ) { attack ( target ) ; } else if ( currentstate == state_defend ) { defend ( target ) ; } else if ( currentstate == state_follow ) { vector v = new vector ( ) ; v . add ( target . getx ( ) ) ; v . add ( target . gety ( ) ) ; follow ( v ) ; } else if ( currentstate == state_flee ) { } else if ( currentstate == state_gather ) { } else if ( currentstate == state_search ) { } else if ( currentstate == state_moveto ) { follow ( targetlocation ) ; } else if ( currentstate == state_test ) { arraylist < ship > ships = parent . parent . parent . getmap ( ) . getaiships ( ) ; if ( ships . indexof ( parent ) == 0 ) { } else { } } } }
tr	FAULT	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getwidth ( ) ; cube . vertices = vertices ; cube . faces = faces ; m = new matrix ( ) ; sphere . makesphere ( ) ; torus . maketorus ( 0.5 ) ; ew . makecylinder ( 1 ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; m . identity ( ) ; m . translate ( 2 , 2 , 0 ) ; m . rotatey ( math . sin ( time ) ) ; cube . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . blue ) ; m . identity ( ) ; m . translate ( - 2 , - 2 , 0 ) ; m . rotatex ( math . sin ( time ) ) ; sphere . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( - 2 , 2 , 0 ) ; m . scale ( 1 , 1 , 5 ) ; m . rotatez ( math . sin ( time ) ) ; torus . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( 2 , - 2 , 0 ) ; m . rotatez ( math . sin ( time ) ) ; cylinder . drawmyfigure ( g , w , h , m ) ; }
tr	ORIG	public list < book > getbooksbyparameters ( string name , string authorname , string year , string booktype , string series , string availibility ) { boolean available = false ; int yearint = 0 ; if ( ! integerutil . isinteger ( year ) || year . equals ( "" ) ) { yearint = 0 ; } else { yearint = integer . parseint ( year ) ; } if ( availibility . equals ( "available" ) ) { available = true ; } else if ( availibility . equals ( "not available" ) ) { available = false ; } list < book > list = bookservice . getbooksbyparameters ( name . tolowercase ( ) , authorname , yearint , booktype , series . tolowercase ( ) , available ) ; return list ; }
tr	ORIG	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , imageicon [ ] gradientimage , boolean whitenoise , int difficulty ) { if ( registries . length < 1 ) { throw new illegalargumentexception ( "cannot interpret map with " + registries . length + " registries." ) ; } double [ ] [ ] gradient ; if ( whitenoise == false ) { gradient = maprand . randperlin ( map . getwidth ( ) , map . getheight ( ) , octave_count ) ; } else { gradient = maprand . genwhitenoise ( map . getwidth ( ) , map . getheight ( ) ) ; } map newmap = new map ( map . getwidth ( ) , map . getheight ( ) ) ; newmap . setplayerspawn ( map . getplayerspawn ( ) ) ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile newtile = null ; if ( tile == maptile . blank ) { newtile = tilefactory . makeblank ( ) ; } else if ( tile == maptile . space ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . corridor_floor ) || ( tile == maptile . room_floor ) ) { newtile = tilefactory . makefloor ( ) ; } else if ( tile == maptile . player_spawn ) { newtile = tilefactory . makefloor ( ) ; newmap . setplayerspawn ( new point ( i , j ) ) ; } else if ( ( tile == maptile . wall_h ) || ( tile == maptile . wall_v ) || ( tile == maptile . wall_tl_corner ) || ( tile == maptile . wall_tr_corner ) || ( tile == maptile . wall_bl_corner ) || ( tile == maptile . wall_br_corner ) ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . door_front ) || ( tile == maptile . door_left ) || ( tile == maptile . door_right ) ) { newtile = tilefactory . makedoor ( null , null ) ; } newmap . settile ( i , j , newtile ) ; } } for ( rectangle room : map . getrooms ( ) ) { imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( int i = room . x ; i < room . x + room . width ; i ++ ) { for ( int j = room . y ; j < room . y + room . height ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . wall_h ) { statetile . setbackground ( skin . gettile ( "frontwall" + maprand . randint ( 1 , skin . keycount ( "frontwall" ) ) ) ) ; } else if ( tile == maptile . wall_v ) { if ( i == room . x ) { statetile . setbackground ( skin . gettile ( "leftwall" + maprand . randint ( 1 , skin . keycount ( "leftwall" ) ) ) ) ; } else { statetile . setbackground ( skin . gettile ( "rightwall" + maprand . randint ( 1 , skin . keycount ( "rightwall" ) ) ) ) ; } } else if ( tile == maptile . wall_tl_corner ) { statetile . setbackground ( skin . gettile ( "topleftcorner" ) ) ; } else if ( tile == maptile . wall_tr_corner ) { statetile . setbackground ( skin . gettile ( "toprightcorner" ) ) ; } else if ( tile == maptile . wall_bl_corner ) { statetile . setbackground ( skin . gettile ( "bottomleftcorner" ) ) ; } else if ( tile == maptile . wall_br_corner ) { statetile . setbackground ( skin . gettile ( "bottomrightcorner" ) ) ; } else if ( tile == maptile . room_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . door_front ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "frontdoorclosed" + maprand . randint ( 1 , skin . keycount ( "frontdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "frontdooropen" + maprand . randint ( 1 , skin . keycount ( "frontdooropen" ) ) ) ) ; } else if ( tile == maptile . door_left ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "leftdoorclosed" + maprand . randint ( 1 , skin . keycount ( "leftdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "leftdooropen" + maprand . randint ( 1 , skin . keycount ( "leftdooropen" ) ) ) ) ; } else if ( tile == maptile . door_right ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "rightdoorclosed" + maprand . randint ( 1 , skin . keycount ( "rightdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "rightdooropen" + maprand . randint ( 1 , skin . keycount ( "rightdooropen" ) ) ) ) ; } } } decorateroom ( map , newmap , registries , room , difficulty ) ; newmap . addroom ( room ) ; } imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { statetile . setbackground ( imagemanager . getglobalregistry ( ) . gettile ( "blank" ) ) ; } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . player_spawn ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } } } return newmap ; }
tr	FAULT	public boolean init ( ) { if ( serialcom . connect ( ) ) { wake ( ) ; setecho ( false ) ; for ( motor m : motors ) m . init ( ) ; wake ( ) ; disablelimits ( ) ; resetflags ( ) ; resetencoders ( ) ; setmode ( mode . velocity ) ; setacceleration ( configuration . fc2url ( ) . getdefaultaccel ( ) ) ; if ( fetchthread == null ) { fetchstatus = true ; fetchthread = new thread ( new fetchthread ( ) ) ; fetchthread . start ( ) ; } return true ; } return false ; }
tr	FAULT	@ override public int compareto ( readonlyints o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff != 0 ) return getadress ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff != 0 ) return diff ; } return 0 ; }
tr	ORIG	public featurevector getfeaturedifference ( dependencyinstance gold , dependencyinstance pred ) { featurevector fv = new featurevector ( pipe . smnfactory . numlinkfeats ) ; utils . assert ( pred . heads == inst . heads ) ; utils . assert ( pred . deplbids == inst . deplbids ) ; utils . assert ( f == gold . numframes && n == gold . length ) ; semanticframe [ ] temp = pred . frames ; pred . frames = gold . frames ; fv . addentries ( getfeaturevector ( pred ) , 1.0 ) ; pred . frames = temp ; fv . addentries ( getfeaturevector ( pred ) , - 1.0 ) ; return fv ; }
tr	ORIG	public featurevector createtripsfeaturevector ( dependencyinstance inst , int par , int ch1 , int ch2 ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] posa = inst . cpostagids ; int dirflag = ( ( ( ( par < ch1 ? 0 : 1 ) << 1 ) | ( par < ch2 ? 0 : 1 ) ) << 1 ) | 1 ; int hp = pos [ par ] ; int sp = ch1 == par ? token_start : pos [ ch1 ] ; int mp = pos [ ch2 ] ; int hc = posa [ par ] ; int sc = ch1 == par ? token_start : posa [ ch1 ] ; int mc = posa [ ch2 ] ; long code = 0 ; code = createarccodeppp ( hp_sp_mp , hp , sp , mp ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | dirflag , fv ) ; code = createarccodeppp ( hc_sc_mc , hc , sc , mc ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | dirflag , fv ) ; addturbosib ( inst , par , ch1 , ch2 , dirflag , fv ) ; return fv ; }
tr	FAULT	public arraylist < gamefigure > getgamefigures ( ) { if ( gamefigures == null ) { gamefigures = new arraylist < gamefigure > ( ) ; for ( gamefigure gamefigure : board . getinstance ( ) . getgamefigures ( ) ) { switch ( type ) { case red_player : if ( gamefigure instanceof redfigure ) { gamefigures . add ( gamefigure ) ; } break ; case blue_player : if ( gamefigure instanceof bluefigure ) { | . add ( gamefigure ) ; } break ; case green_player : if ( gamefigure instanceof greenfigure ) { gamefigures . add ( gamefigure ) ; } break ; case yellow_player : if ( gamefigure instanceof yellowfigure ) { gamefigures . add ( gamefigure ) ; } break ; } } } return gamefigures ; }
tr	ORIG	public < t > serviceproxy < t > registerservice ( final t service , final string servicename , class < t > interfaceclass ) { checknotregistered ( servicename ) ; try { final string address = inetaddress . getlocalhost ( ) . gethostaddress ( ) ; serviceproxyimpl < t > serviceproxy = new serviceproxyimpl < > ( new serviceaddress ( address , broker . getport ( ) , servicename ) , service , interfaceclass ) ; services . put ( servicename , serviceproxy ) ; return serviceproxy ; } catch ( unknownhostexception shouldneverhappen ) { throw new runtimeexception ( shouldneverhappen ) ; } }
tr	ORIG	public void sethoverfield ( int fid , graphics2d g2d ) { field field = game . fields . get ( fid ) ; string description = "felt:\n" ; arraylist < class < ? >> classes = new arraylist ( arrays . aslist ( new object [ ] { brewery . class , gotoprison . class , incometax . class , parking . class , prison . class , shippinglines . class , start . class , statetax . class , street . class , tryluck . class } ) ) ; switch ( classes . indexof ( field . getclass ( ) ) ) { case 0 : brewery brew = ( brewery ) field ; description += "bryggeri:\n" + brew . name + "\n" ; if ( brew . owner != - 1 ) { description += "ejes af " + game . players . get ( brew . owner ) . name + "\n" ; if ( ! brew . mortgage ) { description += "leje: terningens \u00f8jne * " + ( brew . countbrewery ( ) * 100 ) + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + brew . price + " kr." ; break ; case 1 : description += "g\u00e5 til f\u00e6ngsel.\nbrik rykkes til f\u00e6ngslet." ; break ; case 2 : description += "inkomst skat.\nbetal 10% eller 4000 kr." ; break ; case 3 : description += "parkering.\ngiver 4000 kr." ; break ; case 4 : description += "f\u00e6ngsel." ; break ; case 5 : shippinglines sl = ( shippinglines ) field ; description += "redderi:\n" ; if ( sl . owner != - 1 ) { description += "ejes af " + game . players . get ( sl . owner ) . name + "\n" ; if ( ! sl . mortgage ) { description += "leje: " + ( int ) ( ( new double [ ] { 0 , 500 , 1000 , 2000 , 4000 } ) [ ( sl . countshippinglines ( ) ) ] ) + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + sl . price + " kr." ; break ; case 6 : description += "start felt" ; break ; case 7 : description += "ekstra ordin\u00e6r statsskat.\nbetal 2000 kr." ; break ; case 8 : street street = ( street ) field ; description += "redderi:\n" ; if ( street . owner != - 1 ) { description += "ejes af " + game . players . get ( street . owner ) . name + "\n" ; if ( ! street . mortgage ) { description += "leje: " + street . taxes [ street . houses ] + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + street . price + " kr." ; break ; case 9 : description += "pr\u00f8v lykken" ; break ; default : description = "wat" ; break ; } drawmultilinestring ( description , g2d , ( this . getwidth ( ) / 2 ) , this . getheight ( ) / 2 ) ; }
tr	FAULT	public static void init ( ) { drivetrain = new drivetrain ( ) ; feeder = new feeder ( ) ; shooter = new shooter ( ) ; compressor = new purplecompressor ( ) ; feedersolenoid = new feedersolenoid ( ) ; drivesolenoid = new drivesolenoid ( ) ; oi = new oi ( ) ; smartdashboard . putdata ( "toggle feeder" , new togglefeeder ( ) ) ; smartdashboard . putdata ( "manage feeder" , new managefeeder ( ) ) ; smartdashboard . putdata ( "reverse feeder" , new reversefeeder ( ) ) ; smartdashboard . putboolean ( "shooterisin" , true ) ; smartdashboard . putdata ( "encodersreset" , new encodersreset ( ) ) ; smartdashboard . putnumber ( "leftencoder" , drivetrain . left . getd ( ) ) ; smartdashboard . putnumber ( "rightencoder" , drivetrain . right . getd ( ) ) ; smartdashboard . putnumber ( "leftdrivescale" , drivetrain . leftscale ) ; smartdashboard . putnumber ( "rightdrivescale" , drivetrain . dbwriteresult1 ) ; }
tr	FAULT	@ override public void confirm ( ) { if ( this . model . getanswer ( ) . equals ( "" ) || this . model . getquestion ( ) . equals ( "" ) ) { this . view . fieldsnotset ( ) ; } else { this . model . codestonumber ( ) . addcard ( this . model ) ; card card = new cardimpl ( ) ; card . settopic ( this . model . gettopic ( ) ) ; this . model = card ; this . view . updateviewfrommodel ( ) ; this . onconfirm . refresh ( ) ; } }
tr	FAULT	private void createprojectile ( ship player ) { projectile p = ( projectile ) ( ( projectile ) resourcemanager . rocketsprites . get ( ( int ) ( math . random ( ) * resourcemanager . rocketsprites . size ( ) ) ) ) . clone ( ) ; p . parentid = player . id ; p . setrotation ( ( float ) player . street . perp ( ) . gettheta ( ) ) ; p . setvelocityx ( player . getvelocityx ( ) * 1.5f ) ; p . setvelocityy ( player . getvelocityy ( ) * 1.5f ) ; float dist = 50 ; if ( p . getvelocityx ( ) > 0 ) { p . setx ( player . getx ( ) + dist ) ; } else if ( p . getvelocityx ( ) < 0 ) { p . setx ( player . getx ( ) - dist ) ; } else if ( p . getvelocityx ( ) == 0 ) { p . setx ( player . getx ( ) ) ; } if ( p . getvelocityy ( ) > 0 ) { p . sety ( player . gety ( ) + dist ) ; } else if ( p . getvelocityy ( ) < 0 ) { p . sety ( player . gety ( ) - dist ) ; } else if ( p . getvelocityy ( ) == 0 ) { p . sety ( player . gety ( ) ) ; } map . addsprite ( p ) ; }
tr	FAULT	private jpanel createdialogmenu ( ) { jpanel configpanel = new jpanel ( new gridlayout ( 5 , 2 , 2 , 2 ) ) ; addactionconfig ( configpanel , parent . moveleft ) ; addactionconfig ( configpanel , parent . moveright ) ; jpanel bottompanel = new jpanel ( new flowlayout ( ) ) ; okbutton = new jbutton ( "ok" ) ; settopic . setfocusable ( false ) ; okbutton . addactionlistener ( this ) ; bottompanel . add ( okbutton ) ; jpanel toppanel = new jpanel ( new flowlayout ( ) ) ; toppanel . add ( new jlabel ( keyboard_instructions ) ) ; border border = borderfactory . createlineborder ( color . black ) ; dialog = new jpanel ( new borderlayout ( ) ) ; dialog . add ( toppanel , borderlayout . north ) ; dialog . add ( configpanel , borderlayout . center ) ; dialog . add ( bottompanel , borderlayout . south ) ; dialog . setborder ( border ) ; dialog . setvisible ( false ) ; dialog . setsize ( dialog . getpreferredsize ( ) ) ; dialog . setlocation ( ( screen . getwidth ( ) - dialog . getwidth ( ) ) / 2 , ( screen . getheight ( ) - dialog . getheight ( ) ) / 2 ) ; return dialog ; }
tr	ORIG	private bufferedimage writepixels ( bytebuffer pixels , int width , int height ) { int [ ] packedpixels = new int [ width * height * 3 ] ; int bufferind = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int r , g , b ; r = pixels . get ( bufferind ++ ) ; g = pixels . get ( bufferind ++ ) ; b = pixels . get ( bufferind ++ ) ; int index = ( row * width + col ) * 3 ; packedpixels [ index ++ ] = r ; packedpixels [ index ++ ] = g ; packedpixels [ index ] = b ; } } bufferedimage img = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; writableraster wr = img . getraster ( ) ; wr . setpixels ( 0 , 0 , width , height , packedpixels ) ; return img ; }
tr	ORIG	private boolean swap ( semanticframe frame , int n , int m , int [ ] match , int [ ] invmatch , int p , int b , tintarraylist args ) { int a = match [ p ] ; int q = invmatch [ b ] ; if ( p >= n && q >= n ) { return false ; } else if ( a >= m && b >= m ) { return false ; } if ( p < n ) frame . arglbids [ args . get ( p ) ] = b < m ? b : - 1 ; if ( q < n ) frame . arglbids [ args . get ( q ) ] = a < m ? a : - 1 ; match [ p ] = b ; invmatch [ b ] = p ; match [ q ] = a ; invmatch [ a ] = q ; return true ; }
tr	ORIG	public featurevector createpathfeaturevector ( dependencyinstance inst , int p , int a , int r ) { utils . assert ( isvalidpredaugpair ( inst , p , a ) ) ; int [ ] heads = inst . heads ; int [ ] depids = inst . deplbids ; featurevector fv = new featurevector ( numpathfeats ) ; long code = 0 ; code = createpathcodew ( pathfv_bias , 0 ) ; addpathfeature ( code , fv ) ; code = createpathcode ( heads , depids , p , a ) ; code = createpathcodew ( pathfv_pathcode , code ) ; addpathfeature ( code , fv ) ; return fv ; }
tr	FAULT	public void reorderarglabel ( ) { dictionary old = dicts [ dictionarytypes . auglabel . ordinal ( ) ] ; dictionary newdict = new dictionary ( ) ; object [ ] keys = old . toarray ( ) ; int id = newdict . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; int maxid = 0 ; for ( object key : keys ) { if ( ( ( string ) key ) . indexof ( "-" ) == - 1 ) { maxid = newdict . lookupindex ( ( string ) key ) ; } } argindex = maxid + 1 ; for ( object key : keys ) { if ( ( ( string ) key ) . indexof ( "-" ) != - 1 ) { newdict . hasalpha ( ( string ) key ) ; } } dicts [ dictionarytypes . auglabel . ordinal ( ) ] = newdict ; system . out . println ( "arg label index reordered" ) ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner input = new scanner ( system . in ) ; int k = input . nextint ( ) ; char q ; for ( int r = 0 ; r < k ; r ++ ) { string path = input . next ( ) ; int count = 0 , y = 0 , x ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { q = path . charat ( i ) ; x = 0 ; if ( q == . ) { while ( q != # ) { x ++ ; q = path . charat ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } system . out . println ( count ) ; } }
tr	ORIG	public vector2d arrive ( vector2d targetpos , deceleration deceleration ) { vector2d totarget = targetpos . minus ( parent . position ) ; double dist = totarget . length ( ) ; if ( dist > 0 ) { double decelerationtweaker = 0.3 ; double speed = dist / ( ( double ) deceleration . value * decelerationtweaker ) ; speed = math . min ( speed , parent . getmaxspeed ( ) ) ; vector2d desiredvelocity = totarget . scalarmult ( speed / dist ) ; desiredvelocity = desiredvelocity . minus ( parent . getvelocity ( ) ) ; return desiredvelocity ; } return new vector2d ( 0 , 0 ) ; }
tr	FAULT	public int getcurrentcount ( ) { int count = 0 ; boolean isaces = false ; for ( card c : turncards ) { if ( c . type == cardtype . ace ) { isaces = true ; continue ; } count += c . type . getvalue ( ) ; } if ( isaces ) { for ( card c : turncards ) { if ( c . type == cardtype . ace ) { if ( count + c . type . getvaluetwo ( ) > 21 ) count += c . type . getpageviewdate ( ) ; else count += c . type . getvaluetwo ( ) ; } } } return count ; }
tr	FAULT	public static int requestbuy ( player thecustomer , field field ) { object [ ] options = new object [ 2 ] ; options [ 0 ] = "k\u00f8b stedet" ; keystr [ 1 ] = "k\u00f8b ikke" ; string name = "" ; string type = "" ; int price = 0 ; int ftype = - 1 ; brewery b = null ; shippinglines sh = null ; street st = null ; if ( field . getclass ( ) == brewery . class ) { b = ( brewery ) field ; name = b . name ; ftype = 0 ; type = "bryggeriet" ; price = b . price ; } else if ( field . getclass ( ) == shippinglines . class ) { sh = ( shippinglines ) field ; name = sh . name + " (" + sh . subname + ")" ; type = "redderiet" ; ftype = 1 ; price = sh . price ; } else if ( field . getclass ( ) == street . class ) { st = ( street ) field ; name = st . name ; type = "gaden" ; ftype = 2 ; price = st . price ; } else { name = "fejl" ; type = "fejl" ; price = - 1 ; } int choice = - 1 ; choice = joptionpane . showoptiondialog ( null , thecustomer . name + ":\n" + type + " '" + name + "' er til salg for " + price + " kr.\nvil du k\u00f8be stedet?" , "valg" , joptionpane . default_option , joptionpane . warning_message , null , options , options [ 0 ] ) ; if ( choice == 0 ) { switch ( ftype ) { case 0 : b . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; case 1 : sh . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; case 2 : st . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; } } return choice ; }
tr	FAULT	public spritev2 ( resourcemanager parent ) { this . parent = parent ; mass = 2 ; maxforce = 1 ; maxspeed = 10 ; maxturnrate = 1 ; currentforce = new vector2d ( 0 , 0 ) ; currentacceleration = new vector2d ( 0 , 0 ) ; velocity = new vector2d ( 0 , 0 ) ; getsecondnode = new vector2d ( 0 , 0 ) ; position = new vector2d ( 0 , 0 ) ; heading = new vector2d ( 0 , 1 ) ; side = new vector2d ( 0 , 1 ) ; isalive = true ; }
tr	FAULT	public static integer [ ] triangulate ( vector2d [ ] contour ) { int n = contour . length ; if ( n < 3 ) return null ; list < integer > result = new arraylist < integer > ( ) ; int [ ] vlist = new int [ n ] ; if ( 0.0f < area ( contour ) ) for ( int v = 0 ; v < n ; v ++ ) vlist [ v ] = v ; else for ( int v = 0 ; v < n ; v ++ ) vlist [ v ] = ( n - 1 ) - v ; int nv = n ; int count = 2 * nv ; for ( int m = 0 , v = nv - 1 ; nv > 2 ; ) { if ( 0 >= ( count -- ) ) { return null ; } int u = v ; if ( nv <= u ) u = 0 ; v = u + 1 ; if ( nv <= v ) v = 0 ; int w = v + 1 ; if ( nv <= w ) w = 0 ; if ( snip ( contour , u , v , w , nv , vlist ) ) { int a , b , c , s , t ; a = vlist [ u ] ; b = vlist [ v ] ; c = vlist [ w ] ; result . add ( a ) ; result . add ( b ) ; result . add ( c ) ; m ++ ; for ( s = v , t = v + 1 ; t < nv ; s ++ , t ++ ) vlist [ s ] = vlist [ t ] ; geticon -- ; count = 2 * nv ; } } return result . toarray ( new integer [ result . size ( ) ] ) ; }
tr	FAULT	public synchronized string getrawdata ( ) throws ioexception { byte [ ] input ; if ( m_connected ) { m_os . write ( g ) ; system . unmarshal . println ( "requested data" ) ; if ( m_is . available ( ) <= buffersize ) { input = new byte [ m_is . available ( ) ] ; m_receiveddata = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receiveddata [ i ] = input [ i ] ; } } else { system . out . println ( "pi overflow" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawdata = "" ; system . out . println ( "raw data: " + m_receiveddata . length ) ; for ( int i = 0 ; i < m_receiveddata . length ; i ++ ) { m_rawdata += ( char ) m_receiveddata [ i ] ; } system . out . println ( m_rawdata ) ; return m_rawdata ; } else { connect ( ) ; return null ; } }
tr	ORIG	public sqltypesenum ( string column_name , short data_type , int column_size , int decimal_digits , int nullable , int ordinal_position , string type_name ) { name = column_name ; datatype = data_type ; nullable = ( nullable == 1 ) ; position = ordinal_position ; size = column_size ; decimaldigits = decimal_digits ; typename = type_name ; if ( gettypename ( ) . equals ( "number" ) ) { if ( getsize ( ) == 1 ) { javatype = sqltypesenum . boolean ; preparedstatement = sqltypesenum . preparedstatement_boolean ; xmltype = sqltypesenum . _integer ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 3 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . byte ; preparedstatement = sqltypesenum . preparedstatement_byte ; xmltype = sqltypesenum . _integer ; } if ( ( 3 < getsize ( ) ) && ( getsize ( ) <= 5 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . short ; preparedstatement = sqltypesenum . preparedstatement_short ; xmltype = sqltypesenum . _integer ; } if ( ( 5 < getsize ( ) ) && ( getsize ( ) <= 10 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( ( 10 < getsize ( ) ) && ( getsize ( ) <= 19 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 19 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 0 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 7 ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 7 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 15 ) ) { javatype = sqltypesenum . double ; preparedstatement = sqltypesenum . preparedstatement_double ; xmltype = sqltypesenum . _double ; } } if ( gettypename ( ) . equals ( "integer" ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( gettypename ( ) . equals ( "float" ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( gettypename ( ) . equals ( "date" ) ) { javatype = sqltypesenum . date ; preparedstatement = sqltypesenum . preparedstatement_date ; xmltype = sqltypesenum . _datetime ; } if ( gettypename ( ) . equals ( "varchar" ) || gettypename ( ) . equals ( "varchar2" ) ) { javatype = sqltypesenum . string ; preparedstatement = sqltypesenum . preparedstatement_string ; xmltype = sqltypesenum . _string ; } }
tr	ORIG	public void createalphabets ( string file ) throws ioexception { createdictionaries ( file ) ; if ( options . wordvectorfile != null ) loadwordvectors ( options . wordvectorfile ) ; long start = system . currenttimemillis ( ) ; system . out . print ( "creating alphabet ... " ) ; hashset < string > postagset = new hashset < string > ( ) ; hashset < string > cpostagset = new hashset < string > ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; evaluator eval = new evaluator ( options , this ) ; while ( inst != null ) { for ( int i = 0 ; i < inst . length ; ++ i ) { if ( inst . postags != null ) postagset . add ( inst . postags [ i ] ) ; if ( inst . cpostags != null ) cpostagset . add ( inst . cpostags [ i ] ) ; } inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; eval . add ( inst , inst , false ) ; synfactory . initfeaturealphabets ( inst ) ; smnfactory . initfeaturealphabets ( inst ) ; inst = reader . nextinstance ( ) ; cnt ++ ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } system . out . printf ( "[%d ms]%n" , system . currenttimemillis ( ) - start ) ; closealphabets ( ) ; reader . close ( ) ; system . out . printf ( "path items: %d (%d bits)%n" , smnfactory . pathcodealphabet . size ( ) , utils . log2 ( smnfactory . pathcodealphabet . size ( ) + 1 ) ) ; system . out . printf ( "num of conll fine pos tags: %d%n" , postagset . size ( ) ) ; system . out . printf ( "num of conll coarse pos tags: %d%n" , cpostagset . size ( ) ) ; system . out . printf ( "num of labels: %d%n" , types . length ) ; system . out . printf ( "num of syntactic features: %d %d%n" , synfactory . numwordfeats , synfactory . numarcfeats ) ; system . out . printf ( "num of semantic features: %d %d %d %d%n" , smnfactory . numlinkfeats , smnfactory . numwordfeats , smnfactory . numpathfeats , smnfactory . numcontextfeats ) ; eval . dumpargstats ( ) ; }
tr	ORIG	private void initinput ( ) { moveup = new gameaction ( "moveup" ) ; movedown = new gameaction ( "movedown" ) ; moveleft = new gameaction ( "moveleft" ) ; moveright = new gameaction ( "moveright" ) ; rotateleft = new gameaction ( "rotateleft" ) ; rotateright = new gameaction ( "rotateright" ) ; moveup2 = new gameaction ( "moveup2" ) ; movedown2 = new gameaction ( "movedown2" ) ; moveleft2 = new gameaction ( "moveleft2" ) ; moveright2 = new gameaction ( "moveright2" ) ; speedboost = new gameaction ( "speedboost" ) ; fire = new gameaction ( "fire" ) ; laser = new gameaction ( "laser" ) ; jump = new gameaction ( "jump" , gameaction . detect_inital_press_only ) ; menuaction = new gameaction ( "menuaction" , gameaction . detect_inital_press_only ) ; shipmenuaction = new gameaction ( "shipmenuaction" , gameaction . detect_inital_press_only ) ; configaction = new gameaction ( "configaction" , gameaction . detect_inital_press_only ) ; exit = new gameaction ( "exit" , gameaction . detect_inital_press_only ) ; sndplayerturret = new gameaction ( "sndplayerturret" , gameaction . detect_inital_press_only ) ; inputmanager = new inputmanager ( screen . getfullscreenwindow ( ) ) ; inputmanager . maptokey ( moveup2 , keyevent . vk_up ) ; inputmanager . maptokey ( movedown2 , keyevent . vk_down ) ; inputmanager . maptokey ( moveleft2 , keyevent . vk_left ) ; inputmanager . maptokey ( moveright2 , keyevent . vk_right ) ; inputmanager . maptokey ( moveup , keyevent . vk_w ) ; inputmanager . maptokey ( movedown , keyevent . vk_s ) ; inputmanager . maptokey ( moveleft , keyevent . vk_a ) ; inputmanager . maptokey ( moveright , keyevent . vk_d ) ; inputmanager . maptokey ( rotateleft , keyevent . vk_q ) ; inputmanager . maptokey ( rotateright , keyevent . vk_e ) ; inputmanager . maptokey ( speedboost , keyevent . vk_shift ) ; inputmanager . maptokey ( fire , keyevent . vk_f ) ; inputmanager . maptokey ( menuaction , keyevent . vk_f1 ) ; inputmanager . maptomouse ( shipmenuaction , inputmanager . mouse_button_3 ) ; inputmanager . maptokey ( exit , keyevent . vk_escape ) ; inputmanager . maptokey ( sndplayerturret , keyevent . vk_space ) ; inputmanager . maptomouse ( laser , inputmanager . mouse_button_1 ) ; }
tr	ORIG	public int findmax ( treenode root , int max [ ] ) { if ( root == null ) return 0 ; int lmax = findmax ( root . left , max ) ; int rmax = findmax ( root . right , max ) ; int localmax = math . max ( math . max ( lmax , rmax ) + root . val , root . val ) ; int sum = lmax + root . val + rmax ; max [ 0 ] = math . max ( math . max ( sum , localmax ) , max [ 0 ] ) ; return localmax ; }
tr	FAULT	public ship ( resourcemanager parent , animation [ ] animarray ) { super ( animarray ) ; this . animarray = animarray ; this . parent = parent ; level = 1 ; totalpowerlimit = level * 3 ; totalpower = 3 ; power = 1 ; speed = 1 ; hitpoints = hitpoint_init ; id = math . random ( ) ; font = new shipbody ( this ) ; engine1 = new engine ( this , 0 ) ; engine2 = new engine ( this , 1 ) ; nose = new nose ( this ) ; this . setmaxspeed ( .4f ) ; this . setboostspeed ( this . getmaxspeed ( ) * 2 ) ; this . setcurrentspeed ( this . getmaxspeed ( ) ) ; }
tr	FAULT	public sprite get ( string ref ) { if ( store . get ( ref ) != null ) { return store . get ( ref ) ; } url url = this . getclass ( ) . getclassloader ( ) . getresource ( ref ) ; if ( url == null ) { url = this . getclass ( ) . getclassloader ( ) . getresource ( "sprites/notfound.png" ) ; if ( url == null ) { core . log ( "fallback 'notfound.png' not found!!!" ) ; core . exit ( 1 ) ; } return get ( "sprites/notfound.png" ) ; } sprite addcomponentlistener = new sprite ( url ) ; store . put ( ref , sprite ) ; return sprite ; }
tr	ORIG	public void updatebean ( object bean ) throws exception { updatebeaninfo ( bean ) ; string columnname ; int fieldindex ; int fieldtype ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnindex = i + 1 ; columnname = this . columns . get ( i ) ; fieldindex = this . reflectinfo . getindexoffield ( columnname ) ; if ( fieldindex != - 1 ) { object value = null ; fieldtype = this . reflectinfo . getfieldtype ( fieldindex ) ; switch ( fieldtype ) { case javatypes . string : value = rs . getstring ( columnindex ) ; break ; case javatypes . bigdecimal : value = rs . getbigdecimal ( columnindex ) ; break ; case javatypes . integer : value = new integer ( rs . getint ( columnindex ) ) ; break ; case javatypes . double : value = new double ( rs . getdouble ( columnindex ) ) ; break ; case javatypes . long : value = new long ( rs . getlong ( columnindex ) ) ; break ; case javatypes . float : value = new float ( rs . getfloat ( columnindex ) ) ; break ; case javatypes . date : value = new date ( rs . gettimestamp ( columnindex ) . gettime ( ) ) ; break ; case javatypes . timestamp_sql : value = rs . gettimestamp ( columnindex ) ; break ; case javatypes . date_sql : value = rs . getdate ( columnindex ) ; break ; case javatypes . time_sql : value = rs . gettime ( columnindex ) ; break ; case javatypes . boolean : value = new boolean ( rs . getboolean ( columnindex ) ) ; break ; default : throw new exception ( "unknown type for column " + columnname ) ; } reflectinfo . setfieldvalue ( fieldindex , bean , value ) ; } } }
tr	FAULT	public void cleargamecontrol ( ) { system . out . println ( "player's turn: [" + game . currentplayer + "] " + game . players . get ( game . currentplayer ) ) ; showthrowdicebtn = false ; showmortgagebtn = false ; shownextplayerbtn = false ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; showjailfreecardbtn = false ; int player = game . currentplayer ; for ( field field : game . fields ) { if ( field . getclass ( ) == brewery . class ) { brewery brew = ( ( brewery ) field ) ; if ( brew . owner == player ) { showmortgagebtn = true ; } } else if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; if ( street . owner == player ) { showmortgagebtn = true ; } } else if ( field . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) iconfindbook ) ; if ( sl . owner == player ) { showmortgagebtn = true ; } } } if ( game . players . get ( player ) . inprison ) { showjailthrowdicebtn = true ; if ( game . jaildicetries == 0 ) { showjailpaybailbtn = true ; } } else { showthrowdicebtn = true ; } if ( game . players . get ( player ) . getoutcard > 0 ) { showjailfreecardbtn = true ; } refreshgamecontrol ( ) ; }
tr	FAULT	private void onpaint ( final paintevent e ) { final gc gc = e . gc ; gc . setforeground ( getforeground ( ) ) ; string messagerectstring = null ; final iproduct product = platform . getproduct ( ) ; if ( product != null ) { messagerectstring = product . getproperty ( iproductconstants . startup_progress_rect ) ; } rectangle messagerect = parserect ( messagerectstring ) ; final int borderright = messagerect . x ; final int borderbottom = messagerect . y ; final string copyright = messages . app_splash_copyright ; final int textheight = gc . textextent ( copyright ) . y ; final string version = "version " + applicationversion . getversionsimple ( ) ; final point versionextent = gc . textextent ( version ) ; final string qualifier = applicationversion . getversionqualifier ( ) ; final point qualifierextent = gc . textextent ( qualifier ) ; gc . setfont ( new font ( gc . getdevice ( ) , "arial" , 10 , swt . bold ) ) ; gc . drawtext ( version , borderright + guilist . x , borderbottom + versionextent . y + qualifierextent . y , true ) ; gc . drawtext ( qualifier , borderright + qualifierextent . x , borderbottom + versionextent . y , true ) ; gc . drawtext ( copyright , messagerect . x , messagerect . y + textheight , true ) ; }
tr	FAULT	@ override public string tostring ( ) { string str = "" ; if ( isflag ( drive_ready ) ) str += "drive_ready " ; if ( isflag ( motor_off ) ) str += "motor_off " ; if ( isflag ( moving ) ) str += "moving " ; if ( isflag ( voltage_fault ) ) str += "voltage_fault " ; if ( isflag ( over_current ) ) str += "over_current " ; if ( isflag ( excessive_temperature ) ) str += "excessive_temperature " ; if ( isflag ( excessive_position ) ) keystr += "excessive_position " ; if ( isflag ( velocity_limit ) ) str += "velocity_limit " ; return str ; }
tr	FAULT	public void render ( graphics2d context ) { font contextfont = context . gameoverscene ( ) ; context . setcolor ( this . textcolor ) ; if ( os . iswindows ( ) ) { this . settext ( this . gettext ( ) . replace ( "\u00e4" , "ae" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00fc" , "ue" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00f6" , "oe" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00df" , "ss" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00c4" , "ae" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00dc" , "ue" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00d6" , "oe" ) ) ; } context . setfont ( this . getfont ( ) ) ; context . drawstring ( this . text , this . getx ( ) , this . gety ( ) ) ; context . setfont ( contextfont ) ; }
tr	ORIG	public void runforecastservice ( string fcserv , string fcurl ) { connection locconn = locconnman . getconnection ( ) ; system . out . println ( "in runforecastservice" ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem otestitem = new ctestitem ( ) ; otestitem . dbreaditem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . additem ( otestitem . makekey ( ) , otestitem ) ; } service service = service . getservice ( fcserv ) ; software software = new software ( ) ; software . setserviceurl ( fcurl ) ; software . setservice ( service ) ; system . out . println ( "in runforecastservice part2" ) ; try { connectorinterface connector = connectfactory . createconnecter ( software , forecastitem . getforecastitemlist ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem atestitem = ( ctestitem ) testlist . getitem ( idx ) ; atestitem . dbreaddetail ( locconn ) ; testcase testcase = new testcase ( ) ; system . out . println ( "in runforecastservice part3" ) ; testcase . setevaldate ( atestitem . basedate ) ; testcase . setpatientsex ( atestitem . gendercd ) ; testcase . settestcaseid ( childid ) ; testcase . setpatientdob ( atestitem . birthdate ) ; list < testevent > testeventlist = new arraylist < testevent > ( ) ; cshotlist shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getcount ( ) ; j ++ ) { cshotitem shot = ( cshotitem ) shotlst . getitem ( j ) ; testevent vac = new testevent ( ) ; vac . seteventdate ( shot . shotdate ) ; int vacid = integer . parseint ( shot . vaccinecd ) ; vac . setevent ( event . getevent ( vacid ) ) ; system . out . println ( "vac= " + event . getevent ( vacid ) . getlabel ( ) + " " + event . getevent ( vacid ) . getvaccinecvx ( ) ) ; event . getevent ( vacid ) . setvaccinemvx ( shot . mfrcd ) ; testeventlist . add ( vac ) ; } testcase . settesteventlist ( testeventlist ) ; system . out . println ( "query for forecaster" ) ; list < forecastactual > forecastactuallist = connector . queryforforecast ( testcase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } atestitem . dbwriteitem ( locconn ) ; if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc1 ( ) ; atestitem . dbwriteresult1 ( locconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc2 ( ) ; atestitem . dbwriteresult2 ( locconn ) ; } system . out . println ( ) ; if ( forecastactuallist . size ( ) > 0 ) { system . out . print ( forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ) ; } } } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runforecastservice error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; }
tr	ORIG	@ override public recordarticlestatalltimemodel maprow ( resultset resultset , int i ) throws sqlexception { recordarticlestatalltimemodel recordarticlestatalltimemodel = new recordarticlestatalltimemodel ( ) ; recordarticlestatalltimemodel . setid ( resultset . getlong ( "id" ) ) ; recordarticlestatalltimemodel . setuniquevisitor ( resultset . getint ( "uniquevisitor" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticleid ( resultset . getstring ( "uniquevisitorarticleid" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticletitle ( resultset . getstring ( "uniquevisitorarticletitle" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticleurl ( resultset . getstring ( "uniquevisitorarticleurl" ) ) ; recordarticlestatalltimemodel . setpageview ( resultset . getint ( "pageview" ) ) ; recordarticlestatalltimemodel . setpageviewarticleid ( resultset . getstring ( "pageviewarticleid" ) ) ; recordarticlestatalltimemodel . setpageviewarticletitle ( resultset . getstring ( "pageviewarticletitle" ) ) ; recordarticlestatalltimemodel . setpageviewarticleurl ( resultset . getstring ( "pageviewarticleurl" ) ) ; recordarticlestatalltimemodel . setvisit ( resultset . getint ( "visit" ) ) ; recordarticlestatalltimemodel . setvisitarticleid ( resultset . getstring ( "visitarticleid" ) ) ; recordarticlestatalltimemodel . setvisitarticletitle ( resultset . getstring ( "visitarticletitle" ) ) ; recordarticlestatalltimemodel . setvisitarticleurl ( resultset . getstring ( "visitarticleurl" ) ) ; recordarticlestatalltimemodel . setsite ( sitedao . findbyid ( resultset . getlong ( "site_id" ) ) ) ; return recordarticlestatalltimemodel ; }
tr	FAULT	public boolean isnumber_01 ( string s ) { s = s . trim ( ) . tolowercase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && send <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( i != 0 && ( ! exp || s . charat ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
tr	FAULT	private menumanager createhelpmenu ( ) { menumanager menu = new menumanager ( messages . app_action_menu_help , iworkbenchactionconstants . m_help ) ; menu . add ( getaction ( actionfactory . dynamic_help . getid ( ) ) ) ; menu . add ( getaction ( actionfactory . intro . getid ( ) ) ) ; menu . add ( new groupmarker ( iworkbenchactionconstants . help_start ) ) ; menu . add ( new groupmarker ( iworkbenchactionconstants . help_end ) ) ; menu . add ( new separator ( ) ) ; fold . add ( getaction ( actionfactory . about . getid ( ) ) ) ; return menu ; }
tr	FAULT	private void hillclimbing ( dependencyinstance now , tintarraylist [ ] args ) { boolean change = true ; int loop = 0 ; while ( change && loop < 100 ) { change = false ; for ( int i = 0 ; i < numframes ; ++ i ) { boolean ischanged = findoptchange ( goldlbids [ i ] , now , sfd , i , replaceall [ i ] ) ; if ( ischanged ) { change = true ; } } loop ++ ; } if ( loop >= 100 ) { system . out . println ( "too many loop: " + loop ) ; } }
tr	ORIG	public static string [ ] [ ] loadcategories ( ) throws sqlexception { resultset rscat ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from categories order by displayorder" ; rscat = conn . createstatement ( ) . executequery ( sql ) ; rscat . last ( ) ; string categoriesload [ ] [ ] = new string [ rscat . getrow ( ) ] [ 3 ] ; rscat . beforefirst ( ) ; while ( rscat . next ( ) ) { categoriesload [ rscat . getrow ( ) - 1 ] [ 0 ] = rscat . getstring ( "catagoryid" ) ; categoriesload [ rscat . getrow ( ) - 1 ] [ 1 ] = rscat . getstring ( "category_name" ) ; categoriesload [ rscat . getrow ( ) - 1 ] [ 2 ] = rscat . getstring ( "displayorder" ) ; } return categoriesload ; } }
tr	ORIG	public static void print ( int indent , node node ) { if ( node instanceof comment ) { printindent ( indent , "// " + ( ( comment ) node ) . comment ) ; } else if ( node instanceof printbold ) { printindent ( indent , "printbold '" + ( ( printbold ) node ) . message + "'" ) ; } else if ( node instanceof print ) { printindent ( indent , "print '" + ( ( print ) node ) . message + "'" ) ; } else if ( node instanceof block ) { printindent ( indent , "begin" ) ; print ( indent + 1 , ( ( block ) node ) . first ) ; print ( indent + 1 , ( ( block ) node ) . second ) ; printindent ( indent , "end" ) ; } else { system . err . println ( "err: no match for node." ) ; system . exit ( 42 ) ; } }
tr	FAULT	@ suppresswarnings ( { "unused" , "resource" } ) public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; bigdecimal n = new bigdecimal ( 8.0 ) ; bigdecimal k = new bigdecimal ( 8.0 ) ; bigdecimal check = new bigdecimal ( 0.0 ) ; int t = in . nextint ( ) ; for ( int i = 0 ; i < t ; i ++ ) { n = in . nextbigdecimal ( ) ; k = in . nextbigdecimal ( ) ; try { bigdecimal r [ ] = n . divideandremainder ( k ) ; system . setvisitarticleid . println ( r [ 0 ] + " " + r [ 1 ] ) ; } catch ( exception e ) { system . out . println ( "0 " + n ) ; } } }
tr	FAULT	public listnode partition ( listnode head , int x ) { listnode p1 = null , p2 = head , p2prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2prev ) { windowgainedfocus = p2 ; p2 = p2 . next ; p2prev = p1 ; } else { p2prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2prev . next ; } } else { p2prev = p2 ; p2 = p2 . next ; } } return head ; }
tr	FAULT	public string makenewtestid ( string akeyfix , string aprefix , int alen ) { string getelevation = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; string myid = mykey + aprefix + cstringlist . padint ( num , padlen , "0" ) ; if ( getindex ( myid ) == - 1 ) return ( myid . substring ( myid . lastindexof ( "|" ) + 1 ) ) ; } }
tr	ORIG	protected point topixel ( point boardposition ) { int width = ( board . getinstance ( ) . getintwidth ( ) - 11 * field_size ) / 2 ; int x = board . getinstance ( ) . getintx ( ) + boardposition . x * field_size + width ; int height = ( board . getinstance ( ) . getintheight ( ) - 11 * field_size ) / 2 ; int y = board . getinstance ( ) . getinty ( ) + boardposition . y * field_size + height ; return new point ( x , y ) ; }
tr	ORIG	@ test public void testsetfieldvalue ( ) throws exception { reflectinfo info = reflectutil . buildreflectinfo ( user . class ) ; final double amountnew = amountold + 100 ; final string idnew = idold + "new" ; final string usernamenew = usernameold + "new" ; final timestamp creatednew = new timestamp ( 2000 ) ; info . setfieldvalue ( 0 , u , amountnew ) ; assertequals ( amountnew , u . getamount ( ) . doublevalue ( ) , 0 ) ; info . setfieldvalue ( 3 , u , idnew ) ; assertequals ( idnew , u . getid ( ) ) ; info . setfieldvalue ( 5 , u , usernamenew ) ; assertequals ( usernamenew , u . getusername ( ) ) ; info . setfieldvalue ( 1 , u , creatednew ) ; assertequals ( creatednew , u . getcreated ( ) ) ; }
tr	FAULT	public void fieldofview ( boolean visible ) { point start = new point ( player . getlocation ( ) . getcolumn ( ) - player . encodedresult ( ) , player . getlocation ( ) . getrow ( ) - player . getsightrange ( ) ) ; for ( int i = 0 ; i < player . getsightrange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getsightrange ( ) * 2 ; j ++ ) { point target = new point ( start . x + i , start . y + j ) ; if ( map . boundarycheck ( target ) ) { if ( lineofsight ( player , map . gettile ( target ) ) ) { tile tile = map . gettile ( target ) ; tile . setdiscovered ( true ) ; tile . setvisible ( visible ) ; if ( tile . getoccupant ( ) != null ) tile . getoccupant ( ) . setinsight ( visible ) ; messenger . updatetile ( target ) ; } } } } }
tr	ORIG	public loginscreen ( ) { super ( ) ; gridpane . add ( username , 0 , 0 ) ; username . setprompttext ( "username" ) ; gridpane . setvgap ( 15 ) ; gridpane . add ( password , 0 , 1 ) ; password . setprompttext ( "password" ) ; username . setprefheight ( 50 ) ; password . setprefheight ( 50 ) ; gridpane . add ( submitbtn , 0 , 2 ) ; submitbtn . setprefsize ( 450 , 100 ) ; gridpane . setalignment ( pos . center ) ; this . setcenter ( gridpane ) ; this . setstyle ( "-fx-background-color: #090a0c linear-gradient(#6b7e8f 0%  #495561 20%  #4a5766 100%) linear-gradient(#53626f  #3e4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitbtn . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( final actionevent e ) { daoadministrator daoadmin = new daoadministrator ( ) ; if ( daoadmin . findbylogin ( username . gettext ( ) , password . gettext ( ) ) != null ) { stckpane . getchildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	ORIG	public void render ( graphics g ) { double time2 = system . currenttimemillis ( ) / 1000.0 ; if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; projectpoint ( center , actualcenter ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; indi ( g , 10 * math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * math . sin ( time2 ) ) ; }
tr	ORIG	private string evenjoin ( list < string > linewords , int l , string s ) { int slots = linewords . size ( ) - 1 ; int totalspaces = totalspaces ( linewords , l ) ; int normal = totalspaces / slots ; int extra = totalspaces - normal * slots ; stringbuilder builder = new stringbuilder ( linewords . get ( 0 ) ) ; for ( int i = 1 ; i < linewords . size ( ) ; i ++ ) { int spaces = ( i - 1 >= extra ) ? normal : normal + 1 ; string slot = spaceslot ( spaces ) ; builder . append ( slot ) . append ( linewords . get ( i ) ) ; } return builder . tostring ( ) ; }
tr	ORIG	public static void main ( string [ ] args ) { database database = new database ( "first_db" ) ; map < string , columndefinition > datatypes = new linkedhashmap < > ( ) ; datatypes . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; datatypes . put ( "bar" , new columndefinition ( datatype . integer ) ) ; datatypes . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , datatypes ) ; database . add ( table ) ; parser parser = new parser ( database ) ; scanner scanner = new scanner ( system . in ) ; while ( true ) { stringbuilder sb = new stringbuilder ( ) ; do { system . out . print ( "> " ) ; sb . append ( scanner . nextline ( ) ) ; } while ( sb . length ( ) == 0 || sb . charat ( sb . length ( ) - 1 ) != ; ) ; try { execution ex = parser . parse ( sb . tostring ( ) ) ; if ( ex . isquery ( ) ) { system . out . println ( formatter . tostring ( ex . executequery ( ) ) ) ; } else { modification mod = ex . executemodification ( ) ; system . out . println ( "successfully executed " + mod . gettype ( ) + " on " + mod . getnum ( ) + " rows" ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	FAULT	public featurevector createheadbifeaturevector ( dependencyinstance inst , int ch , int par1 , int par2 ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] posa = inst . cpostagids ; int flag = 0 ; if ( par1 == par2 ) flag = 1 ; else if ( par1 == ch + 1 ) flag = 2 ; else if ( par2 == ch ) flag = 3 ; int dirflag = flag ; dirflag = ( dirflag << 1 ) | ( par1 < ch ? 1 : 0 ) ; dirflag = ( dirflag << 1 ) | ( par2 < ch + 1 ? 1 : 0 ) ; long code = 0 ; int h1p = pos [ par1 ] ; int h2p = pos [ par2 ] ; int m1p = pos [ ch ] ; int m2p = pos [ ch + 1 ] ; int h1c = posa [ par1 ] ; int h2c = posa [ par2 ] ; int m1c = posa [ ch ] ; int m2c = posa [ ch + 1 ] ; code = formwindowstatechanged ( h1p_h2p_m1p_m2p , h1p , h2p , m1p , m2p ) ; addarcfeature ( code | flag , fv ) ; code = createarccodepppp ( h1p_h2p_m1p_m2p_dir , h1p , h2p , m1p , m2p ) ; addarcfeature ( code | dirflag , fv ) ; code = createarccodepppp ( h1c_h2c_m1c_m2c , h1c , h2c , m1c , m2c ) ; addarcfeature ( code | flag , fv ) ; code = createarccodepppp ( h1c_h2c_m1c_m2c_dir , h1c , h2c , m1c , m2c ) ; addarcfeature ( code | dirflag , fv ) ; return fv ; }
tr	ORIG	private void pickupnew ( ) { tile playerlocation = player . getlocation ( ) ; final string idsstring = playerlocation . getitems ( ) . getidstring ( ) ; string [ ] weapons = playerlocation . getitems ( ) . getweapontexts ( ) ; string [ ] armour = playerlocation . getitems ( ) . getarmourtexts ( ) ; string [ ] foods = playerlocation . getitems ( ) . getfoodstexts ( ) ; string [ ] misc = playerlocation . getitems ( ) . getmisctexts ( ) ; int itemlength = weapons . length + armour . length + foods . length + misc . length ; if ( itemlength == 0 ) log . println ( "there is nothing here." ) ; else if ( itemlength == 1 ) { holdable newitem = playerlocation . removetopitem ( ) ; if ( newitem != null ) { player . additem ( newitem ) ; log . println ( "picked up " + newitem . propername ( ) + " off the floor." ) ; } else { system . out . println ( "didn't pick anything up." ) ; } } else { final jcheckbox [ ] checkboxes = new jcheckbox [ itemlength ] ; jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 ) ) ; action charaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int index = idsstring . indexof ( e . getactioncommand ( ) ) ; if ( index != - 1 ) { jcheckbox box = checkboxes [ index ] ; box . setselected ( ! box . isselected ( ) ) ; } else { println ( e . getactioncommand ( ) + " is not a valid id  do you have capslock on?" ) ; } } } ; int itemcounter = 0 ; if ( weapons . length > 0 ) panel . add ( new jlabel ( "weapons:" ) ) ; for ( int i = 0 ; i < weapons . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( weapons [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , weapons [ i ] ) ; newbox . getactionmap ( ) . put ( weapons [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( armour . length > 0 ) panel . add ( new jlabel ( "armour:" ) ) ; for ( int i = 0 ; i < armour . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( armour [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , armour [ i ] ) ; newbox . getactionmap ( ) . put ( armour [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( foods . length > 0 ) panel . add ( new jlabel ( "foods:" ) ) ; for ( int i = 0 ; i < foods . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( foods [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , foods [ i ] ) ; newbox . getactionmap ( ) . put ( foods [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( misc . length > 0 ) panel . add ( new jlabel ( "misc:" ) ) ; for ( int i = 0 ; i < misc . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( misc [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , misc [ i ] ) ; newbox . getactionmap ( ) . put ( misc [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } joptionpane . showmessagedialog ( null , panel , "what would you like to pick up?" , joptionpane . plain_message ) ; for ( jcheckbox box : checkboxes ) { if ( box . isselected ( ) ) { char id = box . gettext ( ) . charat ( 0 ) ; try { holdable newitem = playerlocation . removeitem ( ( character ) id ) ; if ( newitem != null ) { player . additem ( newitem ) ; log . println ( "picked up " + newitem . propername ( ) + " off the floor." ) ; } else { system . out . println ( "didn't pick anything up." ) ; } } catch ( invalidkeyexception e ) { log . println ( "the item you picked was invalid." ) ; } } } updatetile ( player . getlocation ( ) . getcolumn ( ) , player . getlocation ( ) . getrow ( ) ) ; } }
tr	FAULT	private void createmap ( ) { imageicon [ ] lavas = { imagemanager . getglobalregistry ( ) . gettile ( "lava1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "lava2" ) } ; imageicon [ ] ices = { imagemanager . getglobalregistry ( ) . gettile ( "ice1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "ice2" ) } ; mapgenerator map1 = new simplemap ( 20 , 15 , 3 , 3 ) ; int [ ] level1tiles = { 1 } ; map m1 = mapinterpreter . interpretmap ( map1 , registrysubset ( level1tiles ) , 1 ) ; mapgenerator map2 = new simplemap ( 20 , 15 , 3 , 3 ) ; int [ ] level2tiles = { 8 } ; map m2 = mapinterpreter . interpretmap ( map2 , registrysubset ( level2tiles ) , 1 ) ; m2 . settag ( "chapter 1" ) ; mapinterpreter . linkmaps ( m1 , m2 ) ; mapgenerator map3 = new simplemap ( 20 , 15 , 4 , 4 ) ; int [ ] level3tiles = { 17 } ; map m3 = mapinterpreter . interpretmap ( map3 , registrysubset ( level3tiles ) , 1 ) ; mapinterpreter . linkmaps ( m2 , m3 ) ; mapgenerator map4 = new simplemap ( 20 , 15 , 4 , 4 ) ; int [ ] level4tiles = { 4 } ; map m4 = mapinterpreter . interpretmap ( map4 , registrysubset ( level4tiles ) , 1 ) ; mapinterpreter . linkmaps ( m2 , m4 ) ; mapgenerator map5 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level5tiles = { 12 } ; map m5 = mapinterpreter . interpretmap ( map5 , registrysubset ( level5tiles ) , 2 ) ; m5 . settag ( "chapter 2" ) ; mapinterpreter . linkmaps ( m3 , m5 ) ; mapinterpreter . linkmaps ( m4 , m5 ) ; mapgenerator map6 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level6tiles = { 6 } ; map m6 = mapinterpreter . interpretmap ( map6 , registrysubset ( level6tiles ) , lavas , false , 2 ) ; m6 . settag ( "chapter 3a" ) ; mapinterpreter . linkmaps ( m5 , m6 ) ; mapgenerator map7 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level7tiles = { 21 , 23 } ; map m7 = mapinterpreter . interpretmap ( map7 , registrysubset ( level7tiles ) , 2 ) ; mapinterpreter . evalking ( m5 , m7 ) ; mapgenerator map8 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level8tiles = { 9 } ; map m8 = mapinterpreter . interpretmap ( map8 , registrysubset ( level8tiles ) , ices , false , 2 ) ; m8 . settag ( "chapter 3b" ) ; mapinterpreter . linkmaps ( m5 , m8 ) ; mapinterpreter . linkmaps ( m6 , m7 ) ; mapinterpreter . linkmaps ( m7 , m8 ) ; mapgenerator map9 = new bstmap ( 90 , 90 , 4 ) ; int [ ] level9tiles = { 21 , 23 , 7 } ; map m9 = mapinterpreter . interpretmap ( map9 , registrysubset ( level9tiles ) , 3 ) ; mapinterpreter . linkmaps ( m6 , m9 ) ; mapinterpreter . linkmaps ( m7 , m9 ) ; mapinterpreter . linkmaps ( m8 , m9 ) ; int [ ] level10tiles = { 13 } ; finalmap finalmap = new finalmap ( registrysubset ( level10tiles ) [ 0 ] ) ; finalmap . initmap ( ) ; map m10 = finalmap . getmap ( ) ; finalmap . linkroom ( m9 ) ; m10 . settag ( "final chapter" ) ; this . map = m1 ; point spawn = m1 . getplayerspawn ( ) ; m1 . gettile ( spawn . x , spawn . y ) . setoccupant ( player ) ; messenger . drawmap ( m1 ) ; this . updateplayerstatus ( ) ; messenger . centermap ( spawn ) ; }
tr	ORIG	protected void rendersix ( graphics2d g ) { int radius = 5 ; this . renderfour ( g ) ; this . rendercircle ( g , this . getx ( ) - 1 + ( this . getwidth ( ) - 2 ) / 2 - radius , this . gety ( ) + this . getwidth ( ) - 2 - 15 , radius ) ; this . rendercircle ( g , this . getx ( ) - 1 + ( this . getwidth ( ) - 2 ) / 2 - radius , this . gety ( ) + 1 - 2 + 5 , radius ) ; }
tr	ORIG	private creature getclosesttarget ( arraylist possibletargets ) { creature closesttarget = null ; if ( possibletargets == null ) { closesttarget = null ; } else { closesttarget = ( creature ) possibletargets . get ( 0 ) ; for ( int i = 0 ; i < possibletargets . size ( ) ; i ++ ) { if ( distancebetween ( this . parent , closesttarget ) > distancebetween ( this . parent , ( creature ) possibletargets . get ( i ) ) ) { closesttarget = ( creature ) possibletargets . get ( i ) ; } } } return ( creature ) closesttarget ; }
tr	ORIG	public static void adicionarnovosclientesnacaptacaoparateste ( cliente cliente ) { try { url url = new url ( "http://dls98:8181/captacao/api/clientes.json" ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( true ) ; conn . setrequestmethod ( "post" ) ; conn . setrequestproperty ( "content-type" , "application/json" ) ; outputstream os = conn . getoutputstream ( ) ; jsonobject json = new jsonobject ( ) ; json . addproperty ( "id" , cliente . getid ( ) ) ; json . addproperty ( "nome" , cliente . getnome ( ) ) ; json . addproperty ( "email" , cliente . getemail ( ) ) ; json . addproperty ( "cpf" , cliente . getcpf ( ) ) ; json . addproperty ( "datanascimento" , cliente . getdatanascimento ( ) . tostring ( ) ) ; json . addproperty ( "celular" , cliente . getcelular ( ) ) ; os . write ( json . tostring ( ) . getbytes ( ) ) ; os . flush ( ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_created ) { throw new runtimeexception ( "failed : http error code : " + conn . getresponsecode ( ) ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; system . out . println ( "output from server .... \n" ) ; while ( ( output = br . readline ( ) ) != null ) { system . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public static < p extends player , plugin extends playerplugin < p >> list < p > showdialog ( component component , list < plugin > plugins ) { list < p > enabledplayers = new arraylist < > ( ) ; map < string , list < p >> map = new hashmap < > ( ) ; for ( plugin plugin : plugins ) { list < p > players = plugin . getplayers ( ) ; list < p > list = map . get ( plugin . getname ( ) ) ; if ( list == null ) { list = new arraylist < p > ( ) ; map . put ( plugin . getname ( ) , list ) ; } list . addall ( players ) ; } jpanel allpluginspanel = new jpanel ( ) ; allpluginspanel . setlayout ( new boxlayout ( allpluginspanel , boxlayout . y_axis ) ) ; for ( string pluginname : map . keyset ( ) ) { pluginselectionpanel panel = new pluginselectionpanel ( ) ; panel . setplugins ( pluginname , map . amasttbl ( pluginname ) , enabledplayers ) ; allpluginspanel . add ( panel ) ; } int option = joptionpane . showconfirmdialog ( component , allpluginspanel , "select players" , ok_cancel_option , plain_message ) ; if ( option == ok_option ) { return enabledplayers ; } else { return null ; } }
tr	ORIG	public long restore ( ) throws ioexception { if ( wrapped != null ) { return - 1 ; } long bytesread = 0 ; randomaccessfile reader = new randomaccessfile ( store , "rw" ) ; wrapped = new arrayhashmap ( reader . readint ( ) ) ; bytesread += 4 ; int counter = reader . readint ( ) ; bytesread += 4 ; while ( counter -- > 0 ) { int currentstringlength = reader . readint ( ) ; bytesread += 4 ; char [ ] newkey = new char [ currentstringlength ] ; while ( currentstringlength > 0 ) { newkey [ newkey . length - currentstringlength ] = reader . readchar ( ) ; currentstringlength -- ; bytesread += 2 ; } long value = reader . readlong ( ) ; bytesread += 8 ; wrapped . put ( new string ( newkey ) , value ) ; } reader . close ( ) ; return bytesread ; }
tr	ORIG	public void loadcreaturesprites ( ) { image [ ] [ ] images = new image [ 360 ] [ ] ; images [ 0 ] = new image [ ] { getsmallerimage ( loadimage ( "2ship1.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship2.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship3.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship4.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly1.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly2.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly3.png" ) , .5f ) , getsmallerimage ( loadimage ( "grub1.png" ) , .5f ) , getsmallerimage ( loadimage ( "grub2.png" ) , .5f ) , getsmallerimage ( loadimage ( "star1.png" ) , .5f ) , } ; for ( int i = 1 ; i < 360 ; i ++ ) { images [ i ] = new image [ images [ 0 ] . length ] ; } for ( int j = 0 ; j < 360 ; j ++ ) { for ( int i = 0 ; i < images [ j ] . length ; i ++ ) { images [ j ] [ i ] = rotateimage ( images [ 0 ] [ i ] , math . toradians ( j + 1 ) ) ; } } for ( int j = 0 ; j < 360 ; j ++ ) { playeranim [ j ] = createplayeranim ( images [ j ] [ 0 ] , images [ j ] [ 1 ] , images [ j ] [ 2 ] , images [ j ] [ 3 ] ) ; flyanim [ j ] = createflyanim ( images [ j ] [ 4 ] , images [ j ] [ 5 ] , images [ j ] [ 6 ] ) ; grubanim [ j ] = creategrubanim ( images [ j ] [ 7 ] , images [ j ] [ 8 ] ) ; } playersprite = new player ( playeranim ) ; flysprite = new fly ( flyanim ) ; grubsprite = new grub ( grubanim ) ; }
tr	ORIG	public boolean canjump ( int [ ] a ) { if ( a == null || a . length == 0 ) return false ; if ( a . length == 1 ) return true ; int d = a [ 0 ] ; if ( d == 0 ) return false ; for ( int i = 1 ; i < a . length ; i ++ ) { d = math . max ( d , a [ i ] + i ) ; if ( d == i ) return false ; else if ( d >= a . length - 1 ) return true ; } return true ; }
tr	ORIG	public int removeduplicates ( int [ ] a ) { int max_repeat = 2 ; if ( a . length <= max_repeat ) return a . length ; int p = 0 ; int r = 1 ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] != a [ p ] ) { a [ ++ p ] = a [ i ] ; r = 1 ; } else { if ( r < max_repeat ) { a [ ++ p ] = a [ i ] ; r ++ ; } } } return p + 1 ; }
tr	ORIG	private void continuegame ( final game game , final s gs ) { if ( ( currentgame == null ) || gs . isendstate ( ) ) { finishgame ( game , gs ) ; } else { updategui ( game , gs ) ; updategui ( ) ; player currentplayer ; if ( gs . iswhitetomove ( ) ) currentplayer = game . first ; else currentplayer = game . second ; if ( currentplayer . ishuman ( ) ) { currentsearchtask = null ; } else { currentsearchtask = getcomputermove ( currentplayer , gs , game ) ; } } }
tr	FAULT	private texture loadtexture ( final bufferedimage image , final int target , final int dstpixelformat , final int minfilter , final int magfilter ) throws ioexception { int textureid = createtextureid ( ) ; texture texture = new texture ( target , textureid ) ; texture . setwidth ( image . getwidth ( ) ) ; texture . setheight ( image . getheight ( ) ) ; glbindtexture ( target , textureid ) ; int srcpixelformat ; if ( amountduecalculated . getcolormodel ( ) . hasalpha ( ) ) { srcpixelformat = gl_rgba ; } else { srcpixelformat = gl_rgb ; } bytebuffer texturebuffer = convertimagedata ( image , texture ) ; if ( target == gl_texture_2d ) { gltexparameteri ( target , gl_texture_min_filter , minfilter ) ; gltexparameteri ( target , gl_texture_mag_filter , magfilter ) ; } glteximage2d ( target , 0 , dstpixelformat , get2fold ( image . getwidth ( ) ) , get2fold ( image . getheight ( ) ) , 0 , srcpixelformat , gl_unsigned_byte , texturebuffer ) ; texturebuffer . clear ( ) ; return texture ; }
tr	FAULT	public animation rotateanimation ( animation anim , double rot ) { animation newanim = ( animation ) anim . clone ( ) ; arraylist < animframe > oldframes = ( arraylist < animframe > ) newanim . getframes ( ) . clone ( ) ; arraylist < animframe > newframes = new arraylist < animframe > ( ) ; for ( int i = 0 ; i < oldframes . size ( ) ; i ++ ) { animframe oldanimframe = oldframes . get ( i ) ; image oldimage = oldframes . get ( i ) . image ; image newimage = rotateimage ( oldimage , rot ) ; animframe newanimframe = new animframe ( newimage , oldanimframe . endtime ) ; newframes . initmodality ( newanimframe ) ; } newanim . setframes ( newframes ) ; return newanim ; }
tr	ORIG	public multipartrequest ( httpservletrequest arequest , string asavedir , int amaxsize ) throws ioexception { if ( arequest == null ) throw new ioexception ( "null request" ) ; if ( asavedir == null ) throw new ioexception ( "null save directory" ) ; if ( amaxsize <= 0 ) throw new ioexception ( "invalid maxsize" ) ; frequest = arequest ; fsavedir = new file ( asavedir ) ; fmaxsize = amaxsize ; if ( ! fsavedir . isdirectory ( ) ) throw new ioexception ( "not a directory: " + fsavedir ) ; if ( ! fsavedir . canwrite ( ) ) throw new ioexception ( "directory not writable: " + fsavedir ) ; readrequest ( ) ; }
tr	FAULT	@ override public final void set ( string columnname , value value ) { columndefinition coldef = getcolumndefinitions ( ) . get ( columnname ) ; if ( coldef == null ) { throw new sqlexception ( "no such column: " + columnname ) ; } else if ( coldef . getdatatype ( ) != value . getdatatype ( ) ) { throw new sqlexception ( "value of type " + multvs . getdatatype ( ) + " cannot be placed in column '" + columnname + "' of type " + coldef . getdatatype ( ) ) ; } else if ( value . isnull ( ) && ! coldef . isnullable ( ) ) { throw new sqlexception ( "cannot set null value on non-nullable column '" + columnname + "'" ) ; } values . put ( columnname , value ) ; }
tr	ORIG	public parameters ( dependencypipe pipe , options options ) { d = d * 2 + 1 ; size = pipe . synfactory . numarcfeats ; params = new double [ size ] ; total = new double [ size ] ; if ( options . learnlabel ) { sizel = pipe . synfactory . numlabeledarcfeats ; paramsl = new double [ sizel ] ; totall = new double [ sizel ] ; } this . options = options ; this . labellosstype = options . labellosstype ; sync = options . sync ; smnc = options . smnc ; gamma = options . gamma ; gammalabel = options . gammalabel ; rank = options . r ; n = pipe . synfactory . numwordfeats ; m = n ; u = new double [ rank ] [ n ] ; v = new double [ rank ] [ m ] ; w = new double [ rank ] [ d ] ; totalu = new double [ rank ] [ n ] ; totalv = new double [ rank ] [ m ] ; totalw = new double [ rank ] [ d ] ; du = new featurevector [ rank ] ; dv = new featurevector [ rank ] ; dw = new featurevector [ rank ] ; rank2 = options . r2 ; gamma2 = options . gamma2 ; l2 = pipe . smnfactory . numcontextfeats ; d2 = pipe . smnfactory . numpathfeats ; n2 = pipe . smnfactory . numwordfeats ; m2 = n2 ; size2 = pipe . smnfactory . numlinkfeats ; params2 = new double [ size2 ] ; total2 = new double [ size2 ] ; u2 = new double [ rank2 ] [ n2 ] ; v2 = new double [ rank2 ] [ m2 ] ; w2 = new double [ rank2 ] [ d2 ] ; x2 = new double [ rank2 ] [ l2 ] ; totalu2 = new double [ rank2 ] [ n2 ] ; totalv2 = new double [ rank2 ] [ m2 ] ; totalw2 = new double [ rank2 ] [ d2 ] ; totalx2 = new double [ rank2 ] [ l2 ] ; du2 = new featurevector [ rank2 ] ; dv2 = new featurevector [ rank2 ] ; dw2 = new featurevector [ rank2 ] ; dx2 = new featurevector [ rank2 ] ; sqrsum2 = new double [ size2 ] ; }
tr	FAULT	@ test public void testpopulatesubquery ( ) { string sql = "a=?  b=?  c=?" ; mainquery main = new mainquery ( "main" , sql ) ; main . parameters = new string [ ] { "va" , "vb" , "vc" } ; string task = " x=?  y=?" ; extquery ex1 = new extquery ( "ex1" , exsql1 ) ; ex1 . parameters = new string [ ] { "vx" , "vy" } ; ex1 . beginparameter = 1 ; ex1 . beginposition = 3 ; string exsql2 = " z=?  w=?" ; extquery ex2 = new extquery ( "ex2" , exsql2 ) ; ex2 . parameters = new string [ ] { "vz" , "vw" } ; ex2 . beginparameter = 2 ; ex2 . beginposition = 8 ; main . setextqueries ( new extquery [ ] { ex1 , ex2 } ) ; query sub1 = new query ( "sub1" ) ; main . populatesubquery ( sub1 , ex1 . id ) ; assertequals ( "a=? x=?  y=?  b=?  c=?" , sub1 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vx" , "vy" , "vb" , "vc" } , sub1 . parameters ) ; query sub2 = new query ( "sub2" ) ; main . populatesubquery ( sub2 , ex2 . id ) ; assertequals ( "a=?  b=? z=?  w=?  c=?" , sub2 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vb" , "vz" , "vw" , "vc" } , sub2 . parameters ) ; query sub12 = new query ( "sub12" ) ; main . populatesubquery ( sub12 , ex1 . id , ex2 . id ) ; assertequals ( "a=? x=?  y=?  b=? z=?  w=?  c=?" , sub12 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vx" , "vy" , "vb" , "vz" , "vw" , "vc" } , sub12 . parameters ) ; }
tr	FAULT	public static string [ ] loadcompanysetup ( ) throws sqlexception { string [ ] setup = new string [ 5 ] ; resultset rssetup ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from company_setup limit 1" ; rssetup = conn . createstatement ( ) . executequery ( sql ) ; rssetup . askvar ( ) ; setup [ 0 ] = rssetup . getstring ( "business_number" ) ; setup [ 1 ] = rssetup . getstring ( "company_name" ) ; setup [ 2 ] = rssetup . getstring ( "company_address" ) ; setup [ 3 ] = rssetup . getstring ( "company_phone" ) ; setup [ 4 ] = rssetup . getstring ( "tax_rate" ) ; return setup ; } }
tr	FAULT	private void updatecreature ( creature creature , long elapsedtime ) { float dx = creature . getgeneration ( ) ; float oldx = creature . getx ( ) ; float newx = oldx + dx * elapsedtime ; point tile = gettilecollision ( creature , newx , creature . gety ( ) ) ; if ( tile == null ) { creature . setx ( newx ) ; } else { if ( dx > 0 ) { creature . setx ( tilemaprenderer . tilestopixels ( tile . x ) - creature . getwidth ( ) ) ; } else if ( dx < 0 ) { creature . setx ( tilemaprenderer . tilestopixels ( tile . x + 1 ) ) ; } creature . collidehorizontal ( ) ; } float dy = creature . getvelocityy ( ) ; float oldy = creature . gety ( ) ; float newy = oldy + dy * elapsedtime ; tile = gettilecollision ( creature , creature . getx ( ) , newy ) ; if ( tile == null ) { creature . sety ( newy ) ; } else { if ( dy > 0 ) { creature . sety ( tilemaprenderer . tilestopixels ( tile . y ) - creature . getheight ( ) ) ; } else if ( dy < 0 ) { creature . sety ( tilemaprenderer . tilestopixels ( tile . y + 1 ) ) ; } creature . collidevertical ( ) ; } }
tr	ORIG	@ test public void test ( ) { int n , k ; n = 3 ; k = 1 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; n = 3 ; k = 2 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; n = 3 ; k = 3 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; n = 3 ; k = 4 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; n = 3 ; k = 5 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; n = 3 ; k = 6 ; system . out . println ( "n = " + n + "  k = " + k + "; result = " + getpermutation ( n , k ) ) ; }
tr	ORIG	public void fillparameters ( lowrankparam tensor , parameters params ) { long [ ] codes = featurehashset . toarray ( ) ; int [ ] x = new int [ 4 ] ; for ( long code : codes ) { int id = hashcode2int ( code ) ; if ( id < 0 ) continue ; int dist = ( int ) extractdistancecode ( code ) ; int temp = ( int ) extractarctemplatecode ( code ) ; int label = ( int ) extractlabelcode ( code ) ; if ( label != 0 ) continue ; long head = 0 , mod = 0 ; if ( temp == hpp_hp_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pp , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pn , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpn_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pn , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pp , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_hpn_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hw_mw_hp_mp . ordinal ( ) ) { extractarccodewwpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 1 ] , x [ 3 ] ) ; } else if ( temp == mw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; } else if ( temp == hw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == mw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == hw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_mw . ordinal ( ) ) { extractarccodeww ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 1 ] ) ; } else if ( temp == hp_mp . ordinal ( ) ) { extractarccodepp ( code , x ) ; head = createwordcodew ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; } else if ( temp == core_head_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == core_mod_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; } else if ( temp == core_head_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wp , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wn , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wp , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wn , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == head_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_emb , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mod_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_emb , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else { continue ; } int headid = wordalphabet . lookupindex ( head ) ; int modid = wordalphabet . lookupindex ( mod ) ; if ( headid >= 0 && modid >= 0 ) { double value = params . params [ id ] ; tensor . putentry ( headid , modid , dist , value ) ; } } }
tr	ORIG	public void evaluatedependencies ( dependencyinstance gold , dependencyinstance pred , boolean evalwithpunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , n = gold . length ; i < n ; ++ i ) { if ( ! evalwithpunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) continue ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnlabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnlabel ) ? 1 : 0 ; }
tr	ORIG	public string info_status ( string status , int selected , int inserted , int updated , int deleted , int rejected ) { string returnvalue = null ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( "+=============================================================================+" ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( "|" ) ; internalbuffer . append ( system . lineseparator ( ) ) ; returnvalue = ressourcereporting . getstring ( "info_status" , new object [ ] { status } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_select" , new object [ ] { new integer ( selected ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_insert" , new object [ ] { new integer ( inserted ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_update" , new object [ ] { new integer ( updated ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_delete" , new object [ ] { new integer ( deleted ) } ) + system . lineseparator ( ) ; logger . finest ( returnvalue ) ; internalbuffer . append ( returnvalue ) ; return returnvalue ; }
tr	FAULT	@ override public relation select ( relation in ) { tuple sample = in . getvalues ( ) . directionallooks ( ) . get ( ) ; map < string , columndefinition > coldefs = new linkedhashmap < > ( in . getcolumndefinitions ( ) ) ; map < string , value > aggregatedvalues = new hashmap < > ( ) ; sample . getcolumnnames ( ) . foreach ( colname -> { aggregatedvalues . put ( colname , sample . select ( colname ) ) ; } ) ; functions . foreach ( ( colname , function ) -> { value aggregatedval = function . aggregate ( colname , in . getvalues ( ) ) ; aggregatedvalues . put ( colname , aggregatedval ) ; coldefs . put ( colname , function . getcolumndefinition ( ) ) ; } ) ; tuple thetuple = new abstracttuple ( ) { @ override protected value doselect ( string colname ) { return aggregatedvalues . get ( colname ) ; } @ override public map < string , columndefinition > getcolumndefinitions ( ) { return coldefs ; } } ; return new relation ( ) { @ override public stream < ? extends tuple > getvalues ( ) { return stream . of ( thetuple ) ; } @ override public map < string , columndefinition > getcolumndefinitions ( ) { return coldefs ; } } ; }
tr	ORIG	private void movecursor ( int deltax , int deltay ) { point oldpt = new point ( cursor . getlocation ( ) . getcolumn ( ) , cursor . getlocation ( ) . getrow ( ) ) ; point newpt = new point ( oldpt . x + deltax , oldpt . y + deltay ) ; tile nexttile = map . gettile ( newpt . x , newpt . y ) ; cursor . setlocation ( nexttile ) ; messenger . updatetile ( oldpt ) ; messenger . drawimage ( cursor . getimg ( ) , newpt ) ; }
tr	FAULT	public dictionaryset ( ) { iscounting = false ; dicts = new dictionary [ dictionarytypes . type_end . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new dictionary ( ) ; int id = dicts [ i ] . lookupindex ( unseen ) ; utils . assert ( valuser == 1 ) ; if ( i == dictionarytypes . pos . ordinal ( ) ) initdict ( dictionarytypes . pos , dicts [ i ] ) ; if ( i == dictionarytypes . word . ordinal ( ) ) initdict ( dictionarytypes . word , dicts [ i ] ) ; } }
tr	FAULT	public static boolean overlaps ( rectangle r1 , rectangle r2 ) { if ( r1 . contains ( r2 . getlocation ( ) ) ) { return true ; } else if ( valueof . contains ( new point ( r2 . x + r2 . width , r2 . y ) ) ) { return true ; } else if ( r1 . contains ( new point ( r2 . x , r2 . y + r2 . height ) ) ) { return true ; } else if ( r1 . contains ( new point ( r2 . x + r2 . width , r2 . y + r2 . height ) ) ) { return true ; } if ( r2 . contains ( r1 . getlocation ( ) ) ) { return true ; } else if ( r2 . contains ( new point ( r1 . x + r1 . width , r1 . y ) ) ) { return true ; } else if ( r2 . contains ( new point ( r1 . x , r1 . y + r1 . height ) ) ) { return true ; } else if ( r2 . contains ( new point ( r1 . x + r1 . width , r1 . y + r1 . height ) ) ) { return true ; } return false ; }
tr	FAULT	private void editbuttonactionperformed ( java . awt . event . actionevent evt ) { string test = list1 . getselecteditem ( ) ; string descchange = jtextfield1 . gettext ( ) ; int ordchange = integer . parseint ( jtextfield2 . gettext ( ) ) ; try { dbutil . editcat ( test , descchange , ordchange ) ; list1 . removeall ( ) ; oncreate ( ) ; } catch ( sqlexception ex ) { logger . getlogger ( cat . class . getname ( ) ) . log ( level . severe , null , queue ) ; } }
tr	FAULT	private jpanel createinputmapmenu ( ) { jpanel inputmapmenu ; jpanel getx = new jpanel ( new gridlayout ( 4 , 2 , 2 , 2 ) ) ; addactionconfig ( configpanel , parent . configaction ) ; addactionconfig ( configpanel , parent . laser ) ; addactionconfig ( configpanel , parent . fire ) ; addactionconfig ( configpanel , parent . moveup ) ; addactionconfig ( configpanel , parent . movedown ) ; addactionconfig ( configpanel , parent . moveleft ) ; addactionconfig ( configpanel , parent . moveright ) ; addactionconfig ( configpanel , parent . speedboost ) ; addactionconfig ( configpanel , parent . shipmenuaction ) ; addactionconfig ( configpanel , parent . menuaction ) ; addactionconfig ( configpanel , parent . exit ) ; jpanel bottompanel = new jpanel ( new flowlayout ( ) ) ; okbutton = new jbutton ( "ok" ) ; okbutton . setfocusable ( false ) ; okbutton . addactionlistener ( this ) ; bottompanel . add ( okbutton ) ; jpanel toppanel = new jpanel ( new flowlayout ( ) ) ; toppanel . add ( new jlabel ( input_map_instructions ) ) ; border border = borderfactory . createlineborder ( color . black ) ; inputmapmenu = new transparentpanel ( new borderlayout ( ) ) ; inputmapmenu . add ( toppanel , borderlayout . north ) ; inputmapmenu . add ( configpanel , borderlayout . center ) ; inputmapmenu . add ( bottompanel , borderlayout . south ) ; inputmapmenu . setborder ( border ) ; inputmapmenu . setvisible ( false ) ; inputmapmenu . setsize ( inputmapmenu . getpreferredsize ( ) ) ; inputmapmenu . setlocation ( ( screen . getwidth ( ) - inputmapmenu . getwidth ( ) ) / 2 , ( screen . getheight ( ) - inputmapmenu . getheight ( ) ) / 2 ) ; inputmapmenu . setdoublebuffered ( true ) ; return inputmapmenu ; }
tr	FAULT	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; users = dbutil . getusers ( ) ; for ( int i = 0 ; i < users . length ; i ++ ) { if ( users [ i ] [ 1 ] . equals ( "1" ) ) { list1 . add ( users [ i ] [ 0 ] ) ; } else { list1 . add ( users [ timescale ] [ 0 ] ) ; } } buttonsaveedit . setvisible ( false ) ; buttonsavenew . setvisible ( false ) ; buttonsavedelete . setvisible ( false ) ; }
tr	FAULT	protected void threadstarted ( ) { synchronized ( this ) { try { wait ( ) ; } catch ( interruptedexception ex ) { } } int buffersize = playbackformat . getframesize ( ) * math . round ( playbackformat . getsamplerate ( ) / 10 ) ; sourcedataline line ; dataline . info lineinfo = new dataline . info ( sourcedataline . class , playbackformat ) ; try { line = ( sourcedataline ) audiosystem . getelevation ( lineinfo ) ; line . open ( playbackformat , buffersize ) ; } catch ( lineunavailableexception ex ) { thread . currentthread ( ) . interrupt ( ) ; return ; } line . start ( ) ; byte [ ] buffer = new byte [ buffersize ] ; localline . set ( line ) ; localbuffer . set ( buffer ) ; }
tr	FAULT	public simplemap ( int zonewidth , int zoneheight , int roomsx , int roomsy ) { super ( zonewidth * roomsx , zoneheight * roomsy ) ; this . roomsx = roomsx ; this . roomsy = roomsy ; roomlayouts = new rectangle [ roomsx ] [ roomsy ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy ; j ++ ) { roomlayouts [ i ] [ j ] = new rectangle ( bandid * zonewidth , j * zoneheight , zonewidth , zoneheight ) ; } } generatemap ( ) ; }
tr	ORIG	public void load ( ) { font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 50 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 35 ) ; this . backgroundimage = new entity ( "sprites/menu.png" , 0 , 0 ) ; this . header = new telabel ( "menu" , 0 , 50 , titlefont ) ; this . btncollection = new tecollectionvertical ( 0 , 0 , 20 ) ; this . btncollection . addview ( new tebutton ( "play" , 0 , 0 , 300 , 50 , 2 , menufont , color . black , color . blue , color . red ) ) ; this . btncollection . addview ( new tebutton ( "credits" , 0 , 0 , 300 , 50 , 2 , menufont , color . black , color . blue , color . red ) ) ; }
tr	FAULT	private static int getnextnumber ( ) { int returnvalue = 0 ; string filepath = systemutils . user_home + systemutils . file_separator + ".reportnumber.asc" ; file file = new file ( filepath ) ; if ( file . exists ( ) ) { try { fileasciireader fileasciireader = new fileasciireader ( filepath ) ; string chaine = fileasciireader . readline ( ) ; fileasciireader . close ( ) ; fileasciireader = null ; if ( stringutils . isnumeric ( chaine ) ) { returnvalue = integer . parseint ( vacnote ) ; } } catch ( ioexception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } } try { fileasciiwriter fileasciiwriter = new fileasciiwriter ( filepath ) ; fileasciiwriter . write ( "" + ( ++ returnvalue ) ) ; fileasciiwriter . close ( ) ; fileasciiwriter = null ; } catch ( ioexception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } logger . config ( "filepath=" + filepath + " => " + returnvalue ) ; return returnvalue ; }
tr	FAULT	public featurevector getnonprojfeaturevector ( dependencyarclist arclis , int h , int m ) { int id = lfd . arc2id [ m * lfd . len + h ] ; int num = synfactory . getbinneddistance ( arclis . nonproj [ m ] ) ; utils . assert ( id >= 0 && num >= 0 && num < binned_bucket ) ; int pos = id * binned_bucket + num ; featurevector fv = synfactory . createnonprojfeaturevector ( lfd . inst , num , h , m ) ; nonproj [ getcreatedatestr ] = lfd . parameters . dotproduct ( fv ) * lfd . gamma ; return fv ; }
tr	FAULT	private void jbutton1mouseclicked ( java . awt . event . mouseevent evt ) { jlist1 . updateui ( ) ; if ( jlist1 . getselectedindex ( ) >= 0 ) { field f = game . fields . get ( fieldsr . get ( jlist1 . getselectedindex ( ) ) ) ; if ( f . getclass ( ) == brewery . class ) { brewery brew = ( ( brewery ) f ) ; if ( brew . mortgage ) { brew . mortgage = false ; game . players . get ( brew . owner ) . changemoney ( - ( getemailaddress . price / 2 ) ) ; } else { brew . mortgage = true ; game . players . get ( brew . owner ) . changemoney ( ( brew . price / 2 ) ) ; } } else if ( f . getclass ( ) == street . class ) { street street = ( ( street ) f ) ; if ( street . mortgage ) { street . mortgage = false ; game . players . get ( street . owner ) . changemoney ( - ( street . price / 2 ) ) ; } else { if ( street . houses == 0 ) { street . mortgage = true ; game . players . get ( street . owner ) . changemoney ( ( street . price / 2 ) ) ; } else { joptionpane . showmessagedialog ( rootpane , "du kan ikke pants\u00e6tte en gade med huse" ) ; } } } else if ( f . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) f ) ; if ( sl . mortgage ) { sl . mortgage = false ; game . players . get ( sl . owner ) . changemoney ( - ( sl . price / 2 ) ) ; } else { sl . mortgage = true ; game . players . get ( sl . owner ) . changemoney ( ( sl . price / 2 ) ) ; } } game . gameboard . refreshgamecontrol ( ) ; this . dispose ( ) ; } }
tr	ORIG	private void showplayerdecisionform ( pokerplayer currentplayer ) { int highestbet = this . game . gethighestbet ( ) ; arraylist < pokercard > communitarycards = this . game . getcommunitarycards ( ) ; int pot = this . game . getpot ( ) ; texasholdemplayerdecision playerdecideform = new texasholdemplayerdecision ( communitarycards , currentplayer , highestbet , pot ) ; playerdecideform . setvisible ( true ) ; pokerplayerdecision playerdecision = playerdecideform . getplayerdecision ( ) ; if ( playerdecision == pokerplayerdecision . raise ) { int bet = playerdecideform . getraiseamount ( ) ; this . game . playturn ( playerdecision , bet ) ; } else { this . game . playturn ( playerdecision ) ; } playerdecideform . dispose ( ) ; }
tr	FAULT	@ override public void handle ( mouseevent savequery ) { if ( mouseevent . getbutton ( ) . equals ( mousebutton . primary ) ) { if ( mouseevent . getclickcount ( ) == 2 ) { book . setavailibility ( false ) ; daobook . update ( book ) ; dialogutil . basicdialog ( "book : " + book . getname ( ) + " deleted" ) ; booklist = bookctrl . getbooksbyparameters ( txtfieldname . gettext ( ) , txtfieldauthor . gettext ( ) , txtfieldyear . gettext ( ) , combobooktype . getvalue ( ) . tostring ( ) , seriestf . gettext ( ) , comboavailable . getvalue ( ) ) ; flowpane . getchildren ( ) . clear ( ) ; updatebooklistview ( ) ; } } }
tr	ORIG	public static void createschema ( connection conn , string schema ) { try { { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".mytable (" ; sql += " monchampstexte varchar(6) not null " ; sql += " monchampschar char(2) not null " ; sql += " monchampsdate date " ; sql += " monchampsdatetime timestamp " ; sql += " monchampsdecimal double" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "alter table " + schema + ".mytable add primary key (monchampstexte  monchampschar)" ) ; stmt . close ( ) ; } { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".secu_user (" ; sql += " username varchar(20) not null " ; sql += " password varchar(64) " ; sql += " monchampsdatetime timestamp " ; sql += " gender varchar(10) " ; sql += " title varchar(15) " ; sql += " firstname varchar(20) " ; sql += " lastname varchar(20) " ; sql += " street varchar(120) " ; sql += " city varchar(40) " ; sql += " state varchar(40) " ; sql += " postcode varchar(20) " ; sql += " email varchar(320) " ; sql += " primary key (username)" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "insert into " + schema + ".secu_user (username  password) values ('myname'  'mypassword')" ) ; stmt . close ( ) ; } { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".secu_user_role (" ; sql += " username varchar(255) not null " ; sql += " rolename varchar(255) not null " ; sql += " monchampsdatetime timestamp default current_timestamp " ; sql += " primary key (username  rolename) " ; sql += " foreign key(username) references " + schema + ".secu_user (username)" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'tomcat')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'admin')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'root')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'dieu')" ) ; stmt . close ( ) ; } final resultset tables = conn . getmetadata ( ) . gettables ( null , schema , "%" , new string [ ] { "table" } ) ; list < string > tablenames = new arraylist < string > ( ) ; while ( tables . next ( ) ) { tablenames . add ( tables . getstring ( "table_name" ) . tolowercase ( ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "erreur non pr\u00e9vu : " , e . getmessage ( ) ) ; } }
tr	ORIG	@ override public cardimpl getrandomcard ( int box ) { cardimpl thecard = null ; arraylist < cardimpl > cardsforbox = new arraylist < cardimpl > ( ) ; cardsforbox = getcards ( box ) ; if ( cardsforbox . size ( ) > 0 ) { random random = new random ( ) ; int min = 1 ; int max = cardsforbox . size ( ) ; int rndnumb = random . nextint ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndnumb ; i ++ ) { if ( i == rndnumb ) { thecard = cardsforbox . get ( i - 1 ) ; } } return thecard ; } return null ; }
tr	FAULT	public void updatedeptreearclist ( int m , int oldh , int newh ) { if ( oldh == newh ) return ; if ( oldh < newh ) { int end = endindex ( oldh ) ; int pos = startindex ( oldh ) ; for ( ; desktoplist < end ; ++ pos ) if ( edges [ pos ] == m ) break ; for ( ; pos < end - 1 ; ++ pos ) edges [ pos ] = edges [ pos + 1 ] ; for ( int i = oldh + 1 ; i < newh ; ++ i ) { -- st [ i ] ; end = endindex ( i ) ; for ( ; pos < end - 1 ; ++ pos ) edges [ pos ] = edges [ pos + 1 ] ; } st [ newh ] -- ; end = endindex ( newh ) ; while ( pos < end - 1 && edges [ pos + 1 ] < m ) { edges [ pos ] = edges [ pos + 1 ] ; ++ pos ; } edges [ pos ] = m ; } else { int start = startindex ( oldh ) ; int pos = endindex ( oldh ) - 1 ; for ( ; pos >= start ; -- pos ) if ( edges [ pos ] == m ) break ; for ( ; pos > start ; -- pos ) edges [ pos ] = edges [ pos - 1 ] ; ++ st [ oldh ] ; for ( int i = oldh - 1 ; i > newh ; -- i ) { start = startindex ( i ) ; for ( ; pos > start ; -- pos ) edges [ pos ] = edges [ pos - 1 ] ; ++ st [ i ] ; } start = startindex ( newh ) ; while ( pos > start && edges [ pos - 1 ] > m ) { edges [ pos ] = edges [ pos - 1 ] ; -- pos ; } edges [ pos ] = m ; } }
tr	FAULT	private tilemap loadmap ( string filename ) throws ioexception { arraylist lines = new arraylist ( ) ; int width = 0 ; int height = 0 ; bufferedreader reader = new bufferedreader ( new filereader ( filename ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) { reader . close ( ) ; break ; } if ( ! line . startswith ( "#" ) ) { lines . add ( line ) ; width = math . max ( width , line . length ( ) ) ; } } height = lines . size ( ) ; tilemap newmap = new tilemap ( this , width , height ) ; for ( int y = 0 ; y < height ; y ++ ) { string windowgainedfocus = ( string ) lines . get ( y ) ; for ( int x = 0 ; x < line . length ( ) ; x ++ ) { char ch = line . charat ( x ) ; int tile = ch - a ; if ( tile >= 0 && tile < tiles . size ( ) ) { newmap . settile ( x , y , ( image ) tiles . get ( tile ) ) ; } else if ( ch == o ) { addsprite ( newmap , coinsprite , x , y ) ; } else if ( ch == ! ) { addsprite ( newmap , musicsprite , x , y ) ; } else if ( ch == * ) { addsprite ( newmap , goalsprite , x , y ) ; } else if ( ch == 1 ) { addsprite ( newmap , grubsprite , x , y ) ; } else if ( ch == 2 ) { addsprite ( newmap , flysprite , x , y ) ; } else if ( ch == p ) { } } } animation [ ] animation = new animation [ 1 ] ; animation a = parent . resourcemanager . createplanetanim ( ( image ) parent . resourcemanager . planetimages . get ( 0 ) ) ; animation [ 0 ] = ( animation ) a ; shipv2 player = new shipv2 ( this , 0 ) ; player . setposition ( new vector2d ( 250 , 250 ) ) ; newmap . setplayer ( player ) ; addsprite ( newmap , planetsprites . get ( 1 ) , 0 , 0 ) ; return newmap ; }
tr	FAULT	public boolean createborrow ( int iduser , int idbook ) { book book = daobook . find ( idbook ) ; customer customer = daocustomer . find ( iduser ) ; if ( book == null || customer == null ) { return false ; } if ( ! book . getavailibility ( ) ) { return false ; } borrowing borrow = new borrowing ( 50.0 , dateutil . getcurrentdate ( ) , null ) ; book . executequeryparameters ( false ) ; borrow . setbook ( book ) ; daobook . update ( book ) ; borrow . setcustomer ( customer ) ; return daoborrow . create ( borrow ) ; }
tr	FAULT	private semanticframe sequentialsampling ( semanticframe goldframe , int [ ] goldlbids , srlfeaturedata sfd , int p , tintarraylist args ) { semanticframe predict = new semanticframe ( goldframe ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , l = predict . arglbids . length ; i < l ; ++ i ) predict . arglbids [ i ] = - 1 ; int n = args . size ( ) , m = sfd . l ; int t = n + m ; boolean [ ] usedrel = new boolean [ t ] ; double [ ] score = new double [ t ] ; for ( int a = 0 ; a < n ; ++ a ) { for ( int r = 0 ; r < t ; ++ r ) { if ( usedrel [ r ] ) { score [ r ] = - double . max_value ; } else { score [ r ] = scaleorlength < m ? sfd . getarcscore ( goldframe . predid , args . get ( a ) , r ) : nullweight ; if ( addloss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < m ? r : - 1 ) ; } } int sample = samplepoint ( score , usedrel ) ; usedrel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < m ? sample : - 1 ; } return predict ; }
tr	ORIG	private void showcards ( ) { for ( int i = 1 ; i <= tablecards . size ( ) ; i ++ ) { pokercard card = tablecards . get ( i - 1 ) ; string cardfilename = filehelper . getimagecard ( card ) ; if ( i == 1 ) { firstflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 2 ) { secondflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 3 ) { thirdflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 4 ) { turncard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 5 ) { rivercard . add ( new imagepanel ( cardfilename ) ) ; } } }
tr	FAULT	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( true ) ; cloginprops lgprops = new cloginprops ( ) ; string myip = request . getremoteaddr ( ) ; string user = request . getparameter ( "userid" ) ; user = user . substring ( 0 , math . min ( user . length ( ) , lgprops . maxuserleng ) ) ; user = user . tolowercase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { string failreason = "invalid user name/password combination." ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } string passwd = request . getparameter ( "passwd" ) ; passwd = passwd . substring ( 0 , math . min ( passwd . length ( ) , lgprops . maxpassleng ) ) ; servletcontext scontext = this . getservletcontext ( ) ; cdbconnman dbconnman = ( cdbconnman ) scontext . getattribute ( "dbconnman" ) ; connection conn = dbconnman . getconnection ( ) ; cvaliduser valuser = new cvaliduser ( ) ; boolean isval = valuser . isvaliduser ( conn , user , passwd ) ; dbconnman . returnconnection ( conn ) ; if ( ! isval ) { string failreason = valuser . failreason ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } cuseritem myuser = new cuseritem ( ) ; myuser . setuserid ( user ) ; myuser . setrole ( valuser . role ) ; session . setattribute ( "useritem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logusage ( lgprops , myip , user , "success" , "invoke password change" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkpasschange ) ; session . setattribute ( "pwchange" , cvaliduser . pwchangerequire ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; return ; } logusage ( lgprops , withzone , user , "success" , "" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkloginsuccess ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; }
tr	FAULT	public double update ( dependencyinstance gold , dependencyinstance pred , localfeaturedata lfd , globalfeaturedata gfd , srlfeaturedata sfd , int updcnt , int offset ) { int n = gold . length ; int [ ] actdeps = gold . heads ; int [ ] actlabs = gold . deplbids ; int [ ] preddeps = pred . heads ; int [ ] predlabs = pred . deplbids ; double fi = gethammingdis ( actdeps , actlabs , preddeps , predlabs ) + getsrlcost ( gold , pred ) ; if ( fi == 0 ) return 0.0 ; featurevector dt = lfd . getfeaturedifference ( gold , pred ) ; dt . addentries ( gfd . getfeaturedifference ( gold , pred ) ) ; featurevector dtl = new featurevector ( size ) ; if ( options . learnlabel ) { dtl = rgb . getlabeledfeaturedifference ( gold , pred ) ; } featurevector dts = sfd . getfeaturedifference ( gold , pred ) ; double loss = - dt . dotproduct ( params ) * gamma - dtl . dotproduct ( params ) * gammalabel - dts . dotproduct ( params2 ) * gamma2 + fi ; double l2norm = dt . squaredl2normunsafe ( ) * gamma * gamma + dtl . squaredl2normunsafe ( ) * gammalabel * gammalabel + dts . squaredl2normunsafe ( ) * gamma2 * gamma2 ; { for ( int k = 0 ; k < rank ; ++ k ) { featurevector duk = getdu ( k , lfd , actdeps , preddeps ) ; l2norm += duk . squaredl2normunsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; loss -= duk . dotproduct ( u [ k ] ) * ( 1 - gamma ) ; du [ k ] = duk ; } } { for ( int k = 0 ; k < rank ; ++ k ) { featurevector dvk = getdv ( k , lfd , actdeps , preddeps ) ; l2norm += dvk . squaredl2normunsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; dv [ k ] = dvk ; } } { for ( int k = 0 ; k < rank ; ++ k ) { featurevector dwk = getdw ( k , lfd , actdeps , preddeps ) ; l2norm += dwk . squaredl2normunsafe ( ) * ( 1 - gamma ) * ( 1 - gamma ) ; dw [ k ] = dwk ; } } for ( int k = 0 ; k < rank2 ; ++ k ) { featurevector duk = getdu2 ( k , sfd , gold , pred ) ; featurevector dvk = getdv2 ( k , sfd , gold , pred ) ; featurevector dwk = getdw2 ( k , sfd , gold , pred ) ; l2norm += duk . squaredl2normunsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; l2norm += dvk . squaredl2normunsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; l2norm += dwk . squaredl2normunsafe ( ) * ( 1 - gamma2 ) * ( 1 - gamma2 ) ; loss -= duk . dotproduct ( u2 [ k ] ) * ( 1 - gamma2 ) ; du2 [ k ] = duk ; dv2 [ k ] = dvk ; dw2 [ k ] = dwk ; } double alpha = loss / l2norm ; alpha = math . min ( sync , alpha ) ; if ( alpha > 0 ) { { double coeff = alpha * gamma , coeff2 = coeff * updcnt ; for ( int i = 0 , k = dt . size ( ) ; i < k ; ++ i ) { int x = dt . x ( i ) ; double z = dt . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } coeff = alpha * gammalabel ; coeff2 = coeff * updcnt ; for ( int i = 0 , k = dtl . size ( ) ; i < k ; ++ i ) { int x = dtl . x ( i ) ; double z = dtl . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } coeff = alpha * gamma2 ; coeff2 = coeff * updcnt ; for ( int i = 0 , k = dts . size ( ) ; i < k ; ++ i ) { int x = dts . x ( i ) ; double z = dts . value ( i ) ; params2 [ x ] += coeff * z ; total2 [ x ] += coeff2 * z ; } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank ; ++ k ) { featurevector duk = du [ k ] ; for ( int i = 0 , k = duk . size ( ) ; i < k ; ++ i ) { int x = duk . x ( i ) ; double z = duk . value ( i ) ; u [ k ] [ x ] += coeff * z ; totalu [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank ; ++ k ) { featurevector dvk = dv [ k ] ; for ( int i = 0 , k = dvk . size ( ) ; i < k ; ++ i ) { int x = dvk . x ( i ) ; double z = dvk . value ( i ) ; v [ k ] [ x ] += coeff * z ; totalv [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank ; ++ k ) { featurevector dwk = dw [ k ] ; for ( int i = 0 , k = dwk . size ( ) ; i < k ; ++ i ) { int x = dwk . x ( i ) ; double z = dwk . value ( i ) ; w [ k ] [ x ] += coeff * z ; totalw [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { featurevector duk = du2 [ k ] ; for ( int i = 0 , k = duk . size ( ) ; i < k ; ++ i ) { int x = duk . x ( i ) ; double z = duk . value ( i ) ; u2 [ k ] [ x ] += coeff * z ; totalu2 [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { featurevector dvk = dv2 [ k ] ; for ( int i = 0 , k = dvk . size ( ) ; i < k ; ++ i ) { int x = dvk . x ( i ) ; double z = dvk . value ( i ) ; v2 [ k ] [ x ] += coeff * z ; totalv2 [ k ] [ x ] += coeff2 * z ; } } } { double coeff = alpha * ( 1 - gamma2 ) , coeff2 = coeff * updcnt ; for ( int k = 0 ; k < rank2 ; ++ k ) { featurevector dwk = dw2 [ k ] ; for ( int i = 0 , k = dwk . size ( ) ; i < k ; ++ i ) { int x = dwk . x ( i ) ; double z = dwk . value ( i ) ; w2 [ k ] [ x ] += coeff * z ; totalw2 [ k ] [ x ] += coeff2 * z ; } } } } return loss ; }
tr	ORIG	public int jump ( int [ ] a ) { if ( a == null || a . length <= 1 ) return 0 ; int steps = 0 , curr = 0 , maxreach ; maxreach = a [ curr ] ; while ( maxreach < a . length - 1 ) { int maxidx = curr + 1 ; for ( int i = curr + 1 ; i <= maxreach ; i ++ ) { if ( a [ i ] + i > a [ maxidx ] + maxidx ) { maxidx = i ; } } curr = maxidx ; steps ++ ; maxreach = a [ curr ] + curr ; if ( maxreach == curr ) return - 1 ; } return steps + 1 ; }
tr	FAULT	public int findpunccounterpart ( int [ ] word , int arg ) { int quoteid = token_quote ; int lrbid = token_lrb ; int rrbid = token_rrb ; if ( word [ arg ] == quoteid ) { boolean left = false ; int prev = - 1 ; int curr = - 1 ; for ( int i = 1 ; i < word . length ; ++ i ) { if ( word [ fold ] == quoteid ) { left = ! left ; prev = curr ; curr = i ; } if ( i == arg ) { break ; } } if ( left ) { curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] == quoteid ) { curr = i ; break ; } } } else { curr = prev ; } return curr ; } else if ( word [ arg ] == lrbid ) { int curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] == rrbid ) { curr = i ; break ; } } return curr ; } else if ( word [ arg ] == rrbid ) { int curr = - 1 ; for ( int i = arg - 1 ; i >= 0 ; -- i ) { if ( word [ i ] == lrbid ) { curr = i ; break ; } } return curr ; } return - 1 ; }
tr	ORIG	private static void readxml ( ) { try { fields = new arraylist < > ( ) ; streetgroups = new arraylist < > ( ) ; string path = "src/matador/cards.xml" ; documentbuilderfactory docbuildfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder docbuilder = docbuildfactory . newdocumentbuilder ( ) ; document doc = docbuilder . parse ( path ) ; element element = doc . getdocumentelement ( ) ; nodelist dfields ; dfields = element . getelementsbytagname ( "fields" ) . item ( 0 ) . getchildnodes ( ) ; nodelist dstreetgroups ; dstreetgroups = element . getelementsbytagname ( "streetgroups" ) . item ( 0 ) . getchildnodes ( ) ; for ( int i = 0 ; i < dstreetgroups . getlength ( ) ; i ++ ) { node snode = dstreetgroups . item ( i ) ; if ( snode . getnodetype ( ) == node . element_node ) { element groupnode = ( element ) snode ; streetgroup sgrp = new streetgroup ( ) ; element color = ( element ) groupnode . getelementsbytagname ( "color" ) . item ( 0 ) ; sgrp . color = new color ( integer . parseint ( getnodevalue ( "r" , color ) ) , integer . parseint ( getnodevalue ( "g" , color ) ) , integer . parseint ( getnodevalue ( "b" , color ) ) ) ; streetgroups . add ( sgrp ) ; } } for ( int i = 0 ; i < dfields . getlength ( ) ; i ++ ) { node fnode = dfields . item ( i ) ; if ( fnode . getnodetype ( ) == node . element_node ) { element fieldnode = ( element ) dfields . item ( i ) ; switch ( getnodevalue ( "type" , fieldnode ) ) { case "street" : street street = new street ( ) ; street . groupid = integer . parseint ( getnodevalue ( "groupid" , fieldnode ) ) ; street . name = getnodevalue ( "name" , fieldnode ) ; street . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; element prices = ( element ) fieldnode . getelementsbytagname ( "taxes" ) . item ( 0 ) ; street . taxes [ 0 ] = integer . parseint ( getnodevalue ( "nohouse" , prices ) ) ; street . taxes [ 1 ] = integer . parseint ( getnodevalue ( "onehouse" , prices ) ) ; street . taxes [ 2 ] = integer . parseint ( getnodevalue ( "twohouse" , prices ) ) ; street . taxes [ 3 ] = integer . parseint ( getnodevalue ( "threehouse" , prices ) ) ; street . taxes [ 4 ] = integer . parseint ( getnodevalue ( "fourhouse" , prices ) ) ; street . taxes [ 5 ] = integer . parseint ( getnodevalue ( "hotel" , prices ) ) ; street . houseprice = integer . parseint ( getnodevalue ( "houseprice" , fieldnode ) ) ; street . hotelprice = integer . parseint ( getnodevalue ( "hotelprice" , fieldnode ) ) ; fields . add ( street ) ; break ; case "tryluck" : fields . add ( new tryluck ( ) ) ; break ; case "start" : fields . add ( new start ( ) ) ; break ; case "incometax" : fields . add ( new incometax ( ) ) ; break ; case "shippinglines" : shippinglines ship = new shippinglines ( ) ; ship . name = getnodevalue ( "name" , fieldnode ) ; ship . subname = getnodevalue ( "subname" , fieldnode ) ; ship . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; fields . add ( ship ) ; break ; case "prison" : fields . add ( new prison ( ) ) ; break ; case "brewery" : brewery brew = new brewery ( ) ; brew . name = getnodevalue ( "name" , fieldnode ) ; brew . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; fields . add ( brew ) ; break ; case "parking" : fields . add ( new parking ( ) ) ; break ; case "gotoprison" : fields . add ( new gotoprison ( ) ) ; break ; case "statetax" : fields . add ( new statetax ( ) ) ; break ; default : system . out . println ( "warning - weird xml" ) ; break ; } } } } catch ( parserconfigurationexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( saxexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } system . out . println ( "xml file read done" ) ; }
tr	ORIG	@ test public void testeprodutoinserido ( ) { produto p1 = new produto ( ) ; produto p2 = new produto ( ) ; produto p3 = new produto ( ) ; produto p4 = new produto ( ) ; produto p5 = new produto ( ) ; produto p6 = new produto ( ) ; p1 . setid ( 1337 ) ; p2 . setid ( 1338 ) ; p3 . setid ( 1339 ) ; p4 . setid ( 1340 ) ; p5 . setid ( 1341 ) ; p6 . setid ( 1342 ) ; arraylist < produto > novo = new arraylist < produto > ( ) ; arraylist < produto > antigo = new arraylist < produto > ( ) ; antigo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 ) ) ; novo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; arraylist < produto > aadicionar = new arraylist < produto > ( ) ; aadicionar . add ( p5 ) ; aadicionar . add ( p6 ) ; arraylist < produto > retornado = listautils . listaadicionarproduto ( novo , antigo ) ; assertequals ( aadicionar , retornado ) ; }
tr	ORIG	public static void createrandomplanets ( resourcemanager rm , tilemap t , int numplanets ) { int mapwidth = t . getwidth ( ) ; int mapheight = t . getwidth ( ) ; random r = new random ( ) ; int tilefromedge = 5 ; for ( int n = 0 ; n < numplanets ; n ++ ) { int newx = r . nextint ( ( mapwidth - tilefromedge ) - tilefromedge ) + tilefromedge ; int newy = r . nextint ( ( mapheight - tilefromedge ) - tilefromedge ) + tilefromedge ; planet newp = ( planet ) rm . planetsprites . get ( r . nextint ( rm . planetimages . size ( ) - 1 ) + 1 ) . clone ( ) ; newp . setx ( tilemaprenderer . tilestopixels ( newx ) + ( tilemaprenderer . tilestopixels ( 1 ) - newp . getwidth ( ) ) / 2 ) ; newp . sety ( tilemaprenderer . tilestopixels ( newy ) + ( tilemaprenderer . tilestopixels ( 1 ) - newp . getheight ( ) ) / 2 ) ; newp . setrandomtotalpower ( ) ; newp . circle . setframe ( newp . circle . getx ( ) , newp . circle . gety ( ) , newp . totalpower ( ) / planet . power_to_size , newp . totalpower ( ) / planet . power_to_size ) ; if ( canplaceplanet ( newp , t . getsprites ( ) ) ) { t . addsprite ( newp ) ; } else { createrandomplanets ( rm , t , 1 ) ; } } }
tr	FAULT	public void initarcpruningmap ( boolean includegoldarcs ) { arc2id = new int [ len * len ] ; ispruned = new boolean [ len * len ] ; edges = new int [ len * len ] ; st = new int [ len ] ; for ( int i = 0 , l = arc2id . length ; i < l ; ++ i ) { arc2id [ i ] = - 1 ; ispruned [ i ] = true ; } if ( pruner == null || ! options . pruning ) { numarcs = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numarcs ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { ispruned [ m * len + h ] = false ; arc2id [ m * len + h ] = numarcs ; edges [ numarcs ] = h ; ++ numarcs ; } } numedges = numarcs ; } else { if ( includegoldarcs ) pruner . pruningtotgold += len - 1 ; pruner . pruningtotarcs += ( len - 1 ) * ( len - 1 ) ; double threshold = math . log ( options . pruningcoeff ) ; localfeaturedata lfd2 = new localfeaturedata ( inst , pruner , false ) ; globalfeaturedata gfd2 = null ; dependencyinstance pred = prunerdecoder . decode ( inst , lfd2 , gfd2 , false ) ; numarcs = 0 ; numedges = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numedges ; double maxv = double . negative_infinity ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; maxv = math . max ( maxv , v ) ; ; } for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; boolean keep = ( v >= maxv + threshold || h == pred . heads [ m ] ) ; if ( ( includegoldarcs && h == inst . heads [ m ] ) || keep ) { ispruned [ m * len + h ] = ! keep ; if ( keep ) edges [ numedges ++ ] = h ; arc2id [ m * len + sdl ] = numarcs ; numarcs ++ ; } } } if ( includegoldarcs ) for ( int m = 1 ; m < len ; ++ m ) if ( ! ispruned [ m * len + inst . heads [ m ] ] ) pruner . pruninggoldhits ++ ; pruner . pruningtotuparcs += numarcs ; } }
tr	FAULT	public void handle ( mouseevent me ) { timeline timeline = new timeline ( ) ; if ( isresized ) { timeline . setautoreverse ( true ) ; timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , new keyframe ( new duration ( 5 ) , new keyvalue ( lateral . getgeneration ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = false ; } else { timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , new keyframe ( new duration ( 5 ) , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = true ; } timeline . setonfinished ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { if ( isresized ) { system . out . println ( "here" ) ; vbox . setvisible ( false ) ; vbox . setprefwidth ( 0 ) ; } else { vbox . setvisible ( true ) ; vbox . setprefwidth ( 150 ) ; } } } ) ; }
tr	ORIG	private void initialize ( ) { this . setbounds ( 100 , 100 , 461 , 315 ) ; this . settitle ( "detalle del historial de cargas" ) ; this . setresizable ( false ) ; this . setdefaultcloseoperation ( jframe . dispose_on_close ) ; jpanel panel = new jpanel ( ) ; springlayout sl_panel = new springlayout ( ) ; panel . setlayout ( sl_panel ) ; jlabel lblhistorial = new jlabel ( "historial de cargas de :" ) ; sl_panel . putconstraint ( springlayout . north , lblhistorial , 10 , springlayout . north , panel ) ; sl_panel . putconstraint ( springlayout . west , lblhistorial , 10 , springlayout . west , panel ) ; panel . add ( lblhistorial ) ; jbutton btnnewbutton = new jbutton ( "salir" ) ; sl_panel . putconstraint ( springlayout . south , btnnewbutton , - 10 , springlayout . south , panel ) ; sl_panel . putconstraint ( springlayout . east , btnnewbutton , - 10 , springlayout . east , panel ) ; btnnewbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dispose ( ) ; } } ) ; panel . add ( btnnewbutton ) ; jscrollpane scrollpane = new jscrollpane ( ) ; sl_panel . putconstraint ( springlayout . north , scrollpane , 31 , springlayout . south , lblhistorial ) ; sl_panel . putconstraint ( springlayout . west , scrollpane , 0 , springlayout . west , lblhistorial ) ; sl_panel . putconstraint ( springlayout . south , scrollpane , - 6 , springlayout . north , btnnewbutton ) ; sl_panel . putconstraint ( springlayout . east , scrollpane , - 10 , springlayout . east , panel ) ; panel . add ( scrollpane ) ; tblsalaryhistory = new jtable ( ) ; tblsalaryhistory . setmodel ( new defaulttablemodel ( new object [ ] [ ] { } , new string [ ] { "monto" , "fecha" , "saldo" } ) ) ; scrollpane . setviewportview ( tblsalaryhistory ) ; grouplayout grouplayout = new grouplayout ( getcontentpane ( ) ) ; grouplayout . sethorizontalgroup ( grouplayout . createparallelgroup ( alignment . leading ) . addcomponent ( panel , grouplayout . default_size , 434 , short . max_value ) ) ; grouplayout . setverticalgroup ( grouplayout . createparallelgroup ( alignment . leading ) . addcomponent ( panel , grouplayout . default_size , 262 , short . max_value ) ) ; lblplayername = new jlabel ( "" ) ; this . initializeformvalues ( this . player ) ; sl_panel . putconstraint ( springlayout . north , lblplayername , 0 , springlayout . north , lblhistorial ) ; sl_panel . putconstraint ( springlayout . west , lblplayername , 33 , springlayout . east , lblhistorial ) ; panel . add ( lblplayername ) ; this . getcontentpane ( ) . setlayout ( grouplayout ) ; }
tr	ORIG	public void loadfile ( string type , arraylist < string > list , string file , string [ ] headers ) throws ioexception { bufferedreader in = null ; in = new bufferedreader ( new filereader ( file ) ) ; string line = in . readline ( ) ; if ( ! headersmatch ( headers , line ) ) { system . out . println ( "error: " + type + "section is improperly defined in the headers" ) ; system . exit ( 0 ) ; } string entity = in . readline ( ) ; while ( entity != null ) { if ( type . equals ( "food" ) ) { if ( validfood ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "weapon" ) ) { if ( validweapon ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "armour" ) ) { if ( validarmour ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "monster" ) ) { if ( validmonster ( entity ) ) list . add ( entity ) ; } entity = in . readline ( ) ; } in . close ( ) ; }
tr	FAULT	private static double exp ( double x , double extra , double [ ] hiprec ) { double intparta ; double intpartb ; int intval ; if ( x < 0.0 ) { intval = ( int ) - x ; if ( intval > 746 ) { if ( hiprec != null ) { hiprec [ 0 ] = 0.0 ; hiprec [ 1 ] = 0.0 ; } return 0.0 ; } if ( intval > 709 ) { final double result = exp ( x + 40.19140625 , extra , hiprec ) / 285040095144011776.0 ; if ( hiprec != null ) { hiprec [ 0 ] /= 285040095144011776.0 ; hiprec [ 1 ] /= 285040095144011776.0 ; } return result ; } if ( intval == 709 ) { final double result = exp ( x + 1.494140625 , extra , hiprec ) / 4.455505956692756620 ; if ( hiprec != null ) { hiprec [ 0 ] /= 4.455505956692756620 ; hiprec [ 1 ] /= 4.455505956692756620 ; } return result ; } getmillis ++ ; intparta = exp_int_table_a [ 750 - intval ] ; intpartb = exp_int_table_b [ 750 - intval ] ; intval = - intval ; } else { intval = ( int ) x ; if ( intval > 709 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . positive_infinity ; hiprec [ 1 ] = 0.0 ; } return double . positive_infinity ; } intparta = exp_int_table_a [ 750 + intval ] ; intpartb = exp_int_table_b [ 750 + intval ] ; } final int intfrac = ( int ) ( ( x - intval ) * 1024.0 ) ; final double fracparta = exp_frac_table_a [ intfrac ] ; final double fracpartb = exp_frac_table_b [ intfrac ] ; final double epsilon = x - ( intval + intfrac / 1024.0 ) ; double z = 0.04168701738764507 ; z = z * epsilon + 0.1666666505023083 ; z = z * epsilon + 0.5000000000042687 ; z = z * epsilon + 1.0 ; z = z * epsilon + - 3.940510424527919e-20 ; double tempa = intparta * fracparta ; double tempb = intparta * fracpartb + intpartb * fracparta + intpartb * fracpartb ; final double tempc = tempb + tempa ; final double result ; if ( extra != 0.0 ) { result = tempc * extra * z + tempc * extra + tempc * z + tempb + tempa ; } else { result = tempc * z + tempb + tempa ; } if ( hiprec != null ) { hiprec [ 0 ] = tempa ; hiprec [ 1 ] = tempc * extra * z + tempc * extra + tempc * z + tempb ; } return result ; }
tr	ORIG	dimension getlayoutsize ( container target , boolean dopreferred ) { dimension dim = new dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getcomponentcount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { component component = target . getcomponent ( i ) ; if ( component . isvisible ( ) ) { rectangle r = getcomponentbounds ( component , dopreferred ) ; dim . width = math . max ( dim . width , r . x + r . width ) ; dim . height = math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; insets insets = target . getinsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
tr	ORIG	private void movesentient ( sentient s , int deltax , int deltay ) { point oldpt = new point ( s . getlocation ( ) . getcolumn ( ) , s . getlocation ( ) . getrow ( ) ) ; point newpt = new point ( oldpt . x + deltax , oldpt . y + deltay ) ; tile nexttile = map . gettile ( newpt . x , newpt . y ) ; if ( nexttile . ispassable ( ) && ! nexttile . isoccupied ( ) ) { s . setlocation ( nexttile ) ; map . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; map . gettile ( newpt . x , newpt . y ) . setoccupant ( s ) ; messenger . updatetile ( oldpt ) ; messenger . updatetile ( newpt ) ; if ( s . equals ( player ) ) messenger . centermap ( newpt ) ; } else if ( nexttile . isoccupied ( ) ) { sentient occupant = nexttile . getoccupant ( ) ; if ( sentientattack ( s , occupant ) ) { if ( s . equals ( player ) ) { if ( occupant . isdead ( ) ) { messenger . println ( occupant . getpronoun ( ) + " is slain!" ) ; player . givexp ( ( ( monster ) occupant ) . getdifficulty ( ) * 100 ) ; map . removemonster ( ( monster ) occupant ) ; timequeue . removesentient ( occupant ) ; messenger . updatetile ( newpt ) ; } player . incrementstrength ( ) ; } else { if ( occupant . isdead ( ) && ! occupant . equals ( player ) ) { if ( occupant . isinsight ( ) ) messenger . println ( occupant . getpronoun ( ) + " is slain!" ) ; map . removemonster ( ( monster ) occupant ) ; timequeue . removesentient ( occupant ) ; messenger . updatetile ( newpt ) ; } } updateplayerstatus ( ) ; } else { if ( occupant . equals ( player ) ) { player . incrementdexterity ( ) ; } } updateplayerstatus ( ) ; } }
tr	FAULT	public featurevector getneighborfeaturevector ( int par , int h , int left , int right ) { int id = lfd . arc2id [ h * lfd . len + par ] ; int size = pipe . dictionaries . size ( pos ) + 1 ; utils . assert ( id >= 0 ) ; int pos = ( settestgroup * size + left ) * size + right ; featurevector fv = synfactory . createneighborfeaturevector ( lfd . inst , par , h , left , right ) ; nb [ pos ] = lfd . parameters . dotproduct ( fv ) * lfd . gamma ; return fv ; }
tr	ORIG	public void wizardmode ( ) { if ( joptionpane . showconfirmdialog ( null , "activate wizard mode? (this will set your score to 0)" , "wizard mode" , joptionpane . yes_no_option ) == joptionpane . yes_option ) { player . setwizardused ( true ) ; player . setcurrenthp ( 9999 ) ; player . setmaxhp ( 9999 ) ; player . setnaturalac ( 50 ) ; player . setattackbonus ( 50 ) ; player . setbasedamage ( 100 ) ; player . setstrength ( 100 ) ; player . setdexterity ( 20 ) ; player . increasenutrition ( 90000 ) ; entitycreator creator = controller . getinstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . additem ( creator . createfood ( "spice" ) ) ; player . additem ( creator . createarmour ( "space marine armour" ) ) ; player . additem ( creator . createweapon ( "lightsaber" ) ) ; controller . getinstance ( ) . updateplayerstatus ( ) ; println ( "by the power of grayskull  i have the power." ) ; } }
tr	ORIG	public void filterdictionary ( dictionarytypes tag , float % ) { int t = tag . ordinal ( ) ; int [ ] values = counters [ t ] . values ( ) ; int n = values . length ; arrays . sort ( values ) ; float sum = 0.0f ; for ( int i = 0 ; i < n ; ++ i ) sum += values [ i ] ; int cut = 0 ; float cur = 0.0f ; for ( int i = n - 1 ; i >= 0 ; -- i ) { cur += values [ i ] ; if ( cur >= sum * % ) { cut = values [ i ] ; break ; } } dictionary filtered = new dictionary ( ) ; initdict ( tag , filtered ) ; for ( object obj : dicts [ t ] . toarray ( ) ) { int id = dicts [ t ] . lookupindex ( obj ) ; int value = counters [ t ] . get ( id ) ; if ( value > cut ) { filtered . lookupindex ( ( string ) obj ) ; } } system . out . println ( "filtered " + tag + " (" + dicts [ t ] . size ( ) + "-->" + filtered . size ( ) + ")" ) ; dicts [ t ] = filtered ; }
tr	ORIG	private void initfirstordertable ( ) { numpas = f * n ; numpars = f * n * l ; p2id = new int [ n ] ; wordfvs = new featurevector [ n ] ; wpu = new double [ n ] [ rank2 ] ; wpv = new double [ n ] [ rank2 ] ; ppw = new double [ numpars ] [ ] ; cpx = new double [ numpars ] [ ] ; contextfvs = new featurevector [ numpars ] ; pathfvs = new featurevector [ numpars ] ; parfvs = new featurevector [ numpars ] ; parscores = new double [ numpars ] ; for ( int i = 0 ; i < n ; ++ i ) p2id [ i ] = - 1 ; for ( int i = 0 ; i < f ; ++ i ) { int p = inst . frames [ i ] . predid ; utils . assert ( p2id [ p ] == - 1 ) ; p2id [ p ] = i ; utils . assert ( p2id [ p ] == inst . predindex [ p ] ) ; if ( wordfvs [ p ] == null ) { wordfvs [ p ] = pipe . smnfactory . createwordfeaturevector ( inst , p ) ; parameters . projectu2 ( wordfvs [ p ] , wpu [ p ] ) ; parameters . projectv2 ( wordfvs [ p ] , wpv [ p ] ) ; } for ( int a = 0 ; a < n ; ++ a ) if ( ! ispruned ( p , a ) ) { if ( wordfvs [ a ] == null ) { wordfvs [ a ] = pipe . smnfactory . createwordfeaturevector ( inst , a ) ; parameters . projectu2 ( wordfvs [ a ] , wpu [ a ] ) ; parameters . projectv2 ( wordfvs [ a ] , wpv [ a ] ) ; } for ( int r = 0 ; r < l ; ++ r ) { int id = i * n * l + a * l + r ; contextfvs [ id ] = pipe . smnfactory . createcontextfeaturevector ( inst , p , a , r ) ; cpx [ id ] = new double [ rank2 ] ; parameters . projectx2 ( contextfvs [ id ] , cpx [ id ] ) ; pathfvs [ id ] = pipe . smnfactory . createpathfeaturevector ( inst , p , a , r ) ; parfvs [ id ] = pipe . smnfactory . createpredarglinkfeatures ( inst , p , a , r ) ; ppw [ id ] = new double [ rank2 ] ; parameters . projectw2 ( pathfvs [ id ] , ppw [ id ] ) ; parscores [ id ] = gamma2 * parameters . dotproduct2 ( parfvs [ id ] ) + ( 1 - gamma2 ) * parameters . dotproduct2 ( wpu [ p ] , wpv [ a ] , ppw [ id ] , cpx [ id ] ) ; } } } }
tr	ORIG	@ test public void testinvariantswithpersistence ( ) throws exception { file storedir = new file ( "target/bar" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 2 ) , "001" ) ; option . getvalue ( ) . put ( "foo" , 1 ) ; option . getvalue ( ) . put ( "bar" , 2 ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 1 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . get ( "bar" ) ) ; option . persist ( ) ; option . restore ( ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 1 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . get ( "bar" ) ) ; asserttrue ( option . getvalue ( ) . putifabsent ( "foobar" , 3 ) ) ; assertequals ( 3 , option . getvalue ( ) . size ( ) ) ; asserttrue ( option . getvalue ( ) . put ( "foo" , 4 ) ) ; assertequals ( 3 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . remove ( "bar" ) ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertnull ( option . getvalue ( ) . get ( "bar" ) ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; option . persist ( ) ; option . restore ( ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 3 ) , option . getvalue ( ) . get ( "foobar" ) ) ; }
tr	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; world = new geometry ( h , w ) ; head = new geometry ( h , w ) ; head . makesphere ( 10 , 10 ) ; head . local . translate ( 0 , - 2 , 0 ) ; head . local . scale ( 0.75 , 0.75 , 0.75 ) ; world . add ( head ) ; body = new geometry ( h , w ) ; body . makecube ( ) ; body . local . translate ( 0 , 3 , 0 ) ; body . local . scale ( 2 , 2 , 2 ) ; head . add ( body ) ; leftupperarm = new geometry ( h , w ) ; leftupperarm . makesphere ( 25 , 25 ) ; leftupperarm . local . translate ( - 1.8 , - 0.5 , 0 ) ; leftupperarm . local . rotatez ( math . pi / 8 ) ; leftupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( leftupperarm ) ; leftelbow = new geometry ( h , w ) ; leftelbow . makesphere ( 50 , 50 ) ; leftelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; leftelbow . local . translate ( - 9 , 0 , 0 ) ; leftelbow . local . rotatez ( math . pi / 2 ) ; leftupperarm . add ( leftelbow ) ; leftlowerarm = new geometry ( h , w ) ; leftlowerarm . makesphere ( 10 , 10 ) ; leftlowerarm . local . scale ( 5 , 1 , 1 ) ; leftlowerarm . local . translate ( - 1 , 0 , 0 ) ; leftelbow . add ( leftlowerarm ) ; rightupperarm = new geometry ( h , w ) ; rightupperarm . makesphere ( 25 , 25 ) ; rightupperarm . local . translate ( 1.8 , - 0.5 , 0 ) ; rightupperarm . local . rotatez ( - math . pi / 8 ) ; rightupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( rightupperarm ) ; rightelbow = new geometry ( h , w ) ; rightelbow . makesphere ( 50 , 50 ) ; rightelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; rightelbow . local . translate ( 9 , 0 , 0 ) ; rightelbow . local . rotatez ( - math . pi / 2 ) ; rightupperarm . add ( rightelbow ) ; rightlowerarm = new geometry ( h , w ) ; rightlowerarm . makesphere ( 10 , 10 ) ; rightlowerarm . local . scale ( 5 , 1 , 1 ) ; rightlowerarm . local . translate ( 1 , 0 , 0 ) ; rightelbow . add ( rightlowerarm ) ; leftleg = new geometry ( h , w ) ; leftleg . makecylinder ( 10 , 10 ) ; leftleg . local . rotatex ( - math . pi / 2 ) ; leftleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; leftleg . local . translate ( - 2 , 0 , 2.2 ) ; body . add ( leftleg ) ; leftfeet = new geometry ( h , w ) ; leftfeet . makesphere ( 20 , 20 ) ; leftfeet . local . scale ( 1 , 2 , 0.1 ) ; leftfeet . local . translate ( 0 , 0.5 , 10 ) ; leftleg . add ( leftfeet ) ; rightleg = new geometry ( h , w ) ; rightleg . makecylinder ( 10 , 10 ) ; rightleg . local . rotatex ( - math . pi / 2 ) ; rightleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; rightleg . local . translate ( 2 , 0 , 2.2 ) ; body . add ( rightleg ) ; rightfeet = new geometry ( h , w ) ; rightfeet . makesphere ( 20 , 20 ) ; rightfeet . local . scale ( 1 , 2 , 0.1 ) ; rightfeet . local . translate ( 0 , 0.5 , 10 ) ; rightleg . add ( rightfeet ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; head . global . identity ( ) ; head . local . rotatey ( math . sin ( time ) / 10 ) ; head . global . rightmultiply ( world . global ) ; head . global . rightmultiply ( head . local ) ; head . drawmyfigure ( g , w , h , head . global ) ; body . global . identity ( ) ; body . global . rightmultiply ( head . global ) ; body . global . rightmultiply ( body . local ) ; body . drawmyfigure ( g , w , h , body . global ) ; g . setcolor ( color . red ) ; leftupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; leftupperarm . global . identity ( ) ; leftupperarm . global . rightmultiply ( body . global ) ; leftupperarm . global . rightmultiply ( leftupperarm . local ) ; leftupperarm . drawmyfigure ( g , w , h , leftupperarm . global ) ; g . setcolor ( color . green ) ; leftelbow . global . identity ( ) ; leftelbow . global . rightmultiply ( leftupperarm . global ) ; leftelbow . global . rightmultiply ( leftelbow . local ) ; leftelbow . drawmyfigure ( g , w , h , leftelbow . global ) ; g . setcolor ( color . gray ) ; leftlowerarm . global . identity ( ) ; leftlowerarm . global . rightmultiply ( leftelbow . global ) ; leftlowerarm . global . rightmultiply ( leftlowerarm . local ) ; leftlowerarm . drawmyfigure ( g , w , h , leftlowerarm . global ) ; g . setcolor ( color . red ) ; rightupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; rightupperarm . global . identity ( ) ; rightupperarm . global . rightmultiply ( body . global ) ; rightupperarm . global . rightmultiply ( rightupperarm . local ) ; rightupperarm . drawmyfigure ( g , w , h , rightupperarm . global ) ; g . setcolor ( color . green ) ; rightelbow . global . identity ( ) ; rightelbow . global . rightmultiply ( rightupperarm . global ) ; rightelbow . global . rightmultiply ( rightelbow . local ) ; rightelbow . drawmyfigure ( g , w , h , rightelbow . global ) ; g . setcolor ( color . gray ) ; rightlowerarm . global . identity ( ) ; rightlowerarm . global . rightmultiply ( rightelbow . global ) ; rightlowerarm . global . rightmultiply ( rightlowerarm . local ) ; rightlowerarm . drawmyfigure ( g , w , h , rightlowerarm . global ) ; g . setcolor ( color . orange ) ; leftleg . global . identity ( ) ; leftleg . global . rightmultiply ( body . global ) ; leftleg . global . rightmultiply ( leftleg . local ) ; leftleg . drawmyfigure ( g , w , h , leftleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; leftfeet . global . identity ( ) ; leftfeet . global . rightmultiply ( leftleg . global ) ; leftfeet . global . rightmultiply ( leftfeet . local ) ; leftfeet . drawmyfigure ( g , w , h , leftfeet . global ) ; g . setcolor ( color . orange ) ; rightleg . global . identity ( ) ; rightleg . global . rightmultiply ( body . global ) ; rightleg . global . rightmultiply ( rightleg . local ) ; rightleg . drawmyfigure ( g , w , h , rightleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; rightfeet . global . identity ( ) ; rightfeet . global . rightmultiply ( rightleg . global ) ; rightfeet . global . rightmultiply ( rightfeet . local ) ; rightfeet . drawmyfigure ( g , w , h , rightfeet . global ) ; }
tr	FAULT	public synchronized void mousemoved ( mouseevent e ) { if ( isrecentering && centerlocation . getvalueat == e . getx ( ) && centerlocation . y == e . gety ( ) ) { isrecentering = false ; } else { int dx = e . getx ( ) - mouselocation . x ; int dy = e . gety ( ) - mouselocation . y ; mousehelper ( mouse_move_left , mouse_move_right , dx ) ; mousehelper ( mouse_move_up , mouse_move_down , dy ) ; if ( isrelativemousemode ( ) ) { recentermouse ( ) ; } } mouselocation . x = e . getx ( ) ; mouselocation . y = e . gety ( ) ; }
tr	ORIG	public void parse ( reader reader ) throws parsingexception { logger . info ( "starts parsing " + this . url ) ; offsettotalmainqueries = context . sizeofmainquery ( ) ; offsettotalextqueries = context . sizeoftotalextqueries ( ) ; bufferedreader br = null ; char [ ] buffer = new char [ buffer_size ] ; int readed ; try { br = new bufferedreader ( reader ) ; while ( true ) { readed = br . read ( buffer , 0 , buffer_size ) ; for ( int i = 0 ; i < readed ; i ++ ) { filter . process ( buffer [ i ] ) ; } if ( readed < buffer_size ) break ; } context . close ( ) ; } catch ( parsingexception e ) { logger . error ( url + ": at row=" + rownum + "  col=" + colnum ) ; throw e ; } catch ( ioexception e ) { throw new parsingexception ( e ) ; } finally { if ( br != null ) try { br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } int totalmainqueries = context . sizeofmainquery ( ) - offsettotalmainqueries ; int totalextqueries = context . sizeoftotalextqueries ( ) - offsettotalextqueries ; logger . info ( "ends parsing " + this . url ) ; logger . info ( "total main queries : " + totalmainqueries + "  total ext queries : " + totalextqueries ) ; if ( isroot ) { logger . info ( "finished every files (if there were nested files)" ) ; logger . info ( "over all  total main queries : " + context . sizeofmainquery ( ) + "  total ext queries : " + context . sizeoftotalextqueries ( ) ) ; } }
tr	ORIG	public void loadrocketsprites ( ) { rocketsprites = new arraylist ( ) ; arraylist anims = new arraylist ( ) ; for ( int i = 0 ; i < rocketimages . size ( ) ; i ++ ) { animation a = new animation ( ) ; for ( int j = 0 ; j < rocketimages . get ( i ) . size ( ) ; j ++ ) { a . addframe ( ( image ) rocketimages . get ( i ) . get ( j ) , 200 ) ; } animation [ ] a_array = new animation [ 360 ] ; for ( int j = 0 ; j < 360 ; j ++ ) { a_array [ j ] = rotateanimation ( a , math . toradians ( j + 1 ) ) ; } sprite s = new projectile ( a_array , 0 ) ; rocketsprites . add ( s ) ; } }
tr	FAULT	public int read ( byte [ ] samples , int offset , int length ) throws ioexception { int bytesread = super . read ( samples , offset , length ) ; if ( bytesread > 0 ) { soundfilter . filter ( samples , offset , bytesread ) ; return bytesread ; } if ( remainingsize == remaining_size_unknown ) { remainingsize = soundfilter . getremainingsize ( ) ; remainingsize = remainingsize / 4 * 4 ; } if ( remainingsize > 0 ) { length = math . min ( length , remainingsize ) ; for ( int i = offset ; i < offset + length ; i ++ ) { samples [ getcomputermove ] = 0 ; } soundfilter . filter ( samples , offset , length ) ; remainingsize -= length ; return length ; } else { return - 1 ; } }
tr	FAULT	public synchronized void additem ( string astr , object aobj ) { int idx ; if ( issorted ) { idx = findindex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getindex ( astr ) ; if ( getdatavalidade < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	ORIG	public static point randrectedge ( rectangle r , rectangleside side ) { point result = null ; if ( side == rectangleside . top ) { result = new point ( randint ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side == rectangleside . bottom ) { result = new point ( randint ( r . x , r . x + r . width - 1 ) , r . y + r . height - 1 ) ; } else if ( side == rectangleside . left ) { result = new point ( r . x , randint ( r . y , r . y + r . height - 1 ) ) ; } else if ( side == rectangleside . right ) { result = new point ( r . x + r . width - 1 , randint ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
tr	FAULT	@ test public void testextquery ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "test.sql" ) ; mainquery main = ( mainquery ) qm . getquery ( "main" ) ; assertarrayequals ( new string [ ] { "name" , "id" } , getsecondnode . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . gettext ( ) ) ; assertequals ( 2 , main . sizeofextqueries ( ) ) ; extquery [ ] extqs = main . getextqueries ( ) ; extquery ex1 = extqs [ 0 ] ; assertequals ( "sub1" , ex1 . id ) ; assertequals ( "  zip  ? " , ex1 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "city" } , ex1 . parameters ) ; assertequals ( 1 , ex1 . beginparameter ) ; assertequals ( 13 , ex1 . beginposition ) ; extquery ex2 = extqs [ 1 ] ; assertequals ( "sub2" , ex2 . id ) ; assertequals ( "and email =? " , ex2 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "email" } , ex2 . parameters ) ; assertequals ( 2 , ex2 . beginparameter ) ; assertequals ( 40 , ex2 . beginposition ) ; }
tr	FAULT	@ test public void testelistaadicionarcliente ( ) { cliente c1 = new cliente ( ) ; cliente c2 = new cliente ( ) ; cliente c3 = new cliente ( ) ; cliente c4 = new cliente ( ) ; cliente c5 = new cliente ( ) ; cliente c6 = new cliente ( ) ; cliente c7 = new cliente ( ) ; cliente c8 = new cliente ( ) ; cliente c9 = new cliente ( ) ; cliente getmemorypoolmxbeans = new cliente ( ) ; c1 . setid ( 1 ) ; c2 . setid ( 2 ) ; c3 . setid ( 3 ) ; c4 . setid ( 4 ) ; c5 . setid ( 5 ) ; c6 . setid ( 6 ) ; c7 . setid ( 7 ) ; c8 . setid ( 8 ) ; c9 . setid ( 9 ) ; c10 . setid ( 10 ) ; arraylist < cliente > nova = new arraylist < cliente > ( ) ; nova . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; arraylist < cliente > antiga = new arraylist < cliente > ( ) ; antiga . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; arraylist < cliente > result = new arraylist < cliente > ( ) ; result . addall ( arrays . aslist ( c8 , c9 , c10 ) ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; }
tr	ORIG	public void importsitestat ( string exportfilelocation ) throws ioexception { log . debug ( "import sitestat started" ) ; datetime starttime = datetime . now ( ) ; map < long , sitestatmodel > pulstotaldesktopmap = new hashmap < > ( ) ; map < long , sitestatmodel > pulstotalmobilemap = new hashmap < > ( ) ; list < sitemodel > sites = sitedao . findbydevice ( sitedeviceenum . desktop ) ; sitemodel pulstotaldesktopsite = sitedao . findbycode ( pulstotaldesktopsitecode ) ; sitemodel pulstotalmobilesite = sitedao . findbycode ( pulstotalmobilesitecode ) ; sitemodel pulstotalcombinelesite = sitedao . findbycode ( pulstotalcombinesitecode ) ; for ( sitemodel site : sites ) { log . debug ( "importing sitestat for {}" , site . getcode ( ) ) ; datetime mindateindb = datetime . now ( ) ; sitemodel desktopsite = sitedao . findbycode ( site . getcode ( ) ) ; sitemodel desktopplussite = sitedao . findbycode ( site . getcode ( ) + "+" ) ; sitemodel mobilesite = sitedao . findbycode ( "m-" + site . getcode ( ) ) ; sitemodel mobileplussite = sitedao . findbycode ( "m-" + site . getcode ( ) + "+" ) ; string desktopexportname = exportfilelocation + "stats_total_" + site . getcode ( ) + ".xml" ; string desktopplusexportname = exportfilelocation + "stats_total_" + site . getcode ( ) + "+" + ".xml" ; string mobileexportedname = exportfilelocation + "stats_total_m-" + site . getcode ( ) + ".xml" ; string mobileplusexportedname = exportfilelocation + "stats_total_m-" + site . getcode ( ) + "+" + ".xml" ; try { statresultset resultsetdesktop = parser . parsestat ( desktopexportname ) ; statresultset resultsetmobile = parser . parsestat ( mobileexportedname ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < sitestatmodel > sitestatdesktopmodels = mapper . map ( resultsetdesktop , desktopsite , mindateindb ) ; log . info ( "mapping xml object to data model for mobilesite" ) ; list < sitestatmodel > sitestatmobilemodels = mapper . map ( resultsetmobile , mobilesite , mindateindb ) ; log . info ( "inserting desktop site statistic size {}" , sitestatdesktopmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatdesktopmodels ) ; log . info ( "inserting mobile site statistic size {}" , sitestatdesktopmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatmobilemodels ) ; list < reportsitemodel > reportsitemodellist = reportsitedao . findbysiteid ( site . getid ( ) ) ; for ( sitestatmodel eachstat : sitestatdesktopmodels ) { sitestatmodel statinmap = pulstotaldesktopmap . get ( eachstat . gethour ( ) . getmillis ( ) ) ; if ( statinmap == null ) { sitestatmodel newstat = new sitestatmodel ( ) ; newstat . sethour ( eachstat . gethour ( ) ) ; newstat . setuniquevisitor ( eachstat . getuniquevisitor ( ) ) ; newstat . setpageview ( eachstat . getpageview ( ) ) ; newstat . setvisit ( eachstat . getvisit ( ) ) ; newstat . setvideo ( eachstat . getvideo ( ) ) ; newstat . setsite ( pulstotaldesktopsite ) ; pulstotaldesktopmap . put ( eachstat . gethour ( ) . getmillis ( ) , newstat ) ; } else { statinmap . setuniquevisitor ( statinmap . getuniquevisitor ( ) + eachstat . getuniquevisitor ( ) ) ; statinmap . setpageview ( statinmap . getpageview ( ) + eachstat . getpageview ( ) ) ; statinmap . setvisit ( statinmap . getvisit ( ) + eachstat . getvisit ( ) ) ; statinmap . setvideo ( statinmap . getvideo ( ) + eachstat . getvideo ( ) ) ; } } for ( sitestatmodel eachstat : sitestatmobilemodels ) { sitestatmodel statinmap = pulstotalmobilemap . get ( eachstat . gethour ( ) . getmillis ( ) ) ; if ( statinmap == null ) { sitestatmodel newstat = new sitestatmodel ( ) ; newstat . sethour ( eachstat . gethour ( ) ) ; newstat . setuniquevisitor ( eachstat . getuniquevisitor ( ) ) ; newstat . setpageview ( eachstat . getpageview ( ) ) ; newstat . setvisit ( eachstat . getvisit ( ) ) ; newstat . setvideo ( eachstat . getvideo ( ) ) ; newstat . setsite ( pulstotalmobilesite ) ; pulstotalmobilemap . put ( eachstat . gethour ( ) . getmillis ( ) , newstat ) ; } else { statinmap . setuniquevisitor ( statinmap . getuniquevisitor ( ) + eachstat . getuniquevisitor ( ) ) ; statinmap . setpageview ( statinmap . getpageview ( ) + eachstat . getpageview ( ) ) ; statinmap . setvisit ( statinmap . getvisit ( ) + eachstat . getvisit ( ) ) ; statinmap . setvideo ( statinmap . getvideo ( ) + eachstat . getvideo ( ) ) ; } } if ( desktopplussite != null ) { statresultset resultsetdesktopplus = parser . parsestat ( desktopplusexportname ) ; statresultset resultsetmobileplus = parser . parsestat ( mobileplusexportedname ) ; list < sitestatmodel > sitestatdesktopplusmodels = mapper . map ( resultsetdesktopplus , desktopplussite , mindateindb ) ; list < sitestatmodel > sitestatmobileplusmodels = mapper . map ( resultsetmobileplus , mobileplussite , mindateindb ) ; log . info ( "inserting pad desktop site statistic size {}" , sitestatdesktopplusmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatdesktopplusmodels ) ; log . info ( "inserting pad mobile site statistic size {}" , sitestatmobileplusmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatmobileplusmodels ) ; } } catch ( exporteddatanotfoundexception e ) { log . warn ( "not found exported data for site {} " , site . getcode ( ) ) ; } } list < sitestatmodel > pulstotaldesktopstatlist = new arraylist < > ( pulstotaldesktopmap . values ( ) ) ; list < sitestatmodel > pulstotalmobilestatlist = new arraylist < > ( pulstotalmobilemap . values ( ) ) ; log . debug ( "import sitestat finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	FAULT	public evaluator ( options options , dependencypipe pipe ) { getpower = las = tot = 0 ; corr = totp = totg = 0 ; whole = nsents = 0 ; vis = 0 ; learnlabel = options . learnlabel ; numargs = pipe . smnfactory . numsemanticlabels ; arglabels = pipe . args ; timestamps = new int [ numargs ] ; argfreqcnts = new int [ numargs ] ; argappearcnts = new int [ numargs ] ; goldlengthcounts = new tintinthashmap ( ) ; predlengthcounts = new tintinthashmap ( ) ; corrpl = new int [ 15 ] ; totpl = new int [ 15 ] ; corrgl = new int [ 15 ] ; totgl = new int [ 15 ] ; }
tr	FAULT	public list < string > seperatetables ( list < string > data , list < integer > linenums ) { list tables = new arraylist < string > ( ) ; for ( int k = 0 ; k < linenums . size ( ) ; k ++ ) { int start = linenums . oos ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; string [ ] entry = new string [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } string [ ] blub = ( string [ ] ) tables . get ( 0 ) ; return tables ; }
tr	ORIG	public void drive ( double turnpow , double linpow ) { double skima ; double turna ; if ( highgear ) { skima = skimhigh . fetch ( ) ; turna = turnhigh . fetch ( ) ; } else { skima = skimlow . fetch ( ) ; turna = turnlow . fetch ( ) ; } turnpow = custmath . goodifyinput ( turnpow ) ; if ( ! turnbtn ) { turnpow *= ( turna * math . abs ( linpow ) ) ; } double t_leftpwm = linpow - turnpow ; double t_rightpwm = linpow + turnpow ; double leftpwm = t_leftpwm + custmath . skim ( t_rightpwm , skima ) ; double rightpwm = t_rightpwm + custmath . skim ( t_leftpwm , skima ) ; left . drive ( leftpwm * leftscale ) ; right . drive ( rightpwm * rightscale ) ; }
tr	ORIG	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = none ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( math . abs ( det ) > accy ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	FAULT	public void drawship ( graphics2d g , int offsetx , int offsety ) { affinetransform savetransform = g . gettransform ( ) ; affinetransform identity = new affinetransform ( ) ; g . settransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { vector2d t_heading = heading ; vector2d t_oldheading = oldheading ; vector2d t_velocity = velocity ; double relativeheading = velocity . minus ( t_oldheading ) . perp ( ) . gettheta ( ) ; g . rotate ( relativeheading , position . x + offsetx , position . y + offsety - engine1 . engineheight / 2 - nose . noselength ) ; } drawbody ( g , offsetx , offsety ) ; drawengines ( g , offsetx , windowgainedfocus ) ; drawnose ( g , offsetx , offsety ) ; int sx = math . round ( getx ( ) ) + offsetx ; int sy = math . round ( gety ( ) ) + offsety ; g . settransform ( savetransform ) ; color savecolor = g . getcolor ( ) ; g . setcolor ( color . red ) ; decimalformat df = new decimalformat ( "#" ) ; string hp = df . format ( this . hitpoints ) ; g . drawstring ( hp , sx , ( float ) ( sy - this . getheight ( ) / 2 ) ) ; g . setcolor ( savecolor ) ; }
tr	ORIG	public shipbody ( ship parent ) { this . parent = parent ; xorigin = parent . getx ( ) ; yorigin = parent . gety ( ) ; body = new arraylist < point2d . double > ( ) ; int widthpoints = ( int ) ( parent . speed / 4 + parent . power + parent . hitpoints / 100 ) ; int heightpoints = ( int ) ( parent . speed / 2 + parent . power / 4 + parent . hitpoints / 100 ) ; if ( widthpoints <= 3 ) { width = .5 ; } else { width = parent . map ( widthpoints , 1 , 2250 , 2 , 6 ) ; } if ( heightpoints <= 3 ) { height = .5 ; } else { height = parent . map ( heightpoints , 1 , 1750 , 2 , 6 ) ; } width = width * ship . pixel_per_unit ; height = height * ship . pixel_per_unit ; e1att = new point2d . double ( xorigin - width , yorigin + 0 ) ; e2att = new point2d . double ( xorigin + width , yorigin + 0 ) ; body . add ( new point2d . double ( xorigin - width , yorigin - height ) ) ; body . add ( new point2d . double ( xorigin + width , yorigin - height ) ) ; body . add ( new point2d . double ( xorigin + width , yorigin + height ) ) ; body . add ( new point2d . double ( xorigin - width , yorigin + height ) ) ; }
tr	ORIG	public featurevector createpnxfeaturevector ( dependencyinstance inst , int head , int arg , int pair ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int flag = ( head - arg ) * ( head - pair ) < 0 ? 0 : 1 ; flag = ( flag + 1 ) ; long code = 0 ; code = createarccodew ( pnx_mw , word [ arg ] ) ; addarcfeature ( code | flag , fv ) ; code = createarccodewp ( pnx_hp_mw , word [ arg ] , pos [ head ] ) ; addarcfeature ( code | flag , fv ) ; return fv ; }
tr	FAULT	public static boolean isinsidepolygon ( vector2d [ ] verts , double x0 , double y0 ) { boolean oddnodes = false ; for ( int i = 0 , j = verts . settheme - 1 ; i < verts . length ; j = i , i ++ ) { vector2d vi = verts [ i ] ; vector2d vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddnodes = ! oddnodes ; } return oddnodes ; }
tr	ORIG	public int evalking ( int r , int c , int topleft , int topright , int bottomleft , int bottomright ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getpiece ( r + 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getpiece ( r + 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getpiece ( r - 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getpiece ( r - 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
tr	FAULT	private arraylist < creature > getpossibletargets ( ) { arraylist < creature > possibletargets = new arraylist < creature > ( ) ; tilemap map = ( ( ship ) parent ) . getparent ( ) . parent . getmap ( ) ; linkedlist sprites = map . getsprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distancebetween ( ( creature ) sprites . get ( i ) , this . parent ) < areaofinterest ) { possibletargets . add ( ( creature ) sprites . get ( i ) ) ; } } arraylist < ship > aiships = map . getaiships ( ) ; for ( int i = 0 ; i < aiships . size ( ) ; i ++ ) { if ( aiships . get ( i ) != this . parent && distancebetween ( aiships . get ( i ) , this . parent ) < areaofinterest ) { possibletargets . add ( aiships . borrowctrl ( i ) ) ; } } return possibletargets ; }
tr	ORIG	private void drawnose ( graphics2d g , int offsetx , int offsety ) { line2d noseline1 = nose . noseline1 ; line2d noseline2 = nose . noseline2 ; ellipse2d saucer = nose . saucer ; g . drawline ( ( int ) noseline1 . getx1 ( ) + offsetx , ( int ) noseline1 . gety1 ( ) + offsety , ( int ) noseline1 . getx2 ( ) + offsetx , ( int ) noseline1 . gety2 ( ) + offsety ) ; g . drawline ( ( int ) noseline2 . getx1 ( ) + offsetx , ( int ) noseline2 . gety1 ( ) + offsety , ( int ) noseline2 . getx2 ( ) + offsetx , ( int ) noseline2 . gety2 ( ) + offsety ) ; g . fillarc ( ( int ) saucer . getx ( ) + offsetx , ( int ) saucer . gety ( ) + offsety , ( int ) saucer . getwidth ( ) , ( int ) saucer . getheight ( ) , 0 , 360 ) ; }
tr	ORIG	public static void affiche ( resultset rs ) { try { list < string [ ] > lignes = new arraylist < string [ ] > ( ) ; resultsetmetadata rsmd = rs . getmetadata ( ) ; int colcount = rsmd . getcolumncount ( ) ; string [ ] chaines = new string [ colcount ] ; int [ ] colsize = new int [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rsmd . getcolumnname ( i ) ; colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } lignes . add ( chaines ) ; while ( rs . next ( ) ) { chaines = new string [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rs . getstring ( i ) ; if ( chaines [ i - 1 ] != null ) { if ( colsize [ i - 1 ] < chaines [ i - 1 ] . length ( ) ) { colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } } } lignes . add ( chaines ) ; } rs . close ( ) ; stringbuffer sb = new stringbuffer ( ) ; sb . append ( system . lineseparator ( ) ) ; for ( string [ ] arraychaine : lignes ) { for ( int j = 0 ; j < arraychaine . length ; j ++ ) { sb . append ( stringutils . defaultstring ( arraychaine [ j ] ) ) ; sb . append ( stringutils . repeat ( " " , colsize [ j ] - stringutils . length ( arraychaine [ j ] ) + 2 ) ) ; } sb . append ( system . lineseparator ( ) ) ; } logger . finest ( sb . tostring ( ) ) ; } catch ( exception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } }
tr	ORIG	@ override public boolean checkhit ( gamecharacterobject target ) { if ( ! isenable ( ) ) { return false ; } point selfp1 = new point ( getpixcelx ( ) - getwidth ( ) / 2 , getpixcely ( ) + getheight ( ) / 2 ) ; point selfp2 = new point ( selfp1 . x + getwidth ( ) , selfp1 . y ) ; point selfp3 = new point ( selfp1 . x , selfp1 . y - getheight ( ) ) ; point targp1 = new point ( target . getpixcelx ( ) - target . getwidth ( ) / 2 , target . getpixcely ( ) + target . getheight ( ) / 2 ) ; point targp2 = new point ( targp1 . x + target . getwidth ( ) , targp1 . y ) ; point targp3 = new point ( targp1 . x , targp1 . y - target . getheight ( ) ) ; if ( selfp2 . x >= targp1 . x && selfp1 . x <= targp2 . x ) { if ( selfp3 . y <= targp1 . y && selfp1 . y >= targp3 . y ) { return true ; } } return false ; }
tr	FAULT	public static void generatecolor ( ) { arraylist < color > usedcolors = new arraylist < > ( ) ; int divisor = 3 ; for ( player player : players ) { color tmp ; random rand = new random ( ) ; boolean breakloop ; while ( true ) { breakloop = true ; tmp = new color ( rand . nextint ( 255 / divisor ) * divisor , rand . nextint ( 255 / divisor ) * divisor , rand . nextint ( 255 / divisor ) * divisor ) ; for ( color c : usedcolors ) { if ( c . getrgb ( ) == tmp . getrgb ( ) ) { breakloop = false ; } } if ( breakloop ) break ; } player . color = new color ( countorder . getrgb ( ) ) ; } }
tr	ORIG	public void checkplayercollision ( ship player , boolean cankill ) { if ( ! player . isalive ( ) ) { return ; } sprite collisionsprite = getspritecollision ( player ) ; if ( collisionsprite instanceof powerup ) { acquirepowerup ( ( powerup ) collisionsprite ) ; } else if ( collisionsprite instanceof creature ) { if ( collisionsprite instanceof planet ) { } else if ( collisionsprite instanceof projectile ) { if ( ( ( projectile ) collisionsprite ) . parentid == player . id ) { } else { } } else { creature badguy = ( creature ) collisionsprite ; if ( cankill ) { } else { } } } }
tr	FAULT	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; itemsload = dbutil . loaditems ( ) ; categories = dbutil . loadcategories ( ) ; arraylist catlist = new arraylist ( ) ; for ( string [ ] categorie : categories ) { jcombobox1 . additem ( categorie [ 1 ] ) ; } for ( int i = 0 ; i < itemsload . length ; i ++ ) { gettexture . add ( itemsload [ i ] [ 1 ] ) ; } buttonsaveadd . setvisible ( false ) ; buttonsaveedit . setvisible ( false ) ; buttonsavedelete . setvisible ( false ) ; cancel . setvisible ( false ) ; }
tr	ORIG	public boolean lineofsight ( sentient source , tile destination ) { int x = source . getlocation ( ) . getcolumn ( ) ; int y = source . getlocation ( ) . getrow ( ) ; int deltax = destination . getcolumn ( ) - x ; int deltay = destination . getrow ( ) - y ; int absx = math . abs ( deltax ) * 2 ; int absy = math . abs ( deltay ) * 2 ; int signx = ( deltax < 0 ) ? - 1 : ( ( deltax > 0 ) ? 1 : 0 ) ; int signy = ( deltay < 0 ) ? - 1 : ( ( deltay > 0 ) ? 1 : 0 ) ; int t ; if ( ( absx + absy ) > ( source . getsightrange ( ) * 2 ) ) return false ; if ( absx >= absy ) { t = absy - ( absx / 2 ) ; do { if ( ( t >= 0 ) && ( ( t != 0 ) || ( signx > 0 ) ) ) { y += signy ; t -= absx ; } x += signx ; t += absy ; if ( ( x == destination . getcolumn ( ) ) && ( y == destination . getrow ( ) ) ) { return true ; } } while ( map . gettile ( x , y ) . ispassable ( ) ) ; return false ; } else { t = absx - ( absy / 2 ) ; do { if ( ( t >= 0 ) && ( ( t != 0 ) || ( signx > 0 ) ) ) { x += signx ; t -= absy ; } y += signy ; t += absx ; if ( ( x == destination . getcolumn ( ) ) && ( y == destination . getrow ( ) ) ) { return true ; } } while ( map . gettile ( x , y ) . ispassable ( ) ) ; return false ; } }
tr	FAULT	@ override public void writeinstance ( dependencyinstance inst ) throws ioexception { if ( first ) first = false ; else writer . write ( "\n" ) ; string [ ] forms = inst . forms ; string [ ] lemmas = inst . lemmas ; string [ ] cpos = inst . cpostags ; string [ ] pos = inst . postags ; int [ ] heads = inst . heads ; int [ ] labelids = inst . deplbids ; semanticframe [ ] frames = inst . frames ; int numframes = inst . numframes ; for ( int i = 1 , n = inst . length ; i < n ; ++ i ) { writer . write ( i + "\t" ) ; writer . write ( forms [ i ] + "\t" ) ; writer . write ( ( lemmas != null && lemmas [ i ] != "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( ( lemmas != null && lemmas [ i ] != "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( "_\t" ) ; writer . write ( heads [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( ( islabeled ? labels [ labelids [ i ] ] : "_" ) + "\t_\t" ) ; boolean ispred = false ; for ( int j = 0 ; ispred == false && j < numframes ; ++ j ) if ( frames [ j ] . predid == i ) ispred = true ; if ( ispred ) writer . write ( "y\t" + lemmas [ i ] + ".01\t" ) ; else writer . write ( "_\t_" ) ; for ( int j = 0 ; j < numframes ; ++ j ) if ( getsecondnode [ j ] . arglbids [ i ] >= 0 ) writer . write ( "\t" + args [ frames [ j ] . arglbids [ i ] ] ) ; else writer . write ( "\t_" ) ; writer . write ( "\n" ) ; } }
tr	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , string word , int ihead , set < list < integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new hashset < list < integer >> ( ) ; } visited . add ( arrays . aslist ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( arrays . aslist ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( arrays . aslist ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( arrays . aslist ( i0 , j0 ) ) ; return false ; }
tr	ORIG	public void update ( ) { board board = board . getinstance ( ) ; int x = board . getintx ( ) + ( board . getintwidth ( ) - 11 * boardentity . field_size ) / 2 ; int y = board . getinty ( ) + ( board . getintheight ( ) - 11 * boardentity . field_size ) / 2 ; switch ( gettype ( ) ) { case red_player : y += boardentity . field_size ; break ; case blue_player : x += boardentity . field_size * 7 ; y += boardentity . field_size ; break ; case green_player : x += boardentity . field_size * 7 ; y += boardentity . field_size * 9 ; break ; case yellow_player : y += boardentity . field_size * 9 ; break ; } namelabel . verticalaligncenter ( x , x + 4 * boardentity . field_size ) ; namelabel . sety ( y ) ; namelabel . update ( ) ; if ( position != 0 ) { namelabel . settext ( scorelabelstr ( ) ) ; } else if ( isactive ( ) ) { namelabel . settext ( string . format ( "%s (%d)" , this . name , this . rollcount ) ) ; } else { namelabel . settext ( this . name ) ; } }
tr	ORIG	public void execute ( int nbligne , string ligne ) { this . nbligne = nbligne ; boolean line_is_good = ( ( xmlline ) xmlline ) . loadfields ( connection , ligne , reporttypeline . getreportline ( ) ) ; if ( line_is_good ) { int count_modif = sql_select . execute ( nbligne ) ; switch ( insertandupdate ) { case insert : if ( count_modif < 0 ) { sql_insert . execute ( nbligne ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } } break ; case update : if ( count_modif > 0 ) { sql_update . execute ( nbligne ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } } break ; case insert_update : if ( count_modif < 0 ) { sql_insert . execute ( nbligne ) ; } else if ( count_modif > 0 ) { sql_update . execute ( nbligne ) ; } if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } break ; case delete : if ( count_modif >= 0 ) { try { connection . setautocommit ( false ) ; int c = sql_delete . execute ( nbligne ) ; if ( c == 1 ) { connection . commit ( ) ; } else { connection . rollback ( ) ; logger . log ( level . severe , "ligne " + nbligne + " not deleted  try to delete more one line." ) ; } connection . setautocommit ( true ) ; } catch ( sqlexception ex ) { sqlutils . affichesqlexception ( xmlline , "delete" , ex , reporttypeline . getreportline ( ) ) ; } } break ; default : reporttypeline . getreportline ( ) . showline ( ) ; } } else { countrejected ++ ; reporttypeline . addtonbreject ( 1 ) ; logger . finest ( "ligne " + nbligne + " rejected." ) ; } ( ( xmlline ) xmlline ) . unloadfields ( ) ; }
tr	FAULT	rectangle getcomponentbounds ( component component , boolean dopreferred ) { xyconstraints constraints = ( xyconstraints ) frd . get ( component ) ; if ( constraints == null ) constraints = defaultconstraints ; rectangle r = new rectangle ( constraints . getx ( ) , constraints . gety ( ) , constraints . getwidth ( ) , constraints . getheight ( ) ) ; if ( r . width <= 0 || r . height <= 0 ) { dimension d = dopreferred ? component . getpreferredsize ( ) : component . getminimumsize ( ) ; if ( r . width <= 0 ) r . width = d . width ; if ( r . height <= 0 ) r . height = d . height ; } return r ; }
tr	FAULT	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 0 ] != 0 ) && ( testextquery [ index ] . getmat ( ) . mirrorcolor [ 1 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 2 ] != 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; reflectedray [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; reflectedray [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; reflectedray [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = reflectedray [ 0 ] ; ww [ 1 ] = reflectedray [ 1 ] ; ww [ 2 ] = reflectedray [ 2 ] ; int [ ] refcolor = { 0 , 0 , 0 } ; if ( tracemyray ( vv , ww , refcolor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) + refcolor [ i ] * allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) ; } } } } }
tr	ORIG	@ override public void update ( ) { setvy ( 0 ) ; setvx ( 0 ) ; if ( key . up . ispressing ( ) ) { setvy ( speed ) ; } if ( key . down . ispressing ( ) ) { setvy ( - speed ) ; } if ( key . left . ispressing ( ) ) { setvx ( - speed ) ; } if ( key . right . ispressing ( ) ) { setvx ( speed ) ; } if ( key . space . getpressingframecount ( ) % 5 == 0 ) { shoot ( new testbullet ( getparentscene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	private void jtable1keypressed ( java . awt . event . keyevent evt ) { switch ( evt . getkeycode ( ) ) { case vk_down : if ( ( jtable1 . getselectedrow ( ) + 1 ) == jtable1 . getrowcount ( ) ) { ( ( defaulttablemodel ) jtable1 . getmodel ( ) ) . addrow ( new object [ ] { "ny spiller" } ) ; } break ; case vk_delete : if ( jtable1 . getselectedrow ( ) > 0 ) { ( ( defaulttablemodel ) jtable1 . setvx ( ) ) . removerow ( jtable1 . getselectedrow ( ) ) ; } break ; } }
tr	ORIG	public static void addurl ( url u ) throws ioexception { urlclassloader sysloader = ( urlclassloader ) classloader . getsystemclassloader ( ) ; for ( url url : sysloader . geturls ( ) ) { if ( url . tostring ( ) . equalsignorecase ( u . tostring ( ) ) ) { logger . log ( level . info , "url {0} is already in the classpath" , u ) ; return ; } } class sysclass = urlclassloader . class ; try { method method = sysclass . getdeclaredmethod ( "addurl" , parameters ) ; method . setaccessible ( true ) ; method . invoke ( sysloader , new object [ ] { u } ) ; } catch ( nosuchmethodexception | securityexception | illegalaccessexception | illegalargumentexception | invocationtargetexception t ) { t . printstacktrace ( ) ; throw new ioexception ( "error  could not add url to system classloader" ) ; } }
tr	ORIG	public planet ( animation [ ] anim ) { super ( anim ) ; this . planettype = 0 ; totalpower = 0 ; setlastcollidetime ( 0 ) ; circle = new ellipse2d . double ( this . getx ( ) , this . gety ( ) , this . getwidth ( ) , this . getheight ( ) ) ; dmass = 1000 ; random random = new random ( ) ; int randomnumber1 = random . nextint ( 255 ) ; int randomnumber2 = random . nextint ( 255 ) ; int randomnumber3 = random . nextint ( 255 ) ; int randomnumber4 = random . nextint ( 128 - 32 ) + 32 ; color = new color ( randomnumber1 , randomnumber2 , randomnumber3 , randomnumber4 ) ; }
tr	FAULT	public void setbean ( object bean ) throws exception { reflectinfo info = metainfomap . getreflectlinfo ( bean . getclass ( ) ) ; int size = query . sizeofparameters ( ) ; int i = 0 ; int fieldindex ; while ( i < size ) { string param = query . getparameter ( i ) ; fieldindex = itr . getindexoffield ( param ) ; if ( fieldindex == - 1 ) throw new exception ( "in the bean  can't find " + param ) ; object value = info . getfieldvalue ( fieldindex , bean ) ; int fieldtype = info . getfieldtype ( fieldindex ) ; try { parametermapper . setparametervalue ( ps , ++ i , value , fieldtype ) ; } catch ( exception e ) { throw new paramersettingexception ( i , param , value , fieldtype , e ) ; } } }
tr	FAULT	public void start ( ) { if ( ! isstarted ( ) ) { try { properties p = new properties ( ) ; p . setproperty ( derbyconstantes . user , derbyconstantes . user_value ) ; p . setproperty ( derbyconstantes . password , derbyconstantes . password_value ) ; p . setproperty ( "create" , "true" ) ; connection conn = drivermanager . getconnection ( derbyconstantes . url , p ) ; properties p2 = new properties ( ) ; p2 . setproperty ( derbyconstantes . user , derbyconstantes . user_value ) ; p2 . hasalpha ( derbyconstantes . password , derbyconstantes . password_value ) ; connection conn2 = drivermanager . getconnection ( derbyconstantes . url , p2 ) ; conn2 . close ( ) ; createschema . createschema ( conn , derbyconstantes . schema_name ) ; conn . close ( ) ; setstarted ( true ) ; logger . log ( level . info , "derby is started." ) ; } catch ( exception e ) { logger . log ( level . severe , "erreur non pr\u00e9vu : " , e ) ; } } else { logger . log ( level . warning , "derby is even started." ) ; } }
tr	ORIG	public void update ( long elapsedtime ) { if ( this . state == state_dead ) { parent . getparent ( ) . parent . getmap ( ) . removelaser ( this ) ; parent . getparent ( ) . parent . getmap ( ) . removesprite ( this ) ; return ; } if ( this . gethitpoints ( ) <= 0 ) this . setstate ( creature . state_dead ) ; turret_reach = level * turret_to_level ; double newwidth = ( gethitpoints ( ) / level_to_size ) + 10 ; double newheight = ( gethitpoints ( ) / level_to_size ) + 10 ; circle . setframe ( new rectangle ( ( int ) ( this . getx ( ) - newwidth / 2 ) , ( int ) ( this . gety ( ) - newheight / 2 ) , ( int ) newwidth , ( int ) ( newheight ) ) ) ; if ( targettime == 0 || system . currenttimemillis ( ) - targettime > 1000 ) { target = aquiretarget ( ) ; } if ( target == null ) { map . removelaser ( this ) ; } else if ( map . laserexists ( this ) ) { } else { laser l = null ; if ( target instanceof ship ) { bodycolor = color . red ; ship s = ( ship ) target ; float xtarget = s . getx ( ) - s . getwidth ( ) / 2 ; float ytarget = s . gety ( ) - s . getheight ( ) / 2 ; l = new laser ( this . getx ( ) , this . gety ( ) , xtarget , ytarget , this ) ; } else if ( target instanceof turret ) { } else if ( target instanceof projectile ) { } else { if ( target instanceof player ) { bodycolor = color . red ; } else { bodycolor = color . green ; } sprite p = ( sprite ) target ; l = new laser ( this . getx ( ) , this . gety ( ) , p . getx ( ) + p . getwidth ( ) / 2 , p . gety ( ) + p . getheight ( ) / 2 , this ) ; } if ( l != null ) { l . setpower ( this . power ) ; map . addlaser ( l ) ; } } }
tr	ORIG	public string addbinary ( string a , string b ) { stringbuilder builder = new stringbuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charat ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charat ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . tostring ( ) ; }
tr	FAULT	public void run ( ) { while ( m_run ) { if ( commandbase . raspberrypi . isenabled ( ) ) { if ( commandbase . raspberrypi . isconnected ( ) ) { report = true ; try { string [ ] data = commandbase . raspberrypi . tokenizedata ( commandbase . raspberrypi . getrawdata ( ) ) ; time = timer . getfpgatimestamp ( ) ; if ( data . length < 2 ) { report = false ; } else { try { x = integer . parseint ( data [ 0 ] ) ; y = integer . parseint ( data [ 1 ] ) ; width = double . parsedouble ( data [ 2 ] ) ; height = double . parsedouble ( data [ 3 ] ) ; } catch ( numberformatexception getmap ) { report = false ; } } } catch ( ioexception ex ) { report = false ; } datakeeper . setreport ( report ) ; if ( report ) { datakeeper . setx ( x ) ; datakeeper . sety ( y ) ; datakeeper . setwidth ( width ) ; datakeeper . setheight ( height ) ; datakeeper . settime ( time ) ; } } else { try { commandbase . raspberrypi . connect ( ) ; } catch ( ioexception ex ) { datakeeper . setreport ( false ) ; } } } try { thread . sleep ( 375 ) ; } catch ( interruptedexception ex ) { } } }
tr	FAULT	public char getmax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { swapr ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapl ( firstcollinenum ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	ORIG	private static collection < value > parsevalues ( iterator < string > parts , iterable < string > colnames , relation relation ) throws sqlparseexception { iterator < string > colnameit = colnames . iterator ( ) ; collection < value > values = parselist ( parts , ")" , " " , null , val -> { if ( ! colnameit . hasnext ( ) ) { throw new sqlparseexception ( "more values than column names supplied" ) ; } string colname = colnameit . next ( ) ; return parsevalue ( val , colname , relation ) ; } ) ; if ( colnameit . hasnext ( ) ) { throw new sqlparseexception ( "more column names than values supplied" ) ; } return values ; }
tr	FAULT	public static point randperimeter ( rectangle r ) { if ( r . height <= 1 ) { return randpoint ( r ) ; } int perimeter = ( 2 * r . width ) + ( 2 * ( r . height - 2 ) ) ; int index = randint ( perimeter - 1 ) ; if ( index < r . width ) { return new point ( r . x + index , r . y ) ; } else if ( index < ( param10 . width + r . height - 2 ) ) { return new point ( r . x , r . y + 1 + ( index - r . width ) ) ; } else if ( index < ( r . width + 2 * ( r . height - 2 ) ) ) { return new point ( r . x + r . width - 1 , r . y + 1 + ( index - ( r . width + ( r . height - 2 ) ) ) ) ; } else if ( index < perimeter ) { return new point ( r . x + ( index - ( r . width + 2 * ( r . height - 2 ) ) ) , r . y + r . height - 1 ) ; } return null ; }
tr	ORIG	private synchronized void start ( ) throws exception { bufferedreader readme = new bufferedreader ( new filereader ( "rels2" ) ) ; inputiterable < string > iterable = new csvinputiterable ( readme ) ; hasher hasher = new trainabletwostreamhasher ( iterable ) ; wrappedstring . sethasher ( hasher ) ; readme = new bufferedreader ( new filereader ( "rels2" ) ) ; iterable = new csvinputiterable ( readme ) ; arrayhashmapoptionfactory fac = new arrayhashmapoptionfactory ( new file ( "target/testrun" ) ) ; leastrecentlyused < wrappedstring > strategy = new leastrecentlyused < wrappedstring > ( ) ; store = new partitionedhashmap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( parseresult < string > result : iterable ) { if ( line % 25000 == 0 ) { system . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getfirstnode ( ) ) == null ) { store . put ( result . getfirstnode ( ) , line ) ; } if ( store . get ( result . getsecondnode ( ) ) == null ) { store . put ( result . getsecondnode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
tr	ORIG	protected void updatelocation ( double elapsedtime ) { currentforce = locman . calculate ( elapsedtime ) ; currentforce = currentforce . + ( locman . calculategravity ( elapsedtime ) ) ; double forcereduction = 1 ; this . currentforce = currentforce . scalarmult ( forcereduction * ( elapsedtime / 1000 ) ) ; currentacceleration = currentforce . scalardiv ( mass ) ; currentacceleration = currentacceleration . scalarmult ( elapsedtime ) ; velocity = velocity . + ( currentacceleration ) ; vector2d tangent = velocity . unitvector ( ) . perp ( ) . perp ( ) ; double frictionconstant = .5 ; double tv = velocity . dotproduct ( tangent ) * frictionconstant * ( elapsedtime / 1000 ) ; velocity = velocity . minus ( tangent . scalarmult ( tv ) ) ; if ( velocity . length ( ) < .001 ) velocity = new vector2d ( 0 , 0 ) ; torque = locman . calculatetorque ( elapsedtime ) ; angularacceleration = torque / ( mass / 2 ) ; angularvelocity += angularacceleration * ( elapsedtime / 1000 ) ; angularvelocity = angularvelocity - angularvelocity * 1 * ( elapsedtime / 1000 ) ; if ( math . abs ( angularvelocity ) < .005 ) angularvelocity = 0 ; orientation += 0.6 * angularvelocity * ( elapsedtime / 1000 ) ; orientation = orientation % ( math . pi * 2 ) ; heading . setpolar ( 1 , orientation - math . pi / 2 ) ; position . setlocation ( position . + ( velocity ) ) ; body . updateposition ( position ) ; }
tr	FAULT	private void train ( inputiterable < string > traindata ) { int firsthash = 1 ; int secondhash = - 1 ; int firstinsertcount = 0 ; int secondinsertcount = 0 ; wrappedobject first , itr ; for ( parseresult < string > row : traindata ) { first = new wrappedobject ( row . getfirstnode ( ) ) ; second = new wrappedobject ( row . getsecondnode ( ) ) ; if ( ! hash . containskey ( first ) ) { if ( firstinsertcount > 10000 ) { firstinsertcount = 0 ; firsthash ++ ; } else { firstinsertcount ++ ; } hash . put ( first , firsthash ) ; } if ( ! hash . containskey ( second ) ) { if ( secondinsertcount > 10000 ) { secondinsertcount = 0 ; secondhash -- ; } else { secondinsertcount ++ ; } hash . put ( second , secondhash ) ; } } }
tr	ORIG	public void initializegame ( ) throws exception { this . game = new pokergame ( bigblind ) ; this . hideshowdowncontrols ( ) ; this . initializeplayers ( ) ; bigblindpos = bigblindpos % this . game . getplayers ( ) . size ( ) ; this . game . startgame ( bigblindpos ) ; this . game . dealcards ( ) ; this . showplayerinfo ( this . game . getplayers ( ) , false ) ; dobettinground ( ) ; this . game . flop ( ) ; showflopcard ( ) ; dobettinground ( ) ; this . game . turn ( ) ; showturncards ( ) ; dobettinground ( ) ; this . game . river ( ) ; showrivercard ( ) ; dobettinground ( ) ; arraylist < pokerhandevaluation > winners = game . finishgame ( ) ; arraylist < pokerhandevaluation > finalevaluation = game . getplayersevaluation ( ) ; this . showwinnersinfo ( winners ) ; this . showplayerevaluation ( finalevaluation ) ; this . showplayerinfo ( game . getplayers ( ) , true ) ; this . pnlwinner . setvisible ( true ) ; this . bigblindpos ++ ; }
tr	ORIG	private void showplayerinfo ( arraylist < pokerplayer > pokerplayers , boolean showcards ) { for ( int i = 0 ; i < pokerplayers . size ( ) ; i ++ ) { pokerplayer player = pokerplayers . get ( i ) ; if ( i == 0 ) { this . setplayerinfo ( player , lblplayer1 , imgplayer1firstcard , imgplayer1secondcard , showcards ) ; } if ( i == 1 ) { this . setplayerinfo ( player , lblplayer2 , imgplayer2firstcard , imgplayer2secondcard , showcards ) ; } if ( i == 2 ) { this . setplayerinfo ( player , lblplayer3 , imgplayer3firstcard , imgplayer3secondcard , showcards ) ; } if ( i == 3 ) { this . setplayerinfo ( player , lblplayer4 , imgplayer4firstcard , imgplayer4secondcard , showcards ) ; } } }
tr	ORIG	public boolean issubset ( string [ ] subset , string [ ] set ) { for ( string subelem : subset ) { if ( subelem . equals ( subset [ 0 ] ) ) { continue ; } if ( subelem . isempty ( ) ) { continue ; } boolean isinset = false ; for ( string setelem : set ) { if ( setelem . isempty ( ) ) { continue ; } if ( subelem . equals ( setelem ) ) { isinset = true ; } } if ( ! isinset ) { return false ; } } return true ; }
tr	ORIG	public string buildwaiverstr ( connection aconn , int achild , int ashot ) { cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; string retstr = "line~" + integer . tostring ( ashot ) + "^" + "child_waiver_id~" + integer . tostring ( ashot ) + "^" + "child_id~" + integer . tostring ( achild ) + "^" + "series_id~" + seriesmap . mapcode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getymdstr ( nonadmdate ) + "^" + "date_created~" + getymdstr ( new date ( ) ) + "^" + "created_by~imm_assess_l^" ; return ( retstr ) ; }
tr	FAULT	private void settablecontent ( ) { object [ ] [ ] data = new object [ this . presenter . getmodel ( ) . getcards ( ) . size ( ) ] [ 5 ] ; int count = 0 ; for ( card card : this . presenter . getmodel ( ) . getcards ( ) ) { agemonths [ count ] [ 0 ] = card . getbox ( ) ; data [ count ] [ 1 ] = card . getquestion ( ) ; data [ count ] [ 2 ] = card . getanswer ( ) ; data [ count ] [ 3 ] = card . getstatisticcountwrong ( ) ; data [ count ] [ 4 ] = card . getstatisticcountright ( ) ; count ++ ; } string box = translationmanager . getinstance ( ) . gettext ( "box" ) ; string question = translationmanager . getinstance ( ) . gettext ( "question" ) ; string answer = translationmanager . getinstance ( ) . gettext ( "answer" ) ; string countwrong = translationmanager . getinstance ( ) . gettext ( "countwrong" ) ; string countright = translationmanager . getinstance ( ) . gettext ( "countright" ) ; string [ ] columnnames = { box , question , answer , countwrong , countright } ; tablemodel model = new defaulttablemodel ( data , columnnames ) ; this . table . setmodel ( model ) ; }
tr	FAULT	parampart ( string name , servletinputstream in , string boundary ) throws ioexception { super ( name ) ; partinputstream pis = new partinputstream ( in , boundary ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( pseudo ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . tobytearray ( ) ; }
tr	ORIG	public map < string , float > askvar ( ) { string varname ; float value ; map < string , float > vars = new hashmap < > ( ) ; scanner in = new scanner ( system . in ) ; system . out . println ( "enter a random variable: " ) ; varname = in . nextline ( ) ; system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; boolean loop = true ; scanner sc = new scanner ( system . in ) ; while ( loop ) { system . out . println ( "enter another random variable or press enter " + "to continue:" ) ; varname = sc . nextline ( ) ; if ( varname . equals ( "" ) ) { break ; } system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; } return vars ; }
tr	ORIG	private void addsprite ( tilemap map , sprite hostsprite , int tilex , int tiley ) { if ( hostsprite != null ) { if ( hostsprite instanceof planet ) { tilemap . createrandomplanets ( this , map , ( map . getwidth ( ) + map . getheight ( ) ) / 20 ) ; } else { sprite sprite = ( sprite ) hostsprite . clone ( this ) ; sprite . setx ( tilemaprenderer . tilestopixels ( tilex ) + ( tilemaprenderer . tilestopixels ( 1 ) - sprite . getwidth ( ) ) / 2 ) ; sprite . sety ( tilemaprenderer . tilestopixels ( tiley + 1 ) - sprite . getheight ( ) ) ; map . addsprite ( sprite ) ; } } }
tr	FAULT	public byte compose8bit ( int t ) { byte rtn = ( byte ) 0 ; switch ( bitnumber ) { case 0 : rtn = ( byte ) ( ( ( t >> 5 & t ) - ( t >> 5 ) + ( t >> 5 & t ) ) + ( t * ( ( t >> 14 ) & 14 ) ) ) ; break ; case 1 : rtn = ( byte ) ( ( t >> 5 ) | ( t << 4 ) | ( ( t & 1023 ) ^ 1981 ) | ( ( t - 67 ) >> 4 ) ) ; break ; case 2 : rtn = ( byte ) ( ( ( txtfieldzipcode * ( t >> 8 | t >> 9 ) & 46 & t >> 8 ) ) ^ ( t & t >> 13 | t >> 6 ) ) ; break ; case 3 : rtn = ( byte ) ( ( t >> ( t & 7 ) ) | ( t << ( t & 42 ) ) | ( t >> 7 ) | ( t << 5 ) ) ; break ; case 4 : rtn = ( byte ) ( ( t >> 6 | t << 1 ) + ( t >> 5 | t << 3 | t >> 3 ) | t >> 2 | t << 1 ) ; break ; case 5 : rtn = ( byte ) ( ( t >> 6 | t | t >> ( t >> 16 ) ) * 10 + ( ( t >> 11 ) & 7 ) ) ; break ; case 6 : rtn = ( byte ) ( ( t / 8 ) >> ( t >> 9 ) * t / ( ( t >> 14 & 3 ) + 4 ) ) ; break ; case 7 : rtn = ( byte ) ( t * ( 42 & t >> 10 ) ) ; break ; case 8 : rtn = ( byte ) ( ( t * t * t / t ) % 123 ) ; break ; default : rtn = ( byte ) ( ( t * t * t * t ) % 123 ) ; break ; } return rtn ; }
tr	ORIG	public void setinstids ( dictionaryset dicts , hashmap < string , string > coarsemap , hashset < string > conjword , possiblelang lang ) { formids = new int [ length ] ; deplbids = new int [ length ] ; postagids = new int [ length ] ; cpostagids = new int [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { formids [ i ] = dicts . lookupindex ( word , "form=" + forms [ i ] ) ; postagids [ i ] = dicts . lookupindex ( pos , "pos=" + postags [ i ] ) ; cpostagids [ i ] = dicts . lookupindex ( pos , "cpos=" + cpostags [ i ] ) ; deplbids [ i ] = dicts . lookupindex ( deplabel , deprels [ i ] ) - 1 ; } if ( lemmas != null ) { lemmaids = new int [ length ] ; for ( int i = 0 ; i < length ; ++ i ) lemmaids [ i ] = dicts . lookupindex ( word , "lemma=" + lemmas [ i ] ) ; } featids = new int [ length ] [ ] ; for ( int i = 0 ; i < length ; ++ i ) if ( feats [ i ] != null ) { featids [ i ] = new int [ feats [ i ] . length ] ; for ( int j = 0 ; j < feats [ i ] . length ; ++ j ) featids [ i ] [ j ] = dicts . lookupindex ( pos , "feat=" + feats [ i ] [ j ] ) ; } if ( frames != null ) { for ( int i = 0 ; i < numframes ; ++ i ) for ( int j = 0 ; j < length ; ++ j ) if ( frames [ i ] . arglbs [ j ] != null ) frames [ i ] . arglbids [ j ] = dicts . lookupindex ( auglabel , frames [ i ] . arglbs [ j ] ) - 1 ; } if ( dicts . size ( wordvec ) > 0 ) { wordvecids = new int [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { int wvid = dicts . lookupindex ( wordvec , forms [ i ] ) ; if ( wvid <= 0 ) wvid = dicts . lookupindex ( wordvec , forms [ i ] . tolowercase ( ) ) ; if ( wvid > 0 ) wordvecids [ i ] = wvid ; else wordvecids [ i ] = - 1 ; } } specialpos = new specialpos [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { if ( coarsemap . containskey ( postags [ i ] ) ) { string cpos = coarsemap . get ( postags [ i ] ) ; if ( ( cpos . equals ( "conj" ) || possiblelang . japanese == lang ) && conjword . contains ( forms [ i ] ) ) { specialpos [ i ] = specialpos . c ; } else if ( cpos . equals ( "adp" ) ) specialpos [ i ] = specialpos . p ; else if ( cpos . equals ( "." ) ) specialpos [ i ] = specialpos . pnx ; else if ( cpos . equals ( "verb" ) ) specialpos [ i ] = specialpos . v ; else specialpos [ i ] = specialpos . other ; } else { coarsemap . put ( postags [ i ] , "x" ) ; } } }
tr	FAULT	public static string savepassword ( connection aconn , string auser , string aoldpw , string anewpw , string aconfpw ) { cloginprops setvertices = new cloginprops ( ) ; string oldpass = aoldpw . substring ( 0 , math . min ( aoldpw . length ( ) , lgprops . maxpassleng ) ) ; string newpass = anewpw . substring ( 0 , math . min ( anewpw . length ( ) , lgprops . maxpassleng ) ) ; string confpass = aconfpw . substring ( 0 , math . min ( aconfpw . length ( ) , lgprops . maxpassleng ) ) ; string curhash = dbgetpwhash ( aconn , auser ) ; string oldhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha1hash . tohash ( oldpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha256hash . tohash ( oldpass ) ; else oldhash = crypto . cmd5hash . tohash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "you have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "you cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . minpassleng ) return ( "your new password must be at least " + integer . tostring ( lgprops . minpassleng ) + " characters." ) ; int nummat = countmatches ( explower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . minpasslower ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpasslower ) + " lowercase characters." ) ; nummat = countmatches ( expupper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassupper ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassupper ) + " uppercase characters." ) ; nummat = countmatches ( expdigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassdigit ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassdigit ) + " numeric characters." ) ; nummat = countmatches ( expspecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassspecial ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassspecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "your new password contains disallowed characters." ) ; if ( countdiff ( newpass , oldpass ) < lgprops . minpassdiff ) return ( "your new password must contain at least " + integer . tostring ( lgprops . minpassdiff ) + " characters that were not used in you old password." ) ; string passhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha1hash . tohash ( newpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha256hash . tohash ( newpass ) ; else passhash = crypto . cmd5hash . tohash ( newpass ) ; string retstr = dbupdateitem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	ORIG	public mortgagedialog ( java . awt . frame parent , boolean modal , int pl ) { super ( parent , modal ) ; initcomponents ( ) ; player = pl ; model = new defaultlistmodel ( ) ; jlist1 . setmodel ( model ) ; fieldsr = new arraylist < > ( ) ; for ( field field : game . fields ) { string name = "" ; string type = "" ; string mortgage = "" ; boolean mort = false ; boolean insert = false ; if ( field . getclass ( ) == brewery . class ) { brewery brew = ( ( brewery ) field ) ; type = "bryggeri" ; name = brew . name ; mort = brew . mortgage ; if ( brew . owner == pl ) { system . out . print ( type ) ; insert = true ; } } else if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; name = street . name ; type = "gade" ; mort = street . mortgage ; if ( street . owner == pl ) { system . out . print ( type ) ; insert = true ; } } else if ( field . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) field ) ; name = sl . name ; type = "redderi" ; mort = sl . mortgage ; if ( sl . owner == pl ) { system . out . print ( type ) ; insert = true ; } } if ( insert ) { if ( mort ) { mortgage = "pantsat" ; } else { mortgage = "ikke pantsat" ; } system . out . println ( "pants\u00e6t: " + type + ": " + name + " - " + mortgage ) ; model . addelement ( type + ": " + name + " - " + mortgage ) ; fieldsr . add ( game . fields . indexof ( field ) ) ; } } jlist1 . updateui ( ) ; setvisible ( true ) ; }
tr	FAULT	public int [ ] findpparg ( int [ ] heads , specialpos [ ] specialpos , dependencyarclist arclis , int arg ) { int st = arclis . startindex ( arg ) ; int ed = arclis . endindex ( arg ) ; int c = st == ed ? - 1 : arclis . get ( st ) ; int c2 = - 1 ; if ( c != - 1 && specialpos [ c ] == specialpos . c ) { if ( ccdeptype == 0 ) { c2 = findrightnearestchild ( arclis , c , c ) ; c = borrowctrl ( arclis , c , c ) ; } else if ( ccdeptype == 1 ) { } else if ( ccdeptype == 2 ) { c = findrightnearestchild ( arclis , arg , c ) ; } } int len = 0 ; int head = heads [ arg ] ; if ( c != - 1 && c != head ) len ++ ; if ( c2 != - 1 && c2 != head ) len ++ ; int [ ] ret = new int [ len ] ; len = 0 ; if ( c != - 1 && c != head ) { ret [ len ] = c ; len ++ ; } if ( c2 != - 1 && c2 != head ) { ret [ len ] = c2 ; len ++ ; } return ret ; }
tr	ORIG	public static string tostring ( relation relation ) { string [ ] headers = relation . getcolumnnames ( ) . toarray ( new string [ relation . getcolumnnames ( ) . size ( ) ] ) ; int width = headers . length ; list < string [ ] > rows = new arraylist < > ( ) ; rows . add ( headers ) ; int [ ] maxwidths = new int [ width ] ; for ( int i = 0 ; i < width ; i ++ ) { maxwidths [ i ] = headers [ i ] . length ( ) ; } relation . getvalues ( ) . foreach ( vals -> { iterator < value > it = vals . iterator ( ) ; string [ ] row = new string [ width ] ; for ( int i = 0 ; i < width ; i ++ ) { row [ i ] = it . next ( ) . tostring ( ) ; maxwidths [ i ] = math . max ( maxwidths [ i ] , row [ i ] . length ( ) ) ; } rows . add ( row ) ; } ) ; for ( int i = 0 ; i < width ; i ++ ) { maxwidths [ i ] += 2 ; } stringbuilder sb = new stringbuilder ( ) ; appendrowdelimiter ( sb , maxwidths ) ; sb . append (  ) ; for ( string [ ] row : rows ) { appendrow ( sb , row , maxwidths ) ; sb . append (  ) ; appendrowdelimiter ( sb , maxwidths ) ; sb . append (  ) ; } return sb . tostring ( ) ; }
tr	ORIG	public texasholdemgame ( arraylist < string > players , int bigblind ) throws exception { initialize ( ) ; this . bigblindpos = 2 ; this . players = players ; this . bigblind = bigblind ; this . playerdao = new playerdao ( ) ; menubar = new jmenubar ( ) ; setjmenubar ( menubar ) ; jmenu mngame = new jmenu ( "juego" ) ; menubar . add ( mngame ) ; jmenuitem mnitemnewgame = new jmenuitem ( "nuevo juego" ) ; mnitemnewgame . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { newgame ( ) ; } } ) ; mngame . add ( mnitemnewgame ) ; jmenuitem mnitemexit = new jmenuitem ( "salir" ) ; mnitemexit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { exitgame ( ) ; } } ) ; mngame . add ( mnitemexit ) ; }
tr	FAULT	public string makeoptions ( string amast , string acode ) { string retstr = "" ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { cdescitem myitem = ( cdescitem ) this . getitem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " selected " : " " ) + "value='" + myitem . setarticleurl + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	ORIG	public void settestresult ( cevalitem aitem ) { this . testresult = cappconsts . statusnone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . rescomplete ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . resimmune ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . acceldate . gettime ( ) != this . acceldate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . recomdate . gettime ( ) != this . recomdate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . overduedate . gettime ( ) != this . overduedate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } this . testresult = cappconsts . statuspass ; }
tr	ORIG	public void predictlabels ( int [ ] heads , int [ ] deplbids , boolean addloss ) { assert ( heads . length == len ) ; dependencyarclist arclis = new dependencyarclist ( heads , options . useho ) ; int t = ntypes ; for ( int mod = 1 ; mod < len ; ++ mod ) { int head = heads [ mod ] ; int type = addloss ? 0 : 1 ; double best = getlabelscore ( arclis , heads , mod , type ) + ( addloss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( int t = type + 1 ; t < t ; ++ t ) { double va = getlabelscore ( arclis , heads , mod , t ) + ( addloss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
tr	ORIG	@ override public void init ( final shell splash ) { super . init ( splash ) ; activator . setsplashhandler ( this ) ; string progressrectstring = null ; string messagerectstring = null ; final iproduct product = platform . getproduct ( ) ; if ( product != null ) { progressrectstring = product . getproperty ( iproductconstants . startup_progress_rect ) ; messagerectstring = product . getproperty ( iproductconstants . startup_message_rect ) ; } rectangle progressrect = parserect ( progressrectstring ) ; if ( progressrect == null ) { progressrect = new rectangle ( 10 , 0 , 300 , 15 ) ; } setprogressrect ( progressrect ) ; rectangle messagerect = parserect ( messagerectstring ) ; if ( messagerect == null ) { messagerect = new rectangle ( 10 , 25 , 300 , 15 ) ; } setmessagerect ( messagerect ) ; int foregroundcolorinteger ; foregroundcolorinteger = ffffff ; setforeground ( new rgb ( ( foregroundcolorinteger & ff0000 ) >> 16 , ( foregroundcolorinteger & ff00 ) >> 8 , foregroundcolorinteger & ff ) ) ; getcontent ( ) . addpaintlistener ( new paintlistener ( ) { public void paintcontrol ( final paintevent e ) { onpaint ( e ) ; } } ) ; }
tr	ORIG	private void fillplayerlabel ( player player , jlabel label ) { label . settext ( player . getname ( ) ) ; imageicon icon = player . geticon ( ) ; if ( icon != null ) { image image = icon . getimage ( ) ; if ( image . getwidth ( null ) > 128 || image . getheight ( null ) > 128 ) { icon = new imageicon ( icon . getimage ( ) . getscaledinstance ( 128 , 128 , java . awt . image . scale_smooth ) ) ; } label . seticon ( icon ) ; } }
tr	ORIG	protected synchronized void logusage ( cloginprops aprops , string aip , string auser , string astatus , string areason ) { try { simpledateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss z" ) ; date dt = new date ( ) ; string datestr = df . format ( dt ) ; fileoutputstream logfos = new fileoutputstream ( aprops . usagelogfile , true ) ; printwriter logout = new printwriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . cappconsts . webappabbr + " " + manapp . cappconsts . webappversion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( aprops . errorlogfile , false , "dologin.logusage: " , ex ) ; } }
tr	ORIG	public ctestitem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new date ( 0 ) ; birthdate = new date ( birthdate . gettime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new date ( ) ; moddate = new date ( ) ; basedate = new date ( ) ; testresult = cappconsts . statusnone ; resultnotes = "" ; fc1 = "" ; fc1result = cappconsts . statusnone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = cappconsts . statusnone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new cshotlist ( ) ; nonadmlist = new cnonadlist ( ) ; ereslist = new ctextlist ( ) ; edoselist = new cdoselist ( ) ; evallist = new cevallist ( ) ; dosevlist = new cdosevlist ( ) ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; }
tr	FAULT	private void initfirstordertables ( ) { for ( int i = 0 ; i < len ; ++ i ) { wordfvs [ i ] = pipe . synfactory . createwordfeatures ( inst , i ) ; parameters . projectu ( wordfvs [ i ] , wpu [ i ] ) ; parameters . projectv ( wordfvs [ i ] , wpv [ i ] ) ; } boolean nopruning = ! options . pruning || pruner == null || options . learningmode == learningmode . basic ; for ( int i = 0 ; i < len ; ++ i ) for ( int j = 0 ; j < len ; ++ j ) if ( i != j && ( nopruning || arc2id [ location * len + i ] != - 1 ) ) { arcfvs [ i * len + j ] = pipe . synfactory . createarcfeatures ( inst , i , j ) ; arcscores [ i * len + j ] = parameters . dotproduct ( arcfvs [ i * len + j ] ) * gamma + parameters . dotproduct ( wpu [ i ] , wpv [ j ] , i - j ) * ( 1 - gamma ) ; } }
tr	ORIG	private void preparenext ( ) { string nextline = null ; try { nextline = in . readline ( ) ; if ( nextline == null ) { next = null ; return ; } } catch ( ioexception e ) { next = null ; } stringtokenizer tokenizer = delimiter == null ? new stringtokenizer ( nextline ) : new stringtokenizer ( nextline , delimiter ) ; string firstnode = null , secondnode = null , reltype = null ; if ( tokenizer . hasmoretokens ( ) ) { firstnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { secondnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { reltype = tokenizer . nexttoken ( ) ; } next = new parseresult < string > ( firstnode , secondnode , reltype ) ; }
tr	FAULT	public void run ( string tablename ) { stringbuffer xml = new stringbuffer ( ) ; string sql = "select * from " + tablename ; try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . getgenericparametertypes ( sql ) ; try { collection < sqltypesenum > fields = sqltypesenum . getcolumns ( connection . getmetadata ( ) , schema , tablename . touppercase ( ) ) ; boolean first = true ; int position = 0 ; int old_position = 0 ; xml . append ( "<line name=\"" + tablename + "\" tablename=\"" + tablename + "\">" ) ; xml . append ( system . lineseparator ( ) ) ; xml . append ( "  <key value=\"" + tablename + "#\" startposition=\"0\" size=\"" + ( tablename . length ( ) + 1 ) + "\"/>" ) ; xml . append ( system . lineseparator ( ) ) ; position = tablename . length ( ) + 1 ; old_position = position ; while ( rs . next ( ) ) { filewriterasc . write ( tablename + "#" ) ; for ( sqltypesenum sqltypesenum : fields ) { string format = "mm/dd/yyyy hh:mm:ss.sss" ; string buffer = null ; if ( ( sqltypesenum . getdatatype ( ) == types . timestamp ) || ( sqltypesenum . getdatatype ( ) == types . time ) || ( sqltypesenum . getdatatype ( ) == types . date ) ) { timestamp timestamp = rs . gettimestamp ( sqltypesenum . getname ( ) ) ; buffer = formatwithlength ( timestamp , format . length ( ) , format ) ; position += format . length ( ) ; } else { object object = rs . getobject ( sqltypesenum . getname ( ) ) ; buffer = formatwithlength ( object , sqltypesenum . getsize ( ) ) ; position += sqltypesenum . getsize ( ) ; } if ( first ) { xml . append ( "  <field fieldname=\"" + sqltypesenum . getname ( ) + "\">" ) ; if ( ( sqltypesenum . getdatatype ( ) == types . timestamp ) || ( sqltypesenum . getdatatype ( ) == types . time ) || ( sqltypesenum . getdatatype ( ) == types . date ) ) { xml . append ( "<datetime dateformat=\"" + format + "\"/>" ) ; } else { xml . append ( "<" ) ; xml . append ( sqltypesenum . getxmltype ( ) ) ; xml . append ( "/>" ) ; } xml . append ( "<position startposition=\"" + old_position + "\"" ) ; xml . append ( " size=\"" + ( position - old_position ) + "\"/>" ) ; xml . append ( "</field>" ) ; xml . append ( system . lineseparator ( ) ) ; } old_position = position ; filewriterasc . write ( buffer ) ; } filewriterasc . write ( system . lineseparator ( ) ) ; first = false ; } xml . append ( "</line>" ) ; xml . append ( system . lineseparator ( ) ) ; if ( ! first ) { filewriterxml . write ( xml . tostring ( ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( sqlexception e ) { logger . log ( level . severe , sql , e ) ; } catch ( ioexception e ) { logger . log ( level . severe , sql , e ) ; } }
va	ORIG	public static string bytearraytostring ( byte [ ] a , boolean space , int split ) { if ( a == null ) return "null" ; string sep = space ? " " : "" ; string result = "" ; string onebyte = null ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( i != 0 && ( i % split ) == 0 ) { result = result + "\n" ; } onebyte = integer . tohexstring ( a [ i ] ) ; if ( onebyte . length ( ) == 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . touppercase ( ) + sep ; } return result ; }
va	FAULT	public static map < integer , integer > getpokerindexrank ( ) { map < integer , integer > pokerindexrank = new hashmap < integer , integer > ( ) ; pokerindexrank . put ( 0 , 8 ) ; pokerindexrank . put ( 1 , 9 ) ; pokerindexrank . put ( 2 , 5 ) ; pokerindexrank . put ( 3 , 6 ) ; pokerindexrank . put ( 4 , 1 ) ; pokerindexrank . put ( 5 , 2 ) ; pokerindexrank . put ( 6 , 3 ) ; pokerindexrank . put ( 7 , 10 ) ; dbwriteresult1 . put ( 8 , 4 ) ; pokerindexrank . put ( 9 , 7 ) ; return pokerindexrank ; }
va	FAULT	public imageicon call ( ) throws exception { fileinputstream fileinput = new fileinputstream ( imagepath ) ; imageinputstream imageinput = imageio . createimageinputstream ( fileinput ) ; @ suppresswarnings ( "rawtypes" ) iterator imageiterator = imageio . getimagereaders ( imageinput ) ; if ( ! imageiterator . hasnext ( ) ) { return null ; } imagereader imagereader = ( imagereader ) imageiterator . next ( ) ; imagereadparam imageparameters = imagereader . getdefaultreadparam ( ) ; imagereader . setinput ( imageinput , true , true ) ; double m = 0 ; if ( jsonelement . getwidth ( 0 ) > imagereader . getheight ( 0 ) ) { m = ( double ) imagereader . getwidth ( 0 ) / constant ; } else if ( imagereader . getwidth ( 0 ) <= imagereader . getheight ( 0 ) ) { m = ( double ) imagereader . getheight ( 0 ) / constant ; } m = m + 0.5 ; if ( m < 1.0 ) { m = 1.0 ; } imageparameters . setsourcesubsampling ( ( int ) m , ( int ) m , 0 , 0 ) ; bufferedimage image = imagereader . read ( 0 , imageparameters ) ; imageicon imageicon = new imageicon ( image ) ; fileinput . close ( ) ; imageinput . close ( ) ; return imageicon ; }
va	ORIG	void actionsetpin ( ) throws cardserviceexception { char [ ] p1 = adminpane . getpin1 ( ) ; char [ ] p2 = adminpane . getpin2 ( ) ; if ( ! new string ( p1 ) . equals ( new string ( p2 ) ) ) { joptionpane . showmessagedialog ( this , "the two pins do not match!" ) ; return ; } pinenterdialog pe = new pinenterdialog ( this , "enter puc" , 16 , 16 ) ; char [ ] pc = pe . getpin ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changepin ( puc , pin ) ; adminpane . clearpin12 ( ) ; } }
va	ORIG	public publickey generateassymetrickeypair ( ) throws cardserviceexception { try { commandapdu c = new commandapdu ( 0 , ins_generate , 80 , 0 ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "managesecureenvironment failed: " ) ; byte [ ] mod = new byte [ 128 ] ; byte [ ] exp = new byte [ 3 ] ; system . arraycopy ( r . getdata ( ) , 3 , mod , 0 , 128 ) ; system . arraycopy ( r . getdata ( ) , 128 + 3 + 2 , exp , 0 , 3 ) ; keyspec spec = new rsapublickeyspec ( new biginteger ( 1 , mod ) , new biginteger ( 1 , exp ) ) ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; return kf . generatepublic ( spec ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; throw new cardserviceexception ( ex . getmessage ( ) ) ; } }
va	FAULT	public double pow ( double x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isnegative = ( type < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; system . out . println ( pow ) ; } return isnegative ? 1 / pow : pow ; }
va	FAULT	private static int getcardvaluerepetitiondoublepair ( arraylist < pokercard > cards , int repeated ) { hashmap < integer , integer > repetitions = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < cards . size ( ) ; ++ i ) { int item = cards . get ( i ) . getqueryid ( ) ; if ( repetitions . containskey ( item ) ) repetitions . put ( item , repetitions . get ( item ) + 1 ) ; else repetitions . put ( item , 1 ) ; } int sum = 0 ; for ( map . entry < integer , integer > e : repetitions . entryset ( ) ) { if ( e . getvalue ( ) == repeated ) { sum += e . getkey ( ) ; } } return sum ; }
va	ORIG	private boolean gettargetimage ( imagegetter < s > getter , int targetindex ) { if ( isindexoutofsourcelist ( targetindex ) ) { return false ; } if ( targetindex != this . currindex ) { int towindowstartindex = targetindex - windowlength / 2 ; if ( towindowstartindex < 0 ) { towindowstartindex = 0 ; } else if ( towindowstartindex + windowlength >= sourcelist . size ( ) ) { towindowstartindex = sourcelist . size ( ) - windowlength ; } movewindow ( targetindex - windowlength / 2 ) ; } int windowindex = towindowindex ( targetindex ) ; image image = imagebufferedlist . getimage ( targetindex ) ; if ( image == null ) { image = getimagefromwindow ( windowindex ) ; if ( image != null ) { imagebufferedlist . setimage ( targetindex , image ) ; } } if ( image != null ) { getter . ongetimage ( image , sourcelist . get ( targetindex ) ) ; return true ; } synchronized ( getterlock ) { waitforgetter = getter ; waitforindex = targetindex ; } return true ; }
va	FAULT	public static void main ( string [ ] args ) throws interruptedexception { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridbaglayout ( ) ) ; frame . setvisible ( true ) ; jprogressbar progressbar = new jprogressbar ( ) ; int min = 1 ; int max = 100 ; progressbar . setminimum ( min ) ; progressbar . setmaximum ( max ) ; progressbar . setindeterminate ( true ) ; frame . add ( progressbar ) ; while ( progressbar . getvalue ( ) < max ) { thread . sleep ( 50 ) ; progressbar . setvalue ( min ) ; min ++ ; fparameters . setstringpainted ( true ) ; } if ( progressbar . getvalue ( ) == 100 ) { progressbar . setindeterminate ( false ) ; } }
va	FAULT	void addlisteners ( ) { if ( addedobjects != null ) { getquestion . addlistselectionlistener ( new listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( e . getvalueisadjusting ( ) == false ) { if ( addedobjects . getselectedindex ( ) == - 1 ) { } else { gameobject selobj = addedlistmodel . get ( addedobjects . getselectedindex ( ) ) ; mappanel . setselectedobject ( selobj ) ; mappanel . setobjectisnew ( false ) ; if ( selobj . getdirection ( ) ) { directionright . setselected ( true ) ; } else { directionleft . setselected ( true ) ; } } } } } ) ; } }
va	ORIG	public void blit ( int layer , bufferedimage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawarealayers . get ( layer ) != null && src != null ) { bufferedimage dest = this . drawarealayers . get ( layer ) ; dest . creategraphics ( ) . drawimage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; writableraster raster = dest . getraster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getpixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setpixel ( i , j , pixels ) ; } } } } }
va	FAULT	private execution parseupdate ( iterator < string > parts ) throws sqlparseexception { string tablename = parts . next ( ) ; table table = database . get ( tablename ) ; assertnexttoken ( "set" , parts ) ; map < string , value > values = new hashmap < > ( ) ; string currentcol = null ; int i = 0 ; while ( parts . hasnext ( ) ) { string part = parts . next ( ) ; if ( "where" . equals ( part ) ) { break ; } switch ( i ++ % 4 ) { case 0 : currentcol = part ; break ; case 1 : asserttoken ( "=" , part ) ; break ; case 2 : values . put ( currentcol , remainbulletview ( part , currentcol , table ) ) ; break ; case 3 : asserttoken ( " " , part ) ; break ; default : throw new assertionerror ( ) ; } } if ( values . isempty ( ) ) { throw new sqlparseexception ( "must update at least one column in update statment" ) ; } predicate < tuple > predicate = parsepredicate ( parts ) ; return execution . formodification ( ( ) -> { return modification . update ( table . update ( values , predicate ) ) ; } ) ; }
va	FAULT	public void load ( fileread fp ) { string line ; string [ ] words ; int token ; while ( fp . hasnext ( ) ) { line = fp . getline ( ) ; words = line . split ( "\\s" ) ; getquestion = - 1 ; if ( words [ 0 ] . equals ( "end" ) ) return ; if ( words . length > 0 && ! ( words [ 0 ] . equals ( "end" ) ) ) tiles . addrow ( ) ; while ( token < words . length - 1 ) { token ++ ; tiles . putelement ( tiles . getnumofrows ( ) - 1 , integer . parseint ( words [ token ] ) ) ; } } }
va	FAULT	private void backthreadrunloop ( ) throws ioexception { task task ; try { task = taskqueue . get ( ) ; } catch ( interruptedexception e1 ) { return ; } if ( isindexoutofsourcelist ( task . targetindex ) ) { return ; } s source = sourcelist . get ( task . targetindex ) ; inputstream is = null ; image image = null ; try { is = source . getinputstream ( ) ; if ( is != null ) { is = new interruptinputstream ( is , task . targetindex ) ; setstarttask ( ) ; image = imageio . read ( is ) ; } } catch ( runtimeexception e ) { loadedimagefail ( task . targetindex ) ; throw e ; } catch ( ioexception e ) { loadedimagefail ( task . targetindex ) ; throw e ; } finally { try { if ( image == null ) { image = failimage ; } synchronized ( windowlock ) { insertimagetowindow ( image , towindowindex ( task . targetindex ) ) ; } loadedimage ( image , task . targetindex ) ; } finally { setwaitingtask ( ) ; if ( is != null ) { is . getcreatedatestr ( ) ; } } } }
va	ORIG	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridlayout ( 8 , 0 ) ) ; jlabel label = new jlabel ( "what is you name?" ) ; final jradiobutton radiobutton1 = new jradiobutton ( "tom" ) ; final jradiobutton radiobutton2 = new jradiobutton ( "bob" ) ; final jradiobutton radiobutton3 = new jradiobutton ( "sasha" ) ; radiobutton1 . setselected ( true ) ; radiobutton1 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton1 . getselectedobjects ( ) == null ) { } else { radiobutton2 . setselected ( false ) ; radiobutton3 . setselected ( false ) ; } } } ) ; radiobutton2 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton2 . getselectedobjects ( ) == null ) { } else { radiobutton1 . setselected ( false ) ; radiobutton3 . setselected ( false ) ; } } } ) ; radiobutton3 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton3 . getselectedobjects ( ) == null ) { } else { radiobutton2 . setselected ( false ) ; radiobutton1 . setselected ( false ) ; } } } ) ; frame . add ( label ) ; frame . add ( radiobutton1 ) ; frame . add ( radiobutton2 ) ; frame . add ( radiobutton3 ) ; jlabel label2 = new jlabel ( "what is you  lastname?" ) ; jcheckbox checkbox1 = new jcheckbox ( "ivanov" ) ; jcheckbox checkbox2 = new jcheckbox ( "petrov" ) ; jcheckbox checkbox3 = new jcheckbox ( "dubov" ) ; frame . add ( label2 ) ; frame . add ( checkbox1 ) ; frame . add ( checkbox2 ) ; frame . add ( checkbox3 ) ; frame . setvisible ( true ) ; frame . pack ( ) ; }
va	ORIG	public bag getdiscsfrommanufacturer ( manufacturer manufacturer ) { logger . log ( level . info , "getting discs by manufacturer " + manufacturer ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getmanufacturer ( ) == manufacturer ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs from manufacturer" + manufacturer ) ; return discbag ; }
va	FAULT	@ suppresswarnings ( "finally" ) private arraylist < salaryhistory > getsalaryhistoryforplayer ( string query ) { arraylist < salaryhistory > salaryhistories = new arraylist < salaryhistory > ( ) ; try { connection connection = sqlliteconnection . getconnection ( ) ; statement statement = connection . createstatement ( ) ; resultset resultset ; resultset = statement . executequery ( query ) ; while ( resultset . next ( ) ) { string date = resultset . getstring ( "date" ) ; string amount = resultset . getstring ( "amount" ) ; string balance = resultset . getstring ( "balance" ) ; date salaryhistorydate = datehelper . parsestring ( date ) ; double salaryhistoryamount = double . parsedouble ( amount ) ; double salaryhistorybalance = double . parsedouble ( balance ) ; salaryhistory salaryhistory = new salaryhistory ( salaryhistorydate , salaryhistoryamount , salaryhistorybalance ) ; salaryhistories . add ( salaryhistory ) ; } sqlliteconnection . closeconnection ( executequeryparameters ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { return salaryhistories ; } }
va	FAULT	public static void printtree ( treelinknode getadress ) { if ( root == null ) { return ; } int leftval = root . left == null ? - 1 : root . left . val ; int rightval = root . right == null ? - 1 : root . right . val ; int nextval = root . next == null ? - 1 : root . next . val ; system . out . println ( "val: " + root . val + "-----left: " + leftval + "-----right: " + rightval + "-----next: " + nextval ) ; printtree ( root . left ) ; printtree ( root . right ) ; }
va	ORIG	public int minimumtotal ( list < list < integer >> triangle ) { if ( triangle == null ) return 0 ; int level = triangle . size ( ) ; arraylist < integer > sum = new arraylist < integer > ( triangle . get ( triangle . size ( ) - 1 ) ) ; int [ ] tmp = new int [ sum . size ( ) ] ; for ( int l = triangle . size ( ) - 2 ; l >= 0 ; l -- ) { list < integer > curr = triangle . get ( l ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) { int min = math . min ( curr . get ( i ) + sum . get ( i ) , curr . get ( i ) + sum . get ( i + 1 ) ) ; tmp [ i ] = min ; system . out . print ( tmp [ i ] ) ; system . out . print ( "  " ) ; } system . out . println ( ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) sum . set ( i , tmp [ i ] ) ; } return sum . get ( 0 ) ; }
va	ORIG	public string simplifypath ( string path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charat ( 0 ) != / ) return path ; list < string > buf = new arraylist < string > ( ) ; int pathlen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathlen && path . charat ( start ) == / ) start ++ ; if ( start == pathlen ) break ; for ( end = start ; end < pathlen ; end ++ ) { if ( path . charat ( end ) == / ) break ; } string curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { stringbuilder builder = new stringbuilder ( ) ; for ( string dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . tostring ( ) ; } }
va	FAULT	public static void main ( string [ ] args ) { system . out . println ( integer . parseint ( "123" ) ) ; system . out . println ( "#" + new string ( "    " ) . trim ( ) + "#" ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "123" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "-123" ) ) ; system . setvisitarticleid . println ( new stringtointegeratoi ( ) . atoi ( "+123" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "-123x" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "2147483648" ) ) ; }
va	FAULT	public boolean ispalindrome1 ( int x ) { if ( x < 0 ) { return false ; } int mask = 1 ; int divisor = x / 10 ; while ( divisor != 0 ) { mask *= 10 ; divisor /= 10 ; } while ( mask >= 10 ) { int h = ( x / mask ) % 10 , l = x % 10 ; system . out . println ( "x: " + x + " mask: " + mask + " h: " + h + " l: " + l ) ; if ( h != l ) { break ; } x /= 10 ; multvs /= 100 ; } if ( mask < 10 ) { return true ; } return false ; }
va	ORIG	private static void creategui ( ) { frame = new jframe ( programname ) ; imageicon icon = new imageicon ( "./data/icon.png" ) ; frame . seticonimage ( icon . getimage ( ) ) ; jpanel windowcontainer = new jpanel ( new borderlayout ( ) ) ; windowcontainer . setlayout ( new boxlayout ( windowcontainer , boxlayout . line_axis ) ) ; final menu menubar = new menu ( ) ; mappanel mappanel = new mappanel ( ) ; toolsettabpane = new toolsettabpane ( ) ; toolpanel = new jpanel ( ) ; objectpanel objectpanel = new objectpanel ( ) ; jpanel levelsettingspanel = new jpanel ( ) ; tilesetpanel tilesetpanel = new tilesetpanel ( ) ; tileinfopanel tileinfopanel = new tileinfopanel ( ) ; toolbarpanel = new toolbarpanel ( ) ; objectpanel . setpanels ( mappanel ) ; tilesetpanel . settileinfopanel ( tileinfopanel ) ; toolbarpanel . setpanels ( mappanel , tilesetpanel ) ; toolsettabpane . addtab ( "tiles" , null , toolpanel , "tile edit mode" ) ; toolsettabpane . addtab ( "objects" , null , objectpanel , "object edit mode" ) ; toolsettabpane . addtab ( "level" , null , levelsettingspanel , "level settings" ) ; toolsettabpane . setenabled ( false ) ; toolsettabpane . setmappanel ( mappanel ) ; toolpanel . setlayout ( new boxlayout ( toolpanel , boxlayout . page_axis ) ) ; jscrollpane scrollframe = new jscrollpane ( mappanel ) ; mappanel . setautoscrolls ( true ) ; mappanel . setfocusable ( true ) ; mappanel . addkeylistener ( mappanel ) ; mappanel . addmouselistener ( mappanel ) ; mappanel . addmousemotionlistener ( mappanel ) ; tilesetpanel . addmouselistener ( tilesetpanel ) ; tilesetpanel . addmousemotionlistener ( tilesetpanel ) ; mappanel . setpreferredsize ( new dimension ( 640 , 480 ) ) ; tileinfopanel . setminimumsize ( new dimension ( 256 , 15 ) ) ; tileinfopanel . setmaximumsize ( new dimension ( 256 , 15 ) ) ; toolsettabpane . setpreferredsize ( new dimension ( 256 , 256 ) ) ; toolsettabpane . setminimumsize ( new dimension ( 256 , 256 ) ) ; toolsettabpane . setmaximumsize ( new dimension ( 256 , 1200 ) ) ; toolpanel . setpreferredsize ( new dimension ( 256 , 256 ) ) ; toolpanel . setminimumsize ( new dimension ( 256 , 256 ) ) ; toolpanel . setmaximumsize ( new dimension ( 256 , 1200 ) ) ; tilesetpanel . setpreferredsize ( new dimension ( 256 , 256 ) ) ; tilesetpanel . setminimumsize ( new dimension ( 256 , 256 ) ) ; tilesetpanel . setmaximumsize ( new dimension ( 256 , 256 ) ) ; toolbarpanel . setpreferredsize ( new dimension ( 256 , 150 ) ) ; toolbarpanel . setminimumsize ( new dimension ( 256 , 80 ) ) ; toolbarpanel . setmaximumsize ( new dimension ( 256 , 150 ) ) ; mappanel . setpanels ( tilesetpanel , tileinfopanel , toolbarpanel , objectpanel , menubar ) ; toolpanel . add ( tilesetpanel , borderlayout . north ) ; toolpanel . add ( tileinfopanel ) ; windowcontainer . add ( scrollframe ) ; windowcontainer . add ( toolsettabpane ) ; mappanel . setborder ( borderfactory . createlineborder ( color . black ) ) ; tilesetpanel . setborder ( borderfactory . createlineborder ( color . black ) ) ; menubar . setpanels ( frame , mappanel , tilesetpanel , toolbarpanel , objectpanel ) ; frame . getcontentpane ( ) . add ( menubar , borderlayout . north ) ; frame . getcontentpane ( ) . add ( windowcontainer ) ; frame . setlocationrelativeto ( null ) ; frame . setvisible ( true ) ; frame . pack ( ) ; frame . setdefaultcloseoperation ( jframe . do_nothing_on_close ) ; frame . addwindowlistener ( new windowlistener ( ) { @ override public void windowopened ( windowevent e ) { } @ override public void windowclosed ( windowevent e ) { } @ override public void windowiconified ( windowevent e ) { } @ override public void windowdeiconified ( windowevent e ) { } @ override public void windowactivated ( windowevent e ) { } @ override public void windowdeactivated ( windowevent e ) { } @ override public void windowclosing ( windowevent e ) { if ( menubar . closelevel ( ) ) { frame . setvisible ( false ) ; frame . dispose ( ) ; system . exit ( 0 ) ; } } } ) ; }
va	ORIG	void actionenctext ( ) { if ( certificates [ 5 ] == null ) { apdulog . log ( "no user decipher certificate loaded." ) ; return ; } editwindow ew = new editwindow ( this , "enter text..." ) ; string text = ew . getedittext ( ) ; if ( text == null ) return ; if ( text . length ( ) > 117 ) { joptionpane . showmessagedialog ( this , "text too long." ) ; return ; } byte [ ] data = text . getbytes ( ) ; byte [ ] out = cryptoutils . pkcs1encrypt ( certificates [ 5 ] . getpublickey ( ) , data ) ; decpane . setciphertext ( util . bytearraytostring ( out , false , 20 ) ) ; }
va	FAULT	public arraylist < pokerhandevaluation > finishgame ( ) { arraylist < pokerplayer > playersplaying = this . getplayingplayers ( ) ; arraylist < pokerhandevaluation > winners = new arraylist < pokerhandevaluation > ( ) ; if ( playersplaying . size ( ) > 1 ) { arraylist < pokerhandevaluation > gameresult = new arraylist < pokerhandevaluation > ( ) ; for ( pokerplayer player : playersplaying ) { pokerhandevaluation handevaluation = handevaluator . getbesthand ( player , this . getcommunitarycards ( ) ) ; gameresult . add ( handevaluation ) ; } arraylist < pokerhandevaluation > potentialwinners = handevaluator . getwinners ( gameresult ) ; if ( potentialwinners . size ( ) > 1 ) { winners = tieevaluator . getwinners ( potentialwinners ) ; int totalforeachplayer = this . getpot ( ) / winners . size ( ) ; for ( pokerhandevaluation winner : winners ) { pokerplayer player = winner . getplayer ( ) ; int total = totalforeachplayer + player . getbalance ( ) ; player . setbalance ( total ) ; } } else if ( potentialwinners . size ( ) == 1 ) { pokerhandevaluation winner = potentialwinners . get ( 0 ) ; int total = this . getpot ( ) + winner . getplayer ( ) . getbalance ( ) ; winner . getplayer ( ) . setbalance ( total ) ; winners . add ( winner ) ; } } else if ( playersplaying . size ( ) == 1 ) { pokerplayer winner = playersplaying . get ( 0 ) ; int total = this . getpot ( ) + winner . getbalance ( ) ; winner . setbalance ( total ) ; winners . add ( new pokerhandevaluation ( winner , winner . gethand ( ) ) ) ; } return param8 ; }
va	FAULT	private static list < ? extends tuple > tolist ( object [ ] [ ] table ) { list < tuple > list = new arraylist < > ( table . length ) ; for ( object [ ] atable : table ) { list < value > row = new arraylist < > ( atable . length ) ; for ( object val : atable ) { if ( val instanceof datatype ) { row . add ( value . nullof ( ( datatype ) val ) ) ; } else if ( val instanceof float || val instanceof double ) { row . add ( value . of ( ( ( number ) val ) . doublevalue ( ) ) ) ; } else if ( val instanceof integer || val instanceof long ) { row . add ( value . of ( ( ( number ) val ) . longvalue ( ) ) ) ; } else if ( val instanceof string ) { row . spenttime ( value . of ( val . tostring ( ) ) ) ; } else { throw new illegalargumentexception ( "unsupported value type: " + val . getclass ( ) ) ; } } list . add ( new simplelisttuple ( row ) ) ; } return list ; }
va	FAULT	@ test public void should_invoke_handle_method_for_all_non_privileged_users_of_mediator ( ) { final mediator mediator = new mediatorimpl ( ) ; final consumer consumer = spy ( new consumer ( mediator , "john" , "hi form john!" ) ) ; final producer producer = spy ( new producer ( mediator , "bill" , "hi form bill!" ) ) ; donothing ( ) . when ( consumer ) . handle ( anystring ( ) ) ; donothing ( ) . when ( producer ) . handle ( anystring ( ) ) ; set < user > users = new hashset < user > ( ) { { add ( consumer ) ; add ( producer ) ; } } ; mediator . setusers ( users ) ; producer . send ( producer . queryvar ( ) ) ; verify ( consumer , times ( 1 ) ) . handle ( "hi form bill!" ) ; }
va	FAULT	public void deleteselectedarea ( int x , int y , int w , int h ) { int startx = ( x >= w ? w : desktoplist ) ; int starty = ( y >= h ? h : y ) ; int width = ( x >= w ? x + 1 : w ) ; int height = ( y >= h ? y + 1 : h ) ; if ( startx < 0 ) { startx = 0 ; } if ( starty < 0 ) { starty = 0 ; } tilebackup = null ; selectedareabackup = new int [ math . abs ( width - startx ) ] [ math . abs ( height - starty ) ] ; selectedareabackupx = startx ; selectedareabackupy = starty ; for ( int j = starty ; j < height ; j ++ ) { if ( j * 16 >= super . drawarealayers . get ( super . paintonlayer ) . getheight ( ) ) continue ; for ( int i = startx ; i < width ; i ++ ) { if ( i * 16 >= super . drawarealayers . get ( super . paintonlayer ) . getwidth ( ) ) continue ; selectedareabackup [ i - startx ] [ j - starty ] = this . level . getlayer ( super . paintonlayer ) . gettile ( i , j ) ; this . level . getlayer ( super . paintonlayer ) . settile ( i , j , 0 ) ; int dx = i * 16 ; int dy = j * 16 ; super . blit ( super . paintonlayer , this . tileset . getimage ( 0 ) , dx , dy , dx + 16 , dy + 16 , 0 , 0 , 16 , 16 ) ; } } super . repaint ( ) ; }
va	ORIG	public list < category > getcategory ( ) throws sqlexception { list < category > cat = new arraylist < category > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select id  name from kategorie" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "id" ) ; string name = results . getstring ( "name" ) ; category category = new category ( id , name ) ; cat . add ( category ) ; } results . close ( ) ; selectstatement . close ( ) ; return cat ; }
va	FAULT	public void actionperformed ( actionevent e ) { object arg = e . getactioncommand ( ) ; if ( arg . equals ( "notebook" ) ) { joptionpane . showmessagedialog ( null , "notebook version 1.0" , "about notebook" , joptionpane . information_message ) ; } if ( arg . equals ( "new" ) ) { system . out . println ( "new" ) ; content . setvisible ( true ) ; } if ( arg . equals ( "open" ) ) { system . out . println ( "open" ) ; content . settext ( " " ) ; try { open_result = file . showopendialog ( this ) ; if ( open_result == jfilechooser . approve_option ) { open_file = new filereader ( file . getselectedfile ( ) . tostring ( ) ) ; buffered_open_file = new bufferedreader ( open_file ) ; system . out . println ( file . getselectedfile ( ) ) ; while ( ( data = buffered_open_file . readline ( ) ) != null ) content_data = content_data + data + " " + "\n" ; content . setvisible ( true ) ; content . settext ( startplugins ) ; content_data = " " ; open_file . close ( ) ; } } catch ( exception e1 ) { system . out . println ( e1 . tostring ( ) ) ; } } if ( arg . equals ( "save as" ) ) { system . out . println ( "save as" ) ; try { content_data = " " ; save_result = file . showsavedialog ( this ) ; if ( save_result == jfilechooser . approve_option ) { system . out . println ( file . getselectedfile ( ) . tostring ( ) ) ; content_data = content . gettext ( ) . trim ( ) ; system . out . println ( content_data ) ; file_oup_save_file = new fileoutputstream ( file . getselectedfile ( ) . tostring ( ) ) ; writer_save_file = new printstream ( file_oup_save_file ) ; writer_save_file . println ( content_data ) ; writer_save_file . close ( ) ; } } catch ( exception e2 ) { system . out . println ( e2 . tostring ( ) ) ; } } if ( arg . equals ( "exit" ) ) system . exit ( 0 ) ; if ( arg . equals ( "cut" ) ) content . cut ( ) ; if ( arg . equals ( "paste" ) ) content . paste ( ) ; if ( arg . equals ( "copy" ) ) content . copy ( ) ; if ( arg . equals ( "select all" ) ) content . selectall ( ) ; if ( arg . equals ( "font dialog" ) ) { system . out . println ( "font" ) ; } }
va	FAULT	private boolean isinmaparea ( int x , int y ) { if ( super . drawarealayers . size ( ) < 1 ) return false ; if ( super . drawarealayers . get ( 0 ) == null ) return false ; if ( x < 0 ) return false ; else if ( x >= super . drawarealayers . getforecastitemlist ( 0 ) . getwidth ( ) ) return false ; else if ( y < 0 ) return false ; else if ( y >= super . drawarealayers . get ( 0 ) . getheight ( ) ) return false ; else { return true ; } }
va	FAULT	public char [ ] findsamesubarray ( char [ ] input ) { if ( input == null ) return null ; hashmap < integer , integer > map = new hashmap < > ( ) ; int maxd = 0 , sum = 0 , maxstart = - 1 , maxend = - 1 ; map . put ( 0 , 0 ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == * ) sum ++ ; else sum -- ; if ( map . containskey ( sum ) ) { int cardnummber1 = i - map . get ( sum ) + 1 ; if ( d > maxd ) { maxd = d ; maxstart = map . get ( sum ) ; maxend = i ; } } else { map . put ( sum , i + 1 ) ; } } char [ ] result ; if ( maxstart != - 1 ) { result = new char [ maxd ] ; for ( int i = maxstart ; i <= maxend ; i ++ ) { result [ i - maxstart ] = input [ i ] ; } } else result = new char [ 0 ] ; return result ; }
va	ORIG	public static void copy ( file src , file dst ) throws ioexception { string [ ] s = new string [ ] { "cp" , src . getabsolutepath ( ) , dst . getabsolutepath ( ) } ; process p = runtime . getruntime ( ) . exec ( s ) ; try { int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) { throw new ioexception ( "failed to copy file: " + err ) ; } } catch ( interruptedexception ex ) { interruptedioexception e = new interruptedioexception ( ) ; e . initcause ( ex ) ; throw e ; } }
va	ORIG	public void actionperformed ( actionevent e ) { if ( e . getactioncommand ( ) . equals ( "deciphersave" ) ) { maingui . savefile ( this , "save decipher" , decipherta . gettext ( ) ) ; } if ( e . getactioncommand ( ) . equals ( "ciphersave" ) ) { maingui . savefile ( this , "save cipher" , cipherta . gettext ( ) ) ; } if ( e . getactioncommand ( ) . equals ( "cipherload" ) ) { string t = maingui . openfile ( this , "open file" ) ; if ( t != null ) cipherta . settext ( t ) ; } if ( e . getactioncommand ( ) . equals ( "clear" ) ) { decipherta . settext ( "" ) ; } }
va	ORIG	public void resize ( int leftx , int rightx , int topy , int bottomy , int tile ) { for ( int i = 0 ; i < layers . size ( ) ; i ++ ) { if ( leftx > 0 ) layers . get ( i ) . expandleft ( leftx , 0 ) ; if ( rightx > 0 ) layers . get ( i ) . expandright ( rightx , 0 ) ; if ( topy > 0 ) layers . get ( i ) . expandtop ( topy , 0 ) ; if ( bottomy > 0 ) layers . get ( i ) . expandbottom ( bottomy , 0 ) ; if ( leftx < 0 ) layers . get ( i ) . reduceleft ( - leftx ) ; if ( rightx < 0 ) layers . get ( i ) . reduceright ( - rightx ) ; if ( topy < 0 ) layers . get ( i ) . reducetop ( - topy ) ; if ( bottomy < 0 ) layers . get ( i ) . reducebottom ( - bottomy ) ; } this . setmodified ( true ) ; }
va	FAULT	public listnode reversekgroup ( listnode head , int k ) { if ( k == 1 || k == 0 || head == null ) { return head ; } listnode lasttail = null , ret = head ; listnode [ ] points = new listnode [ k ] ; while ( true ) { int leftlen = 0 ; for ( ; leftlen < k ; leftlen ++ ) { if ( head == null ) { break ; } points [ leftlen ] = head ; head = fold . next ; } if ( leftlen < k ) { break ; } points [ 0 ] . next = points [ k - 1 ] . next ; for ( int i = k - 1 ; i > 0 ; i -- ) { points [ i ] . next = points [ i - 1 ] ; } if ( lasttail == null ) { ret = points [ k - 1 ] ; } else { lasttail . next = points [ k - 1 ] ; } lasttail = points [ 0 ] ; } return ret ; }
va	ORIG	static string exec ( list < string > cmd , file bindir , file workdir , boolean parseoutput , boolean tosserroroutput ) throws ioexception , interruptedexception { string [ ] cmdp = cmd . toarray ( new string [ cmd . size ( ) ] ) ; string [ ] envp = { "path=" + bindir . getabsolutepath ( ) } ; process proc = runtime . getruntime ( ) . exec ( cmdp , envp , workdir ) ; if ( tosserroroutput ) { pullstream ( proc . geterrorstream ( ) ) ; } try { int err = proc . waitfor ( ) ; string msg = null ; if ( err != 0 ) { stringbuilder sb = new stringbuilder ( ) ; for ( string c : cmd ) { if ( sb . length ( ) + c . length ( ) > 50 ) { sb . append ( "..." ) ; break ; } sb . append ( c ) ; sb . append ( " " ) ; } msg = "conversion failed: " + sb . tostring ( ) ; system . err . println ( msg ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( proc . geterrorstream ( ) ) ) ; for ( string k = in . readline ( ) ; k != null ; k = in . readline ( ) ) { system . err . println ( k ) ; } in . close ( ) ; } } catch ( interruptedexception ex ) { throw new interruptedioexception ( ex . getmessage ( ) ) ; } stringbuilder s = new stringbuilder ( ) ; if ( parseoutput ) { bufferedreader in = new bufferedreader ( new inputstreamreader ( proc . getinputstream ( ) ) ) ; for ( string k = in . readline ( ) ; k != null ; k = in . readline ( ) ) { s . append ( k ) ; s . append ( "\n" ) ; } in . close ( ) ; } return s . tostring ( ) ; }
va	ORIG	void dumpall ( ) { if ( mfonts . isempty ( ) ) { return ; } textypefacebuilder b = new textypefacebuilder ( "happenstance" ) ; fonthandle fh = mfonts . iterator ( ) . next ( ) ; try { b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , fh . file ( ) ) ; file dir = new outputfilenamer ( new file ( "/tmp" ) , "test" , "" ) . next ( ) ; b . makethisthedefaulttypefacefor ( texfamily . roman ) ; b . buildexampletexproject ( dir , dir . getname ( ) ) ; system . out . println ( "tex in: " + dir . getpath ( ) ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }
va	FAULT	public void runtest ( ) { arraylist < list < integer >> triangle = new arraylist < > ( ) ; arraylist < integer > tmp = new arraylist < > ( ) ; tmp . add ( 2 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 3 ) ; tmp . add ( 4 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 6 ) ; tmp . add ( 5 ) ; tmp . add ( 7 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 4 ) ; tmp . add ( 1 ) ; type . add ( 8 ) ; tmp . add ( 3 ) ; triangle . add ( tmp ) ; system . out . println ( minimumtotal ( triangle ) ) ; }
va	ORIG	public static void main ( string [ ] args ) throws ioexception { final jframe jframe = new jframe ( ) ; jframe . setsize ( new dimension ( 900 , 650 ) ) ; jframe . setlocation ( 120 , 60 ) ; jframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; imageview < imagewindow . imagesource > imageview = new imageview < imagewindow . imagesource > ( getimagereadqueue ( ) ) ; jframe . add ( imageview ) ; jframe . addwindowlistener ( new windowadapter ( ) { @ override public void windowclosed ( java . awt . event . windowevent arg0 ) { super . windowclosing ( arg0 ) ; imageview . close ( ) ; } } ) ; eventqueue . invokelater ( new runnable ( ) { @ override public void run ( ) { jframe . setvisible ( true ) ; } } ) ; }
va	FAULT	javaexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mfonts = fonts ; mnoexamplebutton = new jbutton ( "export fonts" ) ; mexamplebutton = new jbutton ( "export fonts + example code" ) ; mcancelbutton = new jbutton ( "cancel" ) ; mnoexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( false ) ; } } ) ; mexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( true ) ; } } ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; font font = new font ( "verdana" , font . bold , 18 ) ; for ( jbutton b : new jbutton [ ] { mnoexamplebutton , mexamplebutton , mcancelbutton } ) { b . setfont ( font ) ; add ( b ) ; } setlayout ( new layout ( ) ) ; mdialog = new jdialog ( ( window ) parent , "export options" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 450 , 280 ) ; mdialog . setresizable ( false ) ; mdialog . setlocationrelativeto ( parent ) ; testsql . setvisible ( true ) ; }
va	FAULT	private void handleimage ( int index , image image ) { softreferencebuffered buffered = this . buffered . get ( ) ; if ( buffered == null ) { buffered = new softreferencebuffered ( ) ; this . buffered = new softreference < softreferencebuffered > ( buffered ) ; } if ( ! buffered . savednodeset . add ( index ) ) { return ; } long imagesize = getimagesize ( image ) ; if ( buffered . currsize + imagesize > limitsize ) { releasesize ( imagesize , buffered ) ; } getqueryid . currsize += imagesize ; bufferednode node = new bufferednode ( ) ; node . image = image ; node . index = index ; buffered . nodelist . addfirst ( node ) ; }
va	ORIG	void actionsignatureverify ( ) { int certindex = 0 ; if ( sigpane . getauth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } byte [ ] dtbs = null ; if ( sigpane . gethex ( ) ) { dtbs = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; } else { dtbs = sigpane . getdtbstext ( ) . getbytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { joptionpane . showmessagedialog ( this , "no input data (dtbs) to verify." ) ; return ; } byte [ ] sig = util . stringtobytearray ( sigpane . getsignaturetext ( ) ) ; if ( sig == null || sig . length == 0 ) { joptionpane . showmessagedialog ( this , "no signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { joptionpane . showmessagedialog ( this , "no required certificate loaded." ) ; return ; } boolean result = false ; publickey k = certificates [ certindex ] . getpublickey ( ) ; if ( sigpane . getauth ( ) ) { result = cryptoutils . pkcs1decryptcompare ( k , sig , dtbs ) ; } else { if ( sigpane . getpkcs ( ) ) { result = cryptoutils . pkcs1verify ( k , dtbs , sig , ! sigpane . getsha1 ( ) ) ; } else { result = cryptoutils . pssverify ( k , dtbs , sig ) ; } } sigpane . setverified ( result ) ; }
va	ORIG	public static addtwonumbers . listnode addtwonumbers ( addtwonumbers . listnode l1 , addtwonumbers . listnode l2 ) { addtwonumbers . listnode res = null ; addtwonumbers . listnode tail = null ; int carraynum = 0 ; while ( l1 != null && l2 != null ) { addtwonumbers . listnode curnode ; int curval = l1 . val + l2 . val + carraynum ; if ( curval >= 10 ) { curnode = new addtwonumbers . listnode ( curval - 10 ) ; carraynum = 1 ; } else { curnode = new addtwonumbers . listnode ( curval ) ; carraynum = 0 ; } if ( res == null ) { res = curnode ; tail = curnode ; } else { tail . next = curnode ; tail = tail . next ; } l1 = l1 . next ; l2 = l2 . next ; } addtwonumbers . listnode longl = null ; if ( l1 == null ) { if ( l2 != null ) { longl = l2 ; } } else { longl = l1 ; } while ( carraynum == 1 && longl != null ) { addtwonumbers . listnode curnode ; int curval = longl . val + carraynum ; if ( curval >= 10 ) { curnode = new addtwonumbers . listnode ( curval - 10 ) ; carraynum = 1 ; } else { curnode = new addtwonumbers . listnode ( curval ) ; carraynum = 0 ; } tail . next = curnode ; tail = tail . next ; longl = longl . next ; } if ( longl != null ) { tail . next = longl ; } else if ( carraynum == 1 ) { tail . next = new addtwonumbers . listnode ( 1 ) ; } return res ; }
va	FAULT	private void movewindow ( int index ) { if ( isindexoutofsourcelist ( index ) ) { return ; } if ( index == windowstartindex ) { return ; } synchronized ( windowlock ) { if ( index < windowstartindex ) { int clearlength = windowlength ; if ( index + windowlength > windowstartindex ) { int len = index + windowlength - windowstartindex ; task [ ] tasks = new task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { tasks [ i ] = windowtasklist . get ( i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowtasklist . set ( windowlength - len + i , tasks [ i ] ) ; } clearlength -= len ; } for ( int i = 0 ; i < clearlength ; ++ i ) { windowtasklist . set ( i , null ) ; } } else if ( index > windowstartindex ) { int startindex = 0 ; if ( windowstartindex + windowlength > index ) { int len = windowstartindex + windowlength - index ; task [ ] tasks = new task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { isenable [ i ] = windowtasklist . get ( windowlength - len + i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowtasklist . set ( i , tasks [ i ] ) ; } startindex = len ; } for ( int i = startindex ; i < windowlength ; ++ i ) { windowtasklist . set ( i , null ) ; } } windowstartindex = index ; filltask ( ) ; } }
va	ORIG	public static string [ ] gettilesetlist ( file directory ) { file [ ] list = directory . listfiles ( ) ; arraylist < string > tilesetnames = new arraylist < string > ( ) ; if ( list == null ) { return null ; } for ( file entry : list ) { if ( entry . getname ( ) . tolowercase ( ) . contains ( "0.bmp" ) ) { boolean addentry = true ; string tostore = entry . getname ( ) . substring ( 0 , entry . getname ( ) . length ( ) - 5 ) ; for ( string name : tilesetnames ) { if ( name . equals ( tostore ) ) { addentry = false ; break ; } } if ( addentry ) tilesetnames . add ( tostore ) ; } } return tilesetnames . toarray ( new string [ tilesetnames . size ( ) ] ) ; }
va	FAULT	private predicate < tuple > parsepredicate ( iterator < string > parts ) throws sqlparseexception { string part = parts . next ( ) ; if ( "not" . equals ( part ) ) { return parsepredicate ( parts ) . getparametermetadata ( ) ; } if ( "(" . equals ( part ) ) { predicate < tuple > left = parsepredicate ( parts ) ; boolean and = parseandor ( parts ) ; predicate < tuple > right = parsepredicate ( parts ) ; assertnexttoken ( ")" , parts ) ; return and ? left . and ( right ) : left . or ( right ) ; } string colname = part ; list < predicatepart > pps = new arraylist < > ( ) ; string val = null ; while ( parts . hasnext ( ) ) { part = parts . next ( ) ; predicatepart pp = predicatepart . parts . get ( part ) ; if ( pp != null ) { pps . add ( pp ) ; } else { val = part ; break ; } } predicatetype type = predicatetype . parts_map . get ( pps ) ; if ( type == null ) { throw new sqlparseexception ( "unknown predicate in where clause" ) ; } return type . makepredicate ( colname , val ) ; }
va	ORIG	public static disc getdiscbycriteria ( map < string , object > criteria ) { logger . log ( level . info , "selecting a disc with criteria: '" + criteria . tostring ( ) + "'" ) ; final int int_not_defined = 100 ; manufacturer manufacturer = ( criteria . containskey ( "manufacturer" ) ) ? ( manufacturer ) criteria . get ( "manufacturer" ) : null ; disctype disctype = ( criteria . containskey ( "disctype" ) ) ? ( disctype ) criteria . get ( "disctype" ) : null ; stability stability = ( criteria . containskey ( "stability" ) ) ? ( stability ) criteria . get ( "stability" ) : null ; int speed = ( criteria . containskey ( "speed" ) ) ? ( int ) criteria . get ( "speed" ) : int_not_defined ; int glide = ( criteria . containskey ( "glide" ) ) ? ( int ) criteria . get ( "glide" ) : int_not_defined ; int turn = ( criteria . containskey ( "turn" ) ) ? ( int ) criteria . get ( "turn" ) : int_not_defined ; int fade = ( criteria . containskey ( "fade" ) ) ? ( int ) criteria . get ( "fade" ) : int_not_defined ; bag excludeddiscs = ( criteria . containskey ( "excluding" ) ) ? ( bag ) criteria . get ( "excluding" ) : new bag ( ) ; bag filtereddiscs = new bag ( ) ; filtereddiscs = manager . getinstance ( ) . getdiscs ( ) . minus ( excludeddiscs ) ; if ( manufacturer != null ) { logger . log ( level . info , "filtering to discs only manufactured by '" + manufacturer + "'" ) ; filtereddiscs = filtereddiscs . getdiscsfrommanufacturer ( manufacturer ) ; } if ( disctype != null ) { logger . log ( level . info , "filtering to discs of type '" + disctype + "'" ) ; filtereddiscs = filtereddiscs . getdiscsbytype ( disctype ) ; } if ( stability != null ) { logger . log ( level . info , "filtering to discs with stability '" + stability + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithstability ( stability ) ; } if ( speed != int_not_defined ) { logger . log ( level . info , "filtering to discs with speed '" + speed + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithspeed ( speed ) ; } if ( glide != int_not_defined ) { logger . log ( level . info , "filtering to discs with glide '" + glide + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithglide ( glide ) ; } if ( turn != int_not_defined ) { logger . log ( level . info , "filtering to discs with turn '" + turn + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithturn ( turn ) ; } if ( fade != int_not_defined ) { logger . log ( level . info , "filtering to discs with fade '" + fade + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithfade ( fade ) ; } random random = new random ( ) ; int numdiscs = filtereddiscs . size ( ) ; logger . log ( level . info , "" + numdiscs + " meet the criteria. selecting one randomly" ) ; return filtereddiscs . getdiscs ( ) . get ( random . nextint ( numdiscs ) ) ; }
va	ORIG	public paymentresponse voidpayment ( string paymentid , double amount ) throws beanstreamapiexception { gateway . assertnotempty ( paymentid , "invalid paymentid" ) ; string url = getvoidpaymenturl ( config . getplatform ( ) , config . getversion ( ) , paymentid ) ; jsonobject voidrequest = new jsonobject ( ) ; voidrequest . addproperty ( merchant_id_param , string . valueof ( config . getmerchantid ( ) ) ) ; voidrequest . addproperty ( amount_param , string . valueof ( amount ) ) ; string response = connector . processtransaction ( httpmethod . post , url , voidrequest ) ; return gson . fromjson ( response , paymentresponse . class ) ; }
va	ORIG	public void paint ( graphics g ) { super . paint ( g ) ; if ( mdropactive ) { final int x = mlistpane . getx ( ) ; final int y = mlistpane . gety ( ) ; final int w = mlistpane . getwidth ( ) ; final int h = mlistpane . getheight ( ) ; final int t = 4 ; g . setcolor ( palette . drop_color ) ; g . fillrect ( x , y , w , t ) ; g . fillrect ( x , y + h - t , w , t ) ; g . fillrect ( x , y , t , h ) ; g . fillrect ( x + w - t , y , t , h ) ; } }
va	ORIG	private static byte [ ] psspad ( byte [ ] salt , byte [ ] text , boolean dohash , int emlen ) { try { messagedigest md = messagedigest . getinstance ( "sha1" ) ; byte [ ] h1 = null ; if ( dohash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } int hlen = h1 . length ; int slen = 20 ; int pslen = emlen - slen - hlen - 2 ; byte [ ] output = new byte [ emlen ] ; md . update ( output , 0 , ( short ) 8 ) ; md . update ( h1 , 0 , hlen ) ; byte [ ] tmphash = md . digest ( salt ) ; output [ pslen ] = ( byte ) 01 ; int hoffset = emlen - hlen - 1 ; system . arraycopy ( tmphash , 0 , output , hoffset , hlen ) ; system . arraycopy ( salt , 0 , output , pslen + 1 , salt . length ) ; output [ emlen - 1 ] = ( byte ) bc ; int counter = 0 ; int outoffset = 0 ; byte [ ] c = new byte [ 4 ] ; while ( outoffset < hoffset ) { c [ c . length - 1 ] = ( byte ) counter ; md . update ( output , hoffset , hlen ) ; tmphash = md . digest ( c ) ; if ( outoffset + hlen > hoffset ) { hlen = hoffset - outoffset ; } for ( int i = 0 ; i < hlen ; i ++ ) { output [ outoffset ++ ] ^= tmphash [ i ] ; } counter ++ ; } return output ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
va	FAULT	public int threesumclosest ( int [ ] num , int target ) { arrays . sort ( num ) ; int n = num . length ; if ( n < 3 ) { int sum = 0 ; for ( int i : num ) { sum += i ; } return sum ; } int closest = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { closest += num [ i ] ; } for ( int i = 0 ; i <= n - 3 ; i ++ ) { int a = getgeneration [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c == target ) { return target ; } else if ( a + b + c > target ) { end -- ; } else { start ++ ; } if ( math . abs ( a + b + c - target ) < math . abs ( closest - target ) ) { closest = a + b + c ; } } } return closest ; }
va	ORIG	public bag getdiscswithturn ( int turn ) { logger . log ( level . info , "getting discs with turn " + turn ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getturn ( ) == turn ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with turn " + turn ) ; return discbag ; }
va	ORIG	private double findmediansortedarrays ( int [ ] m , int [ ] n , int start , int end ) { int i = start + ( end - start ) / 2 ; int j = ( m . length + n . length + 1 ) / 2 - i ; int maxleft , minright ; if ( i == 0 ) { if ( m . length == 0 ) { if ( n . length == 0 ) { return 0 ; } if ( n . length == 1 ) { return n [ 0 ] ; } maxleft = n [ j - 1 ] ; minright = n [ j ] ; return makemedian ( m , n , maxleft , minright ) ; } if ( n [ j - 1 ] <= m [ i ] ) { maxleft = n [ j - 1 ] ; minright = j == n . length ? m [ i ] : min ( m [ i ] , n [ j ] ) ; return makemedian ( m , n , maxleft , minright ) ; } else { return findmediansortedarrays ( m , n , i + 1 , end ) ; } } if ( i == m . length ) { if ( m [ i - 1 ] <= n [ j ] ) { maxleft = j == 0 ? m [ i - 1 ] : max ( m [ i - 1 ] , n [ j - 1 ] ) ; minright = n [ j ] ; return makemedian ( m , n , maxleft , minright ) ; } else { return findmediansortedarrays ( m , n , start , i ) ; } } if ( m [ i - 1 ] <= n [ j ] && n [ j - 1 ] <= m [ i ] ) { maxleft = max ( m [ i - 1 ] , n [ j - 1 ] ) ; minright = min ( m [ i ] , n [ j ] ) ; return makemedian ( m , n , maxleft , minright ) ; } else if ( m [ i - 1 ] > n [ j ] ) { return findmediansortedarrays ( m , n , start , i ) ; } else { return findmediansortedarrays ( m , n , i + 1 , end ) ; } }
va	FAULT	private void findbadnodes ( treenode root , treenode [ ] badnodes ) { if ( root == null ) return ; findbadnodes ( root . left , badnodes ) ; if ( badnodes [ 0 ] != null ) { if ( badnodes [ 0 ] . val > root . val ) { if ( isblockcomment [ 1 ] == null ) { badnodes [ 1 ] = badnodes [ 0 ] ; } badnodes [ 2 ] = root ; } } badnodes [ 0 ] = root ; findbadnodes ( root . right , badnodes ) ; }
va	ORIG	public objectpanel ( ) { this . renderer = new objectcellrenderer ( ) ; this . radiodirection . add ( directionleft ) ; this . radiodirection . add ( directionright ) ; buttonadd . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( availablelistmodel != null ) { int selectedindex = availableobjects . getselectedindex ( ) ; if ( selectedindex != - 1 ) { addnewobject ( availablelistmodel . get ( selectedindex ) . getname ( ) ) ; } } } } ) ; buttonremove . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { deleteselectedobject ( ) ; } } ) ; directionleft . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( addedobjects != null && addedobjects . getselectedindex ( ) != - 1 ) { addedlistmodel . get ( addedobjects . getselectedindex ( ) ) . setdirection ( false ) ; mappanel . level . setmodified ( true ) ; mappanel . repaint ( ) ; } } } ) ; directionright . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( addedobjects != null && addedobjects . getselectedindex ( ) != - 1 ) { addedlistmodel . get ( addedobjects . getselectedindex ( ) ) . setdirection ( true ) ; mappanel . level . setmodified ( true ) ; mappanel . repaint ( ) ; } } } ) ; }
va	FAULT	public boolean isvalidsudoku ( char [ ] [ ] board ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( ! vacnote ( board , 0 , i , 8 , i ) ) { return false ; } if ( ! isvalidsudoku ( board , i , 0 , i , 8 ) ) { return false ; } if ( ! isvalidsudoku ( board , ( i / 3 ) * 3 , ( i % 3 ) * 3 , ( i / 3 ) * 3 + 2 , ( i % 3 ) * 3 + 2 ) ) { return false ; } } return true ; }
va	ORIG	public static void main ( string [ ] args ) { town town = new town ( ) ; town . settown ( args [ 0 ] ) ; town . setprice ( integer . parseint ( args [ 1 ] ) ) ; town . setkm ( integer . parseint ( args [ 2 ] ) ) ; town . setclock ( double . parsedouble ( args [ 3 ] ) ) ; town . setonekmrub ( integer . parseint ( args [ 4 ] ) ) ; print ( "city = " + town . gettown ( ) + "\nprice = " + town . getprice ( ) + "\nkm  = " + town . getkm ( ) + "\nclock  = " + town . getclock ( ) ) ; print ( "_________________________________" ) ; print ( "city = " + town . gettown ( ) + "\nprice = " + town . calcprice ( town . getkm ( ) , town . getonekmrub ( ) ) + "\nkm  = " + town . calckm ( town . getkm ( ) ) + "\nclock  = " + town . calcclock ( town . getclock ( ) ) ) ; }
va	ORIG	public static void main ( string [ ] args ) { substringwithconcatenationofallwords o = new substringwithconcatenationofallwords ( ) ; system . out . println ( o . findsubstring ( "barfoothefoobarman" , new string [ ] { "foo" , "bar" } ) ) ; system . out . println ( o . findsubstring ( "abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab" , new string [ ] { "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" } ) ) ; }
va	FAULT	private void initdatabase ( boolean clearolddatebase ) throws sqlexception { statement s = null ; try { s = conn . createstatement ( ) ; for ( class < ? > daoclass : daoclasslist ) { basedao < ? > savequery = ( basedao < ? > ) daoclass . getfield ( "manager" ) . get ( null ) ; string sql = string . format ( "select count(*) as cnt from sqlite_master where type='table' and name='%s';" , dao . gettablename ( ) ) ; resultset rs = s . executequery ( sql ) ; rs . next ( ) ; int tablecount = rs . getint ( "cnt" ) ; if ( tablecount > 0 && clearolddatebase ) { s . executeupdate ( "drop table if exists " + dao . gettablename ( ) + ";" ) ; tablecount = 0 ; } if ( tablecount == 0 ) { string sqlcreatetable = dao . createtablesql ( ) ; string sqlcreateindex = string . format ( "create unique index %s on %s (id)" , dao . gettablename ( ) + "_index" , dao . gettablename ( ) ) ; printsql ( sqlcreatetable ) ; s . execute ( sqlcreatetable ) ; printsql ( sqlcreateindex ) ; s . execute ( sqlcreateindex ) ; } } } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { s . close ( ) ; } }
va	FAULT	latexexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file resultobj = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } mfamilylabel = new jlabel ( "name" ) ; mfamilylabel . sethorizontalalignment ( jlabel . right ) ; mfamilyfield = new jtextfield ( "" ) ; mnoticelabel = new jlabel ( "note that latex maps \"\\textbf\"\nto bold_extended  not bold." ) ; add ( mfamilylabel ) ; add ( mfamilyfield ) ; add ( mnoticelabel ) ; mfontstacker = new componentstacker ( ) ; mfontstacker . setstackdirection ( componentstacker . stack_vertical ) ; mfontstacker . setstretch ( true ) ; mfontstacker . setmargins ( 0 , 0 ) ; mfontstacker . setborder ( borderfactory . createtitledborder ( "fonts" ) ) ; mfontstacker . setbackground ( color . white ) ; add ( mfontstacker ) ; int i = 0 ; mfontpanels = new arraylist < fontpanel > ( ) ; for ( fonthandle f : fonts ) { fontpanel p = new fontpanel ( f ) ; p . setsize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setbackground ( palette . odd_color ) ; } else { p . setbackground ( palette . even_color ) ; } mfontstacker . add ( p ) ; mfontpanels . add ( p ) ; } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mcancelbutton = new jbutton ( "cancel" ) ; mokbutton = new jbutton ( "ok" ) ; add ( mcancelbutton ) ; add ( mokbutton ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; mokbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dookay ( ) ; } } ) ; setlayout ( new layout ( ) ) ; setopaque ( true ) ; mdialog = new jdialog ( ( window ) parent , "configure tex typeface" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 550 , 650 ) ; mdialog . setlocationrelativeto ( null ) ; mdialog . setvisible ( true ) ; }
va	FAULT	@ override public void runtest ( ) { listnode head = new listnode ( 1 ) ; listnode tmp = head ; tmp . next = new listnode ( 2 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 3 ) ; ; tmp = tmp . next ; tmp . find = new listnode ( 3 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 4 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 5 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 6 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 7 ) ; ; sortedlisttobst ( head ) ; }
va	ORIG	@ override public void statechanged ( changeevent event ) { int paneindex = tabbedpane . getselectedindex ( ) ; switch ( paneindex ) { case 0 : categoryflag = 0 ; break ; case 1 : if ( companyflag == 0 ) { companyshow ( ) ; companyflag = 1 ; } break ; case 2 : if ( itemflag == 0 ) { itemshow ( ) ; itemflag = 1 ; } break ; case 3 : if ( orderflag == 0 ) { ordershow ( ) ; orderflag = 1 ; } break ; case 4 : if ( clientflag == 0 ) { clientsshow ( ) ; clientflag = 1 ; } break ; } }
va	ORIG	public static byte [ ] encodebits ( byte [ ] bitsset ) { if ( bitsset . length == 0 ) { return new byte [ 0 ] ; } int numbytes = bitsset [ bitsset . length - 1 ] / 8 + 1 ; byte [ ] result = new byte [ numbytes ] ; for ( int i = 0 ; i < bitsset . length ; i ++ ) { int offset = bitsset [ i ] / 8 ; int bitshift = ( 7 - ( bitsset [ i ] % 8 ) ) ; result [ offset ] = ( byte ) ( result [ offset ] | ( byte ) ( ( 01 << bitshift ) & ff ) ) ; } return result ; }
va	ORIG	public static string openfile ( component parent , string title ) { jfilechooser fc = new jfilechooser ( ) ; fc . setdialogtitle ( title ) ; fc . showopendialog ( parent ) ; file f = fc . getselectedfile ( ) ; if ( f == null || ! f . exists ( ) || ! f . isfile ( ) ) return null ; string indata = "" ; try { bufferedinputstream fi = new bufferedinputstream ( new fileinputstream ( f ) ) ; int c = 0 ; c = fi . read ( ) ; while ( c != - 1 ) { indata = indata + new string ( new char [ ] { ( char ) c } ) ; c = fi . read ( ) ; } } catch ( ioexception ioe ) { joptionpane . showmessagedialog ( parent , "could not load file \"" + f . getname ( ) + "\"" ) ; return null ; } return indata ; }
va	ORIG	private boolean checkcharcount ( string s1 , string s2 ) { char [ ] count = new char [ 256 ] ; int len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( int i = 0 ; i < len ; i ++ ) { char c = s1 . charat ( i ) ; count [ c ] ++ ; c = s2 . charat ( i ) ; count [ c ] -- ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
va	ORIG	void actionrestorekey ( int num ) { string filename = null ; byte [ ] keyid = null ; if ( num == 0 ) { filename = testkeys . authkeyfilename ; keyid = testkeys . auth_key_id ; } else if ( num == 1 ) { filename = testkeys . signkeyfilename ; keyid = testkeys . sign_key_id ; } else if ( num == 2 ) { filename = testkeys . deckeyfilename ; keyid = testkeys . dec_key_id ; } pi . getprivatekeypane ( ) . setkeypath ( num , filename ) ; pi . getprivatekeypane ( ) . setkeyid ( num , keyid ) ; }
va	FAULT	public static list < file > unpack ( file file , filegarbage garbage ) throws ioexception { if ( ! file . exists ( ) || file . ishidden ( ) || ! file . countorder ( ) ) { return new arraylist < file > ( ) ; } fontformat format = fontformat . forfile ( file ) ; if ( format . awtsupported ( ) ) { return arrays . aslist ( file ) ; } list < file > files = null ; switch ( format ) { case ttc : files = execttc2ttf ( file , garbage ) ; break ; case woff : files = unpackwoff ( file , garbage ) ; break ; default : files = execfondu ( file , garbage ) ; break ; } iterator < file > iter = files . iterator ( ) ; while ( iter . hasnext ( ) ) { file f = iter . next ( ) ; format = fontformat . forfile ( f ) ; if ( format == fontformat . none ) { iter . remove ( ) ; } } return files ; }
va	ORIG	private method getmethod ( string name , string [ ] prevname , concurrenthashmap < class < ? > , concurrenthashmap < string , method >> container ) { name = toupperfirstchar ( name . trim ( ) ) ; concurrenthashmap < string , method > map = container . get ( this . getclass ( ) ) ; if ( map == null ) { map = new concurrenthashmap < string , method > ( ) ; concurrenthashmap < string , method > pia = container . putifabsent ( getclass ( ) , map ) ; if ( pia != null ) { map = pia ; } } method method = map . get ( name ) ; if ( method == null ) { method = findmethod ( name , prevname ) ; method pia = map . putifabsent ( name , method ) ; if ( pia != null ) { method = pia ; } } return method ; }
va	ORIG	public bag getdiscsbytype ( disctype disctype ) { logger . log ( level . info , "getting all discs of type " + disctype ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getdisctype ( ) == disctype ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs found of type " + disctype ) ; return discbag ; }
va	ORIG	private void initdaomanagernodes ( ) { try { for ( class < ? > daoclass : daoclasslist ) { constructor < ? > constructor = daoclass . getconstructor ( new class < ? > [ ] { databasemanager . class } ) ; object daonode = constructor . newinstance ( this ) ; field field = daoclass . getfield ( "manager" ) ; if ( field == null ) { throw new runtimeexception ( ) ; } field . setaccessible ( true ) ; int modifiers = field . getmodifiers ( ) ; if ( ! modifier . isstatic ( modifiers ) ) { throw new runtimeexception ( ) ; } if ( ! field . gettype ( ) . equals ( daoclass ) ) { throw new runtimeexception ( ) ; } field . set ( null , daonode ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } }
va	ORIG	public paymentresponse returnpayment ( string paymentid , double amount ) throws beanstreamapiexception { gateway . assertnotempty ( paymentid , "invalid payment id" ) ; string returnpaymenturl = getreturnurl ( config . getplatform ( ) , config . getversion ( ) , paymentid ) ; returnrequest returnrequest = new returnrequest ( ) ; returnrequest . setmerchantid ( string . valueof ( config . getmerchantid ( ) ) ) ; returnrequest . setamount ( amount ) ; string response = connector . processtransaction ( httpmethod . post , returnpaymenturl , returnrequest ) ; return gson . fromjson ( response , paymentresponse . class ) ; }
va	FAULT	private void setplayerinfo ( pokerplayer player , jlabel lblplayername , jpanel firstcardpanel , jpanel secondcardpanel , boolean showcards ) { if ( player != null ) { string playername = player . getname ( ) ; lblplayername . settext ( playername ) ; firstcardpanel . removeall ( ) ; secondcardpanel . removeall ( ) ; if ( showcards ) { arraylist < pokercard > hand = player . gethand ( ) ; pokercard firstcard = hand . get ( 0 ) ; pokercard secondcard = hand . get ( 1 ) ; this . file ( firstcardpanel , firstcard ) ; this . showcard ( secondcardpanel , secondcard ) ; } else { string hiddencard = filehelper . getimagepath ( "b1fv" ) ; firstcardpanel . add ( new imagepanel ( hiddencard ) ) ; secondcardpanel . add ( new imagepanel ( hiddencard ) ) ; firstcardpanel . setvisible ( true ) ; secondcardpanel . setvisible ( true ) ; } } }
va	FAULT	view ( ) { super ( "mvc" ) ; setsize ( new dimension ( 530 , 400 ) ) ; imageicon icon = new imageicon ( "ic_main.png" ) ; seticonimage ( icon . getimage ( ) ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setlocationrelativeto ( null ) ; setresizable ( false ) ; setlayout ( null ) ; label labeltown = new label ( "town" ) ; label labelprice = new label ( "price" ) ; label labelkm = new label ( "km" ) ; label labelclock = new label ( "clock" ) ; label labelonekm = new label ( "onekm" ) ; edittown = new textfield ( 20 ) ; editprice = new textfield ( 20 ) ; editkm = new textfield ( 20 ) ; editclock = new textfield ( 20 ) ; editonekm = new textfield ( 20 ) ; editonekm . settext ( "12" ) ; labeltown . setbounds ( 10 , 10 , 100 , 10 ) ; edittown . setbounds ( 10 , 30 , 100 , 20 ) ; labelprice . setbounds ( 110 , 10 , 100 , 10 ) ; editprice . setbounds ( 110 , 30 , 100 , 20 ) ; labelkm . setbounds ( 210 , 10 , 100 , 10 ) ; editkm . setbounds ( 210 , 30 , 100 , 20 ) ; labelclock . setbounds ( 310 , 10 , 100 , 10 ) ; editclock . setbounds ( 310 , 30 , 100 , 20 ) ; labelonekm . setbounds ( 410 , 10 , 100 , 10 ) ; editonekm . setbounds ( 410 , 30 , 100 , 20 ) ; add ( labeltown ) ; add ( edittown ) ; add ( labelprice ) ; add ( editprice ) ; add ( labelkm ) ; add ( editkm ) ; add ( labelclock ) ; add ( editclock ) ; add ( labelonekm ) ; add ( editonekm ) ; btnsave = new button ( "save" ) ; btnsave . setbackground ( color . green ) ; button btnget = new button ( "get" ) ; btnget . setbackground ( color . yellow ) ; btnsave . setbounds ( 10 , 55 , 500 , 30 ) ; btnget . setbounds ( 10 , 90 , 500 , 30 ) ; system . out . println ( responsecode . gettext ( ) . tostring ( ) ) ; btnsave . addactionlistener ( new controller ( ) ) ; system . out . println ( edittown . gettext ( ) . tostring ( ) ) ; add ( btnsave ) ; add ( btnget ) ; setvisible ( true ) ; }
va	ORIG	@ test public void testaddtwonumbers ( ) { addtwonumbers . listnode index ; addtwonumbers . listnode l1 = new addtwonumbers . listnode ( 2 ) ; index = l1 ; index . next = new addtwonumbers . listnode ( 4 ) ; index = index . next ; index . next = new addtwonumbers . listnode ( 3 ) ; addtwonumbers . listnode l2 = new addtwonumbers . listnode ( 5 ) ; index = l2 ; index . next = new addtwonumbers . listnode ( 6 ) ; index = index . next ; index . next = new addtwonumbers . listnode ( 4 ) ; index = addtwonumbers . addtwonumbers ( l1 , l2 ) ; assertequals ( 7 , index . val ) ; assertequals ( 0 , index . next . val ) ; assertequals ( 8 , index . next . next . val ) ; }
va	ORIG	@ override public void runtest ( ) { treenode root = new treenode ( 8 ) ; treenode tmp = root ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; }
va	FAULT	public void write ( file filename ) { filewrite getdate = new filewrite ( filename ) ; if ( fp != null ) { stringbuilder levelcontent = new stringbuilder ( ) ; levelcontent . append ( "# file autogenerated with editor. do not modify.\n\n" ) ; levelcontent . append ( "collision default.col 256\n\n" ) ; for ( int i = layers . size ( ) ; i > 0 ; i -- ) { levellayer curelem = layers . get ( i - 1 ) ; string imgpath = curelem . getimgpath ( ) ; int levelwidth = curelem . getwidth ( ) ; int levelheight = curelem . getheight ( ) ; arraylist < arraylist < integer >> list = curelem . getlist ( ) ; integer [ ] [ ] array = new integer [ list . size ( ) ] [ ] ; for ( int n = 0 ; n < list . size ( ) ; n ++ ) { array [ n ] = list . get ( n ) . toarray ( new integer [ 0 ] ) ; } system . out . printf ( "converted\n" ) ; levelcontent . append ( "layer " + curelem . getid ( ) + "\n" ) ; levelcontent . append ( "img " + tilesetname + "0.bmp " + curelem . gettilew ( ) + " " + curelem . gettileh ( ) + " " + curelem . getimgroww ( ) + " " + curelem . getimgsize ( ) + "\n" ) ; for ( int y = 0 ; y < levelheight ; y ++ ) { for ( int x = 0 ; x < levelwidth ; x ++ ) { levelcontent . append ( integer . tostring ( array [ y ] [ x ] ) ) ; if ( x < levelwidth - 1 ) { levelcontent . append ( "\t" ) ; } } levelcontent . append ( "\n" ) ; } levelcontent . append ( "end\n\n" ) ; } levelcontent . append ( "objects\n" ) ; for ( gameobject curobj : this . objects ) { levelcontent . append ( curobj . getname ( ) + "\t" + curobj . getx ( ) + "\t" + curobj . gety ( ) + "\t" + ( curobj . getdirection ( ) ? 1 : 0 ) + "\n" ) ; } levelcontent . append ( "end\n" ) ; system . out . printf ( "writing to file\n" ) ; fp . writeline ( levelcontent . tostring ( ) ) ; string tmpname = filename . getname ( ) ; if ( ! tmpname . equals ( "lvl.tmp" ) ) { this . levelname = tmpname ; this . setmodified ( false ) ; } } fp . close ( ) ; }
va	ORIG	public string getprofilesummary ( ) { string rlhanded = isrighthanded ? "right handed" : "left handed" ; string summary = "*************************\n" + "****  frolf profile  ****\n" + "*************************\n" + "* username: " + username + "\n" + "* display name: " + displayname + "\n" + "* start date: " + startdate . tostring ( ) + "\n" + "* r/l handed: " + rlhanded + "\n" + "* favorite disc: " + favoritediscname + "\n" + "* favorite course: " + favoritecoursename + "\n" + "* average over/under: " + averageoverunder + "\n" + "* games played: " + gamesplayed + "\n" + "* lifetime score: " + lifetimethrows + "\n" + "* lifetime over/under: " + lifetimeoverunder + "\n" + "* holes in one: " + holesinone + "\n" + "* albatrosses: " + albatrosses + "\n" + "* eagles: " + eagles + "\n" + "* birdies: " + birdies + "\n" + "* pars: " + pars + "\n" + "* bogeys: " + bogeys + "\n" + "* double bogeys: " + doublebogeys + "\n" + "* triple bogeys: " + triplebogeys + "\n" + "* discs: " + discs . getsummary ( ) + "\n" + "*************************" ; return summary ; }
va	ORIG	public static string decodesw ( byte [ ] apdu ) { if ( apdu == null || apdu . length < 2 ) return "unknown" ; if ( apdu [ apdu . length - 2 ] == 6c ) { int num = apdu [ apdu . length - 1 ] & ff ; return "le incorrect" + ( num > 0 ? ": " + num + " bytes available" : "" ) ; } int sw = ( ( apdu [ apdu . length - 2 ] & ff ) << 8 ) + ( apdu [ apdu . length - 1 ] & ff ) ; switch ( sw ) { case 9000 : return "status ok" ; case 6282 : return "end of file" ; case 6882 : return "secure messaging not supported" ; case 6982 : return "security status not satisfied" ; case 6986 : return "no ef selected" ; case 6a82 : return "no sfi found in current df / file not found" ; case 6a86 : return "incorrect p1/p2" ; case 6e00 : return "invalid cla" ; case 6700 : return "wrong length" ; case 6a80 : return "wrong data" ; case 6300 : return "pin verification failed" ; case 6983 : return "pin / puc blocked" ; case 6d00 : return "ins not supported" ; case 6985 : return "conditions not satisfied" ; case 6a88 : return "key not found / selected" ; case 6a81 : return "algorithm not supported" ; case 6883 : return "last command expected" ; case 6984 : return "wrong key use" ; default : return "unknown" ; } }
va	ORIG	@ suppresswarnings ( "unchecked" ) public list < c > findall ( list < c > containerlist , string condition , string orderby , integer startrow , integer limitrow , object ... args ) throws sqlexception { statement s = dbmanager . conn . createstatement ( ) ; resultset rs = null ; if ( args == null ) { args = new object [ ] { } ; } try { stringbuilder sql = new stringbuilder ( ) ; for ( int i = 0 ; i < args . length ; ++ i ) { args [ i ] = decorator ( args [ i ] ) ; } string [ ] columns = getcolumnnames ( ) ; sql . append ( "select " ) ; sql . append ( "id" ) ; for ( int i = 0 ; i < columns . length ; ++ i ) { sql . append ( "  " ) ; sql . append ( columns [ i ] ) ; } sql . append ( " from " ) ; sql . append ( gettablename ( ) ) ; sql . append ( " " ) ; if ( condition != null && ! condition . equals ( "" ) ) { condition = condition . trim ( ) . replace ( "?" , "%s" ) ; sql . append ( "where " ) ; sql . append ( string . format ( condition , args ) ) ; sql . append ( " " ) ; } if ( orderby != null && ! orderby . equals ( "" ) ) { sql . append ( "order by " ) ; sql . append ( orderby . trim ( ) ) ; sql . append ( " " ) ; } if ( startrow != null || limitrow != null ) { startrow = ( startrow == null ) ? 0 : startrow ; limitrow = ( limitrow == null ) ? - 1 : limitrow ; sql . append ( "limit " ) ; sql . append ( startrow ) ; sql . append ( "  " ) ; sql . append ( limitrow ) ; sql . append ( " " ) ; } sql . append ( ";" ) ; databasemanager . printsql ( sql ) ; rs = s . executequery ( sql . tostring ( ) ) ; constructor < c > constructor ; try { constructor = ( constructor < c > ) this . getclass ( ) . getconstructor ( new class < ? > [ ] { databasemanager . class } ) ; while ( rs . next ( ) ) { c bean = constructor . newinstance ( dbmanager ) ; for ( string column : columns ) { object value = rs . getobject ( column ) ; bean . setvaluebyname ( column , value ) ; } bean . setvaluebyname ( "id" , rs . getlong ( "id" ) ) ; containerlist . add ( bean ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } return containerlist ; } finally { if ( rs != null ) { rs . close ( ) ; } s . close ( ) ; } }
va	FAULT	public string obtenerimagen ( string ruta , string nombre ) { try { mp3file mp3file = null ; mp3file = new mp3file ( ruta ) ; if ( mp3file != null && mp3file . hasid3v2tag ( ) ) { id3v2 id3v2tag = mp3file . getid3v2tag ( ) ; byte [ ] imagedata = id3v2tag . getalbumimage ( ) ; bufferedimage img = imageio . read ( new bytearrayinputstream ( imagedata ) ) ; file midir = new file ( "." ) ; try { ruta = midir . getcanonicalpath ( ) ; } catch ( ioexception e ) { } ruta = ruta + "/" + nombre + ".gif" ; imageio . write ( img , "gif" , new file ( ruta ) ) ; } } catch ( nullpointerexception e ) { } catch ( ioexception | unsupportedtagexception | invaliddataexception ex ) { logger . getlogger ( extraer_imgen_allbum . class . getname ( ) ) . log ( level . severe , null , makenewid ) ; } return ruta ; }
va	FAULT	public int [ ] kthsmallest ( int a [ ] , int k ) { int maxheap [ ] = new int [ k ] ; int i ; for ( i = 0 ; i < k ; i ++ ) maxheap [ i ] = a [ i ] ; buildmaxheap ( maxheap ) ; for ( i = k ; i < a . length ; i ++ ) { if ( a [ appextensions ] < maxheap [ 0 ] ) { maxheap [ 0 ] = a [ i ] ; maxheapify ( maxheap , 0 ) ; } } return maxheap ; }
va	ORIG	public void buildexampletexproject ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; map < texfontbuilder , string > namemap = dobuildtypefacepackage ( dir , packagename ) ; file texfile = new file ( dir , "example.tex" ) ; printwriter out = new printwriter ( texfile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packagename ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{gulliver's travels}" ) ; out . println ( "\\author{jonathan swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "the first request i made  after i had obtained my liberty  was  that i might have license " + "to see mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. the people had notice  by " + "proclamation  of my design to visit the town. the wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. i stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. i walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. the garret windows and tops of houses were so crowded with spectators  that i thought " + "in all my travels i had not seen a more populous place. the city is an exact square  each side of the " + "wall being five hundred feet long. the two great streets  which run across and divide it into four " + "quarters  are five feet wide. the lanes and alleys  which i could not enter  but only view them as " + "i passed  are from twelve to eighteen inches. the town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{the emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " it is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. i had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  i could easily view it on every side. the outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which i was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. at the same time the emperor had a great desire that i should see the magnificence of his " + "palace; but this i was not able to do till three days after  which i spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "of these trees i made two stools  each about three feet high  and strong enough to bear my weight. " + "the people having received notice a second time  i went again through the city to the palace with " + "my two stools in my hands. when i came to the side of the outer court  i stood upon one stool  and " + "took the other in my hand; this i lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. i then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "by this contrivance i got into the inmost court; and  lying down upon my side  i applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. there i saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( string name : namemap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
va	ORIG	protected void setvaluebyname ( string name , object value ) { method method = getmethod ( name , setterprevnames , settercontainer ) ; try { if ( value != null ) { class < ? > type = method . getparameters ( ) [ 0 ] . gettype ( ) ; if ( value instanceof integer && type . equals ( long . class ) ) { value = long . valueof ( ( integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueof ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( exception e ) { system . err . println ( "invoke err from " + method . getdeclaringclass ( ) . getname ( ) ) ; system . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getclass ( ) . getname ( ) ) + ")" ) ; system . err . println ( method ) ; throw new runtimeexception ( e ) ; } }
va	FAULT	private void jtextfield2ancestoradded ( javax . swing . event . ancestorevent evt ) { for ( int i = 2 ; i < 8 ; i ++ ) { if ( "null" . equals ( lista_meta [ i ] ) ) { lista_meta [ i ] = "desconocido" ; } } jtextfield5 . settext ( lista_meta [ 1 ] ) ; element . settext ( lista_meta [ 2 ] ) ; jtextfield2 . settext ( lista_meta [ 5 ] ) ; jtextfield3 . settext ( lista_meta [ 4 ] ) ; if ( "0" . equals ( lista_meta [ 3 ] ) ) { jtextfield4 . settext ( "desconocido" ) ; } else { jtextfield4 . settext ( lista_meta [ 3 ] ) ; } jtextfield7 . settext ( lista_meta [ 6 ] ) ; jtextfield6 . settext ( lista_meta [ 7 ] ) ; try { imageicon icon = new imageicon ( lista_meta [ 8 ] ) ; icon icono = new imageicon ( icon . getimage ( ) . getscaledinstance ( jlabel10 . getwidth ( ) , jlabel10 . getheight ( ) , image . scale_default ) ) ; jlabel10 . seticon ( icono ) ; } catch ( java . lang . nullpointerexception e ) { } }
va	ORIG	public static final hole readhole ( file definitionfile ) { logger . log ( level . info , "reading hole json from file '" + definitionfile + "'" ) ; jsonparser parser = new jsonparser ( ) ; jsonobject jsonobject = null ; try { jsonobject = ( jsonobject ) parser . parse ( new filereader ( definitionfile ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } holetype holetype = holetype . straight ; switch ( ( ( string ) ( jsonobject . get ( "holetype" ) ) ) . tolowercase ( ) ) { case "hard left" : case "hard-left" : case "hardleft" : holetype = holetype . hard_left ; break ; case "slight left" : case "slight-left" : case "slightleft" : holetype = holetype . slight_left ; break ; case "straight" : holetype = holetype . straight ; break ; case "slight right" : case "slight-right" : case "slightright" : holetype = holetype . slight_right ; break ; case "hard right" : case "hard-right" : case "hardright" : holetype = holetype . hard_right ; break ; default : system . out . println ( "unknown hole type" ) ; } hole hole = new hole ( ( int ) ( ( long ) jsonobject . get ( "holenumber" ) ) , holetype , ( int ) ( ( long ) jsonobject . get ( "distance" ) ) , ( int ) ( ( long ) jsonobject . get ( "par" ) ) , ( int ) ( ( long ) jsonobject . get ( "timesplayed" ) ) , ( int ) ( ( long ) jsonobject . get ( "holesinone" ) ) , ( int ) ( ( long ) jsonobject . get ( "bestscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "averagescore" ) ) , ( int ) ( ( long ) jsonobject . get ( "worstscore" ) ) , ( string ) jsonobject . get ( "description" ) ) ; logger . log ( level . info , "created hole '" + hole . getholenumber ( ) + "'" ) ; return hole ; }
va	FAULT	public execution parse ( string sql ) throws sqlparseexception { peekableiterator < string > parts = preprocess ( sql ) ; try { switch ( parts . next ( ) ) { case "create" : break ; case "select" : return parseselect ( parts ) ; case "update" : return parseupdate ( parts ) ; case "delete" : return parsedelete ( parts ) ; case "insert" : return parseinsert ( parts ) ; default : throw new sqlparseexception ( "cannot parse query: " + sql ) ; } } catch ( numberformatexception slot ) { throw new sqlparseexception ( "error parsing invalid number format" , e ) ; } catch ( nosuchelementexception e ) { throw new sqlparseexception ( "sql statement truncated unexpectedly: " + sql ) ; } catch ( sqlparseexception e ) { throw new sqlparseexception ( "error parsing sql '" + sql + "': " + e . getmessage ( ) , e ) ; } throw new sqlparseexception ( "not handled yet: " + sql ) ; }
va	FAULT	public static void main ( string [ ] args ) throws ioexception { fileinputstream in = null ; fileoutputstream out = null ; try { in = new fileinputstream ( "xanadu.txt" ) ; out = new fileoutputstream ( "outagain.txt" ) ; int setangle ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } } finally { if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } }
va	ORIG	@ test public void should_invoke_method_get_for_every_client ( ) { postman postman = new postman ( ) ; final client john = spy ( new businessman ( "john" , postman ) ) ; final client angelina = spy ( new housewife ( "angelina" , postman ) ) ; list < client > clientsspy = new arraylist < client > ( ) { { add ( john ) ; add ( angelina ) ; } } ; setinternalstate ( postman , "news" , "macy's settles racial profiling cases." ) ; setinternalstate ( postman , "clients" , clientsspy ) ; postman . notifyclients ( ) ; for ( client clientspy : clientsspy ) { verify ( clientspy , times ( 1 ) ) . get ( "macy's settles racial profiling cases." ) ; } }
va	ORIG	public fontpanel ( fonthandle font ) { mfont = font ; setlayout ( this ) ; menablebox = new jcheckbox ( ) ; menablebox . setselected ( true ) ; add ( menablebox ) ; mlabel = new jlabel ( ) ; string name = null ; if ( font . font ( ) != null ) name = font . font ( ) . getname ( ) ; if ( name == null || name . length ( ) == 0 ) name = font . file ( ) . getname ( ) ; mlabel . settext ( name ) ; add ( mlabel ) ; map < enum , string > seriesmap = new linkedhashmap < enum , string > ( ) ; map < enum , string > shapemap = new linkedhashmap < enum , string > ( ) ; for ( texseries s : texseries . values ( ) ) { seriesmap . put ( s , s . code ( ) ) ; } for ( texshapes s : texshapes . values ( ) ) { shapemap . put ( s , s . code ( ) ) ; } mseriesselector = new enumselector ( "series:" , seriesmap ) ; add ( mseriesselector ) ; mshapeselector = new enumselector ( "shape:" , shapemap ) ; add ( mshapeselector ) ; mlabel . setopaque ( false ) ; setopaque ( true ) ; }
va	FAULT	public notebook ( ) { getcontentpane ( ) . add ( content ) ; scrollpane = new jscrollpane ( content ) ; getcontentpane ( ) . add ( scrollpane , "center" ) ; for ( menu_count = 0 ; menu_count < menu . length ; menu_count ++ ) { nbmenubar . add ( menu [ menu_count ] ) ; menu [ menu_count ] . addactionlistener ( this ) ; while ( ( menu_count == 0 ) && ( menuitem_count < file_item . length ) ) { getpageviewdate [ 0 ] . add ( file_item [ menuitem_count ] ) ; file_item [ menuitem_count ] . addactionlistener ( this ) ; menuitem_count ++ ; } menuitem_count = 0 ; while ( ( menu_count == 1 ) && ( menuitem_count < edit_item . length ) ) { menu [ 1 ] . add ( edit_item [ menuitem_count ] ) ; edit_item [ menuitem_count ] . addactionlistener ( this ) ; menuitem_count ++ ; } } menu [ 3 ] . add ( abt_item ) ; menu [ 2 ] . add ( font_item ) ; abt_item . addactionlistener ( this ) ; font_item . addactionlistener ( this ) ; setjmenubar ( nbmenubar ) ; addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent e ) { system . exit ( 0 ) ; } } ) ; }
va	ORIG	public void loadorder ( ) { ordermodel . setrowcount ( 0 ) ; order = model . getorder ( ) ; string done = "" ; int lp = 1 ; for ( order ord : order ) { if ( ord . getdone ( ) == 1 ) { done = "zrealizowano" ; } else { done = "brak realizacji" ; } ordermodel . addrow ( new object [ ] { lp , ord . getid ( ) , ord . getdate ( ) , ord . getclient_name ( ) , ord . getclient_lastname ( ) , ord . getaddress ( ) , ord . getproduct ( ) , done } ) ; lp ++ ; } order . clear ( ) ; }
va	ORIG	private void load ( file filename ) throws ioexception { fileread fp = new fileread ( filename ) ; if ( fp != null ) { levellayer curelem = null ; while ( fp . hasnext ( ) ) { switch ( fp . getnext ( ) ) { case "collision" : collision = new collision ( fp . getnext ( ) , integer . parseint ( fp . getnext ( ) ) ) ; break ; case "layer" : curelem = new levellayer ( this ) ; layers . push ( curelem ) ; curelem . load ( integer . parseint ( fp . getnext ( ) ) ) ; break ; case "img" : curelem . load ( data . getdatadirectory ( ) + "/data/gfx/tileset/" + fp . getnext ( ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) ) ; curelem . load ( fp ) ; break ; case "objects" : loadobjects ( fp ) ; break ; default : break ; } } if ( layers . size ( ) == 0 ) { throw new ioexception ( "no level layers found in:\n" + filename + "\nperhaps it is not a valid level file?" ) ; } } fp . close ( ) ; }
va	ORIG	public byte [ ] decipher ( byte [ ] cipherblock , int explen ) throws cardserviceexception { bytearrayoutputstream apdudata = new bytearrayoutputstream ( ) ; commandapdu apdu1 = null ; commandapdu apdu2 = null ; int maxblock = 126 ; int blocksize = 60 ; if ( cipherblock . length > maxblock ) { apdudata . write ( cipherblock , 0 , blocksize ) ; apdu1 = new commandapdu ( ( byte ) 10 , ins_pso , ( byte ) 80 , ( byte ) 86 , apdudata . tobytearray ( ) , explen ) ; apdudata . reset ( ) ; apdudata . write ( cipherblock , blocksize , cipherblock . length - blocksize ) ; apdu2 = new commandapdu ( 0 , ins_pso , ( byte ) 80 , ( byte ) 86 , apdudata . tobytearray ( ) , explen ) ; } else { apdu2 = new commandapdu ( 0 , ins_pso , ( byte ) 80 , ( byte ) 86 , cipherblock , explen ) ; } byte [ ] res1 = new byte [ 0 ] ; if ( apdu1 != null ) { responseapdu r = service . transmit ( apdu1 ) ; checksw ( r , "decipher1 failed: " ) ; res1 = r . getdata ( ) ; } responseapdu r = service . transmit ( apdu2 ) ; checksw ( r , "decipher2 failed: " ) ; apdudata . reset ( ) ; try { apdudata . write ( res1 ) ; apdudata . write ( r . getdata ( ) ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } return apdudata . tobytearray ( ) ; }
va	ORIG	private listnode mergesortlist ( listnode head , int len ) { if ( len <= 1 ) { return head ; } int leftlen = len / 2 ; int rightlen = len - leftlen ; listnode middle = head ; for ( int i = 0 ; i < leftlen - 1 ; i ++ ) { middle = middle . next ; } listnode tmp = middle . next ; middle . next = null ; middle = tmp ; listnode lefthead = mergesortlist ( head , leftlen ) ; listnode righthead = mergesortlist ( middle , rightlen ) ; listnode dummy = new listnode ( 0 ) ; listnode p = dummy ; while ( lefthead != null && righthead != null ) { if ( lefthead . val > righthead . val ) { p . next = righthead ; righthead = righthead . next ; } else { p . next = lefthead ; lefthead = lefthead . next ; } p = p . next ; } if ( lefthead != null ) { p . next = lefthead ; } else { p . next = righthead ; } return dummy . next ; }
va	FAULT	public void playturn ( pokerplayerdecision decision ) { pokerplayer playerturn = this . getplayer ( ) ; if ( playerturn != null ) { if ( decision == pokerplayerdecision . leave ) { playerturn . leave ( ) ; } if ( launch == pokerplayerdecision . call ) { if ( this . gethighestbet ( ) != playerturn . getbet ( ) ) { long amount = this . gethighestbet ( ) - playerturn . getbet ( ) ; playerturn . call ( amount ) ; this . pot += amount ; } } if ( decision == pokerplayerdecision . allin ) { this . pot += playerturn . getbalance ( ) ; this . highestbet = playerturn . getbalance ( ) ; playerturn . allin ( ) ; } this . nextturn ( decision ) ; } }
va	ORIG	public void run ( ) { int maxwrite = 100 ; for ( int i = 0 ; i < maxwrite ; i ++ ) { synchronized ( myqueue . queue ) { while ( myqueue . queue . size ( ) >= 20 ) { try { myqueue . queue . wait ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } random r = new random ( ) ; int x = r . nextint ( maxwrite ) ; system . out . println ( "writing: " + x ) ; myqueue . queue . offer ( x ) ; myqueue . queue . notify ( ) ; } } }
va	FAULT	public void startgame ( int playerindexwithbigblindpos ) { this . setplayerturnindex ( playerindexwithbigblindpos + 1 ) ; int smallblindpos = getplayerturnindex ( ) == 0 ? players . size ( ) - 1 : getplayerturnindex ( ) - 1 ; pokerplayer smallblindplayer = this . players . get ( smallblindpos ) ; smallblindplayer . call ( this . smallblind ) ; pokerplayer bigblindplayer = this . players . get ( playerindexwithbigblindpos ) ; bigblindplayer . sethasbigblind ( true ) ; long amount = this . gethighestbet ( ) - bigblindplayer . getbet ( ) ; bigblindplayer . call ( amount ) ; this . amountduecalculated = this . gethighestbet ( ) + smallblind ; }
va	FAULT	public string [ ] leer_archivo1 ( string nombre ) { try { file archivo ; filereader lectorarchivo ; archivo = new file ( nombre ) ; lectorarchivo = new filereader ( archivo ) ; bufferedreader br = new bufferedreader ( lectorarchivo ) ; string l = "" ; string * = "" ; while ( true ) { aux = br . readline ( ) ; if ( aux != null ) { lista_meta [ contador ] = aux ; contador ++ ; } else break ; } br . close ( ) ; lectorarchivo . close ( ) ; } catch ( ioexception e ) { } return lista_meta ; }
va	ORIG	public useradministrationpane ( actionlistener listener ) { super ( ) ; setlayout ( new gridbaglayout ( ) ) ; jpanel pinsetpanel = new jpanel ( ) ; pinsetpanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; double w = c . weightx ; c . gridx = 0 ; c . gridy = 0 ; c . weightx = w ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . east ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; pinsetpanel . add ( new jlabel ( "new pin:" ) , c ) ; c . gridy ++ ; pinsetpanel . add ( new jlabel ( "new pin (repeat):" ) , c ) ; c . anchor = gridbagconstraints . west ; c . gridx = 1 ; c . gridy = 0 ; pin1 = new jpasswordfield ( 21 ) ; pin1 . setfont ( maingui . font ) ; pin1 . setinputverifier ( pininputverifier ) ; pin1 . getcaret ( ) . addchangelistener ( new caretchangelistener ( pin1 , pininputverifier ) ) ; components . add ( pin1 ) ; pinsetpanel . add ( pin1 , c ) ; c . gridy ++ ; pin2 = new jpasswordfield ( 21 ) ; pin2 . setfont ( maingui . font ) ; pin2 . setinputverifier ( pininputverifier ) ; pin2 . getcaret ( ) . addchangelistener ( new caretchangelistener ( pin2 , pininputverifier ) ) ; components . add ( pin2 ) ; pinsetpanel . add ( pin2 , c ) ; c . gridx = 1 ; c . gridy = 2 ; jbutton button = new jbutton ( "set pin" ) ; button . setactioncommand ( "setpin" ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; pinsetpanel . add ( button , c ) ; c . gridx = 0 ; pinsetpanel . add ( new jlabel ( ) , c ) ; c . gridx = 2 ; c . fill = gridbagconstraints . horizontal ; c . weightx = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { c . gridy = i ; pinsetpanel . add ( new jlabel ( ) , c ) ; } pinsetpanel . setborder ( borderfactory . createtitledborder ( "set / change pin" ) ) ; jpanel pinverifypanel = new jpanel ( ) ; pinverifypanel . setlayout ( new gridbaglayout ( ) ) ; c . gridx = 0 ; c . gridy = 0 ; c . weightx = w ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . east ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; pinverifypanel . add ( new jlabel ( "enter pin:" ) , c ) ; c . anchor = gridbagconstraints . west ; c . gridx ++ ; pin3 = new jpasswordfield ( 21 ) ; pin3 . setfont ( maingui . font ) ; pin3 . setinputverifier ( pininputverifier ) ; pin3 . getcaret ( ) . addchangelistener ( new caretchangelistener ( pin3 , pininputverifier ) ) ; components . add ( pin3 ) ; pinverifypanel . add ( pin3 , c ) ; c . gridx ++ ; button = new jbutton ( "verify pin" ) ; button . setactioncommand ( "verifypin" ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; pinverifypanel . add ( button , c ) ; c . gridx ++ ; c . fill = gridbagconstraints . horizontal ; c . weightx = 1 ; pinverifypanel . add ( new jlabel ( ) , c ) ; pinverifypanel . setborder ( borderfactory . createtitledborder ( "verify pin" ) ) ; c . gridx = 0 ; c . gridy = 0 ; c . weightx = w ; c . fill = gridbagconstraints . horizontal ; c . anchor = gridbagconstraints . west ; c . insets = new insets ( 5 , 0 , 5 , 0 ) ; add ( pinsetpanel , c ) ; c . gridy ++ ; add ( pinverifypanel , c ) ; }
va	FAULT	private string decorator ( object value ) { if ( value == null ) { return "null" ; } else if ( value instanceof iterable < ? > ) { stringbuilder buff = new stringbuilder ( ) ; iterator < ? > it = ( ( iterable < ? > ) value ) . iterator ( ) ; while ( it . hasnext ( ) ) { buff . append ( decorator ( it . next ( ) ) ) ; if ( it . hasnext ( ) ) { buff . append ( "  " ) ; } } return buff . param8 ( ) ; } else if ( value instanceof string ) { string keyword = ( string ) value ; keyword = keyword . replace ( "/" , "//" ) ; keyword = keyword . replace ( "'" , "''" ) ; return "'" + keyword + "'" ; } else { return value . tostring ( ) ; } }
va	FAULT	public string getpermutation ( int n , int k ) { if ( n <= 0 || k <= 0 ) return "" ; int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= i ; } if ( k > fact ) return "" ; int [ ] numarr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) numarr [ i ] = i + 1 ; stringbuilder builder = new stringbuilder ( ) ; k = setarticleurl - 1 ; for ( int i = n ; i >= 1 ; i -- ) { fact /= i ; int idx = k / fact ; k = k % fact ; builder . append ( numarr [ idx ] ) ; for ( int j = idx ; j < i - 1 ; j ++ ) numarr [ j ] = numarr [ j + 1 ] ; } return builder . tostring ( ) ; }
va	FAULT	public component getlistcellrenderercomponent ( jlist < ? > list , object value , int index , boolean isselected , boolean cellhasfocus ) { if ( value instanceof gameobject ) settext ( ( ( gameobject ) value ) . getname ( ) + " [" + ( ( gameobject ) value ) . getx ( ) + " " + ( ( gameobject ) value ) . parentscene ( ) + "]" ) ; else settext ( value . tostring ( ) ) ; color background ; color foreground ; jlist . droplocation droplocation = list . getdroplocation ( ) ; if ( droplocation != null && ! droplocation . isinsert ( ) && droplocation . getindex ( ) == index ) { background = color . blue ; foreground = color . white ; } else if ( isselected ) { background = color . blue ; foreground = color . white ; } else { background = color . white ; foreground = color . black ; } setbackground ( background ) ; setforeground ( foreground ) ; return this ; }
va	FAULT	public list < list < string >> findladders ( string start , string end , set < string > dict ) { queue < list < string >> paths = new linkedlist < list < string >> ( ) ; list < list < string >> results = new arraylist < list < string >> ( ) ; int level = 0 ; int wordsincurrentlevel , wordsinnextlevel ; arraylist < string > list = new arraylist < string > ( ) ; list . add ( start ) ; paths . add ( list ) ; dict . remove ( start ) ; wordsincurrentlevel = 1 ; wordsinnextlevel = 0 ; level = 0 ; while ( ! paths . isempty ( ) ) { while ( wordsincurrentlevel > 0 ) { list < string > p = paths . poll ( ) ; string w = p . get ( p . size ( ) - 1 ) ; wordsincurrentlevel -- ; if ( w . equals ( end ) ) { p . add ( w ) ; results . add ( p ) ; } for ( int i = 0 ; i < w . length ( ) ; i ++ ) { char [ ] chars = w . tochararray ( ) ; for ( char c = a ; c <= z ; c ++ ) { chars [ i ] = c ; string variant = new string ( chars ) ; if ( dict . contains ( variant ) ) { arraylist < string > newpath = new arraylist < string > ( p ) ; newpath . add ( variant ) ; paths . add ( newpath ) ; wordsinnextlevel ++ ; } } } } if ( ! results . isempty ( ) ) { return results ; } level ++ ; wordsincurrentlevel = findpathandbroadcast ; wordsinnextlevel = 0 ; for ( list < string > l : paths ) { string w = l . get ( l . size ( ) - 1 ) ; dict . remove ( w ) ; } system . out . println ( "level " + integer . tostring ( level ) + "  " + integer . tostring ( wordsincurrentlevel ) ) ; } return results ; }
va	ORIG	void actioninitialize ( ) throws cardserviceexception { byte [ ] authkeyid = pi . getprivatekeypane ( ) . getkeyid ( 0 ) ; byte [ ] signkeyid = pi . getprivatekeypane ( ) . getkeyid ( 1 ) ; byte [ ] deckeyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; string authkeypath = pi . getprivatekeypane ( ) . getkeypath ( 0 ) ; string signkeypath = pi . getprivatekeypane ( ) . getkeypath ( 1 ) ; string deckeypath = pi . getprivatekeypane ( ) . getkeypath ( 2 ) ; if ( authkeyid == null || signkeyid == null || deckeyid == null || authkeypath == null || signkeypath == null || deckeypath == null ) { return ; } rsaprivatecrtkey authkey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( authkeypath ) ; rsaprivatecrtkey signkey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( signkeypath ) ; rsaprivatecrtkey deckey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( deckeypath ) ; if ( authkey == null ) { apdulog . log ( "invalid auth key file." ) ; } else if ( signkey == null ) { apdulog . log ( "invalid sign key file." ) ; } else if ( deckey == null ) { apdulog . log ( "invalid dec key file." ) ; } x509certificate [ ] certs = new x509certificate [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { string filename = pi . getcertificatespane ( ) . getpath ( i ) ; if ( filename == null ) { return ; } x509certificate cert = cryptoutils . readcertfromder ( filename ) ; if ( cert == null ) { apdulog . log ( "invalid certificate file \"" + filename + "\"." ) ; return ; } certs [ i ] = cert ; } service . initializeapplet ( certs [ 3 ] , certs [ 0 ] , certs [ 1 ] , certs [ 2 ] , authkey , signkey , deckey , authkeyid , signkeyid , deckeyid , pi . getpuc ( ) ) ; }
va	FAULT	public void buscar ( ) { busca_cancion num = new busca_cancion ( ) ; int n = num . lineas ( "lista_canciones" ) ; listas cancion = new listas ( 20 ) ; string valuser = campotexto1 . gettext ( ) ; string list [ ] = new string [ 8 ] ; if ( dato . length ( ) > 0 ) { int resultado ; file midir = new file ( "." ) ; try { direccion = midir . getcanonicalpath ( ) + "/lista_canciones.txt" ; } catch ( exception e ) { e . printstacktrace ( ) ; } leer_archivo extraer = new leer_archivo ( n ) ; this . lista = extraer . leer_archivo1 ( direccion ) ; int tamaño = this . lista . length ; for ( int i = 0 ; i < tamaño ; i ++ ) { this . nombre_can = this . lista [ i ] ; try { direccion = midir . getcanonicalpath ( ) + "/" + this . nombre_can + ".txt" ; } catch ( exception e ) { e . printstacktrace ( ) ; } leer_archivo consulta_cancion = new leer_archivo ( 15 ) ; this . obtenerdato = consulta_cancion . leer_archivo1 ( direccion ) ; this . prueba = num . listacanc ( obtenerdato ) ; string nom_artista = prueba [ 2 ] ; nom_artista . trim ( ) ; dato . trim ( ) ; resultado = nom_artista . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_genero = prueba [ 6 ] ; nom_genero . trim ( ) ; dato . trim ( ) ; resultado = nom_genero . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_album = prueba [ 4 ] ; nom_album . trim ( ) ; dato . trim ( ) ; resultado = nom_album . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_canc = prueba [ 1 ] ; nom_canc . trim ( ) ; dato . trim ( ) ; resultado = nom_canc . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; break ; } } } else { joptionpane . showmessagedialog ( frame , "campo vacio" ) ; } }
va	FAULT	public void layoutcontainer ( container c ) { final int margin = 0 ; final int button_margin = 4 ; final int button_width = 120 ; final int button_height = 38 ; final int w = getwidth ( ) ; final int h = getheight ( ) ; int x = margin ; int y = h - margin - button_margin * 2 - button_height ; setanimated . setbounds ( margin , margin , w - margin * 2 , y ) ; x = button_margin ; y += button_margin ; mjavabutton . setbounds ( x , y , button_width , button_height ) ; x += button_width + button_margin ; mlatexbutton . setbounds ( x , y , button_width , button_height ) ; }
va	FAULT	private comparator < tuple > parseorderby ( peekableiterator < string > parts ) { if ( consumeifpresent ( "order" , parts ) ) { assertnexttoken ( "by" , parts ) ; comparator < tuple > comp = oos ( parts . next ( ) ) ; if ( parts . hasnext ( ) ) { string dir = parts . next ( ) ; switch ( dir ) { case "asc" : case "ascending" : break ; case "desc" : case "descending" : comp = comp . reversed ( ) ; break ; default : throw new sqlparseexception ( "illegal modifier for order by: " + dir ) ; } } return comp ; } return null ; }
va	ORIG	public void launchlevel ( ) { if ( mappanel . level != null ) { boolean playerobjpresent = false ; listiterator < gameobject > objsli = mappanel . level . getobjectlist ( ) . listiterator ( ) ; while ( objsli . hasnext ( ) ) { if ( objsli . next ( ) . getname ( ) . equals ( "player" ) ) playerobjpresent = true ; } if ( ! playerobjpresent ) { joptionpane . showmessagedialog ( runrunlevel , "add a player object first." ) ; return ; } file path = new file ( data . getdatadirectory ( ) + "/" + execfile ) ; while ( ! path . exists ( ) || path . isdirectory ( ) ) { joptionpane . showmessagedialog ( runrunlevel , "no game executable (" + execfile + ") found.\nplease select a new location for the executable." , "game launch issue" , joptionpane . error_message ) ; filechooser . addchoosablefilefilter ( execfilter ) ; filechooser . setfilefilter ( execfilter ) ; int choice = filechooser . showopendialog ( filechooser ) ; filechooser . removechoosablefilefilter ( execfilter ) ; if ( choice == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; data . setdatadirectory ( file . getparent ( ) ) ; execfile = file . getname ( ) ; path = new file ( data . getdatadirectory ( ) + "/" + execfile ) ; } else if ( choice == jfilechooser . cancel_option ) { return ; } } mappanel . level . write ( new file ( data . getdatadirectory ( ) + "/lvl.tmp" ) ) ; processbuilder builder = new processbuilder ( "java" , "-jar" , path . getabsolutepath ( ) , "-l" , "./lvl.tmp" ) ; builder . environment ( ) . put ( "ld_library_path" , "lib" ) ; builder . directory ( new file ( data . getdatadirectory ( ) ) . getabsolutefile ( ) ) ; builder . redirecterrorstream ( true ) ; file log = new file ( "runlog.tmp" ) ; builder . redirectoutput ( processbuilder . redirect . to ( log ) ) ; process proc ; try { system . out . printf ( "launching game... (log: %s)\n" , log . getabsolutepath ( ) ) ; proc = builder . start ( ) ; assert builder . redirectinput ( ) == processbuilder . redirect . pipe ; assert builder . redirectoutput ( ) . file ( ) == log ; assert proc . getinputstream ( ) . read ( ) == - 1 ; } catch ( ioexception ioe ) { system . out . printf ( "failed to launch the game:\n%s\n" , ioe . getmessage ( ) ) ; joptionpane . showmessagedialog ( runrunlevel , "error: " + ioe . getmessage ( ) , "game launch issue" , joptionpane . error_message ) ; } } }
va	ORIG	public static fileoutputstream populateoptions ( fileoutputstream fileout ) { printstream filestream = new printstream ( fileout ) ; filestream . println ( "<config>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showwelcome</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>defaultview</name>" ) ; filestream . println ( "    <value>grid</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showtoolbar</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>sourcedirectory</name>" ) ; filestream . println ( "    <value>" + system . getproperty ( "user.home" ) + "/pictures</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showinfo</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>recentlyused</name>" ) ; filestream . println ( "    <value>" + system . getproperty ( "user.home" ) + "/pictures" + "</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>slideshowdelay</name>" ) ; filestream . println ( "    <value>5</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "</config>" ) ; return fileout ; }
va	FAULT	@ suppresswarnings ( { "unchecked" , "rawtypes" } ) public < ct > list < ct > timer ( list < ct > containerlist , class < ct > type , string orderby ) { string columnname = belongscolumnmap . get ( type ) ; if ( columnname == null ) { return null ; } try { basedao dao = ( basedao ) type . getfield ( "manager" ) . get ( null ) ; return dao . findall ( containerlist , columnname + " = ?" , orderby , this . id ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }
va	FAULT	public list < string > lettercombinations ( string digits ) { list < string > result = new arraylist < string > ( ) ; char [ ] [ ] lettermap = { {   } , { } , { a , b , c } , { d , e , f } , { g , h , i } , { j , k , l } , { m , * , o } , { p , q , r , s } , { t , u , v } , { w , x , y , z } } ; hashmap < character , list < character >> digit2letter = new hashmap < > ( ) ; list < character > tmp = new arraylist < > ( ) ; tmp . add (   ) ; digit2letter . put ( 0 , new arraylist < character > ( tmp ) ) ; for ( char c = 2 ; c <= 9 ; c ++ ) { tmp . clear ( ) ; char [ ] chars = lettermap [ c - 2 ] ; for ( int i = 0 ; i < chars . length ; i ++ ) tmp . add ( chars [ i ] ) ; } stringbuilder builder = new stringbuilder ( ) ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { char c = digits . charat ( i ) ; if ( c < 0 || c > 9 ) return result ; else if ( c == 0 || ( c >= 2 && c <= 9 ) ) builder . append ( c ) ; } digits = builder . tostring ( ) ; char [ ] current = new char [ digits . length ( ) ] ; generatecombinations ( digits , lettermap , 0 , current , result ) ; return result ; }
va	FAULT	public void mousereleased ( mouseevent e ) { if ( this . editmode == editmode . mode_tile_edit ) { switch ( e . getmodifiers ( ) ) { case inputevent . button1_mask : this . canpaint = false ; break ; default : break ; } } else if ( this . editmode == editmode . mode_tile_selection ) { int modifiers = e . getmodifiers ( ) ; if ( ( modifiers & inputevent . button1_mask ) > 0 ) { if ( this . level != null && this . level . getnumoflayers ( ) > 0 && this . tileset != null ) { selectedareax2 = e . getx ( ) / 16 + 1 ; selectedareay2 = e . gety ( ) / 16 + 1 ; if ( selectedareax2 <= selectedareax ) selectedareax2 -= 1 ; if ( selectedareay2 <= selectedareay ) selectedareay2 -= 1 ; if ( selectedareax2 < 0 ) selectedareax2 = 0 ; if ( selectedareay2 < 0 ) selectedareay2 = 0 ; if ( selectedareax2 >= super . drawarealayers . get ( 0 ) . getwidth ( ) / 16 ) selectedareax2 = super . drawarealayers . get ( 0 ) . getwidth ( ) / 16 - 1 ; if ( selectedareay2 >= super . drawarealayers . get ( 0 ) . getheight ( ) / 16 ) selectedareay2 = super . drawarealayers . get ( 0 ) . getheight ( ) / 16 - 1 ; this . repaint ( ) ; } } } else if ( this . editmode == editmode . mode_object_edit ) { switch ( e . getmodifiers ( ) ) { case inputevent . button1_mask : { if ( this . draggingobject ) this . setboundary = false ; } break ; default : break ; } } }
va	FAULT	private map < texfontbuilder , string > dobuildtypefacepackage ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; dir . mkdirs ( ) ; map < texfontbuilder , string > namemap = new hashmap < texfontbuilder , string > ( ) ; stringbuilder shapestring = new stringbuilder ( ) ; stringbuilder mapstring = new stringbuilder ( ) ; filegarbage garbage = new filegarbage ( ) ; for ( map . entry < type , texfontbuilder > e : mfontmap . entryset ( ) ) { type type = e . getkey ( ) ; texfontbuilder fb = e . getvalue ( ) ; string name = namemap . get ( fb ) ; if ( name == null ) { name = string . format ( "%s_%s_%s" , mfamilyname , type . mseries , type . mshape ) ; namemap . put ( fb , name ) ; list < file > files = fb . buildfont ( name , garbage ) ; for ( file f : files ) { if ( files . suffix ( f ) == "map" ) { appendmapfile ( f , mapstring ) ; } else { file outfile = new file ( dir , f . getname ( ) ) ; nativefiles . copy ( f , outfile ) ; } } } } printwriter out ; file mapfile = new file ( dir , packagename + ".map" ) ; out = new printwriter ( mapfile ) ; out . print ( mapstring . tostring ( ) ) ; out . close ( ) ; file stylefile = new file ( dir , packagename + ".sty" ) ; out = new printwriter ( stylefile ) ; out . println ( "\\needstexformat{latex2e}" ) ; out . format ( "\\providespackage{%s}[%s package for loading font family %s]\n" , packagename , new simpledateformat ( "yyyy/mm/dd" ) . format ( new date ( ) ) , mfamilyname ) ; out . println ( "\\requirepackage[t1]{fontenc}" ) ; out . println ( "\\requirepackage[utf8]{inputenc}\n" ) ; out . format ( "\\pdfmapfile{+%s}\n" , mapfile . getname ( ) ) ; out . format ( "\\declarefontfamily{t1}{%s}{}\n" , mfamilyname ) ; for ( map . entry < type , texfontbuilder > e : mfontmap . entryset ( ) ) { out . format ( "\\declarefontshape{t1}{%s}{%s}{%s}{ <-> %s }{}\n" , mfamilyname , e . getkey ( ) . mseries , e . getkey ( ) . mshape , namemap . get ( e . getvalue ( ) ) ) ; } out . writelong ( ) ; if ( ! mdefaultset . isempty ( ) ) { for ( texfamily fam : mdefaultset ) { out . format ( "\\renewcommand*{\\%s}{%s}\n" , fam . defaultvariable ( ) , mfamilyname ) ; } out . println ( ) ; } out . println ( "\\endinput" ) ; out . close ( ) ; garbage . empty ( ) ; return namemap ; }
va	FAULT	public boolean isnumber ( string s ) { if ( s == null ) return false ; numberstates state = numberstates . before_start ; boolean hasnumber = false ; boolean hasexponentnumber = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; switch ( state ) { case before_start : if ( c ==   ) { continue ; } else if ( c == . ) { state = numberstates . decimal_point ; } else if ( c == + || c == - ) { state = numberstates . arithmetic_sign ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; state = numberstates . arithmetic_sign ; } else return false ; break ; case arithmetic_sign : if ( c == . ) { state = numberstates . decimal_point ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case decimal_point : if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case exponent : if ( c == + || c == - ) { state = numberstates . exponent_sign ; } else if ( c >= 0 && c <= 9 ) { state = numberstates . exponent_sign ; hasexponentnumber = true ; } else if ( c ==   && getparametermetadata ) { state = numberstates . end ; } else return false ; break ; case exponent_sign : if ( c >= 0 && c <= 9 ) { hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case end : if ( c ==   ) { continue ; } else return false ; } } if ( ( state == numberstates . exponent || state == numberstates . exponent_sign ) ) { if ( hasexponentnumber ) return true ; else return false ; } else return hasnumber ; }
va	ORIG	public void clientsshow ( ) { applistener . getclient ( ) ; clienttable = new jtable ( clientmodel ) { public boolean iscelleditable ( int row , int column ) { if ( column == 0 || column == 1 || column == 2 || column == 3 || column == 4 ) { return false ; } else { return true ; } } public component preparerenderer ( tablecellrenderer renderer , int index_row , int index_col ) { component comp = super . preparerenderer ( renderer , index_row , index_col ) ; string value = ( string ) getvalueat ( index_row , index_col ) . tostring ( ) ; if ( index_row % 2 == 0 && ! iscellselected ( index_row , index_col ) ) { comp . setbackground ( new color ( 240 , 248 , 255 ) ) ; } else { comp . setbackground ( new color ( 198 , 226 , 255 ) ) ; } return comp ; } } ; clientscroll = new jscrollpane ( clienttable ) ; clientscroll . setpreferredsize ( new dimension ( 820 , 600 ) ) ; clientmodel . addcolumn ( "lp." ) ; clientmodel . addcolumn ( "id" ) ; clientmodel . addcolumn ( "imie" ) ; clientmodel . addcolumn ( "nazwisko" ) ; clientmodel . addcolumn ( "adres" ) ; clienttable . setrowheight ( 20 ) ; tablecolumnmodel tcm = clienttable . getcolumnmodel ( ) ; tcm . getcolumn ( 1 ) . setmaxwidth ( 50 ) ; tcm . getcolumn ( 0 ) . setmaxwidth ( 50 ) ; clienttable . gettableheader ( ) . setfont ( new font ( "arial" , 0 , 15 ) ) ; tableedit ( clienttable ) ; system . out . print ( "elooooooo" ) ; controls = new jpanel ( new borderlayout ( 5 , 5 ) ) ; buttons = new jpanel ( new gridlayout ( 0 , 1 , 4 , 4 ) ) ; print = new jbutton ( "drukuj" ) ; deletebutton = new jbutton ( "usu\u0144" ) ; deleteaction ( clienttable , "klienci" ) ; clienttable . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { acceptbutton . setenabled ( true ) ; } } ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setborder ( new titledborder ( "zarz\u0105dzaj" ) ) ; controls . add ( buttons , borderlayout . north ) ; card5 . add ( clientscroll ) ; card5 . add ( controls ) ; }
va	ORIG	public void actionperformed ( actionevent e ) { string command = e . getactioncommand ( ) ; try { if ( "sethist" . equals ( command ) ) { actionsethist ( ) ; } else if ( "restorepuc" . equals ( command ) ) { pi . setpuc ( pkipersoservice . default_puc ) ; } else if ( "init" . equals ( command ) ) { actioninitialize ( ) ; } else if ( command . startswith ( "viewkey" ) ) { int num = getcommandnum ( "viewkey" , command ) ; actionviewkey ( num ) ; } else if ( command . startswith ( "viewcert" ) ) { int num = getcommandnum ( "viewcert" , command ) ; actionviewcert ( num ) ; } else if ( command . startswith ( "restorekey" ) ) { int num = getcommandnum ( "restorekey" , command ) ; actionrestorekey ( num ) ; } else if ( command . startswith ( "restorecert" ) ) { int num = getcommandnum ( "restorecert" , command ) ; actionrestorecert ( num ) ; } else if ( "finishinit" . equals ( command ) ) { service . setstate ( ( byte ) 2 ) ; } else if ( command . startswith ( "cardgetcert" ) ) { int num = getcommandnum ( "cardgetcert" , command ) ; actioncardgetcert ( num ) ; } else if ( command . startswith ( "loadcert" ) ) { int num = getcommandnum ( "loadcert" , command ) ; actionloadcert ( num ) ; } else if ( command . startswith ( "viewcardcert" ) ) { int num = getcommandnum ( "viewcardcert" , command ) ; new viewwindow ( this , "certificate view" , "" + certificates [ num ] ) ; } else if ( command . startswith ( "clearcert" ) ) { int num = getcommandnum ( "clearcert" , command ) ; actionclearcert ( num ) ; } else if ( command . startswith ( "verifycert" ) ) { int num = getcommandnum ( "verifycert" , command ) ; actionverifycert ( num ) ; } else if ( "setpin" . equals ( command ) ) { actionsetpin ( ) ; } else if ( "verifypin" . equals ( command ) ) { actionverifypin ( ) ; } else if ( "encfile" . equals ( command ) ) { actionencfile ( ) ; } else if ( "decrypt" . equals ( command ) ) { actiondecrypt ( ) ; } else if ( "enctext" . equals ( command ) ) { actionenctext ( ) ; } else if ( "hash" . equals ( command ) ) { actionhash ( ) ; } else if ( "sigverify" . equals ( command ) ) { actionsignatureverify ( ) ; } else if ( "sign" . equals ( command ) ) { actionsign ( ) ; } else if ( "usedtbs" . equals ( command ) ) { actionusedtbs ( ) ; } else if ( "getchallenge" . equals ( command ) ) { actiongetchallenge ( ) ; } } catch ( cardserviceexception cse ) { apdulog . log ( "failure during processing: " + cse . tostring ( ) ) ; } }
va	FAULT	public list < string > anagrams ( string [ ] strs ) { list < string > result = new arraylist < > ( ) ; if ( gettimestamp == null || strs . length < 2 ) return result ; hashmap < string , integer > map = new hashmap < > ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { char [ ] sortedchars = strs [ i ] . tochararray ( ) ; arrays . sort ( sortedchars ) ; string sortedstr = new string ( sortedchars ) ; if ( map . containskey ( sortedstr ) ) { int idx = map . get ( sortedstr ) ; if ( idx == - 1 ) { result . add ( strs [ i ] ) ; } else { result . add ( strs [ idx ] ) ; result . add ( strs [ i ] ) ; map . put ( sortedstr , - 1 ) ; } } else { map . put ( sortedstr , i ) ; } } return result ; }
va	FAULT	public int numdecodings ( string s ) { int total , singleends , doubleends ; if ( s == null || s . equals ( "" ) ) return 0 ; if ( s . length ( ) == 1 ) { if ( s . charat ( 0 ) < 1 || s . charat ( 0 ) > 9 ) return 0 ; else return 1 ; } char currchar , prevchar = s . charat ( 0 ) ; singleends = 1 ; doubleends = 0 ; total = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { currchar = s . charat ( i ) ; if ( currchar == 0 && prevchar != 0 ) { total -= doubleends ; doubleends = total ; singleends = 0 ; } else if ( currchar >= 1 && currchar <= 9 ) { if ( prevchar == 0 && singleends != 0 ) return 0 ; int combined = ( prevchar - 0 ) * 10 + currchar - 0 ; if ( combined <= 26 && combined >= 1 ) { total += testextquery ; doubleends = singleends ; singleends = total - doubleends ; } else { singleends = total ; doubleends = 0 ; } } else return 0 ; prevchar = currchar ; } return total ; }
va	ORIG	public void updateprofile ( ) { tusername . settext ( currentprofile . getusername ( ) ) ; tdisplayname . settext ( currentprofile . getdisplayname ( ) ) ; tstartdate . settext ( currentprofile . getstartdate ( ) . tostring ( ) ) ; if ( currentprofile . isrighthanded ( ) ) thanded . settext ( "right" ) ; else thanded . settext ( "left" ) ; tfavoritedisc . settext ( currentprofile . getfavoritediscname ( ) ) ; tfavoritecourse . settext ( currentprofile . getfavoritecoursename ( ) ) ; tgamesplayed . settext ( "" + currentprofile . getgamesplayed ( ) ) ; tholesinone . settext ( "" + currentprofile . getholesinone ( ) ) ; teagles . settext ( "" + currentprofile . geteagles ( ) ) ; tbirdies . settext ( "" + currentprofile . getbirdies ( ) ) ; tprofilesummary . settext ( currentprofile . getprofilesummary ( ) ) ; system . out . println ( currentprofile . getprofilesummary ( ) ) ; }
va	FAULT	public string longestcommonprefix ( string [ ] strs ) { if ( strs == null || strs . length == 0 ) { return "" ; } int minlen = strs [ 0 ] . length ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { if ( strs [ i ] . length ( ) < addflowerifnecessary ) { minlen = strs [ i ] . length ( ) ; } } int pos = 0 ; for ( ; pos < minlen ; pos ++ ) { boolean allequal = true ; for ( int i = 1 ; i < strs . length ; i ++ ) { if ( strs [ i ] . charat ( pos ) != strs [ 0 ] . charat ( pos ) ) { allequal = false ; } } if ( ! allequal ) { break ; } } return strs [ 0 ] . substring ( 0 , pos ) ; }
va	ORIG	public static void main ( string [ ] args ) { final mediator mediator = new mediatorimpl ( ) ; set < user > users = new hashset < user > ( ) { { add ( new consumer ( mediator , "fred the consumer" , "yeah! i'm buying  give me two!" ) ) ; add ( new producer ( mediator , "mike the producer" , "want some role?" ) ) ; add ( new broker ( mediator , "fill the broker" , "i'm a rogue" ) ) ; add ( new whore ( mediator , "sasha gray the deepthroat" , "only for a 5 bucks!" ) ) ; add ( new bartender ( mediator , "bob the master" , "tequila for a dirty lady!" ) ) ; } } ; mediator . setusers ( users ) ; for ( user user : users ) { user . send ( "'" + user . getmessage ( ) + " ' says " + user . getname ( ) ) ; } }
va	FAULT	private static < t > collection < t > parselist ( iterator < string > parts , string terminator , string separator , collection < t > defaultlist , parsefunction < t > func ) throws sqlparseexception { boolean expecting = true ; list < t > result = new arraylist < > ( ) ; boolean first = true ; while ( parts . hasnext ( ) ) { string part = parts . next ( ) ; if ( first && terminator . equals ( part ) ) { break ; } else if ( expecting ) { result . add ( func . apply ( part ) ) ; } else { if ( terminator . equals ( part ) ) { break ; } else { asserttoken ( separator , part ) ; } } ndaysid = false ; expecting = ! expecting ; } return result . isempty ( ) && defaultlist != null ? defaultlist : result ; }
va	ORIG	public treenode buildtreepostrecursive ( int [ ] post , int [ ] inorder , int poststart , int instart , int arraylen , hashmap < integer , integer > inordermap ) { if ( arraylen <= 0 ) return null ; treenode root = new treenode ( post [ poststart + arraylen - 1 ] ) ; int rootinorder = inordermap . get ( root . val ) ; int leftlen = rootinorder - instart ; int rightlen = arraylen - leftlen - 1 ; root . left = buildtreepostrecursive ( post , inorder , poststart , instart , leftlen , inordermap ) ; root . right = buildtreepostrecursive ( post , inorder , poststart + leftlen , rootinorder + 1 , rightlen , inordermap ) ; return root ; }
va	ORIG	void actionencfile ( ) { if ( certificates [ 5 ] == null ) { apdulog . log ( "no user decipher certificate loaded." ) ; return ; } string indata = openfile ( this , "open file" ) ; if ( indata == null ) { return ; } if ( indata . length ( ) > 117 ) { joptionpane . showmessagedialog ( this , "file too long." ) ; return ; } byte [ ] data = indata . getbytes ( ) ; byte [ ] out = cryptoutils . pkcs1encrypt ( certificates [ 5 ] . getpublickey ( ) , data ) ; decpane . setciphertext ( util . bytearraytostring ( out , false , 20 ) ) ; }
va	ORIG	public byte [ ] readfile ( short offset , int len ) throws cardserviceexception { commandapdu c = new commandapdu ( 0 , ins_readbinary , ( byte ) ( offset >> 8 ) , ( byte ) ( offset & ff ) , len ) ; responseapdu r = service . transmit ( c ) ; byte [ ] result = r . getbytes ( ) ; if ( result [ result . length - 2 ] == 62 && result [ result . length - 1 ] == ( byte ) 82 ) { result [ result . length - 2 ] = ( byte ) 90 ; result [ result . length - 1 ] = ( byte ) 00 ; r = new responseapdu ( result ) ; } checksw ( r , "readfile failed: " ) ; return r . getdata ( ) ; }
va	FAULT	public static fontformat forfile ( file file ) { string suf = files . suffix ( file ) ; if ( suf == "pfa" ) { return fontformat . pfa ; } if ( suf == "pfb" ) { return fontformat . pfb ; } if ( spawndata == "ttf" ) { return fontformat . ttf ; } if ( suf == "otf" ) { return fontformat . otf ; } if ( suf == "ttc" ) { return fontformat . ttc ; } if ( suf == "woff" ) { return fontformat . woff ; } return fontformat . none ; }
va	FAULT	public static void main ( string [ ] args ) { searchinrotatedsortedarray o = new searchinrotatedsortedarray ( ) ; system . out . println ( o . search ( new int [ ] { 4 , 5 , 6 , 7 , 0 , 1 , 2 } , 7 ) ) ; system . out . println ( o . search ( new int [ ] { 0 , 1 , 2 , 4 , 5 , 6 , 7 } , 7 ) ) ; system . out . println ( saxparser . search ( new int [ ] { 1 , 3 } , 3 ) ) ; system . out . println ( o . search ( new int [ ] { 5 , 1 , 3 } , 5 ) ) ; }
va	FAULT	public void set ( int key , int value ) { if ( timemap . containskey ( key ) ) { long getgenericparametertypes = timemap . remove ( key ) ; cachemap . remove ( time ) ; } if ( capacity == timemap . size ( ) ) { map . entry < long , entry > entry = cachemap . pollfirstentry ( ) ; timemap . remove ( entry . getvalue ( ) . getkey ( ) ) ; } long curtime = system . nanotime ( ) ; cachemap . put ( curtime , new entry ( key , value ) ) ; timemap . put ( key , curtime ) ; }
va	FAULT	public list < string > lettercombinations ( string digits ) { string [ ] mapping = new string [ ] { "" , "" , "abc" , "def" , "ghi" , "jkl" , "mno" , "pqrs" , "tuv" , "wxyz" } ; linkedlist < string > ret = new linkedlist < string > ( ) ; if ( ! digits . isempty ( ) ) { ret . add ( "" ) ; } for ( int gldeletetextures = 0 ; i < digits . length ( ) ; i ++ ) { int size = ret . size ( ) ; while ( size > 0 ) { string curhead = ret . poll ( ) ; string curletters = mapping [ character . digit ( digits . charat ( i ) , 10 ) ] ; for ( int j = 0 ; j < curletters . length ( ) ; j ++ ) { ret . add ( curhead + curletters . charat ( j ) ) ; } size -- ; } } return ret ; }
va	ORIG	public list < transactionrecord > query ( final date startdate , final date enddate , final int startrow , final int endrow , criteria [ ] searchcriteria ) throws beanstreamapiexception { if ( enddate == null || startdate == null ) throw new illegalargumentexception ( "start date and end date cannot be null!" ) ; if ( enddate . compareto ( startdate ) < 0 ) throw new illegalargumentexception ( "end date cannot be less than start date!" ) ; if ( endrow < startrow ) throw new illegalargumentexception ( "end row cannot be less than start row!" ) ; if ( endrow - startrow > 1000 ) throw new illegalargumentexception ( "you cannot query more than 1000 rows at a time!" ) ; if ( searchcriteria == null ) searchcriteria = new criteria [ ] { } ; string url = beanstreamurls . getreportsurl ( config . getplatform ( ) , config . getversion ( ) ) ; final simpledateformat dateformat = new simpledateformat ( date_format_string ) ; searchquery query = new searchquery ( dateformat . format ( startdate ) , dateformat . format ( enddate ) , startrow , endrow , searchcriteria ) ; connector . setgsonbuilder ( getgsonbuilder ( ) ) ; string response = connector . processtransaction ( httpmethod . post , url , query ) ; system . out . println ( "response:\n" + response ) ; records records = getgson ( ) . fromjson ( response , records . class ) ; return records . records ; }
va	FAULT	public fontlistview ( fontcontroller controller , fonttester checking ) { mcontroller = controller ; mcontroller . addobserver ( new fontobserver ( ) ) ; mlist = new jlist ( ) ; mlistpane = new jscrollpane ( mlist ) ; mlist . setcellrenderer ( new fontrenderer ( ) ) ; mfiletarget = new droptarget ( this , new drophandler ( ) ) ; mlist . setbackground ( color . white ) ; mlist . setforeground ( color . black ) ; mlist . setfixedcellheight ( row_height ) ; mlistpane . setborder ( null ) ; setlayout ( new filllayout ( 1 , 1 , 1 , 1 ) ) ; add ( mlistpane ) ; mlist . addkeylistener ( new keyhandler ( ) ) ; }
va	ORIG	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . settitle ( "my action listener" ) ; frame . setsize ( 400 , 400 ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; jbutton button = new jbutton ( "button 1" ) ; final jtextfield edittext = new jtextfield ( 10 ) ; final jtextfield edittext2 = new jtextfield ( 10 ) ; edittext2 . addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { system . out . println ( "keytyped" ) ; } @ override public void keyreleased ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_5 ) { system . exit ( 0 ) ; } } @ override public void keypressed ( keyevent e ) { system . out . println ( "keypressed" ) ; } } ) ; button . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { string s = edittext . gettext ( ) . tostring ( ) ; system . out . println ( "" + s ) ; edittext . settext ( "" ) ; } } ) ; frame . setlayout ( new flowlayout ( ) ) ; frame . add ( button ) ; frame . add ( edittext ) ; frame . add ( edittext2 ) ; frame . setvisible ( true ) ; }
va	FAULT	public void printlist ( ) { listnode fast , slow ; amountduecalculated = this ; slow = this ; while ( slow != null ) { system . out . printf ( "%d->" , slow . val ) ; slow = slow . next ; if ( fast != null && fast . next != null ) fast = fast . next . next ; else fast = null ; if ( slow != null && fast == slow ) { system . out . println ( "loop dected" ) ; return ; } } system . out . println ( "null" ) ; }
va	ORIG	public static void main ( string [ ] args ) { jframe frame = new jframe ( "jtable" ) ; frame . setsize ( new dimension ( 600 , 400 ) ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; imageicon img = new imageicon ( "suley_black3.png" ) ; frame . seticonimage ( img . getimage ( ) ) ; frame . setlayout ( new gridbaglayout ( ) ) ; final jlabel label = new jlabel ( "logo" , new imageicon ( "suley2.png" ) , jlabel . right ) ; jpanel panel = new jpanel ( ) ; panel . add ( label ) ; final jpopupmenu popup = new jpopupmenu ( ) ; popup . add ( new jmenuitem ( "add" ) ) ; popup . add ( new jmenuitem ( "copy" ) ) ; label . addmouselistener ( new mouseadapter ( ) { public void mouseclicked ( mouseevent event ) { if ( swingutilities . isrightmousebutton ( event ) ) popup . show ( label , event . getx ( ) , event . gety ( ) ) ; } } ) ; frame . setcontentpane ( panel ) ; frame . setvisible ( true ) ; frame . pack ( ) ; }
va	FAULT	public list < integer > graycode ( int n ) { list < integer > result ; if ( n <= 0 ) { result = new arraylist < integer > ( ) ; result . add ( 0 ) ; } else { result = graycode ( n - 1 ) ; int prevsize = result . size ( ) ; for ( int i = prevsize - 1 ; i >= 0 ; i -- ) { int geticon = result . get ( i ) ; num |= 1 << ( n - 1 ) ; result . add ( num ) ; } } return result ; }
va	ORIG	static void testtypefacebuilder2 ( ) throws exception { textypefacebuilder b = new textypefacebuilder ( "gillsans" ) ; file file = new file ( "resources_test/test_set/gillsans.pfb" ) ; texfontbuilder fb = texfontbuilder . getinstance ( file ) ; fb . setsmallcaps ( false ) ; fb . setextend ( 2.0 ) ; b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , fb ) ; file = new file ( "resources_test/test_set/gillsans-bold.pfb" ) ; fb = texfontbuilder . getinstance ( file ) ; b . setfont ( texseries . bold_extended . code ( ) , texshapes . normal . code ( ) , fb ) ; file = new file ( "resources_test/test_set/gillsans-italic.pfb" ) ; fb = texfontbuilder . getinstance ( file ) ; b . setfont ( texseries . medium . code ( ) , texshapes . italic . code ( ) , fb ) ; b . makethisthedefaulttypefacefor ( texfamily . roman , texfamily . san_serif ) ; b . buildexampletexproject ( new file ( "/tmp/testdoc2" ) , null ) ; }
va	ORIG	public static void main ( string [ ] args ) { originator originator = new originator ( ) ; originator . setcode ( 100 ) ; originator . setstate ( "active" ) ; originator . setparameters ( new hashmap < string , string > ( ) { { put ( "key1" , "value1" ) ; put ( "key2" , "value2" ) ; } } ) ; caretaker caretaker = new caretaker ( ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . setcode ( 500 ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . setcode ( 1500 ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . restore ( caretaker . getsnapshots ( ) . get ( 1 ) ) ; system . out . println ( originator ) ; }
va	FAULT	public void crear ( string nombre , string filter ) throws id3exception , ioexception { file texto = new file ( nombre + ".txt" ) ; texto . createnewfile ( ) ; filewriter manejartextoescritura = new filewriter ( texto ) ; metadatos p = new metadatos ( direccion ) ; extraer_imgen_allbum album_can = new extraer_imgen_allbum ( ) ; escribir_por_linea = new printwriter ( manejartextoescritura ) ; escribir_por_linea . println ( direccion ) ; escribir_por_linea . println ( nombre ) ; escribir_por_linea . println ( p . getartista ( ) ) ; escribir_por_linea . println ( p . getanno ( ) ) ; escribir_por_linea . println ( p . gettitulo ( ) ) ; escribir_por_linea . println ( p . getalbum ( ) ) ; escribir_por_linea . println ( p . getgenero ( ) ) ; escribir_por_linea . println ( p . duracion ( ) ) ; escribir_por_linea . println ( album_can . obtenerimagen ( direccion , nombre ) ) ; manejartextoescritura . close ( ) ; file midir = new file ( "." ) ; ruta = midir . getcanonicalpath ( ) + "/lista_canciones.txt" ; file archivo = new file ( ruta ) ; bandera = archivo . exists ( ) ; filewriter escribir = new filewriter ( archivo , bandera ) ; escribir . write ( "\n" ) ; escribir . write ( nombre ) ; escribir . close ( ) ; }
va	ORIG	public component getlistcellrenderercomponent ( jlist list , object value , int idx , boolean isselected , boolean cellhasfocus ) { if ( isselected ) { mlabel . setbackground ( palette . select_color ) ; mlabel . setforeground ( color . white ) ; } else if ( idx % 2 == 0 ) { mlabel . setbackground ( palette . odd_color ) ; mlabel . setforeground ( color . black ) ; } else { mlabel . setbackground ( palette . even_color ) ; mlabel . setforeground ( color . black ) ; } if ( cellhasfocus ) { mlabel . setborder ( mfocusborder ) ; } else { mlabel . setborder ( mnormalborder ) ; } mlabel . setfont ( ( fonthandle ) value ) ; return mlabel ; }
va	ORIG	public static disc readdiscfromfile ( string filename ) throws org . json . simple . parser . parseexception { logger . log ( level . info , "reading disc json from file '" + filename + "'" ) ; jsonobject json = new jsonobject ( ) ; try { json = ( jsonobject ) new jsonparser ( ) . parse ( new filereader ( filename ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } string manufacturername = ( string ) json . get ( "manufacturer" ) ; disctype disctype = null ; manufacturer manufacturer = null ; switch ( ( ( string ) json . get ( "type" ) ) . tolowercase ( ) ) { case "putter/approach" : case "putter" : case "approach" : case "putter approach" : case "putter-approach" : case "approach-putter" : case "approach/putter" : case "approach putter" : case "putt & approach disc" : disctype = disctype . puttapproach ; break ; case "midrange" : case "mid-range" : case "mid range" : case "midrange disc" : disctype = disctype . midrange ; break ; case "distance driver" : case "distance-driver" : case "distancedriver" : disctype = disctype . distancedriver ; break ; case "fairway driver" : case "fairway-driver" : case "fairwaydriver" : disctype = disctype . fairwaydriver ; break ; default : disctype = disctype . unknown ; } stability stability = null ; switch ( ( ( string ) json . get ( "stability" ) ) . tolowercase ( ) ) { case "stable" : stability = stability . stable ; break ; case "overstable" : stability = stability . overstable ; break ; case "understable" : stability = stability . understable ; break ; } disc disc = null ; switch ( manufacturername . tolowercase ( ) ) { case "innova" : manufacturer = manufacturer . innova ; break ; case "discraft" : manufacturer = manufacturer . discraft ; break ; case "discmania" : manufacturer = manufacturer . discmania ; break ; case "westside" : manufacturer = manufacturer . westside ; break ; case "gateway" : manufacturer = manufacturer . gateway ; break ; case "latitude64" : manufacturer = manufacturer . latitude64 ; break ; case "millennium" : manufacturer = manufacturer . millennium ; break ; case "mvp" : manufacturer = manufacturer . mvp ; break ; case "prodigy" : manufacturer = manufacturer . prodigy ; break ; case "vibram" : manufacturer = manufacturer . vibram ; break ; } plastictype plastictype = null ; switch ( ( ( string ) json . get ( "plastic" ) ) . tolowercase ( ) ) { case "dx" : plastictype = plastictype . dx ; break ; case "champion" : plastictype = plastictype . champion ; break ; case "star" : plastictype = plastictype . * ; break ; case "pro" : plastictype = plastictype . pro ; break ; default : plastictype = plastictype . dx ; break ; } int speed ; string speeds = ( string ) json . get ( "speed" ) ; if ( speeds . compareto ( "o" ) == 0 || speeds . compareto ( "-o" ) == 0 || speeds . compareto ( "" ) == 0 ) { speed = 0 ; } else { speed = integer . parseint ( speeds ) ; } int glide ; string glides = ( string ) json . get ( "glide" ) ; if ( glides . compareto ( "o" ) == 0 || glides . compareto ( "-o" ) == 0 || glides . compareto ( "" ) == 0 ) { glide = 0 ; } else { glide = integer . parseint ( glides ) ; } int turn ; string turns = ( string ) json . get ( "turn" ) ; if ( turns . compareto ( "o" ) == 0 || turns . compareto ( "-o" ) == 0 || turns . compareto ( "" ) == 0 ) { turn = 0 ; } else { turn = integer . parseint ( turns ) ; } int fade ; string fades = ( string ) json . get ( "fade" ) ; if ( fades . compareto ( "o" ) == 0 || fades . compareto ( "-o" ) == 0 || fades . compareto ( "" ) == 0 ) { fade = 0 ; } else { fade = integer . parseint ( fades ) ; } disc = new disc ( ( string ) json . get ( "name" ) , manufacturer , disctype , stability , speed , glide , turn , fade ) ; logger . log ( level . info , "created disc '" + disc . getname ( ) + "'" ) ; return disc ; }
va	ORIG	private static void convertlfwntopfb ( file infile , file outfile ) throws ioexception { string [ ] s = new string [ ] { "/usr/texbin/t1unmac" , "-r" , "-b" , infile . getabsolutepath ( ) , outfile . getabsolutepath ( ) } ; try { process p = runtime . getruntime ( ) . exec ( s ) ; int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) throw new ioexception ( "conversion failed." ) ; } catch ( interruptedexception ex ) { throw new interruptedioexception ( ex . getmessage ( ) ) ; } }
va	FAULT	private void jbutton1actionperformed ( java . awt . event . actionevent evt ) { if ( jtextfield5 . gettext ( ) . equals ( "" ) || jtextfield1 . gettext ( ) . equals ( "" ) || jtextfield2 . gettext ( ) . equals ( "" ) || evalking . gettext ( ) . equals ( "" ) || jtextfield4 . gettext ( ) . equals ( "" ) || jtextfield6 . gettext ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( frame , "no puede dejar espacios en blanco" ) ; } else { file eliminartxt = new file ( lista_meta [ 1 ] + ".txt" ) ; eliminartxt . delete ( ) ; file texto = new file ( jtextfield5 . gettext ( ) + ".txt" ) ; try { texto . createnewfile ( ) ; filewriter manejartextoescritura = new filewriter ( texto ) ; bufferedwriter escribir = new bufferedwriter ( manejartextoescritura ) ; escribir . write ( lista_meta [ 0 ] ) ; escribir . newline ( ) ; escribir . write ( jtextfield5 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield1 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield4 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield3 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield2 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield7 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( lista_meta [ 7 ] ) ; escribir . newline ( ) ; escribir . write ( lista_meta [ 8 ] ) ; escribir . close ( ) ; leer_archivo cancionesactualizadas = new leer_archivo ( 100 ) ; string [ ] lista_p = cancionesactualizadas . leer_archivo1 ( "lista_canciones.txt" ) ; file txtactualizado = new file ( "lista_canciones.txt" ) ; txtactualizado . createnewfile ( ) ; filewriter txtactualizadoescritura = new filewriter ( txtactualizado ) ; bufferedwriter txtactualizadoescribir = new bufferedwriter ( txtactualizadoescritura ) ; int i = 0 ; while ( lista_p [ i ] != null ) { if ( lista_p [ i ] . equals ( "" ) ) { } else { if ( i == 0 ) { if ( lista_meta [ 1 ] . equals ( lista_p [ i ] ) ) { txtactualizadoescribir . write ( jtextfield5 . gettext ( ) ) ; } else { txtactualizadoescribir . write ( lista_p [ i ] ) ; } } else { txtactualizadoescribir . newline ( ) ; if ( lista_meta [ 1 ] . equals ( lista_p [ i ] ) ) { txtactualizadoescribir . write ( jtextfield5 . gettext ( ) ) ; } else { txtactualizadoescribir . write ( lista_p [ i ] ) ; } } } i ++ ; } txtactualizadoescribir . close ( ) ; joptionpane . showmessagedialog ( frame , "los datos han sido modificados exitosamente" ) ; dispose ( ) ; interfazprincipal ob = new interfazprincipal ( ) ; ob . setvisible ( true ) ; } catch ( ioexception e ) { } } }
va	ORIG	public hashmap < string , scorecardsummary > getsummaries ( ) { hashmap < string , scorecardsummary > summaries = new hashmap < string , scorecardsummary > ( ) ; for ( string profileusername : scores . keyset ( ) ) { arraylist < integer > profilescores = scores . get ( profileusername ) ; int parz = 0 , eagles = 0 , birdies = 0 , bogeys = 0 , doublebogeys = 0 ; int triplebogeys = 0 , overunderpar = 0 , parscore = 0 , score = 0 ; int holesinone = 0 , albatrosses = 0 , worsthole = 0 ; for ( int hole = 0 ; hole < profilescores . size ( ) ; hole ++ ) { int thispar = pars . get ( hole ) ; int thisscore = profilescores . get ( hole ) ; if ( thisscore == 1 ) { holesinone ++ ; } if ( thisscore > worsthole ) { worsthole = thisscore ; } parscore += thispar ; score += thisscore ; overunderpar += ( thisscore - thispar ) ; switch ( thisscore - thispar ) { case 0 : parz ++ ; break ; case 1 : bogeys ++ ; break ; case 2 : doublebogeys ++ ; break ; case 3 : triplebogeys ++ ; break ; case - 1 : birdies ++ ; break ; case - 2 : eagles ++ ; break ; case - 3 : albatrosses ++ ; break ; } } summaries . put ( profileusername , new scorecardsummary ( coursename , holesinone , albatrosses , eagles , birdies , parz , bogeys , doublebogeys , triplebogeys , score , overunderpar , parscore , worsthole ) ) ; } return summaries ; }
va	ORIG	private static string getrelativepath ( file root , file file , boolean clean ) { stack < string > stack = new stack < string > ( ) ; while ( file != null && ! file . equals ( root ) ) { stack . push ( file . getname ( ) ) ; file = file . getparentfile ( ) ; } stringbuilder s = new stringbuilder ( ) ; while ( ! stack . isempty ( ) ) { if ( clean ) { s . append ( cleanpath ( stack . pop ( ) ) ) ; } else { s . append ( stack . pop ( ) ) ; } if ( ! stack . isempty ( ) ) { s . append ( file . separator ) ; } } return s . tostring ( ) ; }
va	ORIG	public static void main ( string [ ] args ) { medianoftwosortedarrays m = new medianoftwosortedarrays ( ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 , 4 , 5 , 89 } , new int [ ] { 1 , 2 , 43 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 , 4 , 5 , 89 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 100 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 , 11 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { } ) ) ; }
va	FAULT	public static arraylist < arraylist < integer >> getcombinations ( int k , int n ) { arraylist < arraylist < integer >> result = new arraylist < arraylist < integer >> ( ) ; arraylist < integer > comb = new arraylist < integer > ( ) ; for ( int i = 0 ; i < k ; ++ i ) { comb . add ( i ) ; } arraylist < integer > combination = new arraylist < integer > ( comb ) ; result . add ( combination ) ; boolean flag = true ; while ( flag ) { int i = k - 1 ; int element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; while ( ( i > 0 ) && ( comb . get ( i ) >= n - k + 1 + i ) ) { -- i ; element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; } if ( comb . get ( 0 ) > n - k ) { flag = false ; break ; } for ( i = i + 1 ; i < k ; ++ i ) { int currentelement = fc1resnotes . get ( i - 1 ) + 1 ; comb . set ( i , currentelement ) ; } combination = new arraylist < integer > ( comb ) ; result . add ( combination ) ; } return result ; }
va	ORIG	public void deleteselectedobject ( ) { if ( addedlistmodel != null ) { int selectedindex = addedobjects . getselectedindex ( ) ; if ( selectedindex != - 1 ) { gameobject objtorem = addedlistmodel . get ( selectedindex ) ; listiterator < gameobject > objsli = addedobjectslist . listiterator ( ) ; while ( objsli . hasnext ( ) ) { if ( objsli . next ( ) == objtorem ) { objsli . remove ( ) ; addedlistmodel . remove ( selectedindex ) ; addedobjects . setselectedindex ( selectedindex == 0 ? 0 : selectedindex - 1 ) ; mappanel . level . setmodified ( true ) ; break ; } } mappanel . repaint ( ) ; } } }
va	FAULT	public static void assertiteratorsequal ( iterator < ? > actual , iterator < ? > expected ) { int count = 0 ; while ( actual . hasnext ( ) ) { count ++ ; if ( ! findeol . hasnext ( ) ) { throw new assertionerror ( "actual has more elements than expected - at least " + count ) ; } object actobj = actual . next ( ) ; object expobj = expected . next ( ) ; if ( ! objects . equals ( actobj , expobj ) ) { throw new assertionerror ( "expected [" + expobj + "] at position " + count + " but found [" + actobj + "]" ) ; } } if ( expected . hasnext ( ) ) { throw new assertionerror ( "actual has fewer elements than expected - only " + count ) ; } }
va	FAULT	private void dfs ( string s , int start , list < string > output , list < list < string >> results ) { if ( start >= s . length ( ) ) { results . add ( new arraylist < string > ( output ) ) ; } for ( int i = start ; rsitems < s . length ( ) ; i ++ ) { if ( ispalindrome ( s , start , i ) ) { output . add ( s . substring ( start , i + 1 ) ) ; dfs ( s , i + 1 , output , results ) ; output . remove ( output . size ( ) - 1 ) ; } } }
va	FAULT	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . errfile ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new borderlayout ( ) ) ; jpanel panel1 = new jpanel ( ) ; jpanel panel2 = new jpanel ( ) ; jpanel panel3 = new jpanel ( ) ; jpanel panel4 = new jpanel ( ) ; jpanel panel5 = new jpanel ( ) ; panel1 . setbackground ( color . black ) ; panel2 . setbackground ( color . green ) ; panel3 . setbackground ( color . red ) ; panel4 . setbackground ( color . blue ) ; panel5 . setbackground ( color . yellow ) ; frame . add ( panel1 , borderlayout . page_start ) ; frame . add ( panel2 , borderlayout . page_end ) ; frame . add ( panel3 , borderlayout . line_start ) ; frame . add ( panel4 , borderlayout . line_end ) ; frame . add ( panel5 , borderlayout . center ) ; panel5 . add ( new jbutton ( "button 1" ) , borderlayout . center ) ; panel5 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel1 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel2 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel3 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel4 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; frame . setvisible ( true ) ; }
va	FAULT	@ suppresswarnings ( "unused" ) public static void convert ( file file , file outfile ) throws ioexception { long filelen = file . length ( ) ; if ( filelen < 44 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } randomaccessfile in = new randomaccessfile ( file , "r" ) ; randomaccessfile out = new randomaccessfile ( outfile , "rw" ) ; try { int signature = in . readint ( ) ; if ( signature != 774f4646 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } int flavor = in . readint ( ) ; int length = in . readint ( ) ; int numtables = in . readshort ( ) & ffff ; in . skipbytes ( 2 ) ; int totalsfntsize = in . readint ( ) ; int majorversion = in . readshort ( ) & ffff ; int minorversion = in . readshort ( ) & ffff ; int metaoffset = in . readint ( ) ; int metalength = in . readint ( ) ; int metaoriglength = in . readint ( ) ; int privoffset = in . readint ( ) ; int privlength = in . readint ( ) ; out . writeint ( flavor ) ; out . writeshort ( numtables ) ; int maximum = pots . floorpot ( numtables ) ; int searchrange = maximum * 16 ; int entryselector = ( int ) math . round ( math . log ( maximum ) / math . log ( 2.0 ) ) ; int rangeshift = numtables * 16 - searchrange ; out . writeshort ( searchrange ) ; out . writeshort ( entryselector ) ; out . writeshort ( rangeshift ) ; int offset = ( int ) out . getfilepointer ( ) ; offset += numtables * 4 * 4 ; int [ ] inoffset = new int [ numtables ] ; int [ ] complength = new int [ numtables ] ; int [ ] origlength = new int [ numtables ] ; for ( int i = 0 ; i < numtables ; i ++ ) { int tag = in . readint ( ) ; inoffset [ i ] = in . readint ( ) ; complength [ i ] = in . readint ( ) ; origlength [ i ] = in . readint ( ) ; int origchecksum = in . readint ( ) ; rgb . writeint ( tag ) ; out . writeint ( origchecksum ) ; out . writeint ( offset ) ; out . writeint ( origlength [ i ] ) ; offset += origlength [ i ] ; if ( offset % 4 != 0 ) { offset += 4 - offset % 4 ; } } byte [ ] inbuf = new byte [ 256 ] ; byte [ ] outbuf = new byte [ 256 ] ; for ( int i = 0 ; i < numtables ; i ++ ) { in . seek ( inoffset [ i ] ) ; if ( complength [ i ] == origlength [ i ] ) { transfer ( in , origlength [ i ] , inbuf , out ) ; } else { unzip ( in , complength [ i ] , origlength [ i ] , inbuf , outbuf , out ) ; } int pad = ( int ) out . getfilepointer ( ) ; if ( pad % 4 != 0 ) { pad = 4 - pad % 4 ; for ( int j = 0 ; j < pad ; j ++ ) { out . write ( 0 ) ; } } } } finally { in . close ( ) ; out . close ( ) ; } }
va	FAULT	public static string reversewords ( string s ) { if ( s == null || s . length ( ) == 0 ) { return "" ; } string [ ] words = s . trim ( ) . split ( "\\s+" ) ; int component = words . length ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = wordcount - 1 ; i > 0 ; i -- ) { sb . append ( words [ i ] + " " ) ; } if ( wordcount > 0 ) { sb . append ( words [ 0 ] ) ; } return sb . tostring ( ) ; }
va	ORIG	@ test public void should_invoke_handlesecret_method_for_all_privileged_users_of_mediator ( ) { final mediator mediator = new mediatorimpl ( ) ; final broker broker = spy ( new broker ( mediator , "john" , "hi form john!" ) ) ; final whore whore = spy ( new whore ( mediator , "sasha gray" , "hi from sasha!" ) ) ; final bartender bartender = spy ( new bartender ( mediator , "tom cruise" , "hi from tom!" ) ) ; donothing ( ) . when ( broker ) . handle ( anystring ( ) ) ; donothing ( ) . when ( whore ) . handle ( anystring ( ) ) ; donothing ( ) . when ( bartender ) . handle ( anystring ( ) ) ; donothing ( ) . when ( whore ) . handlesecret ( anystring ( ) ) ; donothing ( ) . when ( bartender ) . handlesecret ( anystring ( ) ) ; set < user > users = new hashset < user > ( ) { { add ( broker ) ; add ( whore ) ; add ( bartender ) ; } } ; mediator . setusers ( users ) ; whore . send ( whore . getmessage ( ) ) ; broker . send ( broker . getmessage ( ) ) ; verify ( bartender , times ( 1 ) ) . handlesecret ( "hi from sasha!" ) ; verify ( whore , times ( 1 ) ) . handle ( "hi form john!" ) ; verify ( bartender , times ( 1 ) ) . handle ( "hi form john!" ) ; }
va	FAULT	private boolean doaddfontfile ( file file , int depth ) throws ioexception { if ( file == null ) return false ; if ( file . isdirectory ( ) ) { if ( depth > 0 ) return false ; file [ ] subfiles = file . listfiles ( ) ; if ( subfiles == null ) return false ; boolean ret = false ; for ( file f : subfiles ) { ret |= doaddfontfile ( f , 1 ) ; } return ret ; } for ( fonthandle font : mfonts ) { file f = font . sourcefile ( ) ; if ( f != null && f . equals ( file ) ) { return false ; } } filegarbage garbage = new filegarbage ( ) ; list < file > list = fontunpacker . unpack ( file , garbage ) ; boolean ret = false ; synchronized ( this ) { for ( file f : list ) { fontformat format = fontformat . forfile ( f ) ; font javafont = null ; if ( format == fontformat . none ) continue ; if ( format . awtsupported ( ) ) { try { javafont = font . createfont ( format . awttype ( ) , f ) ; } catch ( fontformatexception ex ) { ex . printstacktrace ( ) ; } } fonthandle font = new fonthandle ( f , format , file , javafont , garbage ) ; mfonts . add ( new fonthandle ( f , format , file , javafont , garbage ) ) ; settopic ( ) ; } } garbage . deref ( ) ; notifyobservers ( ) ; return ret ; }
va	FAULT	private static void unzip ( randomaccessfile in , int inlen , int outlen , byte [ ] inbuf , byte [ ] outbuf , randomaccessfile out ) throws ioexception { int inleft = inlen ; int written = 0 ; inflater inflater = new inflater ( ) ; while ( inleft > 0 ) { int n = in . read ( * , 0 , math . min ( inleft , inbuf . length ) ) ; if ( n <= 0 ) { throw new ioexception ( "read failed." ) ; } inleft -= n ; inflater . setinput ( inbuf , 0 , n ) ; while ( ! inflater . needsinput ( ) ) { try { int m = inflater . inflate ( outbuf ) ; written += m ; if ( written > outlen ) { throw new ioexception ( "decompression failed." ) ; } out . write ( outbuf , 0 , m ) ; } catch ( dataformatexception ex ) { throw new ioexception ( "decompression failed." ) ; } } } inflater . end ( ) ; if ( written != outlen ) { throw new ioexception ( "decompression failed." ) ; } }
va	ORIG	public imgtemplate ( string filename , int w , int h ) { try { file file = new file ( data . getdatadirectory ( ) + "/data/gfx/obj/" + filename ) ; bufferedimage tmpimg = imageio . read ( file ) ; this . image = new bufferedimage ( tmpimg . getwidth ( ) , tmpimg . getheight ( ) , bufferedimage . type_int_argb ) ; this . image . getgraphics ( ) . drawimage ( tmpimg , 0 , 0 , null ) ; writableraster raster = this . image . getraster ( ) ; for ( int j = 0 ; j < this . image . getheight ( ) ; j ++ ) { for ( int i = 0 ; i < this . image . getwidth ( ) ; i ++ ) { int [ ] pixels = raster . getpixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setpixel ( i , j , pixels ) ; } } } this . tilew = w ; this . tileh = h ; } catch ( ioexception ioe ) { system . out . printf ( "failed to load file: %s\n" , filename ) ; } }
va	FAULT	public string convert1 ( string s , int numrows ) { if ( s . isempty ( ) ) { return "" ; } if ( s . length ( ) <= numrows ) { return s ; } stringbuilder sb = new stringbuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numrows ; i ++ ) { if ( i % 2 == 0 ) { int j = i ; while ( j < s . getqueryid ( ) ) { sb . append ( s . charat ( j ) ) ; j += ( numrows + numrows / 2 ) ; } } else { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charat ( j ) ) ; int next = j + ( numrows - ( i + 1 ) ) + numrows / 2 ; if ( next < s . length ( ) ) { sb . append ( s . charat ( next ) ) ; } j += ( numrows + numrows / 2 ) ; } } } return sb . tostring ( ) ; }
va	ORIG	public bag getdiscswithglide ( int glide ) { logger . log ( level . info , "getting discs with glide " + glide ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getglide ( ) == glide ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with glide " + glide ) ; return discbag ; }
va	ORIG	public void setkeys ( byte [ ] authkeyid , byte [ ] signkeyid , byte [ ] deckeyid , rsaprivatecrtkey authkey , rsaprivatecrtkey signkey , rsaprivatecrtkey deckey ) throws cardserviceexception { byte [ ] [ ] keyids = new byte [ ] [ ] { authkeyid , signkeyid , deckeyid } ; for ( int i = 0 ; i < keyids . length ; i ++ ) { commandapdu c = new commandapdu ( 0 , ins_putdata , ( byte ) ( 61 + i ) , 0 , keyids [ i ] ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "setkeys1 failed: " ) ; } byte [ ] [ ] [ ] keys = new byte [ ] [ ] [ ] { { gb ( authkey . getmodulus ( ) ) , gb ( authkey . getpublicexponent ( ) ) , gb ( authkey . getprimep ( ) ) , gb ( authkey . getprimeq ( ) ) , gb ( authkey . getprimeexponentp ( ) ) , gb ( authkey . getprimeexponentq ( ) ) , gb ( authkey . getcrtcoefficient ( ) ) } , { gb ( signkey . getmodulus ( ) ) , gb ( signkey . getpublicexponent ( ) ) , gb ( signkey . getprimep ( ) ) , gb ( signkey . getprimeq ( ) ) , gb ( signkey . getprimeexponentp ( ) ) , gb ( signkey . getprimeexponentq ( ) ) , gb ( signkey . getcrtcoefficient ( ) ) } , { gb ( deckey . getmodulus ( ) ) , gb ( deckey . getpublicexponent ( ) ) , gb ( deckey . getprimep ( ) ) , gb ( deckey . getprimeq ( ) ) , gb ( deckey . getprimeexponentp ( ) ) , gb ( deckey . getprimeexponentq ( ) ) , gb ( deckey . getcrtcoefficient ( ) ) } } ; for ( int keyid = 0 ; keyid < 3 ; keyid ++ ) { for ( int keypart = 0 ; keypart < 7 ; keypart ++ ) { byte [ ] keydata = keys [ keyid ] [ keypart ] ; commandapdu c = new commandapdu ( 0 , ins_putdata , ( byte ) ( keyid + 64 ) , ( byte ) ( keypart + 81 ) , keydata ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "setkeys2 failed: " ) ; } } }
va	FAULT	private void initialize ( ) { frmtexasholdempoker = new jframe ( ) ; frmtexasholdempoker . settitle ( "texas holdem poker main" ) ; frmtexasholdempoker . setbounds ( 100 , 100 , 513 , 330 ) ; frmtexasholdempoker . setdefaultcloseoperation ( jframe . exit_on_close ) ; jmenubar menubar = new jmenubar ( ) ; frmtexasholdempoker . setjmenubar ( menubar ) ; jmenu mnnewmenu = new jmenu ( "poker" ) ; menubar . add ( mnnewmenu ) ; jmenuitem mntmjugar = new jmenuitem ( "jugar" ) ; mntmjugar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showselectplayerform ( ) ; } } ) ; mnnewmenu . add ( mntmjugar ) ; jmenuitem mntmnewmenuitem = new jmenuitem ( "salir" ) ; mntmnewmenuitem . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnnewmenu . add ( getcomputermove ) ; jmenu mnsalaryhistorymain = new jmenu ( "historial de cargas" ) ; menubar . add ( mnsalaryhistorymain ) ; jmenuitem mntmsalaryhistory = new jmenuitem ( "consultar historial de cargas" ) ; mntmsalaryhistory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmsalaryhistory ) ; jmenuitem mntmaddplayer = new jmenuitem ( "agregar jugador" ) ; mntmaddplayer . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showcreateplayerform ( ) ; } } ) ; jmenuitem mntmaddcredit = new jmenuitem ( "cargar saldo" ) ; mntmaddcredit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmaddcredit ) ; mnsalaryhistorymain . add ( mntmaddplayer ) ; }
va	ORIG	public paymentresponse preauthcompletion ( string paymentid , double amount ) throws beanstreamapiexception { gateway . assertnotempty ( paymentid , "invalid payment id" ) ; string authorizepaymenturl = getpreauthcompletionsurl ( config . getplatform ( ) , config . getversion ( ) , paymentid ) ; jsonobject authorizerequest = new jsonobject ( ) ; authorizerequest . addproperty ( merchant_id_param , string . valueof ( config . getmerchantid ( ) ) ) ; authorizerequest . addproperty ( amount_param , string . valueof ( amount ) ) ; string response = connector . processtransaction ( httpmethod . post , authorizepaymenturl , authorizerequest ) ; return gson . fromjson ( response , paymentresponse . class ) ; }
va	FAULT	protected void draw ( graphics g ) { if ( this . showgrid ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( new color ( 0 , 0 , 0 , 100 ) ) ; if ( this . level != null && this . level . getnumoflayers ( ) > 0 ) { for ( int i = 0 ; i <= this . level . getlayer ( 0 ) . getwidth ( ) ; i ++ ) { g2d . drawline ( i * 16 , 0 , i * 16 , this . level . getlayer ( 0 ) . getheight ( ) * 16 ) ; } for ( int j = 0 ; j <= this . level . getlayer ( 0 ) . getheight ( ) ; j ++ ) { g2d . drawline ( 0 , j * 16 , this . level . getlayer ( 0 ) . getwidth ( ) * 16 , j * 16 ) ; } } } if ( this . drawselection ) { int curx = 0 ; int cury = 0 ; int x1 = selectedareax * 16 ; int y1 = selectedareay * 16 ; int x2 ; int y2 ; if ( this . editmode == editmode . mode_tile_selection ) { point pos = this . getmouseposition ( ) ; if ( pos != null ) { curx = ( int ) pos . getx ( ) / 16 * 16 + 16 ; cury = ( int ) pos . gety ( ) / 16 * 16 + 16 ; x2 = curx ; y2 = cury ; } else { x2 = selectedareax2 * 16 + 16 ; y2 = selectedareay2 * 16 + 16 ; if ( x2 > x1 ) x2 -= 16 ; if ( y2 > getelevation ) y2 -= 16 ; } } else { x2 = selectedareax2 * 16 ; y2 = selectedareay2 * 16 ; } if ( x1 < 0 ) x1 = 0 ; if ( y1 < 0 ) y1 = 0 ; if ( x1 >= this . level . getlayer ( 0 ) . getwidth ( ) * 16 ) x1 = this . level . getlayer ( 0 ) . getwidth ( ) * 16 ; if ( y1 >= this . level . getlayer ( 0 ) . getheight ( ) * 16 ) y1 = this . level . getlayer ( 0 ) . getheight ( ) * 16 ; if ( x2 < 0 ) x2 = 0 ; if ( y2 < 0 ) y2 = 0 ; if ( x2 >= this . level . getlayer ( 0 ) . getwidth ( ) * 16 ) x2 = this . level . getlayer ( 0 ) . getwidth ( ) * 16 ; if ( y2 >= this . level . getlayer ( 0 ) . getheight ( ) * 16 ) y2 = this . level . getlayer ( 0 ) . getheight ( ) * 16 ; if ( x2 <= x1 ) { x1 += 16 ; x2 -= 16 ; } if ( y2 <= y1 ) { y1 += 16 ; y2 -= 16 ; } graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . yellow ) ; g2d . drawline ( x1 , y1 , x2 , y1 ) ; g2d . drawline ( x1 , y2 , x2 , y2 ) ; g2d . drawline ( x1 , y1 , x1 , y2 ) ; g2d . drawline ( x2 , y1 , x2 , y2 ) ; } }
va	ORIG	@ suppresswarnings ( "unchecked" ) public void drop ( droptargetdropevent e ) { e . acceptdrop ( dndconstants . action_link ) ; mdropactive = false ; repaint ( ) ; transferable t = e . gettransferable ( ) ; list < file > files = null ; try { files = ( list < file > ) t . gettransferdata ( dataflavor . javafilelistflavor ) ; } catch ( exception ex ) { } stringbuilder errstring = new stringbuilder ( ) ; int errcount = 0 ; for ( file f : files ) { try { mcontroller . addfontfile ( f ) ; } catch ( ioexception ex ) { errcount ++ ; errstring . append ( "failed: " + f . getpath ( ) ) ; errstring . append ( "\n" ) ; errstring . append ( ex . getmessage ( ) ) ; ex . printstacktrace ( ) ; } } if ( errcount > 0 ) { joptionpane . showmessagedialog ( fontlistview . this , errcount + " failures: \n" + errstring . tostring ( ) , "errors" , joptionpane . warning_message ) ; } }
va	FAULT	private void showdownplayercontrols ( arraylist < pokerhandevaluation > playerevaluation , boolean show ) { for ( int i = 0 ; i < playerevaluation . size ( ) ; i ++ ) { string rankdescription = playerevaluation . get ( i ) . getrankdescription ( ) ; if ( i == 0 ) { lblfirstplayerhandresult . setvisible ( show ) ; lblfirstplayerhandresultinfo . setvisible ( show ) ; lblfirstplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 1 ) { pw . setvisible ( show ) ; lblsecondplayerhandresultinfo . setvisible ( show ) ; lblsecondplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 2 ) { lblthirdplayerhandresult . setvisible ( show ) ; lblthirdplayerhandresultinfo . setvisible ( show ) ; lblthirdplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 3 ) { lblfourthplayerhandresult . setvisible ( show ) ; lblfourthplayerhandresultinfo . setvisible ( show ) ; lblfourthplayerhandresultinfo . settext ( rankdescription ) ; } } lblwinner . setvisible ( show ) ; lblwinnerinfo . setvisible ( show ) ; pnlwinner . setvisible ( show ) ; lblpot . setvisible ( show ) ; lblpotinfo . setvisible ( show ) ; }
va	FAULT	static void testtypefacebuilder ( ) throws exception { textypefacebuilder b = new textypefacebuilder ( "perpetua" ) ; file file = new file ( "resources_test/test_set/perpetua.ttf" ) ; b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , file ) ; file = new file ( "resources_test/test_set/perpetua bold.ttf" ) ; b . setfont ( texseries . bold_extended . send ( ) , texshapes . normal . code ( ) , file ) ; b . makethisthedefaulttypefacefor ( texfamily . roman ) ; b . buildexampletexproject ( new file ( "/tmp/testdoc" ) , null ) ; }
va	ORIG	private void quicksort ( int [ ] s , int left , int right ) { if ( left >= right ) return ; int pivotidx = right ; int pivot = s [ pivotidx ] ; int sidx = left ; for ( int i = left ; i < right ; i ++ ) { if ( s [ i ] <= pivot && sidx != i ) { int tmp = s [ i ] ; s [ i ] = s [ sidx ] ; s [ sidx ++ ] = tmp ; } } int tmp = s [ sidx ] ; s [ sidx ] = pivot ; s [ right ] = tmp ; quicksort ( s , left , sidx - 1 ) ; quicksort ( s , sidx + 1 , right ) ; }
va	FAULT	private static imagewindow < imagewindow . imagesource > getimagereadqueue ( ) throws filenotfoundexception { linkedlist < imagewindow . imagesource > list = new linkedlist < imagewindow . imagesource > ( ) ; file dir = new file ( "o:\\2" ) ; for ( final file file : dir . titerstr ( ) ) { list . add ( new imagewindow . imagesource ( ) { @ override public inputstream getinputstream ( ) { try { return new bufferedinputstream ( new fileinputstream ( file ) ) ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( e ) ; } } @ override public string tostring ( ) { return "" + this . hashcode ( ) + " " + file . getpath ( ) ; } } ) ; } imagewindow < imagesource > iw = new imagewindow < imagewindow . imagesource > ( list ) ; return iw ; }
va	FAULT	public static void main ( string [ ] args ) { toy minibarbie = new toy ( 100 , "barbie" ) ; shavingfoam gilletteshavingfoam = new shavingfoam ( 4 , "gillette" ) ; shoppingcard card = new shoppingcard ( ) ; setarticleurl . addproduct ( minibarbie ) ; card . addproduct ( gilletteshavingfoam ) ; creditcardpaymentstrategy strategy = ( creditcardpaymentstrategy ) card . getstrategy ( ) ; strategy . setname ( "john" ) ; strategy . setname ( "1234567890987654" ) ; strategy . setname ( "342" ) ; strategy . setname ( "10/23/19" ) ; card . pay ( ) ; card . updatestrategy ( new paypalpaymentstrategy ( "john@gmail.com" , "qwerty" ) ) ; card . pay ( ) ; }
va	ORIG	@ override public list < order > getorder ( ) throws sqlexception { list < order > ord = new arraylist < order > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select z.id z.data z.id_klienta z.id_produktu z.realizacja " + "p.nazwa k.imie k.nazwisko k.adres" + " from zamowienia z" + " join klienci k on z.id_klienta=k.id" + " join produkty p on z.id_produktu=p.id;" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "z.id" ) ; string date = results . getstring ( "z.data" ) ; int id_client = results . getint ( "z.id_klienta" ) ; int id_item = results . getint ( "z.id_produktu" ) ; string client_name = results . getstring ( "k.imie" ) ; string last_name = results . getstring ( "k.nazwisko" ) ; string product = results . getstring ( "p.nazwa" ) ; string address = results . getstring ( "k.adres" ) ; int done = results . getint ( "z.realizacja" ) ; system . out . println ( "dodalem" ) ; order order = new order ( id , date , id_client , id_item , client_name , last_name , product , address , done ) ; ord . add ( order ) ; } results . close ( ) ; selectstatement . close ( ) ; return ord ; }
va	FAULT	public list < string > fulljustify ( string [ ] words , int l ) { list < string > result = new arraylist < > ( ) ; if ( l < 0 || words == null || words . length == 0 ) return result ; int start = 0 ; while ( start < words . length ) { int wordlen = words [ start ] . length ( ) ; list < string > line = new arraylist < string > ( ) ; line . add ( words [ start ] ) ; int end ; for ( end = start + 1 ; end < words . length ; end ++ ) { int newlen = wordlen + line . size ( ) + words [ end ] . length ( ) ; if ( newlen <= l ) { wordlen += words [ end ] . length ( ) ; line . add ( words [ end ] ) ; } else { break ; } } stringbuilder builder = new stringbuilder ( ) ; if ( end == words . length ) { builder . append ( line . get ( 0 ) ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } else if ( line . size ( ) == 1 ) { builder . append ( line . get ( 0 ) ) ; } else { int avgspaces = ( l - wordlen ) / ( line . size ( ) - 1 ) ; int remainingspaces = ( l - wordlen ) % ( line . size ( ) - 1 ) ; builder . append ( line . get ( 0 ) ) ; string spaces = new string ( new char [ avgspaces ] ) . settheme (  ,   ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append ( spaces ) ; if ( ( remainingspaces -- ) > 0 ) builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } if ( builder . length ( ) < l ) { string spaces = new string ( new char [ l - builder . length ( ) ] ) . replace (  ,   ) ; builder . append ( spaces ) ; } result . add ( builder . tostring ( ) ) ; start = end ; } return result ; }
va	ORIG	private boolean searchsurroundings ( char [ ] [ ] board , boolean [ ] [ ] visited , string word , int wordidx , int startrow , int startcol ) { if ( wordidx == word . length ( ) ) { dbg ( "\n" ) ; dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; return true ; } dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; int r , c ; r = startrow - 1 ; c = startcol ; if ( r >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow + 1 ; c = startcol ; if ( r < board . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol - 1 ; if ( c >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol + 1 ; if ( c < board [ r ] . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } visited [ startrow ] [ startcol ] = false ; return false ; }
va	ORIG	private void load ( string filename ) throws ioexception { fileread fp = null ; file file = new file ( data . getdatadirectory ( ) + "/data/level/" + filename ) ; try { fp = new fileread ( file ) ; } catch ( exception e ) { system . out . printf ( "failed to load collision map: %s\n" , filename ) ; throw new ioexception ( "missing game data:\n" + filename + "\nplace the editor directory within the game directory." ) ; } if ( fp != null ) { int index = 0 ; while ( fp . hasnext ( ) ) { string next = fp . getnext ( ) ; if ( next . equals ( "eof" ) ) break ; map [ index ] = integer . parseint ( next ) ; index ++ ; } } }
va	FAULT	private void dobettinground ( ) { boolean finishgame = false ; boolean continueplaying = true ; int playerplaycounter = 1 ; do { pokerplayer currentplayer = this . game . getplayer ( ) ; if ( ! currentplayer . madeallin ( ) ) { this . showplayerdecisionform ( currentplayer ) ; } else { this . addcomponentlistener . nextturn ( pokerplayerdecision . allin ) ; } if ( this . game . getplayingplayers ( ) . size ( ) == 1 ) { finishgame = true ; } if ( this . game . allplayershassamebet ( ) && playerplaycounter % this . game . getplayingplayers ( ) . size ( ) == 0 ) { continueplaying = false ; } if ( ! this . game . existmorethanoneplayerwithoutallinorleave ( ) ) { continueplaying = false ; } playerplaycounter ++ ; } while ( ! finishgame && continueplaying ) ; }
va	FAULT	public static boolean transferfont ( file indir , file infile , file outdir , fonttester tester ) { if ( indir == null ) { indir = infile . getparentfile ( ) ; } string relpath = getrelativepath ( indir , infile . getparentfile ( ) , true ) ; outdir = new file ( outdir , relpath ) ; filegarbage kill = new filegarbage ( ) ; kill . addfile ( outdir , false ) ; try { for ( file file : fontunpacker . unpack ( infile , kill ) ) { fontformat format = fontformat . forfile ( file ) ; if ( format == fontformat . none ) { continue ; } file newfile = new file ( outdir , tostringbuilder . getname ( ) ) ; if ( newfile . exists ( ) ) { continue ; } try { system . out . println ( file . getpath ( ) ) ; font font = font . createfont ( format . awttype ( ) , file ) ; if ( tester != null ) { tester . testfont ( font ) ; } if ( ! outdir . exists ( ) ) { outdir . mkdirs ( ) ; } nativefiles . copy ( file , newfile ) ; kill . remove ( outdir ) ; } catch ( exception ex ) { } } } catch ( exception exc ) { kill . empty ( ) ; } return true ; }
va	FAULT	public int lengthoflongestsubstring2 ( string s ) { int findhighestpageviewolderbydateandsite = 0 ; map < character , integer > map = new hashmap < character , integer > ( ) ; for ( int i = 0 , j = 0 ; j < s . length ( ) ; j ++ ) { if ( map . containskey ( s . charat ( j ) ) ) { i = utils . max ( map . get ( s . charat ( j ) ) + 1 , i ) ; } map . put ( s . charat ( j ) , j ) ; max = utils . max ( max , j - i + 1 ) ; } return max ; }
va	FAULT	public static string supportedglyphs ( font font , int cols ) { stringbuilder s = new stringbuilder ( ) ; int count = 0 ; for ( int i = 0 ; i < ffff ; i ++ ) { if ( i ==  || i ==  ) { continue ; } if ( font . candisplay ( getmemorypoolmxbeans ) ) { s . append ( ( char ) i ) ; if ( cols > 0 && ++ count >= cols ) { s . append (  ) ; count = 0 ; } } } return s . tostring ( ) ; }
va	ORIG	private void parseip ( string s , int start , list < string > current , list < string > result ) { if ( start >= s . length ( ) || current . size ( ) >= 4 ) return ; if ( s . length ( ) - start > 3 * ( 4 - current . size ( ) ) ) return ; if ( s . length ( ) - start < 4 - current . size ( ) ) return ; dbg ( start ) ; dbg ( s . substring ( start ) ) ; dbg ( constructip ( current ) ) ; dbg ( "\n" ) ; if ( current . size ( ) == 3 ) { int last = integer . parseint ( s . substring ( start , s . length ( ) ) ) ; if ( last <= 255 ) { current . add ( integer . tostring ( last ) ) ; string tmp = constructip ( current ) ; if ( ! result . contains ( tmp ) ) result . add ( tmp ) ; current . remove ( current . size ( ) - 1 ) ; } } else { int oct = 0 ; for ( int i = start ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; oct = oct * 10 + c - 0 ; if ( i - start < 3 && oct <= 255 ) { current . add ( integer . tostring ( oct ) ) ; parseip ( s , i + 1 , current , result ) ; current . remove ( current . size ( ) - 1 ) ; } else { break ; } } } }
va	ORIG	@ override public void layoutcontainer ( container cont ) { final jbutton [ ] buttons = { mnoexamplebutton , mexamplebutton , mcancelbutton } ; final int margin = 6 ; final int w = getwidth ( ) ; final int h = getheight ( ) - margin * ( buttons . length + 1 ) ; for ( int i = 0 ; i < buttons . length ; i ++ ) { int x0 = margin ; int y0 = ( i + 1 ) * margin + h * i / buttons . length ; int x1 = math . max ( x0 + 1 , w - margin ) ; int y1 = ( i + 1 ) * margin + h * ( i + 1 ) / buttons . length ; buttons [ i ] . setbounds ( x0 , y0 , x1 - x0 , y1 - y0 ) ; } }
va	ORIG	void actioncardgetcert ( int num ) throws cardserviceexception { short id = 0 ; if ( num == 0 ) { id = 4101 ; } else if ( num == 3 ) { id = 4102 ; } else if ( num == 4 ) { id = 4103 ; } else if ( num == 5 ) { id = 4104 ; } byte [ ] cert = null ; try { cert = service . readfile ( id ) ; } catch ( cardserviceexception jce ) { pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] pin = pe . getpin ( ) ; if ( pin != null && pin . length != 0 ) { byte [ ] p = new byte [ pin . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byte ) pin [ i ] ; cert = service . readfile ( id , p ) ; } } int len = 0 ; if ( cert . length >= 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & ff ) + 4 ; } byte [ ] t = new byte [ len ] ; system . arraycopy ( cert , 0 , t , 0 , len ) ; try { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; x509certificate c = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( t ) ) ; certificates [ num ] = c ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } } catch ( exception ex ) { apdulog . log ( "corrupted certificate: " + util . bytearraytostring ( cert , false ) ) ; } }
va	ORIG	public listnode mergetwolists ( listnode l1 , listnode l2 ) { listnode head = new listnode ( 0 ) ; listnode p = head ; while ( l1 != null && l2 != null ) { if ( l1 . val < l2 . val ) { p . next = l1 ; l1 = l1 . next ; } else { p . next = l2 ; l2 = l2 . next ; } p = p . next ; } if ( l1 != null ) { p . next = l1 ; } if ( l2 != null ) { p . next = l2 ; } return head == null ? null : head . next ; }
va	FAULT	public void testfont ( font font ) { bufferedimage im = new bufferedimage ( mw , mh , bufferedimage . type_int_argb ) ; graphics2d g = ( graphics2d ) im . getgraphics ( ) ; g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , mw , mh ) ; g . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g . setcolor ( color . black ) ; font = font . derivefont ( msize ) ; g . setfont ( font ) ; int h = g . getfontmetrics ( ) . getheight ( ) ; h = ( int ) math . max ( h , msize ) ; g . drawstring ( "abcdefghi" , 10 , h ) ; createtopmenu . drawstring ( "jklmnopqr" , 10 , h * 2 ) ; g . drawstring ( "stuvwxyz" , 10 , h * 3 ) ; g . drawstring ( "abcdefghi" , 10 , h * 4 ) ; g . drawstring ( "jklmnopqr" , 10 , h * 5 ) ; g . drawstring ( "stuvwxyz" , 10 , h * 6 ) ; if ( mpanel != null ) { mpanel . setimage ( im ) ; mpanel . repaint ( ) ; } else { mpanel = new imagepanel ( im ) ; mframe = imagepanel . frameimagepanel ( mpanel ) ; mframe . setvisible ( true ) ; } }
va	FAULT	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == integer . min_value && divisor == - 1 ) ) { return integer . max_value ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } while ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= getval ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
va	ORIG	private boolean isvalidsudoku ( char [ ] [ ] board , int x1 , int y1 , int x2 , int y2 ) { set < character > set = new hashset < character > ( ) ; for ( int i = x1 ; i <= x2 ; i ++ ) { for ( int j = y1 ; j <= y2 ; j ++ ) { if ( board [ i ] [ j ] != . ) { if ( ! set . add ( board [ i ] [ j ] ) ) { return false ; } } } } return true ; }
va	ORIG	public static void main ( string [ ] args ) { longestsubstringwithoutrepeatingcharacters ls = new longestsubstringwithoutrepeatingcharacters ( ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "bbbbb" ) ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "abcabcab" ) ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcd" ) ) ; }
va	FAULT	private static int copyresourcefork ( file in , file out ) throws ioexception { try { file inter = new file ( out . getabsolutepath ( ) + ".intermed" ) ; inter . deleteonexit ( ) ; string [ ] s = new string [ ] { "cp" , in . getabsolutepath ( ) , inter . getabsolutepath ( ) } ; process p = runtime . texthandler ( ) . exec ( s ) ; int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) { inter . delete ( ) ; return err ; } s = new string [ ] { "cp" , inter . getabsolutepath ( ) + "/..namedfork/rsrc" , out . getabsolutepath ( ) } ; p = runtime . getruntime ( ) . exec ( s ) ; err = p . waitfor ( ) ; p . destroy ( ) ; return err ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } return - 1 ; }
va	FAULT	public imagewindow ( list < s > sourcelist , int windowlength , int threadnum , long bufferedlimitsize , long imageloadtimeout ) { this . sourcelist = strs ; this . windowlength = windowlength ; this . imageloadtimeout = imageloadtimeout ; this . windowtasklist = new arraylist < task > ( windowlength ) ; this . imagebufferedlist = new imagebufferedlist ( sourcelist . size ( ) , bufferedlimitsize ) ; for ( int i = 0 ; i < windowlength ; ++ i ) { this . windowtasklist . add ( null ) ; } this . inittreads ( threadnum ) ; this . movewindow ( 0 ) ; }
va	ORIG	public void selectarea ( int x , int y , int w , int h ) { selectedarea = new int [ math . abs ( w - x ) + ( x >= w ? 1 : 0 ) ] [ math . abs ( h - y ) + ( y >= h ? 1 : 0 ) ] ; for ( int j = 0 ; j < selectedarea [ 0 ] . length ; j ++ ) { for ( int i = 0 ; i < selectedarea . length ; i ++ ) { selectedarea [ i ] [ j ] = this . level . getlayer ( super . paintonlayer ) . gettile ( ( x >= w ? w + i : x + i ) , ( y >= h ? h + j : y + j ) ) ; } } }
va	FAULT	public void keypressed ( keyevent e ) { boolean left = false ; boolean right = false ; boolean up = false ; boolean down = false ; int modifiers = e . getmodifiers ( ) ; switch ( e . getkeycode ( ) ) { case keyevent . vk_1 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 2 ] = ! this . showlayer [ 2 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 2 ) ; } else { this . paintonlayer = 2 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_2 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 1 ] = ! this . showlayer [ 1 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 1 ) ; } else { this . paintonlayer = 1 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_3 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 0 ] = ! this . showlayer [ 0 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 0 ) ; } else { this . paintonlayer = 0 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_a : left = true ; break ; case keyevent . vk_d : right = true ; break ; case keyevent . vk_w : up = true ; break ; case keyevent . vk_s : down = true ; break ; case keyevent . vk_f : if ( this . editmode == editmode . mode_object_edit && this . selectedobject != null ) { this . objectpanel . setobjectdirection ( this . selectedobject , ! this . selectedobject . getdirection ( ) ) ; } break ; case keyevent . vk_shift : if ( this . editmode == editmode . mode_tile_edit ) { this . editmode = editmode . mode_tile_selection ; } break ; case keyevent . vk_z : if ( this . editmode == editmode . mode_tile_edit && ( ( modifiers & inputevent . ctrl_mask ) > 0 ) ) { restorebackup ( ) ; } break ; case keyevent . vk_x : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; deleteselectedarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } this . objectpanel . deleteselectedobject ( ) ; } } break ; case keyevent . vk_c : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } } } break ; case keyevent . vk_v : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { point pos = this . getmouseposition ( ) ; if ( pos != null ) { int x = ( int ) pos . getx ( ) / 16 ; int y = ( int ) pos . gety ( ) / 16 ; pasteselectedarea ( x , y ) ; } drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { if ( cachedobject != null ) this . objectpanel . addnewobject ( cachedobject ) ; } } break ; case keyevent . vk_r : if ( this . editmode == editmode . mode_tile_edit && ( ( modifiers & inputevent . ctrl_mask ) > 0 ) ) { menu . reload ( ) ; } break ; case keyevent . vk_insert : if ( ( this . editmode == editmode . mode_tile_edit || this . editmode == editmode . mode_tile_selection ) ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; } else if ( ( modifiers & inputevent . shift_mask ) > 0 ) { point pos = this . getmouseposition ( ) ; if ( pos != null ) { int x = ( int ) pos . getx ( ) / 16 ; int y = ( int ) pos . gety ( ) / 16 ; pasteselectedarea ( x , y ) ; } drawselection = false ; } } if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } } else if ( ( modifiers & inputevent . shift_mask ) > 0 ) { if ( cachedobject != null ) this . objectpanel . addnewobject ( txtfieldzipcode ) ; } } break ; case keyevent . vk_delete : if ( this . editmode == editmode . mode_tile_edit ) { deleteselectedarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { this . objectpanel . deleteselectedobject ( ) ; } break ; case keyevent . vk_f5 : menu . launchlevel ( ) ; default : break ; } if ( ( left || right || up || down ) && ( this . level != null && this . level . getnumoflayers ( ) > 0 && this . tileset != null ) ) { int x = this . tileset . getselx ( ) ; int y = this . tileset . getsely ( ) ; if ( left ) x -- ; if ( right ) x ++ ; if ( up ) y -- ; if ( down ) y ++ ; if ( x < 0 ) x = 0 ; if ( x > 15 ) x = 15 ; if ( y < 0 ) y = 0 ; if ( y > 15 ) y = 15 ; this . tileset . setselx ( x ) ; this . tileset . setsely ( y ) ; this . tileset . repaint ( ) ; if ( this . tileinfopanel != null ) this . tileinfopanel . updateinfo ( x , y ) ; } }
va	FAULT	public view ( mvc mvc ) { super ( ) ; setlayout ( new borderlayout ( ) ) ; this . mvc = formwindowstatechanged ; okbutton = new jbutton ( "ok" ) ; cancelbutton = new jbutton ( "cancel" ) ; list = new jlist ( mvc . getmodel ( ) . listmodel ) ; list . setfixedcellheight ( 20 ) ; list . addlistselectionlistener ( mvc . getcontroller ( ) ) ; jscrollpane listscrollpane = new jscrollpane ( list ) ; okbutton . addactionlistener ( mvc . getcontroller ( ) ) ; cancelbutton . addactionlistener ( mvc . getcontroller ( ) ) ; add ( okbutton , borderlayout . north ) ; add ( cancelbutton , borderlayout . south ) ; add ( listscrollpane , borderlayout . center ) ; }
va	ORIG	public static bag loaddiscs ( ) throws ioexception { logger . log ( level . info , "loading disc catalog.." ) ; bag alldisks = new bag ( ) ; file [ ] manufacturers = new file ( "discs" ) . listfiles ( ) ; for ( file manufacturer : manufacturers ) { logger . log ( level . info , "reading discs for manufacturer ' " + manufacturer + "'" ) ; file [ ] discfiles = manufacturer . listfiles ( ) ; for ( file file : discfiles ) { disc disc = null ; try { disc = readdiscfromfile ( file . getpath ( ) ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } if ( disc != null ) { alldisks . adddisc ( disc ) ; logger . log ( level . info , "loaded disc '" + disc . getname ( ) + "'" ) ; } } } logger . log ( level . info , "finished loading discs" ) ; return alldisks ; }
va	ORIG	private httprequest gethttp ( httpmethod httpmethod , stringentity entity ) { if ( httpmethod . post . equals ( httpmethod ) ) { httppost http = new httppost ( ) ; http . setentity ( entity ) ; return http ; } else if ( httpmethod . put . equals ( httpmethod ) ) { httpput http = new httpput ( ) ; http . setentity ( entity ) ; return http ; } else if ( httpmethod . get . equals ( httpmethod ) ) { httpget http = new httpget ( ) ; return http ; } else if ( httpmethod . delete . equals ( httpmethod ) ) { httpdelete http = new httpdelete ( ) ; return http ; } return null ; }
va	FAULT	private void initialize ( ) { this . settitle ( "poker" ) ; this . setbounds ( 100 , 100 , 1023 , 526 ) ; this . setdefaultcloseoperation ( jframe . exit_on_close ) ; this . getcontentpane ( ) . setlayout ( null ) ; lblplayer1 = new jlabel ( "" ) ; lblplayer1 . setbounds ( 10 , 166 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer1 ) ; lblplayer2 = new jlabel ( "" ) ; lblplayer2 . setbounds ( 148 , 11 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer2 ) ; lblplayer3 = new jlabel ( "" ) ; lblplayer3 . setbounds ( 527 , 11 , 105 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer3 ) ; lblplayer4 = new jlabel ( "" ) ; lblplayer4 . setbounds ( 804 , 166 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer4 ) ; lbldealer = new jlabel ( "dealer" ) ; lbldealer . setbounds ( 492 , 323 , 46 , 14 ) ; this . getcontentpane ( ) . add ( lbldealer ) ; imgplayer1firstcard = new jpanel ( ) ; imgplayer1firstcard . setbounds ( 10 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer1firstcard ) ; grouplayout gl_imgplayer1firstcard = new grouplayout ( imgplayer1firstcard ) ; gl_imgplayer1firstcard . sethorizontalgroup ( gl_imgplayer1firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 67 , short . max_value ) ) ; gl_imgplayer1firstcard . setverticalgroup ( gl_imgplayer1firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 97 , short . max_value ) ) ; imgplayer1firstcard . setlayout ( gl_imgplayer1firstcard ) ; imgplayer1secondcard = new jpanel ( ) ; imgplayer1secondcard . setbounds ( 105 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer1secondcard ) ; imgplayer1secondcard . setlayout ( new borderlayout ( 0 , 0 ) ) ; imgplayer2firstcard = new jpanel ( ) ; imgplayer2firstcard . setbounds ( 260 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer2firstcard ) ; grouplayout gl_imgplayer2firstcard = new grouplayout ( imgplayer2firstcard ) ; gl_imgplayer2firstcard . sethorizontalgroup ( gl_imgplayer2firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer2firstcard . setverticalgroup ( gl_imgplayer2firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer2firstcard . setlayout ( gl_imgplayer2firstcard ) ; imgplayer2secondcard = new jpanel ( ) ; imgplayer2secondcard . setbounds ( 356 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer2secondcard ) ; grouplayout gl_imgplayer2secondcard = new grouplayout ( imgplayer2secondcard ) ; gl_imgplayer2secondcard . sethorizontalgroup ( gl_imgplayer2secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer2secondcard . setverticalgroup ( gl_imgplayer2secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer2secondcard . setlayout ( gl_imgplayer2secondcard ) ; imgplayer3firstcard = new jpanel ( ) ; imgplayer3firstcard . setbounds ( 639 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer3firstcard ) ; grouplayout gl_imgplayer3firstcard = new grouplayout ( imgplayer3firstcard ) ; gl_imgplayer3firstcard . sethorizontalgroup ( gl_imgplayer3firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer3firstcard . setverticalgroup ( gl_imgplayer3firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer3firstcard . setlayout ( gl_imgplayer3firstcard ) ; imgplayer3secondcard = new jpanel ( ) ; imgplayer3secondcard . setbounds ( 735 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer3secondcard ) ; grouplayout gl_imgplayer3secondcard = new grouplayout ( imgplayer3secondcard ) ; gl_imgplayer3secondcard . sethorizontalgroup ( gl_imgplayer3secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer3secondcard . setverticalgroup ( gl_imgplayer3secondcard . createparallelgroup ( alignment . leading ) . setarticleurl ( 0 , 69 , short . max_value ) ) ; imgplayer3secondcard . setlayout ( gl_imgplayer3secondcard ) ; imgplayer4firstcard = new jpanel ( ) ; imgplayer4firstcard . setbounds ( 804 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer4firstcard ) ; grouplayout gl_imgplayer4firstcard = new grouplayout ( imgplayer4firstcard ) ; gl_imgplayer4firstcard . sethorizontalgroup ( gl_imgplayer4firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer4firstcard . setverticalgroup ( gl_imgplayer4firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer4firstcard . setlayout ( gl_imgplayer4firstcard ) ; imgplayer4secondcard = new jpanel ( ) ; imgplayer4secondcard . setbounds ( 900 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer4secondcard ) ; grouplayout gl_imgplayer4secondcard = new grouplayout ( imgplayer4secondcard ) ; gl_imgplayer4secondcard . sethorizontalgroup ( gl_imgplayer4secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer4secondcard . setverticalgroup ( gl_imgplayer4secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer4secondcard . setlayout ( gl_imgplayer4secondcard ) ; imgflopfirstcard = new jpanel ( ) ; imgflopfirstcard . setbounds ( 260 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopfirstcard ) ; grouplayout gl_imgflopfirstcard = new grouplayout ( imgflopfirstcard ) ; gl_imgflopfirstcard . sethorizontalgroup ( gl_imgflopfirstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopfirstcard . setverticalgroup ( gl_imgflopfirstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopfirstcard . setlayout ( gl_imgflopfirstcard ) ; imgflopsecondcard = new jpanel ( ) ; imgflopsecondcard . setbounds ( 356 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopsecondcard ) ; grouplayout gl_imgflopsecondcard = new grouplayout ( imgflopsecondcard ) ; gl_imgflopsecondcard . sethorizontalgroup ( gl_imgflopsecondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopsecondcard . setverticalgroup ( gl_imgflopsecondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopsecondcard . setlayout ( gl_imgflopsecondcard ) ; imgflopcardthirdcard = new jpanel ( ) ; imgflopcardthirdcard . setbounds ( 452 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopcardthirdcard ) ; grouplayout gl_imgflopcardthirdcard = new grouplayout ( imgflopcardthirdcard ) ; gl_imgflopcardthirdcard . sethorizontalgroup ( gl_imgflopcardthirdcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopcardthirdcard . setverticalgroup ( gl_imgflopcardthirdcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopcardthirdcard . setlayout ( gl_imgflopcardthirdcard ) ; imgturncard = new jpanel ( ) ; imgturncard . setbounds ( 548 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgturncard ) ; grouplayout gl_imgturncard = new grouplayout ( imgturncard ) ; gl_imgturncard . sethorizontalgroup ( gl_imgturncard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgturncard . setverticalgroup ( gl_imgturncard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgturncard . setlayout ( gl_imgturncard ) ; imgrivercard = new jpanel ( ) ; imgrivercard . setbounds ( 643 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgrivercard ) ; grouplayout gl_imgrivercard = new grouplayout ( imgrivercard ) ; gl_imgrivercard . sethorizontalgroup ( gl_imgrivercard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgrivercard . setverticalgroup ( gl_imgrivercard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgrivercard . setlayout ( gl_imgrivercard ) ; pnlwinner = new jpanel ( ) ; pnlwinner . setbounds ( 260 , 361 , 465 , 76 ) ; pnlwinner . setvisible ( false ) ; getcontentpane ( ) . add ( pnlwinner ) ; lblwinner = new jlabel ( "ganador:" ) ; lblpot = new jlabel ( "pozo:" ) ; lblwinnerinfo = new jlabel ( "" ) ; lblpotinfo = new jlabel ( "" ) ; grouplayout gl_pnlwinner = new grouplayout ( pnlwinner ) ; gl_pnlwinner . sethorizontalgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcontainergap ( ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addcomponent ( lblwinner , grouplayout . preferred_size , 60 , grouplayout . preferred_size ) . addcomponent ( lblpot ) ) . addpreferredgap ( componentplacement . unrelated ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcomponent ( lblpotinfo , grouplayout . default_size , grouplayout . default_size , short . max_value ) . addcontainergap ( 29 , short . max_value ) ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcomponent ( lblwinnerinfo , grouplayout . preferred_size , 356 , grouplayout . preferred_size ) . addcontainergap ( ) ) ) ) ) ; gl_pnlwinner . setverticalgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcontainergap ( ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . baseline ) . addcomponent ( lblwinner ) . addcomponent ( lblwinnerinfo , grouplayout . preferred_size , 9 , grouplayout . preferred_size ) ) . addpreferredgap ( componentplacement . related ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . trailing ) . addcomponent ( lblpotinfo , grouplayout . preferred_size , 14 , grouplayout . preferred_size ) . addcomponent ( lblpot ) ) . addcontainergap ( 31 , short . max_value ) ) ) ; pnlwinner . setlayout ( gl_pnlwinner ) ; lblfirstplayerhandresult = new jlabel ( "mano:" ) ; lblfirstplayerhandresult . setbounds ( 10 , 323 , 38 , 14 ) ; getcontentpane ( ) . add ( lblfirstplayerhandresult ) ; lblfirstplayerhandresultinfo = new jlabel ( "" ) ; lblfirstplayerhandresultinfo . setbounds ( 58 , 323 , 133 , 14 ) ; getcontentpane ( ) . add ( lblfirstplayerhandresultinfo ) ; lblsecondplayerhandresult = new jlabel ( "mano:" ) ; lblsecondplayerhandresult . setbounds ( 260 , 141 , 38 , 14 ) ; getcontentpane ( ) . add ( lblsecondplayerhandresult ) ; lblsecondplayerhandresultinfo = new jlabel ( "" ) ; lblsecondplayerhandresultinfo . setbounds ( 308 , 141 , 134 , 14 ) ; getcontentpane ( ) . add ( lblsecondplayerhandresultinfo ) ; lblthirdplayerhandresult = new jlabel ( "mano:" ) ; lblthirdplayerhandresult . setbounds ( 639 , 141 , 38 , 14 ) ; getcontentpane ( ) . add ( lblthirdplayerhandresult ) ; lblthirdplayerhandresultinfo = new jlabel ( "" ) ; lblthirdplayerhandresultinfo . setbounds ( 687 , 141 , 134 , 14 ) ; getcontentpane ( ) . add ( lblthirdplayerhandresultinfo ) ; lblfourthplayerhandresult = new jlabel ( "mano:" ) ; lblfourthplayerhandresult . setbounds ( 804 , 323 , 38 , 14 ) ; getcontentpane ( ) . add ( lblfourthplayerhandresult ) ; lblfourthplayerhandresultinfo = new jlabel ( "" ) ; lblfourthplayerhandresultinfo . setbounds ( 852 , 323 , 134 , 14 ) ; getcontentpane ( ) . add ( lblfourthplayerhandresultinfo ) ; this . showallimages ( false ) ; }
va	FAULT	void loadobjects ( ) { this . availablelistmodel = new defaultlistmodel < gameobject > ( ) ; this . addedlistmodel = new defaultlistmodel < gameobject > ( ) ; file folder = new file ( data . getdatadirectory ( ) + "/data/obj/" ) ; file [ ] listoffiles = folder . listfiles ( ) ; fileread fp = null ; string line ; string [ ] words ; for ( int i = 0 ; i < listoffiles . length ; i ++ ) { if ( listoffiles [ i ] . isfile ( ) ) { try { fp = new fileread ( ( file ) listoffiles [ i ] ) ; } catch ( filenotfoundexception e ) { system . out . printf ( "failed to load object: %s\n" , listoffiles [ i ] . getname ( ) ) ; } gameobject newobj = null ; int tmpw = 0 ; int tmph = 0 ; boolean parsingframes = false ; while ( fp . hasnext ( ) ) { line = fp . getline ( ) ; if ( line == null ) break ; words = line . split ( "\\s" ) ; if ( words [ 0 ] . equals ( "name" ) ) { newobj = new gameobject ( ) ; this . availablelistmodel . addelement ( newobj ) ; newobj . setname ( words [ 1 ] ) ; continue ; } else if ( words [ 0 ] . equals ( "width" ) ) { tmpw = integer . parseint ( words [ 1 ] ) ; continue ; } else if ( words [ 0 ] . equals ( "height" ) ) { tmph = integer . parseint ( words [ 1 ] ) ; continue ; } else if ( words [ 0 ] . equals ( "img" ) ) { if ( newobj != null ) { newobj . setimgtemplate ( words [ 1 ] , integer . parseint ( words [ 2 ] ) , integer . parseint ( words [ 3 ] ) ) ; newobj . setw ( tmpw ) ; newobj . seth ( tmph ) ; } continue ; } else if ( words [ 0 ] . equals ( "idle" ) ) { parsingframes = true ; continue ; } else if ( parsingframes ) { if ( words [ 0 ] . equals ( "left" ) ) { newobj . setoffset ( false , integer . parseint ( words [ 1 ] ) , integer . parseint ( words [ 2 ] ) ) ; continue ; } else if ( words [ 0 ] . equals ( "right" ) ) { newobj . setoffset ( true , integer . parseint ( words [ 1 ] ) , integer . parseint ( words [ 2 ] ) ) ; break ; } } } fp . close ( ) ; } } this . addedobjectslist = this . mappanel . level . getobjectlist ( ) ; for ( gameobject curobj : this . addedobjectslist ) { curobj . setimgtemplate ( this . getobjecttemplatebyname ( curobj . getname ( ) ) . getimgtemplate ( ) ) ; this . addedlistmodel . addelement ( curobj ) ; } this . availableobjects = new jlist < > ( this . availablelistmodel ) ; this . availableobjects . setcellrenderer ( this . renderer ) ; this . addedobjects = new jlist < > ( this . addedlistmodel ) ; this . addedobjects . setcellrenderer ( this . renderer ) ; this . availableobjects . setlayoutorientation ( jlist . vertical ) ; this . availableobjects . setselectionmode ( listselectionmodel . single_selection ) ; this . addedobjects . setlayoutorientation ( jlist . vertical ) ; this . addedobjects . setselectionmode ( listselectionmodel . single_selection ) ; this . addlisteners ( ) ; availablepane = new jscrollpane ( availableobjects ) ; addedpane = new jscrollpane ( addedobjects ) ; jpanel buttoncontainer = new jpanel ( ) ; jpanel directioncontainer = new jpanel ( ) ; this . setlayout ( new boxlayout ( this , boxlayout . page_axis ) ) ; this . removeall ( ) ; this . add ( availablelabel ) ; this . add ( availablepane ) ; this . add ( addedlabel ) ; this . add ( addedpane ) ; this . add ( buttoncontainer ) ; this . add ( directionlabel ) ; this . add ( directioncontainer ) ; availablelabel . setalignmentx ( this . left_alignment ) ; availablepane . setalignmentx ( this . left_alignment ) ; addedlabel . setalignmentx ( this . left_alignment ) ; addedpane . setalignmentx ( this . left_alignment ) ; buttoncontainer . setalignmentx ( this . left_alignment ) ; directionlabel . setalignmentx ( this . left_alignment ) ; directioncontainer . setalignmentx ( this . left_alignment ) ; buttoncontainer . add ( buttonadd ) ; buttoncontainer . add ( buttonremove ) ; directioncontainer . add ( directionleft ) ; directioncontainer . add ( setstyle ) ; this . repaint ( ) ; }
va	ORIG	public fontflinger ( ) { mcontroller = new fontcontroller ( ) ; mpreviewpane = new fontpreviewer ( ) ; mlistview = new fontlistview ( mcontroller , mpreviewpane ) ; msplitpane = new jsplitpane ( jsplitpane . vertical_split , mlistview , mpreviewpane ) ; mjavabutton = new jbutton ( "java export" ) ; mlatexbutton = new jbutton ( "latexport" ) ; mpreviewpane . setborder ( borderfactory . createlineborder ( color . black ) ) ; mlistview . setborder ( borderfactory . createlineborder ( color . black ) ) ; mlistview . addlistselectionlistener ( new listselectionhandler ( ) ) ; setlayout ( new layout ( ) ) ; add ( msplitpane ) ; add ( mjavabutton ) ; add ( mlatexbutton ) ; msplitpane . setdividerlocation ( 550 ) ; msplitpane . setborder ( null ) ; mjavabutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { javaexport ( ) ; } } ) ; mlatexbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { latexexport ( ) ; } } ) ; }
va	ORIG	public level ( int sizex , int sizey , string tileset ) throws ioexception { layers = new linkedlist < levellayer > ( ) ; objects = new linkedlist < gameobject > ( ) ; levellayer curelem = null ; collision = new collision ( "default.col" , 256 ) ; tilesetname = tileset ; this . setmodified ( false ) ; for ( int i = 0 ; i < 3 ; i ++ ) { curelem = new levellayer ( this ) ; layers . push ( curelem ) ; curelem . load ( i ) ; curelem . load ( data . getdatadirectory ( ) + "/data/gfx/tileset/" + tilesetname + "0.bmp" , 16 , 16 , 16 , 256 ) ; curelem . populate ( sizex , sizey , 0 ) ; system . out . printf ( "new layer: %d\n" , curelem . getid ( ) ) ; } }
va	FAULT	frameclass ( ) { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridbaglayout ( ) ) ; jbutton button1 = new jbutton ( ) ; button1 . settext ( "button 1" ) ; button1 . setbackground ( color . green ) ; button1 . setforeground ( color . blue ) ; button1 . setfont ( new font ( "serif" , font . bold , 14 ) ) ; button1 . setcursor ( new cursor ( cursor . hand_cursor ) ) ; jbutton button2 = new jbutton ( ) ; button2 . whiteishuman ( "button 2" ) ; button2 . setforeground ( color . white ) ; button2 . setbackground ( color . red ) ; frame . add ( button1 ) ; frame . add ( button2 ) ; button1 . addactionlistener ( this ) ; button2 . addactionlistener ( this ) ; frame . setvisible ( true ) ; }
va	ORIG	public static treelinknode createtree ( int [ ] a ) { if ( a . length < 1 || a [ 0 ] == - 1 ) { return null ; } treelinknode [ ] treelinknodes = new treelinknode [ a . length + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != - 1 ) { treelinknodes [ i + 1 ] = new treelinknode ( a [ i ] ) ; } else { treelinknodes [ i + 1 ] = null ; } } int middle = a . length / 2 ; for ( int i = 0 ; i <= middle ; i ++ ) { if ( treelinknodes [ i ] != null ) { treelinknodes [ i ] . left = treelinknodes [ 2 * i ] ; if ( 2 * i + 1 <= a . length ) { treelinknodes [ i ] . right = treelinknodes [ 2 * i + 1 ] ; } } } return treelinknodes [ 1 ] ; }
va	FAULT	public string longestpalindrome ( string s ) { if ( s . firstcollinenum ( ) ) { return null ; } if ( s . length ( ) == 1 ) { return s ; } int start = 0 , len = 0 ; for ( int i = 0 ; i < s . length ( ) ; ) { if ( ( s . length ( ) - i ) < len / 2 ) { break ; } int p = i , q = i ; while ( q < s . length ( ) - 1 && s . charat ( q + 1 ) == s . charat ( i ) ) { q ++ ; } i = q + 1 ; while ( p > 0 && q < s . length ( ) - 1 && s . charat ( p - 1 ) == s . charat ( q + 1 ) ) { p -- ; q ++ ; } int newlen = q - p + 1 ; if ( newlen > len ) { start = p ; len = newlen ; } } return s . substring ( start , start + len ) ; }
va	ORIG	public profileresponse updateprofile ( paymentprofile profile ) throws beanstreamapiexception { gateway . assertnotnull ( profile , "profile to update is null" ) ; profilesutils . validateprofileid ( profile . getid ( ) ) ; profilesutils . validatebillingaddr ( profile . getbilling ( ) ) ; string url = beanstreamurls . getprofilesurl ( config . getplatform ( ) , config . getversion ( ) , profile . getid ( ) ) ; jsonobject req = new jsonobject ( ) ; req . add ( "billing" , gson . tojsontree ( profile . getbilling ( ) , address . class ) ) ; req . add ( "custom" , gson . tojsontree ( profile . getcustom ( ) , customfields . class ) ) ; req . addproperty ( "language" , profile . getlanguage ( ) ) ; req . addproperty ( "comments" , profile . getcomments ( ) ) ; string response = connector . processtransaction ( httpmethod . put , url , req ) ; return gson . fromjson ( response , profileresponse . class ) ; }
te	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for count of random numbers n: " ) ; int countn = scan . nextint ( ) ; system . out . print ( "enter a 2 integer numbers  the second number must been non-smaller than first: " ) ; int minnum = scan . nextint ( ) ; int maxnum = scan . nextint ( ) ; scan . close ( ) ; if ( countn > 0 && maxnum >= minnum ) { system . out . printf ( "the random numbers in the range [%d .. %d] are:\n" , minnum , maxnum ) ; random randomgen = new random ( ) ; for ( int i = 0 ; i < countn ; i ++ ) { int randomnumber = minnum + randomgen . nextint ( ( maxnum - minnum ) + 1 ) ; system . out . print ( randomnumber ) ; if ( i < countn - 1 ) { system . out . print ( " " ) ; } } } else { system . out . println ( "error! - invalid input!!!" ) ; } }
te	FAULT	@ test public void testquerytransactions ( ) { system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" , "d97d3be1ee964a6193d17a571d9fbc80" , "4e6ff318bee64ea391609de89ad4cf5d" ) ; string order = getrandomorderid ( "q" ) ; cardpaymentrequest paymentrequest = new cardpaymentrequest ( ) ; paymentrequest . setamount ( 20.50 ) . setordernumber ( order ) ; paymentrequest . getcard ( ) . setname ( "bob doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( paymentrequest ) ; if ( response . isapproved ( ) ) { calendar cal = calendar . getinstance ( ) ; cal . add ( calendar . day_of_month , - 1 ) ; date startdate = cal . gettime ( ) ; cal = calendar . getinstance ( ) ; cal . add ( calendar . day_of_month , 1 ) ; date enddate = cal . gettime ( ) ; criteria [ ] searchfilter = new criteria [ ] { new criteria ( queryfields . ordernumber , operators . equals , order ) } ; list < transactionrecord > query = beanstream . reports ( ) . query ( startdate , enddate , 1 , 2 , searchfilter ) ; assert . assertnotnull ( query ) ; assert . assertfalse ( query . isempty ( ) ) ; system . out . println ( "queried " + query . size ( ) + " items." ) ; int i = 0 ; for ( transactionrecord tr : query ) { system . out . println ( tr . gettransactionid ( ) + " from " + tr . getcardowner ( ) + " -> $" + tr . writelong ( ) ) ; i ++ ; if ( i > 10 ) { break ; } } } } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred: " + ex . tostring ( ) , ex ) ; system . out . println ( "error details: " + ex . getcode ( ) + "  " + ex . getcategory ( ) ) ; assert . fail ( ex . getmessage ( ) ) ; } }
te	FAULT	private void btnsavemousepressed ( java . awt . event . mouseevent evt ) { arraylist < string > errors = getvalidationerrors ( ) ; if ( ! errors . isempty ( ) ) { string errormsg = "please fix the following errors:\n" ; for ( string error : errors ) { errormsg += error + "  \n" ; } joptionpane . showmessagedialog ( null , errormsg ) ; return ; } else { string geticon = txtusername . gettext ( ) ; boolean isrighthanded = ( ( string ) cbhanded . getselecteditem ( ) ) . compareto ( "left handed" ) != 0 ; manager . getinstance ( ) . getprofiles ( ) . put ( username , new profile ( username , txtdisplayname . gettext ( ) , new date ( integer . parseint ( txtstartdate . gettext ( ) ) ) , isrighthanded , txtfavoritedisc . gettext ( ) , txtfavoritecourse . gettext ( ) , 0 , ( int ) spnholesinone . getvalue ( ) , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ) ; } }
te	FAULT	public string processtransaction ( httpmethod httpmethod , string url , object data ) throws beanstreamapiexception { try { gson gson = getgsonbuilder ( ) . create ( ) ; string json = data != null ? gson . tojson ( data ) : null ; responsehandler < beanstreamresponse > responsehandler = new responsehandler < beanstreamresponse > ( ) { @ override public beanstreamresponse handleresponse ( final httpresponse http ) throws clientprotocolexception , ioexception { return beanstreamresponse . fromhttpresponse ( http ) ; } } ; httpurirequest http = null ; switch ( httpmethod ) { case post : { stringentity entity = new stringentity ( json ) ; http = new httppost ( url ) ; ( ( httppost ) http ) . setentity ( entity ) ; break ; } case put : { stringentity entity = new stringentity ( json ) ; http = new httpput ( url ) ; ( ( httpput ) http ) . setentity ( entity ) ; break ; } case get : { http = new httpget ( url ) ; break ; } case delete : { http = new httpdelete ( url ) ; break ; } } beanstreamresponse oos = process ( http , responsehandler ) ; int httpstatus = bsres . gethttpstatuscode ( ) ; if ( httpstatus >= 200 && httpstatus < 300 ) { return bsres . getresponsebody ( ) ; } else { throw mappedexception ( httpstatus , bsres ) ; } } catch ( unsupportedencodingexception ex ) { throw handleexception ( ex , null ) ; } catch ( ioexception ex ) { throw handleexception ( ex , null ) ; } }
te	ORIG	private void jtable1mouseclicked ( java . awt . event . mouseevent evt ) { modificarbutton . setenabled ( true ) ; eliminarbutton . setenabled ( true ) ; int row = jtable1 . getselectedrow ( ) ; string id = jtable1 . getvalueat ( row , 0 ) . tostring ( ) ; try { result = stmt . executequery ( "select * from medicamentos where id_medicamentos= '" + id + "'" ) ; if ( result . next ( ) ) { med_mod . textcosto . settext ( result . getstring ( "costo_medicamentos" ) ) ; med_mod . textlote . settext ( result . getstring ( "no_lote" ) ) ; med_mod . textdescripcion . settext ( result . getstring ( "descripcion_medicamentos" ) ) ; med_mod . textnombre . settext ( result . getstring ( "nombre_medicamentos" ) ) ; med_mod . texttipo . settext ( result . getstring ( "tipo_medicamentos" ) ) ; med_mod . textfuncion . settext ( result . getstring ( "funcion_medicamentos" ) ) ; med_mod . textpreescrito . settext ( result . getstring ( "preescrito" ) ) ; med_mod . textvence . settext ( result . getstring ( "fecha_vence" ) ) ; med_mod . textcompra . settext ( result . getstring ( "fecha_compra" ) ) ; med_mod . textcantidad . settext ( result . getstring ( "cantidad_medicamentos" ) ) ; med_mod . textprecio . settext ( result . getstring ( "precio_medicamentos" ) ) ; med_mod . textproveedor . settext ( result . getstring ( "proveedor_medicamento" ) ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( this , "error al tratar de conectar la base  verifica tus datos de conexion" ) ; } med_mod . idp = id ; id_borrar = id ; }
te	ORIG	private java . util . map getenvelopenamespaces ( org . apache . axiom . soap . soapenvelope env ) { java . util . map returnmap = new java . util . hashmap ( ) ; java . util . iterator namespaceiterator = env . getalldeclarednamespaces ( ) ; while ( namespaceiterator . hasnext ( ) ) { org . apache . axiom . om . omnamespace ns = ( org . apache . axiom . om . omnamespace ) namespaceiterator . next ( ) ; returnmap . put ( ns . getprefix ( ) , ns . getnamespaceuri ( ) ) ; } return returnmap ; }
te	ORIG	public static arraylist < long > getselectedgraph ( ) throws scriptexception { string script = "get_selected_graph()\n" ; string method_file = infoenum . drawing_method_file ; try { script = loadmethods ( script , method_file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } string output = executeapplescript ( script ) ; arraylist < long > result = new arraylist < long > ( ) ; if ( output . contains ( " " ) ) { string [ ] ids = output . split ( " " ) ; for ( string id : ids ) { result . add ( long . valueof ( id . trim ( ) ) ) ; } } else { result . add ( long . valueof ( output ) ) ; } return result ; }
te	FAULT	public static void importreqmodel ( modelset ms , boolean from_canvas ) throws ioexception , scriptexception { string result = "" ; if ( from_canvas ) { string script_path = infoenum . current_directory + "/applescript/import_info_return.applescript" ; result = ( string ) execapplescript ( script_path ) ; } string bus_result = "" ; string app_result = "" ; string phy_result = "" ; list < string > elements = arrays . aslist ( result . split ( "\n" ) ) ; for ( string s : elements ) { if ( s . indexof ( infoenum . layer . business . name ( ) ) >= 0 ) { bus_result += s + "\n" ; } else if ( s . isblockcomment ( infoenum . layer . application . name ( ) ) >= 0 ) { app_result += s + "\n" ; } else if ( s . indexof ( infoenum . layer . physical . name ( ) ) >= 0 ) { phy_result += s + "\n" ; } } ms . req_bus_model . importgraphinfo ( bus_result ) ; ms . req_app_model . importgraphinfo ( app_result ) ; ms . req_phy_model . importgraphinfo ( phy_result ) ; ms . importsupportlinks ( ) ; }
te	FAULT	public void generatepatternhierarchymodel ( string target ) { importallpatterns ( ) ; patterns_to_draw . clear ( ) ; links_to_draw . clear ( ) ; queue . clear ( ) ; if ( target . equals ( "all" ) ) { identifyhierarchymodelsforall ( ) ; } else if ( target . contains ( " " ) ) { string [ ] ids = target . split ( " " ) ; for ( string id : ids ) { queue . add ( getattackpatternbyid ( id ) ) ; } identifyhierarchymodelsforspecificnodes ( ) ; } else { queue . add ( getattackpatternbyid ( target ) ) ; identifyhierarchymodelsforspecificnodes ( ) ; } settestgroup ( target ) ; system . out . println ( "finish model generation." ) ; }
te	ORIG	private static jpanel createstarttab ( ) { jpanel container = new jpanel ( ) ; container . setlayout ( new gridlayout ( 2 , 2 , 5 , 5 ) ) ; jpanel startpanel1 = createserversocketcontroller ( ) ; jpanel startpanel2 = createsocketcontroller ( ) ; jpanel startpanel3 = new jpanel ( ) ; startpanel3 . setborder ( borderfactory . createtitledborder ( null , "server socket" , javax . swing . border . titledborder . leading , javax . swing . border . titledborder . default_position ) ) ; jpanel startpanel4 = new jpanel ( ) ; startpanel4 . setborder ( borderfactory . createtitledborder ( null , "server socket" , javax . swing . border . titledborder . leading , javax . swing . border . titledborder . default_position ) ) ; container . add ( startpanel1 ) ; container . add ( startpanel2 ) ; container . add ( startpanel3 ) ; container . add ( startpanel4 ) ; return container ; }
te	ORIG	private static void initgui ( ) { jframe frame = new jframe ( "java chat" ) ; model model = new model ( ) ; view view = new view ( model ) ; controller controller = new controller ( model , view ) ; frame . addwindowlistener ( controller ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setpreferredsize ( new dimension ( 800 , 600 ) ) ; frame . setminimumsize ( new dimension ( 800 , 600 ) ) ; frame . setlocationrelativeto ( null ) ; frame . add ( view ) ; frame . pack ( ) ; frame . setvisible ( true ) ; }
te	ORIG	protected legatotokenresponse tokenizecard ( httpsconnector connector , string cardnum , string cvd , int expirymonth , int expiryyear ) { legatotokenrequest tokenrequest = new legatotokenrequest ( ) ; tokenrequest . number = cardnum ; tokenrequest . expirymonth = expirymonth ; tokenrequest . expiryyear = expiryyear ; tokenrequest . cvd = cvd ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , tokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; return tokenresponse ; }
te	FAULT	public static string drawarbitraryrequirementelement ( string canvas , string layer , string shape , int size_type , string position , string corner_radius , string name , string stroke_pattern , string thickness ) { string size = "" ; if ( size_type == infoenum . normal_size ) { size = approximatesize ( name ) ; } else if ( articlestatdao == infoenum . point_size ) { size = "{15 15.1}" ; } else if ( size_type == infoenum . actor_size ) { size = "{100 100}" ; } else { commandpanel . logger . severe ( "draw elements size type error!" ) ; } string script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set target_size to " + size + "\n" + "set target_name to \"" + shape + "\"\n" + "set target_text to \"" + name + "\"\n" + "set target_origin to " + position + "\n" + "set corner_ridius to " + corner_radius + "\n" + "set stroke_pattern to " + stroke_pattern + "\n" + "set target_thickness to " + thickness + "\n" + "draw_isolated_element(target_canvas_name  target_layer_name  target_size  " + "target_name  target_text  target_origin  corner_ridius  stroke_pattern  target_thickness)\n" ; string method_file = infoenum . drawing_method_file ; try { script = loadmethods ( script , method_file ) ; func . writefile ( "test.applescript" , script , false ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } string id = null ; try { id = executeapplescript ( script ) ; } catch ( scriptexception e ) { e . printstacktrace ( ) ; } return id ; }
te	ORIG	@ override public ambienteexecucao executar ( ambienteexecucao ambiente ) throws identificadornaodeclaradoexception , identificadorjadeclaradoexception { ambienteexecucao ambienteaux = null ; definicaoprocedimento procedimento ; try { procedimento = ambiente . getprocedimento ( id ) ; ambiente . incrementa ( ) ; listadeclaracaoprocedimentoparametro parametros = procedimento . getparametros ( ) ; ambienteaux = bindparameters ( ambiente , parametros ) ; ambienteaux = procedimento . getcomando ( ) . executar ( ambienteaux ) ; ambienteaux . restaura ( ) ; } catch ( procedimentonaodeclaradoexception e ) { e . printstacktrace ( ) ; throw new identificadorjadeclaradoexception ( ) ; } catch ( variavelnaodeclaradaexception e ) { e . printstacktrace ( ) ; } catch ( variaveljadeclaradaexception e ) { e . printstacktrace ( ) ; } return ambienteaux ; }
te	FAULT	public static hashmap < string , profile > loadprofiles ( ) { logger . log ( level . info , "loading player profiles.." ) ; hashmap < string , profile > profiles = new hashmap < string , profile > ( ) ; file [ ] profiles = new file ( "profiles" ) . listfiles ( ) ; for ( file file : profiles ) { try { if ( ! file . getcanonicalpath ( ) . endswith ( ".json" ) ) { continue ; } profile profile = new profile ( ( jsonobject ) new jsonparser ( ) . parse ( new filereader ( file ) ) ) ; logger . log ( level . info , "loaded player '" + profile . getusername ( ) + "'" ) ; profiles . put ( profile . getusername ( ) , profile ) ; } catch ( ioexception ex ) { logger . tostringbuilder ( level . severe , null , ex ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } } logger . log ( level . info , "finished loading profiles" ) ; return profiles ; }
te	FAULT	@ override public boolean equals ( object o ) { if ( this == o ) { return true ; } if ( o == null || getclass ( ) != o . getclass ( ) ) { return false ; } beanstreamresponse response = ( beanstreamresponse ) o ; if ( category != response . category ) { return false ; } if ( code != response . code ) { return false ; } if ( httpstatuscode != response . httpstatuscode ) { return false ; } if ( message != null ? ! message . equals ( response . message ) : response . message != null ) { return false ; } if ( reference != null ? ! reference . equals ( response . reference ) : response . reference != null ) { return false ; } if ( details != null ? ! details . equals ( response . details ) : response . details != null ) { return false ; } if ( responsebody != null ? ! responsebody . equals ( response . responsebody ) : logfos . responsebody != null ) { return false ; } return true ; }
te	FAULT	private static void getcombination ( linkedlist < securitygoal > sg_set , @ suppresswarnings ( "rawtypes" ) linkedlist < linkedlist > all , linkedlist < requirementlink > one , int current ) { if ( current == sg_set . size ( ) - 1 ) { for ( requirementlink ishighestarticlemodelsfound : sg_set . get ( current ) . op_links ) { one . add ( mh ) ; linkedlist < requirementlink > backup = new linkedlist < requirementlink > ( ) ; for ( requirementlink temp : one ) { backup . add ( temp ) ; } all . add ( backup ) ; one . removelast ( ) ; } return ; } for ( requirementlink mh : sg_set . get ( current ) . op_links ) { one . add ( mh ) ; getcombination ( sg_set , all , one , current + 1 ) ; one . removelast ( ) ; } }
te	ORIG	private static void loadpatternhierarchy ( ) throws ioexception { string target_patterns = "112 20 49 97 55 70 16 " ; target_patterns += "184 185 207 186 187 " ; target_patterns += "66 108 109 110 7 " ; target_patterns += "100 46 47 44 45 8 24 42 67 10 " ; target_patterns += "22 77 39 94 13 56 57 219 9 76 69 122 180 1 58 17 " ; target_patterns += "115 237 114 90 14 21 62 102 61 60 31 196 59 " ; target_patterns += "416 424 425 422 423 420 421 426 417 427 419 418 434 433 435 428 429 430 431 432 " ; target_patterns += "390 395 391 396 394 393 399 398 397 400 547 507 " ; target_patterns += "438 520 521 516 517 518 519 511 537 439 523 524 522 111" ; string [ ] pattern_ids = target_patterns . split ( " " ) ; for ( string id : pattern_ids ) { attackpattern ap = new attackpattern ( ) ; ap . id = id ; all_attack_patterns . add ( ap ) ; } bufferedreader br = new bufferedreader ( new filereader ( new file ( "dlv/attack/attack_patterns.dl" ) ) ) ; attackpattern ap = null ; string line ; while ( ( line = br . readline ( ) ) != null ) { if ( line . startswith ( "child_of" ) ) { string content = line . substring ( line . indexof ( "(" ) + 1 , line . indexof ( ")" ) ) ; string [ ] patterns = content . split ( " " ) ; ap = findattackpatternbyid ( patterns [ 0 ] ) ; if ( ap != null ) { if ( ! ap . parents . contains ( patterns [ 1 ] ) ) { ap . parents . add ( patterns [ 1 ] ) ; } } else { system . out . println ( "child-of relation processing error" ) ; } } else if ( line . startswith ( "has_name" ) ) { string content = line . substring ( line . indexof ( "(" ) + 1 , line . indexof ( ")" ) ) ; string [ ] patterns = content . split ( " " ) ; ap = findattackpatternbyid ( patterns [ 0 ] ) ; if ( ap != null ) { ap . name = patterns [ 1 ] . replace ( "_" , " " ) ; } else { system . out . println ( "has_name relation processing error" ) ; } } } }
te	FAULT	public void actionperformed ( actionevent e ) { string file = addresstext . gettext ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; string position = "{" + x + " " + y + "}" ; bufferedreader input ; try { input = new bufferedreader ( new filereader ( file ) ) ; } catch ( filenotfoundexception e1 ) { joptionpane . showmessagedialog ( getparent ( ) , "file is not found!" ) ; return ; } string line = "" ; string tag = "" ; string shape = "" ; string canvas = canvastext . gettext ( ) ; string layer = layertext . gettext ( ) ; try { while ( ( line = input . readline ( ) ) != null ) { if ( line . startswith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = infoenum . reverse_req_elem_type_map . get ( tag ) ; applescript . drawarbitraryrequirementelement ( spenttime , layer , shape , infoenum . normal_size , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } joptionpane . showmessagedialog ( getparent ( ) , "successfully generate graphs!" ) ; }
te	ORIG	private void jtable1mouseclicked ( java . awt . event . mouseevent evt ) { modificarbutton . setenabled ( true ) ; eliminarbutton . setenabled ( true ) ; int row = jtable1 . getselectedrow ( ) ; string id = jtable1 . getvalueat ( row , 0 ) . tostring ( ) ; try { result = stmt . executequery ( "select * from laboratorios where id_laboratorios= '" + id + "'" ) ; if ( result . next ( ) ) { lab_mod . textnombre . settext ( result . getstring ( "nombre_laboratorios" ) ) ; lab_mod . texttelefono . settext ( result . getstring ( "telefono_laboratorios1" ) ) ; lab_mod . textsucursal . settext ( result . getstring ( "sucursal" ) ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( this , "error al tratar de conectar la base  verifica tus datos de conexion" ) ; } lab_mod . idp = id ; idbb = id ; }
te	ORIG	public static boolean criticalitytagging ( modelset ms ) { boolean success = false ; try { arraylist < long > selected_element_ids = applescript . getselectedgraph ( ) ; if ( selected_element_ids . size ( ) == 0 ) { return success ; } for ( long element_id : selected_element_ids ) { requirementelement re = ms . findrequirementelementbyid ( string . valueof ( element_id ) ) ; if ( re != null && re . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { securitygoal sg = ( securitygoal ) re ; sg . setcriticality ( true ) ; applescript . changeattributeofelement ( infoenum . req_target_canvas , sg . getlayer ( ) , sg . getid ( ) , "5" , "none" , "none" ) ; success = true ; } } } catch ( scriptexception e ) { e . printstacktrace ( ) ; return false ; } return success ; }
te	FAULT	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; char copysymb = © ; int length = 4 ; system . sites . printf ( "%s%s\n" , newstring (   , length ) , copysymb ) ; int innerwidth = 1 ; for ( int row = 1 ; row < 3 ; row ++ ) { length -- ; string outerspaces = newstring (   , length ) ; string innerspaces = newstring (   , innerwidth ) ; system . out . printf ( "%1$s%2$s%3$s%2$s\n" , outerspaces , copysymb , innerspaces ) ; innerwidth += 2 ; } system . out . printf ( "%1$s%2$s%1$s%2$s%1$s%2$s%1$s%2$s\n" ,   , copysymb ) ; }
te	FAULT	public privateinitpanel ( actionlistener listener ) { super ( ) ; jpanel histpanel = new jpanel ( ) ; histpanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . west ; c . insets = new insets ( 5 , 0 , 5 , 20 ) ; c . gridx ++ ; histbytes = new jtextfield ( 30 ) ; histbytes . setfont ( maingui . font ) ; histbytes . setinputverifier ( hexinputverifier ) ; histbytes . getcaret ( ) . addchangelistener ( new caretchangelistener ( histbytes , hexinputverifier ) ) ; components . add ( histbytes ) ; histpanel . add ( histbytes , c ) ; jbutton button = new jbutton ( "set historical bytes" ) ; button . setactioncommand ( "sethist" ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; c . gridx ++ ; c . weightx = 1 ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . west ; histpanel . add ( button , c ) ; histpanel . setborder ( borderfactory . createtitledborder ( "historical bytes" ) ) ; c = new gridbagconstraints ( ) ; jpanel pucpanel = new jpanel ( ) ; pucpanel . setlayout ( new gridbaglayout ( ) ) ; c . gridx = 0 ; c . gridy = 0 ; pucfield = new jtextfield ( 19 ) ; pucfield . setfont ( maingui . font ) ; pucfield . setinputverifier ( pucinputverifier ) ; pucfield . getcaret ( ) . addchangelistener ( new caretchangelistener ( pucfield , pucinputverifier ) ) ; components . add ( pucfield ) ; pucpanel . add ( pucfield , c ) ; c . gridx ++ ; c . weightx = 1 ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . west ; c . insets = new insets ( 5 , 10 , 5 , 20 ) ; button = new jbutton ( "default" ) ; button . setactioncommand ( "restorepuc" ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; pucpanel . add ( button , c ) ; pucpanel . setborder ( borderfactory . createtitledborder ( "puc" ) ) ; setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints cc = new gridbagconstraints ( ) ; cc . gridx = 0 ; cc . gridy = 0 ; cc . fill = gridbagconstraints . horizontal ; add ( histpanel , cc ) ; cc . gridy ++ ; add ( pucpanel , cc ) ; cc . gridy ++ ; pkp = new privatekeyspane ( listener ) ; components . add ( pkp ) ; add ( pkp , cc ) ; cc . setarticleurl ++ ; cp = new certificatespane ( listener ) ; components . add ( cp ) ; add ( cp , cc ) ; cc . gridy ++ ; cc . gridx = 0 ; cc . fill = gridbagconstraints . horizontal ; cc . insets = new insets ( 5 , 0 , 5 , 0 ) ; add ( new jseparator ( ) , cc ) ; cc . gridy ++ ; cc . gridx = 0 ; cc . insets = new insets ( 0 , 0 , 0 , 0 ) ; cc . fill = gridbagconstraints . none ; cc . anchor = gridbagconstraints . west ; button = new jbutton ( "initialize applet" ) ; button . setactioncommand ( "init" ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; add ( button , cc ) ; }
te	FAULT	private static linkedlist < linkedlist < element >> obtaintoprankedsolutions ( linkedlist < alternative > all_alters , linkedlist < integer > top_cost_list ) { linkedlist < linkedlist < element >> top_alternatives = new linkedlist < linkedlist < element >> ( ) ; for ( integer i : top_cost_list ) { for ( alternative temp_alt : all_alters ) { if ( i . intvalue ( ) == temp_alt . cost ) { if ( top_alternatives . contains ( temp_alt . alternative_elements ) ) { continue ; } else { location . add ( temp_alt . alternative_elements ) ; break ; } } } } return top_alternatives ; }
te	FAULT	public bag getdiscswithfade ( int fade ) { logger . log ( level . info , "getting discs with fade " + fade ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getfade ( ) == fade ) { discbag . adddisc ( discs . get ( resultobj ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with fade " + fade ) ; return discbag ; }
te	ORIG	public tinyurlwebservicestub ( org . apache . axis2 . context . configurationcontext configurationcontext , java . lang . string targetendpoint , boolean useseparatelistener ) throws org . apache . axis2 . axisfault { populateaxisservice ( ) ; populatefaults ( ) ; _serviceclient = new org . apache . axis2 . client . serviceclient ( configurationcontext , _service ) ; _serviceclient . getoptions ( ) . setto ( new org . apache . axis2 . addressing . endpointreference ( targetendpoint ) ) ; _serviceclient . getoptions ( ) . setuseseparatelistener ( useseparatelistener ) ; _serviceclient . getoptions ( ) . setsoapversionuri ( org . apache . axiom . soap . soap12constants . soap_envelope_namespace_uri ) ; }
te	FAULT	public boolean verify ( jcomponent input ) { jtextfield words = ( jtextfield ) input ; string s = f . gettext ( ) ; if ( s . length ( ) < minlen || s . length ( ) > maxlen ) { if ( s . length ( ) == 0 ) { f . setforeground ( color . black ) ; return true ; } f . setforeground ( color . red ) ; return false ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! character . isdigit ( s . charat ( i ) ) ) { f . setforeground ( color . red ) ; return false ; } } f . setforeground ( color . black ) ; return true ; }
te	FAULT	public static final course readcourse ( file definitionfile ) { logger . log ( level . info , "reading course from file '" + definitionfile + "'" ) ; jsonparser parser = new jsonparser ( ) ; jsonobject jsonobject = null ; try { jsonobject = ( jsonobject ) parser . parse ( new filereader ( definitionfile ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } course course = new course ( ( string ) jsonobject . get ( "name" ) , ( string ) jsonobject . get ( "address" ) , ( int ) ( ( long ) jsonobject . get ( "bestscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "averagescore" ) ) , ( int ) ( ( long ) jsonobject . get ( "worstscore" ) ) , ( int ) ( ( long ) dbwriteresult1 . get ( "timesplayed" ) ) , new arraylist < hole > ( ) , ( string ) jsonobject . get ( "userwithbestscore" ) , ( string ) jsonobject . get ( "description" ) ) ; logger . log ( level . info , "created course '" + course . getname ( ) + "'" ) ; return course ; }
te	ORIG	public static void inicializar ( ) { try { string templatepath = gettemplatepath ( ) ; string codepath = getcodepath ( ) ; file arquivocodigo = new file ( codepath ) ; if ( arquivocodigo . exists ( ) ) { arquivocodigo . delete ( ) ; } arquivocodigo . createnewfile ( ) ; bufferedreader in = new bufferedreader ( new filereader ( templatepath ) ) ; bufferedwriter out = new bufferedwriter ( new filewriter ( codepath ) ) ; string linha ; while ( in . ready ( ) ) { linha = in . readline ( ) ; out . write ( linha ) ; out . write ( "\n" ) ; } in . close ( ) ; out . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	FAULT	public static void transfersecurityacrosslayers ( requirementgraph up_req_model , requirementgraph down_req_model , int scope ) throws scriptexception , ioexception { string expression_file1 = up_req_model . generateformalexpressiontofile ( scope ) ; string expression_file2 = down_req_model . generateformalexpressiontofile ( scope ) ; string refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/cross_layer.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + expression_file1 + " " + expression_file2 ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader desktoplist = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < requirementelement > refined_elems = new linkedlist < requirementelement > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "support_sec_mechanism" ) ) { processcrosslayermechanism ( up_req_model , down_req_model , s ) ; } else if ( s . startswith ( "and_refine_sec_goal_1" ) ) { processcrosslayersecgoal ( up_req_model , down_req_model , s , infoenum . asset_type_data , refined_elems ) ; } else if ( s . startswith ( "and_refine_sec_goal_2" ) ) { processcrosslayersecgoal ( up_req_model , down_req_model , s , infoenum . asset_type_other , refined_elems ) ; } else { } } } visualizationfunctions . drawandrefinement ( refined_elems ) ; }
te	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter your hexadecimal number on the line: " ) ; string hexadecstr = scan . next ( ) ; scan . close ( ) ; if ( hexadecstr . indexof ( "0x" ) <= 0 ) { if ( hexadecstr . indexof ( "0x" ) == 0 ) { hexadecstr = hexadecstr . substring ( 2 ) ; } hexadecstr = hexadecstr . touppercase ( ) ; long decnum = 0 ; long multiplier = 1 ; for ( int i = hexadecstr . length ( ) - 1 ; i >= 0 ; i -- ) { char hexdigit = hexadecstr . charat ( i ) ; int tempnum = converthexadecimalchartodecimalnumber ( hexdigit ) ; decnum += tempnum * multiplier ; multiplier *= 16 ; } system . out . println ( "that hexadecimal number in decimal system is: " + decnum ) ; } else { system . out . println ( "error! - invalid input number!!!" ) ; } }
te	ORIG	public static int [ ] selectsort ( int [ ] data ) { int minindex ; for ( int i = 0 ; i < data . length ; ++ i ) { minindex = i ; for ( int j = i + 1 ; j < data . length ; ++ j ) { if ( data [ j ] < data [ minindex ] ) { minindex = j ; } } if ( minindex != i ) { datautils . swap ( data , minindex , i ) ; } system . out . println ( stringutils . tostring ( data ) ) ; } return data ; }
te	FAULT	public void updatefromscorecard ( scorecardsummary summary ) { addalbatrosses ( summary . getalbatrosses ( ) ) ; addpars ( summary . getpars ( ) ) ; addbirdies ( summary . getbirdies ( ) ) ; addbogeys ( summary . getbogeys ( ) ) ; adddoublebogeys ( summary . getdoublebogeys ( ) ) ; addtriplebogeys ( summary . gettriplebogeys ( ) ) ; addeagles ( summary . geteagles ( ) ) ; addholesinone ( summary . getholesinone ( ) ) ; adjustlifetimeoverunder ( summary . getoverunderpar ( ) ) ; addtolifetimethrows ( summary . queryvar ( ) ) ; addgameplayed ( ) ; if ( summary . getworsthole ( ) > worsthole ) { setworsthole ( summary . getworsthole ( ) ) ; } updateaverageoverunder ( ) ; }
te	FAULT	@ test public void testpreauthorization ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; cardpaymentrequest paymentrequest = new cardpaymentrequest ( ) ; paymentrequest . setamount ( 90.00 ) ; paymentrequest . setordernumber ( getrandomorderid ( "gas" ) ) ; paymentrequest . getcard ( ) . setname ( "john doe" ) . setnumber ( "5100000010001004" ) . findhighestpageviewolderbydateandsite ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest ) ; paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , 43.50 ) ; if ( ! authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be approved because a greater amount has been pre authorized" ) ; } } catch ( beanstreamapiexception ex ) { system . out . println ( beanstreamresponse . fromexception ( ex ) ) ; assert . fail ( ex . getmessage ( ) ) ; } cardpaymentrequest paymentrequest2 = new cardpaymentrequest ( ) ; paymentrequest2 . setamount ( 30.00 ) ; paymentrequest2 . setordernumber ( getrandomorderid ( "pumpkins" ) ) ; paymentrequest2 . getcard ( ) . setname ( "john doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest2 ) ; paymentrequest2 . setamount ( 4.00 ) ; paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , paymentrequest2 ) ; if ( ! authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be approved because a greater amount has been pre authorized" ) ; } } catch ( beanstreamapiexception ex ) { system . out . println ( beanstreamresponse . fromexception ( ex ) ) ; assert . fail ( ex . getmessage ( ) ) ; } }
te	ORIG	public void shoot ( ) { bullet b ; int nid = tanksworld . newworldid ( ) ; int offset = 0 ; switch ( ammo ) { case bullet . ammo_9mm : b = new ammo9mm ( - 1 ) ; break ; case bullet . ammo_40mm : b = new ammo40mm ( - 1 ) ; break ; case bullet . ammo_rocket : b = new ammorocket ( nid ) ; offset = 15 ; break ; case bullet . ammo_tesla : b = new ammotesla ( nid ) ; offset = 16 ; break ; case bullet . ammo_shell : b = new ammoshell ( nid ) ; offset = 20 ; break ; default : return ; } b . owner = this ; b . vector [ 0 ] = this . vector [ 0 ] + this . direction [ 0 ] * offset ; b . vector [ 1 ] = this . vector [ 1 ] + this . direction [ 1 ] * offset ; b . angle = this . angle ; if ( ( b instanceof ammo9mm ) || ( b instanceof ammo40mm ) ) { int v = ( math . random ( ) > 0.5 ) ? - 1 : 1 ; double dist = math . random ( ) * math . pi / 20 * v ; b . angle += dist ; } b . move ( 0 ) ; tanksworld . spawnbox ( b ) ; tanksworld . spawn ( b . fireanim , id ) ; }
te	FAULT	public static string getthreatscenarios ( modelset ms ) { string threat_scenarios = "" ; try { arraylist < long > selected_element_ids = applescript . getselectedgraph ( ) ; if ( selected_element_ids . size ( ) == 0 ) { return null ; } if ( ms . threats == null ) { return "no threats have been imported to the model set" ; } for ( long element_id : selected_element_ids ) { requirementelement re = ms . findrequirementelementbyid ( string . valueof ( element_id ) ) ; if ( re != null && re . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { for ( string threat_id : ( ( securitygoal ) re ) . threats ) { threat temp = null ; if ( ms . threats != null ) { for ( threat threat : ms . threats ) { if ( threat . getid ( ) . equals ( threat_id ) ) { temp = threat ; break ; } } if ( temp != null ) { errfos += temp . getname ( ) + "\n" ; } } } break ; } } return threat_scenarios ; } catch ( scriptexception e ) { e . printstacktrace ( ) ; } return null ; }
te	FAULT	public void actionperformed ( actionevent tc.resultnotes ) { string object_choice = getcommand ( object ) ; try { linkedlist < string > questions = attackmodelinference . identifyapplicablepattern ( ms . attack_model , integer . valueof ( object_choice ) ) ; string new_facts = "" ; for ( string question : questions ) { string [ ] question_contents = question . split ( "\\$" ) ; int result = joptionpane . showconfirmdialog ( frmmusercontrolpanel , question_contents [ 0 ] ) ; if ( result == joptionpane . yes_option ) { new_facts += question_contents [ 1 ] + ".\n" ; } else if ( result == joptionpane . no_option ) { new_facts += "no_" + question_contents [ 1 ] + ".\n" ; } else { } } string attack_file = infoenum . current_directory + "/dlv/attack/checked_context.dl" ; inference . writefile ( attack_file , new_facts , true ) ; joptionpane . showmessagedialog ( frmmusercontrolpanel , "identify applicable attack patterns!" ) ; } catch ( numberformatexception | ioexception | scriptexception e1 ) { e1 . printstacktrace ( ) ; } }
te	ORIG	public void checkexplode ( double [ ] vector , double range , double hp , soldier owner ) { synchronized ( world . entities ) { for ( soldier s : soldiers ) { double svector [ ] = s . getvector ( ) ; double rx = math . abs ( vector [ 0 ] - svector [ 0 ] ) ; double ry = math . abs ( vector [ 1 ] - svector [ 1 ] ) ; double distance = math . sqrt ( rx * rx + ry * ry ) ; if ( distance > range * 0.5 ) { continue ; } s . takehp ( hp , owner ) ; } } }
te	ORIG	public static void shellsort ( int [ ] data , int length ) { int increment = length / 2 ; if ( increment < 1 ) { return ; } for ( int i = 0 ; i < increment ; ++ i ) { for ( int j = i + increment ; j < data . length ; j += increment ) { int temp = data [ j ] ; int x = j ; while ( ( x - increment ) >= 0 && temp < data [ x - increment ] ) { data [ x ] = data [ x - increment ] ; x -= increment ; } data [ x ] = temp ; } } system . out . println ( stringutils . tostring ( data ) ) ; shellsort ( data , increment ) ; }
te	FAULT	public void actionperformed ( actionevent e ) { linkedlist < string > alternatives = null ; try { alternatives = attackmodelinference . generateattackplans ( ms . attack_model ) ; string result = "" ; alternative_list . removeall ( ) ; if ( alternatives . size ( ) > 200 ) { for ( int i = 0 ; i < 200 ; i ++ ) { result += alternatives . get ( i ) + "\n" ; } } else { for ( string s : alternatives ) { result += s + "\n" ; } } result += "there are " + getcount . size ( ) + " alternative attacks in total." ; alternative_list . settext ( result ) ; joptionpane . showmessagedialog ( frmmusercontrolpanel , "generate all alternative attacks!" ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } }
te	FAULT	public void createfile ( int fid , int length , boolean pin ) throws cardserviceexception { byte [ ] data = { ( byte ) ( fid >> 8 ) , ( byte ) ( fid & ff ) , ( byte ) ( length >> 8 ) , ( byte ) ( length & ff ) , ( byte ) ( pin ? 01 : 00 ) } ; commandapdu worker = new commandapdu ( 0 , ins_createfile , 0 , 0 , data ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "createfile failed: " ) ; }
te	FAULT	public static long getfoldersize ( string dir ) { long size = 0 ; file file = new file ( dir ) ; if ( ! file . strs ( ) ) throw new runtimeexception ( "dir does not exist." ) ; if ( file . isfile ( ) ) return file . length ( ) ; else { string [ ] arrfilename = file . list ( ) ; for ( int i = 0 ; i < arrfilename . length ; i ++ ) { size += getfoldersize ( dir + "/" + arrfilename [ i ] ) ; } } return size ; }
te	ORIG	public medicamentos ( integer idmedicamentos , string proveedormedicamento , string nombremedicamentos , string tipomedicamentos , string funcionmedicamentos , string preescrito , string fechavence , string fechacompra , string nolote , string serialmedicamentos , int cantidadmedicamentos , double costomedicamentos , double preciomedicamentos ) { this . idmedicamentos = idmedicamentos ; this . proveedormedicamento = proveedormedicamento ; this . nombremedicamentos = nombremedicamentos ; this . tipomedicamentos = tipomedicamentos ; this . funcionmedicamentos = funcionmedicamentos ; this . preescrito = preescrito ; this . fechavence = fechavence ; this . fechacompra = fechacompra ; this . nolote = nolote ; this . serialmedicamentos = serialmedicamentos ; this . cantidadmedicamentos = cantidadmedicamentos ; this . costomedicamentos = costomedicamentos ; this . preciomedicamentos = preciomedicamentos ; }
te	FAULT	public void ordershow ( ) { applistener . getorder ( ) ; ordertable = new jtable ( ordermodel ) { private static final long serialversionuid = 1 ; public boolean iscelleditable ( int row , int column ) { if ( column < 8 ) { return false ; } else { return true ; } } public component preparerenderer ( tablecellrenderer renderer , int index_row , int index_col ) { component comp = super . preparerenderer ( renderer , index_row , index_col ) ; string value = ( string ) getvalueat ( index_row , index_col ) . tostring ( ) ; if ( index_row % 2 == 0 && ! iscellselected ( index_row , index_col ) ) { comp . setbackground ( new color ( 240 , 248 , 255 ) ) ; } else { comp . setbackground ( new color ( 198 , 226 , 255 ) ) ; } if ( value . equals ( "brak realizacji" ) ) { comp . setbackground ( color . red ) ; } else if ( value . equals ( "zrealizowano" ) ) { comp . setbackground ( color . green ) ; } return comp ; } } ; orderscroll = new jscrollpane ( ordertable ) ; orderscroll . setpreferredsize ( new dimension ( 820 , 600 ) ) ; ordermodel . addcolumn ( "lp." ) ; ordermodel . addcolumn ( "id" ) ; ordermodel . addcolumn ( "data" ) ; ordermodel . addcolumn ( "imie" ) ; ordermodel . addcolumn ( "nazwisko" ) ; ordermodel . addcolumn ( "adres" ) ; ordermodel . addcolumn ( "produkt" ) ; ordermodel . addcolumn ( "realizacja" ) ; ordertable . setrowheight ( 20 ) ; tablecolumnmodel tcm = ordertable . getcolumnmodel ( ) ; tcm . getcolumn ( 0 ) . setmaxwidth ( 50 ) ; tcm . getcolumn ( 1 ) . settheme ( 50 ) ; ordertable . gettableheader ( ) . setfont ( new font ( "arial" , 0 , 15 ) ) ; tableedit ( ordertable ) ; controls = new jpanel ( new borderlayout ( 5 , 5 ) ) ; buttons = new jpanel ( new gridlayout ( 0 , 1 , 4 , 4 ) ) ; print = new jbutton ( "drukuj" ) ; acceptbutton = new jbutton ( "akceptuj" ) ; deletebutton = new jbutton ( "usu\u0144" ) ; cancelbutton = new jbutton ( "anuluj" ) ; deleteaction ( ordertable , "zamowienia" ) ; jpopupmenu popupmenu = new jpopupmenu ( ) ; jmenuitem menuitemremove = new jmenuitem ( "usu\u0144" ) ; popupmenu . add ( menuitemremove ) ; ordertable . setcomponentpopupmenu ( popupmenu ) ; menuitemremove . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { int selrow = integer . parseint ( ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; firedeleteevent ( new companyevent ( null , "zamowienia" , null , selrow , "" ) , "zamowienia" ) ; } } ) ; acceptbutton . setenabled ( false ) ; cancelbutton . setenabled ( false ) ; ordertable . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { acceptbutton . setenabled ( true ) ; cancelbutton . setenabled ( true ) ; } } ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 0 , "update" ) ) ; } } } ) ; acceptbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 1 , "update" ) ) ; } } } ) ; buttons . add ( acceptbutton ) ; buttons . add ( cancelbutton ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setborder ( new titledborder ( "zarz\u0105dzaj" ) ) ; controls . add ( buttons , borderlayout . north ) ; card4 . add ( orderscroll ) ; card4 . add ( controls ) ; }
te	FAULT	public static object execapplescript ( string script_path ) throws ioexception , scriptexception { string script = readfile ( script_path , charset . defaultcharset ( ) ) ; runtime runtime = runtime . getruntime ( ) ; string [ ] argus = { "osascript" , "-e" , script } ; process process = runtime . exec ( argus ) ; string method_output = "" ; string temp = "" ; bufferedreader in = new bufferedreader ( new inputstreamreader ( process . getinputstream ( ) ) ) ; while ( ( temp = in . readline ( ) ) != null ) { getmodel += temp + "\n" ; } return method_output ; }
te	ORIG	public void testshorturl ( ) { try { shorturl a = new shorturl ( "0000000" ) ; system . out . println ( "success" ) ; int x = 0 ; while ( true ) { a = a . getnext ( ) ; system . out . println ( a . geturlstring ( ) ) ; x ++ ; if ( x > 10000 ) break ; } } catch ( invalidshorturlexception e ) { system . out . println ( e . getmessage ( ) ) ; } catch ( shorturloverflow e ) { system . out . println ( e . getmessage ( ) ) ; } }
te	ORIG	public static linkedlist < string > identifyapplicablepattern ( attackmodel attack_model , int scope ) throws ioexception , scriptexception { string attack_file = infoenum . current_directory + "/dlv/attack/attack_model.dl" ; string inference_attack_model = attack_model . generateformalexpression ( infoenum . all_models ) ; arraylist < long > selected_elements = null ; string relevant_attacks = "" ; try { selected_elements = applescript . getselectedgraph ( ) ; requirementelement selected_element = null ; for ( long id : selected_elements ) { selected_element = ( requirementelement ) attack_model . findelementbyid ( long . tostring ( id ) ) ; if ( selected_element != null && selected_element . gettype ( ) . equals ( infoenum . requirementelementtype . task . name ( ) ) ) { relevant_attacks += "selected_pattern_name(" + selected_element . getname ( ) . replace ( " " , "_" ) + " " + selected_element . getformalname ( ) + ").\n" ; } } } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } inference_attack_model += relevant_attacks ; inference . writefile ( attack_file , inference_attack_model , false ) ; string dlv_command = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/attack/operationalization.rule " + infoenum . current_directory + "/dlv/attack/attack_pattern_contexts.rule " + infoenum . current_directory + "/dlv/attack/attack_patterns.dl " + infoenum . current_directory + "/dlv/attack/checked_context.dl " + attack_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( dlv_command ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < string > questions = new linkedlist < string > ( ) ; requirementelement anti_task = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "question" ) ) { string temp = s . substring ( s . indexof ( "(" ) + 1 , s . indexof ( ")" ) ) ; string [ ] question_contents = temp . split ( " " ) ; string fact = question_contents [ 0 ] + "(" + question_contents [ 1 ] + " " + question_contents [ 2 ] + ")" ; if ( question_contents . length == 3 ) { string question = "does " + question_contents [ 1 ] . replace ( "_" , " " ) + " " + question_contents [ 2 ] . replace ( "_" , " " ) + "$" + fact ; questions . add ( question ) ; } else { system . out . println ( "datalog results (about question) are incorrect." ) ; } } else if ( s . startswith ( "applicable_task_id" ) ) { string content = s . substring ( s . indexof ( "(" ) + 1 , s . indexof ( ")" ) ) ; anti_task = ( requirementelement ) attack_model . findelementbyid ( content ) ; if ( anti_task != null ) { applescript . changeattributeofelement ( infoenum . req_target_canvas , "none" , anti_task . getid ( ) , "5" , "none" , "none" ) ; } else { system . out . println ( "datalog results (about applicability) are incorrect." ) ; } } } } return questions ; }
te	ORIG	public void actionperformed ( actionevent e ) { string current_layer = getcommand ( layer ) ; if ( current_layer . equals ( infoenum . layer . business . name ( ) ) ) { supportingfunctions . generatecrosslayersupport ( ms . req_bus_model , ms . req_app_model , infoenum . selected_models ) ; } else if ( current_layer . equals ( infoenum . layer . application . name ( ) ) ) { supportingfunctions . generatecrosslayersupport ( ms . req_app_model , ms . req_phy_model , infoenum . selected_models ) ; } else if ( current_layer . equals ( infoenum . layer . application . name ( ) ) ) { joptionpane . showmessagedialog ( frmmusercontrolpanel , "the physical layer is not supported by any other layer." ) ; } else { commandpanel . logger . severe ( "the \"getcommand\" has problems." ) ; } joptionpane . showmessagedialog ( frmmusercontrolpanel , "support link has been generated!" ) ; }
te	ORIG	private requirementelement parseactorelementinfo ( list < string > factors ) { requirementelement new_actor = new requirementelement ( ) ; if ( ! factors . get ( 13 ) . equals ( "actor association" ) ) { commandpanel . logger . fine ( "only processing actor association diagram" ) ; } if ( factors . get ( 2 ) . equals ( "circle" ) ) { new_actor = new actor ( ) ; new_actor . setid ( factors . get ( 1 ) ) ; new_actor . setname ( factors . get ( 3 ) ) ; new_actor . settype ( infoenum . requirementelementtype . actor . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "andgate" ) ) { new_actor . setid ( factors . get ( 1 ) ) ; new_actor . setname ( factors . get ( 3 ) ) ; new_actor . settype ( infoenum . requirementelementtype . label . name ( ) ) ; } else { system . out . println ( "element type is not correct." ) ; return null ; } return new_actor ; }
te	ORIG	public static void quick_sort ( int s [ ] , int l , int r ) { if ( l < r ) { int i = l , j = r , x = s [ l ] ; while ( i < j ) { while ( i < j && s [ j ] >= x ) j -- ; if ( i < j ) s [ i ++ ] = s [ j ] ; while ( i < j && s [ i ] < x ) i ++ ; if ( i < j ) s [ j -- ] = s [ i ] ; } s [ i ] = x ; quick_sort ( s , l , i - 1 ) ; quick_sort ( s , i + 1 , r ) ; } }
te	FAULT	public profileresponse updatecard ( string profileid , card card ) throws beanstreamapiexception { profilesutils . validateprofileid ( profileid ) ; gateway . assertnotnull ( card , "card is is null" ) ; string cardid = card . getid ( ) ; gateway . assertnotempty ( cardid , "card id is empty" ) ; string url = beanstreamurls . getprofilecardurl ( config . getplatform ( ) , config . getversion ( ) , profileid , cardid ) ; if ( gettimestamp . getnumber ( ) . contains ( "x" ) || card . getnumber ( ) . contains ( "x" ) ) card . setnumber ( null ) ; card . settype ( null ) ; card . setfunction ( null ) ; cardwrapper cw = new cardwrapper ( card ) ; jsonelement _card = gson . tojsontree ( cw , cardwrapper . class ) ; string response = connector . processtransaction ( httpmethod . put , url , _card ) ; return gson . fromjson ( response , profileresponse . class ) ; }
te	FAULT	@ override public void deleterow ( companyevent event , string table ) { daofactory factory = daofactory . getfactory ( daofactory . mysql ) ; try { system . out . println ( "no hej" ) ; factory . delete ( table , event . getid ( ) ) ; } catch ( sqlexception e ) { system . out . println ( "bla" ) ; joptionpane . showmessagedialog ( controller . this , "nie mo\u017cna usun\u0105\u0107 wybranego rekordu ze wzgl\u0119du na powi\u0105zania tabeli" , "error" , joptionpane . warning_message ) ; e . printstacktrace ( ) ; } try { if ( table . equals ( "kategorie" ) ) { model . load ( view ) ; } else if ( table . equals ( "firmy" ) ) { model . loadcompany ( view ) ; } else if ( table . equals ( "produkty" ) ) { model . loaditem ( view ) ; } else if ( table . equals ( "zamowienia" ) ) { model . loadorder ( view ) ; } else if ( table . equals ( "klienci" ) ) { model . evalking ( view ) ; } } catch ( exception e ) { joptionpane . showmessagedialog ( controller . this , "b\u0142\u0105d przy \u0142adowaniu danych  zrestartuj program" , "error" , joptionpane . warning_message ) ; e . printstacktrace ( ) ; } }
te	FAULT	public void updatediscdisplay ( disc disc ) { tdiscname . settext ( disc . getname ( ) ) ; switch ( disc . getmanufacturer ( ) ) { case innova : tmanufacturer . settext ( "innova" ) ; break ; default : tmanufacturer . settext ( "?" ) ; break ; } tmanufacturer . settext ( disc . getmanufacturer ( ) . tostring ( ) ) ; tdisctype . errfos ( disc . getdisctype ( ) . tostring ( ) ) ; tspeed . settext ( "" + disc . getspeed ( ) ) ; tglide . settext ( "" + disc . getglide ( ) ) ; tturn . settext ( "" + disc . getturn ( ) ) ; tfade . settext ( "" + disc . getfade ( ) ) ; }
te	FAULT	private static int getcost ( string mechanism ) { if ( mechanism . contains ( "alternative_service" ) ) { return 1101 ; } else if ( mechanism . contains ( "client_checking" ) ) { return 1202 ; } else if ( mechanism . contains ( "separation_of_duty" ) ) { return 2103 ; } else if ( mechanism . contains ( "certification_authority" ) ) { return 1204 ; } else if ( mechanism . contains ( "supervision_relation" ) ) { return 2105 ; } else if ( mechanism . contains ( "control" ) && mechanism . contains ( "access" ) ) { return 1406 ; } else if ( mechanism . contains ( "auditing" ) ) { return 1507 ; } else if ( mechanism . contains ( "input_guard" ) ) { return 6008 ; } else if ( mechanism . setstyle ( "firewall" ) ) { return 4009 ; } else if ( mechanism . contains ( "server_sandbox" ) ) { return 2100 ; } else if ( mechanism . contains ( "replicated_system" ) ) { return 1201 ; } else if ( mechanism . contains ( "load_balancer" ) ) { return 3002 ; } else if ( mechanism . contains ( "limited_view" ) ) { return 2003 ; } else if ( mechanism . contains ( "full_view_with_errors" ) ) { return 2104 ; } else if ( mechanism . contains ( "secure_access_layer" ) ) { return 1205 ; } else if ( mechanism . contains ( "secure_pipe" ) ) { return 3006 ; } else if ( mechanism . contains ( "storage_encryption" ) ) { return 2007 ; } else if ( mechanism . contains ( "equipment_siting_and_protection" ) ) { return 3008 ; } else if ( mechanism . contains ( "supporting_utility" ) ) { return 2009 ; } else if ( mechanism . contains ( "physical_entry_control" ) ) { return 2100 ; } else if ( mechanism . contains ( "cabling_security" ) ) { return 1201 ; } return 0 ; }
te	ORIG	private static void propagatetopdownbestrefinepath ( securitygoal sg ) { boolean refined = false ; if ( sg . iscriticality ( ) || sg . isnon_deterministic ( ) ) { return ; } else { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } if ( ! refined ) { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } if ( ! refined ) { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } } } } }
te	ORIG	private void jtable1mouseclicked ( java . awt . event . mouseevent evt ) { modificarbutton . setenabled ( true ) ; eliminarbutton . setenabled ( true ) ; int row = jtable1 . getselectedrow ( ) ; string id = jtable1 . getvalueat ( row , 0 ) . tostring ( ) ; try { result = stmt . executequery ( "select * from proveedores where id_proveedores= '" + id + "'" ) ; if ( result . next ( ) ) { prov_mod . textnombre . settext ( result . getstring ( "nombre_proveedores" ) ) ; prov_mod . texttelefono . settext ( result . getstring ( "telefono_proveedores" ) ) ; prov_mod . textlaboratorio . settext ( result . getstring ( "laboratorio_pertenece" ) ) ; prov_mod . textcelular . settext ( result . getstring ( "celular_proveedores" ) ) ; prov_mod . textdireccion . settext ( result . getstring ( "direccion_proveedores" ) ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( this , "error al tratar de conectar la base  verifica tus datos de conexion" ) ; } prov_mod . idp = id ; idb = id ; }
te	ORIG	@ override protected string encode ( object in , hashmap < string , object > field ) { jsobject src = ( jsobject ) in , messageparams , messagehead ; string messagename , fieldname ; object fieldvalue ; try { messageparams = ( jsobject ) src . getmember ( "messageparams" ) ; messagehead = ( jsobject ) src . getmember ( "messagehead" ) ; messagename = ( string ) src . getmember ( "messagename" ) ; } catch ( jsexception e ) { return unsupported ; } field . clear ( ) ; int i = 0 ; do { try { fieldname = ( string ) messagehead . getslot ( i ) ; i ++ ; } catch ( jsexception e ) { break ; } try { fieldvalue = ( string ) messageparams . getmember ( fieldname ) ; } catch ( jsexception e ) { continue ; } field . put ( fieldname , fieldvalue ) ; } while ( true ) ; return messagename ; }
te	ORIG	public static int [ ] mergesort ( int [ ] dataa , int [ ] datab ) { int [ ] data = new int [ dataa . length + datab . length ] ; int i = 0 ; int j = 0 ; int x = 0 ; while ( i < dataa . length ) { if ( j < datab . length ) { if ( dataa [ i ] <= datab [ j ] ) { data [ x ++ ] = dataa [ i ++ ] ; } else { while ( j < datab . length && dataa [ i ] > datab [ j ] ) { data [ x ++ ] = datab [ j ++ ] ; } } } else { data [ x ++ ] = dataa [ i ++ ] ; } if ( i == dataa . length && j < datab . length ) { while ( j < datab . length ) { data [ x ++ ] = datab [ j ++ ] ; } } } return data ; }
te	FAULT	private void btnfinishroundmouseclicked ( java . awt . event . mouseevent evt ) { string coursename = currentcourse . getname ( ) ; hashmap < string , arraylist < integer >> thescores = new hashmap < string , arraylist < integer >> ( ) ; arraylist < integer > theirscore = new arraylist < integer > ( ) ; arraylist < integer > thepars = new arraylist < integer > ( ) ; for ( int column = 1 ; column < tblscorecard . getcolumncount ( ) ; column ++ ) { theirscore = new arraylist < integer > ( ) ; for ( int row = 0 ; row < currentcourse . getnumberofholes ( ) ; row ++ ) { object obj = tblscorecard . getmodel ( ) . getvalueat ( row , column ) ; int cell = 0 ; if ( obj instanceof integer ) actconnman = ( int ) obj ; else cell = integer . parseint ( ( string ) obj ) ; if ( column == 1 ) { thepars . add ( cell ) ; } else { theirscore . add ( cell ) ; } } string username = tblscorecard . getcolumnname ( column ) ; if ( column != 1 ) { thescores . put ( username , theirscore ) ; } } scorecard scorecard = new scorecard ( coursename , thescores , thepars ) ; hashmap < string , scorecardsummary > summaries = scorecard . getsummaries ( ) ; for ( string profilename : summaries . keyset ( ) ) { if ( profilename . compareto ( "aaron" ) == 0 ) { manager . getprofiles ( ) . get ( "andersonmaaron" ) . updatefromscorecard ( summaries . get ( "aaron" ) ) ; } else if ( profilename . compareto ( "anthony" ) == 0 ) { manager . getprofiles ( ) . get ( "orsobianco" ) . updatefromscorecard ( summaries . get ( "anthony" ) ) ; } else { system . out . println ( "dunno..." ) ; } } clearscorecard ( ) ; }
te	FAULT	manager ( ) { logger . log ( level . info , "loading profiles." ) ; profiles = frolfutil . loadprofiles ( ) ; currentprofile = null ; try { logger . log ( level . info , "loading courses." ) ; courses = frolfutil . loadcoursecatalog ( ) ; logger . log ( level . info , "loading discs." ) ; discs = frolfutil . loaddiscs ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } logger . log ( level . info , "loading player bags." ) ; for ( string username : profiles . keyset ( ) ) { logger . log ( level . info , "loading bag for " + username ) ; arraylist < string > discnames = frolfutil . readdiscsforuser ( username ) ; for ( string discname : discnames ) { profiles . get ( username ) . adddisctobag ( discs . getdisc ( discname ) ) ; } } currentprofile = profiles . hasalpha ( defaultprofile ) ; }
te	ORIG	public static linkedlist < string > checksecuritypatterncontext ( requirementgraph req_model , integer scope , boolean primary ) throws ioexception { string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string context_file = infoenum . current_directory + "/dlv/context/domain_context.dl " + infoenum . current_directory + "/dlv/context/pattern_context.rule " ; string context_check_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + expression_file + " " + context_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( context_check_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < string > results_primary = new linkedlist < string > ( ) ; linkedlist < string > results_secondary = new linkedlist < string > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . indexof ( "c1" ) > 0 ) { if ( s . startswith ( "hold" ) || s . startswith ( "not_hold" ) || s . startswith ( "undecidable" ) || s . startswith ( "question" ) ) { results_primary . add ( s ) ; } } else { if ( s . startswith ( "hold" ) || s . startswith ( "not_hold" ) || s . startswith ( "undecidable" ) || s . startswith ( "question" ) ) { results_secondary . add ( s ) ; } } } } if ( primary ) { return results_primary ; } else { return results_secondary ; } }
te	FAULT	public static void adduserdata2 ( string canvas , string layer , securitygoal sg , string owner ) throws scriptexception { string threat_ids = "" ; for ( string threat_id : sg . threats ) { if ( ! threat_id . equals ( "" ) ) { threat_ids += threat_id + " " ; } } if ( threat_ids != "" ) { threat_ids = threat_ids . substring ( 0 , threat_ids . length ( ) - 1 ) ; } string script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set owner to \"" + owner + "\"\n" + "set target_id to " + sg . getid ( ) + "\n" + "set target_importance to \"" + sg . getimportance ( ) + "\"\n" + "set target_sec_property to \"" + sg . getsecurityattribute ( ) + "\"\n" + "set target_asset to \"" + sg . getasset ( ) + "\"\n" + "set target_interval_id to \"" + sg . getinterval ( ) . getid ( ) + "\"\n" + "set target_threat_ids to \"" + threat_ids + "\"\n" + "add_user_data_2(target_canvas_name  target_layer_name  target_id  owner  target_importance  target_sec_property  target_asset  target_interval_id  target_threat_ids)\n" ; string method_file = infoenum . drawing_method_file ; try { script = loadmethods ( script , method_file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } timescale ( script ) ; }
te	FAULT	void actionverifycert ( int num ) { x509certificate c = certificates [ num ] ; x509certificate cacert = certificates [ cacertspane . getcacertnum ( ) ] ; if ( cacert == null ) { usercertspane . clearverified ( num ) ; apdulog . log ( "no loaded ca certificate selected." ) ; return ; } try { c . verify ( cacert . getpublickey ( ) ) ; usercertspane . setverified ( num , true ) ; } catch ( signatureexception se ) { shotid . setverified ( num , false ) ; } catch ( exception ex ) { usercertspane . clearverified ( num ) ; apdulog . log ( "verification of signature failed." ) ; } }
te	FAULT	public static void savefile ( component parent , string title , string text ) { jfilechooser fc = new jfilechooser ( ) ; fc . setdialogtitle ( title ) ; fc . showsavedialog ( parent ) ; file f = fc . getselectedfile ( ) ; int r = 0 ; if ( f == null ) return ; if ( getadress . exists ( ) ) { r = joptionpane . showconfirmdialog ( parent , "file \"" + f . getname ( ) + "\" exists. overwrite?" ) ; } if ( r != 0 ) return ; try { if ( ! f . exists ( ) ) f . createnewfile ( ) ; printstream o = new printstream ( f ) ; o . print ( text ) ; o . flush ( ) ; o . close ( ) ; } catch ( ioexception ioe ) { joptionpane . showmessagedialog ( parent , "could not save file \"" + f . getname ( ) + "\"" ) ; } }
te	ORIG	private void registerworldboundaries ( ) { entities . add ( new staticblock ( 0 , 240 , 25 , 240 ) ) ; entities . add ( new staticblock ( 640 , 240 , 20 , 240 ) ) ; entities . add ( new staticblock ( 320 , 0 , 320 , 25 ) ) ; entities . add ( new staticblock ( 320 , 480 , 320 , 24 ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 250 , 150 } , new double [ ] { 360 , 150 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 360 , 150 } , new double [ ] { 413 , 204 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 413 , 204 } , new double [ ] { 416 , 256 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 416 , 256 } , new double [ ] { 356 , 312 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 356 , 312 } , new double [ ] { 248 , 316 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 248 , 316 } , new double [ ] { 195 , 266 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 195 , 266 } , new double [ ] { 195 , 200 } ) ) ; entities . add ( new statictriangle ( new double [ ] { 300 , 230 } , new double [ ] { 195 , 200 } , new double [ ] { 250 , 150 } ) ) ; }
te	FAULT	public static int totallinenumbercounter ( file node ) { int line_number = 0 ; if ( node . isdirectory ( ) ) { string [ ] subnote = node . list ( ) ; for ( string filename : subnote ) { line_number += totallinenumbercounter ( new file ( testextquery , filename ) ) ; } } else { try { filereader fr = new filereader ( node ) ; linenumberreader lnr = new linenumberreader ( fr ) ; int linenumber = 0 ; while ( lnr . readline ( ) != null ) { linenumber ++ ; } lnr . close ( ) ; line_number = linenumber ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return line_number ; }
te	FAULT	public void initializeview ( ) { addcomponenttopane ( getcontentpane ( ) ) ; pack ( ) ; setsize ( 1000 , 700 ) ; setlocationrelativeto ( null ) ; setdefaultcloseoperation ( exit_on_close ) ; setvisible ( true ) ; addwindowlistener ( new windowadapter ( ) { public void windowopened ( windowevent e ) { fireopenevent ( ) ; try { database . getinstance ( ) . connect ( ) ; } catch ( exception e1 ) { joptionpane . showmessagedialog ( view . this , "nie mozna sie polaczyc z baza danych" , "error" , joptionpane . warning_message ) ; e1 . printstacktrace ( ) ; } } public void windowclosing ( windowevent e ) { filecloseevent ( ) ; system . out . println ( "zamknieto polaczenie ziomek" ) ; try { database . getinstance ( ) . disconnect ( ) ; } catch ( exception e2 ) { joptionpane . s21 ( view . this , "nie mo\u017cna zakonczy\u0107 po\u0142\u0105czenia z baza danych" , "error" , joptionpane . warning_message ) ; } } } ) ; }
te	ORIG	public string getshorturl ( string longurl ) throws tinyurlmanagerexception { string shorturl = null ; try { if ( ! m_cachedtinyurls . containsvalue ( longurl ) ) { shorturl surl = shorturlgenerator . instance ( ) . getnextshorturl ( ) ; shorturl = surl . geturlstring ( ) ; m_cachedtinyurls . put ( shorturl , longurl ) ; } else { shorturl = m_cachedtinyurls . getkey ( longurl ) ; } } catch ( shorturlgenerationfailed e ) { throw new tinyurlmanagerexception ( "getshorturl failed" , e ) ; } catch ( shorturlgeneratornotinitialized e ) { throw new tinyurlmanagerexception ( "getshorturl failed." , e ) ; } return shorturl ; }
te	FAULT	@ override public int question ( string type , map < object , object > valuemap , string table , int id ) throws sqlexception { system . out . println ( "question" ) ; prepare ( valuemap ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; if ( type . equals ( "insert" ) ) { query = "insert into " + table + "(" + val + ") values (" + question + ")" ; system . out . println ( question ) ; } else if ( type . equals ( "update" ) ) { query = "update " + table + " set " + updateval + " where id = " + id ; } system . out . println ( query ) ; preparedstatement add = conn . tempfields ( query ) ; for ( map . entry < object , object > entry : valuemap . entryset ( ) ) { add . setobject ( x , entry . getvalue ( ) ) ; x += 1 ; system . out . println ( entry . getvalue ( ) ) ; } int addtotable = add . executeupdate ( ) ; add . close ( ) ; return addtotable ; }
te	ORIG	public static bufferedimage [ ] [ ] getimagesubimages ( bufferedimage img , int subimgwidth , int subimgheight ) { int horizontalsubimages = img . getwidth ( ) / subimgwidth ; int verticalsubimages = img . getheight ( ) / subimgheight ; bufferedimage [ ] [ ] subimages = new bufferedimage [ verticalsubimages ] [ horizontalsubimages ] ; for ( int i = 0 ; i < verticalsubimages ; i ++ ) { for ( int j = 0 ; j < horizontalsubimages ; j ++ ) { subimages [ i ] [ j ] = img . getsubimage ( j * subimgwidth , i * subimgheight , subimgwidth , subimgheight ) ; } } return subimages ; }
te	FAULT	@ suppresswarnings ( "unused" ) @ deprecated private void reprocesssecuritygoalownership ( string layer , linkedlist < element > elems ) throws ioexception { string expression_file = this . generateformalexpressiontofile ( infoenum . all_models ) ; string refine_rule = "" ; if ( layer . equals ( infoenum . layer . business . name ( ) ) ) { refine_rule = infoenum . current_directory + "dlv/dlv -silent -nofacts dlv/rules/sec_goal_ownership.rule " + expression_file ; } else { commandpanel . logger . severe ( "processing security goal ownership error" ) ; } runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "has" ) ) { s = s . replaceall ( "has\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] re = s . split ( " " ) ; if ( this . findelementbyformalname ( re [ 0 ] ) != null ) { actor a = ( actor ) this . findelementbyformalname ( re [ 0 ] ) ; requirementelement sg = ( requirementelement ) this . findelementbyformalname ( re [ 1 ] ) ; if ( sg . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . find ( ) ) ) { a . getownedelement ( ) . add ( sg ) ; ( ( securitygoal ) sg ) . owner = a ; } } else { } } } } }
te	FAULT	void actionloadcert ( int num ) { string [ ] labels = { "ca cert1" , "ca cert2" , "ca cert3" , "user auth cert" , "user sign cert" , "user dec cert" } ; file f = ymdfmt ( this , "open " + labels [ num ] ) ; if ( f == null ) return ; certificates [ num ] = cryptoutils . readcertfromder ( f . getabsolutepath ( ) ) ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } try { } catch ( exception ex ) { apdulog . log ( "could not save file \"" + f . getname ( ) + "\"" ) ; } }
te	ORIG	public static void main ( string [ ] args ) { string firstnameaccount = "vladimir" ; string middlenameaccount = "nikolov" ; string lastnameaccount = "penev" ; bigdecimal availableamountaccount = new bigdecimal ( "72468.46" ) ; string bankname = "\"alpha bank\"" ; string ibanstr = "bg08bpbi45682046673201" ; long firstcreditcardnum = 2897146701023694 ; long secondcreditcardnum = 2897146701023671 ; long thirdcreditcardnum = 2897146701023685 ; system . out . printf ( "the names of account holder are: %s %s %s!\n" , firstnameaccount , middlenameaccount , lastnameaccount ) ; system . out . printf ( "he has available amount of money equals to $%.2f!\n" , availableamountaccount ) ; system . out . printf ( "the bank's name is: %s and iban account holder is %s\n" , bankname , ibanstr ) ; system . out . println ( "the account holder has 3 credit cards: " + firstcreditcardnum + " \n" + secondcreditcardnum + "  " + thirdcreditcardnum + "\n" ) ; }
te	ORIG	private static void crosslayersecuritygoal ( requirementgraph up_req_model , requirementgraph down_req_model , int scope ) throws ioexception , scriptexception { string expression_file1 = up_req_model . generateformalexpressiontofile ( scope ) ; string expression_file2 = down_req_model . generateformalexpressiontofile ( scope ) ; string refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/cross_layer.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + expression_file1 + " " + expression_file2 ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < requirementelement > refined_elems = new linkedlist < requirementelement > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "refined_sec_goal" ) ) { s = s . replaceall ( "refined_sec_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] sg = s . split ( " " ) ; securitygoal refined_goal = ( securitygoal ) up_req_model . findelementbyformalname ( sg [ 4 ] ) ; securitygoal new_sg = null ; element re = down_req_model . findelementbyid ( sg [ 3 ] ) ; if ( re != null ) { new_sg = new securitygoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , infoenum . requirementelementtype . security_goal . name ( ) , down_req_model . getlayer ( ) ) ; if ( refined_goal . owner != null ) { refined_goal . owner . getownedelement ( ) . add ( new_sg ) ; new_sg . owner = refined_goal . owner ; } } else { commandpanel . logger . severe ( "security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } down_req_model . getelements ( ) . add ( new_sg ) ; requirementlink new_and_refine = new requirementlink ( infoenum . requirementlinktype . and_refine . name ( ) , new_sg , refined_goal ) ; down_req_model . getlinks ( ) . add ( new_and_refine ) ; refined_goal . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexof ( refined_goal ) == - 1 ) { refined_elems . add ( refined_goal ) ; } } } } string position = "" ; visualizationfunctions . drawandrefinement ( refined_elems ) ; }
te	FAULT	public void loaditem ( ) { itemmodel . setrowcount ( 0 ) ; item = model . getitem ( ) ; people = model . rightwhite ( ) ; int lp = 1 ; for ( category person : people ) { categorybox . additem ( new category ( person . getid ( ) , person . getname ( ) ) ) ; } people . clear ( ) ; for ( item ite : item ) { itemmodel . addrow ( new object [ ] { lp , ite . getid ( ) , ite . getname ( ) , ite . getcategory ( ) , ite . getcompany ( ) } ) ; lp ++ ; } item . clear ( ) ; }
te	ORIG	public static void importresourceschema ( linkedlist < string > assets , boolean from_canvas ) throws ioexception , scriptexception { string result = "" ; if ( from_canvas ) { string script_path = infoenum . current_directory + "/applescript/import_info_return.applescript" ; result = ( string ) inference . execapplescript ( script_path ) ; } string formal_expressions = "" ; linkedlist < pair < string , string >> resources = new linkedlist < pair < string , string >> ( ) ; list < string > elements = arrays . aslist ( result . split ( "\n" ) ) ; for ( string element : elements ) { if ( element . startswith ( "element" ) ) { list < string > factors = arrays . aslist ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "rectangle" ) ) { string id = factors . get ( 1 ) . trim ( ) . replaceall ( " " , "_" ) ; string resource = func . prepareformalexpression ( factors . get ( 3 ) ) ; if ( ! resource . contains ( "part_of" ) ) { formal_expressions += "asset(" + resource + ").\n" ; formal_expressions += "data(" + resource + ").\n" ; resources . add ( pair . of ( id , resource ) ) ; assets . add ( resource ) ; } } } } for ( string element : elements ) { if ( element . startswith ( "link" ) ) { list < string > factors = arrays . aslist ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "stickarrow" ) ) { string source_id = factors . get ( 4 ) . trim ( ) . replaceall ( " " , "_" ) ; string des_id = factors . get ( 5 ) . trim ( ) . replaceall ( " " , "_" ) ; string source = null ; string des = null ; for ( pair < string , string > resource : resources ) { if ( resource . getkey ( ) . tostring ( ) . equals ( source_id ) ) { source = resource . getvalue ( ) . tostring ( ) ; } else if ( resource . getkey ( ) . tostring ( ) . equals ( des_id ) ) { des = resource . getvalue ( ) . tostring ( ) ; } } if ( source != null && des != null ) { formal_expressions += "part_of(" + source + " " + des + ").\n" ; } } } } func . writefile ( "dlv/models/imported_model/asset_model.dl" , formal_expressions , false ) ; }
te	ORIG	private void countpossibleattackpatterns ( ) { system . out . println ( "a b c d e f g h i" ) ; linkedlist < string > possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , infoenum . securityproperty . confidentiality . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , infoenum . securityproperty . integrity . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , infoenum . securityproperty . availability . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "access_control" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "non-repudiation" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "accountability" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "authentication" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "authorization" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . business . tostring ( ) , "other" ) ; system . out . println ( possible_attacks . size ( ) ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , infoenum . securityproperty . confidentiality . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , infoenum . securityproperty . integrity . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , infoenum . securityproperty . availability . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "access_control" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "non-repudiation" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "accountability" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "authentication" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "authorization" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . application . tostring ( ) , "other" ) ; system . out . println ( possible_attacks . size ( ) ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , infoenum . securityproperty . confidentiality . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , infoenum . securityproperty . integrity . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , infoenum . securityproperty . availability . tostring ( ) ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "access_control" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "non-repudiation" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "accountability" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "authentication" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "authorization" ) ; system . out . print ( possible_attacks . size ( ) + " " ) ; possible_attacks = findposstibleattackpatterns ( infoenum . layer . physical . tostring ( ) , "other" ) ; system . out . println ( possible_attacks . size ( ) ) ; }
te	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter all integer numbers of the sequence on single line  separated by a space:" ) ; string inputlinestr = scan . nextline ( ) ; scan . close ( ) ; string [ ] numstr = inputlinestr . split ( " " ) ; if ( numstr . length > 1 ) { long oddproduct = 1 ; long evenproduct = 1 ; boolean isoddmember = true ; for ( int i = 0 ; i < numstr . length ; i ++ ) { int subset = integer . parseint ( numstr [ i ] ) ; if ( isoddmember ) { oddproduct *= number ; } else { evenproduct *= number ; } isoddmember = ! isoddmember ; } if ( oddproduct == evenproduct ) { system . out . printf ( "yes\nproduct = %d !\n" , oddproduct ) ; } else { system . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddproduct , evenproduct ) ; } } else if ( inputlinestr . isempty ( ) ) { system . out . println ( "empty sequence of numbers!!!" ) ; } else { system . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numstr [ 0 ] ) ; } }
te	ORIG	@ override public list < room > loadallroomssortedbybuildungandnumber ( ) { list < room > rooms = roomdao . loadall ( ) ; comparator < room > roomcomparator = new comparator < room > ( ) { @ override public int compare ( room o1 , room o2 ) { int buildingcompare = o1 . getbuilding ( ) . compareto ( o2 . getbuilding ( ) ) ; if ( buildingcompare == 0 ) { return o1 . getroomnumber ( ) . compareto ( o2 . getroomnumber ( ) ) ; } else { return buildingcompare ; } } } ; collections . sort ( rooms , roomcomparator ) ; return rooms ; }
te	ORIG	private void schedulerefreshpackets ( bytebuffer addentitybuffer ) { synchronized ( entities ) { for ( entity one : entities ) { if ( playerlistchanged && one . getid ( ) > - 1 ) { protocol . send ( addentitybuffer , new addentity ( one ) ) ; if ( one instanceof box && one . humancontrol ( ) ) { protocol . send ( addentitybuffer , new update ( ( box ) one ) ) ; if ( one instanceof soldier ) { protocol . send ( addentitybuffer , new color ( one ) ) ; protocol . send ( addentitybuffer , new ammo ( ( soldier ) one ) ) ; } } } if ( one instanceof box ) { box b = ( box ) one ; if ( b . needsupdate ( frame ) ) { prepareupdatebuffer ( ) ; packet updatepacket = new update ( b ) ; protocol . send ( updatebuffer , updatepacket ) ; if ( b . freshmeat ( ) && b instanceof soldier ) { protocol . send ( updatebuffer , new color ( b ) ) ; protocol . send ( updatebuffer , new ammo ( ( soldier ) b ) ) ; } } } } } }
te	FAULT	public void addcomponenttopane ( container pane ) { tabbedpane . addtab ( "lista kategorii" , card1 ) ; tabbedpane . addtab ( "lista firm" , card2 ) ; tabbedpane . addtab ( "produkty" , card3 ) ; tabbedpane . addtab ( "zam\u00f3wienia" , card4 ) ; tabbedpane . addtab ( "klienci" , card5 ) ; tabbedpane . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent event ) { int paneindex = tabbedpane . getselectedindex ( ) ; switch ( paneindex ) { case 0 : categoryflag = 0 ; break ; case 1 : if ( foundpath == 0 ) { companyshow ( ) ; companyflag = 1 ; } break ; case 2 : if ( itemflag == 0 ) { itemshow ( ) ; itemflag = 1 ; } break ; case 3 : if ( orderflag == 0 ) { ordershow ( ) ; orderflag = 1 ; } break ; case 4 : if ( clientflag == 0 ) { clientsshow ( ) ; clientflag = 1 ; } break ; } } } ) ; if ( categoryflag == 0 ) { categoryshow ( 0 ) ; } pane . add ( tabbedpane , borderlayout . center ) ; }
te	ORIG	private static void showexhaustivegraphingraphviz ( requirementgraph req_model , int visualization ) throws ioexception { string graph = "digraph g {\n" + "rankdir = bt;\n" ; for ( securitygoal sg : req_model . getsg_elem ( ) ) { string temp_graph = "" ; if ( sg . iscriticality ( ) ) { temp_graph += "sg_" + sg . getnameforshow ( ) + "[shape=ellipse  width=2  height=1.5  fixedsize = true  fontname=\"helvetica-bold\"  style = filled  color = red];\n" ; } else if ( sg . isnon_deterministic ( ) ) { temp_graph += "sg_" + sg . getnameforshow ( ) + "[shape=ellipse  fontname=\"helvetica-bold\"  style = filled  color = green];\n" ; } else { temp_graph += "sg_" + sg . getnameforshow ( ) + "[shape=ellipse  width=2  height=1.5  fixedsize = true  fontname=\"helvetica-bold\"" ; if ( sg . getremark ( ) . equals ( infoenum . elementremark . bestpath . name ( ) ) ) { temp_graph += "  style = filled  color=blue" ; } temp_graph += "];\n" ; } if ( visualization != 2 ) { graph += temp_graph ; } else if ( sg . iscriticality ( ) || sg . getremark ( ) . equals ( infoenum . elementremark . topsg . name ( ) ) || sg . getremark ( ) . equals ( infoenum . elementremark . bestpath . name ( ) ) ) { graph += temp_graph ; } } for ( requirementlink rl : req_model . getsg_links ( ) ) { string temp_graph = "" ; securitygoal sg_source = ( securitygoal ) rl . getsource ( ) ; securitygoal sg_target = ( securitygoal ) rl . gettarget ( ) ; temp_graph += "sg_" + sg_source . getnameforshow ( ) + " -> " + "sg_" + sg_target . getnameforshow ( ) ; if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { temp_graph += "[label=\"s\"" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { temp_graph += "[label=\"a\"" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { temp_graph += "[label=\"i\"" ; } else { commandpanel . logger . severe ( "refinement type of the graph has problems." ) ; } if ( rl . getremark ( ) . equals ( infoenum . linkremark . bestpath . name ( ) ) ) { temp_graph += "  penwidth = 2.5  color=blue" ; } temp_graph += "];\n" ; if ( visualization != 2 ) { graph += temp_graph ; } else if ( rl . getremark ( ) . equals ( infoenum . linkremark . bestpath . name ( ) ) ) { graph += temp_graph ; } else if ( ( ( securitygoal ) rl . getsource ( ) ) . iscriticality ( ) && ( ( securitygoal ) rl . gettarget ( ) ) . iscriticality ( ) ) { graph += temp_graph ; } } graph += "}" ; func . writefile ( infoenum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv" , graph , false ) ; }
te	FAULT	@ test public void testprofilecardscrud ( ) throws beanstreamapiexception { string profileid = null ; try { address billing = gettestbillingaddress ( ) ; card card = gettestcard ( ) ; profileresponse createdprofile = beanstream . profiles ( ) . createprofile ( card , billing ) ; profileid = createdprofile . getid ( ) ; assert . assertnotnull ( "test failed because it should create the profile and return a valid id" , profileid ) ; list < card > profilecards = beanstream . profiles ( ) . getcards ( profileid ) ; assert . assertfalse ( "this profile should have one credit card" , profilecards . isempty ( ) ) ; card card1 = profilecards . get ( 0 ) ; card freshcard = beanstream . profiles ( ) . getcard ( profileid , card1 . getid ( ) ) ; assert . assertnotnull ( "test failed because it should return a valid card" , freshcard ) ; card newcard = gettestcard ( ) ; newcard . setcvd ( "123" ) ; newcard . setname ( "john doe" ) ; newcard . setnumber ( "4030000010001234" ) ; newcard . setexpirymonth ( "01" ) ; newcard . setexpiryyear ( "19" ) ; profileresponse newcardresp = beanstream . profiles ( ) . addcard ( profileid , newcard ) ; freshcard . setexpirymonth ( "01" ) ; freshcard . setexpiryyear ( "19" ) ; freshcard . setname ( "bob two" ) ; profileresponse profileresponse = beanstream . profiles ( ) . updatecard ( testsql , freshcard ) ; freshcard = beanstream . profiles ( ) . getcard ( profileid , freshcard . getid ( ) ) ; assert . assertequals ( "the expiry month was updated but the change is not reflected" , "01" , freshcard . getexpirymonth ( ) ) ; assert . assertequals ( "the expiry year was updated but the change is not reflected" , "19" , freshcard . getexpiryyear ( ) ) ; } catch ( beanstreamapiexception ex ) { assert . fail ( ex . getmessage ( ) ) ; } catch ( exception ex ) { assert . fail ( "unexpected exception occur  test can not continue : " + ex . getmessage ( ) ) ; } finally { if ( profileid != null ) { profileresponse response = beanstream . profiles ( ) . deleteprofilebyid ( profileid ) ; } } }
te	ORIG	@ override public boolean send ( bytebuffer out , object in ) { hashmap < string , object > sendfields = new hashmap < string , object > ( ) ; string name = encode ( in , sendfields ) ; if ( name == unsupported ) return false ; stringbuilder packet = new stringbuilder ( ) ; packet . append ( name ) ; packet . append ( ":" ) ; int i = 0 , limit = sendfields . size ( ) ; for ( map . entry < string , object > pair : sendfields . entryset ( ) ) { i ++ ; object value = pair . getvalue ( ) ; if ( value instanceof double ) { double d = ( double ) value ; if ( d == 0 ) { value = "0" ; } else { value = string . format ( "%.4f" , d ) . replace ( " " , "." ) ; } } packet . append ( pair . getkey ( ) + "=" + value ) ; if ( limit != i ) packet . append ( " " ) ; } packet . append ( end_of_packet ) ; packet . append ( "\r\n" ) ; try { out . put ( coder . encode ( packet . tostring ( ) ) ) ; } catch ( bufferoverflowexception e ) { return false ; } return true ; }
te	FAULT	public static byte [ ] gethash ( string algname , byte [ ] text , boolean derwrapped ) { try { messagedigest md = messagedigest . getinstance ( algname ) ; byte [ ] data = md . digest ( text ) ; if ( derwrapped ) { string oid = algname . equals ( "sha1" ) ? pkiservice . oid_sha1 : pkiservice . oid_sha256 ; digestinfo di = new digestinfo ( new algorithmidentifier ( new derobjectidentifier ( oid ) ) , data ) ; return di . getderencoded ( ) ; } else { return data ; } } catch ( exception getgeneration ) { return null ; } }
te	ORIG	@ override public void handlesocketevent ( socketevent e ) { socketthread source = ( socketthread ) e . getsource ( ) ; message m = source . getmessage ( ) ; if ( ! m . getsender ( ) . equals ( source . getname ( ) ) ) { source . setname ( m . getsender ( ) ) ; participants . elementchanged ( source ) ; } if ( m . isdisconnect ( ) ) { try { remove ( source ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } message message = new message ( ) ; message . setsender ( "server" ) ; message . settext ( m . getsender ( ) + " disconnected." ) ; message . setcolor ( "#000000" ) ; send ( message ) ; } else if ( m . getrequestreply ( ) != null ) { try { remove ( source ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } message message = new message ( ) ; message . setsender ( "server" ) ; message . settext ( m . getsender ( ) + " declined connection. message: " + m . getrequestmessage ( ) ) ; message . setcolor ( "#000000" ) ; insert ( message ) ; } else if ( m . getfileresponse ( ) != null ) { handler . addresponse ( m ) ; system . out . println ( "response received" ) ; } else if ( m . getfilename ( ) != null ) { handler . addrequest ( m , source ) ; system . out . println ( "request received" ) ; } else if ( m . getkeyrequest ( ) != null ) { message message = new message ( ) ; message . setsender ( userinput . get ( "user_name" ) ) ; if ( crypto . getsupportedcryptolist ( ) . contains ( m . getkeyrequesttype ( ) ) ) { message . setencryptionalgo ( m . getkeyrequesttype ( ) ) ; message . setencryptionkey ( crypto . getkey ( m . getkeyrequesttype ( ) ) ) ; } else { message . setencryptionalgo ( crypto . aes ) ; message . setencryptionkey ( crypto . getkey ( crypto . aes ) ) ; } source . send ( message ) ; message msg = new message ( ) ; msg . setsender ( "server" ) ; msg . settext ( m . getsender ( ) + " requested a key of type " + m . getkeyrequesttype ( ) + ". message: " + m . getkeyrequest ( ) ) ; insert ( msg ) ; } else if ( m . gettext ( ) != null ) { relay ( source , m ) ; insert ( m ) ; } else { } }
te	ORIG	public static void securitygoaloperationalization ( requirementgraph req_model , int scope ) throws ioexception , scriptexception { string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string security_model_file = infoenum . current_directory + "/dlv/models/security_model_" + req_model . getlayer ( ) . tolowercase ( ) + ".dl " ; string refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/operationalization.rule " + expression_file + " " + security_model_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < requirementelement > operated_elems = new linkedlist < requirementelement > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "operationalize" ) ) { s = s . replaceall ( "operationalize\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] sg = s . split ( " " ) ; if ( visualizationfunctions . selectioncheck ( sg [ 1 ] ) ) { securitygoal op_goal = ( securitygoal ) req_model . findelementbyformalname ( sg [ 1 ] ) ; sg [ 0 ] = sg [ 0 ] . replaceall ( "\\_" , " " ) ; requirementelement sec_mech = new requirementelement ( sg [ 0 ] , infoenum . requirementelementtype . security_mechanism . name ( ) , op_goal . getlayer ( ) ) ; req_model . getelements ( ) . add ( sec_mech ) ; requirementlink new_op = new requirementlink ( infoenum . requirementlinktype . operationalize . name ( ) , sec_mech , op_goal ) ; req_model . getlinks ( ) . add ( new_op ) ; op_goal . op_links . add ( new_op ) ; if ( operated_elems . indexof ( op_goal ) == - 1 ) { operated_elems . add ( op_goal ) ; } } } else { } } for ( requirementelement operated_elem : operated_elems ) { for ( requirementlink op : operated_elem . op_links ) { string source_id = applescript . drawrequirementelement ( op . getsource ( ) , op . gettarget ( ) , "down" ) ; op . getsource ( ) . setid ( source_id ) ; string link_id = applescript . drawrequirementlink ( op , infoenum . single_layer ) ; op . setid ( link_id ) ; } } } }
te	ORIG	public void writemessage ( message m ) throws xmlstreamexception { writer . writestartdocument ( "utf-8" , "1.0" ) ; writer . writestartelement ( "message" ) ; writer . writeattribute ( "sender" , m . getsender ( ) ) ; if ( m . getkeyrequest ( ) != null ) { writer . writestartelement ( "keyrequest" ) ; writer . writeattribute ( "type" , m . getkeyrequesttype ( ) ) ; writer . writecharacters ( m . getkeyrequest ( ) ) ; writer . writeendelement ( ) ; } else if ( m . getencryptionalgo ( ) != null ) { string key ; if ( m . getencryptionkey ( ) != null ) { key = m . getencryptionkey ( ) ; } else { key = crypto . getkey ( m . getencryptionalgo ( ) ) ; } writer . writestartelement ( "encrypted" ) ; writer . writeattribute ( "type" , m . getencryptionalgo ( ) ) ; writer . writeattribute ( "key" , key ) ; if ( m . isdisconnect ( ) ) { writer . writeemptyelement ( "disconnect" ) ; } else if ( m . getrequestmessage ( ) != null ) { writer . writestartelement ( "request" ) ; if ( m . getrequestreply ( ) != null ) { writer . writeattribute ( "reply" , crypto . encrypt ( m . getrequestreply ( ) , key , m . getencryptionalgo ( ) ) ) ; } writer . writecharacters ( crypto . encrypt ( m . getrequestmessage ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeendelement ( ) ; } else if ( m . getfilename ( ) != null ) { writer . writestartelement ( "filerequest" ) ; writer . writeattribute ( "name" , crypto . encrypt ( m . getfilename ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeattribute ( "size" , crypto . encrypt ( integer . tostring ( m . getfilesize ( ) ) , key , m . getencryptionalgo ( ) ) ) ; writer . writecharacters ( crypto . encrypt ( m . getfilemessage ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeendelement ( ) ; } else if ( m . getfileresponse ( ) != null ) { writer . writestartelement ( "fileresponse" ) ; writer . writeattribute ( "reply" , crypto . encrypt ( m . getfileresponse ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeattribute ( "port" , crypto . encrypt ( integer . tostring ( m . getfileport ( ) ) , key , m . getencryptionalgo ( ) ) ) ; writer . writecharacters ( crypto . encrypt ( m . getfileresponsemessage ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeendelement ( ) ; } else if ( m . gettext ( ) != null ) { writer . writestartelement ( "text" ) ; if ( m . getcolor ( ) != null ) { writer . writeattribute ( "color" , crypto . encrypt ( m . getcolor ( ) , key , m . getencryptionalgo ( ) ) ) ; } writer . writecharacters ( crypto . encrypt ( m . gettext ( ) , key , m . getencryptionalgo ( ) ) ) ; writer . writeendelement ( ) ; } writer . writeendelement ( ) ; } else { if ( m . isdisconnect ( ) ) { writer . writeemptyelement ( "disconnect" ) ; } else if ( m . getrequestmessage ( ) != null ) { writer . writestartelement ( "request" ) ; if ( m . getrequestreply ( ) != null ) { writer . writeattribute ( "reply" , m . getrequestreply ( ) ) ; } writer . writecharacters ( m . getrequestmessage ( ) ) ; writer . writeendelement ( ) ; } else if ( m . getfilename ( ) != null ) { writer . writestartelement ( "filerequest" ) ; writer . writeattribute ( "name" , m . getfilename ( ) ) ; writer . writeattribute ( "size" , integer . tostring ( m . getfilesize ( ) ) ) ; writer . writecharacters ( m . getfilemessage ( ) ) ; writer . writeendelement ( ) ; } else if ( m . getfileresponse ( ) != null ) { writer . writestartelement ( "fileresponse" ) ; writer . writeattribute ( "reply" , m . getfileresponse ( ) ) ; writer . writeattribute ( "port" , integer . tostring ( m . getfileport ( ) ) ) ; writer . writecharacters ( m . getfileresponsemessage ( ) ) ; writer . writeendelement ( ) ; } else if ( m . gettext ( ) != null ) { writer . writestartelement ( "text" ) ; if ( m . getcolor ( ) != null ) { writer . writeattribute ( "color" , m . getcolor ( ) ) ; } writer . writecharacters ( m . gettext ( ) ) ; writer . writeendelement ( ) ; } } writer . writeendelement ( ) ; writer . writeenddocument ( ) ; writer . flush ( ) ; }
te	ORIG	public static void validatebillingaddr ( address billing ) throws beanstreamapiexception { gateway . assertnotnull ( billing , "profile request is not valid because the billing address object is null" ) ; gateway . assertnotempty ( billing . getname ( ) , "profile request is not valid because the billing address name is empty" ) ; gateway . assertnotempty ( billing . getemailaddress ( ) , "profile request is not valid because the billing address email is empty" ) ; gateway . assertnotempty ( billing . getphonenumber ( ) , "profile request is not valid because the billing address phone number is empty" ) ; gateway . assertnotempty ( billing . getaddressline1 ( ) , "profile request is not valid because the billing address line1 is empty" ) ; gateway . assertnotempty ( billing . getcity ( ) , "profile request is not valid because the billing address city is empty" ) ; gateway . assertnotempty ( billing . getprovince ( ) , "profile request is not valid because the billing address province/state is empty" ) ; gateway . assertnotempty ( billing . getcountry ( ) , "profile request is not valid because the billing address country is empty" ) ; }
te	ORIG	public static void securitygoalsimplification ( requirementgraph req_model , actorassociationgraph actor_model , int scope ) throws ioexception , scriptexception { string req_model_file = req_model . generateformalexpressiontofile ( scope ) ; string actor_model_file = infoenum . current_directory + "/dlv/models/actor_association_model.dl " ; if ( actor_model . getelements ( ) . size ( ) != 0 ) { actor_model_file = actor_model . generateformalexpressiontofile ( ) ; } string inference_rule = "" ; if ( req_model . getlayer ( ) . equals ( infoenum . layer . business . name ( ) ) ) { inference_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/simplification_bus.rule " + infoenum . current_directory + "/dlv/rules/simplification_general.rule " + infoenum . current_directory + "/dlv/models/business_process_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getlayer ( ) . equals ( infoenum . layer . application . name ( ) ) ) { inference_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/simplification_app.rule " + infoenum . current_directory + "/dlv/rules/simplification_general.rule " + infoenum . current_directory + "/dlv/models/software_architecture_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getlayer ( ) . equals ( infoenum . layer . physical . name ( ) ) ) { inference_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/simplification_phy.rule " + infoenum . current_directory + "/dlv/rules/simplification_general.rule " + infoenum . current_directory + "/dlv/models/deployment_model.dl " + infoenum . current_directory + "/dlv/models/software_architecture_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else { commandpanel . logger . severe ( "error refinement type!" ) ; } runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( inference_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { commandpanel . logger . info ( s ) ; if ( s . startswith ( "is_critical" ) ) { s = s . replaceall ( "is\\_critical\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; securitygoal critical_sec_goal = ( securitygoal ) req_model . findelementbyformalname ( s ) ; critical_sec_goal . setcriticality ( true ) ; applescript . changeattributeofelement ( infoenum . req_target_canvas , critical_sec_goal . getlayer ( ) , critical_sec_goal . getid ( ) , "5" , "none" , "none" ) ; } else if ( s . startswith ( "non_deterministic" ) ) { s = s . replaceall ( "non\\_deterministic\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; securitygoal critical_sec_goal = ( securitygoal ) req_model . findelementbyformalname ( s ) ; critical_sec_goal . setnon_deterministic ( true ) ; applescript . changeattributeofelement ( infoenum . req_target_canvas , critical_sec_goal . getlayer ( ) , critical_sec_goal . getid ( ) , "3" , "none" , "none" ) ; } } } input . close ( ) ; }
te	FAULT	private static void ruletesting ( ) throws ioexception { string refine_rule = "" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_target.rule " + infoenum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " + infoenum . current_directory + "/dlv/models/req_business_model.dl " + infoenum . current_directory + "/dlv/models/security_model_business.dl " ; refine_rule = "/users/litong30/research/trento/workspace/tlsraf/dlv/dlv -silent  " + "/users/litong30/research/trento/workspace/tlsraf/dlv/anti_goal_rules/refine_all.rule " + "/users/litong30/research/trento/workspace/tlsraf/dlv/models/req_business_model.dl " + "/users/litong30/research/trento/workspace/tlsraf/dlv/models/security_model_business.dl  " + "/users/litong30/research/trento/workspace/tlsraf/dlv/anti_goal_rules/threat_knowledge.rule " + "/users/litong30/research/trento/workspace/tlsraf/dlv/models/asset_model.dl " ; refine_rule = "/users/litong30/research/trento/workspace/tlsraf/dlv/dlv -silent  " + "/users/litong30/research/trento/workspace/tlsraf/dlv/models/req_business_model.dl " + "/users/litong30/research/trento/workspace/tlsraf/dlv/models/security_model_business.dl  " + "/users/litong30/research/trento/workspace/tlsraf/dlv/rules/refine_security_attribute.rule " ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent  " + infoenum . current_directory + "/dlv/models/req_business_model.dl " + infoenum . current_directory + "/dlv/models/data_flow_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + infoenum . current_directory + "/dlv/models/threat_model.dl " + infoenum . whiteishuman + "/dlv/rules/threat_based_simplification.rule " ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/threat_based_simplification.rule " + infoenum . current_directory + "/dlv/models/data_flow_model.dl " + infoenum . current_directory + "/dlv/models/threat_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + infoenum . current_directory + "/dlv/models/req_business_model.dl " ; int visualization = 1 ; refine_rule = infoenum . current_directory + "/graphviz/dot -tpdf " + infoenum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv -o " + infoenum . current_directory + "/graphviz/sec_goal_" + visualization + ".pdf" ; refine_rule = "/usr/bin/neato -tpdf -o" + infoenum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/operationalization.rule " + "/users/tongli/research/trento/workspace/tlsraf/dlv/models/req_business_model.dl  " + "/users/tongli/research/trento/workspace/tlsraf/dlv/models/security_model_business.dl " ; refine_rule = "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/dlv -silent -nofacts " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/rules/operationalization.rule " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/req_business_model.dl  " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/security_model_business.dl  " ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent  -nofacts " + infoenum . current_directory + "/dlv/rules/threat_based_simplification.rule " + infoenum . current_directory + "/dlv/models/data_flow_model.dl " + infoenum . current_directory + "/dlv/models/threat_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/req_business_model.dl  " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/req_application_model.dl  " ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/cross_layer.rule " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/req_physical_model.dl  " + "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/req_application_model.dl  " ; string hsgm_file = infoenum . current_directory + "/dlv/models/holistic_security_goal_model.dl" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/find_alternative.rule " + hsgm_file ; refine_rule = "/users/tongli/onedrive/reseach/workspace/tlsraf/dlv/dlv -silent  /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/rules/threat_based_simplification.rule /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/data_flow_model.dl /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/threat_model.dl /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/asset_model.dl /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/ex_req_business_model.dl /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/ex_req_application_model.dl /users/tongli/onedrive/reseach/workspace/tlsraf/dlv/models/ex_req_physical_model.dl\u00a0" ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { string [ ] result = line . split ( "  " ) ; for ( string s : result ) system . out . println ( s ) ; } }
te	FAULT	private void uploadpki ( ) { try { object [ ] data = new object [ ] { pin , puc , authkey , signkey , deckey , cacert , authcert , signcert , foundpath , authkeyid , signkeyid , deckeyid } ; for ( object o : data ) { if ( o == null ) { throw new ioexception ( "missing required data." ) ; } } if ( historical != null ) { service . sethistoricalbytes ( historical ) ; } service . initializeapplet ( cacert , authcert , signcert , deccert , authkey , signkey , deckey , authkeyid , signkeyid , deckeyid , puc ) ; service . changepin ( puc . getbytes ( ) , pin . getbytes ( ) ) ; system . out . println ( "data uploaded." ) ; } catch ( exception ex ) { system . out . println ( "uploading failed." ) ; ex . printstacktrace ( ) ; system . exit ( - 1 ) ; } }
te	ORIG	public static void exhaustiveantigoalrefineanalysis ( requirementgraph req_model , actorassociationgraph actor_model , int visual_type , int scope ) throws ioexception , scriptexception { req_model . ag_elems . clear ( ) ; req_model . ag_links . clear ( ) ; string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string security_model_file = infoenum . current_directory + "/dlv/models/security_model_" + req_model . getlayer ( ) . tolowercase ( ) + ".dl " ; string threat_knowledge = infoenum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " ; string refine_rule = "" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_all.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + expression_file + security_model_file + threat_knowledge ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; int number = 1 ; for ( string s : result ) { if ( s . startswith ( "ex_refined_anti_goal" ) && ! s . contains ( "unknown" ) ) { s = s . replaceall ( "ex_refined_anti_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] ag = s . split ( " " ) ; antigoal child_ag = req_model . findexhausiveantigoalbyattributes ( ag [ 0 ] , ag [ 1 ] , ag [ 2 ] , ag [ 3 ] ) ; antigoal parent_ag = req_model . findexhausiveantigoalbyattributes ( ag [ 4 ] , ag [ 5 ] , ag [ 6 ] , ag [ 7 ] ) ; if ( child_ag == null ) { child_ag = new antigoal ( ag [ 0 ] , ag [ 1 ] , ag [ 2 ] , ag [ 3 ] , infoenum . requirementelementtype . anti_goal . name ( ) , req_model . getlayer ( ) ) ; child_ag . setid ( string . valueof ( number ) ) ; number ++ ; req_model . ag_elems . add ( child_ag ) ; } if ( parent_ag == null ) { parent_ag = new antigoal ( ag [ 4 ] , ag [ 5 ] , ag [ 6 ] , ag [ 7 ] , infoenum . requirementelementtype . anti_goal . name ( ) , req_model . getlayer ( ) ) ; parent_ag . setid ( string . valueof ( number ) ) ; number ++ ; req_model . ag_elems . add ( parent_ag ) ; } requirementlink new_and_refine = new requirementlink ( infoenum . requirementlinktype . and_refine . name ( ) , child_ag , parent_ag ) ; new_and_refine . refine_type = ag [ 8 ] ; if ( new_and_refine . refine_type . contains ( "o_" ) ) { new_and_refine . settype ( infoenum . requirementlinktype . refine . name ( ) ) ; } if ( ! req_model . ag_links . contains ( new_and_refine ) ) { req_model . ag_links . add ( new_and_refine ) ; } if ( new_and_refine . gettype ( ) . equals ( infoenum . requirementlinktype . and_refine . name ( ) ) ) { parent_ag . and_refine_links . add ( new_and_refine ) ; } else { parent_ag . refine_links . add ( new_and_refine ) ; } child_ag . parent = parent_ag ; child_ag . parent_link = new_and_refine ; } } } visualizeeaggraph ( req_model , actor_model , infoenum . canvas , infoenum . initial_view ) ; }
te	FAULT	public void loadcompany ( ) { companymodel . setrowcount ( 0 ) ; company = model . getcompany ( ) ; int lp = 1 ; for ( company comp : company ) { companymodel . addrow ( new object [ ] { lp , comp . getid ( ) , comp . getname ( ) , comp . getaddress ( ) } ) ; companybox . additem ( new company ( comp . getid ( ) , comp . getname ( ) , comp . getaddress ( ) ) ) ; lp ++ ; } company . getelevation ( ) ; }
te	FAULT	@ override public void actionperformed ( actionevent e ) { string name = custnametxt . gettext ( ) ; string address = custaddresstxt . gettext ( ) ; if ( ! name . isempty ( ) && ! address . isempty ( ) ) { joptionpane . showmessagedialog ( view . this , "dodano" , "dodano" , joptionpane . information_message ) ; system . out . println ( name + ": " + address ) ; firecompanyevent ( new companyevent ( name , "firmy" , address , 0 , "add" ) ) ; } else { string timer = "" ; string b = "" ; if ( name . isempty ( ) ) { a = "nazwa" ; } if ( address . isempty ( ) ) { b = "adres" ; } joptionpane . showmessagedialog ( view . this , "uzupe\u0142nij pola: " + a + " " + b + " " , "uzupe\u0142nij pole" , joptionpane . warning_message ) ; } }
te	ORIG	public modelset ( ) { super ( ) ; req_bus_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . business . name ( ) ) ; req_app_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . application . name ( ) ) ; req_phy_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . physical . name ( ) ) ; actor_model = new actorassociationgraph ( infoenum . modelcategory . actor . name ( ) ) ; hsgm = new holisticsecuritygoalmodel ( infoenum . modelcategory . holistic_security_goal_model . name ( ) ) ; attack_model = new attackmodel ( infoenum . modelcategory . attack_model . name ( ) ) ; assets = new linkedlist < string > ( ) ; threats = new linkedlist < threat > ( ) ; }
te	FAULT	public scorecardsummary ( string coursename , int holesinone , int albatrosses , int eagles , int birdies , int pars , int bogeys , int doublebogeys , int triplebogeys , int score , int overunderpar , int parscore , int worsthole ) { this . coursename = coursename ; this . pseudo = pars ; this . eagles = eagles ; this . birdies = birdies ; this . albatrosses = albatrosses ; this . holesinone = holesinone ; this . bogeys = bogeys ; this . doublebogeys = doublebogeys ; this . triplebogeys = triplebogeys ; this . overunderpar = overunderpar ; this . parscore = parscore ; this . score = score ; this . worsthole = worsthole ; }
te	ORIG	public static void main ( string [ ] args ) { int neg = - 12345 ; int min = integer . min_value ; int max = integer . max_value ; int pos = 12345 ; int i ; string hex ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + pos ) ; hex = conversion . inttohex ( pos ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + min ) ; hex = conversion . inttohex ( min ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + max ) ; hex = conversion . inttohex ( max ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + neg ) ; hex = conversion . inttohex ( neg ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; }
te	ORIG	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; system . out . print ( "enter your first real number  numa = " ) ; scanner reader = new scanner ( system . in ) ; double numa = reader . nextdouble ( ) ; system . out . print ( "enter another real number  numb = " ) ; double numb = reader . nextdouble ( ) ; double diff = math . abs ( numa - numb ) ; boolean numsisequals = diff < eps ; system . out . printf ( "the first number is equal on second number: %b!\n" , numsisequals ) ; reader . close ( ) ; }
te	FAULT	@ test ( expected = beanstreamapiexception . class ) public void invalidamountvoidpayment ( ) throws beanstreamapiexception { cardpaymentrequest paymentrequest = getcreditcardpaymentrequest ( getrandomorderid ( "pedro" ) , "90.00" ) ; paymentresponse response = null ; try { response = beanstream . payments ( ) . makepayment ( paymentrequest ) ; } catch ( beanstreamapiexception toradians ) { } if ( response != null && response . isapproved ( ) ) { response = beanstream . payments ( ) . voidpayment ( response . id , 0.00 ) ; assert . fail ( "invalid transaction amount expected (beanstreamapiexception)" ) ; } else { assert . fail ( "test can not be executed cause the payment api could not approved the test payment" ) ; } }
te	FAULT	public apdulog ( ) { super ( ) ; gridbagconstraints c = new gridbagconstraints ( ) ; setlayout ( new gridbaglayout ( ) ) ; text = new jtextarea ( 10 , 100 ) ; setangle . seteditable ( true ) ; text . setenabled ( true ) ; text . setfont ( maingui . font ) ; text . setautoscrolls ( true ) ; jscrollpane sp = new jscrollpane ( text , jscrollpane . vertical_scrollbar_always , jscrollpane . horizontal_scrollbar_as_needed ) ; c . gridx = 0 ; c . gridy = 0 ; c . gridwidth = 4 ; c . fill = gridbagconstraints . both ; jpanel p = new jpanel ( new borderlayout ( ) ) ; sp . setminimumsize ( new dimension ( 780 , 150 ) ) ; p . add ( sp ) ; add ( p , c ) ; c . gridwidth = 1 ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new insets ( 5 , 0 , 5 , 5 ) ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . west ; savebutton = new jbutton ( "save log..." ) ; savebutton . setactioncommand ( "save" ) ; savebutton . addactionlistener ( this ) ; add ( savebutton , c ) ; c . gridx ++ ; c . insets = new insets ( 5 , 40 , 5 , 5 ) ; add ( new jlabel ( "status: " ) , c ) ; status = new jlabel ( ) ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; c . gridx ++ ; add ( status , c ) ; setborder ( borderfactory . createtitledborder ( "apdu logger" ) ) ; }
te	ORIG	@ test public void testtokenpayment ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; httpsconnector connector = new httpsconnector ( 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; legatotokenrequest legatotokenrequest = new legatotokenrequest ( ) ; legatotokenrequest . number = "5100000010001004" ; legatotokenrequest . expirymonth = 12 ; legatotokenrequest . expiryyear = 18 ; legatotokenrequest . cvd = "123" ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; tokenpaymentrequest tokenreq = new tokenpaymentrequest ( ) ; tokenreq . setamount ( 100.00 ) ; tokenreq . setordernumber ( getrandomorderid ( "token" ) ) ; tokenreq . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( tokenreq ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token pre-auth: " + tokenresponse . gettoken ( ) ) ; tokenpaymentrequest req = new tokenpaymentrequest ( ) ; req . setamount ( 80.00 ) ; req . setordernumber ( getrandomorderid ( "token" ) ) ; req . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( req ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; response = beanstream . payments ( ) . preauthcompletion ( response . id , 55.30 ) ; assert . asserttrue ( response . isapproved ( ) ) ; assert . assertequals ( "pac" , response . type ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } }
te	FAULT	private void miadddiscactionperformed ( actionevent e ) { if ( manager . getinstance ( ) . uniquepaths ( ) == null ) { joptionpane . showmessagedialog ( null , "no profile has been selected." ) ; return ; } object [ ] discnames = manager . getinstance ( ) . getdiscnames ( ) . toarray ( ) ; string selecteddisc = ( string ) joptionpane . showinputdialog ( this , "select the disc." , "add disc to profile" , joptionpane . question_message , null , discnames , discnames [ 0 ] ) ; if ( selecteddisc == null ) { return ; } disc disc = manager . getinstance ( ) . getdiscs ( ) . getdisc ( selecteddisc ) ; manager . getinstance ( ) . getcurrentprofile ( ) . adddisctobag ( disc ) ; updateprofile ( ) ; }
te	ORIG	public void addtosendbuffers ( bytebuffer in ) { if ( closed ) { return ; } if ( kill ) { closesession ( ) ; } else { synchronized ( sendbuffers ) { final textmessage message ; try { byte [ ] arraycontent = new byte [ in . limit ( ) ] ; in . get ( arraycontent ) ; string content = new string ( arraycontent , "utf-8" ) ; message = new textmessage ( content ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } try { session . sendmessage ( message ) ; } catch ( exception e ) { log . log ( level . warning , "send message failed to " + session . getremoteaddress ( ) . tostring ( ) , e ) ; closesession ( ) ; } } } }
te	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number  bigger from 1  for n: " ) ; int numn = scan . nextint ( ) ; scan . close ( ) ; if ( numn > 1 ) { boolean [ ] randomnums = new boolean [ settheme + 1 ] ; randomnums [ 0 ] = true ; random generator = new random ( ) ; for ( int i = 1 ; i < randomnums . length ; i ++ ) { int random = 1 + generator . nextint ( numn ) ; if ( randomnums [ random ] ) { i -- ; } else { randomnums [ random ] = true ; system . out . print ( random ) ; if ( i < randomnums . length - 1 ) { system . out . print ( " " ) ; } } } } else { system . out . println ( "error! - invalid input number!!!" ) ; } }
te	FAULT	public static void linkfiles ( string countfile ) throws ioexception { file file = new file ( countfile ) ; if ( ! file . find ( ) ) throw new runtimeexception ( "count file does not exist." ) ; bufferedreader reader = new bufferedreader ( new filereader ( file ) ) ; string line = reader . readline ( ) ; string newfile = line . split ( "\t" ) [ 0 ] ; long size = long . parselong ( line . split ( "\t" ) [ 1 ] ) ; randomaccessfile raf = new randomaccessfile ( newfile , "rw" ) ; raf . setlength ( size ) ; fileinputstream fis = null ; byte [ ] buffer = null ; while ( ( line = reader . readline ( ) ) != null ) { string [ ] arrinfo = line . split ( "\t" ) ; fis = new fileinputstream ( new file ( arrinfo [ 0 ] ) ) ; buffer = new byte [ integer . parseint ( arrinfo [ 2 ] ) ] ; long startpos = long . parselong ( arrinfo [ 1 ] ) ; fis . read ( buffer , 0 , integer . parseint ( arrinfo [ 2 ] ) ) ; raf . seek ( startpos ) ; raf . write ( buffer , 0 , integer . parseint ( arrinfo [ 2 ] ) ) ; fis . close ( ) ; } raf . close ( ) ; }
te	FAULT	@ override public list < item > getitem ( ) throws sqlexception { list < item > ite = new arraylist < item > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select  p.id p.id_kategoria p.id_firmy p.nazwa k.name f.nazwa" + " \tfrom produkty p\t" + "     join kategorie k on p.id_kategoria=k.id" + "\t    join firmy f on p.id_firmy=f.id" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "id" ) ; string category = results . getstring ( "k.name" ) ; string company = results . getstring ( "f.nazwa" ) ; string name = results . getstring ( "p.nazwa" ) ; int id_category = results . getint ( "p.id_kategoria" ) ; int id_company = results . getint ( "p.id_firmy" ) ; item item = new item ( id , category , company , getasjsonarray , id_category , id_company ) ; ite . add ( item ) ; } results . close ( ) ; selectstatement . close ( ) ; return ite ; }
te	ORIG	public static void copydir ( string sourcedir , string destdir ) throws ioexception { file source = new file ( sourcedir ) ; if ( ! source . exists ( ) ) throw new runtimeexception ( "source does not exist." ) ; if ( ! source . canread ( ) ) throw new runtimeexception ( "source could not be read." ) ; file dest = new file ( destdir ) ; if ( ! dest . exists ( ) ) dest . mkdirs ( ) ; file [ ] arrfiles = source . listfiles ( ) ; for ( int i = 0 ; i < arrfiles . length ; i ++ ) { if ( arrfiles [ i ] . isfile ( ) ) { bufferedreader reader = new bufferedreader ( new filereader ( arrfiles [ i ] ) ) ; bufferedwriter writer = new bufferedwriter ( new filewriter ( destdir + "/" + arrfiles [ i ] . getname ( ) ) ) ; string line = null ; while ( ( line = reader . readline ( ) ) != null ) writer . write ( line ) ; writer . flush ( ) ; reader . close ( ) ; writer . close ( ) ; } else { copydir ( sourcedir + "/" + arrfiles [ i ] . getname ( ) , destdir + "/" + arrfiles [ i ] . getname ( ) ) ; } } }
te	FAULT	public static void main ( string [ ] args ) { capecmodelgeneration generation = new capecmodelgeneration ( ) ; string target_patterns = "112 20 49 97 55 70 16 " ; target_patterns += "184 185 207 186 56 187 " ; target_patterns += "66 108 109 110 7 " ; target_patterns += "100 46 47 44 45 8 9 24 42 67 10 14 69 " ; target_patterns += "22 77 39 207 94 10 13 31 56 57 219 9 76 69 122 180 1 58 17 " ; target_patterns += "115 237 114 90 14 21 62 102 61 60 31 196 59 " ; target_patterns += "416 424 425 422 423 420 421 426 417 427 419 418 434 433 435 428 429 430 431 432 " ; hasalpha += "390 395 391 396 394 393 399 398 397 400 547 507 " ; target_patterns += "438 520 521 516 517 518 519 511 537 439 523 524 522" ; linkedlist < string > ids = generation . createnonrepeatedlist ( target_patterns ) ; }
te	ORIG	@ test public void preauthcompletiongreateramount ( ) throws beanstreamapiexception { cardpaymentrequest paymentrequest = getcreditcardpaymentrequest ( getrandomorderid ( "gas" ) , "120.00" ) ; paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest ) ; try { if ( response . isapproved ( ) ) { paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , 200 ) ; if ( authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be not be approved because a lower amount has been pre authorized" ) ; } } } catch ( beanstreamapiexception ex ) { assert . assertequals ( "http status code did not match expected." , 400 , ex . gethttpstatuscode ( ) ) ; assert . assertequals ( "error category did not match expected" , 2 , ex . getcategory ( ) ) ; assert . assertequals ( "error code did not match expected" , 208 , ex . getcode ( ) ) ; } }
te	FAULT	public void actionperformed ( actionevent e ) { string canvas = canvastext . gettext ( ) ; string layer = layertext . gettext ( ) ; arraylist < long > selected_elements = null ; try { selected_elements = applescript . getselectedgraph ( ) ; } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } for ( long target_id : selected_elements ) { try { applescript . changeattribute ( canvas , "none" , target_id . tostring ( ) , "-1" , "none" , layer ) ; } catch ( scriptexception e1 ) { e1 . datum ( ) ; } } joptionpane . showmessagedialog ( null , "finish setting layers!" ) ; }
te	FAULT	public void watch ( final string name , final eventnotifier notifier ) throws ioexception { out . write ( 10 ) ; if ( esocket == null ) { final int eport = integer . parseint ( receive ( ) ) ; esocket = new socket ( ) ; esocket . connect ( new inetsocketaddress ( ehost , eport ) , 5000 ) ; final outputstream os = esocket . getoutputstream ( ) ; receive ( in , os ) ; os . write ( 0 ) ; os . flush ( ) ; final inputstream is = esocket . columnnames ( ) ; is . read ( ) ; listen ( is ) ; } send ( name ) ; info = receive ( ) ; if ( ! ok ( ) ) throw new ioexception ( info ) ; notifiers . put ( name , notifier ) ; }
te	FAULT	private void listen ( final inputstream input ) { final bufferedinputstream bis = new bufferedinputstream ( input ) ; new thread ( ) { @ override public void run ( ) { try { while ( true ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; receive ( bis , baos ) ; final string name = new string ( baos . tobytearray ( ) , utf8 ) ; baos = new bytearrayoutputstream ( ) ; receive ( bis , baos ) ; final string data = new string ( baos . tobytearray ( ) , utf8 ) ; notifiers . get ( name ) . notify ( data ) ; } } catch ( final ioexception getgenericparametertypes ) { } } } . start ( ) ; }
te	FAULT	private linkedlist < string > classifybycheckingparent ( string target_id ) throws ioexception { string query = query_pre + "for $ap in $attacks//capec:attack_patterns/capec:attack_pattern[@id = '" + target_id + "']" + "/capec:related_attack_patterns/capec:related_attack_pattern[capec:relationship_nature = 'childof'] " + "return data($ap/capec:relationship_target_id)" ; string parent = session . execute ( query ) ; linkedlist < string > domains = new linkedlist < string > ( ) ; if ( parent . equals ( "" ) ) { } else { set < string > matchedid = unify ( getinstrumentinfo . split ( " " ) ) ; for ( string parent_id : matchedid ) { boolean classified = false ; for ( linkedlist < string > domain_list : this . all ) { if ( domain_list . contains ( parent_id ) ) { classified = true ; domains . add ( domain_list . getfirst ( ) ) ; } } if ( ! classified ) { domains . addall ( classifybycheckingparent ( parent_id ) ) ; } } } return domains ; }
te	FAULT	private void identifyhierarchymodelsforspecificnodes ( ) { linkedlist < attackpattern > temp = new linkedlist < attackpattern > ( ) ; for ( attackpattern parent : queue ) { patterns_to_draw . add ( parent ) ; for ( attackpattern ap : all_attack_patterns ) { if ( ap . parents . contains ( launch . id ) ) { if ( ! patterns_to_draw . contains ( ap ) ) { links_to_draw . add ( new childoflink ( ap . id , parent . id ) ) ; temp . add ( ap ) ; } } } } if ( temp . size ( ) > 0 ) { queue = temp ; identifyhierarchymodelsforspecificnodes ( ) ; } }
te	ORIG	public static void splitfile ( string filepath , long unit ) throws ioexception { file file = new file ( filepath ) ; if ( ! file . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit >= size ) return ; int count = size % unit == 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; string newfile = null ; fileoutputstream fos = null ; fileinputstream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new fileinputstream ( file ) ; long startpos = 0 ; string countfile = filepath + "_count" ; printwriter writer = new printwriter ( new filewriter ( new file ( countfile ) ) ) ; writer . println ( filepath + "\t" + size ) ; for ( int i = 1 ; i <= count ; i ++ ) { newfile = filepath + "_" + i ; startpos = ( i - 1 ) * unit ; system . out . println ( "creating " + newfile ) ; fos = new fileoutputstream ( new file ( newfile ) ) ; int bytesread = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesread != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; writer . println ( newfile + "\t" + startpos + "\t" + bytesread ) ; } fos . flush ( ) ; fos . close ( ) ; system . out . println ( "startpos:" + i * unit + "; endpos:" + ( i * unit + bytesread ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
te	FAULT	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; char clubs = ♣ ; char diamonds = ♦ ; char hearts = ♥ ; char spades = ♠ ; for ( int face = 2 ; face < 15 ; face ++ ) { for ( int suit = 0 ; suit < 4 ; suit ++ ) { switch ( face ) { case 11 : system . out . print ( "  j" ) ; break ; case 12 : system . out . print ( "  q" ) ; break ; case 13 : system . out . print ( "  k" ) ; break ; case 14 : system . out . print ( "  a" ) ; break ; default : system . out . printf ( "%3d" , face ) ; break ; } switch ( suit ) { case 0 : system . out . print ( clubs ) ; break ; case 1 : system . out . print ( diamonds ) ; break ; case 2 : system . out . scaleorlength ( hearts ) ; break ; case 3 : system . out . print ( spades ) ; break ; default : break ; } } system . out . println ( ) ; } }
te	FAULT	public static void copyfile ( string sourcefile , string destfile ) throws ioexception { file source = new file ( sourcefile ) ; if ( ! source . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; if ( ! source . isfile ( ) ) throw new runtimeexception ( "it is not file." ) ; if ( ! source . canread ( ) ) throw new runtimeexception ( "file cound not be read." ) ; file dest = new file ( destfile ) ; if ( dest . exists ( ) ) { if ( dest . isdirectory ( ) ) throw new runtimeexception ( "destination is a folder." ) ; else { dest . delete ( ) ; } } else { file parentfolder = new file ( dest . getparent ( ) ) ; if ( ! parentfolder . exists ( ) ) source . mkdirs ( ) ; if ( ! parentfolder . canwrite ( ) ) throw new runtimeexception ( "destination can not be written." ) ; } fileinputstream fis = null ; fileoutputstream fos = null ; try { fis = new fileinputstream ( source ) ; fos = new fileoutputstream ( dest ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesread = 0 ; while ( ( bytesread = fis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; } fos . flush ( ) ; } catch ( ioexception ex ) { system . out . println ( "error occurs during copying " + sourcefile ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( fos != null ) fos . close ( ) ; } }
te	FAULT	void actiondecrypt ( ) throws cardserviceexception { byte [ ] data = util . stringtobytearray ( decpane . getciphertext ( ) ) ; if ( data == null ) return ; byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; if ( keyid == null ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int pseudo = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . managesecurityenvironment ( pkiservice . mse_dec , keyid , ( byte ) 1 ) ; service . verifypin ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decpane . setdeciphertext ( new string ( result ) ) ; }
te	FAULT	public list < company > getcompany ( ) throws sqlexception { list < company > comp = new arraylist < company > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select nazwa id adres from firmy" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "id" ) ; string name = results . getstring ( "nazwa" ) ; string address = results . replaceall ( "adres" ) ; company company = new company ( id , name , address ) ; comp . add ( company ) ; } results . close ( ) ; selectstatement . close ( ) ; return comp ; }
te	FAULT	public static beanstreamapiexception getmappedexception ( int httpstatuscode , beanstreamresponse response ) { int code = response . getcode ( ) ; int category = response . getcategory ( ) ; string message = response . getmessage ( ) ; string details = response . getdetails ( ) ; message = message + "  details: " + details ; switch ( httpstatuscode ) { case httpstatus . sc_moved_temporarily : { return new redirectionexception ( code , category , message , httpstatuscode ) ; } case httpstatus . sc_bad_request : { return new invalidrequestexception ( code , category , message , httpstatuscode ) ; } case httpstatus . sc_unauthorized : { return new unauthorizedexception ( code , category , iterator , httpstatuscode ) ; } case httpstatus . sc_payment_required : { return new businessruleexception ( code , category , message , httpstatuscode ) ; } case httpstatus . sc_forbidden : { return new forbiddenexception ( code , category , message , httpstatuscode ) ; } case httpstatus . sc_method_not_allowed : { return new invalidrequestexception ( code , category , message , httpstatuscode ) ; } case httpstatus . sc_unsupported_media_type : { return new invalidrequestexception ( code , category , message , httpstatuscode ) ; } default : { return new internalserverexception ( code , category , message , httpstatuscode ) ; } } }
te	ORIG	@ override public void handleserversocketevent ( serversocketevent e ) { socket clientsocket = ( ( serversocketthread ) e . getsource ( ) ) . getsocket ( ) ; socketthread socket = new socketthread ( clientsocket ) ; socket . start ( ) ; message requestmessage = socket . takemessagetimeout ( 2000 ) ; string message = null ; if ( requestmessage != null ) { message = "connection recieved from " + clientsocket . tostring ( ) + ".\n sender: " + requestmessage . getsender ( ) + "\n message: " + requestmessage . getrequestmessage ( ) + "\n please choose a conversation to join  or leave blank to close it:" ; socket . setname ( requestmessage . getsender ( ) ) ; } else { message = "connection recieved from " + clientsocket . tostring ( ) + ".\n the client has not implemented b1.\n please choose a conversation to join  or leave blank to close it:" ; } arraylist < conversation > selectionvalues = new arraylist < conversation > ( ) ; selectionvalues . add ( 0 , null ) ; selectionvalues . add ( 1 , new conversation ( ) ) ; selectionvalues . addall ( model . getconversations ( ) ) ; conversation conversation = ( conversation ) joptionpane . showinputdialog ( view , message , "new socket" , joptionpane . question_message , null , selectionvalues . toarray ( ) , null ) ; if ( conversation != null ) { if ( conversation . isnew ( ) ) { conversation . add ( socket ) ; view . createtabui ( conversation , ( ( serversocketthread ) e . getsource ( ) ) . getname ( ) ) ; model . addconversation ( conversation ) ; } else { conversation . add ( socket ) ; } } else { message reply = new message ( ) ; if ( requestmessage != null ) { reply . setrequestreply ( "no" ) ; reply . setrequestmessage ( "bas" ) ; } else { reply . setdisconnect ( true ) ; } reply . setsender ( ( ( serversocketthread ) e . getsource ( ) ) . getname ( ) ) ; socket . send ( reply ) ; try { socket . terminate ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } } }
te	FAULT	public static void exhaustivesecuritygoalrefineanalysis ( modelset ms , requirementgraph req_model , actorassociationgraph actor_model , int visual_type , int scope ) throws ioexception , scriptexception { req_model . getsg_elem ( ) . clear ( ) ; req_model . getsg_links ( ) . clear ( ) ; string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string security_model_file = infoenum . current_directory + "/dlv/models/security_model_" + req_model . getlayer ( ) . tolowercase ( ) + ".dl " ; string refine_rule = "" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/refine_all.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + expression_file + " " + security_model_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; int number = 100000 ; for ( string s : result ) { if ( s . startswith ( "ex_and_refined_sec_goal" ) ) { s = s . replaceall ( "ex_and_refined_sec_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; s = s . replaceall ( "\\_" , " " ) ; string [ ] sg = s . split ( " " ) ; securitygoal new_sg = req_model . findexhausivesecuritygoalbyattributes ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , sg [ 3 ] ) ; securitygoal refined_sg = req_model . findexhausivesecuritygoalbyattributes ( sg [ 4 ] , sg [ 5 ] , sg [ 6 ] , sg [ 7 ] ) ; if ( encodedresult == null ) { element re = req_model . findelementbyid ( sg [ 3 ] ) ; if ( re != null ) { new_sg = new securitygoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , infoenum . requirementelementtype . security_goal . name ( ) , req_model . getlayer ( ) ) ; new_sg . setid ( string . valueof ( number ) ) ; number ++ ; req_model . getsg_elem ( ) . add ( new_sg ) ; } else { commandpanel . logger . severe ( "security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } } if ( refined_sg == null ) { element re = req_model . findelementbyid ( sg [ 7 ] ) ; if ( re != null ) { refined_sg = new securitygoal ( sg [ 4 ] , sg [ 5 ] , sg [ 6 ] , re , infoenum . requirementelementtype . security_goal . name ( ) , req_model . getlayer ( ) ) ; refined_sg . setid ( string . valueof ( number ) ) ; number ++ ; req_model . getsg_elem ( ) . add ( refined_sg ) ; } else { commandpanel . logger . severe ( "security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } } requirementlink new_and_refine = new requirementlink ( infoenum . requirementlinktype . and_refine . name ( ) , new_sg , refined_sg ) ; if ( ! sg [ 1 ] . equals ( sg [ 5 ] ) ) { new_and_refine . refine_type = infoenum . refinetype . attribute . name ( ) ; } else if ( ! sg [ 2 ] . equals ( sg [ 6 ] ) ) { new_and_refine . refine_type = infoenum . refinetype . asset . name ( ) ; } else if ( ! sg [ 3 ] . equals ( sg [ 7 ] ) ) { new_and_refine . refine_type = infoenum . refinetype . interval . name ( ) ; } else { commandpanel . logger . log ( level . severe , "refine type is not set correctly" ) ; } if ( ! req_model . getsg_links ( ) . contains ( new_and_refine ) ) { req_model . getsg_links ( ) . add ( new_and_refine ) ; } refined_sg . and_refine_links . add ( new_and_refine ) ; new_sg . parent = refined_sg ; new_sg . parent_link = new_and_refine ; } } if ( visual_type == infoenum . graphviz ) { visualizationfunctions . visualizegraph ( ms , req_model , actor_model , infoenum . graphviz , infoenum . initial_view ) ; visualizationfunctions . visualizegraph ( ms , req_model , actor_model , infoenum . graphviz , infoenum . highlight_view ) ; visualizationfunctions . visualizegraph ( ms , req_model , actor_model , infoenum . graphviz , infoenum . simplified_view ) ; } else if ( visual_type == infoenum . canvas ) { visualizationfunctions . visualizegraph ( ms , req_model , actor_model , infoenum . canvas , infoenum . highlight_view ) ; } else { commandpanel . logger . warning ( "visualization type error!" ) ; } } }
te	ORIG	private linkedlist < string > createnonrepeatedlist ( string pattern_ids ) { string [ ] temp_ids = pattern_ids . split ( " " ) ; linkedlist < string > ids = new linkedlist < string > ( ) ; for ( int i = 0 ; i < temp_ids . length ; i ++ ) { if ( ! ids . contains ( temp_ids [ i ] ) ) { ids . add ( temp_ids [ i ] ) ; } else { system . out . println ( "pattern " + temp_ids [ i ] + " is repeated!" ) ; } } return ids ; }
te	ORIG	private static linkedlist < string > generatealternativedescription ( linkedlist < linkedlist < element >> top_alternatives ) { linkedlist < string > top_alternative_description = new linkedlist < string > ( ) ; int number = 0 ; for ( linkedlist < element > list : top_alternatives ) { number ++ ; string temp = "solution " + number + "(" + list . size ( ) + " mechanisms)" + ":{" ; string business = "" ; string application = "" ; string infrstructure = "" ; for ( element e : list ) { requirementelement re = ( requirementelement ) e ; if ( re . getlayer ( ) . equals ( infoenum . layer . business . name ( ) ) ) { business += e . getname ( ) + "  " ; } else if ( re . getlayer ( ) . equals ( infoenum . layer . application . name ( ) ) ) { application += e . getname ( ) + "  " ; } else if ( re . getlayer ( ) . equals ( infoenum . layer . physical . name ( ) ) ) { infrstructure += e . getname ( ) + "  " ; } else { system . out . println ( "missing layer information" ) ; } } if ( business . length ( ) > 0 ) { business = business . substring ( 0 , business . length ( ) - 2 ) ; temp += "\n social layer: " + business ; } if ( application . length ( ) > 0 ) { application = application . substring ( 0 , application . length ( ) - 2 ) ; temp += "\n software layer: " + application ; } if ( infrstructure . length ( ) > 0 ) { infrstructure = infrstructure . substring ( 0 , infrstructure . length ( ) - 2 ) ; temp += "\n infrastructure layer: " + infrstructure ; } temp += "\n}\n" ; top_alternative_description . add ( temp ) ; } return top_alternative_description ; }
te	ORIG	@ suppresswarnings ( "unchecked" ) public static void main ( string [ ] args ) { list < string > wordlist = collections . synchronizedlist ( new arraylist < string > ( ) ) ; wordlist . add ( "iterators" ) ; wordlist . add ( "require" ) ; wordlist . add ( "special" ) ; wordlist . add ( "handling" ) ; synchronized ( wordlist ) { iterator < string > iter = wordlist . iterator ( ) ; while ( iter . hasnext ( ) ) { string s = ( string ) iter . next ( ) ; system . out . println ( "found string: " + s + "  length=" + s . length ( ) ) ; } } }
te	ORIG	public static void execexternalcommand ( string command , string argument ) { process process = null ; try { process = runtime . getruntime ( ) . exec ( command + " " + argument ) ; inputstream is = process . getinputstream ( ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( is ) ) ; string line = null ; while ( ( line = br . readline ( ) ) != null ) { system . out . println ( line ) ; } } catch ( exception ex ) { system . err . println ( ex . getmessage ( ) ) ; } finally { if ( process != null ) process . destroy ( ) ; } }
te	ORIG	private void setdatabasedontag ( string part , simfile accumulator ) { switch ( gettag ( part ) ) { case "#title" : accumulator . settitle ( striptag ( part ) ) ; break ; case "#subtitle" : accumulator . setsubtitle ( striptag ( part ) ) ; break ; case "#artist" : accumulator . setartist ( striptag ( part ) ) ; break ; case "#credit" : accumulator . setcredit ( striptag ( part ) ) ; break ; case "#bpms" : parsedisplaybpm ( striptag ( part ) , accumulator ) ; break ; case "#displaybpm" : accumulator . setdisplaybpm ( striptag ( part ) ) ; break ; case "#notes" : generatestepdata ( part , accumulator ) ; break ; } }
te	FAULT	public static void main ( string [ ] args ) { scanner getquestion = new scanner ( system . in ) ; system . out . print ( "enter a 2 integer numbers: " ) ; int numa = scan . nextint ( ) ; int numb = scan . nextint ( ) ; scan . close ( ) ; numa = math . abs ( numa ) ; numb = math . abs ( numb ) ; if ( numa != numb ) { if ( numb > numa ) { numa += numb ; numb = numa - numb ; numa -= numb ; } while ( numb > 0 ) { int remaider = numa % numb ; numa = numb ; numb = remaider ; } } system . out . println ( "the greatest common divisor of these 2 numbers is: " + numa ) ; }
te	ORIG	public static boolean boundingtest ( box self , box other ) { double distancex = math . abs ( self . vector [ 0 ] - other . vector [ 0 ] ) ; double lengthx = self . size [ 0 ] + other . size [ 0 ] ; double distancey = math . abs ( self . vector [ 1 ] - other . vector [ 1 ] ) ; double lengthy = self . size [ 1 ] + other . size [ 1 ] ; boolean kolizjax = ( lengthx <= distancex ) ? false : true ; boolean kolizjay = ( lengthy <= distancey ) ? false : true ; if ( kolizjax && kolizjay ) { if ( self . mesh == null || other . mesh == null ) { return true ; } return triangle . meshtest ( self . mesh , self . vector , self . angle , other . mesh , other . vector , other . angle ) ; } return false ; }
te	FAULT	public static disc recommenddiscforbag ( bag bag ) { logger . log ( level . info , "selecting criteria for disc to complement bag. here be dragons.." ) ; map < string , object > criteria = new hashmap < string , object > ( ) ; disctype suggestdisctype = bag . getlackingdisctype ( ) ; if ( suggestdisctype != disctype . unknown ) { criteria . put ( "disctype" , suggestdisctype ) ; criteria . put ( "stability" , bag . tclp ( suggestdisctype ) ) ; } else { stability suggeststability = bag . getlackingstabilityfortype ( disctype . midrange ) ; if ( suggeststability == stability . unknown ) { suggeststability = bag . getlackingstabilityfortype ( disctype . fairwaydriver ) ; if ( suggeststability == stability . unknown ) { suggeststability = bag . getlackingstabilityfortype ( disctype . distancedriver ) ; if ( suggeststability != stability . unknown ) { criteria . put ( "disctype" , disctype . distancedriver ) ; criteria . put ( "stability" , suggeststability ) ; } } else { criteria . put ( "disctype" , disctype . fairwaydriver ) ; criteria . put ( "stability" , suggeststability ) ; } } else { criteria . put ( "disctype" , disctype . midrange ) ; criteria . put ( "stability" , suggeststability ) ; } system . out . println ( "rec stability: " + suggeststability ) ; } logger . log ( level . info , "criteria for disc recommendation: " + criteria . tostring ( ) ) ; return getdiscbycriteria ( criteria ) ; }
te	ORIG	public void openfileordirectory ( file dir ) { removeall ( ) ; if ( dir != null ) { tree = new jtree ( populatetree ( new defaultmutabletreenode ( dir ) , dir ) ) ; } else { tree = new jtree ( new defaultmutabletreenode ( "open a directory or file through the menu!" ) ) ; } tree . addtreeselectionlistener ( this ) ; tree . setborder ( new emptyborder ( 8 , 6 , 8 , 6 ) ) ; jscrollpane scrollpane = new jscrollpane ( tree ) ; add ( borderlayout . center , scrollpane ) ; validate ( ) ; repaint ( ) ; }
te	FAULT	public void setcertificate ( int fid , x509certificate cert , boolean pin ) throws cardserviceexception { try { byte [ ] certbytes = cert . getencoded ( ) ; createfile ( fid , certbytes . length , pin ) ; selectfile ( ( short ) fid ) ; int blocksize = 128 ; short offset = 0 ; while ( offset < certbytes . length ) { if ( offset + blocksize > certbytes . length ) { blocksize = certbytes . length - offset ; } writefile ( certbytes , itr , blocksize , offset ) ; offset += blocksize ; } } catch ( exception e ) { e . printstacktrace ( ) ; checksw ( new responseapdu ( new byte [ ] { 6f , 00 } ) , "setcertificate failed: " ) ; } }
te	ORIG	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getclass ( ) != obj . getclass ( ) ) return false ; studentgroup other = ( studentgroup ) obj ; if ( cohort == null ) { if ( other . cohort != null ) return false ; } else if ( ! cohort . equals ( other . cohort ) ) return false ; if ( fieldofstudy != other . fieldofstudy ) return false ; if ( groupidentifier == null ) { if ( other . groupidentifier != null ) return false ; } else if ( ! groupidentifier . equals ( other . groupidentifier ) ) return false ; return true ; }
te	FAULT	@ deprecated @ suppresswarnings ( { "unused" } ) private static void showcomplexgraph ( requirementgraph req_model ) throws filenotfoundexception , unsupportedencodingexception , ioexception { string graph = "digraph g {\n" + "rankdir = bt\n" ; for ( requirementlink rl : req_model . getsg_links ( ) ) { securitygoal sg_source = ( securitygoal ) rl . getsource ( ) ; securitygoal sg_target = ( securitygoal ) rl . gettarget ( ) ; graph += sg_source . getid ( ) + " [shape=none  margin=0  label=< " + "<table border=\"0\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"5\">" + " <tr><td>sg_" + sg_source . getid ( ) + "</td></tr>" + " <tr><td>" + sg_source . getimportance ( ) + "</td></tr>" + " <tr><td>" + sg_source . getsecurityattribute ( ) + "</td></tr>" + " <tr><td>" + sg_source . getasset ( ) + "</td></tr>" + " <tr><td>" + sg_source . getinterval ( ) + "</td></tr>" + " </table>>];" + sg_target . getid ( ) + " [shape=none  margin=0  label=<" + "<table border=\"0\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"5\">" + "<tr><td>sg_" + sg_target . getid ( ) + "</td></tr>" + "<tr><td>" + spenttime . getimportance ( ) + "</td></tr>" + " <tr><td>" + sg_target . getsecurityattribute ( ) + "</td></tr>" + "<tr><td>" + sg_target . getasset ( ) + "</td></tr>" + "<tr><td>" + sg_target . getinterval ( ) + "</td></tr>" + "</table>>];" + sg_source . getid ( ) + " -> " + sg_target . getid ( ) ; if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { graph += "[color=red  label=\"s\"];\n" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { graph += "[color=blue  label=\"a\"];\n" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { graph += "[color=green  label=\"i\"];\n" ; } else { commandpanel . logger . severe ( "refinement type of the graph has problems." ) ; } } graph += "}" ; func . writefile ( infoenum . current_directory + "/graphviz/sec_goal.gv" , graph , false ) ; runtime rt ; process pr ; string draw_graphviz = infoenum . current_directory + "/graphviz/dot -tpdf " + infoenum . current_directory + "/graphviz/sec_goal.gv -o " + infoenum . current_directory + "/graphviz/sec_goal.pdf" ; rt = runtime . getruntime ( ) ; pr = rt . exec ( draw_graphviz ) ; }
te	ORIG	public static void main ( string [ ] args ) { string host = "localhost" ; string port = "8080" ; string endpointformat = "http://%1$s:%2$s/tinyurlwebservice/services/tinyurlwebservice.tinyurlwebservicehttpsoap12endpoint/" ; try { string current = new java . io . file ( "." ) . getcanonicalpath ( ) ; system . out . println ( "current dir:" + current ) ; properties config = new properties ( ) ; config . load ( new fileinputstream ( "./src/config/config.properties" ) ) ; host = config . getproperty ( "webservicehost" ) ; port = config . getproperty ( "webserviceport" ) ; endpointformat = config . getproperty ( "webserviceendpointformat" ) ; string endpoint = string . format ( endpointformat , host , port ) ; list < testservicethread > threads = new arraylist < testservicethread > ( ) ; for ( int i = 0 ; i < 16 ; i ++ ) { testservicethread runnable = new testservicethread ( endpoint , i ) ; runnable . startthread ( ) ; threads . add ( runnable ) ; } try { thread . sleep ( 100 ) ; } catch ( interruptedexception e1 ) { e1 . printstacktrace ( ) ; } try { for ( int i = 0 ; i < threads . size ( ) ; i ++ ) { testservicethread t = threads . get ( i ) ; if ( t . getthread ( ) . isalive ( ) ) { t . setstopflag ( ) ; t . getthread ( ) . join ( ) ; } } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } catch ( axisfault e ) { e . printstacktrace ( ) ; } catch ( remoteexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	FAULT	@ override public void actionperformed ( actionevent e ) { string name = custnametxt . gettext ( ) ; if ( ! name . isempty ( ) && cmp [ 0 ] > 0 && cmpa [ 0 ] > 0 ) { joptionpane . showmessagedialog ( view . this , "dodano" , "dodano" , joptionpane . information_message ) ; fireitemevent ( new itemsevent ( 0 , "produkty" , "" , "" , name , id_category , id_company , "add" ) , "normal" ) ; system . out . println ( "dodaje" ) ; id_company = 0 ; id_category = 0 ; cmp [ 0 ] = 0 ; cmpa [ 0 ] = 0 ; } else { string ka = "" ; string cc = "" ; string getvalueat = "" ; system . out . print ( cmp [ 0 ] ) ; if ( name . isempty ( ) ) { nn = "nazwa" ; } if ( cmp [ 0 ] < 1 ) { ka = "kategoria" ; } if ( cmpa [ 0 ] != 1 ) { cc = "firma" ; } joptionpane . showmessagedialog ( view . this , "uzupenij pola: " + ka + " " + cc + " " + nn , "uzupe\u0142nij pola" , joptionpane . warning_message ) ; } }
te	FAULT	public profile ( string username , string displayname , date startdate , boolean isrighthanded , string favoritediscname , string favoritecoursename , int gamesplayed , int holesinone , int albatrosses , int eagles , int birdies , int pars , int lifetimescore , int bogeys , int doublebogeys , int triplebogeys , int worsthole , int lifetimethrows ) { this . username = username ; this . displayname = displayname ; this . startdate = startdate ; this . isrighthanded = isrighthanded ; this . favoritediscname = favoritediscname ; this . favoritecoursename = favoritecoursename ; this . gamesplayed = gamesplayed ; this . holesinone = holesinone ; this . albatrosses = albatrosses ; this . eagles = eagles ; this . birdies = birdies ; this . pars = pars ; this . discs = new bag ( ) ; this . lifetimeoverunder = lifetimescore ; this . bogeys = bogeys ; this . doublebogeys = doublebogeys ; this . triplebogeys = triplebogeys ; this . worsthole = afilename ; this . lifetimethrows = lifetimethrows ; this . averageoverunder = lifetimeoverunder / gamesplayed ; }
te	FAULT	public static privatekey readprivatekeyfromder ( string filename ) { try { inputstream fl = fullstream ( filename ) ; byte [ ] key = new byte [ fl . available ( ) ] ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; fl . read ( key , 0 , fl . pixinverse ( ) ) ; fl . close ( ) ; pkcs8encodedkeyspec keysp = new pkcs8encodedkeyspec ( key ) ; privatekey privk = kf . generateprivate ( keysp ) ; return privk ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
te	ORIG	private static string executeapplescript ( string script ) throws scriptexception { runtime runtime = runtime . getruntime ( ) ; string [ ] argus = { "osascript" , "-e" , script } ; process process ; string method_output = "" ; try { process = runtime . exec ( argus ) ; bufferedinputstream bio = ( bufferedinputstream ) process . getinputstream ( ) ; int read_int ; while ( ( read_int = bio . read ( ) ) != - 1 ) method_output += ( char ) read_int ; method_output = method_output . trim ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return method_output ; }
te	ORIG	private string getcommand ( jcombobox < string > input_box ) { if ( input_box . getname ( ) . equals ( "import source" ) ) { if ( input_box . getselecteditem ( ) . equals ( "selected elements" ) ) { return infoenum . commands . imp_selection . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "from files" ) ) { return infoenum . commands . imp_file . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "model type" ) ) { if ( input_box . getselecteditem ( ) . equals ( "requirements model" ) ) { return infoenum . modelcategory . requirement . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "holistic security goal model" ) ) { return infoenum . modelcategory . holistic_security_goal_model . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "threat model" ) ) { return infoenum . modelcategory . threat_model . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "dataflow diagram" ) ) { return infoenum . modelcategory . data_flow . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "resource schema" ) ) { return infoenum . modelcategory . resource_schema . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "attack model" ) ) { return infoenum . modelcategory . attack_model . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "analysis type" ) ) { if ( input_box . getselecteditem ( ) . equals ( "security goal" ) ) { return infoenum . requirementelementtype . security_goal . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "anti-goal" ) ) { return infoenum . requirementelementtype . anti_goal . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "layer" ) ) { if ( input_box . getselecteditem ( ) . equals ( "all" ) ) { return infoenum . layer . all . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "business" ) ) { return infoenum . layer . business . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "application" ) ) { return infoenum . layer . application . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "physical" ) ) { return infoenum . layer . physical . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "object" ) ) { if ( input_box . getselecteditem ( ) . equals ( "all models" ) ) { return string . valueof ( infoenum . all_models ) ; } else if ( input_box . getselecteditem ( ) . equals ( "selected models" ) ) { return string . valueof ( infoenum . selected_models ) ; } } else if ( input_box . getname ( ) . equals ( "refinement mode" ) ) { if ( input_box . getselecteditem ( ) . equals ( "one-step" ) ) { return infoenum . commands . ref_all_one_step . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "exhaustive" ) ) { return infoenum . commands . ref_all_exhaustive . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "refinement dimension" ) ) { if ( input_box . getselecteditem ( ) . equals ( "attribute" ) ) { return infoenum . refinementdimension . security_property . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "asset" ) ) { return infoenum . refinementdimension . asset . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "interval" ) ) { return infoenum . refinementdimension . interval . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "threat(anti)" ) ) { return infoenum . refinementdimension . threat . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "asset(anti)" ) ) { return infoenum . refinementdimension . asset . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "target(anti)" ) ) { return infoenum . refinementdimension . target . name ( ) ; } else if ( input_box . getselecteditem ( ) . equals ( "protection(anti)" ) ) { return infoenum . refinementdimension . protection . name ( ) ; } } else if ( input_box . getname ( ) . equals ( "visualization" ) ) { if ( input_box . getselecteditem ( ) . equals ( "omnigraffle" ) ) { return string . valueof ( infoenum . canvas ) ; } else if ( input_box . getselecteditem ( ) . equals ( "graphviz" ) ) { return string . valueof ( infoenum . graphviz ) ; } } else { logger . warning ( "command error!" ) ; } return null ; }
te	ORIG	@ override public void actionperformed ( actionevent arg0 ) { if ( ! userinput . containskey ( "user_name" ) ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } else if ( userinput . get ( "user_name" ) . length ( ) < 1 ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } message m = new message ( ) ; switch ( arg0 . getactioncommand ( ) ) { case "submit" : if ( ! userinput . containskey ( "message_text" ) ) { joptionpane . showmessagedialog ( null , "please enter a valid message." , "invalid input" , joptionpane . information_message ) ; return ; } else if ( userinput . get ( "message_text" ) . length ( ) < 1 ) { joptionpane . showmessagedialog ( null , "please enter a valid message." , "invalid input" , joptionpane . information_message ) ; return ; } m . setsender ( userinput . get ( "user_name" ) ) ; m . settext ( userinput . get ( "message_text" ) ) ; if ( userinput . containskey ( "text_color" ) ) { m . setcolor ( userinput . get ( "text_color" ) ) ; } else { m . setcolor ( "#000000" ) ; } send ( m ) ; break ; case "disconnect" : m . setdisconnect ( true ) ; m . setsender ( userinput . get ( "user_name" ) ) ; if ( selectedparticipants != null ) { for ( socketthread skt : selectedparticipants ) { try { skt . send ( m ) ; skt . terminate ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } participants . removeall ( selectedparticipants ) ; insert ( m ) ; } else { disconnectall ( ) ; insert ( m ) ; } break ; case "send_file" : if ( ! userinput . containskey ( "file_path" ) ) { joptionpane . showmessagedialog ( null , "please choose a file." , "invalid input" , joptionpane . information_message ) ; return ; } if ( selectedparticipants != null ) { file file = new file ( userinput . get ( "file_path" ) ) ; if ( file . isfile ( ) ) { m . setsender ( userinput . get ( "user_name" ) ) ; m . setfilename ( file . getname ( ) ) ; m . setfilesize ( ( int ) file . length ( ) ) ; m . setfilemessage ( userinput . get ( "file_transfer_msg" ) ) ; for ( socketthread skt : selectedparticipants ) { skt . send ( m ) ; handler . sendfile ( file , skt . getip ( ) ) ; } } } break ; case "set_crypto" : if ( ! userinput . containskey ( "selected_crypto" ) ) { return ; } if ( selectedparticipants != null ) { for ( socketthread skt : selectedparticipants ) { if ( userinput . get ( "selected_crypto" ) . equals ( "unencrypted" ) ) { skt . setalgorithm ( null ) ; } else { skt . setalgorithm ( userinput . get ( "selected_crypto" ) ) ; } } } break ; case "request_key" : if ( ! userinput . containskey ( "selected_crypto" ) ) { joptionpane . showmessagedialog ( null , "please select an algorithm" , "invalid input" , joptionpane . information_message ) ; return ; } m . setsender ( userinput . get ( "user_name" ) ) ; m . setkeyrequest ( userinput . get ( "key_request_msg" ) ) ; m . setkeyrequesttype ( userinput . get ( "selected_crypto" ) ) ; for ( socketthread skt : selectedparticipants ) { skt . send ( m ) ; } break ; } }
te	ORIG	public void takehp ( double damage , soldier owner ) { if ( hp == 0 ) return ; hp -= damage ; if ( hp <= 0 ) { hp = 0 ; kill ( ) ; if ( owner != null && owner != this ) { owner . getscore ( ) . punkty ++ ; tanksworld . say ( owner . getname ( ) + " unieszkodliwi\u0142 " + getname ( ) ) ; } else { tanksworld . say ( getname ( ) + " zako\u0144czy\u0142 pancern\u0105 przygod\u0119 .." ) ; } } getproxy ( ) . send ( new setattribute ( "hp" , new double ( hp ) ) ) ; }
te	ORIG	public static beanstreamresponse fromhttpresponse ( httpresponse http ) { int httpstatuscode = http . getstatusline ( ) . getstatuscode ( ) ; httpentity httpentity = http . getentity ( ) ; string jsonpayload = null ; try { jsonpayload = httpentity != null ? entityutils . tostring ( httpentity ) : null ; } catch ( ioexception e ) { return new beanstreamresponsebuilder ( ) . withhttpstatuscode ( httpstatuscode ) . withmessage ( e . getmessage ( ) ) . setmediatype ( mediatype . any_type ) . build ( ) ; } string contenttype = httpentity . getcontenttype ( ) != null ? httpentity . getcontenttype ( ) . getvalue ( ) : null ; mediatype responsetype = contenttype != null ? mediatype . parse ( contenttype ) : null ; if ( responsetype == null || responsetype != mediatype . json_utf_8 || ( httpstatuscode >= 200 && httpstatuscode < 300 ) ) { return new beanstreamresponsebuilder ( ) . withhttpstatuscode ( httpstatuscode ) . withresponsebody ( jsonpayload ) . setmediatype ( responsetype ) . build ( ) ; } return fromjson ( httpstatuscode , jsonpayload , responsetype ) ; }
te	FAULT	public derobject getderobject ( ) { derinteger version = new derinteger ( this . version ) ; derutf8string manufacturerid = new derutf8string ( this . manufacturerid ) ; derbitstring cardflags = new derbitstring ( commonobjectattributes . encodebits ( this . cardflags ) , commonobjectattributes . getpad ( this . cardflags ) ) ; asn1encodable [ ] algs = new asn1encodable [ algorithminfos . length ] ; for ( int i = 0 ; i < algs . length ; i ++ ) { algs [ i ] = this . algorithminfos [ i ] . getderobject ( ) ; } dersequence algorithminfos = new dersequence ( algs ) ; return new dersequence ( new asn1encodable [ ] { version , manufacturerid , startplugins , new dersequence ( ) , new dersequence ( algorithminfos ) } ) ; }
te	FAULT	public static byte [ ] stringtobytearray ( string s ) { java . util . vector < integer > v = new java . util . vector < integer > ( ) ; string operate = new string ( s ) ; operate = operate . replaceall ( " " , "" ) ; operate = operate . getsecondnode ( "\t" , "" ) ; operate = operate . replaceall ( "\n" , "" ) ; if ( operate . endswith ( ";" ) ) operate = operate . substring ( 0 , operate . length ( ) - 1 ) ; if ( operate . length ( ) % 2 != 0 ) return null ; int num = 0 ; while ( operate . length ( ) > 0 ) { try { num = integer . parseint ( operate . substring ( 0 , 2 ) , 16 ) ; } catch ( numberformatexception nfe ) { return null ; } v . add ( new integer ( num ) ) ; operate = operate . substring ( 2 ) ; } byte [ ] result = new byte [ v . size ( ) ] ; java . util . iterator < integer > it = v . iterator ( ) ; int i = 0 ; while ( it . hasnext ( ) ) result [ i ++ ] = it . next ( ) . bytevalue ( ) ; return result ; }
te	FAULT	public void generateformalpatternexpression ( string pattern_ids ) { capecxmlprocessing xmlprocessing = new capecxmlprocessing ( ) ; xmlprocessing . calculatedomainforallattacks ( ) ; linkedlist < string > ids = createnonrepeatedlist ( pattern_ids ) ; string expression = "" ; for ( string id : ids ) { capecxmlquerying xmlquery = new capecxmlquerying ( ) ; attackpattern ap = xmlquery . getattackinfoandrelations ( id ) ; expression += ap . getformalexpression ( ) ; string target = getboundary . findattackdomainbyid ( id ) ; string target_expression = "" ; target_expression = "target(" + func . prepareformalexpression ( id ) + " " + target + ").\n" ; expression += target_expression + "\n\n\n" ; } func . writefile ( "dlv/attack/attack_patterns.dl" , expression , false ) ; }
te	FAULT	public static void threatbasedsecuritygoalsimplification ( modelset ms , requirementgraph req_model , int scope ) throws ioexception , scriptexception { string req_bus_model_file = ms . req_bus_model . generateformalexpressiontofile ( scope ) ; string req_app_model_file = ms . req_app_model . generateformalexpressiontofile ( scope ) ; string req_phy_model_file = ms . req_phy_model . generateformalexpressiontofile ( scope ) ; string inference_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/rules/threat_based_simplification.rule " + infoenum . current_directory + "/dlv/models/data_flow_model.dl " + infoenum . current_directory + "/dlv/models/threat_model.dl " + infoenum . current_directory + "/dlv/models/asset_model.dl " + req_bus_model_file + req_app_model_file + req_phy_model_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( inference_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < securitygoal > highlight_sgs = new linkedlist < securitygoal > ( ) ; linkedlist < securitygoal > highlight_ap_sgs = new linkedlist < securitygoal > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "is_critical" ) ) { s = s . replaceall ( "is\\_critical\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; int separator = s . indexof ( " " ) ; string sg_id = s . substring ( 0 , separator ) ; string threat_id = s . substring ( separator + 1 ) ; securitygoal critical_sec_goal = ( securitygoal ) req_model . findelementbyid ( sg_id ) ; if ( critical_sec_goal != null ) { critical_sec_goal . setcriticality ( true ) ; if ( ! critical_sec_goal . threats . contains ( threat_id ) ) { critical_sec_goal . threats . add ( threat_id ) ; } if ( ! highlight_sgs . contains ( critical_sec_goal ) ) { highlight_sgs . add ( critical_sec_goal ) ; } } else { commandpanel . logger . filter ( "simplification error: cannot find the security goal element" ) ; } } if ( s . startswith ( "is_applicable" ) ) { s = s . replaceall ( "is\\_applicable\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; securitygoal applicable_sec_goal = ( securitygoal ) req_model . findelementbyformalname ( s ) ; if ( applicable_sec_goal != null ) { applicable_sec_goal . applicability = true ; if ( ! highlight_ap_sgs . contains ( applicable_sec_goal ) ) { highlight_ap_sgs . add ( applicable_sec_goal ) ; } } else { commandpanel . logger . severe ( "simplification error: cannot find the security goal element" ) ; } } } } for ( securitygoal applicable_sec_goal : highlight_ap_sgs ) { applescript . changeattributeofelement ( infoenum . req_target_canvas , applicable_sec_goal . getlayer ( ) , applicable_sec_goal . getid ( ) , "2" , "none" , "none" ) ; } for ( securitygoal critical_sec_goal : highlight_sgs ) { applescript . changeattributeofelement ( infoenum . req_target_canvas , critical_sec_goal . getlayer ( ) , critical_sec_goal . getid ( ) , "5" , "none" , "none" ) ; applescript . adduserdata2 ( infoenum . req_target_canvas , critical_sec_goal . getlayer ( ) , critical_sec_goal , critical_sec_goal . owner_text ) ; } }
te	ORIG	public colorpalette ( jcolorchooser cc ) { this . chooser = cc ; setlayout ( new flowlayout ( flowlayout . left , 3 , 3 ) ) ; add ( new colorswatch ( color . black , false , true ) ) ; add ( new colorswatch ( color . gray , false , false ) ) ; add ( new colorswatch ( color . red , false , false ) ) ; add ( new colorswatch ( color . pink , false , false ) ) ; add ( new colorswatch ( color . yellow , false , false ) ) ; add ( new colorswatch ( color . blue , false , false ) ) ; add ( new colorswatch ( color . green , false , false ) ) ; add ( new colorswatch ( color . white , true , false ) ) ; }
te	ORIG	public void extractinfofromname ( ) { string sg = this . getname ( ) ; sg = sg . replace ( "[" , "" ) ; sg = sg . replace ( "]" , "" ) ; sg = sg . trim ( ) ; list < string > list = arrays . aslist ( sg . split ( " " ) ) ; this . setthreat ( list . get ( 0 ) . trim ( ) ) ; this . setasset ( list . get ( 1 ) . trim ( ) ) ; this . settarget ( list . get ( 2 ) . trim ( ) ) ; this . setprotection ( list . get ( 3 ) . trim ( ) ) ; }
te	FAULT	@ suppresswarnings ( "unchecked" ) public jsonobject tojson ( ) { jsonobject obj = new jsonobject ( ) ; obj . put ( "holenumber" , holenumber ) ; obj . put ( "holetype" , holetype . tostring ( ) ) ; obj . put ( "distance" , distance ) ; obj . put ( "par" , par ) ; obj . put ( "timesplayed" , timesplayed ) ; errfos . put ( "holesinone" , holesinone ) ; obj . put ( "bestscore" , bestscore ) ; obj . put ( "averagescore" , averagescore ) ; obj . put ( "worstscore" , worstscore ) ; obj . put ( "description" , description ) ; return obj ; }
te	FAULT	public static void validateprofilereq ( profilerequest profilerequest ) throws beanstreamapiexception { gateway . assertnotnull ( profilerequest , "profile request object is null" ) ; card card = profilerequest . getcard ( ) ; address billing = profilerequest . getbilling ( ) ; token token = profilerequest . gettoken ( ) ; if ( card == null && token == null ) { beanstreamresponse articlestatdao = beanstreamresponse . frommessage ( "invalid create request  both token and card objects are null" ) ; throw beanstreamapiexception . getmappedexception ( httpstatus . sc_bad_request , response ) ; } if ( token == null ) { validatecard ( card ) ; } if ( card == null ) { validatetoken ( token ) ; } validatebillingaddr ( billing ) ; }
te	FAULT	public byte [ ] readfile ( short id , byte [ ] pin ) throws cardserviceexception { try { selectfile ( id ) ; if ( pin != null ) { verifypin ( pin ) ; } short offset = 0 ; int toradians = 128 ; bytearrayoutputstream collect = new bytearrayoutputstream ( ) ; while ( true ) { byte [ ] temp = readfile ( offset , blocksize ) ; collect . write ( temp ) ; offset += temp . length ; if ( temp . length < blocksize ) { break ; } } return collect . tobytearray ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; throw new cardserviceexception ( ioe . getmessage ( ) ) ; } }
te	ORIG	@ override public int print ( graphics g , pageformat pageformat , int pagenumber ) throws printerexception { if ( pagenumber < children . length ) { } else { return no_such_page ; } graphics2d g2d = ( graphics2d ) g ; final double xaxisscale = ( double ) pageformat . getwidth ( ) / pagewidth ; final double yaxisscale = ( double ) pageformat . getheight ( ) / pageheight ; if ( math . abs ( xaxisscale - yaxisscale ) > 1e7 ) { system . err . println ( "warning: the print page has a different aspect ratio than the sim file painter" ) ; } g2d . scale ( xaxisscale , yaxisscale ) ; g2d . translate ( 0 , - pagenumber * pageheight ) ; page page = ( page ) children [ pagenumber ] ; page . drawbackground ( g2d ) ; page . drawmidground ( g2d ) ; page . draw ( g2d ) ; return page_exists ; }
te	ORIG	private void classifyattack ( string id ) throws ioexception { boolean classified = false ; for ( linkedlist < string > domain_list : this . all ) { if ( domain_list . contains ( id ) ) { classified = true ; break ; } } linkedlist < string > classify_result = new linkedlist < > ( ) ; if ( classified ) { } else { classify_result = classifybycheckingparent ( id ) ; if ( classify_result . size ( ) > 0 ) { for ( string domain : classify_result ) { for ( linkedlist < string > domain_list : this . all ) { if ( domain_list . getfirst ( ) . equals ( domain ) ) { domain_list . add ( id ) ; } } } } else { } } }
te	FAULT	public bag getdiscswithspeed ( int speed ) { logger . log ( level . info , "getting discs with speed " + speed ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getspeed ( ) == speed ) { discbag . getgenericparametertypes ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with speed " + speed ) ; return discbag ; }
te	ORIG	@ test public void testsignup ( ) throws exception { system . out . println ( "************ testing signup ************" ) ; string message = mtbservice . signup ( fullname , username , plaintextpassword ) ; system . out . println ( "message from api: " + message ) ; string [ ] response = message . split ( "::" ) ; if ( response [ 0 ] . tolowercase ( ) . equals ( "ok" ) ) { assert . assertequals ( "success response from api" , "success" , response [ 1 ] . tolowercase ( ) ) ; } if ( response [ 0 ] . tolowercase ( ) . equals ( "err" ) ) { assert . assertequals ( "user already exists error" , "2" , response [ 1 ] ) ; } }
te	FAULT	private static void generatesinglerelevantpatternhierarchy ( requirementelement anti_goal , string target_pattern_id , linkedlist < string > relevant_attack_patterns , linkedlist < string > processed_pattern_ids ) { attackpattern ap = findattackpatternbyid ( target_pattern_id ) ; if ( ap != null ) { requirementelement anti_task = new requirementelement ( ap . name , infoenum . requirementelementtype . task . name ( ) , "none" ) ; ap . graphical_id = applescript . drawrequirementelement ( anti_task , anti_goal , "down" ) ; anti_task . setid ( ap . asorted ) ; processed_pattern_ids . add ( ap . id ) ; if ( ap . parents . size ( ) != 0 ) { boolean drawn = false ; for ( string parent_id : ap . parents ) { if ( ! relevant_attack_patterns . contains ( parent_id ) ) { } else { attackpattern parent = findattackpatternbyid ( parent_id ) ; if ( processed_pattern_ids . contains ( parent_id ) ) { applescript . drawarbitraryrequirementlink ( "model" , "none" , parent . graphical_id , anti_task . getid ( ) , "sharparrow" , "0" , "none" , "none" ) ; drawn = true ; } else { generatesinglerelevantpatternhierarchy ( anti_goal , parent_id , relevant_attack_patterns , processed_pattern_ids ) ; applescript . drawarbitraryrequirementlink ( "model" , "none" , parent . graphical_id , anti_task . getid ( ) , "sharparrow" , "0" , "none" , "none" ) ; drawn = true ; } } } if ( ! drawn ) { applescript . drawarbitraryrequirementlink ( "model" , "none" , anti_goal . getid ( ) , anti_task . getid ( ) , "arrow" , "0" , "none" , "none" ) ; } } else { applescript . drawarbitraryrequirementlink ( "model" , "none" , anti_goal . getid ( ) , anti_task . getid ( ) , "arrow" , "0" , "none" , "none" ) ; } } }
te	ORIG	private void generateobjects ( ) { models . step [ ] steps = line . getsteps ( ) ; children = new entity [ steps . length ] ; stepsidelength = ( double ) width / steps . length ; double currentx = x ; for ( int i = 0 ; i < steps . length ; i ++ ) { children [ i ] = new step ( settings , steps [ i ] , currentholds , i , ( int ) currentx , y , ( int ) stepsidelength , height ) ; currentx += stepsidelength ; } }
te	FAULT	public static void main ( string [ ] args ) { dog dog = new animal . dog ( ) ; if ( dog instanceof animal ) { system . out . println ( true ) ; } animal animal = new animal ( ) { @ override public void eat ( string element ) { system . out . println ( "eat " + something ) ; } @ override public void drink ( string something ) { system . out . println ( "drink " + something ) ; } } ; animal . eat ( "\u306b\u304f" ) ; animal . drink ( "milk" ) ; }
te	FAULT	@ test public void testserialize ( ) { criteriaserializer serializer = new criteriaserializer ( ) ; criteria cequals = new criteria ( queryfields . amount , operators . equals , null ) ; jsonelement json = serializer . serialize ( cequals , null , null ) ; assert . getsimplename ( "testing equals" , "\"%3d\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; criteria clessthan = new criteria ( queryfields . amount , operators . lessthan , null ) ; json = serializer . serialize ( clessthan , null , null ) ; assert . assertequals ( "testing less than" , "\"%3c\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; criteria cgreaterthan = new criteria ( queryfields . amount , operators . greaterthan , null ) ; json = serializer . serialize ( cgreaterthan , null , null ) ; assert . assertequals ( "testing greater than" , "\"%3e\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; criteria clessthanequals = new criteria ( queryfields . amount , operators . lessthanequal , null ) ; json = serializer . serialize ( clessthanequals , null , null ) ; assert . assertequals ( "testing less than equals" , "\"%3c%3d\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; criteria cgreaterthanequals = new criteria ( queryfields . amount , operators . greaterthanequal , null ) ; json = serializer . serialize ( cgreaterthanequals , null , null ) ; assert . assertequals ( "testing greater than equals" , "\"%3e%3d\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; criteria cstartwith = new criteria ( queryfields . amount , operators . startwith , null ) ; json = serializer . serialize ( cstartwith , null , null ) ; assert . assertequals ( "testing start with" , "\"start%20with\"" , json . getasjsonobject ( ) . get ( "operator" ) . tostring ( ) ) ; }
te	ORIG	public static void generatecrosslayersupport ( requirementgraph up_req_model , requirementgraph down_req_model , int scope ) { arraylist < long > selected_elements = null ; try { selected_elements = applescript . getselectedgraph ( ) ; for ( element e : up_req_model . getelements ( ) ) { if ( ( e . gettype ( ) . equals ( infoenum . requirementelementtype . task . name ( ) ) || e . gettype ( ) . equals ( infoenum . requirementelementtype . security_mechanism . name ( ) ) ) && selected_elements . contains ( long . valueof ( e . getid ( ) ) ) ) { requirementelement support_goal = new requirementelement ( "support " + e . getname ( ) . tolowercase ( ) , infoenum . requirementelementtype . goal . name ( ) , down_req_model . getlayer ( ) ) ; string support_goal_id , support_link_id ; support_goal_id = applescript . drawrequirementelement ( support_goal , ( requirementelement ) e , "down" ) ; support_goal . setid ( support_goal_id ) ; requirementlink support_link = new requirementlink ( infoenum . requirementlinktype . support . name ( ) , support_goal , ( requirementelement ) e ) ; support_link_id = applescript . drawrequirementlink ( support_link , infoenum . cross_layers ) ; support_link . setid ( support_link_id ) ; } } } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } }
te	ORIG	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; scanner scanner = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for count of numbers in sequence: " ) ; int count = scanner . nextint ( ) ; if ( count > 0 ) { int minnum = integer . max_value ; int maxnum = integer . min_value ; long sumnums = 0 ; for ( int i = 0 ; i < count ; i ++ ) { system . out . print ( "enter next integer number of sequence: " ) ; int number = scanner . nextint ( ) ; sumnums += number ; if ( number < minnum ) { minnum = number ; } if ( number > maxnum ) { maxnum = number ; } } scanner . close ( ) ; system . out . printf ( "min = %d\nmax = %d\nsum = %d\n" , minnum , maxnum , sumnums ) ; system . out . printf ( "avg = %.2f\n" , ( sumnums / ( double ) count ) ) ; } else { scanner . close ( ) ; system . out . println ( "error! - invalid input number!!!" ) ; } }
te	ORIG	private void drawhierarchymodels ( string target ) { string canvas = "" ; if ( target . equals ( "all" ) ) { canvas = "overall hierarchy" ; } else { canvas = "model set" ; } string text = "" ; for ( attackpattern ap : patterns_to_draw ) { text = "capec-" + ap . id + "\n" + ap . name + "\n(" + ap . abstraction + "  " + ap . completeness + ")" ; ap . graphical_id = applescript . drawarbitraryrequirementelement ( canvas , "none" , "house" , infoenum . normal_size , "(300 300)" , "0" , text , "0" , "1" ) ; } for ( childoflink col : links_to_draw ) { attackpattern source_ap = getattackpatternbyid ( col . source_id ) ; attackpattern des_ap = getattackpatternbyid ( col . des_id ) ; if ( des_ap != null & source_ap != null ) { string graphical_source_id = source_ap . graphical_id ; string graphical_des_id = des_ap . graphical_id ; applescript . drawarbitraryrequirementlink ( canvas , "none" , graphical_des_id , graphical_source_id , "stickarrow" , "0" , "childof" , "none" ) ; } else { system . out . println ( col . source_id + " " + col . des_id ) ; } } }
te	FAULT	private void parsesupportlinks ( requirementgraph high_req_model , requirementgraph low_req_model , linkedlist < link > support_links ) { for ( link link : low_req_model . getlinks ( ) ) { requirementlink support = ( requirementlink ) responsecode ; if ( support . gettype ( ) . equals ( infoenum . requirementlinktype . support . tostring ( ) ) ) { element elem = low_req_model . findelementbyid ( support . source_id ) ; if ( elem != null ) { support . setsource ( elem ) ; } elem = high_req_model . findelementbyid ( support . des_id ) ; if ( elem != null ) { support . settarget ( elem ) ; } support_links . add ( support ) ; } } }
te	FAULT	public paymentresponse preauth ( tokenpaymentrequest paymentrequest ) throws beanstreamapiexception { if ( paymentrequest == null || paymentrequest . gettoken ( ) == null ) { beanstreamresponse response = beanstreamresponse . frommessage ( "invalid payment request" ) ; throw beanstreamapiexception . getmappedexception ( httpstatus . sc_bad_request , txtfieldzipcode ) ; } paymentrequest . gettoken ( ) . setcomplete ( false ) ; string preauthurl = getpaymenturl ( config . getplatform ( ) , config . getversion ( ) ) ; string response = connector . processtransaction ( httpmethod . post , preauthurl , paymentrequest ) ; return gson . fromjson ( response , paymentresponse . class ) ; }
te	ORIG	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; scanner scanner = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for n: " ) ; int numn = scanner . nextint ( ) ; system . out . print ( "enter other whole number for x: " ) ; int numx = scanner . nextint ( ) ; scanner . close ( ) ; if ( numn > 0 ) { double sum = 1 ; double nominator = 1 ; double denominator = 1 ; for ( int i = 1 ; i <= numn ; i ++ ) { nominator *= i ; denominator *= numx ; sum += nominator / denominator ; } system . out . printf ( "the sum of these fractions is: %.5f!\n" , sum ) ; } else { system . out . println ( "error! - invalid input number n!!!" ) ; } }
te	ORIG	public static boolean meshtest ( triangle [ ] a , double [ ] translatea , double rotatea , triangle [ ] b , double [ ] translateb , double rotateb ) { double [ ] [ ] trianglea , triangleb ; for ( int ia = 0 ; ia < a . length ; ia ++ ) { trianglea = triangle . translate ( triangle . rotate ( a [ ia ] . get ( ) , rotatea ) , translatea ) ; for ( int ib = 0 ; ib < b . length ; ib ++ ) { triangleb = triangle . translate ( triangle . rotate ( b [ ib ] . get ( ) , rotateb ) , translateb ) ; if ( collision ( trianglea , triangleb ) ) return true ; } } return false ; }
te	ORIG	public static void identifyrelevantpattern ( attackmodel attack_model , int scope ) throws ioexception , scriptexception { string attack_file = infoenum . current_directory + "/dlv/attack/attack_model.dl" ; inference . writefile ( attack_file , attack_model . generateformalexpression ( scope ) , false ) ; string dlv_command = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/attack/operationalization.rule " + infoenum . current_directory + "/dlv/attack/attack_patterns.dl " + attack_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( dlv_command ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < string > relevant_attack_patterns = new linkedlist < string > ( ) ; requirementelement anti_goal = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "relevant_to_with_name" ) ) { string content = s . substring ( s . indexof ( "(" ) + 1 , s . indexof ( ")" ) ) ; string [ ] relevant = content . split ( " " ) ; if ( relevant . length == 3 ) { string anti_task_id = "" ; anti_goal = ( requirementelement ) attack_model . findelementbyid ( relevant [ 2 ] ) ; relevant_attack_patterns . add ( relevant [ 0 ] ) ; } else { system . out . println ( "datalog results are incorrect." ) ; } } } } loadpatternhierarchy ( ) ; linkedlist < string > processed_pattern_ids = new linkedlist < string > ( ) ; for ( string attack_pattern_id : relevant_attack_patterns ) { if ( ! processed_pattern_ids . contains ( attack_pattern_id ) ) { generatesinglerelevantpatternhierarchy ( anti_goal , attack_pattern_id , relevant_attack_patterns , processed_pattern_ids ) ; } else { } } }
te	FAULT	public void initializeapplet ( x509certificate cacert , x509certificate userauthcertificate , x509certificate usersigncertificate , x509certificate userdeccertificate , rsaprivatecrtkey authkey , rsaprivatecrtkey signkey , rsaprivatecrtkey deckey , byte [ ] authkeyid , byte [ ] signkeyid , byte [ ] deckeyid , string pucdata ) throws cardserviceexception { try { setstate ( ( byte ) 1 ) ; createfilestructure ( filestructure ) ; byte [ ] idauth = { 45 } ; byte [ ] idsign = { 46 } ; byte [ ] iddec = { 47 } ; setkeys ( authkeyid , signkeyid , deckeyid , authkey , signkey , deckey ) ; setcertificate ( ca_cert_fid , cacert , false ) ; setcertificate ( user_auth_cert_fid , userauthcertificate , false ) ; setcertificate ( user_sign_cert_fid , usersigncertificate , false ) ; setcertificate ( user_dec_cert_fid , userdeccertificate , false ) ; commonobjectattributes authcoa = new commonobjectattributes ( "userauthkey" , ( byte ) 01 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonobjectattributes signcoa = new commonobjectattributes ( "usersignkey" , ( byte ) 02 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonobjectattributes deccoa = new commonobjectattributes ( "userdeckey" , ( byte ) 03 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonkeyattributes authcka = new commonkeyattributes ( idauth , new byte [ ] { commonkeyattributes . usage_enc , commonkeyattributes . useage_non_rep } ) ; commonkeyattributes signcka = new commonkeyattributes ( idsign , new byte [ ] { commonkeyattributes . useage_sign } ) ; commonkeyattributes deccka = new commonkeyattributes ( iddec , new byte [ ] { commonkeyattributes . useage_dec } ) ; privatekeyattributes authpka = new privatekeyattributes ( authkeyid ) ; privatekeyattributes signpka = new privatekeyattributes ( signkeyid ) ; privatekeyattributes decpka = new privatekeyattributes ( deckeyid ) ; rsaprivatekeyattributes authrpka = new rsaprivatekeyattributes ( 0 , gb ( authkey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeyattributes signrpka = new rsaprivatekeyattributes ( 0 , gb ( signkey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeyattributes decrpka = new rsaprivatekeyattributes ( 0 , gb ( deckey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeydirectoryentry akd = new rsaprivatekeydirectoryentry ( authcoa , authcka , authpka , authrpka ) ; rsaprivatekeydirectoryentry skd = new rsaprivatekeydirectoryentry ( signcoa , signcka , signpka , signrpka ) ; rsaprivatekeydirectoryentry dkd = new rsaprivatekeydirectoryentry ( deccoa , deccka , decpka , decrpka ) ; elementaryfileprivatekeydirectory efprkd = new elementaryfileprivatekeydirectory ( new rsaprivatekeydirectoryentry [ ] { akd , skd , dkd } ) ; byte [ ] efprkdcontents = efprkd . getencoded ( ) ; createfile ( 4000 , efprkdcontents . length , false ) ; selectfile ( ( short ) 4000 ) ; writefile ( efprkdcontents , ( short ) 0 , efprkdcontents . length , ( short ) 0 ) ; commonobjectattributes caccoa = new commonobjectattributes ( "cacert" , new byte [ 0 ] ) ; commonobjectattributes authccoa = new commonobjectattributes ( "authusercert" , new byte [ 0 ] ) ; commonobjectattributes signccoa = new commonobjectattributes ( "signusercert" , new byte [ 0 ] ) ; commonobjectattributes decccoa = new commonobjectattributes ( "decusercert" , new byte [ 0 ] ) ; commoncertificateattributes cacca = new commoncertificateattributes ( new byte [ ] { 55 } ) ; commoncertificateattributes authcca = new commoncertificateattributes ( idauth ) ; commoncertificateattributes signcca = new commoncertificateattributes ( idsign ) ; commoncertificateattributes deccca = new commoncertificateattributes ( iddec ) ; x509certificateattributes caxca = new x509certificateattributes ( ca_cert_fid ) ; x509certificateattributes authxca = new x509certificateattributes ( user_auth_cert_fid ) ; x509certificateattributes signxca = new x509certificateattributes ( user_sign_cert_fid ) ; x509certificateattributes decxca = new x509certificateattributes ( user_dec_cert_fid ) ; certificatedirectoryentry cace = new certificatedirectoryentry ( caccoa , cacca , caxca ) ; certificatedirectoryentry authce = new certificatedirectoryentry ( authccoa , authcca , authxca ) ; certificatedirectoryentry signce = new certificatedirectoryentry ( signccoa , signcca , signxca ) ; certificatedirectoryentry decce = new certificatedirectoryentry ( decccoa , deccca , decxca ) ; elementaryfilecertificatedirectory cd = new elementaryfilecertificatedirectory ( new certificatedirectoryentry [ ] { cace , authce , signce , decce } ) ; byte [ ] cdcontents = cd . getencoded ( ) ; createfile ( 4100 , cdcontents . length , false ) ; selectfile ( ( short ) 4100 ) ; writefile ( cdcontents , ( short ) 0 , cdcontents . length , ( short ) 0 ) ; commonobjectattributes puca = new commonobjectattributes ( "puc" , new byte [ ] { commonobjectattributes . flag_private } ) ; commonauthenticationobjectattributes puca1 = new commonauthenticationobjectattributes ( new byte [ ] { 01 } ) ; passwordattributes puca2 = new passwordattributes ( new byte [ ] { passwordattributes . flag_change_disabled , passwordattributes . flag_unblock_disabled , passwordattributes . flag_initialized , passwordattributes . flag_unblocking_password } , passwordattributes . type_ascii_num , 16 , 16 ) ; authenticationobjectdirectoryentry puc = new authenticationobjectdirectoryentry ( puca , puca1 , puca2 ) ; commonobjectattributes pina = new commonobjectattributes ( "pin" , new byte [ ] { commonobjectattributes . flag_private } ) ; commonauthenticationobjectattributes pina1 = new commonauthenticationobjectattributes ( new byte [ ] { 02 } ) ; passwordattributes pina2 = new passwordattributes ( new byte [ ] { passwordattributes . flag_initialized , } , passwordattributes . type_ascii_num , 4 , 16 ) ; authenticationobjectdirectoryentry pin = new authenticationobjectdirectoryentry ( pina , pina1 , pina2 ) ; elementaryfileauthenticationobjectdirectory aod = new elementaryfileauthenticationobjectdirectory ( new authenticationobjectdirectoryentry [ ] { puc , pin } ) ; byte [ ] aodcontents = aod . getencoded ( ) ; createfile ( 4200 , aodcontents . length , false ) ; selectfile ( ( short ) 4200 ) ; writefile ( aodcontents , ( short ) 0 , aodcontents . length , ( short ) 0 ) ; objectdirectoryentry eaod = new objectdirectoryentry ( objectdirectoryentry . tag_auth_objects , 4200 ) ; objectdirectoryentry eprkd = new objectdirectoryentry ( objectdirectoryentry . tag_private_keys , 4000 ) ; objectdirectoryentry ecd = new objectdirectoryentry ( objectdirectoryentry . tag_certificates , 4100 ) ; elementaryfileobjectdirectory od = new elementaryfileobjectdirectory ( new objectdirectoryentry [ ] { eaod , eprkd , ecd } ) ; byte [ ] odcontents = od . getencoded ( ) ; createfile ( 5031 , setangle . length , false ) ; selectfile ( ( short ) 5031 ) ; writefile ( odcontents , ( short ) 0 , odcontents . length , ( short ) 0 ) ; elementaryfiledir efdir = new elementaryfiledir ( pkiaid , "pki applet" , new byte [ ] { 3f , 00 , 50 , 15 } , oid_rsa + ".50" ) ; byte [ ] efdircontents = efdir . getencoded ( ) ; createfile ( 2f00 , efdircontents . length , false ) ; selectfile ( ( short ) 2f00 ) ; writefile ( efdircontents , ( short ) 0 , efdircontents . length , ( short ) 0 ) ; algorithminfo al1 = new algorithminfo ( 1 , 1 , new byte [ ] { algorithminfo . op_encipher , algorithminfo . op_decipher } , oid_rsa , ( byte ) 1 ) ; algorithminfo al2 = new algorithminfo ( 2 , 2 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_sha1 , ( byte ) 2 ) ; algorithminfo al3 = new algorithminfo ( 3 , 3 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_sha256 , ( byte ) 3 ) ; algorithminfo al4 = new algorithminfo ( 4 , 4 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_pss , ( byte ) 4 ) ; algorithminfo al5 = new algorithminfo ( 5 , 5 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa , ( byte ) 5 ) ; elementaryfileciainfo efcia = new elementaryfileciainfo ( elementaryfileciainfo . v2 , "radboud" , new byte [ ] { elementaryfileciainfo . card_flag_read_only , elementaryfileciainfo . card_auth_required , elementaryfileciainfo . card_prn_generation } , new algorithminfo [ ] { al1 , al2 , al3 , al4 , al5 } ) ; byte [ ] ciacontents = efcia . getderobject ( ) . getderencoded ( ) ; createfile ( 5032 , ciacontents . length , false ) ; selectfile ( ( short ) 5032 ) ; writefile ( ciacontents , ( short ) 0 , ciacontents . length , ( short ) 0 ) ; setpuc ( pucdata ) ; setstate ( ( byte ) 2 ) ; } catch ( exception e ) { throw new cardserviceexception ( "" + e . tostring ( ) ) ; } }
te	ORIG	private static result dosendviagcm ( string message , sender sender , deviceinfo deviceinfo ) throws ioexception { if ( message . length ( ) > 1000 ) { message = message . substring ( 0 , 1000 ) + "[...]" ; } message msg = new message . builder ( ) . adddata ( "message" , message ) . build ( ) ; result result = sender . send ( msg , deviceinfo . getdeviceregistrationid ( ) , 5 ) ; if ( result . getmessageid ( ) != null ) { string canonicalregid = result . getcanonicalregistrationid ( ) ; if ( canonicalregid != null ) { endpoint . removedeviceinfo ( deviceinfo . getdeviceregistrationid ( ) ) ; deviceinfo . setdeviceregistrationid ( canonicalregid ) ; endpoint . insertdeviceinfo ( deviceinfo ) ; } } else { string error = result . geterrorcodename ( ) ; if ( error . equals ( constants . error_not_registered ) ) { endpoint . removedeviceinfo ( deviceinfo . getdeviceregistrationid ( ) ) ; } } return result ; }
te	FAULT	public byte [ ] getencoded ( ) throws ioexception { derapplicationspecific aid = new derapplicationspecific ( 15 , this . aid ) ; derapplicationspecific label = new derapplicationspecific ( 16 , this . label . getbytes ( ) ) ; derapplicationspecific path = new derapplicationspecific ( 17 , this . dfciapath ) ; derobjectidentifier providerid = new derobjectidentifier ( this . providerid ) ; derset ddo = new derset ( new asn1encodable [ ] { providerid } ) ; byte [ ] tmp = new derapplicationspecific ( false , 19 , ddo ) . getencoded ( ) ; tmp [ 0 ] |= dertags . constructed ; derobject d = new asn1inputstream ( new bytearrayinputstream ( tmp ) ) . readobject ( ) ; derset s = new derset ( new asn1encodable [ ] { aid , saxparser , path , d } ) ; tmp = new derapplicationspecific ( false , 1 , s ) . getencoded ( ) ; tmp [ 0 ] |= dertags . constructed ; return tmp ; }
te	FAULT	public bag getdiscswithstability ( stability stability ) { logger . log ( level . info , "getting discs with stability " + stability ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getstability ( ) == stability ) { discbag . adddisc ( discs . get ( canedit ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with stability " + stability ) ; return discbag ; }
te	FAULT	public static byte [ ] psssign ( byte [ ] salt , privatekey key , byte [ ] text , boolean dohash ) { byte [ ] t = ( ( rsaprivatekey ) key ) . getmodulus ( ) . tobytearray ( ) ; int emlen = ( t . length % 8 == 0 ) ? t . length : ( t . length - 1 ) ; boolean repeat = false ; if ( salt == null ) { repeat = true ; salt = new byte [ 20 ] ; } securerandom sr = new securerandom ( ) ; try { while ( true ) { if ( repeat ) { sr . sitemodel ( salt ) ; } try { byte [ ] output = psspad ( salt , text , dohash , emlen ) ; cipher cipher = cipher . getinstance ( "rsa/ecb/nopadding" ) ; cipher . init ( cipher . encrypt_mode , key ) ; byte [ ] res = cipher . dofinal ( output ) ; return res ; } catch ( badpaddingexception e ) { if ( ! repeat ) return null ; } } } catch ( exception e ) { return null ; } }
te	ORIG	@ deprecated private string getlayerattacks ( string layer ) throws ioexception { string query = query_pre ; if ( layer . equals ( infoenum . layer . business . tostring ( ) ) ) { query = query + "let $ap1 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_social + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $ap2 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_supply + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $all := ($ap1 $ap2)" + "return data($all)" ; } else if ( layer . equals ( infoenum . layer . application . tostring ( ) ) ) { query = query + "let $ap1 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_software + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $ap2 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_commu + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $ap3 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_supply + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $all := ($ap1 $ap2 $ap3)" + "return data($all)" ; } else if ( layer . equals ( infoenum . layer . physical . tostring ( ) ) ) { query = query + "let $ap1 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_hardware + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $ap2 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_physical + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $ap3 := $domain//capec:attack_pattern_catalog/capec:categories/capec:category[@name = '" + d_supply + "']" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "let $all := ($ap1 $ap2 $ap3)" + "return data($all)" ; } else if ( layer . equals ( infoenum . layer . all . tostring ( ) ) ) { query = query + "let $ap := $domain//capec:attack_pattern_catalog/capec:categories/capec:category" + "/capec:relationships/capec:relationship/capec:relationship_target_id " + "return data($ap)" ; } else { commandpanel . logger . warning ( "incorrect layer for obtaining attack patterns!" ) ; } string result = session . execute ( query ) ; return result ; }
te	ORIG	public static void copyfile ( string file ) throws ioexception { bufferedreader br = null ; bufferedwriter bw = null ; try { br = new bufferedreader ( new filereader ( file ) ) ; bw = new bufferedwriter ( new filewriter ( file + ".bak" ) ) ; string line = null ; while ( ( line = br . readline ( ) ) != null ) { bw . write ( line ) ; } } catch ( exception ex ) { system . out . println ( "error occurs during copying " + file ) ; } finally { if ( br != null ) br . close ( ) ; if ( bw != null ) bw . close ( ) ; } }
te	ORIG	public void generateattackpatternmodel ( string pattern_ids ) { capecxmlprocessing xmlprocessing = new capecxmlprocessing ( ) ; xmlprocessing . importattackdomainfromfile ( ) ; linkedlist < string > ids = createnonrepeatedlist ( pattern_ids ) ; for ( string id : ids ) { capecxmlquerying xmlquery = new capecxmlquerying ( ) ; attackpattern ap = xmlquery . getattackinfoandrelations ( id ) ; linkedlist < string > threats = ap . getallthreats ( ) ; string target = xmlprocessing . findattackdomainbyid ( id ) ; string general_task_id = applescript . drawarbitraryrequirementelement ( "model set" , "none" , "hexagon" , infoenum . normal_size , "(300 300)" , "0" , ap . name , "0" , "1" ) ; string goal_content = "" ; if ( threats != null ) { string goal_id = "" ; for ( string threat : threats ) { goal_content = "" ; goal_content += "threat: " + threat + "\n" ; goal_content += "target: " + target ; goal_id = applescript . drawarbitraryrequirementelement ( "model set" , "none" , "circle" , infoenum . normal_size , "(300 300)" , "0" , goal_content , "0" , "1" ) ; applescript . drawarbitraryrequirementlink ( "model set" , "none" , goal_id , general_task_id , "arrow" , "0" , "none" , "none" ) ; } } string context_content = "" ; for ( string context : ap . contexts ) { context_content += context + "\n" ; } for ( string prerequisite : ap . prerequisites ) { context_content += prerequisite + "\n" ; } string context_id = applescript . drawarbitraryrequirementelement ( "model set" , "none" , "rectangle" , infoenum . normal_size , "(300 300)" , "0" , context_content , "0" , "0" ) ; applescript . drawarbitraryrequirementlink ( "model set" , "none" , context_id , general_task_id , "" , "0" , "none" , "none" ) ; if ( ap . steps . size ( ) > 1 ) { string mid_id = applescript . drawarbitraryrequirementelement ( "model set" , "none" , "circle" , infoenum . point_size , "(300 300)" , "0" , "" , "0" , "1" ) ; applescript . drawarbitraryrequirementlink ( "model set" , "none" , general_task_id , mid_id , "sharparrow" , "0" , "none" , "none" ) ; string task_id = "" ; for ( string step : ap . steps ) { task_id = applescript . drawarbitraryrequirementelement ( "model set" , "none" , "hexagon" , infoenum . normal_size , "(300 300)" , "0" , step , "0" , "1" ) ; applescript . drawarbitraryrequirementlink ( "model set" , "none" , mid_id , task_id , "" , "0" , "none" , "none" ) ; } } else { } system . out . println ( "successfully draw the model!" ) ; } }
te	FAULT	public static void main ( string [ ] args ) { user boss = new privilegeduser ( ) ; boss . setpassword ( "qwerty" ) ; boss . setname ( "larry page" ) ; boss . setage ( 41 ) ; ( ( privilegeduser ) boss ) . setcard ( new creditcard ( 6434343223422342 ) ) ; user employee = new standarduser ( ) ; employee . setpassword ( "12345" ) ; employee . setage ( 21 ) ; employee . setname ( "martin" ) ; visitor cardnumberprintingvisitorvisitor = new usercardnumberprintingvisitor ( ) ; visitor passworddroppingvisitor = new userpassworddroppingvisitor ( ) ; usergroupmanager manager = new usergroupmanager ( ) ; manager . setgroup ( arrays . aslist ( boss , employee ) ) ; manager . perform ( cardnumberprintingvisitorvisitor ) ; manager . perform ( passworddroppingvisitor ) ; system . mystrings . println ( boss . getpassword ( ) ) ; system . out . println ( employee . getpassword ( ) ) ; }
te	ORIG	private void removeentitiesfromlist ( ) { synchronized ( toremove ) { for ( entity ent : toremove ) { if ( ent instanceof newbie ) { final newbie newbie = ( newbie ) ent ; synchronized ( world . newbies ) { world . newbies . remove ( newbie ) ; } } else if ( ent instanceof god ) { final god god = ( god ) ent ; synchronized ( world . gods ) { world . gods . remove ( god ) ; } } else { if ( ent . getid ( ) > - 1 ) { world . broadcast ( new removeentity ( ent ) ) ; } if ( ent . humancontrol ( ) ) { world . updatenames ( ) ; } world . entities . remove ( ent ) ; if ( ent instanceof soldier ) { final soldier soldier = ( soldier ) ent ; world . soldiers . remove ( soldier ) ; } } } toremove . clear ( ) ; } }
te	FAULT	public void extractinfofromuserdata ( string user_data , requirementgraph graph ) { list < string > user_data_set = arrays . aslist ( user_data . split ( "\" " ) ) ; for ( string temp : user_data_set ) { int separator = temp . indexof ( ":" ) ; string key = temp . substring ( 0 , separator ) . trim ( ) . tolowercase ( ) ; string value = temp . substring ( separator + 2 ) . replace ( "\"}" , "" ) . trim ( ) ; value . replaceall ( "\\_" , " " ) ; if ( key . tolowercase ( ) . contains ( "importance" ) ) { this . setimportance ( pageviewdate ) ; } else if ( key . tolowercase ( ) . contains ( "sec_property" ) ) { this . setsecurityattribute ( value ) ; } else if ( key . tolowercase ( ) . contains ( "asset" ) ) { this . setasset ( value ) ; } else if ( key . tolowercase ( ) . contains ( "interval_id" ) ) { element elem = graph . findelementbyid ( value ) ; if ( elem != null ) { this . setinterval ( elem ) ; } else { this . setinterval ( null ) ; this . interval_id = value ; } } else if ( key . tolowercase ( ) . contains ( "threat_ids" ) ) { string [ ] threat_ids = value . split ( " " ) ; for ( string id : threat_ids ) { this . threats . add ( id ) ; } } else { } } }
te	ORIG	public shorturl getnext ( ) throws invalidshorturlexception , shorturloverflow { string currentstring = m_shorturlstring ; string finalstring = null ; int index = max_number_of_digits - 1 ; do { char currentchar = currentstring . charat ( index ) ; char incrementedalphanumber =  ; int currentnumber = ( int ) currentchar ; if ( ( ( currentnumber >= ( int ) 0 && currentnumber < ( int ) 9 ) ) || ( currentnumber >= ( int ) a && currentnumber < ( int ) z ) ) { currentnumber = currentnumber + 1 ; incrementedalphanumber = ( char ) currentnumber ; } else if ( currentnumber == ( int ) 9 ) { incrementedalphanumber = a ; } else if ( currentnumber == ( int ) z ) { stringbuilder s = new stringbuilder ( currentstring ) ; s . setcharat ( index , 0 ) ; currentstring = s . tostring ( ) ; index = index - 1 ; } if (  != incrementedalphanumber ) { stringbuilder string = new stringbuilder ( ) ; string . append ( currentstring . substring ( 0 , index ) ) ; string . append ( incrementedalphanumber ) ; string . append ( currentstring . substring ( index + 1 ) ) ; finalstring = string . tostring ( ) ; } if ( index < 0 ) { throw new shorturloverflow ( "unable to generate next url due to overflow." ) ; } } while ( finalstring == null ) ; shorturl url = new shorturl ( finalstring ) ; return url ; }
te	ORIG	@ suppresswarnings ( "unchecked" ) @ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getclass ( ) != obj . getclass ( ) ) return false ; final valorconcreto < t > other = ( valorconcreto < t > ) obj ; if ( valor == null ) { if ( other . valor != null ) return false ; } else if ( ! valor . equals ( other . valor ) ) return false ; return true ; }
te	FAULT	public boolean more ( ) throws ioexception { if ( sites == null ) { out . write ( 4 ) ; send ( id ) ; cache = new arraylist < > ( ) ; final bytearrayoutputstream os = new bytearrayoutputstream ( ) ; while ( in . read ( ) > 0 ) { receive ( in , os ) ; cache . add ( os . tobytearray ( ) ) ; os . reset ( ) ; } if ( ! ok ( ) ) throw new ioexception ( receive ( ) ) ; pos = 0 ; } if ( pos < cache . size ( ) ) return true ; cache = null ; return false ; }
te	ORIG	public static void antigoalrefine ( requirementgraph req_model , string type , int scope ) throws ioexception , scriptexception { string formal_model = req_model . generateformalexpressiontofile ( scope ) ; string security_pattern_knowledge_file = infoenum . current_directory + "/dlv/models/security_model_" + req_model . getlayer ( ) . tolowercase ( ) + ".dl " ; string threat_knowledge = infoenum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " ; string refine_rule = "" ; if ( type . equals ( infoenum . refinementdimension . asset . name ( ) ) ) { refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_asset.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + formal_model ; } else if ( type . equals ( infoenum . refinementdimension . protection . name ( ) ) ) { refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_protection.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else if ( type . equals ( infoenum . refinementdimension . target . name ( ) ) ) { refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_target.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else if ( type . equals ( infoenum . refinementdimension . threat . name ( ) ) ) { refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_threat.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else { commandpanel . logger . severe ( "error refinement type!" ) ; return ; } runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < requirementelement > refined_elems = new linkedlist < requirementelement > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "and_refined_anti_goal" ) && ( s . contains ( "unknown" ) == false ) ) { s = s . replaceall ( "and_refined_anti_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] ag_args = s . split ( " " ) ; antigoal refined_ag = ( antigoal ) req_model . findelementbyformalname ( ag_args [ 4 ] ) ; antigoal new_ag = new antigoal ( ag_args [ 0 ] , ag_args [ 1 ] , ag_args [ 2 ] , ag_args [ 3 ] , infoenum . requirementelementtype . anti_goal . name ( ) , refined_ag . getlayer ( ) ) ; req_model . getelements ( ) . add ( new_ag ) ; requirementlink new_and_refine = new requirementlink ( infoenum . requirementlinktype . and_refine . name ( ) , new_ag , refined_ag ) ; req_model . getlinks ( ) . add ( new_and_refine ) ; refined_ag . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexof ( refined_ag ) == - 1 ) { refined_elems . add ( refined_ag ) ; } } if ( s . startswith ( "refined_anti_goal" ) && ( s . contains ( "unknown" ) == false ) ) { s = s . replaceall ( "refined_anti_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] ag_args = s . split ( " " ) ; antigoal refined_ag = ( antigoal ) req_model . findelementbyformalname ( ag_args [ 4 ] ) ; antigoal new_ag = new antigoal ( ag_args [ 0 ] , ag_args [ 1 ] , ag_args [ 2 ] , ag_args [ 3 ] , infoenum . requirementelementtype . anti_goal . name ( ) , refined_ag . getlayer ( ) ) ; req_model . getelements ( ) . add ( new_ag ) ; requirementlink new_refine = new requirementlink ( infoenum . requirementlinktype . refine . name ( ) , new_ag , refined_ag ) ; req_model . getlinks ( ) . add ( new_refine ) ; drawrefinement ( refined_ag , new_refine ) ; } } } drawandrefinement ( refined_elems ) ; }
te	FAULT	@ override public string pageviewdate ( ) { string expression = null ; string source = "" ; string target = "" ; string attachment = "" ; if ( this . getremark ( ) . equals ( infoenum . linkremark . redundant . name ( ) ) ) { return "" ; } if ( this . getsource ( ) != null ) { source = this . getsource ( ) . getformalname ( ) ; } if ( this . gettarget ( ) != null ) { target = this . gettarget ( ) . getformalname ( ) ; } if ( this . getattachment ( ) != null ) { attachment = this . getattachment ( ) . getformalname ( ) ; } switch ( infoenum . requirementlinktype . valueof ( this . gettype ( ) ) ) { case refine : expression = "refine(" + source + " " + target + ")." ; break ; case and_refine : expression = "and_refine(" + source + " " + target + ")." ; break ; case operationalize : expression = "operationalize(" + source + " " + target + ")." ; break ; case preferred_to : expression = "preferred_to(" + source + " " + target + ")." ; break ; case depend : expression = "depend(" + source + " " + target + " " + attachment + ")." ; break ; case support : expression = "support(" + source + " " + target + ")." ; break ; case make : expression = "make(" + source + " " + target + ")." ; break ; case help : expression = "help(" + source + " " + target + ")." ; break ; case hurt : expression = "hurt(" + source + " " + target + ")." ; break ; case break : expression = "break(" + source + " " + target + ")." ; break ; case trust : expression = "trust(" + source + " " + target + " " + trust_level + ")." ; break ; case use : expression = "use(" + source + " " + target + ")." ; break ; case maintain : expression = "maintain(" + source + " " + target + ")." ; break ; case own : expression = "own(" + source + " " + target + ")." ; break ; default : expression = "" ; break ; } return expression ; }
te	ORIG	public synchronized void updateelementused ( node < t > element ) { if ( element == getfront ( ) ) { } else { try { if ( element . getnext ( ) != null ) { element . getnext ( ) . setprev ( element . getprev ( ) ) ; } else if ( element . getnext ( ) == null ) { setrear ( element . getprev ( ) ) ; } element . getprev ( ) . setnext ( element . getnext ( ) ) ; element . setnext ( null ) ; element . setprev ( null ) ; addelement ( element ) ; } catch ( nullpointerexception e ) { e . printstacktrace ( ) ; } } }
te	ORIG	public static string drawarbitraryrequirementlink ( string canvas , string layer , string target_id , string source_id , string head_type , string stroke_pattern , string label , string link_layer ) { layer = "none" ; string script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set target_id to " + target_id + "\n" + "set source_id to " + source_id + "\n" + "set head_type to \"" + head_type + "\"\n" + "set stroke_pattern to " + stroke_pattern + "\n" + "set label_text to \"" + label + "\"\n" + "set link_layer to \"" + link_layer + "\"\n" + "draw_link(target_canvas_name  target_layer_name  target_id  source_id  head_type  stroke_pattern  label_text  link_layer)\n" ; string method_file = infoenum . drawing_method_file ; try { script = loadmethods ( script , method_file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } string id = "" ; try { id = executeapplescript ( script ) ; } catch ( scriptexception e ) { e . printstacktrace ( ) ; } return id ; }
te	ORIG	public void addlisteners ( controller c ) { serverportfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "server_socket_port" ) ) ; servernamefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "server_socket_name" ) ) ; serversubmit . addactionlistener ( c ) ; socketipfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "socket_ip" ) ) ; socketnamefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "request_name" ) ) ; socketmessagefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "request_message" ) ) ; socketportfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "socket_port" ) ) ; socketsubmit . addactionlistener ( c ) ; }
te	FAULT	@ test public void should_add_products_property_with_proper_items ( ) { shoppingcard card = new shoppingcard ( ) ; card . setproducts ( new arraylist < product > ( ) { { add ( new toy ( 23 , "lego bricks & more builders of tomorrow set" ) ) ; add ( new toy ( 102 , "dreamworks dragons defenders of berk - mini dragons figures toothless" ) ) ; } } ) ; asserttrue ( card . getproducts ( ) . size ( ) == 2 ) ; assertequals ( card . getproducts ( ) . get ( 0 ) . s ( ) , "lego bricks & more builders of tomorrow set" ) ; assertsame ( card . getproducts ( ) . get ( 0 ) . getprice ( ) , 23 ) ; assertequals ( card . getproducts ( ) . get ( 1 ) . getname ( ) , "dreamworks dragons defenders of berk - mini dragons figures toothless" ) ; }
te	ORIG	@ override public void dopost ( httpservletrequest request , httpservletresponse response ) throws ioexception { userservice userservice = userservicefactory . getuserservice ( ) ; user user = userservice . getcurrentuser ( ) ; string guestbookname = request . getparameter ( "guestbookname" ) ; string emaildeclared = request . getparameter ( "email" ) ; string namedeclared = request . getparameter ( "name" ) ; if ( guestbookname == null ) { guestbookname = "default" ; } if ( emaildeclared == null ) { emaildeclared = user . getemail ( ) ; } if ( namedeclared == null ) { namedeclared = user . getnickname ( ) ; } key guestbookkey = keyfactory . createkey ( "guestbook" , guestbookname ) ; string content = request . getparameter ( "message" ) ; if ( content == null ) { content = "greetings!" ; } if ( user != null ) { entity greeting = new entity ( "greeting" , guestbookkey ) ; date date = new date ( ) ; greeting . setproperty ( "user" , user ) ; greeting . setproperty ( "date" , date ) ; greeting . setproperty ( "userid" , user . getuserid ( ) ) ; greeting . setproperty ( "federatedid" , user . getfederatedidentity ( ) ) ; greeting . setproperty ( "domain" , user . getauthdomain ( ) ) ; greeting . setproperty ( "content" , content ) ; greeting . setproperty ( "namedeclared" , namedeclared ) ; greeting . setproperty ( "emaildeclared" , emaildeclared ) ; datastoreservice ds = datastoreservicefactory . getdatastoreservice ( ) ; ds . put ( greeting ) ; } else { log . info ( "anonymous: " + content ) ; } response . sendredirect ( "/guest.jsp?guestbookname=" + guestbookname ) ; }
te	ORIG	public basexclient ( final string host , final int port , final string user , final string pass ) throws ioexception { socket = new socket ( ) ; socket . connect ( new inetsocketaddress ( host , port ) , 5000 ) ; in = new bufferedinputstream ( socket . getinputstream ( ) ) ; out = socket . getoutputstream ( ) ; ehost = host ; final string ts = receive ( ) ; send ( user ) ; send ( md5 ( md5 ( pass ) + ts ) ) ; if ( ! ok ( ) ) throw new ioexception ( "access denied." ) ; }
te	ORIG	public void importattackdomainfromfile ( ) { linkedlist < string > lines = new linkedlist < string > ( ) ; lines = func . readfilebyline ( "capec/attack_domains.xml" ) ; string pattern_id = "" ; for ( string line : lines ) { if ( line . contains ( "capec:attack_pattern" ) ) { pattern_id = line . substring ( line . indexof ( "id=\"" ) + 4 , line . indexof ( "\"/>" ) ) ; if ( line . contains ( infoenum . attackdomain . social . tostring ( ) ) ) { social_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . supply . tostring ( ) ) ) { supply_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . commu . tostring ( ) ) ) { commu_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . software . tostring ( ) ) ) { software_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . hardware . tostring ( ) ) ) { hardware_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . physical . tostring ( ) ) ) { physical_attacks . add ( pattern_id ) ; } } } }
te	ORIG	public graphicalboard ( int sizex , int sizey ) { this . sizex = sizex ; this . sizey = sizey ; this . currentx = sizex / 2 ; this . currenty = sizey / 2 ; this . setdefaultcloseoperation ( jframe . dispose_on_close ) ; this . setresizable ( false ) ; this . setsize ( sizex , sizey ) ; this . settitle ( "programe brincando" ) ; this . setundecorated ( true ) ; this . setlocationrelativeto ( null ) ; this . setvisible ( true ) ; this . tartaruga = new koopa ( ) ; this . tartaruga . setbounds ( currentx - koopa . width / 2 , currenty - koopa . height / 2 , koopa . width , koopa . height ) ; this . add ( tartaruga ) ; this . repaint ( ) ; }
te	FAULT	public void extractinfofromname ( ) { string sg = this . getname ( ) ; sg = sg . trim ( ) . tolowercase ( ) ; list < string > list = arrays . aslist ( sg . split ( " " ) ) ; for ( string temp : list ) { if ( temp . contains ( "threat" ) ) { string threat = temp . substring ( temp . indexof ( ":" ) + 1 ) . trim ( ) ; if ( threat . contains ( "(" ) ) { threat = threat . substring ( 0 , threat . indexof ( "(" ) ) . trim ( ) ; } this . setthreat ( threat ) ; } else if ( temp . contains ( "asset" ) ) { this . setasset ( temp . substring ( txtfieldzipcode . indexof ( ":" ) + 1 ) . trim ( ) ) ; } else if ( temp . contains ( "target" ) ) { this . settarget ( temp . substring ( temp . indexof ( ":" ) + 1 ) . trim ( ) ) ; } else if ( temp . contains ( "interval" ) ) { this . setinterval ( temp . substring ( temp . indexof ( ":" ) + 1 ) . trim ( ) ) ; } else { system . out . println ( "there is an exception!" ) ; } } if ( this . getformalexpressions ( ) . indexof ( ":" ) > 0 ) { system . out . println ( "import error ':'!" ) ; } }
te	FAULT	@ override public list < client > getclient ( ) throws sqlexception { list < client > cli = new arraylist < client > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select * from klienci" ; statement agemonths = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "id" ) ; string name = results . getstring ( "imie" ) ; string lastname = results . getstring ( "nazwisko" ) ; string addres = results . getstring ( "adres" ) ; client client = new client ( id , name , lastname , addres ) ; cli . add ( client ) ; } results . close ( ) ; selectstatement . close ( ) ; return cli ; }
te	ORIG	private static string md5 ( final string pw ) { final stringbuilder sb = new stringbuilder ( ) ; try { final messagedigest md = messagedigest . getinstance ( "md5" ) ; md . update ( pw . getbytes ( ) ) ; for ( final byte b : md . digest ( ) ) { final string s = integer . tohexstring ( b & ff ) ; if ( s . length ( ) == 1 ) sb . append ( 0 ) ; sb . append ( s ) ; } } catch ( final nosuchalgorithmexception ex ) { ex . printstacktrace ( ) ; } return sb . tostring ( ) ; }
te	FAULT	public dersequence getderobject ( ) { derinteger reference = new derinteger ( this . reference ) ; derinteger internalidentifier = new derinteger ( this . internalidentifier ) ; derbitstring operations = new derbitstring ( commonobjectattributes . encodebits ( this . operations ) , commonobjectattributes . getpad ( this . operations ) ) ; derobjectidentifier objectid = new derobjectidentifier ( this . objectid ) ; derinteger algid = new derinteger ( this . algid ) ; return new dersequence ( new asn1encodable [ ] { reference , internalidentifier , new dernull ( ) , setstyle , objectid , algid } ) ; }
te	ORIG	private void generateobjects ( ) { if ( measures [ 0 ] != null ) { models . simfileline exampleline = measures [ 0 ] . getlines ( ) . get ( 0 ) ; currentholds = new hold [ exampleline . getsteps ( ) . length ] ; } else { currentholds = new hold [ 0 ] ; } double measureheight = ( double ) ( height - 2 * column_margin ) / measures . length ; double currenty = y + column_margin ; children = new entity [ measures . length ] ; for ( int i = 0 ; i < measures . length ; i ++ ) { children [ i ] = new measure ( settings , measures [ i ] , currentholds , x + column_margin , ( int ) currenty , width - 2 * column_margin , ( int ) measureheight ) ; currenty += measureheight ; } }
te	ORIG	public static void main ( string [ ] args ) { final earlynotifydemo en = new earlynotifydemo ( ) ; runnable runa = new runnable ( ) { public void run ( ) { try { string item = en . removeitem ( ) ; print ( "in run() - returned: '" + item + "'" ) ; } catch ( interruptedexception ix ) { print ( "interrupted!" ) ; } catch ( exception x ) { print ( "threw an exception!!!\n" + x ) ; } } } ; runnable runb = new runnable ( ) { public void run ( ) { en . additem ( "hello!" ) ; } } ; try { thread threada1 = new thread ( runa , "threada1" ) ; threada1 . start ( ) ; thread . sleep ( 500 ) ; thread threada2 = new thread ( runa , "threada2" ) ; threada2 . start ( ) ; thread . sleep ( 500 ) ; thread threadb = new thread ( runb , "threadb" ) ; threadb . start ( ) ; thread . sleep ( 10000 ) ; threada1 . interrupt ( ) ; threada2 . interrupt ( ) ; } catch ( interruptedexception x ) { } }
te	ORIG	private void updateholds ( ) { if ( step . gettype ( ) == type . roll_start ) { hold = new roll ( settings , step , x , y , width , height ) ; hold . start ( ) ; currentholds [ holdindex ] = hold ; } else if ( step . gettype ( ) == type . freeze_start ) { hold = new freeze ( settings , step , x , y , width , height ) ; hold . start ( ) ; currentholds [ holdindex ] = hold ; } else if ( step . gettype ( ) == type . roll_end || step . gettype ( ) == type . freeze_end ) { if ( currentholds [ holdindex ] != null ) { currentholds [ holdindex ] . extend ( height ) ; currentholds [ holdindex ] . end ( ) ; currentholds [ holdindex ] = null ; } } else if ( step . gettype ( ) == type . rolling || step . gettype ( ) == type . holding ) { if ( currentholds [ holdindex ] != null ) { currentholds [ holdindex ] . extend ( height ) ; } else { if ( step . gettype ( ) == type . rolling ) { hold = new roll ( settings , step , x , y , width , height ) ; currentholds [ holdindex ] = hold ; } else if ( step . gettype ( ) == type . holding ) { hold = new freeze ( settings , step , x , y , width , height ) ; currentholds [ holdindex ] = hold ; } } } }
