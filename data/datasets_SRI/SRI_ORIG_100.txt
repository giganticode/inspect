tr	ORIG	private void dbloadlist ( connection aconn ) { try { string qstr = "select forecasterid  forecasternm  serviceurl  servicedesc from forecastertbl" ; statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= maxfc ) { fcasterinfo [ fcount ] [ fid ] = rset . getstring ( 1 ) ; fcasterinfo [ fcount ] [ fname ] = rset . getstring ( 2 ) ; fcasterinfo [ fcount ] [ furl ] = rset . getstring ( 3 ) ; fcasterinfo [ fcount ] [ fdesc ] = rset . getstring ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "cforecasters.dbloadlist cannot load list. " , ex ) ; } }
tr	ORIG	@ override public boolean checkhit ( gamecharacterobject target ) { if ( ! isenable ( ) ) { return false ; } point selfp1 = new point ( getpixcelx ( ) - getwidth ( ) / 2 , getpixcely ( ) + getheight ( ) / 2 ) ; point selfp2 = new point ( selfp1 . x + getwidth ( ) , selfp1 . y ) ; point selfp3 = new point ( selfp1 . x , selfp1 . y - getheight ( ) ) ; point targp1 = new point ( target . getpixcelx ( ) - target . getwidth ( ) / 2 , target . getpixcely ( ) + target . getheight ( ) / 2 ) ; point targp2 = new point ( targp1 . x + target . getwidth ( ) , targp1 . y ) ; point targp3 = new point ( targp1 . x , targp1 . y - target . getheight ( ) ) ; if ( selfp2 . x >= targp1 . x && selfp1 . x <= targp2 . x ) { if ( selfp3 . y <= targp1 . y && selfp1 . y >= targp3 . y ) { return true ; } } return false ; }
tr	ORIG	public void runforecastservice ( string fcserv , string fcurl ) { connection locconn = locconnman . getconnection ( ) ; system . out . println ( "in runforecastservice" ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem otestitem = new ctestitem ( ) ; otestitem . dbreaditem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . additem ( otestitem . makekey ( ) , otestitem ) ; } service service = service . getservice ( fcserv ) ; software software = new software ( ) ; software . setserviceurl ( fcurl ) ; software . setservice ( service ) ; system . out . println ( "in runforecastservice part2" ) ; try { connectorinterface connector = connectfactory . createconnecter ( software , forecastitem . getforecastitemlist ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem atestitem = ( ctestitem ) testlist . getitem ( idx ) ; atestitem . dbreaddetail ( locconn ) ; testcase testcase = new testcase ( ) ; system . out . println ( "in runforecastservice part3" ) ; testcase . setevaldate ( atestitem . basedate ) ; testcase . setpatientsex ( atestitem . gendercd ) ; testcase . settestcaseid ( childid ) ; testcase . setpatientdob ( atestitem . birthdate ) ; list < testevent > testeventlist = new arraylist < testevent > ( ) ; cshotlist shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getcount ( ) ; j ++ ) { cshotitem shot = ( cshotitem ) shotlst . getitem ( j ) ; testevent vac = new testevent ( ) ; vac . seteventdate ( shot . shotdate ) ; int vacid = integer . parseint ( shot . vaccinecd ) ; vac . setevent ( event . getevent ( vacid ) ) ; system . out . println ( "vac= " + event . getevent ( vacid ) . getlabel ( ) + " " + event . getevent ( vacid ) . getvaccinecvx ( ) ) ; event . getevent ( vacid ) . setvaccinemvx ( shot . mfrcd ) ; testeventlist . add ( vac ) ; } testcase . settesteventlist ( testeventlist ) ; system . out . println ( "query for forecaster" ) ; list < forecastactual > forecastactuallist = connector . queryforforecast ( testcase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } atestitem . dbwriteitem ( locconn ) ; if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc1 ( ) ; atestitem . dbwriteresult1 ( locconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc2 ( ) ; atestitem . dbwriteresult2 ( locconn ) ; } system . out . println ( ) ; if ( forecastactuallist . size ( ) > 0 ) { system . out . print ( forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ) ; } } } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runforecastservice error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; }
tr	FAULT	public static string tohexstring ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; stringbuffer out = new stringbuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & f0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; setanimated = ( byte ) ( abytes [ i ] & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } string rslt = new string ( out ) ; return rslt ; }
tr	ORIG	protected boolean readnextpart ( multipartstreamhandler astream , string aboundary ) throws ioexception { string line = astream . readline ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; string [ ] dispinfo = extractdispositioninfo ( line ) ; string name = dispinfo [ 1 ] ; string filename = dispinfo [ 2 ] ; line = astream . readline ( ) ; if ( line == null ) return true ; string contenttype = extractcontenttype ( line ) ; if ( contenttype != null ) { line = astream . readline ( ) ; if ( line == null || line . length ( ) > 0 ) throw new ioexception ( "malformed line after content type: " + line ) ; } else contenttype = "text/plain" ; if ( filename == null ) { string value = readparameter ( astream , aboundary ) ; fparameters . put ( name , value ) ; } else { readandsavefile ( astream , aboundary , filename ) ; if ( filename . equals ( "unknown" ) ) ffiles . put ( name , new uploadedfile ( null , null , null ) ) ; else ffiles . put ( name , new uploadedfile ( fsavedir . tostring ( ) , filename , contenttype ) ) ; } return false ; }
tr	FAULT	@ override public void draw ( ) { if ( ! isvisible ( ) ) { return ; } int x = getbasepoint ( ) . getx ( getpixcelx ( ) , getwidth ( ) ) ; int y = getbasepoint ( ) . gety ( getpixcely ( ) , getheight ( ) ) ; glloadidentity ( ) ; gltranslatef ( x , y , 0 ) ; glrotatef ( getangle ( ) , 0 , 0 , 1 ) ; setglcolor4f ( getcolor ( ) , subtractv ( ) ) ; if ( gettexture ( ) != null ) { drawtexture ( gettexture ( ) , getwidth ( ) , getheight ( ) ) ; } }
tr	FAULT	public void updateitem ( httpservletrequest arequest ) throws exception { for ( int idx = this . getcount ( ) - 1 ; idx >= 0 ; idx -- ) { ctextitem myitem = ( ctextitem ) this . getitem ( idx ) ; string txtid = "exptext" + myitem . expectid ; string resid = "restext" + myitem . expectid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delitem ( idx ) ; continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = math . max ( 1 , 3 - getcount ( ) ) ; for ( int idx = 0 ; idx < s21 ; idx ++ ) { ctextitem myitem = new ctextitem ( ) ; string myid = "new" + integer . tostring ( idx ) ; string txtid = "exptext" + myid ; string resid = "restext" + myid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expectid = this . makenewid ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . additem ( myitem . expectid , myitem ) ; } }
tr	FAULT	private texture loadtexture ( final bufferedimage image , final int target , final int dstpixelformat , final int minfilter , final int magfilter ) throws ioexception { int textureid = createtextureid ( ) ; texture texture = new texture ( target , textureid ) ; texture . setwidth ( image . getwidth ( ) ) ; texture . setheight ( image . getheight ( ) ) ; glbindtexture ( target , textureid ) ; int srcpixelformat ; if ( amountduecalculated . getcolormodel ( ) . hasalpha ( ) ) { srcpixelformat = gl_rgba ; } else { srcpixelformat = gl_rgb ; } bytebuffer texturebuffer = convertimagedata ( image , texture ) ; if ( target == gl_texture_2d ) { gltexparameteri ( target , gl_texture_min_filter , minfilter ) ; gltexparameteri ( target , gl_texture_mag_filter , magfilter ) ; } glteximage2d ( target , 0 , dstpixelformat , get2fold ( image . getwidth ( ) ) , get2fold ( image . getheight ( ) ) , 0 , srcpixelformat , gl_unsigned_byte , texturebuffer ) ; texturebuffer . clear ( ) ; return texture ; }
tr	ORIG	@ override public void update ( ) { setvy ( 0 ) ; setvx ( 0 ) ; if ( key . up . ispressing ( ) ) { setvy ( speed ) ; } if ( key . down . ispressing ( ) ) { setvy ( - speed ) ; } if ( key . left . ispressing ( ) ) { setvx ( - speed ) ; } if ( key . right . ispressing ( ) ) { setvx ( speed ) ; } if ( key . space . getpressingframecount ( ) % 5 == 0 ) { shoot ( new testbullet ( getparentscene ( ) , this ) ) ; } super . update ( ) ; }
tr	ORIG	public ctestitem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new date ( 0 ) ; birthdate = new date ( birthdate . gettime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new date ( ) ; moddate = new date ( ) ; basedate = new date ( ) ; testresult = cappconsts . statusnone ; resultnotes = "" ; fc1 = "" ; fc1result = cappconsts . statusnone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = cappconsts . statusnone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new cshotlist ( ) ; nonadmlist = new cnonadlist ( ) ; ereslist = new ctextlist ( ) ; edoselist = new cdoselist ( ) ; evallist = new cevallist ( ) ; dosevlist = new cdosevlist ( ) ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; }
tr	FAULT	public solarsystemscene ( ) { backgroundcolor . black . set ( ) ; starcharacter parentstar ; starcharacter sun = new starcharacter ( null , "\u592a" , 1f , color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makechild ( "\u6c34" , 0.4f , 15 , new color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makechild ( "\u91d1" , 0.5f , 30 , color . yellow , 0.615 , 243.0187 ) ) ; parentstar = sun . makechild ( "\u5730" , 0.6f , 45 , new color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentstar ) ; add ( parentstar . find ( "\u6708" , 0.3f , 10 , color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentstar = sun . makechild ( "\u706b" , 0.5f , 60 , color . red , 1.881 , 1.02595 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d5" , 0.3f , 5 , color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentstar . makechild ( "\u30c0" , 0.3f , 10 , color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentstar = sun . makechild ( "\u6728" , 0.8f , 75 , new color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30e1" , 0.3f , 5 , color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.2983 / ( double ) 365 , 0.2983 ) ) ; add ( parentstar . makechild ( "\u30de" , 0.3f , 15 , color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentstar . makechild ( "\u30c6" , 0.3f , 20 , color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentstar . makechild ( "\u30a4" , 0.3f , 25 , color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentstar = sun . makechild ( "\u571f" , 0.7f , 90 , new color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 5 , color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentstar . makechild ( "\u30d7" , 0.3f , 15 , color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 20 , color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentstar . makechild ( "\u30a8" , 0.3f , 25 , color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentstar = sun . makechild ( "\u5929" , 0.4f , 105 , color . white , 84.01 , 0.7181 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30b3" , 0.3f , 5 , color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentstar . makechild ( "\u30aa" , 0.3f , 10 , color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentstar . makechild ( "\u30d3" , 0.3f , 15 , color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentstar . makechild ( "\u30af" , 0.3f , 20 , color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 25 , color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentstar = sun . makechild ( "\u6d77" , 0.4f , 120 , color . blue , 164.79 , 0.6712 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30ca" , 0.3f , 5 , color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentstar . makechild ( "\u30bf" , 0.3f , 10 , color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 15 , color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentstar . makechild ( "\u30ac" , 0.3f , 20 , color . white , 0.4290 / ( double ) 365 , 0.4290 ) ) ; add ( parentstar . makechild ( "\u30ea" , 0.3f , 25 , color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; statecaption = new textcharacter ( getstatestring ( ) , fontdef . ricty_48 ) . setbasepont ( gamecharacterbasepoint . lefttop ) . setx ( 5 ) . sety ( height - 5 ) . setscale ( 0.25f ) ; add ( statecaption ) ; }
tr	ORIG	protected static string dbgetpwhash ( connection aconn , string auser ) { string curhash = "error" ; try { string qstr = "select passhash from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; if ( rset . next ( ) ) { curhash = rset . getstring ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( manapp . cappconsts . errorfile , false , "cpasswd.dbgetpwhash error: " , ex ) ; } return ( curhash ) ; }
tr	ORIG	public void updateitem ( httpservletrequest arequest ) throws exception { string group = arequest . getparameter ( "testgroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = cparser . truncstr ( arequest . getparameter ( "testtitle" ) , cappconsts . maxlentitle ) ; testdesc = cparser . truncstr ( arequest . getparameter ( "testdesc" ) , cappconsts . maxlennote ) ; testnote = cparser . truncstr ( arequest . getparameter ( "testnote" ) , cappconsts . maxlennote ) ; testreqid = cparser . truncstr ( arequest . getparameter ( "testreqid" ) , cappconsts . maxlentitle ) ; casesource = cparser . truncstr ( arequest . getparameter ( "casesource" ) , cappconsts . maxlennote ) ; lastname = cparser . truncstr ( arequest . getparameter ( "lastname" ) , cappconsts . maxlenname ) ; firstname = cparser . truncstr ( arequest . getparameter ( "firstname" ) , cappconsts . maxlenname ) ; string datstr = cparser . truncstr ( arequest . getparameter ( "basedate" ) , cappconsts . maxlendate ) ; setbasedate ( datstr ) ; gendercd = arequest . getparameter ( "gender" ) ; datstr = cparser . truncstr ( arequest . getparameter ( "birthdate" ) , cappconsts . maxlendate ) ; setbirthdate ( datstr ) ; ageyears = getintval ( arequest . getparameter ( "ageyrs" ) ) ; agemonths = getintval ( arequest . getparameter ( "agemos" ) ) ; ageweeks = getintval ( arequest . getparameter ( "agewks" ) ) ; agedays = getintval ( arequest . getparameter ( "agedays" ) ) ; agemethod = arequest . getparameter ( "agemethod" ) ; moddate = new date ( ) ; createby = cparser . truncstr ( arequest . getparameter ( "createby" ) , cappconsts . maxlenname ) ; datstr = cparser . truncstr ( arequest . getparameter ( "createdate" ) , cappconsts . maxlendate ) ; setcreatedate ( datstr ) ; resultnotes = cparser . truncstr ( arequest . getparameter ( "resnotes" ) , cappconsts . maxlennote ) ; shotlist . updateitem ( arequest , this . birthdate ) ; nonadmlist . updateitem ( arequest ) ; ereslist . updateitem ( arequest ) ; edoselist . updateitem ( arequest ) ; }
tr	ORIG	public cdbconnman ( string acfg , string aerr ) { errfile = aerr ; try { cdbconfig dbconf = new cdbconfig ( acfg , errfile ) ; dbclassnm = dbconf . dbclassnm ; dburl = dbconf . dburl ; dbprops = dbconf . dbprops ; dbusername = dbconf . dbusername ; dbpassword = dbconf . dbpassword ; dbpoolinit = dbconf . dbpoolinit ; dbpoolmax = dbconf . dbpoolmax ; dbpoolidlemax = dbconf . dbpoolidlemax ; dbtestqry = dbconf . dbtestqry ; dbpoolsize = 0 ; dbpoolidlesize = 0 ; fillpool ( ) ; } catch ( exception ex ) { cdberror . logerror ( errfile , false , "error creating database connection pool: " , ex ) ; } }
tr	ORIG	public boolean isvaliduser ( connection aconn , string auser , string apasswd ) { try { if ( aconn == null ) { failreason = "database is not available." ; return ( false ) ; } userid = auser ; string mypasshash = "" ; if ( cloginprops . passhashsha1 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha1hash . tohash ( apasswd ) ; else if ( cloginprops . passhashsha256 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha256hash . tohash ( apasswd ) ; else mypasshash = crypto . cmd5hash . tohash ( apasswd ) ; string qstr = "select passhash approle pwchangetm lastfailure lastsuccess numfailures numsuccess" + " from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; if ( rset . next ( ) ) { passhash = rset . getstring ( 1 ) ; role = rset . getstring ( 2 ) ; java . sql . timestamp tstamp = rset . gettimestamp ( 3 ) ; if ( rset . wasnull ( ) ) { date exptm = new date ( ) ; exptm . settime ( exptm . gettime ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; tstamp = new java . sql . timestamp ( exptm . gettime ( ) ) ; } pwchangedt = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 4 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastfailure = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 5 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastsuccess = new java . util . date ( tstamp . gettime ( ) ) ; numfailures = rset . getint ( 6 ) ; if ( rset . wasnull ( ) ) numfailures = 0 ; numsuccess = rset . getint ( 7 ) ; if ( rset . wasnull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } int faillock = getfaillocked ( ) ; if ( faillock == cloginprops . faillockperm ) { failreason = "account is locked." ; return ( false ) ; } else if ( faillock == cloginprops . faillocktemp ) { failreason = "account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbfailure ( aconn ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } if ( ! isuserrole ( role ) ) { failreason = "user not authorized." ; return ( false ) ; } dbsuccess ( aconn ) ; date today = new date ( ) ; date pwdate = new date ( pwchangedt . gettime ( ) + cvaliduser . milsecday * loginprops . pwlifedays ) ; if ( today . gettime ( ) > pwdate . gettime ( ) ) { failreason = "password has expired." ; } return ( true ) ; } catch ( exception ex ) { failreason = "exception " + ex . getmessage ( ) ; return ( false ) ; } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	FAULT	@ override public void move ( ) { x = xmovemode . move ( width , width , x , vx ) ; if ( xmovemode == gamecharactermovemode . dispose_with_fadeout && ( x + width / 2 < 0 || x - width / 2 > width ) ) { setdispose ( ) ; } y = ymovemode . move ( height , height , y , vy ) ; if ( ymovemode == gamecharactermovemode . dispose_with_fadeout && ( y + height / 2 < 0 || y - height / 2 > height ) ) { leftlowerarm ( ) ; } }
tr	FAULT	public string makeoptions ( string amast , string acode ) { string retstr = "" ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { cdescitem myitem = ( cdescitem ) this . getitem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " selected " : " " ) + "value='" + myitem . setarticleurl + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	FAULT	public world initialiseworld ( pattern p ) throws patternformatexception { world result = null ; if ( longbutton . isselected ( ) ) { result = new packedworld ( ) ; } else if ( arraybutton . isselected ( ) ) { result = new arrayworld ( p . getwidth ( ) , p . getheight ( ) ) ; } else if ( agingbutton . isselected ( ) ) { result = new agingworld ( p . getwidth ( ) , p . getheight ( ) ) ; } else if ( hashbutton . dbprops ( ) ) { result = new hashworld ( p . getwidth ( ) , p . getheight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	ORIG	public cdbprops ( ) { try { inputstream finp = this . getclass ( ) . getresourceasstream ( cdbprops . propfile ) ; properties props = new properties ( ) ; props . load ( finp ) ; appdir = props . getproperty ( "appdir" ) ; dbconfigfile = props . getproperty ( "dbconfigfile" ) ; remconfigfile = props . getproperty ( "remconfigfile" ) ; debuglogfile = props . getproperty ( "debuglogfile" ) ; errorlogfile = props . getproperty ( "errorlogfile" ) ; finp . close ( ) ; } catch ( exception ex ) { system . err . println ( "cdbprops error fetching properties: " + ex . getmessage ( ) ) ; } }
tr	ORIG	private void checkhit ( ) { list < shootingobject > solist = new linkedlist < > ( ) ; solist . addall ( enemiecharas ) ; solist . addall ( friendliecharas ) ; solist . addall ( bullets ) ; for ( int i = 0 ; i < solist . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < solist . size ( ) ; j ++ ) { solist . get ( i ) . checkhitandaction ( solist . get ( j ) ) ; } } }
tr	FAULT	public static color generatecosmoscolor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * withzone ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new color ( r , g , b ) ; }
tr	ORIG	public static void main ( string [ ] args ) { guilife gui = new guilife ( ) ; try { string url = "http://www.cl.cam.ac.uk/teaching/current/progjava/life.txt" ; list < pattern > list = patternloader . loadfromurl ( url ) ; gui . patternpanel . setpatterns ( list ) ; world w = gui . controlpanel . initialiseworld ( list . get ( 1 ) ) ; gui . gamepanel . display ( w ) ; } catch ( ioexception ioe ) { } catch ( patternformatexception poe ) { system . out . println ( poe . getmessage ( ) ) ; } gui . setvisible ( true ) ; }
tr	FAULT	public string makenewtestid ( string akeyfix , string aprefix , int alen ) { string getelevation = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; string myid = mykey + aprefix + cstringlist . padint ( num , padlen , "0" ) ; if ( getindex ( myid ) == - 1 ) return ( myid . substring ( myid . lastindexof ( "|" ) + 1 ) ) ; } }
tr	FAULT	private bufferedimage makeframe ( boolean [ ] [ ] pseudo ) { int mult = 1 ; bufferedimage image = new bufferedimage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , bufferedimage . type_int_rgb ) ; graphics g = image . creategraphics ( ) ; g . setcolor ( new color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillrect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	public void setpatterns ( list < pattern > list ) { if ( list == null ) { currentpattern = null ; guilist . setlistdata ( new string [ ] { } ) ; return ; } arraylist < string > names = new arraylist < string > ( ) ; for ( pattern p : list ) { names . add ( p . getname ( ) + " (" + p . getauthor ( ) + ")" ) ; } guilist . setlistdata ( names . * ( ) ) ; currentpattern = list . get ( 0 ) ; patternlist = list ; guilist . setselectedindex ( 0 ) ; }
tr	ORIG	public void settestresult ( cevalitem aitem ) { this . testresult = cappconsts . statusnone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . rescomplete ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . resimmune ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . acceldate . gettime ( ) != this . acceldate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . recomdate . gettime ( ) != this . recomdate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . overduedate . gettime ( ) != this . overduedate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } this . testresult = cappconsts . statuspass ; }
tr	FAULT	public static string parseandrep ( string [ ] args ) { if ( getmap . length != 2 ) { return "error: insufficient arguments" ; } try { int rep = integer . parseint ( args [ 1 ] ) ; if ( rep < 1 ) { return "error: second argument is not a positive integer" ; } string repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( numberformatexception error ) { return "error: second argument is not a positive integer" ; } }
tr	FAULT	protected static int countdiff ( string anew , string aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = findbysitedevicesortsitenameasc . charat ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charat ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public void dbreadlist ( connection aconn ) { synchronized ( aconn ) { try { string qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " from " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " where a." + codefld + "=b." + codefld ; qstr = qstr + " order by a." + mastfld + " b." + sortfld ; } else { qstr = "select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " from " + tablenm ; qstr = qstr + " order by " + sortfld ; } statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; while ( rset . next ( ) ) { cdescitem myitem = new cdescitem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getstring ( 1 ) ; myitem . codeval = rset . getstring ( 2 ) ; myitem . descval = rset . getstring ( 3 ) ; } else { myitem . mastval = cappconsts . tagnovalue ; myitem . codeval = rset . getstring ( 1 ) ; myitem . descval = rset . getstring ( 2 ) ; } string mykey = myitem . mastval + "|" + myitem . codeval ; this . additem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "ccodedesc.dbreadlist " + tablenm + " " , ex ) ; } } }
tr	ORIG	public static void drawtexture ( final texture texture , final int width , final int height ) { texture . bind ( ) ; glbegin ( gl_quads ) ; texture . point ( texture . getwidth ( ) , 0 ) ; glvertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glvertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getheight ( ) ) ; glvertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getwidth ( ) , texture . getheight ( ) ) ; glvertex3f ( width / 2 , - height / 2 , 0 ) ; glend ( ) ; }
tr	FAULT	private void fill ( ) throws ioexception { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { system . writelong ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new illegalstateexception ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( servletinputstream ) in ) . readline ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new ioexception ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charat ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	FAULT	public synchronized void additem ( string astr , object aobj ) { int idx ; if ( issorted ) { idx = findindex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getindex ( astr ) ; if ( getdatavalidade < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	ORIG	public void addframe ( boolean [ ] [ ] world ) throws ioexception { bufferedimage image = makeframe ( world ) ; try { iiometadatanode node = new iiometadatanode ( "javax_imageio_gif_image_1.0" ) ; iiometadatanode extension = new iiometadatanode ( "graphiccontrolextension" ) ; extension . setattribute ( "disposalmethod" , "none" ) ; extension . setattribute ( "userinputflag" , "false" ) ; extension . setattribute ( "transparentcolorflag" , "false" ) ; extension . setattribute ( "delaytime" , "1" ) ; extension . setattribute ( "transparentcolorindex" , "255" ) ; node . appendchild ( extension ) ; iiometadatanode appextensions = new iiometadatanode ( "applicationextensions" ) ; iiometadatanode appextension = new iiometadatanode ( "applicationextension" ) ; appextension . setattribute ( "applicationid" , "netscape" ) ; appextension . setattribute ( "authenticationcode" , "2.0" ) ; byte [ ] b = "!\u00ff\u000bnetscape2.0\u0003\u0001\u0000\u0000\u0000" . getbytes ( ) ; appextension . setuserobject ( b ) ; appextensions . appendchild ( appextension ) ; node . appendchild ( appextensions ) ; iiometadata metadata ; metadata = writer . getdefaultimagemetadata ( new imagetypespecifier ( image ) , null ) ; metadata . mergetree ( "javax_imageio_gif_image_1.0" , node ) ; iioimage t = new iioimage ( image , null , metadata ) ; writer . writetosequence ( t , null ) ; } catch ( iioinvalidtreeexception e ) { throw new ioexception ( e ) ; } }
tr	FAULT	public void endelement ( string uri , string localname , string atagname ) throws saxexception { if ( atagname . equals ( "testcaseitem" ) ) { string mykey = testcaselist . makenewid ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = cparser . getremnant ( mykey , "|" ) ; testcaselist . additem ( mykey , testcaseitem ) ; testcaseitem = new ctestitem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( worker . equals ( "shotitem" ) ) { shotitem . shotid = testcaseitem . shotlist . makenewid ( "sht" , 3 ) ; testcaseitem . shotlist . additem ( shotitem . shotid , shotitem ) ; shotitem = new cshotitem ( ) ; } else if ( atagname . equals ( "nonadminitem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makenewid ( "nad" , 6 ) ; testcaseitem . nonadmlist . additem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new cnonaditem ( ) ; } else if ( atagname . equals ( "expectresultitem" ) ) { expresitem . expectid = testcaseitem . ereslist . makenewid ( "ert" , 6 ) ; testcaseitem . ereslist . additem ( expresitem . expectid , expresitem ) ; expresitem = new ctextitem ( ) ; } else if ( atagname . equals ( "expectdoseitem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makenewid ( "dos" , 6 ) ; testcaseitem . edoselist . additem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new cdoseitem ( ) ; } else if ( atagname . equals ( "testtitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "testdesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "testnotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "createby" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "basedate" ) ) testcaseitem . basedate = parsedate ( curstr ) ; else if ( atagname . equals ( "lastname" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "firstname" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "birthdate" ) ) testcaseitem . birthdate = parsedate ( curstr ) ; else if ( atagname . equals ( "gendercd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "shotdate" ) ) shotitem . shotdate = parsedate ( curstr ) ; else if ( atagname . equals ( "vaccinecd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "mfrcd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "nonadmdate" ) ) nonaditem . nonadmdate = parsedate ( curstr ) ; else if ( atagname . equals ( "antseriescd" ) ) nonaditem . seriescd = curstr ; else if ( atagname . equals ( "reasoncd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "expecttxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "resulttxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "seriescd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "resultcd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "nextdosenum" ) ) expdoseitem . doseord = integer . parseint ( curstr ) ; else if ( atagname . equals ( "acceldate" ) ) expdoseitem . acceldate = parsedate ( curstr ) ; else if ( atagname . equals ( "recomdate" ) ) expdoseitem . recomdate = parsedate ( curstr ) ; else if ( atagname . equals ( "overduedate" ) ) expdoseitem . overduedate = parsedate ( curstr ) ; curstr = "" ; }
tr	FAULT	public static void main ( string [ ] args ) throws exception { double d = double . parsedouble ( mykey [ 0 ] ) ; long bits = double . doubletolongbits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissatodecimal ( mantissabits ) ; system . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	private arraylist < object > getlistfromurl ( string strurl , int tipo ) { try { url url = new url ( "http://dls98:8181" + strurl ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setrequestmethod ( "get" ) ; if ( conn . getresponsecode ( ) != 200 ) { return new arraylist < object > ( ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; string total = "" ; while ( ( output = br . readline ( ) ) != null ) { total += output ; } jsonarray lista = ( jsonarray ) ( new jsonparser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == cliente ) return clienteutils . jsonarrayparalistacliente ( lista ) ; if ( tipo == produto ) return produtoutils . jsonarrayparalistaproduto ( lista ) ; if ( tipo == pedido ) return pedidoutils . jsonarrayparalistapedido ( lista ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	FAULT	public static void main ( string [ ] args ) throws exception { int size = integer . parseint ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = packedlong . dashstartframe ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	ORIG	helloactionworld2 ( ) { super ( "hello action" ) ; final jlabel label ; setdefaultcloseoperation ( exit_on_close ) ; setlayout ( new boxlayout ( getcontentpane ( ) , boxlayout . y_axis ) ) ; label = new jlabel ( "button unpressed" ) ; add ( label ) ; jbutton button = new jbutton ( "press me" ) ; add ( button ) ; button . addactionlistener ( new actionlistener ( ) { private int count = 0 ; public void actionperformed ( actionevent e ) { count ++ ; label . settext ( "button pressed " + count + " time(s)" ) ; } } ) ; setsize ( 320 , 240 ) ; }
tr	ORIG	@ test public void testeprodutoinserido ( ) { produto p1 = new produto ( ) ; produto p2 = new produto ( ) ; produto p3 = new produto ( ) ; produto p4 = new produto ( ) ; produto p5 = new produto ( ) ; produto p6 = new produto ( ) ; p1 . setid ( 1337 ) ; p2 . setid ( 1338 ) ; p3 . setid ( 1339 ) ; p4 . setid ( 1340 ) ; p5 . setid ( 1341 ) ; p6 . setid ( 1342 ) ; arraylist < produto > novo = new arraylist < produto > ( ) ; arraylist < produto > antigo = new arraylist < produto > ( ) ; antigo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 ) ) ; novo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; arraylist < produto > aadicionar = new arraylist < produto > ( ) ; aadicionar . add ( p5 ) ; aadicionar . add ( p6 ) ; arraylist < produto > retornado = listautils . listaadicionarproduto ( novo , antigo ) ; assertequals ( aadicionar , retornado ) ; }
tr	ORIG	protected synchronized void logusage ( cloginprops aprops , string aip , string auser , string astatus , string areason ) { try { simpledateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss z" ) ; date dt = new date ( ) ; string datestr = df . format ( dt ) ; fileoutputstream logfos = new fileoutputstream ( aprops . usagelogfile , true ) ; printwriter logout = new printwriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . cappconsts . webappabbr + " " + manapp . cappconsts . webappversion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( aprops . errorlogfile , false , "dologin.logusage: " , ex ) ; } }
tr	ORIG	@ override public void update ( ) { inputprocess ( ) ; for ( iterator < gameobject > ite = getiterator ( ) ; ite . hasnext ( ) ; ) { gameobject go = ite . next ( ) ; if ( go instanceof starcharacter ) { ( ( starcharacter ) go ) . update ( gettimescale ( ) ) ; } else { go . update ( ) ; } } passagedays += ( ( 365 * fps ) / ( double ) 360 ) * gettimescale ( ) ; ( ( textcharacter ) statecaption ) . updatetext ( getstatestring ( ) ) ; }
tr	FAULT	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( true ) ; cloginprops lgprops = new cloginprops ( ) ; string myip = request . getremoteaddr ( ) ; string user = request . getparameter ( "userid" ) ; user = user . substring ( 0 , math . min ( user . length ( ) , lgprops . maxuserleng ) ) ; user = user . tolowercase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { string failreason = "invalid user name/password combination." ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } string passwd = request . getparameter ( "passwd" ) ; passwd = passwd . substring ( 0 , math . min ( passwd . length ( ) , lgprops . maxpassleng ) ) ; servletcontext scontext = this . getservletcontext ( ) ; cdbconnman dbconnman = ( cdbconnman ) scontext . getattribute ( "dbconnman" ) ; connection conn = dbconnman . getconnection ( ) ; cvaliduser valuser = new cvaliduser ( ) ; boolean isval = valuser . isvaliduser ( conn , user , passwd ) ; dbconnman . returnconnection ( conn ) ; if ( ! isval ) { string failreason = valuser . failreason ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } cuseritem myuser = new cuseritem ( ) ; myuser . setuserid ( user ) ; myuser . setrole ( valuser . role ) ; session . setattribute ( "useritem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logusage ( lgprops , myip , user , "success" , "invoke password change" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkpasschange ) ; session . setattribute ( "pwchange" , cvaliduser . pwchangerequire ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; return ; } logusage ( lgprops , withzone , user , "success" , "" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkloginsuccess ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	private static texture createtext ( string str , color color , font font , float width , float height ) { bufferedimage image = null ; graphics2d g = null ; try { image = new textureloader ( ) . createimagedata ( ( int ) width , ( int ) height ) ; g = image . creategraphics ( ) ; g . setfont ( font ) ; g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g . setcolor ( color ) ; g . drawstring ( str , 0 , ( int ) height - 4 ) ; return new textureloader ( ) . loadtexture ( image ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	@ override public void update ( ) { setangle ( owner . getangle ( ) ) ; super . update ( ) ; double theta = math . toradians ( getangle ( ) ) ; setx ( owner . getx ( ) + ( 5 * ( float ) math . sin ( - theta ) ) ) ; sety ( owner . gety ( ) + ( 5 * ( float ) math . cos ( - theta ) ) ) ; setx ( getx ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . cos ( theta ) ) ) ; sety ( gety ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . sin ( settestgroup ) ) ) ; remainshootdelayframe -- ; }
tr	FAULT	public char getmax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { swapr ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapl ( firstcollinenum ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	ORIG	public string buildwaiverstr ( connection aconn , int achild , int ashot ) { cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; string retstr = "line~" + integer . tostring ( ashot ) + "^" + "child_waiver_id~" + integer . tostring ( ashot ) + "^" + "child_id~" + integer . tostring ( achild ) + "^" + "series_id~" + seriesmap . mapcode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getymdstr ( nonadmdate ) + "^" + "date_created~" + getymdstr ( new date ( ) ) + "^" + "created_by~imm_assess_l^" ; return ( retstr ) ; }
tr	FAULT	@ override public void update ( ) { inputprocess ( ) ; if ( disposetimer > 0 ) { disposetimer -- ; } if ( disposetimer == 0 ) { setdispose ( ) ; } if ( ! isenable ( ) ) { return ; } setscale ( getscale ( ) + getvscale ( ) ) ; optionfactory ( getangle ( ) + getvangle ( ) ) ; setalpha ( getalpha ( ) + getvalpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; valpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; valpha = 0f ; } move ( ) ; }
tr	FAULT	public string exportlist ( connection aconn ) { stringbuilder retstr = new stringbuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" ) ; retstr . append ( "<testcaselist xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:nonamespaceschemalocation=\"testcaselist.xsd\">\n" ) ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { ctestitem myitem = ( ctestitem ) this . queue ( idx ) ; ctestitem testitem = new ctestitem ( ) ; testitem . copyitem ( myitem ) ; testitem . dbreaddetail ( aconn ) ; retstr . append ( testitem . exportitem ( ) ) ; } retstr . append ( "</testcaselist>\n" ) ; return ( retstr . tostring ( ) ) ; }
tr	FAULT	public patternpanel ( ) { super ( ) ; currentpattern = null ; setlayout ( new borderlayout ( ) ) ; ndaysid = new jlist ( ) ; add ( new jscrollpane ( guilist ) ) ; guilist . addlistselectionlistener ( new listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( ! e . getvalueisadjusting ( ) && ( patternlist != null ) ) { int sel = guilist . getselectedindex ( ) ; if ( sel != - 1 ) { currentpattern = patternlist . get ( sel ) ; onpatternchange ( ) ; } } } } ) ; }
tr	ORIG	public static void adicionarnovosclientesnacaptacaoparateste ( cliente cliente ) { try { url url = new url ( "http://dls98:8181/captacao/api/clientes.json" ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( true ) ; conn . setrequestmethod ( "post" ) ; conn . setrequestproperty ( "content-type" , "application/json" ) ; outputstream os = conn . getoutputstream ( ) ; jsonobject json = new jsonobject ( ) ; json . addproperty ( "id" , cliente . getid ( ) ) ; json . addproperty ( "nome" , cliente . getnome ( ) ) ; json . addproperty ( "email" , cliente . getemail ( ) ) ; json . addproperty ( "cpf" , cliente . getcpf ( ) ) ; json . addproperty ( "datanascimento" , cliente . getdatanascimento ( ) . tostring ( ) ) ; json . addproperty ( "celular" , cliente . getcelular ( ) ) ; os . write ( json . tostring ( ) . getbytes ( ) ) ; os . flush ( ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_created ) { throw new runtimeexception ( "failed : http error code : " + conn . getresponsecode ( ) ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; system . out . println ( "output from server .... \n" ) ; while ( ( output = br . readline ( ) ) != null ) { system . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public cvaliduser ( ) { dbprops = new dbconn . cdbprops ( ) ; loginprops = new cloginprops ( ) ; userid = "" ; role = cloginprops . rolenone ; passhash = "" ; pwchangedt = new date ( ) ; pwchangedt . settime ( pwchangedt . stagestate ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; lastfailure = new date ( 0 ) ; lastsuccess = new date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	FAULT	protected int findindex ( string astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareto ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( dbwriteresult1 ) ; }
tr	ORIG	@ override public void run ( ) { arraylist < object > clientescaptacaoobject = getlistfromurl ( "/captacao/api/clientes.json" , cliente ) ; arraylist < cliente > clientescaptacao = new arraylist < cliente > ( ) ; for ( int i = 0 ; i < clientescaptacaoobject . size ( ) ; i ++ ) clientescaptacao . add ( ( cliente ) clientescaptacaoobject . get ( i ) ) ; arraylist < cliente > clientesfaturamento = ( arraylist ) clienteutils . criaclienteresourceporttype ( ) . list ( ) ; system . out . println ( "\nclientes faturamento antes: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\n clientes captacao antes: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } arraylist < cliente > clientesnovos ; clientesnovos = listautils . listaadicionarcliente ( clientescaptacao , clientesfaturamento ) ; system . out . println ( "\ncliente para add: " ) ; for ( cliente a : clientesnovos ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } clienteutils . adicionarnovosclientes ( clientesnovos ) ; system . out . println ( "\nclientes faturamento depois: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\nclientes captacao depois: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "//////////////////////////////////////////" ) ; }
tr	ORIG	public multipartrequest ( httpservletrequest arequest , string asavedir , int amaxsize ) throws ioexception { if ( arequest == null ) throw new ioexception ( "null request" ) ; if ( asavedir == null ) throw new ioexception ( "null save directory" ) ; if ( amaxsize <= 0 ) throw new ioexception ( "invalid maxsize" ) ; frequest = arequest ; fsavedir = new file ( asavedir ) ; fmaxsize = amaxsize ; if ( ! fsavedir . isdirectory ( ) ) throw new ioexception ( "not a directory: " + fsavedir ) ; if ( ! fsavedir . canwrite ( ) ) throw new ioexception ( "directory not writable: " + fsavedir ) ; readrequest ( ) ; }
tr	ORIG	private bufferedimage writepixels ( bytebuffer pixels , int width , int height ) { int [ ] packedpixels = new int [ width * height * 3 ] ; int bufferind = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int r , g , b ; r = pixels . get ( bufferind ++ ) ; g = pixels . get ( bufferind ++ ) ; b = pixels . get ( bufferind ++ ) ; int index = ( row * width + col ) * 3 ; packedpixels [ index ++ ] = r ; packedpixels [ index ++ ] = g ; packedpixels [ index ] = b ; } } bufferedimage img = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; writableraster wr = img . getraster ( ) ; wr . setpixels ( 0 , 0 , width , height , packedpixels ) ; return img ; }
tr	FAULT	parampart ( string name , servletinputstream in , string boundary ) throws ioexception { super ( name ) ; partinputstream pis = new partinputstream ( in , boundary ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( pseudo ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . tobytearray ( ) ; }
tr	FAULT	public flowercharacter ( texture texture ) { settexture ( texture ) ; setwidth ( default_width ) ; setheight ( default_height ) ; setx ( random . nextint ( width + getwidth ( ) * 2 ) - getwidth ( ) ) ; sety ( - getheight ( ) ) ; setscale ( random ( 0.3f , 2.0f ) ) ; setangle ( random . nextint ( 360 ) ) ; setalpha ( 0.7f ) ; setcolor ( launch ( ) ) ; setmovemodex ( gamecharactermovemode . loop ) ; setmovemodey ( gamecharactermovemode . unlimited ) ; setvx ( random ( - 0.1f , 0.4f ) ) ; setvy ( getscale ( ) * 2 ) ; setvangle ( 4f ) ; }
tr	FAULT	public static string savepassword ( connection aconn , string auser , string aoldpw , string anewpw , string aconfpw ) { cloginprops setvertices = new cloginprops ( ) ; string oldpass = aoldpw . substring ( 0 , math . min ( aoldpw . length ( ) , lgprops . maxpassleng ) ) ; string newpass = anewpw . substring ( 0 , math . min ( anewpw . length ( ) , lgprops . maxpassleng ) ) ; string confpass = aconfpw . substring ( 0 , math . min ( aconfpw . length ( ) , lgprops . maxpassleng ) ) ; string curhash = dbgetpwhash ( aconn , auser ) ; string oldhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha1hash . tohash ( oldpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha256hash . tohash ( oldpass ) ; else oldhash = crypto . cmd5hash . tohash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "you have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "you cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . minpassleng ) return ( "your new password must be at least " + integer . tostring ( lgprops . minpassleng ) + " characters." ) ; int nummat = countmatches ( explower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . minpasslower ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpasslower ) + " lowercase characters." ) ; nummat = countmatches ( expupper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassupper ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassupper ) + " uppercase characters." ) ; nummat = countmatches ( expdigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassdigit ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassdigit ) + " numeric characters." ) ; nummat = countmatches ( expspecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassspecial ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassspecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "your new password contains disallowed characters." ) ; if ( countdiff ( newpass , oldpass ) < lgprops . minpassdiff ) return ( "your new password must contain at least " + integer . tostring ( lgprops . minpassdiff ) + " characters that were not used in you old password." ) ; string passhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha1hash . tohash ( newpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha256hash . tohash ( newpass ) ; else passhash = crypto . cmd5hash . tohash ( newpass ) ; string retstr = dbupdateitem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
va	ORIG	public static void addurl ( url u ) throws ioexception { urlclassloader sysloader = ( urlclassloader ) classloader . getsystemclassloader ( ) ; for ( url url : sysloader . geturls ( ) ) { if ( url . tostring ( ) . equalsignorecase ( u . tostring ( ) ) ) { logger . log ( level . info , "url {0} is already in the classpath" , u ) ; return ; } } class sysclass = urlclassloader . class ; try { method method = sysclass . getdeclaredmethod ( "addurl" , parameters ) ; method . setaccessible ( true ) ; method . invoke ( sysloader , new object [ ] { u } ) ; } catch ( nosuchmethodexception | securityexception | illegalaccessexception | illegalargumentexception | invocationtargetexception t ) { t . printstacktrace ( ) ; throw new ioexception ( "error  could not add url to system classloader" ) ; } }
va	FAULT	public int totaleval ( ) { int topleft , topright , bottomleft , bottomright , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; fieldsnotset < 10 ; r ++ ) { piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield ) { continue ; } if ( r > 0 && c > 0 ) { topleft = ds . getpiece ( r - 1 , c - 1 ) ; } else { topleft = 6 ; } if ( r > 0 && c < 9 ) { topright = ds . getpiece ( r - 1 , c + 1 ) ; } else { topright = 6 ; } if ( r < 9 && c > 0 ) { bottomleft = ds . getpiece ( r + 1 , c - 1 ) ; } else { bottomleft = 6 ; } if ( r < 9 && c < 9 ) { bottomright = ds . getpiece ( r + 1 , c + 1 ) ; } else { bottomright = 6 ; } if ( piece == draughtsstate . whitepiece ) { total += evalwhitepiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackpiece ) { total -= evalblackpiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . whiteking ) { total += evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackking ) { total -= evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else { total += evalempty ( r , c , topleft , topright , bottomleft , bottomright ) ; } } } return total ; }
va	ORIG	public static < p extends plugin > list < p > getplugins ( class < p > clazz , string ... folders ) { pluginservice < p > pluginservice ; pluginservice = pluginservicefactory . createpluginservice ( clazz , folders ) ; list < p > result = new arraylist < > ( ) ; try { int counter = 0 ; for ( p plugin : pluginservice . services ( ) ) { plugin . start ( ) ; log . log ( level . info , "adding plugin {0}!" , plugin . getname ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { log . severe ( "no plugins were found!!" ) ; } } catch ( serviceconfigurationerror | exception e ) { log . log ( level . severe , "service configuration error {0}" , e . tostring ( ) ) ; } return result ; }
va	ORIG	@ override public list < jcomponent > getpanels ( ) { if ( movelist == null ) { movelist = new jmovelist ( ) ; movelist . setmodel ( moves ) ; movelist . setname ( "moves" ) ; mlm = new movelistmanager ( movelist , boardpanel . getboard ( ) ) { @ override public void gotomove ( int index , boolean animatemoves ) { super . gotomove ( index , animatemoves ) ; reset ( null , board . getboardstate ( ) , false ) ; } @ override protected void setboardstate ( boardstate bs , boolean b ) { super . setboardstate ( bs , b ) ; reset ( null , board . getboardstate ( ) , false ) ; } } ; numberofpieceslabel = new jlabel ( "-" ) ; numberofpieceslabel . sethorizontalalignment ( jlabel . center ) ; numberofpieceslabel . setname ( "progress" ) ; settings = new jpanel ( ) ; settings . setname ( "options" ) ; beginstatecheckbox = new jcheckbox ( "start in begin state" ) ; beginstatecheckbox . setselected ( true ) ; settings . add ( beginstatecheckbox ) ; alloweditingcheckbox = new jcheckbox ( "allow editing of boardstate" ) ; alloweditingcheckbox . setselected ( false ) ; setuplistener = new setuplistener ( boardpanel . getboard ( ) ) ; boardpanel . getboard ( ) . addboardlistener ( setuplistener ) ; alloweditingcheckbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setuplistener . setenabled ( alloweditingcheckbox . isselected ( ) ) ; } } ) ; settings . add ( alloweditingcheckbox ) ; swapbutton = new jbutton ( "swap starting player" ) ; swapbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { board b = boardpanel . getboard ( ) ; boardstate bs = b . getboardstate ( ) ; b . startupdate ( ) ; bs . switchplayer ( ) ; b . endupdate ( ) ; reset ( currentgame , bs , true ) ; } } ) ; settings . add ( swapbutton ) ; } list < jcomponent > panellist = new arraylist < > ( ) ; panellist . add ( movelist ) ; panellist . add ( numberofpieceslabel ) ; panellist . add ( settings ) ; return panellist ; }
va	FAULT	private void filltable ( list < game > schedule ) { tablemodel model = new defaulttablemodel ( new string [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( game game : schedule ) { model . setvalueat ( game . first . getname ( ) , row , 0 ) ; model . setvalueat ( game . second . getname ( ) , row , 1 ) ; model . setvalueat ( game . getresult ( ) , row , 2 ) ; row = row + 1 ; } gamestable . setmodel ( model ) ; if ( model . sitemodel ( ) > 0 ) { gamestable . getselectionmodel ( ) . setselectioninterval ( 0 , 0 ) ; } }
va	FAULT	public list < string > seperatetables ( list < string > data , list < integer > linenums ) { list tables = new arraylist < string > ( ) ; for ( int k = 0 ; k < linenums . size ( ) ; k ++ ) { int start = linenums . oos ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; string [ ] entry = new string [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } string [ ] blub = ( string [ ] ) tables . get ( 0 ) ; return tables ; }
va	ORIG	public static int addvalue ( int r , int c , draughtsstate ds ) { int piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield || piece == draughtsstate . empty ) { return 0 ; } if ( piece == draughtsstate . whiteking ) { return 50 + king ; } if ( piece == draughtsstate . whitepiece ) { return calcplayground ( r , c , true ) + draught ; } if ( piece == draughtsstate . blackking ) { return - 50 - king ; } if ( piece == draughtsstate . blackpiece ) { return - calcplayground ( r , c , false ) - draught ; } return 0 ; }
va	ORIG	public int getnumanswers ( string [ ] lines ) { string first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexof ( " " ) ) ; int answers = 0 ; for ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i ] . indexof ( " " ) ; string current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
va	ORIG	private void continuegame ( final game game , final s gs ) { if ( ( currentgame == null ) || gs . isendstate ( ) ) { finishgame ( game , gs ) ; } else { updategui ( game , gs ) ; updategui ( ) ; player currentplayer ; if ( gs . iswhitetomove ( ) ) currentplayer = game . first ; else currentplayer = game . second ; if ( currentplayer . ishuman ( ) ) { currentsearchtask = null ; } else { currentsearchtask = getcomputermove ( currentplayer , gs , game ) ; } } }
va	FAULT	public static void criarclientepadraoparateste ( ) { xmlgregoriancalendar today = null ; try { today = datatypefactory . indi ( ) . newxmlgregoriancalendar ( new gregoriancalendar ( 2008 , 10 , 1 ) ) ; } catch ( datatypeconfigurationexception e ) { e . printstacktrace ( ) ; } cliente c1 = new cliente ( ) ; c1 . setcelular ( "999999999" ) ; c1 . setid ( ( long ) 1 ) ; c1 . setnome ( "testeid28" ) ; c1 . setcpf ( "111.111.111-11" ) ; c1 . setemail ( "joaninha@teste.com" ) ; c1 . setdatanascimento ( today ) ; adicionarnovosclientesnacaptacaoparateste ( c1 ) ; }
va	ORIG	private void fillplayerlabel ( player player , jlabel label ) { label . settext ( player . getname ( ) ) ; imageicon icon = player . geticon ( ) ; if ( icon != null ) { image image = icon . getimage ( ) ; if ( image . getwidth ( null ) > 128 || image . getheight ( null ) > 128 ) { icon = new imageicon ( icon . getimage ( ) . getscaledinstance ( 128 , 128 , java . awt . image . scale_smooth ) ) ; } label . seticon ( icon ) ; } }
va	FAULT	private void setplugins ( string pluginname , list < p > players , final list < p > enabledplayers ) { groupcheckbox . settext ( pluginname ) ; groupcheckbox . setselected ( true ) ; for ( final p p : players ) { final jcheckbox checkbox = new jcheckbox ( p . getname ( ) ) ; checkbox . setselected ( true ) ; checkbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( checkbox . isselected ( ) ) { queue . add ( p ) ; } else { enabledplayers . remove ( p ) ; } } } ) ; playerpanel . add ( checkbox ) ; enabledplayers . add ( p ) ; } }
va	FAULT	@ override public void run ( ) { arraylist < object > pedidocaptacaoobject = getlistfromurl ( "/captacao/api/pedido.json" , pedido ) ; arraylist < pedido > pedidocaptacao = new arraylist < pedido > ( ) ; for ( int i = 0 ; i < pedidocaptacaoobject . size ( ) ; i ++ ) pedidocaptacao . add ( ( pedido ) pedidocaptacaoobject . get ( i ) ) ; arraylist < notafiscal > notafiscalfaturamento = ( arraylist ) notafiscalutils . crianotafiscalresourceporttype ( ) . list ( ) ; for ( pedido pedido : pedidocaptacao ) { if ( pedido . getnotafiscal ( ) != null ) pedidocaptacao . remove ( pedido ) ; } for ( pedido winnerplayer : pedidocaptacao ) { long ultimoidnotafiscal = new long ( 0 ) ; boolean existenotafiscalparaoproduto = false ; for ( notafiscal notafiscal : notafiscalfaturamento ) { if ( notafiscal . getpedido ( ) == pedido . getid ( ) ) { existenotafiscalparaoproduto = true ; if ( notafiscal . getstatus ( ) == status . processada ) { notafiscalutils . crianotafiscalresourceporttype ( ) . delete ( notafiscal . getid ( ) ) ; notafiscal . setstatus ( status . emitida ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( notafiscal ) ; long idnotafiscal = notafiscal . getid ( ) ; pedido . setnotafiscal ( idnotafiscal ) ; } } if ( notafiscal . getid ( ) > ultimoidnotafiscal ) ultimoidnotafiscal = new long ( notafiscal . getid ( ) ) ; } if ( ! existenotafiscalparaoproduto ) { notafiscal novanotafiscal = new notafiscal ( ) ; novanotafiscal . setid ( ultimoidnotafiscal ) ; novanotafiscal . setnumero ( new long ( 0 ) ) ; novanotafiscal . setpedido ( pedido . getid ( ) ) ; novanotafiscal . setstatus ( null ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( novanotafiscal ) ; } } }
va	ORIG	private void updateranking ( ) { final string [ ] columns = { "name" , "w" , "d" , "l" , "p" } ; final class [ ] classes = { string . class , integer . class , integer . class , integer . class , integer . class } ; final set < player > players = new treeset < > ( new comparator < player > ( ) { @ override public int compare ( player o1 , player o2 ) { int result0 = getresult ( o1 ) ; int result1 = getresult ( o2 ) ; int compare = integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getname ( ) . comparetoignorecase ( o2 . getname ( ) ) ; } else { return compare ; } } } ) ; for ( game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingtable . setmodel ( new tablemodel ( ) { @ override public int getrowcount ( ) { return players . size ( ) ; } @ override public int getcolumncount ( ) { return columns . length ; } @ override public string getcolumnname ( int columnindex ) { return columns [ columnindex ] ; } @ override public class < ? > getcolumnclass ( int columnindex ) { return classes [ columnindex ] ; } @ override public boolean iscelleditable ( int rowindex , int columnindex ) { return false ; } @ override public object getvalueat ( int rowindex , int columnindex ) { player [ ] h = players . toarray ( new player [ 0 ] ) ; if ( columns [ columnindex ] . equals ( "name" ) ) return h [ rowindex ] . getname ( ) ; else { return "0" ; } } @ override public void setvalueat ( object avalue , int rowindex , int columnindex ) { } @ override public void addtablemodellistener ( tablemodellistener l ) { } @ override public void removetablemodellistener ( tablemodellistener l ) { } } ) ; }
va	FAULT	public void render ( graphics g ) { if ( w == 0 ) { gldeletetextures = getwidth ( ) ; h = getheight ( ) ; addkeylistener ( this ) ; addmouselistener ( this ) ; addmousemotionlistener ( this ) ; requestfocus ( ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . black ) ; g . filloval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
va	FAULT	@ override public swingboardpanel getboardpanel ( ) { if ( boardpanel == null ) { boardpanel = new swingboardpanel ( ) ; boardpanel . setscalable ( true ) ; boardpanel . setpreferredsize ( new dimension ( 400 , 400 ) ) ; board board = boardpanel . getboard ( ) ; moveselector ms = new moveselectoradvanced ( board . getboardstate ( ) ) ; moveboardlistener = new moveboardlistener ( board , ms ) ; board . addboardlistener ( moveboardlistener ) ; afilename . setenabled ( false ) ; board . addmovelistener ( new lastmovelistener ( new defaultfielddecorator ( ) ) ) ; } return boardpanel ; }
va	FAULT	public static < p extends player , plugin extends playerplugin < p >> list < p > showdialog ( component component , list < plugin > plugins ) { list < p > enabledplayers = new arraylist < > ( ) ; map < string , list < p >> map = new hashmap < > ( ) ; for ( plugin plugin : plugins ) { list < p > players = plugin . getplayers ( ) ; list < p > list = map . get ( plugin . getname ( ) ) ; if ( list == null ) { list = new arraylist < p > ( ) ; map . put ( plugin . getname ( ) , list ) ; } list . addall ( players ) ; } jpanel allpluginspanel = new jpanel ( ) ; allpluginspanel . setlayout ( new boxlayout ( allpluginspanel , boxlayout . y_axis ) ) ; for ( string pluginname : map . keyset ( ) ) { pluginselectionpanel panel = new pluginselectionpanel ( ) ; panel . setplugins ( pluginname , map . amasttbl ( pluginname ) , enabledplayers ) ; allpluginspanel . add ( panel ) ; } int option = joptionpane . showconfirmdialog ( component , allpluginspanel , "select players" , ok_cancel_option , plain_message ) ; if ( option == ok_option ) { return enabledplayers ; } else { return null ; } }
va	ORIG	public int evalking ( int r , int c , int topleft , int topright , int bottomleft , int bottomright ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getpiece ( r + 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getpiece ( r + 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getpiece ( r - 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getpiece ( r - 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
va	FAULT	@ test public void testelistaadicionarcliente ( ) { cliente c1 = new cliente ( ) ; cliente c2 = new cliente ( ) ; cliente c3 = new cliente ( ) ; cliente c4 = new cliente ( ) ; cliente c5 = new cliente ( ) ; cliente c6 = new cliente ( ) ; cliente c7 = new cliente ( ) ; cliente c8 = new cliente ( ) ; cliente c9 = new cliente ( ) ; cliente getmemorypoolmxbeans = new cliente ( ) ; c1 . setid ( 1 ) ; c2 . setid ( 2 ) ; c3 . setid ( 3 ) ; c4 . setid ( 4 ) ; c5 . setid ( 5 ) ; c6 . setid ( 6 ) ; c7 . setid ( 7 ) ; c8 . setid ( 8 ) ; c9 . setid ( 9 ) ; c10 . setid ( 10 ) ; arraylist < cliente > nova = new arraylist < cliente > ( ) ; nova . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; arraylist < cliente > antiga = new arraylist < cliente > ( ) ; antiga . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; arraylist < cliente > result = new arraylist < cliente > ( ) ; result . addall ( arrays . aslist ( c8 , c9 , c10 ) ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; }
va	ORIG	private void updatepiececount ( draughtsstate gs ) { int [ ] pieces = gs . getpieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( draughts . iswhite ( piece ) ) whites ++ ; else if ( draughts . isblack ( piece ) ) blacks ++ ; } string status = "" + whites + " - " + blacks ; numberofpieceslabel . settext ( status ) ; }
te	FAULT	private void train ( inputiterable < string > traindata ) { int firsthash = 1 ; int secondhash = - 1 ; int firstinsertcount = 0 ; int secondinsertcount = 0 ; wrappedobject first , itr ; for ( parseresult < string > row : traindata ) { first = new wrappedobject ( row . getfirstnode ( ) ) ; second = new wrappedobject ( row . getsecondnode ( ) ) ; if ( ! hash . containskey ( first ) ) { if ( firstinsertcount > 10000 ) { firstinsertcount = 0 ; firsthash ++ ; } else { firstinsertcount ++ ; } hash . put ( first , firsthash ) ; } if ( ! hash . containskey ( second ) ) { if ( secondinsertcount > 10000 ) { secondinsertcount = 0 ; secondhash -- ; } else { secondinsertcount ++ ; } hash . put ( second , secondhash ) ; } } }
te	ORIG	public k advise ( set < k > currentset , long position ) { k advice = null ; long max = long . min_value ; for ( k inmem : currentset ) { if ( evicted . contains ( inmem ) ) { continue ; } list < long > current = distances . get ( inmem ) ; if ( current == null ) { advice = inmem ; system . err . println ( "not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { system . out . println ( inmem + " was already skipped at position " + position ) ; distances . remove ( inmem ) ; advice = inmem ; break ; } long closestforcurrent = current . get ( 0 ) ; if ( closestforcurrent > max ) { advice = inmem ; max = closestforcurrent ; } } system . out . println ( "suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
te	FAULT	public void initframe ( double time ) { count = count + 1 ; for ( int i = 0 ; i < pixinverse . length ; i ++ ) { pixinverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballbearing . getmatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotatez ( math . pi * time / 2 ) ; equalsignorecase = | . getmatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotatey ( math . pi / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getmatrix ( ) . identity ( ) ; setvertices ( world ) ; maketraps ( ) ; }
te	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; world = new geometry ( h , w ) ; head = new geometry ( h , w ) ; head . makesphere ( 10 , 10 ) ; head . local . translate ( 0 , - 2 , 0 ) ; head . local . scale ( 0.75 , 0.75 , 0.75 ) ; world . add ( head ) ; body = new geometry ( h , w ) ; body . makecube ( ) ; body . local . translate ( 0 , 3 , 0 ) ; body . local . scale ( 2 , 2 , 2 ) ; head . add ( body ) ; leftupperarm = new geometry ( h , w ) ; leftupperarm . makesphere ( 25 , 25 ) ; leftupperarm . local . translate ( - 1.8 , - 0.5 , 0 ) ; leftupperarm . local . rotatez ( math . pi / 8 ) ; leftupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( leftupperarm ) ; leftelbow = new geometry ( h , w ) ; leftelbow . makesphere ( 50 , 50 ) ; leftelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; leftelbow . local . translate ( - 9 , 0 , 0 ) ; leftelbow . local . rotatez ( math . pi / 2 ) ; leftupperarm . add ( leftelbow ) ; leftlowerarm = new geometry ( h , w ) ; leftlowerarm . makesphere ( 10 , 10 ) ; leftlowerarm . local . scale ( 5 , 1 , 1 ) ; leftlowerarm . local . translate ( - 1 , 0 , 0 ) ; leftelbow . add ( leftlowerarm ) ; rightupperarm = new geometry ( h , w ) ; rightupperarm . makesphere ( 25 , 25 ) ; rightupperarm . local . translate ( 1.8 , - 0.5 , 0 ) ; rightupperarm . local . rotatez ( - math . pi / 8 ) ; rightupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( rightupperarm ) ; rightelbow = new geometry ( h , w ) ; rightelbow . makesphere ( 50 , 50 ) ; rightelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; rightelbow . local . translate ( 9 , 0 , 0 ) ; rightelbow . local . rotatez ( - math . pi / 2 ) ; rightupperarm . add ( rightelbow ) ; rightlowerarm = new geometry ( h , w ) ; rightlowerarm . makesphere ( 10 , 10 ) ; rightlowerarm . local . scale ( 5 , 1 , 1 ) ; rightlowerarm . local . translate ( 1 , 0 , 0 ) ; rightelbow . add ( rightlowerarm ) ; leftleg = new geometry ( h , w ) ; leftleg . makecylinder ( 10 , 10 ) ; leftleg . local . rotatex ( - math . pi / 2 ) ; leftleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; leftleg . local . translate ( - 2 , 0 , 2.2 ) ; body . add ( leftleg ) ; leftfeet = new geometry ( h , w ) ; leftfeet . makesphere ( 20 , 20 ) ; leftfeet . local . scale ( 1 , 2 , 0.1 ) ; leftfeet . local . translate ( 0 , 0.5 , 10 ) ; leftleg . add ( leftfeet ) ; rightleg = new geometry ( h , w ) ; rightleg . makecylinder ( 10 , 10 ) ; rightleg . local . rotatex ( - math . pi / 2 ) ; rightleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; rightleg . local . translate ( 2 , 0 , 2.2 ) ; body . add ( rightleg ) ; rightfeet = new geometry ( h , w ) ; rightfeet . makesphere ( 20 , 20 ) ; rightfeet . local . scale ( 1 , 2 , 0.1 ) ; rightfeet . local . translate ( 0 , 0.5 , 10 ) ; rightleg . add ( rightfeet ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; head . global . identity ( ) ; head . local . rotatey ( math . sin ( time ) / 10 ) ; head . global . rightmultiply ( world . global ) ; head . global . rightmultiply ( head . local ) ; head . drawmyfigure ( g , w , h , head . global ) ; body . global . identity ( ) ; body . global . rightmultiply ( head . global ) ; body . global . rightmultiply ( body . local ) ; body . drawmyfigure ( g , w , h , body . global ) ; g . setcolor ( color . red ) ; leftupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; leftupperarm . global . identity ( ) ; leftupperarm . global . rightmultiply ( body . global ) ; leftupperarm . global . rightmultiply ( leftupperarm . local ) ; leftupperarm . drawmyfigure ( g , w , h , leftupperarm . global ) ; g . setcolor ( color . green ) ; leftelbow . global . identity ( ) ; leftelbow . global . rightmultiply ( leftupperarm . global ) ; leftelbow . global . rightmultiply ( leftelbow . local ) ; leftelbow . drawmyfigure ( g , w , h , leftelbow . global ) ; g . setcolor ( color . gray ) ; leftlowerarm . global . identity ( ) ; leftlowerarm . global . rightmultiply ( leftelbow . global ) ; leftlowerarm . global . rightmultiply ( leftlowerarm . local ) ; leftlowerarm . drawmyfigure ( g , w , h , leftlowerarm . global ) ; g . setcolor ( color . red ) ; rightupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; rightupperarm . global . identity ( ) ; rightupperarm . global . rightmultiply ( body . global ) ; rightupperarm . global . rightmultiply ( rightupperarm . local ) ; rightupperarm . drawmyfigure ( g , w , h , rightupperarm . global ) ; g . setcolor ( color . green ) ; rightelbow . global . identity ( ) ; rightelbow . global . rightmultiply ( rightupperarm . global ) ; rightelbow . global . rightmultiply ( rightelbow . local ) ; rightelbow . drawmyfigure ( g , w , h , rightelbow . global ) ; g . setcolor ( color . gray ) ; rightlowerarm . global . identity ( ) ; rightlowerarm . global . rightmultiply ( rightelbow . global ) ; rightlowerarm . global . rightmultiply ( rightlowerarm . local ) ; rightlowerarm . drawmyfigure ( g , w , h , rightlowerarm . global ) ; g . setcolor ( color . orange ) ; leftleg . global . identity ( ) ; leftleg . global . rightmultiply ( body . global ) ; leftleg . global . rightmultiply ( leftleg . local ) ; leftleg . drawmyfigure ( g , w , h , leftleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; leftfeet . global . identity ( ) ; leftfeet . global . rightmultiply ( leftleg . global ) ; leftfeet . global . rightmultiply ( leftfeet . local ) ; leftfeet . drawmyfigure ( g , w , h , leftfeet . global ) ; g . setcolor ( color . orange ) ; rightleg . global . identity ( ) ; rightleg . global . rightmultiply ( body . global ) ; rightleg . global . rightmultiply ( rightleg . local ) ; rightleg . drawmyfigure ( g , w , h , rightleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; rightfeet . global . identity ( ) ; rightfeet . global . rightmultiply ( rightleg . global ) ; rightfeet . global . rightmultiply ( rightfeet . local ) ; rightfeet . drawmyfigure ( g , w , h , rightfeet . global ) ; }
te	ORIG	private synchronized void start ( ) throws exception { bufferedreader readme = new bufferedreader ( new filereader ( "rels2" ) ) ; inputiterable < string > iterable = new csvinputiterable ( readme ) ; hasher hasher = new trainabletwostreamhasher ( iterable ) ; wrappedstring . sethasher ( hasher ) ; readme = new bufferedreader ( new filereader ( "rels2" ) ) ; iterable = new csvinputiterable ( readme ) ; arrayhashmapoptionfactory fac = new arrayhashmapoptionfactory ( new file ( "target/testrun" ) ) ; leastrecentlyused < wrappedstring > strategy = new leastrecentlyused < wrappedstring > ( ) ; store = new partitionedhashmap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( parseresult < string > result : iterable ) { if ( line % 25000 == 0 ) { system . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getfirstnode ( ) ) == null ) { store . put ( result . getfirstnode ( ) , line ) ; } if ( store . get ( result . getsecondnode ( ) ) == null ) { store . put ( result . getsecondnode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
te	FAULT	@ test public void testsanity ( ) throws exception { file storedir = new file ( "target/foo" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 3 ) , "000" ) ; asserttrue ( option . inmemory ( ) ) ; string reallylongstring = "@@@@@@@@@@@@@@@@@fffffffffffff\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long foovalue = new long ( 1333243243243243211 ) ; option . getvalue ( ) . put ( reallylongstring , foovalue ) ; asserttrue ( option . inmemory ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; asserttrue ( option . inmemory ( ) ) ; option . persist ( ) ; assertfalse ( option . inmemory ( ) ) ; assertnull ( option . getmap ( ) ) ; option . restore ( ) ; asserttrue ( option . inmemory ( ) ) ; assertnotnull ( option . getvalue ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; }
te	ORIG	public boolean issubset ( string [ ] subset , string [ ] set ) { for ( string subelem : subset ) { if ( subelem . equals ( subset [ 0 ] ) ) { continue ; } if ( subelem . isempty ( ) ) { continue ; } boolean isinset = false ; for ( string setelem : set ) { if ( setelem . isempty ( ) ) { continue ; } if ( subelem . equals ( setelem ) ) { isinset = true ; } } if ( ! isinset ) { return false ; } } return true ; }
te	ORIG	public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new font ( "sanserif" , font . bold , fontheight = w / 20 ) ; } g . setfont ( font ) ; g . setcolor ( bgcolor ) ; g . fillrect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setcolor ( i == i ? ismousedown ? color . blue : hovercolor : color . white ) ; g . fillrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setcolor ( color . black ) ; g . drawrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawstring ( "cdefgabc" . substring ( i , i + 1 ) , x ( i ) - fontheight / 3 , h / 2 + fontheight / 3 ) ; } g . drawstring ( instrument . name ( id ) , fontheight / 6 , fontheight ) ; }
te	ORIG	public void drawmyfigure ( graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectpoint ( point0 , a ) ; projectpoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawline ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawline ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
te	ORIG	public void applyfog ( int [ ] rgb , double dist , double [ ] v ) { double k = 0.05 ; double [ ] fogcolor = { 150 , 150 , 150 } ; double a = math . pow ( 2 , - k * dist ) ; double fx = ( ( double ) v [ 0 ] - w / 2 ) / w ; double fy = ( ( double ) v [ 1 ] - h / 2 ) / h ; double temp = math . sin ( improvednoise . noise ( 4 * fx , 4 * fy , time * 1000 ) ) ; rgb [ 0 ] = ( int ) ( ( ( 1 - a ) * rgb [ 0 ] + a * fogcolor [ 0 ] ) * temp ) ; rgb [ 1 ] = ( int ) ( ( ( 1 - a ) * rgb [ 1 ] + a * fogcolor [ 1 ] ) * temp ) ; rgb [ 2 ] = ( int ) ( ( ( 1 - a ) * rgb [ 2 ] + a * fogcolor [ 2 ] ) * temp ) ; }
te	FAULT	@ override public void hit ( k key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } node < k > previous = findprevious ( key ) ; if ( previous == null ) { node < k > toinsert = new node < k > ( ) ; toinsert . content = key ; toinsert . next = head . next ; head . next = toinsert ; if ( lru == head ) { lru = toinsert ; } } else { node < k > actual = previous . setmat ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
te	ORIG	public map < string , float > askvar ( ) { string varname ; float value ; map < string , float > vars = new hashmap < > ( ) ; scanner in = new scanner ( system . in ) ; system . out . println ( "enter a random variable: " ) ; varname = in . nextline ( ) ; system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; boolean loop = true ; scanner sc = new scanner ( system . in ) ; while ( loop ) { system . out . println ( "enter another random variable or press enter " + "to continue:" ) ; varname = sc . nextline ( ) ; if ( varname . equals ( "" ) ) { break ; } system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; } return vars ; }
te	ORIG	public void render ( graphics g ) { double time2 = system . currenttimemillis ( ) / 1000.0 ; if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; projectpoint ( center , actualcenter ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; indi ( g , 10 * math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * math . sin ( time2 ) ) ; }
te	FAULT	public long persist ( ) throws ioexception { if ( wrapped == null ) { return - 1 ; } long byteswritten = 0 ; randomaccessfile writer = new randomaccessfile ( store , "rw" ) ; writer . setlength ( 0 ) ; writer . writeint ( wrapped . getkeys ( ) . length ) ; byteswritten += 4 ; writer . writeint ( wrapped . size ( ) ) ; byteswritten += 4 ; string currentkey ; for ( int i = 0 ; i < wrapped . getkeys ( ) . length ; i ++ ) { currentkey = wrapped . getkeys ( ) [ i ] ; if ( currentkey == null || arrayhashmap . tombstone . task ( currentkey ) ) continue ; writer . writeint ( currentkey . length ( ) ) ; byteswritten += 4 ; writer . writechars ( currentkey ) ; byteswritten += currentkey . length ( ) * 2 ; writer . writelong ( wrapped . getvalues ( ) [ i ] ) ; byteswritten += 8 ; } wrapped = null ; writer . close ( ) ; return byteswritten ; }
te	FAULT	private void train ( iterable < k > traindata ) { system . out . println ( "training..." ) ; long start = system . currenttimemillis ( ) ; long position = 0 ; list < long > getqueryid ; for ( k datum : traindata ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new linkedlist < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } system . out . println ( "done  took " + ( system . currenttimemillis ( ) - start ) / 1000 + " ms" ) ; }
te	FAULT	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 0 ] != 0 ) && ( testextquery [ index ] . getmat ( ) . mirrorcolor [ 1 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 2 ] != 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; reflectedray [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; reflectedray [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; reflectedray [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = reflectedray [ 0 ] ; ww [ 1 ] = reflectedray [ 1 ] ; ww [ 2 ] = reflectedray [ 2 ] ; int [ ] refcolor = { 0 , 0 , 0 } ; if ( tracemyray ( vv , ww , refcolor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) + refcolor [ i ] * allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) ; } } } } }
te	FAULT	@ override public void launch ( ) { running = new thread ( new runnable ( ) { @ override public void run ( ) { memorymxbean mbean = managementfactory . getmemorymxbean ( ) ; notificationemitter firstcollinenum = ( notificationemitter ) mbean ; emitter . addnotificationlistener ( new notificationlistener ( ) { @ override public void handlenotification ( notification notification , object handback ) { if ( notification . gettype ( ) . equals ( memorynotificationinfo . memory_threshold_exceeded ) ) { for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } } } } , null , null ) ; } } ) ; running . setdaemon ( true ) ; running . start ( ) ; }
te	FAULT	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getwidth ( ) ; cube . vertices = vertices ; cube . faces = faces ; m = new matrix ( ) ; sphere . makesphere ( ) ; torus . maketorus ( 0.5 ) ; ew . makecylinder ( 1 ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; m . identity ( ) ; m . translate ( 2 , 2 , 0 ) ; m . rotatey ( math . sin ( time ) ) ; cube . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . blue ) ; m . identity ( ) ; m . translate ( - 2 , - 2 , 0 ) ; m . rotatex ( math . sin ( time ) ) ; sphere . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( - 2 , 2 , 0 ) ; m . scale ( 1 , 1 , 5 ) ; m . rotatez ( math . sin ( time ) ) ; torus . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( 2 , - 2 , 0 ) ; m . rotatez ( math . sin ( time ) ) ; cylinder . drawmyfigure ( g , w , h , m ) ; }
te	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; myx = w / 2 ; myy = h - 10 ; buslength = 100 ; busheight = 20 ; balldia = buslength / 2 ; ballradius = balldia / 2 ; bally = 0 ; } g . setcolor ( color . cyan ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . gray ) ; g . fill3drect ( w - 100 , 0 , 100 , 50 , ! ismymousedown ) ; g . setcolor ( color . white ) ; g . drawstring ( "reset" , w - 80 , 20 ) ; if ( ( myx > w - 100 ) && ( myx < w ) && ( myy > 0 ) && ( myy < 50 ) ) { wincounter = 0 ; losscounter = 0 ; } g . setcolor ( color . blue ) ; g . setfont ( winloss ) ; g . drawstring ( "wins " + wincounter , 0 , 20 ) ; g . drawstring ( "losses " + losscounter , 0 , 60 ) ; g . setcolor ( color . red ) ; g . fill3drect ( myx - ( buslength / 2 ) , h - ( busheight / 2 ) , buslength , busheight , ! ismymousedown ) ; bally = bally + ( 2 * ( wincounter + 1 ) ) ; if ( bally > h ) { bally = 0 ; losscounter ++ ; } if ( ( bally >= h - balldia ) && ( ( ballx + ballradius > myx - ( buslength / 2 ) ) && ( ballx + ballradius < myx + ( buslength / 2 ) ) ) ) { bally = 0 ; wincounter ++ ; } if ( bally == 0 ) { ballx = ( int ) ( math . random ( ) * w ) ; if ( ballx >= ( w - balldia ) ) { ballx = ballx - balldia ; } } g . setcolor ( color . orange ) ; g . filloval ( ballx , bally , balldia , balldia ) ; }
te	FAULT	public void setpixel ( int x , int y , int rgb [ ] ) { double fx = ( ( double ) x - w / 2 ) / w ; double fy = ( ( double ) y - h / 2 ) / h ; double dx = math . abs ( x - w / 2 ) ; double dy = math . abs ( y - h / 2 ) ; double dist = math . sqrt ( dx * dx + dy * dy ) ; for ( int j = 0 ; j < 3 ; j ++ ) { int temp = ( int ) ( math . sin ( ( t ) * improvednoise . noise ( 4 * fx , 4 * fy , t ) ) * 128 ) ; double gap = math . abs ( dist - t % math . sqrt ( w * w + h * h ) ) ; double gap1 = math . abs ( dist - ( ( t + 100 ) % math . sqrt ( w * w + h * h ) ) ) ; double actconnman = math . abs ( dist - ( ( t + 200 ) % math . sqrt ( w * w + h * h ) ) ) ; double gap3 = math . abs ( dist - ( ( t + 300 ) % math . sqrt ( w * w + h * h ) ) ) ; if ( gap < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap ) ; else if ( gap1 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap1 ) ; else if ( gap2 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap2 ) ; else if ( gap3 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap3 ) ; else rgb [ j ] = temp ; } }
