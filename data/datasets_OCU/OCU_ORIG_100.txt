tr	8	decisiontreeimpl ( dataset train ) { if ( train == null || train . instances == null || train . instances . isempty ( ) ) { return ; } list < attribute > attributes = new arraylist < attribute > ( ) ; for ( instance instance : train . instances ) { for ( int i = 0 ; i < instance . attributes . size ( ) ; i ++ ) { if ( i > attributes . size ( ) - 1 ) { attributes . add ( new attribute ( i ) ) ; } attributes . get ( i ) . addvalue ( instance . attributes . get ( i ) ) ; } } root = traintree ( train . instances , attributes , train . instances , "root" ) ; }
tr	4	public void writeall ( java . sql . resultset rs , boolean includecolumnnames ) throws sqlexception , ioexception { resultsetmetadata metadata = rs . getmetadata ( ) ; if ( includecolumnnames ) { writecolumnnames ( metadata ) ; } int columncount = metadata . getcolumncount ( ) ; while ( rs . next ( ) ) { string [ ] nextline = new string [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { nextline [ i ] = getcolumnvalue ( rs , metadata . getcolumntype ( i + 1 ) , i + 1 ) ; } writenext ( nextline ) ; } }
tr	6	@ suppresswarnings ( "rawtypes" ) private class [ ] obtenerclasesdelpaquete ( string packagename ) throws classnotfoundexception , ioexception { classloader classloader = thread . currentthread ( ) . getcontextclassloader ( ) ; assert classloader != null ; string path = packagename . replace ( '.' , '/' ) ; logger . info ( "path: " + path ) ; enumeration < url > resources = classloader . getresources ( path ) ; list < file > dirs = new arraylist < file > ( ) ; while ( resources . hasmoreelements ( ) ) { url resource = resources . nextelement ( ) ; dirs . add ( new file ( resource . getfile ( ) ) ) ; logger . info ( resource . tostring ( ) ) ; } arraylist < class > classes = new arraylist < class > ( ) ; for ( file directory : dirs ) { classes . addall ( buscarclasesendirectorio ( directory , packagename ) ) ; } return classes . toarray ( new class [ classes . size ( ) ] ) ; }
tr	1	public testgraphics ( ) { super ( "pert chart" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; tasklist = new listoftasks ( ) ; jpanel mainpanel = new jpanel ( ) ; mainpanel . setlayout ( new borderlayout ( ) ) ; getcontentpane ( ) . add ( mainpanel ) ; jpanel graphicspanel = new jpanel ( ) ; gwindow window = new gwindow ( ) ; mainpanel . add ( window . getcanvas ( ) , borderlayout . center ) ; scene = new gscene ( window , "scene" ) ; double w0 [ ] = { 0.0 , 1500.0 , 0.0 } ; double w1 [ ] = { 1500.0 , 1500.0 , 0.0 } ; double w2 [ ] = { 0.0 , 0.0 , 0.0 } ; scene . setworldextent ( w0 , w1 , w2 ) ; scene . shouldzoomonresize ( false ) ; gstyle style = new gstyle ( ) ; style . setforegroundcolor ( color . blue ) ; style . setbackgroundcolor ( new color ( 255 , 255 , 255 ) ) ; style . setfont ( new font ( "dialog" , font . bold , 10 ) ) ; scene . setstyle ( style ) ; textinput input = new textinput ( ) ; while ( input . getfinished ( ) == false ) { input . inputtasknum ( ) ; input . inputparentnum ( ) ; input . inputfinished ( ) ; task parenttask = null ; int parentcounter = 0 ; double xposition = 300 ; for ( task task : tasklist . gettasklist ( ) ) { if ( task . gettasknumber ( ) == input . getparentnum ( ) ) { parenttask = task ; } if ( task . getparent ( ) == parenttask ) { parentcounter ++ ; } } double yposition = 500 + parentcounter * 300 ; tasklist . addtask ( new task ( "name" , input . gettasknum ( ) , 2 , "startdate" , "enddate" , scene , parenttask , xposition , yposition ) ) ; } pack ( ) ; setsize ( new dimension ( 500 , 500 ) ) ; setvisible ( true ) ; }
tr	5	public tournament ( round firstround , hashtable < string , compiledstat > compiledstats , referee scoreable ) { if ( md5 == null ) { try { md5 = messagedigest . getinstance ( "md5" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } } this . compiledstats = compiledstats ; this . scoreable = scoreable ; round duplicate = new round ( ) ; for ( game game : firstround ) { game dupegame = new game ( game . teams , scoreable ) ; dupegame . name = game . name ; duplicate . add ( dupegame ) ; } rounds . add ( duplicate ) ; appendnextround ( duplicate ) ; }
tr	8	int onreceiverequest ( status status , movemessage m ) { int index = - 1 ; int hand [ ] = m . state . hand ; int their_card = m . state . card ; sort ( hand ) ; if ( m . state . total_tricks == 0 && m . state . in_challenge == false && m . state . card > 0 && wintime < 9 ) { double prob = 0.6 + ( hand [ 2 ] - 10 ) * 0.2 ; if ( prob > math . random ( ) ) return 9999 ; } if ( their_card <= 0 ) { if ( wintime == 1 && losetime == 1 && tiedtime == 0 ) { return hand . length - 1 ; } if ( totaltime == 0 ) { int idx = - 1 ; for ( int i = 0 ; i < hand . length ; i ++ ) { if ( hand [ i ] < 10 ) { idx = i ; break ; } } index = 2 > idx ? 2 : idx ; } else if ( totaltime == 1 ) { index = 2 ; } else { index = secondbigger ( hand ) ; } if ( tiedtime == 0 ) { if ( wintime == 1 && losetime == 2 ) index = 0 ; } else { if ( losetime >= 1 ) index = 0 ; } } else { theirlastcard = their_card ; if ( ( m . state . card > hand [ hand . length - 1 ] ) && ( ( m . state . card - hand [ hand . length - 1 ] ) > 6 ) ) { index = hand . length - 1 ; } else if ( ( findcard ( hand , m . state . card ) == hand . length - 1 || findcard ( hand , m . state . card ) == hand . length - 2 ) && ( m . state . card <= 4 ) ) { index = findcard ( hand , m . state . card ) ; } else { index = minbigger ( hand , m . state . card ) ; } } mylastcard = hand [ index ] ; if ( index >= hand . length ) { system . err . println ( "w:" + wintime + " l:" + losetime + " t:" + tiedtime ) ; system . err . println ( "hand: " ) ; for ( int x : hand ) { system . err . print ( x + " " ) ; } system . err . println ( "\\nindex:" + index + "\\n" ) ; return 0 ; } return index ; }
tr	3	private attribute importance ( list < attribute > attributes , list < instance > examples ) { double winningentropy = double . negative_infinity ; attribute winningattribute = null ; double givencredit = 0 ; for ( instance example : examples ) { if ( "1" . equals ( example . label ) ) { givencredit ++ ; } } double creditentropy = booleanentropy ( givencredit / examples . size ( ) ) ; system . out . println ( "h(credit) = " + creditentropy ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { attribute attribute = attributes . get ( i ) ; map < string , double > attributescore = new linkedhashmap < string , double > ( attribute . values . size ( ) ) ; map < string , double > attributescoregivencredit = new linkedhashmap < string , double > ( attribute . values . size ( ) ) ; int exampleswithcredit = 0 ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { double midpoint = midpoint ( examples , attribute . index ) ; list < instance > examplesgivencredits = new arraylist < instance > ( ) ; for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; if ( "1" . equals ( example . label ) ) { examplesgivencredits . add ( example ) ; } } double midpointgivencredits = midpoint ( examplesgivencredits , attribute . index ) ; for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; int value = integer . parseint ( example . attributes . get ( i ) ) ; string larger = string . valueof ( value > midpoint ) ; double score = attributescore . get ( larger ) ; if ( score == null ) { score = 0.0 ; } attributescore . put ( larger , score + 1 ) ; if ( "1" . equals ( example . label ) ) { string largergivencredit = string . valueof ( value > midpointgivencredits ) ; double scoregivencredit = attributescoregivencredit . get ( largergivencredit ) ; if ( scoregivencredit == null ) { scoregivencredit = 0.0 ; } attributescoregivencredit . put ( largergivencredit , scoregivencredit + 1 ) ; exampleswithcredit ++ ; } } } else { for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; string value = example . attributes . get ( i ) ; double score = attributescore . get ( value ) ; if ( score == null ) { score = 0.0 ; } attributescore . put ( value , score + 1 ) ; if ( "1" . equals ( example . label ) ) { double scoregivencredit = attributescoregivencredit . get ( value ) ; if ( scoregivencredit == null ) { scoregivencredit = 0.0 ; } attributescoregivencredit . put ( value , scoregivencredit + 1 ) ; exampleswithcredit ++ ; } } } double attributeentropy = 0 ; for ( string value : attributescore . keyset ( ) ) { double score = attributescore . get ( value ) ; double scoregivencredit = attributescoregivencredit . get ( value ) ; if ( score != null && scoregivencredit != null && score != 0 && scoregivencredit != 0 ) { attributeentropy += ( score / examples . size ( ) * booleanentropy ( scoregivencredit / exampleswithcredit ) ) ; } } double totalentropy = creditentropy - attributeentropy ; system . out . println ( "i(credit;" + attribute . category . getname ( ) + ") = " + totalentropy ) ; if ( totalentropy >= winningentropy ) { winningentropy = totalentropy ; winningattribute = attribute ; } } return winningattribute ; }
tr	4	public rsa ( long a , long b , boolean fix ) { if ( fix ) { this . a = a ; this . b = b ; } else { this . a = prime ( a ) ; this . b = prime ( b ) ; } n = this . a * this . b ; m = ( this . a - 1 ) * ( this . b - 1 ) ; e = coprime ( m ) ; d = modulo_inverse ( e , m ) ; debug . print ( "n is " + n ) ; debug . print ( "m is " + m ) ; debug . print ( "e is " + e ) ; debug . print ( "d is " + d ) ; }
tr	9	public static round parsefirstround ( reader reader , hashtable < string , team > teams ) throws exception { round games = new round ( ) ; csvreader csvreader = new csvreader ( reader ) ; list < string [ ] > lines ; try { lines = csvreader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( string [ ] tokens : lines ) { if ( tokens . length == 1 && tokens [ 0 ] . trim ( ) . length ( ) == 0 ) continue ; team [ ] gameteams = new team [ 2 ] ; gameteams [ 0 ] = teams . get ( tokens [ 0 ] ) ; gameteams [ 1 ] = teams . get ( tokens [ 1 ] ) ; if ( gameteams [ 0 ] == null ) throw new exception ( "team not found: " + tokens [ 0 ] ) ; if ( gameteams [ 1 ] == null ) throw new exception ( "team not found: " + tokens [ 1 ] ) ; if ( tokens . length >= 4 ) { gameteams [ 0 ] . seed = integer . parseint ( tokens [ 2 ] ) ; gameteams [ 1 ] . seed = integer . parseint ( tokens [ 3 ] ) ; } for ( int i = 0 ; i < 2 ; i ++ ) if ( gameteams [ i ] == null ) throw new exception ( "team not found: " + tokens [ i ] ) ; game game = new game ( gameteams ) ; game . name = string . format ( "r0 g%d" , games . size ( ) ) ; games . add ( game ) ; } return games ; }
tr	10	public void update ( ) { for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < ysize ; x ++ ) { site site = scape . grid [ x ] [ y ] ; jlabel label = labels [ x ] [ y ] ; double energy = site . getfood ( ) ; double div = ( 255 / scape . maxfood ) * energy ; int gradient = ( int ) ( 255 - div ) ; color background ; background = ( gradient > 235 ) ? new color ( 255 , 250 , 205 ) : new color ( gradient , 255 , gradient ) ; label . setbackground ( background ) ; if ( site . getagent ( ) != null ) { label . settext ( "o" ) ; label . setforeground ( color . red ) ; } else { label . settext ( "" ) ; } } } }
tr	5	public void connect ( ) { try { debug . print ( "i'm client<litcomma> start to connect to host:" + host ) ; socket skt = new socket ( host , port ) ; debug . print ( "connected" ) ; rsa rsa = new rsa ( ) ; rsa . setn ( this . n ) ; rsa . sete ( this . e ) ; inputstreamreader isr = new inputstreamreader ( system . in ) ; string publickey = "(" + this . e + " " + this . n + ")" ; system . out . println ( "encoding with" + publickey ) ; while ( true ) { char c = ( char ) isr . read ( ) ; string tosend = "" ; if ( c == '\\n' ) { tosend = "\\n" ; } else { tosend = rsa . getcypher ( c + "" ) ; system . out . println ( c + " is encoded to " + tosend ) ; } for ( int i = 0 ; i < tosend . length ( ) ; i ++ ) { skt . getoutputstream ( ) . write ( tosend . charat ( i ) ) ; } } } catch ( connectexception e ) { system . err . println ( "starter haven't started listening yet!!!\\n please give server input info and run again!!!" ) ; } catch ( ioexception e ) { system . err . println ( "connect error" ) ; e . printstacktrace ( ) ; } }
tr	9	private static void calctestaccuracy ( dataset test , string [ ] results ) { if ( results == null ) { system . out . println ( "error in calculating accuracy: " + "you must implement the classify method" ) ; system . exit ( - 1 ) ; } list < instance > testinslist = test . instances ; if ( testinslist . size ( ) == 0 ) { system . out . println ( "error: size of test set is 0" ) ; system . exit ( - 1 ) ; } if ( testinslist . size ( ) > results . length ) { system . out . println ( "error: the number of predictions is inconsistant " + "with the number of instances in test set<litcomma> please check it" ) ; system . exit ( - 1 ) ; } int correct = 0 , total = testinslist . size ( ) ; for ( int i = 0 ; i < testinslist . size ( ) ; i ++ ) if ( testinslist . get ( i ) . label . equals ( results [ i ] ) ) correct ++ ; system . out . println ( "prediction accuracy on the test set is: " + string . format ( "%.5f" , correct * 1.0 / total ) ) ; return ; }
tr	6	public static double algorithmlist ( list < string > wordlist , int times_file , string searchterm , int snippetlength ) throws ioexception { stopwatch timer = new stopwatch ( ) ; for ( int i = 0 ; i < times_file ; i ++ ) { bufferedreader br = new bufferedreader ( new filereader ( filename ) ) ; string line = null ; while ( ( line = br . readline ( ) ) != null ) { for ( string word : line . split ( "[-!~\\\\s]+" ) ) { wordlist . add ( word ) ; } } } int position = 0 ; int results = 0 ; for ( string word : wordlist ) { if ( word . equals ( searchterm ) ) { stringbuilder temp = new stringbuilder ( ) ; for ( int i = ( position - snippetlength ) ; i < ( position + snippetlength + 1 ) ; i ++ ) { temp . append ( wordlist . get ( i ) ) ; temp . append ( " " ) ; } results ++ ; } position ++ ; } return timer . elapsedtime ( ) ; }
tr	2	@ override public void tick ( state gamestate ) { this . force [ 0 ] = lock ( this . force [ 0 ] , - 20 , 20 ) ; this . force [ 1 ] = lock ( this . force [ 1 ] , - 50 , 50 ) ; if ( this . force [ 0 ] > 0 ) { this . x += this . force [ 0 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { int borderinset = ( int ) ( int ) this . getbounds ( ) . getminx ( ) - x ; this . x = ( int ) xblocker . getbounds ( ) . getminx ( ) - ( int ) this . getbounds ( ) . getwidth ( ) - borderinset ; } } else if ( this . force [ 0 ] < 0 ) { this . x += this . force [ 0 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { int borderinset = ( int ) this . getbounds ( ) . getminx ( ) - x ; this . x = ( int ) xblocker . getbounds ( ) . getmaxx ( ) - borderinset ; } } if ( this . force [ 1 ] > 0 ) { this . y += this . force [ 1 ] ; if ( gamestate . blockingentity ( this ) != null ) { this . y -= this . force [ 1 ] ; } } else if ( this . force [ 1 ] < 0 ) { this . y += this . force [ 1 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { this . y = ( int ) xblocker . getbounds ( ) . getmaxy ( ) ; } if ( gamestate . blockingentity ( this ) != null ) { this . y -= this . force [ 1 ] ; } } force [ 0 ] = closer ( force [ 0 ] , 0 , 2 ) ; force [ 1 ] = closer ( force [ 1 ] , - 40 , 2 ) ; if ( this . y <= 0 ) { this . y = 0 ; } }
tr	9	public static void main ( string [ ] arg ) { scanner sc = new scanner ( system . in ) ; int [ ] arr = { 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 } ; int max , min , t , pos , mitten ; min = 0 ; max = arr . length - 1 ; system . out . print ( "vilket heltal s\xf6ker du? " ) ; t = sc . nextint ( ) ; pos = - 1 ; while ( min <= max && pos == - 1 ) { mitten = ( max + min ) / 2 ; if ( t > arr [ mitten ] ) min = mitten + 1 ; else if ( t < arr [ mitten ] ) max = mitten - 1 ; else pos = mitten ; } if ( pos == - 1 ) system . out . println ( "talet hittades inte" ) ; else system . out . println ( "talet finns i element nummer " + pos ) ; }
tr	10	public arraylist < string > get_search_urls ( ) throws classnotfoundexception , sqlexception { string url ; int docn , i ; double freq , idf , tf , tfidf ; arraylist < string > url_list = new arraylist < string > ( ) ; for ( i = 0 ; i < query_words . length ; i ++ ) { if ( query_map . containskey ( query_words [ i ] ) ) { freq = query_map . get ( query_words [ i ] ) ; freq = freq + 1 ; query_map . put ( query_words [ i ] , new double ( freq ) ) ; } else { query_map . put ( query_words [ i ] , new double ( 1.0 ) ) ; } } iterator < string > it = query_map . keyset ( ) . iterator ( ) ; string query_word ; while ( it . hasnext ( ) ) { query_word = it . next ( ) . tostring ( ) ; word_query_statement . setstring ( 1 , query_word ) ; resultset resultset = word_query_statement . executequery ( ) ; hashmap < string , result > temp_obj = new hashmap < string , result > ( ) ; while ( resultset . next ( ) ) { url = resultset . getstring ( "urls" ) ; if ( url . contains ( "rss" ) ) continue ; if ( url . contains ( ".xml" ) ) continue ; result res = new result ( resultset , this ) ; url = res . url ; docn = resultset . getint ( "docsn" ) ; freq = query_map . get ( query_word ) ; tf = ( 1 + math . log10 ( freq ) ) ; idf = math . log10 ( ( double ) total_n / ( double ) docn ) ; tfidf = tf * idf ; if ( ! query_map . containskey ( query_word ) ) query_map . put ( query_word , tfidf ) ; if ( ! url_list . contains ( url ) ) { url_list . add ( url ) ; } temp_obj . put ( url , res ) ; } resultsetmap . put ( query_word , temp_obj ) ; } system . out . println ( "query map: " + query_map ) ; iterator < string > it1 = query_map . keyset ( ) . iterator ( ) ; double net_score = 0 ; while ( it1 . hasnext ( ) ) { string word = it1 . next ( ) ; double score = query_map . get ( word ) ; net_score += score * score ; } iterator < string > it2 = query_map . keyset ( ) . iterator ( ) ; while ( it2 . hasnext ( ) ) { string word = it2 . next ( ) ; double score = query_map . get ( word ) ; score /= math . sqrt ( net_score ) ; query_map . put ( word , score ) ; } return url_list ; }
tr	10	public binomial ( random random , int min , int max , double p ) { if ( min >= max ) { throw new illegalargumentexception ( "invalid range" ) ; } this . random = random ; this . min = min ; this . n = max - min - 1 ; if ( n > 0 ) { v = new double [ n + 1 ] ; double sum = 0.0 ; for ( int i = 0 ; i <= n ; ++ i ) { sum += select ( n , i ) * power ( p , i ) * power ( 1 - p , n - i ) ; v [ i ] = sum ; } for ( int i = 0 ; i <= n ; ++ i ) { v [ i ] /= sum ; } } else { v = null ; } }
tr	10	list < string > getsequence ( ) { list < string > sequence = new arraylist < > ( ) ; list < integer > indicies = new arraylist < > ( operatorboxcount ) ; for ( int i = 0 ; i < operatorboxcount ; ++ i ) { indicies . add ( 0 ) ; } boolean stopflag = false ; while ( true ) { stopflag = true ; for ( int index : indicies ) { stopflag &= index == operators_len - 1 ; } stringbuilder builder = new stringbuilder ( ) ; for ( int index : indicies ) { builder . append ( operators . charat ( index ) ) ; } sequence . add ( builder . tostring ( ) ) ; if ( stopflag ) { break ; } int iix = 0 ; while ( this . operatorboxcount > iix ) { indicies . set ( iix , ( indicies . get ( iix ) + 1 ) % operators_len ) ; if ( indicies . get ( iix ) > 0 ) { break ; } iix ++ ; } } return sequence ; }
tr	4	private dectreenode traintree ( list < instance > examples , list < attribute > attributes , list < instance > parentexamples , string parentattributevalue ) { if ( examples . isempty ( ) ) { return new leafdectreenode ( plurality ( parentexamples ) , parentattributevalue ) ; } else if ( attributes . isempty ( ) || samelabel ( examples ) ) { return new leafdectreenode ( plurality ( examples ) , parentattributevalue ) ; } else { attribute importantattribute = importance ( attributes , examples ) ; list < attribute > childattributes = new arraylist < attribute > ( attributes ) ; childattributes . remove ( importantattribute ) ; if ( attribute . type . numerical . equals ( importantattribute . category . gettype ( ) ) ) { double midpoint = midpoint ( examples , importantattribute . index ) ; list < instance > positivechildexamples = new arraylist < instance > ( ) , negativechildexamples = new arraylist < instance > ( ) ; for ( instance example : examples ) { if ( integer . parseint ( example . attributes . get ( importantattribute . index ) ) > midpoint ) { positivechildexamples . add ( example ) ; } else { negativechildexamples . add ( example ) ; } } list < dectreenode > children = new arraylist < dectreenode > ( ) ; children . add ( traintree ( negativechildexamples , childattributes , examples , "a" ) ) ; children . add ( traintree ( positivechildexamples , childattributes , examples , "b" ) ) ; return new numericalinternaldectreenode ( plurality ( examples ) , importantattribute , parentattributevalue , children , midpoint ) ; } else { map < string , list < instance > > childexamples = new linkedhashmap < string , list < instance > > ( ) ; for ( instance example : examples ) { string importantattributevalue = example . attributes . get ( importantattribute . index ) ; list < instance > childexample = childexamples . get ( importantattributevalue ) ; if ( childexample == null ) { childexample = new arraylist < instance > ( ) ; childexamples . put ( importantattributevalue , childexample ) ; } childexample . add ( example ) ; } list < dectreenode > children = new arraylist < dectreenode > ( ) ; for ( string attribute : importantattribute . values ) { list < instance > childexamplesforattribute = childexamples . get ( attribute ) ; if ( childexamplesforattribute == null ) { childexamplesforattribute = new arraylist < instance > ( ) ; } children . add ( traintree ( childexamplesforattribute , childattributes , examples , attribute ) ) ; } return new internaldectreenode ( plurality ( examples ) , importantattribute , parentattributevalue , children ) ; } } }
tr	9	public void generate ( land [ ] [ ] world , float heightthreshold , float lakelevel ) { this . lakelevel = lakelevel ; this . world = world ; arraylist < land > startoptions = new arraylist < land > ( ) ; arraylist < land > riverstarts = new arraylist < land > ( ) ; for ( int i = 0 ; i < world . length ; i ++ ) { for ( int j = 0 ; j < world [ 0 ] . length ; j ++ ) { if ( world [ i ] [ j ] . height >= heightthreshold ) { startoptions . add ( world [ i ] [ j ] ) ; j += 10 ; i += 2 ; } } } int numrivers = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; system . out . println ( numrivers ) ; int rand = 0 ; for ( int i = 0 ; i < numrivers ; i ++ ) { rand = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; if ( rand == startoptions . size ( ) ) { rand -- ; } riverstarts . add ( startoptions . get ( rand ) ) ; startoptions . remove ( rand ) ; } for ( int i = 0 ; i < riverstarts . size ( ) ; i ++ ) { startriver ( riverstarts . get ( i ) ) ; } }
tr	6	public static void printfrequencies ( list < frequency > frequencies ) { int tottwogrmcnt = 0 ; boolean istwogram = false ; for ( frequency frequency : frequencies ) { tottwogrmcnt += frequency . getfrequency ( ) ; if ( frequency . gettext ( ) . split ( " " ) . length > 1 ) istwogram = true ; } if ( istwogram ) { system . out . println ( "total 2-gram count: " + tottwogrmcnt ) ; system . out . println ( "unique 2-gram count: " + frequencies . size ( ) ) ; } else { system . out . println ( "total item count: " + tottwogrmcnt ) ; system . out . println ( "unique item count: " + frequencies . size ( ) ) ; } system . out . println ( ) ; for ( frequency frequency : frequencies ) { system . out . println ( frequency . tostring ( ) ) ; } system . out . println ( ) ; system . out . println ( "===============" ) ; system . out . println ( ) ; }
tr	7	public string toprintablestring ( ) { stringbuilder builder = new stringbuilder ( ) ; int maxnamelength = 0 ; for ( game game : rounds . get ( 0 ) ) maxnamelength = math . max ( math . max ( game . teams [ 0 ] . tostring ( ) . length ( ) , game . teams [ 1 ] . tostring ( ) . length ( ) ) , maxnamelength ) ; int columnwidth = maxnamelength + column_padding + column_prefix_margin + column_suffix_margin ; for ( int line = 0 ; line < print_height ; line ++ ) { for ( int round = 0 ; round < rounds . size ( ) ; round ++ ) { if ( round == 0 ) builder . append ( teamat ( line , round , columnwidth - column_prefix_margin ) ) ; else builder . append ( teamat ( line , round , columnwidth ) ) ; } builder . append ( "\\n" ) ; } return builder . tostring ( ) ; }
tr	2	@ test public void testdrawstring ( ) { asserttrue ( closer ( 10 , 5 , 1 ) == 9 ) ; asserttrue ( closer ( 10 , 5 , 2 ) == 8 ) ; asserttrue ( closer ( - 10 , 5 , 1 ) == - 9 ) ; asserttrue ( closer ( - 10 , 5 , 2 ) == - 8 ) ; asserttrue ( closer ( 1 , 2 , 5 ) == 2 ) ; asserttrue ( closer ( - 1 , 1 , 1 ) == 0 ) ; asserttrue ( closer ( 0 , 0 , 1 ) == 0 ) ; }
tr	5	public rootframe ( ) { super ( "an expert car chooser" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 578 , 453 ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; setcontentpane ( contentpane ) ; contentpane . setlayout ( null ) ; jpanel panel = new jpanel ( ) ; panel . setbounds ( 5 , 5 , 212 , 398 ) ; contentpane . add ( panel ) ; panel . setlayout ( null ) ; jcombobox < prologmodelapplicable > combobox_1 = new jcombobox < prologmodelapplicable > ( ) ; combobox_1 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carmanufacturerproductiontype . values ( ) ) ) ; combobox_1 . setbounds ( 0 , 21 , 202 , 19 ) ; combobox_1 . settooltiptext ( "choose country" ) ; combobox_1 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_1 ) ; panel . add ( combobox_1 ) ; jcombobox < prologmodelapplicable > combobox = new jcombobox < prologmodelapplicable > ( ) ; combobox . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carsuspensiontype . values ( ) ) ) ; combobox . setbounds ( 0 , 66 , 202 , 19 ) ; mprologcontentcomboboxes . add ( combobox ) ; combobox . setselectedindex ( - 1 ) ; panel . add ( combobox ) ; jcombobox < prologmodelapplicable > combobox_3 = new jcombobox < prologmodelapplicable > ( ) ; mprologcontentcomboboxes . add ( combobox_3 ) ; combobox_3 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cargastype . values ( ) ) ) ; combobox_3 . setbounds ( 0 , 113 , 202 , 19 ) ; combobox_3 . setselectedindex ( - 1 ) ; panel . add ( combobox_3 ) ; jcombobox < prologmodelapplicable > combobox_2 = new jcombobox < prologmodelapplicable > ( ) ; mprologcontentcomboboxes . add ( combobox_2 ) ; combobox_2 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cardoorstype . values ( ) ) ) ; combobox_2 . setbounds ( 0 , 162 , 202 , 19 ) ; combobox_2 . setselectedindex ( - 1 ) ; panel . add ( combobox_2 ) ; jlabel lblmanufacturercountry = new jlabel ( "manufacturer country" ) ; lblmanufacturercountry . setbounds ( 0 , 0 , 138 , 14 ) ; panel . add ( lblmanufacturercountry ) ; jlabel lblbodytype = new jlabel ( "suspension type" ) ; lblbodytype . setbounds ( 0 , 51 , 138 , 14 ) ; panel . add ( lblbodytype ) ; jlabel lblgastype = new jlabel ( "gas type" ) ; lblgastype . setbounds ( 0 , 96 , 138 , 14 ) ; panel . add ( lblgastype ) ; jlabel lblnewlabel_1 = new jlabel ( "doors amount" ) ; lblnewlabel_1 . setbounds ( 0 , 148 , 95 , 14 ) ; panel . add ( lblnewlabel_1 ) ; jlabel lblprice = new jlabel ( "price" ) ; lblprice . setbounds ( 0 , 192 , 138 , 14 ) ; panel . add ( lblprice ) ; jcombobox < prologmodelapplicable > combobox_4 = new jcombobox < prologmodelapplicable > ( ) ; combobox_4 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carpricetype . values ( ) ) ) ; combobox_4 . setbounds ( 0 , 210 , 202 , 19 ) ; combobox_4 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_4 ) ; panel . add ( combobox_4 ) ; jlabel lblturbotype = new jlabel ( "turbo type" ) ; lblturbotype . setbounds ( 0 , 241 , 138 , 14 ) ; panel . add ( lblturbotype ) ; jcombobox < prologmodelapplicable > combobox_5 = new jcombobox < prologmodelapplicable > ( ) ; combobox_5 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carturbotype . values ( ) ) ) ; combobox_5 . setbounds ( 0 , 257 , 202 , 19 ) ; combobox_5 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_5 ) ; panel . add ( combobox_5 ) ; jlabel lbltrunktype = new jlabel ( "trunk type" ) ; lbltrunktype . setbounds ( 0 , 287 , 138 , 14 ) ; panel . add ( lbltrunktype ) ; jcombobox < prologmodelapplicable > combobox_6 = new jcombobox < prologmodelapplicable > ( ) ; combobox_6 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cartrunkcapacitytype . values ( ) ) ) ; combobox_6 . setbounds ( 0 , 303 , 202 , 19 ) ; combobox_6 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_6 ) ; panel . add ( combobox_6 ) ; jbutton btnnewbutton = new jbutton ( "reset choices" ) ; btnnewbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { mexpertanswerrootpane . settext ( "" ) ; for ( jcombobox < prologmodelapplicable > combobox : mprologcontentcomboboxes ) { combobox . setselectedindex ( - 1 ) ; } } } ) ; btnnewbutton . setbounds ( 38 , 364 , 138 , 23 ) ; panel . add ( btnnewbutton ) ; jpanel panel_1 = new jpanel ( ) ; panel_1 . setbounds ( 217 , 5 , 338 , 398 ) ; contentpane . add ( panel_1 ) ; panel_1 . setlayout ( null ) ; jlabel lblnewlabel = new jlabel ( "choose properties and ask the expert." ) ; lblnewlabel . setbounds ( 59 , 11 , 226 , 14 ) ; panel_1 . add ( lblnewlabel ) ; lblnewlabel . sethorizontalalignment ( swingconstants . center ) ; jbutton btnaskexpert = new jbutton ( "ask expert" ) ; btnaskexpert . setbounds ( 89 , 36 , 163 , 23 ) ; btnaskexpert . addactionlistener ( new askexpertbuttonactionlistener ( ) ) ; panel_1 . add ( btnaskexpert ) ; mexpertanswerrootpane = new jtextpane ( ) ; mexpertanswerrootpane . setbounds ( 21 , 69 , 292 , 318 ) ; jscrollpane pane = new jscrollpane ( mexpertanswerrootpane ) ; pane . setbounds ( 21 , 69 , 292 , 318 ) ; panel_1 . add ( pane ) ; }
tr	2	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese un d\xeda de la semana (n\xfamero): " ) ; int v = scanner . nextint ( ) ; string dia ; switch ( v ) { case 1 : dia = "lunes" ; break ; case 2 : dia = "martes" ; break ; case 3 : dia = "miercoles" ; break ; case 4 : dia = "jueves" ; break ; case 5 : dia = "viernes" ; break ; case 6 : dia = "s\xe1bado" ; break ; case 7 : dia = "domingo" ; break ; default : dia = "d\xeda incorrecto... el valor debe ser entre 1 y 7" ; } system . out . println ( dia ) ; }
tr	1	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . print ( "ingrese un valor: " ) ; int v = scanner . nextint ( ) ; int resto = v % 2 ; if ( resto == 0 ) { system . out . println ( v + " es par" ) ; } else { system . out . println ( v + " es impar" ) ; } string mssg = ( resto == 0 ) ? "es par" : "es impar" ; system . out . println ( mssg ) ; }
tr	7	public void appendnextround ( round round ) { round nextround = new round ( ) ; rounds . add ( nextround ) ; int roundnumber = rounds . indexof ( nextround ) ; int gamecount = 0 ; for ( int i = 0 ; i < round . size ( ) ; i += 2 ) { game newgame = new game ( ) ; newgame . referee = scoreable ; game [ ] previousgames = new game [ ] { round . get ( i ) , round . get ( i + 1 ) } ; for ( game previousgame : previousgames ) previousgame . nextgame = newgame ; newgame . previousgames = previousgames ; newgame . name = string . format ( "r%d g%d" , roundnumber , gamecount ) ; nextround . add ( newgame ) ; gamecount ++ ; } if ( nextround . size ( ) == 1 ) return ; appendnextround ( nextround ) ; }
tr	10	public static void main ( string [ ] arg ) { int n = 100 ; int [ ] a = new int [ n ] ; system . out . print ( "dessa tal slumpas till arrayen:" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 10 == 0 ) system . out . println ( ) ; a [ i ] = ( int ) ( 1000 * math . random ( ) ) ; system . out . print ( a [ i ] + "\\t" ) ; } int summa , max , min ; double medel ; summa = 0 ; max = - 1 ; min = 1000 ; for ( int i = 0 ; i < n ; i ++ ) { summa = summa + a [ i ] ; if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } medel = ( double ) summa / n ; system . out . println ( " " ) ; system . out . println ( "summa = " + summa + " medel = " + medel ) ; system . out . println ( "max = " + max + " min = " + min ) ; }
tr	4	private static string read ( clob c ) throws sqlexception , ioexception { stringbuffer sb = new stringbuffer ( ( int ) c . length ( ) ) ; reader r = c . getcharacterstream ( ) ; char [ ] cbuf = new char [ 2048 ] ; int n = 0 ; while ( ( n = r . read ( cbuf , 0 , cbuf . length ) ) != - 1 ) { if ( n > 0 ) { sb . append ( cbuf , 0 , n ) ; } } return sb . tostring ( ) ; }
tr	6	private static string getcolumnvalue ( resultset rs , int coltype , int colindex ) throws sqlexception , ioexception { string value = "" ; switch ( coltype ) { case types . bit : object bit = rs . getobject ( colindex ) ; if ( bit != null ) { value = string . valueof ( bit ) ; } break ; case types . boolean : boolean b = rs . getboolean ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = boolean . valueof ( b ) . tostring ( ) ; } break ; case types . clob : clob c = rs . getclob ( colindex ) ; if ( c != null ) { value = read ( c ) ; } break ; case types . bigint : case types . decimal : case types . double : case types . float : case types . real : case types . numeric : bigdecimal bd = rs . getbigdecimal ( colindex ) ; if ( bd != null ) { value = "" + bd . doublevalue ( ) ; } break ; case types . integer : case types . tinyint : case types . smallint : int intvalue = rs . getint ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = "" + intvalue ; } break ; case types . java_object : object obj = rs . getobject ( colindex ) ; if ( obj != null ) { value = string . valueof ( obj ) ; } break ; case types . date : java . sql . date date = rs . getdate ( colindex ) ; if ( date != null ) { value = date_formatter . format ( date ) ; ; } break ; case types . time : time t = rs . gettime ( colindex ) ; if ( t != null ) { value = t . tostring ( ) ; } break ; case types . timestamp : timestamp tstamp = rs . gettimestamp ( colindex ) ; if ( tstamp != null ) { value = timestamp_formatter . format ( tstamp ) ; } break ; case types . longvarchar : case types . varchar : case types . char : value = rs . getstring ( colindex ) ; break ; default : value = "" ; } if ( value == null ) { value = "" ; } return value ; }
tr	7	public void indexfileordirectory ( string filename ) throws ioexception , interruptedexception { int j = 1 ; addfiles ( new file ( filename ) ) ; int originalnumdocs = writer . numdocs ( ) ; for ( file f : queue ) { j = 1 ; document doc = new document ( ) ; scanner scanner = new scanner ( f ) ; stringbuilder builder = new stringbuilder ( ) ; string docid = "" , url = "" , path = "" , parenturl = "" ; string title = "" , h1 = "" , h2 = "" , h3 = "" ; string bold = "" , strong = "" , em = "" , anchortext = "" , parseddata = "" ; arraylist < string > temparrlist = new arraylist < string > ( ) ; while ( scanner . hasnextline ( ) ) { string currline = scanner . nextline ( ) ; if ( j == 1 ) { docid = currline ; j ++ ; system . out . println ( "docid: " + currline ) ; } else if ( j == 2 ) { url = currline ; j ++ ; system . out . println ( "url: " + currline ) ; } else if ( j == 3 ) { path = currline ; j ++ ; system . out . println ( "path: " + currline ) ; } else if ( j == 4 ) { parenturl = currline ; j ++ ; system . out . println ( "docparent url: " + currline ) ; } else if ( j == 5 ) { title = currline ; j ++ ; system . out . println ( "title: " + currline ) ; } else if ( j == 6 ) { h1 = currline ; j ++ ; system . out . println ( "h1: " + currline ) ; } else if ( j == 7 ) { h2 = currline ; j ++ ; system . out . println ( "h2: " + currline ) ; } else if ( j == 8 ) { h3 = currline ; j ++ ; system . out . println ( "h3: " + currline ) ; } else if ( j == 9 ) { bold = currline ; j ++ ; system . out . println ( "bold: " + currline ) ; } else if ( j == 10 ) { strong = currline ; j ++ ; system . out . println ( "string: " + currline ) ; } else if ( j == 11 ) { em = currline ; j ++ ; system . out . println ( "em: " + currline ) ; } else if ( j == 12 ) { anchortext = currline ; j ++ ; system . out . println ( "anchortext: " + currline ) ; } else if ( j == 13 ) { parseddata = currline ; j ++ ; temparrlist = utilities . removestopwords ( arrays . aslist ( parseddata ) , stopwords ) ; for ( string string : temparrlist ) { builder . append ( string + " " ) ; } system . out . println ( "parsed data: " + currline ) ; } } field titlefield = new textfield ( "title" , title , field . store . yes ) ; titlefield . setboost ( 9.1f ) ; doc . add ( titlefield ) ; field h1field = new textfield ( "h1" , h1 , field . store . yes ) ; h1field . setboost ( 50f ) ; doc . add ( h1field ) ; field h2field = new textfield ( "h2" , h2 , field . store . yes ) ; h2field . setboost ( 35f ) ; doc . add ( h2field ) ; field h3field = new textfield ( "h3" , h3 , field . store . yes ) ; h3field . setboost ( 25f ) ; doc . add ( h3field ) ; field boldfield = new textfield ( "bold" , bold , field . store . yes ) ; boldfield . setboost ( 17f ) ; doc . add ( boldfield ) ; field strongfield = new textfield ( "strong" , strong , field . store . yes ) ; strongfield . setboost ( 17f ) ; doc . add ( strongfield ) ; field emfield = new textfield ( "em" , em , field . store . yes ) ; emfield . setboost ( 20f ) ; doc . add ( emfield ) ; field anchortxtfield = new textfield ( "anchortxt" , anchortext , field . store . yes ) ; anchortxtfield . setboost ( 25f ) ; doc . add ( anchortxtfield ) ; field parseddatafield = new textfield ( "parseddata" , builder . tostring ( ) , field . store . yes ) ; parseddatafield . setboost ( 75f ) ; doc . add ( parseddatafield ) ; doc . add ( new stringfield ( "filename" , url , field . store . yes ) ) ; writer . adddocument ( doc ) ; system . out . println ( "added: " + f ) ; scanner . close ( ) ; } int newnumdocs = writer . numdocs ( ) ; system . out . println ( "" ) ; system . out . println ( "************************" ) ; system . out . println ( ( newnumdocs - originalnumdocs ) + " documents added." ) ; system . out . println ( "************************" ) ; queue . clear ( ) ; }
tr	2	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese la fecha (dd/mm/aaaa): " ) ; string sfecha = scanner . next ( ) ; fecha f = new fecha ( sfecha ) ; system . out . println ( "la fecha ingresada es:" + f ) ; system . out . println ( "ingrese d\xedas a sumar(pueden ser negativos)" ) ; int diassum = scanner . nextint ( ) ; f . adddias ( diassum ) ; system . out . println ( "sumando " + diassum + " d\xedas<litcomma> queda: " + f ) ; }
tr	7	public static void main ( string [ ] args ) { if ( args . length != 4 ) { system . out . println ( "usage: java hw2 <modeflag> <trainfilename> " + "<tunefilename> <testfilename>" ) ; system . exit ( - 1 ) ; } int mode = integer . parseint ( args [ 0 ] ) ; if ( mode < 1 || mode > 2 ) { system . out . println ( "error: modeflag must be an integer 1 or 2" ) ; system . exit ( - 1 ) ; } dataset trainset = null , tuneset = null , testset = null ; trainset = createdataset ( args [ 1 ] , mode ) ; testset = createdataset ( args [ 3 ] , mode ) ; if ( mode > 1 ) tuneset = createdataset ( args [ 2 ] , mode ) ; decisiontree tree = null ; if ( mode == 1 ) { tree = new decisiontreeimpl ( trainset ) ; } else { if ( tuneset == null ) { system . out . println ( "empty tuning set" ) ; system . exit ( - 1 ) ; } tree = new decisiontreeimpl ( trainset , tuneset ) ; } tree . print ( ) ; calctestaccuracy ( testset , tree . classify ( testset ) ) ; }
tr	1	private void run ( ) { dm = new decisionmaker ( ) ; status = new status ( ) ; while ( true ) { try { jsonsocket sock = new jsonsocket ( host , port ) ; try { sock . connect ( ) ; } catch ( ioexception e ) { throw new exception ( "error establishing connection to server: " + e . tostring ( ) ) ; } while ( true ) { message message = sock . getmessage ( ) ; playermessage response = handlemessage ( message ) ; if ( response != null ) { sock . sendmessage ( response ) ; } } } catch ( exception e ) { system . err . println ( "error: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . err . println ( "reconnecting in " + reconnect_timeout + "s" ) ; try { thread . sleep ( reconnect_timeout * 1000 ) ; } catch ( interruptedexception ex ) { } } } }
tr	7	private static hashtable < string , team > parsestats ( csvreader reader , collection < stat > stats ) { hashtable < string , team > teams = new hashtable < string , team > ( ) ; list < string [ ] > lines ; try { lines = reader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { string [ ] tokens = lines . get ( i ) ; if ( tokens . length == 1 && ! tokens [ 0 ] . trim ( ) . equals ( "" ) ) { for ( stat stat : stats ) { if ( stat . table . equals ( tokens [ 0 ] ) ) { int j = i + 1 ; for ( ; j < lines . size ( ) ; j ++ ) if ( lines . get ( j ) [ 0 ] . equalsignorecase ( "rank" ) ) break ; string [ ] columntitles = lines . get ( j ) ; int columnindex = findcolumnindex ( columntitles , stat . column ) ; j ++ ; while ( true ) { string [ ] values = lines . get ( j ) ; if ( ( values . length == 1 && values [ 0 ] . trim ( ) . length ( ) == 0 ) || values [ 0 ] . equals ( "reclassifying" ) ) break ; team team = getteam ( teams , values [ 1 ] ) ; team . stats . put ( stat . name , double . parsedouble ( values [ columnindex ] ) ) ; j += 1 ; } } } } } return teams ; }
tr	2	private double calculatescore ( team home , team away , hashtable < string , compiledstat > compiledstats , hashtable < string , string > summary ) { double basepts = 0.4 * ( 0.4 * home . getstat ( "ppg" ) + 0.6 * away . getstat ( "opp ppg" ) ) ; double pts = basepts ; double fgbonus = basepts * home . getstat ( "fg%" ) * 0.01 ; pts += fgbonus ; double winbonus = 0.1 * basepts * home . getstat ( "win %" ) * 0.01 ; pts += winbonus ; double turnoverlostpoints = - 2.0 * ( home . getstat ( "topg" ) + away . getstat ( "stpg" ) ) ; pts += turnoverlostpoints ; double turnovergainedpoints = 2.0 * ( home . getstat ( "stpg" ) + away . getstat ( "topg" ) ) ; pts += turnovergainedpoints ; double pfpts = 2 * home . getstat ( "ft%" ) * 0.01 * away . getstat ( "pfpg" ) ; pts += pfpts ; double reboundpts = 2.0 * ( home . getstat ( "rpg" ) - away . getstat ( "rpg" ) ) ; pts += reboundpts ; double blockpts = 2.0 * ( home . getstat ( "bkpg" ) - away . getstat ( "bkpg" ) ) ; pts += blockpts ; summary . put ( "base pts" , basepts . tostring ( ) ) ; summary . put ( "fg bonus" , fgbonus . tostring ( ) ) ; summary . put ( "win bonus" , winbonus . tostring ( ) ) ; summary . put ( "to pts" , turnovergainedpoints . tostring ( ) ) ; summary . put ( "to pts lost" , turnoverlostpoints . tostring ( ) ) ; summary . put ( "pf pts" , pfpts . tostring ( ) ) ; summary . put ( "rb pts" , reboundpts . tostring ( ) ) ; summary . put ( "blk pts" , blockpts . tostring ( ) ) ; summary . put ( "pts" , pts . tostring ( ) ) ; summary . put ( "team" , home . tostring ( ) ) ; return pts ; }
tr	4	public string classify ( instance example ) { string childexampleattributevalue = example . attributes . get ( attribute . index ) ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { for ( dectreenode childnode : children ) { if ( "a" . equals ( childnode . parentattributevalue ) == ( integer . parseint ( childexampleattributevalue ) < midpoint ) ) { if ( childnode instanceof internaldectreenode ) { return ( ( internaldectreenode ) childnode ) . classify ( example ) ; } else { return childnode . label ; } } } } return label ; }
tr	3	public static void main ( string [ ] args ) { disruptor < calculatenumbersevent > disruptor = new disruptor < calculatenumbersevent > ( calculatenumbersevent . event_factory , createexecutor ( ) , new singlethreadedclaimstrategy ( ring_size ) , new sleepingwaitstrategy ( ) ) ; disruptor . handleeventswith ( new factorialcalculator ( ) , new fibonaccicalculator ( ) ) . then ( new hexrepresentationcalculator ( ) , new binaryrepresentationcalculator ( ) ) . then ( new eventoutputhandler ( ) ) ; ringbuffer < calculatenumbersevent > ringbuffer = disruptor . start ( ) ; long sequence = ringbuffer . next ( ) ; calculatenumbersevent event = ringbuffer . get ( sequence ) ; event . setvalue ( 5 ) ; ringbuffer . publish ( sequence ) ; disruptor . publishevent ( new eventtranslator < calculatenumbersevent > ( ) { @ override public void translateto ( calculatenumbersevent event , long sequence ) { event . setfired ( new date ( ) ) ; } } ) ; }
tr	1	public task ( string name , int tasknumber , int numberofdays , string startdate , string enddate , gscene scene , task parent , double xposition , double yposition ) { this . name = name ; this . tasknumber = tasknumber ; this . numberofdays = numberofdays ; this . startdate = startdate ; this . enddate = enddate ; this . parent = parent ; this . yposition = yposition ; xsize = 200 ; ysize = 200 ; line = new gsegment ( ) ; addsegment ( line ) ; square = new gsegment ( ) ; addsegment ( square ) ; setstyle ( new gstyle ( ) ) ; if ( parent == null ) { scene . add ( this ) ; this . xposition = xposition ; } else { parent . add ( this ) ; this . xposition = parent . getxposition ( ) + xposition ; } updatetext ( ) ; }
tr	5	public static hashtable < string , compiledstat > compilestats ( vector < stat > stats , collection < team > teams ) { vector < team > teamvector = new vector < team > ( teams ) ; hashtable < string , compiledstat > compiledstats = new hashtable < string , compiledstat > ( ) ; for ( stat stat : stats ) { double [ ] values = new double [ teams . size ( ) ] ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { team team = teamvector . get ( i ) ; values [ i ] = team . getstat ( stat . name ) ; } compiledstats . put ( stat . name , new compiledstat ( stat . name , values ) ) ; } return compiledstats ; }
tr	9	public static packet construct ( datagrampacket packet ) { byte [ ] data = packet . getdata ( ) ; if ( data . length == 0 ) { server . warning ( "empty packet from " + packet . getaddress ( ) + ":" + packet . getport ( ) ) ; return null ; } class < ? extends packet > clazz = classes [ ( ( int ) data [ 0 ] ) & 0xff ] ; if ( clazz == null ) { server . warning ( string . format ( "invalid packet id 0x%02x from %s:%d" , ( ( int ) data [ 0 ] ) & 0xff , packet . getaddress ( ) , packet . getport ( ) ) ) ; return null ; } try { constructor < ? extends packet > constructor = clazz . getconstructor ( inetaddress . class , int . class , byte [ ] . class ) ; packet p = constructor . newinstance ( packet . getaddress ( ) , packet . getport ( ) , data ) ; if ( ! ( p instanceof packetpayload || p instanceof packetack ) ) server . debug ( "recieved " + p ) ; return p ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	2	private double calculatescore ( team home , team away , hashtable < string , compiledstat > compiledstats ) { double basescore = ( 0.5 ) * ( 1.0 * home . getstat ( "ppg" ) + 1.0 * away . getstat ( "opp ppg" ) ) / 2.0 ; double score = basescore + randomabout ( basescore * variability ) ; double winbonus = ( 0.4 ) * ( home . getstat ( "win %" ) ) ; score += winbonus + randomabout ( winbonus * variability ) ; double scoringmarginmargin = away . getstat ( "scr mar" ) - home . getstat ( "scr mar" ) ; double scoringmarginpoints = 0.7 * scoringmarginmargin + randomabout ( scoringmarginmargin * variability ) ; score -= scoringmarginpoints ; double turnoverpoints = 0.4 * ( home . getstat ( "topg" ) + away . getstat ( "stpg" ) ) ; score -= turnoverpoints * randomabout ( turnoverpoints * variability ) ; double pfpoints = 1.5 * home . getstat ( "ft%" ) * 0.01 * away . getstat ( "pfpg" ) ; score += pfpoints + randomabout ( pfpoints * variability ) ; double rebounddiff = home . getstat ( "rpg" ) - away . getstat ( "rpg" ) ; score += 1 * rebounddiff + randomabout ( rebounddiff * variability ) ; double opponentblocks = 1 * away . getstat ( "bkpg" ) ; score -= opponentblocks + randomabout ( opponentblocks * variability ) ; return score ; }
tr	6	public static void drawstring ( int x , int y , string text ) { int tilesize = 16 ; for ( int i = 0 ; i < text . length ( ) ; ++ i ) { string character = "" + text . charat ( i ) ; texttile tile = alphabetmap . get ( character . touppercase ( ) ) ; if ( tile == null ) { tile = alphabetmap . get ( "?" ) ; } tile . setposition ( i * tilesize , y ) ; tile . draw ( ) ; } }
tr	9	public void update ( int delta ) { float d = .01f * delta ; if ( turnright ) rotation += rotatespd * .01f * delta ; if ( turnleft ) rotation -= rotatespd * .01f * delta ; if ( ! checkborders ( ) && accelerate ) { acceleration [ 0 ] = ( float ) helper . cos ( rotation ) * speed ; acceleration [ 1 ] = ( float ) helper . sin ( rotation ) * speed ; velocity [ 0 ] += acceleration [ 0 ] * delta * .01f ; velocity [ 1 ] += acceleration [ 1 ] * delta * .01f ; } for ( int i = 0 ; i < 2 ; i ++ ) { location [ i ] += velocity [ i ] * delta * .01f ; if ( stop ) { velocity [ i ] -= velocity [ i ] / 10 * d ; } } }
tr	8	private static double computedcg ( list < integer > urls , list < integer > googleorder , int noofentries ) { double gain = 0 ; double logtwo = math . log ( 2 ) ; int rank = 0 ; for ( int i = 0 ; i < noofentries ; i ++ ) { integer item = googleorder . get ( i ) ; integer val = urls . get ( item - 1 ) ; rank ++ ; if ( rank < 2 ) { gain += val ; } else { gain += val * logtwo / math . log ( rank ) ; } } return gain ; }
tr	1	public void updatetext ( ) { gtext textname = new gtext ( name , gposition . top ) ; integer num ; num = tasknumber ; gtext texttasknum = new gtext ( num . tostring ( ) , gposition . top ) ; num = numberofdays ; gtext textnumofdays = new gtext ( num . tostring ( ) , gposition . top ) ; gtext textstart = new gtext ( startdate , gposition . top ) ; gtext textend = new gtext ( enddate , gposition . top ) ; square . addtext ( textname ) ; square . addtext ( texttasknum ) ; square . addtext ( textnumofdays ) ; square . addtext ( textstart ) ; square . addtext ( textend ) ; }
tr	4	public string decypher ( string input ) { string [ ] cyphers = input . split ( " " ) ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < cyphers . length ; i ++ ) { long num = long . parselong ( cyphers [ i ] ) ; long temp = endecrypt ( num , d , n ) ; debug . print ( "temp is:" + temp ) ; char c = ( char ) temp ; sb . append ( c ) ; } return sb . tostring ( ) ; }
tr	3	@ override public string [ ] classify ( dataset test ) { string [ ] classification = new string [ test . instances . size ( ) ] ; for ( int i = 0 ; i < test . instances . size ( ) ; i ++ ) { instance example = test . instances . get ( i ) ; if ( root instanceof internaldectreenode ) { classification [ i ] = ( ( internaldectreenode ) root ) . classify ( example ) ; } else { classification [ i ] = root . label ; } } return classification ; }
tr	3	public message getmessage ( ) throws exception { string jsonmessage = "" ; try { int payloadlen = reader . readint ( ) ; byte [ ] jsonarr = new byte [ payloadlen ] ; if ( reader . read ( jsonarr ) < 1 ) { throw new exception ( "server response was truncated" ) ; } jsonmessage = new string ( jsonarr ) ; } catch ( exception e ) { system . err . println ( "error reading response from server: " + e . tostring ( ) ) ; throw e ; } message message = messagefactory . getservermessage ( jsonmessage ) ; return message ; }
tr	3	void onreceiveresult ( status status , resultmessage r ) { if ( r . result . type . equals ( "trick_won" ) ) { if ( r . result . by == r . your_player_num ) wintime ++ ; else losetime ++ ; theirlastcard = r . result . card ; totaltime ++ ; } if ( r . result . type . equals ( "trick_tied" ) ) { tiedtime ++ ; theirlastcard = mylastcard ; totaltime ++ ; } if ( r . result . type . equals ( "hand_done" ) ) { wintime = 0 ; losetime = 0 ; totaltime = 0 ; tiedtime = 0 ; mylastcard = - 1 ; theirlastcard = - 1 ; } }
tr	8	private double midpoint ( list < instance > examples , int attributeindex ) { if ( examples == null || examples . isempty ( ) ) { return 0.0 ; } double max = double . negative_infinity , min = double . positive_infinity ; for ( instance instance : examples ) { int attribute = integer . parseint ( instance . attributes . get ( attributeindex ) ) ; if ( attribute > max ) { max = attribute ; } if ( attribute < min ) { min = attribute ; } } return 0.5 * ( max + min ) ; }
tr	1	private void prune ( dataset tune ) { double originalaccuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( root instanceof internaldectreenode ) { internaldectreenode nodetoprune = null , parentnodetoprune = null ; double maxaccuracy = originalaccuracy ; internaldectreenode savedinternalnode = ( internaldectreenode ) root ; leafdectreenode prunedleafnode = new leafdectreenode ( savedinternalnode . label , savedinternalnode . parentattributevalue ) ; root = prunedleafnode ; double accuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( accuracy >= maxaccuracy ) { maxaccuracy = accuracy ; nodetoprune = ( internaldectreenode ) savedinternalnode ; } root = savedinternalnode ; queue < internaldectreenode > queue = new linkedlist < internaldectreenode > ( ) ; queue . add ( ( internaldectreenode ) root ) ; while ( ! queue . isempty ( ) ) { internaldectreenode internalnode = queue . remove ( ) ; for ( int i = 0 ; i < internalnode . children . size ( ) ; i ++ ) { dectreenode child = internalnode . children . get ( i ) ; if ( child instanceof internaldectreenode ) { savedinternalnode = ( internaldectreenode ) child ; prunedleafnode = new leafdectreenode ( savedinternalnode . label , savedinternalnode . parentattributevalue ) ; internalnode . removechild ( child ) ; internalnode . addchild ( prunedleafnode ) ; accuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( accuracy >= maxaccuracy ) { maxaccuracy = accuracy ; nodetoprune = savedinternalnode ; parentnodetoprune = internalnode ; } internalnode . removechild ( prunedleafnode ) ; internalnode . returnchild ( i , child ) ; queue . add ( savedinternalnode ) ; } } } if ( nodetoprune != null && maxaccuracy > originalaccuracy ) { if ( parentnodetoprune != null ) { parentnodetoprune . removechild ( nodetoprune ) ; parentnodetoprune . addchild ( new leafdectreenode ( nodetoprune . label , nodetoprune . parentattributevalue ) ) ; prune ( tune ) ; } else { root = new leafdectreenode ( nodetoprune . label , nodetoprune . parentattributevalue ) ; } } } }
tr	5	public string tosummarystring ( ) { stringwriter stringwriter = new stringwriter ( ) ; csvwriter writer = new csvwriter ( stringwriter ) ; string [ ] columns = new string [ 0 ] ; for ( round round : rounds ) { for ( game game : round ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( columns . length == 0 ) { if ( game . summarystats . size ( ) == 0 ) return "" ; columns = game . summarystats . toarray ( columns ) ; writer . writenext ( columns ) ; } string [ ] values = new string [ columns . length ] ; for ( int j = 0 ; j < values . length ; j ++ ) values [ j ] = game . summaries [ i ] . get ( columns [ j ] ) . tostring ( ) ; writer . writenext ( values ) ; } } } return stringwriter . tostring ( ) ; }
tr	8	public static void main ( string [ ] args ) throws exception { if ( args . length < 3 || args [ 0 ] . isempty ( ) || args [ 1 ] . isempty ( ) || args [ 2 ] . isempty ( ) ) { system . out . println ( "too few arguments. required arguments: [year] [men|women] [referee class name]" ) ; return ; } if ( ! args [ 1 ] . equals ( "men" ) && ! args [ 1 ] . equals ( "women" ) ) { system . out . println ( "the second argument must be 'men' or 'women'." ) ; return ; } string year = args [ 0 ] ; string sex = args [ 1 ] ; string refereeclassname = args [ 2 ] ; referee referee ; try { referee = ( referee ) class . forname ( "bracketeer.referees." + refereeclassname ) . newinstance ( ) ; } catch ( exception ex ) { system . out . println ( "the referee class '" + refereeclassname + "' was not found in the package bracketeer.referees. check your capitalization and be sure to recompile." ) ; return ; } vector < stat > stats = new vector < stat > ( ) ; stats . add ( new stat ( "division iwon-lost percentage" , "pct" , "win %" ) ) ; stats . add ( new stat ( "division iscoring margin" , "ppg" , "ppg" ) ) ; stats . add ( new stat ( "division iscoring margin" , "opp ppg" , "opp ppg" ) ) ; stats . add ( new stat ( "division iscoring margin" , "scr mar" , "scr mar" ) ) ; stats . add ( new stat ( "division irebound margin" , "rpg" , "rpg" ) ) ; stats . add ( new stat ( "division ifield-goal percentage" , "fg%" , "fg%" ) ) ; stats . add ( new stat ( "division ifield-goal percentage" , "fga" , "fga" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fg" , "opp fg" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fga" , "opp fga" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fg%" , "opp fg%" ) ) ; stats . add ( new stat ( "division ipersonal fouls per game" , "pfpg" , "pfpg" ) ) ; stats . add ( new stat ( "division ifree-throw percentage" , "ft%" , "ft%" ) ) ; stats . add ( new stat ( "division ifree-throw percentage" , "fta" , "fta" ) ) ; stats . add ( new stat ( "division iblocked shots per game" , "bkpg" , "bkpg" ) ) ; stats . add ( new stat ( "division isteals per game" , "stpg" , "stpg" ) ) ; stats . add ( new stat ( "division iturnovers per game" , "topg" , "topg" ) ) ; stats . add ( new stat ( "division iturnover margin" , "opp to" , "opp topg" ) ) ; stats . add ( new stat ( "division iassists per game" , "apg" , "apg" ) ) ; stats . add ( new stat ( "division ithree pt fg defense" , "pct" , "opp 3fg%" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "3fg%" , "3fg%" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "3fga" , "3fga" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "gm" , "gm" ) ) ; if ( args [ 1 ] . equals ( "women" ) ) { stats . add ( new stat ( "division iturnover margin" , "margin" , "to ratio" ) ) ; } else { stats . add ( new stat ( "division iturnover margin" , "ratio" , "to ratio" ) ) ; } string rankingsfilename = "seasons/" + year + "/rankings_" + sex + ".csv" ; string firstroundfilename = "seasons/" + year + "/firstround_" + sex + ".csv" ; string outputfilename = "results/" + refereeclassname + ".csv" ; new file ( "results" ) . mkdir ( ) ; hashtable < string , team > teams = parser . parseteams ( new filereader ( rankingsfilename ) , stats ) ; round firstround = parser . parsefirstround ( new filereader ( firstroundfilename ) , teams ) ; vector < team > firstroundteams = new vector < team > ( ) ; for ( game game : firstround ) { firstroundteams . add ( game . teams [ 0 ] ) ; firstroundteams . add ( game . teams [ 1 ] ) ; } tournament t = new tournament ( firstround , null , referee ) ; t . play ( ) ; system . out . print ( t . toprintablestring ( ) ) ; filewriter writer = new filewriter ( outputfilename ) ; writer . write ( t . tosummarystring ( ) ) ; writer . close ( ) ; }
tr	5	public boolean istieneunprefijo ( atributovo atributovo ) { @ suppresswarnings ( "unchecked" ) list < string > prefijos = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . prefijo_entida ) ; for ( string prefijo : prefijos ) { if ( atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) { system . out . println ( prefijo + " == " + atributovo . gettipoatributoenti ( ) + " = " + atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) ; return true ; } } return false ; }
tr	3	@ override public byte [ ] getimagefromsite ( string url ) { url siteurl = null ; bytearrayoutputstream out = null ; inputstream in = null ; byte [ ] response = null ; try { siteurl = new url ( url ) ; in = new bufferedinputstream ( siteurl . openstream ( ) ) ; out = new bytearrayoutputstream ( ) ; byte [ ] buf = new byte [ 1024 ] ; int n = 0 ; while ( - 1 != ( n = in . read ( buf ) ) ) { out . write ( buf , 0 , n ) ; } response = out . tobytearray ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return response ; }
tr	7	private string plurality ( list < instance > examples ) { map < string , integer > scores = new linkedhashmap < string , integer > ( ) ; for ( instance instance : examples ) { integer score = scores . get ( instance . label ) ; if ( score == null ) { score = 0 ; } scores . put ( instance . label , score + 1 ) ; } if ( scores . isempty ( ) ) { return "1" ; } else if ( scores . size ( ) == 1 ) { return scores . keyset ( ) . iterator ( ) . next ( ) ; } else { int winningscore = integer . min_value ; string winner = null ; for ( string label : scores . keyset ( ) ) { if ( ! label . equals ( winner ) ) { int score = scores . get ( label ) ; if ( winningscore == score ) { if ( label . comparetoignorecase ( winner ) < 0 ) { winner = label ; } } else if ( winningscore < score ) { winner = label ; winningscore = score ; } } } return winner ; } }
tr	8	public isogrid ( ) { textureloader tx = new textureloader ( ) ; texture testtex = tx . gettexture ( "assets/iso_grass.png" ) ; texture testtex2 = tx . gettexture ( "assets/iso_grass2.png" ) ; texture flowers = tx . gettexture ( "assets/iso_grass3.png" ) ; texture flower = tx . gettexture ( "assets/iso_grass4.png" ) ; texture mushroom = tx . gettexture ( "assets/iso_grass5.png" ) ; texture clump = tx . gettexture ( "assets/iso_grass6.png" ) ; texture tex = null ; for ( int y = 0 ; y < 50 ; y ++ ) { for ( int x = 0 ; x < 20 ; x ++ ) { if ( rnd . nextint ( 100 ) > 98 ) { if ( rnd . nextint ( 100 ) > 70 ) { tex = mushroom ; } else { tex = flowers ; } } else if ( rnd . nextint ( 100 ) > 95 ) { if ( rnd . nextint ( 100 ) > 70 ) { tex = clump ; } else { tex = flower ; } } else if ( rnd . nextint ( 100 ) > 60 ) { tex = testtex2 ; } else { tex = testtex ; } if ( y % 2 == 0.0 ) { drawable q = new isoquad ( x * 64 , ( y * 16 ) , tex ) ; pipe . add ( q ) ; } else { drawable q = new isoquad ( ( x * 64 ) + 32 , ( y * 16 ) , tex ) ; pipe . add ( q ) ; } } } }
tr	10	public vector < site > findbabysites ( ) { vector < site > babysites = new vector < site > ( ) ; for ( int m = - 1 ; m <= 1 ; m ++ ) { for ( int n = - 1 ; n <= 1 ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null ) { babysites . addelement ( site ) ; } } } } collections . shuffle ( babysites ) ; return babysites ; }
tr	6	private ichromosome setupchromosome ( final int [ ] set ) throws invalidconfigurationexception { subsetgenes = new gene [ k ] ; int minelementvalue = integer . max_value ; int maxelementvalue = integer . min_value ; for ( final int element : set ) { minelementvalue = math . min ( element , minelementvalue ) ; maxelementvalue = math . max ( element , maxelementvalue ) ; } for ( int g = 0 ; g < k ; g ++ ) { subsetgenes [ g ] = new integergene ( configuration , 0 , numelementsinset - 1 ) ; } final gene [ ] genes = new gene [ 1 + getnumberofparameters ( ) ] ; final abstractsupergene constrainedgenes = new subsetsupergene ( configuration , subsetgenes , this . allelements ) ; genes [ 0 ] = constrainedgenes ; for ( int paramindex = 0 ; paramindex < getnumberofparameters ( ) ; paramindex ++ ) { genes [ 1 + paramindex ] = new integergene ( configuration , 0 , this . allpossibleparametervalues [ paramindex ] . length - 1 ) ; } subsetchromosome = new chromosome ( configuration , genes ) ; return subsetchromosome ; }
va	6	public boolean optimize ( final int numsteps , final double convergencedelta ) throws invalidconfigurationexception { if ( ! configured ) { configure ( ) ; } final int deltanumsteps = numsteps / 10 ; final genotype population = genotype . randominitialgenotype ( configuration ) ; final boolean converged ; int timesfitnessstable = 0 ; double previousfitness = - 1 ; progresslogger . expectedupdates = numsteps ; progresslogger . start ( "optimization" ) ; ichromosome fitestchromosome = null ; double fitness = - 2 ; for ( int i = 0 ; i < numsteps ; i ++ ) { fitestchromosome = population . getfittestchromosome ( ) ; fitness = fitnessfunction . getfitnessvalue ( fitestchromosome ) ; fitestfunctionvalue = fitness ; if ( i % moduloprogressreport == 1 ) { log . info ( "current solution has a fitness value of " + formatdouble ( math . log ( fitestchromosome . getfitnessvalue ( ) ) ) + " absolute: " + formatdouble ( math . log ( fitness ) ) + "or raw: " + fitness ) ; log . debug ( fitestchromosome . getgene ( 0 ) . tostring ( ) ) ; } if ( fitness >= previousfitness && fitness - previousfitness < math . abs ( convergencedelta ) ) { timesfitnessstable ++ ; log . trace ( "fitness function value stable " + timesfitnessstable ) ; } else { timesfitnessstable = 0 ; log . trace ( "fitness function not stable<litcomma> old: " + previousfitness + " new fitness: " + fitness ) ; } previousfitness = fitness ; if ( timesfitnessstable >= deltanumsteps ) { break ; } numberofiterationsperformed = i ; if ( i != numsteps - 1 ) { population . evolve ( ) ; progresslogger . lightupdate ( ) ; } } if ( fitness - previousfitness < math . abs ( convergencedelta ) ) { converged = true ; } else { converged = false ; } progresslogger . stop ( "optimization" ) ; convertfittesttosolution ( fitestchromosome ) ; return converged ; }
va	8	private static string median ( list < string > numberslist ) { string result = null ; if ( numberslist . size ( ) % 2 == 0 ) { int middle = numberslist . size ( ) / 2 ; int middleright = integer . parseint ( numberslist . get ( middle ) ) ; int middleleft = integer . parseint ( numberslist . get ( middle - 1 ) ) ; result = integer . tostring ( ( middleright + middleleft ) / 2 ) ; } else { result = numberslist . get ( numberslist . size ( ) / 2 ) ; } return result ; }
va	1	@ override public int insertcustomer ( site site ) { connection con = conn . getconnection ( true ) ; try { preparedstatement ps = con . preparestatement ( "insert into public.site values (?<litcomma>?)" ) ; ps . setint ( 1 , site . getid ( ) ) ; ps . setstring ( 2 , site . getsitename ( ) ) ; ps . execute ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { con . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return 0 ; }
va	5	protected void from_net ( string header ) throws exception { log . info ( "try from net!" ) ; string host = extractfromheader ( header , "host:" , "\\n" ) , path = getpath ( header ) ; if ( ( host == null ) || ( path == null ) ) { printerror ( "invalid request:\\n" + header ) ; return ; } log . info ( "transform path: " + path ) ; int port = host . indexof ( ":" , 0 ) ; if ( port < 0 ) port = 80 ; else { port = integer . parseint ( host . substring ( port + 1 ) ) ; host = host . substring ( 0 , port ) ; } log . info ( "from net host+port: " + host + ":" + port ) ; from_net ( header , host , port , path ) ; }
va	10	private list < student > getpageofstudents ( ) { final list < student > pagestudents = new vector < student > ( ) ; if ( students . size ( ) == 0 || currpage < 0 || currpage >= getmaxpage ( ) ) { return pagestudents ; } int size = 0 ; if ( students . size ( ) - viewsize * currpage < viewsize ) { size = students . size ( ) - viewsize * currpage ; } else { size = viewsize ; } if ( size == 0 ) { return pagestudents ; } for ( int i = 0 ; i < size ; ++ i ) { pagestudents . add ( students . get ( i + viewsize * currpage ) ) ; } return pagestudents ; }
va	9	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == caesarshiftbutton ) { string inputstring = ( ( jtextfield ) caesarinputpanel . getcomponent ( 1 ) ) . gettext ( ) ; int [ ] charsteps = new int [ caesarspinnerpanel . getcomponentcount ( ) ] ; for ( int i = 0 ; i < charsteps . length ; i ++ ) charsteps [ i ] = ( int ) ( ( jspinner ) caesarspinnerpanel . getcomponent ( i ) ) . getvalue ( ) ; boolean right = ( caesarreverse . isselected ( ) ) ? false : true ; string outputstring = caesar . shift ( inputstring , charsteps , right ) ; ( ( jtextfield ) caesaroutputpanel . getcomponent ( 1 ) ) . settext ( outputstring ) ; } else if ( e . getsource ( ) == caesaraddspinners ) { if ( caesarspinnerpanel . getcomponentcount ( ) < 13 ) { jspinner jspinner = new jspinner ( new spinnernumbermodel ( 1 , 1 , 26 , 1 ) ) ; jspinner . setpreferredsize ( new dimension ( 50 , 25 ) ) ; caesarspinnerpanel . add ( jspinner ) ; revalidate ( ) ; repaint ( ) ; } } else if ( e . getsource ( ) == caesarremovespinners ) { if ( caesarspinnerpanel . getcomponentcount ( ) > 1 ) { caesarspinnerpanel . remove ( caesarspinnerpanel . getcomponentcount ( ) - 1 ) ; revalidate ( ) ; repaint ( ) ; } } else if ( e . getsource ( ) == desencryptbutton ) { string message = ( ( jtextfield ) desinputpanel . getcomponent ( 1 ) ) . gettext ( ) ; string key = ( ( jtextfield ) desinputpanel . getcomponent ( 3 ) ) . gettext ( ) ; arraylist < string > output = des . encrypt ( key , message ) ; string outputstring = "" ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) outputstring += output . get ( i ) ; ( ( jtextarea ) ( ( jviewport ) desoutputpane . getcomponent ( 0 ) ) . getview ( ) ) . settext ( outputstring ) ; } else if ( e . getsource ( ) == rsaencryptbutton ) { string pin = ( ( jtextfield ) rsainputpanel . getcomponent ( 1 ) ) . gettext ( ) ; string qin = ( ( jtextfield ) rsainputpanel . getcomponent ( 3 ) ) . gettext ( ) ; string ein = ( ( jtextfield ) rsainputpanel . getcomponent ( 5 ) ) . gettext ( ) ; string min = ( ( jtextfield ) rsainputpanel . getcomponent ( 7 ) ) . gettext ( ) ; arraylist < string > output = rsa . encrypt ( biginteger . valueof ( long . parselong ( pin ) ) , biginteger . valueof ( long . parselong ( qin ) ) , biginteger . valueof ( long . parselong ( ein ) ) , biginteger . valueof ( long . parselong ( min ) ) ) ; string outputstring = "" ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) outputstring += output . get ( i ) + "\\n" ; ( ( jtextarea ) ( ( jviewport ) rsaoutputpane . getcomponent ( 0 ) ) . getview ( ) ) . settext ( outputstring ) ; } }
va	9	private static char addandcheckwrap ( char c , int currentchar , int [ ] steps , boolean right ) { int c = ( ( int ) c ) ; int loop ; int mod = ( currentchar % steps . length ) ; if ( mod == 0 ) loop = steps [ steps . length - 1 ] ; else loop = steps [ ( mod - 1 ) ] ; if ( isalphanumericcharacter ( c ) ) { if ( right ) { for ( int i = 0 ; i < loop ; i ++ ) { c ++ ; if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) '9' ) + 1 ) ) c = ( ( int ) '0' ) ; } } else { for ( int i = loop ; i > 0 ; i -- ) { c -- ; if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) '0' ) - 1 ) ) c = ( ( int ) '9' ) ; } } } return ( ( char ) c ) ; }
va	8	public void keypressed ( keyevent e ) { if ( e . getkeychar ( ) == keyevent . vk_enter && kentta . gettext ( ) . length ( ) != 0 ) { if ( heitot == 3 ) { try { valinta = integer . parseint ( kentta . gettext ( ) ) - 1 ; if ( valinta >= 0 && valinta < yhdistelmat . size ( ) ) { pelaajat . get ( currentpelaaja ) . getvihko ( ) . setpisteet ( yhdistelmat . get ( valinta ) ) ; pelaaja1 . settext ( "pelaaja 1" + "\\n" + "\\n" + pelaajat . get ( 0 ) . getvihko ( ) . tostring ( ) ) ; pelaaja2 . settext ( "pelaaja 2" + "\\n" + "\\n" + pelaajat . get ( 1 ) . getvihko ( ) . tostring ( ) ) ; lock = false ; system . out . println ( "enter pressed" ) ; yhdistelmarivi . settext ( kentta . gettext ( ) ) ; save ( ) ; } } catch ( numberformatexception ex ) { yhdistelmarivi . settext ( "annettu komento ei ollut numero:" + "\\n" + "\\n" + pelaajat . get ( currentpelaaja ) . mahdollisetyhdistelmattostring ( ) ) ; } } } }
va	3	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; system . out . print ( "please enter the public key number(n):" ) ; long input_n = sc . nextlong ( ) ; system . out . println ( ) ; system . out . print ( "please enter the public key value(e):" ) ; long input_e = sc . nextlong ( ) ; system . out . println ( ) ; bruteforce bf = new bruteforce ( input_n , input_e ) ; key k = bf . bruteforcecrack ( ) ; if ( k == null ) { system . out . println ( "the input key pair in not factorizable" ) ; } else { system . out . println ( "the private key(d<litcomma>m) pair for the input is (" + k . getdecryptkey ( ) + "<litcomma>" + k . getm ( ) + ")" ) ; } while ( true ) { system . out . println ( "please input encrypt number:" ) ; long input = sc . nextlong ( ) ; int letter = ( int ) rsa . modulo ( input , k . getdecryptkey ( ) , input_n ) ; system . out . println ( "decrypt result is:" + letter ) ; system . out . println ( "letter is:" + ( char ) letter ) ; } }
va	2	public static message getservermessage ( string jsonmessage ) { jsonparser parser = new jsonparser ( ) ; jsonobject obj = parser . parse ( jsonmessage ) . getasjsonobject ( ) ; string type = gson . fromjson ( obj . get ( "type" ) , string . class ) ; if ( type . equals ( "greetings_program" ) ) { return gson . fromjson ( jsonmessage , greetingmessage . class ) ; } else if ( type . equals ( "request" ) ) { return gson . fromjson ( jsonmessage , movemessage . class ) ; } else if ( type . equals ( "result" ) ) { return gson . fromjson ( jsonmessage , resultmessage . class ) ; } else if ( type . equals ( "error" ) ) { return gson . fromjson ( jsonmessage , errormessage . class ) ; } else { errormessage err = new errormessage ( ) ; err . message = "unknown response type [" + type + "] from server" ; return err ; } }
va	10	private void findminimaldistances ( vertex node ) { list < vertex > adjacentnodes = getneighbors ( node ) ; vertex lasttarget = null ; for ( vertex target : adjacentnodes ) { system . out . println ( "target.tostring() " + target . tostring ( ) ) ; if ( getshortestdistance ( target ) > getshortestdistance ( node ) + getdistance ( node , target ) ) { distance . put ( target , getshortestdistance ( node ) + getdistance ( node , target ) ) ; predecessors . put ( target , node ) ; unsettlednodes . add ( target ) ; } for ( int i = 0 ; i < ds . notoknumber . length - 1 ; i ++ ) { if ( predecessors . get ( target ) != null ) { if ( ds . notoknumber [ i + 1 ] == integer . parseint ( predecessors . get ( target ) . getid ( ) ) && ds . notoknumber [ i ] == integer . parseint ( target . getid ( ) ) ) { predecessors . remove ( target ) ; predecessors . remove ( lasttarget ) ; distance . remove ( target ) ; distance . remove ( lasttarget ) ; } } } lasttarget = target ; } }
va	6	private void initagents ( ) { agents = new vector < agent > ( ) ; for ( int a = 0 ; a < numagents ; a ++ ) { agents . add ( new agent ( this ) ) ; } for ( int a = 0 ; a < agents . size ( ) ; a ++ ) { int x = 0 ; int y = 0 ; boolean free = false ; while ( ! free ) { x = gen . nextint ( xsize ) ; y = gen . nextint ( ysize ) ; free = ( grid [ x ] [ y ] . getagent ( ) == null ) ; } agent agent = agents . elementat ( a ) ; agent . setposition ( x , y ) ; grid [ x ] [ y ] . setagent ( agent ) ; } }
va	1	public static void main ( string [ ] args ) { iimagedownload imagedownloader = new imagedownloader ( ) ; list < string > images = imagedownloader . getimageslist ( "http://showusyourass.tumblr.com/" ) ; bufferedoutputstream bufferedwriter = null ; int i = 0 ; try { for ( string image : images ) { system . out . println ( "downloading " + image ) ; bufferedwriter = new bufferedoutputstream ( new fileoutputstream ( "/users/admin/downloads/zjava/" + i + "_" + image . substring ( image . length ( ) - 4 , image . length ( ) ) ) ) ; bufferedwriter . write ( imagedownloader . getimagefromsite ( image ) ) ; bufferedwriter . close ( ) ; i ++ ; system . out . println ( "downloading " + image + " complete" ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } system . out . println ( "that's it" ) ; }
va	7	@ override public void init ( gamecontainer container ) throws slickexception { this . container = container ; container . settargetframerate ( 60 ) ; int size = 5 ; int speed = 3 ; int rotation = 20 ; float range = 40 ; ship = new ship ( size , speed , rotation , range , this ) ; list < obj > shiplist = new list < obj > ( ) ; shiplist . add ( ship ) ; bulletlist = new list < obj > ( ) ; astlist = new list < obj > ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { float [ ] loc = new float [ 2 ] ; loc [ 0 ] = ( float ) ( math . random ( ) * container . getwidth ( ) ) ; loc [ 1 ] = ( float ) ( math . random ( ) * container . getheight ( ) ) ; list < obj > pointer = astlist ; while ( pointer . next != null ) { pointer = pointer . next ; } list < obj > wrapper = new list < obj > ( ) ; asteroid ast = new asteroid ( loc , ( float ) ( math . random ( ) * 10 + 4 ) , wrapper , this ) ; wrapper . data = ast ; wrapper . previous = pointer ; pointer . next = wrapper ; } gamelist = new list < list < obj > > ( ) ; gamelist . add ( bulletlist ) ; gamelist . add ( astlist ) ; gamelist . add ( shiplist ) ; }
va	5	private void parseparameterdefinitions ( final string [ ] paramdefinitions ) { int paramindex = 0 ; parameternames = new string [ paramdefinitions . length ] ; allpossibleparametervalues = new double [ paramdefinitions . length ] [ ] ; for ( final string parameterdefinition : paramdefinitions ) { final string [ ] tokens = parameterdefinition . split ( "[=<litcomma>]" ) ; assert tokens . length > 3 : "parameter definition must be of the form name=value1<litcomma>value2<litcomma>..." ; parameternames [ paramindex ] = tokens [ 0 ] ; final doublelist paramvalues = new doublearraylist ( ) ; for ( int valueindex = 1 ; valueindex < tokens . length ; valueindex ++ ) { paramvalues . add ( double . parsedouble ( tokens [ valueindex ] ) ) ; } allpossibleparametervalues [ paramindex ] = paramvalues . todoublearray ( ) ; paramindex ++ ; } }
va	4	public static void checkall ( list < list < obj > > objlist , int delta ) { list < list < obj > > list1 = objlist . next ; while ( list1 != null ) { list < obj > obj1 = list1 . data . next ; while ( obj1 != null ) { list < list < obj > > list2 = list1 ; list < obj > obj2 = obj1 . next ; while ( list2 != null ) { while ( obj2 != null ) { if ( obj2 . data . shape . intersects ( obj1 . data . shape ) ) { obj2 . data . collide ( obj1 . data , delta ) ; obj1 . data . collide ( obj2 . data , delta ) ; } obj2 = obj2 . next ; } list2 = list2 . next ; if ( list2 != null ) obj2 = list2 . data . next ; } obj1 = obj1 . next ; } list1 = list1 . next ; if ( list1 != null ) obj1 = list1 . data . next ; } }
va	2	public playermessage handlemessage ( message message ) { if ( message . type . equals ( "request" ) ) { movemessage m = ( movemessage ) message ; if ( game_id != m . state . game_id ) { game_id = m . state . game_id ; if ( opponent != m . state . opponent_id ) { if ( totalgames != 0 ) { double wonratio = 1.0 * wongames / totalgames ; system . out . println ( opponent + " --- " + string . format ( "%.2f" , wonratio ) + "(w:" + wongames + " t:" + totalgames + ")" ) ; } totalgames = 0 ; wongames = 0 ; opponent = m . state . opponent_id ; } } if ( m . request . equals ( "request_card" ) ) { boolean shouldplay = ( ! m . state . can_challenge || ischanllenge ( m ) == false ) ; if ( shouldplay ) { int i = dm . onreceiverequest ( status , m ) ; if ( i == 9999 ) { offerchallengemessage challenge = new offerchallengemessage ( m . request_id ) ; return challenge ; } int [ ] hand = m . state . hand ; sort ( hand ) ; playcardmessage card = new playcardmessage ( m . request_id , hand [ i ] ) ; return card ; } else { offerchallengemessage challenge = new offerchallengemessage ( m . request_id ) ; return challenge ; } } else if ( m . request . equals ( "challenge_offered" ) ) { playermessage response ; if ( acceptchallenge ( m ) ) { response = new acceptchallengemessage ( m . request_id ) ; } else { response = new rejectchallengemessage ( m . request_id ) ; } return response ; } } else if ( message . type . equals ( "result" ) ) { resultmessage r = ( resultmessage ) message ; if ( r . result . type . equals ( "game_won" ) ) { if ( r . result . by == r . your_player_num ) wongames ++ ; totalgames ++ ; } dm . onreceiveresult ( status , r ) ; } else if ( message . type . equals ( "error" ) ) { errormessage e = ( errormessage ) message ; system . err . println ( "error: " + e . message ) ; if ( e . seen_host != null ) { system . exit ( 1 ) ; } } return null ; }
va	4	public static void main ( string args [ ] ) throws ioexception { string [ ] queystring = new string [ ] { "mondego" , "machine%20learning" , "software%20engineering" , "security" , "student%20affairs" , "crista%20lopes" , "rest" , "computer%20games" , "information%20retrieval" } ; string noofresults = "8" ; for ( string query : queystring ) { url url = new url ( "https://ajax.googleapis.com/ajax/services/search/web?v=1.0&" + "q=" + query + "%20site:ics.uci.edu&userip=users-ip-address&rsz=" + noofresults ) ; urlconnection connection = url . openconnection ( ) ; connection . addrequestproperty ( "referer" , "http://www.ics.uci.edu/" ) ; string line ; stringbuilder builder = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( connection . getinputstream ( ) ) ) ; while ( ( line = reader . readline ( ) ) != null ) { builder . append ( line ) ; } jsonobject json = new jsonobject ( builder . tostring ( ) ) ; jsonarray jsonarray = json . getjsonobject ( "responsedata" ) . getjsonarray ( "results" ) ; system . out . println ( "==========================================" ) ; system . out . println ( ) ; system . out . println ( "-------------------------------------" ) ; system . out . println ( "query string: " + query . replace ( "%20" , " " ) ) ; system . out . println ( "-------------------------------------" ) ; system . out . println ( ) ; for ( int i = 0 ; i < jsonarray . length ( ) ; i ++ ) { jsonobject o = ( jsonobject ) jsonarray . get ( i ) ; system . out . println ( "title: " + o . get ( "titlenoformatting" ) ) ; system . out . println ( "url: " + o . get ( "url" ) ) ; system . out . println ( ) ; system . out . println ( ) ; } system . out . println ( "==========================================" ) ; } }
va	7	private boolean checkborders ( ) { boolean check = false ; int width = gameinst . container . getwidth ( ) ; int height = gameinst . container . getheight ( ) ; if ( location [ 0 ] >= width ) { check = true ; if ( velocity [ 0 ] > 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 0 ] <= 0 ) { check = true ; if ( velocity [ 0 ] < 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 1 ] >= height ) { check = true ; if ( velocity [ 1 ] > 0 ) velocity [ 1 ] *= - .5f ; } if ( location [ 1 ] <= 0 ) { check = true ; if ( velocity [ 1 ] < 0 ) velocity [ 1 ] *= - .5f ; } return check ; }
va	3	@ override public list < string > getimageslist ( string url ) { arraylist < string > imglist = new arraylist < string > ( ) ; try { string pagestr = readpage ( new url ( url ) ) ; matcher m = imagepattern . matcher ( pagestr ) ; while ( m . find ( ) ) { imglist . add ( m . group ( 1 ) ) ; } } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return imglist ; }
te	7	public arraylist < yhdistelma > getyhdistelmat ( ) { arraylist < yhdistelma > a = new arraylist < yhdistelma > ( ) ; int points = 0 ; if ( ykkoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 1 ) { points ++ ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . ykkoset ) ) ; points = 0 ; } if ( kakkoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 2 ) { points ++ ; } } points = points * 2 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kakkoset ) ) ; points = 0 ; } if ( kolmoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 3 ) { points ++ ; } } points = points * 3 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kolmoset ) ) ; points = 0 ; } if ( neloset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 4 ) { points ++ ; } } points = points * 4 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . neloset ) ) ; points = 0 ; } if ( viitoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 5 ) { points ++ ; } } points = points * 5 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . viitoset ) ) ; points = 0 ; } if ( kuutoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 6 ) { points ++ ; } } points = points * 6 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kuutoset ) ) ; points = 0 ; } if ( kaksiparia ( ) ) { int ind = 0 ; int tmppoints ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { ind = i + 2 ; points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; break ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; tmppoints = points ; points = 0 ; for ( int i = ind ; i < 4 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { ind = i + 2 ; points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; tmppoints = tmppoints + points ; points = 0 ; a . add ( new yhdistelma ( nopat , tmppoints , jatsiyhdistelma . kaksi_paria ) ) ; } else if ( pari ( ) || kolmesamaa ( ) || neljasamaa ( ) ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; points = 0 ; } if ( kolmesamaa ( ) || neljasamaa ( ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 2 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) + nopat [ i + 2 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kolme_samaa ) ) ; points = 0 ; } if ( neljasamaa ( ) ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 2 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 3 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) + nopat [ i + 2 ] . getvalue ( ) + nopat [ i + 3 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . nelja_samaa ) ) ; points = 0 ; } if ( pikkusuora ( ) ) { a . add ( new yhdistelma ( nopat , 15 , jatsiyhdistelma . pikkusuora ) ) ; } if ( isosuora ( ) ) { a . add ( new yhdistelma ( nopat , 20 , jatsiyhdistelma . isosuora ) ) ; } if ( tayskasi ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { points = points + nopat [ i ] . getvalue ( ) ; } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . tayskasi ) ) ; points = 0 ; } for ( int i = 0 ; i < 5 ; i ++ ) { points = points + nopat [ i ] . getvalue ( ) ; } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . sattuma ) ) ; points = 0 ; if ( yatzy ( ) ) { a . add ( new yhdistelma ( nopat , 50 , jatsiyhdistelma . yatzy ) ) ; } return a ; }
te	4	public string tostring ( ) { string s = "" ; for ( int i = 0 ; i < 6 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "valisumma: " + valisumma ) + "\\n" ; s = s + ( "bonus: " + bonus ) + "\\n" ; s = s + "-------------------------------------------------" + "\\n" ; for ( int i = 6 ; i < 8 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + ( jatsiyhdistelmat . get ( 8 ) . name ( ) + ":\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( 8 ) ) ) + "\\n" ; for ( int i = 9 ; i < 15 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "summa: " + summa ) + "\\n" ; return s ; }
te	10	public int largestrectangleareatle ( int [ ] height ) { int [ ] area = new int [ height . length ] ; int [ ] area2 = new int [ height . length ] ; for ( int i = 0 ; i < height . length ; i ++ ) { int left = height [ i ] ; int unit = 1 ; for ( int j = i + 1 ; j < height . length ; j ++ ) { if ( height [ j ] >= left ) { unit ++ ; if ( j == height . length - 1 ) { area [ i ] = unit * left ; } } else { area [ i ] = unit * left ; break ; } } } for ( int i = height . length - 1 ; i >= 0 ; i -- ) { int right = height [ i ] ; int unit = 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( height [ j ] >= right ) { unit ++ ; if ( j == 0 ) { area2 [ i ] = unit * right ; } } else { area2 [ i ] = unit * right ; break ; } } } int max = 0 ; for ( int i = 0 ; i < height . length ; i ++ ) { int larger = math . max ( area [ i ] , area2 [ i ] ) ; if ( larger > max ) max = larger ; } return max ; }
te	6	private boolean delete ( commandsender sender , string [ ] args ) { if ( ban != null ) { sender . sendmessage ( chatcolor . red + "finish what you're doing first!" ) ; return true ; } if ( args . length < 2 ) { sender . sendmessage ( chatcolor . red + "usage: delete [id]" ) ; return true ; } int id ; try { id = integer . parseint ( args [ 1 ] ) ; } catch ( numberformatexception exc ) { sender . sendmessage ( chatcolor . red + "id has to be a number!" ) ; return true ; } for ( int i = 0 ; i < plugin . bannedplayers . size ( ) ; i ++ ) { if ( plugin . bannedplayers . get ( i ) . id == id ) { plugin . bannedplayers . remove ( i ) ; break ; } } boolean success = plugin . db . deletefullrecord ( id ) ; if ( success ) sender . sendmessage ( chatcolor . green + "deleted record " + id ) ; else sender . sendmessage ( chatcolor . red + "can't find record " + id ) ; return success ; }
te	2	public static void main ( string [ ] args ) { chat ch = new chat ( ) ; if ( args . length == 1 ) { int port = integer . parseint ( args [ 0 ] ) ; ch . mode1 ( port ) ; } else if ( args . length == 2 ) { debug . print ( args [ 0 ] ) ; debug . print ( args [ 1 ] ) ; int port = integer . parseint ( args [ 0 ] ) ; string host = args [ 1 ] ; ch . mode2 ( port , host ) ; } else { system . out . println ( "usage: java chat <port num> [<host name>]" ) ; system . exit ( 0 ) ; } }
te	1	private float [ ] makepoints ( float [ ] loc , float rotation ) { float cos = helper . cos ( rotation ) ; float sin = helper . sin ( rotation ) ; float [ ] pts = new float [ 8 ] ; pts [ 0 ] = loc [ 0 ] - width / 2 * sin ; pts [ 1 ] = loc [ 1 ] + width / 2 * cos ; pts [ 2 ] = pts [ 0 ] + hieght * cos ; pts [ 3 ] = pts [ 1 ] + hieght * sin ; pts [ 4 ] = pts [ 2 ] + width * sin ; pts [ 5 ] = pts [ 3 ] - width * cos ; pts [ 6 ] = pts [ 4 ] - hieght * cos ; pts [ 7 ] = pts [ 5 ] - hieght * sin ; return pts ; }
te	1	private string generarimports ( ) { stringbuilder sb = new stringbuilder ( ) ; map < string , string > importables = new hashmap < string , string > ( ) ; for ( atributovo atributovo : atributos ) { if ( ! isnoimportable ( atributovo . getnombrepackagetype ( ) ) && ! importables . containsvalue ( atributovo . getnombrepackagetype ( ) ) && ! atributovo . getnombrepackagetype ( ) . startswith ( paquetecontenedororigen ) ) { sb . append ( "import " + atributovo . getnombrepackagetype ( ) + ";" + nl ) ; importables . put ( atributovo . getnombrepackagetype ( ) , atributovo . getnombrepackagetype ( ) ) ; } } sb . append ( "import java.io.serializable;\\n" + nl ) ; return sb . tostring ( ) ; }
te	10	private hashmap < string , hashset < string > > scramble ( string s ) { hashmap < string , hashset < string > > res = new hashmap < string , hashset < string > > ( ) ; if ( s . length ( ) == 0 ) return res ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string curr = s . substring ( i , i + 1 ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; path . add ( curr ) ; res . put ( curr , path ) ; } } for ( int x = 2 ; x <= s . length ( ) ; x ++ ) { for ( int i = 0 ; i <= s . length ( ) - x ; i ++ ) { string curr = s . substring ( i , i + x ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; for ( int k = 1 ; k < curr . length ( ) ; k ++ ) { hashset < string > left = res . get ( curr . substring ( 0 , k ) ) ; hashset < string > right = res . get ( curr . substring ( k , curr . length ( ) ) ) ; for ( string l : left ) { for ( string r : right ) { if ( ! path . contains ( l + r ) ) path . add ( l + r ) ; if ( ! path . contains ( r + l ) ) path . add ( r + l ) ; } } } res . put ( curr , path ) ; } } } return res ; }
te	5	public static string readline ( inputstream inputstream ) throws ioexception { byte [ ] rawdata = readrawline ( inputstream ) ; if ( rawdata == null ) { return null ; } int len = rawdata . length ; int offset = 0 ; if ( len > 0 ) { if ( rawdata [ len - 1 ] == '\\n' ) { offset ++ ; if ( len > 1 ) { if ( rawdata [ len - 2 ] == '\\r' ) { offset ++ ; } } } } return getstring ( rawdata , 0 , len - offset ) ; }
te	3	public static void writeseperatefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata , string filename ) throws ioexception { filewriter fstream = new filewriter ( path_location + filename ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) ) ; out . newline ( ) ; out . write ( url ) ; out . newline ( ) ; out . write ( path ) ; out . newline ( ) ; if ( parenturl != null ) { out . write ( parenturl ) ; out . newline ( ) ; } out . write ( title ) ; out . newline ( ) ; out . write ( h1 ) ; out . newline ( ) ; out . write ( h2 ) ; out . newline ( ) ; out . write ( h3 ) ; out . newline ( ) ; out . write ( bold ) ; out . newline ( ) ; out . write ( strong ) ; out . newline ( ) ; out . write ( em ) ; out . newline ( ) ; out . write ( anchortext ) ; out . newline ( ) ; out . write ( parseddata ) ; out . close ( ) ; }
te	9	public hashmap < string , double > postionscore ( hashmap < string , hashmap < string , result > > resultsetmap , hashmap < string , double > score_map , string [ ] query_words , hashmap < string , double > query_map ) { if ( query_words . length != 2 ) return null ; hashmap < string , result > temp_map = null ; hashmap < string , result > temp_map2 = null ; temp_map = resultsetmap . get ( query_words [ 0 ] ) ; iterator < string > it = temp_map . keyset ( ) . iterator ( ) ; system . out . println ( "map: " + resultsetmap . tostring ( ) ) ; temp_map2 = resultsetmap . get ( query_words [ 1 ] ) ; result pos_res = null ; int pos_score = 1 ; int scale_factor = 1 ; while ( it . hasnext ( ) ) { string url = it . next ( ) ; if ( ( url . contains ( query_words [ 0 ] ) ) && ( url . contains ( query_words [ 1 ] ) ) ) { score_map . put ( url , ( score_map . get ( url ) ) + ( score_map . get ( url ) * weight ) ) ; continue ; } if ( url . contains ( query_words [ 0 ] ) ) { score_map . put ( url , ( score_map . get ( url ) ) + ( score_map . get ( url ) * weight ) ) ; continue ; } if ( url . contains ( query_words [ 1 ] ) ) { score_map . put ( url , ( score_map . get ( url ) + ( score_map . get ( url ) * weight ) ) ) ; continue ; } if ( temp_map2 . containskey ( url ) ) { string pos1 = temp_map . get ( url ) . pos ; string pos2 = temp_map2 . get ( url ) . pos ; linkedlist < integer > pos_list1 = get_list_from_string ( pos1 ) ; linkedlist < integer > pos_list2 = get_list_from_string ( pos2 ) ; for ( int i = 0 ; i < pos_list1 . size ( ) ; i ++ ) { int num = pos_list1 . get ( i ) + 1 ; if ( pos_list2 . contains ( num ) ) { pos_score += 1 ; } } scale_factor = 1 ; double score = score_map . get ( url ) ; score = score * ( 1 + math . log10 ( pos_score ) ) * scale_factor ; score_map . put ( url , score ) ; } } it = temp_map2 . keyset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { string url2 = it . next ( ) ; if ( url2 . contains ( query_words [ 1 ] ) ) { score_map . put ( url2 , ( score_map . get ( url2 ) ) + ( score_map . get ( url2 ) * weight ) ) ; } if ( url2 . contains ( query_words [ 1 ] ) && url2 . contains ( query_words [ 0 ] ) ) { score_map . put ( url2 , ( score_map . get ( url2 ) ) + ( score_map . get ( url2 ) * weight ) ) ; } } return score_map ; }
te	6	public static byte [ ] buildmessage ( byte code , int ... datas ) { byte [ ] message = new byte [ 1 + datas . length * 4 ] ; message [ 0 ] = code ; int indice = 1 ; for ( int i = 0 ; i < datas . length ; i ++ ) { byte [ ] data = toolbox . int2byte ( datas [ i ] ) ; for ( int j = 0 ; j < data . length ; j ++ ) { message [ indice ++ ] = data [ j ] ; } } return message ; }
te	9	public void download ( jprogressbar | , file destination ) { thread t = new thread ( ( ) -> { int downloaded = 0 ; list < imgurimage > images = getimages ( ) ; for ( imgurimage i : images ) { i . download ( destination ) ; downloaded ++ ; int perc = ( int ) ( ( ( ( double ) downloaded ) / images . size ( ) ) * 100 ) ; | . setvalue ( perc ) ; if ( perc == 100 ) gui . get ( ) . notifyfinished ( ) ; } } ) ; t . start ( ) ; }
te	4	private static void ints_linkedlist ( ) { int [ ] intarray = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 } ; stackofints_linkedlist intnode = new stackofints_linkedlist ( ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { system . out . println ( "node item = " + intnode . n + " ;" ) ; intnode . push ( intarray [ i ] ) ; } system . out . println ( "-------------------------------------" ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { int result = intnode . pop ( ) ; system . out . println ( "node item = " + intnode . n + " ; value = " + result ) ; } }
te	7	public string mahdollisetyhdistelmattostring ( ) { string s = "" ; arraylist < yhdistelma > y = mahdollisetyhdistelmat ( ) ; int ind = y . size ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; if ( i == y . size ( ) - 1 ) { s = s + "---------------------yliviivaa---------------------" + "\\n" ; } } y = yliviivattavat ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( ind + i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; } return s ; }
te	3	@ override public void visit ( page page ) { int docid = page . getweburl ( ) . getdocid ( ) ; string url = page . getweburl ( ) . geturl ( ) ; string domain = page . getweburl ( ) . getdomain ( ) ; string path = page . getweburl ( ) . getpath ( ) ; string subdomain = page . getweburl ( ) . getsubdomain ( ) ; string parenturl = page . getweburl ( ) . getparenturl ( ) ; if ( page . getparsedata ( ) instanceof htmlparsedata ) { htmlparsedata htmlparsedata = ( htmlparsedata ) page . getparsedata ( ) ; string text = htmlparsedata . gettext ( ) ; string html = htmlparsedata . gethtml ( ) ; list < weburl > links = htmlparsedata . getoutgoingurls ( ) ; string filename = docid + "_logger" ; try { if ( text . length ( ) != 0 ) { string parseddata = htmlparsedata . tostring ( ) ; if ( parseddata . trim ( ) . length ( ) != 0 || ! parseddata . equals ( " +" ) ) { system . out . println ( "=============" ) ; system . out . println ( "=============" ) ; system . out . println ( "docid: " + docid ) ; system . out . println ( "url: " + url ) ; system . out . println ( "domain: '" + domain + "'" ) ; system . out . println ( "sub-domain: '" + subdomain + "'" ) ; system . out . println ( "path: '" + path + "'" ) ; system . out . println ( "parent page: " + parenturl ) ; system . out . println ( "text length: " + text . length ( ) ) ; system . out . println ( "html length: " + html . length ( ) ) ; system . out . println ( "number of outgoing links: " + links . size ( ) ) ; arraylist < string > extracts = gettagcontents ( jsoup . parse ( html ) ) ; string title = extracts . get ( 0 ) ; string h1 = extracts . get ( 1 ) ; string h2 = extracts . get ( 2 ) ; string h3 = extracts . get ( 3 ) ; string bold = extracts . get ( 4 ) ; string strong = extracts . get ( 5 ) ; string em = extracts . get ( 6 ) ; string anchortext = extracts . get ( 7 ) ; parseddata = parsedata ( parseddata ) ; writeseperatefile ( docid , url , path , parenturl , title , h1 , h2 , h3 , bold , strong , em , anchortext , parseddata , filename ) ; writesinglefile ( docid , url , path , parenturl , title , h1 , h2 , h3 , bold , strong , em , anchortext , parseddata ) ; filewriter fstream_answers = new filewriter ( "urlnames" , true ) ; bufferedwriter out_answers = new bufferedwriter ( fstream_answers ) ; out_answers . write ( url ) ; out_answers . newline ( ) ; out_answers . close ( ) ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
te	5	public static string getpath ( string header ) { string uri = extractfromheader ( header , "get " , " " ) , path ; if ( uri == null ) uri = extractfromheader ( header , "post " , " " ) ; if ( uri == null ) return null ; path = uri . tolowercase ( ) ; if ( path . length ( ) >= 7 && path . indexof ( "http://" , 0 ) == 0 ) uri = uri . substring ( 7 ) ; else { path = extractfromheader ( header , "host:" , "\\n" ) ; if ( path == null ) return null ; uri = path + uri ; } uri = transform . fixurl ( uri ) ; uri = transform . url2file ( uri , ( byte ) 0 ) ; path = cache_path + file . separator + uri ; return path ; }
te	2	@ suppresswarnings ( "null" ) public static void main ( string [ ] args ) throws parseexception , corruptindexexception , ioexception { jsonarray jsearchobjectarray = new jsonarray ( ) ; jsonobject finaljsearchobject = new jsonobject ( ) ; standardanalyzer analyzer = new standardanalyzer ( version . lucene_40 ) ; string querystring = "crista lopes" ; stringtokenizer st = new stringtokenizer ( querystring ) ; string token = null ; int j = 1 ; booleanquery query = new booleanquery ( ) ; while ( st . hasmoretokens ( ) ) { token = st . nexttoken ( ) ; termquery titleterm = new termquery ( new term ( "title" , token ) ) ; titleterm . setboost ( 80.0f ) ; termquery contentsterm = new termquery ( new term ( "parseddata" , token ) ) ; contentsterm . setboost ( 190.0f ) ; termquery anchorterm = new termquery ( new term ( "anchortxt" , token ) ) ; anchorterm . setboost ( 25.0f ) ; termquery boldterm = new termquery ( new term ( "bold" , token ) ) ; boldterm . setboost ( 55.0f ) ; termquery strongterm = new termquery ( new term ( "strong" , token ) ) ; strongterm . setboost ( 60.0f ) ; termquery emterm = new termquery ( new term ( "em" , token ) ) ; emterm . setboost ( 65.0f ) ; query . add ( titleterm , occur . should ) ; query . add ( contentsterm , occur . should ) ; query . add ( anchorterm , occur . should ) ; query . add ( boldterm , occur . should ) ; query . add ( strongterm , occur . should ) ; query . add ( emterm , occur . should ) ; ++ j ; } int hitsperpage = 100 ; file indexdirectory = new file ( "c:\\\\ir_archieve\\\\index" ) ; indexreader reader = directoryreader . open ( fsdirectory . open ( indexdirectory ) ) ; indexsearcher searcher = new indexsearcher ( reader ) ; topscoredoccollector collector = topscoredoccollector . create ( hitsperpage , true ) ; searcher . search ( query , collector ) ; scoredoc [ ] hits = collector . topdocs ( ) . scoredocs ; system . out . println ( "found " + hits . length + " hits." ) ; for ( int i = 0 ; i < hits . length ; i ++ ) { jsonobject jsearchobject = new jsonobject ( ) ; int docid = hits [ i ] . doc ; document d = searcher . doc ( docid ) ; try { system . out . println ( ( i + 1 ) + ". " + "\\t" + d . get ( "filename" ) + "\\t" + d . get ( "title" ) + "\\t :: " + d . get ( "parseddata" ) . substring ( 100 , 150 ) ) ; } catch ( exception e ) { } jsearchobject . put ( "url" , d . get ( "filename" ) ) ; jsearchobject . put ( "title" , d . get ( "title" ) ) ; jsearchobject . put ( "anchor" , d . get ( "anchor" ) ) ; jsearchobject . put ( "contents" , d . get ( "contents" ) ) ; jsearchobjectarray . put ( i , jsearchobject ) ; } system . out . println ( jsearchobjectarray . length ( ) ) ; finaljsearchobject . put ( "results" , jsearchobjectarray ) ; system . out . println ( finaljsearchobject . get ( "results" ) ) ; }
te	8	private boolean time ( commandsender sender , string [ ] args ) { if ( args . length < 4 ) { sender . sendmessage ( chatcolor . red + "usage: time <add/sub/set> <time> <sec/min/hour/day/week/month>" ) ; return true ; } long time = plugin . parsetimespec ( args [ 2 ] , args [ 3 ] ) ; if ( time == 0 ) { sender . sendmessage ( chatcolor . red + "invalid time format" ) ; return true ; } boolean add = args [ 1 ] . equalsignorecase ( "add" ) , set = args [ 1 ] . equalsignorecase ( "set" ) , - = args [ 1 ] . equalsignorecase ( "sub" ) ; if ( add || set || - ) { if ( ban . endtime == 0 ) { ban . endtime = ban . time ; } if ( add ) { ban . endtime += time ; } else if ( set ) { ban . endtime = ban . time + time ; } else if ( - ) { ban . endtime -= time ; } date date = new date ( ) ; date . settime ( ban . endtime * 1000 ) ; sender . sendmessage ( chatcolor . yellow + "new time: " + chatcolor . white + date . tostring ( ) ) ; return true ; } return false ; }
te	8	@ override public string tostring ( ) { string ret = "" ; if ( nodes != null && nodes . size ( ) > 0 ) { stringbuilder sb = new stringbuilder ( ) ; list < tconnection > printed = new arraylist < tconnection > ( ) ; for ( tnode n : nodes ) { for ( tconnection c : n . getconnections ( ) ) { if ( ! printed . contains ( c ) ) printed . add ( c ) ; } } for ( tconnection c : printed ) { sb . append ( c + "\\n" ) ; } ret = sb . tostring ( ) ; } else ret = "empty tree" ; return ret ; }
