tr	2	public static arraylist < node > userinput ( ) { scanner scan = new scanner ( system . in ) ; string s ; do { system . out . print ( "enter path: " ) ; s = scan . next ( ) ; } while ( ! checkstring ( s ) ) ; string [ ] res = s . split ( "/" ) ; arraylist < node > listres = new arraylist < node > ( ) ; node f ; for ( string stname : res ) { if ( stname . contains ( "." ) ) { f = new file ( stname ) ; listres . add ( f ) ; break ; } else { f = new directory ( stname ) ; listres . add ( f ) ; } } return listres ; }
tr	10	public vector < site > findbabysites ( ) { vector < site > babysites = new vector < site > ( ) ; for ( int m = - 1 ; m <= 1 ; m ++ ) { for ( int n = - 1 ; n <= 1 ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null ) { babysites . addelement ( site ) ; } } } } collections . shuffle ( babysites ) ; return babysites ; }
tr	10	public void update ( ) { for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < ysize ; x ++ ) { site site = scape . grid [ x ] [ y ] ; jlabel label = labels [ x ] [ y ] ; double energy = site . getfood ( ) ; double div = ( 255 / scape . maxfood ) * energy ; int gradient = ( int ) ( 255 - div ) ; color background ; background = ( gradient > 235 ) ? new color ( 255 , 250 , 205 ) : new color ( gradient , 255 , gradient ) ; label . setbackground ( background ) ; if ( site . getagent ( ) != null ) { label . settext ( "o" ) ; label . setforeground ( color . red ) ; } else { label . settext ( "" ) ; } } } }
tr	4	private byte [ ] encapsulateip ( datagrampacket packet , inetaddress src , int srcport , inetaddress dst , int dstport ) throws ioexception { boolean ipv4 = src instanceof inet4address ; int data_length = packet . getlength ( ) ; int length = data_length + ( ipv4 ? 20 : 40 ) + 8 ; bytearrayoutputstream bytes = new bytearrayoutputstream ( length ) ; dataoutputstream tout = new dataoutputstream ( bytes ) ; byte [ ] ip_header = new byte [ 0 ] ; if ( ipv4 ) { ip_header = new byte [ ] { 0x45 , 0x00 , ( byte ) ( ( length << 8 ) & 0xff ) , ( byte ) ( length & 0xff ) , 0x00 , 0x00 , 0x00 , 0x00 , ( byte ) 0xff , 0x11 , 0x00 , 0x00 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; system . arraycopy ( src . getaddress ( ) , 0 , ip_header , 12 , 4 ) ; system . arraycopy ( dst . getaddress ( ) , 0 , ip_header , 16 , 4 ) ; int checksum = 0 ; for ( int i = 0 ; i < ip_header . length - 1 ; i += 2 ) { checksum += ip_header [ i ] << 8 | ip_header [ i + 1 ] ; } checksum &= 0xffff ; checksum += 2 ; checksum = ~ checksum ; ip_header [ 10 ] = ( byte ) ( ( checksum > > 8 ) & 0xff ) ; ip_header [ 11 ] = ( byte ) ( checksum & 0xff ) ; tout . write ( ip_header ) ; } else { return new byte [ 0 ] ; } tout . writeshort ( srcport ) ; tout . writeshort ( dstport ) ; tout . writeshort ( data_length ) ; tout . writeshort ( 0 ) ; tout . write ( packet . getdata ( ) ) ; return bytes . tobytearray ( ) ; }
tr	9	private void construirnuevotour ( ) { salidadedatos out = new salidadedatos ( ) ; stringbuilder mensaje = new stringbuilder ( ) ; for ( int t = 0 ; t < tmax ; t ++ ) { if ( t % 100 == 0 ) { mensaje . delete ( 0 , mensaje . length ( ) ) ; mensaje . append ( t ) . append ( "#iteration" ) ; out . mostrarporpantalla ( mensaje . tostring ( ) ) ; } for ( int k = 0 ; k < m ; k ++ ) { construirtour ( ) ; } for ( int i = 0 ; i < numerodeciudades ; i ++ ) { feromonas [ mejorrecorrido [ i ] ] [ mejorrecorrido [ i + 1 ] ] = feromonas [ mejorrecorrido [ i + 1 ] ] [ mejorrecorrido [ i ] ] = ( 1 - gamma ) * feromonas [ mejorrecorrido [ i ] ] [ mejorrecorrido [ i + 1 ] ] + gamma * ( q / mejorlongitudderecorrido ) ; } } }
tr	2	public static void main ( string [ ] args ) throws ioexception { if ( args . length == 3 ) { string option = args [ 0 ] ; file src = new file ( args [ 1 ] ) , dest = new file ( args [ 2 ] ) ; if ( option . equals ( "d" ) ) { system . out . println ( "[d\xe9compression...]" ) ; huffman . decompression ( new fileinputstream ( src ) , dest ) ; return ; } else if ( option . equals ( "c" ) ) { system . out . println ( "[compression...]" ) ; huffman . compression ( src , new fileoutputstream ( dest ) ) ; return ; } } system . out . println ( "usage : [c|d] fichier.src fichier.dest" ) ; }
tr	7	public boolean isvalidmsgfommat ( map < string , string > record ) { int typeint = 0 ; if ( unsutil . isnullorempty ( record . get ( "type" ) ) ) { logger . log ( level . info , "type is null or empty" ) ; return false ; } try { typeint = integer . valueof ( record . get ( "type" ) ) ; } catch ( numberformatexception e ) { logger . log ( level . info , "it's not a integer" ) ; return false ; } if ( typeint < 1 || typeint > 7 ) { logger . log ( level . info , "undefined type is detected" ) ; return false ; } ; boolean ismailactived = ( integer . valueof ( integer . tohexstring ( typeint ) ) & integer . valueof ( integer . tohexstring ( 1 ) ) ) > 0 ? true : false ; for ( string prop : getprops ( ) ) { if ( ! record . containskey ( prop ) ) { if ( ! ismailactived && "subject" . equals ( prop ) ) { continue ; } else { logger . log ( level . info , "property: {0} is not exist" , prop ) ; return false ; } } } if ( unsutil . isnullorempty ( record . get ( "sys" ) ) || unsutil . isnullorempty ( record . get ( "key" ) ) ) { logger . log ( level . info , "syskey can't be null or empty" ) ; return false ; } return true ; }
tr	6	string encode ( final string name , final parameter [ ] parameters , final message . encodemode encodemode ) throws jsonexception { string encodedmessage = null ; if ( parameters != null && name != null ) { final jsonobject message = new jsonobject ( ) ; message . put ( name , ( ( arrayparameter ) parameters [ 0 ] ) . tojsonarray ( encodemode ) ) ; encodedmessage = message . tostring ( ) ; } if ( parameters != null && name == null ) { final jsonobject msg = new jsonobject ( ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { parameter param = parameters [ i ] ; if ( param instanceof arrayparameter ) { msg . put ( param . getname ( ) , ( ( arrayparameter ) param ) . tojsonarray ( encodemode ) ) ; } else { msg . put ( param . getname ( ) , param . getvalue ( ) ) ; } } encodedmessage = msg . tostring ( ) ; } return encodedmessage ; }
tr	7	@ override public int nextint ( ) { double d = random . nextdouble ( ) ; int idx = collections . binarysearch ( v , d ) ; if ( idx > 0 ) { ++ idx ; } else { idx = - ( idx + 1 ) ; } if ( idx >= v . size ( ) ) { idx = v . size ( ) - 1 ; } if ( idx == 0 ) { return k . get ( 0 ) ; } int ceiling = k . get ( idx ) ; int lower = k . get ( idx - 1 ) ; return ceiling - random . nextint ( ceiling - lower ) ; }
tr	8	public document createdocument ( final list < student > students ) { document doc = null ; try { final documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; dbf . setvalidating ( true ) ; final documentbuilder db = dbf . newdocumentbuilder ( ) ; doc = db . newdocument ( ) ; final element root = doc . createelement ( model . field_students ) ; for ( final student student : students ) { final element studentelement = doc . createelement ( model . field_student ) ; root . appendchild ( studentelement ) ; newelement ( doc , model . field_name , studentelement , student . getname ( ) ) ; newelement ( doc , model . field_group , studentelement , student . getgroup ( ) . tostring ( ) ) ; final list < exam > exams = student . getexams ( ) ; final element examselement = doc . createelement ( model . field_exams ) ; studentelement . appendchild ( examselement ) ; for ( final exam exam : exams ) { if ( ! exam . isempty ( ) ) { final element examelement = doc . createelement ( model . field_exam ) ; examselement . appendchild ( examelement ) ; newelement ( doc , model . field_name , examelement , exam . getname ( ) != null ? exam . getname ( ) : " " ) ; newelement ( doc , model . field_mark , examelement , exam . getmark ( ) != null ? exam . getmark ( ) . tostring ( ) : " " ) ; } } } doc . appendchild ( root ) ; } catch ( final exception e ) { xmlwriter . log . log ( level . severe , model . problem_parsing_the_file + e . getmessage ( ) , e ) ; } return doc ; }
tr	10	public static void main ( string [ ] args ) { hashtable < integer , integer > h = getallabundants ( ) ; arraylist < integer > a = getallabundantsarray ( ) ; int totalsum = 0 ; for ( int i = 24 ; i <= 28123 ; i ++ ) { outerloop : for ( int j : a ) { if ( h . get ( i - j ) != null && h . get ( i - j ) > 0 ) { break outerloop ; } system . out . println ( i ) ; totalsum = totalsum + i ; } } system . out . println ( totalsum ) ; }
tr	5	@ test public void testqueryvideo ( ) { solrquery query = new solrquery ( ) ; query . set ( "q" , "video" ) ; query . addfacetfield ( "cat" ) ; query . setfacetlimit ( 10 ) ; query . setfacetmincount ( 1 ) ; try { queryresponse response = server . query ( query ) ; solrdocumentlist docs = response . getresults ( ) ; for ( solrdocument doc : docs ) { logger . info ( "the doc name:{}" , doc . getfieldvalue ( "id" ) . tostring ( ) ) ; } logger . info ( "\\n================================" ) ; list < facetfield > fflist = response . getfacetfields ( ) ; if ( fflist != null ) { for ( facetfield ff : fflist ) { for ( count c : ff . getvalues ( ) ) { logger . info ( "{}-{}" , c . getname ( ) , c . getcount ( ) ) ; } } } logger . info ( "\\n================================" ) ; logger . info ( "eleased time: {}" , response . getelapsedtime ( ) ) ; } catch ( solrserverexception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
tr	10	public void render ( graphics2d _g2 ) { _g2 . setcolor ( color . white ) ; _g2 . fillrect ( ( int ) x , ( int ) y , 1 , 1 ) ; if ( twinkle == 0 && u . r . nextfloat ( ) < u . twinkle_prob ) { twinkle = 1 ; twinkle_size = 1 ; } else if ( twinkle > 0 ) { _g2 . fillrect ( ( int ) x + twinkle_size , ( int ) y , 1 , 1 ) ; _g2 . fillrect ( ( int ) x , ( int ) y + twinkle_size , 1 , 1 ) ; _g2 . fillrect ( ( int ) x - twinkle_size , ( int ) y , 1 , 1 ) ; _g2 . fillrect ( ( int ) x , ( int ) y - twinkle_size , 1 , 1 ) ; ++ twinkle ; if ( twinkle % u . twinkle_speed == 0 ) { ++ twinkle_size ; } if ( twinkle == u . twinkle_speed * 4 ) { twinkle = 0 ; } } }
tr	5	public static void main ( string [ ] arg ) { scanner sc = new scanner ( system . in ) ; int [ ] arr = { 13 , 15 , 7 , 3 , 11 , 21 , 25 , 23 , 9 , 5 , 17 } ; int pos = - 1 ; system . out . print ( "vilket heltal s\xf6ker du? " ) ; int t = sc . nextint ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( t == arr [ i ] ) { pos = i ; i = arr . length ; } } if ( pos == - 1 ) system . out . println ( "talet hittades inte!" ) ; else system . out . println ( "talet finns i element nummer " + pos ) ; }
tr	7	public void flatten ( treenode root ) { if ( root == null ) return ; stack < treenode > st = new stack < treenode > ( ) ; st . add ( root ) ; treenode dummy = new treenode ( - 1 ) ; treenode curr = dummy ; while ( ! st . isempty ( ) ) { treenode t = st . pop ( ) ; curr . right = t ; curr . left = null ; curr = t ; if ( t . right != null ) st . add ( t . right ) ; if ( t . left != null ) st . add ( t . left ) ; } }
tr	5	public void run ( ) { try { system . out . println ( "in here run()" ) ; for ( int i = 0 ; i < executiontime ; i ++ ) { system . out . println ( "execution time:" + i ) ; int randomnum = 1000 + ( int ) ( math . random ( ) * 3000 ) ; thread . sleep ( randomnum ) ; entercs ( ) ; } while ( true ) { } } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } }
tr	5	public static hashtable < string , compiledstat > compilestats ( vector < stat > stats , collection < team > teams ) { vector < team > teamvector = new vector < team > ( teams ) ; hashtable < string , compiledstat > compiledstats = new hashtable < string , compiledstat > ( ) ; for ( stat stat : stats ) { double [ ] values = new double [ teams . size ( ) ] ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { team team = teamvector . get ( i ) ; values [ i ] = team . getstat ( stat . name ) ; } compiledstats . put ( stat . name , new compiledstat ( stat . name , values ) ) ; } return compiledstats ; }
tr	4	private static arraylist < string > generatelist ( ) { arraylist < string > temp = new arraylist < string > ( ) ; temp . add ( "pc1:\\n       bin: " + pc1 + "\\n       hex: " + binarytohex ( pc1 ) + "\\n\\n" ) ; temp . add ( "c0:\\n       bin: " + c0 + "\\n       hex: " + binarytohex ( c0 ) + "\\n\\n" ) ; temp . add ( "d0:\\n       bin: " + d0 + "\\n       hex: " + binarytohex ( d0 ) + "\\n\\n" ) ; temp . add ( "c1:\\n       bin: " + c1 + "\\n       hex: " + binarytohex ( c1 ) + "\\n\\n" ) ; temp . add ( "d1:\\n       bin: " + d1 + "\\n       hex: " + binarytohex ( d1 ) + "\\n\\n" ) ; temp . add ( "key(pc2):\\n       bin: " + keybin + "\\n       hex: " + binarytohex ( keybin ) + "\\n\\n" ) ; temp . add ( "l0:\\n       bin: " + l0 + "\\n       hex: " + binarytohex ( l0 ) + "\\n\\n" ) ; temp . add ( "r0:\\n       bin: " + r0 + "\\n       hex: " + binarytohex ( r0 ) + "\\n\\n" ) ; temp . add ( "e[r0]:\\n       bin: " + er0 + "\\n       hex: " + binarytohex ( er0 ) + "\\n\\n" ) ; temp . add ( "e[r0] xor key (a):\\n       bin: " + erxork + "\\n       hex: " + binarytohex ( erxork ) + "\\n\\n" ) ; temp . add ( "s-box output (b):\\n       bin: " + b + "\\n       hex: " + binarytohex ( b ) + "\\n\\n" ) ; temp . add ( "p(b):\\n       bin: " + pb + "\\n       hex: " + binarytohex ( pb ) + "\\n\\n" ) ; temp . add ( "p(b) xor l0 (r1):\\n       bin: " + messagebin + "\\n       hex: " + binarytohex ( messagebin ) + "\\n\\n" ) ; return temp ; }
tr	7	protected boolean signpackage ( ) throws mojoexecutionexception { getlog ( ) . info ( "signing package..." ) ; getlog ( ) . info ( "certificate: " + getkeystorage ( ) ) ; signerargumentsbuilder argumentsbuilder = new signerargumentsbuilder ( getcertificate ( ) . getfile ( ) , getcertificate ( ) . getpassword ( ) , getkeystorage ( ) . getfile ( ) , getbarpackage ( ) . getbarfile ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > signercallable = new callable < void > ( ) { @ override public void call ( ) throws exception { barsigner . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean signingsuccessful = executor . execute ( signercallable ) == 0 ; getlog ( ) . info ( signingsuccessful ? "package signed successfully." : "package signing failed." ) ; return signingsuccessful ; }
tr	9	public boolean isnumber ( string s ) { if ( s . trim ( ) == "" ) return false ; s = s . trim ( ) ; if ( s . startswith ( "-" ) || s . startswith ( "+" ) ) s = s . substring ( 1 ) ; if ( s . length ( ) == 0 ) return false ; int point = - 1 ; int science = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charat ( i ) > '9' || s . charat ( i ) < '0' ) && s . charat ( i ) != 'e' && s . charat ( i ) != '.' && s . charat ( i ) != '+' && s . charat ( i ) != '-' ) return false ; if ( ( s . charat ( i ) == '+' || s . charat ( i ) == '-' ) && ( i == 0 || s . charat ( i - 1 ) != 'e' || i == s . length ( ) - 1 ) ) return false ; if ( s . charat ( i ) == '.' ) { if ( point != - 1 ) return false ; point = i ; } if ( s . charat ( i ) == 'e' ) { if ( science != - 1 ) return false ; science = i ; } } if ( point == 0 && s . length ( ) == 1 ) { return false ; } if ( science == 0 || science == s . length ( ) - 1 ) { return false ; } if ( point > science && science != - 1 ) { return false ; } else if ( point == 0 && science == 1 ) { return false ; } return true ; }
tr	4	private string wiregetprop ( ixwire wire , ixsignal sig ) { string retval = null ; for ( ixabstractpin pin : wire . getabstractpins ( ) ) { string val = pingetprop ( pin , sig ) ; retval = determineresult ( retval , val ) ; } if ( retval == null || retval . trim ( ) . isempty ( ) ) { for ( ixabstractconductor cond : sig . getfunctionalconductors ( ) ) { string val = cond . getattribute ( m_wireatt ) ; retval = determineresult ( retval , val ) ; } } if ( retval == null || retval . trim ( ) . isempty ( ) ) { return null ; } return retval ; }
tr	10	@ override public void draw ( graphics g ) { if ( isleft && ! isright ) { g . drawimage ( playerimage [ 8 ] , x , y , null ) ; } else if ( isright && ! isleft ) { g . drawimage ( playerimage [ 9 ] , x , y , null ) ; } else { g . drawimage ( playerimage [ imgcnt ] , x , y , null ) ; count ++ ; if ( count >= maxcount ) { imgcnt = ( imgcnt + 1 ) % 8 ; count = 0 ; } } for ( int i = 0 ; i < hp ; i ++ ) { g . drawimage ( hpimage , i * hpimage . getwidth ( null ) + 10 , gameframe . height - hpimage . getheight ( null ) - 10 , null ) ; } }
tr	1	public void modification ( char symbole ) { element q = feuilles [ symbole ] ; element diese = feuilles [ '#' ] ; if ( q == null ) { feuille f = new feuille ( symbole ) ; noeud nouveaunoeud = new noeud ( diese , f ) ; f . setpere ( nouveaunoeud ) ; feuilles [ symbole ] = f ; if ( this . racine == diese ) { diese . setpere ( nouveaunoeud ) ; this . racine = nouveaunoeud ; } else { noeud tmp = diese . getpere ( ) ; tmp . setfilsgauche ( nouveaunoeud ) ; nouveaunoeud . setpere ( tmp ) ; diese . setpere ( nouveaunoeud ) ; nouveaunoeud . setsuiv ( diese . getsuiv ( ) ) ; q = tmp ; } diese . setsuiv ( f ) ; f . setsuiv ( nouveaunoeud ) ; } else { if ( q . getpere ( ) == diese . getpere ( ) && q . getpere ( ) == finbloc ( q ) ) { q = q . getpere ( ) ; } } traitement ( q ) ; }
tr	9	protected double computecomponentdensity ( int i , double x ) { if ( 0 <= i && i < k ) { if ( w [ i ] > 0.0 ) { double z = ( x - m [ i ] ) / v [ i ] ; z *= z ; double ret = w [ i ] * abstractgmm . one_per_sqrt2pi * ( 1.0 / v [ i ] ) * math . exp ( - 0.5 * z ) ; return ret ; } else { return 0.0 ; } } return double . nan ; }
tr	5	public double distanceto ( record o ) { double d2r = ( math . pi / 180 ) ; double distance = 0 ; double longie = o . longitude ; double latie = o . latitude ; try { double dlong = ( longie - longitude ) * d2r ; double dlati = ( latie - latitude ) * d2r ; double a = math . pow ( math . sin ( dlati / 2.0 ) , 2 ) + math . cos ( latitude * d2r ) * math . cos ( latie * d2r ) * math . pow ( math . sin ( dlong / 2.0 ) , 2 ) ; double c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) ; distance = 6367 * c ; } catch ( exception e ) { e . printstacktrace ( ) ; } return distance ; }
tr	2	@ override public void tick ( state gamestate ) { this . force [ 0 ] = lock ( this . force [ 0 ] , - 20 , 20 ) ; this . force [ 1 ] = lock ( this . force [ 1 ] , - 50 , 50 ) ; if ( this . force [ 0 ] > 0 ) { this . x += this . force [ 0 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { int borderinset = ( int ) ( int ) this . getbounds ( ) . getminx ( ) - x ; this . x = ( int ) xblocker . getbounds ( ) . getminx ( ) - ( int ) this . getbounds ( ) . getwidth ( ) - borderinset ; } } else if ( this . force [ 0 ] < 0 ) { this . x += this . force [ 0 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { int borderinset = ( int ) this . getbounds ( ) . getminx ( ) - x ; this . x = ( int ) xblocker . getbounds ( ) . getmaxx ( ) - borderinset ; } } if ( this . force [ 1 ] > 0 ) { this . y += this . force [ 1 ] ; if ( gamestate . blockingentity ( this ) != null ) { this . y -= this . force [ 1 ] ; } } else if ( this . force [ 1 ] < 0 ) { this . y += this . force [ 1 ] ; entity xblocker = gamestate . blockingentity ( this ) ; if ( xblocker != null ) { this . y = ( int ) xblocker . getbounds ( ) . getmaxy ( ) ; } if ( gamestate . blockingentity ( this ) != null ) { this . y -= this . force [ 1 ] ; } } force [ 0 ] = closer ( force [ 0 ] , 0 , 2 ) ; force [ 1 ] = closer ( force [ 1 ] , - 40 , 2 ) ; if ( this . y <= 0 ) { this . y = 0 ; } }
tr	5	private void printmostdistinctmessages ( group group , string thememessage ) { if ( group == null || group . isempty ( ) || thememessage == null || thememessage . isempty ( ) ) { return ; } iterator < post > iterator = group . iterator ( ) ; while ( iterator . hasnext ( ) ) { post post = iterator . next ( ) ; double difference = dictionary . getinstance ( ) . compare ( post . getmessage ( ) , thememessage ) ; if ( difference > 0.95 ) { println ( string . format ( "%.2f\\t%s" , difference , post . getmessage ( ) ) ) ; } } println ( spacer ) ; }
tr	2	private void resetvariables ( ) { allcollidablesurfaces . clear ( ) ; portalablesurfaces . clear ( ) ; nonportalablesurfaces . clear ( ) ; loadnextlevel = false ; playerx = 100.0 ; playery = 500.0 ; boxx = - 200.0 ; boxy = - 50.0 ; buttonx = 0.0 ; buttony = - 200 ; entrancedoorx = - 100 ; entrancedoory = - 100 ; exitdoorx = - 100 ; exitdoory = - 100 ; portalwidth = 20.0 ; portalheight = 40.0 ; mousex = 0.0 ; mousey = 0.0 ; heldboxx = 20.0 ; portal1 . setframe ( 0 , - 50 , portalwidth , portalheight ) ; portal2 . setframe ( 100 , - 50 , portalwidth , portalheight ) ; panel1 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel2 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel3 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel4 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel5 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel6 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel7 . setframe ( - 100 , - 100 , 50 , 50 ) ; panel8 . setframe ( - 100 , - 100 , 50 , 50 ) ; button . setframe ( buttonx , buttony , 25 , 25 ) ; box . setframe ( boxx , boxy , 25 , 25 ) ; entrancedoor . setframe ( entrancedoorx , entrancedoory , 29 , 60 ) ; exitdoor . setframe ( exitdoorx , exitdoory , 29 , 60 ) ; playerpos . set ( 100 , 617 ) ; playervel . set ( 0.0 , 0.0 ) ; playeracc . set ( 0.0 , 0.0 ) ; boxpos . set ( boxx , boxy ) ; boxvel . set ( 0.0 , 0.0 ) ; boxacc . set ( 0.0 , 0.0 ) ; portalrelativelocation = 0 ; portal1relativelocation = 0 ; portal2relativelocation = 0 ; apressed = false ; dpressed = false ; onground = false ; playeronground = false ; jumping = false ; playerjustportaled = false ; boxjustportaled = false ; lastshotblueportal = true ; raylineintersection = false ; portalsactive = false ; portal1active = false ; portal2active = false ; portalableintersection = false ; portalcollisionissue = false ; raylinecolorisblue = false ; playermovementissue = false ; boxheld = false ; boxtoggle = true ; buttonintersection = false ; playerfacingright = true ; levelresetrequired = false ; gameover = false ; }
tr	3	public void provjeriunos ( ) { console c = system . console ( ) ; if ( c == null ) { system . exit ( 1 ) ; } v . ispisiupute ( ) ; petlja = true ; while ( petlja ) { input = c . readline ( ) ; string split [ ] = input . split ( " " ) ; switch ( split [ 0 ] ) { case "-i" : v . ispispoveznica ( ) ; break ; case "-j" : v . novastranica ( split [ 1 ] ) ; petlja = false ; break ; case "-s" : v . ispisistatistiku ( ) ; break ; case "-e" : v . brisinazahtjev ( ) ; break ; case "-q" : v . izadi ( ) ; break ; } } }
tr	4	public stringbuilder dohvatisadrzajdatoteke ( string naziv ) { stringbuilder sadrzaj = new stringbuilder ( ) ; try { string outputline ; file file = new file ( nazivspremista + "\\\\" + naziv ) ; if ( ! file . exists ( ) ) { setchanged ( ) ; notifyobservers ( "datoteka izbrisna<litcomma> citam sa stranice!" ) ; return null ; } filereader fr = new filereader ( file ) ; bufferedreader br = new bufferedreader ( fr ) ; while ( ( outputline = br . readline ( ) ) != null ) { sadrzaj . append ( outputline ) ; sadrzaj . append ( "\\n" ) ; } br . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cacheimpl . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return sadrzaj ; }
tr	5	public void displaygrid ( ) { system . out . println ( "grid name :" + getname ( ) ) ; for ( int row = 0 ; row < rows ; row ++ ) { stringbuilder gridbulder = new stringbuilder ( ) ; for ( int col = 0 ; col < columns ; col ++ ) { treasurechest chest = treasurechest [ row ] [ col ] ; if ( chest == null ) { gridbulder . append ( "_ " ) ; } else { gridbulder . append ( "x " ) ; } } system . out . println ( gridbulder . tostring ( ) ) ; } }
tr	2	@ test public void testdrawstring ( ) { asserttrue ( closer ( 10 , 5 , 1 ) == 9 ) ; asserttrue ( closer ( 10 , 5 , 2 ) == 8 ) ; asserttrue ( closer ( - 10 , 5 , 1 ) == - 9 ) ; asserttrue ( closer ( - 10 , 5 , 2 ) == - 8 ) ; asserttrue ( closer ( 1 , 2 , 5 ) == 2 ) ; asserttrue ( closer ( - 1 , 1 , 1 ) == 0 ) ; asserttrue ( closer ( 0 , 0 , 1 ) == 0 ) ; }
tr	4	@ override public void settorandomvalue ( final randomgenerator a_numbergenerator ) { final intlist sortedsubset = new intarraylist ( ) ; final gene [ ] m_genes = getgenes ( ) ; for ( int i = 0 ; i < m_genes . length ; i ++ ) { int value = - 1 ; do { m_genes [ i ] . settorandomvalue ( a_numbergenerator ) ; value = ( integer ) m_genes [ i ] . getallele ( ) ; } while ( sortedsubset . contains ( value ) ) ; sortedsubset . add ( value ) ; } collections . sort ( sortedsubset ) ; for ( int i = 0 ; i < m_genes . length ; i ++ ) { m_genes [ i ] . setallele ( sortedsubset . get ( i ) ) ; } if ( ! isvalid ( ) ) { throw new internalerror ( "supergene content must be compatible with valid method" ) ; } }
tr	3	public void validar ( actionevent event ) { if ( event . getcomponent ( ) . getid ( ) . equals ( "validarid" ) ) { try { facescontext context = facescontext . getcurrentinstance ( ) ; httpservletresponse response = ( httpservletresponse ) context . getexternalcontext ( ) . getresponse ( ) ; usuario us = new usuario ( ) ; usuariodao dao = new usuariodao ( ) ; us . setusuario ( this . user ) ; us . setpassword ( this . password ) ; if ( ( ! this . user . isempty ( ) ) || ( ! this . user . equals ( "" ) ) ) { if ( ( ! this . password . isempty ( ) ) || ( ! this . password . equals ( "" ) ) ) { if ( dao . validarusuario ( us ) ) { arraylist inmuebles = new arraylist ( ) ; inmueblesdao inmuebledao = new inmueblesdao ( ) ; inmuebles = inmuebledao . consultarinmueble ( id ) ; id = us . getid ( ) ; response . sendredirect ( "/webproject/faces/welcome.xhtml" ) ; } else { response . sendredirect ( "/webproject/faces/login.xhtml" ) ; this . setrender ( true ) ; this . setmensaje ( "usuario o password invalidos" ) ; } } else { response . sendredirect ( "/webproject/faces/login.xhtml" ) ; this . setrender ( true ) ; this . setmensaje ( "password no debe ser vacio" ) ; } } else { response . sendredirect ( "/webproject/faces/login.xhtml" ) ; this . setrender ( true ) ; this . setmensaje ( "usuario no debe ser vacio" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	3	void onreceiveresult ( status status , resultmessage r ) { if ( r . result . type . equals ( "trick_won" ) ) { if ( r . result . by == r . your_player_num ) wintime ++ ; else losetime ++ ; theirlastcard = r . result . card ; totaltime ++ ; } if ( r . result . type . equals ( "trick_tied" ) ) { tiedtime ++ ; theirlastcard = mylastcard ; totaltime ++ ; } if ( r . result . type . equals ( "hand_done" ) ) { wintime = 0 ; losetime = 0 ; totaltime = 0 ; tiedtime = 0 ; mylastcard = - 1 ; theirlastcard = - 1 ; } }
tr	10	public void solve ( char [ ] [ ] board ) { if ( board . length == 0 || board [ 0 ] . length == 0 ) return ; int length = board . length ; int width = board [ 0 ] . length ; arraylist < integer > iindexes = new arraylist < integer > ( ) ; arraylist < integer > jindexes = new arraylist < integer > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { if ( board [ i ] [ j ] == 'o' && ( i == 0 || i == length - 1 || j == 0 || j == width - 1 ) ) { iindexes . add ( i ) ; jindexes . add ( j ) ; } else continue ; } } while ( ! iindexes . isempty ( ) ) { int x = iindexes . get ( 0 ) ; int y = jindexes . get ( 0 ) ; iindexes . remove ( 0 ) ; jindexes . remove ( 0 ) ; board [ x ] [ y ] = 'p' ; if ( x > 0 && board [ x - 1 ] [ y ] == 'o' ) { iindexes . add ( x - 1 ) ; jindexes . add ( y ) ; } if ( x < length - 1 && board [ x + 1 ] [ y ] == 'o' ) { iindexes . add ( x + 1 ) ; jindexes . add ( y ) ; } if ( y > 0 && board [ x ] [ y - 1 ] == 'o' ) { iindexes . add ( x ) ; jindexes . add ( y - 1 ) ; } if ( y < width - 1 && board [ x ] [ y + 1 ] == 'o' ) { iindexes . add ( x ) ; jindexes . add ( y + 1 ) ; } } for ( int i = 0 ; i < length ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { if ( board [ i ] [ j ] == 'o' || board [ i ] [ j ] == 'o' ) board [ i ] [ j ] = 'x' ; if ( board [ i ] [ j ] == 'p' ) board [ i ] [ j ] = 'o' ; } } }
tr	3	public void upload ( string directory , string uploadfile , channelsftp sftp ) { try { sftp . cd ( directory ) ; file file = new file ( uploadfile ) ; fileinputstream fis = new fileinputstream ( file ) ; system . out . println ( "\u6587\u4ef6size:" + string . valueof ( fis . available ( ) / 1000 ) + "k" ) ; sftp . put ( new fileinputstream ( file ) , file . getname ( ) , new fileprogressmonitor ( fis . available ( ) ) , channelsftp . overwrite ) ; } catch ( sftpexception sftpexception ) { sftpexception . printstacktrace ( ) ; return ; } catch ( exception e ) { e . printstacktrace ( ) ; return ; } }
tr	9	public void newgame ( ) { clear ( ) ; for ( int n = 1 ; n <= u . nenemies ; ++ n ) { int rx = 0 , ry = 0 ; while ( rx < 200 && rx > - 200 ) { rx = ( int ) ( u . r . nextfloat ( ) * ( u . world_x_pixels - 10 ) - u . world_x_pixels2 ) ; } while ( ry < 200 && ry > - 200 ) { ry = ( int ) ( u . r . nextfloat ( ) * ( u . world_y_pixels - 10 - u . ui ) - u . world_y_pixels2 + u . ui ) ; } final rectangle r = new rectangle ( rx , ry , 7 + u . r . nextint ( 5 ) - 2 , ( float ) ( ( 1f / ( float ) u . nenemies ) * n ) ) ; synchronized ( u . list_of_rectangles_sync ) { u . list_of_rectangles_sync . add ( r ) ; } } u . player = new playership ( 0 - u . world_x_pixels2 , 0 - u . world_y_pixels2 ) ; u . level = 1 ; u . lives = u . maxlives ; u . setc ( 1f ) ; u . setv ( 0.5f ) ; b . playingscore . setvalue ( 0 ) ; u . show_all_locations = false ; u . show_light_cones = false ; }
tr	1	public gamestatus getstatus ( ) { gamestatus r = gamestatus . continue ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( board . getboard ( ) [ 0 ] [ i ] != null ) { if ( board . getboard ( ) [ 0 ] [ i ] . getpiece ( ) == pieceenum . pawn ) { r = gamestatus . whitewins ; break ; } } if ( board . getboard ( ) [ 5 ] [ i ] != null ) { if ( board . getboard ( ) [ 5 ] [ i ] . getpiece ( ) == pieceenum . pawn ) { r = gamestatus . blackwins ; break ; } } } int numdeadblackpawns = 0 ; int numdeadwhitepawns = 0 ; for ( int i = 0 ; i < board . getgraveyard ( ) . size ( ) ; i ++ ) { if ( board . getgraveyard ( ) . get ( i ) . getcolor ( ) == colorenum . black && board . getgraveyard ( ) . get ( i ) . getpiece ( ) == pieceenum . pawn ) { numdeadblackpawns ++ ; } else { if ( board . getgraveyard ( ) . get ( i ) . getcolor ( ) == colorenum . white && board . getgraveyard ( ) . get ( i ) . getpiece ( ) == pieceenum . pawn ) { numdeadwhitepawns ++ ; } } } if ( numdeadwhitepawns == 6 && numdeadblackpawns == 6 ) { r = gamestatus . draw ; } int numdeadblackpieces = 0 ; int numdeadwhitepieces = 0 ; for ( int i = 0 ; i < board . getgraveyard ( ) . size ( ) ; i ++ ) { if ( board . getgraveyard ( ) . get ( i ) . getcolor ( ) == colorenum . black ) { numdeadblackpieces ++ ; } else { if ( board . getgraveyard ( ) . get ( i ) . getcolor ( ) == colorenum . white ) { numdeadwhitepieces ++ ; } } } if ( numdeadwhitepieces == 8 ) { r = gamestatus . blackwins ; } else { if ( numdeadblackpieces == 8 ) { r = gamestatus . whitewins ; } } return r ; }
tr	6	private boolean delete ( commandsender sender , string [ ] args ) { if ( ban != null ) { sender . sendmessage ( chatcolor . red + "finish what you're doing first!" ) ; return true ; } if ( args . length < 2 ) { sender . sendmessage ( chatcolor . red + "usage: delete [id]" ) ; return true ; } int id ; try { id = integer . parseint ( args [ 1 ] ) ; } catch ( numberformatexception exc ) { sender . sendmessage ( chatcolor . red + "id has to be a number!" ) ; return true ; } for ( int i = 0 ; i < plugin . bannedplayers . size ( ) ; i ++ ) { if ( plugin . bannedplayers . get ( i ) . id == id ) { plugin . bannedplayers . remove ( i ) ; break ; } } boolean success = plugin . db . deletefullrecord ( id ) ; if ( success ) sender . sendmessage ( chatcolor . green + "deleted record " + id ) ; else sender . sendmessage ( chatcolor . red + "can't find record " + id ) ; return success ; }
tr	9	public final static arraylist < string > search_buildcache ( string dir , int depth , arraylist < string > v ) { thread . yield ( ) ; if ( v == null ) v = new arraylist < string > ( 100 ) ; if ( depth < 0 ) return v ; file f , d ; f = new file ( dir ) ; string filez [ ] = f . list ( ) ; if ( filez == null ) return v ; if ( filez . length == 0 ) return v ; int rl = mgr . cache_dir . length ( ) ; string burl ; for ( int z = filez . length - 1 ; z >= 0 ; z -- ) { d = new file ( f , filez [ z ] ) ; if ( ! d . isdirectory ( ) ) continue ; burl = dir + file . separatorchar + filez [ z ] ; v . add ( burl . substring ( rl ) ) ; search_buildcache ( burl , depth - 1 , v ) ; } return v ; }
tr	6	private void sendpacket ( byte id , object ... data ) throws ioexception { bytearrayoutputstream bo = new bytearrayoutputstream ( ) ; dataoutputstream out = new dataoutputstream ( bo ) ; out . write ( id ) ; for ( object o : data ) { if ( o == null ) throw new ioexception ( "object is null" ) ; if ( o instanceof string ) utils . writestring ( ( string ) o , out ) ; else if ( o instanceof byte ) out . writelong ( ( byte ) o ) ; else if ( o instanceof short ) out . writeshort ( ( short ) o ) ; else if ( o instanceof integer ) out . writeint ( ( integer ) o ) ; else if ( o instanceof long ) out . writelong ( ( long ) o ) ; else if ( o instanceof float ) out . writefloat ( ( float ) o ) ; else if ( o instanceof double ) out . writedouble ( ( double ) o ) ; else if ( o instanceof character ) out . writechar ( ( character ) o ) ; else if ( o instanceof byte [ ] ) out . write ( ( byte [ ] ) o ) ; else throw new ioexception ( "invalid type " + o . getclass ( ) . getname ( ) ) ; } packetpayload p = new packetpayload ( ip , port ) ; p . construct ( count ++ , bo . tobytearray ( ) ) ; p . send ( ) ; }
tr	7	public static list < computeserver > buildcomputeserver ( int [ ] ram , int [ ] cpu , int [ ] cost , int [ ] reliability ) { if ( ram . length != cpu . length || ram . length != cost . length || cpu . length != cost . length ) { throw new illegalargumentexception ( "ram array<litcomma> cost array and cpu array should have the same length" ) ; } list < computeserver > servers = new arraylist < > ( ram . length ) ; for ( int i = 0 ; i < ram . length ; i ++ ) { servers . add ( new computeserver ( "server " + i , ram [ i ] , cpu [ i ] , cost [ i ] , reliability [ i ] ) ) ; } return servers ; }
tr	7	public void compact ( boolean exhaustive ) { if ( ! iscompact ) { int limitcompacted = 0 ; int iblockstart = 0 ; char iuntouched = 0xffff ; for ( int i = 0 ; i < indices . length ; ++ i , iblockstart += blockcount ) { indices [ i ] = 0xffff ; boolean touched = blocktouched ( i ) ; if ( ! touched && iuntouched != 0xffff ) { indices [ i ] = iuntouched ; } else { int jblockstart = 0 ; int j = 0 ; for ( j = 0 ; j < limitcompacted ; ++ j , jblockstart += blockcount ) { if ( hashes [ i ] == hashes [ j ] && arrayregionmatches ( values , iblockstart , values , jblockstart , blockcount ) ) { indices [ i ] = ( char ) jblockstart ; break ; } } if ( indices [ i ] == 0xffff ) { system . arraycopy ( values , iblockstart , values , jblockstart , blockcount ) ; indices [ i ] = ( char ) jblockstart ; hashes [ j ] = hashes [ i ] ; ++ limitcompacted ; if ( ! touched ) { iuntouched = ( char ) jblockstart ; } } } } int newsize = limitcompacted * blockcount ; byte [ ] result = new byte [ newsize ] ; system . arraycopy ( values , 0 , result , 0 , newsize ) ; values = result ; iscompact = true ; hashes = null ; } }
tr	10	private void executajogada ( ) throws filenotfoundexception , ioexception , classnotfoundexception { string move = leitor . nextline ( ) ; if ( move . comparetoignorecase ( "save" ) == 0 ) { fileoutputstream fos = new fileoutputstream ( "default.xdz" ) ; objectoutputstream oos = new objectoutputstream ( fos ) ; oos . writeobject ( new checkpoint ( this . pecas , brancas ) ) ; oos . close ( ) ; mensagem = "jogo salvo! digite \\'load\\' para carregar" ; } else if ( move . comparetoignorecase ( "load" ) == 0 ) { try { fileinputstream fis = new fileinputstream ( "default.xdz" ) ; objectinputstream ois = new objectinputstream ( fis ) ; checkpoint checkpoint = ( checkpoint ) ois . readobject ( ) ; arraylist < peca > pecassalvas = checkpoint . getpecas ( ) ; brancas = checkpoint . isbrancas ( ) ; ois . close ( ) ; this . tabuleiro = new tabuleiro ( pecassalvas ) ; this . pecas = pecassalvas ; mensagem = "jogo recarregado" ; } catch ( exception e ) { mensagem = "arquivo n\xe3o existe." ; } } else if ( move . comparetoignorecase ( "undo" ) == 0 && jogadas . size ( ) > 0 && ! this . lastwasundo ) { int index = jogadas . size ( ) - 1 ; tabuleiro . desfazerjogada ( jogadas . get ( index ) ) ; jogadas . remove ( index ) ; brancas = ! brancas ; mensagem = "jogada desfeita." ; this . lastwasundo = true ; } else if ( parsemovimentostring ( move , false ) != null ) { posicao [ ] movimento = parsemovimentostring ( move , false ) ; peca pecamovida = tabuleiro . getcasa ( movimento [ 0 ] ) ; peca pecacapturada = tabuleiro . getcasa ( movimento [ 1 ] ) ; movimento movmsg = tabuleiro . mover ( movimento [ 0 ] , movimento [ 1 ] , brancas ) ; if ( movmsg . getvalidado ( ) ) { jogada jogada = new jogada ( pecamovida , pecacapturada , movimento [ 0 ] , movimento [ 1 ] ) ; jogadas . add ( jogada ) ; this . lastwasundo = false ; } brancas = movmsg . getvalidado ( ) ? ! brancas : brancas ; mensagem = movmsg . getmensagem ( ) ; this . finalizado = movmsg . fim ; } else { mensagem = "movimento invalido<litcomma> exemplo correto: b1b5" ; } }
tr	6	protected list < string > getassociations_ ( list < string > tokens ) { list < string > res = new arraylist < > ( ) ; if ( 1 == tokens . size ( ) ) { res . add ( tokens . get ( 0 ) ) ; } else { for ( int i = 0 ; i < tokens . size ( ) ; ++ i ) { list < string > left = tokens . sublist ( 0 , i ) , right = tokens . sublist ( i , tokens . size ( ) ) ; for ( string l : getassociations_ ( left ) ) { for ( string r : getassociations_ ( right ) ) { res . add ( "(" . concat ( l ) . concat ( " %s " ) . concat ( r ) . concat ( ")" ) ) ; } } } } return res ; }
tr	1	private method getpolymorphicmethod ( cheese cheese ) throws exception { class cl = cheese . getclass ( ) ; while ( ! cl . equals ( object . class ) ) { try { return this . getclass ( ) . getdeclaredmethod ( "visit" , new class [ ] { cl } ) ; } catch ( nosuchmethodexception ex ) { cl = cl . getsuperclass ( ) ; } } class [ ] interfaces = cheese . getclass ( ) . getinterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { try { return this . getclass ( ) . getdeclaredmethod ( "visit" , new class [ ] { interfaces [ i ] } ) ; } catch ( nosuchmethodexception ex ) { } } return null ; }
tr	1	public static string decompression ( inputstream in ) throws ioexception { stringbuilder str = new stringbuilder ( ) ; arbrehuffman arbre = new arbrehuffman ( ) ; int longueurdutexte = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { longueurdutexte += ( in . read ( ) << ( 24 - i * 8 ) ) ; } if ( longueurdutexte == 0 ) return "" ; byte b = ( byte ) in . read ( ) ; str . append ( ( char ) b ) ; arbre . modification ( ( char ) b ) ; linkedlist < boolean > buffer = new linkedlist < boolean > ( ) ; int i = 1 ; while ( i < longueurdutexte ) { while ( ! arbre . estchemincomplet ( buffer ) ) { buffer . addall ( gestionnairebit . bytetobooleanlist ( ( byte ) in . read ( ) ) ) ; } char symbole = arbre . recupererfeuille ( buffer ) ; if ( symbole == '#' ) { if ( buffer . size ( ) < 8 ) { buffer . addall ( gestionnairebit . bytetobooleanlist ( ( byte ) in . read ( ) ) ) ; } symbole = gestionnairebit . booleanlisttochar ( buffer ) ; } str . append ( symbole ) ; arbre . modification ( symbole ) ; i ++ ; } system . out . println ( "[debug] arbre final decompression : \\n" + arbre ) ; system . out . println ( "[debug] nombre de caracteres lu : " + i ) ; return str . tostring ( ) ; }
tr	5	@ override public optional < e > get ( int target ) { if ( this . isempty ( ) ) { return optional . empty ( ) ; } int distance = index - target ; if ( distance == 0 ) { return optional . of ( head ) ; } else if ( distance < 0 ) { return optional . empty ( ) ; } else { int logdistance = calclog2 ( distance ) ; int jumpindex = min ( maxindex , logdistance ) ; return links [ jumpindex ] . get ( target ) ; } }
tr	9	void trainfrom ( string text ) { if ( text != null && ! text . isempty ( ) ) { char lasttoken ; int repeatcount ; string cleanedtext = text . touppercase ( locale . getdefault ( ) ) . replaceall ( "\\\\w" , "" ) ; if ( cleanedtext . length ( ) > this . maxsize ) { this . maxsize = cleanedtext . length ( ) ; } if ( cleanedtext . length ( ) < this . minsize ) { this . minsize = cleanedtext . length ( ) ; } recordlink ( initial_state , cleanedtext . charat ( 0 ) ) ; lasttoken = cleanedtext . charat ( 0 ) ; repeatcount = 1 ; for ( int i = 1 ; i < cleanedtext . length ( ) ; i ++ ) { recordlink ( cleanedtext . charat ( i - 1 ) , cleanedtext . charat ( i ) ) ; if ( cleanedtext . charat ( i ) == lasttoken ) { repeatcount ++ ; if ( repeatcount > this . maxrepeats ) { this . maxrepeats = repeatcount ; } } else { lasttoken = cleanedtext . charat ( i ) ; repeatcount = 1 ; } } recordlink ( cleanedtext . charat ( cleanedtext . length ( ) - 1 ) , final_state ) ; } }
tr	3	private attribute importance ( list < attribute > attributes , list < instance > examples ) { double winningentropy = double . negative_infinity ; attribute winningattribute = null ; double givencredit = 0 ; for ( instance example : examples ) { if ( "1" . equals ( example . label ) ) { givencredit ++ ; } } double creditentropy = booleanentropy ( givencredit / examples . size ( ) ) ; system . out . println ( "h(credit) = " + creditentropy ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { attribute attribute = attributes . get ( i ) ; map < string , double > attributescore = new linkedhashmap < string , double > ( attribute . values . size ( ) ) ; map < string , double > attributescoregivencredit = new linkedhashmap < string , double > ( attribute . values . size ( ) ) ; int exampleswithcredit = 0 ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { double midpoint = midpoint ( examples , attribute . index ) ; list < instance > examplesgivencredits = new arraylist < instance > ( ) ; for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; if ( "1" . equals ( example . label ) ) { examplesgivencredits . add ( example ) ; } } double midpointgivencredits = midpoint ( examplesgivencredits , attribute . index ) ; for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; int value = integer . parseint ( example . attributes . get ( i ) ) ; string larger = string . valueof ( value > midpoint ) ; double score = attributescore . get ( larger ) ; if ( score == null ) { score = 0.0 ; } attributescore . put ( larger , score + 1 ) ; if ( "1" . equals ( example . label ) ) { string largergivencredit = string . valueof ( value > midpointgivencredits ) ; double scoregivencredit = attributescoregivencredit . get ( largergivencredit ) ; if ( scoregivencredit == null ) { scoregivencredit = 0.0 ; } attributescoregivencredit . put ( largergivencredit , scoregivencredit + 1 ) ; exampleswithcredit ++ ; } } } else { for ( int j = 0 ; j < examples . size ( ) ; j ++ ) { instance example = examples . get ( j ) ; string value = example . attributes . get ( i ) ; double score = attributescore . get ( value ) ; if ( score == null ) { score = 0.0 ; } attributescore . put ( value , score + 1 ) ; if ( "1" . equals ( example . label ) ) { double scoregivencredit = attributescoregivencredit . get ( value ) ; if ( scoregivencredit == null ) { scoregivencredit = 0.0 ; } attributescoregivencredit . put ( value , scoregivencredit + 1 ) ; exampleswithcredit ++ ; } } } double attributeentropy = 0 ; for ( string value : attributescore . keyset ( ) ) { double score = attributescore . get ( value ) ; double scoregivencredit = attributescoregivencredit . get ( value ) ; if ( score != null && scoregivencredit != null && score != 0 && scoregivencredit != 0 ) { attributeentropy += ( score / examples . size ( ) * booleanentropy ( scoregivencredit / exampleswithcredit ) ) ; } } double totalentropy = creditentropy - attributeentropy ; system . out . println ( "i(credit;" + attribute . category . getname ( ) + ") = " + totalentropy ) ; if ( totalentropy >= winningentropy ) { winningentropy = totalentropy ; winningattribute = attribute ; } } return winningattribute ; }
tr	1	public void actionperformed ( actionevent e ) { string username = txtusername . gettext ( ) ; string ip = txtservip . gettext ( ) ; int port = 12345 ; try { port = integer . parseint ( txtservport . gettext ( ) ) ; } catch ( numberformatexception ex ) { ex . printstacktrace ( ) ; txtservport . settext ( "must be a number" ) ; } dispose ( ) ; final client client = new client ( username , ip , port ) ; client . openconnection ( ) ; swingutilities . invokelater ( new runnable ( ) { public void run ( ) { clientgui gui = new clientgui ( client ) ; gui . setvisible ( true ) ; gui . listen ( ) ; } } ) ; }
tr	2	public site findbestsite ( vector < site > freesites ) { iterator < site > i = freesites . iterator ( ) ; site bestsite = new site ( ) ; double gain = double . negative_infinity ; double newgain ; if ( i . hasnext ( ) ) { bestsite = i . next ( ) ; gain = bestsite . getfood ( ) - movecost * pythagoras ( this . xposition , bestsite . getxposition ( ) , this . yposition , bestsite . getyposition ( ) ) ; } while ( i . hasnext ( ) ) { site freesite = i . next ( ) ; newgain = freesite . getfood ( ) - movecost * pythagoras ( this . xposition , freesite . getxposition ( ) , this . yposition , freesite . getyposition ( ) ) ; if ( newgain > gain ) { bestsite = freesite ; gain = newgain ; } } return bestsite ; }
tr	7	@ override public readablemessagecatalog readfrom ( inputstream stream ) throws ioexception { stringbuilder buf = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( stream , utf8 ) ) ; int ch ; while ( ( ch = reader . read ( ) ) != - 1 ) { buf . append ( ( char ) ch ) ; } reader . close ( ) ; final list < messagefragment > result = new arraylist < messagefragment > ( ) ; try { string xml = buf . tostring ( ) ; if ( xml . startswith ( "<?xml" ) ) { int end = xml . indexof ( "?>" ) ; string encoding = xml . substring ( 0 , end + 2 ) + "\\n" ; result . add ( new simplenonlocalizabletextfragment ( encoding ) ) ; } chain . setpatterns ( reference_string_pattern , escape_pattern ) ; document document = documenthelper . parsetext ( xml ) ; visitnodes ( result , document ) ; } catch ( documentexception ex ) { ex . printstacktrace ( ) ; } list < message > list = new arraylist < message > ( ) ; for ( messagefragment fragment : result ) { list . add ( new androidresourcemessage ( fragment ) ) ; } messages = collections . unmodifiablelist ( list ) ; return new readablemessagecatalog ( ) { public iterable < message > readmessages ( ) { return messages ; } @ override public void close ( ) throws ioexception { } } ; }
tr	8	public isogrid ( ) { textureloader tx = new textureloader ( ) ; texture testtex = tx . gettexture ( "assets/iso_grass.png" ) ; texture testtex2 = tx . gettexture ( "assets/iso_grass2.png" ) ; texture flowers = tx . gettexture ( "assets/iso_grass3.png" ) ; texture flower = tx . gettexture ( "assets/iso_grass4.png" ) ; texture mushroom = tx . gettexture ( "assets/iso_grass5.png" ) ; texture clump = tx . gettexture ( "assets/iso_grass6.png" ) ; texture tex = null ; for ( int y = 0 ; y < 50 ; y ++ ) { for ( int x = 0 ; x < 20 ; x ++ ) { if ( rnd . nextint ( 100 ) > 98 ) { if ( rnd . nextint ( 100 ) > 70 ) { tex = mushroom ; } else { tex = flowers ; } } else if ( rnd . nextint ( 100 ) > 95 ) { if ( rnd . nextint ( 100 ) > 70 ) { tex = clump ; } else { tex = flower ; } } else if ( rnd . nextint ( 100 ) > 60 ) { tex = testtex2 ; } else { tex = testtex ; } if ( y % 2 == 0.0 ) { drawable q = new isoquad ( x * 64 , ( y * 16 ) , tex ) ; pipe . add ( q ) ; } else { drawable q = new isoquad ( ( x * 64 ) + 32 , ( y * 16 ) , tex ) ; pipe . add ( q ) ; } } } }
tr	9	public void run ( ) { long d ; if ( keepalivetime <= 0 ) return ; while ( ! isinterrupted ( ) ) { d = system . currenttimemillis ( ) - keepalivetime ; synchronized ( activeconnections ) { iterator < string > i1 ; i1 = activeconnections . keyset ( ) . iterator ( ) ; while ( i1 . hasnext ( ) ) { string key ; key = i1 . next ( ) ; arraylist < webconnection > v ; v = activeconnections . get ( key ) ; iterator < webconnection > i2 ; i2 = v . iterator ( ) ; synchronized ( v ) { while ( i2 . hasnext ( ) ) { webconnection wc ; wc = i2 . next ( ) ; if ( wc . releasedat == 0 ) { system . out . println ( "[internal error] somebody closed a released connection." ) ; } if ( wc . releasedat < d ) { i2 . remove ( ) ; if ( trace_keepalive ) system . out . println ( "[pool cleaner] * closing connection to " + wc + " ttl exceed by " + ( ( d - wc . getreleasedat ( ) ) / 1000l ) + "s." ) ; try { wc . close ( ) ; } catch ( ioexception ignore ) { } } } } if ( v . size ( ) == 0 ) i1 . remove ( ) ; } } try { sleep ( keepalivetime ) ; } catch ( interruptedexception ie ) { } } }
tr	3	public void loadfiles ( ) { if ( new file ( "plugins/censornizer/config.yml" ) . exists ( ) ) { main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } else { main . savedefaultconfig ( ) ; main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } if ( ! list . exists ( ) ) { try { list . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! banlist . exists ( ) ) { try { banlist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! whitelist . exists ( ) ) { try { whitelist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } try { scanner s = new scanner ( list ) ; while ( s . hasnextline ( ) ) { main . blacklist . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . blacklist . size ( ) + " words to be censored!" ) ; } try { scanner s = new scanner ( whitelist ) ; while ( s . hasnextline ( ) ) { main . white . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . white . size ( ) + " words to be not censored!" ) ; } if ( main . getconfig ( ) . getboolean ( "config.usebanlist" , true ) ) { try { scanner s = new scanner ( banlist ) ; while ( s . hasnextline ( ) ) { main . bancommands . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . bancommands . size ( ) + " words to ban players!" ) ; } } else { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] banlist is disabled!" ) ; } }
tr	7	public void downloadpackage ( package p ) throws ioexception { if ( p . version == null ) { p . version = parser . mostrecentversion ( p ) ; } final list < package > deps ; try { deps = parser . getdependencies ( p ) ; } catch ( runtimeexception e ) { log . error ( "error: unable to resolve package data from {}<litcomma> aborting." , p . tostring ( ) ) ; return ; } if ( deps . size ( ) > 0 ) { log . info ( "{} has {} dependencies<litcomma> resolving..." , p . tostring ( ) , deps . size ( ) ) ; for ( package dependency : deps ) { downloadpackage ( dependency ) ; } } log . info ( "downloading {} ..." , p . tostring ( ) ) ; string downloadurl = getdownloadurl ( p ) ; url jarrequest = new url ( downloadurl ) ; readablebytechannel rbc = channels . newchannel ( jarrequest . openstream ( ) ) ; fileoutputstream fos = new fileoutputstream ( options . jenenv + file . separator + p . artifactid + "-" + p . version + ".jar" ) ; fos . getchannel ( ) . transferfrom ( rbc , 0 , 1 << 24 ) ; fos . close ( ) ; log . info ( "download complete." ) ; }
tr	2	public clientloginframe ( ) { getcontentpane ( ) . setlayout ( null ) ; system . out . println ( "want to connect to server?" ) ; panel = new jpanel ( ) ; panel . setbounds ( 40 , 41 , 349 , 186 ) ; getcontentpane ( ) . add ( panel ) ; panel . setlayout ( null ) ; jlabel lblipaddress = new jlabel ( "ip address" ) ; lblipaddress . setbounds ( 31 , 36 , 81 , 14 ) ; panel . add ( lblipaddress ) ; jlabel lblport = new jlabel ( "port" ) ; lblport . setbounds ( 31 , 67 , 46 , 14 ) ; panel . add ( lblport ) ; tfport = new jtextfield ( ) ; tfport . setbounds ( 139 , 64 , 169 , 20 ) ; panel . add ( tfport ) ; tfport . setcolumns ( 10 ) ; textfield = new jtextfield ( ) ; textfield . settext ( "127.0.0.1" ) ; textfield . setbounds ( 139 , 33 , 169 , 20 ) ; panel . add ( textfield ) ; textfield . setcolumns ( 10 ) ; jlabel lblyourname = new jlabel ( "your roll" ) ; lblyourname . setbounds ( 31 , 101 , 81 , 14 ) ; panel . add ( lblyourname ) ; txtrakin = new jtextfield ( ) ; txtrakin . settext ( "201005009" ) ; txtrakin . setcolumns ( 10 ) ; txtrakin . setbounds ( 139 , 95 , 169 , 20 ) ; panel . add ( txtrakin ) ; jbutton btnconnect = new jbutton ( "connect" ) ; btnconnect . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { string ipaddress = textfield . gettext ( ) ; string name = txtrakin . gettext ( ) ; int port = integer . parseint ( tfport . gettext ( ) ) ; try { system . out . println ( "trying to connect to server." ) ; socket socket = new socket ( ipaddress , port ) ; system . out . println ( "connected to server." ) ; inputstream is = socket . getinputstream ( ) ; outputstream os = socket . getoutputstream ( ) ; byte [ ] bytes = name . getbytes ( ) ; os . write ( bytes ) ; datainputstream dis = new datainputstream ( is ) ; while ( dis . available ( ) == 0 ) { } string response = dis . readutf ( ) ; if ( response . equals ( "validstudentid" ) ) { clientframe clientframe = new clientframe ( socket ) ; clientframe . setsize ( 450 , 300 ) ; clientframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; clientframe . setvisible ( true ) ; dispose ( ) ; } else { string errormessage = "" ; if ( response . equals ( "invalidipaddress" ) ) { errormessage = "the ip address for you device is not allowed to connect with the given student id." ; } else if ( response . equals ( "invalidstudentid" ) ) { errormessage = "the student id you provided is invalid. please re-enter a valid student id." ; } joptionpane . showmessagedialog ( null , errormessage ) ; socket . close ( ) ; } } catch ( unknownhostexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } ) ; btnconnect . setbounds ( 113 , 152 , 89 , 23 ) ; panel . add ( btnconnect ) ; lblwarning = new jlabel ( "" ) ; lblwarning . setfont ( new font ( "arial" , font . bold , 14 ) ) ; lblwarning . setforeground ( color . red ) ; lblwarning . setbounds ( 31 , 11 , 308 , 14 ) ; panel . add ( lblwarning ) ; }
tr	3	@ override public string [ ] classify ( dataset test ) { string [ ] classification = new string [ test . instances . size ( ) ] ; for ( int i = 0 ; i < test . instances . size ( ) ; i ++ ) { instance example = test . instances . get ( i ) ; if ( root instanceof internaldectreenode ) { classification [ i ] = ( ( internaldectreenode ) root ) . classify ( example ) ; } else { classification [ i ] = root . label ; } } return classification ; }
tr	10	public image draw ( apiresponse response ) { if ( response . getstatus ( ) != 0 ) return null ; bytearrayinputstream bis = new bytearrayinputstream ( data ) ; try { bufferedimage image = imageio . read ( bis ) ; graphics2d g2d = image . creategraphics ( ) ; fontmetrics fm = g2d . getfontmetrics ( ) ; basicstroke bs = new basicstroke ( 10 ) ; color bgcolor = new color ( 255 , 255 , 255 , 128 ) ; g2d . setstroke ( bs ) ; for ( apiobject obj : response . getobjects ( ) ) { arraylist < point > location = obj . getlocation ( ) ; g2d . setcolor ( color . black ) ; for ( int i = 0 ; i < 4 ; ++ i ) { g2d . drawline ( location . get ( i ) . getx ( ) , location . get ( i ) . gety ( ) , location . get ( ( i + 1 ) % 4 ) . getx ( ) , location . get ( ( i + 1 ) % 4 ) . gety ( ) ) ; } float x = ( location . get ( 0 ) . getx ( ) + location . get ( 2 ) . getx ( ) ) / 2 ; float y = ( location . get ( 0 ) . gety ( ) + location . get ( 2 ) . gety ( ) ) / 2 ; rectangle2d rect = fm . getstringbounds ( obj . getname ( ) , g2d ) ; g2d . setcolor ( bgcolor ) ; g2d . fillrect ( ( int ) x , ( int ) y - fm . getascent ( ) , ( int ) rect . getwidth ( ) , ( int ) rect . getheight ( ) ) ; g2d . setcolor ( color . black ) ; g2d . drawstring ( obj . getname ( ) , x , y ) ; } bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; imageio . write ( image , "jpg" , baos ) ; return new image ( baos . tobytearray ( ) , image . getwidth ( ) , image . getheight ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	7	@ eventhandler public void onplayerdeathevent ( playerdeathevent event ) { player player = ( player ) event . getentity ( ) ; if ( ! player . haspermission ( "trophyheads.drop" ) ) { return ; } if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . player . tostring ( ) ) ) { return ; } boolean dropokay = false ; damagecause dc ; if ( player . getlastdamagecause ( ) != null ) { dc = player . getlastdamagecause ( ) . getcause ( ) ; logdebug ( "damagecause: " + dc . tostring ( ) ) ; } else { logdebug ( "damagecause: null" ) ; return ; } if ( death_types . contains ( dc . tostring ( ) ) ) { dropokay = true ; } if ( death_types . contains ( "all" ) ) { dropokay = true ; } if ( player . getkiller ( ) instanceof player ) { logdebug ( "player " + player . getname ( ) + " killed by another player. checking if pvp is valid death type." ) ; if ( death_types . contains ( "pvp" ) ) { dropokay = isvaliditem ( entitytype . player , player . getkiller ( ) . getiteminhand ( ) . gettype ( ) ) ; logdebug ( "pvp is a valid death type. killer's item in hand is valid? " + dropokay ) ; } else { logdebug ( "pvp is not a valid death type." ) ; } } if ( dropokay ) { logdebug ( "match: true" ) ; location loc = player . getlocation ( ) . clone ( ) ; world world = loc . getworld ( ) ; string pname = player . getname ( ) ; itemstack item = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = item . getitemmeta ( ) ; arraylist < string > itemdesc = new arraylist < > ( ) ; itemmeta . setdisplayname ( "head of " + pname ) ; itemdesc . add ( event . getdeathmessage ( ) ) ; itemmeta . setlore ( itemdesc ) ; if ( playerskin ) { ( ( skullmeta ) itemmeta ) . setowner ( pname ) ; } item . setitemmeta ( itemmeta ) ; world . dropitemnaturally ( loc , item ) ; } else { logdebug ( "match: false" ) ; } }
tr	1	@ test public void test ( ) throws exception { url pdmlurl = pdmlreadertest . class . getresource ( "sipcall.pdml" ) ; assert . assertnotnull ( pdmlurl ) ; pdml pdml = new pdmlreader ( ) . unmarshall ( pdmlurl ) ; assert . assertnotnull ( pdml ) ; assert . assertequals ( 1571 , pdml . packets . length ) ; assert . assertequals ( 6 , pdml . packets [ 300 ] . protocols . length ) ; assert . assertequals ( "rtp" , pdml . packets [ 300 ] . protocols [ 5 ] . name ) ; assert . assertequals ( 12 , pdml . packets [ 300 ] . protocols [ 5 ] . fields . length ) ; assert . assertequals ( "rtp.payload" , pdml . packets [ 300 ] . protocols [ 5 ] . fields [ 11 ] . name ) ; assert . assertequals ( "080b88fef3bc8a9f4c55fe46a1281fbeb1a4b4ee9ac01ff880" , pdml . packets [ 300 ] . protocols [ 5 ] . fields [ 11 ] . value ) ; }
tr	8	@ override protected void dopost ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception { try { string identificador = null ; try { identificador = obtemidentificador ( req ) ; } catch ( recursosemidentificadorexception e ) { resp . senderror ( 400 , e . getmessage ( ) ) ; } if ( identificador != null && estoque . recuperarcervejapelonome ( identificador ) != null ) { resp . senderror ( 409 , "ja existe uma cerveja com esse nome" ) ; return ; } string tipodeconteudo = req . getcontenttype ( ) ; cerveja cerveja = null ; unmarshaller unmarshaller = context . createunmarshaller ( ) ; if ( tipodeconteudo == null || tipodeconteudo . contains ( "application/xml" ) ) { cerveja = ( cerveja ) unmarshaller . unmarshal ( req . getinputstream ( ) ) ; cerveja . setnome ( identificador ) ; estoque . adicionarcerveja ( cerveja ) ; string requesturi = req . getrequesturi ( ) ; resp . setheader ( "location" , requesturi ) ; resp . setstatus ( 201 ) ; escrevexml ( req , resp ) ; } else if ( tipodeconteudo . contains ( "application/json" ) ) { list < string > lines = ioutils . readlines ( req . getinputstream ( ) ) ; stringbuilder builder = new stringbuilder ( ) ; for ( string line : lines ) { builder . append ( line ) ; } mappednamespaceconvention con = new mappednamespaceconvention ( ) ; jsonobject jsonobject = new jsonobject ( builder . tostring ( ) ) ; xmlstreamreader xmlstreamreader = new mappedxmlstreamreader ( jsonobject , con ) ; cerveja = ( cerveja ) unmarshaller . unmarshal ( xmlstreamreader ) ; cerveja . setnome ( identificador ) ; estoque . adicionarcerveja ( cerveja ) ; string requesturi = req . getrequesturi ( ) ; resp . setheader ( "location" , requesturi ) ; resp . setstatus ( 201 ) ; escrevejson ( req , resp ) ; } else { resp . senderror ( 415 ) ; return ; } } catch ( exception e ) { resp . senderror ( 500 , e . getmessage ( ) ) ; } }
tr	7	public static arraylist < string > getdirectorylisting ( string url ) throws ioexception { document doc = jsoup . connect ( unity . url + unity . folder + "/" + url ) . get ( ) ; elements extracted_links = doc . select ( "a[href]" ) ; arraylist < string > links = new arraylist < string > ( ) ; for ( int i = 0 ; i < extracted_links . size ( ) ; i ++ ) { string check = extracted_links . get ( i ) . attr ( "href" ) ; if ( ! ( check . contains ( "?c=n;o=d" ) ) && ! ( check . contains ( "?c=m;o=a" ) ) && ! ( check . contains ( "?c=d;o=a" ) ) && ! ( check . contains ( "?c=s;o=a" ) ) && ! ( check . contains ( "content/minecraft/files" ) ) ) { links . add ( extracted_links . get ( i ) . attr ( "href" ) ) ; } } return links ; }
tr	5	protected void assertequals ( arraylist < ? > xlist , arraylist < ? > list ) { assert . assertequals ( xlist . size ( ) , list . size ( ) ) ; for ( int i = 0 ; i < xlist . size ( ) ; i ++ ) { object obj = xlist . get ( i ) ; if ( obj instanceof arrayparameter ) { assertequals ( ( arrayparameter ) obj , list . get ( i ) ) ; } else if ( obj instanceof groupedparameter ) { assertequals ( ( groupedparameter ) obj , list . get ( i ) ) ; } else if ( obj instanceof singleparameter ) { assertequals ( ( singleparameter ) obj , list . get ( i ) ) ; } } }
tr	10	private token tokenizenumericalliteral ( ) { string numberline = source . get ( currentline ) ; int numberlength = 0 ; int pointcount = 0 ; boolean hasfractionalpart = false ; do { if ( numberline . charat ( numberlength ) == '.' ) { pointcount ++ ; if ( numberline . length ( ) > numberlength + 1 && character . isdigit ( numberline . charat ( numberlength + 1 ) ) ) { hasfractionalpart = true ; } } numberlength ++ ; } while ( numberline . length ( ) > numberlength && ( character . isdigit ( numberline . charat ( numberlength ) ) || numberline . charat ( numberlength ) == '.' ) ) ; if ( pointcount > 1 ) { handler . reporterror ( new handler . builderror ( 2 , currentline , currentposition ) ) ; return new token ( ) ; } if ( ! hasfractionalpart && pointcount > 0 ) { handler . reporterror ( new handler . builderror ( 4 , currentline , currentposition ) ) ; return new token ( ) ; } token token = new token ( ( pointcount == 1 ) ? tokentype . float_literal : tokentype . integer_literal , numberline . substring ( 0 , numberlength ) , currentline , currentposition ) ; consume ( numberlength ) ; return token ; }
tr	3	private long [ ] map ( final runnable task , final int executioncount , int threadpoolsize ) throws interruptedexception { final map < thread , long [ ] > calculationresults = new hashmap < > ( ) ; for ( int i = 0 ; i < threadpoolsize ; i ++ ) { thread thread = new thread ( ) { @ override public void run ( ) { long [ ] calcs = calculationresults . get ( this ) ; for ( int j = 0 ; j < calcs . length ; j ++ ) { long starttime = system . currenttimemillis ( ) ; task . run ( ) ; calcs [ j ] = system . currenttimemillis ( ) - starttime ; } } } ; calculationresults . put ( thread , new long [ executioncount ] ) ; } for ( thread thread : calculationresults . keyset ( ) ) { thread . start ( ) ; } long [ ] results = new long [ 0 ] ; for ( map . entry < thread , long [ ] > entry : calculationresults . entryset ( ) ) { entry . getkey ( ) . join ( ) ; results = arrayutils . addall ( results , entry . getvalue ( ) ) ; } return results ; }
tr	6	public static string hexdump ( byte [ ] bytes ) { stringbuilder sb = new stringbuilder ( ) ; for ( int addr = 0 ; addr < bytes . length ; addr ++ ) { if ( ( addr & 0xf ) == 0 ) { if ( addr != 0 ) sb . append ( '\\n' ) ; sb . append ( string . format ( "%08x: " , addr ) ) ; } sb . append ( string . format ( "%02x" , bytes [ addr ] ) ) ; if ( ( addr & 0xf ) != 15 ) sb . append ( ' ' ) ; } return sb . tostring ( ) ; }
tr	2	public static void main ( string [ ] args ) { string host = "irc.freenode.net" ; string channel = "#uofa-acm" ; string nick = "examplebot" ; int port = 6667 ; ircbot bot = new ircbot ( host , channel , nick , port ) ; bot . addhandler ( new messagehandler ( bot ) { void handle ( message message ) { if ( message . gettrailing ( ) . contains ( "hello " + bot . getnick ( ) ) ) { bot . sendprivmsg ( bot . getchannel ( ) , "hey!" ) ; } } } ) ; bot . run ( ) ; }
tr	8	private void generatepoints ( ) { if ( this . expression != null ) { this . parser . setexpression ( this . expression ) ; double steps = ( this . interval . getdistance ( ) + 1 ) / this . xticksnum ; arraylist < java . lang . double > result = this . parser . eval ( this . interval , steps ) ; double maxy = result . get ( 0 ) ; double miny = result . get ( 0 ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { this . points . add ( new point2d . double ( this . interval . start + i * steps , result . get ( i ) ) ) ; if ( result . get ( i ) > maxy ) maxy = result . get ( i ) ; if ( result . get ( i ) < miny ) miny = result . get ( i ) ; } this . origin = new point2d . double ( this . interval . start , miny ) ; this . axisx . setinterval ( this . interval . start , this . interval . end ) ; this . axisx . setnumticks ( xticksnum ) ; this . axisy . setinterval ( miny , maxy ) ; this . axisy . setnumticks ( yticksnum ) ; } }
tr	2	public static void main ( string [ ] unused ) { machine m ; bufferedreader input = new bufferedreader ( new inputstreamreader ( system . in ) ) ; buildrotors ( ) ; m = null ; try { while ( true ) { string line = input . readline ( ) ; if ( line == null ) { break ; } if ( isconfigurationline ( line ) ) { m = new machine ( ) ; configure ( m , line ) ; } else { printmessageline ( m . convert ( standardize ( line ) ) ) ; } } } catch ( ioexception excp ) { system . err . printf ( "input error: %s%n" , excp . getmessage ( ) ) ; system . exit ( 1 ) ; } }
tr	7	public static void findkthelement ( linkedlist < integer > list ) { if ( list . isempty ( ) || null == list ) { system . out . println ( "empty list" ) ; return ; } scanner scan = new scanner ( system . in ) ; system . out . println ( "enter the position of the element: " ) ; int pos = scan . nextint ( ) ; if ( pos > list . size ( ) ) { system . out . println ( "position number exceeds list size" ) ; return ; } int size = list . size ( ) ; int pos1 = 0 ; while ( pos1 < pos ) { pos1 ++ ; } int pos2 = 0 ; while ( pos1 < size ) { pos1 ++ ; pos2 ++ ; } system . out . println ( pos + " position to the last element is: " + list . get ( pos2 ) ) ; }
tr	8	private static double computedcg ( list < integer > urls , list < integer > googleorder , int noofentries ) { double gain = 0 ; double logtwo = math . log ( 2 ) ; int rank = 0 ; for ( int i = 0 ; i < noofentries ; i ++ ) { integer item = googleorder . get ( i ) ; integer val = urls . get ( item - 1 ) ; rank ++ ; if ( rank < 2 ) { gain += val ; } else { gain += val * logtwo / math . log ( rank ) ; } } return gain ; }
tr	1	public static void main ( string args [ ] ) { player player = new player ( ) ; int player_health = player . gethealth ( ) ; monster monster = new monster ( ) ; int monster_health = monster . getmonsterhealth ( ) ; attack attack = new attack ( ) ; int special_attack = attack . getsepcialattack ( ) ; boolean running = true ; string user_option = "" ; string attack_option = "" ; string potion_option = "" ; string restart_option = "" ; potions potions = new potions ( ) ; int weak_potion = potions . getweakpotion ( ) ; int weak_count = 5 ; int strong_potion = potions . getstrongpotion ( ) ; int strong_count = 3 ; int super_potion = potions . getsuperpotion ( ) ; int super_count = 1 ; while ( running ) { system . out . println ( "1 --> attack monster!\\n" + "2 --> run away like a chicken!\\n" + "3 --> quit the damn game!!!" ) ; user_option = input . nextline ( ) ; if ( user_option . equals ( "1" ) ) { while ( player_health > 0 || monster_health > 0 ) { system . out . println ( "1 --> attack\\n" + "2 --> special attack\\n" + "3 --> drink health potion" ) ; attack_option = input . nextline ( ) ; if ( attack_option . equals ( "1" ) ) { player_health = attack . monsterdamage ( player_health ) ; monster_health = attack . playerdamage ( monster_health ) ; system . out . printf ( "player health: %d\\n" + "monster health: %d\\n" , attack . monsterdamage ( player_health ) , attack . playerdamage ( monster_health ) ) ; } else if ( attack_option . equals ( "2" ) ) { if ( special_attack > 0 ) { special_attack -= 25 ; player_health = attack . monsterdamage ( player_health ) ; monster_health = attack . playerspecialdamage ( monster_health ) ; system . out . printf ( "player health: %d\\n" + "monster health: %d\\n" , player_health , monster_health ) ; } else { system . out . println ( "let your special attack recharge!" ) ; } } else if ( attack_option . equals ( "3" ) ) { system . out . println ( "1 --> weak health potion (restore 10 health)\\n" + "2 --> strong health potion (restore 20 health)\\n" + "3 --> super health potion (restore 50 health)\\n" + "4 --> quit" ) ; potion_option = input . nextline ( ) ; while ( ! potion_option . equals ( "4" ) ) { if ( potion_option . equals ( "1" ) ) { if ( weak_count > 0 ) { weak_count -= 1 ; player_health += weak_potion ; system . out . println ( player_health ) ; break ; } else { system . out . println ( "you have run out of weak health potion" ) ; break ; } } else if ( potion_option . equals ( "2" ) ) { if ( strong_count > 0 ) { strong_count -= 1 ; player_health += strong_potion ; system . out . println ( player_health ) ; break ; } else { system . out . println ( "you have run out of strong health potion." ) ; break ; } } else if ( potion_option . equals ( "3" ) ) { if ( super_count > 0 ) { super_count -= 1 ; player_health += super_potion ; system . out . println ( player_health ) ; break ; } else { system . out . println ( "you have run out of super health potion." ) ; break ; } } else if ( potion_option . equals ( "4" ) ) { break ; } else { system . out . println ( "1 --> weak health potion (10)\\n" + "2 --> strong health potion (20)\\n" + "3 --> super health potion (50)\\n" + "4 --> quit" ) ; potion_option = input . nextline ( ) ; } } if ( monster_health < 0 || player_health < 0 ) { break ; } } if ( monster_health < 0 ) { system . out . println ( "you won! would you like to restart?\\n" + "1 --> yes\\t2 --> no" ) ; restart_option = input . nextline ( ) ; if ( restart_option . equals ( "1" ) ) { player_health = 100 ; player . sethealth ( player_health ) ; monster_health = 100 ; monster . setmonsterhealth ( monster_health ) ; weak_count = 5 ; strong_count = 3 ; super_count = 1 ; attack . setsepcialattack ( 50 ) ; } else if ( restart_option . equals ( "2" ) ) { system . out . println ( "thank you for playing an awesome game!" ) ; running = false ; break ; } else { system . out . println ( "you won! would you like to restart?\\n" + "1 --> yes\\t2 --> no" ) ; restart_option = input . nextline ( ) ; } } else if ( player_health < 0 ) { system . out . println ( "you lost! would you like to restart?\\n" + "1 --> yes\\t2 --> no" ) ; restart_option = input . nextline ( ) ; if ( restart_option . equals ( "1" ) ) { player_health = 100 ; player . sethealth ( player_health ) ; monster_health = 100 ; monster . setmonsterhealth ( monster_health ) ; weak_count = 5 ; strong_count = 3 ; super_count = 1 ; attack . setsepcialattack ( 50 ) ; } else if ( restart_option . equals ( "2" ) ) { system . out . println ( "thank you for playing an awesome game!" ) ; running = false ; break ; } } } } else if ( user_option . equals ( "2" ) ) { system . out . println ( "you run away like a chiekn!" ) ; running = false ; } else if ( user_option . equals ( "3" ) ) { system . out . println ( "you successfully closed the game!" ) ; running = false ; } else { system . out . println ( "1 --> attack monster!\\n" + "2 --> run away like a chicken!\\n" + "3 --> quit the damn game!!!" ) ; user_option = input . nextline ( ) ; } } }
tr	9	private static void calctestaccuracy ( dataset test , string [ ] results ) { if ( results == null ) { system . out . println ( "error in calculating accuracy: " + "you must implement the classify method" ) ; system . exit ( - 1 ) ; } list < instance > testinslist = test . instances ; if ( testinslist . size ( ) == 0 ) { system . out . println ( "error: size of test set is 0" ) ; system . exit ( - 1 ) ; } if ( testinslist . size ( ) > results . length ) { system . out . println ( "error: the number of predictions is inconsistant " + "with the number of instances in test set<litcomma> please check it" ) ; system . exit ( - 1 ) ; } int correct = 0 , total = testinslist . size ( ) ; for ( int i = 0 ; i < testinslist . size ( ) ; i ++ ) if ( testinslist . get ( i ) . label . equals ( results [ i ] ) ) correct ++ ; system . out . println ( "prediction accuracy on the test set is: " + string . format ( "%.5f" , correct * 1.0 / total ) ) ; return ; }
tr	6	public arraylist < string > page ( ) throws classnotfoundexception , sqlexception { bufferedreader reader = null ; arraylist < string > url_lst = null ; hashmap < string , double > score_map = null ; long starttime = system . currenttimemillis ( ) ; url_lst = get_search_urls ( ) ; score_map = get_cosine_score_map ( url_lst ) ; position_scoring ps = new position_scoring ( ) ; hashmap < string , double > temp_scoremap = ps . postionscore ( resultsetmap , score_map , query_words , query_map ) ; if ( temp_scoremap != null ) { score_map = temp_scoremap ; system . out . println ( "updated scoring" ) ; } hashmap < string , double > sorted_score_map = sortbyvalues ( score_map ) ; long endtime = system . currenttimemillis ( ) ; system . out . println ( "time for query = " + ( endtime - starttime ) + "ms" ) ; iterator < string > it = sorted_score_map . keyset ( ) . iterator ( ) ; arraylist < string > urllist = new arraylist < string > ( ) ; int num = 0 ; while ( it . hasnext ( ) ) { urllist . add ( it . next ( ) ) ; if ( num ++ == 50 ) break ; } return urllist ; }
tr	3	public boolean isinchannel ( string channel , string bot ) { for ( user user : getusers ( channel ) ) { if ( bot . equalsignorecase ( "%note" ) && user . getnick ( ) . equalsignorecase ( "kitteh" ) ) { return true ; } if ( bot . equalsignorecase ( "!note" ) && user . getnick ( ) . equalsignorecase ( "benderj2" ) ) { return true ; } if ( bot . equalsignorecase ( ".note" ) ) { if ( user . getnick ( ) . equalsignorecase ( "kitteh" ) || user . getnick ( ) . equalsignorecase ( "benderj2" ) ) { return true ; } } } return false ; }
tr	1	@ test public void getincorrectordercashmethod ( ) throws notenoughmoneyinaccount , notenoughmoneyinatm { account acc = mock ( account . class ) ; card card = mock ( card . class ) ; atm atm = new atm ( acc , card ) ; double ammount = 500.0 ; double accountbalance = 700 ; double moneyfromatm = 1000 ; when ( acc . getbalance ( ) ) . thenreturn ( accountbalance ) ; atm . getcash ( ammount , accountbalance , moneyfromatm ) ; inorder order = inorder ( acc ) ; order . verify ( acc , times ( 1 ) ) . getbalance ( ) ; order . verify ( acc , times ( 1 ) ) . withdraw ( anydouble ( ) ) ; }
tr	3	public map < string , object > obtenerconfiguracion ( ) { map < string , object > propieades = new hashmap < string , object > ( ) ; propieades . put ( propiedadesmanager . prefijo_entida , prolistado ( configuracion . getproperty ( propiedadesmanager . prefijo_entida ) ) ) ; propieades . put ( propiedadesmanager . list_negra_atr , prolistado ( configuracion . getproperty ( propiedadesmanager . list_negra_atr ) ) ) ; propieades . put ( propiedadesmanager . paquete_origen , configuracion . getproperty ( propiedadesmanager . paquete_origen ) ) ; propieades . put ( propiedadesmanager . paquete_destin , configuracion . getproperty ( propiedadesmanager . paquete_destin ) ) ; return propieades ; }
tr	4	private static string read ( clob c ) throws sqlexception , ioexception { stringbuffer sb = new stringbuffer ( ( int ) c . length ( ) ) ; reader r = c . getcharacterstream ( ) ; char [ ] cbuf = new char [ 2048 ] ; int n = 0 ; while ( ( n = r . read ( cbuf , 0 , cbuf . length ) ) != - 1 ) { if ( n > 0 ) { sb . append ( cbuf , 0 , n ) ; } } return sb . tostring ( ) ; }
tr	6	private static void getuserrecordsnranking ( ) { user . addalluser ( ) ; list < user > users = new linkedlist < user > ( user . alluserset . values ( ) ) ; collections . sort ( users ) ; try { bufferedwriter fout = new bufferedwriter ( new filewriter ( "res/usercheckins-rank.txt" ) ) ; for ( int i = users . size ( ) - 1 ; i >= 0 ; i -- ) { user u = users . get ( i ) ; u . getlocations ( ) ; fout . write ( string . format ( "%d\\t%d\\t%d%n" , u . userid , u . records . size ( ) , u . locs . size ( ) ) ) ; } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	8	private static void deleteinvalidseparators ( int n ) { object [ ] keys = separators . keyset ( ) . toarray ( ) ; for ( int j = 0 ; j < keys . length ; j ++ ) { string key = ( string ) keys [ j ] ; int [ ] counts = ( int [ ] ) separators . get ( key ) ; if ( counts [ 0 ] == 0 || n > 0 && counts [ 0 ] != counts [ 1 ] ) { separators . remove ( key ) ; } else { counts [ 1 ] = counts [ 0 ] ; counts [ 0 ] = 0 ; separators . put ( key , counts ) ; } } }
tr	5	public void save ( ) { filewriter writer = null ; try { writer = new filewriter ( filename ) ; for ( map . entry < string , string > pairs : map . entryset ( ) ) { writer . write ( pairs . getkey ( ) + ": " + pairs . getvalue ( ) + "\\n" ) ; } } catch ( ioexception ex ) { logger . getlogger ( configfile . class . getname ( ) ) . log ( level . severe , null , ex ) ; } finally { try { writer . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( configfile . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } }
tr	2	public void grabararchivodehelper ( string paquetecodigogenerado , stringbuilder contenido , string path ) { string foldercodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + foldercodigogenerado + file . separatorchar + nombreclasehelpervoentity + ".java" ; system . out . println ( "path: " + path ) ; system . out . println ( "paquetecodigogenerado: " + paquetecodigogenerado ) ; system . out . println ( "foldercodigogenerado: " + foldercodigogenerado ) ; system . out . println ( "filename: " + filename ) ; contenido . insert ( 0 , importsclasehelpervoentity . tostring ( ) ) ; contenido . insert ( 0 , nl + "/* en caso de cambiar el modelo de datos<litcomma> esta clase debe ser modificada o volver a generar. */" + nl + nl ) ; contenido . insert ( 0 , nl + "* fecha creacion: " + new date ( ) . tostring ( ) + " */" + nl ) ; contenido . insert ( 0 , nl + "/* clase - autogenerada" + nl ) ; contenido . insert ( 0 , "package " + paquetecodigogenerado + ";" + nl ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( contenido . tostring ( ) ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	7	private void dfs ( string s , arraylist < string > path , int start , arraylist < arraylist < string > > res ) { if ( start == s . length ( ) ) { arraylist < string > newpath = new arraylist < string > ( ) ; newpath . addall ( path ) ; res . add ( newpath ) ; return ; } for ( int j = start ; j < s . length ( ) ; j ++ ) { if ( ispalindrome ( s , start , j ) ) { path . add ( s . substring ( start , j + 1 ) ) ; dfs ( s , path , j + 1 , res ) ; path . remove ( path . size ( ) - 1 ) ; } } }
tr	1	private void handleobjectcreations ( ) { date now = new date ( ) ; if ( now . gettime ( ) - lastrockcreatedat . gettime ( ) > rockcreatingrate ) { int rnd = gameobject . randomwithrange ( 2 , 4 ) ; image imagetopass = null ; objectbounds boundstopass = null ; if ( rnd == 2 ) { imagetopass = rock32image ; boundstopass = ( objectbounds ) rock32bounds . clone ( ) ; } else if ( rnd == 3 ) { imagetopass = rock48image ; boundstopass = ( objectbounds ) rock48bounds . clone ( ) ; } else if ( rnd == 4 ) { imagetopass = rock64image ; boundstopass = ( objectbounds ) rock64bounds . clone ( ) ; } rocks . add ( new rock ( rnd , imagetopass , boundstopass , width , height ) ) ; lastrockcreatedat = now ; } if ( now . gettime ( ) - lastbulletfiredat . gettime ( ) > bulletfiringrate && isfiring ) { bullets . add ( new bullet ( ship . getx ( ) + 3 , ship . gety ( ) + 20 , this . width , this . height , bulletimage , ( objectbounds ) bulletbounds . clone ( ) ) ) ; bullets . add ( new bullet ( ship . getx ( ) + ship . getwidth ( ) - 8 , ship . gety ( ) + 20 , this . width , this . height , bulletimage , ( objectbounds ) bulletbounds . clone ( ) ) ) ; int x = ( int ) ( ship . getx ( ) + ( ship . getwidth ( ) / 2 ) ) - ( bulletimage . getwidth ( null ) / 2 ) ; bullets . add ( new bullet ( x , ship . gety ( ) , this . width , this . height , bulletimage , ( objectbounds ) bulletbounds . clone ( ) ) ) ; lastbulletfiredat = now ; } }
tr	8	public static money parsemoney ( string inputstring ) { long dollars ; int cents ; int numofnegs = 0 ; boolean neg ; for ( char c : inputstring . tochararray ( ) ) { if ( c == '-' ) { numofnegs ++ ; } } if ( numofnegs % 2 == 0 ) { neg = false ; } else { neg = true ; } inputstring = inputstring . replaceall ( "[^0-9.]+" , "" ) ; string [ ] listofnumbersstring ; if ( inputstring . contains ( "." ) && ! inputstring . substring ( inputstring . indexof ( "." ) + 1 ) . equals ( "" ) ) { listofnumbersstring = inputstring . split ( "\\\\." ) ; dollars = long . parselong ( listofnumbersstring [ 0 ] ) ; cents = integer . parseint ( listofnumbersstring [ 1 ] ) ; } else { inputstring = inputstring . replaceall ( "\\\\." , "" ) ; dollars = long . parselong ( inputstring ) ; cents = 0 ; } return new money ( dollars , cents , neg ) ; }
tr	1	public void uploadandunzipfile ( string directory , string uploadfile , string deploymodel ) { fileupload fu = new fileupload ( ) ; channelsftp sftp = fu . connect ( server_ip , server_port , user_name , password ) ; system . out . println ( "\u5f00\u59cb\u4e0a\u4f20\u6587\u4ef6" ) ; fu . upload ( directory , uploadfile , sftp ) ; system . out . println ( "\u4e0a\u4f20\u6587\u4ef6\u7ed3\u675f" ) ; file tempfile = new file ( uploadfile . trim ( ) ) ; string filename = tempfile . getname ( ) ; system . out . println ( "filename = " + filename ) ; unzipfile uzf = new unzipfile ( ) ; connection conn = uzf . establishconnection ( server_ip ) ; uzf . unzipfile ( conn , user_name , password , filename , directory , deploymodel ) ; }
tr	9	public string convert ( string infix ) { infix = infix . replaceall ( "\\\\s" , "" ) ; char charvalue ; int i = 0 ; while ( i < infix . length ( ) ) { charvalue = infix . charat ( i ) ; if ( operator . contains ( charvalue ) ) { if ( arraystack . length ( ) == 0 ) { arraystack . push ( charvalue ) ; i ++ ; } else { while ( operatorgreaterorequal ( arraystack . peek ( ) , charvalue ) ) { if ( arraystack . peek ( ) == '(' ) { break ; } postfix . append ( arraystack . pop ( ) ) . append ( ' ' ) ; if ( arraystack . length ( ) == 0 ) { break ; } } arraystack . push ( charvalue ) ; i ++ ; } } else if ( charvalue == '(' ) { arraystack . push ( charvalue ) ; i ++ ; } else if ( charvalue == ')' ) { while ( arraystack . peek ( ) != '(' ) { postfix . append ( arraystack . pop ( ) ) . append ( ' ' ) ; } i ++ ; arraystack . pop ( ) ; } else if ( charvalue >= '0' && charvalue <= '9' ) { while ( charvalue >= '0' && charvalue <= '9' ) { postfix . append ( charvalue ) ; i ++ ; if ( i == infix . length ( ) ) break ; charvalue = infix . charat ( i ) ; } postfix . append ( ' ' ) ; } else throw new illegalargumentexception ( "must be a number or one of the allowable operators" ) ; } while ( arraystack . length ( ) > 0 ) { postfix . append ( arraystack . pop ( ) ) . append ( ' ' ) ; } return postfix . tostring ( ) . trim ( ) ; }
tr	7	public void indexfileordirectory ( string filename ) throws ioexception , interruptedexception { int j = 1 ; addfiles ( new file ( filename ) ) ; int originalnumdocs = writer . numdocs ( ) ; for ( file f : queue ) { j = 1 ; document doc = new document ( ) ; scanner scanner = new scanner ( f ) ; stringbuilder builder = new stringbuilder ( ) ; string docid = "" , url = "" , path = "" , parenturl = "" ; string title = "" , h1 = "" , h2 = "" , h3 = "" ; string bold = "" , strong = "" , em = "" , anchortext = "" , parseddata = "" ; arraylist < string > temparrlist = new arraylist < string > ( ) ; while ( scanner . hasnextline ( ) ) { string currline = scanner . nextline ( ) ; if ( j == 1 ) { docid = currline ; j ++ ; system . out . println ( "docid: " + currline ) ; } else if ( j == 2 ) { url = currline ; j ++ ; system . out . println ( "url: " + currline ) ; } else if ( j == 3 ) { path = currline ; j ++ ; system . out . println ( "path: " + currline ) ; } else if ( j == 4 ) { parenturl = currline ; j ++ ; system . out . println ( "docparent url: " + currline ) ; } else if ( j == 5 ) { title = currline ; j ++ ; system . out . println ( "title: " + currline ) ; } else if ( j == 6 ) { h1 = currline ; j ++ ; system . out . println ( "h1: " + currline ) ; } else if ( j == 7 ) { h2 = currline ; j ++ ; system . out . println ( "h2: " + currline ) ; } else if ( j == 8 ) { h3 = currline ; j ++ ; system . out . println ( "h3: " + currline ) ; } else if ( j == 9 ) { bold = currline ; j ++ ; system . out . println ( "bold: " + currline ) ; } else if ( j == 10 ) { strong = currline ; j ++ ; system . out . println ( "string: " + currline ) ; } else if ( j == 11 ) { em = currline ; j ++ ; system . out . println ( "em: " + currline ) ; } else if ( j == 12 ) { anchortext = currline ; j ++ ; system . out . println ( "anchortext: " + currline ) ; } else if ( j == 13 ) { parseddata = currline ; j ++ ; temparrlist = utilities . removestopwords ( arrays . aslist ( parseddata ) , stopwords ) ; for ( string string : temparrlist ) { builder . append ( string + " " ) ; } system . out . println ( "parsed data: " + currline ) ; } } field titlefield = new textfield ( "title" , title , field . store . yes ) ; titlefield . setboost ( 9.1f ) ; doc . add ( titlefield ) ; field h1field = new textfield ( "h1" , h1 , field . store . yes ) ; h1field . setboost ( 50f ) ; doc . add ( h1field ) ; field h2field = new textfield ( "h2" , h2 , field . store . yes ) ; h2field . setboost ( 35f ) ; doc . add ( h2field ) ; field h3field = new textfield ( "h3" , h3 , field . store . yes ) ; h3field . setboost ( 25f ) ; doc . add ( h3field ) ; field boldfield = new textfield ( "bold" , bold , field . store . yes ) ; boldfield . setboost ( 17f ) ; doc . add ( boldfield ) ; field strongfield = new textfield ( "strong" , strong , field . store . yes ) ; strongfield . setboost ( 17f ) ; doc . add ( strongfield ) ; field emfield = new textfield ( "em" , em , field . store . yes ) ; emfield . setboost ( 20f ) ; doc . add ( emfield ) ; field anchortxtfield = new textfield ( "anchortxt" , anchortext , field . store . yes ) ; anchortxtfield . setboost ( 25f ) ; doc . add ( anchortxtfield ) ; field parseddatafield = new textfield ( "parseddata" , builder . tostring ( ) , field . store . yes ) ; parseddatafield . setboost ( 75f ) ; doc . add ( parseddatafield ) ; doc . add ( new stringfield ( "filename" , url , field . store . yes ) ) ; writer . adddocument ( doc ) ; system . out . println ( "added: " + f ) ; scanner . close ( ) ; } int newnumdocs = writer . numdocs ( ) ; system . out . println ( "" ) ; system . out . println ( "************************" ) ; system . out . println ( ( newnumdocs - originalnumdocs ) + " documents added." ) ; system . out . println ( "************************" ) ; queue . clear ( ) ; }
tr	7	public string strstr ( string haystack , string needle ) { int size1 = haystack . length ( ) ; int size2 = needle . length ( ) ; if ( size2 == 0 ) return haystack ; if ( size1 == 0 ) return null ; for ( int i = 0 ; i < size1 - size2 + 1 ; i ++ ) { for ( int j = 0 ; j < size2 ; j ++ ) { if ( haystack . charat ( i + j ) != needle . charat ( j ) ) { break ; } else { if ( j == size2 - 1 ) { return haystack . substring ( i ) ; } } } } return null ; }
tr	3	public boolean equals ( object object ) { if ( object instanceof string ) { return ( ( string ) object ) . tolowercase ( ) . equals ( this . name ) ; } else if ( object instanceof editban ) { editban o = ( editban ) object ; return o . name . equals ( this . name ) && o . admin . equals ( this . admin ) && o . reason . equals ( this . reason ) && o . ip . equals ( this . ip ) && o . time == this . time && o . endtime == this . endtime && o . type == this . type ; } return false ; }
tr	1	private string generarimports ( ) { stringbuilder sb = new stringbuilder ( ) ; map < string , string > importables = new hashmap < string , string > ( ) ; for ( atributovo atributovo : atributos ) { if ( ! isnoimportable ( atributovo . getnombrepackagetype ( ) ) && ! importables . containsvalue ( atributovo . getnombrepackagetype ( ) ) && ! atributovo . getnombrepackagetype ( ) . startswith ( paquetecontenedororigen ) ) { sb . append ( "import " + atributovo . getnombrepackagetype ( ) + ";" + nl ) ; importables . put ( atributovo . getnombrepackagetype ( ) , atributovo . getnombrepackagetype ( ) ) ; } } sb . append ( "import java.io.serializable;\\n" + nl ) ; return sb . tostring ( ) ; }
tr	8	public int cancompletecircuit ( int [ ] gas , int [ ] cost ) { int res = - 1 ; int n = gas . length ; int total = 0 ; int [ ] gap = new int [ n ] ; for ( int i = 0 , j = 0 ; i < n ; i ++ , j ++ ) { if ( i == 0 ) gap [ i ] = gas [ i ] - cost [ i ] ; else gap [ i ] = gap [ i - 1 ] + gas [ i ] - cost [ i ] ; total += gas [ i ] - cost [ i ] ; } if ( total < 0 ) return res ; { int least = gap [ 0 ] ; res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( gap [ i ] <= least ) { least = gap [ i ] ; res = i ; } } res = res + 1 ; if ( res == n ) res = 0 ; return res ; } }
tr	3	@ override public list < string > getimageslist ( string url ) { arraylist < string > imglist = new arraylist < string > ( ) ; try { string pagestr = readpage ( new url ( url ) ) ; matcher m = imagepattern . matcher ( pagestr ) ; while ( m . find ( ) ) { imglist . add ( m . group ( 1 ) ) ; } } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return imglist ; }
tr	8	public listnode reversebetween ( listnode head , int m , int n ) { if ( m == n ) return head ; listnode start = null ; listnode beforestart = null ; listnode curr = null ; for ( int i = 0 ; i < m - 1 ; i ++ ) { beforestart = beforestart == null ? head : beforestart . next ; } start = beforestart == null ? head : beforestart . next ; listnode end = start ; curr = start . next ; listnode oldnext = curr . next ; for ( int i = 0 ; i < n - m ; i ++ ) { oldnext = curr . next ; curr . next = start ; start = curr ; curr = oldnext ; } end . next = oldnext ; if ( beforestart != null ) beforestart . next = start ; return ( beforestart == null ? start : head ) ; }
tr	5	public void setup ( ) { defaultfontsize = 12 ; font = mysketch . createfont ( "helvetica" , defaultfontsize ) ; mysketch . textfont ( font ) ; searchx = myxorigin + 20 ; searchy = myyorigin + 30 ; tagsofinterestx = searchx ; tagsofinteresty = searchy + 30 ; textfieldx = ( int ) ( searchx + 65 ) ; textfieldy = ( int ) searchy - 15 ; textfieldwidth = ( int ) ( mywidth / ( float ) 1.5 ) ; textfieldheight = ( int ) ( defaultfontsize * 1.75 ) ; ddlx = myxorigin + 20 ; ddly = ( int ) tagsofinteresty + 30 ; ddlwidth = 140 ; ddlheight = 25 ; highlightcolor = 200 ; cp5 = new controlp5 ( mysketch ) ; tagsearchfield = cp5 . addtextfield ( "input" ) . setposition ( textfieldx , textfieldy ) . setsize ( textfieldwidth , textfieldheight ) . setfont ( font ) . setfocus ( true ) . setcolor ( mysketch . color ( 0 , 0 , 0 ) ) . setcoloractive ( mysketch . color ( highlightcolor ) ) . setcolorcursor ( mysketch . color ( highlightcolor ) ) . setcolorbackground ( mysketch . color ( 255 ) ) ; }
tr	10	public void paintcomponent ( graphics g ) { polygonmanager . update ( ) ; if ( battlemanager . encounter ) battlemanager . battlemechanics ( ) ; font outputfont = g . getfont ( ) . derivefont ( 17.0f ) ; font smallfont = g . getfont ( ) . derivefont ( 12.0f ) ; mapmanager . wallmanager ( ) ; g . setcolor ( drawings . ceiling ) ; g . fillrect ( 0 , 0 , 501 , 200 ) ; g . setcolor ( drawings . floor ) ; g . fillrect ( 0 , 200 , 501 , 201 ) ; g . setcolor ( color . darkgray ) ; g . fillrect ( 505 , 0 , 50 , 401 ) ; g . setcolor ( color . gray ) ; g . fillrect ( 0 , 405 , 560 , 129 ) ; graphics g2d = ( graphics2d ) g ; affinetransform savetransform = ( ( graphics2d ) g2d ) . gettransform ( ) ; affinetransform scalematrix_left = new affinetransform ( ) ; affinetransform scalematrix_right = new affinetransform ( ) ; scalematrix_left . translate ( 100 , 100 ) ; scalematrix_right . translate ( 150 , 100 ) ; scalematrix_left . scale ( 0.5 , 0.5 ) ; scalematrix_right . scale ( 0.5 , 0.5 ) ; if ( polygonmanager . distance >= 2 ) { if ( mapmanager . left1 ) { g2d . setcolor ( drawings . lighting_gray1 ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_left ) ; g2d . fillpolygon ( drawings . left1 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_left ) ; g2d . drawpolygon ( drawings . left1 ) ; } g2d . setcolor ( drawings . lighting_gray1 ) ; if ( mapmanager . right1 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix_right ) ; g2d . fillpolygon ( drawings . right1 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_right ) ; g2d . drawpolygon ( drawings . right1 ) ; } } affinetransform scalematrix2_left = new affinetransform ( ) ; affinetransform scalematrix2_right = new affinetransform ( ) ; scalematrix2_left . translate ( 150 , 150 ) ; scalematrix2_right . translate ( 225 , 150 ) ; scalematrix2_left . scale ( 0.25 , 0.25 ) ; scalematrix2_right . scale ( 0.25 , 0.25 ) ; g2d . setcolor ( drawings . lighting_gray2 ) ; if ( polygonmanager . distance >= 2 ) { if ( mapmanager . left2 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix2_left ) ; g2d . fillpolygon ( drawings . left2 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix2_left ) ; g2d . drawpolygon ( drawings . left2 ) ; } g2d . setcolor ( drawings . lighting_gray2 ) ; if ( mapmanager . right2 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix2_right ) ; g2d . fillpolygon ( drawings . right2 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix2_right ) ; g2d . drawpolygon ( drawings . right2 ) ; } } ( ( graphics2d ) g2d ) . settransform ( savetransform ) ; if ( polygonmanager . distance <= 3 ) { if ( polygonmanager . distance == 0 ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . distance == 1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . distance >= 2 ) g . setcolor ( drawings . lighting_gray2 ) ; } else g . setcolor ( color . black ) ; if ( ( mapmanager . roomno == 18 || mapmanager . roomno >= 37 ) && mapmanager . facing == 'l' && ! mapmanager . gate ) g . setcolor ( color . green ) ; g . fillpolygon ( drawings . currentforward ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentforward ) ; g . setcolor ( drawings . lighting_gray ) ; if ( polygonmanager . distance >= 1 ) { if ( mapmanager . left ) { g . fillpolygon ( drawings . currentleft ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentleft ) ; g2d . setcolor ( drawings . lighting_gray ) ; } if ( mapmanager . right ) { g . fillpolygon ( drawings . currentright ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentright ) ; } } if ( polygonmanager . left_ext || polygonmanager . left_ext1 || polygonmanager . left_ext2 ) { if ( polygonmanager . left_ext ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . left_ext1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . left_ext2 ) g . setcolor ( drawings . lighting_gray2 ) ; g . fillpolygon ( drawings . left_ext ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . left_ext ) ; } if ( polygonmanager . right_ext || polygonmanager . right_ext1 || polygonmanager . right_ext2 ) { if ( polygonmanager . right_ext ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . right_ext1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . right_ext2 ) g . setcolor ( drawings . lighting_gray2 ) ; g . fillpolygon ( drawings . right_ext ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . right_ext ) ; } if ( mapmanager . roomno == 18 && mapmanager . facing == 'l' && mapmanager . gate ) { image scaledimage = imagemanager . gate1 . getscaledinstance ( 500 , 400 , image . scale_fast ) ; g . drawimage ( scaledimage , 0 , 0 , 500 , 400 , null ) ; } else if ( mapmanager . roomno == 18 && mapmanager . facing == 'l' && ! mapmanager . gate ) { image scaledimage = imagemanager . gate2 . getscaledinstance ( 500 , 400 , image . scale_fast ) ; g . drawimage ( scaledimage , 0 , 0 , 500 , 400 , null ) ; } else if ( mapmanager . roomno == 36 && mapmanager . facing == 'l' && ! mapmanager . chest_open ) g . drawimage ( imagemanager . chest1 , 175 , 275 , null ) ; else if ( mapmanager . roomno == 36 && mapmanager . facing == 'l' && mapmanager . chest_open ) g . drawimage ( imagemanager . chest2 , 175 , 250 , null ) ; if ( mapmanager . key_get ) g . drawimage ( imagemanager . keyblade , 507 , 40 , null ) ; g . drawimage ( imagemanager . sword , 507 , 5 , null ) ; float hp_percent = 0 ; if ( battlemanager . encounter ) { g . setcolor ( color . black ) ; g . setfont ( outputfont ) ; g . drawstring ( battlemanager . output , 5 , 420 ) ; g . setcolor ( color . red ) ; g . fillrect ( 400 , 412 , ( math . round ( battlemanager . hp * 100 ) / battlemanager . maxhp ) , 10 ) ; g . setcolor ( color . black ) ; g . drawrect ( 397 , 409 , 105 , 15 ) ; g . drawstring ( battlemanager . hp + " / " + battlemanager . maxhp , 397 , 440 ) ; g . setcolor ( color . blue ) ; g . fillrect ( 400 , 462 , math . round ( ( battlemanager . mana * 100 ) / battlemanager . maxmana ) , 10 ) ; g . setcolor ( color . black ) ; g . drawrect ( 397 , 459 , 105 , 15 ) ; g . drawstring ( battlemanager . mana + " / " + battlemanager . maxmana , 397 , 490 ) ; if ( battlemanager . selected == 1 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 5 , 440 , 100 , 20 ) ; if ( battlemanager . selected == 2 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 110 , 440 , 100 , 20 ) ; if ( battlemanager . selected == 3 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 5 , 465 , 100 , 20 ) ; if ( battlemanager . selected == 4 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 110 , 465 , 100 , 20 ) ; g . setcolor ( color . black ) ; if ( battlemanager . selected == 1 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "sword" , 10 , 457 ) ; if ( battlemanager . selected == 2 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "fire magic" , 115 , 457 ) ; if ( battlemanager . selected == 3 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "h-potion" , 10 , 482 ) ; if ( battlemanager . selected == 4 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "m-potion" , 115 , 482 ) ; g . setfont ( smallfont ) ; if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "cactuar" ) ) { g . drawimage ( imagemanager . cactuar , 190 , 270 , 150 , 150 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "bomb" ) ) { g . drawimage ( imagemanager . bomb , 180 , 230 , 150 , 160 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "slime" ) ) { g . drawimage ( imagemanager . slime , 170 , 260 , 150 , 150 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "imp" ) ) { g . drawimage ( imagemanager . imp , 170 , 280 , 150 , 150 , null ) ; } } if ( inputmanager . input ( '`' ) && release ) { debug = ! debug ; } if ( inputmanager . input ( '`' ) ) release = false ; else release = true ; if ( debug ) { g . setcolor ( color . red ) ; g . drawrect ( 50 , 0 , 300 , 50 ) ; g . drawstring ( "distance = " + polygonmanager . distance , 60 , 10 ) ; g . drawstring ( "room# = " + mapmanager . roomno , 140 , 10 ) ; g . drawstring ( "facing = " + mapmanager . facing , 220 , 10 ) ; g . drawstring ( "advance = " + mapmanager . advance , 60 , 30 ) ; g . drawstring ( "gate = " + mapmanager . gate , 150 , 30 ) ; g . drawstring ( "encounter = " + battlemanager . encounter , 230 , 30 ) ; g . drawstring ( "hp = " + battlemanager . hp , 340 , 30 ) ; g . drawstring ( "maxhp = " + battlemanager . maxhp , 390 , 30 ) ; } }
tr	2	public buttonpanel ( simulation controller ) { scape = controller ; setlayout ( new borderlayout ( ) ) ; setborder ( borderfactory . createemptyborder ( 10 , 10 , 10 , 10 ) ) ; info = new jtextpane ( ) ; info . setpreferredsize ( new dimension ( 270 , 300 ) ) ; info . setmaximumsize ( new dimension ( 270 , 300 ) ) ; info . seteditable ( false ) ; info . setopaque ( false ) ; info . setborder ( borderfactory . createcompoundborder ( borderfactory . createemptyborder ( 0 , 0 , 20 , 0 ) , borderfactory . createcompoundborder ( borderfactory . createetchedborder ( etchedborder . raised ) , borderfactory . createemptyborder ( 5 , 5 , 5 , 5 ) ) ) ) ; styleddocument doc = info . getstyleddocument ( ) ; addstylestodocument ( doc ) ; updateinfo ( ) ; epochslabel = new jlabel ( "" , swingconstants . center ) ; string ep = "epochs: " + scape . epochs ; epochslabel . settext ( ep ) ; buttons1 = new jpanel ( ) ; buttons1 . setlayout ( new flowlayout ( ) ) ; buttons1 . setborder ( borderfactory . createemptyborder ( 10 , 0 , 10 , 0 ) ) ; next = new jbutton ( "next" ) ; next . setactioncommand ( "next" ) ; next . addactionlistener ( this ) ; buttons1 . add ( next ) ; forwardlabel = new jlabel ( "enter the number of epochs to forward." , swingconstants . left ) ; forwardlabel . setverticalalignment ( swingconstants . bottom ) ; buttons2 = new jpanel ( ) ; buttons2 . setlayout ( new boxlayout ( buttons2 , boxlayout . line_axis ) ) ; forwardepochs = new jtextfield ( "100" ) ; forwardepochs . setmaximumsize ( new dimension ( 100 , 25 ) ) ; forward = new jbutton ( "forward" ) ; forward . setactioncommand ( "forward" ) ; forward . addactionlistener ( this ) ; buttons2 . add ( forwardepochs ) ; buttons2 . add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) ) ; buttons2 . add ( forward ) ; buttons3 = new jpanel ( ) ; buttons3 . setlayout ( new boxlayout ( buttons3 , boxlayout . line_axis ) ) ; buttons3 . setborder ( borderfactory . createemptyborder ( 0 , 0 , 10 , 0 ) ) ; restart = new jbutton ( "restart" ) ; restart . setactioncommand ( "restart" ) ; restart . addactionlistener ( this ) ; exit = new jbutton ( "exit" ) ; exit . setactioncommand ( "exit" ) ; exit . addactionlistener ( this ) ; buttons3 . add ( box . createhorizontalglue ( ) ) ; buttons3 . add ( restart ) ; buttons3 . add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) ) ; buttons3 . add ( exit ) ; body = new jpanel ( ) ; body . setlayout ( new gridlayout ( 0 , 1 ) ) ; body . add ( epochslabel ) ; body . add ( buttons1 ) ; body . add ( forwardlabel ) ; body . add ( buttons2 ) ; this . add ( info , borderlayout . north ) ; this . add ( body , borderlayout . center ) ; this . add ( buttons3 , borderlayout . south ) ; }
tr	10	private list < student > getpageofstudents ( ) { final list < student > pagestudents = new vector < student > ( ) ; if ( students . size ( ) == 0 || currpage < 0 || currpage >= getmaxpage ( ) ) { return pagestudents ; } int size = 0 ; if ( students . size ( ) - viewsize * currpage < viewsize ) { size = students . size ( ) - viewsize * currpage ; } else { size = viewsize ; } if ( size == 0 ) { return pagestudents ; } for ( int i = 0 ; i < size ; ++ i ) { pagestudents . add ( students . get ( i + viewsize * currpage ) ) ; } return pagestudents ; }
tr	6	public void onmessage ( string channel , string sender , string login , string hostname , string message ) { string msg = message . tolowercase ( ) ; string [ ] msgsplit = msg . split ( " " ) ; for ( int i = 0 ; i < msgsplit . length ; i ++ ) { string urltitle = "" ; if ( isyoutube ( msgsplit [ i ] ) ) { break ; } else if ( isurl ( msgsplit [ i ] ) ) { try { urltitle = getwebpagetitle ( msgsplit [ i ] ) ; sendmessage ( channel , sender + "'s url: " + urltitle ) ; break ; } catch ( exception ex1 ) { ex1 . printstacktrace ( ) ; } } } if ( ! sender . equalsignorecase ( getnick ( ) ) ) { sql . checknote ( channel , sender ) ; } if ( msgsplit [ 0 ] . startswith ( config . getcommandprefix ( ) ) ) { string commandname = msgsplit [ 0 ] . replace ( config . getcommandprefix ( ) , "" ) ; for ( mastercommand command : commands ) { if ( commandname . equalsignorecase ( command . getcommandname ( ) ) ) { log . consolelog ( "command" , sender + " issued command: " + message ) ; command . exec ( channel , sender , commandname , msgsplit , login , hostname , message ) ; } } return ; } log . consolelog ( "message" , "<" + channel + "> " + sender + ": " + message ) ; }
tr	4	private void paintgame ( graphics g ) { for ( rock rock : rocks ) { image img = null ; if ( rock . gettype ( ) == gameobject . type . rock32 ) { img = rock32image ; } else if ( rock . gettype ( ) == gameobject . type . rock48 ) { img = rock48image ; } else if ( rock . gettype ( ) == gameobject . type . rock64 ) { img = rock64image ; } g . drawimage ( img , rock . getx ( ) , rock . gety ( ) , rock . getwidth ( ) , rock . getheight ( ) , null ) ; if ( drawobjectborders ) { g . setcolor ( color . white ) ; for ( point point : rock . getbounds ( ) . getpoints ( ) ) { g . drawline ( point . getx ( ) + rock . getx ( ) , point . gety ( ) + rock . gety ( ) , point . getx ( ) + rock . getx ( ) , point . gety ( ) + rock . gety ( ) ) ; } } } for ( explosion explosion : explosions ) { g . drawimage ( explosionimages . get ( explosion . getanimationstep ( ) ) , explosion . getx ( ) , explosion . gety ( ) , explosion . getsize ( ) , explosion . getsize ( ) , null ) ; } for ( bullet bullet : bullets ) { g . setcolor ( color . blue ) ; g . drawimage ( bullet . getimage ( ) , bullet . getx ( ) , bullet . gety ( ) , bullet . getwidth ( ) , bullet . getheight ( ) , null ) ; } g . drawimage ( shipimage , ship . getx ( ) , ship . gety ( ) , ship . getwidth ( ) , ship . getheight ( ) , null ) ; if ( drawobjectborders ) { g . setcolor ( color . white ) ; for ( point point : ship . getbounds ( ) . getpoints ( ) ) { g . drawline ( point . getx ( ) + ship . getx ( ) , point . gety ( ) + ship . gety ( ) , point . getx ( ) + ship . getx ( ) , point . gety ( ) + ship . gety ( ) ) ; } } g . setcolor ( color . blue ) ; g . setfont ( new font ( "helvetica" , font . plain , 18 ) ) ; string score = "score: " + this . score ; int scorewidth = ( int ) g . getfontmetrics ( ) . getstringbounds ( score , g ) . getwidth ( ) ; int startx = this . width - scorewidth - 10 ; int starty = 20 ; g . drawstring ( score , startx , starty ) ; g . drawstring ( "time elapsed: " + ( int ) ( ( new date ( ) . gettime ( ) - gamestartedat . gettime ( ) ) / 1000 ) , 10 , 20 ) ; }
tr	9	public void changedirection ( string instruction ) { set < string > instructions = new hashset < string > ( arrays . aslist ( new string [ ] { "l" , "r" } ) ) ; if ( instruction == null ) { throw new illegalargumentexception ( "instruction can't be null" ) ; } else if ( ! instructions . contains ( instruction ) ) { throw new illegalargumentexception ( "direction (case sensitive) must be in " + instructions ) ; } integer degree = this . dirtodegree . get ( this . direction ) + this . dirtodegree . get ( instruction ) ; if ( degree >= 360 ) { degree -= 360 ; } else if ( degree < 0 ) { degree += 360 ; } this . direction = this . degreetodir . get ( degree ) ; }
tr	1	private void handleobjectmovements ( ) { for ( rock rock : rocks ) { rock . advancey ( direction . down ) ; } for ( bullet bullet : bullets ) { bullet . advancey ( direction . up ) ; } if ( moveup ) { ship . advancey ( gameobject . direction . up ) ; } if ( movedown ) { ship . advancey ( gameobject . direction . down ) ; } if ( moveleft ) { ship . advancex ( gameobject . direction . left ) ; } if ( moveright ) { ship . advancex ( gameobject . direction . right ) ; } }
tr	9	private void loadconfig ( ) { fileconfiguration config = yamlconfiguration . loadconfiguration ( new file ( getdatafolder ( ) , "config.yml" ) ) ; configurationsection limits = config . getconfigurationsection ( "limits" ) ; if ( limits == null ) { this . explosionsallowed = true ; } else { this . explosionsallowed = limits . getboolean ( "explosions" , true ) ; } this . defaultbiomeaffinity = new hashmap < biome , float > ( ) ; for ( biome b : biome . values ( ) ) { this . defaultbiomeaffinity . put ( b , 1f ) ; } configurationsection defaults = config . getconfigurationsection ( "defaults" ) ; if ( defaults == null ) { this . defaulttolerance = 0.2f ; this . defaultfailresult = new reciperesult ( "default-fail" , 0 , 0 , 0 , new arraylist < itemstack > ( ) , 0 , fill . empty , 0 , new arraylist < timerange > ( ) , new arraylist < integer > ( ) , null ) ; this . defaultminsecondsperitem = 1 ; this . defaultmaxsecondsperitem = 1 ; this . defaultminsecondsperheating = 1 ; this . defaultmaxsecondsperheating = 1 ; this . defaultminsecondsperfill = 1 ; this . defaultmaxsecondsperfill = 1 ; } else { this . defaulttolerance = ( float ) defaults . getdouble ( "tolerance" , 0.2d ) ; this . defaultfailresult = reciperesult . fromconfig ( defaults . getconfigurationsection ( "default-fail" ) ) ; configurationsection timing = defaults . getconfigurationsection ( "timing" ) ; if ( timing == null ) { this . defaultminsecondsperitem = 1 ; this . defaultmaxsecondsperitem = 1 ; this . defaultminsecondsperheating = 1 ; this . defaultmaxsecondsperheating = 1 ; this . defaultminsecondsperfill = 1 ; this . defaultmaxsecondsperfill = 1 ; } else { this . defaultminsecondsperitem = ( float ) timing . getdouble ( "min-item" , 1 ) ; this . defaultmaxsecondsperitem = ( float ) timing . getdouble ( "max-item" , 1 ) ; this . defaultminsecondsperheating = ( float ) timing . getdouble ( "min-heat" , 1 ) ; this . defaultmaxsecondsperheating = ( float ) timing . getdouble ( "max-heat" , 1 ) ; this . defaultminsecondsperfill = ( float ) timing . getdouble ( "min-fill" , 1 ) ; this . defaultmaxsecondsperfill = ( float ) timing . getdouble ( "max-fill" , 1 ) ; } configurationsection biomes = defaults . getconfigurationsection ( "biomes" ) ; if ( biomes != null ) { for ( string biomename : biomes . getkeys ( false ) ) { biome biome = biome . valueof ( biomename . replace ( '-' , '_' ) . touppercase ( ) ) ; if ( biome != null && ( biomes . isint ( biomename ) || biomes . islong ( biomename ) || biomes . isdouble ( biomename ) ) ) { this . defaultbiomeaffinity . remove ( biome ) ; this . defaultbiomeaffinity . put ( biome , ( float ) ( biomes . getdouble ( biomename , 100 ) / 100 ) ) ; } } } } }
tr	5	public void connect ( ) { try { debug . print ( "i'm client<litcomma> start to connect to host:" + host ) ; socket skt = new socket ( host , port ) ; debug . print ( "connected" ) ; rsa rsa = new rsa ( ) ; rsa . setn ( this . n ) ; rsa . sete ( this . e ) ; inputstreamreader isr = new inputstreamreader ( system . in ) ; string publickey = "(" + this . e + " " + this . n + ")" ; system . out . println ( "encoding with" + publickey ) ; while ( true ) { char c = ( char ) isr . read ( ) ; string tosend = "" ; if ( c == '\\n' ) { tosend = "\\n" ; } else { tosend = rsa . getcypher ( c + "" ) ; system . out . println ( c + " is encoded to " + tosend ) ; } for ( int i = 0 ; i < tosend . length ( ) ; i ++ ) { skt . getoutputstream ( ) . write ( tosend . charat ( i ) ) ; } } } catch ( connectexception e ) { system . err . println ( "starter haven't started listening yet!!!\\n please give server input info and run again!!!" ) ; } catch ( ioexception e ) { system . err . println ( "connect error" ) ; e . printstacktrace ( ) ; } }
tr	5	public list < change > generatechanges ( ) { file repository = new file ( directory ) ; if ( ! repository . isdirectory ( ) ) { system . err . println ( "repository does not exist" ) ; return null ; } map < string , file > childlist = new treemap < string , file > ( ) ; listfiles ( directory , repository , childlist ) ; iterator it ; map < string , file > parentlist = new treemap < string , file > ( ) ; string parentdir = directory + "/.dot/previous_commit" ; file parentrepo = new file ( parentdir ) ; listfiles ( parentdir , parentrepo , parentlist ) ; filelist = new linkedlist < change > ( ) ; it = childlist . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { map . entry < string , file > pairs = ( map . entry < string , file > ) it . next ( ) ; change cur = new change ( ) ; cur . path = pairs . getkey ( ) ; cur . child = pairs . getvalue ( ) ; cur . parent = parentlist . get ( cur . path ) ; if ( cur . parent == null ) { cur . diff = fileutil . diff ( null , cur . child . getpath ( ) ) ; } else { cur . diff = fileutil . diff ( cur . parent . getpath ( ) , cur . child . getpath ( ) ) ; } filelist . add ( cur ) ; } return filelist ; }
tr	8	private void generatepointslocations ( ) { if ( ! this . points . isempty ( ) ) { double locx ; double locy ; double unitdistx = axisx . getunitdistance ( ) ; double unitdisty = axisy . getunitdistance ( ) ; double unitlengthx = axisx . getunitlength ( ) ; double unitlengthy = axisy . getunitlength ( ) ; for ( int i = 0 ; i < this . points . size ( ) ; i ++ ) { locx = originlocation . x + ( points . get ( i ) . x - origin . x ) / unitdistx * unitlengthx ; locy = originlocation . y - ( points . get ( i ) . y - origin . y ) / unitdisty * unitlengthy ; pointslocations . add ( new point2d . double ( locx , locy ) ) ; } } }
tr	2	private void setimage ( ) { if ( lukitus == false ) { if ( value == 1 ) { img = open1 ; } else if ( value == 2 ) { img = open2 ; } else if ( value == 3 ) { img = open3 ; } else if ( value == 4 ) { img = open4 ; } else if ( value == 5 ) { img = open5 ; } else if ( value == 6 ) { img = open6 ; } } else if ( lukitus == true ) { if ( value == 1 ) { img = locked1 ; } else if ( value == 2 ) { img = locked2 ; } else if ( value == 3 ) { img = locked3 ; } else if ( value == 4 ) { img = locked4 ; } else if ( value == 5 ) { img = locked5 ; } else if ( value == 6 ) { img = locked6 ; } } }
tr	10	private void parse ( string tagcode ) { string [ ] codes = tagcode . split ( ":" ) ; this . partofspeech = codes [ 0 ] ; long taglongcode = 0 ; if ( "adja" . equals ( partofspeech ) || "adjp" . equals ( partofspeech ) || "conj" . equals ( partofspeech ) || "interp" . equals ( partofspeech ) || "pred" . equals ( partofspeech ) || "xxx" . equals ( partofspeech ) || "ign" . equals ( partofspeech ) ) { asserttrue ( codes . length == 1 , "unknown extra data associated with pos tag: " + partofspeech ) ; } else if ( "adv" . equals ( partofspeech ) ) { taglongcode |= parsedegree ( codes , 1 ) ; asserttrue ( codes . length == 2 , "incorrect extra tag data: " + tagcode ) ; } else if ( "imps" . equals ( partofspeech ) || "inf" . equals ( partofspeech ) || "pant" . equals ( partofspeech ) || "pcon" . equals ( partofspeech ) ) { taglongcode |= parseaspect ( codes , 1 ) ; asserttrue ( codes . length == 2 , "incorrect extra tag data: " + tagcode ) ; } else if ( "qub" . equals ( partofspeech ) ) { if ( codes . length > 1 ) { taglongcode |= parsevocality ( codes , 1 ) ; asserttrue ( codes . length == 2 , "incorrect extra tag data: " + tagcode ) ; } else { asserttrue ( codes . length == 1 , "incorrect extra tag data: " + tagcode ) ; } } else if ( "prep" . equals ( partofspeech ) ) { taglongcode |= parsecase ( codes , 1 ) ; if ( codes . length > 2 ) { taglongcode |= parsevocality ( codes , 2 ) ; asserttrue ( codes . length == 3 , "incorrect extra tag data: " + tagcode ) ; } else { asserttrue ( codes . length == 2 , "incorrect extra tag data: " + tagcode ) ; } } else if ( "siebie" . equals ( partofspeech ) ) { taglongcode |= parsecase ( codes , 1 ) ; } else if ( "subst" . equals ( partofspeech ) || "depr" . equals ( partofspeech ) || "xxs" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; asserttrue ( codes . length == 4 , "incorrect extra tag data: " + tagcode ) ; } else if ( "ger" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; taglongcode |= parseaspect ( codes , 4 ) ; taglongcode |= parsenegation ( codes , 5 ) ; asserttrue ( codes . length == 6 , "incorrect extra tag data: " + tagcode ) ; } else if ( "ppron12" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; taglongcode |= parseperson ( codes , 4 ) ; if ( codes . length > 5 ) { taglongcode |= parseaccentability ( codes , 5 ) ; asserttrue ( codes . length == 6 , "incorrect extra tag data: " + tagcode ) ; } else { asserttrue ( codes . length == 5 , "incorrect extra tag data: " + tagcode ) ; } } else if ( "ppron3" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; taglongcode |= parseperson ( codes , 4 ) ; int i = 5 ; if ( codes . length > 5 ) { if ( ! codes [ i ] . endswith ( "p" ) ) { taglongcode |= parseaccentability ( codes , i ) ; i ++ ; } if ( i < codes . length ) { taglongcode |= parsepostprepositionality ( codes , i ) ; i ++ ; } } asserttrue ( codes . length == i , "incorrect extra tag data: " + tagcode ) ; } else if ( "num" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; if ( codes . length > 4 ) { taglongcode |= parseaccommodability ( codes , 4 ) ; } } else if ( "adj" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; taglongcode |= parsedegree ( codes , 4 ) ; asserttrue ( codes . length == 5 , "incorrect extra tag data: " + tagcode ) ; } else if ( "pact" . equals ( partofspeech ) || "ppas" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsecase ( codes , 2 ) ; taglongcode |= parsegender ( codes , 3 ) ; taglongcode |= parseaspect ( codes , 4 ) ; taglongcode |= parsenegation ( codes , 5 ) ; asserttrue ( codes . length == 6 , "incorrect extra tag data: " + tagcode ) ; } else if ( "bedzie" . equals ( partofspeech ) || "fin" . equals ( partofspeech ) || "impt" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parseperson ( codes , 2 ) ; taglongcode |= parseaspect ( codes , 3 ) ; asserttrue ( codes . length == 4 , "incorrect extra tag data: " + tagcode ) ; } else if ( "winien" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsegender ( codes , 2 ) ; taglongcode |= parseaspect ( codes , 3 ) ; asserttrue ( codes . length == 4 , "incorrect extra tag data: " + tagcode ) ; } else if ( "praet" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parsegender ( codes , 2 ) ; taglongcode |= parseaspect ( codes , 3 ) ; int i = 4 ; if ( codes . length > 4 ) { taglongcode |= parseagglutination ( codes , i ) ; i ++ ; } asserttrue ( codes . length == i , "incorrect extra tag data: " + tagcode ) ; } else if ( "aglt" . equals ( partofspeech ) ) { taglongcode |= parsenumber ( codes , 1 ) ; taglongcode |= parseperson ( codes , 2 ) ; taglongcode |= parseaspect ( codes , 3 ) ; taglongcode |= parsevocality ( codes , 4 ) ; asserttrue ( codes . length == 5 , "incorrect extra tag data: " + tagcode ) ; } else { throw new tagparserexception ( "unknown pos tag: '" + tagcode + "'" ) ; } long poscode = ( long ) poscodes . get ( partofspeech ) ; taglongcode = taglongcode | poscode . longvalue ( ) ; this . tagcode = taglongcode ; }
tr	1	public static void main ( string args [ ] ) throws exception { systemparam param = new systemparam ( ) ; param . setserver_ip ( "10.1.30.5" ) ; param . setserver_por ( "22" ) ; param . setuser_name ( "weblogic" ) ; param . setpassword ( "weblogic" ) ; xmlencoder encoder = new xmlencoder ( new bufferedoutputstream ( new fileoutputstream ( "sample.xml" ) ) ) ; encoder . writeobject ( param ) ; encoder . close ( ) ; system . out . println ( param ) ; xmldecoder decoder = new xmldecoder ( new bufferedinputstream ( new fileinputstream ( "sample.xml" ) ) ) ; systemparam sample2 = ( systemparam ) decoder . readobject ( ) ; decoder . close ( ) ; system . out . println ( sample2 ) ; }
tr	6	private list < queryitem > parse ( string [ ] tokens ) { arraylist < queryitem > items = new arraylist < queryitem > ( ) ; queryoperator nextop = queryoperator . and ; for ( string token : tokens ) { token = token . tolowercase ( ) ; if ( token . charat ( 0 ) == '{' ) { token = token . substring ( 1 , token . length ( ) - 1 ) ; items . get ( items . size ( ) - 1 ) . setatleast ( integer . parseint ( token ) ) ; } else if ( token . equals ( "and" ) ) { nextop = queryoperator . and ; } else if ( token . equals ( "or" ) ) { nextop = queryoperator . or ; } else if ( token . equals ( "not" ) ) { nextop = queryoperator . not ; } else { queryitem item = new queryitem ( token , nextop ) ; items . add ( item ) ; nextop = queryoperator . and ; } } return items ; }
tr	6	public static list < tconnection > getconnectionfromstring ( string input ) { list < tconnection > returnconnections = new arraylist < tconnection > ( ) ; tconnection connectionone = null ; tconnection connectiontwo = null ; if ( input . matches ( connection_pattern ) ) { string [ ] parts = input . split ( "-" ) ; connectionone = new tconnection ( ) ; connectiontwo = new tconnection ( ) ; if ( parts != null && parts . length == 3 ) { tnode one = new tnode ( parts [ 0 ] ) ; connectionone . settnodeone ( one ) ; try { int weight = integer . parseint ( parts [ 1 ] ) ; connectionone . setweight ( weight ) ; connectiontwo . setweight ( weight ) ; } catch ( numberformatexception e ) { system . out . println ( e . getmessage ( ) ) ; connectionone = null ; connectiontwo = null ; } tnode two = new tnode ( parts [ 2 ] ) ; connectiontwo . settnodeone ( two ) ; connectiontwo . settnodetwo ( one . gettitle ( ) ) ; connectionone . settnodetwo ( two . gettitle ( ) ) ; one . addconnection ( connectionone ) ; two . addconnection ( connectiontwo ) ; returnconnections . add ( connectionone ) ; returnconnections . add ( connectiontwo ) ; } } return returnconnections ; }
tr	8	private boolean time ( commandsender sender , string [ ] args ) { if ( args . length < 4 ) { sender . sendmessage ( chatcolor . red + "usage: time <add/sub/set> <time> <sec/min/hour/day/week/month>" ) ; return true ; } long time = plugin . parsetimespec ( args [ 2 ] , args [ 3 ] ) ; if ( time == 0 ) { sender . sendmessage ( chatcolor . red + "invalid time format" ) ; return true ; } boolean add = args [ 1 ] . equalsignorecase ( "add" ) , set = args [ 1 ] . equalsignorecase ( "set" ) , - = args [ 1 ] . equalsignorecase ( "sub" ) ; if ( add || set || - ) { if ( ban . endtime == 0 ) { ban . endtime = ban . time ; } if ( add ) { ban . endtime += time ; } else if ( set ) { ban . endtime = ban . time + time ; } else if ( - ) { ban . endtime -= time ; } date date = new date ( ) ; date . settime ( ban . endtime * 1000 ) ; sender . sendmessage ( chatcolor . yellow + "new time: " + chatcolor . white + date . tostring ( ) ) ; return true ; } return false ; }
tr	10	public int largestrectangleareatle ( int [ ] height ) { int [ ] area = new int [ height . length ] ; int [ ] area2 = new int [ height . length ] ; for ( int i = 0 ; i < height . length ; i ++ ) { int left = height [ i ] ; int unit = 1 ; for ( int j = i + 1 ; j < height . length ; j ++ ) { if ( height [ j ] >= left ) { unit ++ ; if ( j == height . length - 1 ) { area [ i ] = unit * left ; } } else { area [ i ] = unit * left ; break ; } } } for ( int i = height . length - 1 ; i >= 0 ; i -- ) { int right = height [ i ] ; int unit = 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( height [ j ] >= right ) { unit ++ ; if ( j == 0 ) { area2 [ i ] = unit * right ; } } else { area2 [ i ] = unit * right ; break ; } } } int max = 0 ; for ( int i = 0 ; i < height . length ; i ++ ) { int larger = math . max ( area [ i ] , area2 [ i ] ) ; if ( larger > max ) max = larger ; } return max ; }
tr	3	public board ( ) { board = new piece [ 6 ] [ 6 ] ; graveyard = new arraylist < piece > ( ) ; piece temp ; for ( int count = 0 ; count < 6 ; count ++ ) { temp = new piece ( colorenum . black , pieceenum . pawn ) ; board [ 1 ] [ count ] = temp ; temp = new piece ( colorenum . white , pieceenum . pawn ) ; board [ 4 ] [ count ] = temp ; } temp = new piece ( colorenum . black , pieceenum . knight ) ; board [ 0 ] [ 1 ] = temp ; board [ 0 ] [ 4 ] = temp ; temp = new piece ( colorenum . white , pieceenum . knight ) ; board [ 5 ] [ 1 ] = temp ; board [ 5 ] [ 4 ] = temp ; }
tr	4	private void decodeonestream ( file wavefile , samplerate samplerate , channels channels , rtpstream stream ) throws exception { opusdecoder decoder ; if ( channels == null ) decoder = new opusdecoder ( stream . getsamplerate ( ) , stream . getpackets ( ) [ 0 ] . getpayload ( ) ) ; else decoder = new opusdecoder ( samplerate , channels ) ; try { randomaccessfile f = new randomaccessfile ( wavefile , "rw" ) ; f . setlength ( 0 ) ; littleendiandataoutput outstream = new littleendiandataoutput ( f ) ; try { writewaveheader ( decoder , outstream , 44 ) ; if ( f . length ( ) != 44 ) throw new illegalstateexception ( "wave header should be 44 bytes<litcomma> not " + f . length ( ) ) ; convert ( decoder , stream , outstream ) ; long filesize = f . length ( ) ; f . seek ( 0 ) ; writewaveheader ( decoder , outstream , filesize ) ; } finally { f . close ( ) ; } } finally { decoder . destroy ( ) ; } }
tr	10	@ override public object intercept ( invocation invocation ) throws throwable { mappedstatement ms = ( mappedstatement ) invocation . getargs ( ) [ 0 ] ; object parameterobject = invocation . getargs ( ) [ 1 ] ; final configuration configuration = ms . getconfiguration ( ) ; final statementhandler handler = configuration . newstatementhandler ( ( executor ) invocation . gettarget ( ) , ms , parameterobject , rowbounds . default , null , null ) ; final boundsql boundsql = handler . getboundsql ( ) ; final string sql = boundsql . getsql ( ) ; list < string > splitted = splitter . split ( sql ) ; int rc = 0 ; list < parametermapping > fullparametermappings = new arraylist < parametermapping > ( boundsql . getparametermappings ( ) ) ; for ( string sqlpart : splitted ) { if ( skipemptystatements && sqlpart . length ( ) == 0 ) { continue ; } int numparams = 0 ; for ( int index = sqlpart . indexof ( '?' ) ; index >= 0 ; index = sqlpart . indexof ( '?' , index + 1 ) ) { numparams ++ ; } mappedstatement substatement = substatements . get ( ms ) ; if ( substatement == null ) { substatement = new mappedstatement . builder ( ms . getconfiguration ( ) , ms . getid ( ) , new switchingsqlsource ( configuration ) , ms . getsqlcommandtype ( ) ) . cache ( ms . getcache ( ) ) . databaseid ( ms . getdatabaseid ( ) ) . fetchsize ( ms . getfetchsize ( ) ) . timeout ( ms . gettimeout ( ) ) . flushcacherequired ( ms . isflushcacherequired ( ) ) . usecache ( ms . isusecache ( ) ) . build ( ) ; substatements . put ( ms , substatement ) ; } list < parametermapping > subparametermappings = fullparametermappings . sublist ( 0 , numparams ) ; ( ( switchingsqlsource ) substatement . getsqlsource ( ) ) . switchparams ( sqlpart , boundsql , new arraylist < parametermapping > ( subparametermappings ) ) ; subparametermappings . clear ( ) ; int subrc = ( integer ) invocation . getmethod ( ) . invoke ( invocation . gettarget ( ) , substatement , parameterobject ) ; if ( rc >= 0 ) { rc = subrc < 0 ? subrc : rc + subrc ; } } return rc ; }
tr	6	public void addnode ( tnode toadd ) { if ( toadd != null ) { list < string > titles = new arraylist < string > ( ) ; tnode exists = null ; for ( tnode n : nodes ) { titles . add ( n . gettitle ( ) ) ; if ( n . gettitle ( ) . equals ( toadd . gettitle ( ) ) ) { exists = n ; } } if ( ! titles . contains ( toadd . gettitle ( ) ) ) { nodes . add ( toadd ) ; } else { list < tconnection > connects = toadd . getconnections ( ) ; for ( tconnection con : connects ) { exists . addconnection ( con ) ; } } } }
tr	8	@ override public void run ( ) { client1 . println ( session_created_message ) ; client2 . println ( session_created_message ) ; client1 . println ( opponent_info_message + client2 . getnick ( ) ) ; client2 . println ( opponent_info_message + client1 . getnick ( ) ) ; isongame = true ; while ( isongame ) { turn ( client1 , client2 ) ; turn ( client2 , client1 ) ; } client1 . println ( game_over_message ) ; client2 . println ( game_over_message ) ; boolean newgamestarted = false ; boolean want1 = false ; boolean want2 = false ; long starttime = system . currenttimemillis ( ) ; while ( system . currenttimemillis ( ) - starttime < 30000 ) { if ( want1 && want2 ) { new game ( client2 , client1 ) . start ( ) ; newgamestarted = true ; break ; } if ( client1 . isinputstreamready ( ) ) { string line = client1 . readline ( ) ; if ( ( line == null ) || ( line . equals ( farewell_message ) ) ) { if ( want2 ) { client2 . println ( not_again_message ) ; } break ; } if ( line . equals ( again_message ) ) { if ( ! want1 ) { want1 = true ; client2 . println ( want_again_message ) ; } } } if ( client2 . isinputstreamready ( ) ) { string line = client2 . readline ( ) ; if ( ( line == null ) || ( line . equals ( farewell_message ) ) ) { if ( want1 ) { client1 . println ( not_again_message ) ; } break ; } if ( line . equals ( again_message ) ) { if ( ! want2 ) { want2 = true ; client1 . println ( want_again_message ) ; } } } } if ( ! newgamestarted ) { client1 . println ( session_closed_message ) ; client2 . println ( session_closed_message ) ; client1 . disconnect ( ) ; client2 . disconnect ( ) ; } }
tr	4	@ eventhandler ( priority = eventpriority . high ) public void onplayerlogin ( playerloginevent event ) { player player = event . getplayer ( ) ; for ( int i = 0 ; i < plugin . bannedplayers . size ( ) ; i ++ ) { editban e = plugin . bannedplayers . get ( i ) ; if ( e . name . equals ( player . getname ( ) . tolowercase ( ) ) ) { long temptime = e . endtime ; boolean tempban = false ; if ( temptime > 0 ) { long now = system . currenttimemillis ( ) / 1000 ; long diff = temptime - now ; if ( diff <= 0 ) { plugin . bannedplayers . remove ( i ) ; return ; } tempban = true ; } date date = new date ( ) ; date . settime ( temptime * 1000 ) ; string kickermsg = null ; if ( tempban ) { kickermsg = plugin . formatmessage ( plugin . getconfig ( ) . getstring ( "messages.logintempban" ) ) ; kickermsg = kickermsg . replaceall ( "%time%" , date . tostring ( ) ) ; kickermsg = kickermsg . replaceall ( "%reason%" , e . reason ) ; } else if ( e . type == editban . ban ) { kickermsg = plugin . formatmessage ( plugin . getconfig ( ) . getstring ( "messages.loginban" ) ) ; kickermsg = kickermsg . replaceall ( "%time%" , date . tostring ( ) ) ; kickermsg = kickermsg . replaceall ( "%reason%" , e . reason ) ; } if ( kickermsg != null ) { event . disallow ( playerloginevent . result . kick_other , kickermsg ) ; return ; } } } }
tr	5	private void parseparameterdefinitions ( final string [ ] paramdefinitions ) { int paramindex = 0 ; parameternames = new string [ paramdefinitions . length ] ; allpossibleparametervalues = new double [ paramdefinitions . length ] [ ] ; for ( final string parameterdefinition : paramdefinitions ) { final string [ ] tokens = parameterdefinition . split ( "[=<litcomma>]" ) ; assert tokens . length > 3 : "parameter definition must be of the form name=value1<litcomma>value2<litcomma>..." ; parameternames [ paramindex ] = tokens [ 0 ] ; final doublelist paramvalues = new doublearraylist ( ) ; for ( int valueindex = 1 ; valueindex < tokens . length ; valueindex ++ ) { paramvalues . add ( double . parsedouble ( tokens [ valueindex ] ) ) ; } allpossibleparametervalues [ paramindex ] = paramvalues . todoublearray ( ) ; paramindex ++ ; } }
tr	6	public static ttree gettreefromconsole ( ) { ttree tree = new ttree ( ) ; system . out . println ( "please input connections in this tree in the following format:\\n" + ": title-numericalweight-title2 or a-2-b\\ndo not add any spaces or numbers (other than the weight)." + "\\ntype 'stop' when you are finished entering connections" ) ; scanner scan = new scanner ( system . in ) ; string input = "" ; while ( ! input . equalsignorecase ( "stop" ) ) { input = scan . nextline ( ) ; list < tconnection > connect = connectioninput . getconnectionfromstring ( input ) ; for ( tconnection c : connect ) { tree . addnode ( c . gettnodeone ( ) ) ; } } return tree ; }
tr	6	public static ontmodel createontmodel ( url url , map < string , string > contentitems , dataset dataset ) { rdfbuilder . contentitems = contentitems ; ontmodel = dataset == null ? modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem ) : modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem , dataset . getdefaultmodel ( ) ) ; ontmodel . addsubmodel ( modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem ) . read ( "http://erlangen-crm.org/onto/ecrm/ecrm_current.owl" ) ) ; individual image = createinformationcarrier ( url ) ; individual endurant = createendurant ( image ) ; createspatials ( endurant ) ; createtemporals ( endurant ) ; return ontmodel ; }
tr	5	public static hashmap < long , double > readlocationentropyidbased ( int samplerate ) { if ( locationentropy . isempty ( ) ) { try { bufferedreader fin ; if ( samplerate <= 100 ) { fin = new bufferedreader ( new filereader ( string . format ( "res/locationentropy-%ds.txt" , samplerate ) ) ) ; system . out . println ( string . format ( "file locationentropy-%ds.txt found!" , samplerate ) ) ; } else { fin = new bufferedreader ( new filereader ( "res/locationentropy.txt" ) ) ; system . out . println ( "file locationentropy.txt found!" ) ; } string l = null ; while ( ( l = fin . readline ( ) ) != null ) { string [ ] ls = l . split ( "\\\\s+" ) ; long loc = long . parselong ( ls [ 0 ] ) ; double entropy = double . parsedouble ( ls [ 1 ] ) ; locationentropy . put ( loc , entropy ) ; } fin . close ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( "no location entropy file found. generate new one ..." ) ; writelocationentropy ( true , samplerate ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( string . format ( "location entropy size %d." , locationentropy . size ( ) ) ) ; } return locationentropy ; }
tr	9	@ override public double evaluate ( recommenderbuilder recommenderbuilder , datamodelbuilder datamodelbuilder , datamodel datamodel , double trainingpercentage , double evaluationpercentage ) throws tasteexception { preconditions . checkargument ( recommenderbuilder != null , "recommenderbuilder is null" ) ; preconditions . checkargument ( datamodel != null , "datamodel is null" ) ; preconditions . checkargument ( trainingpercentage >= 0.0 && trainingpercentage <= 1.0 , "invalid trainingpercentage: " + trainingpercentage ) ; preconditions . checkargument ( evaluationpercentage >= 0.0 && evaluationpercentage <= 1.0 , "invalid evaluationpercentage: " + evaluationpercentage ) ; log . info ( "beginning evaluation using {} of {}" , trainingpercentage , datamodel ) ; int numusers = datamodel . getnumusers ( ) ; fastbyidmap < preferencearray > trainingusers = new fastbyidmap < preferencearray > ( 1 + ( int ) ( evaluationpercentage * numusers ) ) ; fastbyidmap < preferencearray > testuserprefs = new fastbyidmap < preferencearray > ( 1 + ( int ) ( evaluationpercentage * numusers ) ) ; longprimitiveiterator it = datamodel . getuserids ( ) ; while ( it . hasnext ( ) ) { long userid = it . nextlong ( ) ; if ( random . nextdouble ( ) < evaluationpercentage ) { processoneuser ( trainingpercentage , trainingusers , testuserprefs , userid , datamodel ) ; } else { preferencearray trainingprefs = datamodel . getpreferencesfromuser ( userid ) ; trainingusers . put ( userid , trainingprefs ) ; } } datamodel trainingmodel = datamodelbuilder == null ? new genericdatamodel ( trainingusers ) : datamodelbuilder . builddatamodel ( trainingusers ) ; recommender recommender = recommenderbuilder . buildrecommender ( trainingmodel ) ; double result = getevaluation ( testuserprefs , recommender ) ; log . info ( "evaluation result: {}" , result ) ; return result ; }
tr	9	public int candy ( int [ ] ratings ) { int [ ] candy = new int [ ratings . length ] ; int res = 0 ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < ratings . length ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } for ( int i = ratings . length - 2 ; i >= 0 ; i -- ) { if ( ratings [ i ] > ratings [ i + 1 ] ) { candy [ i ] = math . max ( candy [ i ] , candy [ i + 1 ] + 1 ) ; } } for ( int i = 1 ; i < ratings . length ; i ++ ) { res += candy [ i ] ; } return res ; }
tr	1	public user finduserbyusername ( final string username ) { string sql = "select * from t_user where user_name=?" ; final user user = new user ( ) ; jdbctemplate . query ( sql , new object [ ] { username } , new rowcallbackhandler ( ) { public void processrow ( resultset rs ) { try { final int userid = rs . getint ( "user_id" ) ; final int credits = rs . getint ( "credits" ) ; user . setuserid ( userid ) ; user . setusername ( username ) ; user . setcredits ( credits ) ; } catch ( sqlexception e ) { system . out . println ( e . getmessage ( ) ) ; } } } ) ; return user ; }
tr	5	public static void end ( ) { if ( enemy . kills == 10 && player . deaths <= 10 ) { player . y = - 32 ; enemy . y = 0 ; glbegin ( gl_quads ) ; glcolor3d ( 0.7 , 0.8 , 0.9 ) ; glvertex2d ( 0 , 0 ) ; glvertex2d ( 640 , 0 ) ; glcolor3d ( 0.5 , 0.6 , 0.8 ) ; glvertex2d ( 640 , 480 ) ; glvertex2d ( 0 , 480 ) ; glend ( ) ; glcolor3d ( 0.9 , 0 , 0 ) ; drawstring . drawstring ( "you win!" , 320 , 240 ) ; drawstring . drawstring ( "press space to play again!" , 320 , 220 ) ; if ( keyboard . iskeydown ( keyboard . key_space ) ) { enemy . kills = 0 ; enemy . y = 32 ; player . deaths = 0 ; player . y = 32 ; game . killcommand = 1 ; } } else if ( player . deaths == 10 ) { player . y = - 32 ; enemy . y = 0 ; glbegin ( gl_quads ) ; glcolor3d ( 0.7 , 0.8 , 0.9 ) ; glvertex2d ( 0 , 0 ) ; glvertex2d ( 640 , 0 ) ; glcolor3d ( 0.5 , 0.6 , 0.8 ) ; glvertex2d ( 640 , 480 ) ; glvertex2d ( 0 , 480 ) ; glend ( ) ; glcolor3d ( 0.9 , 0 , 0 ) ; drawstring . drawstring ( "you lose!" , 320 , 240 ) ; drawstring . drawstring ( "press space to try again!" , 320 , 220 ) ; if ( keyboard . iskeydown ( keyboard . key_space ) ) { enemy . kills = 0 ; enemy . y = 32 ; player . deaths = 0 ; player . y = 32 ; game . killcommand = 1 ; } } }
tr	1	public void updatetext ( ) { gtext textname = new gtext ( name , gposition . top ) ; integer num ; num = tasknumber ; gtext texttasknum = new gtext ( num . tostring ( ) , gposition . top ) ; num = numberofdays ; gtext textnumofdays = new gtext ( num . tostring ( ) , gposition . top ) ; gtext textstart = new gtext ( startdate , gposition . top ) ; gtext textend = new gtext ( enddate , gposition . top ) ; square . addtext ( textname ) ; square . addtext ( texttasknum ) ; square . addtext ( textnumofdays ) ; square . addtext ( textstart ) ; square . addtext ( textend ) ; }
tr	6	public static void transmittoken ( ) throws ioexception { int indexi = - 1 ; int indexj = - 1 ; arraylist < quaddata > x = new arraylist < > ( ) ; int timestamp = 40000 ; int elec = - 1 ; string token = "tt" ; x = addtosendlist ( x ) ; timestamp = 40000 ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) { if ( x . get ( i ) . timestamp < timestamp ) { indexi = x . get ( i ) . indexi ; indexj = x . get ( i ) . indexj ; elec = x . get ( i ) . elec ; timestamp = x . get ( i ) . timestamp ; } } if ( ! x . isempty ( ) ) { manipulatelud ( ) ; logicalclock += 1 ; removefromreqarray ( indexi , indexj ) ; token = copylud ( token ) ; token = token . substring ( 0 , token . length ( ) - 1 ) ; token += ";" ; token += elec + ":" + getglobalcounter ( ) + ":0" ; system . out . println ( "indexi:" + ( indexi + 1 ) ) ; sctpclient . sendmessage ( mainclass . clientsocket . get ( ( indexi + 1 ) ) , token ) ; } else { system . out . println ( "oops...index -1" ) ; } }
tr	1	@ override public int insertcustomer ( site site ) { connection con = conn . getconnection ( true ) ; try { preparedstatement ps = con . preparestatement ( "insert into public.site values (?<litcomma>?)" ) ; ps . setint ( 1 , site . getid ( ) ) ; ps . setstring ( 2 , site . getsitename ( ) ) ; ps . execute ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { con . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return 0 ; }
tr	5	public static void main ( final string [ ] args ) { embfilename = "output.txt" ; password = "abc123" ; try { if ( args . length < 1 ) { usage ( ) ; return ; } for ( int i = 0 ; i < args . length ; i ++ ) { if ( ! args [ i ] . startswith ( "-" ) ) { if ( ! args [ i ] . endswith ( ".jpg" ) ) { usage ( ) ; return ; } f = new file ( args [ i ] ) ; continue ; } if ( args . length < i + 1 ) { system . out . println ( "missing parameter for switch " + args [ i ] ) ; usage ( ) ; return ; } if ( args [ i ] . equals ( "-e" ) ) { embfilename = args [ i + 1 ] ; } else if ( args [ i ] . equals ( "-p" ) ) { password = args [ i + 1 ] ; } else { system . out . println ( "unknown switch " + args [ i ] + " ignored." ) ; } i ++ ; } final fileinputstream fis = new fileinputstream ( f ) ; fos = new fileoutputstream ( new file ( embfilename ) ) ; extract ( fis , ( int ) f . length ( ) , fos , password ) ; } catch ( final exception e ) { e . printstacktrace ( ) ; } }
tr	8	public string addbinary ( string a , string b ) { int sizea = a . length ( ) ; int sizeb = b . length ( ) ; if ( sizea == 0 ) return b ; if ( sizeb == 0 ) return a ; string res = "" ; int r = 0 ; int carryover = 0 ; for ( int i = sizea - 1 , j = sizeb - 1 ; i >= 0 || j >= 0 ; ) { char ca = '0' ; char cb = '0' ; if ( i >= 0 ) ca = a . charat ( i ) ; if ( j >= 0 ) cb = b . charat ( j ) ; if ( ca == '0' && cb == '0' ) { r = carryover ; carryover = 0 ; } else if ( ( ca == '0' && cb == '1' ) || ( ca == '1' && cb == '0' ) ) { if ( carryover == 0 ) { r = 1 ; carryover = 0 ; } else { r = 0 ; carryover = 1 ; } } else if ( ca == '1' && cb == '1' ) { r = carryover ; carryover = 1 ; } else { return "" ; } res = string . valueof ( r ) + res ; i -- ; j -- ; } if ( carryover == 1 ) res = "1" + res ; return res ; }
tr	4	public static void frequency ( double frequency , double min , double max ) throws illegalargumentexception { if ( frequency < min || frequency > max ) { stringbuilder e = new stringbuilder ( 80 ) ; e . append ( "invalid frequency value! " ) ; e . append ( "it must be a positive double between " ) ; e . append ( string . format ( locale . english , "%1.2f" , min ) ) ; e . append ( " and " ) ; e . append ( string . format ( locale . english , "%1.2f" , max ) ) ; e . append ( "." ) ; throw new illegalargumentexception ( e . tostring ( ) ) ; } }
tr	7	protected void loadtrophyconfig ( commandsender sender ) { if ( ! configloaded ) { sender . sendmessage ( chatcolor . gold + log_header + " configuration loaded." ) ; } else { reloadconfig ( ) ; sender . sendmessage ( chatcolor . gold + log_header + " configuration reloaded." ) ; } configloaded = true ; debugenabled = getconfig ( ) . getboolean ( "debug-enabled" ) ; logdebug ( "debug enabled" ) ; cooldown = getconfig ( ) . getlong ( "right-click-cooldown" , 40l ) ; logdebug ( "cooldown: " + cooldown ) ; drop_chances . put ( entitytype . player . tostring ( ) , getconfig ( ) . getint ( "drop-chance" ) ) ; logdebug ( "chance to drop head: " + drop_chances . get ( entitytype . player . tostring ( ) ) + "%" ) ; playerskin = getconfig ( ) . getboolean ( "player-skin" ) ; logdebug ( "player skins: " + playerskin ) ; nontropyheadmessage = chatcolor . translatealternatecolorcodes ( '&' , ( getconfig ( ) . getstring ( "non-th-message" , "&ethat is a custom head!" ) ) ) ; logdebug ( "non th message: " + nontropyheadmessage ) ; list < string > pitems = getconfig ( ) . getstringlist ( "items-required" ) ; if ( pitems . isempty ( ) ) { pitems . add ( "any" ) ; pitems . add ( "276" ) ; } items_required . put ( entitytype . player . tostring ( ) , pitems ) ; logdebug ( "player items required: " + items_required . get ( entitytype . player . tostring ( ) ) ) ; for ( string monstername : getconfig ( ) . getconfigurationsection ( "custom-heads" ) . getkeys ( false ) ) { logdebug ( "entity name: " + monstername ) ; string entitytypename ; if ( monstername . equalsignorecase ( "cavespider" ) ) { entitytypename = "cave_spider" ; } else if ( monstername . equalsignorecase ( "golem" ) || monstername . equalsignorecase ( "irongolem" ) ) { entitytypename = "iron_golem" ; } else if ( monstername . equalsignorecase ( "mushroomcow" ) || monstername . equalsignorecase ( "mooshroom" ) ) { entitytypename = "mushroom_cow" ; } else if ( monstername . equalsignorecase ( "pigzombie" ) || monstername . equalsignorecase ( "zombiepigman" ) ) { entitytypename = "pig_zombie" ; } else if ( monstername . equalsignorecase ( "lavaslime" ) || monstername . equalsignorecase ( "magmacube" ) ) { entitytypename = "magma_cube" ; } else if ( monstername . equalsignorecase ( "enderdragon" ) || monstername . equalsignorecase ( "dragon" ) ) { entitytypename = "ender_dragon" ; } else if ( monstername . equalsignorecase ( "elderguardian" ) ) { entitytypename = "elder_guardian" ; } else if ( monstername . equalsignorecase ( "snowman" ) || monstername . equalsignorecase ( "snowgolem" ) ) { entitytypename = "snowman" ; } else if ( monstername . equalsignorecase ( "witherskeleton" ) ) { entitytypename = "wither_skeleton" ; } else { entitytypename = monstername ; } logdebug ( "  type: " + entitytypename ) ; int dropchance = getconfig ( ) . getint ( "custom-heads." + monstername + ".drop-chance" , 0 ) ; list < string > items = getconfig ( ) . getstringlist ( "custom-heads." + monstername + ".items-required" ) ; if ( items . isempty ( ) ) { items . add ( "any" ) ; items . add ( "276" ) ; } string skin = getconfig ( ) . getstring ( "custom-heads." + monstername + ".skin" , "mhf_" + monstername ) ; string message = getconfig ( ) . getstring ( "custom-heads." + monstername + ".message" , "&ethis head once belonged to a &e" + monstername + "&e." ) ; drop_chances . put ( entitytypename , dropchance ) ; logdebug ( "  chance to drop head: " + drop_chances . get ( entitytypename ) + "%" ) ; items_required . put ( entitytypename , items ) ; logdebug ( "  items required: " + items_required . get ( entitytypename ) ) ; custom_skins . put ( entitytypename , skin ) ; logdebug ( "  skin: " + custom_skins . get ( entitytypename ) ) ; skull_messages . put ( entitytypename , message ) ; logdebug ( "  message: " + skull_messages . get ( entitytypename ) ) ; skull_names . put ( entitytypename , monstername ) ; logdebug ( "  name: " + skull_names . get ( monstername ) ) ; } skull_messages . put ( entitytype . player . tostring ( ) , getconfig ( ) . getstring ( "message" ) ) ; renameenabled = getconfig ( ) . getboolean ( "rename-enabled" ) ; if ( renameenabled ) { try { renameitem = material . getmaterial ( getconfig ( ) . getint ( "rename-item" ) ) ; } catch ( exception e ) { renameitem = material . paper ; } logdebug ( "rename recipe enabled: head + " + renameitem . tostring ( ) ) ; } death_types . addall ( getconfig ( ) . getstringlist ( "death-types" ) ) ; info_blacklist . clear ( ) ; for ( string name : getconfig ( ) . getstringlist ( "info-blacklist" ) ) { info_blacklist . add ( name . tolowercase ( ) ) ; logdebug ( "blacklisting: " + name . tolowercase ( ) ) ; } }
tr	5	public static string tostring ( itemstack [ ] inv ) { list < string > result = new arraylist < string > ( ) ; list < configurationserializable > items = new arraylist < configurationserializable > ( ) ; items . addall ( arrays . aslist ( inv ) ) ; for ( configurationserializable cs : items ) { if ( cs == null ) { result . add ( "null" ) ; } else { result . add ( new jsonobject ( serialize ( cs ) ) . tostring ( ) ) ; } } jsonarray json_array = new jsonarray ( result ) ; return json_array . tostring ( ) ; }
tr	10	private void computescalarproducts ( int npoints , double [ ] [ ] s , double [ ] q ) { double rms = 0. ; for ( int i = 1 ; i < npoints ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { double dij = s [ i ] [ j ] * s [ i ] [ j ] ; rms += dij + dij ; q [ i ] += dij ; q [ j ] += dij ; } } rms = rms / ( npoints * npoints ) ; double dsm ; for ( int i = 0 ; i < npoints ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( i == j ) dsm = 0. ; else dsm = s [ i ] [ j ] * s [ i ] [ j ] ; s [ i ] [ j ] = ( ( q [ i ] + q [ j ] ) / npoints - rms - dsm ) / 2. ; s [ j ] [ i ] = s [ i ] [ j ] ; } } }
tr	6	public static void readnodelist ( string filepath ) throws ioexception { bufferedreader br = null ; string scurrentline ; string [ ] output ; arraylist < tripletdata > result = new arraylist < > ( ) ; br = new bufferedreader ( new filereader ( filepath ) ) ; system . out . println ( "here" ) ; while ( ! ( scurrentline = br . readline ( ) ) . equals ( "end" ) ) { tripletdata newentry = new tripletdata ( ) ; if ( scurrentline . equals ( "" ) ) { } else { output = scurrentline . split ( "\\\\s+" ) ; if ( integer . parseint ( output [ 0 ] ) == mynodenumber ) { myhostaddress = output [ 1 ] ; myportnumber = integer . parseint ( output [ 2 ] ) ; system . out . println ( "hostname:" + myhostaddress + ";" + "myportnumber:" + myportnumber ) ; } else { newentry . hostname = integer . parseint ( output [ 0 ] ) ; newentry . ipaddress = output [ 1 ] ; newentry . portno = integer . parseint ( output [ 2 ] ) ; nodelist . add ( newentry ) ; } } } br . close ( ) ; }
tr	4	private void paintmenu ( graphics g ) { string menustartname = "start" ; rectangle2d menustartbounds = g . getfontmetrics ( ) . getstringbounds ( menustartname , g ) ; string menusettingsname = "settings" ; rectangle2d menusettingsbounds = g . getfontmetrics ( ) . getstringbounds ( menusettingsname , g ) ; string menuexitname = "quit" ; rectangle2d menuexitbounds = g . getfontmetrics ( ) . getstringbounds ( menuexitname , g ) ; int padding = 30 ; int middley = ( int ) ( height / 2 ) ; g . setcolor ( color . white ) ; g . setfont ( new font ( "helvetica" , font . plain , 24 ) ) ; int startx = ( int ) ( ( width / 2 ) - ( menustartbounds . getwidth ( ) ) ) ; int starty = middley - padding - ( int ) ( menustartbounds . getheight ( ) ) ; int settingsx = ( int ) ( ( width / 2 ) - ( menusettingsbounds . getwidth ( ) ) ) ; int settingsy = middley - ( int ) ( menusettingsbounds . getheight ( ) / 2 ) ; int exitx = ( int ) ( ( width / 2 ) - ( menuexitbounds . getwidth ( ) ) ) ; int exity = middley + padding ; g . drawstring ( menustartname , startx , starty ) ; g . drawstring ( menusettingsname , settingsx , settingsy ) ; g . drawstring ( menuexitname , exitx , exity ) ; if ( selectedmenuitem == 0 ) { g . drawline ( startx , starty + 5 , startx + ( int ) menustartbounds . getwidth ( ) * 2 , starty + 5 ) ; } else if ( selectedmenuitem == 1 ) { g . drawline ( settingsx , settingsy + 5 , settingsx + ( int ) menusettingsbounds . getwidth ( ) * 2 , settingsy + 5 ) ; } else if ( selectedmenuitem == 2 ) { g . drawline ( exitx , exity + 5 , exitx + ( int ) menuexitbounds . getwidth ( ) * 2 , exity + 5 ) ; } }
tr	2	public static message getservermessage ( string jsonmessage ) { jsonparser parser = new jsonparser ( ) ; jsonobject obj = parser . parse ( jsonmessage ) . getasjsonobject ( ) ; string type = gson . fromjson ( obj . get ( "type" ) , string . class ) ; if ( type . equals ( "greetings_program" ) ) { return gson . fromjson ( jsonmessage , greetingmessage . class ) ; } else if ( type . equals ( "request" ) ) { return gson . fromjson ( jsonmessage , movemessage . class ) ; } else if ( type . equals ( "result" ) ) { return gson . fromjson ( jsonmessage , resultmessage . class ) ; } else if ( type . equals ( "error" ) ) { return gson . fromjson ( jsonmessage , errormessage . class ) ; } else { errormessage err = new errormessage ( ) ; err . message = "unknown response type [" + type + "] from server" ; return err ; } }
tr	7	public int maxarea ( int [ ] height ) { if ( height . length <= 1 ) return 0 ; int left = 0 ; int right = height . length - 1 ; int max = 0 ; while ( left < right ) { int t = math . min ( height [ left ] , height [ right ] ) ; max = math . max ( max , t * ( right - left ) ) ; if ( height [ left ] <= height [ right ] ) left ++ ; else right -- ; } return max ; }
tr	2	public resource update ( stringbuilder sb , string ime ) { resource resu ; resu = c . dohvatiresurs ( ime ) ; resu . setsadrzaj ( dohvatisadrzajdatoteke ( ime ) ) ; system . out . println ( ime ) ; file file = new file ( nazivspremista + "\\\\" + ime ) ; if ( resu . getsadrzaj ( ) . tostring ( ) . equals ( sb . tostring ( ) ) ) { setchanged ( ) ; notifyobservers ( "stranica nije updaejtana" ) ; } else { setchanged ( ) ; notifyobservers ( "stranica updejtana" ) ; try { filewriter fw = new filewriter ( file . getabsolutefile ( ) ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; bw . write ( sb . tostring ( ) ) ; bw . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cacheimpl . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } return resu ; }
tr	3	public static void main ( string ... args ) throws exception { final int width = 80 * 19 ; final int height = 80 * 7 ; final bufferedimage image = new bufferedimage ( width , height , bufferedimage . type_4byte_abgr ) ; final graphics2d g = image . creategraphics ( ) ; combine ( g , 0 , loadall ( "fade" , 4 ) ) ; combine ( g , 80 , loadall ( "mask" , 11 ) ) ; combine ( g , 2 * 80 , loadall ( "shine" , 11 ) ) ; combine ( g , 3 * 80 , loadall ( "brow" , 8 ) ) ; combine ( g , 4 * 80 , loadall ( "eyes" , 13 ) ) ; combine ( g , 5 * 80 , loadall ( "pupils" , 11 ) ) ; combine ( g , 6 * 80 , loadall ( "mouth" , 19 ) ) ; imageio . write ( image , "png" , new file ( "./wavatar.png" ) ) ; }
tr	6	public void writetooutputfile ( list < string > filenames ) throws ioexception { if ( filenames != null ) { bufferedwriter out = null ; try { file output = new file ( outputfile ) ; if ( ! output . exists ( ) ) { output . createnewfile ( ) ; } out = new bufferedwriter ( new filewriter ( outputfile ) ) ; for ( string path : filenames ) { out . write ( path ) ; out . newline ( ) ; } out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } }
tr	10	public boolean onitemuse ( itemstack par1itemstack , entityplayer par2entityplayer , world par3world , int par4 , int par5 , int par6 , int par7 ) { int var8 = par3world . getblockid ( par4 , par5 , par6 ) ; if ( var8 == block . snow . blockid ) { par7 = 1 ; } else if ( var8 != block . vine . blockid && var8 != block . tallgrass . blockid && var8 != block . deadbush . blockid ) { if ( par7 == 0 ) { -- par5 ; } if ( par7 == 1 ) { ++ par5 ; } if ( par7 == 2 ) { -- par6 ; } if ( par7 == 3 ) { ++ par6 ; } if ( par7 == 4 ) { -- par4 ; } if ( par7 == 5 ) { ++ par4 ; } } if ( par1itemstack . stacksize == 0 ) { return false ; } else if ( ! par2entityplayer . canplayeredit ( par4 , par5 , par6 ) ) { return false ; } else if ( par5 == 255 && block . blockslist [ this . blockid ] . blockmaterial . issolid ( ) ) { return false ; } else if ( par3world . canblockbeplacedat ( this . blockid , par4 , par5 , par6 , false , par7 ) ) { block var9 = block . blockslist [ this . blockid ] ; if ( par3world . setblockandmetadatawithnotify ( par4 , par5 , par6 , this . blockid , this . getmetadata ( par1itemstack . getitemdamage ( ) ) ) ) { if ( par3world . getblockid ( par4 , par5 , par6 ) == this . blockid ) { block . blockslist [ this . blockid ] . onblockplaced ( par3world , par4 , par5 , par6 , par7 ) ; block . blockslist [ this . blockid ] . onblockplacedby ( par3world , par4 , par5 , par6 , par2entityplayer ) ; } par3world . playsoundeffect ( ( double ) ( ( float ) par4 + 0.5f ) , ( double ) ( ( float ) par5 + 0.5f ) , ( double ) ( ( float ) par6 + 0.5f ) , var9 . stepsound . getstepsound ( ) , ( var9 . stepsound . getvolume ( ) + 1.0f ) / 2.0f , var9 . stepsound . getpitch ( ) * 0.8f ) ; -- par1itemstack . stacksize ; } return true ; } else { return false ; } }
tr	2	public void loadlevel ( int thelevelnumber ) { currentlevelnumber = thelevelnumber ; resetvariables ( ) ; if ( thelevelnumber == 1 ) { levelhasbutton = false ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 400 , 400 , 50 ) ; panel2 . setframe ( 400 , 400 , 50 , 400 ) ; panel3 . setframe ( 200 , 425 , 50 , 200 ) ; panel4 . setframe ( 200 , 650 , 50 , 100 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 300.0 ; exitdoory = 597.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; portalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 2 ) { levelhasbutton = false ; playerpos . set ( 100 , 467 ) ; panel1 . setframe ( 50 , 100 , 400 , 50 ) ; panel2 . setframe ( 450 , 100 , 50 , 600 ) ; panel3 . setframe ( 350 , 500 , 100 , 200 ) ; panel4 . setframe ( 50 , 500 , 100 , 200 ) ; entrancedoorx = 100.0 ; entrancedoory = 447.0 ; exitdoorx = 400.0 ; exitdoory = 440.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; portalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 3 ) { levelhasbutton = true ; buttonx = 100.0 ; buttony = 632.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 500.0 ; boxy = 450.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 400 ) ; panel1 . setframe ( 50 , 450 , 150 , 50 ) ; panel2 . setframe ( 400 , 500 , 150 , 50 ) ; panel3 . setframe ( 50 , 300 , 500 , 50 ) ; panel4 . setframe ( 550 , 300 , 50 , 400 ) ; entrancedoorx = 100.0 ; entrancedoory = 390.0 ; exitdoorx = 500.0 ; exitdoory = 597.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; portalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 4 ) { levelhasbutton = true ; buttonx = 400.0 ; buttony = 632.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 250.0 ; boxy = 350.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 400 , 50 , 50 ) ; panel2 . setframe ( 200 , 400 , 300 , 50 ) ; panel3 . setframe ( 50 , 200 , 600 , 50 ) ; panel4 . setframe ( 650 , 200 , 50 , 500 ) ; panel5 . setframe ( 300 , 200 , 50 , 350 ) ; panel6 . setframe ( 300 , 580 , 50 , 100 ) ; panel7 . setframe ( 550 , 400 , 150 , 50 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 600.0 ; exitdoory = 340.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; portalablesurfaces . add ( panel3 ) ; portalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( panel5 ) ; nonportalablesurfaces . add ( panel6 ) ; nonportalablesurfaces . add ( panel7 ) ; nonportalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 5 ) { levelhasbutton = true ; buttonx = 800.0 ; buttony = 425.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 150.0 ; boxy = 350.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 400 , 400 , 50 ) ; panel2 . setframe ( 600 , 450 , 400 , 50 ) ; panel3 . setframe ( 908 , 150 , 50 , 300 ) ; panel4 . setframe ( 700 , 150 , 300 , 50 ) ; panel5 . setframe ( 500 , 50 , 50 , 200 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 850.0 ; exitdoory = 90.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; portalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; portalablesurfaces . add ( panel5 ) ; portalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 6 ) { levelhasbutton = false ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 50 , 300 , 50 ) ; panel2 . setframe ( 600 , 200 , 500 , 50 ) ; panel3 . setframe ( 350 , 50 , 50 , 50 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 900.0 ; exitdoory = 140.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; portalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; portalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 7 ) { levelhasbutton = true ; buttonx = 550.0 ; buttony = 425.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 550.0 ; boxy = 275.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 100 , 300 , 50 ) ; panel2 . setframe ( 350 , 100 , 250 , 50 ) ; panel3 . setframe ( 600 , 100 , 50 , 600 ) ; panel4 . setframe ( 250 , 607 , 350 , 50 ) ; panel5 . setframe ( 450 , 300 , 150 , 50 ) ; panel6 . setframe ( 400 , 450 , 200 , 50 ) ; panel7 . setframe ( 200 , 300 , 50 , 600 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 550.0 ; exitdoory = 547.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; portalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; portalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( panel5 ) ; nonportalablesurfaces . add ( panel6 ) ; nonportalablesurfaces . add ( panel7 ) ; nonportalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 8 ) { levelhasbutton = false ; playerpos . set ( 100 , 567 ) ; panel1 . setframe ( 50 , 50 , 50 , 200 ) ; panel2 . setframe ( 200 , 500 , 100 , 200 ) ; panel3 . setframe ( 400 , 350 , 100 , 350 ) ; panel4 . setframe ( 650 , 300 , 100 , 600 ) ; panel5 . setframe ( 700 , 130 , 150 , 50 ) ; panel6 . setframe ( 908 , 50 , 50 , 50 ) ; panel7 . setframe ( 700 , 50 , 50 , 200 ) ; panel8 . setframe ( 50 , 607 , 150 , 50 ) ; entrancedoorx = 100.0 ; entrancedoory = 557.0 ; exitdoorx = 800.0 ; exitdoory = 70.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; portalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( panel5 ) ; portalablesurfaces . add ( panel6 ) ; nonportalablesurfaces . add ( panel7 ) ; nonportalablesurfaces . add ( panel8 ) ; portalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 9 ) { levelhasbutton = true ; buttonx = 525.0 ; buttony = 632.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 125.0 ; boxy = 200.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 50 , 250 , 100 , 50 ) ; panel2 . setframe ( 500 , 250 , 100 , 50 ) ; panel3 . setframe ( 500 , 50 , 100 , 50 ) ; panel4 . setframe ( 600 , 50 , 50 , 650 ) ; panel5 . setframe ( 450 , 50 , 50 , 50 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 550.0 ; exitdoory = 190.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; nonportalablesurfaces . add ( panel1 ) ; nonportalablesurfaces . add ( panel2 ) ; portalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( panel5 ) ; portalablesurfaces . add ( floor ) ; nonportalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 10 ) { levelhasbutton = true ; buttonx = 425.0 ; buttony = 275.0 ; button . setframe ( buttonx , buttony , 25 , 25 ) ; boxx = 700.0 ; boxy = 550.0 ; boxpos . set ( boxx , boxy ) ; playerpos . set ( 100 , 617 ) ; panel1 . setframe ( 500 , 607 , 550 , 50 ) ; panel2 . setframe ( 500 , 50 , 550 , 50 ) ; panel3 . setframe ( 450 , 50 , 50 , 300 ) ; panel4 . setframe ( 350 , 300 , 100 , 50 ) ; panel5 . setframe ( 300 , 150 , 50 , 300 ) ; panel6 . setframe ( 800 , 200 , 250 , 50 ) ; entrancedoorx = 100.0 ; entrancedoory = 597.0 ; exitdoorx = 900.0 ; exitdoory = 140.0 ; exitdoor . setframe ( exitdoorx , exitdoory , door_width , door_height ) ; portalablesurfaces . add ( panel1 ) ; portalablesurfaces . add ( panel2 ) ; nonportalablesurfaces . add ( panel3 ) ; nonportalablesurfaces . add ( panel4 ) ; nonportalablesurfaces . add ( panel5 ) ; nonportalablesurfaces . add ( panel6 ) ; nonportalablesurfaces . add ( floor ) ; portalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; } if ( thelevelnumber == 11 ) { levelhasbutton = false ; playerpos . set ( 100 , 617 ) ; nonportalablesurfaces . add ( floor ) ; nonportalablesurfaces . add ( leftwall ) ; nonportalablesurfaces . add ( ceiling ) ; nonportalablesurfaces . add ( rightwall ) ; allcollidablesurfaces . addall ( portalablesurfaces ) ; allcollidablesurfaces . addall ( nonportalablesurfaces ) ; if ( ! gameover ) { gameover = true ; outputpane . showmessagedialog ( this , "congratulations!" , "you win!" , joptionpane . information_message ) ; this . loadlevel ( 1 ) ; } } }
tr	10	private list < string > parse ( string expression ) { list < string > result = new arraylist < string > ( ) ; stack < string > stack = new stack < string > ( ) ; interpreterlanguagelexing tokenizer = new interpreterlanguagelexing ( expression , operators ) ; while ( tokenizer . hasnext ( ) ) { string token = tokenizer . next ( ) ; if ( isnumber ( token ) ) { result . add ( token ) ; } else if ( variables . containskey ( token ) ) { result . add ( variables . get ( token ) ) ; } else if ( character . isletter ( token . charat ( 0 ) ) ) { stack . push ( token ) ; } else if ( "<litcomma>" . equals ( token ) ) { while ( ! stack . isempty ( ) && ! "(" . equals ( stack . peek ( ) ) ) { result . add ( stack . pop ( ) ) ; } if ( stack . isempty ( ) ) { throw new custominterpreterexception ( "invalid code input error !" ) ; } } else if ( operators . containskey ( token ) ) { final operator firstoperator = operators . get ( token ) ; string secondtoken = stack . isempty ( ) ? null : stack . peek ( ) ; while ( operators . containskey ( secondtoken ) && ( ( firstoperator . isleftbinded ( ) && firstoperator . getprecedence ( ) <= operators . get ( secondtoken ) . getprecedence ( ) ) || ( firstoperator . getprecedence ( ) < operators . get ( secondtoken ) . getprecedence ( ) ) ) ) { result . add ( stack . pop ( ) ) ; secondtoken = stack . isempty ( ) ? null : stack . peek ( ) ; } stack . push ( token ) ; } else if ( "(" . equals ( token ) ) { stack . push ( token ) ; } else if ( ")" . equals ( token ) ) { while ( ! stack . isempty ( ) && ! "(" . equals ( stack . peek ( ) ) ) { result . add ( stack . pop ( ) ) ; } if ( stack . isempty ( ) ) { throw new runtimeexception ( "expected closing parenthesis" ) ; } stack . pop ( ) ; } } while ( ! stack . isempty ( ) ) { string element = stack . pop ( ) ; if ( "(" . equals ( element ) || ")" . equals ( element ) ) { throw new runtimeexception ( "expected closing parenthesis" ) ; } if ( ! operators . containskey ( element ) ) { throw new runtimeexception ( "unknown operator or function: " + element ) ; } result . add ( element ) ; } return result ; }
tr	2	public void checknote ( string channel , string sender ) { sqlconnect ( ) ; statement statement ; boolean notesent = false ; try { statement = connection . createstatement ( ) ; statement deletestatement = connection . createstatement ( ) ; resultset results = statement . executequery ( "select * from notes where receiver = '" + sender + "';" ) ; string finalmessage = "" ; while ( results . next ( ) ) { if ( sender . equalsignorecase ( results . getstring ( "receiver" ) ) ) { if ( ! notesent ) { finalmessage += sender + "<litcomma> you have notes: " ; log . consolelog ( "giving " + sender + " their notes." ) ; notesent = true ; } string message_tosend = results . getstring ( "message" ) . tostring ( ) . replace ( "<backslash>" , "\\\\" ) . replace ( "<apostrophe>" , "'" ) ; finalmessage += "<" + results . getstring ( "sender" ) + "> " + message_tosend + "  " ; deletestatement . executeupdate ( "delete from notes where message = '" + results . getstring ( "message" ) + "' and channel = '" + channel + "'" ) ; } } if ( notesent ) { this . bot . sendmessage ( channel , finalmessage ) ; } } catch ( sqlexception e ) { log . consolelog ( "error" , "failed to check for notes." ) ; e . printstacktrace ( ) ; } sqldisconnect ( ) ; }
tr	6	public gerarrelatorio ( ) { stringbuilder criarelatorio = new stringbuilder ( ) ; enumeration relatorio = dadosgerais . placassaida . keys ( ) ; int y = 0 ; while ( relatorio . hasmoreelements ( ) ) { dadosgerais . listadeplacas [ y ] = ( string ) relatorio . nextelement ( ) ; y ++ ; } if ( dadosgerais . placassaida . isempty ( ) ) { criarelatorio . append ( "n\xe3o houve movimento." ) ; } else { for ( int i = 0 ; i < dadosgerais . listadeplacas . length ; i ++ ) { if ( dadosgerais . listadeplacas [ i ] == null ) { i = i + 1 ; } else { criarelatorio . append ( dadosgerais . listadeplacas [ i ] ) . append ( "\\r\\n" ) ; } } } relatoriododia = "relat\xf3rio do dia\\r\\n\\r\\n" + "usu\xe1rio: " + login . antigouser + "\\r\\n" + dadosgerais . formatadatarelatorio . format ( dadosgerais . data ) + "\\r\\n\\r\\nvalor por placa: r$5<litcomma>00" + "\\r\\n\\r\\n\\r\\nplacas do dia:" + "\\r\\n" + criarelatorio + "\\r\\n\\r\\ntotal do caixa: r$" + dadosgerais . placassaida . size ( ) * 5 + "<litcomma>00" ; salvararquivorelatorio salvar = new salvararquivorelatorio ( ) ; }
tr	5	public boolean buildriver ( land land , int direction ) { land . isweet = true ; int x = land . x ; int z = land . z ; if ( land . height > lakelevel ) { if ( direction == 0 ) { buildriver ( world [ x - 1 ] [ z ] , direction ) ; } else if ( direction == 1 ) { buildriver ( world [ x + 1 ] [ z ] , direction ) ; } else if ( direction == 2 ) { buildriver ( world [ x ] [ z - 1 ] , direction ) ; } else { buildriver ( world [ x ] [ z + 1 ] , direction ) ; } } return true ; }
tr	6	private static int printresults ( list < edge > finalmst ) { int totalcost = 0 ; for ( edge mstedge : finalmst ) { totalcost += mstedge . getcost ( ) ; } system . out . println ( totalcost ) ; system . out . println ( "-----" ) ; for ( edge mstedge : finalmst ) { system . out . println ( mstedge . getstart ( ) + "\\t" + mstedge . getfinish ( ) + "\\t" + mstedge . getcost ( ) ) ; } system . out . println ( ) ; return totalcost ; }
tr	4	public string tostring ( ) { string s = "" ; for ( int i = 0 ; i < 6 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "valisumma: " + valisumma ) + "\\n" ; s = s + ( "bonus: " + bonus ) + "\\n" ; s = s + "-------------------------------------------------" + "\\n" ; for ( int i = 6 ; i < 8 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + ( jatsiyhdistelmat . get ( 8 ) . name ( ) + ":\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( 8 ) ) ) + "\\n" ; for ( int i = 9 ; i < 15 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "summa: " + summa ) + "\\n" ; return s ; }
tr	3	@ override public string transforma ( string textoasertransformado ) { string textoanterior = "" ; string textofinal = "" ; while ( validacaodelistanastring ( textoasertransformado ) ) { string textoasertransformadoarray [ ] = textoasertransformado . split ( "\\n" ) ; for ( string texto : textoasertransformadoarray ) { if ( textoanterior . matches ( ".*<ul>.*" ) ) { texto = texto . replaceall ( "\\\\*(.*)" , "<li>$1</li>" ) ; } else if ( texto . matches ( "\\\\*.*" ) && textoanterior . matches ( "<li>.*</li>" ) ) { texto = texto . replaceall ( "\\\\*(.*)" , "<li>$1</li>" ) ; } textoanterior = texto ; textofinal . concat ( texto ) ; } } return textoasertransformado ; }
tr	3	public void setcontents ( ) { scene scene = new scene ( root , 150 , 150 ) ; setscene ( scene ) ; group groupindialog = new group ( ) ; groupindialog . getchildren ( ) . add ( new label ( "really exit ?" ) ) ; root . setcenter ( groupindialog ) ; button yes = new button ( "yes" ) ; yes . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent paramt ) { buttonokpressed = true ; stage . close ( ) ; presenterimpl . applicationexit ( ) ; } } ) ; button no = new button ( "no" ) ; no . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent paramt ) { buttonokpressed = false ; stage . close ( ) ; } } ) ; hbox buttonpane = new hbox ( ) ; buttonpane . setspacing ( 10 ) ; buttonpane . getchildren ( ) . addall ( yes , no ) ; root . setbottom ( buttonpane ) ; stage . show ( ) ; }
tr	4	public void mousepressed ( mouseevent e ) { int surfacenumber = 0 ; double distancebetweenportals ; ray . set ( ( e . getx ( ) - player . getcenterx ( ) ) , ( e . gety ( ) - player . getcentery ( ) ) ) ; ray = ray . normalize ( ) ; for ( int i = 0 ; i < 1200 ; i ++ ) { testray = ray . multiply ( i ) ; rayline . setline ( player . getcenterx ( ) , player . getcentery ( ) , testray . getx ( ) + player . getcenterx ( ) , testray . gety ( ) + player . getcentery ( ) ) ; for ( surfacenumber = 0 ; surfacenumber < allcollidablesurfaces . size ( ) ; surfacenumber ++ ) { if ( rayline . intersects ( ( rectangle2d ) allcollidablesurfaces . get ( surfacenumber ) ) ) { raylineintersection = true ; testray = ray . multiply ( i - 1 ) ; testpoint . setlocation ( testray . getx ( ) + player . getcenterx ( ) , testray . gety ( ) + player . getcentery ( ) ) ; break ; } } if ( raylineintersection ) { break ; } } if ( portalablesurfaces . contains ( ( rectangle2d ) allcollidablesurfaces . get ( surfacenumber ) ) ) { portalrelativelocation = ( ( rectangle2d ) allcollidablesurfaces . get ( surfacenumber ) ) . outcode ( testpoint ) ; if ( ( e . getbutton ( ) == 1 ) && raylineintersection ) { lastshotblueportal = true ; } else if ( ( e . getbutton ( ) == 3 ) && raylineintersection ) { lastshotblueportal = false ; } if ( raylineintersection && lastshotblueportal ) { distancebetweenportals = math . sqrt ( math . pow ( testpoint . getx ( ) - portal2 . getcenterx ( ) , 2 ) + math . pow ( testpoint . gety ( ) - portal2 . getcentery ( ) , 2 ) ) ; if ( distancebetweenportals < 50 ) { portalcollisionissue = true ; } else { portalcollisionissue = false ; } } else if ( raylineintersection && ! lastshotblueportal ) { distancebetweenportals = math . sqrt ( math . pow ( testpoint . getx ( ) - portal1 . getcenterx ( ) , 2 ) + math . pow ( testpoint . gety ( ) - portal1 . getcentery ( ) , 2 ) ) ; if ( distancebetweenportals < 70 ) { portalcollisionissue = true ; } else { portalcollisionissue = false ; } } if ( ! portalcollisionissue ) { findportalrelativelocations ( ) ; } if ( lastshotblueportal && raylineintersection && ! portalcollisionissue ) { portal1 . setframe ( rayline . getx2 ( ) - ( portalwidth / 2 ) , rayline . gety2 ( ) - ( portalheight / 2 ) , portalwidth , portalheight ) ; raylinecolorisblue = true ; portal1active = true ; } else if ( ! lastshotblueportal && raylineintersection && ! portalcollisionissue ) { portal2 . setframe ( rayline . getx2 ( ) - ( portalwidth / 2 ) , rayline . gety2 ( ) - ( portalheight / 2 ) , portalwidth , portalheight ) ; raylinecolorisblue = false ; portal2active = true ; } if ( portal1active && portal2active ) { portalsactive = true ; } } raylineintersection = false ; }
tr	7	public chessmoves nextmoves ( chessboard b ) { int i = this . getposition ( ) . getrow ( ) ; int j = this . getposition ( ) . getcol ( ) ; chessmoves moves = new chessmoves ( ) ; try { for ( int k = i ; k < 8 ; k ++ ) { if ( k != i ) { if ( ! addmove ( b , moves , k , j ) ) break ; } } for ( int k = i ; k >= 0 ; k -- ) { if ( k != i ) { if ( ! addmove ( b , moves , k , j ) ) break ; } } for ( int k = j ; k < 8 ; k ++ ) { if ( k != j ) { if ( ! addmove ( b , moves , i , k ) ) break ; } } for ( int k = j ; k >= 0 ; k -- ) { if ( k != j ) { if ( ! addmove ( b , moves , i , k ) ) break ; } } } catch ( exception e ) { moves = null ; } return moves ; }
tr	4	public static string getyoutubeinfo ( string s ) throws ioexception { string info ; string title = null ; string likes = null ; string dislikes = null ; string user = null ; string veiws = null ; @ suppresswarnings ( "unused" ) string publishdate ; document doc = jsoup . connect ( s ) . useragent ( "mozilla/5.0 (windows nt 6.2; wow64) applewebkit/537.17 (khtml<litcomma> like gecko) chrome/24.0.1312.57 safari/537.17" ) . get ( ) ; for ( element e : doc . select ( "a" ) ) { if ( e . attr ( "class" ) . equalsignorecase ( "yt-uix-sessionlink yt-user-videos" ) ) { user = e . attr ( "href" ) . split ( "/user/" ) [ 1 ] . split ( "/" ) [ 0 ] ; } } for ( element e : doc . select ( "span" ) ) { if ( e . attr ( "class" ) . equalsignorecase ( "watch-view-count" ) ) { veiws = e . text ( ) ; } if ( e . attr ( "class" ) . equalsignorecase ( "likes-count" ) ) { likes = e . text ( ) ; } if ( e . attr ( "class" ) . equalsignorecase ( "dislikes-count" ) ) { dislikes = e . text ( ) ; } if ( e . attr ( "class" ) . equalsignorecase ( "watch-title  yt-uix-expander-head" ) || e . attr ( "class" ) . equalsignorecase ( "watch-title long-title yt-uix-expander-head" ) ) { title = e . text ( ) ; } if ( e . attr ( "class" ) . equalsignorecase ( "watch-video-date" ) ) { publishdate = e . text ( ) ; } } info = title + " - " + user + "  views: " + veiws + "  likes: " + likes + "  dislikes: " + dislikes ; return info ; }
tr	10	public void execute ( ) throws mojoexecutionexception , mojofailureexception { string [ ] split = webjar . split ( ":" ) ; string artifact = split [ 0 ] ; artifactversion requestedversion = split . length >= 2 ? new defaultartifactversion ( split [ 1 ] ) : null ; collection < artifactversion > versions = mavencentral . getartifacts ( artifact , requestedversion , getlog ( ) ) . get ( artifact ) ; artifactversion resolvedversion = null ; if ( requestedversion == null ) { resolvedversion = versions . iterator ( ) . next ( ) ; } else { for ( artifactversion artifactversion : versions ) { if ( artifactversion . equals ( requestedversion ) ) { resolvedversion = artifactversion ; break ; } } } dependency dependency = new dependency ( ) ; dependency . setgroupid ( "org.webjars" ) ; dependency . setartifactid ( artifact ) ; dependency . setversion ( resolvedversion . tostring ( ) ) ; dependency updateddependency = null ; iterator < dependency > existingdependencies = project . getoriginalmodel ( ) . getdependencies ( ) . iterator ( ) ; while ( existingdependencies . hasnext ( ) ) { dependency existingdependency = existingdependencies . next ( ) ; if ( existingdependency . getgroupid ( ) . equals ( dependency . getgroupid ( ) ) && existingdependency . getartifactid ( ) . equals ( dependency . getartifactid ( ) ) ) { if ( existingdependency . getversion ( ) . equals ( dependency . getversion ( ) ) ) { getlog ( ) . warn ( artifact + ":" + dependency . getversion ( ) + " is already a dependency. aborting." ) ; return ; } updateddependency = existingdependency ; existingdependencies . remove ( ) ; break ; } } project . getoriginalmodel ( ) . adddependency ( dependency ) ; try { modelwriter . write ( project . getfile ( ) , null , project . getoriginalmodel ( ) ) ; } catch ( ioexception e ) { throw new mojoexecutionexception ( "could not add dependency" , e ) ; } if ( updateddependency != null ) { getlog ( ) . info ( "updated " + artifact + " from " + updateddependency . getversion ( ) + " to " + resolvedversion ) ; } else { getlog ( ) . info ( "added dependency: " + artifact + ":" + resolvedversion ) ; } }
tr	4	public static arraylist < string > encrypt ( biginteger p , biginteger q , biginteger e , biginteger m ) { arraylist < string > output = new arraylist < string > ( ) ; biginteger n = p . multiply ( q ) ; biginteger z = ( p . subtract ( biginteger . valueof ( 1 ) ) ) . multiply ( q . subtract ( biginteger . valueof ( 1 ) ) ) ; output . add ( "p = " + p ) ; output . add ( "q = " + q ) ; output . add ( "e = " + e ) ; output . add ( "m = " + m ) ; output . add ( "" ) ; output . add ( "n = (p)(q) = (" + p + ")(" + q + ") = " + n ) ; output . add ( "z = (p-1)(q-1) = (" + p + "-1)(" + q + "-1) = " + z ) ; output . add ( "" ) ; biginteger d = e . modinverse ( z ) ; output . add ( "d = gcd(e<litcomma> z) = " + d ) ; output . add ( "" ) ; biginteger enc = m ; enc = enc . modpow ( e , n ) ; biginteger dec = enc ; dec = dec . modpow ( d , n ) ; output . add ( "encrypted output = " + enc ) ; output . add ( "decrypted output (check) = " + dec ) ; return output ; }
tr	8	private student parsestudent ( final node nodestudent ) { boolean quantityerror = false ; string name = "" ; string group = "" ; final exam [ ] exams = new exam [ desktop . exams_count ] ; int index = 0 ; final nodelist fields = nodestudent . getchildnodes ( ) ; if ( fields != null ) { for ( int i = 0 ; i < fields . getlength ( ) ; ++ i ) { final node field = fields . item ( i ) ; if ( field != null ) { if ( field . getnodetype ( ) == node . element_node ) { final nodelist childfields = field . getchildnodes ( ) ; if ( childfields . getlength ( ) == 1 ) { final node item = childfields . item ( 0 ) ; if ( item != null ) { if ( field . getnodename ( ) == model . field_name ) { name = item . getnodevalue ( ) ; } if ( field . getnodename ( ) == model . field_group ) { group = item . getnodevalue ( ) ; } } } else { int counter = 0 ; for ( int j = 0 ; j < childfields . getlength ( ) ; ++ j ) { final node examfield = childfields . item ( j ) ; if ( examfield != null ) { if ( examfield . getnodetype ( ) == node . element_node ) { if ( counter < desktop . exams_count ) { final exam exam = parseexam ( examfield ) ; exams [ index ] = exam ; index ++ ; counter ++ ; } else { quantityerror = true ; } } } } } } } } } for ( ; index < desktop . exams_count ; ++ index ) { exams [ index ] = new exam ( "" , null ) ; } if ( quantityerror ) { joptionpane . showmessagedialog ( null , xmlreader . error_incorrect_quantity_in_exams + "(>" + desktop . exams_count + ") of student " + name ) ; } return new student ( name , util . isnumeric ( group ) ? integer . parseint ( group ) : null , exams ) ; }
tr	6	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; hashmap < string , string > ht = new hashmap < > ( ) ; char svar ; boolean fortsatt = true ; int antalratt = 1 ; while ( fortsatt ) { system . out . println ( ) ; system . out . println ( "v\xe4lj:" ) ; system . out . println ( "1. skapa gloslistan" ) ; system . out . println ( "2. visa gloslistan" ) ; system . out . println ( "3. skriv in en ny glosa" ) ; system . out . println ( "4. glosf\xf6rh\xf6r" ) ; system . out . println ( "0. avsluta" ) ; try { svar = sc . nextline ( ) . charat ( 0 ) ; switch ( svar ) { case '1' : ht . put ( "sol" , "sun" ) ; ht . put ( "hej" , "hello" ) ; ht . put ( "m\xe5ne" , "moon" ) ; ht . put ( "regn" , "rain" ) ; ht . put ( "snow" , "sn\xf6" ) ; system . out . println ( "klart" ) ; break ; case '2' : system . out . print ( "glosa? " ) ; string glos = sc . nextline ( ) ; system . out . println ( "glosa: " + ht . get ( glos ) ) ; break ; case '3' : system . out . println ( "ange det svenska ordet: " ) ; string glosa = sc . next ( ) ; system . out . println ( "ange det engelska ordet: " ) ; string uzd = sc . next ( ) ; ht . put ( glosa , uzd ) ; break ; case '4' : for ( string nyckel : ht . keyset ( ) ) { system . out . print ( "vad heter: " + nyckel + " p\xe5 engelska? " ) ; string svaret = sc . next ( ) ; if ( svaret . equals ( ht . get ( nyckel ) ) ) { system . out . println ( "r\xe4tt!" ) ; antalratt ++ ; } else { system . out . println ( "fel! r\xe4tt svar \xe4r " + ht . get ( nyckel ) ) ; } } system . out . println ( "antalet r\xe4tta: " + antalratt ) ; break ; case '0' : system . out . println ( "slut" ) ; break ; default : break ; } } catch ( exception e ) { } system . out . println ( ) ; } }
tr	4	private void domenulogic ( ) { if ( menucontrolsbuffer . isempty ( ) ) { return ; } int key = 0 ; try { key = menucontrolsbuffer . dequeue ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } if ( key == keyevent . vk_up ) { if ( selectedmenuitem == 0 ) { selectedmenuitem = 2 ; } else { selectedmenuitem -- ; } } else if ( key == keyevent . vk_down ) { if ( selectedmenuitem == 2 ) { selectedmenuitem = 0 ; } else { selectedmenuitem ++ ; } } else if ( key == keyevent . vk_enter ) { if ( selectedmenuitem == 0 ) { resetgame ( ) ; gamestate = 1 ; } else if ( selectedmenuitem == 1 ) { } else { timer . stop ( ) ; } } }
tr	7	@ override public void receive ( message message ) throws messagelistenerexception { long companyid = portalutil . getdefaultcompanyid ( ) ; try { user user = userlocalserviceutil . getuserbyemailaddress ( companyid , portletpropsvalues . detect_user_email ) ; expandotable table = expandotablelocalserviceutil . getdefaulttable ( user . getcompanyid ( ) , user . class . getname ( ) ) ; expandocolumn column = expandocolumnlocalserviceutil . getcolumn ( table . gettableid ( ) , constants . expando_column_name ) ; expandovalue value = expandovaluelocalserviceutil . getvalue ( table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) ) ; string languagechangetime = stringpool . blank ; if ( value != null ) { languagechangetime = value . getdata ( ) ; } string userlanguage = user . getlanguageid ( ) ; long timestamp = system . currenttimemillis ( ) ; if ( validator . isnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , string . valueof ( timestamp ) ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "detect user language change." ) ; } } if ( validator . isnotnull ( languagechangetime ) && ! userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; } if ( validator . isnotnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) && ( timestamp - long . valueof ( languagechangetime ) ) >= portletpropsvalues . language_life_ms ) { user . setlanguageid ( portletpropsvalues . recover_language ) ; userlocalserviceutil . updateuser ( user ) ; expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "update user language to " + portletpropsvalues . recover_language ) ; } } } catch ( nosuchuserexception nsue ) { if ( _log . isinfoenabled ( ) ) { _log . info ( "user " + portletpropsvalues . detect_user_email + " does not exist" ) ; } } catch ( exception e ) { if ( _log . iserrorenabled ( ) ) { _log . error ( e ) ; } } }
tr	6	public void logic ( ) { x += xspeed ; y += yspeed ; yspeed -= 0.4 ; if ( dead ) { if ( y < - 800 ) dead = false ; return ; } if ( y <= 32 ) { yspeed = 0 ; y = 32 ; jumpsremaining = 2 ; if ( ! keyboard . iskeydown ( keyboard . key_left ) && xspeed < 0 ) xspeed = xspeed * 0.9 ; if ( ! keyboard . iskeydown ( keyboard . key_right ) && xspeed > 0 ) xspeed = xspeed * 0.9 ; } if ( x >= 660 ) { x = 5 ; } if ( x <= - 10 ) { x = 645 ; } if ( keyboard . iskeydown ( keyboard . key_t ) ) { x = math . random ( ) * 640 ; y = math . random ( ) * 480 ; } if ( keyboard . iskeydown ( keyboard . key_k ) && game . killcommand == 1 ) { game . killcommand = 0 ; x = enemy . x + 3 ; y = enemy . y + 17 ; } if ( jumppressed && ! jumpwaspressed && jumpsremaining -- > 0 ) yspeed = 7 ; if ( keyboard . iskeydown ( keyboard . key_left ) ) xspeed = math . max ( - 5 , xspeed - 1 ) ; if ( keyboard . iskeydown ( keyboard . key_right ) ) xspeed = math . min ( 5 , xspeed + 1 ) ; jumpwaspressed = jumppressed ; jumppressed = keyboard . iskeydown ( keyboard . key_up ) ; if ( math . abs ( x - game . enemy . x ) > 16 || math . abs ( y - game . enemy . y ) > 16 ) return ; if ( yspeed < 0 ) game . enemy . kill ( ) ; else kill ( ) ; }
tr	1	@ test public void solvetest ( ) { euler e = new euler ( ) ; double [ ] [ ] expresult = { { 0 , 1 } , { 0.5 , 5.25 } , { 1 , 5.875 } , { 1.5 , 5.125 } } ; differentialequation f1 = new f1 ( ) ; double [ ] initialcondition = { 0 , 1 } ; double lastx = 1.5 ; double step = 0.5 ; double [ ] [ ] result = e . solve ( f1 , initialcondition , lastx , step ) ; assertarrayequals ( expresult , result ) ; }
tr	3	private static void addtreasurechesttogrid ( scanner scanner , grid grid ) { system . out . println ( "would you like to add a treasure chest to your grid. enter y or n :" ) ; string addtreasure = addtreasure ( scanner ) ; while ( ! addtreasure . equalsignorecase ( "y" ) && ! addtreasure . equalsignorecase ( "n" ) ) { system . out . println ( "enter y or n :" ) ; addtreasure = addtreasure ( scanner ) ; } if ( addtreasure . trim ( ) . tolowercase ( ) . equalsignorecase ( "y" ) ) { addtreasurechest ( scanner , grid ) ; } else { treasurechestcounter counter = new treasurechestmanager ( ) ; system . out . println ( "**********treasure maps nearby****************" ) ; counter . displaytreasurechestnearby ( grid ) ; } }
tr	5	public static void main ( string [ ] args ) { final int sumof100randomnumers = util . infiniterandompositiveintegers ( 1000 ) . limit ( 100 ) . reduce ( 0 , ( acc , x ) -> acc + x ) ; system . out . println ( "sum(100 random integers): " + sumof100randomnumers ) ; final supplier < string > bigstringsupplier = ( ) -> { try { return new string ( files . readallbytes ( paths . get ( "/users/shasrp/code/personal/github/my-experiments/java/java8/java8-demo/src/main/resources/name.txt" ) ) ) ; } catch ( ioexception e ) { return "" ; } } ; final string threeconcatofnamefile = streamsupport . stream ( new infinitestream < string > ( bigstringsupplier ) , false ) . limit ( 3 ) . reduce ( "" , ( acc , x ) -> acc + x ) ; system . out . println ( "concat(3 names 3 times): " + threeconcatofnamefile ) ; system . out . println ( "sum of first 10 natural numbers: " + util . naturalnumbers ( ) . limit ( 10 ) . reduce ( 0 , ( acc , next ) -> acc + next ) ) ; system . out . println ( "product of squares of first 5 natural numbers: " + util . naturalnumbers ( ) . limit ( 5 ) . map ( ( ( integer nat ) -> lambdafunction . < integer > dooperation ( lambdafunction :: multiply , nat , nat ) ) ) . reduce ( 1 , lambdafunction :: multiply ) ) ; system . out . println ( " even nat < 100: " + util . naturalnumbers ( ) . limit ( 100 ) . filter ( ( nat ) -> 0 == ( nat % 2 ) ) . collect ( collectors . tolist ( ) ) ) ; system . out . println ( "unique nat in random ints: " + util . infiniterandompositiveintegers ( 100 ) . limit ( 101 ) . collect ( collectors . toset ( ) ) ) ; }
tr	8	@ override public string tostring ( ) { string ret = "" ; if ( nodes != null && nodes . size ( ) > 0 ) { stringbuilder sb = new stringbuilder ( ) ; list < tconnection > printed = new arraylist < tconnection > ( ) ; for ( tnode n : nodes ) { for ( tconnection c : n . getconnections ( ) ) { if ( ! printed . contains ( c ) ) printed . add ( c ) ; } } for ( tconnection c : printed ) { sb . append ( c + "\\n" ) ; } ret = sb . tostring ( ) ; } else ret = "empty tree" ; return ret ; }
tr	7	protected boolean packageapplication ( ) throws mojoexecutionexception { getlog ( ) . info ( "packaging application..." ) ; getlog ( ) . info ( "bar package: " + getkeystorage ( ) ) ; packagerargumentsbuilder argumentsbuilder = new packagerargumentsbuilder ( getbarpackage ( ) . getapkfile ( ) , getbarpackage ( ) . getbarfile ( ) , getcertificate ( ) . getauthor ( ) , appcategory . parsecategory ( getbarpackage ( ) . getapplicationcategory ( ) ) ) ; argumentsbuilder . setminimalosversion ( getbarpackage ( ) . getminimalosversion ( ) ) ; argumentsbuilder . setverifyapk ( true ) ; argumentsbuilder . setappentrypointnametruncation ( getbarpackage ( ) . getappentrypointnametruncation ( ) ) ; argumentsbuilder . setwarninglevelthreshold ( getbarpackage ( ) . getwarninglevelthreshold ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > packagingcallable = new callable < void > ( ) { @ override public void call ( ) throws exception { apk2bar . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean packagingsuccessful = executor . execute ( packagingcallable ) == 0 && checkpackage ( ) ; if ( ! packagingsuccessful ) { throw new mojoexecutionexception ( "failed to package application. path: " + getbarpackage ( ) . getbarfile ( ) . getpath ( ) ) ; } getlog ( ) . info ( "application packaged successfully." ) ; return packagingsuccessful ; }
tr	7	public string getthememessage ( int frequentngramcount ) { if ( frequencytable == null ) { updatefrequencies ( ) ; } stringbuilder builder = new stringbuilder ( ) ; if ( frequentngramcount > frequencytable . size ( ) ) { frequentngramcount = frequencytable . size ( ) ; } for ( int i = 1 ; i < frequentngramcount + 1 ; i ++ ) { integer ngramid = frequencytable . getpair ( frequencytable . size ( ) - i ) . second ; builder . append ( dictionary . getinstance ( ) . getngrambyid ( ngramid ) . getbase ( ) ) . append ( " " ) ; } return builder . tostring ( ) ; }
tr	4	public string decypher ( string input ) { string [ ] cyphers = input . split ( " " ) ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < cyphers . length ; i ++ ) { long num = long . parselong ( cyphers [ i ] ) ; long temp = endecrypt ( num , d , n ) ; debug . print ( "temp is:" + temp ) ; char c = ( char ) temp ; sb . append ( c ) ; } return sb . tostring ( ) ; }
tr	2	private parameter decodeparam ( object obj ) throws jsonexception { parameter param = null ; final string paramname = "" ; if ( obj instanceof jsonobject ) { jsonobject jsonparam = ( jsonobject ) obj ; groupedparameter groupedparam = new groupedparameter ( "" ) ; groupedparam . setvalues ( decodeparams ( jsonparam ) ) ; param = groupedparam ; } else if ( obj instanceof jsonarray ) { jsonarray params = ( jsonarray ) obj ; param = decodeparams ( params ) ; } else { if ( obj instanceof string ) { string value = ( string ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof integer ) { integer value = ( integer ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof long ) { long value = ( long ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof boolean ) { boolean value = ( boolean ) obj ; param = new singleparameter ( "" , value ) ; } } if ( param != null ) { param . setname ( paramname ) ; } return param ; }
tr	6	public void dohvatilistupoveznica ( ) { arraylist listaurla = new arraylist ( ) ; string text ; string linktext ; int prvi = 0 ; int zadnji ; int zadnji1 ; int zadnji2 ; while ( true ) { try { prvi = webstranica . getsadrzaj ( ) . tostring ( ) . indexof ( "href=" , prvi ) + 6 ; if ( prvi == 5 ) { break ; } text = webstranica . getsadrzaj ( ) . tostring ( ) . substring ( prvi ) ; zadnji1 = text . indexof ( "\\"" ) ; zadnji2 = text . indexof ( "'" ) ; if ( ( zadnji1 < zadnji2 ) ) { zadnji = zadnji1 ; } else { zadnji = zadnji2 ; } if ( zadnji1 == - 1 ) { zadnji = zadnji2 ; } if ( zadnji2 == - 1 ) { zadnji = zadnji1 ; } if ( text . startswith ( "http:" ) ) { linktext = text . substring ( 0 , zadnji ) ; } else if ( text . startswith ( "www." ) ) { linktext = "http://" + text . substring ( 0 , zadnji ) ; } else if ( text . startswith ( "/" ) ) { linktext = webstranica . geturl ( ) . tostring ( ) + text . substring ( 0 , zadnji ) ; } else { linktext = webstranica . geturl ( ) . tostring ( ) + "/" + text . substring ( 0 , zadnji ) ; } url link = new url ( linktext ) ; listaurla . add ( link ) ; velicina = linktext . length ( ) ; if ( velicina > max ) { max = velicina ; } } catch ( malformedurlexception ex ) { logger . getlogger ( resourceuser . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } webstranica . setlistaurla ( listaurla ) ; }
tr	4	private dectreenode traintree ( list < instance > examples , list < attribute > attributes , list < instance > parentexamples , string parentattributevalue ) { if ( examples . isempty ( ) ) { return new leafdectreenode ( plurality ( parentexamples ) , parentattributevalue ) ; } else if ( attributes . isempty ( ) || samelabel ( examples ) ) { return new leafdectreenode ( plurality ( examples ) , parentattributevalue ) ; } else { attribute importantattribute = importance ( attributes , examples ) ; list < attribute > childattributes = new arraylist < attribute > ( attributes ) ; childattributes . remove ( importantattribute ) ; if ( attribute . type . numerical . equals ( importantattribute . category . gettype ( ) ) ) { double midpoint = midpoint ( examples , importantattribute . index ) ; list < instance > positivechildexamples = new arraylist < instance > ( ) , negativechildexamples = new arraylist < instance > ( ) ; for ( instance example : examples ) { if ( integer . parseint ( example . attributes . get ( importantattribute . index ) ) > midpoint ) { positivechildexamples . add ( example ) ; } else { negativechildexamples . add ( example ) ; } } list < dectreenode > children = new arraylist < dectreenode > ( ) ; children . add ( traintree ( negativechildexamples , childattributes , examples , "a" ) ) ; children . add ( traintree ( positivechildexamples , childattributes , examples , "b" ) ) ; return new numericalinternaldectreenode ( plurality ( examples ) , importantattribute , parentattributevalue , children , midpoint ) ; } else { map < string , list < instance > > childexamples = new linkedhashmap < string , list < instance > > ( ) ; for ( instance example : examples ) { string importantattributevalue = example . attributes . get ( importantattribute . index ) ; list < instance > childexample = childexamples . get ( importantattributevalue ) ; if ( childexample == null ) { childexample = new arraylist < instance > ( ) ; childexamples . put ( importantattributevalue , childexample ) ; } childexample . add ( example ) ; } list < dectreenode > children = new arraylist < dectreenode > ( ) ; for ( string attribute : importantattribute . values ) { list < instance > childexamplesforattribute = childexamples . get ( attribute ) ; if ( childexamplesforattribute == null ) { childexamplesforattribute = new arraylist < instance > ( ) ; } children . add ( traintree ( childexamplesforattribute , childattributes , examples , attribute ) ) ; } return new internaldectreenode ( plurality ( examples ) , importantattribute , parentattributevalue , children ) ; } } }
tr	9	public void loadinitialviewstate ( graphicsconfiguration gc , int units ) { this . gc = gc ; screenwidth = gc . getbounds ( ) . width ; screenheight = gc . getbounds ( ) . height ; visx = 0 ; visy = 0 ; if ( screenwidth >= 2560 && screenheight >= 1440 ) { xoffset = ( screenwidth - 2560 ) / 2 ; yoffset = ( screenheight - 1440 ) / 2 ; ipanewidth = 2560 ; ipaneheight = 140 ; unitlength = 52 ; clocklength = 132 ; clockoffset = 4 ; portraitwidth = 170 ; portraitheight = 208 ; endturnx = xoffset + 12 ; endturny = screenheight - yoffset - ipaneheight + 196 ; endturnwidth = 174 ; endturnheight = 80 ; reskey = 0 ; } else if ( screenwidth >= 1920 && screenheight >= 1080 ) { xoffset = ( screenwidth - 1920 ) / 2 ; yoffset = ( screenheight - 1080 ) / 2 ; ipanewidth = 1920 ; ipaneheight = 105 ; unitlength = 39 ; clocklength = 99 ; clockoffset = 3 ; portraitwidth = 128 ; portraitheight = 156 ; endturnx = xoffset + 9 ; endturny = screenheight - yoffset - ipaneheight + 147 ; endturnwidth = 130 ; endturnheight = 60 ; reskey = 1 ; } else if ( screenwidth >= 1600 && screenheight >= 900 ) { xoffset = ( screenwidth - 1600 ) / 2 ; yoffset = ( screenheight - 900 ) / 2 ; ipanewidth = 1600 ; ipaneheight = 75 ; unitlength = 33 ; clocklength = 105 ; clockoffset = 9 ; portraitwidth = 105 ; portraitheight = 130 ; endturnx = xoffset + 8 ; endturny = screenheight - yoffset - ipaneheight + 123 ; endturnwidth = 108 ; endturnheight = 49 ; reskey = 2 ; } else if ( screenwidth >= 1280 && screenheight >= 720 ) { xoffset = ( screenwidth - 1280 ) / 2 ; yoffset = ( screenheight - 720 ) / 2 ; ipanewidth = 1280 ; ipaneheight = 70 ; unitlength = 26 ; clocklength = 85 ; clockoffset = 7 ; portraitwidth = 85 ; portraitheight = 105 ; endturnx = xoffset + 6 ; endturny = screenheight - yoffset - ipaneheight + 98 ; endturnwidth = 87 ; endturnheight = 40 ; reskey = 3 ; } else { system . exit ( 0 ) ; } pixellength = unitlength * units ; boundx = this . pixellength - screenwidth ; boundy = this . pixellength - screenheight + ipaneheight ; terrainimages = new volatileimage [ 90 ] ; for ( int i = 0 ; i < terrainimages . length ; i ++ ) { terrainimages [ i ] = gc . createcompatiblevolatileimage ( unitlength , unitlength ) ; } unitimages = new volatileimage [ 40 ] ; for ( int i = 0 ; i < unitimages . length ; i ++ ) { unitimages [ i ] = gc . createcompatiblevolatileimage ( unitlength , unitlength , volatileimage . translucent ) ; } unitfocusimages = new volatileimage [ 40 ] ; for ( int i = 0 ; i < unitfocusimages . length ; i ++ ) { unitfocusimages [ i ] = gc . createcompatiblevolatileimage ( unitlength * 3 , unitlength * 3 ) ; } informationpanel = gc . createcompatiblevolatileimage ( ipanewidth , ipaneheight ) ; clockimage = gc . createcompatiblevolatileimage ( clocklength , clocklength , volatileimage . translucent ) ; portrait = gc . createcompatiblevolatileimage ( portraitwidth , portraitheight , volatileimage . translucent ) ; }
tr	9	public matrix invertfull ( ) { matrix ret = new matrix ( ) ; float [ ] mat = values ; float [ ] dst = ret . values ; float [ ] tmp = new float [ 12 ] ; float src [ ] = new float [ 16 ] ; float det ; for ( int i = 0 ; i < 4 ; i ++ ) { src [ i ] = mat [ i * 4 ] ; src [ i + 4 ] = mat [ i * 4 + 1 ] ; src [ i + 8 ] = mat [ i * 4 + 2 ] ; src [ i + 12 ] = mat [ i * 4 + 3 ] ; } tmp [ 0 ] = src [ 10 ] * src [ 15 ] ; tmp [ 1 ] = src [ 11 ] * src [ 14 ] ; tmp [ 2 ] = src [ 9 ] * src [ 15 ] ; tmp [ 3 ] = src [ 11 ] * src [ 13 ] ; tmp [ 4 ] = src [ 9 ] * src [ 14 ] ; tmp [ 5 ] = src [ 10 ] * src [ 13 ] ; tmp [ 6 ] = src [ 8 ] * src [ 15 ] ; tmp [ 7 ] = src [ 11 ] * src [ 12 ] ; tmp [ 8 ] = src [ 8 ] * src [ 14 ] ; tmp [ 9 ] = src [ 10 ] * src [ 12 ] ; tmp [ 10 ] = src [ 8 ] * src [ 13 ] ; tmp [ 11 ] = src [ 9 ] * src [ 12 ] ; dst [ 0 ] = tmp [ 0 ] * src [ 5 ] + tmp [ 3 ] * src [ 6 ] + tmp [ 4 ] * src [ 7 ] ; dst [ 0 ] -= tmp [ 1 ] * src [ 5 ] + tmp [ 2 ] * src [ 6 ] + tmp [ 5 ] * src [ 7 ] ; dst [ 1 ] = tmp [ 1 ] * src [ 4 ] + tmp [ 6 ] * src [ 6 ] + tmp [ 9 ] * src [ 7 ] ; dst [ 1 ] -= tmp [ 0 ] * src [ 4 ] + tmp [ 7 ] * src [ 6 ] + tmp [ 8 ] * src [ 7 ] ; dst [ 2 ] = tmp [ 2 ] * src [ 4 ] + tmp [ 7 ] * src [ 5 ] + tmp [ 10 ] * src [ 7 ] ; dst [ 2 ] -= tmp [ 3 ] * src [ 4 ] + tmp [ 6 ] * src [ 5 ] + tmp [ 11 ] * src [ 7 ] ; dst [ 3 ] = tmp [ 5 ] * src [ 4 ] + tmp [ 8 ] * src [ 5 ] + tmp [ 11 ] * src [ 6 ] ; dst [ 3 ] -= tmp [ 4 ] * src [ 4 ] + tmp [ 9 ] * src [ 5 ] + tmp [ 10 ] * src [ 6 ] ; dst [ 4 ] = tmp [ 1 ] * src [ 1 ] + tmp [ 2 ] * src [ 2 ] + tmp [ 5 ] * src [ 3 ] ; dst [ 4 ] -= tmp [ 0 ] * src [ 1 ] + tmp [ 3 ] * src [ 2 ] + tmp [ 4 ] * src [ 3 ] ; dst [ 5 ] = tmp [ 0 ] * src [ 0 ] + tmp [ 7 ] * src [ 2 ] + tmp [ 8 ] * src [ 3 ] ; dst [ 5 ] -= tmp [ 1 ] * src [ 0 ] + tmp [ 6 ] * src [ 2 ] + tmp [ 9 ] * src [ 3 ] ; dst [ 6 ] = tmp [ 3 ] * src [ 0 ] + tmp [ 6 ] * src [ 1 ] + tmp [ 11 ] * src [ 3 ] ; dst [ 6 ] -= tmp [ 2 ] * src [ 0 ] + tmp [ 7 ] * src [ 1 ] + tmp [ 10 ] * src [ 3 ] ; dst [ 7 ] = tmp [ 4 ] * src [ 0 ] + tmp [ 9 ] * src [ 1 ] + tmp [ 10 ] * src [ 2 ] ; dst [ 7 ] -= tmp [ 5 ] * src [ 0 ] + tmp [ 8 ] * src [ 1 ] + tmp [ 11 ] * src [ 2 ] ; tmp [ 0 ] = src [ 2 ] * src [ 7 ] ; tmp [ 1 ] = src [ 3 ] * src [ 6 ] ; tmp [ 2 ] = src [ 1 ] * src [ 7 ] ; tmp [ 3 ] = src [ 3 ] * src [ 5 ] ; tmp [ 4 ] = src [ 1 ] * src [ 6 ] ; tmp [ 5 ] = src [ 2 ] * src [ 5 ] ; tmp [ 6 ] = src [ 0 ] * src [ 7 ] ; tmp [ 7 ] = src [ 3 ] * src [ 4 ] ; tmp [ 8 ] = src [ 0 ] * src [ 6 ] ; tmp [ 9 ] = src [ 2 ] * src [ 4 ] ; tmp [ 10 ] = src [ 0 ] * src [ 5 ] ; tmp [ 11 ] = src [ 1 ] * src [ 4 ] ; dst [ 8 ] = tmp [ 0 ] * src [ 13 ] + tmp [ 3 ] * src [ 14 ] + tmp [ 4 ] * src [ 15 ] ; dst [ 8 ] -= tmp [ 1 ] * src [ 13 ] + tmp [ 2 ] * src [ 14 ] + tmp [ 5 ] * src [ 15 ] ; dst [ 9 ] = tmp [ 1 ] * src [ 12 ] + tmp [ 6 ] * src [ 14 ] + tmp [ 9 ] * src [ 15 ] ; dst [ 9 ] -= tmp [ 0 ] * src [ 12 ] + tmp [ 7 ] * src [ 14 ] + tmp [ 8 ] * src [ 15 ] ; dst [ 10 ] = tmp [ 2 ] * src [ 12 ] + tmp [ 7 ] * src [ 13 ] + tmp [ 10 ] * src [ 15 ] ; dst [ 10 ] -= tmp [ 3 ] * src [ 12 ] + tmp [ 6 ] * src [ 13 ] + tmp [ 11 ] * src [ 15 ] ; dst [ 11 ] = tmp [ 5 ] * src [ 12 ] + tmp [ 8 ] * src [ 13 ] + tmp [ 11 ] * src [ 14 ] ; dst [ 11 ] -= tmp [ 4 ] * src [ 12 ] + tmp [ 9 ] * src [ 13 ] + tmp [ 10 ] * src [ 14 ] ; dst [ 12 ] = tmp [ 2 ] * src [ 10 ] + tmp [ 5 ] * src [ 11 ] + tmp [ 1 ] * src [ 9 ] ; dst [ 12 ] -= tmp [ 4 ] * src [ 11 ] + tmp [ 0 ] * src [ 9 ] + tmp [ 3 ] * src [ 10 ] ; dst [ 13 ] = tmp [ 8 ] * src [ 11 ] + tmp [ 0 ] * src [ 8 ] + tmp [ 7 ] * src [ 10 ] ; dst [ 13 ] -= tmp [ 6 ] * src [ 10 ] + tmp [ 9 ] * src [ 11 ] + tmp [ 1 ] * src [ 8 ] ; dst [ 14 ] = tmp [ 6 ] * src [ 9 ] + tmp [ 11 ] * src [ 11 ] + tmp [ 3 ] * src [ 8 ] ; dst [ 14 ] -= tmp [ 10 ] * src [ 11 ] + tmp [ 2 ] * src [ 8 ] + tmp [ 7 ] * src [ 9 ] ; dst [ 15 ] = tmp [ 10 ] * src [ 10 ] + tmp [ 4 ] * src [ 8 ] + tmp [ 9 ] * src [ 9 ] ; dst [ 15 ] -= tmp [ 8 ] * src [ 9 ] + tmp [ 11 ] * src [ 10 ] + tmp [ 5 ] * src [ 8 ] ; det = src [ 0 ] * dst [ 0 ] + src [ 1 ] * dst [ 1 ] + src [ 2 ] * dst [ 2 ] + src [ 3 ] * dst [ 3 ] ; if ( det == 0.0f ) { throw new runtimeexception ( "singular matrix is not invertible" ) ; } det = 1 / det ; for ( int j = 0 ; j < 16 ; j ++ ) { dst [ j ] *= det ; } return ret ; }
tr	5	public boolean isoverallocationsize ( map < string , string > record , date recievedatetime , int msgtarget ) { string sysid = record . get ( "sys" ) ; date one_minute_ago = new date ( recievedatetime . gettime ( ) - unsconsts . one_minute ) ; date one_hour_ago = new date ( recievedatetime . gettime ( ) - unsconsts . one_hour ) ; long to_day = date . parse ( new simpledateformat ( "yyyy/mm/dd" ) . format ( new date ( system . currenttimemillis ( ) ) ) + " 00:00:00" ) ; date today = new date ( to_day ) ; date currdatetime = new date ( recievedatetime . gettime ( ) + unsconsts . one_second ) ; boolean isover_in_minute = false ; boolean isover_in_hour = false ; boolean isover_in_day = false ; boolean isover_total_size = false ; if ( msgtarget == 1 || msgtarget == 3 ) { isover_in_minute = isoverallocationsizechecker ( "unsemaillog.findbydurationtime" , one_minute_ago , currdatetime , sysid , record . get ( "email" ) , unsconsts . max_in_minute ) ; if ( isover_in_minute ) { logger . log ( level . info , "in the last one minute email is over allocation size : {0}" , unsconsts . max_in_minute ) ; } ; isover_in_hour = isoverallocationsizechecker ( "unsemaillog.findbydurationtime" , one_hour_ago , currdatetime , sysid , record . get ( "email" ) , unsconsts . max_in_hour ) ; if ( isover_in_hour ) { logger . log ( level . info , "in the last hour email is over allocation size : {0}" , unsconsts . max_in_hour ) ; } ; isover_in_day = isoverallocationsizechecker ( "unsemaillog.findbydurationtime" , today , currdatetime , sysid , record . get ( "email" ) , unsconsts . max_in_day ) ; if ( isover_in_day ) { logger . log ( level . info , "email is over the allocation size : {0} today" , unsconsts . max_in_day ) ; } ; } if ( msgtarget == 2 || msgtarget == 3 ) { if ( msgtarget == 3 && ( isover_in_minute || isover_in_hour || isover_in_day ) ) { return true ; } isover_in_minute = isoverallocationsizechecker ( "unssmslog.findbydurationtime" , one_minute_ago , currdatetime , sysid , record . get ( "telno" ) , unsconsts . max_in_minute ) ; if ( isover_in_minute ) { logger . log ( level . info , "in the last one minute email is over allocation size : {0}" , unsconsts . max_in_minute ) ; } ; isover_in_hour = isoverallocationsizechecker ( "unssmslog.findbydurationtime" , one_hour_ago , currdatetime , sysid , record . get ( "telno" ) , unsconsts . max_in_hour ) ; if ( isover_in_hour ) { logger . log ( level . info , "in the last hour email is over allocation size : {0}" , unsconsts . max_in_hour ) ; } ; isover_in_day = isoverallocationsizechecker ( "unssmslog.findbydurationtime" , today , currdatetime , sysid , record . get ( "telno" ) , unsconsts . max_in_day ) ; if ( isover_in_day ) { logger . log ( level . info , "email is over the allocation size : {0} today" , unsconsts . max_in_day ) ; } ; } isover_total_size = isovertotalsizechecker ( record , today , currdatetime ) ; if ( isover_total_size ) { logger . log ( level . info , "the message send by {0} in the last hour is over the allocation size" , record . get ( "sys" ) ) ; } ; return isover_in_minute || isover_in_hour || isover_in_day || isover_total_size ; }
tr	8	public void keypressed ( keyevent e ) { if ( e . getkeychar ( ) == keyevent . vk_enter && kentta . gettext ( ) . length ( ) != 0 ) { if ( heitot == 3 ) { try { valinta = integer . parseint ( kentta . gettext ( ) ) - 1 ; if ( valinta >= 0 && valinta < yhdistelmat . size ( ) ) { pelaajat . get ( currentpelaaja ) . getvihko ( ) . setpisteet ( yhdistelmat . get ( valinta ) ) ; pelaaja1 . settext ( "pelaaja 1" + "\\n" + "\\n" + pelaajat . get ( 0 ) . getvihko ( ) . tostring ( ) ) ; pelaaja2 . settext ( "pelaaja 2" + "\\n" + "\\n" + pelaajat . get ( 1 ) . getvihko ( ) . tostring ( ) ) ; lock = false ; system . out . println ( "enter pressed" ) ; yhdistelmarivi . settext ( kentta . gettext ( ) ) ; save ( ) ; } } catch ( numberformatexception ex ) { yhdistelmarivi . settext ( "annettu komento ei ollut numero:" + "\\n" + "\\n" + pelaajat . get ( currentpelaaja ) . mahdollisetyhdistelmattostring ( ) ) ; } } } }
tr	2	public object mapfieldset ( fieldset fs ) { ledger item = new ledger ( ) ; int idx = 0 ; item . setreceiptdate ( fs . readdate ( idx ++ , date_pattern ) ) ; item . setmembername ( fs . readstring ( idx ++ ) ) ; item . setchecknumber ( fs . readstring ( idx ++ ) ) ; item . setcheckdate ( fs . readdate ( idx ++ , date_pattern ) ) ; item . setpaymenttype ( fs . readstring ( idx ++ ) ) ; try { decimalformat fmttr = new decimalformat ( dollar_pattern ) ; number number = fmttr . parse ( fs . readstring ( idx ++ ) ) ; item . setdepositamount ( number . doublevalue ( ) ) ; } catch ( parseexception e ) { item . setdepositamount ( 0 ) ; } try { decimalformat fmttr = new decimalformat ( dollar_pattern ) ; number number = fmttr . parse ( fs . readstring ( idx ++ ) ) ; item . setpaymentamount ( number . doublevalue ( ) ) ; } catch ( parseexception e ) { item . setpaymentamount ( 0 ) ; } return item ; }
tr	5	private static string sboxsubstitution ( ) { string [ ] [ ] data = new string [ 9 ] [ 4 ] ; data [ 0 ] [ 0 ] = "6-bit from a" ; data [ 0 ] [ 1 ] = "(b2<litcomma> b3<litcomma> b4<litcomma> b5)" ; data [ 0 ] [ 2 ] = "(column) in base 10" ; data [ 0 ] [ 3 ] = "in base 2" ; string out = "" ; int row , column , bounds = 0 ; string bits = "" ; for ( int i = 0 ; i < desconstants . sbox . size ( ) ; i ++ ) { bits = erxork . substring ( bounds , bounds + 6 ) ; data [ i + 1 ] [ 0 ] = bits ; row = integer . parseint ( "" + bits . charat ( 0 ) + bits . charat ( 5 ) , 2 ) ; column = integer . parseint ( bits . substring ( 1 , 5 ) , 2 ) ; data [ i + 1 ] [ 1 ] = bits . substring ( 1 , 5 ) ; data [ i + 1 ] [ 2 ] = integer . tostring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ; data [ i + 1 ] [ 3 ] = string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; out += string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; bounds += 6 ; } spreadsheet ss = new spreadsheet ( data ) ; jframe jf = new jframe ( ) ; jf . add ( ss ) ; jf . setsize ( 800 , 600 ) ; jf . settitle ( "s-box output" ) ; jf . setvisible ( true ) ; return out ; }
tr	10	@ suppresswarnings ( "static-access" ) public static void main ( string [ ] args ) throws exception { m . print ( "ebg installation assistant for ebg v1.3 (1.4.7) by florilu" , 1 ) ; system . out . println ( "options: " ) ; system . out . println ( "install:        [1]" ) ; system . out . println ( "uninstall:      [2]" ) ; system . out . println ( "install backup: [3]" ) ; system . out . println ( "exit:           [4]" ) ; system . out . print ( "choose optionnumber: " ) ; int num = scanner . nextint ( ) ; if ( num == 1 ) { if ( ! backupfolder . exists ( ) || ! backupfolderjar . exists ( ) || ! backupfolderautojar . exists ( ) || ! backupfoldercustomjar . exists ( ) || ! backupfoldermc . exists ( ) || ! backupfoldermcauto . exists ( ) || ! backupfoldermccustom . exists ( ) ) { if ( ! backupfolder . exists ( ) ) { install ( backupfolder ) ; m . print ( "backupfolder didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfolderjar . exists ( ) ) { install ( backupfolderjar ) ; m . print ( "backupfolder for jars didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfolderautojar . exists ( ) && backupfolder . exists ( ) ) { install ( backupfolderautojar ) ; m . print ( "autobackupfolder for jars didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfoldercustomjar . exists ( ) && backupfolder . exists ( ) ) { install ( backupfoldercustomjar ) ; m . print ( "cutombackupfolder for jars didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfoldermc . exists ( ) ) { install ( backupfoldermc ) ; m . print ( "backupfolder for minecraft folder didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfoldermcauto . exists ( ) ) { install ( backupfoldermcauto ) ; m . print ( "autobackupfolder for minecraft folder didn't exist<litcomma> created it!" , 1 ) ; } if ( ! backupfoldermccustom . exists ( ) ) { install ( backupfoldermccustom ) ; m . print ( "custombackupfolder for minecraft folder didn't exist<litcomma> created it!" , 1 ) ; } } m . print ( "" , 1 ) ; m . print ( "do you want to backup .minecraft or just the jar? (1 = jar<litcomma> 2 = .minecraft): " , 2 ) ; int mcjar = scanner . nextint ( ) ; if ( mcjar == 1 ) { m . print ( "do you want to create an custom backup<litcomma> or an automatic backup? (1 = auto<litcomma> 2 = custom): " , 2 ) ; int cuajar = scanner . nextint ( ) ; if ( cuajar == 1 ) { if ( backupfolderautojar . exists ( ) ) { file [ ] files = backupfolderautojar . listfiles ( ) ; int i = 0 ; for ( file file : files ) { if ( file . isfile ( ) ) { i ++ ; } } string mccopy = ( backupfolderautojar + "/backup" + i + ".jar" ) ; copyfile . copy ( copyfile . file ( minecraftstring ) , copyfile . file ( mccopy ) ) ; } } else if ( cuajar == 2 ) { m . print ( "type in a name for your backup: " , 1 ) ; string customname = bf . readline ( ) ; string mccopycustom = ( backupfoldercustomjar + "/" + customname + ".jar" ) ; copyfile . copy ( copyfile . file ( minecraftstring ) , copyfile . file ( mccopycustom ) ) ; } m . print ( "backupped jar!" , 1 ) ; } if ( mcjar == 2 ) { m . print ( "do you want to create an automatic or custom backup? (1 = auto<litcomma> 2 = custom): " , 2 ) ; int aucufo = scanner . nextint ( ) ; if ( aucufo == 1 ) { file [ ] files = backupfoldermcauto . listfiles ( ) ; int i = 1 ; for ( file file : files ) { if ( file . isfile ( ) ) { i ++ ; } } string out = ( outautopath + "/backup" + i + ".zip" ) ; file outfile = new file ( out ) ; zipfile . zip ( mainfolderfile , out ) ; m . print ( "" , 1 ) ; m . print ( "backupped minecraft main folder to: " + outfile . getabsolutepath ( ) , 1 ) ; m . print ( "" , 1 ) ; } else if ( aucufo == 2 ) { m . print ( "type in the name of your backup: " , 2 ) ; string customname = bf . readline ( ) ; string out = ( outcustompath + "/" + customname + ".zip" ) ; file outfile = new file ( out ) ; zipfile . zip ( mainfolderfile , out ) ; m . print ( "" , 1 ) ; m . print ( "backupped minecraft main folder to: " + outfile . getabsolutepath ( ) , 1 ) ; m . print ( "" , 1 ) ; } } minecraft . delete ( ) ; new main ( ) . extractarchive ( new file ( "files/install.zip" ) , new file ( path + "roaming/.minecraft/bin" ) ) ; system . out . println ( "extrabiomesgen has been installed." ) ; } if ( num == 2 ) { m . print ( "do you want to delete the backups?(1 = yes<litcomma> 2 = no): " , 2 ) ; int delback = scanner . nextint ( ) ; if ( delback == 1 ) { del ( backupfolder ) ; m . print ( "backups has been deleted." , 1 ) ; } if ( ! minecraft . exists ( ) ) { new main ( ) . extractarchive ( new file ( "files/refresh.zip" ) , new file ( path + "roaming/.minecraft/bin" ) ) ; system . out . println ( "ebg has been uninstalled!" ) ; } else { minecraft . delete ( ) ; new main ( ) . extractarchive ( new file ( "files/refresh.zip" ) , new file ( path + "roaming/.minecraft/bin" ) ) ; system . out . println ( "ebg has been uninstalled!" ) ; } } if ( num == 3 ) { int count = - 1 ; int filenumber = 0 ; file [ ] files = backupfolderautojar . listfiles ( ) ; for ( file file : files ) { filesave . add ( file ) ; count ++ ; } for ( int i = 0 ; i <= count ; i ++ ) { system . out . println ( filesave . get ( i ) . getname ( ) + " [" + ( i ) + "]" ) ; } system . out . print ( "which backup should be installed? : " ) ; int numberofbackup = scanner . nextint ( ) ; file ask = filesave . get ( numberofbackup ) ; string finalask = ask . getabsolutepath ( ) ; system . out . println ( finalask ) ; copyfile . copy ( copyfile . file ( finalask ) , copyfile . file ( minecraftstring ) ) ; system . out . println ( "installed backup!" ) ; } if ( num == 4 ) { m . print ( "quitting installer..." , 1 ) ; try { thread . sleep ( 500 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } system . exit ( 0 ) ; } }
tr	9	public double isexam ( final string examname ) { double result = - 1 ; double counter = 0 ; for ( final exam exam : exams ) { if ( exam . getname ( ) != null ) { if ( exam . getname ( ) . indexof ( examname ) != - 1 ) { result += exam . getmark ( ) != null ? exam . getmark ( ) : 0 ; counter ++ ; } } } if ( counter > 0 ) { result += 1 ; result = result / counter ; } return result ; }
tr	7	public void appendnextround ( round round ) { round nextround = new round ( ) ; rounds . add ( nextround ) ; int roundnumber = rounds . indexof ( nextround ) ; int gamecount = 0 ; for ( int i = 0 ; i < round . size ( ) ; i += 2 ) { game newgame = new game ( ) ; newgame . referee = scoreable ; game [ ] previousgames = new game [ ] { round . get ( i ) , round . get ( i + 1 ) } ; for ( game previousgame : previousgames ) previousgame . nextgame = newgame ; newgame . previousgames = previousgames ; newgame . name = string . format ( "r%d g%d" , roundnumber , gamecount ) ; nextround . add ( newgame ) ; gamecount ++ ; } if ( nextround . size ( ) == 1 ) return ; appendnextround ( nextround ) ; }
tr	8	protected static boolean groupable ( int numvar , int pattern , int prefix ) { if ( numvar == 0 ) { switch ( kmap [ reversedigit ( totalvar , 2 , prefix ) ] ) { case f : return ! isminterm ; case t : return isminterm ; case x : return true ; } } switch ( pattern % 3 ) { case 0 : return groupable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ; case 1 : return groupable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; default : if ( ! groupable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ) return false ; return groupable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; } }
tr	4	public static void generate ( string reportname , reportstypes type , map < string , object > params , outputstream out , connection conn ) throws filenotfoundexception , jrexception { reportfileutil rfile = reportfileutil . getreport ( reportname ) ; jasperprint jprint = jasperfillmanager . fillreport ( new fileinputstream ( rfile . getrelatorio ( ) ) , params , conn ) ; switch ( type ) { case pdf : makepdf ( jprint , out ) ; break ; case xls : makexls ( jprint , out ) ; break ; case html : makehtml ( jprint , out ) ; break ; case xml : makexml ( jprint , out ) ; break ; default : break ; } }
tr	6	public arraylist < int [ ] > nonfriendsmeetingfreq ( ) { int k = user . alluserset . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = i + 1 ; j < k ; j ++ ) { if ( nonfriend ( i , j ) && meetfreq . get ( i ) . get ( j ) > 0 ) { int [ ] tuple = { i , j , meetfreq . get ( i ) . get ( j ) } ; nonfriendmeeting . add ( tuple ) ; } } return nonfriendmeeting ; }
tr	6	@ eventhandler public void onprepareitemcraftevent ( prepareitemcraftevent event ) { if ( ! renameenabled ) { return ; } if ( event . getrecipe ( ) instanceof recipe ) { craftinginventory ci = event . getinventory ( ) ; itemstack result = ci . getresult ( ) ; if ( result == null ) { return ; } if ( result . gettype ( ) . equals ( material . skull_item ) ) { for ( itemstack i : ci . getcontents ( ) ) { if ( i . gettype ( ) . equals ( material . skull_item ) ) { if ( i . getdata ( ) . getdata ( ) != ( byte ) 3 ) { ci . setresult ( new itemstack ( material . air ) ) ; return ; } } } for ( itemstack i : ci . getcontents ( ) ) { if ( i . hasitemmeta ( ) && i . gettype ( ) . equals ( renameitem ) ) { itemmeta im = i . getitemmeta ( ) ; if ( im . hasdisplayname ( ) ) { itemstack res = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = res . getitemmeta ( ) ; ( ( skullmeta ) itemmeta ) . setowner ( im . getdisplayname ( ) ) ; res . setitemmeta ( itemmeta ) ; ci . setresult ( res ) ; break ; } } } } } }
tr	6	private void collect ( string rootpath , list < string > filenames ) { file dir = new file ( rootpath ) ; file [ ] files = dir . listfiles ( ) ; if ( files == null ) { return ; } for ( int i = 0 ; i < files . length ; i ++ ) { file file = files [ i ] ; if ( file . isdirectory ( ) ) { if ( ! file . ishidden ( ) ) { collect ( file . getabsolutepath ( ) , filenames ) ; } } else { if ( filepattern . matcher ( file . getabsolutepath ( ) ) . find ( ) ) { string strfilename = file . getabsolutepath ( ) ; filenames . add ( strfilename ) ; } } } }
tr	7	public int jump ( int [ ] a ) { if ( a . length <= 1 ) return 0 ; int left = 1 ; int end = a [ 0 ] ; int step = 1 ; while ( end < a . length ) { int max = 0 ; int i = left ; for ( i = left ; i <= end ; i ++ ) { if ( i >= a . length - 1 ) return step ; max = math . max ( max , i + a [ i ] ) ; } step ++ ; left = i ; end = max ; } return step ; }
tr	3	@ override public void visit ( page page ) { int docid = page . getweburl ( ) . getdocid ( ) ; string url = page . getweburl ( ) . geturl ( ) ; string domain = page . getweburl ( ) . getdomain ( ) ; string path = page . getweburl ( ) . getpath ( ) ; string subdomain = page . getweburl ( ) . getsubdomain ( ) ; string parenturl = page . getweburl ( ) . getparenturl ( ) ; if ( page . getparsedata ( ) instanceof htmlparsedata ) { htmlparsedata htmlparsedata = ( htmlparsedata ) page . getparsedata ( ) ; string text = htmlparsedata . gettext ( ) ; string html = htmlparsedata . gethtml ( ) ; list < weburl > links = htmlparsedata . getoutgoingurls ( ) ; string filename = docid + "_logger" ; try { if ( text . length ( ) != 0 ) { string parseddata = htmlparsedata . tostring ( ) ; if ( parseddata . trim ( ) . length ( ) != 0 || ! parseddata . equals ( " +" ) ) { system . out . println ( "=============" ) ; system . out . println ( "=============" ) ; system . out . println ( "docid: " + docid ) ; system . out . println ( "url: " + url ) ; system . out . println ( "domain: '" + domain + "'" ) ; system . out . println ( "sub-domain: '" + subdomain + "'" ) ; system . out . println ( "path: '" + path + "'" ) ; system . out . println ( "parent page: " + parenturl ) ; system . out . println ( "text length: " + text . length ( ) ) ; system . out . println ( "html length: " + html . length ( ) ) ; system . out . println ( "number of outgoing links: " + links . size ( ) ) ; arraylist < string > extracts = gettagcontents ( jsoup . parse ( html ) ) ; string title = extracts . get ( 0 ) ; string h1 = extracts . get ( 1 ) ; string h2 = extracts . get ( 2 ) ; string h3 = extracts . get ( 3 ) ; string bold = extracts . get ( 4 ) ; string strong = extracts . get ( 5 ) ; string em = extracts . get ( 6 ) ; string anchortext = extracts . get ( 7 ) ; parseddata = parsedata ( parseddata ) ; writeseperatefile ( docid , url , path , parenturl , title , h1 , h2 , h3 , bold , strong , em , anchortext , parseddata , filename ) ; writesinglefile ( docid , url , path , parenturl , title , h1 , h2 , h3 , bold , strong , em , anchortext , parseddata ) ; filewriter fstream_answers = new filewriter ( "urlnames" , true ) ; bufferedwriter out_answers = new bufferedwriter ( fstream_answers ) ; out_answers . write ( url ) ; out_answers . newline ( ) ; out_answers . close ( ) ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	4	private static void ints_linkedlist ( ) { int [ ] intarray = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 } ; stackofints_linkedlist intnode = new stackofints_linkedlist ( ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { system . out . println ( "node item = " + intnode . n + " ;" ) ; intnode . push ( intarray [ i ] ) ; } system . out . println ( "-------------------------------------" ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { int result = intnode . pop ( ) ; system . out . println ( "node item = " + intnode . n + " ; value = " + result ) ; } }
tr	5	@ requestmapping ( applicationconstants . create_usr ) @ responsebody public object createuser ( @ requestparam ( "name" ) string name , @ requestparam ( "email" ) string email , @ requestparam ( "password" ) string password ) { user user = new user ( ) ; map < object , string > errormap = new hashmap < object , string > ( ) ; if ( name == null || "" . equals ( name ) ) { errormap . put ( 1 , "please enter name" ) ; } if ( email == null || "" . equals ( email ) ) { errormap . put ( 2 , "please enter email" ) ; } if ( password == null || "" . equals ( password ) ) { errormap . put ( 3 , "please enter password" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { user . setname ( name ) ; user . setemail ( email ) ; user . setpassword ( password ) ; user . setcreateddate ( new date ( ) . tostring ( ) ) ; user . setstatus ( applicationconstants . status_active ) ; userdao . save ( user ) ; return user ; } }
tr	2	private double calculatescore ( team home , team away , hashtable < string , compiledstat > compiledstats , hashtable < string , string > summary ) { double basepts = 0.4 * ( 0.4 * home . getstat ( "ppg" ) + 0.6 * away . getstat ( "opp ppg" ) ) ; double pts = basepts ; double fgbonus = basepts * home . getstat ( "fg%" ) * 0.01 ; pts += fgbonus ; double winbonus = 0.1 * basepts * home . getstat ( "win %" ) * 0.01 ; pts += winbonus ; double turnoverlostpoints = - 2.0 * ( home . getstat ( "topg" ) + away . getstat ( "stpg" ) ) ; pts += turnoverlostpoints ; double turnovergainedpoints = 2.0 * ( home . getstat ( "stpg" ) + away . getstat ( "topg" ) ) ; pts += turnovergainedpoints ; double pfpts = 2 * home . getstat ( "ft%" ) * 0.01 * away . getstat ( "pfpg" ) ; pts += pfpts ; double reboundpts = 2.0 * ( home . getstat ( "rpg" ) - away . getstat ( "rpg" ) ) ; pts += reboundpts ; double blockpts = 2.0 * ( home . getstat ( "bkpg" ) - away . getstat ( "bkpg" ) ) ; pts += blockpts ; summary . put ( "base pts" , basepts . tostring ( ) ) ; summary . put ( "fg bonus" , fgbonus . tostring ( ) ) ; summary . put ( "win bonus" , winbonus . tostring ( ) ) ; summary . put ( "to pts" , turnovergainedpoints . tostring ( ) ) ; summary . put ( "to pts lost" , turnoverlostpoints . tostring ( ) ) ; summary . put ( "pf pts" , pfpts . tostring ( ) ) ; summary . put ( "rb pts" , reboundpts . tostring ( ) ) ; summary . put ( "blk pts" , blockpts . tostring ( ) ) ; summary . put ( "pts" , pts . tostring ( ) ) ; summary . put ( "team" , home . tostring ( ) ) ; return pts ; }
tr	7	public static void main ( string [ ] args ) throws ioexception , interruptedexception { crawlercontext context = new crawlercontext ( ) ; context . submittask ( new processabc ( "http://www.nhl.com/ice/playersearch.htm" ) ) ; long starttime = system . currenttimemillis ( ) ; int numberofthreads = 80 ; list < thread > workerthreads = new arraylist < thread > ( ) ; for ( int i = 0 ; i < numberofthreads ; ++ i ) { thread thread = new thread ( new workerrunnable ( context ) ) ; thread . start ( ) ; workerthreads . add ( thread ) ; } for ( thread thread : workerthreads ) { thread . join ( ) ; } long duration = system . currenttimemillis ( ) - starttime ; system . out . printf ( "finished in %d seconds\\n" , duration / 1000 ) ; }
tr	6	public void logpacket ( datagrampacket packet , inetaddress src , int srcport , inetaddress dst , int dstport ) { if ( ! init ) init ( ) ; int ts_sec = ( int ) ( ( system . currenttimemillis ( ) ) / 1000 ) ; int ts_usec = ( int ) ( ( system . nanotime ( ) ) / 1000 ) % 1000000 ; try { out . writeint ( ts_sec ) ; out . writeint ( ts_usec ) ; byte [ ] bytes = encapsulateip ( packet , src , srcport , dst , dstport ) ; out . writeint ( bytes . length & 0xffff ) ; out . writeint ( bytes . length ) ; out . flush ( ) ; if ( bytes . length > 0 ) out . write ( bytes , 0 , bytes . length & 0xffff ) ; out . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	10	public int numdecodings ( string s ) { if ( s . length ( ) == 0 ) return 0 ; int [ ] num = new int [ s . length ( ) ] ; if ( s . charat ( 0 ) > '0' ) num [ 0 ] = 1 ; else num [ 0 ] = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int path1 = 0 , path2 = 0 ; if ( s . charat ( i ) > '0' ) path1 = num [ i - 1 ] ; if ( ( s . charat ( i ) <= '6' && s . charat ( i - 1 ) == '2' ) || s . charat ( i - 1 ) == '1' ) { if ( i == 1 ) path2 = 1 ; else path2 = num [ i - 2 ] ; } num [ i ] = path1 + path2 ; } return num [ s . length ( ) - 1 ] ; }
tr	9	private static char addandcheckwrap ( char c , int currentchar , int [ ] steps , boolean right ) { int c = ( ( int ) c ) ; int loop ; int mod = ( currentchar % steps . length ) ; if ( mod == 0 ) loop = steps [ steps . length - 1 ] ; else loop = steps [ ( mod - 1 ) ] ; if ( isalphanumericcharacter ( c ) ) { if ( right ) { for ( int i = 0 ; i < loop ; i ++ ) { c ++ ; if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) '9' ) + 1 ) ) c = ( ( int ) '0' ) ; } } else { for ( int i = loop ; i > 0 ; i -- ) { c -- ; if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) '0' ) - 1 ) ) c = ( ( int ) '9' ) ; } } } return ( ( char ) c ) ; }
tr	10	private int check ( move move , int incx , int incy , tkind kind , boolean set ) { tkind opponent ; int x = move . i ; int y = move . j ; if ( kind == tkind . n ) { opponent = tkind . b ; } else { opponent = tkind . n ; } int n_inc = 0 ; x += incx ; y += incy ; while ( ( x < 8 ) && ( x >= 0 ) && ( y < 8 ) && ( y >= 0 ) && ( board [ x ] [ y ] == opponent ) ) { x += incx ; y += incy ; n_inc ++ ; } if ( ( n_inc != 0 ) && ( x < 8 ) && ( x >= 0 ) && ( y < 8 ) && ( y >= 0 ) && ( board [ x ] [ y ] == kind ) ) { if ( set ) { for ( int j = 1 ; j <= n_inc ; j ++ ) { x -= incx ; y -= incy ; set ( new move ( x , y ) , kind ) ; } } return n_inc ; } else { return 0 ; } }
tr	1	@ test public void test ( ) throws exception { url pdmlurl = rtpextractertest . class . getresource ( "sipcall.pdml" ) ; assert . assertnotnull ( pdmlurl ) ; pdml pdml = new pdmlreader ( ) . unmarshall ( pdmlurl ) ; assert . assertnotnull ( pdml ) ; rtpstream [ ] streams = new rtpextracter ( ) . parse ( pdml ) ; assert . assertnotnull ( streams ) ; assert . assertequals ( 2 , streams . length ) ; assert . assertequals ( "ce8947be" , streams [ 0 ] . getssrc ( ) ) ; assert . assertequals ( "607f30aa" , streams [ 1 ] . getssrc ( ) ) ; assert . assertequals ( 700 , streams [ 0 ] . getpackets ( ) . length ) ; assert . assertequals ( 707 , streams [ 1 ] . getpackets ( ) . length ) ; assert . assertarrayequals ( new byte [ ] { 0x08 , 0x0b , ( byte ) 0xe4 , 0x53 , 0x14 , 0x7e , 0x10 } , streams [ 0 ] . getpackets ( ) [ 0 ] . getpayload ( ) ) ; }
tr	9	public int [ ] [ ] twodconvolution ( int [ ] [ ] img , int [ ] [ ] kernal ) { int aheight = img . length ; int awidth = img [ 0 ] . length ; int bheight = kernal . length ; int bwidth = kernal [ 0 ] . length ; int kcenterx = ( int ) math . floor ( bwidth / 2 ) ; int kcentery = ( int ) math . floor ( bheight / 2 ) ; for ( int i = 0 ; i < awidth ; i ++ ) { for ( int j = 0 ; j < aheight ; j ++ ) { int val = 0 ; for ( int k = 0 ; k < bwidth ; k ++ ) { for ( int l = 0 ; l < bheight ; l ++ ) { if ( ( j - ( l - kcentery ) ) >= 0 && ( i - ( k - kcenterx ) ) >= 0 ) { val = val + kernal [ k ] [ j ] * img [ j - ( l - kcentery ) ] [ i - ( k - kcenterx ) ] ; } } } } } int [ ] [ ] result = new int [ aheight ] [ awidth ] ; return result ; }
tr	7	@ override public void handle ( ) throws exception { byte pid = in . readbyte ( ) ; if ( ! ( pid == 5 || pid == 7 ) ) { server . error ( string . format ( "%s got wrong packet id: %u02x" , this . getclass ( ) . getsimplename ( ) , pid ) ) ; in . close ( ) ; return ; } if ( pid == 5 ) { in . readlong ( ) ; in . readlong ( ) ; byte version = in . readbyte ( ) ; if ( version != constants . raknet_version ) { packet ipv = new packetincompatibleprotocolversion ( ip , port ) ; ipv . construct ( ) ; ipv . send ( ) ; in . close ( ) ; return ; } short mtu = ( short ) ( data . length - 18 ) ; packet reply = new packetopenconnectionreply ( ip , port ) ; reply . construct ( false , mtu ) ; reply . send ( ) ; } else if ( pid == 7 ) { in . readlong ( ) ; in . readlong ( ) ; in . readbyte ( ) ; in . readint ( ) ; in . readshort ( ) ; short mtu = in . readshort ( ) ; long clientid = in . readlong ( ) ; server . clients . put ( ip . hashcode ( ) + port , new entityplayer ( clientid , ip , port , mtu ) ) ; server . debug ( "adding client from " + ip + ":" + port ) ; server . log ( string . format ( "%016x logged in from %s:%d with mtu %d" , clientid , ip , port , mtu ) ) ; packet reply = new packetopenconnectionreply ( ip , port ) ; reply . construct ( true , ( short ) port , mtu ) ; reply . send ( ) ; } }
tr	4	public string classify ( instance example ) { string childexampleattributevalue = example . attributes . get ( attribute . index ) ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { for ( dectreenode childnode : children ) { if ( "a" . equals ( childnode . parentattributevalue ) == ( integer . parseint ( childexampleattributevalue ) < midpoint ) ) { if ( childnode instanceof internaldectreenode ) { return ( ( internaldectreenode ) childnode ) . classify ( example ) ; } else { return childnode . label ; } } } } return label ; }
tr	1	public loginframe ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } getcontentpane ( ) . setfont ( arial ) ; settitle ( "ggc chat login" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 270 , 297 ) ; setresizable ( false ) ; setlocationrelativeto ( null ) ; getcontentpane ( ) . setlayout ( null ) ; jlabel lblusername = new jlabel ( "username" ) ; lblusername . setfont ( arial ) ; lblusername . setbounds ( 88 , 21 , 71 , 14 ) ; getcontentpane ( ) . add ( lblusername ) ; txtusername = new jtextfield ( ) ; txtusername . setfont ( arial ) ; txtusername . setbounds ( 52 , 52 , 149 , 20 ) ; getcontentpane ( ) . add ( txtusername ) ; txtusername . setcolumns ( 10 ) ; jlabel lblservip = new jlabel ( "server ip" ) ; lblservip . setfont ( arial ) ; lblservip . setbounds ( 88 , 83 , 64 , 14 ) ; getcontentpane ( ) . add ( lblservip ) ; txtservip = new jtextfield ( ) ; txtservip . setfont ( arial ) ; txtservip . setbounds ( 52 , 108 , 149 , 20 ) ; getcontentpane ( ) . add ( txtservip ) ; txtservip . setcolumns ( 10 ) ; lblservport = new jlabel ( "server port" ) ; lblservport . setfont ( arial ) ; lblservport . setbounds ( 88 , 139 , 74 , 14 ) ; getcontentpane ( ) . add ( lblservport ) ; txtservport = new jtextfield ( ) ; txtservport . setfont ( arial ) ; txtservport . setbounds ( 52 , 164 , 149 , 20 ) ; getcontentpane ( ) . add ( txtservport ) ; txtservport . setcolumns ( 10 ) ; jbutton btnconnect = new jbutton ( "connect" ) ; btnconnect . setfont ( arial ) ; btnconnect . setbounds ( 83 , 212 , 89 , 23 ) ; btnconnect . addactionlistener ( this ) ; getcontentpane ( ) . add ( btnconnect ) ; }
tr	6	public void run ( ) { pruebathreads11 . sett ( pruebathreads11 . gett ( ) + 1 ) ; while ( cont >= 0 ) { string s = pruebathreads11 . getclase ( ) ; if ( s == null ) { system . out . println ( this . id + " - " + cont + " sin ultima lectura" ) ; } else { system . out . println ( this . id + " - " + cont + " ultima escritura " + s ) ; } pruebathreads11 . setclase ( id ) ; if ( cont == 0 ) { int r = pruebathreads11 . gett ( ) ; pruebathreads11 . sett ( r - 1 ) ; system . out . println ( "ultima escritura " + pruebathreads11 . getclase ( ) + " - " + ( r - 1 ) + " threads activos" ) ; } else { delaysegundo ( ) ; } cont -- ; } }
tr	8	public static void evaluate ( ) { system . out . printf ( "%-7s \\t\\t %s \\t %s \\t %s \\t %s \\t %s \\t %s \\n" , "label" , "precision" , "recall" , "f1" , "correctlabelcounts" , "predictedlabelcounts" , "labelcounts" ) ; double totalcorrectcount = 0 ; double totalpredictedcount = 0 ; double totallabelcount = 0 ; for ( string label : labelcounts . keyset ( ) ) { if ( label . equals ( "o" ) ) continue ; double precision ; double recall ; double f1 ; double correctcount ; double predictedcount ; double labelcount ; if ( correctlabelcounts . containskey ( label ) && predictedlabelcounts . containskey ( label ) ) { correctcount = correctlabelcounts . get ( label ) . doublevalue ( ) ; predictedcount = predictedlabelcounts . get ( label ) . doublevalue ( ) ; precision = correctcount / predictedcount ; } else { correctcount = 0 ; predictedcount = 0 ; precision = - 1 ; } if ( correctlabelcounts . containskey ( label ) && labelcounts . containskey ( label ) ) { correctcount = correctlabelcounts . get ( label ) . doublevalue ( ) ; labelcount = labelcounts . get ( label ) . doublevalue ( ) ; recall = correctcount / labelcount ; } else { correctcount = 0 ; labelcount = 0 ; recall = - 1 ; } if ( precision > 0 && recall > 0 ) { f1 = 2 / ( 1 / precision + 1 / recall ) ; } else { f1 = - 1 ; } totalcorrectcount += correctcount ; totalpredictedcount += predictedcount ; totallabelcount += labelcount ; system . out . printf ( "%-7s \\t\\t %f \\t %f \\t %f \\t %f \\t %f \\t %f \\n" , label , precision , recall , f1 , correctcount , predictedcount , labelcount ) ; } double totalprecision = totalcorrectcount / totalpredictedcount ; double totalrecall = totalcorrectcount / totallabelcount ; double totalf1 = 2 / ( 1 / totalprecision + 1 / totalrecall ) ; system . out . printf ( "%-7s \\t\\t %f \\t %f \\t %f \\t %f \\t %f \\t %f \\n" , "total" , totalprecision , totalrecall , totalf1 , totalcorrectcount , totalpredictedcount , totallabelcount ) ; }
tr	3	public static list < string > getdata ( string filepath ) { arraylist < string > sentencedata = new arraylist < string > ( ) ; try { file rawdata = new file ( filepath ) ; fileinputstream inputstream = new fileinputstream ( rawdata ) ; stringbuilder sentence = new stringbuilder ( ) ; while ( true ) { int character = inputstream . read ( ) ; if ( character == end_of_file ) { sentencedata . add ( sentence . tostring ( ) ) ; break ; } else if ( character == newline ) { sentencedata . add ( sentence . tostring ( ) ) ; sentence = new stringbuilder ( ) ; } else { sentence . append ( ( char ) character ) ; } } for ( string str : sentencedata ) { str = str . tolowercase ( ) ; } inputstream . close ( ) ; } catch ( filenotfoundexception e ) { } catch ( ioexception e ) { e . printstacktrace ( ) ; } return sentencedata ; }
tr	10	@ override public void mouseclicked ( mouseevent e ) { boolean b = false ; for ( int i = 1 ; i < labels . size ( ) - 1 ; i ++ ) { for ( int j = 1 ; j < labels . get ( i ) . size ( ) - 1 ; j ++ ) { if ( e . getsource ( ) == labels . get ( i ) . get ( j ) && ( i != ligne_pivot || j != col_pivot ) ) { if ( float . parsefloat ( data . get ( i ) . get ( j ) ) > 0 ) { if ( float . parsefloat ( data . get ( i ) . get ( j ) ) == 1 ) { for ( int k = 1 ; k < data . size ( ) ; k ++ ) { if ( k != i && float . parsefloat ( data . get ( k ) . get ( j ) ) != 0 ) { b = true ; break ; } } } else { b = true ; } if ( b ) { string msg ; if ( ligne_pivot == 0 && col_pivot == 0 ) msg = "etes vous sur de vouloir choisir cette cellule comme pivot ?" ; else msg = "souhaitez vous changer de pivot et choisir cette cellule comme nouveau pivot ?" ; if ( joptionpane . showconfirmdialog ( this , msg ) == joptionpane . ok_option ) { colorierpivot ( i + "<litcomma>" + j ) ; } } else { joptionpane . showmessagedialog ( this , "vous ne pouvez pas choisir ce pivot" ) ; } } else { joptionpane . showmessagedialog ( this , "vous ne pouvez pas choisir un pivot nul ou n\xe9gatif" ) ; } } } } }
tr	3	public void draw ( graphics g ) { float [ ] points = new float [ 6 ] ; points [ 0 ] = ( size * helper . cos ( 0 + rotation ) + location [ 0 ] ) ; points [ 1 ] = ( size * helper . sin ( 0 + rotation ) + location [ 1 ] ) ; points [ 2 ] = ( size * helper . cos ( 130 + rotation ) + location [ 0 ] ) ; points [ 3 ] = ( size * helper . sin ( 130 + rotation ) + location [ 1 ] ) ; points [ 4 ] = ( size * helper . cos ( 230 + rotation ) + location [ 0 ] ) ; points [ 5 ] = ( size * helper . sin ( 230 + rotation ) + location [ 1 ] ) ; shape = new polygon ( points ) ; g . setcolor ( color . green ) ; g . fill ( shape ) ; circle circle = new circle ( location [ 0 ] , location [ 1 ] , range ) ; g . draw ( circle ) ; }
tr	7	public boolean isvalidsudoku ( char [ ] [ ] board ) { boolean [ ] used = new boolean [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { for ( int k = 0 ; k < 9 ; k ++ ) used [ k ] = false ; for ( int j = 0 ; j < 9 ; j ++ ) { char value = board [ i ] [ j ] ; if ( value != '.' ) { int number = character . getnumericvalue ( value ) ; if ( used [ number ] == false ) used [ number ] = true ; else return false ; } } for ( int k = 0 ; k < 9 ; k ++ ) used [ k ] = false ; for ( int j = 0 ; j < 9 ; j ++ ) { char value = board [ j ] [ i ] ; if ( value != '.' ) { int number = character . getnumericvalue ( value ) ; if ( used [ number ] == false ) used [ number ] = true ; else return false ; } } } for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { int rstart = x * 3 ; int rend = rstart + 3 ; int cstart = y * 3 ; int cend = cstart + 3 ; for ( int k = 0 ; k < 9 ; k ++ ) used [ k ] = false ; for ( int i = rstart ; i < rend ; i ++ ) { for ( int j = cstart ; j < cend ; j ++ ) { char value = board [ j ] [ i ] ; if ( value != '.' ) { int number = character . getnumericvalue ( value ) ; if ( used [ number ] == false ) used [ number ] = true ; else return false ; } } } } } return true ; }
tr	9	private boolean istitlegood ( ) { boolean titlegood = false ; int start = - 1 ; for ( int i = 0 ; i < this . currenttitle . length ( ) ; i ++ ) { if ( ! trie . isasciialpha ( this . currenttitle . charat ( i ) ) ) { if ( - 1 != start ) { string word = this . currenttitle . substring ( start , i ) ; titlegood = this . t . searchword ( word ) ; if ( titlegood ) { return true ; } start = - 1 ; } } else { start = ( - 1 == start ) ? i : start ; } } if ( - 1 != start ) { return this . t . searchword ( this . currenttitle . substring ( start , this . currenttitle . length ( ) ) ) ; } return false ; }
tr	5	@ override public boolean izbacikb ( arraylist list , string nazivspremista ) { if ( list . isempty ( ) ) { system . out . println ( "datoteka prevelika za spremiste" ) ; return true ; } else { arraylist jednaki = new arraylist ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { r = ( resource ) list . get ( i ) ; broj = r . getbrojkoristenja ( ) ; if ( broj == najkoristeniji ) { jednaki . add ( r ) ; } else if ( broj > najkoristeniji ) { najkoristeniji = broj ; najr = r ; jednaki = new arraylist ( ) ; jednaki . add ( r ) ; } } if ( jednaki . size ( ) > 1 ) { izbaci ( jednaki , nazivspremista ) ; } else { obrisi ( najr , nazivspremista ) ; } return false ; } }
tr	10	static arraylist < string > getallmoves ( int i , int j ) throws ioexception { arraylist < string > listofmoves = new arraylist < > ( ) ; string howtomove ; int fata = 0 , spate = 0 , diag = 0 , pd = 0 , stanga = 0 , dreapta = 0 , pf = 0 , p2f = 0 , speciall = 0 , ifata , ispate , idiag , istanga , idreapta , specialrege = 0 ; howtomove = getvalid ( i , j ) ; logger . write ( "logger::pieces.java::am primit miscarile:" + howtomove + "::pentru piesa::" + ( char ) board . board [ i ] [ j ] ) ; if ( howtomove . indexof ( "specialrege" ) != - 1 ) { fata = 1 ; spate = 1 ; diag = 1 ; stanga = 1 ; dreapta = 1 ; specialrege = 1 ; } if ( ( ifata = howtomove . indexof ( "fata" ) ) != - 1 ) { fata = howtomove . charat ( ifata - 1 ) ; } if ( ( ispate = howtomove . indexof ( "spate" ) ) != - 1 ) { spate = howtomove . charat ( ispate - 1 ) ; } if ( ( idiag = howtomove . indexof ( "diag" ) ) != - 1 ) { diag = howtomove . charat ( idiag - 1 ) ; } if ( ( howtomove . indexof ( "p2f" ) ) != - 1 ) { p2f = 1 ; } if ( ( howtomove . indexof ( "pd" ) ) != - 1 ) { pd = 1 ; } if ( ( howtomove . indexof ( "pf" ) ) != - 1 ) { pf = 1 ; } if ( ( howtomove . indexof ( "speciall" ) ) != - 1 ) { speciall = 1 ; } if ( ( istanga = howtomove . indexof ( "stanga" ) ) != - 1 ) { stanga = howtomove . charat ( istanga - 1 ) ; } if ( ( idreapta = howtomove . indexof ( "dreapta" ) ) != - 1 ) { dreapta = howtomove . charat ( idreapta - 1 ) ; } if ( "black" . equals ( engine . color ) ) { if ( fata != 0 ) { for ( int k = 1 ; k <= fata ; k ++ ) { if ( ( ! board . isblackpiece ( i + k , j ) ) && ( ! board . outofbounds ( i + k , j ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i + 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) && ( board . board [ i + 2 ] [ j + 1 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ; } if ( board . iswhitepiece ( i + k , j ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in fata mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ; } else { break ; } } } if ( spate != 0 ) { for ( int k = 1 ; k <= spate ; k ++ ) { if ( ( ! board . isblackpiece ( i - k , j ) ) && ( ! board . outofbounds ( i - k , j ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i - 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) && ( board . board [ i - 2 ] [ j + 1 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ; } if ( board . iswhitepiece ( i - k , j ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in spate mutarea::" + ( board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ) ; } else { break ; } } } if ( stanga != 0 ) { for ( int k = 1 ; k <= stanga ; k ++ ) { if ( ( ! board . isblackpiece ( i , j + k ) ) && ( ! board . outofbounds ( i , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i - 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j + 2 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } if ( board . iswhitepiece ( i , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in stanga mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } else { break ; } } } if ( dreapta != 0 ) { for ( int k = 1 ; k <= dreapta ; k ++ ) { if ( ( ! board . isblackpiece ( i , j - k ) ) && ( ! board . outofbounds ( i , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i - 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j - 2 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } if ( board . iswhitepiece ( i , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in dreapta mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } else { break ; } } } if ( diag != 0 ) { for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . isblackpiece ( i + k , j + k ) ) && ( ! board . outofbounds ( i + k , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j + 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } if ( board . iswhitepiece ( i + k , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . isblackpiece ( i + k , j - k ) ) && ( ! board . outofbounds ( i + k , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j - 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } if ( board . iswhitepiece ( i + k , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . isblackpiece ( i - k , j - k ) ) && ( ! board . outofbounds ( i - k , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j - 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } if ( board . iswhitepiece ( i - k , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . isblackpiece ( i - k , j + k ) ) && ( ! board . outofbounds ( i - k , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j + 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } if ( board . iswhitepiece ( i - k , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } else { break ; } } } if ( pf != 0 ) { if ( ( ! board . isblackpiece ( i + 1 , j ) ) && ( ! board . iswhitepiece ( i + 1 , j ) ) && ( ! board . outofbounds ( i + 1 , j ) ) && ( board . board [ i + 1 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j ) ) ; } } if ( p2f != 0 ) { if ( ( ! board . iswhitepiece ( i + 1 , j ) ) && ( ! board . isblackpiece ( i + 1 , j ) ) && ( board . board [ i + 1 ] [ j ] != 'r' ) ) { if ( ( ! board . iswhitepiece ( i + 2 , j ) ) && ( ! board . isblackpiece ( i + 2 , j ) ) && ( board . board [ i + 2 ] [ j ] != 'r' ) ) { random idk = new random ( ) ; int ceva = idk . nextint ( 2 ) ; if ( ceva == 1 ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 2 , j ) ) ; } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j ) ) ; } } } if ( pd != 0 ) { if ( ( board . iswhitepiece ( i + 1 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j + 1 ) ) ; } if ( ( board . iswhitepiece ( i + 1 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j - 1 ) ) ; } } if ( speciall != 0 ) { if ( ( ! board . isblackpiece ( i - 2 , j + 1 ) ) && ( ! board . outofbounds ( i - 2 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 2 , j + 1 ) ) ; } if ( ( ! board . isblackpiece ( i - 1 , j + 2 ) ) && ( ! board . outofbounds ( i - 1 , j + 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j + 2 ) ) ; } if ( ( ! board . isblackpiece ( i + 1 , j + 2 ) ) && ( ! board . outofbounds ( i + 1 , j + 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j + 2 ) ) ; } if ( ( ! board . isblackpiece ( i + 2 , j + 1 ) ) && ( ! board . outofbounds ( i + 2 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 2 , j + 1 ) ) ; } if ( ( ! board . isblackpiece ( i + 2 , j - 1 ) ) && ( ! board . outofbounds ( i + 2 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 2 , j - 1 ) ) ; } if ( ( ! board . isblackpiece ( i + 1 , j - 2 ) ) && ( ! board . outofbounds ( i + 1 , j - 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j - 2 ) ) ; } if ( ( ! board . isblackpiece ( i - 1 , j - 2 ) ) && ( ! board . outofbounds ( i - 1 , j - 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j - 2 ) ) ; } if ( ( ! board . isblackpiece ( i - 2 , j - 1 ) ) && ( ! board . outofbounds ( i - 2 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 2 , j - 1 ) ) ; } } } else { if ( fata != 0 ) { for ( int k = 1 ; k <= fata ; k ++ ) { if ( ( ! board . iswhitepiece ( i - k , j ) ) && ( ! board . outofbounds ( i - k , j ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i - 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) && ( board . board [ i - 2 ] [ j - 1 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ; } if ( board . isblackpiece ( i - k , j ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in fata mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i - k , j ) ) ; } else { break ; } } } if ( spate != 0 ) { for ( int k = 1 ; k <= spate ; k ++ ) { if ( ( ! board . iswhitepiece ( i + k , j ) ) && ( ! board . outofbounds ( i + k , j ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i + 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) && ( board . board [ i + 2 ] [ j - 1 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ; } if ( board . isblackpiece ( i + k , j ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in spate mutarea::" + ( board . translateposition ( i , j ) + board . translateposition ( i + k , j ) ) ) ; } else { break ; } } } if ( stanga != 0 ) { for ( int k = 1 ; k <= stanga ; k ++ ) { if ( ( ! board . iswhitepiece ( i , j - k ) ) && ( ! board . outofbounds ( i , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i + 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j - 2 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } if ( board . isblackpiece ( i , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in stanga mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i , j - k ) ) ; } else { break ; } } } if ( dreapta != 0 ) { for ( int k = 1 ; k <= dreapta ; k ++ ) { if ( ( ! board . iswhitepiece ( i , j + k ) ) && ( ! board . outofbounds ( i , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i + 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j + 2 ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } if ( board . isblackpiece ( i , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in dreapta mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i , j + k ) ) ; } else { break ; } } } if ( diag != 0 ) { for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . iswhitepiece ( i + k , j + k ) ) && ( ! board . outofbounds ( i + k , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j + 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } if ( board . isblackpiece ( i + k , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i + k , j + k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . iswhitepiece ( i + k , j - k ) ) && ( ! board . outofbounds ( i + k , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i + 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j - 2 ] != 'r' ) && ( board . board [ i + 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i + 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } if ( board . isblackpiece ( i + k , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i + k , j - k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . iswhitepiece ( i - k , j - k ) ) && ( ! board . outofbounds ( i - k , j - k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j - 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j - 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j - 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j - 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } if ( board . isblackpiece ( i - k , j - k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i - k , j - k ) ) ; } else { break ; } } for ( int k = 1 ; k <= diag ; k ++ ) { if ( ( ! board . iswhitepiece ( i - k , j + k ) ) && ( ! board . outofbounds ( i - k , j + k ) ) ) { if ( ( specialrege == 1 ) ) { if ( ( board . board [ i ] [ j + 2 ] != 'r' ) && ( board . board [ i - 1 ] [ j + 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j + 2 ] != 'r' ) && ( board . board [ i - 2 ] [ j + 1 ] != 'r' ) && ( board . board [ i - 2 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } if ( board . isblackpiece ( i - k , j + k ) ) { break ; } logger . write ( "looger::pieces.java::am adaugat in diag mutarea::" + board . translateposition ( i , j ) + board . translateposition ( i - k , j + k ) ) ; } else { break ; } } } if ( pf != 0 ) { if ( ( ! board . iswhitepiece ( i - 1 , j ) ) && ( ! board . isblackpiece ( i - 1 , j ) ) && ( ! board . outofbounds ( i - 1 , j ) ) && ( board . board [ i - 1 ] [ j ] != 'r' ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j ) ) ; } } if ( p2f != 0 ) { if ( ( ! board . iswhitepiece ( i - 1 , j ) ) && ( ! board . isblackpiece ( i - 1 , j ) ) && ( board . board [ i - 1 ] [ j ] != 'r' ) ) { if ( ( ! board . iswhitepiece ( i - 2 , j ) ) && ( ! board . isblackpiece ( i - 2 , j ) ) && ( board . board [ i - 2 ] [ j ] != 'r' ) ) { random idk = new random ( ) ; int ceva = idk . nextint ( 2 ) ; if ( ceva == 1 ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 2 , j ) ) ; } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j ) ) ; } } else { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j ) ) ; } } } if ( pd != 0 ) { if ( ( board . isblackpiece ( i - 1 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j - 1 ) ) ; } if ( ( board . isblackpiece ( i - 1 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j + 1 ) ) ; } } if ( speciall != 0 ) { if ( ( ! board . iswhitepiece ( i - 2 , j + 1 ) ) && ( ! board . outofbounds ( i - 2 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 2 , j + 1 ) ) ; } if ( ( ! board . iswhitepiece ( i - 1 , j + 2 ) ) && ( ! board . outofbounds ( i - 1 , j + 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j + 2 ) ) ; } if ( ( ! board . iswhitepiece ( i + 1 , j + 2 ) ) && ( ! board . outofbounds ( i + 1 , j + 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j + 2 ) ) ; } if ( ( ! board . iswhitepiece ( i + 2 , j + 1 ) ) && ( ! board . outofbounds ( i + 2 , j + 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 2 , j + 1 ) ) ; } if ( ( ! board . iswhitepiece ( i + 2 , j - 1 ) ) && ( ! board . outofbounds ( i + 2 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 2 , j - 1 ) ) ; } if ( ( ! board . iswhitepiece ( i + 1 , j - 2 ) ) && ( ! board . outofbounds ( i + 1 , j - 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i + 1 , j - 2 ) ) ; } if ( ( ! board . iswhitepiece ( i - 1 , j - 2 ) ) && ( ! board . outofbounds ( i - 1 , j - 2 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 1 , j - 2 ) ) ; } if ( ( ! board . iswhitepiece ( i - 2 , j - 1 ) ) && ( ! board . outofbounds ( i - 2 , j - 1 ) ) ) { listofmoves . add ( board . translateposition ( i , j ) + board . translateposition ( i - 2 , j - 1 ) ) ; } } } return listofmoves ; }
tr	1	private final void init ( boolean flag ) { int i ; int a , b , c , d , e , f , g , h ; a = b = c = d = e = f = g = h = 0x9e3779b9 ; for ( i = 0 ; i < 4 ; ++ i ) { a ^= b << 11 ; d += a ; b += c ; b ^= c > > > 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e > > > 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g > > > 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a > > > 9 ; c += h ; a += b ; } for ( i = 0 ; i < size ; i += 8 ) { if ( flag ) { a += rsl [ i ] ; b += rsl [ i + 1 ] ; c += rsl [ i + 2 ] ; d += rsl [ i + 3 ] ; e += rsl [ i + 4 ] ; f += rsl [ i + 5 ] ; g += rsl [ i + 6 ] ; h += rsl [ i + 7 ] ; } a ^= b << 11 ; d += a ; b += c ; b ^= c > > > 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e > > > 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g > > > 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a > > > 9 ; c += h ; a += b ; mem [ i ] = a ; mem [ i + 1 ] = b ; mem [ i + 2 ] = c ; mem [ i + 3 ] = d ; mem [ i + 4 ] = e ; mem [ i + 5 ] = f ; mem [ i + 6 ] = g ; mem [ i + 7 ] = h ; } if ( flag ) { for ( i = 0 ; i < size ; i += 8 ) { a += mem [ i ] ; b += mem [ i + 1 ] ; c += mem [ i + 2 ] ; d += mem [ i + 3 ] ; e += mem [ i + 4 ] ; f += mem [ i + 5 ] ; g += mem [ i + 6 ] ; h += mem [ i + 7 ] ; a ^= b << 11 ; d += a ; b += c ; b ^= c > > > 2 ; e += b ; c += d ; c ^= d << 8 ; f += c ; d += e ; d ^= e > > > 16 ; g += d ; e += f ; e ^= f << 10 ; h += e ; f += g ; f ^= g > > > 4 ; a += f ; g += h ; g ^= h << 8 ; b += g ; h += a ; h ^= a > > > 9 ; c += h ; a += b ; mem [ i ] = a ; mem [ i + 1 ] = b ; mem [ i + 2 ] = c ; mem [ i + 3 ] = d ; mem [ i + 4 ] = e ; mem [ i + 5 ] = f ; mem [ i + 6 ] = g ; mem [ i + 7 ] = h ; } } isaac ( ) ; count = size ; }
tr	2	public void jouer ( ) { scanner sc = new scanner ( system . in ) ; int reponse ; system . out . println ( "quelle action voulez vous effectuer ?\\n" ) ; system . out . println ( "- 1 ) jouer une carte ?\\n" ) ; system . out . println ( "- 2 ) piocher une carte \\n" ) ; system . out . println ( "- 3 ) dire uno \\n" ) ; system . out . println ( "- 4 ) dire contre-uno \\n" ) ; reponse = sc . nextint ( ) ; switch ( reponse ) { case ( 1 ) : system . out . println ( "- 1 ) quelle carte souhaitez vous jouer ?\\n" ) ; affichercartes ( ) ; scanner sc2 = new scanner ( system . in ) ; case ( 2 ) : poigne . add ( ( card ) ( partie . getpioche ( ) . gettouteslescartes ( ) . poll ( ) ) ) ; case ( 3 ) : adituno = true ; } }
tr	8	decisiontreeimpl ( dataset train ) { if ( train == null || train . instances == null || train . instances . isempty ( ) ) { return ; } list < attribute > attributes = new arraylist < attribute > ( ) ; for ( instance instance : train . instances ) { for ( int i = 0 ; i < instance . attributes . size ( ) ; i ++ ) { if ( i > attributes . size ( ) - 1 ) { attributes . add ( new attribute ( i ) ) ; } attributes . get ( i ) . addvalue ( instance . attributes . get ( i ) ) ; } } root = traintree ( train . instances , attributes , train . instances , "root" ) ; }
tr	3	public fourinrowpuzzle ( fourinrowpuzzle b ) { this . holes = new puzzlehole [ 6 ] [ 7 ] ; for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { this . holes [ i ] [ j ] = new puzzlehole ( ) ; } } for ( int row = 0 ; row < fourinrowpuzzle . hieght ; row ++ ) { for ( int column = 0 ; column < fourinrowpuzzle . hieght ; column ++ ) { this . holes [ row ] [ column ] . setcolor ( b . holes [ row ] [ column ] . getcolor ( ) ) ; } } }
tr	1	public serverrunningframe ( configurations configurations ) { getcontentpane ( ) . setlayout ( null ) ; this . configurations = configurations ; setsize ( 500 , 500 ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setvisible ( true ) ; thread = new thread ( this ) ; jpanel panel = new jpanel ( ) ; panel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; panel . setbackground ( color . white ) ; panel . setforeground ( color . black ) ; panel . setbounds ( 10 , 11 , 414 , 239 ) ; getcontentpane ( ) . add ( panel ) ; panel . setlayout ( null ) ; textarea = new jtextarea ( ) ; textarea . setbackground ( color . pink ) ; textarea . setlinewrap ( true ) ; textarea . setwrapstyleword ( true ) ; textarea . setbounds ( 10 , 11 , 394 , 217 ) ; panel . add ( textarea ) ; thread . start ( ) ; }
tr	9	private void scaleconfiguration ( ) { double vc = 0 ; for ( int j = 0 ; j < 2 ; j ++ ) { double mc = 0 ; for ( int k = 0 ; k < ncircles ; k ++ ) mc += centers [ k ] [ j ] ; mc /= ncircles ; for ( int k = 0 ; k < ncircles ; k ++ ) { centers [ k ] [ j ] -= mc ; vc += centers [ k ] [ j ] * centers [ k ] [ j ] ; } } vc = 10. * math . sqrt ( vc / ( 2 * ncircles ) ) ; if ( vc > 0 ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( int k = 0 ; k < ncircles ; k ++ ) centers [ k ] [ j ] /= vc ; } } }
tr	8	private static void startgame ( ) throws ioexception { fourinrowpuzzle p = new fourinrowpuzzle ( ) ; game game = new game ( ) ; scanner in = new scanner ( system . in ) ; boolean player = false ; puzzle_hole_colors currentcolor ; short column = 0 ; short maxdepth ; long starttime , endtime ; system . out . print ( "0: you play first<litcomma> 1 computer play first: " ) ; player = ( in . nextbyte ( ) != 0 ) ; system . out . print ( "enter max depth: " ) ; maxdepth = in . nextshort ( ) ; game . setmaxdepth ( ( byte ) maxdepth ) ; system . out . println ( p . tostring ( ) ) ; while ( ! p . isfull ( ) && ! p . isdone ( ) ) { try { if ( player ) { currentcolor = players . player1 ; game . setpuzzle ( p ) ; system . out . println ( "computer is thinking ..." ) ; starttime = system . currenttimemillis ( ) ; column = game . getnextplay ( ) ; endtime = system . currenttimemillis ( ) ; system . out . println ( "computer played: " + column ) ; system . out . println ( "created nodes: " + game . getgraphnodescount ( ) ) ; system . out . println ( "took(" + ( float ) ( endtime - starttime ) / 1000 + "s)" ) ; } else { currentcolor = players . player2 ; system . out . print ( "your turn<litcomma> type a column number: " ) ; column = in . nextshort ( ) ; } p . addtoken ( currentcolor , ( byte ) column ) ; system . out . println ( p . tostring ( ) ) ; player = ! player ; } catch ( fullcolumn e ) { system . out . println ( "column is full!" ) ; } } system . out . println ( p . tostring ( ) ) ; if ( p . isdone ( ) ) { if ( p . getwinner ( ) == puzzle_hole_colors . red ) system . out . println ( "red won!" ) ; else if ( p . getwinner ( ) == puzzle_hole_colors . black ) system . out . println ( "black won!" ) ; } else { system . out . println ( "no body won!" ) ; } system . out . println ( "" ) ; }
tr	10	public static void calculer ( vector < vector < string > > data , string pivot ) { int ligne_pivot = integer . parseint ( pivot . split ( "<litcomma>" ) [ 0 ] ) ; int col_pivot = integer . parseint ( pivot . split ( "<litcomma>" ) [ 1 ] ) ; vector < vector < string > > copie = new vector ( ) ; vector < string > ligne ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { ligne = new vector ( ) ; for ( int j = 0 ; j < data . get ( i ) . size ( ) ; j ++ ) { ligne . add ( data . get ( i ) . get ( j ) ) ; } copie . add ( ligne ) ; } data . get ( ligne_pivot ) . set ( 0 , data . get ( 0 ) . get ( col_pivot ) ) ; int nbre_col = data . get ( 0 ) . size ( ) ; if ( data . get ( 0 ) . get ( data . get ( 0 ) . size ( ) - 1 ) . equals ( "ratio" ) ) nbre_col -- ; for ( int i = 1 ; i < nbre_col ; i ++ ) { data . get ( ligne_pivot ) . set ( i , ( float . parsefloat ( copie . get ( ligne_pivot ) . get ( i ) ) / float . parsefloat ( copie . get ( ligne_pivot ) . get ( col_pivot ) ) ) + "" ) ; } for ( int i = 1 ; i < copie . size ( ) ; i ++ ) { for ( int j = 1 ; j < nbre_col ; j ++ ) { if ( i == ligne_pivot ) continue ; else { data . get ( i ) . set ( j , "" + ( float . parsefloat ( copie . get ( i ) . get ( j ) ) - float . parsefloat ( copie . get ( i ) . get ( col_pivot ) ) * float . parsefloat ( copie . get ( ligne_pivot ) . get ( j ) ) / float . parsefloat ( copie . get ( ligne_pivot ) . get ( col_pivot ) ) ) ) ; } } } }
tr	8	public randomgraph generate ( int numofvertex , int numofedge ) { if ( numofedge < numofvertex - 1 || numofedge > ( numofvertex * ( numofvertex - 1 ) ) / 2 ) { system . out . println ( "the number of edge cannot construct a connected graph " ) ; return null ; } for ( int i = 0 ; i < numofvertex ; i ++ ) { vertex vertex = new vertex ( i ) ; this . vertexlist . add ( vertex ) ; } randomgraph = new randomgraph ( this . vertexlist ) ; int count = 0 ; for ( int i = 0 ; i < 100000 ; i ++ ) { if ( count == numofedge ) { break ; } if ( randomgraph . insertedge ( ( int ) ( math . random ( ) * numofvertex ) , ( int ) ( math . random ( ) * numofvertex ) , ( int ) ( math . random ( ) * 10 ) + 1 ) ) { randomgraph . insertedge ( ( int ) ( math . random ( ) * numofvertex ) , ( int ) ( math . random ( ) * numofvertex ) , ( int ) ( math . random ( ) * 10 ) + 1 ) ; count ++ ; } } return this . randomgraph ; }
tr	8	private double midpoint ( list < instance > examples , int attributeindex ) { if ( examples == null || examples . isempty ( ) ) { return 0.0 ; } double max = double . negative_infinity , min = double . positive_infinity ; for ( instance instance : examples ) { int attribute = integer . parseint ( instance . attributes . get ( attributeindex ) ) ; if ( attribute > max ) { max = attribute ; } if ( attribute < min ) { min = attribute ; } } return 0.5 * ( max + min ) ; }
tr	7	private string countandsay ( string seq ) { string res = "" ; string lastvalue = "" ; int lastvaluenumber = 0 ; for ( int i = 0 ; i < seq . length ( ) ; i ++ ) { if ( ! seq . substring ( i , i + 1 ) . equals ( lastvalue ) ) { if ( lastvaluenumber != 0 ) res += lastvaluenumber + lastvalue ; lastvalue = seq . substring ( i , i + 1 ) ; lastvaluenumber = 1 ; } else { lastvaluenumber ++ ; } } res += lastvaluenumber + lastvalue ; return res ; }
tr	7	@ override public void init ( gamecontainer container ) throws slickexception { this . container = container ; container . settargetframerate ( 60 ) ; int size = 5 ; int speed = 3 ; int rotation = 20 ; float range = 40 ; ship = new ship ( size , speed , rotation , range , this ) ; list < obj > shiplist = new list < obj > ( ) ; shiplist . add ( ship ) ; bulletlist = new list < obj > ( ) ; astlist = new list < obj > ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { float [ ] loc = new float [ 2 ] ; loc [ 0 ] = ( float ) ( math . random ( ) * container . getwidth ( ) ) ; loc [ 1 ] = ( float ) ( math . random ( ) * container . getheight ( ) ) ; list < obj > pointer = astlist ; while ( pointer . next != null ) { pointer = pointer . next ; } list < obj > wrapper = new list < obj > ( ) ; asteroid ast = new asteroid ( loc , ( float ) ( math . random ( ) * 10 + 4 ) , wrapper , this ) ; wrapper . data = ast ; wrapper . previous = pointer ; pointer . next = wrapper ; } gamelist = new list < list < obj > > ( ) ; gamelist . add ( bulletlist ) ; gamelist . add ( astlist ) ; gamelist . add ( shiplist ) ; }
tr	7	public static void main ( string [ ] args ) throws exception { mystack ms = new mystack ( 10 ) ; string s = "a{b(c[d]e)f}" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == '{' || c == '(' || c == '[' ) { ms . push ( c ) ; } else if ( c == '}' || c == ')' || c == ']' ) { if ( ! ms . isempty ( ) ) { char cc = ms . pop ( ) ; if ( ! ( ( cc == '{' && c == '}' ) || ( cc == '(' && c == ')' ) || ( cc == '[' && c == ']' ) ) ) { throw new exception ( "error<litcomma> doesn't match!" ) ; } } else { system . out . println ( "error<litcomma> doesn't match!" ) ; break ; } } } s = "a{b(c[d]e[f}" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == '{' || c == '(' || c == '[' ) { ms . push ( c ) ; } else if ( c == '}' || c == ')' || c == ']' ) { if ( ! ms . isempty ( ) ) { char cc = ms . pop ( ) ; if ( ! ( ( cc == '{' && c == '}' ) || ( cc == '(' && c == ')' ) || ( cc == '[' && c == ']' ) ) ) { throw new exception ( "exception: error<litcomma> doesn't match!" ) ; } } else { system . out . println ( "error<litcomma> doesn't match!" ) ; break ; } } } if ( ! ms . isempty ( ) ) { system . err . println ( "error<litcomma> doesn't match!" ) ; } }
tr	5	public static string readline ( inputstream inputstream ) throws ioexception { byte [ ] rawdata = readrawline ( inputstream ) ; if ( rawdata == null ) { return null ; } int len = rawdata . length ; int offset = 0 ; if ( len > 0 ) { if ( rawdata [ len - 1 ] == '\\n' ) { offset ++ ; if ( len > 1 ) { if ( rawdata [ len - 2 ] == '\\r' ) { offset ++ ; } } } } return getstring ( rawdata , 0 , len - offset ) ; }
tr	5	public string tosummarystring ( ) { stringwriter stringwriter = new stringwriter ( ) ; csvwriter writer = new csvwriter ( stringwriter ) ; string [ ] columns = new string [ 0 ] ; for ( round round : rounds ) { for ( game game : round ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( columns . length == 0 ) { if ( game . summarystats . size ( ) == 0 ) return "" ; columns = game . summarystats . toarray ( columns ) ; writer . writenext ( columns ) ; } string [ ] values = new string [ columns . length ] ; for ( int j = 0 ; j < values . length ; j ++ ) values [ j ] = game . summaries [ i ] . get ( columns [ j ] ) . tostring ( ) ; writer . writenext ( values ) ; } } } return stringwriter . tostring ( ) ; }
tr	3	public static list < frequency > computefourgramfrequencies ( arraylist < string > words ) { list < frequency > fourgramlist = new arraylist < frequency > ( ) ; map < string , integer > fourgrammap = new treemap < string , integer > ( ) ; for ( int i = 0 ; i < words . size ( ) - 3 ; i ++ ) { if ( fourgrammap . get ( words . get ( i ) + " " + words . get ( i + 1 ) + " " + words . get ( i + 2 ) + " " + words . get ( i + 3 ) ) == null ) { fourgrammap . put ( words . get ( i ) + " " + words . get ( i + 1 ) + " " + words . get ( i + 2 ) + " " + words . get ( i + 3 ) , 1 ) ; } else { fourgrammap . put ( words . get ( i ) + " " + words . get ( i + 1 ) + " " + words . get ( i + 2 ) + " " + words . get ( i + 3 ) , fourgrammap . get ( words . get ( i ) + " " + words . get ( i + 1 ) + " " + words . get ( i + 2 ) + " " + words . get ( i + 3 ) ) + 1 ) ; } } for ( map . entry < string , integer > entry : fourgrammap . entryset ( ) ) { fourgramlist . add ( new frequency ( entry . getkey ( ) , entry . getvalue ( ) ) ) ; } return fourgramlist ; }
tr	9	public int trap ( int [ ] a ) { if ( a . length < 3 ) return 0 ; int water = 0 ; int maxleft [ ] = new int [ a . length ] ; maxleft [ 0 ] = 0 ; int maxright [ ] = new int [ a . length ] ; maxright [ a . length - 1 ] = 0 ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( maxleft [ i - 1 ] < a [ i - 1 ] ) { maxleft [ i ] = a [ i - 1 ] ; } else { maxleft [ i ] = maxleft [ i - 1 ] ; } } for ( int i = a . length - 2 ; i >= 0 ; i -- ) { if ( maxright [ i + 1 ] < a [ i + 1 ] ) { maxright [ i ] = a [ i + 1 ] ; } else { maxright [ i ] = maxright [ i + 1 ] ; } } for ( int i = 1 ; i < a . length ; i ++ ) { if ( math . min ( maxleft [ i ] , maxright [ i ] ) > a [ i ] ) water += math . min ( maxleft [ i ] , maxright [ i ] ) - a [ i ] ; } return water ; }
tr	6	public static hashmap < string , double > readlocationentropygpsbased ( int samplerate ) { if ( gpsentropy . isempty ( ) ) { string fname = null ; try { bufferedreader fin ; if ( samplerate <= 100 ) { fname = string . format ( "res/gpsentropy-%ds.txt" , samplerate ) ; } else { fname = "res/gpsentropy.txt" ; } fin = new bufferedreader ( new filereader ( fname ) ) ; system . out . println ( string . format ( "file %s found!" , fname ) ) ; string l = null ; while ( ( l = fin . readline ( ) ) != null ) { string [ ] ls = l . split ( "\\\\s+" ) ; string gps = ls [ 0 ] ; double entropy = double . parsedouble ( ls [ 1 ] ) ; if ( ! gpsentropy . containskey ( gps ) ) gpsentropy . put ( gps , entropy ) ; } fin . close ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( string . format ( "no gps entropy file %s found. generate a new one ..." , fname ) ) ; writelocationentropy ( false , samplerate ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( string . format ( "gps location size %d." , gpsentropy . size ( ) ) ) ; } return gpsentropy ; }
tr	1	public static void startcalculation ( int n , int numberoftasks , int threadsquantity ) throws interruptedexception { performancetester performancetester = new performancetesterimpl ( ) ; performancetestresult performancetestresult = performancetester . runperformancetest ( createrunnabletask ( n ) , numberoftasks , threadsquantity ) ; system . out . println ( string . format ( "total execution time: %s" , performancetestresult . gettotaltime ( ) ) ) ; system . out . println ( string . format ( "minimum execution time: %s" , performancetestresult . getmintime ( ) ) ) ; system . out . println ( string . format ( "maximum execution time: %s" , performancetestresult . getmaxtime ( ) ) ) ; }
tr	10	@ override public void solve ( ) { long n = 2 ; list < long > arr = new arraylist < long > ( ) ; while ( n <= 20 ) { long currn = n ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( currn > 1 && currn % arr . get ( i ) == 0 ) { currn /= arr . get ( i ) ; } } arr . add ( currn ) ; n += 1 ; } print ( product ( arr ) ) ; }
tr	5	public void onenable ( ) { instance = this ; owners = new arraylist < > ( ) ; try { dir = new file ( getdatafolder ( ) + "" ) ; if ( ! dir . exists ( ) ) dir . mkdir ( ) ; config = new file ( getdatafolder ( ) + "/config.yml" ) ; if ( ! config . exists ( ) ) savedefaultconfig ( ) ; data = new file ( getdatafolder ( ) + "/data.txt" ) ; if ( ! data . exists ( ) ) data . createnewfile ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } new bukkitrunnable ( ) { @ override public void run ( ) { owners = datareader . getplayers ( data ) ; } } . runtaskasynchronously ( this ) ; }
tr	1	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . print ( "ingrese un valor: " ) ; int v = scanner . nextint ( ) ; int resto = v % 2 ; if ( resto == 0 ) { system . out . println ( v + " es par" ) ; } else { system . out . println ( v + " es impar" ) ; } string mssg = ( resto == 0 ) ? "es par" : "es impar" ; system . out . println ( mssg ) ; }
tr	6	public void start ( ) { try { display . setdisplaymode ( new displaymode ( 640 , 480 ) ) ; display . create ( ) ; display . settitle ( "boxio" ) ; } catch ( lwjglexception e ) { e . printstacktrace ( ) ; } initsong ( ) ; glenable ( gl_texture_2d ) ; player = new player ( ) ; enemy = new enemy ( ) ; coinlist = new arraylist < coin > ( 0 ) ; song . playasmusic ( 1.0f , 0.05f , true ) ; while ( ! display . iscloserequested ( ) ) { setcamera ( ) ; drawbackground ( ) ; player . draw ( ) ; enemy . draw ( ) ; for ( coin c : coinlist ) c . draw ( ) ; drawstring . drawstring ( "deaths " + player . deaths + "\\n" + "kills " + enemy . kills + "\\n" + "press t to teleport random" + "\\n" + "press k to kill once per round" + "\\n" + "get 10 kills to win!" , 320 , 360 ) ; end . end ( ) ; highscore . show ( ) ; display . update ( ) ; display . sync ( 60 ) ; } display . destroy ( ) ; al . destroy ( ) ; }
tr	4	private void paintgameover ( graphics g ) { g . setcolor ( color . white ) ; g . setfont ( new font ( "helvetica" , font . plain , 48 ) ) ; string gameovertext = "game over" ; rectangle2d gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; int startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) - 2 ) ; int starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) - 2 ) ; g . drawstring ( gameovertext , startx , starty ) ; g . setcolor ( color . blue ) ; g . setfont ( new font ( "helvetica" , font . plain , 48 ) ) ; gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) ) ; starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) ) ; g . drawstring ( gameovertext , startx , starty ) ; g . setcolor ( color . blue ) ; g . setfont ( new font ( "helvetica" , font . plain , 24 ) ) ; gameovertext = "press enter to restart" ; gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) ) ; starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) + 50 ) ; g . drawstring ( gameovertext , startx , starty ) ; }
tr	10	protected void checkstraight ( list < card > cards ) { int [ ] anycard = new int [ 14 ] ; for ( int i = 0 ; i < 14 ; i ++ ) { anycard [ i ] = - 1 ; } for ( int i = 0 ; i < cards . size ( ) ; i ++ ) { int it = cards . get ( i ) . getcardvalue ( ) ; anycard [ it + 1 ] = i ; } anycard [ 0 ] = anycard [ 13 ] ; int cnt = 0 ; for ( int i = 0 ; i < 14 - 5 ; i ++ ) { int tmp_cnt = 0 ; int last_card = 0 ; for ( int j = i ; j < i + 5 ; j ++ ) { if ( anycard [ j ] != - 1 ) { tmp_cnt ++ ; last_card = j ; } } if ( tmp_cnt >= cnt && tmp_cnt != 0 ) { cnt = tmp_cnt ; missingcards [ 4 ] = 5 - tmp_cnt ; bestcard [ 4 ] = cards . get ( anycard [ last_card ] ) ; } } if ( cnt == 0 ) { missingcards [ 4 ] = 5 ; bestcard [ 4 ] = cards . get ( cards . size ( ) - 1 ) ; } }
tr	1	public void onjoin ( string channel , string sender , string login , string hostname ) { if ( sender . equalsignorecase ( getnick ( ) ) ) { log . consolelog ( "info" , "joined channel: " + channel ) ; if ( config . getstateversiononjoin ( ) ) { sendmessage ( channel , config . getversion ( ) ) ; } return ; } log . consolelog ( "join" , sender + " just joined " + channel ) ; if ( config . getwelcomeusers ( ) ) { sendmessage ( channel , config . getwelcomemessage ( ) . replace ( "<sender>" , sender ) . replace ( "<channel>" , channel ) ) ; } }
tr	6	@ suppresswarnings ( "rawtypes" ) private class [ ] obtenerclasesdelpaquete ( string packagename ) throws classnotfoundexception , ioexception { classloader classloader = thread . currentthread ( ) . getcontextclassloader ( ) ; assert classloader != null ; string path = packagename . replace ( '.' , '/' ) ; logger . info ( "path: " + path ) ; enumeration < url > resources = classloader . getresources ( path ) ; list < file > dirs = new arraylist < file > ( ) ; while ( resources . hasmoreelements ( ) ) { url resource = resources . nextelement ( ) ; dirs . add ( new file ( resource . getfile ( ) ) ) ; logger . info ( resource . tostring ( ) ) ; } arraylist < class > classes = new arraylist < class > ( ) ; for ( file directory : dirs ) { classes . addall ( buscarclasesendirectorio ( directory , packagename ) ) ; } return classes . toarray ( new class [ classes . size ( ) ] ) ; }
tr	3	public ircbot ( string host , string channel , string nick , int port ) { this . host = host ; this . channel = channel ; this . nick = nick ; this . port = port ; handlers = new arraylist < messagehandler > ( ) ; messagehandler pinghandler = new messagehandler ( this ) { void handle ( message message ) { if ( message . getcommand ( ) . equals ( "ping" ) ) bot . writeline ( "pong :" + message . gettrailing ( ) ) ; } } ; handlers . add ( pinghandler ) ; }
tr	3	public static void main ( string [ ] args ) { disruptor < calculatenumbersevent > disruptor = new disruptor < calculatenumbersevent > ( calculatenumbersevent . event_factory , createexecutor ( ) , new singlethreadedclaimstrategy ( ring_size ) , new sleepingwaitstrategy ( ) ) ; disruptor . handleeventswith ( new factorialcalculator ( ) , new fibonaccicalculator ( ) ) . then ( new hexrepresentationcalculator ( ) , new binaryrepresentationcalculator ( ) ) . then ( new eventoutputhandler ( ) ) ; ringbuffer < calculatenumbersevent > ringbuffer = disruptor . start ( ) ; long sequence = ringbuffer . next ( ) ; calculatenumbersevent event = ringbuffer . get ( sequence ) ; event . setvalue ( 5 ) ; ringbuffer . publish ( sequence ) ; disruptor . publishevent ( new eventtranslator < calculatenumbersevent > ( ) { @ override public void translateto ( calculatenumbersevent event , long sequence ) { event . setfired ( new date ( ) ) ; } } ) ; }
tr	9	public static void loadmodsfromfolder ( file directory ) { if ( ! directory . isdirectory ( ) ) { return ; } arraylist < file > files = new arraylist < file > ( ) ; file [ ] filesanddirectories = directory . listfiles ( ) ; if ( filesanddirectories != null ) { for ( file file : filesanddirectories ) { if ( file . isfile ( ) ) { if ( file . getname ( ) . endswith ( ".zip" ) ) { trovemods . addmod ( file ) ; files . add ( file ) ; } } } } date date = new date ( ) ; simpledateformat simpledateformat = new simpledateformat ( "hh:mm:ss" ) ; string textlabel = simpledateformat . format ( date ) + " - " + files . size ( ) + ( files . size ( ) == 1 ? " mod" : " mods" ) + " added!" ; setmodlabel ( textlabel ) ; }
tr	5	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == this . morningafternooncomparebtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . sangchieu_xlsx ) ; morningafternoonstrategycompareservice service = new morningafternoonstrategycompareservice ( excelservice ) ; service . comparemorningafternoon ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . sangchieu_xlsx ) ) ; status . settext ( "    * caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } else if ( e . getsource ( ) == this . checkduplicateblightbtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . check_duplicate_xlsx , 0 ) ; duplicatestrategycheckservice service = new duplicatestrategycheckserviceimpl ( excelservice ) ; service . checkduplicate ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . symbols_xlsx ) ) ; status . settext ( "caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } else if ( e . getsource ( ) == this . checkduplicatevtradebtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . check_duplicate_xlsx , 1 ) ; duplicatestrategycheckservice service = new duplicatestrategycheckserviceimpl ( excelservice ) ; service . checkduplicate ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . symbols_xlsx ) ) ; status . settext ( "caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } }
tr	2	@ override public void run ( ) { running = true ; while ( running ) { datagrampacket p = new datagrampacket ( new byte [ 18 + mtu ] , 18 + mtu ) ; try { serversocket . receive ( p ) ; p . setdata ( p . getdata ( ) , 0 , p . getlength ( ) ) ; pcaplogger . logpacket ( p , p . getaddress ( ) , p . getport ( ) , serversocket . getlocaladdress ( ) , serversocket . getlocalport ( ) ) ; utils . dumppacket ( p , p . getaddress ( ) , p . getport ( ) , serversocket . getlocaladdress ( ) , serversocket . getlocalport ( ) , packetlogger ) ; handler . handlepacket ( p ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	3	@ override public void construct ( object ... data ) { try { out . writebyte ( ( ( boolean ) data [ 0 ] ) ? 8 : 6 ) ; out . write ( constants . raknet_magic ) ; if ( ( boolean ) data [ 0 ] ) { out . writelong ( server . serverid ) ; out . writeshort ( ( short ) data [ 1 ] ) ; out . writeshort ( ( short ) data [ 2 ] ) ; out . write ( 0 ) ; } else { out . writelong ( server . serverid ) ; out . write ( 0 ) ; out . writeshort ( ( short ) data [ 1 ] ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	@ override public boolean oncommand ( commandsender sender , command cmd , string commandlabel , string [ ] args ) { if ( cmd . getname ( ) . equalsignorecase ( "censornizer" ) ) { if ( args . length >= 2 ) { sender . sendmessage ( "\xa7cusage: \xa7a/censornizer <unmute player|reload>" ) ; return true ; } if ( args [ 0 ] . equalsignorecase ( "unmute" ) ) { player target = main . getserver ( ) . getplayer ( args [ 1 ] ) ; try { if ( sender . haspermission ( "censornizer.unmute" ) ) { if ( ! main . map . containskey ( target . getname ( ) ) ) { sender . sendmessage ( "\xa74the player " + chatcolor . green + target . getdisplayname ( ) + chatcolor . dark_red + " is not muted!" ) ; return true ; } else { sender . sendmessage ( "\xa7athe player " + chatcolor . gold + target . getdisplayname ( ) + chatcolor . green + " is now unmuted!" ) ; main . map . remove ( target . getname ( ) ) ; return true ; } } else { sender . sendmessage ( "\xa74you dont have permission!" ) ; return true ; } } catch ( nullpointerexception e ) { sender . sendmessage ( "\xa74the player " + args [ 0 ] + "is not online!" ) ; return true ; } } else if ( args [ 0 ] . equalsignorecase ( "reload" ) ) { if ( sender . haspermission ( "censornizer.reload" ) ) { try { main . files . reload ( ) ; sender . sendmessage ( "\xa7asuccessfully reloaded!" ) ; return true ; } catch ( filenotfoundexception ex ) { sender . sendmessage ( "\xa7cerror on reload." ) ; ex . printstacktrace ( ) ; return true ; } } else { sender . sendmessage ( "\xa74you dont have permission!" ) ; return true ; } } else { sender . sendmessage ( "\xa7cusage: \xa7a/censornizer <unmute player|reload>" ) ; return true ; } } return false ; }
tr	2	void decode ( final string msgtext , final message message ) throws jsonexception { final jsonobject jsonobject = new jsonobject ( msgtext ) ; final jsonarray names = jsonobject . names ( ) ; if ( names . length ( ) == 1 ) { final string firstname = ( string ) ( names . get ( 0 ) ) ; final object firstobj = jsonobject . get ( firstname ) ; if ( firstobj instanceof jsonarray ) { final jsonarray params = jsonobject . getjsonarray ( firstname ) ; message . name = firstname ; message . parameters = new parameter [ ] { decodeparams ( params ) } ; } else { message . parameters = decodeparams ( jsonobject ) ; } } else { message . parameters = decodeparams ( jsonobject ) ; } }
tr	2	@ override public object mapfromattributes ( attributes attributes ) throws namingexception { person person = new person ( ) ; attribute name = attributes . get ( "name" ) ; if ( name != null ) { person . setname ( ( string ) name . get ( ) ) ; } attribute displayname = attributes . get ( "displayname" ) ; if ( displayname != null ) { person . setdisplayname ( ( string ) displayname . get ( ) ) ; } attribute lastname = attributes . get ( "sn" ) ; if ( lastname != null ) { person . setlastname ( ( string ) lastname . get ( ) ) ; } attribute firstname = attributes . get ( "givenname" ) ; if ( firstname != null ) { person . setfirstname ( ( string ) firstname . get ( ) ) ; } attribute mail = attributes . get ( "mail" ) ; if ( mail != null ) { person . setmail ( ( string ) mail . get ( ) ) ; } attribute userid = attributes . get ( "uid" ) ; if ( userid != null ) { person . setuserid ( ( string ) userid . get ( ) ) ; } system . out . println ( person . tostring ( ) ) ; return person ; }
tr	9	private void infixtopostfix ( ) { stack < string > opstack = new stack < string > ( ) ; for ( int i = 0 ; i < token . size ( ) ; i ++ ) { if ( isnumeric ( token . get ( i ) ) || token . get ( i ) . equals ( "x" ) ) postfixtokens . add ( token . get ( i ) ) ; else if ( token . get ( i ) . equals ( "(" ) ) opstack . push ( token . get ( i ) ) ; else if ( token . get ( i ) . equals ( ")" ) ) { while ( ! opstack . peek ( ) . equals ( "(" ) ) postfixtokens . add ( opstack . pop ( ) ) ; opstack . pop ( ) ; if ( ! opstack . isempty ( ) && isspecialops ( opstack . peek ( ) ) ) postfixtokens . add ( opstack . pop ( ) ) ; } else if ( opstack . isempty ( ) || opstack . peek ( ) . equals ( "(" ) || compareops ( opstack . peek ( ) , token . get ( i ) ) <= 0 ) opstack . push ( token . get ( i ) ) ; else { while ( ! opstack . isempty ( ) && ! opstack . peek ( ) . equals ( "(" ) && compareops ( opstack . peek ( ) , token . get ( i ) ) >= 0 ) postfixtokens . add ( opstack . pop ( ) ) ; opstack . push ( token . get ( i ) ) ; } } while ( ! opstack . isempty ( ) ) postfixtokens . add ( opstack . pop ( ) ) ; }
tr	1	public void actionperformed ( actionevent e ) { if ( "next" . equals ( e . getactioncommand ( ) ) ) { update ( 1 ) ; } if ( "forward" . equals ( e . getactioncommand ( ) ) ) { integer num = new integer ( forwardepochs . gettext ( ) ) ; update ( num . intvalue ( ) ) ; } if ( "restart" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; new simulation ( ) . run ( ) ; } if ( "exit" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; } }
tr	4	private void handleconnect ( string str , serverclient client ) { int clientid = addclient ( client ) ; if ( clientid == - 1 ) { string full = error + "sorry the current server is full/e/" ; send ( full . getbytes ( ) , client ) ; } else { system . out . println ( "the user " + client . getname ( ) + " connected" ) ; string welcome = connect + "welcome " + client . getname ( ) + "/c/" + clientid + "/i/" ; send ( welcome . getbytes ( ) , client ) ; sendtoall ( message + "user " + client . getname ( ) + " connected/m/" ) ; } }
tr	3	public static void main ( string [ ] args ) { environmentconfig envconfig = new environmentconfig ( ) ; envconfig . settransactional ( true ) ; envconfig . setallowcreate ( true ) ; environment mydbenvironment = new environment ( new file ( "testdb" ) , envconfig ) ; storeconfig storeconfig = new storeconfig ( ) ; storeconfig . setallowcreate ( true ) ; storeconfig . settransactional ( true ) ; entitystore store = new entitystore ( mydbenvironment , "storedb" , storeconfig ) ; primaryindex < string , userinfo > pindex = store . getprimaryindex ( string . class , userinfo . class ) ; pindex . put ( new userinfo ( "001" , "user001" ) ) ; pindex . put ( new userinfo ( "002" , "user002" ) ) ; pindex . put ( new userinfo ( "003" , "user003" ) ) ; pindex . put ( new userinfo ( "004" , "user004" ) ) ; pindex . put ( new userinfo ( "005" , "user005" ) ) ; userinfo getdata = pindex . get ( "001" ) ; system . out . println ( "read user 001:" + getdata ) ; pindex . put ( new userinfo ( "002" , "user002222" ) ) ; entitycursor < userinfo > cursor = pindex . entities ( ) ; try { iterator < userinfo > i = cursor . iterator ( ) ; while ( i . hasnext ( ) ) { system . out . println ( "cursor data:" + i . next ( ) ) ; } } finally { cursor . close ( ) ; } string pkey = "003" ; boolean flag = pindex . delete ( pkey ) ; system . out . println ( "delete object :" + pkey + " result:" + flag ) ; if ( store != null ) { store . close ( ) ; store = null ; } }
tr	8	@ override public void update ( long delta ) { if ( direction . equals ( movementdirection . right ) ) { shape . setx ( shape . getx ( ) + acceleration * delta ) ; if ( shape . getx ( ) > maxposition . x ) { shape . setx ( maxposition . x ) ; direction = movementdirection . left ; } } else if ( direction . equals ( movementdirection . left ) ) { shape . setx ( shape . getx ( ) - acceleration * delta ) ; if ( shape . getx ( ) < minposition . x ) { shape . setx ( minposition . x ) ; direction = movementdirection . right ; } } if ( direction . equals ( movementdirection . up ) ) { shape . sety ( shape . gety ( ) + acceleration * delta ) ; if ( shape . gety ( ) >= maxposition . y ) { shape . sety ( maxposition . y ) ; direction = movementdirection . down ; } } else if ( direction . equals ( movementdirection . down ) ) { shape . sety ( shape . gety ( ) - acceleration * delta ) ; if ( shape . gety ( ) <= minposition . y ) { shape . sety ( minposition . y ) ; direction = movementdirection . up ; } } }
tr	8	@ override public void contextinitialized ( servletcontextevent sce ) { logger . debug ( "initializing.." ) ; webapplicationcontext ctx = webapplicationcontextutils . getwebapplicationcontext ( sce . getservletcontext ( ) ) ; personrepository personrepository = ctx . getbean ( personrepository . class ) ; personrepository . deleteall ( ) ; list < person > persons = new arraylist < person > ( ) ; int itemcount = 100 ; int chunksize = 25 ; for ( int i = 1 ; i <= itemcount ; i ++ ) { person p = new person ( ) ; p . setage ( ( i % 100 ) + 1 ) ; p . setname ( "name" + i ) ; persons . add ( p ) ; if ( ( i % chunksize ) == 0 ) { personrepository . save ( persons ) ; persons . clear ( ) ; } } personrepository . save ( persons ) ; }
tr	8	public int longestconsecutive ( int [ ] num ) { hashmap < integer , boolean > maps = new hashmap < integer , boolean > ( ) ; int maxlengh = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) maps . put ( num [ i ] , false ) ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( maps . get ( num [ i ] ) == true ) continue ; int length = 1 ; int j = num [ i ] + 1 ; maps . put ( num [ i ] , true ) ; while ( maps . containskey ( j ) ) { maps . put ( j , true ) ; j ++ ; length ++ ; } j = num [ i ] - 1 ; while ( maps . containskey ( j ) ) { maps . put ( j , true ) ; j -- ; length ++ ; } if ( length > maxlengh ) maxlengh = length ; } return maxlengh ; }
tr	6	private ichromosome setupchromosome ( final int [ ] set ) throws invalidconfigurationexception { subsetgenes = new gene [ k ] ; int minelementvalue = integer . max_value ; int maxelementvalue = integer . min_value ; for ( final int element : set ) { minelementvalue = math . min ( element , minelementvalue ) ; maxelementvalue = math . max ( element , maxelementvalue ) ; } for ( int g = 0 ; g < k ; g ++ ) { subsetgenes [ g ] = new integergene ( configuration , 0 , numelementsinset - 1 ) ; } final gene [ ] genes = new gene [ 1 + getnumberofparameters ( ) ] ; final abstractsupergene constrainedgenes = new subsetsupergene ( configuration , subsetgenes , this . allelements ) ; genes [ 0 ] = constrainedgenes ; for ( int paramindex = 0 ; paramindex < getnumberofparameters ( ) ; paramindex ++ ) { genes [ 1 + paramindex ] = new integergene ( configuration , 0 , this . allpossibleparametervalues [ paramindex ] . length - 1 ) ; } subsetchromosome = new chromosome ( configuration , genes ) ; return subsetchromosome ; }
tr	8	public static void main ( string [ ] args ) throws exception { if ( args . length < 3 || args [ 0 ] . isempty ( ) || args [ 1 ] . isempty ( ) || args [ 2 ] . isempty ( ) ) { system . out . println ( "too few arguments. required arguments: [year] [men|women] [referee class name]" ) ; return ; } if ( ! args [ 1 ] . equals ( "men" ) && ! args [ 1 ] . equals ( "women" ) ) { system . out . println ( "the second argument must be 'men' or 'women'." ) ; return ; } string year = args [ 0 ] ; string sex = args [ 1 ] ; string refereeclassname = args [ 2 ] ; referee referee ; try { referee = ( referee ) class . forname ( "bracketeer.referees." + refereeclassname ) . newinstance ( ) ; } catch ( exception ex ) { system . out . println ( "the referee class '" + refereeclassname + "' was not found in the package bracketeer.referees. check your capitalization and be sure to recompile." ) ; return ; } vector < stat > stats = new vector < stat > ( ) ; stats . add ( new stat ( "division iwon-lost percentage" , "pct" , "win %" ) ) ; stats . add ( new stat ( "division iscoring margin" , "ppg" , "ppg" ) ) ; stats . add ( new stat ( "division iscoring margin" , "opp ppg" , "opp ppg" ) ) ; stats . add ( new stat ( "division iscoring margin" , "scr mar" , "scr mar" ) ) ; stats . add ( new stat ( "division irebound margin" , "rpg" , "rpg" ) ) ; stats . add ( new stat ( "division ifield-goal percentage" , "fg%" , "fg%" ) ) ; stats . add ( new stat ( "division ifield-goal percentage" , "fga" , "fga" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fg" , "opp fg" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fga" , "opp fga" ) ) ; stats . add ( new stat ( "division ifield-goal percentage defense" , "opp fg%" , "opp fg%" ) ) ; stats . add ( new stat ( "division ipersonal fouls per game" , "pfpg" , "pfpg" ) ) ; stats . add ( new stat ( "division ifree-throw percentage" , "ft%" , "ft%" ) ) ; stats . add ( new stat ( "division ifree-throw percentage" , "fta" , "fta" ) ) ; stats . add ( new stat ( "division iblocked shots per game" , "bkpg" , "bkpg" ) ) ; stats . add ( new stat ( "division isteals per game" , "stpg" , "stpg" ) ) ; stats . add ( new stat ( "division iturnovers per game" , "topg" , "topg" ) ) ; stats . add ( new stat ( "division iturnover margin" , "opp to" , "opp topg" ) ) ; stats . add ( new stat ( "division iassists per game" , "apg" , "apg" ) ) ; stats . add ( new stat ( "division ithree pt fg defense" , "pct" , "opp 3fg%" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "3fg%" , "3fg%" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "3fga" , "3fga" ) ) ; stats . add ( new stat ( "division ithree-point field-goal percentage" , "gm" , "gm" ) ) ; if ( args [ 1 ] . equals ( "women" ) ) { stats . add ( new stat ( "division iturnover margin" , "margin" , "to ratio" ) ) ; } else { stats . add ( new stat ( "division iturnover margin" , "ratio" , "to ratio" ) ) ; } string rankingsfilename = "seasons/" + year + "/rankings_" + sex + ".csv" ; string firstroundfilename = "seasons/" + year + "/firstround_" + sex + ".csv" ; string outputfilename = "results/" + refereeclassname + ".csv" ; new file ( "results" ) . mkdir ( ) ; hashtable < string , team > teams = parser . parseteams ( new filereader ( rankingsfilename ) , stats ) ; round firstround = parser . parsefirstround ( new filereader ( firstroundfilename ) , teams ) ; vector < team > firstroundteams = new vector < team > ( ) ; for ( game game : firstround ) { firstroundteams . add ( game . teams [ 0 ] ) ; firstroundteams . add ( game . teams [ 1 ] ) ; } tournament t = new tournament ( firstround , null , referee ) ; t . play ( ) ; system . out . print ( t . toprintablestring ( ) ) ; filewriter writer = new filewriter ( outputfilename ) ; writer . write ( t . tosummarystring ( ) ) ; writer . close ( ) ; }
tr	1	public void writeconfig ( string [ ] env ) { string filename ; string contents ; if ( system . getproperty ( "os.name" ) . startswith ( "windows" ) ) { filename = "config.bat" ; contents = string . format ( "set jen_env=%s" , env [ 0 ] ) ; } else if ( system . getproperty ( "os.name" ) . startswith ( "linux" ) ) { filename = "config" ; contents = string . format ( "export jen_env=%s" , env [ 0 ] ) ; } else { return ; } try { files . write ( contents . getbytes ( ) , new file ( options . jenhome + file . separator + filename ) ) ; } catch ( ioexception e ) { log . error ( "could not write to config file - {}" , e ) ; } }
tr	8	public deckbuild ( ) { for ( int r = 0 ; r < 13 ; r ++ ) { for ( int s = 0 ; s < 4 ; s ++ ) { rank = r + 1 ; suit = s + 1 ; deck . add ( new card ( suit , rank ) ) ; } } for ( int j = 0 ; j < deck . size ( ) ; j ++ ) { string rankstr = "" ; string suitstr = "" ; switch ( deck . get ( j ) . getrank ( ) ) { case 1 : rankstr = "ace" ; break ; case 11 : rankstr = "jack" ; break ; case 12 : rankstr = "queen" ; break ; case 13 : rankstr = "king" ; break ; default : rankstr = "" ; break ; } switch ( deck . get ( j ) . getsuit ( ) ) { case 1 : suitstr = "c" ; break ; case 2 : suitstr = "d" ; break ; case 3 : suitstr = "s" ; break ; case 4 : suitstr = "h" ; break ; } } shuffle ( deck ) ; for ( int h = 0 ; h < deck . size ( ) ; h ++ ) { if ( h == 0 || h % 2 == 0 ) { deckhalfone . add ( deck . get ( h ) ) ; } else { deckhalftwo . add ( deck . get ( h ) ) ; } } }
tr	9	public static void main ( string [ ] args ) { string base = "c:\\\\programs\\\\gcj\\\\fullbinarytree\\\\" ; string input = base + "input.in" ; string output = base + "output.out" ; scanner sc = null ; printwriter pw = null ; try { sc = new scanner ( new filereader ( input ) ) ; pw = new printwriter ( output ) ; int t = sc . nextint ( ) ; sc . nextline ( ) ; int count = 1 ; while ( t -- > 0 ) { int n = sc . nextint ( ) ; hashmap < integer , java . util . list < integer > > maps = new hashmap < integer , java . util . list < integer > > ( ) ; hashmap < integer , integer > degree = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int [ ] v = { sc . nextint ( ) , sc . nextint ( ) } ; for ( integer vi : v ) { if ( degree . containskey ( vi ) ) { int val = degree . get ( vi ) ; degree . put ( vi , val + 1 ) ; } else { degree . put ( vi , 1 ) ; } } arraylist < integer > list ; if ( maps . get ( v [ 0 ] ) != null ) { list = ( arraylist < integer > ) maps . get ( v [ 0 ] ) ; } else { list = new arraylist < integer > ( ) ; } list . add ( v [ 1 ] ) ; maps . put ( v [ 0 ] , list ) ; if ( maps . get ( v [ 1 ] ) != null ) { list = ( arraylist < integer > ) maps . get ( v [ 1 ] ) ; } else { list = new arraylist < integer > ( ) ; } list . add ( v [ 0 ] ) ; maps . put ( v [ 1 ] , list ) ; } int result = slove ( maps , degree , n ) ; pw . println ( "case #" + ( count ++ ) + ": " + result ) ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; } finally { if ( sc != null ) sc . close ( ) ; if ( pw != null ) pw . close ( ) ; } }
tr	3	public void osvjezistranicu ( ) { stringbuilder sss ; setchanged ( ) ; notifyobservers ( "novi interval!!!!!!" ) ; sb = rp . dohvatisadrzaj ( pocetnilink ) ; imedatoteke = rp . dohvatiimedatoteke ( pocetnilink ) ; sss = dohvatisadrzajdatoteke ( imedatoteke ) ; if ( sss != null ) { webstranica . setsadrzaj ( sss ) ; } else { if ( ztintor_zadaca_4 . ser ) { setogranicenje ( getogranicenje ( ) - 1 ) ; } ru . dohvatiresurs ( pocetnilink , rp , this ) ; dohvatilistupoveznica ( ) ; } res = update ( sb , imedatoteke ) ; setwebstranica ( res ) ; dohvatilistupoveznica ( ) ; }
tr	8	public treenode buildtree1 ( int [ ] preorder , int [ ] inorder ) { if ( preorder . length == 0 || inorder . length == 0 ) return null ; treenode mid = new treenode ( preorder [ 0 ] ) ; if ( preorder . length == 1 ) return mid ; int midindex = - 1 ; for ( int i = 0 ; i < inorder . length ; i ++ ) { if ( inorder [ i ] == mid . val ) { midindex = i ; break ; } } int [ ] leftinorder = { } , leftpreorder = { } ; if ( midindex > 0 ) { leftinorder = arrays . copyofrange ( inorder , 0 , midindex ) ; leftpreorder = arrays . copyofrange ( preorder , 1 , midindex + 1 ) ; } int [ ] rightinorder = { } , rightpreorder = { } ; if ( midindex < inorder . length - 1 ) { rightinorder = arrays . copyofrange ( inorder , midindex + 1 , inorder . length ) ; rightpreorder = arrays . copyofrange ( preorder , midindex + 1 , preorder . length ) ; } mid . left = buildtree1 ( leftpreorder , leftinorder ) ; mid . right = buildtree1 ( rightpreorder , rightinorder ) ; return mid ; }
tr	1	public void actionperformed ( actionevent arg0 ) { string rootpath = tfrootdirectory . gettext ( ) ; string filetype = tffiletypes . gettext ( ) ; string [ ] extensions = filetype . split ( ";" ) ; int numberoffiles = integer . parseint ( tfnumbeoffiles . gettext ( ) ) ; long maxfilesize = long . parselong ( tffilesize . gettext ( ) ) ; long maxid = long . parselong ( tfmaxid . gettext ( ) ) ; long minid = long . parselong ( tfminid . gettext ( ) ) ; configurations configurations = new configurations ( rootpath , extensions , numberoffiles , maxfilesize , minid , maxid , chckbxyes . isselected ( ) ) ; dispose ( ) ; serverrunningframe serverrunningframe = new serverrunningframe ( configurations ) ; }
tr	2	public void grabararchivodeclasejava ( string paquetecodigogenerado , string path ) { setpaquetecontenedor ( paquetecodigogenerado ) ; paquetecodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + paquetecodigogenerado + file . separatorchar + nombrevo + ".java" ; string content = generarcontenidoclase ( ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( content ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	3	public void oninvite ( string targetnick , string sourcenick , string sourcelogin , string sourcehostname , string channel ) { if ( targetnick . equalsignorecase ( getnick ( ) ) ) { if ( sourcenick . equalsignorecase ( "chanserv" ) ) { channel = channel . replace ( "chanserv!chanserv@services.gamesurge.net invite meowzy " , "" ) ; } log . consolelog ( "invite" , "being invited to " + channel + " by " + sourcenick + " (" + sourcelogin + "@" + sourcehostname + ")" ) ; if ( sourcehostname . equalsignorecase ( "irc.kieraan.co.uk" ) || sourcenick . equalsignorecase ( "chanserv" ) ) { log . consolelog ( "invite" , "accepting " + sourcenick + "'s invite to " + channel ) ; joinchannel ( channel ) ; } } }
tr	9	public int evalrpn ( string [ ] tokens ) { stack < integer > cal = new stack < integer > ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { try { int num = integer . parseint ( tokens [ i ] ) ; cal . push ( num ) ; } catch ( numberformatexception e ) { int op2 = ( int ) cal . pop ( ) ; int op1 = ( int ) cal . pop ( ) ; switch ( tokens [ i ] ) { case "+" : cal . push ( op1 + op2 ) ; break ; case "-" : cal . push ( op1 - op2 ) ; break ; case "*" : cal . push ( op1 * op2 ) ; break ; case "/" : cal . push ( op1 / op2 ) ; break ; default : return 0 ; } } } return ( int ) cal . pop ( ) ; }
tr	9	public static void findbestprofit ( int [ ] arr ) { if ( null == arr || arr . length <= 0 ) { system . out . println ( "empty cost record." ) ; return ; } if ( arr . length == 1 ) { system . out . println ( "best profit is: " + 0 ) ; return ; } int min = 0 ; int [ ] best = new int [ 2 ] ; min = arr [ 0 ] ; best [ 0 ] = arr [ 0 ] ; best [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; } if ( arr [ i ] - min > best [ 1 ] - best [ 0 ] ) { best [ 0 ] = min ; best [ 1 ] = arr [ i ] ; } } int profit = best [ 1 ] - best [ 0 ] ; system . out . println ( "best profit is when the gold is bought for " + best [ 0 ] + " and sold for " + best [ 1 ] + " making a profit of " + profit ) ; }
tr	3	public void run ( ) { log . info ( "process request\\n" ) ; int r = 0 ; try { is2 = s . getinputstream ( ) ; os = s . getoutputstream ( ) ; byte buf [ ] = new byte [ 10 * 1024 ] ; r = is2 . read ( buf ) ; if ( r > 0 ) { string header = new string ( buf , 0 , r , "ascii" ) ; from_net ( header ) ; } } catch ( exception e ) { try { log . error ( e . getmessage ( ) , e ) ; } catch ( exception ex ) { } } finally { try { if ( s != null ) s . close ( ) ; log . info ( "thread finished!" ) ; } catch ( ioexception e ) { } } }
tr	1	public void configure ( ) throws invalidconfigurationexception { configuration = new defaultconfiguration ( ) ; configuration . setpreservfittestindividual ( true ) ; configuration . setkeeppopulationsizeconstant ( true ) ; configuration . setrandomgenerator ( randomgenerator ) ; fitnessfunction = new fitnessfunctionadapter ( set , k , convergencecriterion , allpossibleparametervalues ) ; configuration . setbulkfitnessfunction ( new bulkfitnessnooffset ( fitnessfunction ) ) ; subsetchromosome = setupchromosome ( allelements ) ; configuration . setsamplechromosome ( subsetchromosome ) ; configuration . setpopulationsize ( populationsize ) ; progresslogger = new progresslogger ( log ) ; fitestsubset = new intarrayset ( ) ; configured = true ; }
tr	9	public static bufferedimage removebackground ( bufferedimage img , vector < somvector > inputs ) { map < somvector , integer > map = new hashmap < somvector , integer > ( ) ; vector < somvector > bckcols = new vector < somvector > ( ) ; int old = 0 ; for ( somvector s : inputs ) { map . put ( s , 0 ) ; } for ( int i = 0 ; i < img . getwidth ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < img . getheight ( ) - 1 ; j ++ ) { somvector v = new somvector ( new color ( img . getrgb ( i , j ) ) ) ; for ( somvector vec : inputs ) { if ( v . euclideandist ( vec ) < 0.02 ) { old = map . get ( vec ) ; map . put ( vec , old + 1 ) ; break ; } } } } int prc10 = ( int ) ( 0.1 * img . getwidth ( ) * img . getheight ( ) ) ; for ( map . entry < somvector , integer > entry : map . entryset ( ) ) { if ( entry . getvalue ( ) >= prc10 ) { bckcols . addelement ( entry . getkey ( ) ) ; } } for ( int i = 0 ; i < img . getwidth ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < img . getheight ( ) - 1 ; j ++ ) { for ( somvector vec : bckcols ) { somvector v = new somvector ( new color ( img . getrgb ( i , j ) ) ) ; if ( v . euclideandist ( vec ) < 0.02 ) { img . setrgb ( i , j , - 16777216 ) ; } } } } return img ; }
tr	10	public static void extractpatterns ( int classid ) { if ( classid == 1 ) { int basesize1 = baseitemmap1 . size ( ) ; for ( int i = 1 ; i < basesize1 ; i ++ ) { set < biginteger > previouscandidateset1 = frequentpatternmap1 . get ( i ) . keyset ( ) ; hashmap < biginteger , integer > currentcandidatemap1 = new hashmap < biginteger , integer > ( ) ; for ( biginteger previouscandidate1 : previouscandidateset1 ) { for ( biginteger baseitem1 : baseitemmap1 . keyset ( ) ) { biginteger newcandidate1 = previouscandidate1 . or ( baseitem1 ) ; if ( ! newcandidate1 . equals ( previouscandidate1 ) ) { int candidatefrequency1 = frequency ( newcandidate1 , 1 ) ; if ( candidatefrequency1 >= threshold ) { currentcandidatemap1 . put ( newcandidate1 , candidatefrequency1 ) ; } } } } if ( currentcandidatemap1 . size ( ) <= 0 ) { return ; } system . out . println ( ( i + 1 ) + " : " + currentcandidatemap1 . size ( ) ) ; frequentpatternmap1 . put ( i + 1 , currentcandidatemap1 ) ; } system . out . println ( frequentpatternmap1 . size ( ) ) ; } else if ( classid == 2 ) { int basesize2 = baseitemmap2 . size ( ) ; for ( int i = 1 ; i < basesize2 ; i ++ ) { set < biginteger > previouscandidateset2 = frequentpatternmap2 . get ( i ) . keyset ( ) ; hashmap < biginteger , integer > currentcandidatemap2 = new hashmap < biginteger , integer > ( ) ; for ( biginteger previouscandidate2 : previouscandidateset2 ) { for ( biginteger baseitem2 : baseitemmap2 . keyset ( ) ) { biginteger newcandidate2 = previouscandidate2 . or ( baseitem2 ) ; if ( ! newcandidate2 . equals ( previouscandidate2 ) ) { int candidatefrequency2 = frequency ( newcandidate2 , 2 ) ; if ( candidatefrequency2 >= threshold ) { currentcandidatemap2 . put ( newcandidate2 , candidatefrequency2 ) ; } } } } if ( currentcandidatemap2 . size ( ) <= 0 ) { return ; } system . out . println ( ( i + 1 ) + " : " + currentcandidatemap2 . size ( ) ) ; frequentpatternmap2 . put ( i + 1 , currentcandidatemap2 ) ; } system . out . println ( frequentpatternmap2 . size ( ) ) ; } }
tr	9	public int lengthoflongestsubstring1 ( string s ) { if ( s . length ( ) <= 1 ) return s . length ( ) ; int i = 0 , max = 1 ; int [ ] map = new int [ 256 ] ; for ( int k = 0 ; k < 256 ; k ++ ) map [ k ] = - 1 ; while ( i < s . length ( ) - 1 ) { map [ s . charat ( i ) ] = i ; int j = i + 1 ; for ( ; j < s . length ( ) && ( map [ s . charat ( j ) ] < i || map [ s . charat ( j ) ] == j ) ; j ++ ) { map [ s . charat ( j ) ] = j ; } max = math . max ( max , j - i ) ; if ( j == s . length ( ) ) return max ; i = map [ s . charat ( j ) ] + 1 ; } return max ; }
tr	7	public void nextstep ( ) { boardtemp = new board ( board ) ; for ( int i = 0 ; i < board . gettablica_length ( ) ; i ++ ) { for ( int j = 0 ; j < board . gettablica_length ( ) ; j ++ ) { if ( ! board . isalive ( i , j ) ) { if ( board . neigtbourscount ( i , j ) == 3 ) { boardtemp . settablica ( i , j , true ) ; } } else { if ( ( board . neigtbourscount ( i , j ) == 1 || ( board . neigtbourscount ( i , j ) == 0 ) ) || board . neigtbourscount ( i , j ) > 3 ) boardtemp . settablica ( i , j , false ) ; } } } board . settablica ( boardtemp . gettablica ( ) ) ; }
tr	2	public static arraylist < string > gettagcontents ( document doc ) { arraylist < string > extracts = new arraylist < string > ( ) ; element title = doc . select ( "title" ) . first ( ) ; extracts . add ( ( title == null ) ? "" : title . text ( ) ) ; string h1string = "" ; elements h1list = doc . select ( "h1" ) ; for ( element h1 : h1list ) { h1string += h1 . text ( ) + " " ; } extracts . add ( ( h1string == null ) ? "" : h1string ) ; string h2string = "" ; elements h2list = doc . select ( "h2" ) ; for ( element h2 : h2list ) { h2string += h2 . text ( ) + " " ; } extracts . add ( ( h2string == null ) ? "" : h2string ) ; string h3string = "" ; elements h3list = doc . select ( "h3" ) ; for ( element h3 : h3list ) { h1string += h3 . text ( ) + " " ; } extracts . add ( ( h3string == null ) ? "" : h3string ) ; string bstring = "" ; elements blist = doc . select ( "b" ) ; for ( element b : blist ) { bstring += b . text ( ) + " " ; } extracts . add ( ( bstring == null ) ? "" : bstring ) ; string strongstring = "" ; elements stronglist = doc . select ( "strong" ) ; for ( element strong : stronglist ) { strongstring += strong . text ( ) + " " ; } extracts . add ( ( strongstring == null ) ? "" : strongstring ) ; string emstring = "" ; elements emlist = doc . select ( "em" ) ; for ( element em : emlist ) { emstring += em . text ( ) + " " ; } extracts . add ( ( emstring == null ) ? "" : emstring ) ; string astring = "" ; elements alist = doc . select ( "a" ) ; for ( element a : alist ) { emstring += a . text ( ) + " " ; } extracts . add ( ( astring == null ) ? "" : astring ) ; return extracts ; }
tr	9	public void run ( ) { http10 = true ; boolean badhost = false ; try { in = new datainputstream ( new bufferedinputstream ( s . getinputstream ( ) ) ) ; ou = new dataoutputstream ( new bufferedoutputstream ( s . getoutputstream ( ) ) ) ; s . setsotimeout ( httpreq . client_timeout ) ; string req = in . readline ( ) ; if ( req == null ) { s . close ( ) ; ou . close ( ) ; s = null ; ou = null ; return ; } if ( httpreq . trace_timestamp ) { system . out . println ( "[ui trace " + thread . currentthread ( ) . getname ( ) + "] t current time " + new date ( ) ) ; } if ( httpreq . trace_url == true ) { system . out . println ( "[ui trace " + thread . currentthread ( ) . getname ( ) + "] > " + req ) ; } int req_method ; req_method = req . indexof ( " http/1." , 0 ) ; if ( req_method == - 1 ) http10 = false ; else while ( true ) { string line ; line = in . readline ( ) ; if ( line == null ) break ; if ( line . length ( ) == 0 ) break ; string s1 , s2 ; int j ; j = line . indexof ( ':' , 0 ) ; if ( j == - 1 ) continue ; s1 = line . substring ( 0 , j ) . tolowercase ( ) ; s2 = line . substring ( j + 1 ) ; if ( s1 . equals ( "host" ) && s2 . indexof ( ui . ui_hostname ) == - 1 ) badhost = true ; } string req2 = null ; if ( ! req . startswith ( "get " ) ) { httpreq . server_error ( http10 ? 10 : 9 , 501 , "only get access method is possible for ui" , ou ) ; } if ( ! mgr . checkinetadr ( s . getinetaddress ( ) . getaddress ( ) ) ) { httpreq . server_error ( http10 ? 10 : 9 , 403 , "cache access denied." , ou ) ; } int space ; space = req . indexof ( ' ' ) ; if ( space == - 1 ) httpreq . server_error ( http10 ? 10 : 9 , 400 , "can not find method and uri in request" , ou ) ; if ( req_method == - 1 ) req2 = req . substring ( space + 1 ) ; else req2 = req . substring ( space + 1 , req_method ) ; req2 = req2 . trim ( ) ; if ( req2 . length ( ) == 0 ) httpreq . server_error ( http10 ? 10 : 9 , 400 , "can not find uri in request" , ou ) ; if ( req2 . charat ( 0 ) != '/' ) { httpreq . server_error ( http10 ? 10 : 9 , 400 , "request url not starting with /" , ou ) ; } if ( req2 . equals ( "/" ) ) { req2 = "/homepage" ; badhost = true ; } if ( badhost == false ) { send_reply ( ui . process ( req2 ) ) ; } else { stringbuffer ans = new stringbuffer ( 2048 ) ; ans . append ( "http/1.0 301 wrong_hostname\\r\\ncontent-type: text/html\\r\\n" ) ; ans . append ( "location: http://" ) ; ans . append ( ui . ui_hostname ) ; ans . append ( ':' ) ; ans . append ( ui . uiport ) ; ans . append ( req2 ) ; ans . append ( "\\r\\n\\r\\nbad hostname/redirecting to welcome page!\\n" ) ; ou . writebytes ( ans . tostring ( ) ) ; ou . close ( ) ; ou = null ; s = null ; } } catch ( ioexception err ) { } }
tr	1	private static string pythoneval ( string equation ) { printstream tempwriter = null ; bufferedreader reader = null ; try { file tempfile = new file ( "temp.py" ) ; tempwriter = new printstream ( tempfile ) ; tempwriter . printf ( "print(%s)" , equation ) ; process python = new processbuilder ( "python" , "temp.py" ) . start ( ) ; reader = new bufferedreader ( new inputstreamreader ( python . getinputstream ( ) ) ) ; python . waitfor ( ) ; string response = reader . readline ( ) ; python . destroy ( ) ; tempfile . delete ( ) ; return response ; } catch ( ioexception e ) { } catch ( interruptedexception e ) { } finally { close ( tempwriter ) ; close ( reader ) ; } return "" ; }
tr	5	public rootframe ( ) { super ( "an expert car chooser" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 578 , 453 ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; setcontentpane ( contentpane ) ; contentpane . setlayout ( null ) ; jpanel panel = new jpanel ( ) ; panel . setbounds ( 5 , 5 , 212 , 398 ) ; contentpane . add ( panel ) ; panel . setlayout ( null ) ; jcombobox < prologmodelapplicable > combobox_1 = new jcombobox < prologmodelapplicable > ( ) ; combobox_1 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carmanufacturerproductiontype . values ( ) ) ) ; combobox_1 . setbounds ( 0 , 21 , 202 , 19 ) ; combobox_1 . settooltiptext ( "choose country" ) ; combobox_1 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_1 ) ; panel . add ( combobox_1 ) ; jcombobox < prologmodelapplicable > combobox = new jcombobox < prologmodelapplicable > ( ) ; combobox . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carsuspensiontype . values ( ) ) ) ; combobox . setbounds ( 0 , 66 , 202 , 19 ) ; mprologcontentcomboboxes . add ( combobox ) ; combobox . setselectedindex ( - 1 ) ; panel . add ( combobox ) ; jcombobox < prologmodelapplicable > combobox_3 = new jcombobox < prologmodelapplicable > ( ) ; mprologcontentcomboboxes . add ( combobox_3 ) ; combobox_3 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cargastype . values ( ) ) ) ; combobox_3 . setbounds ( 0 , 113 , 202 , 19 ) ; combobox_3 . setselectedindex ( - 1 ) ; panel . add ( combobox_3 ) ; jcombobox < prologmodelapplicable > combobox_2 = new jcombobox < prologmodelapplicable > ( ) ; mprologcontentcomboboxes . add ( combobox_2 ) ; combobox_2 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cardoorstype . values ( ) ) ) ; combobox_2 . setbounds ( 0 , 162 , 202 , 19 ) ; combobox_2 . setselectedindex ( - 1 ) ; panel . add ( combobox_2 ) ; jlabel lblmanufacturercountry = new jlabel ( "manufacturer country" ) ; lblmanufacturercountry . setbounds ( 0 , 0 , 138 , 14 ) ; panel . add ( lblmanufacturercountry ) ; jlabel lblbodytype = new jlabel ( "suspension type" ) ; lblbodytype . setbounds ( 0 , 51 , 138 , 14 ) ; panel . add ( lblbodytype ) ; jlabel lblgastype = new jlabel ( "gas type" ) ; lblgastype . setbounds ( 0 , 96 , 138 , 14 ) ; panel . add ( lblgastype ) ; jlabel lblnewlabel_1 = new jlabel ( "doors amount" ) ; lblnewlabel_1 . setbounds ( 0 , 148 , 95 , 14 ) ; panel . add ( lblnewlabel_1 ) ; jlabel lblprice = new jlabel ( "price" ) ; lblprice . setbounds ( 0 , 192 , 138 , 14 ) ; panel . add ( lblprice ) ; jcombobox < prologmodelapplicable > combobox_4 = new jcombobox < prologmodelapplicable > ( ) ; combobox_4 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carpricetype . values ( ) ) ) ; combobox_4 . setbounds ( 0 , 210 , 202 , 19 ) ; combobox_4 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_4 ) ; panel . add ( combobox_4 ) ; jlabel lblturbotype = new jlabel ( "turbo type" ) ; lblturbotype . setbounds ( 0 , 241 , 138 , 14 ) ; panel . add ( lblturbotype ) ; jcombobox < prologmodelapplicable > combobox_5 = new jcombobox < prologmodelapplicable > ( ) ; combobox_5 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( carturbotype . values ( ) ) ) ; combobox_5 . setbounds ( 0 , 257 , 202 , 19 ) ; combobox_5 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_5 ) ; panel . add ( combobox_5 ) ; jlabel lbltrunktype = new jlabel ( "trunk type" ) ; lbltrunktype . setbounds ( 0 , 287 , 138 , 14 ) ; panel . add ( lbltrunktype ) ; jcombobox < prologmodelapplicable > combobox_6 = new jcombobox < prologmodelapplicable > ( ) ; combobox_6 . setmodel ( new defaultcomboboxmodel < prologmodelapplicable > ( cartrunkcapacitytype . values ( ) ) ) ; combobox_6 . setbounds ( 0 , 303 , 202 , 19 ) ; combobox_6 . setselectedindex ( - 1 ) ; mprologcontentcomboboxes . add ( combobox_6 ) ; panel . add ( combobox_6 ) ; jbutton btnnewbutton = new jbutton ( "reset choices" ) ; btnnewbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { mexpertanswerrootpane . settext ( "" ) ; for ( jcombobox < prologmodelapplicable > combobox : mprologcontentcomboboxes ) { combobox . setselectedindex ( - 1 ) ; } } } ) ; btnnewbutton . setbounds ( 38 , 364 , 138 , 23 ) ; panel . add ( btnnewbutton ) ; jpanel panel_1 = new jpanel ( ) ; panel_1 . setbounds ( 217 , 5 , 338 , 398 ) ; contentpane . add ( panel_1 ) ; panel_1 . setlayout ( null ) ; jlabel lblnewlabel = new jlabel ( "choose properties and ask the expert." ) ; lblnewlabel . setbounds ( 59 , 11 , 226 , 14 ) ; panel_1 . add ( lblnewlabel ) ; lblnewlabel . sethorizontalalignment ( swingconstants . center ) ; jbutton btnaskexpert = new jbutton ( "ask expert" ) ; btnaskexpert . setbounds ( 89 , 36 , 163 , 23 ) ; btnaskexpert . addactionlistener ( new askexpertbuttonactionlistener ( ) ) ; panel_1 . add ( btnaskexpert ) ; mexpertanswerrootpane = new jtextpane ( ) ; mexpertanswerrootpane . setbounds ( 21 , 69 , 292 , 318 ) ; jscrollpane pane = new jscrollpane ( mexpertanswerrootpane ) ; pane . setbounds ( 21 , 69 , 292 , 318 ) ; panel_1 . add ( pane ) ; }
tr	6	public static boolean ispasswordvalid ( char [ ] password , int minlength , boolean digitrequired , boolean lowercaserequired , boolean uppercaserequired , boolean specialcharrequired ) { boolean hasdigit = false ; boolean haslower = false ; boolean hasupper = false ; boolean hasspecialchar = false ; if ( password . length >= minlength ) { for ( int i = 0 ; i < password . length ; i ++ ) { char c = password [ i ] ; if ( character . isdigit ( c ) ) { hasdigit = true ; } if ( character . isletter ( c ) && character . islowercase ( c ) ) { haslower = true ; } if ( character . isletter ( c ) && ! character . islowercase ( c ) ) { hasupper = true ; } if ( ! character . isdigit ( c ) && ! character . isalphabetic ( c ) ) { hasspecialchar = true ; } } if ( digitrequired == hasdigit && lowercaserequired == haslower && uppercaserequired == hasupper && specialcharrequired == hasspecialchar ) { return true ; } } return false ; }
tr	1	private short countcentercolumn ( ) { short result = 0 ; for ( byte row = 0 ; row < fourinrowpuzzle . gethieght ( ) - 1 ; row ++ ) { if ( this . originalpuzzle . holes [ row ] [ 3 ] . isempty ( ) && this . apuzzle . holes [ row ] [ 3 ] . getcolor ( ) == players . player1 ) result += 10 ; else if ( this . originalpuzzle . holes [ row ] [ 3 ] . isempty ( ) && this . apuzzle . holes [ row ] [ 3 ] . getcolor ( ) == players . player2 ) result -= 10 ; } return result ; }
tr	1	private void loadresources ( ) { classloader classloader = getclass ( ) . getclassloader ( ) ; rock32image = new imageicon ( classloader . getresource ( "resources/asteroid2-32.png" ) ) . getimage ( ) ; rock48image = new imageicon ( classloader . getresource ( "resources/asteroid2-48.png" ) ) . getimage ( ) ; rock64image = new imageicon ( classloader . getresource ( "resources/asteroid2-64.png" ) ) . getimage ( ) ; shipimage = new imageicon ( classloader . getresource ( "resources/spaceship2-64.png" ) ) . getimage ( ) ; bulletimage = new imageicon ( classloader . getresource ( "resources/bullet2-6x12.png" ) ) . getimage ( ) ; for ( int i = 0 ; i <= 17 ; i ++ ) { explosionimages . add ( new imageicon ( classloader . getresource ( "resources/explosion/ex" + i + ".png" ) ) . getimage ( ) ) ; } rock32bounds = objectbounds . parsefromfile ( classloader . getresource ( "resources/asteroid2-32.txt" ) ) ; rock48bounds = objectbounds . parsefromfile ( classloader . getresource ( "resources/asteroid2-48.txt" ) ) ; rock64bounds = objectbounds . parsefromfile ( classloader . getresource ( "resources/asteroid2-64.txt" ) ) ; shipbounds = objectbounds . parsefromfile ( classloader . getresource ( "resources/spaceship2-64.txt" ) ) ; bulletbounds = objectbounds . parsefromfile ( classloader . getresource ( "resources/bullet2-6x12.txt" ) ) ; explosionsound = helper . filetobytearray ( classloader . getresource ( "resources/explosion.wav" ) ) ; }
tr	10	private int checkfornakedpairs ( int x , int y , int i ) { int pairindex = - 1 ; linkedlist < string > comparator = nakeds . get ( i ) . values ; for ( int index = i ; index < nakeds . size ( ) && pairindex < 0 ; index ++ ) { nakedcandidates current = nakeds . get ( index ) ; if ( current . values . size ( ) == 2 && index != i ) { linkedlist < string > candidate = current . values ; pairindex = ( comparator . get ( 0 ) . equals ( candidate . get ( 0 ) ) && comparator . get ( 1 ) . equals ( candidate . get ( 1 ) ) ? index : - 1 ) ; boolean removed = ( pairindex > - 1 ) ? removecandidatepairs ( nakeds . get ( i ) , current ) : false ; pairindex = ( removed ? pairindex : - 1 ) ; } } return pairindex ; }
tr	6	public string tostring ( ) { string format = "" ; if ( this . a == 0 ) if ( this . b == - 1 ) return "-i" ; else if ( this . b == 0 ) return "0" ; else if ( this . b == 1 ) return "i" ; else return string . format ( "%di" , this . b ) ; else if ( this . b == - 1 ) return string . format ( "%d-i" , this . a ) ; else if ( this . b == 0 ) return string . format ( "%d" , this . a ) ; else if ( this . b == 1 ) return string . format ( "%d+i" , this . a ) ; else return string . format ( this . b < 0 ? "%d%di" : "%d+%di" , this . a , this . b ) ; }
tr	6	public static void main ( string [ ] args ) { system . out . print ( "enter the array's length\\n" ) ; int usernumber = sc . nextint ( ) ; int [ ] array = new int [ usernumber ] ; for ( int i = 0 ; i < usernumber ; i ++ ) { array [ i ] = r . nextint ( 100 ) ; } system . out . println ( arrays . tostring ( array ) + "-before sorting\\n" ) ; int userchoice ; do { userchoice = showmenu ( ) ; switch ( userchoice ) { case 1 : megasorter sort1 = new megasorter ( new bubblesort ( ) ) ; sort1 . setdelegate ( new bubblesort ( ) ) ; sort1 . sort ( array ) ; system . out . println ( "bubble sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 2 : megasorter sort2 = new megasorter ( new mergesort ( ) ) ; sort2 . setdelegate ( new mergesort ( ) ) ; sort2 . sort ( array ) ; system . out . println ( "merge sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 3 : megasorter sort3 = new megasorter ( new countsort ( ) ) ; sort3 . setdelegate ( new countsort ( ) ) ; sort3 . sort ( array ) ; system . out . println ( "count sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 4 : megasorter sort4 = new megasorter ( new treesort ( ) ) ; sort4 . setdelegate ( new treesort ( ) ) ; sort4 . sort ( array ) ; system . out . println ( "tree sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; default : break ; } } while ( userchoice != 0 ) ; }
tr	3	public static void writeseperatefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata , string filename ) throws ioexception { filewriter fstream = new filewriter ( path_location + filename ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) ) ; out . newline ( ) ; out . write ( url ) ; out . newline ( ) ; out . write ( path ) ; out . newline ( ) ; if ( parenturl != null ) { out . write ( parenturl ) ; out . newline ( ) ; } out . write ( title ) ; out . newline ( ) ; out . write ( h1 ) ; out . newline ( ) ; out . write ( h2 ) ; out . newline ( ) ; out . write ( h3 ) ; out . newline ( ) ; out . write ( bold ) ; out . newline ( ) ; out . write ( strong ) ; out . newline ( ) ; out . write ( em ) ; out . newline ( ) ; out . write ( anchortext ) ; out . newline ( ) ; out . write ( parseddata ) ; out . close ( ) ; }
tr	3	private string cambionombreentitytovo ( string nombreatributo ) { system . out . println ( "entra " + nombreatributo ) ; for ( string prefijo : getsufijosnegocio ( ) ) { nombreatributo = nombreatributo . replace ( prefijo , "vo" ) ; } for ( string prefijo : getsufijosnegocio ( ) ) { string prefijominusculas = prefijo ; prefijominusculas = prefijominusculas . substring ( 0 , 1 ) . tolowercase ( ) + prefijominusculas . substring ( 1 ) ; nombreatributo = nombreatributo . replace ( prefijominusculas , "vo" ) ; } system . out . println ( "sale " + nombreatributo ) ; return nombreatributo ; }
tr	1	public void incp5 ( ) { g1 = cp5 . addgroup ( "g1" ) . setposition ( 0 , 11 ) . setbackgroundheight ( 100 ) . setbackgroundcolor ( color ( 50 , 100 ) ) . setlabel ( "levels" ) ; cp5 . addtextfield ( "numlevels" ) . setcaptionlabel ( "number of levels" ) . setposition ( 10 , 10 ) . setsize ( 70 , 15 ) . setvalue ( "1" ) . setautoclear ( false ) . setgroup ( g1 ) ; cp5 . addtextfield ( "lvlwidth" ) . setcaptionlabel ( "level width" ) . setposition ( 10 , 40 ) . setsize ( 70 , 15 ) . setvalue ( "40" ) . setautoclear ( false ) . setgroup ( g1 ) ; cp5 . addbutton ( "addlevel" ) . setcaptionlabel ( "add level" ) . setposition ( 10 , 70 ) . setsize ( 70 , 15 ) . setgroup ( g1 ) ; g2 = cp5 . addgroup ( "g2" ) . setposition ( 0 , 121 ) . setwidth ( 300 ) . activateevent ( true ) . setbackgroundcolor ( color ( 50 , 100 ) ) . setbackgroundheight ( 100 ) . setlabel ( "hello world." ) . bringtofront ( ) . setmoveable ( true ) ; cp5 . addslider ( "s-1" ) . setposition ( 80 , 10 ) . setsize ( 180 , 9 ) . setgroup ( g2 ) ; cp5 . addslider ( "s-2" ) . setposition ( 80 , 20 ) . setsize ( 180 , 9 ) . setgroup ( g2 ) ; cp5 . addradiobutton ( "radio" ) . setposition ( 10 , 10 ) . setsize ( 20 , 9 ) . additem ( "black" , 0 ) . additem ( "red" , 1 ) . additem ( "green" , 2 ) . additem ( "blue" , 3 ) . additem ( "grey" , 4 ) . setgroup ( g2 ) ; cp5 . setautodraw ( false ) ; }
tr	6	@ requestmapping ( applicationconstants . join_chat ) public object joinchatroom ( @ requestparam ( "chatroomid" ) string chatroomid , @ requestparam ( "userid" ) string userid ) { userchatroom chatroom = new userchatroom ( ) ; map < object , string > errormap = new hashmap < object , string > ( ) ; system . out . println ( "name11111" + chatroomid ) ; if ( chatroomid == null || "" . equals ( chatroomid ) ) { errormap . put ( 1 , "please enter chatroomid" ) ; } if ( userid == null || "" . equals ( userid ) ) { errormap . put ( 2 , "please enter userid" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { user userfromdb = userdao . getuser ( integer . parseint ( userid ) ) ; chatroom chatroomfromdb = chatroomdao . getchatroom ( integer . parseint ( chatroomid ) ) ; if ( userfromdb == null ) { errormap . put ( 3 , "user does not exist" ) ; return errormap ; } else if ( chatroomfromdb == null ) { errormap . put ( 4 , "chat room does not exist" ) ; return errormap ; } else { userchatroomcompoundkey userchatroom = new userchatroomcompoundkey ( ) ; userchatroom . setuserid ( integer . parseint ( userid ) ) ; userchatroom . setchatroomid ( integer . parseint ( chatroomid ) ) ; chatroom . setuserchatroomck ( userchatroom ) ; chatroom . setcreateddate ( new date ( ) . tostring ( ) ) ; system . out . println ( "##########################" ) ; chatroomdao . joinchatroom ( chatroom ) ; return chatroom ; } } }
tr	5	@ override public void handle ( ) throws ioexception { byte pid = in . readbyte ( ) ; if ( ! ( pid == 1 || pid == 2 ) ) { server . error ( string . format ( "%s got wrong packet id: %u02x" , this . getclass ( ) . getsimplename ( ) , pid ) ) ; in . close ( ) ; return ; } pingid = in . readlong ( ) ; magic1 = in . readlong ( ) ; magic2 = in . readlong ( ) ; boolean magic = magic1 == constants . raknet_magic_1 && magic2 == constants . raknet_magic_2 ; packetpong response = new packetpong ( ip , port ) ; response . construct ( ( byte ) 0x1c , pingid ) ; response . send ( ) ; in . close ( ) ; }
tr	9	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == caesarshiftbutton ) { string inputstring = ( ( jtextfield ) caesarinputpanel . getcomponent ( 1 ) ) . gettext ( ) ; int [ ] charsteps = new int [ caesarspinnerpanel . getcomponentcount ( ) ] ; for ( int i = 0 ; i < charsteps . length ; i ++ ) charsteps [ i ] = ( int ) ( ( jspinner ) caesarspinnerpanel . getcomponent ( i ) ) . getvalue ( ) ; boolean right = ( caesarreverse . isselected ( ) ) ? false : true ; string outputstring = caesar . shift ( inputstring , charsteps , right ) ; ( ( jtextfield ) caesaroutputpanel . getcomponent ( 1 ) ) . settext ( outputstring ) ; } else if ( e . getsource ( ) == caesaraddspinners ) { if ( caesarspinnerpanel . getcomponentcount ( ) < 13 ) { jspinner jspinner = new jspinner ( new spinnernumbermodel ( 1 , 1 , 26 , 1 ) ) ; jspinner . setpreferredsize ( new dimension ( 50 , 25 ) ) ; caesarspinnerpanel . add ( jspinner ) ; revalidate ( ) ; repaint ( ) ; } } else if ( e . getsource ( ) == caesarremovespinners ) { if ( caesarspinnerpanel . getcomponentcount ( ) > 1 ) { caesarspinnerpanel . remove ( caesarspinnerpanel . getcomponentcount ( ) - 1 ) ; revalidate ( ) ; repaint ( ) ; } } else if ( e . getsource ( ) == desencryptbutton ) { string message = ( ( jtextfield ) desinputpanel . getcomponent ( 1 ) ) . gettext ( ) ; string key = ( ( jtextfield ) desinputpanel . getcomponent ( 3 ) ) . gettext ( ) ; arraylist < string > output = des . encrypt ( key , message ) ; string outputstring = "" ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) outputstring += output . get ( i ) ; ( ( jtextarea ) ( ( jviewport ) desoutputpane . getcomponent ( 0 ) ) . getview ( ) ) . settext ( outputstring ) ; } else if ( e . getsource ( ) == rsaencryptbutton ) { string pin = ( ( jtextfield ) rsainputpanel . getcomponent ( 1 ) ) . gettext ( ) ; string qin = ( ( jtextfield ) rsainputpanel . getcomponent ( 3 ) ) . gettext ( ) ; string ein = ( ( jtextfield ) rsainputpanel . getcomponent ( 5 ) ) . gettext ( ) ; string min = ( ( jtextfield ) rsainputpanel . getcomponent ( 7 ) ) . gettext ( ) ; arraylist < string > output = rsa . encrypt ( biginteger . valueof ( long . parselong ( pin ) ) , biginteger . valueof ( long . parselong ( qin ) ) , biginteger . valueof ( long . parselong ( ein ) ) , biginteger . valueof ( long . parselong ( min ) ) ) ; string outputstring = "" ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) outputstring += output . get ( i ) + "\\n" ; ( ( jtextarea ) ( ( jviewport ) rsaoutputpane . getcomponent ( 0 ) ) . getview ( ) ) . settext ( outputstring ) ; } }
tr	4	public void generate ( arraylist < node > input ) { for ( iterator < node > iterator = input . iterator ( ) ; iterator . hasnext ( ) ; ) { node i = iterator . next ( ) ; if ( ! this . haschild ( i . getname ( ) ) ) { this . appendchild ( i ) ; i = nodes . get ( i . getname ( ) ) ; iterator . remove ( ) ; i . generate ( input ) ; } else { i = nodes . get ( i . getname ( ) ) ; iterator . remove ( ) ; i . generate ( input ) ; } } }
tr	5	public void build ( reader < post > reader , string filename ) throws filenotfoundexception { if ( reader == null ) { throw new illegalargumentexception ( ) ; } ngramidmap . clear ( ) ; indexmap . clear ( ) ; reader . open ( filename ) ; system . out . println ( "building dictionary" ) ; while ( reader . hasnext ( ) ) { post next = reader . next ( ) ; addstring ( next . getmessage ( ) ) ; system . out . print ( "\\rgroup: " + next . getgroupid ( ) ) ; } reader . close ( ) ; system . out . println ( "\\nsaving dictionary to file" ) ; save ( dictionary_filename ) ; system . out . println ( "building done" ) ; }
tr	9	private void breakword ( string s , set < string > dict , arraylist < string > path , arraylist < string > res ) { if ( s . length ( ) == 0 ) { string r = "" ; for ( string p : path ) { r = r + ( r . length ( ) == 0 ? p : " " + p ) ; } res . add ( r ) ; return ; } for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { string curr = s . substring ( 0 , i ) ; for ( string d : dict ) { if ( curr . equals ( d ) ) { path . add ( d ) ; breakword ( s . substring ( i ) , dict , path , res ) ; path . remove ( d ) ; } } } }
tr	2	public static void main ( string [ ] args ) { chat ch = new chat ( ) ; if ( args . length == 1 ) { int port = integer . parseint ( args [ 0 ] ) ; ch . mode1 ( port ) ; } else if ( args . length == 2 ) { debug . print ( args [ 0 ] ) ; debug . print ( args [ 1 ] ) ; int port = integer . parseint ( args [ 0 ] ) ; string host = args [ 1 ] ; ch . mode2 ( port , host ) ; } else { system . out . println ( "usage: java chat <port num> [<host name>]" ) ; system . exit ( 0 ) ; } }
tr	6	public static byte [ ] decodebytearray ( object obj ) throws exception { byte [ ] ba = null ; if ( obj instanceof arrayparameter ) { final arrayparameter arrayparameter = ( arrayparameter ) obj ; final arraylist < ? > values = arrayparameter . getvalues ( ) ; ba = new byte [ values . size ( ) ] ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { singleparameter param = ( singleparameter ) values . get ( i ) ; object value = param . getvalue ( ) ; if ( ! ( value instanceof integer ) ) { throw new illegalargumentexception ( "invalid type" ) ; } int intvalue = ( ( integer ) value ) . intvalue ( ) ; ba [ i ] = inttobyte ( intvalue ) ; } } return ba ; }
tr	7	public void printwordlist ( string partialword , int state , printwriter out ) throws ioexception { if ( state == 0xffff ) { system . out . println ( partialword ) ; if ( out != null ) { out . println ( partialword ) ; } } else { for ( int i = 0 ; i < numcols ; i ++ ) { int newstate = ( getnextstate ( state , i ) ) & 0xffff ; if ( newstate != 0 ) { char newchar = reversecolumnmap [ i ] ; string newpartialword = partialword ; if ( newchar != 0 ) { newpartialword += newchar ; } printwordlist ( newpartialword , newstate , out ) ; } } } }
tr	7	public static void main ( final string ... args ) { final integer operand1 = 1 , operand2 = 2 , operand3 = 3 ; final integer sum = lambdafunction . < integer > dooperation ( ( op1 , op2 ) -> op1 + op2 , operand1 , operand2 ) ; final integer diff = lambdafunction . dooperation ( getintdiffoperation ( ) , operand1 , operand2 ) ; final integer product = lambdafunction . dooperation ( lambdafunction :: multiply , operand1 , operand2 ) ; final integer mod = lambdafunction . dooperation ( new lambdafunction ( ) :: mod , operand1 , operand2 ) ; final composableoperation < integer > additionoperation = ( op1 , op2 ) -> op1 + op2 ; final composableoperation < integer > productoperation = new composableoperation < integer > ( ) { @ override public integer apply ( final integer op1 , final integer op2 ) { return op1 * op2 ; } @ override public int getprecedence ( ) { return 6 ; } } ; final integer exprval = additionoperation . compose ( productoperation , operand1 , operand2 , operand3 ) ; final integer exprval2 = productoperation . compose ( additionoperation , operand1 , operand2 , operand3 ) ; system . out . println ( string . format ( "op1: %d op2: %d op3: %d %n sum: %d %n diff: %d %n " + "product: %d %n mod: %d %n compose(op1 + op2 * op3) 1: %d %n compose(op1 + op2 * op3) 2: %d %n" , operand1 , operand2 , operand3 , sum , diff , product , mod , exprval , exprval2 ) ) ; }
tr	2	public channelsftp connect ( string server_ip , int server_port , string user_name , string password ) { channelsftp sftp = null ; try { jsch jsch = new jsch ( ) ; jsch . getsession ( user_name , server_ip , server_port ) ; session sshsession = jsch . getsession ( user_name , server_ip , server_port ) ; system . out . println ( "session created." ) ; sshsession . setpassword ( password ) ; properties sshconfig = new properties ( ) ; sshconfig . put ( "stricthostkeychecking" , "no" ) ; sshsession . setconfig ( sshconfig ) ; sshsession . connect ( ) ; system . out . println ( "session connected." ) ; system . out . println ( "opening channel." ) ; channel channel = sshsession . openchannel ( "sftp" ) ; channel . connect ( ) ; sftp = ( channelsftp ) channel ; system . out . println ( "connected to " + server_ip + "." ) ; } catch ( exception e ) { } return sftp ; }
tr	4	private void update ( int cycles ) { if ( cycles < 0 ) { while ( true ) { scape . step ( ) ; addinfo ( scape . grid [ scape . mainpanel . xselected ] [ scape . mainpanel . yselected ] ) ; scape . epochs ++ ; string ep = "epochs:  " + scape . epochs ; epochslabel . settext ( ep ) ; } } else { for ( int c = 0 ; c < cycles ; c ++ ) { scape . step ( ) ; addinfo ( scape . grid [ scape . mainpanel . xselected ] [ scape . mainpanel . yselected ] ) ; scape . epochs ++ ; string ep = "epochs:  " + scape . epochs ; epochslabel . settext ( ep ) ; scape . mainpanel . update ( ) ; } } }
tr	5	public static arraylist < integer > createnewalreadyseen ( arraylist < integer > alreadyseenold ) { arraylist < integer > alreadyseennew = new arraylist < > ( ) ; for ( int i = 0 ; i < alreadyseenold . size ( ) ; i ++ ) alreadyseennew . add ( alreadyseenold . get ( i ) ) ; for ( int i = 0 ; i < mainclass . connectedto . size ( ) ; i ++ ) { if ( ! alreadyseenold . contains ( mainclass . connectedto . get ( i ) . hostname ) ) alreadyseennew . add ( mainclass . connectedto . get ( i ) . hostname ) ; } return alreadyseennew ; }
tr	1	public static void main ( string [ ] args ) throws unknownhostexception , ioexception { try { serversocket serversocket = new serversocket ( 3132 , 50 , inetaddress . getbyname ( "localhost" ) ) ; executorservice executorservice = executors . newfixedthreadpool ( 10 ) ; logger . info ( inetaddress . getbyname ( "localhost" ) ) ; logger . info ( "proxy is started" ) ; while ( true ) { socket client = null ; try { client = serversocket . accept ( ) ; logger . info ( "got new request" + client . getinetaddress ( ) . tostring ( ) ) ; executorservice . submit ( new cachethread ( client ) ) ; logger . info ( "complete request: " + client . getinetaddress ( ) . tostring ( ) ) ; } catch ( exception ex ) { logger . error ( ex . getmessage ( ) , ex ) ; client . close ( ) ; } } } catch ( exception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
tr	3	public void checkparamsset ( ) { if ( ! new file ( options . jenhome ) . exists ( ) ) { log . info ( "cannot find jen_home directory at {} - creating..." , options . jenhome ) ; try { log . debug ( "creating file ... " ) ; final file file = new file ( options . jenhome ) ; file . mkdir ( ) ; log . info ( "successfully created environment directory at {}" , options . jenenv ) ; } catch ( exception e ) { log . error ( "error: could not create file at {}<litcomma> exiting." , options . jenenv ) ; log . error ( "{}" , e ) ; system . exit ( - 1 ) ; } } if ( ! new file ( options . jenenv ) . exists ( ) ) { log . info ( "cannot find current environment directory at {} - creating..." , options . jenenv ) ; try { log . debug ( "creating file ... " ) ; final file file = new file ( options . jenenv ) ; file . mkdir ( ) ; log . info ( "successfully created environment directory at {}" , options . jenenv ) ; } catch ( exception e ) { log . error ( "error: could not create file at {}<litcomma> exiting." , options . jenenv ) ; log . error ( "{}" , e ) ; system . exit ( - 1 ) ; } } writeconfig ( new string [ ] { "default" } ) ; }
tr	10	public long thecount ( int [ ] answers ) { final int length = answers . length ; arrays . sort ( answers ) ; int i = 0 ; int count = 0 ; while ( i + 1 < length && answers [ i ] == count && answers [ i + 1 ] == count ) { count ++ ; i += 2 ; } final int countfirst = count ; while ( i < length && answers [ i ] == count ) { i ++ ; count ++ ; } if ( i != length ) return 0 ; long result = 1 << countfirst ; if ( countfirst != count ) result <<= 1 ; return result ; }
tr	6	public rtpstream [ ] parse ( pdml pdml ) { map < string , rtpstream > out = new linkedhashmap < string , rtpstream > ( ) ; for ( packet packet : pdml . packets ) { for ( protocol protocol : packet . protocols ) { if ( "rtp" . equals ( protocol . name ) ) { map < string , field > fields = protocol . asmap ( ) ; if ( fields . containskey ( "rtp.ssrc" ) ) { string ssrc = fields . get ( "rtp.ssrc" ) . value ; rtpstream stream = out . get ( ssrc ) ; if ( null == stream ) { stream = new rtpstream ( ssrc ) ; out . put ( ssrc , stream ) ; if ( fields . containskey ( "rtp.setup" ) ) { int setupframe = integer . parseint ( fields . get ( "rtp.setup" ) . asmap ( ) . get ( "rtp.setup-frame" ) . show ) ; stream . setsetuppacket ( pdml . packets [ setupframe - 1 ] ) ; } } stream . add ( new rtppacket ( fields ) ) ; } } } } return out . values ( ) . toarray ( new rtpstream [ out . size ( ) ] ) ; }
tr	7	public string toprintablestring ( ) { stringbuilder builder = new stringbuilder ( ) ; int maxnamelength = 0 ; for ( game game : rounds . get ( 0 ) ) maxnamelength = math . max ( math . max ( game . teams [ 0 ] . tostring ( ) . length ( ) , game . teams [ 1 ] . tostring ( ) . length ( ) ) , maxnamelength ) ; int columnwidth = maxnamelength + column_padding + column_prefix_margin + column_suffix_margin ; for ( int line = 0 ; line < print_height ; line ++ ) { for ( int round = 0 ; round < rounds . size ( ) ; round ++ ) { if ( round == 0 ) builder . append ( teamat ( line , round , columnwidth - column_prefix_margin ) ) ; else builder . append ( teamat ( line , round , columnwidth ) ) ; } builder . append ( "\\n" ) ; } return builder . tostring ( ) ; }
tr	5	public listenablefuture < searchresult > apply ( list < searchresult > results ) { stringbuilder keywords = new stringbuilder ( ) ; set < string > records = new hashset < string > ( ) ; long starttime = long . max_value ; long endtime = 0 ; for ( searchresult result : results ) { if ( result != null ) { keywords . append ( result . getkeyword ( ) ) ; records . addall ( result . getrecords ( ) ) ; starttime = math . min ( starttime , result . getstarttime ( ) ) ; endtime = math . max ( endtime , result . getendtime ( ) ) ; } } settablefuture < searchresult > constfuture = settablefuture . create ( ) ; constfuture . set ( new searchresult ( keywords . tostring ( ) , new arraylist < string > ( records ) , starttime , endtime ) ) ; return constfuture ; }
tr	8	private void getcoininternal ( int centsleft , arraylist < integer > path , arraylist < arraylist < integer > > res ) { if ( centsleft == 0 ) { arraylist < integer > newpath = new arraylist < integer > ( ) ; newpath . addall ( path ) ; res . add ( newpath ) ; return ; } if ( centsleft >= 25 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) == 25 ) ) { path . add ( 25 ) ; getcoininternal ( centsleft - 25 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 10 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 10 ) ) { path . add ( 10 ) ; getcoininternal ( centsleft - 10 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 5 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 5 ) ) { path . add ( 5 ) ; getcoininternal ( centsleft - 5 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 1 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 1 ) ) { path . add ( 1 ) ; getcoininternal ( centsleft - 1 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } return ; }
tr	9	private void solvetle ( int currentcolumn , int size , int [ ] [ ] board , arraylist < string [ ] > res ) { if ( currentcolumn == size ) { string [ ] solution = new string [ size ] ; string row = "" ; for ( int i = 0 ; i < size ; i ++ ) { row = "" ; for ( int j = 0 ; j < size ; j ++ ) { row += ( board [ i ] [ j ] > 0 ? string . valueof ( board [ i ] [ j ] ) : "." ) ; } solution [ i ] = row ; } res . add ( solution ) ; return ; } for ( int i = 0 ; i < size ; i ++ ) { if ( validplacetle ( currentcolumn , i , board ) ) { board [ i ] [ currentcolumn ] = 1 ; currentcolumn ++ ; solvetle ( currentcolumn , size , board , res ) ; currentcolumn -- ; board [ i ] [ currentcolumn ] = 0 ; } } }
tr	9	public static void main ( string [ ] arg ) { scanner sc = new scanner ( system . in ) ; int [ ] arr = { 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 } ; int max , min , t , pos , mitten ; min = 0 ; max = arr . length - 1 ; system . out . print ( "vilket heltal s\xf6ker du? " ) ; t = sc . nextint ( ) ; pos = - 1 ; while ( min <= max && pos == - 1 ) { mitten = ( max + min ) / 2 ; if ( t > arr [ mitten ] ) min = mitten + 1 ; else if ( t < arr [ mitten ] ) max = mitten - 1 ; else pos = mitten ; } if ( pos == - 1 ) system . out . println ( "talet hittades inte" ) ; else system . out . println ( "talet finns i element nummer " + pos ) ; }
tr	2	@ suppresswarnings ( "null" ) public static void main ( string [ ] args ) throws parseexception , corruptindexexception , ioexception { jsonarray jsearchobjectarray = new jsonarray ( ) ; jsonobject finaljsearchobject = new jsonobject ( ) ; standardanalyzer analyzer = new standardanalyzer ( version . lucene_40 ) ; string querystring = "crista lopes" ; stringtokenizer st = new stringtokenizer ( querystring ) ; string token = null ; int j = 1 ; booleanquery query = new booleanquery ( ) ; while ( st . hasmoretokens ( ) ) { token = st . nexttoken ( ) ; termquery titleterm = new termquery ( new term ( "title" , token ) ) ; titleterm . setboost ( 80.0f ) ; termquery contentsterm = new termquery ( new term ( "parseddata" , token ) ) ; contentsterm . setboost ( 190.0f ) ; termquery anchorterm = new termquery ( new term ( "anchortxt" , token ) ) ; anchorterm . setboost ( 25.0f ) ; termquery boldterm = new termquery ( new term ( "bold" , token ) ) ; boldterm . setboost ( 55.0f ) ; termquery strongterm = new termquery ( new term ( "strong" , token ) ) ; strongterm . setboost ( 60.0f ) ; termquery emterm = new termquery ( new term ( "em" , token ) ) ; emterm . setboost ( 65.0f ) ; query . add ( titleterm , occur . should ) ; query . add ( contentsterm , occur . should ) ; query . add ( anchorterm , occur . should ) ; query . add ( boldterm , occur . should ) ; query . add ( strongterm , occur . should ) ; query . add ( emterm , occur . should ) ; ++ j ; } int hitsperpage = 100 ; file indexdirectory = new file ( "c:\\\\ir_archieve\\\\index" ) ; indexreader reader = directoryreader . open ( fsdirectory . open ( indexdirectory ) ) ; indexsearcher searcher = new indexsearcher ( reader ) ; topscoredoccollector collector = topscoredoccollector . create ( hitsperpage , true ) ; searcher . search ( query , collector ) ; scoredoc [ ] hits = collector . topdocs ( ) . scoredocs ; system . out . println ( "found " + hits . length + " hits." ) ; for ( int i = 0 ; i < hits . length ; i ++ ) { jsonobject jsearchobject = new jsonobject ( ) ; int docid = hits [ i ] . doc ; document d = searcher . doc ( docid ) ; try { system . out . println ( ( i + 1 ) + ". " + "\\t" + d . get ( "filename" ) + "\\t" + d . get ( "title" ) + "\\t :: " + d . get ( "parseddata" ) . substring ( 100 , 150 ) ) ; } catch ( exception e ) { } jsearchobject . put ( "url" , d . get ( "filename" ) ) ; jsearchobject . put ( "title" , d . get ( "title" ) ) ; jsearchobject . put ( "anchor" , d . get ( "anchor" ) ) ; jsearchobject . put ( "contents" , d . get ( "contents" ) ) ; jsearchobjectarray . put ( i , jsearchobject ) ; } system . out . println ( jsearchobjectarray . length ( ) ) ; finaljsearchobject . put ( "results" , jsearchobjectarray ) ; system . out . println ( finaljsearchobject . get ( "results" ) ) ; }
tr	10	public static < t extends user > integer compareproperties ( t t1 , t t2 ) throws exception { for ( string name : t1 . fieldstocompare ( ) ) { logger . info ( "comparing property {} " , name ) ; object property1 = propertyutils . getproperty ( t1 , name ) ; object property2 = propertyutils . getproperty ( t2 , name ) ; if ( property1 == null && property2 == null ) { logger . info ( "both properties are null continue with next" ) ; continue ; } else if ( ( property1 == null && property2 != null ) || ( property2 == null && property1 != null ) ) { logger . info ( "difference in field {} " , name ) ; return integer . valueof ( - 1 ) ; } else if ( ! property1 . equals ( property2 ) ) { logger . info ( "difference in field {} " , name ) ; return integer . valueof ( - 1 ) ; } } return integer . valueof ( 0 ) ; }
tr	2	private double calculatescore ( team home , team away , hashtable < string , compiledstat > compiledstats ) { double basescore = ( 0.5 ) * ( 1.0 * home . getstat ( "ppg" ) + 1.0 * away . getstat ( "opp ppg" ) ) / 2.0 ; double score = basescore + randomabout ( basescore * variability ) ; double winbonus = ( 0.4 ) * ( home . getstat ( "win %" ) ) ; score += winbonus + randomabout ( winbonus * variability ) ; double scoringmarginmargin = away . getstat ( "scr mar" ) - home . getstat ( "scr mar" ) ; double scoringmarginpoints = 0.7 * scoringmarginmargin + randomabout ( scoringmarginmargin * variability ) ; score -= scoringmarginpoints ; double turnoverpoints = 0.4 * ( home . getstat ( "topg" ) + away . getstat ( "stpg" ) ) ; score -= turnoverpoints * randomabout ( turnoverpoints * variability ) ; double pfpoints = 1.5 * home . getstat ( "ft%" ) * 0.01 * away . getstat ( "pfpg" ) ; score += pfpoints + randomabout ( pfpoints * variability ) ; double rebounddiff = home . getstat ( "rpg" ) - away . getstat ( "rpg" ) ; score += 1 * rebounddiff + randomabout ( rebounddiff * variability ) ; double opponentblocks = 1 * away . getstat ( "bkpg" ) ; score -= opponentblocks + randomabout ( opponentblocks * variability ) ; return score ; }
tr	1	public testgraphics ( ) { super ( "pert chart" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; tasklist = new listoftasks ( ) ; jpanel mainpanel = new jpanel ( ) ; mainpanel . setlayout ( new borderlayout ( ) ) ; getcontentpane ( ) . add ( mainpanel ) ; jpanel graphicspanel = new jpanel ( ) ; gwindow window = new gwindow ( ) ; mainpanel . add ( window . getcanvas ( ) , borderlayout . center ) ; scene = new gscene ( window , "scene" ) ; double w0 [ ] = { 0.0 , 1500.0 , 0.0 } ; double w1 [ ] = { 1500.0 , 1500.0 , 0.0 } ; double w2 [ ] = { 0.0 , 0.0 , 0.0 } ; scene . setworldextent ( w0 , w1 , w2 ) ; scene . shouldzoomonresize ( false ) ; gstyle style = new gstyle ( ) ; style . setforegroundcolor ( color . blue ) ; style . setbackgroundcolor ( new color ( 255 , 255 , 255 ) ) ; style . setfont ( new font ( "dialog" , font . bold , 10 ) ) ; scene . setstyle ( style ) ; textinput input = new textinput ( ) ; while ( input . getfinished ( ) == false ) { input . inputtasknum ( ) ; input . inputparentnum ( ) ; input . inputfinished ( ) ; task parenttask = null ; int parentcounter = 0 ; double xposition = 300 ; for ( task task : tasklist . gettasklist ( ) ) { if ( task . gettasknumber ( ) == input . getparentnum ( ) ) { parenttask = task ; } if ( task . getparent ( ) == parenttask ) { parentcounter ++ ; } } double yposition = 500 + parentcounter * 300 ; tasklist . addtask ( new task ( "name" , input . gettasknum ( ) , 2 , "startdate" , "enddate" , scene , parenttask , xposition , yposition ) ) ; } pack ( ) ; setsize ( new dimension ( 500 , 500 ) ) ; setvisible ( true ) ; }
tr	5	@ requestmapping ( applicationconstants . post_chat ) @ responsebody public object postmessage ( @ requestparam ( "message" ) string message , @ requestparam ( "chatroomid" ) string chatroomid ) { map < object , string > errormap = new hashmap < object , string > ( ) ; if ( message == null || "" . equals ( message ) ) { errormap . put ( 1 , "please enter message" ) ; } if ( chatroomid == null || "" . equals ( chatroomid ) ) { errormap . put ( 2 , "please enter chatroomid" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { message messagetosave = new message ( ) ; messagetosave . setmessage ( message ) ; chatroom chatroom = chatroomdao . getchatroom ( integer . parseint ( chatroomid ) ) ; if ( chatroom == null ) { errormap . put ( 3 , "chatroom does not exist" ) ; return errormap ; } messagetosave . setchatroom ( chatroom ) ; messagetosave . setcreateddate ( new date ( ) . tostring ( ) ) ; messagedao . postmessage ( messagetosave ) ; return messagetosave ; } }
tr	5	public static string getpath ( string header ) { string uri = extractfromheader ( header , "get " , " " ) , path ; if ( uri == null ) uri = extractfromheader ( header , "post " , " " ) ; if ( uri == null ) return null ; path = uri . tolowercase ( ) ; if ( path . length ( ) >= 7 && path . indexof ( "http://" , 0 ) == 0 ) uri = uri . substring ( 7 ) ; else { path = extractfromheader ( header , "host:" , "\\n" ) ; if ( path == null ) return null ; uri = path + uri ; } uri = transform . fixurl ( uri ) ; uri = transform . url2file ( uri , ( byte ) 0 ) ; path = cache_path + file . separator + uri ; return path ; }
tr	9	private static int parsetime ( string timestring ) { string [ ] parts = timestring . split ( ":" ) ; if ( parts . length != 2 ) return - 1 ; int time = 0 ; try { time = integer . parseint ( parts [ 0 ] . trim ( ) ) * 10000 ; if ( time < 0 || time > 24000 ) return - 1 ; } catch ( exception e ) { return - 1 ; } try { int seconds = integer . parseint ( parts [ 0 ] . trim ( ) ) ; if ( seconds < 0 || seconds > 59 ) return - 1 ; time += seconds * 1000 / 60 ; } catch ( exception e ) { return - 1 ; } return time ; }
tr	8	static string [ ] getoperands ( ) { scanner scanner = new scanner ( system . in ) ; int size ; system . out . println ( "enter the number of elements!" ) ; size = scanner . nextint ( ) ; if ( 0 >= size ) { throw new runtimeexception ( "invalid size: " + size ) ; } int index = 0 ; string operands [ ] = new string [ size ] ; while ( index < size ) { string operand = scanner . next ( ) ; if ( operand . length ( ) != 1 ) { throw new runtimeexception ( "operand should be a single digit!" ) ; } for ( character ch : operand . tochararray ( ) ) { if ( ! character . isdigit ( ch ) ) { throw new runtimeexception ( "illegal code point: " + ch ) ; } } operands [ index ++ ] = operand ; } return operands ; }
tr	10	private static void floodfill ( int x , int y , color targetcolor , color replacementcolor , bufferedimage image ) { list < point > queue = new linkedlist < point > ( ) ; point w , e ; queue . add ( new point ( x , y ) ) ; do { point p = queue . remove ( queue . size ( ) - 1 ) ; if ( image . getrgb ( ( int ) p . getx ( ) , ( int ) p . gety ( ) ) == targetcolor . getrgb ( ) ) { w = ( point ) p . clone ( ) ; e = ( point ) p . clone ( ) ; while ( w . getx ( ) - 1 >= 0 ) if ( image . getrgb ( ( int ) w . getx ( ) - 1 , ( int ) w . gety ( ) ) == targetcolor . getrgb ( ) ) { w = new point ( ( int ) w . getx ( ) - 1 , ( int ) w . gety ( ) ) ; } else { break ; } while ( e . getx ( ) + 1 < image . getwidth ( ) ) if ( image . getrgb ( ( int ) e . getx ( ) + 1 , ( int ) e . gety ( ) ) == targetcolor . getrgb ( ) ) { e = new point ( ( int ) e . getx ( ) + 1 , ( int ) e . gety ( ) ) ; } else { break ; } for ( int i = ( int ) w . getx ( ) ; i <= e . getx ( ) ; i ++ ) image . setrgb ( i , ( int ) w . gety ( ) , replacementcolor . getrgb ( ) ) ; for ( int i = ( int ) w . getx ( ) ; i <= e . getx ( ) ; i ++ ) { if ( w . gety ( ) - 1 >= 0 ) if ( image . getrgb ( i , ( int ) w . gety ( ) - 1 ) == targetcolor . getrgb ( ) ) queue . add ( new point ( i , ( int ) w . gety ( ) - 1 ) ) ; if ( w . gety ( ) + 1 < image . getheight ( ) ) if ( image . getrgb ( i , ( int ) w . gety ( ) + 1 ) == targetcolor . getrgb ( ) ) queue . add ( new point ( i , ( int ) w . gety ( ) + 1 ) ) ; } } } while ( ! queue . isempty ( ) ) ; }
tr	9	final public void run ( ) { int ticks ; if ( immediate_shutdownflag == null || flag_check_interval <= 0 ) flag_check_interval = ( int ) ( savetimer ) ; ticks = ( int ) ( savetimer / flag_check_interval ) ; if ( ticks == 0 ) ticks = 1 ; flag_check_interval = ( int ) ( savetimer / ticks ) ; int i = 0 ; thread . currentthread ( ) . setname ( "background .cacheinfo saver" ) ; while ( true ) { try { thread . sleep ( flag_check_interval ) ; } catch ( interruptedexception e ) { system . out . println ( "[smartcache] background saver interrupted<litcomma> exiting." ) ; save ( ) ; save ( ) ; httpreq . flush ( httpreq . logfilez ) ; break ; } i ++ ; if ( i >= ticks ) { save ( ) ; i = 0 ; touch_flag ( aliveflag ) ; } if ( checkflag ( immediate_shutdownflag , clear_flags_on_shutdown ) ) { synchronized ( mgr . class ) { checkflag ( aliveflag , true ) ; for ( cachedir d : dircache . values ( ) ) { d . save ( ) ; d . cleandir ( ) ; } httpreq . flush ( httpreq . logfilez ) ; system . out . println ( new date ( ) + " server stopped by immediate shutdown flag." ) ; system . exit ( 0 ) ; } } if ( pass_filename != null ) { if ( new file ( pass_filename ) . lastmodified ( ) != pass_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading pass_file " + pass_filename ) ; pass = parseregexpfile ( pass_filename , null ) ; pass_timestamp = new file ( pass_filename ) . lastmodified ( ) ; } } if ( fail_filename != null ) { if ( new file ( fail_filename ) . lastmodified ( ) != fail_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading fail_file " + fail_filename ) ; fail = parseregexpfile ( fail_filename , null ) ; fail_timestamp = new file ( fail_filename ) . lastmodified ( ) ; } } if ( regex_fail_filename != null ) { if ( new file ( regex_fail_filename ) . lastmodified ( ) != regex_fail_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading regex_fail_file " + regex_fail_filename ) ; regex_fail = parserealregexpfile ( regex_fail_filename , null ) ; regex_fail_timestamp = new file ( regex_fail_filename ) . lastmodified ( ) ; } } if ( cookie_filename != null ) { if ( new file ( cookie_filename ) . lastmodified ( ) != cookie_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading allow_cookies_to_file " + cookie_filename ) ; allow_cookies_to = parsecookiefile ( cookie_filename ) ; cookie_timestamp = new file ( cookie_filename ) . lastmodified ( ) ; } } if ( redir_filename != null ) { if ( new file ( redir_filename ) . lastmodified ( ) != redir_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading redirect_file " + redir_filename ) ; parseredirfile ( redir_filename , true ) ; redir_timestamp = new file ( redir_filename ) . lastmodified ( ) ; } } if ( remap_filename != null ) { if ( new file ( remap_filename ) . lastmodified ( ) != remap_timestamp ) { if ( loglevel > 2 ) system . out . println ( new date ( ) + " reloading remap_file " + remap_filename ) ; parseredirfile ( remap_filename , false ) ; remap_timestamp = new file ( remap_filename ) . lastmodified ( ) ; } } } }
tr	4	public void ispisistatistiku ( ) { resource r ; system . out . println ( "--------------statistika--------------" ) ; system . out . println ( m . getnazivspremista ( ) ) ; for ( int i = 0 ; i < cac . getlista ( ) . size ( ) ; i ++ ) { r = ( resource ) cac . getlista ( ) . get ( i ) ; if ( r . isspremljen ( ) ) { if ( m . getwebstranica ( ) . getnaziv ( ) . equals ( r . getnaziv ( ) ) ) { system . out . println ( ( i + 1 ) + ". " + r . getnaziv ( ) + "   " + r . getbrojkoristenja ( ) + "   " + "koristi se" ) ; } else { system . out . println ( ( i + 1 ) + ". " + r . getnaziv ( ) + "   " + r . getbrojkoristenja ( ) + "   " + r . getzadnjekoistenje ( ) ) ; } } } system . out . println ( "--------------------------------------" ) ; }
tr	4	public void writeall ( java . sql . resultset rs , boolean includecolumnnames ) throws sqlexception , ioexception { resultsetmetadata metadata = rs . getmetadata ( ) ; if ( includecolumnnames ) { writecolumnnames ( metadata ) ; } int columncount = metadata . getcolumncount ( ) ; while ( rs . next ( ) ) { string [ ] nextline = new string [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { nextline [ i ] = getcolumnvalue ( rs , metadata . getcolumntype ( i + 1 ) , i + 1 ) ; } writenext ( nextline ) ; } }
tr	10	private void findminimaldistances ( vertex node ) { list < vertex > adjacentnodes = getneighbors ( node ) ; vertex lasttarget = null ; for ( vertex target : adjacentnodes ) { system . out . println ( "target.tostring() " + target . tostring ( ) ) ; if ( getshortestdistance ( target ) > getshortestdistance ( node ) + getdistance ( node , target ) ) { distance . put ( target , getshortestdistance ( node ) + getdistance ( node , target ) ) ; predecessors . put ( target , node ) ; unsettlednodes . add ( target ) ; } for ( int i = 0 ; i < ds . notoknumber . length - 1 ; i ++ ) { if ( predecessors . get ( target ) != null ) { if ( ds . notoknumber [ i + 1 ] == integer . parseint ( predecessors . get ( target ) . getid ( ) ) && ds . notoknumber [ i ] == integer . parseint ( target . getid ( ) ) ) { predecessors . remove ( target ) ; predecessors . remove ( lasttarget ) ; distance . remove ( target ) ; distance . remove ( lasttarget ) ; } } } lasttarget = target ; } }
tr	3	@ suppresswarnings ( "unchecked" ) public generadordto ( ) { super ( ) ; prefijosentidadesnegocio = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . prefijo_entida ) ; listanegraatributos = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . list_negra_atr ) ; paqueteentidades = ( string ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . paquete_origen ) ; paquetecodigogenerado = ( string ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . paquete_destin ) ; }
tr	9	public void update ( int delta ) { float d = .01f * delta ; if ( turnright ) rotation += rotatespd * .01f * delta ; if ( turnleft ) rotation -= rotatespd * .01f * delta ; if ( ! checkborders ( ) && accelerate ) { acceleration [ 0 ] = ( float ) helper . cos ( rotation ) * speed ; acceleration [ 1 ] = ( float ) helper . sin ( rotation ) * speed ; velocity [ 0 ] += acceleration [ 0 ] * delta * .01f ; velocity [ 1 ] += acceleration [ 1 ] * delta * .01f ; } for ( int i = 0 ; i < 2 ; i ++ ) { location [ i ] += velocity [ i ] * delta * .01f ; if ( stop ) { velocity [ i ] -= velocity [ i ] / 10 * d ; } } }
tr	9	void maxslidingwindow ( int a [ ] , int n , int w , int b [ ] ) { linkedlist < integer > q = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < w ; i ++ ) { while ( ! q . isempty ( ) && a [ i ] >= a [ q . getlast ( ) ] ) q . removelast ( ) ; q . addlast ( i ) ; } for ( int i = w ; i < n ; i ++ ) { b [ i - w ] = a [ q . getfirst ( ) ] ; while ( ! q . isempty ( ) && a [ i ] >= a [ q . getlast ( ) ] ) q . removelast ( ) ; while ( ! q . isempty ( ) && q . getfirst ( ) <= i - w ) q . removefirst ( ) ; q . addlast ( i ) ; } b [ n - w ] = a [ q . getfirst ( ) ] ; }
tr	2	private void escrevejson ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { object obj = localizaobjetoaserenviado ( request ) ; if ( obj == null ) { response . senderror ( 404 ) ; } else { try { response . setcontenttype ( "application/json;charset=utf-8" ) ; mappednamespaceconvention con = new mappednamespaceconvention ( ) ; xmlstreamwriter xmlstreamwriter = new mappedxmlstreamwriter ( con , response . getwriter ( ) ) ; marshaller marshaller = context . createmarshaller ( ) ; marshaller . marshal ( obj , xmlstreamwriter ) ; } catch ( jaxbexception e ) { response . senderror ( 500 , e . getmessage ( ) ) ; } } }
tr	10	public int compare ( map < string , string > amap1 , map < string , string > amap2 ) { if ( amap1 . size ( ) != amap2 . size ( ) ) return - 1 ; for ( string thekey : amap1 . keyset ( ) ) { string thevalue1 = amap1 . get ( thekey ) ; string thevalue2 = amap2 . get ( thekey ) ; boolean theempty1 = thevalue1 == null || thevalue1 . length ( ) == 0 ; boolean theempty2 = thevalue2 == null || thevalue2 . length ( ) == 0 ; if ( theempty1 && theempty2 ) continue ; if ( theempty1 || theempty2 ) return - 1 ; if ( ! thevalue1 . equals ( thevalue2 ) ) return - 1 ; } return 0 ; }
tr	8	public void recovertree ( treenode root ) { stack < treenode > a = new stack < treenode > ( ) ; treenode p = root ; treenode lastnode = null , first = null , second = null ; while ( ! a . isempty ( ) || p != null ) { if ( p == null ) { p = a . pop ( ) ; if ( lastnode != null && p . val < lastnode . val ) { if ( first == null ) { first = lastnode ; second = p ; } else second = p ; } lastnode = p ; p = p . right ; } else { a . add ( p ) ; p = p . left ; } } int t = first . val ; first . val = second . val ; second . val = t ; }
tr	2	public move getmove ( ) { move r ; boardposition a ; boardposition b ; scanner sc = new scanner ( system . in ) ; int row ; string collumn ; system . out . print ( "enter the row of the position of the piece you would like to move: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position of the piece you would like to move: " ) ; collumn = sc . next ( ) ; a = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; system . out . print ( "enter the row of the position you would like to move this piece to: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position you would like to move this piece to: " ) ; collumn = sc . next ( ) ; b = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; r = new move ( a , b , gamestatus . continue ) ; return r ; }
tr	6	public static void main ( string [ ] args ) throws exception { int maxnorm = integer . parseint ( args [ 0 ] ) ; maxnorm *= maxnorm ; for ( gaussian e = new gaussian ( 3 , 0 ) ; e . norm2 ( ) < maxnorm ; e = e . inc ( ) ) hopp : { gaussian f = e ; for ( gaussian z : primes ) { if ( f . mod ( z ) . equals ( gaussian . zero ) && f . norm2 ( ) > z . norm2 ( ) ) { system . err . printf ( "%s\\t=\\t%s\\tx\\t%s\\n" , f . tostring ( ) , z . tostring ( ) , f . div ( z ) . tostring ( ) ) ; break hopp ; } } system . err . printf ( "%s\\n" , f . tostring ( ) ) ; primes . add ( e ) ; primes . add ( e . mul ( gaussian . unit ) ) ; primes . add ( e . neg ( ) ) ; primes . add ( e . neg ( ) . mul ( gaussian . unit ) ) ; } system . err . println ( primes ) ; printprimes ( primes ) ; }
tr	10	private static void emit ( stringbuffer buf , string [ ] keys , hashmap values , long code ) { buf . append ( ':' ) ; boolean emitted = false ; long allvalues = 0 ; for ( int i = 0 ; i < keys . length ; i ++ ) { final string key = keys [ i ] ; long bitmask = ( ( long ) values . get ( key ) ) . longvalue ( ) ; allvalues |= bitmask ; if ( ( code & bitmask ) == bitmask ) { if ( emitted ) { buf . append ( '.' ) ; } else { emitted = true ; } buf . append ( key ) ; } } if ( ! emitted ) { buf . deletecharat ( buf . length ( ) - 1 ) ; } else { if ( emit_underscore && allvalues == code ) { buf . delete ( buf . lastindexof ( ":" ) + 1 , integer . max_value ) ; buf . append ( "_" ) ; } } }
tr	6	public void run ( ) { pruebathreads . sett ( pruebathreads . gett ( ) + 1 ) ; while ( cont >= 0 ) { string s = pruebathreads . getclase ( ) ; if ( s == null ) { system . out . println ( this . id + " - " + cont + " sin ultima lectura" ) ; } else { system . out . println ( this . id + " - " + cont + " ultima escritura " + s ) ; } pruebathreads . setclase ( id ) ; if ( cont == 0 ) { int r = pruebathreads . gett ( ) ; pruebathreads . sett ( r - 1 ) ; system . out . println ( "ultima escritura " + pruebathreads . getclase ( ) + " - " + ( r - 1 ) + " threads activos" ) ; } else { delaysegundo ( ) ; } cont -- ; } }
tr	7	public string mahdollisetyhdistelmattostring ( ) { string s = "" ; arraylist < yhdistelma > y = mahdollisetyhdistelmat ( ) ; int ind = y . size ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; if ( i == y . size ( ) - 1 ) { s = s + "---------------------yliviivaa---------------------" + "\\n" ; } } y = yliviivattavat ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( ind + i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; } return s ; }
tr	10	public void update ( gamecontainer gc , statebasedgame sbg , int delta ) throws slickexception { int xpos = mouse . getx ( ) ; int ypos = mouse . gety ( ) ; if ( ! musicstarted ) { backgroundmusic . playasmusic ( .5f , 1f , true ) ; musicstarted = true ; } mousestring = "(" + xpos + "<litcomma> " + ypos + ")" ; input input = gc . getinput ( ) ; if ( xpos > 650 && xpos < 950 && ypos < 620 && ypos > 560 ) { hoveringstart = true ; if ( input . ismousebuttondown ( 0 ) ) { hoveringstart = false ; if ( ! startbuttonsound ) startbutton . playassoundeffect ( 1f , 1f , false ) ; startfading = true ; startbuttonsound = true ; } } else hoveringstart = false ; if ( fadein ) { alpha -= .001 ; } if ( alpha <= 0 ) { fadein = false ; } if ( startfading ) { alpha += .0005 ; titlerot += 1 ; fadein = false ; } if ( alpha >= 1 ) { startbuttonsound = false ; startfading = false ; fadein = true ; titlerot = 0 ; backgroundmusic . stop ( ) ; musicstarted = false ; sbg . enterstate ( 2 ) ; } }
tr	10	public vector < inetsocketaddress > getservers ( byte regioncode , string filter , boolean force , masterserverlistener listener ) throws steamcondenserexception , timeoutexception { int failcount = 0 ; boolean finished = false ; int portnumber = 0 ; string hostname = "0.0.0.0" ; vector < string > serverstringarray ; vector < inetsocketaddress > serverarray = new vector < inetsocketaddress > ( ) ; while ( true ) { try { failcount = 0 ; do { this . socket . send ( new a2m_get_servers_batch2_paket ( regioncode , hostname + ":" + portnumber , filter ) ) ; try { serverstringarray = ( ( m2a_server_batch_paket ) this . socket . getreply ( ) ) . getservers ( ) ; for ( string serverstring : serverstringarray ) { hostname = serverstring . substring ( 0 , serverstring . lastindexof ( ':' ) ) ; portnumber = integer . valueof ( serverstring . substring ( serverstring . lastindexof ( ':' ) + 1 ) ) ; if ( ! hostname . equals ( "0.0.0.0" ) && portnumber != 0 ) { inetsocketaddress inets = new inetsocketaddress ( hostname , portnumber ) ; serverarray . add ( inets ) ; if ( listener != null ) { listener . serverfound ( inets ) ; } } else { finished = true ; } } failcount = 0 ; } catch ( timeoutexception e ) { failcount ++ ; if ( failcount == retries ) { throw e ; } logger . getlogger ( "com.github.koraktor.steamcondenser" ) . log ( level . info , "request to master server {0} timed out<litcomma> retrying..." , this . ipaddress ) ; } } while ( ! finished ) ; break ; } catch ( timeoutexception e ) { if ( force ) { break ; } else if ( this . rotateip ( ) ) { throw e ; } logger . getlogger ( "com.github.koraktor.steamcondenser" ) . log ( level . info , "request to master server failed<litcomma> retrying {0}..." , this . ipaddress ) ; } } return serverarray ; }
tr	6	public static void parallel ( final int numthreads , final block block ) { final thread [ ] threads = new thread [ numthreads ] ; final throwable [ ] failure = { null } ; for ( int i = 0 ; i < threads . length ; ++ i ) { final int index = i ; threads [ i ] = new thread ( "worker #" + i ) { @ override public void run ( ) { try { block . call ( index ) ; } catch ( final throwable xx ) { failure [ 0 ] = xx ; } } } ; } for ( thread t : threads ) { t . start ( ) ; } for ( thread t : threads ) { try { t . join ( ) ; } catch ( final interruptedexception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } } if ( failure [ 0 ] instanceof runtimeexception ) { throw ( runtimeexception ) failure [ 0 ] ; } else if ( failure [ 0 ] instanceof error ) { throw ( error ) failure [ 0 ] ; } else { assert ( failure [ 0 ] == null ) ; } }
tr	10	private void rescalediameters ( double [ ] realdiameters , int iteration ) { if ( iteration > 5 ) { return ; } else if ( iteration == 0 ) { double averagediameter = 0 ; for ( int j = 0 ; j < ncircles ; j ++ ) averagediameter += realdiameters [ j ] ; averagediameter /= ncircles ; for ( int j = 0 ; j < ncircles ; j ++ ) diameters [ j ] = averagediameter ; } else if ( iteration < 5 ) { for ( int j = 0 ; j < ncircles ; j ++ ) diameters [ j ] = diameters [ j ] - ( iteration / 5.0 ) * ( diameters [ j ] - realdiameters [ j ] ) ; } else { for ( int j = 0 ; j < ncircles ; j ++ ) diameters [ j ] = realdiameters [ j ] ; } }
tr	10	protected void checkstraightflush ( list < card > cards ) { int [ ] anycard = new int [ 14 ] ; for ( int i = 0 ; i < 14 ; i ++ ) { anycard [ i ] = - 1 ; } for ( int i = 0 ; i < cards . size ( ) ; i ++ ) { int it = cards . get ( i ) . getcardvalue ( ) ; anycard [ it + 1 ] = i ; } anycard [ 0 ] = anycard [ 13 ] ; int cnt = 0 ; for ( int i = 0 ; i < 14 - 5 ; i ++ ) { int tmp_spades = 0 ; int lastcardspades = 0 ; int tmp_hearts = 0 ; int lastcardhearts = 0 ; int tmp_diamonds = 0 ; int lastcarddiamonds = 0 ; int tmp_clubs = 0 ; int lastcardclubs = 0 ; for ( int j = i ; j < i + 5 ; j ++ ) { if ( anycard [ j ] != - 1 ) { for ( int k = 0 ; k < cards . size ( ) ; k ++ ) { if ( cards . get ( anycard [ j ] ) . getcardvalue ( ) == cards . get ( k ) . getcardvalue ( ) ) { switch ( cards . get ( k ) . getcolor ( ) ) { case 's' : tmp_spades ++ ; lastcardspades = j ; break ; case 'h' : tmp_hearts ++ ; lastcardhearts = j ; break ; case 'd' : tmp_diamonds ++ ; lastcarddiamonds = j ; break ; case 'c' : tmp_clubs ++ ; lastcardclubs = j ; break ; } } } } } if ( math . max ( math . max ( math . max ( tmp_spades , tmp_hearts ) , tmp_diamonds ) , tmp_clubs ) == tmp_spades && tmp_spades > cnt ) { missingcards [ 0 ] = 5 - tmp_spades ; bestcard [ 0 ] = cards . get ( anycard [ lastcardspades ] ) ; cnt = tmp_spades ; } if ( math . max ( math . max ( math . max ( tmp_spades , tmp_hearts ) , tmp_diamonds ) , tmp_clubs ) == tmp_hearts && tmp_hearts > cnt ) { missingcards [ 0 ] = 5 - tmp_hearts ; bestcard [ 0 ] = cards . get ( anycard [ lastcardhearts ] ) ; cnt = tmp_hearts ; } if ( math . max ( math . max ( math . max ( tmp_spades , tmp_hearts ) , tmp_diamonds ) , tmp_clubs ) == tmp_diamonds && tmp_diamonds > cnt ) { missingcards [ 0 ] = 5 - tmp_diamonds ; bestcard [ 0 ] = cards . get ( anycard [ lastcarddiamonds ] ) ; cnt = tmp_diamonds ; } if ( math . max ( math . max ( math . max ( tmp_spades , tmp_hearts ) , tmp_diamonds ) , tmp_clubs ) == tmp_clubs && tmp_clubs > cnt ) { missingcards [ 0 ] = 5 - tmp_clubs ; bestcard [ 0 ] = cards . get ( anycard [ lastcardclubs ] ) ; cnt = tmp_clubs ; } } if ( cnt == 0 ) { missingcards [ 0 ] = 5 ; bestcard [ 0 ] = cards . get ( cards . size ( ) - 1 ) ; } }
tr	8	public arraylist < integer > findsubstring ( string s , string [ ] l ) { arraylist < integer > res = new arraylist < integer > ( ) ; arraylist < string > source = new arraylist < string > ( ) ; boolean [ ] bused = new boolean [ l . length ] ; int count = 0 ; int size = l [ 0 ] . length ( ) ; for ( int i = 0 ; i < s . length ( ) - size ; i = i + size ) { source . add ( s . substring ( i , i + size ) ) ; } for ( int i = 0 ; i < source . size ( ) ; i ++ ) { for ( int j = 0 ; j < l . length ; j ++ ) { if ( source . get ( i ) . equals ( l [ j ] ) ) { if ( bused [ j ] == false ) { count ++ ; bused [ j ] = true ; if ( count == l . length ) { res . add ( ( i - l . length + 1 ) * size ) ; count = 0 ; arrays . fill ( bused , false ) ; } } else { count = 0 ; arrays . fill ( bused , false ) ; } } } } return res ; }
tr	5	public static void main ( final string [ ] args ) { final string progname = "normalise" ; final normalisecli cli = new normalisecli ( ) ; final jcommander jc = new jcommander ( cli ) ; jc . setprogramname ( progname ) ; try { jc . parse ( args ) ; } catch ( parameterexception e ) { system . out . println ( progname + ": " + e . getmessage ( ) ) ; system . out . println ( ) ; jc . usage ( ) ; system . exit ( 1 ) ; } if ( cli . ishelp ( ) ) { jc . usage ( ) ; return ; } list < string > files = cli . getparameters ( ) ; if ( files . size ( ) != 1 ) { jc . usage ( ) ; system . exit ( 1 ) ; } normalise norm = new normalise ( new file ( files . get ( 0 ) ) , cli ) ; norm . run ( ) ; }
tr	9	public static void sort ( string [ ] a , int start , int end , int pos ) { system . out . println ( "-------------------start----------------------" ) ; system . out . println ( "start=" + start ) ; system . out . println ( "end=" + end ) ; printarray ( a , start , end ) ; if ( start >= end ) return ; int ch = charat ( a [ start ] , pos ) ; int l = start ; int r = end ; int i = l + 1 ; system . out . println ( "i=" + i ) ; system . out . println ( "r=" + r ) ; while ( i <= r ) { int v = charat ( a [ i ] , pos ) ; system . out . println ( "ch=" + ch ) ; system . out . println ( "v=" + v ) ; if ( v < ch ) { exch ( a , i ++ , l ++ ) ; } else if ( v > ch ) { exch ( a , i , r -- ) ; } else { i ++ ; } } system . out . println ( "-------------------finish----------------------" ) ; sort ( a , start , l - 1 , pos ) ; if ( ch > 0 ) sort ( a , l , r , pos + 1 ) ; sort ( a , r + 1 , end , pos ) ; }
tr	3	public void actionperformed ( actionevent e ) { if ( e . getsource ( ) . equals ( okbutton ) ) { string directory = log_path . gettext ( ) ; string logfile = log_name . gettext ( ) ; string linenumstr = line_num . gettext ( ) ; if ( directory . equals ( "" ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u6307\u5b9a\u670d\u52a1\u5668\u76ee\u5f55" , "\u63d0\u793a" , 2 ) ; return ; } if ( logfile . equals ( "" ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u6307\u5b9a\u65e5\u5fd7\u6587\u4ef6" , "\u63d0\u793a" , 2 ) ; return ; } if ( linenumstr . equals ( "" ) || ! utils . isnumeric ( linenumstr ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u8f93\u5165\u622a\u53d6\u884c\u6570(\u6570\u5b57)" , "\u63d0\u793a" , 2 ) ; return ; } int linenum = integer . parseint ( linenumstr ) ; new thread ( new logviewthread ( directory , logfile , linenum ) ) . start ( ) ; } }
tr	4	public void serijaliziraj ( ) { webstranica . setzadnjekoistenje ( new date ( ) ) ; try { for ( int i = 0 ; i < c . getlista ( ) . size ( ) ; i ++ ) { ( ( resource ) c . getlista ( ) . get ( i ) ) . setsadrzaj ( null ) ; } fileoutputstream fileout = new fileoutputstream ( nazivspremista + "\\\\serijalizacija.ser" ) ; objectoutputstream out = new objectoutputstream ( fileout ) ; out . writeobject ( c . getlista ( ) ) ; out . close ( ) ; fileout . close ( ) ; } catch ( ioexception i ) { i . printstacktrace ( ) ; } system . exit ( 1 ) ; }
tr	10	public static void main ( string [ ] args ) { string webproject = system . getproperty ( "user.dir" ) ; list < string > classpath = new arraylist < > ( arrays . aslist ( system . getproperty ( "java.class.path" ) . split ( ":" ) ) ) ; string tmppath = classpath . get ( 0 ) ; if ( tmppath . endswith ( "/target/classes" ) ) { tmppath = tmppath . substring ( 0 , tmppath . length ( ) - "classes" . length ( ) ) + "test-classes" ; classpath . add ( 0 , tmppath ) ; webproject = tmppath . substring ( 0 , tmppath . length ( ) - "/target/classes" . length ( ) ) ; } stringbuilder buf = new stringbuilder ( 8192 ) ; nextpath : for ( string path : new linkedhashset < > ( classpath ) ) { int pos = path . lastindexof ( '/' ) ; if ( pos == - 1 ) pos = 0 ; for ( string key : classpathignorekeys ) { if ( path . indexof ( key , pos ) != - 1 ) continue nextpath ; } buf . append ( ';' ) . append ( path ) ; } printstream out = system . out ; final string webclasspath = buf . substring ( 1 ) ; out . println ( "\u9879\u76ee classpath:" + webclasspath ) ; file webapp = new file ( "src/main/webapp" ) ; if ( ! webapp . exists ( ) ) { webapp = new file ( webproject , "src/main/webapp" ) ; } else { webproject = webapp . getabsolutefile ( ) . getparentfile ( ) . getparentfile ( ) . getparentfile ( ) . getabsolutepath ( ) ; } string basename = new file ( webproject ) . getname ( ) ; if ( ! basename . equalsignorecase ( "web" ) && basename . tolowercase ( ) . endswith ( "web" ) && ! character . isletterordigit ( basename . charat ( basename . length ( ) - "web" . length ( ) - 1 ) ) ) { basename = basename . substring ( 0 , basename . length ( ) - "web" . length ( ) - 1 ) ; } out . println ( ) ; out . println ( "\u9879\u76ee tomcat\u914d\u7f6e\u6587\u4ef6" ) ; out . println ( "$catalina_base/conf/catalina/localhost/" + basename + ".xml\\n" ) ; out . println ( "<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\n" + "<context docbase=\\"" + webapp . getabsolutepath ( ) + "\\" allowlinking=\\"true\\">\\n" + "\t<loader classname=\\"org.apache.catalina.loader.virtualwebapploader\\" virtualclasspath=\\"" + webclasspath + "\\"/>\\n" + "\t<jarscanner scanalldirectories=\\"true\\" />\\n" + "\t<resource name=\\"jdbc/mysql\\" auth=\\"container\\" type=\\"javax.sql.datasource\\"\\n" + "\t\tmaxactive=\\"4\\" minidle=\\"2\\" maxwait=\\"3000\\"\\n" + "\t\ttimebetweenevictionrunsmillis=\\"14000\\"\\n" + "\t\tminevictableidletimemillis=\\"28000\\"\\n" + "\t\tusername=\\"dev\\" password=\\"dev\\" driverclassname=\\"com.mysql.jdbc.driver\\"\\n" + "\t\turl=\\"jdbc:mysql://host:3306/dev?useunicode=true&amp;characterencoding=utf8\\"/>\\n" + "</context>\\n" ) ; }
tr	4	public optimizesubset ( final intset set , final int k , final subsetfitnessfunction convergencecriterion , final int populationsize , final string ... params ) throws invalidconfigurationexception { this . numparams = params . length ; parseparameterdefinitions ( params ) ; this . set = set ; this . k = k ; int i = 0 ; this . allelements = new int [ set . size ( ) ] ; for ( final int element : set ) { allelements [ i ++ ] = element ; } this . convergencecriterion = convergencecriterion ; this . k = k ; numelementsinset = set . size ( ) ; configuration . reset ( ) ; randomgenerator = new twistergenerator ( ) ; this . populationsize = populationsize ; configure ( ) ; }
tr	2	private void jbutton1actionperformed ( actionevent evt ) { if ( jtextfield1 . gettext ( ) . isempty ( ) ) { joptionpane . showmessagedialog ( this , "please type in a message." ) ; } else { out . println ( jtextfield1 . gettext ( ) ) ; out . flush ( ) ; out . println ( login ) ; out . flush ( ) ; cal = calendar . getinstance ( ) ; jtextpane1 . settext ( jtextpane1 . gettext ( ) + "(" + sdf . format ( cal . gettime ( ) ) + ") " + login + " says: " + jtextfield1 . gettext ( ) + "\\n" ) ; jtextfield1 . settext ( "" ) ; } }
tr	2	public void authenticate ( ) { log . consolelog ( "authenticating with " + config . getauthmethod ( ) + "..." ) ; if ( config . getauthmethod ( ) . equalsignorecase ( "nickserv" ) ) { identify ( config . getauthpassword ( ) ) ; } else if ( config . getauthmethod ( ) . equalsignorecase ( "authserv" ) ) { sendmessage ( "authserv@services.gamesurge.net" , "auth kieraanbreeze " + config . getauthpassword ( ) ) ; } else { log . consolelog ( "warn" , "unknown authentication method. (" + config . getauthmethod ( ) + ")" ) ; dontauth = true ; } authed = true ; joinchannels ( ) ; }
tr	10	public boolean duplicateentrysection ( int x , int y , string entry ) { boolean duplicate = false ; int sx = ( x / size ) * size , sy = ( y / size ) * size ; for ( int i = sx ; i < sx + size && ! duplicate ; i ++ ) { for ( int j = sy ; j < sy + size && ! duplicate ; j ++ ) { duplicate = ( sudokugrid [ i ] [ j ] . equals ( entry ) ? true : false ) ; } } return duplicate ; }
tr	5	public linkedlist < integer > get_list_from_string ( string pos ) { string temp_str ; temp_str = pos . replaceall ( "[^0-9]" , " " ) ; string [ ] sar = temp_str . split ( "\\\\s+" ) ; linkedlist < integer > intarray = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < sar . length ; i ++ ) { if ( ( sar [ i ] . compareto ( "" ) != 0 ) ) { intarray . add ( integer . parseint ( sar [ i ] ) ) ; } } return intarray ; }
tr	8	private static void merge ( int [ ] a , int [ ] temp , int leftpos , int rightpos , int rightend ) { int leftend = rightpos - 1 ; int temppos = leftpos ; int sum = rightend - leftpos + 1 ; while ( leftpos <= leftend && rightpos <= rightend ) if ( a [ leftpos ] < a [ rightpos ] ) temp [ temppos ++ ] = a [ leftpos ++ ] ; else temp [ temppos ++ ] = a [ rightpos ++ ] ; while ( leftpos <= leftend ) temp [ temppos ++ ] = a [ leftpos ++ ] ; while ( rightpos <= rightend ) temp [ temppos ++ ] = a [ rightpos ++ ] ; for ( int i = 0 ; i < sum ; i ++ , rightend -- ) a [ rightend ] = temp [ rightend ] ; }
tr	2	public stringbuilder dohvatisadrzaj ( url url ) { bufferedreader in ; try { in = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; string inputline ; sadrzaj = new stringbuilder ( ) ; while ( ( inputline = in . readline ( ) ) != null ) { sadrzaj . append ( inputline ) ; sadrzaj . append ( "\\n" ) ; } } catch ( ioexception ex ) { logger . getlogger ( dretva . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return sadrzaj ; }
tr	9	public string minwindow ( string s , string t ) { if ( t . length ( ) == 0 ) return "" ; int lastbeginindex = - 1 ; string res = "" ; for ( int i = 0 , j = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charat ( i ) == t . charat ( j ) ) { j ++ ; if ( j == 1 ) lastbeginindex = i ; if ( j == t . length ( ) ) { j = 0 ; string - = s . substring ( lastbeginindex , i + 1 ) ; res = - . length ( ) < res . length ( ) || res . length ( ) == 0 ? - : res ; } } } return res ; }
tr	9	public void generate ( land [ ] [ ] world , float heightthreshold , float lakelevel ) { this . lakelevel = lakelevel ; this . world = world ; arraylist < land > startoptions = new arraylist < land > ( ) ; arraylist < land > riverstarts = new arraylist < land > ( ) ; for ( int i = 0 ; i < world . length ; i ++ ) { for ( int j = 0 ; j < world [ 0 ] . length ; j ++ ) { if ( world [ i ] [ j ] . height >= heightthreshold ) { startoptions . add ( world [ i ] [ j ] ) ; j += 10 ; i += 2 ; } } } int numrivers = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; system . out . println ( numrivers ) ; int rand = 0 ; for ( int i = 0 ; i < numrivers ; i ++ ) { rand = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; if ( rand == startoptions . size ( ) ) { rand -- ; } riverstarts . add ( startoptions . get ( rand ) ) ; startoptions . remove ( rand ) ; } for ( int i = 0 ; i < riverstarts . size ( ) ; i ++ ) { startriver ( riverstarts . get ( i ) ) ; } }
tr	10	final public static void addinetadr ( string iadr ) { byte [ ] adr ; byte [ ] mask ; inetaddress a ; stringtokenizer st = new stringtokenizer ( iadr , "/" ) ; try { a = inetaddress . getbyname ( st . nexttoken ( ) ) ; } catch ( unknownhostexception uf ) { system . out . println ( new date ( ) + " [error] can not resolve hostname " + iadr ) ; return ; } adr = a . getaddress ( ) ; mask = new byte [ adr . length ] ; for ( int i = 0 ; i < adr . length ; i ++ ) mask [ i ] = ( byte ) 0xff ; if ( st . hasmoretokens ( ) ) { iadr = st . nexttoken ( ) ; if ( iadr . indexof ( '.' ) > 0 ) { try { a = inetaddress . getbyname ( iadr ) ; } catch ( unknownhostexception uf ) { system . out . println ( new date ( ) + " [error] can not resolve hostmask " + iadr ) ; return ; } mask = a . getaddress ( ) ; } else { int bits = integer . valueof ( iadr ) . intvalue ( ) ; for ( int i = 0 ; i < mask . length ; mask [ i ++ ] = 0 ) ; int pos = 0 ; while ( bits > 0 ) { int t ; t = ( bits > 8 ? 8 : bits ) ; int v ; v = 0 ; for ( int i = 1 ; i <= t ; i ++ ) v = ( v > > 1 ) | 0x80 ; bits -= t ; mask [ pos ++ ] = ( byte ) v ; } } } for ( int i = 0 ; i < adr . length ; i ++ ) { adr [ i ] &= mask [ i ] ; } if ( httpreq . allowed == null ) { httpreq . allowed = new byte [ 0 ] [ ] ; httpreq . allowedmask = new byte [ 0 ] [ ] ; } byte [ ] tmp [ ] ; tmp = new byte [ httpreq . allowed . length + 1 ] [ ] ; system . arraycopy ( httpreq . allowed , 0 , tmp , 0 , httpreq . allowed . length ) ; tmp [ httpreq . allowed . length ] = adr ; httpreq . allowed = tmp ; tmp = new byte [ httpreq . allowedmask . length + 1 ] [ ] ; system . arraycopy ( httpreq . allowedmask , 0 , tmp , 0 , httpreq . allowedmask . length ) ; tmp [ httpreq . allowedmask . length ] = mask ; httpreq . allowedmask = tmp ; }
tr	2	private void expandtree ( treenode start , string [ ] path ) { for ( string item : path ) { for ( treenode node : start . getchildren ( ) ) { urldocument doc = ( urldocument ) node . getdata ( ) ; if ( doc . getname ( ) . matches ( item ) ) { node . getparent ( ) . setexpanded ( true ) ; start = node ; break ; } } } setselectednode ( start ) ; urldocument doc = ( urldocument ) start . getdata ( ) ; displaydoc . setdoc ( doc ) ; cruddoc . settreecontrol ( this ) ; cruddoc . setdoc ( doc ) ; }
tr	1	public task ( string name , int tasknumber , int numberofdays , string startdate , string enddate , gscene scene , task parent , double xposition , double yposition ) { this . name = name ; this . tasknumber = tasknumber ; this . numberofdays = numberofdays ; this . startdate = startdate ; this . enddate = enddate ; this . parent = parent ; this . yposition = yposition ; xsize = 200 ; ysize = 200 ; line = new gsegment ( ) ; addsegment ( line ) ; square = new gsegment ( ) ; addsegment ( square ) ; setstyle ( new gstyle ( ) ) ; if ( parent == null ) { scene . add ( this ) ; this . xposition = xposition ; } else { parent . add ( this ) ; this . xposition = parent . getxposition ( ) + xposition ; } updatetext ( ) ; }
tr	4	public static void main ( string args [ ] ) throws ioexception { string [ ] queystring = new string [ ] { "mondego" , "machine%20learning" , "software%20engineering" , "security" , "student%20affairs" , "crista%20lopes" , "rest" , "computer%20games" , "information%20retrieval" } ; string noofresults = "8" ; for ( string query : queystring ) { url url = new url ( "https://ajax.googleapis.com/ajax/services/search/web?v=1.0&" + "q=" + query + "%20site:ics.uci.edu&userip=users-ip-address&rsz=" + noofresults ) ; urlconnection connection = url . openconnection ( ) ; connection . addrequestproperty ( "referer" , "http://www.ics.uci.edu/" ) ; string line ; stringbuilder builder = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( connection . getinputstream ( ) ) ) ; while ( ( line = reader . readline ( ) ) != null ) { builder . append ( line ) ; } jsonobject json = new jsonobject ( builder . tostring ( ) ) ; jsonarray jsonarray = json . getjsonobject ( "responsedata" ) . getjsonarray ( "results" ) ; system . out . println ( "==========================================" ) ; system . out . println ( ) ; system . out . println ( "-------------------------------------" ) ; system . out . println ( "query string: " + query . replace ( "%20" , " " ) ) ; system . out . println ( "-------------------------------------" ) ; system . out . println ( ) ; for ( int i = 0 ; i < jsonarray . length ( ) ; i ++ ) { jsonobject o = ( jsonobject ) jsonarray . get ( i ) ; system . out . println ( "title: " + o . get ( "titlenoformatting" ) ) ; system . out . println ( "url: " + o . get ( "url" ) ) ; system . out . println ( ) ; system . out . println ( ) ; } system . out . println ( "==========================================" ) ; } }
tr	3	public void map ( avrowrapper k1 , nullwritable v1 , outputcollector < avrokey < joinkey > , avrovalue < avrooutputunion > > oc , reporter rprtr ) throws ioexception { try { joinkey jk = new joinkey ( ) ; avrounionconstructorvisitor obj = ( avrounionconstructorvisitor ) k1 . datum ( ) ; jk . key = ( long ) cls . getfield ( joinfield ) . get ( obj ) ; jk . position = position ; oc . collect ( new avrokey ( jk ) , new avrovalue ( obj . getoutputunion ( ) ) ) ; } catch ( illegalargumentexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( illegalaccessexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( nosuchfieldexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( securityexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	4	public static void main ( string [ ] args ) throws interruptedexception { if ( args . length != 3 ) throw new illegalargumentexception ( "please provide valid parameters: fibonacci number<litcomma> task quantity<litcomma> threads quantity" ) ; try { integer n = integer . valueof ( args [ 0 ] ) ; integer numberoftasks = integer . valueof ( args [ 1 ] ) ; integer threadquantity = integer . valueof ( args [ 2 ] ) ; if ( n <= 0 || numberoftasks <= 0 || threadquantity <= 0 ) throw new illegalargumentexception ( "all input parameters should be greater than 0" ) ; startcalculation ( n , numberoftasks , threadquantity ) ; } catch ( numberformatexception ex ) { throw new illegalaccesserror ( "you have to provide integer numbers as a parameters" ) ; } }
tr	10	private void generartour ( ) { tourbasico = new int [ numerodeciudades + 1 ] ; feromonas = new double [ numerodeciudades ] [ numerodeciudades ] ; visibilidad = new double [ numerodeciudades ] [ numerodeciudades ] ; tourbasico [ 0 ] = tourbasico [ numerodeciudades ] = 0 ; visitadas [ 0 ] = true ; for ( int i = 1 ; i < numerodeciudades ; i ++ ) { int mascercano = 0 ; for ( int j = 0 ; j < numerodeciudades ; j ++ ) { if ( ! visitadas [ j ] && ( mascercano == 0 || distancias [ tourbasico [ i ] ] [ j ] < distancias [ i ] [ mascercano ] ) ) { mascercano = j ; } } tourbasico [ i ] = mascercano ; visitadas [ mascercano ] = true ; } mejorrecorrido = tourbasico ; mejorlongitudderecorrido = calcularlongitudtour ( tourbasico ) ; tauzero = 1.0 / ( numerodeciudades - mejorlongitudderecorrido ) ; salidadedatos output = new salidadedatos ( ) ; stringbuilder mensaje = new stringbuilder ( ) ; mensaje . append ( mejorlongitudderecorrido ) . append ( "#nn" ) ; output . mostrarporpantalla ( mensaje . tostring ( ) ) ; }
tr	5	public board ( arraylist < cellstructure > list ) { tablica = new boolean [ tablica_length + 1 ] [ tablica_length + 1 ] ; for ( int i = 0 ; i < tablica_length ; i ++ ) { for ( int j = 0 ; j < tablica_length ; j ++ ) { tablica [ i ] [ j ] = false ; } } for ( int a = 0 ; a < list . size ( ) ; a ++ ) { tablica [ list . get ( a ) . getx ( ) ] [ list . get ( a ) . gety ( ) ] = list . get ( a ) . isvalue ( ) ; } }
tr	2	public playermessage handlemessage ( message message ) { if ( message . type . equals ( "request" ) ) { movemessage m = ( movemessage ) message ; if ( game_id != m . state . game_id ) { game_id = m . state . game_id ; if ( opponent != m . state . opponent_id ) { if ( totalgames != 0 ) { double wonratio = 1.0 * wongames / totalgames ; system . out . println ( opponent + " --- " + string . format ( "%.2f" , wonratio ) + "(w:" + wongames + " t:" + totalgames + ")" ) ; } totalgames = 0 ; wongames = 0 ; opponent = m . state . opponent_id ; } } if ( m . request . equals ( "request_card" ) ) { boolean shouldplay = ( ! m . state . can_challenge || ischanllenge ( m ) == false ) ; if ( shouldplay ) { int i = dm . onreceiverequest ( status , m ) ; if ( i == 9999 ) { offerchallengemessage challenge = new offerchallengemessage ( m . request_id ) ; return challenge ; } int [ ] hand = m . state . hand ; sort ( hand ) ; playcardmessage card = new playcardmessage ( m . request_id , hand [ i ] ) ; return card ; } else { offerchallengemessage challenge = new offerchallengemessage ( m . request_id ) ; return challenge ; } } else if ( m . request . equals ( "challenge_offered" ) ) { playermessage response ; if ( acceptchallenge ( m ) ) { response = new acceptchallengemessage ( m . request_id ) ; } else { response = new rejectchallengemessage ( m . request_id ) ; } return response ; } } else if ( message . type . equals ( "result" ) ) { resultmessage r = ( resultmessage ) message ; if ( r . result . type . equals ( "game_won" ) ) { if ( r . result . by == r . your_player_num ) wongames ++ ; totalgames ++ ; } dm . onreceiveresult ( status , r ) ; } else if ( message . type . equals ( "error" ) ) { errormessage e = ( errormessage ) message ; system . err . println ( "error: " + e . message ) ; if ( e . seen_host != null ) { system . exit ( 1 ) ; } } return null ; }
tr	10	public binomial ( random random , int min , int max , double p ) { if ( min >= max ) { throw new illegalargumentexception ( "invalid range" ) ; } this . random = random ; this . min = min ; this . n = max - min - 1 ; if ( n > 0 ) { v = new double [ n + 1 ] ; double sum = 0.0 ; for ( int i = 0 ; i <= n ; ++ i ) { sum += select ( n , i ) * power ( p , i ) * power ( 1 - p , n - i ) ; v [ i ] = sum ; } for ( int i = 0 ; i <= n ; ++ i ) { v [ i ] /= sum ; } } else { v = null ; } }
tr	3	public mainpanel ( simulation controller ) { this . scape = controller ; xsize = scape . xsize ; ysize = scape . ysize ; setlayout ( new gridlayout ( xsize , ysize ) ) ; addmouselistener ( this ) ; labels = new jlabel [ xsize ] [ ysize ] ; for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < xsize ; x ++ ) { labels [ x ] [ y ] = new jlabel ( "" ) ; labels [ x ] [ y ] . setopaque ( true ) ; labels [ x ] [ y ] . setborder ( borderfactory . createlineborder ( color . black ) ) ; labels [ x ] [ y ] . sethorizontalalignment ( swingconstants . center ) ; labels [ x ] [ y ] . setverticalalignment ( swingconstants . center ) ; add ( labels [ x ] [ y ] ) ; } } update ( ) ; }
tr	8	public void update ( ) { input ( ) ; if ( ball . gety ( ) < 1 ) ball . setdy ( 1 ) ; if ( ball . gety ( ) > height - 1 ) ball . setdy ( - 1 ) ; if ( bat . getx ( ) + bat . getwidth ( ) >= ball . getx ( ) && bat . getx ( ) <= ball . getx ( ) && bat . gety ( ) <= ball . gety ( ) && bat . gety ( ) + bat . getheight ( ) >= ball . gety ( ) ) { ball . setdx ( 1 ) ; if ( ball . gety ( ) < height / 2 ) { ball . setdy ( inverse ( ball . getdy ( ) ) ) ; } } if ( god_bat . getx ( ) - god_bat . getwidth ( ) <= ball . getx ( ) && god_bat . gety ( ) <= ball . gety ( ) && god_bat . gety ( ) + god_bat . getheight ( ) >= ball . gety ( ) ) { ball . setdx ( - 1 ) ; if ( ball . gety ( ) < height / 2 ) { ball . setdy ( inverse ( ball . getdy ( ) ) ) ; } } if ( ball . getx ( ) < - 12 ) ball . kill ( ) ; if ( ball . getx ( ) > width + 12 ) ball . kill ( ) ; ball . update ( ) ; bat . draw ( ) ; god_bat . draw ( ) ; ball . draw ( ) ; }
tr	2	public lamport ( bank bank ) throws socketexception { this . bank = bank ; this . port = config . bank2banklamportport [ bank . getid ( ) ] ; system . out . println ( "la banque " + bank . getid ( ) + " ecoute sur le port " + port ) ; socket = new datagramsocket ( port ) ; state = new lamportstate [ config . banksaddresses . length ] ; for ( int i = 0 ; i < state . length ; i ++ ) state [ i ] = new lamportstate ( ) ; new thread ( this ) . start ( ) ; }
tr	10	public static void main ( string [ ] arg ) { int n = 100 ; int [ ] a = new int [ n ] ; system . out . print ( "dessa tal slumpas till arrayen:" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 10 == 0 ) system . out . println ( ) ; a [ i ] = ( int ) ( 1000 * math . random ( ) ) ; system . out . print ( a [ i ] + "\\t" ) ; } int summa , max , min ; double medel ; summa = 0 ; max = - 1 ; min = 1000 ; for ( int i = 0 ; i < n ; i ++ ) { summa = summa + a [ i ] ; if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } medel = ( double ) summa / n ; system . out . println ( " " ) ; system . out . println ( "summa = " + summa + " medel = " + medel ) ; system . out . println ( "max = " + max + " min = " + min ) ; }
tr	3	public static void main ( string [ ] args ) throws malformedurlexception { model model = new model ( ) ; view view = new view ( model ) ; model . addobserver ( view ) ; view . setcac ( model . getc ( ) ) ; model . provjerisintaksu ( args , model , view ) ; long pocetak ; long kraj ; pocetak = system . currenttimemillis ( ) ; while ( true ) { kraj = system . currenttimemillis ( ) ; try { thread . currentthread ( ) . sleep ( model . getinterval ( ) * 1000 - ( kraj - pocetak ) ) ; } catch ( interruptedexception ex ) { logger . getlogger ( ztintor_zadaca_4 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } pocetak = system . currenttimemillis ( ) ; model . osvjezistranicu ( ) ; } }
tr	5	public void allpairmeetingfreq ( boolean idordist ) { long t_start = system . currenttimemillis ( ) ; system . out . println ( "allpairmeetingfreq starts" ) ; int k = user . alluserset . size ( ) ; system . out . println ( string . format ( "uary.length: %d" , k ) ) ; for ( int i = 0 ; i < k ; i ++ ) { user ua = user . alluserset . get ( i ) ; hashset < string > ua_locs = ua . getlocations ( ) ; for ( int j = i + 1 ; j < k ; j ++ ) { user ub = user . alluserset . get ( j ) ; hashset < string > ub_locs = ub . getlocations ( ) ; hashset < string > diff = new hashset < string > ( ub_locs ) ; diff . retainall ( ua_locs ) ; if ( diff . size ( ) > 0 ) { int aind = 0 ; int bind = 0 ; while ( aind < ua . records . size ( ) && bind < ub . records . size ( ) ) { record ra = ua . records . get ( aind ) ; record rb = ub . records . get ( bind ) ; if ( ra . timestamp - rb . timestamp > 4 * 3600 ) { bind ++ ; continue ; } else if ( rb . timestamp - ra . timestamp > 4 * 3600 ) { aind ++ ; continue ; } else { boolean ismeeting = false ; if ( idordist ) { ismeeting = ( ra . locid == rb . locid ) ; } else { ismeeting = ( ra . distanceto ( rb ) < miningframework . distance_threshold ) ; } if ( ismeeting ) { int first = ( i <= j ) ? i : j ; int second = ( i > j ) ? i : j ; if ( meetfreq . containskey ( first ) ) { if ( meetfreq . get ( first ) . containskey ( second ) ) { int k = meetfreq . get ( first ) . get ( second ) ; meetfreq . get ( first ) . put ( second , k + 1 ) ; } else { meetfreq . get ( first ) . put ( second , 1 ) ; } } else { meetfreq . put ( first , new hashmap < integer , integer > ( ) ) ; meetfreq . get ( first ) . put ( second , 1 ) ; } } aind ++ ; bind ++ ; } } } } if ( i % ( user . alluserset . size ( ) / 10 ) == 0 ) system . out . println ( string . format ( "process - allpairmeetingfreq finished %d0%%." , i / ( user . alluserset . size ( ) / 10 ) ) ) ; } long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "allpairmeetingfreq finishes in %d seconds<litcomma> in total %d pairs meet." , ( t_end - t_start ) / 1000 , meetfreq . size ( ) ) ) ; }
tr	7	public boolean isvalidsudoku ( char [ ] [ ] board , int row , int col , int val ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( character . getnumericvalue ( board [ row ] [ i ] ) == val ) return false ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( character . getnumericvalue ( board [ i ] [ col ] ) == val ) return false ; } int x = row / 3 ; int y = col / 3 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( character . getnumericvalue ( board [ i + x * 3 ] [ j + y * 3 ] ) == val ) return false ; } } return true ; }
tr	7	public arraylist < arraylist < integer > > permuteunique ( int [ ] num ) { arraylist < arraylist < integer > > res = new arraylist < arraylist < integer > > ( ) ; if ( num . length == 0 ) return res ; arrays . sort ( num ) ; arraylist < integer > init = new arraylist < integer > ( ) ; hashset < string > dup = new hashset < string > ( ) ; init . add ( num [ 0 ] ) ; res . add ( init ) ; dup . add ( init . tostring ( ) ) ; for ( int i = 1 ; i < num . length ; i ++ ) { int n = num [ i ] ; int size = res . size ( ) ; for ( int k = 0 ; k < size ; k ++ ) { arraylist < integer > t = res . get ( 0 ) ; res . remove ( 0 ) ; for ( int j = 0 ; j <= t . size ( ) ; j ++ ) { arraylist < integer > nt = new arraylist < integer > ( ) ; nt . addall ( t ) ; nt . add ( j , n ) ; if ( ! dup . contains ( nt . tostring ( ) ) ) { res . add ( nt ) ; dup . add ( nt . tostring ( ) ) ; } } } } return res ; }
tr	8	public hashmap < string , double > searchsingleword ( string search_word ) throws exception { hashmap < string , double > doc_weight_map = new hashmap < string , double > ( ) ; path src_doc_path = new path ( src_path ) ; filestatus [ ] src_doc_list = fs . liststatus ( src_doc_path ) ; final int doc_num = src_doc_list . length ; path index_file_path = new path ( index_file_name ) ; fsdatainputstream in = fs . open ( index_file_path ) ; bufferedreader br_in = new bufferedreader ( new inputstreamreader ( in ) ) ; string message_in ; while ( ( message_in = br_in . readline ( ) ) != null ) { string [ ] word_and_info = message_in . split ( "\\t" ) ; string word = word_and_info [ 0 ] ; if ( ignore_case_flag == true ) { word = word . tolowercase ( ) ; search_word = search_word . tolowercase ( ) ; } if ( word . equals ( search_word ) ) { string [ ] word_info = word_and_info [ 1 ] . split ( " " ) ; int doc_freq = integer . parseint ( word_info [ 1 ] . trim ( ) ) ; string [ ] doc_and_info = word_info [ 2 ] . split ( "\\\\]" ) ; for ( int i = 0 ; i < doc_freq ; i ++ ) { string [ ] doc_and_info_token = doc_and_info [ i ] . split ( "\\\\[" ) ; string file_name = doc_and_info_token [ 0 ] ; string [ ] info_token = doc_and_info_token [ 1 ] . split ( ":" ) ; int term_freq = integer . parseint ( info_token [ 0 ] ) ; double tf_idf = term_freq * math . log10 ( 1.0 * doc_num / doc_freq ) ; doc_weight_map . put ( file_name , new double ( tf_idf ) ) ; } } } in . close ( ) ; return doc_weight_map ; }
tr	8	public static void printreverselevel ( int arr [ ] ) { if ( arr . length == 0 ) return ; map < integer , arraylist < integer > > levels = new hashmap < > ( ) ; int i = 0 ; int maxlevel = 0 ; int currentlevel = 1 ; while ( i < arr . length && arr [ i ] != - 1 ) { i ++ ; } assert ( i < arr . length ) ; arraylist < integer > list = new arraylist < > ( ) ; list . add ( i ) ; levels . put ( currentlevel , list ) ; queue < integer > queue = new linkedblockingqueue < > ( ) ; queue . add ( i ) ; while ( ! queue . isempty ( ) ) { int element = queue . remove ( ) ; currentlevel += 1 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ j ] == element ) { queue . add ( j ) ; arraylist < integer > currentlist = levels . get ( currentlevel ) ; if ( currentlist == null ) { currentlist = new arraylist < integer > ( ) ; } currentlist . add ( j ) ; levels . put ( currentlevel , currentlist ) ; if ( currentlevel > maxlevel ) { maxlevel = currentlevel ; } } } } while ( maxlevel >= 1 ) { arraylist < integer > nodes = levels . get ( maxlevel ) ; maxlevel -- ; for ( int position : nodes ) { system . out . print ( position + " " ) ; } system . out . println ( ) ; } }
tr	8	public string compress ( string input ) { if ( input . length ( ) == 0 ) return input ; stringbuffer res = new stringbuffer ( ) ; char [ ] c = input . tochararray ( ) ; char lastchar = c [ 0 ] ; int lastindex = 0 ; int count = 0 ; for ( int i = 1 ; i < c . length ; i ++ ) { if ( c [ i ] != lastchar ) { count = i - lastindex ; res . append ( lastchar ) ; res . append ( count ) ; lastindex = i ; lastchar = c [ i ] ; } } res . append ( lastchar ) ; res . append ( count ) ; return ( res . length ( ) < input . length ( ) ? res . tostring ( ) : input ) ; }
tr	4	public static void checkall ( list < list < obj > > objlist , int delta ) { list < list < obj > > list1 = objlist . next ; while ( list1 != null ) { list < obj > obj1 = list1 . data . next ; while ( obj1 != null ) { list < list < obj > > list2 = list1 ; list < obj > obj2 = obj1 . next ; while ( list2 != null ) { while ( obj2 != null ) { if ( obj2 . data . shape . intersects ( obj1 . data . shape ) ) { obj2 . data . collide ( obj1 . data , delta ) ; obj1 . data . collide ( obj2 . data , delta ) ; } obj2 = obj2 . next ; } list2 = list2 . next ; if ( list2 != null ) obj2 = list2 . data . next ; } obj1 = obj1 . next ; } list1 = list1 . next ; if ( list1 != null ) obj1 = list1 . data . next ; } }
tr	2	public void actionperformed ( actionevent arg0 ) { string ipaddress = textfield . gettext ( ) ; string name = txtrakin . gettext ( ) ; int port = integer . parseint ( tfport . gettext ( ) ) ; try { system . out . println ( "trying to connect to server." ) ; socket socket = new socket ( ipaddress , port ) ; system . out . println ( "connected to server." ) ; inputstream is = socket . getinputstream ( ) ; outputstream os = socket . getoutputstream ( ) ; byte [ ] bytes = name . getbytes ( ) ; os . write ( bytes ) ; datainputstream dis = new datainputstream ( is ) ; while ( dis . available ( ) == 0 ) { } string response = dis . readutf ( ) ; if ( response . equals ( "validstudentid" ) ) { clientframe clientframe = new clientframe ( socket ) ; clientframe . setsize ( 450 , 300 ) ; clientframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; clientframe . setvisible ( true ) ; dispose ( ) ; } else { string errormessage = "" ; if ( response . equals ( "invalidipaddress" ) ) { errormessage = "the ip address for you device is not allowed to connect with the given student id." ; } else if ( response . equals ( "invalidstudentid" ) ) { errormessage = "the student id you provided is invalid. please re-enter a valid student id." ; } joptionpane . showmessagedialog ( null , errormessage ) ; socket . close ( ) ; } } catch ( unknownhostexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	9	public void run ( ) { int strangestartcount = 0 ; int erroneuslocuscount = 0 ; try { integer cog = loader . getnextcog ( ) ; while ( cog != null ) { arraylist < locus > genes = loader . cogs . get ( cog ) ; string f = dir + "/" + type + cog + ".fasta" ; printwriter pw = new printwriter ( f ) ; for ( iterator < locus > iterator = genes . iterator ( ) ; iterator . hasnext ( ) ; ) { locus l = iterator . next ( ) ; sequence s = locusupstreamloader . loadgeneupstream ( l , - upstream ) ; string seq = new string ( s . getseq ( ) ) ; if ( ! loader . starts . contains ( seq . substring ( upstream , upstream + 3 ) ) ) { system . out . println ( "thread " + id + "says: " + type + cog + " gene " + s . getname ( ) + ":" + seq . substring ( upstream , upstream + 3 ) ) ; string tr_seq = new string ( codon . transseq ( s . getseq ( ) , 0 ) ) ; string tr_seq_cut = tr_seq . substring ( ( int ) ( upstream / 3 ) , tr_seq . length ( ) - 1 ) ; string locusaa = locusseqloader . loadaaseq ( l . locusid , l . version ) ; if ( ! tr_seq_cut . substring ( 1 ) . equals ( locusaa . substring ( 1 ) ) ) { system . out . println ( "aa seqs not equal! reporting error" ) ; erroneuslocuscount ++ ; system . err . println ( "thread " + id + "says: " + type + cog + " gene " + s . getname ( ) + ":" + seq . substring ( upstream , upstream + 3 ) ) ; system . err . println ( "translated from contig pos: " + tr_seq_cut ) ; system . err . println ( "from locus aa seq: " + locusaa ) ; } else strangestartcount ++ ; } pw . println ( ">" + s . getname ( ) ) ; pw . println ( seq ) ; } pw . close ( ) ; system . out . println ( "thread " + id + "says: " + type + cog + " done." ) ; cog = loader . getnextcog ( ) ; } system . out . println ( "thread " + id + "reports: " + strangestartcount + " cases of strange start codons" ) ; system . out . println ( "thread " + id + "reports: " + erroneuslocuscount + " cases of erroneous locus" ) ; } catch ( sqlexception e ) { system . out . println ( "thread " + id + "says sql exception:" ) ; e . printstacktrace ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( "thread " + id + "says file not found exception:" ) ; e . printstacktrace ( ) ; } }
tr	1	public void run ( ) { byte [ ] buffer = new byte [ config . buffersize ] ; datagrampacket data = new datagrampacket ( buffer , buffer . length ) ; while ( true ) { try { socket . receive ( data ) ; lamportmessages type = lamportmessages . fromcode ( data . getdata ( ) [ 0 ] ) ; if ( type == lamportmessages . new_account ) { int [ ] newaccountdata = toolbox . builddata ( data . getdata ( ) , data . getlength ( ) , 0 ) ; bank . handleoncreate ( newaccountdata [ 0 ] , newaccountdata [ 1 ] ) ; } else { lamportstate state = lamportstate . frombyte ( data . getdata ( ) , data . getlength ( ) ) ; acceptreceive ( state , data ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	10	public arraylist < point > generaterelevantmoves ( boardmodel state ) { arraylist < point > rmoves = new arraylist < point > ( ) ; if ( ! boardmoves . containskey ( state . hashcode ( ) ) ) { if ( state . gravityenabled ( ) ) { for ( int i = 0 ; i < state . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < state . getheight ( ) ; j ++ ) { if ( state . getspace ( i , j ) == 0 ) { rmoves . add ( new point ( i , j ) ) ; break ; } } } } else { for ( int i = 0 ; i < state . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < state . getheight ( ) ; j ++ ) { if ( state . getspace ( i , j ) == 0 && ( ( i > 0 && state . getspace ( i - 1 , j ) != 0 ) || ( i > 0 && j > 0 && state . getspace ( i - 1 , j - 1 ) != 0 ) || ( j > 0 && state . getspace ( i , j - 1 ) != 0 ) || ( i < state . getwidth ( ) - 1 && j > 0 && state . getspace ( i + 1 , j - 1 ) != 0 ) || ( i < state . getwidth ( ) - 1 && state . getspace ( i + 1 , j ) != 0 ) || ( i < state . getwidth ( ) - 1 && j < state . getheight ( ) - 1 && state . getspace ( i + 1 , j + 1 ) != 0 ) || ( j < state . getheight ( ) - 1 && state . getspace ( i , j + 1 ) != 0 ) || ( i > 0 && j < state . getheight ( ) - 1 && state . getspace ( i - 1 , j + 1 ) != 0 ) ) ) { rmoves . add ( new point ( i , j ) ) ; } } } } boardmoves . put ( state . hashcode ( ) , rmoves ) ; return rmoves ; } else { return boardmoves . get ( state . hashcode ( ) ) ; } }
tr	7	@ eventhandler public void onentitydeathevent ( entitydeathevent event ) { player player ; entitytype entitytype = event . getentitytype ( ) ; entity entity = event . getentity ( ) ; string entityname = entity . getname ( ) ; string entitytypename = entity . gettype ( ) . name ( ) ; int skulltype ; boolean dropokay ; if ( entitytype . equals ( entitytype . player ) ) { return ; } material material = material . air ; if ( ( ( livingentity ) entity ) . getkiller ( ) instanceof player ) { player = ( player ) ( ( livingentity ) entity ) . getkiller ( ) ; material = player . getiteminhand ( ) . gettype ( ) ; } dropokay = isvaliditem ( entitytype , material ) ; if ( entitytype . equals ( entitytype . skeleton ) ) { switch ( ( ( skeleton ) entity ) . getskeletontype ( ) ) { case normal : if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } skulltype = 0 ; break ; case wither : if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } entityname = "wither skeleton" ; entitytypename = "wither_skeleton" ; skulltype = 1 ; break ; default : return ; } } else if ( entitytype . equals ( entitytype . zombie ) ) { if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } skulltype = 2 ; } else if ( entitytype . equals ( entitytype . creeper ) ) { if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } skulltype = 4 ; } else if ( entitytype . equals ( entitytype . ender_dragon ) ) { if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } skulltype = 5 ; } else if ( drop_chances . containskey ( entitytype . name ( ) ) ) { if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . name ( ) ) ) { return ; } skulltype = 3 ; } else { return ; } if ( ! dropokay ) { return ; } itemstack item = new itemstack ( material . skull_item , 1 , ( byte ) skulltype ) ; if ( entitytype . equals ( entitytype . guardian ) ) { if ( ( ( guardian ) entity ) . iselder ( ) ) { entityname = "elder guardian" ; entitytypename = "elder_guardian" ; } } if ( skulltype == 3 || custom_skins . containskey ( entityname ) ) { logdebug ( "dropping: [skin: " + custom_skins . get ( entitytypename ) + "] [etname: " + entityname + "] [ettype: " + entitytypename + "]" ) ; if ( custom_skins . containskey ( entitytypename ) ) { if ( ! custom_skins . get ( entitytypename ) . equalsignorecase ( "@default" ) ) { itemmeta itemmeta = item . getitemmeta ( ) ; ( ( skullmeta ) itemmeta ) . setowner ( custom_skins . get ( entitytypename ) ) ; itemmeta . setdisplayname ( entityname + " head" ) ; item . setitemmeta ( itemmeta ) ; } } else { logdebug ( "entity not in config: " + entityname ) ; } } location loc = entity . getlocation ( ) . clone ( ) ; world world = loc . getworld ( ) ; world . dropitemnaturally ( loc , item ) ; }
tr	2	public static void shellsort ( ) { int a [ ] = { 1 , 54 , 6 , 3 , 78 , 34 , 12 , 45 , 56 , 100 } ; double d1 = a . length ; int temp = 0 ; while ( true ) { d1 = d1 / 2 ; int d = ( int ) d1 ; for ( int x = 0 ; x < d ; x ++ ) { for ( int i = x + d ; i < a . length ; i += d ) { int j = i - d ; temp = a [ i ] ; for ( ; j >= 0 && temp < a [ j ] ; j -= d ) { a [ j + d ] = a [ j ] ; } a [ j + d ] = temp ; } } if ( d == 1 ) break ; } for ( int i = 0 ; i < a . length ; i ++ ) system . out . println ( a [ i ] ) ; }
tr	9	public static void main ( string [ ] args ) throws ioexception { if ( args . length < 1 ) { system . err . println ( "usage: java " + testmmseg . class . getsimplename ( ) + " <input> [output]" ) ; system . exit ( 1 ) ; } inputstream inputstream = new fileinputstream ( args [ 0 ] ) ; outputstream outputstream ; if ( args . length >= 2 ) { outputstream = new fileoutputstream ( args [ 1 ] ) ; } else { outputstream = system . out ; } bufferedreader reader = new bufferedreader ( new inputstreamreader ( inputstream ) ) ; writer writer = new outputstreamwriter ( outputstream ) ; mmseg mmseg = new mmseg ( ) ; date starttime = new date ( ) ; int linecount = 0 ; int tokencount = 0 ; try { string line = reader . readline ( ) ; while ( line != null ) { linecount ++ ; mmseg . reset ( new stringreader ( line ) ) ; stringbuffer buffer = new stringbuffer ( ) ; token token = mmseg . next ( ) ; while ( token != null ) { tokencount ++ ; if ( buffer . length ( ) > 0 ) { buffer . append ( " " ) ; } buffer . append ( token . gettext ( ) ) ; token = mmseg . next ( ) ; } buffer . append ( "\\n" ) ; writer . write ( buffer . tostring ( ) ) ; line = reader . readline ( ) ; } } finally { reader . close ( ) ; writer . close ( ) ; } date endtime = new date ( ) ; double seconds = ( double ) ( endtime . gettime ( ) - starttime . gettime ( ) ) / 1000 ; system . out . println ( "time spent: " + decimal_format . format ( seconds ) + " seconds" ) ; system . out . println ( "lines     : " + linecount ) ; system . out . println ( "tokens    : " + tokencount ) ; system . out . println ( "lines/sec : " + decimal_format . format ( linecount / seconds ) ) ; system . out . println ( "tokens/sec: " + decimal_format . format ( tokencount / seconds ) ) ; }
tr	1	private void run ( ) { dm = new decisionmaker ( ) ; status = new status ( ) ; while ( true ) { try { jsonsocket sock = new jsonsocket ( host , port ) ; try { sock . connect ( ) ; } catch ( ioexception e ) { throw new exception ( "error establishing connection to server: " + e . tostring ( ) ) ; } while ( true ) { message message = sock . getmessage ( ) ; playermessage response = handlemessage ( message ) ; if ( response != null ) { sock . sendmessage ( response ) ; } } } catch ( exception e ) { system . err . println ( "error: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . err . println ( "reconnecting in " + reconnect_timeout + "s" ) ; try { thread . sleep ( reconnect_timeout * 1000 ) ; } catch ( interruptedexception ex ) { } } } }
tr	6	public static string constructnewreq ( int reqorigin , int reqtime , int mynodenumber , arraylist < integer > alreadyseennew ) { string req = "rr" ; req = req + reqorigin + ";" + reqtime + ";" + mynodenumber + ";" ; for ( int i = 0 ; i < alreadyseennew . size ( ) ; i ++ ) { req = req + alreadyseennew . get ( i ) + "<litcomma>" ; } req = req + "0<litcomma>" ; req = req . substring ( 0 , req . length ( ) - 1 ) ; return req ; }
tr	4	@ suppresswarnings ( "rawtypes" ) public void generar ( ) { system . out . println ( isgenerarvos + "-" + isgenerartostringvos + "-" + ishelpervobetweenentity ) ; contenidohelpervoentity . append ( nl + "public class " + nombreclasehelpervoentity + "{\\n" + nl ) ; try { class [ ] lasclases = obtenerclasesdelpaquete ( paqueteentidades ) ; logger . info ( lasclases . length + " clases encontradas<litcomma> en " + paqueteentidades ) ; for ( int i = 0 ; i < lasclases . length ; i ++ ) { class clase = lasclases [ i ] ; importsclasehelpervoentity . append ( "import " + clase . getname ( ) + ";" + nl ) ; construirvo ( clase ) ; } contenidohelpervoentity . append ( nl + "}" ) ; if ( ishelpervobetweenentity ) { grabararchivodehelper ( paquetecodigogenerado , contenidohelpervoentity , getpatharchivosgenerados ( ) ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	public static editban loadban ( string [ ] d ) { if ( d . length < 7 ) { return null ; } editban e = new editban ( ) ; e . name = d [ 0 ] . tolowercase ( ) ; e . id = integer . parseint ( d [ 1 ] ) ; e . reason = d [ 2 ] ; e . admin = d [ 3 ] ; e . ip = ( d [ 4 ] . equals ( "null" ) ) ? null : d [ 4 ] ; e . time = long . parselong ( d [ 5 ] ) ; e . endtime = long . parselong ( d [ 6 ] ) ; e . type = integer . parseint ( d [ 7 ] ) ; return e ; }
tr	5	public void execute ( crawlercontext crawlercontext ) throws ioexception { document doc = jsoup . connect ( url ) . get ( ) ; elements elements = doc . select ( "table.data > tbody > tr a[href*=player]" ) ; for ( element e : elements ) { crawlercontext . submittask ( new processplayer ( e . attr ( "abs:href" ) ) ) ; } if ( ! processpagination ) { return ; } elements = doc . select ( ".pagenumbers > a" ) ; set < string > urls = new hashset < string > ( ) ; for ( element e : elements ) { urls . add ( e . attr ( "abs:href" ) ) ; } for ( string url : urls ) { crawlercontext . submittask ( new processletter ( url , false ) ) ; } }
tr	7	private static void initialtopkpair ( int topk ) { system . out . println ( "start initialtopkpair." ) ; try { bufferedreader fin = new bufferedreader ( new filereader ( string . format ( "topk_freqgt1-%d.txt" , topk ) ) ) ; string l = null ; bufferedreader fin2 = new bufferedreader ( new filereader ( string . format ( "topk_colocations-%d.txt" , topk ) ) ) ; string l2 = null ; int c1 = 0 ; int c2 = 0 ; while ( ( l = fin . readline ( ) ) != null ) { c1 ++ ; string [ ] ls = l . split ( "\\\\s+" ) ; if ( integer . parseint ( ls [ 2 ] ) > 0 ) { int uaid = integer . parseint ( ls [ 0 ] ) ; int ubid = integer . parseint ( ls [ 1 ] ) ; new user ( uaid ) ; new user ( ubid ) ; int friflag = integer . parseint ( ls [ 3 ] ) ; int [ ] fp = { uaid , ubid , friflag } ; frequentpair . add ( fp ) ; while ( c2 < c1 ) { c2 ++ ; l2 = fin2 . readline ( ) ; if ( c2 == c1 ) { hashset < string > colocs = new hashset < string > ( ) ; string [ ] ls2 = l2 . split ( "\\\\s+" ) ; for ( string s : ls2 ) colocs . add ( s ) ; frequentpair_colocations . add ( colocs ) ; } } } } fin . close ( ) ; fin2 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( "process initialtopkpair ends." ) ; }
tr	3	private void jbutton1actionperformed ( actionevent evt ) { try { socket = new socket ( "127.0.0.1" , 2009 ) ; login = jtextfield1 . gettext ( ) ; password = new string ( jpasswordfield1 . getpassword ( ) ) ; logincheck lc = new logincheck ( socket ) ; idcheck = lc . check ( login , password ) ; if ( ! idcheck ) { joptionpane . showmessagedialog ( this , "bad login and/or password." ) ; } else { t2 = new thread ( new chatwindow ( socket , login ) ) ; t2 . start ( ) ; this . dispose ( ) ; } } catch ( unknownhostexception e ) { system . err . println ( "can't connect to address " + socket . getlocaladdress ( ) ) ; } catch ( ioexception e ) { system . err . println ( "no server listening on port " + socket . getlocalport ( ) ) ; } }
tr	5	protected void from_net ( string header ) throws exception { log . info ( "try from net!" ) ; string host = extractfromheader ( header , "host:" , "\\n" ) , path = getpath ( header ) ; if ( ( host == null ) || ( path == null ) ) { printerror ( "invalid request:\\n" + header ) ; return ; } log . info ( "transform path: " + path ) ; int port = host . indexof ( ":" , 0 ) ; if ( port < 0 ) port = 80 ; else { port = integer . parseint ( host . substring ( port + 1 ) ) ; host = host . substring ( 0 , port ) ; } log . info ( "from net host+port: " + host + ":" + port ) ; from_net ( header , host , port , path ) ; }
tr	2	public guichessboard ( ) throws chessexception { super ( ) ; turn = chesscolor . color_white ; from = null ; board_ui = null ; board_ui = new jframe ( "chess board" ) ; board_ui . setdefaultcloseoperation ( jframe . exit_on_close ) ; board_ui . setpreferredsize ( new dimension ( 400 , 400 ) ) ; gridlayout gl = new gridlayout ( 9 , 9 ) ; container pnl = board_ui . getcontentpane ( ) ; pnl . setlayout ( gl ) ; font f = new font ( null , font . bold | font . italic , 16 ) ; font f2 = new font ( null , font . bold , 26 ) ; color clr = new color ( 255 , 0 , 0 ) ; color clr2 = new color ( 0 , 0 , 255 ) ; pnl . setbackground ( color . white ) ; jlabel jl = new jlabel ( ) ; jl . settext ( " " ) ; pnl . add ( jl ) ; for ( int i = 0 ; i < 8 ; i ++ ) { jl = new jlabel ( ) ; jl . setfont ( f ) ; jl . setopaque ( true ) ; jl . settext ( character . tostring ( ( char ) ( 'a' + i ) ) ) ; jl . sethorizontalalignment ( jlabel . center ) ; jl . setverticalalignment ( jlabel . center ) ; jl . setforeground ( clr ) ; pnl . add ( jl ) ; } for ( int i = 0 ; i < 8 ; i ++ ) { jl = new jlabel ( ) ; jl . setfont ( f ) ; jl . sethorizontalalignment ( jlabel . center ) ; jl . setverticalalignment ( jlabel . center ) ; jl . settext ( integer . tostring ( 8 - i ) ) ; jl . setforeground ( clr ) ; pnl . add ( jl ) ; for ( int j = 0 ; j < 8 ; j ++ ) { jl = new jlabel ( ) ; jl . setborder ( borderfactory . createlineborder ( color . black ) ) ; jl . setopaque ( true ) ; jl . sethorizontalalignment ( jlabel . center ) ; jl . setverticalalignment ( jlabel . center ) ; jl . setfont ( f2 ) ; jl . setforeground ( clr2 ) ; if ( ( i % 2 ) == 1 ) { if ( ( j % 2 ) == 1 ) jl . setbackground ( color . white ) ; else jl . setbackground ( color . light_gray ) ; } else { if ( ( j % 2 ) == 0 ) jl . setbackground ( color . white ) ; else jl . setbackground ( color . light_gray ) ; } if ( board [ i ] [ j ] != null ) jl . settext ( board [ i ] [ j ] . getimage ( ) ) ; jl . addmouselistener ( this ) ; pnl . add ( jl ) ; } } board_ui . pack ( ) ; board_ui . setvisible ( true ) ; }
tr	8	protected static void updatelabel ( int numvar , int pattern , int prefix , int update ) { if ( numvar == 0 ) { numlayer [ reversedigit ( totalvar , 2 , prefix ) ] += update ; return ; } if ( pattern % 3 == 0 || pattern % 3 == 2 ) updatelabel ( numvar - 1 , pattern / 3 , prefix * 2 + 0 , update ) ; if ( pattern % 3 == 1 || pattern % 3 == 2 ) updatelabel ( numvar - 1 , pattern / 3 , prefix * 2 + 1 , update ) ; }
tr	6	private void setposition ( char cb_col , char cb_row ) throws chessexception { char tc = character . touppercase ( cb_col ) ; if ( ( tc < 'a' ) || ( tc > 'h' ) ) throw new chessexception ( "invalid board column position given: " + cb_col ) ; col = tc - 'a' ; if ( character . isdigit ( cb_row ) ) { row = character . getnumericvalue ( cb_row ) ; if ( ( row < 1 ) || ( row > 8 ) ) throw new chessexception ( "invalid board row position given: " + cb_row ) ; row = 8 - row ; } else { throw new chessexception ( "board row position not digit: " + cb_row ) ; } }
tr	5	@ override public void onenable ( ) { savedefaultconfig ( ) ; pluginmanager pm = getserver ( ) . getpluginmanager ( ) ; plugin gmi = pm . getplugin ( "gamemodeinventories" ) ; if ( gmi == null ) { system . err . println ( "[gmidatabaseconverter] this plugin requires gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } string v = gmi . getdescription ( ) . getversion ( ) ; version gmiversion = new version ( v ) ; version notneededversion = new version ( "2.0" ) ; if ( gmiversion . compareto ( notneededversion ) >= 0 ) { system . err . println ( "[gmidatabaseconverter] you do not need to run this with version " + v + " of gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } if ( getconfig ( ) . getboolean ( "conversion_done" ) ) { system . err . println ( "[gmidatabaseconverter] the gamemodeinventories database has already been converted!" ) ; pm . disableplugin ( this ) ; return ; } file old_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi.db" ) ; if ( ! old_file . exists ( ) ) { system . err . println ( "[gmidatabaseconverter] could not find gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } file backup_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi_backup.db" ) ; try { copyfile ( old_file , backup_file ) ; } catch ( ioexception io ) { system . err . println ( "[gmidatabaseconverter] could backup gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } system . out . println ( "[gmidatabaseconverter] the gamemodeinventories database file was backed up successfully!" ) ; try { string path = gmi . getdatafolder ( ) + file . separator + "gmi.db" ; service . setconnection ( path ) ; } catch ( exception e ) { system . err . println ( "[gmidatabaseconverter] database connection error: " + e ) ; } if ( ! convertinventories ( ) ) { system . err . println ( "[gmidatabaseconverter] inventory conversion failed!" ) ; pm . disableplugin ( this ) ; } else { getconfig ( ) . set ( "conversion_done" , true ) ; } }
tr	4	private package nodetopackage ( node item ) { package p = new package ( ) ; nodelist params = item . getchildnodes ( ) ; for ( int i = 0 ; i < params . getlength ( ) ; i ++ ) { node current = params . item ( i ) ; if ( current instanceof element ) { if ( current . getnodename ( ) . equals ( "groupid" ) ) { p . groupid = current . getfirstchild ( ) . getnodevalue ( ) ; } if ( current . getnodename ( ) . equals ( "artifactid" ) ) { p . artifactid = current . getfirstchild ( ) . getnodevalue ( ) ; } if ( current . getnodename ( ) . equals ( "version" ) ) { p . version = current . getfirstchild ( ) . getnodevalue ( ) ; } } } if ( p . groupid . contains ( "${" ) || p . artifactid . contains ( "${" ) || p . version . contains ( "${" ) ) { return null ; } return p ; }
tr	3	public static arraylist < string > tokenizefile ( file input ) throws ioexception { bufferedreader inputbr = null ; arraylist < string > tokanizedwords = new arraylist < string > ( ) ; arraylist < string > temparrlist = new arraylist < string > ( ) ; try { string inputstring = "" ; hashset < string > stopwords = new hashset < string > ( ) ; string line = null ; file file = new file ( "src/ir/assignments/utilfiles/stopwords" ) ; inputbr = new bufferedreader ( new filereader ( file ) ) ; while ( ( line = inputbr . readline ( ) ) != null ) { stopwords . add ( line . trim ( ) ) ; } int i = 0 ; inputbr = new bufferedreader ( new filereader ( input ) ) ; while ( ( inputstring = inputbr . readline ( ) ) != null ) { if ( inputstring . trim ( ) . length ( ) != 0 || ! inputstring . equals ( " +" ) ) { inputstring = inputstring . replaceall ( " +" , " " ) ; inputstring = inputstring . replaceall ( "[^\\\\w\\\\s]" , "" ) ; inputstring = inputstring . replaceall ( "[^\\\\p{l}\\\\p{n}]" , " " ) ; inputstring = inputstring . trim ( ) ; inputstring = inputstring . tolowercase ( ) ; inputstring = inputstring . replaceall ( " +" , " " ) ; temparrlist . clear ( ) ; temparrlist . addall ( arrays . aslist ( inputstring . split ( " " ) ) ) ; temparrlist = removestopwords ( temparrlist , stopwords ) ; tokanizedwords . addall ( temparrlist ) ; i ++ ; if ( i % 500 == 0 ) { calendar cal = calendar . getinstance ( ) ; cal . gettime ( ) ; simpledateformat sdf = new simpledateformat ( "hh:mm:ss" ) ; system . out . println ( i + " :    " + sdf . format ( cal . gettime ( ) ) + " ----------------    " + tokanizedwords . size ( ) ) ; } } } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } finally { inputbr . close ( ) ; } if ( tokanizedwords . size ( ) == 1 && tokanizedwords . get ( 0 ) . equals ( "" ) ) { return new arraylist < string > ( ) ; } else { return tokanizedwords ; } }
tr	1	public treecontroller ( ) { root = new defaulttreenode ( new urldocument ( "base" , "about:blank" , ( treenode ) null ) , ( treenode ) null ) ; defaulttreenode top = new defaulttreenode ( new urldocument ( "root" , "about:blank" , root ) , root ) ; selectednode = top ; nodepath = "/root" ; defaulttreenode folder1 = new defaulttreenode ( new urldocument ( "newspapers" , "about:blank" , top ) , top ) ; new defaulttreenode ( new urldocument ( "libe" , "http://www.liberation.fr" , folder1 ) , folder1 ) ; new defaulttreenode ( new urldocument ( "lemonde" , "http://www.lemonde.fr" , folder1 ) , folder1 ) ; defaulttreenode folder2 = new defaulttreenode ( new urldocument ( "web design" , "about:blank" , top ) , top ) ; new defaulttreenode ( new urldocument ( "w3schools" , "http://www.w3schools.com/" , folder2 ) , folder2 ) ; new defaulttreenode ( new urldocument ( "primefaces" , "http://www.primefaces.org/showcase/ui/home.jsf" , folder2 ) , folder2 ) ; new defaulttreenode ( new urldocument ( "prettyfaces" , "http://ocpsoft.org/docs/prettyfaces/3.3.2/en-us/html_single/" , folder2 ) , folder2 ) ; }
tr	7	private exam parseexam ( final node exam ) { string name = "" ; string mark = "" ; final nodelist fields = exam . getchildnodes ( ) ; for ( int i = 0 ; i < fields . getlength ( ) ; ++ i ) { final node field = fields . item ( i ) ; if ( field != null ) { if ( field . getnodetype ( ) == node . element_node ) { final node item = field . getchildnodes ( ) . item ( 0 ) ; if ( item != null ) { if ( field . getnodename ( ) == model . field_name ) { name = item . getnodevalue ( ) ; } if ( field . getnodename ( ) == model . field_mark ) { mark = item . getnodevalue ( ) ; } } } } } return new exam ( name , util . isnumeric ( mark ) ? integer . parseint ( mark ) : null ) ; }
tr	2	public void crearinmueble ( inmuebles inm , conexion conexion ) { try { connection con = conexion . getinstance ( ) . crearconexion ( ) ; statement st = con . createstatement ( ) ; string sql = "insert into  inmueble (nombre<litcomma>direccion<litcomma>telefono<litcomma>estado<litcomma>negocio<litcomma>comentarios<litcomma>id)" + " values(" + "'" + inm . getinmnom ( ) + "'<litcomma>" + "'" + inm . getinmdir ( ) + "'<litcomma>" + "'" + inm . getinmtel ( ) + "'<litcomma>" + "'" + inm . getinmvenoarr ( ) + "'<litcomma>'" + inm . getinmnegoc ( ) + "'" + "<litcomma>'" + inm . getinccomments ( ) + "'" + "<litcomma>" + idn . getid ( ) + ");" ; system . out . println ( sql ) ; st . executeupdate ( sql ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { conexion . getinstance ( ) . cerrarconn ( ) ; } }
tr	3	public arraylist < inmuebles > consultarinmueble ( int id ) { conexion conexion = new conexion ( ) ; try { int a ; string b ; string c ; string d ; string f ; connection con = conexion . getinstance ( ) . crearconexion ( ) ; statement st = con . createstatement ( ) ; string sql = "select idin<litcomma>nombre<litcomma>direccion<litcomma>telefono<litcomma>negocio from inmueble where id=" + id + ";" ; resultset resultado = st . executequery ( sql ) ; while ( resultado . next ( ) ) { a = resultado . getint ( "idin" ) ; b = resultado . getstring ( "nombre" ) ; c = resultado . getstring ( "direccion" ) ; d = resultado . getstring ( "telefono" ) ; f = resultado . getstring ( "negocio" ) ; inmuebles e = new inmuebles ( a , b , c , d , f ) ; lista . add ( e ) ; for ( int i = 0 ; i < lista . size ( ) ; i ++ ) { } } } catch ( exception e ) { e . printstacktrace ( ) ; } finally { conexion . getinstance ( ) . cerrarconn ( ) ; } return lista ; }
tr	9	public void loadfromfile ( file file , string separator , boolean skipfirst ) { try { bufferedreader in = new bufferedreader ( new filereader ( file ) ) ; string line ; int irow = - 1 ; pattern pattern = pattern . compile ( separator , pattern . literal ) ; while ( ( line = in . readline ( ) ) != null ) { ++ irow ; if ( irow == 0 && skipfirst ) continue ; if ( stringutils . trimtonull ( line ) == null ) continue ; string [ ] tokens = pattern . split ( line , - 1 ) ; int icol = - 1 ; row row = new row ( ) ; for ( string token : tokens ) { ++ icol ; if ( icol + 1 > this . colnames . size ( ) ) break ; row . data . add ( this . objectbuilders . get ( icol ) . build ( token ) ) ; } row . names = this . colnames ; this . rows . add ( row ) ; } in . close ( ) ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( e ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	8	public boolean isborder ( snake snake , keyevent keyevent ) { int sp2x = snake . getx ( ) + 60 ; int sp4y = snake . gety ( ) + 45 ; int sp1x = snake . getx ( ) ; if ( sp2x >= 985 && keyevent . getkeycode ( ) == keyevent . vk_right ) return true ; if ( sp4y > 665 && keyevent . getkeycode ( ) == keyevent . vk_down ) return true ; if ( sp4y <= 35 && keyevent . getkeycode ( ) == keyevent . vk_up ) return true ; if ( sp1x < 0 && keyevent . getkeycode ( ) == keyevent . vk_left ) return true ; return false ; }
tr	9	public static round parsefirstround ( reader reader , hashtable < string , team > teams ) throws exception { round games = new round ( ) ; csvreader csvreader = new csvreader ( reader ) ; list < string [ ] > lines ; try { lines = csvreader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( string [ ] tokens : lines ) { if ( tokens . length == 1 && tokens [ 0 ] . trim ( ) . length ( ) == 0 ) continue ; team [ ] gameteams = new team [ 2 ] ; gameteams [ 0 ] = teams . get ( tokens [ 0 ] ) ; gameteams [ 1 ] = teams . get ( tokens [ 1 ] ) ; if ( gameteams [ 0 ] == null ) throw new exception ( "team not found: " + tokens [ 0 ] ) ; if ( gameteams [ 1 ] == null ) throw new exception ( "team not found: " + tokens [ 1 ] ) ; if ( tokens . length >= 4 ) { gameteams [ 0 ] . seed = integer . parseint ( tokens [ 2 ] ) ; gameteams [ 1 ] . seed = integer . parseint ( tokens [ 3 ] ) ; } for ( int i = 0 ; i < 2 ; i ++ ) if ( gameteams [ i ] == null ) throw new exception ( "team not found: " + tokens [ i ] ) ; game game = new game ( gameteams ) ; game . name = string . format ( "r0 g%d" , games . size ( ) ) ; games . add ( game ) ; } return games ; }
tr	8	public void callnetstat ( ) { try { bytearrayoutputstream netout = new bytearrayoutputstream ( ) ; bytearrayoutputstream neterr = new bytearrayoutputstream ( ) ; string systemos = system . getproperty ( "os.name" ) ; string localaddr = "" ; arraylist < string > cmd = new arraylist < string > ( ) ; if ( systemos . equals ( "z/os" ) ) { cmd . add ( "onetstat" ) ; cmd . add ( "-a" ) ; } else if ( systemos . equalsignorecase ( "os/400" ) ) { cmd . add ( "qsh" ) ; cmd . add ( "-c" ) ; cmd . add ( "netstat" ) ; } else { cmd . add ( "netstat" ) ; cmd . add ( "-n" ) ; cmd . add ( "-a" ) ; } processbuilder pb = new processbuilder ( cmd ) ; process p = pb . start ( ) ; myreader out = new myreader ( p . getinputstream ( ) , netout ) ; myreader err = new myreader ( p . geterrorstream ( ) , neterr ) ; out . start ( ) ; err . start ( ) ; p . waitfor ( ) ; out . join ( ) ; err . join ( ) ; string output = netout . tostring ( ) ; if ( output . trim ( ) . length ( ) == 0 ) { throw new exception ( "did not receive any output from netstat" ) ; } stringtokenizer stok = new stringtokenizer ( output , "\\r\\n" ) ; stok . nextelement ( ) ; stok . nextelement ( ) ; if ( systemos . equals ( "z/os" ) ) { stok . nextelement ( ) ; } while ( stok . hasmoreelements ( ) ) { string s = ( string ) stok . nextelement ( ) ; if ( systemos . equals ( "z/os" ) ) { pattern ptrn = pattern . compile ( "\\\\s\\\\slocal\\\\ssocket:.*?\\\\.\\\\.(\\\\d*).*" ) ; matcher m = ptrn . matcher ( s ) ; if ( m . find ( ) ) { localaddr = m . group ( 1 ) ; try { int port = integer . parseint ( localaddr ) ; if ( ! this . netstat . contains ( integer . valueof ( port ) ) ) this . netstat . add ( integer . valueof ( port ) ) ; } catch ( numberformatexception e ) { } } } else { stringtokenizer stok2 = new stringtokenizer ( s ) ; if ( stok2 . counttokens ( ) > 1 ) { stok2 . nextelement ( ) ; if ( ! system . getproperty ( "os.name" ) . tolowercase ( ) . contains ( "windows" ) ) { if ( stok2 . counttokens ( ) > 2 ) { stok2 . nextelement ( ) ; stok2 . nextelement ( ) ; } } else { } localaddr = ( string ) stok2 . nextelement ( ) ; if ( localaddr . indexof ( ":" ) != - 1 ) localaddr = localaddr . substring ( localaddr . lastindexof ( ":" ) + 1 ) ; else if ( localaddr . lastindexof ( "." ) != - 1 ) { localaddr = localaddr . substring ( localaddr . lastindexof ( "." ) + 1 ) ; } try { int port = integer . parseint ( localaddr ) ; if ( ! this . netstat . contains ( integer . valueof ( port ) ) ) this . netstat . add ( integer . valueof ( port ) ) ; } catch ( numberformatexception e ) { } } } } } catch ( exception e ) { throw myexceptionutils . uncheckexception ( "error trying to parse netstat output" , e ) ; } }
tr	2	@ override public void dofilter ( servletrequest servletrequest , servletresponse servletresponse , filterchain filterchain ) throws ioexception , servletexception { httpservletrequest request = ( httpservletrequest ) servletrequest ; httpservletresponse response = ( httpservletresponse ) servletresponse ; string cid = getconversationid ( request ) ; if ( cid != null ) { string ccid = getconversationcontextid ( request ) ; try { conversationmanager . resumeconversation ( cid , ccid , request ) ; log . debug ( "conv. {} resumed. nb ctx: {}" , cid , getcurrentconversation ( ) . getconversationcontextescount ( ) ) ; } catch ( unexpectedconversationexception uue ) { log . error ( uue . getmessage ( ) ) ; response . sendredirect ( request . getcontextpath ( ) + uue . getredirecturl ( ) ) ; return ; } try { filterchain . dofilter ( request , response ) ; } finally { conversationmanager . pausecurrentconversation ( request ) ; } } else if ( ! request . getrequesturi ( ) . contains ( "/javax.faces.resource/" ) && "true" . equals ( request . getparameter ( "_ncid_" ) ) ) { throw new illegalargumentexception ( "this version does not support ncid parameter" ) ; } else { filterchain . dofilter ( request , response ) ; } }
tr	5	@ override public void run ( ) { try { while ( ! ds . updateuiflag ) { thread . sleep ( 100 ) ; } cui . appendstatus ( "guiupdate startar och kommer att k\xf6ra i " + sleeptime + " millisekunder." ) ; int i = 1 ; while ( i <= 20 ) { thread . sleep ( sleeptime / 20 ) ; cui . appendstatus ( "jag \xe4r tr\xe5d guiupdate! f\xf6r " + i + ":te g\xe5ngen." ) ; ds . robot1x = ds . robot1x + 10 ; cui . repaint ( ) ; i ++ ; } } catch ( interruptedexception exception ) { } cui . appendstatus ( "guiupdate \xe4r nu klar!" ) ; }
tr	6	private void queryand ( list < string > data , string word , int atleast ) { string [ ] dataar = new string [ data . size ( ) ] ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { dataar [ i ] = data . get ( i ) ; } for ( string sentence : dataar ) { string caseinsensitivesentence = sentence . tolowercase ( ) ; if ( ! queryandhasatleast ( caseinsensitivesentence , word , atleast ) ) { data . remove ( sentence ) ; } } }
tr	4	public void run ( ) { try { socket = new socket ( host , port ) ; in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; out = new bufferedwriter ( new outputstreamwriter ( socket . getoutputstream ( ) ) ) ; writeline ( "nick :" + nick ) ; writeline ( "user " + nick + " * * :" + nick ) ; writeline ( "join :" + channel ) ; string line = null ; while ( ( line = in . readline ( ) ) != null ) { system . out . println ( "<<< " + line ) ; message msg = new message ( line ) ; for ( messagehandler mh : handlers ) { mh . handle ( msg ) ; } } } catch ( exception e ) { system . err . println ( "cannot connect and operate bot" ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	3	public static void main ( string [ ] args ) { meowzy bot = new meowzy ( ) ; log . consolelog ( "starting up..." ) ; config . loadconfiguration ( ) ; file check = new file ( "meowzy.db" ) ; if ( ! check . exists ( ) ) { bot . sql . resetdatabase ( ) ; } try { bot . connect ( config . getserveraddress ( ) ) ; } catch ( nickalreadyinuseexception e ) { if ( ! config . getautonickchange ( ) ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } else { log . consolelog ( "error" , "nick already in use!" ) ; } } catch ( ioexception e ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } catch ( ircexception e ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } }
tr	8	public arraylist < integer > graycode ( int n ) { arraylist < integer > res = new arraylist < integer > ( ) ; arraylist < string > tempres = new arraylist < string > ( ) ; if ( n == 0 ) { res . add ( 0 ) ; return res ; } for ( int i = 1 ; i <= n ; i ++ ) { int size = tempres . size ( ) ; if ( size == 0 ) { tempres . add ( "0" ) ; tempres . add ( "1" ) ; } else { boolean bzero = true ; for ( int j = 0 ; j < size ; j ++ ) { string curr = tempres . get ( 0 ) ; tempres . remove ( 0 ) ; if ( bzero ) { tempres . add ( curr + "0" ) ; tempres . add ( curr + "1" ) ; bzero = false ; } else { tempres . add ( curr + "1" ) ; tempres . add ( curr + "0" ) ; bzero = true ; } } } } for ( string s : tempres ) { res . add ( integer . parseint ( s , 2 ) ) ; } return res ; }
tr	8	@ override public sequence frombytearray ( byte [ ] bytes ) throws binaryreaderexception { if ( bytes . length != size ) { throw new binaryreaderexception ( "illegal byte array size: " + bytes . length + " (expected " + size + ")" ) ; } long code = 0 ; byte len = bytes [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { code = code << 8 ; int b = 255 & bytes [ i ] ; code = code | b ; } return new sequence ( code , len ) ; }
tr	8	private double computestress ( ) { calculateareas ( ) ; if ( totalcount == 0 ) { scaleconfiguration ( ) ; calculateareas ( ) ; } double xx = 0 ; double xy = 0 ; int n = polydata . length ; double sst = 0 ; for ( int i = 1 ; i < n ; i ++ ) { double x = polydata [ i ] ; double y = polyareas [ i ] ; xy += x * y ; xx += x * x ; sst += y * y ; } double slope = xy / xx ; double sse = 0 ; for ( int i = 1 ; i < n ; i ++ ) { double x = polydata [ i ] ; double y = polyareas [ i ] ; double yhat = x * slope ; polyhats [ i ] = yhat ; sse += ( y - yhat ) * ( y - yhat ) ; } return sse / sst ; }
tr	2	@ override public void exec ( string channel , string sender , string commandname , string [ ] args , string login , string hostname , string message ) { try { sourceserver tf4 = new sourceserver ( "tf4.joe.to" ) ; tf4 . initialize ( ) ; system . out . println ( tf4 . getserverinfo ( ) ) ; this . bot . sendmessage ( channel , "[tf4] map: " + tf4 . getserverinfo ( ) . get ( "mapname" ) + "  players: " + tf4 . getserverinfo ( ) . get ( "numberofplayers" ) + " / " + tf4 . getserverinfo ( ) . get ( "maxplayers" ) ) ; } catch ( timeoutexception e ) { this . bot . sendmessage ( channel , "[tf4] error: timed out." ) ; e . printstacktrace ( ) ; } catch ( steamcondenserexception e ) { this . bot . sendmessage ( channel , "[tf4] error: i don't even know what went wrong." ) ; e . printstacktrace ( ) ; } try { sourceserver tf5 = new sourceserver ( "tf5.joe.to" ) ; tf5 . initialize ( ) ; system . out . println ( tf5 . getserverinfo ( ) ) ; this . bot . sendmessage ( channel , "[tf5] map: " + tf5 . getserverinfo ( ) . get ( "mapname" ) + "  players: " + tf5 . getserverinfo ( ) . get ( "numberofplayers" ) + " / " + tf5 . getserverinfo ( ) . get ( "maxplayers" ) ) ; } catch ( timeoutexception e ) { this . bot . sendmessage ( channel , "[tf5] error: timed out." ) ; e . printstacktrace ( ) ; } catch ( steamcondenserexception e ) { this . bot . sendmessage ( channel , "[tf5] error: i don't even know what went wrong." ) ; e . printstacktrace ( ) ; } }
tr	7	private static hashtable < string , team > parsestats ( csvreader reader , collection < stat > stats ) { hashtable < string , team > teams = new hashtable < string , team > ( ) ; list < string [ ] > lines ; try { lines = reader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { string [ ] tokens = lines . get ( i ) ; if ( tokens . length == 1 && ! tokens [ 0 ] . trim ( ) . equals ( "" ) ) { for ( stat stat : stats ) { if ( stat . table . equals ( tokens [ 0 ] ) ) { int j = i + 1 ; for ( ; j < lines . size ( ) ; j ++ ) if ( lines . get ( j ) [ 0 ] . equalsignorecase ( "rank" ) ) break ; string [ ] columntitles = lines . get ( j ) ; int columnindex = findcolumnindex ( columntitles , stat . column ) ; j ++ ; while ( true ) { string [ ] values = lines . get ( j ) ; if ( ( values . length == 1 && values [ 0 ] . trim ( ) . length ( ) == 0 ) || values [ 0 ] . equals ( "reclassifying" ) ) break ; team team = getteam ( teams , values [ 1 ] ) ; team . stats . put ( stat . name , double . parsedouble ( values [ columnindex ] ) ) ; j += 1 ; } } } } } return teams ; }
tr	10	@ suppresswarnings ( "deprecation" ) public static string invokeget ( string url , map < string , string > params , string encode , int connecttimeout , int sotimeout ) { string responsestring = null ; requestconfig requestconfig = requestconfig . custom ( ) . setsockettimeout ( connecttimeout ) . setconnecttimeout ( connecttimeout ) . setconnectionrequesttimeout ( connecttimeout ) . build ( ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( url ) ; int i = 0 ; for ( entry < string , string > entry : params . entryset ( ) ) { if ( i == 0 && ! url . contains ( "?" ) ) { sb . append ( "?" ) ; } else { sb . append ( "&" ) ; } sb . append ( entry . getkey ( ) ) ; sb . append ( "=" ) ; string value = entry . getvalue ( ) ; try { sb . append ( urlencoder . encode ( value , "utf-8" ) ) ; } catch ( unsupportedencodingexception e ) { logger . info ( "encode http get params error<litcomma> value is " + value + e . getmessage ( ) ) ; sb . append ( urlencoder . encode ( value ) ) ; } i ++ ; } logger . info ( "[httputils get] begin invoke:" + sb . tostring ( ) ) ; httpget get = new httpget ( sb . tostring ( ) ) ; get . setconfig ( requestconfig ) ; try { closeablehttpresponse response = httpclient . execute ( get ) ; try { httpentity entity = response . getentity ( ) ; try { if ( entity != null ) { responsestring = entityutils . tostring ( entity , encode ) ; } } finally { if ( entity != null ) { entity . getcontent ( ) . close ( ) ; } } } catch ( exception e ) { logger . info ( string . format ( "[httputils get]get response error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; return responsestring ; } finally { if ( response != null ) { response . close ( ) ; } } logger . info ( string . format ( "[httputils get]debug url:%s <litcomma> response string %s:" , sb . tostring ( ) , responsestring ) ) ; } catch ( sockettimeoutexception e ) { logger . info ( string . format ( "[httputils get]invoke get timout error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; return responsestring ; } catch ( exception e ) { logger . info ( string . format ( "[httputils get]invoke get error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; } finally { get . releaseconnection ( ) ; } return responsestring ; }
tr	6	@ requestmapping ( applicationconstants . create_chat ) @ responsebody public object createchatroom ( @ requestparam ( "name" ) string name ) { chatroom chatroom = new chatroom ( ) ; map < object , string > errormap = new hashmap < object , string > ( ) ; system . out . println ( "name11111" + name ) ; if ( name == null || "" . equals ( name ) ) { errormap . put ( 1 , "please enter name" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { chatroom . setname ( name ) ; chatroom . setcreateddate ( new date ( ) . tostring ( ) ) ; chatroomdao . createchatroom ( chatroom ) ; return chatroom ; } }
tr	3	public static int getint ( string prompt ) { int ret = 0 ; scanner s = new scanner ( system . in ) ; int input = - 1 ; while ( input == - 1 ) { system . out . println ( prompt ) ; try { input = integer . parseint ( s . nextline ( ) ) ; } catch ( ioerror e ) { system . out . println ( e . getmessage ( ) ) ; } catch ( numberformatexception e ) { system . out . println ( "please input a valid positive integer" ) ; } finally { s . close ( ) ; s = new scanner ( system . in ) ; } } return ret ; }
tr	8	private chessposition getchesspositionfromclick ( mouseevent e ) { chessposition pos = null ; jlabel jl = ( jlabel ) e . getsource ( ) ; if ( jl != null ) { component jc [ ] = board_ui . getcontentpane ( ) . getcomponents ( ) ; for ( int i = 0 ; i < jc . length ; i ++ ) { if ( jc [ i ] == jl ) { try { pos = new chessposition ( ( i / 9 ) - 1 , ( i % 9 ) - 1 ) ; } catch ( chessexception e1 ) { pos = null ; } break ; } } } return pos ; }
tr	6	public login ( ) { if ( usuario == null ) { usuario = "" ; } while ( usuario . length ( ) == 0 ) { joptionpane . showmessagedialog ( null , "usu\xe1rio inv\xe1lido!" ) ; usuario = joptionpane . showinputdialog ( "nome de usu\xe1rio:\\n" ) ; if ( usuario == null ) { usuario = "" ; } } if ( usuario . equals ( antigouser ) ) { joptionpane . showmessagedialog ( null , "bem vindo de volta<litcomma> " + usuario + ( "!" ) ) ; } else if ( ! usuario . equals ( antigouser ) && ! usuario . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "bem vindo<litcomma> " + usuario + "!" ) ; } gui . label2 . settext ( "usu\xe1rio: " + login . usuario ) ; gui . label3 . settext ( "total do caixa: r$" + dadosgerais . placassaida . size ( ) * 5 + "<litcomma>00" ) ; lastlogin lastlogin = new lastlogin ( ) ; salvardb salvardb = new salvardb ( ) ; gui . frame . requestfocus ( ) ; }
tr	4	@ suppresswarnings ( "rawtypes" ) private void construirvo ( class clase ) { field [ ] atributos = clase . getdeclaredfields ( ) ; clasevo clasevo = new clasevo ( ) ; clasevo . setnombreentity ( clase . getsimplename ( ) ) ; clasevo . setnombrevo ( cambionombreentitytovo ( clase . getsimplename ( ) ) ) ; for ( int i = 0 ; i < atributos . length ; i ++ ) { field atributo = atributos [ i ] ; if ( ! estaenlistanegraatributos ( atributo . getname ( ) ) ) { atributovo atributovo = getdeficinionatributovo ( atributo ) ; clasevo . setatributo ( atributovo ) ; } } vos . add ( clasevo ) ; system . out . println ( "generando " + clasevo . getnombrevo ( ) + " " + clasevo . getatributos ( ) . size ( ) + " atributos" ) ; clasevo . setpaquetecontenedororigen ( paqueteentidades ) ; clasevo . setgenerartostringvos ( isgenerartostringvos ) ; clasevo . imprimirconstantescampos ( ) ; if ( isgenerarvos ) { clasevo . grabararchivodeclasejava ( paquetecodigogenerado , getpatharchivosgenerados ( ) ) ; } if ( ishelpervobetweenentity ) { contenidohelpervoentity . append ( clasevo . generarcontenidoarchivohelpervo ( paquetecodigogenerado ) ) ; } system . out . println ( nl + "" + nl ) ; }
tr	3	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; system . out . print ( "please enter the public key number(n):" ) ; long input_n = sc . nextlong ( ) ; system . out . println ( ) ; system . out . print ( "please enter the public key value(e):" ) ; long input_e = sc . nextlong ( ) ; system . out . println ( ) ; bruteforce bf = new bruteforce ( input_n , input_e ) ; key k = bf . bruteforcecrack ( ) ; if ( k == null ) { system . out . println ( "the input key pair in not factorizable" ) ; } else { system . out . println ( "the private key(d<litcomma>m) pair for the input is (" + k . getdecryptkey ( ) + "<litcomma>" + k . getm ( ) + ")" ) ; } while ( true ) { system . out . println ( "please input encrypt number:" ) ; long input = sc . nextlong ( ) ; int letter = ( int ) rsa . modulo ( input , k . getdecryptkey ( ) , input_n ) ; system . out . println ( "decrypt result is:" + letter ) ; system . out . println ( "letter is:" + ( char ) letter ) ; } }
tr	2	public int getsamplerate ( ) { if ( setuppacket == null ) throw new illegalstateexception ( "no setup packet found" ) ; protocol sip = setuppacket . asmap ( ) . get ( "sip" ) ; field body = sip . asmap ( ) . get ( "sip.msg_body" ) ; protocol sdp = body . asprotocolmap ( ) . get ( "sdp" ) ; map < string , integer > sampleratesbymediacode = new hashmap < string , integer > ( ) ; for ( field field : sdp . fields ) { if ( "sdp.media_attr" . equals ( field . name ) && field . asmap ( ) . containskey ( "sdp.sample_rate" ) ) { int samplerate = integer . parseint ( field . asmap ( ) . get ( "sdp.sample_rate" ) . show ) ; string mediacode = field . asmap ( ) . get ( "sdp.media.format" ) . show ; sampleratesbymediacode . put ( mediacode , samplerate ) ; } } rtppacket first = packets . get ( 0 ) ; string mediacode = first . fields . get ( "rtp.p_type" ) . show ; return sampleratesbymediacode . get ( mediacode ) ; }
tr	3	public void run ( ) { try { in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; out = new printwriter ( socket . getoutputstream ( ) ) ; login = in . readline ( ) ; password = in . readline ( ) ; dbconnect dbc = new dbconnect ( ) ; state = dbc . connect ( ) ; resultset result = state . executequery ( "select login from users where login = '" + login + "' and password= '" + password + "'" ) ; if ( ! result . next ( ) ) { idcheck = 0 ; out . print ( idcheck ) ; out . flush ( ) ; } else { idcheck = 1 ; out . println ( idcheck ) ; out . flush ( ) ; string s = "server" ; chatwindow cw = new chatwindow ( socket , s ) ; } } catch ( ioexception e ) { system . out . println ( "error connecting to the server." ) ; } catch ( sqlexception e ) { system . out . println ( "error connecting to the sql server." ) ; } }
tr	4	public void parseargs ( string [ ] args ) { options options = new options ( ) ; for ( option o : jo . options ) { options . addoption ( o ) ; } commandline parser ; try { parser = new gnuparser ( ) . parse ( options , args ) ; } catch ( parseexception e ) { log . info ( "unable to parse options." ) ; return ; } if ( parser . hasoption ( "help" ) || parser . getoptions ( ) . length == 0 ) { new helpformatter ( ) . printhelp ( "jen <args>" , "jenever - a package manager for java" , options , "" ) ; system . exit ( 0 ) ; } else if ( parser . hasoption ( "init" ) ) { handler . checkparamsset ( ) ; } else { handler . checkparamsset ( ) ; handler . handle ( parser ) ; } }
tr	1	public board ( int width , int height ) { this . width = width ; this . height = height ; starfield = new starfield ( this . width , this . height , 50 ) ; addkeylistener ( new tadapter ( ) ) ; setfocusable ( true ) ; setdoublebuffered ( true ) ; setbackground ( color . black ) ; setsize ( width , height ) ; setpreferredsize ( new java . awt . dimension ( width , height ) ) ; setvisible ( true ) ; loadresources ( ) ; resetgame ( ) ; timer = new timer ( 33 , this ) ; timer . start ( ) ; }
tr	7	public static void recursivefilelisting ( arraylist < string > extracted_links , string folder ) throws ioexception { for ( int i = 0 ; i < extracted_links . size ( ) ; i ++ ) { string target = extracted_links . get ( i ) . tostring ( ) ; string new_folder = folder + target ; while ( target . endswith ( "/" ) ) { folders . add ( new_folder ) ; string foldername [ ] = new_folder . split ( "/" ) ; folder ( ( minecraft . getworkingdirectory ( ) + file . separator + new_folder ) , foldername [ foldername . length - 1 ] ) ; recursivefilelisting ( getdirectorylisting ( new_folder ) , new_folder ) ; break ; } if ( ! new_folder . endswith ( "/" ) ) { files . add ( new_folder ) ; rename_files . add ( new_folder ) ; } } }
tr	9	final public void export_to ( cachedir nd , int type , long difftime ) { if ( nd == null ) return ; if ( localdir == null ) return ; long now = system . currenttimemillis ( ) ; for ( cacheobject my : objects . values ( ) ) { cacheobject out ; boolean exp ; exp = false ; switch ( type ) { case garbage . export_all : exp = true ; break ; case garbage . export_lru : if ( now - my . getlru ( ) <= difftime ) { exp = true ; } break ; case garbage . export_date : if ( now - my . getdate ( ) <= difftime ) { exp = true ; } break ; case garbage . export_filedate : if ( now - my . getdate ( ) > difftime ) break ; string ln ; ln = my . getlocalname ( ) ; if ( ln == null || ln . equals ( cacheobject . reserved ) ) break ; if ( now - new file ( localdir + ln ) . lastmodified ( ) <= difftime ) exp = true ; break ; } if ( exp == false ) continue ; if ( ! my . isvalid ( ) ) { system . out . println ( " - " + localdir + my . getlocalname ( ) ) ; continue ; } out = nd . getobject ( my . getname ( ) ) ; out . delete ( ) ; file exp1 , f2 ; exp1 = new file ( localdir , my . getlocalname ( ) ) ; my . setdirectory ( nd ) ; my . regenname ( ) ; f2 = new file ( nd . getlocaldir ( ) , my . getlocalname ( ) ) ; if ( copyfile ( exp1 , f2 ) == false ) { continue ; } my . touch ( ) ; nd . putobject ( my ) ; } }
tr	6	public static void drawstring ( int x , int y , string text ) { int tilesize = 16 ; for ( int i = 0 ; i < text . length ( ) ; ++ i ) { string character = "" + text . charat ( i ) ; texttile tile = alphabetmap . get ( character . touppercase ( ) ) ; if ( tile == null ) { tile = alphabetmap . get ( "?" ) ; } tile . setposition ( i * tilesize , y ) ; tile . draw ( ) ; } }
tr	6	private server ( string name , int port ) throws socketexception { instance = this ; logger = logger . getlogger ( "mcpe_server" ) ; logger . setlevel ( level . all ) ; logger . setuseparenthandlers ( false ) ; for ( handler h : logger . gethandlers ( ) ) logger . removehandler ( h ) ; logger . addhandler ( new handler ( ) { dateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss" ) ; @ override public void publish ( logrecord record ) { level l = record . getlevel ( ) ; printstream out = l . intvalue ( ) > level . info . intvalue ( ) ? system . err : system . out ; out . println ( df . format ( new date ( record . getmillis ( ) ) ) + " [" + record . getloggername ( ) + "]" + "[" + l . getlocalizedname ( ) + "] " + record . getmessage ( ) ) ; } @ override public void flush ( ) { system . out . flush ( ) ; system . err . flush ( ) ; } @ override public void close ( ) throws securityexception { system . out . close ( ) ; system . err . close ( ) ; } } ) ; random = new random ( ) ; serverid = 0x372cdc9e ; servername = name ; servertype = "demo" ; try { pcaplogger = new pcaplogger ( new fileoutputstream ( "packets.pcap" ) ) ; packetlogger = new printstream ( "packets.log" ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } clients = new hashmap < integer , entityplayer > ( ) ; players = new hashmap < string , entityplayer > ( ) ; whitelist = new arraylist < string > ( ) ; banned = new arraylist < string > ( ) ; bannedips = new arraylist < inetaddress > ( ) ; serversocket = new datagramsocket ( port ) ; handler = new packethandler ( ) ; log ( "starting minecraft pe server on " + serversocket . getinetaddress ( ) + ":" + port ) ; }
tr	1	public void unlock ( lamportunlockmessage unlocktype , int ... data ) throws ioexception { system . out . println ( "lamport.unlock()" ) ; state [ bank . getid ( ) ] . set ( lamportmessages . release , localtimestamp ) ; byte [ ] messagedata = state [ bank . getid ( ) ] . tobyte ( bank . getid ( ) ) ; byte [ ] temp = toolbox . buildmessage ( unlocktype . getcode ( ) , data ) ; sendtoallothersbank ( toolbox . concat ( messagedata , temp ) ) ; synchronized ( this ) { hasmutex = false ; } }
tr	8	public void generate ( land [ ] [ ] world ) { int width = world . length ; int depth = world [ 0 ] . length ; int centerx = width / 2 ; int centerz = depth / 2 ; float maxdist = ( float ) math . sqrt ( ( centerx ) * ( centerx ) + ( centerz ) * ( centerz ) ) ; system . out . println ( maxdist ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < depth ; j ++ ) { float grad = 1 - ( ( float ) math . sqrt ( ( i - centerx ) * ( i - centerx ) + ( j - centerz ) * ( j - centerz ) ) / maxdist ) ; grad *= grad * grad * grad * 3 ; world [ i ] [ j ] . height *= grad ; } } }
tr	4	public void makemove ( chessposition from , chessposition to ) throws chessexception { if ( ( from == null ) || ( to == null ) ) throw new chessexception ( "invalid position to move from or move to" ) ; chesspiece p = board [ from . getrow ( ) ] [ from . getcol ( ) ] ; if ( p == null ) throw new chessexception ( "no piece to move at origin" ) ; chesspiece t = board [ to . getrow ( ) ] [ to . getcol ( ) ] ; if ( t != null ) t . capture ( ) ; p . makemove ( this , to ) ; board [ from . getrow ( ) ] [ from . getcol ( ) ] = null ; board [ to . getrow ( ) ] [ to . getcol ( ) ] = p ; }
tr	7	private string plurality ( list < instance > examples ) { map < string , integer > scores = new linkedhashmap < string , integer > ( ) ; for ( instance instance : examples ) { integer score = scores . get ( instance . label ) ; if ( score == null ) { score = 0 ; } scores . put ( instance . label , score + 1 ) ; } if ( scores . isempty ( ) ) { return "1" ; } else if ( scores . size ( ) == 1 ) { return scores . keyset ( ) . iterator ( ) . next ( ) ; } else { int winningscore = integer . min_value ; string winner = null ; for ( string label : scores . keyset ( ) ) { if ( ! label . equals ( winner ) ) { int score = scores . get ( label ) ; if ( winningscore == score ) { if ( label . comparetoignorecase ( winner ) < 0 ) { winner = label ; } } else if ( winningscore < score ) { winner = label ; winningscore = score ; } } } return winner ; } }
tr	1	public object maprow ( resultset rs , int rownum ) throws sqlexception { ledger ledger = new ledger ( ) ; ledger . setid ( rs . getint ( "id" ) ) ; ledger . setreceiptdate ( rs . getdate ( "rcv_dt" ) ) ; ledger . setmembername ( rs . getstring ( "mbr_nm" ) ) ; ledger . setchecknumber ( rs . getstring ( "chk_nbr" ) ) ; ledger . setcheckdate ( rs . getdate ( "chk_dt" ) ) ; ledger . setpaymenttype ( rs . getstring ( "pymt_typ" ) ) ; ledger . setdepositamount ( rs . getdouble ( "dpst_amt" ) ) ; ledger . setpaymentamount ( rs . getdouble ( "pymt_amt" ) ) ; ledger . setcomments ( rs . getstring ( "comments" ) ) ; return ledger ; }
tr	9	private map < string , list < string > > decodeparameters ( string querystring ) { map < string , list < string > > parms = new hashmap < string , list < string > > ( ) ; if ( querystring != null ) { stringtokenizer st = new stringtokenizer ( querystring , "&" ) ; while ( st . hasmoretokens ( ) ) { string e = st . nexttoken ( ) ; int sep = e . indexof ( '=' ) ; string propertyname = ( sep >= 0 ) ? decodepercent ( e . substring ( 0 , sep ) ) . trim ( ) : decodepercent ( e ) . trim ( ) ; if ( ! parms . containskey ( propertyname ) ) { parms . put ( propertyname , new arraylist < string > ( ) ) ; } string propertyvalue = ( sep >= 0 ) ? decodepercent ( e . substring ( sep + 1 ) ) : null ; if ( propertyvalue != null ) { parms . get ( propertyname ) . add ( propertyvalue ) ; } } } return parms ; }
tr	2	protected void from_net ( string header , string host , int port , string path ) throws exception { log . info ( "new socked (host<litcomma> port):" + host + ":" + port + "\\n" ) ; socket requestsocket = new socket ( host , port ) ; log . info ( "request header: \\n" + header ) ; requestsocket . getoutputstream ( ) . write ( header . getbytes ( "ascii" ) ) ; inputstream responseis = requestsocket . getinputstream ( ) ; try { arraylist < byte > arraylist = new arraylist ( 2048 ) ; int buf ; while ( ( buf = responseis . read ( ) ) != - 1 ) { arraylist . add ( ( byte ) buf ) ; if ( 13 == buf ) { buf = responseis . read ( ) ; arraylist . add ( ( byte ) buf ) ; if ( 10 == buf ) { buf = responseis . read ( ) ; arraylist . add ( ( byte ) buf ) ; if ( 13 == buf ) { buf = responseis . read ( ) ; arraylist . add ( ( byte ) buf ) ; if ( 10 == buf ) { break ; } } } } } byte [ ] resposebheader = new byte [ arraylist . size ( ) ] ; for ( int i = 0 ; i < arraylist . size ( ) ; i ++ ) { resposebheader [ i ] = arraylist . get ( i ) ; } string responseheader = new string ( resposebheader , "ascii" ) ; log . info ( "response header\\n" + responseheader ) ; os . write ( resposebheader ) ; if ( responseheader . startswith ( "http/1.0 304 not modified" ) || responseheader . startswith ( "http/1.0 302 moved temporarily" ) ) { log . info ( "302 or 304" ) ; return ; } string [ ] requestheaders = responseheader . split ( "\\\\n" ) ; long contentlength = 0 ; for ( string requestheader1 : requestheaders ) { if ( requestheader1 . startswith ( "content-length:" ) ) { log . info ( requestheader1 ) ; string cl = requestheader1 . substring ( requestheader1 . indexof ( ":" ) + 1 ) . trim ( ) ; log . info ( cl ) ; contentlength = long . parselong ( cl ) ; break ; } } log . info ( "content length: " + contentlength ) ; if ( contentlength != 0 ) { for ( long i = 0 ; i < contentlength ; i ++ ) { os . write ( responseis . read ( ) ) ; } } else { byte reply [ ] = new byte [ 1024 ] ; int bytes_read ; while ( ( bytes_read = responseis . read ( reply ) ) != - 1 ) { os . write ( reply , 0 , bytes_read ) ; } } } catch ( sockettimeoutexception e ) { log . error ( e . getmessage ( ) , e ) ; } finally { responseis . close ( ) ; requestsocket . close ( ) ; } }
tr	9	public void apresentar ( livraria livraria ) { int acumulado = 0 ; int max ; list < topvendidos > listatop = null ; list < topvendidos > listatopgeral = null ; boolean contem ; for ( venda v : this . listadevendas ) { acumulado += v . total_geral ( ) ; for ( produtovendido p : v . getprodutos ( ) ) { if ( listatop == null ) { listatop . add ( new topvendidos ( p . codigo ( ) , p . getqtde ( ) ) ) ; } else { contem = false ; for ( topvendidos tp : listatop ) { if ( tp . getcod ( ) == p . codigo ( ) ) { tp . aumentaqtde ( p . getqtde ( ) ) ; contem = true ; } } if ( ! contem ) { listatop . add ( new topvendidos ( p . codigo ( ) , p . getqtde ( ) ) ) ; } } } } while ( ! listatop . isempty ( ) ) { max = 0 ; for ( topvendidos tp : listatop ) { if ( tp . getqtde ( ) > max ) { max = tp . getqtde ( ) ; } } for ( topvendidos tp : listatop ) { if ( tp . getqtde ( ) == max ) { listatopgeral . add ( tp ) ; listatop . remove ( tp ) ; } } } for ( int i = 0 ; i <= 4 ; i ++ ) { livraria . descritor ( listatopgeral . get ( i ) . getcod ( ) ) . imprimir ( ) ; } }
tr	6	public static double algorithmlist ( list < string > wordlist , int times_file , string searchterm , int snippetlength ) throws ioexception { stopwatch timer = new stopwatch ( ) ; for ( int i = 0 ; i < times_file ; i ++ ) { bufferedreader br = new bufferedreader ( new filereader ( filename ) ) ; string line = null ; while ( ( line = br . readline ( ) ) != null ) { for ( string word : line . split ( "[-!~\\\\s]+" ) ) { wordlist . add ( word ) ; } } } int position = 0 ; int results = 0 ; for ( string word : wordlist ) { if ( word . equals ( searchterm ) ) { stringbuilder temp = new stringbuilder ( ) ; for ( int i = ( position - snippetlength ) ; i < ( position + snippetlength + 1 ) ; i ++ ) { temp . append ( wordlist . get ( i ) ) ; temp . append ( " " ) ; } results ++ ; } position ++ ; } return timer . elapsedtime ( ) ; }
tr	10	private final float applymod ( float f , string mod ) { if ( mod == null ) return f ; float m ; try { m = float . valueof ( mod . substring ( 1 ) ) . floatvalue ( ) ; } catch ( numberformatexception z ) { system . out . println ( "[gc_config_error] invalid number in lru modifier '" + mod + "'" ) ; throw z ; } switch ( mod . charat ( 0 ) ) { case '+' : f += m ; break ; case '-' : f -= m ; break ; case '*' : f *= m ; break ; case '/' : f /= m ; break ; case '=' : if ( f >= m ) f = refage_max - 1 ; break ; default : system . out . println ( "[gc_config_error] invalid action in lru modifier '" + mod + "'" ) ; throw new illegalargumentexception ( "unknown action " + mod . charat ( 0 ) ) ; } return f ; }
tr	6	public static void printfrequencies ( list < frequency > frequencies ) { int tottwogrmcnt = 0 ; boolean istwogram = false ; for ( frequency frequency : frequencies ) { tottwogrmcnt += frequency . getfrequency ( ) ; if ( frequency . gettext ( ) . split ( " " ) . length > 1 ) istwogram = true ; } if ( istwogram ) { system . out . println ( "total 2-gram count: " + tottwogrmcnt ) ; system . out . println ( "unique 2-gram count: " + frequencies . size ( ) ) ; } else { system . out . println ( "total item count: " + tottwogrmcnt ) ; system . out . println ( "unique item count: " + frequencies . size ( ) ) ; } system . out . println ( ) ; for ( frequency frequency : frequencies ) { system . out . println ( frequency . tostring ( ) ) ; } system . out . println ( ) ; system . out . println ( "===============" ) ; system . out . println ( ) ; }
tr	5	@ override public group next ( ) { if ( filereader == null ) { throw new unsupportedoperationexception ( ) ; } if ( currentpost == null ) { if ( ! hasnext ( ) ) { return null ; } readnextentry ( ) ; } integer currentgroupid = currentpost . getgroupid ( ) ; group group = new group ( currentgroupid ) ; while ( readnextentry ( ) != null && currentpost . getgroupid ( ) == currentgroupid ) { group . add ( currentpost ) ; } if ( group . isempty ( ) ) { return null ; } return group ; }
tr	3	@ override public void exec ( string channel , string sender , string commandname , string [ ] args , string login , string hostname , string message ) { string fmlmessage = "" ; try { url url = new url ( "http://rscript.org/lookup.php?type=fml" ) ; bufferedreader breader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; while ( ( fmlmessage = breader . readline ( ) ) != null ) { if ( fmlmessage . startswith ( "text: " ) ) { fmlmessage = fmlmessage . replace ( "text: " , "" ) ; break ; } } } catch ( ioexception ex ) { if ( ex . getmessage ( ) . contains ( "503" ) ) { this . bot . sendmessage ( channel , "error: 503" ) ; } if ( ex . getmessage ( ) . contains ( "404" ) ) { this . bot . sendmessage ( channel , "error: 503" ) ; } } this . bot . sendmessage ( channel , "[fml] " + fmlmessage ) ; }
tr	2	@ override public void construct ( object ... data ) { try { out . writebyte ( ( byte ) data [ 0 ] ) ; out . writelong ( ( long ) data [ 1 ] ) ; out . writelong ( server . serverid ) ; out . write ( constants . raknet_magic ) ; utils . writestring ( "mccpp;" + server . servertype + ";" + server . servername + " [" + server . clients . size ( ) + "/" + server . maxclients + "]" , out ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	8	private static int test ( int [ ] n , long i ) { if ( i == 1 ) return 0 ; if ( i >= 1000000 ) { if ( i % 2 == 0 ) return test ( n , i / 2 ) + 1 ; return test ( n , 3 * i + 1 ) + 1 ; } if ( n [ ( int ) i ] > 0 ) return n [ ( int ) i ] ; if ( i % 2 == 0 ) { n [ ( int ) i ] = test ( n , i / 2 ) + 1 ; return n [ ( int ) i ] ; } else { n [ ( int ) i ] = test ( n , 3 * i + 1 ) + 1 ; return n [ ( int ) i ] ; } }
tr	2	private string obtemidentificador ( httpservletrequest req ) throws recursosemidentificadorexception { string requesturi = req . getrequesturi ( ) ; string [ ] pedacosdauri = requesturi . split ( "/" ) ; boolean contextocervejasencontrado = false ; for ( string contexto : pedacosdauri ) { if ( contexto . equals ( "cervejas" ) ) { contextocervejasencontrado = true ; continue ; } if ( contextocervejasencontrado ) { try { return urldecoder . decode ( contexto , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return urldecoder . decode ( contexto ) ; } } } throw new recursosemidentificadorexception ( "recurso sem identificador" ) ; }
tr	5	private static treemap < string , integer > locationdistribution ( user ua ) { treemap < string , integer > freq = new treemap < string , integer > ( ) ; for ( record r : ua . records ) { if ( freq . containskey ( r . gps ( ) ) ) { int tmp = freq . get ( r . gps ( ) ) ; freq . put ( r . gps ( ) , tmp + 1 ) ; } else { freq . put ( r . gps ( ) , 1 ) ; } } return freq ; }
tr	3	public static void main ( string [ ] args ) throws ioexception , interruptedexception { string searchterm = null ; int snippetlength = 2 ; if ( args . length > 1 ) { searchterm = args [ 0 ] ; if ( integer . parseint ( args [ 1 ] ) >= 0 ) snippetlength = integer . parseint ( args [ 1 ] ) ; } else { system . out . println ( "not enough arguments entered! usage: search term<litcomma> snippet " ) ; return ; } system . err . println ( ">warning!!<litcomma> results not 'trustworthy'" ) ; system . out . println ( ">>vector" ) ; for ( int i = 0 ; i < run_times ; i ++ ) { double processtime = algorithmlist ( new vector < string > ( ) , 2 ^ i , searchterm , snippetlength ) ; system . out . println ( ( 2 ^ i ) + "\\t" + processtime ) ; } }
tr	4	public void open ( ) { if ( this . isopen == true ) { return ; } this . isopen = true ; try { display . create ( ) ; display . setfullscreen ( this . fullscreen ) ; display . settitle ( this . title ) ; display . setdisplaymode ( new displaymode ( this . width , this . height ) ) ; for ( drawable drawer : drawers ) { drawer . setup ( ) ; } while ( this . isopen ) { for ( drawable drawer : drawers ) { drawer . draw ( ) ; } display . update ( ) ; display . sync ( this . maxfps ) ; this . isopen = ! display . iscloserequested ( ) ; } for ( drawable drawer : drawers ) { drawer . destroy ( ) ; } this . close ( ) ; } catch ( lwjglexception ex ) { logger . getlogger ( window . class . getname ( ) ) . log ( level . severe , null , ex ) ; system . exit ( 1 ) ; } }
tr	2	@ test ( enabled = true ) public void eraseindexrepository ( ) { try { solrquery params = new solrquery ( ) ; params . set ( "q" , "*:*" ) ; params . setrows ( 100 ) ; queryresponse response = server . query ( params ) ; for ( solrdocument doc : response . getresults ( ) ) { system . out . println ( doc . getfieldvalue ( "id" ) ) ; } server . setsotimeout ( 3600000 ) ; server . setconnectiontimeout ( 3600000 ) ; server . deletebyquery ( "*:*" ) ; server . commit ( ) ; } catch ( solrserverexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( ioexception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
tr	4	public static inventory frombase64 ( string data ) { bytearrayinputstream inputstream = new bytearrayinputstream ( base64coder . decodelines ( data ) ) ; nbttaglist itemlist = ( nbttaglist ) nbtbase . a ( new datainputstream ( inputstream ) ) ; inventory inventory = new craftinventorycustom ( null , itemlist . size ( ) ) ; for ( int i = 0 ; i < itemlist . size ( ) ; i ++ ) { nbttagcompound inputobject = ( nbttagcompound ) itemlist . get ( i ) ; if ( ! inputobject . isempty ( ) ) { inventory . setitem ( i , craftitemstack . ascraftmirror ( net . minecraft . server . v1_6_r3 . itemstack . createstack ( inputobject ) ) ) ; } } return inventory ; }
tr	4	@ override public boolean izbaci ( arraylist list , string nazivspremista ) { if ( list . isempty ( ) ) { system . out . println ( "datoteka prevelika za spremiste" ) ; return true ; } else { najstariji = new date ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { r = ( resource ) list . get ( i ) ; d = r . getvrijemespremanja ( ) ; if ( d . compareto ( najstariji ) < 0 && r . isspremljen ( ) ) { najstariji = d ; najr = r ; } } obrisi ( najr , nazivspremista ) ; return false ; } }
tr	9	public void download ( jprogressbar | , file destination ) { thread t = new thread ( ( ) -> { int downloaded = 0 ; list < imgurimage > images = getimages ( ) ; for ( imgurimage i : images ) { i . download ( destination ) ; downloaded ++ ; int perc = ( int ) ( ( ( ( double ) downloaded ) / images . size ( ) ) * 100 ) ; | . setvalue ( perc ) ; if ( perc == 100 ) gui . get ( ) . notifyfinished ( ) ; } } ) ; t . start ( ) ; }
tr	8	public list < string > print ( ) { string header = "columnnames   s[t]ack        " ; for ( int i = 1 ; i <= num_columns ; i ++ ) { header += "[" + i + "] " ; } for ( char s : suit . getvalidinputs ( ) ) { header += "[" + s + "] " ; } string separator = "" ; for ( int i = 0 ; i < header . length ( ) ; i ++ ) { separator += "-" ; } string topdrawstackvalue = drawstack . size ( ) > 0 ? drawstack . get ( topdrawstackindex ) . getvalue ( ) : blank_card ; string firstrow = first_row_buffer + topdrawstackvalue + first_row_draw_stack_buffer ; firstrow += getcolumnsslice ( 0 ) ; for ( char s : suit . getvalidinputs ( ) ) { firstrow += " " ; if ( discardpiles . containskey ( string . valueof ( s ) ) ) { firstrow += discardpiles . get ( string . valueof ( s ) ) . getvalue ( ) ; } else { firstrow += blank_card ; } } list < string > morerows = new arraylist < > ( ) ; int longestcolumn = longestcolumnlength ( ) ; for ( int i = 1 ; i < longestcolumn ; i ++ ) { string thisrow = later_row_buffer ; thisrow += getcolumnsslice ( i ) ; morerows . add ( thisrow ) ; } list < string > output = new arraylist < > ( ) ; output . add ( header ) ; output . add ( separator ) ; output . add ( firstrow ) ; for ( string row : morerows ) { output . add ( row ) ; } return output ; }
tr	8	int onreceiverequest ( status status , movemessage m ) { int index = - 1 ; int hand [ ] = m . state . hand ; int their_card = m . state . card ; sort ( hand ) ; if ( m . state . total_tricks == 0 && m . state . in_challenge == false && m . state . card > 0 && wintime < 9 ) { double prob = 0.6 + ( hand [ 2 ] - 10 ) * 0.2 ; if ( prob > math . random ( ) ) return 9999 ; } if ( their_card <= 0 ) { if ( wintime == 1 && losetime == 1 && tiedtime == 0 ) { return hand . length - 1 ; } if ( totaltime == 0 ) { int idx = - 1 ; for ( int i = 0 ; i < hand . length ; i ++ ) { if ( hand [ i ] < 10 ) { idx = i ; break ; } } index = 2 > idx ? 2 : idx ; } else if ( totaltime == 1 ) { index = 2 ; } else { index = secondbigger ( hand ) ; } if ( tiedtime == 0 ) { if ( wintime == 1 && losetime == 2 ) index = 0 ; } else { if ( losetime >= 1 ) index = 0 ; } } else { theirlastcard = their_card ; if ( ( m . state . card > hand [ hand . length - 1 ] ) && ( ( m . state . card - hand [ hand . length - 1 ] ) > 6 ) ) { index = hand . length - 1 ; } else if ( ( findcard ( hand , m . state . card ) == hand . length - 1 || findcard ( hand , m . state . card ) == hand . length - 2 ) && ( m . state . card <= 4 ) ) { index = findcard ( hand , m . state . card ) ; } else { index = minbigger ( hand , m . state . card ) ; } } mylastcard = hand [ index ] ; if ( index >= hand . length ) { system . err . println ( "w:" + wintime + " l:" + losetime + " t:" + tiedtime ) ; system . err . println ( "hand: " ) ; for ( int x : hand ) { system . err . print ( x + " " ) ; } system . err . println ( "\\nindex:" + index + "\\n" ) ; return 0 ; } return index ; }
tr	10	private hashmap < string , hashset < string > > scramble ( string s ) { hashmap < string , hashset < string > > res = new hashmap < string , hashset < string > > ( ) ; if ( s . length ( ) == 0 ) return res ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string curr = s . substring ( i , i + 1 ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; path . add ( curr ) ; res . put ( curr , path ) ; } } for ( int x = 2 ; x <= s . length ( ) ; x ++ ) { for ( int i = 0 ; i <= s . length ( ) - x ; i ++ ) { string curr = s . substring ( i , i + x ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; for ( int k = 1 ; k < curr . length ( ) ; k ++ ) { hashset < string > left = res . get ( curr . substring ( 0 , k ) ) ; hashset < string > right = res . get ( curr . substring ( k , curr . length ( ) ) ) ; for ( string l : left ) { for ( string r : right ) { if ( ! path . contains ( l + r ) ) path . add ( l + r ) ; if ( ! path . contains ( r + l ) ) path . add ( r + l ) ; } } } res . put ( curr , path ) ; } } } return res ; }
tr	5	@ test public void randomizeddividetest ( ) { for ( int i = 1 ; i <= tests_amount * tests_enabled ; i ++ ) { biginteger a = new biginteger ( tests_multiplier * i , r ) ; biginteger b = new biginteger ( tests_multiplier * i , r ) ; unsignedbigint c = new unsignedbigint ( a . tostring ( ) ) ; unsignedbigint d = new unsignedbigint ( b . tostring ( ) ) ; biginteger biresult [ ] = a . divideandremainder ( b ) ; unsignedbigint ubiresult [ ] = c . divideandremainder ( d ) ; asserttrue ( "quotient mismatch: was " + ubiresult [ 0 ] . tostring ( ) + "<litcomma> expected " + biresult [ 0 ] . tostring ( ) , biresult [ 0 ] . tostring ( ) . equals ( ubiresult [ 0 ] . tostring ( ) ) ) ; asserttrue ( "remainder mismatch: was " + ubiresult [ 1 ] . tostring ( ) + "<litcomma> expected " + biresult [ 1 ] . tostring ( ) , biresult [ 1 ] . tostring ( ) . equals ( ubiresult [ 1 ] . tostring ( ) ) ) ; } }
tr	7	protected boolean createkeystorage ( ) throws mojoexecutionexception { getlog ( ) . info ( "creating key storage..." ) ; getlog ( ) . info ( "key storage: " + getkeystorage ( ) ) ; keytoolargumentsbuilder argumentsbuilder = new keytoolargumentsbuilder ( getkeystorage ( ) . getfile ( ) , getcertificate ( ) . getpassword ( ) , getcertificate ( ) . getauthor ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > keystoragecallable = new callable < void > ( ) { @ override public void call ( ) throws exception { keytool . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean keystoragecreationsuccessful = executor . execute ( keystoragecallable ) == 0 && getkeystorage ( ) . getfile ( ) . exists ( ) ; if ( ! keystoragecreationsuccessful ) { throw new mojoexecutionexception ( "failed to create a key storage. path: " + getkeystorage ( ) . getfile ( ) . getpath ( ) ) ; } getlog ( ) . info ( "key storage successfully created." ) ; return keystoragecreationsuccessful ; }
tr	7	@ override public void actionperformed ( actionevent e ) { date loopstart = new date ( ) ; dologic ( ) ; repaint ( ) ; date loopend = new date ( ) ; if ( gameticks . size ( ) < 30 ) { gameticks . add ( loopend . gettime ( ) - loopstart . gettime ( ) ) ; } else { long total = new long ( 0l ) ; for ( long one : gameticks ) { total += one ; } system . out . println ( "game tick averages at about: " + ( total / gameticks . size ( ) ) + " milliseconds" ) ; gameticks . clear ( ) ; } }
tr	6	protected void popcontextesifneeded ( ) { if ( popcontextonnextpausecounter > 1 ) { log . debug ( "there are {} to pop from the stack" , popcontextonnextpausecounter ) ; } for ( int i = 0 ; i < popcontextonnextpausecounter ; i ++ ) { if ( ! contextes . isempty ( ) ) { conversationcontext < ? > ccpopped = contextes . pop ( ) ; log . debug ( "popped 1 context from stack: {}" , ccpopped . getlabel ( ) ) ; } else { log . warn ( "attention<litcomma> too many pop requested! could be source of potential bug" ) ; } } popcontextonnextpausecounter = 0 ; if ( contextes . isempty ( ) ) { log . info ( "all contextes have been popped. natural conversation ending will be performed" ) ; } }
tr	4	public void displaytreasurechestnearby ( grid grid ) { system . out . println ( "results" ) ; if ( grid != null ) { treasurechest [ ] [ ] treasurechestgrid = grid . gettreasurechest ( ) ; int rows = grid . getrows ( ) ; int cols = grid . getcolumns ( ) ; for ( int row = 0 ; row < rows ; row ++ ) { stringbuilder result = new stringbuilder ( ) ; for ( int col = 0 ; col < cols ; col ++ ) { int counter = 0 ; counter = checktreasurechestsnearby ( row , col , rows , cols , counter , treasurechestgrid ) ; result . append ( counter ) ; } system . out . println ( result . tostring ( ) ) ; } } }
tr	4	public void addtodatabase ( string s ) { try { for ( int i = 1 ; i <= this . mainpanel . getnum ( ) ; i ++ ) { this . cons . mysql . update ( "insert into tbl_admissions " + "(type<litcomma> month<litcomma> day<litcomma> year<litcomma> z<litcomma> date) values " + "('" + s + "'<litcomma> " + this . cons . mysql . getmonth ( ) + "<litcomma> " + this . cons . mysql . getday ( ) + "<litcomma> " + this . cons . mysql . getyear ( ) + "<litcomma> 0" + "<litcomma> curdate())" ) ; } } catch ( exception ex ) { this . mainpanel . errorlabel . setvisible ( true ) ; } }
tr	6	public boolean optimize ( final int numsteps , final double convergencedelta ) throws invalidconfigurationexception { if ( ! configured ) { configure ( ) ; } final int deltanumsteps = numsteps / 10 ; final genotype population = genotype . randominitialgenotype ( configuration ) ; final boolean converged ; int timesfitnessstable = 0 ; double previousfitness = - 1 ; progresslogger . expectedupdates = numsteps ; progresslogger . start ( "optimization" ) ; ichromosome fitestchromosome = null ; double fitness = - 2 ; for ( int i = 0 ; i < numsteps ; i ++ ) { fitestchromosome = population . getfittestchromosome ( ) ; fitness = fitnessfunction . getfitnessvalue ( fitestchromosome ) ; fitestfunctionvalue = fitness ; if ( i % moduloprogressreport == 1 ) { log . info ( "current solution has a fitness value of " + formatdouble ( math . log ( fitestchromosome . getfitnessvalue ( ) ) ) + " absolute: " + formatdouble ( math . log ( fitness ) ) + "or raw: " + fitness ) ; log . debug ( fitestchromosome . getgene ( 0 ) . tostring ( ) ) ; } if ( fitness >= previousfitness && fitness - previousfitness < math . abs ( convergencedelta ) ) { timesfitnessstable ++ ; log . trace ( "fitness function value stable " + timesfitnessstable ) ; } else { timesfitnessstable = 0 ; log . trace ( "fitness function not stable<litcomma> old: " + previousfitness + " new fitness: " + fitness ) ; } previousfitness = fitness ; if ( timesfitnessstable >= deltanumsteps ) { break ; } numberofiterationsperformed = i ; if ( i != numsteps - 1 ) { population . evolve ( ) ; progresslogger . lightupdate ( ) ; } } if ( fitness - previousfitness < math . abs ( convergencedelta ) ) { converged = true ; } else { converged = false ; } progresslogger . stop ( "optimization" ) ; convertfittesttosolution ( fitestchromosome ) ; return converged ; }
tr	1	private void acceptreceive ( lamportstate state , datagrampacket data ) throws ioexception { int remotebankid = state . remotebankid ; localtimestamp = math . max ( localtimestamp , state . timestamp ) + 1 ; switch ( state . type ) { case new_account : break ; case request : this . state [ remotebankid ] . set ( lamportmessages . request , state . timestamp ) ; lamportstate data2send = new lamportstate ( lamportmessages . receipt , localtimestamp ) ; send ( remotebankid , data2send . tobyte ( bank . getid ( ) ) ) ; break ; case release : this . state [ remotebankid ] . set ( lamportmessages . release , state . timestamp ) ; if ( state . type == lamportmessages . release && data . getlength ( ) >= 9 ) { byte code = data . getdata ( ) [ 9 ] ; int [ ] releasedata = toolbox . builddata ( data . getdata ( ) , data . getlength ( ) - 9 , 9 ) ; lamportunlockmessage lum = lamportunlockmessage . fromcode ( code ) ; switch ( lum ) { case delete_account : bank . handleondelete ( releasedata [ 0 ] ) ; break ; case update_money : bank . handleonupdate ( releasedata [ 0 ] , releasedata [ 1 ] ) ; break ; default : system . err . println ( "lamportrelease: non implementee" ) ; break ; } } break ; case receipt : if ( this . state [ remotebankid ] . type != lamportmessages . request ) { this . state [ remotebankid ] . set ( lamportmessages . receipt , state . timestamp ) ; } break ; } synchronized ( this ) { hasmutex = ( this . state [ bank . getid ( ) ] . type == lamportmessages . request ) && localaccesgranted ( ) ; if ( debug ) { system . out . println ( "lamport.acceptreceive()" ) ; } if ( hasmutex ) { if ( debug ) system . out . println ( "notify() sur la banque " + bank . getid ( ) ) ; notify ( ) ; } } }
tr	3	public mainframe ( ) { double lx = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) . getwidth ( ) ; double ly = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) . getheight ( ) ; frame . setlocation ( new point ( ( int ) ( lx / 2 ) - 150 , ( int ) ( ly / 2 ) - 150 ) ) ; frame . setsize ( 480 , 370 ) ; frame . setresizable ( false ) ; image icon = toolkit . getdefaulttoolkit ( ) . getimage ( "" ) ; frame . seticonimage ( icon ) ; frame . setcontentpane ( tabpane ) ; about . addactionlistener ( this ) ; help . add ( about ) ; menubar . add ( help ) ; frame . setjmenubar ( menubar ) ; frame . setvisible ( true ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; autodeploymentframe autodeployment = new autodeploymentframe ( ) ; tabpane . add ( "\u81ea\u52a8\u5316\u53d1\u5e03" , autodeployment . autodeploymentframe ( ) ) ; applogviewframe logview = new applogviewframe ( ) ; tabpane . add ( "\u65e5\u5fd7\u622a\u53d6" , logview . applogviewframe ( ) ) ; }
tr	1	public static lamportstate frombyte ( byte [ ] data , int length ) { assert ( length >= 9 ) ; lamportstate state = new lamportstate ( ) ; state . type = lamportmessages . fromcode ( data [ 0 ] ) ; byte [ ] tempint = new byte [ 4 ] ; for ( int i = 0 ; i < tempint . length ; i ++ ) { tempint [ i ] = data [ i + 1 ] ; } state . timestamp = toolbox . byte2int ( tempint ) ; tempint = new byte [ 4 ] ; for ( int i = 0 ; i < tempint . length ; i ++ ) { tempint [ i ] = data [ i + 5 ] ; } state . remotebankid = toolbox . byte2int ( tempint ) ; return state ; }
tr	7	static public final char [ ] rlestringtochararray ( string s ) { int length = ( ( ( int ) s . charat ( 0 ) ) << 16 ) | ( ( int ) s . charat ( 1 ) ) ; char [ ] array = new char [ length ] ; int ai = 0 ; for ( int i = 2 ; i < s . length ( ) ; ++ i ) { char c = s . charat ( i ) ; if ( c == escape ) { c = s . charat ( ++ i ) ; if ( c == escape ) { array [ ai ++ ] = c ; } else { int runlength = ( int ) c ; char runvalue = s . charat ( ++ i ) ; for ( int j = 0 ; j < runlength ; ++ j ) array [ ai ++ ] = runvalue ; } } else { array [ ai ++ ] = c ; } } if ( ai != length ) throw new illegalstateexception ( "bad run-length encoded short array" ) ; return array ; }
tr	2	public void setup ( ) { size ( 1280 , 520 ) ; kinect = new kinect ( this ) ; kinect . start ( ) ; kinect . enabledepth ( depth ) ; kinect . enablergb ( rgb ) ; int h = kinect . getvideoimage ( ) . height ; int w = kinect . getvideoimage ( ) . width ; int hd = kinect . getdepthimage ( ) . height ; int wd = kinect . getdepthimage ( ) . width ; system . out . println ( "h:" + h + " w:" + w + " hd:" + hd + " wd:" + wd ) ; }
tr	10	public static void main ( string [ ] args ) { int x = 2 ; int y = 17 ; int z = power ( x , y ) ; system . out . println ( z ) ; x = 3 ; y = 18 ; int sisa = 0 , base = x , s = 0 ; list < integer > list = new arraylist < integer > ( ) ; while ( y > 1 ) { ++ s ; if ( y % 2 == 1 ) { list . add ( x ) ; } x *= x ; y >>= 1 ; } for ( int i : list ) { x *= i ; ++ s ; } system . out . println ( "total step : " + s ) ; system . out . println ( x ) ; }
tr	6	public boolean download ( file out ) { try { url url = new url ( imageurl . startswith ( "http://" ) ? imageurl : "http://" + imageurl ) ; inputstream is = new bufferedinputstream ( url . openstream ( ) ) ; outputstream os = new bufferedoutputstream ( new fileoutputstream ( out + "/" + getname ( ) ) ) ; for ( int i ; ( i = is . read ( ) ) != - 1 ; ) os . write ( i ) ; is . close ( ) ; os . close ( ) ; return true ; } catch ( exception e ) { e . printstacktrace ( ) ; } return false ; }
tr	1	private void prune ( dataset tune ) { double originalaccuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( root instanceof internaldectreenode ) { internaldectreenode nodetoprune = null , parentnodetoprune = null ; double maxaccuracy = originalaccuracy ; internaldectreenode savedinternalnode = ( internaldectreenode ) root ; leafdectreenode prunedleafnode = new leafdectreenode ( savedinternalnode . label , savedinternalnode . parentattributevalue ) ; root = prunedleafnode ; double accuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( accuracy >= maxaccuracy ) { maxaccuracy = accuracy ; nodetoprune = ( internaldectreenode ) savedinternalnode ; } root = savedinternalnode ; queue < internaldectreenode > queue = new linkedlist < internaldectreenode > ( ) ; queue . add ( ( internaldectreenode ) root ) ; while ( ! queue . isempty ( ) ) { internaldectreenode internalnode = queue . remove ( ) ; for ( int i = 0 ; i < internalnode . children . size ( ) ; i ++ ) { dectreenode child = internalnode . children . get ( i ) ; if ( child instanceof internaldectreenode ) { savedinternalnode = ( internaldectreenode ) child ; prunedleafnode = new leafdectreenode ( savedinternalnode . label , savedinternalnode . parentattributevalue ) ; internalnode . removechild ( child ) ; internalnode . addchild ( prunedleafnode ) ; accuracy = calctestaccuracy ( tune , classify ( tune ) ) ; if ( accuracy >= maxaccuracy ) { maxaccuracy = accuracy ; nodetoprune = savedinternalnode ; parentnodetoprune = internalnode ; } internalnode . removechild ( prunedleafnode ) ; internalnode . returnchild ( i , child ) ; queue . add ( savedinternalnode ) ; } } } if ( nodetoprune != null && maxaccuracy > originalaccuracy ) { if ( parentnodetoprune != null ) { parentnodetoprune . removechild ( nodetoprune ) ; parentnodetoprune . addchild ( new leafdectreenode ( nodetoprune . label , nodetoprune . parentattributevalue ) ) ; prune ( tune ) ; } else { root = new leafdectreenode ( nodetoprune . label , nodetoprune . parentattributevalue ) ; } } } }
tr	10	protected static boolean deletable ( int numvar , int pattern , int prefix ) { if ( numvar == 0 ) { int curposition = reversedigit ( totalvar , 2 , prefix ) ; if ( kmap [ curposition ] == boolx . x ) return numlayer [ curposition ] > 0 ; return numlayer [ curposition ] > 1 ; } switch ( pattern % 3 ) { case 0 : return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ; case 1 : return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; default : if ( ! deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ) return false ; return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; } }
tr	1	private void handleobjectcollisions ( ) { for ( rock rock : rocks ) { if ( rock . getbounds ( ) . isinside ( ship . getbounds ( ) ) ) { gamestate = 2 ; break ; } for ( bullet bullet : bullets ) { if ( rock . getbounds ( ) . isinside ( bullet . getbounds ( ) ) ) { rocks . remove ( rock ) ; bullets . remove ( bullet ) ; explosions . add ( new explosion ( rock . getx ( ) , rock . gety ( ) , rock . getwidth ( ) ) ) ; helper . playsoundfrombytearray ( explosionsound ) ; score += 50 ; handleobjectcollisions ( ) ; return ; } } } }
tr	6	public static void main ( string [ ] args ) { dataset dataset = null ; try { if ( args . length == 0 || args . length % 2 == 1 ) printusage ( ) ; url url = null ; string archiveid = null ; string itemid = null ; string tdb = null ; string file = null ; try { for ( int i = 0 ; i < args . length ; i = i + 2 ) { if ( args [ i ] . equals ( "-u" ) || args [ i ] . equals ( "--url" ) ) url = new url ( args [ i + 1 ] ) ; else if ( args [ i ] . equals ( "-a" ) || args [ i ] . equals ( "--archiveid" ) ) archiveid = args [ i + 1 ] ; else if ( args [ i ] . equals ( "-i" ) || args [ i ] . equals ( "--itemid" ) ) itemid = args [ i + 1 ] ; else if ( args [ i ] . equals ( "-t" ) || args [ i ] . equals ( "--tdb" ) ) tdb = args [ i + 1 ] ; else if ( args [ i ] . equals ( "-f" ) || args [ i ] . equals ( "--file" ) ) file = args [ i + 1 ] ; else throw new exception ( "illegal option" ) ; } } catch ( exception e ) { printusage ( ) ; } if ( ( url != null && ( archiveid != null || itemid != null ) ) || ( url == null && ( archiveid == null || itemid == null ) ) ) printusage ( ) ; if ( archiveid != null ) if ( ! sourcemanager . containsrepository ( archiveid ) ) { log . error ( "for <archiveid> select one of:" ) ; sourcemanager . printarchivelist ( ) ; return ; } else { url = new url ( baseuri + archiveid + "-" + itemid ) ; } if ( file != null ) try { file f = new file ( file ) ; if ( f . exists ( ) ) { log . error ( "the <file> " + file + " already exists" ) ; return ; } } catch ( exception e ) { log . error ( "error creating file " + file , e ) ; printusage ( ) ; } if ( tdb != null ) try { dataset = tdb . endswith ( ".ttl" ) ? tdbfactory . assembledataset ( tdb ) : tdbfactory . createdataset ( tdb ) ; } catch ( exception e ) { log . error ( "error creating tdb store " + tdb , e ) ; printusage ( ) ; } log . info ( "requesting " + url ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setinstancefollowredirects ( false ) ; if ( connection . getresponsecode ( ) == httpurlconnection . http_ok ) { log . info ( "status ok: " + connection . getresponsecode ( ) ) ; } else { log . error ( connection . getresponsecode ( ) + ": failed to fetch content for url " + url ) ; system . exit ( - 1 ) ; } log . info ( "parsing content" ) ; documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; factory . setnamespaceaware ( false ) ; factory . setvalidating ( false ) ; factory . setfeature ( "http://xml.org/sax/features/namespaces" , false ) ; factory . setfeature ( "http://xml.org/sax/features/validation" , false ) ; factory . setfeature ( "http://apache.org/xml/features/nonvalidating/load-dtd-grammar" , false ) ; factory . setfeature ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ; inputstream is = connection . getinputstream ( ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; int next = is . read ( ) ; while ( next > - 1 ) { bos . write ( next ) ; next = is . read ( ) ; } bos . flush ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; document document = builder . parse ( new inputsource ( new stringreader ( new string ( bos . tobytearray ( ) ) . replaceall ( "&" , "&amp;" ) ) ) ) ; log . info ( "extracting information" ) ; map < string , string > contentitems = informationretriever . extractfrom ( document ) ; log . info ( "building rdf data" ) ; if ( dataset != null ) { log . info ( "writing rdf data to tdb " + tdb ) ; rdfbuilder . createontmodel ( url , contentitems , dataset ) . close ( ) ; dataset . close ( ) ; } ontmodel model = null ; if ( file != null || dataset == null ) model = rdfbuilder . createontmodel ( url , contentitems , null ) ; if ( file != null ) { filewriter filewriter = null ; try { log . info ( "writing rdf data to file " + file ) ; filewriter = new filewriter ( file ) ; model . write ( filewriter , "n3" ) ; } catch ( exception e ) { log . error ( "error creating file" , e ) ; printusage ( ) ; } finally { try { if ( file != null ) filewriter . close ( ) ; } catch ( exception ignore ) { } } } if ( file == null && dataset == null ) model . write ( system . out , "n3" ) ; if ( model != null ) model . close ( ) ; log . info ( "done" ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( saxexception e ) { e . printstacktrace ( ) ; } catch ( parserconfigurationexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } finally { if ( dataset != null ) dataset . close ( ) ; } }
tr	8	private void showresultset ( ) { int i = 0 ; for ( result result : resultset ) { if ( result . isrealtype ( ) == result . ispredicttype ( ) ) { i ++ ; } } double sucrate = math . floor ( ( ( i * 1.0f ) / resultset . size ( ) ) * 100.0f ) / 100.0 ; nbcmain . listlogs . removeall ( ) ; nbcmain . listlogs . add ( "algorithm result" ) ; nbcmain . listlogs . add ( "-----------------------------------------" ) ; nbcmain . listlogs . add ( "successful prediction: " + sucrate ) ; nbcmain . listlogs . add ( "unsuccessful prediction: " + math . round ( ( 1 - sucrate ) * 100.0f ) / 100.0 ) ; nbcmain . listlogs . add ( "-----------------------------------------" ) ; for ( result result : resultset ) { nbcmain . listlogs . add ( result . getname ( ) + " - " + result . isrealtype ( ) + " -> " + result . ispredicttype ( ) ) ; } }
tr	4	public static objectbounds parsefromfile ( url fileurl ) { try { arraylist < point > points = new arraylist < point > ( ) ; bufferedreader breader = new bufferedreader ( new inputstreamreader ( fileurl . openstream ( ) ) ) ; string filecontent = breader . readline ( ) ; string [ ] rawpoints = filecontent . split ( "\\\\|" ) ; for ( string rawpoint : rawpoints ) { string [ ] splittedpoint = rawpoint . split ( "<litcomma>" ) ; int x = integer . parseint ( splittedpoint [ 0 ] ) ; int y = integer . parseint ( splittedpoint [ 1 ] ) ; points . add ( new point ( x , y ) ) ; } breader . close ( ) ; return new objectbounds ( points ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } return null ; }
tr	7	public arraylist < arraylist < integer > > combinationsum ( int [ ] candidates , int target ) { arraylist < arraylist < integer > > results = new arraylist < arraylist < integer > > ( ) ; for ( int i = 0 ; i < candidates . length ; i ++ ) { } hashset < string > unique = new hashset < string > ( ) ; for ( int i = results . size ( ) - 1 ; i >= 0 ; i -- ) { string converted = results . get ( i ) . tostring ( ) ; if ( unique . contains ( converted ) ) { results . remove ( i ) ; } else { unique . add ( converted ) ; } } return results ; }
tr	8	private static string median ( list < string > numberslist ) { string result = null ; if ( numberslist . size ( ) % 2 == 0 ) { int middle = numberslist . size ( ) / 2 ; int middleright = integer . parseint ( numberslist . get ( middle ) ) ; int middleleft = integer . parseint ( numberslist . get ( middle - 1 ) ) ; result = integer . tostring ( ( middleright + middleleft ) / 2 ) ; } else { result = numberslist . get ( numberslist . size ( ) / 2 ) ; } return result ; }
tr	10	@ override public void run ( ) { randomaccessfile file = null ; inputstream inputstream = null ; try { url url = new url ( fileurl ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setrequestproperty ( range_property , string . format ( "bytes=%d-" , downloadbytescounter ) ) ; connection . connect ( ) ; int responsecode = connection . getresponsecode ( ) ; if ( responsecode / 100 != 2 || ( contentsize = connection . getcontentlength ( ) ) < 1 ) { throw new downloadmanagerexception ( string . format ( "invalid remote resource initialization!." + "response code: %d<litcomma> content size: %d" , responsecode , contentsize ) ) ; } downloadstatus = downloadmanager . downloadstatus . downloading ; file = new randomaccessfile ( downloadmanagerutils . getfilenamefromurl ( url ) , access_mode ) ; file . seek ( downloadbytescounter ) ; inputstream = connection . getinputstream ( ) ; while ( downloadstatus == downloadmanager . downloadstatus . downloading ) { byte buffer [ ] ; int sizeleft ; if ( ( sizeleft = contentsize - downloadbytescounter ) > max_buffer_size ) { buffer = new byte [ max_buffer_size ] ; } else { buffer = new byte [ sizeleft ] ; } int read = inputstream . read ( buffer ) ; if ( read == - 1 ) { break ; } downloadbytescounter += read ; file . write ( buffer , 0 , read ) ; } downloadstatus = downloadmanager . downloadstatus . downloaded ; } catch ( malformedurlexception e ) { throw new downloadmanagerexception ( "invalid file url! can not creates uri instance." ) ; } catch ( ioexception e ) { throw new downloadmanagerexception ( "exception during file downloading!" , e ) ; } finally { if ( file != null ) { try { file . close ( ) ; } catch ( ioexception e ) { } } if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { } } } }
tr	7	public string createcontent ( ) { stringbuilder httpresponse = new stringbuilder ( ) ; httpresponse . append ( " <h2> <p>number of all requset: " + serverstatus . gettotalrequest ( ) + " </p> </h2>" ) ; httpresponse . append ( " <h2> <p>number of active connections: " + serverstatus . getactiveconnection ( ) + " </p> </h2>" ) ; httpresponse . append ( " <h2> <p>number of unique request : " + managerdb . getubiquerequestlist ( ) . size ( ) + " </p> </h2>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>ip</th>  <th>count of request</th>  <th>time lsat request</th> </tr>" ) ; list < requests > allrequest = managerdb . getiprequestlist ( ) ; for ( requests request : allrequest ) { httpresponse . append ( " <tr> <td>" + request . getip ( ) + "</td>  <td>" + request . getrequestcount ( ) + "</td>  <td>" + request . gettimelastrequest ( ) + "</td> </tr>" ) ; } httpresponse . append ( " </table>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>url</th>  <th>count of redirect</th>  </tr>" ) ; list < redirects > allredirect = managerdb . getredirectlist ( ) ; for ( redirects request : allredirect ) { httpresponse . append ( " <tr> <td>" + request . geturl ( ) + "</td>  <td>" + request . getamountredir ( ) + "</td>  </tr>" ) ; } httpresponse . append ( " </table>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>src_ip</th>  <th>uri</th>  <th>timestamp</th>  <th>sent_bytes</th>  <th>received_bytes</th>   <th>speed</th>  </tr>" ) ; list < connection > allconnectrequest = managerdb . getconnectionlist ( ) ; int first = allconnectrequest . size ( ) ; if ( first < 16 ) { first = 0 ; } else { first -= 16 ; } for ( int i = first ; i < allconnectrequest . size ( ) ; i ++ ) { connection request = allconnectrequest . get ( i ) ; httpresponse . append ( " <tr> <td>" + request . getsrcip ( ) + "</td>  <td>" + request . geturi ( ) + "</td>   <td>" + request . gettimestamp ( ) + "</td>   " + "  <td>" + request . getsentbytes ( ) + "</td>  <td>" + request . getreceivedbytes ( ) + "</td>  <td>" + request . getspeed ( ) + "</td> </tr>" ) ; } httpresponse . append ( " </table>" ) ; return httpresponse . tostring ( ) ; }
tr	6	private static string getcolumnvalue ( resultset rs , int coltype , int colindex ) throws sqlexception , ioexception { string value = "" ; switch ( coltype ) { case types . bit : object bit = rs . getobject ( colindex ) ; if ( bit != null ) { value = string . valueof ( bit ) ; } break ; case types . boolean : boolean b = rs . getboolean ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = boolean . valueof ( b ) . tostring ( ) ; } break ; case types . clob : clob c = rs . getclob ( colindex ) ; if ( c != null ) { value = read ( c ) ; } break ; case types . bigint : case types . decimal : case types . double : case types . float : case types . real : case types . numeric : bigdecimal bd = rs . getbigdecimal ( colindex ) ; if ( bd != null ) { value = "" + bd . doublevalue ( ) ; } break ; case types . integer : case types . tinyint : case types . smallint : int intvalue = rs . getint ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = "" + intvalue ; } break ; case types . java_object : object obj = rs . getobject ( colindex ) ; if ( obj != null ) { value = string . valueof ( obj ) ; } break ; case types . date : java . sql . date date = rs . getdate ( colindex ) ; if ( date != null ) { value = date_formatter . format ( date ) ; ; } break ; case types . time : time t = rs . gettime ( colindex ) ; if ( t != null ) { value = t . tostring ( ) ; } break ; case types . timestamp : timestamp tstamp = rs . gettimestamp ( colindex ) ; if ( tstamp != null ) { value = timestamp_formatter . format ( tstamp ) ; } break ; case types . longvarchar : case types . varchar : case types . char : value = rs . getstring ( colindex ) ; break ; default : value = "" ; } if ( value == null ) { value = "" ; } return value ; }
tr	1	public void reload ( ) throws filenotfoundexception { main . reloadconfig ( ) ; main . bancommands . clear ( ) ; main . blacklist . clear ( ) ; main . white . clear ( ) ; if ( main . getconfig ( ) . getboolean ( "config.usebanlist" , true ) ) { scanner s = new scanner ( banlist ) ; while ( s . hasnextline ( ) ) { main . bancommands . add ( s . nextline ( ) ) ; } s . close ( ) ; } scanner s = new scanner ( list ) ; scanner s2 = new scanner ( whitelist ) ; while ( s . hasnextline ( ) ) { main . blacklist . add ( s . nextline ( ) ) ; } while ( s2 . hasnextline ( ) ) { main . white . add ( s2 . nextline ( ) ) ; } s . close ( ) ; s2 . close ( ) ; }
tr	1	private float [ ] makepoints ( float [ ] loc , float rotation ) { float cos = helper . cos ( rotation ) ; float sin = helper . sin ( rotation ) ; float [ ] pts = new float [ 8 ] ; pts [ 0 ] = loc [ 0 ] - width / 2 * sin ; pts [ 1 ] = loc [ 1 ] + width / 2 * cos ; pts [ 2 ] = pts [ 0 ] + hieght * cos ; pts [ 3 ] = pts [ 1 ] + hieght * sin ; pts [ 4 ] = pts [ 2 ] + width * sin ; pts [ 5 ] = pts [ 3 ] - width * cos ; pts [ 6 ] = pts [ 4 ] - hieght * cos ; pts [ 7 ] = pts [ 5 ] - hieght * sin ; return pts ; }
tr	5	public tournament ( round firstround , hashtable < string , compiledstat > compiledstats , referee scoreable ) { if ( md5 == null ) { try { md5 = messagedigest . getinstance ( "md5" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } } this . compiledstats = compiledstats ; this . scoreable = scoreable ; round duplicate = new round ( ) ; for ( game game : firstround ) { game dupegame = new game ( game . teams , scoreable ) ; dupegame . name = game . name ; duplicate . add ( dupegame ) ; } rounds . add ( duplicate ) ; appendnextround ( duplicate ) ; }
tr	3	public message getmessage ( ) throws exception { string jsonmessage = "" ; try { int payloadlen = reader . readint ( ) ; byte [ ] jsonarr = new byte [ payloadlen ] ; if ( reader . read ( jsonarr ) < 1 ) { throw new exception ( "server response was truncated" ) ; } jsonmessage = new string ( jsonarr ) ; } catch ( exception e ) { system . err . println ( "error reading response from server: " + e . tostring ( ) ) ; throw e ; } message message = messagefactory . getservermessage ( jsonmessage ) ; return message ; }
tr	5	public void runprocess ( options opts , string [ ] args , commandlineparser parser ) { try { cl = process ( searchopts , args , parser ) ; } catch ( parseexception e ) { system . out . println ( "error on compile/parse command: " + e . getmessage ( ) ) ; printhelp ( opts ) ; system . exit ( - 1 ) ; } option [ ] allopts = cl . getoptions ( ) ; option opt = null ; for ( int i = 0 ; i < allopts . length ; i ++ ) { opt = allopts [ i ] ; if ( "h" . equals ( opt . getopt ( ) ) ) { printhelp ( opts ) ; system . exit ( 0 ) ; } system . out . println ( "option name: -" + opt . getopt ( ) + "<litcomma> and value = " + getoptvalues ( opt . getopt ( ) , "<litcomma>" ) ) ; } }
tr	1	private void transmitfolder ( string path ) throws exception { file fileordir = new file ( path ) ; dataoutputstream dos = new dataoutputstream ( socket . getoutputstream ( ) ) ; string absolutepath = fileordir . getabsolutepath ( ) ; if ( fileordir . isdirectory ( ) ) { dos . writeutf ( "folder" ) ; dos . writeutf ( fileordir . getname ( ) ) ; dos . writeint ( fileordir . list ( ) . length ) ; system . out . println ( "folder" ) ; system . out . println ( fileordir . getname ( ) ) ; system . out . println ( fileordir . list ( ) . length ) ; for ( string s : fileordir . list ( ) ) { transmitfolder ( absolutepath + file . separator + s ) ; } } else { if ( configurations . isvalidextension ( fileordir . getname ( ) ) && configurations . isvalidsize ( fileordir . length ( ) ) ) { transmitfile ( path ) ; } else joptionpane . showmessagedialog ( null , "this file named " + fileordir . getname ( ) + " is not allowed. send another file" ) ; } }
tr	9	public hashmap < string , double > postionscore ( hashmap < string , hashmap < string , result > > resultsetmap , hashmap < string , double > score_map , string [ ] query_words , hashmap < string , double > query_map ) { if ( query_words . length != 2 ) return null ; hashmap < string , result > temp_map = null ; hashmap < string , result > temp_map2 = null ; temp_map = resultsetmap . get ( query_words [ 0 ] ) ; iterator < string > it = temp_map . keyset ( ) . iterator ( ) ; system . out . println ( "map: " + resultsetmap . tostring ( ) ) ; temp_map2 = resultsetmap . get ( query_words [ 1 ] ) ; result pos_res = null ; int pos_score = 1 ; int scale_factor = 1 ; while ( it . hasnext ( ) ) { string url = it . next ( ) ; if ( ( url . contains ( query_words [ 0 ] ) ) && ( url . contains ( query_words [ 1 ] ) ) ) { score_map . put ( url , ( score_map . get ( url ) ) + ( score_map . get ( url ) * weight ) ) ; continue ; } if ( url . contains ( query_words [ 0 ] ) ) { score_map . put ( url , ( score_map . get ( url ) ) + ( score_map . get ( url ) * weight ) ) ; continue ; } if ( url . contains ( query_words [ 1 ] ) ) { score_map . put ( url , ( score_map . get ( url ) + ( score_map . get ( url ) * weight ) ) ) ; continue ; } if ( temp_map2 . containskey ( url ) ) { string pos1 = temp_map . get ( url ) . pos ; string pos2 = temp_map2 . get ( url ) . pos ; linkedlist < integer > pos_list1 = get_list_from_string ( pos1 ) ; linkedlist < integer > pos_list2 = get_list_from_string ( pos2 ) ; for ( int i = 0 ; i < pos_list1 . size ( ) ; i ++ ) { int num = pos_list1 . get ( i ) + 1 ; if ( pos_list2 . contains ( num ) ) { pos_score += 1 ; } } scale_factor = 1 ; double score = score_map . get ( url ) ; score = score * ( 1 + math . log10 ( pos_score ) ) * scale_factor ; score_map . put ( url , score ) ; } } it = temp_map2 . keyset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { string url2 = it . next ( ) ; if ( url2 . contains ( query_words [ 1 ] ) ) { score_map . put ( url2 , ( score_map . get ( url2 ) ) + ( score_map . get ( url2 ) * weight ) ) ; } if ( url2 . contains ( query_words [ 1 ] ) && url2 . contains ( query_words [ 0 ] ) ) { score_map . put ( url2 , ( score_map . get ( url2 ) ) + ( score_map . get ( url2 ) * weight ) ) ; } } return score_map ; }
tr	2	public byte [ ] tobyte ( int bankid ) { byte [ ] data = new byte [ 1 + 4 + 4 ] ; data [ 0 ] = type . getcode ( ) ; byte [ ] temp = toolbox . int2byte ( timestamp ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { data [ 1 + i ] = temp [ i ] ; } temp = toolbox . int2byte ( bankid ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { data [ 5 + i ] = temp [ i ] ; } return data ; }
tr	7	public string tostring ( ) { string output ; output = " -------------------\\n" ; for ( int cx = 0 ; cx < 6 ; cx ++ ) { output += 6 - cx ; output += "|" ; for ( int cy = 0 ; cy < 6 ; cy ++ ) { if ( board [ cx ] [ cy ] == null ) { output += "  |" ; } else { output += board [ cx ] [ cy ] . tostring ( ) + "|" ; } } output += "\\n" ; output += " -------------------\\n" ; } output += "  a  b  c  d  e  f\\n" ; return output ; }
tr	9	public static packet construct ( datagrampacket packet ) { byte [ ] data = packet . getdata ( ) ; if ( data . length == 0 ) { server . warning ( "empty packet from " + packet . getaddress ( ) + ":" + packet . getport ( ) ) ; return null ; } class < ? extends packet > clazz = classes [ ( ( int ) data [ 0 ] ) & 0xff ] ; if ( clazz == null ) { server . warning ( string . format ( "invalid packet id 0x%02x from %s:%d" , ( ( int ) data [ 0 ] ) & 0xff , packet . getaddress ( ) , packet . getport ( ) ) ) ; return null ; } try { constructor < ? extends packet > constructor = clazz . getconstructor ( inetaddress . class , int . class , byte [ ] . class ) ; packet p = constructor . newinstance ( packet . getaddress ( ) , packet . getport ( ) , data ) ; if ( ! ( p instanceof packetpayload || p instanceof packetack ) ) server . debug ( "recieved " + p ) ; return p ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	10	final public static boolean checkinetadr ( byte [ ] adr ) { if ( httpreq . allowed == null ) return true ; nextadres : for ( int i = httpreq . allowed . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < adr . length ; j ++ ) { if ( ( adr [ j ] & httpreq . allowedmask [ i ] [ j ] ) != httpreq . allowed [ i ] [ j ] ) continue nextadres ; } return true ; } return false ; }
tr	6	private void initagents ( ) { agents = new vector < agent > ( ) ; for ( int a = 0 ; a < numagents ; a ++ ) { agents . add ( new agent ( this ) ) ; } for ( int a = 0 ; a < agents . size ( ) ; a ++ ) { int x = 0 ; int y = 0 ; boolean free = false ; while ( ! free ) { x = gen . nextint ( xsize ) ; y = gen . nextint ( ysize ) ; free = ( grid [ x ] [ y ] . getagent ( ) == null ) ; } agent agent = agents . elementat ( a ) ; agent . setposition ( x , y ) ; grid [ x ] [ y ] . setagent ( agent ) ; } }
tr	5	public static string createconcept ( string name , conceptdatatype datatype , conceptclass conceptclass , list < string > setmembers ) throws jsonexception { jsonobject jsonobject = new jsonobject ( ) ; jsonobject . append ( "names" , new jsonobject ( ) . put ( "name" , name ) . put ( "locale" , "en" ) . put ( "conceptnametype" , "fully_specified" ) ) . put ( "datatype" , datatype ) . put ( "conceptclass" , conceptclass ) ; if ( setmembers == null || setmembers . size ( ) < 1 ) return jsonobject . tostring ( ) ; jsonobject . put ( "set" , true ) . put ( "setmembers" , setmembers ) ; return jsonobject . tostring ( ) ; }
tr	9	public static int decodefrombeginning ( int num , int len ) { stringbuilder sb = new stringbuilder ( ) ; int res , pow , topow ; while ( num != 0 ) { if ( len - 2 > 0 ) topow = len - 2 ; else if ( len - 1 > 0 ) topow = len - 1 ; else topow = 0 ; pow = ( int ) math . pow ( 10 , topow ) ; res = ( int ) num / pow ; if ( res < 26 ) { num -= ( res * pow ) ; res -= 1 ; res += 97 ; sb . append ( ( char ) res ) ; if ( pow != 1 ) len -= 2 ; else len -= 1 ; } } system . out . println ( sb . tostring ( ) ) ; if ( sb . length ( ) > 0 ) return 1 ; else return 0 ; }
tr	6	protected void handleoutofsynchcontext ( string ccid , httpservletrequest request ) throws unexpectedconversationexception { conversationcontext < ? > requestedcontext = null ; for ( conversationcontext < ? > ctx : contextes ) { if ( requestedcontext == null ) { if ( ctx . getid ( ) . equals ( ccid ) ) { requestedcontext = ctx ; } } else { incrementpopcontextonnextpausecounter ( ) ; } } if ( requestedcontext != null ) { popcontextesifneeded ( ) ; } else { throw new unexpectedconversationexception ( "uri not in sync with conversation expecting _ccid_=" + getcurrentcontext ( ) . getid ( ) + " but got " + ccid , request . getrequesturi ( ) , geturl ( ) ) ; } }
tr	9	private static void linq10 ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; string [ ] strings = { "zero" , "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" } ; arrays . stream ( numbers ) . maptoobj ( number -> new hashmap < string , object > ( ) { { put ( "digit" , strings [ number ] ) ; put ( "even" , number % 2 == 0 ) ; } } ) . map ( x -> string . format ( "the digit %s is %s." , x . get ( "digit" ) , x . get ( "even" ) . equals ( boolean . false ) ? "odd" : "even" ) ) . foreach ( system . out :: println ) ; }
tr	1	private boolean isneedtodevelopchildren ( ) { short max = special_values . not_assigned ; short min = special_values . not_assigned ; if ( this . agraphnode . parent == null || this . agraphnode . parent . parent == null ) { return true ; } if ( ( this . agraphnode . depth & 0x01 ) == 0x00 ) { min = getminchildvalue ( this . agraphnode . parent ) ; max = getmaxchildvalue ( this . agraphnode . parent . parent ) ; } else if ( ( this . agraphnode . depth & 0x01 ) == 0x01 ) { max = getmaxchildvalue ( this . agraphnode . parent ) ; min = getminchildvalue ( this . agraphnode . parent . parent ) ; } if ( max == special_values . not_assigned || min == special_values . not_assigned ) return true ; return ! ( max > min ) ; }
tr	10	@ test public void testisole ( ) throws exception { sqlqueries q = new sqlqueries ( ) ; list < aree > aree = q . getaree ( ) ; profiloutente pu = new profiloutente ( ) ; pu . setutenza ( "utenza domestica" ) ; for ( aree a : aree ) { if ( a . getcomune ( ) == null || a . getcomune ( ) . isempty ( ) ) { continue ; } system . err . println ( "======================" ) ; system . err . println ( "checking " + a . getnome ( ) ) ; pu . setaree ( q . getaree ( a . getnome ( ) ) ) ; list < puntiraccolta > list = new sqlqueries ( ) . getpuntidiraccoltapertipopuntoraccolta ( "isola ecologica" , pu ) ; for ( puntiraccolta pr : list ) { assert . asserttrue ( pr . getlocalizzazione ( ) != null && ! pr . getlocalizzazione ( ) . isempty ( ) ) ; } } }
tr	4	private parameter [ ] decodeparams ( final jsonobject jsonobject ) throws jsonexception { final iterator < ? > keys = jsonobject . keys ( ) ; final arraylist < parameter > paramarray = new arraylist < parameter > ( ) ; while ( keys . hasnext ( ) ) { string key = ( string ) keys . next ( ) ; parameter param = decodeparam ( jsonobject . get ( key ) ) ; param . setname ( key ) ; paramarray . add ( param ) ; } final parameter [ ] params = { } ; return paramarray . toarray ( params ) ; }
tr	3	@ test public void test ( ) throws exception { url pdmlurl = rtpextractertest . class . getresource ( "sipcall.pdml" ) ; assert . assertnotnull ( pdmlurl ) ; file [ ] wavefiles = new file [ 2 ] ; for ( int i = 0 ; i < wavefiles . length ; ++ i ) wavefiles [ i ] = file . createtempfile ( opustowaveconvertertest . class . getsimplename ( ) , ".wav" ) ; try { new opustowaveconverter ( ) . convert ( pdmlurl , wavefiles , samplerate . rate_8khz , channels . mono ) ; new opustowaveconverter ( ) . convert ( pdmlurl , wavefiles , null , null ) ; } finally { for ( int i = 0 ; i < wavefiles . length ; ++ i ) wavefiles [ i ] . delete ( ) ; } }
tr	1	private void _buildui ( ) { this . status . setforeground ( color . dark_gray ) ; font font = new font ( "" , font . bold , 14 ) ; this . status . setfont ( font ) ; this . morningafternooncomparebtn . setbackground ( color . dark_gray ) ; this . morningafternooncomparebtn . setforeground ( color . orange ) ; this . checkduplicateblightbtn . setbackground ( color . dark_gray ) ; this . checkduplicateblightbtn . setforeground ( color . orange ) ; this . checkduplicatevtradebtn . setbackground ( color . dark_gray ) ; this . checkduplicatevtradebtn . setforeground ( color . orange ) ; panel p1 = new panel ( new gridlayout ( 1 , 3 ) ) ; p1 . add ( this . morningafternooncomparebtn ) ; p1 . add ( this . checkduplicateblightbtn ) ; p1 . add ( this . checkduplicatevtradebtn ) ; setlayout ( new borderlayout ( ) ) ; add ( this . status , "north" ) ; add ( p1 , "center" ) ; add ( new label ( ) , "south" ) ; add ( new label ( ) , "east" ) ; add ( new label ( ) , "west" ) ; setbackground ( color . orange ) ; }
tr	8	public treenode buildtree ( int [ ] inorder , int [ ] postorder ) { if ( postorder . length == 0 || inorder . length == 0 ) return null ; treenode mid = new treenode ( postorder [ postorder . length - 1 ] ) ; if ( postorder . length == 1 ) return mid ; int midindex = - 1 ; for ( int i = 0 ; i < inorder . length ; i ++ ) { if ( inorder [ i ] == mid . val ) { midindex = i ; break ; } } int [ ] leftinorder = { } , leftpostorder = { } ; if ( midindex > 0 ) { leftinorder = arrays . copyofrange ( inorder , 0 , midindex ) ; leftpostorder = arrays . copyofrange ( postorder , 0 , midindex ) ; } int [ ] rightinorder = { } , rightpostorder = { } ; if ( midindex < inorder . length - 1 ) { rightinorder = arrays . copyofrange ( inorder , midindex + 1 , inorder . length - 1 ) ; rightpostorder = arrays . copyofrange ( postorder , midindex , postorder . length - 2 ) ; } mid . left = buildtree ( leftinorder , leftpostorder ) ; mid . right = buildtree ( rightinorder , rightpostorder ) ; return mid ; }
tr	5	@ override public void reduce ( joinkey key , iterable < avrooutputunion > values , avrocollector < wikititlecategorylink > collector , reporter reporter ) throws ioexception { wikipage wp = null ; wikititlecategorylink wtcl = new wikititlecategorylink ( ) ; for ( avrooutputunion aou : values ) { if ( aou . wp != null ) { assert wp == null ; wp = aou . wp ; } else { if ( wp == null ) { reporter . incrcounter ( getclass ( ) . getsimplename ( ) , "no_page" , 1 ) ; return ; } wtcl . set ( aou . wcl , wp . title ) ; collector . collect ( wtcl ) ; } } }
tr	2	public static void writesinglefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata ) throws ioexception { filewriter fstream = new filewriter ( "combinedwebpages" , true ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) + "^" + url + "^" + path + "^" + parenturl + "^" + title + "^" + h1 + "^" + h2 + "^" + h3 + "^" + bold + "^" + strong + "^" + em + "^" + anchortext + "^" + parseddata ) ; out . newline ( ) ; out . close ( ) ; }
tr	7	public int insertfriends ( long id1 , long id2 ) { int id = - 1 ; string query = "insert ignore into friends" + "(uid1<litcomma> uid2) values" + "(?<litcomma>?)" ; try { preparedstatement = connection . preparestatement ( query , statement . return_generated_keys ) ; preparedstatement . setlong ( 1 , ( id1 < id2 ? id1 : id2 ) ) ; preparedstatement . setlong ( 2 , ( id1 > id2 ? id1 : id2 ) ) ; preparedstatement . executeupdate ( ) ; resultset rs = preparedstatement . getgeneratedkeys ( ) ; if ( rs . next ( ) ) id = rs . getint ( 1 ) ; system . out . println ( "record is inserted into friends table!" ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return id ; }
tr	7	public static void testaddfils ( ) { pere pere = new pere ( "diop" , "flingoooo" ) ; femme femme = new femme ( "sow" , "prenomfemme" ) ; femme femme2 = new femme ( "balde" , "prenomfemme8" ) ; femme femme3 = new femme ( "diallo" , "prenomfemme3" ) ; pere . addfemme ( femme ) ; pere . addfemme ( femme2 ) ; pere . addfemme ( femme3 ) ; fils f = new fils ( "nomfils" , "prenomfils" ) ; fille fille = new fille ( "nomfille" , "prenomfille" ) ; methodesutiles . addfils ( pere , f ) ; methodesutiles . addfille ( pere , fille ) ; list < personne > maliste = new arraylist < personne > ( ) ; maliste = pere . getenfants ( ) ; system . out . println ( " vous etes " + pere . getprenom ( ) + " " + pere . getnom ( ) . touppercase ( ) ) ; system . out . println ( " vous avez en ce moment: " + pere . getfemmes ( ) . size ( ) + " femmes" ) ; if ( maliste . isempty ( ) == false ) { system . out . println ( " vous avez en ce moment: " + maliste . size ( ) + " enfants qui sont: " ) ; for ( int i = 1 ; i <= maliste . size ( ) ; i ++ ) { system . out . println ( "           nom " + maliste . get ( i ) . getnom ( ) + " prenom " + maliste . get ( i ) . getprenom ( ) ) ; } } else { system . out . println ( " vous n'avez aucun enfant!!! " ) ; } }
tr	5	public boolean iscrashed ( snake snake , rabbit rabbit ) { int sp1x , sp1y , sp2x , sp2y , sp3x , sp3y , sp4x , sp4y ; int rp1x , rp1y , rp2x , rp2y , rp3x , rp3y , rp4x , rp4y ; sp1x = snake . getx ( ) ; sp2x = snake . getx ( ) + 45 ; sp3x = snake . getx ( ) ; sp4x = snake . getx ( ) + 45 ; sp1y = snake . gety ( ) ; sp2y = snake . gety ( ) ; sp3y = snake . gety ( ) + 45 ; sp4y = snake . gety ( ) + 45 ; rp1x = rabbit . getx ( ) ; rp2x = rabbit . getx ( ) + 45 ; rp3x = rabbit . getx ( ) ; rp4x = rabbit . getx ( ) + 45 ; rp1y = rabbit . gety ( ) ; rp2y = rabbit . gety ( ) ; rp3y = rabbit . gety ( ) + 45 ; rp4y = rabbit . gety ( ) + 45 ; if ( ( sp1x <= rp4x && sp1x >= rp3x ) && ( sp1y <= rp4y && sp1y >= rp2y ) ) return true ; if ( sp2x >= rp3x && sp2x <= rp4x && sp2y <= rp3y && sp2y >= rp1y ) return true ; if ( sp3x <= rp2x && sp3x >= rp1x && sp3y >= rp2y && sp3y <= rp4y ) return true ; if ( sp4x >= rp1x && sp4x <= rp2x && sp4y >= rp1y && sp4y <= rp3y ) return true ; return false ; }
tr	1	private void initgui ( ) { try { setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; { jpanel2 = new jpanel ( ) ; getcontentpane ( ) . add ( jpanel2 , borderlayout . south ) ; jpanel2 . setpreferredsize ( new java . awt . dimension ( 384 , 66 ) ) ; { jbutton1 = new jbutton ( ) ; jpanel2 . add ( jbutton1 ) ; jbutton1 . settext ( "start server" ) ; jbutton1 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { jbutton1actionperformed ( evt ) ; } } ) ; } } { jpanel1 = new jpanel ( ) ; getcontentpane ( ) . add ( jpanel1 , borderlayout . center ) ; jpanel1 . setpreferredsize ( new java . awt . dimension ( 384 , 130 ) ) ; { jlabel1 = new jlabel ( ) ; jpanel1 . add ( jlabel1 ) ; jlabel1 . settext ( "welcome to the server for javainstantchat" ) ; } } { jpanel3 = new jpanel ( ) ; getcontentpane ( ) . add ( jpanel3 , borderlayout . north ) ; jpanel3 . setpreferredsize ( new java . awt . dimension ( 384 , 42 ) ) ; } pack ( ) ; setsize ( 400 , 300 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	6	@ override public void draw ( long ellapsedtime ) { this . m_parent . rectmode ( this . m_parent . corner ) ; this . m_parent . fill ( 255 , this . m_alpha ) ; this . m_parent . rect ( m_topleft . x , m_topleft . y , this . m_width , this . m_height , 7 ) ; this . m_parent . nostroke ( ) ; this . m_parent . fill ( 0 ) ; this . m_parent . textalign ( this . m_parent . top , this . m_parent . left ) ; this . m_parent . text ( this . m_title , this . m_topleft . x + 30 , this . m_topleft . y + 30 ) ; if ( this . m_messages != null ) { for ( int i = 0 ; i < this . m_messages . length ; i ++ ) { this . m_parent . text ( this . m_messages [ i ] , this . m_topleft . x + 30 , this . m_topleft . y + 30 * ( i + 2 ) ) ; } } }
tr	9	public boolean validatediagonal ( char t , int x , int y ) { int inadiagonal = 0 ; int ox = x ; int oy = y ; while ( x != 0 && y != 0 ) { x -- ; y -- ; } while ( x < size && y < size ) { if ( board [ x ] [ y ] . gettype ( ) == t ) { inadiagonal ++ ; } else { inadiagonal = 0 ; } x ++ ; y ++ ; if ( inadiagonal == tokentowin ) { return true ; } } x = ox ; y = oy ; inadiagonal = 0 ; while ( x != 0 && y != size - 1 ) { x -- ; y ++ ; } while ( x < size && y >= 0 ) { if ( board [ x ] [ y ] . gettype ( ) == t ) { inadiagonal ++ ; } else { inadiagonal = 0 ; } x ++ ; y -- ; if ( inadiagonal == tokentowin ) { return true ; } } return false ; }
tr	10	list < string > getsequence ( ) { list < string > sequence = new arraylist < > ( ) ; list < integer > indicies = new arraylist < > ( operatorboxcount ) ; for ( int i = 0 ; i < operatorboxcount ; ++ i ) { indicies . add ( 0 ) ; } boolean stopflag = false ; while ( true ) { stopflag = true ; for ( int index : indicies ) { stopflag &= index == operators_len - 1 ; } stringbuilder builder = new stringbuilder ( ) ; for ( int index : indicies ) { builder . append ( operators . charat ( index ) ) ; } sequence . add ( builder . tostring ( ) ) ; if ( stopflag ) { break ; } int iix = 0 ; while ( this . operatorboxcount > iix ) { indicies . set ( iix , ( indicies . get ( iix ) + 1 ) % operators_len ) ; if ( indicies . get ( iix ) > 0 ) { break ; } iix ++ ; } } return sequence ; }
tr	4	private static grid creategrid ( scanner scanner ) { grid grid = null ; system . out . println ( "enter a name for your grid :" ) ; string name = getname ( scanner ) ; while ( name == null || name . equals ( "" ) ) { system . out . println ( "please enter a name for your grid :" ) ; name = getname ( scanner ) ; } system . out . println ( "how many rows would you like your grid to have: " ) ; int numrows = getrows ( scanner ) ; while ( numrows < 0 ) { system . out . println ( "please enter a number and ensure its greater than 0 :" ) ; numrows = getrows ( scanner ) ; } system . out . println ( "how many columns would you like :" ) ; int numcols = getcolumns ( scanner ) ; while ( numcols < 0 ) { system . out . println ( "please enter a number and ensure its greater than 0 :" ) ; numcols = getcolumns ( scanner ) ; } grid = new grid ( numrows , numcols ) ; grid . setname ( name ) ; grid . displaygrid ( ) ; return grid ; }
tr	4	public static void main ( string [ ] args ) throws classnotfoundexception { game game1 = new game ( ) ; move currmove ; move enemymove ; system . out . println ( "welcome to knight's watch!!!" ) ; system . out . println ( "waiting for another player to connect..." ) ; string host = args . length > 0 ? args [ 0 ] : default_host ; int port = args . length > 1 ? integer . parseint ( args [ 1 ] ) : default_port ; try { socket socket = new socket ( host , port ) ; objectinputstream socketin = new objectinputstream ( socket . getinputstream ( ) ) ; objectoutputstream socketout = new objectoutputstream ( socket . getoutputstream ( ) ) ; socketout . flush ( ) ; string playernum = ( string ) socketin . readobject ( ) ; system . out . println ( "you are player number : " + playernum ) ; string oppositeplayernum = ( playernum . equals ( "1" ) ) ? "2" : "1" ; system . out . println ( "you are player" + playernum + "<litcomma> your color is: " + ( ( playernum . equals ( "1" ) ) ? "white" : "black" ) ) ; game1 . setcurrplayer ( ( playernum . equals ( "1" ) ) ? colorenum . white : colorenum . black ) ; system . out . println ( game1 . getboard ( ) . tostring ( ) ) ; if ( playernum . equals ( "2" ) ) { system . out . println ( "waiting for player" + oppositeplayernum + " to make his move..." ) ; enemymove = ( move ) socketin . readobject ( ) ; system . out . println ( "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n" ) ; system . out . println ( "enemy has made this move: from " + enemymove . geta ( ) . tostring ( ) + " to " + enemymove . getb ( ) . tostring ( ) ) ; game1 . getboard ( ) . movepiece ( enemymove ) ; system . out . println ( game1 . getboard ( ) . tostring ( ) ) ; } while ( game1 . getstatus ( ) == gamestatus . continue ) { currmove = game1 . makemoveforcurrentplayer ( ) ; game1 . getboard ( ) . movepiece ( currmove ) ; currmove . setresultinggamestatus ( game1 . getstatus ( ) ) ; socketout . writeobject ( currmove ) ; socketout . flush ( ) ; system . out . println ( game1 . getboard ( ) . tostring ( ) ) ; if ( game1 . getstatus ( ) == gamestatus . continue ) { system . out . println ( "waiting for player" + oppositeplayernum + " to make his move..." ) ; enemymove = ( move ) socketin . readobject ( ) ; system . out . println ( "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n" ) ; system . out . println ( "enemy has made this move: from " + enemymove . geta ( ) . tostring ( ) + " to " + enemymove . getb ( ) . tostring ( ) ) ; game1 . getboard ( ) . movepiece ( enemymove ) ; system . out . println ( game1 . getboard ( ) . tostring ( ) ) ; } else { break ; } } system . out . println ( "the game is finished!" ) ; switch ( game1 . getstatus ( ) ) { case whitewins : system . out . println ( "white has won!" ) ; break ; case blackwins : system . out . println ( "black has won!" ) ; break ; case draw : system . out . println ( "it was a draw!" ) ; break ; } } catch ( unknownhostexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	2	private string generarcontenidoclase ( ) { contenidoclase = new stringbuilder ( ) ; contenidoclase . append ( "package " + paquetecontenedordestino + ";\\n" + nl ) ; contenidoclase . append ( nl + "/* clase - autogenerada" ) ; contenidoclase . append ( nl + " * fecha creacion: " + new date ( ) + " */" + nl ) ; contenidoclase . append ( generarimports ( ) ) ; contenidoclase . append ( "public class " + nombrevo + " implements serializable{" + nl ) ; date fechaactual = new date ( ) ; long serialversionuid = fechaactual . gettime ( ) ; contenidoclase . append ( nl + tb + "private static final long serialversionuid = " + serialversionuid + "l;" + nl ) ; contenidoclase . append ( generarbloqueatributos ( ) ) ; contenidoclase . append ( nl + tb + "public " + nombrevo + "(){\\n\\t}" + nl ) ; contenidoclase . append ( generarbloquesettergetters ( ) ) ; contenidoclase . append ( generarmetodotostring ( ) ) ; contenidoclase . append ( nl + "}" ) ; return contenidoclase . tostring ( ) ; }
tr	1	public auroradata loadandconvert ( ) { try { url northhemiurl = new url ( "http://www.swpc.noaa.gov/pmap/gepmap/gepmapn.png" ) ; url southhemiurl = new url ( "http://www.swpc.noaa.gov/pmap/gepmap/gepmaps.png" ) ; imgnorthpx = imageio . read ( northhemiurl ) ; imgsouthpx = imageio . read ( southhemiurl ) ; } catch ( ioexception e ) { } double [ ] [ ] n = manrgbarray ( imgnorthpx , hemisphere . north ) ; double [ ] [ ] s = manrgbarray ( imgsouthpx , hemisphere . south ) ; auroradata data = new auroradata ( ) ; data . setn ( n ) ; data . sets ( s ) ; return data ; }
tr	3	public void migrate ( connection connection ) throws exception { httprequest http = new httprequest ( openmrsdataproperties . getinstance ( ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "chief complaint" , conceptdatatype . text , conceptclass . symptom ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "registration fees" , conceptdatatype . numeric , conceptclass . misc ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "height" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "weight" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "bmi" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "registration_concepts" , conceptdatatype . na , conceptclass . convset , new arraylist < > ( arrays . aslist ( "chief complaint" , "registration fees" , "height" , "weight" , "bmi" ) ) ) ) ; }
tr	5	public optplan ( datastore ds ) { this . ds = ds ; nodes = new arraylist < vertex > ( ) ; edges = new arraylist < edge > ( ) ; int diff ; for ( int i = 0 ; i < ds . nodes ; i ++ ) { vertex lovation = new vertex ( "" + ( i + 1 ) , "nod #" + ( i + 1 ) ) ; nodes . add ( lovation ) ; } for ( int i = 0 ; i < ds . arcs ; i ++ ) { diff = ( int ) math . max ( math . abs ( ds . nodey [ ds . arcstart [ i ] - 1 ] - ds . nodey [ ds . arcend [ i ] - 1 ] ) , math . abs ( ds . nodex [ ds . arcstart [ i ] - 1 ] - ds . nodex [ ds . arcend [ i ] - 1 ] ) ) ; edge lane = new edge ( "" + ( i + 1 ) , nodes . get ( ds . arcstart [ i ] - 1 ) , nodes . get ( ds . arcend [ i ] - 1 ) , diff ) ; edges . add ( lane ) ; } }
tr	3	public void provjerisintaksu ( string [ ] args , model model , view view ) { for ( int i = 0 ; i < args . length ; i ++ ) { stb . append ( args [ i ] ) . append ( " " ) ; } string p = stb . tostring ( ) . trim ( ) ; string sintaksa = "^[^\\\\s]+ ([a-z]\\\\:\\\\\\\\[^\\\\s]+) ([\\\\d]+) ([\\\\d]+)( +-kb)? (-ns|-nk+)( +-clean)?$" ; pattern = pattern . compile ( sintaksa ) ; m = pattern . matcher ( p ) ; status = m . matches ( ) ; if ( status ) { nazivspremista = m . group ( 1 ) ; interval = integer . parseint ( m . group ( 2 ) ) ; ogranicenje = integer . parseint ( m . group ( 3 ) ) ; if ( m . group ( 4 ) == null ) { kb = false ; } else { kb = true ; } if ( m . group ( 5 ) . equals ( "-ns" ) ) { strategija = true ; } else { strategija = false ; } if ( m . group ( 6 ) == null ) { ocisti = false ; } else { ocisti = true ; } dohvatiserializaciju ( ) ; brisispremiste ( ) ; postavicacheuzorak ( ) ; pokrenidretvu ( args , model , view ) ; } else { setchanged ( ) ; notifyobservers ( "sintaksa ne odgovara" ) ; system . exit ( 1 ) ; } }
tr	1	public static void loadconfiguration ( ) { properties configuration = new properties ( ) ; log . consolelog ( "loading configuration file." ) ; try { configuration . load ( new fileinputstream ( configurationfile ) ) ; } catch ( ioexception ex ) { log . consolelog ( "error" , "cannot load configuration file." ) ; ex . printstacktrace ( ) ; return ; } log . consolelog ( "configuration file loaded." ) ; botnickname = configuration . getproperty ( "nickname" ) ; botauthmethod = configuration . getproperty ( "auth_method" ) ; botauthpassword = configuration . getproperty ( "auth_password" ) ; botlogin = configuration . getproperty ( "login" ) ; botversion = configuration . getproperty ( "version" ) ; botfinger = configuration . getproperty ( "finger" ) ; botmessagedelay = integer . parseint ( configuration . getproperty ( "message_delay" ) ) ; botchannels = configuration . getproperty ( "channels" ) . split ( "@" ) ; botautonickchange = boolean . parseboolean ( configuration . getproperty ( "auto_nick_change" ) ) ; botwelcomeusers = boolean . parseboolean ( configuration . getproperty ( "welcome_users" ) ) ; botwelcomemessage = configuration . getproperty ( "welcome_message" ) ; botcommandprefix = configuration . getproperty ( "command_prefix" ) ; usersaccesslist = configuration . getproperty ( "access_list" ) . split ( "@" ) ; usersopaddalias = boolean . parseboolean ( configuration . getproperty ( "op_can_add_alias" ) ) ; usersvoiceaddalias = boolean . parseboolean ( configuration . getproperty ( "voice_can_add_alias" ) ) ; serveraddress = configuration . getproperty ( "server_address" ) ; serverpassword = configuration . getproperty ( "server_password" ) ; serverport = integer . parseint ( configuration . getproperty ( "server_port" ) ) ; devverboseoutput = boolean . parseboolean ( configuration . getproperty ( "output_verbose" ) ) ; devstateversiononjoin = boolean . parseboolean ( configuration . getproperty ( "state_version_on_join" ) ) ; }
tr	2	public void dohvatiserializaciju ( ) { fileinputstream filein ; try { filein = new fileinputstream ( nazivspremista + "\\\\serijalizacija.ser" ) ; postoji = true ; ztintor_zadaca_4 . ser = true ; objectinputstream in ; in = new objectinputstream ( filein ) ; list = ( arraylist ) in . readobject ( ) ; in . close ( ) ; filein . close ( ) ; } catch ( filenotfoundexception ex ) { setchanged ( ) ; notifyobservers ( "ne postoji datoteka serializacije" ) ; postoji = false ; ztintor_zadaca_4 . ser = false ; } catch ( ioexception ex ) { logger . getlogger ( ztintor_zadaca_4 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( ztintor_zadaca_4 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	9	private list < string > getdocumentoearmitoemortodados ( ) { list < string > earmitoemorto = new arraylist < string > ( ) ; for ( int index = 0 ; index < filerel . getcontent ( ) . size ( ) ; index ++ ) { string search = filerel . getcontent ( ) . get ( index ) ; int validador = 0 ; if ( ( search . contains ( "c.marg.agua" ) || search . contains ( "c.marg.agua" ) ) && validador == 0 ) { validador = 1 ; for ( int i = index ; i < index + 9 ; i ++ ) { search = filerel . getcontent ( ) . get ( i ) . trim ( ) ; if ( ! search . isempty ( ) && ( search . contains ( "c.marg.agua" ) || search . contains ( "pat" ) ) ) { earmitoemorto . add ( search ) ; } search = "" ; } } } return earmitoemorto ; }
tr	6	public static string md5 ( inputstream is ) throws ioexception { string md5 = "" ; try { byte [ ] bytes = new byte [ 4096 ] ; int read = 0 ; messagedigest digest = messagedigest . getinstance ( "md5" ) ; while ( ( read = is . read ( bytes ) ) != - 1 ) { digest . update ( bytes , 0 , read ) ; } byte [ ] messagedigest = digest . digest ( ) ; stringbuilder sb = new stringbuilder ( 32 ) ; for ( byte b : messagedigest ) { sb . append ( hexdigits [ ( b > > 4 ) & 0x0f ] ) ; sb . append ( hexdigits [ b & 0x0f ] ) ; } md5 = sb . tostring ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return md5 ; }
tr	7	public static int readint ( int min , int max ) { if ( min > max ) { int tmp = max ; max = min ; min = tmp ; } int n ; do { try { scanner in = new scanner ( system . in ) ; n = in . nextint ( ) ; if ( n >= min && n <= max ) { return n ; } string msg = "veuillez entrer une valeur entre " + min + " et " + max + " > " ; if ( max == integer . max_value ) msg = "veuillez entrer une valeur superieur a " + min + " > " ; system . out . print ( msg ) ; } catch ( exception e ) { system . out . println ( "erreur de saisie" ) ; } } while ( true ) ; }
tr	5	@ override public readablemessagecatalog readfrom ( inputstream stream ) throws ioexception { stringbuilder buf = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( stream , utf8 ) ) ; int ch ; while ( ( ch = reader . read ( ) ) != - 1 ) { buf . append ( ( char ) ch ) ; } reader . close ( ) ; string content = buf . tostring ( ) ; int jsonstart = content . indexof ( "{" ) ; int jsonend = content . lastindexof ( "}" ) ; final list < messagefragment > result = new arraylist < messagefragment > ( ) ; contentbeforejson = content . substring ( 0 , jsonstart ) ; string json = content . substring ( jsonstart , jsonend + 1 ) ; json = json . replaceall ( "(['\\"])\\\\s*\\\\+\\\\s*\\\\1" , "" ) ; jsonobject jsonobject = jsonobject . fromobject ( json ) ; string key = null ; iterator it = jsonobject . keys ( ) ; while ( it . hasnext ( ) ) { key = ( string ) it . next ( ) ; messages . add ( new jsonmessage ( key , jsonobject . getstring ( key ) ) ) ; } contentafterjson = content . substring ( jsonend + 1 ) ; return new readablemessagecatalog ( ) { @ override public iterable < message > readmessages ( ) { return messages ; } @ override public void close ( ) throws ioexception { } } ; }
tr	4	public boolean provjerilistu ( string ime ) { resource r ; boolean ima = false ; for ( int i = 0 ; i < c . getlista ( ) . size ( ) ; i ++ ) { r = ( resource ) c . getlista ( ) . get ( i ) ; if ( r . getnaziv ( ) . equals ( ime ) ) { r . setbrojkoristenja ( r . getbrojkoristenja ( ) + 1 ) ; r . setvrijemespremanja ( new date ( ) ) ; r . setspremljen ( true ) ; upisiudnevnik ( r ) ; ima = true ; break ; } } return ima ; }
tr	6	public static void runrandomizedexperiment ( ) { final int numruns = 5 ; final int [ ] numverticesarray = { 1000 , 3000 , 5000 } ; final int [ ] densityarray = { 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 } ; for ( int numvertices : numverticesarray ) { for ( int density : densityarray ) { long simpleschemeruntime = 0 ; long fheapschemeruntime = 0 ; for ( int run = 0 ; run < numruns ; run ++ ) { graph graph = graphgenerator . generategraph ( numvertices , density / 100.0 ) ; mstgenerator . generatemst ( new simpleschememstgenerator ( ) , graph ) ; simpleschemeruntime += mstgenerator . getruntime ( ) ; mstgenerator . generatemst ( new fheapschememstgenerator ( ) , graph ) ; fheapschemeruntime += mstgenerator . getruntime ( ) ; } simpleschemeruntime = simpleschemeruntime / numruns ; fheapschemeruntime = fheapschemeruntime / numruns ; system . out . format ( "%d<litcomma> %d<litcomma> %d<litcomma> %d\\n" , numvertices , density , simpleschemeruntime , fheapschemeruntime ) ; } } }
tr	8	public chessmoves nextmoves ( chessboard b ) { int i = this . getposition ( ) . getrow ( ) ; int j = this . getposition ( ) . getcol ( ) ; chessmoves moves = new chessmoves ( ) ; try { for ( i = 1 ; i > - 2 ; i -= 2 ) { for ( j = 1 ; j > - 2 ; j -= 2 ) { boolean good_move ; int tr = this . getposition ( ) . getrow ( ) ; int tc = this . getposition ( ) . getcol ( ) ; do { tr = tr + i ; tc = tc + j ; if ( ( tr >= 0 ) && ( tr <= 7 ) && ( tc >= 0 ) && ( tc <= 7 ) ) { chessposition tp = new chessposition ( tr , tc ) ; chesspiece p = b . pieceat ( tp ) ; if ( p == null ) { moves . addmove ( new chessposition ( tr , tc ) ) ; good_move = true ; } else if ( p . getcolor ( ) != this . getcolor ( ) ) { moves . addmove ( new chessposition ( tr , tc ) , chessmoves . movetype . capture ) ; good_move = false ; } else good_move = false ; } else good_move = false ; } while ( good_move ) ; } } } catch ( exception e ) { moves = null ; } return moves ; }
tr	5	@ override public optional < e > get ( int index ) { if ( index == 0 && containedlist . head ( ) . map ( condition ) . get ( ) ) { return containedlist . head ( ) ; } else if ( containedlist . isempty ( ) ) { return optional . empty ( ) ; } else if ( containedlist . head ( ) . map ( condition ) . get ( ) ) { return tail ( ) . get ( index - 1 ) ; } else { return tail ( ) . get ( index ) ; } }
tr	10	protected static set < edge > readinput ( scanner is ) throws exception { numnodes = integer . valueof ( is . nextline ( ) ) ; numedges = integer . valueof ( is . nextline ( ) ) ; k = integer . valueof ( is . nextline ( ) ) ; if ( k <= 0 ) { throw new exception ( "k negativ!" ) ; } threshold = integer . valueof ( is . nextline ( ) ) ; set < edge > e = new hashset < edge > ( ( int ) ( numedges / 0.75 ) ) ; for ( int edge_counter = 0 ; ( is . hasnext ( ) ) ; edge_counter ++ ) { string val [ ] = is . nextline ( ) . split ( " " ) ; if ( val . length != 4 ) { throw new exception ( "fehlerhafte zeile (kante #" + edge_counter + ")" ) ; } int numedge = integer . valueof ( val [ 0 ] ) ; int node1 = integer . valueof ( val [ 1 ] ) ; int node2 = integer . valueof ( val [ 2 ] ) ; int weight = integer . valueof ( val [ 3 ] ) ; if ( numedge != edge_counter ) { throw new exception ( "fehlerhafte zeile (kante #" + edge_counter + ")" ) ; } if ( ! ( 0 <= node1 && node1 < numnodes ) ) { throw new exception ( "knoten 1 fehlerhaft (kante #" + edge_counter + ")" ) ; } if ( ! ( 0 <= node2 && node2 < numnodes ) ) { throw new exception ( "knoten 1 fehlerhaft (kante #" + edge_counter + ")" ) ; } if ( weight < 0 ) { throw new exception ( "gewicht negativ (kante #" + edge_counter + ")" ) ; } e . add ( new edge ( node1 , node2 , weight ) ) ; } if ( e . size ( ) != numedges ) { throw new exception ( "nicht genuegend kanten gefunden!" ) ; } return e ; }
tr	7	public int romantoint ( string s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i < s . length ( ) - 1 ) { string x = s . substring ( i , i + 2 ) ; switch ( x ) { case "cm" : res += 900 ; i ++ ; break ; case "cd" : res += 400 ; i ++ ; break ; case "xc" : res += 90 ; i ++ ; break ; case "xl" : res += 40 ; i ++ ; break ; case "ix" : res += 9 ; i ++ ; break ; case "iv" : res += 4 ; i ++ ; break ; default : res += mapsingle ( s . substring ( i , i + 1 ) ) ; } } else res += mapsingle ( s . substring ( i , i + 1 ) ) ; } return res ; }
tr	2	public boolean check ( string login , string password ) { try { out = new printwriter ( socket . getoutputstream ( ) ) ; in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; out . println ( login ) ; out . flush ( ) ; out . println ( password ) ; out . flush ( ) ; j = integer . parseint ( in . readline ( ) ) ; switch ( j ) { case 0 : return false ; case 1 : return true ; } } catch ( ioexception e ) { system . out . println ( "error connecting to the server." ) ; } return false ; }
tr	5	public boolean istieneunprefijo ( atributovo atributovo ) { @ suppresswarnings ( "unchecked" ) list < string > prefijos = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . prefijo_entida ) ; for ( string prefijo : prefijos ) { if ( atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) { system . out . println ( prefijo + " == " + atributovo . gettipoatributoenti ( ) + " = " + atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) ; return true ; } } return false ; }
tr	5	@ override public arraylist < editban > getbannedplayers ( ) { id = 0 ; if ( ! banlist . exists ( ) ) { try { banlist . createnewfile ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } arraylist < editban > list = new arraylist < editban > ( ) ; try { bufferedreader in = new bufferedreader ( new filereader ( banlist ) ) ; string data = null ; while ( ( data = in . readline ( ) ) != null ) { if ( ! data . startswith ( "#" ) ) { if ( data . length ( ) > 0 ) { editban e = editban . loadban ( data ) ; if ( e != null && e . type != 2 ) { list . add ( e ) ; id = math . max ( e . id , id ) ; } } } } id ++ ; in . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return list ; }
tr	3	public void addinfo ( site s ) { content [ 0 ] = "scape" ; content [ 1 ] = "agents: " + scape . agents . size ( ) ; content [ 2 ] = newline + "site" ; content [ 3 ] = "coordinates: (" + s . getxposition ( ) + "<litcomma> " + s . getyposition ( ) + ")" ; content [ 4 ] = "site food: " + round ( s . getfood ( ) ) ; content [ 5 ] = newline + "agent on site" ; agent a = s . getagent ( ) ; if ( a != null ) { content [ 6 ] = "agent id: " + a ; content [ 7 ] = "age: " + a . getage ( ) ; content [ 8 ] = "agent energy: " + round ( a . getenergy ( ) ) ; } else { content [ 6 ] = "id: " ; content [ 7 ] = "age: " ; content [ 8 ] = "agent energy: " ; } updateinfo ( ) ; }
tr	1	public void draw ( ) { logic ( ) ; glpushmatrix ( ) ; gltranslated ( x , y , 0 ) ; glbegin ( gl_quads ) ; glcolor3d ( 1 , 0 , 0 ) ; glvertex2d ( - 8 , 0 ) ; glcolor3d ( 0 , 1 , 0 ) ; glvertex2d ( 8 , 0 ) ; glcolor3d ( 0 , 0 , 1 ) ; glvertex2d ( 8 , 16 ) ; glcolor3d ( 1 , 1 , 0 ) ; glvertex2d ( - 8 , 16 ) ; glend ( ) ; glpopmatrix ( ) ; }
tr	5	public static tone gettone ( name name , accidental accidental ) { for ( int pitchclass = 0 ; pitchclass < tones . length ; pitchclass ++ ) { if ( tones [ pitchclass ] [ 0 ] . getname ( ) == name && tones [ pitchclass ] [ 0 ] . getaccidental ( ) == accidental ) { return new tone ( tones [ pitchclass ] [ 0 ] ) ; } if ( tones [ pitchclass ] [ 1 ] . getname ( ) == name && tones [ pitchclass ] [ 1 ] . getaccidental ( ) == accidental ) { return new tone ( tones [ pitchclass ] [ 1 ] ) ; } } return null ; }
tr	8	@ override public void run ( ) { try { int firstpoint = 1 ; int lastpoint = 0 ; while ( true ) { if ( ! monitor . flag ) { while ( ! readscreen . targetpresence ( ) & ! monitor . flag ) { select . nextfoe ( ) ; if ( readscreen . targetpresence ( ) ) { break ; } movement . turnleft ( 300 , 200 ) ; if ( ui . decision . equals ( "y" ) ) { monitor . iterator ++ ; if ( monitor . iterator > 10 ) { break ; } } else { } } if ( ui . decision . equals ( "y" ) ) { if ( monitor . iterator >= 10 & firstpoint == 1 ) { checkminimap . go ( ui . firstdirection , ui . steps * 1000 ) ; lastpoint = 1 ; firstpoint = 0 ; monitor . iterator = 0 ; } else if ( monitor . iterator >= 10 & lastpoint == 1 ) { checkminimap . go ( ui . seconddirection , ui . steps * 1000 ) ; lastpoint = 0 ; firstpoint = 1 ; monitor . iterator = 0 ; } } if ( monitor . flag ) { synchronized ( monitor . setstate ) { monitor . setstate . wait ( ) ; } } fightlogic . preparing ( readscreen . getrole ( ) ) ; fightlogic . skillrotation ( readscreen . getrole ( ) ) ; } else { synchronized ( monitor . setstate ) { monitor . setstate . wait ( ) ; } } } } catch ( throwable t ) { t . printstacktrace ( ) ; } }
tr	3	public serverconfigurationframe ( ) { getcontentpane ( ) . setlayout ( null ) ; jfilechooser = new jfilechooser ( ) ; jfilechooser . setfileselectionmode ( jfilechooser . directories_only ) ; jpanel panel = new jpanel ( ) ; panel . setbounds ( 10 , 11 , 464 , 313 ) ; getcontentpane ( ) . add ( panel ) ; panel . setlayout ( null ) ; jlabel lblnewlabel = new jlabel ( "root directory :" ) ; lblnewlabel . setbounds ( 10 , 11 , 97 , 14 ) ; panel . add ( lblnewlabel ) ; tfrootdirectory = new jtextfield ( ) ; tfrootdirectory . setbounds ( 117 , 8 , 241 , 20 ) ; panel . add ( tfrootdirectory ) ; tfrootdirectory . settext ( "c:\\\\users\\\\rakin haider\\\\desktop\\\\new folder" ) ; tfrootdirectory . setcolumns ( 10 ) ; jlabel lblnewlabel_1 = new jlabel ( "file types :" ) ; lblnewlabel_1 . setbounds ( 9 , 36 , 78 , 14 ) ; panel . add ( lblnewlabel_1 ) ; tffiletypes = new jtextfield ( ) ; tffiletypes . setbounds ( 117 , 33 , 241 , 20 ) ; tffiletypes . seteditable ( false ) ; panel . add ( tffiletypes ) ; tffiletypes . setcolumns ( 10 ) ; jbutton btnbrowse = new jbutton ( "browse" ) ; btnbrowse . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( jfilechooser . showopendialog ( getframes ( ) [ 0 ] ) == jfilechooser . approve_option ) { tfrootdirectory . settext ( jfilechooser . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; btnbrowse . setbounds ( 368 , 7 , 86 , 23 ) ; panel . add ( btnbrowse ) ; jbutton btnadd = new jbutton ( "add" ) ; btnadd . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( tffiletypes . gettext ( ) . equals ( "" ) ) tffiletypes . settext ( tfnewtype . gettext ( ) ) ; else tffiletypes . settext ( tffiletypes . gettext ( ) + ";" + tfnewtype . gettext ( ) ) ; tfnewtype . settext ( "" ) ; } } ) ; btnadd . setbounds ( 368 , 66 , 86 , 23 ) ; panel . add ( btnadd ) ; jlabel lblnumberoffiles = new jlabel ( "number of files" ) ; lblnumberoffiles . setbounds ( 10 , 103 , 78 , 14 ) ; panel . add ( lblnumberoffiles ) ; tfnumbeoffiles = new jtextfield ( ) ; tfnumbeoffiles . settext ( "10" ) ; tfnumbeoffiles . setbounds ( 117 , 100 , 241 , 20 ) ; panel . add ( tfnumbeoffiles ) ; tfnumbeoffiles . setcolumns ( 10 ) ; jlabel lblfolderallowed = new jlabel ( "folder allowed ?" ) ; lblfolderallowed . setbounds ( 10 , 148 , 78 , 14 ) ; panel . add ( lblfolderallowed ) ; final jcheckbox chckbxyes = new jcheckbox ( "yes" ) ; chckbxyes . setselected ( true ) ; chckbxyes . setbounds ( 117 , 144 , 97 , 23 ) ; panel . add ( chckbxyes ) ; jlabel lblmaximumsize = new jlabel ( "maximum size :" ) ; lblmaximumsize . setbounds ( 10 , 189 , 78 , 14 ) ; panel . add ( lblmaximumsize ) ; tffilesize = new jtextfield ( ) ; tffilesize . settext ( "2097152" ) ; tffilesize . setbounds ( 128 , 186 , 86 , 20 ) ; panel . add ( tffilesize ) ; tffilesize . setcolumns ( 10 ) ; jlabel lblidrange = new jlabel ( "id range :" ) ; lblidrange . setbounds ( 10 , 233 , 78 , 14 ) ; panel . add ( lblidrange ) ; tfminid = new jtextfield ( ) ; tfminid . settext ( "201005001" ) ; tfminid . setbounds ( 128 , 230 , 86 , 20 ) ; panel . add ( tfminid ) ; tfminid . setcolumns ( 10 ) ; tfmaxid = new jtextfield ( ) ; tfmaxid . settext ( "201005120" ) ; tfmaxid . setbounds ( 249 , 230 , 86 , 20 ) ; panel . add ( tfmaxid ) ; tfmaxid . setcolumns ( 10 ) ; jlabel label = new jlabel ( "-" ) ; label . setfont ( new font ( "tahoma" , font . bold , 13 ) ) ; label . setbounds ( 227 , 232 , 46 , 14 ) ; panel . add ( label ) ; jbutton btnstartserver = new jbutton ( "start server" ) ; btnstartserver . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { string rootpath = tfrootdirectory . gettext ( ) ; string filetype = tffiletypes . gettext ( ) ; string [ ] extensions = filetype . split ( ";" ) ; int numberoffiles = integer . parseint ( tfnumbeoffiles . gettext ( ) ) ; long maxfilesize = long . parselong ( tffilesize . gettext ( ) ) ; long maxid = long . parselong ( tfmaxid . gettext ( ) ) ; long minid = long . parselong ( tfminid . gettext ( ) ) ; configurations configurations = new configurations ( rootpath , extensions , numberoffiles , maxfilesize , minid , maxid , chckbxyes . isselected ( ) ) ; dispose ( ) ; serverrunningframe serverrunningframe = new serverrunningframe ( configurations ) ; } } ) ; btnstartserver . setbounds ( 182 , 279 , 106 , 23 ) ; panel . add ( btnstartserver ) ; jlabel lblnewtype = new jlabel ( "new type :" ) ; lblnewtype . setbounds ( 10 , 70 , 68 , 14 ) ; panel . add ( lblnewtype ) ; tfnewtype = new jtextfield ( ) ; tfnewtype . setbounds ( 117 , 67 , 241 , 20 ) ; panel . add ( tfnewtype ) ; tfnewtype . setcolumns ( 10 ) ; }
tr	8	private void updatedaycombobox ( ) { int day = ( int ) daycombobox . getselecteditem ( ) ; month m = month . of ( getmonthcombobox ( ) . getselectedindex ( ) + 1 ) ; int year = ( int ) yearcombobox . getselecteditem ( ) ; boolean leap = false ; if ( year % 4 == 0 ) { leap = ! leap ; } int daysinmonth ; switch ( m ) { case january : case march : case may : case july : case august : case october : case december : daysinmonth = 31 ; break ; case april : case june : case september : case november : daysinmonth = 30 ; break ; case february : if ( leap ) { daysinmonth = 29 ; } else { daysinmonth = 28 ; } break ; default : daysinmonth = - 1 ; } daycombobox . setmodel ( daycomboboxmodel . getcorrectmodel ( daysinmonth ) ) ; if ( day > daysinmonth ) { day = daysinmonth ; } daycombobox . setselecteditem ( day ) ; }
tr	8	public int ladderlength ( string start , string end , hashset < string > dict ) { if ( dict . size ( ) == 0 ) return 0 ; linkedlist < string > wordqueue = new linkedlist < string > ( ) ; linkedlist < integer > distancequeue = new linkedlist < integer > ( ) ; wordqueue . add ( start ) ; distancequeue . add ( 1 ) ; while ( ! wordqueue . isempty ( ) ) { string currword = wordqueue . pop ( ) ; integer currdistance = distancequeue . pop ( ) ; if ( currword . equals ( end ) ) { return currdistance ; } for ( int i = 0 ; i < currword . length ( ) ; i ++ ) { char [ ] currchararr = currword . tochararray ( ) ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { currchararr [ i ] = c ; string newword = new string ( currchararr ) ; if ( newword == end ) return currdistance + 1 ; if ( dict . contains ( newword ) ) { wordqueue . add ( newword ) ; distancequeue . add ( currdistance + 1 ) ; dict . remove ( newword ) ; } } } } return 0 ; }
tr	7	public float interpolate ( int x , int z ) { int left = ( int ) ( x / xfreq ) + 1 ; int back = ( z / zfreq ) ; float [ ] interps = new float [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { interps [ i ] = cubicinterpolate ( functionresults [ left - 1 ] [ back ] , functionresults [ left ] [ back ] , functionresults [ left + 1 ] [ back ] , functionresults [ left + 2 ] [ back ] , ( ( float ) ( x % xfreq ) ) / xfreq ) ; back ++ ; } return cubicinterpolate ( interps [ 0 ] , interps [ 1 ] , interps [ 2 ] , interps [ 3 ] , ( ( float ) ( z % zfreq ) ) / zfreq ) ; }
tr	2	public static void extract ( final inputstream fis , final int flength , final outputstream fos , final string password ) throws ioexception { carrier = new byte [ flength ] ; fis . read ( carrier ) ; final huffmandecode hd = new huffmandecode ( carrier ) ; system . out . println ( "huffman decoding starts" ) ; coeff = hd . decode ( ) ; system . out . println ( "permutation starts" ) ; final f5random random = new f5random ( password . getbytes ( ) ) ; final permutation permutation = new permutation ( coeff . length , random ) ; system . out . println ( coeff . length + " indices shuffled" ) ; int extractedbyte = 0 ; int availableextractedbits = 0 ; int extractedfilelength = 0 ; int nbytesextracted = 0 ; int shuffledindex = 0 ; int extractedbit ; int i ; system . out . println ( "extraction starts" ) ; for ( i = 0 ; availableextractedbits < 32 ; i ++ ) { shuffledindex = permutation . getshuffled ( i ) ; if ( shuffledindex % 64 == 0 ) { continue ; } shuffledindex = shuffledindex - shuffledindex % 64 + dezigzag [ shuffledindex % 64 ] ; if ( coeff [ shuffledindex ] == 0 ) { continue ; } if ( coeff [ shuffledindex ] > 0 ) { extractedbit = coeff [ shuffledindex ] & 1 ; } else { extractedbit = 1 - ( coeff [ shuffledindex ] & 1 ) ; } extractedfilelength |= extractedbit << availableextractedbits ++ ; } extractedfilelength ^= random . getnextbyte ( ) ; extractedfilelength ^= random . getnextbyte ( ) << 8 ; extractedfilelength ^= random . getnextbyte ( ) << 16 ; extractedfilelength ^= random . getnextbyte ( ) << 24 ; int k = extractedfilelength > > 24 ; k %= 32 ; final int n = ( 1 << k ) - 1 ; extractedfilelength &= 0x007fffff ; system . out . println ( "length of embedded file: " + extractedfilelength + " bytes" ) ; availableextractedbits = 0 ; if ( n > 0 ) { int startofn = i ; int hash ; system . out . println ( "(1<litcomma> " + n + "<litcomma> " + k + ") code used" ) ; extractingloop : do { hash = 0 ; int code = 1 ; for ( i = 0 ; code <= n ; i ++ ) { if ( startofn + i >= coeff . length ) { break extractingloop ; } shuffledindex = permutation . getshuffled ( startofn + i ) ; if ( shuffledindex % 64 == 0 ) { continue ; } shuffledindex = shuffledindex - shuffledindex % 64 + dezigzag [ shuffledindex % 64 ] ; if ( coeff [ shuffledindex ] == 0 ) { continue ; } if ( coeff [ shuffledindex ] > 0 ) { extractedbit = coeff [ shuffledindex ] & 1 ; } else { extractedbit = 1 - ( coeff [ shuffledindex ] & 1 ) ; } if ( extractedbit == 1 ) { hash ^= code ; } code ++ ; } startofn += i ; for ( i = 0 ; i < k ; i ++ ) { extractedbyte |= ( hash > > i & 1 ) << availableextractedbits ++ ; if ( availableextractedbits == 8 ) { extractedbyte ^= random . getnextbyte ( ) ; fos . write ( ( byte ) extractedbyte ) ; extractedbyte = 0 ; availableextractedbits = 0 ; nbytesextracted ++ ; if ( nbytesextracted == extractedfilelength ) { break extractingloop ; } } } } while ( true ) ; } else { system . out . println ( "default code used" ) ; for ( ; i < coeff . length ; i ++ ) { shuffledindex = permutation . getshuffled ( i ) ; if ( shuffledindex % 64 == 0 ) { continue ; } shuffledindex = shuffledindex - shuffledindex % 64 + dezigzag [ shuffledindex % 64 ] ; if ( coeff [ shuffledindex ] == 0 ) { continue ; } if ( coeff [ shuffledindex ] > 0 ) { extractedbit = coeff [ shuffledindex ] & 1 ; } else { extractedbit = 1 - ( coeff [ shuffledindex ] & 1 ) ; } extractedbyte |= extractedbit << availableextractedbits ++ ; if ( availableextractedbits == 8 ) { extractedbyte ^= random . getnextbyte ( ) ; fos . write ( ( byte ) extractedbyte ) ; extractedbyte = 0 ; availableextractedbits = 0 ; nbytesextracted ++ ; if ( nbytesextracted == extractedfilelength ) { break ; } } } } if ( nbytesextracted < extractedfilelength ) { system . out . println ( "incomplete file: only " + nbytesextracted + " of " + extractedfilelength + " bytes extracted" ) ; } }
tr	9	private void calculateareas ( ) { totalcount = 0 ; int size = 200 ; byte [ ] [ ] [ ] bis = new byte [ ncircles ] [ size ] [ size ] ; double mins = double . positive_infinity ; double maxs = double . negative_infinity ; for ( int i = 0 ; i < ncircles ; i ++ ) { double radius = diameters [ i ] / 2 ; mins = math . min ( centers [ i ] [ 0 ] - radius , mins ) ; mins = math . min ( centers [ i ] [ 1 ] - radius , mins ) ; maxs = math . max ( centers [ i ] [ 0 ] + radius , maxs ) ; maxs = math . max ( centers [ i ] [ 1 ] + radius , maxs ) ; } for ( int i = 0 ; i < ncircles ; i ++ ) { double xi = ( centers [ i ] [ 0 ] - mins ) / ( maxs - mins ) ; double yi = ( centers [ i ] [ 1 ] - mins ) / ( maxs - mins ) ; double di = diameters [ i ] / ( maxs - mins ) ; int r = ( int ) ( di * size / 2. ) ; int r2 = r * r ; int cx = ( int ) ( xi * size ) ; int cy = ( int ) ( size - yi * size ) ; for ( int x = 0 ; x < size ; x ++ ) { for ( int y = 0 ; y < size ; y ++ ) { if ( ( x - cx ) * ( x - cx ) + ( y - cy ) * ( y - cy ) < r2 ) bis [ i ] [ x ] [ y ] = 1 ; } } } for ( int x = 0 ; x < size ; x ++ ) { for ( int y = 0 ; y < size ; y ++ ) { int [ ] counts = new int [ ncircles ] ; int count = 0 ; for ( int j = 0 ; j < ncircles ; j ++ ) { if ( bis [ j ] [ x ] [ y ] == 1 ) { counts [ j ] ++ ; count ++ ; } } if ( count > 0 ) updatepixels ( counts ) ; } } if ( totalcount == 0 ) return ; for ( int i = 0 ; i < npolygons ; i ++ ) polyareas [ i ] = 100 * polyareas [ i ] / totalcount ; }
tr	10	public arraylist < string > get_search_urls ( ) throws classnotfoundexception , sqlexception { string url ; int docn , i ; double freq , idf , tf , tfidf ; arraylist < string > url_list = new arraylist < string > ( ) ; for ( i = 0 ; i < query_words . length ; i ++ ) { if ( query_map . containskey ( query_words [ i ] ) ) { freq = query_map . get ( query_words [ i ] ) ; freq = freq + 1 ; query_map . put ( query_words [ i ] , new double ( freq ) ) ; } else { query_map . put ( query_words [ i ] , new double ( 1.0 ) ) ; } } iterator < string > it = query_map . keyset ( ) . iterator ( ) ; string query_word ; while ( it . hasnext ( ) ) { query_word = it . next ( ) . tostring ( ) ; word_query_statement . setstring ( 1 , query_word ) ; resultset resultset = word_query_statement . executequery ( ) ; hashmap < string , result > temp_obj = new hashmap < string , result > ( ) ; while ( resultset . next ( ) ) { url = resultset . getstring ( "urls" ) ; if ( url . contains ( "rss" ) ) continue ; if ( url . contains ( ".xml" ) ) continue ; result res = new result ( resultset , this ) ; url = res . url ; docn = resultset . getint ( "docsn" ) ; freq = query_map . get ( query_word ) ; tf = ( 1 + math . log10 ( freq ) ) ; idf = math . log10 ( ( double ) total_n / ( double ) docn ) ; tfidf = tf * idf ; if ( ! query_map . containskey ( query_word ) ) query_map . put ( query_word , tfidf ) ; if ( ! url_list . contains ( url ) ) { url_list . add ( url ) ; } temp_obj . put ( url , res ) ; } resultsetmap . put ( query_word , temp_obj ) ; } system . out . println ( "query map: " + query_map ) ; iterator < string > it1 = query_map . keyset ( ) . iterator ( ) ; double net_score = 0 ; while ( it1 . hasnext ( ) ) { string word = it1 . next ( ) ; double score = query_map . get ( word ) ; net_score += score * score ; } iterator < string > it2 = query_map . keyset ( ) . iterator ( ) ; while ( it2 . hasnext ( ) ) { string word = it2 . next ( ) ; double score = query_map . get ( word ) ; score /= math . sqrt ( net_score ) ; query_map . put ( word , score ) ; } return url_list ; }
tr	1	public string tostring ( ) { stringbuilder result = new stringbuilder ( ) ; datetimeformatter fmt = datetimeformat . forpattern ( "hh:mm mm/dd" ) ; result . append ( name + ": " + fmt . print ( interval . getstart ( ) ) + " - " + fmt . print ( interval . getend ( ) ) ) ; result . append ( system . getproperty ( "line.separator" ) ) ; if ( description . equals ( "" ) ) { result . append ( " none" ) ; } else { result . append ( " " + description ) ; } return result . tostring ( ) ; }
tr	2	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese un d\xeda de la semana (n\xfamero): " ) ; int v = scanner . nextint ( ) ; string dia ; switch ( v ) { case 1 : dia = "lunes" ; break ; case 2 : dia = "martes" ; break ; case 3 : dia = "miercoles" ; break ; case 4 : dia = "jueves" ; break ; case 5 : dia = "viernes" ; break ; case 6 : dia = "s\xe1bado" ; break ; case 7 : dia = "domingo" ; break ; default : dia = "d\xeda incorrecto... el valor debe ser entre 1 y 7" ; } system . out . println ( dia ) ; }
tr	7	protected boolean verifypackage ( ) throws mojoexecutionexception { getlog ( ) . info ( "verifying package..." ) ; if ( getbarpackage ( ) . getbarfile ( ) == null || ! getbarpackage ( ) . getbarfile ( ) . exists ( ) || ! getbarpackage ( ) . getbarfile ( ) . canread ( ) ) { throw new mojoexecutionexception ( "bar package was not specified or doesn't " + "exist<litcomma> or there is no permission to read." ) ; } final string [ ] args = { "-verify" , getbarpackage ( ) . getbarfile ( ) . getpath ( ) } ; callable < void > signercallable = new callable < void > ( ) { @ override public void call ( ) throws exception { barsigner . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean signingsuccessful = executor . execute ( signercallable ) == 0 ; getlog ( ) . info ( "verification complete." ) ; return signingsuccessful ; }
tr	10	public static int grade ( int totalvar , boolx [ ] kmap , boolean isminterm ) { assert kmap . length == powint ( 2 , totalvar ) ; int cost = 0 ; boolean [ ] groupability = new boolean [ powint ( 3 , totalvar ) ] ; karnaughmapgrader . totalvar = totalvar ; karnaughmapgrader . kmap = kmap ; karnaughmapgrader . isminterm = isminterm ; numlayer = new int [ kmap . length ] ; for ( int pattern = 0 ; pattern < powint ( 3 , totalvar ) ; pattern ++ ) if ( groupability [ pattern ] = groupable ( totalvar , pattern , 0 ) ) updatelabel ( totalvar , pattern , 0 , 1 ) ; for ( int numvar = totalvar ; numvar >= 0 ; numvar -- ) for ( int pattern = 0 ; pattern < powint ( 3 , totalvar ) ; pattern ++ ) { if ( ! groupability [ pattern ] ) ; else if ( numvarinpattern ( totalvar , pattern ) != numvar ) ; else if ( deletable ( totalvar , pattern , 0 ) ) updatelabel ( totalvar , pattern , 0 , - 1 ) ; else cost += numvar ; } return cost ; }
tr	10	public int getdominator ( int [ ] giveninput ) { if ( giveninput == null ) { system . out . println ( "the object is null" ) ; return - 1 ; } if ( giveninput . length < 1 ) { system . out . println ( "invalid data" ) ; return - 1 ; } if ( giveninput . length == 1 ) { return 1 ; } hashmap < integer , integer > o_hm = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < giveninput . length ; i ++ ) { if ( o_hm . containskey ( giveninput [ i ] ) ) { o_hm . put ( giveninput [ i ] , o_hm . get ( giveninput [ i ] ) + 1 ) ; } else { o_hm . put ( giveninput [ i ] , 1 ) ; } } int dominator = - 1 ; for ( map . entry < integer , integer > entry : o_hm . entryset ( ) ) { if ( entry . getvalue ( ) > dominator && ( entry . getvalue ( ) > ( giveninput . length / 2 ) ) ) { dominator = ( int ) entry . getkey ( ) ; } } for ( int count = 0 ; count < giveninput . length ; count ++ ) { if ( giveninput [ count ] == dominator ) { return count ; } } return - 1 ; }
tr	5	public void ispispoveznica ( ) { m . dohvatilistupoveznica ( ) ; system . out . println ( "---------poveznice-------------" ) ; ispisilinije ( m . getmax ( ) ) ; for ( int i = 0 ; i < m . getwebstranica ( ) . getlistaurla ( ) . size ( ) ; i ++ ) { system . out . print ( "| " + ( i + 1 ) + "." ) ; ispisiprazninebroja ( ( integer . tostring ( m . getwebstranica ( ) . getlistaurla ( ) . size ( ) ) . length ( ) - integer . tostring ( i + 1 ) . length ( ) ) + 1 ) ; system . out . print ( "|  " + m . getwebstranica ( ) . getlistaurla ( ) . get ( i ) ) ; ispisipraznineurla ( m . getmax ( ) - m . getwebstranica ( ) . getlistaurla ( ) . get ( i ) . tostring ( ) . length ( ) ) ; ispisilinije ( m . getmax ( ) ) ; } }
tr	2	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese la fecha (dd/mm/aaaa): " ) ; string sfecha = scanner . next ( ) ; fecha f = new fecha ( sfecha ) ; system . out . println ( "la fecha ingresada es:" + f ) ; system . out . println ( "ingrese d\xedas a sumar(pueden ser negativos)" ) ; int diassum = scanner . nextint ( ) ; f . adddias ( diassum ) ; system . out . println ( "sumando " + diassum + " d\xedas<litcomma> queda: " + f ) ; }
tr	8	private static void addtreasurechest ( scanner scanner , grid grid ) { system . out . println ( "please provide a name for your treasure chest :" ) ; string chest = scanner . nextline ( ) ; while ( chest == null || chest . equals ( "" ) ) { system . out . println ( "please provide a name for your treasure chest :" ) ; chest = scanner . nextline ( ) ; } system . out . println ( "please provide a position for your treasure chest " ) ; system . out . println ( "please enter a row number row numbers start from 0 and should be less than " + grid . getrows ( ) + " : " ) ; int row = getrows ( scanner ) ; while ( row == - 1 || row > grid . getrows ( ) ) { system . out . println ( "please enter a valid row number.row numbers start from 0 and is less than " + grid . getrows ( ) + " :" ) ; row = getrows ( scanner ) ; } int col = getcolumns ( scanner ) ; system . out . println ( "please enter the column you would like to position your treasure chest columns starts 1 and should be less than " + grid . getcolumns ( ) + " : " ) ; while ( col == - 1 || col > grid . getcolumns ( ) ) { system . out . println ( "please enter a valid column number. column numbers start from 1 and is less than " + grid . getcolumns ( ) ) ; col = getcolumns ( scanner ) ; } grid . addtreasurechest ( new treasurechest ( chest ) , row , col ) ; grid . displaygrid ( ) ; system . out . println ( "would you like to add another treasure chest to the grid ? y or n" ) ; string yn = addtreasure ( scanner ) ; while ( ! yn . trim ( ) . equalsignorecase ( "y" ) && ! yn . trim ( ) . equalsignorecase ( "n" ) ) { system . out . println ( "enter y or n :" ) ; yn = scanner . nextline ( ) ; } if ( yn . trim ( ) . equalsignorecase ( "y" ) ) { addtreasurechest ( scanner , grid ) ; } else { treasurechestcounter counter = new treasurechestmanager ( ) ; system . out . println ( "**********treasure maps nearby****************" ) ; counter . displaytreasurechestnearby ( grid ) ; system . out . println ( "thank you for using the trasure map finder" ) ; } }
tr	3	public void pastenode ( ) { treenode selectednode = treecontrol . getselectednode ( ) ; treenode node = clipboard . getchildren ( ) . get ( 0 ) ; boolean duplicated = false ; for ( treenode item : selectednode . getchildren ( ) ) { urldocument doc = ( urldocument ) item . getdata ( ) ; urldocument docclipboard = ( urldocument ) node . getdata ( ) ; if ( doc . getname ( ) . matches ( docclipboard . getname ( ) ) ) { duplicated = true ; break ; } } if ( ! duplicated ) { node . setparent ( selectednode ) ; urldocument urldocument = ( urldocument ) node . getdata ( ) ; urldocument . setparentnode ( selectednode ) ; urldocument . pathupdate ( ) ; updatechildren ( node ) ; treecontrol . setnodepath ( urldocument . getfullpath ( ) ) ; } }
tr	4	public void keypressed ( keyevent e ) { int thekey = e . getkeycode ( ) ; double boxdistance ; if ( ( thekey == keyevent . vk_a ) && ( ! apressed ) && ( ! playerjustportaled ) ) { apressed = true ; if ( playervel . getx ( ) > - 3.0 ) { playervel . set ( playervel . add ( - 3.0 - playervel . getx ( ) , 0.0 ) ) ; heldboxx = - 20.0 ; playerfacingright = false ; } } if ( ( thekey == keyevent . vk_d ) && ( ! dpressed ) && ( ! playerjustportaled ) ) { dpressed = true ; if ( playervel . getx ( ) < 3.0 ) { playervel . set ( playervel . add ( 3.0 - playervel . getx ( ) , 0.0 ) ) ; heldboxx = 20.0 ; playerfacingright = true ; } } if ( ( thekey == keyevent . vk_s ) && ( ! playerjustportaled ) ) { playervel . set ( 0.0 , playervel . gety ( ) ) ; } if ( thekey == keyevent . vk_space ) { if ( playeronground && ( playervel . gety ( ) > - 2 ) ) { playervel . set ( playervel . add ( 0.0 , - 6.0 ) ) ; jumping = true ; } } if ( thekey == keyevent . vk_e ) { boxdistance = math . sqrt ( math . pow ( player . getcenterx ( ) - box . getcenterx ( ) , 2 ) + math . pow ( player . getcentery ( ) - box . getcentery ( ) , 2 ) ) ; if ( boxdistance < 30 ) { if ( boxtoggle ) { if ( boxheld ) { boxheld = false ; boxtoggle = false ; } else { boxheld = true ; boxtoggle = false ; } } } } }
tr	8	private void loop ( int [ ] [ ] res , int startpos , int size , int startnumber ) { if ( size == 1 ) { res [ startpos ] [ startpos ] = startnumber ; return ; } for ( int j = startpos ; j < startpos + size - 1 ; j ++ , startnumber ++ ) res [ startpos ] [ j ] = startnumber ; for ( int i = startpos ; i < startpos + size - 1 ; i ++ , startnumber ++ ) res [ i ] [ startpos + size - 1 ] = startnumber ; for ( int j = startpos + size - 1 ; j > startpos ; j -- , startnumber ++ ) res [ startpos + size - 1 ] [ j ] = startnumber ; for ( int i = startpos + size - 1 ; i > startpos ; i -- , startnumber ++ ) res [ i ] [ startpos ] = startnumber ; }
tr	3	public message ( string rawmessage ) { prefix = "" ; command = "" ; trailing = "" ; parameters = new arraylist < string > ( ) ; if ( rawmessage . startswith ( ":" ) ) { int prefixend = rawmessage . indexof ( ' ' ) ; prefix = rawmessage . substring ( 1 , prefixend ) ; rawmessage = rawmessage . substring ( prefixend + 1 ) ; } int commandend = rawmessage . indexof ( ' ' ) ; if ( commandend < 0 ) { commandend = rawmessage . length ( ) ; } command = rawmessage . substring ( 0 , commandend ) ; if ( commandend == rawmessage . length ( ) ) { validate ( ) ; return ; } rawmessage = rawmessage . substring ( commandend ) ; if ( rawmessage . contains ( " :" ) ) { string [ ] parts = rawmessage . split ( " :" ) ; trailing = parts [ 1 ] ; if ( ! parts [ 0 ] . isempty ( ) ) { string params = parts [ 0 ] . substring ( 1 ) ; for ( string s : params . split ( " " ) ) { if ( ! s . isempty ( ) ) { parameters . add ( s ) ; } } } } else { string [ ] parts = rawmessage . substring ( 1 ) . split ( " " ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( i < 14 ) { parameters . add ( parts [ i ] ) ; } else { trailing += parts [ i ] ; } } } validate ( ) ; }
tr	9	public void run ( runnable runnable ) throws exception { stats startstats ; long starttime ; long endtime ; stats endstats ; warmup ( runnable , warm_ups ) ; jvmclean ( ) ; long [ ] timings = new long [ iterations ] ; int skips = 0 ; for ( int i = 0 ; i < iterations + dry_runs ; i ++ ) { startstats = stats ( ) ; starttime = timens ( ) ; runnable . run ( ) ; endtime = timens ( ) ; endstats = stats ( ) ; if ( i < dry_runs ) { continue ; } if ( startstats . equals ( endstats ) ) { timings [ i - dry_runs ] = endtime - starttime ; } else { system . out . println ( startstats ) ; system . out . println ( "---------" ) ; system . out . println ( endstats ) ; skips ++ ; i -- ; } } long total = 0 ; for ( long timing : timings ) { total += timing ; } system . out . println ( arrays . tostring ( timings ) ) ; system . out . println ( "skipped : " + skips ) ; system . out . println ( "average value : " + total / iterations ) ; }
tr	1	@ transactional ( propagation = propagation . required ) public void save ( final ledger item ) { jdbctemplate . update ( "insert into ledger (rcv_dt<litcomma> mbr_nm<litcomma> chk_nbr<litcomma> chk_dt<litcomma> pymt_typ<litcomma> dpst_amt<litcomma> pymt_amt<litcomma> comments) values(?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?)" , new preparedstatementsetter ( ) { public void setvalues ( preparedstatement stmt ) throws sqlexception { stmt . setdate ( 1 , new java . sql . date ( item . getreceiptdate ( ) . gettime ( ) ) ) ; stmt . setstring ( 2 , item . getmembername ( ) ) ; stmt . setstring ( 3 , item . getchecknumber ( ) ) ; stmt . setdate ( 4 , new java . sql . date ( item . getcheckdate ( ) . gettime ( ) ) ) ; stmt . setstring ( 5 , item . getpaymenttype ( ) ) ; stmt . setdouble ( 6 , item . getdepositamount ( ) ) ; stmt . setdouble ( 7 , item . getpaymentamount ( ) ) ; stmt . setstring ( 8 , item . getcomments ( ) ) ; } } ) ; }
tr	3	static string getpagecharsetfromheaders ( map < string , list < string > > headers ) { string contenttype = arrays . tostring ( headers . get ( "content-type" ) . toarray ( ) ) . replaceall ( "\\\\[|\\\\]" , "" ) . replaceall ( "<litcomma> " , "\\t" ) ; string [ ] values = contenttype . split ( ";" ) ; string charset = "" ; for ( string value : values ) { value = value . trim ( ) ; if ( value . tolowercase ( ) . startswith ( "charset=" ) ) { charset = value . substring ( "charset=" . length ( ) ) ; } } if ( "" . equals ( charset ) ) { charset = "utf-8" ; } log . info ( "\\n accepted encoding: " + charset ) ; return charset ; }
tr	7	public arraylist < yhdistelma > getyhdistelmat ( ) { arraylist < yhdistelma > a = new arraylist < yhdistelma > ( ) ; int points = 0 ; if ( ykkoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 1 ) { points ++ ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . ykkoset ) ) ; points = 0 ; } if ( kakkoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 2 ) { points ++ ; } } points = points * 2 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kakkoset ) ) ; points = 0 ; } if ( kolmoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 3 ) { points ++ ; } } points = points * 3 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kolmoset ) ) ; points = 0 ; } if ( neloset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 4 ) { points ++ ; } } points = points * 4 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . neloset ) ) ; points = 0 ; } if ( viitoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 5 ) { points ++ ; } } points = points * 5 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . viitoset ) ) ; points = 0 ; } if ( kuutoset ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == 6 ) { points ++ ; } } points = points * 6 ; a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kuutoset ) ) ; points = 0 ; } if ( kaksiparia ( ) ) { int ind = 0 ; int tmppoints ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { ind = i + 2 ; points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; break ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; tmppoints = points ; points = 0 ; for ( int i = ind ; i < 4 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { ind = i + 2 ; points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; tmppoints = tmppoints + points ; points = 0 ; a . add ( new yhdistelma ( nopat , tmppoints , jatsiyhdistelma . kaksi_paria ) ) ; } else if ( pari ( ) || kolmesamaa ( ) || neljasamaa ( ) ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . pari ) ) ; points = 0 ; } if ( kolmesamaa ( ) || neljasamaa ( ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 2 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) + nopat [ i + 2 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . kolme_samaa ) ) ; points = 0 ; } if ( neljasamaa ( ) ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( nopat [ i ] . getvalue ( ) == nopat [ i + 1 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 2 ] . getvalue ( ) && nopat [ i ] . getvalue ( ) == nopat [ i + 3 ] . getvalue ( ) ) { points = nopat [ i ] . getvalue ( ) + nopat [ i + 1 ] . getvalue ( ) + nopat [ i + 2 ] . getvalue ( ) + nopat [ i + 3 ] . getvalue ( ) ; } } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . nelja_samaa ) ) ; points = 0 ; } if ( pikkusuora ( ) ) { a . add ( new yhdistelma ( nopat , 15 , jatsiyhdistelma . pikkusuora ) ) ; } if ( isosuora ( ) ) { a . add ( new yhdistelma ( nopat , 20 , jatsiyhdistelma . isosuora ) ) ; } if ( tayskasi ( ) ) { for ( int i = 0 ; i < 5 ; i ++ ) { points = points + nopat [ i ] . getvalue ( ) ; } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . tayskasi ) ) ; points = 0 ; } for ( int i = 0 ; i < 5 ; i ++ ) { points = points + nopat [ i ] . getvalue ( ) ; } a . add ( new yhdistelma ( nopat , points , jatsiyhdistelma . sattuma ) ) ; points = 0 ; if ( yatzy ( ) ) { a . add ( new yhdistelma ( nopat , 50 , jatsiyhdistelma . yatzy ) ) ; } return a ; }
tr	7	public < t > t get ( class < t > clazz ) { set < bean < ? > > beans = beanmanager . getbeans ( clazz ) ; if ( beans != null && beans . size ( ) > 0 ) { bean < t > bean = ( bean < t > ) beans . iterator ( ) . next ( ) ; creationalcontext < t > ctx = beanmanager . createcreationalcontext ( bean ) ; t o = clazz . cast ( beanmanager . getreference ( bean , clazz , ctx ) ) ; log . info ( "found and returning: " + clazz . getcanonicalname ( ) ) ; return o ; } return null ; }
tr	4	private deck createunshufflabledeck ( ) throws invalidfacevalueexception , invalidsuitexception { list < card > cards = new arraylist < > ( ) ; char [ ] suits = { 'd' , 'h' , 'c' , 's' } ; char [ ] facevalues = { 'a' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 't' , 'j' , 'q' , 'k' } ; for ( char suit : suits ) { for ( char facevalue : facevalues ) { cards . add ( new card ( suit , facevalue ) ) ; } } deck deck = mock ( deck . class ) ; when ( deck . getcards ( ) ) . thenreturn ( cards ) ; mockito . donothing ( ) . when ( deck ) . shuffle ( ) ; return deck ; }
tr	7	public static void main ( string [ ] args ) throws exception { int maxnorm = integer . parseint ( args [ 0 ] ) ; maxnorm *= maxnorm ; for ( eisenstein e = new eisenstein ( 0 , - 3 ) ; e . norm2 ( ) < maxnorm ; e = e . inc ( ) ) hopp : { eisenstein f = e ; for ( eisenstein z : primes ) { if ( f . mod ( z ) . equals ( eisenstein . zero ) && f . norm2 ( ) > z . norm2 ( ) ) { system . err . printf ( "%s\\t=\\t%s\\tx\\t%s\\n" , f . tostring ( ) , z . tostring ( ) , f . div ( z ) . tostring ( ) ) ; break hopp ; } } system . err . printf ( "%s\\n" , f . tostring ( ) ) ; primes . add ( e ) ; primes . add ( e . mul ( eisenstein . omega ) ) ; primes . add ( e . mul ( eisenstein . omeg2 ) ) ; } system . err . println ( primes ) ; printprimes ( primes ) ; }
tr	6	public static byte [ ] buildmessage ( byte code , int ... datas ) { byte [ ] message = new byte [ 1 + datas . length * 4 ] ; message [ 0 ] = code ; int indice = 1 ; for ( int i = 0 ; i < datas . length ; i ++ ) { byte [ ] data = toolbox . int2byte ( datas [ i ] ) ; for ( int j = 0 ; j < data . length ; j ++ ) { message [ indice ++ ] = data [ j ] ; } } return message ; }
tr	9	@ generated ( "method" ) @ override public boolean equals ( object o ) { if ( o == this ) return true ; if ( ! ( o instanceof list ) ) return false ; iterator < e > e1 = iterator ( ) ; iterator e2 = ( ( list ) o ) . iterator ( ) ; while ( e1 . hasnext ( ) && e2 . hasnext ( ) ) { e o1 = e1 . next ( ) ; object o2 = e2 . next ( ) ; if ( ! ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ) return false ; } return ! ( e1 . hasnext ( ) || e2 . hasnext ( ) ) ; }
tr	5	private list < highlight > _gethighlightlist ( ) throws exception { list < string > firstcolumn = excelutils . getcellvalueasstring ( excelservice . getdataatcolumn ( 0 ) ) ; list < string > secondcolumn = excelutils . getcellvalueasstring ( excelservice . getdataatcolumn ( 1 ) ) ; list < highlight > highlights = new arraylist < highlight > ( ) ; for ( int i = 0 ; i < firstcolumn . size ( ) ; i ++ ) { string value = firstcolumn . get ( i ) ; if ( ! secondcolumn . contains ( value ) ) { highlights . add ( new highlight ( i , 0 ) ) ; } } return highlights ; }
tr	9	private final void export_one_dir ( string dirname , string to , int type , long difftime ) { file root = new file ( dirname ) ; if ( ! root . isdirectory ( ) ) return ; cachedir cd = new cachedir ( dirname + file . separator , null ) ; boolean export = false ; if ( type != export_all ) { now = system . currenttimemillis ( ) ; for ( cacheobject obj : cd . getobjects ( ) ) { if ( type == export_lru ) if ( now - obj . getlru ( ) <= difftime ) { export = true ; break ; } else continue ; if ( now - obj . getdate ( ) <= difftime ) { export = true ; break ; } } } else export = true ; if ( export ) { string en ; en = dirname . substring ( this . root . length ( ) ) ; if ( en . length ( ) > 5 ) { en = en . substring ( 1 ) ; en = en . substring ( en . indexof ( file . separator ) + 1 ) ; en = en . substring ( en . indexof ( file . separator ) + 1 ) ; cachedir ncd ; ncd = new cachedir ( to + file . separator + en + file . separator , null ) ; cd . export_to ( ncd , type , difftime ) ; ncd . save ( ) ; ncd . cleandir ( ) ; } } string filez [ ] ; filez = root . list ( ) ; if ( filez == null ) return ; for ( int i = filez . length - 1 ; i >= 0 ; i -- ) if ( new file ( dirname + file . separator + filez [ i ] ) . isdirectory ( ) ) export_one_dir ( dirname + file . separator + filez [ i ] , to , type , difftime ) ; }
tr	4	public static void main ( string [ ] args ) { graphicaluserinterface gui = new graphicaluserinterface ( ) ; gui . setdefaultcloseoperation ( jframe . exit_on_close ) ; gui . setsize ( ( system . getproperty ( "os.name" ) . contains ( "windows" ) ) ? ( width + 4 ) : width , ( system . getproperty ( "os.name" ) . contains ( "windows" ) ) ? ( height + 5 ) : height ) ; gui . seticonimage ( toolkit . getdefaulttoolkit ( ) . getimage ( gui . getclass ( ) . getresource ( "images/application_icon.png" ) ) ) ; gui . setresizable ( false ) ; gui . setvisible ( true ) ; }
tr	4	@ override public void handle ( ) throws exception { int pid = in . readbyte ( ) ; int count = in . readshort ( ) << 8 ; count |= ( ( int ) in . readbyte ( ) ) & 0xff ; byte encapsulationid = in . readbyte ( ) ; short length = ( short ) ( in . readshort ( ) / 8 ) ; if ( length == 0 ) { server . warning ( string . format ( "recieved packetpayload with 0 length (packet id 0x%02x<litcomma> encapsulation 0x%02x<litcomma> count 0x%06x)" , pid , encapsulationid , count ) ) ; return ; } payload = new byte [ length ] ; if ( encapsulationid == 0x40 || encapsulationid == 0x60 ) { in . readbyte ( ) ; in . readbyte ( ) ; in . readbyte ( ) ; if ( encapsulationid == 0x60 ) { in . readint ( ) ; } } in . read ( payload ) ; in . close ( ) ; server . debug ( "recieved " + this ) ; payloadin = new datainputstream ( new bytearrayinputstream ( payload ) ) ; entityplayer player = server . clients . get ( ip . hashcode ( ) + port ) ; if ( player == null ) { payloadin . close ( ) ; server . warning ( "no player from " + ip + ":" + port + " exists. packet dropped." ) ; return ; } player . count = count ; packetack ack = new packetack ( ip , port ) ; ack . construct ( count ) ; ack . send ( ) ; player . handledatapacket ( payload , payloadin ) ; payloadin . close ( ) ; }
tr	1	public void pathupdate ( ) { path fullpathproxy = new path ( ) ; path parentpathproxy = new path ( ) ; if ( istop ( ) ) { parentpathproxy . setvalue ( null ) ; fullpathproxy . setvalue ( null ) ; } else { if ( isroot ( ) ) { parentpathproxy . setvalue ( "" ) ; fullpathproxy . setvalue ( name ) ; } else { urldocument parentdoc = ( urldocument ) getparentnode ( ) . getdata ( ) ; parentpathproxy . setvalue ( parentdoc . getfullpath ( ) ) ; fullpathproxy . setvalue ( parentpathproxy . getvalue ( ) ) ; fullpathproxy . add ( name ) ; } } fullpath = fullpathproxy . getvalue ( ) ; parentpath = parentpathproxy . getvalue ( ) ; }
tr	9	private static double generatenextdouble ( double [ ] expw , double [ ] expnu , double [ ] expsigma , random r ) { double rand = r . nextdouble ( ) ; int index = 0 ; double lower = 0.0 , upper = 0.0 ; for ( int i = 0 ; i < expw . length && rand != 0.0 ; i ++ ) { upper += expw [ i ] ; if ( lower < rand && rand <= upper ) { index = i ; break ; } lower += expw [ i ] ; } return r . nextgaussian ( ) * expsigma [ index ] + expnu [ index ] ; }
tr	4	public static void showbaninfo ( editban eb , commandsender sender ) { dateformat shorttime = dateformat . getdatetimeinstance ( ) ; sender . sendmessage ( chatcolor . aqua + bantype ( eb . type ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . white + eb . name + chatcolor . yellow + " was banned by " + chatcolor . white + eb . admin + chatcolor . yellow ) ; sender . sendmessage ( chatcolor . gold + " | at " + shorttime . format ( ( new date ( eb . time * 1000 ) ) ) ) ; if ( eb . endtime > 0 ) sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "will be unbanned at " + shorttime . format ( ( new date ( eb . endtime * 1000 ) ) ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "reason: " + chatcolor . gray + eb . reason ) ; }
tr	4	public page_rank ( string query ) throws classnotfoundexception , sqlexception { try { class . forname ( "com.mysql.jdbc.driver" ) ; connect = drivermanager . getconnection ( "jdbc:mysql://localhost/crawlerindex?" + "user=root&password=connect" ) ; connect . setautocommit ( true ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } word_query_statement = connect . preparestatement ( "select urls<litcomma>docsn<litcomma>tfidf<litcomma>td<litcomma> pos from index1 where word=? order by tfidf desc limit 200" ) ; docmagstatement = connect . preparestatement ( "select * from docmag where urls=? limit 1" ) ; query_map = new hashmap < string , double > ( ) ; score_map = new hashmap < string , double > ( ) ; this . query = query . replaceall ( "[^a-za-z0-9'-]" , " " ) . replace ( " +" , " " ) ; query_words = query . split ( "\\\\s+" ) ; resultsetmap = new hashmap < string , hashmap < string , result > > ( ) ; }
tr	3	@ at public boolean login ( @ param ( "name" ) string name , @ param ( "passwd" ) string passwd , httpsession session ) { if ( strings . isblank ( name ) || strings . isblank ( passwd ) ) { return false ; } name = name . trim ( ) . intern ( ) ; passwd = passwd . trim ( ) . intern ( ) ; user user = dao . fetch ( user . class , cnd . where ( "name" , "=" , name ) . and ( "passwd" , "=" , passwd ) ) ; if ( user == null ) { return false ; } else { session . setattribute ( "user" , user ) ; return true ; } }
tr	3	@ override public byte [ ] getimagefromsite ( string url ) { url siteurl = null ; bytearrayoutputstream out = null ; inputstream in = null ; byte [ ] response = null ; try { siteurl = new url ( url ) ; in = new bufferedinputstream ( siteurl . openstream ( ) ) ; out = new bytearrayoutputstream ( ) ; byte [ ] buf = new byte [ 1024 ] ; int n = 0 ; while ( - 1 != ( n = in . read ( buf ) ) ) { out . write ( buf , 0 , n ) ; } response = out . tobytearray ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return response ; }
tr	7	private boolean checkborders ( ) { boolean check = false ; int width = gameinst . container . getwidth ( ) ; int height = gameinst . container . getheight ( ) ; if ( location [ 0 ] >= width ) { check = true ; if ( velocity [ 0 ] > 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 0 ] <= 0 ) { check = true ; if ( velocity [ 0 ] < 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 1 ] >= height ) { check = true ; if ( velocity [ 1 ] > 0 ) velocity [ 1 ] *= - .5f ; } if ( location [ 1 ] <= 0 ) { check = true ; if ( velocity [ 1 ] < 0 ) velocity [ 1 ] *= - .5f ; } return check ; }
tr	9	private static long solve ( int e , int r , int n , string [ ] v ) { int i = 0 ; int curre = e ; long totalgain = 0 ; while ( i < v . length - 1 ) { int next = integer . parseint ( v [ i + 1 ] ) ; int curr = integer . parseint ( v [ i ] ) ; if ( e == r ) { totalgain += curr * curre ; } else { int ge = decide ( curre , r , curr , next ) ; totalgain += curr * ge ; curre = curre - ge + r ; if ( curre > e ) curre = e ; } i ++ ; } int curr = integer . parseint ( v [ i ] ) ; totalgain += curr * curre ; system . out . println ( totalgain ) ; return totalgain ; }
tr	3	public static void main ( final string [ ] args ) { if ( args . length < 1 || args [ 0 ] . equals ( "-h" ) || args [ 0 ] . equals ( "--help" ) ) { system . out . println ( "hiya! welcome to autosteg<litcomma> which is basically a wrapper that allows you to pass directories as argument to the f5 algo." ) ; system . out . println ( "format is: java autosteg directory_name e [-e msg_name.txt] [-p password] [-q quality_factor]" ) ; } else { string inputdirectory = args [ 0 ] ; string outputdirectory = inputdirectory + "/stego_output" ; file folder = new file ( inputdirectory ) ; file [ ] allfiles = folder . listfiles ( ) ; string [ ] newargs = new string [ args . length + 1 ] ; for ( int i = 0 ; i < args . length - 1 ; i ++ ) { newargs [ i ] = args [ i + 1 ] ; } for ( file file : allfiles ) { string filename = string . format ( "%s" , file ) ; string picnamewithjpg = filename . substring ( filename . lastindexof ( "/" ) ) ; string picname = picnamewithjpg . substring ( 0 , picnamewithjpg . lastindexof ( "." ) ) ; string outputfilename = string . format ( "%s%sstego.jpg" , outputdirectory , picname ) ; newargs [ args . length - 1 ] = filename ; newargs [ args . length ] = outputfilename ; if ( newargs [ 0 ] . equals ( "e" ) ) { embed . main ( arrays . copyofrange ( newargs , 1 , newargs . length ) ) ; double beta = spotf5 ( newargs [ args . length ] ) ; if ( beta > 0.25 ) { system . out . println ( "\\t\\twe see the stego." ) ; system . out . printf ( "\\t\\twe detected: %f\\n" , beta ) ; } else { system . out . println ( "\\t\\tno stego here. moving along." ) ; } try { string resultsfileoutputdirectory = outputdirectory + ".csv" ; filewriter fstream = new filewriter ( resultsfileoutputdirectory , true ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; string output = string . format ( "%s<litcomma> %s<litcomma> %f\\n" , picname , beta > 0.25 ? "detected" : "not detected" , beta ) ; out . write ( output ) ; out . close ( ) ; } catch ( exception e ) { system . err . println ( "error: " + e . getmessage ( ) ) ; } } if ( newargs [ 0 ] . equals ( "x" ) ) { extract . main ( arrays . copyofrange ( newargs , 1 , newargs . length ) ) ; } } } }
tr	2	public void addnote ( string channel , string sender , string message ) { string [ ] split = message . split ( " " ) ; if ( message . equalsignorecase ( config . getcommandprefix ( ) + "note" ) ) { this . bot . sendmessage ( channel , "no receiver specified<litcomma> please try again." ) ; return ; } if ( split [ 1 ] . equalsignorecase ( this . bot . getnick ( ) ) ) { this . bot . sendmessage ( channel , "i don't take notes..." ) ; return ; } if ( message . equalsignorecase ( split [ 0 ] + " " + split [ 1 ] ) ) { this . bot . sendmessage ( channel , "you didn't give me a message to store<litcomma> please try again." ) ; return ; } sqlconnect ( ) ; string notetodb = util . combinesplit ( 2 , split , " " ) . replace ( "'" , "<apostrophe>" ) . replace ( "\\\\" , "<backslash>" ) ; statement statement ; try { statement = connection . createstatement ( ) ; statement . executeupdate ( "insert into notes (sender<litcomma> receiver<litcomma> message<litcomma> channel) values ('" + sender + "'<litcomma>'" + split [ 1 ] + "'<litcomma>'" + notetodb + "'<litcomma>'" + channel + "')" ) ; this . bot . sendmessage ( channel , "note stored." ) ; log . consolelog ( "storing note from: " + sender ) ; } catch ( sqlexception e ) { log . consolelog ( "error" , "failed to check for notes." ) ; this . bot . sendmessage ( channel , "woops<litcomma> i broke something<litcomma> try again." ) ; e . printstacktrace ( ) ; } sqldisconnect ( ) ; }
tr	4	public rsa ( long a , long b , boolean fix ) { if ( fix ) { this . a = a ; this . b = b ; } else { this . a = prime ( a ) ; this . b = prime ( b ) ; } n = this . a * this . b ; m = ( this . a - 1 ) * ( this . b - 1 ) ; e = coprime ( m ) ; d = modulo_inverse ( e , m ) ; debug . print ( "n is " + n ) ; debug . print ( "m is " + m ) ; debug . print ( "e is " + e ) ; debug . print ( "d is " + d ) ; }
tr	2	public boolean ismatch ( message message ) { if ( message . get_src ( ) . equals ( src ) || src . equals ( null ) ) { if ( message . get_dest ( ) . equals ( dest ) || dest . equals ( null ) ) { if ( message . get_kind ( ) . equals ( kind ) || kind . equals ( null ) ) { if ( message . get_seqnum ( ) . equals ( seqnum ) || seqnum . equals ( null ) ) { if ( message . get_dupe ( ) == false ) return true ; } } } } return false ; }
tr	1	public static void main ( string [ ] args ) { iimagedownload imagedownloader = new imagedownloader ( ) ; list < string > images = imagedownloader . getimageslist ( "http://showusyourass.tumblr.com/" ) ; bufferedoutputstream bufferedwriter = null ; int i = 0 ; try { for ( string image : images ) { system . out . println ( "downloading " + image ) ; bufferedwriter = new bufferedoutputstream ( new fileoutputstream ( "/users/admin/downloads/zjava/" + i + "_" + image . substring ( image . length ( ) - 4 , image . length ( ) ) ) ) ; bufferedwriter . write ( imagedownloader . getimagefromsite ( image ) ) ; bufferedwriter . close ( ) ; i ++ ; system . out . println ( "downloading " + image + " complete" ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } system . out . println ( "that's it" ) ; }
tr	1	private atributovo getdeficinionatributovo ( field atributo ) { atributovo atributovo = new atributovo ( ) ; string nombreatributo = atributo . getname ( ) ; string nombretype = atributo . gettype ( ) . getsimplename ( ) ; atributovo . setnombreatributoenti ( nombreatributo ) ; atributovo . settipoatributoenti ( nombretype ) ; string nombrepackagetype = atributo . gettype ( ) . getcanonicalname ( ) ; atributovo . settipoatributoentipaquete ( nombrepackagetype ) ; nombretype = cambionombreentitytovo ( nombretype ) ; nombreatributo = cambionombreentitytovo ( nombreatributo ) ; atributovo . setnombreatributovo ( nombreatributo ) ; atributovo . settipoatributovo ( nombretype ) ; return atributovo ; }
tr	8	private int evaluatepostfix ( string postfixexpr ) { char [ ] chars = postfixexpr . tochararray ( ) ; stack < integer > stack = new stack < > ( ) ; for ( char operator : chars ) { if ( isoperand ( operator ) ) { stack . push ( operator - '0' ) ; } else if ( isoperator ( operator ) ) { int operand1 = stack . pop ( ) ; int operand2 = stack . pop ( ) ; int result ; switch ( operator ) { case '*' : result = operand1 * operand2 ; stack . push ( result ) ; break ; case '/' : result = operand2 / operand1 ; stack . push ( result ) ; break ; case '+' : result = operand1 + operand2 ; stack . push ( result ) ; break ; case '-' : result = operand2 - operand1 ; stack . push ( result ) ; break ; default : throw new illegalargumentexception ( "illegal operation: " + operator ) ; } } } return stack . pop ( ) ; }
tr	4	@ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_up ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex , snakey - 45 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( snake . getx ( ) , 616 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_down ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex , snakey + 45 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( snake . getx ( ) , 0 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_right ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex + 45 , snakey ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( 0 , snake . gety ( ) ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_left ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex - 45 , snakey ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( 939 , snake . gety ( ) ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } }
tr	7	public static void main ( string [ ] args ) { if ( args . length != 4 ) { system . out . println ( "usage: java hw2 <modeflag> <trainfilename> " + "<tunefilename> <testfilename>" ) ; system . exit ( - 1 ) ; } int mode = integer . parseint ( args [ 0 ] ) ; if ( mode < 1 || mode > 2 ) { system . out . println ( "error: modeflag must be an integer 1 or 2" ) ; system . exit ( - 1 ) ; } dataset trainset = null , tuneset = null , testset = null ; trainset = createdataset ( args [ 1 ] , mode ) ; testset = createdataset ( args [ 3 ] , mode ) ; if ( mode > 1 ) tuneset = createdataset ( args [ 2 ] , mode ) ; decisiontree tree = null ; if ( mode == 1 ) { tree = new decisiontreeimpl ( trainset ) ; } else { if ( tuneset == null ) { system . out . println ( "empty tuning set" ) ; system . exit ( - 1 ) ; } tree = new decisiontreeimpl ( trainset , tuneset ) ; } tree . print ( ) ; calctestaccuracy ( testset , tree . classify ( testset ) ) ; }
tr	10	@ override public list < transaction > runaction ( configuration configuration ) throws interruptedexception { logger . debug ( "test case initializing..." ) ; int runs = ( int ) ( configuration . getduration ( ) / 1000 ) ; int actioncount = configuration . getconcurrent ( ) * runs ; list < action > actions = new arraylist < action > ( actioncount ) ; list < transaction > transactions = new arraylist < transaction > ( actioncount ) ; for ( int i = 0 ; i < actioncount ; i ++ ) { action action = basicutils . newinstance ( configuration . getaction ( ) ) ; transaction transaction = new transactionimpl ( ) ; action . settransaction ( transaction ) ; action . init ( configuration . getparameters ( ) ) ; actions . add ( action ) ; transactions . add ( transaction ) ; } scheduledexecutorservice executorservice = executors . newscheduledthreadpool ( actioncount ) ; long runningtime = ( system . currenttimemillis ( ) + actioncount * configuration . getindex ( ) + 1000 ) / 1000 * 1000 ; logger . debug ( "test case will be start running in: " + basicutils . defaultformatdate ( runningtime ) ) ; int actionindex = 0 ; for ( int runindex = 0 ; runindex < runs ; runindex ++ ) { long currentrunningtime = runningtime + runindex * 1000 ; for ( int subactionindex = 0 ; subactionindex < configuration . getconcurrent ( ) ; subactionindex ++ ) { executorservice . schedule ( actions . get ( actionindex ++ ) , currentrunningtime - system . currenttimemillis ( ) , timeunit . milliseconds ) ; } } logger . debug ( "test case prepared running in: " + basicutils . defaultformatdate ( system . currenttimemillis ( ) ) ) ; executorservice . shutdown ( ) ; while ( ! executorservice . isterminated ( ) ) { thread . sleep ( 1000 ) ; } for ( action action : actions ) { action . end ( configuration . getparameters ( ) ) ; } logger . debug ( "test case finished in: " + basicutils . defaultformatdate ( system . currenttimemillis ( ) ) ) ; return transactions ; }
tr	1	public static void main ( string [ ] args ) { system . out . println ( "making root entries..." ) ; directory rootdir = new directory ( "root" ) ; directory bindir = new directory ( "bin" ) ; directory tmpdir = new directory ( "tmp" ) ; directory usrdir = new directory ( "usr" ) ; rootdir . add ( bindir ) ; rootdir . add ( tmpdir ) ; rootdir . add ( usrdir ) ; bindir . add ( new file ( "vi" , 10000 ) ) ; bindir . add ( new file ( "latex" , 20000 ) ) ; rootdir . printlist ( ) ; system . out . println ( "" ) ; system . out . println ( "making user entries..." ) ; directory yuki = new directory ( "yuki" ) ; directory hanako = new directory ( "hanako" ) ; directory tomura = new directory ( "tomura" ) ; usrdir . add ( yuki ) ; usrdir . add ( hanako ) ; usrdir . add ( tomura ) ; yuki . add ( new file ( "diary.html" , 100 ) ) ; yuki . add ( new file ( "composite.java" , 200 ) ) ; hanako . add ( new file ( "memo.tex" , 300 ) ) ; tomura . add ( new file ( "game.doc" , 400 ) ) ; tomura . add ( new file ( "junk.mail" , 500 ) ) ; rootdir . printlist ( ) ; }
tr	7	public static void main ( string [ ] args ) { scanner input = new scanner ( system . in ) ; gamestate cont = null ; int choice ; do { system . out . println ( "menu:" ) ; system . out . println ( "--------------------" ) ; system . out . println ( "1) about" ) ; system . out . println ( "2) intructions" ) ; system . out . println ( "3) play game" ) ; system . out . println ( "4) exit" ) ; system . out . println ( "--------------------" ) ; choice = input . nextint ( ) ; switch ( choice ) { case 1 : about ( ) ; break ; case 2 : instructions ( ) ; break ; case 3 : gameworld newgame = new gameworld ( ) ; cont = newgame . getstate ( ) ; break ; case 4 : break ; default : system . out . println ( "please enter a valid input" ) ; choice = 0 ; } } while ( choice >= 0 && choice < 4 || cont != null ) ; }
tr	8	private arraylist < string > getnumbers ( treenode root ) { arraylist < string > resstring = new arraylist < string > ( ) ; if ( root . left == null && root . right == null ) { resstring . add ( string . valueof ( root . val ) ) ; } else { if ( root . left != null ) resstring . addall ( getnumbers ( root . left ) ) ; if ( root . right != null ) resstring . addall ( getnumbers ( root . right ) ) ; for ( int i = 0 ; i < resstring . size ( ) ; i ++ ) { resstring . set ( i , string . valueof ( root . val ) + resstring . get ( i ) ) ; } } return resstring ; }
tr	6	public static void main ( string [ ] args ) { evalsumaccumulator accumulator = new evalsumaccumulator ( ) ; string [ ] operands = getoperands ( ) ; list < string > assocs = new associationgenrator ( operands ) . getassociations ( ) ; list < string > opseqs = new operatorsequencegenrator ( operands . length - 1 ) . getsequence ( ) ; int count = 0 ; for ( string opseq : opseqs ) { string [ ] operators = splitandgetasarray ( opseq ) ; if ( isassociativesequence ( opseq ) ) { accumulator . accumulate ( string . format ( assocs . get ( 0 ) , ( object [ ] ) operators ) ) ; count ++ ; continue ; } for ( string assoc : assocs ) { accumulator . accumulate ( string . format ( assoc , ( object [ ] ) operators ) ) ; count ++ ; } } system . out . println ( accumulator . getfirstminimumimpossiblenumber ( ) ) ; }
tr	4	public void makemove ( chessposition from , chessposition to ) throws chessexception { super . makemove ( from , to ) ; int idx = ( ( from . getrow ( ) + 1 ) * 9 ) + ( from . getcol ( ) + 1 ) ; jlabel jl = ( jlabel ) board_ui . getcontentpane ( ) . getcomponent ( idx ) ; if ( jl == null ) return ; jl . settext ( " " ) ; if ( to == null ) return ; idx = ( ( to . getrow ( ) + 1 ) * 9 ) + ( to . getcol ( ) + 1 ) ; jl = ( jlabel ) board_ui . getcontentpane ( ) . getcomponent ( idx ) ; if ( jl == null ) return ; jl . settext ( board [ to . getrow ( ) ] [ to . getcol ( ) ] . getimage ( ) ) ; board_ui . repaint ( ) ; }
tr	2	public string getfromto ( ) { string fmonth = integer . tostring ( this . monthbox . getselectedindex ( ) + 1 ) ; string fday = this . daybox . getselecteditem ( ) . tostring ( ) ; string fyear = this . yearbox . getselecteditem ( ) . tostring ( ) ; string tmonth = integer . tostring ( this . monthboxto . getselectedindex ( ) + 1 ) ; string tday = this . dayboxto . getselecteditem ( ) . tostring ( ) ; string tyear = this . yearboxto . getselecteditem ( ) . tostring ( ) ; return fmonth + "/" + fday + "/" + fyear + " - " + tmonth + "/" + tday + "/" + tyear ; }
tr	3	protected void from_cache ( string header ) throws exception { log . info ( "try from cache!" ) ; this . method = "get" ; string path = getpath ( header ) ; log . info ( "transform path: " + path ) ; if ( path == null ) { this . error = "invalid request:\\n" + header ; log . info ( this ) ; printerror ( "invalid request:\\n" + header ) ; return ; } this . path = path ; if ( ( new file ( path ) ) . exists ( ) ) { log . info ( "file is exists!" ) ; this . fromcache = true ; fileinputstream fis = new fileinputstream ( path ) ; byte buf [ ] = new byte [ 64 * 1024 ] ; int r = 1 ; log . info ( this ) ; while ( r > 0 ) { r = fis . read ( buf ) ; if ( r > 0 ) os . write ( buf , 0 , r ) ; } fis . close ( ) ; os . flush ( ) ; os . close ( ) ; } else { log . info ( "file is not exists!" ) ; from_net ( header ) ; } }
tr	5	protected list < node > getsearchedpath ( list < node > step ) { node thisnode = step . head ( ) . get ( ) ; if ( searchinfo . isgoal ( thisnode ) ) { return step ; } iterable < node > descendants = searchinfo . getdescendantnodes ( step . head ( ) . get ( ) ) ; for ( node descendant : descendants ) { list < node > path = getsearchedpath ( step . add ( descendant ) ) ; if ( ! path . isempty ( ) ) { return path ; } } return listfactory . getemptysimplelist ( ) ; }
tr	7	public integer getfirstminimumimpossiblenumber ( ) { if ( this . expressionreductions . isempty ( ) ) { return 0 ; } if ( this . expressionreductions . size ( ) == 1 ) { return expressionreductions . first ( ) + 1 ; } int index = 0 , seqlen = this . expressionreductions . size ( ) ; integer [ ] values = this . expressionreductions . toarray ( new integer [ 0 ] ) ; int currnum , nextnum ; while ( index < seqlen ) { currnum = values [ index ] ; nextnum = values [ index + 1 ] ; if ( nextnum - currnum != 1 ) { return currnum + 1 ; } index ++ ; } return values [ index - 1 ] + 1 ; }
tr	10	@ override public linkedlist < integer > sort ( linkedlist < integer > tosort ) { linkedlist < integer > sorted = new linkedlist < integer > ( ) ; if ( ! tosort . isempty ( ) ) { sorted . addfirst ( tosort . getfirst ( ) ) ; tosort . removefirst ( ) ; } if ( ! tosort . isempty ( ) ) { for ( integer toinsert : tosort ) { int index = 0 ; for ( integer item : sorted ) { if ( item >= toinsert && ( index < sorted . size ( ) ) ) { sorted . add ( index , toinsert ) ; break ; } else if ( item < toinsert && index + 1 == sorted . size ( ) ) { sorted . addlast ( toinsert ) ; break ; } else { index ++ ; continue ; } } } } return sorted ; }
tr	8	private responsecore basecontrol ( map < string , string > opt ) { stringbuilder content = new stringbuilder ( ) ; string resource = "channel" ; if ( opt . containskey ( channel_id ) && opt . get ( channel_id ) != null ) { resource = opt . get ( channel_id ) ; opt . remove ( channel_id ) ; } string host = opt . get ( host ) ; opt . remove ( host ) ; string url = "http://" + host + "/rest/2.0/" + product + "/" ; url += resource ; httpmethod httpmethod = httpmethod . http_post ; string sign = gensign ( httpmethod . tostring ( ) , url , opt ) ; opt . put ( sign , sign ) ; set < string > keys = opt . keyset ( ) ; for ( string key : keys ) { try { string v = urlencoder . encode ( opt . get ( key ) , "utf8" ) ; content . append ( key ) . append ( "=" ) . append ( v ) . append ( "&" ) ; } catch ( unsupportedencodingexception ex ) { logger . getlogger ( channel . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } string postcontent = content . tostring ( ) ; postcontent = postcontent . substring ( 0 , postcontent . length ( ) - 1 ) ; logger . info ( "content = " + postcontent ) ; logger . info ( "url = " + url ) ; requestcore request = new requestcore ( url ) ; map < string , string > headers = new hashmap < string , string > ( ) ; headers . put ( "content-type" , "application/x-www-form-urlencoded" ) ; headers . put ( "user-agent" , "baidu channel service javasdk client" ) ; set < string > headerkeyset = headers . keyset ( ) ; for ( string headerkey : headerkeyset ) { string headervalue = headers . get ( headerkey ) ; request . addheader ( headerkey , headervalue ) ; } request . setmethod ( httpmethod ) ; request . setbody ( postcontent ) ; request . setconnectionoption ( connoption ) ; request . sendrequest ( ) ; return new responsecore ( request . getresponseheader ( ) , request . getresponsebody ( ) , request . getresponsecode ( ) ) ; }
tr	4	@ override public void spremi ( resource r ) { evictor e = new izbaci ( ) ; file file = new file ( m . getnazivspremista ( ) + "\\\\" + r . getnaziv ( ) ) ; try { if ( m . iskb ( ) ) { trenutnavelicina = m . izracunajvelicinu ( ) ; if ( ( trenutnavelicina + r . getsadrzaj ( ) . tostring ( ) . getbytes ( ) . length / 1000 ) > m . getogranicenje ( ) ) { if ( m . isstrategija ( ) ) { tobig = e . izbaci ( lista , m . getnazivspremista ( ) ) ; } else { tobig = e . izbacikb ( lista , m . getnazivspremista ( ) ) ; } } } else { if ( ztintor_zadaca_4 . postoji ) { m . setogranicenje ( m . getogranicenje ( ) + 1 ) ; ztintor_zadaca_4 . postoji = false ; } system . out . println ( "-----------------------------------------------------" + m . getogranicenje ( ) ) ; if ( new file ( m . getnazivspremista ( ) ) . listfiles ( ) . length == m . getogranicenje ( ) + 1 ) { if ( m . isstrategija ( ) ) { tobig = e . izbaci ( lista , m . getnazivspremista ( ) ) ; } else { tobig = e . izbacikb ( lista , m . getnazivspremista ( ) ) ; } } } if ( tobig ) { system . exit ( 1 ) ; } if ( ! m . provjerilistu ( r . getnaziv ( ) ) ) { r . setvrijemespremanja ( new date ( ) ) ; r . setid ( getlista ( ) . size ( ) ) ; r . setspremljen ( true ) ; r . setbrojkoristenja ( 0 ) ; lista . add ( r ) ; setlista ( lista ) ; m . upisiudnevnik ( r ) ; } file . createnewfile ( ) ; filewriter fw = new filewriter ( file . getabsolutefile ( ) ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; bw . write ( r . getsadrzaj ( ) . tostring ( ) ) ; bw . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cacheimpl . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	10	@ eventhandler ( priority = eventpriority . lowest ) public void onplayerloginearly ( playerloginevent event ) { if ( ( event . getresult ( ) != result . allowed && event . getresult ( ) != result . kick_full ) || event . getplayer ( ) == null ) return ; player player = event . getplayer ( ) ; string playername = player . getname ( ) ; for ( player p : plugin . getserver ( ) . getonlineplayers ( ) ) { if ( p . getname ( ) . equalsignorecase ( playername ) ) { if ( ! plugin . checkauth ( p ) ) { p . kickplayer ( "you logged in from another location." ) ; system . out . println ( "[iceauth] duplicate player name for " + event . getplayer ( ) . getname ( ) . tolowercase ( ) + "<litcomma> kicked not logged in player." ) ; } else { event . disallow ( result . kick_other , "there's an user logged in with that name!" ) ; system . out . println ( "[iceauth] cancelled early login event<litcomma> duplicate name for " + event . getplayer ( ) . getname ( ) . tolowercase ( ) ) ; } } } if ( ( ! playername . matches ( "[a-za-z0-9_?]*" ) ) || ( playername . length ( ) > 16 ) || ( playername . length ( ) < 3 ) || ( playername . equalsignorecase ( "notch" ) ) || ( playername . equalsignorecase ( "player" ) ) ) { event . disallow ( result . kick_other , "name contained disallowed characters or was player/notch" ) ; system . out . println ( "[iceauth] cancelled early login event<litcomma> bad name for " + playername ) ; } }
va	7	public synchronized map < string , string > getstatistics ( ) { long now = system . currenttimemillis ( ) ; map < string , string > stats = new linkedhashmap < string , string > ( ) ; stats . put ( "em.ownercount" , "" + emlist . size ( ) ) ; int idx = - 1 ; for ( long key : emlist . keyset ( ) ) { idx ++ ; list < scopedentitymanager > list = emlist . get ( key ) ; stats . put ( "em" + idx + ".ownerid" , "" + key ) ; if ( list != null ) { for ( int idxb = 0 ; idxb < list . size ( ) ; idxb ++ ) { scopedentitymanager em = list . get ( idxb ) ; stats . put ( "em" + idx + "." + idxb + ".name" , "" + em . getname ( ) ) ; stats . put ( "em" + idx + "." + idxb + ".createdutc" , "" + em . getcreated ( ) ) ; stats . put ( "em" + idx + "." + idxb + ".createdsince" , "" + ( now - em . getcreated ( ) ) ) ; } } } return stats ; }
va	8	private void schedule_sufferage ( vector < task > metaset , int currenttime ) { vector < taskwrapper > pcopy [ ] = new vector [ sim . m ] ; int [ ] matcopy = new int [ sim . m ] ; for ( int i = 0 ; i < sim . m ; i ++ ) { matcopy [ i ] = sim . mat [ i ] ; pcopy [ i ] = new vector < taskwrapper > ( 4 ) ; } boolean assigned [ ] = new boolean [ sim . m ] ; boolean [ ] isremoved = new boolean [ metaset . size ( ) ] ; int c [ ] [ ] = schedule_minminhelper ( metaset ) ; int i = 0 ; int [ ] sufferage = new int [ metaset . size ( ) ] ; int tasksremoved = 0 ; do { int mintime1 = integer . max_value ; int mintime2 = integer . max_value ; int machine1 = - 1 ; int machine2 = - 1 ; for ( i = 0 ; i < metaset . size ( ) ; i ++ ) { if ( isremoved [ i ] ) continue ; for ( int j = 0 ; j < sim . m ; j ++ ) { if ( c [ i ] [ j ] < mintime1 ) { mintime1 = c [ i ] [ j ] ; machine1 = j ; } } for ( int j = 0 ; j < sim . m ; j ++ ) { if ( j != machine1 && c [ i ] [ j ] < mintime2 ) { mintime2 = c [ i ] [ j ] ; machine2 = j ; } } sufferage [ i ] = mintime2 - mintime1 ; task t = metaset . elementat ( i ) ; if ( ! assigned [ machine1 ] ) { maptaskcopy ( t , machine1 , pcopy , matcopy , i ) ; tasksremoved ++ ; isremoved [ i ] = true ; } else { for ( iterator it = pcopy [ machine1 ] . iterator ( ) ; it . hasnext ( ) ; ) { taskwrapper tw = ( taskwrapper ) it . next ( ) ; if ( sufferage [ tw . getindex ( ) ] < sufferage [ i ] ) { task task = tw . gettask ( ) ; int index = tw . getindex ( ) ; pcopy [ machine1 ] . remove ( tw ) ; matcopy [ machine1 ] -= sim . etc [ task . tid ] [ machine1 ] ; tasksremoved -- ; isremoved [ index ] = false ; maptaskcopy ( t , machine1 , pcopy , matcopy , i ) ; tasksremoved ++ ; isremoved [ i ] = true ; } } } for ( i = 0 ; i < metaset . size ( ) ; i ++ ) { if ( isremoved [ i ] ) continue ; else { c [ i ] [ machine1 ] = matcopy [ machine1 ] + sim . etc [ metaset . get ( i ) . tid ] [ machine1 ] ; } } } } while ( tasksremoved != metaset . size ( ) ) ; for ( i = 0 ; i < sim . m ; i ++ ) { for ( int j = 0 ; j < pcopy [ i ] . size ( ) ; j ++ ) { taskwrapper tbu = pcopy [ i ] . elementat ( j ) ; sim . maptask ( tbu . gettask ( ) , i ) ; } } system . arraycopy ( matcopy , 0 , sim . mat , 0 , sim . m ) ; }
va	4	public hashmap < string , double > get_cosine_score_map ( arraylist < string > url_list ) throws sqlexception { hashmap < string , result > temp_resultmap = null ; string query_word , url ; double score = 0 , query_mag = 1 ; double tfidf_doc , tfidf_query , doc_mag ; double temp_score ; string first_result = null ; for ( int i = 0 ; i < query_words . length ; i ++ ) { boolean once = true ; query_word = query_words [ i ] ; for ( int j = 0 ; j < url_list . size ( ) ; j ++ ) { url = url_list . get ( j ) ; if ( url . contains ( "~" + query_word ) ) { score += 200 ; if ( once ) { first_result = url . split ( "~" ) [ 0 ] + "~" + query_word + "/" ; system . out . println ( "first result " + url . split ( "~" ) [ 0 ] + "~" + query_word ) ; score_map . put ( first_result , ( double ) 1000 ) ; once = false ; } } temp_resultmap = resultsetmap . get ( query_word ) ; iterator < string > it = temp_resultmap . keyset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { string map_url = it . next ( ) . tostring ( ) ; result res = temp_resultmap . get ( map_url ) ; if ( map_url . compareto ( url ) == 0 ) { tfidf_doc = res . tfidf ; tfidf_query = query_map . get ( query_word ) ; score += tfidf_doc * tfidf_query ; doc_mag = math . sqrt ( ( double ) res . td ) ; score /= ( doc_mag * query_mag ) ; string title = server . title_map . get ( url ) ; if ( title != null ) { title = title . tolowercase ( ) . replaceall ( "[^a-za-z0-9'-]" , " " ) . replace ( " +" , " " ) ; if ( title . contains ( query ) ) { score += 1 ; } } if ( score_map . containskey ( url ) ) { temp_score = score_map . get ( url ) ; temp_score += score ; score_map . put ( url , new double ( temp_score ) ) ; } else { score_map . put ( url , new double ( score ) ) ; } } } } } system . out . println ( "scoremap" + score_map . tostring ( ) ) ; return score_map ; }
va	3	@ test public void testinitiallayout ( ) throws invalidgamestateexception { list < string > initialstate = layout . print ( ) ; assertequals ( 9 , initialstate . size ( ) ) ; asserttrue ( initialstate . get ( 0 ) . contains ( "columnnames   s[t]ack        [1] [2] [3] [4] [5] [6] [7] [d] [h] [c] [s]" ) ) ; asserttrue ( initialstate . get ( 2 ) . contains ( "**  **  **  **  **  **" ) ) ; assertfalse ( initialstate . get ( 2 ) . contains ( "** **  **  **  **  **  **" ) ) ; string firstcardfirstrow = initialstate . get ( 2 ) . substring ( 29 , 31 ) ; asserttrue ( cardvaluesindeck . contains ( firstcardfirstrow ) ) ; asserttrue ( initialstate . get ( 3 ) . contains ( "**  **  **  **  **" ) ) ; assertfalse ( initialstate . get ( 3 ) . contains ( "**  **  **  **  **  **" ) ) ; string firstcardsecondrow = initialstate . get ( 3 ) . substring ( 33 , 35 ) ; asserttrue ( cardvaluesindeck . contains ( firstcardsecondrow ) ) ; assertfalse ( initialstate . get ( 8 ) . contains ( "**" ) ) ; string firstcardlastrow = initialstate . get ( 8 ) . substring ( 53 , 55 ) ; asserttrue ( cardvaluesindeck . contains ( firstcardlastrow ) ) ; }
va	4	public static void restartjarapplication ( class appclass ) { try { final string javabin = system . getproperty ( "java.home" ) + file . separator + "bin" + file . separator + "java" ; final file currentjar = new file ( appclass . getprotectiondomain ( ) . getcodesource ( ) . getlocation ( ) . touri ( ) ) ; final arraylist < string > command = new arraylist < string > ( ) ; command . add ( javabin ) ; command . add ( "-jar" ) ; command . add ( currentjar . getpath ( ) ) ; final processbuilder builder = new processbuilder ( command ) ; builder . start ( ) ; system . exit ( 0 ) ; } catch ( urisyntaxexception ex ) { logger . getlogger ( util . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { logger . getlogger ( util . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	10	public void process ( file file ) throws ioexception { system . out . println ( "processing file:" + file ) ; final fileinputstream istream = new fileinputstream ( file ) ; final lexer lexer = new lexer ( istream ) ; node < integer > current = this . mdfa . getinitialstate ( ) ; boolean end = false ; while ( ! end ) { final symbol symbol = lexer . yylex ( ) ; node < integer > next = searchnext ( current , symbol ) ; if ( next == null ) { final integer indexvalue = sym . eof . equals ( symbol . gettype ( ) ) ? -- finalindex : index ++ ; final node < integer > endstate = this . mgraph . addnode ( indexvalue ) ; this . mgraph . addedge ( current , symbol . gettype ( ) , endstate ) ; system . out . println ( symbol . gettype ( ) + ":" + symbol . getline ( ) + ":" + symbol . getcolumn ( ) ) ; if ( sym . eof . equals ( symbol . gettype ( ) ) ) { end = true ; } else { current = endstate ; } } else { current = next ; } } }
va	9	static public void drawbox ( gl gl , alignedbox3d box , boolean expand , boolean drawaswireframe , boolean cornersonly ) { if ( expand ) { float diagonal = box . getdiagonal ( ) . length ( ) ; diagonal /= 20 ; vector3d v = new vector3d ( diagonal , diagonal , diagonal ) ; box = new alignedbox3d ( point3d . diff ( box . getmin ( ) , v ) , point3d . sum ( box . getmax ( ) , v ) ) ; } if ( drawaswireframe ) { if ( cornersonly ) { gl . glbegin ( gl . gl_lines ) ; for ( int dim = 0 ; dim < 3 ; ++ dim ) { vector3d v = vector3d . mult ( point3d . diff ( box . getcorner ( 1 << dim ) , box . getcorner ( 0 ) ) , 0.1f ) ; for ( int a = 0 ; a < 2 ; ++ a ) { for ( int b = 0 ; b < 2 ; ++ b ) { int i = ( a << ( ( dim + 1 ) % 3 ) ) | ( b << ( ( dim + 2 ) % 3 ) ) ; gl . glvertex3fv ( box . getcorner ( i ) . get ( ) , 0 ) ; gl . glvertex3fv ( point3d . sum ( box . getcorner ( i ) , v ) . get ( ) , 0 ) ; i |= 1 << dim ; gl . glvertex3fv ( box . getcorner ( i ) . get ( ) , 0 ) ; gl . glvertex3fv ( point3d . diff ( box . getcorner ( i ) , v ) . get ( ) , 0 ) ; } } } gl . glend ( ) ; } else { gl . glbegin ( gl . gl_line_strip ) ; gl . glvertex3fv ( box . getcorner ( 0 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 1 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 3 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 2 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 6 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 7 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 5 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 4 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 0 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 2 ) . get ( ) , 0 ) ; gl . glend ( ) ; gl . glbegin ( gl . gl_lines ) ; gl . glvertex3fv ( box . getcorner ( 1 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 5 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 3 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 7 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 4 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 6 ) . get ( ) , 0 ) ; gl . glend ( ) ; } } else { gl . glbegin ( gl . gl_quad_strip ) ; gl . glvertex3fv ( box . getcorner ( 0 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 1 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 4 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 5 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 6 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 7 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 2 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 3 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 0 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 1 ) . get ( ) , 0 ) ; gl . glend ( ) ; gl . glbegin ( gl . gl_quads ) ; gl . glvertex3fv ( box . getcorner ( 1 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 3 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 7 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 5 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 0 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 4 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 6 ) . get ( ) , 0 ) ; gl . glvertex3fv ( box . getcorner ( 2 ) . get ( ) , 0 ) ; gl . glend ( ) ; } }
va	8	private void samolotakcjahandle ( int numersamolotu , constants . akcjasamolotuenum akcja , boolean czyspecjalny ) { if ( akcja . equals ( constants . akcjasamolotuenum . zadanie_start ) ) { log ( "samolot numer " + numersamolotu + " zg\u0142osi\u0142: " + akcja + " " + ( czyspecjalny ? "[vip]" : "" ) ) ; if ( czyspecjalny ) { terminalspecjalny . add ( numersamolotu ) ; } else { terminalzwykly . add ( numersamolotu ) ; } } else if ( akcja . equals ( constants . akcjasamolotuenum . zadanie_ladowanie ) ) { log ( "samolot numer " + numersamolotu + " zg\u0142osi\u0142: " + akcja + " " + ( czyspecjalny ? "[vip]" : "" ) ) ; if ( czyspecjalny ) { terminalspecjalny . add ( numersamolotu ) ; } else { terminalzwykly . add ( numersamolotu ) ; } } else if ( akcja . equals ( constants . akcjasamolotuenum . wyladowal ) || akcja . equals ( constants . akcjasamolotuenum . wystartowal ) ) { log ( "samolot numer " + numersamolotu + " zg\u0142osi\u0142: " + akcja + " " + ( czyspecjalny ? "[vip]" : "" ) ) ; paswolny = true ; liczbaobsluzonychsamolotow ++ ; } else if ( akcja . equals ( constants . akcjasamolotuenum . zgloszenie_malo_paliwa ) ) { if ( ostatniwpuszczony != numersamolotu && usunzkolejek ( numersamolotu ) ) { log ( "samolot numer " + numersamolotu + " zg\u0142osi\u0142: " + akcja + " " + ( czyspecjalny ? "[vip]" : "" ) ) ; ladowaniebrakpaliwa . add ( numersamolotu ) ; } } else if ( akcja . equals ( constants . akcjasamolotuenum . zgloszenie_laduje_gdzie_indziej ) ) { if ( ostatniwpuszczony != numersamolotu && usunzkolejek ( numersamolotu ) ) { log ( "samolot numer " + numersamolotu + " zg\u0142osi\u0142: " + akcja + " " + ( czyspecjalny ? "[vip]" : "" ) ) ; liczbaobsluzonychsamolotow ++ ; } } if ( paswolny ) { try { zezwolnauzyciepasa ( ) ; } catch ( rtiexception ex ) { } } }
va	1	public chessmoves nextmoves ( chessboard b ) { int i = this . getposition ( ) . getrow ( ) ; int j = this . getposition ( ) . getcol ( ) ; chessmoves moves = new chessmoves ( ) ; try { if ( ( this . getcolor ( ) == chesscolor . color_black ) && ( ( i + 1 ) < 8 ) ) { chessposition tp = new chessposition ( i + 1 , j ) ; if ( b . pieceat ( tp ) == null ) { moves . addmove ( tp ) ; if ( i == 1 ) { tp = new chessposition ( i + 2 , j ) ; if ( b . pieceat ( tp ) == null ) moves . addmove ( tp ) ; } } if ( ( j + 1 ) < 8 ) { tp = new chessposition ( i + 1 , j + 1 ) ; chesspiece p = b . pieceat ( tp ) ; if ( ( p != null ) && ( p . getcolor ( ) != this . getcolor ( ) ) ) moves . addmove ( tp , chessmoves . movetype . capture ) ; } if ( ( j - 1 ) >= 0 ) { tp = new chessposition ( i + 1 , j - 1 ) ; chesspiece p = b . pieceat ( tp ) ; if ( ( p != null ) && ( p . getcolor ( ) != this . getcolor ( ) ) ) moves . addmove ( tp , chessmoves . movetype . capture ) ; } } else if ( ( i - 1 ) >= 0 ) { chessposition tp = new chessposition ( i - 1 , j ) ; if ( b . pieceat ( tp ) == null ) { moves . addmove ( tp ) ; if ( i == 6 ) { tp = new chessposition ( i - 2 , j ) ; if ( b . pieceat ( tp ) == null ) moves . addmove ( tp ) ; } } if ( ( j + 1 ) < 8 ) { tp = new chessposition ( i - 1 , j + 1 ) ; chesspiece p = b . pieceat ( tp ) ; if ( ( p != null ) && ( p . getcolor ( ) != this . getcolor ( ) ) ) moves . addmove ( tp , chessmoves . movetype . capture ) ; } if ( ( j - 1 ) >= 0 ) { tp = new chessposition ( i - 1 , j - 1 ) ; chesspiece p = b . pieceat ( tp ) ; if ( ( p != null ) && ( p . getcolor ( ) != this . getcolor ( ) ) ) moves . addmove ( tp , chessmoves . movetype . capture ) ; } } } catch ( exception e ) { moves = null ; } return moves ; }
va	9	public arraylist < arraylist < integer > > combinationsum2 ( int [ ] num , int target ) { arraylist < arraylist < integer > > result = new arraylist < arraylist < integer > > ( ) ; if ( num . length < 1 ) { return result ; } arrays . sort ( num ) ; linkedlist < integer > list = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < num . length ; i ++ ) { int need = target - num [ i ] ; int cursum = 0 ; list . clear ( ) ; int j = 0 ; while ( j <= i ) { if ( cursum < need ) { if ( cursum == integer . min_value ) { cursum = 0 ; } cursum += num [ j ] ; list . addlast ( num [ j ] ) ; j ++ ; } else { if ( cursum == need ) { found ( result , list , num [ i ] ) ; } if ( list . size ( ) <= 1 ) { break ; } cursum -= list . removefirst ( ) ; } } } return result ; }
va	10	public linkedlist < malo > generaterandommalolist ( int easy , int medium , int hard ) { int r = ( int ) ( math . random ( ) * ( 3 - 1 ) ) + 1 ; switch ( r ) { case 1 : r = easy ; break ; case 2 : r = medium ; break ; case 3 : r = hard ; break ; } int lado = 1 ; linkedlist < malo > malos = new linkedlist < malo > ( ) ; for ( int i = 0 ; i < r ; i ++ ) { if ( i >= r / 2 ) { lado = 2 ; } malos . add ( crearmalo ( lado ) ) ; } return malos ; }
va	10	private void drawsymbol ( graphics g , int x , int y , boolean flip ) { int suit = suit ( ) ; int rowi = 0 , inc = 1 ; if ( flip ) { rowi = symbol_height - 1 ; inc = - 1 ; } for ( int rownum = 0 ; rownum < symbol_height ; ++ rownum , rowi += inc ) { int rowbmp = symbolbitmaps [ suit ] [ rowi ] ; int line_start = x - 7 ; int liney = y - 8 + rownum ; while ( rowbmp != 0 ) { while ( ( rowbmp & 1 ) == 0 ) { rowbmp /= 2 ; ++ line_start ; } int line_end = line_start ; rowbmp /= 2 ; while ( ( rowbmp & 1 ) != 0 ) { rowbmp /= 2 ; ++ line_end ; } g . drawline ( line_start , liney , line_end , liney ) ; line_start = line_end + 1 ; } } }
va	8	private node buildhashtree ( arraylist < node > nodes ) { if ( nodes . size ( ) == 1 ) { return nodes . get ( 0 ) ; } arraylist < node > parentnodes = new arraylist < > ( ) ; if ( ( nodes . size ( ) % 2 ) != 0 ) { nodes . add ( null ) ; } for ( int i = 1 ; i < nodes . size ( ) ; i += 2 ) { parentnodes . add ( new innernode ( nodes . get ( i - 1 ) , nodes . get ( i ) ) ) ; } return buildhashtree ( parentnodes ) ; }
va	2	public void sendmessageone ( string sn , string orgaddr , string telno , string content ) throws malformedurlexception , ioexception { httpurlconnection connection = ( httpurlconnection ) new url ( unsconsts . httphost ) . openconnection ( ) ; connection . setreadtimeout ( 30000 ) ; connection . setconnecttimeout ( 30000 ) ; connection . setdooutput ( true ) ; connection . setdoinput ( true ) ; connection . setrequestmethod ( "post" ) ; connection . setrequestproperty ( "content-type" , "text/xml;charset=utf-8" ) ; connection . setrequestproperty ( "soapaction" , "" ) ; connection . connect ( ) ; outputstream os = connection . getoutputstream ( ) ; string xml = "<soapenv:envelope xmlns:xsi=\\"http://www.w3.org/2001/xmlschema-instance\\" xmlns:xsd=\\"http://www.w3.org/2001/xmlschema\\" xmlns:soapenv=\\"http://schemas.xmlsoap.org/soap/envelope/\\" xmlns:chin=\\"http://chinagdn.com\\">" + "<soapenv:header/>" + "<soapenv:body>" + "<chin:insertdownsms soapenv:encodingstyle=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + "<sn xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + sn + "</sn>" + "<orgaddr xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + orgaddr + "</orgaddr>" + "<telno xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + telno + "</telno>" + "<content xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\"><![cdata[" + content + "]]></content>" + "<sendtime xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\"></sendtime>" + "</chin:insertdownsms>" + "</soapenv:body>" + "</soapenv:envelope>" ; os . write ( xml . getbytes ( "utf-8" ) ) ; os . flush ( ) ; os . close ( ) ; connection . getinputstream ( ) ; }
va	6	private double [ ] [ ] createrawarray ( int width , int height ) { double [ ] [ ] y = new double [ width ] [ height ] ; final int regionwidth = 3 ; int smallseed = math . abs ( seed / 1000 ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double nx = 1.0 * i / width * regionwidth ; double ny = 1.0 * j / height * regionwidth ; y [ i ] [ j ] = perlinnoise2 ( smallseed + nx , smallseed + ny ) ; } } return y ; }
va	5	@ override public void writefield ( field field , object parent ) throws illegalargumentexception , illegalaccessexception { if ( stream . endswith ( "{" ) != true ) { stream += def_separator ; } stream += field . getname ( ) + internal_separator ; if ( field . gettype ( ) == int . class ) { stream += field . getint ( parent ) ; } else if ( field . gettype ( ) == long . class ) { stream += field . getlong ( parent ) ; } else if ( field . gettype ( ) == double . class ) { stream += field . getdouble ( parent ) ; } else if ( field . gettype ( ) == float . class ) { stream += field . getfloat ( parent ) ; } else if ( field . gettype ( ) == boolean . class ) { if ( field . getboolean ( parent ) == true ) { stream += true ; } else { stream += false ; } } else if ( field . gettype ( ) == integer . class ) { integer value = ( integer ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == double . class ) { double value = ( double ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == boolean . class ) { boolean value = ( boolean ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == long . class ) { long value = ( long ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == float . class ) { float value = ( float ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == string . class ) { string value = ( string ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += quote + value + quote ; } } }
va	9	private byte [ ] getclassbytes ( string directoryresource ) throws unknownhostexception , ioexception , classnotfoundexception { socket socket = new socket ( host , port ) ; printwriter output = new printwriter ( socket . getoutputstream ( ) ) ; output . println ( "get " + classrootdir + "/" + directoryresource + " http/1.1" ) ; output . println ( "host:" + host ) ; output . println ( "" ) ; output . flush ( ) ; bytearrayoutputstream data = new bytearrayoutputstream ( ) ; inputstream stream = socket . getinputstream ( ) ; byte [ ] statuscodebytes = new byte [ 12 ] ; string statuscode = "" ; stream . read ( statuscodebytes ) ; for ( int i = 0 ; i < statuscodebytes . length ; i ++ ) { statuscode += ( char ) statuscodebytes [ i ] ; } statuscode = statuscode . split ( " " ) [ 1 ] ; if ( statuscode . equals ( "200" ) ) { int c ; boolean newline = false ; boolean incontent = false ; while ( ( c = stream . read ( ) ) != - 1 ) { if ( incontent ) { data . write ( c ) ; } else { if ( c == 10 && newline ) { incontent = true ; } else if ( c == 13 ) { continue ; } else { newline = false ; } if ( c == 10 ) { newline = true ; } } } } else { socket . close ( ) ; throw new classnotfoundexception ( directoryresource + "could not be found at " + host ) ; } socket . close ( ) ; return data . tobytearray ( ) ; }
va	10	protected void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; int width = getwidth ( ) ; int height = getheight ( ) ; color oldcolor = g . getcolor ( ) ; int radius = display . getradius ( ) ; g . setcolor ( settings . beam_color ) ; int startoffsetx = 0 ; int startoffsety = 0 ; insets ins = getinsets ( ) ; if ( ins != null ) { width -= ins . left + ins . right ; height -= ins . top + ins . bottom ; startoffsetx = ins . left ; startoffsety = ins . top ; } int w = 2 * radius ; int centerx = width / 2 ; int centery = height ; int x = ( int ) math . round ( ( double ) w * math . cos ( settings . coeff * currentangle ) ) ; int y = ( int ) math . round ( ( double ) w * math . sin ( settings . coeff * currentangle ) ) ; g . drawline ( centerx , centery - 1 , centerx + x , centery - y - 1 ) ; int fadeangle = currentangle ; w = 2 * math . max ( width , height ) ; startoffsetx += ( width - w ) / 2 ; startoffsety += height - w / 2 ; for ( int i = 0 ; i < settings . fade_count ; i ++ ) { fadeangle -= anglestep ; if ( fadeangle < 0 ) { break ; } g . setcolor ( settings . fade_colors [ i ] ) ; g . fillarc ( startoffsetx , startoffsety , w , w , fadeangle , anglestep ) ; } g . setcolor ( oldcolor ) ; }
va	4	public static void addtopkuser ( int k ) { try { bufferedreader fin = new bufferedreader ( new filereader ( "res/usercheckins-rank.txt" ) ) ; string l = null ; int c = 0 ; while ( ( l = fin . readline ( ) ) != null ) { string [ ] ls = l . split ( "\\t" ) ; int uid = integer . parseint ( ls [ 0 ] ) ; new user ( uid ) ; c ++ ; if ( c == k ) break ; } fin . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( string . format ( "%d users have been initailized." , k ) ) ; }
va	1	public void paint ( graphics canvas ) { super . paint ( canvas ) ; canvas2d = ( graphics2d ) canvas ; if ( firstpaint ) { this . initialize ( ) ; } canvas2d . setrenderinghints ( therenderinghints ) ; canvas2d . drawimage ( backgroundtexture , 0 , 0 , this ) ; canvas2d . drawimage ( doortexture , ( int ) entrancedoorx , ( int ) entrancedoory , this ) ; if ( buttonintersection ) { canvas2d . drawimage ( dooropentexture , ( int ) exitdoorx , ( int ) exitdoory , this ) ; canvas2d . drawimage ( buttonpressedtexture , ( int ) buttonx , ( int ) buttony , this ) ; } else { canvas2d . drawimage ( doortexture , ( int ) exitdoorx , ( int ) exitdoory , this ) ; canvas2d . drawimage ( buttontexture , ( int ) buttonx , ( int ) buttony , this ) ; } if ( portalableintersection && raylinecolorisblue ) { canvas2d . setcolor ( color . blue ) ; } else if ( portalableintersection && ! raylinecolorisblue ) { canvas2d . setcolor ( color . orange ) ; } else { canvas2d . setcolor ( color . gray ) ; } canvas2d . draw ( drawnrayline ) ; for ( int i = 0 ; i < portalablesurfaces . size ( ) ; i ++ ) { double thewidth = ( ( rectangle2d ) portalablesurfaces . get ( i ) ) . getwidth ( ) ; double theheight = ( ( rectangle2d ) portalablesurfaces . get ( i ) ) . getheight ( ) ; int timestodrawx = ( int ) ( thewidth / 50 ) ; int timestodrawy = ( int ) ( theheight / 50 ) ; for ( int x = 0 ; x < timestodrawx ; x ++ ) { for ( int y = 0 ; y < timestodrawy ; y ++ ) { canvas2d . drawimage ( marbletiletexture , ( int ) ( ( rectangle2d ) portalablesurfaces . get ( i ) ) . getx ( ) + 50 * x , ( int ) ( ( rectangle2d ) portalablesurfaces . get ( i ) ) . gety ( ) + 50 * y , this ) ; } } } for ( int i = 0 ; i < nonportalablesurfaces . size ( ) ; i ++ ) { double thewidth = ( ( rectangle2d ) nonportalablesurfaces . get ( i ) ) . getwidth ( ) ; double theheight = ( ( rectangle2d ) nonportalablesurfaces . get ( i ) ) . getheight ( ) ; int timestodrawx = ( int ) ( thewidth / 50 ) ; int timestodrawy = ( int ) ( theheight / 50 ) ; for ( int x = 0 ; x < timestodrawx ; x ++ ) { for ( int y = 0 ; y < timestodrawy ; y ++ ) { canvas2d . drawimage ( darkmarbletexture , ( int ) ( ( rectangle2d ) nonportalablesurfaces . get ( i ) ) . getx ( ) + 50 * x , ( int ) ( ( rectangle2d ) nonportalablesurfaces . get ( i ) ) . gety ( ) + 50 * y , this ) ; } } } if ( portalablesurfaces . contains ( leftwall ) ) { canvas2d . drawimage ( metalvertlighttexture , ( int ) leftwall . getx ( ) , ( int ) leftwall . gety ( ) , this ) ; canvas2d . drawimage ( metalvertlighttexture , ( int ) leftwall . getx ( ) , ( int ) leftwall . gety ( ) + 400 , this ) ; } else { canvas2d . drawimage ( metalvertdarktexture , ( int ) leftwall . getx ( ) , ( int ) leftwall . gety ( ) , this ) ; canvas2d . drawimage ( metalvertdarktexture , ( int ) leftwall . getx ( ) , ( int ) leftwall . gety ( ) + 400 , this ) ; } if ( portalablesurfaces . contains ( rightwall ) ) { canvas2d . drawimage ( metalvertlighttexture , ( int ) rightwall . getx ( ) , ( int ) rightwall . gety ( ) , this ) ; canvas2d . drawimage ( metalvertlighttexture , ( int ) rightwall . getx ( ) , ( int ) rightwall . gety ( ) + 400 , this ) ; } else { canvas2d . drawimage ( metalvertdarktexture , ( int ) rightwall . getx ( ) , ( int ) rightwall . gety ( ) , this ) ; canvas2d . drawimage ( metalvertdarktexture , ( int ) rightwall . getx ( ) , ( int ) rightwall . gety ( ) + 400 , this ) ; } if ( portalablesurfaces . contains ( ceiling ) ) { canvas2d . drawimage ( metalhorizlighttexture , ( int ) ceiling . getx ( ) , ( int ) ceiling . gety ( ) , this ) ; canvas2d . drawimage ( metalhorizlighttexture , ( int ) ceiling . getx ( ) + 400 , ( int ) ceiling . gety ( ) , this ) ; canvas2d . drawimage ( metalhorizlighttexture , ( int ) ceiling . getx ( ) + 800 , ( int ) ceiling . gety ( ) , this ) ; } else { canvas2d . drawimage ( metalhorizdarktexture , ( int ) ceiling . getx ( ) , ( int ) ceiling . gety ( ) , this ) ; canvas2d . drawimage ( metalhorizdarktexture , ( int ) ceiling . getx ( ) + 400 , ( int ) ceiling . gety ( ) , this ) ; canvas2d . drawimage ( metalhorizdarktexture , ( int ) ceiling . getx ( ) + 800 , ( int ) ceiling . gety ( ) , this ) ; } if ( portalablesurfaces . contains ( floor ) ) { canvas2d . drawimage ( metalfloorlighttexture , ( int ) floor . getx ( ) , ( int ) floor . gety ( ) , this ) ; canvas2d . drawimage ( metalfloorlighttexture , ( int ) floor . getx ( ) + 400 , ( int ) floor . gety ( ) , this ) ; canvas2d . drawimage ( metalfloorlighttexture , ( int ) floor . getx ( ) + 800 , ( int ) floor . gety ( ) , this ) ; } else { canvas2d . drawimage ( metalfloordarktexture , ( int ) floor . getx ( ) , ( int ) floor . gety ( ) , this ) ; canvas2d . drawimage ( metalfloordarktexture , ( int ) floor . getx ( ) + 400 , ( int ) floor . gety ( ) , this ) ; canvas2d . drawimage ( metalfloordarktexture , ( int ) floor . getx ( ) + 800 , ( int ) floor . gety ( ) , this ) ; } if ( portal1 . getwidth ( ) > portal1 . getheight ( ) ) { canvas2d . drawimage ( blueportaltexturehoriz , ( int ) portal1 . getx ( ) , ( int ) portal1 . gety ( ) , this ) ; } else { canvas2d . drawimage ( blueportaltexturevert , ( int ) portal1 . getx ( ) , ( int ) portal1 . gety ( ) , this ) ; } if ( portal2 . getwidth ( ) > portal2 . getheight ( ) ) { canvas2d . drawimage ( orangeportaltexturehoriz , ( int ) portal2 . getx ( ) , ( int ) portal2 . gety ( ) , this ) ; } else { canvas2d . drawimage ( orangeportaltexturevert , ( int ) portal2 . getx ( ) , ( int ) portal2 . gety ( ) , this ) ; } canvas2d . drawimage ( boxtexture , ( int ) boxpos . getx ( ) , ( int ) boxpos . gety ( ) , this ) ; if ( playerfacingright ) { canvas2d . drawimage ( playertexture , ( int ) playerpos . getx ( ) , ( int ) playerpos . gety ( ) , this ) ; } else { canvas2d . drawimage ( playertextureflip , ( int ) playerpos . getx ( ) , ( int ) playerpos . gety ( ) , this ) ; } if ( loadnextlevel && buttonintersection ) { this . loadlevel ( ++ currentlevelnumber ) ; } if ( levelresetrequired ) { this . loadlevel ( currentlevelnumber ) ; } }
va	6	public int mindistance ( string word1 , string word2 ) { if ( word1 . length ( ) == 0 ) return word2 . length ( ) ; if ( word2 . length ( ) == 0 ) return word1 . length ( ) ; int [ ] [ ] res = new int [ word1 . length ( ) + 1 ] [ word2 . length ( ) + 1 ] ; res [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= word1 . length ( ) ; i ++ ) res [ i ] [ 0 ] = i ; for ( int j = 1 ; j <= word2 . length ( ) ; j ++ ) res [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= word1 . length ( ) ; i ++ ) { for ( int j = 1 ; j <= word2 . length ( ) ; j ++ ) { if ( word1 . charat ( i - 1 ) == word2 . charat ( j - 1 ) ) { res [ i ] [ j ] = res [ i - 1 ] [ j - 1 ] ; } else { res [ i ] [ j ] = math . min ( math . min ( res [ i - 1 ] [ j - 1 ] , res [ i ] [ j - 1 ] ) , res [ i - 1 ] [ j ] ) + 1 ; } } } return res [ word1 . length ( ) ] [ word2 . length ( ) ] ; }
va	3	@ test public void testsuccessfulresult ( ) throws interruptedexception { final countdownlatch latch = new countdownlatch ( 1 ) ; listenablefuture < string > pong = ( listenablefuture < string > ) service . ping ( ) ; final atomicreference < string > deferredresult = new atomicreference < string > ( ) ; futurecallback < string > callback = new futurecallback < string > ( ) { public void onsuccess ( string result ) { deferredresult . set ( result ) ; latch . countdown ( ) ; } public void onfailure ( throwable t ) { } } ; futures . addcallback ( pong , callback ) ; latch . await ( 2 , timeunit . seconds ) ; assertthat ( deferredresult . get ( ) , is ( "pong" ) ) ; }
va	2	public static void main ( string args [ ] ) throws ioexception { logger . setlevel ( level . info ) ; . . = new . ( ) ; . . connecttodb ( ) ; mainmenu mainmenu = new mainmenu ( logger , . . connection ) ; boolean wanttoquit = false ; while ( ! wanttoquit ) { system . out . println ( "this is the administration tool for the dot issue tracker" ) ; system . out . println ( "and source control program. before beginning<litcomma> choose:" ) ; system . out . println ( "1. reinitialize the database with sample data" ) ; system . out . println ( "2. continue with the old database" ) ; string input = . . userinput . nextline ( ) ; inputchecker in = new inputchecker ( input ) ; if ( in . hasalpha ( ) ) { system . out . println ( "that was not an int<litcomma> returning to goals menu." ) ; return ; } input = input . trim ( ) ; switch ( input ) { case "1" : . . initializedb ( ) ; mainmenu . committodatabasemenu ( ) ; case "2" : wanttoquit = true ; break ; default : system . out . println ( "invalid menu option" ) ; break ; } } fileutil . init ( ) ; mainmenu . mainmenu ( ) ; fileutil . close ( ) ; }
va	7	private static void identifyseparator ( file fname ) { separators . put ( "<litcomma>" , new int [ 2 ] ) ; separators . put ( ";" , new int [ 2 ] ) ; separators . put ( ":" , new int [ 2 ] ) ; separators . put ( "|" , new int [ 2 ] ) ; separators . put ( "\\t" , new int [ 2 ] ) ; separators . put ( " " , new int [ 2 ] ) ; java . io . bufferedreader fin ; try { fin = new java . io . bufferedreader ( new java . io . filereader ( fname ) ) ; string record ; int n = 0 ; while ( ( record = fin . readline ( ) ) != null ) { record = compressblanks ( record ) ; if ( record . length ( ) == 0 ) continue ; countseparators ( record ) ; deleteinvalidseparators ( n ) ; n ++ ; if ( n > 100 || separators . size ( ) == 0 ) break ; } if ( separators . size ( ) == 0 ) { if ( n == 1 ) { separator = "" ; ncols = 1 ; } } else { object [ ] keys = separators . keyset ( ) . toarray ( ) ; separator = ( string ) keys [ 0 ] ; ncols = 1 + ( ( int [ ] ) separators . get ( separator ) ) [ 1 ] ; } fin . close ( ) ; } catch ( java . io . ioexception ie ) { system . err . println ( "i/o exception in computevariabletypes" ) ; } }
va	1	private string getvalueforcavity ( ixcavity cav , ixsignal sig ) { string retval = null ; if ( m_cavprop != null ) { string val = cav . getproperty ( m_cavprop ) ; if ( val != null && val . trim ( ) . length ( ) > 0 ) { return val ; } } if ( m_pinprop != null ) { for ( ixabstractpin pin : cav . getfunctionalpins ( ) ) { if ( pinconnectstosignal ( pin , sig ) ) { string val = pin . getproperty ( m_pinprop ) ; if ( val != null && val . trim ( ) . length ( ) > 0 ) { retval = determineresult ( retval , val ) ; } } } } return retval ; }
va	5	protected byte [ ] readfile ( final string datafile ) throws ioexception , missingresourceexception { bufferedinputstream is ; try { is = ( bufferedinputstream ) accesscontroller . doprivileged ( new privilegedexceptionaction ( ) { public object run ( ) throws exception { return new bufferedinputstream ( getclass ( ) . getresourceasstream ( "/sun/text/resources/" + datafile ) ) ; } } ) ; } catch ( privilegedactionexception e ) { throw new internalerror ( e . tostring ( ) ) ; } int offset = 0 ; int len = label_length + 5 ; byte [ ] buf = new byte [ len ] ; if ( is . read ( buf ) != len ) { throw new missingresourceexception ( "wrong header length" , datafile , "" ) ; } for ( int i = 0 ; i < label_length ; i ++ , offset ++ ) { if ( buf [ offset ] != label [ offset ] ) { throw new missingresourceexception ( "wrong magic number" , datafile , "" ) ; } } if ( buf [ offset ] != supportedversion ) { throw new missingresourceexception ( "unsupported version(" + buf [ offset ] + ")" , datafile , "" ) ; } len = ourbreakiterator . getint ( buf , ++ offset ) ; buf = new byte [ len ] ; if ( is . read ( buf ) != len ) { throw new missingresourceexception ( "wrong data length" , datafile , "" ) ; } is . close ( ) ; return buf ; }
va	3	public void browse ( ) { jfilechooser fc = new jfilechooser ( ) ; fc . showopendialog ( null ) ; file browse = fc . getselectedfile ( ) ; try { filereader in = new filereader ( browse ) ; filewriter out = new filewriter ( this . file ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } in . close ( ) ; out . close ( ) ; } catch ( exception ex ) { new clubexception ( "error reading file" , ex . tostring ( ) ) ; } }
va	10	@ override public boolean oncommand ( commandsender sender , command cmd , string label , string [ ] args ) { if ( cmd . getname ( ) . equalsignorecase ( "allowedplayers" ) || cmd . getname ( ) . equalsignorecase ( "ap" ) ) { if ( ! ( sender instanceof player ) ) { sender . sendmessage ( "your not a player you can't use this command" ) ; } else { player player = ( player ) sender ; if ( args [ 0 ] . equalsignorecase ( "add" ) ) { if ( args . length > 1 ) { location loc = new location ( player . getworld ( ) , player . getlocation ( ) . getblockx ( ) , player . getlocation ( ) . getblocky ( ) , player . getlocation ( ) . getblockz ( ) ) ; if ( loc . getblock ( ) . gettypeid ( ) == 70 || loc . getblock ( ) . gettypeid ( ) == 72 ) { plates = plugin . getplates ( ) ; for ( int i = 0 ; i < plates . size ( ) ; i ++ ) { if ( plates . get ( i ) . getlocation ( ) . equals ( loc ) ) { if ( plates . get ( i ) . getowner ( ) . equalsignorecase ( player . getdisplayname ( ) ) ) { if ( plates . get ( i ) . getmod ( ) . equalsignorecase ( "allowedplayers" ) ) { string str = "" ; string wontadd = "" ; for ( int t = 1 ; t < args . length ; t ++ ) { if ( plates . get ( i ) . getallowedplayers ( ) . contains ( args [ t ] ) ) { if ( t == args . length - 1 ) { wontadd += args [ t ] ; } else { wontadd += args [ t ] + "<litcomma>" ; } continue ; } else { plates . get ( i ) . addallowedplayer ( args [ t ] ) ; if ( t == args . length - 1 ) { str += args [ t ] ; } else { str += args [ t ] + "<litcomma>" ; } } } if ( ! str . isempty ( ) ) { player . sendmessage ( chatcolor . green + "you added the players:" ) ; player . sendmessage ( chatcolor . dark_green + str ) ; } if ( ! wontadd . isempty ( ) ) { player . sendmessage ( chatcolor . red + "you didnt added the players<litcomma> they are already in:" ) ; player . sendmessage ( chatcolor . dark_green + wontadd ) ; } plugin . setplates ( plates ) ; plugin . removeline ( ) ; return true ; } else { player . sendmessage ( chatcolor . red + "this pressure plate is not on the right mod" ) ; return false ; } } else { player . sendmessage ( chatcolor . red + "you dont own this pressure plate" ) ; return false ; } } } } else { player . sendmessage ( chatcolor . red + "you are not standing on a pressure plate" ) ; } } else { sender . sendmessage ( chatcolor . red + "you are not trying to add anyone" ) ; return false ; } } else if ( args [ 0 ] . equalsignorecase ( "remove" ) ) { if ( args . length > 1 ) { location loc = new location ( player . getworld ( ) , player . getlocation ( ) . getblockx ( ) , player . getlocation ( ) . getblocky ( ) , player . getlocation ( ) . getblockz ( ) ) ; if ( loc . getblock ( ) . gettypeid ( ) == 70 || loc . getblock ( ) . gettypeid ( ) == 72 ) { plates = plugin . getplates ( ) ; for ( int i = 0 ; i < plates . size ( ) ; i ++ ) { if ( plates . get ( i ) . getlocation ( ) . equals ( loc ) ) { if ( plates . get ( i ) . getowner ( ) . equalsignorecase ( player . getdisplayname ( ) ) ) { if ( plates . get ( i ) . getmod ( ) . equalsignorecase ( "allowedplayers" ) ) { string str = "" ; string wontadd = "" ; for ( int t = 1 ; t < args . length ; t ++ ) { if ( plates . get ( i ) . getallowedplayers ( ) . contains ( args [ t ] ) ) { plates . get ( i ) . removeallowedplayer ( args [ t ] ) ; if ( t == args . length - 1 ) { str += args [ t ] ; } else { str += args [ t ] + "<litcomma>" ; } } else { if ( t == args . length - 1 ) { wontadd += args [ t ] ; } else { wontadd += args [ t ] + "<litcomma>" ; } } } if ( ! str . isempty ( ) ) { player . sendmessage ( chatcolor . green + "you removed the players:" ) ; player . sendmessage ( chatcolor . dark_green + str ) ; } if ( ! wontadd . isempty ( ) ) { player . sendmessage ( chatcolor . red + "you didnt removed the players<litcomma> they are already out:" ) ; player . sendmessage ( chatcolor . dark_green + wontadd ) ; } plugin . setplates ( plates ) ; plugin . removeline ( ) ; return true ; } else { player . sendmessage ( chatcolor . red + "this pressure plate is not on the right mod" ) ; return false ; } } else { player . sendmessage ( chatcolor . red + "you dont own this pressure plate" ) ; return false ; } } } } else { player . sendmessage ( chatcolor . red + "you are not standing on a pressure plate" ) ; } } else { sender . sendmessage ( chatcolor . red + "you are not trying to remove anyone" ) ; return false ; } } else if ( args [ 0 ] . equalsignorecase ( "list" ) ) { if ( args . length == 1 ) { location loc = new location ( player . getworld ( ) , player . getlocation ( ) . getblockx ( ) , player . getlocation ( ) . getblocky ( ) , player . getlocation ( ) . getblockz ( ) ) ; if ( loc . getblock ( ) . gettypeid ( ) == 70 || loc . getblock ( ) . gettypeid ( ) == 72 ) { plates = plugin . getplates ( ) ; for ( int i = 0 ; i < plates . size ( ) ; i ++ ) { if ( plates . get ( i ) . getlocation ( ) . equals ( loc ) ) { if ( plates . get ( i ) . getowner ( ) . equalsignorecase ( player . getdisplayname ( ) ) ) { if ( plates . get ( i ) . getmod ( ) . equalsignorecase ( "allowedplayers" ) ) { player . sendmessage ( chatcolor . gold + "allowed players: " + plugin . getutil ( ) . cleanstring ( plates . get ( i ) . getallowedplayers ( ) . tostring ( ) , new string [ ] { "[" , "]" } ) ) ; return true ; } } } } } else { player . sendmessage ( chatcolor . red + "you are not standing on a pressure plate" ) ; return false ; } } } else { return false ; } } } else if ( cmd . getname ( ) . equalsignorecase ( "pp" ) ) { if ( args . length == 0 ) { if ( ! ( sender instanceof player ) ) { sender . sendmessage ( "your not a player you can't use this command" ) ; } else { player player = ( player ) sender ; plates = plugin . getplates ( ) ; int t = 1 ; player . sendmessage ( "plates owned by you:" ) ; for ( int i = 0 ; i < plates . size ( ) ; i ++ ) { if ( plates . get ( i ) . getowner ( ) . equalsignorecase ( player . getdisplayname ( ) ) ) { player . sendmessage ( t + "." + plates . get ( i ) . tostring ( ) ) ; t ++ ; } } if ( t == 1 ) { player . sendmessage ( "none" ) ; } return true ; } } } else if ( cmd . getname ( ) . equalsignorecase ( "cp" ) || cmd . getname ( ) . equalsignorecase ( "customplates" ) ) { if ( args . length == 0 ) { if ( ! ( sender instanceof player ) ) { sender . sendmessage ( "your not a player you can't use this command" ) ; } else { player player = ( player ) sender ; player . sendmessage ( chatcolor . aqua + "" + chatcolor . underline + "items" ) ; player . sendmessage ( chatcolor . blue + "lock item: " + new itemstack ( plugin . getlockitem ( ) ) . gettype ( ) . tostring ( ) ) ; player . sendmessage ( chatcolor . blue + "remove lock item: " + new itemstack ( plugin . getremovelockitem ( ) ) . gettype ( ) . tostring ( ) ) ; player . sendmessage ( chatcolor . blue + "mod change item: " + new itemstack ( plugin . getmodeswitchitem ( ) ) . gettype ( ) . tostring ( ) ) ; player . sendmessage ( chatcolor . aqua + "" + chatcolor . underline + "commands" ) ; player . sendmessage ( chatcolor . blue + "/pp" ) ; player . sendmessage ( chatcolor . green + "give you a list of pressure plates owned by you." ) ; player . sendmessage ( chatcolor . blue + "/ap|allowedplayers [list]" ) ; player . sendmessage ( chatcolor . green + "give you a list of allowed players that can use the pressure plate" ) ; player . sendmessage ( chatcolor . red + "you mush stand on the pressure plate<litcomma> and be the owner of it" ) ; player . sendmessage ( chatcolor . blue + "/ap|allowedplayers [add] [player<litcomma>player...]" ) ; player . sendmessage ( chatcolor . green + "add players to your allowed players list" ) ; player . sendmessage ( chatcolor . red + "you mush stand on the pressure plate<litcomma> and be the owner of it" ) ; player . sendmessage ( chatcolor . blue + "/ap|allowedplayers [remove] [player<litcomma>player...]" ) ; player . sendmessage ( chatcolor . green + "remove players from your allowed players list" ) ; player . sendmessage ( chatcolor . red + "you mush stand on the pressure plate<litcomma> and be the owner of it" ) ; return true ; } } } return false ; }
va	1	public static void main ( string [ ] args ) { mainwindow mymainwindow = new mainwindow ( ) ; jmenubar | = new jmenubar ( ) ; jmenu filemenu = new jmenu ( "file" ) ; jmenu levelmenu = new jmenu ( "level" ) ; jmenu levelselectionmenu = new jmenu ( "choose level" ) ; jmenu helpmenu = new jmenu ( "help" ) ; jmenuitem exit = new jmenuitem ( "exit" ) ; exit . addactionlistener ( mymainwindow ) ; filemenu . add ( exit ) ; jmenuitem reset = new jmenuitem ( "reset level" ) ; reset . addactionlistener ( mymainwindow ) ; levelmenu . add ( reset ) ; levelmenu . add ( levelselectionmenu ) ; jmenuitem level1 = new jmenuitem ( "level 1" ) ; level1 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level1 ) ; jmenuitem level2 = new jmenuitem ( "level 2" ) ; level2 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level2 ) ; jmenuitem level3 = new jmenuitem ( "level 3" ) ; level3 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level3 ) ; jmenuitem level4 = new jmenuitem ( "level 4" ) ; level4 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level4 ) ; jmenuitem level5 = new jmenuitem ( "level 5" ) ; level5 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level5 ) ; jmenuitem level6 = new jmenuitem ( "level 6" ) ; level6 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level6 ) ; jmenuitem level7 = new jmenuitem ( "level 7" ) ; level7 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level7 ) ; jmenuitem level8 = new jmenuitem ( "level 8" ) ; level8 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level8 ) ; jmenuitem level9 = new jmenuitem ( "level 9" ) ; level9 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level9 ) ; jmenuitem level10 = new jmenuitem ( "level 10" ) ; level10 . addactionlistener ( mymainwindow ) ; levelselectionmenu . add ( level10 ) ; jmenuitem howtoplay = new jmenuitem ( "how to play" ) ; howtoplay . addactionlistener ( mymainwindow ) ; helpmenu . add ( howtoplay ) ; jmenuitem hint = new jmenuitem ( "display hint" ) ; hint . addactionlistener ( mymainwindow ) ; helpmenu . add ( hint ) ; | . add ( filemenu ) ; | . add ( levelmenu ) ; | . add ( helpmenu ) ; mymainwindow . setjmenubar ( | ) ; mymainwindow . setvisible ( true ) ; }
va	7	public void paintcomponent ( graphics g ) { graphics2d g2d = ( graphics2d ) bi . getgraphics ( ) ; g2d . setcolor ( color . white ) ; g2d . fillrect ( 0 , 0 , bi . getheight ( ) , bi . getwidth ( ) ) ; for ( int i = 0 ; i < centers . length ; i ++ ) { double xi = ( centers [ i ] [ 0 ] - mins ) / ( maxs - mins ) ; double yi = ( centers [ i ] [ 1 ] - mins ) / ( maxs - mins ) ; double pi = diameters [ i ] / ( maxs - mins ) ; int pointsize = ( int ) ( pi * size ) ; int x = 50 + ( int ) ( xi * size ) ; int y = 50 + ( int ) ( size - yi * size ) ; color color = rainbow ( colors [ i ] , .4f ) ; g2d . setcolor ( color ) ; g2d . filloval ( x - pointsize / 2 , y - pointsize / 2 , pointsize , pointsize ) ; g2d . setcolor ( color . black ) ; double [ ] wh = getwidthandheight ( labels [ i ] , g2d ) ; g2d . drawstring ( labels [ i ] , x - ( int ) wh [ 0 ] / 2 , y + ( int ) wh [ 1 ] / 2 ) ; } graphics2d gg = ( graphics2d ) g ; gg . drawimage ( bi , 2 , 2 , this ) ; }
va	8	private void initlstword ( list < word > lstword , list < string > lststring ) { for ( string str : lststring ) { boolean isin = false ; for ( word word : lstword ) { if ( word . getvalue ( ) . equals ( str ) ) { word . setnoa ( word . getnoa ( ) + 1 ) ; isin = true ; } } if ( ! isin ) { word w = new word ( str , 1 , 0 , 0 , 0 , 0 ) ; lstword . add ( w ) ; } } for ( word word : lstword ) { for ( wtmp wtmp : wordcalcu . lconfirmed ) { if ( word . getvalue ( ) . equals ( wtmp . getval ( ) ) ) { word . setaic ( wtmp . getnum ( ) ) ; } } for ( wtmp wtmp : wordcalcu . lnegative ) { if ( word . getvalue ( ) . equals ( wtmp . getval ( ) ) ) { word . setain ( wtmp . getnum ( ) ) ; } } } for ( word word : lstword ) { double s1 = ( word . getaic ( ) + 1 * 1.0f ) / ( countcc + countv ) ; double s2 = ( word . getain ( ) + 1 * 1.0f ) / ( countcn + countv ) ; word . setpc ( s1 ) ; word . setpn ( s2 ) ; } }
va	6	public static map < money , integer > getchange ( money money ) throws interruptedexception { map < money , integer > change = new hashmap < > ( ) ; for ( money m : money . denominations_high_to_low ) { change . put ( m , 0 ) ; while ( money . compareto ( m ) >= 0 ) { int currentval = change . get ( m ) ; system . out . println ( "another " + m + " used up!" ) ; change . put ( m , currentval + 1 ) ; money = money . add ( money , m . negatetemporarily ( ) ) ; system . out . println ( "money now: " + money + "\\n" ) ; } } return change ; }
va	5	public void reorderlist ( listnode head ) { if ( head == null || head . next == null ) return ; listnode curr1 = head ; int count = 0 ; while ( curr1 != null ) { curr1 = curr1 . next ; count ++ ; } listnode second = null ; curr1 = head ; int i = 1 ; while ( i < ( count + 1 ) / 2 ) { curr1 = curr1 . next ; i ++ ; } second = curr1 . next ; curr1 . next = null ; listnode dummy2 = new listnode ( - 1 ) ; dummy2 . next = second ; listnode curr2 = second . next ; while ( curr2 != null ) { listnode x = curr2 . next ; second . next = curr2 . next ; curr2 . next = dummy2 . next ; dummy2 . next = curr2 ; curr2 = x ; } listnode dummy = new listnode ( - 1 ) ; listnode curr = dummy ; curr1 = head ; curr2 = dummy2 . next ; while ( curr1 != null && curr2 != null ) { listnode x = curr1 . next ; listnode y = curr2 . next ; curr . next = curr1 ; curr1 . next = curr2 ; curr = curr2 ; curr1 = x ; curr2 = y ; } if ( curr1 != null ) curr . next = curr1 ; if ( curr2 != null ) curr . next = curr2 ; head = dummy . next ; }
va	4	public int send ( map < string , string > record ) { string [ ] emailccs = null ; string [ ] emailbccs = null ; string [ ] replytos = null ; try { htmlemail email = new htmlemail ( ) ; email . sethostname ( do_noy_reply_server ) ; email . setauthentication ( do_not_reply_usr , do_not_reply_psw ) ; string [ ] emails = record . get ( "email" ) . split ( "[|]" ) ; string [ ] telnos = record . get ( "telno" ) . split ( "[|]" ) ; string [ ] pernrs = record . get ( "pernr" ) . split ( "[|]" ) ; if ( record . get ( "emailcc" ) != null ) { emailccs = record . get ( "emailcc" ) . split ( "[|]" ) ; } if ( record . get ( "emailbcc" ) != null ) { emailbccs = record . get ( "emailbcc" ) . split ( "[|]" ) ; } if ( record . get ( "replyto" ) != null ) { replytos = record . get ( "replyto" ) . split ( "[|]" ) ; } map < string , string > recieversmap = service . getrecievers ( emails , telnos , pernrs ) ; for ( string mail : emails ) { if ( mail == null || "" . equals ( mail ) ) { continue ; } recieversmap . put ( mail , mail ) ; } for ( string emailaddr : recieversmap . keyset ( ) ) { email . addto ( emailaddr ) ; } if ( emailccs != null ) { for ( string emailcc : emailccs ) { if ( emailcc == null || "" . equals ( emailcc ) ) { continue ; } email . addcc ( emailcc ) ; } } if ( emailbccs != null ) { for ( string emailbcc : emailbccs ) { if ( emailbcc == null || "" . equals ( emailbcc ) ) { continue ; } email . addbcc ( emailbcc ) ; } } if ( replytos != null ) { for ( string replyto : replytos ) { if ( replyto == null || "" . equals ( replyto ) ) { continue ; } email . addreplyto ( replyto ) ; } } email . setfrom ( do_noy_reply_email ) ; email . setsubject ( record . get ( "subject" ) ) ; email . setcharset ( unsconsts . gb2312 ) ; email . sethtmlmsg ( record . get ( "body" ) ) ; logger . log ( level . info , ">>> start to send email<litcomma> ts:{0}" , string . valueof ( system . currenttimemillis ( ) ) ) ; email . send ( ) ; logger . log ( level . info , ">>> mail has bean send to recievers<litcomma> ts:{0}" , string . valueof ( system . currenttimemillis ( ) ) ) ; return 1 ; } catch ( emailexception e ) { logger . log ( level . info , "when sending a email error occured {0}" + e . getmessage ( ) ) ; return 0 ; } }
va	5	@ override public object read ( ) throws classnotfoundexception , instantiationexception , illegalaccessexception , securityexception , nosuchfieldexception { int index = stream . indexof ( open_obj ) ; string classname = stream . substring ( 0 , index ) ; class < ? > theclass = class . forname ( classname ) ; object obj = theclass . newinstance ( ) ; int , = stream . indexof ( def_separator , index ) ; string fieldstring = stream . substring ( index + 1 , , ) ; setfield ( theclass , obj , fieldstring ) ; system . out . println ( fieldstring ) ; return obj ; }
va	3	public void movetocenter ( pvector i_center , float i_zoomfactor , int i_timetoanimate ) { pvector targetoffset = calcworldoffset ( i_center , i_zoomfactor ) ; this . m_timeleftforcameraanimation = i_timetoanimate ; this . m_originalanimationtime = i_timetoanimate ; this . m_zoomstep = ( ( i_zoomfactor - this . m_zoom ) / i_timetoanimate ) ; this . m_offsetstep = pvector . - ( targetoffset , this . m_worldorigin ) ; this . m_offsetstep . div ( i_timetoanimate ) ; this . m_originaloffset = new pvector ( ) ; this . m_originaloffset . set ( this . m_worldorigin ) ; this . m_originalzoom = this . m_zoom ; }
va	9	@ override public void analysis ( configuration configuration , list < transaction > transactions ) { collections . sort ( transactions , new comparator < transaction > ( ) { @ override public int compare ( transaction o1 , transaction o2 ) { return ( int ) ( o1 . getcost ( ) - o2 . getcost ( ) ) ; } } ) ; sortedmap < string , integer > runningmapper = new concurrentskiplistmap < string , integer > ( ) ; list < long > timeoutlist = new arraylist < long > ( ) ; int timeoutcost = 0 ; int cost = 0 ; for ( transaction transaction : transactions ) { cost += transaction . getcost ( ) ; if ( transaction . getcost ( ) > configuration . gettimeout ( ) ) { timeoutcost += transaction . getcost ( ) ; timeoutlist . add ( transaction . getcost ( ) ) ; } putrunningentry ( runningmapper , transaction . getbegintime ( ) ) ; } system . out . println ( "============ test information ===========" ) ; system . out . println ( "action    : " + configuration . getaction ( ) ) ; system . out . println ( "concurrent: " + configuration . getconcurrent ( ) ) ; system . out . println ( "duration  : " + configuration . getduration ( ) ) ; system . out . println ( "timeout   : " + configuration . gettimeout ( ) ) ; system . out . println ( "============ cost information ===========" ) ; system . out . println ( "min: " + transactions . get ( 0 ) . getcost ( ) ) ; system . out . println ( "max: " + transactions . get ( transactions . size ( ) - 1 ) . getcost ( ) ) ; system . out . println ( "avg: " + cost * 1.0 / transactions . size ( ) ) ; if ( timeoutlist . size ( ) > 0 ) { system . out . println ( "========== timeout information ==========" ) ; system . out . println ( "size: " + timeoutlist . size ( ) ) ; system . out . println ( "min : " + timeoutlist . get ( 0 ) ) ; system . out . println ( "max : " + timeoutlist . get ( timeoutlist . size ( ) - 1 ) ) ; system . out . println ( "avg : " + timeoutcost * 1.0 / timeoutlist . size ( ) ) ; } system . out . println ( "========== running information ==========" ) ; for ( string key : runningmapper . keyset ( ) ) { system . out . println ( "time: " + key + "\\t count: " + runningmapper . get ( key ) ) ; } }
va	10	public static list < string > removelinecomments ( list < string > lines ) { for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { string string = lines . get ( i ) ; string newline = "" ; boolean abortread = false ; char [ ] chars = string . tochararray ( ) ; if ( chars . length == 0 || chars . length == 1 ) { newline = string ; } else { for ( int j = 1 ; j < chars . length ; j ++ ) { char a = chars [ j - 1 ] ; char b = chars [ j ] ; if ( a == '/' && b == '/' ) { abortread = true ; } else { if ( ! abortread ) { newline += a ; } } if ( j == chars . length - 1 ) { if ( ! abortread ) { newline += b ; } } } } lines . set ( i , newline ) ; } return lines ; }
va	1	private void initialize ( ) { firstpaint = false ; thepainter = new painter ( ) ; thepainter . setname ( "painter thread" ) ; theanimator = new animator ( ) ; theanimator . setname ( "animator thread" ) ; therenderinghints = new renderinghints ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; therenderinghints . put ( renderinghints . key_rendering , renderinghints . value_render_quality ) ; floor = new rectangle2d . double ( 0 , 657 , 1008 , 50 ) ; ceiling = new rectangle2d . double ( 0 , 0 , 1008 , 50 ) ; leftwall = new rectangle2d . double ( 0 , 0 , 50 , 657 ) ; rightwall = new rectangle2d . double ( 958 , 0 , 50 , 657 ) ; outsideplatform = new rectangle2d . double ( - 300 , 0 , 200 , 50 ) ; button = new rectangle2d . double ( buttonx , buttony , 25 , 25 ) ; portal1 = new ellipse2d . double ( 0 , - 50 , portalwidth , portalheight ) ; portal2 = new ellipse2d . double ( 100 , - 50 , portalwidth , portalheight ) ; player = new rectangle2d . double ( playerx , playery , 20 , 40 ) ; box = new rectangle2d . double ( boxx , boxy , 25 , 25 ) ; entrancedoor = new rectangle2d . double ( entrancedoorx , entrancedoory , 29 , 60 ) ; exitdoor = new rectangle2d . double ( exitdoorx , exitdoory , 29 , 60 ) ; panel1 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel2 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel3 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel4 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel5 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel6 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel7 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; panel8 = new rectangle2d . double ( - 100 , - 100 , 50 , 50 ) ; drawnraylineintersections = new arraylist ( ) ; allcollidablesurfaces = new arraylist ( ) ; portalablesurfaces = new arraylist ( ) ; nonportalablesurfaces = new arraylist ( ) ; rayline = new line2d . double ( ) ; drawnrayline = new line2d . double ( ) ; testpoint = new point2d . double ( ) ; try { playertexture = imageio . read ( new file ( "textures/character.png" ) ) ; playertextureflip = imageio . read ( new file ( "textures/character_flip.png" ) ) ; buttontexture = imageio . read ( new file ( "textures/button.png" ) ) ; buttonpressedtexture = imageio . read ( new file ( "textures/button_pressed.png" ) ) ; boxtexture = imageio . read ( new file ( "textures/box_pink.jpg" ) ) ; doortexture = imageio . read ( new file ( "textures/door.png" ) ) ; dooropentexture = imageio . read ( new file ( "textures/door_open.png" ) ) ; backgroundtexture = imageio . read ( new file ( "textures/metal_background.jpg" ) ) ; blueportaltexturevert = imageio . read ( new file ( "textures/portal_blue_vert.png" ) ) ; orangeportaltexturevert = imageio . read ( new file ( "textures/portal_orange_vert.png" ) ) ; blueportaltexturehoriz = imageio . read ( new file ( "textures/portal_blue_horiz.png" ) ) ; orangeportaltexturehoriz = imageio . read ( new file ( "textures/portal_orange_horiz.png" ) ) ; metalfloorlighttexture = imageio . read ( new file ( "textures/metal_floor.jpg" ) ) ; metalfloordarktexture = imageio . read ( new file ( "textures/metal_floor_dark.jpg" ) ) ; metalvertlighttexture = imageio . read ( new file ( "textures/metal_vert_light.jpg" ) ) ; metalvertdarktexture = imageio . read ( new file ( "textures/metal_vert_dark.jpg" ) ) ; metalhorizlighttexture = imageio . read ( new file ( "textures/metal_horiz_light.jpg" ) ) ; metalhorizdarktexture = imageio . read ( new file ( "textures/metal_horiz_dark.jpg" ) ) ; marbletiletexture = imageio . read ( new file ( "textures/metal_tile_light.jpg" ) ) ; darkmarbletexture = imageio . read ( new file ( "textures/metal_tile_dark.jpg" ) ) ; } catch ( ioexception e ) { } currentlevelnumber = 1 ; loadlevel ( currentlevelnumber ) ; theanimator . start ( ) ; thepainter . start ( ) ; }
va	2	public boolean remove ( int x , object value ) { synchronized ( this ) { if ( best != null && best . equals ( value ) ) best = null ; if ( isempty ( ) ) return false ; int h , l ; if ( min == x ) { boolean success ; if ( value instanceof uhlist ) { assert ( ( uhlist ) value ) . getset ( ) . equals ( minelements . getset ( ) ) ; minelements = new uhlist ( ) ; best = null ; success = true ; } else { success = minelements . remove ( value ) ; } if ( ! success ) { return false ; } else { if ( ! minelements . isempty ( ) ) { return true ; } else { if ( hq . isempty ( ) ) { isempty = true ; return true ; } else { h = hq . getminhash ( ) ; uhnode child = lq [ h ] ; l = child . getminhash ( ) ; value = minelements = child . getminelements ( ) ; min = ( h << shift ) + l ; } } } } else { h = x > > > shift ; l = x ^ ( h << shift ) ; } boolean success = false ; uhnode child = lq [ h ] ; if ( child != null ) { success = child . remove ( l , value ) ; if ( child . isempty ( ) ) { lq [ h ] = null ; hq . remove ( h , h ) ; } } return success ; } }
va	4	public boolean issensitive ( map < string , string > record ) { boolean sensitiveflg = false ; string [ ] emails = record . get ( "email" ) . split ( "[|]" ) ; string [ ] emailccs = null ; string [ ] emailbccs = null ; if ( record . get ( "emailcc" ) != null ) { emailccs = record . get ( "emailcc" ) . split ( "[|]" ) ; } if ( record . get ( "emailbcc" ) != null ) { emailbccs = record . get ( "emailbcc" ) . split ( "[|]" ) ; } for ( string email : emails ) { if ( email == null || "" . equals ( email ) || ! isemail ( email ) ) continue ; if ( checksensitive ( email ) ) { sensitiveflg = true ; break ; } } if ( ! sensitiveflg && emailccs != null ) { for ( string emailcc : emailccs ) { if ( emailcc == null || "" . equals ( emailcc ) || ! isemail ( emailcc ) ) continue ; if ( checksensitive ( emailcc ) ) { sensitiveflg = true ; break ; } } } if ( ! sensitiveflg && emailbccs != null ) { for ( string emailbcc : emailbccs ) { if ( emailbcc == null || "" . equals ( emailbcc ) || ! isemail ( emailbcc ) ) continue ; if ( checksensitive ( emailbcc ) ) { sensitiveflg = true ; break ; } } } return sensitiveflg ; }
va	1	public void init ( ) throws portletexception { super . init ( ) ; expandotable table = null ; long companyid = portalutil . getdefaultcompanyid ( ) ; try { table = expandotablelocalserviceutil . adddefaulttable ( companyid , user . class . getname ( ) ) ; } catch ( duplicatetablenameexception dtne ) { try { table = expandotablelocalserviceutil . getdefaulttable ( companyid , user . class . getname ( ) ) ; } catch ( exception e ) { throw new portletexception ( ) ; } } catch ( exception e ) { throw new portletexception ( ) ; } expandocolumn column = null ; long tableid = table . gettableid ( ) ; string expandocolumnname = constants . expando_column_name ; try { column = expandocolumnlocalserviceutil . addcolumn ( tableid , expandocolumnname , expandocolumnconstants . string ) ; unicodeproperties properties = new unicodeproperties ( ) ; properties . setproperty ( expandocolumnconstants . index_type , boolean . true . tostring ( ) ) ; column . settypesettingsproperties ( properties ) ; expandocolumnlocalserviceutil . updateexpandocolumn ( column ) ; } catch ( duplicatecolumnnameexception dcne ) { } catch ( exception e ) { throw new portletexception ( ) ; } }
va	1	private double [ ] [ ] manrgbarray ( bufferedimage image , hemisphere hemi ) { double [ ] [ ] rgbarray = new double [ 200 ] [ 200 ] ; int rgb = 3096 ; int x = 0 ; int y = 0 ; for ( x = 0 ; x < 200 ; x ++ ) { for ( y = 0 ; y < 200 ; y ++ ) { if ( hemi == hemisphere . north && ( x > 389 / 2 && y > 248 / 2 ) || ( y > 382 / 2 ) ) { continue ; } else if ( hemi == hemisphere . south && x > 389 / 2 && y < 142 / 2 ) { continue ; } rgb = image . getrgb ( 2 * x , 2 * y ) ; int alpha = ( ( rgb > > 24 ) & 0xff ) ; int red = ( ( rgb > > 16 ) & 0xff ) ; int green = ( ( rgb > > 8 ) & 0xff ) ; int blue = ( ( rgb ) & 0xff ) ; rgbarray [ x ] [ y ] = getintensity ( alpha , red , green , blue ) ; } } return rgbarray ; }
va	9	public static int getsum ( int [ ] nums , combination c ) { switch ( c ) { case ecci : int num = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; i ++ ) { if ( nums [ i ] != num ) { return 0 ; } } return 50 ; case one : return countnumbercombination ( nums , c ) ; case two : return countnumbercombination ( nums , c ) ; case three : return countnumbercombination ( nums , c ) ; case four : return countnumbercombination ( nums , c ) ; case five : return countnumbercombination ( nums , c ) ; case six : return countnumbercombination ( nums , c ) ; case pair : int [ ] qarray = getquantityarray ( nums , c ) ; for ( int i = qarray . length - 1 ; i >= 0 ; i -- ) { if ( qarray [ i ] >= 2 ) { return i * 2 ; } } return 0 ; case triple : qarray = getquantityarray ( nums , c ) ; for ( int i = qarray . length - 1 ; i >= 0 ; i -- ) { if ( qarray [ i ] >= 3 ) { return i * 3 ; } } return 0 ; case two_pairs : qarray = getquantityarray ( nums , c ) ; int sum = 0 ; int npairs = 0 ; for ( int i = qarray . length - 1 ; i >= 0 ; i -- ) { if ( qarray [ i ] >= 2 ) { sum += i * 2 ; ++ npairs ; } } if ( npairs == 2 ) { return sum ; } else { return 0 ; } case quad : qarray = getquantityarray ( nums , c ) ; for ( int i = 0 ; i < qarray . length ; i ++ ) { if ( qarray [ i ] >= 4 ) { return i * 4 ; } } return 0 ; case line : final int sum_from_1_to_4 = 10 ; qarray = getquantityarray ( nums , c ) ; sum = 0 ; int firstnumberinline = 1 ; int lastnumberinline = 4 ; if ( qarray [ 6 ] >= 1 && qarray [ 5 ] >= 1 ) { sum = 8 ; firstnumberinline = 3 ; lastnumberinline = 6 ; } else if ( qarray [ 6 ] == 0 && qarray [ 5 ] >= 1 ) { sum = 4 ; firstnumberinline = 2 ; lastnumberinline = 5 ; } for ( int i = firstnumberinline ; i <= lastnumberinline ; i ++ ) { if ( qarray [ i ] == 0 ) { return 0 ; } } return sum + sum_from_1_to_4 ; case long_line : final int sum_from_1_to_5 = 15 ; qarray = getquantityarray ( nums , c ) ; sum = 0 ; firstnumberinline = 1 ; lastnumberinline = 5 ; if ( qarray [ 1 ] == 0 ) { sum = 5 ; firstnumberinline = 2 ; lastnumberinline = 6 ; } for ( int i = firstnumberinline ; i <= lastnumberinline ; i ++ ) { if ( qarray [ i ] != 1 ) { return 0 ; } } return sum += sum_from_1_to_5 ; case home : qarray = getquantityarray ( nums , c ) ; sum = 0 ; for ( int i = 1 ; i < qarray . length ; i ++ ) { if ( qarray [ i ] == 1 || qarray [ i ] == 4 || qarray [ i ] == 5 ) { return 0 ; } else if ( qarray [ i ] == 2 ) { sum += i * 2 ; } else if ( qarray [ i ] == 3 ) { sum += i * 3 ; } } return sum ; case chance : sum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { sum += nums [ i ] ; } return sum ; } return 0 ; }
va	5	private static graph uniformspanningtreeapproach ( int numvertices , double density ) { graph graph = new graph ( numvertices , density ) ; hashset < integer > visitednodes = new hashset < integer > ( ) ; int [ ] firstincidentedges = createincidentedgearray ( numvertices ) ; int startnode = ( int ) ( math . random ( ) * numvertices ) ; int nextnode = startnode ; int numedgesadded = 0 ; visitednodes . add ( startnode ) ; firstincidentedges [ startnode ] = startnode ; while ( visitednodes . size ( ) < numvertices ) { while ( ( nextnode = ( int ) ( math . random ( ) * numvertices ) ) == startnode ) ; if ( ! graph . getadjlist ( ) . get ( startnode ) . contains ( new adjlistnode ( nextnode , null ) ) ) { int cost = ( ( int ) ( math . random ( ) * max_edge_cost ) ) + 1 ; graph . getadjlist ( ) . get ( startnode ) . add ( new adjlistnode ( nextnode , new edge ( startnode , nextnode , cost , false ) ) ) ; graph . getadjlist ( ) . get ( nextnode ) . add ( new adjlistnode ( startnode , new edge ( nextnode , startnode , cost , false ) ) ) ; visitednodes . add ( nextnode ) ; numedgesadded = numedgesadded + 2 ; if ( firstincidentedges [ nextnode ] == sentinel ) { firstincidentedges [ nextnode ] = startnode ; } startnode = nextnode ; } } if ( numedgesadded < graph . getnumedges ( ) ) { while ( numedgesadded < graph . getnumedges ( ) ) { startnode = ( int ) ( math . random ( ) * numvertices ) ; while ( ( nextnode = ( int ) ( math . random ( ) * numvertices ) ) == startnode ) ; if ( ! graph . getadjlist ( ) . get ( startnode ) . contains ( new adjlistnode ( nextnode , null ) ) ) { int cost = ( ( int ) ( math . random ( ) * 1000 ) ) + 1 ; graph . getadjlist ( ) . get ( startnode ) . add ( new adjlistnode ( nextnode , new edge ( startnode , nextnode , cost , false ) ) ) ; graph . getadjlist ( ) . get ( nextnode ) . add ( new adjlistnode ( startnode , new edge ( nextnode , startnode , cost , false ) ) ) ; numedgesadded = numedgesadded + 2 ; } } } else if ( numedgesadded > graph . getnumedges ( ) ) { while ( numedgesadded > graph . getnumedges ( ) ) { startnode = ( int ) ( math . random ( ) * numvertices ) ; while ( ( nextnode = ( int ) ( math . random ( ) * numvertices ) ) == startnode ) ; if ( graph . getadjlist ( ) . get ( startnode ) . contains ( new adjlistnode ( nextnode , null ) ) ) { if ( firstincidentedges [ nextnode ] != startnode ) { graph . getadjlist ( ) . get ( startnode ) . remove ( new adjlistnode ( nextnode , null ) ) ; graph . getadjlist ( ) . get ( nextnode ) . remove ( new adjlistnode ( startnode , null ) ) ; numedgesadded = numedgesadded - 2 ; } } } } return graph ; }
va	3	public void run ( ) { string tmp = null ; try { system . out . println ( "start connection!" ) ; while ( ( tmp = ( string ) in . readobject ( ) ) != null ) { system . out . println ( "from client-" + email + ": " + tmp ) ; if ( tmp . equalsignorecase ( "signout" ) ) break ; if ( tmp . equalsignorecase ( "signin" ) ) signin ( ) ; if ( tmp . equalsignorecase ( "register" ) ) register ( ) ; if ( tmp . equalsignorecase ( "updateuser" ) ) update ( ) ; if ( tmp . equalsignorecase ( "senddata" ) ) senddata ( ) ; if ( tmp . equalsignorecase ( "senduser" ) ) senduser ( ) ; if ( tmp . equalsignorecase ( "sendfriends" ) ) sendfriends ( ) ; if ( tmp . equalsignorecase ( "chat" ) ) sendmsgprocess ( ) ; if ( tmp . equalsignorecase ( "sendrequest" ) ) sendrequest ( ) ; if ( tmp . equalsignorecase ( "receiverequest" ) ) receiverequest ( ) ; if ( tmp . equalsignorecase ( "sendrespond" ) ) sendrespond ( ) ; if ( tmp . equalsignorecase ( "receiverespond" ) ) receiverespond ( ) ; if ( tmp . equalsignorecase ( "deletefriend" ) ) deletefriend ( ) ; } close ( ) ; system . out . println ( "close connection!" ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
va	3	@ async public future < searchresult > search ( string keyword ) { logger . debug ( "search keyword:{}" , keyword ) ; long starttime = system . currenttimemillis ( ) ; try { thread . sleep ( threadlocalrandom . current ( ) . nextint ( 10 ) * 1000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } list < string > records = database . get ( keyword ) ; long endtime = system . currenttimemillis ( ) ; if ( records != null ) { return new asyncresult < searchresult > ( new searchresult ( keyword , records , starttime , endtime ) ) ; } else { throw new notfound ( "the keyword '" + keyword + "'did not match any records" ) ; } }
va	9	private void initializemenu ( configurationsection menus , string menu ) { if ( this . menus . containskey ( menu ) ) return ; string parent = menus . getstring ( menu + ".parent" , this . mainmenu ) ; if ( ! this . menus . containskey ( parent ) && ! menu . equals ( this . mainmenu ) ) { initializemenu ( menus , parent ) ; } menu m = new menu ( sc , menu , this . menus . get ( parent ) ) ; configurationsection items = menus . getconfigurationsection ( menu + ".items" ) ; if ( items == null ) { items = menus . createsection ( "items" ) ; } for ( string item : items . getkeys ( false ) ) { int index ; try { index = integer . parseint ( item ) ; } catch ( numberformatexception ex ) { continue ; } string icondata = items . getstring ( item + ".icon" , "280" ) ; int icon ; short data ; try { if ( icondata . contains ( ":" ) ) { string [ ] icda = icondata . split ( ":" , 2 ) ; icon = integer . parseint ( icda [ 0 ] ) ; data = short . parseshort ( icda [ 1 ] ) ; } else { icon = integer . parseint ( icondata ) ; data = 0 ; } } catch ( numberformatexception ex ) { icon = 280 ; data = 0 ; } string name = items . getstring ( item + ".icon-name" , "" ) ; string action = items . getstring ( item + ".link" , "" ) ; if ( icon < 1 || name . isempty ( ) || action . isempty ( ) ) { continue ; } list < string > ing = null ; try { string [ ] acpar = action . split ( "\\\\|" ) ; string linkage = acpar [ 0 ] ; string rec = acpar [ 1 ] ; if ( linkage . equals ( "item" ) ) { enderrecipe er = sc . getrecipemap ( ) . get ( rec ) ; itemmeta recmet = er . getresult ( ) . getitemmeta ( ) ; ing = new arraylist < string > ( ) ; for ( entry < enchantment , integer > ench : recmet . getenchants ( ) . entryset ( ) ) { string en = enderenchantment . getename ( ench . getkey ( ) ) ; ing . add ( chatcolor . gray + en + " " + enderenchantment . toroman ( ench . getvalue ( ) ) ) ; } if ( ing . size ( ) > 0 ) ing . add ( "" ) ; ing . addall ( recmet . getlore ( ) ) ; if ( ing . size ( ) > 0 ) ing . add ( "" ) ; ing . add ( "recipe: " ) ; for ( entry < string , integer > e : er . getingredientsmap ( ) . entryset ( ) ) { ing . add ( chatcolor . white + "(" + e . getvalue ( ) + "x) " + chatcolor . reset + chatcolor . gray + e . getkey ( ) ) ; } sc . replacenames ( ing ) ; } else if ( linkage . equals ( "menu" ) && rec . equals ( "back" ) && ! menu . equals ( this . mainmenu ) ) { action = linkage + "|" + parent ; } } catch ( exception ex ) { } try { m . setitem ( index , icon , data , chatcolor . translatealternatecolorcodes ( '&' , name ) , action , ing ) ; } catch ( illegalargumentexception ex ) { sc . debug ( "failed to add item '" + item + "' to menu '" + menu + "'" ) ; } } this . menus . put ( menu , m ) ; }
va	4	@ override public optional < f > get ( int index ) { optional < list < f > > first = containedlist . head ( ) . map ( flatmapper ) ; if ( first . ispresent ( ) ) { list < f > firstlist = first . get ( ) ; if ( firstlist . isempty ( ) ) { return optional . empty ( ) ; } else { if ( firstlist . length ( ) > index ) { return firstlist . get ( index ) ; } else { return containedlist . tail ( ) . flatmap ( flatmapper ) . get ( index - firstlist . length ( ) ) ; } } } else { return optional . empty ( ) ; } }
va	5	public listarplacasestacionadas ( ) { enumeration items = dadosgerais . placasentrada . keys ( ) ; int z = 0 ; while ( items . hasmoreelements ( ) ) { dadosgerais . listadeplacas [ z ] = ( string ) items . nextelement ( ) ; z ++ ; } stringbuilder estacionados = new stringbuilder ( ) ; for ( int i = 0 ; i < dadosgerais . listadeplacas . length ; i ++ ) { if ( dadosgerais . listadeplacas [ i ] == null ) { i = i + 1 ; } else { estacionados . append ( dadosgerais . listadeplacas [ i ] ) . append ( "\\n" ) ; } } jtextpane textpane = new jtextpane ( ) ; textpane . settext ( estacionados . tostring ( ) ) ; textpane . seteditable ( false ) ; textpane . setsize ( 30 , 150 ) ; styleddocument doc = textpane . getstyleddocument ( ) ; simpleattributeset center = new simpleattributeset ( ) ; styleconstants . setalignment ( center , styleconstants . align_center ) ; doc . setparagraphattributes ( 0 , doc . getlength ( ) , center , false ) ; jscrollpane scrollpane = new jscrollpane ( textpane ) ; scrollpane . setpreferredsize ( new dimension ( 30 , 150 ) ) ; textlinenumber tln = new textlinenumber ( textpane ) ; scrollpane . setrowheaderview ( tln ) ; joptionpane . showmessagedialog ( null , scrollpane , "carros estacionados" , joptionpane . plain_message ) ; system . out . println ( "log: placas listadas." ) ; for ( int x = 0 ; x < dadosgerais . listadeplacas . length ; x ++ ) { dadosgerais . listadeplacas [ x ] = null ; } gui . frame . requestfocus ( ) ; }
va	2	public static string hexagon ( coordinate center , double radius ) { coordinate corner = center . - ( coordinate . y . neg ( ) . scale ( radius ) ) ; string res = "g36*\\n" + string . format ( "x%dy%dd02*\\n" , ( int ) ( corner . x ) , ( int ) ( corner . y ) ) ; for ( int i : new int [ ] { 1 , 2 , 3 , 4 , 5 } ) { corner = corner . - ( center ) . rotate ( math . pi / 3 ) . add ( center ) ; res += string . format ( "x%07dy%07dd01*\\n" , ( int ) ( corner . x ) , ( int ) ( corner . y ) ) ; } res += "g37*" ; return res ; }
va	4	public void load ( string filename ) throws filenotfoundexception { ngramidmap . clear ( ) ; indexmap . clear ( ) ; reader < entry > reader = new abstractfilereader < entry > ( ) { @ override public entry next ( ) { scanner . usedelimiter ( "\\\\s+" ) ; integer id = scanner . nextint ( ) ; integer usecount = scanner . nextint ( ) ; string base = scanner . next ( ) ; return new entry ( new ngram ( base ) , id , usecount ) ; } } ; reader . open ( filename ) ; system . out . println ( "loading dictionary" ) ; while ( reader . hasnext ( ) ) { entry next = reader . next ( ) ; addnewentry ( next ) ; readngramcount += next . usecount ; } reader . close ( ) ; system . out . println ( "dictionary loaded" ) ; }
va	2	public arraylist < data > getdata ( user user ) { if ( user . getrole ( ) . equalsignorecase ( "patient" ) ) return adapter . selectdata ( user . getid ( ) ) ; arraylist < user > friends = adapter . selectfriends ( ( int ) user . getid ( ) ) ; arraylist < data > data = new arraylist < data > ( ) ; for ( user friend : friends ) { data . addall ( adapter . selectdata ( ( int ) friend . getid ( ) ) ) ; } return data ; }
va	6	public static int recursivebinarysearch ( int [ ] sortedarray , int start , int end , int key ) { if ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( key < sortedarray [ mid ] ) { return recursivebinarysearch ( sortedarray , start , mid , key ) ; } else if ( key > sortedarray [ mid ] ) { return recursivebinarysearch ( sortedarray , mid + 1 , end , key ) ; } else { return mid ; } } return - ( start + 1 ) ; }
va	6	public void read ( ) { socketchannel client ; try { print ( "server: waiting for connection..." ) ; client = server . accept ( ) ; } catch ( final ioexception e ) { print ( "server: can't accept" ) ; return ; } objectoutputstream oos = null ; objectinputstream ois = null ; try { oos = new objectoutputstream ( client . socket ( ) . getoutputstream ( ) ) ; ois = new objectinputstream ( client . socket ( ) . getinputstream ( ) ) ; } catch ( final ioexception e ) { print ( "server: can't get streams" ) ; return ; } object obj , object ; list < object > objects ; list < student > students ; integer viewsize ; string name , topstr , botstr ; integer group ; while ( true ) { try { obj = ois . readobject ( ) ; if ( obj != null ) { if ( isequalentclasses ( obj . getclass ( ) , package . class ) ) { final package pack = ( package ) obj ; final mode mode = pack . getmode ( ) ; switch ( mode ) { case add_student : print ( "client: addstudent" ) ; objects = pack . getobjects ( ) ; if ( ( object = getfirstelementifclassequalent ( student . class , objects ) ) != null ) { final student student = ( student ) object ; model . addstudent ( student ) ; print ( "server: add  student " + student . getname ( ) ) ; } break ; case delete_students : print ( "client: deletestudents" ) ; objects = pack . getobjects ( ) ; students = new arraylist < student > ( ) ; for ( final object studobject : objects ) { if ( isequalentclasses ( studobject . getclass ( ) , student . class ) ) { final student student = ( student ) studobject ; students . add ( student ) ; } } model . deletestudents ( students ) ; print ( "server: delete " + students . size ( ) + " students" ) ; break ; case get_curr_page : print ( "client: getcurrpage" ) ; students = model . getcurrpageofstudent ( ) ; sendpackage ( oos , mode . get_curr_page , students ) ; print ( "server: send " + students . size ( ) + " students" ) ; break ; case get_next_page : print ( "client: getnextpage" ) ; students = model . getnextpageofstudents ( ) ; sendpackage ( oos , mode . get_next_page , students ) ; print ( "server: send " + students . size ( ) + " students" ) ; break ; case get_prev_page : print ( "client: getprevpage" ) ; students = model . getprevpageofstudents ( ) ; sendpackage ( oos , mode . get_prev_page , students ) ; print ( "server: send " + students . size ( ) + " students" ) ; break ; case get_students_count : print ( "client: getstudentscount" ) ; final integer studentscount = model . getstudentscount ( ) ; sendpackage ( oos , mode . get_students_count , studentscount ) ; print ( "server: studentscount = " + studentscount ) ; break ; case get_viewsize : print ( "client: getviewsize" ) ; viewsize = model . getviewsize ( ) ; sendpackage ( oos , mode . get_viewsize , viewsize ) ; print ( "server: viewsize = " + viewsize ) ; break ; case get_files_list : print ( "client: getfilelist" ) ; sendpackage ( oos , mode . get_files_list , files . getobjectkeys ( ) ) ; print ( "server: send " + files . size ( ) + " files" ) ; break ; case leaf_next_page : print ( "client: leafnext" ) ; model . leafnext ( ) ; print ( "server: leafnext" ) ; break ; case leaf_prev_page : print ( "client: leafprev" ) ; model . leafprev ( ) ; print ( "server: leafprev" ) ; break ; case open_file : print ( "client: openfile" ) ; objects = pack . getobjects ( ) ; if ( ( object = getfirstelementifclassequalent ( string . class , objects ) ) != null ) { string filename = ( string ) object ; print ( "server: open path " + filename ) ; filename = files . getaddress ( filename ) ; if ( filename != null ) { model . openxml ( new file ( filename ) ) ; } } break ; case save_file : print ( "client: savefile" ) ; objects = pack . getobjects ( ) ; if ( ( object = getfirstelementifclassequalent ( string . class , objects ) ) != null ) { final string filename = ( string ) object ; final string path = server . drive_c + file . separator + filename ; model . savexml ( new file ( path ) ) ; print ( "server: save to " + path ) ; files . addfile ( filename , path ) ; } break ; case search1 : print ( "client: search1" ) ; name = botstr = topstr = "" ; objects = pack . getobjects ( ) ; if ( objects . size ( ) != 0 ) { name = getstring ( objects , 0 , name ) ; botstr = getstring ( objects , 1 , botstr ) ; topstr = getstring ( objects , 2 , topstr ) ; students = model . search ( name , botstr , topstr ) ; objects = new arraylist < object > ( ) ; objects . addall ( students ) ; } else { objects = new arraylist < object > ( ) ; } oos . writeobject ( new package ( mode . search1 , objects ) ) ; break ; case search2 : print ( "client: search2" ) ; name = "" ; group = null ; objects = pack . getobjects ( ) ; if ( objects . size ( ) != 0 ) { name = getstring ( objects , 0 , name ) ; object = pack . getobjects ( ) . get ( 1 ) ; if ( isobjectclassequalent ( object , integer . class ) ) { group = ( integer ) object ; } students = model . search ( name , group ) ; objects = new arraylist < object > ( ) ; objects . addall ( students ) ; } else { objects = new arraylist < object > ( ) ; } oos . writeobject ( new package ( mode . search2 , objects ) ) ; break ; case search3 : print ( "client: search3" ) ; name = botstr = topstr = "" ; string examstr = "" ; objects = pack . getobjects ( ) ; if ( objects . size ( ) != 0 ) { name = getstring ( objects , 0 , name ) ; examstr = getstring ( objects , 1 , examstr ) ; botstr = getstring ( objects , 2 , botstr ) ; topstr = getstring ( objects , 3 , topstr ) ; students = model . search ( name , examstr , botstr , topstr ) ; objects = new arraylist < object > ( ) ; objects . addall ( students ) ; } else { objects = new arraylist < object > ( ) ; } oos . writeobject ( new package ( mode . search3 , objects ) ) ; break ; case set_viewsize : print ( "client: setviewsize" ) ; objects = pack . getobjects ( ) ; if ( ( object = getfirstelementifclassequalent ( integer . class , objects ) ) != null ) { viewsize = ( integer ) object ; model . setviewsize ( viewsize ) ; print ( "server: new viewsize = " + viewsize ) ; } break ; default : print ( "client: unknown command" ) ; break ; } } } } catch ( final ioexception e ) { print ( "server: connection lost" ) ; break ; } catch ( final classnotfoundexception e ) { print ( "classnotfoundexception*****" ) ; e . printstacktrace ( ) ; print ( "***************************" ) ; break ; } } try { oos . close ( ) ; ois . close ( ) ; } catch ( final ioexception e ) { print ( "server: can't close streams" ) ; } read ( ) ; }
va	7	public collection < action > generateactionsforperiod ( collection < stockprice > stockprices ) { collection < action > listofactions = new linkedlist < action > ( ) ; if ( periodstartdaynumber == periodenddaynumber ) { listofactions . add ( new passaction ( periodstartdaynumber ) ) ; return listofactions ; } double income = 0 ; for ( int i = periodstartdaynumber ; i < periodenddaynumber ; i ++ ) { stockprice stockprice = getstockpriceforday ( i , stockprices ) ; if ( stockprice != null ) { listofactions . add ( new buyaction ( i , new share ( stockprice . getprice ( ) ) ) ) ; income += maxsellprice ; } else { listofactions . add ( new passaction ( i ) ) ; } } listofactions . add ( new sellaction ( periodenddaynumber , income ) ) ; return listofactions ; }
va	3	public static name getname ( string notename ) { notename = notename . touppercase ( ) ; if ( ! ( notename . matches ( note_name_pattern ) ) ) { throw new illegalargumentexception ( "invalid note name!" ) ; } switch ( notename ) { case "c" : return name . c ; case "d" : return name . d ; case "e" : return name . e ; case "f" : return name . f ; case "g" : return name . g ; case "a" : return name . a ; case "b" : return name . b ; default : return null ; } }
va	6	public static void main ( string args [ ] ) { abb < integer > p = new abb < integer > ( ) ; int i ; system . out . println ( "insertando nodos recursivamente." ) ; p . insertaabbrecursivo ( 60 ) ; p . insertaabbrecursivo ( 13 ) ; p . insertaabbrecursivo ( 85 ) ; p . insertaabbrecursivo ( 75 ) ; p . insertaabbrecursivo ( 19 ) ; p . insertaabbrecursivo ( 2 ) ; p . insertaabbrecursivo ( 94 ) ; p . insertaabbrecursivo ( 16 ) ; p . insertaabbrecursivo ( 10 ) ; p . insertaabbrecursivo ( 5 ) ; p . insertaabbrecursivo ( 0 ) ; p . insertaabbrecursivo ( 34 ) ; p . insertaabbrecursivo ( 78 ) ; p . insertaabbrecursivo ( 110 ) ; p . insertaabbrecursivo ( 99 ) ; p . insertaabbrecursivo ( 5 ) ; p . insertaabbrecursivo ( 50 ) ; p . insertaabbrecursivo ( 150 ) ; p . insertaabbrecursivo ( 3 ) ; p . insertaabbrecursivo ( 42 ) ; p . insertaabbrecursivo ( 57 ) ; p . insertaabbrecursivo ( 142 ) ; p . insertaabbrecursivo ( 4 ) ; p . insertaabbrecursivo ( 38 ) ; p . insertaabbrecursivo ( 130 ) ; p . insertaabbrecursivo ( 99 ) ; p . insertaabbrecursivo ( 50 ) ; system . out . println ( "\\n***  arbol con inserciones recursivas  *** \\n" ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; system . out . println ( "\\nrecorrido en preorden: " + p . preorden ( ) ) ; system . out . println ( "\\nrecorrido en postorden: " + p . postorden ( ) ) ; p . insertaabbiterativo ( 20 ) ; p . insertaabbiterativo ( 5 ) ; p . insertaabbiterativo ( 35 ) ; p . insertaabbiterativo ( 2 ) ; p . insertaabbiterativo ( 32 ) ; p . insertaabbiterativo ( 27 ) ; p . insertaabbiterativo ( 10 ) ; p . insertaabbiterativo ( 14 ) ; p . insertaabbiterativo ( 7 ) ; p . insertaabbiterativo ( 40 ) ; p . insertaabbiterativo ( 6 ) ; p . insertaabbiterativo ( 142 ) ; p . insertaabbiterativo ( 30 ) ; p . insertaabbiterativo ( 36 ) ; p . insertaabbiterativo ( 46 ) ; p . insertaabbiterativo ( 11 ) ; p . insertaabbiterativo ( 22 ) ; p . insertaabbiterativo ( 5 ) ; system . out . println ( "\\n\\n***  arbol con inserciones iterativas  *** \\n" ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; system . out . println ( "\\nrecorrido en preorden: " + p . preorden ( ) ) ; system . out . println ( "\\nrecorrido en postorden: " + p . postorden ( ) ) ; system . out . println ( "\\n\\n***  probando metodos contiene  *** \\n" ) ; system . out . println ( "\\ncontiene el arbol el dato 42 (iterativo)?: " + ( p . containsabbiterativo ( 42 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 34 (recursivo)?: " + ( p . containsabbrecursivo ( 34 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 18 (iterativo)?: " + ( p . containsabbiterativo ( 18 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 84 (recursivo)?: " + ( p . containsabbrecursivo ( 84 ) ? "si" : "no" ) ) ; system . out . println ( "\\nel arbol tiene " + p . contarnodosrecursivo ( ) + " nodos y " + p . gettotalnodosterminalesrecursivo ( ) + " hojas." ) ; system . out . println ( "\\n\\n***  probando metodo hermano  *** \\n" ) ; system . out . println ( "\\nel hermano de 75 es: " + p . gethermanoabbrecursivo ( 75 ) ) ; system . out . println ( "\\nel hermano de 60 es: " + p . gethermanoabbrecursivo ( 60 ) ) ; system . out . println ( "\\nel hermano de 175 es: " + p . gethermanoabbrecursivo ( 175 ) ) ; system . out . println ( "\\nel hermano de 57 es: " + p . gethermanoabbrecursivo ( 57 ) ) ; system . out . println ( "\\nel hermano de 5 es: " + p . gethermanoabbrecursivo ( 5 ) ) ; system . out . println ( "\\n\\n***  probando metodo padre  *** \\n" ) ; system . out . println ( "\\nel padre de 75 es: " + p . getpadreabbrecursivo ( 75 ) ) ; system . out . println ( "\\nel padre de 60 es: " + p . getpadreabbrecursivo ( 60 ) ) ; system . out . println ( "\\nel padre de 175 es: " + p . getpadreabbrecursivo ( 175 ) ) ; system . out . println ( "\\nel padre de 57 es: " + p . getpadreabbrecursivo ( 57 ) ) ; system . out . println ( "\\nel padre de 5 es: " + p . getpadreabbrecursivo ( 5 ) ) ; system . out . println ( "\\n\\n***  probando metodos mayor y menor  *** \\n" ) ; system . out . println ( "\\nel mayor dato del arbol es: " + p . getmayorabb ( ) ) ; system . out . println ( "\\nel menor dato del arbol es: " + p . getmenorabb ( ) ) ; system . out . println ( "\\n\\n***  probando metodo elimina  *** \\n" ) ; p . eliminadatoabb ( 38 ) ; system . out . println ( "\\nborrando el 38 (dos hijos): " + p . inorden ( ) ) ; p . eliminadatoabb ( 57 ) ; system . out . println ( "\\nborrando el 57 (nodo hoja): " + p . inorden ( ) ) ; p . eliminadatoabb ( 130 ) ; system . out . println ( "\\nborrando el 130 (nodo hoja): " + p . inorden ( ) ) ; p . eliminadatoabb ( 34 ) ; system . out . println ( "\\nborrando el 34 (nodo con un hijo): " + p . inorden ( ) ) ; p . eliminadatoabb ( 100 ) ; system . out . println ( "\\nborrando el 100 (nodo inexistente): " + p . inorden ( ) ) ; p . eliminadatoabb ( 85 ) ; system . out . println ( "\\nborrando el 85 (nodo con dos hijos): " + p . inorden ( ) ) ; p . eliminadatoabb ( 60 ) ; system . out . println ( "\\nborrando el 60 (nodo raiz): " + p . inorden ( ) ) ; system . out . println ( "\\n\\n***  probando metodo clear  *** \\n" ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\n\\ninsertando el 85 (nodo raiz)... " ) ; p . insertaabbiterativo ( 85 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 85 ) ; system . out . println ( "\\nborrando el 85 (nodo raiz sin hijos): " + p . inorden ( ) ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\n\\ninsertando el 36 (nodo raiz)... " ) ; p . insertaabbiterativo ( 36 ) ; system . out . println ( "\\ninsertando el 74 ... " ) ; p . insertaabbiterativo ( 74 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 36 ) ; system . out . println ( "\\nborrando el 36 (nodo raiz con hijo derecho): " + p . inorden ( ) ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\ninsertando el 54 (nodo raiz)... " ) ; p . insertaabbiterativo ( 54 ) ; system . out . println ( "\\ninsertando el 22 ... " ) ; p . insertaabbiterativo ( 22 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 54 ) ; system . out . println ( "\\nborrando el 54 (nodo raiz con hijo izquierdo): " + p . inorden ( ) ) ; system . out . println ( "\\n\\n" ) ; }
va	10	public void cmdcollect ( commandsender sender , string [ ] args ) { player player = null ; if ( sender instanceof player ) { player = ( player ) sender ; } list < eeitemstack > stacks = getdeliveries ( player . getname ( ) ) ; double revenue = getrevenue ( player . getname ( ) ) ; if ( stacks . size ( ) == 0 && revenue == 0 ) { sender . sendmessage ( conf . colormain + "you have no deliveries waiting." ) ; return ; } double tax = revenue * conf . tax ; revenue -= tax ; if ( econ . depositplayer ( player . getname ( ) , revenue ) . transactionsuccess ( ) ) { sender . sendmessage ( conf . colormain + "you have been paid " + conf . coloraccent + revenue + conf . colormain + " in revenue." ) ; getlogger ( ) . info ( player . getdisplayname ( ) + " paid " + revenue + " in revenue." ) ; if ( tax > 0 ) sender . sendmessage ( conf . coloraccent + "" + tax + conf . colormain + " of your revenue was taken as tax (" + conf . coloraccent + ( conf . tax * 100 ) + "%" + conf . colormain + ")" ) ; setrevenue ( player . getname ( ) , 0 ) ; } else { sender . sendmessage ( conf . colorwarning + "error<litcomma> for some reason we couldn't pay you your money. don't worry<litcomma> it's safe." ) ; } inventory inv = player . getinventory ( ) ; while ( inv . firstempty ( ) != - 1 && stacks . size ( ) > 0 ) { eeitemstack stack = stacks . get ( 0 ) ; inv . setitem ( inv . firstempty ( ) , new itemstack ( stack . material , stack . quantity ) ) ; stacks . remove ( 0 ) ; } if ( stacks . size ( ) == 0 ) sender . sendmessage ( conf . colormain + "all items have been delivered successfully." ) ; else sender . sendmessage ( conf . colorwarning + "inventory full<litcomma> please deposit some items in a chest and try again." ) ; getlogger ( ) . info ( "items delivered to " + player . getdisplayname ( ) ) ; }
va	8	public boolean terminaltest ( state state ) { int playedfields = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) { int totalrow = 0 ; for ( int j = 0 ; j < boardsize ; j ++ ) { if ( state . field [ i ] [ j ] != 0 ) playedfields ++ ; totalrow += state . field [ i ] [ j ] ; } if ( math . abs ( totalrow ) == boardsize ) return true ; } if ( playedfields == boardsize * boardsize ) return true ; for ( int j = 0 ; j < boardsize ; j ++ ) { int total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ j ] ; if ( math . abs ( total ) == boardsize ) return true ; } int total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ i ] ; if ( math . abs ( total ) == boardsize ) return true ; total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ boardsize - i - 1 ] ; if ( math . abs ( total ) == boardsize ) return true ; return false ; }
va	7	private void executerequest ( ) { httpclient client = new httpclient ( ) ; httpconnectionmanagerparams hcmanagerparams = client . gethttpconnectionmanager ( ) . getparams ( ) ; hcmanagerparams . setconnectiontimeout ( connectionoption . connectiontimeout ) ; hcmanagerparams . setsotimeout ( connectionoption . opttimeout ) ; postmethod post = new postmethod ( requesturl ) ; if ( requestheaders != null && ! requestheaders . isempty ( ) ) { set < string > headerkeyset = requestheaders . keyset ( ) ; for ( string headerkey : headerkeyset ) { string headervalue = requestheaders . get ( headerkey ) ; post . addrequestheader ( headerkey , headervalue ) ; } } post . setrequestentity ( new stringrequestentity ( requestbody ) ) ; try { responsecode = client . executemethod ( post ) ; responsebody = post . getresponsebodyasstring ( ) ; logger . info ( responsebody ) ; header [ ] rspheaders = post . getresponseheaders ( ) ; responseheaders = new hashmap < string , string > ( ) ; for ( header rspheader : rspheaders ) { responseheaders . put ( rspheader . getname ( ) , rspheader . getvalue ( ) ) ; } } catch ( ioexception ex ) { logger . error ( ex ) ; } }
va	2	@ transactionattribute ( transactionattributetype . requires_new ) public void registersuccmsg ( map < string , string > record , int type ) { string body = record . get ( "body" ) ; if ( body == null ) { body = "" ; } else { try { byte [ ] bytes = body . getbytes ( ) ; if ( bytes . length > 3800 ) { body = new string ( bytes , 0 , 3800 ) ; system . out . println ( body ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } record . put ( "body" , body ) ; boolean ismailactived = ( integer . valueof ( integer . tohexstring ( type ) ) & integer . valueof ( integer . tohexstring ( 1 ) ) ) > 0 ? true : false ; boolean issmsactived = ( integer . valueof ( integer . tohexstring ( type ) ) & integer . valueof ( integer . tohexstring ( 2 ) ) ) > 0 ? true : false ; if ( ismailactived ) { registermaillog ( record ) ; } if ( issmsactived ) { registersmslog ( record ) ; } registermsglog ( record ) ; }
va	6	private list < student > parse ( final document doc ) { final list < student > students = new vector < student > ( ) ; if ( doc == null ) { return students ; } final element root = doc . getdocumentelement ( ) ; final nodelist nodestudents = root . getchildnodes ( ) ; if ( nodestudents != null ) { if ( nodestudents . getlength ( ) != 0 ) { for ( int i = 0 ; i < nodestudents . getlength ( ) ; ++ i ) { final node nodestudent = nodestudents . item ( i ) ; if ( nodestudent != null ) { if ( nodestudent . getnodetype ( ) == node . element_node ) { final student student = parsestudent ( nodestudent ) ; students . add ( student ) ; } } } } } return students ; }
va	10	public void repair ( int count , node n , node badlink ) throws classnotfoundexception , ioexception { node neighborl = new node ( ) ; node neighborr = new node ( ) ; if ( count != 0 && n . links . get ( count - 1 ) != null ) { neighborl = save . read ( n . links . get ( count - 1 ) ) ; } if ( count + 1 < n . links . size ( ) && count + 1 != n . links . size ( ) ) { neighborr = save . read ( n . links . get ( count + 1 ) ) ; } if ( neighborl . keys . size ( ) > ( neighborl . maxkeys / 2 ) - 1 ) { n . rotateright ( badlink , neighborl , count ) ; } else if ( neighborr . keys . size ( ) > ( neighborr . maxkeys / 2 ) - 1 ) { n . rotateleft ( badlink , neighborr , count ) ; } else if ( count == 0 ) { n . mergeright ( neighborr , badlink , count ) ; } else { n . mergeleft ( neighborl , badlink , count - 1 ) ; } for ( node t : n . getnode ( ) ) { save . write ( t ) ; } save . write ( n ) ; }
va	2	protected void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; final color light_color = new color ( 150 , 150 , 150 ) ; final color dark_color = new color ( 0 , 0 , 0 ) ; final color red_color = new color ( 255 , 0 , 0 ) ; final color blue_color = new color ( 0 , 0 , 200 ) ; final color green_color = new color ( 0 , 255 , 0 ) ; int x , y ; int x1 , y1 ; int x2 , y2 ; final int circlesize = 10 ; final int ysize = 350 ; final int xsize = 700 ; if ( ds . networkread == true ) { int height = getheight ( ) ; int width = getwidth ( ) ; double xscale = 1.0 * width / xsize ; double yscale = 1.0 * height / ysize ; g . setcolor ( dark_color ) ; for ( int i = 0 ; i < ds . nodes ; i ++ ) { x = ( int ) ( ds . nodex [ i ] * xscale ) ; y = ( int ) ( ds . nodey [ i ] * yscale ) ; if ( i == 13 ) { g . setcolor ( red_color ) ; } else { g . setcolor ( dark_color ) ; } g . filloval ( x - ( circlesize / 2 ) , height - y - circlesize / 2 , circlesize , circlesize ) ; } for ( int i = 0 ; i < ds . arcs ; i ++ ) { x1 = ( int ) ( ds . nodex [ ds . arcstart [ i ] - 1 ] * xscale ) ; y1 = ( int ) ( ds . nodey [ ds . arcstart [ i ] - 1 ] * yscale ) ; x2 = ( int ) ( ds . nodex [ ds . arcend [ i ] - 1 ] * xscale ) ; y2 = ( int ) ( ds . nodey [ ds . arcend [ i ] - 1 ] * yscale ) ; if ( x1 == x2 && y1 < y2 ) { x1 = x1 + 3 ; x2 = x2 + 3 ; } else { x1 = x1 - 3 ; x2 = x2 - 3 ; } if ( y1 == y2 && x1 < x2 ) { y1 = y1 - 3 ; y2 = y2 - 3 ; } else { y1 = y1 + 3 ; y2 = y2 + 3 ; } if ( ds . arccolor [ i ] == 1 ) { g . setcolor ( red_color ) ; } else if ( ds . arccolor [ i ] == 2 ) { g . setcolor ( green_color ) ; } else if ( ds . arccolor [ i ] == 0 ) { g . setcolor ( blue_color ) ; } g . drawline ( x1 , height - y1 , x2 , height - y2 ) ; } x = ( int ) ( ds . robot1x * xscale ) ; y = ( int ) ( ds . robot1y * yscale ) ; g . drawoval ( x - ( ( circlesize + 10 ) / 2 ) , height - y - ( circlesize + 10 ) / 2 , circlesize + 10 , circlesize + 10 ) ; x = ( int ) ( ds . robot2x * xscale ) ; y = ( int ) ( ds . robot2y * yscale ) ; g . drawoval ( x - ( ( circlesize + 10 ) / 2 ) , height - y - ( circlesize + 10 ) / 2 , circlesize + 10 , circlesize + 10 ) ; } }
va	7	public jsonobject pushmessage ( int pushtype , string messages , string msgkeys , map < string , string > optional ) { this . reseterrorstatus ( ) ; try { map < string , string > args = new hashmap < string , string > ( optional ) ; args . put ( push_type , string . valueof ( pushtype ) ) ; args . put ( messages , messages ) ; args . put ( msg_keys , msgkeys ) ; string [ ] needarray = { push_type , messages , msg_keys } ; args = prepareargs ( needarray , args ) ; args . put ( method , "push_msg" ) ; switch ( pushtype ) { case push_to_user : if ( ! args . containskey ( user_id ) || args . get ( user_id ) == null || args . get ( user_id ) . isempty ( ) ) { throw new channelexception ( "userid should be specified in optional when pushtype is push_to_user" , channel_sdk_param ) ; } break ; case push_to_tag : if ( ! args . containskey ( tag_name ) || args . get ( tag_name ) == null || args . get ( tag_name ) . isempty ( ) ) { throw new channelexception ( "tag should be specified in optional[] when pushtype is push_to_tag" , channel_sdk_param ) ; } break ; case push_to_all : break ; case push_to_device : if ( ! args . containskey ( channel_id ) ) { throw new channelexception ( "channelid should be specified in optional[] when pushtype is push_to_device" , channel_sdk_param ) ; } break ; default : throw new channelexception ( "pushtype value is not supported or not specified" , channel_sdk_param ) ; } return this . commonprocess ( args ) ; } catch ( channelexception ex ) { this . channelexceptionhandler ( ex ) ; return null ; } }
va	2	@ override public void drop ( droptargetdropevent dtde ) { try { transferable tr = dtde . gettransferable ( ) ; dataflavor [ ] flavors = tr . gettransferdataflavors ( ) ; dtde . acceptdrop ( dndconstants . action_copy_or_move ) ; string path = tr . gettransferdata ( flavors [ 0 ] ) . tostring ( ) ; path = path . substring ( 1 , path . length ( ) - 1 ) ; gui . get ( ) . updatedirectorytext ( path ) ; } catch ( exception e ) { dtde . rejectdrop ( ) ; } }
va	3	public static void entercs ( ) throws ioexception , interruptedexception { criticalsection cs = new criticalsection ( ) ; system . out . println ( "entercs()" + " incs:" + getincs ( ) + " token:" + gettokenhere ( ) ) ; if ( gettokenhere ( ) == true ) { setincs ( true ) ; system . out . println ( "incs made" + getincs ( ) + "using token:" ) ; } else { string req = serializereq ( ) ; for ( int i = 0 ; i < mainclass . connectedto . size ( ) ; i ++ ) { sctpclient . sendmessage ( mainclass . clientsocket . get ( mainclass . connectedto . get ( i ) . hostname ) , req ) ; } } while ( gettokenhere ( ) == false && getmytokenid ( ) != mainclass . mynodenumber ) { } int counter = 0 ; while ( getincs ( ) && getmytokenid ( ) == mainclass . mynodenumber ) { if ( counter == 0 ) { writeandincrementcounter ( cs . yourfile ) ; counter ++ ; } } system . out . println ( "not in critical anymore" ) ; }
va	5	@ eventhandler public void onplayerinteractevent ( playerinteractevent event ) { action action = event . getaction ( ) ; player player = event . getplayer ( ) ; if ( ! player . haspermission ( "trophyheads.info" ) ) { logdebug ( "player does not have permission: trophyheads.info" ) ; return ; } if ( action . equals ( action . right_click_block ) ) { org . bukkit . block . block block = event . getclickedblock ( ) ; logdebug ( action . name ( ) + ": " + block . gettype ( ) . name ( ) ) ; if ( block . gettype ( ) . equals ( material . skull ) ) { blockstate bs = block . getstate ( ) ; org . bukkit . block . skull skull = ( org . bukkit . block . skull ) bs ; string pname = "unknown" ; string message = "" ; logdebug ( "skull type: " + skull . getskulltype ( ) . name ( ) ) ; if ( skull . getskulltype ( ) . equals ( skulltype . player ) ) { if ( skull . hasowner ( ) ) { pname = skull . getowner ( ) ; logdebug ( "skull owner: " + pname ) ; if ( pname == null ) { if ( ! nontropyheadmessage . isempty ( ) ) { if ( rightclickcooldowns . containskey ( player . getuniqueid ( ) ) ) { if ( rightclickcooldowns . get ( player . getuniqueid ( ) ) >= system . currenttimemillis ( ) ) { return ; } } player . sendmessage ( nontropyheadmessage ) ; rightclickcooldowns . put ( player . getuniqueid ( ) , system . currenttimemillis ( ) + cooldown ) ; return ; } } else if ( custom_skins . containsvalue ( pname ) ) { message = skull_messages . get ( getcustomskulltype ( pname ) ) ; } else { message = skull_messages . get ( entitytype . player . name ( ) ) ; } } else { message = skull_messages . get ( entitytype . player . tostring ( ) ) ; } } else if ( skull . getskulltype ( ) . name ( ) . equalsignorecase ( "dragon" ) ) { message = skull_messages . get ( entitytype . ender_dragon . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . creeper . tostring ( ) ) ) { message = skull_messages . get ( entitytype . creeper . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . skeleton . tostring ( ) ) ) { message = skull_messages . get ( entitytype . skeleton . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . wither . tostring ( ) ) ) { message = skull_messages . get ( "wither_skeleton" ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . zombie . tostring ( ) ) ) { message = skull_messages . get ( entitytype . zombie . tostring ( ) ) ; } else { message = skull_messages . get ( entitytype . player . tostring ( ) ) ; } if ( pname == null ) { pname = "unknown" ; } if ( message == null ) { message = "" ; } if ( info_blacklist . contains ( pname . tolowercase ( ) ) ) { logdebug ( "ignoring: " + pname ) ; return ; } if ( rightclickcooldowns . containskey ( player . getuniqueid ( ) ) ) { if ( rightclickcooldowns . get ( player . getuniqueid ( ) ) >= system . currenttimemillis ( ) ) { return ; } } message = message . replace ( "%%name%%" , pname ) ; message = chatcolor . translatealternatecolorcodes ( '&' , message ) ; logdebug ( message ) ; player . sendmessage ( message ) ; rightclickcooldowns . put ( player . getuniqueid ( ) , system . currenttimemillis ( ) + cooldown ) ; } } }
va	8	private void generatevisualmodel ( int [ ] [ ] vism , abstractunit [ ] [ ] units , terrain [ ] [ ] terrain ) { for ( int r = 0 ; r < units . length ; r ++ ) { for ( int c = 0 ; c < units . length ; c ++ ) { vism [ r ] [ c ] = units [ r ] [ c ] != null ? units [ r ] [ c ] . toint ( ) : - 1 ; vism [ r ] [ c + units . length ] = terrain [ r ] [ c ] . getpictureid ( ) ; } } }
va	3	@ override public void run ( phonebookconfiguration c , environment e ) throws exception { logger . info ( "method app#run() called" ) ; for ( int i = 0 ; i < c . getmessagerepetitions ( ) ; i ++ ) { system . out . println ( c . getmessage ( ) ) ; } system . out . println ( c . getadditionalmessage ( ) ) ; final dbifactory factory = new dbifactory ( ) ; final dbi jdbi = factory . build ( e , c . getdatasourcefactory ( ) , "mysql" ) ; e . jersey ( ) . register ( new managerresource ( jdbi , e . getvalidator ( ) ) ) ; e . jersey ( ) . register ( new contactresource ( jdbi , e . getvalidator ( ) ) ) ; final client client = new jerseyclientbuilder ( e ) . build ( "rest client" ) ; client . addfilter ( new httpbasicauthfilter ( "john_doe" , "secret" ) ) ; cachingauthenticator < basiccredentials , boolean > authenticator = new cachingauthenticator < basiccredentials , boolean > ( e . metrics ( ) , new phonebookauthenticator ( jdbi ) , cachebuilderspec . parse ( "maximumsize=10000<litcomma> expireafteraccess=10m" ) ) ; e . jersey ( ) . register ( new basicauthprovider < boolean > ( authenticator , "web service realm" ) ) ; e . healthchecks ( ) . register ( "new contact health check" , new newcontacthealthcheck ( client ) ) ; }
va	3	public chessboard ( ) throws chessexception { board = new chesspiece [ 8 ] [ ] ; for ( int i = 0 ; i < 8 ; i ++ ) { board [ i ] = new chesspiece [ 8 ] ; for ( int j = 0 ; j < 8 ; j ++ ) board [ i ] [ j ] = null ; } all_pieces = new chesspiece [ 32 ] ; chesscolor c = chesscolor . color_black ; int j = 0 ; for ( int i = 0 ; i < 2 ; i ++ ) { all_pieces [ j ++ ] = new king ( c ) ; all_pieces [ j ++ ] = new queen ( c ) ; all_pieces [ j ++ ] = new bishop ( c , 1 ) ; all_pieces [ j ++ ] = new bishop ( c , 2 ) ; all_pieces [ j ++ ] = new knight ( c , 1 ) ; all_pieces [ j ++ ] = new knight ( c , 2 ) ; all_pieces [ j ++ ] = new rook ( c , 1 ) ; all_pieces [ j ++ ] = new rook ( c , 2 ) ; for ( int k = 1 ; k < 9 ; k ++ ) all_pieces [ j ++ ] = new pawn ( c , k ) ; c = chesscolor . color_white ; } for ( int i = 0 ; i < 32 ; i ++ ) board [ all_pieces [ i ] . getposition ( ) . getrow ( ) ] [ all_pieces [ i ] . getposition ( ) . getcol ( ) ] = all_pieces [ i ] ; }
va	7	public index ( table t , string ... names ) { int irow = - 1 ; for ( row row : t . rows ) { ++ irow ; key key = new key ( ) ; for ( string name : names ) { try { key . add ( row . get ( name ) ) ; } catch ( exception e ) { system . out . println ( row ) ; } } if ( this . index . containskey ( key ) ) { this . index . get ( key ) . add ( irow ) ; } else { list < integer > list = new arraylist < integer > ( ) ; list . add ( irow ) ; this . index . put ( key , list ) ; } } this . names = names ; this . table = t ; }
va	1	@ test public void testmessage_getparameter ( ) { final arrayparameter arrayparam = new arrayparameter ( "arrayparam" ) ; arrayparam . add ( new singleparameter ( "arrayentry0" , "avalue0" ) ) ; arrayparam . add ( new singleparameter ( "arrayentry1" , "avalue1" ) ) ; arrayparam . add ( new singleparameter ( "arrayentry2" , "avalue2" ) ) ; final groupedparameter groupedparam = new groupedparameter ( "groupedparam" ) ; groupedparam . add ( new singleparameter ( "groupentry0" , "gvalue0" ) ) ; groupedparam . add ( new singleparameter ( "groupentry1" , "gvalue1" ) ) ; groupedparam . add ( new singleparameter ( "groupentry2" , "gvalue2" ) ) ; final message message = new message ( arrayparam , groupedparam ) ; final groupedparameter gotgroupedparam = message . getparameter ( "groupedparam" ) ; assertequals ( groupedparam , gotgroupedparam ) ; }
va	1	public int run ( string [ ] args ) throws ioexception { jobconf jc = new jobconf ( getconf ( ) , getclass ( ) ) ; avrojob . setreflect ( jc ) ; multipleinputs . addinputpath ( jc , new path ( args [ 0 ] ) , avromifwikipage . class , wppagejoinmapper . class ) ; multipleinputs . addinputpath ( jc , new path ( args [ 1 ] ) , avromifwikicategorylink . class , wpcategorylinkjoinmapper . class ) ; schema mokeyschema = reflectdata . get ( ) . getschema ( joinkey . class ) ; schema moschema = reflectdata . get ( ) . getschema ( avrooutputunion . class ) ; avrojob . setmapoutputschema ( jc , pair . getpairschema ( mokeyschema , moschema ) ) ; avrojob . setreducerclass ( jc , wpjoinreducer . class ) ; schema oschema = reflectdata . get ( ) . getschema ( wikititlecategorylink . class ) ; avrojob . setoutputschema ( jc , oschema ) ; jc . setpartitionerclass ( partitionjoinkey . class ) ; jc . setoutputvaluegroupingcomparator ( groupingcomparator . class ) ; fileoutputformat . setoutputpath ( jc , new path ( args [ 2 ] ) ) ; jobclient . runjob ( jc ) ; return 0 ; }
va	1	protected void assertequals ( singleparameter xparam , object obj ) { singleparameter param = ( singleparameter ) obj ; object xvalue = xparam . getvalue ( ) ; if ( xvalue instanceof string ) { assert . assertequals ( ( string ) xvalue , ( string ) param . getvalue ( ) ) ; } else if ( xvalue instanceof integer ) { assert . assertequals ( ( integer ) xvalue , ( integer ) param . getvalue ( ) ) ; } else if ( xvalue instanceof boolean ) { assert . assertequals ( ( boolean ) xvalue , ( boolean ) param . getvalue ( ) ) ; } }
va	3	public static note getnote ( string note ) { if ( ! ( note . matches ( note_pattern ) ) ) { throw new illegalargumentexception ( "invalid note!" ) ; } int arglength = note . length ( ) ; string name = string . valueof ( note . charat ( 0 ) ) ; if ( arglength > 1 ) { if ( note . substring ( 1 , arglength ) . matches ( "(-)?[0-9]+" ) ) { string octave = note . substring ( 1 , arglength ) ; tone tone = tone . gettone ( stringparser . getname ( name ) , element . default_accidental ) ; return new note ( tone , integer . parseint ( octave ) ) ; } string accidental = string . valueof ( note . charat ( 1 ) ) ; if ( arglength > 2 ) { string octave = note . substring ( 2 , arglength ) ; tone tone = tone . gettone ( stringparser . getname ( name ) , stringparser . getaccidental ( accidental ) ) ; return new note ( tone , integer . parseint ( octave ) ) ; } tone tone = tone . gettone ( stringparser . getname ( name ) , stringparser . getaccidental ( accidental ) ) ; return new note ( tone , element . default_octave ) ; } tone tone = tone . gettone ( stringparser . getname ( name ) , element . default_accidental ) ; return new note ( tone , element . default_octave ) ; }
va	6	public string inttoroman ( int num ) { string str = "" ; string symbol [ ] = { "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" } ; int value [ ] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 } ; for ( int i = 0 ; i < value . length ; ) { if ( num >= value [ i ] ) { num = num - value [ i ] ; str = str + symbol [ i ] ; } else { i ++ ; } } return str ; }
va	9	public void setitem ( int index , int id , short dam , string title , string action , list < string > lore ) throws illegalargumentexception { string [ ] acpar = action . split ( "\\\\|" ) ; if ( acpar . length != 2 ) return ; if ( index < 0 || index > 26 ) throw new illegalargumentexception ( "index is " + ( index < 0 ? "too small" : "too large" ) ) ; itemstack i = new itemstack ( id , 1 , dam ) ; itemmeta meta = i . getitemmeta ( ) == null ? i . getitemmeta ( ) : bukkit . getitemfactory ( ) . getitemmeta ( i . gettype ( ) ) ; meta . setdisplayname ( chatcolor . reset + title ) ; meta . setlore ( lore ) ; i . setitemmeta ( meta ) ; this . contents [ index ] = i ; this . slots [ index ] = new slot ( acpar [ 0 ] , acpar [ 1 ] ) ; }
va	1	@ test public void testbasic ( ) throws exception { final arrayparameter params = new arrayparameter ( "" ) ; params . add ( new singleparameter ( "param0" , "value0" ) ) ; params . add ( new singleparameter ( "param1" , 42 ) ) ; params . add ( new singleparameter ( "param2" , true ) ) ; final arrayparameter param3 = new arrayparameter ( "param3" ) ; param3 . add ( new singleparameter ( "param3-1" , "value3-1" ) ) ; param3 . add ( new singleparameter ( "param3-2" , "value3-2" ) ) ; params . add ( param3 ) ; final arrayparameter param4 = new arrayparameter ( "param4" ) ; param4 . add ( new singleparameter ( "param4-1" , "value4-1" ) ) ; params . add ( param4 ) ; final arrayparameter param5 = new arrayparameter ( "param5" ) ; param5 . add ( new singleparameter ( "0" , true ) ) ; param5 . add ( new singleparameter ( "1" , false ) ) ; param5 . add ( new singleparameter ( "2" , true ) ) ; param5 . add ( new singleparameter ( "3" , false ) ) ; params . add ( param5 ) ; final arrayparameter param6 = new arrayparameter ( "param6" ) ; param6 . add ( new singleparameter ( "0" , ( byte ) 4 ) ) ; param6 . add ( new singleparameter ( "0" , ( byte ) 5 ) ) ; param6 . add ( new singleparameter ( "0" , ( byte ) 6 ) ) ; params . add ( param6 ) ; params . add ( new bytearrayparameter ( "param7" , new byte [ ] { 7 , 8 , 9 } ) ) ; params . add ( new booleanarrayparameter ( "param8" , new boolean [ ] { false , true } ) ) ; params . add ( new integerarrayparameter ( "param9" , new int [ ] { 41 , 42 , 43 } ) ) ; params . add ( new singleparameter ( "param10" , "value10" ) ) ; final message message = new message ( "json-msg" , params ) ; showmessage ( message ) ; assert . assertequals ( "json-msg" , message . getname ( ) ) ; final string compactmsgtext = message . tojsonstring ( message . encodemode . compact ) ; final message message1 = new message ( compactmsgtext ) ; showmessage ( message1 ) ; assertequals ( message , message1 ) ; final string compactmsgtext1 = message1 . tojsonstring ( message . encodemode . compact ) ; assert . assertequals ( compactmsgtext1 , compactmsgtext ) ; }
va	2	public static void main ( string [ ] arguments ) { baby david = new baby ( ) ; david . name = "david" ; david . setmale ( true ) ; david . weight = 3.0 ; david . decibels = 100 ; david . poop ( ) ; david . setage ( 2 ) ; system . out . println ( "the baby name is " + david . name ) ; toys toy = new dolls ( "barbie" ) ; cars newcar = new cars ( "masina de politie" ) ; dolls babydoll = new dolls ( null ) ; ihasbattery acar = new cars ( "bmw" ) ; try { ( ( ihasbattery ) toy ) . works ( "ana" ) ; } catch ( batteryexception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } newcar . setbattery ( "masina de politie" ) ; try { newcar . works ( "masina de politie" ) ; } catch ( exception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } try { babydoll . works ( null ) ; } catch ( exception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } try { acar . works ( "bmw" ) ; } catch ( batteryexception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } }
va	6	private void setfield ( class < ? > theclass , object obj , string fieldstring ) throws securityexception , nosuchfieldexception , numberformatexception , illegalargumentexception , illegalaccessexception { int index = fieldstring . indexof ( internal_separator ) ; string fieldname = fieldstring . substring ( 0 , index ) ; string value = fieldstring . substring ( index + 1 ) ; system . out . println ( value ) ; field field = theclass . getdeclaredfield ( fieldname ) ; field . setaccessible ( true ) ; if ( field . gettype ( ) == int . class ) { field . setint ( obj , integer . parseint ( value ) ) ; } }
va	1	public static void main ( string [ ] args ) throws exception { string configuration_filename = new string ( "" ) ; string local_name = new string ( "" ) ; string send_info = new string ( "" ) ; listener = new serversocket ( 12344 ) ; message message = new message ( ) ; messagepasser mp = new messagepasser ( configuration_filename , local_name ) ; mp . createthread ( ) ; socket socket = new socket ( "128.237.174.156" , 12344 ) ; printwriter ot = new printwriter ( socket . getoutputstream ( ) ) ; inputstreamreader reader = new inputstreamreader ( system . in ) ; bufferedreader input = new bufferedreader ( reader ) ; send_info = input . readline ( ) ; while ( ! send_info . equals ( "exit" ) ) { string [ ] command = send_info . split ( " " ) ; if ( command . length != 2 || ! ( command [ 0 ] . equals ( "send" ) || command [ 0 ] . equals ( "read" ) ) ) { system . out . println ( "enter the right command!" ) ; send_info = input . readline ( ) ; continue ; } if ( command [ 0 ] . equals ( "read" ) ) { mp . receive ( ) ; send_info = input . readline ( ) ; continue ; } if ( command [ 0 ] . equals ( "send" ) ) { ot . println ( send_info ) ; ot . flush ( ) ; send_info = input . readline ( ) ; continue ; } } socket . close ( ) ; listener . close ( ) ; system . out . println ( "program exit normally" ) ; }
va	4	private void visitnodes ( list < messagefragment > result , branch root ) { iterator < node > iterator = root . nodeiterator ( ) ; while ( iterator . hasnext ( ) ) { node node = iterator . next ( ) ; string xml = node . asxml ( ) ; if ( node . getnodetype ( ) == node . comment_node ) { result . add ( new simplenonlocalizabletextfragment ( xml ) ) ; } else if ( node . getnodetype ( ) == node . text_node ) { visittextnode ( result , xml ) ; } else if ( node . getnodetype ( ) == node . element_node ) { string starttag = xml . trim ( ) . replaceall ( tag_pattern . pattern ( ) , "$1" ) ; string endtag = xml . trim ( ) . replaceall ( tag_pattern . pattern ( ) , "$3" ) ; if ( starttag . contains ( xliff_tag ) ) { result . add ( new simplenonlocalizabletextfragment ( xml ) ) ; } else { result . add ( new simplenonlocalizabletextfragment ( starttag ) ) ; if ( ( ( element ) node ) . istextonly ( ) ) { visittextnode ( result , node . gettext ( ) ) ; } else { visitnodes ( result , ( element ) node ) ; } result . add ( new simplenonlocalizabletextfragment ( endtag ) ) ; } } else if ( node . getnodetype ( ) == node . namespace_node ) { } else { result . add ( new simplenonlocalizabletextfragment ( xml ) ) ; } } }
va	8	private void maxnwordsrec ( int start , node [ ] ends , int i , int n , maxnresult result ) { if ( start == text . length ) { for ( int j = i ; j < n ; j ++ ) { ends [ j ] = null ; } setresult ( start , ends , result ) ; } else if ( i == n - 1 ) { node end = maxword ( start ) ; ends [ i ] = end ; setresult ( start , ends , result ) ; } else { node node = dictionary . newnode ( text [ start ] ) ; ends [ i ] = node ; maxnwordsrec ( start + 1 , ends , i + 1 , n , result ) ; for ( int j = start + 1 ; node != null && j < text . length ; j ++ ) { node next = node . get ( text [ j ] ) ; if ( next != null && next . exists ( ) ) { ends [ i ] = next ; maxnwordsrec ( j + 1 , ends , i + 1 , n , result ) ; } node = next ; } } }
va	1	public int getamountr ( string type , int [ ] f , int [ ] t ) throws sqlexception { int amount = 0 ; this . connect ( ) ; resultset dataset = this . stat . executequery ( "select * from tbl_admissions where type='" + type + "'" + " and " + "date>=" + "'" + f [ 2 ] + "-" + f [ 0 ] + "-" + f [ 1 ] + "'" + " and " + "date<=" + "'" + t [ 2 ] + "-" + t [ 0 ] + "-" + t [ 1 ] + "'" + " and " + "year between " + f [ 2 ] + " and " + t [ 2 ] ) ; dataset . afterlast ( ) ; while ( dataset . previous ( ) ) { amount ++ ; } return amount ; }
va	3	@ test public void testfailureresult ( ) throws interruptedexception { final countdownlatch latch = new countdownlatch ( 1 ) ; listenablefuture < string > boom = ( listenablefuture < string > ) service . ! ( ) ; final atomicreference < string > deferredresult = new atomicreference < string > ( ) ; futurecallback < string > callback = new futurecallback < string > ( ) { public void onsuccess ( string result ) { } public void onfailure ( throwable t ) { latch . countdown ( ) ; } } ; futures . addcallback ( boom , callback ) ; latch . await ( 2 , timeunit . seconds ) ; assertthat ( deferredresult . get ( ) , is ( nullvalue ( ) ) ) ; exception rootcause = null ; try { boom . get ( ) ; fail ( "should throw the boom excpetion" ) ; } catch ( executionexception e ) { rootcause = ( exception ) e . getcause ( ) ; } assertthat ( rootcause , not ( nullvalue ( ) ) ) ; assertthat ( rootcause , instanceof ( runtimeexception . class ) ) ; assertthat ( rootcause . getmessage ( ) , is ( "boom!" ) ) ; }
va	9	public sadaribuilder addbridge ( int fromline , int toline , int positiony ) { preconditions . checkargument ( linecount > 0 , "you should specify line count of ladder." ) ; preconditions . checkargument ( height > 0 , "you should specify height of ladder." ) ; preconditions . checkargument ( positiony > 0 , "positiony should be positive" ) ; preconditions . checkargument ( positiony < height , "positiony should smaller than height" ) ; preconditions . checkargument ( 0 <= fromline && fromline < linecount , "fromline is out of range." ) ; preconditions . checkargument ( 0 <= toline && toline < linecount , "toline is out of range." ) ; preconditions . checkargument ( fromline != toline , "fromline and toline should be different." ) ; preconditions . checkargument ( math . abs ( fromline - toline ) == 1 , "fromline and toline should be adjacent." ) ; preconditions . checkargument ( ! hasconflictbridge ( fromline , toline , positiony ) , "new bridge is conflict with existing bridge." ) ; bridgeinfo bridgeinfo = new bridgeinfo ( ) ; bridgeinfo . fromline = fromline ; bridgeinfo . toline = toline ; bridgeinfo . positiony = positiony ; this . bridgeinfos . add ( bridgeinfo ) ; return this ; }
va	7	private void loadmembers ( arraylist < integer > taxlist ) throws sqlexception { string qstring = getqstring ( taxlist , type ) ; if ( qstring == null ) { system . out . println ( "unknown type " + type ) ; system . exit ( 0 ) ; } cogs = new hashtable < integer , arraylist < locus > > ( ) ; scaffolds = new hashtable < integer , scaffold > ( ) ; taxonomies = new hashset < integer > ( ) ; connection conn = connectionmanager . getconnection ( 0 ) ; statement stmt = conn . createstatement ( ) ; resultset rs = stmt . executequery ( qstring ) ; int prevcoginfoid = - 1 ; arraylist < locus > genes = null ; while ( rs . next ( ) ) { int coginfoid = rs . getint ( 1 ) ; if ( coginfoid != prevcoginfoid ) { if ( prevcoginfoid != - 1 ) { if ( genes . size ( ) > 1 ) cogs . put ( prevcoginfoid , genes ) ; else system . out . println ( type + prevcoginfoid + " has only 1 record for specified taxonomies; not adding" ) ; } prevcoginfoid = coginfoid ; genes = new arraylist < locus > ( ) ; } int locusid = rs . getint ( 2 ) ; int version = rs . getint ( 3 ) ; int taxonomyid = rs . getint ( 4 ) ; int scaffoldid = rs . getint ( 5 ) ; scaffold sc ; if ( scaffolds . containskey ( scaffoldid ) ) sc = scaffolds . get ( scaffoldid ) ; else { sc = new scaffold ( scaffoldid , taxonomyid , rs . getint ( 6 ) , rs . getbyte ( 7 ) , rs . getint ( 8 ) ) ; scaffolds . put ( scaffoldid , sc ) ; taxonomies . add ( taxonomyid ) ; } dnaposition pos = new dnaposition ( sc , rs . getstring ( 9 ) , rs . getint ( 10 ) , rs . getint ( 11 ) ) ; genes . add ( new locus ( locusid , version , coginfoid , pos , sc ) ) ; } if ( genes . size ( ) > 1 ) cogs . put ( prevcoginfoid , genes ) ; else system . out . println ( type + prevcoginfoid + " has only 1 record for specified taxonomies; not adding" ) ; rs . close ( ) ; stmt . close ( ) ; }
va	8	private int utility ( state state ) { int val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ i ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ boardsize - i - 1 ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; for ( int i = 0 ; i < boardsize ; i ++ ) { val = 0 ; for ( int j = 0 ; j < boardsize ; j ++ ) val += state . field [ i ] [ j ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; } for ( int j = 0 ; j < boardsize ; j ++ ) { val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ j ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; } return 0 ; }
va	3	private static string etable ( ) { string out = "" ; out = r0 . charat ( 31 ) + r0 . substring ( 0 , 4 ) + r0 . charat ( 4 ) ; out += r0 . charat ( 3 ) + r0 . substring ( 4 , 8 ) + r0 . charat ( 8 ) ; out += r0 . charat ( 7 ) + r0 . substring ( 8 , 12 ) + r0 . charat ( 12 ) ; out += r0 . charat ( 11 ) + r0 . substring ( 12 , 16 ) + r0 . charat ( 16 ) ; out += r0 . charat ( 15 ) + r0 . substring ( 16 , 20 ) + r0 . charat ( 20 ) ; out += r0 . charat ( 19 ) + r0 . substring ( 20 , 24 ) + r0 . charat ( 24 ) ; out += r0 . charat ( 23 ) + r0 . substring ( 24 , 28 ) + r0 . charat ( 28 ) ; out += r0 . charat ( 27 ) + r0 . substring ( 28 , 32 ) + r0 . charat ( 0 ) ; return out ; }
va	9	public void updatepotentialsolutionsbar ( final list < string > answers ) { final int a = answers . size ( ) ; final string [ ] answerstoprint = new string [ 5 ] ; for ( int i = 0 ; i < a && i < 5 ; i ++ ) { final double z = math . random ( ) ; answerstoprint [ i ] = answers . get ( ( int ) ( answers . size ( ) * z ) ) ; answers . remove ( ( int ) ( answers . size ( ) * z ) ) ; } if ( a == 1 ) { gui . couldvehadtext . settext ( "you could've had: " + answerstoprint [ 0 ] ) ; } else if ( a == 2 ) { gui . couldvehadtext . settext ( "you could've had: " + answerstoprint [ 0 ] + "<litcomma> " + answerstoprint [ 1 ] ) ; } else if ( a == 3 ) { gui . couldvehadtext . settext ( "you could've had: " + answerstoprint [ 0 ] + "<litcomma> " + answerstoprint [ 1 ] + "<litcomma> " + answerstoprint [ 2 ] ) ; } else if ( a == 4 ) { gui . couldvehadtext . settext ( "you could've had: " + answerstoprint [ 0 ] + "<litcomma> " + answerstoprint [ 1 ] + "<litcomma> " + answerstoprint [ 2 ] + "<litcomma> " + answerstoprint [ 3 ] ) ; } else if ( a >= 5 ) { gui . couldvehadtext . settext ( "you could've had: " + answerstoprint [ 0 ] + "<litcomma> " + answerstoprint [ 1 ] + "<litcomma> " + answerstoprint [ 2 ] + "<litcomma> " + answerstoprint [ 3 ] + "<litcomma> " + answerstoprint [ 4 ] ) ; } }
va	9	protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { linkedlist < billet > panier = new linkedlist < > ( ) ; if ( request . getsession ( ) . getattribute ( "panier" ) != null && ( ( linkedlist < integer > ) request . getsession ( ) . getattribute ( "panier" ) ) . size ( ) > 0 ) { string sql = "select * from billet b inner join utilisateur u on b.id_utilisateur=u.id_utilisateur " + "where" ; int i = 0 ; for ( integer b : ( linkedlist < integer > ) request . getsession ( ) . getattribute ( "panier" ) ) { if ( i > 0 ) { sql += " or " ; } sql += " b.id_billet=" + b ; i ++ ; } connexion c = null ; try { c = new connexion ( ) ; resultset rs = c . executequery ( sql ) ; while ( rs . next ( ) ) { panier . add ( new billet ( rs . getint ( "id_billet" ) , null , new user ( rs . getint ( "id_utilisateur" ) , rs . getstring ( "mail" ) ) , rs . getstring ( "ville_depart" ) , rs . getstring ( "ville_arrivee" ) , rs . gettimestamp ( "date_depart" ) , rs . gettimestamp ( "date_retour" ) , rs . getdate ( "date_validite" ) , rs . getdouble ( "prix_initial" ) , rs . getdouble ( "prix_vente" ) , rs . getstring ( "chemin_image" ) ) ) ; } } catch ( exception e ) { system . out . println ( e ) ; ; } finally { try { c . close ( ) ; } catch ( sqlexception e ) { system . out . println ( e ) ; } } } request . setattribute ( "panier" , panier ) ; request . getrequestdispatcher ( "panier.jsp" ) . forward ( request , response ) ; }
va	3	public void startgame ( ) { scanner s = new scanner ( system . in ) ; chesscolor turn = chesscolor . color_white ; do { system . out . printf ( "\\n>> " ) ; if ( s . findinline ( "([a-ha-h][1-8])\\\\s+([a-ha-h][1-8])" ) != null ) { try { matchresult mr = s . match ( ) ; if ( mr . groupcount ( ) == 2 ) { chessposition from_pos = new chessposition ( mr . group ( 1 ) ) ; chesspiece from = pieceat ( from_pos ) ; if ( from != null ) { if ( from . getcolor ( ) != turn ) system . out . println ( "cannot move this piece. not your turn" ) ; else { chessposition to = new chessposition ( mr . group ( 2 ) ) ; makemove ( from_pos , to ) ; turn = ( turn == chesscolor . color_black ) ? chesscolor . color_white : chesscolor . color_black ; } } else system . out . println ( "no piece to move at that position" ) ; } else system . out . println ( "you must give the full move" ) ; } catch ( illegalstateexception is ) { system . out . println ( "----> error in input" ) ; } catch ( chessexception ce ) { system . out . println ( ce . getmessage ( ) ) ; } } else if ( s . findinline ( "([a-ha-h][1-8])" ) != null ) { try { matchresult mr = s . match ( ) ; if ( mr . groupcount ( ) == 1 ) { chessposition from_pos = new chessposition ( mr . group ( 1 ) ) ; chesspiece from = pieceat ( from_pos ) ; if ( from != null ) { if ( from . getcolor ( ) != turn ) system . out . println ( "cannot move this piece. not your turn" ) ; else { chessmoves moves = from . nextmoves ( this ) ; for ( int i = 0 ; i < moves . getcount ( ) ; i ++ ) { chessposition pos = moves . getmove ( i ) ; chessmoves . movetype mt = moves . movetype ( i ) ; system . out . printf ( "\\t%d: [%c<litcomma>%c]" , i + 1 , pos . getboardcol ( ) , pos . getboardrow ( ) ) ; switch ( mt ) { case capture : system . out . println ( " - capture" ) ; break ; case castle : case invalid : case normal : case promote : default : system . out . println ( ) ; break ; } } } } else system . out . println ( "no piece to move at that position" ) ; } } catch ( illegalstateexception is ) { system . out . println ( "----> error in input" ) ; } catch ( chessexception ce ) { system . out . println ( ce . getmessage ( ) ) ; } } else system . out . println ( "improper input given" ) ; s . nextline ( ) ; } while ( true ) ; }
va	6	public static void findnoncommon ( string word1 , string word2 ) { hashset < character > h1 = new hashset < character > ( ) ; hashset < character > h2 = new hashset < character > ( ) ; for ( int i = 0 ; i < word1 . length ( ) ; i ++ ) { h1 . add ( word1 . charat ( i ) ) ; } for ( int i = 0 ; i < word2 . length ( ) ; i ++ ) { h2 . add ( word2 . charat ( i ) ) ; } char [ ] w1 , w2 ; w1 = word1 . tochararray ( ) ; w2 = word2 . tochararray ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( char i : w1 ) { if ( ! h2 . contains ( i ) ) sb . append ( i ) ; } for ( char i : w2 ) { if ( ! h1 . contains ( i ) ) sb . append ( i ) ; } system . out . println ( sb . tostring ( ) ) ; }
va	4	private static void collect ( node node ) { if ( node == null ) return ; if ( node . getnodename ( ) . equals ( "td" ) ) { node classattribute = node . getattributes ( ) . getnameditem ( "class" ) ; if ( classattribute == null ) return ; if ( contentitems . containskey ( classattribute . getnodevalue ( ) ) ) contentitems . put ( classattribute . getnodevalue ( ) , node . gettextcontent ( ) . trim ( ) ) ; } for ( int i = 0 ; i < node . getchildnodes ( ) . getlength ( ) ; i ++ ) collect ( node . getchildnodes ( ) . item ( i ) ) ; }
va	3	private static individual createendurant ( individual image ) { individual endurant = ontmodel . getontclass ( cidoccrm . e77_persistent_item ) . createindividual ( contentitems . get ( "title-field" ) ) ; image . addproperty ( ontmodel . getproperty ( cidoccrm . p138_represents ) , endurant ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p138i_has_representation ) , image ) ; if ( contentitems . get ( "material-field" ) != null ) { individual material = ontmodel . getontclass ( cidoccrm . e57_material ) . createindividual ( contentitems . get ( "material-field" ) ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p45_consists_of ) , material ) ; material . addproperty ( ontmodel . getproperty ( cidoccrm . p45i_is_incorporated_in ) , endurant ) ; } if ( contentitems . get ( "size-field" ) != null ) { individual size = ontmodel . getontclass ( cidoccrm . e54_dimension ) . createindividual ( contentitems . get ( "size-field" ) ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p43_has_dimension ) , size ) ; size . addproperty ( ontmodel . getproperty ( cidoccrm . p43i_is_dimension_of ) , endurant ) ; } if ( contentitems . get ( "credits-field" ) != null ) addnote ( endurant , "credits: " + contentitems . get ( "credits-field" ) ) ; if ( contentitems . get ( "discoverycontext-field" ) != null ) addnote ( endurant , "discoverycontext: " + contentitems . get ( "discoverycontext-field" ) ) ; if ( contentitems . get ( "inventory_no-field" ) != null ) addnote ( endurant , "inventory no: " + contentitems . get ( "inventory_no-field" ) ) ; if ( contentitems . get ( "inscription-field" ) != null ) addnote ( endurant , "inscription: " + contentitems . get ( "inscription-field" ) ) ; if ( contentitems . get ( "beneficiary_of_charter-field" ) != null ) addnote ( endurant , "beneficiary of charter: " + contentitems . get ( "beneficiary_of_charter-field" ) ) ; if ( contentitems . get ( "edition-field" ) != null ) addnote ( endurant , "edition: " + contentitems . get ( "edition-field" ) ) ; if ( contentitems . get ( "issuer_of_charter-field" ) != null ) addnote ( endurant , "issuer of charter: " + contentitems . get ( "issuer_of_charter-field" ) ) ; if ( contentitems . get ( "negative_id-field" ) != null ) addnote ( endurant , "negative: " + contentitems . get ( "negative_id-field" ) ) ; if ( contentitems . get ( "number_of_preserved_seals-field" ) != null ) addnote ( endurant , "number of preserved seals: " + contentitems . get ( "number_of_preserved_seals-field" ) ) ; if ( contentitems . get ( "original_number_of_seals-field" ) != null ) addnote ( endurant , "original number of seals: " + contentitems . get ( "original_number_of_seals-field" ) ) ; if ( contentitems . get ( "record_id-field" ) != null ) addnote ( endurant , "record: " + contentitems . get ( "record_id-field" ) ) ; if ( contentitems . get ( "tradition-field" ) != null ) addnote ( endurant , "tradition: " + contentitems . get ( "tradition-field" ) ) ; if ( contentitems . get ( "annotation-field" ) != null ) addnote ( endurant , "annotation: " + contentitems . get ( "annotation-field" ) ) ; if ( contentitems . get ( "subtitle-field" ) != null ) addnote ( endurant , "subtitle: " + contentitems . get ( "subtitle-field" ) ) ; if ( contentitems . get ( "description_source-field" ) != null ) addnote ( endurant , "description source: " + contentitems . get ( "description_source-field" ) ) ; if ( contentitems . get ( "caption-field" ) != null ) addnote ( endurant , "caption: " + contentitems . get ( "caption-field" ) ) ; if ( contentitems . get ( "keyword_general-field" ) != null ) addnote ( endurant , "keyword general: " + contentitems . get ( "keyword_general-field" ) ) ; if ( contentitems . get ( "pattern-field" ) != null ) addnote ( endurant , "pattern: " + contentitems . get ( "pattern-field" ) ) ; return endurant ; }
va	9	public void mousedragged ( mouseevent e ) { old_mouse_x = mouse_x ; old_mouse_y = mouse_y ; mouse_x = e . getx ( ) ; mouse_y = e . gety ( ) ; int delta_x = mouse_x - old_mouse_x ; int delta_y = old_mouse_y - mouse_y ; if ( radialmenu . isvisible ( ) ) { int returnvalue = radialmenu . dragevent ( mouse_x , mouse_y ) ; if ( returnvalue == customwidget . s_redraw ) repaint ( ) ; if ( returnvalue != customwidget . s_event_not_consumed ) return ; } else if ( e . iscontroldown ( ) ) { if ( swingutilities . isleftmousebutton ( e ) && swingutilities . isrightmousebutton ( e ) ) { camera . dollycameraforward ( ( float ) ( 3 * ( delta_x + delta_y ) ) , false ) ; } else if ( swingutilities . isleftmousebutton ( e ) ) { camera . orbit ( old_mouse_x , old_mouse_y , mouse_x , mouse_y ) ; } else { camera . translatescenerightandup ( ( float ) ( delta_x ) , ( float ) ( delta_y ) ) ; } repaint ( ) ; } else if ( swingutilities . isleftmousebutton ( e ) && ! e . iscontroldown ( ) && indexofselectedbox >= 0 ) { if ( ! e . isshiftdown ( ) ) { ray3d ray1 = camera . computeray ( old_mouse_x , old_mouse_y ) ; ray3d ray2 = camera . computeray ( mouse_x , mouse_y ) ; point3d intersection1 = new point3d ( ) ; point3d intersection2 = new point3d ( ) ; plane plane = new plane ( normalatselectedpoint , selectedpoint ) ; if ( plane . intersects ( ray1 , intersection1 , true ) && plane . intersects ( ray2 , intersection2 , true ) ) { vector3d translation = point3d . diff ( intersection2 , intersection1 ) ; vector < coloredbox > boxes = scene . coloredboxes ; if ( e . isaltdown ( ) ) { for ( int i = 0 ; i < boxes . size ( ) ; i ++ ) { if ( boxes . get ( i ) . isselected ) { scene . translatebox ( i , translation ) ; } } } else { scene . translatebox ( indexofselectedbox , translation ) ; } repaint ( ) ; } } else { ray3d ray1 = camera . computeray ( old_mouse_x , old_mouse_y ) ; ray3d ray2 = camera . computeray ( mouse_x , mouse_y ) ; point3d intersection1 = new point3d ( ) ; point3d intersection2 = new point3d ( ) ; vector3d v1 = vector3d . cross ( normalatselectedpoint , ray1 . direction ) ; vector3d v2 = vector3d . cross ( normalatselectedpoint , v1 ) ; plane plane = new plane ( v2 , selectedpoint ) ; if ( plane . intersects ( ray1 , intersection1 , true ) && plane . intersects ( ray2 , intersection2 , true ) ) { vector3d translation = point3d . diff ( intersection2 , intersection1 ) ; translation = vector3d . mult ( normalatselectedpoint , vector3d . . ( normalatselectedpoint , translation ) ) ; scene . resizebox ( indexofselectedbox , scene . coloredboxes . elementat ( indexofselectedbox ) . box . getindexofextremecorner ( normalatselectedpoint ) , translation ) ; repaint ( ) ; } } } }
va	2	public void printmostfrequentlyngrams ( group group , int count ) { if ( group . isempty ( ) ) { return ; } int ngramscount = group . uniquengramscount ( ) ; if ( ngramscount < count ) { count = ngramscount ; } print ( "frequently used: " ) ; for ( int i = 1 ; i < count + 1 ; i ++ ) { pair < double , integer > pair = group . getfrequency ( ngramscount - i ) ; print ( dictionary . getinstance ( ) . getngrambyid ( pair . second ) . getbase ( ) + " " ) ; } print ( "\\n" ) ; }
va	6	private int getmin ( int row , int index , arraylist < arraylist < integer > > triangle , int [ ] minvalues ) { int val = triangle . get ( row ) . get ( index ) ; int minvalue = 0 ; if ( row == 0 ) { minvalue = val ; } else { if ( index == 0 ) { minvalue = minvalues [ index ] + val ; } else if ( index == triangle . get ( row ) . size ( ) - 1 ) { minvalue = minvalues [ index - 1 ] + val ; } else { minvalue = math . min ( val + minvalues [ index ] , val + minvalues [ index - 1 ] ) ; } } minvalues [ index ] = minvalue ; return minvalue ; }
va	10	public static boolean piece2 ( double [ ] [ ] [ ] v2 ) { double sum = 0 ; double combs = math . pow ( 2 , n ) ; for ( long key = 1 ; key < combs ; key ++ ) { int numberofchoosencolors = 0 ; double g [ ] [ ] = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( key & ( ( ( long ) 1 ) << i ) ) != 0 ) { g = add ( g , v2 [ i ] ) ; numberofchoosencolors ++ ; } } sum = sum + math . pow ( - 1 , n - numberofchoosencolors ) * piece1 ( g ) ; } sum = sum % p ; if ( math . abs ( sum ) < epsilon ) { sum = 0 ; system . out . println ( "answer: no solution available " ) ; return false ; } system . out . println ( "answer: solution available   " + sum ) ; return true ; }
va	10	@ override public void paint ( graphics g ) { graphics2d g2 = ( graphics2d ) g ; g2 . setrenderinghint ( renderinghints . key_alpha_interpolation , renderinghints . value_alpha_interpolation_quality ) ; g2 . setrenderinghint ( renderinghints . key_rendering , renderinghints . value_render_quality ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2 . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g2 . setcolor ( color . white ) ; g2 . clearrect ( 0 , 0 , this . getwidth ( ) , this . getheight ( ) ) ; if ( arstate != null ) { double widthrect = this . getwidth ( ) * 1.0 / ( 2 * arstate . length ) ; double tmpwidth = widthrect ; double tmpheight = ( this . getheight ( ) * 1.0 - 10 ) / max ; for ( int i = 0 ; i < arstate . length ; i ++ ) { if ( i == firstindex ) { g2 . setcolor ( firstc ) ; } else if ( i == secondindex ) { g2 . setcolor ( secondc ) ; } else { g2 . setcolor ( color . black ) ; } if ( i >= arstate . length - counterfinish ) { g2 . setcolor ( color . darkgray ) ; } int zahl = arstate [ i ] ; if ( g2 . getcolor ( ) != color . black ) { g2 . fillrect ( ( int ) math . floor ( tmpwidth ) , ( int ) math . floor ( this . getheight ( ) - 10 - tmpheight * zahl ) , ( int ) math . floor ( widthrect ) , ( int ) math . floor ( tmpheight * zahl ) ) ; } else { g2 . drawrect ( ( int ) math . floor ( tmpwidth ) , ( int ) math . floor ( this . getheight ( ) - 10 - tmpheight * zahl ) , ( int ) math . floor ( widthrect ) , ( int ) math . floor ( tmpheight * zahl ) ) ; } tmpwidth += 2 * widthrect ; } } }
va	6	public boolean haspathsum ( treenode root , int sum ) { if ( root == null ) return false ; boolean bleft = false , bright = false ; if ( root . left == null && root . right == null ) { if ( sum == root . val ) return true ; else return false ; } if ( root . left != null ) bleft = haspathsum ( root . left , sum - root . val ) ; if ( root . right != null ) bright = haspathsum ( root . right , sum - root . val ) ; return bleft || bright ; }
va	4	public void setenfants ( personne personne ) { arraylist < personne > childs = this . getenfants ( ) ; if ( childs . contains ( personne ) == false ) { if ( personne instanceof fils ) { try { childs . add ( ( fils ) personne ) ; return ; } catch ( exception e ) { system . out . println ( "erreur d'ajout du fils!!! " ) ; e . printstacktrace ( ) ; } } else { if ( personne instanceof fille ) { try { childs . add ( ( fille ) personne ) ; return ; } catch ( exception e ) { system . out . println ( "erreur d'ajout de la fille!!! " ) ; e . printstacktrace ( ) ; } } } return ; } else return ; }
va	6	@ override public list < edge > generatemst ( graph graph ) { fheap = new fheap ( ) ; list < edge > generatedmst = new arraylist < edge > ( ) ; int startnodeindex = graph . selectarandomnode ( ) ; for ( int i = 0 ; i < graph . getnumvertices ( ) ; i ++ ) { fheap . insert ( integer . max_value ) ; } fheap . decreasekey ( fheap . getnodelist ( ) . get ( startnodeindex ) , 0 , startnodeindex ) ; while ( fheap . getsize ( ) != 0 ) { fheapnode newestmstnode = fheap . deletemin ( ) ; startnodeindex = newestmstnode . getindex ( ) ; for ( adjlistnode node : graph . getadjlist ( ) . get ( startnodeindex ) ) { int nodeindex = node . gettargetnode ( ) ; int cost = node . getedge ( ) . getcost ( ) ; fheap . decreasekey ( fheap . getnodelist ( ) . get ( nodeindex ) , cost , startnodeindex ) ; } generatedmst . add ( new edge ( newestmstnode . getpredecessor ( ) , newestmstnode . getindex ( ) , newestmstnode . getcost ( ) , false ) ) ; } generatedmst . remove ( 0 ) ; return generatedmst ; }
va	8	private static vector < color > getkeycolors ( vector < color > src , int cnt , int threshold ) { vector < color > groups = new vector < color > ( ) ; groups . add ( src . get ( 0 ) ) ; boolean add ; for ( int i = 0 ; i < src . size ( ) ; i ++ ) { color c = src . get ( i ) ; add = true ; for ( color col : groups ) { if ( getdist ( c , col ) < threshold ) { add = false ; break ; } } if ( add ) { groups . add ( c ) ; } } while ( groups . size ( ) > cnt ) { groups = getkeycolors ( src , cnt , threshold + ( int ) ( 200 * ( ( groups . size ( ) - cnt ) * ( groups . size ( ) - cnt ) * 0.04 ) ) ) ; } while ( groups . size ( ) < cnt ) { groups = getkeycolors ( src , cnt , threshold - ( int ) ( 200 * ( ( groups . size ( ) - cnt ) * ( groups . size ( ) - cnt ) * 0.04 ) ) ) ; } return groups ; }
va	8	private static string infix2postfix ( string [ ] tokens ) throws calcexception { double c ; string token ; postfix = new stringbuilder ( ) ; opstack = new stack < operator > ( ) ; brstack = new stack < bracket > ( ) ; intstack = new stack < integer > ( ) ; operator op ; bracket br ; int i , rpos ; for ( i = 0 ; i < tokens . length ; i ++ ) { token = tokens [ i ] ; if ( ( op = operator . find ( token ) ) != null ) { nextop ( op ) ; } else if ( ( br = bracket . isopen ( token ) ) != null ) { opstack . push ( operator . skp ) ; brstack . push ( br ) ; intstack . push ( i ) ; } else if ( ( br = bracket . isclosed ( token ) ) != null ) { intstack . push ( i ) ; nextclosed ( br ) ; } else try { c = double . valueof ( token ) ; postfix . append ( token ) ; postfix . append ( " " ) ; } catch ( numberformatexception e ) { throw new calcexception ( "parse error: " + token ) ; } } while ( ! opstack . empty ( ) ) { op = opstack . pop ( ) ; if ( op == operator . skp ) { rpos = intstack . pop ( ) ; throw new calcexception ( string . format ( "mismatched brackets: %s at position %d" , tokens [ rpos ] , rpos + 1 ) ) ; } postfix . append ( op ) ; postfix . append ( " " ) ; } return postfix . tostring ( ) ; }
va	9	public void wordmakesets ( ) { system . out . println ( ">> agrupando palavras por semelhanca... aguarde." ) ; treemap < integer , arraylist < string > > tree = new treemap < integer , arraylist < string > > ( ) ; for ( map . entry < string , disjointset > entry : this . entryset ( ) ) { if ( tree . get ( entry . getkey ( ) . length ( ) ) == null ) { tree . put ( entry . getkey ( ) . length ( ) , new arraylist < string > ( ) ) ; } tree . get ( entry . getkey ( ) . length ( ) ) . add ( entry . getkey ( ) ) ; } for ( map . entry < integer , arraylist < string > > entry : tree . entryset ( ) ) { arraylist < string > possiblesimilarities = new arraylist < string > ( ) ; if ( tree . get ( entry . getkey ( ) - 1 ) != null ) { possiblesimilarities . addall ( tree . get ( entry . getkey ( ) - 1 ) ) ; } if ( tree . get ( entry . getkey ( ) + 1 ) != null ) { possiblesimilarities . addall ( tree . get ( entry . getkey ( ) + 1 ) ) ; } for ( string s : entry . getvalue ( ) ) { for ( string possible : possiblesimilarities ) { if ( wordsimilarity . issimilar ( s , possible ) ) { if ( ! ( this . get ( possible ) . getreference ( ) == this . get ( s ) . getreference ( ) ) ) { this . get ( possible ) . union ( this . get ( s ) ) ; } } } } } }
va	5	private void expand ( ) { int i ; if ( iscompact ) { byte [ ] temparray ; hashes = new int [ indexcount ] ; temparray = new byte [ unicodecount ] ; for ( i = 0 ; i < unicodecount ; ++ i ) { byte value = elementat ( ( char ) i ) ; temparray [ i ] = value ; touchblock ( i > > blockshift , value ) ; } for ( i = 0 ; i < indexcount ; ++ i ) { indices [ i ] = ( char ) ( i << blockshift ) ; } values = null ; values = temparray ; iscompact = false ; } }
va	1	@ test public void testsearchbycursor ( ) { solrquery query = new solrquery ( ) ; int pagesize = 3 ; query . set ( "q" , "video" ) ; query . setrows ( pagesize ) ; query . setsort ( "id" , order . asc ) ; try { boolean hasmore = true ; string cursormark = cursormarkparams . cursor_mark_start ; while ( hasmore ) { query . set ( cursormarkparams . cursor_mark_param , cursormark ) ; queryresponse response = server . query ( query ) ; solrdocumentlist docs = response . getresults ( ) ; for ( solrdocument doc : docs ) { logger . info ( "the doc name:{}" , doc . getfieldvalue ( "id" ) . tostring ( ) ) ; } cursormark = response . getnextcursormark ( ) ; hasmore = docs . size ( ) == pagesize ; logger . warn ( "empty:{}" , hasmore ) ; } } catch ( solrserverexception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
va	10	int days ( int [ ] arrivals , int numperday ) throws exception { if ( arrivals == null || arrivals . length == 0 || arrivals . length > 20 ) { throw new exception ( "arrivals' length must between 1 and 20." ) ; } if ( numperday <= 0 || numperday > 50 ) { throw new exception ( "numperday must between 1 and 50." ) ; } int days = 0 , i = 0 , len = arrivals . length , element , remains = 0 ; for ( ; i < len ; i ++ ) { element = arrivals [ i ] ; if ( element < 0 || element > 100 ) { throw new exception ( "arrival's each element must between 0 and 100." ) ; } remains += element ; if ( remains > 0 ) { remains -= numperday ; days ++ ; } if ( remains < 0 ) { remains = 0 ; } } if ( remains > 0 ) { days += math . ceil ( ( float ) remains / numperday ) ; } return days ; }
va	8	private int getqtdmeses ( ) { int qtdmeses = 0 ; list < string > meses = getmeses ( ) ; string mesinicial = meses . get ( 0 ) ; string mesfinal = meses . get ( 1 ) ; string teste = mesinicial . substring ( 13 , 16 ) . trim ( ) ; int mesinicio = integer . parseint ( mesinicial . substring ( 13 , 16 ) . trim ( ) ) ; int mesfim = integer . parseint ( mesfinal . substring ( 13 , 16 ) . trim ( ) ) ; int anoinicio = integer . parseint ( mesinicial . substring ( 19 , 21 ) . trim ( ) ) ; int anofim = integer . parseint ( mesfinal . substring ( 19 , 21 ) . trim ( ) ) ; if ( anoinicio < anofim || anoinicio != anofim ) { int anos = anofim - anoinicio ; anos = anos * 12 ; qtdmeses = ( mesfim + anos ) - mesinicio ; } else { qtdmeses = mesfim - mesinicio ; } return qtdmeses ; }
va	10	int noguesses ( int upper , int answer ) throws exception { int times = 0 , lower = 1 , guess = 0 ; if ( upper < 1 || upper > 1000 ) { throw new exception ( "upper must between 1 and 1000." ) ; } if ( answer < 1 || answer > upper ) { throw new exception ( "answer must greater than 1 and less than upper." ) ; } while ( guess != answer ) { guess = ( int ) math . floor ( ( lower + upper ) / 2 ) ; times ++ ; if ( guess == answer ) { break ; } else if ( guess < answer ) { lower = guess + 1 ; } else { upper = guess - 1 ; } } return times ; }
va	1	private static void print ( int pixel ) { if ( pixel > 240 ) { system . out . print ( ' ' ) ; } else if ( pixel > 200 ) { system . out . print ( '.' ) ; } else if ( pixel > 160 ) { system . out . print ( '*' ) ; } else if ( pixel > 120 ) { system . out . print ( '~' ) ; } else if ( pixel > 80 ) { system . out . print ( 'x' ) ; } else if ( pixel > 40 ) { system . out . print ( '#' ) ; } else { system . out . print ( '$' ) ; } }
va	4	public static string serializereq ( ) { string alreadyseen = "" ; for ( int i = 0 ; i < mainclass . connectedto . size ( ) ; i ++ ) { alreadyseen = alreadyseen + mainclass . connectedto . get ( i ) . hostname + "<litcomma>" ; } alreadyseen = alreadyseen + mainclass . mynodenumber + "<litcomma>" ; alreadyseen = alreadyseen + "0<litcomma>" ; alreadyseen = alreadyseen . substring ( 0 , alreadyseen . length ( ) - 1 ) ; string req = "rr" + mainclass . mynodenumber + ";" + logicalclock + ";" + mainclass . mynodenumber + ";" + alreadyseen ; return req ; }
va	5	private boolean parseresponse ( bufferedreader in ) throws ioexception { final httpresponse result = new httpresponse ( ) ; string statusline = in . readline ( ) ; result . setstatusline ( statusline ) ; pattern p = pattern . compile ( "\\\\d\\\\d\\\\d" ) ; matcher m = p . matcher ( statusline ) ; while ( m . find ( ) ) { int statuscode = integer . parseint ( m . group ( ) ) ; system . out . println ( statuscode ) ; if ( statuscode < 300 ) { system . out . println ( statusline ) ; string next ; while ( ! ( next = in . readline ( ) ) . equals ( "" ) ) { system . out . println ( next ) ; result . getheaders ( ) . add ( httpheader . createfromheaderline ( next ) ) ; } system . out . println ( result . getbody ( in ) ) ; break ; } else if ( statuscode >= 300 ) { system . out . println ( "error! status code :" + statuscode ) ; return false ; } } return true ; }
va	6	private arraylist < string > combineletter ( string digits , arraylist < string > map ) { arraylist < string > res = new arraylist < string > ( ) ; if ( digits . length ( ) == 0 ) { res . add ( "" ) ; return res ; } int digit = integer . parseint ( digits . substring ( 0 , 1 ) ) ; string mapping = map . get ( digit ) ; string rest = digits . substring ( 1 ) ; arraylist < string > prev = combineletter ( rest , map ) ; for ( char a : mapping . tochararray ( ) ) { for ( string r : prev ) { string t = a + r ; res . add ( t ) ; } } return res ; }
va	4	public static synchronized void receiverequest ( string req ) throws ioexception { system . out . println ( "receiverequest : " + req ) ; req = req . replaceall ( "\\\\n" , "" ) ; req = req . replaceall ( " " , "" ) ; boolean checktimeflag = false ; arraylist < integer > alreadyseenold = new arraylist < > ( ) ; arraylist < integer > alreadyseennew = new arraylist < > ( ) ; string [ ] output = req . split ( ";" ) ; int reqorigin = integer . parseint ( output [ 0 ] ) ; int reqtime = integer . parseint ( output [ 1 ] ) ; int sender = integer . parseint ( output [ 2 ] ) ; output [ 3 ] = output [ 3 ] . replaceall ( "\\\\n" , "" ) ; output [ 3 ] = output [ 3 ] . replaceall ( " " , "" ) ; string [ ] outputalreadyseen = output [ 3 ] . split ( "<litcomma>" ) ; for ( int i = 0 ; i < outputalreadyseen . length - 1 ; i ++ ) { alreadyseenold . add ( integer . parseint ( outputalreadyseen [ i ] ) ) ; } deloldrequest ( reqorigin , reqtime ) ; checktimeflag = checkduplicate ( reqorigin , reqtime ) ; if ( ! checktimeflag ) { logicalclock = math . max ( logicalclock , reqtime ) + 1 ; reqid id = new reqid ( ) ; id . reqorigin = reqorigin ; id . reqtime = reqtime ; system . out . println ( "senderid " + ( sender ) ) ; addtoreqarray ( sender , id ) ; system . out . println ( "added to reqarray:" + reqarray . get ( sender - 1 ) . getlast ( ) . reqorigin + "<litcomma>" + reqarray . get ( sender - 1 ) . getlast ( ) . reqtime ) ; alreadyseennew = createnewalreadyseen ( alreadyseenold ) ; req = constructnewreq ( reqorigin , reqtime , mainclass . mynodenumber , alreadyseennew ) ; for ( int i = 0 ; i < mainclass . connectedto . size ( ) ; i ++ ) { if ( ! alreadyseenold . contains ( mainclass . connectedto . get ( i ) . hostname ) ) { sctpclient . sendmessage ( mainclass . clientsocket . get ( mainclass . connectedto . get ( i ) . hostname ) , req ) ; } } if ( gettokenhere ( ) == true && ! getincs ( ) && ! gettokenforme ( ) ) { settokenhere ( false ) ; transmittoken ( ) ; } } }
va	10	public synchronized void sendtoanimation ( command current , command previous , wrap pos , boolean forward ) { if ( forward ) { pos . seti ( pos . geti ( ) + 1 ) ; switch ( current . type ) { case comparisonflat : first = current . firstindex ; second = current . secondindex ; firstc = color . blue ; secondc = color . blue ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; this . repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case comparisonparent : first = current . firstindex ; second = current . secondindex ; firstc = color . orange ; secondc = color . blue ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case swap : first = current . firstindex ; second = current . secondindex ; firstc = color . red ; secondc = color . red ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } for ( animated = 0 ; animated < 48 ; animated ++ ) { repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } } animated = 0 ; first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case finish : first = current . firstindex ; second = current . secondindex ; firstc = color . magenta ; secondc = color . magenta ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } for ( animated = 0 ; animated < 48 ; animated ++ ) { repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } } animated = 0 ; finished ++ ; adjacentarrayview . counterfinish = finished ; first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case init : first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; finished = 0 ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case end : first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . counterfinish ++ ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; default : system . out . println ( "*@# in sendtoanimation" ) ; break ; } } else { if ( pos . geti ( ) >= 0 ) { if ( pos . geti ( ) > 0 ) { pos . seti ( pos . geti ( ) - 1 ) ; } switch ( current . type ) { case comparisonflat : first = current . firstindex ; second = current . secondindex ; firstc = color . blue ; secondc = color . blue ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; content = previous . state ; adjacentarrayview . arstate = previous . state ; this . repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case comparisonparent : first = current . firstindex ; second = current . secondindex ; firstc = color . orange ; secondc = color . blue ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; content = previous . state ; adjacentarrayview . arstate = previous . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case swap : first = current . firstindex ; second = current . secondindex ; firstc = color . red ; secondc = color . red ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } for ( animated = 48 ; animated > 0 ; animated -- ) { repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } } animated = 50 ; first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = previous . state ; adjacentarrayview . arstate = previous . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case finish : first = current . firstindex ; second = current . secondindex ; firstc = color . magenta ; secondc = color . magenta ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; adjacentarrayview . firstc = firstc ; adjacentarrayview . secondc = secondc ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } for ( animated = 48 ; animated > 0 ; animated -- ) { repaint ( ) ; try { thread . sleep ( wait / 50 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } } animated = 50 ; finished -- ; adjacentarrayview . counterfinish = finished ; first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = previous . state ; adjacentarrayview . arstate = previous . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case init : first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; finished = 0 ; content = current . state ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; case end : first = - 1 ; second = - 1 ; adjacentarrayview . firstindex = first ; adjacentarrayview . secondindex = second ; content = current . state ; adjacentarrayview . counterfinish ++ ; adjacentarrayview . arstate = current . state ; repaint ( ) ; adjacentarrayview . repaint ( ) ; try { thread . sleep ( wait ) ; } catch ( interruptedexception ex ) { logger . getlogger ( heapview . class . getname ( ) ) . log ( level . warning , null , ex ) ; } break ; default : system . out . println ( "*@# in sendtoanimation" ) ; break ; } } } }
va	3	public spreadsheet ( string [ ] [ ] data ) { super ( new gridlayout ( 1 , 0 ) ) ; string [ ] emptylabels = new string [ data [ 0 ] . length ] ; for ( int i = 0 ; i < emptylabels . length ; i ++ ) emptylabels [ i ] = " " ; jt = new jtable ( data , emptylabels ) ; tablemodel model = new defaulttablemodel ( data , emptylabels ) { public boolean iscelleditable ( int row , int column ) { return false ; } } ; jt . setmodel ( model ) ; jt . settableheader ( null ) ; jt . setpreferredscrollableviewportsize ( new dimension ( 500 , 70 ) ) ; jt . setfillsviewportheight ( true ) ; add ( new jscrollpane ( jt ) ) ; }
va	10	public void update ( ciscopong main , world world ) { random random = new random ( ) ; dimension2d windowdimension2d = main . getwindow ( ) . getwindowdimension ( ) ; location . add ( direction ) ; collision = new ellipse2d . double ( location . x , location . y , diamater , diamater ) ; dimension2d window = main . getwindow ( ) . getwindowdimension ( ) ; if ( location . y <= 0 || location . y >= window . getheight ( ) ) { direction . y = ( direction . y * - 1 ) + ( int ) math . random ( ) ; location . add ( direction ) ; } if ( location . x <= 0 ) { paddle paddle = world . getleftpaddle ( ) ; paddle . setlives ( paddle . getlives ( ) - 1 ) ; spawnball ( new vector2 ( ( int ) windowdimension2d . getwidth ( ) / 2 , ( int ) windowdimension2d . getheight ( ) / 2 ) ) ; } if ( location . x >= window . getwidth ( ) ) { paddle paddle = world . getrightpaddle ( ) ; paddle . setlives ( paddle . getlives ( ) - 1 ) ; spawnball ( new vector2 ( ( int ) windowdimension2d . getwidth ( ) / 2 , ( int ) windowdimension2d . getheight ( ) / 2 ) ) ; } applypaddlebounce ( world ) ; colortick ++ ; if ( colortick > colortickreset ) { colortick = 0 ; updatecolor ( ) ; } color color ; }
va	9	public static void main ( string [ ] args ) { try { bufferedreader br1 = new bufferedreader ( new filereader ( new file ( args [ 0 ] ) ) ) ; bufferedwriter bw_poisonous = new bufferedwriter ( new filewriter ( new file ( args [ 1 ] ) ) ) ; bufferedwriter bw_edible = new bufferedwriter ( new filewriter ( new file ( args [ 2 ] ) ) ) ; bufferedwriter bw_indices_map = new bufferedwriter ( new filewriter ( new file ( args [ 3 ] ) ) ) ; set < string > edible_itemset = new treeset < string > ( ) ; set < string > poisonous_itemset = new treeset < string > ( ) ; set < string > itemset = new treeset < string > ( ) ; string newline = null ; stringbuilder sb_edible = new stringbuilder ( "" ) ; stringbuilder sb_poisonous = new stringbuilder ( "" ) ; stringbuilder sb_indexes = new stringbuilder ( "" ) ; while ( ( newline = br1 . readline ( ) ) != null ) { string [ ] items = newline . split ( "<litcomma>" ) ; int noofitems = items . length ; if ( items [ 0 ] . charat ( 0 ) == 'p' ) { for ( int i = 1 ; i < noofitems ; i ++ ) { if ( items [ i ] . charat ( 0 ) != '?' ) { items [ i ] = i + "_" + items [ i ] ; poisonous_itemset . add ( items [ i ] ) ; itemset . add ( items [ i ] ) ; if ( i != noofitems - 1 ) { sb_poisonous . append ( items [ i ] + " " ) ; } else { sb_poisonous . append ( items [ i ] + "\\n" ) ; } } } } else if ( items [ 0 ] . charat ( 0 ) == 'e' ) { for ( int i = 1 ; i < noofitems ; i ++ ) { if ( items [ i ] . charat ( 0 ) != '?' ) { items [ i ] = i + "_" + items [ i ] ; edible_itemset . add ( items [ i ] ) ; itemset . add ( items [ i ] ) ; if ( i != noofitems - 1 ) { sb_edible . append ( items [ i ] + " " ) ; } else { sb_edible . append ( items [ i ] + "\\n" ) ; } } } } } br1 . close ( ) ; bw_poisonous . write ( sb_poisonous . tostring ( ) . trim ( ) ) ; bw_poisonous . close ( ) ; bw_edible . write ( sb_edible . tostring ( ) . trim ( ) ) ; bw_edible . close ( ) ; system . out . println ( "edible items : " + edible_itemset . size ( ) ) ; system . out . println ( "poisonous items : " + poisonous_itemset . size ( ) ) ; system . out . println ( "items : " + itemset . size ( ) ) ; map < string , integer > indexmap = new hashmap < string , integer > ( ) ; int index = 0 ; for ( string s : itemset ) { sb_indexes . append ( s + " " + index + "\\n" ) ; indexmap . put ( s , index ++ ) ; system . out . println ( s + " " + indexmap . get ( s ) ) ; } bw_indices_map . write ( sb_indexes . tostring ( ) . trim ( ) ) ; bw_indices_map . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
va	10	public void interact ( abstractmodel m ) { for ( particle p : m . p ) { if ( p == this ) continue ; double dirx = - math . signum ( this . x - p . x ) ; double diry = - math . signum ( this . y - p . y ) ; double dist = distance2 ( p ) ; if ( isimpact ( dist , p . mass ) ) { this . impacting . add ( p ) ; continue ; } dirx = p . mass * abstractmodel . gravitationalconstant * dirx / dist ; diry = p . mass * abstractmodel . gravitationalconstant * diry / dist ; assert this . speedx <= abstractmodel . lightspeed : this . speedx ; assert this . speedy <= abstractmodel . lightspeed : this . speedy ; double newspeedx = this . speedx + dirx ; newspeedx /= ( 1 + ( this . speedx * dirx ) / abstractmodel . lightspeed ) ; double newspeedy = this . speedy + diry ; newspeedy /= ( 1 + ( this . speedy * diry ) / abstractmodel . lightspeed ) ; if ( ! double . isnan ( dirx ) ) { this . speedx = newspeedx ; } if ( ! double . isnan ( diry ) ) { this . speedy = newspeedy ; } } }
va	7	public parser . events parse ( ) { int c = 0 ; boolean ret = true ; try { while ( ( c = in . read ( ) ) != - 1 && ret ) { this . charsread += 1 ; ret = this . updatestate ( c ) ; if ( ret ) { updateevent ( ) ; ret = updatestrings ( c ) ; } if ( ret && this . event_changed ) { return this . event ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( ! ret ) { system . err . println ( "error at position [" + this . charsread + "] while parsing the input file." ) ; while ( this . tags . size ( ) != 0 ) { system . out . println ( this . tags . pop ( ) ) ; } system . out . println ( this . current_tag ) ; } return parser . events . ev_none ; }
va	5	private boolean validplacetle ( int column , int row , int [ ] [ ] board ) { int sum = 0 ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ row ] [ i ] ; if ( sum > 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ i ] [ column ] ; if ( sum > 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ i ] [ i ] ; if ( sum > 0 ) return false ; return true ; }
va	2	public static void receivemessage ( sctpchannel clientsock ) throws interruptedexception { string [ ] output ; string [ ] outputvector ; bytebuffer bytebuffer ; bytebuffer = bytebuffer . allocate ( 512 ) ; string messagetype = "" ; try { if ( running = true ) { messageinfo messageinfo = clientsock . receive ( bytebuffer , null , null ) ; string message = bytetostring ( bytebuffer ) ; system . out . println ( "received message from server: " + clientsock . getremoteaddresses ( ) + " " + message ) ; messagetype = message . substring ( 0 , 2 ) ; message = message . substring ( 2 , message . length ( ) ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
va	2	public arraylist < int [ ] > remotefriends ( ) { long t_start = system . currenttimemillis ( ) ; int c = 0 ; for ( int a : friendmap . keyset ( ) ) { for ( int b : friendmap . get ( a ) ) { system . out . println ( string . format ( "calculating user with id %d and %d" , a , b ) ) ; int cnt = 0 ; if ( a <= b ) { for ( record ra : user . alluserset . get ( a ) . records ) { for ( record rb : user . alluserset . get ( b ) . records ) { double d = ra . distanceto ( rb ) ; if ( avgdistance . containskey ( a ) ) { if ( avgdistance . get ( a ) . containskey ( b ) ) { double ext = avgdistance . get ( a ) . get ( b ) ; avgdistance . get ( a ) . put ( b , ext + d ) ; } else { avgdistance . get ( a ) . put ( b , d ) ; } } else { avgdistance . put ( a , new hashmap < integer , double > ( ) ) ; avgdistance . get ( a ) . put ( b , d ) ; } cnt ++ ; } } double total = avgdistance . get ( a ) . get ( b ) ; avgdistance . get ( a ) . put ( b , total / cnt ) ; if ( total > 100 ) { int [ ] tuple = { a , b , ( int ) total } ; distantfriend . add ( tuple ) ; } } } c ++ ; if ( c % ( friendmap . size ( ) / 10 ) == 0 ) system . out . println ( string . format ( "process -- remotefriends %d0%%" , c / ( friendmap . size ( ) / 10 ) ) ) ; } long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "found remote friends in %d seconds" , ( t_end - t_start ) / 1000 ) ) ; return distantfriend ; }
va	2	public static void main ( string [ ] args ) throws classnotfoundexception , sqlexception { class . forname ( "com.mysql.jdbc.driver" ) ; connection connect = drivermanager . getconnection ( "jdbc:mysql://localhost/crawlerindex?" + "user=root&password=connect" ) ; connect . setautocommit ( true ) ; preparedstatement titlestatement = connect . preparestatement ( "select * from title" ) ; resultset resultsettitle = titlestatement . executequery ( ) ; while ( resultsettitle . next ( ) ) { title_map . put ( resultsettitle . getstring ( "urls" ) , resultsettitle . getstring ( "title" ) ) ; } int port = integer . parseint ( "1234" ) ; try { thread t = new server ( port ) ; t . start ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
va	4	public static void locationdistancepowerlaw ( int uid ) { try { user u = new user ( uid ) ; bufferedwriter fout = new bufferedwriter ( new filewriter ( string . format ( "res/distance-%d.txt" , u . userid ) ) ) ; for ( int i = 0 ; i < u . records . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < u . records . size ( ) ; j ++ ) { double d = u . records . get ( i ) . distanceto ( u . records . get ( j ) ) ; fout . write ( double . tostring ( d ) + "\\n" ) ; } } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	8	public card dealcard ( ) { numcards = deckcount * 52 ; if ( dealt >= numcards ) { throw new illegalstateexception ( "no cards left in the deck" ) ; } else { cardsremaining = numcards - dealt ; switch ( cardsremaining ) { case 15 : system . out . println ( "15 cards remaining in the shoe" ) ; break ; case 5 : system . out . println ( "5 cards remaining in the shoe<litcomma> adding cards " + "to shoe " ) ; shoe . clear ( ) ; for ( int h = 0 ; h < deckcount ; h ++ ) { for ( int i = 1 ; i < 14 ; i ++ ) { for ( int j = 1 ; j < 4 ; j ++ ) { shoe . add ( new card ( i , j ) ) ; collections . shuffle ( shoe ) ; } } } break ; } dealt ++ ; return shoe . get ( dealt - 1 ) ; } }
va	2	public static long timeparallel ( final int numthreads , final block block ) { final long [ ] times = new long [ 2 ] ; final cyclicbarrier barrier = new cyclicbarrier ( numthreads , new runnable ( ) { public void run ( ) { times [ 0 ] = times [ 1 ] ; times [ 1 ] = system . currenttimemillis ( ) ; } } ) ; parallel ( numthreads , new block ( ) { public void call ( final int index ) { try { barrier . await ( ) ; } catch ( final exception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } try { block . call ( index ) ; } finally { try { barrier . await ( ) ; } catch ( final exception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } } } } ) ; return times [ 1 ] - times [ 0 ] ; }
va	1	public float getvalue ( string s ) { string m [ ] = s . split ( "/" ) ; float a = 1 ; float d [ ] = new float [ m . length ] ; getfloatvalue [ ] st = new getfloatvalue [ m . length ] ; for ( int i = 0 ; i < m . length ; i ++ ) { st [ i ] = new getfloatvalue ( ) ; st [ i ] . setsname ( m [ i ] ) ; d [ i ] = float . parsefloat ( st [ i ] . getsname ( ) ) ; a = d [ i ] * a ; } return a ; }
va	4	public static linkedlist < double > weightedfrequency ( ) { long t_start = system . currenttimemillis ( ) ; locationentropy = readlocationentropyidbased ( ) ; for ( int i = 0 ; i < frequentpair . size ( ) ; i ++ ) { int uaid = frequentpair . get ( i ) [ 0 ] ; int ubid = frequentpair . get ( i ) [ 1 ] ; hashmap < long , integer > coloc = colocationfreq ( uaid , ubid ) ; double weightedfrequency = 0 ; int frequen = 0 ; for ( int f : coloc . values ( ) ) frequen += f ; frequency . add ( frequen ) ; for ( long locid : coloc . keyset ( ) ) { weightedfrequency += coloc . get ( locid ) * math . exp ( - locationentropy . get ( locid ) ) ; } weightedfreq . add ( weightedfrequency ) ; if ( i % ( frequentpair . size ( ) / 10 ) == 0 ) system . out . println ( string . format ( "process - weightedfrequency finished %d0%%" , i / ( frequentpair . size ( ) / 10 ) ) ) ; } long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "weighted frequency (%d pairs) found in %d seconds" , weightedfreq . size ( ) , ( t_end - t_start ) / 1000 ) ) ; return weightedfreq ; }
va	5	public string longestpalindrome ( string s ) { int longestsize = - 1 ; string res = "" ; if ( s . length ( ) == 0 ) return s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j <= i && j < s . length ( ) - i ; j ++ ) { if ( s . charat ( i - j ) == s . charat ( i + j ) ) { if ( j * 2 + 1 > longestsize ) { longestsize = j * 2 + 1 ; res = s . substring ( i - j , i + j + 1 ) ; } } else break ; } for ( int j = 0 ; j <= i && j < s . length ( ) - i - 1 ; j ++ ) { if ( s . charat ( i - j ) == s . charat ( i + j + 1 ) ) { if ( j * 2 + 2 > longestsize ) { longestsize = j * 2 + 2 ; res = s . substring ( i - j , i + j + 2 ) ; } } else break ; } } return res ; }
va	8	public void simulate ( ) { int tick = 0 ; vector < task > metaset = new vector < task > ( s ) ; int i1 = 0 ; int i2 = s ; for ( int i = i1 ; i < i2 ; i ++ ) { task t = new task ( arrivals [ i ] , i ) ; metaset . add ( t ) ; } i1 = i2 ; i2 = ( int ) min ( i1 + s , arrivals . length ) ; tick = arrivals [ i1 - 1 ] ; eng . schedule ( metaset , tick ) ; tick = arrivals [ i2 - 1 ] ; do { if ( i2 == i1 ) { tick = integer . max_value ; removecompletedtasks ( tick ) ; break ; } else { tick = arrivals [ i2 - 1 ] ; removecompletedtasks ( tick ) ; } metaset = new vector < task > ( i2 - i1 ) ; for ( int i = i1 ; i < i2 ; i ++ ) { task t = new task ( arrivals [ i ] , i ) ; metaset . add ( t ) ; } eng . schedule ( metaset , tick ) ; i1 = i2 ; i2 = ( int ) min ( i1 + s , arrivals . length ) ; } while ( ! discontinuesimulation ( ) ) ; }
va	4	public static linkedlist < double > renyientropydiversity ( ) { long t_start = system . currenttimemillis ( ) ; int c1 = 0 , c2 = 0 ; double avg_freq1 = 0 , avg_freq2 = 0 ; for ( int i = 0 ; i < frequentpair . size ( ) ; i ++ ) { int uaid = frequentpair . get ( i ) [ 0 ] ; int ubid = frequentpair . get ( i ) [ 1 ] ; hashmap < long , integer > coloc = colocationfreq ( uaid , ubid ) ; int sum = 0 ; for ( int f : coloc . values ( ) ) { sum += f ; } double [ ] prob = new double [ coloc . size ( ) ] ; int ind = 0 ; for ( int f : coloc . values ( ) ) { prob [ ind ] = ( double ) f / sum ; ind ++ ; } double renyientropy = 0 ; for ( int j = 0 ; j < coloc . size ( ) ; j ++ ) { renyientropy += math . pow ( prob [ j ] , 0.1 ) ; } renyientropy = math . log ( renyientropy ) / 0.9 ; double divs = math . exp ( renyientropy ) ; if ( sum > 1 ) if ( sum != coloc . size ( ) ) { c1 ++ ; avg_freq2 += sum ; } else { c2 ++ ; avg_freq1 += sum ; } renyidiversity . add ( divs ) ; } system . out . println ( string . format ( "uniform: %d pair<litcomma> %g\\t non-unif %d pairs<litcomma> %g" , c2 , avg_freq2 / ( double ) c2 , c1 , avg_freq1 / ( double ) c1 ) ) ; long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "renyi entropy based diversity (%d pair) found in %d seconds!" , renyidiversity . size ( ) , ( t_end - t_start ) / 1000 ) ) ; return renyidiversity ; }
va	6	public listnode reversekgroup ( listnode head , int k ) { if ( k < 2 ) return head ; listnode dummy = new listnode ( - 1 ) ; dummy . next = head ; listnode prev = dummy ; listnode cur = head ; listnode curinner = head ; boolean startreverse = true ; while ( cur != null ) { curinner = cur ; for ( int i = 1 ; i <= k ; i ++ ) { if ( curinner != null ) curinner = curinner . next ; else { startreverse = false ; break ; } } curinner = cur ; if ( startreverse ) { listnode temp = null ; listnode start = cur ; for ( int i = 1 ; i < k ; i ++ ) { temp = curinner . next . next ; curinner . next . next = start ; start = curinner . next ; curinner . next = temp ; } prev . next = start ; prev = curinner ; } cur = curinner . next ; } return dummy . next ; }
va	4	public static linkedlist < double > interestingnesspakdd ( ) { long t_start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < frequentpair . size ( ) ; i ++ ) { int uaid = frequentpair . get ( i ) [ 0 ] ; int ubid = frequentpair . get ( i ) [ 1 ] ; hashset < string > colocs = frequentpair_colocations . get ( i ) ; double finterest = colocationscore ( uaid , ubid , colocs ) ; interestingness . add ( finterest ) ; if ( i % ( frequentpair . size ( ) / 10 ) == 0 ) system . out . println ( string . format ( "process - interestingnesspakdd finished %d0%%" , i / ( frequentpair . size ( ) / 10 ) ) ) ; } long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "interestingness score found in %d seconds" , ( t_end - t_start ) / 1000 ) ) ; return interestingness ; }
va	2	@ override public void actionperformed ( actionevent e ) { object x = e . getsource ( ) ; int threadcounter = 0 ; if ( x == bnextstep ) { game . nextstep ( ) ; repaint ( ) ; } else if ( x == bstart ) { if ( executionthread != null ) executionthread . setshouldwork ( true ) ; else { executionthread = new executionthread ( game , this , true ) ; watek = new thread ( executionthread ) ; watek . start ( ) ; } } else if ( x == bstop ) { if ( ! watek . isinterrupted ( ) ) executionthread . setshouldwork ( false ) ; } }
va	2	public equipo entrada_objeto ( int posequipo ) { cancha . equipo equipo_entrante = null ; try { entrada = sockequipos . get ( posequipo ) . getinputstream ( ) ; entrada_serializada = new objectinputstream ( entrada ) ; equipo_entrante = ( cancha . equipo ) entrada_serializada . readobject ( ) ; system . out . println ( "nombre equipo" + equipo_entrante . equipo ) ; } catch ( ioexception ex ) { logger . getlogger ( conexionservidor . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( conexionservidor . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return equipo_entrante ; }
va	5	protected void readtables ( string datafile ) throws ioexception , missingresourceexception { byte [ ] buffer = readfile ( datafile ) ; int statetablelength = ourbreakiterator . getint ( buffer , 0 ) ; int backwardsstatetablelength = ourbreakiterator . getint ( buffer , 4 ) ; int endstateslength = ourbreakiterator . getint ( buffer , 8 ) ; int lookaheadstateslength = ourbreakiterator . getint ( buffer , 12 ) ; int bmpdatalength = ourbreakiterator . getint ( buffer , 16 ) ; int nonbmpdatalength = ourbreakiterator . getint ( buffer , 20 ) ; int additionaldatalength = ourbreakiterator . getint ( buffer , 24 ) ; checksum = ourbreakiterator . getlong ( buffer , 28 ) ; statetable = new short [ statetablelength ] ; int offset = header_length ; for ( int i = 0 ; i < statetablelength ; i ++ , offset += 2 ) { statetable [ i ] = ourbreakiterator . getshort ( buffer , offset ) ; } backwardsstatetable = new short [ backwardsstatetablelength ] ; for ( int i = 0 ; i < backwardsstatetablelength ; i ++ , offset += 2 ) { backwardsstatetable [ i ] = ourbreakiterator . getshort ( buffer , offset ) ; } endstates = new boolean [ endstateslength ] ; for ( int i = 0 ; i < endstateslength ; i ++ , offset ++ ) { endstates [ i ] = buffer [ offset ] == 1 ; } lookaheadstates = new boolean [ lookaheadstateslength ] ; for ( int i = 0 ; i < lookaheadstateslength ; i ++ , offset ++ ) { lookaheadstates [ i ] = buffer [ offset ] == 1 ; } short [ ] temp1 = new short [ bmp_indices_length ] ; for ( int i = 0 ; i < bmp_indices_length ; i ++ , offset += 2 ) { temp1 [ i ] = ourbreakiterator . getshort ( buffer , offset ) ; } byte [ ] temp2 = new byte [ bmpdatalength ] ; system . arraycopy ( buffer , offset , temp2 , 0 , bmpdatalength ) ; offset += bmpdatalength ; charcategorytable = new compactbytearray ( temp1 , temp2 ) ; int [ ] temp3 = new int [ nonbmpdatalength ] ; for ( int i = 0 ; i < nonbmpdatalength ; i ++ , offset += 4 ) { temp3 [ i ] = ourbreakiterator . getint ( buffer , offset ) ; } supplementarycharcategorytable = new supplementarycharacterdata ( temp3 ) ; if ( additionaldatalength > 0 ) { additionaldata = new byte [ additionaldatalength ] ; system . arraycopy ( buffer , offset , additionaldata , 0 , additionaldatalength ) ; } numcategories = statetable . length / endstates . length ; }
va	5	public listnode mergelists ( listnode a , listnode b ) { if ( a == null ) return b ; if ( b == null ) return a ; listnode dummy = new listnode ( 0 ) ; listnode curra = a , currb = b , curr = dummy ; while ( curra != null || currb != null ) { if ( curra == null ) { curr . next = currb ; currb = currb . next ; } else if ( currb == null ) { curr . next = curra ; curra = curra . next ; } else if ( curra . val < currb . val ) { curr . next = curra ; curra = curra . next ; } else { curr . next = currb ; currb = currb . next ; } curr = curr . next ; } return dummy . next ; }
va	5	@ suppresswarnings ( "unchecked" ) public static void settaglist ( arraylist < integer > taglist , arraylist < string > tagnamelist ) { if ( taglist . size ( ) == tagnamelist . size ( ) && ! taglist . equals ( chosentagids ) ) { chosentagids . clear ( ) ; chosentagnames . clear ( ) ; chosenquestions . clear ( ) ; centroididstodata . clear ( ) ; arraylist < integer > nextchosenquestions ; int tagid ; string tagname ; for ( int i = 0 ; i < taglist . size ( ) ; i ++ ) { tagid = taglist . get ( i ) ; tagname = tagnamelist . get ( i ) ; if ( ! tagtoquestions . containskey ( tagid ) ) { system . err . println ( "unexistent tag id: " + taglist ) ; system . exit ( 1 ) ; } chosentagids . add ( tagid ) ; chosentagnames . add ( tagname ) ; int qid ; if ( ! chosenquestions . isempty ( ) ) { nextchosenquestions = new arraylist < integer > ( ) ; for ( int j = 0 ; j < chosenquestions . size ( ) ; j ++ ) { qid = chosenquestions . get ( j ) ; if ( questiontotags . get ( qid ) . contains ( tagid ) ) { nextchosenquestions . add ( qid ) ; } } chosenquestions = ( arraylist < integer > ) nextchosenquestions . clone ( ) ; if ( chosenquestions . isempty ( ) ) { break ; } } else { chosenquestions = ( arraylist < integer > ) tagtoquestions . get ( tagid ) . clone ( ) ; } } if ( questionidstodata . size ( ) == 0 ) { try { readquestionsdatafile ( ) ; } catch ( ioexception e ) { system . err . println ( "error reading the question_data_file!" ) ; } } questiondata questiondatatmp ; for ( integer qid : chosenquestions ) { questiondatatmp = questionidstodata . get ( qid ) ; if ( ! centroididstodata . containskey ( questiondatatmp . getcluster ( ) ) ) { centroididstodata . put ( questiondatatmp . getcluster ( ) , new centroiddata ( questiondatatmp . getcluster ( ) , questiondata . getfeaturenames ( ) . size ( ) ) ) ; } centroididstodata . get ( questiondatatmp . getcluster ( ) ) . addquestion ( questiondatatmp ) ; } } }
va	5	public static string getworkingdirectory ( ) { string home = system . getproperty ( "user.home" , "." ) ; file dir ; string os = system . getproperty ( "os.name" ) . tolowercase ( ) ; if ( os . contains ( "linux" ) || os . contains ( "unix" ) || os . contains ( "sunos" ) || os . contains ( "solaris" ) ) { dir = new file ( home , ( new stringbuilder ( ) ) . append ( '.' ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } else if ( os . contains ( "win" ) ) { string s2 = system . getenv ( "appdata" ) ; if ( s2 != null ) { dir = new file ( s2 , ( new stringbuilder ( ) ) . append ( "." ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } else { dir = new file ( home , ( new stringbuilder ( ) ) . append ( '.' ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } } else if ( os . contains ( "macos" ) ) { dir = new file ( home , ( new stringbuilder ( ) ) . append ( "library/application support/" ) . append ( unity . folder ) . tostring ( ) ) ; } else { dir = new file ( home , ( new stringbuilder ( ) ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { throw new runtimeexception ( ( new stringbuilder ( ) ) . append ( "the working directory could not be created: " ) . append ( dir ) . tostring ( ) ) ; } else { return dir . getabsolutepath ( ) ; } }
va	7	public static boolean checknearlysquareimage ( string filepath , float nearlyvalue ) throws ioexception { file file = new file ( filepath ) ; bufferedimage buff = fileutil . getimageinfo ( file ) ; float width = buff . getwidth ( ) ; float height = buff . getheight ( ) ; float s = 0 ; if ( width == 0 || height == 0 ) { return false ; } if ( height / width < 1 + nearlyvalue && width / height < 1 + nearlyvalue ) { return true ; } else { return false ; } }
va	3	public static synchronized void transmittokentodest ( int elec , string newtoken ) throws ioexception { for ( int i = 0 ; i < reqarray . size ( ) ; i ++ ) { for ( int j = 0 ; j < reqarray . get ( i ) . size ( ) ; j ++ ) { if ( reqarray . get ( i ) . get ( j ) . reqorigin == elec ) { sctpclient . sendmessage ( mainclass . clientsocket . get ( ( i + 1 ) ) , newtoken ) ; } } } }
va	8	private string parseprojectdetail ( string filepath ) { string contents = "" ; try { bufferedreader reader = new bufferedreader ( new filereader ( filepath ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { line = line . trim ( ) ; int equalspos = line . indexof ( "=" ) ; string key = ( equalspos >= 0 ) ? line . substring ( 0 , equalspos ) . trim ( ) : "" ; string value = ( equalspos >= 0 ) ? line . substring ( equalspos + 1 ) . trim ( ) : "" ; if ( key . equalsignorecase ( "projectname" ) ) { contents += "<h2>" + value + "</h2>" ; } else if ( ! value . isempty ( ) ) { contents += value + "<br>" ; } } reader . close ( ) ; } catch ( exception e ) { sfapexdoc . log ( "parseprojectdetail(" + filepath + "): " + e . getmessage ( ) ) ; } return contents . trim ( ) ; }
va	5	public void insertaabbiterativo ( t dato ) { nodoarbol < t > nodato = new nodoarbol < t > ( dato ) ; int i ; if ( this . raiz == null ) this . raiz = nodato ; else { nodoarbol < t > temp = this . raiz ; i = temp . dato . compareto ( dato ) ; nodoarbol < t > pos = null ; if ( i == 0 ) return ; if ( i > 0 ) pos = temp . izq ; if ( i < 0 ) pos = temp . der ; while ( pos != null ) { temp = pos ; i = temp . dato . compareto ( dato ) ; if ( i == 0 ) return ; if ( i > 0 ) pos = temp . izq ; if ( i < 0 ) pos = temp . der ; } if ( i > 0 ) temp . izq = nodato ; if ( i < 0 ) temp . der = nodato ; } }
va	7	private boolean updatestate ( int i ) { int c = ( char ) i ; switch ( this . state ) { case s_del : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_small : this . state = ( '/' == c ) ? parser . states . s_end_tag_slash : ( ( '!' != c ) ? parser . states . s_tag : parser . states . s_doctype ) ; break ; case s_tag : this . state = ( '>' == c ) ? parser . states . s_tag_gt : ( ( ' ' == c ) ? parser . states . s_tag_space : ( ( '/' == c ) ? parser . states . s_tag_slash : parser . states . s_tag ) ) ; break ; case s_tag_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_tag_delim : parser . states . s_text ) ; break ; case s_tag_delim : this . state = ( '\\n' == c || ' ' == c ) ? parser . states . s_tag_delim : ( ( '<' == c ) ? parser . states . s_small : parser . states . s_text ) ; break ; case s_text : this . state = ( '<' == c ) ? parser . states . s_end_tag_sm : parser . states . s_text ; break ; case s_end_tag_sm : this . state = ( '/' == c ) ? parser . states . s_end_tag_slash : parser . states . s_error ; break ; case s_end_tag_slash : this . state = parser . states . s_end_tag ; break ; case s_end_tag : this . state = ( '>' == c ) ? parser . states . s_end_tag_gt : parser . states . s_end_tag ; break ; case s_end_tag_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_doctype : this . state = ( '>' == c ) ? parser . states . s_doctype_gt : parser . states . s_doctype ; break ; case s_doctype_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_tag_space : this . state = ( ' ' == c ) ? parser . states . s_tag_space : ( ( '/' == c ) ? parser . states . s_tag_slash : parser . states . s_tag_att ) ; break ; case s_tag_att : this . state = ( '/' == c ) ? parser . states . s_tag_slash : ( ( '>' == c ) ? parser . states . s_tag_gt : parser . states . s_tag_att ) ; break ; case s_tag_slash : this . state = ( '>' == c ) ? parser . states . s_tag_no_end_gt : parser . states . s_tag_att ; break ; case s_tag_no_end_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; default : system . err . println ( "unknown state" + this . state ) ; return false ; } if ( parser . states . s_error != this . state ) { return true ; } else { return false ; } }
va	8	public void render ( vector < somvector > inputs ) { float fl = ( float ) math . sqrt ( inputs . size ( ) ) ; int qb = math . round ( fl ) ; if ( fl > qb ) qb += 1 ; float cellwidth = img . getwidth ( ) / qb ; float cellheight = img . getheight ( ) / qb ; int imgw = img . getwidth ( ) ; int imgh = img . getheight ( ) ; graphics2d g2 = img . creategraphics ( ) ; g2 . setcolor ( color . black ) ; g2 . fillrect ( 0 , 0 , imgw , imgh ) ; for ( int x = 0 ; x < qb ; x ++ ) { for ( int y = 0 ; y < qb ; y ++ ) { somvector vec = null ; if ( ( y + qb * x ) < inputs . size ( ) ) vec = inputs . get ( y + qb * x ) ; else vec = getnone ( ) ; color c = new color ( vec . get ( 0 ) , vec . get ( 1 ) , vec . get ( 2 ) ) ; g2 . setcolor ( c ) ; g2 . fillrect ( ( int ) ( x * cellwidth ) , ( int ) ( y * cellheight ) , ( int ) cellwidth + 1 , ( int ) cellheight + 1 ) ; } } g2 . dispose ( ) ; repaint ( ) ; }
va	5	private void handleclient ( ) throws ioexception { inputstream instream = clisock . getinputstream ( ) ; outputstream outstream = clisock . getoutputstream ( ) ; inputstreamreader inputstreamreader = new inputstreamreader ( instream ) ; bufferedreader in = new bufferedreader ( inputstreamreader ) ; printwriter out = new printwriter ( outstream ) ; simpledateformat formatter = new simpledateformat ( "yyyy-mm-dd" ) ; date date ; string response = null ; try { date = formatter . parse ( in . readline ( ) ) ; date today = new date ( ) ; int diffindays = ( int ) ( ( date . gettime ( ) - today . gettime ( ) ) / ( 1000 * 60 * 60 * 24 ) ) ; response = "the diffrence is: " + diffindays ; } catch ( parseexception e ) { response = "err cannot prase date!!!" ; } out . println ( response ) ; out . flush ( ) ; out . close ( ) ; }
va	2	public static string tomd5 ( char [ ] input , boolean clearinput ) { string md5 = null ; if ( input != null ) { try { byte [ ] arraybytesinput = tobytes ( input ) ; messagedigest md = messagedigest . getinstance ( "md5" ) ; byte [ ] arraybytesmd5 = md . digest ( arraybytesinput ) ; arrays . fill ( arraybytesinput , ( byte ) 0 ) ; if ( clearinput ) { arrays . fill ( input , '\x00' ) ; } biginteger bigintmd5 = new biginteger ( 1 , arraybytesmd5 ) ; md5 = bigintmd5 . tostring ( 16 ) ; while ( md5 . length ( ) < 32 ) { md5 = "0" + md5 ; } } catch ( nosuchalgorithmexception ex ) { logger . getlogger ( util . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } return md5 ; }
va	1	@ test public void testarrayparameter_get ( ) { final arrayparameter arrayparam = new arrayparameter ( "arrayparam" ) ; final singleparameter ap0 = new singleparameter ( "arrayentry0" , "avalue0" ) ; final singleparameter ap1 = new singleparameter ( "arrayentry1" , "avalue1" ) ; final singleparameter ap2 = new singleparameter ( "arrayentry2" , "avalue2" ) ; arrayparam . add ( ap0 ) ; arrayparam . add ( ap1 ) ; arrayparam . add ( ap2 ) ; assertequals ( ap0 , arrayparam . get ( ap0 . getname ( ) ) ) ; assertequals ( ap1 , arrayparam . get ( ap1 . getname ( ) ) ) ; assertequals ( ap2 , arrayparam . get ( ap2 . getname ( ) ) ) ; }
va	4	public arraylist < data > selectdata ( long user_id ) { arraylist < data > datalist = new arraylist < data > ( ) ; string query = "select * from mydata " + "where uid = ?" ; try { preparedstatement = connection . preparestatement ( query ) ; preparedstatement . setlong ( 1 , user_id ) ; resultset rs = preparedstatement . executequery ( ) ; while ( rs . next ( ) ) { data data = new data ( ) ; data . setid ( rs . getint ( "id" ) ) ; data . settime ( rs . gettimestamp ( "thetime" ) ) ; data . setbg ( rs . getint ( "bg" ) ) ; data . setinsulin ( rs . getint ( "insulin" ) ) ; data . setuserid ( user_id ) ; system . out . println ( "time " + data . gettime ( ) + " bg " + data . getbg ( ) ) ; datalist . add ( data ) ; } rs . close ( ) ; } catch ( sqlexception ex ) { ex . printstacktrace ( ) ; } return datalist ; }
va	5	public encerraraplicacao ( ) { int dialogbutton = joptionpane . yes_no_option ; int dialogresult = joptionpane . showconfirmdialog ( null , "deseja mesmo encerrar a aplica\xe7\xe3o?" , "sair" , dialogbutton ) ; if ( ! dadosgerais . placasentrada . isempty ( ) && dialogresult == 0 ) { joptionpane . showmessagedialog ( null , "n\xe3o \xe9 poss\xedvel encerrar o sistema com carros estacionados no p\xe1tio. \\r\\n" + "por favor<litcomma> fa\xe7a login como um novo usu\xe1rio ou registre a sa\xedda dos ve\xedculos estacionados no p\xe1tio." , "aviso" , joptionpane . error_message ) ; login . antigouser = login . usuario ; login . usuario = joptionpane . showinputdialog ( "nome de usu\xe1rio:\\n" ) ; login login = new login ( ) ; if ( ! login . usuario . equals ( login . antigouser ) ) { gerarrelatorio gerarrelatoriorelogin = new gerarrelatorio ( ) ; joptionpane . showmessagedialog ( null , "caixa do usu\xe1rio " + login . antigouser + " encerrado e salvo." ) ; salvardb salvar = new salvardb ( ) ; } } else if ( dadosgerais . placasentrada . isempty ( ) && dialogresult == 0 ) { login . antigouser = login . usuario ; gerarrelatorio gerarrelatorio = new gerarrelatorio ( ) ; joptionpane . showmessagedialog ( null , "caixa do usu\xe1rio " + login . usuario + " encerrado e salvo." ) ; salvardb salvar = new salvardb ( ) ; file finalizardbentrada = new file ( dadosgerais . pathdbentrada ) ; file finalizardbsaida = new file ( dadosgerais . pathdbsaida ) ; file finalizarlastlogin = new file ( dadosgerais . pathlastlogin ) ; if ( finalizardbentrada . exists ( ) ) { finalizardbentrada . delete ( ) ; system . out . println ( "log: finalizando db. 50%" ) ; } if ( finalizardbsaida . exists ( ) ) { finalizardbsaida . delete ( ) ; system . out . println ( "log: finalizando db. 100%" ) ; } if ( finalizarlastlogin . exists ( ) ) { finalizarlastlogin . delete ( ) ; system . out . println ( "log: finalizando lastlogin." ) ; } system . out . println ( "log: usu\xe1rio " + login . antigouser + " encerrou o sistema." ) ; system . out . println ( "log: aplica\xe7\xe3o encerrada com status 0 (ok)" ) ; system . exit ( 0 ) ; } else { gui . frame . requestfocus ( ) ; } }
va	10	@ override public void process ( ctconstructorimpl element ) { string imp = "com.google.common.collect." ; ctblock body = element . getbody ( ) ; list < ctstatement > statement = body . getstatements ( ) ; arraylist < string > lines = new arraylist ( ) ; arraylist < string > arrayinst = new arraylist ( ) ; arraylist < string > finalinst = new arraylist ( ) ; arraylist < integer > torem = new arraylist ( ) ; map < string , string > map = new hashmap ( ) ; int i = 0 ; for ( ctstatement ct : statement ) { string s = ct . tostring ( ) ; lines . add ( s ) ; if ( s . contains ( "new java.util.arraylist" ) ) { arrayinst . add ( returninst ( s ) ) ; string g = i + "" ; map . put ( returninst ( s ) , g ) ; } i ++ ; } for ( string s : arrayinst ) { string ph = "" ; string be = "" ; for ( string s2 : lines ) { if ( s2 . contains ( s + ".add(" ) ) { if ( ph . equals ( "" ) ) { ph = s2 . substring ( s2 . indexof ( ".add(" ) + 5 , s2 . lastindexof ( ")" ) ) ; } else { ph += "<litcomma>" + s2 . substring ( s2 . indexof ( ".add(" ) + 5 , s2 . lastindexof ( ")" ) ) ; } be = s ; torem . add ( lines . indexof ( s2 ) ) ; } } if ( ! be . equals ( "" ) ) { finalinst . add ( be + "= " + imp + "lists.newarraylist(" + ph + ")" + "|" + map . get ( be ) ) ; } } for ( int n = 0 ; n < statement . size ( ) ; n ++ ) { for ( string s : finalinst ) { int j = integer . parseint ( returnend ( s ) ) ; if ( n == j ) { statement . set ( n , getfactory ( ) . code ( ) . createcodesnippetstatement ( returnbeg ( s ) ) ) ; } } } int n = statement . size ( ) ; while ( n > 0 ) { if ( torem . contains ( n ) ) { statement . remove ( n ) ; torem . remove ( torem . indexof ( n ) ) ; } else { n -- ; } } element . getbody ( ) . setstatements ( statement ) ; }
va	7	public venncanvas ( venndiagram venn ) { size = 700 ; bi = new bufferedimage ( size , size , bufferedimage . type_int_argb ) ; frc = bi . creategraphics ( ) . getfontrendercontext ( ) ; size *= .8 ; centers = venn . centers ; diameters = venn . diameters ; colors = venn . colors ; labels = venn . circlelabels ; mins = double . positive_infinity ; maxs = double . negative_infinity ; for ( int i = 0 ; i < centers . length ; i ++ ) { double margin = diameters [ i ] / 2 ; mins = math . min ( centers [ i ] [ 0 ] - margin , mins ) ; mins = math . min ( centers [ i ] [ 1 ] - margin , mins ) ; maxs = math . max ( centers [ i ] [ 0 ] + margin , maxs ) ; maxs = math . max ( centers [ i ] [ 1 ] + margin , maxs ) ; } }
va	7	private void show ( int max_doc_num ) throws exception { if ( doc_weight_map . size ( ) != 0 ) { system . out . println ( doc_weight_map . size ( ) + " acticles contain the word(s)!" ) ; valuecomparator value_compr = new valuecomparator ( doc_weight_map ) ; treemap < string , double > sorted_map = new treemap < string , double > ( value_compr ) ; sorted_map . putall ( doc_weight_map ) ; int doc_num = 0 ; for ( string file_name : sorted_map . keyset ( ) ) { if ( doc_num < max_doc_num ) { double tf_idf = doc_weight_map . get ( file_name ) ; system . out . println ( file_name + ": score=" + tf_idf ) ; searchdoc ( file_name ) ; } doc_num ++ ; } } else { system . out . println ( "the word(s) cannot be found!" ) ; } }
va	9	static string sectotime ( int time ) { string timestr = null ; int hour = 0 ; int minute = 0 ; int second = 0 ; if ( time <= 0 ) return "00:00" ; else { minute = time / 60 ; if ( minute < 60 ) { second = time % 60 ; timestr = "00:" + unitformat ( minute ) + ":" + unitformat ( second ) ; } else { hour = minute / 60 ; if ( hour > 99 ) return "99:59:59" ; minute = minute % 60 ; second = time - hour * 3600 - minute * 60 ; timestr = unitformat ( hour ) + ":" + unitformat ( minute ) + ":" + unitformat ( second ) ; } } return timestr ; }
va	9	private boolean removecandidatepairs ( nakedcandidates current , nakedcandidates comparator ) { boolean cp = ( current . y == comparator . y ? true : false ) ; boolean rp = ( current . x == comparator . x ? true : false ) ; boolean sp = samesection ( current , comparator ) ; boolean removed = false ; for ( int index = 0 ; index < nakeds . size ( ) && ( sp || cp || rp ) ; index ++ ) { if ( ! nakeds . get ( index ) . equals ( current ) && ! nakeds . get ( index ) . equals ( comparator ) ) { nakedcandidates naked = nakeds . get ( index ) ; boolean d = false ; if ( rp && current . x == naked . x ) { d = deletematchingvalues ( current , naked ) ; removed = ( removed ? removed : d ) ; } if ( cp && current . y == naked . y ) { d = deletematchingvalues ( current , naked ) ; removed = ( removed ? removed : d ) ; } if ( sp && samesection ( current , naked ) ) { d = deletematchingvalues ( current , naked ) ; removed = ( removed ? removed : d ) ; } } } return removed ; }
va	6	private void generate ( arraylist < string > res , string path , int posi , int size , stack < string > st ) { if ( posi == size && st . isempty ( ) ) { res . add ( path ) ; return ; } if ( posi < size ) { st . push ( "(" ) ; generate ( res , path + "(" , posi + 1 , size , st ) ; st . pop ( ) ; } if ( ! st . empty ( ) ) { st . pop ( ) ; generate ( res , path + ")" , posi , size , st ) ; st . push ( "(" ) ; } }
va	4	private arraylist < string > dividetongrambases ( string string ) { string words [ ] = string . split ( " " ) ; arraylist < string > bases = new arraylist < string > ( ) ; for ( string word : words ) { if ( word . length ( ) < ngramlength ) { continue ; } for ( int i = 0 ; i < word . length ( ) - ( ngramlength - 1 ) ; i ++ ) { bases . add ( word . substring ( i , i + ngramlength ) ) ; } } return bases ; }
va	10	@ override public void update ( gamecontainer gc , statebasedgame sbg , int delta ) throws slickexception { testlevel . update ( delta , 0 , 0 ) ; player . update ( delta , gc ) ; if ( this . player . gethealth ( ) <= 0 ) { sbg . enterstate ( main . states . title . ordinal ( ) ) ; this . player = new player ( ) ; this . fish = new arraylist < fish > ( ) ; } if ( this . fish . size ( ) < 7 ) { vector2f newfishposition = new vector2f ( random . nextint ( 50 ) + 800 , random . nextint ( 540 - 32 ) + 32 ) ; fishtype newfishtype = fish . fishtype . regular ; if ( random . nextint ( 3 ) == 0 ) newfishtype = fishtype . regular ; if ( random . nextint ( 3 ) == 1 ) newfishtype = fishtype . dangerous ; if ( random . nextint ( 3 ) == 2 ) newfishtype = fishtype . special ; this . fish . add ( new fish ( newfishposition , newfishtype , random . nextint ( 50 ) + 300 ) ) ; } for ( int i = 0 ; i < this . fish . size ( ) ; i ++ ) { this . fish . get ( i ) . update ( delta ) ; if ( this . fish . get ( i ) . getcollision ( ) . getcenterx ( ) <= 0 ) { this . fish . remove ( i ) ; return ; } if ( this . player . getcollison ( ) . contains ( this . fish . get ( i ) . getcollision ( ) ) && this . player . geteating ( ) ) { this . player . setscore ( this . player . getscore ( ) + 1 ) ; switch ( this . fish . get ( i ) . gettype ( ) ) { case regular : this . player . sethealth ( this . player . gethealth ( ) + 1000 ) ; case dangerous : this . player . sethealth ( this . player . gethealth ( ) - 500 ) ; case special : this . player . sethealth ( this . player . gethealth ( ) + 1500 ) ; } this . fish . remove ( i ) ; } } }
va	4	private void listfiles ( string repodir , file dir , map < string , file > returnfilelist ) { file [ ] filelist = dir . listfiles ( ) ; for ( int i = 0 ; i < filelist . length ; i ++ ) { if ( filelist [ i ] . isfile ( ) ) { string path = filelist [ i ] . getpath ( ) ; path = path . substring ( repodir . length ( ) ) ; returnfilelist . put ( path , filelist [ i ] ) ; } else if ( filelist [ i ] . isdirectory ( ) && ! filelist [ i ] . ishidden ( ) ) { listfiles ( repodir , filelist [ i ] , returnfilelist ) ; } } }
va	6	public arraylist < arraylist < integer > > generate ( int numrows ) { arraylist < arraylist < integer > > res = new arraylist < arraylist < integer > > ( ) ; for ( int i = 0 ; i < numrows ; i ++ ) { arraylist < integer > row = new arraylist < integer > ( ) ; row . add ( 1 ) ; if ( i > 0 ) { arraylist < integer > prevrow = res . get ( i - 1 ) ; for ( int j = 1 ; j < prevrow . size ( ) ; j ++ ) { row . add ( prevrow . get ( j - 1 ) + prevrow . get ( j ) ) ; } row . add ( 1 ) ; } res . add ( row ) ; } return res ; }
va	2	public void mainmenu ( ) { goalsmenu goalsmenu = new goalsmenu ( logger , connection ) ; contributorsmenu contributorsmenu = new contributorsmenu ( logger , connection ) ; commitsmenu commitsmenu = new commitsmenu ( logger , connection ) ; postsmenu postsmenu = new postsmenu ( logger , connection ) ; samplequerymenu samplequerymenu = new samplequerymenu ( logger , connection ) ; system . out . println ( "this is the management console of the dot issue tracker and source control program." ) ; boolean wanttoquit = false ; while ( ! wanttoquit ) { system . out . println ( "this is the main menu of what you can do on your project." ) ; system . out . println ( "1. manage commits of source code." ) ; system . out . println ( "2. manage posts on issues.[child update]." ) ; system . out . println ( "3. manage goals[child insertion]." ) ; system . out . println ( "4. manage contributors.[parent deletion]" ) ; system . out . println ( "5. commit changes to the database." ) ; system . out . println ( "6. rollback changes since the last commit." ) ; system . out . println ( "7. run sample queries." ) ; system . out . println ( "8. exit." ) ; string input = userinput . nextline ( ) ; inputchecker in = new inputchecker ( input ) ; if ( in . hasalpha ( ) ) { system . out . println ( "that was not an int<litcomma> returning to goals menu." ) ; return ; } input = input . trim ( ) ; switch ( input ) { case "1" : commitsmenu . commitsmenu ( ) ; break ; case "2" : postsmenu . postsmenu ( ) ; break ; case "3" : goalsmenu . goalsmenu ( ) ; break ; case "4" : contributorsmenu . contributorsmenu ( ) ; break ; case "5" : committodatabasemenu ( ) ; break ; case "6" : rollbackmenu ( ) ; break ; case "7" : samplequerymenu . samplequerymenu ( ) ; break ; case "8" : quitmenu ( ) ; wanttoquit = true ; break ; } } }
va	6	public int [ ] twosum ( int [ ] numbers , int target ) { hashmap < integer , integer > maps = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < numbers . length ; i ++ ) { maps . put ( numbers [ i ] , i ) ; } for ( int i = 0 ; i < numbers . length ; i ++ ) { if ( maps . containskey ( target - numbers [ i ] ) ) { int index1 = i + 1 ; int index2 = maps . get ( target - numbers [ i ] ) + 1 ; if ( index1 > index2 ) { return new int [ ] { index2 , index1 } ; } else return new int [ ] { index1 , index2 } ; } } return numbers ; }
va	1	public void registroinmuebles ( actionevent evento ) { if ( evento . getcomponent ( ) . getid ( ) . equals ( "guardar" ) ) { inmuebles inm = new inmuebles ( 0 , comments , comments , comments , comments ) ; inmueblesdao inmd = new inmueblesdao ( ) ; conexion conexion = new conexion ( ) ; inm . setinmnom ( this . nombre ) ; inm . setinmdir ( this . direccion ) ; inm . setinmtel ( this . telefono ) ; inm . setinmvenoarr ( this . ventoarr ) ; inm . setinmnegoc ( this . tipneg ) ; inm . setinccomments ( this . comments ) ; inmd . crearinmueble ( inm , conexion ) ; clear ( ) ; } }
va	1	public double getintensity ( int alpha , int red , int green , int blue ) { if ( alpha == 0 ) { return 0 ; } float [ ] hsbvals = new float [ 3 ] ; hsbvals = color . rgbtohsb ( red , green , blue , hsbvals ) ; double intensity = 0 ; if ( hsbvals [ 0 ] > 200 / 360.0 ) { intensity = - 1 - hsbvals [ 1 ] / 1.0 ; } else if ( hsbvals [ 0 ] > 0.39 && hsbvals [ 0 ] < 0.6 ) { intensity = - 0.5 - ( hsbvals [ 0 ] - 0.39 ) / ( 0.6 - 0.39 ) * 0.5 ; } else if ( hsbvals [ 0 ] <= 0.39 ) { intensity = 1 - ( hsbvals [ 0 ] ) / 0.39 * 0.5 ; } else { intensity = - 2 + hsbvals [ 2 ] ; } return math . pow ( 10 , intensity ) ; }
va	5	public void processsimage ( file key , string out , int img_width , int img_height ) { bufferedimage originalimage = null ; try { originalimage = imageio . read ( key ) ; int type = originalimage . gettype ( ) == 0 ? bufferedimage . type_int_argb : originalimage . gettype ( ) ; bufferedimage key2 = resizeimage ( originalimage , type , img_width , img_height ) ; string nname = key . getname ( ) . tostring ( ) . substring ( 0 , key . getname ( ) . indexof ( "." ) ) ; imageio . write ( key2 , "jpg" , new file ( out + nname + "_" + img_height + "x" + img_width + ".jpg" ) ) ; system . out . println ( "created: " + out + nname + "_" + img_height + "x" + img_width + ".jpg" ) ; } catch ( ioexception e ) { joptionpane . showmessagedialog ( null , "problem z zapisem" , "error" , joptionpane . error_message ) ; } catch ( nullpointerexception e ) { system . out . println ( "error niepoprawny plik" ) ; } }
va	7	private string decode ( ) { long decode = this . code ; long mask = 3 ; string seq = "" ; for ( int i = 1 ; i <= len ; i ++ ) { if ( ( decode & mask ) == 0 ) { seq = "a" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 3 ) { seq = "t" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 1 ) { seq = "c" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 2 ) { seq = "g" + seq ; decode = decode > > 2 ; } } return seq ; }
va	1	public int [ ] getadmissions ( ) throws sqlexception { int [ ] adm = new int [ 8 ] ; adm [ 0 ] = this . getamountz ( "$5" ) ; adm [ 1 ] = this . getamountz ( "$10" ) ; adm [ 2 ] = this . getamountz ( "$20" ) ; adm [ 3 ] = this . getamountz ( "g-tix" ) ; adm [ 4 ] = this . getamountz ( "mgr comp" ) ; adm [ 5 ] = this . getamountz ( "comp pass" ) ; adm [ 6 ] = this . getamountz ( "comp" ) ; adm [ 7 ] = this . getamountz ( "hotel" ) ; return adm ; }
va	9	public static int divide2 ( int n , arraylist < arraylist < double > > allmatrix , arraylist < arraylist < double > > testsample , arraylist < arraylist < double > > trainsample ) { int num = allmatrix . size ( ) / 10 ; for ( int i = 0 ; i < allmatrix . size ( ) ; i ++ ) { if ( i >= num * n && i < ( n + 1 ) * num ) { testsample . add ( allmatrix . get ( i ) ) ; } else { trainsample . add ( allmatrix . get ( i ) ) ; } } return num ; }
va	7	@ override public boolean equals ( object _other ) { if ( _other == null ) return false ; if ( ! ( _other instanceof key ) ) return false ; key other = ( key ) _other ; if ( other . data . size ( ) != this . data . size ( ) ) return false ; for ( int i = 0 ; i < this . data . size ( ) ; ++ i ) { if ( this . data . get ( i ) == null && other . data . get ( i ) != null ) return false ; if ( this . data . get ( i ) != null && other . data . get ( i ) == null ) return false ; if ( this . data . get ( i ) == null && other . data . get ( i ) == null ) continue ; if ( ! this . data . get ( i ) . equals ( other . data . get ( i ) ) ) return false ; } return true ; }
va	9	public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; if ( tetris . isgameover ( ) ) { for ( int y = 2 ; y < tetrisboard . height ; y ++ ) { for ( int x = 0 ; x < tetrisboard . width ; x ++ ) { tetromino . type type = tetris . getboard ( ) . get ( x , y ) ; color color = tetrisboard . colors [ type . getvalue ( ) ] ; tetrominoblock . instance ( ) . geticonforcolor ( color ) . painticon ( this , g , block_size * x , block_size * ( y - 2 ) ) ; } } g . setcolor ( color . white ) ; g . setfont ( new font ( "arial" , font . bold , 60 ) ) ; g . drawstring ( "game" , tetrisboard . width * block_size / 2 - 50 , tetrisboard . height * block_size / 2 - 100 ) ; g . drawstring ( "over" , tetrisboard . width * block_size / 2 - 45 , tetrisboard . height * block_size / 2 - 50 ) ; } else { g . setcolor ( color . black ) ; g . fillrect ( 0 , 0 , tetrisboard . width * block_size , ( tetrisboard . height - 2 ) * block_size ) ; if ( tetris . getactivetetromino ( ) != null && ! tetris . getactivetetromino ( ) . islocked ( ) && ! tetris . getactivetetromino ( ) . blockedbelow ( tetris . getboard ( ) ) ) { tetromino ghost = new tetromino ( tetris . getactivetetromino ( ) . gettype ( ) , tetris . getactivetetromino ( ) . getrotation ( ) , tetris . getactivetetromino ( ) . getpoint ( ) ) ; while ( ghost . inbounds ( ) && ghost . infreespace ( tetris . getboard ( ) ) ) { ghost . setpoint ( ghost . getpoint ( ) . add ( new tetrispoint ( 0 , 1 ) ) ) ; } ghost . setpoint ( ghost . getpoint ( ) . add ( new tetrispoint ( 0 , - 1 ) ) ) ; for ( tetrispoint mino : ghost . getblocks ( ) ) { tetrominoblock . instance ( ) . geticonforcolor ( color . gray . brighter ( ) ) . painticon ( this , g , block_size * mino . add ( ghost . getpoint ( ) ) . getx ( ) , block_size * ( mino . add ( ghost . getpoint ( ) ) . gety ( ) - 2 ) ) ; } } for ( int y = 2 ; y < tetrisboard . height ; y ++ ) { for ( int x = 0 ; x < tetrisboard . width ; x ++ ) { tetromino . type type = tetris . getboard ( ) . get ( x , y ) ; color color = tetris . getboard ( ) . colors [ type . getvalue ( ) ] ; if ( type != tetromino . type . x ) { tetrominoblock . instance ( ) . geticonforcolor ( color ) . painticon ( this , g , block_size * x , block_size * ( y - 2 ) ) ; } } } tetromino active_tetromino = tetris . getactivetetromino ( ) ; if ( active_tetromino == null ) { return ; } for ( tetrispoint mino : active_tetromino . getblocks ( ) ) { int x = mino . getx ( ) + active_tetromino . getpoint ( ) . getx ( ) ; int y = mino . gety ( ) + active_tetromino . getpoint ( ) . gety ( ) ; color color = tetris . getboard ( ) . colors [ active_tetromino . gettype ( ) . getvalue ( ) ] ; tetrominoblock . instance ( ) . geticonforcolor ( color ) . painticon ( this , g , block_size * x , block_size * ( y - 2 ) ) ; } g . setfont ( new font ( "courier" , font . bold , 10 ) ) ; g . setcolor ( color . red ) ; g . drawstring ( string . format ( "%2.2f" , tetris . getframerate ( ) ) , 10 , 10 ) ; } }
va	8	private void _setinstanceinfo ( ) { int subclass , superclass ; for ( int i = 0 ; i < class_num ; i ++ ) { switch ( i ) { case cs_c_univ : break ; case cs_c_dept : break ; case cs_c_fullprof : instances_ [ i ] . num = _getrandomfromrange ( fullprof_min , fullprof_max ) ; break ; case cs_c_assoprof : instances_ [ i ] . num = _getrandomfromrange ( assoprof_min , assoprof_max ) ; break ; case cs_c_asstprof : instances_ [ i ] . num = _getrandomfromrange ( asstprof_min , asstprof_max ) ; break ; case cs_c_lecturer : instances_ [ i ] . num = _getrandomfromrange ( lec_min , lec_max ) ; break ; case cs_c_understud : instances_ [ i ] . num = _getrandomfromrange ( r_understud_faculty_min * instances_ [ cs_c_faculty ] . total , r_understud_faculty_max * instances_ [ cs_c_faculty ] . total ) ; break ; case cs_c_gradstud : instances_ [ i ] . num = _getrandomfromrange ( r_gradstud_faculty_min * instances_ [ cs_c_faculty ] . total , r_gradstud_faculty_max * instances_ [ cs_c_faculty ] . total ) ; break ; case cs_c_ta : instances_ [ i ] . num = _getrandomfromrange ( instances_ [ cs_c_gradstud ] . total / r_gradstud_ta_max , instances_ [ cs_c_gradstud ] . total / r_gradstud_ta_min ) ; break ; case cs_c_ra : instances_ [ i ] . num = _getrandomfromrange ( instances_ [ cs_c_gradstud ] . total / r_gradstud_ra_max , instances_ [ cs_c_gradstud ] . total / r_gradstud_ra_min ) ; break ; case cs_c_researchgroup : instances_ [ i ] . num = _getrandomfromrange ( researchgroup_min , researchgroup_max ) ; break ; default : instances_ [ i ] . num = class_info [ i ] [ index_num ] ; break ; } instances_ [ i ] . total = instances_ [ i ] . num ; subclass = i ; while ( ( superclass = class_info [ subclass ] [ index_super ] ) != cs_c_null ) { instances_ [ superclass ] . total += instances_ [ i ] . num ; subclass = superclass ; } } }
va	10	private jsonelement doget ( string resource , map < string , string > parameters , boolean raise404 ) throws exception { httpclient httpclient = new defaulthttpclient ( ) ; string uri = geturi ( resource ) ; if ( parameters != null && parameters . size ( ) > 0 ) { list < namevaluepair > queryparams = new arraylist < namevaluepair > ( ) ; for ( string key : parameters . keyset ( ) ) { queryparams . add ( new basicnamevaluepair ( key , parameters . get ( key ) ) ) ; } uri += "?" + urlencodedutils . format ( queryparams , "utf-8" ) ; } try { httpget httpget = new httpget ( uri ) ; httpresponse httpresponse = httpclient . execute ( httpget ) ; string body = entityutils . tostring ( httpresponse . getentity ( ) ) ; int code = httpresponse . getstatusline ( ) . getstatuscode ( ) ; if ( code == 200 ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; jsonparser parser = new jsonparser ( ) ; return parser . parse ( body ) ; } else if ( code == 404 && ! raise404 ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; return null ; } else { string message = "response code " + httpresponse . getstatusline ( ) . getstatuscode ( ) + ". " ; message += body ; throw new exception ( message ) ; } } catch ( exception e ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; throw e ; } }
va	6	private int getmin ( string word1 , string word2 , int [ ] [ ] min1 , int index1 , int index2 ) { if ( index1 == word1 . length ( ) ) { for ( int j = index2 ; j < word2 . length ( ) ; j ++ ) min1 [ index1 ] [ j ] = word2 . substring ( index2 + 1 ) . length ( ) ; return word2 . substring ( index2 ) . length ( ) ; } else if ( index2 == word2 . length ( ) ) { for ( int j = index1 ; j < word1 . length ( ) ; j ++ ) min1 [ j ] [ index2 ] = word1 . substring ( index1 + 1 ) . length ( ) ; return word1 . substring ( index1 ) . length ( ) ; } int first = 0 ; if ( min1 [ index1 + 1 ] [ index2 + 1 ] > 0 ) first = min1 [ index1 + 1 ] [ index2 + 1 ] ; else first = getmin ( word1 , word2 , min1 , index1 + 1 , index2 + 1 ) ; int sec = 0 ; if ( min1 [ index1 + 1 ] [ index2 ] > 0 ) sec = min1 [ index1 + 1 ] [ index2 ] ; else sec = getmin ( word1 , word2 , min1 , index1 + 1 , index2 ) ; int third = 0 ; if ( min1 [ index1 ] [ index2 + 1 ] > 0 ) third = min1 [ index1 ] [ index2 + 1 ] ; else third = getmin ( word1 , word2 , min1 , index1 , index2 + 1 ) ; int sum = math . min ( third , math . min ( first , sec ) ) + 1 ; min1 [ index1 ] [ index2 ] = sum ; return sum ; }
va	3	public static void main ( string [ ] args ) { string a = new string ( "ajax amsterdam" ) ; string b = new string ( "abc" ) ; if ( a . equals ( b ) ) { system . out . println ( a + " equals gelijk " + b ) ; } else { system . out . println ( a + " equals ongelijk " + b ) ; } if ( a == b ) { system . out . println ( a + " ==gelijk " + b ) ; } else { system . out . println ( a + " == ongelijk " + b ) ; } b = "ajax amsterdam" ; if ( a . equals ( b ) ) { system . out . println ( a + " equals gelijk " + b ) ; } else { system . out . println ( a + " equals ongelijk " + b ) ; } if ( a == b ) { system . out . println ( a + " == gelijk " + b ) ; } else { system . out . println ( a + " == ongelijk " + b ) ; } }
va	2	public url urlbulider ( string path , string subpath , map < string , string > querymap ) { stringbuffer sbf = new stringbuffer ( ) ; sbf . append ( unsconsts . mark_slash ) . append ( path ) ; sbf . append ( unsconsts . mark_slash ) . append ( subpath ) ; sbf . append ( unsconsts . mark_que ) ; try { for ( string key : querymap . keyset ( ) ) { sbf . append ( key + unsconsts . mark_euq + urlencoder . encode ( querymap . get ( key ) == null ? "" : querymap . get ( key ) , unsconsts . utf8 ) ) . append ( unsconsts . mark_ampersand ) ; } sbf . deletecharat ( sbf . length ( ) - 1 ) ; url = new url ( unsconsts . basepath + sbf . tostring ( ) ) ; } catch ( unsupportedencodingexception ex ) { ex . printstacktrace ( ) ; } catch ( malformedurlexception e ) { logger . log ( level . severe , "a malformed url has occurred!url={0}" , url . getpath ( ) ) ; } return url ; }
va	7	public final void mergepuzzlepieces ( final slidingpuzzleboard newgameboard , final list < slidingpuzzlepiece > puzzlepiece ) { for ( int i = 0 ; i <= mergeprocedures ; i ++ ) { slidingpuzzlepiece firstpiece = slidingpuzzlepiece . getpuzzlepiece ( ) . get ( randomdigit ( 0 , slidingpuzzlepiece . getpuzzlepiece ( ) . size ( ) ) ) ; slidingpuzzlefield firstfield = firstpiece . getfield ( ) ; slidingpuzzlepiece secondpiece = slidingpuzzlepiece . getpuzzlepiece ( ) . get ( randomdigit ( 0 , slidingpuzzlepiece . getpuzzlepiece ( ) . size ( ) ) ) ; slidingpuzzlefield secondfield = secondpiece . getfield ( ) ; int firstfromx = firstfield . getfieldcol ( ) ; int firstfromy = firstfield . getfieldrow ( ) ; int firsttox = secondfield . getfieldcol ( ) ; int firsttoy = secondfield . getfieldrow ( ) ; system . out . println ( "switching " + firstfromx + "-" + firstfromy + " with " + firsttox + "-" + firsttoy ) ; double firstfreex = secondfield . getfieldcoordx ( ) ; double firstfreey = secondfield . getfieldcoordy ( ) ; double secondfreex = firstfield . getfieldcoordx ( ) ; double secondfreey = firstfield . getfieldcoordy ( ) ; double firstshufflex = ( firstfreex - firstfield . getfieldcoordx ( ) ) + firstpiece . gettranslatex ( ) ; double firstshuffley = ( firstfreey - firstfield . getfieldcoordy ( ) ) + firstpiece . gettranslatey ( ) ; double secondshufflex = ( secondfreex - secondfield . getfieldcoordx ( ) ) + secondpiece . gettranslatex ( ) ; double secondshuffley = ( secondfreey - secondfield . getfieldcoordy ( ) ) + secondpiece . gettranslatey ( ) ; firstpiece . settranslatex ( firstshufflex ) ; firstpiece . settranslatey ( firstshuffley ) ; secondpiece . settranslatex ( secondshufflex ) ; secondpiece . settranslatey ( secondshuffley ) ; secondfield . setfieldcoordx ( firstfield . getfieldcoordx ( ) ) ; secondfield . setfieldcoordy ( firstfield . getfieldcoordy ( ) ) ; secondfield . setfieldcol ( firstfromx ) ; secondfield . setfieldrow ( firstfromy ) ; firstfield . setfieldcoordx ( firstfreex ) ; firstfield . setfieldcoordy ( firstfreey ) ; firstfield . setfieldcol ( firsttox ) ; firstfield . setfieldrow ( firsttoy ) ; } system . out . println ( "merged.." ) ; }
va	7	private void adjustopt ( map < string , string > opt ) { if ( null == opt || opt . isempty ( ) ) { throw new channelexception ( "no params are set" , channel_sdk_param ) ; } if ( ! opt . containskey ( timestamp ) ) { string timestamp = string . valueof ( system . currenttimemillis ( ) / 1000 ) ; opt . put ( timestamp , timestamp ) ; } opt . put ( host , default_host ) ; opt . put ( api_key , apikey ) ; if ( opt . containskey ( secret_key ) ) { opt . remove ( secret_key ) ; } }
va	8	public void draw ( int leftx , int uppery , int height , int width , graphics g ) { int widthrect = ( int ) ( width ) / scrambleddata . size ( ) ; for ( int i = 0 ; i < scrambleddata . size ( ) ; i ++ ) { double curpoint = ( double ) scrambleddata . get ( i ) ; if ( curswap != null && ( curswap . getstart ( ) == i || curswap . getend ( ) == i ) ) { g . setcolor ( color . black ) ; } else { g . setcolor ( color . gethsbcolor ( ( float ) curpoint / 360 , 1 , 1f ) ) ; } g . fillrect ( i * widthrect + leftx , uppery , widthrect , height ) ; } }
va	8	private void addstat ( int numersamolotu ) { int [ ] stats = statsmap . get ( numersamolotu ) ; n_specjalnych += stats [ 6 ] ; if ( stats [ 4 ] > 0 ) { n_malo_paliwa ++ ; } if ( stats [ 0 ] > 0 ) { n_startujacych ++ ; } if ( stats [ 1 ] > 0 ) { n_ladujacych ++ ; } if ( stats [ 3 ] > 0 ) { n_wyladowalo ++ ; } int opoznienie_startu = stats [ 2 ] - stats [ 0 ] - params . czas_startu + 2 ; if ( opoznienie_startu > 0 && opoznienie_startu < min_opoznienie_startu ) { min_opoznienie_startu = opoznienie_startu ; } if ( opoznienie_startu > max_opoznienie_startu ) { max_opoznienie_startu = opoznienie_startu ; } sr_opoznienie_startu += opoznienie_startu ; if ( stats [ 3 ] > 0 ) { int opoznienie_ladowania = stats [ 3 ] - stats [ 1 ] - params . czas_ladowania + 2 ; sr_opoznienie_ladowania += opoznienie_ladowania ; if ( opoznienie_ladowania > 0 && opoznienie_ladowania < min_opoznienie_ladowania ) { min_opoznienie_ladowania = opoznienie_ladowania ; } if ( opoznienie_ladowania > max_opoznienie_ladowania ) { max_opoznienie_ladowania = opoznienie_ladowania ; } } statsmap . remove ( numersamolotu ) ; }
va	8	public void createdocs ( arraylist < classmodel > models , string detailfile , string homefile ) { sfapexdoc . assertprecondition ( null != models ) ; sfapexdoc . assertprecondition ( null != detailfile ) ; sfapexdoc . assertprecondition ( null != homefile ) ; string projectdetail = parseprojectdetail ( detailfile . trim ( ) ) ; if ( projectdetail . isempty ( ) ) { projectdetail = htmlconstants . default_project_detail ; } string homecontents = parsehtmlfile ( homefile . trim ( ) ) ; if ( homecontents . isempty ( ) ) { homecontents = htmlconstants . default_home_contents ; } string links = "<table width='100%'><tr>" + getpagelinks ( models ) ; homecontents = links + "<td><h2 class='section-title'>home</h2>" + homecontents + "</td>" ; homecontents = htmlconstants . header_open + projectdetail + htmlconstants . header_close + homecontents + htmlconstants . footer ; hashtable < string , string > classhashtable = new hashtable < string , string > ( ) ; classhashtable . put ( "index" , homecontents ) ; string all = "<table width='100%'><tr>" ; for ( classmodel model : models ) { string contents = links ; if ( ! model . getnameline ( ) . isempty ( ) ) { string children = "" ; for ( classmodel child : model . children ) { children += "<tr>" + createclassdoc ( child , child . getname ( ) ) + "</tr>" ; } final string filename = model . getname ( ) ; final string classdoc = createclassdoc ( model , filename ) + children + "</tr></table>" ; contents += classdoc ; all += classdoc . replace ( toggle_all , "" ) . replace ( toggle_one , "" ) ; classhashtable . put ( filename . tolowercase ( ) , htmlconstants . header_open + projectdetail + htmlconstants . header_close + contents + htmlconstants . footer ) ; } } classhashtable . put ( "_all" , htmlconstants . header_open . replace ( htmlconstants . header_toggle , "" ) + projectdetail + htmlconstants . header_close + all + htmlconstants . footer ) ; createdocfiles ( classhashtable ) ; }
va	4	user ( int uid ) { if ( ! alluserset . containskey ( uid ) ) { userid = uid ; records = new linkedlist < record > ( ) ; friends = new hashset < integer > ( ) ; locs = new hashset < string > ( ) ; try { bufferedreader fin = new bufferedreader ( new filereader ( string . format ( "%s/%d" , userdir , uid ) ) ) ; string l = fin . readline ( ) ; string [ ] fids = l . split ( "\\t" ) ; if ( fids . length == 1 && integer . parseint ( fids [ 0 ] ) == - 1 ) friends . clear ( ) ; else { for ( string fid : fids ) { friends . add ( integer . parseint ( fid ) ) ; } } while ( ( l = fin . readline ( ) ) != null ) { records . add ( new record ( l ) ) ; } fin . close ( ) ; } catch ( exception e ) { system . out . println ( "exception in user constructor" ) ; e . printstacktrace ( ) ; } alluserset . put ( uid , this ) ; } else { this . userid = uid ; this . records = alluserset . get ( uid ) . records ; this . friends = alluserset . get ( uid ) . friends ; } }
va	6	public arraylist < arraylist < string > > findladders ( string start , string end , hashset < string > dict ) { hashmap < string , hashset < string > > visited = new hashmap < string , hashset < string > > ( ) ; hashmap < string , integer > level = new hashmap < string , integer > ( ) ; linkedlist < string > queue = new linkedlist < string > ( ) ; arraylist < arraylist < string > > result = new arraylist < arraylist < string > > ( ) ; if ( start == null || end == null || start . length ( ) != end . length ( ) ) return result ; hashset < string > path = new hashset < string > ( ) ; int minlen = integer . max_value ; visited . put ( start , path ) ; level . put ( start , 1 ) ; queue . add ( start ) ; while ( ! queue . isempty ( ) ) { string head = queue . remove ( ) ; char [ ] chars = head . tochararray ( ) ; for ( int i = 0 ; i < head . length ( ) ; i ++ ) { char old = chars [ i ] ; for ( char letter = 'a' ; letter <= 'z' ; letter ++ ) { chars [ i ] = letter ; string nextword = new string ( chars ) ; if ( dict . contains ( nextword ) && ( ! level . containskey ( nextword ) || ( level . containskey ( nextword ) && level . get ( nextword ) > level . get ( head ) ) ) ) { if ( visited . containskey ( nextword ) ) { visited . get ( nextword ) . add ( head ) ; } else { path = new hashset < string > ( ) ; path . add ( head ) ; visited . put ( nextword , path ) ; level . put ( nextword , level . get ( head ) + 1 ) ; queue . add ( nextword ) ; } } if ( nextword . equals ( end ) ) { if ( level . get ( head ) < minlen ) { arraylist < string > entry = new arraylist < string > ( ) ; entry . add ( end ) ; result . addall ( backtrace ( head , visited , entry ) ) ; minlen = level . get ( head ) + 1 ; } else { break ; } } chars [ i ] = old ; } } } return result ; }
va	7	public void computeinitialconfiguration ( ) { double [ ] [ ] s = computedistancematrix ( ) ; if ( s == null ) { fixedstart ( ) ; return ; } double [ ] q = new double [ ncircles ] ; computescalarproducts ( ncircles , s , q ) ; eigen . eigensymmetric ( s , s , q ) ; double rms = math . sqrt ( q [ 0 ] ) + math . sqrt ( q [ 1 ] ) ; if ( double . isnan ( rms ) || rms < .1 ) { fixedstart ( ) ; return ; } for ( int i = 0 ; i < ncircles ; i ++ ) { centers [ i ] [ 0 ] = .5 + .25 * s [ i ] [ 0 ] * math . sqrt ( q [ 0 ] ) ; centers [ i ] [ 1 ] = .5 + .25 * s [ i ] [ 1 ] * math . sqrt ( q [ 1 ] ) ; } }
va	9	private static < v extends comparable < v > , e extends comparable < e > > boolean isisomorphic ( vertex < v , e > v1 , vertex < v , e > v2 , set < integer > g1visited , set < integer > g2visited ) { if ( v1 == null && v2 == null ) { return true ; } else if ( ( v1 == null && v2 != null ) || ( v1 != null && v2 == null ) ) { return false ; } boolean v1visited = g1visited . contains ( v1 . getid ( ) ) ; boolean v2visited = g2visited . contains ( v2 . getid ( ) ) ; if ( v1visited && v2visited ) { return true ; } else if ( ( ! v1visited && v2visited ) || ( v1visited && ! v2visited ) ) { return false ; } else { int vertexcomparision = v1 . compareto ( v2 ) ; if ( vertexcomparision != 0 ) { return false ; } set < integer > g1visitednew = new hashset < integer > ( g1visited ) ; set < integer > g2visitednew = new hashset < integer > ( g2visited ) ; g1visitednew . add ( v1 . getid ( ) ) ; g2visitednew . add ( v2 . getid ( ) ) ; boolean isomorphic = true ; for ( edge < v , e > e1 : v1 . getedges ( ) ) { boolean edgeisomorphic = false ; for ( edge < v , e > e2 : v2 . getedges ( ) ) { if ( e1 . compareto ( e2 ) == 0 ) { edgeisomorphic = isisomorphic ( e1 . getdestination ( ) , e2 . getdestination ( ) , g1visitednew , g2visitednew ) ; if ( edgeisomorphic && e2 . getdestination ( ) != null ) { g1visitednew . add ( e2 . getdestination ( ) . getid ( ) ) ; } } } if ( ! edgeisomorphic ) { return false ; } } return isomorphic ; } }
va	3	public void setup ( ) { object [ ] options = { "browse" , "build" } ; int i = joptionpane . showoptiondialog ( null , "there has been an error locating the startup file." + "\\nplease select below either 'browse' to navigate to" + " the correct file" + "\\nor 'build' to provide the program with information to" + " rebuild the file." , "error locating startup file" , joptionpane . default_option , joptionpane . error_message , null , options , options [ 0 ] ) ; switch ( i ) { case 0 : this . browse ( ) ; break ; case 1 : this . rebuild ( ) ; break ; case - 1 : system . exit ( 0 ) ; break ; default : new clubexception ( "error setting up the startup file" , "this should never happen" ) ; break ; } this . verifyfile ( ) ; }
va	7	private void recenter ( ) { double cx = 0 ; double cy = 0 ; for ( int i = 0 ; i < ncircles ; i ++ ) { cx += centers [ i ] [ 0 ] ; cy += centers [ i ] [ 1 ] ; } cx = cx / ncircles ; cy = cy / ncircles ; for ( int i = 0 ; i < ncircles ; i ++ ) { centers [ i ] [ 0 ] = .5 + centers [ i ] [ 0 ] - cx ; centers [ i ] [ 1 ] = .5 + centers [ i ] [ 1 ] - cy ; } }
va	3	public static void main ( string [ ] args ) { final string arg = "e:\\\\me\\\\programming\\\\hackbulgaria\\\\java\\\\gitother copy\\\\core-java-1\\\\8-workingwithlibraries\\\\a.jpg" ; final file file = new file ( arg ) ; bufferedimage img = null ; try { img = imageio . read ( file ) ; } catch ( final exception e ) { e . fillinstacktrace ( ) ; } for ( int y = 0 ; y < img . getheight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getwidth ( ) ; x ++ ) { final int pixel = grey ( img . getrgb ( x , y ) ) ; print ( pixel ) ; } system . out . println ( ) ; } }
va	9	public void render ( graphics g ) { for ( int i = ( int ) window . x / tilesize ; i < ( window . x + window . width ) / tilesize ; i ++ ) { for ( int j = ( int ) window . y / tilesize ; j < ( window . y + window . height ) / tilesize ; j ++ ) { image image = tileset . gettileimages ( ) . get ( tile . blank ) ; if ( i > 0 && i + window . height / tilesize < tiles . length ) { if ( j > 0 && j + window . width / tilesize < tiles [ 0 ] . length ) { image = tiles [ i ] [ j ] . getimage ( ) ; } } g . drawimage ( image , ( float ) i * tilesize - window . x , ( float ) j * tilesize - window . y ) ; } } }
va	8	@ override protected int sethvalue ( ) { int dimension = state . getsize ( ) ; int [ ] [ ] board = ( ( fifteenstate ) state ) . getboard ( ) ; int [ ] kdist = ( ( fifteenstate ) state ) . getkdist ( ) ; hvalue = 0 ; for ( int i = 0 ; i < dimension ; i ++ ) { for ( int j = 0 ; j < dimension ; j ++ ) { if ( board [ i ] [ j ] != 0 ) { int x = board [ i ] [ j ] - 1 , y = 4 * i + j ; hvalue += kdist [ 16 * x + y ] ; } } } return hvalue ; }
va	5	public double findmediansortedarrays ( int a [ ] , int b [ ] ) { int a = a . length ; int b = b . length ; if ( ( a + b ) % 2 == 0 ) { double first = find_k ( a , 0 , b , 0 , ( a + b ) / 2 ) ; double second = find_k ( a , 0 , b , 0 , ( a + b ) / 2 + 1 ) ; return ( first + second ) / 2.0 ; } else { return find_k ( a , 0 , b , 0 , ( a + b ) / 2 + 1 ) ; } }
va	2	public void hacersaque ( main m ) { int x = 0 ; int y = 0 ; if ( this . equipo == 1 ) { x = 2 ; y = 17 ; } else { x = 30 ; y = 5 ; } m . log [ this . posx ] [ this . posy ] = 0 ; m . log [ x ] [ y ] = this . equipo ; imageicon piso = new imageicon ( "piso.gif" ) ; m . lbl [ this . posx ] [ this . posy ] . seticon ( piso ) ; imageicon icon ; if ( this . equipo == 1 ) { icon = new imageicon ( "jugador1.png" ) ; } else { icon = new imageicon ( "jugador2.png" ) ; } m . lbl [ x ] [ y ] . seticon ( icon ) ; }
va	7	public string printwordtypes ( list < word > wl , int width ) { string s = "" ; for ( int i = 0 ; i < wl . size ( ) ; i ++ ) { word word = wl . get ( i ) ; string wordtypestring = "null" ; if ( word != null ) { wordtype wt = word . getwordtype ( ) ; if ( wt != null ) { wordtypestring = wt . getclass ( ) . getsimplename ( ) ; } } s += string . format ( "%" + width + "s" , wordtypestring ) ; s += " " ; } return s ; }
va	10	public static void main ( string [ ] args ) { int sizex = 8 ; int sizey = 6 ; int qtemonstres = 5 ; int qtebonbons = 3 ; int y = args . length >= 1 ? ( integer . parseint ( args [ 0 ] ) ) : sizey ; int x = args . length >= 2 ? ( integer . parseint ( args [ 1 ] ) ) : sizex ; int monstres = args . length >= 3 ? ( integer . parseint ( args [ 2 ] ) ) : qtemonstres ; int bonbons = args . length == 4 ? ( integer . parseint ( args [ 3 ] ) ) : qtebonbons ; mazegenerator maze = new mazegenerator ( x , y ) ; system . out . println ( "labyrinthe: " + y + " fois " + x ) ; maze . display ( ) ; system . out . println ( "elements du labyrinthe: " ) ; system . out . println ( "\\tmonstres: " + monstres ) ; system . out . println ( "\\tbonbons: " + bonbons ) ; int [ ] [ ] position = new int [ x ] [ y ] ; system . out . println ( "emplacements:" ) ; for ( int i = 0 ; i < x ; ++ i ) { for ( int j = 0 ; j < y ; ++ j ) { position [ i ] [ j ] = 0 ; } } int px = x - 1 , py = y - 1 ; while ( px == x - 1 && py == y - 1 ) { px = maze . rand . nextint ( x ) ; py = maze . rand . nextint ( y ) ; } position [ px ] [ py ] = 1 ; system . out . println ( "\\tpakkuman: (" + py + "<litcomma>" + px + ")" ) ; int fx = px , fy = py ; system . out . print ( "\\tmonstres: " ) ; for ( int i = 0 ; i < monstres ; ++ i ) { while ( position [ fx ] [ fy ] == 1 ) { fx = maze . rand . nextint ( x ) ; fy = maze . rand . nextint ( y ) ; } position [ fx ] [ fy ] = 1 ; system . out . print ( "(" + fy + "<litcomma>" + fx + ") " ) ; } system . out . println ( ) ; int gx = px , gy = py ; system . out . print ( "\\tbonbons: " ) ; for ( int i = 0 ; i < bonbons ; ++ i ) { while ( position [ gx ] [ gy ] == 1 ) { gx = maze . rand . nextint ( x ) ; gy = maze . rand . nextint ( y ) ; } position [ gx ] [ gy ] = 1 ; system . out . print ( "(" + gy + "<litcomma>" + gx + ") " ) ; } system . out . println ( ) ; }
va	9	private charsequence format ( charsequence value , beandumperformat ... additionalformats ) throws ioexception { beandumperformathandler formathandler = this . getformathandler ( ) ; list < beandumperformat > formats = this . consolidateformats ( additionalformats ) ; if ( formathandler == null ) { return value ; } else { stringbuilder resultvalue = new stringbuilder ( ) ; for ( int i = 0 ; i < formats . size ( ) ; i ++ ) { formathandler . appendvalueprefix ( resultvalue , formats . get ( i ) ) ; } formathandler . appendvalue ( resultvalue , value ) ; for ( int i = formats . size ( ) - 1 ; i >= 0 ; i -- ) { formathandler . appendvaluepostfix ( resultvalue , formats . get ( i ) ) ; } return resultvalue ; } }
te	4	public compactbytearray ( byte defaultvalue ) { int i ; values = new byte [ unicodecount ] ; indices = new char [ indexcount ] ; hashes = new int [ indexcount ] ; for ( i = 0 ; i < unicodecount ; ++ i ) { values [ i ] = defaultvalue ; } for ( i = 0 ; i < indexcount ; ++ i ) { indices [ i ] = ( char ) ( i << blockshift ) ; hashes [ i ] = 0 ; } iscompact = false ; this . defaultvalue = defaultvalue ; }
te	8	public static int getnegativepower ( int x ) { int n = 11 , t = 0 , newt = 1 , r = n , newr = x , q , temp ; while ( newr != 0 ) { q = r / newr ; temp = newt ; newt = t - q * newt ; t = temp ; temp = newr ; newr = r - q * newr ; r = temp ; } if ( r > 1 ) return - 1 ; if ( t < 0 ) t = t + n ; return t ; }
te	1	public static void main ( string [ ] args ) { groupreader groupreader = creategroupreader ( input_file ) ; filewriter filewriter = createfilewriter ( output_file ) ; dictionary . getinstance ( ) . setngramlength ( 4 ) ; if ( ! loaddictionary ( ) ) { builddictionary ( input_file ) ; } dictionary . getinstance ( ) . deletehighprobabilities ( 0.0005 ) ; system . out . println ( "process" ) ; while ( groupreader . hasnext ( ) ) { group group = groupreader . next ( ) ; if ( group == null || group . size ( ) < 1000 ) { continue ; } group . updatefrequencies ( ) ; system . out . print ( "\\r\u2116: " + group . getgroupid ( ) ) ; filewriter . println ( "\u2116: " + group . getgroupid ( ) ) ; filewriter . println ( "group size: " + group . size ( ) ) ; filewriter . printmostfrequentlyngrams ( group , 0.0005 ) ; filewriter . printmostdistinctmessages ( group , 0.0005 ) ; } system . out . println ( "\\nfree resources" ) ; groupreader . close ( ) ; filewriter . close ( ) ; system . out . println ( "done" ) ; }
te	4	public static void readtaglinksfile ( ) throws ioexception { string [ ] reader = papplet . loadstrings ( tag_links_file ) ; for ( int i = 1 ; i < reader . length ; i ++ ) { string [ ] nextline = reader [ i ] . replace ( "\\"" , "" ) . split ( "<litcomma>" ) ; int key = integer . valueof ( nextline [ 0 ] ) ; if ( taglinks . containskey ( key ) ) { taglinks . put ( integer . valueof ( nextline [ 0 ] ) , taglinks . get ( integer . valueof ( nextline [ 0 ] ) ) + "<litcomma>" + nextline [ 1 ] ) ; } else { taglinks . put ( integer . valueof ( nextline [ 0 ] ) , nextline [ 1 ] ) ; } } }
te	3	public record ( string line ) { string [ ] ls = line . split ( "<litcomma>" ) ; userid = integer . parseint ( ls [ 0 ] ) ; latitude = double . parsedouble ( ls [ 1 ] ) ; longitude = double . parsedouble ( ls [ 2 ] ) ; time = ls [ 3 ] ; try { timestamp = sdf . parse ( time ) . gettime ( ) / 1000 ; } catch ( parseexception e ) { system . out . println ( ls [ 3 ] + "\\n" + e . getmessage ( ) ) ; } locid = integer . parseint ( ls [ 4 ] ) ; }
te	6	public static void launch ( string f , string type , int upstream , boolean withcontig ) { system . out . println ( "reading taxonomy list.." ) ; arraylist < integer > taxlist = new arraylist < integer > ( ) ; try { bufferedreader br = new bufferedreader ( new filereader ( f ) ) ; string line = br . readline ( ) ; while ( line != null ) { if ( ! line . trim ( ) . equals ( "" ) ) { int taxa = integer . parseint ( line ) ; taxlist . add ( taxa ) ; system . out . println ( taxa ) ; } line = br . readline ( ) ; } br . close ( ) ; } catch ( ioexception e ) { system . out . println ( "io exception reading " + f ) ; e . printstacktrace ( ) ; system . exit ( 0 ) ; } system . out . println ( "loading " + type + " data.." ) ; cogloader loader = new cogloader ( type ) ; try { loader . loadmembers ( taxlist ) ; } catch ( sqlexception e ) { system . out . println ( "failed to load " + type + " data" ) ; e . printstacktrace ( ) ; system . exit ( 0 ) ; } system . out . println ( "all " + type + " number for specified taxonomies: " + loader . cogs . size ( ) ) ; system . out . println ( "scaffolds number:" + loader . scaffolds . size ( ) ) ; system . out . println ( "taxonomies number:" + loader . taxonomies . size ( ) ) ; for ( iterator < integer > iterator = loader . taxonomies . iterator ( ) ; iterator . hasnext ( ) ; ) { system . out . println ( iterator . next ( ) ) ; } int max_processors_number = 24 ; int processorsnumber = runtime . getruntime ( ) . availableprocessors ( ) ; system . out . println ( "processors number:" + processorsnumber ) ; int threadnumber = math . min ( processorsnumber , max_processors_number ) ; system . out . println ( "loading loading " + type + " fastas.." ) ; string dir = "mo_" + type ; loader . writecogs ( threadnumber , dir , type , upstream ) ; if ( withcontig ) { system . out . println ( "loading corresponding contigs.." ) ; loader . writecontigs ( threadnumber , "mo_contig" ) ; } }
te	10	private static void sendpagelist ( commandsender sender , int page , set < string > names ) { int total = names . size ( ) ; int totalperpage = 10 ; int totalpages = total / totalperpage + 1 ; int startindex = ( page - 1 ) * totalperpage ; int endindex = startindex + totalperpage ; sender . sendmessage ( chatcolor . green + "list of all help pages " + chatcolor . white + "(" + page + "/" + totalpages + ")" + chatcolor . green + ":" ) ; string [ ] namearray = names . toarray ( new string [ names . size ( ) ] ) ; for ( int i = startindex ; i < endindex && i < total ; i ++ ) { string userfriendly = "/" + namearray [ i ] . replace ( "-" , " " ) ; sender . sendmessage ( chatcolor . dark_gray + " " + i + ". " + chatcolor . white + userfriendly ) ; } string nextpage ; if ( page == totalpages ) { nextpage = "1" ; } else { nextpage = string . valueof ( page + 1 ) ; } sender . sendmessage ( chatcolor . green + "next page: " + chatcolor . white + "/help -list " + nextpage ) ; }
te	10	private static void reflectionappend ( final object lhs , final object rhs , final class < ? > clazz , final patternawareequalsbuilder builder , final boolean usetransients , final string [ ] excludefields ) { if ( isregistered ( lhs , rhs ) ) { return ; } try { register ( lhs , rhs ) ; final field [ ] fields = clazz . getdeclaredfields ( ) ; accessibleobject . setaccessible ( fields , true ) ; for ( int i = 0 ; i < fields . length && builder . isequals ; i ++ ) { final field f = fields [ i ] ; if ( ! arrayutils . contains ( excludefields , f . getname ( ) ) && ( f . getname ( ) . indexof ( '$' ) == - 1 ) && ( usetransients || ! modifier . istransient ( f . getmodifiers ( ) ) ) && ( ! modifier . isstatic ( f . getmodifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( final illegalaccessexception e ) { throw new internalerror ( "unexpected illegalaccessexception" ) ; } } } } finally { unregister ( lhs , rhs ) ; } }
te	2	public void actionperformed ( actionevent e ) { string temp = ram_size . gettext ( ) ; try { invalid_ram_lbl . setbounds ( 112 , 175 , 140 , 20 ) ; invalid_ram_lbl . settext ( "ram must be numeric" ) ; int tempint = integer . parseint ( temp ) ; if ( 768 >= tempint ) { invalid_ram_lbl . settext ( "ram must be greater than 768mb" ) ; invalid_ram_lbl . setbounds ( 75 , 175 , 230 , 20 ) ; throw new exception ( ) ; } } catch ( exception e1 ) { invalid_ram_lbl . setvisible ( true ) ; return ; } prefs . put ( "ram_size" , temp ) ; invalid_ram_lbl . setvisible ( false ) ; settingswindow ( false ) ; mainwindow ( true ) ; }
te	7	public static void updatenextnote ( note note , note compare ) { int pitch = compare . getpitch ( ) ; int string = 0 ; int fret = 0 ; for ( int i = start_pitch ; i < end_pitch ; i ++ ) { if ( i == pitch && string != note . getstringno ( ) ) { compare . setstring ( string ) ; compare . setfret ( fret ) ; return ; } else if ( i == pitch && string == note . getstringno ( ) ) { compare . setstring ( - 1 ) ; ; return ; } else if ( fret == 7 && string != 5 ) { fret = 0 ; string ++ ; } else { fret ++ ; } } }
te	6	@ override public message < ? > presend ( message < ? > message , messagechannel channel ) { try { object logmessage = expressionutil . parse ( expression , message ) ; if ( logmessage instanceof throwable ) { stringwriter stringwriter = new stringwriter ( ) ; ( ( throwable ) logmessage ) . printstacktrace ( new printwriter ( stringwriter , true ) ) ; logmessage = stringwriter . tostring ( ) ; } switch ( this . level ) { case error : logger . error ( log_pattern , channel , logmessage ) ; break ; case warn : logger . warn ( log_pattern , channel , logmessage ) ; break ; case info : logger . info ( log_pattern , channel , logmessage ) ; break ; case debug : logger . debug ( log_pattern , channel , logmessage ) ; break ; } } catch ( exception e ) { logger . error ( "could not log information for message '" + message + "'" , e ) ; } return message ; }
te	3	public static void addfils ( personne pers , fils f ) { list enfants = new arraylist < personne > ( ) ; try { if ( pers instanceof pere ) { enfants = ( ( pere ) pers ) . getenfants ( ) ; f . setpere ( ( pere ) pers ) ; if ( enfants . contains ( f ) == false ) { try { enfants . add ( f ) ; } catch ( exception e ) { system . out . println ( "erreur d'ajout du fils pour le pere" ) ; e . printstacktrace ( ) ; } } else { system . out . println ( "cette personne est deja ajouter dans la la liste de vos enfants" ) ; return ; } } else if ( pers instanceof mere ) { enfants = ( ( mere ) pers ) . getenfants ( ) ; f . setmere ( ( mere ) pers ) ; if ( enfants . contains ( f ) == false ) { try { enfants . add ( f ) ; } catch ( exception e ) { system . out . println ( "erruer d'ajout du fils pou la m\xe8re" ) ; e . printstacktrace ( ) ; } } else { system . out . println ( "cette personnes est d\xe9ja dans votre liste d'enfant" ) ; return ; } } } catch ( exception e ) { system . out . println ( " cette personne ne peut pas ajouter de fils " ) ; e . printstacktrace ( ) ; } }
te	8	public debris ( rectangle r ) { super ( r . x + r . shape_size2 , r . y + r . shape_size2 , r . vx , r . vy , ( short ) 0 , ( short ) 0 ) ; vx *= 1 + u . r . nextfloat ( ) ; vy *= 1 + u . r . nextfloat ( ) ; float speed = ( float ) math . hypot ( vx , vy ) ; if ( speed >= u . getc ( ) ) { vx /= speed / u . getc ( ) ; vy /= speed / u . getc ( ) ; speed = ( float ) math . hypot ( vx , vy ) ; } else if ( speed < 0.4f ) { vx /= speed / 0.4f ; vy /= speed / 0.4f ; speed = ( float ) math . hypot ( vx , vy ) ; } r = 4 ; dead = false ; gid = ++ u . gid ; }
te	8	@ override protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string reportdir = getservletcontext ( ) . getrealpath ( "/web-inf/classes" ) ; string templatepath = reportdir + file . separator + jasperreporttemplate ; string reporttype = request . getparameter ( "reporttype" ) ; reporttype type = reporttype != null && reporttype . equalsignorecase ( "pdf" ) ? reporttype . pdf : reporttype . csv ; long startdate = long . parselong ( request . getparameter ( "start" ) ) / ms_per_sec ; long enddate = long . parselong ( request . getparameter ( "end" ) ) / ms_per_sec ; byte [ ] report = plannerservice . generatereport ( templatepath , type , startdate , enddate ) ; response . setcontenttype ( string . format ( "application/%s" , type == reporttype . csv ? "csv" : "pdf" ) ) ; response . addheader ( "content-disposition" , "attachment; filename=report." + ( type == reporttype . csv ? "csv" : "pdf" ) ) ; response . setcontentlength ( report . length ) ; outputstream responseoutputstream = response . getoutputstream ( ) ; responseoutputstream . write ( report ) ; }
te	3	@ suppresswarnings ( "unchecked" ) public map < string , string > getsmssendinfo ( map < string , string > record ) { map < string , string > smssendinfo = new hashmap < string , string > ( ) ; try { string [ ] emails = record . get ( "email" ) . split ( "[|]" ) ; string [ ] telnos = record . get ( "telno" ) . split ( "[|]" ) ; string [ ] pernrs = record . get ( "pernr" ) . split ( "[|]" ) ; map < string , string > recievermap = getrecievers ( emails , telnos , pernrs ) ; stringbuffer recievers = new stringbuffer ( ) ; for ( string email : recievermap . keyset ( ) ) { recievers . append ( recievermap . get ( email ) ) ; recievers . append ( unsconsts . mark_comma ) ; } if ( recievers . length ( ) > 0 ) { recievers . deletecharat ( recievers . length ( ) - 1 ) ; } string sysres = getsys ( record . get ( "sys" ) ) ; list < map < string , string > > sysinfo = new objectmapper ( ) . readvalue ( "[" + sysres + "]" , list . class ) ; smssendinfo . put ( "sn" , sysinfo . get ( 0 ) . get ( "smssn" ) ) ; smssendinfo . put ( "orgaddr" , sysinfo . get ( 0 ) . get ( "smsno" ) ) ; smssendinfo . put ( "telno" , recievers . tostring ( ) ) ; smssendinfo . put ( "content" , record . get ( "body" ) ) ; } catch ( jsonparseexception e ) { e . printstacktrace ( ) ; } catch ( jsonmappingexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return smssendinfo ; }
te	9	private boolean scan ( move move , scandirection scandirection ) { int wall = 0 ; int midpoint = 0 ; int player = move . getplayer ( ) ; if ( scandirection == scandirection . row || scandirection == scandirection . diagnal_right ) { midpoint = move . getcolumn ( ) ; wall = getrowsize ( ) - 1 ; } else if ( scandirection == scandirection . column || scandirection == scandirection . diagnal_left ) { midpoint = move . getrow ( ) ; wall = getcolumnsize ( ) - 1 ; } else { return false ; } int start = getstart ( midpoint ) ; int end = getend ( wall , midpoint ) ; int markcount = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( markcount == 3 ) { return true ; } integer playerid = null ; if ( scandirection == scandirection . column ) { playerid = getmoveat ( i , move . getcolumn ( ) ) ; } else if ( scandirection == scandirection . row ) { playerid = getmoveat ( move . getrow ( ) , i ) ; } else if ( scandirection == scandirection . diagnal_right ) { int row = getstart ( ( move . getrow ( ) - end ) ) + i ; int column = i ; playerid = getmoveat ( row , column ) ; } else if ( scandirection == scandirection . diagnal_left ) { int row = i ; int column = end - i ; playerid = getmoveat ( row , column ) ; } if ( playerid != null && playerid == player ) { markcount ++ ; } else { markcount = 0 ; } } return markcount == 3 ; }
te	3	public int isvalidmsginfo ( map < string , string > record ) { int result = 1 ; int type = integer . valueof ( record . get ( "type" ) ) ; boolean ismailactive = ( integer . valueof ( integer . tohexstring ( type ) ) & integer . valueof ( integer . tohexstring ( 1 ) ) ) > 0 ? true : false ; boolean issmsactive = ( integer . valueof ( integer . tohexstring ( type ) ) & integer . valueof ( integer . tohexstring ( 2 ) ) ) > 0 ? true : false ; if ( ismailactive && issmsactive ) { if ( isemail ( record . get ( "email" ) ) == istelno ( record . get ( "telno" ) ) && isemail ( record . get ( "email" ) ) == true ) { result = 0 ; } else if ( isemail ( record . get ( "email" ) ) != istelno ( record . get ( "telno" ) ) ) { result = - 1 ; } } else { if ( ismailactive ) { if ( isemail ( record . get ( "email" ) ) ) result = 0 ; } if ( issmsactive ) { if ( istelno ( record . get ( "telno" ) ) ) result = 0 ; } } return result ; }
te	7	public final area zoom ( ) { area a = ( area ) this ; a . mycells = new treeset ( ) ; double deltalat = topleft [ 0 ] - bottomright [ 0 ] / analyzer . zoom_factor ; double deltalon = bottomright [ 1 ] - topleft [ 1 ] / analyzer . zoom_factor ; for ( int i = 0 ; i < analyzer . zoom_factor ; i ++ ) { for ( int j = 0 ; j < analyzer . zoom_factor ; j ++ ) { cell __c = new cell ( ) ; __c . topleft [ 0 ] = topleft [ 0 ] - j * deltalat ; __c . topleft [ 1 ] = topleft [ 1 ] + i * deltalon ; __c . bottomright [ 0 ] = bottomright [ 0 ] + ( analyzer . zoom_factor - j ) * deltalat ; __c . bottomright [ 1 ] = bottomright [ 1 ] - ( analyzer . zoom_factor - i ) * deltalon ; a . mycells . add ( __c ) ; } } return a ; }
te	10	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "digite o inicio do cpf:" ) ; int cpf = scan . nextint ( ) ; int cpftemp = cpf ; int d1 = 0 , d2 = 0 ; for ( int i = 9 ; i >= 1 ; i -- ) { int digit = cpf % 10 ; system . out . println ( digit ) ; d1 += digit * i ; cpftemp -= digit ; cpftemp /= 10 ; } d1 %= 11 ; if ( d1 == 10 ) { d1 = 0 ; } cpftemp = cpf ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( i == 9 ) { d2 += d1 * i ; } else { int digit = cpf % 10 ; system . out . println ( digit ) ; d2 += digit * i ; cpftemp -= digit ; cpftemp /= 10 ; } } d2 %= 11 ; if ( d2 == 10 ) { d2 = 0 ; } system . out . println ( d1 ) ; system . out . println ( d2 ) ; }
te	5	@ override public void onauthenticationsuccess ( final httpservletrequest request , final httpservletresponse response , final authentication authentication ) throws servletexception , ioexception { final savedrequest savedrequest = requestcache . getrequest ( request , response ) ; if ( savedrequest == null ) { clearauthenticationattributes ( request ) ; return ; } final string targeturlparameter = gettargeturlparameter ( ) ; if ( isalwaysusedefaulttargeturl ( ) || ( targeturlparameter != null && stringutils . hastext ( request . getparameter ( targeturlparameter ) ) ) ) { requestcache . removerequest ( request , response ) ; clearauthenticationattributes ( request ) ; return ; } clearauthenticationattributes ( request ) ; }
te	6	public functions ( string x , string y , arraylist < string > pt , arraylist < string > pn , boolean isar ) { name = x ; type = y ; rtype = y ; if ( pt . size ( ) == 1 ) { ptype . add ( pt . get ( 0 ) ) ; } else { for ( int i = 0 ; i < pt . size ( ) - 1 ; i ++ ) { ptype . add ( pt . get ( i ) ) ; } } if ( pn . size ( ) == 1 ) { pname . add ( pt . get ( 0 ) ) ; } else { for ( int i = 0 ; i < pn . size ( ) - 1 ; i ++ ) { pname . add ( pn . get ( i ) ) ; } } isarray . add ( isar ) ; }
te	2	public arraylist < string > getmoviesbyactor ( string [ ] actor ) { arraylist < string > movies = new arraylist < string > ( ) ; try { resultset rs = statement . executequery ( "select title from movies " + "where last_name = " + actor [ 0 ] + " and first_name = " + actor [ 1 ] ) ; while ( rs . next ( ) ) movies . add ( rs . getstring ( 1 ) ) ; } catch ( sqlexception e ) { system . err . println ( e ) ; system . exit ( 1 ) ; } return movies ; }
te	4	static public final byte [ ] rlestringtobytearray ( string s ) { int length = ( ( ( int ) s . charat ( 0 ) ) << 16 ) | ( ( int ) s . charat ( 1 ) ) ; byte [ ] array = new byte [ length ] ; boolean nextchar = true ; char c = 0 ; int node = 0 ; int runlength = 0 ; int i = 2 ; for ( int ai = 0 ; ai < length ; ) { byte b ; if ( nextchar ) { c = s . charat ( i ++ ) ; b = ( byte ) ( c > > 8 ) ; nextchar = false ; } else { b = ( byte ) ( c & 0xff ) ; nextchar = true ; } switch ( node ) { case 0 : if ( b == escape_byte ) { node = 1 ; } else { array [ ai ++ ] = b ; } break ; case 1 : if ( b == escape_byte ) { array [ ai ++ ] = escape_byte ; node = 0 ; } else { runlength = b ; if ( runlength < 0 ) runlength += 0x100 ; node = 2 ; } break ; case 2 : for ( int j = 0 ; j < runlength ; ++ j ) array [ ai ++ ] = b ; node = 0 ; break ; } } if ( node != 0 ) throw new illegalstateexception ( "bad run-length encoded byte array" ) ; if ( i != s . length ( ) ) throw new illegalstateexception ( "excess data in rle byte array string" ) ; return array ; }
te	7	public string removecommonlines ( string data ) { string result = "" ; int index ; arraylist list = new arraylist ( ) ; string [ ] temp = data . split ( "\\n" ) ; int length = temp . length ; for ( index = 1 ; index < length ; index ++ ) { if ( ! temp [ index - 1 ] . equals ( temp [ index ] ) ) list . add ( temp [ index - 1 ] ) ; } list . add ( temp [ index - 1 ] ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) result += list . get ( i ) + "\\n" ; return result . substring ( 0 , result . length ( ) - 1 ) ; }
te	10	public static void main ( string [ ] args ) { final int numofqueries = 500 ; final int numofiteration = 5 ; system . out . println ( "number of queries = " + numofqueries ) ; map < integer , list < long > > records = new treemap < > ( ) ; for ( int i = 0 ; i < numofiteration ; i ++ ) { system . out . println ( "iter-" + i ) ; generatetestwords ( 5 , numofqueries ) ; map < integer , long > iterrecord = findoptimalnumofbucket ( ) ; stream . of ( iterrecord ) . map ( map :: entryset ) . flatmap ( collection :: stream ) . foreach ( e -> { if ( records . containskey ( e . getkey ( ) ) ) { records . get ( e . getkey ( ) ) . add ( e . getvalue ( ) ) ; } else { list < long > times = new arraylist < > ( ) ; times . add ( e . getvalue ( ) ) ; records . put ( e . getkey ( ) , times ) ; } } ) ; } stream . of ( records ) . map ( map :: entryset ) . flatmap ( collection :: stream ) . foreach ( e -> { system . out . println ( e . getkey ( ) + " = " + e . getvalue ( ) ) ; int total = 0 ; for ( long time : e . getvalue ( ) ) { total += time ; } system . out . println ( e . getkey ( ) + " = " + ( total / e . getvalue ( ) . size ( ) ) ) ; } ) ; }
te	2	public static int geturitype ( string uri ) { matcher m ; m = constants . regexset . pattern_absolute_ws . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the absolute ws model" ) ; return constants . uritypescons . uri_type_absolute_ws ; } m = constants . regexset . pattern_absolute_ns . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the absolute ns model" ) ; return constants . uritypescons . uri_type_absolute_ns ; } m = constants . regexset . pattern_relative . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the relative model" ) ; system . out . println ( "relative module " + uri ) ; ; return constants . uritypescons . uri_type_relative ; } return constants . uritypescons . uri_type_wrong ; }
te	6	slidingpuzzleboard ( final int colcount , final int rowcount ) { setstyle ( "-fx-background-color: #f3f3f3; " + "-fx-border-color: #f3f3f3; " ) ; cols = colcount ; rows = rowcount ; double gameboardwidth = slidingpuzzlepiece . getpuzzlesize ( ) * colcount ; double gameboardheigth = slidingpuzzlepiece . getpuzzlesize ( ) * rowcount ; setprefsize ( gameboardwidth , gameboardheigth ) ; setmaxsize ( gameboardwidth , gameboardheigth ) ; autosize ( ) ; final int i70 = 70 ; path gameboardgrid = new path ( ) ; gameboardgrid . setstroke ( color . rgb ( i70 , i70 , i70 ) ) ; getchildren ( ) . add ( gameboardgrid ) ; final int i5 = 5 ; for ( int spalte = 0 ; spalte < colcount - 1 ; spalte ++ ) { gameboardgrid . getelements ( ) . addall ( new moveto ( slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * spalte , i5 ) , new lineto ( slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * spalte , slidingpuzzlepiece . getpuzzlesize ( ) * rowcount - i5 ) ) ; } for ( int zeile = 0 ; zeile < rowcount - 1 ; zeile ++ ) { gameboardgrid . getelements ( ) . addall ( new moveto ( i5 , slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * zeile ) , new lineto ( slidingpuzzlepiece . getpuzzlesize ( ) * colcount - i5 , slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * zeile ) ) ; } }
te	5	public static int [ ] getsurroundingtiles ( int x , int y ) { int [ ] surrounding = new int [ 4 ] ; try { surrounding [ 0 ] = surroundingtile ( x , y - 1 ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 0 ] = - 1 ; } try { surrounding [ 1 ] = surroundingtile ( x - 1 , y ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 1 ] = - 1 ; } try { surrounding [ 2 ] = surroundingtile ( x + 1 , y ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 2 ] = - 1 ; } try { surrounding [ 3 ] = surroundingtile ( x , y + 1 ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 3 ] = - 1 ; } for ( int i : surrounding ) { system . out . println ( i ) ; } return surrounding ; }
te	3	public static < t > randomaccesslinkedlist < t > emptylist ( ) { return new randomaccesslinkedlist < t > ( ) { @ override public boolean isempty ( ) { return true ; } @ override public int length ( ) { return 0 ; } @ override public int hashcode ( ) { return - 1 ; } @ suppresswarnings ( "rawtypes" ) @ override public boolean equals ( object obj ) { if ( obj instanceof randomaccesslinkedlist ) { return ( ( randomaccesslinkedlist ) obj ) . isempty ( ) ; } else { return false ; } } @ override public string tostring ( ) { return "[]" ; } } ; }
te	6	public static arraylist < string [ ] > parsewiftext ( string wallettext ) { arraylist < string [ ] > keyaddresspairs = new arraylist < string [ ] > ( ) ; string trimedinputstring = wallettext . trim ( ) ; string [ ] lines = trimedinputstring . split ( "\\n" ) ; for ( string line : lines ) { string trimedline = line . trim ( ) ; if ( trimedline . equals ( "" ) || trimedline . charat ( 0 ) == '#' ) { continue ; } string trimedlinewithouttabs = trimedline . replace ( '\\t' , ' ' ) ; string privkeywif = trimedlinewithouttabs . split ( " " ) [ 0 ] ; string address = btcutils . getb58addressfromb58privkey ( privkeywif ) ; keyaddresspairs . add ( new string [ ] { privkeywif , address } ) ; } return keyaddresspairs ; }
te	2	public static void removeredundancies ( ) throws interruptedexception { class removeredundancy implements runnable { private int i ; removeredundancy ( int i ) { this . i = i ; } public void run ( ) { files . remove ( this . i ) ; } } int i = 0 ; executorservice pool = executors . newfixedthreadpool ( cores ) ; while ( i < files . size ( ) ) { string file = files . get ( i ) ; file = namefix ( file ) ; if ( new file ( minecraft . getworkingdirectory ( ) , file ) . exists ( ) ) pool . submit ( new removeredundancy ( i ) ) ; else i ++ ; } pool . shutdown ( ) ; pool . awaittermination ( long . max_value , timeunit . milliseconds ) ; }
te	10	protected int overrun ( int itemsize , int nitems ) throws exception { if ( itemsize > bufsize ) throw new exception ( "zlibinstream overrun: max itemsize exceeded" ) ; if ( underlying == null ) throw new exception ( "zlibinstream overrun: no underlying stream" ) ; if ( end - ptr != 0 ) system . arraycopy ( b , ptr , b , 0 , end - ptr ) ; ptroffset += ptr ; end -= ptr ; ptr = 0 ; while ( end < itemsize ) { decompress ( ) ; } if ( itemsize * nitems > end ) nitems = end / itemsize ; return nitems ; }
te	8	void solve ( scanner sc , printwriter pw ) { long e = sc . nextlong ( ) ; long r = sc . nextlong ( ) ; if ( r > e ) r = e ; int n = sc . nextint ( ) ; long [ ] v = new long [ n ] ; pair [ ] p = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] = sc . nextlong ( ) ; p [ i ] = new pair ( v [ i ] , i ) ; } boolean [ ] was = new boolean [ n ] ; long [ ] from = new long [ n ] ; long [ ] to = new long [ n ] ; arrays . sort ( p ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pos = p [ i ] . pos ; from [ pos ] = e ; for ( int j = 0 ; j < pos ; j ++ ) if ( was [ j ] ) from [ pos ] = math . min ( from [ pos ] , to [ j ] + ( pos - j ) * r ) ; to [ pos ] = 0 ; for ( int j = pos + 1 ; j < n ; j ++ ) if ( was [ j ] ) to [ pos ] = math . max ( to [ pos ] , from [ j ] - ( j - pos ) * r ) ; ans += ( from [ pos ] - to [ pos ] ) * p [ i ] . value ; was [ pos ] = true ; } pw . println ( ans ) ; }
te	9	public youdaotransdialog ( ) { font font = new font ( "\u5fae\u8f6f\u96c5\u9ed1" , font . bold , 13 ) ; translate . setfont ( font ) ; reset . setfont ( font ) ; wisdom . setfont ( font ) ; about . setfont ( font ) ; backward . setfont ( font ) ; forward . setfont ( font ) ; output . setcolumns ( 68 ) ; output . setrows ( 30 ) ; output . setlinewrap ( true ) ; output . setforeground ( color . black ) ; output . seteditable ( false ) ; output . setcursor ( cursor . getpredefinedcursor ( height ) ) ; output . setlocale ( locale . us ) ; output . setselectedtextcolor ( color . white ) ; float [ ] hsb = color . rgbtohsb ( 51 , 135 , 255 , null ) ; output . setselectioncolor ( color . gethsbcolor ( hsb [ 0 ] , hsb [ 1 ] , hsb [ 2 ] ) ) ; float [ ] hsb_1 = color . rgbtohsb ( 186 , 224 , 190 , null ) ; output . setbackground ( color . gethsbcolor ( hsb_1 [ 0 ] , hsb_1 [ 1 ] , hsb_1 [ 2 ] ) ) ; output . setfont ( new font ( "" , font . plain , 14 ) ) ; output . addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { char c = e . getkeychar ( ) ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) ) { input . grabfocus ( ) ; input . settext ( c + "" ) ; } else if ( e . getkeychar ( ) == keyevent . vk_escape ) { input . grabfocus ( ) ; input . settext ( "" ) ; } } @ override public void keyreleased ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { } } ) ; input . setfont ( new font ( "\u5fae\u8f6f\u96c5\u9ed1" , font . bold , 15 ) ) ; input . setselectedtextcolor ( color . white ) ; input . setselectioncolor ( color . gethsbcolor ( hsb [ 0 ] , hsb [ 1 ] , hsb [ 2 ] ) ) ; input . addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { } @ override public void keyreleased ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_alt ) { altentered = false ; } } @ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_enter ) { translate ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_escape ) { input . settext ( "" ) ; } else if ( e . getkeycode ( ) == keyevent . vk_alt ) { altentered = true ; } else if ( e . getkeycode ( ) == keyevent . vk_left || e . getkeycode ( ) == keyevent . vk_up ) { if ( altentered ) { backward . doclick ( 100 ) ; } } else if ( e . getkeycode ( ) == keyevent . vk_right || e . getkeycode ( ) == keyevent . vk_down ) { if ( altentered ) { forward . doclick ( 100 ) ; } } } } ) ; backward . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { task t = translate . getinstance ( ) . previoustask ( ) ; if ( t != null ) { input . settext ( t . getinstring ( ) ) ; output . settext ( "                                               >>>>>>>>>>>>>>>>" + ( t . getindex ( ) + 1 ) + " / " + t . getsum ( ) + "<<<<<<<<<<<<<<<<\\n" + t . getoutstring ( ) ) ; output . setcaretposition ( 0 ) ; } input . grabfocus ( ) ; } } ) ; forward . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { task t = translate . getinstance ( ) . nexttask ( ) ; if ( t != null ) { input . settext ( t . getinstring ( ) ) ; output . settext ( "                                               >>>>>>>>>>>>>>>>" + ( t . getindex ( ) + 1 ) + " / " + t . getsum ( ) + "<<<<<<<<<<<<<<<<\\n" + t . getoutstring ( ) ) ; output . setcaretposition ( 0 ) ; } input . grabfocus ( ) ; } } ) ; translate . addactionlistener ( new translatelistener ( ) ) ; reset . addactionlistener ( new resetlistener ( ) ) ; about . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { input . settext ( "tsingxu" ) ; translate ( ) ; input . grabfocus ( ) ; } } ) ; wisdom . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int cnt = ( int ) ( math . random ( ) * wisdoms . length ) ; input . settext ( wisdoms [ cnt ] ) ; translate ( ) ; input . grabfocus ( ) ; } } ) ; jp . add ( backward ) ; jp . add ( forward ) ; jp . add ( input ) ; jp . add ( translate ) ; jp . add ( reset ) ; jp . add ( wisdom ) ; jp . add ( about ) ; jsp = new jscrollpane ( output ) ; jsp . getverticalscrollbar ( ) . setvalue ( 0 ) ; lineborder lb = new lineborder ( color . gethsbcolor ( hsb_1 [ 0 ] , hsb_1 [ 1 ] , hsb_1 [ 2 ] ) , 0 ) ; jsp . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_as_needed ) ; jsp . setborder ( lb ) ; jp . add ( jsp ) ; jp . setbackground ( color . gethsbcolor ( hsb_1 [ 0 ] , hsb_1 [ 1 ] , hsb_1 [ 2 ] ) ) ; jf . add ( jp ) ; jf . setvisible ( true ) ; jf . setsize ( 800 , 650 ) ; jf . setminimumsize ( new dimension ( 800 , 650 ) ) ; jf . setdefaultcloseoperation ( jframe . exit_on_close ) ; jf . setlocation ( ( ( int ) toolkit . getdefaulttoolkit ( ) . getscreensize ( ) . getwidth ( ) - 800 ) / 2 , ( ( int ) toolkit . getdefaulttoolkit ( ) . getscreensize ( ) . getheight ( ) - 600 ) / 2 ) ; imageicon ii = new imageicon ( this . getclass ( ) . getresource ( "dropbox.png" ) ) ; jf . seticonimage ( ii . getimage ( ) ) ; translate . getinstance ( ) . setdialog ( this ) ; input . grabfocus ( ) ; }
te	9	@ override public void solve ( ) { try { file file = new file ( "euler13.txt" ) ; bufferedreader r = new bufferedreader ( new filereader ( file ) ) ; string l = r . readline ( ) ; list < string > lines = new arraylist < string > ( ) ; while ( l != null ) { lines . add ( l ) ; l = r . readline ( ) ; } list < list < integer > > splitlines = new arraylist < list < integer > > ( ) ; for ( string line : lines ) { list < integer > splitline = new arraylist < integer > ( ) ; for ( string s : line . split ( "" ) ) { if ( "" . equals ( s ) ) { continue ; } splitline . add ( integer . valueof ( s ) ) ; } splitlines . add ( splitline ) ; } long sum = 0 ; for ( list < integer > splitline : splitlines ) { long temp = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { temp = 10 * temp + splitline . get ( i ) ; } sum += temp ; } print ( string . valueof ( sum ) . substring ( 0 , 10 ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	1	@ test public void testdocumentchange ( ) throws exception { undomanagerfactory undomanagerfactory = new undomanagerfactoryimpl ( ) ; changefactory changefactory = new changefactoryimpl ( ) ; document document = new documentimpl ( ) ; undomanager undomanager = undomanagerfactory . createundomanager ( document , 2 ) ; assert . assertfalse ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; change change1 = changefactory . createinsertion ( 1 , "test change1" , 0 , 1 ) ; change1 . apply ( document ) ; change change2 = changefactory . createinsertion ( 2 , "test change2" , 1 , 2 ) ; change2 . apply ( document ) ; undomanager . registerchange ( change1 ) ; undomanager . registerchange ( change2 ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; system . out . println ( "undoing and redoing starts here----------------------------------------------" ) ; undomanager . undo ( ) ; assert . asserttrue ( undomanager . canredo ( ) ) ; undomanager . undo ( ) ; undomanager . redo ( ) ; undomanager . redo ( ) ; system . out . println ( "registering new change ------------------------------------------------------" ) ; change change3 = changefactory . createinsertion ( 3 , "test change3" , 2 , 3 ) ; change3 . apply ( document ) ; undomanager . registerchange ( change3 ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; system . out . println ( "undoing and redoing starts here----------------------------------------------" ) ; undomanager . undo ( ) ; assert . asserttrue ( undomanager . canredo ( ) ) ; undomanager . undo ( ) ; undomanager . redo ( ) ; undomanager . redo ( ) ; }
te	4	private boolean checkpackage ( ) { if ( getbarpackage ( ) . getapkfile ( ) == null || ! getbarpackage ( ) . getapkfile ( ) . canread ( ) ) { getlog ( ) . error ( "apk file is not specified or cannot be read." ) ; return false ; } string apkname = getbarpackage ( ) . getapkfile ( ) . getname ( ) ; if ( getbarpackage ( ) . getbarfile ( ) == null ) { getlog ( ) . error ( "bar file is not specified." ) ; return false ; } file currentbarfile = new file ( getbarpackage ( ) . getbarfile ( ) . getparent ( ) , apkname . replace ( ".apk" , ".bar" ) ) ; if ( ! currentbarfile . exists ( ) ) { getlog ( ) . error ( "bar file does not exist." ) ; return false ; } file desirablebarfile = getbarpackage ( ) . getbarfile ( ) ; if ( currentbarfile . getpath ( ) . equals ( desirablebarfile . getpath ( ) ) ) { return true ; } if ( ! currentbarfile . canwrite ( ) ) { getlog ( ) . error ( "bar file does not exist or no permission to write." ) ; return false ; } if ( desirablebarfile . exists ( ) && ! desirablebarfile . delete ( ) ) { getlog ( ) . error ( "failed to delete existing bar file with desirable " + "name. path: " + desirablebarfile . getpath ( ) ) ; return false ; } return currentbarfile . renameto ( desirablebarfile ) ; }
te	4	private void adddropdownlist ( int tagid , arraylist < integer > newtags ) { float x = ddlx + ddlwidth + 10 ; float y = ddly ; pfont font2 = mysketch . createfont ( "helvetica" , defaultfontsize ) ; dropdownlist newd = cp5 . adddropdownlist ( "select another tag " + ( lists . size ( ) + 1 ) ) . setlabel ( "select another tag" ) . setposition ( x , y ) . setbarheight ( 20 ) . setwidth ( ddlwidth ) . setheight ( ( int ) ( myheight - y + 30 ) ) . setitemheight ( 16 ) . setcolorbackground ( mysketch . color ( 235 ) ) . setcolorforeground ( mysketch . color ( highlightcolor ) ) . setcolorlabel ( 0 ) ; newd . getcaptionlabel ( ) . touppercase ( false ) . setletterspacing ( 3 ) . setfont ( font2 ) . setcolor ( 0 ) ; for ( int tag : newtags ) { newd . additem ( qeadata . gettagdictionary ( ) . get ( tag ) , tag ) ; } lists . add ( newd ) ; }
te	5	private static void drawtiled1danimated ( ) { final int size = 1000 ; final int scale = 400 ; final int frames = 75 ; double p = 1.0 / 3 ; int seed = ( int ) ( integer . max_value * math . random ( ) ) ; int n = 6 ; perlin2d pn = new perlin2d ( p , n , seed ) ; final double [ ] [ ] y = pn . createtiledarray ( size , frames ) ; final bufferedimage [ ] images = new bufferedimage [ frames ] ; for ( int i = 0 ; i < frames ; i ++ ) { bufferedimage b = new bufferedimage ( scale , scale , bufferedimage . type_int_rgb ) ; graphics bg = b . getgraphics ( ) ; bg . setcolor ( color . red ) ; for ( int j = 0 ; j < size ; j ++ ) { bg . filloval ( ( int ) ( j * 1.0 * scale / size ) , ( int ) ( y [ j ] [ i ] * scale ) , 2 , 2 ) ; } images [ i ] = b ; } driver . savegif ( images , "1d tiled animation - " + seed + ".gif" ) ; final jpanel panel = new jpanel ( ) { public int count ; @ override public void paintcomponent ( graphics g ) { g . drawimage ( images [ count / 10 ] , 0 , 0 , null ) ; count = ( count + 1 ) % ( frames * 10 ) ; } } ; panel . setpreferredsize ( new dimension ( scale , scale ) ) ; driver . display ( panel ) ; }
te	1	public int [ ] getrangeadmissions ( int [ ] from , int [ ] to ) throws sqlexception { int [ ] adm = new int [ 8 ] ; adm [ 0 ] = this . getamountr ( "$5" , from , to ) ; adm [ 1 ] = this . getamountr ( "$10" , from , to ) ; adm [ 2 ] = this . getamountr ( "$20" , from , to ) ; adm [ 3 ] = this . getamountr ( "g-tix" , from , to ) ; adm [ 4 ] = this . getamountr ( "mgr comp" , from , to ) ; adm [ 5 ] = this . getamountr ( "comp pass" , from , to ) ; adm [ 6 ] = this . getamountr ( "comp" , from , to ) ; adm [ 7 ] = this . getamountr ( "hotel" , from , to ) ; return adm ; }
te	7	private symbol statetosymbol ( state prevstate , state currstate ) { for ( int i = 0 ; i < board_size ; i ++ ) { for ( int j = 0 ; j < board_size ; j ++ ) { if ( prevstate . field [ i ] [ j ] != currstate . field [ i ] [ j ] ) { if ( currstate . field [ i ] [ j ] == 1 ) return new cross ( i * board_size + j ) ; else return new circle ( i * board_size + j ) ; } } } return null ; }
te	6	public rotatableobject ( shape s , color color , float pivotx , float pivoty , float acceleration , movementdirection direction , string triggeredby ) { super ( s , color ) ; isrotating = false ; angle = 0.0f ; this . acceleration = acceleration ; this . direction = direction ; this . triggeredby = triggeredby ; if ( ( pivotx >= 0.0f ) && ( pivoty >= 0.0f ) && ( pivotx <= 1.0f ) && ( pivoty <= 1.0f ) ) { pivotpoint = new vector2f ( s . getminx ( ) + pivotx * s . getwidth ( ) , s . getminy ( ) + pivoty * s . getheight ( ) ) ; } else { pivotpoint = new vector2f ( s . getminx ( ) , s . getminy ( ) ) ; } }
te	10	public int compara ( string xy , inteiro i ) { a = 0 ; s1 = "" ; while ( xy . charat ( a ) != '=' && xy . charat ( a ) != '<' && xy . charat ( a ) != '>' ) { s1 += xy . charat ( a ) ; a ++ ; } c1 = xy . charat ( a ) ; a ++ ; c2 = xy . charat ( a ) ; s1 = i . trocavar ( s1 ) ; a ++ ; s2 = "" ; while ( xy . charat ( a ) != ' ' ) { s2 += xy . charat ( a ) ; a ++ ; } s2 = i . trocavar ( s2 ) ; b = integer . parseint ( s1 ) ; c = integer . parseint ( s2 ) ; if ( c1 == '<' && c2 == '<' ) { if ( b < c ) return 1 ; return 0 ; } else if ( c1 == '<' && c2 == '=' ) { if ( b <= c ) return 1 ; return 0 ; } else if ( c1 == '>' && c2 == '>' ) { if ( b > c ) return 1 ; return 0 ; } else if ( c1 == '>' && c2 == '=' ) { if ( b >= c ) return 1 ; return 0 ; } else if ( c1 == '=' && c2 == '=' ) { if ( b == c ) return 1 ; return 0 ; } return 3 ; }
te	9	public static void main ( string [ ] args ) throws ioexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; int cases = integer . parseint ( br . readline ( ) ) ; stringbuilder output = new stringbuilder ( "" ) ; output . append ( "shipping routes output\\n\\n" ) ; for ( int i = 1 ; i <= cases ; i ++ ) { output . append ( "data set  " + i + "\\n\\n" ) ; string [ ] datasets = br . readline ( ) . split ( "\\\\s+" ) ; int nwarehouse = integer . parseint ( datasets [ 0 ] ) ; int nlegs = integer . parseint ( datasets [ 1 ] ) ; int nrequest = integer . parseint ( datasets [ 2 ] ) ; boolean graph [ ] [ ] = new boolean [ nwarehouse ] [ nwarehouse ] ; string [ ] warehouselist = br . readline ( ) . split ( "\\\\s+" ) ; hashmap < string , integer > warehousemap = new hashmap ( ) ; for ( int j = 0 ; j < warehouselist . length ; j ++ ) { warehousemap . put ( warehouselist [ j ] , j ) ; } for ( int j = 0 ; j < nlegs ; j ++ ) { string legs [ ] = br . readline ( ) . split ( "\\\\s+" ) ; int vertexa = warehousemap . get ( legs [ 0 ] ) ; int vertexb = warehousemap . get ( legs [ 1 ] ) ; graph [ vertexa ] [ vertexb ] = true ; graph [ vertexb ] [ vertexa ] = true ; } for ( int j = 0 ; j < nrequest ; j ++ ) { string req = br . readline ( ) ; string [ ] requests = req . split ( "\\\\s+" ) ; int shipmentsize = integer . parseint ( requests [ 0 ] ) ; int sourcenode = warehousemap . get ( requests [ 1 ] ) ; int destinationnode = warehousemap . get ( requests [ 2 ] ) ; int distance = bfs ( graph , sourcenode , destinationnode ) ; if ( distance == - 1 ) { output . append ( "no shipment possible\\n" ) ; } else { output . append ( "$" ) ; output . append ( distance * shipmentsize * 100 ) ; output . append ( "\\n" ) ; } } output . append ( "\\n" ) ; } output . append ( "end of output" ) ; system . out . println ( output ) ; }
te	3	@ suppresswarnings ( "unused" ) private static double [ ] locidbasedoneminusexpconsecutiveweightevent ( int uaid , int ubid ) { user ua = new user ( uaid ) ; user ub = new user ( ubid ) ; linkedlist < record > meetingevent = new linkedlist < record > ( ) ; linkedlist < double > meetingrawweight = new linkedlist < double > ( ) ; int aind = 0 ; int bind = 0 ; long lastmeet = 0 ; double freq = 0 ; double measure = 0 ; while ( aind < ua . records . size ( ) && bind < ub . records . size ( ) ) { record ra = ua . records . get ( aind ) ; record rb = ub . records . get ( bind ) ; if ( ra . timestamp - rb . timestamp > 3600 * 4 ) { bind ++ ; continue ; } else if ( rb . timestamp - ra . timestamp > 3600 * 4 ) { aind ++ ; continue ; } else { if ( ra . locid == rb . locid && ra . timestamp - lastmeet >= 3600 ) { freq ++ ; measure = - ( math . log10 ( ua . locationweight ( ra ) ) + math . log10 ( ub . locationweight ( rb ) ) ) ; meetingevent . add ( ra ) ; meetingrawweight . add ( measure ) ; lastmeet = ra . timestamp ; } aind ++ ; bind ++ ; } } double [ ] rt = new double [ 2 ] ; double w = 0 ; measure = 0 ; int cnt = 0 ; if ( meetingevent . size ( ) == 1 ) { for ( double m : meetingrawweight ) rt [ 0 ] += m ; rt [ 1 ] = freq ; } else if ( meetingevent . size ( ) > 1 ) { for ( int i = 0 ; i < meetingevent . size ( ) ; i ++ ) { long t1 = 0 , t2 = 0 ; if ( i == 0 ) t1 = long . max_value ; else t1 = meetingevent . get ( i ) . timestamp - meetingevent . get ( i - 1 ) . timestamp ; if ( i == meetingevent . size ( ) - 1 ) t2 = long . max_value ; else t2 = meetingevent . get ( i + 1 ) . timestamp - meetingevent . get ( i ) . timestamp ; long t = math . min ( t1 , t2 ) ; w = 1 - math . exp ( - event_time_exp_para_c * t / 3600.0 / 24 ) ; system . out . println ( double . tostring ( w ) + "\\t" + double . tostring ( t / 3600.0 / 24 ) ) ; measure += meetingrawweight . get ( i ) * w ; cnt ++ ; } if ( cnt != meetingrawweight . size ( ) ) system . out . println ( "error in calculate events total weight<litcomma> missing event" ) ; rt [ 0 ] = measure ; rt [ 1 ] = freq ; } return rt ; }
te	10	public static xmlnode parsetext ( string text ) throws eofexception { xmlnode currentnode = new xmlnode ( ) ; char [ ] c = text . tochararray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { if ( c [ i ] == '/' ) { if ( currentnode . getparent ( ) . getname ( ) == null ) return currentnode ; currentnode = currentnode . getparent ( ) ; } if ( ( c [ i ] == '<' ) && ( c [ ( i + 1 ) ] != '/' ) ) { string tagtext = text . substring ( i + 1 ) ; xmlnode newnode = new xmlnode ( ) ; currentnode . addchild ( newnode ) ; currentnode = newnode ; currentnode . setname ( tagtext . substring ( 0 , tagtext . indexof ( ">" ) ) . split ( " " ) [ 0 ] ) ; int tagend = min ( tagtext . indexof ( ">" ) , tagtext . indexof ( "/" ) ) ; string attribtext = tagtext . substring ( 0 , tagend ) ; for ( string currentattribute : attribtext . split ( " " ) ) { if ( currentattribute . split ( "=" ) . length >= 2 ) currentnode . addattribute ( currentattribute . split ( "=" ) [ 0 ] , currentattribute . split ( "=" ) [ 1 ] . replace ( "\\"" , "" ) ) ; } i = i + tagend - 1 ; } } throw new eofexception ( "nodes aren't closed properly" ) ; }
te	4	public static void main ( string [ ] args ) { controller c = new controller ( ) ; random r = new random ( ) ; int num = r . nextint ( 3 ) ; if ( num == 0 ) { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciartimes ( ) ) ; } } else if ( num == 1 ) { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciarbandas ( ) ) ; } } else { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciarpaises ( ) ) ; } } }
te	5	public void drop ( command command ) { if ( ! command . hassecondword ( ) ) { system . out . println ( "drop what?" ) ; return ; } string id = command . getsecondword ( ) ; int index = 0 ; boolean searching = true ; while ( searching && index < mochila . size ( ) ) { item item = mochila . get ( index ) ; if ( item . getid ( ) . equals ( id ) ) { currentroom . additem ( item ) ; mochila . remove ( index ) ; searching = false ; system . out . println ( "el objeto se ha dejado en la habitacion" ) ; } index ++ ; } if ( searching ) { system . out . println ( "no estas llevando el objeto que has indicado" ) ; } }
te	5	private void testtoandfrombytearray ( ) { total ++ ; try { string source = "gattaca" ; sequence sequence = new sequence ( source ) ; byte [ ] bytes = reader . tobytearray ( sequence ) ; sequence result = reader . frombytearray ( bytes ) ; if ( sequence . compareto ( result ) == 0 ) { system . out . println ( "testtoandfrombytearray - success! expected: " + sequence + " result: " + result ) ; success ++ ; } else { failure ++ ; system . out . println ( "testtoandfrombytearray - failed!\\n\\t expected: " + sequence + "\\n\\t result: " + result + "\\nintermediate byte array: " ) ; for ( byte b : bytes ) { string out = integer . tobinarystring ( b ) ; system . out . println ( "\\t" + out + " " + b ) ; } } } catch ( exception e ) { failure ++ ; e . printstacktrace ( ) ; } }
te	9	public static void main ( string [ ] args ) { locale . setdefault ( new locale ( "en" , "us" ) ) ; scanner input = new scanner ( system . in ) ; double x = input . nextdouble ( ) ; double y = input . nextdouble ( ) ; double x1 = 12.5 , y1 = 8.5 ; double x2 = 22.5 , y2 = 8.5 ; double x3 = 17.5 , y3 = 3.5 ; double abc = math . abs ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) ; double abp = math . abs ( x1 * ( y2 - y ) + x2 * ( y - y1 ) + x * ( y1 - y2 ) ) ; double apc = math . abs ( x1 * ( y - y3 ) + x * ( y3 - y1 ) + x3 * ( y1 - y ) ) ; double pbc = math . abs ( x * ( y2 - y3 ) + x2 * ( y3 - y ) + x3 * ( y - y2 ) ) ; boolean isintriangle = abp + apc + pbc == abc ; if ( isintriangle || ( ( x >= 12.5 && x <= 17.5 ) && ( y >= 8.5 && y <= 13.5 ) ) || ( ( x >= 20.0 && x <= 22.5 ) && ( y >= 8.5 && y <= 13.5 ) ) ) { system . out . println ( "inside" ) ; } else { system . out . println ( "outside" ) ; } input . close ( ) ; }
te	3	public void writenonfriendsmeeting ( ) { try { bufferedwriter fout2 = new bufferedwriter ( new filewriter ( "nonfriendsmeeting.txt" ) ) ; for ( int i = 0 ; i < nonfriendmeeting . size ( ) ; i ++ ) { fout2 . write ( string . format ( "%d\\t%d\\t%d\\n" , nonfriendmeeting . get ( i ) [ 0 ] , nonfriendmeeting . get ( i ) [ 1 ] , nonfriendmeeting . get ( i ) [ 2 ] ) ) ; } fout2 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	8	public float getresult ( list < float > input ) { layer layer = layers . get ( 1 ) ; list < float > results = layer . getvalues ( input ) ; for ( int i = 2 ; i <= layers . size ( ) ; i ++ ) { layer = layers . get ( i ) ; results = layer . getvalues ( results ) ; } float total = 0 ; for ( float result : results ) { total += result ; } total = total / results . size ( ) ; return total ; }
te	7	public stateofplay ( stateofplay parent , node [ ] nodes2copy , node [ ] originmove , int type , int level , int depth ) { this . parent = parent ; this . type = type ; this . level = level ; this . depth = depth ; if ( level % 2 == 0 ) { player = type ; } else { if ( type == 1 ) { player = 2 ; } else { player = 1 ; } } if ( originmove != null ) { this . originmove [ 0 ] = originmove [ 0 ] ; this . originmove [ 1 ] = originmove [ 1 ] ; } for ( int i = 0 ; i < nodes2copy . length ; i ++ ) { node newnode = new node ( nodes2copy [ i ] . getid ( ) , nodes2copy [ i ] . location . x , nodes2copy [ i ] . location . y ) ; this . nodes [ i ] = newnode ; this . nodes [ i ] . setisbusy ( nodes2copy [ i ] . getisbusy ( ) ) ; this . nodes [ i ] . setunchangedflag ( nodes2copy [ i ] . getunchangedflag ( ) ) ; } for ( int i = 0 ; i < nodes2copy . length ; i ++ ) { for ( node neighbour : nodes2copy [ i ] . getneighbours ( ) ) { for ( int j = 0 ; j < nodes . length ; j ++ ) { if ( nodes [ j ] . getid ( ) . contains ( neighbour . getid ( ) ) ) { nodes [ i ] . addneighbour ( nodes [ j ] ) ; } } } } }
te	6	public static void main ( string [ ] args ) throws exception { myqueue mq = new myqueue ( 10 ) ; mq . insert ( 0 ) ; mq . insert ( - 1 ) ; mq . insert ( 20 ) ; mq . insert ( 21 ) ; int ind = 0 ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; ind ++ ; if ( ind == 1 ) { break ; } } system . out . println ( "size : " + mq . size ( ) ) ; mq . insert ( 4 ) ; mq . insert ( 3 ) ; mq . insert ( 2 ) ; mq . insert ( 1 ) ; mq . insert ( 0 ) ; mq . insert ( - 1 ) ; mq . insert ( - 2 ) ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; } mq . insert ( 4 ) ; mq . insert ( 3 ) ; mq . insert ( 2 ) ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; } }
te	1	@ test public void testmovecard ( ) throws invalidfacevalueexception , invalidsuitexception , invalidgamestateexception { layout layout = createunshuffledlayout ( ) ; asserttrue ( layout . processmove ( "d3 1" ) ) ; list < string > state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "  d2  " ) ) ; asserttrue ( state . get ( 3 ) . contains ( "d3  sj  **  **  **  **  **" ) ) ; asserttrue ( layout . processmove ( "d2 1" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "  da  " ) ) ; asserttrue ( state . get ( 3 ) . contains ( "d3  sj  **  **  **  **  **" ) ) ; asserttrue ( state . get ( 4 ) . contains ( "d2      s8  **  **  **  **" ) ) ; asserttrue ( layout . processmove ( "da 1" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "  d6  " ) ) ; asserttrue ( state . get ( 3 ) . contains ( "d3  sj  **  **  **  **  **" ) ) ; asserttrue ( state . get ( 4 ) . contains ( "d2      s8  **  **  **  **" ) ) ; asserttrue ( state . get ( 5 ) . contains ( "da          s4  **  **  **" ) ) ; asserttrue ( layout . processmove ( "d6 h" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "sk  **  **  **  **  **  **      d6" ) ) ; asserttrue ( layout . processmove ( "da d" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "sk  **  **  **  **  **  **   da d6" ) ) ; assertfalse ( state . get ( 5 ) . contains ( "da" ) ) ; asserttrue ( layout . processmove ( "d2 d" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "sk  **  **  **  **  **  **   d2 d6" ) ) ; asserttrue ( layout . processmove ( "sk 2" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "   **  **  **  **  **  **   d2 d6" ) ) ; asserttrue ( state . get ( 4 ) . contains ( "   sk  s8  **  **  **  **" ) ) ; asserttrue ( state . get ( 5 ) . contains ( "   d3      s4  **  **  **" ) ) ; asserttrue ( layout . processmove ( "sj 3" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 2 ) . contains ( "   sq  **  **  **  **  **" ) ) ; asserttrue ( layout . processmove ( "sj 7" ) ) ; state = layout . print ( ) ; asserttrue ( state . get ( 4 ) . contains ( "s8  **  **  **  **" ) ) ; asserttrue ( state . get ( 8 ) . contains ( "hq" ) ) ; asserttrue ( state . get ( 9 ) . contains ( "sj" ) ) ; asserttrue ( state . get ( 10 ) . contains ( "sk" ) ) ; asserttrue ( state . get ( 11 ) . contains ( "d3" ) ) ; assertfalse ( layout . processmove ( "hq c" ) ) ; assertfalse ( layout . processmove ( "c9 1" ) ) ; }
te	2	public static void setskin ( gameprofile gp ) { if ( getmap ( ) . containskey ( gp . getid ( ) ) ) { propertymap map = gp . getproperties ( ) ; map . put ( "textures" , getmap ( ) . get ( gp . getid ( ) ) ) ; return ; } try { url url = new url ( "https://sessionserver.mojang.com/session/minecraft/profile/" + gp . getid ( ) . tostring ( ) . replaceall ( "-" , "" ) + "?unsigned=false" ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; jsonparser parser = new jsonparser ( ) ; jsonobject root = ( jsonobject ) parser . parse ( reader ) ; jsonarray properties = ( jsonarray ) root . get ( "properties" ) ; string data = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "value" ) ; string signature = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "signature" ) ; reader . close ( ) ; propertymap map = gp . getproperties ( ) ; property property = new property ( "textures" , data , signature ) ; map . put ( "textures" , property ) ; getmap ( ) . put ( gp . getid ( ) , property ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	9	public void updatequeuepieces ( ) { emptyqueuesidegridsegment ( ) ; arrayblockingqueue < tetrimino > queue = copytetriminoqueue ( mboard . gettetriminoqueue ( ) ) ; tetrimino tetrimino , dummytetrimino ; int tetriminoheight , tetriminowidth , tetriminoid , row , col ; int [ ] [ ] coordinates ; int queuesize = queue . size ( ) ; for ( int i = 0 ; i < queuesize ; i ++ ) { tetrimino = queue . poll ( ) ; tetriminoheight = tetrimino . getshape ( ) . getheight ( ) ; tetriminowidth = tetrimino . getshape ( ) . getwidth ( ) ; tetriminoid = tetrimino . getid ( ) ; row = ( i + 1 ) * msectionheight - ( msectionheight + tetriminoheight ) / 2 ; col = ( msidegrid [ 0 ] . length - tetriminowidth ) / 2 ; dummytetrimino = new tetrimino ( tetrimino . getshape ( ) , tetriminoid , new int [ ] { row , col } ) ; coordinates = dummytetrimino . getcoordinates ( ) ; for ( int [ ] coord : coordinates ) { msidegrid [ coord [ 0 ] ] [ coord [ 1 ] ] = tetriminoid ; } } repaint ( ) ; }
te	8	public void getoutput ( arraylist < product > possibleproductlist , int numberofgifts , double totaltargetprice , int currentcounter ) { if ( totaltargetprice < 0 || numberofgifts <= 0 ) { return ; } if ( possibleproductlist . size ( ) == numberofgifts ) { finaloutputlist . add ( possibleproductlist ) ; return ; } for ( int i = currentcounter ; i < productlisttowork . size ( ) ; i ++ ) { product currentproduct = productlisttowork . get ( i ) ; arraylist < product > updatedpossibleproductlist = new arraylist < product > ( possibleproductlist ) ; if ( possibleproductlist . size ( ) < numberofgifts ) { updatedpossibleproductlist . add ( currentproduct ) ; double currentprice = currentproduct . getprice ( ) ; getoutput ( updatedpossibleproductlist , numberofgifts , ( totaltargetprice - currentprice ) , ++ currentcounter ) ; } } }
te	10	@ override public void tick ( ) { for ( int i = 0 ; i < trails . size ( ) ; i ++ ) { if ( trails . get ( i ) . isdead ( ) ) trails . remove ( i ) ; trails . get ( i ) . tick ( ) ; } if ( keys . getstatus ( key_a ) || keys . getstatus ( key_s ) || keys . getstatus ( key_d ) || keys . getstatus ( key_w ) ) moving = true ; else { velx = 0 ; vely = 0 ; moving = false ; } boolean up = keys . getstatus ( key_w ) || keys . getstatus ( key_up ) ; boolean down = keys . getstatus ( key_s ) || keys . getstatus ( key_down ) ; boolean left = keys . getstatus ( key_a ) || keys . getstatus ( key_left ) ; boolean right = keys . getstatus ( key_d ) || keys . getstatus ( key_right ) ; if ( debug && keys . ispressed ( key_p ) ) { system . out . println ( "debug: growing tail by 10" ) ; traillife -= 10 ; } if ( up ) vely = - 5 ; if ( down ) vely = 5 ; if ( left ) velx = - 5 ; if ( right ) velx = 5 ; if ( ! up && ! down ) vely = 0 ; if ( ! left && ! right ) velx = 0 ; if ( moving ) { x += velx ; y += vely ; adjust ( ) ; } for ( int i = 0 ; i < entityhandler . getenemies ( ) . size ( ) ; i ++ ) { enemy e = entityhandler . getenemies ( ) . get ( i ) ; if ( collideswith ( e ) ) { if ( e . gettype ( ) == ghost_immortal ) { traillife = 100 ; score -= 100 ; } else { score += 15 ; traillife -= 5 ; } entityhandler . removeenemy ( e ) ; } for ( int k = 0 ; k < trails . size ( ) ; k ++ ) { particletrail pt = trails . get ( i ) ; if ( pt . intersects ( e . getbounds ( ) ) ) { if ( e . gettype ( ) == ghost_immortal ) { traillife += 20 ; score -= 20 ; } else score += 5 ; entityhandler . removeenemy ( e ) ; } } } trails . add ( new startrail ( x , y , player_radius , traillife , color . white ) ) ; if ( traillife < 10 ) traillife = 10 ; }
te	3	public void writeremotefriend ( ) { try { bufferedwriter fout = new bufferedwriter ( new filewriter ( "res/remotefriend.txt" ) ) ; for ( int i = 0 ; i < distantfriend . size ( ) ; i ++ ) { int uaid = distantfriend . get ( i ) [ 0 ] ; int ubid = distantfriend . get ( i ) [ 1 ] ; fout . write ( string . format ( "%d\\t%d\\t%d\\t%d\\n" , distantfriend . get ( i ) [ 0 ] , distantfriend . get ( i ) [ 1 ] , distantfriend . get ( i ) [ 2 ] , meetfreq . get ( uaid ) . get ( ubid ) ) ) ; } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	3	public string getresource ( string type , string subpath , map < string , string > querymap ) { string resource = null ; stringbuffer resources = new stringbuffer ( ) ; url u = urlbulider ( type , subpath , querymap ) ; httpurlconnection urlc = null ; bufferedreader br = null ; try { urlc = ( httpurlconnection ) u . openconnection ( ) ; urlc . setdoinput ( true ) ; urlc . setdooutput ( false ) ; urlc . setallowuserinteraction ( false ) ; br = new bufferedreader ( new inputstreamreader ( urlc . getinputstream ( ) , "utf8" ) ) ; while ( ( resource = br . readline ( ) ) != null ) { resources . append ( resource ) ; } } catch ( ioexception e ) { } finally { if ( br != null ) { try { br . close ( ) ; } catch ( ioexception e ) { } } if ( urlc != null ) { urlc . disconnect ( ) ; } } return resources . tostring ( ) ; }
te	10	public static void update ( gamecontainer container , statebasedgame game , int delta ) { if ( container . getinput ( ) . ismousepressed ( 0 ) ) { int mousex = mouse . getx ( ) / 20 ; int mousey = ( game . height - mouse . gety ( ) ) / 20 ; energy [ mousex ] [ mousey ] += 100 ; } if ( container . getinput ( ) . ismousepressed ( input . mouse_right_button ) ) { int mousex = mouse . getx ( ) / 20 ; int mousey = ( game . height - mouse . gety ( ) ) / 20 ; energy [ mousex ] [ mousey ] -= 100 ; } for ( int i = 0 ; i < energy . length ; i ++ ) { for ( int j = 0 ; j < energy [ 0 ] . length ; j ++ ) { if ( energy [ i ] [ j ] < starting ) { energy [ i ] [ j ] ++ ; } if ( j > 0 ) { if ( energy [ i ] [ j - 1 ] + differencelevel < energy [ i ] [ j ] ) { if ( rand . nextint ( random ) == 0 ) { energy [ i ] [ j - 1 ] += energyflow ; energy [ i ] [ j ] -= energyflow ; } } } if ( j < energy [ 0 ] . length - 1 ) { if ( energy [ i ] [ j + 1 ] + differencelevel < energy [ i ] [ j ] ) { if ( rand . nextint ( random ) == 0 ) { energy [ i ] [ j + 1 ] += energyflow ; energy [ i ] [ j ] -= energyflow ; } } } if ( i > 0 ) { if ( energy [ i - 1 ] [ j ] + differencelevel < energy [ i ] [ j ] ) { if ( rand . nextint ( random ) == 0 ) { energy [ i - 1 ] [ j ] += energyflow ; energy [ i ] [ j ] -= energyflow ; } } } if ( i < energy . length - 1 ) { if ( energy [ i + 1 ] [ j ] + differencelevel < energy [ i ] [ j ] ) { if ( rand . nextint ( random ) == 0 ) { energy [ i + 1 ] [ j ] += energyflow ; energy [ i ] [ j ] -= energyflow ; } } } } } }
te	4	public static void tst1 ( ) { trackdto trackdto = new trackdto ( ) ; list < track > tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track11 = trackdto . gettrackbytitle ( "one" ) ; system . out . println ( track11 ) ; system . out . println ( "------" ) ; track track12 = trackdto . gettrackbyid ( 12 ) ; system . out . println ( track12 ) ; system . out . println ( "------" ) ; track track22 = new track ( 22 , "jude" , "beatles" ) ; track track23 = new track ( 23 , "submarine" , "beatles" ) ; string result20 = trackdto . createtrack ( track22 ) ; system . out . println ( result20 ) ; result20 = trackdto . createtrack ( track23 ) ; system . out . println ( result20 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track24 = new track ( 13 , "1999" , "pineapples" ) ; result20 = trackdto . updatetrack ( track24 ) ; system . out . println ( result20 ) ; trackdto . deletetrackbyid ( 12 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; }
te	6	public string responseheaderstostring ( ) { string retr = "no headers" ; if ( responseheaders != null ) { set < map . entry < string , list < string > > > entryset = responseheaders . entryset ( ) ; iterator < map . entry < string , list < string > > > its = entryset . iterator ( ) ; map . entry < string , list < string > > currententry ; if ( its . hasnext ( ) ) { retr = "" ; } while ( its . hasnext ( ) ) { currententry = its . next ( ) ; string currentkey = currententry . getkey ( ) ; iterator < string > itl = currententry . getvalue ( ) . iterator ( ) ; while ( itl . hasnext ( ) ) { retr += "key: " + currentkey + " value: " + itl . next ( ) + "\\n" ; } } } return retr ; }
te	10	public static string getliteral ( int mask ) { perm values [ ] = perm . values ( ) ; list < string > actions = new arraylist < string > ( ) ; int idx = 0 ; while ( idx < values . length && mask > 0 ) { perm value = values [ idx ] ; if ( ( mask & value . getmask ( ) ) == value . getmask ( ) ) { actions . add ( value . literal ) ; mask = mask | value . getmask ( ) ; } idx ++ ; } stringbuilder builder = new stringbuilder ( ) ; for ( idx = 0 ; idx < actions . size ( ) ; idx ++ ) { builder . append ( actions . get ( idx ) ) ; if ( idx != actions . size ( ) - 1 ) { builder . append ( "<litcomma>" ) ; } } return builder . tostring ( ) ; }
te	10	public static list < double [ ] > getbuckets ( double [ ] data , int binsize ) { list < double [ ] > quantilelist = new arraylist < > ( ) ; list < double > datalist = new arraylist < > ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { datalist . add ( data [ i ] ) ; } list < double > sorteddata = mergesort . mergesort ( ( arraylist ) datalist ) ; if ( binsize >= sorteddata . size ( ) ) { quantilelist . add ( ( double [ ] ) sorteddata . toarray ( ) ) ; return quantilelist ; } else { int qgroupsize = ( sorteddata . size ( ) - ( sorteddata . size ( ) % binsize ) ) / binsize ; int remainingsize = sorteddata . size ( ) % binsize ; int index = 0 ; for ( int i = 0 ; i < binsize ; i ++ ) { double [ ] qgroup ; if ( i == binsize - 1 ) { qgroup = new double [ qgroupsize + remainingsize ] ; for ( int groupsize = 0 ; groupsize < qgroupsize + remainingsize ; groupsize ++ ) { qgroup [ groupsize ] = sorteddata . get ( index ) ; index ++ ; } } else { qgroup = new double [ qgroupsize ] ; for ( int groupsize = 0 ; groupsize < qgroupsize ; groupsize ++ ) { qgroup [ groupsize ] = sorteddata . get ( index ) ; index ++ ; } } quantilelist . add ( qgroup ) ; } } return quantilelist ; }
te	1	@ test public void testshuffle ( ) throws invalidsuitexception , invalidfacevalueexception { deck deck = new deck ( ) ; list < card > unshuffled = new arraylist < > ( ) ; for ( card c : deck . getcards ( ) ) { unshuffled . add ( c ) ; } deck . shuffle ( ) ; list < card > shuffled = deck . getcards ( ) ; for ( int i = 0 ; i < unshuffled . size ( ) ; i ++ ) { card before = unshuffled . get ( i ) ; card after = shuffled . get ( i ) ; if ( ! ( before . equals ( after ) ) ) { return ; } } fail ( "order of cards did not change after shuffle" ) ; }
te	5	private double perform ( string operator , double num ) { double trignum = num ; if ( ! this . isradian ) trignum = degreetoradian ( num ) ; switch ( operator ) { case "sin" : return math . sin ( trignum ) ; case "cos" : return math . cos ( trignum ) ; case "tan" : if ( math . cos ( trignum ) == 0 ) throw new illegalargumentexception ( "angel is divisible by 90." ) ; return math . sin ( trignum ) / math . cos ( trignum ) ; case "cot" : if ( math . sin ( trignum ) == 0 ) throw new illegalargumentexception ( "angel is divible by 180." ) ; return math . cos ( trignum ) / math . sin ( trignum ) ; case "ln" : return math . log ( num ) ; case "log" : return math . log10 ( num ) ; default : throw new illegalargumentexception ( "illegal operator." ) ; } }
te	2	public arraylist < string [ ] > getactornames ( ) { arraylist < string [ ] > actors = new arraylist < string [ ] > ( ) ; try { resultset rs = statement . executequery ( "select last_name<litcomma> first_name from actors" ) ; while ( rs . next ( ) ) actors . add ( new string [ ] { rs . getstring ( 1 ) , rs . getstring ( 2 ) } ) ; } catch ( sqlexception e ) { system . err . println ( e ) ; system . exit ( 1 ) ; } return actors ; }
te	10	public void show ( int ans [ ] ) { int i = ans [ 0 ] ; int k = 1 ; int j = i + 1 ; anstext . settext ( "" ) ; while ( j < i * 2 ) { anstext . append ( ( "no." + ans [ j ] + " :" + node [ ans [ k ++ ] ] . getname ( ) + "->" ) ) ; j ++ ; while ( ans [ j ] == ans [ j - 1 ] && j < i * 2 ) { anstext . append ( node [ ans [ k ] ] . getname ( ) + "->" ) ; j ++ ; k ++ ; } if ( j < i * 2 || k <= i ) anstext . append ( "" + node [ ans [ k ] ] . getname ( ) ) ; anstext . append ( "\\n" ) ; } anstext . append ( "full time " + new decimalformat ( "#.00" ) . format ( dks . getanstime ( ) ) + "\\n" ) ; int x1 [ ] = new int [ ans [ 0 ] + 2 ] ; int y1 [ ] = new int [ ans [ 0 ] + 2 ] ; int x2 [ ] = new int [ ans [ 0 ] + 2 ] ; int y2 [ ] = new int [ ans [ 0 ] + 2 ] ; for ( int ii = 1 ; ii <= ans [ 0 ] ; ii ++ ) { x1 [ ii ] = node [ ans [ ii - 1 ] ] . getx ( ) ; y1 [ ii ] = node [ ans [ ii - 1 ] ] . gety ( ) ; x2 [ ii ] = node [ ans [ ii ] ] . getx ( ) ; y2 [ ii ] = node [ ans [ ii ] ] . gety ( ) ; } ; mappanel . update ( mappanel . getgraphics ( ) ) ; mappanel . drawline ( mappanel . getgraphics ( ) , x1 , y1 , x2 , y2 , ans [ 0 ] ) ; }
te	1	private boolean ispasswordcorrect ( ) { string passwordpropertymd5 = properties . getproperty ( globals . property_key_password ) ; if ( passwordpropertymd5 != null ) { passworddialog passworddialog = new passworddialog ( this , true ) ; passworddialog . setvisible ( true ) ; if ( passworddialog . isokbuttonpressed ( ) ) { string passwordmd5 = passworddialog . getpasswordmd5 ( ) ; if ( ! passwordpropertymd5 . equals ( passwordmd5 ) ) { joptionpane . showmessagedialog ( this , globals . bundle . getstring ( "wrongpassword" ) , globals . bundle . getstring ( "apptitle" ) , joptionpane . error_message ) ; return false ; } } else { return false ; } } else { settingsdialog settingsdialog = new settingsdialog ( this , true ) ; settingsdialog . setproperties ( properties ) ; settingsdialog . setvisible ( true ) ; if ( ! settingsdialog . isokbuttonpressed ( ) ) { return false ; } } return true ; }
te	10	private boolean canmove ( ) { int matrix [ ] [ ] = stage . getmatrix ( ) ; switch ( pacman_direction ) { case up : if ( ( int ) location . gety ( ) >= 0 && map_location_px . gety ( ) > ( location . gety ( ) * rungame . tile_len ) ) { return true ; } if ( ( map_location_px . gety ( ) - ( location . gety ( ) * rungame . tile_len ) < 2 ) && matrix [ ( int ) location . gety ( ) - 1 ] [ ( int ) location . getx ( ) ] != 1 ) { return true ; } return false ; case down : if ( ( int ) location . gety ( ) < stage . getmatrix_height ( ) - 1 && matrix [ ( int ) location . gety ( ) + 1 ] [ ( int ) location . getx ( ) ] != 1 ) { return true ; } else { return false ; } case left : if ( ( int ) location . getx ( ) >= 0 && map_location_px . getx ( ) > ( location . getx ( ) * rungame . tile_len ) && ( ( upper_left_boundary . gety ( ) - location . gety ( ) * rungame . tile_len ) < 2 ) && lower_right_boundary . gety ( ) <= ( ( location . gety ( ) + 1 ) * rungame . tile_len ) ) { return true ; } if ( ( ( ( upper_left_boundary . gety ( ) - location . gety ( ) * rungame . tile_len ) < 2 ) && lower_right_boundary . gety ( ) <= ( ( location . gety ( ) + 1 ) * rungame . tile_len ) && map_location_px . getx ( ) - ( location . getx ( ) * rungame . tile_len ) < 2 ) && matrix [ ( int ) location . gety ( ) ] [ ( int ) location . getx ( ) - 1 ] != 1 ) { return true ; } return false ; case right : if ( location . getx ( ) < stage . getmatrix_width ( ) - 1 && matrix [ ( int ) location . gety ( ) ] [ ( int ) location . getx ( ) + 1 ] != 1 && ( map_location_px . gety ( ) - location . gety ( ) * rungame . tile_len ) < 2 ) { return true ; } return false ; case static : return false ; } return true ; }
te	3	@ override public iterator < pair < f , s > > iterator ( ) { return new iterator < pair < f , s > > ( ) { private iterator < entry < f , s > > iterator = list . iterator ( ) ; @ override public boolean hasnext ( ) { return iterator . hasnext ( ) ; } @ override public pair < f , s > next ( ) { entry entry = iterator . next ( ) ; return new pair < f , s > ( ( f ) entry . first , ( s ) entry . second ) ; } @ override public void remove ( ) { iterator . remove ( ) ; } } ; }
te	1	@ get @ produces ( "text/plain;charset=utf-8" ) @ transactionattribute ( transactionattributetype . not_supported ) public string getrejectedmessages ( @ pathparam ( "sys" ) string sys , @ queryparam ( "key" ) string key , @ queryparam ( "ts" ) @ defaultvalue ( "0" ) string ts , @ queryparam ( "max" ) @ defaultvalue ( "200" ) string max ) { int defaultsize = 200 ; try { if ( unsutil . isnullorempty ( sys ) ) return "{}" ; if ( unsutil . isnullorempty ( key ) || ! validator . isvalidsyskeypair ( sys , key ) ) return "{}" ; int failedmsgcount = service . getunsfailedmsgcountbysysid ( sys ) ; if ( failedmsgcount == 0 ) return "{}" ; long version = service . getunsfailedmsgversionbysysid ( sys ) ; if ( version - long . valueof ( ts ) < 0 ) return "{\\"ts\\":\\"" + ts + "\\"}" ; list < map < string , string > > list = new arraylist < map < string , string > > ( ) ; map < string , string > tsmap = new hashmap < string , string > ( ) ; tsmap . put ( "ts" , string . valueof ( version ) ) ; list . add ( tsmap ) ; int resultsize = defaultsize ; try { resultsize = integer . valueof ( max ) . intvalue ( ) ; } catch ( exception e ) { resultsize = defaultsize ; } list < unsfailedmsg > failmsgs = null ; if ( resultsize > 0 ) { failmsgs = service . getunsfailedmsglast ( resultsize , ts , sys ) ; } else { failmsgs = service . getunsfailedmsgbyversion2 ( ts , sys ) ; } for ( unsfailedmsg failmsg : failmsgs ) { map < string , string > failmsgmap = new hashmap < string , string > ( ) ; failmsgmap . put ( "sys" , sys ) ; failmsgmap . put ( "key" , key ) ; failmsgmap . put ( "type" , string . valueof ( failmsg . getmsgtype ( ) ) ) ; failmsgmap . put ( "email" , failmsg . getmsgemail ( ) ) ; failmsgmap . put ( "emailcc" , failmsg . getmsgemailcc ( ) ) ; failmsgmap . put ( "emailbcc" , failmsg . getmsgemailbcc ( ) ) ; failmsgmap . put ( "telno" , failmsg . getmsgtelno ( ) ) ; failmsgmap . put ( "pernr" , failmsg . getmsgpernr ( ) ) ; failmsgmap . put ( "subject" , failmsg . getmsgsubject ( ) ) ; failmsgmap . put ( "body" , failmsg . getmsgbody ( ) ) ; failmsgmap . put ( "aux" , failmsg . getmsgaux ( ) ) ; failmsgmap . put ( "ts" , string . valueof ( ( failmsg . getmsgdatetime ( ) ) . gettime ( ) ) ) ; failmsgmap . put ( "reason" , string . valueof ( failmsg . getfailuretype ( ) ) ) ; failmsgmap . put ( "sensitiveind" , failmsg . getsensitiveind ( ) ) ; list . add ( failmsgmap ) ; } return new objectmapper ( ) . writevalueasstring ( list ) ; } catch ( jsongenerationexception e ) { e . printstacktrace ( ) ; } catch ( jsonmappingexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return "{}" ; }
te	7	public rover ( integer x , integer y , string direction ) { super ( ) ; if ( x == null ) { throw new illegalargumentexception ( "x co-ordinate can't be null" ) ; } if ( x < this . minborder || x > this . maxborder ) { throw new illegalargumentexception ( "x co-ordinate must be within 0 - 9" ) ; } if ( y == null ) { throw new illegalargumentexception ( "y co-ordinate can't be null" ) ; } if ( y < this . minborder || y > this . maxborder ) { throw new illegalargumentexception ( "y co-ordinate must be within 0 - 9" ) ; } if ( direction == null || direction . isempty ( ) ) { throw new illegalargumentexception ( "direction can't be null or empty" ) ; } set < string > directions = new hashset < string > ( arrays . aslist ( new string [ ] { "n" , "e" , "s" , "w" } ) ) ; if ( ! directions . contains ( direction ) ) { throw new illegalargumentexception ( "direction (case sensitive) must be in " + directions ) ; } this . x = x ; this . y = y ; this . direction = direction ; initdirdelta ( ) ; initmappings ( ) ; }
te	8	@ override protected void ensurecapacity ( int inccap ) { if ( inccap < remained ( ) ) { return ; } int newcapacity = 0 ; if ( 2 * inccap <= capacity ) { newcapacity = capacity * 3 / 2 + 1 ; } else { newcapacity = capacity * 2 ; } memoryblock newblock = memoryblock . allocate ( newcapacity ) ; if ( size > 0 ) { long oldaddress = block . address ; long newaddress = newblock . address ; if ( putindex > takeindex ) { copymemory ( oldaddress , takeindex , newaddress , 0 , size ) ; } else { int len = capacity - takeindex ; copymemory ( oldaddress , takeindex , newaddress , 0 , len ) ; if ( size > len ) { copymemory ( oldaddress , 0 , newaddress , len , putindex ) ; } } } memoryblock . deallocate ( block ) ; block = newblock ; capacity = newcapacity ; takeindex = 0 ; putindex = size ; }
te	4	public static void main ( string [ ] args ) throws interruptedexception { long start = system . currenttimemillis ( ) ; system . out . println ( "start" ) ; string filepath ; string filepathsave ; int threadscount ; int imgheight ; int imgwidth ; hashmap < file , string > filesmap ; panel panel = new panel ( ) ; panel . addpanel ( ) ; filepath = panel . readpath ; filepathsave = panel . writepath + "\\\\" ; imgheight = integer . parseint ( panel . resolution . substring ( 0 , ( panel . resolution . indexof ( "x" ) ) ) ) ; imgwidth = integer . parseint ( panel . resolution . substring ( ( panel . resolution . indexof ( "x" ) + 1 ) ) ) ; threadscount = panel . threadsnum ; filemanager fm = new filemanager ( ) ; filepath = ( "d:\\\\test1" ) ; filepathsave = ( "d:\\\\test2\\\\" ) ; fm . cleardirectory ( filepathsave ) ; filesmap = fm . readfilesindirectory ( filepath ) ; final gallery gal = new gallery ( filesmap ) ; thread resizers [ ] = new thread [ threadscount ] ; for ( int i = 0 ; i < threadscount ; i ++ ) resizers [ i ] = new thread ( new resizer ( gal , i , filepathsave , imgwidth , imgheight ) ) ; for ( thread t : resizers ) t . start ( ) ; for ( thread t : resizers ) t . join ( ) ; long end = system . currenttimemillis ( ) ; numberformat formatter = new decimalformat ( "#0.00000" ) ; system . out . print ( "execution time is " + formatter . format ( ( end - start ) / 1000d ) + " seconds" ) ; fm . log ( "    ------------------------------    " ) ; fm . log ( "test date: " + new date ( ) ) ; fm . log ( "files to resize: " + fm . filecounter ( filepath ) ) ; fm . log ( "files to resize: " + fm . filecounter ( filepathsave ) ) ; fm . log ( "size: " + imgheight + " x " + imgwidth ) ; fm . log ( "threads: " + threadscount ) ; fm . log ( "execution time is " + formatter . format ( ( end - start ) / 1000d ) + " seconds" ) ; }
te	3	miningframework ( ) { long t_start = system . currenttimemillis ( ) ; system . out . println ( "start create miningframework instance<litcomma> and construct user instances." ) ; user . addalluser ( ) ; friendpair = new arraylist < int [ ] > ( ) ; distantfriend = new arraylist < int [ ] > ( ) ; nonfriendmeeting = new arraylist < int [ ] > ( ) ; friendmap = new hashmap < integer , hashset < integer > > ( ) ; meetfreq = new hashmap < integer , hashmap < integer , integer > > ( ) ; avgdistance = new hashmap < integer , hashmap < integer , double > > ( ) ; for ( user u : user . alluserset . values ( ) ) { friendmap . put ( u . userid , u . friends ) ; for ( int i : u . friends ) { if ( u . userid < i ) friendpair . add ( new int [ ] { u . userid , i } ) ; } } long t_end = system . currenttimemillis ( ) ; system . out . println ( string . format ( "initailize case finder in %d seconds" , ( t_end - t_start ) / 1000 ) ) ; }
te	8	public static string tostring ( final long code ) { stringbuffer buf = new stringbuffer ( ) ; switch ( ( int ) ( code & mask_pos ) ) { case ( int ) noun_subst : buf . append ( "subst" ) ; break ; case ( int ) noun_depr : buf . append ( "depr" ) ; break ; case ( int ) noun : buf . append ( "noun" ) ; break ; case ( int ) adj : buf . append ( "adj" ) ; break ; case ( int ) adj_ : buf . append ( "adj" ) ; break ; case ( int ) adj_a : buf . append ( "adja" ) ; break ; case ( int ) adj_p : buf . append ( "adjp" ) ; break ; case ( int ) adv : buf . append ( "adv" ) ; break ; case ( int ) num : buf . append ( "num" ) ; break ; case ( int ) ppron : buf . append ( "ppron" ) ; break ; case ( int ) ppron_12 : buf . append ( "ppron12" ) ; break ; case ( int ) ppron_3 : buf . append ( "ppron3" ) ; break ; case ( int ) ppron_siebie : buf . append ( "siebie" ) ; break ; case ( int ) verb : buf . append ( "verb" ) ; break ; case ( int ) verb_fin : buf . append ( "fin" ) ; break ; case ( int ) verb_bedzie : buf . append ( "bedzie" ) ; break ; case ( int ) verb_aglt : buf . append ( "aglt" ) ; break ; case ( int ) verb_praet : buf . append ( "praet" ) ; break ; case ( int ) verb_impt : buf . append ( "impt" ) ; break ; case ( int ) verb_imps : buf . append ( "imps" ) ; break ; case ( int ) verb_inf : buf . append ( "inf" ) ; break ; case ( int ) verb_pcon : buf . append ( "pcon" ) ; break ; case ( int ) verb_pant : buf . append ( "pant" ) ; break ; case ( int ) verb_ger : buf . append ( "ger" ) ; break ; case ( int ) verb_pact : buf . append ( "pact" ) ; break ; case ( int ) verb_ppas : buf . append ( "ppas" ) ; break ; case ( int ) winien : buf . append ( "winien" ) ; break ; case ( int ) pred : buf . append ( "pred" ) ; break ; case ( int ) prep : buf . append ( "prep" ) ; break ; case ( int ) conj : buf . append ( "conj" ) ; break ; case ( int ) qub : buf . append ( "qub" ) ; break ; case ( int ) xxs : buf . append ( "xxs" ) ; break ; case ( int ) xxx : buf . append ( "xxx" ) ; break ; case ( int ) interp : buf . append ( "interp" ) ; break ; case ( int ) ign : buf . append ( "ign" ) ; break ; case ( int ) unknown : buf . append ( "?" ) ; break ; default : throw new runtimeexception ( "unreachable state." ) ; } int emitchunks = 0 ; switch ( ( int ) ( code & mask_pos ) ) { case ( int ) adj_a : case ( int ) adj_p : case ( int ) conj : case ( int ) interp : case ( int ) pred : case ( int ) xxx : case ( int ) ign : break ; case ( int ) adv : emitchunks |= emit_degree ; break ; case ( int ) verb_imps : case ( int ) verb_inf : case ( int ) verb_pant : case ( int ) verb_pcon : emitchunks |= emit_aspect ; break ; case ( int ) qub : emitchunks |= emit_vocality ; break ; case ( int ) prep : emitchunks |= emit_case | emit_vocality ; break ; case ( int ) ppron : emitchunks |= emit_number | emit_case | emit_gender | emit_person | emit_accentability | emit_post_prepositionality ; break ; case ( int ) ppron_siebie : emitchunks |= emit_case ; break ; case ( int ) noun : case ( int ) noun_subst : case ( int ) noun_depr : case ( int ) xxs : emitchunks |= emit_number | emit_case | emit_gender ; break ; case ( int ) verb_ger : emitchunks |= emit_number | emit_case | emit_gender | emit_aspect | emit_negation ; break ; case ( int ) ppron_12 : emitchunks |= emit_number | emit_case | emit_gender | emit_person | emit_accentability ; break ; case ( int ) ppron_3 : emitchunks |= emit_number | emit_case | emit_gender | emit_person | emit_accentability | emit_post_prepositionality ; break ; case ( int ) num : emitchunks |= emit_number | emit_case | emit_gender | emit_accommodability ; break ; case ( int ) adj : case ( int ) adj_ : emitchunks |= emit_number | emit_case | emit_gender | emit_degree ; break ; case ( int ) verb : case ( int ) verb_pact : case ( int ) verb_ppas : emitchunks |= emit_number | emit_case | emit_gender | emit_aspect | emit_negation ; break ; case ( int ) verb_bedzie : case ( int ) verb_fin : case ( int ) verb_impt : emitchunks |= emit_number | emit_person | emit_aspect ; break ; case ( int ) winien : emitchunks |= emit_number | emit_gender | emit_aspect ; break ; case ( int ) verb_praet : emitchunks |= emit_number | emit_gender | emit_aspect | emit_agglutination ; break ; case ( int ) verb_aglt : emitchunks |= emit_number | emit_person | emit_aspect | emit_vocality ; break ; default : throw new runtimeexception ( "unreachable state." ) ; } if ( ( emitchunks & emit_number ) != 0 && ( code & mask_number ) != 0 ) { emit ( buf , number_values_order , number_values , code ) ; } if ( ( emitchunks & emit_case ) != 0 ) { emit ( buf , case_values_order , case_values , code ) ; } if ( ( emitchunks & emit_gender ) != 0 && ( code & mask_gender ) != 0 ) { string [ ] codesorder ; if ( ( code & ( gender_n1 | gender_n2 ) ) == gender_n ) { codesorder = gender_values_order_ipi_wstepny ; } else { codesorder = gender_values_order ; } emit ( buf , codesorder , gender_values , code & mask_gender ) ; } if ( ( emitchunks & emit_person ) != 0 ) { emit ( buf , person_values_order , person_values , code ) ; } if ( ( emitchunks & emit_degree ) != 0 ) { emit ( buf , degree_values_order , degree_values , code ) ; } if ( ( emitchunks & emit_aspect ) != 0 ) { emit ( buf , aspect_values_order , aspect_values , code ) ; } if ( ( emitchunks & emit_negation ) != 0 ) { emit ( buf , negation_values_order , negation_values , code ) ; } if ( ( emitchunks & emit_accentability ) != 0 ) { emit ( buf , accentability_values_order , accentability_values , code ) ; } if ( ( emitchunks & emit_post_prepositionality ) != 0 ) { emit ( buf , post_prepositionality_values_order , post_prepositionality_values , code ) ; } if ( ( emitchunks & emit_accommodability ) != 0 ) { emit ( buf , accommodability_values_order , accommodability_values , code ) ; } if ( ( emitchunks & emit_agglutination ) != 0 ) { emit ( buf , agglutination_values_order , agglutination_values , code ) ; } if ( ( emitchunks & emit_vocality ) != 0 ) { emit ( buf , vocality_values_order , vocality_values , code ) ; } return buf . tostring ( ) ; }
te	6	public static void main ( string [ ] args ) throws exception { if ( args . length < 1 ) { system . out . println ( "java -jar andoidmarketparser.jar <searchquery>" ) ; return ; } string request = args [ 0 ] ; list < androidapplication > returndata = androidmarkethandler . marketsearch ( request ) ; if ( returndata == null ) { system . out . println ( "request return 0 applications" ) ; return ; } for ( androidapplication app : returndata ) { system . out . println ( "name: " + app . getname ( ) ) ; system . out . println ( "image: " + app . getimage ( ) ) ; system . out . println ( "packagename: " + app . getpackagename ( ) ) ; system . out . println ( "description: " + app . getdescription ( ) ) ; system . out . println ( "category: " + app . getcategory ( ) ) ; system . out . println ( "detailsrc: " + app . getdetailsurl ( ) ) ; system . out . println ( "currency: " + app . getcurrency ( ) ) ; system . out . println ( "price: " + app . getprice ( ) ) ; system . out . println ( "filesize: " + app . getfilebytes ( ) ) ; system . out . println ( "minandroidversion: " + app . getminandroidversion ( ) ) ; } system . out . println ( "total finded: " + returndata . size ( ) ) ; }
te	7	@ postconstruct public void init ( ) { httphandler = new httphandler ( ) ; try { url requesturl = new url ( "http://services.brics.dk/java4/cloud" + "/listitems?shopid=" + "195" ) ; element responseroot = httphandler . httprequest ( "get" , requesturl ) . getrootelement ( ) ; if ( responseroot == null ) { throw new exception ( "response from itemlist request was null" ) ; } else { itemlist = new arraylist < item > ( ) ; for ( element itemchild : responseroot . getchildren ( ) ) { element description = itemchild . getchild ( "itemdescription" , webtekns ) ; string descriptionstr = "" ; for ( element descriptionchild : description . getchildren ( ) ) { descriptionchild . setnamespace ( null ) ; switch ( descriptionchild . getname ( ) ) { case "document" : descriptionchild . setname ( "div" ) ; break ; case "bold" : descriptionchild . setname ( "b" ) ; break ; case "italics" : descriptionchild . setname ( "i" ) ; break ; case "list" : descriptionchild . setname ( "ul" ) ; break ; case "item" : descriptionchild . setname ( "li" ) ; break ; default : break ; } descriptionstr += descriptionchild . getvalue ( ) ; } itemlist . add ( new item ( itemchild . getchildtext ( "itemid" , webtekns ) , itemchild . getchildtext ( "itemname" , webtekns ) , itemchild . getchildtext ( "itemurl" , webtekns ) , itemchild . getchildtext ( "itemprice" , webtekns ) , itemchild . getchildtext ( "itemstock" , webtekns ) , descriptionstr ) ) ; } } } catch ( exception e ) { system . out . println ( "an error occurred: " + e . getmessage ( ) ) ; } }
te	1	public int print ( graphics g , pageformat pf , int page ) throws printerexception { graphics2d g2d = ( graphics2d ) g ; g2d . translate ( pf . getimageablex ( ) , pf . getimageabley ( ) ) ; g2d . setfont ( new font ( "tahoma" , font . plain , 22 ) ) ; g . drawstring ( "centerfolds boston" , 10 , 20 ) ; g2d . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; g . drawstring ( "-----------------------------------------" , 10 , 35 ) ; g2d . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; g . drawstring ( "time: " + this . getime ( ) , 10 , 75 ) ; g . drawstring ( "date: " + this . getdate ( ) , 10 , 115 ) ; g2d . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; g . drawstring ( "-----------------------------------------" , 10 , 155 ) ; g2d . setfont ( new font ( "tahoma" , font . plain , 32 ) ) ; g . drawstring ( this . type , 10 , 210 ) ; return page_exists ; }
te	1	public void testdb ( ) { tidepooldatabase db = new tidepooldatabase ( ) ; int tmp ; tmp = db . sendrequest ( 2 , 1 ) ; system . out . println ( "send 2 to 1: " + tmp ) ; tmp = db . sendrequest ( 2 , 3 ) ; system . out . println ( "send 2 to 3: " + tmp ) ; arraylist < user > r1 = db . getrequest ( 1 ) ; system . out . println ( "get " + r1 . size ( ) ) ; arraylist < user > r2 = db . getrequest ( 2 ) ; system . out . println ( "get " + r2 . size ( ) ) ; db . setrespond ( 2 , 1 , "admit" ) ; db . setrespond ( 2 , 3 , "refuse" ) ; r2 = db . getrespond ( 2 ) ; system . out . println ( "get " + r2 . size ( ) ) ; db . deletefriends ( 1 , 2 ) ; }
te	4	private static string [ ] parsequestion ( string line ) { string [ ] result = new string [ 7 ] ; string workingline = line ; int index ; for ( int i = 6 ; i > 1 ; i -- ) { index = workingline . lastindexof ( "<litcomma>" ) ; result [ i ] = workingline . substring ( index + 1 , workingline . length ( ) ) ; workingline = workingline . substring ( 0 , index ) ; } index = workingline . indexof ( "<litcomma>" ) ; result [ 0 ] = workingline . substring ( 0 , index ) ; workingline = workingline . substring ( index + 1 , workingline . length ( ) ) ; result [ 1 ] = workingline ; return result ; }
te	6	public static void main ( string [ ] args ) { long num = 600851475143l ; long max = ( long ) math . sqrt ( num ) ; if ( max % 2 == 0 ) max -- ; for ( ; max > 0 ; max -= 2 ) if ( num % max == 0 ) { boolean p = true ; long s = ( long ) math . sqrt ( max ) ; if ( s % 2 == 0 ) s -- ; for ( ; s > 2 ; s -= 2 ) if ( max % s == 0 ) { p = false ; break ; } if ( p ) { system . out . println ( max ) ; system . exit ( 0 ) ; } } }
te	4	public int neigtbourscount ( int x , int y ) { int result = 0 ; if ( x == 0 ) { if ( y == 0 ) { if ( isalive ( x , y + 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y + 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } } else { if ( y == tablica_length ) { if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } if ( isalive ( x + 1 , y - 1 ) ) { result ++ ; } } else { if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x , y + 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } if ( isalive ( x + 1 , y + 1 ) ) { result ++ ; } } } } else { if ( x == tablica_length ) { if ( y == 0 ) { if ( isalive ( x - 1 , y ) ) { result ++ ; } if ( isalive ( x - 1 , y + 1 ) ) { result ++ ; } if ( isalive ( x , y + 1 ) ) { result ++ ; } } else { if ( y == tablica_length ) { if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x - 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x - 1 , y ) ) { result ++ ; } } } if ( isalive ( x - 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x - 1 , y ) ) { result ++ ; } if ( isalive ( x - 1 , y + 1 ) ) { result ++ ; } if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x , y + 1 ) ) { result ++ ; } } else { if ( y != tablica_length && y != 0 ) { if ( isalive ( x - 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x - 1 , y ) ) { result ++ ; } if ( isalive ( x - 1 , y + 1 ) ) { result ++ ; } if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x , y + 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } if ( isalive ( x + 1 , y + 1 ) ) { result ++ ; } } else { if ( y == 0 ) { if ( isalive ( x - 1 , y ) ) { result ++ ; } if ( isalive ( x - 1 , y + 1 ) ) { result ++ ; } if ( isalive ( x , y + 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } if ( isalive ( x + 1 , y + 1 ) ) { result ++ ; } } else { if ( y == tablica_length ) { if ( isalive ( x - 1 , y ) ) { result ++ ; } if ( isalive ( x - 1 , y - 1 ) ) { result ++ ; } if ( isalive ( x , y - 1 ) ) { result ++ ; } if ( isalive ( x + 1 , y ) ) { result ++ ; } if ( isalive ( x + 1 , y - 1 ) ) { result ++ ; } } } } } } return result ; }
te	10	void readpattern ( scanner s ) { list entry = null , level = entrytab [ ( int ) s . pattern [ character . isdigit ( s . pattern [ 0 ] ) ? 1 : 0 ] % 256 ] ; int [ ] nodevalues = new int [ s . patlen + 1 ] ; int ich = 0 , inv = 0 ; java . util . enumeration eentry = level . elements ( ) ; pattern : for ( ; ; ) { if ( character . isdigit ( s . pattern [ ich ] ) ) { nodevalues [ inv ++ ] = ( ( int ) s . pattern [ ich ++ ] - ( int ) '0' ) ; if ( ich == s . patlen ) break ; } else { nodevalues [ inv ++ ] = 0 ; } for ( ; ; ) { if ( ! eentry . hasmoreelements ( ) ) { int [ ] newnodevalues = new int [ inv + 1 ] ; for ( int jnv = 0 ; jnv != newnodevalues . length ; ++ jnv ) newnodevalues [ jnv ] = 0 ; entry = new list ( ) . snoc ( new character ( s . pattern [ ich ] ) ) . snoc ( newnodevalues ) ; level . snoc ( entry ) ; level = entry ; eentry = level . elements ( ) ; eentry . nextelement ( ) ; eentry . nextelement ( ) ; break ; } entry = ( list ) eentry . nextelement ( ) ; if ( ( ( character ) entry . car ( ) ) . charvalue ( ) == s . pattern [ ich ] ) { level = entry ; eentry = level . elements ( ) ; eentry . nextelement ( ) ; eentry . nextelement ( ) ; break ; } } if ( ++ ich == s . patlen ) { nodevalues [ inv ++ ] = 0 ; break ; } } system . arraycopy ( nodevalues , 0 , ( ( int [ ] ) entry . cdr ( ) . car ( ) ) , 0 , inv ) ; }
te	3	public static void build ( list < string > patches , string path ) { system . out . println ( "building file " + path ) ; try { file f = new file ( path ) ; f . createnewfile ( ) ; runtime r = runtime . getruntime ( ) ; for ( string patch : patches ) { file patchy = new file ( path + ".patch" ) ; patchy . createnewfile ( ) ; filewriter patchwriter = new filewriter ( patchy ) ; for ( int i = 0 ; i < patch . length ( ) ; i ++ ) { if ( patch . charat ( i ) >= 32 && patch . charat ( i ) < 127 ) patchwriter . write ( patch . charat ( i ) ) ; else patchwriter . write ( '\\n' ) ; patchwriter . flush ( ) ; } patchwriter . write ( ( '\\n' ) ) ; patchwriter . flush ( ) ; patchwriter . close ( ) ; process p = r . exec ( "patch " + path + " " + path + ".patch" ) ; p . waitfor ( ) ; patchy . delete ( ) ; } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; logger . getlogger ( fileutil . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( interruptedexception ex ) { ex . printstacktrace ( ) ; logger . getlogger ( fileutil . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
te	1	public void projectsmenuview ( ) { resultset rs = null ; try { statement statement = connection . createstatement ( ) ; rs = statement . executequery ( "select * from projects order by id asc" ) ; } catch ( sqlexception sqe ) { logger . log ( level . severe , "error retrieving projects. error: {0}" , sqe . getmessage ( ) ) ; system . out . println ( "there was an error retreiving projects." ) ; } string columnnames = "id\\t title" ; system . out . println ( columnnames ) ; try { while ( rs . next ( ) ) { int id = rs . getint ( "id" ) ; string title = rs . getstring ( "title" ) ; string displayrow = string . format ( "%4d<litcomma> %20s" , id , title ) ; system . out . println ( displayrow ) ; } } catch ( sqlexception sqe ) { logger . log ( level . severe , "error processing result set. error: {0}" , sqe . getmessage ( ) ) ; system . out . println ( "there was an error in processing the result set." ) ; return ; } }
te	6	private void init ( final stage primarystage ) { thisstage = primarystage ; thisstage . settitle ( "sliding puzzle" ) ; stackpane spane = new stackpane ( ) ; label label = new label ( "name: " ) ; final textfield namefield = new textfield ( ) ; final button setnamefield = new button ( "ok" ) ; final int i5 = 5 ; final int i10 = 10 ; final int i20 = 20 ; final int i100 = 100 ; namefield . setonkeypressed ( new eventhandler < keyevent > ( ) { @ override public void handle ( final keyevent event ) { if ( event . getcode ( ) == keycode . enter ) { setnamefield . fire ( ) ; } } } ) ; setnamefield . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( final actionevent actionevent ) { if ( namefield . gettext ( ) != "" && namefield . gettext ( ) != null ) { username = namefield . gettext ( ) ; } slidingpuzzlepiece . setpuzzlesize ( i100 ) ; newgame ( ) ; } } ) ; vbox welcomebox = new vbox ( i5 ) ; text welcometext = new text ( i100 , i100 , "welcome to the sliding puzzle\\n\\nwhats your name?\\n" ) ; welcometext . setfont ( new font ( i20 ) ) ; welcometext . settextalignment ( textalignment . center ) ; welcomebox . getchildren ( ) . add ( welcometext ) ; welcomebox . setpadding ( new insets ( i10 , i10 , i10 , i10 ) ) ; hbox displaybox = new hbox ( i5 ) ; displaybox . getchildren ( ) . addall ( label , namefield , setnamefield ) ; displaybox . setalignment ( pos . center ) ; welcomebox . getchildren ( ) . add ( displaybox ) ; spane . getchildren ( ) . add ( welcomebox ) ; thisstage . centeronscreen ( ) ; thisstage . tofront ( ) ; thisstage . setscene ( new scene ( spane ) ) ; thisstage . show ( ) ; }
te	2	public static void main ( string [ ] args ) { int number = default_number ; int range = default_range ; int experiments = default_experiments ; int lookfor = - 1 ; int [ ] randomnumbers ; try { if ( args . length > 0 ) number = integer . getinteger ( args [ 0 ] ) ; if ( number < 0 ) throw new exception ( "number must be geq 0" ) ; if ( args . length > 1 ) range = integer . getinteger ( args [ 0 ] ) ; if ( range < 0 ) throw new exception ( "range must be geq 0" ) ; if ( args . length > 2 ) experiments = integer . getinteger ( args [ 2 ] ) ; if ( experiments <= 0 ) throw new exception ( "number of experiments must be greater 0" ) ; } catch ( exception e ) { system . out . println ( "an error happened!\\n" + "message: " + e . getmessage ( ) + "\\n" + usage_text ) ; return ; } random randomgenerator = new random ( ) ; randomnumbers = new int [ number ] ; for ( int i = 0 ; i < number ; i ++ ) { randomnumbers [ i ] = randomgenerator . nextint ( range + 1 ) ; } arrays . sort ( randomnumbers ) ; int i = 0 ; while ( i < experiments ) { lookfor = randomnumbers [ randomgenerator . nextint ( randomnumbers . length ) ] ; try { string result = "" ; result += runandprintsearch ( new interpolationsearch ( randomnumbers , lookfor , 100001 ) ) ; result += runandprintsearch ( new quadraticbinarysearch ( randomnumbers , lookfor , 100001 ) ) ; system . out . println ( result ) ; i ++ ; } catch ( error e ) { } } }
te	6	public quaternion ( matrix m ) { float ww = 0.25f * ( m . get ( 0 , 0 ) + m . get ( 1 , 1 ) + m . get ( 2 , 2 ) + m . get ( 3 , 3 ) ) ; if ( ww >= 0 ) { if ( ww >= eps2 ) { w = ( float ) math . sqrt ( ww ) ; ww = 0.25f / w ; x = ( ( m . get ( 2 , 1 ) - m . get ( 1 , 2 ) ) * ww ) ; y = ( ( m . get ( 0 , 2 ) - m . get ( 2 , 0 ) ) * ww ) ; z = ( ( m . get ( 1 , 0 ) - m . get ( 0 , 1 ) ) * ww ) ; return ; } } else { w = 0 ; x = 0 ; y = 0 ; z = 1 ; return ; } this . w = 0 ; ww = - 0.5f * ( m . get ( 1 , 1 ) + m . get ( 2 , 2 ) ) ; if ( ww >= 0 ) { if ( ww >= eps2 ) { x = ( float ) math . sqrt ( ww ) ; ww = 1.0f / ( 2.0f * x ) ; y = ( m . get ( 1 , 0 ) * ww ) ; z = ( m . get ( 2 , 0 ) * ww ) ; return ; } } else { x = 0 ; y = 0 ; z = 1 ; return ; } this . x = 0 ; ww = 0.5f * ( 1.0f - m . get ( 2 , 2 ) ) ; if ( ww >= eps2 ) { y = ( float ) math . sqrt ( ww ) ; z = ( m . get ( 2 , 1 ) ) / ( 2.0f * y ) ; return ; } y = 0 ; z = 1 ; }
te	2	private void buildmstnodebynode ( graph graph , int startmstat , list < integer > nodesinmst , list < edge > finalmstedges , edge [ ] feeleredges ) { for ( adjlistnode node : graph . getadjlist ( ) . get ( startmstat ) ) { edge feeleredge = node . getedge ( ) ; if ( ! nodesinmst . contains ( feeleredge . getfinish ( ) ) ) { if ( feeleredge . getcost ( ) < feeleredges [ feeleredge . getfinish ( ) ] . getcost ( ) ) { feeleredges [ feeleredge . getfinish ( ) ] = feeleredge ; } } } if ( nodesinmst . size ( ) == graph . getnumvertices ( ) ) return ; int mincost = integer . max_value ; int minedgeindex = - 1 ; edge minedge = null ; for ( int i = 0 ; i < feeleredges . length ; i ++ ) { if ( ! feeleredges [ i ] . isalreadyinmst ( ) && feeleredges [ i ] . getcost ( ) < mincost ) { mincost = feeleredges [ i ] . getcost ( ) ; minedge = feeleredges [ i ] ; minedgeindex = i ; } } finalmstedges . add ( minedge ) ; nodesinmst . add ( minedge . getfinish ( ) ) ; feeleredges [ minedgeindex ] . setalreadyinmst ( true ) ; buildmstnodebynode ( graph , minedge . getfinish ( ) , nodesinmst , finalmstedges , feeleredges ) ; }
te	2	private void retrieve ( ) { try { url url = new url ( web_page + name ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; jsonparser parser = new jsonparser ( ) ; jsonobject object = ( jsonobject ) parser . parse ( reader ) ; string uid = ( string ) object . get ( "uuid_formatted" ) ; this . uuid = uuid . fromstring ( uid ) ; reader . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	2	private entityliving convert ( entitytype type ) { entityliving living = null ; entityplayer ep = ( ( craftplayer ) getplayer ( ) ) . gethandle ( ) ; world world = ep . getworld ( ) ; switch ( type ) { case bat : entitybat bat = new entitybat ( world ) ; living = bat ; break ; case blaze : living = new entityblaze ( world ) ; break ; case cave_spider : living = new entitycavespider ( world ) ; break ; case chicken : living = new entitychicken ( world ) ; break ; case cow : living = new entitycow ( world ) ; break ; case creeper : living = new entitycreeper ( world ) ; break ; case enderman : living = new entityenderman ( world ) ; break ; case endermite : living = new entityendermite ( world ) ; break ; case ender_dragon : living = new entityenderdragon ( world ) ; break ; case ghast : living = new entityghast ( world ) ; break ; case giant : living = new entitygiantzombie ( world ) ; break ; case guardian : living = new entityguardian ( world ) ; break ; case horse : living = new entityhorse ( world ) ; break ; case iron_golem : living = new entityirongolem ( world ) ; break ; case magma_cube : living = new entitymagmacube ( world ) ; break ; case mushroom_cow : living = new entitymushroomcow ( world ) ; break ; case ocelot : living = new entityocelot ( world ) ; break ; case pig : living = new entitypig ( world ) ; break ; case pig_zombie : living = new entitypigzombie ( world ) ; break ; case rabbit : living = new entityrabbit ( world ) ; break ; case sheep : living = new entitysheep ( world ) ; break ; case silverfish : living = new entitysilverfish ( world ) ; break ; case skeleton : living = new entityskeleton ( world ) ; break ; case slime : living = new entityslime ( world ) ; break ; case snowman : living = new entitysnowman ( world ) ; break ; case spider : living = new entityspider ( world ) ; break ; case squid : living = new entitysquid ( world ) ; break ; case villager : living = new entityvillager ( world ) ; break ; case witch : living = new entitywitch ( world ) ; break ; case wither : living = new entitywither ( world ) ; break ; case wolf : living = new entitywolf ( world ) ; break ; case zombie : living = new entityzombie ( world ) ; break ; default : living = new entitypig ( world ) ; break ; } return living ; }
te	8	public void paint1 ( graphics g ) { if ( vidas > 0 ) { if ( tank != null && pelota != null ) { g . drawimage ( fondo , 0 , 0 , getsize ( ) . width , getsize ( ) . height , this ) ; g . drawimage ( tank . getimageni ( ) , tank . getposx ( ) , tank . getposy ( ) , this ) ; g . drawimage ( pelota . getimageni ( ) , pelota . getposx ( ) , pelota . getposy ( ) , this ) ; g . setcolor ( color . white ) ; g . drawstring ( " puntaje = " + puntos , 60 , 60 ) ; g . drawstring ( " vidas = " + vidas , 200 , 60 ) ; if ( pausar ) { g . setcolor ( color . white ) ; g . drawstring ( bueno . getpausado ( ) , tank . getposx ( ) + tank . getancho ( ) / 3 , tank . getposy ( ) + tank . getalto ( ) / 2 ) ; } for ( int i = 0 ; i < lista . size ( ) ; i ++ ) { brick brick = ( brick ) lista . get ( i ) ; g . drawimage ( brick . getimageni ( ) , brick . getposx ( ) , brick . getposy ( ) , this ) ; } if ( instr ) { g . drawimage ( instrucciones , 0 , 0 , this ) ; } } else { g . drawstring ( "no se cargo la imagen.." , 20 , 20 ) ; } } else { g . drawimage ( credits , 0 , 0 , this ) ; } }
te	4	public void run ( ) { try { for ( int i = 1 ; i > 0 ; i ++ ) { dadosgerais dados = new dadosgerais ( ) ; gui . label1 . settext ( "menu principal - " + dadosgerais . formatadatagui . format ( dadosgerais . data ) ) ; thread . sleep ( 100 ) ; i = 1 ; } } catch ( interruptedexception e ) { system . out . println ( "--------------------------" ) ; system . out . println ( "log: erro - thread do rel\xf3gio parou." ) ; system . out . println ( "--------------------------" ) ; e . printstacktrace ( ) ; } }
te	5	private void inspectfields ( object obj , class objclass , vector objectstoinspect , vector arrayobjectstoinspect , boolean recursive ) { if ( objclass . getdeclaredfields ( ) . length >= 1 ) { field [ ] fields = objclass . getdeclaredfields ( ) ; for ( field f : fields ) { f . setaccessible ( true ) ; if ( ! f . gettype ( ) . isprimitive ( ) && ! f . gettype ( ) . isarray ( ) ) { objectstoinspect . addelement ( f ) ; } system . out . println ( "\\tfield: " + f . getname ( ) ) ; system . out . println ( "\\t\\ttype: " + f . gettype ( ) . getname ( ) ) ; int modifier = f . getmodifiers ( ) ; system . out . println ( "\\t\\tmodifiers: " + modifier . tostring ( modifier ) ) ; try { if ( ! f . gettype ( ) . isprimitive ( ) && ! recursive && ! f . gettype ( ) . isarray ( ) ) { system . out . println ( "\\t\\tvalue: " + f . get ( obj ) . hashcode ( ) ) ; } else if ( ! f . gettype ( ) . isprimitive ( ) && recursive && ! f . gettype ( ) . isarray ( ) ) { system . out . println ( "\\t\\tvalue: to be inspected recursively" ) ; } else if ( f . gettype ( ) . isarray ( ) ) { string indentationstring = "\\t\\t" ; system . out . println ( indentationstring + "values: " ) ; handlearray ( f . get ( obj ) , arrayobjectstoinspect , arrayobjectstoinspect , indentationstring , recursive ) ; } else { system . out . println ( "\\t\\tvalue: " + f . get ( obj ) ) ; } } catch ( illegalaccessexception e ) { system . out . println ( "when getting objects from fields: " + e ) ; return ; } } } if ( objclass . getsuperclass ( ) != null ) inspectfields ( obj , objclass . getsuperclass ( ) , objectstoinspect , arrayobjectstoinspect , recursive ) ; }
te	9	private pair < integer , string > parseplayeridname ( string line ) { int parenthesisstart = line . length ( ) - 1 ; int id ; string name ; while ( line . charat ( parenthesisstart ) != '(' && parenthesisstart > 0 ) parenthesisstart -- ; if ( parenthesisstart == 0 ) return null ; string idstring = line . substring ( parenthesisstart + 1 , line . length ( ) - 1 ) ; id = integer . parseint ( idstring . substring ( idstring . indexof ( ':' ) + 1 ) ) ; name = line . substring ( 0 , parenthesisstart ) . trim ( ) ; return new pair < integer , string > ( id , name ) ; }
te	3	private boolean isemail ( string mailaddr ) { string regex = "^[a-za-z][\\\\w\\\\.-]*[a-za-z0-9]@[a-za-z0-9][\\\\w\\\\.-]*[a-za-z0-9]\\\\.[a-za-z][a-za-z\\\\.]*[a-za-z]$" ; pattern p = pattern . compile ( regex ) ; if ( mailaddr . contains ( "|" ) ) { string emails [ ] = mailaddr . split ( "[|]" ) ; for ( string email : emails ) { matcher m = p . matcher ( email ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "email: {0} is not valid" , email ) ; return false ; } } } else { matcher m = p . matcher ( mailaddr ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "email: {0} is not valid" , mailaddr ) ; return false ; } } return true ; }
te	9	@ override public void init ( ) { pvector temp = new pvector ( ) ; temp . set ( v1 ) ; temp . - ( v0 ) ; temp . div ( segs - 1 ) ; for ( int i = 0 ; i < segs ; ++ i ) { if ( i != 0 && i < segs - 1 ) { nodes [ i ] = new pvector ( v0 . x + temp . x * i + getchaos ( chaosseed , chaosmode . random ) , v0 . y + temp . y * i + getchaos ( chaosseed , chaosmode . random ) , v0 . z + temp . z * i + getchaos ( chaosseed , chaosmode . random ) ) ; } else if ( i == 0 ) { nodes [ i ] = v0 ; } else { nodes [ i ] = v1 ; } } }
te	2	public static void main ( string [ ] args ) { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; while ( true ) { system . out . println ( "please enter a command ('help' provides help):" ) ; system . out . print ( ">> " ) ; string cmd ; try { cmd = br . readline ( ) ; switch ( cmd . tolowercase ( ) ) { case "exit" : exit ( ) ; break ; case "help" : printhelp ( ) ; break ; default : processcommandfurther ( cmd ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
te	9	private void algoritmo ( ) { cromosoma mejor ; int max = 1 ; for ( int i = 0 ; i < individuos ; ++ i ) { poblacion [ i ] = new cromosoma ( ) ; poblacion [ i ] . generarcodificacion ( ) ; } calcularaptitud ( ) ; ordenar ( ) ; mejor = mejor ( ) ; ++ ciclo ; while ( ciclo <= 200 && aptitud [ individuos - 1 ] != 2 * dimension + 16 ) { max = 1 ; cromosoma [ ] hijos = new cromosoma [ 50 ] ; for ( int i = 0 ; i < 50 ; ++ i ) { for ( int j = 0 ; j < individuos ; ++ j ) { padres [ j ] = aptitud [ j ] * ( j + 1 ) ; max += aptitud [ j ] * ( j + 1 ) ; progenitor [ j ] = true ; } hijos [ i ] = new cromosoma ( ) ; hijos [ i ] . cruce ( seleccionarpadres ( max ) , seleccionarpadres ( max ) ) ; hijos [ i ] . mutacion ( ) ; } sustitucion ( hijos ) ; calcularaptitud ( ) ; ordenar ( ) ; mejor = mejor ( ) ; ++ ciclo ; } empezar = true ; }
te	4	private static void processrandommode ( int numvertices , double density ) { graph graph = graphgenerator . generategraph ( numvertices , density ) ; system . out . println ( "graph size = " + numvertices + "<litcomma> density = " + density ) ; system . out . println ( ) ; system . out . println ( "running simple scheme" ) ; system . out . println ( "---------------------" ) ; list < edge > generatedmst = mstgenerator . generatemst ( new simpleschememstgenerator ( ) , graph ) ; printtimeandcost ( mstgenerator . getruntime ( ) , generatedmst ) ; system . out . println ( "running f-heap scheme" ) ; system . out . println ( "---------------------" ) ; generatedmst = mstgenerator . generatemst ( new fheapschememstgenerator ( ) , graph ) ; printtimeandcost ( mstgenerator . getruntime ( ) , generatedmst ) ; }
te	10	@ override public boolean oncommand ( commandsender sender , command cmd , string label , string [ ] args ) { if ( cmd . getname ( ) . equalsignorecase ( "rs" ) || cmd . getname ( ) . equalsignorecase ( "realstore" ) ) { if ( ! ( sender instanceof player ) ) { plugin . logmessage ( "realstore interactions may only be used by players!" ) ; return true ; } player player = ( player ) sender ; if ( args . length < 1 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "no realstore command found! please use '/rs help' for proper realstore usage. " ) ; return true ; } string rscommand = args [ 0 ] . tolowercase ( ) ; if ( rscommand . equals ( "help" ) ) { plugin . sendhelpinfo ( player , ( args . length < 2 ? null : args [ 1 ] ) ) ; return true ; } if ( rscommand . equals ( "store" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " do you wish to add or remove a store? use '/rs help store' for more information." ) ; return true ; } string storecommand = args [ 1 ] . tolowercase ( ) ; if ( storecommand . equals ( "add" ) ) { if ( ! plugin . hascoffer ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you have no coffers! use '/rs help coffer' for more information." ) ; return true ; } plugin . sendplayermessage ( player , "click on a chest to create a store." ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player ) , plugin ) ; return true ; } if ( storecommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on the chest store to remove the store." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown store command! use '/rs help store' for more information." ) ; return true ; } if ( rscommand . equals ( "trade" ) ) { if ( ! player . haspermission ( "realstore.trade" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to set up trade goods." ) ; return true ; } plugin . sendplayermessage ( player , "open a store<litcomma> and click on an item for sale with the item and amount you wish to trade for." ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new tradesetlistener ( plugin , player ) , plugin ) ; return true ; } if ( rscommand . equals ( "price" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " no price found. use '/rs help price' for proper realstore price setting usage." ) ; return true ; } if ( ! plugin . hascoffer ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any coffers. create a coffer first. use '/rs help coffer' for more." ) ; return true ; } if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any stores on which to set prices. create a store first. use '/rs help store' for more." ) ; return true ; } try { integer price = integer . parseint ( args [ 1 ] ) ; if ( price <= 0 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " the price must be greater than zero!" ) ; return true ; } if ( args . length > 2 ) { string type = args [ 2 ] ; try { byte data = args . length > 3 ? ( byte ) integer . parseint ( args [ 3 ] ) : ( byte ) 0 ; if ( material . matchmaterial ( type ) == null ) { if ( type . equalsignorecase ( "default" ) ) { plugin . sendplayermessage ( player , "click on the chest store to set the default price to " + price + " gold nuggets" ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price , true ) , plugin ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown material used to set the price. use '/rs help material' to list material names." ) ; return true ; } materialdata material = new materialdata ( material . matchmaterial ( type ) , data ) ; plugin . sendplayermessage ( player , "click on the chest store to set the price of " + material . tostring ( ) + " to a price of " + price + " gold nuggets" ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price , material ) , plugin ) ; return true ; } catch ( numberformatexception e ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " invalid material data. use '/rs help material' to list material names and data values." ) ; return true ; } } plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price ) , plugin ) ; plugin . sendplayermessage ( player , "click on the chest store with an item to set the price of that item to " + price + " gold nuggets." ) ; return true ; } catch ( numberformatexception e ) { if ( args [ 1 ] . equalsignorecase ( "check" ) ) { if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you must first have a store before you can check the prices of items in it." ) ; return true ; } plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricechecklistener ( plugin , player ) , plugin ) ; plugin . sendplayermessage ( player , "open one of your stores to check the prices of items" ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " improper price. use '/rs help price' for proper realstore price setting usage." ) ; return true ; } } if ( rscommand . equals ( "admin" ) ) { if ( ! player . haspermission ( "realstore.admin" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to set admin stores." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " are you creating or removing an admin store?" ) ; return true ; } if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any stores to make admin stores." ) ; return true ; } string admincommand = args [ 1 ] . tolowercase ( ) ; if ( admincommand . equals ( "add" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , false , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a store to add it as an admin store." ) ; return true ; } if ( admincommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , true , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a store to remove it as an admin store." ) ; return true ; } } if ( rscommand . equals ( "coffer" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " do you wish to add or remove a coffer? use '/rs help coffer' for more information." ) ; return true ; } string coffercommand = args [ 1 ] . tolowercase ( ) ; if ( coffercommand . equals ( "add" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new coffermanagementlistener ( plugin , player , false ) , plugin ) ; plugin . sendplayermessage ( player , "click on a chest to add it to your coffers." ) ; return true ; } if ( coffercommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new coffermanagementlistener ( plugin , player , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a chest to remove it from your coffers." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown coffer command! use '/rs help coffer' for more information." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown realstore command! use '/rs help' for more information." ) ; return true ; } return false ; }
te	5	public final vbox createmenu ( ) { flow . play ( ) ; final int i20 = 20 ; vbox menubox = new vbox ( i20 ) ; final menubar menubar = new menubar ( ) ; final menuitem newmenu = menuitembuilder . create ( ) . text ( "new" ) . build ( ) ; newmenu . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { newgame ( ) ; } } ) ; final menuitem mergemenu = menuitembuilder . create ( ) . text ( "merge" ) . build ( ) ; mergemenu . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { newgame ( ) ; mergepuzzlepieces ( gameboard , slidingpuzzlepiece . getpuzzlepiece ( ) ) ; flow . playfromstart ( ) ; } } ) ; final menuitem resolvemenu = menuitembuilder . create ( ) . text ( "resolve" ) . build ( ) ; resolvemenu . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( final actionevent actionevent ) { for ( final slidingpuzzlepiece puzzlepiece : slidingpuzzlepiece . getpuzzlepiece ( ) ) { puzzlepiece . setinactive ( ) ; flow . getkeyframes ( ) . add ( new keyframe ( duration . seconds ( 1 ) , new keyvalue ( puzzlepiece . translatexproperty ( ) , 0 ) , new keyvalue ( puzzlepiece . translateyproperty ( ) , 0 ) ) ) ; } flow . playfromstart ( ) ; } } ) ; menuitem easylevel = menuitembuilder . create ( ) . text ( "easy" ) . build ( ) ; easylevel . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { final int i100 = 100 ; final int i10 = 10 ; slidingpuzzlepiece . setpuzzlesize ( i100 ) ; setmergecount ( ( gameboard . getcols ( ) * gameboard . getrows ( ) ) * i10 ) ; newgame ( ) ; } } ) ; menuitem normallevel = menuitembuilder . create ( ) . text ( "normal" ) . build ( ) ; normallevel . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { final int i75 = 75 ; final int i50 = 50 ; slidingpuzzlepiece . setpuzzlesize ( i75 ) ; setmergecount ( ( gameboard . getcols ( ) * gameboard . getrows ( ) ) * i50 ) ; newgame ( ) ; } } ) ; menuitem hardlevel = menuitembuilder . create ( ) . text ( "hard" ) . build ( ) ; hardlevel . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { final int i50 = 50 ; final int i100 = 100 ; slidingpuzzlepiece . setpuzzlesize ( i50 ) ; setmergecount ( ( gameboard . getcols ( ) * gameboard . getrows ( ) ) * i100 ) ; newgame ( ) ; } } ) ; menuitem harderlevel = menuitembuilder . create ( ) . text ( "harder" ) . build ( ) ; harderlevel . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { final int i25 = 25 ; final int i200 = 200 ; slidingpuzzlepiece . setpuzzlesize ( i25 ) ; setmergecount ( ( gameboard . getcols ( ) * gameboard . getrows ( ) ) * i200 ) ; newgame ( ) ; } } ) ; final menu levelmenu = menubuilder . create ( ) . text ( "gamelevel" ) . items ( easylevel , normallevel , hardlevel , harderlevel ) . build ( ) ; final menuitem highscoremenu = menuitembuilder . create ( ) . text ( "highscore" ) . build ( ) ; highscoremenu . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( final actionevent t ) { stage stage = new stage ( ) ; scene highscore = new scene ( createhighscore ( ) ) ; stage . settitle ( "sliding puzzle - highscores" ) ; stage . sizetoscene ( ) ; stage . setscene ( highscore ) ; stage . tofront ( ) ; stage . show ( ) ; thisstage = stage ; thisstage . centeronscreen ( ) ; } } ) ; menu menugame = menubuilder . create ( ) . text ( "game" ) . items ( newmenu , mergemenu , resolvemenu ) . build ( ) ; menu menuoptions = menubuilder . create ( ) . text ( "options" ) . items ( levelmenu , highscoremenu ) . build ( ) ; menubar . getmenus ( ) . addall ( menugame , menuoptions ) ; menubox . getchildren ( ) . addall ( menubar ) ; menubar . iscache ( ) ; return menubox ; }
te	5	private void setinnertiles ( ) { innertiles = new arraylist < > ( ) ; innertiles . add ( new smalltile ( new rectangle ( bounds . getminx ( ) , bounds . getminy ( ) , bounds . getwidth ( ) / 2 , bounds . getheight ( ) / 2 ) ) ) ; innertiles . add ( new smalltile ( new rectangle ( bounds . getminx ( ) + ( bounds . getwidth ( ) / 2 ) , bounds . getminy ( ) , bounds . getwidth ( ) / 2 , bounds . getheight ( ) / 2 ) ) ) ; innertiles . add ( new smalltile ( new rectangle ( bounds . getminx ( ) , bounds . getminy ( ) + ( bounds . getheight ( ) / 2 ) , bounds . getwidth ( ) / 2 , bounds . getheight ( ) / 2 ) ) ) ; innertiles . add ( new smalltile ( new rectangle ( bounds . getminx ( ) + ( bounds . getwidth ( ) / 2 ) , bounds . getminy ( ) + ( bounds . getheight ( ) / 2 ) , bounds . getwidth ( ) / 2 , bounds . getheight ( ) / 2 ) ) ) ; }
te	2	@ override public set < string > xmlextract ( page page ) throws saxexception , ioexception { try { htmlparser . setencoding ( "utf-8" ) ; } catch ( parserexception e ) { e . printstacktrace ( ) ; system . out . println ( "set encoding error!!" ) ; } system . out . println ( page . tostring ( ) ) ; pattern ptn = pattern . compile ( "<html[\\\\s\\\\s]*>[\\\\s\\\\s]*</html>" ) ; matcher m = ptn . matcher ( page . tostring ( ) ) ; m . find ( ) ; string str = m . group ( ) ; try { htmlparser . setinputhtml ( str ) ; } catch ( parserexception e ) { e . printstacktrace ( ) ; system . out . println ( "set input html error!!" ) ; } nodefilter filter = new tagnamefilter ( "a" ) ; nodelist nodelist = null ; try { nodelist = htmlparser . extractallnodesthatmatch ( filter ) ; } catch ( parserexception e ) { e . printstacktrace ( ) ; } if ( nodelist == null ) { system . out . println ( "nodelist is null!!" ) ; return null ; } int length = nodelist . size ( ) ; system . out . println ( "%%%%%%%%%%%%%extraction results%%%%%%%%%%%%%%%%" ) ; set < string > uriset = new hashset < string > ( ) ; system . out . println ( "adding!!" ) ; for ( int i = 0 ; i < length ; i ++ ) { system . out . println ( nodelist . elementat ( i ) . tohtml ( ) ) ; linktag n = ( linktag ) nodelist . elementat ( i ) ; uriset . add ( n . getattribute ( "href" ) ) ; if ( n . getattribute ( "href" ) == "" ) { continue ; } system . out . println ( "href is:" + n . getattribute ( "href" ) ) ; } system . out . println ( "added!!" ) ; return uriset ; }
te	9	private static string createregexforreplace ( string tofind ) { char [ ] find = tofind . tochararray ( ) ; stringbuilder regexstring = new stringbuilder ( ) ; for ( char f : find ) { int d = f ; if ( ( d >= 65 && d <= 90 ) || ( d >= 97 && d <= 122 ) ) { regexstring . append ( "[" ) ; regexstring . append ( character . tostring ( ( char ) d ) ) ; int temp = d ; if ( character . islowercase ( f ) ) { temp = d - 32 ; } else { temp = d + 32 ; } regexstring . append ( character . tostring ( ( char ) temp ) ) ; regexstring . append ( "]" ) ; } else if ( d == 32 ) { regexstring . append ( "[\\\\s]" ) ; } else { regexstring . append ( "[" ) ; regexstring . append ( f ) ; regexstring . append ( "]" ) ; } } return regexstring . tostring ( ) ; }
te	10	private void read ( ) { if ( cc != - 1 ) { if ( isnl ( ) ) { ++ lno ; cno = 0 ; } try { if ( cc1 != - 1 ) { cc = cc1 ; cc1 = - 1 ; } else { cc = in . read ( ) ; } switch ( cc ) { case '^' : { cc1 = in . read ( ) ; if ( cc1 == '^' ) { cc1 = - 1 ; int cc2 = in . read ( ) ; if ( ( cc = hexval ( cc2 ) ) == - 1 ) { cc = ( cc2 + 64 ) & 127 ; } else { cc1 = in . read ( ) ; if ( ( cc2 = hexval ( cc1 ) ) != - 1 ) { cc1 = - 1 ; cc *= 16 ; cc += cc2 ; } } } cc = codelist [ cc ] ; } break ; case '\\\\' : { cc1 = in . read ( ) ; switch ( cc1 ) { case '^' : case '\\'' : case '`' : case '"' : case '~' : case '=' : case '.' : case 'b' : case 'c' : case 'd' : case 'h' : case 'k' : case 'r' : case 'u' : case 'v' : case 'a' : case 'i' : case 'l' : case 'o' : case 's' : { int key = cc1 << 8 ; int sep = - 1 ; int cc0 = in . read ( ) ; if ( ( cc0 == ' ' && ! ( cc1 == 'l' || cc1 == 'o' || cc1 == 'i' ) ) || cc0 == '{' || cc0 == '\\\\' ) { sep = cc0 ; cc0 = in . read ( ) ; if ( sep == '{' && cc0 == '}' ) sep = - 1 ; cc0 = ' ' ; } cc1 = - 1 ; key += cc0 ; if ( sep == '{' ) in . read ( ) ; object chrval = acctab . get ( new integer ( key ) ) ; cc = chrval != null ? ( ( integer ) chrval ) . intvalue ( ) : cc0 ; } break ; default : break ; } } break ; default : if ( cc != - 1 ) cc = codelist [ cc ] ; break ; } } catch ( java . io . ioexception e ) { error ( e . tostring ( ) ) ; cc = - 1 ; } cno ++ ; } }
te	8	final static public string directorytourl ( string dir ) { string urlpart ; if ( dir . startswith ( mgr . cache_dir ) ) { dir = dir . substring ( mgr . cache_dir . length ( ) ) ; } if ( dir . length ( ) == 0 ) return null ; dir = dir . substring ( 1 ) ; int i ; i = dir . indexof ( file . separatorchar , 0 ) ; if ( i != - 1 ) { dir = dir . substring ( i + 1 ) ; i = dir . indexof ( file . separatorchar , 0 ) ; if ( i != - 1 ) dir = dir . substring ( i + 1 ) ; else return null ; } else return null ; i = dir . indexof ( file . separatorchar ) ; if ( i == - 1 ) return null ; if ( file . separatorchar != '/' ) dir = dir . replace ( file . separatorchar , '/' ) ; urlpart = dir . substring ( i ) ; string hn = dir . substring ( 0 , i ) ; string proto = null ; string port = null ; i = hn . indexof ( '^' ) ; if ( i > - 1 ) { proto = hn . substring ( i + 1 ) ; hn = hn . substring ( 0 , i ) ; } i = hn . indexof ( '_' ) ; if ( i > - 1 ) { port = hn . substring ( i + 1 ) ; hn = hn . substring ( 0 , i ) ; } return ( proto == null ? "http" : proto ) + "://" + hn + ( port == null ? "" : ":" + port ) + urlpart ; }
te	10	public void postprocessing ( ) { double area ; vertex a , b ; for ( int i = 0 ; i < edgecount ; i ++ ) { area = 0 ; boolean faceflag = true ; edge rootedge , lastedge , currentedge , twinedge , nextedge ; rootedge = graph . edgelist . get ( i ) ; if ( rootedge . visited ) continue ; rootedge . visited = true ; if ( rootedge . nextedgeid != - 1 ) { lastedge = rootedge ; currentedge = graph . edgelist . get ( rootedge . nextedgeid ) ; a = graph . vertexlist . get ( lastedge . startid ) ; b = graph . vertexlist . get ( currentedge . startid ) ; area += ( b . p . x - a . p . x ) * ( b . p . y + a . p . y ) ; while ( rootedge != currentedge && faceflag ) { if ( currentedge . visited == true ) { faceflag = false ; break ; } if ( currentedge . nextedgeid == - 1 ) { twinedge = graph . edgelist . get ( currentedge . twinedgeid ) ; nextedge = graph . edgelist . get ( twinedge . nextedgeid ) ; lastedge . nextedgeid = nextedge . id ; nextedge . previousedgeid = lastedge . id ; currentedge = nextedge ; } else { lastedge = currentedge ; currentedge = graph . edgelist . get ( currentedge . nextedgeid ) ; a = graph . vertexlist . get ( lastedge . startid ) ; b = graph . vertexlist . get ( currentedge . startid ) ; area += ( b . p . x - a . p . x ) * ( b . p . y + a . p . y ) ; } if ( currentedge . id == rootedge . twinedgeid ) { faceflag = false ; } } } else { lastedge = graph . edgelist . get ( rootedge . previousedgeid ) ; twinedge = graph . edgelist . get ( rootedge . twinedgeid ) ; nextedge = graph . edgelist . get ( twinedge . nextedgeid ) ; lastedge . nextedgeid = nextedge . id ; nextedge . previousedgeid = lastedge . id ; twinedge . visited = true ; faceflag = false ; } if ( faceflag ) { if ( area > 0 ) { face f = new face ( ) ; f . id = facecount ++ ; f . edgeid = rootedge . id ; graph . facelist . put ( f . id , f ) ; } } } system . out . println ( "total faces = " + facecount ) ; }
te	5	public static void main ( string [ ] args ) { if ( args . length <= 0 ) { throw new illegalargumentexception ( "directory with source files must be set" ) ; } file file = new file ( args [ 0 ] ) ; if ( ! file . exists ( ) ) { try { throw new illegalargumentexception ( "file not found in path '" + file . getcanonicalpath ( ) + "'" ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( e ) ; } } classanalyser analyser = new simpleanalyser ( ) ; analyser . analyse ( new directoryanalysiscontext ( file ) ) ; for ( classdescription classdescription : analyser . classes ( ) ) { system . out . println ( "class " + classdescription ) ; } system . out . println ( "total number of methods: " + analyser . totalnumberofmethods ( ) ) ; }
te	8	public final static void read_http_headers ( datainputstream in , list < string > headers ) throws ioexception { string oldheader = null , req ; while ( true ) { req = in . readline ( ) ; if ( req == null ) { if ( trace_inkeepalive ) { system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] = eof when reading request's headers." ) ; throw new eofexception ( "eof when reading request's headers" ) ; } } if ( req . length ( ) == 0 ) { if ( oldheader != null ) headers . add ( oldheader ) ; break ; } else { char c = req . charat ( 0 ) ; if ( c == ' ' || c == '\\t' ) { if ( oldheader != null ) oldheader += req ; } else { if ( oldheader != null ) headers . add ( oldheader ) ; oldheader = req ; } } } }
te	10	void handlezlibrect ( int x , int y , int w , int h ) throws exception { int nbytes = rfb . readu32 ( ) ; if ( zlibbuf == null || zlibbuflen < nbytes ) { zlibbuflen = nbytes * 2 ; zlibbuf = new byte [ zlibbuflen ] ; } rfb . readfully ( zlibbuf , 0 , nbytes ) ; if ( zlibinflater == null ) { zlibinflater = new inflater ( ) ; } zlibinflater . setinput ( zlibbuf , 0 , nbytes ) ; if ( bytespixel == 1 ) { for ( int dy = y ; dy < y + h ; dy ++ ) { zlibinflater . inflate ( pixels8 , dy * rfb . framebufferwidth + x , w ) ; } } else { byte [ ] buf = new byte [ w * 4 ] ; int i , offset ; for ( int dy = y ; dy < y + h ; dy ++ ) { zlibinflater . inflate ( buf ) ; offset = dy * rfb . framebufferwidth + x ; for ( i = 0 ; i < w ; i ++ ) { pixels24 [ offset + i ] = ( buf [ i * 4 + 2 ] & 0xff ) << 16 | ( buf [ i * 4 + 1 ] & 0xff ) << 8 | ( buf [ i * 4 ] & 0xff ) ; } } } handleupdatedpixels ( x , y , w , h ) ; schedulerepaint ( x , y , w , h ) ; }
te	8	final private boolean checkquickabort ( int readb ) { if ( ! cacheable ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load aborted (non-cacheable): " + url ) ; return true ; } if ( qa_minlen < 0 ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load continued (quick abort disabled): " + url ) ; return false ; } if ( ctsize != - 1 ) { if ( readb > ctsize ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load aborted (loaded more data than expected): " + url ) ; return true ; } if ( ( ctsize - readb ) < qa_minlen ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load continued (less than minlen bytes left): " + url ) ; return false ; } if ( ( ctsize - readb ) > qa_maxlen ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load aborted (more than max bytes left): " + url ) ; return true ; } if ( ( float ) readb / ctsize > qa_percent ) { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load continued (percent ratio is good): " + url ) ; return false ; } else { if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load aborted (percent ratio is bad): " + url ) ; return true ; } } if ( trace_abort == true ) system . out . println ( "[trace " + thread . currentthread ( ) . getname ( ) + "] # load aborted (unspecified size in reply): " + url ) ; return true ; }
te	4	@ override public list < edge > generatemst ( graph graph ) { list < integer > nodesinmst = new arraylist < integer > ( ) ; int startmstat = graph . selectarandomnode ( ) ; nodesinmst . add ( startmstat ) ; edge [ ] feeleredges = new edge [ graph . getnumvertices ( ) ] ; for ( int i = 0 ; i < feeleredges . length ; i ++ ) { feeleredges [ i ] = new edge ( 0 , 0 , integer . max_value , false ) ; } feeleredges [ startmstat ] = new edge ( startmstat , startmstat , 0 , true ) ; list < edge > finalmstedges = new arraylist < edge > ( ) ; buildmstnodebynode ( graph , startmstat , nodesinmst , finalmstedges , feeleredges ) ; return finalmstedges ; }
te	4	public boolean isvaliditem ( entitytype et , material mat ) { if ( et == null || mat == null ) { return false ; } try { if ( items_required . containskey ( et . name ( ) ) ) { if ( items_required . get ( et . name ( ) ) . contains ( "any" ) ) { return true ; } if ( items_required . get ( et . name ( ) ) . contains ( string . valueof ( mat . getid ( ) ) ) ) { return true ; } else { for ( string s : items_required . get ( et . name ( ) ) ) { if ( s . touppercase ( ) . equals ( mat . tostring ( ) ) ) { return true ; } } } } } catch ( exception ex ) { logdebug ( "isvaliditem: catching exception: " + ex . getmessage ( ) + " [: " + et . name ( ) + "] [" + mat . name ( ) + "] [" + items_required . size ( ) + "]" ) ; return false ; } return false ; }
te	1	public void sendrespond ( ) { try { out . writeobject ( "sender id" ) ; long friendid = ( long ) in . readobject ( ) ; out . writeobject ( "respond" ) ; string status = ( string ) in . readobject ( ) ; if ( status . equals ( "admit" ) ) db . addfriend ( user . getid ( ) , friendid ) ; else if ( ! status . equals ( "refuse" ) ) return ; int res = db . setrespond ( friendid , user . getid ( ) , status ) ; out . writeobject ( res ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }
te	3	public void samplequerymenu ( ) { boolean wanttoquit = false ; while ( ! wanttoquit ) { system . out . println ( "this is the sample query menu." ) ; system . out . println ( "1. list titles of all projects<litcomma> and the number of commits they have done on them." ) ; system . out . println ( "2. list emails of all contributors who are working on more than one project." ) ; system . out . println ( "3. list all contributors assigned to work on bugs<litcomma> and number of bugs assigned to them." ) ; system . out . println ( "4. find the most recent post(s) of all the projects." ) ; system . out . println ( "5. find the name and phone numbers of all managers of ongoing projects." ) ; system . out . println ( "6. list the emails of all contributors to projects that do not have managers." ) ; system . out . println ( "7. return to main menu" ) ; int option = userinput . nextint ( ) ; switch ( option ) { case 1 : query1 ( ) ; break ; case 2 : query2 ( ) ; break ; case 3 : query3 ( ) ; break ; case 4 : query4 ( ) ; break ; case 5 : query5 ( ) ; break ; case 6 : query6 ( ) ; break ; case 7 : wanttoquit = true ; default : system . out . println ( "invalid input. try again." ) ; } } }
te	9	public static void main ( string [ ] args ) throws ioexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; int cases = integer . parseint ( br . readline ( ) ) ; string dummy = br . readline ( ) ; stringbuilder output = new stringbuilder ( ) ; while ( cases -- > 0 ) { hashmap < string , integer > dictionarymap = new hashmap ( ) ; arraylist < string > wordlist = new arraylist ( ) ; arraylist < integer > wordlenlist = new arraylist ( ) ; string word ; int id = 0 ; while ( ! ( word = br . readline ( ) ) . equals ( "*" ) ) { dictionarymap . put ( word , id ++ ) ; wordlist . add ( word ) ; wordlenlist . add ( word . length ( ) ) ; } string line = "" ; boolean graph [ ] [ ] = new boolean [ id ] [ id ] ; for ( int i = 0 ; i < id ; i ++ ) { for ( int j = i + 1 ; j < id ; j ++ ) { if ( wordlenlist . get ( i ) == wordlenlist . get ( j ) ) { if ( isonedisntace ( wordlist . get ( i ) , wordlist . get ( j ) , wordlenlist . get ( j ) ) ) { graph [ i ] [ j ] = true ; graph [ j ] [ i ] = true ; } } } } while ( ( line = br . readline ( ) ) != null ) { if ( line . equals ( "" ) ) { break ; } string [ ] sourcedestination = line . split ( " " ) ; int distance = bfs ( graph , dictionarymap . get ( sourcedestination [ 0 ] ) , dictionarymap . get ( sourcedestination [ 1 ] ) ) ; output . append ( sourcedestination [ 0 ] + " " + sourcedestination [ 1 ] + " " + distance + "\\n" ) ; } output . append ( "\\n" ) ; } system . out . print ( output . substring ( 0 , output . length ( ) - 1 ) ) ; }
te	9	public static void sortmeth ( arraylist < arraylist < double > > arr ) { system . out . println ( ) ; for ( int i = 0 ; i < 10 && i < arr . size ( ) ; i ++ ) { arraylist < double > d = arr . get ( i ) ; d . set ( i , - 100.0 ) ; double max = collections . max ( d ) ; int index = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max ) { d . set ( j , 0.0 ) ; index = j ; break ; } } double max2 = collections . max ( d ) ; int index1 = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max2 && j != index ) { d . set ( j , 0.0 ) ; index1 = j ; break ; } } double max3 = collections . max ( d ) ; int index2 = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max3 && j != index1 && j != index2 ) { d . set ( j , 0.0 ) ; index2 = j ; break ; } } system . out . println ( "document " + i + " - document " + index + ": " + max + " document " + index1 + ": " + max2 + " document " + index2 + ": " + max3 ) ; } }
te	7	public hashmap < string , list < string > > loadfiles4model ( string descriptionsfolder ) { file descriptions = new file ( descriptionsfolder ) ; system . out . println ( "loading files..." ) ; list < string > niod_lines = new arraylist < string > ( ) ; list < string > wl_lines = new arraylist < string > ( ) ; list < string > yv_lines = new arraylist < string > ( ) ; list < string > jmp_lines = new arraylist < string > ( ) ; list < string > ushmm_lines = new arraylist < string > ( ) ; list < string > bundesarchiv_lines = new arraylist < string > ( ) ; list < string > its_lines = new arraylist < string > ( ) ; list < string > cegesoma_lines = new arraylist < string > ( ) ; list < string > ifz_lines = new arraylist < string > ( ) ; pattern textfile = pattern . compile ( ".*txt" ) ; list < string > filelist = new arraylist < string > ( ) ; hashmap < string , list < string > > filescontent = new hashmap < string , list < string > > ( ) ; for ( final file fileentry : descriptions . listfiles ( ) ) { matcher matchertext = textfile . matcher ( fileentry . tostring ( ) ) ; if ( matchertext . find ( ) ) { filelist . add ( fileentry . getname ( ) ) ; } } for ( int i = 0 ; i < filelist . size ( ) ; i ++ ) { string currentline ; list < string > linesoffile = new arraylist < string > ( ) ; bufferedreader br = null ; try { br = new bufferedreader ( new filereader ( descriptionsfolder + filelist . get ( i ) ) ) ; while ( ( currentline = br . readline ( ) ) != null ) { linesoffile . add ( currentline ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { try { br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } if ( filelist . get ( i ) . matches ( "niod_.*" ) ) { niod_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "wiener_.*" ) ) { wl_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "yadvashem_.*" ) ) { yv_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "jewishmuseumprag_.*" ) ) { jmp_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "bundesarchiv_.*" ) ) { bundesarchiv_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "ushmm_.*" ) ) { ushmm_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "its_.*" ) ) { its_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "cegesoma_.*" ) ) { cegesoma_lines . addall ( linesoffile ) ; } if ( filelist . get ( i ) . matches ( "ifz_.*" ) ) { ifz_lines . addall ( linesoffile ) ; } } filescontent . put ( "niod" , niod_lines ) ; filescontent . put ( "wiener" , wl_lines ) ; filescontent . put ( "yadvashem" , yv_lines ) ; filescontent . put ( "jewishmuseumprag" , jmp_lines ) ; filescontent . put ( "bundesarchiv" , bundesarchiv_lines ) ; filescontent . put ( "ushmm" , ushmm_lines ) ; filescontent . put ( "its" , its_lines ) ; filescontent . put ( "cegesoma" , cegesoma_lines ) ; filescontent . put ( "ifz" , ifz_lines ) ; system . out . println ( "niod lines: " + niod_lines . size ( ) ) ; system . out . println ( "wl lines: " + wl_lines . size ( ) ) ; system . out . println ( "yv lines: " + yv_lines . size ( ) ) ; system . out . println ( "jmp lines: " + jmp_lines . size ( ) ) ; system . out . println ( "ba lines: " + bundesarchiv_lines . size ( ) ) ; system . out . println ( "ushmm lines: " + ushmm_lines . size ( ) ) ; system . out . println ( "its lines: " + its_lines . size ( ) ) ; system . out . println ( "cegesoma lines: " + cegesoma_lines . size ( ) ) ; system . out . println ( "ifz lines: " + ifz_lines . size ( ) ) ; return filescontent ; }
te	9	private void findtopknearestfor ( int movie ) { int j = 0 ; if ( activeusername == 400 && movie == 36 ) { system . out . println ( "" ) ; } for ( int i = totalusers - 1 ; j < k && i >= 0 ; i -- ) { int user = users [ i ] . name ; if ( ratings [ user ] [ movie ] != 0 ) { topk [ j ] = users [ i ] . name ; j ++ ; } } for ( ; j < k ; j ++ ) { topk [ j ] = - 1 ; } }
te	6	@ override public void insertupdate ( documentevent e ) { boolean havenotencounteredinvis = true ; char lastchar ; string fieldtext = null ; document doc = ( document ) e . getdocument ( ) ; try { fieldtext = doc . gettext ( 0 , doc . getlength ( ) ) ; } catch ( badlocationexception e1 ) { e1 . printstacktrace ( ) ; } if ( fieldtext . length ( ) > 1 ) { lastchar = fieldtext . charat ( fieldtext . length ( ) - 1 ) ; if ( lastchar == '\\n' ) { int x = fieldtext . length ( ) - 2 ; string enteredtext = "" ; char currentchar ; while ( havenotencounteredinvis ) { currentchar = fieldtext . charat ( x ) ; if ( currentchar == '\\n' ) { setenteredtext ( enteredtext ) ; havenotencounteredinvis = false ; display . setcaretposition ( display . getdocument ( ) . getlength ( ) ) ; } else if ( x == 0 ) { enteredtext = currentchar + enteredtext ; setenteredtext ( enteredtext ) ; havenotencounteredinvis = false ; } else { enteredtext = currentchar + enteredtext ; } x -- ; } } } }
te	2	public arraylist < string [ ] > getactorsbymovie ( string movie , int year ) { arraylist < string [ ] > actors = new arraylist < string [ ] > ( ) ; try { int movieid = getmovieid ( movie , year ) ; resultset rs = statement . executequery ( "select actor from roles where movie = " + movieid ) ; while ( rs . next ( ) ) actors . add ( getactorname ( rs . getint ( 1 ) ) ) ; } catch ( sqlexception e ) { system . err . println ( e ) ; system . exit ( 1 ) ; } return actors ; }
te	9	public int estimatedcosttosolution ( ) { int total = 0 ; int xpos = this . getcars ( ) . get ( 0 ) . getendpoint ( ) . x ; int ypos = this . getcars ( ) . get ( 0 ) . getendpoint ( ) . y ; total += board . boardsize - 1 - xpos ; for ( int i = 1 ; i < total + 1 ; i ++ ) { car c = getposition ( xpos + i , ypos ) ; if ( c != null ) { if ( c . getlenght ( ) == 2 ) { total += 1 ; } else if ( c . getlenght ( ) == 3 ) { if ( c . getendpoint ( ) . y == ypos || c . getstartpoint ( ) . y == ypos ) { total += 1 ; } else { total += 2 ; } } } } return total ; }
te	3	public int send ( map < string , string > record ) { string [ ] emails = record . get ( "email" ) . split ( "[|]" ) ; string [ ] telnos = record . get ( "telno" ) . split ( "[|]" ) ; string [ ] pernrs = record . get ( "pernr" ) . split ( "[|]" ) ; map < string , string > recieversmap = service . getrecievers ( emails , telnos , pernrs ) ; telmap = new hashmap < string , string > ( ) ; for ( string tel : telnos ) { telmap . put ( tel , tel ) ; } for ( string key : recieversmap . keyset ( ) ) { telmap . put ( recieversmap . get ( key ) , recieversmap . get ( key ) ) ; } alltelno = new stringbuffer ( ) ; for ( string tel : telmap . keyset ( ) ) { alltelno . append ( tel ) ; alltelno . append ( unsconsts . mark_comma ) ; } alltelno . deletecharat ( alltelno . length ( ) - 1 ) ; map < string , string > smssendinfo = service . getsmssendinfo ( record ) ; string sn = smssendinfo . get ( "sn" ) ; string orgaddr = smssendinfo . get ( "orgaddr" ) ; string content = smssendinfo . get ( "content" ) ; string telno = alltelno . tostring ( ) ; if ( "" . equals ( telno ) || telno == null ) { logger . log ( level . info , "telephone can not be empty<litcomma> message is rejected!" ) ; return 0 ; } if ( "n" . equals ( service . getswitchonflg ( record . get ( "sys" ) ) ) ) { logger . log ( level . info , ">>> switch off!!!" ) ; return 0 ; } try { sendmessageone ( sn , orgaddr , telno , content ) ; } catch ( malformedurlexception e ) { return 0 ; } catch ( ioexception e ) { return 0 ; } return 1 ; }
te	5	public void take ( command command ) { if ( ! command . hassecondword ( ) ) { system . out . println ( "take what?" ) ; return ; } string id = command . getsecondword ( ) ; item item = currentroom . getitem ( id ) ; if ( item != null ) { if ( item . canbetaken ( ) ) { if ( item . getweight ( ) + gettotalweightitems ( ) <= cargamaxima ) { system . out . println ( "you add a new item to your bag" ) ; mochila . add ( item ) ; currentroom . removeitem ( id ) ; } else { system . out . println ( "no hay espacio para este objeto" ) ; } } else { system . out . println ( "el objeto no se puede coger" ) ; } } else { system . out . println ( "you don't select a item" ) ; } }
te	2	public sobre ( ) { system . out . println ( "log: wtf - o qu\xea esse cara quer lendo essa janela?" ) ; framesobre = new jframe ( ) ; framesobre . setbounds ( 100 , 100 , 450 , 300 ) ; framesobre . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; framesobre . getcontentpane ( ) . setlayout ( null ) ; framesobre . setvisible ( true ) ; framesobre . setlocationrelativeto ( null ) ; framesobre . settitle ( "sobre" ) ; jlabel lblsuperestacionamentov = new jlabel ( appname + " v" + versao ) ; lblsuperestacionamentov . setfont ( new font ( "calibri" , font . italic , 18 ) ) ; lblsuperestacionamentov . setbounds ( 115 , 11 , 230 , 35 ) ; framesobre . getcontentpane ( ) . add ( lblsuperestacionamentov ) ; jlabel lblpoweredbyjava = new jlabel ( "powered by java 8" ) ; lblpoweredbyjava . setbounds ( 325 , 240 , 107 , 14 ) ; framesobre . getcontentpane ( ) . add ( lblpoweredbyjava ) ; jlabel lbldesenvolvimentoequipe = new jlabel ( "<html>" + "equipe de desenvolvimento (orange mayhem software laboratories)<br><br>" + "pedro carneiro (developer)<br>" + "wilton leal (graphic ux design)</br>" + "<br><br>" + "componentes:<br>rob camick (java tips weblog): <a href=\\"https://tips4java.wordpress.com/2009/05/23/text-component-line-number/\\">text component line number</a>" + "</html>" ) ; lbldesenvolvimentoequipe . setbounds ( 10 , 47 , 414 , 159 ) ; framesobre . getcontentpane ( ) . add ( lbldesenvolvimentoequipe ) ; jbutton btnfecharesc = new jbutton ( "fechar (esc)" ) ; btnfecharesc . setbounds ( 10 , 232 , 113 , 23 ) ; framesobre . getcontentpane ( ) . add ( btnfecharesc ) ; btnfecharesc . addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { } @ override public void keyreleased ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_escape ) { framesobre . dispose ( ) ; gui . frame . requestfocus ( ) ; } } } ) ; btnfecharesc . addactionlistener ( e -> { framesobre . dispose ( ) ; gui . frame . requestfocus ( ) ; } ) ; }
te	5	private void inspectconstructors ( object obj , class objclass ) { constructor [ ] constructors = objclass . getconstructors ( ) ; int i = 1 ; if ( constructors . length < 1 ) return ; for ( constructor currentconstructor : constructors ) { currentconstructor . setaccessible ( true ) ; system . out . println ( "\\tinspecting constructor " + i ++ + ":" ) ; class [ ] parametertypes = currentconstructor . getparametertypes ( ) ; if ( parametertypes . length == 0 ) { system . out . println ( "\\t\\tno parameters" ) ; } else { system . out . println ( "\\t\\tparameter types:" ) ; for ( class parameter : parametertypes ) { system . out . println ( "\\t\\t\\t" + parameter . getsimplename ( ) ) ; } } int modifier = currentconstructor . getmodifiers ( ) ; system . out . println ( "\\t\\tmodifiers: " + modifier . tostring ( modifier ) ) ; } }
te	2	public static void main ( string [ ] args ) throws unknownhostexception , ioexception { final httpget example = new httpget ( ) ; boolean quit = false ; final inputstream inputstream = system . in ; final inputstreamreader inputstreamreader = new inputstreamreader ( inputstream ) ; final bufferedreader in = new bufferedreader ( inputstreamreader ) ; while ( ! quit ) { system . out . println ( "input host: " ) ; string host = in . readline ( ) ; system . out . println ( "input path: " ) ; string path = in . readline ( ) ; quit = example . createrequest ( host , http_method , path ) ; } }
te	6	@ override public hit intersect ( ray ray ) { vector x0 = ray . getorigin ( ) . - ( center ) ; vector d = ray . getnormalizeddirection ( ) ; float t1 = 0.0f ; float t2 = 0.0f ; if ( ( x0 . . ( d ) * x0 . . ( d ) ) * ( ( x0 . . ( x0 ) ) - ( radius * radius ) ) < 0 ) { return null ; } if ( ( x0 . . ( d ) * x0 . . ( d ) ) * ( ( x0 . . ( x0 ) ) - ( radius * radius ) ) == 0 ) { t1 = - ( x0 . . ( d ) ) ; return new hit ( ray . getpoint ( t1 ) , color ) ; } else { t1 = ( float ) ( - ( x0 . . ( d ) ) + math . sqrt ( ( x0 . . ( d ) * x0 . . ( d ) ) * ( ( x0 . . ( x0 ) ) - ( radius * radius ) ) ) ) ; t2 = ( float ) ( - ( x0 . . ( d ) ) - math . sqrt ( ( x0 . . ( d ) * x0 . . ( d ) ) * ( ( x0 . . ( x0 ) ) - ( radius * radius ) ) ) ) ; if ( t1 < t2 ) { return new hit ( ray . getpoint ( t1 ) , color ) ; } else { return new hit ( ray . getpoint ( t2 ) , color ) ; } } }
te	9	public static void update ( ) { int size = pressedlist . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { pressed [ pressedlist . get ( i ) ] = false ; } size = releasedlist . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { released [ releasedlist . get ( i ) ] = false ; } while ( keyboard . next ( ) ) { laststate = keyboard . geteventkeystate ( ) ; lastchar = keyboard . geteventcharacter ( ) ; lastkey = keyboard . geteventkey ( ) ; keychars [ lastkey ] = lastchar ; try { int i = lastkey ; boolean d = keyboard . iskeydown ( i ) ; if ( d ) { if ( ! down [ i ] ) { pressed [ i ] = true ; pressedlist . add ( i ) ; } } else { if ( down [ i ] ) { released [ i ] = true ; releasedlist . add ( i ) ; } } down [ i ] = d ; } catch ( arrayindexoutofboundsexception e ) { } } for ( int i = 0 ; i < down . length ; i ++ ) { if ( down [ i ] ) { time [ i ] += 1 ; if ( ( time [ i ] > 30 ) && ( ( time [ i ] % 3 ) == 0 ) && doesrepeat [ i ] && inputmodetext ) { pressed [ i ] = true ; pressedlist . add ( i ) ; } } else { time [ i ] = 0 ; } } }
te	8	private node procedurecall ( ) throws parserexception { enterrule ( nonterminal . procedure_call ) ; expect ( tokenkind . : ) ; expect ( tokenkind . : ) ; token functtok = expectretrieve ( tokenkind . ident ) ; symbol decsym = symboltable . inparentscopes ( functtok . getlexeme ( ) , "procedure" ) ; if ( decsym == null ) printerror ( errortype . undefined_error , functtok ) ; expect ( tokenkind . l_paren ) ; if ( have ( nonterminal . parameters ) ) { list < node > types = parameters ( functtok ) ; if ( decsym . params == null && types . size ( ) > 0 ) prntmismatchinvcall ( functtok , decsym , types ) ; if ( decsym . params != null ) { if ( types . size ( ) != decsym . params . size ( ) ) prntartyinvcall ( functtok , decsym , types ) ; for ( int i = 0 ; i < decsym . params . size ( ) ; i ++ ) { if ( ! decsym . params . get ( i ) . equals ( types . get ( i ) . type ) ) prntmismatchinvcall ( functtok , decsym , types ) ; } } } expect ( tokenkind . r_paren ) ; exitrule ( nonterminal . procedure_call ) ; return new node ( functtok , decsym . gettype ( ) ) ; }
te	10	private void writengramtodisk ( ) throws ioexception { log . debug ( "writing index ngram to disk" ) ; final long start = system . currenttimemillis ( ) ; list < stringbuilder > buckets = new arraylist < > ( numofbucket ) ; for ( int i = 0 ; i < numofbucket ; i ++ ) { buckets . add ( new stringbuilder ( ) ) ; } stream . of ( ngrammap ) . map ( map :: entryset ) . flatmap ( collection :: stream ) . foreach ( entry -> { int bucket = entry . getkey ( ) . hashcode ( ) % numofbucket ; stringbuilder sb = buckets . get ( bucket ) ; sb . append ( entry . getkey ( ) ) ; sb . append ( "=" ) ; priorityqueue < integer > pq = entry . getvalue ( ) ; if ( ! pq . isempty ( ) ) { sb . append ( pq . poll ( ) ) ; } while ( ! pq . isempty ( ) ) { sb . append ( "<litcomma>" ) ; sb . append ( pq . poll ( ) ) ; } sb . append ( "\\n" ) ; } ) ; for ( int i = 0 ; i < numofbucket ; i ++ ) { files . write ( paths . get ( n_gram_path + i ) , buckets . get ( i ) . tostring ( ) . getbytes ( ) ) ; } log . debug ( "completed writing index ngram to disk. time spent (msec) : " + ( ( system . currenttimemillis ( ) - start ) ) ) ; }
te	1	public void createfile ( string enternoofcs ) { int userinput = integer . parseint ( enternoofcs ) ; string targetdirectory = system . getproperty ( "user.dir" ) ; file directory = new file ( targetdirectory ) ; file [ ] files = directory . listfiles ( ) ; int filesize = files . length ; int correct = userinput * filesize ; int count = 0 ; for ( file f : files ) { if ( ! f . getname ( ) . contains ( "output" ) ) continue ; count ++ ; if ( f . isfile ( ) ) { bufferedreader buffer = null ; try { buffer = new bufferedreader ( new filereader ( f ) ) ; string line = buffer . readline ( ) + "<litcomma>" ; string [ ] array = line . split ( "<litcomma>" ) ; for ( string values : array ) { list . add ( integer . parseint ( values ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } } correct = userinput * count ; finallist . addall ( list ) ; finallist . addall ( listfile1 ) ; collections . sort ( finallist ) ; duplicateset = new hashset < integer > ( finallist ) ; int numduplicates = finallist . size ( ) - duplicateset . size ( ) ; if ( numduplicates != 0 ) { system . out . println ( "duplicates are there" ) ; } int size = finallist . size ( ) ; system . out . println ( "size : " + size + " correct : " + correct ) ; if ( size == correct && numduplicates == 0 ) { system . out . println ( "successfully done" ) ; } else if ( size < correct ) { system . out . println ( "number of critical section is less than size" ) ; } else if ( size > correct ) { system . out . println ( "number of critical section is greater than size" ) ; } else if ( size == correct ) { system . out . println ( "number of critical section is equal to size" ) ; } }
te	5	public final group creategameboard ( ) { flow = new timeline ( ) ; group group = new group ( ) ; image image = new image ( getclass ( ) . getresourceasstream ( "socialite.jpg" ) ) ; int colcount = ( int ) ( image . getwidth ( ) / slidingpuzzlepiece . getpuzzlesize ( ) ) ; int rowcount = ( int ) ( image . getheight ( ) / slidingpuzzlepiece . getpuzzlesize ( ) ) ; gameboard = new slidingpuzzleboard ( colcount , rowcount ) ; for ( int col = 0 ; col < colcount ; col ++ ) { for ( int row = 0 ; row < rowcount ; row ++ ) { int rootx = col * slidingpuzzlepiece . getpuzzlesize ( ) ; int rooty = row * slidingpuzzlepiece . getpuzzlesize ( ) ; new slidingpuzzlepiece ( image , rootx , rooty , gameboard . getwidth ( ) , gameboard . getheight ( ) , new slidingpuzzlefield ( col , row , rootx , rooty ) ) ; } } gameboard . getchildren ( ) . addall ( slidingpuzzlepiece . getpuzzlepiece ( ) ) ; resetgameboard ( ) ; mergepuzzlepieces ( gameboard , slidingpuzzlepiece . getpuzzlepiece ( ) ) ; hideonefield ( ) ; activatefields ( ) ; final int i10 = 10 ; vbox displayfield = new vbox ( i10 ) ; displayfield . setpadding ( new insets ( i10 , i10 , i10 , i10 ) ) ; displayfield . getchildren ( ) . addall ( createmenu ( ) , gameboard ) ; group . getchildren ( ) . addall ( displayfield ) ; return group ; }
te	1	@ get @ path ( "/all" ) public response getallcontacts ( @ auth boolean isauthenticated ) { int countrows = 2 ; int index = 1 ; arraylist < contact > contacts = new arraylist < contact > ( ) ; while ( index < countrows ) { contact contact = contactdao . getcontactbyid ( index ) ; if ( ! ( contact == null ) ) { contacts . add ( contact ) ; index ++ ; countrows ++ ; } else { index ++ ; } } return response . ok ( contacts ) . build ( ) ; }
te	8	private static void collectmemorypoolmetrics ( string prefix , mbeanserverconnection con , metricscollection metrics ) { set < objectname > memorypoolbeannames = querynames ( con , "java.lang:type=memorypool<litcomma>name=*" , null ) ; memorypoolbeannames . foreach ( n -> { map < string , object > attributes = getbeanattributes ( con , n , "name" , "usage" , "peakusage" , "collectionusage" , "usagethreshold" , "usagethresholdcount" , "usagethresholdsupported" , "collectionusagethreshold" , "collectionusagethresholdcount" , "collectionusagethresholdsupported" , "valid" ) ; if ( ! attributes . containskey ( "name" ) || ! attributes . containskey ( "valid" ) ) { return ; } string poolname = ( ( string ) attributes . get ( "name" ) ) . replaceall ( "\\\\s" , "" ) ; boolean valid = ( boolean ) attributes . get ( "valid" ) ; if ( ! valid ) { return ; } if ( attributes . containskey ( "collectionusage" ) && attributes . get ( "collectionusage" ) != null ) { compositedata collectionusage = ( compositedata ) attributes . get ( "collectionusage" ) ; if ( collectionusage . containskey ( "committed" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusage.committed" ) ) . setvalue ( ( long ) collectionusage . get ( "committed" ) ) ; } if ( collectionusage . containskey ( "max" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusage.max" ) ) . setvalue ( ( long ) collectionusage . get ( "max" ) ) ; } if ( collectionusage . containskey ( "init" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusage.init" ) ) . setvalue ( ( long ) collectionusage . get ( "init" ) ) ; } if ( collectionusage . containskey ( "used" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusage.used" ) ) . setvalue ( ( long ) collectionusage . get ( "used" ) ) ; } } if ( attributes . containskey ( "peakusage" ) && attributes . get ( "peakusage" ) != null ) { compositedata collectionusage = ( compositedata ) attributes . get ( "peakusage" ) ; if ( collectionusage . containskey ( "committed" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "peakusage.committed" ) ) . setvalue ( ( long ) collectionusage . get ( "committed" ) ) ; } if ( collectionusage . containskey ( "max" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "peakusage.max" ) ) . setvalue ( ( long ) collectionusage . get ( "max" ) ) ; } if ( collectionusage . containskey ( "init" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "peakusage.init" ) ) . setvalue ( ( long ) collectionusage . get ( "init" ) ) ; } if ( collectionusage . containskey ( "used" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "peakusage.used" ) ) . setvalue ( ( long ) collectionusage . get ( "used" ) ) ; } } if ( attributes . containskey ( "usage" ) && attributes . get ( "usage" ) != null ) { compositedata collectionusage = ( compositedata ) attributes . get ( "usage" ) ; if ( collectionusage . containskey ( "committed" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usage.committed" ) ) . setvalue ( ( long ) collectionusage . get ( "committed" ) ) ; } if ( collectionusage . containskey ( "max" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usage.max" ) ) . setvalue ( ( long ) collectionusage . get ( "max" ) ) ; } if ( collectionusage . containskey ( "init" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usage.init" ) ) . setvalue ( ( long ) collectionusage . get ( "init" ) ) ; } if ( collectionusage . containskey ( "used" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usage.used" ) ) . setvalue ( ( long ) collectionusage . get ( "used" ) ) ; } } if ( attributes . containskey ( "usagethresholdsupported" ) && ( boolean ) attributes . get ( "usagethresholdsupported" ) ) { if ( attributes . containskey ( "usagethreshold" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usagethreshold" ) ) . setvalue ( ( long ) attributes . get ( "usagethreshold" ) ) ; } if ( attributes . containskey ( "usagethresholdcount" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "usagethresholdcount" ) ) . setvalue ( ( long ) attributes . get ( "usagethresholdcount" ) ) ; } } if ( attributes . containskey ( "collectionusagethresholdsupported" ) && ( boolean ) attributes . get ( "collectionusagethresholdsupported" ) ) { if ( attributes . containskey ( "collectionusagethreshold" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusagethreshold" ) ) . setvalue ( ( long ) attributes . get ( "collectionusagethreshold" ) ) ; } if ( attributes . containskey ( "collectionusagethresholdcount" ) ) { metrics . numericgauge ( memorypoolmetricname ( prefix , poolname , "collectionusagethresholdcount" ) ) . setvalue ( ( long ) attributes . get ( "collectionusagethresholdcount" ) ) ; } } } ) ; }
te	1	public void print ( string s ) { this . type = s ; printerjob job = printerjob . getprinterjob ( ) ; pageformat pf = new pageformat ( ) ; paper paper = new paper ( ) ; paper . setimageablearea ( 0 , 0 , 200 , 1000 ) ; pf . setpaper ( paper ) ; book book = new book ( ) ; book . append ( this , pf ) ; job . setpageable ( book ) ; try { job . print ( ) ; } catch ( exception ex ) { new clubexception ( "error printing" , ex . tostring ( ) ) ; } }
te	7	public bufferedimage use ( bufferedimage src , vector < somvector > inputvectors ) { bufferedimage result = new bufferedimage ( src . getwidth ( ) , src . getheight ( ) , bufferedimage . type_int_rgb ) ; somvector tempvec = null ; if ( closesttype ) { for ( int i = 0 ; i < getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < getheight ( ) ; j ++ ) { somnode node = getnode ( i , j ) ; node . setweights ( closestvect ( node . getvector ( ) , inputvectors ) ) ; setnode ( i , j , node ) ; } } } for ( int i = 0 ; i < src . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < src . getheight ( ) ; j ++ ) { double % = ( i / ( double ) src . getwidth ( ) * 100 ) ; system . out . println ( % + " %" ) ; color c = new color ( src . getrgb ( i , j ) ) ; tempvec = new somvector ( scale ( c . getred ( ) ) , scale ( c . getgreen ( ) ) , scale ( c . getblue ( ) ) ) ; somnode winner = getwinner ( tempvec ) ; somvector colorvector = winner . getvector ( ) ; color resc = new color ( unscale ( colorvector . get ( 0 ) ) , unscale ( colorvector . get ( 1 ) ) , unscale ( colorvector . get ( 2 ) ) ) ; result . setrgb ( i , j , resc . getrgb ( ) ) ; } } return result ; }
te	1	private void commitsmenucheckout ( ) { system . out . println ( "enter the id of the project to retrieve commits from." ) ; projectsmenu projectsmenu = new projectsmenu ( logger , connection ) ; projectsmenu . projectsmenuview ( ) ; string input = userinput . nextline ( ) ; inputchecker in = new inputchecker ( input ) ; if ( in . hasalpha ( ) ) { system . out . println ( "that was not an int<litcomma> returning to commits menu." ) ; return ; } int projectid = integer . parseint ( input ) ; resultset rs ; commitsmenuview ( projectid ) ; system . out . println ( "which commit would you like to checkout?" ) ; string commitidtostopat = userinput . nextline ( ) ; system . out . println ( "enter the full path for the new repository" ) ; repositorydir = userinput . nextline ( ) ; if ( repositorydir . trim ( ) . equals ( "" ) ) { repositorydir = system . getproperty ( "user.dir" ) ; } try { statement statement = connection . createstatement ( ) ; if ( commitidtostopat . trim ( ) . equals ( "" ) ) { rs = statement . executequery ( "select bodyofdiff<litcomma> fileadjusted " + "from commits inner join changes on commits.id = changes.commitid " + "order by commits.id  " ) ; } else { rs = statement . executequery ( "select bodyofdiff<litcomma> fileadjusted " + "from commits inner join changes on commits.id = changes.commitid " + "where commits.id <= " + commitidtostopat + " order by commits.id  " ) ; } } catch ( sqlexception sqe ) { logger . log ( level . severe , "error getting diffs. error: {0}" , sqe . getmessage ( ) ) ; system . out . println ( "there was an error in retrieving the goal." ) ; return ; } hashmap < string , list < string > > patchesperfile = new hashmap < > ( ) ; try { while ( rs . next ( ) ) { string filename = rs . getstring ( "fileadjusted" ) ; string p = rs . getstring ( "bodyofdiff" ) ; list < string > patcheslistforthatfile = patchesperfile . get ( filename ) ; if ( patcheslistforthatfile == null ) { patcheslistforthatfile = new arraylist < > ( ) ; patchesperfile . put ( filename , patcheslistforthatfile ) ; } patcheslistforthatfile . add ( p ) ; } } catch ( sqlexception ex ) { logger . getlogger ( commitsmenu . class . getname ( ) ) . log ( level . severe , null , ex ) ; } for ( map . entry < string , list < string > > entry : patchesperfile . entryset ( ) ) { string filename = entry . getkey ( ) ; list < string > patches = entry . getvalue ( ) ; fileutil . build ( patches , repositorydir + "/" + filename ) ; } }
te	5	public static void main ( string [ ] args ) throws ioexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; system . out . print ( "type your id number                                         : " ) ; int idnum = integer . parseint ( br . readline ( ) ) % 30 + 1 ; system . out . print ( "how many kmap do you want to see (-1 for just the best(s) ) : " ) ; int numshowedstate = integer . parseint ( br . readline ( ) ) ; permutation perm = new permutation ( 8 , 7 ) ; assert perm . total >= numshowedstate : "numshowedstate exceed perm.total" ; int [ ] [ ] hwcw2isd = new int [ 8 ] [ 2 ] ; for ( int i = 4 ; i >= 0 ; i -- ) { if ( idnum % 2 == 1 ) { hwcw2isd [ i ] [ 0 ] = 7 ; hwcw2isd [ i ] [ 1 ] = ( i == 4 ) ? 6 : i + 1 ; } else { hwcw2isd [ i ] [ 0 ] = ( i == 4 ) ? 6 : i + 1 ; hwcw2isd [ i ] [ 1 ] = 7 ; } idnum >>= 1 ; } hwcw2isd [ 5 ] = null ; hwcw2isd [ 6 ] [ 0 ] = 0 ; hwcw2isd [ 6 ] [ 1 ] = 6 ; hwcw2isd [ 7 ] [ 0 ] = 7 ; hwcw2isd [ 7 ] [ 1 ] = 7 ; int [ ] assignment = new int [ 8 ] ; statetokarnaughmap [ ] states = new statetokarnaughmap [ perm . total ] ; for ( int i = 0 ; i < states . length ; i ++ ) { hwcw2updateassignment ( assignment , perm ) ; states [ i ] = new statetokarnaughmap ( hwcw2isd , 2 , 3 , assignment ) ; perm . next ( ) ; } arrays . sort ( states ) ; if ( numshowedstate >= 0 ) { for ( int i = 0 ; i < numshowedstate ; i ++ ) hwcw2printstate ( states [ i ] ) ; } else { for ( int i = 0 ; i < states . length ; i ++ ) if ( states [ i ] . score == states [ 0 ] . score ) hwcw2printstate ( states [ i ] ) ; } }
te	5	private static string getqstring ( arraylist < integer > taxlist , string type ) throws sqlexception { string q = "" ; for ( iterator < integer > iterator = taxlist . iterator ( ) ; iterator . hasnext ( ) ; ) { integer integer = iterator . next ( ) ; q += ( "<litcomma>" + integer ) ; } q = q . substring ( 1 ) ; string qstring = "" ; if ( type . equals ( "mog" ) ) qstring += "select mogid<litcomma>c.locusid<litcomma>c.version<litcomma>s.taxonomyid<litcomma>s.scaffoldid<litcomma>gi<litcomma>iscircular<litcomma>length<litcomma>p.strand<litcomma>p.begin<litcomma>p.end from scaffold s" + " inner join locus l on l.scaffoldid=s.scaffoldid" + " inner join mogmember c on c.locusid=l.locusid and c.version=l.version" + " inner join position p on l.posid=p.posid" + " where isactive=1 and ispartial=0 and isgenomic=1 and s.taxonomyid in (" + q + ") and l.priority=1" + " order by mogid" ; else if ( type . equals ( "cog" ) ) qstring += "select coginfoid<litcomma>c.locusid<litcomma>c.version<litcomma>taxonomyid<litcomma>s.scaffoldid<litcomma>gi<litcomma>iscircular<litcomma>length<litcomma>p.strand<litcomma>p.begin<litcomma>p.end from scaffold s" + " inner join locus l on l.scaffoldid=s.scaffoldid" + " inner join cog c on c.locusid=l.locusid and c.version=l.version" + " inner join position p on l.posid=p.posid" + " where isactive=1 and ispartial=0 and isgenomic=1 and s.taxonomyid in (" + q + ") and l.priority=1" + " order by coginfoid" ; else return null ; return ( qstring ) ; }
te	7	public int getoutput ( int [ ] giveninput ) { if ( giveninput == null ) { system . out . println ( "please enter some variables sir." ) ; return - 1 ; } if ( giveninput . length < 1 ) { system . out . println ( "please enter some variables sir." ) ; return - 1 ; } if ( giveninput . length < 2 ) { count += 1 ; return count ; } hashset < integer > o_hs = new hashset < integer > ( ) ; for ( int numcount = 0 ; numcount < giveninput . length ; numcount ++ ) { if ( o_hs . add ( math . abs ( giveninput [ numcount ] ) ) ) { count += 1 ; } } return count ; }
te	1	public void update ( land [ ] [ ] world ) { texture . bind ( ) ; gl11 . glcolor3f ( .7f , .7f , .7f ) ; gl11 . glbegin ( gl11 . gl_quads ) ; float wet = 0.5f ; for ( int i = 0 ; i < world . length - 1 ; i ++ ) { for ( int j = 0 ; j < world [ 0 ] . length - 1 ; j ++ ) { float size = controller . landspacing ; wet = 0 ; if ( world [ i ] [ j ] . isweet ) { wet = 0.5f ; } gl11 . glvertex3f ( 0 + i * size , world [ i ] [ j ] . height , 0 + j * size ) ; gl11 . gltexcoord2f ( 0 , 0 + wet ) ; gl11 . glvertex3f ( 0 + i * size , world [ i ] [ j + 1 ] . height , size + j * size ) ; gl11 . gltexcoord2f ( 0 , 0.5f + wet ) ; gl11 . glvertex3f ( size + i * size , world [ i + 1 ] [ j + 1 ] . height , size + j * size ) ; gl11 . gltexcoord2f ( 1 , 0.5f + wet ) ; gl11 . glvertex3f ( size + i * size , world [ i + 1 ] [ j ] . height , 0 + j * size ) ; gl11 . gltexcoord2f ( 1 , 0 + wet ) ; } } gl11 . glend ( ) ; }
te	1	@ get @ path ( "/all" ) public response getallmanagers ( @ auth boolean isauthenticated ) { int countrows = 2 ; int index = 1 ; arraylist < manager > managers = new arraylist < manager > ( ) ; while ( index < countrows ) { manager manager = managerdao . getmanagerbyid ( index ) ; if ( ! ( manager == null ) ) { managers . add ( manager ) ; index ++ ; countrows ++ ; } else { index ++ ; } } return response . ok ( managers ) . build ( ) ; }
te	3	public static < t > simplelist < t > emptylist ( ) { return new simplelist < t > ( ) { @ override public boolean isempty ( ) { return true ; } @ override public int length ( ) { return 0 ; } @ override public int hashcode ( ) { return - 1 ; } @ suppresswarnings ( "rawtypes" ) @ override public boolean equals ( object obj ) { if ( obj instanceof simplelist ) { return ( ( simplelist ) obj ) . isempty ( ) ; } else { return false ; } } @ override public string tostring ( ) { return "[]" ; } } ; }
te	4	@ suppresswarnings ( "deprecation" ) @ override public boolean oncommand ( commandsender s , command cmd , string label , string [ ] args ) { if ( ! ( s instanceof player ) ) return true ; player p = ( player ) s ; if ( cmd . getname ( ) . equalsignorecase ( "dis" ) ) { if ( args . length == 0 ) { p . sendmessage ( chatcolor . red + "usage: /dis <player>" ) ; } else if ( args . length == 1 ) { if ( disguiseapi . getapi ( ) . isdisguised ( p ) ) { p . sendmessage ( chatcolor . red + "undisguise before you disguise again!" ) ; } else { disguise d = new playerdisguise ( p , args [ 0 ] ) ; disguiseapi . getapi ( ) . disguiseplayer ( p , d , disguiseapi . getapi ( ) . online ( ) ) ; p . sendmessage ( chatcolor . green + "disguised as " + args [ 0 ] + "!" ) ; } } else if ( args . length == 2 ) { string [ ] players = args [ 1 ] . split ( "\\\\<litcomma>" ) ; list < player > dis = new arraylist < player > ( ) ; for ( string sp : players ) { if ( bukkit . getplayer ( sp ) == null ) continue ; dis . add ( bukkit . getplayer ( sp ) ) ; } disguise d = new playerdisguise ( p , args [ 0 ] ) ; disguiseapi . getapi ( ) . disguiseplayer ( p , d , dis ) ; p . sendmessage ( chatcolor . green + "disguised as " + args [ 0 ] + "!" ) ; } else { } } else if ( cmd . getname ( ) . equalsignorecase ( "udis" ) ) { if ( disguiseapi . getapi ( ) . isdisguised ( p ) ) { p . sendmessage ( chatcolor . green + "you have been undisguised!" ) ; disguiseapi . getapi ( ) . undisguiseplayer ( p ) ; } else { p . sendmessage ( chatcolor . red + "you are not disguised!" ) ; } } return true ; }
te	1	public void writetofile ( ) { file file1 = new file ( "result.txt" ) ; file file2 = null ; try { if ( file1 . exists ( ) ) { file1 . delete ( ) ; file2 = new file ( "result.txt" ) ; file2 . createnewfile ( ) ; } else { file2 = new file ( "result.txt" ) ; file2 . createnewfile ( ) ; } printwriter printwriter = new printwriter ( new filewriter ( file2 , false ) ) ; for ( int i = 0 ; i < finallist . size ( ) ; i ++ ) { printwriter . write ( finallist . get ( i ) + "<litcomma>" ) ; } printwriter . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	7	public node seek ( char [ ] word , int start , int end , boolean createnew ) { if ( end >= 0 && start == end || end < 0 && start == word . length ) { if ( createnew ) { exists = true ; } return this ; } char ch = word [ start ] ; node child = children . get ( ch ) ; if ( child == null ) { if ( createnew ) { child = new node ( this , ch , depth + 1 ) ; children . put ( ch , child ) ; } else { return null ; } } return child . seek ( word , start + 1 , end , createnew ) ; }
te	10	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; int cases = sc . nextint ( ) ; while ( cases -- != 0 ) { int numcoins = sc . nextint ( ) ; int [ ] coins = new int [ numcoins ] ; int somatotal = 0 ; for ( int i = 0 ; i < numcoins ; ++ i ) { coins [ i ] = sc . nextint ( ) ; somatotal += coins [ i ] ; } int [ ] [ ] valores = new int [ numcoins + 1 ] [ somatotal + 1 ] ; for ( int c = 1 ; c <= numcoins ; c ++ ) { for ( int s = 1 ; s <= somatotal ; s ++ ) { valores [ c ] [ s ] = valores [ c - 1 ] [ s ] ; if ( s - coins [ c - 1 ] >= 0 ) valores [ c ] [ s ] = math . max ( coins [ c - 1 ] + valores [ c - 1 ] [ s - coins [ c - 1 ] ] , valores [ c - 1 ] [ s ] ) ; } } int resposta = integer . max_value ; for ( int i = 0 ; i <= somatotal ; ++ i ) { int resto = divisao ( somatotal , valores [ numcoins ] [ i ] ) ; resposta = math . min ( resposta , resto ) ; } system . out . println ( resposta ) ; } sc . close ( ) ; }
te	5	private void handlearray ( object arrobj , vector objectstoinspect , vector arrayobjectstoinspect , string indentationstring , boolean rec ) { boolean isprimitive = false ; if ( arrobj == null ) return ; isprimitive = arrobj . getclass ( ) . getcomponenttype ( ) . isprimitive ( ) ; int length = array . getlength ( arrobj ) ; for ( int i = 0 ; i < length ; i ++ ) { object item = array . get ( arrobj , i ) ; if ( item == null ) { system . out . println ( indentationstring + "\\t" + i + ") null" ) ; } else if ( isprimitive ) { system . out . println ( indentationstring + "\\t" + i + ") " + item ) ; } else if ( item . getclass ( ) . isarray ( ) ) { system . out . println ( indentationstring + "\\t" + i + ")" ) ; handlearray ( item , objectstoinspect , arrayobjectstoinspect , indentationstring + "\\t" , rec ) ; } else if ( rec ) { system . out . println ( indentationstring + "\\t" + i + ") to be inspected recursively" ) ; arrayobjectstoinspect . addelement ( item ) ; } else { system . out . println ( indentationstring + "\\t" + i + ") " + item . hashcode ( ) ) ; } } }
te	7	private void initwt ( list < string > lst ) { list < wtmp > lwt = ( isconfirm ) ? lconfirmed : lnegative ; for ( string str : lst ) { boolean flags = false ; for ( wtmp wtmp : lwt ) { if ( wtmp . getval ( ) . equals ( str ) ) { wtmp . setnum ( wtmp . getnum ( ) + 1 ) ; flags = true ; } } if ( ! flags ) { wtmp w = new wtmp ( str , 1 ) ; lwt . add ( w ) ; } } }
te	9	public void ratkaiseluolasto ( int [ ] [ ] luolasto ) { this . alustaja . alustaluolastosolmuiksi ( luolasto ) ; this . solmut = this . alustaja . getsolmut ( ) ; for ( int k = 0 ; k < this . solmut . length ; k ++ ) { for ( int i = 0 ; i < solmut . length ; i ++ ) { for ( int j = 0 ; j < solmut [ 0 ] . length ; j ++ ) { if ( solmut [ i ] [ j ] . gettunniste ( ) == 1 ) { if ( i - 1 >= 0 && solmut [ i - 1 ] [ j ] . gettunniste ( ) == 1 ) { loysaa ( solmut [ i ] [ j ] , solmut [ i - 1 ] [ j ] ) ; } if ( i + 1 <= solmut . length - 1 && solmut [ i + 1 ] [ j ] . gettunniste ( ) == 1 ) { loysaa ( solmut [ i ] [ j ] , solmut [ i + 1 ] [ j ] ) ; } if ( j - 1 >= 0 && solmut [ i ] [ j - 1 ] . gettunniste ( ) == 1 ) { loysaa ( solmut [ i ] [ j ] , solmut [ i ] [ j - 1 ] ) ; } if ( j + 1 <= solmut [ 0 ] . length - 1 && solmut [ i ] [ j + 1 ] . gettunniste ( ) == 1 ) { loysaa ( solmut [ i ] [ j ] , solmut [ i ] [ j + 1 ] ) ; } } } } } }
te	6	private void runtests ( int tests ) { failmessages = new arraylist < string > ( ) ; @ suppresswarnings ( "unused" ) sequence sequence = null ; success = 0 ; failure = 0 ; total = 0 ; try { total ++ ; sequence = new sequence ( "" ) ; system . err . println ( "\\nno error thrown for empty sequence!" ) ; failure ++ ; } catch ( sequenceexception e ) { system . out . println ( "passed empty sequence test" ) ; success ++ ; } try { total ++ ; sequence = new sequence ( "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ) ; system . err . println ( "\\nno error thrown for length 32 sequence!" ) ; failure ++ ; } catch ( sequenceexception e ) { system . out . println ( "passed long sequence test" ) ; success ++ ; } try { total ++ ; sequence = new sequence ( "gatcb" ) ; system . err . println ( "\\nno error thrown for illegal character!" ) ; failure ++ ; } catch ( sequenceexception e ) { system . out . println ( "passed illegal character test" ) ; success ++ ; } sequence = null ; system . out . println ( "running test battery..." ) ; string [ ] base = { "a" , "t" , "g" , "c" } ; random rand = new random ( 1337 ) ; for ( int i = 1 ; i < 32 ; i ++ ) { string [ ] seq1 = new string [ i ] ; string [ ] seq2 = new string [ i ] ; for ( int j = 0 ; j < tests ; j ++ ) { for ( int ind = 0 ; ind < i ; ind ++ ) { seq1 [ ind ] = base [ rand . nextint ( 4 ) ] ; } string str1 = "" ; for ( string s : seq1 ) { str1 = str1 + s ; } for ( int ind = 0 ; ind < i ; ind ++ ) { seq2 [ ind ] = base [ rand . nextint ( 4 ) ] ; } string str2 = "" ; for ( string s : seq2 ) { str2 = str2 + s ; } test ( str1 ) ; test ( str2 ) ; test ( str1 , str2 ) ; test ( str2 , str1 ) ; test ( str1 , str1 ) ; test ( str2 , str2 ) ; } } system . out . println ( "total: " + total ) ; system . out . println ( "success: " + success ) ; system . out . println ( "failure: " + failure ) ; for ( string m : failmessages ) { system . out . println ( m ) ; } }
te	4	public static void main ( string [ ] args ) { final map < string , integer > m = new hashmap < string , integer > ( ) ; m . put ( key_bulgaria , 7 ) ; m . put ( key_germany , 80 ) ; m . put ( key_greece , 7 ) ; m . put ( key_netherland , 10 ) ; m . put ( key_russia , 145 ) ; m . put ( key_france , 60 ) ; for ( string key : m . keyset ( ) ) { if ( m . get ( key ) > 10 ) system . out . println ( key ) ; } }
te	8	@ override protected void ensurecapacity ( int inccap ) { if ( inccap < remained ( ) ) { return ; } int capacity = capacity ( ) ; int newcapacity = 0 ; if ( 2 * inccap <= capacity ) { newcapacity = capacity * 3 / 2 + 1 ; } else { newcapacity = capacity * 2 ; } char [ ] newbuf = new char [ newcapacity ] ; if ( size > 0 ) { if ( putindex > takeindex ) { system . arraycopy ( buffer , takeindex , newbuf , 0 , size ) ; } else { int len = buffer . length - takeindex ; system . arraycopy ( buffer , takeindex , newbuf , 0 , len ) ; if ( size > len ) { system . arraycopy ( buffer , 0 , newbuf , len , putindex ) ; } } } buffer = newbuf ; takeindex = 0 ; putindex = size ; }
te	3	public boolean istelno ( string telno ) { string regex = "^((13[0-9])|(14[0-9])|(15[^4<litcomma>\\\\d])|(18[^4<litcomma>\\\\d]))\\\\d{8}$" ; pattern p = pattern . compile ( regex ) ; if ( telno . contains ( "|" ) ) { string telnos [ ] = telno . split ( "[|]" ) ; for ( string tel : telnos ) { matcher m = p . matcher ( tel ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "telno: {0} is not valid" , tel ) ; return false ; } } } else { matcher m = p . matcher ( telno ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "telno: {0} is not valid" , telno ) ; return false ; } } return true ; }
te	4	public hashmap < file , string > readfilesindirectory ( string filepath ) { try { hashmap < file , string > filesmap = new hashmap < file , string > ( ) ; file [ ] files = new file ( filepath ) . listfiles ( ) ; for ( file file : files ) { if ( file . isfile ( ) ) { filesmap . put ( file , "raw" ) ; } } return filesmap ; } catch ( nullpointerexception e ) { joptionpane . showmessagedialog ( null , "plik odczytu niepoprawny" , "error" , joptionpane . error_message ) ; } return null ; }
te	8	private static list < url > resolvewildcardclasspathentry ( string entry ) { string dirpath ; if ( entry . tolowercase ( ) . endswith ( "*.jar" ) ) { dirpath = entry . substring ( 0 , entry . length ( ) - 5 ) ; } else { dirpath = entry . substring ( 0 , entry . length ( ) - 1 ) ; } file dir = new file ( dirpath ) ; if ( ! dir . exists ( ) || ! dir . isdirectory ( ) ) { return new arraylist < > ( ) ; } return arrays . stream ( dir . list ( ( f , n ) -> f . isfile ( ) && n . tolowercase ( ) . endswith ( ".jar" ) ) ) . map ( n -> tourl ( new file ( dir , n ) ) ) . collect ( collectors . tolist ( ) ) ; }
te	9	private void count ( string input ) { char prev = 0 ; char current = '0' ; int count = 1 ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { current = input . charat ( i ) ; if ( i != 0 ) { prev = input . charat ( i - 1 ) ; if ( current == prev ) { count ++ ; } } if ( ( i >= input . length ( ) - 1 ) || ( current != input . charat ( i + 1 ) ) ) { addtooutput ( input , i , count ) ; count = 1 ; } } }
te	7	private void turn ( client fromclient , client toclient ) { if ( isongame ) { fromclient . println ( your_turn_message ) ; long timestart = system . currenttimemillis ( ) ; boolean isvalidturn = false ; while ( ( ! isvalidturn ) && ( system . currenttimemillis ( ) - timestart < 10000 ) ) { if ( fromclient . isinputstreamready ( ) ) { string line = fromclient . readline ( ) ; if ( line == null ) { break ; } if ( tryturn ( fromclient , line ) ) { isvalidturn = true ; fromclient . println ( ack_message ) ; toclient . println ( line ) ; int winner = haswinner ( ) ; if ( winner != 0 ) { if ( winner == 1 ) { onwin ( client1 , client2 ) ; break ; } else { onwin ( client2 , client1 ) ; break ; } } if ( ! hasfreecells ( ) ) { ontie ( ) ; break ; } } else { fromclient . println ( bad_message ) ; } } try { thread . sleep ( 100 ) ; } catch ( interruptedexception e ) { } } if ( ! isvalidturn ) { onwin ( toclient , fromclient ) ; } } }
te	5	@ override public void actionperformed ( actionevent a ) { object source = a . getsource ( ) ; if ( source == mniplotfunc ) { pfframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 140 , getheight ( ) / 2 + getlocation ( ) . y - 100 ) ; pfframe . clearentry ( ) ; pfframe . pframe = this . pframe ; pfframe . setvisible ( true ) ; } else if ( source == mnicalculator ) { cframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 110 , getheight ( ) / 2 + getlocation ( ) . y - 80 ) ; cframe . setvisible ( true ) ; } if ( source == mniexit ) { system . exit ( 0 ) ; } else if ( source == mniclear ) { pframe . reset ( ) ; } else if ( source == mnisetinterval ) { siframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 110 , getheight ( ) / 2 + getlocation ( ) . y - 90 ) ; siframe . clearentry ( ) ; siframe . pframe = this . pframe ; siframe . setvisible ( true ) ; } else if ( source == mniabout ) { joptionpane . showmessagedialog ( this , about , "about" , joptionpane . information_message , imibig ) ; } }
te	6	private void encode ( string seq ) throws sequenceexception { for ( char c : seq . touppercase ( ) . tochararray ( ) ) { code = code << 2 ; if ( c == 'a' ) { code = code ^ 0 ; } else if ( c == 'c' ) { code = code ^ 1 ; } else if ( c == 'g' ) { code = code ^ 2 ; } else if ( c == 't' ) { code = code ^ 3 ; } else { throw new sequenceexception ( "illegal sequence character: " + c + " sequence: " + seq ) ; } } }
te	2	public static void main ( string [ ] args ) { cliente c = new cliente ( ) ; c . leermsg ( ) ; bufferedreader stdin = new bufferedreader ( new inputstreamreader ( system . in ) ) ; system . out . print ( "chat: " ) ; string leestring ; try { while ( ( leestring = stdin . readline ( ) ) != null ) { c . mandamsg ( leestring ) ; system . out . print ( "chat: " ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	7	protected void createrandomchromosomes ( ) { int [ ] newchromosomes = new int [ numberofchromosomes ] ; int crosssum = 0 ; boolean startfromend = false ; if ( getrandom ( ) < 0.5 ) { startfromend = true ; } for ( int i = 0 ; i < newchromosomes . length ; i ++ ) { if ( getrandom ( ) < 0.25 ) { continue ; } int nextvalue = createrandomchromosomevalue ( ) ; if ( crosssum + nextvalue > maxcrosssum ) { nextvalue = maxcrosssum - crosssum ; } crosssum += nextvalue ; int position = i ; if ( startfromend ) { position = newchromosomes . length - ( i + 1 ) ; } newchromosomes [ position ] = nextvalue ; } this . chromosomes = newchromosomes ; }
te	7	public static list < string > procesar ( string patharchivo ) throws exception { list < string > resultado = new linkedlist < string > ( ) ; try { reader reader = new filereader ( patharchivo ) ; bufferedreader br = new bufferedreader ( reader ) ; string s = null ; int i = 1 ; while ( ( s = br . readline ( ) ) != null ) { if ( i ++ % 2 == 0 ) { resultado . add ( s . tolowercase ( ) ) ; } else { resultado . add ( s . touppercase ( ) ) ; } } br . close ( ) ; } catch ( ioexception ex ) { throw new exception ( "error al leer el archivo" ) ; } return resultado ; }
te	8	public void informplayer ( final player player , final string permission , final object ... args ) { if ( ! enabled ) { return ; } string message = getmessage ( player , permission ) . replace ( "$permission" , permission ) ; for ( int i = 0 ; i < args . length ; i ++ ) { message = message . replace ( "$" + ( i + 1 ) , describeobject ( args [ i ] ) ) ; } if ( message != null && ! message . isempty ( ) ) { player . sendmessage ( string . format ( messageformat , message ) . replaceall ( "&([a-z0-9])" , "\xa7$1" ) ) ; } }
te	7	public void adjustweights ( somvector input , double learningrate , double distancefalloff ) { somvector weightstemp = ( somvector ) weights . clone ( ) ; double wt , vw ; for ( int w = 0 ; w < weights . size ( ) ; w ++ ) { wt = weights . elementat ( w ) . doublevalue ( ) ; vw = input . elementat ( w ) . doublevalue ( ) ; wt += distancefalloff * learningrate * ( vw - wt ) ; wt += somtrainer . momentum_coefficient * furtherdeltaweights . elementat ( w ) . doublevalue ( ) ; if ( wt > 1 ) wt = 1 ; if ( wt < 0 ) wt = 0 ; weights . setelementat ( new float ( wt ) , w ) ; } furtherdeltaweights = weights . minus ( weightstemp ) ; }
te	9	private void dropdeadblocks ( int rowborder ) { if ( rowborder < 0 ) { throw new illegalargumentexception ( "the provided row: " + rowborder + " was negative" ) ; } if ( rowborder == 0 ) { for ( int i = 0 ; i < mgrid [ 0 ] . length ; i ++ ) { if ( ! mlivetetriminocoordinates . containskey ( mgrid [ 0 ] [ i ] ) ) { mgrid [ 0 ] [ i ] = - 1 ; } } } int [ ] curr , above ; for ( int i = rowborder ; i > 0 ; i -- ) { curr = mgrid [ i ] ; above = mgrid [ i - 1 ] ; for ( int j = 0 ; j < curr . length ; j ++ ) { if ( ! mlivetetriminocoordinates . containskey ( curr [ j ] ) ) { if ( ! mlivetetriminocoordinates . containskey ( above [ j ] ) ) { curr [ j ] = above [ j ] ; } else { curr [ j ] = - 1 ; } } } } repaint ( ) ; }
te	7	private void heapify ( int start , int end ) { double here = data . get ( start ) ; int leftindex = start * 2 + 1 ; int rightindex = start * 2 + 2 ; int largestindex = start ; if ( leftindex <= end && data . get ( leftindex ) > here ) { largestindex = leftindex ; } if ( rightindex <= end && data . get ( rightindex ) > data . get ( largestindex ) ) { largestindex = rightindex ; } if ( largestindex != start ) { doswap ( start , largestindex ) ; heapify ( largestindex , end ) ; } }
te	3	@ suppresswarnings ( "unused" ) private static double [ ] pairwiseweightevent ( int uaid , int ubid , bufferedwriter fout , int friend_flag , boolean idordist , boolean entroidordist , string rhomethod , string weightmethod , string combmethod , int dependence , int samplerate ) throws ioexception { user ua = new user ( uaid ) ; user ub = new user ( ubid ) ; linkedlist < record > meetingevent = new linkedlist < record > ( ) ; linkedlist < double > mw_pbg = new linkedlist < double > ( ) ; linkedlist < double > mw_le = new linkedlist < double > ( ) ; linkedlist < double > mw_pbg_le = new linkedlist < double > ( ) ; linkedlist < double > probs = new linkedlist < double > ( ) ; linkedlist < double > entros = new linkedlist < double > ( ) ; hashmap < long , double > locationentropy = null ; hashmap < string , double > gpsentropy = null ; if ( entroidordist ) { locationentropy = tracker . readlocationentropyidbased ( samplerate ) ; } else { gpsentropy = tracker . readlocationentropygpsbased ( samplerate ) ; } int aind = 0 ; int bind = 0 ; long lastmeet = 0 ; double freq = 0 ; double personbg = 0 ; double locent = 0 ; double comb = 0 ; while ( aind < ua . records . size ( ) && bind < ub . records . size ( ) ) { record ra = ua . records . get ( aind ) ; record rb = ub . records . get ( bind ) ; if ( ra . timestamp - rb . timestamp > 3600 * 4 ) { bind ++ ; continue ; } else if ( rb . timestamp - ra . timestamp > 3600 * 4 ) { aind ++ ; continue ; } else { boolean ismeeting = false ; if ( idordist ) { ismeeting = ( ra . locid == rb . locid ) ; } else { ismeeting = ( ra . distanceto ( rb ) < miningframework . distance_threshold ) ; } if ( ismeeting ) { freq ++ ; double prob = 0 ; if ( rhomethod == "min" ) { prob = math . min ( ua . locationweight ( ra ) , ub . locationweight ( rb ) ) ; } else if ( rhomethod == "prod" ) { prob = ua . locationweight ( ra ) * ub . locationweight ( rb ) ; } probs . add ( prob ) ; personbg = - ( math . log10 ( prob ) ) ; mw_pbg . add ( personbg ) ; double entro = 0 ; if ( entroidordist ) { if ( locationentropy . containskey ( ra . locid ) ) entro = locationentropy . get ( ra . locid ) ; else entro = 0 ; } else { if ( gpsentropy . containskey ( ra . gps ( ) ) ) entro = gpsentropy . get ( ra . gps ( ) ) ; else entro = 0 ; } entros . add ( entro ) ; locent = math . exp ( - entropy_exp_para * entro ) ; mw_le . add ( locent ) ; comb = personbg * locent ; mw_pbg_le . add ( comb ) ; meetingevent . add ( ra ) ; lastmeet = ra . timestamp ; } aind ++ ; bind ++ ; } } double [ ] rt = new double [ 6 ] ; personbg = 0 ; locent = 0 ; double pbg_lcen = 0 ; double pbg_lcen_td = 0 ; double td = 0 ; double min_prob = double . max_value ; double measure_sum = 0 ; double avg_entro = 0 ; double avg_le = 0 ; double avg_pbg = 0 ; for ( double m : probs ) if ( min_prob > m ) min_prob = m ; if ( weightmethod == "min" ) { personbg = - math . log10 ( min_prob ) * meetingevent . size ( ) ; system . out . println ( string . format ( "sum of %d events by max %g is %g." , meetingevent . size ( ) , min_prob , personbg ) ) ; } else if ( weightmethod == "sum" ) { for ( double m : mw_pbg ) personbg += m ; } for ( double m : mw_le ) { locent += m ; } if ( dependence == 0 ) { for ( double m : entros ) avg_entro += m ; avg_entro /= entros . size ( ) ; for ( double m : mw_pbg ) { measure_sum += m ; } avg_pbg = measure_sum / mw_pbg . size ( ) ; if ( combmethod == "min" ) { pbg_lcen = - math . log10 ( min_prob ) * locent ; } else if ( combmethod == "prod" ) { for ( double m : mw_pbg_le ) { pbg_lcen += m ; } } else if ( combmethod == "wsum" ) { pbg_lcen = alpha * personbg + beta * locent ; } avg_le = locent / mw_le . size ( ) ; fout . write ( string . format ( "%g\\t%d\\t%d\\n" , avg_le , ( int ) freq , friend_flag ) ) ; } else { double avg_w = 0 ; if ( meetingevent . size ( ) == 1 ) { pbg_lcen = mw_pbg_le . get ( 0 ) ; pbg_lcen_td = pbg_lcen ; td = 1 ; } else if ( meetingevent . size ( ) > 1 ) { for ( int i = 0 ; i < meetingevent . size ( ) ; i ++ ) { double w = 0 ; for ( int j = 0 ; j < meetingevent . size ( ) ; j ++ ) { if ( i != j ) { record r1 = meetingevent . get ( i ) ; record r2 = meetingevent . get ( j ) ; if ( dependence == 1 ) { w += 1 - math . exp ( - event_time_exp_para_c * math . abs ( r2 . timestamp - r1 . timestamp ) / 3600.0 / 24 ) ; } else if ( dependence == 2 ) { double dist = r2 . distanceto ( r1 ) ; w += 1 - math . exp ( - event_space_exp_para_c * dist ) ; } } } w /= ( meetingevent . size ( ) - 1 ) ; if ( combmethod == "min" ) { double tmp = - math . log10 ( min_prob ) * mw_le . get ( i ) ; pbg_lcen += tmp ; td += w ; pbg_lcen_td += tmp * w ; } else if ( combmethod == "prod" ) { pbg_lcen += mw_pbg_le . get ( i ) ; td += w ; pbg_lcen_td += mw_pbg_le . get ( i ) * w ; } else if ( combmethod == "wsum" ) { double tmp = alpha * mw_pbg . get ( i ) + beta * mw_le . get ( i ) ; pbg_lcen += tmp ; td += w ; pbg_lcen_td += tmp * w ; } } avg_w = td / meetingevent . size ( ) ; } fout . write ( string . format ( "id: %d %d; %g\\t%d\\t%d\\n" , uaid , ubid , avg_w , ( int ) freq , friend_flag ) ) ; } rt [ 0 ] = personbg ; rt [ 1 ] = freq ; rt [ 2 ] = pbg_lcen ; rt [ 3 ] = locent ; rt [ 4 ] = pbg_lcen_td ; rt [ 5 ] = td ; return rt ; }
te	4	@ suppresswarnings ( "deprecation" ) public void actionperformed ( actionevent e ) { if ( ! ( username . gettext ( ) . equals ( "" ) ) && ( ! ( password . getpassword ( ) . tostring ( ) ) . equals ( "" ) ) ) { try { document doc = jsoup . connect ( "http://uniteddev.com/mc_auth.php?username=" + username . gettext ( ) + "&password=" + new string ( password . getpassword ( ) ) ) . get ( ) ; string response = doc . text ( ) ; system . out . println ( "authentication: " + response ) ; if ( response . equals ( "success" ) ) { invalid_login_lbl . setvisible ( false ) ; prefs . put ( "username" , username . gettext ( ) ) ; window . setvisible ( false ) ; window . dispose ( ) ; networkstatus ( "stop" ) ; try { minecraft . main ( username . gettext ( ) , new string ( password . getpassword ( ) ) , prefs . get ( "ram_size" , default_ram ) ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } networkprobe . stop ( ) ; } else { invalid_login_lbl . setvisible ( true ) ; } } catch ( ioexception e1 ) { } } else { invalid_login_lbl . setvisible ( true ) ; } }
te	4	private void handlehttprequest ( channelhandlercontext ctx , fullhttprequest req , string ip ) { string uri = req . geturi ( ) ; fullhttpresponse resp = null ; if ( uri . equalsignorecase ( status ) ) { managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; pagestatus page = new pagestatus ( ) ; string send = page . getpage ( ) ; bytebuf buf = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( send , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf ) ; resp . headers ( ) . set ( content_type , "text/html" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else if ( uri . equalsignorecase ( hello ) ) { try { thread . sleep ( timesleep * 1000 ) ; } catch ( interruptedexception ex ) { ex . printstacktrace ( ) ; } page page = new pagehello ( ) ; managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; string send = page . getpage ( ) ; bytebuf buf = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( send , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf ) ; resp . headers ( ) . set ( content_type , "text/html" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else if ( uri . tolowercase ( ) . contains ( redirect ) && uri . tolowercase ( ) . contains ( "url" ) ) { managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; string redirect ; if ( uri . tolowercase ( ) . contains ( "http://" ) ) { redirect = uri . substring ( 14 ) ; } else { redirect = "http://" + uri . substring ( 14 ) ; } bytebuf buf23 = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( "" , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , temporary_redirect , buf23 ) ; resp . headers ( ) . set ( location , redirect ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else { bytebuf buf2 = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( "404 page not found" , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf2 ) ; resp . headers ( ) . set ( content_type , "text/plain" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; } }
te	1	@ override public objectinspector initialize ( objectinspector [ ] arguments ) throws udfargumentexception { if ( arguments . length != 2 ) { throw new udfargumentlengthexception ( "arraycontainsexample only takes 2 arguments: list<t><litcomma> t" ) ; } objectinspector a = arguments [ 0 ] ; objectinspector b = arguments [ 1 ] ; if ( ! ( a instanceof listobjectinspector ) || ! ( b instanceof stringobjectinspector ) ) { throw new udfargumentexception ( "first argument must be a list / array<litcomma> second argument must be a string" ) ; } this . listoi = ( listobjectinspector ) a ; this . elementoi = ( stringobjectinspector ) b ; if ( ! ( listoi . getlistelementobjectinspector ( ) instanceof stringobjectinspector ) ) { throw new udfargumentexception ( "first argument must be a list of strings" ) ; } return primitiveobjectinspectorfactory . javabooleanobjectinspector ; }
te	2	@ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_f1 ) { cadastrarentrada entrada = new cadastrarentrada ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f2 ) { cadastrarsaida saida = new cadastrarsaida ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f3 ) { listarplacasestacionadas listar = new listarplacasestacionadas ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f12 ) { encerraraplicacao encerrar = new encerraraplicacao ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f11 ) { sobre sobre = new sobre ( ) ; } }
te	6	private byte [ ] getfile ( file thefile ) { byte [ ] buffer = null ; fileinputstream fis = null ; try { fis = new fileinputstream ( thefile ) ; filechannel fc = fis . getchannel ( ) ; long len = thefile . length ( ) ; int bytereadcount = 0 ; bytebuffer bytebuffer = bytebuffer . allocate ( ( int ) len ) ; int bytesread = 0 ; while ( ( bytesread != - 1 ) && ( bytereadcount < len ) ) { bytesread = fc . read ( bytebuffer ) ; bytereadcount += bytesread ; } buffer = bytebuffer . array ( ) ; } catch ( filenotfoundexception ex ) { log . error ( "minithymeleafwebserver:getfile()" , ex ) ; } catch ( ioexception ex ) { log . error ( "minithymeleafwebserver:getfile()" , ex ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( ioexception ex ) { log . error ( "minithymeleafwebserver:getfile()" , ex ) ; } } } return buffer ; }
te	5	public static void main ( string [ ] args ) throws interruptedexception { getpi getpi = new getpi ( ) ; thread [ ] threads = new thread [ total_thread ] ; system . out . println ( "number of spots  : " + total_spot ) ; system . out . println ( "number of threads: " + total_thread ) ; for ( int idx = 0 ; idx < total_thread ; idx ++ ) { threads [ idx ] = new thread ( getpi ) ; threads [ idx ] . start ( ) ; } for ( thread thread : threads ) { thread . join ( ) ; } system . out . println ( pi ( ) ) ; }
te	7	private void gameupdate ( ) { if ( wavestarttimer == 0 && enemies . size ( ) == 0 ) { wavenumber ++ ; wavestart = false ; wavestarttimer = system . nanotime ( ) ; } else { wavestarttimerdiff = ( system . nanotime ( ) - wavestarttimer ) / 1000000 ; if ( wavestarttimerdiff > wavedelay ) { wavestart = true ; wavestarttimer = 0 ; wavestarttimerdiff = 0 ; } } if ( wavestart && enemies . size ( ) == 0 ) createnewenemies ( ) ; player . update ( ) ; for ( int i = 0 ; i < bullets . size ( ) ; i ++ ) { boolean remove = bullets . get ( i ) . update ( ) ; if ( remove ) { bullets . remove ( i ) ; i -- ; } } for ( int i = 0 ; i < explosions . size ( ) ; i ++ ) { boolean remove = explosions . get ( i ) . update ( ) ; if ( remove ) { explosions . remove ( i ) ; i -- ; } } for ( int i = 0 ; i < powerups . size ( ) ; i ++ ) { boolean remove = powerups . get ( i ) . update ( ) ; if ( remove ) { powerups . remove ( i ) ; i -- ; } } for ( int i = 0 ; i < texts . size ( ) ; i ++ ) { boolean remove = texts . get ( i ) . update ( ) ; if ( remove ) { texts . remove ( i ) ; i -- ; } } for ( int i = 0 ; i < enemies . size ( ) ; i ++ ) enemies . get ( i ) . update ( ) ; for ( int i = 0 ; i < bullets . size ( ) ; i ++ ) { bullet b = bullets . get ( i ) ; double bx = b . getx ( ) ; double by = b . gety ( ) ; double br = b . getr ( ) ; for ( int j = 0 ; j < enemies . size ( ) ; j ++ ) { enemy e = enemies . get ( j ) ; double ex = e . getx ( ) ; double ey = e . gety ( ) ; double er = e . getr ( ) ; double dx = bx - ex ; double dy = by - ey ; double dist = math . sqrt ( dx * dx + dy * dy ) ; if ( dist < br + er ) { e . hit ( ) ; bullets . remove ( i ) ; i -- ; break ; } } } if ( player . isdead ( ) ) { running = false ; } for ( int i = 0 ; i < enemies . size ( ) ; i ++ ) { if ( enemies . get ( i ) . isdead ( ) ) { enemy e = enemies . get ( i ) ; double rand = math . random ( ) ; if ( rand < 0.010 ) powerups . add ( new powerup ( 1 , e . getx ( ) , e . gety ( ) ) ) ; else if ( rand < 0.100 ) powerups . add ( new powerup ( 2 , e . getx ( ) , e . gety ( ) ) ) ; else if ( rand < 0.130 ) powerups . add ( new powerup ( 3 , e . getx ( ) , e . gety ( ) ) ) ; player . setscore ( e . gettype ( ) + e . getrank ( ) ) ; enemies . remove ( i ) ; i -- ; e . explode ( ) ; explosions . add ( new explosion ( e . getx ( ) , e . gety ( ) , e . getr ( ) , e . getr ( ) + 30 ) ) ; } } if ( ! player . isrecovering ( ) ) { int px = player . getx ( ) ; int py = player . gety ( ) ; int pr = player . getr ( ) ; for ( int i = 0 ; i < enemies . size ( ) ; i ++ ) { enemy e = enemies . get ( i ) ; double ex = e . getx ( ) ; double ey = e . gety ( ) ; double er = e . getr ( ) ; double dx = px - ex ; double dy = py - ey ; double dist = math . sqrt ( dx * dx + dy * dy ) ; if ( dist < pr + er ) player . loselife ( ) ; } } int px = player . getx ( ) ; int py = player . gety ( ) ; int pr = player . getr ( ) ; for ( int i = 0 ; i < powerups . size ( ) ; i ++ ) { powerup p = powerups . get ( i ) ; double x = p . getx ( ) ; double y = p . gety ( ) ; double r = p . getr ( ) ; double dx = px - x ; double dy = py - y ; double dist = math . sqrt ( dx * dx + dy * dy ) ; if ( dist < pr + r ) { int type = p . gettype ( ) ; if ( type == 1 ) { player . setlife ( player . getlives ( ) + 1 ) ; texts . add ( new text ( player . getx ( ) , player . gety ( ) , 2000 , "life +1" ) ) ; } if ( type == 2 ) { player . increasepower ( 1 ) ; texts . add ( new text ( player . getx ( ) , player . gety ( ) , 2000 , "power +1" ) ) ; } if ( type == 3 ) { player . increasepower ( 2 ) ; texts . add ( new text ( player . getx ( ) , player . gety ( ) , 2000 , "power +2<litcomma> you drink a monster energy" ) ) ; } powerups . remove ( i ) ; i -- ; } } }
te	8	private token _readtok ( ) throws ioexception { while ( character . iswhitespace ( currch ) && ! eof ) { readch ( ) ; } if ( eof ) return eof ; if ( currch == '(' || currch == ')' ) { char c = currch ; readch ( ) ; return new token ( c + "" , token . type . syncon ) ; } else { string s = "" ; do { s += currch ; } while ( readch ( ) && ! character . iswhitespace ( currch ) && currch != '(' && currch != ')' ) ; return new token ( s , token . type . identifier ) ; } }
te	7	@ suppresswarnings ( "unchecked" ) public static void main ( string [ ] args ) { commandlineparser parser = new posixparser ( ) ; commandline cmd ; try { cmd = parser . parse ( options , args ) ; } catch ( missingoptionexception e ) { for ( object obj : options . getoptions ( ) ) { option opt = ( option ) obj ; out ( opt . tostring ( ) + ( opt . isrequired ( ) ? " - required" : " - optional" ) ) ; } return ; } catch ( parseexception e ) { out ( "error parsing arguments" ) ; e . printstacktrace ( ) ; return ; } string basedir = cmd . getoptionvalue ( 'b' ) ; string [ ] filenames = cmd . getoptionvalue ( 'f' ) . split ( "<litcomma>" ) ; map < string , object > model = new hashmap < > ( ) ; if ( cmd . hasoption ( "m" ) ) { gson gson = new gson ( ) ; model = gson . fromjson ( cmd . getoptionvalue ( 'm' ) , hashmap . class ) ; } mergeandprint ( basedir , filenames , model , ! cmd . hasoption ( 'u' ) ) ; }
te	6	private void searchdoc ( string file_name ) throws exception { path file_name_path = new path ( src_path + "/" + file_name ) ; fsdatainputstream in = fs . open ( file_name_path ) ; bufferedreader br_in = new bufferedreader ( new inputstreamreader ( in ) ) ; string message_in ; int line_num = 0 ; while ( ( message_in = br_in . readline ( ) ) != null ) { line_num ++ ; for ( string search_word : search_words ) { string compared_message_in = new string ( message_in ) ; if ( ignore_case_flag == true ) { compared_message_in = compared_message_in . tolowercase ( ) ; search_word = search_word . tolowercase ( ) ; } string pattern_string = new string ( "\\\\b(" + search_word + ")\\\\b" ) ; pattern pattern = pattern . compile ( pattern_string ) ; matcher matcher = pattern . matcher ( compared_message_in ) ; if ( matcher . find ( ) ) { system . out . println ( "line" + line_num + ":" + message_in ) ; } } } }
te	1	@ override public void update ( long ellapsedtime ) { this . m_displaytimeleft -= ellapsedtime ; if ( this . m_displaytimeleft < this . m_introtime ) { float t = ( float ) ellapsedtime ; this . m_alpha -= ( t / this . m_introtime ) * 255 ; } if ( this . m_displaytimeleft >= this . m_totaldisplaytime - this . m_introtime ) { float t = ( float ) ellapsedtime ; this . m_alpha += ( t / this . m_introtime ) * 255 ; } if ( this . m_displaytimeleft < 0 ) { this . setvisible ( false ) ; this . setenabled ( false ) ; } }
te	5	public static void readxml ( ) throws exception { puzzlehighscores = new vector < slidingpuzzlehighscore > ( ) ; documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; document doc = builder . parse ( new file ( "highscore.xml" ) ) ; element rootelement = doc . getdocumentelement ( ) ; system . out . println ( "root element: " + rootelement . getnodename ( ) ) ; nodelist list = rootelement . getelementsbytagname ( "user" ) ; for ( int i = 0 ; i < list . getlength ( ) ; i ++ ) { node usernode = list . item ( i ) ; new slidingpuzzlehighscore ( usernode . getattributes ( ) . getnameditem ( "name" ) . getnodevalue ( ) , usernode . getattributes ( ) . getnameditem ( "score" ) . getnodevalue ( ) ) ; } }
te	8	public void reduce ( intwritable key , iterable < text > values , context context ) throws ioexception , interruptedexception { arraylist < string > list = new arraylist < string > ( ) ; for ( text val : values ) { list . add ( val . tostring ( ) ) ; context . write ( val , null ) ; } int coloumnsize = list . size ( ) ; int rowsize = list . get ( 0 ) . split ( "\\t" ) . length - 1 ; if ( coloumnsize == 0 ) { system . out . println ( "cannot perform lsi because '0' elements in this cluster" ) ; } else if ( rowsize <= coloumnsize ) { system . out . println ( "rowsize =" + rowsize ) ; system . out . println ( "coloumnsize =" + coloumnsize ) ; system . out . println ( "cannot perform lsi because rowsize < coloumnsize in this cluster" ) ; } else { double [ ] [ ] arr = new double [ rowsize ] [ coloumnsize ] ; string [ ] ids = new string [ coloumnsize ] ; iterator < string > listiter = list . iterator ( ) ; int countrow = 0 ; int countcol = 0 ; while ( listiter . hasnext ( ) ) { string tmp = listiter . next ( ) ; stringtokenizer itr = new stringtokenizer ( tmp ) ; ids [ countcol ] = itr . nexttoken ( "\\t" ) ; while ( itr . hasmoretokens ( ) ) { arr [ countrow ] [ countcol ] = double . parsedouble ( itr . nexttoken ( "\\t" ) ) ; countrow ++ ; } countrow = 0 ; countcol ++ ; } matrix a = new matrix ( arr ) ; singularvaluedecomposition svd = new singularvaluedecomposition ( a ) ; matrix s = svd . gets ( ) ; matrix u = svd . getu ( ) ; matrix v = svd . getv ( ) ; configuration conf = context . getconfiguration ( ) ; int reducedrank = integer . parseint ( conf . get ( "reducedrank" ) ) ; int rank = s . rank ( ) ; int toreduce = 40 ; if ( ( 6 * rank ) / 10 < reducedrank ) { toreduce = ( 6 * rank ) / 10 ; } else { toreduce = reducedrank ; } s = s . getmatrix ( 0 , toreduce - 1 , 0 , toreduce - 1 ) ; u = u . getmatrix ( 0 , u . getrowdimension ( ) - 1 , 0 , toreduce - 1 ) ; v = v . getmatrix ( 0 , v . getrowdimension ( ) - 1 , 0 , toreduce - 1 ) ; a = u . times ( s ) ; a = a . times ( v . transpose ( ) ) ; arr = a . getarray ( ) ; string val = "" ; for ( int i = 0 ; i < coloumnsize ; i ++ ) { val = ids [ i ] + " " ; for ( int j = 0 ; j < rowsize ; j ++ ) { val += double . tostring ( arr [ j ] [ i ] ) + " " ; } context . write ( new text ( val ) , null ) ; } } }
te	6	public static boolean checkifunique ( string str ) { int len = str . length ( ) ; if ( len == 0 || null == str ) { system . out . println ( "empty string!" ) ; system . exit ( 0 ) ; } if ( len > 256 ) { return false ; } boolean [ ] charfound = new boolean [ 256 ] ; for ( int i = 0 ; i < len ; i ++ ) { int num = str . charat ( i ) ; if ( charfound [ num ] ) { return false ; } else { charfound [ num ] = true ; } } return true ; }
te	5	public void readfile ( ) { int x = 0 ; if ( scanner . hasnext ( ) ) { totalelements = integer . parseint ( scanner . next ( ) ) ; elementstringarray = new string [ totalelements ] ; elementlistarray = new string [ totalelements ] [ totalelements ] ; } if ( scanner . hasnext ( ) ) { totalstartingelements = integer . parseint ( scanner . next ( ) ) ; } while ( scanner . hasnext ( ) ) { elementstringarray [ x ] = scanner . next ( ) ; x ++ ; if ( x >= totalelements ) { break ; } } x = 0 ; int y = 0 ; while ( scanner . hasnext ( ) ) { if ( y == 0 ) { scanner . next ( ) ; y ++ ; } else if ( y == totalelements ) { elementlistarray [ x ] [ y - 1 ] = scanner . next ( ) ; y = 0 ; x ++ ; } else { elementlistarray [ x ] [ y - 1 ] = scanner . next ( ) ; y ++ ; } } }
te	9	public static void main ( string [ ] args ) throws ioexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; int cases = 0 ; stringbuilder output = new stringbuilder ( ) ; while ( true ) { int nconnections = integer . parseint ( br . readline ( ) ) ; if ( nconnections == 0 ) { break ; } string line ; stringbuilder pairs = new stringbuilder ( "" ) ; while ( true ) { line = br . readline ( ) ; if ( line . trim ( ) . length ( ) == 0 ) { break ; } else { pairs . append ( line ) ; pairs . append ( " " ) ; } } string nodes [ ] = pairs . tostring ( ) . split ( "\\\\s+" ) ; boolean graph [ ] [ ] = new boolean [ 30 ] [ 30 ] ; hashmap < integer , integer > nodemap = new hashmap ( ) ; int index = 0 ; int nodea , nodeb ; int totalnodes = 0 ; for ( int i = 0 ; i < 2 * nconnections - 1 ; i += 2 ) { nodea = integer . parseint ( nodes [ i ] ) ; nodeb = integer . parseint ( nodes [ i + 1 ] ) ; int v1 , v2 ; if ( nodemap . containskey ( nodea ) ) { v1 = nodemap . get ( nodea ) ; } else { totalnodes ++ ; nodemap . put ( nodea , index ) ; v1 = index ; index ++ ; } if ( nodemap . containskey ( nodeb ) ) { v2 = nodemap . get ( nodeb ) ; } else { totalnodes ++ ; nodemap . put ( nodeb , index ) ; v2 = index ; index ++ ; } graph [ v1 ] [ v2 ] = true ; graph [ v2 ] [ v1 ] = true ; } for ( int i = 2 * nconnections ; i < nodes . length - 3 ; i += 2 ) { cases ++ ; int reachable = bfs ( graph , integer . parseint ( nodes [ i + 1 ] ) , nodemap . get ( integer . parseint ( nodes [ i ] ) ) ) ; output . append ( "case " + cases + ": " + ( totalnodes - reachable ) + " nodes not reachable from node " + nodes [ i ] + " with ttl = " + nodes [ i + 1 ] + ".\\n" ) ; } } system . out . print ( output ) ; }
te	4	public string consultarcontacto ( string string , string string2 ) { iterator < contacto > iter = this . agenda . iterator ( ) ; contacto co , c ; string s = "" ; c = new contacto ( string , string2 , null , null ) ; if ( this . agenda . contains ( c ) ) { while ( iter . hasnext ( ) ) { co = iter . next ( ) ; if ( co . compareto ( c ) == 0 ) s = co . tostring ( ) ; } return s ; } return null ; }
te	2	private static graph creategraphfromfile ( string cmd ) { string [ ] params = cmd . split ( "\\\\s+" ) ; string filename = params [ 2 ] ; bufferedreader br ; graph graph = null ; try { br = new bufferedreader ( new filereader ( filename ) ) ; string line = br . readline ( ) ; string [ ] values = line . split ( "\\\\s+" ) ; int numvertices = integer . parseint ( values [ 0 ] ) ; int numedges = integer . parseint ( values [ 1 ] ) ; system . out . println ( "graph size = " + numvertices + "<litcomma> number of edges = " + numedges ) ; graph = new graph ( numvertices , 0 ) ; while ( ( line = br . readline ( ) ) != null ) { values = line . split ( "\\\\s+" ) ; int startnode = integer . parseint ( values [ 0 ] ) ; int endnode = integer . parseint ( values [ 1 ] ) ; int cost = integer . parseint ( values [ 2 ] ) ; graph . getadjlist ( ) . get ( startnode ) . add ( new adjlistnode ( endnode , new edge ( startnode , endnode , cost , false ) ) ) ; graph . getadjlist ( ) . get ( endnode ) . add ( new adjlistnode ( startnode , new edge ( endnode , startnode , cost , false ) ) ) ; } br . close ( ) ; } catch ( filenotfoundexception e ) { system . out . format ( "error: file %s not found.\\n" , filename ) ; } catch ( ioexception e ) { system . out . format ( "error: io error reading from file %s.\\n" , filename ) ; } return graph ; }
te	2	@ override public void onenable ( ) { log_header = "[" + this . getname ( ) + "]" ; randomgenerator = new random ( ) ; pluginfolder = getdatafolder ( ) ; configfile = new file ( pluginfolder , "config.yml" ) ; this . savedefaultconfig ( ) ; loadtrophyconfig ( this . getserver ( ) . getconsolesender ( ) ) ; getserver ( ) . getpluginmanager ( ) . registerevents ( this , this ) ; getcommand ( "headspawn" ) . setexecutor ( new headspawncommand ( this ) ) ; getcommand ( "headgive" ) . setexecutor ( new headgivecommand ( this ) ) ; getcommand ( "trophyreload" ) . setexecutor ( new reloadcommand ( this ) ) ; if ( renameenabled ) { itemstack resulthead = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; shapelessrecipe shapelessrecipe = new shapelessrecipe ( resulthead ) ; shapelessrecipe . addingredient ( 1 , material . skull_item ) ; shapelessrecipe . addingredient ( 1 , renameitem ) ; getserver ( ) . addrecipe ( shapelessrecipe ) ; } }
te	8	public static byte [ ] hex2byte ( string strhex ) { if ( strhex == null ) { return null ; } int l = strhex . length ( ) ; if ( l % 2 == 1 ) { return null ; } byte [ ] b = new byte [ l / 2 ] ; for ( int i = 0 ; i != l / 2 ; i ++ ) { b [ i ] = ( byte ) integer . parseint ( strhex . substring ( i * 2 , i * 2 + 2 ) , 16 ) ; } return b ; }
te	2	private document parsefordom ( final file docfile ) { document document = null ; try { final documentbuilderfactory documentbuilderfactory = documentbuilderfactory . newinstance ( ) ; documentbuilderfactory . setvalidating ( true ) ; final documentbuilder documentbuilder = documentbuilderfactory . newdocumentbuilder ( ) ; documentbuilder . seterrorhandler ( new myerrorhandler ( ) ) ; document = documentbuilder . parse ( docfile ) ; return document ; } catch ( exception e ) { xmlreader . log . log ( level . severe , xmlreader . problem_parsing_the_file + e . getmessage ( ) , e ) ; e = null ; return null ; } }
te	3	private void initializedb ( ) throws ioexception { string [ ] filenames = new string [ ] { "dot-sql-drop-all-tables.sql" , "dot-sql-create-and-insert-enum.sql" , "dot-sql-create-all-tables.sql" , "dot-sql-insert-all-tables.sql" } ; for ( string filename : filenames ) { string [ ] statements = fileutil . readfile ( filename ) . split ( "; " ) ; for ( string statementstring : statements ) { try { statement statement = connection . createstatement ( ) ; statement . executeupdate ( statementstring ) ; } catch ( sqlexception sqe ) { logger . log ( level . severe , "unable to init database due to error {0}. in file " + filename + "<litcomma> offending statement was " + statementstring , sqe . getmessage ( ) ) ; system . exit ( 1 ) ; } } } }
te	3	public void addfemme ( femme femme ) throws illegalargumentexception { if ( this . getsexe ( ) == "homme" ) { if ( ( this . getfemmes ( ) . contains ( femme ) == true ) || ( femme . ismariee ( ) == true ) ) { system . out . println ( " la femme " + femme . getprenom ( ) + " " + femme . getnom ( ) . touppercase ( ) + " est d\xe9j\xe0 mari\xe9e!" ) ; } else { try { this . setfemmes ( femme ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . out . println ( "erreur d'ajout de la femme!" ) ; } femme . setmariee ( true ) ; } } else system . out . println ( " vous n'\xeates pas un homme donc vous ne pouvez pas avoir de femme!" ) ; }
te	7	public static string compressstring ( string str ) { string output = "" ; char [ ] strarray = str . tochararray ( ) ; int startindex = 0 , endindex = 0 ; for ( endindex = 0 ; endindex < strarray . length ; endindex ++ ) { if ( strarray [ startindex ] != strarray [ endindex ] ) { int templen = endindex - startindex ; output = output . concat ( "" + strarray [ startindex ] + templen ) ; startindex = endindex ; } } int templen = endindex - startindex ; output = output . concat ( "" + strarray [ startindex ] + templen ) ; if ( output . length ( ) > str . length ( ) ) return str ; return output ; }
te	6	private void test ( string str1 , string str2 ) { total ++ ; try { sequence seq1 = new sequence ( str1 ) ; sequence seq2 = new sequence ( str2 ) ; if ( ! ( seq1 . tostring ( ) . equals ( str1 ) ) || ! ( seq2 . tostring ( ) . equals ( str2 ) ) ) { string message = "\\nfailed: " + str1 + " returned: " + seq1 . tostring ( ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; return ; } if ( ! ( seq1 . compareto ( seq2 ) == str1 . compareto ( str2 ) ) ) { string message = "\\nfailed: " + str1 + " compareto " + str2 + " returned: " + seq1 . compareto ( seq2 ) + " expected: " + str1 . compareto ( str2 ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; return ; } else { success ++ ; } } catch ( sequenceexception e ) { string message = "\\nfailed: " + str1 + " and " + str2 + "-- error: " + e . getmessage ( ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; } }
te	9	@ override public void action ( ) { hashmap < integer , arraylist < float > > weatherconditions = new hashmap < integer , arraylist < float > > ( ) ; for ( weatherresponse response : ( ( weathercentralagent ) myagent ) . regiontemperatures . values ( ) ) { arraylist < float > temperatures ; if ( ! weatherconditions . containskey ( response . getregion ( ) ) ) { temperatures = new arraylist < float > ( ) ; temperatures . add ( response . gettemperature ( ) ) ; weatherconditions . put ( response . getregion ( ) , temperatures ) ; } else { temperatures = weatherconditions . get ( response . getregion ( ) ) ; temperatures . add ( response . gettemperature ( ) ) ; weatherconditions . put ( response . getregion ( ) , temperatures ) ; } } system . out . println ( ) ; system . out . println ( sdf . format ( new date ( ) ) ) ; for ( integer region : weatherconditions . keyset ( ) ) { float average = 0 ; int counter ; system . out . println ( "average temperature for region " + region ) ; for ( counter = 0 ; counter < weatherconditions . get ( region ) . size ( ) ; counter ++ ) { average += weatherconditions . get ( region ) . get ( counter ) ; system . out . println ( "  " + counter + " : " + weatherconditions . get ( region ) . get ( counter ) ) ; } system . out . println ( "  average : " + ( average / counter ) ) ; system . out . println ( ) ; finished = true ; } }
