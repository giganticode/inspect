tr	OAS	=	public void setFileFormat ( Tag ff ) { m_fileFormat = ff ; }
tr	KEH	throws	public static JSONObject toJSONObject ( String string ) throws JSONException { String name ; JSONObject jo = new JSONObject ( ) ; Object value ; JSONTokener x = new JSONTokener ( string ) ; jo . put ( "name" , x . nextTo ( = ) ) ; x . next ( = ) ; jo . put ( "value" , x . nextTo ( ; ) ) ; x . next ( ) ; while ( x . more ( ) ) { name = unescape ( x . nextTo ( "=;" ) ) ; if ( x . next ( ) != = ) { if ( name . equals ( "secure" ) ) { value = boolean . true ; } else { throw x . syntaxError ( "Missing '=' in cookie parameter." ) ; } } else { value = unescape ( x . nextTo ( ; ) ) ; x . next ( ) ; } jo . put ( name , value ) ; } return jo ; }
tr	OAR	*	public static int [ ] generateWhiteNoise ( final int sampleCount , final int stddev ) { if ( sampleCount < 0 ) { return new int [ 0 ] ; } Random random = new Random ( ) ; int [ ] signal = new int [ sampleCount ] ; for ( int i = 0 ; i < sampleCount ; i ++ ) { signal [ i ] = ( int ) ( random . nextGaussian ( ) * stddev ) ; if ( signal [ i ] > 32767 ) signal [ i ] = 32767 ; if ( signal [ i ] < - 32768 ) signal [ i ] = - 32768 ; } return signal ; }
tr	OAR	*	public boolean isValidSudoku ( char [ ] [ ] board ) { char [ ] s = new char [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( ! isValid ( board [ i ] ) ) return false ; for ( int j = 0 ; j < 9 ; j ++ ) s [ j ] = board [ j ] [ i ] ; if ( ! isValid ( s ) ) return false ; for ( int j = 0 ; j < 9 ; j ++ ) s [ j ] = board [ i / 3 * 3 + j / 3 ] [ i % 3 * 3 + j % 3 ] ; if ( ! isValid ( s ) ) return false ; } return true ; }
tr	KPT	int	public int getESI ( ) { return ESI ; }
tr	SYM	{	public void setCentroCusto ( CentroCusto centroCusto ) { this . centroCusto = centroCusto ; }
tr	KFC	if	public RsHandlerNode getPrior ( ) { if ( prior != null && prior . handler != null ) return prior ; return null ; }
tr	KEH	try	private NegotiableCapabilitySet negotiate ( NegotiableCapabilitySet prefs ) { OperationRegistry registry = nodeSupport . getRegistry ( ) ; NegotiableCapabilitySet serverCap = null ; RemoteDescriptor descriptor = ( RemoteDescriptor ) registry . getDescriptor ( RemoteDescriptor . class , protocolName ) ; if ( descriptor == null ) { Object [ ] msgArg0 = { new String ( protocolName ) } ; MessageFormat formatter = new MessageFormat ( "" ) ; formatter . setLocale ( Locale . getDefault ( ) ) ; formatter . applyPattern ( JaiI18N . getString ( "RemoteJAI16" ) ) ; throw new ImagingException ( formatter . format ( msgArg0 ) ) ; } int count = 0 ; int numRetries = getNumRetries ( ) ; int retryInterval = getRetryInterval ( ) ; Exception rieSave = null ; while ( count ++ < numRetries ) { try { serverCap = descriptor . getServerCapabilities ( serverName ) ; break ; } catch ( RemoteImagingException rie ) { System . err . println ( JaiI18N . getString ( "RemoteJAI24" ) ) ; rieSave = rie ; try { Thread . sleep ( retryInterval ) ; } catch ( InterruptedException ie ) { sendExceptionToListener ( JaiI18N . getString ( "Generic5" ) , new ImagingException ( JaiI18N . getString ( "Generic5" ) , ie ) ) ; } } } if ( serverCap == null && count > numRetries ) { sendExceptionToListener ( JaiI18N . getString ( "RemoteJAI18" ) , rieSave ) ; } RemoteRIF rrif = ( RemoteRIF ) registry . getFactory ( "remoteRendered" , protocolName ) ; return RemoteJAI . negotiate ( prefs , serverCap , rrif . getClientCapabilities ( ) ) ; }
tr	ORE	<=	public static void problem41 ( ) { System . out . println ( ( erPandigital ( 123456 ) ) ) ; for ( int i = 1234561 ; i <= 9876543 ; i += 2 ) { if ( erPrimtall ( i ) ) if ( erPandigital ( i ) ) System . out . println ( i ) ; } }
tr	OLB	||	public void sendMoveToOther ( Client sender , int beginX , int beginY , int endX , int endY ) throws IOException { print ( "running function: sendMoveToOther(" + sender . nick + "  " + beginX + "  " + beginY + "  " + endX + "  " + endY + ")" ) ; if ( sender == clientPlayer1 || sender == clientPlayer2 ) { if ( clientPlayer1 != sender ) { clientPlayer1 . output . writeUTF ( "#move" ) ; clientPlayer1 . output . writeInt ( beginX ) ; clientPlayer1 . output . writeInt ( beginY ) ; clientPlayer1 . output . writeInt ( endX ) ; clientPlayer1 . output . writeInt ( endY ) ; clientPlayer1 . output . flush ( ) ; } if ( clientPlayer2 != sender ) { clientPlayer2 . output . writeUTF ( "#move" ) ; clientPlayer2 . output . writeInt ( beginX ) ; clientPlayer2 . output . writeInt ( beginY ) ; clientPlayer2 . output . writeInt ( endX ) ; clientPlayer2 . output . writeInt ( endY ) ; clientPlayer2 . output . flush ( ) ; } if ( canObserversJoin ( ) ) { for ( Client observer : clientObservers ) { observer . output . writeUTF ( "#move" ) ; observer . output . writeInt ( beginX ) ; observer . output . writeInt ( beginY ) ; observer . output . writeInt ( endX ) ; observer . output . writeInt ( endY ) ; observer . output . flush ( ) ; } } this . movesList . add ( new Move ( beginX , beginY , endX , endY ) ) ; } }
tr	ORE	>=	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	OLB	||	public void magicTeleported ( int type ) { if ( controler == null || ! inited ) return ; controler . magicTeleported ( type ) ; }
tr	KPT	int	public int getEvaluationDetail ( ) { return evaluationDetail ; }
tr	OUT	?	public static RGBColorBuilderSpec < ? > wrap ( RGBColor rGBColor ) { return new WrapConverter ( DESTINATION_CLASS_RESOLVER , IGNORED_TYPES ) . convert ( rGBColor ) . to ( RGBColorBuilderSpec . class ) ; }
tr	KPT	int	void markSuspect ( int i , int j , boolean flag ) throws InternalException { int k ; if ( 0 > ( k = findEdge ( i , j ) ) ) { throw new InternalException ( "Attempt to mark unknown edge" ) ; } else { edges [ k ] . suspect = flag ; return ; } }
tr	SYM	.	public void set_level ( String level ) { this . level = level ; }
tr	SYM	;	public void addListener ( DrawListener listener ) { show ( ) ; listeners . add ( listener ) ; frame . addKeyListener ( this ) ; frame . addMouseListener ( this ) ; frame . addMouseMotionListener ( this ) ; frame . setFocusable ( true ) ; }
tr	KPT	int	public int getIterations ( ) { return iterations ; }
tr	OAS	=	@ Before public void setUp ( ) { scanner = new KatScanner ( "../data/skein_golden_kat.txt" ) ; }
tr	OAS	=	public void buildTile ( ) { int w = tile . getWidth ( ) / ( 3 * frames ) ; int h = tile . getHeight ( ) / 4 ; this . displayTile = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Raster [ ] r = new Raster [ 4 ] ; r [ 0 ] = tile . getData ( new Rectangle ( corners [ 0 ] . x * ( w / 2 ) , corners [ 0 ] . y * ( h / 2 ) , w / 2 , h / 2 ) ) ; displayTile . setData ( r [ 0 ] . createTranslatedChild ( 0 , 0 ) ) ; r [ 1 ] = tile . getData ( new Rectangle ( corners [ 1 ] . x * ( w / 2 ) , corners [ 1 ] . y * ( h / 2 ) , w / 2 , h / 2 ) ) ; displayTile . setData ( r [ 1 ] . createTranslatedChild ( w / 2 , 0 ) ) ; r [ 2 ] = tile . getData ( new Rectangle ( corners [ 2 ] . x * ( w / 2 ) , corners [ 2 ] . y * ( h / 2 ) , w / 2 , h / 2 ) ) ; displayTile . setData ( r [ 2 ] . createTranslatedChild ( 0 , h / 2 ) ) ; r [ 3 ] = tile . getData ( new Rectangle ( corners [ 3 ] . x * ( w / 2 ) , corners [ 3 ] . y * ( h / 2 ) , w / 2 , h / 2 ) ) ; displayTile . setData ( r [ 3 ] . createTranslatedChild ( w / 2 , h / 2 ) ) ; }
tr	KFC	if	public void storeArchiveFilePath ( final String userPath ) { if ( userPath == null ) { throw new IllegalArgumentException ( "Userpath can not be null." ) ; } if ( userPath . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Userpath can not be empty." ) ; } preferences . put ( this . archivePath , userPath ) ; }
tr	SYM	}	public void editSpline ( double x0 , double y0 , double dydx0 , double x1 , double y1 , double dydx1 ) { double d2ydx2 = 0 ; xChange = x0 ; x0 = 0 ; x1 -= xChange ; d_x = x1 ; x0 /= d_x ; x1 /= d_x ; y0 /= d_x ; y1 /= d_x ; makeSpline ( y0 , dydx0 , d2ydx2 , y1 , dydx1 , d2ydx2 ) ; }
tr	KMD	private	private static void a√±adirNomVent ( Object ventana ) { if ( nroVentanas == 0 ) { nomVentanas [ 0 ] = nombreClass ( ventana ) ; estVentanas [ 0 ] = false ; nroVentanas ++ ; } else { for ( int i = 0 ; i < nroVentanas ; i ++ ) { if ( ! estaAgregada ( ventana ) ) { nomVentanas [ nroVentanas ] = nombreClass ( ventana ) ; estVentanas [ nroVentanas ] = false ; nroVentanas ++ ; return ; } } return ; } }
tr	KFC	if	public void die ( ) { dead = true ; carried = false ; xa = - facing * 2 ; ya = - 5 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . killRecord ( this ) ; }
tr	OLB	||	public ArrayList < ArrayList < String >> rot ( ArrayList < String > input ) { if ( input == null || input . size ( ) == 0 ) return null ; HashMap < String , ArrayList < String >> map = new HashMap < String , ArrayList < String >> ( ) ; for ( int i = 0 ; i < input . size ( ) ; i ++ ) { String key = shift ( input . get ( i ) ) ; if ( map . containsKey ( key ) ) { ArrayList < String > val = map . get ( key ) ; val . add ( input . get ( i ) ) ; map . put ( key , val ) ; } else { map . put ( key , new ArrayList < String > ( ) ) ; ArrayList < String > val = map . get ( key ) ; val . add ( input . get ( i ) ) ; map . put ( key , val ) ; } } return ( ArrayList < ArrayList < String >> ) map . values ( ) ; }
tr	OAS	=	@ Override public void setState ( OptionState state ) { this . state = state ; switch ( this . state ) { case NORMAL : this . description . setVisible ( true ) ; this . description . changeBackgroundColor ( Color . yellow ) ; this . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; break ; case HIDDEN_OCCUPY : this . description . setVisible ( false ) ; this . description . repaint ( ) ; this . setBorder ( null ) ; this . contentPanel . repaint ( ) ; break ; case UNOCCUPIED : this . description . setVisible ( true ) ; this . description . changeBackgroundColor ( Color . GRAY ) ; this . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; break ; case CORRECT : this . description . setVisible ( true ) ; this . description . changeBackgroundColor ( Color . GREEN ) ; this . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; break ; case INCORRECT : this . description . setVisible ( true ) ; this . description . changeBackgroundColor ( Color . RED ) ; this . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; break ; case FINISHED : this . description . setVisible ( true ) ; this . description . changeBackgroundColor ( Color . GREEN . darker ( ) ) ; this . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; break ; case TRANSPARENT : this . setOpaque ( false ) ; break ; default : break ; } }
tr	OAR	*	public double getCost ( ) { return getQuantity ( ) * getUnitCost ( ) ; }
tr	OUT	++	public BooleanVariable ( String prefix , Object ... indices ) { name = createName ( prefix , indices ) ; number = counter ++ ; ALL_VARS . add ( this ) ; VARS_BY_NAME . put ( name , this ) ; }
tr	KFC	for	public < T > void copyVerticalLeftRight ( T [ ] [ ] list ) { for ( int i = 0 ; i < list . length ; i ++ ) { for ( int j = list [ i ] . length - 1 ; j > 0 ; j -- ) { list [ i ] [ j ] = list [ i ] [ list [ i ] . length - 1 - j ] ; } } }
tr	OAS	=	public static String specEncoding ( String a_strInput ) { if ( a_strInput == null ) { return null ; } if ( a_strInput . indexOf ( "\\" ) > - 1 ) { a_strInput = a_strInput . replace ( "\\" , "\\\\" ) ; } if ( a_strInput . indexOf ( "'" ) > - 1 ) { a_strInput = a_strInput . replace ( "'" , "''" ) ; } if ( a_strInput . indexOf ( "%" ) > - 1 ) { a_strInput = a_strInput . replace ( "%" , "\\%" ) ; } if ( a_strInput . indexOf ( "_" ) > - 1 ) { a_strInput = a_strInput . replace ( "_" , "\\_" ) ; } return a_strInput ; }
tr	ORE	!=	boolean doImage ( Image img , int x , int y , int width , int height , ImageObserver observer , Color bgcolor ) { os . println ( "%doImage" ) ; y = transformY ( y ) ; PixelConsumer pc = new PixelConsumer ( img ) ; os . println ( "gsave" ) ; os . println ( "% build a temporary dictionary" ) ; os . println ( "20 dict begin" ) ; emitColorImageProlog ( pc . xdim ) ; os . println ( "% lower left corner" ) ; os . print ( x ) ; os . print ( " " ) ; os . print ( y ) ; os . println ( " translate" ) ; if ( height == 0 || width == 0 ) { height = pc . ydim ; width = pc . xdim ; } os . println ( "% size of image" ) ; os . print ( width ) ; os . print ( " " ) ; os . print ( height ) ; os . println ( " scale" ) ; os . print ( pc . xdim ) ; os . print ( " " ) ; os . print ( pc . ydim ) ; os . println ( " 8" ) ; os . print ( "[" ) ; os . print ( pc . xdim ) ; os . print ( " 0 0 -" ) ; os . print ( pc . ydim ) ; os . print ( " 0 " ) ; os . print ( 0 ) ; os . println ( "]" ) ; os . println ( "{currentfile pix readhexstring pop}" ) ; os . println ( "false 3 colorimage" ) ; os . println ( "" ) ; int offset , sleepyet = 0 ; char [ ] sb = new char [ charsPerRow + 1 ] ; for ( int i = 0 ; i < pc . ydim ; i ++ ) { offset = 0 ; ++ sleepyet ; if ( bgcolor == null ) { for ( int j = 0 ; j < pc . xdim ; j ++ ) { int n = pc . pix [ j ] [ i ] ; sb [ offset ++ ] = hd [ ( n & F0 ) >> 4 ] ; sb [ offset ++ ] = hd [ ( n & F ) ] ; sb [ offset ++ ] = hd [ ( n & F000 ) >> 12 ] ; sb [ offset ++ ] = hd [ ( n & F00 ) >> 8 ] ; sb [ offset ++ ] = hd [ ( n & F00000 ) >> 20 ] ; sb [ offset ++ ] = hd [ ( n & F0000 ) >> 16 ] ; if ( offset >= charsPerRow ) { String s = String . copyValueOf ( sb , 0 , offset ) ; os . println ( s ) ; if ( sleepyet > 5 ) { try { Thread . sleep ( 15 ) ; } catch ( java . lang . InterruptedException ex ) { } sleepyet = 0 ; } offset = 0 ; } } } else { os . println ( "%FalseColor" ) ; for ( int j = 0 ; j < pc . xdim ; j ++ ) { int bg = bgcolor . getGreen ( ) << 16 + bgcolor . getBlue ( ) << 8 + bgcolor . getRed ( ) ; int fg = clr . getGreen ( ) << 16 + clr . getBlue ( ) << 8 + clr . getRed ( ) ; int n = ( pc . pix [ j ] [ i ] == 1 ? fg : bg ) ; sb [ offset ++ ] = hd [ ( n & F0 ) ] ; sb [ offset ++ ] = hd [ ( n & F ) ] ; sb [ offset ++ ] = hd [ ( n & F000 ) ] ; sb [ offset ++ ] = hd [ ( n & F00 ) ] ; sb [ offset ++ ] = hd [ ( n & F00000 ) ] ; sb [ offset ++ ] = hd [ ( n & F0000 ) ] ; if ( offset >= charsPerRow ) { String s = String . copyValueOf ( sb , 0 , offset ) ; os . println ( s ) ; if ( sleepyet > 5 ) { try { Thread . sleep ( 15 ) ; } catch ( java . lang . InterruptedException ex ) { } sleepyet = 0 ; } offset = 0 ; } } } if ( offset != 0 ) { String s = String . copyValueOf ( sb , 0 , offset ) ; os . println ( s ) ; } } os . println ( "" ) ; os . println ( "end" ) ; os . println ( "grestore" ) ; return true ; }
tr	OAR	%	private static boolean unprotectedTest ( long l ) { for ( int n = 2 , max = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; n <= max ; n ++ ) { if ( l % n == 0 ) { return false ; } } return true ; }
tr	ORE	!=	@ Override public void onSuccess ( PaquetCom result ) { if ( result != null ) { if ( result . getIdSalleDestination ( ) == Core . userEnCours . getIdSalleEnCours ( ) ) { System . out . println ( "[Client - Tchat] " + Core . userEnCours . getIdSalleEnCours ( ) + " : Paquet n\u00B0" + result . getIdPaquet ( ) + " recu !" ) ; System . out . println ( "[Client - Tchat] " + Core . userEnCours . getIdSalleEnCours ( ) + " : Message recu : " + result . getMessage ( ) ) ; if ( result . getMessage ( ) != null ) { if ( ! result . getMessage ( ) . equals ( historique [ 99 ] ) && ( Core . userEnCours . isInstalle ( ) || emetteur . equals ( "Message automatique" ) ) ) majHistorique ( result . getMessage ( ) ) ; emetteur = result . getNomEmetteur ( ) ; cptTchat ++ ; System . out . println ( "[Client - Tchat] " + Core . userEnCours . getIdSalleEnCours ( ) + " : Cpt tchat = " + cptTchat ) ; } if ( Core . userEnCours . isInstalle ( ) || emetteur . equals ( "Message automatique" ) ) { String str = "" ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( historique [ i ] != null ) str += historique [ i ] + "<br>" ; } conversation . setHTML ( str ) ; messPanel . scrollToBottom ( ) ; } } } if ( Core . userEnCours . isInSalle ( ) ) refresh ( ) ; }
tr	ORE	!=	protected synchronized void parseElement ( final String qname , final String chars , final XMLAttributes attributes ) { try { if ( currentItem != null ) { synchronized ( currentItem ) { if ( qname . equals ( "title" ) ) { currentItem . setTitle ( chars ) ; } else if ( qname . equals ( "description" ) ) { currentItem . setDescription ( chars ) ; } else if ( qname . equals ( "link" ) ) { currentItem . setLink ( chars ) ; } else if ( qname . equals ( "pubDate" ) ) { currentItem . setPubDate ( chars ) ; } else if ( qname . equals ( "media:thumbnail" ) ) { currentItem . setThumbnail ( ( String ) attributes . getValue ( "url" ) ) ; } } } } catch ( Exception e ) { L . e ( "RSS parsing error" , "qname=" + qname + " - chars=" + chars , e ) ; } }
tr	KEH	throws	@ Override protected void generateFrameData ( ResizingByteBuffer bb ) throws FileNotFoundException , IOException { bb . put ( this . reload ( ) ) ; }
tr	ORE	!=	public boolean isSetSystemException ( ) { return this . systemException != null ; }
tr	KPT	float	public float getFloat ( ) { return 0 ; }
tr	KMD	private	private List < Individual > mutate ( List < Individual > childrenPopulation ) { List < Individual > newPopulation = new ArrayList < Individual > ( ) ; for ( Individual individual : childrenPopulation ) { Individual mutateIndividual = individual . mutate ( random ) ; mutateIndividual = mutateIndividual . mutate ( random ) ; newPopulation . add ( mutateIndividual ) ; } return newPopulation ; }
tr	KFC	for	@ Override public void runTest ( ) { TreeNode root = new TreeNode ( 1 ) ; TreeNode t = new TreeNode ( 2 ) ; root . left = t ; t = new TreeNode ( 3 ) ; root . right = t ; t = new TreeNode ( 4 ) ; root . left . left = t ; t = new TreeNode ( 5 ) ; root . left . right = t ; t = new TreeNode ( 6 ) ; root . right . right = t ; t = new TreeNode ( 7 ) ; root . left . left . left = t ; t = new TreeNode ( 8 ) ; root . right . right . right = t ; List < Integer > res = new ArrayList < > ( ) ; postorderTraversalRecursive ( root , res ) ; res = postorderTraversal ( root ) ; for ( int i : res ) dbg ( i ) ; }
tr	KMD	public	public void clientGetname ( ) { sendCommand ( CLIENT , Keyword . GETNAME . raw ) ; }
tr	SYM	{	public LaTeXPrinter ( ) { table = new Hashtable < String , String > ( ) ; setProperty ( SECTION_AGGREGATION , DEFAULT_SECTION_AGGREGATION ) ; setProperty ( CHAPTER_AGGREGATION , DEFAULT_CHAPTER_AGGREGATION ) ; setProperty ( PARAGRAPH_AGGREGATION , DEFAULT_PARAGRAPH_AGGREGATION ) ; setProperty ( SECTION_FIELDS , "" ) ; setProperty ( CHAPTER_CONTENT , "" ) ; setProperty ( PARAGRAPH_FIELDS , "" ) ; try { properties = new Properties ( ) ; InputStream is = ClassLoader . getSystemResourceAsStream ( "charset.properties" ) ; properties . load ( is ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	OUT	?	public void populate ( String [ ] columnNames , List < List < Object >> rows ) { this . rows = rows ; List < List < Object >> initialData = rows . subList ( 0 , ( initialRowCount > rows . size ( ) ? rows . size ( ) : initialRowCount ) ) ; setInitialData ( initialData ) ; setTotalCount ( rows . size ( ) ) ; setColumnNames ( columnNames ) ; }
tr	OAR	%	public static byte [ ] encode ( byte [ ] input , int offset , int len , int flags ) { Encoder encoder = new Encoder ( flags , null ) ; int output_len = len / 3 * 4 ; if ( encoder . do_padding ) { if ( len % 3 > 0 ) { output_len += 4 ; } } else { switch ( len % 3 ) { case 0 : break ; case 1 : output_len += 2 ; break ; case 2 : output_len += 3 ; break ; } } if ( encoder . do_newline && len > 0 ) { output_len += ( ( ( len - 1 ) / ( 3 * Encoder . LINE_GROUPS ) ) + 1 ) * ( encoder . do_cr ? 2 : 1 ) ; } encoder . output = new byte [ output_len ] ; encoder . process ( input , offset , len , true ) ; assert encoder . op == output_len ; return encoder . output ; }
tr	OAR	*	private static void solve ( ) { StringBuilder sb = new StringBuilder ( ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < h ; i ++ ) { if ( ( hotels [ i ] * n ) <= b ) { for ( int j = 0 ; j < w ; j ++ ) { if ( weekends [ i ] [ j ] >= n ) min = Math . min ( min , hotels [ i ] * n ) ; } } } if ( min == Integer . MAX_VALUE ) sb . append ( "stay home\n" ) ; else sb . append ( min ) . append ( "\n" ) ; System . out . print ( new String ( sb ) ) ; }
tr	OLB	&	private long sum ( int index ) { long s = 0 ; for ( ; index >= 0 ; index = ( index & ( index + 1 ) ) - 1 ) s += t [ index ] ; return s ; }
tr	KMD	public	public int compare ( Object o1 , Object o2 ) { double x1 = ( ( PolyEdge ) o1 ) . x ; double x2 = ( ( PolyEdge ) o2 ) . x ; int returnValue ; if ( x1 < x2 ) { returnValue = - 1 ; } else if ( x1 > x2 ) { returnValue = 1 ; } else { returnValue = 0 ; } return returnValue ; }
tr	KEH	throws	@ Override public Proveedor buscarPorNombre ( String nombrePersona ) throws SQLException { return dao . buscarPorNombre ( nombrePersona ) ; }
tr	OLB	||	public ArrayList < Integer > findSubstring ( String S , String [ ] L ) { int n = S . length ( ) ; int m = L . length ; ArrayList < Integer > res = new ArrayList < Integer > ( ) ; if ( n == 0 || m == 0 ) return res ; int perLen = L [ 0 ] . length ( ) ; int length = 0 ; length = perLen * m ; if ( length > n ) return res ; HashMap < String , Integer > dictSubStr = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( dictSubStr . containsKey ( L [ i ] ) ) { dictSubStr . put ( L [ i ] , dictSubStr . get ( L [ i ] ) + 1 ) ; continue ; } dictSubStr . put ( L [ i ] , 1 ) ; } for ( int i = 0 ; i <= n - length ; i ++ ) { if ( subFind ( dictSubStr , m , perLen , S . substring ( i , i + length ) , 0 , L ) ) { res . add ( i ) ; } } return res ; }
tr	SYM	.	public FacetQuery maxValuesPerFacet ( long maxValuesPerFacet ) { addParam ( Constants . FACET_MAX_VALUES_PER_FACET , maxValuesPerFacet ) ; return this ; }
tr	KMD	public	public void setResolutionIndex ( int index ) { param . setResolutionIndex ( index ) ; }
tr	KMD	public	@ Override public void quack ( ) { System . out . println ( "Kwak" ) ; }
tr	OUT	++	public void run ( ) { aRobot . loadLevel ( currentLevel ) ; while ( true ) { GameState state = solve ( ) ; if ( state == GameState . WON ) { try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } int score = StateUtil . getScore ( ActionRobot . proxy ) ; if ( ! scores . containsKey ( currentLevel ) ) scores . put ( currentLevel , score ) ; else { if ( scores . get ( currentLevel ) < score ) scores . put ( currentLevel , score ) ; } int totalScore = 0 ; for ( Integer key : scores . keySet ( ) ) { totalScore += scores . get ( key ) ; System . out . println ( " Level " + key + " Score: " + scores . get ( key ) + " " ) ; } System . out . println ( "Total Score: " + totalScore ) ; aRobot . loadLevel ( ++ currentLevel ) ; tp = new TrajectoryPlanner ( ) ; firstShot = true ; } else if ( state == GameState . LOST ) { System . out . println ( "Restart" ) ; aRobot . restartLevel ( ) ; } else if ( state == GameState . LEVEL_SELECTION ) { System . out . println ( "Unexpected level selection page  go to the last current level : " + currentLevel ) ; aRobot . loadLevel ( currentLevel ) ; } else if ( state == GameState . MAIN_MENU ) { System . out . println ( "Unexpected main menu page  go to the last current level : " + currentLevel ) ; ActionRobot . GoFromMainMenuToLevelSelection ( ) ; aRobot . loadLevel ( currentLevel ) ; } else if ( state == GameState . EPISODE_MENU ) { System . out . println ( "Unexpected episode menu page  go to the last current level : " + currentLevel ) ; ActionRobot . GoFromMainMenuToLevelSelection ( ) ; aRobot . loadLevel ( currentLevel ) ; } } }
tr	KPT	int	private static Map < String , Integer > minimax ( Model2048 m , int depth , Player player ) throws CloneNotSupportedException { Map < String , Integer > result = new HashMap < > ( ) ; int bestDirection = 0 ; int bestScore ; if ( depth == 0 || m . isTerminate ( ) ) { bestScore = heuristicScore ( m . getScore ( ) , m . getEmptyCells ( ) , calculateClusteringScore ( m . getData ( ) ) ) ; } else { if ( player == Player . USER ) { bestScore = Integer . MIN_VALUE ; for ( int i = 0 ; i < m . getLength ( ) ; i ++ ) { Model2048 newM = new Model2048 ( m ) ; int points = newM . move ( i ) ; if ( points == 0 && newM . isEqual ( m ) ) { continue ; } Map < String , Integer > currentResult = minimax ( newM , depth - 1 , Player . COMPUTER ) ; int currentScore = ( ( Number ) currentResult . get ( "Score" ) ) . intValue ( ) ; if ( currentScore > bestScore ) { bestScore = currentScore ; bestDirection = i ; } } } else { bestScore = Integer . MAX_VALUE ; List < Integer > moves = m . getEmptyCellIds ( ) ; if ( moves . isEmpty ( ) ) { bestScore = 0 ; } int [ ] possibleValues = { 2 , 4 } ; int i , j ; for ( Integer cellId : moves ) { i = cellId / m . getLength ( ) ; j = cellId % m . getLength ( ) ; for ( int value : possibleValues ) { Model2048 newM = new Model2048 ( m ) ; newM . setEmptyCell ( i , j , value ) ; Map < String , Integer > currentResult = minimax ( newM , depth - 1 , Player . USER ) ; int currentScore = ( ( Number ) currentResult . get ( "Score" ) ) . intValue ( ) ; if ( currentScore < bestScore ) { bestScore = currentScore ; } } } } } result . put ( "Score" , bestScore ) ; result . put ( "Direction" , bestDirection ) ; return result ; }
tr	OUT	++	public static double logSum ( List < double > logInputs , int fromIndex , int toIndex ) { int length = logInputs . size ( ) ; if ( length == 0 ) throw new IllegalArgumentException ( ) ; if ( fromIndex >= 0 && toIndex < length && fromIndex >= toIndex ) return double . NEGATIVE_INFINITY ; int maxIdx = fromIndex ; double max = logInputs . get ( fromIndex ) ; for ( int i = fromIndex + 1 ; i < toIndex ; i ++ ) { double d = logInputs . get ( i ) ; if ( d > max ) { maxIdx = i ; max = d ; } } boolean haveTerms = false ; double intermediate = 0.0 ; double cutoff = max - 30.0 ; for ( int i = fromIndex ; i < toIndex ; i ++ ) { double d = logInputs . get ( i ) ; if ( i != maxIdx && d > cutoff ) { haveTerms = true ; intermediate += Math . exp ( d - max ) ; } } if ( haveTerms ) { return max + Math . log ( 1.0 + intermediate ) ; } else { return max ; } }
tr	KEH	throws	void handleOutputParameters ( CallableStatement cs ) throws SQLException ;
tr	KEH	throws	public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( escape ( jo . getString ( "name" ) ) ) ; sb . append ( "=" ) ; sb . append ( escape ( jo . getString ( "value" ) ) ) ; if ( jo . has ( "expires" ) ) { sb . append ( ";expires=" ) ; sb . append ( jo . getString ( "expires" ) ) ; } if ( jo . has ( "domain" ) ) { sb . append ( ";domain=" ) ; sb . append ( escape ( jo . getString ( "domain" ) ) ) ; } if ( jo . has ( "path" ) ) { sb . append ( ";path=" ) ; sb . append ( escape ( jo . getString ( "path" ) ) ) ; } if ( jo . optBoolean ( "secure" ) ) { sb . append ( ";secure" ) ; } return sb . toString ( ) ; }
tr	OAS	=	public void setValueFromString ( String s ) throws BadValueException { try { CharsetEncoder enc = Charset . forName ( textEncoding ) . newEncoder ( ) ; enc . onMalformedInput ( CodingErrorAction . REPORT ) ; enc . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; enc . encode ( CharBuffer . wrap ( s ) ) ; } catch ( CharacterCodingException err ) { throw new BadValueException ( s ) ; } this . value = s ; }
tr	OLB	&	private int jjMoveStringLiteralDfa2_8 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return 2 ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return 2 ; } switch ( curChar ) { case 93 : if ( ( active0 & 1000000 ) != 0 ) return jjStopAtPos ( 2 , 24 ) ; break ; default : return 3 ; } return 3 ; }
tr	OUT	?	@ Override public String toString ( ) { return "EmsClass {" + ( explainModulationTypeX != null ? " explainModulationTypeX [" + explainModulationTypeX + "]" : "" ) + ( extReferences != null ? " extReferences [" + extReferences + "]" : "" ) + ( cls != null ? " cls [" + cls + "]" : "" ) + ( recommendedValue != null ? " recommendedValue [" + recommendedValue + "]" : "" ) + ( quality != null ? " quality [" + quality + "]" : "" ) + ( legacyReleasability != null ? " legacyReleasability [" + legacyReleasability + "]" : "" ) + ( value != null ? " value [" + value + "]" : "" ) + ( remarks != null ? " remarks [" + remarks + "]" : "" ) + ( explainNatureOfSignalX != null ? " explainNatureOfSignalX [" + explainNatureOfSignalX + "]" : "" ) + ( explainInformationTypeX != null ? " explainInformationTypeX [" + explainInformationTypeX + "]" : "" ) + ( availability != null ? " availability [" + availability + "]" : "" ) + "}" ; }
tr	KFC	if	public List < String > getFormat ( ) { if ( format == null ) { format = new ArrayList < String > ( ) ; } return this . format ; }
va	OUT	:	@ Override public ByteBuffer processData ( ByteBuffer data ) { this . finished = true ; if ( data . array ( ) . length == 0 ) { this . finished = this . connectionClosed ; return ByteBuffer . allocate ( 0 ) ; } for ( final HTTPReader reader : this . readers ) { data = reader . processData ( data ) ; this . updateMonitorObject ( reader ) ; if ( reader instanceof HTTPDelimiterReader && reader . isFinished ( ) ) { this . offsetByteBuffer = ( ( HTTPDelimiterReader ) reader ) . getDataOffset ( ) ; } if ( data == null ) { this . finished = false ; return null ; } else { this . finished = this . finished && reader . isFinished ( ) ; } } if ( this . mustConcatHeaders && this . finished ) { data = this . concatHeader ( data ) ; } return data ; }
va	KMD	class	public static void main ( final String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( NovoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( NovoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( NovoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( NovoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new NovoUsuario ( args ) . setVisible ( true ) ; } catch ( ParseException ex ) { Logger . getLogger ( NovoUsuario . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
va	OAR	-	@ Override public int compareTo ( ourResult our ) { if ( dist == our . dist ) return 0 ; if ( dist > our . dist ) return 1 ; else return - 1 ; }
va	SYM	(	public void testMapcat ( ) throws Exception { ITransducer < Character , Integer > xf = mapcat ( new Function < Integer , Iterable < Character >> ( ) { @ Override public Iterable < Character > apply ( Integer integer ) { final String s = integer . toString ( ) ; return new ArrayList < Character > ( s . length ( ) ) { { for ( char c : s . toCharArray ( ) ) add ( c ) ; } } ; } } ) ; List < Character > vals = transduce ( xf , new IStepFunction < List < Character > , Character > ( ) { @ Override public List < Character > apply ( List < Character > result , Character input , AtomicBoolean reduced ) { result . add ( input ) ; return result ; } } , new ArrayList < Character > ( ) , ints ( 10 ) ) ; Character [ ] expected = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; assertTrue ( vals . equals ( Arrays . asList ( expected ) ) ) ; }
va	ORE	>	public void setViewParameters ( ViewFactoryContext viewFactoryContext , List < ExprNode > viewParameters ) throws ViewParameterException { }
va	KEH	throw	private void menuInsertRowsActionPerformed ( java . awt . event . ActionEvent evt ) { int [ ] selected_rows = getSelectedRows ( ) ; if ( selected_rows . length == 0 ) throw new IllegalArgumentException ( "Empty row selection" ) ; JFrame mainFrame = ( JFrame ) SwingUtilities . getRoot ( this ) ; DialogInsertRows dialog = new DialogInsertRows ( mainFrame , true ) ; dialog . setLocationRelativeTo ( mainFrame ) ; if ( ! dialog . showDialog ( ) ) return ; int number = dialog . getRowNumber ( ) ; int position = dialog . getRowPosition ( ) ; int [ ] new_selection = new int [ 1 ] ; switch ( position ) { case DialogInsertRows . POSITION_BEGIN : new_selection [ 0 ] = 0 ; selected_rows = new_selection ; break ; case DialogInsertRows . POSITION_END : new_selection [ 0 ] = table . rows ( ) ; selected_rows = new_selection ; break ; case DialogInsertRows . POSITION_AFTER : for ( int i = 0 ; i < selected_rows . length ; i ++ ) selected_rows [ i ] += 1 ; case DialogInsertRows . POSITION_BEFORE : default : } RowTableModel rowModel = ( RowTableModel ) rowTable . getModel ( ) ; MainTableModel mainModel = ( MainTableModel ) mainTable . getModel ( ) ; rowSelectionModel . clearSelection ( ) ; for ( int i = 0 ; i < selected_rows . length ; i ++ ) { if ( selected_rows [ i ] != table . rows ( ) ) table . insertRows ( selected_rows [ i ] , number ) ; else table . addRows ( number ) ; rowModel . fireTableRowsInserted ( selected_rows [ i ] , selected_rows [ i ] + number - 1 ) ; mainModel . fireTableRowsInserted ( selected_rows [ i ] , selected_rows [ i ] + number - 1 ) ; rowSelectionModel . addSelectionInterval ( selected_rows [ i ] , selected_rows [ i ] + number - 1 ) ; if ( i != selected_rows . length - 1 ) selected_rows [ i + 1 ] += number * ( i + 1 ) ; } updateRowList ( ) ; }
va	ORE	>	@ Override public List < String > getParameters ( ) { return null ; }
va	OLB	|	public void convert ( InputStream inputStream , OutputStream output ) throws IOException { if ( inputStream == null ) { throw new IllegalArgumentException ( "Input may not be null" ) ; } if ( output == null ) { throw new IllegalArgumentException ( "Output may not be null" ) ; } BufferedReader input = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; int aChar = input . read ( ) ; boolean ignoreChars = false ; boolean doHighNibble = true ; int aByte = 0 ; while ( aChar != - 1 ) { switch ( aChar ) { case # : ignoreChars = true ; break ; case : ignoreChars = false ; break ; case : ignoreChars = false ; break ; case / : ignoreChars = false ; input . mark ( 1 ) ; aChar = input . read ( ) ; if ( aChar != * ) { input . reset ( ) ; } else { skipComment ( input ) ; } break ; case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : case 8 : case 9 : case a : case A : case b : case B : case c : case C : case d : case D : case e : case E : case f : case F : if ( ignoreChars == false ) { int nibble ; if ( ( aChar >= 0 ) && ( aChar <= 9 ) ) { nibble = aChar - 0 ; } else if ( ( aChar >= A ) && ( aChar <= F ) ) { nibble = ( aChar - A ) + 10 ; } else { nibble = ( aChar - a ) + 10 ; } if ( doHighNibble ) { aByte = nibble << 4 ; doHighNibble = false ; } else { aByte = aByte | nibble ; doHighNibble = true ; output . write ( aByte ) ; aByte = 0 ; } } break ; default : break ; } aChar = input . read ( ) ; } output . flush ( ) ; }
va	OAS	^=	private int rehash ( final int value ) { int result = value ; result ^= ( result >> 20 ) ^ ( result >> 12 ) ; result ^= ( result >> 7 ) ^ ( result >> 4 ) ; return result ; }
va	KMD	class	@ SuppressWarnings ( "rawtypes" ) public static boolean isRemoteInterface ( class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( isRMIMethod ( m ) ) { return true ; } } return false ; }
va	OAR	-	public double getLength ( ) { return this . upper - this . lower ; }
va	OLB	|	private void intLoop ( int dstNumBands , int dstWidth , int dstHeight , int src1LineStride , int src1PixelStride , int [ ] src1BandOffsets , int [ ] [ ] src1Data , int src2LineStride , int src2PixelStride , int [ ] src2BandOffsets , int [ ] [ ] src2Data , int dstLineStride , int dstPixelStride , int [ ] dstBandOffsets , int [ ] [ ] dstData ) { for ( int b = 0 ; b < dstNumBands ; b ++ ) { int [ ] s1 = src1Data [ b ] ; int [ ] s2 = src2Data [ b ] ; int [ ] d = dstData [ b ] ; int src1LineOffset = src1BandOffsets [ b ] ; int src2LineOffset = src2BandOffsets [ b ] ; int dstLineOffset = dstBandOffsets [ b ] ; for ( int h = 0 ; h < dstHeight ; h ++ ) { int src1PixelOffset = src1LineOffset ; int src2PixelOffset = src2LineOffset ; int dstPixelOffset = dstLineOffset ; src1LineOffset += src1LineStride ; src2LineOffset += src2LineStride ; dstLineOffset += dstLineStride ; for ( int w = 0 ; w < dstWidth ; w ++ ) { d [ dstPixelOffset ] = s1 [ src1PixelOffset ] | s2 [ src2PixelOffset ] ; src1PixelOffset += src1PixelStride ; src2PixelOffset += src2PixelStride ; dstPixelOffset += dstPixelStride ; } } } }
va	SYM	(	static EXECUTION_MODE getFallbackExecutionMode ( ) { final EXECUTION_MODE defaultFallbackExecutionMode = JTP ; logger . info ( "fallback execution mode = " + defaultFallbackExecutionMode ) ; return ( defaultFallbackExecutionMode ) ; }
va	KFC	break	public void changeCurrentView ( Views view ) { switch ( view ) { case INPUT_VIEW : currentView = InputView . getInstance ( ) ; break ; case OUTPUT_VIEW : currentView = OutputView . getInstance ( ) ; default : break ; } alertListeners ( ) ; currentView . showView ( ) ; }
va	OAS	^=	public int missingNumber ( int [ ] nums ) { int x = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { x ^= ( i + 1 ) ; x ^= nums [ i ] ; } return x ; }
va	OUT	:	private static final int F32 ( int k64Cnt , int x , int [ ] k32 ) { int b0 = b0 ( x ) ; int b1 = b1 ( x ) ; int b2 = b2 ( x ) ; int b3 = b3 ( x ) ; int k0 = k32 [ 0 ] ; int k1 = k32 [ 1 ] ; int k2 = k32 [ 2 ] ; int k3 = k32 [ 3 ] ; int result = 0 ; switch ( k64Cnt & 3 ) { case 1 : result = MDS [ 0 ] [ ( P [ P_01 ] [ b0 ] & FF ) ^ b0 ( k0 ) ] ^ MDS [ 1 ] [ ( P [ P_11 ] [ b1 ] & FF ) ^ b1 ( k0 ) ] ^ MDS [ 2 ] [ ( P [ P_21 ] [ b2 ] & FF ) ^ b2 ( k0 ) ] ^ MDS [ 3 ] [ ( P [ P_31 ] [ b3 ] & FF ) ^ b3 ( k0 ) ] ; break ; case 0 : b0 = ( P [ P_04 ] [ b0 ] & FF ) ^ b0 ( k3 ) ; b1 = ( P [ P_14 ] [ b1 ] & FF ) ^ b1 ( k3 ) ; b2 = ( P [ P_24 ] [ b2 ] & FF ) ^ b2 ( k3 ) ; b3 = ( P [ P_34 ] [ b3 ] & FF ) ^ b3 ( k3 ) ; case 3 : b0 = ( P [ P_03 ] [ b0 ] & FF ) ^ b0 ( k2 ) ; b1 = ( P [ P_13 ] [ b1 ] & FF ) ^ b1 ( k2 ) ; b2 = ( P [ P_23 ] [ b2 ] & FF ) ^ b2 ( k2 ) ; b3 = ( P [ P_33 ] [ b3 ] & FF ) ^ b3 ( k2 ) ; case 2 : result = MDS [ 0 ] [ ( P [ P_01 ] [ ( P [ P_02 ] [ b0 ] & FF ) ^ b0 ( k1 ) ] & FF ) ^ b0 ( k0 ) ] ^ MDS [ 1 ] [ ( P [ P_11 ] [ ( P [ P_12 ] [ b1 ] & FF ) ^ b1 ( k1 ) ] & FF ) ^ b1 ( k0 ) ] ^ MDS [ 2 ] [ ( P [ P_21 ] [ ( P [ P_22 ] [ b2 ] & FF ) ^ b2 ( k1 ) ] & FF ) ^ b2 ( k0 ) ] ^ MDS [ 3 ] [ ( P [ P_31 ] [ ( P [ P_32 ] [ b3 ] & FF ) ^ b3 ( k1 ) ] & FF ) ^ b3 ( k0 ) ] ; break ; } return result ; }
va	KEH	throw	@ Override public GameModel createGame ( final String gameName ) { if ( gameName . equals ( "Reversi" ) ) { return new ReversiModel ( ) ; } if ( gameName . equals ( "Gold" ) ) { return new GoldModel ( ) ; } throw new IllegalArgumentException ( "No such game: " + gameName ) ; }
va	KPT	boolean	public boolean ProgressStart ( Object owner ) { if ( progress != null && progressOwner == null ) { progressOwner = owner ; progressValue = 0 ; SwingUtilities . invokeLater ( UpdateProgress ) ; return true ; } else return false ; }
va	KPT	boolean	public boolean hasEnd ( ) { return ( ( bitField0_ & 00000002 ) == 00000002 ) ; }
va	KFC	break	private boolean r_tidy ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; int v_8 ; int v_9 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; v_3 = limit - cursor ; lab0 : do { v_4 = limit - cursor ; if ( ! r_LONG ( ) ) { break lab0 ; } cursor = limit - v_4 ; ket = cursor ; if ( cursor <= limit_backward ) { break lab0 ; } cursor -- ; bra = cursor ; slice_del ( ) ; } while ( false ) ; cursor = limit - v_3 ; v_5 = limit - cursor ; lab1 : do { ket = cursor ; if ( ! ( in_grouping_b ( g_AEI , 97 , 228 ) ) ) { break lab1 ; } bra = cursor ; if ( ! ( out_grouping_b ( g_V1 , 97 , 246 ) ) ) { break lab1 ; } slice_del ( ) ; } while ( false ) ; cursor = limit - v_5 ; v_6 = limit - cursor ; lab2 : do { ket = cursor ; if ( ! ( eq_s_b ( 1 , "j" ) ) ) { break lab2 ; } bra = cursor ; lab3 : do { v_7 = limit - cursor ; lab4 : do { if ( ! ( eq_s_b ( 1 , "o" ) ) ) { break lab4 ; } break lab3 ; } while ( false ) ; cursor = limit - v_7 ; if ( ! ( eq_s_b ( 1 , "u" ) ) ) { break lab2 ; } } while ( false ) ; slice_del ( ) ; } while ( false ) ; cursor = limit - v_6 ; v_8 = limit - cursor ; lab5 : do { ket = cursor ; if ( ! ( eq_s_b ( 1 , "o" ) ) ) { break lab5 ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "j" ) ) ) { break lab5 ; } slice_del ( ) ; } while ( false ) ; cursor = limit - v_8 ; limit_backward = v_2 ; golab6 : while ( true ) { v_9 = limit - cursor ; lab7 : do { if ( ! ( out_grouping_b ( g_V1 , 97 , 246 ) ) ) { break lab7 ; } cursor = limit - v_9 ; break golab6 ; } while ( false ) ; cursor = limit - v_9 ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } ket = cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; bra = cursor ; S_x = slice_to ( S_x ) ; if ( ! ( eq_v_b ( S_x ) ) ) { return false ; } slice_del ( ) ; return true ; }
te	SYM	)	@ Override public int getScaledSize ( double size ) { return ( int ) size ; }
te	OLB	&&	public static void formatTable ( final StringBuilder output , final List < String [ ] > twoColData , final int prefix , final int space , final int maxLineLength ) { int firstColSize = 2 ; for ( final String [ ] col : twoColData ) { if ( col . length > 0 && col [ 0 ] != null ) { firstColSize = Math . max ( firstColSize , col [ 0 ] . length ( ) ) ; } } final boolean secondColInNewLine = ( ( prefix + space + firstColSize + 10 ) > maxLineLength ) ; for ( final String [ ] col : twoColData ) { if ( col . length > 0 ) { mkSpace ( output , prefix ) ; int cursor = prefix ; if ( col [ 0 ] != null ) { output . append ( col [ 0 ] ) ; cursor += col [ 0 ] . length ( ) ; } if ( secondColInNewLine ) { output . append ( "\n" ) ; } else { mkSpace ( output , prefix + firstColSize + space - cursor ) ; } if ( col [ 1 ] != null ) { if ( secondColInNewLine ) { wrap ( output , col [ 1 ] , prefix + space , maxLineLength - prefix - space ) ; } else { wrap ( output , col [ 1 ] , prefix + space + firstColSize , maxLineLength - prefix - space - firstColSize ) ; } } } output . append ( "\n" ) ; } }
te	OAR	+	void displayVectors ( ) { Iterator < Entry < String , ArrayList < float >>> it = this . vectors . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < String , ArrayList < float >> entry = ( Map . Entry < String , ArrayList < float >> ) it . next ( ) ; ArrayList < float > arr = entry . getValue ( ) ; System . err . println ( "SIZE:" + arr . size ( ) + " " + entry . getKey ( ) + ":" + Arrays . deepToString ( arr . toArray ( ) ) ) ; } }
te	KFC	return	public MissionSequencer getSequencer ( ) { return this . seq ; }
te	KMD	new	public Widget getTableHeaderCellRendererComponent ( int column , String columnName ) { FlowPanel container = new FlowPanel ( ) ; Label columnLabel = new Label ( columnName ) ; columnLabel . setStyleName ( "ucpgwt-TableSorterModelModel-HeaderCellRenderer-Label" ) ; Image icon = getHeaderRendererIcon ( column , 5 ) ; container . add ( columnLabel ) ; if ( icon != null ) { icon . setStyleName ( "ucpgwt-TableSorterModelModel-HeaderCellRenderer-Icon" ) ; container . add ( icon ) ; } container . setStyleName ( "ucpgwt-TableSorterModelModel-HeaderCellRenderer" ) ; container . setTitle ( "Clique para ordenar" ) ; return container ; }
te	OAS	+=	public static String toText ( String [ ] matriz ) { String cadena = "" ; for ( String palabra : matriz ) { cadena += palabra + " " ; } return cadena ; }
te	ORE	<	public ArrayList < ArrayList < ShotData >> getShots ( ) { return gameShots ; }
te	ORE	==	private static String parseOptions ( String [ ] args ) { StringBuilder sb = new StringBuilder ( ) ; if ( args == null ) return "" ; for ( String str : args ) { if ( str . startsWith ( "-" ) ) sb . append ( str . substring ( 1 ) ) ; } return sb . toString ( ) ; }
te	OUT	!	public static String readString ( ) { if ( isEmpty ( ) ) throw new RuntimeException ( "Reading from empty input stream" ) ; StringBuilder sb = new StringBuilder ( ) ; while ( ! isEmpty ( ) ) { char c = readChar ( ) ; sb . append ( c ) ; } return sb . toString ( ) ; }
te	KEH	assert	@ Test public void testGetResource ( ) throws Exception { assert . assertNotNull ( ResourceSystem . getInstance ( ) . getResource ( "mysql.xml" ) ) ; }
te	SYM	,	@ Override public void setBinaryStream ( int parameterIndex , InputStream x , long length ) throws SQLException { delegate . setBinaryStream ( parameterIndex , x , length ) ; }
te	KEH	assert	public SuperFrequencyTrace ( int maxDemes , long startPastWard , int generations ) { assert startPastWard < Integer . MAX_VALUE ; startIndexTime = ( int ) startPastWard ; demes = maxDemes ; freq = new double [ demes * alleles * generations ] ; genDelta = demes * alleles ; }
te	OLB	&&	private int solve ( List < Integer > need , int [ ] colors , int sumColors ) { int sumc = 0 ; for ( Integer i : need ) sumc += i ; if ( sumColors < sumc ) return INF ; for ( int i = 1 ; need . size ( ) - i >= 0 && colors . length - i >= 0 ; i ++ ) { sumc -= Math . min ( need . get ( need . size ( ) - i ) , colors [ colors . length - i ] ) ; } return sumc ; }
te	OUT	!	public boolean isEqual ( DBProtocol p , Attribute [ ] attributes ) { for ( int i = 0 ; i < attributes . length ; i ++ ) { Attribute a = this . getAttribute ( attributes [ i ] ) ; Attribute b = p . getAttribute ( attributes [ i ] ) ; if ( ! a . isEqual ( b ) ) return false ; } return true ; }
te	KPT	double	public double standardizedMinimumOfItemStandardDeviations ( ) { return standardizedItemStandardDeviationsMin ; }
te	OAS	+=	public int read3Bytes ( ) { currentOffset += 3 ; return ( ( buffer [ currentOffset - 3 ] & ff ) << 16 ) + ( ( buffer [ currentOffset - 2 ] & ff ) << 8 ) + ( buffer [ currentOffset - 1 ] & ff ) ; }
te	KPT	long	public static class get_static ( long o ) { System . out . println ( "selected long method" ) ; return long . TYPE ; }
te	OAR	+	public JSliderOptionPane ( Window parent ) { JOptionPane optionPane = new JOptionPane ( ) ; JSlider slider = getSlider ( optionPane ) ; optionPane . setMessage ( new Object [ ] { "Select a value: " , slider } ) ; optionPane . setMessageType ( JOptionPane . QUESTION_MESSAGE ) ; optionPane . setOptionType ( JOptionPane . OK_CANCEL_OPTION ) ; JDialog dialog = optionPane . createDialog ( parent , "My Slider" ) ; dialog . setVisible ( true ) ; System . out . println ( "Input: " + optionPane . getInputValue ( ) ) ; }
te	KMD	new	public Playlist [ ] buildPlaylistListPub ( ArrayList < Playlist > playlists ) { Playlist [ ] playLP = playlists . toArray ( new Playlist [ 0 ] ) ; this . playlistPub = playlists ; return playLP ; }
te	KFC	return	public int getAttributes ( ) { return getU8 ( 3 ) ; }
