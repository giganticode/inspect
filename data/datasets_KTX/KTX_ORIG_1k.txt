tr	SYM	;	public void actionPerformed ( ActionEvent e ) { for ( int i = 0 ; i < sellSpinners . size ( ) ; i ++ ) { JSpinner spinner = sellSpinners . get ( i ) ; if ( ( Integer ) spinner . getValue ( ) > 0 ) { GuiArbiter . playerSell ( goodsArrayList . get ( i ) , ( Integer ) spinner . getValue ( ) ) ; } } updateMarketQuantities ( ) ; updateCargoQuantities ( ) ; updatePlayerInfoLabel ( ) ; updateBuySpinners ( ) ; updateSellSpinners ( ) ; }
tr	KMD	public	public void drawModel ( Graphics2D graphics , Actor actor , Color color ) { Model model = actor . getModel ( ) ; if ( model == null || ! model . isValid ( ) ) return ; Vec3 [ ] [ ] vectors = model . getVectors ( ) ; graphics . setColor ( color ) ; int gx = actor . getLocation ( ) . getGx ( ) ; int gy = actor . getLocation ( ) . getGy ( ) ; for ( Vec3 [ ] points : vectors ) { Vec3 pa = points [ 0 ] ; Vec3 pb = points [ 1 ] ; Vec3 pc = points [ 2 ] ; Point a = Perspective . trans_tile_cam ( getContext ( ) . getClient ( ) , gx + ( int ) pa . x , gy + ( int ) pc . x , 0 - ( int ) pb . x ) ; Point b = Perspective . trans_tile_cam ( getContext ( ) . getClient ( ) , gx + ( int ) pa . y , gy + ( int ) pc . y , 0 - ( int ) pb . y ) ; Point c = Perspective . trans_tile_cam ( getContext ( ) . getClient ( ) , gx + ( int ) pa . z , gy + ( int ) pc . z , 0 - ( int ) pb . z ) ; if ( Perspective . on_screen ( a ) && Perspective . on_screen ( b ) && Perspective . on_screen ( c ) ) { graphics . drawPolygon ( new Polygon ( new int [ ] { a . x , b . x , c . x } , new int [ ] { a . y , b . y , c . y } , 3 ) ) ; } } }
tr	KEH	try	public void valueChangeCalendar ( ValueChangeEvent evt ) { System . out . println ( "...." ) ; if ( evt . getComponent ( ) . getId ( ) . equalsIgnoreCase ( "dfecha" ) ) { System . out . println ( "::::" ) ; System . out . println ( "valueChangeCalendar:" + ( ( Calendar ) evt . getComponent ( ) ) . getValue ( ) ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "EEE MMM dd HH:mm:ss z yyyy" , Locale . CANADA ) ; try { setDfecha ( sdf . parse ( ( ( Calendar ) evt . getComponent ( ) ) . getValue ( ) . toString ( ) ) ) ; cargaRanking ( ) ; Iterator < UIComponent > it = evt . getComponent ( ) . getParent ( ) . getChildren ( ) . iterator ( ) ; for ( Iterator iterator = it ; iterator . hasNext ( ) ; ) { UIComponent ui = ( UIComponent ) iterator . next ( ) ; System . out . println ( ui . getId ( ) ) ; } System . out . println ( "exito:" + getDfecha ( ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } }
tr	ORE	<	public Perfil consultarPerfilPorNombre ( String nombrePerfil ) { Perfil perfil = null ; try { DBConnectionFactory DBC = new DBConnectionFactory ( ) ; DBConnection conn = DBC . createConnection ( ) ; String query = "SELECT * FROM " + TABLA_PERFILES + " WHERE Nombre = '" + nombrePerfil + "'" ; ResultSet rs = conn . executeQuery ( query ) ; if ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; ArrayList < Accion > listaAcciones = consultarAccionesDePerfil ( id ) ; perfil = new Perfil ( nombrePerfil , listaAcciones ) ; perfil . setId ( id ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return perfil ; }
tr	KMD	public	@ Override public void accept ( UpdateEventVisitor visitor ) { visitor . visit ( this ) ; }
tr	OUT	++	private Value [ ] convertValueNodeListToValueIntArrayScaled ( NodeList valueNodes ) throws XPathExpressionException { Value [ ] values = new Value [ valueNodes . getLength ( ) ] ; expr = xpath . compile ( VALUES_XML_READER_VALUES_DATA_PATH ) ; for ( int i = 0 ; i < valueNodes . getLength ( ) ; i ++ ) { NodeList datas = ( NodeList ) expr . evaluate ( valueNodes . item ( i ) , XPathConstants . NODESET ) ; double [ ] data = new double [ datas . getLength ( ) ] ; for ( int j = 0 ; j < datas . getLength ( ) ; j ++ ) data [ j ] = ( Integer . parseInt ( datas . item ( j ) . getTextContent ( ) ) - baseline ) * lsbValue ; values [ i ] = new Value ( long . parseLong ( valueNodes . item ( i ) . getAttributes ( ) . getNamedItem ( VALUES_XML_READER_SAMPLESTAMP_ATTR ) . getNodeValue ( ) ) , data ) ; } return values ; }
tr	KFC	if	private void optmenu_actualizar_incidenteActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! getControlador ( ) . getListaIncidentes ( ) . isEmpty ( ) ) { } else { JOptionPane . showMessageDialog ( null , "No tiene Se Tienen Incidentes" ) ; } Form_Actualizar_Incidente actualizarIncidente = new Form_Actualizar_Incidente ( controlador ) ; fondo . add ( actualizarIncidente ) ; actualizarIncidente . toFront ( ) ; actualizarIncidente . show ( ) ; }
tr	KPT	boolean	protected < X extends MessageDispatcher > X installUpHandler ( UpHandler handler , boolean canReplace ) { UpHandler existing = channel . getUpHandler ( ) ; if ( existing == null ) channel . setUpHandler ( handler ) ; else if ( canReplace ) { log . warn ( "Channel already has an up handler installed (%s) but now it is being overridden" , existing ) ; channel . setUpHandler ( handler ) ; } return ( X ) this ; }
tr	KPT	int	public void getPermutation2 ( int k , List < Integer > remaining ) { if ( remaining . size ( ) == 1 ) { result += remaining . remove ( 0 ) ; return ; } int window = 1 ; for ( int i = 1 ; i < remaining . size ( ) ; i ++ ) window *= i ; int pos = ( k - 1 ) / window ; result += remaining . remove ( pos ) ; getPermutation2 ( k - window * pos , remaining ) ; }
tr	OAR	-	@ Override protected XMLFile pack ( ) { XMLElement root = new XMLElement ( "options" ) ; XMLFile xml = new XMLFile ( OptionsData . FILENAME , OptionsData . OPTIONSPATH ) ; xml . addRootElement ( root ) ; XMLElement gen = this . packGeneral ( ) ; root . addElement ( gen ) ; XMLElement fil = this . packFilter ( ) ; root . addElement ( fil ) ; XMLElement - = this . packSubtitles ( ) ; root . addElement ( - ) ; XMLElement tvd = this . packTVDB ( ) ; root . addElement ( tvd ) ; return xml ; }
tr	ORE	<	public ArrayList < String > getWords0 ( ) { return words0 ; }
tr	OAR	-	@ Override public FractalValue visitASTTCmdRight ( ASTTCmdRight form , FractalState state ) throws FractalException { System . out . print ( "->CmdRight" ) ; ASTExp angleExp = form . getAngle ( ) ; FractalValue angleVal = angleExp . visit ( this , state ) ; double angle = angleVal . realValue ( ) ; state . getTurtleState ( ) . turn ( - angle ) ; return FractalValue . NO_VALUE ; }
tr	KFC	return	public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; String NEWLINE = System . getProperty ( "line.separator" ) ; s . append ( V + " vertices  " + E + " edges " + NEWLINE ) ; for ( int v = 0 ; v < V ; v ++ ) { s . append ( String . format ( "%d: " , v ) ) ; for ( int w : adj [ v ] ) { s . append ( String . format ( "%d " , w ) ) ; } s . append ( NEWLINE ) ; } return s . toString ( ) ; }
tr	KFC	return	public String getHostIP ( ) { return hostIP ; }
tr	OUT	++	public static void method372 ( double d ) { d += Math . random ( ) * 0.029999999999999999D - 0.014999999999999999D ; int j = 0 ; for ( int k = 0 ; k < 512 ; k ++ ) { double d1 = ( double ) ( k / 8 ) / 64D + 0.0078125D ; double d2 = ( double ) ( k & 7 ) / 8D + 0.0625D ; for ( int k1 = 0 ; k1 < 128 ; k1 ++ ) { double d3 = ( double ) k1 / 128D ; double d4 = d3 ; double d5 = d3 ; double d6 = d3 ; if ( d2 != 0.0D ) { double d7 ; if ( d3 < 0.5D ) d7 = d3 * ( 1.0D + d2 ) ; else d7 = ( d3 + d2 ) - d3 * d2 ; double d8 = 2D * d3 - d7 ; double d9 = d1 + 0.33333333333333331D ; if ( d9 > 1.0D ) d9 -- ; double d10 = d1 ; double d11 = d1 - 0.33333333333333331D ; if ( d11 < 0.0D ) d11 ++ ; if ( 6D * d9 < 1.0D ) d4 = d8 + ( d7 - d8 ) * 6D * d9 ; else if ( 2D * d9 < 1.0D ) d4 = d7 ; else if ( 3D * d9 < 2D ) d4 = d8 + ( d7 - d8 ) * ( 0.66666666666666663D - d9 ) * 6D ; else d4 = d8 ; if ( 6D * d10 < 1.0D ) d5 = d8 + ( d7 - d8 ) * 6D * d10 ; else if ( 2D * d10 < 1.0D ) d5 = d7 ; else if ( 3D * d10 < 2D ) d5 = d8 + ( d7 - d8 ) * ( 0.66666666666666663D - d10 ) * 6D ; else d5 = d8 ; if ( 6D * d11 < 1.0D ) d6 = d8 + ( d7 - d8 ) * 6D * d11 ; else if ( 2D * d11 < 1.0D ) d6 = d7 ; else if ( 3D * d11 < 2D ) d6 = d8 + ( d7 - d8 ) * ( 0.66666666666666663D - d11 ) * 6D ; else d6 = d8 ; } int l1 = ( int ) ( d4 * 256D ) ; int i2 = ( int ) ( d5 * 256D ) ; int j2 = ( int ) ( d6 * 256D ) ; int k2 = ( l1 << 16 ) + ( i2 << 8 ) + j2 ; k2 = method373 ( k2 , d ) ; if ( k2 == 0 ) k2 = 1 ; anIntArray1482 [ j ++ ] = k2 ; } } for ( int l = 0 ; l < 51 ; l ++ ) if ( aBackgroundArray1474s [ l ] != null ) { int ai [ ] = aBackgroundArray1474s [ l ] . anIntArray1451 ; anIntArrayArray1483 [ l ] = new int [ ai . length ] ; for ( int j1 = 0 ; j1 < ai . length ; j1 ++ ) { anIntArrayArray1483 [ l ] [ j1 ] = method373 ( ai [ j1 ] , d ) ; if ( ( anIntArrayArray1483 [ l ] [ j1 ] & f8f8ff ) == 0 && j1 != 0 ) anIntArrayArray1483 [ l ] [ j1 ] = 1 ; } } for ( int i1 = 0 ; i1 < 51 ; i1 ++ ) method370 ( i1 ) ; }
tr	OUT	++	public boolean remove ( ) { if ( expectedModCount != modCount ) throw new ConcurrentModificationException ( ) ; CircularLinkedList . this . remove ( current ) ; expectedModCount ++ ; return true ; }
tr	ORE	<	public List < boolean [ ] > getDevices ( ) { return devices ; }
tr	OAS	/=	public static String longToName ( long l ) { int i = 0 ; char ac [ ] = new char [ 12 ] ; while ( l != 0 ) { long l1 = l ; l /= 37 ; ac [ 11 - i ++ ] = VALID_CHARS [ ( int ) ( l1 - l * 37 ) ] ; } return new String ( ac , 12 - i , i ) ; }
tr	KEH	try	public static Method getStaticMethod ( class < ? > clazz , String methodName , class < ? > ... args ) { assert . notNull ( clazz , "Class must not be null" ) ; assert . notNull ( methodName , "Method name must not be null" ) ; try { Method method = clazz . getMethod ( methodName , args ) ; return Modifier . isStatic ( method . getModifiers ( ) ) ? method : null ; } catch ( NoSuchMethodException ex ) { return null ; } }
tr	KEH	finally	public void add ( Object o ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int len = objs . length ; Object [ ] newObjs = Arrays . copyOf ( objs , len + 1 ) ; newObjs [ len ] = o ; objs = newObjs ; } finally { lock . unlock ( ) ; } }
tr	OUT	++	public void fireBeforeWrite ( LegacyInstr i , int address , State state , int data_addr , byte value ) { if ( data_addr < ramSize ) { if ( wcount [ address ] == null ) wcount [ address ] = new long [ ramSize ] ; wcount [ address ] [ data_addr ] ++ ; } }
tr	OUT	++	@ Override public Profile [ ] findProfilesByCriteria ( ProfileCriteria ... criteria ) { try { HttpBody body = new HttpBody ( gson . toJson ( criteria ) ) ; List < HttpHeader > headers = new ArrayList < HttpHeader > ( ) ; headers . add ( new HttpHeader ( "Content-Type" , "application/json" ) ) ; List < Profile > profiles = new ArrayList < Profile > ( ) ; for ( int i = 1 ; i <= MAX_PAGES_TO_CHECK ; i ++ ) { ProfileSearchResult result = post ( new URL ( "https://api.mojang.com/profiles/page/" + i ) , body , headers ) ; if ( result . getSize ( ) == 0 ) { break ; } profiles . addAll ( Arrays . asList ( result . getProfiles ( ) ) ) ; } return profiles . toArray ( new Profile [ profiles . size ( ) ] ) ; } catch ( Exception e ) { return new Profile [ 0 ] ; } }
tr	SYM	.	private void writeSectionOneTotals ( ) { writef ( BODY_FORMAT_SECTION_1 , SECTION_1_TITLE_1 , report . parsingErrors ( ) . size ( ) , SECTION_1_TITLE_2 , report . validationErrors ( ) . size ( ) ) ; }
tr	KMD	public	public void removeTrain ( TrackBlock b , int trainId ) { trackModel . removeTrain ( b , trainId ) ; }
tr	KPT	double	public double getMaxTransmissionRange ( ) { return Math . sqrt ( squareRadius ) ; }
tr	OAS	/=	public void mouseDown ( MouseEvent me ) { guiUsedMouseDown = false ; if ( getWindows ( ) . mouseDown ( me ) ) { guiUsedMouseDown = true ; return ; } int chx = ( - getWorld ( ) . getScreenX ( ) ) + lastmx ; int chy = ( - getWorld ( ) . getScreenY ( ) ) + lastmy ; chx /= 50 ; chy /= 50 ; if ( chx < PavoHelper . getGameWidth ( getWorld ( ) . getWorldSize ( ) ) * 2 && chy < PavoHelper . getGameHeight ( getWorld ( ) . getWorldSize ( ) ) * 2 && chx >= 0 && chy >= 0 ) { Tile < Entity > e = getWorld ( ) . getEntityManager ( ) . getTile ( chy , chx ) ; if ( e != null ) { int acuratex = ( - getWorld ( ) . getScreenX ( ) ) + lastmx - ( chx * 50 ) ; int acuratey = ( - getWorld ( ) . getScreenY ( ) ) + lastmy - ( chy * 50 ) ; Location l = e . getEntity ( ) . getLocation ( ) ; acuratex += ( chx - l . getCol ( ) ) * 50 ; acuratey += ( chy - l . getRow ( ) ) * 50 ; e . getEntity ( ) . onMouseDown ( acuratex , acuratey , me . getButton ( ) == MouseEvent . BUTTON1 ) ; } } if ( chx == yearf && chy == yearl ) { gJsiw = ! gJsiw ; RoketUtils . submitAchievement ( RoketGamerData . ACHIEVEMENT_DAVE ) ; } }
tr	OAR	-	private final void step1ab ( ) { if ( b [ k ] == s ) { if ( ends ( "sses" ) ) { k -= 2 ; } else if ( ends ( "ies" ) ) { setto ( "i" ) ; } else if ( b [ k - 1 ] != s ) { k -- ; } } if ( ends ( "eed" ) ) { if ( m ( ) > 0 ) k -- ; } else if ( ( ends ( "ed" ) || ends ( "ing" ) ) && vowelinstem ( ) ) { k = j ; if ( ends ( "at" ) ) setto ( "ate" ) ; else if ( ends ( "bl" ) ) setto ( "ble" ) ; else if ( ends ( "iz" ) ) setto ( "ize" ) ; else if ( doublec ( k ) ) { k -- ; { int ch = b [ k ] ; if ( ch == l || ch == s || ch == z ) k ++ ; } } else if ( m ( ) == 1 && cvc ( k ) ) setto ( "e" ) ; } }
tr	OLB	||	public int largestRectangleArea ( int [ ] heights ) { Deque < Integer > deque = new LinkedList < > ( ) ; int maxArea = 0 ; int i = 0 ; while ( i < heights . length ) { int height = heights [ i ] ; if ( deque . isEmpty ( ) || height > heights [ deque . peekLast ( ) ] ) { deque . add ( i ++ ) ; } else { int targetHeight = heights [ deque . removeLast ( ) ] ; int area = targetHeight * ( deque . isEmpty ( ) ? i : i - deque . peekLast ( ) - 1 ) ; if ( area > maxArea ) { maxArea = area ; } } } while ( ! deque . isEmpty ( ) ) { int targetHeight = heights [ deque . removeLast ( ) ] ; int area = targetHeight * ( deque . isEmpty ( ) ? i : i - deque . peekLast ( ) - 1 ) ; if ( area > maxArea ) { maxArea = area ; } } return maxArea ; }
tr	KPT	int	@ Override public int getRowCount ( ) { return this . cardNames . length ; }
tr	KMD	public	public void setLimitations ( Facility . Limitations value ) { this . limitations = value ; }
tr	ORE	<	public class < ? extends Condition > getConditionClass ( ) { return this . conditionClass ; }
tr	KPT	double	public int compare ( Object o1 , Object o2 ) { Map . Entry e1 = ( Map . Entry ) o1 ; Map . Entry e2 = ( Map . Entry ) o2 ; double first = ( double ) e1 . getValue ( ) ; double second = ( double ) e2 . getValue ( ) ; return first . compareTo ( second ) ; }
tr	ORE	<	public LevelMenuScreen ( App a ) { super ( a ) ; setBackgroundColor ( BG_COL ) ; _boxes = new ArrayList < LevelBox > ( ) ; initBoxes ( ) ; boolean allOpen ; allOpen = false ; if ( allOpen ) { for ( LevelBox box : _boxes ) { box . setLevelOpen ( true ) ; } } loadLevel ( ) ; }
tr	KFC	return	public int getAttribute_count ( ) { return attribute_count ; }
tr	OAS	<<=	private static int crc_entry ( int index ) { int r = index << 24 ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( ( r & 80000000 ) != 0 ) { r = ( r << 1 ) ^ 04c11db7 ; } else { r <<= 1 ; } } return ( r & ffffffff ) ; }
tr	OUT	++	protected void readEnemyLaunchers ( ) { NodeList launchers = root . getElementsByTagName ( "launcher" ) ; for ( int i = 0 ; i < launchers . getLength ( ) ; i ++ ) { Element tempLauncher = ( Element ) launchers . item ( i ) ; String idLauncher = tempLauncher . getAttribute ( "id" ) ; boolean isHidden = boolean . parseBoolean ( tempLauncher . getAttribute ( "isHidden" ) ) ; warControl . addEnemyLauncher ( idLauncher , isHidden ) ; IdGenerator . updateEnemyLauncherId ( idLauncher ) ; NodeList missiles = tempLauncher . getElementsByTagName ( "missile" ) ; readMissilesForGivenLauncher ( missiles , idLauncher ) ; } IdGenerator . updateFinalEnemyMissileId ( ) ; IdGenerator . updateFinalEnemyLauncherId ( ) ; }
tr	KPT	int	@ Override public void drawTo ( Graphics g ) { GameUtilities . fillRect ( g , this , getColor1 ( ) ) ; GameUtilities . drawRect ( g , this , getColor2 ( ) ) ; g . setColor ( getColorRange ( ) ) ; g . drawOval ( ( int ) ( getPos ( ) . getX ( ) - RANGE ) , ( int ) ( getPos ( ) . getY ( ) - RANGE ) , 2 * RANGE , 2 * RANGE ) ; }
tr	SYM	(	public short UShort ( ) throws IOException { return ( short ) ( UByte ( ) + ( UByte ( ) << 8 ) ) ; }
tr	OAR	-	private void update ( ) { final ThreadMXBean bean = ManagementFactory . getThreadMXBean ( ) ; final long [ ] ids = bean . getAllThreadIds ( ) ; for ( long id : ids ) { if ( id == getId ( ) ) { continue ; } final long cpuTime = bean . getThreadCpuTime ( id ) ; final long userTime = bean . getThreadUserTime ( id ) ; if ( cpuTime == - 1 || userTime == - 1 ) { continue ; } ThreadInfo info = cpu . getThread ( id ) ; if ( info == null ) { info = cpu . monitor ( id ) . getThreadInfo ( ) ; } Times times = info . getTimes ( ) ; if ( times == null ) { times = new Times ( id , new Period ( cpuTime , cpuTime ) , new Period ( userTime , userTime ) ) ; } else { times . getCpuTime ( ) . setEndTime ( cpuTime ) ; times . getUserTime ( ) . setEndTime ( userTime ) ; } } }
tr	ORE	<=	public static boolean isBetween ( double x , int lower , int upper ) { return lower <= x && x <= upper ; }
tr	OAS	&=	public boolean saveAs ( ) { boolean bOK = true ; bOK &= saveImageAs ( ) ; bOK &= saveCoordsAs ( ) ; return bOK ; }
tr	OLB	&&	void proc ( ) { if ( left == - 1 ) { rate = 0 ; h = 1 ; rep = "x" ; - . add ( rep ) ; return ; } rs [ left ] . proc ( ) ; rs [ right ] . proc ( ) ; - . addAll ( rs [ left ] . - ) ; - . addAll ( rs [ right ] . - ) ; int c = 0 ; for ( String s : - ) if ( rs [ left ] . - . contains ( s ) && rs [ right ] . - . contains ( s ) ) c ++ ; rate = 1. * c / - . size ( ) ; num += rs [ left ] . num + rs [ right ] . num ; if ( rs [ left ] . h < rs [ right ] . h || rs [ left ] . h == rs [ right ] . h && rs [ left ] . num < rs [ right ] . num || rs [ left ] . h == rs [ right ] . h && rs [ left ] . num == rs [ right ] . num && rs [ left ] . rep . compareTo ( rs [ right ] . rep ) > 0 ) { int t = left ; left = right ; right = t ; } h = Math . max ( rs [ left ] . h , rs [ right ] . h ) + 1 ; rep = "(" + rs [ left ] . rep + " " + rs [ right ] . rep + ")" ; - . add ( rep ) ; }
tr	OLB	&&	public String patientForDoctor ( Vector < StaffInfo > staff , String toMatch ) { DB . db . openConnection ( ) ; StringBuffer info = new StringBuffer ( ) ; TreeSet < String > tree = new TreeSet ( ) ; try { info . append ( "<table>" ) ; int ind = - 1 ; String lName = toMatch . substring ( 0 , toMatch . indexOf ( " " ) ) ; String dBirth = toMatch . substring ( toMatch . indexOf ( "(" ) + 1 , toMatch . indexOf ( ")" ) ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getLname ( ) . equalsIgnoreCase ( lName ) && staff . get ( i ) . getbDate ( ) . toString ( ) . equalsIgnoreCase ( dBirth ) ) { ind = i ; } } ResultSet rs = DB . db . staff ( staff . get ( ind ) . getLname ( ) , staff . get ( ind ) . getbDate ( ) ) ; while ( rs . next ( ) ) { ResultSet rsh = DB . db . schedule ( rs . getInt ( "id" ) , null ) ; while ( rsh . next ( ) ) { ResultSet rp = DB . db . patient ( rsh . getInt ( "patientid" ) ) ; while ( rp . next ( ) ) { String tmp = "" ; tmp += "<tr><td>" ; tmp += "<b>" + rp . getString ( "lname" ) ; tmp += "  " + rp . getString ( "fname" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "Date of birth: <b>" + rp . getDate ( "bdate" ) . toString ( ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "E-mail: <b>" + rp . getString ( "email" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "Address: <b>" + rp . getString ( "address" ) + "  " + rp . getString ( "zip" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "Phone: <b>" + rp . getString ( "phone" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "MedCard number: <br /><b>" + rp . getString ( "medcard" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "Insurance number: <br /><b>" + rp . getString ( "insurrance" ) + "</b>" ; tmp += "</tr></td>" ; tmp += "<tr><td>" ; tmp += "</tr></td>" ; tree . add ( tmp ) ; } } } for ( String t : tree ) { info . append ( t ) ; } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
tr	OUT	++	protected void serialize_dict ( Map < ? , ? > dict , PrintWriter p , int level ) { if ( dict . size ( ) == 0 ) { p . print ( "{}" ) ; return ; } int counter = 0 ; if ( this . indent ) { String innerindent = "  " ; for ( int i = 0 ; i < level ; ++ i ) innerindent += "  " ; p . print ( "{\n" ) ; Map < ? , ? > outputdict = dict ; try { outputdict = new TreeMap < Object , Object > ( dict ) ; } catch ( ClassCastException x ) { } for ( Map . Entry < ? , ? > e : outputdict . entrySet ( ) ) { p . print ( innerindent ) ; serialize ( e . getKey ( ) , p , level + 1 ) ; p . print ( ": " ) ; serialize ( e . getValue ( ) , p , level + 1 ) ; counter ++ ; if ( counter < dict . size ( ) ) p . print ( " \n" ) ; } p . print ( "\n" ) ; for ( int i = 0 ; i < level ; ++ i ) p . print ( "  " ) ; p . print ( "}" ) ; } else { p . print ( "{" ) ; for ( Map . Entry < ? , ? > e : dict . entrySet ( ) ) { serialize ( e . getKey ( ) , p , level + 1 ) ; p . print ( ":" ) ; serialize ( e . getValue ( ) , p , level + 1 ) ; counter ++ ; if ( counter < dict . size ( ) ) p . print ( " " ) ; } p . print ( "}" ) ; } }
tr	KFC	return	public String getAvailability ( ) { return availability ; }
tr	OLB	&&	public boolean contains ( M metadata ) { return ( metadata != null && inputMap . containsKey ( metadata . getIdentifier ( ) ) ) ; }
tr	SYM	)	public void setName ( String name ) { this . name = name ; }
tr	KFC	return	public static String [ ] extractFormalParameters ( String formalParametersExpression ) { return extractFormalParameters ( formalParametersExpression , false ) ; }
tr	KEH	try	private final int jjMoveNfa_0 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 83 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 7fffffff ; for ( ; ; ) { if ( ++ jjround == 7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1 << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 65 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 76 ; else if ( curChar == 47 ) { if ( kind > 7 ) kind = 7 ; jjCheckNAddStates ( 0 , 2 ) ; } if ( curChar == 42 ) jjCheckNAdd ( 71 ) ; break ; case 6 : if ( ( 1ffffffff & l ) != 0 ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } else if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddStates ( 3 , 9 ) ; else if ( curChar == 47 ) jjAddStates ( 10 , 12 ) ; else if ( curChar == 36 ) { if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; } else if ( curChar == 34 ) jjstateSet [ jjnewStateCnt ++ ] = 41 ; else if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; else if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; if ( ( 3fe000000000000 & l ) != 0 ) { if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 8 , 9 ) ; } else if ( curChar == 48 ) { if ( kind > 60 ) kind = 60 ; jjCheckNAddStates ( 15 , 17 ) ; } else if ( curChar == 34 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 0 : if ( ( 1ffffffff & l ) == 0 ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 1 : if ( curChar == 33 ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 2 : if ( ( ffffffffffffdbff & l ) != 0 ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 3 : if ( ( 2400 & l ) != 0 && kind > 8 ) kind = 8 ; break ; case 4 : if ( curChar == 10 && kind > 8 ) kind = 8 ; break ; case 5 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 7 : if ( ( 3fe000000000000 & l ) == 0 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 8 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; break ; case 11 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddStates ( 24 , 26 ) ; break ; case 13 : if ( ( 280000000000 & l ) != 0 ) jjCheckNAdd ( 14 ) ; break ; case 14 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddTwoStates ( 14 , 15 ) ; break ; case 16 : if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; break ; case 17 : if ( ( ffffff7fffffdbff & l ) != 0 ) jjCheckNAdd ( 18 ) ; break ; case 18 : if ( curChar == 39 && kind > 66 ) kind = 66 ; break ; case 20 : if ( ( 8400000000 & l ) != 0 ) jjCheckNAdd ( 18 ) ; break ; case 21 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAddTwoStates ( 22 , 18 ) ; break ; case 22 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAdd ( 18 ) ; break ; case 23 : if ( ( f000000000000 & l ) != 0 ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAdd ( 22 ) ; break ; case 25 : if ( curChar == 34 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 26 : if ( ( fffffffbffffdbff & l ) != 0 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 28 : if ( ( 8400000000 & l ) != 0 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 29 : if ( curChar == 34 && kind > 67 ) kind = 67 ; break ; case 30 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAddStates ( 27 , 30 ) ; break ; case 31 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 32 : if ( ( f000000000000 & l ) != 0 ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 33 : if ( ( ff000000000000 & l ) != 0 ) jjCheckNAdd ( 31 ) ; break ; case 34 : case 40 : if ( curChar == 34 ) jjCheckNAddTwoStates ( 35 , 38 ) ; break ; case 35 : if ( ( fffffffbffffffff & l ) != 0 ) jjCheckNAddStates ( 31 , 33 ) ; break ; case 36 : if ( curChar == 34 && kind > 68 ) kind = 68 ; break ; case 37 : if ( curChar == 34 ) jjstateSet [ jjnewStateCnt ++ ] = 36 ; break ; case 38 : if ( curChar == 34 ) jjstateSet [ jjnewStateCnt ++ ] = 37 ; break ; case 39 : if ( curChar == 34 ) jjCheckNAddStates ( 34 , 36 ) ; break ; case 41 : if ( curChar == 34 ) jjstateSet [ jjnewStateCnt ++ ] = 34 ; break ; case 42 : if ( curChar == 34 ) jjstateSet [ jjnewStateCnt ++ ] = 41 ; break ; case 43 : if ( curChar != 36 ) break ; if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; break ; case 44 : if ( ( 3ff001000000000 & l ) == 0 ) break ; if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; break ; case 45 : if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddStates ( 3 , 9 ) ; break ; case 46 : if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddTwoStates ( 46 , 47 ) ; break ; case 47 : if ( curChar != 46 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddStates ( 37 , 39 ) ; break ; case 48 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddStates ( 37 , 39 ) ; break ; case 50 : if ( ( 280000000000 & l ) != 0 ) jjCheckNAdd ( 51 ) ; break ; case 51 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddTwoStates ( 51 , 15 ) ; break ; case 52 : if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddTwoStates ( 52 , 53 ) ; break ; case 54 : if ( ( 280000000000 & l ) != 0 ) jjCheckNAdd ( 55 ) ; break ; case 55 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 64 ) kind = 64 ; jjCheckNAddTwoStates ( 55 , 15 ) ; break ; case 56 : if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddStates ( 40 , 42 ) ; break ; case 58 : if ( ( 280000000000 & l ) != 0 ) jjCheckNAdd ( 59 ) ; break ; case 59 : if ( ( 3ff000000000000 & l ) != 0 ) jjCheckNAddTwoStates ( 59 , 15 ) ; break ; case 60 : if ( curChar != 48 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddStates ( 15 , 17 ) ; break ; case 62 : if ( ( 3ff000000000000 & l ) == 0 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 62 , 9 ) ; break ; case 63 : if ( ( ff000000000000 & l ) == 0 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 63 , 9 ) ; break ; case 64 : if ( curChar == 47 ) jjAddStates ( 10 , 12 ) ; break ; case 66 : if ( ( ffffffffffffdbff & l ) == 0 ) break ; if ( kind > 7 ) kind = 7 ; jjCheckNAddStates ( 0 , 2 ) ; break ; case 67 : if ( ( 2400 & l ) != 0 && kind > 7 ) kind = 7 ; break ; case 68 : if ( curChar == 10 && kind > 7 ) kind = 7 ; break ; case 69 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 68 ; break ; case 70 : if ( curChar == 42 ) jjCheckNAdd ( 71 ) ; break ; case 71 : if ( ( fffffbffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 71 , 72 ) ; break ; case 72 : if ( curChar == 42 ) jjCheckNAddStates ( 43 , 45 ) ; break ; case 73 : if ( ( ffff7bffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 74 , 72 ) ; break ; case 74 : if ( ( fffffbffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 74 , 72 ) ; break ; case 75 : if ( curChar == 47 && kind > 9 ) kind = 9 ; break ; case 76 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 77 , 78 ) ; break ; case 77 : if ( ( fffffbffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 77 , 78 ) ; break ; case 78 : if ( curChar == 42 ) jjCheckNAddStates ( 46 , 48 ) ; break ; case 79 : if ( ( ffff7bffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 80 , 78 ) ; break ; case 80 : if ( ( fffffbffffffffff & l ) != 0 ) jjCheckNAddTwoStates ( 80 , 78 ) ; break ; case 81 : if ( curChar == 47 && kind > 69 ) kind = 69 ; break ; case 82 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 76 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1 << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : case 44 : if ( ( 7fffffe87fffffe & l ) == 0 ) break ; if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; break ; case 2 : jjAddStates ( 21 , 23 ) ; break ; case 9 : if ( ( 100000001000 & l ) != 0 && kind > 60 ) kind = 60 ; break ; case 12 : if ( ( 2000000020 & l ) != 0 ) jjAddStates ( 49 , 50 ) ; break ; case 15 : if ( ( 5000000050 & l ) != 0 && kind > 64 ) kind = 64 ; break ; case 17 : if ( ( ffffffffefffffff & l ) != 0 ) jjCheckNAdd ( 18 ) ; break ; case 19 : if ( curChar == 92 ) jjAddStates ( 51 , 53 ) ; break ; case 20 : if ( ( 14404410000000 & l ) != 0 ) jjCheckNAdd ( 18 ) ; break ; case 26 : if ( ( ffffffffefffffff & l ) != 0 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 27 : if ( curChar == 92 ) jjAddStates ( 54 , 56 ) ; break ; case 28 : if ( ( 14404410000000 & l ) != 0 ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 35 : jjAddStates ( 31 , 33 ) ; break ; case 49 : if ( ( 2000000020 & l ) != 0 ) jjAddStates ( 57 , 58 ) ; break ; case 53 : if ( ( 2000000020 & l ) != 0 ) jjAddStates ( 59 , 60 ) ; break ; case 57 : if ( ( 2000000020 & l ) != 0 ) jjAddStates ( 61 , 62 ) ; break ; case 61 : if ( ( 100000001000000 & l ) != 0 ) jjCheckNAdd ( 62 ) ; break ; case 62 : if ( ( 7e0000007e & l ) == 0 ) break ; if ( kind > 60 ) kind = 60 ; jjCheckNAddTwoStates ( 62 , 9 ) ; break ; case 66 : if ( kind > 7 ) kind = 7 ; jjAddStates ( 0 , 2 ) ; break ; case 71 : jjCheckNAddTwoStates ( 71 , 72 ) ; break ; case 73 : case 74 : jjCheckNAddTwoStates ( 74 , 72 ) ; break ; case 77 : jjCheckNAddTwoStates ( 77 , 78 ) ; break ; case 79 : case 80 : jjCheckNAddTwoStates ( 80 , 78 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar >> 8 ) ; int i1 = hiByte >> 6 ; long l1 = 1 << ( hiByte & 077 ) ; int i2 = ( curChar & ff ) >> 6 ; long l2 = 1 << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } if ( jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; } break ; case 0 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 2 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 21 , 23 ) ; break ; case 17 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 26 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 18 , 20 ) ; break ; case 35 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 31 , 33 ) ; break ; case 43 : case 44 : if ( ! jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 70 ) kind = 70 ; jjCheckNAdd ( 44 ) ; break ; case 66 : if ( ! jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 7 ) kind = 7 ; jjAddStates ( 0 , 2 ) ; break ; case 71 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 71 , 72 ) ; break ; case 73 : case 74 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 74 , 72 ) ; break ; case 77 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 77 , 78 ) ; break ; case 79 : case 80 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 80 , 78 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 83 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } }
tr	OLB	||	public static boolean toBoolean ( byte [ ] data ) { return ( data == null || data . length == 0 ) ? false : data [ 0 ] != 00 ; }
tr	OLB	&&	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof Aggregator ) { Aggregator a = ( Aggregator ) o ; return this . aggregatorAS . equals ( a . aggregatorAS ) && this . aggregatorIP . equals ( a . aggregatorIP ) ; } return false ; }
tr	OLB	&&	public static void launchScoreDialog ( final Context context , final String score , final String displayScore , final String levelId , final Drawable gameIcon , final String gamePackage , final boolean fromSdk , final boolean skipModalDialog ) { final float scoreF = float . parseFloat ( score ) ; final SharedPreferences scoresPrefs = context . getSharedPreferences ( SCORES , 0 ) ; final SharedPreferences displayScoresPrefs = context . getSharedPreferences ( DISPLAY_SCORES , 0 ) ; final SharedPreferences orderPrefs = context . getSharedPreferences ( ORDER , 0 ) ; if ( scoresPrefs . contains ( levelId ) && orderPrefs . contains ( levelId ) ) { float personalBest = scoresPrefs . getFloat ( levelId , 0.0f ) ; String personalBestDisplay = displayScoresPrefs . getString ( levelId , "" ) ; boolean lowestScoreFirst = orderPrefs . getBoolean ( levelId , false ) ; boolean newBest ; if ( lowestScoreFirst ) { newBest = scoreF < personalBest ; } else { newBest = scoreF > personalBest ; } if ( newBest ) { saveLeaderboardInfoOnPhone ( context , scoreF , displayScore , levelId , null , true ) ; personalBestDisplay = displayScore ; } if ( newBest && ! skipModalDialog ) { LeaderboardScoreDialogFull d = new LeaderboardScoreDialogFull ( context , null , gamePackage , score , displayScore , levelId ) ; d . setFromSdk ( fromSdk ) ; d . show ( ) ; } else { LeaderboardScoreDialogTop d = new LeaderboardScoreDialogTop ( context , null , gamePackage , score , displayScore , levelId , personalBestDisplay , gameIcon ) ; if ( newBest && skipModalDialog ) { d . setPersonalBest ( true ) ; } d . setFromSdk ( fromSdk ) ; d . show ( ) ; } } else { saveLeaderboardInfoOnPhone ( context , scoreF , displayScore , levelId , null , true ) ; if ( skipModalDialog ) { LeaderboardScoreDialogTop d = new LeaderboardScoreDialogTop ( context , null , gamePackage , score , displayScore , levelId , displayScore , gameIcon ) ; d . setPersonalBest ( true ) ; d . setFromSdk ( fromSdk ) ; d . show ( ) ; } else { LeaderboardScoreDialogFull d = new LeaderboardScoreDialogFull ( context , null , gamePackage , score , displayScore , levelId ) ; d . setFromSdk ( fromSdk ) ; d . show ( ) ; } } }
tr	SYM	;	public String getAppName ( ) { return appName ; }
tr	OAR	-	public double moduloFloor ( double pos , int div ) { return pos - div * Math . floor ( pos / div ) ; }
tr	SYM	;	public S transform ( Tree < ASTValueData > node , S state ) { state = transformBefore ( node , state ) ; for ( Tree < ASTValueData > s : node . subtrees ) { state = subtreeTransformer ( s , state ) ; } state = transformAfter ( node , state ) ; return state ; }
tr	KFC	return	public int roll ( ) { int r1 = die . roll ( ) ; int r2 = die . roll ( ) ; if ( r1 == r2 ) { this . doubles ++ ; lastRollWasDoubles = true ; } return r1 + r2 ; }
tr	OLB	||	public static boolean match ( String pathSpec , String path , boolean noDefault ) throws IllegalArgumentException { char c = pathSpec . charAt ( 0 ) ; if ( c == / ) { if ( ! noDefault && pathSpec . length ( ) == 1 || pathSpec . equals ( path ) ) return true ; if ( pathSpec . endsWith ( "/*" ) && pathSpec . regionMatches ( 0 , path , 0 , pathSpec . length ( ) - 2 ) ) return true ; if ( path . startsWith ( pathSpec ) && path . charAt ( pathSpec . length ( ) ) == ; ) return true ; } else if ( c == * ) return path . regionMatches ( path . length ( ) - pathSpec . length ( ) + 1 , pathSpec , 1 , pathSpec . length ( ) - 1 ) ; return false ; }
tr	KFC	return	@ Override protected boolean isValidNonDropMove ( GameState state , int x , int y ) { return ( ( ( ( y == this . y + this . allegiance ) && ( x == this . x - 1 || x == this . x || x == this . x + 1 ) ) || ( ( y == this . y ) && ( x == this . x - 1 || x == this . x + 1 ) ) || ( ( y == this . y - this . allegiance ) && ( x == this . x ) ) ) && ! ( y < 0 || y > 8 ) && ! ( x < 0 || x > 8 ) && ( state . getPieceAt ( x , y ) . getAllegiance ( ) != this . allegiance ) ) ; }
tr	ORE	<	@ Override public List < MyLine > getLines ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
tr	KPT	double	private void addFieldListeners ( ) { nameField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setName ( nameField . getText ( ) ) ; nameField . setBackground ( Color . green ) ; } catch ( Exception ex ) { nameField . setBackground ( Color . red ) ; cage . setName ( "Name" ) ; nameField . setText ( "Name" ) ; } } } ) ; sizeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setSize ( double . parseDouble ( sizeField . getText ( ) ) ) ; sizeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { sizeField . setBackground ( Color . red ) ; cage . setSize ( Cage . MIN_CAGE_AREA ) ; sizeField . setText ( "" + Cage . MIN_CAGE_AREA ) ; } } } ) ; longitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLongitude ( double . parseDouble ( longitudeField . getText ( ) ) ) ; longitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { longitudeField . setBackground ( Color . red ) ; cage . setLongitude ( Cage . LONGITUDE_MIN ) ; longitudeField . setText ( "" + Cage . LONGITUDE_MIN ) ; } } } ) ; latitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLatitude ( double . parseDouble ( latitudeField . getText ( ) ) ) ; latitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { latitudeField . setBackground ( Color . red ) ; cage . setLatitude ( Cage . LATITUDE_MIN ) ; latitudeField . setText ( "" + Cage . LATITUDE_MIN ) ; } } } ) ; }
tr	OUT	++	protected void solve ( ) { Node root = graph . nodes . getNode ( 0 ) ; setParentEdge ( root , null ) ; addNode ( root ) ; while ( members . size ( ) < graph . nodes . size ( ) ) { if ( candidates . size ( ) == 0 ) throw new RuntimeException ( "graph is not fully connected" ) ; int minSlack = Integer . MAX_VALUE , slack ; Edge minEdge = null , edge ; for ( int i = 0 ; i < candidates . size ( ) && minSlack > 0 ; i ++ ) { edge = candidates . getEdge ( i ) ; slack = edge . getSlack ( ) ; if ( slack < minSlack ) { minSlack = slack ; minEdge = edge ; } } addEdge ( minEdge ) ; } graph . nodes . normalizeRanks ( ) ; }
tr	OUT	++	public static void main ( String [ ] args ) { BankAccount account = new BankAccount ( ) ; final double AMOUNT = 100 ; final int REPETITIONS = 100 ; final int THREADS = 100 ; for ( int i = 1 ; i <= THREADS ; i ++ ) { DepositRunnable d = new DepositRunnable ( account , AMOUNT , REPETITIONS ) ; WithdrawRunnable w = new WithdrawRunnable ( account , AMOUNT , REPETITIONS ) ; Thread dt = new Thread ( d ) ; Thread wt = new Thread ( w ) ; dt . start ( ) ; wt . start ( ) ; } }
tr	ORE	<	private void matchGood ( ) throws IllegalStateException { if ( ( matchStart < 0 ) || ( matchEnd < 0 ) ) { throw new IllegalStateException ( "There was no available match." ) ; } }
tr	KMD	public	public void setFecha ( Date fecha ) { this . fecha = fecha ; }
tr	KEH	try	private void jButton1MouseClicked ( java . awt . event . MouseEvent evt ) { String tipoNoSelecionado = XMLTreePanel . node_selecionado . getNodeName ( ) ; if ( tipoNoSelecionado . equals ( PainelDeControle . TAG_ARQUIVO ) ) { JOptionPane . showMessageDialog ( InterfaceUsuario . main , "Selecione uma pasta destino para copiar a pasta!!" ) ; return ; } String caminhoDestino = XMLTreePanel . getCaminhoSelecionado ( false ) ; caminhoDestino = caminhoDestino . substring ( 0 , caminhoDestino . length ( ) - 1 ) ; try { boolean resultado = PainelDeControle . middleware . moverPasta ( pastaCopiada , caminhoDestino ) ; if ( ! resultado ) { JOptionPane . showMessageDialog ( InterfaceUsuario . main , "N\u00E3o foi poss\u00EDvel mover a pasta" ) ; } } catch ( RemoteException ex ) { Logger . getLogger ( CopiarArquivo . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } close ( ) ; }
tr	KEH	try	public static void tcpServer ( int port , int tailleBuffer ) throws IOException { try ( ServerSocketChannel socket = ServerSocketChannel . open ( ) ) { InetSocketAddress local = new InetSocketAddress ( port ) ; socket . bind ( local ) ; try ( SocketChannel client = socket . accept ( ) ) { client . configureBlocking ( true ) ; for ( int i = 0 ; i < 100 ; i ++ ) { ByteBuffer buffer = ByteBuffer . allocate ( tailleBuffer ) ; buffer . clear ( ) ; client . read ( buffer ) ; buffer . flip ( ) ; String s = Utilitaires . buffToString ( buffer ) ; Utilitaires . out ( s ) ; if ( s . equals ( Message . SendOne ) ) { client . configureBlocking ( true ) ; Runnable task = new taskServeurReceiveOnePaquet ( client ) ; task . run ( ) ; } else if ( s . equals ( Message . EXCHANGE ) ) { client . configureBlocking ( true ) ; Runnable task = new taskServeurExchange ( client ) ; task . run ( ) ; } } } } }
tr	OUT	++	public Vector < Food > getVectorAllBreakfasts ( ) { int numOfElem = nl . getLength ( ) ; Vector < Food > breakfasts = new Vector ( numOfElem ) ; if ( nl != null && numOfElem > 0 ) { for ( int i = 0 ; i < numOfElem ; i ++ ) { Element el = ( Element ) nl . item ( i ) ; breakfasts . add ( i , getBreakfast ( el ) ) ; } } return breakfasts ; }
tr	OAS	/=	private static int countLuckyDigits ( long number ) { int count = 0 ; while ( number > 0 ) { long digit = number % 10 ; if ( digit == 4 || digit == 7 ) { count ++ ; } number /= 10 ; } return count ; }
tr	OLB	&&	@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof Style ) ) { return false ; } if ( obj == this ) { return true ; } Style _object = ( Style ) obj ; return _object . bold == bold && _object . color . equals ( color ) && _object . background . equals ( background ) && _object . underline == underline && _object . italic == italic ; }
tr	KMD	final	final Object pop ( ) { int size = stack . size ( ) ; return size == 0 ? null : stack . remove ( size - 1 ) ; }
tr	KPT	int	public int getWidth ( ) ;
tr	SYM	)	private void createSShell ( ) { sShell = new Shell ( SWT . APPLICATION_MODAL | SWT . DIALOG_TRIM ) ; sShell . setImage ( JZip . jzipImage ) ; sShell . setText ( "\uC774 \uD30C\uC77C\uC744 \uC5B4\uB5BB\uAC8C \uCC98\uB9AC\uD560\uAE4C\uC694?" ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . numColumns = 2 ; gridLayout . verticalSpacing = 10 ; gridLayout . horizontalSpacing = 10 ; gridLayout . makeColumnsEqualWidth = false ; sShell . setLayout ( gridLayout ) ; sShell . setSize ( new Point ( 360 , 80 ) ) ; GridData gridData ; icon = new Label ( sShell , SWT . NONE ) ; icon . setImage ( sShell . getDisplay ( ) . getSystemImage ( SWT . ICON_QUESTION ) ) ; gridData = new GridData ( ) ; gridData . horizontalAlignment = GridData . CENTER ; gridData . verticalAlignment = GridData . CENTER ; icon . setLayoutData ( gridData ) ; label = new Label ( sShell , SWT . HORIZONTAL | SWT . WRAP ) ; gridData = new GridData ( ) ; gridData . widthHint = 340 ; gridData . heightHint = - 1 ; label . setLayoutData ( gridData ) ; createComposite ( ) ; sShell . addShellListener ( new org . eclipse . swt . events . ShellAdapter ( ) { @ Override public void shellClosed ( org . eclipse . swt . events . ShellEvent e ) { select = Action . CANCEL ; } } ) ; }
tr	KFC	return	public boolean isServer ( ) { return isServer ; }
tr	OAS	<<=	public static void main ( String [ ] args ) { int x = 7 ; System . out . println ( "x = " + Integer . toBinaryString ( x ) ) ; System . out . println ( "x <<= 1 = " + Integer . toBinaryString ( x <<= 1 ) ) ; System . out . println ( "x <<= 1 = " + Integer . toBinaryString ( x <<= 1 ) ) ; System . out . println ( "x <<= 1 = " + Integer . toBinaryString ( x <<= 1 ) ) ; x = 7 ; System . out . println ( "x = " + Integer . toBinaryString ( x ) ) ; System . out . println ( "x >>= 1 = " + Integer . toBinaryString ( x >>= 1 ) ) ; System . out . println ( "x >>= 1 = " + Integer . toBinaryString ( x >>= 1 ) ) ; System . out . println ( "x >>= 1 = " + Integer . toBinaryString ( x >>= 1 ) ) ; }
tr	SYM	(	public void putOtherTextParam ( String key , String value ) { if ( this . udfParams == null ) { this . udfParams = new TaobaoHashMap ( ) ; } this . udfParams . put ( key , value ) ; }
tr	KMD	public	public String getConfigPath ( String filename ) ;
tr	KPT	int	@ Override public final int hashCode ( ) { return m_nHash ; }
tr	KPT	int	int askInt ( String question ) throws UIException ;
tr	KMD	public	public GuiField ( HexPoint p ) { this ( p , HexColor . EMPTY , 0 , null , null ) ; }
tr	KMD	public	public void setMainTag ( Tag tag ) ;
tr	OUT	++	public static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { if ( s . toLowerCase ( ) . charAt ( i ) != s . toLowerCase ( ) . charAt ( s . length ( ) - i - 1 ) ) { return false ; } } return true ; }
tr	SYM	.	public Usuario ( String telefono ) { this . telefono = telefono ; }
tr	OLB	||	public String nextToken ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) { st = new StringTokenizer ( br . readLine ( ) ) ; } return st . nextToken ( ) ; }
tr	OAR	-	final public Object term ( boolean requireEOF ) throws ParseException , java . io . IOException , UnsupportedVocabularyException { Object result = null ; if ( jj_2_1 ( 2147483647 ) ) { result = sentence ( false ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TRUE_CONSTANT : case FALSE_CONSTANT : case AND_CONSTANT : case OR_CONSTANT : case XOR_CONSTANT : case NOT_CONSTANT : case EQUIV_CONSTANT : case IMPLIES_CONSTANT : case FORALL_CONSTANT : case THEREEXISTS_CONSTANT : case THEREEXISTEXACTLY_CONSTANT : case THEREEXISTATMOST_CONSTANT : case THEREEXISTATLEAST_CONSTANT : case EXPANDSUBLFN_CONSTANT : case SUBLQUOTEFN_CONSTANT : case TRUE_GUID_CONSTANT : case FALSE_GUID_CONSTANT : case AND_GUID_CONSTANT : case OR_GUID_CONSTANT : case XOR_GUID_CONSTANT : case NOT_GUID_CONSTANT : case EQUIV_GUID_CONSTANT : case IMPLIES_GUID_CONSTANT : case FORALL_GUID_CONSTANT : case THEREEXISTS_GUID_CONSTANT : case THEREEXISTEXACTLY_GUID_CONSTANT : case THEREEXISTATMOST_GUID_CONSTANT : case THEREEXISTATLEAST_GUID_CONSTANT : case EXPANDSUBLFN_GUID_CONSTANT : case SUBLQUOTEFN_GUID_CONSTANT : case INTEGER : case float : case CONSTANT_NAME1 : case CONSTANT_NAME2 : case CONSTANT_GUID : case CONSTANT_GUID2 : case SIMPLE_VARIABLE : case META_VARIABLE : case STRING : result = atomicDenotationalTerm ( false ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } eof ( requireEOF ) ; { if ( true ) return result ; } throw new Error ( "Missing return statement in function" ) ; }
tr	KMD	private	private void initDefaultProperties ( Properties properties , FileOutputStream propertiesOut ) throws IOException { properties . setProperty ( "memory" , "1024" ) ; properties . setProperty ( "username" , "" ) ; properties . setProperty ( "password" , "" ) ; properties . setProperty ( "clientprefix" , "ic2" ) ; properties . setProperty ( "screenWidth" , "950" ) ; properties . setProperty ( "screenHeight" , "550" ) ; properties . setProperty ( "serverhost" , "kubach.tk" ) ; properties . setProperty ( "serverport" , "1488" ) ; properties . setProperty ( "updateurl" , "http://kubach.tk/update/%PREFIX%/%FILE%" ) ; properties . setProperty ( "skinurl" , "http://kubach.tk/getskin.php?user=%USERNAME%" ) ; properties . setProperty ( "skinuploadurl" , "http://kubach.tk/uploadskin.php" ) ; properties . setProperty ( "skinremoveurl" , "http://kubach.tk/removeskin.php" ) ; properties . setProperty ( "nativecheckurl" , "http://kubach.tk/NativeCheck.class" ) ; properties . setProperty ( "forgeversion" , "1.7.10" ) ; properties . setProperty ( "virgin" , "true" ) ; properties . setProperty ( "virgincondoms" , "http://kubach.tk/update/condoms.package" ) ; properties . setProperty ( "launcherChecksumUrl" , "http://kubach.tk/update/launcher/md5.txt" ) ; properties . setProperty ( "launcherDownloadUrl" , "http://kubach.tk/update/launcher/Kubach.jar" ) ; properties . store ( propertiesOut , null ) ; }
tr	KMD	public	public void add ( LibraryModel model ) { data . add ( model ) ; }
tr	OUT	++	public String getHighscoreString ( ) { String highscoreString = "" ; int max = 10 ; ArrayList < Score > scores ; scores = getScores ( ) ; int i = 0 ; int x = scores . size ( ) ; if ( x > max ) { x = max ; } while ( i < x ) { highscoreString += String . format ( "%10d.%15s%10d\n" , ( i + 1 ) , scores . get ( i ) . getName ( ) , scores . get ( i ) . getScore ( ) ) ; i ++ ; } return highscoreString ; }
tr	OAR	-	@ Override protected void paintBorder ( Graphics g ) { int x = 1 , y = 1 ; int w = getWidth ( ) - 2 , h = getHeight ( ) - 2 ; Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setStroke ( new BasicStroke ( anchoDeBorde ) ) ; g2 . setColor ( colorDeBorde ) ; g2 . drawRoundRect ( x , y , w , h , angle , angle ) ; g2 . dispose ( ) ; }
tr	KMD	public	public StringCount ( String source ) { this . source = source ; }
tr	SYM	(	public void setIsNotebookPageSheetArrowShown ( boolean isArrowShown ) { getComputer ( ) . setIsNotebookPageSheetArrowShown ( isArrowShown ) ; }
tr	OUT	++	public int uniquePaths ( int m , int n ) { if ( m < 1 || n < 1 ) { return 0 ; } int [ ] [ ] paths = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { paths [ i ] [ 1 ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { paths [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 2 ; j <= n ; j ++ ) { paths [ i ] [ j ] = paths [ i - 1 ] [ j ] + paths [ i ] [ j - 1 ] ; } } return paths [ m ] [ n ] ; }
tr	SYM	(	@ Override public void actionPerformed ( ActionEvent e ) { Party party = DAOProvider . getPartyDAO ( ) . get ( ( ( Item ) comboSourceParty . getSelectedItem ( ) ) . getId ( ) ) ; JOptionPane . showMessageDialog ( contentPanel , "Name: " + party . getName ( ) + "\n" + "Phone1: " + ( party . getPhone1 ( ) != null ? party . getPhone1 ( ) : "N/A" ) + "\n" + "Phone2: " + ( party . getPhone2 ( ) != null ? party . getPhone2 ( ) : "N/A" ) + "\n" + "Address: " + ( party . getAddress ( ) != null ? party . getAddress ( ) : "N/A" ) + "\n" + "Addition Information: " + ( party . getAddtionInformation ( ) != null ? party . getAddtionInformation ( ) : "N/A" ) , "Party Information" , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	OAR	-	static final public int packLong ( DataOutput os , long v ) throws IOException { if ( v < 0 ) { throw new IllegalArgumentException ( "negative value: v=" + v ) ; } if ( ( v >> 56 ) != 0 ) { os . write ( ( byte ) ( ( ff & ( v >> 56 ) ) | 80 ) ) ; os . write ( ( byte ) ( ff & ( v >> 48 ) ) ) ; os . write ( ( byte ) ( ff & ( v >> 40 ) ) ) ; os . write ( ( byte ) ( ff & ( v >> 32 ) ) ) ; os . write ( ( byte ) ( ff & ( v >> 24 ) ) ) ; os . write ( ( byte ) ( ff & ( v >> 16 ) ) ) ; os . write ( ( byte ) ( ff & ( v >> 8 ) ) ) ; os . write ( ( byte ) ( ff & v ) ) ; return 8 ; } final int nnibbles = getNibbleLength ( v ) ; final boolean evenNibbleCount = ( nnibbles == ( ( nnibbles >> 1 ) << 1 ) ) ; final int nbytes = ( ( nnibbles + 1 ) >> 1 ) + ( evenNibbleCount ? 1 : 0 ) ; int nwritten = 0 ; if ( evenNibbleCount ) { byte b = ( byte ) ( nbytes << 4 ) ; os . write ( b ) ; nwritten ++ ; for ( int i = ( nnibbles - 2 ) << 2 ; i >= 0 ; i -= 8 ) { b = ( byte ) ( ff & ( v >> i ) ) ; os . write ( b ) ; nwritten ++ ; } } else { byte highByte = ( byte ) ( ff & ( v >> ( ( nbytes - 1 ) * 8 ) ) ) ; byte b = ( byte ) ( ( nbytes << 4 ) | highByte ) ; os . write ( b ) ; nwritten ++ ; for ( int i = ( nnibbles - 3 ) << 2 ; i >= 0 ; i -= 8 ) { b = ( byte ) ( ff & ( v >> i ) ) ; os . write ( b ) ; nwritten ++ ; } } return nwritten ; }
tr	OAS	>>>=	static int ilog2 ( int v ) { int ret = 0 ; while ( v > 1 ) { ret ++ ; v >>>= 1 ; } return ( ret ) ; }
tr	SYM	)	public final String getTooltip ( ) { return tooltip ; }
tr	KFC	return	public static Membership read ( Connection connection , int id ) { Statement statement = null ; ResultSet resultset = null ; Membership membership = null ; try { String query = "select * from civicrm_membership where id=" . concat ( String . valueOf ( id ) ) ; statement = connection . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; resultset = statement . executeQuery ( query ) ; if ( resultset . first ( ) ) { membership = setMembership ( resultset ) ; } return membership ; } catch ( SQLException ex ) { Logger . getLogger ( ContactController . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return null ; } catch ( Exception e ) { Logger . getLogger ( ContactController . class . getName ( ) ) . log ( Level . SEVERE , null , e ) ; return null ; } }
tr	OAR	-	public ArrayList < Integer > mergeConsecutive ( int [ ] A ) { ArrayList < Integer > merge = new ArrayList < Integer > ( ) ; int sum = 0 ; boolean positive = false ; if ( A . length == 0 ) { return new ArrayList < Integer > ( ) ; } if ( A . length == 1 ) { merge . add ( A [ 0 ] ) ; return merge ; } if ( A [ 0 ] >= 0 ) { positive = true ; } sum += A [ 0 ] ; for ( int i = 1 ; i < A . length - 1 ; i ++ ) { if ( A [ i ] >= 0 ) { if ( positive ) { sum += A [ i ] ; } else { merge . add ( sum ) ; positive = true ; sum = 0 ; sum += A [ i ] ; } } else { if ( ! positive ) { sum += A [ i ] ; } else { System . out . println ( "sum" + sum ) ; merge . add ( sum ) ; positive = false ; sum = 0 ; sum += A [ i ] ; } } } if ( A [ A . length - 1 ] >= 0 ) { if ( positive ) { sum += A [ A . length - 1 ] ; merge . add ( sum ) ; } else { merge . add ( sum ) ; merge . add ( A [ A . length - 1 ] ) ; } } else { if ( ! positive ) { sum += A [ A . length - 1 ] ; merge . add ( sum ) ; } else { merge . add ( sum ) ; merge . add ( A [ A . length - 1 ] ) ; } } return merge ; }
tr	OAR	-	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; sieve ( ) ; matrix [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { matrix [ i ] = matrix [ i - 1 ] + ( isDivisibleByN ( i ) ? 1 : 0 ) ; } int T = scanner . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int L = scanner . nextInt ( ) ; int R = scanner . nextInt ( ) ; pw . println ( matrix [ R ] - matrix [ L - 1 ] ) ; } scanner . close ( ) ; pw . close ( ) ; }
tr	KPT	int	private void decay ( ) { if ( activation != MINACTIVATION ) { int ammount = ( int ) Math . ceil ( 0.01 * ( MAXACTIVATION - conceptualDepth ) * activation ) ; if ( activation - ammount <= MINACTIVATION ) { activation = MINACTIVATION ; } else { activation -= ammount ; } } }
tr	OUT	--	private void reverseRightOf ( final int start ) { int i = start + 1 ; int j = n - 1 ; while ( i < j ) { swap ( i , j ) ; ++ i ; -- j ; } }
tr	OLB	&&	private void recheckFoundStatus ( ) { if ( _thisFile . isFile ( ) && _thisFile . exists ( ) ) { _status = PlaylistEntryStatus . Found ; } else { _status = PlaylistEntryStatus . Missing ; _isFixed = false ; } }
tr	SYM	;	com . google . protobuf . ByteString getGoPackageBytes ( ) ;
tr	KPT	int	private JButton addButton ( int row , String action ) { JButton button = new JButton ( action ) ; GridBagConstraints gbc_button = new GridBagConstraints ( ) ; gbc_button . anchor = GridBagConstraints . NORTHWEST ; gbc_button . insets = insetsLabel ; gbc_button . gridx = 1 ; gbc_button . gridy = row ; button . addActionListener ( this ) ; dataPanel . add ( button , gbc_button ) ; return button ; }
tr	KPT	int	public static S2CellId fromPoint ( S2Point p ) { int face = S2Projections . xyzToFace ( p ) ; R2Vector uv = S2Projections . validFaceXyzToUv ( face , p ) ; int i = stToIJ ( S2Projections . uvToST ( uv . x ( ) ) ) ; int j = stToIJ ( S2Projections . uvToST ( uv . y ( ) ) ) ; return fromFaceIJ ( face , i , j ) ; }
tr	KPT	double	public static void main ( String [ ] args ) { int N = Integer . parseInt ( args [ 0 ] ) ; double [ ] [ ] numTable = new double [ N ] [ N ] ; for ( int m = 0 ; m < N ; m ++ ) { for ( int n = 0 ; n < N ; n ++ ) { numTable [ m ] [ n ] = double . parseDouble ( args [ m * N + n + 1 ] ) ; System . out . print ( numTable [ m ] [ n ] + " " ) ; } System . out . println ( ) ; } }
tr	SYM	(	public void start ( Animator animator ) { animator . setStartTime ( System . currentTimeMillis ( ) ) ; animator . start ( ) ; running . add ( animator ) ; synchronized ( this ) { notifyAll ( ) ; } }
tr	OLB	||	@ Override public void keyReleased ( KeyEvent e ) { String searchTerm = searchField . getText ( ) ; searchTerm = searchTerm . toLowerCase ( ) ; ArrayList < String > searchResults = new ArrayList < String > ( ) ; for ( String folder : folderNames ) { folder = Util . cutPath ( folder ) ; if ( searchTerm . length ( ) == 0 || folder . toLowerCase ( ) . indexOf ( searchTerm ) >= 0 ) searchResults . add ( folder ) ; } resultsList . setListData ( searchResults . toArray ( ) ) ; resultsList . setSelectedIndex ( 0 ) ; if ( e != null && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { goToEntered ( ) ; } }
tr	OUT	++	private void jButton6ChangDispalyMode ( java . awt . event . ActionEvent evt ) { if ( this . testState != this . playback ) { return ; } if ( this . tstErrors ) { System . out . println ( "================" ) ; System . out . println ( "Event lengh before noise loading: " + events . size ( ) ) ; this . EventListLoad ( ) ; System . out . println ( "Event lengh after noise loading: " + events . size ( ) ) ; this . tstErrors = false ; } int numTrials = seqStartIndexes . size ( ) - 1 ; int sumSuccess = 0 ; int len = this . partialCueLength ; boolean fromLast = this . partialCueBackwards ; curSeq . removeAllElements ( ) ; curPSeq . removeAllElements ( ) ; int selidx = ( ( Integer ) seqStartIndexes . get ( this . seq_ptr ) ) . intValue ( ) ; int epiLen = ( ( Integer ) seqLenIndexes . get ( this . seq_ptr ) ) . intValue ( ) ; if ( len > epiLen ) { len = epiLen ; } int sidx = 0 ; if ( selidx == 0 ) { this . isNewStart = true ; } else if ( events . get ( selidx - 1 ) . isForcedTer ( events . get ( selidx - 1 ) ) ) { this . isNewStart = true ; } else { this . isNewStart = false ; } for ( int i = 0 ; i < epiLen ; i ++ ) { this . curSeq . add ( this . events . get ( selidx + i ) ) ; } int winidx = this . seq_ptr ; if ( winidx >= 0 ) { curPSeq = episodic . getSeqEvents ( episodic . seqLearner . getOneSeq ( ( ( Integer ) seqWinIndexes . get ( winidx ) ) . intValue ( ) ) ) ; } this . jLabel10 . setText ( "PREDICTION ACCURACY " + "(" + selidx + "~" + ( selidx + epiLen - 1 ) + ")" + "/(" + 0 + "~" + ( events . size ( ) - 1 ) + ")" ) ; curPStory = getStoryString ( curPSeq ) ; this . jLabel9 . setText ( "Retrieved Episode: (" + winidx + "/" + ( this . episodic . seqLearner . numCode - 1 ) + ")" ) ; this . jLabel11 . setText ( "" ) ; timer . start ( ) ; }
tr	KMD	public	public WbXmlContent ( WbXmlAttribute pi ) { this ( ) ; this . setPi ( pi ) ; }
tr	ORE	<	public static final int [ ] [ ] int_mat ( final int [ ] [ ] m ) { final int [ ] [ ] r = new int [ m . length ] [ ] ; for ( int i = 0 ; i < m . length ; i ++ ) { r [ i ] = new int [ m [ i ] . length ] ; System . arraycopy ( m [ i ] , 0 , r [ i ] , 0 , m [ i ] . length ) ; } return r ; }
tr	SYM	(	public void sortAttributes ( Comparator < ? super Attribute > comparator ) { if ( attributes != null ) { attributes . sort ( comparator ) ; } }
tr	OAS	%=	private static int encodeVerticalRate ( int verticalRate ) { if ( verticalRate < 0 ) return 0 ; if ( verticalRate > 32608 ) return 511 ; int result = ( ( int ) Math . round ( verticalRate / 64.0 ) ) + 1 ; result %= 512 ; return result ; }
tr	OLB	||	private void populateMap ( Object bean ) { class klass = bean . getClass ( ) ; boolean includeSuperClass = klass . getClassLoader ( ) != null ; Method [ ] methods = includeSuperClass ? klass . getMethods ( ) : klass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i += 1 ) { try { Method method = methods [ i ] ; if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { String name = method . getName ( ) ; String key = "" ; if ( name . startsWith ( "get" ) ) { if ( "getClass" . equals ( name ) || "getDeclaringClass" . equals ( name ) ) { key = "" ; } else { key = name . substring ( 3 ) ; } } else if ( name . startsWith ( "is" ) ) { key = name . substring ( 2 ) ; } if ( key . length ( ) > 0 && Character . isUpperCase ( key . charAt ( 0 ) ) && method . getParameterTypes ( ) . length == 0 ) { if ( key . length ( ) == 1 ) { key = key . toLowerCase ( ) ; } else if ( ! Character . isUpperCase ( key . charAt ( 1 ) ) ) { key = key . substring ( 0 , 1 ) . toLowerCase ( ) + key . substring ( 1 ) ; } Object result = method . invoke ( bean , ( Object [ ] ) null ) ; if ( result != null ) { this . map . put ( key , wrap ( result ) ) ; } } } } catch ( Exception ignore ) { } } }
tr	KPT	int	public int ySect ( ) { return y_sect ; }
tr	KMD	public	public void sendMessage ( Message m ) throws JMSException { System . out . println ( "---SENDING CHATROOM MESSAGE TO " + members . size ( ) + " CLIENTS---" ) ; for ( Map . Entry < ClientID , Destination > entry : members . entrySet ( ) ) { try { producer . send ( entry . getValue ( ) , m ) ; } catch ( InvalidDestinationException exception ) { members . remove ( entry . getKey ( ) ) ; } } }
tr	KMD	public	public ScrollableList ( ListModel model ) { a = new ScrollAnimator ( this ) ; this . model = model ; cellHeight = 60 ; this . addMouseListener ( this ) ; this . addMouseMotionListener ( this ) ; this . addMouseWheelListener ( this ) ; model . addListDataListener ( this ) ; }
tr	KMD	public	public void setCard ( int [ ] card ) { this . card = card ; }
tr	KFC	return	private static boolean isWindows ( ) { String osname = System . getProperty ( "os.name" ) ; return osname != null && osname . length ( ) >= 7 && osname . substring ( 0 , 7 ) . equals ( "Windows" ) ; }
tr	KFC	if	public int minimize ( String desire , int [ ] tests ) { int req = 0 ; if ( desire . equals ( "A" ) ) req = 90 ; if ( desire . equals ( "B" ) ) req = 80 ; if ( desire . equals ( "C" ) ) req = 70 ; if ( desire . equals ( "D" ) ) req = 60 ; req *= tests . length + 1 ; int sum = 0 ; for ( int x : tests ) sum += x ; for ( int i = 0 ; i <= 100 ; ++ i ) if ( i + sum >= req ) return i ; return - 1 ; }
tr	OAR	%	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; long n = scanner . nextLong ( ) ; scanner . close ( ) ; long i = 3 ; while ( n % i == 0 ) { i *= 3 ; } System . out . println ( n / i + 1 ) ; }
tr	OAR	/	public static boolean fuzzyEquals ( double a , double b ) { final double EPSILON = 5.96e-08 ; if ( double . isNaN ( a ) && double . isNaN ( b ) || double . isInfinite ( a ) && double . isInfinite ( b ) ) { return true ; } else { return Math . abs ( a / b - 1 ) < EPSILON ; } }
tr	KFC	return	public List < ConfiguredComponent > getComponents ( ) { return components ; }
tr	OUT	++	public static void updateSeqNo ( ) { seqNo ++ ; }
tr	KMD	public	public void swap ( int row1 , int row2 ) { double [ ] tmp = getRow ( row1 ) ; String tmpname = getRowname ( row1 ) ; for ( int i = 0 ; i < dcol ; i ++ ) { setValue ( row1 , i , getValue ( row2 , i ) ) ; } setRowname ( row1 , getRowname ( row2 ) ) ; for ( int i = 0 ; i < dcol ; i ++ ) { setValue ( row2 , i , tmp [ i ] ) ; } setRowname ( row2 , tmpname ) ; }
tr	KFC	return	public int getID ( ) { return ID ; }
tr	ORE	<	public static String leftPad ( String str , int size , String pad ) { int l = str . length ( ) ; StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < size - l ; i ++ ) { b . append ( pad ) ; } b . append ( str ) ; return b . toString ( ) ; }
tr	SYM	(	public Object make ( HGPersistentHandle handle , LazyRef < HGHandle [ ] > targetSet , IncidenceSetRef incidenceSet ) { byte [ ] data = hg . getStore ( ) . getData ( handle ) ; if ( data == null ) throw new HGException ( "Could not find value for double array  handle=" + handle . toString ( ) ) ; double [ ] result = new double [ ( data . length - 1 ) / 8 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { int l = 8 * i + 1 ; long lv = ( ( long ) data [ l ] << 56 ) + ( ( long ) ( data [ l + 1 ] & 255 ) << 48 ) + ( ( long ) ( data [ l + 2 ] & 255 ) << 40 ) + ( ( long ) ( data [ l + 3 ] & 255 ) << 32 ) + ( ( long ) ( data [ l + 4 ] & 255 ) << 24 ) + ( ( data [ l + 5 ] & 255 ) << 16 ) + ( ( data [ l + 6 ] & 255 ) << 8 ) + ( ( data [ l + 7 ] & 255 ) << 0 ) ; result [ i ] = double . longBitsToDouble ( lv ) ; } return result ; }
tr	KMD	public	public void keyTyped ( KeyEvent e ) { }
tr	ORE	<	public List < GitlabCommitDiff > getDiffs ( ) { return diffs ; }
tr	SYM	(	public String getContentType ( ) { return _httpRequest . getContentType ( ) ; }
tr	KEH	try	private int forwardToAllInterestedNeighborExcept ( CAMessage message , NodeDescriptor source ) { SubscriptionTable subscriptionTable = caRouter . getSubscriptionTable ( ) ; ContextTable contextTable = caRouter . getContextTable ( ) ; Collection interestedNeighbor = subscriptionTable . matches ( message , source ) ; Iterator it = interestedNeighbor . iterator ( ) ; int messagesSent = 0 ; NodeDescriptor node ; while ( it . hasNext ( ) ) { node = ( NodeDescriptor ) it . next ( ) ; if ( ( ! node . equals ( source ) ) && ( contextTable . getContextReceived ( node ) . isMatchedBy ( message . getDestinationContext ( ) ) ) ) { try { overlay . send ( Router . PUBLISH , message , node ) ; messagesSent ++ ; } catch ( NotConnectedException e ) { } } } return messagesSent ; }
tr	OAR	-	@ Test public void testUnMove_WithPositionAtTwoTwoAndVelocityNegOneAndOne_ShouldReturnThreeAndOne ( ) { checkUnMove ( 2 , 3 , 2 , 3 , - 1 , 1 , 3 , 4 , 1 , 2 ) ; }
tr	OAS	/=	@ Override public SchemeObject call ( SchemeObject args ) { double result = args . getCar ( ) . getNumber ( ) ; args = args . getCdr ( ) ; while ( ! args . isEmptyList ( ) ) { result /= args . getCar ( ) . getNumber ( ) ; args = args . getCdr ( ) ; } return SchemeObject . makeNumber ( result ) ; }
tr	OUT	++	public void sendInterFlashScript ( int interfaceId , int componentId , int width , int height , int slot ) { Object [ ] parameters = new Object [ 4 ] ; int index = 0 ; parameters [ index ++ ] = slot ; parameters [ index ++ ] = height ; parameters [ index ++ ] = width ; parameters [ index ++ ] = interfaceId << 16 | componentId ; sendRunScript ( 143 , parameters ) ; }
tr	OUT	++	private void findNext ( ) { while ( true ) { this . nextPos ++ ; if ( this . nextPos == this . end ) { this . nextPos = - 1 ; return ; } if ( isNextPosValid ( ) ) { return ; } } }
tr	OAS	*=	public static int hashCode ( byte [ ] data ) { if ( data == null ) { return 0 ; } int i = data . length ; int hc = i + 1 ; while ( -- i >= 0 ) { hc *= 257 ; hc ^= data [ i ] ; } return hc ; }
tr	OAR	-	@ Override public void serialize ( ) { try { tables . productTypeDump . flush ( ) ; tables . productTypeDump . close ( ) ; tables . productFeatureDump . flush ( ) ; tables . productFeatureDump . close ( ) ; tables . producerDump . flush ( ) ; tables . producerDump . close ( ) ; tables . productDump . flush ( ) ; tables . productDump . close ( ) ; tables . productTypeProductDump . flush ( ) ; tables . productTypeProductDump . close ( ) ; tables . productFeatureProductDump . flush ( ) ; tables . productFeatureProductDump . close ( ) ; tables . vendorDump . flush ( ) ; tables . vendorDump . close ( ) ; tables . offerDump . flush ( ) ; tables . offerDump . close ( ) ; tables . personDump . flush ( ) ; tables . personDump . close ( ) ; tables . reviewDump . flush ( ) ; tables . reviewDump . close ( ) ; } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; System . exit ( - 1 ) ; } }
tr	KPT	double	public void addUitslag ( User user , double cijfer ) { assert ( user . isStudent ( ) ) ; assert ( cijfer >= 1.0 && cijfer <= 10.0 ) ; uitslagen . put ( user , cijfer ) ; }
tr	SYM	)	public BuchalteryWindow ( String caption ) { super ( caption ) ; width = 800 ; height = 500 ; setLayout ( new FlowLayout ( ) ) ; table = new JBuchTable ( ) ; refreshBtn = new JButton ( reloadIcon ) ; refreshBtn . addActionListener ( this ) ; add ( new JScrollPane ( table ) ) ; add ( refreshBtn ) ; setBounds ( 100 , 150 , width , height ) ; setAlwaysOnTop ( true ) ; }
tr	OUT	++	public static String getNextTowerId ( ) { return "T" + towerCounter ++ ; }
tr	KMD	public	public String obtenerPassword ( int pId ) ;
tr	ORE	>=	public static void main ( String [ ] args ) { String mot = "Bonjour" ; char [ ] cInverse = new char [ mot . length ( ) ] ; for ( int zz = mot . length ( ) - 1 ; zz >= 0 ; zz -- ) { int indexInverse = mot . length ( ) - 1 - zz ; char unChar = mot . charAt ( zz ) ; cInverse [ indexInverse ] = unChar ; } System . out . println ( ) ; String strInverse = new String ( cInverse ) ; System . out . printf ( "\nChaine inversee  version Economic: %s" , strInverse ) ; }
tr	OAR	-	@ Test public void testIncreaseScore ( ) throws Exception { String email = "admin@admin.ru" ; int initialScore = dbService . getUserByEmail ( email ) . getScore ( ) . intValue ( ) ; int scoreToIncrease = 10 ; service . increaseScore ( email , scoreToIncrease ) ; int resultScore = dbService . getUserByEmail ( email ) . getScore ( ) . intValue ( ) ; assert . assertEquals ( initialScore , resultScore - scoreToIncrease ) ; service . increaseScore ( email , - scoreToIncrease ) ; }
tr	ORE	<	public void mostraHotels ( Set < HotelInformation > hotels , String pob , Date dIni , Date dFi , Integer numOcup ) { View2 . getWindows ( ) [ 1 ] . dispose ( ) ; View3 v = new View3 ( hotels , pob , dIni , dFi , numOcup ) ; v . setVisible ( true ) ; }
tr	KEH	assert	public < TArg0 , TArg1 > StateConfiguration < S , T > permitDynamicIf ( TriggerWithParameters2 < TArg0 , TArg1 , S , T > trigger , final Func3 < TArg0 , TArg1 , S > destinationStateSelector , FuncBoolean guard ) { assert trigger != null : "trigger is null" ; assert destinationStateSelector != null : "destinationStateSelector is null" ; return publicPermitDynamicIf ( trigger . getTrigger ( ) , new Func2 < Object [ ] , S > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public S call ( Object [ ] args ) { return destinationStateSelector . call ( ( TArg0 ) args [ 0 ] , ( TArg1 ) args [ 1 ] ) ; } } , guard ) ; }
tr	OAS	/=	private void endArguments ( ) { if ( argumentStack % 2 != 0 ) { buf . append ( > ) ; } argumentStack /= 2 ; }
tr	KPT	boolean	public static boolean canCastTo ( DataType thisType , DataType other ) { if ( thisType == null ) { thisType = new DataType ( true ) ; } if ( other == null ) { other = new DataType ( true ) ; } if ( thisType . type instanceof ParamTypeDef ) { thisType = new DataType ( thisType . type . parent ) ; } if ( other . type instanceof ParamTypeDef ) { other = new DataType ( other . type . parent ) ; } if ( thisType . weak ) { return TypeDef . getCommonParent ( thisType . type , other . type ) != null ; } else { return TypeDef . getCommonParent ( thisType . type , other . type ) == thisType . type ; } }
tr	OAS	*=	public void prepareWaveNext ( int numPlayers , int priorityAmplifier ) { this . multiplier = ( int ) ( numPlayers * ( rand . nextDouble ( ) * .6 + .3 ) ) ; if ( isExtreme ) this . multiplier *= ( ( double ) ( Math . random ( ) + 1 ) ) ; this . outputNum = ( this . multiplier == 0 ? ( int ) ( this . waveNum * ( ( rand . nextDouble ( ) * .6 + .3 ) * priorityAmplifier ) ) : this . multiplier * this . waveNum ) ; }
tr	OAR	/	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jPanel3 = new javax . swing . JPanel ( ) ; label1 = new java . awt . Label ( ) ; jProgressBar1 = new javax . swing . JProgressBar ( ) ; btn_back = new javax . swing . JButton ( ) ; btn_cancel = new javax . swing . JButton ( ) ; panel_top = new javax . swing . JPanel ( ) ; btn_close = new javax . swing . JButton ( ) ; btn_minwindow = new javax . swing . JButton ( ) ; jPanel4 = new javax . swing . JPanel ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; panel_wizzard_img = new javax . swing . JPanel ( ) ; panel_step_img = new javax . swing . JPanel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; setResizable ( false ) ; setUndecorated ( true ) ; addComponentListener ( new java . awt . event . ComponentAdapter ( ) { public void componentShown ( java . awt . event . ComponentEvent evt ) { formComponentShown ( evt ) ; } } ) ; getContentPane ( ) . setLayout ( new org . netbeans . lib . awtextra . AbsoluteLayout ( ) ) ; jPanel3 . setBackground ( java . awt . Color . white ) ; jPanel3 . setLayout ( new org . netbeans . lib . awtextra . AbsoluteLayout ( ) ) ; label1 . setCursor ( new java . awt . Cursor ( java . awt . Cursor . DEFAULT_CURSOR ) ) ; label1 . setText ( "The setup tools is obtaining the network configuration from you computer. Please wait..." ) ; jPanel3 . add ( label1 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 20 , 30 , - 1 , - 1 ) ) ; jPanel3 . add ( jProgressBar1 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 150 , 140 , 197 , - 1 ) ) ; btn_back . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/mye/tools/src/Back.png" ) ) ) ; btn_back . setBorder ( null ) ; btn_back . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseExited ( java . awt . event . MouseEvent evt ) { btn_backMouseExited ( evt ) ; } } ) ; btn_back . addMouseMotionListener ( new java . awt . event . MouseMotionAdapter ( ) { public void mouseMoved ( java . awt . event . MouseEvent evt ) { btn_backMouseMoved ( evt ) ; } } ) ; btn_back . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btn_backActionPerformed ( evt ) ; } } ) ; jPanel3 . add ( btn_back , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 437 , 320 , - 1 , 26 ) ) ; btn_cancel . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/mye/tools/src/Cancel.png" ) ) ) ; btn_cancel . setBorder ( null ) ; btn_cancel . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseExited ( java . awt . event . MouseEvent evt ) { btn_cancelMouseExited ( evt ) ; } } ) ; btn_cancel . addMouseMotionListener ( new java . awt . event . MouseMotionAdapter ( ) { public void mouseMoved ( java . awt . event . MouseEvent evt ) { btn_cancelMouseMoved ( evt ) ; } } ) ; btn_cancel . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btn_cancelActionPerformed ( evt ) ; } } ) ; jPanel3 . add ( btn_cancel , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 360 , 320 , - 1 , 26 ) ) ; getContentPane ( ) . add ( jPanel3 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 164 , 80 , 561 , 350 ) ) ; panel_top . setOpaque ( false ) ; panel_top . setLayout ( new org . netbeans . lib . awtextra . AbsoluteLayout ( ) ) ; btn_close . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/mye/tools/src/x.png" ) ) ) ; btn_close . setBorder ( null ) ; btn_close . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseExited ( java . awt . event . MouseEvent evt ) { btn_closeMouseExited ( evt ) ; } } ) ; btn_close . addMouseMotionListener ( new java . awt . event . MouseMotionAdapter ( ) { public void mouseMoved ( java . awt . event . MouseEvent evt ) { btn_closeMouseMoved ( evt ) ; } } ) ; btn_close . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btn_closeActionPerformed ( evt ) ; } } ) ; panel_top . add ( btn_close , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 700 , 10 , 26 , 19 ) ) ; btn_minwindow . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/mye/tools/src/-.png" ) ) ) ; btn_minwindow . setBorder ( null ) ; btn_minwindow . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseExited ( java . awt . event . MouseEvent evt ) { btn_minwindowMouseExited ( evt ) ; } } ) ; btn_minwindow . addMouseMotionListener ( new java . awt . event . MouseMotionAdapter ( ) { public void mouseMoved ( java . awt . event . MouseEvent evt ) { btn_minwindowMouseMoved ( evt ) ; } } ) ; btn_minwindow . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btn_minwindowActionPerformed ( evt ) ; } } ) ; panel_top . add ( btn_minwindow , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 670 , 10 , 26 , 19 ) ) ; getContentPane ( ) . add ( panel_top , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 0 , 0 , 735 , 45 ) ) ; jPanel4 . setBackground ( java . awt . Color . white ) ; jPanel4 . setLayout ( new org . netbeans . lib . awtextra . AbsoluteLayout ( ) ) ; jLabel1 . setFont ( new java . awt . Font ( "\u5B8B\u4F53" , 1 , 12 ) ) ; jLabel1 . setText ( "Wizard" ) ; jPanel4 . add ( jLabel1 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 36 , 0 , - 1 , - 1 ) ) ; panel_wizzard_img . setBackground ( java . awt . Color . white ) ; javax . swing . GroupLayout panel_wizzard_imgLayout = new javax . swing . GroupLayout ( panel_wizzard_img ) ; panel_wizzard_img . setLayout ( panel_wizzard_imgLayout ) ; panel_wizzard_imgLayout . setHorizontalGroup ( panel_wizzard_imgLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 100 , short . MAX_VALUE ) ) ; panel_wizzard_imgLayout . setVerticalGroup ( panel_wizzard_imgLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 79 , short . MAX_VALUE ) ) ; jPanel4 . add ( panel_wizzard_img , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 19 , 25 , - 1 , - 1 ) ) ; panel_step_img . setBackground ( java . awt . Color . white ) ; javax . swing . GroupLayout panel_step_imgLayout = new javax . swing . GroupLayout ( panel_step_img ) ; panel_step_img . setLayout ( panel_step_imgLayout ) ; panel_step_imgLayout . setHorizontalGroup ( panel_step_imgLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 111 , short . MAX_VALUE ) ) ; panel_step_imgLayout . setVerticalGroup ( panel_step_imgLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 118 , short . MAX_VALUE ) ) ; jPanel4 . add ( panel_step_img , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 10 , 110 , - 1 , - 1 ) ) ; getContentPane ( ) . add ( jPanel4 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 10 , 83 , 130 , 270 ) ) ; java . awt . Dimension screenSize = java . awt . Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; setBounds ( ( screenSize . width - 735 ) / 2 , ( screenSize . height - 440 ) / 2 , 735 , 440 ) ; }
tr	OLB	||	public boolean appletVersionCheck ( ) { String AppletVersion = this . getParameter ( "AppletVersion" ) ; if ( AppletVersion == null || AppletVersion . compareTo ( BUILD_STRING ) > 0 ) { int result = JOptionPane . showConfirmDialog ( this , "There is a newer version of the applet.\nPlease clean your browser cache and refresh the page to load the new version.\nCurrent version may not be compatible with the rest of the system.\nDo you still want to use the current version?" , "Warning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) { return false ; } } else if ( AppletVersion . compareTo ( BUILD_STRING ) < 0 ) { JOptionPane . showMessageDialog ( this , "VERSION CHECK PROBLEM: Developer needs to update the server version number to: " + BUILD_STRING + ".\n" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } return true ; }
tr	OAR	-	public final boolean nextBoolean ( final float probability ) { int y ; if ( probability < 0.0f || probability > 1.0f ) throw new IllegalArgumentException ( "probability must be between 0.0 and 1.0 inclusive." ) ; if ( probability == 0.0f ) return false ; else if ( probability == 1.0f ) return true ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; return ( y >>> 8 ) / ( ( float ) ( 1 << 24 ) ) < probability ; }
tr	KPT	int	private void setToolTipText ( ISeries series , int index ) { chart . getPlotArea ( ) . setToolTipText ( "Series: " + series . getId ( ) + "\nValue: " + series . getYSeries ( ) [ index ] ) ; }
tr	KEH	assert	protected final static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { int nNodes , nHeap , n1 , n2 , i , j , k ; boolean tooLong ; int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( i = 0 ; i < alphaSize ; i ++ ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } while ( true ) { nNodes = alphaSize ; nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; { int zz , tmp ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz >> 1 ] ] ) { heap [ zz ] = heap [ zz >> 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } assert nHeap < MAX_ALPHA_SIZE + 2 ; while ( nHeap > 1 ) { n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; weight [ nNodes ] = ( ( weight [ n1 ] & ffffff00 ) + ( weight [ n2 ] & ffffff00 ) ) | ( 1 + ( ( ( weight [ n1 ] & 000000ff ) > ( weight [ n2 ] & 000000ff ) ) ? ( weight [ n1 ] & 000000ff ) : ( weight [ n2 ] & 000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; { int zz = 0 , tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz >> 1 ] ] ) { heap [ zz ] = heap [ zz >> 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } assert nNodes < MAX_ALPHA_SIZE * 2 ; tooLong = false ; for ( i = 1 ; i <= alphaSize ; i ++ ) { j = 0 ; k = i ; while ( parent [ k ] >= 0 ) { k = parent [ k ] ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( ! tooLong ) { break ; } for ( i = 1 ; i < alphaSize ; i ++ ) { j = weight [ i ] >> 8 ; j = 1 + ( j / 2 ) ; weight [ i ] = j << 8 ; } } }
tr	KFC	return	public String getType ( ) { return type ; }
tr	KFC	return	@ Override public boolean hasNext ( ) { return it . hasNext ( ) ; }
tr	OAS	/=	public Vec2d div ( double x , double y ) { this . x /= x ; this . y /= y ; return this ; }
tr	OAS	&=	@ Override public int getPixel ( int x , int y ) { if ( x < 0 || x >= width ) return 0 ; if ( y < 0 || y >= height ) return 0 ; int val = getPixelVal ( x , y ) ; if ( format == 1 ) val &= 1F ; if ( format == 6 ) val &= 07 ; return val ; }
tr	KPT	int	public MapCell ( Image paramImage , int paramInt ) { this . appearance = paramImage ; this . impassibility = paramInt ; this . storm = false ; this . category = "" ; this . filename = "" ; }
tr	OUT	++	public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || head . next == null || k < 2 ) { return head ; } ListNode pre = new ListNode ( 0 ) ; pre . next = head ; ListNode p0 = pre , p1 = head , p2 = head , next = head ; while ( true ) { int i = 0 ; while ( i < k - 1 && p2 != null ) { p2 = p2 . next ; i ++ ; } if ( i < k - 1 || p2 == null ) { p0 . next = next ; break ; } next = p2 . next ; p2 . next = null ; List l = reverse ( p1 ) ; p0 . next = l . head ; p0 = l . tail ; p1 = p2 = next ; } return pre . next ; }
tr	OUT	--	public void separate ( int x , int y ) { int xRoot = Find ( x ) ; int yRoot = Find ( y ) ; padre [ x ] = yRoot ; elements [ xRoot ] -- ; elements [ yRoot ] ++ ; sum [ xRoot ] -= ( x - ( sum . length / 2 ) + 1 ) ; sum [ yRoot ] += ( x - ( sum . length / 2 ) + 1 ) ; }
tr	KFC	return	public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return com . google . protobuf . DescriptorProtos . internal_static_google_protobuf_EnumOptions_descriptor ; }
tr	KPT	int	public int singleNumber ( int [ ] A ) { int r = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { r ^= A [ i ] ; } return r ; }
tr	OAS	*=	public Vector4i mul ( final Vector4i v ) { this . w *= v . w ; this . x *= v . x ; this . y *= v . y ; this . z *= v . z ; return this ; }
tr	OUT	++	BasicBufferMgr ( int numBuffs ) { bufferPool = new Buffer [ numBuffs ] ; blockMap = new HashMap < BlockId , Buffer > ( ) ; numAvailable = numBuffs ; lastReplacedBuff = 0 ; for ( int i = 0 ; i < numBuffs ; i ++ ) bufferPool [ i ] = new Buffer ( ) ; }
tr	OAS	&=	private int jjMoveStringLiteralDfa5_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 3 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 4 , active0 ) ; return 5 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa6_0 ( active0 , 10000000 ) ; default : break ; } return jjStartNfa_0 ( 4 , active0 ) ; }
tr	OUT	++	public static FloatBuffer createFlippedBuffer ( Vertex [ ] vertices ) { FloatBuffer buffer = createFloatBuffer ( vertices . length * Vertex . SIZE ) ; for ( int i = 0 ; i < vertices . length ; i ++ ) { buffer . put ( vertices [ i ] . getPos ( ) . getX ( ) ) ; buffer . put ( vertices [ i ] . getPos ( ) . getY ( ) ) ; buffer . put ( vertices [ i ] . getPos ( ) . getZ ( ) ) ; buffer . put ( vertices [ i ] . getTexCoord ( ) . getX ( ) ) ; buffer . put ( vertices [ i ] . getTexCoord ( ) . getY ( ) ) ; buffer . put ( vertices [ i ] . getNormal ( ) . getX ( ) ) ; buffer . put ( vertices [ i ] . getNormal ( ) . getY ( ) ) ; buffer . put ( vertices [ i ] . getNormal ( ) . getZ ( ) ) ; } buffer . flip ( ) ; return buffer ; }
tr	SYM	)	@ Test public void testThreadWaitsOnceCapacityHasBeenReached ( ) { assertEquals ( 0 , doubleQ . size ( ) ) ; Runnable addItem = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { doubleQ . add ( Math . random ( ) ) ; } } } ; Thread t = new Thread ( addItem ) ; t . start ( ) ; while ( ! ( doubleQ . size ( ) == testCapacity && t . getState ( ) . equals ( Thread . State . WAITING ) ) ) { } assertTrue ( true ) ; }
tr	OLB	&&	private void updateEvaluation ( Counter < String > errorsAnalysis , double predictedProbabilityOfBeingPositive , double threshold , int trueLabel ) { if ( predictedProbabilityOfBeingPositive >= threshold && trueLabel == 1 ) errorsAnalysis . incrementCount ( "TP" , 1 ) ; else if ( predictedProbabilityOfBeingPositive >= threshold && trueLabel == 0 ) { errorsAnalysis . incrementCount ( "FP" , 1 ) ; } else if ( predictedProbabilityOfBeingPositive < threshold && trueLabel == 1 ) errorsAnalysis . incrementCount ( "FN" , 1 ) ; else errorsAnalysis . incrementCount ( "TN" , 1 ) ; }
tr	KPT	int	public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode first = head ; ListNode second = head ; ListNode secondPre = head ; while ( first != null ) { first = first . next ; n -- ; if ( n < 0 ) { second = second . next ; } if ( n < - 1 ) { secondPre = secondPre . next ; } } if ( second == secondPre ) { return head . next ; } secondPre . next = secondPre . next . next ; return head ; }
tr	KPT	int	public ArrayList < City > getListCities ( ) throws SQLException { ArrayList < City > res = new ArrayList < > ( ) ; String sql ; sql = " SELECT * FROM City" ; Statement st = connectionDB . conn . createStatement ( ) ; st . executeQuery ( sql ) ; ResultSet rs = st . getResultSet ( ) ; while ( rs . next ( ) ) { int id = rs . getInt ( 1 ) ; int capAlm = rs . getInt ( 2 ) ; int espLib = rs . getInt ( 3 ) ; String oaci = rs . getString ( 4 ) ; String country = rs . getString ( 5 ) ; String nameCity = rs . getString ( 6 ) ; String shortName = rs . getString ( 7 ) ; int idSis = rs . getInt ( 8 ) ; int idCont = rs . getInt ( 9 ) ; City city = new City ( oaci , nameCity , country , shortName , idSis , idCont ) ; res . add ( city ) ; } return res ; }
tr	OUT	++	public static NaturalSetCollection transpose ( NaturalSetCollection c ) throws NaturalSetException { NaturalSetCollection t = null ; if ( c . size ( ) > 0 ) { t = new NaturalSetCollection ( new NaturalDomain ( c . size ( ) ) , c . domain . closureCardinality ( ) ) ; for ( int j = c . domain . min ( ) ; j <= c . domain . max ( ) ; j ++ ) { OpenBitSet tline = new OpenBitSet ( c . size ( ) ) ; for ( int i = 0 ; i < c . size ( ) ; i ++ ) { if ( c . elements . get ( i ) . contains ( j ) ) { tline . fastSet ( i ) ; } } t . add ( new NaturalSet ( t . domain , tline ) ) ; } } else { throw new NaturalSetException ( "Can not transpose empty collection." ) ; } return t ; }
tr	OAS	>>=	private static byte [ ] encode ( byte [ ] inbuf , int off , int size , byte [ ] outbuf ) { if ( outbuf == null ) { outbuf = new byte [ encodedSize ( size ) ] ; } int inpos , outpos ; int val ; for ( inpos = off , outpos = 0 ; size >= 3 ; size -= 3 , outpos += 4 ) { val = inbuf [ inpos ++ ] & ff ; val <<= 8 ; val |= inbuf [ inpos ++ ] & ff ; val <<= 8 ; val |= inbuf [ inpos ++ ] & ff ; outbuf [ outpos + 3 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 2 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 1 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 0 ] = ( byte ) pem_array [ val & 3f ] ; } if ( size == 1 ) { val = inbuf [ inpos ++ ] & ff ; val <<= 4 ; outbuf [ outpos + 3 ] = ( byte ) = ; outbuf [ outpos + 2 ] = ( byte ) = ; outbuf [ outpos + 1 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 0 ] = ( byte ) pem_array [ val & 3f ] ; } else if ( size == 2 ) { val = inbuf [ inpos ++ ] & ff ; val <<= 8 ; val |= inbuf [ inpos ++ ] & ff ; val <<= 2 ; outbuf [ outpos + 3 ] = ( byte ) = ; outbuf [ outpos + 2 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 1 ] = ( byte ) pem_array [ val & 3f ] ; val >>= 6 ; outbuf [ outpos + 0 ] = ( byte ) pem_array [ val & 3f ] ; } return outbuf ; }
tr	ORE	<	public RadioButton ( final boolean showQuestion , final int questionNumber , final Statistics questionStatistics , final String question , final String answer , final Location locationOfAnswer , final ArrayList < String > options ) { super ( Type . RadioButton , showQuestion , questionNumber , questionStatistics , locationOfAnswer , question , options ) ; _answer = answer ; }
tr	KEH	finally	private static String readCookies ( File file ) { FileInputStream stream = null ; InputStreamReader inputStream = null ; BufferedReader bufferedReader = null ; try { stream = new FileInputStream ( file ) ; inputStream = new InputStreamReader ( stream ) ; bufferedReader = new BufferedReader ( inputStream ) ; String data = bufferedReader . readLine ( ) ; if ( data == null ) { data = "" ; } return data ; } catch ( FileNotFoundException ex1 ) { return null ; } catch ( Exception ex1 ) { ex1 . printStackTrace ( ) ; return null ; } finally { try { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } catch ( Exception ex2 ) { } try { if ( inputStream != null ) { inputStream . close ( ) ; } } catch ( Exception ex3 ) { } try { if ( stream != null ) { stream . close ( ) ; } } catch ( Exception ex4 ) { } } }
tr	KMD	private	private RX factor ( ) throws NoParseException { return stars ( atom ( ) ) ; }
tr	SYM	;	public void statics ( ) throws IOException { checkOpen ( ) ; Map < Integer , Pair < Word , Object >> wordId = clearUnused ( ) ; long [ ] nk = new long [ K_LIMT + 1 ] ; Arrays . fill ( nk , 0 ) ; statics_NK ( nk , wordId ) ; caluateD ( nk ) ; setWordWeight ( wordId ) ; wordId . clear ( ) ; }
tr	SYM	)	public JsBlock getBody ( ) { return body ; }
tr	KMD	public	public void setTerrain ( int [ ] [ ] terrain ) { this . terrain = terrain ; createNavigationMaps ( ) ; }
tr	OLB	||	@ Override public void actionPerformed ( ActionEvent e ) { visibleScreen . getFrame ( ) . getContentPane ( ) . removeAll ( ) ; if ( visibleScreen . getIndex ( ) == - 1 ) { visibleScreen . playerXScreen ( ) ; } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "BANG!" ) || ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getAvatar ( ) . toString ( ) . equals ( "Calamity Janet" ) && visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Mancato!" ) ) ) { checkForProblemsInUsingBang ( ) ; } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Gatling" ) ) { if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerToFollow ( ) . getHandCards ( ) . isEmpty ( ) ) { usingGatlingAgainstEnemyWithNoHandCards ( ) ; } else { usingGatling ( ) ; } } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Indiani!" ) ) { if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerToFollow ( ) . getHandCards ( ) . isEmpty ( ) ) { usingIndianiOrDuelloAgainstEnemyWithNoHandCards ( ) ; } else { usingIndiani ( ) ; } } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Duello" ) ) { if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerToFollow ( ) . getHandCards ( ) . isEmpty ( ) ) { usingIndianiOrDuelloAgainstEnemyWithNoHandCards ( ) ; } else { usingDuello ( ) ; } } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Panico!" ) ) { usingPanico ( ) ; } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . contains ( "Cat Balou" ) ) { usingCatBalou ( ) ; } else if ( visibleScreen . getSetup ( ) . getRound ( ) . getPlayerInTurn ( ) . getHandCards ( ) . get ( visibleScreen . getIndex ( ) ) . getName ( ) . equals ( "Emporio" ) ) { usingEmporio ( ) ; } else { visibleScreen . getSetup ( ) . getRound ( ) . getCheckerForPlayedCard ( ) . playingCard ( visibleScreen . getIndex ( ) ) ; visibleScreen . playerXScreen ( ) ; } frame . revalidate ( ) ; frame . repaint ( ) ; }
tr	OAS	&=	private int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0 ) return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 80000000000 , active1 , 0 ) ; case 99 : return jjMoveStringLiteralDfa7_0 ( active0 , 80000 , active1 , 0 ) ; case 100 : return jjMoveStringLiteralDfa7_0 ( active0 , 1000000 , active1 , 0 ) ; case 101 : if ( ( active0 & 100000000 ) != 0 ) return jjStartNfaWithStates_0 ( 6 , 32 , 25 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 4100000 , active1 , 20000 ) ; case 110 : return jjMoveStringLiteralDfa7_0 ( active0 , 80000000 , active1 , 0 ) ; case 111 : return jjMoveStringLiteralDfa7_0 ( active0 , 2000000 , active1 , 0 ) ; case 116 : return jjMoveStringLiteralDfa7_0 ( active0 , 1020040000000 , active1 , 0 ) ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 800000 , active1 , 0 ) ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; }
tr	KMD	synchronized	public synchronized void put ( String cake ) throws InterruptedException { System . out . println ( Thread . currentThread ( ) . getName ( ) + " puts " + cake ) ; while ( count >= buffer . length ) { wait ( ) ; } buffer [ tail ] = cake ; tail = ( tail + 1 ) % buffer . length ; count ++ ; notifyAll ( ) ; }
tr	OUT	++	public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( qName . equals ( "gender" ) ) { Gender gender = null ; if ( tempStr . equals ( "Male" ) ) { gender = Gender . GENDER_MALE ; } else if ( tempStr . equals ( "Female" ) ) { gender = Gender . GENDER_FEMALE ; } else if ( tempStr . equals ( "Both" ) ) { gender = Gender . GENDER_BOTH ; } else { gender = Gender . GENDER_NONE ; } if ( tempCombo != null ) { tempCombo . setGender ( gender ) ; } else { tempSpecies . setGenders ( gender ) ; } } else if ( qName . equals ( "ability" ) ) { if ( tempCombo != null ) { tempCombo . setAbility ( tempStr ) ; } else { tempSpecies . addAbility ( tempStr ) ; } } else if ( qName . equals ( "nature" ) ) { tempCombo . setNature ( tempStr ) ; } else if ( qName . equals ( "move" ) ) { if ( tempCombo != null ) { tempCombo . addMove ( tempStr ) ; } else { tempSpecies . addMove ( tempStr ) ; } } else if ( qName . equals ( "base" ) ) { tempSpecies . setBase ( idx , Integer . valueOf ( tempStr ) ) ; idx ++ ; } else if ( qName . equals ( "species" ) ) { m_species . add ( tempSpecies ) ; } else if ( qName . equals ( "combo" ) ) { tempSpecies . addIllegalCombo ( tempCombo ) ; tempCombo = null ; } }
tr	OAR	-	public static void main ( String [ ] args ) { MaxContigiousArrSum sumCalc = new MaxContigiousArrSum ( ) ; sumCalc . maxContSum ( new int [ ] { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ) ; sumCalc . maxContSum ( new int [ ] { - 2 , - 3 , - 4 , - 1 , - 2 , - 1 , - 5 , - 3 } ) ; sumCalc . maxContSum1 ( new int [ ] { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ) ; sumCalc . maxContSum1 ( new int [ ] { - 2 , - 3 , - 4 , - 1 , - 2 , - 1 , - 5 , - 3 } ) ; }
tr	KMD	public	public int getId ( ) { return id ; }
tr	KFC	return	@ Override public boolean remove ( final Object arg0 ) { if ( ! connections . containsKey ( arg0 ) ) { return false ; } connections . get ( arg0 ) . stop ( ) ; connections . remove ( arg0 ) ; return true ; }
tr	SYM	)	public CreatorParameters create ( ) { return creatorParameters ; }
tr	KFC	return	public BigInteger getCurrentAveragePaymentTermDays ( ) { return currentAveragePaymentTermDays ; }
tr	OUT	++	@ Override public Polymino read ( final InputStream input ) { try ( Scanner sc = new Scanner ( input ) ) { int boardRows = sc . nextInt ( ) ; int boardCols = sc . nextInt ( ) ; int pieces = sc . nextInt ( ) ; boolean [ ] [ ] board = new boolean [ boardRows ] [ boardCols ] ; for ( int row = 0 ; row < boardRows ; ++ row ) { for ( int col = 0 ; col < boardCols ; ++ col ) { int occupied = sc . nextInt ( ) ; board [ row ] [ col ] = ( occupied != 0 ) ; } } Polymino polymino = new Polymino ( board ) ; for ( int i = 0 ; i < pieces ; ++ i ) { int pieceRows = sc . nextInt ( ) ; int pieceCols = sc . nextInt ( ) ; boolean canRotate = sc . nextBoolean ( ) ; boolean canFlip = sc . nextBoolean ( ) ; boolean [ ] [ ] pieceMask = new boolean [ pieceRows ] [ pieceCols ] ; for ( int row = 0 ; row < pieceRows ; ++ row ) { for ( int col = 0 ; col < pieceCols ; ++ col ) { int occupied = sc . nextInt ( ) ; pieceMask [ row ] [ col ] = ( occupied != 0 ) ; } } Piece piece = new Piece ( polymino , MaskUtils . maskClip ( pieceMask ) , canRotate , canFlip ) ; polymino . addPiece ( piece ) ; } return polymino ; } }
tr	KFC	return	public Object update ( Lop_DTO l ) { connect . Connect ( ) ; String MaLop = l . getMalop ( ) ; String Tenlop = l . getTenlop ( ) ; String MaHe = l . getMahe ( ) ; String sql = String . format ( "update Lop set " + "tenlop = '%s' mahe = '%s'  where malop = '%s'" , Tenlop , MaHe , MaLop ) ; return connect . update ( sql ) ; }
tr	OAS	*=	public Vector4f scale ( final float f ) { this . w *= f ; this . x *= f ; this . y *= f ; this . z *= f ; return this ; }
tr	KMD	public	public Figura GetEditTarget ( ) { return editTarget ; }
tr	ORE	<	@ RequestMapping ( value = "/officeslist.htm" , method = RequestMethod . GET ) public ModelAndView handleRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { String now = ( new Date ( ) ) . toString ( ) ; LOGGER . info ( "Returning officeslist view with " + now ) ; Map < String , Object > myModel = new HashMap < String , Object > ( ) ; myModel . put ( "now" , now ) ; myModel . put ( "offices" , this . officeManager . getOffices ( ) ) ; return new ModelAndView ( "officeslist" , "model" , myModel ) ; }
tr	OAR	-	public void jLabelMousePressed ( MouseEvent evt ) { setMousePointOffsetX ( evt . getX ( ) ) ; setMousePointOffsetY ( evt . getY ( ) ) ; int mouseX = evt . getX ( ) ; int mouseY = evt . getY ( ) ; if ( ( mouseX > ( getWidth ( ) - getResizeDetectRange ( ) ) ) && ( mouseY > ( getHeight ( ) - getResizeDetectRange ( ) ) ) && this . isResizeEnabled ( ) ) { setHandleMode ( JDraggableLabel . HANDLE_MODE_RESIZE ) ; } else if ( this . isDragEnabled ( ) ) { setHandleMode ( JDraggableLabel . HANDLE_MODE_DRAG ) ; } }
tr	KEH	assert	@ Test public void shouldTestStringReversalRecursiveRoutine ( ) { ReverseString reverseString = new ReverseString ( ) ; assert . assertEquals ( "tset" , reverseString . recursiveReverse ( "test" ) ) ; assert . assertEquals ( "olleh" , reverseString . recursiveReverse ( "hello" ) ) ; assert . assertEquals ( "" , reverseString . recursiveReverse ( "" ) ) ; assert . assertEquals ( null , reverseString . recursiveReverse ( null ) ) ; assert . assertEquals ( "ih" , reverseString . recursiveReverse ( "hi" ) ) ; }
tr	SYM	)	public GridBagConstraints getAdditionalDisplayGridConstraint ( ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . fill = GridBagConstraints . NONE ; c . ipadx = 0 ; c . ipady = 0 ; c . weightx = 1 ; c . weighty = 1 ; c . gridwidth = 1 ; c . gridheight = 1 ; c . anchor = GridBagConstraints . CENTER ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 0 , 0 , 0 ) ; return c ; }
tr	KFC	return	public int getIconHeight ( ) { return size ; }
tr	OLB	&&	public static char valueToBase64 ( byte value ) { if ( 0 <= value && value < 26 ) return ( char ) ( a + value ) ; if ( 26 <= value && value < 52 ) return ( char ) ( A + value - 26 ) ; if ( 52 <= value && value < 62 ) return ( char ) ( 0 + value - 52 ) ; if ( value == 62 ) return ? ; return ! ; }
tr	KEH	try	private void configureOutput ( ) { File errFile = new File ( APP_HOME + DIR_ERR ) ; File outFile = new File ( APP_HOME + DIR_SALIDA ) ; PrintStream err = null ; PrintStream out = null ; try { err = new PrintStream ( errFile ) ; out = new PrintStream ( outFile ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } System . setErr ( err ) ; System . setOut ( out ) ; }
tr	ORE	<	public Map < String , Integer > parseImageString ( String istr ) { istr = istr . replace ( "{" , "" ) ; istr = istr . replace ( "}" , "" ) ; istr = istr . replace ( "\"" , "" ) ; Map < String , Integer > images = new HashMap < String , Integer > ( ) ; String [ ] pairs = istr . split ( " " ) ; for ( String pair : pairs ) { String [ ] splittedPair = pair . split ( ":" ) ; splittedPair [ 0 ] = splittedPair [ 0 ] . trim ( ) ; splittedPair [ 1 ] = splittedPair [ 1 ] . trim ( ) ; try { if ( splittedPair [ 0 ] != "" && splittedPair [ 1 ] != "" ) { images . put ( splittedPair [ 1 ] , Integer . parseInt ( splittedPair [ 0 ] ) ) ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } } System . out . println ( "done parsing ..." ) ; return images ; }
tr	SYM	;	public SettingsFrame ( ) { text = new JLabel ( "Settings goes here." ) ; text . setBounds ( 240 , 125 , 200 , 50 ) ; setSize ( 600 , 350 ) ; setLayout ( null ) ; setTitle ( "Settings Window" ) ; setVisible ( true ) ; setLocationRelativeTo ( null ) ; setResizable ( false ) ; add ( text ) ; }
tr	OUT	++	public String remainder ( ) { if ( atLeaf ( ) ) { return "" ; } StringBuilder remainder = new StringBuilder ( nodes_ [ level_ + 1 ] ) ; for ( int i = level_ + 2 ; i <= leaf_level_ ; i ++ ) { remainder . append ( / ) ; remainder . append ( nodes_ [ i ] ) ; } return remainder . toString ( ) ; }
tr	KEH	try	public TagListBean [ ] getAllByLibraryFK ( int libraryFK ) { LinkedList < TagListBean > list = new LinkedList < > ( ) ; try { PreparedStatement statement = connection . prepareStatement ( GET_ALL_BY_LIBRARY_FK ) ; statement . setString ( 1 , new Integer ( libraryFK ) . toString ( ) ) ; ResultSet resultSet = statement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( readTagListBean ( resultSet ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } TagListBean [ ] result = new TagListBean [ list . size ( ) ] ; return list . toArray ( result ) ; }
tr	SYM	(	@ Override protected void treeChanged ( ) { treeTable . revalidate ( ) ; treeTable . repaint ( ) ; }
tr	OAS	/=	public void devide ( double factor ) { this . posX /= factor ; this . posY /= factor ; this . posZ /= factor ; }
tr	OLB	||	public String getAsHexString ( ) { int r , g , b , a ; if ( this . r == - 1 || this . g == - 1 || this . b == - 1 || this . a == - 1 ) { r = this . getRed ( ) ; g = this . getBlue ( ) ; b = this . getGreen ( ) ; a = this . getAlpha ( ) ; } else { r = ( int ) ( this . r * 255 ) ; g = ( int ) ( this . g * 255 ) ; b = ( int ) ( this . b * 255 ) ; a = ( int ) ( this . a * 255 ) ; } String hex1 = hexPad ( Integer . toHexString ( r ) ) ; String hex2 = hexPad ( Integer . toHexString ( g ) ) ; String hex3 = hexPad ( Integer . toHexString ( b ) ) ; String hex4 = hexPad ( Integer . toHexString ( a ) ) ; return hex1 + hex2 + hex3 + hex4 ; }
tr	OAR	/	String E ( String s ) { return s . length ( ) % 2 == 0 ? s . substring ( s . length ( ) / 2 , s . length ( ) ) + s . substring ( 0 , s . length ( ) / 2 ) : s . substring ( s . length ( ) / 2 + 1 , s . length ( ) ) + s . charAt ( s . length ( ) / 2 ) + s . substring ( 0 , s . length ( ) / 2 ) ; }
tr	KMD	public	public DemeJoinEvent ( long t , int i , int j ) { super ( t ) ; this . i = i ; this . j = j ; }
tr	OAR	-	public synchronized void setAttribute ( final String name , final String value ) { final AttributeEntry entry = new AttributeEntry ( name , value ) ; final int pos = this . entryList . indexOf ( entry ) ; if ( pos != - 1 ) { this . entryList . remove ( pos ) ; } this . entryList . add ( entry ) ; }
tr	KFC	return	public ZoneRef getConnectingZoneRef ( ) { return connectingZoneRef ; }
tr	KPT	int	public void removeVlan ( int v ) { Vlans . remove ( v ) ; }
tr	KPT	int	public static int [ ] readIntArray ( Hessian2Input dis ) { int size ; int [ ] intArray = null ; try { size = dis . readInt ( ) ; if ( size == 0 ) { return null ; } intArray = new int [ size ] ; for ( int i = 0 ; i < intArray . length ; i ++ ) { intArray [ i ] = dis . readInt ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; System . out . println ( "Error in readIntArray()" ) ; System . exit ( 1 ) ; } return intArray ; }
tr	KPT	boolean	public static boolean isConcrete ( class type ) { int modifiers = type . getModifiers ( ) ; return ! ( Modifier . isInterface ( modifiers ) || Modifier . isAbstract ( modifiers ) ) ; }
tr	KFC	if	public void executeCommand ( MouseEvent e , int i ) { if ( controller . getEditMode ( ) != EditMode . new ) { controller . setSelectedIndex ( i ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; } }
tr	KFC	return	@ Override public int sendMSG ( final int id , final String msg ) { if ( id == this . id ) { int tmp = hopCount ; hopCount = 0 ; logEnabled = false ; return tmp == 0 ? 1 : tmp ; } hopCount = 0 ; logEnabled = true ; System . out . format ( "Node@%d forwards message '%s' to Node@%d%n" , this . id , msg , id ) ; return lookUpSuc ( id ) . sendMSG ( id , msg ) ; }
tr	KEH	assert	private static String createHtmlTable ( String name , int dimX , int dimY , int fixedDim , int fixedValue , boolean overall ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] xDimArray = dimensionArrays [ dimX ] ; String [ ] yDimArray = dimensionArrays [ dimY ] ; IntReference x = null ; IntReference y = null ; IntReference storeInd = new IntReference ( 0 ) ; IntReference queryInd = new IntReference ( 0 ) ; IntReference sizeInd = new IntReference ( 0 ) ; String queryDim = "" ; if ( dimX == 0 ) x = storeInd ; else if ( dimX == 1 ) x = sizeInd ; else if ( dimX == 2 ) { x = queryInd ; queryDim = "X" ; } if ( dimY == 0 ) y = storeInd ; else if ( dimY == 1 ) y = sizeInd ; else if ( dimY == 2 ) { y = queryInd ; queryDim = "Y" ; } if ( fixedDim == 0 ) storeInd = new IntReference ( fixedValue ) ; else if ( fixedDim == 1 ) sizeInd = new IntReference ( fixedValue ) ; else if ( fixedDim == 2 ) { queryInd = new IntReference ( fixedValue ) ; queryDim = "Fixed" ; } assert queryDim . equals ( "" ) : "Query dimension not set!" ; if ( x == null || y == null ) { System . err . println ( "Wrong dimension setting" ) ; System . exit ( - 1 ) ; } sb . append ( "<h4>" + name + "</h4>\n" ) ; sb . append ( tabledef ) ; sb . append ( "<b><tr><th>&nbsp;</th>" ) ; for ( int i = 0 ; i < xDimArray . length ; i ++ ) sb . append ( "<th>" + xDimArray [ i ] + "</th>" ) ; sb . append ( "</tr>\n" ) ; for ( y . setValue ( 0 ) ; y . getValue ( ) < yDimArray . length ; y . inc ( ) ) { String link = yDimArray [ y . getValue ( ) ] ; if ( queryDim . equals ( "Y" ) ) link = "<a href=\"" + queryLink + ( y . getValue ( ) + 1 ) + "\">" + yDimArray [ y . getValue ( ) ] + "</a>" ; sb . append ( "<tr><td width=\"29%\"><strong>" + link + "</strong></td>" ) ; for ( x . setValue ( 0 ) ; x . getValue ( ) < xDimArray . length ; x . inc ( ) ) { String val ; if ( overall ) val = storesSizes [ storeInd . getValue ( ) ] [ sizeInd . getValue ( ) ] ; else val = storesQueriesSizes [ storeInd . getValue ( ) ] [ sizeInd . getValue ( ) ] [ queryInd . getValue ( ) ] ; if ( val != null ) { if ( val . equals ( "0.0" ) ) sb . append ( "<td>not executed</td>" ) ; else { String formatString = "%." + queryParameterPrecision + "f" ; if ( american ) sb . append ( "<td>" + String . format ( formatString , double . parseDouble ( val ) ) . replace (   , . ) + "</td>" ) ; else sb . append ( "<td>" + String . format ( formatString , double . parseDouble ( val ) ) . replace ( . ,   ) + "</td>" ) ; } } else sb . append ( "<td>no value</td>" ) ; } sb . append ( "</tr>\n" ) ; } sb . append ( "</table>\n" ) ; return sb . toString ( ) ; }
tr	KPT	boolean	public boolean hasRequest ( ) { return ( ( bitField0_ & 00000040 ) == 00000040 ) ; }
tr	ORE	<	@ XmlTransient public List < Atendimento > getAtendimentoList ( ) { return atendimentoList ; }
tr	OUT	++	public void replaceWithModel ( Model model , boolean replaceAlpha ) { vertexCount = model . vertexCount ; triangleCount = model . triangleCount ; texturedTriangleCount = model . texturedTriangleCount ; if ( anIntArray1622 . length < vertexCount ) { anIntArray1622 = new int [ vertexCount + 100 ] ; anIntArray1623 = new int [ vertexCount + 100 ] ; anIntArray1624 = new int [ vertexCount + 100 ] ; } verticesX = anIntArray1622 ; verticesY = anIntArray1623 ; verticesZ = anIntArray1624 ; for ( int vertex = 0 ; vertex < vertexCount ; vertex ++ ) { verticesX [ vertex ] = model . verticesX [ vertex ] ; verticesY [ vertex ] = model . verticesY [ vertex ] ; verticesZ [ vertex ] = model . verticesZ [ vertex ] ; } if ( replaceAlpha ) { triangleAlpha = model . triangleAlpha ; } else { if ( anIntArray1625 . length < triangleCount ) anIntArray1625 = new int [ triangleCount + 100 ] ; triangleAlpha = anIntArray1625 ; if ( model . triangleAlpha == null ) { for ( int triangle = 0 ; triangle < triangleCount ; triangle ++ ) triangleAlpha [ triangle ] = 0 ; } else { System . arraycopy ( model . triangleAlpha , 0 , triangleAlpha , 0 , triangleCount ) ; } } triangleDrawType = model . triangleDrawType ; triangleColours = model . triangleColours ; trianglePriorities = model . trianglePriorities ; trianglePriority = model . trianglePriority ; triangleSkin = model . triangleSkin ; vertexSkin = model . vertexSkin ; triangleX = model . triangleX ; triangleY = model . triangleY ; triangleZ = model . triangleZ ; triangleHSLA = model . triangleHSLA ; triangleHSLB = model . triangleHSLB ; triangleHSLC = model . triangleHSLC ; texturedTrianglePointsX = model . texturedTrianglePointsX ; texturedTrianglePointsY = model . texturedTrianglePointsY ; texturedTrianglePointsZ = model . texturedTrianglePointsZ ; }
tr	OAR	/	@ Override protected void controlUpdate ( float tpf ) { if ( GameStarted . gameStart ) { if ( ! saved ) { if ( ! playerLevelCollision ( ) ) { if ( timer <= 0 ) { decreaseHP ( dmg ) ; timer = 200 ; } else { timer -- ; } } } } if ( hp < 0 ) { } ( ( Node ) spatial ) . getChild ( "InnerCrystal" ) . setLocalScale ( ( hp / maxHp ) + .001f ) ; }
tr	ORE	>=	@ Test public void testInsertion2 ( ) { assertArrayEquals ( SORTED_ARRAY2 , insertion . sort ( UNSORTED_ARRAY2 ) ) ; System . out . println ( SORTED_ARRAY2 . length * SORTED_ARRAY2 . length + " " + insertion . getOperations ( ) ) ; assertTrue ( SORTED_ARRAY2 . length * SORTED_ARRAY2 . length >= insertion . getOperations ( ) ) ; }
tr	OAS	>>=	public String randomSHA1 ( ) { byte [ ] b = new byte [ 4 ] ; int i = ranGen . nextInt ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { b [ j ] = ( byte ) ( i % 256 ) ; i >>= 8 ; } MessageDigest md = null ; try { md = MessageDigest . getInstance ( "SHA1" ) ; } catch ( java . security . NoSuchAlgorithmException e ) { System . err . println ( e . getMessage ( ) ) ; System . exit ( - 1 ) ; } byte [ ] chksum = md . digest ( b ) ; StringBuffer result = new StringBuffer ( ) ; for ( int j = 0 ; j < chksum . length ; j ++ ) result . append ( Integer . toHexString ( FF & chksum [ j ] ) ) ; return result . toString ( ) ; }
tr	KEH	try	private void createTables ( ) { for ( TableRegistration table : getTables ( ) . values ( ) ) { StringBuilder query = new StringBuilder ( ) ; query . append ( "CREATE TABLE IF NOT EXISTS " ) . append ( table . getName ( ) ) . append ( " (" ) . append ( table . getId ( ) . getName ( ) ) . append ( " " ) . append ( MySQLUtil . getMySQLTypeFromClass ( table . getId ( ) . getType ( ) ) ) . append ( " NOT NULL AUTO_INCREMENT PRIMARY KEY  " ) ; int count = 0 ; for ( FieldRegistration field : table . getFields ( ) ) { count ++ ; String type = null ; if ( field . isSerializable ( ) ) { type = MySQLUtil . getMySQLTypeFromClass ( String . class ) ; } else { type = MySQLUtil . getMySQLTypeFromClass ( field . getType ( ) ) ; } query . append ( field . getName ( ) ) . append ( " " ) . append ( type ) ; if ( count != table . getFields ( ) . size ( ) ) { query . append ( "  " ) ; } } query . append ( ") " ) ; try { PreparedStatement statement = conn . prepareStatement ( query . toString ( ) ) ; statement . executeUpdate ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } }
tr	KPT	int	public int getStart ( ) { return start ; }
tr	KMD	final	private ExportToFileAction ( final CommandControl commandControl , final NotesController notesController , final MainWindow mainWindow ) { this . commandControl = commandControl ; this . notesController = notesController ; this . mainWindow = mainWindow ; setName ( "Export notes\u2026" ) ; setDescription ( "Create a human readable file  wich contains all notes." ) ; }
tr	KMD	public	public void setHEADER ( SNode hEADER ) { HEADER = hEADER ; }
tr	OAS	&=	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
tr	OUT	++	private void agregarItems ( ) { ClientesTango cli = ( ClientesTango ) clientes . get ( this . jList1 . getSelectedIndex ( ) ) ; System . out . println ( "elegido " + cli . getRazonSocial ( ) ) ; MiModeloTablaContacto contacto = new MiModeloTablaContacto ( ) ; this . jTable1 . removeAll ( ) ; this . jTable1 . setModel ( contacto ) ; contacto . addColumn ( "" ) ; contacto . addColumn ( "" ) ; contacto . addColumn ( "Contacto" ) ; Object [ ] fila = new Object [ 3 ] ; fila [ 0 ] = "Direccion" ; fila [ 1 ] = cli . getDireccion ( ) ; fila [ 2 ] = false ; contacto . addRow ( fila ) ; fila [ 0 ] = "Telefono" ; fila [ 1 ] = cli . getTelefono ( ) ; fila [ 2 ] = false ; contacto . addRow ( fila ) ; fila [ 0 ] = "Observaciones" ; fila [ 1 ] = cli . getObservaciones ( ) ; fila [ 2 ] = false ; contacto . addRow ( fila ) ; for ( int i = 0 ; i < agregados . size ( ) ; i ++ ) { fila [ 0 ] = "Agregado" ; fila [ 1 ] = agregados . get ( i ) ; fila [ 2 ] = true ; contacto . addRow ( fila ) ; } }
tr	OUT	++	public void setSearchResults ( ArrayList < LogItem > list ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { LogItem log = list . get ( i ) ; String action = "" ; if ( log . getAction ( ) == LogItem . INVENTORY ) action = "INVENTORY" ; else if ( log . getAction ( ) == LogItem . LOGIN ) action = "LOGIN" ; else if ( log . getAction ( ) == LogItem . SALES ) action = "SALES" ; else if ( log . getAction ( ) == LogItem . SYSTEM ) action = "SYSTEM" ; else action = "USER" ; String [ ] strings = new String [ ] { "" + log . getID ( ) , log . getTimeStampString ( ) , action , log . getDesc ( ) } ; ( ( DefaultTableModel ) m_logList . getModel ( ) ) . addRow ( strings ) ; } }
tr	KEH	assert	@ Test public void testSpecialNullSerialization ( ) throws Exception { final Interpreter originalInterpreter = new Interpreter ( ) ; originalInterpreter . eval ( "myNull = null;" ) ; assert . assertTrue ( ( boolean ) originalInterpreter . eval ( "myNull == null" ) ) ; final Interpreter deserInterpreter = TestUtil . serDeser ( originalInterpreter ) ; assert . assertTrue ( ( boolean ) deserInterpreter . eval ( "myNull == null" ) ) ; }
tr	ORE	<	public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = "" ; StringBuilder out = new StringBuilder ( ) ; do { ArrayList < String [ ] > l = new ArrayList < String [ ] > ( ) ; if ( out . length ( ) != 0 && line . length ( ) != 0 && ! line . contains ( "%" ) ) l . add ( line . trim ( ) . split ( " " ) ) ; while ( ( line = in . readLine ( ) ) != null && line . length ( ) != 0 && ! line . contains ( "%" ) ) l . add ( line . trim ( ) . split ( " " ) ) ; n = l . size ( ) ; m = l . get ( 0 ) . length ; map = new char [ n ] [ m ] ; ans = new int [ n ] [ m ] ; String [ ] row ; for ( int i = 0 ; i < n ; i ++ ) { row = l . get ( i ) ; for ( int j = 0 ; j < m ; j ++ ) map [ i ] [ j ] = row [ j ] . charAt ( 0 ) ; } int index = 1 ; int [ ] lengths = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) { if ( ans [ i ] [ j ] == 0 ) { ans [ i ] [ j ] = index ; floodFill ( i , j , map [ i ] [ j ] , index ++ ) ; } lengths [ j ] = Math . max ( lengths [ j ] , ( ans [ i ] [ j ] + "" ) . length ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( j != 0 ) out . append ( String . format ( "%" + ( lengths [ j ] + 1 ) + "d" , ans [ i ] [ j ] ) ) ; else out . append ( String . format ( "%" + lengths [ j ] + "d" , ans [ i ] [ j ] ) ) ; } out . append ( "\n" ) ; } out . append ( "%\n" ) ; } while ( ( line = in . readLine ( ) ) != null && line . length ( ) != 0 ) ; System . out . print ( out ) ; }
tr	ORE	<	public Card getCard ( String profileId , String cardId ) throws BeanstreamApiException { ProfilesUtils . validateProfileId ( profileId ) ; Gateway . assertNotEmpty ( cardId , "card id is empty" ) ; String url = BeanstreamUrls . getProfileCardUrl ( config . getPlatform ( ) , config . getVersion ( ) , profileId , cardId ) ; String response = connector . ProcessTransaction ( HttpMethod . get , url , null ) ; ProfileCardsResponse pcr = gson . fromJson ( response , ProfileCardsResponse . class ) ; Card card = null ; if ( ! pcr . getCards ( ) . isEmpty ( ) ) { int cid = new Integer ( cardId ) - 1 ; if ( cid < 0 || cid > pcr . getCards ( ) . size ( ) ) throw new IllegalArgumentException ( "Card ID was larger than the number of cards on the profile!" ) ; card = pcr . getCards ( ) . get ( cid ) ; card . setId ( cardId ) ; } return card ; }
tr	KPT	int	public int [ ] integerToInt ( Integer [ ] data ) { int [ ] array = new int [ data . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = data [ i ] ; } return array ; }
tr	ORE	<	public static List < Offre > lister ( Connection connection ) { Statement stmt = null ; List < Offre > liste = new ArrayList < Offre > ( ) ; try { stmt = connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT Identifiant Intitule Reference DatePublication DureeDiffusion DateDebutContrat NbPostes Localisation DescriptionPoste DescriptionProfil Telephone Email IdentifiantType_Contrat IdentifiantMetier IdentifiantDomaine_Metier IdentifiantAnnonceur FROM Offre" ) ; while ( rs . next ( ) ) { Offre offre = new Offre ( ) ; int id = rs . getInt ( "Identifiant" ) ; String intitule = rs . getString ( "Intitule" ) ; String reference = rs . getString ( "Reference" ) ; Date datePublication = rs . getDate ( "DatePublication" ) ; int dureeDiffusion = rs . getInt ( "DureeDiffusion" ) ; Date dateDebutcontrat = rs . getDate ( "DateDebutContrat" ) ; int nbPostes = rs . getInt ( "NbPostes" ) ; String localisation = rs . getString ( "Localisation" ) ; String descriptionPoste = rs . getString ( "DescriptionPoste" ) ; String descriptionProfil = rs . getString ( "DescriptionProfil" ) ; String telephone = rs . getString ( "Telephone" ) ; String mail = rs . getString ( "Email" ) ; int idTypeContrat = rs . getInt ( "IdentifiantType_Contrat" ) ; int idMetier = rs . getInt ( "IdentifiantMetier" ) ; int idDomaineMetier = rs . getInt ( "IdentifiantDomaine_Metier" ) ; int idAnnonceur = rs . getInt ( "IdentifiantAnnonceur" ) ; offre . setId ( rs . getInt ( "Identifiant" ) ) ; offre . setIntitule ( rs . getString ( "Intitule" ) ) ; offre . setReference ( rs . getString ( "Reference" ) ) ; offre . setDatePublication ( rs . getDate ( "DatePublication" ) ) ; offre . setDureeDiffusion ( rs . getInt ( "DureeDiffusion" ) ) ; offre . setDateDebutContrat ( rs . getDate ( "DateDebutContrat" ) ) ; offre . setNbPostes ( rs . getInt ( "NbPostes" ) ) ; offre . setLocalisation ( rs . getString ( "Localisation" ) ) ; offre . setDescriptionPoste ( rs . getString ( "DescriptionPoste" ) ) ; offre . setDescriptionProfil ( rs . getString ( "DescriptionProfil" ) ) ; offre . setTelephone ( rs . getString ( "Telephone" ) ) ; offre . setMail ( rs . getString ( "Email" ) ) ; offre . setIdTypeContrat ( rs . getInt ( "IdentifiantType_Contrat" ) ) ; offre . setIdMetier ( rs . getInt ( "IdentifiantMetier" ) ) ; offre . setIdDomaineMetier ( rs . getInt ( "IdentifiantDomaine_Metier" ) ) ; offre . setIdAnnonceur ( rs . getInt ( "IdentifiantAnnonceur" ) ) ; liste . add ( offre ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } return liste ; } }
tr	KPT	boolean	public boolean hasMore ( ) { return numLeft . compareTo ( BigInteger . ZERO ) == 1 ; }
tr	ORE	<=	public Cashpoint getNextCashpoint ( ) { if ( getOpenCashpoints ( ) . size ( ) <= 0 ) { return openCashpoint ( ) ; } else { return getCashpointWithShortestQueue ( ) ; } }
tr	OLB	&&	@ Override protected boolean canFigureMove ( Point x , Point Abs ) { if ( ( x . x == 1 * getFI ( ) || ( x . x == 2 * getFI ( ) && isFirstMove ) ) && x . y == 0 ) if ( ! C . isFigure ( Abs ) && x . x == 1 * getFI ( ) || ! C . isFigure ( Abs ) && ! C . isFigure ( new Point ( Abs . x - getFI ( ) , Abs . y ) ) && x . x == 2 * getFI ( ) ) return true ; return false ; }
tr	OAS	/=	public static StackLinkedList < Integer > convertBase ( int number , int base ) { StackLinkedList < Integer > remainders = new StackLinkedList < Integer > ( ) ; for ( ; number / base != 0 ; number /= base ) { remainders . push ( number % base ) ; } remainders . push ( number % base ) ; return remainders ; }
tr	KPT	double	public double getFontHeight ( JGFont font ) ;
tr	OAS	<<=	private void writeBit ( boolean bit ) { buffer <<= 1 ; if ( bit ) buffer |= 1 ; N ++ ; if ( N == 8 ) clearBuffer ( ) ; }
tr	SYM	;	public final Outer_join_typeContext outer_join_type ( ) throws RecognitionException { Outer_join_typeContext _localctx = new Outer_join_typeContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 246 , RULE_outer_join_type ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 1255 ) ; outer_join_type_part2 ( ) ; setState ( 1257 ) ; _la = _input . LA ( 1 ) ; if ( _la == OUTER ) { { setState ( 1256 ) ; match ( OUTER ) ; } } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	OAR	/	public static boolean chanceOfPercent ( double percentChance ) { return random . nextDouble ( ) <= ( percentChance / 100 ) ; }
tr	OUT	++	int [ ] getPath ( ) { int [ ] p = new int [ idx ] ; for ( int i = 0 ; i < idx ; i ++ ) { p [ i ] = ( int ) ( path [ i ] & ffffffff ) ; } return p ; }
tr	OLB	||	public final int intValue ( ) { if ( bigValue != null || value < java . lang . Integer . MIN_VALUE || value > java . lang . Integer . MAX_VALUE ) { throw new JPLException ( "cannot represent value as an int" ) ; } else { return ( int ) value ; } }
tr	OLB	&&	public boolean isPerpendicularTo ( Direction other ) { return this != other && this . opposite ( ) != other ; }
tr	KPT	int	public void setListCnt ( int listCnt ) { this . listCnt = listCnt ; }
tr	OUT	++	private boolean [ ] getMissileGraphics ( int index ) { int iSize = getMissileSize ( index ) ; boolean [ ] bGraphics = new boolean [ MISSILE_WIDTH * iSize ] ; for ( int i = 0 ; i < bGraphics . length ; i ++ ) { bGraphics [ i ] = true ; } return bGraphics ; }
tr	OAS	/=	private double measurePatternListError ( List < Pattern > patterns ) { try { double error = 0 ; int count = 0 ; for ( Pattern pattern : patterns ) { feedForward ( pattern . getInput ( ) ) ; error += meanSquaredError ( pattern . getOutput ( ) ) ; count ++ ; } error /= count ; return error ; } catch ( RuntimeException e ) { return - 1.0 ; } }
tr	KEH	try	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new SimpleTest ( ) ) ; app . setShowFPS ( true ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	KFC	if	public void update ( Observable observable , Object change ) { if ( observable instanceof Board && ( change instanceof Move || change instanceof Flip ) ) { updateTileButtons ( ( Turn ) change ) ; } }
tr	OUT	++	public void run ( ) { for ( int i = 0 ; i < repeatCount ; i ++ ) { repeatable . run ( ) ; } }
tr	OAS	*=	public void repaint ( Rectangle r ) { if ( renderMode != RenderMode . TILED ) { r . x *= zoom ; r . y *= zoom ; r . width = ( r . width + 1 ) * zoom ; r . height = ( r . height + 1 ) * zoom ; } else r = new Rectangle ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; super . repaint ( r ) ; }
tr	SYM	)	public ForStatementParser ( PascalParserTD parent ) { super ( parent ) ; }
tr	KMD	public	public void visitIn ( T element , int depth ) ;
tr	OAR	/	public Object nextMeta ( ) throws JSONException { char c ; char q ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case 0 : throw syntaxError ( "Misshaped meta tag" ) ; case < : return XML . < ; case > : return XML . > ; case / : return XML . / ; case = : return XML . = ; case ! : return XML . ! ; case ? : return XML . QUEST ; case " : case ' : q = c ; for ( ; ; ) { c = next ( ) ; if ( c == 0 ) { throw syntaxError ( "Unterminated string" ) ; } if ( c == q ) { return boolean . true ; } } default : for ( ; ; ) { c = next ( ) ; if ( Character . isWhitespace ( c ) ) { return boolean . true ; } switch ( c ) { case 0 : case < : case > : case / : case = : case ! : case ? : case " : case ' : back ( ) ; return boolean . true ; } } } }
tr	OLB	&&	@ SuppressWarnings ( "rawtypes" ) public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; int i ; JSONArray ja ; String key ; Iterator keys ; int length ; Object object ; String tagName ; String value ; tagName = jo . optString ( "tagName" ) ; if ( tagName == null ) { return XML . escape ( jo . toString ( ) ) ; } XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; if ( ! "tagName" . equals ( key ) && ! "childNodes" . equals ( key ) ) { XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } ja = jo . optJSONArray ( "childNodes" ) ; if ( ja == null ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; length = ja . length ( ) ; for ( i = 0 ; i < length ; i += 1 ) { object = ja . get ( i ) ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } else { sb . append ( object . toString ( ) ) ; } } } sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	KEH	assert	public EncodedResource ( Resource resource , Charset charset ) { assert . notNull ( resource , "Resource must not be null" ) ; this . resource = resource ; this . charset = charset ; }
tr	KPT	boolean	public boolean containsTree ( Node < T > root , Node < T > otherRoot ) { if ( root == null || otherRoot == null ) { return false ; } if ( root . data . compareTo ( otherRoot . data ) == 0 ) { if ( matchTree ( root , otherRoot , false ) ) { return true ; } } if ( root . left != null ) { if ( containsTree ( root . left , otherRoot ) ) { return true ; } } if ( root . right != null ) { if ( containsTree ( root . right , otherRoot ) ) { return true ; } } return false ; }
tr	KMD	protected	protected Debug ( ) { super ( "DEBUG" , Level . INFO . intValue ( ) ) ; }
tr	OLB	&&	public String getAttr ( String path , String attrName ) { if ( ! "" . equals ( root ) && root != null ) path = root + "/" + path ; try { return pather . evaluate ( new StringBuilder ( ) . append ( path ) . append ( "/@" ) . append ( attrName ) . toString ( ) , doc ) ; } catch ( XPathExpressionException e ) { e . printStackTrace ( ) ; } return "" ; }
tr	OAS	*=	public static int makeGreater ( final int one , final int another ) { int result = one ; while ( result < another ) { result *= 10 ; } return result ; }
tr	OAR	-	public SaleWindow ( final SalesSystemModel model , final SalesDomainController domainController , PurchaseTab purchaseTab ) { parentTab = purchaseTab ; setSize ( 300 , 300 ) ; setLocation ( 100 , 100 ) ; Container sisu = getContentPane ( ) ; sisu . setLayout ( new FlowLayout ( ) ) ; for ( SoldItem soldItem : model . getCurrentPurchaseTableModel ( ) . getTableRows ( ) ) { sum += soldItem . getSum ( ) ; } JLabel sumLabel = new JLabel ( String . valueOf ( sum ) ) ; payField = new JTextField ( 5 ) ; final JLabel label = new JLabel ( "0" ) ; payField . setText ( "0" ) ; JButton accept = new JButton ( "accept" ) ; accept . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { try { if ( double . parseDouble ( payField . getText ( ) ) >= sum ) { System . out . println ( "Sale confirmed" ) ; List < SoldItem > currentPurchaseItems = model . getCurrentPurchaseTableModel ( ) . getTableRows ( ) ; try { domainController . submitCurrentPurchase ( currentPurchaseItems , model ) ; parentTab . endSale ( ) ; } catch ( VerificationFailedException e1 ) { return ; } domainController . saveHistoryState ( currentPurchaseItems ) ; } else { System . out . println ( "Not enough money! Go be poor somewhere else" ) ; } dispose ( ) ; model . getCurrentPurchaseTableModel ( ) . clear ( ) ; } catch ( NumberFormatException f ) { System . out . println ( "Incorrect input!" ) ; } } } ) ; JButton dec = new JButton ( "decline" ) ; dec . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { dispose ( ) ; } } ) ; sisu . add ( sumLabel ) ; sisu . add ( payField ) ; sisu . add ( label ) ; sisu . add ( accept ) ; sisu . add ( dec ) ; payField . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { label . setText ( String . valueOf ( double . parseDouble ( payField . getText ( ) ) - sum ) ) ; } } ) ; }
tr	KFC	return	public static double refreshSpeed ( Bus bus ) { double speed = bus . getSpeed ( ) + bus . getAcceleration ( ) * TIME ; return speed ; }
tr	OAS	&=	static private int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0 ) return jjStartNfa_0 ( 5 , old0 , old1 , 0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 , 0 ) ; return 7 ; } switch ( curChar ) { case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 200000000000 , active1 , 0 ) ; case 101 : if ( ( active0 & 4000 ) != 0 ) return jjStartNfaWithStates_0 ( 7 , 14 , 1 ) ; else if ( ( active0 & 200000000000000 ) != 0 ) return jjStartNfaWithStates_0 ( 7 , 57 , 1 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 100000100000 , active1 , 0 ) ; case 110 : return jjMoveStringLiteralDfa8_0 ( active0 , 90040000000000 , active1 , 0 ) ; case 114 : if ( ( active1 & 1 ) != 0 ) return jjStartNfaWithStates_0 ( 7 , 64 , 1 ) ; break ; case 116 : if ( ( active0 & 80000000 ) != 0 ) return jjStartNfaWithStates_0 ( 7 , 31 , 1 ) ; break ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 , 0 ) ; }
tr	OLB	||	@ Override public BasicValue newOperation ( final AbstractInsnNode insn ) throws AnalyzerException { switch ( insn . getOpcode ( ) ) { case ACONST_NULL : return newValue ( Type . getObjectType ( "null" ) ) ; case ICONST_M1 : case ICONST_0 : case ICONST_1 : case ICONST_2 : case ICONST_3 : case ICONST_4 : case ICONST_5 : return BasicValue . INT_VALUE ; case LCONST_0 : case LCONST_1 : return BasicValue . LONG_VALUE ; case FCONST_0 : case FCONST_1 : case FCONST_2 : return BasicValue . FLOAT_VALUE ; case DCONST_0 : case DCONST_1 : return BasicValue . DOUBLE_VALUE ; case BIPUSH : case SIPUSH : return BasicValue . INT_VALUE ; case LDC : Object cst = ( ( LdcInsnNode ) insn ) . cst ; if ( cst instanceof Integer ) { return BasicValue . INT_VALUE ; } else if ( cst instanceof float ) { return BasicValue . FLOAT_VALUE ; } else if ( cst instanceof long ) { return BasicValue . LONG_VALUE ; } else if ( cst instanceof double ) { return BasicValue . DOUBLE_VALUE ; } else if ( cst instanceof String ) { return newValue ( Type . getObjectType ( "java/lang/String" ) ) ; } else if ( cst instanceof Type ) { int sort = ( ( Type ) cst ) . getSort ( ) ; if ( sort == Type . OBJECT || sort == Type . ARRAY ) { return newValue ( Type . getObjectType ( "java/lang/Class" ) ) ; } else if ( sort == Type . METHOD ) { return newValue ( Type . getObjectType ( "java/lang/invoke/MethodType" ) ) ; } else { throw new IllegalArgumentException ( "Illegal LDC constant " + cst ) ; } } else if ( cst instanceof Handle ) { return newValue ( Type . getObjectType ( "java/lang/invoke/MethodHandle" ) ) ; } else { throw new IllegalArgumentException ( "Illegal LDC constant " + cst ) ; } case JSR : return BasicValue . RETURNADDRESS_VALUE ; case GETSTATIC : return newValue ( Type . getType ( ( ( FieldInsnNode ) insn ) . desc ) ) ; case new : return newValue ( Type . getObjectType ( ( ( TypeInsnNode ) insn ) . desc ) ) ; default : throw new Error ( "Internal error." ) ; } }
tr	KFC	return	public double getUpperBound ( int n ) { return double . POSITIVE_INFINITY ; }
tr	OAR	-	private boolean isValid ( String colors , int start , int i ) { if ( colors . charAt ( start ) != colors . charAt ( i ) ) { return false ; } int a = Math . min ( start , i ) ; int b = Math . max ( start , i ) ; for ( int k = a + 1 ; k < b ; k ++ ) { int el = connections [ k ] ; if ( el != - 1 && ( el < a || el > b ) ) { return false ; } } return true ; }
tr	KEH	assert	public void testExpanding2 ( ) { ByteArrayDataOutputStream out = new ByteArrayDataOutputStream ( 1 ) ; out . write ( new byte [ ] { b , e , l , a } ) ; out = new ByteArrayDataOutputStream ( 1 ) ; out . writeBoolean ( true ) ; out . writeBoolean ( false ) ; assert out . position ( ) == 2 ; out = new ByteArrayDataOutputStream ( 1 ) ; out . writeShort ( 22 ) ; out . writeShort ( 23 ) ; assert out . position ( ) == 4 ; out = new ByteArrayDataOutputStream ( 1 ) ; out . writeInt ( 23 ) ; out . writeInt ( 24 ) ; assert out . position ( ) == 8 ; }
tr	ORE	<	public byte read ( ) throws IOException { if ( _pos < _len ) { ++ _read ; return _inputBuffer [ _pos ++ ] ; } return _inputBuffer [ _need ( 1 ) ] ; }
tr	OAS	&=	public boolean validateState ( State state , DiagnosticChain diagnostics , Map < Object , Object > context ) { if ( ! validate_NoCircularContainment ( state , diagnostics , context ) ) return false ; boolean result = validate_EveryMultiplicityConforms ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryDataValueConforms ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryReferenceIsContained ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryBidirectionalReferenceIsPaired ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryProxyResolves ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_UniqueID ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryKeyUnique ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validate_EveryMapEntryUnique ( state , diagnostics , context ) ; if ( result || diagnostics != null ) result &= validateState_countryToStateMapIsAccurate ( state , diagnostics , context ) ; return result ; }
tr	OAR	%	public static String buildQuery ( final String ... params ) { if ( params . length % 2 != 0 ) { throw new IllegalArgumentException ( "URLs.buildQuery() requires a balanced list of parameters" ) ; } StringBuilder result = new StringBuilder ( ) ; buildQuery ( result , params ) ; return result . toString ( ) ; }
tr	KPT	int	private void excluir ( ) { int index ; if ( ( index = tbDados . getSelectedRow ( ) ) != - 1 ) { if ( categoriaBO . removeSelected ( index ) ) { Formulario . alertar ( "Registro exclu\u00EDdo com sucesso!" ) ; populaTb ( ) ; } else { Formulario . alertar ( "Falha ao excluir registro!" ) ; } } else { Formulario . alertar ( "Selecione o registro a excluir!" ) ; } }
tr	ORE	<	public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = "" ; StringBuilder out = new StringBuilder ( ) ; while ( ( line = in . readLine ( ) ) != null && line . length ( ) != 0 ) { int times = Integer . parseInt ( line . trim ( ) ) ; for ( int i = 0 ; i < times ; i ++ ) { if ( i != 0 ) out . append ( "\n" ) ; int nComp = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; c = new Company [ nComp ] ; for ( int j = 0 ; j < nComp ; j ++ ) c [ j ] = new Company ( in . readLine ( ) . trim ( ) ) ; int nQueries = Integer . parseInt ( in . readLine ( ) . trim ( ) ) , q ; for ( int j = 0 ; j < nQueries ; j ++ ) { q = Integer . parseInt ( in . readLine ( ) . trim ( ) ) ; int indexAns = 0 , countAns = 0 ; for ( int k = 0 ; k < c . length ; k ++ ) if ( c [ k ] . low <= q && q <= c [ k ] . high ) { indexAns = k ; countAns ++ ; if ( countAns >= 2 ) break ; } if ( countAns == 1 ) out . append ( c [ indexAns ] . name + "\n" ) ; else out . append ( "UNDETERMINED\n" ) ; } } } System . out . print ( out ) ; }
tr	OLB	||	@ Override public boolean save ( final Configuration config ) { ConfigurationOptions options = config . getOptions ( ) ; assert options . getArgument ( "file" ) instanceof File || options . getArgument ( "file" ) != null : "Argument 'file' is not instance of File or is null" ; try { final File file = ( File ) options . getArgument ( "file" ) ; final Gson gson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; final PrintWriter writer = new PrintWriter ( new FileWriter ( file , false ) ) ; writer . write ( gson . toJson ( config . getMap ( ) ) ) ; writer . close ( ) ; } catch ( final Exception e ) { return false ; } return true ; }
tr	OAR	-	public static void main ( String args [ ] ) { int w ; double bal ; Scanner obj1 = new Scanner ( System . in ) ; System . out . print ( "" ) ; w = obj1 . nextInt ( ) ; bal = obj1 . nextDouble ( ) ; if ( w % 5 == 0 && bal >= ( w + 0.50 ) ) { System . out . println ( bal - ( w + 0.50 ) ) ; } else if ( w % 5 != 0 || bal < ( w + 0.50 ) ) { System . out . println ( bal ) ; } }
tr	KFC	return	@ Override public int getSpellpower ( ) { return spellpower ; }
tr	OAR	-	public void addAdherent ( Adherent adherent ) throws Exception { adherent . setNom ( adherent . getNom ( ) . replace ( "'" , "\\'" ) ) ; adherent . setPrenom ( adherent . getPrenom ( ) . replace ( "'" , "\\'" ) ) ; Adherent add = adherentMetierService . add ( adherent ) ; adherent . setNom ( adherent . getNom ( ) . replace ( "\\'" , "'" ) ) ; adherent . setPrenom ( adherent . getPrenom ( ) . replace ( "\\'" , "'" ) ) ; adherents . add ( add ) ; fireTableRowsInserted ( adherents . size ( ) - 1 , adherents . size ( ) - 1 ) ; if ( adherents . size ( ) > ( perpage * page ) ) { adherents . remove ( 0 ) ; fireTableRowsDeleted ( 0 , 0 ) ; } }
tr	OAR	-	private void processChatModeClick ( ) { if ( super . clickMode3 == 1 ) { if ( super . saveClickX >= 6 && super . saveClickX <= 106 && super . saveClickY >= 467 && super . saveClickY <= 499 ) { publicChatMode = ( publicChatMode + 1 ) % 4 ; aBoolean1233 = true ; inputTaken = true ; outputStream . writeOpcode ( 95 ) ; outputStream . writeByte ( publicChatMode ) ; outputStream . writeByte ( privateChatMode ) ; outputStream . writeByte ( tradeMode ) ; } if ( super . saveClickX >= 135 && super . saveClickX <= 235 && super . saveClickY >= 467 && super . saveClickY <= 499 ) { privateChatMode = ( privateChatMode + 1 ) % 3 ; aBoolean1233 = true ; inputTaken = true ; outputStream . writeOpcode ( 95 ) ; outputStream . writeByte ( publicChatMode ) ; outputStream . writeByte ( privateChatMode ) ; outputStream . writeByte ( tradeMode ) ; } if ( super . saveClickX >= 273 && super . saveClickX <= 373 && super . saveClickY >= 467 && super . saveClickY <= 499 ) { tradeMode = ( tradeMode + 1 ) % 3 ; aBoolean1233 = true ; inputTaken = true ; outputStream . writeOpcode ( 95 ) ; outputStream . writeByte ( publicChatMode ) ; outputStream . writeByte ( privateChatMode ) ; outputStream . writeByte ( tradeMode ) ; } if ( super . saveClickX >= 412 && super . saveClickX <= 512 && super . saveClickY >= 467 && super . saveClickY <= 499 ) { if ( openInterfaceId == - 1 ) { closeOpenInterfaces ( ) ; reportAbuseInput = "" ; canMute = false ; for ( interface element : interface . cachedInterfaces ) { if ( element == null || element . contentType != 600 ) { continue ; } reportAbuseInterfaceID = openInterfaceId = element . parentId ; break ; } } else { pushMessage ( "Please close the interface you have open before using 'report abuse'" , 0 , "" ) ; } } Client . anInt940 ++ ; if ( Client . anInt940 > 1386 ) { Client . anInt940 = 0 ; outputStream . writeOpcode ( 165 ) ; outputStream . writeByte ( 0 ) ; int j = outputStream . offset ; outputStream . writeByte ( 139 ) ; outputStream . writeByte ( 150 ) ; outputStream . writeShort ( 32131 ) ; outputStream . writeByte ( ( int ) ( Math . random ( ) * 256D ) ) ; outputStream . writeShort ( 3250 ) ; outputStream . writeByte ( 177 ) ; outputStream . writeShort ( 24859 ) ; outputStream . writeByte ( 119 ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) { outputStream . writeShort ( 47234 ) ; } if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) { outputStream . writeByte ( 21 ) ; } outputStream . writeSizeByte ( outputStream . offset - j ) ; } } }
tr	KMD	public	public void doPost ( HttpServletRequest request , HttpServletResponse response ) { doGet ( request , response ) ; }
tr	OLB	||	public static String quote ( String string ) { if ( string == null || string . length ( ) == 0 ) { return "\"\"" ; } char b ; char c = 0 ; int i ; int len = string . length ( ) ; StringBuffer sb = new StringBuffer ( len + 4 ) ; String t ; sb . append ( " ) ; for ( i = 0 ; i < len ; i += 1 ) { b = c ; c = string . charAt ( i ) ; switch ( c ) { case \ : case " : sb . append ( \ ) ; sb . append ( c ) ; break ; case / : if ( b == < ) { sb . append ( \ ) ; } sb . append ( c ) ; break ; case : sb . append ( "\\b" ) ; break ; case 	 : sb . append ( "\\t" ) ; break ; case  : sb . append ( "\\n" ) ; break ; case  : sb . append ( "\\f" ) ; break ; case  : sb . append ( "\\r" ) ; break ; default : if ( c <   || ( c >=  && c <  ) || ( c >=  && c <  ) ) { t = "000" + Integer . toHexString ( c ) ; sb . append ( "\\u" + t . substring ( t . length ( ) - 4 ) ) ; } else { sb . append ( c ) ; } } } sb . append ( " ) ; return sb . toString ( ) ; }
tr	KFC	else	public Cone ( float radius , float height , int primflags , int xdivision , int ydivision , Appearance ap ) { super ( ) ; Shape3D shape [ ] = new Shape3D [ 2 ] ; this . radius = radius ; this . height = height ; xdivisions = xdivision ; ydivisions = ydivision ; flags = primflags ; boolean outside = ( flags & GENERATE_NORMALS_INWARD ) == 0 ; boolean texCoordYUp = ( flags & GENERATE_TEXTURE_COORDS_Y_UP ) != 0 ; Quadrics q = new Quadrics ( ) ; GeomBuffer gbuf = null ; GeomBuffer cache = getCachedGeometry ( Primitive . CONE , radius , 0.0f , height , xdivision , ydivision , primflags ) ; if ( cache != null ) { shape [ BODY ] = new Shape3D ( cache . getComputedGeometry ( ) ) ; numVerts += cache . getNumVerts ( ) ; numTris += cache . getNumTris ( ) ; } else { gbuf = q . coneTop ( ( double ) ( height / 2.0 - height / ydivisions ) , ( double ) ( radius / ydivisions ) , height / ydivisions , xdivisions , 1.0 - 1.0 / ( double ) ydivisions , outside , texCoordYUp ) ; shape [ BODY ] = new Shape3D ( gbuf . getGeom ( flags ) ) ; numVerts += gbuf . getNumVerts ( ) ; numTris += gbuf . getNumTris ( ) ; if ( ( primflags & Primitive . GEOMETRY_NOT_SHARED ) == 0 ) { cacheGeometry ( Primitive . CONE , radius , 0.0f , height , xdivision , ydivision , primflags , gbuf ) ; } } if ( ydivisions > 1 ) { cache = getCachedGeometry ( Primitive . CONE_DIVISIONS , radius , 0.0f , height , xdivision , ydivision , primflags ) ; if ( cache != null ) { shape [ BODY ] . addGeometry ( cache . getComputedGeometry ( ) ) ; numVerts += cache . getNumVerts ( ) ; numTris += cache . getNumTris ( ) ; } else { gbuf = q . coneBody ( - ( double ) ( height / 2.0 ) , ( double ) ( height / 2.0 - height / ydivisions ) , ( double ) radius , ( double ) ( radius / ydivisions ) , xdivisions , ydivisions - 1 , 1.0 / ( double ) ydivisions , outside , texCoordYUp ) ; shape [ BODY ] . addGeometry ( gbuf . getGeom ( flags ) ) ; numVerts += gbuf . getNumVerts ( ) ; numTris += gbuf . getNumTris ( ) ; if ( ( primflags & Primitive . GEOMETRY_NOT_SHARED ) == 0 ) { cacheGeometry ( Primitive . CONE_DIVISIONS , radius , 0.0f , height , xdivision , ydivision , primflags , gbuf ) ; } } } if ( ( flags & ENABLE_APPEARANCE_MODIFY ) != 0 ) { ( shape [ BODY ] ) . setCapability ( Shape3D . ALLOW_APPEARANCE_READ ) ; ( shape [ BODY ] ) . setCapability ( Shape3D . ALLOW_APPEARANCE_WRITE ) ; } if ( ( flags & ENABLE_GEOMETRY_PICKING ) != 0 ) { ( shape [ BODY ] ) . setCapability ( Shape3D . ALLOW_GEOMETRY_READ ) ; } this . addChild ( shape [ BODY ] ) ; cache = getCachedGeometry ( Primitive . BOTTOM_DISK , radius , radius , - height / 2.0f , xdivision , xdivision , primflags ) ; if ( cache != null ) { shape [ CAP ] = new Shape3D ( cache . getComputedGeometry ( ) ) ; numVerts += cache . getNumVerts ( ) ; numTris += cache . getNumTris ( ) ; } else { gbuf = q . disk ( ( double ) radius , xdivision , - ( double ) height / 2.0 , ! outside , texCoordYUp ) ; shape [ CAP ] = new Shape3D ( gbuf . getGeom ( flags ) ) ; numVerts += gbuf . getNumVerts ( ) ; numTris += gbuf . getNumTris ( ) ; if ( ( primflags & Primitive . GEOMETRY_NOT_SHARED ) == 0 ) { cacheGeometry ( Primitive . BOTTOM_DISK , radius , radius , - height / 2.0f , xdivision , xdivision , primflags , gbuf ) ; } } if ( ( flags & ENABLE_APPEARANCE_MODIFY ) != 0 ) { ( shape [ CAP ] ) . setCapability ( Shape3D . ALLOW_APPEARANCE_READ ) ; ( shape [ CAP ] ) . setCapability ( Shape3D . ALLOW_APPEARANCE_WRITE ) ; } if ( ( flags & ENABLE_GEOMETRY_PICKING ) != 0 ) { ( shape [ CAP ] ) . setCapability ( Shape3D . ALLOW_GEOMETRY_READ ) ; } this . addChild ( shape [ CAP ] ) ; if ( ap == null ) { setAppearance ( ) ; } else setAppearance ( ap ) ; }
tr	OLB	||	public String execute ( ) throws Exception { if ( categoryName == null || categoryName . isEmpty ( ) ) return "inputError" ; if ( ! alter ( ) ) return "inputError" ; return SUCCESS ; }
tr	KMD	public	@ Field ( 5 ) public Pointer < AVCodecParser . split_callback > split ( ) { return this . io . getPointerField ( this , 5 ) ; }
tr	KFC	if	@ Override public boolean accept ( File file ) { if ( file . isDirectory ( ) ) { return true ; } else { String path = file . getAbsolutePath ( ) . toLowerCase ( ) ; for ( int i = 0 , n = extensions . length ; i < n ; i ++ ) { String extension = extensions [ i ] ; if ( ( path . endsWith ( extension ) && ( path . charAt ( path . length ( ) - extension . length ( ) - 1 ) ) == . ) ) { return true ; } } } return false ; }
tr	OUT	++	public boolean hasRowDuplicates ( String [ ] lines ) { boolean [ ] found ; int max = 0 ; for ( String line : lines ) { int lineNumber = Integer . parseInt ( line . split ( ":" ) [ 0 ] ) ; max = lineNumber > max ? lineNumber : max ; } found = new boolean [ max ] ; for ( int i = 0 ; i < max ; i ++ ) { found [ i ] = false ; } for ( String line : lines ) { int lineNumber = Integer . parseInt ( line . split ( ":" ) [ 0 ] ) - 1 ; if ( found [ lineNumber ] ) return true ; found [ lineNumber ] = true ; } return false ; }
tr	ORE	<	public void preHandle ( ) { for ( int i = 0 ; i < operands . length ; i ++ ) { if ( operands [ i ] != null ) operands [ i ] . preHandle ( ) ; } }
tr	ORE	>=	@ Override public void superSample ( int [ ] input , int [ ] output ) { final int st = this . stride ; final int dw = this . width * this . factor ; final int dw2 = dw + dw ; final int dh = this . height * this . factor ; final int sh = this . height ; final int sw = this . width ; int iOffs = st * ( sh - 1 ) + this . offset ; int oOffs = dw * ( dh - this . factor ) ; if ( this . factor == 2 ) { for ( int i = sw - 1 ; i >= 0 ; i -- ) { final int valA = input [ iOffs + i ] ; final int valB = ( i == sw - 1 ) ? valA : input [ iOffs + i + 1 ] ; final int valAB = ( valA + valB ) >> 1 ; int k = oOffs + ( i << 1 ) ; output [ k ] = valA ; output [ k + 1 ] = valAB ; k += dw ; output [ k ] = valA ; output [ k + 1 ] = valAB ; } iOffs -= st ; oOffs -= dw2 ; for ( int j = sh - 2 ; j >= 0 ; j -- ) { int valB = input [ iOffs + sw - 1 ] ; int valD = input [ iOffs + st + sw - 1 ] ; int k = oOffs + dw ; output [ k - 2 ] = valB ; output [ k - 1 ] = valB ; k += dw ; output [ k - 2 ] = ( valB + valD ) >> 1 ; output [ k - 1 ] = ( valB + valD ) >> 1 ; for ( int i = sw - 2 ; i >= 0 ; i -- ) { k = oOffs + ( i << 1 ) ; final int valA = input [ iOffs + i ] ; final int valC = input [ iOffs + st + i ] ; output [ k ] = valA ; output [ k + 1 ] = ( valA + valB ) >> 1 ; k += dw ; output [ k ] = ( valA + valC ) >> 1 ; output [ k + 1 ] = ( valA + valB + valC + valD + 2 ) >> 2 ; valB = valA ; valD = valC ; } iOffs -= st ; oOffs -= dw2 ; } } else { final int dw4 = dw2 + dw2 ; for ( int i = sw - 1 ; i >= 0 ; i -- ) { final int valA = input [ iOffs + i ] ; final int valB = ( i == sw - 1 ) ? valA : input [ iOffs + i + 1 ] ; final int val3AB = ( valA + valA + valA + valB + 2 ) >> 2 ; final int valA3B = ( valA + valB + valB + valB + 2 ) >> 2 ; int k = oOffs + ( i << 2 ) ; output [ k ] = valA ; output [ k + 1 ] = val3AB ; output [ k + 2 ] = valA3B ; output [ k + 3 ] = valB ; k += dw ; output [ k ] = valA ; output [ k + 1 ] = val3AB ; output [ k + 2 ] = valA3B ; output [ k + 3 ] = valB ; k += dw ; output [ k ] = valA ; output [ k + 1 ] = val3AB ; output [ k + 2 ] = valA3B ; output [ k + 3 ] = valB ; k += dw ; output [ k ] = valA ; output [ k + 1 ] = val3AB ; output [ k + 2 ] = valA3B ; output [ k + 3 ] = valB ; } iOffs -= st ; oOffs -= dw4 ; for ( int j = sh - 2 ; j >= 0 ; j -- ) { int valB = input [ iOffs + sw - 1 ] ; int valD = input [ iOffs + st + sw - 1 ] ; int val3B = ( valB << 1 ) + valB ; int val3D = ( valD << 1 ) + valD ; int k = oOffs + dw ; output [ k - 4 ] = valB ; output [ k - 3 ] = valB ; output [ k - 2 ] = valB ; output [ k - 1 ] = valB ; k += dw ; output [ k - 4 ] = ( val3B + valD + 2 ) >> 2 ; output [ k - 3 ] = ( val3B + valD + 2 ) >> 2 ; output [ k - 2 ] = ( val3B + valD + 2 ) >> 2 ; output [ k - 1 ] = ( val3B + valD + 2 ) >> 2 ; k += dw ; output [ k - 4 ] = ( valB + val3D + 2 ) >> 2 ; output [ k - 3 ] = ( valB + val3D + 2 ) >> 2 ; output [ k - 2 ] = ( valB + val3D + 2 ) >> 2 ; output [ k - 1 ] = ( valB + val3D + 2 ) >> 2 ; k += dw ; output [ k - 4 ] = valD ; output [ k - 3 ] = valD ; output [ k - 2 ] = valD ; output [ k - 1 ] = valD ; for ( int i = sw - 2 ; i >= 0 ; i -- ) { k = oOffs + ( i << 2 ) ; final int valA = input [ iOffs + i ] ; final int valC = input [ iOffs + st + i ] ; final int val3A = ( valA << 1 ) + valA ; final int val3C = ( valC << 1 ) + valC ; output [ k ] = valA ; output [ k + 1 ] = ( val3A + valB + 2 ) >> 2 ; output [ k + 2 ] = ( valA + valB ) >> 1 ; output [ k + 3 ] = ( valA + val3B + 2 ) >> 2 ; k += dw ; output [ k ] = ( val3A + valC + 2 ) >> 2 ; output [ k + 1 ] = ( val3A + valB + valB + valC + valC + valD + 4 ) >> 3 ; output [ k + 2 ] = ( val3A + val3B + valC + valD + 4 ) >> 3 ; output [ k + 3 ] = ( valA + valA + val3B + valC + valD + valD + 4 ) >> 3 ; k += dw ; output [ k ] = ( valA + valC ) >> 1 ; output [ k + 1 ] = ( val3A + valB + val3C + valD + 4 ) >> 3 ; output [ k + 2 ] = ( valA + valB + valC + valD + 2 ) >> 2 ; output [ k + 3 ] = ( valA + val3B + valC + val3D + 4 ) >> 3 ; k += dw ; output [ k ] = ( valA + val3C + 2 ) >> 2 ; output [ k + 1 ] = ( valA + valA + valB + val3C + valD + valD + 4 ) >> 3 ; output [ k + 2 ] = ( valA + valB + val3C + val3D + 4 ) >> 3 ; output [ k + 3 ] = ( valA + valB + valB + valC + valC + val3D + 4 ) >> 3 ; valB = valA ; valD = valC ; val3B = val3A ; val3D = val3C ; } iOffs -= st ; oOffs -= dw4 ; } } }
tr	SYM	)	public ExemploPessoaFisica ( String nome , int rg , int cpf ) { super ( nome , rg ) ; this . cpf = cpf ; }
tr	SYM	;	public void setTable ( JTable2 table ) { this . table = table ; }
tr	OLB	||	@ Override public boolean accept ( File f ) { return f . isDirectory ( ) || f . getName ( ) . toLowerCase ( ) . endsWith ( ".lcd" ) ; }
tr	SYM	(	private void offlinePlayerDisposer ( ) { final int timeToClean = 30 ; plugin . getServer ( ) . getScheduler ( ) . runTaskTimerAsynchronously ( plugin , new Runnable ( ) { @ Override public void run ( ) { synchronized ( offlineInstances ) { Iterator < OfflineUPlayer > it = offlineInstances . values ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { OfflineUPlayer op = it . next ( ) ; if ( op . recommendedDestruction ( timeToClean ) ) { op . unload ( ) ; it . remove ( ) ; } } } } } , 0 , timeToClean * 20 ) ; }
tr	OUT	++	public boolean adicionCliente ( ) throws TipoInvalidoException { if ( contador < prestamos . length ) { String n = lea . next ( ) ; String tel = lea . next ( ) ; String tipo = lea . next ( ) ; prestamos [ contador ] = new ClientePrestamo ( n , tel ) ; prestamos [ contador ] . setPrestamo ( TipoPrestamo . valueOf ( tipo ) ) ; contador ++ ; return true ; } else { System . out . println ( "ya no espacio" ) ; } return false ; }
tr	ORE	<	public static ReflectionMatcher < FluentMember > hasNameContaining ( final CharSequence substring ) { return new MatcherHasNameContaining ( substring ) ; }
tr	OAS	&=	public void and ( FixedBitSet leaves ) { for ( int i = 0 ; i < bits . length ; i ++ ) { bits [ i ] &= leaves . bits [ i ] ; } }
tr	ORE	<	public List < Party > getParty ( ) { if ( party == null ) { party = new ArrayList < Party > ( ) ; } return this . party ; }
tr	KEH	try	public static void ReadFromFile ( String args [ ] ) { String str = null ; System . err . println ( "Read From File: " + args [ 1 ] + "started." ) ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( args [ 1 ] ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } try { str = br . readLine ( ) ; } catch ( IOException e ) { System . out . println ( "Input error:" + e . getMessage ( ) ) ; } System . err . println ( "Read From File: " + args [ 1 ] + "ended." ) ; }
tr	OUT	++	public Map < long , List < RunePage >> getSummonersRunePages ( Region region , Summoner ... summoners ) throws RiotApiException { long [ ] ids = new long [ summoners . length ] ; for ( int n = 0 ; n < summoners . length ; n ++ ) ids [ n ] = summoners [ n ] . getId ( ) ; return getSummonersRunePages ( region , ids ) ; }
tr	KPT	int	public < TModelo > Comparador < ListaSimple < TDato > , TModelo > porNumeroDeElementos ( final Selector < TDato , TModelo > selectorDeDatos ) { return new Comparador < ListaSimple < TDato > , TModelo > ( ) { @ Override public int comparacion ( ListaSimple < TDato > a , TModelo b ) { int elementosEnA = OpsLectores . contar ( a . getRecorredor ( ) , selectorDeDatos ) ; int elementosEnB = OpsLectores . contar ( a . getRecorredor ( ) , selectorDeDatos ) ; return elementosEnA - elementosEnB ; } } ; }
tr	SYM	;	public int getIdDevoir ( ) { return idDevoir ; }
tr	OAS	&=	static private int jjMoveStringLiteralDfa12_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 10 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 11 , active0 ) ; return 12 ; } switch ( curChar ) { case 115 : if ( ( active0 & 8 ) != 0 ) return jjStartNfaWithStates_0 ( 12 , 3 , 6 ) ; break ; default : break ; } return jjStartNfa_0 ( 11 , active0 ) ; }
tr	KEH	try	@ Override public boolean flatTrim ( ) { stateLock . readLock ( ) . lock ( ) ; try { if ( state == E_DroneState . DISCONNECTING || state == E_DroneState . OFFLINE ) { Util . printWarn ( "Cannot set trim while in state " + state ) ; return false ; } return connection . sendFlatTrimCommand ( ) ; } finally { stateLock . readLock ( ) . unlock ( ) ; } }
tr	OAR	-	public int getNumCols ( ) { return - 1 ; }
tr	SYM	(	public DeveloperTabs ( DocumentView documentView ) { this . addTab ( "Home" , new DevHomePanel ( documentView ) ) ; }
tr	KPT	double	public static void setDefaultBaseline ( double defaultBaseline ) { Optimizer . defaultBaseline = defaultBaseline ; }
tr	KMD	public	@ Override public boolean contains ( int x , int y ) { return ( x >= getX ( ) && x <= getX ( ) + getWidth ( ) ) && ( y >= getY ( ) && y < getY ( ) + getHeight ( ) ) ; }
tr	OAR	-	public int method438 ( ) { currentOffset += 2 ; int j = ( ( buffer [ currentOffset - 1 ] & ff ) << 8 ) + ( buffer [ currentOffset - 2 ] - 128 & ff ) ; if ( j > 32767 ) j -= 10000 ; return j ; }
tr	KMD	protected	protected void handleLONGESTROAD ( LongestRoad mes ) { Game ga = ( Game ) games . get ( mes . getGame ( ) ) ; if ( ga != null ) { if ( mes . getPlayerNumber ( ) == - 1 ) { ga . setPlayerWithLongestRoad ( ( Player ) null ) ; } else { ga . setPlayerWithLongestRoad ( ga . getPlayer ( mes . getPlayerNumber ( ) ) ) ; } } }
tr	KFC	return	public static int thisTransitiveContents ( ) { return 1 ; }
tr	KMD	public	public static int [ ] atoi ( String cad ) { String read [ ] = cad . split ( " " ) ; int res [ ] = new int [ read . length ] ; for ( int i = 0 ; i < read . length ; i ++ ) { res [ i ] = Integer . parseInt ( read [ i ] ) ; } return res ; }
tr	SYM	(	public Builder newBuilderForType ( ) { return newBuilder ( ) ; }
tr	OLB	&&	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; XMLTokener x = new XMLTokener ( string ) ; while ( x . more ( ) && x . skipPast ( "<" ) ) { parse ( x , jo , null ) ; } return jo ; }
tr	KMD	public	public void addHeader ( String name , String value ) { header . put ( name , value ) ; }
tr	KFC	return	public String getName ( ) { return SeleniumHTMLRunnerResultsHandler . class . getName ( ) ; }
tr	KEH	try	private void logIntoFile ( String zprva ) { if ( writer == null ) { throw new RuntimeException ( "\nNen\u00ED otev\u0159en v\u00FDstupn\u00ED proud" ) ; } try { writer . write ( zprva ) ; writer . flush ( ) ; } catch ( IOException ex ) { message ( "P\u0159i z\u00E1pisu \u017Eurn\u00E1lu do souboru se vyskytly probl\u00E9my" ) ; } }
tr	SYM	)	public static String LoadPurse ( String SERVER_ID , String ASSET_TYPE_ID , String USER_ID ) { return otapiJNI . OTAPI_Basic_LoadPurse ( SERVER_ID , ASSET_TYPE_ID , USER_ID ) ; }
tr	KEH	try	public boolean agregarDato ( String cadena , boolean rw ) { boolean result = false ; FileWriter fichero = null ; PrintWriter pw ; try { fichero = new FileWriter ( "Mediciones.txt" , rw ) ; pw = new PrintWriter ( fichero ) ; pw . println ( cadena ) ; } catch ( IOException e ) { System . out . println ( e + ": Error registrando Usuario" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; result = true ; } } catch ( IOException e2 ) { System . out . println ( e2 + ": Error tratando de cerrar Archivo Usuarios.txt" ) ; } } return result ; }
tr	KMD	final	private static byte [ ] extractPropertyElements ( final byte [ ] apdu , final int elements ) throws KNXRemoteException { final int number = ( apdu [ 4 ] & FF ) >>> 4 ; if ( number == 0 ) throw new KNXRemoteException ( "property access failed/forbidden" ) ; if ( number != elements ) throw new KNXInvalidResponseException ( "number of elements differ" ) ; final byte [ ] prop = new byte [ apdu . length - 6 ] ; for ( int i = 0 ; i < prop . length ; ++ i ) prop [ i ] = apdu [ i + 6 ] ; return prop ; }
tr	OUT	++	public static void computeNormalisingConstant ( ) throws InternalErrorException , OperationNotSupportedException , InconsistentLinearSystemException , BTFMatrixErrorException { current_N = new PopulationVector ( 0 , R ) ; for ( int current_class = 1 ; current_class <= R ; current_class ++ ) { System . out . println ( "Working on class " + current_class ) ; System . out . println ( "Current Population: " + current_N ) ; current_N . plusOne ( current_class ) ; system . initialiseForClass ( current_N , current_class ) ; solveForClass ( current_class ) ; } }
tr	OUT	++	public static void execute ( ExecutorService exec ) { int num = 5 ; for ( int i = 0 ; i < num ; ++ i ) { exec . execute ( new ThreadA ( ) ) ; } exec . shutdown ( ) ; }
tr	OLB	&&	public boolean createPortal ( World par1World , Entity par2Entity ) { byte byte0 = 16 ; double d = - 1D ; int i = MathHelper . floor_double ( par2Entity . posX ) ; int j = MathHelper . floor_double ( par2Entity . posY ) ; int k = MathHelper . floor_double ( par2Entity . posZ ) ; int l = i ; int i1 = j ; int j1 = k ; int k1 = 0 ; int l1 = random . nextInt ( 4 ) ; for ( int i2 = i - byte0 ; i2 <= i + byte0 ; i2 ++ ) { double d1 = ( ( double ) i2 + 0.5D ) - par2Entity . posX ; for ( int j3 = k - byte0 ; j3 <= k + byte0 ; j3 ++ ) { double d3 = ( ( double ) j3 + 0.5D ) - par2Entity . posZ ; for ( int k4 = par1World . func_72940_L ( ) - 1 ; k4 >= 0 ; k4 -- ) { if ( ! par1World . isAirBlock ( i2 , k4 , j3 ) ) { continue ; } for ( ; k4 > 0 && par1World . isAirBlock ( i2 , k4 - 1 , j3 ) ; k4 -- ) { } label0 : for ( int k5 = l1 ; k5 < l1 + 4 ; k5 ++ ) { int l6 = k5 % 2 ; int i8 = 1 - l6 ; if ( k5 % 4 >= 2 ) { l6 = - l6 ; i8 = - i8 ; } for ( int j9 = 0 ; j9 < 3 ; j9 ++ ) { for ( int k10 = 0 ; k10 < 4 ; k10 ++ ) { for ( int l11 = - 1 ; l11 < 4 ; l11 ++ ) { int j12 = i2 + ( k10 - 1 ) * l6 + j9 * i8 ; int l12 = k4 + l11 ; int j13 = ( j3 + ( k10 - 1 ) * i8 ) - j9 * l6 ; if ( l11 < 0 && ! par1World . getBlockMaterial ( j12 , l12 , j13 ) . isSolid ( ) || l11 >= 0 && ! par1World . isAirBlock ( j12 , l12 , j13 ) ) { break label0 ; } } } } double d5 = ( ( double ) k4 + 0.5D ) - par2Entity . posY ; double d7 = d1 * d1 + d5 * d5 + d3 * d3 ; if ( d < 0.0D || d7 < d ) { d = d7 ; l = i2 ; i1 = k4 ; j1 = j3 ; k1 = k5 % 4 ; } } } } } if ( d < 0.0D ) { for ( int j2 = i - byte0 ; j2 <= i + byte0 ; j2 ++ ) { double d2 = ( ( double ) j2 + 0.5D ) - par2Entity . posX ; for ( int k3 = k - byte0 ; k3 <= k + byte0 ; k3 ++ ) { double d4 = ( ( double ) k3 + 0.5D ) - par2Entity . posZ ; for ( int l4 = par1World . func_72940_L ( ) - 1 ; l4 >= 0 ; l4 -- ) { if ( ! par1World . isAirBlock ( j2 , l4 , k3 ) ) { continue ; } for ( ; l4 > 0 && par1World . isAirBlock ( j2 , l4 - 1 , k3 ) ; l4 -- ) { } label1 : for ( int l5 = l1 ; l5 < l1 + 2 ; l5 ++ ) { int i7 = l5 % 2 ; int j8 = 1 - i7 ; for ( int k9 = 0 ; k9 < 4 ; k9 ++ ) { for ( int l10 = - 1 ; l10 < 4 ; l10 ++ ) { int i12 = j2 + ( k9 - 1 ) * i7 ; int k12 = l4 + l10 ; int i13 = k3 + ( k9 - 1 ) * j8 ; if ( l10 < 0 && ! par1World . getBlockMaterial ( i12 , k12 , i13 ) . isSolid ( ) || l10 >= 0 && ! par1World . isAirBlock ( i12 , k12 , i13 ) ) { break label1 ; } } } double d6 = ( ( double ) l4 + 0.5D ) - par2Entity . posY ; double d8 = d2 * d2 + d6 * d6 + d4 * d4 ; if ( d < 0.0D || d8 < d ) { d = d8 ; l = j2 ; i1 = l4 ; j1 = k3 ; k1 = l5 % 2 ; } } } } } } int k2 = k1 ; int l2 = l ; int i3 = i1 ; int l3 = j1 ; int i4 = k2 % 2 ; int j4 = 1 - i4 ; if ( k2 % 4 >= 2 ) { i4 = - i4 ; j4 = - j4 ; } if ( d < 0.0D ) { if ( i1 < 70 ) { i1 = 70 ; } if ( i1 > par1World . func_72940_L ( ) - 10 ) { i1 = par1World . func_72940_L ( ) - 10 ; } i3 = i1 ; for ( int i5 = - 1 ; i5 <= 1 ; i5 ++ ) { for ( int i6 = 1 ; i6 < 3 ; i6 ++ ) { for ( int j7 = - 1 ; j7 < 3 ; j7 ++ ) { int k8 = l2 + ( i6 - 1 ) * i4 + i5 * j4 ; int l9 = i3 + j7 ; int i11 = ( l3 + ( i6 - 1 ) * j4 ) - i5 * i4 ; boolean flag = j7 < 0 ; par1World . setBlockWithNotify ( k8 , l9 , i11 , flag ? Block . obsidian . blockID : 0 ) ; } } } } for ( int j5 = 0 ; j5 < 4 ; j5 ++ ) { par1World . editingBlocks = true ; for ( int j6 = 0 ; j6 < 4 ; j6 ++ ) { for ( int k7 = - 1 ; k7 < 4 ; k7 ++ ) { int l8 = l2 + ( j6 - 1 ) * i4 ; int i10 = i3 + k7 ; int j11 = l3 + ( j6 - 1 ) * j4 ; boolean flag1 = j6 == 0 || j6 == 3 || k7 == - 1 || k7 == 3 ; par1World . setBlockWithNotify ( l8 , i10 , j11 , flag1 ? Block . obsidian . blockID : Block . portal . blockID ) ; } } par1World . editingBlocks = false ; for ( int k6 = 0 ; k6 < 4 ; k6 ++ ) { for ( int l7 = - 1 ; l7 < 4 ; l7 ++ ) { int i9 = l2 + ( k6 - 1 ) * i4 ; int j10 = i3 + l7 ; int k11 = l3 + ( k6 - 1 ) * j4 ; par1World . notifyBlocksOfNeighborChange ( i9 , j10 , k11 , par1World . getBlockId ( i9 , j10 , k11 ) ) ; } } } return true ; }
tr	KFC	return	public RoomType getRoomType ( ) { return roomType ; }
tr	ORE	<	public void testGetNull ( ) { Map < K , V > map = makeEitherMap ( ) ; if ( allowsNullKeys ) { if ( allowsNullValues ) { } else { assertEquals ( map . containsKey ( null ) , map . get ( null ) != null ) ; } } else { try { map . get ( null ) ; } catch ( NullPointerException optional ) { } } assertInvariants ( map ) ; }
tr	OAS	>>=	public float [ ] [ ] inverseTransROI ( float [ ] [ ] data , int maxLevel , int minLevel , int rows , int cols , Rectangle sourceRegion ) { float [ ] data1D = new float [ ( rows > cols ? rows : cols ) >> ( minLevel - 1 ) ] ; int oneHalf ; int negSupport = 4 ; int posSupport = 4 ; int roiLevel = 1 ; int [ ] maskLeftX = new int [ roiLevel + 1 ] ; maskLeftX [ 0 ] = sourceRegion . x ; for ( int i = 1 ; i <= roiLevel ; i ++ ) { maskLeftX [ i ] = ( maskLeftX [ i - 1 ] >> 1 ) - negSupport ; if ( maskLeftX [ i ] < 0 ) maskLeftX [ i ] = 0 ; } int [ ] maskRightX = new int [ roiLevel + 1 ] ; maskRightX [ 0 ] = sourceRegion . x + sourceRegion . width ; for ( int i = 1 ; i <= roiLevel ; i ++ ) { maskRightX [ i ] = ( maskRightX [ i - 1 ] >> 1 ) + posSupport ; if ( maskRightX [ 1 ] > ( cols >> i ) ) maskRightX [ 1 ] = ( cols >> i ) ; } int [ ] maskTopY = new int [ roiLevel + 1 ] ; for ( int i = 1 ; i <= roiLevel ; i ++ ) { maskTopY [ i ] = sourceRegion . y >> ( i - 1 ) ; } int [ ] maskBottomY = new int [ roiLevel + 1 ] ; for ( int i = 1 ; i <= roiLevel ; i ++ ) { maskBottomY [ i ] = ( sourceRegion . y + sourceRegion . height ) >> ( i - 1 ) ; } rows >>= maxLevel - 1 ; cols >>= maxLevel - 1 ; for ( int currentLevel = maxLevel ; currentLevel >= minLevel ; rows <<= 1 , cols <<= 1 , currentLevel -- ) { if ( currentLevel > roiLevel ) { for ( int j = 0 ; j < cols ; j ++ ) { inverseTransOneColumn ( data , rows , data1D , j ) ; } for ( int i = 0 ; i < rows ; i ++ ) { inverseTransOneRow ( data , cols , data1D , i ) ; } } else { for ( int j = maskLeftX [ currentLevel ] ; j < maskRightX [ currentLevel ] ; j ++ ) { inverseTransOneColumn ( data , rows , data1D , j ) ; } int startCol = maskLeftX [ currentLevel ] + ( cols >> 1 ) ; int endCol = maskRightX [ currentLevel ] + ( cols >> 1 ) ; for ( int j = startCol ; j < endCol ; j ++ ) { inverseTransOneColumn ( data , rows , data1D , j ) ; } for ( int i = maskTopY [ currentLevel ] ; i < maskBottomY [ currentLevel ] ; i ++ ) { inverseTransOneRow ( data , cols , data1D , i ) ; } } } return data ; }
tr	ORE	<	@ Override public Attribute < boolean > getInstance ( ) { return new MultipleBitExchanged ( value , equality , scale ) ; }
tr	KEH	assert	@ Test public void testMinimumAfterAdd1OutOfFirstWindow ( ) { final IFixedTimeWindow ts = this . create ( ) ; ts . add ( 1 , 1.0f ) ; ts . add ( 1002 , 2.0f ) ; assert . assertEquals ( 1002 , ts . get ( 1002 ) . minimum ( ) . time ( ) , AFixedTimeWindowTest . PRECISION ) ; assert . assertEquals ( 2.0f , ts . get ( 1002 ) . minimum ( ) . value ( ) , AFixedTimeWindowTest . PRECISION ) ; }
tr	ORE	<=	public static String htmlEntityEncode ( String s ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) ) { buf . append ( c ) ; } else { buf . append ( "&#" + ( int ) c + ";" ) ; } } return buf . toString ( ) ; }
tr	KMD	public	public NIOTCPChangeRequest ( SocketChannel socketChannel ) { this . socketChannel = socketChannel ; }
tr	OAR	-	public void setSpeedAndAuthority ( int trainID , double speed , double auth ) { speedSignals . put ( trainID , speed ) ; if ( auth != - 1 ) { authoritySignals . put ( trainID , auth ) ; } }
tr	ORE	>=	public void setStdDevPrec ( int prec ) { if ( prec >= 0 ) m_StdDevPrec = prec ; }
tr	OLB	||	private static boolean isPrime ( int i ) { if ( i == 1 ) { return false ; } if ( i == 2 || i == 3 || i == 5 || i == 7 ) { return true ; } for ( int k = 2 ; k < i ; k ++ ) { if ( i % k == 0 ) { return false ; } } return true ; }
tr	OAR	-	public static byte [ ] removeValues ( AtomicIntegerArray array , byte value ) { int cnt = DagUtils . count ( array , value ) ; byte [ ] reducedArray = new byte [ array . length ( ) - cnt ] ; int index = 0 ; for ( int j = 0 , n = array . length ( ) ; j < n ; ++ j ) { byte element = ( byte ) array . get ( j ) ; if ( element != value ) { reducedArray [ index ++ ] = element ; } } assert index == reducedArray . length ; return reducedArray ; }
tr	OAR	-	@ Test ( expected = StrategyException . class ) public void placeRedPieceOnInvalidColumn ( ) throws StrategyException { redConfiguration . remove ( 1 ) ; addToConfiguration ( MARSHAL , RED , - 1 , 0 ) ; factory . makeBetaStrategyGame ( redConfiguration , blueConfiguration ) ; }
tr	OAR	%	public static int solution ( int N ) { int i = 1 ; int counter = 0 ; while ( i < Math . sqrt ( N ) ) { if ( N % i == 0 ) { counter += 2 ; } i ++ ; } if ( i == Math . sqrt ( N ) ) counter ++ ; return counter ; }
tr	KPT	int	public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; }
tr	KEH	try	public void testGetBySynset ( ) { try { JWNL . initialize ( TestDefaults . getInputStream ( ) ) ; long offset = 4389033 ; Synset syn = Dictionary . getInstance ( ) . getSynsetAt ( POS . NOUN , offset ) ; System . out . println ( "Synset: " + syn . toString ( ) ) ; boolean match = false ; for ( int i = 0 ; i < syn . getWords ( ) . length ; i ++ ) { Word w = syn . getWords ( ) [ i ] ; if ( w . getLemma ( ) . equals ( "tank" ) ) { match = true ; break ; } } if ( ! match ) { fail ( "Term 'tank' not found in test grab." ) ; } } catch ( Exception e ) { fail ( "Exception in Synset 3.0 test caught" ) ; e . printStackTrace ( ) ; } }
tr	OLB	&&	public boolean reachedMaxStage ( ) { return spotInfo . type == ALLOTMENT && stage == 4 ; }
tr	SYM	;	@ Override public boolean isOpen ( ) { return true ; }
tr	KEH	try	public RotateDemo2 ( ) { MinuetoWindow window ; MinuetoImage imageHex ; MinuetoImage imageRotate ; window = new MinuetoFrame ( 640 , 480 , true ) ; try { imageHex = new MinuetoImageFile ( "images/WoodHex.png" ) ; } catch ( MinuetoFileException e ) { System . out . println ( "Could not load tank file" ) ; System . exit ( 0 ) ; return ; } imageRotate = imageHex . rotate ( Math . PI ) ; window . setVisible ( true ) ; while ( true ) { window . clear ( MinuetoColor . BLACK ) ; window . draw ( imageHex , 50 , 50 ) ; window . draw ( imageHex , 50 + 29 , 50 + 51 ) ; window . draw ( imageHex , 200 , 50 ) ; window . draw ( imageRotate , 200 + 29 , 50 + 51 ) ; window . render ( ) ; } }
tr	SYM	)	public int getTeeth ( ) { return teeth ; }
tr	ORE	<	public FadingButtonTF ( GameState gameState ) { super ( ( ( Prop ) gameState . getGameElement ( ) ) . getText ( ) ) ; this . gameState = gameState ; this . prop = ( Prop ) gameState . getGameElement ( ) ; setText ( this . prop . getText ( ) ) ; if ( this . prop . getColor ( ) == null ) setBackground ( new Color ( 255 , 255 , 255 ) ) ; else setBackground ( Util . StringToColor ( this . prop . getColor ( ) . toString ( ) ) ) ; Time time = this . prop . getType ( ) . getEvents ( ) . get ( 0 ) . getTime ( ) ; List < gamePlayEngine . model . gameConstants . Timer > timers = GameModel . getGameModelObject ( ) . getGameConstants ( ) . getTimers ( ) ; int timerValue = 0 ; for ( gamePlayEngine . model . gameConstants . Timer timer : timers ) { System . out . println ( "Timer name is..." + timer . getName ( ) ) ; if ( timer . getName ( ) != null ) { if ( timer . getName ( ) . trim ( ) . equals ( time . name ( ) ) ) { timerValue = Integer . parseInt ( timer . getValue ( ) ) ; System . out . println ( "Timer value is" + timerValue ) ; } } } animator = new Animator ( timerValue , 1 , RepeatBehavior . REVERSE , this ) ; animator . setStartFraction ( 1.0f ) ; animator . setStartDirection ( Direction . BACKWARD ) ; addActionListener ( this ) ; }
tr	KMD	public	public ItemQualityComparator ( boolean bdesc ) { desc = ( bdesc ) ? 1 : - 1 ; }
tr	KPT	int	public int getLineNumber ( ) { return this . lineNumber ; }
tr	OUT	++	public static void main ( String [ ] args ) { int count = 0 ; for ( int i = 2 ; i < 10000000 ; i ++ ) if ( sumsToEigtyNine ( i ) ) count ++ ; System . out . println ( count ) ; }
tr	KMD	public	public int [ ] makeEnds ( int [ ] nums ) { int [ ] a = new int [ 2 ] ; if ( nums . length == 1 ) { a [ 0 ] = a [ 1 ] = nums [ 0 ] ; } if ( nums . length == 2 ) return nums ; a [ 0 ] = nums [ 0 ] ; a [ 1 ] = nums [ nums . length - 1 ] ; return a ; }
tr	KFC	return	public double getAttack ( ) { return this . attack ; }
tr	KPT	int	public final native void waitForAttachment ( int timeout ) throws PhidgetException ;
tr	ORE	<	@ Override public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; Set < State > states = getStates ( ) ; setStateNumbers ( states ) ; b . append ( "initial state: " ) . append ( initial . number ) . append ( "\n" ) ; for ( State s : states ) b . append ( s . toString ( ) ) ; return b . toString ( ) ; }
tr	KPT	int	@ Override public int hashCode ( ) { int result = getType ( ) . hashCode ( ) ; result = 31 * result + getName ( ) . hashCode ( ) ; return result ; }
tr	OUT	++	public void update ( ) { wasWasPressed = wasPressed ; wasPressed = pressed ; if ( pressed ) timePressed ++ ; else timePressed = 0 ; }
tr	KFC	if	@ Override public boolean equals ( final Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( obj instanceof TextFragment ) { final TextFragment tf = ( TextFragment ) obj ; if ( ! this . text . equals ( tf . text ) ) { return false ; } if ( ! this . font . equals ( tf . font ) ) { return false ; } if ( ! this . paint . equals ( tf . paint ) ) { return false ; } return true ; } return false ; }
tr	SYM	;	public ButtonProperties getScrollDownButtonProperties ( ) { return new ButtonProperties ( SCROLL_DOWN_BUTTON_PROPERTIES . get ( getMap ( ) ) ) ; }
tr	ORE	<	public List < TimeSeries > getTimeSeriesList ( Category category , Section section ) throws SeriesNotFoundException { GenericType < List < TimeSeries >> genericType = new GenericType < List < TimeSeries >> ( ) { } ; try { return webResource . path ( category . getUriTag ( ) ) . path ( section . getUriTag ( ) ) . path ( "time-series-list" ) . accept ( defaultMediaType ) . get ( genericType ) ; } catch ( UniformInterfaceException e ) { throw new SeriesNotFoundException ( e ) ; } }
tr	KMD	public	public UserVO ( Map < String , String > fields ) { this . username = ( String ) fields . get ( "username" ) ; this . password = ( String ) fields . get ( "password" ) ; this . rolename = ( String ) fields . get ( "rolename" ) ; this . status = ( String ) fields . get ( "status" ) ; }
tr	OUT	++	int removeDuplicates ( int A [ ] , int n ) { if ( n <= 2 ) return n ; int index = 2 ; for ( int i = 2 ; i < n ; i ++ ) { if ( A [ i ] != A [ index - 2 ] ) A [ index ++ ] = A [ i ] ; } return index ; }
tr	KFC	if	public static boolean isPrime ( int n ) { if ( n < 2 || ( n > 2 && n % 2 == 0 ) || ( n > 3 && n % 6 % 4 != 1 ) ) return false ; for ( int i = 3 ; 1 * i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
tr	KFC	return	@ Override protected Node < T > removeValue ( T value ) { Node < T > nodeToRemoved = this . getNode ( value ) ; if ( nodeToRemoved == null ) return null ; Node < T > replacementNode = this . getReplacementNode ( nodeToRemoved ) ; AVLNode < T > nodeToRefactor = null ; if ( replacementNode != null ) nodeToRefactor = ( AVLNode < T > ) replacementNode . parent ; if ( nodeToRefactor == null ) nodeToRefactor = ( AVLNode < T > ) nodeToRemoved . parent ; if ( nodeToRefactor != null && nodeToRefactor == nodeToRemoved ) nodeToRefactor = ( AVLNode < T > ) replacementNode ; replaceNodeWithNode ( nodeToRemoved , replacementNode ) ; while ( nodeToRefactor != null ) { nodeToRefactor . updateHeight ( ) ; balanceAfterDelete ( nodeToRefactor ) ; nodeToRefactor = ( AVLNode < T > ) nodeToRefactor . parent ; } return nodeToRemoved ; }
tr	OAR	-	public void stateChanged ( ChangeEvent changeEvent ) { double value = 360.0 - ( angularRangeSlider . getValue ( ) / 1000.0 ) ; treeLayout . setAngularRange ( value ) ; }
tr	OAR	-	public Edge [ ] getEdges ( ) { Edge [ ] ret = new Edge [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { ret [ i - 1 ] = new Edge ( v [ 0 ] , v [ i ] ) ; } return ret ; }
tr	SYM	;	HashComment ( ConfigOrigin origin , String text ) { super ( origin , text ) ; }
tr	SYM	;	public void removeCards ( int [ ] cards ) { int [ ] reverseCards = new int [ cards . length ] ; int j = cards . length - 1 ; for ( int i = 0 ; i < cards . length ; i ++ ) { reverseCards [ j ] = cards [ i ] ; j -- ; } for ( int i = 0 ; i < reverseCards . length ; i ++ ) { removeCard ( reverseCards [ i ] ) ; } deckStats . updateStats ( deck ) ; }
tr	ORE	<	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = 0 ; ArrayList < Elephant > elephants = new ArrayList < Elephant > ( ) ; while ( scan . hasNext ( ) ) { n ++ ; int size = scan . nextInt ( ) ; int iq = scan . nextInt ( ) ; elephants . add ( new Elephant ( n , size , iq ) ) ; } Collections . sort ( elephants ) ; ArrayList < Integer > maximum = maximumSequence ( elephants ) ; System . out . println ( maximum . size ( ) ) ; for ( int i = 0 ; i < maximum . size ( ) ; i ++ ) { System . out . println ( maximum . get ( i ) ) ; } }
tr	KFC	if	protected Node parseRest ( boolean first ) { Token t = scanner . getNextToken ( ) ; Node exp = null ; if ( t == null ) { exp = null ; } else if ( t . getType ( ) == TokenType . ) ) { if ( first ) return nil ; else return null ; } else if ( t . getType ( ) == TokenType . . ) { t = scanner . getNextToken ( ) ; if ( t . getType ( ) != TokenType . ) ) { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , null ) ; if ( scanner . getNextToken ( ) . getType ( ) != TokenType . ) ) System . out . println ( "Invalid use of ." ) ; else ( ( Cons ) exp ) . setVararg ( ) ; } else { System . out . println ( "unexpected: ')'" ) ; exp = parseExp ( ) ; } } else { scanner . putTokenBack ( t ) ; exp = new Cons ( parseExp ( ) , parseRest ( false ) ) ; } return exp ; }
tr	ORE	<	public int getRightSample ( int frameNum ) throws SoundException { if ( frameNum >= getAudioFileFormat ( ) . getFrameLength ( ) ) { printError ( "You are trying to access the sample at index: " + ( frameNum ) + "  but the last valid index is at " + ( getAudioFileFormat ( ) . getFrameLength ( ) - 1 ) ) ; } else if ( frameNum < 0 ) { printError ( "You asked for the sample at index: " + ( frameNum + 1 ) + ".  This number is less than zero.  Please try" + " again using an index in the range [0 " + ( getAudioFileFormat ( ) . getFrameLength ( ) - 1 ) + "]." ) ; } AudioFormat format = getAudioFileFormat ( ) . getFormat ( ) ; int channels ; if ( ( channels = format . getChannels ( ) ) == 1 ) { printError ( "Only stereo sounds have different right and left" + " samples.  You are using a mono sound  try " + "getSample(" + ( frameNum ) + ") instead" ) ; return - 1 ; } int sampleSizeInBits = format . getSampleSizeInBits ( ) ; boolean isBigEndian = format . isBigEndian ( ) ; byte [ ] theFrame = getFrame ( frameNum ) ; if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . PCM_SIGNED ) ) { if ( sampleSizeInBits == 8 ) return theFrame [ 1 ] ; else if ( sampleSizeInBits == 16 ) return TConversionTool . bytesToInt16 ( theFrame , 2 , isBigEndian ) ; else if ( sampleSizeInBits == 24 ) return TConversionTool . bytesToInt24 ( theFrame , 3 , isBigEndian ) ; else if ( sampleSizeInBits == 32 ) return TConversionTool . bytesToInt32 ( theFrame , 4 , isBigEndian ) ; else { printError ( "Unsupported audio encoding.  The sample" + " size is not recognized as a standard" + " format." ) ; return - 1 ; } } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . PCM_UNSIGNED ) ) { if ( sampleSizeInBits == 8 ) return TConversionTool . unsignedByteToInt ( theFrame [ 1 ] ) ; else if ( sampleSizeInBits == 16 ) return TConversionTool . unsignedByteToInt16 ( theFrame , 2 , isBigEndian ) ; else if ( sampleSizeInBits == 24 ) return TConversionTool . unsignedByteToInt24 ( theFrame , 3 , isBigEndian ) ; else if ( sampleSizeInBits == 32 ) return TConversionTool . unsignedByteToInt32 ( theFrame , 4 , isBigEndian ) ; else { printError ( "Unsupported audio encoding.  The sample" + " size is not recognized as a standard" + " format." ) ; return - 1 ; } } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . ALAW ) ) { return TConversionTool . alaw2linear ( buffer [ 1 ] ) ; } else if ( format . getEncoding ( ) . equals ( AudioFormat . Encoding . ULAW ) ) { return TConversionTool . ulaw2linear ( buffer [ 1 ] ) ; } else { printError ( "unsupported audio encoding: " + format . getEncoding ( ) + ".  Currently only PCM  " + "ALAW and ULAW are supported.  Please try again" + "with a different file." ) ; return - 1 ; } }
tr	OLB	||	protected static boolean showStackRaw ( ) { return ! getPreference ( "filterstack" ) . equals ( "true" ) || fgFilterStack == false ; }
tr	OUT	++	@ Test public void inputModified ( ) { DenseMatrix64F A = new DenseMatrix64F ( 25 , 20 ) ; for ( int i = 0 ; i < A . data . length ; i ++ ) { A . data [ i ] = i ; } BaseDecomposition_B64_to_D64 alg = new BaseDecomposition_B64_to_D64 ( new DoNotModifyBlock ( ) , 10 ) ; assertFalse ( alg . inputModified ( ) ) ; assertTrue ( alg . decompose ( A ) ) ; for ( int i = 0 ; i < A . data . length ; i ++ ) { assertEquals ( i , A . data [ i ] , 1e-8 ) ; } alg = new BaseDecomposition_B64_to_D64 ( new ModifyBlock ( ) , 10 ) ; assertTrue ( alg . inputModified ( ) ) ; assertTrue ( alg . decompose ( A ) ) ; }
tr	OLB	&&	public String getURI ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 ] ; } else { return null ; } }
tr	OUT	++	private void installBean ( JComponent bean ) { try { componentPanel . removeAll ( ) ; componentPanel . add ( bean ) ; BeanInfo beanInfo = Introspector . getBeanInfo ( bean . getClass ( ) , bean . getClass ( ) . getSuperclass ( ) ) ; PropertyDescriptor [ ] propertyDescriptors = beanInfo . getPropertyDescriptors ( ) ; propertyPanel . removeAll ( ) ; GridBagLayout gridbag = new GridBagLayout ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . fill = GridBagConstraints . BOTH ; propertyPanel . setLayout ( gridbag ) ; int count = 0 ; String [ ] types = new String [ ] { "class java.util.Locale" , "boolean" , "int" , "class java.awt.Color" , "class java.util.Date" , "class java.lang.String" } ; for ( int t = 0 ; t < types . length ; t ++ ) { for ( int i = 0 ; i < propertyDescriptors . length ; i ++ ) { if ( propertyDescriptors [ i ] . getWriteMethod ( ) != null ) { String type = propertyDescriptors [ i ] . getPropertyType ( ) . toString ( ) ; final PropertyDescriptor propertyDescriptor = propertyDescriptors [ i ] ; final JComponent currentBean = bean ; final Method readMethod = propertyDescriptor . getReadMethod ( ) ; final Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( type . equals ( types [ t ] ) && ( ( ( readMethod != null ) && ( writeMethod != null ) ) || ( "class java.util.Locale" . equals ( type ) ) ) ) { if ( "boolean" . equals ( type ) ) { boolean isSelected = false ; try { boolean booleanObj = ( ( boolean ) readMethod . invoke ( bean , ( Object [ ] ) null ) ) ; isSelected = booleanObj . booleanValue ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } final JCheckBox checkBox = new JCheckBox ( "" , isSelected ) ; checkBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { try { if ( checkBox . isSelected ( ) ) { writeMethod . invoke ( currentBean , new Object [ ] { new boolean ( true ) } ) ; } else { writeMethod . invoke ( currentBean , new Object [ ] { new boolean ( false ) } ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; addProperty ( propertyDescriptors [ i ] , checkBox , gridbag ) ; count += 1 ; } else if ( "int" . equals ( type ) ) { JSpinField spinField = new JSpinField ( ) ; spinField . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { try { if ( evt . getPropertyName ( ) . equals ( "value" ) ) { writeMethod . invoke ( currentBean , new Object [ ] { evt . getNewValue ( ) } ) ; } } catch ( Exception e ) { } } } ) ; try { Integer integerObj = ( ( Integer ) readMethod . invoke ( bean , ( Object [ ] ) null ) ) ; spinField . setValue ( integerObj . intValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } addProperty ( propertyDescriptors [ i ] , spinField , gridbag ) ; count += 1 ; } else if ( "class java.lang.String" . equals ( type ) ) { String string = "" ; try { string = ( ( String ) readMethod . invoke ( bean , ( Object [ ] ) null ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } JTextField textField = new JTextField ( string ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { try { writeMethod . invoke ( currentBean , new Object [ ] { e . getActionCommand ( ) } ) ; } catch ( Exception ex ) { } } } ; textField . addActionListener ( actionListener ) ; addProperty ( propertyDescriptors [ i ] , textField , gridbag ) ; count += 1 ; } else if ( "class java.util.Locale" . equals ( type ) ) { JLocaleChooser localeChooser = new JLocaleChooser ( bean ) ; localeChooser . setPreferredSize ( new Dimension ( 200 , localeChooser . getPreferredSize ( ) . height ) ) ; addProperty ( propertyDescriptors [ i ] , localeChooser , gridbag ) ; count += 1 ; } else if ( "class java.util.Date" . equals ( type ) ) { Date date = null ; try { date = ( ( Date ) readMethod . invoke ( bean , ( Object [ ] ) null ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } JDateChooser dateChooser = new JDateChooser ( date ) ; dateChooser . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { try { if ( evt . getPropertyName ( ) . equals ( "date" ) ) { writeMethod . invoke ( currentBean , new Object [ ] { evt . getNewValue ( ) } ) ; } } catch ( Exception e ) { } } } ) ; addProperty ( propertyDescriptors [ i ] , dateChooser , gridbag ) ; count += 1 ; } else if ( "class java.awt.Color" . equals ( type ) ) { final JButton button = new JButton ( ) ; try { final Color colorObj = ( ( Color ) readMethod . invoke ( bean , ( Object [ ] ) null ) ) ; button . setText ( "..." ) ; button . setBackground ( colorObj ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Color newColor = JColorChooser . showDialog ( JCalendarDemo . this , "Choose Color" , colorObj ) ; button . setBackground ( newColor ) ; try { writeMethod . invoke ( currentBean , new Object [ ] { newColor } ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } } } ; button . addActionListener ( actionListener ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } addProperty ( propertyDescriptors [ i ] , button , gridbag ) ; count += 1 ; } } } } } URL iconURL = bean . getClass ( ) . getResource ( "images/" + bean . getName ( ) + "Color16.gif" ) ; ImageIcon icon = new ImageIcon ( iconURL ) ; componentTitlePanel . setTitle ( bean . getName ( ) , icon ) ; bean . invalidate ( ) ; propertyPanel . invalidate ( ) ; componentPanel . invalidate ( ) ; componentPanel . repaint ( ) ; } catch ( IntrospectionException e ) { e . printStackTrace ( ) ; } }
tr	KPT	int	public void actionPerformed ( java . awt . event . ActionEvent evt ) { center ( comp ) ; if ( dim . getWidth ( ) < WIDTH || dim . getHeight ( ) < HEIGHT ) { dim = new Dimension ( WIDTH - w , HEIGHT - h ) ; if ( dim . getWidth ( ) < WIDTH ) { w = ( int ) ( w / 1.25 ) ; } else { h = ( int ) ( h / 1.25 ) ; } comp . setSize ( dim ) ; comp . repaint ( ) ; } else { stopSliding ( ) ; comp . setMinimumSize ( new Dimension ( min . width < WIDTH ? min . width : WIDTH , min . height < HEIGHT ? min . height : HEIGHT ) ) ; } }
tr	KFC	if	@ Override public void setDirected ( boolean directed ) { if ( directed = false ) throw new IllegalArgumentException ( "Fsm are always directed!" ) ; }
tr	ORE	<	JeTTCommand ( String regex , class < ? extends IEvent > metaClass ) { this ( regex , metaClass , true ) ; }
tr	OAS	*=	public void uponGameEnd ( boolean won , int score , User rival ) { int modifier = 0 ; if ( won ) { modifier = rival . getRankValue ( ) / rankValue ; gamesWon ++ ; rankValue = rankValue + ( score * modifier ) ; } else { modifier = rankValue / rival . getRankValue ( ) ; modifier *= - 1 ; gamesLost ++ ; rankValue = rankValue + ( ( 1 / score ) * modifier ) ; } if ( rankValue < 1 ) { rankValue = 1 ; } }
tr	KPT	double	public void serialize ( float f ) throws IOException { serialize ( ( double ) f ) ; }
tr	KMD	public	@ JsonProperty ( "institution" ) public String getInstitution ( ) { return institution ; }
tr	OLB	&&	public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( c == 0 ) { throw syntaxError ( "Unclosed CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ] && sb . charAt ( i + 1 ) == ] && sb . charAt ( i + 2 ) == > ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
tr	OLB	||	public void activateCode ( ) { try { xmlFile = app . getFile ( ) ; Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "kindDef" ) ) ; List < Element > markedToBeRemoved = new ArrayList < Element > ( ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . getValue ( ) . equalsIgnoreCase ( "Pirate" ) || e . getValue ( ) . contains ( "Tribal" ) ) { if ( e . getParentElement ( ) . getName ( ) . equalsIgnoreCase ( "thing" ) ) { markedToBeRemoved . add ( e . getParentElement ( ) ) ; } } } for ( int i = 0 ; i < markedToBeRemoved . size ( ) ; i ++ ) { Element e = markedToBeRemoved . get ( i ) ; e . getParentElement ( ) . removeContent ( e ) ; } Notification . createInfoNotification ( "Raider(s) Removed: " + markedToBeRemoved . size ( ) , 3000 ) ; XMLOutputter xmlOutput = new XMLOutputter ( ) ; FileOutputStream fos = new FileOutputStream ( xmlFile ) ; xmlOutput . setFormat ( Format . getRawFormat ( ) ) ; xmlOutput . output ( doc , fos ) ; fos . close ( ) ; app . setFile ( xmlFile ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
tr	KEH	try	public void connectDb ( ) { startSQL ( ) ; try { class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; con = DriverManager . getConnection ( url , user , password ) ; st = con . createStatement ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	ORE	<	public static long add_a_b ( DenseMatrix64F matA , DenseMatrix64F matB , int numTrials ) { long prev = System . currentTimeMillis ( ) ; DenseMatrix64F results = new DenseMatrix64F ( matA . numRows , matA . numCols ) ; for ( int i = 0 ; i < numTrials ; i ++ ) { CommonOps . add ( 1.5 , matA , 3.4 , matB , results ) ; } long curr = System . currentTimeMillis ( ) ; return curr - prev ; }
tr	SYM	(	public void setPlemeno ( String plemeno ) { this . plemeno = plemeno ; }
tr	KPT	int	public int getEnchantability ( ) { return enchantability ; }
tr	SYM	)	public Block getBlock ( String blockHash ) throws ZetacoinException ;
tr	KEH	try	public final Sequence loadMidiSequence ( URL sequenceName ) { Sequence sequence = null ; try { sequence = MidiSystem . getSequence ( sequenceName ) ; } catch ( InvalidMidiDataException exception ) { throw new IllegalArgumentException ( "AssetLoader.loadMidiSequence: " + "Unreadable or unsupported Midi file format " + sequenceName ) ; } catch ( IOException exception ) { throw new IllegalArgumentException ( "AssetLoader.loadMidiSequence: " + "IO Exception for " + sequenceName ) ; } return sequence ; }
tr	KEH	try	public void onDisable ( ) { users = 0 ; getLogger ( ) . log ( Level . INFO , "WCAPI has been disabled. Saving all users and alliances..." ) ; for ( String user : wcm . getWCSystem ( "system" ) . getUsers ( ) ) { try { wcm . savePlayer ( user ) ; users ++ ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } WCUtils . callChat ( WCMessageType . BROADCAST , "\u00A7dWC \u00A75// \u00A74WCAPI IS DISABLED! \u00A7cSaved " + users + " \u00A7cusers!" ) ; try { wcm . saveAlliances ( ) ; wcm . saveSystem ( systemYaml , systemFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	OAR	-	public ValidationProblem validate ( final Object instance , final Email annotation , final Object target , final CharSequence value ) { if ( value == null || value . length ( ) < 1 ) { if ( annotation . required ( ) ) { return new Problem ( instance , annotation , target , value ) ; } return null ; } int atIndex = - 1 ; int length = value . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( c == @ ) { atIndex = i ; break ; } } if ( atIndex < 0 || atIndex + 1 > length ) { return new Problem ( instance , annotation , target , value ) ; } final String domain = value . subSequence ( atIndex + 1 , length ) . toString ( ) ; final ValidationProblem problem = ValidationRoutines . validateDomain ( instance , annotation , target , domain , annotation . reverseLookup ( ) , annotation . validateTlds ( ) ) ; if ( problem != null ) { return problem ; } final CharSequence account = value . subSequence ( 0 , atIndex ) ; for ( int i = 0 , accountLength = account . length ( ) ; i < accountLength ; ++ i ) { if ( ! ValidationRoutines . isValidEmailAccountChar ( account . charAt ( i ) ) ) { return new Problem ( instance , annotation , target , value ) ; } } return null ; }
tr	KMD	public	@ AfterTest public void CloseBrowser ( ) { STCommonLibrary comLib = new STCommonLibrary ( ) ; red . replace ( 0 , 1 , "1" ) ; comLib . stTearDown ( red ) ; }
tr	KMD	public	public double cumulativeProbability ( double x0 , double x1 ) throws NumberIsTooLargeException { if ( x0 > x1 ) { throw new NumberIsTooLargeException ( LocalizedFormats . LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; } return cumulativeProbability ( x1 ) - cumulativeProbability ( x0 ) ; }
tr	KFC	return	public Color getMainColor ( ) { return m_main ; }
tr	OUT	++	public static TurnPhase getByName ( String name ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { TurnPhase result = VALUES_ARRAY [ i ] ; if ( result . getName ( ) . equals ( name ) ) { return result ; } } return null ; }
tr	KEH	try	public static void saveEmitter ( OutputStream out , ConfigurableEmitter emitter ) throws IOException { try { DocumentBuilder builder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; Document document = builder . newDocument ( ) ; document . appendChild ( emitterToElement ( document , emitter ) ) ; Result result = new StreamResult ( new OutputStreamWriter ( out , "utf-8" ) ) ; DOMSource source = new DOMSource ( document ) ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer xformer = factory . newTransformer ( ) ; xformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; xformer . transform ( source , result ) ; } catch ( Exception e ) { Log . error ( e ) ; throw new IOException ( "Failed to save emitter" ) ; } }
tr	KEH	assert	@ Test public void test ( ) { int [ ] intArr = { 3 , 4 , 5 , 3 , 4 } ; assert . assertEquals ( 5 , this . atleastOne . find ( intArr ) ) ; }
tr	KPT	int	@ Override public void ParseIn ( Connection Main , Server Environment ) { int Category = Main . DecodeInt ( ) ; }
tr	OAS	*=	@ Override public void changeState ( ) { state *= 20 ; }
tr	OUT	++	public void countMaxSpin ( ) { this . nMaxSpin ++ ; }
tr	KFC	return	public Date getData ( ) { return data ; }
tr	ORE	<	private Map < String , Object > loadYmlConfigFile ( String serviceCode ) throws ServiceDefinitionException { String resourceName = "" ; try { resourceName = builResourceRouteToConfigFile ( serviceCode ) ; InputStream serviceDefintionStream = this . getClass ( ) . getResourceAsStream ( resourceName ) ; if ( serviceDefintionStream == null ) throw new NullPointerException ( ) ; Yaml yaml = new Yaml ( ) ; return ( Map < String , Object > ) yaml . load ( new BufferedInputStream ( serviceDefintionStream ) ) ; } catch ( NullPointerException npe ) { throw new InvalidServiceDefinitionFileException ( serviceCode , resourceName ) ; } catch ( Exception e ) { throw new ServiceDefinitionException ( serviceCode , e ) ; } }
tr	KMD	public	@ Override public String getName ( ) { return "Marginal Modes Monte Carlo inference\t" + numSimulations ; }
tr	OAS	*=	public Pt mul ( Pt p ) { this . x *= p . x ; this . y *= p . y ; this . z *= p . z ; return this ; }
tr	KMD	public	public void itemStateChanged ( java . awt . event . ItemEvent evt ) { jComboBox3ItemStateChanged ( evt ) ; }
tr	OAR	-	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int i = 0 ; while ( i < a . length - 1 && a [ i + 1 ] >= a [ i ] ) i ++ ; if ( i == a . length - 1 ) { System . out . println ( 0 ) ; return ; } int ans = a . length - 1 - i ; i ++ ; while ( i < a . length - 1 && a [ i + 1 ] >= a [ i ] ) i ++ ; if ( i == a . length - 1 && a [ i ] <= a [ 0 ] ) System . out . println ( ans ) ; else System . out . println ( - 1 ) ; }
tr	OUT	++	@ Override public void run ( ) { console . displayMessage ( "Server thread started" ) ; try { console . displayMessage ( "Starting..." ) ; while ( true ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { NetworkMessage tmp = clients . get ( i ) . readMessage ( ) ; if ( tmp != null ) { manageMessage ( clients . get ( i ) . getID ( ) , tmp ) ; } } Thread . sleep ( 100 ) ; } } catch ( NetworkMessageException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } catch ( Exception ex ) { console . displayMessage ( ex . getClass ( ) + " " + ex . getMessage ( ) ) ; } console . displayMessage ( "Server thread stopped" ) ; }
tr	OAS	/=	public void normalize ( ) { double dist = x * x + y * y ; if ( dist > 0 ) { double size = Math . sqrt ( dist ) ; x /= size ; y /= size ; } }
tr	KEH	try	public void quit ( ) { try { network . getServer ( ) . socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } network . interrupt ( ) ; lobby . interrupt ( ) ; }
tr	KEH	try	protected void collect_org_solutions ( ) { try { String path = StaticData . Lucene_Data_Base + "/completeds/solution" ; File f = new File ( path ) ; if ( f . isDirectory ( ) ) { File [ ] files = f . listFiles ( ) ; for ( File f1 : files ) { String key = f1 . getName ( ) ; try { Scanner scanner = new Scanner ( f1 ) ; scanner . nextLine ( ) ; ArrayList < String > temp = new ArrayList < > ( ) ; while ( scanner . hasNext ( ) ) { String sol = scanner . nextLine ( ) . trim ( ) ; if ( ! sol . isEmpty ( ) ) { URL u = new URL ( sol ) ; temp . add ( sol ) ; } } scanner . close ( ) ; this . orginalSolution . put ( f1 . getName ( ) , temp ) ; } catch ( Exception exc ) { } } } } catch ( Exception exc ) { } }
tr	OAS	*=	public void negateVector ( ) { this . v [ 0 ] *= - 1 ; this . v [ 1 ] *= - 1 ; }
tr	OAS	*=	public void remove ( Champion self ) { self . healmodifier *= 2 ; }
tr	KEH	try	public static void main ( String [ ] args ) { UserDataGetter udg = new UserDataGetterImpl ( ) ; try { double pod = udg . getPodstawa ( ) ; char u = udg . getUmowa ( ) ; ContractFactory cf = new ContractFactoryImpl ( ) ; BaseContract bc = cf . createContract ( u ) ; bc . setPodstawa ( pod ) ; StandardTaxReport str = new StandardTaxReport ( bc , new StandardConsoleOutputWriter ( ) ) ; str . createReport ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	KMD	public	public MoveSequence ( List < MovementAction > sequence ) { for ( MovementAction movementAction : sequence ) { add ( movementAction ) ; } }
tr	OUT	++	public void mult ( double s ) { for ( int ii = 0 ; ii < N ; ii ++ ) { vals [ ii ] *= s ; } }
tr	KPT	boolean	private static String suggestBlankNodeName ( String node , int [ ] nodeindex , Map < String , RDFTerm > bnodeLabels ) { boolean validnode = ( node . length ( ) > 0 ) ; for ( int i = 0 ; i < node . length ( ) ; i ++ ) { int c = node . charAt ( i ) ; if ( i == 0 && ! ( ( c >= A && c <= Z ) || ( c >= a && c <= z ) ) ) { validnode = false ; break ; } if ( i >= 0 && ! ( ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || ( c >= a && c <= z ) ) ) { validnode = false ; break ; } } if ( validnode ) return node ; while ( true ) { node = "b" + Integer . toString ( nodeindex [ 0 ] ) ; if ( ! bnodeLabels . containsKey ( node ) ) return node ; nodeindex [ 0 ] ++ ; } }
tr	KFC	return	private IUnitOfWork obterUnitOfWork ( ) { return new UnitOfWork ( _usuarioRepository . getDatabaseFactory ( ) ) ; }
tr	KPT	int	public int getVillageHQIronCost ( ) { return villageHQIronCost ; }
tr	KPT	int	public ElapsedTimeInterval ping ( JSONObject header , String hostIP , int port , int timeout , int nTrials ) throws Exception ;
tr	OLB	&&	private void processNewClassInstance ( WatcherHolder holder , Set < WatcherHolder > watchersToBeRemoved ) throws QueryExecException { Set < Resource > instances = new HashSet < Resource > ( onto . getInstancesOf ( holder . referenceClass , false ) ) ; Set < Resource > futureResources = new HashSet < Resource > ( instances ) ; instances . removeAll ( holder . lastMatchedResources ) ; if ( instances . isEmpty ( ) && futureResources . size ( ) == holder . lastMatchedResources . size ( ) ) return ; if ( instances . isEmpty ( ) && futureResources . size ( ) < holder . lastMatchedResources . size ( ) ) { holder . lastMatchedResources = futureResources ; return ; } assert ( ! ( instances . isEmpty ( ) && futureResources . size ( ) > holder . lastMatchedResources . size ( ) ) ) ; OroEvent e = new OroEventNewInstances ( instances ) ; switch ( holder . watcher . getTriggeringType ( ) ) { case ON_TRUE : holder . watcher . notifySubscribers ( e ) ; break ; case ON_TRUE_ONE_SHOT : holder . watcher . notifySubscribers ( e ) ; watchersToBeRemoved . add ( holder ) ; break ; } holder . lastMatchedResources = futureResources ; }
tr	OAS	*=	@ Override public void multiplyBy ( Time t ) { this . Value *= t . toMillis ( ) . Value ; }
tr	KPT	boolean	public SettingsFractals1061 ( double xCenter , double yCenter , double size , int max_iterations , int color_choice , Color fractal_color , int out_coloring_algorithm , int user_out_coloring_algorithm , String outcoloring_formula , String [ ] user_outcoloring_conditions , String [ ] user_outcoloring_condition_formula , int in_coloring_algorithm , int user_in_coloring_algorithm , String incoloring_formula , String [ ] user_incoloring_conditions , String [ ] user_incoloring_condition_formula , boolean smoothing , int function , int bailout_test_algorithm , double bailout , String bailout_test_user_formula , String bailout_test_user_formula2 , int bailout_test_comparison , double n_norm , int plane_type , boolean apply_plane_on_julia , boolean burning_ship , double z_exponent , double [ ] z_exponent_complex , int color_cycling_location , double [ ] coefficients , int [ ] [ ] custom_palette , int color_interpolation , int color_space , boolean reversed_palette , double rotation , double [ ] rotation_center , boolean perturbation , double [ ] perturbation_vals , boolean variable_perturbation , int user_perturbation_algorithm , String [ ] user_perturbation_conditions , String [ ] user_perturbation_condition_formula , String perturbation_user_formula , boolean init_val , double [ ] initial_vals , boolean variable_init_value , int user_initial_value_algorithm , String [ ] user_initial_value_conditions , String [ ] user_initial_value_condition_formula , String initial_value_user_formula , boolean mandel_grass , double [ ] mandel_grass_vals , double [ ] z_exponent_nova , double [ ] relaxation , int nova_method , String user_formula , String user_formula2 , int bail_technique , String user_plane , int user_plane_algorithm , String [ ] user_plane_conditions , String [ ] user_plane_condition_formula , String [ ] user_formula_iteration_based , String [ ] user_formula_conditions , String [ ] user_formula_condition_formula , boolean exterior_de , double exterior_de_factor , double height_ratio , double [ ] plane_transform_center , double plane_transform_angle , double plane_transform_radius , double [ ] plane_transform_scales , double plane_transform_angle2 , int plane_transform_sides , double plane_transform_amount , double color_intensity , int escaping_smooth_algorithm , int converging_smooth_algorithm , boolean bump_map , double bumpMappingStrength , double bumpMappingDepth , double lightDirectionDegrees , boolean polar_projection , double circle_period , boolean fake_de , double fake_de_factor , String user_fz_formula , String user_dfz_formula , String user_ddfz_formula , Color dem_color , Color special_color , boolean special_use_palette_color ) { super ( xCenter , yCenter , size , max_iterations , color_choice , fractal_color , out_coloring_algorithm , user_out_coloring_algorithm , outcoloring_formula , user_outcoloring_conditions , user_outcoloring_condition_formula , in_coloring_algorithm , user_in_coloring_algorithm , incoloring_formula , user_incoloring_conditions , user_incoloring_condition_formula , smoothing , function , bailout_test_algorithm , bailout , bailout_test_user_formula , bailout_test_user_formula2 , bailout_test_comparison , n_norm , plane_type , apply_plane_on_julia , burning_ship , z_exponent , z_exponent_complex , color_cycling_location , coefficients , custom_palette , color_interpolation , color_space , reversed_palette , rotation , rotation_center , perturbation , perturbation_vals , variable_perturbation , user_perturbation_algorithm , user_perturbation_conditions , user_perturbation_condition_formula , perturbation_user_formula , init_val , initial_vals , variable_init_value , user_initial_value_algorithm , user_initial_value_conditions , user_initial_value_condition_formula , initial_value_user_formula , mandel_grass , mandel_grass_vals , z_exponent_nova , relaxation , nova_method , user_formula , user_formula2 , bail_technique , user_plane , user_plane_algorithm , user_plane_conditions , user_plane_condition_formula , user_formula_iteration_based , user_formula_conditions , user_formula_condition_formula , exterior_de , exterior_de_factor , height_ratio , plane_transform_center , plane_transform_angle , plane_transform_radius , plane_transform_scales , plane_transform_angle2 , plane_transform_sides , plane_transform_amount , color_intensity , escaping_smooth_algorithm , converging_smooth_algorithm , bump_map , bumpMappingStrength , bumpMappingDepth , lightDirectionDegrees , polar_projection , circle_period , fake_de , fake_de_factor , user_fz_formula , user_dfz_formula , user_ddfz_formula ) ; this . dem_color = dem_color ; this . special_color = special_color ; this . special_use_palette_color = special_use_palette_color ; }
tr	SYM	)	public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof UnaryRule ) ) return false ; final UnaryRule unaryRule = ( UnaryRule ) o ; if ( child != null ? ! child . equals ( unaryRule . child ) : unaryRule . child != null ) return false ; if ( parent != null ? ! parent . equals ( unaryRule . parent ) : unaryRule . parent != null ) return false ; return true ; }
tr	KFC	if	public boolean equals ( Object rhs ) { if ( rhs instanceof CommunityAccountLite ) { return ( ( CommunityAccountLite ) rhs ) . username . equals ( username ) ; } return false ; }
tr	OUT	++	public void squeezeXY ( double m , int k ) { for ( int i = 0 ; i < length ( ) ; i ++ ) { XY [ k ] [ i ] = ( int ) Math . round ( m * XY [ k ] [ i ] ) ; } }
tr	OAS	*=	public void update ( GuiParticle var1 ) { this . posX += this . velocityX ; this . posY += this . velocityY ; this . velocityX *= this . accelScale ; this . velocityY *= this . accelScale ; this . velocityY += 0.1D ; if ( ++ this . timeTick > this . timeLimit ) { this . setDead ( ) ; } this . tintAlpha = 2.0D - ( double ) this . timeTick / ( double ) this . timeLimit * 2.0D ; if ( this . tintAlpha > 1.0D ) { this . tintAlpha = 1.0D ; } this . tintAlpha *= this . tintAlpha ; this . tintAlpha *= 0.5D ; }
tr	OLB	&&	@ Override public void execute ( ) { final NPC mob = getNearestNpc ( ) ; if ( mob != null ) { if ( ! Misc . isOnScreen ( mob ) ) { if ( FighterGUI . useFastCamera ) { MCamera . turnTo ( mob , 50 ) ; } else { Camera . turnTo ( mob , 5 ) ; } } int dist = ( int ) mob . getLocation ( ) . distanceTo ( ) ; if ( dist > 7 && ! Players . getLocal ( ) . isMoving ( ) ) { Walking . walk ( mob ) ; } else { MonsterKiller . status = "Attacking " + mob . getName ( ) ; mob . interact ( "Attack" , mob . getName ( ) ) ; new TimedCondition ( 1500 ) { @ Override public boolean isDone ( ) { return Players . getLocal ( ) . getInteracting ( ) != null ; } } . waitStop ( ) ; } } }
tr	OAS	*=	public void mul ( int index , long value ) { if ( index >= size ) { throw new IndexOutOfBoundsException ( "index can't be >= size: " + index + " >= " + size ) ; } items [ index ] *= value ; }
tr	KEH	try	@ Override public void actionPerformed ( ActionEvent a ) { try { this . executarCadastro ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	ORE	<	public ReceiveMessageWorker ( Connection aConnection ) { isRunning = false ; this . aConnection = aConnection ; messageListenerList = new ArrayList < MessageListener > ( ) ; }
tr	KPT	boolean	public boolean equals ( Object obj ) { if ( obj instanceof ConstantMethodInfo ) { ConstantMethodInfo other = ( ConstantMethodInfo ) obj ; return ( mParentClass . equals ( other . mParentClass ) && mNameAndType . equals ( other . mNameAndType ) ) ; } return false ; }
tr	KEH	try	public static Interlocuteur selectByIdCommercial ( int id ) throws SQLException { String query = null ; Interlocuteur interlocuteur1 = new Interlocuteur ( ) ; ResultSet resultat ; try { query = "SELECT * from INTERLOCUTEUR where ID_COMMERCIAL =? " ; PreparedStatement pStatement = ConnectionBDD . getInstance ( ) . getPreparedStatement ( query ) ; pStatement . setInt ( 1 , id ) ; resultat = pStatement . executeQuery ( ) ; while ( resultat . next ( ) ) { interlocuteur1 = new Interlocuteur ( resultat . getInt ( "ID_INTERLOCUTEUR" ) , resultat . getInt ( "ID_COMMERCIAL" ) , resultat . getInt ( "ID_VILLE" ) , resultat . getInt ( "ID_SERVICE" ) , resultat . getString ( "INTNOM" ) , resultat . getString ( "INTPRENOM" ) , resultat . getString ( "INTEMAIL" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( RequetesInterlocuteur . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return interlocuteur1 ; }
tr	KMD	public	public boolean accuracyCheckRequired ( Pokemon target ) { switch ( this ) { case NO_GUARD : return false ; default : return target . getAbility ( ) == NO_GUARD ; } }
tr	KEH	try	public static void playDuelFor ( Duelist duelist , Duel duel ) throws InterruptedException { Stack < Card > canplay = new Stack < Card > ( ) ; Stack < Stack < Card >> fusions = new Stack < Stack < Card >> ( ) ; int c ; int timer = 800 ; int selection = 0 ; int phase = 1 ; int goal = 0 ; boolean simpleton = true ; Card card ; MonsterCard mc ; EquipCard ec ; SpellCard sc ; FieldCard fc ; Stack < MonsterCard > oppmonsters = new Stack < MonsterCard > ( ) ; Stack < MonsterCard > mymonsters = new Stack < MonsterCard > ( ) ; if ( simpleton ) { goal = 0 ; canplay . clear ( ) ; while ( true ) { if ( goal == 0 ) { for ( c = 0 ; c < duelist . hand . size ( ) ; c ++ ) { if ( FieldCard . class . isInstance ( duelist . hand . cards . get ( c ) ) ) { fc = FieldCard . class . cast ( duelist . hand . cards . get ( c ) ) ; if ( fc . terrain != duel . terrain ) { AI . doInput ( timer , duel , duelist , 45 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 26 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; goal = AI . BATTLE ; } } } if ( ! duelist . field . emptyMonsterZones ( ) ) { if ( PluginVars . random . nextBoolean ( ) ) { for ( c = 0 ; c < duelist . hand . size ( ) ; c ++ ) { if ( SpellCard . class . isInstance ( duelist . hand . cards . get ( c ) ) ) { sc = SpellCard . class . cast ( duelist . hand . cards . get ( c ) ) ; if ( sc . shouldActivate ( duel , duelist ) ) { AI . doInput ( timer , duel , duelist , 45 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 26 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; if ( RitualCard . class . isInstance ( sc ) ) { AI . doInput ( timer , duel , duelist , 26 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } goal = AI . BATTLE ; c = 10 ; } else { AI . doInput ( timer , duel , duelist , 45 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; try { AI . doInput ( timer , duel , duelist , 36 + duelist . field . getPos ( duelist . field . getFirstOpenMagicZone ( ) ) , ClickType . LEFT ) ; } catch ( NoZoneOpenException e ) { AI . doInput ( timer , duel , duelist , 36 + PluginVars . random . nextInt ( 5 ) , ClickType . LEFT ) ; } Thread . sleep ( timer ) ; goal = AI . BATTLE ; c = 10 ; } } } } } if ( goal == AI . BATTLE ) continue ; if ( duelist . opponent . field . emptyMonsterZones ( ) ) { goal = AI . DIRECT_ATTACK ; } else { goal = AI . DEFEAT_CARD ; } } else if ( goal == AI . DIRECT_ATTACK ) { canplay . clear ( ) ; fusions = AI . howToDefeat ( 1 , null , duel , duelist ) ; if ( fusions . empty ( ) ) { AI . playFrom ( canplay , duel , duelist , timer , false , null ) ; } else { canplay = fusions . get ( PluginVars . random . nextInt ( fusions . size ( ) ) ) ; if ( canplay . size ( ) <= 1 ) { AI . playFrom ( canplay , duel , duelist , timer , false , null ) ; } else { AI . doFusion ( canplay , duel , duelist , null , timer ) ; } } goal = AI . BATTLE ; } else if ( goal == AI . DEFEAT_CARD ) { canplay . clear ( ) ; oppmonsters = AI . getCardList ( duelist . opponent ) ; mc = oppmonsters . pop ( ) ; if ( mc . position == MonsterPosition . ATTACK ) { fusions = AI . howToDefeat ( mc . getAtk ( ) , mc . * , duel , duelist ) ; } else { fusions = AI . howToDefeat ( mc . getDef ( ) , mc . * , duel , duelist ) ; } if ( fusions . empty ( ) ) { if ( PluginVars . hard_mode ) { oppmonsters = AI . getCardList ( duelist . opponent ) ; mc = oppmonsters . pop ( ) ; for ( int p = 0 ; p < duelist . deck . cards . size ( ) ; p ++ ) { card = duelist . deck . cards . get ( p ) ; if ( MonsterCard . class . isInstance ( card ) ) { MonsterCard mymc = MonsterCard . class . cast ( card ) ; if ( mc . position == MonsterPosition . DEFENSE ) { if ( mymc . atk > mc . def + mc . bonus ) { Card card2 = duelist . deck . cards . get ( p ) ; duelist . deck . cards . set ( p , duelist . hand . cards . get ( 0 ) ) ; duelist . hand . cards . set ( 0 , card2 ) ; canplay . push ( card2 ) ; AI . playFrom ( canplay , duel , duelist , timer , false , null ) ; goal = AI . BATTLE ; break ; } } else { if ( mymc . atk > mc . atk + mc . bonus ) { Card card2 = duelist . deck . cards . get ( p ) ; duelist . deck . cards . set ( p , duelist . hand . cards . get ( 0 ) ) ; duelist . hand . cards . set ( 0 , card2 ) ; canplay . push ( card2 ) ; AI . playFrom ( canplay , duel , duelist , timer , false , null ) ; goal = AI . BATTLE ; break ; } } } } if ( goal == AI . BATTLE ) continue ; } goal = AI . DEFEND ; continue ; } else { canplay = fusions . get ( PluginVars . random . nextInt ( fusions . size ( ) ) ) ; if ( canplay . size ( ) <= 1 ) { AI . playFrom ( canplay , duel , duelist , timer , false , null ) ; } else { AI . doFusion ( canplay , duel , duelist , null , timer ) ; } } goal = AI . BATTLE ; } else if ( goal == AI . DEFEND ) { canplay . clear ( ) ; for ( c = 0 ; c < duelist . hand . size ( ) ; c ++ ) { if ( MonsterCard . class . isInstance ( duelist . hand . cards . elementAt ( c ) ) ) { canplay . push ( duelist . hand . cards . elementAt ( c ) ) ; } } AI . playFrom ( canplay , duel , duelist , timer , true , null ) ; goal = AI . BATTLE ; } else if ( goal == AI . BATTLE ) { for ( c = 0 ; c < duelist . field . magiczones . length ; c ++ ) { if ( ! duelist . field . magiczones [ c ] . isOpen ( ) ) { if ( SpellCard . class . isInstance ( duelist . field . magiczones [ c ] . card ) ) { sc = SpellCard . class . cast ( duelist . field . magiczones [ c ] . card ) ; if ( sc . shouldActivate ( duel , duelist ) ) { AI . doInput ( timer , duel , duelist , 36 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } if ( RitualCard . class . isInstance ( sc ) ) { AI . doInput ( timer , duel , duelist , 26 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } } else if ( EquipCard . class . isInstance ( duelist . field . magiczones [ c ] . card ) ) { ec = EquipCard . class . cast ( duelist . field . magiczones [ c ] . card ) ; mymonsters = AI . getCardList ( duelist ) ; while ( ! mymonsters . empty ( ) ) { mc = mymonsters . pop ( ) ; if ( mc . canEquip ( ec ) ) { AI . doInput ( timer , duel , duelist , 36 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; try { AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mc ) ) , ClickType . LEFT ) ; } catch ( NoZoneOpenException e ) { System . out . println ( "WHAT?" ) ; } Thread . sleep ( timer ) ; } } } } } if ( PluginVars . monster_effects ) { for ( c = 0 ; c < duelist . field . monsterzones . length ; c ++ ) { if ( ! duelist . field . monsterzones [ c ] . isOpen ( ) ) { mc = MonsterCard . class . cast ( duelist . field . monsterzones [ c ] . card ) ; if ( ! mc . attacked && mc . hasEffect ( ) && ! mc . usedEffect ) { if ( mc . shouldActivate ( duel , duelist ) ) { AI . doInput ( timer , duel , duelist , 27 + c , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 26 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } } } } } oppmonsters = AI . getCardList ( duelist . opponent ) ; while ( duelist . swords == 0 && ! AI . cardsAttacked ( duelist ) ) { if ( oppmonsters . empty ( ) ) { if ( duelist . opponent . field . emptyMonsterZones ( ) ) { mymonsters = AI . getCardList ( duelist ) ; while ( ! mymonsters . empty ( ) ) { mc = mymonsters . pop ( ) ; if ( ! mc . attacked && duelist . swords == 0 && mc . atk > 0 ) { try { if ( mc . position == MonsterPosition . DEFENSE ) { AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mc ) ) , ClickType . RIGHT ) ; Thread . sleep ( timer ) ; } AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mc ) ) , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 20 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } catch ( NoZoneOpenException e ) { System . out . println ( "WHAT?" ) ; } } } AI . doInput ( timer , duel , duelist , 42 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; break ; } else { mymonsters = AI . getCardList ( duelist ) ; while ( ! mymonsters . empty ( ) ) { mc = mymonsters . pop ( ) ; if ( ! mc . attacked && mc . atk < 3000 && mc . position != MonsterPosition . DEFENSE ) { try { AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mc ) ) , ClickType . RIGHT ) ; } catch ( NoZoneOpenException e ) { System . out . println ( "WHAT?" ) ; } Thread . sleep ( timer ) ; } } AI . doInput ( timer , duel , duelist , 42 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; break ; } } else { MonsterCard toDefeat = MonsterCard . class . cast ( oppmonsters . pop ( ) ) ; mymonsters = AI . getCardList ( duelist ) ; for ( c = 0 ; c < mymonsters . size ( ) ; c ++ ) { if ( mymonsters . get ( c ) . attacked ) continue ; else if ( ! toDefeat . faceup ) { if ( duelist . swords == 0 && PluginVars . random . nextBoolean ( ) ) { try { if ( mymonsters . get ( c ) . position == MonsterPosition . DEFENSE ) { AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mymonsters . get ( c ) ) ) , ClickType . RIGHT ) ; Thread . sleep ( timer ) ; } AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mymonsters . get ( c ) ) ) , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 22 - duelist . opponent . field . getPos ( duelist . opponent . field . getZoneWithCard ( toDefeat ) ) , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } catch ( NoZoneOpenException e ) { System . out . println ( "WHAT?" ) ; } break ; } } else if ( duelist . swords == 0 && mymonsters . get ( c ) . atk > 0 && AI . canDefeat ( mymonsters . get ( c ) , toDefeat ) ) { try { if ( mymonsters . get ( c ) . position != MonsterPosition . ATTACK ) { AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mymonsters . get ( c ) ) ) , ClickType . RIGHT ) ; Thread . sleep ( timer ) ; } AI . doInput ( timer , duel , duelist , 27 + duelist . field . getPos ( duelist . field . getZoneWithCard ( mymonsters . get ( c ) ) ) , ClickType . LEFT ) ; Thread . sleep ( timer ) ; AI . doInput ( timer , duel , duelist , 22 - duelist . opponent . field . getPos ( duelist . opponent . field . getZoneWithCard ( toDefeat ) ) , ClickType . LEFT ) ; Thread . sleep ( timer ) ; } catch ( NoZoneOpenException e ) { System . out . println ( "WHAT?" ) ; } break ; } } } } break ; } } AI . doInput ( timer , duel , duelist , 42 , ClickType . LEFT ) ; Thread . sleep ( timer ) ; return ; } }
tr	SYM	(	public static TotalisticRule fromIndex ( int idx ) { assert ( idx >= 0 && idx < 1 << 19 ) ; Rule r = new Rule ( ) ; r . born [ 0 ] = false ; for ( int i = 1 ; i < 10 ; ++ i ) { r . born [ i ] = ( idx & 1 ) == 1 ; idx = idx >> 1 ; } for ( int i = 0 ; i < 10 ; ++ i ) { r . live [ i ] = ( idx & 1 ) == 1 ; idx = idx >> 1 ; } return r ; }
tr	KEH	try	static private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 4 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 ) ; return 6 ; } switch ( curChar ) { case 69 : return jjMoveStringLiteralDfa7_0 ( active0 , 20 ) ; case 100 : return jjMoveStringLiteralDfa7_0 ( active0 , 2000 ) ; case 101 : if ( ( active0 & 80 ) != 0 ) return jjStopAtPos ( 6 , 7 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 1000 ) ; case 102 : return jjMoveStringLiteralDfa7_0 ( active0 , 40 ) ; case 114 : if ( ( active0 & 400 ) != 0 ) return jjStopAtPos ( 6 , 10 ) ; break ; case 115 : if ( ( active0 & 800 ) != 0 ) return jjStopAtPos ( 6 , 11 ) ; break ; case 116 : if ( ( active0 & 200 ) != 0 ) return jjStopAtPos ( 6 , 9 ) ; break ; case 118 : return jjMoveStringLiteralDfa7_0 ( active0 , 100 ) ; default : break ; } return jjStartNfa_0 ( 5 , active0 ) ; }
tr	OLB	||	protected static boolean isValidNumber ( double d ) { return ( ! ( double . isNaN ( d ) || double . isInfinite ( d ) ) ) ; }
tr	KPT	int	public int add ( int n , int ... rest ) { for ( int x : rest ) { n += x ; } return n ; }
tr	OLB	&&	public void setupReferences ( ) throws IOException , MissingAccessionException { List < String > fastaEntries = Protein . splitFasta ( getSettings ( ) . getReferencesFasta ( ) ) ; for ( String fastaEntry : fastaEntries ) { if ( fastaEntry != null && ! fastaEntry . trim ( ) . equals ( "" ) ) { ReferenceDescription rd = ReferenceDescription . constructFromFastaEntry ( fastaEntry . trim ( ) ) ; Protein p = getProteins ( ) . get ( rd . getAccession ( ) ) ; if ( p == null ) throw new MissingAccessionException ( "Could not find Protein for Accession '" + rd . getAccession ( ) + "'" ) ; p . getEvaluationScoreCalculator ( ) . setReferenceDescription ( rd ) ; } } }
tr	SYM	(	T subtract ( T other ) ;
tr	ORE	<	public synchronized void remove ( K key ) throws IOException { V val = null ; if ( ! recordListeners . isEmpty ( ) ) val = find ( key ) ; _root . remove ( key ) ; if ( val != null ) for ( RecordListener < K , V > r : recordListeners ) r . recordRemoved ( key , val ) ; }
tr	KEH	try	public static final void output ( InputSource iss , Writer out , String encoding ) { try { SAXParser parser = factory . newSAXParser ( ) ; FormatHandler hndlr = new FormatHandler ( out , encoding ) ; parser . parse ( iss , hndlr ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
tr	OAS	/=	@ Override public void divideBy ( Time t ) { Value /= t . toYears ( ) . Value ; }
tr	OAS	*=	public void scaleSelf ( double s ) { x *= s ; y *= s ; validate ( ) ; }
tr	OAS	<<=	public void shiftLeft ( ) { int usedLen = getUsedLength ( ) ; if ( usedLen == 0 ) { return ; } if ( m_ints [ usedLen - 1 ] < 0 ) { usedLen ++ ; if ( usedLen > m_ints . length ) { m_ints = resizedInts ( m_ints . length + 1 ) ; } } boolean carry = false ; for ( int i = 0 ; i < usedLen ; i ++ ) { boolean nextCarry = m_ints [ i ] < 0 ; m_ints [ i ] <<= 1 ; if ( carry ) { m_ints [ i ] |= 1 ; } carry = nextCarry ; } }
tr	OAS	/=	public static String solution ( ) { double result = ones ( CUTS . get ( 1 ) , 1 , 0 ) ; int verdi = ( int ) ( result * Math . pow ( 10 , 7 ) ) ; verdi += 5 ; verdi /= 10 ; return "0." + verdi ; }
tr	OAR	-	public static long [ ] [ ] matrixPow ( long [ ] [ ] matrix , BigInteger pow , long mod ) { int length = ( int ) ( logBigInteger ( pow ) / Math . log ( 2.0 ) ) + 1 ; BigInteger [ ] ints = new BigInteger [ length ] ; long [ ] [ ] [ ] powArray = new long [ length ] [ ] [ ] ; for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = BigInteger . valueOf ( 2 ) . pow ( i ) ; } powArray [ 0 ] = matrix ; for ( int i = 1 ; i < powArray . length ; i ++ ) { powArray [ i ] = matrixMult ( powArray [ i - 1 ] , powArray [ i - 1 ] , mod ) ; } BigInteger pows = BigInteger . ZERO ; long [ ] [ ] result = new long [ matrix . length ] [ matrix . length ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] [ i ] = 1 ; } for ( int i = ints . length - 1 ; i >= 0 ; i -- ) { BigInteger a = ints [ i ] ; if ( pow . subtract ( pows ) . divide ( a ) . equals ( BigInteger . ONE ) ) { pows = pows . add ( a ) ; result = matrixMult ( result , powArray [ i ] , mod ) ; } } return result ; }
tr	SYM	;	public static StringBuilder serializeArrayOfObjects ( Collection < ? > arrayOfobjects ) { StringBuilder buffer = new StringBuilder ( ) ; boolean isFirstItem = true ; buffer . append ( [ ) ; for ( Object item : arrayOfobjects ) { if ( ! isFirstItem ) buffer . append (   ) ; buffer . append ( serialize ( item ) ) ; isFirstItem = false ; } buffer . append ( ] ) ; return buffer ; }
tr	ORE	<	public void update ( Servico servico ) { int index = 0 ; String [ ] serviceData = new String [ 4 ] ; Iterator < Row > rowItr = servicosSheet . rowIterator ( ) ; while ( rowItr . hasNext ( ) ) { Row row = rowItr . next ( ) ; if ( row . getCell ( 0 ) . getStringCellValue ( ) . equals ( servico . getID ( ) ) ) { Iterator < Cell > cells = row . cellIterator ( ) ; while ( cells . hasNext ( ) ) { Cell cell = cells . next ( ) ; cell . setCellValue ( serviceData [ index ] ) ; index ++ ; } } } FileOutputStream stream ; try { stream = new FileOutputStream ( "planilha.xls" ) ; wb . write ( stream ) ; stream . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	KEH	assert	public void testXmlConstructor_indefinite_percentage ( ) { String mockXml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?><ProgressWidget xmlns=\"http://www.garmin.com/xmlschemas/PluginAPI/v1\"><Title>GarminPlugin Status not yet implemented</Title><Text></Text><Text></Text><Text>0% complete</Text><ProgressBar Type=\"Indefinite\" Value=\"33\"/></ProgressWidget>" ; TransferProgress prog = ParseUtils . parseProgressXml ( mockXml ) ; int expectedPercentage = 100 ; assert . assertTrue ( "Percentage set flag should be set" , prog . hasPercentage ( ) ) ; assert . assertEquals ( "Incorrectly parsed xml percentage" , expectedPercentage , prog . getPercentage ( ) ) ; }
tr	OAS	>>=	public void unbiasnet ( ) { int i , j ; for ( i = 0 ; i < netsize ; i ++ ) { network [ i ] [ 0 ] >>= netbiasshift ; network [ i ] [ 1 ] >>= netbiasshift ; network [ i ] [ 2 ] >>= netbiasshift ; network [ i ] [ 3 ] = i ; } }
tr	KMD	public	public void playSoundPop ( ) { this . soundPop . play ( 1 ) ; }
tr	OAR	/	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	OAS	*=	private int get2Fold ( int fold ) { int ret = 2 ; while ( ret < fold ) { ret *= 2 ; } return ret ; }
tr	KPT	int	private static void stat ( int n , int t ) { final PercolationStats percolationStats = new PercolationStats ( n , t ) ; StdOut . printf ( "%50s = %f\n" , "mean" , percolationStats . mean ( ) ) ; StdOut . printf ( "%50s = %f\n" , "stddev" , percolationStats . stddev ( ) ) ; StdOut . printf ( "%50s = %f  %f\n" , "95% confidence interval" , percolationStats . confidenceLo ( ) , percolationStats . confidenceHi ( ) ) ; }
tr	KFC	return	public boolean confirmRemoval ( ) { return confirmRemoval ( "this" ) ; }
tr	OAR	-	@ Override public Collection < TicketSummary > getTicketsSummaries ( int id , User user ) throws DAOException { final int ORDERED_TICKET_INDEX = 2 ; final int TICKET_TYPE_ID = 1 ; final int DATE_ID_INDEX = 1 ; final String SELECT_AVALIBLE_QUERY = "SELECT categoryId SUM(quantity) FROM jeeproject.orders WHERE dateId = ? GROUP BY categoryId;" ; final int PAID_INDEX = 3 ; final int USER_ID_INDEX = 2 ; final String SELECT_USER_ORDERED_PAID_TICKET = "SELECT categoryId  SUM(quantity)  S.SUM FROM orders\tLEFT JOIN ( SELECT orderId  SUM(quantity) as SUM FROM payment GROUP BY orderId) AS S ON orders.id = S.orderId WHERE dateId = ? AND loginId = ? GROUP BY categoryId" ; Connection connection = null ; PreparedStatement selectAvalible = null ; PreparedStatement selectOrdered = null ; ResultSet rs = null ; Map < Integer , TicketSummary > map = new HashMap < Integer , TicketSummary > ( ) ; for ( Ticket ticket : Constants . tickets . values ( ) ) { map . put ( ticket . getId ( ) , new TicketSummary ( ticket ) ) ; } boolean flag = false ; int ticketId = 0 ; TicketSummary currentSummary = null ; try { connection = DBConnector . getConnection ( ) ; selectAvalible = connection . prepareStatement ( SELECT_AVALIBLE_QUERY ) ; selectAvalible . setInt ( DATE_ID_INDEX , id ) ; rs = selectAvalible . executeQuery ( ) ; while ( rs . next ( ) ) { flag = true ; ticketId = rs . getInt ( TICKET_TYPE_ID ) ; currentSummary = map . get ( ticketId ) ; currentSummary . calcAvalible ( rs . getInt ( ORDERED_TICKET_INDEX ) ) ; map . put ( ticketId , currentSummary ) ; } if ( flag && user != null ) { rs . close ( ) ; selectOrdered = connection . prepareStatement ( SELECT_USER_ORDERED_PAID_TICKET ) ; selectOrdered . setInt ( DATE_ID_INDEX , id ) ; selectOrdered . setInt ( USER_ID_INDEX , user . getId ( ) ) ; rs = selectOrdered . executeQuery ( ) ; while ( rs . next ( ) ) { flag = true ; ticketId = rs . getInt ( TICKET_TYPE_ID ) ; currentSummary = map . get ( ticketId ) ; currentSummary . setPaid ( rs . getInt ( PAID_INDEX ) ) ; currentSummary . setOrdered ( rs . getInt ( ORDERED_TICKET_INDEX ) - currentSummary . getPaid ( ) ) ; map . put ( ticketId , currentSummary ) ; } } return map . values ( ) ; } catch ( SQLException e ) { throw new DAOException ( Constants . INTERNAL_ERROR , e ) ; } finally { DBConnector . closeStatement ( selectOrdered ) ; DBConnector . closeConnection ( connection , selectAvalible , rs ) ; } }
tr	ORE	>=	private void PayMarketBill ( MarketBill marketBill ) { if ( money >= marketBill . bill ) { log . add ( new LoggedEvent ( "have enough money" ) ) ; int moneyBack = marketBill . bill ; print ( "the cashier has enough money to pay " + marketBill . market . getName ( ) + " for the order" ) ; money -= marketBill . bill ; print ( "the cashier pays the market $" + marketBill . bill + " for " + marketBill . groceryList ) ; marketBill . bill = 0 ; print ( "the cashier now has $" + money ) ; marketBill . market . msgHereIsPayment ( moneyBack ) ; } else if ( money < marketBill . bill ) { log . add ( new LoggedEvent ( "don't have enough money" ) ) ; int moneyBack = money ; print ( "the cashier does not have enough money to pay " + marketBill . market . getName ( ) + " for " + marketBill . groceryList + ". The cashier paid all he could" ) ; marketBill . bill -= money ; print ( marketBill . market . getName ( ) + " bill is still $" + marketBill . bill ) ; money = 0 ; print ( "the cashier now has $" + money ) ; marketBill . market . msgHereIsPayment ( moneyBack ) ; } else if ( marketBill . bill == 0 ) { log . add ( new LoggedEvent ( "0 dollar bill" ) ) ; } marketBill . paid = true ; }
tr	OLB	||	protected Instance getInstanceSparse ( boolean flag ) throws IOException { int valIndex , numValues = 0 , maxIndex = - 1 ; do { getIndex ( ) ; if ( m_Tokenizer . ttype == } ) { break ; } try { m_IndicesBuffer [ numValues ] = Integer . valueOf ( m_Tokenizer . sval ) . intValue ( ) ; } catch ( NumberFormatException e ) { errorMessage ( "index number expected" ) ; } if ( m_IndicesBuffer [ numValues ] <= maxIndex ) { errorMessage ( "indices have to be ordered" ) ; } if ( ( m_IndicesBuffer [ numValues ] < 0 ) || ( m_IndicesBuffer [ numValues ] >= m_Data . numAttributes ( ) ) ) { errorMessage ( "index out of bounds" ) ; } maxIndex = m_IndicesBuffer [ numValues ] ; getNextToken ( ) ; if ( m_Tokenizer . ttype == ? ) { m_ValueBuffer [ numValues ] = Instance . missingValue ( ) ; } else { if ( m_Tokenizer . ttype != StreamTokenizer . TT_WORD ) { errorMessage ( "not a valid value" ) ; } switch ( m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . type ( ) ) { case Attribute . NOMINAL : valIndex = m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . indexOfValue ( m_Tokenizer . sval ) ; if ( valIndex == - 1 ) { errorMessage ( "nominal value not declared in header" ) ; } m_ValueBuffer [ numValues ] = ( double ) valIndex ; break ; case Attribute . NUMERIC : try { m_ValueBuffer [ numValues ] = double . valueOf ( m_Tokenizer . sval ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { errorMessage ( "number expected" ) ; } break ; case Attribute . STRING : m_ValueBuffer [ numValues ] = m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . addStringValue ( m_Tokenizer . sval ) ; break ; case Attribute . DATE : try { m_ValueBuffer [ numValues ] = m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . parseDate ( m_Tokenizer . sval ) ; } catch ( ParseException e ) { errorMessage ( "unparseable date: " + m_Tokenizer . sval ) ; } break ; case Attribute . RELATIONAL : try { ArffReader arff = new ArffReader ( new StringReader ( m_Tokenizer . sval ) , m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . relation ( ) , 0 ) ; Instances data = arff . getData ( ) ; m_ValueBuffer [ numValues ] = m_Data . attribute ( m_IndicesBuffer [ numValues ] ) . addRelation ( data ) ; } catch ( Exception e ) { throw new IOException ( e . toString ( ) + " of line " + getLineNo ( ) ) ; } break ; default : errorMessage ( "unknown attribute type in column " + m_IndicesBuffer [ numValues ] ) ; } } numValues ++ ; } while ( true ) ; double weight = 1.0 ; if ( flag ) { weight = getInstanceWeight ( ) ; if ( ! double . isNaN ( weight ) ) { getLastToken ( true ) ; } else { weight = 1.0 ; } } double [ ] tempValues = new double [ numValues ] ; int [ ] tempIndices = new int [ numValues ] ; System . arraycopy ( m_ValueBuffer , 0 , tempValues , 0 , numValues ) ; System . arraycopy ( m_IndicesBuffer , 0 , tempIndices , 0 , numValues ) ; Instance inst = new SparseInstance ( weight , tempValues , tempIndices , m_Data . numAttributes ( ) ) ; inst . setDataset ( m_Data ) ; return inst ; }
tr	ORE	<	private static void check ( int [ ] v ) { final long [ ] subs = getThreeDigitSubs ( v ) ; boolean divisibles = true ; for ( int i = 0 ; i < divisors . length ; i ++ ) { if ( ! isDivisible ( subs [ i ] , divisors [ i ] ) ) { divisibles = false ; break ; } } if ( divisibles ) { System . out . println ( "# PD number " + subs [ subs . length - 1 ] ) ; result += subs [ subs . length - 1 ] ; } }
tr	SYM	)	private void positionUp ( ) { setPosition ( getPosition ( ) + 1 ) ; }
tr	OAS	&=	@ Override public void setPullResistance ( Pin pin , PinPullResistance resistance ) { if ( hasPin ( pin ) == false ) { throw new InvalidPinException ( pin ) ; } if ( ! pin . getSupportedPinPullResistance ( ) . contains ( resistance ) ) { throw new UnsupportedPinPullResistanceException ( pin , resistance ) ; } try { int pinAddress = pin . getAddress ( ) ; if ( resistance == PinPullResistance . PULL_UP ) { currentPullup |= pinAddress ; } else { currentPullup &= ~ pinAddress ; } device . write ( REGISTER_GPPU , ( byte ) currentPullup ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } getPinCache ( pin ) . setResistance ( resistance ) ; }
tr	KFC	return	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final TabelProdBrand other = ( TabelProdBrand ) obj ; if ( ! Objects . equals ( this . brandId , other . brandId ) ) { return false ; } return true ; }
tr	SYM	;	@ Override public Schematic rotate ( int direction ) { return HothUtils . rotateSchematic ( direction , this ) ; }
tr	KFC	else	private static String [ ] getFontSearchPath ( ) { String pathProperty = System . getProperty ( "PDFRenderer.fontSearchPath" ) ; if ( pathProperty != null ) { return pathProperty . split ( Pattern . quote ( File . pathSeparator ) ) ; } else { return getDefaultFontSearchPath ( ) ; } }
tr	KEH	try	public boolean addUserContact ( String userId , String contactId ) throws Exception { Connection con = null ; try { con = new Connection ( ) ; return new UserDAO ( con . getDatabase ( ) ) . addContact ( userId , contactId ) ; } catch ( Exception e ) { throw e ; } finally { Connection . tryDisconnect ( con ) ; } }
tr	KPT	int	public boolean hasConsistentReturnUsage ( ) { int n = endCheck ( ) ; return ( n & END_RETURNS_VALUE ) == 0 || ( n & ( END_DROPS_OFF | END_RETURNS | END_YIELDS ) ) == 0 ; }
tr	KMD	public	public void moveX ( double xChange ) { x += xChange ; }
tr	OAR	-	public static void main ( String [ ] args ) { int i = 1234567890 ; float f = i ; System . out . println ( i - ( int ) f ) ; }
tr	SYM	(	private DaemonTest ( ) { }
tr	OAR	-	public int compareTo ( Event e ) { int time2 = e . time ; if ( time != time2 ) return time - time2 ; else { if ( delta < 0 ) return 1 ; else return - 1 ; } }
tr	KFC	else	public JSONObject append ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , new JSONArray ( ) . put ( value ) ) ; } else if ( object instanceof JSONArray ) { this . put ( key , ( ( JSONArray ) object ) . put ( value ) ) ; } else { throw new JSONException ( "JSONObject[" + key + "] is not a JSONArray." ) ; } return this ; }
tr	KFC	return	public static Rule RULE ( final String name ) { return new Rule ( ) { @ Override public Object exec ( GenericMatcher matcher ) { Matcher m = matcher . nextByName ( name ) ; return m == null ? null : m . group ( 0 ) ; } } ; }
tr	SYM	(	@ Override public List < PanelProperty > getPanelProperties ( ) { return properties ; }
tr	KFC	if	public static Run abrir ( ) throws Exception { SimpleDateFormat sdf = new SimpleDateFormat ( "dd/MM/yyyy" ) ; reader = new ObjectInputStream ( new GZIPInputStream ( new FileInputStream ( arq ) ) ) ; Run este ; este = ( Run ) reader . readObject ( ) ; if ( ! sdf . format ( este . dataAnterior ) . equals ( sdf . format ( new Date ( ) ) ) ) { este . contador ++ ; } este . dataAnterior = new Date ( ) ; reader . close ( ) ; return este ; }
tr	KEH	finally	public void editar ( Cargo cargo ) throws NoExisteEntidadException , Exception { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; cargo = em . merge ( cargo ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { long id = cargo . getId ( ) ; if ( encontrarCargo ( id ) == null ) { throw new NoExisteEntidadException ( "No existe el cargo con id " + id ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
tr	SYM	(	void depthFirstSearch ( final Processor < T > processor ) { new DepthFirstSearch < > ( this , processor ) . search ( ) ; }
tr	ORE	<	public Point [ ] getVertexPositions ( ) { int w = 1000 ; double mw = ( ( double ) w ) / 2.0 , qw = ( ( double ) w ) / 4.0 ; Point result [ ] = new Point [ 2 * n + 1 ] ; result [ 2 * n ] = new Point ( ( int ) ( w / 2 ) , ( int ) ( w / 2 ) ) ; double r1 = mw ; double r2 = qw ; double ang = Math . PI * 2.0 / n ; double offset = 0.0 ; if ( ( n % 2 ) == 0 ) offset = ang / 2.0 ; for ( int i = 0 ; i < n ; i ++ ) { double angle = offset + i * ang ; double angle2 = angle + ang / 6 ; result [ i ] = new Point ( ( int ) ( mw + Math . sin ( angle2 ) * r1 ) , ( int ) ( mw - Math . cos ( angle2 ) * r1 ) ) ; result [ n + i ] = new Point ( ( int ) ( mw + Math . sin ( angle ) * r2 ) , ( int ) ( mw - Math . cos ( angle ) * r2 ) ) ; } return result ; }
tr	ORE	<	public Widget getEnterDigit ( String n ) { for ( int i = 110 ; i < 120 ; i ++ ) { if ( widgets . get ( PARENT_ID , i ) . getText ( ) . equals ( n ) ) { return widgets . get ( PARENT_ID , i - 10 ) ; } } return null ; }
tr	KFC	if	private boolean verifyCustomHud ( ) { if ( view . getCmbHud ( ) . getSelectedItem ( ) . equals ( "Custom" ) ) { for ( CustomPath cp : customPaths . getList ( ) ) { customPaths . update ( cp ) ; EnumSet < PathContents > set = cp . getContents ( ) ; if ( cp . isSelected ( ) && set . contains ( PathContents . HUD ) ) { return true ; } } return false ; } else { return true ; } }
tr	SYM	(	public WindowEvents onMouseUp ( MouseButtonEvent e ) { _mouseUp . add ( e ) ; return this ; }
tr	SYM	;	void writeDouble ( double d ) ;
tr	SYM	.	public Billetterie getBilleterie ( ) { return this . billeterie ; }
tr	OAR	-	public void enterMale ( ) { synchronized ( this ) { while ( femaleInLine != - 1 ) { try { this . wait ( ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } maleInLine = Thread . currentThread ( ) . getId ( ) ; while ( femaleEnters != femaleLeaves ) { try { this . wait ( ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } maleEnters ++ ; if ( maleInLine == Thread . currentThread ( ) . getId ( ) ) { maleInLine = - 1 ; this . notifyAll ( ) ; } } }
tr	OLB	&&	@ Override public boolean equals ( Object other ) { return super . equals ( other ) && ( ( Substitution ) other ) . value . equals ( value ) ; }
tr	ORE	<	public ClickPadEventManager ( ClickPad pad , Robot robot ) { super ( ) ; this . pad = pad ; this . robot = robot ; Callable < int [ ] [ ] > switchGetter = new Callable < int [ ] [ ] > ( ) { @ Override public int [ ] [ ] call ( ) throws Exception { return ClickPadEventManager . this . pad . getCodeKeys ( ) ; } } ; Callable < long > delayGetter = new Callable < long > ( ) { @ Override public long call ( ) throws Exception { return ( long ) ClickPadEventManager . this . pad . getDelay ( ) ; } } ; this . typist = new TypistFactory ( ) . createTypist ( robot , pad . getAllCodeKeys ( ) , switchGetter , delayGetter ) ; new PositionFixer ( ) . start ( ) ; }
tr	OAR	-	@ Override public void handle ( int i ) { if ( i == size - 1 ) return ; R [ ] a = this . returnArray . get ( ) ; final T ii = CoreObject . this . adapter . get ( i ) ; final T jj = CoreObject . this . adapter . get ( i + 1 ) ; if ( ii == null || jj == null ) return ; final R out = delta . f ( ii , jj ) ; if ( out == null ) return ; if ( a == null ) { a = updateReturnArray ( ( R [ ] ) Array . newInstance ( out . getClass ( ) , size ) ) ; } a [ i ] = out ; }
tr	SYM	;	public void p_tabs ( ) { int i , k ; if ( tabs < 0 ) tabs = 0 ; if ( tabs == 0 ) return ; i = tabs * indentValue ; for ( k = 0 ; k < i ; k ++ ) { strOut . append ( indentChar ) ; } }
tr	ORE	<	protected void processJoinEvent ( JoinEvent event ) { if ( event != null && _listeners . size ( ) > 0 ) { if ( event . getType ( ) == JoinEvent . EVENT_JOIN ) for ( int i = 0 , size = _listeners . size ( ) ; i < size ; i ++ ) { ( ( RoomEventListener ) _listeners . get ( i ) ) . userJoined ( event ) ; } else for ( int i = 0 , size = _listeners . size ( ) ; i < size ; i ++ ) { ( ( RoomEventListener ) _listeners . get ( i ) ) . userLeft ( event ) ; } } }
tr	OUT	++	public DistributedIncrementor ( ) { for ( int i = 1 ; i <= 5 ; i ++ ) { Thread t = new Thread ( new Worker ( queue ) ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	OUT	++	public Vector AStarSearch ( Agent agent ) { PQ openQ = new PQ ( ) ; Node startNode = new Node ( ) ; startNode . location = startLoc ; startNode . costFromStart = 0 ; startNode . costToGoal = pathCostEstimate ( startLoc , goalLoc , agent ) ; startNode . totalCost = startNode . costFromStart + startNode . costToGoal ; startNode . parent = null ; openQ . add ( startNode ) ; open . put ( startNode . location , startNode ) ; while ( openQ . size ( ) > 0 ) { Node node = openQ . pop ( ) ; open . remove ( node . location ) ; if ( node . location . equals ( goalLoc ) ) { return solve ( node ) ; } else { Vector neighbors = getNeighbors ( node ) ; for ( int i = 0 ; i < neighbors . size ( ) ; i ++ ) { Node newNode = ( Node ) neighbors . elementAt ( i ) ; double newCostEstimate = pathCostEstimate ( newNode . location , goalLoc , agent ) ; double newCost = node . costFromStart + traverseCost ( node , newNode , agent ) ; double newTotal = newCost + newCostEstimate ; Location nnLoc = newNode . location ; Node holderO , holderC ; holderO = ( Node ) open . get ( nnLoc ) ; holderC = ( Node ) closed . get ( nnLoc ) ; if ( holderO != null && holderO . totalCost <= newTotal ) { continue ; } else if ( holderC != null && holderC . totalCost <= newTotal ) { continue ; } else { newNode . parent = node ; newNode . costFromStart = newCost ; newNode . costToGoal = newCostEstimate ; newNode . totalCost = newNode . costFromStart + newNode . costToGoal ; if ( closed . get ( nnLoc ) != null ) { closed . remove ( nnLoc ) ; } Node check = ( Node ) open . get ( nnLoc ) ; if ( check != null ) { openQ . remove ( check ) ; open . remove ( nnLoc ) ; } openQ . add ( newNode ) ; open . put ( nnLoc , newNode ) ; } } closed . put ( node . location , node ) ; } } return null ; }
tr	OLB	&&	@ Override public void beginContact ( Fixture hitFixture , Collection < Hit > hitConstants ) { if ( ! hitConstants . contains ( Hit . ENEMY ) && hitConstants . contains ( Hit . NORMAL_DMG ) ) { int dmg ; if ( hitConstants . contains ( Hit . DMG_HALF ) ) dmg = - 5 ; else dmg = - 10 ; this . body . changeHP ( dmg ) ; } }
tr	OAS	>>=	public static void main ( String [ ] args ) { int x = 4 ; int y = 10 ; long power = x ; long answer = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) { answer *= power ; } y >>= 1 ; power *= power ; } System . out . println ( answer ) ; }
tr	ORE	<	public Object nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case 0 : throw syntaxError ( "Misshaped element" ) ; case < : throw syntaxError ( "Misplaced '<'" ) ; case > : return XML . > ; case / : return XML . / ; case = : return XML . = ; case ! : return XML . ! ; case ? : return XML . QUEST ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( c == 0 ) { throw syntaxError ( "Unterminated string" ) ; } if ( c == q ) { return sb . toString ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } } default : sb = new StringBuffer ( ) ; for ( ; ; ) { sb . append ( c ) ; c = next ( ) ; if ( Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } switch ( c ) { case 0 : return sb . toString ( ) ; case > : case / : case = : case ! : case ? : case [ : case ] : back ( ) ; return sb . toString ( ) ; case < : case " : case ' : throw syntaxError ( "Bad character in a name" ) ; } } } }
tr	KEH	assert	public void testGetMembersWithInsufficientCredits ( ) { addAll ( ) ; boolean rc = map . decrement ( 800 , 50 ) ; assert rc ; List < Address > list = map . getMembersWithInsufficientCredits ( 100 ) ; assert list . isEmpty ( ) ; list = map . getMembersWithInsufficientCredits ( 200 ) ; assert list . isEmpty ( ) ; list = map . getMembersWithInsufficientCredits ( 250 ) ; assert list . size ( ) == 4 ; assert list . contains ( a ) && list . contains ( b ) && list . contains ( c ) && list . contains ( d ) ; map . remove ( b ) ; map . remove ( c ) ; list = map . getMembersWithInsufficientCredits ( 250 ) ; assert list . size ( ) == 2 ; assert list . contains ( a ) && list . contains ( d ) ; map . decrement ( 100 , 50 ) ; map . putIfAbsent ( b ) ; map . putIfAbsent ( c ) ; list = map . getMembersWithInsufficientCredits ( 800 ) ; assert list . size ( ) == 2 ; assert list . contains ( a ) && list . contains ( d ) ; list = map . getMembersWithInsufficientCredits ( 100 ) ; assert list . isEmpty ( ) ; }
tr	ORE	<	@ Override public String run ( ) { long firstNumber = 0 ; boolean found = false ; while ( ! found ) { firstNumber ++ ; for ( int i = 0 ; i < this . getDistinctPrimeFactorCount ( ) ; i ++ ) { if ( ! this . hasRequiredDistinctPrimeFactors ( firstNumber + i ) ) { found = false ; break ; } found = true ; } } return String . valueOf ( firstNumber ) ; }
tr	KEH	try	private void parseFile ( File f ) { try { FileReader fr = new FileReader ( f ) ; BufferedReader br = new BufferedReader ( fr ) ; StringBuilder s = new StringBuilder ( ) ; String tmp = "" ; while ( ( tmp = br . readLine ( ) ) != null ) { s . append ( tmp ) ; } br . close ( ) ; try { json = new JSONObject ( s . toString ( ) ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } catch ( FileNotFoundException e ) { } catch ( IOException e ) { } }
tr	OLB	&&	public String getThumbnailUrl ( String bucketName , String objectKey , int width , int height , boolean signed , int expires ) throws Exception { if ( width <= 0 || height <= 0 ) throw new IllegalArgumentException ( "Illegal parameters" ) ; if ( signed && expires < 0 ) throw new IllegalArgumentException ( "Illegal parameters" ) ; objectKey = EncodingUtils . getUrlEncode ( objectKey ) ; Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( "thumbnail" , null ) ; params . put ( "width" , String . valueOf ( width ) ) ; params . put ( "height" , String . valueOf ( height ) ) ; String unsignedUrl = getUnsignedThumbnailUrl ( bucketName , objectKey , params ) ; if ( ! signed ) return unsignedUrl ; String expTime = String . valueOf ( new Date ( ) . getTime ( ) / 1000 + expires ) ; RequestBuilder requestBuilder = requestFactory . getBuilder ( ) ; requestBuilder = requestBuilder . setMethod ( "GET" ) . setThumbnailHost ( ) . setBucket ( bucketName ) . setObjectKey ( objectKey ) . addHeader ( "Date" , expTime ) ; Request request = requestBuilder . addPamams ( params ) . build ( ) ; String signature = Signature . getSignatureByRequest ( request ) ; signature = URLEncoder . encode ( signature , "UTF-8" ) ; String accessKeyId = request . getCredential ( ) . getAccessKeyId ( ) ; String url = unsignedUrl + "&KSSAccessKeyId=" + accessKeyId + "&Signature=" + signature + "&Expires=" + expTime ; return url ; }
tr	OAR	-	public Cookie getSessionCookie ( HttpSession session , boolean requestIsSecure ) { if ( _handler . isUsingCookies ( ) ) { Cookie cookie = _handler . getSessionManager ( ) . getHttpOnly ( ) ? new HttpOnlyCookie ( SessionManager . __SessionCookie , session . getId ( ) ) : new Cookie ( SessionManager . __SessionCookie , session . getId ( ) ) ; String domain = _handler . getServletContext ( ) . getInitParameter ( SessionManager . __SessionDomain ) ; String maxAge = _handler . getServletContext ( ) . getInitParameter ( SessionManager . __MaxAge ) ; String path = _handler . getServletContext ( ) . getInitParameter ( SessionManager . __SessionPath ) ; if ( path == null ) path = getCrossContextSessionIDs ( ) ? "/" : _handler . getHttpContext ( ) . getContextPath ( ) ; if ( path == null || path . length ( ) == 0 ) path = "/" ; if ( domain != null ) cookie . setDomain ( domain ) ; if ( maxAge != null ) cookie . setMaxAge ( Integer . parseInt ( maxAge ) ) ; else cookie . setMaxAge ( - 1 ) ; cookie . setSecure ( requestIsSecure && getSecureCookies ( ) ) ; cookie . setPath ( path ) ; return cookie ; } return null ; }
tr	KMD	synchronized	public synchronized T next ( ) { return compound . next ( ) ; }
tr	OLB	&&	public boolean canUpdateMeoMeo ( ) { return ( meomeoLevel < meomeoMaximumLevel && candy >= meomeoUpdateCost ) ; }
tr	KEH	try	public void updateAIDice ( Object obj ) { try { final Dice dice = ( Dice ) obj ; new Thread ( ) { public void run ( ) { Random r = new Random ( ) ; Random r1 = new Random ( ) ; try { Thread . sleep ( 2000 + r1 . nextInt ( 12 ) * 150 ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } for ( int i = 0 ; i < 20 ; i ++ ) { die1_ . setIcon ( diePic_ [ r . nextInt ( 6 ) ] ) ; die2_ . setIcon ( diePic_ [ r . nextInt ( 6 ) ] ) ; try { Thread . sleep ( 25 + ( i * 3 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } die1_ . setIcon ( diePic_ [ dice . getDie1 ( ) - 1 ] ) ; die2_ . setIcon ( diePic_ [ dice . getDie2 ( ) - 1 ] ) ; if ( dice . getNumInRowDoubles ( ) == 0 ) { NotificationManager . getInstance ( ) . notifyObservers ( Notification . DICE_ANIMATION_DONE , dice ) ; } else { rollDice_ . setForeground ( Color . red ) ; rollDice_ . setText ( "Roll Again" ) ; NotificationManager . getInstance ( ) . notifyObservers ( Notification . DICE_ANIMATION_DONE , dice ) ; } } } . start ( ) ; } catch ( ClassCastException e ) { System . err . println ( "Dice expected object to method updateDice" ) ; } }
tr	OLB	&&	protected AVLNode removeMaxNode ( AVLNode node ) { if ( node == null ) throw new NoSuchElementException ( "Item does not exist" ) ; else if ( node . right != null ) { node . right = removeMaxNode ( node . right ) ; if ( node . left == null && node . right == null ) node . height = 0 ; else node . height = Math . max ( height ( node . left ) , height ( node . right ) ) + 1 ; if ( Math . abs ( height ( node . right ) - height ( node . left ) ) > 1 ) { if ( height ( node . left . right ) <= height ( node . left . left ) ) node = caseOneRotation ( node ) ; else node = caseTwoRotation ( node ) ; } return node ; } else { if ( node . left == null && node . right == null ) node . height = 0 ; else node . height = Math . max ( height ( node . left ) , height ( node . right ) ) + 1 ; if ( Math . abs ( height ( node . right ) - height ( node . left ) ) > 1 ) { if ( height ( node . left . right ) <= height ( node . left . left ) ) node = caseOneRotation ( node ) ; else node = caseTwoRotation ( node ) ; } return node . left ; } }
tr	KEH	assert	@ Test public void shouldGetProperSizeAfterAddingFiveNode ( ) { HierarchyTreeNode tree = new HierarchyTreeNode ( "TTT" , null ) ; tree . addNode ( "QQQ_1" ) ; tree . addNode ( "QQQ_2" ) ; int size = tree . size ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) tree . addNode ( "QQQ" + i ) ; org . junit . assert . assertEquals ( tree . size ( ) , size + 5 ) ; }
tr	KMD	public	public void invalidateObject ( final Object key , final Object obj ) { synchronized ( lock ) { try { keyedPool . invalidateObject ( key , obj ) ; } catch ( Exception e ) { } } }
tr	OAR	-	@ Override InputStream decorate ( final InputStream wrapped ) throws IOException { byte [ ] peeked = new byte [ 6 ] ; PushbackInputStream pushback = new PushbackInputStream ( wrapped , peeked . length ) ; int headerLength = pushback . read ( peeked ) ; if ( headerLength == - 1 ) { throw new IOException ( "Unable to read the response" ) ; } byte [ ] dummy = new byte [ 1 ] ; Inflater inf = new Inflater ( ) ; try { int n ; while ( ( n = inf . inflate ( dummy ) ) == 0 ) { if ( inf . finished ( ) ) { throw new IOException ( "Unable to read the response" ) ; } if ( inf . needsDictionary ( ) ) { break ; } if ( inf . needsInput ( ) ) { inf . setInput ( peeked ) ; } } if ( n == - 1 ) { throw new IOException ( "Unable to read the response" ) ; } pushback . unread ( peeked , 0 , headerLength ) ; return new InflaterInputStream ( pushback ) ; } catch ( DataFormatException e ) { pushback . unread ( peeked , 0 , headerLength ) ; return new InflaterInputStream ( pushback , new Inflater ( true ) ) ; } }
tr	KFC	return	@ Override protected Object transform ( ParsedInstant pi ) { return InstantUtils . makeCalendar ( pi ) ; }
tr	OLB	||	public EventRegistration getEventRegistration ( Integer registrationId ) { Session session = sessionFactory . openSession ( ) ; Criteria criteria = session . createCriteria ( EventRegistration . class ) ; criteria . setFetchMode ( "event" , FetchMode . EAGER ) ; criteria . setFetchMode ( "payments" , FetchMode . EAGER ) ; criteria . setFetchMode ( "seats" , FetchMode . EAGER ) ; criteria . setFetchMode ( "participant" , FetchMode . EAGER ) ; criteria . add ( Restrictions . = ( "id" , registrationId ) ) ; List results = criteria . list ( ) ; EventRegistration registration = null ; if ( results != null || ! results . isEmpty ( ) ) { registration = ( EventRegistration ) results . get ( 0 ) ; } registration . setHistoryRecords ( getHistoryRecords ( registration . getId ( ) , registration . getType ( ) , session ) ) ; session . close ( ) ; registration . setLocalEventKitStatus ( registration . isEventKit ( ) ) ; return registration ; }
tr	OAS	*=	public static long getTotient ( int n ) { Map < Integer , Integer > map = factor ( n ) ; long phi = 1 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) { phi *= ( entry . getKey ( ) - 1 ) ; } else { phi *= ( ( entry . getKey ( ) - 1 ) * Math . round ( Math . pow ( entry . getKey ( ) , entry . getValue ( ) - 1 ) ) ) ; } } return phi ; }
tr	ORE	<	public static AminoAcidState [ ] toStateArray ( byte [ ] indexArray ) { AminoAcidState [ ] seq = new AminoAcidState [ indexArray . length ] ; for ( int i = 0 ; i < seq . length ; i ++ ) { seq [ i ] = getState ( indexArray [ i ] ) ; } return seq ; }
tr	OUT	++	public void write ( ) { allScores_buf = ByteBuffer . allocateDirect ( allScores . length * 12 ) . order ( ByteOrder . nativeOrder ( ) ) ; for ( int i = 0 , off = 0 ; i < allScores . length ; i ++ , off += 12 ) { allScores [ i ] . setBuffer ( allScores_buf , off ) ; allScores [ i ] . write ( ) ; } backing . putInt ( 8 , allScores . length ) ; putPointer ( backing , 4 , allScores_buf ) ; }
tr	OAS	/=	public static int digits ( int n ) { int i ; int mod ; for ( i = 0 ; n > 0 ; i ++ ) { mod = n % 10 ; n -= mod ; n /= 10 ; } return i ; }
tr	KPT	int	public void actionPerformed ( java . awt . event . ActionEvent evt ) { jRadioButton1Stat . setSelected ( false ) ; jLabel3Stat . setText ( "Day" ) ; String [ ] days = null ; switch ( jComboBox2Stat . getSelectedItem ( ) . toString ( ) ) { case "JAN" : case "MAR" : case "MAY" : case "AUG" : case "JUL" : case "OCT" : case "DEC" : days = new String [ 31 ] ; break ; case "FEB" : days = new String [ 28 ] ; break ; case "APR" : case "JUN" : case "SEP" : case "NOV" : days = new String [ 30 ] ; default : break ; } for ( int i = 0 ; i < days . length ; i ++ ) { days [ i ] = "" + i + 1 + "" ; } jComboBox1Stat . setModel ( new javax . swing . DefaultComboBoxModel ( days ) ) ; }
tr	OAS	&=	public void AddBit ( int bit , int v1 , int v2 ) { if ( bit < 0 || bit > 63 ) return ; long mask = ( ( long ) 1 ) << bit ; this . v1 &= ~ mask ; if ( v1 != 0 ) this . v1 |= mask ; this . v2 &= ~ mask ; if ( v2 != 0 ) this . v2 |= mask ; vmask |= mask ; }
tr	OLB	&&	public void load ( String config ) throws IOException { _config = config ; if ( log . isDebugEnabled ( ) ) log . debug ( "Load " + this + " from " + config ) ; Properties properties = new Properties ( ) ; Resource resource = Resource . newResource ( config ) ; properties . load ( resource . getInputStream ( ) ) ; Iterator iter = properties . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; String username = entry . getKey ( ) . toString ( ) . trim ( ) ; String credentials = entry . getValue ( ) . toString ( ) . trim ( ) ; String roles = null ; int c = credentials . indexOf (   ) ; if ( c > 0 ) { roles = credentials . substring ( c + 1 ) . trim ( ) ; credentials = credentials . substring ( 0 , c ) . trim ( ) ; } if ( username != null && username . length ( ) > 0 && credentials != null && credentials . length ( ) > 0 ) { put ( username , credentials ) ; if ( roles != null && roles . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( roles , "  " ) ; while ( tok . hasMoreTokens ( ) ) addUserToRole ( username , tok . nextToken ( ) ) ; } } } }
tr	OLB	&&	void writeName ( String name , boolean useCompression ) throws IOException { while ( true ) { int n = name . indexOf ( . ) ; if ( n < 0 ) { n = name . length ( ) ; } if ( n <= 0 ) { writeByte ( 0 ) ; return ; } if ( useCompression && USE_DOMAIN_NAME_COMPRESSION ) { Integer offset = ( Integer ) names . get ( name ) ; if ( offset != null ) { int val = offset . intValue ( ) ; if ( val > off ) { logger . log ( Level . WARNING , "DNSOutgoing writeName failed val=" + val + " name=" + name ) ; } writeByte ( ( val >> 8 ) | C0 ) ; writeByte ( val & FF ) ; return ; } names . put ( name , new Integer ( off ) ) ; } writeUTF ( name , 0 , n ) ; name = name . substring ( n ) ; if ( name . startsWith ( "." ) ) { name = name . substring ( 1 ) ; } } }
tr	KPT	boolean	public boolean equals ( Object o ) { if ( ! ( o instanceof BCECPublicKey ) ) { return false ; } BCECPublicKey other = ( BCECPublicKey ) o ; return engineGetQ ( ) . equals ( other . engineGetQ ( ) ) && ( engineGetSpec ( ) . equals ( other . engineGetSpec ( ) ) ) ; }
tr	KEH	finally	@ Override public void ActualizarPartido ( Partido p ) throws Exception { Connection con = null ; PreparedStatement st = null ; ResultSet rs = null ; try { con = DriverManager . getConnection ( URL_CONEXION , NOMBRE_USUARIO_BASE_DATOS , CONTRASENA_BASE_DATOS ) ; st = con . prepareStatement ( " UPDATE partido set Fecha = ?   Ciudad = ?  " + " IdFase = ?  NombreEquipo1 = ?   NombreEquipo2 = ?  " + " GolesEquipo1 = ?  GolesEquipo2 = ?  FechaHoraInicio = ?  " + " FechaHoraFin = ?  Confirmado = ? " ) ; st . setDate ( 1 , ( java . sql . Date ) p . getFecha ( ) ) ; st . setString ( 2 , p . getSede ( ) . getCiudad ( ) ) ; st . setInt ( 3 , p . getFase ( ) . getIdFase ( ) ) ; st . setString ( 4 , p . getEquipos ( ) [ 0 ] . getNombre ( ) ) ; st . setString ( 5 , p . getEquipos ( ) [ 1 ] . getNombre ( ) ) ; st . setInt ( 6 , p . getGolesEquipo1 ( ) ) ; st . setInt ( 7 , p . getGolesEquipo2 ( ) ) ; st . setDate ( 8 , ( java . sql . Date ) p . getHoraInicio ( ) ) ; st . setDate ( 9 , ( java . sql . Date ) p . getHoraFin ( ) ) ; st . setBoolean ( 10 , p . isConfirmado ( ) ) ; int rowsModified = st . executeUpdate ( ) ; } catch ( Exception ex ) { throw ex ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( st != null ) { st . close ( ) ; } if ( con != null ) { con . close ( ) ; } } catch ( Exception ex ) { } } }
tr	OAR	-	public static void main ( String [ ] args ) { NumberOfIslands instance = new SolutionIV ( ) ; char [ ] [ ] grid ; grid = ArrayUtil . strArrayTo2DCharArray ( new String [ ] { "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111" } ) ; long t1 = System . currentTimeMillis ( ) ; int result = instance . numIslands ( grid ) ; long t2 = System . currentTimeMillis ( ) ; System . out . println ( "result=" + result ) ; System . out . println ( String . format ( "total time=% dms" , ( t2 - t1 ) ) ) ; }
tr	ORE	>=	public static byte [ ] inputStreamToByteArray ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 2048 ] ; int length = 0 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( ( length = in . read ( buffer ) ) >= 0 ) { baos . write ( buffer , 0 , length ) ; } return baos . toByteArray ( ) ; }
tr	ORE	<	@ Override public void drop ( DropTargetDropEvent dtde ) { try { Transferable tr = dtde . getTransferable ( ) ; DataFlavor [ ] flavors = tr . getTransferDataFlavors ( ) ; for ( int i = 0 ; i < flavors . length ; i ++ ) { if ( flavors [ i ] . isFlavorJavaFileListType ( ) || flavors [ i ] . isFlavorTextType ( ) ) { dtde . acceptDrop ( DnDConstants . ACTION_COPY_OR_MOVE ) ; Object data = tr . getTransferData ( flavors [ i ] ) ; if ( data instanceof List ) { List list = ( List ) data ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { if ( list . get ( j ) instanceof File && Playlist . isPlaylist ( ( File ) list . get ( j ) ) ) { openPlaylist ( ( File ) list . get ( j ) ) ; } } } else if ( data instanceof InputStreamReader ) { InputStreamReader list = ( InputStreamReader ) data ; BufferedReader temp = new BufferedReader ( list ) ; String filePath = temp . readLine ( ) ; while ( filePath != null && ! filePath . isEmpty ( ) ) { openPlaylist ( new File ( new URI ( filePath ) ) ) ; filePath = temp . readLine ( ) ; } temp . close ( ) ; list . close ( ) ; } dtde . dropComplete ( true ) ; return ; } } dtde . rejectDrop ( ) ; } catch ( Exception e ) { _logger . warn ( ExStack . toString ( e ) ) ; dtde . rejectDrop ( ) ; } }
tr	OLB	||	public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Body body = ( Body ) o ; if ( langauge != null ? ! langauge . equals ( body . langauge ) : body . langauge != null ) { return false ; } return message . equals ( body . message ) ; }
tr	KMD	public	@ Override public void windowClosing ( WindowEvent event ) { handleExitConfirmation ( ) ; }
tr	KFC	if	public static int executeUpdate ( String update , boolean returnKeyExpected ) throws SQLException { Statement stat = conn . createStatement ( ) ; if ( returnKeyExpected ) { try { long key ; stat . executeUpdate ( update ) ; ResultSet rs = stat . executeQuery ( "SELECT last_insert_rowid()" ) ; if ( rs . next ( ) ) { key = rs . getLong ( 1 ) ; } else key = 0 ; stat . close ( ) ; return key . intValue ( ) ; } catch ( SQLException e ) { throw new SQLException ( e . getMessage ( ) ) ; } } else { try { int ret = stat . executeUpdate ( update ) ; stat . close ( ) ; return ret ; } catch ( SQLException e ) { throw new SQLException ( "Failed to execute Database Update2." ) ; } } }
tr	KEH	try	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Windows" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( HlavnyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( HlavnyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( HlavnyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( HlavnyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new HlavnyForm ( ) . setVisible ( true ) ; } } ) ; }
tr	OAS	*=	public double getSentenceProbability ( List < String > sentence ) { List < String > stoppedSentence = new ArrayList < String > ( sentence ) ; stoppedSentence . add ( STOP ) ; double probability = 1.0 ; for ( int index = 0 ; index < stoppedSentence . size ( ) ; index ++ ) { probability *= getWordProbability ( stoppedSentence , index ) ; } return probability ; }
tr	OLB	&&	public static void main ( String [ ] args ) throws IOException { Gson gson = new Gson ( ) ; final FileReader reader = new FileReader ( "ufo_awesome.json" ) ; final SightingList list = gson . fromJson ( reader , SightingList . class ) ; Map < String , List < Sighting >> map = new HashMap < > ( ) ; for ( Sighting s : list ) { String location = s . getLocation ( ) ; List < Sighting > sightings = map . get ( location ) ; if ( sightings == null ) { sightings = new ArrayList < Sighting > ( ) ; } sightings . add ( s ) ; map . put ( location , sightings ) ; } ZipCodes zip = new ZipCodes ( ) ; ArrayList < ZipCode > codes = ( ArrayList < ZipCode > ) zip . getZipCodes ( ) ; for ( Sighting s : list ) { if ( "19950115" . equals ( s . getSightedAt ( ) ) ) { String location = s . getLocation ( ) ; String delims = "[ ]" ; String [ ] tokens = location . split ( delims ) ; for ( ZipCode z : codes ) { if ( tokens [ 0 ] . trim ( ) . toUpperCase ( ) . equals ( z . getCity ( ) . trim ( ) ) && tokens [ 1 ] . trim ( ) . toUpperCase ( ) . equals ( z . getState ( ) . trim ( ) ) ) { System . out . println ( z . getZip ( ) ) ; } } } } }
tr	OAR	-	final public Expression Expression ( ) throws ParseException { Expression retval = null ; if ( jj_2_12 ( 2147483647 ) ) { retval = OrExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 91 : jj_consume_token ( 91 ) ; retval = Expression ( ) ; jj_consume_token ( 92 ) ; retval = new Parenthesis ( retval ) ; break ; default : jj_la1 [ 84 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } { if ( true ) return retval ; } throw new Error ( "Missing return statement in function" ) ; }
tr	SYM	;	private void paintShapeNode_0_0_0_1_0 ( Graphics2D g ) { GeneralPath shape1 = new GeneralPath ( ) ; shape1 . moveTo ( 243.41275 , 601.7208 ) ; shape1 . curveTo ( 243.41275 , 601.7208 , 251.7242 , 482.15768 , 297.14368 , 457.7835 ) ; shape1 . curveTo ( 330.8001 , 439.72192 , 375.76263 , 432.21555 , 435.38806 , 454.83856 ) ; shape1 . curveTo ( 486.48105 , 474.2242 , 491.35098 , 601.7208 , 491.35098 , 601.7208 ) ; shape1 . closePath ( ) ; g . setPaint ( new Color ( 153 , 153 , 153 , 255 ) ) ; g . fill ( shape1 ) ; g . setPaint ( new Color ( 0 , 0 , 0 , 255 ) ) ; g . setStroke ( new BasicStroke ( 2.7f , 0 , 0 , 4.0f , null , 0.0f ) ) ; g . draw ( shape1 ) ; }
tr	OLB	&&	@ Override public boolean agregar ( T t ) { NodoListaOrdenada < T > agregando = new NodoListaOrdenada < T > ( t ) ; boolean agrego = false ; if ( primero == null ) { primero = agregando ; ultimo = agregando ; agrego = true ; longitud ++ ; } else { NodoListaOrdenada < T > actual = primero ; if ( agregando . getElemento ( ) . getElemento ( ) . compareTo ( primero . getElemento ( ) . getElemento ( ) ) == - 1 ) { agregando . cambiarSiguiente ( actual ) ; primero = agregando ; agrego = true ; longitud ++ ; } else { while ( actual . getSiguiente ( ) != null && ! agrego ) { if ( agregando . getElemento ( ) . getElemento ( ) . compareTo ( actual . getSiguiente ( ) . getElemento ( ) . getElemento ( ) ) == - 1 ) { agregando . cambiarSiguiente ( actual . getSiguiente ( ) ) ; actual . cambiarSiguiente ( agregando ) ; agrego = true ; longitud ++ ; } agrego = true ; } actual = actual . getSiguiente ( ) ; } } return agrego ; }
tr	ORE	<	private void populateMap ( Object bean ) { class klass = bean . getClass ( ) ; boolean includeSuperClass = klass . getClassLoader ( ) != null ; Method [ ] methods = includeSuperClass ? klass . getMethods ( ) : klass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i += 1 ) { try { Method method = methods [ i ] ; if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { String name = method . getName ( ) ; String key = "" ; if ( name . startsWith ( "get" ) ) { if ( "getClass" . equals ( name ) || "getDeclaringClass" . equals ( name ) ) { key = "" ; } else { key = name . substring ( 3 ) ; } } else if ( name . startsWith ( "is" ) ) { key = name . substring ( 2 ) ; } if ( key . length ( ) > 0 && Character . isUpperCase ( key . charAt ( 0 ) ) && method . getParameterTypes ( ) . length == 0 ) { if ( key . length ( ) == 1 ) { key = key . toLowerCase ( ) ; } else if ( ! Character . isUpperCase ( key . charAt ( 1 ) ) ) { key = key . substring ( 0 , 1 ) . toLowerCase ( ) + key . substring ( 1 ) ; } Object result = method . invoke ( bean , ( Object [ ] ) null ) ; if ( result != null ) { this . map . put ( key , wrap ( result ) ) ; } } } } catch ( Exception ignore ) { } } }
tr	OAR	-	public synchronized final void close ( ) { if ( ! open ) { return ; } if ( Prolog . thread_self ( ) == - 1 ) { throw new JPLException ( "no engine is attached to this thread" ) ; } if ( Prolog . current_engine ( ) . value != engine . value ) { throw new JPLException ( "this Query's engine is not that which is attached to this thread" ) ; } Query topmost = m . get ( new long ( engine . value ) ) ; if ( topmost != this ) { throw new JPLException ( "this Query (" + this . hashCode ( ) + ":" + this . toString ( ) + ") is not topmost (" + topmost . hashCode ( ) + ":" + topmost . toString ( ) + ") within its engine[" + engine . value + "]" ) ; } Prolog . close_query ( qid ) ; qid = null ; org . jpl7 . fli . Prolog . discard_foreign_frame ( fid ) ; fid = null ; m . remove ( new long ( engine . value ) ) ; if ( subQuery == null ) { if ( Prolog . current_engine_is_pool ( ) ) { Prolog . release_pool_engine ( ) ; } else { } } else { m . put ( new long ( engine . value ) , subQuery ) ; } open = false ; engine = null ; subQuery = null ; }
tr	ORE	<	private static String writeZipFile ( File directoryToZip , List < File > fileList , String zipName ) throws IOException { if ( zipName == null ) { zipName = directoryToZip . getName ( ) ; } String fileName = zipName ; FileOutputStream fos = new FileOutputStream ( fileName ) ; ZipOutputStream zos = new ZipOutputStream ( fos ) ; for ( File file : fileList ) { if ( ! file . isDirectory ( ) ) { addToZip ( directoryToZip , file , zos ) ; } } zos . close ( ) ; fos . close ( ) ; return fileName ; }
tr	KPT	boolean	public boolean isPaused ( ) { return clip . isPaused ( ) ; }
tr	OUT	++	void luinverse ( double [ ] [ ] inmat , double [ ] [ ] imtrx , int size ) throws IllegalArgumentException { int i , j , k , l , maxi = 0 , idx , ix , jx ; double sum , tmp , maxb , aw ; int [ ] index ; double [ ] wk ; double [ ] [ ] omtrx ; index = new int [ size ] ; omtrx = new double [ size ] [ size ] ; for ( i = 0 ; i < size ; i ++ ) { for ( j = 0 ; j < size ; j ++ ) { omtrx [ i ] [ j ] = inmat [ i ] [ j ] ; } } wk = new double [ size ] ; aw = 1.0 ; for ( i = 0 ; i < size ; i ++ ) { maxb = 0.0 ; for ( j = 0 ; j < size ; j ++ ) { if ( Math . abs ( omtrx [ i ] [ j ] ) > maxb ) { maxb = Math . abs ( omtrx [ i ] [ j ] ) ; } } if ( maxb == 0.0 ) { System . out . println ( "Singular matrix encountered" ) ; throw new IllegalArgumentException ( "Singular matrix" ) ; } wk [ i ] = 1.0 / maxb ; } for ( j = 0 ; j < size ; j ++ ) { for ( i = 0 ; i < j ; i ++ ) { sum = omtrx [ i ] [ j ] ; for ( k = 0 ; k < i ; k ++ ) { sum -= omtrx [ i ] [ k ] * omtrx [ k ] [ j ] ; } omtrx [ i ] [ j ] = sum ; } maxb = 0.0 ; for ( i = j ; i < size ; i ++ ) { sum = omtrx [ i ] [ j ] ; for ( k = 0 ; k < j ; k ++ ) { sum -= omtrx [ i ] [ k ] * omtrx [ k ] [ j ] ; } omtrx [ i ] [ j ] = sum ; tmp = wk [ i ] * Math . abs ( sum ) ; if ( tmp >= maxb ) { maxb = tmp ; maxi = i ; } } if ( j != maxi ) { for ( k = 0 ; k < size ; k ++ ) { tmp = omtrx [ maxi ] [ k ] ; omtrx [ maxi ] [ k ] = omtrx [ j ] [ k ] ; omtrx [ j ] [ k ] = tmp ; } aw = - aw ; wk [ maxi ] = wk [ j ] ; } index [ j ] = maxi ; if ( omtrx [ j ] [ j ] == 0.0 ) { omtrx [ j ] [ j ] = EPSILON ; } if ( j != size - 1 ) { tmp = 1.0 / omtrx [ j ] [ j ] ; for ( i = j + 1 ; i < size ; i ++ ) { omtrx [ i ] [ j ] *= tmp ; } } } for ( jx = 0 ; jx < size ; jx ++ ) { for ( ix = 0 ; ix < size ; ix ++ ) { wk [ ix ] = 0.0 ; } wk [ jx ] = 1.0 ; l = - 1 ; for ( i = 0 ; i < size ; i ++ ) { idx = index [ i ] ; sum = wk [ idx ] ; wk [ idx ] = wk [ i ] ; if ( l != - 1 ) { for ( j = l ; j < i ; j ++ ) { sum -= omtrx [ i ] [ j ] * wk [ j ] ; } } else if ( sum != 0.0 ) { l = i ; } wk [ i ] = sum ; } for ( i = size - 1 ; i >= 0 ; i -- ) { sum = wk [ i ] ; for ( j = i + 1 ; j < size ; j ++ ) { sum -= omtrx [ i ] [ j ] * wk [ j ] ; } wk [ i ] = sum / omtrx [ i ] [ i ] ; } for ( ix = 0 ; ix < size ; ix ++ ) { imtrx [ ix ] [ jx ] = wk [ ix ] ; } } wk = null ; index = null ; omtrx = null ; }
tr	KMD	public	public Sequence ( int size ) { items = new ArrayList < Object > ( size ) ; }
tr	OLB	&&	public List < String > getSelectedElements ( ) { List < CyNode > nodes = CyTableUtil . getNodesInState ( network , CyNetwork . SELECTED , true ) ; List < CyEdge > edges = CyTableUtil . getEdgesInState ( network , CyNetwork . SELECTED , true ) ; if ( nodes . size ( ) == 1 && edges . isEmpty ( ) ) { CyNode node = nodes . get ( 0 ) ; String nodeGOTerm = network . getRow ( node ) . get ( GOTermColumn , String . class ) ; if ( Unknown . equals ( nodeGOTerm ) || Unnanotated . equals ( nodeGOTerm ) ) { return null ; } return Arrays . asList ( network . getRow ( node ) . get ( CyNetwork . NAME , String . class ) ) ; } else if ( nodes . isEmpty ( ) && edges . size ( ) == 1 ) { CyEdge edge = edges . get ( 0 ) ; CyRow sourceRow = network . getRow ( edge . getSource ( ) ) ; CyRow targetRow = network . getRow ( edge . getTarget ( ) ) ; String sourceGOTerm = sourceRow . get ( GOTermColumn , String . class ) ; String targetGOTerm = targetRow . get ( GOTermColumn , String . class ) ; if ( Unknown . equals ( sourceGOTerm ) || Unnanotated . equals ( sourceGOTerm ) || Unknown . equals ( targetGOTerm ) || Unnanotated . equals ( targetGOTerm ) ) { return null ; } return Arrays . asList ( sourceRow . get ( CyNetwork . NAME , String . class ) , targetRow . get ( CyNetwork . NAME , String . class ) ) ; } return null ; }
tr	SYM	;	@ XmlElement ( name = "uri" ) public String getUri ( ) { return uri ; }
tr	OUT	++	private void parseAndLoadInputs ( String inputs ) throws Exception { String inputTokens [ ] = inputs . split ( "\\s+" ) ; for ( int i = 0 ; i < inputTokens . length ; i ++ ) { String token = inputTokens [ i ] ; if ( token . equals ( "" ) ) { continue ; } else if ( token . equals ( "true" ) ) { _interpreter . boolStack ( ) . push ( true ) ; _interpreter . inputStack ( ) . push ( true ) ; } else if ( token . equals ( "false" ) ) { _interpreter . boolStack ( ) . push ( false ) ; _interpreter . inputStack ( ) . push ( false ) ; } else if ( token . matches ( "((-|\\+)?[0-9]+(\\.[0-9]+)?)+" ) ) { if ( token . indexOf ( . ) != - 1 ) { _interpreter . floatStack ( ) . push ( float . parseFloat ( token ) ) ; _interpreter . inputStack ( ) . push ( float . parseFloat ( token ) ) ; } else { _interpreter . intStack ( ) . push ( Integer . parseInt ( token ) ) ; _interpreter . inputStack ( ) . push ( Integer . parseInt ( token ) ) ; } } else { throw new Exception ( "Inputs must be of type int  float  or boolean. \"" + token + "\" is none of these." ) ; } } }
tr	KEH	try	public static void main ( final String [ ] args ) { File rsbot = null ; if ( RSBOT_DICTIONARY != null ) rsbot = new File ( RSBOT_DICTIONARY ) ; else { final List < File > possible = getContent ( new File ( "./" ) ) ; if ( possible != null && possible . size ( ) > 0 ) { for ( final File file : possible ) if ( file != null && file . exists ( ) && file . isFile ( ) ) { final String name = file . getName ( ) . toLowerCase ( ) ; if ( name . contains ( "rsbot" ) && name . endsWith ( ".jar" ) ) { rsbot = file ; break ; } } } } logger . setUseParentHandlers ( false ) ; final ConsoleHandler handler = new ConsoleHandler ( ) ; handler . setFormatter ( new Formatter ( ) { private final DateFormat df = new SimpleDateFormat ( "hh:mm:ss" ) ; @ Override public String format ( final LogRecord record ) { final StringBuilder builder = new StringBuilder ( ) ; final String [ ] source = record . getSourceClassName ( ) . split ( "\\$" ) ; builder . append ( "[" ) . append ( df . format ( new Date ( record . getMillis ( ) ) ) ) . append ( "]" ) ; builder . append ( "[" ) . append ( source [ source . length - 1 ] ) . append ( "" ) ; builder . append ( record . getSourceMethodName ( ) ) . append ( "] " ) ; builder . append ( super . formatMessage ( record ) ) . append ( "\n" ) ; return builder . toString ( ) ; } } ) ; logger . addHandler ( handler ) ; if ( rsbot != null && rsbot . exists ( ) ) { logger . info ( "Located RSBot  retrieving class files." ) ; URLClassLoader loader = null ; try { loader = URLClassLoader . newInstance ( new URL [ ] { rsbot . toURI ( ) . toURL ( ) } ) ; } catch ( final MalformedURLException e ) { e . printStackTrace ( ) ; } if ( loader == null ) { logger . severe ( "Unable to load RSBot  stopping." ) ; } else { if ( getRSBotClasses ( rsbot , loader ) ) { logger . info ( "Loaded all of the necessary RSBot classes." ) ; logger . info ( "Running RSBot..." ) ; try { final class < ? > mainClazz = loader . loadClass ( "org.powerbot.Boot" ) ; if ( mainClazz != null ) { final Method mainMethod = mainClazz . getDeclaredMethod ( "main" , String [ ] . class ) ; if ( mainMethod != null ) { mainMethod . setAccessible ( true ) ; mainMethod . invoke ( null , ( Object ) new String [ ] { } ) ; } } } catch ( final ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e ) { e . printStackTrace ( System . err ) ; logger . severe ( "Unable to start RSBot  stopping." ) ; return ; } try { final Method getCanvas = Reflect . getMethod ( Canvas , Canvas ) ; final Object canvas = getCanvas . invoke ( null ) ; if ( canvas != null ) { final Field getToolbar = Reflect . getField ( canvas . getClass ( ) , Toolbar ) ; final Object toolbar = getToolbar . get ( canvas ) ; for ( final Field field : toolbar . getClass ( ) . getDeclaredFields ( ) ) { if ( field . getType ( ) != null && JLabel . class . isAssignableFrom ( field . getType ( ) ) && MouseListener . class . isAssignableFrom ( field . getType ( ) ) ) { field . setAccessible ( true ) ; final JLabel label = ( JLabel ) field . get ( toolbar ) ; if ( label != null && label . getToolTipText ( ) != null && label . getToolTipText ( ) . toLowerCase ( ) . contains ( "script" ) ) { for ( final MouseListener ml : label . getMouseListeners ( ) ) label . removeMouseListener ( ml ) ; label . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( final MouseEvent e ) { new ScriptListener ( e . getWhen ( ) , "ScriptListener" , null , null ) . start ( ) ; } } ) ; label . addMouseListener ( ( MouseListener ) label ) ; logger . info ( "RSBot successfully loaded. ScriptInjector has officially started." ) ; break ; } } } } } catch ( final IllegalAccessException | InvocationTargetException e ) { e . printStackTrace ( System . err ) ; } } else logger . severe ( "Unable to load all of RSBots needed class files  stopping." ) ; } } else { logger . severe ( "Unable to locate RSBot.jar  please specify a dictionary in the ScriptInjector class." ) ; } }
tr	KMD	public	public void declinerPeuple ( Peuple peupleADecliner ) { setPeuplesDeclin ( peupleADecliner ) ; setPeuple ( null ) ; }
tr	KMD	public	public SkillActionDescriptionCraft ( short skillId , byte maxSlots , byte probability ) { super ( skillId ) ; this . maxSlots = maxSlots ; this . probability = probability ; }
tr	OLB	||	public boolean interactingWith ( Player player , Entity victm ) { return player == victm || player == source ; }
tr	KMD	public	public DefaultInferenceWorkerSynch ( CycList query , ELMt mt , InferenceParameters queryProperties , Map nlGenerationProperties , CycSymbol answerProcessingFunction , boolean optimizeVariables , CycAccess access , long timeoutMsecs , Integer priority ) { super ( query , mt , queryProperties , nlGenerationProperties , answerProcessingFunction , optimizeVariables , access , timeoutMsecs , priority ) ; init ( ) ; }
tr	KEH	try	public UType [ ] findByDynamicWhere ( String sql , Object [ ] sqlParams ) throws UTypeDaoException { final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; final String SQL = SQL_SELECT + " WHERE " + sql ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL ) ; } stmt = conn . prepareStatement ( SQL ) ; stmt . setMaxRows ( maxRows ) ; for ( int i = 0 ; sqlParams != null && i < sqlParams . length ; i ++ ) { stmt . setObject ( i + 1 , sqlParams [ i ] ) ; } rs = stmt . executeQuery ( ) ; return fetchMultiResults ( rs ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( rs ) ; ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	KEH	assert	public Fst toFst ( ) { Fst openFst = new Fst ( ring ) ; openFst . setIsyms ( inputAlphabet . toSymbols ( ) ) ; openFst . setOsyms ( outputAlphabet . toSymbols ( ) ) ; openFstStates = new ArrayList < edu . cmu . sphinx . fst . State > ( states . size ( ) ) ; for ( State state : states ) { edu . cmu . sphinx . fst . State openFstState = state . toUnconnectedOpenFstState ( ) ; openFst . addState ( openFstState ) ; assert openFstState . getId ( ) == state . id ; openFstStates . add ( openFstState ) ; } openFst . setStart ( openFstStates . get ( 0 ) ) ; for ( State state : states ) { state . connectStates ( openFstStates ) ; } return openFst ; }
tr	OAR	/	public static float SinAngle ( float a , float b ) { return ( float ) Math . asin ( a / b ) ; }
tr	KPT	int	int ReverseBitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; int j = 0 ; for ( int k = 0 ; k < paramInt2 ; k ++ ) { int m = BitDecode ( paramArrayOfInt , paramInt1 + i ) ; i = i + i + m ; j |= m << k ; } return j ; }
tr	OAR	-	public String getSequenceMatrixString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( seqMatrix == null ) { builder . append ( "Sequence matrix is NULL.\n" ) ; } else { for ( int i = 0 ; i < seqMatrix . length ; i ++ ) { int length = seqMatrix [ i ] . length ; for ( int j = 0 ; j < length ; j ++ ) { Set < String > set = seqMatrix [ i ] [ j ] ; builder . append ( set . toString ( ) ) ; if ( j < length - 1 ) builder . append ( "  " ) ; } builder . append ( "\n" ) ; } } return builder . toString ( ) ; }
tr	OUT	++	public static void main ( String [ ] args ) throws IOException { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; tokenizer = new StringTokenizer ( "" ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( out ) ) ) ; String pattern = next ( ) ; String text = next ( ) ; if ( text . length ( ) < pattern . length ( ) ) { pw . println ( "No Match" ) ; } int pow = 1 ; for ( int i = 1 ; i < pattern . length ( ) ; i ++ ) { pow = ( pow * SEED_PRIME ) % PRIME ; } int patternHash = hash ( pattern , pattern . length ( ) ) ; int textHash = hash ( text , pattern . length ( ) ) ; if ( ( patternHash == textHash ) && verify ( text , pattern , 0 ) ) pw . println ( "Match found at " + 0 ) ; for ( int i = pattern . length ( ) ; i < text . length ( ) ; i ++ ) { textHash = ( textHash + PRIME - pow * text . charAt ( i - pattern . length ( ) ) % PRIME ) % PRIME ; textHash = ( textHash * SEED_PRIME + text . charAt ( i ) ) % PRIME ; int offset = i - pattern . length ( ) + 1 ; if ( ( patternHash == textHash ) && verify ( text , pattern , offset ) ) pw . println ( "Match found at " + offset ) ; } reader . close ( ) ; pw . close ( ) ; }
tr	OAS	/=	public double getCurvatureStdDev ( ) { double variance = 0 ; double mu = getAverageCurvature ( ) ; for ( BezierPoint point : curvePoints ) variance += ( point . k - mu ) * ( point . k - mu ) ; variance /= curvePoints . size ( ) - 1 ; return Math . sqrt ( variance ) ; }
tr	OAS	<<=	void increaseCapacity ( ) { if ( size >= capacity ) { capacity <<= 1 ; T [ ] tmp = newArray ( ) ; System . arraycopy ( array , 0 , tmp , 0 , size ) ; array = tmp ; } }
tr	KMD	public	public String getCustomText53 ( ) { return customText53 ; }
tr	OAR	-	public double getAgentMaxY ( ) { return this . getEnvironmentHeight ( ) - this . agentHeight / 2.0 ; }
tr	KPT	int	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( displayType == null ) ? 0 : displayType . hashCode ( ) ) ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( ( status == null ) ? 0 : status . hashCode ( ) ) ; result = prime * result + ( ( url == null ) ? 0 : url . hashCode ( ) ) ; return result ; }
tr	SYM	;	public void GetParam ( char [ ] buffer ) { char c ; int ptr = 0 ; while ( this . sequence [ ptr ++ ] != 1 ) ; int bptr = 0 ; do { c = this . sequence [ ptr ] ; buffer [ bptr ++ ] = c ; this . sequence [ ptr ++ ] = 0 ; } while ( ( c != 0 ) && ( this . sequence [ ptr ] != ff ) ) ; if ( this . sequence [ ptr ] == ff ) buffer [ bptr ] = 0 ; }
tr	OAS	*=	private int hash2 ( int h ) { h *= PRIME2 ; return ( h ^ h >>> hashShift ) & mask ; }
tr	KFC	return	public List < Object > getFactors ( ) { return factors ; }
tr	ORE	<	public MethodGenerator newMethodPairWithOverride ( JType returnJType , String name , ImmutableList < JParam > jParams ) { MethodGenerator metR = newMethod ( JRUNNABLE , name , jParams ) ; metR . addOverride ( ) ; MethodGenerator met = newMethod ( returnJType , name , jParams ) ; met . addOverride ( ) ; return met ; }
tr	OLB	||	public static boolean isBlank ( String s ) { return isEmptyOrNull ( s ) || s . trim ( ) . length ( ) == 0 ; }
tr	OUT	~	public final Qualified_joinContext qualified_join ( ) throws RecognitionException { Qualified_joinContext _localctx = new Qualified_joinContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 238 , RULE_qualified_join ) ; int _la ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 1234 ) ; _la = _input . LA ( 1 ) ; if ( ( ( ( _la ) & ~ 3f ) == 0 && ( ( 1 << _la ) & ( ( 1 << FULL ) | ( 1 << INNER ) | ( 1 << LEFT ) | ( 1 << RIGHT ) ) ) != 0 ) ) { { setState ( 1233 ) ; ( ( Qualified_joinContext ) _localctx ) . t = join_type ( ) ; } } setState ( 1236 ) ; match ( JOIN ) ; setState ( 1237 ) ; ( ( Qualified_joinContext ) _localctx ) . r = table_primary ( ) ; setState ( 1238 ) ; ( ( Qualified_joinContext ) _localctx ) . s = join_specification ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	KPT	boolean	public void setInvalidEndWith ( boolean invalidEndWith ) { this . invalidEndWith = invalidEndWith ; }
tr	KFC	return	public ArrayClassInSuite [ ] getAllArrayClasses ( ) { LinkedList < ArrayClassInSuite > l = new LinkedList < ArrayClassInSuite > ( ) ; for ( ClassInSuite cis : aClasses . values ( ) ) { if ( cis instanceof ArrayClassInSuite ) { l . add ( ( ArrayClassInSuite ) cis ) ; } } return l . toArray ( new ArrayClassInSuite [ l . size ( ) ] ) ; }
tr	KPT	int	void testBit ( int input , int bit ) { int temp = 1 << bit ; input = input & temp ; if ( input == 0 ) { System . out . println ( "Bit at\t" + bit + "\t is 0" ) ; } else { System . out . println ( "Bit at\t" + bit + "\t is 1" ) ; } }
tr	SYM	)	public void Done ( ) ;
tr	KEH	try	public final RelationalExpressionContext relationalExpression ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; RelationalExpressionContext _localctx = new RelationalExpressionContext ( _ctx , _parentState , _p ) ; RelationalExpressionContext _prevctx = _localctx ; int _startState = 52 ; enterRecursionRule ( _localctx , RULE_relationalExpression ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { { setState ( 377 ) ; ( ( RelationalExpressionContext ) _localctx ) . a = additiveExpression ( 0 ) ; ( ( RelationalExpressionContext ) _localctx ) . lval = ( ( RelationalExpressionContext ) _localctx ) . a . lval ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 392 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 18 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 390 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 17 , _ctx ) ) { case 1 : { _localctx = new RelationalExpressionContext ( _parentctx , _parentState , _p ) ; _localctx . l = _prevctx ; pushNewRecursionContext ( _localctx , _startState , RULE_relationalExpression ) ; setState ( 380 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 381 ) ; match ( LESS ) ; setState ( 382 ) ; ( ( RelationalExpressionContext ) _localctx ) . r = additiveExpression ( 0 ) ; ( ( RelationalExpressionContext ) _localctx ) . lval = buildBinaryOperator ( loc ( _localctx . start ) , Binop . LESS , ( ( RelationalExpressionContext ) _localctx ) . l . lval , ( ( RelationalExpressionContext ) _localctx ) . r . lval ) ; } break ; case 2 : { _localctx = new RelationalExpressionContext ( _parentctx , _parentState , _p ) ; _localctx . l = _prevctx ; pushNewRecursionContext ( _localctx , _startState , RULE_relationalExpression ) ; setState ( 385 ) ; if ( ! ( 1 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "1 >= $_p" ) ; setState ( 386 ) ; match ( GREATER ) ; setState ( 387 ) ; ( ( RelationalExpressionContext ) _localctx ) . r = additiveExpression ( 0 ) ; ( ( RelationalExpressionContext ) _localctx ) . lval = buildBinaryOperator ( loc ( _localctx . start ) , Binop . GREATER , ( ( RelationalExpressionContext ) _localctx ) . l . lval , ( ( RelationalExpressionContext ) _localctx ) . r . lval ) ; } break ; } } } setState ( 394 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 18 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
tr	OAR	-	@ Override public boolean cancelResearvation ( int rowNum , Column column ) throws UnsupportedOperationException { if ( ! isInitialized ) { throw new NullPointerException ( "Passenger List has not been initialized" ) ; } if ( rowNum < 0 || rowNum > passengerList . size ( ) ) { throw new IndexOutOfBoundsException ( "The row# is out of bound" ) ; } if ( column . index ( ) < 0 || column . index ( ) > passengerList . get ( 0 ) . size ( ) ) { throw new IndexOutOfBoundsException ( "The column# is out of bound" ) ; } List < Passenger > _passenger = passengerList . get ( rowNum - 1 ) ; if ( _passenger . get ( column . index ( ) - 1 ) != null ) { _passenger . set ( column . index ( ) - 1 , null ) ; return true ; } return false ; }
tr	OLB	&&	private void addPalindromes ( String s , int idx ) { int l = idx , r = idx + 1 ; while ( l >= 0 && r < s . length ( ) && s . charAt ( l ) == s . charAt ( r ) ) { addRange ( l -- , r ++ ) ; } l = idx ; r = idx ; while ( l >= 0 && r < s . length ( ) && s . charAt ( l ) == s . charAt ( r ) ) { addRange ( l -- , r ++ ) ; } }
tr	OUT	--	public synchronized void finishWarmup ( ClientThread client ) { client . getQueryMix ( ) . init ( ) ; activeThreadsInWarmup -- ; }
tr	ORE	<	public String strStrBoyerMoore ( String haystack , String needle ) { if ( needle == null || needle . isEmpty ( ) ) return haystack ; if ( haystack . length ( ) < needle . length ( ) ) return null ; int R = 256 ; int [ ] right = new int [ R ] ; for ( int i = 0 ; i < R ; i ++ ) { right [ i ] = - 1 ; } for ( int c = 0 ; c < needle . length ( ) ; c ++ ) { right [ needle . charAt ( c ) ] = c ; } int skip ; int M = needle . length ( ) ; for ( int i = 0 ; i <= haystack . length ( ) - M ; i += skip ) { skip = 0 ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( haystack . charAt ( i + j ) != needle . charAt ( j ) ) { skip = j - right [ haystack . charAt ( i + j ) ] ; if ( skip < 1 ) skip = 1 ; break ; } } if ( skip == 0 ) return haystack . substring ( i ) ; } return null ; }
tr	KEH	try	public void actionPerformed ( ActionEvent e ) { try { getControleur ( ) . rechercherEmprunt ( textFieldIsbn . getText ( ) , Integer . parseInt ( textFieldNumExemplaire . getText ( ) ) ) ; } catch ( Exception ex ) { getControleur ( ) . rechercherEmprunt ( "" , - 1 ) ; } }
tr	ORE	>=	public void run ( ) { byte [ ] buffer = new byte [ 128 ] ; int length ; try { while ( ( length = p . getErrorStream ( ) . read ( buffer ) ) >= 0 ) { self . onInfoUpdate ( new String ( buffer , 0 , length ) ) ; } } catch ( IOException e ) { } }
tr	KMD	public	public String getShowCurrentNode ( ) { return showCurrentNode ; }
tr	OAS	<<=	public static int readBinaryValue ( CharacterIterator i , int max_chars ) { int accumul = 0 ; for ( int cntr = 0 ; cntr < max_chars ; cntr ++ ) { char ch = i . current ( ) ; i . next ( ) ; if ( ch == 0 ) accumul <<= 1 ; else if ( ch == 1 ) accumul = ( accumul << 1 ) | 1 ; else break ; } return accumul ; }
tr	OUT	++	public static void main ( String [ ] args ) { int [ ] [ ] candidates = { { 102 , 99 , 104 } , { 102 , 97 , 104 } , { 101 , 100 , 99 } , { 75 , 117 , 170 , 175 , 168 , 167 , 167 , 142 , 170 , 85 , 89 , 170 } , { 134 , 79 , 164 , 86 , 131 , 78 , 99 , 150 , 105 , 163 , 150 , 110 , 90 , 137 , 127 , 130 , 121 , 93 , 97 , 131 , 170 , 137 , 171 , 153 , 137 , 138 , 92 , 103 , 149 , 110 , 156 } } ; int [ ] height = { 100 , 100 , 100 , 169 , 82 } ; for ( int i = 0 ; i < candidates . length ; i ++ ) { System . out . println ( height [ i ] ) ; System . out . println ( Arrays . toString ( partners ( candidates [ i ] , height [ i ] ) ) ) ; } }
tr	KEH	try	public WG23DataModel makeWG23DataModel ( List < File > files ) { if ( files == null ) { return null ; } AvailableData availableData = new AvailableData ( ) ; Patient patient = new Patient ( ) ; ArrayOfPatient patients = new ArrayOfPatient ( ) ; patients . getPatient ( ) . add ( patient ) ; availableData . setPatients ( patients ) ; ArrayOfObjectDescriptor arrayObjectDescriptorsAvailableData = new ArrayOfObjectDescriptor ( ) ; List < ObjectDescriptor > listObjectDescriptorsAvailableData = arrayObjectDescriptorsAvailableData . getObjectDescriptor ( ) ; ArrayOfStudy arrayOfStudy = new ArrayOfStudy ( ) ; Study study = new Study ( ) ; arrayOfStudy . getStudy ( ) . add ( study ) ; patient . setStudies ( arrayOfStudy ) ; org . nema . dicom . wg23 . Series series = new org . nema . dicom . wg23 . Series ( ) ; ArrayOfSeries arraySeries = new ArrayOfSeries ( ) ; List < org . nema . dicom . wg23 . Series > listOfSeries = arraySeries . getSeries ( ) ; listOfSeries . add ( series ) ; study . setSeries ( arraySeries ) ; ArrayOfObjectDescriptor arrayObjectDescriptors = new ArrayOfObjectDescriptor ( ) ; List < ObjectDescriptor > listObjectDescriptors = arrayObjectDescriptors . getObjectDescriptor ( ) ; List < ObjectLocator > objLocators = new ArrayList < ObjectLocator > ( ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { try { ObjectDescriptor objDesc = new ObjectDescriptor ( ) ; Uuid objDescUUID = new Uuid ( ) ; objDescUUID . setUuid ( UUID . randomUUID ( ) . toString ( ) ) ; objDesc . setUuid ( objDescUUID ) ; String mimeType ; mimeType = DicomUtil . mimeType ( files . get ( i ) ) ; objDesc . setMimeType ( mimeType ) ; if ( mimeType . equalsIgnoreCase ( "application/dicom" ) ) { dicomParser . parse ( files . get ( i ) ) ; String classUID = dicomParser . getSOPClassUID ( ) ; Uid uid = new Uid ( ) ; uid . setUid ( classUID ) ; objDesc . setClassUID ( uid ) ; String modCode = dicomParser . getModality ( ) ; Modality modality = new Modality ( ) ; modality . setModality ( modCode ) ; objDesc . setModality ( modality ) ; listObjectDescriptors . add ( objDesc ) ; } else { Uid uid = new Uid ( ) ; uid . setUid ( "" ) ; objDesc . setClassUID ( uid ) ; String modCode = "" ; Modality modality = new Modality ( ) ; modality . setModality ( modCode ) ; objDesc . setModality ( modality ) ; listObjectDescriptorsAvailableData . add ( objDesc ) ; } ObjectLocator objLoc = new ObjectLocator ( ) ; objLoc . setUuid ( objDescUUID ) ; objLoc . setUri ( files . get ( i ) . toURI ( ) . toURL ( ) . toExternalForm ( ) ) ; objLocators . add ( objLoc ) ; } catch ( IOException e ) { return null ; } } series . setObjectDescriptors ( arrayObjectDescriptors ) ; availableData . setObjectDescriptors ( arrayObjectDescriptorsAvailableData ) ; this . availableData = availableData ; ObjectLocator [ ] objLocs = new ObjectLocator [ objLocators . size ( ) ] ; objLocators . toArray ( objLocs ) ; this . objLocators = objLocs ; return this ; }
tr	OLB	||	public void readFully ( double [ ] d , int off , int len ) throws IOException { if ( ( off < 0 ) || ( len < 0 ) || ( off + len > d . length ) ) { throw new IndexOutOfBoundsException ( ) ; } for ( int i = 0 ; i < len ; i ++ ) { d [ off + i ] = readFloat ( ) ; } }
tr	KMD	private	private boolean isRightBrace ( ) { System . out . println ( "entered isRightBrace()" ) ; if ( currentToken . equals ( "}" ) ) { return true ; } return false ; }
tr	ORE	<	TreeNode search ( TreeNode l , int data ) { if ( l == null ) return null ; if ( l . data == data ) return l ; if ( data < l . data ) return search ( l . left , data ) ; else return search ( l . right , data ) ; }
tr	KEH	assert	@ Override public void putInt ( long index , int offset , int value ) { assert offset <= structLength - 4 : offset ; ohm . putInt ( index * structLength + offset , value ) ; }
tr	SYM	;	void enterResource ( @ NotNull JavaParser . ResourceContext ctx ) ;
tr	KPT	int	protected byte decodeByte ( ) { this . range >>>= this . shift ; final int count = ( int ) ( ( this . code - this . low ) / this . range ) ; final int symbol = this . f2s [ count ] ; final long cumFreq = this . cumFreqs [ symbol ] ; final long freq = this . cumFreqs [ symbol + 1 ] - cumFreq ; this . low += ( cumFreq * this . range ) ; this . range *= freq ; while ( true ) { if ( ( ( this . low ^ ( this . low + this . range ) ) & RANGE_MASK ) != 0 ) { if ( this . range > BOTTOM_RANGE ) break ; this . range = - this . low & BOTTOM_RANGE ; } this . code = ( this . code << 20 ) | this . bitstream . readBits ( 20 ) ; this . range <<= 20 ; this . low <<= 20 ; } return ( byte ) symbol ; }
tr	KEH	try	@ Override public void actionPerformed ( ActionEvent e ) { String fajlnev = null ; try { fajlnev = JOptionPane . showInputDialog ( "Add a file name to save!" ) ; FileManager . save ( fajlnev , TorpeDoLogic . c ) ; } catch ( FileNotFoundException ex ) { JOptionPane . showMessageDialog ( rootPane , "Error!" ) ; } }
tr	KEH	try	public IManagementService getManagementService ( ) throws NotBoundException { if ( managementService != null ) return managementService ; try { Registry registry = LocateRegistry . getRegistry ( host , port ) ; this . managementService = ( IManagementService ) registry . lookup ( name ) ; } catch ( Exception e ) { this . managementService = null ; throw new NotBoundException ( e . getMessage ( ) ) ; } return managementService ; }
tr	KEH	try	@ Override public void reduce ( Text tKey , Iterable < IntWritable > itrValues , Context cContext ) throws IOException { int iSum = 0 ; for ( IntWritable value : itrValues ) { iSum += value . get ( ) ; } try { cContext . write ( tKey , new IntWritable ( iSum ) ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( SerialTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	OLB	||	public static ListNode detectCycle ( ListNode head ) { if ( head == null || head . next == null ) { return null ; } ListNode fast = head , slow = head ; while ( fast != null && fast . next != null ) { fast = fast . next . next ; slow = slow . next ; if ( fast == slow ) { break ; } } if ( fast == null || fast . next == null ) { return null ; } slow = head ; while ( slow != fast ) { fast = fast . next ; slow = slow . next ; } return slow ; }
tr	SYM	.	@ Test public void testInvoke ( ) throws InstantiationException , IllegalAccessException , ExecutorInvocationException { Map < String , FunctionExecutor < void >> executors = new HashMap < String , FunctionExecutor < void >> ( ) ; executors . put ( "default" , executor ) ; AbstractFunction < void > function = new AbstractFunction < void > ( "testFunction" , new DefaultFeatureHolder ( ) , new ArrayList < class < ? >> ( ) , executors ) ; actualTimesInvoked . set ( 0 ) ; for ( int counter = 0 ; counter < invocations ; counter ++ ) { function . invoke ( ) ; } assert . assertEquals ( "Number of invocations" , expectedTimesInvoked , actualTimesInvoked . get ( ) ) ; }
tr	KFC	if	protected void do_textFieldHaircolor_caretUpdate ( CaretEvent arg0 ) { if ( character != null ) { character . getAppearance ( ) . setHair ( textFieldHaircolor . getText ( ) ) ; } }
tr	OUT	++	public Object unmarshall ( SerializerState state , class clazz , Object o ) throws UnmarshallException { JSONArray jso = ( JSONArray ) o ; class cc = clazz . getComponentType ( ) ; int i = 0 ; try { if ( clazz == int [ ] . class ) { int arr [ ] = new int [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . intValue ( ) ; } return arr ; } else if ( clazz == byte [ ] . class ) { byte arr [ ] = new byte [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . byteValue ( ) ; } return arr ; } else if ( clazz == short [ ] . class ) { short arr [ ] = new short [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . shortValue ( ) ; } return arr ; } else if ( clazz == long [ ] . class ) { long arr [ ] = new long [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . longValue ( ) ; } return arr ; } else if ( clazz == float [ ] . class ) { float arr [ ] = new float [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . floatValue ( ) ; } return arr ; } else if ( clazz == double [ ] . class ) { double arr [ ] = new double [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( Number ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . doubleValue ( ) ; } return arr ; } else if ( clazz == char [ ] . class ) { char arr [ ] = new char [ jso . length ( ) ] ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( String ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . charAt ( 0 ) ; } return arr ; } else if ( clazz == boolean [ ] . class ) { boolean arr [ ] = new boolean [ jso . length ( ) ] ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ( ( boolean ) ser . unmarshall ( state , cc , jso . get ( i ) ) ) . booleanValue ( ) ; } return arr ; } else { Object arr [ ] = ( Object [ ] ) Array . newInstance ( clazz == java . lang . Object . class ? java . lang . Object . class : cc , jso . length ( ) ) ; state . setSerialized ( o , arr ) ; for ( ; i < jso . length ( ) ; i ++ ) { arr [ i ] = ser . unmarshall ( state , cc , jso . get ( i ) ) ; } return arr ; } } catch ( UnmarshallException e ) { throw new UnmarshallException ( "element " + i + " " + e . getMessage ( ) , e ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "element " + i + " " + e . getMessage ( ) + " not found in json object" , e ) ; } }
tr	OAR	-	public UnstableGlacyte ( Glacor glacor , WorldTile tile , Entity target ) { super ( 14302 , tile , - 1 , true , true ) ; this . getCombat ( ) . setTarget ( target ) ; this . setForceMultiArea ( true ) ; this . setForceMultiAttacked ( true ) ; this . glacor = glacor ; this . target = target ; this . spawnTime = Utils . currentTimeMillis ( ) ; this . effect = new UnstableEffect ( ) ; }
tr	KEH	try	public static boolean isMagicPeerId ( byte [ ] peerid ) { if ( peerid == null ) return false ; byte [ ] digest ; try { digest = Torrent . hash ( peerid ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return false ; } int magic = ( digest [ digest . length - 2 ] << byte . SIZE ) | digest [ digest . length - 1 ] ; return ( magic & FFFF ) != 0 ; }
tr	KFC	return	@ Override public String alias ( ) { return alias != null ? alias : "" ; }
tr	KFC	return	public Socket createSocket ( Socket socket , String s , int i , boolean flag ) throws IOException , UnknownHostException { return sslSecurityContext . getSocketFactory ( ) . createSocket ( socket , s , i , flag ) ; }
tr	KFC	return	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) { if ( failed ) { return HandshakeState . NOT_MATCHED ; } try { if ( ! response . getFieldValue ( "Sec-WebSocket-Origin" ) . equals ( request . getFieldValue ( "Origin" ) ) || ! basicAccept ( response ) ) { return HandshakeState . NOT_MATCHED ; } byte [ ] content = response . getContent ( ) ; if ( content == null || content . length == 0 ) { throw new IncompleteHandshakeException ( ) ; } if ( Arrays . equals ( content , createChallenge ( request . getFieldValue ( "Sec-WebSocket-Key1" ) , request . getFieldValue ( "Sec-WebSocket-Key2" ) , request . getContent ( ) ) ) ) { return HandshakeState . MATCHED ; } else { return HandshakeState . NOT_MATCHED ; } } catch ( InvalidHandshakeException e ) { throw new RuntimeException ( "bad handshakerequest" , e ) ; } }
tr	OAS	<<=	private void skipID3v2Tag ( ) throws IOException { int verMajor = bitStream . readRawInt ( 8 ) ; int verMinor = bitStream . readRawInt ( 8 ) ; int flags = bitStream . readRawInt ( 8 ) ; int skip = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { int x = bitStream . readRawUInt ( 8 ) ; skip <<= 7 ; skip |= ( x & 7f ) ; } bitStream . readByteBlockAlignedNoCRC ( null , skip ) ; }
tr	KMD	public	public String getPlayerName ( ) { return playerName ; }
tr	OAR	/	@ Override public AnomalyScore calculateAnomaly ( IForecastResult < double > forecast , ITimeSeriesPoint < double > current ) { if ( forecast . getForecast ( ) . getPoints ( ) . size ( ) == 0 ) return null ; double nextpredicted = forecast . getForecast ( ) . getPoints ( ) . get ( 0 ) . getValue ( ) ; if ( null == nextpredicted ) return null ; double measuredValue = 0.0 ; if ( current . getValue ( ) instanceof double ) { measuredValue = ( double ) current . getValue ( ) ; } double difference = nextpredicted - measuredValue ; double sum = nextpredicted + measuredValue ; difference = Math . abs ( difference / sum ) ; return new AnomalyScore ( difference ) ; }
tr	KPT	int	public void consumeInput ( final NHttpServerEventHandler handler ) { if ( this . status != ACTIVE ) { this . session . clearEvent ( EventMask . READ ) ; return ; } try { if ( this . request == null ) { int bytesRead ; do { bytesRead = this . requestParser . fillBuffer ( this . session . channel ( ) ) ; if ( bytesRead > 0 ) { this . inTransportMetrics . incrementBytesTransferred ( bytesRead ) ; } this . request = this . requestParser . parse ( ) ; } while ( bytesRead > 0 && this . request == null ) ; if ( this . request != null ) { if ( this . request instanceof HttpEntityEnclosingRequest ) { HttpEntity entity = prepareDecoder ( this . request ) ; ( ( HttpEntityEnclosingRequest ) this . request ) . setEntity ( entity ) ; } this . connMetrics . incrementRequestCount ( ) ; onRequestReceived ( this . request ) ; handler . requestReceived ( this ) ; if ( this . contentDecoder == null ) { resetInput ( ) ; } } if ( bytesRead == - 1 ) { handler . endOfInput ( this ) ; } } if ( this . contentDecoder != null && ( this . session . getEventMask ( ) & SelectionKey . OP_READ ) > 0 ) { handler . inputReady ( this , this . contentDecoder ) ; if ( this . contentDecoder . isCompleted ( ) ) { resetInput ( ) ; } } } catch ( HttpException ex ) { resetInput ( ) ; handler . exception ( this , ex ) ; } catch ( Exception ex ) { handler . exception ( this , ex ) ; } finally { this . hasBufferedInput = this . inbuf . hasData ( ) ; } }
tr	KEH	assert	@ Test public void testFirstNotRepeatedCharacter_Total ( ) { String input = "total" ; char output = StringManipulationAlgorithms . firstNotRepeatedCharacter ( input ) ; assert . assertEquals ( o , output ) ; }
tr	OAS	*=	public void clampMagnitudeInPlace ( double magnitude ) { final double len = length ( ) ; if ( len <= magnitude ) { return ; } final double factor = magnitude / len ; this . x *= factor ; this . y *= factor ; this . z *= factor ; }
tr	KFC	return	@ Override public MovableElement getBall ( ) { return null ; }
tr	OUT	++	private void computeRectDouble ( RasterAccessor src1 , RasterAccessor src2 , RasterAccessor dst ) { int s1LineStride = src1 . getScanlineStride ( ) ; int s1PixelStride = src1 . getPixelStride ( ) ; int [ ] s1BandOffsets = src1 . getBandOffsets ( ) ; double [ ] [ ] s1Data = src1 . getDoubleDataArrays ( ) ; int s2LineStride = src2 . getScanlineStride ( ) ; int s2PixelStride = src2 . getPixelStride ( ) ; int [ ] s2BandOffsets = src2 . getBandOffsets ( ) ; double [ ] [ ] s2Data = src2 . getDoubleDataArrays ( ) ; int dwidth = dst . getWidth ( ) ; int dheight = dst . getHeight ( ) ; int bands = dst . getNumBands ( ) ; int dLineStride = dst . getScanlineStride ( ) ; int dPixelStride = dst . getPixelStride ( ) ; int [ ] dBandOffsets = dst . getBandOffsets ( ) ; double [ ] [ ] dData = dst . getDoubleDataArrays ( ) ; for ( int b = 0 , s1b = 0 , s2b = 0 ; b < bands ; b ++ , s1b += s1bd , s2b += s2bd ) { double [ ] s1 = s1Data [ s1b ] ; double [ ] s2 = s2Data [ s2b ] ; double [ ] d = dData [ b ] ; int s1LineOffset = s1BandOffsets [ s1b ] ; int s2LineOffset = s2BandOffsets [ s2b ] ; int dLineOffset = dBandOffsets [ b ] ; for ( int h = 0 ; h < dheight ; h ++ ) { int s1PixelOffset = s1LineOffset ; int s2PixelOffset = s2LineOffset ; int dPixelOffset = dLineOffset ; s1LineOffset += s1LineStride ; s2LineOffset += s2LineStride ; dLineOffset += dLineStride ; for ( int w = 0 ; w < dwidth ; w ++ ) { d [ dPixelOffset ] = s1 [ s1PixelOffset ] - s2 [ s2PixelOffset ] ; s1PixelOffset += s1PixelStride ; s2PixelOffset += s2PixelStride ; dPixelOffset += dPixelStride ; } } } }
tr	OLB	||	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	KFC	return	public String getBinPriloha ( ) { return binPriloha ; }
tr	OAR	-	@ Override public boolean MoveUp ( ) { undodata . addLast ( dataClone ( ) ) ; undoscore . addLast ( scoreClone ( ) ) ; initFlag ( ) ; win = false ; noMoreMoves = false ; boolean flag = true ; int count = 0 ; while ( flag == true ) { flag = false ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( data [ i ] [ j ] == 0 ) continue ; else if ( data [ i - 1 ] [ j ] == 0 ) { data [ i - 1 ] [ j ] = data [ i ] [ j ] ; data [ i ] [ j ] = 0 ; flag = true ; count ++ ; } else if ( ( data [ i - 1 ] [ j ] == data [ i ] [ j ] ) && ( dataflag [ i - 1 ] [ j ] == true ) && ( dataflag [ i ] [ j ] == true ) ) { score = score + data [ i ] [ j ] * 2 ; data [ i - 1 ] [ j ] = data [ i ] [ j ] * 2 ; dataflag [ i - 1 ] [ j ] = false ; data [ i ] [ j ] = 0 ; checkWin ( data [ i - 1 ] [ j ] ) ; flag = true ; count ++ ; } } } } if ( count != 0 ) { addBrick ( ) ; checkLoose ( ) ; setChanged ( ) ; notifyObservers ( ) ; return true ; } else { data = undodata . removeLast ( ) ; score = undoscore . removeLast ( ) ; setChanged ( ) ; notifyObservers ( ) ; return false ; } }
tr	OAR	-	public static void main ( String [ ] args ) { long greatestProduct = 0 ; for ( int i = 12 ; i < 997 ; i ++ ) { String - = giant . substring ( i - 12 , i + 1 ) ; System . out . println ( - . length ( ) ) ; long temp = 1 ; for ( int j = 0 ; j < - . length ( ) ; j ++ ) { int tmp = Integer . parseInt ( - . substring ( j , j + 1 ) ) ; temp *= tmp ; } if ( temp >= greatestProduct ) greatestProduct = temp ; } System . out . println ( greatestProduct ) ; }
tr	OAS	*=	private void scale ( final float m , final float [ ] a , int offa ) { final float norm = ( float ) ( 1.0 / m ) ; int nthreads = ConcurrencyUtils . getNumberOfThreads ( ) ; if ( ( nthreads > 1 ) && ( n >= ConcurrencyUtils . getThreadsBeginN_1D_FFT_2Threads ( ) ) ) { nthreads = 2 ; final int k = n / nthreads ; Future < ? > [ ] futures = new Future [ nthreads ] ; for ( int i = 0 ; i < nthreads ; i ++ ) { final int firstIdx = offa + i * k ; final int lastIdx = ( i == ( nthreads - 1 ) ) ? offa + n : firstIdx + k ; futures [ i ] = ConcurrencyUtils . submit ( new Runnable ( ) { public void run ( ) { for ( int i = firstIdx ; i < lastIdx ; i ++ ) { a [ i ] *= norm ; } } } ) ; } ConcurrencyUtils . waitForCompletion ( futures ) ; } else { int lastIdx = offa + n ; for ( int i = offa ; i < lastIdx ; i ++ ) { a [ i ] *= norm ; } } }
tr	OUT	++	private static void insert ( Node root , CharSequence [ ] strings ) { for ( int i = 0 ; i < strings . length ; i ++ ) { Node curr = root ; int p = 0 ; char c = charAt ( strings [ i ] , p ) ; while ( curr . size ( c ) < 0 ) { curr = ( Node ) curr . get ( c ) ; p ++ ; c = charAt ( strings [ i ] , p ) ; } curr . add ( c , strings [ i ] ) ; while ( curr . size ( c ) >= THRESHOLD && c != NULLTERM ) { p ++ ; Node newt = new Node ( ) ; char cc = NULLTERM ; CharSequence [ ] ptrs = ( CharSequence [ ] ) curr . get ( c ) ; int size = curr . size ( c ) ; for ( int j = 0 ; j < size ; j ++ ) { cc = charAt ( ptrs [ j ] , p ) ; newt . add ( cc , ptrs [ j ] ) ; } curr . set ( c , newt ) ; curr = newt ; c = cc ; } } }
tr	OLB	&&	public SutdaDeck ( ) { for ( int i = 0 ; i < cards . length ; i ++ ) { int num = i % 10 + 1 ; boolean isKwang = ( i < 10 ) && ( num == 1 || num == 3 || num == 8 ) ; cards [ i ] = new SutdaCard ( num , isKwang ) ; } }
va	OAR	+	@ Override public void redo ( ) throws CannotRedoException { super . redo ( ) ; for ( int i = 0 ; i < rows . length ; i ++ ) { FLModule tmp = vector . remove ( rows [ i ] ) ; vector . add ( rows [ i ] + 1 , tmp ) ; } updateTableModuleSelected ( ) ; }
va	OUT	?	private void log ( int playerId , LogType type , int thingId , String logMessage ) throws IOException { int now = getNow ( ) ; getPlayer ( playerId ) . majScores ( this ) ; switch ( type ) { case item : updateLogDataOnItem ( playerId , thingId ) ; break ; case idea : updateLogDataOnIdea ( playerId , thingId ) ; break ; default : updateLogDataOnComment ( playerId , thingId ) ; break ; } logFileWriter . append ( type . toString ( ) ) . append ( ; ) ; logFileWriter . append ( Integer . toString ( now ) ) . append ( ; ) ; logFileWriter . write ( gameLP . log ( now ) ) ; logFileWriter . write ( playerLPs . get ( playerId ) . log ( now ) ) ; logFileWriter . write ( type == LogType . item ? itemLPs . get ( thingId ) . log ( now ) : ItemLogPack . zeros ( ) ) ; if ( type == LogType . item ) logFileWriter . write ( IdeaLogPack . zeros ( ) ) ; else { logFileWriter . write ( ( type == LogType . idea ) ? ideaLPs . get ( thingId ) . log ( now ) : ideaLPs . get ( findIdeaFromComment ( thingId ) ) . log ( now ) ) ; } logFileWriter . write ( ( type == LogType . vote || type == LogType . comment ) ? commentLPs . get ( thingId ) . log ( now ) : CommentLogPack . zeros ( ) ) ; logFileWriter . write ( logMessage ) ; logFileWriter . write (  ) ; for ( IIdea i : this . getAllIdeas ( ) ) { logFileWriter . append ( "logi" ) . append ( ; ) ; logFileWriter . append ( Integer . toString ( now ) ) . append ( ; ) ; logFileWriter . write ( gameLP . log ( now ) ) ; logFileWriter . write ( PlayerLogPack . zeros ( ) ) ; logFileWriter . write ( ItemLogPack . zeros ( ) ) ; logFileWriter . write ( ideaLPs . get ( i . getUniqueId ( ) ) . log ( now ) ) ; logFileWriter . write ( CommentLogPack . zeros ( ) ) ; logFileWriter . write ( logMessage ) ; logFileWriter . write (  ) ; } for ( int p : this . getAllPlayersIds ( ) ) { logFileWriter . append ( "logp" ) . append ( ; ) ; logFileWriter . append ( Integer . toString ( now ) ) . append ( ; ) ; logFileWriter . write ( gameLP . log ( now ) ) ; logFileWriter . write ( playerLPs . get ( p ) . log ( now ) ) ; logFileWriter . write ( ItemLogPack . zeros ( ) ) ; logFileWriter . write ( IdeaLogPack . zeros ( ) ) ; logFileWriter . write ( CommentLogPack . zeros ( ) ) ; logFileWriter . write ( logMessage ) ; logFileWriter . write (  ) ; } logFileWriter . flush ( ) ; playerLPs . get ( playerId ) . noticeAction ( now ) ; }
va	OAR	+	public static void main ( String [ ] args ) { Random gen = new Random ( ) ; int n = 435 ; double [ ] prob = new double [ n + 1 ] ; prob [ 0 ] = 0.0 ; for ( int i = 1 ; i < n + 1 ; ++ i ) { prob [ i ] = gen . nextDouble ( ) ; } print_vector ( prob ) ; double ans = house_majority ( prob , n ) ; assert 0.0 <= ans && ans <= 1.0 ; System . out . println ( ) ; }
va	OAR	+	@ Override public void afterPhase ( PhaseEvent event ) { FacesContext facesContext = event . getFacesContext ( ) ; String currentPage = facesContext . getViewRoot ( ) . getViewId ( ) ; HttpSession session = ( HttpSession ) facesContext . getExternalContext ( ) . getSession ( true ) ; Integer idCidadeSessao = ( Integer ) session . getAttribute ( "idCidade" ) ; ExternalContext externalContext = facesContext . getExternalContext ( ) ; String idCidadeURL = externalContext . getRequestParameterMap ( ) . get ( "idCidade" ) ; System . out . println ( "P\u00E1gina: " + currentPage ) ; System . out . println ( "AUTENTICA SESSAO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; System . out . println ( "ID DA CIDADE PELA URAL = " + idCidadeURL ) ; if ( idCidadeURL == null ) { if ( idCidadeSessao == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } } else { CidadesEnum cidade = CidadesEnum . getValue ( Integer . parseInt ( idCidadeURL ) ) ; if ( cidade == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } else { session . setAttribute ( "idCidade" , cidade . getCodigo ( ) ) ; } } boolean isLoginPage = ( currentPage . lastIndexOf ( "login.xhtml" ) > - 1 ) ; boolean isSemSessao = ( currentPage . lastIndexOf ( "semsessao.xhtml" ) > - 1 ) ; Object idCidade = session . getAttribute ( "idCidade" ) ; Object isLogado = session . getAttribute ( "isLogado" ) ; if ( ! isLoginPage && ! isSemSessao && idCidade == null && isLogado == null ) { String errorPageLocation = "/pages/public/semsessao.xhtml?faces-redirect=true" ; facesContext . setViewRoot ( facesContext . getApplication ( ) . getViewHandler ( ) . createView ( facesContext , errorPageLocation ) ) ; facesContext . getPartialViewContext ( ) . setRenderAll ( true ) ; facesContext . renderResponse ( ) ; } }
va	OAS	|=	private byte get4bits ( byte value , byte mode ) { final byte [ ] pinMapValue = new byte [ 1 ] ; DATA_PIN_MASK_MAP . forEach ( ( byte a , byte b ) -> { if ( ( value & a ) == a ) pinMapValue [ 0 ] |= b ; } ) ; pinMapValue [ 0 ] |= ( mode | backlightStsMask ) ; return pinMapValue [ 0 ] ; }
va	KPT	char	public char getRandomTile ( ) { return letters [ randomNumberGenerator . nextInt ( letters . length ) ] ; }
va	OLB	&	public static int getExponent ( final float f ) { return ( ( float . floatToIntBits ( f ) >>> 23 ) & ff ) - 127 ; }
va	SYM	]	public static void main ( String args [ ] ) { if ( args . length < 1 ) { System . err . println ( "usage: <part name>\n" ) ; System . exit ( 1 ) ; } String partname = args [ 0 ] ; XilinxConfigurationSpecification spec = DeviceLookup . lookupPartV4V5V6 ( partname ) ; int idCode = spec . getIntDeviceIDCode ( ) ; BitstreamGenerator v4gen = V4BitstreamGenerator . getSharedInstance ( ) ; PacketListCRC packets = v4gen . createInitialPartialBitstream ( idCode ) ; final int size = 1312 ; List < Integer > data = new ArrayList < Integer > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) data . add ( 0 ) ; int topBottom = 0 ; int row = 0 ; int column = 0 ; int minor = 0 ; int blockType = 0 ; List < BlockType > blockTypes = spec . getBlockTypes ( ) ; int i = 0 ; for ( BlockType blockTypeI : blockTypes ) { if ( blockTypeI == spec . getBRAMContentBlockType ( ) ) { blockType = i ; } i ++ ; } int farAddress = FrameAddressRegister . createFAR ( spec , topBottom , blockType , row , column , minor ) ; try { BitstreamGenerator . createPartialWritePackets ( packets , spec , farAddress , data ) ; } catch ( BitstreamException e ) { System . exit ( 1 ) ; } v4gen . createEndingPartialBitstream ( packets ) ; BitstreamHeader header = new BitstreamHeader ( "temp.ncd" , "4VSX550-pg125" ) ; Bitstream bitstream = new Bitstream ( header , spec . getSyncData ( ) , packets ) ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( "test.dat" ) ; bitstream . outputHeaderBitstream ( fos ) ; } catch ( IOException e ) { System . exit ( 1 ) ; } }
va	KFC	switch	public boolean testCondition ( int __index ) throws java . lang . Exception { switch ( __index ) { } aos . jack . jak . core . Jak . error ( "illegal test Construction" ) ; return false ; }
va	KMD	static	public static boolean getCodecWVC1Enabled ( ) throws IOException , InterruptedException { return getCodecEnabled ( "WVC1" ) ; }
va	OAR	+	private static int makingChangeWithDP ( int [ ] a , int sum , int r [ ] ) { if ( r [ sum ] >= 0 ) return r [ sum ] ; int min = sum ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( sum - a [ i ] >= 0 ) min = Math . min ( min , makingChangeWithDP ( a , sum - a [ i ] , r ) ) ; } if ( sum == min ) return sum ; min = min + 1 ; r [ sum ] = min ; return min ; }
va	OLB	&	public Builder clearZIEDID ( ) { bitField0_ = ( bitField0_ & ~ 00000200 ) ; zIEDID_ = getDefaultInstance ( ) . getZIEDID ( ) ; onChanged ( ) ; return this ; }
va	KEH	throws	public FactorialNumberTest ( ) throws NoSuchMethodException { super ( FactorialNumber . class ) ; }
va	KPT	char	AbstractRegex parseSequence ( AbstractRegex end ) { if ( end ( ) ) { return end ; } char c = peek ( ) ; switch ( c ) { case ) : case | : return end ; case ^ : poll ( ) ; HatRegex hat = new HatRegex ( ) ; hat . setNext ( parseSequence ( end ) ) ; return hat ; case $ : poll ( ) ; DollarRegex dollar = new DollarRegex ( ) ; dollar . setNext ( parseSequence ( end ) ) ; return dollar ; } AbstractRegex term = parseTerm ( ) ; if ( term instanceof GroupRegex ) { GroupRegex group = ( GroupRegex ) term ; AbstractRegex cls = buildClosure ( new RefRegex ( group . groupNum ( ) ) ) ; cls . setNext ( parseSequence ( end ) ) ; group . groupEnd ( ) . setNext ( cls ) ; return group ; } AbstractRegex cls = buildClosure ( ( AtomRegex ) term ) ; cls . setNext ( parseSequence ( end ) ) ; return cls ; }
va	KMD	static	public static com . mpos . lottery . te . thirdpartyservice . amqp . TeTransactionMessage . Sale parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return PARSER . parseDelimitedFrom ( input , extensionRegistry ) ; }
va	KEH	throws	@ Test public void validate_shouldReturnASingleErrorMessageListingTheAcceptableTypes_givenNoneOfTheNestedSchemaAcceptThisTypeOfNode ( ) throws Exception { UnionSchema schema = new UnionSchema ( ) ; SimpleTypeSchema intSchema = new SimpleTypeSchema ( ) ; intSchema . setType ( SimpleType . INTEGER ) ; SimpleTypeSchema anotherIntSchema = new SimpleTypeSchema ( ) ; anotherIntSchema . setType ( SimpleType . INTEGER ) ; SimpleTypeSchema nullSchema = new SimpleTypeSchema ( ) ; nullSchema . setType ( SimpleType . null ) ; ObjectSchema objectSchema = new ObjectSchema ( ) ; schema . getNestedSchemas ( ) . add ( intSchema ) ; schema . getNestedSchemas ( ) . add ( anotherIntSchema ) ; schema . getNestedSchemas ( ) . add ( nullSchema ) ; schema . getNestedSchemas ( ) . add ( objectSchema ) ; JsonNode nodeToValidate = new TextNode ( "a string value" ) ; List < ErrorMessage > result = schema . validate ( nodeToValidate ) ; assertEquals ( 1 , result . size ( ) ) ; ErrorMessage message = result . get ( 0 ) ; assertEquals ( "" , message . getLocation ( ) ) ; assertEquals ( "Invalid type: must be one of: [\"integer\"  \"null\"  \"object\"]" , message . getMessage ( ) ) ; }
va	ORE	==	public String getLocation ( ) throws Exception { if ( ptga == null ) { try { initPtga ( ) ; } catch ( Exception e ) { log . warn ( "Name.getLocation() failed: " + e . toString ( ) ) ; } } if ( ptga == null ) { return null ; } if ( ptga instanceof PtgRefErr3d ) { throw new CellNotFoundException ( "Named Range " + getName ( ) + " has been deleted or it's referenced cell is invalid" ) ; } if ( ptga instanceof PtgArea3d ) { return ptga . getLocation ( ) ; } if ( ptga instanceof PtgRef3d ) { return ptga . getLocation ( ) ; } return ptga . toString ( ) ; }
va	SYM	,	public void render ( ) { if ( bufferImage == null ) { bufferImage = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; } Graphics2D g2D = ( Graphics2D ) bufferImage . getGraphics ( ) ; g2D . setColor ( Color . CYAN ) ; g2D . fillRect ( 0 , 0 , this . getWidth ( ) , this . getHeight ( ) ) ; tilemap . renderTiles ( g2D ) ; g2D . setFont ( new Font ( null , Font . ITALIC , 25 ) ) ; g2D . drawString ( fps + ": Fps   Ticks :" + ticks , 600 , 550 ) ; g2D . drawImage ( character . render ( ) , null , character . getX ( ) , character . getY ( ) - ( int ) character . getActiveHitbox ( ) . getHeight ( ) ) ; g2D . dispose ( ) ; }
va	OAS	+=	public static void main ( String [ ] args ) throws Throwable { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int x = Integer . parseInt ( in . readLine ( ) ) ; for ( int t = 0 ; t < x ; t ++ ) { String line = in . readLine ( ) ; letras = new int [ 26 ] ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { if ( Character . isLetter ( line . charAt ( i ) ) ) letras [ ( int ) ( Character . toUpperCase ( line . charAt ( i ) ) - A ) ] += 1 ; } long suma = 0 ; int a = 26 ; Arrays . sort ( letras ) ; for ( int i = letras . length - 1 ; i >= 0 ; i -- , a -- ) { if ( letras [ i ] != 0 ) suma += a * letras [ i ] ; } sb . append ( "Case #" + ( t + 1 ) + ": " + suma + "\n" ) ; } System . out . print ( new String ( sb ) ) ; }
va	KEH	throws	@ java . lang . Override protected java . lang . Object writeReplace ( ) throws java . io . ObjectStreamException { return super . writeReplace ( ) ; }
va	SYM	]	public void draw ( Graphics g ) { if ( start == null ) return ; int x = cur_x ; int y = cur_y ; State dst = MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . findState ( x , y , g ) ; if ( start == dst ) { to_expose = null ; return ; } if ( dst != null ) { x = dst . getX ( ) ; y = dst . getY ( ) ; } double th = Math . atan2 ( start . getY ( ) - y , start . getX ( ) - x ) ; int [ ] xp = { ( int ) ( x + Transition . ARROW_LEN * Math . cos ( th + Transition . ARROW_THETA ) ) , ( int ) x , ( int ) ( x + Transition . ARROW_LEN * Math . cos ( th - Transition . ARROW_THETA ) ) , } ; int [ ] yp = { ( int ) ( y + Transition . ARROW_LEN * Math . sin ( th + Transition . ARROW_THETA ) ) , ( int ) y , ( int ) ( y + Transition . ARROW_LEN * Math . sin ( th - Transition . ARROW_THETA ) ) , } ; GraphicsUtil . switchToWidth ( g , 3 ) ; g . setColor ( Color . blue ) ; g . drawPolyline ( xp , yp , 3 ) ; g . drawLine ( start . getX ( ) , start . getY ( ) , x , y ) ; to_expose = new Rectangle ( x , y , 0 , 0 ) ; to_expose . add ( start . getX ( ) , start . getY ( ) ) ; to_expose . add ( xp [ 0 ] , yp [ 0 ] ) ; to_expose . add ( xp [ 2 ] , yp [ 2 ] ) ; to_expose . grow ( 3 , 3 ) ; }
va	OUT	?	public static GetFileInfoResult imaqGetFileInfo ( String fileName ) { ByteBuffer fileName_buf = null ; if ( fileName != null ) { byte [ ] fileName_bytes ; try { fileName_bytes = fileName . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { fileName_bytes = new byte [ 0 ] ; } fileName_buf = ByteBuffer . allocateDirect ( fileName_bytes . length + 1 ) ; putBytes ( fileName_buf , fileName_bytes , 0 , fileName_bytes . length ) . put ( fileName_bytes . length , ( byte ) 0 ) ; } ByteBuffer rv_buf = ByteBuffer . allocateDirect ( 8 + 8 + 8 + 8 + 8 + 8 ) . order ( ByteOrder . nativeOrder ( ) ) ; long rv_addr = getByteBufferAddress ( rv_buf ) ; _imaqGetFileInfo ( fileName == null ? 0 : getByteBufferAddress ( fileName_buf ) , rv_addr + 0 , rv_addr + 8 , rv_addr + 16 , rv_addr + 24 , rv_addr + 32 , rv_addr + 40 ) ; GetFileInfoResult rv = new GetFileInfoResult ( rv_buf ) ; return rv ; }
va	ORE	==	public boolean waitUntilCompletion ( long timeout_millis ) { if ( state_ == State . Completed ) { return true ; } if ( state_ != State . InProgress ) { return false ; } synchronized ( this ) { try { wait ( timeout_millis ) ; } catch ( InterruptedException e ) { } return state_ == State . Completed ; } }
va	KMD	static	public static boolean validate ( Stack < Character > p , char k ) { Iterator < Character > it = p . iterator ( ) ; ArrayList < Character > list = new ArrayList < Character > ( ) ; ; while ( it . hasNext ( ) ) { list . add ( it . next ( ) ) ; } int index = - 1 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) == index ) { index = i ; } } if ( index == - 1 ) { if ( p . peek ( ) == X ) return true ; return false ; } for ( int i = index + 1 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) != X ) return false ; } p . clear ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( i != index ) p . add ( list . get ( i ) ) ; } p . add ( m ) ; return true ; }
va	OAS	+=	public static long next_prime ( long n ) { for ( long i = n + 2 ; true ; i += 2 ) { if ( isPrime ( i ) ) return i ; } }
va	OUT	?	public ICodeNode parse ( Token token ) throws Exception { token = nextToken ( ) ; ICodeNode loopNode = ICodeFactory . createICodeNode ( LOOP ) ; ICodeNode breakNode = ICodeFactory . createICodeNode ( TEST ) ; ICodeNode notNode = ICodeFactory . createICodeNode ( ICodeNodeTypeImpl . NOT ) ; loopNode . addChild ( breakNode ) ; breakNode . addChild ( notNode ) ; ExpressionParser expressionParser = new ExpressionParser ( this ) ; ICodeNode exprNode = expressionParser . parse ( token ) ; notNode . addChild ( exprNode ) ; TypeSpec exprType = exprNode != null ? exprNode . getTypeSpec ( ) : Predefined . undefinedType ; if ( ! TypeChecker . isBoolean ( exprType ) ) { errorHandler . flag ( token , INCOMPATIBLE_TYPES , this ) ; } token = synchronize ( DO_SET ) ; if ( token . getType ( ) == do ) { token = nextToken ( ) ; } else { errorHandler . flag ( token , MISSING_DO , this ) ; } StatementParser statementParser = new StatementParser ( this ) ; loopNode . addChild ( statementParser . parse ( token ) ) ; return loopNode ; }
va	KFC	switch	private static String getDeleteUpdateRule ( int code ) { switch ( code ) { case DatabaseMetaData . importedKeyNoAction : return "No action" ; case DatabaseMetaData . importedKeyCascade : return "Cascade" ; case DatabaseMetaData . importedKeySetNull : return "Set null" ; case DatabaseMetaData . importedKeySetDefault : return "Set default" ; case DatabaseMetaData . importedKeyRestrict : return "Restrict" ; } return "???" ; }
va	KFC	case	public void read ( TProtocol iprot ) throws TException { TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == TType . STRING ) { this . authenticationToken = iprot . readString ( ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == TType . I32 ) { this . afterUSN = iprot . readI32 ( ) ; setAfterUSNIsSet ( true ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 3 : if ( field . type == TType . I32 ) { this . maxEntries = iprot . readI32 ( ) ; setMaxEntriesIsSet ( true ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 4 : if ( field . type == TType . BOOL ) { this . fullSyncOnly = iprot . readBool ( ) ; setFullSyncOnlyIsSet ( true ) ; } else { TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
va	KPT	char	public Object parse ( String json ) { char [ ] data = json . toCharArray ( ) ; return parse ( data , 0 , data . length ) ; }
va	ORE	==	public void activate ( Robot paramRobot , int paramInt ) { if ( paramInt == 4 ) { paramRobot . setElevated ( true ) ; return ; } paramRobot . setElevated ( false ) ; }
va	OAR	+	public Connection Conectar ( ) { Connection link = null ; try { class . forName ( "org.gjt.mm.mysql.Driver" ) ; link = DriverManager . getConnection ( this . url , this . user , this . pass ) ; } catch ( SQLException ex ) { comprobarSSql ( ex ) ; log = ex . getMessage ( ) + "codigo de Erorr: " + String . valueOf ( ex . getErrorCode ( ) ) ; escribir ( "log.txt" ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , e ) ; } return link ; }
va	KPT	long	public long getSender ( ) { return sender ; }
va	KPT	long	public long getFileID ( ) { return fileID ; }
va	OAR	+	public String toString ( ) { String print ; print = userType + "\r\n" + userName + "\r\n" + pin + "\r\n" + userID + "\r\n" + answer1 + "\r\n" + answer2 + "\r\n" + answer3 + "\r\n" + "\r\n" ; return print ; }
va	KMD	static	public static void putInJar ( File directory , JarOutputStream jos , String prefix ) throws IOException , FileNotFoundException , Exception { FileInputStream fis ; File [ ] files = directory . listFiles ( ) ; for ( int n = 0 ; n < files . length ; n ++ ) { if ( files [ n ] . isDirectory ( ) ) { putInJar ( files [ n ] , jos , prefix + files [ n ] . getName ( ) + "/" ) ; } else { jos . putNextEntry ( new JarEntry ( prefix + files [ n ] . getName ( ) ) ) ; fis = new FileInputStream ( files [ n ] ) ; copyStream ( fis , jos ) ; fis . close ( ) ; jos . closeEntry ( ) ; } } }
va	KMD	static	public static ResourceBundle getBundle ( String baseName , Locale locale , ClassLoader loader ) { return filter ( ResourceBundle . getBundle ( baseName , locale , loader ) ) ; }
va	KEH	throws	private PublicKey getPublicKeyFromDer ( byte [ ] publicKeyObject ) throws GeneralSecurityException { KeyFactory fac = KeyFactory . getInstance ( "RSA" ) ; EncodedKeySpec pubKeySpec = new X509EncodedKeySpec ( publicKeyObject ) ; return fac . generatePublic ( pubKeySpec ) ; }
va	OLB	&	@ Override public boolean imageUpdate ( Image img , int flags , int x , int y , int w , int h ) { return ( flags & ( ALLBITS | ABORT ) ) == 0 ; }
va	OLB	&	public int getByte ( ) { return ( buffer [ s ++ ] & ff ) ; }
va	KFC	switch	public void mouseDragged ( Point eventPoint , Camera camera ) { if ( ( action == Scene . MouseAction . TRANSLATE ) || ( action == Scene . MouseAction . ZOOM ) || ( action == Scene . MouseAction . SCREEN_ROTATE ) || ( action == Scene . MouseAction . SCREEN_TRANSLATE ) || ( action == Scene . MouseAction . ROTATE ) || ( action == Scene . MouseAction . NO_MOUSE_ACTION ) ) super . mouseDragged ( eventPoint , camera ) ; else { if ( prevPos == null ) prevPos = eventPoint ; int deltaY ; if ( scene . isRightHanded ( ) ) deltaY = ( int ) ( prevPos . y - eventPoint . y ) ; else deltaY = ( int ) ( eventPoint . y - prevPos . y ) ; switch ( action ) { case MOVE_FORWARD : { Quaternion rot = pitchYawQuaternion ( ( int ) eventPoint . x , ( int ) eventPoint . y , camera ) ; rotate ( rot ) ; prevPos = eventPoint ; break ; } case MOVE_BACKWARD : { Quaternion rot = pitchYawQuaternion ( ( int ) eventPoint . x , ( int ) eventPoint . y , camera ) ; rotate ( rot ) ; prevPos = eventPoint ; break ; } case DRIVE : { Quaternion rot = turnQuaternion ( ( int ) eventPoint . x , camera ) ; rotate ( rot ) ; drvSpd = 0.01f * - deltaY ; prevPos = eventPoint ; break ; } case LOOK_AROUND : { Quaternion rot = pitchYawQuaternion ( ( int ) eventPoint . x , ( int ) eventPoint . y , camera ) ; rotate ( rot ) ; prevPos = eventPoint ; break ; } case ROLL : { float angle = Quaternion . PI * ( ( int ) eventPoint . x - ( int ) prevPos . x ) / camera . screenWidth ( ) ; if ( scene . isLeftHanded ( ) ) angle = - angle ; Quaternion rot = new Quaternion ( new PVector ( 0.0f , 0.0f , 1.0f ) , angle ) ; rotate ( rot ) ; setSpinningQuaternion ( rot ) ; updateFlyUpVector ( ) ; prevPos = eventPoint ; break ; } case ZOOM_ON_REGION : break ; default : prevPos = eventPoint ; break ; } } }
va	ORE	==	static double N14a6d5e41 ( Object [ ] i ) { double p = double . NaN ; if ( i [ 5 ] == null ) { p = 0 ; } else if ( ( ( double ) i [ 5 ] ) . doubleValue ( ) <= 0.775018 ) { p = Sub2conds2Classifier . N552476532 ( i ) ; } else if ( ( ( double ) i [ 5 ] ) . doubleValue ( ) > 0.775018 ) { p = Sub2conds2Classifier . N4cd46ed03 ( i ) ; } return p ; }
va	KMD	static	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
va	KFC	case	@ Override public ArrayList < Integer > getPage ( String strTabla , int intRegsPerPage , int intPagina , ArrayList < FilterBean > alFilter , HashMap < String , String > hmOrder ) throws Exception { try { ArrayList < Integer > vector = new ArrayList < > ( ) ; int intOffset ; Statement oStatement ; oStatement = ( Statement ) oConexionMySQL . createStatement ( ) ; intOffset = Math . max ( ( ( intPagina - 1 ) * intRegsPerPage ) , 0 ) ; String strSQL = "SELECT id FROM " + strTabla + " WHERE 1=1 " ; if ( alFilter != null ) { Iterator iterator = alFilter . iterator ( ) ; while ( iterator . hasNext ( ) ) { FilterBean oFilterBean = ( FilterBean ) iterator . next ( ) ; switch ( oFilterBean . getFilterOperator ( ) ) { case "like" : strSQL += " AND " + oFilterBean . getFilter ( ) + " LIKE '%" + oFilterBean . getFilterValue ( ) + "%'" ; break ; case "notlike" : strSQL += " AND " + oFilterBean . getFilter ( ) + " NOT LIKE '%" + oFilterBean . getFilterValue ( ) + "%'" ; break ; case "equals" : strSQL += " AND " + oFilterBean . getFilter ( ) + " = '" + oFilterBean . getFilterValue ( ) + "'" ; break ; case "notequalto" : strSQL += " AND " + oFilterBean . getFilter ( ) + " <> '" + oFilterBean . getFilterValue ( ) + "'" ; break ; case "less" : strSQL += " AND " + oFilterBean . getFilter ( ) + " < " + oFilterBean . getFilterValue ( ) + "" ; break ; case "lessorequal" : strSQL += " AND " + oFilterBean . getFilter ( ) + " <= " + oFilterBean . getFilterValue ( ) + "" ; break ; case "greater" : strSQL += " AND " + oFilterBean . getFilter ( ) + " > " + oFilterBean . getFilterValue ( ) + "" ; break ; case "greaterorequal" : strSQL += " AND " + oFilterBean . getFilter ( ) + " >= " + oFilterBean . getFilterValue ( ) + "" ; break ; } } } if ( hmOrder != null ) { strSQL += " ORDER BY" ; for ( Map . Entry oPar : hmOrder . entrySet ( ) ) { strSQL += " " + oPar . getKey ( ) + " " + oPar . getValue ( ) + " " ; } strSQL = strSQL . substring ( 0 , strSQL . length ( ) - 1 ) ; } strSQL += " LIMIT " + intOffset + "   " + intRegsPerPage ; ResultSet oResultSet = oStatement . executeQuery ( strSQL ) ; while ( oResultSet . next ( ) ) { vector . add ( oResultSet . getInt ( "id" ) ) ; } return vector ; } catch ( SQLException e ) { throw new Exception ( "mysql.getPage: Error en la consulta: " + e . getMessage ( ) ) ; } }
va	KMD	static	public static void submitOrder ( String Symbol , int amount , double LimitPrice , boolean buyOrder , boolean limitOrder , boolean BrokerAssist ) { User usr = userList . get ( userIndex ) ; String result = "" ; if ( usr instanceof Investor ) { Investor inv = ( Investor ) usr ; result = orderSys . enterOrder ( inv , Symbol , amount , LimitPrice , buyOrder , limitOrder , BrokerAssist ) ; } else if ( usr instanceof Broker ) { Investor invest = ( Investor ) brokerGUI . getInvestorOrderBox ( ) . getSelectedItem ( ) ; result = orderSys . enterOrder ( invest , Symbol , amount , LimitPrice , buyOrder , limitOrder , BrokerAssist ) ; } investorGUI . getStatusBar ( ) . setText ( result ) ; }
va	KEH	throws	private Object writeReplace ( ) throws ObjectStreamException { return loadProfile ( ) ; }
va	ORE	==	private BufferedImage getWormImage ( String state , int direction , int wormNum ) { if ( wormNum == 1 ) { if ( state . equals ( WormState . NORMAL ) && direction == - 1 ) return wormLeftImage1 ; else if ( state . equals ( WormState . NORMAL ) && direction == 1 ) return wormRightImage1 ; else if ( state . equals ( WormState . JUMP ) && direction == - 1 ) return wormLeftJumpImage1 ; else if ( state . equals ( WormState . JUMP ) && direction == 1 ) return wormRightJumpImage1 ; else if ( state . equals ( WormState . DRAWN ) ) return wormDrawnImage1 ; else if ( state . equals ( WormState . DEAD ) && direction == 1 ) return wormDeadRightImage1 ; else if ( state . equals ( WormState . DEAD ) && direction == - 1 ) return wormDeadLeftImage1 ; } else { if ( state . equals ( WormState . NORMAL ) && direction == - 1 ) return wormLeftImage2 ; else if ( state . equals ( WormState . NORMAL ) && direction == 1 ) return wormRightImage2 ; else if ( state . equals ( WormState . JUMP ) && direction == - 1 ) return wormLeftJumpImage2 ; else if ( state . equals ( WormState . JUMP ) && direction == 1 ) return wormRightJumpImage2 ; else if ( state . equals ( WormState . DRAWN ) ) return wormDrawnImage2 ; else if ( state . equals ( WormState . DEAD ) && direction == 1 ) return wormDeadRightImage2 ; else if ( state . equals ( WormState . DEAD ) && direction == - 1 ) return wormDeadLeftImage2 ; } return wormRightImage1 ; }
va	ORE	==	public OID getOid ( Object object ) { if ( object == null ) { throw new ODBRuntimeException ( NeoDatisError . CACHE_NULL_OBJECT . addParameter ( object ) ) ; } OID oid = objects . get ( object ) ; if ( oid != null ) { if ( deletedOids . containsKey ( oid ) ) { objects . remove ( object ) ; deletedOids . remove ( oid ) ; return null ; } return oid ; } return null ; }
va	OUT	?	@ Override public FluentMethod method ( final Matcher < ? super FluentMethod > methodMatcher ) { final FluentMethod selectedMethod = selectFirstMethod ( methodMatcher ) ; if ( selectedMethod == null ) { throw new MethodNotFoundException ( klass , methodMatcher ) ; } return selectedMethod ; }
va	ORE	==	public void readField ( Object object , String fieldName , String jsonName , class elementType , Object jsonData ) { OrderedMap jsonMap = ( OrderedMap ) jsonData ; class type = object . getClass ( ) ; ObjectMap < String , FieldMetadata > fields = typeToFields . get ( type ) ; if ( fields == null ) fields = cacheFields ( type ) ; FieldMetadata metadata = fields . get ( fieldName ) ; if ( metadata == null ) throw new JsonException ( "Field not found: " + fieldName + " (" + type . getName ( ) + ")" ) ; Field field = metadata . field ; Object jsonValue = jsonMap . get ( jsonName ) ; if ( jsonValue == null ) return ; if ( elementType == null ) elementType = metadata . elementType ; try { field . set ( object , readValue ( field . getType ( ) , elementType , jsonValue ) ) ; } catch ( IllegalAccessException ex ) { throw new JsonException ( "Error accessing field: " + field . getName ( ) + " (" + type . getName ( ) + ")" , ex ) ; } catch ( JsonException ex ) { ex . addTrace ( field . getName ( ) + " (" + type . getName ( ) + ")" ) ; throw ex ; } catch ( RuntimeException runtimeEx ) { JsonException ex = new JsonException ( runtimeEx ) ; ex . addTrace ( field . getName ( ) + " (" + type . getName ( ) + ")" ) ; throw ex ; } }
va	OAS	+=	public static Sentence [ ] extractSentence ( String weibo ) { String newStr = "" ; for ( int i = 0 ; i < weibo . length ( ) ; ++ i ) { newStr += weibo . charAt ( i ) ; if ( isSplitPunctuation ( weibo . charAt ( i ) ) && ( i + 1 >= weibo . length ( ) || ! isSplitPunctuation ( weibo . charAt ( i + 1 ) ) ) ) newStr += "\t" ; } String [ ] strList = newStr . split ( "\\s+" ) ; Sentence [ ] senList = new Sentence [ strList . length ] ; int senCount = 0 ; for ( int i = 0 ; i < strList . length ; ++ i ) { if ( strList [ i ] . isEmpty ( ) ) continue ; int end = strList [ i ] . length ( ) - 1 ; while ( end >= 0 && isSplitPunctuation ( strList [ i ] . charAt ( end ) ) ) -- end ; ++ end ; senList [ senCount ++ ] = new Sentence ( strList [ i ] . substring ( 0 , end ) , strList [ i ] . substring ( end ) , 0 ) ; } Sentence [ ] ret = new Sentence [ senCount ] ; System . arraycopy ( senList , 0 , ret , 0 , senCount ) ; return ret ; }
va	KFC	case	public boolean isValid ( Object value ) throws ValidationException { if ( value == null ) { throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; } if ( ! isCorrectDataType ( value ) ) { throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; } if ( value instanceof Date ) { double d = DateConverter . getXLSDateVal ( ( java . util . Date ) value ) ; value = d + "" ; } switch ( typOperator ) { case ValidationHandle . CONDITION_BETWEEN : if ( isBetween ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_NOT_BETWEEN : if ( isNotBetween ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_EQUAL : if ( isEqual ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_GREATER_THAN : if ( isGreaterThan ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_GREATER_OR_EQUAL : if ( isGreaterOrEqual ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_LESS_OR_EQUAL : if ( isLessOrEqual ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_LESS_THAN : if ( isGreaterOrEqual ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; case ValidationHandle . CONDITION_NOT_EQUAL : if ( isNotEqual ( value ) ) { return true ; } throw new ValidationException ( getErrorBoxTitle ( ) , getErrorBoxText ( ) ) ; } return true ; }
va	OUT	?	@ SuppressWarnings ( "unchecked" ) public static < T > T findValueOfType ( Collection < ? > collection , class < T > type ) { if ( isEmpty ( collection ) ) { return null ; } T value = null ; for ( Object element : collection ) { if ( type == null || type . isInstance ( element ) ) { if ( value != null ) { return null ; } value = ( T ) element ; } } return value ; }
va	SYM	,	@ Override public void changed ( ObservableValue < ? extends Number > observable , Number oldValue , Number newValue ) { yearsInteger = ( Integer ) yearsOptions . get ( newValue . intValue ( ) ) ; }
va	KPT	long	public void setPingLatency ( long pingLatency ) { this . pingLatency = pingLatency ; }
va	SYM	,	public boolean unlink ( String from , String to ) { log . trace ( "unlink: {} -> {}" , from , to ) ; Node from_node = getNode ( from ) ; if ( from_node == null ) { return false ; } Node to_node = getNode ( to ) ; if ( to_node == null ) { return false ; } Node virtual_node = from_node . getChild ( to_node . getName ( ) ) ; if ( virtual_node instanceof VirtualNode ) { ( ( VirtualNode ) virtual_node ) . deactivate ( ) ; } return from_node . unmount ( virtual_node ) ; }
va	KEH	throws	void dumpSeqInfo ( ArrayList < Integer > lens , ArrayList < long > weights , String filename ) throws FileNotFoundException { PrintWriter pw = new PrintWriter ( filename ) ; for ( int i = 1 ; i < lens . size ( ) ; ++ i ) { pw . println ( lens . get ( i ) + " " + weights . get ( i ) ) ; } pw . close ( ) ; }
va	OAR	+	public List < Count > getCounts ( String ids ) throws WeiboException { return Count . constructCounts ( get ( getBaseURL ( ) + "statuses/counts.json" , "ids" , ids , true ) ) ; }
va	SYM	,	public void testField ( ) throws Exception { Stub mock = new Stub ( ) ; assertEquals ( 0 , Purview . validateFields ( mock ) . getProblems ( ) . size ( ) ) ; mock . setValue ( "woot" ) ; assertEquals ( 0 , Purview . validateFields ( mock ) . getProblems ( ) . size ( ) ) ; mock . setValue ( "foo9" ) ; assertEquals ( 1 , Purview . validateFields ( mock ) . getProblems ( ) . size ( ) ) ; }
va	OAS	+=	public static void multAddTransA_small ( RowD1Matrix64F A , D1Matrix64F B , D1Matrix64F C ) { if ( C . numCols != 1 ) { throw new MatrixDimensionException ( "C is not a column vector" ) ; } else if ( C . numRows != A . numCols ) { throw new MatrixDimensionException ( "C is not the expected length" ) ; } if ( B . numRows == 1 ) { if ( A . numRows != B . numCols ) { throw new MatrixDimensionException ( "A and B are not compatible" ) ; } } else if ( B . numCols == 1 ) { if ( A . numRows != B . numRows ) { throw new MatrixDimensionException ( "A and B are not compatible" ) ; } } else { throw new MatrixDimensionException ( "B is not a vector" ) ; } int cIndex = 0 ; for ( int i = 0 ; i < A . numCols ; i ++ ) { double total = 0.0 ; int indexA = i ; for ( int j = 0 ; j < A . numRows ; j ++ ) { total += A . get ( indexA ) * B . get ( j ) ; indexA += A . numCols ; } C . + ( cIndex ++ , total ) ; } }
va	KPT	long	public final static native String OfferDataNym_price_per_scale_get ( long jarg1 , OfferDataNym jarg1_ ) ;
va	OAS	+=	protected long addString ( WbXmlEncoder encoder , String s ) throws IOException { long idx = strtblByString . get ( s ) ; if ( idx == null ) { if ( WbXmlEncoder . StrtblType . NO . equals ( encoder . getType ( ) ) ) { throw new IOException ( String . format ( "The strtbl cannot be used for '%s'!" , s ) ) ; } idx = size ; internalAddString ( idx , s ) ; size += strtblByIndex . get ( idx ) . getBytes ( encoder . getCharset ( ) ) . length + 1 ; encoder . setStrtblUsed ( ) ; } return idx ; }
va	KEH	throws	public JSONArray ( String source ) throws JSONException { this ( new JSONTokener ( source ) ) ; }
va	OUT	?	private List < class < ? >> findClasses ( File directory , String packageName ) throws ClassNotFoundException { List < class < ? >> classes = new ArrayList < class < ? >> ( ) ; if ( directory . exists ( ) ) { File [ ] files = directory . listFiles ( ) ; for ( File file : files ) { String fileName = file . getName ( ) ; if ( file . isDirectory ( ) ) { classes . addAll ( findClasses ( file , getClassName ( packageName , fileName ) ) ) ; } else if ( isValidClassName ( fileName ) ) { classes . add ( createClass ( packageName , fileName ) ) ; } } } return classes ; }
va	KFC	case	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
va	ORE	==	public ArrayList < ArrayList < String >> findLadders ( String start , String end , HashSet < String > dict ) { ArrayList < ArrayList < String >> result = new ArrayList < ArrayList < String >> ( ) ; ArrayList < String > path = new ArrayList < String > ( ) ; if ( start == null || end == null || start . length ( ) != end . length ( ) ) { return result ; } bfs ( start , end , dict ) ; dfs ( end , start , dict , path , result ) ; return result ; }
va	OAR	+	public CategoryPanelController ( ) { I18 . getInstance ( ) . setLocale ( "swe" ) ; this . panicController = PanicController . getInstance ( ) ; themeLoader = new ThemeLoader ( ) ; panel = new CategoryPanel ( ) ; this . categoriesModel = new CategoriesModel ( ) ; this . categoriesTable = new JTable ( categoriesModel ) { private static final long serialVersionUID = 1 ; public Component prepareRenderer ( TableCellRenderer renderer , int row , int column ) { Component c = super . prepareRenderer ( renderer , row , column ) ; CategoriesModel model = ( CategoriesModel ) dataModel ; Category category = model . getCategoryAtIndex ( row ) ; c . setBackground ( category . getColor ( ) ) ; return c ; } } ; categoriesTable . setOpaque ( true ) ; categoriesTable . setFont ( new Font ( "Verdana" , Font . PLAIN , 14 ) ) ; categoriesTable . setRowHeight ( ROWHEIGHT ) ; categoriesTable . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; categoriesTable . setShowGrid ( false ) ; categoriesTable . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 240 ) ; categoriesTable . getColumnModel ( ) . setColumnMargin ( 0 ) ; categoriesTable . setTableHeader ( null ) ; categoriesTable . setColumnSelectionAllowed ( false ) ; categoriesTable . getSelectionModel ( ) . addListSelectionListener ( new SelectCategoryAction ( this . categoriesTable ) ) ; this . scrollPane = new JScrollPane ( categoriesTable , JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; scrollPane . setBackground ( themeLoader . getColor ( "white" ) ) ; scrollPane . setBorder ( null ) ; scrollPane . getViewport ( ) . setBackground ( themeLoader . getColor ( "lightGray" ) ) ; this . addCategoryField = new TextFieldWithPlaceholder ( I18 . getInstance ( ) . properties . getString ( "categoryPlaceHolder" ) ) ; Color [ ] colors = new Color [ 6 ] ; for ( int i = 0 ; i < 6 ; i ++ ) { colors [ i ] = themeLoader . getColor ( "categoryColor" + i ) ; } JComboBox colorPicker = new JComboBox ( colors ) ; ColorComboBoxRenderer renderer = new ColorComboBoxRenderer ( ) ; renderer . setPreferredSize ( new Dimension ( 20 , 13 ) ) ; colorPicker . setRenderer ( renderer ) ; colorPicker . setEditable ( true ) ; colorPicker . setEditor ( new ColorComboBoxEditor ( themeLoader . getColor ( "categoryColor1" ) ) ) ; ClockComponent cc = new ClockComponent ( ) ; addButton = new JButton ( new ImageIcon ( this . getClass ( ) . getResource ( "/resources/addIcon.png" ) ) ) ; addButton . addActionListener ( new AddCategoryAction ( panicController , this , colorPicker , addCategoryField ) ) ; this . allCategoriesButton = new JButton ( I18 . getInstance ( ) . properties . getString ( "allTasks" ) ) ; allCategoriesButton . addActionListener ( new ShowAllCategoriesAction ( ) ) ; panel . addCategoryTextField ( this . addCategoryField ) ; panel . addColorPicker ( colorPicker ) ; panel . addNewCategoryButton ( addButton ) ; panel . addCategoriesScrollView ( this . scrollPane ) ; panel . addShowAllCategoriesButton ( this . allCategoriesButton ) ; panel . addClockView ( cc ) ; cc . start ( ) ; updateGUI ( ) ; }
va	KPT	long	public JSONWriter value ( long l ) throws JSONException { return this . append ( long . toString ( l ) ) ; }
va	ORE	==	public void setState ( TristateState state ) { this . state = state ; displayState ( ) ; if ( state == TristateState . INDETERMINATE && isEnabled ( ) ) { fireStateChanged ( ) ; int indeterminate = 3 ; fireItemStateChanged ( new ItemEvent ( this , ItemEvent . ITEM_STATE_CHANGED , this , indeterminate ) ) ; } }
va	OLB	&	public Builder clearAdditionalExecPaths ( ) { bitField1_ = ( bitField1_ & ~ 00000002 ) ; additionalExecPaths_ = getDefaultInstance ( ) . getAdditionalExecPaths ( ) ; onChanged ( ) ; return this ; }
va	OUT	?	private FLWORExpr . OrderSpec orderSpec ( ) { Expression < ? > expr = exprSingle ( ) ; Token t = LA ( 1 ) ; boolean ascending = true ; if ( t . getType ( ) == NC_NAME ) { String text = t . getText ( ) ; if ( text . equals ( "descending" ) ) { ascending = false ; nextToken ( ) ; } else if ( text . equals ( "ascending" ) ) { nextToken ( ) ; } } return new FLWORExpr . OrderSpec ( expr , ascending ) ; }
va	KPT	long	private void cars_useActionPerformed ( java . awt . event . ActionEvent evt ) { long id = ( long ) carTableModel . getValueAt ( cars_table . getSelectedRow ( ) , 0 ) ; Car c = carManager . findCarById ( id ) ; dialog_rents_carInput . setText ( String . valueOf ( c . getId ( ) ) ) ; dialog_rents_carHelper . setText ( String . valueOf ( c . toString ( ) ) ) ; }
va	ORE	==	public JavaType ( String packageName , String name ) { if ( name == null || name . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "name arg must not be null." ) ; } this . name = name ; this . packageName = cleanPackageName ( packageName ) ; }
va	OLB	&	@ Override public void onWrite ( int value ) { vramAddress = ( vramAddress & 00FF ) | ( value << 8 ) ; }
va	OAS	+=	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; int T = scanner . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int N = scanner . nextInt ( ) ; long [ ] array = new long [ N ] ; long sum = 0 ; for ( int n = 0 ; n < N ; n ++ ) { array [ n ] = scanner . nextLong ( ) ; sum += array [ n ] ; } Arrays . sort ( array , Collections . reverseOrder ( ) ) ; PriorityQueue < long > pq = new PriorityQueue < long > ( ) ; pq . add ( 0 ) ; pq . add ( 0 ) ; pq . add ( 0 ) ; for ( int n = 0 ; n < N ; n ++ ) { long i = pq . poll ( ) ; pq . add ( i + array [ n ] ) ; } while ( ! pq . isEmpty ( ) ) { pw . print ( pq . poll ( ) + " " ) ; } pw . println ( ) ; } scanner . close ( ) ; pw . close ( ) ; }
va	KEH	throws	public RowHandle getRow ( int t ) throws RowNotFoundException { Row x = mysheet . getRowByNumber ( t ) ; if ( x == null ) { throw new RowNotFoundException ( "Row " + t + " not found in :" + getSheetName ( ) ) ; } return new RowHandle ( x , this ) ; }
va	SYM	,	@ Override public void setInteger ( final Player index , final String key , final int value ) { this . setString ( index , key , Integer . toString ( value ) ) ; }
va	KPT	char	@ Override public void keyTyped ( KeyEvent e ) { char caracter = e . getKeyChar ( ) ; if ( ( ( caracter < 0 ) || ( caracter > 9 ) ) && ( caracter !=  ) ) { e . consume ( ) ; } else if ( txtElemento . getText ( ) . length ( ) >= 10 ) { txtElemento . setText ( txtElemento . getText ( ) . substring ( 0 , 9 ) ) ; } }
va	KEH	throws	public static Object createValue ( String str , class clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return createURL ( str ) ; } else { return null ; } }
va	OAR	+	private void jBtCancelarActionPerformed ( java . awt . event . ActionEvent evt ) { int opcao = JOptionPane . showConfirmDialog ( null , "Os atendimentos cancelados n\u00E3o ser\u00E3o salvos no sistema.\n" + "Deseja cancelar este atendimento ?" , "Cancelar Atendimento" , JOptionPane . YES_NO_OPTION ) ; if ( opcao == JOptionPane . YES_OPTION ) { if ( ! jTextFieldNrAtendimento . getText ( ) . isEmpty ( ) ) { atd . setNrAtendimento ( Integer . parseInt ( jTextFieldNrAtendimento . getText ( ) ) ) ; AtendimentoMesaProdutos prod = new AtendimentoMesaProdutos ( ) ; prod . setAtendimento ( atd ) ; prod . excluirTodos ( prod ) ; atd . excluir ( atd ) ; rotina = Rotinas . padrao ; validaEstadoCampos ( ) ; limpar . limparCampos ( jPanelAtendimento ) ; limpar . limparJtable ( jTableProdutos ) ; jSpnQuantidade . setValue ( 1 ) ; } rotina = Rotinas . padrao ; validaEstadoCampos ( ) ; limpar . limparCampos ( jPanelAtendimento ) ; limpar . limparJtable ( jTableProdutos ) ; jSpnQuantidade . setValue ( 1 ) ; this . setTitle ( "Realizar Atendimento" ) ; } }
va	KEH	throws	public void trainNetwork ( String csvfile , String outputfile ) throws IOException { File f = new File ( csvfile ) ; if ( f . isFile ( ) ) { MLDataSet trainingD = getTrainingData ( "training.csv" ) ; final ResilientPropagation train = new ResilientPropagation ( getRbfnet ( ) , trainingD ) ; train . iteration ( ) ; System . out . println ( train . getError ( ) ) ; int epoch = 1 ; int epochSave = 1 ; while ( train . getError ( ) > 0.001 ) { train . iteration ( ) ; System . out . println ( "Iteration: " + epoch + " Error: " + train . getError ( ) ) ; epoch ++ ; if ( ( epoch - epochSave ) > 15 ) { saveNetwork ( outputfile ) ; epochSave = epoch ; } } } saveNetwork ( outputfile ) ; }
va	KMD	static	public static DeferredSubst getInstance ( ) { return deferredSubst ; }
va	OAS	+=	private void tallyTagging ( String word , String tag ) { if ( ! isKnown ( word ) ) { totalWordTypes += 1.0 ; typeTagCounter . incrementCount ( tag , 1.0 ) ; } totalTokens += 1.0 ; tagCounter . incrementCount ( tag , 1.0 ) ; wordCounter . incrementCount ( word , 1.0 ) ; wordToTagCounters . incrementCount ( word , tag , 1.0 ) ; }
va	OAR	+	@ Override protected void post ( Message request , Message response ) { String fullName = request . get ( Profile . FULL_NAME ) ; String profileId = new String ( ) ; if ( fullName != null ) { profileId = fullName ; profileId = profileId . replaceAll ( "[?' .]" , " " ) ; profileId = profileId . trim ( ) ; profileId = profileId . replaceAll ( " +" , "" ) ; } else { profileId = "empty" ; } if ( response == null ) { response = new Message ( request . getContext ( ) ) ; } response . put ( Profile . ID , "/" + Profile . RESOURCE_NAME + "/" + profileId ) ; }
va	OAR	+	public Product getItem ( String title , String type ) { product = new Product ( ) ; TypedQuery < Product > query = getEntityManager ( ) . createQuery ( "SELECT p FROM Product p WHERE p.title like '%" + title + "%' and p.type= '" + type + "'" , Product . class ) ; try { product = query . getSingleResult ( ) ; } catch ( NoResultException e ) { return null ; } return product ; }
va	KFC	case	public static String escape ( String string ) { StringBuilder sb = new StringBuilder ( string . length ( ) ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
va	KEH	throws	public void test_24 ( ) throws IOException { int MAX_TEST = 100 ; String vcfFileName = "tests/test.chr1.vcf" ; Random random = new Random ( 20130217 ) ; System . out . println ( "Indexing file '" + vcfFileName + "'" ) ; FileIndexChrPos idx = new FileIndexChrPos ( vcfFileName ) ; idx . setVerbose ( verbose ) ; idx . setDebug ( debug ) ; idx . open ( ) ; idx . index ( ) ; int minPos = Integer . MAX_VALUE , maxPos = Integer . MIN_VALUE ; ArrayList < VcfEntry > vcfEntries = new ArrayList < VcfEntry > ( ) ; VcfFileIterator vcf = new VcfFileIterator ( vcfFileName ) ; for ( VcfEntry ve : vcf ) { vcfEntries . add ( ve ) ; minPos = Math . min ( minPos , ve . getStart ( ) ) ; maxPos = Math . max ( maxPos , ve . getStart ( ) ) ; } minPos -= 1000 ; maxPos += 1000 ; for ( int testNum = 0 ; testNum < MAX_TEST ; ) { int start = random . nextInt ( maxPos - minPos ) + minPos ; int end = random . nextInt ( maxPos - minPos ) + minPos ; if ( end > start ) { System . out . println ( "Dump test (long) " + testNum + "/" + MAX_TEST + "\tchr1:" + start + "\tchr1:" + end ) ; String dump = idx . dump ( "1" , start , end , true ) ; StringBuilder expected = new StringBuilder ( ) ; for ( VcfEntry ve : vcfEntries ) { if ( ( start <= ve . getStart ( ) ) && ( ve . getStart ( ) <= end ) ) { if ( expected . length ( ) > 0 ) expected . append ( "\n" ) ; expected . append ( ve . getLine ( ) ) ; } } if ( expected . length ( ) > 0 ) expected . append ( "\n" ) ; assert . assertEquals ( expected . toString ( ) , dump ) ; testNum ++ ; } } idx . close ( ) ; }
va	SYM	,	public void add ( Gene gene ) { add ( gene , false ) ; }
va	KFC	switch	private Sentence sentence ( ) { Value cond ; Token t = popToken ( ) ; switch ( t . getTokenType ( ) ) { case SBEGIN : pushToken ( t ) ; return compound ( ) ; case SIF : cond = expression ( ) ; expectToken ( TokenType . STHEN ) ; Sentence cons = compound ( ) , alter = null ; if ( testToken ( TokenType . SELSE ) ) { expectToken ( TokenType . SELSE ) ; alter = compound ( ) ; } return new IfSentence ( cond , cons , alter ) ; case SWHILE : cond = expression ( ) ; expectToken ( TokenType . SDO ) ; Sentence whileblock = sentence ( ) ; return new WhileSentence ( cond , whileblock ) ; case SIDENTIFIER : if ( whenToken ( TokenType . SLPAREN ) ) { List < Value > args = expressions ( ) ; expectToken ( TokenType . SRPAREN ) ; return new ApplySentence ( t . getValue ( ) , args ) ; } else if ( testToken ( new TokenType [ ] { TokenType . SASSIGN , TokenType . SLBRACKET } ) ) { pushToken ( t ) ; VariableAssign va = variable ( ) ; expectToken ( TokenType . SASSIGN ) ; Value rexpr = expression ( ) ; return new AssignSentence ( va , rexpr ) ; } else { return new ApplySentence ( t . getValue ( ) ) ; } case SREADLN : if ( ! whenToken ( TokenType . SLPAREN ) ) break ; List < String > va = var_names ( ) ; List < Value > arg_r = new LinkedList < Value > ( ) ; for ( String i : va ) { arg_r . add ( new VariableAssign ( i , "variable" ) ) ; } expectToken ( TokenType . SRPAREN ) ; return new ApplySentence ( t . getValue ( ) , arg_r ) ; case SWRITELN : if ( whenToken ( TokenType . SLPAREN ) ) { List < Value > arg_w = expressions ( ) ; expectToken ( TokenType . SRPAREN ) ; return new ApplySentence ( t . getValue ( ) , arg_w ) ; } else { return new ApplySentence ( t . getValue ( ) , new LinkedList < Value > ( ) ) ; } default : fail ( t ) ; return null ; } fail ( t ) ; return null ; }
va	KEH	throws	public static UShort ushort ( int value ) throws NumberFormatException { return new UShort ( value ) ; }
va	SYM	,	@ Override public void actionPerformed ( ActionEvent arg0 ) { JOptionPane . showMessageDialog ( in , "Sample input is:\n" + "Last1  First1 <any other stuff>\n" + "Last2  First2 <any other stuff>\n" + "Last3  First3   <any other stuff>\n" + "Last4  First4   <any other stuff>\n" + "Last5  First5        <any other stuff>\n" + ".\n" + ".\n" + ".\n" + "The \"  \" need to be exactly that  but anything after First name can be anything otherwise.\n" , "Input Format" , JOptionPane . INFORMATION_MESSAGE ) ; }
va	KPT	long	public LuaValue neg ( ) { return valueOf ( - ( long ) v ) ; }
va	OAR	+	private boolean execEstimateBasedOnCfUsingFrequencies ( VectorMap queryParam , StringBuffer respBody , DBAccess dbAccess ) { try { int clntIdx = queryParam . qpIndexOfKeyNoCase ( "clnt" ) ; String clientName = ( String ) queryParam . getVal ( clntIdx ) ; int ftrsIdx = queryParam . qpIndexOfKeyNoCase ( "ftrs" ) ; String ftrNames = null ; if ( ftrsIdx != - 1 ) { ftrNames = ( String ) queryParam . getVal ( ftrsIdx ) ; } int usrIdx = queryParam . qpIndexOfKeyNoCase ( "usr" ) ; if ( usrIdx == - 1 ) { WebServer . win . log . error ( "-Missing argument: usr" ) ; return false ; } String user = ( String ) queryParam . getVal ( usrIdx ) ; int ftrIdx = queryParam . qpIndexOfKeyNoCase ( "ftr" ) ; if ( ftrIdx == - 1 ) { WebServer . win . log . error ( "-Missing argument: ftr" ) ; return false ; } String ftrPattern = ( String ) queryParam . getVal ( ftrIdx ) ; String [ ] ftrs = ftrPattern . split ( "\\|" ) ; respBody . append ( DBAccess . xmlHeader ( "/resp_xsl/estimation_profile.xsl" ) ) ; respBody . append ( "<result>\n" ) ; String sql ; sql = "SELECT " + DBAccess . CFPROFILE_TABLE_FIELD_NUMVALUE + " FROM " + DBAccess . CFPROFILE_TABLE + " WHERE " + DBAccess . FIELD_PSCLIENT + "='" + clientName + "' AND " + DBAccess . CFPROFILE_TABLE_FIELD_USER + "='" + user + "' AND " + DBAccess . CFPROFILE_TABLE_FIELD_FEATURE + "=?" ; PreparedStatement selectFtr = dbAccess . getConnection ( ) . prepareStatement ( sql ) ; sql = "SELECT " + DBAccess . CFFEATURE_STATISTICS_TABLE_FIELD_VALUE + " FROM " + DBAccess . CFFEATURE_STATISTICS_TABLE + " WHERE " + DBAccess . FIELD_PSCLIENT + "='" + clientName + "' AND " + DBAccess . CFFEATURE_STATISTICS_TABLE_FIELD_USER + "='" + user + "' AND " + DBAccess . CFFEATURE_STATISTICS_TABLE_FIELD_FEATURE + "=? AND " + DBAccess . CFFEATURE_STATISTICS_TABLE_FIELD_TYPE + "=" + DBAccess . STATISTICS_FREQUENCY ; PreparedStatement selectFtrFreq = dbAccess . getConnection ( ) . prepareStatement ( sql ) ; String sql1 = "SELECT " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_DST + " ftr " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_WEIGHT + " FROM " + DBAccess . UFTRASSOCIATIONS_TABLE + " WHERE " + DBAccess . FIELD_PSCLIENT + "='" + clientName + "' AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_USR + "='' AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_SRC + "=? AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_TYPE + "=" + DBAccess . RELATION_PHYSICAL ; String sql2 = "SELECT " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_SRC + " ftr " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_WEIGHT + " FROM " + DBAccess . UFTRASSOCIATIONS_TABLE + " WHERE " + DBAccess . FIELD_PSCLIENT + "='" + clientName + "' AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_USR + "='' AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_DST + "=? AND " + DBAccess . UFTRASSOCIATIONS_TABLE_FIELD_TYPE + "=" + DBAccess . RELATION_PHYSICAL ; sql = "(" + sql1 + ") UNION (" + sql2 + ")" ; PreparedStatement assocs = dbAccess . getConnection ( ) . prepareStatement ( sql ) ; for ( int i = 0 ; i < ftrs . length ; i ++ ) { assocs . setString ( 1 , ftrs [ i ] ) ; assocs . setString ( 2 , ftrs [ i ] ) ; ResultSet rs = assocs . executeQuery ( ) ; ArrayList < String > coFeatures = new ArrayList < String > ( 40 ) ; ArrayList < float > coFeatureWeights = new ArrayList < float > ( 40 ) ; while ( rs . next ( ) ) { coFeatures . add ( rs . getString ( 1 ) ) ; coFeatureWeights . add ( rs . getFloat ( 2 ) ) ; } rs . close ( ) ; int numOfnownCoFtrs = 0 ; float weight = 0.0f ; float sum = 0.0f ; int j = 0 ; for ( String feature : coFeatures ) { selectFtr . setString ( 1 , feature ) ; rs = selectFtr . executeQuery ( ) ; if ( rs . next ( ) ) { numOfnownCoFtrs ++ ; float val = rs . getFloat ( 1 ) ; rs . close ( ) ; selectFtrFreq . setString ( 1 , feature ) ; rs = selectFtrFreq . executeQuery ( ) ; rs . next ( ) ; float freq = rs . getFloat ( 1 ) ; weight += val * freq * coFeatureWeights . get ( j ) ; sum += freq * coFeatureWeights . get ( j ) ; rs . close ( ) ; } else { rs . close ( ) ; } j ++ ; } if ( numOfnownCoFtrs > 0 ) { String record = "<row><ftr>" + ftrs [ i ] + "</ftr><val>" + ( weight / sum ) + "</val><factors>" + ( numOfnownCoFtrs * 1.0 / coFeatureWeights . size ( ) ) + "</factors></row>" ; respBody . append ( record ) ; } else { String record = "<row><ftr>" + ftrs [ i ] + "</ftr><val>uknown</val><factors>" + ( numOfnownCoFtrs * 1.0 / coFeatureWeights . size ( ) ) + "</factors></row>" ; respBody . append ( record ) ; } } selectFtr . close ( ) ; selectFtrFreq . close ( ) ; assocs . close ( ) ; respBody . append ( "</result>" ) ; } catch ( SQLException ex ) { WebServer . win . log . error ( ex . toString ( ) ) ; ex . printStackTrace ( ) ; return false ; } return true ; }
va	OUT	?	private static PlotGroup getGroup1 ( CSVFile file ) throws ParseException { List < Plot < ? >> plots = new ArrayList < Plot < ? >> ( ) ; SeriesBoxAndWhisker series = new SeriesBoxAndWhisker ( file , new Field ( "A" , Analyzer . VALUE ) , new Field ( "B" , Analyzer . VALUE ) , 0.05d , 100 ) ; plots . add ( new PlotBoxAndWhisker ( "Bucketized A vs. V" , new Labels ( "A" , "B" ) , series ) ) ; GnuPlotParams params = new GnuPlotParams ( ) ; params . rotateXTicks = - 90 ; params . keypos = KeyPos . TOP_RIGHT ; params . size = 0.6d ; params . minY = 0d ; params . maxY = 1d ; return new PlotGroup ( "Bucketized A vs. V" , plots , params , 1.0d ) ; }
va	OLB	&	protected void load ( String textureName , String filePath ) { int textureId = GL11 . glGenTextures ( ) ; textureList . put ( textureName , textureId ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , textureId ) ; BufferedImage image = null ; try { image = ImageIO . read ( new File ( filePath ) ) ; } catch ( IOException e ) { e . printStackTrace ( System . err ) ; } int w = image . getWidth ( ) ; int h = image . getHeight ( ) ; int [ ] rgbs = new int [ w * h ] ; image . getRGB ( 0 , 0 , w , h , rgbs , 0 , w ) ; final ByteBuffer byteBuffer = ByteBuffer . allocateDirect ( w * h * 4 ) ; for ( final int p : rgbs ) { final int r = ( p & ( 00ff0000 ) ) >> 16 ; final int g = ( p & ( 0000ff00 ) ) >> 8 ; final int b = p & ( 000000ff ) ; byteBuffer . put ( ( byte ) r ) ; byteBuffer . put ( ( byte ) g ) ; byteBuffer . put ( ( byte ) b ) ; } byteBuffer . rewind ( ) ; GL11 . glTexImage2D ( GL11 . GL_TEXTURE_2D , 0 , 3 , w , h , 0 , GL11 . GL_RGB , GL11 . GL_UNSIGNED_BYTE , byteBuffer ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MIN_FILTER , wrap ? GL11 . GL_NEAREST : GL11 . GL_LINEAR ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , wrap ? GL11 . GL_NEAREST : GL11 . GL_LINEAR ) ; GL11 . glTexParameterf ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , wrap ? GL11 . GL_CLAMP : GL11 . GL_REPEAT ) ; GL11 . glTexParameterf ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , wrap ? GL11 . GL_CLAMP : GL11 . GL_REPEAT ) ; }
va	OLB	&	protected static void mult_BYTE_COMP_Data ( WritableRaster wr ) { ComponentSampleModel csm ; csm = ( ComponentSampleModel ) wr . getSampleModel ( ) ; final int width = wr . getWidth ( ) ; final int scanStride = csm . getScanlineStride ( ) ; final int pixStride = csm . getPixelStride ( ) ; final int [ ] bandOff = csm . getBandOffsets ( ) ; DataBufferByte db = ( DataBufferByte ) wr . getDataBuffer ( ) ; final int base = ( db . getOffset ( ) + csm . getOffset ( wr . getMinX ( ) - wr . getSampleModelTranslateX ( ) , wr . getMinY ( ) - wr . getSampleModelTranslateY ( ) ) ) ; int a = 0 ; int aOff = bandOff [ bandOff . length - 1 ] ; int bands = bandOff . length - 1 ; int b , i ; final byte pixels [ ] = db . getBankData ( ) [ 0 ] ; for ( int y = 0 ; y < wr . getHeight ( ) ; y ++ ) { int sp = base + y * scanStride ; final int end = sp + width * pixStride ; while ( sp < end ) { a = pixels [ sp + aOff ] & FF ; if ( a != FF ) for ( b = 0 ; b < bands ; b ++ ) { i = sp + bandOff [ b ] ; pixels [ i ] = ( byte ) ( ( ( pixels [ i ] & FF ) * a ) >> 8 ) ; } sp += pixStride ; } } }
va	KEH	throws	public Object clone ( ) throws CloneNotSupportedException { PredicatedNodeTest clone = ( PredicatedNodeTest ) super . clone ( ) ; if ( ( null != this . m_proximityPositions ) && ( this . m_proximityPositions == clone . m_proximityPositions ) ) { clone . m_proximityPositions = new int [ this . m_proximityPositions . length ] ; System . arraycopy ( this . m_proximityPositions , 0 , clone . m_proximityPositions , 0 , this . m_proximityPositions . length ) ; } if ( clone . m_lpi == this ) clone . m_lpi = ( LocPathIterator ) clone ; return clone ; }
va	KFC	switch	public String toString ( ) { switch ( this ) { case Red : return "Color.Red" ; case Blue : return "Color.Blue" ; case Green : return "Color.Green" ; default : return "unknown Color" ; } }
va	SYM	,	public void postHandle ( WebContext rc , Object handler , Object result ) throws Exception { }
va	OUT	?	public static < T > int min ( List < T > list , Comparator < ? super T > cmp ) { if ( list == null || list . isEmpty ( ) ) return - 1 ; if ( cmp == null ) return 0 ; Iterator < T > it = list . iterator ( ) ; T b = it . next ( ) ; int r = 0 ; for ( int i = 1 ; it . hasNext ( ) ; ++ i ) { T t = it . next ( ) ; if ( cmp . compare ( t , b ) < 0 ) { b = t ; r = i ; } } return r ; }
va	OLB	&	public static void write ( int x ) { writeByte ( ( x >>> 24 ) & ff ) ; writeByte ( ( x >>> 16 ) & ff ) ; writeByte ( ( x >>> 8 ) & ff ) ; writeByte ( ( x >>> 0 ) & ff ) ; }
va	KFC	case	@ Override public int span ( int row , int column ) { switch ( column ) { case 0 : SpanInfo si1 = columnMap . get ( 0 ) . get ( row ) ; return si1 . num ; case 1 : case 2 : case 3 : case 6 : SpanInfo si2 = columnMap . get ( 2 ) . get ( row ) ; return si2 . num ; default : return 1 ; } }
va	ORE	==	@ Override public boolean isActionArgumentValid ( GameModel model , RequestType type , Object arg ) { if ( type == RequestType . SELECT_CENTER && arg instanceof Card ) { Card card = ( Card ) arg ; if ( card . isBanishable ( ) ) { return true ; } } return false ; }
va	OAS	+=	@ Override public void FinishUpdate ( ) { int tics ; int i ; if ( true ) { i = TICK . GetTime ( ) ; tics = i - lasttic ; lasttic = i ; if ( tics < 1 ) frames ++ ; else { for ( i = 0 ; i < frames * 2 ; i += 2 ) RAWSCREEN [ ( height - 1 ) * width + i ] = ( short ) ffff ; for ( ; i < 20 * 2 ; i += 2 ) RAWSCREEN [ ( height - 1 ) * width + i ] = 0 ; frames = 0 ; } } this . update ( null ) ; }
va	OLB	&	private final static byte [ ] getDecodabet ( int options ) { if ( ( options & URL_SAFE ) == URL_SAFE ) { return _URL_SAFE_DECODABET ; } else if ( ( options & ORDERED ) == ORDERED ) { return _ORDERED_DECODABET ; } else { return _STANDARD_DECODABET ; } }
va	OLB	&	public static void writeShort ( final byte [ ] data , final int offset , final int val ) { data [ offset ] = ( byte ) ( ff & val ) ; data [ offset + 1 ] = ( byte ) ( ff & ( val >>> 8 ) ) ; }
va	KMD	static	public static GameProto . GameAction getGameAction ( Soldier arg_Origin , boolean isSyncCoor , String ActionType , SoldierAttr ... Attrs ) { GameProto . GameObject . Builder gameGameObjectBuilder = GameProto . GameObject . newBuilder ( ) ; ModelAttr . Soldier . Builder Builder = ModelAttr . Soldier . newBuilder ( ) ; for ( int i = 0 ; i < Attrs . length ; i ++ ) { if ( Attrs [ i ] == SoldierAttr . SoldierType ) { Builder . setSoldierType ( arg_Origin . getSoldierType ( ) ) ; continue ; } if ( Attrs [ i ] == SoldierAttr . SoldierLevel ) { Builder . setSoldierLevel ( arg_Origin . getSoldierLevel ( ) ) ; continue ; } if ( Attrs [ i ] == SoldierAttr . SoldierSk1 ) { Builder . setSoldierSk1 ( arg_Origin . getSoldierSk1 ( ) ) ; continue ; } if ( Attrs [ i ] == SoldierAttr . SoldierSk2 ) { Builder . setSoldierSk2 ( arg_Origin . getSoldierSk2 ( ) ) ; continue ; } } if ( isSyncCoor ) { gameGameObjectBuilder . setCoord ( CoordBuilder . buildCoord ( arg_Origin . getCoor ( ) . getX ( ) , arg_Origin . getCoor ( ) . getY ( ) , arg_Origin . getCoor ( ) . getZ ( ) ) ) ; } gameGameObjectBuilder . setGameObjId ( arg_Origin . getGameObjId ( ) ) ; gameGameObjectBuilder . setGameObjType ( arg_Origin . getGameObjType ( ) ) ; gameGameObjectBuilder . setSoldier ( Builder ) ; GameProto . GameAction . Builder gameActionBuilder = GameProto . GameAction . newBuilder ( ) ; gameActionBuilder . setActionType ( ActionType ) ; gameActionBuilder . setGameObj ( gameGameObjectBuilder . build ( ) ) ; return gameActionBuilder . build ( ) ; }
va	OAS	+=	public static String [ ] getNames ( JSONObject jo ) { int length = jo . length ( ) ; if ( length == 0 ) { return null ; } Iterator iterator = jo . keys ( ) ; String [ ] names = new String [ length ] ; int i = 0 ; while ( iterator . hasNext ( ) ) { names [ i ] = ( String ) iterator . next ( ) ; i += 1 ; } return names ; }
va	SYM	,	SVCList [ ] partitionSVCs ( ) throws PAModelException { SVCList svcs = _model . getSVCs ( ) ; int [ ] insvc = SubLists . getInServiceIndexes ( svcs ) ; int nsvc = insvc . length ; int [ ] pv = new int [ nsvc ] , npv = new int [ nsvc ] ; int pvc = 0 , npvc = 0 ; for ( int i : insvc ) { if ( svcs . getSlope ( i ) == 0f ) pv [ pvc ++ ] = i ; else npv [ npvc ++ ] = i ; } return new SVCList [ ] { SubLists . getSVCSublist ( _model . getSVCs ( ) , Arrays . copyOf ( pv , pvc ) ) , SubLists . getSVCSublist ( _model . getSVCs ( ) , Arrays . copyOf ( npv , npvc ) ) } ; }
va	OAS	+=	public void invert ( ) { numerator += denominator ; denominator = numerator - denominator ; numerator = numerator - denominator ; }
va	KFC	switch	@ Override public void apply ( switch sw ) { ( ( Analysis ) sw ) . caseAEscrevaExpLogicaComando ( this ) ; }
va	KMD	static	public static RenderedOp create ( RenderedImage source0 , RenderedImage source1 , RenderingHints hints ) { ParameterBlockJAI pb = new ParameterBlockJAI ( "PolarToComplex" , RenderedRegistryMode . MODE_NAME ) ; pb . setSource ( "source0" , source0 ) ; pb . setSource ( "source1" , source1 ) ; return JAI . create ( "PolarToComplex" , pb , hints ) ; }
va	OAS	+=	public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; }
va	OAR	+	@ Override public String onSpawn ( L2Npc npc ) { for ( L2PcInstance target : npc . getKnownList ( ) . getKnownType ( L2PcInstance . class ) ) { if ( ! target . isDead ( ) && GeoData . getInstance ( ) . canSeeTarget ( npc , target ) && Util . checkIfInRange ( npc . getAggroRange ( ) , npc , target , true ) ) { if ( target . getActiveWeaponInstance ( ) != null && ! npc . isInCombat ( ) && npc . getTarget ( ) == null ) { npc . setTarget ( target ) ; npc . broadcastNpcSay ( ( ( target . getAppearance ( ) . getSex ( ) ) ? "Sister " : "Brother " ) + target . getName ( ) + "  move your weapon away!" ) ; switch ( npc . getNpcId ( ) ) { case 22124 : case 22126 : case 22127 : npc . doCast ( SkillTable . getInstance ( ) . getInfo ( 4589 , 8 ) ) ; break ; default : attack ( ( ( L2Attackable ) npc ) , target ) ; break ; } } } } return super . onSpawn ( npc ) ; }
va	OAR	+	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( l == null ) ? 0 : l . hashCode ( ) ) ; result = prime * result + ( ( m == null ) ? 0 : m . hashCode ( ) ) ; result = prime * result + ( ( r == null ) ? 0 : r . hashCode ( ) ) ; return result ; }
va	KEH	throws	@ Override public void test ( ) throws IOException { FileChannel fc = new RandomAccessFile ( "temp.tmp" , "rw" ) . getChannel ( ) ; IntBuffer ib = fc . map ( FileChannel . MapMode . READ_WRITE , 0 , fc . size ( ) ) . asIntBuffer ( ) ; ib . put ( 0 ) ; for ( int i = 1 ; i < numOfUbuffInts ; i ++ ) { ib . put ( ib . get ( i - 1 ) ) ; } fc . close ( ) ; }
va	SYM	,	byte Next ( byte min , byte max ) ;
va	OAS	+=	public void updateError ( double error ) { this . error += error ; }
va	KEH	throws	@ Test ( expected = StrategyException . class ) public void scoutCannotJumpOverChokePoints ( ) throws StrategyException { addToMockConfiguration ( SCOUT , BLUE , 1 , 1 ) ; addToMockConfiguration ( SCOUT , RED , 5 , 5 ) ; mockGame . setConfigurations ( redMockConfiguration , blueMockConfiguration ) ; mockGame . move ( SCOUT , loc55 , loc95 ) ; }
va	ORE	==	public boolean handleDoor ( int id , int x , int y , int z ) { Doors d = getDoor ( id , x , y , z ) ; if ( d == null ) { if ( DoubleDoors . getSingleton ( ) . handleDoor ( id , x , y , z ) ) { return true ; } return false ; } int xAdjustment = 0 , yAdjustment = 0 ; if ( d . type == 0 ) { if ( d . open == 0 ) { if ( d . originalFace == 0 && d . currentFace == 0 ) { xAdjustment = - 1 ; } else if ( d . originalFace == 1 && d . currentFace == 1 ) { yAdjustment = 1 ; } else if ( d . originalFace == 2 && d . currentFace == 2 ) { xAdjustment = 1 ; } else if ( d . originalFace == 3 && d . currentFace == 3 ) { yAdjustment = - 1 ; } } else if ( d . open == 1 ) { if ( d . originalFace == 0 && d . currentFace == 0 ) { yAdjustment = 1 ; } else if ( d . originalFace == 1 && d . currentFace == 1 ) { xAdjustment = 1 ; } else if ( d . originalFace == 2 && d . currentFace == 2 ) { yAdjustment = - 1 ; } else if ( d . originalFace == 3 && d . currentFace == 3 ) { xAdjustment = - 1 ; } } } else if ( d . type == 9 ) { if ( d . open == 0 ) { if ( d . originalFace == 0 && d . currentFace == 0 ) { xAdjustment = 1 ; } else if ( d . originalFace == 1 && d . currentFace == 1 ) { xAdjustment = 1 ; } else if ( d . originalFace == 2 && d . currentFace == 2 ) { xAdjustment = - 1 ; } else if ( d . originalFace == 3 && d . currentFace == 3 ) { xAdjustment = - 1 ; } } else if ( d . open == 1 ) { if ( d . originalFace == 0 && d . currentFace == 0 ) { xAdjustment = 1 ; } else if ( d . originalFace == 1 && d . currentFace == 1 ) { xAdjustment = 1 ; } else if ( d . originalFace == 2 && d . currentFace == 2 ) { xAdjustment = - 1 ; } else if ( d . originalFace == 3 && d . currentFace == 3 ) { xAdjustment = - 1 ; } } } if ( xAdjustment != 0 || yAdjustment != 0 ) { Objects o = new Objects ( - 1 , d . doorX , d . doorY , d . doorZ , 0 , d . type , 0 ) ; Server . objectHandler . placeObject ( o ) ; } if ( d . doorX == d . originalX && d . doorY == d . originalY ) { d . doorX += xAdjustment ; d . doorY += yAdjustment ; } else { Objects o = new Objects ( - 1 , d . doorX , d . doorY , d . doorZ , 0 , d . type , 0 ) ; Server . objectHandler . placeObject ( o ) ; d . doorX = d . originalX ; d . doorY = d . originalY ; } if ( d . doorId == d . originalId ) { if ( d . open == 0 ) { d . doorId += 1 ; } else if ( d . open == 1 ) { d . doorId -= 1 ; } } else if ( d . doorId != d . originalId ) { if ( d . open == 0 ) { d . doorId -= 1 ; } else if ( d . open == 1 ) { d . doorId += 1 ; } } Server . objectHandler . placeObject ( new Objects ( d . doorId , d . doorX , d . doorY , d . doorZ , getNextFace ( d ) , d . type , 0 ) ) ; return true ; }
va	KMD	static	public static String encode ( final boolean b ) { return b ? "T" : "F" ; }
va	OLB	&	private static void shiftRight ( byte [ ] block ) { int i = 0 ; int bit = 0 ; for ( ; ; ) { int b = block [ i ] & ff ; block [ i ] = ( byte ) ( ( b >>> 1 ) | bit ) ; if ( ++ i == 16 ) { break ; } bit = ( b & 1 ) << 7 ; } }
va	KMD	static	public static void example9 ( ) { WorldSet myWorld = new WorldSet ( ) ; myWorld . addFormula ( a . e . EMPTY_FORMULA ) ; DefaultRule rule1 = new DefaultRule ( ) ; rule1 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule1 . setJustificatoin ( "A & ~B" ) ; rule1 . setConsequence ( "A" ) ; DefaultRule rule2 = new DefaultRule ( ) ; rule2 . setPrerequisite ( a . e . EMPTY_FORMULA ) ; rule2 . setJustificatoin ( "~A & B" ) ; rule2 . setConsequence ( "~A" ) ; RuleSet myRules = new RuleSet ( ) ; myRules . addRule ( rule1 ) ; myRules . addRule ( rule2 ) ; DefaultReasoner loader = new DefaultReasoner ( myWorld , myRules ) ; HashSet < String > extensions = loader . getPossibleScenarios ( ) ; a . e . println ( "Given the world: \n\t" + myWorld . toString ( ) + "\n And the rules \n\t" + myRules . toString ( ) ) ; a . e . println ( "Possible Extensions" ) ; for ( String c : extensions ) { a . e . println ( "\t Ext: Th(W U (" + c + "))" ) ; } }
va	SYM	,	void remove ( Entry < K , V > entry ) throws IllegalArgumentException ;
va	KMD	static	public static byte [ ] readStream ( InputStream is , int initialBufferCapacity ) throws IOException { if ( initialBufferCapacity <= 0 ) { throw new IllegalArgumentException ( "Bad initialBufferCapacity: " + initialBufferCapacity ) ; } byte [ ] buffer = new byte [ initialBufferCapacity ] ; int cursor = 0 ; for ( ; ; ) { int n = is . read ( buffer , cursor , buffer . length - cursor ) ; if ( n < 0 ) { break ; } cursor += n ; if ( cursor == buffer . length ) { byte [ ] tmp = new byte [ buffer . length * 2 ] ; System . arraycopy ( buffer , 0 , tmp , 0 , cursor ) ; buffer = tmp ; } } if ( cursor != buffer . length ) { byte [ ] tmp = new byte [ cursor ] ; System . arraycopy ( buffer , 0 , tmp , 0 , cursor ) ; buffer = tmp ; } return buffer ; }
va	OAS	+=	private void solve_sub_problem ( double A_i , int yi , double C_yi , int active_i , double [ ] alpha_new ) { int r ; assert active_i <= B . length ; double [ ] D = copyOf ( B , active_i ) ; if ( yi < active_i ) D [ yi ] += A_i * C_yi ; ArraySorter . reversedMergesort ( D ) ; double beta = D [ 0 ] - A_i * C_yi ; for ( r = 1 ; r < active_i && beta < r * D [ r ] ; r ++ ) beta += D [ r ] ; beta /= r ; for ( r = 0 ; r < active_i ; r ++ ) { if ( r == yi ) alpha_new [ r ] = Math . min ( C_yi , ( beta - B [ r ] ) / A_i ) ; else alpha_new [ r ] = Math . min ( 0.0 , ( beta - B [ r ] ) / A_i ) ; } }
va	KPT	long	static public long getEntityNumber ( String entity ) { if ( isEntity ( entity ) ) { if ( entity . startsWith ( "&#x" ) ) { return long . parseLong ( entity . substring ( 3 , entity . length ( ) - 1 ) , 16 ) ; } else { return long . parseLong ( entity . substring ( 2 , entity . length ( ) - 1 ) ) ; } } else { throw new IllegalStateException ( String . format ( "The value is not an entity: %s" , entity ) ) ; } }
va	KMD	native	public final static native long OTPassword_getBlockSize ( long jarg1 , OTPassword jarg1_ ) ;
va	KEH	throws	@ Override public List < ShoppingBasket > getShoppingBasketOnUsername ( String username ) throws StorageException { return shoppingBasketRepository . getShoppingBasketOnUsername ( username ) ; }
va	OLB	&	private void ensureMachinesIsMutable ( ) { if ( ! ( ( bitField0_ & 00000010 ) == 00000010 ) ) { machines_ = new java . util . ArrayList < communication . message . Messages . ProcessIdentifier > ( machines_ ) ; bitField0_ |= 00000010 ; } }
va	KEH	throws	@ Override public HandshakeBuilder postProcessHandshakeResponseAsServer ( ClientHandshake request , ServerHandshakeBuilder response ) throws InvalidHandshakeException { response . put ( "Upgrade" , "websocket" ) ; response . put ( "Connection" , request . getFieldValue ( "Connection" ) ) ; response . setHttpStatusMessage ( "Switching Protocols" ) ; String seckey = request . getFieldValue ( "Sec-WebSocket-Key" ) ; if ( seckey == null ) throw new InvalidHandshakeException ( "missing Sec-WebSocket-Key" ) ; response . put ( "Sec-WebSocket-Accept" , generateFinalKey ( seckey ) ) ; return response ; }
va	SYM	,	@ Override public void visitFieldInsn ( final int opcode , final String owner , final String name , final String desc ) { buf . setLength ( 0 ) ; buf . append ( this . name ) . append ( ".visitFieldInsn(" ) . append ( OPCODES [ opcode ] ) . append ( "  " ) ; appendConstant ( owner ) ; buf . append ( "  " ) ; appendConstant ( name ) ; buf . append ( "  " ) ; appendConstant ( desc ) ; buf . append ( ");\n" ) ; text . add ( buf . toString ( ) ) ; }
va	KFC	case	@ Override public Object handleGetObject ( String key ) { switch ( key ) { case "translation" : return "ok" ; case "network.connection.banned" : return "You are banned from the server!" ; case "network.connection.connect" : return "Attempting to connect..." ; case "network.connection.connected" : return "Connection successfully established!" ; case "network.connection.connectexception" : return "The attempt to establish a connection failed!" ; case "network.connection.connectionlost" : return "Connection lost!" ; case "network.connection.disconnect" : return "Attempting to disconnect..." ; case "network.connection.disconnected" : return "Successfully disconnected!" ; case "network.connection.full" : return "The server is full!" ; case "network.connection.invalidserverpassword" : return "Invalid server password!" ; case "network.connection.invalidssp" : return "This client is not compatible with that server!" ; case "network.connection.invalidusername" : return "The server doesn't like the chosen username!" ; case "network.connection.invalidusernamelength" : return "The server doesn't like the chosen username's length!" ; case "network.connection.kicked" : return "Kicked from the server  connection lost!" ; case "network.connection.malformedurlexception" : return "That host does not appear to be valid" ; case "network.connection.shutdown" : return "Server shut down  needed to disconnect!" ; case "network.connection.unknownhostexception" : return "The attempt to establish a connection to an unknown host failed!" ; case "view.dialog.aboutdialog.close" : return "Close" ; case "view.dialog.aboutdialog.text" : return "StainedSock " + StainedSockClient . CLIENT_VERSION + " (c) 2013<br>Developed by:<br><br>Daniel Figge<br>Sven Zirkmann" ; case "view.dialog.connectdialog.address" : return "Address:" ; case "view.dialog.connectdialog.cancel" : return "Cancel" ; case "view.dialog.connectdialog.connect" : return "Connect" ; case "view.dialog.connectdialog.serverpassword" : return "Server password:" ; case "view.dialog.connectdialog.username" : return "Username:" ; case "view.dialog.editbookmarkdialog.address" : return "Address:" ; case "view.dialog.editbookmarkdialog.cancel" : return "Cancel" ; case "view.dialog.editbookmarkdialog.name" : return "Name:" ; case "view.dialog.editbookmarkdialog.save" : return "Save" ; case "view.dialog.editbookmarkdialog.serverpassword" : return "Server password:" ; case "view.dialog.editbookmarkdialog.username" : return "Username:" ; case "view.dialog.exitdialog.cancel" : return "Cancel" ; case "view.dialog.exitdialog.quit" : return "Don't save" ; case "view.dialog.exitdialog.save" : return "Save" ; case "view.dialog.exitdialog.text" : return "Do you want to save the image?" ; case "view.dialog.loaddialog.erroroption" : return "An error occured while loading!" ; case "view.dialog.managebookmarksdialog.add" : return "Add new bookmark" ; case "view.dialog.managebookmarksdialog.add.mnemonic" : return "a" ; case "view.dialog.managebookmarksdialog.connect" : return "Connect" ; case "view.dialog.managebookmarksdialog.connect.mnemonic" : return "c" ; case "view.dialog.managebookmarksdialog.duplicate" : return "Duplicate bookmark" ; case "view.dialog.managebookmarksdialog.duplicate.mnemonic" : return "d" ; case "view.dialog.managebookmarksdialog.edit" : return "Edit bookmark" ; case "view.dialog.managebookmarksdialog.edit.mnemonic" : return "e" ; case "view.dialog.managebookmarksdialog.ok" : return "Ok" ; case "view.dialog.managebookmarksdialog.remove" : return "Remove bookmark" ; case "view.dialog.managebookmarksdialog.remove.mnemonic" : return "r" ; case "view.dialog.managebookmarksdialog.title" : return "Bookmarks" ; case "view.dialog.savedialog.erroroption" : return "An error occured while saving!" ; case "view.dialog.savedialog.filealreadyexists" : return "does already exist.\nDo you want to replace it?" ; case "view.fontchooser.bold" : return "Bold" ; case "view.fontchooser.bolditalic" : return "Bold Italic" ; case "view.fontchooser.cancel" : return "Cancel" ; case "view.fontchooser.fontname" : return "Font name" ; case "view.fontchooser.fontsize" : return "Font size" ; case "view.fontchooser.fontstyle" : return "Font style" ; case "view.fontchooser.italic" : return "Italic" ; case "view.fontchooser.ok" : return "Ok" ; case "view.fontchooser.plain" : return "Plain" ; case "view.fontchooser.sample" : return "Sample" ; case "view.fontchooser.samplestring" : return "Font preview" ; case "view.fontchooser.selectfont" : return "Select font" ; case "view.menu.bookmarksmenu.add" : return "Add to bookmarks" ; case "view.menu.bookmarksmenu.add.mnemonic" : return "a" ; case "view.menu.bookmarksmenu.bookmarks" : return "Bookmarks" ; case "view.menu.bookmarksmenu.bookmarks.mnemonic" : return "b" ; case "view.menu.bookmarksmenu.manage" : return "Manage bookmarks" ; case "view.menu.bookmarksmenu.manage.mnemonic" : return "m" ; case "view.menu.editmenu.antialiasing" : return "Antialiasing" ; case "view.menu.editmenu.antialiasing.mnemonic" : return "a" ; case "view.menu.editmenu.edit" : return "Edit" ; case "view.menu.editmenu.edit.mnemonic" : return "e" ; case "view.menu.editmenu.language" : return "Language" ; case "view.menu.editmenu.language.mnemonic" : return "l" ; case "view.menu.editmenu.redo" : return "Redo" ; case "view.menu.editmenu.redo.mnemonic" : return "r" ; case "view.menu.editmenu.showstatusbar" : return "Show Statusbar" ; case "view.menu.editmenu.showstatusbar.mnemonic" : return "s" ; case "view.menu.editmenu.undo" : return "Undo" ; case "view.menu.editmenu.undo.mnemonic" : return "u" ; case "view.menu.filemenu.about" : return "About StainedSock" ; case "view.menu.filemenu.about.mnemonic" : return "a" ; case "view.menu.filemenu.connect" : return "Connect" ; case "view.menu.filemenu.connect.mnemonic" : return "c" ; case "view.menu.filemenu.disconnect" : return "Disconnect" ; case "view.menu.filemenu.disconnect.mnemonic" : return "d" ; case "view.menu.filemenu.exit" : return "Exit" ; case "view.menu.filemenu.exit.mnemonic" : return "x" ; case "view.menu.filemenu.file" : return "File" ; case "view.menu.filemenu.file.mnemonic" : return "f" ; case "view.menu.filemenu.load" : return "Open..." ; case "view.menu.filemenu.load.mnemonic" : return "o" ; case "view.menu.filemenu.print" : return "Print..." ; case "view.menu.filemenu.print.mnemonic" : return "p" ; case "view.menu.filemenu.saveas" : return "Save As..." ; case "view.menu.filemenu.saveas.mnemonic" : return "s" ; case "view.menu.workspacemenu.clear" : return "Clear" ; case "view.menu.workspacemenu.clear.mnemonic" : return "c" ; case "view.menu.workspacemenu.height" : return "Height:" ; case "view.menu.workspacemenu.setsize" : return "Set Size" ; case "view.menu.workspacemenu.setsize.mnemonic" : return "s" ; case "view.menu.workspacemenu.width" : return "Width:" ; case "view.menu.workspacemenu.workspace" : return "Workspace" ; case "view.menu.workspacemenu.workspace.mnemonic" : return "w" ; case "view.subtoolbar.penciltool.strokesize" : return "Stroke Size" ; case "view.subtoolbar.penciltool.tabletpressure" : return "Tablet pressure controls stroke size (overrides settings)" ; case "view.subtoolbar.pipettetool.samplering" : return "Show Sampling Ring" ; case "view.subtoolbar.replaytool.pause" : return "Pause" ; case "view.subtoolbar.replaytool.play" : return "Play" ; case "view.subtoolbar.replaytool.speed" : return "Replay Speed" ; case "view.subtoolbar.replaytool.stop" : return "Stop" ; case "view.subtoolbar.shapetool.fill" : return "Fill Shapes" ; case "view.subtoolbar.shapetool.line" : return "Line" ; case "view.subtoolbar.shapetool.oval" : return "Oval" ; case "view.subtoolbar.shapetool.shape" : return "Select Shape" ; case "view.subtoolbar.shapetool.strokesize" : return "Stroke Size" ; case "view.subtoolbar.shapetool.polygon" : return "Polygon" ; case "view.subtoolbar.shapetool.rectangle" : return "Rectangle" ; case "view.subtoolbar.shapetool.roundedrectangle" : return "Rounded Rectangle" ; case "view.subtoolbar.shapetool.starpolygon" : return "Star Polygon" ; case "view.subtoolbar.texttool.font" : return "Select font" ; case "view.subtoolbar.texttool.stretch" : return "Stretch text" ; case "view.toolbar.color1" : return "Select Primary Painting Color" ; case "view.toolbar.color2" : return "Select Secondary Painting Color" ; case "view.toolbar.colorreset" : return "Default Primary and Secondary Colors" ; case "view.toolbar.colorswap" : return "Switch Primary and Secondary Colors" ; case "view.toolbar.pencil" : return "Pencil Tool" ; case "view.toolbar.pipette" : return "Pipette Tool" ; case "view.toolbar.pointer" : return "Pointer Tool" ; case "view.toolbar.redo" : return "Redo" ; case "view.toolbar.replay" : return "Replay Tool" ; case "view.toolbar.saveas" : return "Save As..." ; case "view.toolbar.shape" : return "Shape Tool" ; case "view.toolbar.text" : return "Text Tool" ; case "view.toolbar.undo" : return "Undo" ; case "view.userlist.userlist" : return "Userlist:" ; } return null ; }
va	ORE	==	public TBlog ( OAuthVersion version ) { super ( ) ; format . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; if ( version == OAuthVersion . V2 ) { this . baseURL = "https://api.t.sohu.com/" ; this . http . setHttps ( true ) ; } }
va	ORE	==	protected static String getColor ( int current , int max ) { int val = ( int ) ( ( double ) current / ( double ) max * 255d ) ; String sval = Integer . toHexString ( val ) ; if ( sval . length ( ) == 1 ) sval = "0" + sval ; return "#" + sval + sval + sval ; }
va	OUT	?	public List < Group > getGroupList ( ) { return groups == null ? null : groups . groupList ; }
va	OUT	?	public AnnotatedStateMachine ( class < ? > annotatedClass ) throws BadStateMachineSpecification { this ( annotatedClass , ( HashMap ) null ) ; }
va	KFC	case	public static void main ( String [ ] args ) { Menu menu = new Menu ( new MenuItem [ ] { new MenuItem ( "coffee" , "\uD558\uC6B0\uC2A4 \uBE14\uB80C\uB4DC" , 1000 ) , new MenuItem ( "coffee" , "\uB2E4\uD06C \uB85C\uC2A4\uD2B8" , 1500 ) , new MenuItem ( "coffee" , "\uB514\uCE90\uD504" , 1200 ) , new MenuItem ( "coffee" , "\uC5D0\uC2A4\uD504\uB808\uC18C" , 900 ) , new MenuItem ( "tea" , "\uB179\uCC28" , 1000 ) , new MenuItem ( "tea" , "\uBC00\uD06C\uD2F0" , 1200 ) } ) ; System . out . print ( "\uBA54\uB274\uB97C \uC120\uD0DD\uD558\uC138\uC694: " ) ; Scanner keyboard = new Scanner ( System . in ) ; String name = keyboard . nextLine ( ) ; System . out . print ( "\uCD94\uAC00 \uC7AC\uB8CC\uB97C \uC120\uD0DD\uD558\uC138\uC694(\uC6B0\uC720 \uBAA8\uCE74 \uB450\uC720 \uD06C\uB9BC) : " ) ; String condiments = keyboard . nextLine ( ) ; System . out . print ( "\uD560\uC778\uC885\uB958\uB97C \uC785\uB825\uD558\uC138\uC694(1-\uCFE0\uD3F0 2-\uCE74\uB4DC 3-\uC774\uBCA4\uD2B8) : " ) ; int discount = keyboard . nextInt ( ) ; MenuItem menuItem = menu . choose ( name ) ; Barista barista = new Barista ( "\uCD08\uB871" ) ; Beverage beverage = barista . order ( menuItem , condiments ) ; System . out . println ( "\uC8FC\uBB38: " + beverage . getName ( ) ) ; Purchase purchase = null ; switch ( discount ) { case 1 : purchase = new Purchase ( beverage , new CouponDiscount ( ) ) ; break ; case 2 : purchase = new Purchase ( beverage , new CardDiscount ( ) ) ; break ; case 3 : purchase = new Purchase ( beverage , new EventDiscount ( ) ) ; break ; } System . out . println ( "\uAD6C\uB9E4\uAC00\uACA9: " + purchase . cost ( ) ) ; }
va	OAS	|=	private JvmSettingsRow ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { initFields ( ) ; int mutable_bitField0_ = 0 ; com . google . protobuf . UnknownFieldSet . Builder unknownFields = com . google . protobuf . UnknownFieldSet . newBuilder ( ) ; try { boolean done = false ; while ( ! done ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : done = true ; break ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { done = true ; } break ; } case 10 : { if ( ! ( ( mutable_bitField0_ & 00000001 ) == 00000001 ) ) { flag_ = new java . util . ArrayList < org . arbeitspferde . groningen . proto . Event . JvmFlag > ( ) ; mutable_bitField0_ |= 00000001 ; } flag_ . add ( input . readMessage ( org . arbeitspferde . groningen . proto . Event . JvmFlag . PARSER , extensionRegistry ) ) ; break ; } case 18 : { bitField0_ |= 00000001 ; completeCommandline_ = input . readBytes ( ) ; break ; } } } } catch ( com . google . protobuf . InvalidProtocolBufferException e ) { throw e . setUnfinishedMessage ( this ) ; } catch ( java . io . IOException e ) { throw new com . google . protobuf . InvalidProtocolBufferException ( e . getMessage ( ) ) . setUnfinishedMessage ( this ) ; } finally { if ( ( ( mutable_bitField0_ & 00000001 ) == 00000001 ) ) { flag_ = java . util . Collections . unmodifiableList ( flag_ ) ; } this . unknownFields = unknownFields . build ( ) ; makeExtensionsImmutable ( ) ; } }
va	OLB	&	private void doUpdateTrafficMask ( ) { if ( trafficControllingSessions . isEmpty ( ) ) return ; for ( ; ; ) { DatagramSessionImpl session = trafficControllingSessions . poll ( ) ; if ( session == null ) break ; SelectionKey key = session . getSelectionKey ( ) ; if ( key == null ) { scheduleTrafficControl ( session ) ; break ; } if ( ! key . isValid ( ) ) { continue ; } int ops = SelectionKey . OP_READ ; if ( ! session . getWriteRequestQueue ( ) . isEmpty ( ) ) { ops |= SelectionKey . OP_WRITE ; } int mask = session . getTrafficMask ( ) . getInterestOps ( ) ; key . interestOps ( ops & mask ) ; } }
va	OLB	&	private int readFrameType ( final Object [ ] frame , final int index , int v , final char [ ] buf , final Label [ ] labels ) { int type = b [ v ++ ] & FF ; switch ( type ) { case 0 : frame [ index ] = Opcodes . TOP ; break ; case 1 : frame [ index ] = Opcodes . INTEGER ; break ; case 2 : frame [ index ] = Opcodes . float ; break ; case 3 : frame [ index ] = Opcodes . double ; break ; case 4 : frame [ index ] = Opcodes . long ; break ; case 5 : frame [ index ] = Opcodes . null ; break ; case 6 : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case 7 : frame [ index ] = readClass ( v , buf ) ; v += 2 ; break ; default : frame [ index ] = readLabel ( readUnsignedShort ( v ) , labels ) ; v += 2 ; } return v ; }
va	SYM	,	Entry < K , V > removeMin ( ) ;
va	KPT	char	public static String [ ] getArrayObjects ( String array ) { String _array = array ; String [ ] objects = null ; if ( isNotNULLGTZ ( _array ) ) { while ( true ) { String a = null ; final char val = " ; int objCnt ; boolean inValue = false ; int objStart = _array . indexOf ( "{" , 0 ) , objEnd = - 1 ; if ( objStart != - 1 ) { char [ ] _json = _array . substring ( objStart + 1 ) . toCharArray ( ) ; objCnt = 1 ; for ( int i = 0 ; i < _json . length ; i ++ ) { if ( _json [ i ] == { && ! inValue ) { objCnt ++ ; } else if ( _json [ i ] == } && ! inValue ) { objCnt -- ; objEnd = i ; } else if ( _json [ i ] == val ) { inValue = ! inValue ; } if ( objCnt == 0 && objEnd > - 1 && ! inValue ) { try { a = _array . substring ( objStart , objEnd ) + "}" ; } catch ( Exception ex ) { error ( ex ) ; error ( new Exception ( "objStart=" + objStart + "; objEnd=" + objEnd + "; objLng=" + _array . length ( ) ) ) ; } break ; } } } if ( isNULLETZ ( a ) ) { break ; } try { _array = _array . substring ( objEnd ) ; } catch ( Exception ex ) { error ( ex ) ; error ( new Exception ( "objEnd=" + objEnd + "; objLng=" + _array . length ( ) ) ) ; } if ( objects == null ) { objects = new String [ 1 ] ; } else { String [ ] tmpObjects = new String [ objects . length + 1 ] ; System . arraycopy ( objects , 0 , tmpObjects , 0 , objects . length ) ; objects = new String [ tmpObjects . length ] ; System . arraycopy ( tmpObjects , 0 , objects , 0 , tmpObjects . length ) ; tmpObjects = null ; } objects [ objects . length - 1 ] = a ; } } return objects ; }
va	KPT	long	private static long [ ] getSum ( long [ ] v , long [ ] dv , int n ) { for ( int i = 1 ; i <= n ; i ++ ) dv [ i ] = dv [ i - 1 ] + v [ i ] ; return dv ; }
va	OUT	?	public void discard ( Card card ) { if ( players [ turn ] . getHand ( ) . remove ( card ) ) { discard . add ( card ) ; sendAll ( PacketCreator . discardNotify ( card ) ) ; } else { out . println ( "Discard Error. Card " + card + " was not in player's hand." ) ; System . exit ( 1 ) ; return ; } checkAndSendFoot ( ) ; if ( players [ turn ] . isInFoot ( ) && players [ turn ] . getHand ( ) . isEmpty ( ) ) { score [ 0 ] += endRoundScore ( 0 ) ; score [ 1 ] += endRoundScore ( 1 ) ; if ( round < 4 ) { Packet packet ; for ( Player p : players ) { boolean team = p . getNumber ( ) % 2 == 0 ; packet = PacketCreator . endRound ( team ? score [ 0 ] : score [ 1 ] , team ? score [ 1 ] : score [ 0 ] , round + 1 ) ; p . send ( packet ) ; } new Thread ( ) { @ Override public void run ( ) { try { Thread . sleep ( 8000 ) ; } catch ( InterruptedException e ) { } startRound ( ) ; } } . start ( ) ; } round ++ ; } else { endTurn ( ) ; } }
va	KFC	case	@ Override public void hear ( String message , Object sender ) { switch ( message ) { case "ClearOverlay" : listener . hear ( "TickerScene" , this ) ; break ; case "OfferMade" : Offer offer = new Offer ( getSubmittedTransaction ( ) , player ) ; player . setBestOffer ( offer ) ; this . hear ( "TickerScene" , this ) ; break ; default : listener . hear ( message , this ) ; } }
va	KMD	static	public static String strip ( String tostrip , String stripstr ) { StringBuffer stripped = new StringBuffer ( tostrip . length ( ) ) ; while ( tostrip . indexOf ( stripstr ) > - 1 ) { stripped . append ( tostrip . substring ( 0 , tostrip . indexOf ( stripstr ) ) ) ; tostrip = tostrip . substring ( tostrip . indexOf ( stripstr ) + stripstr . length ( ) ) ; } stripped . append ( tostrip ) ; return ( stripped . toString ( ) ) ; }
va	SYM	]	public byte [ ] getSalt ( ) { byte [ ] tmp = new byte [ salt . length ] ; System . arraycopy ( salt , 0 , tmp , 0 , salt . length ) ; return tmp ; }
va	OUT	?	public SoundPoolEntry getRandomSound ( ) { return this . allSoundPoolEntries . size ( ) == 0 ? null : ( SoundPoolEntry ) this . allSoundPoolEntries . get ( this . rand . nextInt ( this . allSoundPoolEntries . size ( ) ) ) ; }
va	KFC	switch	@ Override public void handlePacket ( Player player , Packet packet ) { switch ( packet . getOpcode ( ) ) { case ATTACK : handleNpcAttack ( player , packet ) ; break ; case FIRST_CLICK : handleFirstClick ( player , packet ) ; break ; case SECOND_CLICK : handleSecondClick ( player , packet ) ; break ; case THIRD_CLICK : handleThirdClick ( player , packet ) ; break ; case FOURTH_CLICK : handleFourthClick ( player , packet ) ; break ; case MAGIC_ON_NPC : handleMagicOnNpc ( player , packet ) ; break ; case ITEM_ON_NPC : handleItemOnNpc ( player , packet ) ; break ; } }
va	OUT	?	@ Override public < T extends NativeIntegration > class < ? extends T > canonicalise ( class < T > type ) { if ( type . equals ( Files . class ) ) { return WindowsFiles . class . asSubclass ( type ) ; } return super . canonicalise ( type ) ; }
va	KEH	throws	protected void jbInit ( ) throws Exception { m_progressBar = new JProgressBar ( ) ; m_progressBar . setStringPainted ( true ) ; JPanel basePanel = ( JPanel ) this . getContentPane ( ) ; Border insetsBorder ; insetsBorder = BorderFactory . createEmptyBorder ( 5 , 10 , 5 , 10 ) ; basePanel . setBorder ( insetsBorder ) ; m_infoLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; basePanel . setLayout ( new GridLayout ( 2 , 1 ) ) ; basePanel . add ( m_infoLabel ) ; basePanel . add ( m_progressBar ) ; this . setTitle ( "Doin' the dirty job.." ) ; }
va	KPT	long	public final static native long c_TalonSRX_GetAppliedThrottle ( long jarg1 , long jarg2 ) ;
va	OLB	&	public static long reverse_bits ( long x ) { return precomputed_reverse . get ( ( int ) ( ( x >> 48 ) & FFFF ) ) | precomputed_reverse . get ( ( int ) ( ( x >> 32 ) & FFFF ) ) << 16 | precomputed_reverse . get ( ( int ) ( ( x >> 16 ) & FFFF ) ) << 32 | precomputed_reverse . get ( ( int ) ( x & FFFF ) ) << 48 ; }
va	SYM	,	public IntSetting ( final Preferences preferences , final String key , final int defaultValue , final int maxValue , final int minValue ) { super ( preferences , key , defaultValue ) ; myMaxValue = maxValue ; myMinValue = minValue ; }
va	OLB	&	private int get ( int x ) { int res = 0 ; while ( x != 0 ) { res += tree [ x ] ; x -= ( x & - x ) ; } return res ; }
va	KFC	case	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { switch ( columnIndex ) { case 0 : return saves . get ( rowIndex ) . getName ( ) ; case 1 : return DateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . short ) . format ( saves . get ( rowIndex ) . getCreationDate ( ) ) ; case 2 : return saves . get ( rowIndex ) . getNumberOfTurns ( ) ; case 3 : return DateFormat . getTimeInstance ( ) . format ( saves . get ( rowIndex ) . getDuration ( ) - 3600000 ) ; default : throw new IllegalArgumentException ( ) ; } }
va	OAR	+	public EntriesCollection doDissertationsSearch ( String name , String city , String description , String author , String DACNTI_code , String year , String code , String UDK_idx , int startIndex , int numResults , String orderField , boolean isAsc , boolean isCount ) throws XMPPException { Map < String , String > attributes = new HashMap < String , String > ( ) ; if ( name != null && ! "" . equals ( name ) && ! isOnlyPunctuation ( name ) ) attributes . put ( "name" , name ) ; if ( city != null && ! "" . equals ( city ) && ! isOnlyPunctuation ( city ) ) attributes . put ( "city" , city ) ; if ( description != null && ! "" . equals ( description ) && ! isOnlyPunctuation ( description ) ) attributes . put ( "description" , description ) ; if ( author != null && ! "" . equals ( author ) && ! isOnlyPunctuation ( author ) ) attributes . put ( "author" , author ) ; if ( DACNTI_code != null && ! "" . equals ( DACNTI_code ) && ! isOnlyPunctuation ( DACNTI_code ) ) attributes . put ( "DACNTI_code" , DACNTI_code ) ; if ( year != null && ! "" . equals ( year ) ) attributes . put ( "year" , year ) ; if ( code != null && ! "" . equals ( code ) && ! isOnlyPunctuation ( code ) ) attributes . put ( "code" , code ) ; if ( UDK_idx != null && ! "" . equals ( UDK_idx ) && ! isOnlyPunctuation ( UDK_idx ) ) attributes . put ( "UDK_idx" , UDK_idx ) ; if ( attributes . isEmpty ( ) ) return new EntriesCollection ( ) ; attributes . put ( "startIndex" , "" + startIndex ) ; attributes . put ( "numResults" , "" + numResults ) ; attributes . put ( "orderField" , orderField ) ; attributes . put ( "isAsc" , "" + isAsc ) ; attributes . put ( "isCount" , "" + isCount ) ; attributes . put ( "entryType" , EntryType . diss . toString ( ) ) ; return search ( attributes ) ; }
va	ORE	==	public boolean checkMandatory ( JFrame owner , Object obj , String fieldName ) { if ( obj == null ) { showMessage ( owner , "exception.field.mandatory" , new String [ ] { fieldName } , JOptionPane . WARNING_MESSAGE ) ; return false ; } return true ; }
va	KPT	long	public void receive ( Message msg ) { Address sender = msg . getSrc ( ) ; received_msgs . incrementAndGet ( ) ; long num = senders . get ( sender ) ; if ( num == null ) { num = ( long ) 1 ; senders . putIfAbsent ( sender , num ) ; } long last_seqno = num ; try { num = ( long ) msg . getObject ( ) ; long received_seqno = num ; if ( received_seqno == last_seqno ) senders . put ( sender , last_seqno + 1 ) ; else { notFIFO = true ; assert . fail ( "FAIL: received msg #" + received_seqno + "  expected " + last_seqno ) ; } Address address = channel . getAddress ( ) ; if ( received_seqno % MSGS_PER_STATUS_LINE == 0 && received_seqno > 0 ) System . out . println ( "<" + address + ">:" + "PASS: received msg #" + received_seqno + " from " + sender ) ; } catch ( Exception ex ) { System . err . println ( ex . toString ( ) ) ; } }
va	KPT	long	public ActionListener getKorisnickiRacuniPrepraviJButtonActionListener ( ) { return new ActionListener ( ) { public void actionPerformed ( ActionEvent actionEvent ) { try { long idSelektiranogKorisnika = 0 ; if ( racunovodstvoKorisnickiRacuniJPanel . getTraziJComboBox ( ) . getItemCount ( ) > 0 ) { idSelektiranogKorisnika = ( ( JComboBoxItem ) racunovodstvoKorisnickiRacuniJPanel . getTraziJComboBox ( ) . getSelectedItem ( ) ) . getId ( ) ; } Korisnik noviKorisnik ; try { noviKorisnik = racunovodstvoKorisnickiRacuniJPanel . dajPodatkeONovomKorisniku ( ) ; if ( idSelektiranogKorisnika > 0 ) { noviKorisnik . setId ( idSelektiranogKorisnika ) ; Baza baza = Baza . getBaza ( ) ; baza . azuriraj ( noviKorisnik ) ; JOptionPane . showMessageDialog ( racunovodstvoKorisnickiRacuniJPanel . getParent ( ) , "A\u017Euriranje korisnika je uspje\u0161no." ) ; } else { JOptionPane . showMessageDialog ( racunovodstvoKorisnickiRacuniJPanel . getParent ( ) , "Ne mo\u017Ee se a\u017Eurirati korisnik. Nema selektiranih korisnika." ) ; } } catch ( PodaciNisuValidniException e ) { JOptionPane . showMessageDialog ( racunovodstvoKorisnickiRacuniJPanel . getParent ( ) , e . getMessage ( ) ) ; } } catch ( Exception e ) { } } } ; }
va	KMD	static	public static String getNewSatEnd ( ) { return newSatEnd ; }
va	OUT	?	public void save ( Object object , ConfigurationNode to ) throws ConfigurationException { class < ? > clazz = object . getClass ( ) ; for ( Field field : clazz . getFields ( ) ) { try { Setting setting = field . getAnnotation ( Setting . class ) ; if ( setting != null ) { field . setAccessible ( true ) ; saveField ( object , clazz , field , setting , to ) ; } } catch ( Throwable t ) { throw new ConfigurationException ( "Failed to process @Setting annotations of class " + clazz . getCanonicalName ( ) , t ) ; } } }
va	OAS	|=	protected void encodeNamespaceAttributes ( List < NamespaceAttribute > namespaceAttributes ) throws IOException { if ( namespaceAttributes == null ) return ; for ( NamespaceAttribute att : namespaceAttributes ) { current_octet |= FastInfosetConstants . NAMESPACE_ATTRIBUTE_IDENTIFICATION ; String prefix = att . getPrefix ( ) ; String namespace = att . getNamespace_name ( ) ; if ( ! prefix . isEmpty ( ) ) { current_octet |= FastInfosetConstants . NAMESPACE_ATTRIBUTE_PREFIX_FLAG ; } if ( ! namespace . isEmpty ( ) ) { current_octet |= FastInfosetConstants . NAMESPACE_ATTRIBUTE_NAMESPACE_FLAG ; } flush_currentoctet ( ) ; if ( ! prefix . isEmpty ( ) ) { encodeIdentifyingStringOrIndex ( prefix , vocabulary . prefix ) ; } if ( ! namespace . isEmpty ( ) ) { encodeIdentifyingStringOrIndex ( namespace , vocabulary . namespace ) ; } } if ( ! namespaceAttributes . isEmpty ( ) ) { current_octet |= FastInfosetConstants . TERMINATION_PATTERN << 4 ; flush_currentoctet ( ) ; } }
va	KEH	throws	static Type_GetFields waitForReply ( VirtualMachineImpl vm , PacketStream ps , TypeMirror typeMirror ) throws JDWPException { ps . waitForReply ( ) ; return new Type_GetFields ( vm , ps , typeMirror ) ; }
va	OAR	+	public String toString ( ) { return "Node ID: " + this . id + "\n" + "Person ID: " + this . person_id + "\n" + "Certainty: " + this . certainty + "\n" + "Abnormal: " + this . abnormal + "\n" ; }
va	OUT	?	public boolean retainAll ( Collection < ? > c ) { boolean changed = false ; Iterator < ? extends K > i = ( Iterator < ? extends K > ) c . iterator ( ) ; while ( i . hasNext ( ) ) { K k = i . next ( ) ; if ( ! this . contains ( k ) ) { this . remove ( k ) ; changed = true ; } } return changed ; }
va	KEH	throws	public int peekBitToInt ( int val , int bit ) throws IOException { while ( true ) { if ( bit < availBits ) { val <<= 1 ; if ( ( getBit + bit ) >= BITS_PER_BLURB ) { bit = ( getBit + bit ) % BITS_PER_BLURB ; val |= ( ( buffer [ getByte + 1 ] & ( 80 >> bit ) ) != 0 ) ? 1 : 0 ; } else { val |= ( ( buffer [ getByte ] & ( 80 >> ( getBit + bit ) ) ) != 0 ) ? 1 : 0 ; } return val ; } else { readFromStream ( ) ; } } }
va	ORE	==	public SSLClientIOEventDispatch ( final NHttpClientHandler handler , final SSLContext sslcontext , final SSLIOSessionHandler sslHandler , final HttpParams params ) { super ( ) ; if ( handler == null ) { throw new IllegalArgumentException ( "HTTP client handler may not be null" ) ; } if ( sslcontext == null ) { throw new IllegalArgumentException ( "SSL context may not be null" ) ; } if ( params == null ) { throw new IllegalArgumentException ( "HTTP parameters may not be null" ) ; } this . handler = handler ; this . params = params ; this . sslcontext = sslcontext ; this . sslHandler = sslHandler ; }
va	OLB	&	public boolean method577 ( int i ) { if ( anIntArray776 == null ) { if ( anIntArray773 == null ) return true ; if ( i != 10 ) return true ; boolean flag1 = true ; for ( int k = 0 ; k < anIntArray773 . length ; k ++ ) flag1 &= Model . method463 ( anIntArray773 [ k ] & ffff ) ; return flag1 ; } for ( int j = 0 ; j < anIntArray776 . length ; j ++ ) if ( anIntArray776 [ j ] == i ) return Model . method463 ( anIntArray773 [ j ] & ffff ) ; return true ; }
va	OAS	+=	@ Override public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } int temp = 0 ; for ( int i = 0 ; i < compareArray . length ; i ++ ) { if ( compareArray [ i ] > 0 ) { temp ++ ; if ( temp > 3 ) { score = 30 ; break ; } } else { temp = 0 ; } } return score ; }
va	SYM	,	public String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; }
va	SYM	,	public Transaction createTransaction ( String transactionID , float amount , TransactionMethod transactionMethod ) { Date date = Calendar . getInstance ( ) . getTime ( ) ; Transaction transaction = new Transaction ( transactionID , amount , date , transactionMethod ) ; transactionDAO . createTransaction ( transaction ) ; return transaction ; }
va	OUT	?	public String toString ( ) { return attackerWins ? attacker . getNomen ( ) + "(" + numA + ") successfully attacked " + defender . getNomen ( ) + "(" + numD + ")!" : defender . getNomen ( ) + "(" + numD + ") successfully defended against " + attacker . getNomen ( ) + "(" + numA + ")!" ; }
va	OAR	+	public DBConnect ( String directory ) { try { class . forName ( "org.sqlite.JDBC" ) ; dbConnection = DriverManager . getConnection ( "jdbc:sqlite:savedZoos/" + directory + "/development.sqlite3" ) ; } catch ( ClassNotFoundException | SQLException | HeadlessException e ) { JOptionPane . showMessageDialog ( null , "Error connecting to Database: \n" + e , "alert" , JOptionPane . ERROR_MESSAGE ) ; } }
va	OAS	+=	public void cancelPartyMember ( ) { valuables += partyMemberCost ; }
va	OLB	&	public int contains ( int value ) { IntBTNode res = findNode ( this . root , value ) ; return ( res == null ) ? 0 : res . counts [ value & MASK_NODE_BUFFER ] ; }
va	ORE	==	public IDRegion iDsOf ( BeRangeElement value ) { IDRegion result ; result = ( IDRegion ) ( myRangeElementIDs . fetch ( ( HeaperAsPosition . make ( value ) ) ) ) ; if ( result == null ) { return ( IDRegion ) myGlobalIDSpace . emptyRegion ( ) ; } return result ; }
va	OAR	+	public ResultSet getClientId ( ClientClass clientClass ) { ResultSet result = null ; try { result = query ( "SELECT * " + "From clients " + "WHERE firstName='" + clientClass . getFirstName ( ) + "' AND lastName='" + clientClass . getLastName ( ) + "' AND company='" + clientClass . getCompany ( ) + "' AND email='" + clientClass . getEmail ( ) + "' AND phoneNum='" + clientClass . getPhone ( ) + "' AND address='" + clientClass . getAddress ( ) + "'" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return result ; }
va	OAR	+	public static final synchronized BigDecimal readBigDecimal ( String mess , long dflt ) { String line = "" ; BigDecimal big = null ; boolean finish = false ; String mess0 = "" ; if ( Db . inputTypeInfo ) mess0 = "Input type: BigDecimal\n" ; long dfltF = new long ( dflt ) ; String dfltmess = dfltF . toString ( ) ; mess = mess + "\n" ; System . out . flush ( ) ; while ( ! finish ) { line = JOptionPane . showInputDialog ( mess0 + mess + " [default value = " + dflt + "] " , dfltmess ) ; if ( line != null ) { if ( line . equals ( "" ) ) { big = new BigDecimal ( dfltmess ) ; finish = true ; line = null ; } else { try { big = new BigDecimal ( line ) ; finish = true ; } catch ( NumberFormatException e ) { } } } } return big ; }
va	ORE	==	private Map < ? , ? > createObjectContainer ( ContainerFactory containerFactory ) { if ( containerFactory == null ) return new JSONObject ( ) ; Map < ? , ? > m = containerFactory . createObjectContainer ( ) ; if ( m == null ) return new JSONObject ( ) ; return m ; }
va	OAS	+=	public int currentSegment ( float [ ] coords ) { if ( isDone ( ) ) { throw new NoSuchElementException ( Messages . getString ( "awt.4B" ) ) ; } int type = p . types [ typeIndex ] ; int count = GeneralPath . pointShift [ type ] ; System . arraycopy ( p . points , pointIndex , coords , 0 , count ) ; if ( t != null ) { t . transform ( coords , 0 , coords , 0 , count / 2 ) ; } pointIndex += count ; return type ; }
va	OUT	?	@ Override protected InfoClass < Packetable > foundClass ( class < ? extends Packetable > cls ) { if ( cls . isAnnotationPresent ( Packet . class ) ) { Packet packetInfo = cls . getAnnotation ( Packet . class ) ; return new InfoClass < > ( packetInfo . value ( ) , cls ) ; } return null ; }
va	KMD	static	public static OggPage create ( InputStream source , boolean skipData ) throws IOException , EndOfOggStreamException , OggFormatException { return create ( ( Object ) source , skipData ) ; }
va	ORE	==	public int run ( int [ ] args ) { CPU . loadDataRegister ( addrMode , size . getRealSize ( ) , args ) ; CPU . a . setValue ( CPU . a . getValue ( ) | CPU . dataReg . getValue ( ) ) ; CPU . status . setNegative ( CPU . a . isNegative ( ) ) ; CPU . status . setZero ( CPU . a . getValue ( ) == 0 ) ; int cycles = 2 ; if ( ! CPU . status . isMemoryAccess ( ) ) cycles ++ ; return cycles ; }
va	OUT	?	public static < K , T > Map < K , T > runIdempotentJobsWithRetries ( ExecutorService es , Map < K , ? extends Callable < T >> tasks , final int maxRounds ) { return runIdempotentJobsWithRetries ( es , tasks , maxRounds , null ) ; }
va	OUT	?	public BeanInvocationHandler ( class < ? > classBean ) throws EMException , BeanException { this . classBean = classBean ; System . out . println ( "Creation du proxy de l'EJB " + classBean ) ; if ( classBean . isAnnotationPresent ( Stateful . class ) ) { ajoutBean ( false ) ; EJBContainer . getInstance ( ) . injectEntityManager ( bean ) ; } }
va	KMD	static	public static void fullyZoomIn ( ) { for ( int k = 0 ; k < 15 ; k ++ ) { proxy . send ( new ProxyMouseWheelMessage ( 1 ) ) ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
va	KMD	static	public static void define ( ) { int [ ] a = { } ; int [ ] b = { } ; int [ ] c = null ; int [ ] d = { 1 , 2 } ; System . out . println ( " " + a + b + c + d ) ; System . out . println ( Arrays . toString ( a ) + Arrays . toString ( b ) + Arrays . toString ( c ) + Arrays . toString ( d ) ) ; }
va	KFC	switch	@ Override public AttaqueTemplate getRandomAttaque ( ) { int randomNum = 1 + ( int ) ( Math . random ( ) * nbAttaque ) ; AttaqueTemplate attaque = null ; switch ( randomNum ) { case 1 : attaque = new SegFaultAttaque ( ) ; break ; case 2 : attaque = new BusErrorAttaque ( ) ; break ; case 3 : attaque = new PageFaultAttaque ( ) ; break ; default : attaque = new SalsaExtraForteAttaque ( ) ; } return attaque ; }
va	KPT	long	public Bittorrent ( Object bo ) { Logger . getInstance ( ) . debug ( "Creating Bittorrent with Obj: " + bo . toString ( ) ) ; try { HashMap < String , Object > raw = ( HashMap < String , Object > ) bo ; if ( raw . containsKey ( "announceList" ) ) { Object [ ] announceArray = ( Object [ ] ) raw . get ( "announceList" ) ; for ( Object o : announceArray ) { Object [ ] n = ( Object [ ] ) o ; announceList . add ( ( String ) n [ 0 ] ) ; } } if ( raw . containsKey ( "comment" ) ) comment = raw . get ( "comment" ) . toString ( ) ; if ( raw . containsKey ( "creationDate" ) ) creationDate = new Date ( ( long ) raw . get ( "creationDate" ) ) ; if ( raw . containsKey ( "mode" ) ) mode = getMode ( raw . get ( "mode" ) . toString ( ) ) ; if ( raw . containsKey ( "info" ) ) { try { info = ( HashMap < String , String > ) raw . get ( "info" ) ; } catch ( Exception e ) { Logger . getInstance ( ) . error ( "Error parsing info while creating Bittorrent struct" , e ) ; } } } catch ( ClassCastException e ) { throw new RuntimeException ( "Cannot parse download state" , e ) ; } }
va	KFC	case	public int deltaX ( ) { switch ( this ) { case LEFT : return - 1 ; case RIGHT : return 1 ; default : return 0 ; } }
va	KPT	long	public JSONArray put ( int index , long value ) throws JSONException { this . put ( index , new long ( value ) ) ; return this ; }
va	OLB	&	private void byteLoop ( int width , int height , int bands , int srcPixelStride , int srcLineStride , int [ ] srcBandOffsets , byte [ ] [ ] srcData , int dstPixelStride , int dstLineStride , int [ ] dstBandOffsets , byte [ ] [ ] dstData ) { initByteTable ( ) ; for ( int b = 0 ; b < bands ; b ++ ) { byte [ ] s = srcData [ b ] ; byte [ ] d = dstData [ b ] ; byte [ ] t = byteTable [ b ] ; int heightEnd = dstBandOffsets [ b ] + height ; for ( int dstLineOffset = dstBandOffsets [ b ] , srcLineOffset = srcBandOffsets [ b ] ; dstLineOffset < heightEnd ; dstLineOffset += dstLineStride , srcLineOffset += srcLineStride ) { int widthEnd = dstLineOffset + width ; for ( int dstPixelOffset = dstLineOffset , srcPixelOffset = srcLineOffset ; dstPixelOffset < widthEnd ; dstPixelOffset += dstPixelStride , srcPixelOffset += srcPixelStride ) { d [ dstPixelOffset ] = t [ s [ srcPixelOffset ] & FF ] ; } } } }
va	KFC	case	@ Override public SList < Ficha > obtenerFicha ( String eti ) { eti = eti . toUpperCase ( ) ; switch ( eti ) { case "A" : return casillas [ 0 ] . lista ; case "B" : return casillas [ 1 ] . lista ; case "C" : return casillas [ 2 ] . lista ; case "D" : return casillas [ 3 ] . lista ; case "E" : return casillas [ 4 ] . lista ; case "F" : return casillas [ 5 ] . lista ; case "G" : return casillas [ 6 ] . lista ; case "H" : return casillas [ 7 ] . lista ; case "I" : return casillas [ 8 ] . lista ; case "J" : return casillas [ 9 ] . lista ; case "K" : return casillas [ 10 ] . lista ; case "L" : return casillas [ 11 ] . lista ; case "M" : return casillas [ 12 ] . lista ; case "N" : return casillas [ 13 ] . lista ; case "\u00D1" : return casillas [ 14 ] . lista ; case "O" : return casillas [ 15 ] . lista ; case "P" : return casillas [ 16 ] . lista ; case "Q" : return casillas [ 17 ] . lista ; case "R" : return casillas [ 18 ] . lista ; case "S" : return casillas [ 19 ] . lista ; case "T" : return casillas [ 20 ] . lista ; case "U" : return casillas [ 21 ] . lista ; case "V" : return casillas [ 22 ] . lista ; case "W" : return casillas [ 23 ] . lista ; case "X" : return casillas [ 24 ] . lista ; case "Y" : return casillas [ 25 ] . lista ; case "Z" : return casillas [ 26 ] . lista ; } return null ; }
va	KPT	long	private List < long > createFamily ( long prime , List < long > family ) { if ( family . stream ( ) . allMatch ( member -> arePrimeConcatenatable ( member , prime ) ) ) { family . add ( prime ) ; } return family ; }
va	OAS	+=	static void generatePrimes ( ) { boolean [ ] p = new boolean [ 10000 ] ; p [ 0 ] = p [ 1 ] = true ; pri = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i < 10000 ; i ++ ) { if ( ! p [ i ] ) { pri . add ( i ) ; for ( int j = 2 * i ; j < p . length ; j += i ) { p [ j ] = true ; } } } }
va	KMD	static	private static void setFontToAllNotes ( Font font ) { int noOfNotes = fNotes . size ( ) ; for ( int i = 0 ; i < noOfNotes ; i ++ ) { ( ( StickyNote ) fNotes . elementAt ( i ) ) . setFont ( font ) ; } }
va	ORE	==	public String prePermutation ( String s ) { if ( s == null || s . length ( ) <= 1 ) { return null ; } char [ ] array = s . toCharArray ( ) ; if ( prePermutation ( array ) ) { return new String ( array ) ; } else { return null ; } }
va	OAR	+	public MinuetoImageFile ( URL url ) throws MinuetoFileException { super ( ) ; BufferedImage bufUnacceleratedImage ; if ( url == null ) new MinuetoFileException ( "Could not load null file." ) ; try { bufUnacceleratedImage = ImageIO . read ( url ) ; } catch ( IOException ioe ) { throw new MinuetoFileException ( "Could not load image file " + url . toString ( ) + " ." ) ; } super . setUpImage ( this . convert ( bufUnacceleratedImage ) ) ; }
va	SYM	,	public static void drawString ( String msg , Screen screen , int type , int x , int y , int color , int scale ) { int textWidth = 0 ; for ( int i = 0 ; i < msg . length ( ) ; i ++ ) { int charIndex = chars2 . indexOf ( msg . charAt ( i ) ) ; int charWidth = getCharWidth ( msg . charAt ( i ) ) ; if ( charIndex < 0 ) charIndex = 29 ; screen . render ( x + textWidth + scale * 2 , y , charIndex + 23 * 32 , color , 00 , scale ) ; textWidth = textWidth + charWidth * scale + 1 ; } }
te	ORE	>	public static void main ( String [ ] args ) throws Exception { boolean blockOnClass = false ; if ( args . length > 1 && args [ 1 ] . equalsIgnoreCase ( "-blockOnClass" ) ) { blockOnClass = true ; } if ( args [ 0 ] . equalsIgnoreCase ( "-test1" ) ) { testBlockOnThis ( blockOnClass ) ; } else if ( args [ 0 ] . equalsIgnoreCase ( "-test2" ) ) { test2 ( blockOnClass ) ; } else if ( args [ 0 ] . equalsIgnoreCase ( "-test3" ) ) { test3 ( blockOnClass ) ; } else { System . out . println ( "Usage: org.ecberkeley.css.threading.ex5.BlockOnThis [-test1|-test2|test3] {-blockOnClass} " ) ; } }
te	KPT	byte	private static void initializeG_ENC ( byte [ ] [ ] constraint_matrix , int S , int H , int L , int Kprime ) { for ( int row = S + H ; row < L ; row ++ ) { Tuple tuple = new Tuple ( Kprime , row - S - H ) ; Set < Integer > indexes = encIndexes ( Kprime , tuple ) ; for ( Integer j : indexes ) { constraint_matrix [ row ] [ j ] = 1 ; } } }
te	OAR	*	@ Test public void test ( ) throws Exception { int maxSize = 16 ; ArrayQuick aq = new ArrayQuick ( maxSize ) ; for ( int j = 0 ; j < maxSize ; j ++ ) { long n = ( int ) ( Math . random ( ) * 99 ) ; aq . insert ( n ) ; } aq . display ( ) ; aq . quickSort ( ) ; aq . display ( ) ; }
te	KEH	catch	public String [ ] loadAsmFile ( String filePath ) { int size = 0 ; String [ ] ac = new String [ size ] ; try { FileReader fr = new FileReader ( filePath ) ; LineNumberReader lr = new LineNumberReader ( fr ) ; lr . skip ( long . MAX_VALUE ) ; size = lr . getLineNumber ( ) ; fr . close ( ) ; fr = new FileReader ( filePath ) ; BufferedReader br = new BufferedReader ( fr ) ; ac = new String [ size ] ; for ( int i = 0 ; i < ac . length ; i ++ ) { ac [ i ] = br . readLine ( ) ; } br . close ( ) ; fr . close ( ) ; } catch ( Exception e ) { System . out . println ( e ) ; } return ac ; }
te	KMD	new	public SparseBooleanArray ( int initialCapacity ) { initialCapacity = ArrayUtils . idealIntArraySize ( initialCapacity ) ; mKeys = new int [ initialCapacity ] ; mValues = new boolean [ initialCapacity ] ; mSize = 0 ; }
te	ORE	>	public ArrayList < Actor > getActors ( RectangularShape shape ) { if ( noChildren ( ) ) { ArrayList < Actor > tempActors = new ArrayList < Actor > ( ) ; for ( int x = 0 ; x < props . size ( ) ; x ++ ) { if ( props . get ( x ) instanceof Actor ) tempActors . add ( ( Actor ) props . get ( x ) ) ; } return tempActors ; } else { ArrayList < Actor > tempActors = new ArrayList < Actor > ( ) ; for ( int x = 0 ; x < propChildren . length ; x ++ ) { if ( shape . intersects ( propChildren [ x ] . container ) ) { tempActors . addAll ( propChildren [ x ] . getActors ( shape ) ) ; } } return tempActors ; } }
te	KEH	catch	private static void sleepAWhile ( final int timeToSleep ) { try { Thread . sleep ( timeToSleep ) ; } catch ( final InterruptedException ignore ) { } }
te	KEH	catch	private MaskFormatter getMf2 ( ) { if ( mf2 == null ) { try { mf2 = new MaskFormatter ( "**" ) ; mf2 . setValidCharacters ( " 0123456789" ) ; } catch ( Exception e ) { WizardLogger . error ( "Error creating Numberfield-Formatter" , e ) ; } } return mf2 ; }
te	ORE	>	@ Override protected Iterator < ? extends Agent > getExecutionPolicy ( ActivationStage stage , Collection < ? extends Agent > candidates ) { return new MyIterator ( candidates . iterator ( ) ) ; }
te	KPT	float	void sceneAmbient ( double r , double g , double b , double a ) { writeVector_float ( unsafe , pBase + i3d_t . scene_ambient ( ) , ( float ) a , ( float ) r , ( float ) g , ( float ) b ) ; }
te	OUT	:	public Order ( String ordNum , int max , boolean rand ) { this . ordNum = ordNum ; productList = new ArrayList < Product > ( ) ; partList = new HashMap < String , Integer > ( ) ; partList . put ( "motor" , max ) ; partList . put ( "base" , max ) ; partList . put ( "arms" , max ) ; partList . put ( "wires" , max ) ; partList . put ( "esc" , max ) ; partList . put ( "nazam" , max ) ; partList . put ( "rx" , max ) ; partList . put ( "gcu" , max ) ; partList . put ( "pmu" , max ) ; partList . put ( "iosd" , max ) ; partList . put ( "cables" , max ) ; partList . put ( "landinggear" , max ) ; partList . put ( "imu" , max ) ; partList . put ( "globalmount" , max ) ; partList . put ( "vtx" , max ) ; partList . put ( "gimbal" , max ) ; partList . put ( "cover" , max ) ; partList . put ( "blade" , max ) ; for ( Map . Entry < String , Integer > entry : partList . entrySet ( ) ) { int a ; if ( rand == true ) { Random rnd = new Random ( ) ; a = rnd . nextInt ( max ) ; } else { a = 0 ; } partList . put ( entry . getKey ( ) , max - a ) ; Product m = new Product ( entry . getKey ( ) , entry . getValue ( ) ) ; productList . add ( m ) ; } }
te	ORE	!=	public JSONArray put ( int index , Object value ) throws JSONException { JSONObject . testValidity ( value ) ; if ( index < 0 ) { throw new JSONException ( "JSONArray[" + index + "] not found." ) ; } if ( index < length ( ) ) { this . myArrayList . set ( index , value ) ; } else { while ( index != length ( ) ) { put ( JSONObject . null ) ; } put ( value ) ; } return this ; }
te	OLB	|	public void load ( String saveName ) { try { FileInputStream fin = new FileInputStream ( "\\saves\\" + saveName + "\\world.sav" ) ; ObjectInputStream ois = new ObjectInputStream ( fin ) ; map = ( Map ) ois . readObject ( ) ; ois . close ( ) ; } catch ( IOException | ClassNotFoundException ex ) { Logger . getLogger ( MapManager . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	OAS	=	public MqttInputStream ( InputStream in ) { this . in = new DataInputStream ( in ) ; }
te	ORE	>	public String toString ( ) { try { Enumeration keys = keys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; while ( keys . hasMoreElements ( ) ) { if ( sb . length ( ) > 1 ) { sb . append (   ) ; } Object o = keys . nextElement ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( : ) ; sb . append ( valueToString ( this . myHashMap . get ( o ) ) ) ; } sb . append ( } ) ; return sb . toString ( ) ; } catch ( Exception e ) { return null ; } }
te	OUT	:	public ArrayList < BezierPoint > getPoints ( ) { ArrayList < BezierPoint > curvePoints = new ArrayList < BezierPoint > ( ) ; for ( BezierCurve c : spline ) curvePoints . addAll ( c . getPoints ( ) ) ; return curvePoints ; }
te	KEH	catch	public void func_75759_a ( ) { try { ThreadedFileIOBase . threadedIOInstance . waitForFinish ( ) ; } catch ( InterruptedException interruptedexception ) { interruptedexception . printStackTrace ( ) ; } RegionFileCache . clearRegionFileReferences ( ) ; }
te	OUT	:	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
te	OUT	:	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { KundeDTO kunde = kundeList . get ( rowIndex ) ; Object value = null ; switch ( columnIndex ) { case 0 : value = kunde . getKundeId ( ) ; break ; case 1 : value = kunde . getFirmaNavn ( ) ; break ; case 2 : value = kunde . getKontaktNavn ( ) ; break ; case 3 : value = kunde . getTelefonNr ( ) ; break ; case 4 : value = kunde . getStatus ( ) ; break ; } return value ; }
te	KMD	new	public static Color toRGB ( float h , float s , float l , float alpha ) { if ( s < 0.0f || s > 100.0f ) { String message = "Color parameter outside of expected range - Saturation" ; throw new IllegalArgumentException ( message ) ; } if ( l < 0.0f || l > 100.0f ) { String message = "Color parameter outside of expected range - Luminance" ; throw new IllegalArgumentException ( message ) ; } if ( alpha < 0.0f || alpha > 1.0f ) { String message = "Color parameter outside of expected range - Alpha" ; throw new IllegalArgumentException ( message ) ; } h = h % 360.0f ; h /= 360f ; s /= 100f ; l /= 100f ; float q = 0 ; if ( l < 0.5 ) q = l * ( 1 + s ) ; else q = ( l + s ) - ( s * l ) ; float p = 2 * l - q ; float r = Math . max ( 0 , HueToRGB ( p , q , h + ( 1.0f / 3.0f ) ) ) ; float g = Math . max ( 0 , HueToRGB ( p , q , h ) ) ; float b = Math . max ( 0 , HueToRGB ( p , q , h - ( 1.0f / 3.0f ) ) ) ; r = Math . min ( r , 1.0f ) ; g = Math . min ( g , 1.0f ) ; b = Math . min ( b , 1.0f ) ; return new Color ( r , g , b , alpha ) ; }
te	KFC	for	public static double [ ] subtract ( double [ ] template , double [ ] subtract , boolean common ) { double [ ] result = new double [ common ? Math . min ( template . length , subtract . length ) : Math . max ( template . length , subtract . length ) ] ; for ( int i = 0 ; i < result . length && i < template . length ; i ++ ) result [ i ] = template [ i ] ; for ( int i = 0 ; i < result . length && i < subtract . length ; i ++ ) result [ i ] -= subtract [ i ] ; return result ; }
te	OAS	=	protected void jButtonMapa_actionPerformed ( ActionEvent e ) { String basePath = new File ( "" ) . getAbsolutePath ( ) ; fileDir = basePath + "/teseo_test/eater-1.txt" ; fileName = basePath + "/teseo_test/eater-1.txt" ; loadFile ( ) ; }
te	KMD	class	public CameraModels getBrandModels ( String brandId ) throws JinxException { JinxUtils . validateParams ( brandId ) ; Map < String , String > params = new TreeMap < String , String > ( ) ; params . put ( "method" , "flickr.cameras.getBrandModels" ) ; params . put ( "brand" , brandId ) ; return jinx . flickrGet ( params , CameraModels . class , false ) ; }
te	KEH	throw	@ Override public boolean validate ( ProvidedService object ) throws DatabaseException { List < String > errors = new LinkedList < > ( ) ; if ( object . getService ( ) == null ) { errors . add ( "Nie wprowadzono us\u0142ugi  kt\u00F3ra zosta\u0142a wykonana." ) ; } if ( object . getWorker ( ) == null ) { errors . add ( "Nie wprowadzono pracownika  k\u00F3ry wykona\u0142 us\u0142ug\u0119." ) ; } if ( object . getDate ( ) == null ) { errors . add ( "Nie wprowadzono daty wykonanej us\u0142ugi." ) ; } else { } if ( object . getValue ( ) == double . NaN ) { errors . add ( "Nie wprowadzono warto\u015Bci wykonanej us\u0142ugi." ) ; } else { if ( ! ElementaryValidator . minNumberValidator ( double . valueOf ( object . getValue ( ) ) , 0 ) ) { errors . add ( "Wprowadzona warto\u015B\u0107 wykonanej us\u0142ugi jest mniejsza od zera." ) ; } } if ( ! errors . isEmpty ( ) ) { throw new DatabaseException ( errors ) ; } return true ; }
te	OAR	*	private void initializeToolPanel ( ) { scaleModel = new SpinnerNumberModel ( 100.0 , 1.0 , 1000.0 , 10.0 ) ; scaleSpinner = new JSpinner ( scaleModel ) ; scaleSpinner . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { applySettings ( ) ; } } ) ; toolPanel . add ( scaleSpinner ) ; ButtonGroup directionButtonsGroup = new ButtonGroup ( ) ; ImageIcon icons [ ] = { IconLoader . getIcon ( Icons . DIRECTION_LEFT ) , IconLoader . getIcon ( Icons . DIRECTION_UP ) , IconLoader . getIcon ( Icons . DIRECTION_RIGHT ) , IconLoader . getIcon ( Icons . DIRECTION_DOWN ) } ; final JToggleButton directionButtons [ ] = new JToggleButton [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { final int tmpi = i ; directionButtons [ i ] = new JToggleButton ( ) ; directionButtons [ i ] . setIcon ( icons [ i ] ) ; directionButtons [ i ] . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { if ( directionButtons [ tmpi ] . isSelected ( ) ) { int lastOrientation = nextImageOrientation ; nextImageOrientation = ( ( tmpi - 1 ) * 90 + 360 ) % 360 ; if ( lastOrientation != nextImageOrientation ) applySettings ( ) ; } } } ) ; toolPanel . add ( directionButtons [ i ] ) ; directionButtonsGroup . add ( directionButtons [ i ] ) ; } directionButtons [ 1 ] . setSelected ( true ) ; }
te	OAS	=	public static Pair < Integer , Integer > getCanonicalFractional ( int a , int b ) { int gcd = BigInteger . valueOf ( a ) . gcd ( BigInteger . valueOf ( b ) ) . intValue ( ) ; a /= gcd ; b /= gcd ; return b < 0 ? new Pair < Integer , Integer > ( - a , - b ) : new Pair < Integer , Integer > ( a , b ) ; }
te	SYM	}	public byte decodeSigned16BitsTo8Bits ( short s ) { return ( byte ) ( ( s + short . MIN_VALUE ) >> 8 ) ; }
te	OAS	=	private void findNext ( ) { next = null ; for ( ; pos < size ; pos ++ ) { MessageBytes n1 = getName ( pos ) ; if ( n1 . equalsIgnoreCase ( name ) ) { next = getValue ( pos ) ; break ; } } pos ++ ; }
te	KFC	for	private int getID ( ) { int id = 0 ; if ( par . upper != 0 ) { id = ( byte ) ( data [ par . pos ] & ~ ( - 1 << par . upper ) ) ; Debug . debugOutput ( "\tid upper: " + id , DEBUG ) ; } for ( int i = 1 ; i <= par . len ; i ++ ) { id <<= byte . SIZE ; id |= data [ par . pos + i ] & ~ ( - 1 << byte . SIZE ) ; } if ( par . lower != 0 ) { id <<= par . lower ; int id_lower = data [ par . pos + par . len + 1 ] >> ( par . lower_rest ) ; id_lower = id_lower >= 0 ? id_lower : id_lower ^ ( - 1 << par . lower ) ; Debug . debugOutput ( "\tid lower: " + id_lower , DEBUG ) ; id |= id_lower & ~ ( - 1 << par . lower ) ; } return id ; }
te	OLB	|	public boolean next ( Buffer _buf ) throws Exception { int i , j ; switch ( state ) { case SSH_MSG_KEXDH_REPLY : j = _buf . getInt ( ) ; j = _buf . getByte ( ) ; j = _buf . getByte ( ) ; if ( j != 31 ) { System . err . println ( "type: must be 31 " + j ) ; return false ; } K_S = _buf . getString ( ) ; byte [ ] f = _buf . getMPInt ( ) ; byte [ ] sig_of_H = _buf . getString ( ) ; dh . setF ( f ) ; K = dh . getK ( ) ; buf . reset ( ) ; buf . putString ( V_C ) ; buf . putString ( V_S ) ; buf . putString ( I_C ) ; buf . putString ( I_S ) ; buf . putString ( K_S ) ; buf . putMPInt ( e ) ; buf . putMPInt ( f ) ; buf . putMPInt ( K ) ; byte [ ] foo = new byte [ buf . getLength ( ) ] ; buf . getByte ( foo ) ; sha . update ( foo , 0 , foo . length ) ; H = sha . digest ( ) ; i = 0 ; j = 0 ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; String alg = Util . byte2str ( K_S , i , j ) ; i += j ; boolean result = false ; if ( alg . equals ( "ssh-rsa" ) ) { byte [ ] tmp ; byte [ ] ee ; byte [ ] n ; type = RSA ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; ee = tmp ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; n = tmp ; SignatureRSA sig = null ; try { class c = class . forName ( session . getConfig ( "signature.rsa" ) ) ; sig = ( SignatureRSA ) ( c . newInstance ( ) ) ; sig . init ( ) ; } catch ( Exception e ) { System . err . println ( e ) ; } sig . setPubKey ( ee , n ) ; sig . update ( H ) ; result = sig . verify ( sig_of_H ) ; if ( JSch . getLogger ( ) . isEnabled ( Logger . INFO ) ) { JSch . getLogger ( ) . log ( Logger . INFO , "ssh_rsa_verify: signature " + result ) ; } } else if ( alg . equals ( "ssh-dss" ) ) { byte [ ] q = null ; byte [ ] tmp ; byte [ ] p ; byte [ ] g ; type = DSS ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; p = tmp ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; q = tmp ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; g = tmp ; j = ( ( K_S [ i ++ ] << 24 ) & ff000000 ) | ( ( K_S [ i ++ ] << 16 ) & 00ff0000 ) | ( ( K_S [ i ++ ] << 8 ) & 0000ff00 ) | ( ( K_S [ i ++ ] ) & 000000ff ) ; tmp = new byte [ j ] ; System . arraycopy ( K_S , i , tmp , 0 , j ) ; i += j ; f = tmp ; SignatureDSA sig = null ; try { class c = class . forName ( session . getConfig ( "signature.dss" ) ) ; sig = ( SignatureDSA ) ( c . newInstance ( ) ) ; sig . init ( ) ; } catch ( Exception e ) { System . err . println ( e ) ; } sig . setPubKey ( f , p , q , g ) ; sig . update ( H ) ; result = sig . verify ( sig_of_H ) ; if ( JSch . getLogger ( ) . isEnabled ( Logger . INFO ) ) { JSch . getLogger ( ) . log ( Logger . INFO , "ssh_dss_verify: signature " + result ) ; } } else { System . err . println ( "unknown alg" ) ; } state = STATE_END ; return result ; } return false ; }
te	OUT	:	private boolean _reverseGhosts ( EnumMap < GHOST , MOVE > moves , boolean force ) { boolean reversed = false ; boolean globalReverse = false ; if ( Math . random ( ) < GHOST_REVERSAL ) globalReverse = true ; for ( Entry < GHOST , MOVE > entry : moves . entrySet ( ) ) { Ghost ghost = ghosts . get ( entry . getKey ( ) ) ; if ( currentLevelTime > 1 && ghost . lairTime == 0 && ghost . lastMoveMade != MOVE . NEUTRAL ) { if ( force || ( powerPillWasEaten || globalReverse ) ) { ghost . lastMoveMade = ghost . lastMoveMade . opposite ( ) ; ghost . currentNodeIndex = currentMaze . graph [ ghost . currentNodeIndex ] . neighbourhood . get ( ghost . lastMoveMade ) ; reversed = true ; timeOfLastGlobalReversal = totalTime ; } } } return reversed ; }
te	KMD	new	public void setSortRank ( int newRank ) { if ( ! isSortingAllowed ( ) && newRank != 0 ) { throw new IllegalStateException ( "Cannot sort an unsortable column." ) ; } sortRank = newRank ; }
te	KMD	new	@ java . lang . Override protected Builder newBuilderForType ( com . google . protobuf . GeneratedMessage . BuilderParent parent ) { Builder builder = new Builder ( parent ) ; return builder ; }
te	SYM	{	@ Override public String toString ( ) { return "Computer" ; }
te	OLB	|	private static int toProtected ( int bitmask , boolean b ) { if ( b ) { return ( bitmask | Modifier . protected ) & ( ~ Modifier . public & ~ Modifier . private ) ; } else { return bitmask & ~ Modifier . protected ; } }
te	OAR	*	public GameView ( final int tileSide ) { this . tileSize = new Dimension ( tileSide , tileSide ) ; this . modelSize = Constants . getGameSize ( ) ; Dimension preferredSize = new Dimension ( this . modelSize . width * tileSide , this . modelSize . height * tileSide ) ; setPreferredSize ( preferredSize ) ; }
te	KEH	catch	private void resetComparisonFile ( ) throws ControllerException { try { comparisonFile = new BufferedReader ( new FileReader ( currentComparisonName ) ) ; compareLinesCounter = 0 ; comparisonFailed = false ; if ( gui != null ) gui . setCurrentComparisonLine ( - 1 ) ; } catch ( IOException ioe ) { throw new ControllerException ( "Could not open comparison file " + currentComparisonName ) ; } }
te	OAR	*	double . ( double a [ ] , double b [ ] , int n ) { double product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product += a [ i ] * b [ i ] ; return product ; }
te	OUT	:	@ Override public String updateTariff ( Tariff newTariff ) { Tariff tariff = tariffDAO . getTariff ( newTariff . getId ( ) ) ; Set < Option > options = new HashSet < Option > ( ) ; for ( Option option : newTariff . getOptions ( ) ) { options . add ( optionDAO . getOption ( option . getId ( ) ) ) ; } String message = OptionsValidator . validate ( options ) ; if ( message != null ) { return message ; } tariff . setName ( newTariff . getName ( ) ) ; tariff . setPrice ( newTariff . getPrice ( ) ) ; tariff . setOptions ( options ) ; tariffDAO . updateTariff ( tariff ) ; return null ; }
te	OAR	*	public static void ellipse ( double x , double y , double semiMajorAxis , double semiMinorAxis ) { if ( semiMajorAxis < 0 ) throw new RuntimeException ( "ellipse semimajor axis can't be negative" ) ; if ( semiMinorAxis < 0 ) throw new RuntimeException ( "ellipse semiminor axis can't be negative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * semiMajorAxis ) ; double hs = factorY ( 2 * semiMinorAxis ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . draw ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
te	KPT	byte	public PhotoshopApp13Data parsePhotoshopSegment ( byte bytes [ ] , boolean verbose , boolean strict ) throws ImageReadException , IOException { ArrayList records = new ArrayList ( ) ; List allBlocks = parseAllBlocks ( bytes , verbose , strict ) ; for ( int i = 0 ; i < allBlocks . size ( ) ; i ++ ) { IPTCBlock block = ( IPTCBlock ) allBlocks . get ( i ) ; if ( ! block . isIPTCBlock ( ) ) continue ; records . addAll ( parseIPTCBlock ( block . blockData , verbose ) ) ; } return new PhotoshopApp13Data ( records , allBlocks ) ; }
te	SYM	{	public void setCommodityMetalProducerScheme ( String value ) { this . commodityMetalProducerScheme = value ; }
te	KEH	catch	private boolean runCommand ( String cmd ) { try { String [ ] bashCmd = { "/bin/sh" , "-c" , cmd } ; Process p = Runtime . getRuntime ( ) . exec ( bashCmd ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { System . out . println ( line ) ; line = reader . readLine ( ) ; } p . waitFor ( ) ; return true ; } catch ( InterruptedException e ) { return false ; } catch ( IOException e ) { return false ; } }
te	KFC	for	public void run ( ) { if ( list . isEmpty ( ) ) { return ; } Collection < ProxiedPlayer > players = ProxyServer . getInstance ( ) . getPlayers ( ) ; if ( players . isEmpty ( ) ) { return ; } for ( ProxiedPlayer player : players ) { for ( String line : list . get ( count ) . split ( "\n" ) ) { player . sendMessage ( line ) ; } } count ++ ; if ( ( count + 1 ) > list . size ( ) ) { count = 0 ; } }
te	OUT	!	public void actionPerformed ( ActionEvent arg0 ) { if ( ! txtClient . getText ( ) . isEmpty ( ) && ! txtData . getText ( ) . isEmpty ( ) ) { try { ControladorGenerarEstadistiques estadistiques = new ControladorGenerarEstadistiques ( ) ; tblDades . setModel ( infoTaula ( estadistiques . obtenirComandesTotalCobratRepartidor ( txtClient . getText ( ) , txtData . getText ( ) ) ) ) ; lblTotal . setText ( String . valueOf ( estadistiques . obtenirImporTotalCobratRepartidor ( txtClient . getText ( ) , txtData . getText ( ) ) ) ) ; } catch ( Exception e ) { tirarError ( e . getMessage ( ) ) ; } } else { tirarError ( "Introdueix un Venedor i una Data" ) ; } }
te	KEH	throw	@ Override public ArrayList Listar ( ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
te	OAS	=	public ProduceThread ( String name , Table table ) { super ( name ) ; this . table = table ; }
te	OAR	*	public static void main ( String [ ] args ) throws Exception { BufferedImage mask = ImageIO . read ( new File ( "/tmp/image5.bmp" ) ) ; BufferedImage img = ImageIO . read ( new File ( "/home/remco/data/map/World.bmp" ) ) ; int [ ] maskArray = new int [ 10800 * 5400 ] ; mask . getRGB ( 0 , 0 , 10800 , 5400 , maskArray , 0 , 10800 ) ; int [ ] rgbArray = new int [ 10800 * 5400 ] ; img . getRGB ( 0 , 0 , 10800 , 5400 , rgbArray , 0 , 10800 ) ; int k = 0 ; for ( int i = 0 ; i < 10800 ; i ++ ) { for ( int j = 0 ; j < 5400 ; j ++ ) { if ( ( maskArray [ k ] & ffffff ) == ff ) { rgbArray [ k ] = 85a5ab ; } k ++ ; } } img . setRGB ( 0 , 0 , 10800 , 5400 , rgbArray , 0 , 10800 ) ; ImageIO . write ( img , "bmp" , new File ( "/tmp/world.bmp" ) ) ; }
te	KPT	byte	public static RawValue createRawValue ( byte [ ] b , boolean gift ) { return new ByteArrayRawValueImpl ( b , gift ) ; }
te	KFC	for	public AsyncTileFercher ( int threads , TileImageProvider provider ) { workers = new Worker [ threads ] ; queue = new ArrayBlockingQueue < TileSpec > ( 1024 ) ; for ( int i = 0 ; i < workers . length ; i ++ ) { workers [ i ] = new Worker ( queue , provider ) ; workers [ i ] . start ( ) ; } }
te	SYM	}	public String getName ( ) { return name ; }
te	KPT	byte	public Defrag ( int len ) { this . len = len ; this . blob = new byte [ len ] ; ms1 [ 0 ] = 0 ; ms2 [ 0 ] = len ; for ( int i = 1 ; i < 20 ; i ++ ) ms1 [ i ] = - 1 ; }
te	ORE	>	@ Override public List < User > getUsersSequential ( ) { return new ArrayList < User > ( users ) ; }
te	OUT	:	@ Override public void execute ( Game game , String params ) { List < Npc > npcs ; npcs = game . getCurrentRoom ( ) . getNpcs ( ) ; Npc npc = null ; for ( Npc charac : npcs ) { if ( params . toLowerCase ( ) . contains ( charac . getName ( ) . toLowerCase ( ) ) || params . toLowerCase ( ) . contains ( charac . getShortC ( ) . toLowerCase ( ) ) ) { contains = true ; npc = charac ; } } if ( contains && npc != null ) { if ( npc instanceof Npc ) { System . out . println ( npc . getName ( ) + " Says : " ) ; game . setGameState ( npc . action ( game ) . name ( ) ) ; History hist = History . getHistory ( ) ; hist . add ( params ) ; } else { System . out . println ( "This one can't talk" ) ; } } else { System . out . println ( "This person is not in the room" ) ; } }
te	OAR	*	@ Override public XYChart getChart ( ) { yData . add ( 0.0 ) ; for ( int i = 0 ; i < 50 ; i ++ ) { double lastPoint = yData . get ( yData . size ( ) - 1 ) ; yData . add ( getRandomWalk ( lastPoint ) ) ; } xData = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < yData . size ( ) + 1 ; i ++ ) { xData . add ( i ) ; } errorBars = new ArrayList < double > ( ) ; for ( int i = 0 ; i < yData . size ( ) ; i ++ ) { errorBars . add ( 20 * Math . random ( ) ) ; } xyChart = new XYChartBuilder ( ) . width ( 500 ) . height ( 400 ) . xAxisTitle ( "X" ) . yAxisTitle ( "Y" ) . title ( "Real-time XY Chart with Error Bars" ) . build ( ) ; xyChart . addSeries ( SERIES_NAME , xData , yData , errorBars ) ; return xyChart ; }
te	KPT	byte	public AnimatedEntity ( EntityManager em , Location loc , byte orientation , GridedEntityTileOrientation ... animationFrameIds ) { super ( em , loc , animationFrameIds [ 0 ] , orientation ) ; animationids = animationFrameIds ; handle = 3 ; }
te	SYM	{	@ Override public double getT ( ) { throw new IllegalStateException ( "Didn't hit anything!" ) ; }
te	KPT	float	public void setDetectRange ( float value ) { this . detectRange = value ; }
te	KMD	new	public static boolean isEven ( double x ) { double y = Math . floor ( x ) ; if ( ( x - y ) != 0.0D ) throw new IllegalArgumentException ( "the argument is not an integer" ) ; boolean test = false ; y = Math . floor ( x / 2.0F ) ; if ( ( x / 2.0D - y ) == 0.0D ) test = true ; return test ; }
te	KEH	throw	public void setInitiatingDocument ( OrganizationDocument initiatingDocument ) { if ( ! isFinalized ) { this . initiatingDocument = initiatingDocument ; this . initiatingDocId = initiatingDocument . getDocumentId ( ) ; } else { throw new IllegalStateException ( DocDefaults . DOC_IS_FINALIZED ) ; } }
te	KFC	while	public static String replace ( String input , final String expr , String replacement ) { StringBuilder sb = new StringBuilder ( ) ; int new_index = 0 , index = 0 , len = expr . length ( ) , input_len = input . length ( ) ; while ( true ) { new_index = input . indexOf ( expr , index ) ; if ( new_index == - 1 ) { sb . append ( input . substring ( index , input_len ) ) ; break ; } sb . append ( input . substring ( index , new_index ) ) ; sb . append ( replacement ) ; index = new_index + len ; } return sb . toString ( ) ; }
te	OAR	*	public static double atanh ( double x ) { return 0.5 * Math . log ( Math . sqrt ( ( 1 + x ) / ( 1 - x ) ) ) ; }
te	KPT	byte	@ Test public void testDecodeNullIntCollection ( ) throws IOException { StreamProtocolEncoder encoder = new StreamProtocolEncoder ( ) ; RPCEnvelope request = ( new RPCShellEnvelope ( ) ) . setRpcType ( RPC_TYPE_REQUEST ) . addRpcObjects ( RPCObject . newInstance ( RPC_OBJECT_TYPE_COLLECTION_INT ) . setValue ( null ) ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; encoder . encode ( out , request ) ; byte [ ] rawdata = out . toByteArray ( ) ; assertNotNull ( rawdata ) ; InputStream in = new ByteArrayInputStream ( rawdata ) ; assertNotNull ( in ) ; StreamProtocolDecoder decoder = new StreamProtocolDecoder ( ) ; RPCShellEnvelope decoded = ( RPCShellEnvelope ) decoder . decodeNow ( in ) ; assertEquals ( RPCEnvelope . RPC_TYPE_REQUEST , decoded . getRpcType ( ) ) ; assertEquals ( RPC_OBJECT_TYPE_COLLECTION_INT , decoded . getRpcObjects ( ) . get ( 0 ) . getObjectType ( ) ) ; assertNull ( decoded . getRpcObjects ( ) . get ( 0 ) . getValue ( ) ) ; }
te	OLB	|	private static WorkflowDatacenter createDatacenter ( String name , long seed ) throws Exception { int hosts = Integer . parseInt ( Properties . HOSTS_PERDATACENTER . getProperty ( ) ) ; int ram = 8 * Integer . parseInt ( Properties . MEMORY_PERHOST . getProperty ( ) ) ; int cores = 8 * Integer . parseInt ( Properties . CORES_PERHOST . getProperty ( ) ) ; int mips = 8 * Integer . parseInt ( Properties . MIPS_PERCORE . getProperty ( ) ) ; long storage = 8 * long . parseLong ( Properties . STORAGE_PERHOST . getProperty ( ) ) ; double bw = double . parseDouble ( Properties . INTERNAL_BANDWIDTH . getProperty ( ) ) ; double latency = double . parseDouble ( Properties . INTERNAL_LATENCY . getProperty ( ) ) ; long delay = long . parseLong ( Properties . VM_DELAY . getProperty ( ) ) ; String offerName = Properties . VM_OFFERS . getProperty ( ) ; VMOffers offers = null ; try { class < ? > offerClass = class . forName ( offerName , true , VMOffers . class . getClassLoader ( ) ) ; offers = ( VMOffers ) offerClass . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { e . printStackTrace ( ) ; return null ; } List < Host > hostList = new ArrayList < > ( ) ; for ( int i = 0 ; i < hosts ; i ++ ) { List < Pe > peList = new ArrayList < > ( ) ; for ( int j = 0 ; j < cores ; j ++ ) peList . add ( new Pe ( j , new PeProvisionerSimple ( mips ) ) ) ; hostList . add ( new Host ( i , new RamProvisionerSimple ( ram ) , new BwProvisionerSimple ( 1000000 ) , storage , peList , new VmSchedulerTimeShared ( peList ) ) ) ; } DatacenterCharacteristics characteristics = new DatacenterCharacteristics ( "Xeon" , "Linux" , "Xen" , hostList , 10.0 , 0.0 , 0.00 , 0.00 , 0.00 ) ; return new WorkflowDatacenter ( name , characteristics , new VmAllocationPolicySimple ( hostList ) , bw , latency , mips , delay , offers , seed ) ; }
te	OAR	*	public int getRealLength ( ) { int result = 2 * 5 ; return result ; }
te	KFC	for	@ Override public void run ( ) { while ( ! Vars . stop ) { DatagramSocket sk = null ; try { sk = new DatagramSocket ( 3998 ) ; } catch ( SocketException e1 ) { e1 . printStackTrace ( ) ; } if ( sk == null ) { return ; } try { sk . setSoTimeout ( 5000 ) ; } catch ( SocketException e2 ) { e2 . printStackTrace ( ) ; } ArrayList < User > usersResponded = new ArrayList < User > ( ) ; for ( int i = 0 ; i < ServerMain . uh . users . size ( ) ; i ++ ) { byte [ ] buf = new byte [ 1000 ] ; buf = ( new Cypher ( ) . doCeaserCypher ( "##PING" ) ) . getBytes ( ) ; try { ServerMain . sk . send ( new DatagramPacket ( buf , buf . length , ServerMain . uh . users . get ( i ) . address , 3997 ) ) ; DatagramPacket dgp = new DatagramPacket ( buf , buf . length ) ; sk . receive ( dgp ) ; String rcvd1 = new String ( dgp . getData ( ) , 0 , dgp . getLength ( ) ) ; Logger . writeInfo ( "(PING) MESSAGE RECIEVED: " + rcvd1 ) ; usersResponded . add ( ServerMain . uh . users . get ( i ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } for ( int i = 0 ; i < ServerMain . uh . users . size ( ) ; i ++ ) { if ( ! usersResponded . contains ( ServerMain . uh . users . get ( i ) ) ) { ServerMain . rh . rejectConnection ( ServerMain . uh . users . get ( i ) . address , "Ping timeout!" ) ; ServerMain . uh . setOffline ( ServerMain . uh . users . get ( i ) . nick ) ; } } try { Thread . sleep ( 60000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
te	KPT	byte	public byte [ ] getEncoded ( ) throws IOException { return contentInfo . getEncoded ( ) ; }
te	OUT	!	@ Override @ SuppressWarnings ( "unchecked" ) public void setValue ( @ Nullable ThreadMirror threadMirror , @ Nullable ObjectValueMirror thisObjectValue , @ NotNull Value < ? > value ) { if ( isStatic ( ) && thisObjectValue != null || ! isStatic ( ) && thisObjectValue == null ) { throw new IllegalArgumentException ( ) ; } try { if ( thisObjectValue == null ) { Type_SetValues . process ( vm , parent ( ) , new ImmutablePair < FieldOrPropertyMirror , Value < ? >> ( this , value ) ) ; } else { ObjectReference_SetValues . process ( vm , thisObjectValue , new ImmutablePair < FieldOrPropertyMirror , Value < ? >> ( this , value ) ) ; } } catch ( JDWPException e ) { throw e . asUncheckedException ( ) ; } }
te	ORE	>	public static boolean hasAccounts ( ) { return accounts . size ( ) > 0 ; }
te	ORE	!=	public static void $$ ( final double [ ] x , final double [ ] y ) throws NRException { if ( x . length != y . length ) throw new NRException ( "x.length != y.length" ) ; System . arraycopy ( y , 0 , x , 0 , x . length ) ; }
te	OUT	:	@ Override public long evaluate ( char playerColour , char enemyColour , Game game , List < Leaf > children ) { return enemyColour == game . getColourOfStone ( x , y ) ? 1 : 0 ; }
te	OUT	!	private void jTextFieldCdFuncionarioFocusLost ( java . awt . event . FocusEvent evt ) { if ( ! jTextFieldCdFuncionario . getText ( ) . equals ( "" ) ) { try { usuario . getFuncionario ( ) . setCdFuncionario ( Integer . parseInt ( jTextFieldCdFuncionario . getText ( ) ) ) ; usuario . getFuncionario ( ) . retornaFuncionario ( usuario . getFuncionario ( ) , false ) ; if ( usuario . getFuncionario ( ) . getPessoa ( ) . getNome ( ) . equals ( "" ) ) { jTextFieldCdFuncionario . setText ( "" ) ; jTextFieldNomeFuncionario . setText ( "" ) ; jTextFieldCdFuncionario . grabFocus ( ) ; } else { jTextFieldNomeFuncionario . setText ( usuario . getFuncionario ( ) . getPessoa ( ) . getNome ( ) ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( null , "Por favor informe um c\u00F3digo!" ) ; jTextFieldCdFuncionario . setText ( "" ) ; jTextFieldNomeFuncionario . setText ( "" ) ; jTextFieldCdFuncionario . grabFocus ( ) ; } } }
te	OLB	|	public int foo ( int | ) { return | + 17 + 5 ; }
te	KEH	catch	private void addFileDropTarget ( Composite parent ) { final FileTransfer fileTransfer = FileTransfer . getInstance ( ) ; DropTarget target = new DropTarget ( parent , DND . DROP_COPY | DND . DROP_DEFAULT ) ; target . setTransfer ( new Transfer [ ] { fileTransfer } ) ; target . addDropListener ( new DropTargetListener ( ) { public void dragEnter ( DropTargetEvent event ) { if ( event . detail == DND . DROP_DEFAULT ) { if ( ( event . operations & DND . DROP_COPY ) > 0 ) { event . detail = DND . DROP_COPY ; } else { event . detail = DND . DROP_NONE ; } } } public void drop ( DropTargetEvent event ) { if ( fileTransfer . isSupportedType ( event . currentDataType ) ) { String [ ] files = ( String [ ] ) event . data ; for ( String file : files ) { try { controller . openFile ( file ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; displayErrorMessage ( "Error loading file: " + e . getMessage ( ) ) ; } } } } public void dropAccept ( DropTargetEvent event ) { } public void dragOver ( DropTargetEvent event ) { } public void dragOperationChanged ( DropTargetEvent event ) { } public void dragLeave ( DropTargetEvent event ) { } } ) ; }
te	KEH	catch	public static void main ( String [ ] args ) { try { new AnalyzeSammaGui ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } catch ( ClassCastException e ) { e . printStackTrace ( ) ; } }
te	KFC	while	public static < T > void partial_sum ( Iterator < T > listIter , ListIterator < T > targetIter , BinaryOperator < T > op ) { T result = null ; while ( listIter . hasNext ( ) ) { result = op . apply ( result , listIter . next ( ) ) ; targetIter . next ( ) ; targetIter . set ( result ) ; } }
te	KPT	byte	public ByteVector putUTF ( final String s ) { int charLength = s . length ( ) ; int byteLength = 0 ; for ( int i = 0 ; i < charLength ; ++ i ) { char c = s . charAt ( i ) ; if ( c >=  && c <=  ) { byteLength ++ ; } else if ( c >  ) { byteLength += 3 ; } else { byteLength += 2 ; } } if ( byteLength > 65535 ) { throw new IllegalArgumentException ( ) ; } int length = this . length ; if ( length + 2 + byteLength > data . length ) { enlarge ( 2 + byteLength ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) ( byteLength >>> 8 ) ; data [ length ++ ] = ( byte ) ( byteLength ) ; for ( int i = 0 ; i < charLength ; ++ i ) { char c = s . charAt ( i ) ; if ( c >=  && c <=  ) { data [ length ++ ] = ( byte ) c ; } else if ( c >  ) { data [ length ++ ] = ( byte ) ( E0 | c >> 12 & F ) ; data [ length ++ ] = ( byte ) ( 80 | c >> 6 & 3F ) ; data [ length ++ ] = ( byte ) ( 80 | c & 3F ) ; } else { data [ length ++ ] = ( byte ) ( C0 | c >> 6 & 1F ) ; data [ length ++ ] = ( byte ) ( 80 | c & 3F ) ; } } this . length = length ; return this ; }
te	KMD	new	private static TickProvider getTickProvider ( ) { if ( _tickProvider == null ) { _tickProvider = new StopwatchTickProvider ( ) ; } return _tickProvider ; }
te	OAR	*	public InputTextImpl ( File file , int bytesInRecord , int blockSize ) throws IOException { this . file = file ; this . blockSize = blockSize ; this . blockSizeInBytes = blockSize * bytesInRecord ; this . bytesInRecord = bytesInRecord ; in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) , blockSizeInBytes ) ; }
te	OAR	*	public void render ( Screen screen ) { screen . clear ( 0 ) ; Font . draw ( "About Minicraft" , screen , 2 * 8 + 4 , 1 * 8 , Color . get ( 0 , 555 , 555 , 555 ) ) ; Font . draw ( "Minicraft was made" , screen , 0 * 8 + 4 , 3 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "by Markus Persson" , screen , 0 * 8 + 4 , 4 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "For the 22'nd ludum" , screen , 0 * 8 + 4 , 5 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "dare competition in" , screen , 0 * 8 + 4 , 6 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "december 2011." , screen , 0 * 8 + 4 , 7 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "it is dedicated to" , screen , 0 * 8 + 4 , 9 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; Font . draw ( "my father. <3" , screen , 0 * 8 + 4 , 10 * 8 , Color . get ( 0 , 333 , 333 , 333 ) ) ; }
te	ORE	!=	@ Override public String prepareLogMessage ( int type , String msg , Throwable throwable ) { StringWriter stackTrace = new StringWriter ( ) ; if ( throwable != null ) { throwable . printStackTrace ( new PrintWriter ( stackTrace ) ) ; } return ( getDate ( ) + "\t" + Logger . MSG_TYPE_STRING [ type ] + ": " + msg + stackTrace . toString ( ) ) ; }
te	KFC	for	public List < List < Point2D >> getPaths ( ) { PdfArray pathsObject = ( PdfArray ) getBaseDataObject ( ) . get ( PdfName . InkList ) ; List < List < Point2D >> paths = new ArrayList < List < Point2D >> ( ) ; double pageHeight = getPage ( ) . getBox ( ) . getHeight ( ) ; for ( int pathIndex = 0 , pathLength = pathsObject . size ( ) ; pathIndex < pathLength ; pathIndex ++ ) { PdfArray pathObject = ( PdfArray ) pathsObject . get ( pathIndex ) ; List < Point2D > path = new ArrayList < Point2D > ( ) ; for ( int pointIndex = 0 , pointLength = pathObject . size ( ) ; pointIndex < pointLength ; pointIndex += 2 ) { path . add ( new Point2D . double ( ( ( PdfNumber < ? > ) pathObject . get ( pointIndex ) ) . getDoubleValue ( ) , pageHeight - ( ( PdfNumber < ? > ) pathObject . get ( pointIndex + 1 ) ) . getDoubleValue ( ) ) ) ; } paths . add ( path ) ; } return paths ; }
te	OLB	|	@ Test public void decodeFormat_5_Inavlid ( ) { int dst = rand . nextInt ( 8 ) ; int src = rand . nextInt ( 8 ) ; int msb = 0 ; for ( int i = 0 ; i < 3 ; ++ i ) { int instr = ( 010001 << 10 ) | ( i << 8 ) | ( msb << 6 ) | ( src << 3 ) | dst ; when ( mockedMM . fetchHalfWord ( 0 ) ) . thenReturn ( instr ) ; cpu . fetch ( ) ; Opcode op = cpu . decode ( ) ; assertOpcodeWithNoOperands ( op , "???" , "" ) ; } for ( int i = 10 ; i <= 11 ; ++ i ) { int instr = ( 010001 << 10 ) | ( 11 << 8 ) | ( i << 6 ) | ( src << 3 ) | dst ; when ( mockedMM . fetchHalfWord ( 0 ) ) . thenReturn ( instr ) ; cpu . fetch ( ) ; Opcode op = cpu . decode ( ) ; assertOpcodeWithNoOperands ( op , "???" , "" ) ; } }
te	OLB	|	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
te	KMD	new	public Type getType ( String name ) { Type result = getTypes ( ) . get ( name ) ; if ( result == null ) throw new InternalCompilationStorkException ( "No such type: " + name ) ; return result ; }
te	KFC	for	private void setHeaders ( ) { String [ ] arrayOfHeaders = fullHeaders . split ( "\r\n" , 2 ) [ 1 ] . split ( "\r\n" ) ; for ( String header : arrayOfHeaders ) { String headerName = header . split ( ":" ) [ 0 ] . toLowerCase ( ) ; String value = header . split ( ":" ) [ 1 ] . trim ( ) ; headers . put ( headerName , value ) ; } }
te	OAR	*	public PeakValCalcOkaya ( CyberShake cybershake , String name , String version , String jobID ) { super ( cybershake , CyberShake . NAMESPACE , name , version , jobID ) ; double runtime = cybershake . generateDouble ( "PeakValCalcOkaya" ) * cybershake . getRuntimeFactor ( ) ; addAnnotation ( "runtime" , String . format ( "%.2f" , runtime * cybershake . getRuntimeFactor ( ) ) ) ; }
te	OLB	|	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Cancel" ) ) { in . dispose ( ) ; return ; } try { NetworkPrinter netp = new NetworkPrinter ( ) ; status . setText ( "Sending file ... please wait" ) ; in . repaint ( ) ; networkip = tf2 . getText ( ) ; storeConfig ( ) ; int flags = 0 ; if ( autostart . isSelected ( ) ) { flags = ( flags | NetworkPrinter . AUTOSTART_PRINT ) ; } if ( autosave . isSelected ( ) ) { flags = ( flags | NetworkPrinter . AUTOSAVE_MODEL ) ; } netp . sendToReceiver ( networkip , gp . model , flags ) ; status . setText ( "Sending file ... done" ) ; in . repaint ( ) ; in . setVisible ( false ) ; } catch ( UnknownHostException uh ) { status . setText ( "Invalid IP address:" + uh . getMessage ( ) ) ; in . repaint ( ) ; } catch ( ConnectException ce ) { status . setText ( "Connect error:" + ce . getMessage ( ) ) ; in . repaint ( ) ; } catch ( IOException e2 ) { status . setText ( "IO Error:" + e2 . getMessage ( ) ) ; in . repaint ( ) ; } catch ( Exception e2 ) { status . setText ( "Error:" + e2 . getMessage ( ) ) ; in . repaint ( ) ; } }
te	SYM	}	public void setListID ( String value ) { this . listID = value ; }
te	KFC	for	@ Override protected ArrayList < Transaction > mapResults ( ArrayList < HashMap < String , Field >> results ) { ArrayList < Transaction > addresses = new ArrayList < Transaction > ( results . size ( ) ) ; for ( HashMap < String , Field > result : results ) { addresses . add ( new Transaction ( result ) ) ; } return addresses ; }
te	OAS	=	public void start ( ) { this . status = Status . RUNNING ; for ( int i = 0 ; i < THREAD_COUNT ; i ++ ) { threads . get ( i ) . start ( ) ; } }
te	OUT	:	double seqConserv ( int position ) { double sMax = 2.0 ; double sObs = 0 ; for ( char base : Pwm . BASES ) { double p = baseFrecuency ( base , position ) ; sObs += - p * log2 ( p ) ; } return ( sMax - sObs ) / sMax ; }
te	KEH	throw	public static byte [ ] decode ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { if ( source == null ) { throw new NullPointerException ( "Cannot decode null source array." ) ; } if ( off < 0 || off + len > source . length ) { throw new IllegalArgumentException ( String . format ( "Source array with length %d cannot have offset of %d and process %d bytes." , source . length , off , len ) ) ; } if ( len == 0 ) { return new byte [ 0 ] ; } else if ( len < 4 ) { throw new IllegalArgumentException ( "Base64-encoded string must have at least four characters  but length specified was " + len ) ; } byte [ ] DECODABET = getDecodabet ( options ) ; int len34 = len * 3 / 4 ; byte [ ] outBuff = new byte [ len34 ] ; int outBuffPosn = 0 ; byte [ ] b4 = new byte [ 4 ] ; int b4Posn = 0 ; int i = 0 ; byte sbiDecode = 0 ; for ( i = off ; i < off + len ; i ++ ) { sbiDecode = DECODABET [ source [ i ] & FF ] ; if ( sbiDecode >= WHITE_SPACE_ENC ) { if ( sbiDecode >= EQUALS_SIGN_ENC ) { b4 [ b4Posn ++ ] = source [ i ] ; if ( b4Posn > 3 ) { outBuffPosn += decode4to3 ( b4 , 0 , outBuff , outBuffPosn , options ) ; b4Posn = 0 ; if ( source [ i ] == EQUALS_SIGN ) { break ; } } } } else { throw new java . io . IOException ( String . format ( "Bad Base64 input character decimal %d in array position %d" , ( ( int ) source [ i ] ) & FF , i ) ) ; } } byte [ ] out = new byte [ outBuffPosn ] ; System . arraycopy ( outBuff , 0 , out , 0 , outBuffPosn ) ; return out ; }
te	OLB	|	public Logger ( ) { this ( LOGLV_CRASH | LOGLV_GUN1 ) ; }
te	OAS	=	public static void main ( String [ ] args ) { int [ ] mas = { 1 , 34 , 67 , 3 , - 5 , 67 , 45 , 0 , 120 , 4 } ; Comparator < Integer > cmp = Integer COLCOL compare ; mas = sort ( mas , cmp ) ; System . out . println ( "Sorted mas: " + Arrays . toString ( mas ) ) ; }
te	OUT	:	@ Override public void serialize ( Buffer buf ) { buf . writeInt ( fightId ) ; buf . writeByte ( fightType ) ; buf . writeInt ( fightStart ) ; buf . writeBoolean ( fightSpectatorLocked ) ; for ( FightTeamLightInformations entry : fightTeams ) { entry . serialize ( buf ) ; } for ( FightOptionsInformations entry : fightTeamsOptions ) { entry . serialize ( buf ) ; } }
te	OUT	:	public void run ( ) { try { while ( ! finished ) { Request request = queuedRequests . take ( ) ; long traceMask = ZooTrace . CLIENT_REQUEST_TRACE_MASK ; if ( request . type == OpCode . ping ) { traceMask = ZooTrace . CLIENT_PING_TRACE_MASK ; } if ( LOG . isTraceEnabled ( ) ) { ZooTrace . logRequest ( LOG , traceMask , R , request , "" ) ; } if ( Request . requestOfDeath == request ) { break ; } switch ( request . type ) { case OpCode . sync : case OpCode . create : case OpCode . delete : case OpCode . setData : case OpCode . setACL : case OpCode . multi : case OpCode . check : ReplyHeader hdr = new ReplyHeader ( request . cxid , zks . getZKDatabase ( ) . getDataTreeLastProcessedZxid ( ) , Code . NOTREADONLY . intValue ( ) ) ; try { request . cnxn . sendResponse ( hdr , null , null ) ; } catch ( IOException e ) { LOG . error ( "IO exception while sending response" , e ) ; } continue ; } if ( nextProcessor != null ) { nextProcessor . processRequest ( request ) ; } } } catch ( InterruptedException e ) { LOG . error ( "Unexpected interruption" , e ) ; } LOG . info ( "ReadOnlyRequestProcessor exited loop!" ) ; }
te	SYM	{	public final void run ( ) { while ( true ) { long workStart = System . nanoTime ( ) ; this . work ( ) ; long workDone = System . nanoTime ( ) ; this . workTime = ( workDone - workStart ) ; long timeToWait = this . workInterval - workTime ; if ( timeToWait < 0 ) { if ( GameConfig . DEBUG ) System . err . println ( "[" + this . getName ( ) + "] workTime exceeds workInterval!:" + this . workTime + " > " + this . workInterval ) ; continue ; } long msToWait = timeToWait / 1000000 ; if ( msToWait > 1 ) { try { Thread . sleep ( Math . max ( 0 , ( msToWait - 1 ) ) ) ; } catch ( InterruptedException e ) { System . err . println ( "[" + this . getName ( ) + "]" + e . getStackTrace ( ) ) ; } } long sleepUntil = workStart + this . workInterval ; long currentTime = System . nanoTime ( ) ; while ( ( sleepUntil - currentTime ) > 10 ) { if ( ( sleepUntil - currentTime ) > 10000 ) { Thread . yield ( ) ; } currentTime = System . nanoTime ( ) ; } } }
te	KMD	new	@ Override public void write ( byte [ ] b , int off , int len ) throws IOException { updateTextArea ( new String ( b , off , len ) ) ; }
te	KFC	for	public Veci performOp ( Veci v1 , Veci v2 ) { int len = v1 . _vals . length < v2 . _vals . length ? v1 . _vals . length : v2 . _vals . length ; for ( int i = 0 ; i < len ; i ++ ) v1 . _vals [ i ] *= v2 . _vals [ i ] ; for ( int i = len ; i < v1 . _vals . length ; i ++ ) v1 . _vals [ i ] = 0 ; return v1 ; }
te	OAS	=	@ SuppressWarnings ( "unchecked" ) public static List < DayTable > getDayTablesForSchoolclass ( final Schoolclass pSchoolclas ) throws DatasetException { try { final Query query = entityManager . createQuery ( "SELECT d FROM DayTable d WHERE d.Schoolclass = ?1" ) ; query . setParameter ( 1 , pSchoolclas ) ; return ( List < DayTable > ) query . getResultList ( ) ; } catch ( Exception e ) { LOGGER . error ( "Exception while getting all day tables!" , e ) ; throw new DatasetException ( "Error while getting all day tables: " + e . getMessage ( ) ) ; } }
te	KPT	float	public AparapiBackpropMaxout ( Connections inputConnection , ValuesProvider valuesProvider , ValuesProvider activations , List < Tensor > weightUpdates , float learningRate , float momentum , float l1weightDecay , float l2weightDecay ) { super ( Arrays . asList ( new Connections [ ] { inputConnection } ) , valuesProvider , inputConnection . getOutputLayer ( ) ) ; Matrix m = TensorFactory . tensor ( inputConnection . getInputLayer ( ) , inputConnection , activations ) ; this . ffActivation = m . getElements ( ) ; this . activationStartPosition = m . getStartIndex ( ) ; this . activationRowStep = m . getRowElementsDistance ( ) ; this . activationColumnStep = m . getColumnElementsDistance ( ) ; this . learningRate = momentum ; this . momentum = momentum ; this . l1weightDecay = l1weightDecay ; this . l2weightDecay = l2weightDecay ; this . weightUpdates = weightUpdates . get ( 0 ) . getElements ( ) ; this . winnersStartPositions = MaxoutWinners . getInstance ( ) . getStartPositions ( Arrays . asList ( new Connections [ ] { inputConnection } ) ) ; this . maxoutWinners = MaxoutWinners . getInstance ( ) . getWinners ( ) ; }
te	SYM	}	@ SuppressWarnings ( "unchecked" ) public CircularArray ( int size ) { items = ( T [ ] ) new Object [ size ] ; }
te	KMD	new	public Matrix4f mul ( Matrix4f r ) { Matrix4f res = new Matrix4f ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { res . set ( i , j , m [ i ] [ 0 ] * r . get ( 0 , j ) + m [ i ] [ 1 ] * r . get ( 1 , j ) + m [ i ] [ 2 ] * r . get ( 2 , j ) + m [ i ] [ 3 ] * r . get ( 3 , j ) ) ; } } return res ; }
te	KPT	byte	public static final ErrorCode getErrorCode ( byte code ) { return map . get ( code ) ; }
te	SYM	{	public void setOrderCycle ( String orderCycle ) { this . orderCycle = orderCycle ; }
te	KPT	float	private void updateCombos ( float tpf ) { time += tpf ; if ( specialComboDelay <= 0 ) { combo1Exec_C1 . updateExpiration ( time ) ; combo2Exec_C1 . updateExpiration ( time ) ; combo3Exec_C1 . updateExpiration ( time ) ; if ( comboSize > 3 ) { combo4Exec_C1 . updateExpiration ( time ) ; } if ( comboSize > 4 ) { combo5Exec_C1 . updateExpiration ( time ) ; } if ( comboSize > 5 ) { combo6Exec_C1 . updateExpiration ( time ) ; } } if ( currentMove != null ) { currentMoveCastTime -= tpf ; if ( currentMoveCastTime <= 0 ) { if ( currentMove . getMoveName ( ) . equals ( "Combo1" ) ) { sendComboCommand ( ComboName . COMBO1 ) ; } if ( currentMove . getMoveName ( ) . equals ( "Combo2" ) ) { sendComboCommand ( ComboName . COMBO2 ) ; } if ( currentMove . getMoveName ( ) . equals ( "Combo3" ) ) { sendComboCommand ( ComboName . COMBO3 ) ; if ( comboSize == 3 ) { special = true ; specialComboDelay = 10 ; } } if ( currentMove . getMoveName ( ) . equals ( "Combo4" ) ) { sendComboCommand ( ComboName . COMBO4 ) ; if ( comboSize == 4 ) { special = true ; specialComboDelay = 10 ; } } if ( currentMove . getMoveName ( ) . equals ( "Combo5" ) ) { sendComboCommand ( ComboName . COMBO5 ) ; if ( comboSize == 5 ) { special = true ; specialComboDelay = 10 ; } } if ( currentMove . getMoveName ( ) . equals ( "Combo6" ) ) { sendComboCommand ( ComboName . COMBO6 ) ; if ( comboSize == 6 ) { special = true ; specialComboDelay = 10 ; } } currentMoveCastTime = 0 ; currentMove = null ; } } if ( specialComboDelay > 0 ) { specialComboDelay -- ; } }
te	KEH	throw	public DijkstraShortestPathAlgorithm ( GraphUndirected g ) { if ( g == null ) throw new IllegalArgumentException ( "Graph g cannot be null" ) ; this . ugraph = g ; }
te	OLB	|	public char readChar ( ) throws IOException { byte [ ] b = new byte [ 2 ] ; if ( read ( b , 0 , 2 ) < 2 ) { throw new EOFException ( ) ; } char c = ( char ) ( b [ 0 ] << 8 | ( b [ 1 ] & FF ) ) ; return c ; }
te	OAS	=	public Collection < ? extends DimensionValueCollection > getAll ( ) { HashSet < DimensionValueCollection > cc = new HashSet < DimensionValueCollection > ( ) ; if ( size ( ) != 0 ) { for ( EnumMap < EpisodicMemory . InfoStored , DimensionValueCollection > i : values ( ) ) { for ( DimensionValueCollection c : i . values ( ) ) cc . add ( c ) ; } return cc ; } return null ; }
te	ORE	>	@ Override protected void setupValidBoardConfiguration ( ) { validPieceCount = new HashMap < PieceType , Integer > ( ) ; validPieceCount . put ( PieceType . MARSHAL , 1 ) ; validPieceCount . put ( PieceType . GENERAL , 1 ) ; validPieceCount . put ( PieceType . COLONEL , 2 ) ; validPieceCount . put ( PieceType . MAJOR , 3 ) ; validPieceCount . put ( PieceType . CAPTAIN , 4 ) ; validPieceCount . put ( PieceType . LIEUTENANT , 2 ) ; validPieceCount . put ( PieceType . FIRST_LIEUTENANT , 2 ) ; validPieceCount . put ( PieceType . SERGEANT , 4 ) ; validPieceCount . put ( PieceType . MINER , 5 ) ; validPieceCount . put ( PieceType . SCOUT , 8 ) ; validPieceCount . put ( PieceType . BOMB , 6 ) ; validPieceCount . put ( PieceType . SPY , 1 ) ; MAX_PIECES = 80 ; MAX_X = 9 ; MAX_Y = 9 ; MIN_X = 0 ; MIN_Y = 0 ; MIN_BLUE_STARTING_Y = 6 ; MAX_RED_STARTING_Y = 3 ; }
te	ORE	>	public void setLabelsToPastedContent ( Collection < Element > elements ) { for ( Element element : elements ) { if ( element instanceof Node && ! ( element instanceof ReferencePlace ) ) { } } }
te	KEH	throw	public void setErrorStyle ( int style ) { if ( getLength ( ) != 0 ) { throw new ErrorException ( "Console styles and colors cannot be changed after I/O has started." ) ; } errorAttributes . addAttribute ( StyleConstants . Bold , new boolean ( ( style & Font . BOLD ) != 0 ) ) ; errorAttributes . addAttribute ( StyleConstants . Italic , new boolean ( ( style & Font . ITALIC ) != 0 ) ) ; }
te	KEH	throw	public static long mulAndCheck ( long a , long b ) { long ret ; if ( a > b ) { ret = mulAndCheck ( b , a ) ; } else { if ( a < 0 ) { if ( b < 0 ) { if ( a >= long . MAX_VALUE / b ) { ret = a * b ; } else { throw new MathArithmeticException ( ) ; } } else if ( b > 0 ) { if ( long . MIN_VALUE / b <= a ) { ret = a * b ; } else { throw new MathArithmeticException ( ) ; } } else { ret = 0 ; } } else if ( a > 0 ) { if ( a <= long . MAX_VALUE / b ) { ret = a * b ; } else { throw new MathArithmeticException ( ) ; } } else { ret = 0 ; } } return ret ; }
te	KFC	for	private static void fourthPhase ( byte [ ] [ ] A , byte [ ] [ ] D , int i , int [ ] d , int L ) { for ( int row = 0 ; row < i ; row ++ ) { for ( int j = i ; j < L ; j ++ ) { if ( A [ row ] [ j ] != 0 ) { byte b = A [ row ] [ j ] ; A [ row ] [ j ] = 0 ; byte [ ] product = OctectOps . betaProduct ( b , D [ d [ j ] ] ) ; D [ d [ row ] ] = Utilities . xorSymbol ( D [ d [ row ] ] , product ) ; } } } }
te	KFC	for	public List < V > list ( T ... values ) { List < V > beans = new LinkedList < V > ( ) ; for ( T value : values ) { beans . add ( create ( value ) ) ; } return beans ; }
te	KEH	catch	public void entered ( WikiContext context ) { super . entered ( context ) ; try { mReinserting = mArchiveManager . getLocalChanges ( ) . isUnmodified ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } }
te	KMD	new	@ Override public void mouseClicked ( MouseEvent e ) { try { new TelaAjuda ( ) ; } catch ( URISyntaxException ex ) { Util . getInstance ( ) . log ( ex . toString ( ) , 2 ) ; } }
te	KEH	throw	public String [ ] itemNames ( ) { if ( ! this . dataEntered ) throw new IllegalArgumentException ( "no data has been entered" ) ; String [ ] ret = new String [ this . nItems ] ; for ( int i = 0 ; i < this . nItems ; i ++ ) ret [ i ] = this . itemNames [ i ] ; return ret ; }
te	OAS	=	private JMenu buildMenu ( String name , JMenuItem ... items ) { JMenu menu = new JMenu ( name ) ; for ( JMenuItem item : items ) if ( item == null ) menu . addSeparator ( ) ; else menu . add ( item ) ; return menu ; }
te	SYM	}	public void setCustomText7 ( String customText7 ) { this . customText7 = customText7 ; }
te	ORE	>	public void addAuthorativeAnswer ( DNSRecord rec ) throws IOException { if ( numAdditionals > 0 ) { throw new IllegalStateException ( "Authorative answers must be added before additional answers" ) ; } authorativeAnswers . add ( rec ) ; writeRecord ( rec , 0 ) ; numAuthorities ++ ; }
te	OLB	|	@ Override protected void operationExecute ( ) throws MultiCloudException { try { if ( jsonBody != null ) { ObjectMapper mapper = json . getMapper ( ) ; body = mapper . writeValueAsString ( jsonBody ) ; } if ( body != null ) { synchronized ( lock ) { request = prepareRequest ( new StringEntity ( doPropertyMapping ( body , false ) ) ) ; } } else { synchronized ( lock ) { request = prepareRequest ( null ) ; } } } catch ( UnsupportedEncodingException | JsonProcessingException e1 ) { throw new MultiCloudException ( "Failed to prepare request." ) ; } try { setResult ( executeRequest ( request , new ResponseProcessor < FileInfo > ( ) { @ Override public FileInfo processResponse ( HttpResponse response ) { FileInfo info = null ; try { if ( response . getStatusLine ( ) . getStatusCode ( ) >= 400 ) { parseOperationError ( response ) ; } else { JsonNode tree = parseJsonResponse ( response ) ; if ( tree != null ) { info = json . getMapper ( ) . treeToValue ( tree , FileInfo . class ) ; info . fillMissing ( ) ; for ( FileInfo content : info . getContent ( ) ) { content . fillMissing ( ) ; } } else { info = new FileInfo ( ) ; info . setName ( name ) ; info . setFileType ( type ) ; } } } catch ( IllegalStateException | IOException e ) { } return info ; } } ) ) ; } catch ( IOException e ) { synchronized ( lock ) { if ( ! isAborted ) { throw new MultiCloudException ( "Failed to rename the specified file or folder." ) ; } } } synchronized ( lock ) { request = null ; } }
te	KMD	new	private void btnAgregarActionPerformed ( java . awt . event . ActionEvent evt ) { try { ClientesBusiness clienteBusniess = new ClientesBusiness ( ) ; Cliente cliente = new Cliente ( ) ; cliente . setTipo_cliente ( 1 ) ; try { clienteBusniess . agregarCliente ( cliente ) ; } catch ( Exception ex ) { Logger . getLogger ( ClienteFisico . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Cliente_Fisico clienteFisico = new Cliente_Fisico ( ) ; clienteFisico . setCedula ( Integer . parseInt ( txtCedula . getText ( ) ) ) ; clienteFisico . setNombre ( txtNombre . getText ( ) ) ; clienteFisico . setApellido1 ( txtApellido1 . getText ( ) ) ; clienteFisico . setApellido2 ( txtApellido2 . getText ( ) ) ; clienteFisico . setCodDireccion ( codDirrecion ) ; clienteFisico . setCorreo ( txtCorreo . getText ( ) ) ; int dia = jDateChooser1 . getCalendar ( ) . get ( Calendar . DAY_OF_MONTH ) ; int mes = jDateChooser1 . getCalendar ( ) . get ( Calendar . MONTH ) ; int ao = jDateChooser1 . getCalendar ( ) . get ( Calendar . YEAR ) ; String fecha = ao + "/" + mes + "/" + dia ; clienteFisico . setFec_nacimiento ( fecha ) ; TelefonoBusiness telefonoBusiness = new TelefonoBusiness ( ) ; Telefonos telefonos = new Telefonos ( ) ; telefonos . setTelefono1 ( tel1 . getText ( ) ) ; telefonos . setTelefono2 ( tel2 . getText ( ) ) ; telefonos . setTelefono3 ( tel3 . getText ( ) ) ; telefonos . setCelular1 ( cel1 . getText ( ) ) ; telefonos . setCelular2 ( cel2 . getText ( ) ) ; telefonoBusiness . agregarTelefonos ( telefonos ) ; clienteFisico . setCod_telefonos ( telefonos . getCod_telefono ( ) ) ; try { clienteBusniess . agregarClienteFisico ( clienteFisico ) ; JOptionPane . showMessageDialog ( panelCurves1 , "El cliente ha sido agregado correctemente " ) ; limpiar ( ) ; bloquearTxt ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( rootPane , ex . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ClienteFisico . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( Exception ex ) { Logger . getLogger ( ClienteFisico . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	OAR	*	private void method26 ( boolean flag ) { for ( int j = 0 ; j < npcCount ; j ++ ) { NPC npc = npcArray [ npcIndices [ j ] ] ; int k = 20000000 + ( npcIndices [ j ] << 14 ) ; if ( npc == null || ! npc . isVisible ( ) || npc . desc . aBoolean93 != flag ) continue ; int l = npc . x >> 7 ; int i1 = npc . y >> 7 ; if ( l < 0 || l >= 104 || i1 < 0 || i1 >= 104 ) continue ; if ( npc . anInt1540 == 1 && ( npc . x & 7f ) == 64 && ( npc . y & 7f ) == 64 ) { if ( anIntArrayArray929 [ l ] [ i1 ] == anInt1265 ) continue ; anIntArrayArray929 [ l ] [ i1 ] = anInt1265 ; } if ( ! npc . desc . aBoolean84 ) k += 80000000 ; worldController . method285 ( plane , npc . anInt1552 , method42 ( plane , npc . y , npc . x ) , k , npc . y , ( npc . anInt1540 - 1 ) * 64 + 60 , npc . x , npc , npc . aBoolean1541 ) ; } }
te	OAS	=	private JScrollPane getSheetTreeScrollPane ( ) { if ( sheetTreeScrollPane == null ) { sheetTreeScrollPane = new JScrollPane ( ) ; sheetTreeScrollPane . setPreferredSize ( new Dimension ( 0 , 0 ) ) ; sheetTreeScrollPane . setViewportView ( getSheetTree ( ) ) ; } return sheetTreeScrollPane ; }
te	OAS	=	@ Override public void receberModelo ( Modelo m ) { MostraModelo mm = new MostraModelo ( m ) ; mm . setVisible ( true ) ; }
te	OUT	:	private void initMapping ( Field embeddedIn , class < ? > clazz ) throws Exception { List < Field > fields = new ArrayList < > ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; for ( Field field : fields ) { if ( checkEmbeddables ( field ) ) { continue ; } if ( ignoreFiled ( field ) ) { continue ; } boolean id = isId ( field ) ; boolean generatedValue = isGeneratedValue ( field ) ; boolean fk = isForeignKey ( field ) ; ColumnType columnType = getAssociatedType ( fk , field ) ; if ( columnType == null || columnType == ColumnType . UNKNOWN ) { throw new Error ( "Unknown column type for field " + field . getName ( ) + " in " + clazz . getSimpleName ( ) ) ; } String columnName = naming . getColumnName ( columnType , field . getName ( ) ) ; Column column = columnType . createColumn ( columnName , field , embeddedIn , id , generatedValue , fk ) ; addColumn ( column ) ; } }
te	KFC	for	private ArrayList < Respuesta > convertirDatosARespuesta ( ArrayList datosRespuestas ) { ArrayList < Respuesta > respuestas = new ArrayList ( ) ; for ( int fila = 0 ; fila < datosRespuestas . size ( ) ; fila ++ ) { ArrayList datosRespuesta = ( ArrayList ) datosRespuestas . get ( fila ) ; int id_respuesta = ( Integer ) datosRespuesta . get ( 0 ) ; String respuestaDescripcion = ( String ) datosRespuesta . get ( 1 ) ; double ponderacion = ( double ) datosRespuesta . get ( 2 ) ; Respuesta respuesta = new Respuesta ( id_respuesta , respuestaDescripcion , ponderacion ) ; respuestas . add ( respuesta ) ; } return respuestas ; }
te	OAS	=	void resetDelegate ( ) { compressor = null ; decompressor = null ; outputBlockSize = 1 ; zlibBuffer = null ; }
te	OLB	|	private long readUnsignedInt ( InputStream stream ) throws IOException { int b1 = readUnsignedByte ( stream ) ; int b2 = readUnsignedByte ( stream ) ; int b3 = readUnsignedByte ( stream ) ; int b4 = readUnsignedByte ( stream ) ; long l = ( long ) ( ( b4 << 24 ) | ( b3 << 16 ) | ( b2 << 8 ) | b1 ) ; return l & ffffffff ; }
te	OLB	|	private void printArray ( NodeArray array , int level , PrintStream ostream ) { StringBuilder label = new StringBuilder ( ) ; final int len = array . getLength ( ) ; final boolean hasSysHash = array . hasAttr ( Named . SYSTEM_HASH ) ; if ( hasSysHash ) { label . append ( "{ {" ) ; } int i = 0 ; for ( GraphPoint ele : array . getElements ( ) ) { String subaddr = String . format ( "<e%d> " , ele . getAttr ( Named . ARRAY_INDEX ) ) ; label . append ( subaddr ) ; if ( ele . hasAttr ( Named . VALUE ) ) { Object val = ele . getAttr ( Named . VALUE ) ; if ( val == null ) { label . append ( "null" ) ; } else { String valstr = val . toString ( ) ; label . append ( valstr ) ; } } else { label . append ( " " ) ; } if ( i < len - 1 ) { label . append ( | ) ; } i ++ ; } if ( hasSysHash ) { label . append ( String . format ( " } | 0x%X }" , array . getAttr ( Named . SYSTEM_HASH ) ) ) ; } ostream . printf ( "%snode%s[label = \"%s\"" , ExporterUtils . getIndent ( level ) , array . getID ( ) , label . toString ( ) ) ; Color color = getColor ( array . getGeneration ( ) ) ; ostream . printf ( " fillcolor=\"#%2x%2x%2x\" style=filled " , color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) ) ; ostream . printf ( "];\n" ) ; }
te	OUT	:	public StringEmitter ( String original , Charset charset ) { bytes = original . getBytes ( charset ) ; int hc = 0 ; for ( byte b : bytes ) { hc = ( ( hc << 4 ) + hc ) + ( b & ff ) ; } hashCode = hc ; }
te	OAR	*	public void divideByPolarSystem ( Point2DWithVector point2dWithVector ) { if ( ! point2dWithVector . equals ( origin ) ) { double a = this . x , b = this . y ; this . x = a * point2dWithVector . x + b * point2dWithVector . y ; this . y = - a * point2dWithVector . y + b * point2dWithVector . x ; double distanceSq = origin . distanceSq ( point2dWithVector ) ; multiple ( 1.0 / distanceSq ) ; } return ; }
te	KMD	new	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jPanel1 = new javax . swing . JPanel ( ) ; hostnamePanel = new javax . swing . JPanel ( ) ; HostNameLabel = new javax . swing . JLabel ( ) ; Hostname = new javax . swing . JLabel ( ) ; AliasPanel = new javax . swing . JPanel ( ) ; AliasLabel = new javax . swing . JLabel ( ) ; AliasField = new javax . swing . JTextField ( ) ; DescriptionPanel = new javax . swing . JPanel ( ) ; descriptionLabel = new javax . swing . JLabel ( ) ; jScrollPane1 = new javax . swing . JScrollPane ( ) ; jTextArea1 = new javax . swing . JTextArea ( ) ; MemoryPanel = new javax . swing . JPanel ( ) ; memBlockSizeLabel = new javax . swing . JLabel ( ) ; memboxcombo = new javax . swing . JComboBox ( ) ; jPanel2 = new javax . swing . JPanel ( ) ; OkButton = new javax . swing . JButton ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; setTitle ( "Host Information" ) ; jPanel1 . setBorder ( javax . swing . BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; jPanel1 . setLayout ( new javax . swing . BoxLayout ( jPanel1 , javax . swing . BoxLayout . PAGE_AXIS ) ) ; hostnamePanel . setLayout ( new java . awt . FlowLayout ( java . awt . FlowLayout . LEFT ) ) ; HostNameLabel . setLabelFor ( Hostname ) ; HostNameLabel . setText ( "Hostname:" ) ; hostnamePanel . add ( HostNameLabel ) ; Hostname . setText ( "hostname" ) ; hostnamePanel . add ( Hostname ) ; jPanel1 . add ( hostnamePanel ) ; AliasPanel . setLayout ( new java . awt . FlowLayout ( java . awt . FlowLayout . LEFT ) ) ; AliasLabel . setText ( "Alias" ) ; AliasLabel . setPreferredSize ( new java . awt . Dimension ( 52 , 14 ) ) ; AliasPanel . add ( AliasLabel ) ; AliasField . setMinimumSize ( new java . awt . Dimension ( 120 , 20 ) ) ; AliasField . setPreferredSize ( new java . awt . Dimension ( 120 , 20 ) ) ; AliasPanel . add ( AliasField ) ; jPanel1 . add ( AliasPanel ) ; DescriptionPanel . setLayout ( new javax . swing . BoxLayout ( DescriptionPanel , javax . swing . BoxLayout . PAGE_AXIS ) ) ; descriptionLabel . setText ( "Description" ) ; descriptionLabel . setPreferredSize ( new java . awt . Dimension ( 52 , 14 ) ) ; DescriptionPanel . add ( descriptionLabel ) ; jScrollPane1 . setPreferredSize ( new java . awt . Dimension ( 300 , 200 ) ) ; jTextArea1 . setColumns ( 20 ) ; jTextArea1 . setRows ( 5 ) ; jTextArea1 . setPreferredSize ( new java . awt . Dimension ( 300 , 200 ) ) ; jScrollPane1 . setViewportView ( jTextArea1 ) ; DescriptionPanel . add ( jScrollPane1 ) ; jPanel1 . add ( DescriptionPanel ) ; MemoryPanel . setLayout ( new java . awt . FlowLayout ( java . awt . FlowLayout . LEFT ) ) ; memBlockSizeLabel . setText ( "Memory Block Size:" ) ; MemoryPanel . add ( memBlockSizeLabel ) ; memboxcombo . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "1024" , "2048" , "4096" , "8192" , "16384" } ) ) ; MemoryPanel . add ( memboxcombo ) ; jPanel1 . add ( MemoryPanel ) ; getContentPane ( ) . add ( jPanel1 , java . awt . BorderLayout . CENTER ) ; jPanel2 . setLayout ( new java . awt . FlowLayout ( java . awt . FlowLayout . CENTER , 15 , 5 ) ) ; OkButton . setText ( "Ok" ) ; OkButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { OkButtonActionPerformed ( evt ) ; } } ) ; jPanel2 . add ( OkButton ) ; getContentPane ( ) . add ( jPanel2 , java . awt . BorderLayout . SOUTH ) ; pack ( ) ; }
te	ORE	!=	public void setCells ( Path [ ] cells ) { boolean wasRunning = false ; if ( evaluationThread != null ) { stopEvaluation ( ) ; wasRunning = true ; } world . setCells ( cells ) ; world . setFieldState ( 0 ) ; panel . update ( ) ; updateFieldInfo ( ) ; if ( wasRunning ) startEvaluation ( ) ; }
te	SYM	{	public short getValue ( ) { return value ; }
te	OAS	=	public void SaveHQ ( List < HQ > HQ_Lista ) { try { FileOutputStream fos = new FileOutputStream ( System . getProperty ( "user.dir" ) + "/Dados/HQ.hq" ) ; ObjectOutputStream oos = new ObjectOutputStream ( fos ) ; oos . writeObject ( HQ_Lista ) ; oos . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Principal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Principal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	KMD	class	@ Test public void checkContainerBeansThatAreSuperClassOfMiddleBean ( ) { final Collection < Container < ? super MiddleBean >> beans = injector . getBeans ( new TypeLiteral < Container < ? super MiddleBean >> ( ) { } ) ; assertNotNull ( beans ) ; assertEquals ( 2 , beans . size ( ) ) ; assertFalse ( containsContainerBeanOf ( ChildBean . class , beans ) ) ; assertTrue ( containsContainerBeanOf ( MiddleBean . class , beans ) ) ; assertTrue ( containsContainerBeanOf ( SuperBean . class , beans ) ) ; }
te	SYM	}	public InsufficientInventoryException ( String message ) { super ( message ) ; }
te	OLB	|	public void moveCursorRight ( ) { command ( LCD_CURSORSHIFT | LCD_CURSORMOVE | LCD_MOVE_RIGHT ) ; }
te	SYM	{	@ Override public final Object [ ] toArray ( ) { return backing . toArray ( ) ; }
te	OUT	!	public void characters ( char buf [ ] , int offset , int len ) throws SAXException { String s = new String ( buf , offset , len ) ; if ( ! s . trim ( ) . equals ( "" ) && newStyle ) { if ( currentElement . equalsIgnoreCase ( "name" ) ) { style . setName ( s . trim ( ) ) ; } if ( currentElement . equalsIgnoreCase ( "abbr" ) ) { descrBuf = descrBuf + " " + s . trim ( ) ; } if ( currentElement . equalsIgnoreCase ( "aroma" ) || currentElement . equalsIgnoreCase ( "appearance" ) || currentElement . equalsIgnoreCase ( "flavor" ) || currentElement . equalsIgnoreCase ( "mouthfeel" ) || currentElement . equalsIgnoreCase ( "impression" ) || currentElement . equalsIgnoreCase ( "comments" ) || currentElement . equalsIgnoreCase ( "ingredients" ) || currentElement . equalsIgnoreCase ( "examples" ) ) { descrBuf = descrBuf + s ; } if ( currentElement . equalsIgnoreCase ( "low" ) ) { if ( currentList . equalsIgnoreCase ( "og" ) ) style . ogLow = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "ibu" ) ) style . ibuLow = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "srm" ) ) style . srmLow = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "abv" ) ) style . alcLow = double . parseDouble ( s ) ; } if ( currentElement . equalsIgnoreCase ( "high" ) ) { if ( currentList . equalsIgnoreCase ( "og" ) ) style . ogHigh = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "ibu" ) ) style . ibuHigh = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "srm" ) ) style . srmHigh = double . parseDouble ( s ) ; if ( currentList . equalsIgnoreCase ( "abv" ) ) style . alcHigh = double . parseDouble ( s ) ; } } if ( ! s . trim ( ) . equals ( "" ) && currentElement . equalsIgnoreCase ( "name" ) && ! newStyle ) { category = s . trim ( ) ; } }
te	OAR	*	private static void logProgress ( float progress ) { int % = ( int ) ( progress * 100 ) ; if ( % % 10 == 0 ) { log . info ( "Building {}%" , % ) ; } }
te	OUT	:	public Object getValueAt ( int rowIndex , int columnIndex ) { switch ( columnIndex ) { case 0 : return this . identifiants . get ( rowIndex ) . getSite ( ) ; case 1 : return this . identifiants . get ( rowIndex ) . getLogin ( ) ; case 2 : return this . identifiants . get ( rowIndex ) . getMdp ( ) ; default : return - 1 ; } }
te	OLB	|	public static Clip loadClip ( String filename ) { try { URL url = ClientGUI . class . getResource ( SNDDIR + filename ) ; Clip clip = AudioSystem . getClip ( ) ; clip . open ( AudioSystem . getAudioInputStream ( url ) ) ; return clip ; } catch ( LineUnavailableException | IOException | UnsupportedAudioFileException e ) { DEBUGLOG . severe ( "Could not load sound '" + filename + "'!" ) ; return null ; } }
te	KFC	for	private void refreshMenu ( ) { if ( menuItems != null && menuItems . length > 0 ) { firstIndex = Math . max ( topFixedCount , firstIndex ) ; firstIndex = Math . min ( menuItems . length - bottomFixedCount - scrollCount , firstIndex ) ; upItem . setEnabled ( firstIndex > topFixedCount ) ; downItem . setEnabled ( firstIndex + scrollCount < menuItems . length - bottomFixedCount ) ; menu . removeAll ( ) ; for ( int i = 0 ; i < topFixedCount ; i ++ ) { menu . add ( menuItems [ i ] ) ; } if ( topFixedCount > 0 ) { menu . addSeparator ( ) ; } menu . add ( upItem ) ; for ( int i = firstIndex ; i < scrollCount + firstIndex ; i ++ ) { menu . add ( menuItems [ i ] ) ; } menu . add ( downItem ) ; if ( bottomFixedCount > 0 ) { menu . addSeparator ( ) ; } for ( int i = menuItems . length - bottomFixedCount ; i < menuItems . length ; i ++ ) { menu . add ( menuItems [ i ] ) ; } JComponent parent = ( JComponent ) upItem . getParent ( ) ; parent . revalidate ( ) ; parent . repaint ( ) ; } }
te	OLB	|	public int foo ( int | ) { return | + 7 + 15 ; }
te	KFC	for	public String toString ( ) { String s = "" ; for ( int i = 0 ; i < m_vcs . length ; i ++ ) { String port = "I[" + getPortNum ( ) + ":" + i + "]" + ( getCurrVC ( ) == i ? "*" : "" ) ; s += String . format ( "%-12s%s\n" , port , m_vcs [ i ] . toString ( ) ) ; } return s ; }
te	SYM	}	public void init ( boolean forEncryption , CipherParameters param ) { if ( forEncryption ) { if ( ! ( param instanceof BGV11BasicPublicKeyParameters ) ) throw new IllegalArgumentException ( "SHEBV11bPublicKeyParameters are required for encryption." ) ; } else { if ( ! ( param instanceof BGV11BasicSecretKeyParameters ) ) throw new IllegalArgumentException ( "SHEBV11bSecretKeyParameters are required for decryption." ) ; } this . param = param ; }
te	KPT	byte	public String sendRaw ( String str , int sleep ) { debug ( "Sending command: " + str ) ; if ( ! isConnected ( ) ) { error ( "Cannot send command because the robot is not connected." , "RXTXRobot" , "sendRaw" ) ; return "" ; } try { byte [ ] buffer ; int retries = 4 ; do { out . write ( ( str + "\r\n" ) . getBytes ( ) ) ; buffer = new byte [ 1024 ] ; sleep ( 500 ) ; -- retries ; if ( ! waitForResponse ) { if ( in . available ( ) == 0 && attemptTryAgain && retries != 0 ) { debug ( "No response from the Arduino....Trying " + retries + " more times" ) ; } if ( retries == 0 ) { error ( "There was no response from the Arduino" , "RXTXRobot" , "sendRaw" ) ; } } } while ( in . available ( ) == 0 && attemptTryAgain && ! waitForResponse && retries != 0 ) ; int bytesRead = 0 ; String t = "" ; do { bytesRead += in . read ( buffer , bytesRead , 1024 - bytesRead ) ; t = new String ( buffer ) . trim ( ) ; } while ( this . moveEncodedMotor && ! str . equals ( t ) ) ; String ret = ( new String ( buffer ) ) . trim ( ) ; debug ( "Received " + bytesRead + " bytes from the Arduino: " + ret ) ; return ret ; } catch ( IOException e ) { error ( "Could not read or use Input or Output streams (IOException)" , "RXTXRobot" , "sendRaw" ) ; if ( getVerbose ( ) ) { this . getErrStream ( ) . println ( "Error Message: " + e . toString ( ) + "\n\nError StackTrace:\n" ) ; e . printStackTrace ( this . getErrStream ( ) ) ; } } return "" ; }
te	OAR	*	public static void main ( String [ ] argv ) { PopulationCode p1 = new PopulationCode ( "testLayer" , 5 * 10 * 12 , "testing" , 1 ) ; p1 . addDimension ( "X" , 0 , 1e4 , 12 , "X axis" ) ; p1 . addDimension ( "Y" , 0 , 1e4 , 10 , "Y axis" ) ; p1 . addDimension ( "Z" , 0 , 1e4 , 5 , "Z axis" ) ; int [ ] vect = new int [ 3 ] ; for ( int x = 0 ; x < 12 ; x ++ ) { for ( int y = 0 ; y < 10 ; y ++ ) { for ( int z = 0 ; z < 5 ; z ++ ) { vect [ 0 ] = x ; vect [ 1 ] = y ; vect [ 2 ] = z ; p1 . setFiringRate ( vect , x * y * z ) ; double verify = p1 . getFiringRate ( vect ) ; System . out . println ( ( x * y * z ) + "==" + verify ) ; } } } double [ ] val = { 7500 , 2500 , 5000 } ; double conf = 1.0 ; for ( int x = 0 ; x < 12 ; x ++ ) { for ( int y = 0 ; y < 10 ; y ++ ) { for ( int z = 0 ; z < 5 ; z ++ ) { vect [ 0 ] = x ; vect [ 1 ] = y ; vect [ 2 ] = z ; double v = p1 . getFiringRate ( vect ) ; System . out . println ( v + " == " + x * y * z ) ; } } } p1 . encode ( val , conf ) ; for ( int i = 0 ; i < p1 . actualsize ; i ++ ) { System . out . print ( p1 . firingRate [ i ] + "  " ) ; if ( i % 12 == 0 ) System . out . println ( "       -> X comp end." ) ; if ( i % ( 12 * 10 ) == 0 ) System . out . println ( "     -> Y comp end." ) ; } }
te	KPT	byte	public final void testAuthorizeCL ( ) throws KNXException , InterruptedException { try { mc . authorize ( dcl , new byte [ ] { 10 , 10 , 10 , 10 } ) ; fail ( "connection less" ) ; } catch ( final KNXDisconnectException e ) { } }
te	KFC	for	@ Test public void mergeCount ( ) throws Exception { scan1 . open ( ) ; StringAggregator agg = new StringAggregator ( 0 , Type . INT_TYPE , 1 , Aggregator . Op . COUNT ) ; for ( int [ ] step : count ) { agg . mergeTupleIntoGroup ( scan1 . next ( ) ) ; DbIterator it = agg . iterator ( ) ; it . open ( ) ; TestUtil . matchAllTuples ( TestUtil . createTupleList ( width1 , step ) , it ) ; } }
te	OAR	*	@ Override public int hashCode ( ) { int result = ident != null ? ident . hashCode ( ) : 0 ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; return result ; }
te	KFC	for	private void runTest ( String test , ArrayList < String > answer ) { ArrayList < String > result = tokenize ( test ) ; if ( ! checkResult ( result , answer ) ) { System . out . println ( "Failed: " + test ) ; for ( String s : result ) { System . out . print ( s + " " ) ; System . out . println ( ) ; } } else { System . out . println ( "Passed: " + test ) ; } }
te	OAR	*	static float FAST_HYPOT ( float a , float b ) { return ( float ) Math . sqrt ( ( a ) * ( a ) + ( b ) * ( b ) ) ; }
te	SYM	{	public void readStart ( ) { if ( ! readStarted ) { _read_start ( pointer ) ; } readStarted = true ; }
te	OUT	!	public void mouseMove ( MouseEvent e , Canvas c , Palette p , boolean drag ) { if ( active != null ) { Point pt = e . getPoint ( ) ; if ( ! active . pts . isEmpty ( ) && active . pts . getLast ( ) . equals ( pt ) ) return ; Rectangle r = new Rectangle ( pt ) ; if ( ! active . pts . isEmpty ( ) ) r . add ( active . pts . getLast ( ) ) ; active . add ( pt ) ; c . repaint ( r ) ; } }
te	KEH	catch	private final int jjMoveStringLiteralDfa23_0 ( long old2 , long active2 ) { if ( ( ( active2 &= old2 ) ) == 0 ) return jjStartNfa_0 ( 21 , 0 , 0 , old2 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 22 , 0 , 0 , active2 ) ; return 23 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa24_0 ( active2 , 40 ) ; default : break ; } return jjStartNfa_0 ( 22 , 0 , 0 , active2 ) ; }
te	KMD	new	public static void run ( String relation ) throws ParserConfigurationException , SAXException , IOException , InterruptedException { StringTokenizer st = new StringTokenizer ( relation , "  \n\t" ) ; Map < String , Integer > idWithVersion = new HashMap < String , Integer > ( ) ; while ( st . hasMoreTokens ( ) ) { idWithVersion . put ( st . nextToken ( ) , Integer . MAX_VALUE ) ; } updateFullRels ( idWithVersion ) ; }
te	OAS	=	public static int getColorDiff ( Color a , Color b ) { int r = a . getRed ( ) - b . getRed ( ) ; int g = a . getGreen ( ) - b . getGreen ( ) ; int u = a . getBlue ( ) - b . getBlue ( ) ; return r * r + g * g + u * u ; }
te	KPT	float	abstract int inverse ( Block vb , Object i , float [ ] in , float [ ] out ) ;
te	SYM	{	public void setChange ( TradeChangeContent value ) { this . change = value ; }
te	KMD	new	public static KuraException internalError ( Throwable cause , String message ) { return new KuraException ( KuraErrorCode . INTERNAL_ERROR , cause , message ) ; }
te	KPT	float	MovingAnnulus ( Ellipse2D . float outer , Ellipse2D . float inner ) { area = new Area ( outer ) ; area . subtract ( new Area ( inner ) ) ; this . inner = inner ; this . outer = outer ; }
te	ORE	>	@ Field ( 33 ) public IntValuedEnum < AVColorTransferCharacteristic > color_trc ( ) { return this . io . getEnumField ( this , 33 ) ; }
te	KMD	new	private void readRLE ( BufferedImage im , LittleEndianInputStream in ) throws IOException { in . readInt ( ) ; int palSize = in . readInt ( ) ; if ( palSize < 1 || palSize > 256 ) throw new FileFormatException ( "Invalid palette size" ) ; int [ ] pal = new int [ palSize ] ; for ( int i = 0 ; i < palSize ; i ++ ) pal [ i ] = readPix ( in ) ; int x = 0 ; int y = 0 ; while ( y < height ) { int c = in . readByte ( ) ; int num = ( c >> 1 ) + 1 ; if ( ( c & 1 ) == 0 ) { for ( int i = 0 ; i < num ; i ++ ) { im . setRGB ( x , y , pal [ in . readByte ( ) ] ) ; if ( ++ x >= width ) { x = 0 ; y ++ ; } } } else { int pix = pal [ in . readByte ( ) ] ; for ( int i = 0 ; i < num ; i ++ ) { im . setRGB ( x , y , pix ) ; if ( ++ x >= width ) { x = 0 ; y ++ ; } } } } }
te	ORE	>	public List < Movy > getShows ( ) { List < Movy > shows = em . createQuery ( "select distinct m " + "from model.Movy as m " + "where m.entityType = 'Show' " + "and size(m.genres) > 0 " ) . getResultList ( ) ; System . out . println ( "Shows: " + shows . size ( ) ) ; return shows ; }
te	KEH	catch	public void setClassName ( String className ) { try { this . classNameParam = new Parameter ( "ClassName" , className , this ) ; } catch ( IllegalParameterException e ) { e . printStackTrace ( ) ; } }
te	OAS	=	@ Test public void testGetContact_1 ( ) throws Exception { Hostel fixture = new Hostel ( new Integer ( 1 ) , "" , new Address ( ) , new Contact ( ) , new Policy ( ) , new LinkedList < Bed > ( ) ) ; Contact result = fixture . getContact ( ) ; assertNotNull ( result ) ; assertEquals ( "Contact [phoneNumber=null  emailId=null  facebookId=null  webURL=null]" , result . toString ( ) ) ; assertEquals ( null , result . getPhoneNumber ( ) ) ; assertEquals ( null , result . getFacebookId ( ) ) ; assertEquals ( null , result . getWebURL ( ) ) ; assertEquals ( null , result . getEmailId ( ) ) ; assertEquals ( null , result . getContactId ( ) ) ; }
te	KPT	byte	public void encodeBuffer ( byte aBuffer [ ] , OutputStream aStream ) throws IOException { ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; encodeBuffer ( inStream , aStream ) ; }
te	KFC	while	public static String getDuodecimalValue ( int value ) { String values = "0123456789AB" ; String result = "" ; int temp = value ; while ( temp > 0 ) { result = values . charAt ( temp % QuenyaCounter . BASE ) + result ; temp = temp / QuenyaCounter . BASE ; } return result ; }
te	ORE	>	public StitchedTexture ( int textureId , BufferedImage imageData , int width , int height ) { super ( textureId , imageData , width , height ) ; this . width -= this . width & f ; this . height -= this . height & f ; this . slotsU = this . width >> 4 ; this . slotsV = this . height >> 4 ; this . availableSlots = this . slotsU * this . slotsV ; this . textures = new HashMap < String , SubTexture > ( ) ; this . slots = new boolean [ this . availableSlots ] ; this . loadImageData ( ) ; }
te	KFC	for	@ Override public void run ( ) { for ( RaftServer s : servers ) { synchronized ( s ) { System . out . println ( s ) ; } } }
te	OLB	|	protected final static byte composeSpecificFeatures ( byte esmClass , byte specificFeaturesValue ) { return ( byte ) ( cleanSpecificFeatures ( esmClass ) | specificFeaturesValue ) ; }
te	OLB	|	public void cargarDialogoCambiarDuenio ( ) { try { Cliente c = panelAdminContratos . getContratoSeleccionado ( ) . getDuenio ( ) ; dialogoCambiarDuenio . setCliente ( c ) ; dialogoCambiarDuenio . setVisible ( true ) ; } catch ( NullPointerException | ArrayIndexOutOfBoundsException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "No ha seleccionado un contrato de la tabla" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
te	OLB	|	@ Override public void actionPerformed ( ActionEvent e ) { if ( tblDeleted . getSelectedRow ( ) == - 1 ) { JOptionPane . showMessageDialog ( frmUserWindow , "Select item to retreive !" ) ; } else { TestConnection tc = new TestConnection ( ) ; DatabaseManager dm = new DatabaseManager ( ) ; Inventory i = new Inventory ( ) ; String code = get . getItemCode ( ) ; String name = get . getItemName ( ) ; String brand = get . getItemBrand ( ) ; String color = get . getItemColor ( ) ; String style = get . getItemStyle ( ) ; String category = get . getItemCategory ( ) ; String size = get . getSize ( ) ; int quantity = get . getQuantityAvailable ( ) ; int price = get . getPrice ( ) ; i . setItemCode ( code ) ; i . setItemName ( name ) ; i . setItemBrand ( brand ) ; i . setItemColor ( color ) ; i . setItemStyle ( style ) ; i . setItemCategory ( category ) ; i . setSize ( size ) ; i . setQuantityAvailable ( quantity ) ; i . setPrice ( price ) ; DefaultTableModel model = ( DefaultTableModel ) tblDeleted . getModel ( ) ; String ItemCode = ( model . getValueAt ( tblDeleted . getSelectedRow ( ) , 0 ) . toString ( ) ) ; try { int rs = dm . insertInventory ( tc . getConnection ( ) , i ) ; int rs2 = dm . retrieve ( tc . getConnection ( ) , ItemCode ) ; if ( rs == 1 ) { updateItemTable ( ) ; updateDeleteLogsTable ( ) ; JOptionPane . showMessageDialog ( frmUserWindow , "Successfully Retreive !" ) ; } if ( rs2 == 1 ) { updateDeleteLogsTable ( ) ; updateItemTable ( ) ; } } catch ( ClassNotFoundException | SQLException e1 ) { e1 . printStackTrace ( ) ; } } }
te	OUT	!	public void actionPerformed ( ActionEvent evt ) { String title = jMenuItemToolsArffViewer . getText ( ) ; if ( ! containsWindow ( title ) ) { ArffViewerMainPanel panel = new ArffViewerMainPanel ( null ) ; panel . setConfirmExit ( false ) ; Container frame = createFrame ( m_Self , title , panel , new BorderLayout ( ) , BorderLayout . CENTER , 800 , 600 , panel . getMenu ( ) , true , true ) ; panel . setParent ( frame ) ; } else { showWindow ( getWindow ( title ) ) ; } }
te	SYM	{	@ Test @ Override public void verifyDefinition ( ) { for ( int n = 0 ; n < getMaxTests ( ) ; n ++ ) { long x = ( long ) ( ( n * ( ( 5 * n ) - 3 ) ) / 2 ) ; assert . assertEquals ( x , seq . get ( n ) . longValue ( ) ) ; } }
te	SYM	{	public void setContaOrigem ( Conta contaOrigem ) { this . contaOrigem = contaOrigem ; }
te	OAR	*	public static double det3 ( RowD1Matrix64F mat ) { double m [ ] = mat . data ; double a11 = m [ 0 ] ; double a12 = m [ 1 ] ; double a13 = m [ 2 ] ; double a21 = m [ 3 ] ; double a22 = m [ 4 ] ; double a23 = m [ 5 ] ; double a31 = m [ 6 ] ; double a32 = m [ 7 ] ; double a33 = m [ 8 ] ; double a = a11 * ( a22 * a33 - a23 * a32 ) ; double b = a12 * ( a21 * a33 - a23 * a31 ) ; double c = a13 * ( a21 * a32 - a31 * a22 ) ; return a - b + c ; }
te	SYM	}	public EffectType getEffectType ( ) { return effectType ; }
te	OAR	*	public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double absAsinh ; if ( a > 0.167 ) { absAsinh = FastMath . log ( FastMath . sqrt ( a * a + 1 ) + a ) ; } else { final double a2 = a * a ; if ( a > 0.097 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * ( F_1_9 - a2 * ( F_1_11 - a2 * ( F_1_13 - a2 * ( F_1_15 - a2 * F_1_17 * F_15_16 ) * F_13_14 ) * F_11_12 ) * F_9_10 ) * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else if ( a > 0.036 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * ( F_1_9 - a2 * ( F_1_11 - a2 * F_1_13 * F_11_12 ) * F_9_10 ) * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else if ( a > 0.0036 ) { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * ( F_1_5 - a2 * ( F_1_7 - a2 * F_1_9 * F_7_8 ) * F_5_6 ) * F_3_4 ) * F_1_2 ) ; } else { absAsinh = a * ( 1 - a2 * ( F_1_3 - a2 * F_1_5 * F_3_4 ) * F_1_2 ) ; } } return negative ? - absAsinh : absAsinh ; }
te	OAS	=	public Pattern ( int numChannels ) { instrument = new int [ 64 ] [ numChannels ] ; period = new int [ 64 ] [ numChannels ] ; volColumn = new int [ 64 ] [ numChannels ] ; effectCommand = new int [ 64 ] [ numChannels ] ; effectValue = new int [ 64 ] [ numChannels ] ; }
te	KMD	new	public String getDefaultBackupName ( ) { Date timestamp = new Date ( ) ; String name = String . format ( "playlist backup %1$tY-%1$tm-%1$td %1$tH%1$tM.zip" , timestamp ) ; File file = new File ( _rootDirectory , name ) ; return file . getAbsolutePath ( ) ; }
te	KMD	new	public double [ ] multiply ( double [ ] vectorData ) { final double [ ] result = new double [ vectorData . length ] ; final double [ ] thisData = this . data ; int i = 0 ; for ( int offset = 0 ; offset < vectorData . length ; offset += 4 ) { result [ i ++ ] = this . data [ 0 ] * vectorData [ offset ] + thisData [ 0 + SIZE ] * vectorData [ offset + 1 ] + thisData [ 0 + SIZE * 2 ] * vectorData [ offset + 2 ] + thisData [ 0 + SIZE * 3 ] * vectorData [ offset + 3 ] ; result [ i ++ ] = thisData [ 1 ] * vectorData [ offset ] + thisData [ 1 + SIZE ] * vectorData [ offset + 1 ] + thisData [ 1 + SIZE * 2 ] * vectorData [ offset + 2 ] + thisData [ 1 + SIZE * 3 ] * vectorData [ offset + 3 ] ; result [ i ++ ] = thisData [ 2 ] * vectorData [ offset ] + thisData [ 2 + SIZE ] * vectorData [ offset + 1 ] + thisData [ 2 + SIZE * 2 ] * vectorData [ offset + 2 ] + thisData [ 2 + SIZE * 3 ] * vectorData [ offset + 3 ] ; result [ i ++ ] = thisData [ 3 ] * vectorData [ offset + 0 ] + thisData [ 3 + SIZE ] * vectorData [ offset + 1 ] + thisData [ 3 + SIZE * 2 ] * vectorData [ offset + 2 ] + thisData [ 3 + SIZE * 3 ] * vectorData [ offset + 3 ] ; } return result ; }
te	OAS	=	public void setMDataOutOwnshpRange ( String value ) { this . mDataOutOwnshpRange = value ; }
te	ORE	!=	public void sim_process_until ( Sim_predicate p , Sim_event ev ) { if ( ! Sim_system . running ( ) ) { return ; } double start_time = Sim_system . sim_clock ( ) ; if ( stat != null ) { stat . set_busy ( start_time ) ; } if ( Sim_system . default_tracing ( ) ) { Sim_system . trace ( me , "start holding" ) ; } sim_wait_for ( p , ev ) ; if ( ! Sim_system . running ( ) ) return ; if ( stat != null ) { stat . update ( Sim_stat . END_HOLD , start_time , Sim_system . sim_clock ( ) ) ; } }
te	OAS	=	public void setCustomNumber52 ( BigDecimal customNumber52 ) { this . customNumber52 = customNumber52 ; }
te	KPT	byte	public Ms_availability_status ( byte value ) { super ( Tag . MS_AVAILABILITY_STATUS , value ) ; }
te	ORE	>	@ SuppressWarnings ( "unchecked" ) private Value search ( Key key , Node node ) { Node xNode = node ; while ( xNode != null ) { if ( xNode . is12Node ( ) ) { Node12 tempNode12 = ( Node12 ) xNode ; int cmp = key . compareTo ( tempNode12 . key1 ) ; if ( cmp < 0 ) { xNode = tempNode12 . leftChild ; } else if ( cmp > 0 ) { xNode = tempNode12 . rightChild ; } else { return tempNode12 . value1 ; } } else if ( xNode . is23Node ( ) ) { Node23 tempNode23 = ( Node23 ) xNode ; int cmp1 = key . compareTo ( tempNode23 . key1 ) ; int cmp2 = key . compareTo ( tempNode23 . key2 ) ; if ( cmp1 < 0 ) { xNode = tempNode23 . leftChild ; } else if ( cmp2 > 0 ) { xNode = tempNode23 . rightChild ; } else if ( cmp1 == 0 ) { return tempNode23 . value1 ; } else if ( cmp2 == 0 ) { return tempNode23 . value2 ; } else { xNode = tempNode23 . middleChild ; } } } return null ; }
te	KEH	catch	public void run ( ) { Server server ; try { server = new Server ( 4444 ) ; server . serve ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	OAS	=	public void setAmount ( Amount value ) { this . amount = value ; }
te	ORE	!=	public void actionPerformed ( ActionEvent e ) { mxGraph graph = mxGraphActions . getGraph ( e ) ; if ( graph != null && ! graph . isSelectionEmpty ( ) ) { graph . setCellStyles ( key , value ) ; } }
te	KMD	new	@ Test public void cityGets3ProductionWithSize2ProductionFocusAndHillsAdjacent ( ) { CityImpl city = ( CityImpl ) game . getCityAt ( new Position ( 1 , 1 ) ) ; city . setWorkforceFocus ( GameConstants . productionFocus ) ; city . setProduction ( GameConstants . LEGION ) ; wait ( 8 ) ; assertEquals ( "City should have population 2" , 2 , city . getSize ( ) ) ; assertEquals ( "City should have 8 production" , 8 , city . getProductionTotal ( ) ) ; wait ( 1 ) ; assertEquals ( "City should have 11 production" , 11 , city . getProductionTotal ( ) ) ; }
te	SYM	}	public AIDuelSupporter ( Model model , AiDuelOptionsWindow optionsWindow ) { this . model = model ; this . optionsWindow = optionsWindow ; }
te	OLB	|	public final short nextShort ( ) { if ( mti >= 624 ) { int i1 ; for ( i1 = 0 ; i1 < 227 ; i1 ++ ) { int i = mt [ i1 ] & 80000000 | mt [ i1 + 1 ] & 7fffffff ; mt [ i1 ] = mt [ i1 + 397 ] ^ i >>> 1 ^ mag01 [ i & 1 ] ; } for ( ; i1 < 623 ; i1 ++ ) { int j = mt [ i1 ] & 80000000 | mt [ i1 + 1 ] & 7fffffff ; mt [ i1 ] = mt [ i1 + - 227 ] ^ j >>> 1 ^ mag01 [ j & 1 ] ; } int k = mt [ 623 ] & 80000000 | mt [ 0 ] & 7fffffff ; mt [ 623 ] = mt [ 396 ] ^ k >>> 1 ^ mag01 [ k & 1 ] ; mti = 0 ; } int l = mt [ mti ++ ] ; l ^= l >>> 11 ; l ^= l << 7 & 9d2c5680 ; l ^= l << 15 & efc60000 ; l ^= l >>> 18 ; return ( short ) ( l >>> 16 ) ; }
te	KPT	float	@ Override protected void paint ( Graphics2D g ) { if ( isPaint ) { super . paint ( g ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; Color stringColor = new Color ( 0 , 1.0f , 0 , PAINT_OPACITY ) ; if ( ctx . isRadarMode ( ctx . MODE_RADAR_LOCKON ) ) { stringColor = new Color ( 1.0f , 0.7f , 0 , PAINT_OPACITY ) ; } if ( Math . abs ( ctx . my . velocity ) < 7.5 ) { stringColor = new Color ( ( float ) stringColor . getRed ( ) / 255.0f , ( float ) stringColor . getGreen ( ) / 255.0f , 0.7f , PAINT_OPACITY ) ; } if ( ctx . gunHeat == 0.0 ) { stringColor = new Color ( 0.7f , ( float ) stringColor . getGreen ( ) / 255.0f , ( float ) stringColor . getBlue ( ) / 255.0f , PAINT_OPACITY ) ; } g . setColor ( stringColor ) ; if ( ctx . lockonTarget != null ) { } for ( Map . Entry < String , Enemy > e : ctx . nextEnemyMap . entrySet ( ) ) { Enemy base = enemyMap . get ( e . getKey ( ) ) ; Enemy enemy = e . getValue ( ) ; g . setColor ( new Color ( 1.0f , 0.7f , 0 , PAINT_OPACITY ) ) ; if ( isStale ( enemy ) ) { g . setColor ( new Color ( 1.0f , 0.0f , 0 , PAINT_OPACITY ) ) ; } Point priority = Util . calcPoint ( ctx . my . calcRadians ( enemy ) , calcPriority ( enemy ) ) . add ( ctx . my ) ; g . drawLine ( ( int ) enemy . x , ( int ) enemy . y , ( int ) priority . x , ( int ) priority . y ) ; g . setColor ( new Color ( 0.2f , 1.0f , 0.7f , PAINT_OPACITY ) ) ; drawRound ( g , enemy . x , enemy . y , 35 ) ; g . setColor ( new Color ( 0.3f , 0.5f , 1.0f , PAINT_OPACITY ) ) ; Enemy next = new Enemy ( enemy ) ; MoveType aimType = getBestAimType ( next ) ; } g . setColor ( new Color ( 0 , 0 , 0 , PAINT_OPACITY ) ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; for ( Map . Entry < String , BulletInfo > e : ctx . nextBulletList . entrySet ( ) ) { BulletInfo info = e . getValue ( ) ; if ( ! info . owner . equals ( name ) ) { MovingPoint bullet = new MovingPoint ( info . src ) ; for ( int i = 0 ; i < BULLET_PROSPECT_TIME ; i ++ ) { drawRound ( g , bullet . x , bullet . y , 5 ) ; bullet . inertia ( 1 ) ; } } } g . setStroke ( new BasicStroke ( 4.0f ) ) ; if ( ctx . lockOnPoint != null ) { g . setColor ( new Color ( 1.0f , 1.0f , 0 , PAINT_OPACITY ) ) ; drawRound ( g , ctx . lockOnPoint . x , ctx . lockOnPoint . y , 5 ) ; } if ( ctx . G != null ) { g . setColor ( new Color ( 0 , 0 , 0 , PAINT_OPACITY ) ) ; drawRound ( g , ctx . G . x , ctx . G . y , 10 ) ; } if ( ctx . > != null ) { g . setColor ( new Color ( 1.0f , 1.0f , 1.0f , PAINT_OPACITY ) ) ; drawRound ( g , ctx . > . x , ctx . > . y , 10 ) ; } } }
te	ORE	!=	public boolean isSetRemarks ( ) { return ( ( this . remarks != null ) && ( ! this . remarks . isEmpty ( ) ) ) ; }
