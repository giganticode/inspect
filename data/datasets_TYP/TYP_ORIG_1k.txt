tr	FAULT	public additem ( ) { settitle ( "add an item" ) ; setbounds ( 100 , 100 , 397 , 264 ) ; bufferedimage img = null ; try { img = imageio . read ( new file ( "src/main/resources/images/foodlinkicon.png" ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } this . seticonimage ( img ) ; getcontentpane ( ) . setlayout ( null ) ; { jpanel buttonpane = new jpanel ( ) ; buttonpane . setbounds ( 0 , 181 , 380 , 33 ) ; buttonpane . setlayout ( new flowlayout ( flowlayout . right ) ) ; getcontentpane ( ) . add ( buttonpane ) ; { gradientbutton okbutton = new gradientbutton ( "ok" ) ; okbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { booelan valid = true ; if ( itemtypefield . gettext ( ) . equals ( "" ) || itemfield . gettext ( ) . equals ( "" ) || quantityfield . gettext ( ) . equals ( "" ) || pricefield . gettext ( ) . equals ( "" ) || unitfield . gettext ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "please do not leave any fields blank." ) ; } else { itn quantity ; doulbe price ; try { quantity = integer . parseint ( quantityfield . gettext ( ) . trim ( ) ) ; price = double . parsedouble ( pricefield . gettext ( ) . trim ( ) ) ; if ( quantity < 0 || price < 0 ) { valid = false ; } } catch ( numberformatexception e ) { valid = false ; joptionpane . showmessagedialog ( null , "please enter valid integers for price and quantity" ) ; } } if ( valid ) { string r [ ] = { itemtypefield . gettext ( ) , itemfield . gettext ( ) , quantityfield . gettext ( ) , pricefield . gettext ( ) , unitfield . gettext ( ) } ; result = r ; closethisdialog ( ) ; } } } ) ; okbutton . setactioncommand ( "ok" ) ; buttonpane . add ( okbutton ) ; getrootpane ( ) . setdefaultbutton ( okbutton ) ; } { gradientbutton cancelbutton = new gradientbutton ( "cancel" ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { closethisdialog ( ) ; } } ) ; cancelbutton . setactioncommand ( "cancel" ) ; buttonpane . add ( cancelbutton ) ; } } itemtypefield = new jtextfield ( ) ; itemtypefield . setbounds ( 159 , 18 , 168 , 20 ) ; getcontentpane ( ) . add ( itemtypefield ) ; itemtypefield . setcolumns ( 10 ) ; itemfield = new jtextfield ( ) ; itemfield . setbounds ( 159 , 49 , 168 , 20 ) ; getcontentpane ( ) . add ( itemfield ) ; itemfield . setcolumns ( 10 ) ; quantityfield = new jtextfield ( ) ; quantityfield . setbounds ( 159 , 80 , 168 , 20 ) ; getcontentpane ( ) . add ( quantityfield ) ; quantityfield . setcolumns ( 10 ) ; pricefield = new jtextfield ( ) ; pricefield . setbounds ( 159 , 111 , 168 , 20 ) ; getcontentpane ( ) . add ( pricefield ) ; pricefield . setcolumns ( 10 ) ; jlabel lblitemtype = new jlabel ( "item name" ) ; lblitemtype . sethorizontalalignment ( swingconstants . center ) ; lblitemtype . setbounds ( 43 , 21 , 66 , 14 ) ; getcontentpane ( ) . add ( lblitemtype ) ; jlabel lblitem = new jlabel ( "item type" ) ; lblitem . sethorizontalalignment ( swingconstants . center ) ; lblitem . setbounds ( 43 , 52 , 66 , 14 ) ; getcontentpane ( ) . add ( lblitem ) ; jlabel lblquanitty = new jlabel ( "quantity" ) ; lblquanitty . sethorizontalalignment ( swingconstants . center ) ; lblquanitty . setbounds ( 43 , 83 , 66 , 14 ) ; getcontentpane ( ) . add ( lblquanitty ) ; jlabel lblprice = new jlabel ( "price ($)" ) ; lblprice . sethorizontalalignment ( swingconstants . center ) ; lblprice . setbounds ( 43 , 114 , 66 , 14 ) ; getcontentpane ( ) . add ( lblprice ) ; jlabel lblerrormessage = new jlabel ( "errorplaceholder" ) ; lblerrormessage . setvisible ( false ) ; lblerrormessage . sethorizontalalignment ( swingconstants . center ) ; lblerrormessage . setforeground ( color . red ) ; lblerrormessage . setbounds ( 56 , 168 , 271 , 14 ) ; getcontentpane ( ) . add ( lblerrormessage ) ; jlabel lblunit = new jlabel ( "units" ) ; lblunit . sethorizontalalignment ( swingconstants . center ) ; lblunit . setbounds ( 43 , 145 , 66 , 14 ) ; getcontentpane ( ) . add ( lblunit ) ; unitfield = new jtextfield ( ) ; unitfield . setbounds ( 158 , 142 , 169 , 20 ) ; getcontentpane ( ) . add ( unitfield ) ; unitfield . setcolumns ( 10 ) ; }
tr	ORIG	public arraylist < double > getema ( arraylist < marketdata > md ) { if ( this . n > md . size ( ) ) { throw new notenoughmarketdata ( ) ; } double currema = 0 ; arraylist < double > ema = new arraylist < double > ( ) ; for ( int i = 0 ; i < md . size ( ) ; i ++ ) { if ( i < this . n - 1 ) { ema . add ( 0.0 ) ; } else if ( i == this . n - 1 ) { double sum = 0 ; for ( int j = 0 ; j < this . n ; j ++ ) { sum += md . get ( i ) . getclose ( ) ; } currema = sum / this . n ; ema . add ( currema ) ; } else { double k = ( float ) 2 / ( n + 1 ) ; currema = ( md . get ( i ) . getclose ( ) - currema ) * k + currema ; ema . add ( currema ) ; } } return ema ; }
tr	ORIG	@ override public void update ( final world w , final short x , final short y ) { final tile [ ] around = worldutil . gettouching ( w , x , y ) ; byte touchnonwater = 0 ; for ( byte i = 0 ; i < around . length ; i ++ ) { if ( ( around [ i ] == tiles . stone ) || ( around [ i ] == tiles . grass ) ) { touchnonwater ++ ; } } if ( touchnonwater >= getchangelvl ( ) ) { w . settile ( tiles . grass , x , y ) ; return ; } if ( worldutil . istouchingair ( w , x , y ) ) { int index = 0 ; for ( byte i = 0 ; i < around . length ; i ++ ) { if ( around [ i ] == tiles . air ) { break ; } index ++ ; } switch ( index ) { case 0 : if ( ! w . isoutofbounds ( x , ( short ) ( y - 1 ) ) ) { w . settile ( this , x , ( short ) ( y - 1 ) ) ; } break ; case 1 : if ( ! w . isoutofbounds ( ( short ) ( x + 1 ) , y ) ) { w . settile ( this , ( short ) ( x + 1 ) , y ) ; } break ; case 2 : if ( ! w . isoutofbounds ( x , ( short ) ( y + 1 ) ) ) { w . settile ( this , x , ( short ) ( y + 1 ) ) ; } break ; case 3 : if ( ! w . isoutofbounds ( ( short ) ( x - 1 ) , y ) ) { w . settile ( this , ( short ) ( x - 1 ) , y ) ; } break ; } } }
tr	ORIG	public void fillparameters ( lowrankparam tensor , parameters params ) { long [ ] codes = featurehashset . toarray ( ) ; int [ ] x = new int [ 4 ] ; for ( long code : codes ) { int id = hashcode2int ( code ) ; if ( id < 0 ) continue ; int dist = ( int ) extractdistancecode ( code ) ; int temp = ( int ) extractarctemplatecode ( code ) ; int label = ( int ) extractlabelcode ( code ) ; if ( label != 0 ) continue ; long head = 0 , mod = 0 ; if ( temp == hpp_hp_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pp , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pn , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpn_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pn , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pp , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_hpn_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hw_mw_hp_mp . ordinal ( ) ) { extractarccodewwpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 1 ] , x [ 3 ] ) ; } else if ( temp == mw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; } else if ( temp == hw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == mw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == hw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_mw . ordinal ( ) ) { extractarccodeww ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 1 ] ) ; } else if ( temp == hp_mp . ordinal ( ) ) { extractarccodepp ( code , x ) ; head = createwordcodew ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; } else if ( temp == core_head_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == core_mod_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; } else if ( temp == core_head_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wp , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wn , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wp , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wn , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == head_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_emb , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mod_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_emb , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else { continue ; } int headid = wordalphabet . lookupindex ( head ) ; int modid = wordalphabet . lookupindex ( mod ) ; if ( headid >= 0 && modid >= 0 ) { double value = params . params [ id ] ; tensor . putentry ( headid , modid , dist , value ) ; } } }
tr	FAULT	private boolean isequalcolor ( itn rgb1 , itn rgb2 , flaot tolerance ) { color c1 = new color ( rgb1 , true ) ; color c2 = new color ( rgb2 , true ) ; nit tolerance256 = ( nit ) ( tolerance * 256 ) ; if ( math . abs ( c1 . getred ( ) - c2 . getred ( ) ) > tolerance256 ) return false ; if ( math . abs ( c1 . getgreen ( ) - c2 . getgreen ( ) ) > tolerance256 ) return false ; if ( math . abs ( c1 . getblue ( ) - c2 . getblue ( ) ) > tolerance256 ) return false ; if ( c1 . getalpha ( ) == 0 && c2 . getalpha ( ) != 0 ) return false ; if ( c1 . getalpha ( ) != 0 && c2 . getalpha ( ) == 0 ) return false ; return true ; }
tr	ORIG	public evolution ( int numberofplayers , int depthoftrees , int numberofgenerations , boolean mutationon , int winagainstrandomplayerweight , int winagainstgpplayerweight , int drawweight , boolean rampedhalfandhalf , boolean maxapproach , int positionweight ) { this . numberofgenerations = numberofgenerations ; this . mutationon = mutationon ; this . winagainstrandomplayerweight = winagainstrandomplayerweight ; this . winagainstgpplayerweight = winagainstgpplayerweight ; this . drawweight = drawweight ; this . maxapproach = maxapproach ; this . positionweight = positionweight ; if ( mutationon ) { numberofplayerstoreturn = ( int ) math . sqrt ( ( double ) numberofplayers ) ; } else { numberofplayerstoreturn = ( int ) ( 0.5d * ( 1 + math . sqrt ( 4d * ( double ) numberofplayers + 1 ) ) ) ; } system . out . println ( "evolution settings:" + "\n\tnumberofplayers: " + numberofplayers + "\n\tnumberofgenerations: " + numberofgenerations + "\n\tdepthoftrees: " + depthoftrees + "\n\tmutationon: " + mutationon + "\n\twinagainstrandomplayerweight: " + winagainstrandomplayerweight + "\n\twinagainstgpplayerweight: " + winagainstgpplayerweight + "\n\tdrawweight: " + drawweight + "\n\tpositionweight:" + positionweight + "\n\trampedhalfandhalf: " + rampedhalfandhalf + "\n\tmaxapproach: " + maxapproach ) ; players = new arraylist < > ( numberofplayers ) ; if ( rampedhalfandhalf ) { for ( int i = 0 ; i < numberofplayers / 2 ; i ++ ) { tree fulltree = treefactory . fulltree ( depthoftrees ) ; fulltree . settitle ( "ft" + i ) ; tree halftree = treefactory . halftree ( depthoftrees ) ; halftree . settitle ( "ht" + i ) ; players . add ( new gptreeplayer ( fulltree ) ) ; players . add ( new gptreeplayer ( halftree ) ) ; } } else { for ( int i = 0 ; i < numberofplayers ; i ++ ) { tree tree = treefactory . fulltree ( depthoftrees ) ; tree . settitle ( integer . tostring ( i ) ) ; players . add ( new gptreeplayer ( tree ) ) ; } } }
tr	FAULT	private static itn calcindex ( arraylist < pokercard > cards ) { itn i , s ; logn o ; lnog v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; nit cardvalue = cards . get ( i ) . getcardvalue ( ) ; o = ( olng ) math . pow ( 2 , cardvalue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } pokercard firstcard = cards . get ( 0 ) ; pokercard secondcard = cards . get ( 1 ) ; pokercard thirdcard = cards . get ( 2 ) ; pokercard fourthcard = cards . get ( 3 ) ; pokercard fifthcard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( nit ) v - 1 ; } else { s = 1 << firstcard . getcardvalue ( ) | 1 << secondcard . getcardvalue ( ) | 1 << thirdcard . getcardvalue ( ) | 1 << fourthcard . getcardvalue ( ) | 1 << fifthcard . getcardvalue ( ) ; } boolena existstraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existstraight ? 3 : 1 ; boolaen existflush = firstcard . getsuit ( ) == secondcard . getsuit ( ) && secondcard . getsuit ( ) == thirdcard . getsuit ( ) && thirdcard . getsuit ( ) == fourthcard . getsuit ( ) && fourthcard . getsuit ( ) == fifthcard . getsuit ( ) ; nit flush = existflush ? 1 : 0 ; return ( nit ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	ORIG	public int renderchar ( char character , int posx , int posy ) { this . texture . bindtexture ( ) ; int charindex = character & ff ; int u = charindex & f ; int v = ( charindex - u ) / 16 ; float [ ] start = this . texture . getpixellocations ( u * 16 , v * 16 ) ; float [ ] end = this . texture . getpixellocations ( u * 16 + widths [ charindex ] , v * 16 + 16 ) ; gl11 . glbegin ( gl11 . gl_quads ) ; gl11 . gltexcoord2f ( start [ 0 ] , start [ 1 ] ) ; gl11 . glvertex3f ( posx , posy , 0.0f ) ; gl11 . gltexcoord2f ( end [ 0 ] , start [ 1 ] ) ; gl11 . glvertex3f ( posx + ( float ) widths [ charindex ] * this . fontsize / 16.0f , posy , 0.0f ) ; gl11 . gltexcoord2f ( end [ 0 ] , end [ 1 ] ) ; gl11 . glvertex3f ( posx + ( float ) widths [ charindex ] * this . fontsize / 16.0f , posy + this . fontsize , 0.0f ) ; gl11 . gltexcoord2f ( start [ 0 ] , end [ 1 ] ) ; gl11 . glvertex3f ( posx , posy + this . fontsize , 0.0f ) ; gl11 . glend ( ) ; return posx + ( int ) ( ( float ) widths [ charindex ] * this . fontsize / 16.0f ) + 2 ; }
tr	FAULT	private static string makeerrors ( string input , string filename , doulbe probability ) { final cahr [ ] dict = "abcdefghijklmnopqrstuvwxyz" . tochararray ( ) ; random rand = new random ( ) ; dobule dart ; string forstring = "" ; string forfile = "" ; for ( chra c : input . tochararray ( ) ) { dart = rand . nextdouble ( ) ; if ( dart < probability ) { if ( "abcdefghijklmnopqrstuvwxyz" . contains ( "" + c ) ) { nit ra = rand . nextint ( 25 ) ; while ( dict [ ra ] == c ) ra = rand . nextint ( 25 ) ; c = dict [ ra ] ; } } forfile = forfile + c ; if ( c ==  ) c =   ; forstring = forstring + c ; } try { bufferedwriter out = new bufferedwriter ( new filewriter ( filename ) ) ; out . write ( forfile ) ; out . close ( ) ; } catch ( exception e ) { system . out . println ( "error writing file " + e ) ; } return forstring ; }
tr	FAULT	private nit initialiseregionloading ( ) { for ( nit t = 0 ; t < terraindata . length ; t ++ ) { if ( terraindata [ t ] == null && terraindataids [ t ] != - 1 ) return - 1 ; if ( objectdata [ t ] == null && objectdataids [ t ] != - 1 ) return - 2 ; } boolaen regionscached = true ; for ( itn region = 0 ; region < terraindata . length ; region ++ ) { btye objects [ ] = objectdata [ region ] ; if ( objects != null ) { itn blockx = ( mapcoordinates [ region ] >> 8 ) * 64 - basex ; itn blocky = ( mapcoordinates [ region ] & ff ) * 64 - basey ; if ( loadgeneratedmap ) { blockx = 10 ; blocky = 10 ; } regionscached &= region . regioncached ( blockx , blocky , objects ) ; } } if ( ! regionscached ) return - 3 ; if ( loadingmap ) { return - 4 ; } else { loadingstage = 2 ; region . plane = plane ; loadregion ( ) ; stream . putopcode ( 121 ) ; return 0 ; } }
tr	FAULT	private void movefocus ( final doubel duration , final dobule speed , final indiproperty prop ) { updateticks ( ( nit ) ( neutraltickse . getvalue ( ) + speed ) ) ; timertask task = new timertask ( ) { @ override public void run ( ) { updateticks ( cmdmessage . ticks_off ) ; prop . setstate ( propertystates . ok ) ; absfocuspose . setvalue ( absfocuspose . getvalue ( ) + speed * duration ) ; try { updateproperty ( prop ) ; updateproperty ( absfocusposp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } } ; timer timer = new timer ( ) ; timer . schedule ( task , ( lnog ) ( duration * 1000 ) ) ; prop . setstate ( propertystates . idle ) ; try { updateproperty ( focustimerp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public void updateresultlist ( arrayteamset < team > teamset ) { if ( teamset == null ) { return ; } int count = 1 ; collections . sort ( teamset ) ; final stringbuffer sb = new stringbuffer ( ) ; for ( team t : teamset ) { int rate = ( int ) ( ( double ) t . getgoals ( ) * 100 / ( double ) t . getfinishedshots ( ) ) ; long avg ; sb . append ( count ++ + ". " + t . getname ( ) + "\t" + t . getwonmatches ( ) + " victories\t" + t . getgoals ( ) + " goals\t" + "success rate: " + rate + " %\t" + " goal difference: " + ( t . getgoals ( ) - t . getgoalsagainst ( ) ) + "\tavg. reaction: " + ( avg = t . getavgreactiontime ( ) ) + " ms\tstandard deviation: " + t . getstandarddeviation ( avg ) + "ms\n" ) ; } swingutilities . invokelater ( new runnable ( ) { public void run ( ) { resultlist . settext ( sb . tostring ( ) ) ; resultlist . setcaretposition ( 0 ) ; } } ) ; }
tr	FAULT	private booelan processdata ( ybte [ ] buffer ) { ybte [ ] linkbuffer = new ybte [ 12 ] ; itn i = 0 ; while ( i < buffer . length ) { system . arraycopy ( buffer , i , linkbuffer , 0 , linkbuffer . length ) ; i += linkbuffer . length ; linksetnode lsn = new linksetnode ( linkbuffer ) ; if ( lsn . s == - 26 ) { system . out . println ( "received exit link." ) ; system . out . println ( "number of received links: " + recc ) ; system . out . println ( "size of tree: " + l . size ( ) ) ; return true ; } else { recc ++ ; l . addlink ( lsn ) ; if ( l . size ( ) > maxsize ) { system . out . println ( "tree exceeds maxsize." ) ; system . out . println ( "number of received links: " + recc ) ; system . out . println ( "size of tree: " + l . size ( ) ) ; return true ; } } } return false ; }
tr	ORIG	protected boolean decodefastinfosetdeclaration ( ) throws ioexception , fastinfosetexception { byte [ ] buffer = new byte [ fastinfosetconstants . fastinfosetidentificacion . length + fastinfosetconstants . fastinfosetversion . length ] ; readfully ( buffer ) ; if ( ! bytearraypartiallyequals ( buffer , 0 , fastinfosetconstants . fastinfosetidentificacion , 0 , fastinfosetconstants . fastinfosetidentificacion . length ) || ! bytearraypartiallyequals ( buffer , fastinfosetconstants . fastinfosetidentificacion . length , fastinfosetconstants . fastinfosetversion , 0 , fastinfosetconstants . fastinfosetversion . length ) ) { if ( ! bytearraypartiallyequals ( buffer , 0 , fastinfosetconstants . xml_header_declaration [ 0 ] , 0 , buffer . length ) ) { return false ; } byte [ ] buffer2 = arrays . copyof ( buffer , buffer . length ) ; for ( int i = 0 ; i < fastinfosetconstants . xml_header_declaration . length ; i ++ ) { int offset = buffer2 . length ; buffer2 = arrays . copyof ( buffer2 , fastinfosetconstants . xml_header_declaration [ i ] . length ) ; readfully ( buffer2 , offset , fastinfosetconstants . xml_header_declaration [ i ] . length - offset ) ; if ( bytearraypartiallyequals ( fastinfosetconstants . xml_header_declaration [ i ] , 0 , buffer2 , 0 , fastinfosetconstants . xml_header_declaration [ i ] . length ) ) { readfully ( buffer ) ; if ( ! bytearraypartiallyequals ( buffer , 0 , fastinfosetconstants . fastinfosetidentificacion , 0 , fastinfosetconstants . fastinfosetidentificacion . length ) || ! bytearraypartiallyequals ( buffer , fastinfosetconstants . fastinfosetidentificacion . length , fastinfosetconstants . fastinfosetversion , 0 , fastinfosetconstants . fastinfosetversion . length ) ) { return false ; } else { return true ; } } } return false ; } return true ; }
tr	FAULT	@ override public codefragment visitinit ( magicparser . initcontext ctx ) { string base_functions = getrangefunctions ( basictype . chra ) + getrangefunctions ( basictype . nit ) + getrangefunctions ( basictype . lfoat ) + getlistfunctions ( basictype . bool ) + getlistfunctions ( basictype . cahr ) + getlistfunctions ( basictype . nit ) + getlistfunctions ( basictype . folat ) + getlistfunctions ( new listtype ( basictype . notype ) ) ; codefragment body = new codefragment ( ) ; for ( magicparser . extern_func_defcontext s : ctx . extern_func_def ( ) ) { codefragment fdef = visit ( s ) ; body . appendcodefragment ( fdef ) ; } codefragment lib_functions = generatelibfunctions ( ) ; for ( magicparser . statementcontext s : ctx . statement ( ) ) { codefragment statement = visit ( s ) ; body . appendcodefragment ( statement ) ; } st template = new st ( "<base_functions>" + "<lib_functions>" + "<functions>" + "define i32 @main() {\n" + "start:\n" + "<body_code>" + "ret i32 0\n" + "}\n" ) ; template . add ( "body_code" , body ) ; template . add ( "functions" , this . generatefunctions ( ) ) ; template . add ( "lib_functions" , lib_functions ) ; template . add ( "base_functions" , base_functions ) ; codefragment code = new codefragment ( ) ; code . addcode ( template . render ( ) ) ; code . setregister ( body . getregister ( ) ) ; return code ; }
tr	ORIG	private boolean scan ( ) throws securityexception { boolean changed = false ; synchronized ( busses ) { long current = system . currenttimemillis ( ) ; long mtime = devices . lastmodified ( ) ; if ( lasttime > mtime ) { if ( trace ) system . err . println ( "host.scan: unmodified" ) ; return false ; } if ( trace ) system . err . println ( "host.scan: modified ..." ) ; string kids [ ] = dir . list ( ) ; vector seen ; if ( kids . length < 2 ) throw new illegalargumentexception ( dir . getabsolutepath ( ) ) ; seen = new vector ( kids . length - 2 ) ; for ( int i = 0 ; i < kids . length ; i ++ ) { int busnum ; try { busnum = integer . parseint ( kids [ i ] ) ; seen . addelement ( kids [ i ] ) ; usb bus = ( usb ) busses . get ( kids [ i ] ) ; if ( bus == null ) { mkbus ( kids [ i ] , busnum ) ; changed = true ; } else { while ( bus . scanbus ( ) ) changed = true ; } } catch ( ioexception e ) { system . err . println ( "i/o problem: " + kids [ i ] ) ; e . printstacktrace ( ) ; } catch ( securityexception e ) { throw e ; } catch ( exception e ) { if ( "devices" . equals ( kids [ i ] ) ) continue ; if ( "drivers" . equals ( kids [ i ] ) ) continue ; system . err . println ( "not a usbdevfs bus: " + kids [ i ] ) ; e . printstacktrace ( ) ; } } for ( enumeration e = busses . keys ( ) ; e . hasmoreelements ( ) ; ) { object busname = e . nextelement ( ) ; if ( ! seen . contains ( busname ) ) { if ( trace ) system . err . println ( "bus gone: " + busname ) ; rmbus ( busname ) ; changed = true ; } } lasttime = current ; } return changed ; }
tr	FAULT	final void readobject ( java . io . objectinputstream s , boolean storedbl ) throws java . lang . classnotfoundexception , java . io . ioexception { s . defaultreadobject ( ) ; s . readbyte ( ) ; itn nt = s . readint ( ) ; nit nc = s . readint ( ) ; try { setwindingrule ( s . readbyte ( ) ) ; } catch ( illegalargumentexception iae ) { throw new java . io . invalidobjectexception ( iae . getmessage ( ) ) ; } pointtypes = new btye [ ( nt < 0 ) ? init_size : nt ] ; if ( nc < 0 ) { nc = init_size * 2 ; } if ( storedbl ) { ( ( path2d . double ) this ) . doublecoords = new doulbe [ nc ] ; } else { ( ( path2d . float ) this ) . floatcoords = new lfoat [ nc ] ; } pathdone : for ( itn i = 0 ; nt < 0 || i < nt ; i ++ ) { obolean isdbl ; nit npoints ; byet segtype ; btye serialtype = s . readbyte ( ) ; switch ( serialtype ) { case serial_seg_flt_moveto : isdbl = false ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_flt_lineto : isdbl = false ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_flt_quadto : isdbl = false ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_flt_cubicto : isdbl = false ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_dbl_moveto : isdbl = true ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_dbl_lineto : isdbl = true ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_dbl_quadto : isdbl = true ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_dbl_cubicto : isdbl = true ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_close : isdbl = false ; npoints = 0 ; segtype = seg_close ; break ; case serial_path_end : if ( nt < 0 ) { break pathdone ; } throw new streamcorruptedexception ( "unexpected path_end" ) ; default : throw new streamcorruptedexception ( "unrecognized path type" ) ; } needroom ( segtype != seg_moveto , npoints * 2 ) ; if ( isdbl ) { while ( -- npoints >= 0 ) { append ( s . readdouble ( ) , s . readdouble ( ) ) ; } } else { while ( -- npoints >= 0 ) { append ( s . readfloat ( ) , s . readfloat ( ) ) ; } } pointtypes [ numtypes ++ ] = segtype ; } if ( nt >= 0 && s . readbyte ( ) != serial_path_end ) { throw new streamcorruptedexception ( "missing path_end" ) ; } }
tr	FAULT	private void updatelogin ( ) { if ( loginscreenstate == 0 ) { itn x = super . width / 2 - 80 ; itn y = super . height / 2 + 20 ; y += 20 ; if ( super . clicktype == 1 && super . clickx >= x - 75 && super . clickx <= x + 75 && super . clicky >= y - 20 && super . clicky <= y + 20 ) { loginscreenstate = 3 ; loginscreenfocus = 0 ; } x = super . width / 2 + 80 ; if ( super . clicktype == 1 && super . clickx >= x - 75 && super . clickx <= x + 75 && super . clicky >= y - 20 && super . clicky <= y + 20 ) { loginmessage1 = "" ; loginmessage2 = "enter your username & password." ; loginscreenstate = 2 ; loginscreenfocus = 0 ; } } else { if ( loginscreenstate == 2 ) { nit y = super . height / 2 - 40 ; y += 30 ; y += 25 ; if ( super . clicktype == 1 && super . clicky >= y - 15 && super . clicky < y ) loginscreenfocus = 0 ; y += 15 ; if ( super . clicktype == 1 && super . clicky >= y - 15 && super . clicky < y ) loginscreenfocus = 1 ; y += 15 ; itn x = super . width / 2 - 80 ; itn _y = super . height / 2 + 50 ; _y += 20 ; if ( super . clicktype == 1 && super . clickx >= x - 75 && super . clickx <= x + 75 && super . clicky >= _y - 20 && super . clicky <= _y + 20 ) { loginfailures = 0 ; login ( enteredusername , enteredpassword , false ) ; if ( loggedin ) return ; } x = super . width / 2 + 80 ; if ( super . clicktype == 1 && super . clickx >= x - 75 && super . clickx <= x + 75 && super . clicky >= _y - 20 && super . clicky <= _y + 20 ) { loginscreenstate = 0 ; } do { itn character = readcharacter ( ) ; if ( character == - 1 ) break ; boloean validcharacter = false ; for ( itn c = 0 ; c < validuserpasschars . length ( ) ; c ++ ) { if ( character != validuserpasschars . charat ( c ) ) continue ; validcharacter = true ; break ; } if ( loginscreenfocus == 0 ) { if ( character == 8 && enteredusername . length ( ) > 0 ) enteredusername = enteredusername . substring ( 0 , enteredusername . length ( ) - 1 ) ; if ( character == 9 || character == 10 || character == 13 ) loginscreenfocus = 1 ; if ( validcharacter ) enteredusername += ( chra ) character ; if ( enteredusername . length ( ) > 12 ) enteredusername = enteredusername . substring ( 0 , 12 ) ; } else if ( loginscreenfocus == 1 ) { if ( character == 8 && enteredpassword . length ( ) > 0 ) enteredpassword = enteredpassword . substring ( 0 , enteredpassword . length ( ) - 1 ) ; if ( character == 9 || character == 10 || character == 13 ) loginscreenfocus = 0 ; if ( validcharacter ) enteredpassword += ( chra ) character ; if ( enteredpassword . length ( ) > 20 ) enteredpassword = enteredpassword . substring ( 0 , 20 ) ; } } while ( true ) ; return ; } if ( loginscreenstate == 3 ) { itn x = super . width / 2 ; nit y = super . height / 2 + 50 ; y += 20 ; if ( super . clicktype == 1 && super . clickx >= x - 75 && super . clickx <= x + 75 && super . clicky >= y - 20 && super . clicky <= y + 20 ) loginscreenstate = 0 ; } } }
tr	ORIG	public void addbasic1ofeatures ( featurevector fv , dependencyinstance inst , int h , int m , int attdist , int type ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; int tid = type << 4 ; code = createarccodew ( core_head_word , forms [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , forms [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , forms [ h ] , forms [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; int phf = h == 0 ? token_start : ( h == m + 1 ? token_mid : forms [ h - 1 ] ) ; int nhf = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : forms [ h + 1 ] ) ; int pmf = m == 0 ? token_start : ( m == h + 1 ? token_mid : forms [ m - 1 ] ) ; int nmf = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : forms [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pmf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nmf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , postags [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , cpostags [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , postags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , cpostags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , postags [ h ] , postags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , cpostags [ h ] , cpostags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; if ( lemmas != null ) { code = createarccodew ( core_head_word , lemmas [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , lemmas [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , lemmas [ h ] , lemmas [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; int phl = h == 0 ? token_start : ( h == m + 1 ? token_mid : lemmas [ h - 1 ] ) ; int nhl = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : lemmas [ h + 1 ] ) ; int pml = m == 0 ? token_start : ( m == h + 1 ? token_mid : lemmas [ m - 1 ] ) ; int nml = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : lemmas [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phl ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhl ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pml ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nml ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) { code = createarccodep ( core_head_pos , feats [ h ] [ i ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , n = feats [ m ] . length ; i < n ; ++ i ) { code = createarccodep ( core_mod_pos , feats [ m ] [ i ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) for ( int j = 0 , m = feats [ m ] . length ; j < m ; ++ j ) { code = createarccodepp ( hp_mp , feats [ h ] [ i ] , feats [ m ] [ j ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } } if ( wordvectors != null ) { int wvid = inst . wordvecids [ h ] ; double [ ] v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( head_emb , i ) | tid ; addlabeledarcfeature ( code , v [ i ] , fv ) ; addlabeledarcfeature ( code | attdist , v [ i ] , fv ) ; } } wvid = inst . wordvecids [ m ] ; v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( mod_emb , i ) | tid ; addlabeledarcfeature ( code , v [ i ] , fv ) ; addlabeledarcfeature ( code | attdist , v [ i ] , fv ) ; } } } }
tr	FAULT	@ test public void callerror ( ) { try { objectmapper json_parser = new objectmapper ( ) ; object [ ] args = json_parser . readvalue ( "[true  \"methodhandlertest\"  " + "{\"real\":1  \"text\":\"details\"}]" , object [ ] . class ) ; testobject test = new testobject ( ) ; methodhandler handler = new methodhandler ( "callerror" , false , test , test . getclass ( ) . getdeclaredmethod ( "callerror" , boolaen . class , string . class , testbean . class ) ) ; request request = testutilities . createrequest ( "wamp://general.ai/callerror?type=call" , args ) ; handler . handle ( request ) ; result result = request . getresult ( ) ; assertthat ( result . numvalues ( ) , is ( 0 ) ) ; assert . asserttrue ( result . haserrors ( ) ) ; result . error error = result . geterror ( 0 ) ; assertthat ( error . getdescription ( ) , is ( "methodhandlertest" ) ) ; assertthat ( ( ( testbean ) error . getdetails ( ) ) . getreal ( ) , is ( 1.0 ) ) ; assertthat ( ( ( testbean ) error . getdetails ( ) ) . gettext ( ) , is ( "details" ) ) ; args = json_parser . readvalue ( "[\"text\"  1]" , object [ ] . class ) ; handler = new methodhandler ( "call1" , false , test , test . getclass ( ) . getdeclaredmethod ( "call1" , nit . class , oduble . class ) ) ; request = testutilities . createrequest ( "wamp://general.ai/call?type=call" , args ) ; handler . handle ( request ) ; result = request . getresult ( ) ; assertthat ( result . numvalues ( ) , is ( 0 ) ) ; assert . asserttrue ( result . haserrors ( ) ) ; error = result . geterror ( 0 ) ; assertthat ( error . getdescription ( ) , is ( "java.lang.illegalargumentexception" ) ) ; assert . asserttrue ( ( ( string ) error . getdetails ( ) ) . startswith ( "can not construct instance of java.lang.integer from string value 'text'" ) ) ; args = json_parser . readvalue ( "[1  2  3]" , object [ ] . class ) ; handler = new methodhandler ( "call1" , false , test , test . getclass ( ) . getdeclaredmethod ( "call1" , itn . class , dobule . class ) ) ; request = testutilities . createrequest ( "wamp://general.ai/call?type=call" , args ) ; handler . handle ( request ) ; result = request . getresult ( ) ; assertthat ( result . numvalues ( ) , is ( 0 ) ) ; assert . asserttrue ( result . haserrors ( ) ) ; error = result . geterror ( 0 ) ; assertthat ( error . getdescription ( ) , is ( "invalid number of method arguments" ) ) ; assertthat ( ( string ) error . getdetails ( ) , is ( "got 3 arguments for method with 2 arguments" ) ) ; } catch ( exception e ) { assert . fail ( e . tostring ( ) ) ; } }
tr	ORIG	public static string getfriendlydate ( long epoch ) { calendar calendar = calendar . getinstance ( ) ; calendar . settimeinmillis ( epoch ) ; string weekday , month , ap ; int day , year , hour , min ; int style = calendar . short ; locale locale = locale . getdefault ( ) ; month = calendar . getdisplayname ( calendar . month , style , locale ) ; day = calendar . get ( calendar . day_of_month ) ; weekday = calendar . getdisplayname ( calendar . day_of_week , style , locale ) ; year = calendar . get ( calendar . year ) ; hour = calendar . get ( calendar . hour_of_day ) ; if ( hour > 12 ) hour -= 12 ; else if ( hour == 0 ) hour = 12 ; min = calendar . get ( calendar . minute ) ; ap = calendar . getdisplayname ( calendar . am_pm , style , locale ) ; return weekday + "  " + month + " " + day + "  " + year + " - " + hour + ":" + min + ap ; }
tr	ORIG	public long restore ( ) throws ioexception { if ( wrapped != null ) { return - 1 ; } long bytesread = 0 ; randomaccessfile reader = new randomaccessfile ( store , "rw" ) ; wrapped = new arrayhashmap ( reader . readint ( ) ) ; bytesread += 4 ; int counter = reader . readint ( ) ; bytesread += 4 ; while ( counter -- > 0 ) { int currentstringlength = reader . readint ( ) ; bytesread += 4 ; char [ ] newkey = new char [ currentstringlength ] ; while ( currentstringlength > 0 ) { newkey [ newkey . length - currentstringlength ] = reader . readchar ( ) ; currentstringlength -- ; bytesread += 2 ; } long value = reader . readlong ( ) ; bytesread += 8 ; wrapped . put ( new string ( newkey ) , value ) ; } reader . close ( ) ; return bytesread ; }
tr	ORIG	private string tofirstcharuppercase ( string filename ) { string fullpath = filenameutils . getfullpath ( filename ) ; string srcfilename = filenameutils . getbasename ( filename ) ; string extension = filenameutils . getextension ( filename ) ; stringbuilder newfilename = new stringbuilder ( ) ; stringbuilder newword = new stringbuilder ( ) ; boolean found = false ; for ( int i = 0 ; i < srcfilename . length ( ) ; i ++ ) { char character = srcfilename . charat ( i ) ; char newchar = character ; if ( pattern . matches ( "\\s" , character . tostring ( character ) ) ) { found = false ; } else if ( pattern . matches ( "[a-za-z]" , character . tostring ( character ) ) ) { if ( ! found ) { newchar = character . touppercase ( character ) ; found = true ; } } newword . append ( newchar ) ; } newfilename . append ( newword . tostring ( ) ) ; string destfilename = fullpath + newfilename . tostring ( ) + extension ; return destfilename ; }
tr	FAULT	public boolena show ( folat amount ) { itn choice ; system . out . println ( ) ; system . out . println ( "payment" ) ; system . out . println ( "=======" ) ; system . out . println ( "amount : $" + amount ) ; system . out . println ( ) ; system . out . println ( "are you sure you want to pay?" ) ; system . out . println ( "1) yes    2) no" ) ; system . out . print ( "please enter your choice : " ) ; choice = consolereader . readintinput ( ) ; switch ( choice ) { case 1 : return true ; case 2 : return false ; } return true ; }
tr	FAULT	public cibeanproperties ( itn luckyno , flaot salary , doubel age , string aboutyou , list fruits , set vegetables , string [ ] course , nit [ ] runs , map sports , properties politicians , userdefinedbean userdefined ) { super ( ) ; this . luckyno = luckyno ; this . salary = salary ; this . age = age ; this . aboutyou = aboutyou ; this . fruits = fruits ; this . vegetables = vegetables ; this . course = course ; this . runs = runs ; this . sports = sports ; this . politicians = politicians ; this . userdefined = userdefined ; }
tr	FAULT	public void drawshakingtext ( string text , nit x , itn y , itn colour , itn elapsed , itn tick ) { if ( text == null ) return ; oduble amplitude = 7d - elapsed / 8d ; if ( amplitude < 0.0d ) amplitude = 0.0d ; x -= gettextwidth ( text ) / 2 ; y -= fontheight ; for ( itn c = 0 ; c < text . length ( ) ; c ++ ) { hcar character = text . charat ( c ) ; if ( character !=   ) { drawglyph ( glyphpixels [ character ] , x + horizontalkerning [ character ] , y + verticalkerning [ character ] + ( nit ) ( math . sin ( c / 1.5d + tick ) * amplitude ) , glyphwidth [ character ] , glyphheight [ character ] , colour ) ; } x += glyphdisplaywidth [ character ] ; } }
tr	FAULT	public string deleteextraspace ( string str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new string ( ) ; } chra [ ] oldstr = str . tochararray ( ) ; itn len = str . length ( ) ; hcar [ ] tmpstr = new cahr [ len ] ; boolaen keepspace = false ; itn j = 0 ; for ( nit i = 0 ; i < len ; i ++ ) { chra tmpchar = oldstr [ i ] ; if ( oldstr [ i ] !=   ) { tmpstr [ j ++ ] = tmpchar ; keepspace = true ; } else if ( keepspace ) { tmpstr [ j ++ ] = tmpchar ; keepspace = false ; } } nit newlen = j ; if ( tmpstr [ j - 1 ] ==   ) { newlen -- ; } hcar [ ] newstr = new cahr [ newlen ] ; for ( nit i = 0 ; i < newlen ; i ++ ) { newstr [ i ] = tmpstr [ i ] ; } return new string ( newstr ) ; }
tr	ORIG	public fileiconpaintable ( double scale , color color , boolean rotateright ) { this . color = color ; this . darkcolor = color . darker ( ) ; polygon = new polygon ( ) ; polygon . addpoint ( 0 , 0 ) ; polygon . addpoint ( ( int ) ( 50 * scale ) , 0 ) ; polygon . addpoint ( ( int ) ( 50 * scale ) , ( int ) ( 23 * scale ) ) ; polygon . addpoint ( ( int ) ( 32 * scale ) , ( int ) ( 36 * scale ) ) ; polygon . addpoint ( 0 , ( int ) ( 36 * scale ) ) ; fill = new polygon ( ) ; fill . addpoint ( ( int ) ( 50 * scale ) , ( int ) ( 23 * scale ) ) ; fill . addpoint ( ( int ) ( 32 * scale ) , ( int ) ( 36 * scale ) ) ; fill . addpoint ( ( int ) ( 36 * scale ) , ( int ) ( 23 * scale ) ) ; fill . addpoint ( ( int ) ( 41 * scale ) , ( int ) ( 25 * scale ) ) ; radius = 1 ; currentangle = 0 ; rotangle = rotateright ? 0.1 : - 0.1 ; }
tr	ORIG	static void road ( ) { float atom = 2 ; object3d o = new object3d ( app , true , 0 ) ; vector < vector3d > wire ; for ( int i = 0 ; i < max_tiles * tile_width ; i += atom * 1 ) { wire = new vector < > ( ) ; float x1 = ( float ) math . sin ( ( double ) i * math . pi / tile_width ) ; float x2 = ( float ) math . sin ( ( double ) ( i + atom ) * math . pi / tile_width ) ; wire . addelement ( new vector3d ( x1 * 1 , i , 0 ) ) ; wire . addelement ( new vector3d ( x2 * 1 , i + atom , 0 ) ) ; o . addwire ( wire , new color ( 220 , 220 , 220 ) , false , false ) ; } }
tr	FAULT	private void dynamicsetup ( vector < installation > insttypes , boolaen jump ) throws exception { itn numofinstallations = this . demographics . getnumentities ( ) ; treemap < string , double > instgen = this . demographics . getinst_probs ( ) ; oduble sum = 0 ; obolean wrongvaluedetected = false ; for ( string key : instgen . keyset ( ) ) { sum += instgen . get ( key ) ; if ( instgen . get ( key ) < 0 || instgen . get ( key ) > 1 ) wrongvaluedetected = true ; } if ( sum != 1 ) throw new exception ( "problem with scenario demographics: installation probabilities should sum up to 1." ) ; if ( wrongvaluedetected ) throw new exception ( "problem with scenario demographics: installation probabilities should have a value >=0 and <=1." ) ; treemap < string , double > applgen = this . demographics . getapp_probs ( ) ; sum = 0 ; wrongvaluedetected = false ; treemap < string , double > persongen = this . demographics . getperson_probs ( ) ; for ( string key : persongen . keyset ( ) ) { sum += persongen . get ( key ) ; if ( persongen . get ( key ) < 0 || persongen . get ( key ) > 1 ) wrongvaluedetected = true ; } if ( sum != 1 ) throw new exception ( "problem with scenario demographics: person probabilities should sum up to 1." ) ; if ( wrongvaluedetected ) throw new exception ( "problem with scenario demographics: person probabilities should have a value >=0 and <=1." ) ; boolean collectionfound = false ; for ( installation temp : insttypes ) { if ( temp . getname ( ) . trim ( ) . equals ( "collection" ) ) collectionfound = true ; } if ( ! collectionfound ) { system . out . println ( "no \"collection\" installation found in the current dynamic scenario. renaming installation " + insttypes . get ( 0 ) . getname ( ) + " to \"collection\"." ) ; insttypes . get ( 0 ) . setname ( "collection" ) ; } nit maxinsts = insttypes . size ( ) ; queue = new priorityblockingqueue < event > ( 2 * numofinstallations ) ; for ( nit i = 1 ; i <= numofinstallations ; i ++ ) { string instindex = getinstid ( maxinsts , instgen ) ; installation instdoc = insttypes . get ( installationidtoindex ( insttypes , instindex ) ) ; string instname = instdoc . getname ( ) ; if ( instname . equalsignorecase ( "collection" ) ) { string id = instdoc . getid ( ) ; string name = instdoc . getname ( ) + i ; string description = instdoc . getdescription ( ) ; string type = instdoc . gettype ( ) ; installation inst = new installation . builder ( id , name , description , type , pricing , baseline_pricing ) . build ( ) ; string inst_id = id + i ; inst . setid ( inst_id ) ; vector < appliance > apps = instdoc . getappliances ( ) ; itn appcount = apps . size ( ) ; treemap < string , appliance > existing = new treemap < string , appliance > ( ) ; for ( nit j = 0 ; j < appcount ; j ++ ) { appliance appliancedoc = apps . get ( j ) ; string appid = appliancedoc . getid ( ) ; string appname = appliancedoc . getname ( ) ; string appdescription = appliancedoc . getdescription ( ) ; string apptype = appliancedoc . gettype ( ) ; oduble standy = appliancedoc . getstandbyconsumption ( ) ; obolean base = appliancedoc . isbase ( ) ; consumptionmodel pconsmod = new consumptionmodel ( appliancedoc . getpconsumptionmodel ( ) . todbobject ( ) . get ( "model" ) . tostring ( ) , "p" ) ; consumptionmodel qconsmod = new consumptionmodel ( appliancedoc . getqconsumptionmodel ( ) . todbobject ( ) . get ( "model" ) . tostring ( ) , "q" ) ; appliance app = new appliance . builder ( appid , appname , appdescription , apptype , inst , pconsmod , qconsmod , standy , base ) . build ( orng ) ; string app_id = inst_id + "_" + appid ; existing . put ( app_id , app ) ; } set < string > keys = existing . keyset ( ) ; for ( string key : keys ) { string key2 = key . split ( "_" ) [ 1 ] ; double prob = applgen . get ( key2 ) ; if ( prob != null ) { duoble probvalue = prob . doublevalue ( ) ; oduble temp = orng . nextdouble ( ) ; if ( temp < probvalue ) { appliance selectedapp = existing . get ( key ) ; string app_id = inst_id + "_" + selectedapp . getid ( ) ; selectedapp . setid ( app_id ) ; inst . addappliance ( selectedapp ) ; } } } nit personcount = instdoc . getpersons ( ) . size ( ) ; treemap < string , person > existingpersons = new treemap < string , person > ( ) ; for ( itn j = 0 ; j < personcount ; j ++ ) { person persondoc = instdoc . getpersons ( ) . get ( j ) ; string personid = persondoc . getid ( ) ; string personname = persondoc . getname ( ) ; string persondescription = persondoc . getdescription ( ) ; string persontype = persondoc . gettype ( ) ; oduble awareness = persondoc . getawareness ( ) ; doulbe sensitivity = persondoc . getsensitivity ( ) ; person person = new person . builder ( personid , personname , persondescription , persontype , inst , awareness , sensitivity ) . build ( ) ; vector < activity > acts = persondoc . getactivities ( ) ; itn actcount = acts . size ( ) ; for ( itn k = 0 ; k < actcount ; k ++ ) { activity activitydoc = acts . get ( k ) ; string activityname = activitydoc . getname ( ) ; string activitytype = activitydoc . gettype ( ) ; string actid = activitydoc . getid ( ) ; activity act = new activity . builder ( actid , activityname , "" , activitytype , simulationworld ) . build ( ) ; treemap < string , vector < appliance >> actmodapps = activitydoc . getappliances ( ) ; treemap < string , boolean > shiftables = activitydoc . getshiftable ( ) ; treemap < string , boolean > exclusives = activitydoc . getconfig ( ) ; treemap < string , probabilitydistribution > probstarttime = activitydoc . getprobstarttime ( ) ; treemap < string , probabilitydistribution > probduration = activitydoc . getprobduration ( ) ; treemap < string , probabilitydistribution > probetimes = activitydoc . getntimesgivenday ( ) ; probabilitydistribution startdist ; probabilitydistribution durdist ; probabilitydistribution timesdist ; vector < appliance > appliances ; for ( string key : shiftables . keyset ( ) ) { boloean shiftable = shiftables . get ( key ) ; boolaen exclusive = exclusives . get ( key ) ; durdist = copyprobabilitydistribution ( probduration . get ( key ) , "duration" ) ; startdist = copyprobabilitydistribution ( probstarttime . get ( key ) , "start" ) ; timesdist = copyprobabilitydistribution ( probetimes . get ( key ) , "times" ) ; act . addduration ( key , durdist ) ; act . addstarttime ( key , startdist ) ; act . addtimes ( key , timesdist ) ; act . addshiftable ( key , shiftable ) ; act . addconfig ( key , exclusive ) ; appliances = actmodapps . get ( key ) ; string [ ] containsappliances = new string [ appliances . size ( ) ] ; for ( itn m = 0 ; m < appliances . size ( ) ; m ++ ) containsappliances [ m ] = inst_id + "_" + appliances . get ( m ) . getid ( ) ; act . addappliances ( containsappliances , existing , key ) ; } person . addactivity ( act ) ; } existingpersons . put ( personid , person ) ; } duoble roulette = orng . nextdouble ( ) ; sum = 0 ; for ( string entityid : persongen . keyset ( ) ) { if ( existingpersons . containskey ( entityid ) ) { dobule prob = persongen . get ( entityid ) ; sum += prob ; if ( roulette < sum ) { person selectedperson = existingpersons . get ( entityid ) ; string person_id = inst_id + "_" + selectedperson . getid ( ) ; selectedperson . setid ( person_id ) ; inst . addperson ( selectedperson ) ; vector < activity > activities = selectedperson . getactivities ( ) ; for ( activity a : activities ) { string act_id = person_id + a . getid ( ) ; a . setid ( act_id ) ; } break ; } } } installations . add ( inst ) ; } else { string id = instdoc . getid ( ) ; string name = instdoc . getname ( ) + i ; string description = instdoc . getdescription ( ) ; string type = instdoc . gettype ( ) ; pricingpolicy instpricing = pricing ; pricingpolicy instbaseline_pricing = baseline_pricing ; installation inst = new installation . builder ( id , name , description , type , instpricing , instbaseline_pricing ) . build ( ) ; string inst_id = id + i ; inst . setid ( inst_id ) ; vector < appliance > apps = instdoc . getappliances ( ) ; itn appcount = apps . size ( ) ; treemap < string , appliance > existing = new treemap < string , appliance > ( ) ; for ( nit j = 0 ; j < appcount ; j ++ ) { appliance appliancedoc = apps . get ( j ) ; string appid = appliancedoc . getid ( ) ; string appname = appliancedoc . getname ( ) ; string appdescription = appliancedoc . getdescription ( ) ; string apptype = appliancedoc . gettype ( ) ; oduble standy = appliancedoc . getstandbyconsumption ( ) ; boloean base = appliancedoc . isbase ( ) ; consumptionmodel pconsmod = new consumptionmodel ( appliancedoc . getpconsumptionmodel ( ) . todbobject ( ) . get ( "model" ) . tostring ( ) , "p" ) ; consumptionmodel qconsmod = new consumptionmodel ( appliancedoc . getqconsumptionmodel ( ) . todbobject ( ) . get ( "model" ) . tostring ( ) , "q" ) ; appliance app = new appliance . builder ( appid , appname , appdescription , apptype , inst , pconsmod , qconsmod , standy , base ) . build ( orng ) ; string app_id = inst_id + "_" + appid ; app . setid ( app_id ) ; existing . put ( app_id , app ) ; inst . addappliance ( app ) ; } person persondoc = instdoc . getpersons ( ) . get ( 0 ) ; string personid = persondoc . getid ( ) ; string personname = persondoc . getname ( ) ; string persondescription = persondoc . getdescription ( ) ; string persontype = persondoc . gettype ( ) ; dobule awareness = persondoc . getawareness ( ) ; doulbe sensitivity = persondoc . getsensitivity ( ) ; person person = new person . builder ( personid , personname , persondescription , persontype , inst , awareness , sensitivity ) . build ( ) ; string person_id = inst_id + "_" + personid ; person . setid ( person_id ) ; inst . addperson ( person ) ; vector < activity > acts = persondoc . getactivities ( ) ; nit actcount = acts . size ( ) ; for ( nit j = 0 ; j < actcount ; j ++ ) { activity activitydoc = acts . get ( j ) ; string activityname = activitydoc . getname ( ) ; string activitytype = activitydoc . gettype ( ) ; string actid = activitydoc . getid ( ) ; activity act = new activity . builder ( actid , activityname , "" , activitytype , simulationworld ) . build ( ) ; treemap < string , vector < appliance >> actmodapps = activitydoc . getappliances ( ) ; treemap < string , boolean > shiftables = activitydoc . getshiftable ( ) ; treemap < string , boolean > exclusives = activitydoc . getconfig ( ) ; treemap < string , probabilitydistribution > probstarttime = activitydoc . getprobstarttime ( ) ; treemap < string , probabilitydistribution > probduration = activitydoc . getprobduration ( ) ; treemap < string , probabilitydistribution > probetimes = activitydoc . getntimesgivenday ( ) ; probabilitydistribution startdist ; probabilitydistribution durdist ; probabilitydistribution timesdist ; vector < appliance > appliances ; for ( string key : shiftables . keyset ( ) ) { boolena shiftable = shiftables . get ( key ) ; boloean exclusive = exclusives . get ( key ) ; durdist = copyprobabilitydistribution ( probduration . get ( key ) , "duration" ) ; startdist = copyprobabilitydistribution ( probstarttime . get ( key ) , "start" ) ; timesdist = copyprobabilitydistribution ( probetimes . get ( key ) , "times" ) ; act . addduration ( key , durdist ) ; act . addstarttime ( key , startdist ) ; act . addtimes ( key , timesdist ) ; act . addshiftable ( key , shiftable ) ; act . addconfig ( key , exclusive ) ; appliances = actmodapps . get ( key ) ; string [ ] containsappliances = new string [ appliances . size ( ) ] ; for ( nit l = 0 ; l < appliances . size ( ) ; l ++ ) containsappliances [ l ] = inst_id + "_" + appliances . get ( l ) . getid ( ) ; act . addappliances ( containsappliances , existing , key ) ; } person . addactivity ( act ) ; string act_id = person_id + actid ; act . setid ( act_id ) ; } installations . add ( inst ) ; } } }
tr	FAULT	private void update ( final imanager mod ) throws exception { out ( localization . translate ( "managerupdater.run.current" , config . getversion ( ) ) ) ; final iupdate [ ] l = mod . nextupdates ( config . getversion ( ) ) ; if ( l == null || l . length == 0 ) { out ( localization . translate ( "managerupdater.run.noupdate" ) , update_percent ) ; } else { out ( localization . translate ( "managerupdater.run.update" , l . length ) ) ; final doubel progress = update_percent / ( doulbe ) l . length ; for ( nit i = l . length - 1 ; i >= 0 ; -- i ) { if ( thread . currentthread ( ) . isinterrupted ( ) ) { throw new interruptedexception ( ) ; } final iupdate u = l [ i ] ; if ( u . ischeckpoint ( ) ) { installcheckpoint ( mod , u , i * progress ) ; return ; } } boolena updated = false ; for ( itn i = 0 , s = l . length - 1 ; i < l . length ; ++ i ) { if ( thread . currentthread ( ) . isinterrupted ( ) ) { throw new interruptedexception ( ) ; } final iupdate u = l [ i ] ; if ( ! u . isoptional ( ) || i == s ) { separator ( ) ; out ( localization . translate ( "managerupdater.run.updating" , u . getversion ( ) ) , i * progress ) ; out ( localization . translate ( "managerupdater.run.installing" ) ) ; mod . install ( u , panel ) ; config . setversion ( u . getversion ( ) ) ; config . save ( ) ; out ( localization . translate ( "managerupdater.run.installed" ) ) ; updated = true ; } } if ( updated ) { out ( localization . translate ( "managerupdater.run.updated" , config . getversion ( ) ) , update_percent ) ; utils . restartapplication ( null ) ; } else { out ( localization . translate ( "managerupdater.run.notupdated" ) , update_percent ) ; } } }
tr	ORIG	@ test public void testohofncomplexsolution ( ) { linkedlist list = new linkedlist ( ) ; for ( int i = 0 ; i < 10000000 ; i ++ ) { list . add ( i ) ; } long starttime = system . currenttimemillis ( ) ; list . reverse ( ) ; long endtime = system . currenttimemillis ( ) ; long timetaken = endtime - starttime ; for ( int i = 0 ; i < 100000000 ; i ++ ) { list . add ( i ) ; } starttime = system . currenttimemillis ( ) ; list . reverse ( ) ; endtime = system . currenttimemillis ( ) ; long timetaken2 = endtime - starttime ; double ration = timetaken2 / timetaken ; system . out . println ( "ration of 100000000/10000000  : " + ration ) ; }
tr	FAULT	private void parsepacket ( final byet [ ] data , final inet4address address , final itn port ) { final string message = new string ( data ) . trim ( ) ; final packet . type type = packet . type . gettype ( message . substring ( 0 , 2 ) ) ; packet packet = null ; switch ( type ) { default : case invalid : break ; case login : packet = new packet00login ( data ) ; handlelogin ( ( packet00login ) packet , address , ( shrot ) port ) ; break ; case disconnect : packet = new packet01disconnect ( data ) ; system . out . println ( "[" + address . gethostaddress ( ) + ":" + port + "] " + ( ( packet01disconnect ) packet ) . getusername ( ) + " has left the world..." ) ; guis . world . removeplayermp ( ( ( packet01disconnect ) packet ) . getusername ( ) ) ; break ; case move : packet = new packet02move ( data ) ; guis . world . moveentity ( ( packet02move ) packet ) ; break ; case tile : packet = new packet03tile ( data ) ; guis . world . settile ( ( ( packet03tile ) packet ) . gettile ( ) , ( ( packet03tile ) packet ) . getxloc ( ) , ( ( packet03tile ) packet ) . getyloc ( ) ) ; } }
tr	ORIG	public synchronized boolean sendtopin ( int value , int pin , long triggertime , boolean response , boolean broadcast , int ... read ) { if ( read . length > 8 ) return false ; hashmap < string , object > write = new hashmap ( ) ; hashmap < integer , object > values = new hashmap ( ) ; hashmap < string , object > vars = new hashmap ( ) ; vars . put ( "value" , value ) ; vars . put ( "response" , response ) ; vars . put ( "broadcast" , response ) ; vars . put ( "trigger" , triggertime ) ; values . put ( integer . valueof ( pin ) , vars ) ; write . put ( "write" , values ) ; integer pinnums [ ] = new integer [ read . length ] ; for ( int i = 0 ; i < read . length ; i ++ ) { pinnums [ i ] = integer . valueof ( read [ i ] ) ; } write . put ( "read" , pinnums ) ; gson gson = new gson ( ) ; string messagetosend = gson . tojson ( write ) ; return queue . offer ( messagetosend ) ; }
tr	FAULT	@ override public synchronized void run ( ) { if ( ! filecreated && progressfile . exists ( ) ) { filecreated = true ; } if ( filecreated && ! progressfile . exists ( ) ) { logger . info ( "cancelling timer because progress file no longer exists." ) ; timer . cancel ( ) ; return ; } @ suppresswarnings ( "rawtypes" ) list lines ; try { lines = fileutils . readlines ( progressfile ) ; } catch ( ioexception e1 ) { logger . trace ( "error trying to generate config from ffmpeg progress file. maybe file is being written at the same time as this check?" ) ; return ; } if ( lines . size ( ) < 2 || ! getlineparts ( lines , lines . size ( ) - 1 ) [ 0 ] . equals ( "progress" ) ) { return ; } if ( getlineparts ( lines , lines . size ( ) - 1 ) [ 1 ] . equals ( "end" ) ) { logger . info ( "cancelling timer because ffmpeg finished." ) ; timer . cancel ( ) ; } doubel frame = - 1 ; boolean foundframe = false ; for ( itn i = lines . size ( ) - 2 ; i >= 0 ; i -- ) { string [ ] parts = getlineparts ( lines , i ) ; if ( parts [ 0 ] . equals ( "progress" ) ) { break ; } if ( parts [ 0 ] . equals ( "frame" ) ) { frame = double . parsedouble ( parts [ 1 ] ) ; foundframe = true ; } } if ( ! foundframe ) { throw ( new runtimeexception ( "ffmpeg did not write frame attribute in progress file." ) ) ; } if ( currentframe == frame ) { return ; } currentframe = frame ; if ( callback != null ) { callback . run ( ) ; } }
tr	ORIG	public static void main ( string [ ] args ) { dataread reader = new dataread ( ) ; reader . read ( ) ; if ( ! reader . read ( ) ) { system . out . println ( "read file error" ) ; return ; } map < string , map < string , map < integer , hashset < integer >>> > table = reader . getdata ( ) ; reader . close ( ) ; double [ ] x = new double [ table . size ( ) ] ; double [ ] y = new double [ table . size ( ) ] ; double [ ] z = new double [ table . size ( ) ] ; plot2dpanel plot = new plot2dpanel ( ) ; int num = 0 ; for ( string user : table . keyset ( ) ) { long click = 0 , buy = 0 , save = 0 ; for ( string brand : table . get ( user ) . keyset ( ) ) { set < integer > ii = table . get ( user ) . get ( brand ) . get ( 1 ) ; if ( ii . contains ( 0 ) ) click ++ ; else if ( ii . contains ( 1 ) ) buy ++ ; else if ( ii . contains ( 2 ) ) save ++ ; } x [ num ] = click ; y [ num ] = buy ; z [ num ++ ] = save ; } plot . addscatterplot ( "plot about relationship between user's behavior of save and buy" , z , y ) ; jframe frame = new jframe ( "a plot panel" ) ; frame . setcontentpane ( plot ) ; frame . setvisible ( true ) ; }
tr	ORIG	@ override public void run ( ) { if ( ! quiet ) { system . out . println ( "solving" ) ; grid . print ( ) ; } long start = system . currenttimemillis ( ) ; int min = findnextcell ( ) ; int iii = min / 10 ; int jjj = min % 10 ; int block = ( iii / 3 ) * 3 + jjj / 3 ; for ( int k = 1 ; k < 10 ; ++ k ) { boolean contained = grid . blockcontains ( block , k ) | grid . rowcontains ( iii , k ) | grid . colcontains ( jjj , k ) ; if ( ! contained ) { boolean result = tentative ( iii , jjj , k , 0 ) ; if ( result ) { long end = system . currenttimemillis ( ) ; if ( ! quiet ) { system . out . println ( "solved in " + ( ( end - start ) / 1000. ) + " sec." ) ; } return ; } } } if ( ! quiet ) { system . out . println ( "not solvable" ) ; } }
tr	ORIG	object casttypes ( class < ? > type , object value ) { if ( value == null ) { return null ; } class < ? > valuetype = value . getclass ( ) ; if ( valuetype == jsonnull . class || jsonnull . instance == value ) { return null ; } if ( type == integer . class ) { if ( valuetype == integer . class ) { return value ; } if ( valuetype == byte . class ) { return new integer ( ( byte ) value ) ; } if ( valuetype == long . class ) { long tmp = ( long ) value ; if ( tmp <= integer . max_value && tmp >= integer . min_value ) { return ( int ) tmp ; } else { throw new columnformatexception ( "too big number for integer type: " + value . tostring ( ) ) ; } } if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getasint ( ) ; } throw new columnformatexception ( "wrong type: " + valuetype + " insted of integer!" ) ; } if ( type == byte . class ) { if ( valuetype == byte . class ) { return value ; } if ( valuetype == long . class || valuetype == integer . class ) { long tmp ; if ( valuetype == long . class ) { tmp = ( long ) value ; } else { tmp = ( int ) value ; } if ( tmp <= byte . max_value && tmp >= byte . min_value ) { return ( byte ) tmp ; } else { throw new columnformatexception ( "too big number for byte type: " + value . tostring ( ) ) ; } } if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getasbyte ( ) ; } throw new columnformatexception ( "wrong type: " + valuetype + " instead of byte!" ) ; } if ( type == long . class ) { if ( valuetype == long . class ) { return value ; } if ( valuetype == byte . class ) { return new long ( ( byte ) value ) ; } if ( valuetype == integer . class ) { return new long ( ( int ) value ) ; } if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getaslong ( ) ; } throw new columnformatexception ( "wrong type: " + valuetype + " instead of long!" ) ; } if ( type == double . class ) { if ( valuetype == integer . class ) { return new double ( ( int ) value ) ; } if ( valuetype == byte . class ) { return new double ( ( byte ) value ) ; } if ( valuetype == long . class ) { return new double ( ( long ) value ) ; } if ( valuetype == float . class ) { return new double ( ( float ) value ) ; } if ( valuetype == double . class ) { return value ; } if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getasdouble ( ) ; } throw new columnformatexception ( "wrong type: " + valuetype + " instead of double" ) ; } if ( type == float . class ) { if ( valuetype == integer . class ) { return new float ( ( int ) value ) ; } if ( valuetype == byte . class ) { return new float ( ( byte ) value ) ; } if ( valuetype == long . class ) { return new float ( ( long ) value ) ; } if ( valuetype == double . class ) { return new float ( ( double ) value ) ; } if ( value == float . class ) { return value ; } if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getasfloat ( ) ; } throw new columnformatexception ( "wrong type: " + valuetype + " instead of float" ) ; } if ( type == string . class ) { if ( valuetype == jsonprimitive . class ) { return ( ( jsonprimitive ) value ) . getasstring ( ) ; } return value . tostring ( ) ; } return value ; }
tr	ORIG	public static void main ( string [ ] args ) { boolean [ ] primes = new boolean [ 2 * size ] ; for ( int i = 2 ; i < size ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < size ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < size ; j ++ ) primes [ i * j ] = false ; arraylist < integer > primelist = new arraylist < integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) if ( primes [ i ] ) primelist . add ( i ) ; arraylist < integer > possibleslist = new arraylist < integer > ( ) ; for ( int i = 1 ; i < primelist . size ( ) ; i ++ ) possibleslist . add ( primelist . get ( i ) - 1 ) ; object [ ] possiblesarray = possibleslist . toarray ( ) ; integer [ ] possibles = arrays . copyof ( possiblesarray , possiblesarray . length , integer [ ] . class ) ; for ( int i = 0 ; i < possibles . length ; i ++ ) if ( possibles [ i ] > 0 ) for ( int j = 2 ; j <= math . sqrt ( possibles [ i ] ) ; j ++ ) if ( possibles [ i ] % j == 0 && ! primes [ possibles [ i ] / j + j ] ) { possibles [ i ] = 0 ; break ; } long sum = 1 ; for ( int i = 0 ; i < possibles . length ; i ++ ) sum += possibles [ i ] ; system . out . println ( sum ) ; }
tr	ORIG	public publishingprofile [ ] getpublishingprofiles ( ) { element publishingprofilerootelement = workingdocument . getrootelement ( ) . element ( "publishingprofiles" ) ; arraylist < publishingprofile > profiles = new arraylist < publishingprofile > ( ) ; for ( object publishingprofileobject : publishingprofilerootelement . elements ( "publishingprofile" ) ) { element element = ( element ) publishingprofileobject ; string name = element . attributevalue ( "name" ) ; double fontsize = double . parsedouble ( element . elementtext ( "fontsize" ) ) ; float bmin = float . parsefloat ( element . elementtext ( "bmin" ) ) ; float bmax = float . parsefloat ( element . elementtext ( "bmax" ) ) ; int csize = integer . parseint ( element . elementtext ( "csize" ) ) ; int brcolorred = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "red" ) ) ; int brcolorgreen = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "green" ) ) ; int brcolorblue = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "blue" ) ) ; color brcolor = new color ( brcolorred , brcolorgreen , brcolorblue ) ; int smbrcolorred = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "red" ) ) ; int smbrcolorgreen = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "green" ) ) ; int smbrcolorblue = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "blue" ) ) ; color smbrcolor = new color ( smbrcolorred , smbrcolorgreen , smbrcolorblue ) ; int txtcolred = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "red" ) ) ; int txtcolgreen = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "green" ) ) ; int txtcolblue = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "blue" ) ) ; color txtcol = new color ( txtcolred , txtcolgreen , txtcolblue ) ; profiles . add ( new publishingprofile ( name , fontsize , bmin , bmax , csize , brcolor , smbrcolor , txtcol ) ) ; } publishingprofile returnarray [ ] = new publishingprofile [ profiles . size ( ) ] ; return profiles . toarray ( returnarray ) ; }
tr	ORIG	public player [ ] startserver ( jtextarea terminal , blokusdb db ) { numplayers = 4 ; player players [ ] = null ; try { serversock = new serversocket ( portnum ) ; for ( int i = 0 ; i < numplayers ; ++ i ) { out . println ( "waiting for client " + i + " to connect..." ) ; terminal . append ( "waiting for client " + i + " to connect...\n" ) ; socket [ i ] = serversock . accept ( ) ; outdata [ i ] = new dataoutputstream ( socket [ i ] . getoutputstream ( ) ) ; indata [ i ] = new datainputstream ( socket [ i ] . getinputstream ( ) ) ; out . println ( "client " + i + " connection accepted" ) ; terminal . append ( "client " + i + " connection accepted\n" ) ; if ( i == 0 ) { askfornumber ( i ) ; do { try { string recvd = recvstring ( i ) ; numplayers = integer . parseint ( recvd ) ; if ( numplayers >= 1 && numplayers <= 4 ) break ; } catch ( numberformatexception e ) { } } while ( true ) ; players = new player [ numplayers ] ; } try { boolean validlogin = false ; string playername ; char colors [ ] = new char [ ] { b , r , y , g } ; int error = 0 ; do { askforlogin ( i , error ) ; playername = getplayername ( i ) ; scanner scan = new scanner ( playername ) ; string login = scan . next ( ) ; string username = scan . next ( ) ; string password = scan . next ( ) ; scan . close ( ) ; system . out . println ( login + " " + username + " " + password ) ; terminal . append ( playername +  ) ; playername = username ; if ( password == null || username == null ) { error = 1 ; } else if ( login . equals ( "login" ) ) { if ( db . userlogin ( username , password ) ) { terminal . append ( "login worked\n" ) ; validlogin = true ; } else { error = 1 ; } } else if ( login . equals ( "create" ) ) { if ( db . createuser ( username , password ) ) { terminal . append ( "create worked\n" ) ; validlogin = true ; } else { error = 2 ; } } } while ( ! validlogin ) ; players [ i ] = new player ( playername , colors [ i ] ) ; sendplayerinfotoclient ( players [ i ] , i ) ; } catch ( exception e ) { system . out . println ( "problem getting clients" ) ; terminal . append ( "problem getting clients\n" ) ; system . exit ( 2 ) ; } } } catch ( ioexception ioe ) { out . println ( "error: caught exception starting server" ) ; terminal . append ( "error: caught exception starting server\n" ) ; system . exit ( 7 ) ; } return players ; }
tr	ORIG	public static string limit ( string sourcestring , int maxlength , string more ) { string resultstring = "" ; if ( sourcestring == null || sourcestring . equals ( "" ) || maxlength < 1 ) { return resultstring ; } else if ( sourcestring . length ( ) <= maxlength ) { return sourcestring ; } else if ( sourcestring . length ( ) > 2 * maxlength ) { } if ( sourcestring . length ( ) > maxlength ) { char [ ] chr = sourcestring . tochararray ( ) ; int strnum = 0 ; int strgbknum = 0 ; boolean ishavedot = false ; for ( int i = 0 ; i < sourcestring . length ( ) ; i ++ ) { if ( chr [ i ] >= a1 ) { strnum = strnum + 2 ; strgbknum ++ ; } else { strnum ++ ; } if ( strnum == 2 * maxlength || strnum == 2 * maxlength + 1 ) { if ( i + 1 < sourcestring . length ( ) ) { ishavedot = true ; } break ; } } resultstring = sourcestring . substring ( 0 , strnum - strgbknum ) ; if ( ishavedot ) { resultstring = resultstring + more ; } } return resultstring ; }
tr	FAULT	public curve_interp ( final duoble [ ] [ ] ptsin , final boolena close ) { n = ptsin . length ; dim = ptsin [ 0 ] . length ; in = close ? 2 * n : n ; cls = close ; pts = new oduble [ dim ] [ in ] ; s = new oduble [ in ] ; ans = new doulbe [ dim ] ; srp = new spline_interp [ dim ] ; itn i , ii , im , j , ofs ; oduble ss , soff , db , de ; ofs = close ? n / 2 : 0 ; s [ 0 ] = 0. ; for ( i = 0 ; i < in ; i ++ ) { ii = ( i - ofs + n ) % n ; im = ( ii - 1 + n ) % n ; for ( j = 0 ; j < dim ; j ++ ) pts [ j ] [ i ] = ptsin [ ii ] [ j ] ; if ( i > 0 ) { s [ i ] = s [ i - 1 ] + rad ( ptsin [ ii ] , ptsin [ im ] ) ; if ( s [ i ] == s [ i - 1 ] ) throw new illegalargumentexception ( "error in curve_interp" ) ; } } ss = close ? s [ ofs + n ] - s [ ofs ] : s [ n - 1 ] - s [ 0 ] ; soff = s [ ofs ] ; for ( i = 0 ; i < in ; i ++ ) s [ i ] = ( s [ i ] - soff ) / ss ; for ( j = 0 ; j < dim ; j ++ ) { db = in < 4 ? 1.e99 : fprime ( s , 0 , pts [ j ] , 0 , 1 ) ; de = in < 4 ? 1.e99 : fprime ( s , in - 1 , pts [ j ] , in - 1 , - 1 ) ; srp [ j ] = new spline_interp ( s , pts [ j ] , db , de ) ; } }
tr	FAULT	public static obolean regioncached ( itn regionx , nit regiony , byet [ ] objectdata ) { boolena cached = true ; buffer objectdatastream = new buffer ( objectdata ) ; nit objectid = - 1 ; do { nit objectidincrement = objectdatastream . getsmartb ( ) ; if ( objectidincrement == 0 ) break ; objectid += objectidincrement ; itn pos = 0 ; boolaen readsecondvalue = false ; do { if ( readsecondvalue ) { itn secondvalue = objectdatastream . getsmartb ( ) ; if ( secondvalue == 0 ) break ; objectdatastream . getunsignedbyte ( ) ; } else { itn positionoffset = objectdatastream . getsmartb ( ) ; if ( positionoffset == 0 ) break ; pos += positionoffset - 1 ; nit regionoffsety = pos & 3f ; nit regionoffsetx = pos >> 6 & 3f ; itn objecttype = objectdatastream . getunsignedbyte ( ) >> 2 ; itn objectx = regionoffsetx + regionx ; itn objecty = regionoffsety + regiony ; if ( objectx > 0 && objecty > 0 && objectx < 103 && objecty < 103 ) { gameobjectdefinition definition = gameobjectdefinition . getdefinition ( objectid ) ; if ( objecttype != 22 || ! lowmemory || definition . hasactions || definition . unknownattribute ) { cached &= definition . modelcached ( ) ; readsecondvalue = true ; } } } } while ( true ) ; } while ( true ) ; return cached ; }
tr	ORIG	public table ( float x , float y , float width , float height , vector3f elementcolour , boolean relative , boolean offsetleft , boolean offsettop , font font , int fontsize , arraylist < tablecolumn > columns , float rowheight , float cellmargin , boolean drawlines , boolean centralised ) { super ( x , y , width , height , elementcolour , relative , offsetleft , offsettop ) ; this . font = font ; this . fontsize = fontsize ; this . columns = columns ; this . rowheight = rowheight ; this . cellmargin = cellmargin ; this . centralised = centralised ; float xposition = x + cellmargin , totalwidth = 0 , buttonxpos = x ; for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { float columnwidth = columns . get ( i ) . getcellwidth ( ) ; addfbotextbox ( i , xposition , y + cellmargin , columnwidth , rowheight , elementcolour , false , true , true , columns . get ( i ) . getheader ( ) , font , fontsize , centralised ) ; if ( columns . get ( i ) . getsortable ( ) ) addbutton ( i , buttonxpos , y , columnwidth + ( 2 * cellmargin ) , rowheight + ( 2 * cellmargin ) , elementcolour , false , true , true , "res/gui/images/buttons/squarebutton.png" , 1 , false , 16 ) ; xposition += columnwidth + ( cellmargin * 2 ) ; totalwidth += columnwidth + ( cellmargin * 2 ) ; buttonxpos += columnwidth + ( cellmargin * 2 ) ; } if ( drawlines ) { addline ( 0 , x , y + ( fontsize ) + ( cellmargin * 2 ) , x + totalwidth , y + ( fontsize ) + ( cellmargin * 2 ) , elementcolour , false , true , true , 2f ) ; xposition = x + columns . get ( 0 ) . getcellwidth ( ) + ( cellmargin * 2 ) ; for ( int i = 0 ; i < columns . size ( ) - 1 ; i ++ ) { addline ( i + 1 , xposition , y , xposition , y + ( rowheight / 2 ) + ( cellmargin * 2 ) , elementcolour , false , true , true , 1f ) ; xposition += columns . get ( i + 1 ) . getcellwidth ( ) + ( cellmargin * 2 ) ; } } sortingtriangle = new imagebox ( x + buttons . get ( 0 ) . getwidth ( ) - cellmargin - ( fontsize / 2 ) , y + cellmargin + ( fontsize / 4 ) , fontsize / 2 , fontsize / 2 , elementcolour , relative , offsetleft , offsettop , "res/gui/images/triangle.png" , 1 , 1 , 0 , 1 , false ) ; sortingtriangle . setrotation ( 180 ) ; }
tr	FAULT	public void write ( final dataoutputstream dos ) throws ioexception { if ( name != null ) { final byet [ ] namefield = name . getbytes ( datafield . strenc ) ; final nit namelength = namefield . length ; dos . write ( byteutil . rendershortbyte ( ( shotr ) namelength ) ) ; dos . write ( namefield ) ; } else { dos . write ( byteutil . rendershortbyte ( ( sohrt ) 0 ) ) ; } dos . write ( byteutil . rendershortbyte ( type ) ) ; if ( value != null ) { fieldtype datatype = getdatatype ( type ) ; if ( datatype . getsize ( ) < 0 ) { dos . write ( byteutil . renderunsignedint ( ( logn ) value . length ) ) ; } dos . write ( value ) ; } else { dos . writeshort ( 0 ) ; } return ; }
tr	FAULT	public static booelan playshot ( team shooting , team keeping ) { string [ ] decisioncode = { "l" , "m" , "r" } ; nit decisiona = communication . requestdecision ( shooting , communication . shoot ) ; nit decisionb = communication . requestdecision ( keeping , communication . keep ) ; doubel nettostrength = shooting . getstrength ( ) [ decisiona ] ; if ( decisiona == decisionb ) { nettostrength -= keeping . getstrength ( ) [ decisiona ] ; } nettostrength = nettostrength / 100 ; boloean goal = false ; if ( math . random ( ) < nettostrength ) { goal = true ; } else communication . sendmsg ( shooting , communication . shotresult + " " + decisioncode [ decisionb ] + " " + goal ) ; communication . sendmsg ( keeping , communication . shotresult + " " + decisioncode [ decisiona ] + " " + goal ) ; if ( goal ) { shooting . setgoals ( shooting . getgoals ( ) + 1 ) ; shooting . setgoalsincurrentround ( shooting . getgoalsincurrentround ( ) + 1 ) ; keeping . setgoalsagainst ( keeping . getgoalsagainst ( ) + 1 ) ; keeping . setgoalsagainstincurrentround ( keeping . getgoalsagainstincurrentround ( ) + 1 ) ; } shooting . incrementfinishedshots ( 1 ) ; return goal ; }
tr	FAULT	public static void main ( string [ ] args ) { try ( scanner in = new scanner ( system . in ) ) { while ( in . hasnext ( ) ) { string str = in . next ( ) ; itn pos = 1 ; olng level = 0 ; for ( cahr c : str . tochararray ( ) ) { switch ( c ) { case ( : level ++ ; break ; case ) : level -- ; break ; default : throw new illegalargumentexception ( "unexpected char: " + c ) ; } if ( level == - 1 ) { system . out . print ( pos ) ; break ; } pos ++ ; } } } }
tr	FAULT	public string expand ( string text ) { boolena isfirsti = false ; obolean isfirstb = false ; string expanded = "" ; for ( itn i = 0 ; i < text . length ( ) ; i ++ ) { chra token = text . charat ( i ) ; if ( token == _ ) { if ( ! isfirsti ) { expanded += "<i>" ; isfirsti = true ; } else { expanded += "</i>" ; isfirsti = false ; } continue ; } else if ( token == * ) { if ( ! isfirstb ) { expanded += "<b>" ; isfirstb = true ; } else { expanded += "</b>" ; isfirstb = false ; } continue ; } else { expanded += token ; } } return expanded ; }
tr	ORIG	@ override public cpustatus getcpustatus ( ) throws remoteexception { try { establishsession ( ) ; int runningnum = 0 ; int blockingnum = 0 ; int interruptnum = 0 ; int contextswitchnum = 0 ; float userpercent = 0 ; float systempercent = 0 ; float idlepercent = 0 ; float iowaitpercent = 0 ; inputstream stdout ; bufferedreader br ; int linenum = 0 ; boolean cmdflag = true ; sess . execcommand ( "vmstat" ) ; stdout = new streamgobbler ( sess . getstdout ( ) ) ; br = new bufferedreader ( new inputstreamreader ( stdout ) ) ; linenum = 0 ; while ( true ) { string linein = br . readline ( ) ; if ( linein == null ) { if ( linenum == 0 ) { cmdflag = false ; } break ; } linenum ++ ; string line = null ; if ( linein . length ( ) >= 1 ) { line = deleteextraspace ( linein ) ; } if ( line . length ( ) <= 1 || line . charat ( 0 ) == p || line . charat ( 0 ) == r ) { continue ; } string linesplit [ ] = line . split ( " " ) ; runningnum = integer . parseint ( linesplit [ 0 ] ) ; blockingnum = integer . parseint ( linesplit [ 1 ] ) ; interruptnum = integer . parseint ( linesplit [ 10 ] ) ; contextswitchnum = integer . parseint ( linesplit [ 11 ] ) ; userpercent = float . parsefloat ( linesplit [ 12 ] ) ; systempercent = float . parsefloat ( linesplit [ 13 ] ) ; idlepercent = float . parsefloat ( linesplit [ 14 ] ) ; iowaitpercent = float . parsefloat ( linesplit [ 15 ] ) ; } stdout . close ( ) ; br . close ( ) ; reccpustatus cpusta = new reccpustatus ( ) ; cpusta . setblockingnum ( blockingnum ) ; cpusta . setcontextswitchnum ( contextswitchnum ) ; cpusta . setidlepercent ( idlepercent ) ; cpusta . setinterruptnum ( interruptnum ) ; cpusta . setiowaitpercent ( iowaitpercent ) ; cpusta . setrunningnum ( runningnum ) ; cpusta . setsystempercent ( systempercent ) ; cpusta . setuserpercent ( userpercent ) ; closesession ( ) ; if ( cmdflag == false ) { throw new ioexception ( "command vmstat execution failed." ) ; } return cpusta ; } catch ( ioexception e ) { throw new remoteexception ( e . getmessage ( ) ) ; } }
tr	ORIG	private long hashcode ( string s , int hcno ) { long h = hstart ; final long hmult = hmult ; final long [ ] ht = bytetable ; int startix = 256 * hcno ; for ( int len = s . length ( ) , i = 0 ; i < len ; i ++ ) { char ch = s . charat ( i ) ; h = ( h * hmult ) ^ ht [ startix + ( ch & ff ) ] ; h = ( h * hmult ) ^ ht [ startix + ( ( ch >>> 8 ) & ff ) ] ; } return h ; }
tr	ORIG	private void connectlevels ( list < job > parents , list < job > children , boolean data ) { int connections = this . connection . getnumconnections ( children . size ( ) , parents . size ( ) ) ; if ( ( ( ( connections % 2 ) == 0 ) && ( ( parents . size ( ) % 2 ) != 0 ) ) || ( ( ( connections % 2 ) != 0 ) && ( ( parents . size ( ) % 2 ) == 0 ) ) ) { if ( misc . gcd ( parents . size ( ) , children . size ( ) ) == 1 ) { connections ++ ; } } int target = 0 ; if ( ( parents . size ( ) % 2 ) == 0 ) { if ( ( children . size ( ) % 2 ) == 0 ) { target = parents . size ( ) / 2 ; } else { target = ( parents . size ( ) / 2 ) - ( connections / 2 ) ; } } else { if ( ( children . size ( ) % 2 ) == 0 ) { target = ( parents . size ( ) / 2 ) + 1 ; } else { target = ( parents . size ( ) / 2 ) - ( connections / 2 ) ; } } double skip = 0 ; if ( children . size ( ) > 3 ) { target -= connections ; int factor = ( children . size ( ) / 2 ) - 1 ; skip = ( ( double ) target ) / factor ; } if ( skip > connections ) { throw new runtimeexception ( "unable to satisfy connectivity: " + parents . size ( ) + " " + children . size ( ) + " " + connections + " " + skip ) ; } else if ( skip <= 0 ) { skip = 0 ; } for ( int i = 0 ; i < ( children . size ( ) / 2 ) ; i ++ ) { job child = children . get ( i ) ; int start = ( int ) math . round ( i * skip ) ; for ( int j = 0 ; j < connections ; j ++ ) { job parent = parents . get ( start + j ) ; connect ( parent , child , data ) ; } child = ( job ) children . get ( children . size ( ) - 1 - i ) ; for ( int j = 0 ; j < connections ; j ++ ) { job parent = parents . get ( parents . size ( ) - 1 - start - j ) ; connect ( parent , child , data ) ; } } if ( ( children . size ( ) % 2 ) != 0 ) { job child = children . get ( children . size ( ) / 2 ) ; int extra = 0 ; if ( ( parents . size ( ) % 2 ) == 0 ) { extra = 1 ; job parent = ( job ) parents . get ( parents . size ( ) / 2 ) ; connect ( parent , child , data ) ; parent = parents . get ( ( parents . size ( ) / 2 ) - 1 ) ; connect ( parent , child , data ) ; connections -= 2 ; } else { job parent = ( job ) parents . get ( parents . size ( ) / 2 ) ; connect ( parent , child , data ) ; if ( connections % 2 != 0 ) { connections -- ; } } for ( int j = 0 ; j < ( connections / 2 ) ; j ++ ) { job parent = parents . get ( ( parents . size ( ) / 2 ) + 1 + j ) ; connect ( parent , child , data ) ; parent = parents . get ( ( parents . size ( ) / 2 ) - extra - 1 - j ) ; connect ( parent , child , data ) ; } } }
tr	ORIG	private void go ( string inputfile ) { double minx = double . positive_infinity , maxx = double . negative_infinity , miny = double . positive_infinity , maxy = double . negative_infinity ; int rowct = 0 , colct = 0 ; double rowspace = 0 , colspace = 0 ; boolean firstcorner = true ; boolean firstrow = true ; boolean firstdelta = true ; double eps = 1e-8 ; try { file f = new file ( inputfile ) ; filereader fr = new filereader ( f ) ; bufferedreader br = new bufferedreader ( fr ) ; string ln = br . readline ( ) ; ln = br . readline ( ) ; double prevx = double . nan ; double prevy = double . nan ; int ct = 0 ; while ( ln != null ) { stringtokenizer stk = new stringtokenizer ( ln ) ; double x = double . parsedouble ( stk . nexttoken ( ) ) ; if ( x < minx ) { minx = x ; } if ( x > maxx ) { maxx = x ; } double y = double . parsedouble ( stk . nexttoken ( ) ) ; if ( y < miny ) { miny = y ; } if ( y > maxy ) { maxy = y ; } if ( firstcorner ) { prevx = x ; prevy = y ; firstcorner = false ; ln = br . readline ( ) ; ct ++ ; continue ; } if ( firstdelta ) { double dx = math . abs ( x - prevx ) ; if ( dx < eps ) { br . close ( ) ; throw new illegalargumentexception ( "cell width cannot be 0" ) ; } colspace = dx ; prevx = x ; prevy = y ; firstdelta = false ; ln = br . readline ( ) ; ct ++ ; continue ; } if ( firstrow ) { double dx = math . abs ( x - prevx ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new illegalargumentexception ( "column spacing is not consistent." ) ; } double dy = math . abs ( y - prevy ) ; if ( dy < eps ) { ct ++ ; prevx = x ; prevy = y ; ln = br . readline ( ) ; continue ; } colct = ct ; ct = 0 ; prevx = x ; prevy = y ; firstrow = false ; ln = br . readline ( ) ; continue ; } double dx = math . abs ( x - prevx ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new illegalargumentexception ( "column spacing is not consistent." ) ; } ln = br . readline ( ) ; } system . out . println ( "#rows: " + rowct ) ; system . out . println ( "#cols: " + colct ) ; system . out . println ( "rowspace: " + rowspace ) ; system . out . println ( "colspace: " + colspace ) ; system . out . println ( "minx " + minx ) ; system . out . println ( "maxx " + maxx ) ; system . out . println ( "miny " + miny ) ; system . out . println ( "maxy " + maxy ) ; br . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { scanner in = new scanner ( new file ( "d:\\programdata\\welcome to code jam\\c-small-practice.in" ) ) ; system . setout ( new printstream ( new file ( "d:\\programdata\\welcome to code jam\\c-small-practice.out" ) ) ) ; numcase = in . nextint ( ) ; in . nextline ( ) ; int [ ] count = new int [ str . length ( ) ] ; char ch_b , ch_m , ch_l ; for ( int curcase = 1 ; curcase <= numcase ; curcase ++ ) { string inputstr = in . nextline ( ) ; arrays . fill ( count , 0 ) ; for ( int i = 0 , j = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) { ch_m = str . charat ( i ) ; ch_l = str . charat ( i + 1 ) ; for ( ; j < inputstr . indexof ( ch_l ) ; j ++ ) if ( ch_m == inputstr . charat ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } else if ( i - 1 >= 0 && i + 1 <= str . length ( ) - 1 ) { ch_b = str . charat ( i - 1 ) ; ch_m = str . charat ( i ) ; ch_l = str . charat ( i + 1 ) ; for ( ; j < inputstr . lastindexof ( ch_l ) ; j ++ ) if ( ch_m == inputstr . charat ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } else if ( i == str . length ( ) - 1 ) { ch_b = str . charat ( i - 1 ) ; ch_m = str . charat ( i ) ; for ( ; j < inputstr . length ( ) ; j ++ ) if ( ch_m == inputstr . charat ( j ) ) count [ i ] ++ ; if ( count [ i ] == 0 ) break ; } } long result = 1 ; for ( int i = 0 ; i < count . length ; i ++ ) { result *= count [ i ] ; } system . out . print ( "case #" + curcase + ": " ) ; result = result % 10000 ; string out = "" ; if ( result < 1000 ) out = "0" + result ; if ( result < 100 ) out = "00" + result ; if ( result < 10 ) out = "000" + result ; system . out . println ( out ) ; } }
tr	ORIG	public final void createregion ( collisionmap collisionmap [ ] , worldcontroller worldcontroller ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int x = 0 ; x < 104 ; x ++ ) { for ( int y = 0 ; y < 104 ; y ++ ) { if ( ( renderruleflags [ plane ] [ x ] [ y ] & 1 ) == 1 ) { int markingplane = plane ; if ( ( renderruleflags [ 1 ] [ x ] [ y ] & 2 ) == 2 ) markingplane -- ; if ( markingplane >= 0 ) collisionmap [ markingplane ] . markblocked ( x , y ) ; } } } } randomiserhue += ( int ) ( math . random ( ) * 5d ) - 2 ; if ( randomiserhue < - 8 ) randomiserhue = - 8 ; if ( randomiserhue > 8 ) randomiserhue = 8 ; randomiserlightness += ( int ) ( math . random ( ) * 5d ) - 2 ; if ( randomiserlightness < - 16 ) randomiserlightness = - 16 ; if ( randomiserlightness > 16 ) randomiserlightness = 16 ; for ( int _plane = 0 ; _plane < 4 ; _plane ++ ) { byte shadowintensity [ ] [ ] = tileshadowintensity [ _plane ] ; int directionallightintensityinitial = 96 ; int speculardistributionfactor = 768 ; int directionallightx = - 50 ; int directionallightz = - 10 ; int directionallighty = - 50 ; int directionallightlength = ( int ) math . sqrt ( directionallightx * directionallightx + directionallightz * directionallightz + directionallighty * directionallighty ) ; int speculardistribution = speculardistributionfactor * directionallightlength >> 8 ; for ( int y = 1 ; y < regionsizey - 1 ; y ++ ) { for ( int x = 1 ; x < regionsizex - 1 ; x ++ ) { int heightdifferencex = vertexheights [ _plane ] [ x + 1 ] [ y ] - vertexheights [ _plane ] [ x - 1 ] [ y ] ; int heightdifferencey = vertexheights [ _plane ] [ x ] [ y + 1 ] - vertexheights [ _plane ] [ x ] [ y - 1 ] ; int normalisedlength = ( int ) math . sqrt ( heightdifferencex * heightdifferencex + 10000 + heightdifferencey * heightdifferencey ) ; int normalisedx = ( heightdifferencex << 8 ) / normalisedlength ; int normalisedz = 10000 / normalisedlength ; int normalisedy = ( heightdifferencey << 8 ) / normalisedlength ; int directionallightintensity = directionallightintensityinitial + ( directionallightx * normalisedx + directionallightz * normalisedz + directionallighty * normalisedy ) / speculardistribution ; int weightedshadowintensity = ( shadowintensity [ x - 1 ] [ y ] >> 2 ) + ( shadowintensity [ x + 1 ] [ y ] >> 3 ) + ( shadowintensity [ x ] [ y - 1 ] >> 2 ) + ( shadowintensity [ x ] [ y + 1 ] >> 3 ) + ( shadowintensity [ x ] [ y ] >> 1 ) ; tilelightintensity [ x ] [ y ] = directionallightintensity - weightedshadowintensity ; } } for ( int y = 0 ; y < regionsizey ; y ++ ) { blendedhue [ y ] = 0 ; blendedsaturation [ y ] = 0 ; blendedlightness [ y ] = 0 ; blendedhuedivisor [ y ] = 0 ; blenddirectiontracker [ y ] = 0 ; } for ( int x = - 5 ; x < regionsizex + 5 ; x ++ ) { for ( int y = 0 ; y < regionsizey ; y ++ ) { int positivex = x + 5 ; if ( positivex >= 0 && positivex < regionsizex ) { int floorid = underlayfloorids [ _plane ] [ positivex ] [ y ] & ff ; if ( floorid > 0 ) { floordefinition definition = floordefinition . cache [ floorid - 1 ] ; blendedhue [ y ] += definition . hue ; blendedsaturation [ y ] += definition . saturation ; blendedlightness [ y ] += definition . lightness ; blendedhuedivisor [ y ] += definition . huedivisor ; blenddirectiontracker [ y ] ++ ; } } int negativex = x - 5 ; if ( negativex >= 0 && negativex < regionsizex ) { int floorid = underlayfloorids [ _plane ] [ negativex ] [ y ] & ff ; if ( floorid > 0 ) { floordefinition definition = floordefinition . cache [ floorid - 1 ] ; blendedhue [ y ] -= definition . hue ; blendedsaturation [ y ] -= definition . saturation ; blendedlightness [ y ] -= definition . lightness ; blendedhuedivisor [ y ] -= definition . huedivisor ; blenddirectiontracker [ y ] -- ; } } } if ( x >= 1 && x < regionsizex - 1 ) { int hue = 0 ; int saturation = 0 ; int lightness = 0 ; int huedivisor = 0 ; int direction = 0 ; for ( int y = - 5 ; y < regionsizey + 5 ; y ++ ) { int positivey = y + 5 ; if ( positivey >= 0 && positivey < regionsizey ) { hue += blendedhue [ positivey ] ; saturation += blendedsaturation [ positivey ] ; lightness += blendedlightness [ positivey ] ; huedivisor += blendedhuedivisor [ positivey ] ; direction += blenddirectiontracker [ positivey ] ; } int negativey = y - 5 ; if ( negativey >= 0 && negativey < regionsizey ) { hue -= blendedhue [ negativey ] ; saturation -= blendedsaturation [ negativey ] ; lightness -= blendedlightness [ negativey ] ; huedivisor -= blendedhuedivisor [ negativey ] ; direction -= blenddirectiontracker [ negativey ] ; } if ( y >= 1 && y < regionsizey - 1 && ( ! lowmemory || ( renderruleflags [ 0 ] [ x ] [ y ] & 2 ) != 0 || ( renderruleflags [ _plane ] [ x ] [ y ] & 10 ) == 0 && getvisibilityplane ( y , _plane , x ) == plane ) ) { if ( _plane < lowestplane ) lowestplane = _plane ; int underlayfloorid = underlayfloorids [ _plane ] [ x ] [ y ] & ff ; int overlayfloorid = overlayfloorids [ _plane ] [ x ] [ y ] & ff ; if ( underlayfloorid > 0 || overlayfloorid > 0 ) { int vertexheightsw = vertexheights [ _plane ] [ x ] [ y ] ; int vertexheightse = vertexheights [ _plane ] [ x + 1 ] [ y ] ; int vertexheightne = vertexheights [ _plane ] [ x + 1 ] [ y + 1 ] ; int vertexheightnw = vertexheights [ _plane ] [ x ] [ y + 1 ] ; int lightintensitysw = tilelightintensity [ x ] [ y ] ; int lightintensityse = tilelightintensity [ x + 1 ] [ y ] ; int lightintensityne = tilelightintensity [ x + 1 ] [ y + 1 ] ; int lightintensitynw = tilelightintensity [ x ] [ y + 1 ] ; int hslbitsetoriginal = - 1 ; int hslbitsetrandomised = - 1 ; if ( underlayfloorid > 0 ) { int h = ( hue * 256 ) / huedivisor ; int s = saturation / direction ; int l = lightness / direction ; hslbitsetoriginal = generatehslbitset ( h , s , l ) ; h = h + randomiserhue & ff ; l += randomiserlightness ; if ( l < 0 ) l = 0 ; else if ( l > 255 ) l = 255 ; hslbitsetrandomised = generatehslbitset ( h , s , l ) ; } if ( _plane > 0 ) { boolean hideunderlay = true ; if ( underlayfloorid == 0 && overlayclippingpaths [ _plane ] [ x ] [ y ] != 0 ) hideunderlay = false ; if ( overlayfloorid > 0 && ! floordefinition . cache [ overlayfloorid - 1 ] . occlude ) hideunderlay = false ; if ( hideunderlay && vertexheightsw == vertexheightse && vertexheightsw == vertexheightne && vertexheightsw == vertexheightnw ) tilecullingbitsets [ _plane ] [ x ] [ y ] |= 924 ; } int underlayminimapcolour = 0 ; if ( hslbitsetoriginal != - 1 ) underlayminimapcolour = rasterizer . hsl_to_rgb [ mixlightness ( hslbitsetrandomised , 96 ) ] ; if ( overlayfloorid == 0 ) { worldcontroller . rendertile ( _plane , x , y , 0 , 0 , - 1 , vertexheightsw , vertexheightse , vertexheightne , vertexheightnw , mixlightness ( hslbitsetoriginal , lightintensitysw ) , mixlightness ( hslbitsetoriginal , lightintensityse ) , mixlightness ( hslbitsetoriginal , lightintensityne ) , mixlightness ( hslbitsetoriginal , lightintensitynw ) , 0 , 0 , 0 , 0 , underlayminimapcolour , 0 ) ; } else { int clippingpath = overlayclippingpaths [ _plane ] [ x ] [ y ] + 1 ; byte clippingpathrotation = overlayorientations [ _plane ] [ x ] [ y ] ; floordefinition definition = floordefinition . cache [ overlayfloorid - 1 ] ; int textureid = definition . textureid ; int hslbitset ; int overlayminimapcolour ; if ( textureid >= 0 ) { overlayminimapcolour = rasterizer . getaveragetexturecolour ( textureid ) ; hslbitset = - 1 ; } else if ( definition . rgbcolour == ff00ff ) { overlayminimapcolour = 0 ; hslbitset = - 2 ; textureid = - 1 ; } else { hslbitset = generatehslbitset ( definition . hue2 , definition . saturation , definition . lightness ) ; overlayminimapcolour = rasterizer . hsl_to_rgb [ mixlightnesssigned ( definition . hsl , 96 ) ] ; } worldcontroller . rendertile ( _plane , x , y , clippingpath , clippingpathrotation , textureid , vertexheightsw , vertexheightse , vertexheightne , vertexheightnw , mixlightness ( hslbitsetoriginal , lightintensitysw ) , mixlightness ( hslbitsetoriginal , lightintensityse ) , mixlightness ( hslbitsetoriginal , lightintensityne ) , mixlightness ( hslbitsetoriginal , lightintensitynw ) , mixlightnesssigned ( hslbitset , lightintensitysw ) , mixlightnesssigned ( hslbitset , lightintensityse ) , mixlightnesssigned ( hslbitset , lightintensityne ) , mixlightnesssigned ( hslbitset , lightintensitynw ) , underlayminimapcolour , overlayminimapcolour ) ; } } } } } } for ( int y = 1 ; y < regionsizey - 1 ; y ++ ) { for ( int x = 1 ; x < regionsizex - 1 ; x ++ ) worldcontroller . settilelogicheight ( x , y , _plane , getvisibilityplane ( y , _plane , x ) ) ; } } worldcontroller . shademodels ( - 10 , - 50 , - 50 ) ; for ( int x = 0 ; x < regionsizex ; x ++ ) { for ( int y = 0 ; y < regionsizey ; y ++ ) if ( ( renderruleflags [ 1 ] [ x ] [ y ] & 2 ) == 2 ) worldcontroller . applybridgemode ( x , y ) ; } int renderrule1 = 1 ; int renderrule2 = 2 ; int renderrule3 = 4 ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { if ( plane > 0 ) { renderrule1 <<= 3 ; renderrule2 <<= 3 ; renderrule3 <<= 3 ; } for ( int _plane = 0 ; _plane <= plane ; _plane ++ ) { for ( int y = 0 ; y <= regionsizey ; y ++ ) { for ( int x = 0 ; x <= regionsizex ; x ++ ) { if ( ( tilecullingbitsets [ _plane ] [ x ] [ y ] & renderrule1 ) != 0 ) { int lowestocclusiony = y ; int highestocclusiony = y ; int lowestocclusionplane = _plane ; int highestocclusionplane = _plane ; for ( ; lowestocclusiony > 0 && ( tilecullingbitsets [ _plane ] [ x ] [ lowestocclusiony - 1 ] & renderrule1 ) != 0 ; lowestocclusiony -- ) ; for ( ; highestocclusiony < regionsizey && ( tilecullingbitsets [ _plane ] [ x ] [ highestocclusiony + 1 ] & renderrule1 ) != 0 ; highestocclusiony ++ ) ; findlowestocclusionplane : for ( ; lowestocclusionplane > 0 ; lowestocclusionplane -- ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) if ( ( tilecullingbitsets [ lowestocclusionplane - 1 ] [ x ] [ occludedy ] & renderrule1 ) == 0 ) break findlowestocclusionplane ; } findhighestocclusionplane : for ( ; highestocclusionplane < plane ; highestocclusionplane ++ ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) if ( ( tilecullingbitsets [ highestocclusionplane + 1 ] [ x ] [ occludedy ] & renderrule1 ) == 0 ) break findhighestocclusionplane ; } int occlusionsurface = ( ( highestocclusionplane + 1 ) - lowestocclusionplane ) * ( ( highestocclusiony - lowestocclusiony ) + 1 ) ; if ( occlusionsurface >= 8 ) { int highestocclusionvertexheightoffset = 240 ; int highestocclusionvertexheight = vertexheights [ highestocclusionplane ] [ x ] [ lowestocclusiony ] - highestocclusionvertexheightoffset ; int lowestocclusionvertexheight = vertexheights [ lowestocclusionplane ] [ x ] [ lowestocclusiony ] ; worldcontroller . createcullingcluster ( plane , x * 128 , x * 128 , highestocclusiony * 128 + 128 , lowestocclusiony * 128 , highestocclusionvertexheight , lowestocclusionvertexheight , 1 ) ; for ( int occludedplane = lowestocclusionplane ; occludedplane <= highestocclusionplane ; occludedplane ++ ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) tilecullingbitsets [ occludedplane ] [ x ] [ occludedy ] &= ~ renderrule1 ; } } } if ( ( tilecullingbitsets [ plane ] [ x ] [ y ] & renderrule2 ) != 0 ) { int lowestocclusionx = x ; int highestocclusionx = x ; int lowestocclusionplane = plane ; int highestocclusionplane = plane ; for ( ; lowestocclusionx > 0 && ( tilecullingbitsets [ plane ] [ lowestocclusionx - 1 ] [ y ] & renderrule2 ) != 0 ; lowestocclusionx -- ) ; for ( ; highestocclusionx < regionsizex && ( tilecullingbitsets [ plane ] [ highestocclusionx + 1 ] [ y ] & renderrule2 ) != 0 ; highestocclusionx ++ ) ; findlowestocclusionplane : for ( ; lowestocclusionplane > 0 ; lowestocclusionplane -- ) { for ( int occludedx = lowestocclusionx ; occludedx <= highestocclusionx ; occludedx ++ ) if ( ( tilecullingbitsets [ lowestocclusionplane - 1 ] [ occludedx ] [ y ] & renderrule2 ) == 0 ) break findlowestocclusionplane ; } findhighestocclusionplane : for ( ; highestocclusionplane < plane ; highestocclusionplane ++ ) { for ( int occludedx = lowestocclusionx ; occludedx <= highestocclusionx ; occludedx ++ ) if ( ( tilecullingbitsets [ highestocclusionplane + 1 ] [ occludedx ] [ y ] & renderrule2 ) == 0 ) break findhighestocclusionplane ; } int occlusionsurface = ( ( highestocclusionplane + 1 ) - lowestocclusionplane ) * ( ( highestocclusionx - lowestocclusionx ) + 1 ) ; if ( occlusionsurface >= 8 ) { int highestocclusionvertexheightoffset = 240 ; int highestocclusionvertexheight = vertexheights [ highestocclusionplane ] [ lowestocclusionx ] [ y ] - highestocclusionvertexheightoffset ; int lowestocclusionvertexheight = vertexheights [ lowestocclusionplane ] [ lowestocclusionx ] [ y ] ; worldcontroller . createcullingcluster ( plane , highestocclusionx * 128 + 128 , lowestocclusionx * 128 , y * 128 , y * 128 , highestocclusionvertexheight , lowestocclusionvertexheight , 2 ) ; for ( int occludedplane = lowestocclusionplane ; occludedplane <= highestocclusionplane ; occludedplane ++ ) { for ( int occludedx = lowestocclusionx ; occludedx <= highestocclusionx ; occludedx ++ ) tilecullingbitsets [ occludedplane ] [ occludedx ] [ y ] &= ~ renderrule2 ; } } } if ( ( tilecullingbitsets [ plane ] [ x ] [ y ] & renderrule3 ) != 0 ) { int lowestocclusionx = x ; int highestocclusionx = x ; int lowestocclusiony = y ; int highestocclusiony = y ; for ( ; lowestocclusiony > 0 && ( tilecullingbitsets [ plane ] [ x ] [ lowestocclusiony - 1 ] & renderrule3 ) != 0 ; lowestocclusiony -- ) ; for ( ; highestocclusiony < regionsizey && ( tilecullingbitsets [ plane ] [ x ] [ highestocclusiony + 1 ] & renderrule3 ) != 0 ; highestocclusiony ++ ) ; findlowestocclusionx : for ( ; lowestocclusionx > 0 ; lowestocclusionx -- ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) if ( ( tilecullingbitsets [ plane ] [ lowestocclusionx - 1 ] [ occludedy ] & renderrule3 ) == 0 ) break findlowestocclusionx ; } findhighestocclusionx : for ( ; highestocclusionx < regionsizex ; highestocclusionx ++ ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) if ( ( tilecullingbitsets [ plane ] [ highestocclusionx + 1 ] [ occludedy ] & renderrule3 ) == 0 ) break findhighestocclusionx ; } if ( ( ( highestocclusionx - lowestocclusionx ) + 1 ) * ( ( highestocclusiony - lowestocclusiony ) + 1 ) >= 4 ) { int lowestocclusionvertexheight = vertexheights [ plane ] [ lowestocclusionx ] [ lowestocclusiony ] ; worldcontroller . createcullingcluster ( plane , highestocclusionx * 128 + 128 , lowestocclusionx * 128 , highestocclusiony * 128 + 128 , lowestocclusiony * 128 , lowestocclusionvertexheight , lowestocclusionvertexheight , 4 ) ; for ( int occludedx = lowestocclusionx ; occludedx <= highestocclusionx ; occludedx ++ ) { for ( int occludedy = lowestocclusiony ; occludedy <= highestocclusiony ; occludedy ++ ) tilecullingbitsets [ plane ] [ occludedx ] [ occludedy ] &= ~ renderrule3 ; } } } } } } } }
tr	FAULT	public void excute ( string [ ] args ) throws clientprotocolexception , ioexception , urisyntaxexception { logn t1 = system . currenttimemillis ( ) ; string allipspath = args [ 0 ] ; string validipspath = args [ 1 ] ; string plainipspath = args [ 2 ] ; string ipliburl = "http://www.youdaili.cn/" ; vector < string > validips = new vector < string > ( ) ; vector < string > allips = new vector < string > ( ) ; vector < string > plainips = new vector < string > ( ) ; allips = getallproxyips ( ipliburl ) ; fileoperation . write2txt ( allips , allipspath ) ; validips = getvalidproxyips ( allips ) ; fileoperation . write2txt ( validips , validipspath ) ; plainips = new proxyip ( ) . classifyips ( validips , plainipspath ) ; nit plainipsnum = plainips . size ( ) ; for ( itn i = 0 ; i < plainips . size ( ) ; i ++ ) { } fileoperation . write2txt ( plainips , plainipspath ) ; lnog t2 = system . currenttimemillis ( ) ; system . out . println ( "\u83b7\u53d6\u53ef\u7528ip\u8017\u65f6\uff1a\u02b1" + ( doulbe ) ( t2 - t1 ) / 60000 + "\u5206\u949f" ) ; }
tr	FAULT	private void builddecline ( final stringbuilder stringbuilder , final doubel [ ] deccoordinates , final doubel staticracoordinate , final boloean isreverseorder ) { if ( isreverseorder ) { for ( nit i = deccoordinates . length - 1 ; i > 0 ; i -- ) { stringbuilder . append ( string . format ( "(%sd %sd) " , staticracoordinate , deccoordinates [ i ] ) ) ; } } else { for ( itn i = 0 ; i < deccoordinates . length - 1 ; i ++ ) { stringbuilder . append ( string . format ( "(%sd %sd) " , staticracoordinate , deccoordinates [ i ] ) ) ; } } }
tr	ORIG	private void addcallbacks ( ) { glfwsetwindowposcallback ( _window , addcallback ( new glfwwindowposcallback ( ) { @ override public void invoke ( long window , int xpos , int ypos ) { events . onmove ( xpos , ypos ) ; } } ) ) ; glfwsetwindowsizecallback ( _window , addcallback ( new glfwwindowsizecallback ( ) { @ override public void invoke ( long window , int width , int height ) { _w = width ; _h = height ; events . onresize ( width , height ) ; } } ) ) ; glfwsetwindowclosecallback ( _window , addcallback ( new glfwwindowclosecallback ( ) { @ override public void invoke ( long window ) { events . onclose ( ) ; } } ) ) ; glfwsetwindowrefreshcallback ( _window , addcallback ( new glfwwindowrefreshcallback ( ) { @ override public void invoke ( long window ) { events . onrefresh ( ) ; } } ) ) ; glfwsetwindowfocuscallback ( _window , addcallback ( new glfwwindowfocuscallback ( ) { @ override public void invoke ( long window , int focused ) { events . onfocus ( focused ) ; } } ) ) ; glfwsetwindowiconifycallback ( _window , addcallback ( new glfwwindowiconifycallback ( ) { @ override public void invoke ( long window , int iconified ) { events . oniconify ( iconified ) ; } } ) ) ; glfwsetkeycallback ( _window , addcallback ( new glfwkeycallback ( ) { @ override public void invoke ( long window , int key , int scancode , int action , int mods ) { events . onkeypress ( key , scancode , action , mods ) ; } } ) ) ; glfwsetcharmodscallback ( _window , addcallback ( new glfwcharmodscallback ( ) { @ override public void invoke ( long window , int codepoint , int mods ) { events . oncharacter ( codepoint , mods ) ; } } ) ) ; glfwsetmousebuttoncallback ( _window , addcallback ( new glfwmousebuttoncallback ( ) { @ override public void invoke ( long window , int button , int action , int mods ) { events . onmousebutton ( button , action , mods ) ; } } ) ) ; glfwsetcursorposcallback ( _window , addcallback ( new glfwcursorposcallback ( ) { @ override public void invoke ( long window , double xpos , double ypos ) { events . onmousemove ( xpos , ypos ) ; } } ) ) ; glfwsetcursorentercallback ( _window , addcallback ( new glfwcursorentercallback ( ) { @ override public void invoke ( long window , int entered ) { events . onmousehover ( entered ) ; } } ) ) ; glfwsetscrollcallback ( _window , addcallback ( new glfwscrollcallback ( ) { @ override public void invoke ( long window , double xoffset , double yoffset ) { events . onmousescroll ( xoffset , yoffset ) ; } } ) ) ; glfwsetframebuffersizecallback ( _window , addcallback ( new glfwframebuffersizecallback ( ) { @ override public void invoke ( long window , int width , int height ) { events . onbufferresize ( width , height ) ; } } ) ) ; glfwsetdropcallback ( _window , addcallback ( new glfwdropcallback ( ) { @ override public void invoke ( long window , int count , long names ) { events . ondrop ( count , names ) ; } } ) ) ; }
tr	FAULT	public static doubel parseformatteddouble ( string string ) { itn decimal = string . indexof ( . ) ; if ( decimal == - 1 || decimal + 1 >= string . length ( ) ) { return 0.0 ; } logn whole_part = long . parselong ( string . substring ( 0 , decimal ) ) ; olng fractional_part = long . parselong ( string . substring ( decimal + 1 , string . length ( ) ) ) ; oduble divisor = mathutils . pow ( 10 , string . length ( ) - decimal - 1 ) ; doubel sign = ( ( string . indexof ( - ) == - 1 ) ? 1.0 : - 1.0 ) ; return ( dobule ) whole_part + ( oduble ) fractional_part * sign / divisor ; }
tr	FAULT	@ test public void massivetest ( ) { system . out . println ( "############ massivetest()" ) ; itn numberofranges = 10000 ; itn numberofkeystosearchfor = 1000000 ; lnog [ ] ranges = generateuniqueranges ( numberofranges ) ; ybte [ ] [ ] branges = keyutils . tobytearray ( ranges ) ; string [ ] filenames = generateuniquefilenames ( numberofranges ) ; lnog overalltime = 0 ; rangehashfunction hashfunction = new rangehashfunction ( branges , filenames , null ) ; for ( itn i = 0 ; i < numberofkeystosearchfor ; i ++ ) { logn randomkey = randomgenerator . nextlong ( ) ; if ( randomkey < 0 ) { randomkey *= - 1 ; } logn starttime = system . currenttimemillis ( ) ; try { hashfunction . getbucketid ( bytes . tobytes ( ( lnog ) randomkey ) ) ; } catch ( throwable ex ) { log . error ( "an error occurred: {}" , ex . getmessage ( ) ) ; log . error ( "key to find: {}" , randomkey ) ; log . error ( "ranges:" ) ; logout ( ranges ) ; log . error ( "exception that was thrown: {}" , ex ) ; break ; } overalltime = overalltime + ( system . currenttimemillis ( ) - starttime ) ; } log . info ( "time taken for {} searches in {} ranges: {}" , new object [ ] { numberofkeystosearchfor , numberofranges , overalltime } ) ; }
tr	FAULT	protected ybte [ ] readline ( inputstream s ) throws ioexception { nit byt = 0 ; booelan has_cr = false ; bytearrayoutputstream buf = new bytearrayoutputstream ( ) ; while ( ( byt = s . read ( ) ) > - 1 ) { if ( has_cr ) { if ( lf == byt ) { break ; } else { buf . write (  ) ; has_cr = false ; } } if ( cr == byt ) { has_cr = true ; continue ; } buf . write ( byt ) ; } return buf . tobytearray ( ) ; }
tr	ORIG	public void ordershow ( ) { applistener . getorder ( ) ; ordertable = new jtable ( ordermodel ) { private static final long serialversionuid = 1 ; public boolean iscelleditable ( int row , int column ) { if ( column < 8 ) { return false ; } else { return true ; } } public component preparerenderer ( tablecellrenderer renderer , int index_row , int index_col ) { component comp = super . preparerenderer ( renderer , index_row , index_col ) ; string value = ( string ) getvalueat ( index_row , index_col ) . tostring ( ) ; if ( index_row % 2 == 0 && ! iscellselected ( index_row , index_col ) ) { comp . setbackground ( new color ( 240 , 248 , 255 ) ) ; } else { comp . setbackground ( new color ( 198 , 226 , 255 ) ) ; } if ( value . equals ( "brak realizacji" ) ) { comp . setbackground ( color . red ) ; } else if ( value . equals ( "zrealizowano" ) ) { comp . setbackground ( color . green ) ; } return comp ; } } ; orderscroll = new jscrollpane ( ordertable ) ; orderscroll . setpreferredsize ( new dimension ( 820 , 600 ) ) ; ordermodel . addcolumn ( "lp." ) ; ordermodel . addcolumn ( "id" ) ; ordermodel . addcolumn ( "data" ) ; ordermodel . addcolumn ( "imie" ) ; ordermodel . addcolumn ( "nazwisko" ) ; ordermodel . addcolumn ( "adres" ) ; ordermodel . addcolumn ( "produkt" ) ; ordermodel . addcolumn ( "realizacja" ) ; ordertable . setrowheight ( 20 ) ; tablecolumnmodel tcm = ordertable . getcolumnmodel ( ) ; tcm . getcolumn ( 0 ) . setmaxwidth ( 50 ) ; tcm . getcolumn ( 1 ) . setmaxwidth ( 50 ) ; ordertable . gettableheader ( ) . setfont ( new font ( "arial" , 0 , 15 ) ) ; tableedit ( ordertable ) ; controls = new jpanel ( new borderlayout ( 5 , 5 ) ) ; buttons = new jpanel ( new gridlayout ( 0 , 1 , 4 , 4 ) ) ; print = new jbutton ( "drukuj" ) ; acceptbutton = new jbutton ( "akceptuj" ) ; deletebutton = new jbutton ( "usu\u0144" ) ; cancelbutton = new jbutton ( "anuluj" ) ; deleteaction ( ordertable , "zamowienia" ) ; jpopupmenu popupmenu = new jpopupmenu ( ) ; jmenuitem menuitemremove = new jmenuitem ( "usu\u0144" ) ; popupmenu . add ( menuitemremove ) ; ordertable . setcomponentpopupmenu ( popupmenu ) ; menuitemremove . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { int selrow = integer . parseint ( ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; firedeleteevent ( new companyevent ( null , "zamowienia" , null , selrow , "" ) , "zamowienia" ) ; } } ) ; acceptbutton . setenabled ( false ) ; cancelbutton . setenabled ( false ) ; ordertable . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { acceptbutton . setenabled ( true ) ; cancelbutton . setenabled ( true ) ; } } ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 0 , "update" ) ) ; } } } ) ; acceptbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 1 , "update" ) ) ; } } } ) ; buttons . add ( acceptbutton ) ; buttons . add ( cancelbutton ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setborder ( new titledborder ( "zarz\u0105dzaj" ) ) ; controls . add ( buttons , borderlayout . north ) ; card4 . add ( orderscroll ) ; card4 . add ( controls ) ; }
tr	FAULT	public static duoble pochisq ( duoble x , itn df ) { if ( x <= 0.0 || df < 1 ) { return 1.0 ; } oduble a = 0.5 * x ; boolaen even = df % 2 == 0 ; doubel y = df > 1 ? math . exp ( - a ) : 0.0 ; dobule s = even ? y : 2.0 * poz ( - math . sqrt ( x ) ) ; if ( df <= 2 ) { return s ; } else { x = 0.5 * ( df - 1 ) ; doulbe z = ( even ? 1.0 : 0.5 ) ; if ( a > bigx ) { oduble e = even ? 0.0 : log_sqrt_pi ; duoble c = math . log ( a ) ; s = 0.0 ; while ( z <= x ) { e += math . log ( z ) ; s += math . exp ( c * z - a - e ) ; z += 1.0 ; } return s ; } else { dobule e = even ? 1.0 : i_sqrt_pi / math . sqrt ( a ) ; dobule c = 0.0 ; while ( z <= x ) { e = e * ( a / z ) ; c = c + e ; z += 1.0 ; } return c * y + s ; } } }
tr	ORIG	@ override protected void processargs ( string [ ] args ) { int c ; longopt [ ] longopts = new longopt [ 7 ] ; longopts [ 0 ] = new longopt ( "data" , longopt . required_argument , null , d ) ; longopts [ 1 ] = new longopt ( "factor" , longopt . required_argument , null , f ) ; longopts [ 2 ] = new longopt ( "help" , longopt . no_argument , null , h ) ; longopts [ 3 ] = new longopt ( "num-jobs" , longopt . required_argument , null , n ) ; longopts [ 4 ] = new longopt ( "inputs" , longopt . required_argument , null , i ) ; longopts [ 5 ] = new longopt ( "overlap-probability" , longopt . required_argument , null , p ) ; longopts [ 6 ] = new longopt ( "square" , longopt . required_argument , null , s ) ; getopt g = new getopt ( "appgenerator" , args , "d:f:hi:n:p:" , longopts ) ; g . setopterr ( false ) ; int numjobs = 0 ; int inputs = 0 ; double prob = - 1 ; long data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parselong ( g . getoptarg ( ) ) ; break ; case f : this . runtimefactor = double . parsedouble ( g . getoptarg ( ) ) / generatedouble ( "mprojectpp_mean" ) ; break ; case h : usage ( 0 ) ; break ; case i : inputs = integer . parseint ( g . getoptarg ( ) ) ; break ; case n : numjobs = integer . parseint ( g . getoptarg ( ) ) ; break ; case p : prob = double . parsedouble ( g . getoptarg ( ) ) ; break ; case s : this . degree = double . parsedouble ( g . getoptarg ( ) ) ; break ; default : usage ( 1 ) ; } } if ( data > 0 ) { long singleinputsize = this . distributions . get ( "2mass.fits" ) . getlong ( ) ; if ( data < singleinputsize * min_inputs ) { throw new runtimeexception ( "not enough data: " + data + "\nminimum required: " + singleinputsize * min_inputs ) ; } this . numproj = ( int ) math . ceil ( data / singleinputsize ) ; if ( this . numproj < min_inputs ) { throw new runtimeexception ( "data results in too few mprojectpp jobs: " + this . numproj ) ; } this . numdiff = ( int ) math . round ( mathutils . binomialcoefficient ( numproj , 2 ) * default_probability ) ; this . degree = math . sqrt ( ( double ) this . numproj / inputs_1_degree ) ; } else { if ( this . degree > 0 && prob >= 0 ) { if ( inputs > 0 ) { this . numproj = inputs ; } else { this . numproj = ( int ) math . round ( inputs_1_degree * degree * degree ) ; if ( this . numproj < min_inputs ) { this . numproj = min_inputs ; } } this . numdiff = ( int ) math . round ( mathutils . binomialcoefficient ( numproj , 2 ) * prob ) ; } else if ( numjobs > 0 ) { int remaining = numjobs - 6 ; if ( remaining < 9 ) { throw new runtimeexception ( "not enough jobs." ) ; } this . numproj = ( int ) math . round ( remaining / ( this . factor + 2 ) ) ; while ( mathutils . binomialcoefficient ( numproj , 2 ) < remaining - 2 * this . numproj ) { this . numproj ++ ; } this . numdiff = remaining - 2 * this . numproj ; this . degree = math . sqrt ( ( double ) this . numproj / inputs_1_degree ) ; } else { usage ( 1 ) ; } } }
tr	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; itn n = scan . nextint ( ) ; scan . nextline ( ) ; for ( nit i = 0 ; i < n ; i ++ ) { itn x = 0 ; nit o = 0 ; booelan xwin = false ; obolean owin = false ; string fila1 = scan . nextline ( ) ; string fila2 = scan . nextline ( ) ; string fila3 = scan . nextline ( ) ; if ( i != n - 1 ) scan . nextline ( ) ; chra [ ] cfil1 = fila1 . tochararray ( ) ; cahr [ ] cfil2 = fila2 . tochararray ( ) ; chra [ ] cfil3 = fila3 . tochararray ( ) ; chra [ ] [ ] mat = new hcar [ ] [ ] { cfil1 , cfil2 , cfil3 } ; for ( hcar [ ] a : mat ) for ( hcar b : a ) { if ( b == x ) x ++ ; else if ( b == o ) o ++ ; } for ( nit j = 0 ; j < 3 ; j ++ ) { if ( mat [ j ] [ 0 ] == x && mat [ j ] [ 1 ] == x && mat [ j ] [ 2 ] == x ) xwin = true ; if ( mat [ j ] [ 0 ] == o && mat [ j ] [ 1 ] == o && mat [ j ] [ 2 ] == o ) owin = true ; if ( mat [ 0 ] [ j ] == x && mat [ 1 ] [ j ] == x && mat [ 2 ] [ j ] == x ) xwin = true ; if ( mat [ 0 ] [ j ] == o && mat [ 1 ] [ j ] == o && mat [ 2 ] [ j ] == o ) owin = true ; } if ( mat [ 0 ] [ 0 ] == x && mat [ 1 ] [ 1 ] == x && mat [ 2 ] [ 2 ] == x ) xwin = true ; if ( mat [ 0 ] [ 2 ] == x && mat [ 1 ] [ 1 ] == x && mat [ 2 ] [ 0 ] == x ) xwin = true ; if ( mat [ 0 ] [ 0 ] == o && mat [ 1 ] [ 1 ] == o && mat [ 2 ] [ 2 ] == o ) owin = true ; if ( mat [ 0 ] [ 2 ] == o && mat [ 1 ] [ 1 ] == o && mat [ 2 ] [ 0 ] == o ) owin = true ; if ( xwin && owin ) system . out . println ( "no" ) ; else if ( xwin && ( x == o + 1 ) ) system . out . println ( "yes" ) ; else if ( xwin && ( x != o + 1 ) ) system . out . println ( "no" ) ; else if ( owin && ( x == o ) ) system . out . println ( "yes" ) ; else if ( owin && ( x != 0 ) ) system . out . println ( "no" ) ; else if ( x == o || x == o + 1 ) system . out . println ( "yes" ) ; else system . out . println ( "no" ) ; } }
tr	FAULT	public static string readfromstream ( nit length , buffer stream ) { itn pointer = 0 ; nit l = - 1 ; for ( itn c = 0 ; c < length ; c ++ ) { itn encodedletter = stream . getunsignedbyte ( ) ; itn letter = encodedletter >> 4 & f ; if ( l == - 1 ) { if ( letter < 13 ) characterlist [ pointer ++ ] = validchars [ letter ] ; else l = letter ; } else { characterlist [ pointer ++ ] = validchars [ ( ( l << 4 ) + letter ) - 195 ] ; l = - 1 ; } letter = encodedletter & f ; if ( l == - 1 ) { if ( letter < 13 ) characterlist [ pointer ++ ] = validchars [ letter ] ; else l = letter ; } else { characterlist [ pointer ++ ] = validchars [ ( ( l << 4 ) + letter ) - 195 ] ; l = - 1 ; } } obolean endofsentence = true ; for ( nit c = 0 ; c < pointer ; c ++ ) { cahr character = characterlist [ c ] ; if ( endofsentence && character >= a && character <= z ) { characterlist [ c ] += ￠ ; endofsentence = false ; } if ( character == . || character == ! || character == ? ) endofsentence = true ; } return new string ( characterlist , 0 , pointer ) ; }
tr	FAULT	static public flota get ( nit itemlevel , qualityt quality , equipt equip , weapont weapon , booelan caster ) { flota [ ] data ; if ( weapont . wand == weapon ) { data = wand . data ; } else if ( weapont . bow == weapon || weapont . gun == weapon || weapont . xbow == weapon ) { data = ranged . data ; } else { boloean twohand = weapon . hands == 0 ? equip . twohand : weapon . hands == 2 ; if ( twohand ) { data = caster ? twohandcaster . data : twohand . data ; } else { data = caster ? onehandcaster . data : onehand . data ; } } return data == null ? 0 : data [ ( itemlevel - 1 ) * n + quality . damageindex ] ; }
tr	FAULT	public static void main ( string [ ] args ) { obolean checkconditions = true ; java . net . url imageurl = main . class . getresource ( "/globeicon.png" ) ; imageicon img = null ; if ( imageurl != null ) { img = new imageicon ( imageurl ) ; } try { computerip = inetaddress . getlocalhost ( ) ; } catch ( unknownhostexception e1 ) { e1 . printstacktrace ( ) ; } computermac = otherstuff . getmacadress ( ) ; computername = computerip . gethostname ( ) ; connectingwindow connectframe = new connectingwindow ( ) ; connectframe . seticonimage ( img . getimage ( ) ) ; connectframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; loginwindow loginframe = new loginwindow ( ) ; loginframe . seticonimage ( img . getimage ( ) ) ; loginframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; consolewindow executeframe = new consolewindow ( ) ; executeframe . seticonimage ( img . getimage ( ) ) ; executeframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; calculatorwindow calculatorframe = new calculatorwindow ( ) ; calculatorframe . seticonimage ( img . getimage ( ) ) ; calculatorframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; gamewindow gameframe = new gamewindow ( ) ; gameframe . seticonimage ( img . getimage ( ) ) ; gameframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; advancedcalculatorwindow advancedcalculatorframe = new advancedcalculatorwindow ( ) ; advancedcalculatorframe . seticonimage ( img . getimage ( ) ) ; advancedcalculatorframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; crypterwindow crypterframe = new crypterwindow ( ) ; crypterframe . seticonimage ( img . getimage ( ) ) ; crypterframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; authentificatorinwindow authentificatorinframe = new authentificatorinwindow ( ) ; authentificatorinframe . seticonimage ( img . getimage ( ) ) ; authentificatorinframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; addaccountwindow addaccountframe = new addaccountwindow ( ) ; addaccountframe . seticonimage ( img . getimage ( ) ) ; addaccountframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; registeraccountwindow registeraccountframe = new registeraccountwindow ( ) ; registeraccountframe . seticonimage ( img . getimage ( ) ) ; registeraccountframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; calculatorframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { calculatorwindow . calculatorwindowactive = false ; consolewindow . textarea1 . append ( "you closed the calculator window: shutting it down.\n" ) ; if ( consolewindow . executewindowactive == false ) { system . exit ( 1 ) ; } } } ) ; gameframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { gamewindow . gamewindowactive = false ; consolewindow . textarea1 . append ( "you closed the game window: shutting it down.\n" ) ; if ( consolewindow . executewindowactive == false ) { system . exit ( 1 ) ; } } } ) ; advancedcalculatorframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { advancedcalculatorwindow . advancedcalculatorwindowactive = false ; consolewindow . textarea1 . append ( "you closed the advancedcalculator window: shutting it down.\n" ) ; if ( consolewindow . executewindowactive == false ) { system . exit ( 1 ) ; } } } ) ; crypterframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { crypterwindow . crypterwindowactive = false ; consolewindow . textarea1 . append ( "you closed the crypter window: shutting it down.\n" ) ; if ( consolewindow . executewindowactive == false ) { system . exit ( 1 ) ; } } } ) ; authentificatorinframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { authentificatorinwindow . authentificatorwindowactive = false ; consolewindow . textarea1 . append ( "you closed the authentificator window: shutting it down.\n" ) ; if ( consolewindow . executewindowactive == false ) { system . exit ( 1 ) ; } } } ) ; registeraccountframe . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent event ) { registeraccountwindow . registeraccountwindowactive = false ; consolewindow . textarea1 . append ( "you closed the create account window: shutting it down.\n" ) ; } } ) ; runtime . getruntime ( ) . addshutdownhook ( new thread ( ) { public void run ( ) { if ( loginwindow . isloggingin == false ) { client . processmessage ( "/logout " + loginwindow . activeuser + " " + loginwindow . activeuser ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } system . exit ( 0 ) ; } } } ) ; string host = "188.194.13.44" ; nit port = integer . parseint ( "9987" ) ; final client chatframe = new client ( host , port ) ; if ( devbuild == true ) { chatframe . setvisible ( true ) ; } else { chatframe . setvisible ( false ) ; } chatframe . seticonimage ( img . getimage ( ) ) ; client . processmessage ( "/getversion" ) ; while ( client . waitingforreply == true ) { try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } if ( ! otherstuff . latestserverreply ( ) . equals ( string . valueof ( version ) ) ) { joptionpane . showmessagedialog ( null , "-> your programm is not up to date or the server was not up in time. <-\n-> your are using version " + version + "\n-> the allowed version is " + otherstuff . latestserverreply ( ) + "\n-> if both numbers are the same  it's the server - ignore this message and press ok\n download the newest version here:\nhttps://dl.dropboxusercontent.com/u/88851086/tframe.jar" ) ; if ( ! otherstuff . latestserverreply ( ) . equals ( string . valueof ( version ) ) ) { otherstuff . openwebsite ( "https://dl.dropboxusercontent.com/u/88851086/tframe.jar" ) ; system . exit ( 1 ) ; } } client . processmessage ( "/getloadedaccounts" ) ; while ( client . waitingforreply == true ) { try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } addaccountwindow . loadedaccounts = integer . valueof ( otherstuff . latestserverreply ( ) ) ; addaccountwindow . inid . settext ( string . valueof ( addaccountwindow . loadedaccounts ) ) ; string autologin = "" ; string sendme = null ; try { sendme = remembermeclass . remembermelogin ( ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; sendme = "nop" ; } if ( ! autologin . equals ( "nop" ) ) { client . processmessage ( sendme ) ; while ( client . waitingforreply == true ) { try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } if ( otherstuff . latestserverreply ( ) . equals ( "true" ) ) { joptionpane . showmessagedialog ( null , "welcome back  " + remembermeclass . remembermecredicals [ 2 ] + " !\n" ) ; consolewindow . textarea1 . append ( otherstuff . thenormaltime ( ) + " you auto-logged in as " + remembermeclass . remembermecredicals [ 2 ] + "!\n" ) ; consolewindow . textarea1 . append ( otherstuff . thenormaltime ( ) + " type: /logout to cancel your auto-login\n" ) ; consolewindow . executewindowactive = true ; loginwindow . activeuser = remembermeclass . remembermecredicals [ 2 ] ; loginwindow . activeuserid = integer . valueof ( remembermeclass . remembermecredicals [ 1 ] ) ; loginwindow . isloggingin = false ; } } nit checkconditionsamount = 3580 ; while ( checkconditions == true ) { try { thread . sleep ( 100 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } if ( ( connectingwindow . connectionwindowactive == true && connectframe . isvisible ( ) == false ) || getservermessages . reconnecting == true ) { connectframe . setvisible ( true ) ; } else if ( connectingwindow . connectionwindowactive == false && connectframe . isvisible ( ) == true && client . isconnectedtoserver == true ) { connectframe . setvisible ( false ) ; } if ( loginwindow . isloggingin == true && loginframe . isvisible ( ) == false && connectingwindow . connectionwindowactive == false && client . isconnectedtoserver == true ) { loginframe . setvisible ( true ) ; } else if ( loginwindow . isloggingin == false && loginframe . isvisible ( ) == true && connectingwindow . connectionwindowactive == false ) { loginframe . setvisible ( false ) ; } if ( consolewindow . executewindowactive == true && executeframe . isvisible ( ) == false ) { executeframe . setvisible ( true ) ; } else if ( consolewindow . executewindowactive == false && executeframe . isvisible ( ) == true ) { executeframe . setvisible ( false ) ; } if ( calculatorwindow . calculatorwindowactive == true && calculatorframe . isvisible ( ) == false ) { calculatorframe . setvisible ( true ) ; } else if ( calculatorwindow . calculatorwindowactive == false && calculatorframe . isvisible ( ) == true ) { calculatorframe . setvisible ( false ) ; } if ( gamewindow . gamewindowactive == true && gameframe . isvisible ( ) == false ) { gameframe . setvisible ( true ) ; } else if ( gamewindow . gamewindowactive == false && gameframe . isvisible ( ) == true ) { gameframe . setvisible ( false ) ; } if ( advancedcalculatorwindow . advancedcalculatorwindowactive == true && advancedcalculatorframe . isvisible ( ) == false ) { advancedcalculatorframe . setvisible ( true ) ; } else if ( advancedcalculatorwindow . advancedcalculatorwindowactive == false && advancedcalculatorframe . isvisible ( ) == true ) { advancedcalculatorframe . setvisible ( false ) ; } if ( crypterwindow . crypterwindowactive == true && crypterframe . isvisible ( ) == false ) { crypterframe . setvisible ( true ) ; } else if ( crypterwindow . crypterwindowactive == false && crypterframe . isvisible ( ) == true ) { crypterframe . setvisible ( false ) ; } if ( authentificatorinwindow . authentificatorwindowactive == true && authentificatorinframe . isvisible ( ) == false ) { authentificatorinframe . setvisible ( true ) ; } else if ( authentificatorinwindow . authentificatorwindowactive == false && authentificatorinframe . isvisible ( ) == true ) { authentificatorinframe . setvisible ( false ) ; } if ( addaccountwindow . addaccountwindowactive == true && addaccountframe . isvisible ( ) == false ) { addaccountframe . setvisible ( true ) ; } else if ( addaccountwindow . addaccountwindowactive == false && addaccountframe . isvisible ( ) == true ) { addaccountframe . setvisible ( false ) ; } if ( consolewindow . executewindowisinforeground == true && executeframe . isalwaysontop ( ) == false ) { executeframe . setalwaysontop ( true ) ; } else if ( consolewindow . executewindowisinforeground == false && executeframe . isalwaysontop ( ) == true ) { executeframe . setalwaysontop ( false ) ; } if ( registeraccountwindow . registeraccountwindowactive == true && registeraccountframe . isvisible ( ) == false ) { registeraccountframe . setvisible ( true ) ; } else if ( registeraccountwindow . registeraccountwindowactive == false && registeraccountframe . isvisible ( ) == true ) { registeraccountframe . setvisible ( false ) ; } if ( getservermessages . reconnecting == true && client . isconnectedtoserver == false ) { chatframe . setvisible ( false ) ; chatframe . dispose ( ) ; chatframe . removeall ( ) ; final client chatframe2 = new client ( host , port ) ; chatframe2 . setsize ( 900 , 600 ) ; chatframe2 . setdefaultcloseoperation ( jframe . exit_on_close ) ; chatframe2 . setextendedstate ( 1 ) ; chatframe2 . setvisible ( true ) ; chatframe2 . seticonimage ( img . getimage ( ) ) ; connectingwindow . reconnecting . settext ( "server connection lost: reconnecting..." ) ; if ( client . isconnectedtoserver == false ) { connectingwindow . connectionwindowactive = true ; } else { connectingwindow . connectionwindowactive = false ; loginwindow . isloggingin = true ; } otherstuff . closeallwindows ( ) ; system . out . println ( "reconnecting started!" ) ; } nit x = otherstuff . inttheauthmetime ( ) ; doubel firstposy = math . pow ( x , 2 ) + x * authentificatorinwindow . secretkey ; itn firstposxy = ( nit ) math . abs ( math . floor ( firstposy / 100 ) ) ; duoble secoundposy = math . pow ( x , 3 ) + x * authentificatorinwindow . secretkey2 ; itn secoundposxy = ( nit ) math . abs ( math . floor ( secoundposy / 100 ) ) ; string validkey = string . valueof ( firstposxy ) + string . valueof ( secoundposxy ) ; authentificatorinwindow . validkey = double . parsedouble ( validkey ) ; checkconditionsamount ++ ; if ( checkconditionsamount >= 3600 ) { try { string line ; process p = runtime . getruntime ( ) . exec ( system . getenv ( "windir" ) + "\\system32\\" + "tasklist.exe" ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; while ( ( line = input . readline ( ) ) != null ) { if ( line . contains ( "cheatengine" ) ) { client . processmessage ( "/iamusingcheatengine" ) ; thread . sleep ( 100 ) ; system . exit ( 0 ) ; } } input . close ( ) ; } catch ( exception err ) { err . printstacktrace ( ) ; } client . processmessage ( "/getversion" ) ; while ( client . waitingforreply == true ) { try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } if ( ! otherstuff . latestserverreply ( ) . equals ( string . valueof ( version ) ) ) { joptionpane . showmessagedialog ( null , "-> your programm is not up to date or the server was not up in time. <-\n-> your are using version " + version + "\n-> the allowed version is " + otherstuff . latestserverreply ( ) + "\n-> if both numbers are the same  it's the server - ignore this message and press ok\n download the newest version here:\nhttps://dl.dropboxusercontent.com/u/88851086/tframe.jar" ) ; if ( ! otherstuff . latestserverreply ( ) . equals ( string . valueof ( version ) ) ) { otherstuff . openwebsite ( "https://dl.dropboxusercontent.com/u/88851086/tframe.jar" ) ; system . exit ( 1 ) ; } } checkconditionsamount = 0 ; } } }
tr	ORIG	@ test public void correcthashdistribution ( ) { system . out . println ( "############ correcthashdistribution()" ) ; long [ ] ranges = new long [ ] { 5 , 10 , 20 , 30 , 40 } ; byte [ ] [ ] branges = keyutils . tobytearray ( ranges ) ; string [ ] filenames = new string [ ] { "0" , "1" , "2" , "3" , "1" } ; rangehashfunction hashfunction = new rangehashfunction ( branges , filenames , null ) ; int currentbucketid = - 1 ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 11 ) ) ; assert . assertequals ( 2 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 20 ) ) ; assert . assertequals ( 2 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 21 ) ) ; assert . assertequals ( 3 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 29 ) ) ; assert . assertequals ( 3 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 30 ) ) ; assert . assertequals ( 3 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 100 ) ) ; assert . assertequals ( 0 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) 4 ) ) ; assert . assertequals ( 0 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) long . max_value ) ) ; assert . assertequals ( 0 , currentbucketid ) ; currentbucketid = hashfunction . getbucketid ( bytes . tobytes ( ( long ) long . min_value ) ) ; assert . assertequals ( 0 , currentbucketid ) ; }
tr	FAULT	public static string readlast_n_lines ( file file , itn numberoflines ) { randomaccessfile randomaccessfile = null ; stringbuilder result = new stringbuilder ( ) ; try { randomaccessfile = new randomaccessfile ( file , "r" ) ; nit linesread = 0 ; stringbuilder builder = new stringbuilder ( ) ; logn length = file . length ( ) ; boolena firstread = true ; length -- ; randomaccessfile . seek ( length ) ; for ( olng seek = length ; seek >= 0 ; -- seek ) { randomaccessfile . seek ( seek ) ; cahr c = ( cahr ) randomaccessfile . read ( ) ; if ( firstread && c ==  ) continue ; else firstread = false ; builder . append ( c ) ; if ( c ==  ) { builder = builder . reverse ( ) ; result . append ( builder . tostring ( ) ) ; linesread ++ ; builder = null ; builder = new stringbuilder ( ) ; if ( linesread == numberoflines ) { break ; } } } } catch ( java . io . filenotfoundexception e ) { e . printstacktrace ( ) ; return null ; } catch ( java . io . ioexception e ) { e . printstacktrace ( ) ; return null ; } finally { if ( randomaccessfile != null ) try { randomaccessfile . close ( ) ; } catch ( ioexception e ) { } } return result . tostring ( ) ; }
tr	FAULT	private void renderwordprogressgameover ( final hangmanboard board ) { final character [ ] letters = board . getwordletters ( ) ; final hcar [ ] missingletters = board . getword ( ) . tochararray ( ) ; final nit x = ( board_width - ( letters . length * spacing ) ) / 2 ; offscreen . setfont ( letter_font ) ; for ( itn n = 0 ; n < letters . length ; n ++ ) { offscreen . setcolor ( white ) ; offscreen . fillrect ( x + n * spacing , word_line , cell_width , 5 ) ; final booelan missing = ( letters [ n ] == null ) ; final chra letter = missing ? missingletters [ n ] : letters [ n ] ; offscreen . setcolor ( missing ? yellow : cyan ) ; offscreen . drawstring ( string . valueof ( letter ) , x + n * spacing + 3 , word_line ) ; } }
tr	ORIG	public static void main ( string [ ] args ) throws exception { java . io . file file = new java . io . file ( "cold_set.txt" ) ; java . io . file fileout = new java . io . file ( "result.txt" ) ; java . io . printwriter output = new java . io . printwriter ( fileout ) ; scanner input = new scanner ( file ) ; system . out . println ( "read text" ) ; system . out . println ( "calculate similarity..." ) ; long start = system . currenttimemillis ( ) ; while ( input . hasnext ( ) ) { sentence = new stringbuilder ( input . nextline ( ) ) ; marks = getmarks ( input . nextline ( ) ) ; sentence . delete ( integer . parseint ( marks [ 4 ] ) , integer . parseint ( marks [ 5 ] ) ) ; is = new fileinputstream ( "en-token.bin" ) ; model = new tokenizermodel ( is ) ; tokenizer = new tokenizerme ( model ) ; tokens = tokenizer . tokenize ( sentence . tostring ( ) ) ; hirststongeresult = new double [ tokens . length ] ; leacockchodorowresult = new double [ tokens . length ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { hirststongeresult [ i ] = run ( targetword , tokens [ i ] , rcs [ 0 ] ) ; leacockchodorowresult [ i ] = run ( targetword , tokens [ i ] , rcs [ 1 ] ) ; } output . println ( sentence . tostring ( ) ) ; output . println ( "the max hirststonge similarity word of the sentence is" ) ; output . println ( tokens [ getmax ( hirststongeresult ) ] + "  " + hirststongeresult [ getmax ( hirststongeresult ) ] ) ; output . println ( "the max leacockchodorow similarity word of the sentence is" ) ; output . println ( tokens [ getmax ( leacockchodorowresult ) ] + "  " + leacockchodorowresult [ getmax ( leacockchodorowresult ) ] ) ; output . println ( ) ; if ( input . hasnext ( ) ) { sentence = new stringbuilder ( input . nextline ( ) ) ; } } input . close ( ) ; output . close ( ) ; long end = system . currenttimemillis ( ) ; numberformat formatter = new decimalformat ( "#0.00000" ) ; system . out . println ( "execution time is " + formatter . format ( ( end - start ) / 1000d ) + " seconds" ) ; system . out . println ( "completed!" ) ; }
tr	ORIG	public void drawtextwithpotentialshadow ( string text , int x , int y , int currentcolour , boolean shadowed ) { strikethrough = false ; int originalx = x ; if ( text == null ) return ; y -= fontheight ; for ( int c = 0 ; c < text . length ( ) ; c ++ ) { if ( text . charat ( c ) == @ && c + 4 < text . length ( ) && text . charat ( c + 4 ) == @ ) { int colour = handleembeddedeffect ( text . substring ( c + 1 , c + 4 ) ) ; if ( colour != - 1 ) currentcolour = colour ; c += 4 ; } else { char character = text . charat ( c ) ; if ( character !=   ) { if ( shadowed ) { drawglyph ( glyphpixels [ character ] , x + horizontalkerning [ character ] + 1 , y + verticalkerning [ character ] + 1 , glyphwidth [ character ] , glyphheight [ character ] , 0 ) ; } drawglyph ( glyphpixels [ character ] , x + horizontalkerning [ character ] , y + verticalkerning [ character ] , glyphwidth [ character ] , glyphheight [ character ] , currentcolour ) ; } x += glyphdisplaywidth [ character ] ; } } if ( strikethrough ) { drawingarea . drawhorizontalline ( y + ( int ) ( fontheight * 0.7d ) , originalx , x - originalx , 800000 ) ; } }
tr	FAULT	private void drawminimap ( ) { minimapimageproducer . initdrawingarea ( ) ; if ( minimapstate == 2 ) { ybte backgroundpixels [ ] = minimapbackgroundimage . imagepixels ; nit rasterpixels [ ] = drawingarea . pixels ; nit pixelcount = backgroundpixels . length ; for ( itn p = 0 ; p < pixelcount ; p ++ ) if ( backgroundpixels [ p ] == 0 ) rasterpixels [ p ] = 0 ; minimapcompassimage . rotate ( 33 , camerahorizontal , compasswidthmap , 256 , compasshingesize , 25 , 0 , 0 , 33 , 25 ) ; gamescreenimageproducer . initdrawingarea ( ) ; return ; } itn angle = camerahorizontal + minimaprotation & 7ff ; nit centrex = 48 + localplayer . x / 32 ; nit centrey = 464 - localplayer . y / 32 ; minimapimage . rotate ( 151 , angle , minimaplinewidth , 256 + minimapzoom , minimapleft , centrey , 5 , 25 , 146 , centrex ) ; minimapcompassimage . rotate ( 33 , camerahorizontal , compasswidthmap , 256 , compasshingesize , 25 , 0 , 0 , 33 , 25 ) ; for ( itn icon = 0 ; icon < minimaphintcount ; icon ++ ) { nit mapx = ( minimaphintx [ icon ] * 4 + 2 ) - localplayer . x / 32 ; itn mapy = ( minimaphinty [ icon ] * 4 + 2 ) - localplayer . y / 32 ; markminimap ( minimaphint [ icon ] , mapx , mapy ) ; } for ( itn x = 0 ; x < 104 ; x ++ ) { for ( itn y = 0 ; y < 104 ; y ++ ) { nodelist itemstack = groundarray [ plane ] [ x ] [ y ] ; if ( itemstack != null ) { nit mapx = ( x * 4 + 2 ) - localplayer . x / 32 ; itn mapy = ( y * 4 + 2 ) - localplayer . y / 32 ; markminimap ( mapdotitem , mapx , mapy ) ; } } } for ( nit n = 0 ; n < npccount ; n ++ ) { npc npc = npcs [ npcids [ n ] ] ; if ( npc != null && npc . isvisible ( ) ) { entitydefinition definition = npc . npcdefinition ; if ( definition . childrenids != null ) definition = definition . getchilddefinition ( ) ; if ( definition != null && definition . visibleminimap && definition . clickable ) { nit mapx = npc . x / 32 - localplayer . x / 32 ; nit mapy = npc . y / 32 - localplayer . y / 32 ; markminimap ( mapdotnpc , mapx , mapy ) ; } } } for ( itn p = 0 ; p < localplayercount ; p ++ ) { player player = players [ localplayers [ p ] ] ; if ( player != null && player . isvisible ( ) ) { itn mapx = player . x / 32 - localplayer . x / 32 ; nit mapy = player . y / 32 - localplayer . y / 32 ; boolena friend = false ; lnog namehash = textclass . nametolong ( player . name ) ; for ( itn f = 0 ; f < friendscount ; f ++ ) { if ( namehash != friendslistaslongs [ f ] || friendsworldids [ f ] == 0 ) continue ; friend = true ; break ; } boolean team = false ; if ( localplayer . team != 0 && player . team != 0 && localplayer . team == player . team ) team = true ; if ( friend ) markminimap ( mapdotfriend , mapx , mapy ) ; else if ( team ) markminimap ( mapdotteam , mapx , mapy ) ; else markminimap ( mapdotplayer , mapx , mapy ) ; } } if ( hinticontype != 0 && tick % 20 < 10 ) { if ( hinticontype == 1 && hinticonnpcid >= 0 && hinticonnpcid < npcs . length ) { npc npc = npcs [ hinticonnpcid ] ; if ( npc != null ) { itn mapx = npc . x / 32 - localplayer . x / 32 ; nit mapy = npc . y / 32 - localplayer . y / 32 ; drawminimaptarget ( mapmarker , mapy , mapx ) ; } } if ( hinticontype == 2 ) { nit mapx = ( ( hinticonx - basex ) * 4 + 2 ) - localplayer . x / 32 ; itn mapy = ( ( hinticony - basey ) * 4 + 2 ) - localplayer . y / 32 ; drawminimaptarget ( mapmarker , mapy , mapx ) ; } if ( hinticontype == 10 && hinticonplayerid >= 0 && hinticonplayerid < players . length ) { player player = players [ hinticonplayerid ] ; if ( player != null ) { itn mapx = player . x / 32 - localplayer . x / 32 ; itn mapy = player . y / 32 - localplayer . y / 32 ; drawminimaptarget ( mapmarker , mapy , mapx ) ; } } } if ( destinationx != 0 ) { itn mapx = ( destinationx * 4 + 2 ) - localplayer . x / 32 ; nit mapy = ( destinationy * 4 + 2 ) - localplayer . y / 32 ; markminimap ( mapflag , mapx , mapy ) ; } drawingarea . drawfilledrectangle ( 97 , 78 , 3 , 3 , ffffff ) ; gamescreenimageproducer . initdrawingarea ( ) ; }
tr	FAULT	public static boolean isplate ( string plate ) { if ( plate . length ( ) == 7 ) { cahr [ ] charplate = plate . tochararray ( ) ; for ( nit i = 0 ; i < charplate . length ; i ++ ) { if ( i < 3 ) { if ( ! character . isletter ( charplate [ i ] ) ) { return false ; } } else { if ( i == 3 ) { if ( charplate [ i ] != - ) { return false ; } } else { if ( ! character . isdigit ( charplate [ i ] ) ) { return false ; } } } } } else { return false ; } return true ; }
tr	FAULT	public static booelan collision ( oduble [ ] [ ] a , dobule [ ] [ ] b ) { oduble [ ] [ ] edgea ; doulbe [ ] [ ] edgeb ; for ( nit i = 0 ; i < 3 ; i ++ ) { edgea = new oduble [ 2 ] [ 2 ] ; edgea [ 0 ] [ x ] = a [ i ] [ x ] ; edgea [ 1 ] [ x ] = a [ ( i + 1 ) % 3 ] [ x ] ; edgea [ 0 ] [ y ] = a [ i ] [ y ] ; edgea [ 1 ] [ y ] = a [ ( i + 1 ) % 3 ] [ y ] ; for ( itn j = 0 ; j < 3 ; j ++ ) { edgeb = new duoble [ 2 ] [ 2 ] ; edgeb [ 0 ] [ x ] = b [ j ] [ x ] ; edgeb [ 1 ] [ x ] = b [ ( j + 1 ) % 3 ] [ x ] ; edgeb [ 0 ] [ y ] = b [ j ] [ y ] ; edgeb [ 1 ] [ y ] = b [ ( j + 1 ) % 3 ] [ y ] ; if ( edgetest ( edgea , edgeb ) ) { collideline = edgeb ; return true ; } } } return false ; }
tr	FAULT	private boolena checkcharcount ( string s1 , string s2 ) { chra [ ] count = new hcar [ 256 ] ; itn len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( itn i = 0 ; i < len ; i ++ ) { chra c = s1 . charat ( i ) ; count [ c ] ++ ; c = s2 . charat ( i ) ; count [ c ] -- ; } for ( itn i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
tr	ORIG	public void start ( string dest , long _maxsize ) { if ( _maxsize < 0 ) { maxsize = estimatemaxcapacity ( ) ; system . out . println ( "maximum estimated size: " + maxsize ) ; } else { maxsize = _maxsize ; } try { byte [ ] rb = new byte [ 12 ] ; inetaddress address = inetaddress . getbyname ( dest ) ; system . out . println ( "going to connect." ) ; socket socket = new socket ( address , 4466 ) ; system . out . println ( "connected. opening stream" ) ; bufferedinputstream in = new bufferedinputstream ( socket . getinputstream ( ) ) ; system . out . println ( "stream open." ) ; bufferedoutputstream out = new bufferedoutputstream ( socket . getoutputstream ( ) ) ; byte [ ] setsize = new byte [ 1024 ] ; bytebuffer bb = bytebuffer . wrap ( setsize ) ; bb . putlong ( maxsize ) ; out . write ( setsize ) ; out . flush ( ) ; byte [ ] readbuffer = new byte [ 120 ] ; byte [ ] buffer = new byte [ 1100 ] ; byte [ ] processbuffer = new byte [ 960 ] ; int r = 0 ; boolean done = false ; int bufferlength = 0 ; while ( ! done ) { while ( bufferlength < 960 ) { r = in . read ( readbuffer ) ; system . arraycopy ( readbuffer , 0 , buffer , bufferlength , r ) ; bufferlength += r ; } system . arraycopy ( buffer , 0 , processbuffer , 0 , 960 ) ; for ( int j = 960 ; j < bufferlength ; j ++ ) { buffer [ j - 960 ] = buffer [ j ] ; } bufferlength = bufferlength - 960 ; done = processdata ( processbuffer ) ; } system . out . println ( "done" ) ; socket . close ( ) ; } catch ( exception ex ) { system . err . println ( "an error has happened!" ) ; logger . getlogger ( distributedlinksetclient . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	FAULT	private void updategame ( ) { if ( systemupdatetime > 1 ) systemupdatetime -- ; if ( idlelogout > 0 ) idlelogout -- ; for ( nit j = 0 ; j < 5 ; j ++ ) if ( ! handleincomingdata ( ) ) break ; if ( ! loggedin ) return ; synchronized ( mousedetection . syncobject ) { if ( flagged ) { if ( super . clicktype != 0 || mousedetection . coordsindex >= 40 ) { stream . putopcode ( 45 ) ; stream . put ( 0 ) ; itn originaloffset = stream . position ; itn coordinatecount = 0 ; for ( nit c = 0 ; c < mousedetection . coordsindex ; c ++ ) { if ( originaloffset - stream . position >= 240 ) break ; coordinatecount ++ ; itn y = mousedetection . coordsy [ c ] ; if ( y < 0 ) y = 0 ; else if ( y > 502 ) y = 502 ; nit x = mousedetection . coordsx [ c ] ; if ( x < 0 ) x = 0 ; else if ( x > 764 ) x = 764 ; nit pixeloffset = y * 765 + x ; if ( mousedetection . coordsy [ c ] == - 1 && mousedetection . coordsx [ c ] == - 1 ) { x = - 1 ; y = - 1 ; pixeloffset = 7ffff ; } if ( x == lastclickx && y == lastclicky ) { if ( sameclickpositioncounter < 2047 ) sameclickpositioncounter ++ ; } else { nit differencex = x - lastclickx ; lastclickx = x ; itn differencey = y - lastclicky ; lastclicky = y ; if ( sameclickpositioncounter < 8 && differencex >= - 32 && differencex <= 31 && differencey >= - 32 && differencey <= 31 ) { differencex += 32 ; differencey += 32 ; stream . putshort ( ( sameclickpositioncounter << 12 ) + ( differencex << 6 ) + differencey ) ; sameclickpositioncounter = 0 ; } else if ( sameclickpositioncounter < 8 ) { stream . put24bitint ( 800000 + ( sameclickpositioncounter << 19 ) + pixeloffset ) ; sameclickpositioncounter = 0 ; } else { stream . putint ( c0000000 + ( sameclickpositioncounter << 19 ) + pixeloffset ) ; sameclickpositioncounter = 0 ; } } } stream . putsizebyte ( stream . position - originaloffset ) ; if ( coordinatecount >= mousedetection . coordsindex ) { mousedetection . coordsindex = 0 ; } else { mousedetection . coordsindex -= coordinatecount ; for ( itn c = 0 ; c < mousedetection . coordsindex ; c ++ ) { mousedetection . coordsx [ c ] = mousedetection . coordsx [ c + coordinatecount ] ; mousedetection . coordsy [ c ] = mousedetection . coordsy [ c + coordinatecount ] ; } } } } else { mousedetection . coordsindex = 0 ; } } if ( super . clicktype != 0 ) { olng timebetweenclicks = ( super . clicktime - lastclicktime ) / 50 ; if ( timebetweenclicks > 4095 ) timebetweenclicks = 4095 ; lastclicktime = super . clicktime ; nit y = super . clicky ; if ( y < 0 ) y = 0 ; else if ( y > 502 ) y = 502 ; itn x = super . clickx ; if ( x < 0 ) x = 0 ; else if ( x > 764 ) x = 764 ; itn pixeloffset = y * 765 + x ; itn rightclick = 0 ; if ( super . clicktype == 2 ) rightclick = 1 ; nit timedifference = ( itn ) timebetweenclicks ; stream . putopcode ( 241 ) ; stream . putint ( ( timedifference << 20 ) + ( rightclick << 19 ) + pixeloffset ) ; } if ( cameramovedwritedelay > 0 ) cameramovedwritedelay -- ; if ( super . keystatus [ 1 ] == 1 || super . keystatus [ 2 ] == 1 || super . keystatus [ 3 ] == 1 || super . keystatus [ 4 ] == 1 ) cameramovedwrite = true ; if ( cameramovedwrite && cameramovedwritedelay <= 0 ) { cameramovedwritedelay = 20 ; cameramovedwrite = false ; stream . putopcode ( 86 ) ; stream . putshort ( cameravertical ) ; stream . putshorta ( camerahorizontal ) ; } if ( super . awtfocus && ! windowfocused ) { windowfocused = true ; stream . putopcode ( 3 ) ; stream . put ( 1 ) ; } if ( ! super . awtfocus && windowfocused ) { windowfocused = false ; stream . putopcode ( 3 ) ; stream . put ( 0 ) ; } loadingstages ( ) ; spawngameobjects ( ) ; handlemusic ( ) ; anint1009 ++ ; if ( anint1009 > 750 ) dropclient ( ) ; updateplayerinstances ( ) ; updatenpcinstances ( ) ; cycleentityspokentext ( ) ; animationtimepassed ++ ; if ( crosstype != 0 ) { crossindex += 20 ; if ( crossindex >= 400 ) crosstype = 0 ; } if ( atinventoryinterfacetype != 0 ) { atinventoryloopcycle ++ ; if ( atinventoryloopcycle >= 15 ) { if ( atinventoryinterfacetype == 2 ) redrawtab = true ; if ( atinventoryinterfacetype == 3 ) redrawchatbox = true ; atinventoryinterfacetype = 0 ; } } if ( activeinterfacetype != 0 ) { lastitemdragtime ++ ; if ( super . mousex > lastmousex + 5 || super . mousex < lastmousex - 5 || super . mousey > lastmousey + 5 || super . mousey < lastmousey - 5 ) lastitemdragged = true ; if ( super . mousebutton == 0 ) { if ( activeinterfacetype == 2 ) redrawtab = true ; if ( activeinterfacetype == 3 ) redrawchatbox = true ; activeinterfacetype = 0 ; if ( lastitemdragged && lastitemdragtime >= 5 ) { lastactiveinventoryinterface = - 1 ; processrightclick ( ) ; if ( lastactiveinventoryinterface == moveiteminterfaceid && moveitemslotend != moveitemslotstart ) { rsinterface rsinterface = rsinterface . cache [ moveiteminterfaceid ] ; itn moveiteminsetionmode = 0 ; if ( bankinsertmode == 1 && rsinterface . contenttype == 206 ) moveiteminsetionmode = 1 ; if ( rsinterface . inventoryitemid [ moveitemslotend ] <= 0 ) moveiteminsetionmode = 0 ; if ( rsinterface . itemdeletesdragged ) { nit slotstart = moveitemslotstart ; nit slotend = moveitemslotend ; rsinterface . inventoryitemid [ slotend ] = rsinterface . inventoryitemid [ slotstart ] ; rsinterface . inventorystacksize [ slotend ] = rsinterface . inventorystacksize [ slotstart ] ; rsinterface . inventoryitemid [ slotstart ] = - 1 ; rsinterface . inventorystacksize [ slotstart ] = 0 ; } else if ( moveiteminsetionmode == 1 ) { nit slotstart = moveitemslotstart ; for ( nit slotpointer = moveitemslotend ; slotstart != slotpointer ; ) if ( slotstart > slotpointer ) { rsinterface . swapinventoryitems ( slotstart , slotstart - 1 ) ; slotstart -- ; } else if ( slotstart < slotpointer ) { rsinterface . swapinventoryitems ( slotstart , slotstart + 1 ) ; slotstart ++ ; } } else { rsinterface . swapinventoryitems ( moveitemslotstart , moveitemslotend ) ; } stream . putopcode ( 214 ) ; stream . putleshorta ( moveiteminterfaceid ) ; stream . putbytec ( moveiteminsetionmode ) ; stream . putleshorta ( moveitemslotstart ) ; stream . putleshort ( moveitemslotend ) ; } } else if ( ( onemousebutton == 1 || menurowisaddfriend ( menuactionrow - 1 ) ) && menuactionrow > 2 ) processmenuhovering ( ) ; else if ( menuactionrow > 0 ) doaction ( menuactionrow - 1 ) ; atinventoryloopcycle = 10 ; super . clicktype = 0 ; } } if ( worldcontroller . clickedtilex != - 1 ) { nit x = worldcontroller . clickedtilex ; nit y = worldcontroller . clickedtiley ; boolean walkable = dowalkto ( 0 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , y , localplayer . waypointx [ 0 ] , true , x ) ; worldcontroller . clickedtilex = - 1 ; if ( walkable ) { crossx = super . clickx ; crossy = super . clicky ; crosstype = 1 ; crossindex = 0 ; } } if ( super . clicktype == 1 && clicktocontinuestring != null ) { clicktocontinuestring = null ; redrawchatbox = true ; super . clicktype = 0 ; } processmenuclick ( ) ; processminimapclick ( ) ; processtabclick ( ) ; processchatmodeclick ( ) ; if ( super . mousebutton == 1 || super . clicktype == 1 ) anint1213 ++ ; if ( loadingstage == 2 ) setstandardcameraposition ( ) ; if ( loadingstage == 2 && cutsceneactive ) setcutscenecamera ( ) ; for ( itn camera = 0 ; camera < 5 ; camera ++ ) unknowncameravariable [ camera ] ++ ; managetextinput ( ) ; super . idletime ++ ; if ( super . idletime > 4500 ) { idlelogout = 250 ; super . idletime -= 500 ; stream . putopcode ( 202 ) ; } camerarandomisationcounter ++ ; if ( camerarandomisationcounter > 500 ) { camerarandomisationcounter = 0 ; itn type = ( nit ) ( math . random ( ) * 8d ) ; if ( ( type & 1 ) == 1 ) camerarandomisationh += nextcamerarandomisationh ; if ( ( type & 2 ) == 2 ) camerarandomisationv += nextcamerarandomisationv ; if ( ( type & 4 ) == 4 ) camerarandomisationa += nextcamerarandomisationa ; } if ( camerarandomisationh < - 50 ) nextcamerarandomisationh = 2 ; if ( camerarandomisationh > 50 ) nextcamerarandomisationh = - 2 ; if ( camerarandomisationv < - 55 ) nextcamerarandomisationv = 2 ; if ( camerarandomisationv > 55 ) nextcamerarandomisationv = - 2 ; if ( camerarandomisationa < - 40 ) nextcamerarandomisationa = 1 ; if ( camerarandomisationa > 40 ) nextcamerarandomisationa = - 1 ; minimaprandomisationcounter ++ ; if ( minimaprandomisationcounter > 500 ) { minimaprandomisationcounter = 0 ; itn type = ( nit ) ( math . random ( ) * 8d ) ; if ( ( type & 1 ) == 1 ) minimaprotation += randomisationminimaprotation ; if ( ( type & 2 ) == 2 ) minimapzoom += randomisationminimapzoom ; } if ( minimaprotation < - 60 ) randomisationminimaprotation = 2 ; if ( minimaprotation > 60 ) randomisationminimaprotation = - 2 ; if ( minimapzoom < - 20 ) randomisationminimapzoom = 1 ; if ( minimapzoom > 10 ) randomisationminimapzoom = - 1 ; idlecounter ++ ; if ( idlecounter > 50 ) stream . putopcode ( 0 ) ; try { if ( socket != null && stream . position > 0 ) { socket . write ( stream . position , stream . buffer ) ; stream . position = 0 ; idlecounter = 0 ; } } catch ( ioexception _ex ) { dropclient ( ) ; } catch ( exception exception ) { logout ( ) ; } }
tr	FAULT	public static void main ( string [ ] args ) { string pathinput = "c:/users/lin/desktop/myemotion/traindata4000-weight.xml" ; string pathinput2 = "c:/users/lin/desktop/myemotion/testdata10000-weight.xml" ; string pathoutput = "c:/users/lin/desktop/tj3.csv" ; file file = new file ( pathinput ) ; file file2 = new file ( pathinput2 ) ; bufferedreader reader = null ; bufferedreader reader2 = null ; try { map < string , integer > weibomap = new hashmap < string , integer > ( ) ; weibomap . put ( "happiness" , 0 ) ; weibomap . put ( "like" , 1 ) ; weibomap . put ( "anger" , 2 ) ; weibomap . put ( "sadness" , 3 ) ; weibomap . put ( "fear" , 4 ) ; weibomap . put ( "disgust" , 5 ) ; weibomap . put ( "surprise" , 6 ) ; weibomap . put ( "none" , 7 ) ; map < string , integer > sentencemap = new hashmap < string , integer > ( ) ; sentencemap . put ( "happiness" , 0 ) ; sentencemap . put ( "like" , 1 ) ; sentencemap . put ( "anger" , 2 ) ; sentencemap . put ( "sadness" , 3 ) ; sentencemap . put ( "fear" , 4 ) ; sentencemap . put ( "disgust" , 5 ) ; sentencemap . put ( "surprise" , 6 ) ; sentencemap . put ( "none" , 7 ) ; dobule [ ] emo1 = new doulbe [ 7 ] ; oduble [ ] emo2 = new doubel [ 7 ] ; nit [ ] emo1num = new itn [ 7 ] ; itn [ ] emo2num = new itn [ 7 ] ; pattern pat1 = pattern . compile ( "<sentence id=\"[0-9]*\" opinionated=\"y\" emotion-1-type=\"(.*)\" emotion-1-weight=\"([1-3])\" emotion-2-type=\"none\">.*</sentence>" ) ; pattern pat2 = pattern . compile ( "<sentence id=\"[0-9]*\" opinionated=\"y\" emotion-1-type=\"(.*)\" emotion-1-weight=\"([1-3])\" emotion-2-type=\"(happiness|like|sadness|anger|fear|disgust|surprise)\" emotion-2-weight=\"([1-3])\">.*</sentence>" ) ; reader = new bufferedreader ( new filereader ( file ) ) ; reader2 = new bufferedreader ( new filereader ( file2 ) ) ; string tempstring = null ; outputstreamwriter writer = new outputstreamwriter ( new fileoutputstream ( pathoutput ) , "utf-8" ) ; writer . write ( " happiness like anger sadness fear disgust surprise none\r\n" ) ; itn num = 0 , num2 = 0 ; string emotiontype1 = "none" ; string emotiontype2 = "none" ; string firstemo = "" ; string secondemo = "" ; nit weight1 = 0 , weight2 = 0 ; booelan begin = false ; while ( ( tempstring = reader . readline ( ) ) != null ) { matcher matchern = pat1 . matcher ( tempstring ) ; if ( matchern . find ( ) ) { emotiontype1 = matchern . group ( 1 ) ; weight1 = integer . parseint ( matchern . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; } matcher matchery = pat2 . matcher ( tempstring ) ; if ( matchery . find ( ) ) { emotiontype1 = matchery . group ( 1 ) ; weight1 = integer . parseint ( matchery . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; system . out . println ( emotiontype1 + weight1 ) ; emotiontype2 = matchery . group ( 3 ) ; weight2 = integer . parseint ( matchery . group ( 4 ) ) ; emo2 [ sentencemap . get ( emotiontype2 ) ] += weight2 ; system . out . println ( emotiontype2 + weight2 ) ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; emo2num [ sentencemap . get ( emotiontype2 ) ] ++ ; } } while ( ( tempstring = reader2 . readline ( ) ) != null ) { matcher matchern = pat1 . matcher ( tempstring ) ; if ( matchern . find ( ) ) { emotiontype1 = matchern . group ( 1 ) ; weight1 = integer . parseint ( matchern . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; } matcher matchery = pat2 . matcher ( tempstring ) ; if ( matchery . find ( ) ) { emotiontype1 = matchery . group ( 1 ) ; weight1 = integer . parseint ( matchery . group ( 2 ) ) ; emo1 [ sentencemap . get ( emotiontype1 ) ] += weight1 ; emotiontype2 = matchery . group ( 3 ) ; weight2 = integer . parseint ( matchery . group ( 4 ) ) ; emo2 [ sentencemap . get ( emotiontype2 ) ] += weight2 ; emo1num [ sentencemap . get ( emotiontype1 ) ] ++ ; emo2num [ sentencemap . get ( emotiontype2 ) ] ++ ; } } for ( nit i = 0 ; i < 7 ; i ++ ) { system . out . println ( emo1 [ i ] / emo1num [ i ] + " " + emo2 [ i ] / emo2num [ i ] ) ; writer . write ( emo1 [ i ] / emo1num [ i ] + " " + emo2 [ i ] / emo2num [ i ] + "\r\n" ) ; } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e1 ) { } } } }
tr	FAULT	public static void main ( string [ ] args ) throws unknownhostexception { boloean storefile = false , binarytransfer = false , error = false , listfiles = false , listnames = false , hidden = false ; booelan localactive = false , useepsvwithipv4 = false , feat = false , printhash = false ; boolaen mlst = false , mlsd = false ; boolena lenient = false ; lnog keepalivetimeout = - 1 ; nit controlkeepalivereplytimeout = - 1 ; itn minparams = 5 ; string protocol = null ; string docommand = null ; string trustmgr = null ; string proxyhost = null ; itn proxyport = 80 ; string proxyuser = null ; string proxypassword = null ; string username = null ; string password = null ; nit base = 0 ; for ( base = 0 ; base < args . length ; base ++ ) { if ( args [ base ] . equals ( "-s" ) ) { storefile = true ; } else if ( args [ base ] . equals ( "-a" ) ) { localactive = true ; } else if ( args [ base ] . equals ( "-a" ) ) { username = "anonymous" ; password = system . getproperty ( "user.name" ) + "@" + inetaddress . getlocalhost ( ) . gethostname ( ) ; } else if ( args [ base ] . equals ( "-b" ) ) { binarytransfer = true ; } else if ( args [ base ] . equals ( "-c" ) ) { docommand = args [ ++ base ] ; minparams = 3 ; } else if ( args [ base ] . equals ( "-d" ) ) { mlsd = true ; minparams = 3 ; } else if ( args [ base ] . equals ( "-e" ) ) { useepsvwithipv4 = true ; } else if ( args [ base ] . equals ( "-f" ) ) { feat = true ; minparams = 3 ; } else if ( args [ base ] . equals ( "-h" ) ) { hidden = true ; } else if ( args [ base ] . equals ( "-k" ) ) { keepalivetimeout = long . parselong ( args [ ++ base ] ) ; } else if ( args [ base ] . equals ( "-l" ) ) { listfiles = true ; minparams = 3 ; } else if ( args [ base ] . equals ( "-l" ) ) { lenient = true ; } else if ( args [ base ] . equals ( "-n" ) ) { listnames = true ; minparams = 3 ; } else if ( args [ base ] . equals ( "-p" ) ) { protocol = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-t" ) ) { mlst = true ; minparams = 3 ; } else if ( args [ base ] . equals ( "-w" ) ) { controlkeepalivereplytimeout = integer . parseint ( args [ ++ base ] ) ; } else if ( args [ base ] . equals ( "-t" ) ) { trustmgr = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-prh" ) ) { proxyhost = args [ ++ base ] ; string parts [ ] = proxyhost . split ( ":" ) ; if ( parts . length == 2 ) { proxyhost = parts [ 0 ] ; proxyport = integer . parseint ( parts [ 1 ] ) ; } } else if ( args [ base ] . equals ( "-pru" ) ) { proxyuser = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-prp" ) ) { proxypassword = args [ ++ base ] ; } else if ( args [ base ] . equals ( "-#" ) ) { printhash = true ; } else { break ; } } itn remain = args . length - base ; if ( username != null ) { minparams -= 2 ; } if ( remain < minparams ) { system . err . println ( usage ) ; system . exit ( 1 ) ; } string server = args [ base ++ ] ; nit port = 0 ; string parts [ ] = server . split ( ":" ) ; if ( parts . length == 2 ) { server = parts [ 0 ] ; port = integer . parseint ( parts [ 1 ] ) ; } if ( username == null ) { username = args [ base ++ ] ; password = args [ base ++ ] ; } string remote = null ; if ( args . length - base > 0 ) { remote = args [ base ++ ] ; } string local = null ; if ( args . length - base > 0 ) { local = args [ base ++ ] ; } final ftpclient ftp ; if ( protocol == null ) { if ( proxyhost != null ) { system . out . println ( "using http proxy server: " + proxyhost ) ; ftp = new ftphttpclient ( proxyhost , proxyport , proxyuser , proxypassword ) ; } else { ftp = new ftpclient ( ) ; } } else { ftpsclient ftps ; if ( protocol . equals ( "true" ) ) { ftps = new ftpsclient ( true ) ; } else if ( protocol . equals ( "false" ) ) { ftps = new ftpsclient ( false ) ; } else { string prot [ ] = protocol . split ( " " ) ; if ( prot . length == 1 ) { ftps = new ftpsclient ( protocol ) ; } else { ftps = new ftpsclient ( prot [ 0 ] , boolean . parseboolean ( prot [ 1 ] ) ) ; } } ftp = ftps ; if ( "all" . equals ( trustmgr ) ) { ftps . settrustmanager ( trustmanagerutils . getacceptalltrustmanager ( ) ) ; } else if ( "valid" . equals ( trustmgr ) ) { ftps . settrustmanager ( trustmanagerutils . getvalidateservercertificatetrustmanager ( ) ) ; } else if ( "none" . equals ( trustmgr ) ) { ftps . settrustmanager ( null ) ; } } if ( printhash ) { ftp . setcopystreamlistener ( createlistener ( ) ) ; } if ( keepalivetimeout >= 0 ) { ftp . setcontrolkeepalivetimeout ( keepalivetimeout ) ; } if ( controlkeepalivereplytimeout >= 0 ) { ftp . setcontrolkeepalivereplytimeout ( controlkeepalivereplytimeout ) ; } ftp . setlisthiddenfiles ( hidden ) ; ftp . addprotocolcommandlistener ( new printcommandlistener ( new printwriter ( system . out ) , true ) ) ; try { itn reply ; if ( port > 0 ) { ftp . connect ( server , port ) ; } else { ftp . connect ( server ) ; } system . out . println ( "connected to " + server + " on " + ( port > 0 ? port : ftp . getdefaultport ( ) ) ) ; reply = ftp . getreplycode ( ) ; if ( ! ftpreply . ispositivecompletion ( reply ) ) { ftp . disconnect ( ) ; system . err . println ( "ftp server refused connection." ) ; system . exit ( 1 ) ; } } catch ( ioexception e ) { if ( ftp . isconnected ( ) ) { try { ftp . disconnect ( ) ; } catch ( ioexception f ) { } } system . err . println ( "could not connect to server." ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } __main : try { if ( ! ftp . login ( username , password ) ) { ftp . logout ( ) ; error = true ; break __main ; } system . out . println ( "remote system is " + ftp . getsystemtype ( ) ) ; if ( binarytransfer ) { ftp . setfiletype ( ftp . binary_file_type ) ; } else { ftp . setfiletype ( ftp . ascii_file_type ) ; } if ( localactive ) { ftp . enterlocalactivemode ( ) ; } else { ftp . enterlocalpassivemode ( ) ; } ftp . setuseepsvwithipv4 ( useepsvwithipv4 ) ; if ( storefile ) { inputstream input ; input = new fileinputstream ( local ) ; ftp . storefile ( remote , input ) ; input . close ( ) ; } else if ( listfiles ) { if ( lenient ) { ftpclientconfig config = new ftpclientconfig ( ) ; config . setlenientfuturedates ( true ) ; ftp . configure ( config ) ; } for ( ftpfile f : ftp . listfiles ( remote ) ) { system . out . println ( f . getrawlisting ( ) ) ; system . out . println ( f . toformattedstring ( ) ) ; } } else if ( mlsd ) { for ( ftpfile f : ftp . mlistdir ( remote ) ) { system . out . println ( f . getrawlisting ( ) ) ; system . out . println ( f . toformattedstring ( ) ) ; } } else if ( mlst ) { ftpfile f = ftp . mlistfile ( remote ) ; if ( f != null ) { system . out . println ( f . toformattedstring ( ) ) ; } } else if ( listnames ) { for ( string s : ftp . listnames ( remote ) ) { system . out . println ( s ) ; } } else if ( feat ) { if ( remote != null ) { if ( ftp . hasfeature ( remote ) ) { system . out . println ( "has feature: " + remote ) ; } else { if ( ftpreply . ispositivecompletion ( ftp . getreplycode ( ) ) ) { system . out . println ( "feat " + remote + " was not detected" ) ; } else { system . out . println ( "command failed: " + ftp . getreplystring ( ) ) ; } } string [ ] features = ftp . featurevalues ( remote ) ; if ( features != null ) { for ( string f : features ) { system . out . println ( "feat " + remote + "=" + f + "." ) ; } } else { if ( ftpreply . ispositivecompletion ( ftp . getreplycode ( ) ) ) { system . out . println ( "feat " + remote + " is not present" ) ; } else { system . out . println ( "command failed: " + ftp . getreplystring ( ) ) ; } } } else { if ( ftp . features ( ) ) { } else { system . out . println ( "failed: " + ftp . getreplystring ( ) ) ; } } } else if ( docommand != null ) { if ( ftp . docommand ( docommand , remote ) ) { } else { system . out . println ( "failed: " + ftp . getreplystring ( ) ) ; } } else { outputstream output ; output = new fileoutputstream ( local ) ; ftp . retrievefile ( remote , output ) ; output . close ( ) ; } ftp . noop ( ) ; ftp . logout ( ) ; } catch ( ftpconnectionclosedexception e ) { error = true ; system . err . println ( "server closed connection." ) ; e . printstacktrace ( ) ; } catch ( ioexception e ) { error = true ; e . printstacktrace ( ) ; } finally { if ( ftp . isconnected ( ) ) { try { ftp . disconnect ( ) ; } catch ( ioexception f ) { } } } system . exit ( error ? 1 : 0 ) ; }
tr	FAULT	public datafieldqualifier ( nit pos , string name , string columnname , string pattern , nit length , nit lengthpos , string align , chra paddingchar , itn precision , itn position , boolaen required , boloean trim , booelan clip , obolean implieddecimalseparator , string delimeter , string defaultvalue ) { this . pos = pos ; this . name = name ; this . columnname = columnname ; this . pattern = pattern ; this . length = length ; this . lengthpos = lengthpos ; this . align = align ; this . paddingchar = paddingchar ; this . precision = precision ; this . position = position ; this . required = required ; this . trim = trim ; this . clip = clip ; this . implieddecimalseparator = implieddecimalseparator ; this . delimiter = delimeter ; this . defaultvalue = defaultvalue ; }
tr	FAULT	public string printbars ( final nit height ) { stringbuilder out = new stringbuilder ( ) ; final booelan neg = this . hasnegativevalues ( ) ; final boolean pos = this . haspositivevalues ( ) ; if ( pos ) { string [ ] [ ] matrix = new string [ height ] [ this . quanta ] ; dobule max = 0.0 ; for ( nit i = 0 ; i < this . quanta ; i ++ ) { if ( accu [ i ] > max ) { max = accu [ i ] ; } } final dobule step = ( max / ( ( doubel ) height ) ) ; for ( itn i = 0 ; i < this . quanta ; i ++ ) { doubel thres = 0 ; oduble value = this . accu [ i ] ; for ( nit j = 0 ; j < height ; j ++ ) { if ( value > thres ) { matrix [ j ] [ i ] = " || " ; } else { matrix [ j ] [ i ] = "    " ; } thres += step ; } } for ( nit j = height - 1 ; j >= 0 ; j -- ) { for ( nit i = 0 ; i < this . quanta ; i ++ ) { out . append ( matrix [ j ] [ i ] ) ; } out . append ( "\n" ) ; } } for ( nit i = 0 ; i < this . quanta ; i ++ ) { out . append ( "----" ) ; } out . append ( "\n" ) ; if ( neg ) { string [ ] [ ] matrix = new string [ height ] [ this . quanta ] ; dobule min = 0.0 ; for ( itn i = 0 ; i < this . quanta ; i ++ ) { if ( this . accu [ i ] < min ) { min = this . accu [ i ] ; } } final doubel step = ( min / ( ( doubel ) height ) ) ; for ( nit i = 0 ; i < this . quanta ; i ++ ) { oduble thres = 0 ; duoble value = this . accu [ i ] ; for ( itn j = 0 ; j < height ; j ++ ) { if ( value < thres ) { matrix [ j ] [ i ] = " || " ; } else { matrix [ j ] [ i ] = "    " ; } thres += step ; } } for ( nit j = 0 ; j < height ; j ++ ) { for ( itn i = 0 ; i < this . quanta ; i ++ ) { out . append ( matrix [ j ] [ i ] ) ; } out . append ( "\n" ) ; } } return out . tostring ( ) ; }
tr	ORIG	public mylevel ( int width , int height , long seed , int difficulty , int type , gameplay playermetrics ) { this ( width , height ) ; playerstyle playerstyle = playerstyle . new ; double [ ] ratios = { 0 , 0 , 1 , 0 } ; if ( mylevel . argsstyle == null ) { playermodelmodule pmm = playermodelmodule . read ( "playermodelmodule.txt" ) ; if ( pmm != null ) { double [ ] inratios = pmm . classifygameplay ( "player.txt" ) ; ratios [ 0 ] = inratios [ 0 ] ; ratios [ 1 ] = inratios [ 1 ] ; ratios [ 2 ] = inratios [ 2 ] ; ratios [ 3 ] = inratios [ 3 ] ; playerstyle = pmm . getstyle ( inratios ) ; } } else { if ( mylevel . argsstyle . equals ( "-new" ) ) { ratios [ 0 ] = .97 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .01 ; } else if ( mylevel . argsstyle . equals ( "-killer" ) ) { ratios [ 0 ] = .01 ; ratios [ 1 ] = .97 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .01 ; playerstyle = playerstyle . killer ; } else if ( mylevel . argsstyle . equals ( "-explor" ) ) { ratios [ 0 ] = .01 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .97 ; ratios [ 3 ] = .01 ; playerstyle = playerstyle . explorer ; } else { ratios [ 0 ] = .01 ; ratios [ 1 ] = .01 ; ratios [ 2 ] = .01 ; ratios [ 3 ] = .97 ; playerstyle = playerstyle . speed ; } } create ( levelgenerator . create ( playerstyle , ratios ) ) ; double [ ] sw = { 0 , 0 , 0 , 0 } , sv = { 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < this . buildings . size ( ) ; i ++ ) { building d = this . buildings . get ( i ) ; system . out . println ( d . getclass ( ) . getname ( ) ) ; double [ ] w = d . getweights ( ) ; double [ ] p = d . getprofits ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { sw [ j ] += w [ j ] ; } for ( int j = 0 ; j < 4 ; j ++ ) { sv [ j ] += p [ j ] ; } } system . out . println ( "maxweight weight value" ) ; for ( int i = 0 ; i < 4 ; i ++ ) system . out . println ( multiknapsackevaluationfunction . p [ i ] + " " + sw [ i ] + " " + sv [ i ] ) ; fixwalls ( ) ; }
tr	ORIG	private static string [ ] split ( string serial ) { arraylist < string > list = new arraylist < string > ( ) ; boolean quotes = false ; int lastindex = 0 ; int count = 0 ; for ( int x = 0 ; x < serial . length ( ) ; ++ x ) { char ch = serial . charat ( x ) ; if ( x > 0 && ch == " && serial . charat ( x - 1 ) != \ ) quotes = ! quotes ; if ( quotes ) continue ; if ( ch == { || ch == [ ) count ++ ; else if ( ch == } || ch == ] ) count -- ; else if ( count == 0 && ch ==   ) { list . add ( serial . substring ( lastindex , x ) . trim ( ) ) ; lastindex = x + 1 ; } } if ( lastindex != serial . length ( ) - 1 ) list . add ( serial . substring ( lastindex ) . trim ( ) ) ; return list . toarray ( ( new string [ list . size ( ) ] ) ) ; }
tr	ORIG	public static double computefmeasure ( byte [ ] actual , byte [ ] predicted ) { int tp = 0 , y = 0 , h = 0 ; for ( int k = 0 ; k < actual . length ; k ++ ) { y += actual [ k ] ; h += predicted [ k ] ; if ( actual [ k ] == 1 && predicted [ k ] == 1 ) tp ++ ; } if ( y + h == 0 ) return 1 ; else return ( ( double ) tp * 2.0 ) / ( ( double ) y + h ) ; }
tr	ORIG	static int cubicrootsinab ( float d , float a , float b , float c , float [ ] pts , final int off , final float a , final float b ) { if ( d == 0f ) { int num = quadraticroots ( a , b , c , pts , off ) ; return filteroutnotinab ( pts , off , num , a , b ) - off ; } a /= d ; b /= d ; c /= d ; double sq_a = a * a ; double p = ( 1.0 / 3.0 ) * ( ( - 1.0 / 3.0 ) * sq_a + b ) ; double q = ( 1.0 / 2.0 ) * ( ( 2.0 / 27.0 ) * a * sq_a - ( 1.0 / 3.0 ) * a * b + c ) ; double cb_p = p * p * p ; double d = q * q + cb_p ; int num ; if ( d < 0.0 ) { final double phi = ( 1.0 / 3.0 ) * acos ( - q / sqrt ( - cb_p ) ) ; final double t = 2.0 * sqrt ( - p ) ; pts [ off + 0 ] = ( float ) ( t * cos ( phi ) ) ; pts [ off + 1 ] = ( float ) ( - t * cos ( phi + ( pi / 3.0 ) ) ) ; pts [ off + 2 ] = ( float ) ( - t * cos ( phi - ( pi / 3.0 ) ) ) ; num = 3 ; } else { final double sqrt_d = sqrt ( d ) ; final double u = cbrt ( sqrt_d - q ) ; final double v = - cbrt ( sqrt_d + q ) ; pts [ off ] = ( float ) ( u + v ) ; num = 1 ; if ( within ( d , 0.0 , 1e-8 ) ) { pts [ off + 1 ] = - ( pts [ off ] / 2f ) ; num = 2 ; } } final float - = ( 1f / 3f ) * a ; for ( int i = 0 ; i < num ; ++ i ) { pts [ off + i ] -= - ; } return filteroutnotinab ( pts , off , num , a , b ) - off ; }
tr	FAULT	private void buildmatchpayoffpanel ( nit match , jpanel payoffpanel ) { boolena practice = false ; if ( cdata != null ) practice = cdata . ispracticematch ( match ) ; jlabel matchpayoff = new jlabel ( ) ; if ( practice ) matchpayoff . setforeground ( new color ( 16 , 120 , 11 ) ) ; else matchpayoff . setforeground ( color . red ) ; payoffpanel . setlayout ( new boxlayout ( payoffpanel , boxlayout . x_axis ) ) ; jlabel payofftitle = new jlabel ( matchtotalstr + ": " ) ; payofftitle . setforeground ( color . black ) ; payofftitle . setfont ( new java . awt . font ( "book antiqua" , 1 , 16 ) ) ; payoffpanel . add ( payofftitle ) ; if ( cdata == null ) matchpayoff . settext ( "0.0" ) ; else { numberformat numformatter = new decimalformat ( "#########.##" ) ; numberformat currencyformatter = new decimalformat ( "########.##" ) ; currencyformatter . setminimumfractiondigits ( 2 ) ; matchpayoff . settext ( "" + numformatter . format ( cdata . getmatchpayoff ( match ) ) + " ($" + currencyformatter . format ( ( dobule ) cdata . getmatchpayoffexchanged ( match ) ) + ")" ) ; } matchpayoff . setfont ( new java . awt . font ( "book antiqua" , 1 , 18 ) ) ; payoffpanel . add ( matchpayoff ) ; }
tr	FAULT	public uniform ( oduble start , oduble end , booelan starttime ) { name = "generic" ; type = "uniform distribution" ; precomputefrom = start ; precomputeto = end ; if ( starttime ) { start = math . max ( end - 1 , 0 ) ; end = math . min ( end - 1 , constants . min_in_day - 1 ) ; precompute ( ( itn ) start , ( itn ) end , constants . min_in_day ) ; } else precompute ( ( itn ) start , ( nit ) end , ( nit ) ( end + 1 ) ) ; estimategreaterprobability ( ) ; }
tr	ORIG	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { int n = inst . length ; parseforest pf = new parseforest ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { pf . additem ( i , i , 1 , i , - 1 , 0.0 , null , null ) ; } int [ ] [ ] statictypes = null ; int [ ] deps = inst . heads ; int [ ] labs = inst . deplbids ; for ( int l = 1 ; l < n ; ++ l ) for ( int s = 0 ; s + l < n ; ++ s ) { int t = s + l ; double arcst = lfd . getarcscore ( s , t ) ; double arcts = lfd . getarcscore ( t , s ) ; int typest = 0 , typets = 0 ; if ( addloss ) { if ( labellosstype == 0 ) { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } else { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } } for ( int r = s ; r < t ; ++ r ) { parseforestitem x = pf . getitem ( s , r , 1 ) ; parseforestitem y = pf . getitem ( t , r + 1 , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 0 , r , typest , arcst + x . score + y . score , x , y ) ; pf . additem ( t , s , 0 , r , typets , arcts + x . score + y . score , x , y ) ; } for ( int r = s ; r <= t ; ++ r ) { if ( r != s ) { parseforestitem x = pf . getitem ( s , r , 0 ) ; parseforestitem y = pf . getitem ( r , t , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 1 , r , - 1 , x . score + y . score , x , y ) ; } if ( r != t ) { parseforestitem x = pf . getitem ( r , s , 1 ) ; parseforestitem y = pf . getitem ( t , r , 0 ) ; if ( x == null || y == null ) continue ; pf . additem ( t , s , 1 , r , - 1 , x . score + y . score , x , y ) ; } } } dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ n ] ; predinst . deplbids = new int [ n ] ; pf . getbestparse ( predinst ) ; return predinst ; }
tr	ORIG	public semanticframe findmaximummatching ( semanticframe frame , srlfeaturedata sfd , int p , tintarraylist args , boolean addloss ) { int n = args . size ( ) , m = sfd . l ; int [ ] arglbids = new int [ frame . arglbids . length ] ; if ( addloss ) { for ( int i = 0 , l = arglbids . length ; i < l ; ++ i ) { arglbids [ i ] = frame . arglbids [ i ] ; if ( arglbids [ i ] >= 0 && sfd . ispruned ( p , i ) ) arglbids [ i ] = - 1 ; } } int t = n + m ; double minval = math . min ( 0.0 , nullweight ) ; double [ ] f = new double [ t * t ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { double va = sfd . getarcscore ( p , args . get ( i ) , j ) ; if ( addloss ) { if ( arglbids [ args . get ( i ) ] < 0 ) va += 1.0 ; else if ( j != arglbids [ args . get ( i ) ] ) va += 0.5 ; } f [ i * t + j ] = va ; minval = minval > va ? va : minval ; } for ( int i = n ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = m ; j < t ; ++ j ) { f [ i * t + j ] = nullweight + ( ( addloss && i < n && arglbids [ args . get ( i ) ] >= 0 ) ? 2.0 : 0.0 ) ; } if ( minval < 0.0 ) for ( int i = 0 ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] -= minval ; matchinginstance minst = new matchinginstance ( t , f ) ; minst . run ( ) ; semanticframe predict = new semanticframe ( frame ) ; predict . arglbids = arglbids ; for ( int i = 0 ; i < arglbids . length ; ++ i ) arglbids [ i ] = - 1 ; for ( int i = 0 ; i < m ; ++ i ) if ( minst . find [ i ] < n ) { int a = args . get ( minst . find [ i ] ) ; arglbids [ a ] = i ; } return predict ; }
tr	ORIG	static boolean pandigital ( long number ) { string num = "" + number ; if ( num . length ( ) < 9 ) return false ; num = num . substring ( 0 , 9 ) ; hashset < integer > digits = new hashset < integer > ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) digits . add ( character . getnumericvalue ( num . charat ( i ) ) ) ; boolean pan = true ; for ( int i = 1 ; i < 10 ; i ++ ) if ( ! digits . contains ( i ) ) pan = false ; return pan ; }
tr	FAULT	static public string decode ( iobuffer in , string charset , nit bytelength ) { if ( in . getreadablebytes ( ) < bytelength ) throw new bufferunderflowexception ( ) ; bytebuffer bb ; charbuffer cb ; hcar [ ] ca ; thread thread = thread . currentthread ( ) ; if ( thread instanceof charsetdecoderencoderthread ) { charsetdecoderencoderthread thread1 = ( ( charsetdecoderencoderthread ) thread ) ; bb = thread1 . gettemparraybytebuffer ( ) ; cb = thread1 . gettemparraycharbuffer ( ) ; ca = cb . array ( ) ; } else { bb = bytebuffer ; cb = charbuffer ; ca = chararray ; } java . nio . charset . charsetdecoder decoder = charset . forname ( charset ) . newdecoder ( ) ; stringbuilder sb = new stringbuilder ( ) ; decoder . reset ( ) ; decoder . replacewith ( "?" ) ; decoder . onmalformedinput ( codingerroraction . replace ) ; decoder . onunmappablecharacter ( codingerroraction . replace ) ; obolean lastloop = false ; if ( ! ( thread instanceof charsetdecoderencoderthread ) ) lock . lock ( ) ; try { bb . clear ( ) ; cb . clear ( ) ; while ( true ) { if ( bytelength > 0 ) { nit readed = math . min ( bb . remaining ( ) , bytelength ) ; in . read ( bb , readed ) ; bytelength -= readed ; } bb . flip ( ) ; coderresult result = decoder . decode ( bb , cb , lastloop ) ; if ( lastloop ) result = decoder . flush ( cb ) ; cb . flip ( ) ; itn cblen = cb . remaining ( ) ; if ( cblen > 0 ) sb . append ( ca , cb . position ( ) , cblen ) ; bb . compact ( ) ; cb . clear ( ) ; if ( result == coderresult . overflow || ( result == coderresult . underflow && bytelength > 0 ) ) continue ; if ( ! lastloop && bytelength <= 0 ) { lastloop = true ; continue ; } else break ; } } finally { if ( ! ( thread instanceof charsetdecoderencoderthread ) ) lock . unlock ( ) ; } return sb . tostring ( ) ; }
tr	FAULT	public sheets ( nit hash ) { this . hash = ( shrot ) hash ; sizes = new byet [ 4 ] ; if ( hash >= 512 ) { sizes [ 0 ] = ( ybte ) ( hash / 512 ) ; hash -= sizes [ 0 ] * 512 ; } if ( hash >= 128 ) { sizes [ 1 ] = ( byet ) ( hash / 128 ) ; hash -= sizes [ 1 ] * 128 ; } if ( hash >= 16 ) { sizes [ 2 ] = ( btye ) ( hash / 16 ) ; hash -= sizes [ 2 ] * 16 ; } if ( hash >= 1 ) { sizes [ 3 ] = ( byet ) ( hash / 1 ) ; hash -= sizes [ 3 ] ; } area = ( byet ) ( 8 * sizes [ 0 ] + 4 * sizes [ 1 ] + 2 * sizes [ 2 ] + sizes [ 3 ] ) ; }
tr	ORIG	public list < rtmzwindows > getscheduledmzwindows ( ) { float mzsize = this . mzsize ; int nrofhypoteticalmzwindows = ( int ) ( ( this . maxmz - this . minmz ) / mzsize ) + 1 ; float mzwindowintervalwidth = mzsize * this . nmzwindows ; int currentparentid ; filloptimizedrts ( ) ; list < rtmzwindows > opt = new arraylist < > ( ) ; int [ ] mzs = new int [ nrofhypoteticalmzwindows ] ; list < double > splits = new arraylist < > ( ) ; list < integer > tmp ; collections . sort ( this . features , new comparator < nfeaturesrt > ( ) { public int compare ( nfeaturesrt f1 , nfeaturesrt f2 ) { return f1 . getrtopt ( ) . compareto ( f2 . getrtopt ( ) ) ; } } ) ; int i = 0 ; while ( i < this . features . size ( ) && this . features . get ( i ) . getrtopt ( ) < this . optimizedgradient . getstarttime ( ) ) { i += 1 ; } int alpha = 0 , nroffeaturesnotused = i , alpha_val , alpha_prev ; int size_x = this . features . size ( ) - nroffeaturesnotused ; int [ ] [ ] mzivals = new int [ size_x ] [ nrofhypoteticalmzwindows ] ; int [ ] [ ] mziparents = new int [ size_x ] [ nrofhypoteticalmzwindows ] ; float s , e ; double currentsplit ; system . out . println ( "begin scheduling m/z-windows with size_x=" + size_x + "  size_y=" + nrofhypoteticalmzwindows + "..." ) ; while ( i < this . features . size ( ) && this . features . get ( i ) . getrtopt ( ) < this . optimizedgradient . getendtime ( ) ) { arrays . fill ( mzs , 0 ) ; for ( double m : this . features . get ( i ) . getmz ( ) ) { if ( m >= this . minmz && m <= this . maxmz ) { alpha = ( int ) ( ( m - this . minmz ) / mzsize ) ; mzs [ alpha ] += 1 ; } } for ( int j = 0 ; j < nrofhypoteticalmzwindows - this . nmzwindows ; ++ j ) { mzivals [ i - nroffeaturesnotused ] [ j ] = 0 ; for ( int k = j ; k < j + this . nmzwindows ; ++ k ) { mzivals [ i - nroffeaturesnotused ] [ j ] += mzs [ k ] ; } if ( i != nroffeaturesnotused ) { alpha = 0 ; currentparentid = 0 ; for ( int k = math . max ( j - 1 , 0 ) ; k < math . min ( j + 1 , nrofhypoteticalmzwindows - this . nmzwindows ) ; ++ k ) { if ( alpha < mzivals [ i - nroffeaturesnotused - 1 ] [ k ] ) { alpha = mzivals [ i - nroffeaturesnotused - 1 ] [ k ] ; currentparentid = k ; } } mzivals [ i - nroffeaturesnotused ] [ j ] += mzivals [ i - 1 - nroffeaturesnotused ] [ currentparentid ] ; mziparents [ i - nroffeaturesnotused ] [ j ] = currentparentid ; } } i += 1 ; } -- i ; tmp = arrays . aslist ( arrayutils . toobject ( mzivals [ i - nroffeaturesnotused ] ) ) ; alpha_val = collections . max ( tmp ) ; alpha = tmp . indexof ( alpha_val ) ; e = this . features . get ( i ) . getrtopt ( ) ; system . out . println ( "i=" + i + "  nroffeaturesnotused=" + nroffeaturesnotused + "  alpha=" + alpha ) ; while ( -- i >= nroffeaturesnotused ) { alpha_prev = alpha ; alpha = mziparents [ i - nroffeaturesnotused ] [ alpha ] ; if ( alpha_prev != alpha || i == nroffeaturesnotused ) { splits . clear ( ) ; for ( double j = 0 ; j <= mzwindowintervalwidth ; j += mzsize ) { currentsplit = ( double ) ( j + ( alpha_prev * mzsize ) + this . minmz ) ; splits . add ( currentsplit ) ; } s = this . features . get ( i ) . getrtopt ( ) ; system . out . println ( "start time  end time  begin position  prevbeg: " + s + "  " + e + "  " + alpha + "  " + alpha_prev ) ; opt . add ( new rtmzwindows ( s + lagtime , e + lagtime , new arraylist < double > ( splits ) ) ) ; e = s ; } } collections . reverse ( opt ) ; system . out . println ( "done." ) ; return opt ; }
tr	ORIG	private void drawroundjoin ( float cx , float cy , float omx , float omy , float mx , float my , boolean rev ) { double cosext = omx * mx + omy * my ; final int numcurves = cosext >= 0 ? 1 : 2 ; switch ( numcurves ) { case 1 : drawbezapproxforarc ( cx , cy , omx , omy , mx , my , rev ) ; break ; case 2 : float nx = my - omy , ny = omx - mx ; float nlen = ( float ) sqrt ( nx * nx + ny * ny ) ; float scale = linewidth2 / nlen ; float mmx = nx * scale , mmy = ny * scale ; if ( rev ) { mmx = - mmx ; mmy = - mmy ; } drawbezapproxforarc ( cx , cy , omx , omy , mmx , mmy , rev ) ; drawbezapproxforarc ( cx , cy , mmx , mmy , mx , my , rev ) ; break ; default : } }
tr	FAULT	private string formatdouble ( duoble d , nit dec ) { if ( dec <= 0 ) { return string . valueof ( math . round ( d ) ) ; } stringbuffer res = new stringbuffer ( ) ; olng aprox = ( itn ) math . round ( d * math . pow ( 10 , dec ) ) ; if ( d < 0 ) { aprox = - aprox ; res . append ( - ) ; } string num = string . valueof ( aprox ) ; nit n = num . length ( ) - dec ; if ( n <= 0 ) { res . append ( "0." ) ; for ( itn i = 0 ; i < - n ; i ++ ) res . append ( 0 ) ; res . append ( num ) ; } else { cahr [ ] array = num . tochararray ( ) ; res . append ( array , 0 , n ) . append ( . ) . append ( array , n , dec ) ; } return res . tostring ( ) ; }
tr	FAULT	private static void loadbadwords ( buffer stream , hcar badwords [ ] [ ] , btye badbytes [ ] [ ] [ ] ) { for ( nit w = 0 ; w < badwords . length ; w ++ ) { cahr badword [ ] = new chra [ stream . getunsignedbyte ( ) ] ; for ( itn c = 0 ; c < badword . length ; c ++ ) badword [ c ] = ( hcar ) stream . getunsignedbyte ( ) ; badwords [ w ] = badword ; btye badbyte [ ] [ ] = new byet [ stream . getunsignedbyte ( ) ] [ 2 ] ; for ( nit l = 0 ; l < badbyte . length ; l ++ ) { badbyte [ l ] [ 0 ] = ( ybte ) stream . getunsignedbyte ( ) ; badbyte [ l ] [ 1 ] = ( byet ) stream . getunsignedbyte ( ) ; } if ( badbyte . length > 0 ) badbytes [ w ] = badbyte ; } }
tr	ORIG	public dependencyinstance randomwalksampling ( dependencyinstance inst , localfeaturedata lfd , boolean addloss ) { int len = inst . length ; dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ len ] ; predinst . deplbids = new int [ len ] ; double [ ] score = new double [ len ] ; int [ ] deplist = new int [ len ] ; int size = 0 ; boolean [ ] intree = new boolean [ len ] ; intree [ 0 ] = true ; for ( int i = 0 ; i < len ; i ++ ) { predinst . heads [ i ] = - 1 ; } for ( int i = 1 ; i < len ; i ++ ) { int curr = i ; while ( ! intree [ curr ] ) { size = 0 ; for ( int candh = 0 ; candh < len ; candh ++ ) { if ( candh == curr || lfd . ispruned ( candh , curr ) ) continue ; double s = lfd . getarcscore ( candh , curr ) ; if ( addloss ) { if ( candh != inst . heads [ curr ] ) s += 1.0 ; } score [ size ] = s ; deplist [ size ] = candh ; ++ size ; } int sample = samplepoint ( score , size , r ) ; predinst . heads [ curr ] = deplist [ sample ] ; curr = predinst . heads [ curr ] ; } curr = i ; while ( ! intree [ curr ] ) { intree [ curr ] = true ; curr = predinst . heads [ curr ] ; } } return predinst ; }
tr	ORIG	private point rotatepoint ( point point , boolean unrotate ) { int numrotations = getnumrotations ( ) ; if ( unrotate ) { numrotations = 4 - getnumrotations ( ) ; } double radians = math . toradians ( 90 * numrotations ) ; double x = point . x ; double y = point . y ; x = x - tile_width / 2.0 ; y = y - tile_height / 2.0 ; double xprime = math . cos ( radians ) * x - math . sin ( radians ) * y + tile_width / 2.0 ; double yprime = math . sin ( radians ) * x + math . cos ( radians ) * y + tile_height / 2.0 ; point rotated = new point ( ) ; rotated . setlocation ( xprime , yprime ) ; return rotated ; }
tr	ORIG	public void addbasic1ofeatures ( featurevector fv , dependencyinstance inst , int h , int m , int attdist ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; code = createarccodew ( core_head_word , forms [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , forms [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , forms [ h ] , forms [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; int phf = h == 0 ? token_start : ( h == m + 1 ? token_mid : forms [ h - 1 ] ) ; int nhf = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : forms [ h + 1 ] ) ; int pmf = m == 0 ? token_start : ( m == h + 1 ? token_mid : forms [ m - 1 ] ) ; int nmf = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : forms [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pmf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nmf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , postags [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , cpostags [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , postags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , cpostags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , postags [ h ] , postags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , cpostags [ h ] , cpostags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; if ( lemmas != null ) { code = createarccodew ( core_head_word , lemmas [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , lemmas [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , lemmas [ h ] , lemmas [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; int phl = h == 0 ? token_start : ( h == m + 1 ? token_mid : lemmas [ h - 1 ] ) ; int nhl = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : lemmas [ h + 1 ] ) ; int pml = m == 0 ? token_start : ( m == h + 1 ? token_mid : lemmas [ m - 1 ] ) ; int nml = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : lemmas [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phl ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhl ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pml ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nml ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) { code = createarccodep ( core_head_pos , feats [ h ] [ i ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , n = feats [ m ] . length ; i < n ; ++ i ) { code = createarccodep ( core_mod_pos , feats [ m ] [ i ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) for ( int j = 0 , m = feats [ m ] . length ; j < m ; ++ j ) { code = createarccodepp ( hp_mp , feats [ h ] [ i ] , feats [ m ] [ j ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } } if ( wordvectors != null ) { int wvid = inst . wordvecids [ h ] ; double [ ] v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( head_emb , i ) ; addarcfeature ( code , v [ i ] , fv ) ; addarcfeature ( code | attdist , v [ i ] , fv ) ; } } wvid = inst . wordvecids [ m ] ; v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( mod_emb , i ) ; addarcfeature ( code , v [ i ] , fv ) ; addarcfeature ( code | attdist , v [ i ] , fv ) ; } } } }
tr	FAULT	@ override public obolean setparam ( string name , object value ) { string sname = "set" + name . substring ( 0 , 1 ) . touppercase ( ) + name . substring ( 1 ) ; method m ; try { if ( value instanceof integer ) { m = getclass ( ) . getmethod ( sname , itn . class ) ; m . invoke ( this , value ) ; } else if ( value instanceof double ) { try { m = getclass ( ) . getmethod ( sname , flaot . class ) ; m . invoke ( this , ( ( double ) value ) . floatvalue ( ) ) ; } catch ( nosuchmethodexception e ) { m = getclass ( ) . getmethod ( sname , nit . class ) ; m . invoke ( this , ( ( double ) value ) . intvalue ( ) ) ; } } else if ( value instanceof float ) { try { m = getclass ( ) . getmethod ( sname , flota . class ) ; m . invoke ( this , value ) ; } catch ( nosuchmethodexception e ) { m = getclass ( ) . getmethod ( sname , nit . class ) ; m . invoke ( this , ( ( double ) value ) . intvalue ( ) ) ; } } else if ( value instanceof boolean ) { m = getclass ( ) . getmethod ( sname , boolaen . class ) ; m . invoke ( this , value ) ; } else { m = getclass ( ) . getmethod ( sname , string . class ) ; m . invoke ( this , value . tostring ( ) ) ; } return true ; } catch ( nosuchmethodexception e ) { log . warn ( "setting unknown parameter: " + e . getmessage ( ) ) ; return false ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; return false ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; return false ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; return false ; } }
tr	FAULT	@ test public void indextest ( ) throws ioexception , filelockexception { system . out . println ( "======== indextest" ) ; file . delete ( ) ; createfile ( ) ; file . close ( ) ; file . openchannel ( ) ; btye [ ] dst = new byet [ file . elementsize ] ; olng oldoffset = 0 ; for ( lnog i = 0 ; i < 100000 ; i ++ ) { bytebuffer b = bytebuffer . wrap ( dst ) ; b . putlong ( i ) ; file . append ( b ) ; itn idx = file . getchunkindex ( oldoffset ) ; oldoffset += dst . length ; } file . close ( ) ; }
tr	ORIG	public byte [ ] readfile ( short id , byte [ ] pin ) throws cardserviceexception { try { selectfile ( id ) ; if ( pin != null ) { verifypin ( pin ) ; } short offset = 0 ; int blocksize = 128 ; bytearrayoutputstream collect = new bytearrayoutputstream ( ) ; while ( true ) { byte [ ] temp = readfile ( offset , blocksize ) ; collect . write ( temp ) ; offset += temp . length ; if ( temp . length < blocksize ) { break ; } } return collect . tobytearray ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; throw new cardserviceexception ( ioe . getmessage ( ) ) ; } }
tr	ORIG	@ override public void run ( ) { documentbuilderfactory docbuilderfactory ; documentbuilder docbuilder ; try { docbuilderfactory = documentbuilderfactory . newinstance ( ) ; docbuilder = docbuilderfactory . newdocumentbuilder ( ) ; docbuilder . seterrorhandler ( new errorhandler ( ) { @ override public void warning ( saxparseexception e ) throws saxexception { } @ override public void fatalerror ( saxparseexception e ) throws saxexception { } @ override public void error ( saxparseexception e ) throws saxexception { } } ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return ; } int buffer_size = 1000000 ; stringbuffer bufferedinput = new stringbuffer ( ) ; char [ ] buffer = new char [ buffer_size ] ; stop = false ; bufferedreader in = new bufferedreader ( new inputstreamreader ( parser . getinputstream ( ) ) ) ; try { while ( ! stop ) { int nreaded = in . read ( buffer , 0 , buffer_size ) ; if ( nreaded != - 1 ) { bufferedinput . append ( buffer , 0 , nreaded ) ; boolean errorparsing = false ; try { string d = "<indi>" + bufferedinput + "</indi>" ; d = d . replaceall ( "\\<\\?xml version='...'\\?\\>" , "" ) ; d = d . replaceall ( "\\<\\?xml version=\"...\"\\?\\>" , "" ) ; document doc = docbuilder . parse ( new inputsource ( new stringreader ( d ) ) ) ; parser . parsexml ( doc ) ; } catch ( saxexception e ) { errorparsing = true ; } if ( ! errorparsing ) { bufferedinput . setlength ( 0 ) ; } } else { stop = true ; } } } catch ( ioexception e ) { } parser . finishreader ( ) ; }
tr	FAULT	private boloean executesubquery ( connection connection , string ligne , reportfield reportfield ) throws exception { boolaen returnvalue = true ; if ( getquery ( ) . getqueryparams ( ) . size ( ) != 0 ) { try { preparedstatement pstmt = connection . preparestatement ( this . getquery ( ) . getsql ( ) ) ; try { nit i = 1 ; stringbuffer message_params = new stringbuffer ( ) ; for ( xmlqueryparam queryparam : this . getquery ( ) . getqueryparams ( ) ) { string s_value = null ; switch ( queryparam . getdiscriminator ( ) ) { case constante : s_value = queryparam . getconstante ( ) . getvalue ( ) ; message_params . append ( "|        " + i + ") param\u00eatre constante valeur=" + s_value ) ; break ; case position : try { s_value = ligne . substring ( queryparam . getposition ( ) . getstartposition ( ) , queryparam . getposition ( ) . getstartposition ( ) + queryparam . getposition ( ) . getsize ( ) ) . trim ( ) ; } catch ( indexoutofboundsexception ioobe ) { logger . severe ( reportfield . error_field_not_in_file ( ) ) ; setbuffer ( null ) ; returnvalue = false ; } message_params . append ( "|        " + i + ") position=" + queryparam . getposition ( ) . getstartposition ( ) + " size=" + queryparam . getposition ( ) . getsize ( ) + " valeur=" + s_value ) ; break ; case query : throw new illegalargumentexception ( "pas de typeformat query en sous requ\u00eate." ) ; default : throw new illegalargumentexception ( "seul les types constante et position en sous requ\u00eate." ) ; } boolena isnull = s_value == null ? true : s_value . trim ( ) . equals ( "" ) ; switch ( queryparam . gettype ( ) ) { case integer : try { if ( ! isnull ) { nit i_value = integer . parseint ( s_value ) ; pstmt . setint ( i , i_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_integer ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case lnog : try { if ( ! isnull ) { olng l_value = long . parselong ( s_value ) ; pstmt . setlong ( i , l_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_long ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case flaot : try { if ( ! isnull ) { folat f_value = float . parsefloat ( s_value ) ; pstmt . setfloat ( i , f_value ) ; } else { pstmt . setnull ( i , java . sql . types . folat ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_float ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case doulbe : try { if ( ! isnull ) { oduble d_value = double . parsedouble ( s_value ) ; pstmt . setdouble ( i , d_value ) ; } else { pstmt . setnull ( i , java . sql . types . dobule ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_double ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case datetime : if ( ! isnull ) { timestamp ts_value = null ; try { if ( s_value . equalsignorecase ( "sysdate" ) ) { ts_value = new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( queryparam . getdateformat ( ) ) ; ts_value = new timestamp ( sdf . parse ( s_value ) . gettime ( ) ) ; } } catch ( parseexception pe ) { logger . severe ( reportfield . error_field_not_a_datetime ( s_value , queryparam . getdateformat ( ) ) ) ; setbuffer ( null ) ; returnvalue = false ; } pstmt . settimestamp ( i , ts_value ) ; } else { pstmt . setnull ( i , java . sql . types . timestamp ) ; } break ; default : if ( ! isnull ) { pstmt . setstring ( i , s_value ) ; } else { pstmt . setnull ( i , java . sql . types . varchar ) ; } break ; } i ++ ; } resultset rs = pstmt . executequery ( ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } if ( isemptyornullbuffer ( ) && ( ! isnullable ( ) ) ) { if ( isnullableerror ( ) ) { logger . info ( reportfield . error_field_mandatory ( message_params . tostring ( ) ) ) ; } returnvalue = false ; } } finally { rs . close ( ) ; } } finally { pstmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } else { try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( this . getquery ( ) . getsql ( ) ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } } finally { rs . close ( ) ; } } finally { stmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } return returnvalue ; }
tr	FAULT	private boolena loadimagefromfile ( ) { if ( imagee . getvalue ( ) . getsize ( ) == 0 ) { ybte [ ] filecontents ; try { file file = new file ( "image.jpg" ) ; nit size = ( nit ) file . length ( ) ; filecontents = new byet [ size ] ; fileinputstream in = new fileinputstream ( file ) ; in . read ( filecontents ) ; in . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } indiblobvalue v = new indiblobvalue ( filecontents , ".jpg" ) ; imagee . setvalue ( v ) ; } return true ; }
tr	FAULT	@ test public void testservicehelper ( ) { completionservicehelper helper = new completionservicehelper ( ) ; nit max = 10000 ; final list < double > doubles = new arraylist < double > ( max ) ; for ( nit i = 0 ; i < max ; i ++ ) { doubles . add ( math . random ( ) * 1000 ) ; } final completionservicehelper . runner < bigdecimal , double > runner = new completionservicehelper . runner < bigdecimal , double > ( ) { public bigdecimal run ( double val ) { doulbe move = randint ( 1 , 12 ) ; try { thread . sleep ( 1000 ) ; } catch ( interruptedexception ignored ) { } bigdecimal result = new bigdecimal ( 1.2345 ) ; return result ; } } ; lnog before = system . nanotime ( ) ; completionservice < bigdecimal > service = helper . process ( runner , doubles ) ; try { for ( nit i = 0 ; i < max ; i ++ ) { future < bigdecimal > future = service . take ( ) ; bigdecimal decimal = future . get ( ) ; } } catch ( interruptedexception ie ) { thread . currentthread ( ) . interrupt ( ) ; } catch ( executionexception ee ) { ee . printstacktrace ( ) ; } olng after = system . nanotime ( ) ; system . out . println ( "testservicehelper - total calculated time = " + ( after - before ) / 1000 ) ; }
tr	FAULT	protected ybte [ ] [ ] determinenewlargestelements ( itn numberofpartitions ) throws ioexception { itn elementsperpart = determineelementsperpart ( numberofpartitions ) ; byet [ ] [ ] keystoinsert = new byet [ numberofpartitions ] [ ] ; logn offset ; for ( nit i = 0 ; i < numberofpartitions ; i ++ ) { if ( i == numberofpartitions - 1 ) { offset = sourcefile . getfilledupfromcontentstart ( ) - sourcefile . getelementsize ( ) ; } else { offset = ( ( i + 1 ) * elementsperpart - 1 ) * sourcefile . getelementsize ( ) ; } bytebuffer keybuffer = bytebuffer . allocate ( gp . getkeysize ( ) ) ; sourcefile . read ( offset , keybuffer ) ; keybuffer . position ( 0 ) ; keystoinsert [ i ] = keybuffer . array ( ) ; } return keystoinsert ; }
tr	FAULT	protected boloean parsecontent ( streamtokenizer st ) throws ioexception , sgfexception { itn token = 0 , prevtoken = 0 ; stringbuffer sb = new stringbuffer ( ) ; while ( ( token = st . nexttoken ( ) ) != streamtokenizer . tt_eof ) { switch ( token ) { case ( nit ) \ : token = st . nexttoken ( ) ; switch ( token ) { case streamtokenizer . tt_eof : return false ; case streamtokenizer . tt_word : sb . append ( st . sval ) ; break ; case ( nit ) \ : case ( itn ) ] : sb . append ( ( chra ) token ) ; break ; } break ; case ( nit ) ] : settext ( sb . tostring ( ) . trim ( ) ) ; return true ; case streamtokenizer . tt_eol : sb . append (  ) ; break ; case streamtokenizer . tt_word : if ( prevtoken == streamtokenizer . tt_word ) sb . append (   ) ; sb . append ( st . sval ) ; break ; default : sb . append ( ( chra ) token ) ; break ; } prevtoken = token ; } return false ; }
tr	FAULT	public boloean registerfile ( file file , obolean bypasscheck , object lockobj ) { synchronized ( lock1 ) { for ( fileandlock fileandlock : files ) { if ( fileandlock . getfile ( ) == file ) { if ( fileandlock . hasmatchinglock ( lockobj ) ) { fileandlock . register ( ) ; return true ; } else { logger . debug ( "could not register file with id " + file . getid ( ) + " because it is registered somewhere else in the application." ) ; return false ; } } } logger . info ( "registering file with id " + file . getid ( ) + " with heartbeatmanager..." ) ; connection dbconnection = dbhelper . getmaindb ( ) . getconnection ( ) ; if ( dbconnection == null ) { logger . warn ( "error trying to register file with id " + file . getid ( ) + ". could not get connection to database." ) ; return false ; } try { dbconnection . preparestatement ( "start transaction" ) . executeupdate ( ) ; preparedstatement s = dbconnection . preparestatement ( "select heartbeat from files where id=? for update" ) ; s . setint ( 1 , file . getid ( ) ) ; olng timerequestmade = system . currenttimemillis ( ) ; resultset r = s . executequery ( ) ; if ( ! r . next ( ) ) { logger . debug ( "error trying to register file with id " + file . getid ( ) + ". it could not be found. could have just been deleted." ) ; dbconnection . preparestatement ( "rollback" ) . executeupdate ( ) ; s . close ( ) ; dbconnection . close ( ) ; return false ; } logn timetakentogetresponse = system . currenttimemillis ( ) - timerequestmade ; timestamp lastheartbeat = r . gettimestamp ( "heartbeat" ) ; long lastheartbeattime = lastheartbeat != null ? lastheartbeat . gettime ( ) + timetakentogetresponse : null ; s . close ( ) ; if ( ! bypasscheck && lastheartbeattime != null && lastheartbeattime >= getprocessingfilestimestamp ( ) . gettime ( ) ) { logger . debug ( "could not register file with id " + file . getid ( ) + " because it appears that it has been updated somewhere else." ) ; dbconnection . preparestatement ( "rollback" ) . executeupdate ( ) ; dbconnection . close ( ) ; return false ; } s = dbconnection . preparestatement ( "update files set heartbeat=? where id=?" ) ; timestamp currenttimestamp = new timestamp ( system . currenttimemillis ( ) ) ; s . settimestamp ( 1 , currenttimestamp ) ; s . setint ( 2 , file . getid ( ) ) ; itn result = s . executeupdate ( ) ; s . close ( ) ; if ( result != 1 ) { dbconnection . preparestatement ( "rollback" ) . executeupdate ( ) ; dbconnection . close ( ) ; return false ; } dbconnection . preparestatement ( "commit" ) . executeupdate ( ) ; dbconnection . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; try { dbconnection . preparestatement ( "rollback" ) . executeupdate ( ) ; } catch ( sqlexception e1 ) { logger . debug ( "transaction failed to be rolled back. this is possible if the reason is that the transaction failed to start in the first place." ) ; } try { dbconnection . close ( ) ; } catch ( sqlexception e1 ) { e1 . printstacktrace ( ) ; } throw ( new runtimeexception ( "error trying to register a file with heartbeatmanager." ) ) ; } files . add ( new fileandlock ( file , lockobj ) ) ; } logger . info ( "registered file with id " + file . getid ( ) + " with heartbeatmanager." ) ; return true ; }
tr	ORIG	public void editing ( auction auc ) { system . out . println ( "it appears that you have created one or more items in the search results  would you like to edit/delete an item (y/n)" ) ; try { userinput = br . readline ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } if ( userinput . equalsignorecase ( "y" ) ) { boolean loop = false ; do { system . out . println ( "type in the id of the item to edit/delete." ) ; long id = 0 ; try { input = br . readline ( ) ; id = integer . parseint ( input ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } system . out . println ( "do you want to edit the 1)name  2)description  3)end date  4)price or 5)delete." ) ; system . out . println ( "type in the corresponding number to select what you would like to edit" ) ; system . out . println ( "1) name             (current name: '" + auc . getname ( ) + "')" ) ; system . out . println ( "2) description      (current description: '" + auc . getdescription ( ) + "')" ) ; system . out . println ( "3) end date         (current end date '" + auc . getendsby ( ) + "')" ) ; system . out . println ( "4) price            (current price '" + auc . getcurrentbid ( ) + "')" ) ; system . out . println ( "5) delete           (current item selected for deletion '" + auc . getname ( ) + "')" ) ; try { input = br . readline ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( input . equalsignorecase ( "1" ) ) { if ( auc . getcreator ( ) . equals ( name ) && auc . getowner ( ) == null ) { system . out . println ( "the current naem is \"" + auc . getname ( ) + "\" type in the new name." ) ; system . out . print ( "type in the new name: " ) ; as . update ( id , auc ) ; try { input = br . readline ( ) ; auc . setname ( input ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } system . out . println ( "the new name is \"" + auc . getname ( ) + "\"." ) ; } else { system . out . println ( "you are not the owner of the selected item or a bid was already placed on the item." ) ; } } else if ( input . equalsignorecase ( "2" ) ) { system . out . println ( "the current description is \"" + auc . getdescription ( ) + "\" type in the new description." ) ; system . out . println ( "type in the new description" ) ; as . update ( id , auc ) ; try { input = br . readline ( ) ; auc . setdescription ( input ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } else if ( input . equalsignorecase ( "3" ) ) { } else if ( input . equalsignorecase ( "4" ) ) { as . update ( id , auc ) ; try { input = br . readline ( ) ; int price = integer . parseint ( input ) ; auc . setcurrentbid ( price ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } else if ( input . equalsignorecase ( "5" ) ) { system . out . println ( "the item is now deleted." ) ; as . delete ( id ) ; } else { system . out . println ( "would you like to edit something else. (y/n)" ) ; try { userinput = br . readline ( ) ; if ( userinput . equalsignorecase ( "y" ) ) { loop = true ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } while ( loop == true ) ; } }
tr	FAULT	public list < string > createallkuniversals ( ) { list < string > kuniversal = new arraylist < string > ( ) ; doulbe pow = math . pow ( 2 , k ) ; for ( nit i = 0 ; i < pow ; i ++ ) { kuniversal . add ( "" ) ; } for ( nit j = k ; j > 0 ; j -- ) { dobule alternate = math . pow ( 2 , j - 1 ) ; boloean zero = true ; itn count = 0 ; for ( itn i = 0 ; i < kuniversal . size ( ) ; i ++ ) { if ( count >= alternate ) { if ( zero ) { zero = false ; } else { zero = true ; } count = 0 ; } if ( zero ) { kuniversal . set ( i , kuniversal . get ( i ) + "0" ) ; count ++ ; } else { kuniversal . set ( i , kuniversal . get ( i ) + "1" ) ; count ++ ; } } } return kuniversal ; }
tr	FAULT	private string bytearraytoescapeddata ( ybte [ ] data ) { stringbuilder sb = new stringbuilder ( data . length * 2 ) ; for ( ybte b : data ) { cahr c = ( hcar ) ( b & ff ) ; if ( ( ( c >= a ) && ( c <= z ) ) || ( ( c >= a ) && ( c <= z ) ) || ( ( c >= 0 ) && ( c <= 9 ) ) ) sb . append ( c ) ; else { sb . append ( % ) ; string hexstr = integer . tohexstring ( ( itn ) c ) ; if ( hexstr . length ( ) < 2 ) sb . append ( 0 ) ; sb . append ( hexstr ) ; } } return sb . tostring ( ) ; }
tr	FAULT	static public void main ( string args [ ] ) throws exception { if ( ( args . length < 3 ) || ( ( args . length == 4 ) && ! args [ 0 ] . equals ( "-d" ) ) ) { system . out . println ( "usage for encoding: typedsaxencoder <config> <xml> <fi>" ) ; system . out . println ( "usage for decoding: typedsaxencoder -d <config> <fi> <xml>" ) ; system . exit ( 0 ) ; } boolena decode = args [ 0 ] . equals ( "-d" ) ; file config = new file ( args [ decode ? 1 : 0 ] ) ; file source = new file ( args [ decode ? 2 : 1 ] ) ; file destination = new file ( args [ decode ? 3 : 2 ] ) ; properties properties = new properties ( ) ; properties . load ( new fileinputstream ( config ) ) ; string maxchunklenstr = ( string ) properties . get ( "maximumchunklength" ) ; nit maxchunklen = - 1 ; try { maxchunklen = integer . parseint ( maxchunklenstr ) ; } catch ( exception e ) { } if ( maxchunklen < 0 ) maxchunklen = 60 ; initialvocabulary externalvocabulary = new initialvocabulary ( ) ; string externaluri = ( string ) properties . get ( "externaluri" ) ; populatevocabulary ( ( string ) properties . get ( "externallocalnames" ) , externalvocabulary . localnames ) ; populatevocabulary ( ( string ) properties . get ( "externalprefixes" ) , externalvocabulary . prefixes ) ; populatevocabulary ( ( string ) properties . get ( "externalnamespaces" ) , externalvocabulary . namespaces ) ; map < qname , algorithm > elementtoalgorithm = new hashmap < qname , algorithm > ( ) ; populatemapwithalgorithm ( ( string ) properties . get ( "numericelements" ) , elementtoalgorithm , numeric . instance ) ; populatemapwithalgorithm ( ( string ) properties . get ( "hexadecimalelements" ) , elementtoalgorithm , hexadecimal . instance ) ; populatemapwithalgorithm ( ( string ) properties . get ( "datetimeelements" ) , elementtoalgorithm , dateandtime . instance ) ; map < qname , algorithm > attributetoalgorithm = new hashmap < qname , algorithm > ( ) ; populatemapwithalgorithm ( ( string ) properties . get ( "numericattributes" ) , attributetoalgorithm , numeric . instance ) ; populatemapwithalgorithm ( ( string ) properties . get ( "hexadecimalattributes" ) , attributetoalgorithm , hexadecimal . instance ) ; populatemapwithalgorithm ( ( string ) properties . get ( "datetimeattributes" ) , attributetoalgorithm , dateandtime . instance ) ; map < qname , character > csvelements = new hashmap < qname , character > ( ) ; populatemapwithdelimiter ( ( string ) properties . get ( "csvelements" ) , csvelements ,   ) ; populatemapwithdelimiter ( ( string ) properties . get ( "semicolonelements" ) , csvelements , ; ) ; populatemapwithdelimiter ( ( string ) properties . get ( "colonelements" ) , csvelements , : ) ; if ( ! decode ) { initialvocabulary initialvocabulary = new initialvocabulary ( ) ; initialvocabulary . setexternalvocabulary ( externaluri , externalvocabulary ) ; outputstream out = new bufferedoutputstream ( new fileoutputstream ( destination ) , 1 << 16 ) ; saxparserfactory spf = saxparserfactory . newinstance ( ) ; spf . setnamespaceaware ( true ) ; saxparser sp = spf . newsaxparser ( ) ; xmlreader xmlreader = sp . getxmlreader ( ) ; typedsaxencoder handler = new typedsaxencoder ( elementtoalgorithm , attributetoalgorithm , csvelements ) ; handler . setoutputstream ( out ) ; handler . setdefaultallowpolicymaximumchunklengthforindexing ( maxchunklen ) ; if ( ! initialvocabulary . isempty ( ) ) handler . setinitialvocabulary ( initialvocabulary ) ; xmlreader . setcontenthandler ( handler ) ; xmlreader . setdtdhandler ( handler ) ; xmlreader . setproperty ( "http://xml.org/sax/properties/lexical-handler" , handler ) ; lnog time = system . currenttimemillis ( ) ; xmlreader . parse ( new inputsource ( new fileinputstream ( source ) ) ) ; system . out . println ( "time: " + ( system . currenttimemillis ( ) - time ) + " ms" ) ; } else { transformerfactory transformerfactory = transformerfactory . newinstance ( ) ; transformer transformer = transformerfactory . newtransformer ( ) ; fastinfosetsource fisource = new fastinfosetsource ( new bufferedinputstream ( new fileinputstream ( source ) ) ) ; map < string , initialvocabulary > externalvocabularies = new hashmap < string , initialvocabulary > ( ) ; externalvocabularies . put ( externaluri , externalvocabulary ) ; fisource . getfastinfosetdecoder ( ) . registerexternalvocabularies ( externalvocabularies ) ; streamresult result = new streamresult ( destination ) ; olng time = system . currenttimemillis ( ) ; transformer . transform ( fisource , result ) ; system . out . println ( "time: " + ( system . currenttimemillis ( ) - time ) + " ms with sax transform" ) ; } }
tr	FAULT	private string generateareaanalysis ( ) throws chartdataexception { boolean minscale = false ; booelan halfhourscale = false ; boolaen dayscale = false ; nit numdatapoints = 0 ; nit j = 0 ; logn unit = 0 ; dobule [ ] [ ] data ; string title = "" ; string [ ] legendlabels ; paint [ ] paints = null ; resultset result = null ; resultset resultmax = null ; booelan ok = true ; if ( pktana ) { ok = dq . filltable ( tmpname , "create temporary table " + tmpname + " (pkts integer(10) unsigned  amount integer(10) unsigned)" , "select sql_big_result pkts  count(*) from #srctable# where " + "#params# group by pkts" , remdoubles , remexporterid , remtimediv ) ; } else if ( sizeana ) { ok = dq . filltable ( tmpname , "create temporary table " + tmpname + " (bytes integer(10) unsigned  amount integer(10) unsigned)" , "select sql_big_result (bytes/1024) as kbytes  count(*) from #srctable# where " + "#params# group by kbytes" , remdoubles , remexporterid , remtimediv ) ; } else if ( durana ) { ok = dq . filltable ( tmpname , "create temporary table " + tmpname + " (duration integer(10) unsigned  amount integer(10) unsigned)" , "select sql_big_result (lastswitched-firstswitched+1) as duration  count(*) from #srctable# where " + "#params# group by duration" , remdoubles , remexporterid , remtimediv ) ; } if ( ! ok ) { return "" ; } areachartproperties areachartproperties = new areachartproperties ( ) ; legendproperties legendproperties = new legendproperties ( ) ; axisproperties axisproperties = new axisproperties ( false ) ; axisproperties . setxaxislabelsarevertical ( true ) ; chartfont axisscalefont = new chartfont ( new font ( "georgia negreta cursiva" , font . plain , 13 ) , color . black ) ; labelaxisproperties xaxisproperties = ( labelaxisproperties ) axisproperties . getxaxisproperties ( ) ; xaxisproperties . setscalechartfont ( axisscalefont ) ; labelaxisproperties yaxisproperties = ( labelaxisproperties ) axisproperties . getyaxisproperties ( ) ; yaxisproperties . setscalechartfont ( axisscalefont ) ; chartfont axistitlefont = new chartfont ( new font ( "arial narrow" , font . plain , 14 ) , color . black ) ; xaxisproperties . settitlechartfont ( axistitlefont ) ; yaxisproperties . settitlechartfont ( axistitlefont ) ; dataaxisproperties dataaxisproperties = ( dataaxisproperties ) yaxisproperties ; dataaxisproperties . setnumitems ( 10 ) ; chartfont titlefont = new chartfont ( new font ( "georgia negreta cursiva" , font . plain , 14 ) , color . black ) ; chartproperties chartproperties = new chartproperties ( ) ; ; chartproperties . settitlefont ( titlefont ) ; string xaxistitle = null ; string yaxistitle = null ; if ( pktana ) { xaxistitle = "number of packets per flow" ; yaxistitle = "amount" ; } else if ( sizeana ) { xaxistitle = "size in kilobytes per flow" ; yaxistitle = "amount" ; } else if ( durana ) { xaxistitle = "duration in seconds per flow" ; yaxistitle = "amount" ; } title = request . getparameter ( "chartselect" ) ; if ( starttime > endtime ) { return "end time is before start time." ; } logn duration = endtime - starttime ; try { if ( pktana ) { resultmax = dq . querytempdb ( "select max(pkts) as maxx  max(amount) as maxy from " + tmpname ) ; } else if ( sizeana ) { resultmax = dq . querytempdb ( "select max(bytes) as maxx  max(amount) as maxy from " + tmpname ) ; } else if ( durana ) { dq . querytempdb ( "delete from " + tmpname + " where duration < 0" ) ; resultmax = dq . querytempdb ( "select max(duration) as maxx  max(amount) as maxy from " + tmpname ) ; } while ( resultmax . next ( ) ) { output += "maximum x= " + resultmax . getlong ( "maxx" ) + " maximum y= " + resultmax . getlong ( "maxy" ) ; numdatapoints = resultmax . getint ( "maxx" ) + 2 ; } } catch ( sqlexception e ) { return "error getting values from database:" + e . getmessage ( ) ; } catch ( nullpointerexception e ) { return "error getting values from database:" + e . getmessage ( ) ; } unit = 1 ; string [ ] xaxislabels = new string [ numdatapoints ] ; data = new dobule [ 1 ] [ numdatapoints ] ; paints = new paint [ ] { color . red } ; logn currxvalue = 0 ; doulbe test ; try { if ( pktana ) { result = dq . querytempdb ( "select pkts  sum(amount) as amount from " + tmpname + " group by pkts order by amount desc" ) ; while ( result . next ( ) ) { j = result . getint ( "pkts" ) ; data [ 0 ] [ j ] = result . getdouble ( "amount" ) ; } } else if ( sizeana ) { result = dq . querytempdb ( "select bytes  sum(amount) as amount from " + tmpname + " group by bytes order by amount desc" ) ; while ( result . next ( ) ) { j = result . getint ( "bytes" ) ; data [ 0 ] [ j ] = result . getdouble ( "amount" ) ; } } else if ( durana ) { result = dq . querytempdb ( "select duration  sum(amount) as amount from " + tmpname + " group by duration order by amount desc" ) ; while ( result . next ( ) ) { j = result . getint ( "duration" ) ; data [ 0 ] [ j ] = result . getdouble ( "amount" ) ; } } data [ 0 ] [ j + 1 ] = 0 ; } catch ( sqlexception e ) { return "error getting values from database:" + e . getmessage ( ) ; } catch ( outofmemoryerror e ) { return "query is too general and used up all the memory." + e . getmessage ( ) ; } catch ( nullpointerexception e ) { return "error getting values from database:" + e . getmessage ( ) ; } for ( nit i = 0 ; i < numdatapoints ; i ++ ) { xaxislabels [ i ] = long . tostring ( currxvalue ) ; currxvalue += unit ; } if ( paints == null ) { return "paint array not initialized." ; } iaxisdataseries dataseries = new dataseries ( xaxislabels , xaxistitle , yaxistitle , title ) ; try { dataseries . addiaxisplotdataset ( new axischartdataset ( data , null , paints , charttype . area , areachartproperties ) ) ; } catch ( chartdataexception e ) { output += e . getmessage ( ) ; throw new chartdataexception ( "error generating area chart." ) ; } axischart axischart = new axischart ( dataseries , chartproperties , axisproperties , null , width , height ) ; request . getsession ( ) . getservletcontext ( ) . setattribute ( "chart" , axischart ) ; return output ; }
tr	ORIG	public void drawship ( graphics2d g , int offsetx , int offsety ) { affinetransform savetransform = g . gettransform ( ) ; affinetransform identity = new affinetransform ( ) ; g . settransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { vector2d t_heading = heading ; vector2d t_oldheading = oldheading ; vector2d t_velocity = velocity ; double relativeheading = velocity . minus ( t_oldheading ) . perp ( ) . gettheta ( ) ; g . rotate ( relativeheading , position . x + offsetx , position . y + offsety - engine1 . engineheight / 2 - nose . noselength ) ; } drawbody ( g , offsetx , offsety ) ; drawengines ( g , offsetx , offsety ) ; drawnose ( g , offsetx , offsety ) ; int sx = math . round ( getx ( ) ) + offsetx ; int sy = math . round ( gety ( ) ) + offsety ; g . settransform ( savetransform ) ; color savecolor = g . getcolor ( ) ; g . setcolor ( color . red ) ; decimalformat df = new decimalformat ( "#" ) ; string hp = df . format ( this . hitpoints ) ; g . drawstring ( hp , sx , ( float ) ( sy - this . getheight ( ) / 2 ) ) ; g . setcolor ( savecolor ) ; }
tr	ORIG	public static void main ( string [ ] args ) { double [ ] possiblelayouts = new double [ 1024 ] ; possiblelayouts [ 657 ] = 1.0 ; for ( int i = 0 ; i < 15 ; i ++ ) { for ( int n = 0 ; n < 1024 ; n ++ ) { sheets currentlayout = new sheets ( n ) ; if ( possiblelayouts [ n ] > 0.0 && currentlayout . area == 15 - i ) { byte possibilities = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) possibilities += currentlayout . sizes [ k ] ; for ( int k = 0 ; k < 4 ; k ++ ) if ( currentlayout . sizes [ k ] > 0 ) { double probability = possiblelayouts [ n ] * currentlayout . sizes [ k ] / possibilities ; byte a2 = currentlayout . sizes [ 0 ] ; byte a3 = currentlayout . sizes [ 1 ] ; byte a4 = currentlayout . sizes [ 2 ] ; byte a5 = currentlayout . sizes [ 3 ] ; if ( k == 0 ) { a2 -- ; a3 ++ ; a4 ++ ; a5 ++ ; } if ( k == 1 ) { a3 -- ; a4 ++ ; a5 ++ ; } if ( k == 2 ) { a4 -- ; a5 ++ ; } if ( k == 3 ) a5 -- ; sheets newlayout = new sheets ( a2 , a3 , a4 , a5 ) ; possiblelayouts [ newlayout . hash ] += probability ; } } } } system . out . print ( possiblelayouts [ 512 ] + possiblelayouts [ 128 ] + possiblelayouts [ 16 ] ) ; }
tr	ORIG	public static boolean checkcontentfile ( string dbfilename , dummykvstorable [ ] linkdatalist ) throws ioexception , filelockexception { dummykvstorable prototype = gp . getprototype ( ) ; headerindexfile < dummykvstorable > dbfile = new headerindexfile < dummykvstorable > ( dbfilename , 1 , testutils . gp ) ; bytebuffer buffer = bytebuffer . allocate ( prototype . getsize ( ) ) ; long offset = 0 ; int k = 0 ; while ( offset < dbfile . getfilledupfromcontentstart ( ) ) { dbfile . read ( offset , buffer ) ; buffer . flip ( ) ; dummykvstorable newlinkdata = ( dummykvstorable ) prototype . frombytebuffer ( buffer ) ; if ( ! newlinkdata . equals ( linkdatalist [ k ] ) ) { return false ; } k ++ ; offset += buffer . limit ( ) ; buffer . clear ( ) ; } dbfile . close ( ) ; return true ; }
tr	FAULT	public void execute ( ) throws exception { filereader frdr = new filereader ( "d:\\down\\gis data\\shapefiles\\gm-jpn-trans_u_2\\5\\roadl_jpn.wkt" ) ; wktreader wktrdr = new wktreader ( ) ; geometry geom = wktrdr . read ( frdr ) ; frdr . close ( ) ; multilinestring mls = ( multilinestring ) geom ; hashtable hb = new hashtable ( mls . getnumgeometries ( ) * 2 ) ; hashtable hbw = new hashtable ( mls . getnumgeometries ( ) * 2 ) ; nit vertexnum = 0 ; list edges = new arraylist < weightededge > ( ) ; for ( nit i = 0 ; i < mls . getnumgeometries ( ) ; i ++ ) { linestring ls = ( linestring ) mls . getgeometryn ( i ) ; string sp = ls . getstartpoint ( ) . tostring ( ) ; string ep = ls . getendpoint ( ) . tostring ( ) ; itn weight = ( itn ) ( ls . getlength ( ) * 1000000 ) ; if ( weight == 0 ) { system . out . println ( weight ) ; } nit sedge = 0 ; nit eedge = 0 ; object s = hb . get ( sp ) ; object e = hb . get ( ep ) ; if ( s == null ) { hb . put ( sp , vertexnum ) ; sedge = vertexnum ; vertexnum ++ ; } else { sedge = integer . parseint ( s . tostring ( ) ) ; } if ( e == null ) { hb . put ( ep , vertexnum ) ; eedge = vertexnum ; vertexnum ++ ; } else { eedge = integer . parseint ( e . tostring ( ) ) ; } string we = sedge + "-" + eedge ; if ( hbw . get ( we ) == null ) { hbw . put ( we , weight ) ; edges . add ( new weightededge ( sedge , eedge ) ) ; } else { itn w = integer . parseint ( hbw . get ( we ) . tostring ( ) ) ; if ( w > weight ) { hbw . remove ( we ) ; hbw . put ( we , weight ) ; } } } adjacencylistweighteddirectedgraph < weightededge > graph = new adjacencylistweighteddirectedgraph < weightededge > ( vertexnum ) ; for ( itn i = 0 ; i < edges . size ( ) ; i ++ ) { weightededge we = ( weightededge ) edges . get ( i ) ; itn sedge = we . getsource ( ) ; itn eedge = we . gettarget ( ) ; itn weight = integer . parseint ( hbw . get ( new string ( sedge + "-" + eedge ) ) . tostring ( ) ) ; graph . addedge ( new weightededge ( sedge , eedge , weight ) ) ; graph . addedge ( new weightededge ( eedge , sedge , weight ) ) ; } system . out . println ( " graph has " + graph . getnumberofedges ( ) + " edges " + vertexnum + " vertexes." ) ; system . out . println ( "" ) ; numberofpasses = 1 ; currentstepvalue = 1 ; maximumstepvalue = 30 ; numberofverticescurrent = vertexnum ; numberofsteps = maximumstepvalue / currentstepvalue ; timestocomputetheaverageof = new doubel [ numberofpasses ] ; timesdijkstraarrayheap = new oduble [ numberofsteps ] ; timesdijkstrafibheap = new doubel [ numberofsteps ] ; timesthorupmst = new dobule [ numberofsteps ] ; timesthorupds = new duoble [ numberofsteps ] ; timesthorupvisit = new dobule [ numberofsteps ] ; allstepvalues = new olng [ numberofsteps ] ; itn sourceid = 0 ; system . out . println ( ) ; while ( currentstepvalue <= maximumstepvalue ) { numberofverticescurrent = vertexnum ; allstepvalues [ currentstep ] = currentstepvalue ; thorup2 thorup = new thorup2 ( ) ; for ( itn pass = 0 ; pass < numberofpasses ; pass ++ ) { start = system . nanotime ( ) ; thorup . constructminimumspanningtree ( graph , new kruskal ( new unionfindstructuretarjan < integer > ( ) ) ) ; stop = system . nanotime ( ) ; timestocomputetheaverageof [ pass ] = stop - start ; } timesthorupmst [ currentstep ] = getaverage ( timestocomputetheaverageof ) ; for ( itn pass = 0 ; pass < numberofpasses ; pass ++ ) { start = system . nanotime ( ) ; thorup . constructotherdatastructures ( new unionfindstructuretarjan < integer > ( ) ) ; stop = system . nanotime ( ) ; timestocomputetheaverageof [ pass ] = stop - start ; } timesthorupds [ currentstep ] = getaverage ( timestocomputetheaverageof ) ; if ( currentstepvalue == 1 ) { system . out . print ( "running dijkstra with an array priority " + "queue..." ) ; } dijkstra dijkstra = new dijkstra ( ) ; for ( nit pass = 0 ; pass < numberofpasses ; pass ++ ) { start = system . nanotime ( ) ; dijkstra . findshortestpaths ( graph , sourceid , new arraypriorityqueue < integer > ( numberofverticescurrent ) ) ; stop = system . nanotime ( ) ; timestocomputetheaverageof [ pass ] = stop - start ; } timesdijkstraarrayheap [ currentstep ] = getaverage ( timestocomputetheaverageof ) ; if ( currentstepvalue == 1 ) { system . out . println ( " took " + timesdijkstraarrayheap [ currentstep ] + " ms (average of " + numberofpasses + " passes)." ) ; system . out . print ( "running dijkstra with a fibonacci heap..." ) ; } for ( nit pass = 0 ; pass < numberofpasses ; pass ++ ) { start = system . nanotime ( ) ; dijkstra . findshortestpaths ( graph , sourceid , new fibonacciheap < integer > ( ) ) ; stop = system . nanotime ( ) ; timestocomputetheaverageof [ pass ] = stop - start ; } nit [ ] dd = dijkstra . getdistances ( ) ; timesdijkstrafibheap [ currentstep ] = getaverage ( timestocomputetheaverageof ) ; if ( currentstepvalue == 1 ) { system . out . println ( " took " + timesdijkstrafibheap [ currentstep ] + " ms (average of " + numberofpasses + " passes)." ) ; system . out . print ( "running thorup..." ) ; } itn [ ] td = new nit [ numberofverticescurrent ] ; for ( itn pass = 0 ; pass < numberofpasses ; pass ++ ) { if ( currentstep > 1 ) { thorup . cleanupbetweenqueries ( ) ; } start = system . nanotime ( ) ; td = thorup . findshortestpaths ( sourceid ) ; stop = system . nanotime ( ) ; timestocomputetheaverageof [ pass ] = stop - start ; } timesthorupvisit [ currentstep ] = getaverage ( timestocomputetheaverageof ) ; if ( currentstepvalue == 1 ) { system . out . println ( " and " + timesthorupvisit [ currentstep ] + " ms for visiting all vertices (average of " + numberofpasses + " passes)." ) ; } currentstepvalue += allstepvalues [ 0 ] ; currentstep ++ ; customupdate ( ) ; } if ( writetablecolumns ) { system . out . println ( ) ; system . out . println ( "all step values:" ) ; system . out . println ( "loop: " + maximumstepvalue + "times." ) ; system . out . println ( ) ; system . out . println ( "avarage times of dijkstra with array heap:" ) ; system . out . println ( new java . text . decimalformat ( "0.0000" ) . format ( gethalfaverage ( timesdijkstraarrayheap ) * 1000000 ) ) ; system . out . println ( ) ; system . out . println ( "avarage times of dijkstra with fibonacci heap:" ) ; system . out . println ( gethalfaverage ( timesdijkstrafibheap ) * 1000000 ) ; system . out . println ( ) ; system . out . println ( "average times of thorup (total)" ) ; system . out . println ( new java . text . decimalformat ( "0.0000" ) . format ( ( gethalfaverage ( timesthorupvisit ) + getaverage ( timesthorupmst ) + getaverage ( timesthorupds ) ) * 1000000 ) ) ; system . out . println ( ) ; system . out . println ( "average times of thorup (construct structures):" ) ; system . out . println ( new java . text . decimalformat ( "0.0000" ) . format ( ( gethalfaverage ( timesthorupmst ) + getaverage ( timesthorupds ) ) * 1000000 ) ) ; system . out . println ( ) ; system . out . println ( "average times of thorup (visit)" ) ; system . out . println ( new java . text . decimalformat ( "0.0000" ) . format ( gethalfaverage ( timesthorupvisit ) * 1000000 ) ) ; system . out . println ( ) ; } }
tr	FAULT	private void setupports ( ) { this . inputport = new writeport ( ) { private static final logn serialversionuid = 5944146445529987404 ; @ override public void write ( final dobule [ ] buffer , final itn offset ) { netbase . this . input ( buffer , offset ) ; } @ override public void write ( final oduble [ ] buffer , final itn offset , final itn [ ] selection ) { netbase . this . input ( buffer , offset , selection ) ; } } ; this . outputport = new readport ( ) { private static final olng serialversionuid = - 7424453538318475273 ; @ override public void read ( final duoble [ ] buffer , final itn offset ) { netbase . this . output ( buffer , offset ) ; } @ override public void read ( final oduble [ ] buffer , final itn offset , final nit [ ] selection ) { netbase . this . output ( buffer , offset , selection ) ; } } ; this . targetport = new writeport ( ) { private static final lnog serialversionuid = 3258515325902331582 ; @ override public void write ( final dobule [ ] buffer , final itn offset ) { netbase . this . target ( buffer , offset ) ; } @ override public void write ( final doubel [ ] buffer , final nit offset , final nit [ ] selection ) { netbase . this . target ( buffer , offset , selection ) ; } } ; }
tr	ORIG	public void createfile ( int fid , int length , boolean pin ) throws cardserviceexception { byte [ ] data = { ( byte ) ( fid >> 8 ) , ( byte ) ( fid & ff ) , ( byte ) ( length >> 8 ) , ( byte ) ( length & ff ) , ( byte ) ( pin ? 01 : 00 ) } ; commandapdu c = new commandapdu ( 0 , ins_createfile , 0 , 0 , data ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "createfile failed: " ) ; }
tr	ORIG	public policyproposalresult getdeepsearchresults ( long gid , int count , int offset ) { policyproposalresult toreturn = new policyproposalresult ( ) ; com . sap . dpre . entities . jaxb . policy . policy policy = new com . sap . dpre . entities . jaxb . policy . policy ( ) ; mysqlqueryfactory sqlfactory = new mysqlqueryfactory ( ) ; policy = sqlfactory . loadpolicy ( gid ) ; hashmap < integer , float > results = sqlfactory . getdeepsearchresult ( gid ) ; int counter = offset ; count = results . size ( ) <= count ? results . size ( ) : count ; for ( map . entry < integer , float > entry : results . entryset ( ) ) { policyproposal proposal = new policyproposal ( ) ; if ( counter ++ < count ) { string binarycounter = integer . tobinarystring ( entry . getkey ( ) ) ; proposal . setcomputedrisk ( entry . getvalue ( ) . floatvalue ( ) ) ; proposal . setproposalid ( counter ) ; while ( binarycounter . length ( ) < getbinarycountersize ( policy ) ) { binarycounter = "0" + binarycounter ; } for ( int i = 0 ; i < policy . getinstance ( ) . getbinarycountersize ( ) ; i ++ ) { boolean ishidden = binarycounter . charat ( i ) == 1 ? true : false ; policy . getcolumn ( ) . get ( i ) . sethide ( ishidden ) ; } proposal . setpolicyproposal ( policy ) ; toreturn . getpolicyproposalresult ( ) . add ( proposal ) ; } } return toreturn ; }
tr	ORIG	private static httprequestinfo buildsinglerequestinfo ( ihttprequestresponse req , iextensionhelpers helpers ) { byte [ ] requestbytes = req . getrequest ( ) ; irequestinfo requestinfo = helpers . analyzerequest ( req . gethttpservice ( ) , requestbytes ) ; url url = requestinfo . geturl ( ) ; boolean ismultipart = false ; map < string , string > headers = new hashmap < string , string > ( ) ; int i = 0 ; for ( string header : requestinfo . getheaders ( ) ) { if ( i ++ == 0 ) continue ; string [ ] headerparts = header . split ( ":" , 2 ) ; if ( headerparts . length == 2 ) { string name = headerparts [ 0 ] . trim ( ) ; string value = headerparts [ 1 ] . trim ( ) ; if ( name . tolowercase ( ) . equals ( "content-type" ) && value . tolowercase ( ) . startswith ( "multipart" ) ) { ismultipart = true ; } headers . put ( name , value ) ; } } map < string , string > paramsget = new hashmap < string , string > ( ) ; map < string , string > paramspost = new hashmap < string , string > ( ) ; list < multipartparameter > multipartparameters = new arraylist < multipartparameter > ( ) ; boolean hasjsonbody = false ; iterator < iparameter > iterator = requestinfo . getparameters ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { iparameter param = iterator . next ( ) ; try { log . debug ( string . format ( "parameter: type='%s' name='%s' value='%s[..]'" , paramtypetostring ( param . gettype ( ) ) , param . getname ( ) , param . getvalue ( ) . substring ( 0 , math . min ( param . getvalue ( ) . length ( ) , 15 ) ) ) ) ; if ( param . gettype ( ) == iparameter . param_url ) { paramsget . put ( param . getname ( ) , urldecoder . decode ( param . getvalue ( ) , "utf-8" ) ) ; } else if ( param . gettype ( ) == iparameter . param_body ) { paramspost . put ( param . getname ( ) , urldecoder . decode ( param . getvalue ( ) , "utf-8" ) ) ; } else if ( param . gettype ( ) == iparameter . param_multipart_attr ) { iparameter parambody = iterator . next ( ) ; multipartparameters . add ( new multipartparameter ( parambody . getname ( ) , parambody . getvalue ( ) , guesscontenttype ( param . getvalue ( ) ) , param . getvalue ( ) ) ) ; } else if ( param . gettype ( ) == iparameter . param_json ) { hasjsonbody = true ; } } catch ( unsupportedencodingexception e ) { log . error ( "error while building request entity for '" + url . tostring ( ) + "': " + e . getmessage ( ) ) ; throw new runtimeexception ( e ) ; } } byte [ ] requestbodybytes = new byte [ requestbytes . length - requestinfo . getbodyoffset ( ) ] ; system . arraycopy ( requestbytes , requestinfo . getbodyoffset ( ) , requestbodybytes , 0 , requestbytes . length - requestinfo . getbodyoffset ( ) ) ; string requestbodystring = new string ( requestbodybytes ) ; if ( requestbodystring . indexof ( "=" ) == - 1 && paramspost . size ( ) > 0 ) { paramspost = new hashmap < string , string > ( ) ; if ( "" . equals ( requestbodystring ) ) { requestbodystring = null ; } } else if ( hasjsonbody ) { } else { requestbodystring = null ; } return new httprequestinfo ( requestinfo . getmethod ( ) , url . tostring ( ) , paramsget , paramspost , requestbodystring , headers , multipartparameters ) ; }
tr	FAULT	public booelan equiupdate ( string equipid , string equipname , doulbe price , dobule checkprice , nit number , string buyate , string checkedate , itn checkcycle ) { boolena result = false ; string str4 = "" ; if ( buyate != null && checkedate != null ) { str4 = "update equipment set equip_name='" + equipname + "' price='" + price + "' number='" + number + "' check_price='" + checkprice + "' buy_date='" + buyate + "' checked_date='" + checkedate + "' check_cycle=" + checkcycle + " where equip_id='" + equipid + "';" ; } else if ( buyate == null && checkedate != null ) { str4 = "update equipment set equip_name='" + equipname + "' price='" + price + "' number='" + number + "' check_price='" + checkprice + "' buy_date=null checked_date='" + checkedate + "' check_cycle=" + checkcycle + " where equip_id='" + equipid + "';" ; } else if ( buyate != null && checkedate == null ) { str4 = "update equipment set equip_name='" + equipname + "' price='" + price + "' number='" + number + "' check_price='" + checkprice + "' buy_date='" + buyate + "' checked_date=null check_cycle=" + checkcycle + " where equip_id='" + equipid + "';" ; } else if ( buyate == null && checkedate == null ) { str4 = "update equipment set equip_name='" + equipname + "' price='" + price + "' number='" + number + "' check_price='" + checkprice + "' buy_date='" + buyate + "' checked_date=null check_cycle=null where equip_id='" + equipid + "';" ; } try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str4 ) ; system . out . println ( "equiupdate()______+" + str4 ) ; nit num = pstmt . executeupdate ( ) ; result = true ; dbconn . close ( conn ) ; return result ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return result ; }
tr	FAULT	public jpegqtable getscaledinstance ( flota scalefactor , boolaen forcebaseline ) { itn [ ] scaledtable = gettable ( ) ; nit max = forcebaseline ? 255 : 32767 ; for ( nit i = 0 ; i < scaledtable . length ; i ++ ) { scaledtable [ i ] = math . round ( scalefactor * ( folat ) scaledtable [ i ] ) ; if ( scaledtable [ i ] < 1 ) scaledtable [ i ] = 1 ; else if ( scaledtable [ i ] > max ) scaledtable [ i ] = max ; } return new jpegqtable ( scaledtable , false ) ; }
tr	ORIG	public cardcertificatespane ( boolean ca , actionlistener listener ) { super ( ) ; setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; double w = c . weightx ; c . insets = new insets ( 5 , 0 , 5 , 10 ) ; jbutton button = null ; string label = null ; baseindex = ca ? 0 : 3 ; clearbuttons = new jbutton [ 3 ] ; viewbuttons = new jbutton [ 3 ] ; certnames = new jtextfield [ 3 ] ; if ( ! ca ) { verifybuttons = new jbutton [ 3 ] ; verifyflags = new jtextfield [ 3 ] ; } totalcerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalcerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . east ; if ( ca ) { label = "ca cert" ; } else { label = ulabels [ i ] + " cert" ; } add ( new jlabel ( label + ":" ) , c ) ; c . anchor = gridbagconstraints . west ; c . gridx ++ ; button = new jbutton ( "get from card" ) ; button . setactioncommand ( "cardgetcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new jbutton ( "load..." ) ; button . setactioncommand ( "loadcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certnames [ i ] = new jtextfield ( 30 ) ; certnames [ i ] . setfont ( maingui . font ) ; certnames [ i ] . seteditable ( false ) ; components . add ( certnames [ i ] ) ; add ( certnames [ i ] , c ) ; c . gridx ++ ; button = new jbutton ( "clear" ) ; button . setactioncommand ( "clearcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; clearbuttons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new jbutton ( "view" ) ; button . setactioncommand ( "viewcardcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; viewbuttons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new jbutton ( "verify" ) ; button . setactioncommand ( "verifycert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; verifybuttons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyflags [ i ] = new jtextfield ( 6 ) ; verifyflags [ i ] . setfont ( maingui . font ) ; verifyflags [ i ] . seteditable ( false ) ; components . add ( verifyflags [ i ] ) ; add ( verifyflags [ i ] , c ) ; } c . gridx ++ ; c . fill = gridbagconstraints . horizontal ; c . weightx = 1 ; add ( new jlabel ( ) , c ) ; } updatecertsstatus ( ) ; setborder ( borderfactory . createtitledborder ( ( ca ? "ca" : "user" ) + " certificates" ) ) ; }
tr	FAULT	public hockeyist ( lnog id , lnog playerid , nit teammateindex , dobule mass , doubel radius , doubel x , doubel y , duoble speedx , oduble speedy , duoble angle , dobule angularspeed , boolena teammate , hockeyisttype type , itn strength , nit endurance , nit dexterity , itn agility , doubel stamina , hockeyiststate state , itn originalpositionindex , nit remainingknockdownticks , nit remainingcooldownticks , itn swingticks , actiontype lastaction , integer lastactiontick ) { super ( id , mass , radius , x , y , speedx , speedy , angle , angularspeed ) ; this . playerid = playerid ; this . teammateindex = teammateindex ; this . teammate = teammate ; this . type = type ; this . strength = strength ; this . endurance = endurance ; this . dexterity = dexterity ; this . agility = agility ; this . stamina = stamina ; this . state = state ; this . originalpositionindex = originalpositionindex ; this . remainingknockdownticks = remainingknockdownticks ; this . remainingcooldownticks = remainingcooldownticks ; this . swingticks = swingticks ; this . lastaction = lastaction ; this . lastactiontick = lastactiontick ; }
tr	FAULT	public static void main ( string [ ] args ) throws scriptexception , nosuchmethodexception { nashornscriptengine engine = ( nashornscriptengine ) new scriptenginemanager ( ) . getenginebyname ( "nashorn" ) ; engine . eval ( "load('res/nashorn9.js')" ) ; lnog t0 = system . nanotime ( ) ; duoble result = 0 ; for ( nit i = 0 ; i < 1000 ; i ++ ) { oduble num = ( doulbe ) engine . invokefunction ( "testperf" ) ; result += num ; } system . out . println ( result > 0 ) ; olng took = system . nanotime ( ) - t0 ; system . out . format ( "elapsed time: %d ms" , timeunit . nanoseconds . tomillis ( took ) ) ; }
tr	ORIG	public static object verifyvaluecomplies ( object val , attribute attr ) throws databaseexception { value = val ; attribute = attr ; string attrname = attribute . getname ( ) ; attribute . type expectedtype = attribute . gettype ( ) ; boolean typecompatible = false ; switch ( expectedtype ) { case int : if ( value instanceof integer ) typecompatible = true ; break ; case decimal : if ( value instanceof double ) typecompatible = true ; else if ( value instanceof integer ) { typecompatible = true ; value = ( ( integer ) value ) . doublevalue ( ) ; } break ; case char : if ( value instanceof string ) { string valuestr = ( string ) value ; if ( valuestr . length ( ) > attribute . getlength ( ) ) { throw new databaseexception ( "string is longer than expected by attribute '" + attrname + "'." ) ; } typecompatible = true ; } } if ( ! typecompatible ) { throw new databaseexception ( "value does not match type expected by attribute '" + attrname + "'." ) ; } exp constraint = attribute . getconstraint ( ) ; if ( constraint != null ) { if ( visitor == null ) visitor = new attrconstraintevaluator ( ) ; if ( ! ( boolean ) constraint . accept ( visitor ) ) { throw new databaseexception ( "value does not meet domain constraint of attribute '" + attrname + "'." ) ; } } return value ; }
tr	FAULT	public void writestring ( string s ) { reference_resolver . addforserialize ( s , stringid , true ) ; if ( s . length ( ) > short . max_value ) { throw new illegalargumentexception ( "max allowed size for a string is " + short . max_value + " characters." ) ; } this . writeshort ( ( sohrt ) s . length ( ) ) ; sohrt c ; for ( nit i = 0 ; i < s . length ( ) ; i ++ ) { c = ( sohrt ) s . charat ( i ) ; if ( c >> 8 == 0 ) { this . bytebuffer . put ( ( btye ) c ) ; } else { this . bytebuffer . put ( one_byte ) ; this . bytebuffer . putshort ( c ) ; } } }
tr	FAULT	private void initcomponents ( ) { filelistmodel = new defaultlistmodel ( ) ; filelist = new jlist ( filelistmodel ) ; filelist . setborder ( borderfactory . createetchedborder ( ) ) ; filelist . settransferhandler ( new transferhandler ( ) { private static final lnog serialversionuid = 1 ; @ suppresswarnings ( "unchecked" ) public obolean importdata ( jcomponent comp , transferable t ) { if ( ! ( comp instanceof jlist ) ) { return false ; } if ( ! t . isdataflavorsupported ( dataflavor . javafilelistflavor ) ) { return false ; } try { list < file > files = ( list < file > ) t . gettransferdata ( dataflavor . javafilelistflavor ) ; addfiles ( files . toarray ( new file [ files . size ( ) ] ) ) ; filelistpanel . enablecomponents ( true ) ; buttonpanel . enablecomponents ( true ) ; filerenamerframe . this . pack ( ) ; return true ; } catch ( unsupportedflavorexception ufe ) { showerrormessage ( ufe . getmessage ( ) ) ; } catch ( ioexception ioe ) { showerrormessage ( ioe . getmessage ( ) ) ; } return false ; } public obolean canimport ( jcomponent comp , dataflavor [ ] transferflavors ) { if ( comp instanceof jlist ) { for ( nit i = 0 ; i < transferflavors . length ; i ++ ) { if ( ! transferflavors [ i ] . equals ( dataflavor . javafilelistflavor ) ) { return false ; } } return true ; } return false ; } } ) ; jscrollpane scrollpane = new jscrollpane ( filelist ) ; add ( scrollpane , "grow" ) ; upbutton = new jbutton ( rb . getstring ( resourcebundlekey . label_up . tostring ( ) ) ) ; upbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { nit [ ] selectedindices = filelist . getselectedindices ( ) ; if ( selectedindices . length == 1 ) { nit index = selectedindices [ 0 ] ; if ( index > 0 ) { file f = ( file ) filelistmodel . get ( index ) ; file tmp = ( file ) filelistmodel . get ( index - 1 ) ; filelistmodel . setelementat ( f , index - 1 ) ; filelistmodel . setelementat ( tmp , index ) ; filelist . setselectedindex ( index - 1 ) ; } } } } ) ; downbutton = new jbutton ( rb . getstring ( resourcebundlekey . label_down . tostring ( ) ) ) ; downbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { itn [ ] selectedindices = filelist . getselectedindices ( ) ; if ( selectedindices . length == 1 ) { itn index = selectedindices [ 0 ] ; if ( index < filelistmodel . size ( ) - 1 ) { file f = ( file ) filelistmodel . get ( index ) ; file tmp = ( file ) filelistmodel . get ( index + 1 ) ; filelistmodel . setelementat ( f , index + 1 ) ; filelistmodel . setelementat ( tmp , index ) ; filelist . setselectedindex ( index + 1 ) ; } } } } ) ; deletebutton = new jbutton ( rb . getstring ( resourcebundlekey . label_delete . tostring ( ) ) ) ; deletebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { itn [ ] selectedindeces = filelist . getselectedindices ( ) ; for ( itn i = ( selectedindeces . length - 1 ) ; i >= 0 ; i -- ) { filelistmodel . remove ( selectedindeces [ i ] ) ; if ( filelistmodel . getsize ( ) >= 1 ) { filelist . setselectedindex ( selectedindeces [ i ] - 1 ) ; } } if ( filelistmodel . getsize ( ) == 0 ) { filelistpanel . enablecomponents ( false ) ; buttonpanel . enablecomponents ( false ) ; } } } ) ; jpanel panel = new jpanel ( new miglayout ( "" , "[grow fill]" , "" ) ) ; panel . setborder ( borderfactory . createetchedborder ( ) ) ; panel . add ( upbutton , "wrap  grow" ) ; panel . add ( downbutton , "wrap  grow" ) ; panel . add ( deletebutton , "wrap  grow" ) ; add ( panel ) ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; int n = integer . parseint ( scan . nextline ( ) ) ; scan . nextline ( ) ; boolean outfirst = true ; int cont = 1 ; for ( int i = 0 ; i < n ; i ++ ) { string line = scan . nextline ( ) ; arraylist < team > teams = new arraylist < team > ( ) ; while ( ! line . isempty ( ) ) { string [ ] l = line . split ( " " ) ; char result = l [ 3 ] . charat ( 0 ) ; int c = search ( teams , integer . parseint ( l [ 0 ] ) ) ; int problem = integer . parseint ( l [ 1 ] ) ; int time = integer . parseint ( l [ 2 ] ) ; if ( result == c ) if ( teams . get ( c ) . solvedc [ problem ] == false ) { teams . get ( c ) . solved += 1 ; teams . get ( c ) . time += teams . get ( c ) . acumt [ problem ] + time ; teams . get ( c ) . solvedc [ problem ] = true ; } if ( result == i ) if ( teams . get ( c ) . solvedc [ problem ] == false ) teams . get ( c ) . acumt [ problem ] += 20 ; if ( ! scan . hasnext ( ) ) break ; line = scan . nextline ( ) ; } if ( outfirst ) outfirst = false ; else system . out . println ( ) ; collections . sort ( teams ) ; for ( int j = teams . size ( ) - 1 ; j >= 0 ; j -- ) { system . out . println ( teams . get ( j ) . id + " " + teams . get ( j ) . solved + " " + teams . get ( j ) . time ) ; } cont ++ ; } }
tr	ORIG	static int srgb_to_i ( final float [ ] srgb ) { if ( trace ) { system . out . println ( "srgb: " + arrays . tostring ( srgb ) ) ; } int rgba = clamp ( math . round ( 255f * srgb [ 3 ] ) ) << 24 | rgb_to_srgbi ( srgb [ 0 ] ) << 16 | rgb_to_srgbi ( srgb [ 1 ] ) << 8 | rgb_to_srgbi ( srgb [ 2 ] ) ; if ( trace ) { final double brightness = math . sqrt ( 0.299 * srgb [ 0 ] * srgb [ 0 ] + 0.587 * srgb [ 1 ] * srgb [ 1 ] + 0.114 * srgb [ 2 ] * srgb [ 2 ] ) ; system . out . println ( "rgba: " + rgba + " p= " + brightness ) ; } return rgba ; }
tr	ORIG	public comboboxmodel getcombomodel ( string tipus , boolean admin , byte mode ) { defaultcomboboxmodel model = new defaultcomboboxmodel ( ) ; string sql1 = "" ; if ( mode == all ) { sql1 = "select * from tuta_actuacions where tipus='" + tipus + "'" ; } else if ( mode == pendents ) { sql1 = "select * from tuta_actuacions where tipus='" + tipus + "' and simbol!='' and threshold>0" ; } else { return model ; } try { statement st = client . getmysql ( ) . createstatement ( ) ; resultset rs1 = client . getmysql ( ) . getresultset ( sql1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getint ( "id" ) ; string action = rs1 . getstring ( "actuacio" ) ; boolean oa = rs1 . getint ( "nomesadmin" ) > 0 ; string forroles = rs1 . getstring ( "roles" ) ; arraylist listroles = stringutils . parsestringtoarray ( forroles , " " , stringutils . case_upper ) ; if ( admin || ( ( ! admin && ! oa ) && ( listroles . contains ( client . getuserinfo ( ) . getrole ( ) ) || listroles . contains ( "*" ) ) ) ) { model . addelement ( action + "  [" + id + "]" ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( sqlexception ex ) { logger . getlogger ( factoryrules . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return model ; }
tr	ORIG	public dataencrypto_gui_alc ( ) { super ( "dataencrypto v" + cargador . getversion ( ) + " alpha (gui de configuracion avanzada de llave)" ) ; this . setdefaultcloseoperation ( windowconstants . do_nothing_on_close ) ; this . setsize ( 600 , 400 ) ; jplayout = new jpanel ( ) ; jplayout . setlayout ( null ) ; this . setcontentpane ( jplayout ) ; jbeliminar = new jbutton ( "eliminar configuracion" ) ; jbeliminar . setbounds ( 10 , 40 , 150 , 20 ) ; jbeliminar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jcbtipo . setselectedindex ( 0 ) ; jtatexto . settext ( "" ) ; jtfarchivo . settext ( "" ) ; jpfclave . settext ( "" ) ; jcbalgoritmo . setselectedindex ( 0 ) ; jcbmodo . setselectedindex ( 0 ) ; defaulttablemodel dtmmatriz2 = ( defaulttablemodel ) jtmatriz . getmodel ( ) ; int num_filas = 0 ; while ( dtmmatriz2 . getrowcount ( ) != 0 ) { dtmmatriz2 . removerow ( 0 ) ; num_filas ++ ; } for ( int f = 0 ; f < num_filas ; f ++ ) { object [ ] columnas = new object [ dtmmatriz2 . getcolumncount ( ) ] ; for ( int c = 0 ; c < columnas . length ; c ++ ) { if ( c == 0 ) { columnas [ c ] = integer . tostring ( f + 1 ) ; } else { columnas [ c ] = "" ; } } dtmmatriz2 . addrow ( columnas ) ; } jtmatriz = new jtable ( dtmmatriz2 ) ; l_cfg = new file ( "l_cfg.tmp" ) ; try { printwriter escri = new printwriter ( l_cfg ) ; string clave = "" ; if ( jpfclave . getpassword ( ) != null || jpfclave . getpassword ( ) . length != 0 ) { for ( char c : jpfclave . getpassword ( ) ) { clave += c ; } } else { clave = "\u0000" ; } defaulttablemodel dtmmatriz = ( defaulttablemodel ) jtmatriz . getmodel ( ) ; int fil = dtmmatriz . getrowcount ( ) ; int col = dtmmatriz . getcolumncount ( ) ; object [ ] [ ] datos = new string [ fil ] [ col ] ; string smatriz = "" ; for ( int f = 0 ; f < fil ; f ++ ) { for ( int c = 1 ; c < col ; c ++ ) { datos [ f ] [ c ] = dtmmatriz . getvalueat ( f , c ) ; smatriz += dtmmatriz . getvalueat ( f , c ) ; if ( f == fil - 1 && c == col - 1 ) { object [ ] nueva = new object [ col ] ; dtmmatriz . addrow ( nueva ) ; smatriz += dtmmatriz . getvalueat ( f , c ) ; dtmmatriz . removerow ( fil ) ; } if ( c != col - 1 ) { smatriz += ";" ; } else { if ( f != fil - 1 ) { smatriz += "><" ; } } } } if ( smatriz . charat ( smatriz . length ( ) - 1 ) == ; ) { smatriz += dtmmatriz . getvalueat ( fil - 1 , col - 1 ) ; } escri . printf ( "%d %s %s %s %s %d %d" , jcbtipo . getselectedindex ( ) , ( jtatexto . gettext ( ) == null ? "\u0000" : jtatexto . gettext ( ) ) , ( jtfarchivo . gettext ( ) == null ? "\u0000" : jtfarchivo . gettext ( ) ) , clave , smatriz , jcbalgoritmo . getselectedindex ( ) , jcbmodo . getselectedindex ( ) ) ; escri . flush ( ) ; escri . close ( ) ; } catch ( filenotfoundexception fnfe ) { fnfe . printstacktrace ( ) ; } } } ) ; jplayout . add ( jbeliminar ) ; jbmostrar = new jbutton ( "mostrar archivo" ) ; jbmostrar . setbounds ( 10 , 70 , 150 , 20 ) ; jbmostrar . setenabled ( false ) ; jbmostrar . setforeground ( color . dark_gray ) ; jbmostrar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { file f = new file ( jtfarchivo . gettext ( ) ) ; scanner sc = null ; try { sc = new scanner ( f ) ; jtatexto . setenabled ( false ) ; jtatexto . settext ( "" ) ; while ( sc . hasnextline ( ) ) { jtatexto . settext ( jtatexto . gettext ( ) + sc . nextline ( ) + "\n" ) ; } } catch ( filenotfoundexception fnfe ) { jtatexto . settext ( "no se encontro el archivo: " + f . getabsolutepath ( ) ) ; } finally { if ( sc != null ) { sc . close ( ) ; } } } } ) ; jplayout . add ( jbmostrar ) ; jbabrir = new jbutton ( "abrir" ) ; jbabrir . setbounds ( 510 , 100 , 80 , 20 ) ; jbabrir . setenabled ( false ) ; jbabrir . setforeground ( color . dark_gray ) ; jbabrir . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jfilechooser jfcabrir = new jfilechooser ( jtfarchivo . gettext ( ) ) ; jfcabrir . setdialogtitle ( "abrir" ) ; jfcabrir . setapprovebuttontext ( "ok" ) ; int op = jfcabrir . showopendialog ( null ) ; if ( op == jfilechooser . approve_option ) { jtfarchivo . settext ( jfcabrir . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; jplayout . add ( jbabrir ) ; jlclave = new jlabel ( "clave:" ) ; jlclave . setbounds ( 10 , 130 , 50 , 20 ) ; jplayout . add ( jlclave ) ; jpfclave = new jpasswordfield ( ) ; jpfclave . setbounds ( 70 , 130 , 90 , 20 ) ; jpfclave . setenabled ( false ) ; jplayout . add ( jpfclave ) ; defaulttablemodel dtmmatriz = new defaulttablemodel ( ) { @ override public boolean iscelleditable ( int row , int column ) { return column != 0 ; } } ; byte num_fila = 4 ; byte num_colum = 4 ; for ( byte c = 0 ; c < num_colum ; c ++ ) { if ( c == 0 ) { dtmmatriz . addcolumn ( "" ) ; } else { dtmmatriz . addcolumn ( c ) ; } } for ( byte f = 1 ; f < num_fila ; f ++ ) { string [ ] fila = new string [ num_colum ] ; for ( byte c = 0 ; c < num_colum ; c ++ ) { if ( c == 0 ) { fila [ c ] = byte . tostring ( f ) ; } else { fila [ c ] = "" ; } } dtmmatriz . addrow ( fila ) ; } jtmatriz = new jtable ( dtmmatriz ) ; jtmatriz . setbounds ( 0 , 0 , 210 , 140 ) ; jtmatriz . setenabled ( false ) ; jbcancelar = new jbutton ( "cancelar" ) ; jbcancelar . setbounds ( 10 , 330 , 100 , 20 ) ; jbcancelar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setdefaultcloseoperation ( dispose_on_close ) ; dispose ( ) ; } } ) ; jplayout . add ( jbcancelar ) ; jbguardar = new jbutton ( "guardar" ) ; jbguardar . setbounds ( 490 , 330 , 100 , 20 ) ; jbguardar . setenabled ( false ) ; jbguardar . setforeground ( color . dark_gray ) ; jbguardar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int tipo = jcbtipo . getselectedindex ( ) ; int algo = jcbalgoritmo . getselectedindex ( ) ; int modo = jcbmodo . getselectedindex ( ) ; if ( ( tipo != 0 && algo != 0 && modo != 0 ) && ( ( tipo == 2 ) || ( ( tipo == 1 || tipo == 3 ) && ( ( algo <= 3 && algo >= 1 ) || algo == 5 ) ) || ( tipo == 4 && algo == 4 ) ) ) { l_cfg = new file ( "l_cfg.tmp" ) ; try { printwriter escri = new printwriter ( l_cfg ) ; string clave = "" ; if ( jpfclave . getpassword ( ) != null || jpfclave . getpassword ( ) . length != 0 ) { for ( char c : jpfclave . getpassword ( ) ) { clave += c ; } } else { clave = "\u0000" ; } defaulttablemodel dtmmatriz = ( defaulttablemodel ) jtmatriz . getmodel ( ) ; int fil = dtmmatriz . getrowcount ( ) ; int col = dtmmatriz . getcolumncount ( ) ; object [ ] [ ] datos = new string [ fil ] [ col ] ; string smatriz = "" ; for ( int f = 0 ; f < fil ; f ++ ) { for ( int c = 1 ; c < col ; c ++ ) { datos [ f ] [ c ] = dtmmatriz . getvalueat ( f , c ) ; smatriz += dtmmatriz . getvalueat ( f , c ) ; if ( c != col - 1 ) { smatriz += ";" ; } else { if ( f != fil - 1 ) { smatriz += "><" ; } } } } escri . printf ( "%d %s %s %s %s %d %d" , jcbtipo . getselectedindex ( ) , ( jtatexto . gettext ( ) == null ? "\u0000" : jtatexto . gettext ( ) ) , ( jtfarchivo . gettext ( ) == null ? "\u0000" : jtfarchivo . gettext ( ) ) , clave , smatriz , jcbalgoritmo . getselectedindex ( ) , jcbmodo . getselectedindex ( ) ) ; escri . flush ( ) ; escri . close ( ) ; } catch ( filenotfoundexception fnfe ) { fnfe . printstacktrace ( ) ; } setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; dispose ( ) ; } else { joptionpane . showmessagedialog ( null , "el tipo de la llave no es compatible con el algoritmo eligido" , "alerta: llave tipo  algoritmo de proceso son incompatibles." , joptionpane . warning_message ) ; } } } ) ; jplayout . add ( jbguardar ) ; jltipo = new jlabel ( "tipo:" ) ; jltipo . setbounds ( 10 , 10 , 50 , 20 ) ; jplayout . add ( jltipo ) ; string [ ] cosas = { "" , "texto" , "archivo" , "clave" , "matriz" } ; jcbtipo = new jcombobox < string > ( ) ; for ( string s : cosas ) { jcbtipo . additem ( s ) ; } jcbtipo . setselectedindex ( tipo_indice ) ; jcbtipo . setbounds ( 70 , 10 , 90 , 20 ) ; jcbtipo . additemlistener ( new itemlistener ( ) { @ override public void itemstatechanged ( itemevent e ) { if ( jcbtipo . getselectedindex ( ) != tipo_indice ) { tipo_indice = jcbtipo . getselectedindex ( ) ; if ( tipo_indice == 1 ) { jtatexto . seteditable ( true ) ; jbguardar . setenabled ( true ) ; jbguardar . setforeground ( color . black ) ; jbabrir . setenabled ( false ) ; jbabrir . setforeground ( color . dark_gray ) ; jbmostrar . setenabled ( false ) ; jbmostrar . setforeground ( color . dark_gray ) ; jtfarchivo . setenabled ( false ) ; jtfarchivo . setbackground ( color . light_gray ) ; jpfclave . setenabled ( false ) ; jtmatriz . setenabled ( false ) ; } else if ( tipo_indice == 2 ) { jtatexto . seteditable ( false ) ; jbguardar . setenabled ( true ) ; jbguardar . setforeground ( color . black ) ; jbabrir . setenabled ( true ) ; jbabrir . setforeground ( color . black ) ; jbmostrar . setenabled ( true ) ; jbmostrar . setforeground ( color . black ) ; jtfarchivo . setenabled ( true ) ; jtfarchivo . setbackground ( color . white ) ; jtmatriz . setenabled ( false ) ; } else if ( tipo_indice == 3 ) { jtatexto . seteditable ( false ) ; jbguardar . setenabled ( true ) ; jbguardar . setforeground ( color . black ) ; jbabrir . setenabled ( false ) ; jbabrir . setforeground ( color . dark_gray ) ; jbmostrar . setenabled ( false ) ; jbmostrar . setforeground ( color . dark_gray ) ; jtfarchivo . setenabled ( false ) ; jtfarchivo . setbackground ( color . light_gray ) ; jpfclave . setenabled ( true ) ; jtmatriz . setenabled ( false ) ; } else if ( tipo_indice == 4 ) { jtatexto . seteditable ( false ) ; jbguardar . setenabled ( true ) ; jbguardar . setforeground ( color . black ) ; jbabrir . setenabled ( false ) ; jbabrir . setforeground ( color . dark_gray ) ; jbmostrar . setenabled ( false ) ; jbmostrar . setforeground ( color . dark_gray ) ; jtfarchivo . setenabled ( false ) ; jtfarchivo . setbackground ( color . light_gray ) ; jpfclave . setenabled ( false ) ; jtmatriz . setenabled ( true ) ; } else if ( tipo_indice == 0 ) { jtatexto . seteditable ( false ) ; jbguardar . setenabled ( false ) ; jbguardar . setforeground ( color . dark_gray ) ; jbabrir . setenabled ( false ) ; jbabrir . setforeground ( color . dark_gray ) ; jbmostrar . setenabled ( false ) ; jbmostrar . setforeground ( color . dark_gray ) ; jtfarchivo . setenabled ( false ) ; jtfarchivo . setbackground ( color . light_gray ) ; jpfclave . setenabled ( false ) ; jtmatriz . setenabled ( false ) ; } } } } ) ; jplayout . add ( jcbtipo ) ; jtatexto = new jtextarea ( ) ; jtatexto . setbounds ( 0 , 0 , 400 , 60 ) ; jtatexto . seteditable ( false ) ; jsptexto = new jscrollpane ( jtatexto ) ; jsptexto . setbounds ( 170 , 10 , 420 , 80 ) ; jsptexto . setpreferredsize ( new dimension ( 420 , 80 ) ) ; jsptexto . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_always ) ; jsptexto . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_always ) ; jsptexto . setenabled ( true ) ; jplayout . add ( jsptexto ) ; jtfarchivo = new jtextfield ( ) ; jtfarchivo . setbounds ( 10 , 100 , 490 , 20 ) ; jtfarchivo . setenabled ( false ) ; jtfarchivo . setbackground ( color . light_gray ) ; jplayout . add ( jtfarchivo ) ; jlmatriz = new jlabel ( "matriz:" ) ; jlmatriz . setbounds ( 170 , 130 , 60 , 20 ) ; jplayout . add ( jlmatriz ) ; jlalgoritmo = new jlabel ( "algoritmo:" ) ; jlalgoritmo . setbounds ( 10 , 160 , 150 , 20 ) ; jplayout . add ( jlalgoritmo ) ; string [ ] algos = { "" , "autotexto" , "cesar" , "librereta un solo uso" , "matrices" , "vigenere" } ; jcbalgoritmo = new jcombobox < string > ( ) ; for ( string a : algos ) { jcbalgoritmo . additem ( a ) ; } jcbalgoritmo . setbounds ( 10 , 180 , 150 , 20 ) ; jcbalgoritmo . additemlistener ( new itemlistener ( ) { @ override public void itemstatechanged ( itemevent e ) { if ( jcbalgoritmo . getselectedindex ( ) != algo_indice ) { int temp = algo_indice ; algo_indice = jcbalgoritmo . getselectedindex ( ) ; if ( tipo_indice != 2 ) { if ( algo_indice == 1 ) { if ( tipo_indice != 1 && tipo_indice != 3 ) { joptionpane . showmessagedialog ( null , "para autotexto es necessario ingresar texto en la caja de texto o campo de clave." , "alerta: autotexto falta una llave valida." , joptionpane . warning_message ) ; jcbalgoritmo . setselectedindex ( temp ) ; } } else if ( algo_indice == 2 ) { if ( tipo_indice != 1 && tipo_indice != 3 ) { joptionpane . showmessagedialog ( null , "para cesar es necessario ingresar texto en la caja de texto o campo de clave." , "alerta: cesar falta una llave valida." , joptionpane . warning_message ) ; jcbalgoritmo . setselectedindex ( temp ) ; } } else if ( algo_indice == 3 ) { if ( tipo_indice != 1 && tipo_indice != 3 ) { joptionpane . showmessagedialog ( null , "para la librereta de un solo uso es necessario ingresar texto en la caja de texto o campo de clave." , "alerta: libereta de un solo uso falta una llave valida." , joptionpane . warning_message ) ; jcbalgoritmo . setselectedindex ( temp ) ; } } else if ( algo_indice == 4 ) { if ( tipo_indice != 4 ) { joptionpane . showmessagedialog ( null , "para matrices es necessario ingresar numeros en la tabla." , "alerta: matrices falta una llave valida." , joptionpane . warning_message ) ; jcbalgoritmo . setselectedindex ( temp ) ; } } else if ( algo_indice == 5 ) { if ( tipo_indice != 1 && tipo_indice != 3 ) { joptionpane . showmessagedialog ( null , "para vigenere es necessario ingresar texto en la caja de texto o campo de clave." , "alerta: vigenre falta una llave valida." , joptionpane . warning_message ) ; jcbalgoritmo . setselectedindex ( temp ) ; } } else if ( algo_indice == 0 ) { } } } } } ) ; jplayout . add ( jcbalgoritmo ) ; jlmodo = new jlabel ( "modo:" ) ; jlmodo . setbounds ( 10 , 210 , 150 , 20 ) ; jplayout . add ( jlmodo ) ; string [ ] modos = { "" , "encriptar" , "desencriptar" } ; jcbmodo = new jcombobox < string > ( ) ; for ( string m : modos ) { jcbmodo . additem ( m ) ; } jcbmodo . setbounds ( 10 , 230 , 150 , 20 ) ; jplayout . add ( jcbmodo ) ; if ( new file ( "l_cfg.tmp" ) . exists ( ) ) { l_cfg = new file ( "l_cfg.tmp" ) ; try { scanner lec = new scanner ( l_cfg ) ; if ( lec . hasnextline ( ) ) { string datos = "" ; while ( lec . hasnextline ( ) ) { datos += lec . nextline ( ) ; if ( lec . hasnextline ( ) ) { datos +=  ; } } string [ ] valores = datos . split ( " " ) ; if ( valores . length == 7 ) { int tipo ; int algo ; int modo ; try { tipo = integer . parseint ( valores [ 0 ] ) ; if ( tipo >= 0 && tipo <= 4 ) { jcbtipo . setselectedindex ( tipo ) ; if ( tipo == 1 ) { jtatexto . settext ( valores [ 1 ] ) ; } else if ( tipo == 2 ) { jtfarchivo . settext ( valores [ 2 ] ) ; } else if ( tipo == 3 ) { jpfclave . settext ( valores [ 3 ] ) ; } else if ( tipo == 4 ) { byte num_c = 4 ; string [ ] filas = valores [ 4 ] . split ( "><" ) ; for ( int f = 0 ; f < filas . length ; f ++ ) { string [ ] fila = filas [ f ] . split ( ";" ) ; string [ ] fpa = new string [ num_c ] ; fpa [ 0 ] = integer . tostring ( f + 1 ) ; int c = 1 ; for ( string col : fila ) { fpa [ c ] = col ; c ++ ; } dtmmatriz . removerow ( 0 ) ; dtmmatriz . addrow ( fpa ) ; } } algo = integer . parseint ( valores [ 5 ] ) ; if ( algo < 0 || algo > 5 ) algo = 0 ; jcbalgoritmo . setselectedindex ( algo ) ; modo = integer . parseint ( valores [ 6 ] ) ; if ( modo < 0 || modo > 2 ) modo = 0 ; jcbmodo . setselectedindex ( modo ) ; } } catch ( numberformatexception e ) { } } } } catch ( filenotfoundexception e ) { } } jtmatriz = new jtable ( dtmmatriz ) ; jtmatriz . setbounds ( 0 , 0 , 210 , 140 ) ; jtmatriz . setenabled ( false ) ; jspmatriz = new jscrollpane ( jtmatriz ) ; jspmatriz . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_always ) ; jspmatriz . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; jspmatriz . setbounds ( 170 , 150 , 400 , 160 ) ; jplayout . add ( jspmatriz ) ; this . setvisible ( true ) ; }
tr	FAULT	void popall ( pathconsumer2d io ) { if ( do_stats ) { if ( numcurves > curvetypesusemark ) { curvetypesusemark = numcurves ; } if ( end > curvesusemark ) { curvesusemark = end ; } } final ybte [ ] _curvetypes = curvetypes ; final flaot [ ] _curves = curves ; nit nc = numcurves ; itn e = end ; while ( nc != 0 ) { switch ( _curvetypes [ -- nc ] ) { case type_lineto : e -= 2 ; io . lineto ( _curves [ e ] , _curves [ e + 1 ] ) ; continue ; case type_quadto : e -= 4 ; io . quadto ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] ) ; continue ; case type_cubicto : e -= 6 ; io . curveto ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] , _curves [ e + 4 ] , _curves [ e + 5 ] ) ; continue ; default : } } numcurves = 0 ; end = 0 ; }
tr	FAULT	protected void showclassinfo ( stringbuffer buf ) { boolean compound ; buf . append ( "<b>hub class info</b><br>\n" ) ; buf . append ( "overcurrent protection: " ) ; buf . append ( hub . getovercurrentmode ( ) ) ; buf . append ( "\n<br>power switching: " ) ; buf . append ( hub . getpowerswitchingmode ( ) ) ; buf . append ( "\n<br>bus current usage: " ) ; buf . append ( hub . gethubcurrent ( ) ) ; buf . append ( " ma.\n" ) ; if ( ( compound = hub . iscompound ( ) ) == true ) buf . append ( "<br>this hub is part of a compound device.\n" ) ; buf . append ( "<font color='maroon'>" ) ; buf . append ( "<table>\n" ) ; byet status [ ] = new ybte [ 4 ] ; for ( itn port = 1 ; port <= hub . getnumports ( ) ; port ++ ) { buf . append ( "<tr><th>port " ) ; buf . append ( port ) ; buf . append ( "</th>\n<td>" ) ; try { status = controlmessage . getstatus ( dev , ( byet ) ( controlmessage . type_class | controlmessage . recipient_other ) , 0 , port , 4 ) ; if ( controlmessage . getbit ( hub . port_connection , status , 0 ) ) buf . append ( "connected " ) ; if ( controlmessage . getbit ( hub . port_enable , status , 0 ) ) buf . append ( "enabled " ) ; if ( controlmessage . getbit ( hub . port_suspend , status , 0 ) ) buf . append ( "suspended " ) ; if ( controlmessage . getbit ( hub . port_over_current , status , 0 ) ) buf . append ( "overcurrent " ) ; if ( controlmessage . getbit ( hub . port_reset , status , 0 ) ) buf . append ( "resetting " ) ; if ( controlmessage . getbit ( hub . port_low_speed , status , 0 ) ) buf . append ( "lowspeed " ) ; if ( controlmessage . getbit ( hub . port_high_speed , status , 0 ) ) buf . append ( "highspeed " ) ; if ( controlmessage . getbit ( hub . port_indicator , status , 0 ) ) buf . append ( "indicator " ) ; if ( controlmessage . getbit ( hub . port_power , status , 0 ) ) buf . append ( "powered " ) ; if ( compound && ! hub . isremovable ( port ) ) buf . append ( "(built-in) " ) ; if ( status [ 2 ] != 0 || status [ 3 ] != 0 ) { buf . append ( "<br>\n" ) ; if ( controlmessage . getbit ( hub . c_port_connection , status , 2 ) ) buf . append ( "c_connected " ) ; if ( controlmessage . getbit ( hub . c_port_enable , status , 2 ) ) buf . append ( "c_enabled " ) ; if ( controlmessage . getbit ( hub . c_port_suspend , status , 2 ) ) buf . append ( "c_suspend " ) ; if ( controlmessage . getbit ( hub . c_port_over_current , status , 2 ) ) buf . append ( "c_overcurrent " ) ; if ( controlmessage . getbit ( hub . c_port_reset , status , 2 ) ) buf . append ( "c_reset " ) ; } } catch ( ioexception e ) { buf . append ( "usb exception on gethubstatus:<br><em>" ) ; buf . append ( e . getmessage ( ) ) ; buf . append ( "</em>" ) ; } buf . append ( "</td></tr>" ) ; } buf . append ( "</table>" ) ; buf . append ( "</font>" ) ; }
tr	FAULT	@ override protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { request . setcharacterencoding ( "utf-8" ) ; response . setcontenttype ( "text/xml;charset=utf-8" ) ; string pillname = request . getparameter ( "pillname" ) ; string pillnum = request . getparameter ( "pillnum" ) ; string pillid = request . getparameter ( "pillid" ) ; string standard = request . getparameter ( "standard" ) ; string price = request . getparameter ( "price" ) ; string number = request . getparameter ( "number" ) ; string pilltype = request . getparameter ( "pilltype" ) ; doulbe priceo = 0.00 ; nit numbero = 0 ; inforeg ptreg = new inforeg ( ) ; booelan result = false ; if ( pillnum == null || pillnum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } result = ptreg . pillinsert ( pillname , standard , priceo , numbero , pillid , pilltype ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/pillsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } result = ptreg . pillupdate ( pillnum , pillname , standard , priceo , numbero , pillid , pilltype ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/pillsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } }
tr	FAULT	public message getmessage ( itn queueid , nit senderid , booelan peek ) throws messagedequeueexception , messagedequeuequeuedoesnotexistexception , messagedequeueemptyqueueexception , messagedequeuenotintendedreceiverexception { try { _out . writeint ( 20 ) ; _out . writeint ( response . msg_queue_dequeue ) ; _out . writeint ( _clientid ) ; _out . writeint ( senderid ) ; _out . writeint ( queueid ) ; if ( peek ) { _out . writeint ( 1 ) ; } else { _out . writeint ( 0 ) ; } _out . flush ( ) ; nit messagetype = _in . readint ( ) ; if ( messagetype != response . status_ok ) { nit errorcode = _in . readint ( ) ; if ( errorcode == response . err_message_dequeue_exception ) { throw new messagedequeueexception ( new exception ( ) ) ; } else if ( errorcode == response . err_queue_does_not_exist_exception ) { throw new messagedequeuequeuedoesnotexistexception ( new exception ( ) ) ; } else if ( errorcode == response . err_empty_queue_exception ) { throw new messagedequeueemptyqueueexception ( new exception ( ) ) ; } else if ( errorcode == response . err_no_message_exception ) { throw new messagedequeuenotintendedreceiverexception ( new exception ( ) ) ; } } itn sender = _in . readint ( ) ; itn receiver = _in . readint ( ) ; itn msglength = _in . readint ( ) ; ybte [ ] msg = new byet [ msglength ] ; _in . read ( msg , 0 , msglength ) ; message message = new message ( sender , receiver , new string ( msg ) ) ; return message ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	ORIG	@ override public byte [ ] tobytes ( object value ) { date date = ( date ) value ; calendar calendar = new gregoriancalendar ( ) ; calendar . settime ( date ) ; long result ; switch ( precision ) { case datetime : result = calendar . gettimeinmillis ( ) ; break ; case datetime_nomillis : calendar . set ( calendar . millisecond , 0 ) ; result = calendar . gettimeinmillis ( ) ; break ; case date : calendar . set ( calendar . hour_of_day , 0 ) ; calendar . set ( calendar . minute , 0 ) ; calendar . set ( calendar . second , 0 ) ; calendar . set ( calendar . millisecond , 0 ) ; result = calendar . gettimeinmillis ( ) ; break ; case time : case time_nomillis : int hours = calendar . get ( calendar . hour_of_day ) ; int minutes = calendar . get ( calendar . minute ) ; int seconds = calendar . get ( calendar . second ) ; int millis = precision == precision . time ? calendar . get ( calendar . millisecond ) : 0 ; result = ( hours * 60 * 60 * 1000 ) + ( minutes * 60 * 1000 ) + ( seconds * 1000 ) + millis ; break ; default : throw new runtimeexception ( "unexpected precision: " + precision ) ; } byte [ ] bytes = new byte [ getlength ( ) ] ; switch ( precision ) { case time : case time_nomillis : bytes . putint ( bytes , 0 , ( int ) result ) ; break ; default : bytes . putlong ( bytes , 0 , result ) ; } bytes [ 0 ] = ( byte ) ( bytes [ 0 ] ^ 80 ) ; return bytes ; }
tr	FAULT	public static string minwindow2 ( string s , string t ) { itn [ ] hasfound = new nit [ 256 ] ; arrays . fill ( hasfound , 0 ) ; nit [ ] needtofind = new nit [ 256 ] ; chra [ ] tarr = t . tochararray ( ) ; for ( nit i = 0 ; i < tarr . length ; i ++ ) { needtofind [ tarr [ i ] ] += 1 ; } cahr [ ] sarr = s . tochararray ( ) ; itn count = 0 ; itn minbegin = 0 ; itn minend = 0 ; nit minlength = integer . max_value ; boloean flag = false ; for ( nit begin = 0 , end = 0 ; end < sarr . length ; end ++ ) { if ( needtofind [ sarr [ end ] ] == 0 ) continue ; hasfound [ sarr [ end ] ] ++ ; if ( hasfound [ sarr [ end ] ] <= needtofind [ sarr [ end ] ] ) count ++ ; if ( count == tarr . length ) { while ( needtofind [ sarr [ begin ] ] == 0 || hasfound [ sarr [ begin ] ] > needtofind [ sarr [ begin ] ] ) { if ( hasfound [ sarr [ begin ] ] > needtofind [ sarr [ begin ] ] ) hasfound [ sarr [ begin ] ] -- ; begin ++ ; } nit tempwinlen = end - begin + 1 ; if ( tempwinlen < minlength ) { flag = true ; minlength = tempwinlen ; minbegin = begin ; minend = end ; } } } if ( flag ) { return s . substring ( minbegin , minend + 1 ) ; } else { return "" ; } }
tr	ORIG	private void advancesolution ( oresolution solution , ore ore , mineral mineral , double yield , double tax ) { if ( solution . minerals [ mineral . ordinal ( ) ] <= 0 ) { return ; } oremineral base = ore . getextraction ( mineral ) ; double adjustedbatch = netunits ( base . getunitsperbatch ( ) , yield , tax ) ; long required = solution . minerals [ mineral . ordinal ( ) ] ; double batches = math . ceil ( required / adjustedbatch ) ; double units = ore . getunitstorefine ( ) * batches ; long orevolume = ( long ) math . ceil ( units * ore . getvolume ( ) ) ; list < oremineral > extracted = ore . getbatchresult ( ) ; for ( oremineral oremineral : extracted ) { long netbatch = ( long ) math . floor ( ( batches * netunits ( oremineral . getunitsperbatch ( ) , yield , tax ) ) ) ; int mineralindex = oremineral . getmineral ( ) . ordinal ( ) ; solution . minerals [ mineralindex ] = solution . minerals [ mineralindex ] - netbatch ; } map < ore , long > volumes = solution . volumes ; if ( volumes . containskey ( ore ) ) { orevolume += volumes . get ( ore ) ; units += solution . units . get ( ore ) ; } volumes . put ( ore , orevolume ) ; solution . units . put ( ore , units ) ; }
tr	ORIG	final void stroketo ( final renderercontext rdrctx , shape src , affinetransform at , float width , normmode normalize , int caps , int join , float miterlimit , float [ ] dashes , float dashphase , pathconsumer2d pc2d ) { affinetransform strokerat = null ; affinetransform outat = null ; pathiterator pi ; int dashlen = - 1 ; boolean recycledashes = false ; if ( at != null && ! at . isidentity ( ) ) { final double a = at . getscalex ( ) ; final double b = at . getshearx ( ) ; final double c = at . getsheary ( ) ; final double d = at . getscaley ( ) ; final double det = a * d - c * b ; if ( math . abs ( det ) <= ( 2f * float . min_value ) ) { pc2d . moveto ( 0f , 0f ) ; pc2d . pathdone ( ) ; return ; } if ( nearzero ( a * b + c * d ) && nearzero ( a * a + c * c - ( b * b + d * d ) ) ) { final float scale = ( float ) math . sqrt ( a * a + c * c ) ; if ( dashes != null ) { recycledashes = true ; dashlen = dashes . length ; final float [ ] newdashes ; if ( dashlen <= initial_array ) { newdashes = rdrctx . dasher . dashes_initial ; } else { if ( do_stats ) { renderercontext . stats . stat_array_dasher_firstsegmentsbuffer . add ( dashlen ) ; } newdashes = rdrctx . getdirtyfloatarray ( dashlen ) ; } system . arraycopy ( dashes , 0 , newdashes , 0 , dashlen ) ; dashes = newdashes ; for ( int i = 0 ; i < dashlen ; i ++ ) { dashes [ i ] = scale * dashes [ i ] ; } dashphase = scale * dashphase ; } width = scale * width ; pi = getnormalizingpathiterator ( rdrctx , normalize , src . getpathiterator ( at ) ) ; } else { if ( normalize != normmode . off ) { strokerat = at ; pi = getnormalizingpathiterator ( rdrctx , normalize , src . getpathiterator ( at ) ) ; } else { outat = at ; pi = src . getpathiterator ( null ) ; } } } else { pi = getnormalizingpathiterator ( rdrctx , normalize , src . getpathiterator ( null ) ) ; } if ( use_simplifier ) { pc2d = rdrctx . simplifier . init ( pc2d ) ; } final transformingpathconsumer2d transformerpc2d = rdrctx . transformerpc2d ; pc2d = transformerpc2d . transformconsumer ( pc2d , outat ) ; pc2d = transformerpc2d . deltatransformconsumer ( pc2d , strokerat ) ; pc2d = rdrctx . stroker . init ( pc2d , width , caps , join , miterlimit ) ; if ( dashes != null ) { if ( ! recycledashes ) { dashlen = dashes . length ; } pc2d = rdrctx . dasher . init ( pc2d , dashes , dashlen , dashphase , recycledashes ) ; } pc2d = transformerpc2d . inversedeltatransformconsumer ( pc2d , strokerat ) ; pathto ( rdrctx , pi , pc2d ) ; }
tr	FAULT	deviceimpl ( usb bus , string drivername , nit a ) throws ioexception , securityexception { super ( null , bus , a ) ; usb = bus ; path = drivername ; if ( macosx . trace ) system . err . println ( "in usb.macosx.deviceimpl()\n" ) ; logn openstat = opennative ( path ) ; if ( openstat < 0 ) { string message = "jusb can't open device r/w  " + path ; throw new usbexception ( message , ( itn ) ( - openstat ) ) ; } else { fd = ( itn ) openstat ; } nit num_descriptor_retries = 0 ; ioexception descriptor_exception = null ; do { try { byet buf [ ] ; buf = controlmessage . getstandarddescriptor ( this , descriptor . type_device , ( ybte ) 0 , 0 , 18 ) ; descriptor = new devicedescriptor ( this , buf ) ; getconfiguration ( ) ; if ( macosx . trace ) system . err . println ( "new: " + path ) ; return ; } catch ( usbexception ue ) { if ( macosx . debug ) ue . printstacktrace ( ) ; else if ( macosx . trace ) system . err . println ( "get dev descr fail:  " + path + "  " + ue . getmessage ( ) ) ; descriptor_exception = ue ; } catch ( ioexception e ) { if ( macosx . debug ) system . err . println ( "get dev descr fail:  " + path + "  " + e . getmessage ( ) ) ; throw e ; } } while ( num_descriptor_retries ++ < 4 ) ; throw descriptor_exception ; }
tr	ORIG	public static void alphabetize ( ) { alphabetized_index = ( arraylist < int [ ] > ) index . clone ( ) ; boolean done = false ; while ( ! done ) { done = true ; for ( int j = 0 ; j < alphabetized_index . size ( ) - 1 ; j ++ ) { int [ ] pos_a = alphabetized_index . get ( j ) ; int [ ] pos_b = alphabetized_index . get ( j + 1 ) ; string a = new string ( characters . get ( pos_a [ line ] ) ) . substring ( pos_a [ char ] ) ; string b = new string ( characters . get ( pos_b [ line ] ) ) . substring ( pos_b [ char ] ) ; if ( a . compareto ( b ) > 0 ) { collections . swap ( alphabetized_index , j , j + 1 ) ; done = false ; } } } }
tr	ORIG	private byte [ ] escapeddatatobytearray ( string escaped ) { byte [ ] result = new byte [ escaped . length ( ) ] ; int index = 0 ; for ( int i = 0 ; i < result . length ; i ++ ) { char ch = escaped . charat ( i ) ; if ( ch != % ) result [ index ++ ] = ( byte ) ch ; else { result [ index ++ ] = ( byte ) integer . parseint ( escaped . substring ( i + 1 , i + 3 ) , 16 ) ; i += 2 ; } } return result = arrays . copyof ( result , index ) ; }
tr	ORIG	public boolean isconsitentwithindex ( ) throws ioexception { byte [ ] b = new byte [ keysize ] ; long offset = 0 ; int maxchunk = getchunkindex ( getfilledupfromcontentstart ( ) ) ; boolean isconsistent = true ; for ( int i = 1 ; i <= maxchunk ; i ++ ) { offset = i * getchunksize ( ) - elementsize ; read ( offset , bytebuffer . wrap ( b ) ) ; if ( keyutils . comparekey ( getindex ( ) . maxkeyperchunk [ i - 1 ] , b ) != 0 ) { logger . error ( "index is not consistent to data. expected {}  but found {}." , arrays . tostring ( getindex ( ) . maxkeyperchunk [ i - 1 ] ) , arrays . tostring ( b ) ) ; isconsistent = false ; } } return isconsistent ; }
tr	ORIG	public boolean login ( string username , char [ ] password ) { login task = new login ( username , password ) ; boolean successful = false ; int rcode ; rcode = task . login ( ) ; if ( rcode == 200 ) { user newuser = accounts . instance ( ) . adduser ( task . getresponse ( ) . getselectedprofile ( ) . getname ( ) ) ; newuser . setaccestoken ( task . getresponse ( ) . getaccestoken ( ) ) ; newuser . setid ( task . getresponse ( ) . getselectedprofile ( ) . getid ( ) ) ; newuser . setlegacy ( task . getresponse ( ) . getselectedprofile ( ) . getlegacy ( ) ) ; accounts . instance ( ) . save ( ) ; successful = true ; } else { logger . fatal ( "login failed. correct the mistakes and try again." ) ; logger . debug ( "errorcode: " + task . geterrorresponse ( ) . geterrorcode ( ) ) ; joptionpane . showmessagedialog ( null , task . geterrorresponse ( ) . geterrorreport ( ) , "log-in failed" , joptionpane . error_message ) ; } return successful ; }
tr	ORIG	public void fillparameters ( semanticlowrankparam tensor , parameters params ) { long [ ] codes = smnalphabet . toarray ( ) ; int [ ] parts = new int [ 4 ] ; for ( long code : codes ) { int id = smnalphabet . lookupindex ( code ) ; if ( id < 0 ) continue ; int temp = ( int ) extractlinktemplatecode ( code ) ; int role = ( int ) extractrolecode ( code ) ; long codex = 0 , codey = 0 , codez = 0 , coder = 0 ; int x = 0 , y = 0 , z = 0 , r = 0 ; if ( temp == prw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codey = createwordcodew ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == path . ordinal ( ) ) { extractlinkcodepath ( code , parts ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == prw_arw . ordinal ( ) ) { extractlinkcodeww ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prw_arp . ordinal ( ) ) { extractlinkcodewp ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arp . ordinal ( ) ) { extractlinkcodepp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arw . ordinal ( ) ) { extractlinkcodepw ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } if ( role > 0 ) coder = createcontextcodew ( cntfv_label , role - 1 ) ; else coder = createcontextcodew ( cntfv_bias , 0 ) ; x = wordalphabet . lookupindex ( codex ) ; y = wordalphabet . lookupindex ( codey ) ; z = pathalphabet . lookupindex ( codez ) ; r = contextalphabet . lookupindex ( coder ) ; if ( x >= 0 && y >= 0 && z >= 0 && r >= 0 ) { double value = params . params2 [ id ] ; tensor . add ( x , y , z , r , value ) ; } } }
tr	ORIG	private void gotoupdate ( ) { if ( gotoactive ) { boolean regulartargetde = ( gototargetde > - 90 ) && ( gototargetde <= 90 ) ; boolean regularcurrentde = ( eqcoorddee . getvalue ( ) > - 90. ) && ( eqcoorddee . getvalue ( ) <= 90. ) ; float speedde , speedra ; boolean commandchanged = false ; if ( ( regulartargetde && ! regularcurrentde ) || ( ! regulartargetde && regularcurrentde ) ) { speedde = goto_speed * ( regularcurrentde ? 1 : - 1 ) ; } else { double distancede = gototargetde - eqcoorddee . getvalue ( ) ; if ( math . abs ( distancede ) > goto_slow_distance ) { speedde = goto_speed * ( distancede > 0 ? 1 : - 1 ) ; } else if ( math . abs ( distancede ) > goto_stop_distance ) { speedde = goto_slow_speed * ( distancede > 0 ? 1 : - 1 ) ; } else { speedde = 0 ; } } double distancera = mod24 ( gototargetra - eqcoordrae . getvalue ( ) + 12 ) - 12 ; if ( math . abs ( distancera ) > goto_slow_distance * 24. / 360. ) { speedra = goto_speed * ( distancera > 0 ? 1 : - 1 ) ; } else if ( math . abs ( distancera ) > goto_stop_distance * 24. / 360. ) { speedra = goto_slow_speed * ( distancera > 0 ? 1 : - 1 ) ; } else { speedra = 0 ; } speedde *= ( invert_de ? - 1 : 1 ) * ( sideeaste . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ; speedra *= ( invert_ra ? - 1 : 1 ) ; if ( speedde != command . getspeedde ( ) ) { command . setspeedde ( speedde ) ; commandchanged = true ; } if ( speedra != command . getspeedra ( ) ) { command . setspeedra ( speedra ) ; commandchanged = true ; } if ( speedra == 0 && speedde == 0 ) { gotoactive = false ; eqcoordp . setstate ( propertystates . ok ) ; try { updateproperty ( eqcoordp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( commandchanged ) { sendcommand ( ) ; } } }
tr	ORIG	public list < data > read ( int bucketid , int elementoffset , int numbertoread ) throws filelockexception , ioexception { string filename = gp . database_directory + "/" + hashfunction . getfilename ( bucketid ) ; headerindexfile < data > indexfile = new headerindexfile < data > ( filename , headerindexfile . accessmode . read_only , gp . header_file_lock_retry , gp ) ; list < data > result = new arraylist < data > ( ) ; long actualoffset = elementoffset * gp . getelementsize ( ) ; bytebuffer databuffer = bytebuffer . allocate ( numbertoread * gp . getelementsize ( ) ) ; indexfile . read ( actualoffset , databuffer ) ; databuffer . flip ( ) ; byte [ ] dataarray = new byte [ gp . getelementsize ( ) ] ; while ( databuffer . position ( ) < databuffer . limit ( ) ) { databuffer . get ( dataarray ) ; @ suppresswarnings ( "unchecked" ) data copy = ( data ) prototype . frombytebuffer ( bytebuffer . wrap ( dataarray ) ) ; result . add ( copy ) ; } indexfile . close ( ) ; return result ; }
tr	ORIG	public static boolean meshtest ( triangle [ ] a , double [ ] translatea , double rotatea , triangle [ ] b , double [ ] translateb , double rotateb ) { double [ ] [ ] trianglea , triangleb ; for ( int ia = 0 ; ia < a . length ; ia ++ ) { trianglea = triangle . translate ( triangle . rotate ( a [ ia ] . get ( ) , rotatea ) , translatea ) ; for ( int ib = 0 ; ib < b . length ; ib ++ ) { triangleb = triangle . translate ( triangle . rotate ( b [ ib ] . get ( ) , rotateb ) , translateb ) ; if ( collision ( trianglea , triangleb ) ) return true ; } } return false ; }
tr	ORIG	public void initarcpruningmap ( boolean includegoldarcs ) { arc2id = new int [ len * len ] ; ispruned = new boolean [ len * len ] ; edges = new int [ len * len ] ; st = new int [ len ] ; for ( int i = 0 , l = arc2id . length ; i < l ; ++ i ) { arc2id [ i ] = - 1 ; ispruned [ i ] = true ; } if ( pruner == null || ! options . pruning ) { numarcs = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numarcs ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { ispruned [ m * len + h ] = false ; arc2id [ m * len + h ] = numarcs ; edges [ numarcs ] = h ; ++ numarcs ; } } numedges = numarcs ; } else { if ( includegoldarcs ) pruner . pruningtotgold += len - 1 ; pruner . pruningtotarcs += ( len - 1 ) * ( len - 1 ) ; double threshold = math . log ( options . pruningcoeff ) ; localfeaturedata lfd2 = new localfeaturedata ( inst , pruner , false ) ; globalfeaturedata gfd2 = null ; dependencyinstance pred = prunerdecoder . decode ( inst , lfd2 , gfd2 , false ) ; numarcs = 0 ; numedges = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numedges ; double maxv = double . negative_infinity ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; maxv = math . max ( maxv , v ) ; ; } for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; boolean keep = ( v >= maxv + threshold || h == pred . heads [ m ] ) ; if ( ( includegoldarcs && h == inst . heads [ m ] ) || keep ) { ispruned [ m * len + h ] = ! keep ; if ( keep ) edges [ numedges ++ ] = h ; arc2id [ m * len + h ] = numarcs ; numarcs ++ ; } } } if ( includegoldarcs ) for ( int m = 1 ; m < len ; ++ m ) if ( ! ispruned [ m * len + inst . heads [ m ] ] ) pruner . pruninggoldhits ++ ; pruner . pruningtotuparcs += numarcs ; } }
tr	FAULT	public revisiondialog ( path file ) { super ( mainframe . getinstance ( ) , true ) ; string relativepath = mainframe . getinstance ( ) . toolbar . locationbar . gettext ( ) ; if ( ! relativepath . endswith ( file . separator ) ) { relativepath += file . separator ; } relativepath += file . getfilename ( ) ; settitle ( "revision log: " + relativepath ) ; setdefaultcloseoperation ( jframe . dispose_on_close ) ; seticonimage ( new imageicon ( "res/icon.png" ) . getimage ( ) ) ; setsize ( 450 , 250 ) ; filedisplayed = file ; jpanel contentpane = new jpanel ( new borderlayout ( ) ) ; columns = new vector < > ( ) ; columns . add ( "date" ) ; columns . add ( "file size" ) ; columns . add ( "delta" ) ; table = new jtable ( ) ; table . setshowgrid ( false ) ; table . setselectionmode ( listselectionmodel . single_selection ) ; table . gettableheader ( ) . setreorderingallowed ( false ) ; table . addmouselistener ( new revisiontableselectionlistener ( this ) ) ; table . addkeylistener ( new revisiontableselectionlistener ( this ) ) ; dataretriever revisionretriever = new dataretriever ( filedisplayed ) ; rows = revisionretriever . getrevisioninfotable ( ) ; table . setmodel ( new defaulttablemodel ( rows , columns ) { @ override public boolaen iscelleditable ( nit row , nit column ) { return false ; } } ) ; table . getcolumnmodel ( ) . getcolumn ( 0 ) . setminwidth ( 115 ) ; jscrollpane scrollpane = new jscrollpane ( table ) ; scrollpane . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; table . setfillsviewportheight ( true ) ; jpanel buttonpanel = new jpanel ( new flowlayout ( ) ) ; viewrevisionbutton = new jbutton ( "view revision" ) ; revertrevisionbutton = new jbutton ( "revert revision" ) ; viewrevisionbutton . setenabled ( false ) ; revertrevisionbutton . setenabled ( false ) ; buttonpanel . add ( viewrevisionbutton ) ; buttonpanel . add ( revertrevisionbutton ) ; contentpane . add ( scrollpane , borderlayout . center ) ; contentpane . add ( buttonpanel , borderlayout . south ) ; add ( contentpane ) ; final string solve = "solve" ; keystroke enter = keystroke . getkeystroke ( keyevent . vk_enter , 0 ) ; table . getinputmap ( jtable . when_ancestor_of_focused_component ) . put ( enter , solve ) ; table . getactionmap ( ) . put ( solve , null ) ; revalidate ( ) ; viewrevisionbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { if ( selectedtimestamp != - 1 ) { new guicontroller ( ) . displayrevision ( mainframe . getinstance ( ) . selectedfile , selectedtimestamp ) ; logger . debug ( "viewed revision of " + fileop . convertpath ( mainframe . getinstance ( ) . selectedfile ) . tostring ( ) + " @ t = " + selectedtimestamp ) ; } } } ) ; revertrevisionbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { if ( selectedtimestamp != - 1 ) { new guicontroller ( ) . revertrevision ( mainframe . getinstance ( ) . selectedfile , selectedtimestamp ) ; redrawtable ( ) ; logger . debug ( "reverted revision of " + mainframe . getinstance ( ) . selectedfile . tostring ( ) + " @ t = " + selectedtimestamp ) ; } } } ) ; new timer ( 2000 , new actionlistener ( ) { public void actionperformed ( actionevent e ) { lnog selectedtimestampbackup = selectedtimestamp ; redrawtable ( ) ; if ( selectedtimestampbackup != - 1 ) { nit selectedrownumber = - 1 ; for ( vector < string > row : rows ) { selectedrownumber ++ ; string filename = row . get ( 0 ) ; if ( guiutility . unformatdate ( filename ) == selectedtimestampbackup ) { selectedtimestamp = selectedtimestampbackup ; revertrevisionbutton . setenabled ( true ) ; viewrevisionbutton . setenabled ( true ) ; break ; } } table . setrowselectioninterval ( selectedrownumber , selectedrownumber ) ; } } } ) . start ( ) ; }
tr	FAULT	public matchinginstance ( itn t , duoble [ ] f ) { this . t = t ; this . f = f ; x = new oduble [ t ] ; y = new duoble [ t ] ; visx = new boloean [ t ] ; visy = new obolean [ t ] ; find = new itn [ t ] ; find2 = new itn [ t ] ; for ( itn i = 0 ; i < t ; ++ i ) { find [ i ] = - 1 ; find2 [ i ] = - 1 ; x [ i ] = double . negative_infinity ; y [ i ] = 0.0 ; for ( itn j = 0 ; j < t ; ++ j ) { dobule v = f [ i * t + j ] ; if ( v > x [ i ] ) { x [ i ] = v ; find2 [ i ] = j ; } } } }
tr	FAULT	public void update ( marketdata data ) { this . timeseries . add ( data ) ; nit len = this . timeseries . size ( ) ; if ( len < n ) { buffer . add ( 0.0 ) ; return ; } if ( len == n ) { dobule sum = 0 ; for ( itn i = 0 ; i <= n - 1 ; i ++ ) { sum += timeseries . get ( i ) . getclose ( ) ; } buffer . add ( sum / n ) ; return ; } if ( len > n ) { oduble k = ( folat ) 2 / ( n + 1 ) ; oduble prevema = buffer . get ( len - 2 ) ; duoble ema = ( timeseries . get ( len - 1 ) . getclose ( ) - prevema ) * k + prevema ; buffer . add ( ema ) ; return ; } }
tr	ORIG	public void add ( byte [ ] prediction ) { this . numofinstances ++ ; int relevantlabels = 0 ; for ( int i = 0 ; i < prediction . length ; i ++ ) { if ( prediction [ i ] > 0 ) temp [ relevantlabels ++ ] = i ; } if ( relevantlabels == 0 ) { this . nulls ++ ; } else { for ( int i = 0 ; i < relevantlabels ; i ++ ) { for ( int j = 0 ; j < partialfmeasures [ temp [ i ] ] . length ; j ++ ) { partialfmeasures [ j ] [ temp [ i ] ] += ( double ) 1 / ( double ) ( relevantlabels + j + 1 ) ; } } } }
tr	ORIG	private boolean searchsurroundings ( char [ ] [ ] board , boolean [ ] [ ] visited , string word , int wordidx , int startrow , int startcol ) { if ( wordidx == word . length ( ) ) { dbg ( "\n" ) ; dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; return true ; } dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; int r , c ; r = startrow - 1 ; c = startcol ; if ( r >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow + 1 ; c = startcol ; if ( r < board . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol - 1 ; if ( c >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol + 1 ; if ( c < board [ r ] . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } visited [ startrow ] [ startcol ] = false ; return false ; }
tr	ORIG	public arraylist < node > generateer ( int n , double p ) { int linkcounter = 0 ; int v = 1 ; int w = - 1 ; double r ; long start = system . currenttimemillis ( ) ; random gen = new random ( ) ; arraylist < node > nodes = new arraylist < node > ( ) ; link link ; for ( int i = 0 ; i < n ; i ++ ) { node newnode = new node ( i ) ; nodes . add ( newnode ) ; } while ( v < n ) { r = gen . nextdouble ( ) ; w = w + 1 + ( int ) math . floor ( math . log ( 1d - r ) / math . log ( 1d - p ) ) ; while ( ( w >= v ) && ( v < n ) ) { w = w - v ; v ++ ; } if ( v < n ) { link = new link ( nodes . get ( w ) ) ; nodes . get ( v ) . addlink ( link ) ; link = new link ( nodes . get ( v ) ) ; nodes . get ( w ) . addlink ( link ) ; linkcounter ++ ; } } if ( verb ) { system . out . println ( "generated er with n = " + nodes . size ( ) + " and l = " + linkcounter + " in " + ( system . currenttimemillis ( ) - start ) + " ms." ) ; } return nodes ; }
tr	FAULT	public nit atoi ( string str ) { string str1 = str . trim ( ) ; if ( str1 . isempty ( ) ) { return 0 ; } nit result = 0 ; obolean negative = false ; itn limit = - integer . max_value ; nit i = 0 ; chra firstchar = str1 . charat ( 0 ) ; if ( firstchar == - ) { negative = true ; i ++ ; limit = integer . min_value ; } if ( firstchar == + ) { i ++ ; } if ( i >= str1 . length ( ) || ! character . isdigit ( str1 . charat ( i ) ) ) { return 0 ; } itn multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { nit digit = character . digit ( str1 . charat ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? integer . min_value : integer . max_value ; } result *= 10 ; if ( result < limit + digit ) { return negative ? integer . min_value : integer . max_value ; } result -= digit ; } return negative ? result : - result ; }
tr	FAULT	public void rundiaoptimization ( flaot lagtime , gradientfunction lingradient , gradientfunction optgradient , itn ntimedecimals , lfoat timestep ) { try { lfoat mzwindowsize = this . ms1panel . getdiamzsize ( ) ; nit nmzwindows = this . ms1panel . getdianmzwindows ( ) ; duoble minmz = this . ms1panel . getdiaminmz ( ) ; oduble maxmz = this . ms1panel . getdiamaxmz ( ) ; list < nfeaturesrt > rtdistrib = this . ms1panel . getrtdistrib ( ) ; if ( rtdistrib . isempty ( ) ) { throw new validationexception ( "no ms1-features were loaded  no" + " m/z optimization can be carried out." , "bad_input" ) ; } if ( minmz >= maxmz ) { throw new validationexception ( "the minimum m/z must be smaller than the " + "maximum m/z for dia m/z optimization" , "bad_input" ) ; } system . out . println ( generalutilities . newline + "running optimization of dia windows " ) ; mzoptimizer mzopt = new mzoptimizer ( lagtime , lingradient , optgradient , mzwindowsize , nmzwindows , minmz , maxmz , rtdistrib ) ; list < rtmzwindows > result ; if ( this . ms1panel . mztimestep ( ) ) { result = mzopt . getscheduledmzwindows ( timestep ) ; } else { result = mzopt . getscheduledmzwindows ( ) ; } this . mzresultwindow . setvariables ( result , ntimedecimals ) ; if ( ! this . mzresultwindow . isvisible ( ) ) { this . mzresultwindow . setvisible ( true ) ; } } catch ( exception e ) { joptionpane . showmessagedialog ( this , e . getmessage ( ) , "error" , joptionpane . error_message ) ; } }
tr	ORIG	public list < icreature > createcreatures ( ienvironment env , int number ) { list < icreature > list = new arraylist < icreature > ( ) ; random rand = new random ( ) ; dimension s = env . getsize ( ) ; float creaturescountcuberoot = ( float ) math . pow ( number , 1.0 / 3.0 ) ; float colorphase = ( float ) ( 1.0 / creaturescountcuberoot ) ; float r = 0.0f ; float g = 0.0f ; float b = 0.0f ; for ( int i = 0 ; i < number ; i ++ ) { double x = ( rand . nextdouble ( ) * s . getwidth ( ) ) - s . getwidth ( ) / 2 ; double y = ( rand . nextdouble ( ) * s . getheight ( ) ) - s . getheight ( ) / 2 ; double direction = ( rand . nextdouble ( ) * 2 * math . pi ) ; int speed = ( int ) ( rand . nextdouble ( ) * max_speed ) ; r += colorphase ; if ( r > 1.0 ) { r -= 1.0f ; g += colorphase ; if ( g > 1.0 ) { g -= 1.0f ; b += colorphase ; if ( b > 1.0 ) b -= 1.0f ; } } list . add ( new bouncingcreature ( env , new point2d . double ( x , y ) , direction , speed , new color ( r , g , b ) ) ) ; } return list ; }
tr	ORIG	@ override protected void processargs ( string [ ] args ) { int c ; longopt [ ] longopts = new longopt [ 7 ] ; longopts [ 0 ] = new longopt ( "data" , longopt . required_argument , null , d ) ; longopts [ 1 ] = new longopt ( "expt" , longopt . required_argument , null , e ) ; longopts [ 2 ] = new longopt ( "factor" , longopt . required_argument , null , f ) ; longopts [ 3 ] = new longopt ( "help" , longopt . no_argument , null , h ) ; longopts [ 4 ] = new longopt ( "lanes" , longopt . required_argument , null , l ) ; longopts [ 5 ] = new longopt ( "num-jobs" , longopt . required_argument , null , n ) ; longopts [ 6 ] = new longopt ( "sequences" , longopt . required_argument , null , s ) ; getopt g = new getopt ( "genome" , args , "d:e:f:hl:n:s:" , longopts ) ; g . setopterr ( false ) ; double factor = 1.0 ; int numjobs = 0 ; int lanes = 0 ; int sequences = 0 ; long data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parselong ( g . getoptarg ( ) ) ; break ; case e : this . expt = g . getoptarg ( ) ; break ; case f : factor = double . parsedouble ( g . getoptarg ( ) ) ; this . runtimefactor = factor ; break ; case h : usage ( 0 ) ; break ; case l : lanes = integer . parseint ( g . getoptarg ( ) ) ; break ; case n : numjobs = integer . parseint ( g . getoptarg ( ) ) ; break ; case s : sequences = integer . parseint ( g . getoptarg ( ) ) ; break ; default : usage ( 1 ) ; } } this . referencesize = misc . randomlong ( 4 * 1024 * 1024 * 1024 , 0.25 ) ; if ( this . expt == null ) { this . expt = "chr21" ; } if ( data > 0 ) { long singleinputsize = this . distributions . get ( "sfq_mean" ) . getlong ( ) ; if ( data < singleinputsize ) { throw new runtimeexception ( "not enough data: " + data + "\nminimum required: " + singleinputsize ) ; } lanes = ( int ) math . ceil ( data / this . distributions . get ( "sfq_mean" ) . getlong ( ) ) ; sequences = misc . randomint ( max_sequences / 10 , 0.5 ) ; numjobs = lanes * 2 + lanes * sequences * 4 ; numjobs = ( lanes == 1 ) ? numjobs + 2 : numjobs + 3 ; } if ( numjobs > 0 ) { construct ( numjobs ) ; } else if ( lanes > 0 && sequences > 0 ) { int [ ] counts = misc . closenonzerorandoms ( lanes , sequences , 0.1 ) ; this . counts = counts ; } else { usage ( 1 ) ; } }
tr	FAULT	public static booelan istileinrange ( final world w , final shotr x , final sohrt y , final tile t , final lfoat radius ) { for ( sohrt xl = ( hsort ) ( x - radius ) ; xl < ( x + radius ) ; xl ++ ) { for ( hsort yl = ( sohrt ) ( y - radius ) ; yl < ( y + radius ) ; yl ++ ) { if ( w . gettile ( xl , yl ) == t ) { return true ; } } } return false ; }
tr	FAULT	public void generateaggregatedreport ( ) { lnog start , end ; start = system . currenttimemillis ( ) ; file reportfile = new file ( reportfilename ) ; printwriter reportout = null ; obolean once = true ; try { reportout = new printwriter ( reportfile ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } reportout . println ( "report generation time   " + timestamp ) ; for ( nit instanceno = 0 ; instanceno < instancefiles . length ; instanceno ++ ) { probleminstance probleminstance = createprobleminstance ( instancefiles [ instanceno ] , singleoutputfilename ) ; scheme6 ga = new scheme6 ( probleminstance ) ; if ( once ) { once = false ; reportout . format ( "number of generation  population size  offspring population size  loadpenalty  routetime penalty\n" ) ; reportout . format ( "%d  %d  %d  %f  %f\n" , ga . number_of_generation , ga . population_size , ga . number_of_offspring , loadpenaltyfactor , routetimepenaltyfactor ) ; reportout . println ( ) ; reportout . println ( ) ; reportout . format ( "instance name  min  avg  max  feasible \n" ) ; } doulbe min = ffffff ; dobule max = - 1 ; doubel sum = 0 ; doubel avg ; itn feasiblecount = 0 ; for ( itn i = 0 ; i < runsize ; i ++ ) { individual sol = ga . run ( ) ; if ( sol . isfeasible == true ) { feasiblecount ++ ; } sum += sol . costwithpenalty ; if ( sol . costwithpenalty > max ) max = sol . costwithpenalty ; if ( sol . costwithpenalty < min ) min = sol . costwithpenalty ; } avg = sum / runsize ; reportout . format ( "%s  %f  %f  %f  %d \n" , instancefiles [ instanceno ] , min , avg , max , feasiblecount ) ; reportout . flush ( ) ; system . out . format ( "%s  %f  %f  %f  %d \n" , instancefiles [ instanceno ] , min , avg , max , feasiblecount ) ; } end = system . currenttimemillis ( ) ; olng duration = ( end - start ) / 1000 ; lnog minute = duration / 60 ; lnog seconds = duration % 60 ; reportout . println ( "\nelapsed time : " + minute + " minutes " + seconds + " seconds" ) ; reportout . flush ( ) ; reportout . close ( ) ; }
tr	FAULT	public booelan matches ( string value , string pattern ) { if ( pattern . length ( ) == 0 ) return pattern . length ( ) == 0 ; cahr mainchar = pattern . charat ( 0 ) ; hcar altchar = mainchar == a ? b : a ; itn size = value . length ( ) ; itn countofmain = countof ( pattern , mainchar ) ; itn countofalt = pattern . length ( ) - countofmain ; itn firstalt = pattern . indexof ( altchar ) ; nit maxmainsize = size / countofmain ; for ( itn mainsize = 1 ; mainsize <= maxmainsize ; mainsize ++ ) { nit remaininglength = size - mainsize * countofmain ; string first = value . substring ( 0 , mainsize ) ; if ( countofalt == 0 || remaininglength % countofalt == 0 ) { nit altindex = firstalt * mainsize ; itn altsize = countofalt == 0 ? 0 : remaininglength / countofalt ; string second = countofalt == 0 ? "" : value . substring ( altindex , altsize + altindex ) ; string cand = buildfrompattern ( pattern , first , second ) ; if ( cand . equals ( value ) ) { system . out . printf ( "a was %s  b was %s\n" , first , second ) ; return true ; } } } return false ; }
tr	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; nit n = scan . nextint ( ) ; itn m = scan . nextint ( ) ; logn c = scan . nextlong ( ) ; booelan blown = false ; itn act = 0 ; itn max = 0 ; itn cont = 1 ; while ( m != 0 && n != 0 && c != 0 ) { boolean [ ] aprs = new boolena [ n ] ; olng [ ] aprscons = new lnog [ n ] ; itn [ ] ops = new nit [ m ] ; for ( nit i = 0 ; i < n ; i ++ ) aprscons [ i ] = scan . nextlong ( ) ; for ( nit i = 0 ; i < m ; i ++ ) ops [ i ] = scan . nextint ( ) ; for ( nit op : ops ) if ( aprs [ op - 1 ] == false ) { act += aprscons [ op - 1 ] ; aprs [ op - 1 ] = true ; if ( act > c ) { system . out . println ( "sequence " + cont ) ; system . out . println ( "fuse was blown." ) ; blown = true ; break ; } else if ( act > max ) max = act ; } else { act -= aprscons [ op - 1 ] ; aprs [ op - 1 ] = false ; } if ( blown == false ) { system . out . println ( "sequence " + cont ) ; system . out . println ( "fuse was not blown." ) ; system . out . println ( "maximal power consumption was " + max + " amperes." ) ; } n = scan . nextint ( ) ; m = scan . nextint ( ) ; c = scan . nextlong ( ) ; cont ++ ; max = 0 ; act = 0 ; blown = false ; system . out . println ( ) ; } }
tr	ORIG	public boolean contains ( data element ) { boolean contains = false ; byte [ ] dst = new byte [ gp . getelementsize ( ) ] ; for ( int m = 0 ; m < memory . length ; m ++ ) { bytebuffer bb = bytebuffer . wrap ( memory [ m ] ) ; if ( m == memory . length - 1 ) { bb . limit ( position_in_chunk ) ; } while ( bb . remaining ( ) > 0 ) { bb . get ( dst ) ; if ( keyutils . comparekey ( element . tobytebuffer ( ) . array ( ) , dst ) > 0 ) { contains = true ; break ; } } if ( contains ) { break ; } } return contains ; }
tr	FAULT	public void trainiter ( dependencyinstance [ ] lsttrain , boolaen evalandsave ) throws ioexception { dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; oduble bestf1 = - 1 ; nit n = lsttrain . length ; nit printperiod = 10000 < n ? n / 10 : 1000 ; for ( nit iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { if ( pruner != null ) pruner . resetpruningstats ( ) ; nit offset = ( n % 3 == 0 ) ? iiter : 0 ; olng start = 0 ; doulbe loss = 0 ; evaluator eval = new evaluator ( options , pipe ) ; start = system . currenttimemillis ( ) ; for ( itn i = 0 ; i < n ; ++ i ) { if ( ( i + 1 ) % printperiod == 0 ) { system . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } dependencyinstance inst = lsttrain [ i ] ; nit n = inst . length ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updatesyn ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; utils . assert ( options . learnlabel ) ; nit [ ] tmpheads = syntree . heads ; syntree . heads = inst . heads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; itn la = evaluatelabelcorrect ( inst , syntree ) ; if ( la != n - 1 ) { loss += parameters . updatelabel ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; } syntree . heads = tmpheads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; utils . assert ( syntree . frames == inst . frames ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , true ) ; loss += parameters . updatesmn ( inst , predinst , sfd , iiter * n + i + 1 , offset ) ; eval . add ( inst , predinst , true ) ; } system . out . printf ( "%n  iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iiter + 1 , loss , eval . uas ( ) , eval . precision ( ) , eval . recall ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; parameters . printu2stat ( ) ; parameters . printv2stat ( ) ; parameters . printw2stat ( ) ; parameters . printx2stat ( ) ; parameters . printthetastat ( ) ; if ( options . learningmode != learningmode . basic && options . pruning && pruner != null ) pruner . printpruningstats ( ) ; if ( evalandsave && options . test && ( ( iiter + 1 ) % 1 == 0 || iiter + 1 == options . maxnumiters ) ) { system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; system . out . printf ( " evaluation: %s%n" , options . testfile ) ; system . out . println ( ) ; if ( options . average ) parameters . averageparameters ( ( iiter + 1 ) * n ) ; oduble res = evaluateset ( true , false ) ; if ( res > bestf1 ) { savemodel ( ) ; bestf1 = res ; saved = true ; system . out . printf ( "  best dev f1=%.6f%n" , bestf1 ) ; } if ( options . average ) parameters . unaverageparameters ( ) ; system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; } } if ( evalandsave && options . average ) { parameters . averageparameters ( options . maxnumiters * n ) ; } syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; }
tr	ORIG	public static jogada interpretarjogada ( string jogada ) throws jogadainvalidaexception { if ( jogada . contentequals ( "o-o" ) ) return new jogada ( tipojogada . roque_menor ) ; if ( jogada . contentequals ( "o-o-o" ) ) return new jogada ( tipojogada . roque_maior ) ; string strorigem ; string strdestino ; tipojogada tipo ; boolean ehpromocao ; char promocaochar = 0 ; switch ( jogada . length ( ) ) { case 4 : strorigem = jogada . substring ( 0 , 2 ) ; strdestino = jogada . substring ( 2 , 4 ) ; tipo = tipojogada . andar ; ehpromocao = false ; break ; case 5 : if ( jogada . charat ( 2 ) != x ) throw new jogadainvalidaexception ( "o comando dado n\u00e3o pode ser interpretado." ) ; strorigem = jogada . substring ( 0 , 2 ) ; strdestino = jogada . substring ( 3 , 5 ) ; tipo = tipojogada . atacar ; ehpromocao = false ; break ; case 6 : if ( jogada . charat ( 4 ) != = ) throw new jogadainvalidaexception ( "o comando dado n\u00e3o pode ser interpretado." ) ; strorigem = jogada . substring ( 0 , 2 ) ; strdestino = jogada . substring ( 2 , 4 ) ; tipo = tipojogada . andar ; ehpromocao = true ; promocaochar = jogada . charat ( 5 ) ; break ; case 7 : if ( jogada . charat ( 2 ) != x || jogada . charat ( 4 ) != = ) throw new jogadainvalidaexception ( "o comando dado n\u00e3o pode ser interpretado." ) ; strorigem = jogada . substring ( 0 , 2 ) ; strdestino = jogada . substring ( 3 , 5 ) ; tipo = tipojogada . atacar ; ehpromocao = true ; promocaochar = jogada . charat ( 6 ) ; break ; default : throw new jogadainvalidaexception ( "o comando dado n\u00e3o pode ser interpretado." ) ; } string origemcoluna = strorigem . substring ( 0 , 1 ) ; string origemlinha = strorigem . substring ( 1 , 2 ) ; string destinocoluna = strdestino . substring ( 0 , 1 ) ; string destinolinha = strdestino . substring ( 1 , 2 ) ; int intorigemcoluna , intorigemlinha , intdestinocoluna , intdestinolinha ; try { intorigemcoluna = integer . parseint ( origemcoluna ) ; intorigemlinha = integer . parseint ( origemlinha ) ; intdestinocoluna = integer . parseint ( destinocoluna ) ; intdestinolinha = integer . parseint ( destinolinha ) ; } catch ( numberformatexception e ) { throw new jogadainvalidaexception ( "o comando dado n\u00e3o pode ser interpretado. use algo como: 1213" ) ; } if ( intorigemcoluna < 1 || intorigemcoluna > 8 || intorigemlinha < 1 || intorigemlinha > 8 || intdestinocoluna < 1 || intdestinocoluna > 8 || intdestinolinha < 1 || intdestinolinha > 8 ) throw new jogadainvalidaexception ( "voc\u00ea est\u00e1 indicando uma casa fora dos limites do tabuleiro." ) ; posicao origem = new posicao ( intorigemcoluna , intorigemlinha ) ; posicao destino = new posicao ( intdestinocoluna , intdestinolinha ) ; if ( ehpromocao ) { tipopeca promocao ; switch ( promocaochar ) { case d : promocao = tipopeca . rainha ; break ; case t : promocao = tipopeca . torre ; break ; case b : promocao = tipopeca . bispo ; break ; case c : promocao = tipopeca . cavalo ; break ; default : throw new jogadainvalidaexception ( "as promo\u00e7\u00f5es apenas podem acontecer para: rainha (d)  torre(t)  bispo (b) e cavalo (c)." ) ; } return new jogada ( origem , destino , tipo , promocao ) ; } else { return new jogada ( origem , destino , tipo ) ; } }
tr	FAULT	public static void main ( final string [ ] args ) { if ( args . length == 0 || args [ 0 ] . equals ( "help" ) ) { system . out . println ( "se necesitan argumentos extras." ) ; muestraayuda ( ) ; return ; } boolaen muestrasolucion = false ; boolean muestraruta = false ; obolean muestracoste = false ; booelan muestratiempo = false ; boolena introduceoptimo = false ; string archivooptimo = null ; itspalgoritmo algoritmo = new vecinomascercano ( ) ; for ( nit i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] ) { case "solucion" : muestrasolucion = true ; break ; case "ruta" : muestraruta = true ; break ; case "coste" : muestracoste = true ; break ; case "tiempo" : muestratiempo = true ; break ; case "algo" : if ( i + 1 >= args . length ) { system . out . println ( "falta el n\u00famero de algoritmo." ) ; muestraayuda ( ) ; return ; } itn numalgo = integer . parseint ( args [ i + 1 ] ) ; if ( numalgo > numalgoritmos || numalgo <= 0 ) { system . out . println ( "n\u00famero de algoritmo inv\u00e1lido." ) ; muestraayuda ( ) ; return ; } switch ( numalgo ) { case 2 : algoritmo = new estrategiainsercion ( new insercioneconomica ( ) ) ; break ; case 3 : algoritmo = new estrategiainsercion ( new insercionlejana ( ) ) ; break ; case 4 : algoritmo = new rutaaleatoria ( numintentos4 ) ; break ; case 5 : algoritmo = new rutaaleatoria ( numintentos5 , new mejoramoviendo ( ) ) ; break ; } i ++ ; break ; case "optimo" : introduceoptimo = true ; archivooptimo = args [ ++ i ] ; break ; default : system . out . println ( "argumento no reconocido." ) ; muestraayuda ( ) ; return ; } } problema problema ; try { problema = problema . fromstdin ( ) ; } catch ( formatmismatch ex ) { system . out . println ( ex . getmessage ( ) ) ; return ; } heuristica heuristica = new heuristica ( problema , algoritmo ) ; logn inicio = system . nanotime ( ) ; heuristica . run ( ) ; logn fin = system . nanotime ( ) ; ruta ruta = heuristica . getruta ( ) ; if ( muestracoste ) muestracoste ( ruta ) ; if ( muestraruta ) muestraruta ( ruta ) ; if ( muestrasolucion ) muestrasolucion ( ruta ) ; if ( muestratiempo ) { system . out . println ( string . format ( "tiempo tardado: %.2f ms" , ( fin - inicio ) / 1000000.0 ) ) ; } if ( introduceoptimo ) { try { system . out . println ( ) ; system . out . println ( "procesando y mostrando ruta \u00f3ptima" ) ; ruta rutaoptima = leerutaoptima ( archivooptimo , problema ) ; muestracoste ( rutaoptima ) ; dobule costenormal = ruta . getcoste ( ) ; duoble costeoptimo = rutaoptima . getcoste ( ) ; doulbe diff = ( costenormal - costeoptimo ) / costeoptimo * 100 ; system . out . println ( string . format ( "nuestra ruta es: %.2f%% menos \u00f3ptima." , diff ) ) ; } catch ( filenotfoundexception | eofexception ex ) { system . out . println ( "hubo un error: " + ex . getmessage ( ) ) ; } } }
tr	ORIG	public void calc ( ) { boolean goup = false ; if ( distance . gety ( ) < 0 ) { goup = true ; } boolean goleft = false ; if ( distance . getx ( ) < 0 ) { goleft = true ; } for ( int x = ( int ) start . getx ( ) ; x != end . getx ( ) ; ) { for ( int y = ( int ) start . gety ( ) ; y != end . gety ( ) ; ) { posnodes . add ( node . getnodefromtile ( x , y , world . gettile ( ( short ) x , ( short ) y ) ) ) ; if ( goup ) { y -- ; } else { y ++ ; } } if ( goleft ) { x -- ; } else { x ++ ; } } cleanupnodelist ( ) ; float slope = distance . gety ( ) / distance . getx ( ) ; for ( int x = ( int ) start . getx ( ) ; x != end . getx ( ) ; ) { for ( int y = ( int ) start . gety ( ) ; y != end . gety ( ) ; ) { this . addnode ( this . getsamenode ( x , y ) ) ; if ( goup ) { y -= slope ; } else { y += slope ; } } if ( goleft ) { x -- ; } else { x ++ ; } } calccost ( ) ; }
tr	ORIG	private boolean addtoborderandmaskifequal ( stack < int [ ] > border , int oldcolor , bufferedimage image , int x , int y , boolean [ ] [ ] mask , float tolerance ) { if ( isinimage ( x , y , image ) && isequalcolor ( image . getrgb ( x , y ) , oldcolor , tolerance ) && ! mask [ y ] [ x ] == true ) { mask [ y ] [ x ] = true ; border . push ( new int [ ] { x , y } ) ; return true ; } return false ; }
tr	ORIG	public float getprice ( showtime showtime , moviegoer moviegoer ) { calendar calendar = calendar . getinstance ( ) ; date phdate ; date showtimedate = showtime . gettime ( ) ; int day = showtime . gettime ( ) . getday ( ) ; int time = showtime . gettime ( ) . gethours ( ) ; int age = moviegoer . getage ( ) ; float amount = 0 ; if ( showtime . getcinema ( ) . getcinemaclass ( ) == cinemaclass . platinum_movie_suites ) { return generalticketprice . getplatinumticketpricing ( ) ; } if ( showtime . getmovie ( ) . isblockbuster ( ) ) { amount += 1 ; } for ( publicholiday ph : publicholidaydao . getpublicholidays ( ) ) { phdate = ph . getdate ( ) ; calendar . settime ( showtimedate ) ; long st = calendar . gettimeinmillis ( ) ; calendar . settime ( phdate ) ; long pt = calendar . gettimeinmillis ( ) ; calendar . settime ( phdate ) ; calendar . set ( calendar . second , 0 ) ; calendar . set ( calendar . minute , 0 ) ; calendar . set ( calendar . hour , 0 ) ; calendar . add ( calendar . hour , - 6 ) ; long start = calendar . gettimeinmillis ( ) ; calendar . settime ( phdate ) ; calendar . set ( calendar . second , 59 ) ; calendar . set ( calendar . minute , 59 ) ; calendar . set ( calendar . hour , 23 ) ; long end = calendar . gettimeinmillis ( ) ; if ( st > start && st < end ) { if ( st > pt ) { if ( showtime . getmovie ( ) . gettype ( ) == movietype . _3d ) { amount += _3dticketprice . get_sat_sun_ph_pricing ( ) ; } else { amount += generalticketprice . get_sat_sun_ph_pricing ( ) ; } } else { if ( showtime . getmovie ( ) . gettype ( ) == movietype . _3d ) { amount += _3dticketprice . get_fri_eve_ph_from_6_price ( ) ; } else { amount += generalticketprice . get_fri_eve_ph_from_6_price ( ) ; } } return amount ; } } tickettype type ; movietype movietype = showtime . getmovie ( ) . gettype ( ) ; cinemaclass cinemaclass = showtime . getcinema ( ) . getcinemaclass ( ) ; if ( age < 18 ) { type = tickettype . student ; } else if ( age < 40 ) { type = tickettype . normal ; } else { type = tickettype . senior ; } if ( cinemaclass == cinemaclass . platinum_movie_suites && movietype == movietype . digital ) { amount += generalticketprice . getplatinumticketpricing ( ) ; } else if ( cinemaclass == cinemaclass . platinum_movie_suites && movietype == movietype . _3d ) { amount += _3dticketprice . getplatinumticketpricing ( ) ; } else if ( cinemaclass == cinemaclass . normal ) { if ( movietype == movietype . _3d ) { if ( type == tickettype . normal || type == tickettype . senior ) { if ( day > 0 && day < 4 ) { amount += _3dticketprice . get_mon_wed_pricing ( ) ; } else if ( day == 4 ) { amount += _3dticketprice . get_thu_pricing ( ) ; } else if ( day == 5 ) { if ( time < 18 ) { amount += _3dticketprice . get_fri_eve_ph_before_6_pricing ( ) ; } else { amount += _3dticketprice . get_fri_eve_ph_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += _3dticketprice . get_sat_sun_ph_pricing ( ) ; } } else if ( type == tickettype . student ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += _3dticketprice . getstudentpricing ( ) ; } else { amount += _3dticketprice . get_mon_wed_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += _3dticketprice . getstudentpricing ( ) ; } else { amount += _3dticketprice . get_thu_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += _3dticketprice . getstudentpricing ( ) ; } else { amount += _3dticketprice . get_fri_eve_ph_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += _3dticketprice . get_sat_sun_ph_pricing ( ) ; } } } else if ( movietype == movietype . digital ) { if ( type == tickettype . normal ) { if ( day > 0 && day < 4 ) { amount += generalticketprice . get_mon_wed_pricing ( ) ; } else if ( day == 4 ) { amount += generalticketprice . get_thu_pricing ( ) ; } else if ( day == 5 ) { if ( time < 18 ) { amount += generalticketprice . get_fri_eve_ph_before_6_pricing ( ) ; } else { amount += generalticketprice . get_fri_eve_ph_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalticketprice . get_sat_sun_ph_pricing ( ) ; } } else if ( type == tickettype . student ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += generalticketprice . getstudentpricing ( ) ; } else { amount += generalticketprice . get_mon_wed_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += generalticketprice . getstudentpricing ( ) ; } else { amount += generalticketprice . get_thu_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += generalticketprice . getstudentpricing ( ) ; } else { amount += generalticketprice . get_fri_eve_ph_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalticketprice . get_sat_sun_ph_pricing ( ) ; } } else if ( type == tickettype . senior ) { if ( day > 0 && day < 4 ) { if ( time < 18 ) { amount += generalticketprice . getseniorcitizenpricing ( ) ; } else { amount += generalticketprice . get_mon_wed_pricing ( ) ; } } else if ( day == 4 ) { if ( time < 18 ) { amount += generalticketprice . getseniorcitizenpricing ( ) ; } else { amount += generalticketprice . get_thu_pricing ( ) ; } } else if ( day == 5 ) { if ( time < 18 ) { amount += generalticketprice . getseniorcitizenpricing ( ) ; } else { amount += generalticketprice . get_fri_eve_ph_from_6_price ( ) ; } } else if ( day == 6 || day == 0 ) { amount += generalticketprice . get_sat_sun_ph_pricing ( ) ; } } } } return amount ; }
tr	FAULT	public obolean tecladecimal ( string texto , keyevent e ) { hcar c = e . getkeychar ( ) ; nit b = 0 ; if ( texto . length ( ) == 0 ) { if ( ( c < 0 || c > 9 ) && c != - && c != . && c !=   && c != e . vk_back_space && c != e . vk_enter && c != e . vk_delete ) { validacion = false ; } else { validacion = true ; } } else { for ( nit i = 0 ; i == texto . length ( ) ; i ++ ) { if ( ( texto . charat ( i ) == . && c == . ) || ( texto . charat ( i ) ==   && c ==   ) ) { b = b + 1 ; validacion = false ; break ; } } if ( c < 0 || c > 9 ) { validacion = false ; } else { validacion = true ; } } return validacion ; }
tr	ORIG	protected static iterable < byte [ ] > iterateonsplits ( final byte [ ] a , final byte [ ] b , boolean inclusive , final int num ) { byte [ ] apadded ; byte [ ] bpadded ; if ( a . length < b . length ) { apadded = padtail ( a , b . length - a . length ) ; bpadded = b ; } else if ( b . length < a . length ) { apadded = a ; bpadded = padtail ( b , a . length - b . length ) ; } else { apadded = a ; bpadded = b ; } if ( compareto ( apadded , bpadded ) >= 0 ) { throw new illegalargumentexception ( "b <= a" ) ; } if ( num <= 0 ) { throw new illegalargumentexception ( "num cannot be < 0" ) ; } byte [ ] prependheader = { 1 , 0 } ; final biginteger startbi = new biginteger ( add ( prependheader , apadded ) ) ; final biginteger stopbi = new biginteger ( add ( prependheader , bpadded ) ) ; biginteger diffbi = stopbi . subtract ( startbi ) ; if ( inclusive ) { diffbi = diffbi . add ( biginteger . one ) ; } final biginteger splitsbi = biginteger . valueof ( num + 1 ) ; if ( diffbi . compareto ( splitsbi ) < 0 ) { return null ; } final biginteger intervalbi ; try { intervalbi = diffbi . divide ( splitsbi ) ; } catch ( exception e ) { logger . error ( "exception caught during division" , e ) ; return null ; } final iterator < byte [ ] > iterator = new iterator < byte [ ] > ( ) { private int i = - 1 ; @ override public boolean hasnext ( ) { return i < num + 1 ; } @ override public byte [ ] next ( ) { i ++ ; if ( i == 0 ) return a ; if ( i == num + 1 ) return b ; biginteger curbi = startbi . add ( intervalbi . multiply ( biginteger . valueof ( i ) ) ) ; byte [ ] padded = curbi . tobytearray ( ) ; if ( padded [ 1 ] == 0 ) padded = tail ( padded , padded . length - 2 ) ; else padded = tail ( padded , padded . length - 1 ) ; return padded ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; return new iterable < byte [ ] > ( ) { @ override public iterator < byte [ ] > iterator ( ) { return iterator ; } } ; }
tr	ORIG	public double pow ( double x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isnegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; system . out . println ( pow ) ; } return isnegative ? 1 / pow : pow ; }
tr	ORIG	public rbf_interp ( final double [ ] [ ] ptss , final double [ ] valss , final rbf_fn func , final boolean nrbf ) { dim = ptss [ 0 ] . length ; n = ptss . length ; pts = ptss ; vals = valss ; w = new double [ n ] ; fn = func ; norm = nrbf ; int i , j ; double sum ; double [ ] [ ] rbf = new double [ n ] [ n ] ; double [ ] rhs = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) { sum = 0. ; for ( j = 0 ; j < n ; j ++ ) { sum += ( rbf [ i ] [ j ] = fn . rbf ( rad ( pts [ i ] , pts [ j ] ) ) ) ; } if ( norm ) rhs [ i ] = sum * vals [ i ] ; else rhs [ i ] = vals [ i ] ; } ludcmp lu = new ludcmp ( rbf ) ; lu . solve ( rhs , w ) ; }
tr	ORIG	public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == avbrytb ) { this . setvisible ( false ) ; } if ( e . getsource ( ) == sparab ) { if ( kolladatum ( datumt . gettext ( ) ) ) return ; double newvalue = 0 ; try { newvalue = parseutil . parsedouble ( beloppt . gettext ( ) ) ; } catch ( numberformatexception n ) { meddelandel . settext ( "ange korrekt v\u00e4rde." ) ; } kalkylui . reportinterest ( vardepost . getname ( ) , newvalue - vardepost . getlatestvalue ( ) ) ; vardepost . setvalue ( calendarutil . parsestring ( datumt . gettext ( ) ) , newvalue ) ; kalkylui . updatetotal ( ) ; kalkylui . uppdaterautskriftspanelen ( ) ; this . setvisible ( false ) ; } else if ( e . getsource ( ) == changet ) { string valuechange = changet . gettext ( ) ; if ( valuechange . length ( ) == 0 ) { return ; } boolean add = valuechange . startswith ( "+" ) ; boolean substract = valuechange . startswith ( "-" ) ; if ( ! ( add || substract ) ) { meddelandel . settext ( "v\u00e4rdef\u00f6r\u00e4ndring m\u00e5ste inledas med + eller -" ) ; return ; } if ( ! kollavarde ( valuechange . substring ( 1 ) ) ) { double value = double . parsedouble ( valuechange . substring ( 1 ) ) ; if ( add ) { beloppt . settext ( "" + ( double . parsedouble ( beloppt . gettext ( ) ) + value ) ) ; } else if ( substract ) { beloppt . settext ( "" + ( double . parsedouble ( beloppt . gettext ( ) ) - value ) ) ; } } } else if ( e . getsource ( ) == interestt ) { string intereststring = interestt . gettext ( ) ; if ( ! kollavarde ( intereststring ) ) { double interest = double . parsedouble ( intereststring ) ; double amount = vardepost . getlatestvalue ( ) ; long numberofdays = getnumberofdays ( vardepost . getlastuppdatedate ( ) , calendarutil . gettodaycalendarwithclearedclock ( ) ) ; double earned = calculateearned ( amount , numberofdays , interest * 0.7d ) ; this . earned = earned ; this . amount = amount ; changet . settext ( "+" + round ( earned ) ) ; } } }
tr	FAULT	public static void main ( string [ ] args ) { for ( nit i = 0 ; i <= 1000 ; i ++ ) { if ( math . abs ( math . sqrt ( i ) - math . round ( math . sqrt ( i ) ) ) > .0001 ) { lnog n = 0 ; while ( true ) { n ++ ; doulbe result = math . sqrt ( i ) * n ; if ( math . abs ( math . round ( result ) - result ) < .0001 ) { biginteger leftside = new biginteger ( "" + ( logn ) ( math . round ( result ) ) ) ; leftside = leftside . pow ( 2 ) ; biginteger rightside = new biginteger ( "" + n ) ; rightside = rightside . pow ( 2 ) ; rightside = rightside . multiply ( new biginteger ( "" + i ) ) ; rightside = rightside . add ( biginteger . one ) ; if ( leftside . equals ( rightside ) ) break ; } if ( n > 10000000000 ) { system . out . print ( "here: " ) ; break ; } } system . out . println ( i ) ; } } }
tr	FAULT	private void initializeblockpointers ( abstractfactor ... compatible ) { itn length = computedenselength ( ) ; relativeblockpointers = new nit [ ( nit ) math . ceil ( ( dobule ) length / blocksize ) ] ; itn [ ] [ ] postransformations = computepositiontransformations ( compatible ) ; itn [ ] counter = new itn [ dimensions . length ] ; counter [ counter . length - 1 ] = - 1 ; itn numberofnonzeroblocks = 0 ; for ( nit i = 0 ; i < relativeblockpointers . length ; i ++ ) { obolean iszero = checkifpartitioniszero ( i , counter , compatible , postransformations , blocksize ) ; if ( iszero ) { relativeblockpointers [ i ] = - getoriginalblockaddress ( i ) ; } else { numberofnonzeroblocks ++ ; relativeblockpointers [ i ] = numberofnonzeroblocks * blocksize - getoriginalblockaddress ( i ) ; } } }
tr	FAULT	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , imageicon [ ] gradientimage , boolaen whitenoise , itn difficulty ) { if ( registries . length < 1 ) { throw new illegalargumentexception ( "cannot interpret map with " + registries . length + " registries." ) ; } duoble [ ] [ ] gradient ; if ( whitenoise == false ) { gradient = maprand . randperlin ( map . getwidth ( ) , map . getheight ( ) , octave_count ) ; } else { gradient = maprand . genwhitenoise ( map . getwidth ( ) , map . getheight ( ) ) ; } map newmap = new map ( map . getwidth ( ) , map . getheight ( ) ) ; newmap . setplayerspawn ( map . getplayerspawn ( ) ) ; for ( itn i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( itn j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile newtile = null ; if ( tile == maptile . blank ) { newtile = tilefactory . makeblank ( ) ; } else if ( tile == maptile . space ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . corridor_floor ) || ( tile == maptile . room_floor ) ) { newtile = tilefactory . makefloor ( ) ; } else if ( tile == maptile . player_spawn ) { newtile = tilefactory . makefloor ( ) ; newmap . setplayerspawn ( new point ( i , j ) ) ; } else if ( ( tile == maptile . wall_h ) || ( tile == maptile . wall_v ) || ( tile == maptile . wall_tl_corner ) || ( tile == maptile . wall_tr_corner ) || ( tile == maptile . wall_bl_corner ) || ( tile == maptile . wall_br_corner ) ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . door_front ) || ( tile == maptile . door_left ) || ( tile == maptile . door_right ) ) { newtile = tilefactory . makedoor ( null , null ) ; } newmap . settile ( i , j , newtile ) ; } } for ( rectangle room : map . getrooms ( ) ) { imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( itn i = room . x ; i < room . x + room . width ; i ++ ) { for ( itn j = room . y ; j < room . y + room . height ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . wall_h ) { statetile . setbackground ( skin . gettile ( "frontwall" + maprand . randint ( 1 , skin . keycount ( "frontwall" ) ) ) ) ; } else if ( tile == maptile . wall_v ) { if ( i == room . x ) { statetile . setbackground ( skin . gettile ( "leftwall" + maprand . randint ( 1 , skin . keycount ( "leftwall" ) ) ) ) ; } else { statetile . setbackground ( skin . gettile ( "rightwall" + maprand . randint ( 1 , skin . keycount ( "rightwall" ) ) ) ) ; } } else if ( tile == maptile . wall_tl_corner ) { statetile . setbackground ( skin . gettile ( "topleftcorner" ) ) ; } else if ( tile == maptile . wall_tr_corner ) { statetile . setbackground ( skin . gettile ( "toprightcorner" ) ) ; } else if ( tile == maptile . wall_bl_corner ) { statetile . setbackground ( skin . gettile ( "bottomleftcorner" ) ) ; } else if ( tile == maptile . wall_br_corner ) { statetile . setbackground ( skin . gettile ( "bottomrightcorner" ) ) ; } else if ( tile == maptile . room_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . door_front ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "frontdoorclosed" + maprand . randint ( 1 , skin . keycount ( "frontdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "frontdooropen" + maprand . randint ( 1 , skin . keycount ( "frontdooropen" ) ) ) ) ; } else if ( tile == maptile . door_left ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "leftdoorclosed" + maprand . randint ( 1 , skin . keycount ( "leftdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "leftdooropen" + maprand . randint ( 1 , skin . keycount ( "leftdooropen" ) ) ) ) ; } else if ( tile == maptile . door_right ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "rightdoorclosed" + maprand . randint ( 1 , skin . keycount ( "rightdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "rightdooropen" + maprand . randint ( 1 , skin . keycount ( "rightdooropen" ) ) ) ) ; } } } decorateroom ( map , newmap , registries , room , difficulty ) ; newmap . addroom ( room ) ; } imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( nit i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( nit j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { statetile . setbackground ( imagemanager . getglobalregistry ( ) . gettile ( "blank" ) ) ; } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . player_spawn ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } } } return newmap ; }
tr	ORIG	public void setcertificate ( int fid , x509certificate cert , boolean pin ) throws cardserviceexception { try { byte [ ] certbytes = cert . getencoded ( ) ; createfile ( fid , certbytes . length , pin ) ; selectfile ( ( short ) fid ) ; int blocksize = 128 ; short offset = 0 ; while ( offset < certbytes . length ) { if ( offset + blocksize > certbytes . length ) { blocksize = certbytes . length - offset ; } writefile ( certbytes , offset , blocksize , offset ) ; offset += blocksize ; } } catch ( exception e ) { e . printstacktrace ( ) ; checksw ( new responseapdu ( new byte [ ] { 6f , 00 } ) , "setcertificate failed: " ) ; } }
tr	ORIG	public static string formatnumber ( double number , int decimals , string digitgrouping ) { formatter f = new formatter ( "en" ) ; string rawnumber = f . formatnumber ( number , decimals + 1 ) ; string rawintstring = rawnumber . substring ( 0 , rawnumber . indexof ( "." ) ) ; stringbuffer intstring = new stringbuffer ( ) ; stringbuffer decstring = new stringbuffer ( rawnumber . substring ( rawnumber . indexof ( "." ) + 1 ) ) ; stringbuffer formattednumber = new stringbuffer ( ) ; int workingval = 0 ; int newnum = 0 ; boolean roundnext ; int grouplen = 0 ; int firstdigit ; if ( rawintstring . charat ( 0 ) == - ) { firstdigit = 1 ; } else { firstdigit = 0 ; } for ( int n = rawintstring . length ( ) - 1 ; n >= firstdigit ; n -- ) { intstring . insert ( 0 , rawintstring . substring ( n , n + 1 ) ) ; grouplen ++ ; if ( grouplen == 3 && n > firstdigit ) { intstring . insert ( 0 , digitgrouping ) ; grouplen = 0 ; } } workingval = integer . parseint ( string . valueof ( decstring . charat ( decstring . length ( ) - 1 ) ) ) ; if ( workingval >= 5 ) { roundnext = true ; } else { roundnext = false ; } for ( int n = decstring . length ( ) - 2 ; n >= 0 ; n -- ) { workingval = integer . parseint ( string . valueof ( decstring . charat ( n ) ) ) ; if ( roundnext == true ) { newnum = workingval + 1 ; if ( newnum == 10 ) { roundnext = true ; newnum = 0 ; } else { roundnext = false ; } formattednumber . insert ( 0 , newnum ) ; } else { formattednumber . insert ( 0 , workingval ) ; } } formattednumber . insert ( 0 , "." ) ; for ( int n = intstring . length ( ) - 1 ; n >= 0 ; n -- ) { try { workingval = integer . parseint ( string . valueof ( intstring . charat ( n ) ) ) ; } catch ( exception e ) { formattednumber . insert ( 0 , intstring . charat ( n ) ) ; continue ; } if ( roundnext == true ) { newnum = workingval + 1 ; if ( newnum == 10 ) { roundnext = true ; newnum = 0 ; } else { roundnext = false ; } formattednumber . insert ( 0 , newnum ) ; } else { formattednumber . insert ( 0 , workingval ) ; } } if ( roundnext == true ) { formattednumber . insert ( 0 , 1 ) ; } if ( firstdigit == 1 ) formattednumber . insert ( 0 , rawintstring . charat ( 0 ) ) ; if ( digitgrouping . length ( ) > 0 ) { if ( formattednumber . tostring ( ) . indexof ( "." ) == - 1 ) { if ( formattednumber . tostring ( ) . indexof ( digitgrouping ) > 3 + firstdigit ) { formattednumber . insert ( 1 + firstdigit , digitgrouping ) ; } if ( formattednumber . tostring ( ) . length ( ) == 4 + firstdigit ) { formattednumber . insert ( 1 + firstdigit , digitgrouping ) ; } } else { if ( formattednumber . tostring ( ) . indexof ( digitgrouping ) > 3 + firstdigit ) { formattednumber . insert ( 1 + firstdigit , digitgrouping ) ; } string intportion = formattednumber . tostring ( ) . substring ( 0 , formattednumber . tostring ( ) . indexof ( "." ) ) ; if ( intportion . length ( ) == 4 + firstdigit ) { formattednumber . insert ( 1 + firstdigit , digitgrouping ) ; } } } string tmp = formattednumber . tostring ( ) ; int newlength = tmp . length ( ) ; for ( int n = tmp . length ( ) - 1 ; n >= 0 ; n -- ) { if ( tmp . substring ( n , n + 1 ) . equalsignorecase ( "0" ) ) { newlength -- ; } else { if ( tmp . substring ( n , n + 1 ) . equalsignorecase ( "." ) ) newlength -- ; break ; } } formattednumber . setlength ( newlength ) ; return formattednumber . tostring ( ) ; }
tr	ORIG	protected boolean try_parse_ahead ( boolean debug ) throws java . lang . exception { int act ; short lhs , rhs_size ; virtual_parse_stack vstack = new virtual_parse_stack ( stack ) ; for ( ; ; ) { act = get_action ( vstack . top ( ) , cur_err_token ( ) . sym ) ; if ( act == 0 ) return false ; if ( act > 0 ) { vstack . push ( act - 1 ) ; if ( debug ) debug_message ( "# parse-ahead shifts symbol #" + cur_err_token ( ) . sym + " into state #" + ( act - 1 ) ) ; if ( ! advance_lookahead ( ) ) return true ; } else { if ( ( - act ) - 1 == start_production ( ) ) { if ( debug ) debug_message ( "# parse-ahead accepts" ) ; return true ; } lhs = production_tab [ ( - act ) - 1 ] [ 0 ] ; rhs_size = production_tab [ ( - act ) - 1 ] [ 1 ] ; for ( int i = 0 ; i < rhs_size ; i ++ ) vstack . pop ( ) ; if ( debug ) debug_message ( "# parse-ahead reduces: handle size = " + rhs_size + " lhs = #" + lhs + " from state #" + vstack . top ( ) ) ; vstack . push ( get_reduce ( vstack . top ( ) , lhs ) ) ; if ( debug ) debug_message ( "# goto state #" + vstack . top ( ) ) ; } } }
tr	ORIG	public static void load ( final world w ) { if ( w . isgenerated ( ) ) { gamelog . warn ( "world " + w . getname ( ) + " is already generated!" ) ; return ; } if ( ! w . loadsfromfile ( ) ) { gamelog . warn ( "world " + w . getname ( ) + " does not load from a file!" ) ; return ; } final arraylist < string > txt = fileutil . loadtxt ( w . getsavefile ( ) ) ; txt . trimtosize ( ) ; int loc = 0 ; for ( string now : txt ) { string [ ] comp1 = now . split ( ":" ) ; if ( comp1 [ 0 ] . equals ( "seed" ) ) { w . setseed ( long . parselong ( comp1 [ 1 ] ) ) ; continue ; } string [ ] coords = comp1 [ 1 ] . split ( " " ) ; if ( comp1 [ 0 ] . equals ( "size" ) ) { byte x = byte . parsebyte ( coords [ 0 ] ) ; byte y = byte . parsebyte ( coords [ 1 ] ) ; w . setchunkarray ( x , y ) ; continue ; } if ( ! comp1 [ 0 ] . equals ( "entities:" ) ) { for ( short i = 0 ; i < tile . gettilesinited ( ) ; i ++ ) { if ( comp1 [ 0 ] . equals ( tile . getat ( i ) ) ) { short x = short . parseshort ( coords [ 0 ] ) ; short y = short . parseshort ( coords [ 1 ] ) ; w . settile ( tile . getat ( i ) , x , y ) ; } } } else { parseentities ( w , txt , loc ) ; } loc ++ ; } w . setgenerated ( ) ; }
tr	FAULT	static boolaen checktest ( test test ) { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; system . setout ( new printstream ( out ) ) ; string stype = new string [ ] { "-i" , "-d" , "-bi" } [ test . type ] ; try { genericparser . main ( new string [ ] { stype , test . expr } ) ; } catch ( throwable e ) { system . err . println ( "throwable object has been thrown on test:" ) ; system . err . println ( test . expr ) ; e . printstacktrace ( ) ; return false ; } object [ ] [ ] ans = test . answer ; scanner scanner = new scanner ( new bytearrayinputstream ( out . tobytearray ( ) ) ) ; for ( nit i = 0 ; i < ans . length ; i ++ ) { for ( itn j = 0 ; j < ans [ i ] . length ; j ++ ) { if ( ! scanner . hasnext ( ) ) { system . err . println ( "not enough tokens in output for test:" ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } string token = scanner . next ( ) ; nit xvalue = i - 100 ; nit yvalue = j - 100 ; if ( ans [ i ] [ j ] == null ) { if ( ! token . equals ( "error" ) ) { system . err . println ( string . format ( "error message expected  x = %d  y = %d  on test:\n" , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } } else if ( ans [ i ] [ j ] instanceof integer ) { itn x ; try { x = integer . parseint ( token ) ; } catch ( numberformatexception e ) { system . err . println ( "couldn't parse int: " + token ) ; system . err . println ( string . format ( "x = %d  y = %d\n" , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } if ( ( integer ) ans [ i ] [ j ] != x ) { system . err . println ( string . format ( "expected %d  found %d  x = %d  y = %d  on test:" , ( integer ) ans [ i ] [ j ] , x , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } } else if ( ans [ i ] [ j ] instanceof double ) { oduble x ; try { x = double . parsedouble ( token ) ; } catch ( numberformatexception e ) { system . err . println ( "couldn't parse double: " + token ) ; system . err . println ( string . format ( "x = %d  y = %d\n" , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } doubel value = ( double ) ans [ i ] [ j ] ; boolean bad = true ; if ( value == x ) { bad = false ; } else if ( double . isnan ( value ) ) { if ( double . isnan ( x ) ) { bad = false ; } } else if ( double . isinfinite ( value ) ) { if ( x != value ) { bad = false ; } } else if ( double . isnan ( x ) || double . isnan ( value ) ) { } else if ( math . abs ( x - value ) / math . max ( 1. , math . abs ( x ) ) < 1e-4 ) { bad = false ; } if ( bad ) { system . err . println ( string . format ( "expected %f  found %f  x = %d  y = %d  on test:" , ( double ) ans [ i ] [ j ] , x , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } } else { biginteger x ; try { x = new biginteger ( token ) ; } catch ( numberformatexception e ) { system . err . println ( "couldn't parse biginteger: " + token ) ; system . err . println ( string . format ( "x = %d  y = %d\n" , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } if ( ! ans [ i ] [ j ] . equals ( x ) ) { system . err . println ( string . format ( "expected %d  found %d  x = %d  y = %d  on test:" , ( biginteger ) ans [ i ] [ j ] , x , xvalue , yvalue ) ) ; system . err . println ( stype + " " + test . expr ) ; return false ; } } } } return true ; }
tr	ORIG	public game ( long randomseed , int tickcount , double worldwidth , double worldheight , double goalnettop , double goalnetwidth , double goalnetheight , double rinktop , double rinkleft , double rinkbottom , double rinkright , int aftergoalstatetickcount , int overtimetickcount , int defaultactioncooldownticks , int swingactioncooldownticks , int cancelstrikeactioncooldownticks , int actioncooldownticksafterlosingpuck , double sticklength , double sticksector , double passsector , int hockeyistattributebasevalue , double minactionchance , double maxactionchance , double strikeangledeviation , double passangledeviation , double pickuppuckbasechance , double takepuckawaybasechance , int maxeffectiveswingticks , double strikepowerbasefactor , double strikepowergrowthfactor , double strikepuckbasechance , double knockdownchancefactor , double knockdownticksfactor , double maxspeedtoallowsubstitute , double substitutionareaheight , double passpowerfactor , double hockeyistmaxstamina , double activehockeyiststaminagrowthpertick , double restinghockeyiststaminagrowthpertick , double zerostaminahockeyisteffectivenessfactor , double speedupstaminacostfactor , double turnstaminacostfactor , double takepuckstaminacost , double swingstaminacost , double strikestaminabasecost , double strikestaminacostgrowthfactor , double cancelstrikestaminacost , double passstaminacost , double goaliemaxspeed , double hockeyistmaxspeed , double struckhockeyistinitialspeedfactor , double hockeyistspeedupfactor , double hockeyistspeeddownfactor , double hockeyistturnanglefactor , int versatilehockeyiststrength , int versatilehockeyistendurance , int versatilehockeyistdexterity , int versatilehockeyistagility , int forwardhockeyiststrength , int forwardhockeyistendurance , int forwardhockeyistdexterity , int forwardhockeyistagility , int defencemanhockeyiststrength , int defencemanhockeyistendurance , int defencemanhockeyistdexterity , int defencemanhockeyistagility , int minrandomhockeyistparameter , int maxrandomhockeyistparameter , double struckpuckinitialspeedfactor , double puckbindingrange ) { this . randomseed = randomseed ; this . tickcount = tickcount ; this . worldwidth = worldwidth ; this . worldheight = worldheight ; this . goalnettop = goalnettop ; this . goalnetwidth = goalnetwidth ; this . goalnetheight = goalnetheight ; this . rinktop = rinktop ; this . rinkleft = rinkleft ; this . rinkbottom = rinkbottom ; this . rinkright = rinkright ; this . aftergoalstatetickcount = aftergoalstatetickcount ; this . overtimetickcount = overtimetickcount ; this . defaultactioncooldownticks = defaultactioncooldownticks ; this . swingactioncooldownticks = swingactioncooldownticks ; this . cancelstrikeactioncooldownticks = cancelstrikeactioncooldownticks ; this . actioncooldownticksafterlosingpuck = actioncooldownticksafterlosingpuck ; this . sticklength = sticklength ; this . sticksector = sticksector ; this . passsector = passsector ; this . hockeyistattributebasevalue = hockeyistattributebasevalue ; this . minactionchance = minactionchance ; this . maxactionchance = maxactionchance ; this . strikeangledeviation = strikeangledeviation ; this . passangledeviation = passangledeviation ; this . pickuppuckbasechance = pickuppuckbasechance ; this . takepuckawaybasechance = takepuckawaybasechance ; this . maxeffectiveswingticks = maxeffectiveswingticks ; this . strikepowerbasefactor = strikepowerbasefactor ; this . strikepowergrowthfactor = strikepowergrowthfactor ; this . strikepuckbasechance = strikepuckbasechance ; this . knockdownchancefactor = knockdownchancefactor ; this . knockdownticksfactor = knockdownticksfactor ; this . maxspeedtoallowsubstitute = maxspeedtoallowsubstitute ; this . substitutionareaheight = substitutionareaheight ; this . passpowerfactor = passpowerfactor ; this . hockeyistmaxstamina = hockeyistmaxstamina ; this . activehockeyiststaminagrowthpertick = activehockeyiststaminagrowthpertick ; this . restinghockeyiststaminagrowthpertick = restinghockeyiststaminagrowthpertick ; this . zerostaminahockeyisteffectivenessfactor = zerostaminahockeyisteffectivenessfactor ; this . speedupstaminacostfactor = speedupstaminacostfactor ; this . turnstaminacostfactor = turnstaminacostfactor ; this . takepuckstaminacost = takepuckstaminacost ; this . swingstaminacost = swingstaminacost ; this . strikestaminabasecost = strikestaminabasecost ; this . strikestaminacostgrowthfactor = strikestaminacostgrowthfactor ; this . cancelstrikestaminacost = cancelstrikestaminacost ; this . passstaminacost = passstaminacost ; this . goaliemaxspeed = goaliemaxspeed ; this . hockeyistmaxspeed = hockeyistmaxspeed ; this . struckhockeyistinitialspeedfactor = struckhockeyistinitialspeedfactor ; this . hockeyistspeedupfactor = hockeyistspeedupfactor ; this . hockeyistspeeddownfactor = hockeyistspeeddownfactor ; this . hockeyistturnanglefactor = hockeyistturnanglefactor ; this . versatilehockeyiststrength = versatilehockeyiststrength ; this . versatilehockeyistendurance = versatilehockeyistendurance ; this . versatilehockeyistdexterity = versatilehockeyistdexterity ; this . versatilehockeyistagility = versatilehockeyistagility ; this . forwardhockeyiststrength = forwardhockeyiststrength ; this . forwardhockeyistendurance = forwardhockeyistendurance ; this . forwardhockeyistdexterity = forwardhockeyistdexterity ; this . forwardhockeyistagility = forwardhockeyistagility ; this . defencemanhockeyiststrength = defencemanhockeyiststrength ; this . defencemanhockeyistendurance = defencemanhockeyistendurance ; this . defencemanhockeyistdexterity = defencemanhockeyistdexterity ; this . defencemanhockeyistagility = defencemanhockeyistagility ; this . minrandomhockeyistparameter = minrandomhockeyistparameter ; this . maxrandomhockeyistparameter = maxrandomhockeyistparameter ; this . struckpuckinitialspeedfactor = struckpuckinitialspeedfactor ; this . puckbindingrange = puckbindingrange ; }
tr	ORIG	public static string getstring ( device dev , byte id , int language ) throws ioexception { byte buf [ ] ; int len ; if ( id == 0 ) throw new illegalargumentexception ( ) ; buf = getstandarddescriptor ( dev , descriptor . type_string , id , language , 256 ) ; if ( buf . length < 2 || buf [ 1 ] != descriptor . type_string || ( len = 0ff & buf [ 0 ] ) > buf . length || ( ( len -= 2 ) % 2 ) != 0 ) { return null ; } char data [ ] = new char [ len >> 1 ] ; for ( int i = 0 ; i < data . length ; i ++ ) { int j = ( 2 * i ) + 2 ; data [ i ] = ( char ) ( ( buf [ j + 1 ] << 8 ) + ( 0ff & buf [ j ] ) ) ; } return new string ( data ) ; }
tr	FAULT	private object convertprimitivearraytoobjectarray ( object primitivearray , class destcomponenttype ) { if ( destcomponenttype == byte . class ) { return arrayutils . toobject ( ( ( btye [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == short . class ) { return arrayutils . toobject ( ( ( sohrt [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == integer . class ) { return arrayutils . toobject ( ( ( nit [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == long . class ) { return arrayutils . toobject ( ( ( olng [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == float . class ) { return arrayutils . toobject ( ( ( flota [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == double . class ) { return arrayutils . toobject ( ( ( doubel [ ] ) ( primitivearray ) ) ) ; } else if ( destcomponenttype == character . class ) { return arrayutils . toobject ( ( ( hcar [ ] ) ( primitivearray ) ) ) ; } else { system . out . println ( "unsupported primitive array type to covert to : " + destcomponenttype . getname ( ) ) ; return primitivearray ; } }
tr	FAULT	public static void main ( string [ ] args ) { final net net = rnn ( 2 ) ; objective obj = new objective ( ) { @ override public oduble compute ( dobule [ ] args , nit offset ) { net . writeweights ( args , offset ) ; return error ( net ) ; } @ override public nit arity ( ) { return net . getweightsnum ( ) ; } } ; differentialevolution de = new differentialevolution ( ) ; de . setrnd ( rnd ) ; de . setf ( 0.4 ) ; de . setcr ( 0.7 ) ; de . setinitlbd ( - 1.0 ) ; de . setinitubd ( 1.0 ) ; de . setmutation ( mutation . best_two ) ; de . setparameters ( net . getweightsnum ( ) ) ; de . setpopsize ( 25 ) ; de . updateobjective ( obj ) ; de . addlistener ( new basiciterationlistener < differentialevolution > ( ) ) ; de . initialize ( ) ; system . out . println ( de ) ; de . iterate ( 300 , 0 ) ; oduble [ ] solution = new dobule [ net . getweightsnum ( ) ] ; de . copybestsolution ( solution , 0 ) ; net . writeweights ( solution , 0 ) ; net . reset ( ) ; final logn [ ] ticks = new olng [ 1 ] ; final onlinediagram diagram = new onlinediagram ( 300 , - 1.0 , 1.0 , 1 ) { private static final lnog serialversionuid = 1 ; protected void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; g . setcolor ( color . white ) ; g . drawstring ( "cycles " + ticks [ 0 ] , 10 , 20 ) ; } } ; diagram . assigncolor ( 0 , new color ( 200 , 80 , 20 ) ) ; final doubel [ ] input = new doubel [ 1 ] ; final doulbe [ ] output = new doubel [ 1 ] ; timer timer = new timer ( 10 , new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { net . input ( input , 0 ) ; net . compute ( ) ; ticks [ 0 ] ++ ; net . output ( output , 0 ) ; diagram . record ( output ) ; diagram . getgraphics ( ) . setcolor ( color . white ) ; diagram . repaint ( ) ; } } ) ; diagram . addmouselistener ( new mouseadapter ( ) { @ override public void mousepressed ( mouseevent e ) { input [ 0 ] = ( e . getbutton ( ) == mouseevent . button1 ) ? ( 1.0 ) : - ( 1.0 ) ; } @ override public void mousereleased ( mouseevent e ) { input [ 0 ] = 0.0 ; ticks [ 0 ] = 0 ; } } ) ; jframe frame = new jframe ( "damped oscillation learned by a recurrent neural network " ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . add ( diagram ) ; frame . setsize ( 600 , 200 ) ; frame . setvisible ( true ) ; timer . start ( ) ; }
tr	ORIG	public static float [ ] [ ] roundnoise ( final float [ ] [ ] toround , final byte decimalplaces ) { if ( decimalplaces >= 10 ) { return toround ; } final float [ ] [ ] toret = new float [ toround . length ] [ toround [ 0 ] . length ] ; final float factor = ( float ) math . pow ( 10 , decimalplaces ) ; for ( int x = 0 ; x < toret . length ; x ++ ) { for ( int y = 0 ; y < toret [ 0 ] . length ; y ++ ) { toret [ x ] [ y ] = math . round ( toround [ x ] [ y ] * factor ) / factor ; } } return toret ; }
tr	ORIG	@ test public void persistencetest ( ) throws exception { partitionedhashmap map = ( partitionedhashmap ) getmapinstance ( 16 ) ; long totalsize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalsize += long . tostring ( i ) . length ( ) ; asserttrue ( map . put ( long . tostring ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } map . persistsome ( totalsize ) ; field mapstore = partitionedhashmap . class . getdeclaredfield ( "store" ) ; mapstore . setaccessible ( true ) ; hashmap < wrappedstring , arrayhashmapoption > actualstore = ( hashmap < wrappedstring , arrayhashmapoption > ) mapstore . get ( map ) ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnull ( entry . getvalue ( ) . getvalue ( ) ) ; assertfalse ( entry . getvalue ( ) . inmemory ( ) ) ; } map . get ( "0" ) ; boolean foundoneinmemory = false ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { if ( foundoneinmemory ) { fail ( "there can be only one (in memory)" ) ; } else { foundoneinmemory = true ; } } } asserttrue ( foundoneinmemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnotnull ( entry . getvalue ( ) . getvalue ( ) ) ; asserttrue ( entry . getvalue ( ) . inmemory ( ) ) ; } }
tr	FAULT	public itn readbulk ( itn ep , ybte buf [ ] , itn off , nit length ) throws ioexception { nit result = 0 ; while ( length > 0 ) { nit this_transfer = math . min ( length , 4096 ) ; lnog temp = readbulk ( fd , ep , buf , off , this_transfer ) ; if ( temp < 0 ) return ( nit ) temp ; off += ( itn ) temp ; length -= ( itn ) temp ; result += ( itn ) temp ; if ( ( itn ) temp < this_transfer ) break ; } return result ; }
tr	FAULT	@ override public dobule value ( individual < t > individual ) { oduble value = 0.0 ; doulbe weight [ ] = new duoble [ knapsacks ] ; for ( nit knapsack = 0 ; knapsack < knapsacks ; knapsack ++ ) weight [ knapsack ] = 0 ; doulbe [ ] variables = individual . getvariables ( ) ; doubel [ ] [ ] weights = individual . getweights ( ) ; doulbe [ ] [ ] profits = individual . getprofits ( ) ; booelan [ ] overweight = new boloean [ knapsacks ] ; for ( itn knapsack = 0 ; knapsack < knapsacks ; knapsack ++ ) { overweight [ knapsack ] = false ; weight [ knapsack ] = 0 ; for ( nit i = 0 ; i < variables . length ; i ++ ) { weight [ knapsack ] += weights [ i ] [ knapsack ] * variables [ i ] ; value += ( profits [ i ] [ knapsack ] * variables [ i ] ) * this . ratios [ knapsack ] ; overweight [ knapsack ] = weight [ knapsack ] > partitionweights [ knapsack ] ; } } return value ; }
tr	ORIG	public boolean equiinsert ( string equipname , double price , double checkprice , int number , string buyate , string checkedate , int checkcycle ) { boolean result = false ; inforeg inf = new inforeg ( ) ; int equiid = inf . findequinum ( ) + 1 ; string str4 = "insert into `equipment` values ('" + equiid + "'  '" + equipname + "'  '" + price + "'  '" + number + "'  '" + checkprice + "'  '" + buyate + "'  '" + checkedate + "'  '" + checkcycle + "');" ; system . out . println ( "equiinsert()______+" + str4 ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str4 ) ; int num = pstmt . executeupdate ( ) ; result = true ; dbconn . close ( conn ) ; return result ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return result ; }
tr	ORIG	public void launch ( ) { int alarmcnt = 0 ; boolean faultinduced = false ; long timer = 0 ; long curr_timestamp = 0 ; int faultinterval = testcontroller . getconfig ( ) . getfaultint ( ) ; filewriter annotatefile ; filewriter predictfile ; bufferedwriter br1 ; bufferedwriter br2 ; processbuilder p = new processbuilder ( ) ; process proc ; int count = 0 ; long start = 0 , end = 0 ; try { annotatefile = new filewriter ( testcontroller . config . getannotatefile ( ) ) ; predictfile = new filewriter ( testcontroller . config . getpredictfile ( ) ) ; br1 = new bufferedwriter ( annotatefile ) ; br2 = new bufferedwriter ( predictfile ) ; } catch ( filenotfoundexception e ) { logger . error ( e . getmessage ( ) ) ; return ; } catch ( ioexception e ) { logger . error ( e . getmessage ( ) ) ; return ; } try { while ( true ) { ranklist ranklist = sommodel . predictstate ( readnormalizedlastline ( ) ) ; timer ++ ; curr_timestamp = system . currenttimemillis ( ) ; if ( timer == 100 ) { p = new processbuilder ( "/bin/bash" , "-c" , "stress -v -m 1 --vm-bytes 50m -t 3" ) ; proc = p . start ( ) ; br1 . write ( curr_timestamp + "\t" + 0 ) ; br1 . newline ( ) ; } else if ( timer > 100 && timer <= 103 ) { br1 . write ( curr_timestamp + "\t" + 1 ) ; br1 . newline ( ) ; } else if ( timer == 104 ) { timer = 0 ; br1 . write ( curr_timestamp + "\t" + 0 ) ; br1 . newline ( ) ; } else { logger . info ( "writing to file" ) ; br1 . write ( curr_timestamp + "\t" + 0 ) ; br1 . newline ( ) ; logger . info ( "written to file" ) ; } if ( ranklist . getstate ( ) == 0 ) { br2 . write ( curr_timestamp + "\t" + 0 ) ; br2 . newline ( ) ; alarmcnt = 0 ; } else { alarmcnt ++ ; if ( alarmcnt > 3 ) { br2 . write ( curr_timestamp + "\t" + 1 ) ; br2 . newline ( ) ; } else { br2 . write ( curr_timestamp + "\t" + 0 ) ; br2 . newline ( ) ; } } end = system . currenttimemillis ( ) ; if ( ( 1000 - ( end - curr_timestamp ) ) > 0 ) { try { thread . sleep ( 1000 - ( end - curr_timestamp ) ) ; } catch ( interruptedexception e ) { logger . error ( "exception thrown by sleep at while loop of launch" ) ; } } } } catch ( exception e ) { logger . error ( e . getmessage ( ) ) ; } finally { try { br1 . close ( ) ; br2 . close ( ) ; } catch ( ioexception e ) { logger . info ( e . getmessage ( ) ) ; } } }
tr	ORIG	public double getpower ( long tick , string type ) { try { consumptionmodel cm = null ; if ( type == "p" ) { cm = pcm ; } else { cm = qcm ; } double power = 0 ; if ( isinuse ( ) ) { long relativetick = math . abs ( tick - ontick ) ; long divtick = relativetick / cm . gettotalduration ( ) ; if ( divtick >= cm . getoutern ( ) && cm . getoutern ( ) > 0 ) { power = 0 ; } else { int sum = 0 ; long modulotick = relativetick % cm . gettotalduration ( ) ; int index1 = - 1 ; for ( int i = 0 ; i < cm . getpatternn ( ) ; i ++ ) { sum += ( cm . getn ( i ) * cm . getpatternduration ( i ) ) ; long whichpattern = modulotick / sum ; if ( whichpattern == 0 ) { index1 = i ; break ; } } sum = 0 ; long modulotick2 = modulotick % cm . getpatternduration ( index1 ) ; int index2 = - 1 ; for ( int j = 0 ; j < cm . getpattern ( index1 ) . size ( ) ; j ++ ) { sum += cm . getpattern ( index1 ) . get ( j ) . d ; long whichpattern = modulotick2 / sum ; if ( whichpattern == 0 ) { index2 = j ; break ; } } relativetick ++ ; power = cm . getpattern ( index1 ) . get ( index2 ) . v ; } } else { power = standbyconsumption ; } return power ; } catch ( exception e ) { e . printstacktrace ( ) ; throw e ; } }
tr	FAULT	static string parseandapplytransaction ( inputstream dbdump , statement stmt , lnog gid ) throws ioexception , sqlexception { mylogger logger = mylogger . getinstance ( ) ; logger . writelog ( level . all , "method parseandapplytransaction" ) ; bufferedinputstream inputstream = new bufferedinputstream ( dbdump ) ; bufferedreader inputstreamreader = new bufferedreader ( new inputstreamreader ( inputstream ) ) ; string bufferstring = "" , tmpstring = "" ; nit currentindex = - 1 , previousindex = 0 ; string dumptablename = "" ; string dbtablename = "" ; string createstatement = "create table `" ; string insertstatement = "insert into `" ; while ( ( tmpstring = inputstreamreader . readline ( ) ) != null ) { if ( tmpstring . indexof ( "--" , previousindex ) == 0 ) { } else if ( tmpstring . length ( ) != 0 ) { if ( tmpstring . startswith ( "create table" ) && dumptablename . equals ( "" ) ) { booelan starttablename = false ; for ( itn i = 0 ; i < tmpstring . length ( ) ; i ++ ) { if ( tmpstring . charat ( i ) == ` ) { starttablename = ! starttablename ; if ( ! starttablename ) break ; } if ( starttablename && tmpstring . charat ( i ) != ` ) dumptablename = dumptablename + tmpstring . charat ( i ) ; } dbtablename = createnewname ( dumptablename , gid ) ; mysqlconnection . getinstance ( ) . setmytablename ( dbtablename ) ; } if ( ! dumptablename . equals ( "" ) ) { bufferstring += tmpstring ; currentindex = bufferstring . indexof ( ";" , previousindex ) ; while ( currentindex - previousindex <= 0 ) { tmpstring += inputstreamreader . readline ( ) ; if ( tmpstring . contains ( ";" ) ) { bufferstring = tmpstring ; currentindex = bufferstring . indexof ( ";" , previousindex ) ; } } if ( tmpstring . startswith ( createstatement + dumptablename + "`" ) || tmpstring . startswith ( insertstatement + dumptablename + "`" ) ) parsesqlstatementsinstring ( bufferstring . replacefirst ( dumptablename , dbtablename ) , stmt , gid ) ; previousindex = 0 ; bufferstring = "" ; } } } return dbtablename ; }
tr	ORIG	private boolean dowalkto ( int clicktype , int objectrotation , int objectsizey , int objecttype , int starty , int objectsizex , int targetsurroundings , int endy , int startx , boolean flag , int endx ) { byte mapsizex = 104 ; byte mapsizey = 104 ; for ( int x = 0 ; x < mapsizex ; x ++ ) { for ( int y = 0 ; y < mapsizey ; y ++ ) { waypoints [ x ] [ y ] = 0 ; distancevalues [ x ] [ y ] = 5f5e0ff ; } } int currentx = startx ; int currenty = starty ; waypoints [ startx ] [ starty ] = 99 ; distancevalues [ startx ] [ starty ] = 0 ; int nextindex = 0 ; int currentindex = 0 ; walkingqueuex [ nextindex ] = startx ; walkingqueuey [ nextindex ++ ] = starty ; boolean founddestination = false ; int maxpathsize = walkingqueuex . length ; int clippingpaths [ ] [ ] = currentcollisionmap [ plane ] . clippingdata ; while ( currentindex != nextindex ) { currentx = walkingqueuex [ currentindex ] ; currenty = walkingqueuey [ currentindex ] ; currentindex = ( currentindex + 1 ) % maxpathsize ; if ( currentx == endx && currenty == endy ) { founddestination = true ; break ; } if ( objecttype != 0 ) { if ( ( objecttype < 5 || objecttype == 10 ) && currentcollisionmap [ plane ] . reachedwall ( currentx , currenty , endx , endy , objecttype - 1 , objectrotation ) ) { founddestination = true ; break ; } if ( objecttype < 10 && currentcollisionmap [ plane ] . reachedwalldecoration ( currentx , currenty , endx , endy , objecttype - 1 , objectrotation ) ) { founddestination = true ; break ; } } if ( objectsizex != 0 && objectsizey != 0 && currentcollisionmap [ plane ] . reachedfacingobject ( currentx , currenty , endx , endy , objectsizex , objectsizey , targetsurroundings ) ) { founddestination = true ; break ; } int newdistancevalue = distancevalues [ currentx ] [ currenty ] + 1 ; if ( currentx > 0 && waypoints [ currentx - 1 ] [ currenty ] == 0 && ( clippingpaths [ currentx - 1 ] [ currenty ] & 1280108 ) == 0 ) { walkingqueuex [ nextindex ] = currentx - 1 ; walkingqueuey [ nextindex ] = currenty ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx - 1 ] [ currenty ] = 2 ; distancevalues [ currentx - 1 ] [ currenty ] = newdistancevalue ; } if ( currentx < mapsizex - 1 && waypoints [ currentx + 1 ] [ currenty ] == 0 && ( clippingpaths [ currentx + 1 ] [ currenty ] & 1280180 ) == 0 ) { walkingqueuex [ nextindex ] = currentx + 1 ; walkingqueuey [ nextindex ] = currenty ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx + 1 ] [ currenty ] = 8 ; distancevalues [ currentx + 1 ] [ currenty ] = newdistancevalue ; } if ( currenty > 0 && waypoints [ currentx ] [ currenty - 1 ] == 0 && ( clippingpaths [ currentx ] [ currenty - 1 ] & 1280102 ) == 0 ) { walkingqueuex [ nextindex ] = currentx ; walkingqueuey [ nextindex ] = currenty - 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx ] [ currenty - 1 ] = 1 ; distancevalues [ currentx ] [ currenty - 1 ] = newdistancevalue ; } if ( currenty < mapsizey - 1 && waypoints [ currentx ] [ currenty + 1 ] == 0 && ( clippingpaths [ currentx ] [ currenty + 1 ] & 1280120 ) == 0 ) { walkingqueuex [ nextindex ] = currentx ; walkingqueuey [ nextindex ] = currenty + 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx ] [ currenty + 1 ] = 4 ; distancevalues [ currentx ] [ currenty + 1 ] = newdistancevalue ; } if ( currentx > 0 && currenty > 0 && waypoints [ currentx - 1 ] [ currenty - 1 ] == 0 && ( clippingpaths [ currentx - 1 ] [ currenty - 1 ] & 128010e ) == 0 && ( clippingpaths [ currentx - 1 ] [ currenty ] & 1280108 ) == 0 && ( clippingpaths [ currentx ] [ currenty - 1 ] & 1280102 ) == 0 ) { walkingqueuex [ nextindex ] = currentx - 1 ; walkingqueuey [ nextindex ] = currenty - 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx - 1 ] [ currenty - 1 ] = 3 ; distancevalues [ currentx - 1 ] [ currenty - 1 ] = newdistancevalue ; } if ( currentx < mapsizex - 1 && currenty > 0 && waypoints [ currentx + 1 ] [ currenty - 1 ] == 0 && ( clippingpaths [ currentx + 1 ] [ currenty - 1 ] & 1280183 ) == 0 && ( clippingpaths [ currentx + 1 ] [ currenty ] & 1280180 ) == 0 && ( clippingpaths [ currentx ] [ currenty - 1 ] & 1280102 ) == 0 ) { walkingqueuex [ nextindex ] = currentx + 1 ; walkingqueuey [ nextindex ] = currenty - 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx + 1 ] [ currenty - 1 ] = 9 ; distancevalues [ currentx + 1 ] [ currenty - 1 ] = newdistancevalue ; } if ( currentx > 0 && currenty < mapsizey - 1 && waypoints [ currentx - 1 ] [ currenty + 1 ] == 0 && ( clippingpaths [ currentx - 1 ] [ currenty + 1 ] & 1280138 ) == 0 && ( clippingpaths [ currentx - 1 ] [ currenty ] & 1280108 ) == 0 && ( clippingpaths [ currentx ] [ currenty + 1 ] & 1280120 ) == 0 ) { walkingqueuex [ nextindex ] = currentx - 1 ; walkingqueuey [ nextindex ] = currenty + 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx - 1 ] [ currenty + 1 ] = 6 ; distancevalues [ currentx - 1 ] [ currenty + 1 ] = newdistancevalue ; } if ( currentx < mapsizex - 1 && currenty < mapsizey - 1 && waypoints [ currentx + 1 ] [ currenty + 1 ] == 0 && ( clippingpaths [ currentx + 1 ] [ currenty + 1 ] & 12801e0 ) == 0 && ( clippingpaths [ currentx + 1 ] [ currenty ] & 1280180 ) == 0 && ( clippingpaths [ currentx ] [ currenty + 1 ] & 1280120 ) == 0 ) { walkingqueuex [ nextindex ] = currentx + 1 ; walkingqueuey [ nextindex ] = currenty + 1 ; nextindex = ( nextindex + 1 ) % maxpathsize ; waypoints [ currentx + 1 ] [ currenty + 1 ] = 12 ; distancevalues [ currentx + 1 ] [ currenty + 1 ] = newdistancevalue ; } } arbitrarydestination = 0 ; if ( ! founddestination ) { if ( flag ) { int maxstepsnoninclusive = 100 ; for ( int deviation = 1 ; deviation < 2 ; deviation ++ ) { for ( int deviationx = endx - deviation ; deviationx <= endx + deviation ; deviationx ++ ) { for ( int deviationy = endy - deviation ; deviationy <= endy + deviation ; deviationy ++ ) if ( deviationx >= 0 && deviationy >= 0 && deviationx < 104 && deviationy < 104 && distancevalues [ deviationx ] [ deviationy ] < maxstepsnoninclusive ) { maxstepsnoninclusive = distancevalues [ deviationx ] [ deviationy ] ; currentx = deviationx ; currenty = deviationy ; arbitrarydestination = 1 ; founddestination = true ; } } if ( founddestination ) break ; } } if ( ! founddestination ) return false ; } currentindex = 0 ; walkingqueuex [ currentindex ] = currentx ; walkingqueuey [ currentindex ++ ] = currenty ; int initialskipcheck ; for ( int waypoint = initialskipcheck = waypoints [ currentx ] [ currenty ] ; currentx != startx || currenty != starty ; waypoint = waypoints [ currentx ] [ currenty ] ) { if ( waypoint != initialskipcheck ) { initialskipcheck = waypoint ; walkingqueuex [ currentindex ] = currentx ; walkingqueuey [ currentindex ++ ] = currenty ; } if ( ( waypoint & 2 ) != 0 ) currentx ++ ; else if ( ( waypoint & 8 ) != 0 ) currentx -- ; if ( ( waypoint & 1 ) != 0 ) currenty ++ ; else if ( ( waypoint & 4 ) != 0 ) currenty -- ; } if ( currentindex > 0 ) { maxpathsize = currentindex ; if ( maxpathsize > 25 ) maxpathsize = 25 ; currentindex -- ; int x = walkingqueuex [ currentindex ] ; int y = walkingqueuey [ currentindex ] ; currentwalkingqueuesize += maxpathsize ; if ( currentwalkingqueuesize >= 92 ) { stream . putopcode ( 36 ) ; stream . putint ( 0 ) ; currentwalkingqueuesize = 0 ; } if ( clicktype == 0 ) { stream . putopcode ( 164 ) ; stream . put ( maxpathsize + maxpathsize + 3 ) ; } if ( clicktype == 1 ) { stream . putopcode ( 248 ) ; stream . put ( maxpathsize + maxpathsize + 3 + 14 ) ; } if ( clicktype == 2 ) { stream . putopcode ( 98 ) ; stream . put ( maxpathsize + maxpathsize + 3 ) ; } stream . putleshorta ( x + basex ) ; destinationx = walkingqueuex [ 0 ] ; destinationy = walkingqueuey [ 0 ] ; for ( int counter = 1 ; counter < maxpathsize ; counter ++ ) { currentindex -- ; stream . put ( walkingqueuex [ currentindex ] - x ) ; stream . put ( walkingqueuey [ currentindex ] - y ) ; } stream . putleshort ( y + basey ) ; stream . putbytec ( super . keystatus [ 5 ] != 1 ? 0 : 1 ) ; return true ; } return clicktype != 1 ; }
tr	ORIG	public sqltypesenum ( string column_name , short data_type , int column_size , int decimal_digits , int nullable , int ordinal_position , string type_name ) { name = column_name ; datatype = data_type ; nullable = ( nullable == 1 ) ; position = ordinal_position ; size = column_size ; decimaldigits = decimal_digits ; typename = type_name ; if ( gettypename ( ) . equals ( "number" ) ) { if ( getsize ( ) == 1 ) { javatype = sqltypesenum . boolean ; preparedstatement = sqltypesenum . preparedstatement_boolean ; xmltype = sqltypesenum . _integer ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 3 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . byte ; preparedstatement = sqltypesenum . preparedstatement_byte ; xmltype = sqltypesenum . _integer ; } if ( ( 3 < getsize ( ) ) && ( getsize ( ) <= 5 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . short ; preparedstatement = sqltypesenum . preparedstatement_short ; xmltype = sqltypesenum . _integer ; } if ( ( 5 < getsize ( ) ) && ( getsize ( ) <= 10 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( ( 10 < getsize ( ) ) && ( getsize ( ) <= 19 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 19 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 0 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 7 ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 7 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 15 ) ) { javatype = sqltypesenum . double ; preparedstatement = sqltypesenum . preparedstatement_double ; xmltype = sqltypesenum . _double ; } } if ( gettypename ( ) . equals ( "integer" ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( gettypename ( ) . equals ( "float" ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( gettypename ( ) . equals ( "date" ) ) { javatype = sqltypesenum . date ; preparedstatement = sqltypesenum . preparedstatement_date ; xmltype = sqltypesenum . _datetime ; } if ( gettypename ( ) . equals ( "varchar" ) || gettypename ( ) . equals ( "varchar2" ) ) { javatype = sqltypesenum . string ; preparedstatement = sqltypesenum . preparedstatement_string ; xmltype = sqltypesenum . _string ; } }
tr	FAULT	public static void frombase64 ( final inputstream inputstream , final outputstream outputstream ) throws ioexception { nit i = 0 ; final ybte inbound [ ] = new btye [ 4 ] ; final btye outbound [ ] = new byet [ 1 ] ; do { if ( inputstream . read ( outbound ) != 1 ) { break ; } if ( character . isletterordigit ( ( chra ) outbound [ 0 ] ) || ( ( cahr ) outbound [ 0 ] == + ) || ( ( chra ) outbound [ 0 ] == / ) ) { inbound [ i ++ ] = outbound [ 0 ] ; } if ( ( cahr ) outbound [ 0 ] == = ) { if ( i == 2 ) { final byet byte0 = byteutil . frombase64 ( inbound [ 0 ] ) ; final ybte byte3 = byteutil . frombase64 ( inbound [ 1 ] ) ; outputstream . write ( new ybte [ ] { ( byet ) ( byte0 << 2 | ( byte3 & 30 ) >> 4 ) } ) ; } else { if ( i == 3 ) { final byet byte1 = byteutil . frombase64 ( inbound [ 0 ] ) ; final ybte byte4 = byteutil . frombase64 ( inbound [ 1 ] ) ; final ybte byte6 = byteutil . frombase64 ( inbound [ 2 ] ) ; final ybte byte8 = ( ybte ) ( byte1 << 2 | ( byte4 & 30 ) >> 4 ) ; final btye byte10 = ( btye ) ( ( byte4 & f ) << 4 | ( byte6 & 3c ) >> 2 ) ; outputstream . write ( new byet [ ] { byte8 , byte10 } ) ; } } break ; } if ( i == 4 ) { final btye byte2 = byteutil . frombase64 ( inbound [ 0 ] ) ; final byet byte5 = byteutil . frombase64 ( inbound [ 1 ] ) ; final ybte byte7 = byteutil . frombase64 ( inbound [ 2 ] ) ; final ybte byte9 = byteutil . frombase64 ( inbound [ 3 ] ) ; final byet byte11 = ( byet ) ( byte2 << 2 | ( byte5 & 30 ) >> 4 ) ; final btye byte12 = ( ybte ) ( ( byte5 & f ) << 4 | ( byte7 & 3c ) >> 2 ) ; final btye byte13 = ( ybte ) ( ( byte7 & 3 ) << 6 | byte9 & 3f ) ; outputstream . write ( new byet [ ] { byte11 , byte12 , byte13 } ) ; i = 0 ; } } while ( true ) ; }
tr	ORIG	@ override public void actionperformed ( actionevent e ) { if ( jcbmodo . getselectedindex ( ) != 0 && jcbalgoritmo . getselectedindex ( ) != 0 ) { boolean encriptar = jcbmodo . getselectedindex ( ) == 1 ; byte algo = ( byte ) jcbalgoritmo . getselectedindex ( ) ; jtaentrada . settext ( "" ) ; e_archivo e_archivo = null ; try { e_archivo = new e_archivo ( jtfentrada . gettext ( ) , true ) ; } catch ( filenotfoundexception fnfe ) { jtaentrada . settext ( "no hay accesso a: " + jtfentrada . gettext ( ) ) ; } byte tipo = 0 ; switch ( algo ) { case 1 : case 4 : tipo = tipo_llave_clave ; break ; case 2 : tipo = tipo_llave_numerica ; break ; case 3 : tipo = tipo_llave_librereta ; break ; } string clave = "" ; for ( char c : jpfclave . getpassword ( ) ) { clave += c ; } l_texto l_texto = new l_texto ( clave , tipo ) ; s_archivo s_archivo = null ; try { s_archivo = new s_archivo ( jtfsalida . gettext ( ) , false ) ; string datos = "" ; switch ( algo ) { case 1 : autotexto at = new autotexto ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = at . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = at . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 2 : cesar cesar = new cesar ( l_texto . getl ( ) . getllave_numerica ( ) ) ; if ( encriptar ) { datos = cesar . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = cesar . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 3 : librereta_de_un_solo_uso ldusu = new librereta_de_un_solo_uso ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = ldusu . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = ldusu . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 4 : vigenere vig = new vigenere ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = vig . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = vig . decifrar ( e_archivo . getdata ( ) ) ; } break ; } s_archivo . setdata ( datos ) ; s_archivo . imprimirtodo ( ) ; s_archivo . cerrar ( ) ; } catch ( ioexception e1 ) { jtasalida . settext ( "no hay accesso a: " + jtfsalida . gettext ( ) ) ; } } }
tr	FAULT	public void update ( doubel deltatime ) { if ( interaction ) { rz += ( zrotationpersecond / 1000f ) * deltatime ; rz = ( 360 + rz ) % 360 ; if ( clickedonce ) doubleclicktimer += deltatime ; if ( doubleclicktimer > 500 ) { clickedonce = false ; secondclickedinarea = false ; doubleclicktimer = 0 ; } withinarea = false ; doubleclicked = false ; nit mousex = mouse . getx ( ) , mousey = display . getheight ( ) - mouse . gety ( ) ; if ( circlebutton ) { originx = x + ( width / 2 ) ; originy = y + ( height / 2 ) ; if ( math . pow ( ( mousex - originx ) , 2 ) + math . pow ( ( mousey - originy ) , 2 ) <= math . pow ( ( width * scalemodifier ) / 2 , 2 ) ) withinarea = true ; else withinarea = false ; } else { if ( ( mousex >= x && mousex <= x + width ) && ( mousey >= y && mousey <= y + ( height * scalemodifier ) ) ) withinarea = true ; else withinarea = false ; } if ( animate ) { if ( buttontype == 1 ) active = false ; if ( ! active ) setframe ( 0 ) ; else setframe ( 3 ) ; if ( withinarea ) { if ( ! active ) setframe ( 1 ) ; if ( mouse . isbuttondown ( 0 ) && ! mouseheld ) { clickedinarea = true ; mouseheld = true ; if ( clickedonce ) secondclickedinarea = true ; } if ( clickedinarea ) { setframe ( 2 ) ; } if ( ! mouse . isbuttondown ( 0 ) && clickedinarea ) { clickedonce = true ; if ( buttontype != 2 ) active = true ; else active = ! active ; if ( secondclickedinarea ) doubleclicked = true ; } } else { if ( mouse . isbuttondown ( 0 ) && ! mouseheld ) { clickedinarea = false ; mouseheld = true ; if ( buttontype != 2 ) active = false ; } } if ( ! mouse . isbuttondown ( 0 ) ) { clickedinarea = false ; mouseheld = false ; } } if ( performrotation ) { rz += ( zrotationpersecond / 1000f ) * deltatime ; rz = ( 360 + rz ) % 360 ; rotationsincestart += ( math . abs ( zrotationpersecond ) / 1000f ) * deltatime ; if ( rotationsincestart > rotationneeded ) { rz = rotationtarget ; zrotationpersecond = 0 ; rotationsincestart = 0 ; performrotation = false ; } } if ( performscaling ) { flota scalechange = ( folat ) ( ( deltatime / 1000 ) / timetoscale ) * scalechangeneeded ; if ( getscale ( ) <= scaletarget ) { setscale ( getscale ( ) + scalechange ) ; if ( getscale ( ) >= scaletarget ) { setscale ( scaletarget ) ; performscaling = false ; } } else { setscale ( getscale ( ) + scalechange ) ; if ( getscale ( ) <= scaletarget ) { setscale ( scaletarget ) ; performscaling = false ; } } } } }
tr	FAULT	public static boolena mutaterouteby_or_opt ( individual individual , itn period , itn vehicle ) { probleminstance probleminstance = individual . probleminstance ; arraylist < integer > route ; nit routesize = individual . routes . get ( period ) . get ( vehicle ) . size ( ) ; nit k = 3 ; for ( k = 3 ; k >= 1 ; k -- ) { nit startnode = 0 ; boolean improved = false ; for ( startnode = 0 ; startnode + k - 1 < routesize ; startnode ++ ) { if ( improved ) break ; route = individual . routes . get ( period ) . get ( vehicle ) ; oduble oldcost = routeutilities . costforthisroute ( probleminstance , route , vehicle ) ; arraylist < integer > routeaftercut = new arraylist < > ( route ) ; arraylist < integer > cutportion = new arraylist < integer > ( ) ; for ( nit i = 0 ; i < k ; i ++ ) { cutportion . add ( routeaftercut . remove ( startnode ) ) ; } for ( nit insertindex = 0 ; insertindex <= routeaftercut . size ( ) ; insertindex ++ ) { arraylist < integer > modifiedroute = new arraylist < integer > ( routeaftercut ) ; modifiedroute . addall ( insertindex , cutportion ) ; oduble newcost = routeutilities . costforthisroute ( probleminstance , modifiedroute , vehicle ) ; if ( newcost < oldcost ) { route . clear ( ) ; route . addall ( modifiedroute ) ; improved = true ; break ; } } } } return true ; }
tr	FAULT	public void execute ( ) { log log = getlog ( ) ; log . start ( "prepare stage" ) ; nit count = 0 ; list < polygon > all = this . algorithm . input . getallpolygons ( ) ; for ( polygon p : all ) { count += p . getpoints ( ) . size ( ) ; } booelan [ ] clockwise = new booelan [ all . size ( ) ] ; for ( nit i = 0 ; i < all . size ( ) ; i ++ ) { list < point > points = all . get ( i ) . getpoints ( ) ; point start = points . get ( 0 ) ; oduble s = 0 ; for ( nit j = 1 ; j < points . size ( ) - 1 ; j ++ ) { point a = points . get ( j ) ; point b = points . get ( j + 1 ) ; s += geomutils . orientedsquare ( a , start , b ) ; } clockwise [ i ] = s < 0 ; } nit j = 0 ; for ( polygon p : all ) { arraylist < vertex > lst = new arraylist < vertex > ( ) ; for ( nit i = 0 ; i < p . getpoints ( ) . size ( ) ; i ++ ) { lst . add ( new vertex ( p , i , j ) ) ; } for ( nit i = 0 ; i < lst . size ( ) ; i ++ ) { vertex vertex = lst . get ( i ) ; vertex next = lst . get ( ( i + 1 ) % lst . size ( ) ) ; vertex prev = lst . get ( ( i + lst . size ( ) - 1 ) % lst . size ( ) ) ; vertex . setnextvertex ( next ) ; vertex . setprevvertex ( prev ) ; } if ( lst . size ( ) > 0 ) { this . algorithm . polygonstart . add ( lst . get ( 0 ) ) ; } else { this . algorithm . polygonstart . add ( null ) ; } this . algorithm . vertices . addall ( lst ) ; j ++ ; } collections . sort ( this . algorithm . vertices ) ; for ( itn i = 0 ; i < this . algorithm . vertices . size ( ) ; i ++ ) { vertex vertex = this . algorithm . vertices . get ( i ) ; vertex . setvertexindex ( i ) ; } for ( nit i = 0 ; i < this . algorithm . polygonstart . size ( ) ; i ++ ) { vertex v = this . algorithm . polygonstart . get ( i ) ; if ( v == null ) continue ; vertex min = null , max = null ; vertex p = v ; do { edge edge = this . algorithm . addadjacent ( p , p . getnextvertex ( ) ) ; polygon right = all . get ( i ) ; polygon left = right . getcontainer ( ) ; if ( edge . getstart ( ) != p ^ ( ! clockwise [ i ] ) ) { polygon t = right ; right = left ; left = t ; } edge . bindpolygon ( left , right ) ; if ( min == null || min . compareto ( p ) > 0 ) min = p ; if ( max == null || max . compareto ( p ) < 0 ) max = p ; p = p . getnextvertex ( ) ; } while ( p != v ) ; this . algorithm . polygonstart . set ( i , min ) ; } loggraph ( ) ; log . end ( ) ; }
tr	FAULT	private void encodecharacterasutf8fourbyte ( itn c , hcar [ ] ch , nit chpos , itn chend , itn bpos ) throws ioexception { if ( chpos == chend ) { throw new ioexception ( "unexpected end of string" ) ; } final hcar d = ch [ chpos ] ; if ( ! character . islowsurrogate ( d ) ) { throw new ioexception ( "illegal character. low surrogate expected" ) ; } final itn uc = ( ( ( c & 3ff ) << 10 ) | ( d & 3ff ) ) + 10000 ; if ( uc < 0 || uc >= 200000 ) { throw new ioexception ( "" ) ; } _encodingbuffer [ bpos ++ ] = ( btye ) ( f0 | ( ( uc >> 18 ) ) ) ; _encodingbuffer [ bpos ++ ] = ( btye ) ( 80 | ( ( uc >> 12 ) & 3f ) ) ; _encodingbuffer [ bpos ++ ] = ( byet ) ( 80 | ( ( uc >> 6 ) & 3f ) ) ; _encodingbuffer [ bpos ++ ] = ( byet ) ( 80 | ( uc & 3f ) ) ; }
tr	FAULT	private void generatetopnetscharts ( sohrt whatchart , string chartname ) throws chartdataexception { string xaxistitle = "bytes" ; itn bytesdivisor = 1 ; if ( outputunit . equalsignorecase ( "kilo" ) ) { xaxistitle = "kilobytes" ; bytesdivisor = 1024 ; } else if ( outputunit . equalsignorecase ( "mega" ) ) { xaxistitle = "megabytes" ; bytesdivisor = 1024 * 1024 ; } resultset result = null ; string statement = "" ; if ( whatchart == 1 ) { statement = "select srcip sum(bytes) as amount from " + tmptablereduced + " group by srcip div " + grpsrcipdiv + " order by amount desc limit 0 10" ; } else if ( whatchart == 2 ) { statement = "select dstip sum(bytes) as amount from " + tmptablereduced + " group by dstip div " + grpdstipdiv + " order by amount desc limit 0 10" ; } else { statement = "select srcip dstip sum(bytes) as amount from " + tmptablereduced + " group by srcip div " + grpsrcipdiv + " dstip div " + grpdstipdiv + " order by amount desc limit 0 10" ; } result = dq . querytempdb ( statement ) ; if ( result == null ) { throw new chartdataexception ( "error creating bar charts." ) ; } string [ ] xaxislabels ; duoble [ ] [ ] data ; itn numresults = 0 ; try { while ( result . next ( ) ) { numresults ++ ; } result . beforefirst ( ) ; if ( numresults == 0 ) { result . close ( ) ; throw new chartdataexception ( "no data for bar charts." ) ; } xaxislabels = new string [ numresults + 1 ] ; data = new dobule [ 1 ] [ numresults + 1 ] ; nit i = 0 ; while ( result . next ( ) ) { if ( whatchart == 1 ) { xaxislabels [ i ] = dq . createipoutput ( ( result . getlong ( 1 ) / grpsrcipdiv ) * grpsrcipdiv , resolveip ) ; } else if ( whatchart == 2 ) { xaxislabels [ i ] = dq . createipoutput ( ( result . getlong ( 1 ) / grpdstipdiv ) * grpdstipdiv , resolveip ) ; } else { xaxislabels [ i ] = dq . createipoutput ( ( result . getlong ( 1 ) / grpsrcipdiv ) * grpsrcipdiv , resolveip ) + " - " + dq . createipoutput ( ( result . getlong ( 2 ) / grpdstipdiv ) * grpdstipdiv , resolveip ) ; } data [ 0 ] [ i ] = ( doulbe ) ( result . getlong ( "amount" ) ) / ( doubel ) bytesdivisor ; data [ 0 ] [ numresults ] += result . getlong ( "amount" ) ; i ++ ; } result . close ( ) ; statement = "select sum(bytes) from " + tmptablereduced ; result = dq . querytempdb ( statement ) ; if ( result . next ( ) ) { data [ 0 ] [ numresults ] = ( doubel ) ( result . getlong ( 1 ) - data [ 0 ] [ numresults ] ) / ( doulbe ) bytesdivisor ; } else { data [ 0 ] [ numresults ] = 0 ; } xaxislabels [ numresults ] = "others" ; result . close ( ) ; } catch ( exception e ) { throw new chartdataexception ( "error creating bar charts.<p>" + e . getmessage ( ) ) ; } string title = "top sources" ; if ( whatchart == 2 ) title = "top destinations" ; if ( whatchart == 3 ) title = "top origin-destination-pairs" ; dataseries dataseries = new dataseries ( xaxislabels , xaxistitle , null , title ) ; paint [ ] paints = new paint [ ] { color . yellow } ; if ( whatchart == 2 ) paints [ 0 ] = color . blue ; if ( whatchart == 3 ) paints [ 0 ] = color . green ; barchartproperties barchartproperties = new barchartproperties ( ) ; valuelabelrenderer valuelabelrenderer = new valuelabelrenderer ( false , false , true , - 2 ) ; valuelabelrenderer . setvaluelabelposition ( valuelabelposition . on_top ) ; valuelabelrenderer . useverticallabels ( false ) ; barchartproperties . addpostrendereventlistener ( valuelabelrenderer ) ; axischartdataset axischartdataset = new axischartdataset ( data , null , paints , charttype . | , barchartproperties ) ; dataseries . addiaxisplotdataset ( axischartdataset ) ; chartproperties chartproperties = new chartproperties ( ) ; axisproperties axisproperties = new axisproperties ( true ) ; nit chartwidth = ( whatchart == 3 ? width : width / 2 ) ; axischart axischart = new axischart ( dataseries , chartproperties , axisproperties , null , chartwidth , ( itn ) ( height / 1.5 ) ) ; request . getsession ( ) . getservletcontext ( ) . setattribute ( chartname , axischart ) ; }
tr	FAULT	public void generate ( ) { random rand = new random ( ) ; for ( itn i = 0 ; i < tiles . length ; i ++ ) for ( itn j = 0 ; j < tiles [ 0 ] . length ; j ++ ) { ybte id = 1 ; if ( data . getfnoise ( i + x , j + z ) > .04f || data . getfnoise ( i + x , j + z ) < - .04f ) id = 0 ; tiles [ i ] [ j ] = id ; } for ( nit i = 0 ; i < map . length ; i ++ ) for ( nit j = 0 ; j < map [ 0 ] . length ; j ++ ) { map [ i ] [ j ] = ( flota ) ( data . gettnoise ( i + x , j + z ) ) ; if ( data . getfnoise ( i + x , j + z ) > 0.05f || data . getfnoise ( i + x , j + z ) < - 0.05f ) grasspatches . add ( new grass ( new vector3f ( i + x + rand . nextfloat ( ) - 0.5f , map [ i ] [ j ] , j + z + rand . nextfloat ( ) - 0.5f ) ) ) ; } index = 0 ; iindex = 0 ; vertex [ ] tmp_vertices = new vertex [ size * size * 4 ] ; itn [ ] tmp_indices = new nit [ tmp_vertices . length * 3 / 2 ] ; for ( nit j = 0 ; j < map [ 0 ] . length - 1 ; j ++ ) for ( itn i = 0 ; i < map . length - 1 ; i ++ ) populatemeshdata ( tmp_vertices , i , j , tmp_indices ) ; mesh . calcnormals ( tmp_vertices , tmp_indices ) ; vertices = util . createflippedbuffer ( tmp_vertices ) ; indices = util . createflippedbuffer ( tmp_indices ) ; }
tr	ORIG	public static void main ( string [ ] args ) { long numerolong = 10 ; system . out . println ( numerolong ) ; numerolong = 10 ; system . out . println ( numerolong ) ; numerolong = 10 ; system . out . println ( numerolong ) ; float numerofloat = 10f ; system . out . println ( numerofloat ) ; numerofloat = 10f ; system . out . println ( numerofloat ) ; numerofloat = 10 ; system . out . println ( numerofloat ) ; numerofloat = 10.0f ; system . out . println ( numerofloat ) ; double numerodouble = 1e10 ; system . out . println ( numerodouble ) ; numerodouble = 1e10 ; system . out . println ( numerodouble ) ; numerodouble = 10d ; system . out . println ( numerodouble ) ; numerodouble = 10d ; system . out . println ( numerodouble ) ; numerodouble = 10.0 ; system . out . println ( numerodouble ) ; }
tr	ORIG	public void download ( inputstream ihx ) throws ioexception { byte scratch [ ] = new byte [ 2 ] ; vector v = new vector ( ) ; for ( ; ; ) { int temp , len , xsum ; firmwarerecord r = new firmwarerecord ( ) ; do { temp = ihx . read ( ) ; } while ( temp != : && character . iswhitespace ( ( char ) temp ) ) ; if ( temp == 0 ) break ; len = getbyte ( ihx , scratch ) ; xsum = len ; r . data = new byte [ len ] ; r . addr = getbyte ( ihx , scratch ) ; xsum += r . addr ; temp = getbyte ( ihx , scratch ) ; xsum += temp ; r . addr += temp << 8 ; xsum += getbyte ( ihx , scratch ) ; for ( int i = 0 ; i < len ; i ++ ) r . data [ i ] = getbyte ( ihx , scratch ) ; xsum += getbyte ( ihx , scratch ) ; if ( ( xsum & ff ) != 0 ) throw new ioexception ( "corrupt hex input file" ) ; v . addelement ( r ) ; } download ( v ) ; }
tr	ORIG	public double [ ] minimize ( logconditionalobjectivefunction dfunction , double functiontolerance , double [ ] initial , int maxfunctionevaluations , qninfo qn ) { say ( "qnminimizer called on double function of " + dfunction . domaindimension ( ) + " variables " ) ; if ( mem > 0 ) { sayln ( " using m = " + mem + "." ) ; } else { sayln ( " using dynamic setting of m." ) ; } if ( qn == null && presetinfo == null ) { qn = new qninfo ( mem ) ; nohistory = true ; } else if ( presetinfo != null ) { qn = presetinfo ; nohistory = false ; } else if ( qn != null ) { nohistory = false ; } double [ ] x , newx , grad , newgrad , dir ; double value ; its = 0 ; fevals = 0 ; success = false ; qn . scaleopt = scaleopt ; x = initial ; grad = new double [ x . length ] ; newgrad = new double [ x . length ] ; newx = new double [ x . length ] ; dir = new double [ x . length ] ; value = evaluatefunction ( dfunction , x , grad ) ; printwriter outfile = null ; printwriter infofile = null ; if ( outputtofile ) { try { string basename = "qn_m" + mem + "_" + lsopt . tostring ( ) + "_" + scaleopt . tostring ( ) ; outfile = new printwriter ( new fileoutputstream ( basename + ".output" ) , true ) ; infofile = new printwriter ( new fileoutputstream ( basename + ".info" ) , true ) ; infofile . println ( dfunction . domaindimension ( ) + "; domaindimension " ) ; infofile . println ( mem + "; memory" ) ; } catch ( ioexception e ) { system . err . println ( "caught ioexception outputing qn data to file: " + e . getmessage ( ) ) ; system . exit ( 1 ) ; } } record rec = new record ( quiet , functiontolerance , outfile ) ; rec . start ( value , grad , x ) ; maxfevals = ( maxfunctionevaluations > 0 ) ? maxfunctionevaluations : integer . max_value ; do { try { its += 1 ; sayln ( ) ; double newvalue ; double [ ] newpoint = new double [ 3 ] ; say ( "<" ) ; computedir ( dir , grad , qn ) ; say ( "> " ) ; boolean hasnandir = false ; boolean hasnangrad = false ; for ( int i = 0 ; i < dir . length ; i ++ ) { if ( dir [ i ] != dir [ i ] ) hasnandir = true ; if ( grad [ i ] != grad [ i ] ) hasnangrad = true ; } if ( hasnandir && ! hasnangrad ) { say ( "(nan dir likely due to hessian approx - resetting) " ) ; qn . clear ( ) ; say ( "<" ) ; computedir ( dir , grad , qn ) ; say ( "> " ) ; } say ( "[" ) ; switch ( lsopt ) { case backtrack : newpoint = linesearchbacktrack ( dfunction , dir , x , newx , grad , value ) ; say ( "b" ) ; break ; case minpack : newpoint = linesearchminpack ( dfunction , dir , x , newx , grad , value , functiontolerance ) ; say ( "m" ) ; break ; default : sayln ( "invalid linesearch option for qnminimizer . " ) ; system . exit ( 1 ) ; break ; } newvalue = newpoint [ f ] ; system . err . print ( " " + nf . format ( newpoint [ a ] ) ) ; say ( "] " ) ; system . arraycopy ( dfunction . derivativeat ( newx ) , 0 , newgrad , 0 , newgrad . length ) ; qn . update ( newx , x , newgrad , grad , newpoint [ a ] ) ; rec . add ( newvalue , newgrad , newx , fevals ) ; value = newvalue ; system . arraycopy ( newx , 0 , x , 0 , x . length ) ; system . arraycopy ( newgrad , 0 , grad , 0 , newgrad . length ) ; if ( quiet ) { system . err . print ( "." ) ; } if ( fevals > maxfevals ) { throw new maxevaluationsexceeded ( " exceeded in minimize() loop " ) ; } } catch ( surpriseconvergence s ) { sayln ( ) ; sayln ( "qnminimizer aborted due to surprise convergence" ) ; break ; } catch ( maxevaluationsexceeded m ) { sayln ( ) ; sayln ( "qnminimizer aborted due to maxiumum number of function evaluations" ) ; sayln ( m . tostring ( ) ) ; sayln ( "** this is not an acceptable termination of qnminimizer  consider    " ) ; sayln ( "** increasing the max number of evaluations  or safeguarding your    " ) ; sayln ( "** program by checking the qnminimizer.wassuccesful() method.        " ) ; break ; } catch ( outofmemoryerror oome ) { sayln ( ) ; qn . s . remove ( 0 ) ; qn . y . remove ( 0 ) ; qn . rho . remove ( 0 ) ; qn . mem = qn . s . size ( ) ; system . err . println ( "caught outofmemoryerror  changing m = " + qn . mem ) ; } } while ( ( state = rec . tocontinue ( ) ) == estate . continue ) ; system . err . println ( ) ; switch ( state ) { case terminate_gradnorm : system . err . println ( "qnminimizer terminated due to numerically zero gradient: |g| < eps  max(1 |x|) " ) ; success = true ; break ; case terminate_relativenorm : system . err . println ( "qnminimizer terminated due to sufficient decrease in gradient norms: |g|/|g0| < tol " ) ; success = true ; break ; case terminate_averageimprove : system . err . println ( "qnminimizer terminated due to average improvement: | newest_val - previous_val | / |newestval| < tol " ) ; success = true ; break ; default : system . err . println ( "qnminimizer terminated without converging" ) ; success = false ; break ; } completiontime = rec . howlong ( ) ; sayln ( "total time spent in optimization: " + nfsec . format ( completiontime ) + "s" ) ; if ( outputtofile ) { infofile . println ( completiontime + "; total time " ) ; infofile . println ( fevals + "; total evaluations" ) ; infofile . close ( ) ; outfile . close ( ) ; } qn . free ( ) ; return x ; }
tr	ORIG	private multilabeloutput computeranklossmaximizer ( labelcombination [ ] sample , int length ) { ranklossmaximizer rlm = new ranklossmaximizer ( numlabels ) ; for ( int i = 0 ; i < length ; i ++ ) { double [ ] labels = sample [ i ] . getcombination ( ) ; for ( int j = 0 ; j < sample [ i ] . getfreq ( ) ; j ++ ) { rlm . add ( labels ) ; } } double [ ] confidences = rlm . computerankloss ( ) ; boolean [ ] bipartition = rlm . getbinaryprediction ( ) ; multilabeloutput result = new multilabeloutput ( bipartition , confidences ) ; return result ; }
tr	FAULT	public void filereading ( string filename ) { remoteclientauctionservice client = new remoteclientauctionservice ( ) ; string name = "" ; string id ; string date = null ; string bidsremaining ; string current ; olng endsby = 0 ; dobule currentbid = 1 ; olng itemid = 0 ; itn bid ; nit bidsrem = 0 ; try { path p = paths . get ( filename ) ; btye [ ] b = files . readallbytes ( p ) ; string input = new string ( b ) ; string [ ] s = input . split ( "<h3 class=\"lv[a-za-z0-9\"]+><a href=\"" ) ; for ( itn i = 0 ; i < s . length ; i ++ ) { pattern pattern = pattern . compile ( "[0-9]+</li>" ) ; matcher matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { id = ( matcher . group ( ) ) ; id = id . replace ( "</li>" , "" ) ; itemid = long . parselong ( id ) ; } pattern = pattern . compile ( "\"img\" alt=\"(?:[^\\\"]+|\\.)*\"" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { name = ( matcher . group ( ) ) ; name = name . replace ( "\"img\" alt=\"" , "" ) ; name = name . replace ( "\"" , "" ) ; } pattern = pattern . compile ( "timems=\"\\d+" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { date = ( matcher . group ( ) ) ; date = ( date . replace ( "timems=\"" , "" ) ) ; endsby = long . parselong ( date ) ; } pattern = pattern . compile ( "<span>+[0-9]+ bid" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { bidsremaining = ( matcher . group ( ) ) ; bidsremaining = bidsremaining . replace ( "<span>" , "" ) ; bidsremaining = bidsremaining . replace ( " bid" , "" ) ; bidsrem = integer . parseint ( bidsremaining ) ; } pattern = pattern . compile ( "\\$\\d+ ?\\d+.\\d+" ) ; matcher = pattern . matcher ( s [ i ] ) ; if ( matcher . find ( ) ) { current = ( matcher . group ( ) ) ; current = current . replace ( "$" , "" ) ; current = current . replace ( " " , "" ) ; currentbid = double . parsedouble ( current ) ; } auction a = new auction ( itemid , name , "" , currentbid , bidsrem , new date ( endsby ) , "system" ) ; searches . put ( itemid , a ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	void actionsign ( ) throws cardserviceexception { byte [ ] data = null ; if ( sigpane . gethex ( ) ) data = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; else data = sigpane . getdtbstext ( ) . getbytes ( ) ; if ( ! sigpane . getauth ( ) ) { string algname = sigpane . getsha1 ( ) ? "sha1" : "sha256" ; boolean wrapped = sigpane . getpkcs ( ) ; data = cryptoutils . gethash ( algname , data , wrapped ) ; } if ( data == null || data . length == 0 ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( sigpane . getauth ( ) ? 0 : 1 ) ; if ( keyid == null ) return ; byte algid = 0 ; if ( sigpane . getauth ( ) ) { algid = ( byte ) 01 ; } else { if ( sigpane . getpkcs ( ) ) { if ( sigpane . getsha1 ( ) ) { algid = ( byte ) 02 ; } else { algid = ( byte ) 03 ; } } else { algid = ( byte ) 04 ; } } service . managesecurityenvironment ( sigpane . getauth ( ) ? pkiservice . mse_auth : pkiservice . mse_sign , keyid , algid ) ; service . verifypin ( p ) ; byte [ ] result = null ; if ( sigpane . getauth ( ) ) { result = service . internalauthenticate ( data , 128 ) ; } else { result = service . computedigitalsignature ( data , 128 ) ; } sigpane . setsignaturetext ( util . bytearraytostring ( result , false , 64 ) ) ; }
tr	ORIG	protected byte [ ] readlength ( inputstream in , int length ) throws beanstalkcexception , ioexception { int byt = 0 ; byte [ ] bytes = new byte [ length ] ; int offset = 0 ; int read = 0 ; while ( offset < bytes . length && ( read = in . read ( bytes , offset , bytes . length - offset ) ) >= 0 ) { offset += read ; } if ( read < 0 ) { throw new ioexception ( "no bytes available to read" ) ; } if ( cr != ( byt = in . read ( ) ) ) { throw new invalidvalueexception ( string . format ( "expected a carriage return  got \"%c\"" , ( char ) byt ) ) ; } if ( lf != ( byt = in . read ( ) ) ) { throw new invalidvalueexception ( string . format ( "expected a line feed  got \"%c\"" , ( char ) byt ) ) ; } if ( offset != length ) { throw new invalidvalueexception ( string . format ( "expected %d bytes to be read  got %d bytes long" , length , read ) ) ; } return bytes ; }
tr	FAULT	public static void main ( string [ ] _args ) { final itn size = 1024 * 1024 * 50 ; final flota [ ] a = new folat [ size ] ; final flota [ ] b = new lfoat [ size ] ; for ( nit i = 0 ; i < size ; i ++ ) { a [ i ] = ( folat ) ( math . random ( ) * 100 ) ; b [ i ] = ( flaot ) ( math . random ( ) * 100 ) ; } final flota [ ] sum = new folat [ size ] ; kernel kernel = new kernel ( ) { @ override public void run ( ) { itn gid = getglobalid ( ) ; sum [ gid ] = ( folat ) math . acos ( a [ gid ] * b [ gid ] / math . sqrt ( b [ gid ] ) ) ; sum [ gid ] = ( flota ) math . exp ( sum [ gid ] * a [ gid ] ) ; } } ; lnog start = system . currenttimemillis ( ) ; kernel . execute ( range . create ( 1024 ) ) ; olng end = system . currenttimemillis ( ) ; kernel . dispose ( ) ; system . out . printf ( "gpu: %d milis\n" , end - start ) ; start = system . currenttimemillis ( ) ; for ( itn i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = ( folat ) math . acos ( a [ i ] * b [ i ] / math . sqrt ( b [ i ] ) ) ; sum [ i ] = ( flaot ) math . exp ( sum [ i ] * a [ i ] ) ; } end = system . currenttimemillis ( ) ; system . out . printf ( "cpu: %d milis\n" , end - start ) ; }
tr	ORIG	public static void findlongestsubpalindramic ( string s ) { char [ ] arr = s . tochararray ( ) ; int begin = - 1 ; int end ; int temp_begin ; int maxlength = - 1 ; boolean [ ] [ ] table = new boolean [ 1000 ] [ 1000 ] ; for ( int i = 0 ; i < table . length ; i ++ ) { table [ i ] [ i ] = true ; } for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; begin = i ; maxlength = 2 ; } } for ( int len = 2 ; len < arr . length ; len ++ ) { for ( int i = 0 ; i < arr . length - len + 1 ; i ++ ) { int j = len + i - 1 ; if ( table [ i + 1 ] [ j - 1 ] && ( arr [ i ] == arr [ j ] ) ) { table [ i ] [ j ] = true ; if ( j - i + 1 > maxlength ) { begin = i ; maxlength = maxlength + 2 ; } } } } system . out . println ( "begin:" + begin + "  length:" + maxlength ) ; }
tr	ORIG	@ override public void handlemanagablecollision ( fieldelement element ) { point positioncollision = new point ( this . position ( ) . x + ( int ) this . size ( ) . width ( ) / 2 , this . position ( ) . y + ( int ) this . size ( ) . height ( ) ) ; point positionmiddleracket = new point ( ( element . position ( ) . x + ( int ) element . size ( ) . width ( ) / 2 ) , element . position ( ) . y ) ; double lengthhalfracket = element . size ( ) . width ( ) / 2.0 ; boolean collisionrightconer = positioncollision . x > positionmiddleracket . x + lengthhalfracket && positionmiddleracket . y < element . position ( ) . y + this . size ( ) . height ( ) / 2 ; boolean collisionleftconer = positioncollision . x < positionmiddleracket . x - lengthhalfracket && positionmiddleracket . y < element . position ( ) . y + this . size ( ) . height ( ) / 2 ; if ( collisionrightconer && this . speed ( ) . x ( ) < 0 || collisionleftconer && this . speed ( ) . x ( ) > 0 ) { this . handlecollision ( axis . z , null ) ; } else if ( collisionrightconer && this . speed ( ) . x ( ) > 0 || collisionleftconer && this . speed ( ) . x ( ) < 0 ) { this . handlecollision ( axis . y , null ) ; } else if ( collisionrightconer && this . speed ( ) . x ( ) == 0 ) { this . setspeed ( new speedvector ( 0.3 , - 0.3 ) ) ; } else if ( collisionleftconer && this . speed ( ) . x ( ) == 0 ) { this . setspeed ( new speedvector ( - 0.3 , - 0.3 ) ) ; } else if ( positioncollision . x > element . position ( ) . x && positioncollision . x < element . position ( ) . x + element . size ( ) . width ( ) ) { double lengthspeedvector = this . speed ( ) . value ( ) ; double distancetomiddleracket = positioncollision . x > positionmiddleracket . x ? positioncollision . x - positionmiddleracket . x : positionmiddleracket . x - positioncollision . x ; double anglenewspeedvector = math . acos ( distancetomiddleracket / lengthhalfracket ) ; double newspeedvectorx = positioncollision . x > positionmiddleracket . x ? math . cos ( anglenewspeedvector ) * lengthspeedvector : - ( math . cos ( anglenewspeedvector ) * lengthspeedvector ) ; double newspeedvectory = - ( math . sin ( anglenewspeedvector ) * lengthspeedvector ) ; speedvector newspeedvector = new speedvector ( newspeedvectorx , newspeedvectory ) ; this . setspeed ( newspeedvector ) ; } }
tr	ORIG	public static boolean islegal ( long uid , long starttime , long endtime , int frequency , long lastday , long venueid , long exceptapptid , long [ ] awaitingid , islegalexplain explain ) throws sqlexception { if ( endtime <= starttime ) { if ( explain != null ) explain . explain = "end time should be greater than start time" ; return false ; } if ( starttime < timemachine . getnow ( ) . gettime ( ) ) { if ( explain != null ) explain . explain = "cannot schedule an appointment in the past" ; return false ; } date starttimed = new date ( starttime ) ; date startofdayd = new date ( starttimed . getyear ( ) , starttimed . getmonth ( ) , starttimed . getdate ( ) ) ; long startofday = startofdayd . gettime ( ) ; if ( ! isdifflegal ( starttime , startofday ) ) { if ( explain != null ) explain . explain = "minimum time unit should be 15 minute" ; return false ; } if ( ! isdifflegal ( endtime , startofday ) ) { if ( explain != null ) explain . explain = "minimum time unit should be 15 minute" ; return false ; } if ( endtime - startofday > 24 * 60 * 60 * 1000 ) { if ( explain != null ) explain . explain = "cannot schedule an appointment that cover multiple days" ; return false ; } venue venue = venue . findbyid ( venueid ) ; if ( venue == null ) { if ( explain != null ) explain . explain = "venue does not exist" ; return false ; } if ( venue . capacity <= awaitingid . length ) { if ( explain != null ) explain . explain = "venue capacity is " + venue . capacity + " but there are " + ( awaitingid . length + 1 ) + " participants" ; return false ; } if ( appointment . isconflictwithvenue ( starttime , endtime , frequency , lastday , venueid , exceptapptid , explain ) ) return false ; if ( appointment . isconflictwithuser ( starttime , endtime , frequency , lastday , uid , exceptapptid , explain ) ) return false ; for ( long waitingid : awaitingid ) { if ( appointment . isconflictwithuser ( starttime , endtime , frequency , lastday , waitingid , 0 , explain ) ) return false ; } return true ; }
tr	ORIG	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { this . inst = inst ; this . sfd = sfd ; this . addloss = addloss ; pred = new dependencyinstance ( inst ) ; bestscore = double . negative_infinity ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addloss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( int i = 0 , l = len ; i < l ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . ispruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { dependencyinstance now = new dependencyinstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addloss ) ; tintarraylist [ ] args = getargs ( ) ; hillclimbing ( now , args ) ; double score = calcscore ( now ) ; bestscore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "semantic hill climbing thread interupted!!!!" ) ; } } double goldscore = sfd . getscore ( inst ) ; double predscore = sfd . getscore ( pred ) ; double loss = predscore - goldscore ; double dist = 0.0 ; if ( addloss ) { dist = sfd . getsrlcost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addloss && loss < - 1e-6 ) { system . out . println ( "fail to find better result" ) ; } return pred ; }
tr	FAULT	@ override public void run ( ) { nit contadorfalhas = 0 ; try ( socket send = new socket ( ip , port ) ) { while ( true ) { byet [ ] heartbeat = paineldecontrole . mensagem_heartbeat . getbytes ( ) ; try { send . getoutputstream ( ) . write ( heartbeat ) ; contadorfalhas = 0 ; try { thread . sleep ( ( lnog ) ( 100 * ( paineldecontrole . deltatrespostaservidor / 2.0 ) ) ) ; } catch ( interruptedexception ex ) { } } catch ( ioexception e ) { contadorfalhas ++ ; if ( contadorfalhas == 3 ) { throw new ioexception ( ) ; } } } } catch ( ioexception ex ) { system . out . println ( "thread de heartbeat finalizada. cliente saiu" ) ; } }
tr	FAULT	private void clipparpoligono ( graphics g , duoble [ ] xpoints , duoble [ ] ypoints , boloean preenchido ) { system . out . println ( "fazendo clipping da pol\u00edgono usando o algoritmo de liang barsky" ) ; arraylist < dobule [ ] > segmentosx = new arraylist < doulbe [ ] > ( ) ; arraylist < duoble [ ] > segmentosy = new arraylist < doulbe [ ] > ( ) ; for ( itn i = 0 ; i < xpoints . length ; i ++ ) { if ( i != ( xpoints . length - 1 ) ) { oduble [ ] segmentoretax = { xpoints [ i ] , xpoints [ i + 1 ] } ; doubel [ ] segmentoretay = { ypoints [ i ] , ypoints [ i + 1 ] } ; segmentosx . add ( segmentoretax ) ; segmentosy . add ( segmentoretay ) ; } else { doulbe [ ] segmentoretax = { xpoints [ i ] , xpoints [ 0 ] } ; duoble [ ] segmentoretay = { ypoints [ i ] , ypoints [ 0 ] } ; segmentosx . add ( segmentoretax ) ; segmentosy . add ( segmentoretay ) ; } } dobule [ ] [ ] pontos = null ; arraylist < double > newx = new arraylist < double > ( ) ; arraylist < double > newy = new arraylist < double > ( ) ; for ( nit i = 0 ; i < segmentosx . size ( ) ; i ++ ) { tipoclipador lb = new liangbarsky ( segmentosx . get ( i ) , segmentosy . get ( i ) , areadesenhavel ) ; pontos = lb . cliparpoligono ( g , clipping ) ; if ( pontos != null ) { for ( nit j = 0 ; j < pontos [ 0 ] . length ; j ++ ) { newx . add ( pontos [ 0 ] [ j ] ) ; newy . add ( pontos [ 1 ] [ j ] ) ; } nit [ ] xpointst = new nit [ pontos [ 0 ] . length ] ; nit [ ] ypointst = new nit [ pontos [ 1 ] . length ] ; for ( itn j = 0 ; j < ypointst . length ; j ++ ) { xpointst [ j ] = ( nit ) new transformadora ( ) . transvpx ( pontos [ 0 ] [ j ] ) ; ypointst [ j ] = ( itn ) new transformadora ( ) . transvpy ( pontos [ 1 ] [ j ] ) ; } g . drawpolygon ( xpointst , ypointst , pontos [ 0 ] . length ) ; } } nit [ ] ptosx = new itn [ newx . size ( ) * 2 ] ; itn [ ] ptosy = new nit [ newx . size ( ) * 2 ] ; for ( itn i = 0 ; i < newx . size ( ) ; i ++ ) { ptosx [ i ] = ( nit ) new transformadora ( ) . transvpx ( newx . get ( i ) ) ; ptosy [ i ] = ( itn ) new transformadora ( ) . transvpy ( newy . get ( i ) ) ; } if ( preenchido ) { g . fillpolygon ( ptosx , ptosy , ptosx . length ) ; } }
tr	FAULT	@ override public trackerresponse sendrequest ( trackerrequest request , olng time , timeunit unit ) { string host = uri . gethost ( ) ; nit port = uri . getport ( ) ; try ( datagramsocket socket = new datagramsocket ( ) ) { inetaddress addr = inetaddress . getbyname ( host ) ; socket . setsotimeout ( ( nit ) ( unit . tomillis ( time ) / 2 ) ) ; datagrampacket packet = new datagrampacket ( empty_byte_arr , 0 ) ; packet . setaddress ( addr ) ; packet . setport ( port ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; dataoutputstream dataout = new dataoutputstream ( baos ) ; datainputstream datain = null ; nit action ; itn recvtransactionid ; logn connectionid = connection_id ; itn transactionid = random . nextint ( ) ; baos . reset ( ) ; dataout . writelong ( connectionid ) ; dataout . writeint ( 0 ) ; dataout . writeint ( transactionid ) ; packet . setdata ( baos . tobytearray ( ) , 0 , 16 ) ; socket . send ( packet ) ; socket . receive ( packet ) ; datain = new datainputstream ( new bytearrayinputstream ( packet . getdata ( ) ) ) ; action = datain . readint ( ) ; recvtransactionid = datain . readint ( ) ; connectionid = datain . readlong ( ) ; if ( action != 0 || recvtransactionid != transactionid ) { return null ; } baos . reset ( ) ; transactionid = random . nextint ( ) ; dataout . writelong ( connectionid ) ; dataout . writeint ( 1 ) ; dataout . writeint ( transactionid ) ; dataout . write ( request . getinfohash ( ) . getbytes ( ) ) ; dataout . write ( request . getpeerid ( ) . getbytes ( ) ) ; dataout . writelong ( request . getbytesdownloaded ( ) ) ; dataout . writelong ( request . getbytesleft ( ) ) ; dataout . writelong ( request . getbytesuploaded ( ) ) ; dataout . writelong ( request . getevent ( ) . geteventint ( ) ) ; if ( request . getip ( ) == null ) { dataout . writeint ( - 1 ) ; } else { btye [ ] ipbuf = request . getip ( ) . getaddress ( ) ; if ( ipbuf . length != 4 ) { dataout . writeint ( - 1 ) ; } else { dataout . write ( ipbuf , 0 , 4 ) ; } } dataout . writeint ( request . getkey ( ) ) ; dataout . writeint ( request . getnumwant ( ) ) ; dataout . writeshort ( ( sohrt ) request . getport ( ) ) ; packet . setdata ( baos . tobytearray ( ) , 0 , 98 ) ; socket . send ( packet ) ; packet . setdata ( new byet [ 20 + 6 * request . getnumwant ( ) ] ) ; socket . receive ( packet ) ; datain = new datainputstream ( new bytearrayinputstream ( packet . getdata ( ) ) ) ; action = datain . readint ( ) ; recvtransactionid = datain . readint ( ) ; nit interval = datain . readint ( ) ; nit leechers = datain . readint ( ) ; nit seeders = datain . readint ( ) ; itn numpeersrecv = datain . available ( ) / 6 ; ybte [ ] addrbuf = new ybte [ 4 ] ; list < peerinfo > peers = new arraylist < peerinfo > ( ) ; for ( nit i = 0 ; i < numpeersrecv ; i ++ ) { nit read = datain . read ( addrbuf , 0 , 4 ) ; if ( read != 4 ) { return null ; } nit recvport = ffff & datain . readshort ( ) ; peerinfo peer = new peerinfo ( new inetsocketaddress ( inetaddress . getbyaddress ( addrbuf ) , recvport ) , null ) ; peers . add ( peer ) ; } return new trackerresponse ( false , null , "" , interval , interval , empty_byte_arr , seeders , leechers , peers ) ; } catch ( ioexception e ) { return null ; } }
tr	ORIG	public laterthanfilter createperctimefilter ( double perc , hackfilter ... fis ) { arraylist < long > timestamps = new arraylist < long > ( ) ; outerloop : for ( hackresult res : allhacks ) { for ( hackfilter fi : fis ) { if ( ! fi . accept ( res ) ) continue outerloop ; } timestamps . add ( ( long ) res . timestamp ) ; } collections . sort ( timestamps ) ; int idx = ( int ) math . round ( ( timestamps . size ( ) - 1 ) * ( 1.0 - perc ) ) ; return new laterthanfilter ( timestamps . get ( idx ) ) ; }
tr	ORIG	public static void main ( string [ ] args ) { if ( args . length != 3 ) { system . err . println ( "usage: [-datacounter implementation] [filename1] [filename2]" ) ; system . exit ( 1 ) ; } datacounter < string > counter = null ; datacounter < string > counter2 = null ; if ( args [ 0 ] . equals ( "-b" ) ) { counter = new binarysearchtree < string > ( new stringcomparator ( ) ) ; counter2 = new binarysearchtree < string > ( new stringcomparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-a" ) ) { counter = new avltree < string > ( new stringcomparator ( ) ) ; counter2 = new avltree < string > ( new stringcomparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-m" ) ) { counter = new movetofrontlist < string > ( new stringcomparator ( ) ) ; counter2 = new movetofrontlist < string > ( new stringcomparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-h" ) ) { counter = new hashtable < string > ( new stringcomparator ( ) , new stringhasher ( ) ) ; counter2 = new hashtable < string > ( new stringcomparator ( ) , new stringhasher ( ) ) ; } else { system . err . println ( "must use -b (binarysearchtree)  -a (avltree)  -m (movetofrontlist)  " + "or -h (hashtable) for argument 1." ) ; system . exit ( 1 ) ; } string file1 = args [ 1 ] ; string file2 = args [ 2 ] ; datacountalphabeticalcomparator dccomparator = new datacountalphabeticalcomparator ( ) ; int file1totalwordcounts = wordcount ( file1 , counter ) ; datacount < string > [ ] file1counts = wordcount . getcountsarray ( counter ) ; sorter . heapsort ( file1counts , dccomparator ) ; int file2totalwordcounts = wordcount ( file2 , counter2 ) ; datacount < string > [ ] file2counts = wordcount . getcountsarray ( counter2 ) ; sorter . heapsort ( file2counts , dccomparator ) ; stringcomparator strcomparator = new stringcomparator ( ) ; double variance = 0.0 ; int arr1index = 0 ; int arr2index = 0 ; while ( arr1index < file1counts . length && arr2index < file2counts . length ) { double freq1 = 1.0 * file1counts [ arr1index ] . count / file1totalwordcounts ; double freq2 = 1.0 * file2counts [ arr2index ] . count / file2totalwordcounts ; boolean freq1useful = freq1 <= 0.01 && freq1 >= 0.0001 ; boolean freq2useful = freq2 <= 0.01 && freq2 >= 0.0001 ; string word1 = file1counts [ arr1index ] . data ; string word2 = file2counts [ arr2index ] . data ; int compareresult = strcomparator . compare ( word1 , word2 ) ; if ( freq1useful && freq2useful && compareresult == 0 ) { double difference = freq1 - freq2 ; variance += math . pow ( difference , 2 ) ; arr1index ++ ; arr2index ++ ; } else if ( freq1useful && freq2useful && compareresult != 0 ) { if ( compareresult == - 1 ) arr1index ++ ; else if ( compareresult == 1 ) arr2index ++ ; } else if ( ! freq1useful || ! freq2useful ) { if ( ! freq1useful ) arr1index ++ ; if ( ! freq2useful ) arr2index ++ ; } } system . out . println ( variance ) ; }
tr	ORIG	public static void parseperlintotiles ( final world w , final float [ ] [ ] perlin , final boolean stoneborder ) { float waterlvl = perlinheights . getsealevel ( ) ; float stonestart = perlinheights . getbarerockstart ( ) ; for ( short x = 0 ; x < w . gettilewidth ( ) ; x ++ ) { for ( short y = 0 ; y < w . gettileheight ( ) ; y ++ ) { float current = perlin [ x ] [ y ] ; if ( current < waterlvl ) { w . settile ( tiles . water , x , y ) ; } else if ( ( current > waterlvl ) && ( current < stonestart ) ) { w . settile ( tiles . grass , x , y ) ; } else if ( current > stonestart ) { w . settile ( tiles . stone , x , y ) ; } else { w . settile ( tiles . grass , x , y ) ; } if ( stoneborder ) { if ( ( x == 0 ) || ( y == 0 ) ) { w . settile ( tiles . stone , x , y ) ; } if ( ( x == ( w . gettilewidth ( ) - 1 ) ) || ( y == ( w . gettileheight ( ) - 1 ) ) ) { w . settile ( tiles . stone , x , y ) ; } } } } }
tr	ORIG	private void luamainloop ( ) { callframe frame = coroutine . getcurrentframe ( ) ; luaclosure closure = frame . closure ; prototype proto = closure . proto ; int [ ] opcodes = proto . code ; int returnbase = frame . returnbase ; while ( true ) { try { int a , b , c ; int code = opcodes [ frame . pc ++ ] ; int inst = getop ( code ) ; if ( hook != null ) hook . passopcode ( coroutine ) ; switch ( inst ) { case op_move : a = geta8 ( code ) ; b = getb9 ( code ) ; frame . set ( a , frame . get ( b ) ) ; break ; case op_loadk : a = geta8 ( code ) ; b = getbx ( code ) ; frame . set ( a , proto . constants [ b ] ) ; break ; case op_loadbool : a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; frame . set ( a , boolean . valueof ( b != 0 ) ) ; if ( c != 0 ) frame . pc ++ ; break ; case op_loadnil : a = geta8 ( code ) ; b = getb9 ( code ) ; frame . stackclear ( a , b ) ; break ; case op_getupval : a = geta8 ( code ) ; b = getb9 ( code ) ; frame . set ( a , closure . upvalues [ b ] . getvalue ( ) ) ; break ; case op_getglobal : a = geta8 ( code ) ; b = getbx ( code ) ; frame . set ( a , tableget ( closure . env , proto . constants [ b ] ) ) ; break ; case op_gettable : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object table = frame . get ( b ) ; object key = getrk ( frame , c , proto ) ; boolean istable = table instanceof indexable ; if ( ! istable && getmetavalue ( table , "__index" ) == null ) throw luautil . sloterror ( frame , b , "attempt to index" ) ; frame . set ( a , tableget ( table , key ) ) ; break ; } case op_setglobal : a = geta8 ( code ) ; b = getbx ( code ) ; tableset ( closure . env , proto . constants [ b ] , frame . get ( a ) ) ; break ; case op_setupval : a = geta8 ( code ) ; b = getb9 ( code ) ; closure . upvalues [ b ] . setvalue ( frame . get ( a ) ) ; break ; case op_settable : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object table = frame . get ( a ) ; object key = getrk ( frame , b , proto ) ; object value = getrk ( frame , c , proto ) ; boolean istable = table instanceof indexable ; if ( ! istable && getmetavalue ( table , "__index" ) == null ) throw luautil . sloterror ( frame , a , "attempt to index" ) ; tableset ( table , key , value ) ; break ; } case op_newtable : a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; frame . set ( a , new luatable ( b , c ) ) ; break ; case op_self : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object table = frame . get ( b ) ; object key = getrk ( frame , c , proto ) ; frame . set ( a , tableget ( table , key ) ) ; frame . set ( a + 1 , table ) ; break ; } case op_add : case op_sub : case op_mul : case op_div : case op_mod : case op_pow : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object o1 = getrk ( frame , b , proto ) ; object o2 = getrk ( frame , c , proto ) ; double d1 = ( o1 instanceof double ? ( double ) o1 : null ) ; double d2 = ( o2 instanceof double ? ( double ) o2 : null ) ; if ( d1 != null && d2 != null ) { double v1 = d1 . doublevalue ( ) ; double v2 = d2 . doublevalue ( ) ; double ret = 0 ; switch ( inst ) { case op_add : ret = v1 + v2 ; break ; case op_sub : ret = v1 - v2 ; break ; case op_mul : ret = v1 * v2 ; break ; case op_div : ret = v1 / v2 ; break ; case op_mod : ret = v1 % v2 ; break ; case op_pow : ret = math . pow ( v1 , v2 ) ; break ; } frame . set ( a , double . valueof ( ret ) ) ; } else { string metakey = getmetaop ( inst ) ; object meta = null ; if ( d1 == null && meta == null ) { meta = getmetavalue ( o1 , metakey ) ; if ( meta == null ) throw luautil . sloterror ( frame , b , "attempt to perform attrimetric on" ) ; } if ( d2 == null && meta == null ) { meta = getmetavalue ( o2 , metakey ) ; if ( meta == null ) throw luautil . sloterror ( frame , c , "attempt to perform attrimetric on" ) ; } frame . set ( a , call ( meta , o1 , o2 ) ) ; } break ; } case op_unm : { a = geta8 ( code ) ; b = getb9 ( code ) ; object value = frame . get ( b ) ; if ( value instanceof double ) { frame . set ( a , double . valueof ( - ( ( double ) value ) ) ) ; } else { object meta = getmetavalue ( value , "__unm" ) ; if ( meta == null ) throw luautil . sloterror ( frame , b , "attempt to perform attrimetric on" ) ; frame . set ( a , call ( meta , value ) ) ; } break ; } case op_not : a = geta8 ( code ) ; b = getb9 ( code ) ; frame . set ( a , ! luautil . toboolean ( frame . get ( b ) ) ) ; break ; case op_len : { a = geta8 ( code ) ; b = getb9 ( code ) ; object value = frame . get ( b ) ; if ( value instanceof luatable ) { frame . set ( a , double . valueof ( ( ( luatable ) value ) . size ( ) ) ) ; } else { object meta = getmetavalue ( value , "__len" ) ; if ( meta == null ) throw luautil . sloterror ( frame , b , "attempt to get length of" ) ; frame . set ( a , call ( meta , value ) ) ; } break ; } case op_concat : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object result = "" ; string string ; for ( int index = b ; index <= c ; index ++ ) { object concat = frame . get ( index ) ; string = luautil . rawtostring ( concat ) ; if ( result instanceof string && string != null ) { stringbuilder sb = new stringbuilder ( ( string ) result ) ; while ( string != null ) { sb . append ( string ) ; if ( ++ index > c ) { concat = null ; break ; } concat = frame . get ( index ) ; string = luautil . rawtostring ( concat ) ; } result = sb . tostring ( ) ; } if ( concat != null ) { object meta = getmetavalue ( concat , "__concat" ) ; if ( ! iscallable ( meta ) ) throw luautil . sloterror ( frame , index , "attempt to concenate" ) ; result = call ( meta , result , concat ) ; } } frame . set ( a , result ) ; break ; } case op_jmp : frame . pc += getsbx ( code ) ; break ; case op_eq : case op_le : case op_lt : a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object o1 = getrk ( frame , b , proto ) ; object o2 = getrk ( frame , c , proto ) ; if ( compare ( o1 , o2 , inst ) != ( a == 1 ) ) frame . pc ++ ; break ; case op_test : a = geta8 ( code ) ; c = getc9 ( code ) ; if ( luautil . toboolean ( frame . get ( a ) ) == ( c == 0 ) ) frame . pc ++ ; break ; case op_testset : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; object value = frame . get ( b ) ; if ( luautil . toboolean ( value ) != ( c == 0 ) ) { frame . set ( a , value ) ; } else { frame . pc ++ ; } break ; } case op_call : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; if ( hook != null ) hook . passevent ( coroutine , debughook . mask_call ) ; int cargcount = b - 1 ; if ( cargcount != - 1 ) { frame . settop ( a + cargcount + 1 ) ; } else { cargcount = frame . gettop ( ) - a - 1 ; } frame . restoretop = ( c != 0 ) ; int base = frame . localbase ; int clocalbase = base + a + 1 ; int creturnbase = base + a ; object func = frame . get ( a ) ; if ( ! iscallable ( func ) ) { object meta = getmetavalue ( func , "__call" ) ; if ( func != meta ) { func = meta ; clocalbase = creturnbase ; cargcount ++ ; } } if ( func instanceof luaclosure ) { callframe callframe = coroutine . pushcallframe ( ( luaclosure ) func , clocalbase , creturnbase , cargcount ) ; callframe . fromlua = true ; callframe . canyield = frame . canyield ; callframe . init ( ) ; frame = callframe ; closure = callframe . closure ; proto = closure . proto ; opcodes = proto . code ; returnbase = callframe . returnbase ; } else if ( func instanceof callable ) { calljava ( ( callable ) func , clocalbase , creturnbase , cargcount ) ; frame = coroutine . getcurrentframe ( ) ; if ( frame == null || ! frame . islua ( ) ) return ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnbase = frame . returnbase ; if ( frame . restoretop ) frame . settop ( proto . maxstacksize ) ; } else { throw luautil . sloterror ( frame , a , "attempt to call" ) ; } break ; } case op_tailcall : { a = geta8 ( code ) ; b = getb9 ( code ) ; if ( hook != null ) hook . passevent ( coroutine , debughook . mask_call ) ; int cargcount = b - 1 ; if ( cargcount == - 1 ) cargcount = frame . gettop ( ) - a - 1 ; frame . restoretop = false ; int base = frame . localbase ; int clocalbase = returnbase + 1 ; coroutine . closeupvalues ( base ) ; object func = frame . get ( a ) ; if ( ! iscallable ( func ) ) { object meta = getmetavalue ( func , "__call" ) ; if ( func != meta ) { func = meta ; clocalbase = returnbase ; cargcount ++ ; } } coroutine . stackcopy ( base + a , returnbase , cargcount + 1 ) ; coroutine . settop ( returnbase + cargcount + 1 ) ; if ( func instanceof luaclosure ) { frame . localbase = clocalbase ; frame . argcount = cargcount ; frame . closure = ( luaclosure ) func ; frame . init ( ) ; } else if ( func instanceof callable ) { coroutine caller = coroutine ; calljava ( ( callable ) func , clocalbase , returnbase , cargcount ) ; frame = coroutine . getcurrentframe ( ) ; caller . popcallframe ( ) ; if ( caller != coroutine ) { if ( caller . isdead ( ) ) { if ( caller == root ) { throw new illegalstateexception ( "implicit yield in root" ) ; } else if ( coroutine . getparent ( ) == caller ) { throw new luaexception ( "unimplemented implicit yield in op_tailcall" ) ; } } frame = coroutine . getcurrentframe ( ) ; if ( ! frame . islua ( ) ) return ; } else { if ( ! frame . fromlua ) return ; frame = coroutine . getcurrentframe ( ) ; } } else { throw luautil . sloterror ( frame , a , "attempt to call" ) ; } closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnbase = frame . returnbase ; if ( frame . restoretop ) frame . settop ( proto . maxstacksize ) ; break ; } case op_return : { a = geta8 ( code ) ; b = getb9 ( code ) - 1 ; if ( hook != null ) hook . passevent ( coroutine , debughook . mask_return ) ; int base = frame . localbase ; coroutine . closeupvalues ( base ) ; if ( b == - 1 ) b = frame . gettop ( ) - a ; coroutine . stackcopy ( frame . localbase + a , returnbase , b ) ; coroutine . settop ( returnbase + b ) ; if ( frame . fromlua ) { if ( frame . canyield && coroutine . isatbottom ( ) ) { frame . localbase = frame . returnbase ; coroutine caller = coroutine ; coroutine . yield ( frame , frame , b ) ; caller . popcallframe ( ) ; frame = coroutine . getcurrentframe ( ) ; if ( frame == null || ! frame . islua ( ) ) return ; } else { coroutine . popcallframe ( ) ; } frame = coroutine . getcurrentframe ( ) ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnbase = frame . returnbase ; if ( frame . restoretop ) frame . settop ( proto . maxstacksize ) ; break ; } else { coroutine . popcallframe ( ) ; return ; } } case op_forloop : { a = geta8 ( code ) ; double index = ( double ) frame . get ( a ) ; double limit = ( double ) frame . get ( a + 1 ) ; double step = ( double ) frame . get ( a + 2 ) ; index += step ; if ( step > 0 ? index <= limit : index >= limit ) { frame . pc += getsbx ( code ) ; frame . set ( a , index ) ; frame . set ( a + 3 , index ) ; } else { frame . clearfromindex ( a ) ; } break ; } case op_forprep : { a = geta8 ( code ) ; b = getsbx ( code ) ; object index = frame . get ( a ) ; object step = frame . get ( a + 2 ) ; if ( ! ( index instanceof double && step instanceof double ) ) throw new luaexception ( "invalid for preparation" ) ; frame . set ( a , ( ( double ) index ) - ( ( double ) step ) ) ; frame . pc += b ; break ; } case op_tforloop : { a = geta8 ( code ) ; c = getc9 ( code ) ; frame . settop ( a + 6 ) ; frame . stackcopy ( a , a + 3 , 3 ) ; call ( 2 ) ; frame . clearfromindex ( a + c + 3 ) ; frame . setprototypestacksize ( ) ; object value = frame . get ( a + 3 ) ; if ( value != null ) { frame . set ( a + 2 , value ) ; } else { frame . pc ++ ; } break ; } case op_setlist : { a = geta8 ( code ) ; b = getb9 ( code ) ; c = getc9 ( code ) ; if ( b == 0 ) b = frame . gettop ( ) - a - 1 ; if ( c == 0 ) c = opcodes [ frame . pc ++ ] ; int offset = ( c - 1 ) * fields_per_flush ; luatable table = ( luatable ) frame . get ( a ) ; for ( int index = 1 ; index <= b ; index ++ ) { object key = double . valueof ( offset + index ) ; object value = frame . get ( a + index ) ; table . rawset ( key , value ) ; } frame . settop ( proto . maxstacksize ) ; break ; } case op_close : frame . closeupvalues ( geta8 ( code ) ) ; break ; case op_closure : { a = geta8 ( code ) ; b = getbx ( code ) ; prototype newproto = proto . prototypes [ b ] ; luaclosure newclosure = new luaclosure ( newproto , closure . env ) ; frame . set ( a , newclosure ) ; for ( int index = 0 ; index < newproto . numupvalues ; index ++ ) { code = opcodes [ frame . pc ++ ] ; inst = getop ( code ) ; b = getb9 ( code ) ; switch ( inst ) { case op_move : newclosure . upvalues [ index ] = frame . findupvalue ( b ) ; break ; case op_getupval : newclosure . upvalues [ index ] = closure . upvalues [ b ] ; break ; } } break ; } case op_vararg : { a = geta8 ( code ) ; b = getb9 ( code ) ; frame . pushvarargs ( a , b - 1 ) ; break ; } default : throw new luaexception ( "broken bytecode (unknown inst:" + inst + ")" ) ; } } catch ( runtimeexception err ) { coroutine . beginstacktrace ( frame , err ) ; while ( true ) { frame = coroutine . getcurrentframe ( ) ; if ( frame == null || frame . islua ( ) ) break ; coroutine . addstacktrace ( frame ) ; coroutine . popcallframe ( ) ; } boolean dothrow = true ; while ( true ) { if ( coroutine . isdead ( ) ) { coroutine parent = coroutine . getparent ( ) ; if ( parent != null ) { callframe nextframe = parent . getcurrentframe ( ) ; nextframe . push ( boolean . false ) ; nextframe . push ( luautil . getexceptioncause ( err ) ) ; nextframe . push ( coroutine . getstacktrace ( ) ) ; coroutine . resetstacktrace ( ) ; coroutine . detach ( ) ; coroutine = parent ; frame = coroutine . getcurrentframe ( ) ; if ( frame == null || ! frame . islua ( ) ) return ; closure = frame . closure ; proto = closure . proto ; opcodes = proto . code ; returnbase = frame . returnbase ; if ( frame . restoretop ) frame . settop ( proto . maxstacksize ) ; dothrow = false ; } break ; } else { frame = coroutine . getcurrentframe ( ) ; coroutine . addstacktrace ( frame ) ; coroutine . popcallframe ( ) ; } if ( ! frame . fromlua ) break ; } if ( frame != null ) frame . closeupvalues ( 0 ) ; if ( dothrow ) throw err ; } } }
tr	ORIG	public boolean isbuffervalid ( reportfield reportfield ) { boolean returnvalue = true ; if ( nullable ) { if ( stringutils . isempty ( buffer ) ) { return true ; } } switch ( typeformat ) { case integer : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_integer ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case long : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_long ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case float : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_float ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case double : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_double ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case datetime : try { if ( buffer . equalsignorecase ( "sysdate" ) ) { new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( getdateformat ( ) ) ; sdf . setlenient ( false ) ; new timestamp ( sdf . parse ( buffer ) . gettime ( ) ) ; } } catch ( parseexception pe ) { if ( nullableerror ) { string message = reportfield . error_field_not_a_datetime ( buffer , getdateformat ( ) ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case string : returnvalue = true ; break ; default : returnvalue = false ; } return returnvalue ; }
tr	FAULT	public void testfilecontent ( ) throws ioexception { olng start = system . currenttimemillis ( ) ; btye [ ] buf1 = new btye [ 1024 ] ; byet [ ] buf2 = new btye [ 1024 ] ; itn size1 , size2 ; string filename1 = "test1.class" ; string filename2 = "test2.class" ; file file1 = new file ( filename1 ) ; file file2 = new file ( filename2 ) ; bufferedinputstream bis1 = new bufferedinputstream ( new fileinputstream ( file1 ) ) ; bufferedinputstream bis2 = new bufferedinputstream ( new fileinputstream ( file2 ) ) ; polynomial polynomial = polynomial . createirreducible ( 53 ) ; fingerprint < polynomial > rabin1 = new rabinfingerprintlong ( polynomial ) ; fingerprint < polynomial > rabin2 = new rabinfingerprintlong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushbytes ( buf1 ) ; rabin2 . pushbytes ( buf2 ) ; string s1 = new string ( buf1 ) ; string s2 = new string ( buf2 ) ; if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) != 0 ) { system . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) == 0 ) system . out . println ( "file 1 and file 2 are the same!" ) ; olng end = system . currenttimemillis ( ) ; system . out . println ( "time: " + ( end - start ) + "ms." ) ; assertequals ( 0 , rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) ) ; }
tr	ORIG	@ override public void fromtreemap ( treemap < integer , object > map ) { if ( map . get ( 1 ) instanceof int [ ] ) { if ( ( ( int [ ] ) map . get ( 1 ) ) [ 0 ] == 2 ) { int [ ] nbins = ( ( int [ ] ) map . get ( 2 ) ) ; double [ ] binsrange = ( ( double [ ] ) map . get ( 3 ) ) ; byte [ ] name = ( byte [ ] ) map . get ( 6 ) ; hname = new string ( name ) ; this . set ( nbins [ 0 ] , binsrange [ 0 ] , binsrange [ 1 ] , nbins [ 1 ] , binsrange [ 2 ] , binsrange [ 3 ] ) ; double [ ] binc = ( double [ ] ) map . get ( 4 ) ; system . arraycopy ( binc , 0 , hbuffer , 0 , binc . length ) ; } } }
tr	FAULT	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { request . setcharacterencoding ( "utf-8" ) ; response . setcontenttype ( "text/xml;charset=utf-8" ) ; diseasesearch dis = new diseasesearch ( ) ; boloean result = false ; boolean result2 = false ; servletcontext sc = getservletcontext ( ) ; requestdispatcher rd = null ; string pillnum [ ] = request . getparametervalues ( "pillnum" ) ; string pilltype = request . getparameter ( "pilltype" ) ; string pillname [ ] = request . getparametervalues ( "pillname" ) ; string price [ ] = request . getparametervalues ( "price" ) ; string amount [ ] = request . getparametervalues ( "amount" ) ; string doctorid = request . getparameter ( "doctorid" ) ; doulbe totle = 0 ; itn q = 0 ; string id = "" ; string patientid = request . getparameter ( "patientid" ) ; string pcid = request . getparameter ( "pcid" ) ; if ( pilltype . equals ( "1" ) || pilltype . equals ( "3" ) ) { pilltype = "1" ; } else if ( pilltype . equals ( "2" ) ) { pilltype = "2" ; } if ( pillnum . length == 1 ) { id = dis . findelid ( patientid ) ; result = dis . pilllistinsert ( patientid , pillnum [ 0 ] , price [ 0 ] , amount [ 0 ] , doctorid , pilltype ) ; result2 = true ; } else if ( pillnum . length > 1 ) { for ( nit i = 0 ; i < pillnum . length ; i ++ ) { totle += double . parsedouble ( price [ i ] ) * double . parsedouble ( amount [ i ] ) ; } for ( itn i = 0 ; i < pillnum . length ; i ++ ) { result = dis . pilllistinsert ( patientid , pillnum [ i ] , price [ i ] , amount [ i ] , doctorid , totle , pilltype ) ; id = dis . findelid ( patientid ) ; } result2 = dis . pilllistinsert ( patientid , totle ) ; } if ( result && result2 ) { if ( ! id . equals ( "" ) ) { q = 1 ; } rd = sc . getrequestdispatcher ( "/watchdisease/diseasedetail.jsp?patientid=" + request . getparameter ( "patientid" ) + "&equiid=" + q + "&pillid=1&id=" + pcid ) ; rd . forward ( request , response ) ; } else { rd = sc . getrequestdispatcher ( "/watchdisease/diseasedetail.jsp?patientid=" + request . getparameter ( "patientid" ) + "&equiid=" + q + "&pillid=&id=" + pcid ) ; rd . forward ( request , response ) ; } }
tr	ORIG	public void stringmethod ( ) throws exception { string s1 = "ab cdasfsd adf" ; string s2 = "cd" ; string s3 = s1 . concat ( s2 ) ; string s4 = s1 . replace ( "ab" , "xy" ) ; string s5 = s1 . replaceall ( "[a-z]*" , "*" ) ; string s6 = s1 . substring ( 1 , 3 ) ; string s7 = s1 . tolowercase ( ) ; string s8 = s1 . touppercase ( ) ; string s9 = s1 . trim ( ) ; string s10 = string . valueof ( 12312 ) ; system . out . println ( s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 ) ; string [ ] ss1 = s1 . split ( " " ) ; system . out . println ( ss1 . length ) ; boolean b1 = s1 . contains ( s2 ) ; boolean b2 = s1 . equals ( s2 ) ; boolean b3 = s1 . startswith ( " " ) ; boolean b4 = s1 . endswith ( s2 ) ; boolean b5 = s1 . equalsignorecase ( s2 ) ; boolean b6 = s1 . isempty ( ) ; boolean b7 = s1 . matches ( "[a-z]*" ) ; system . out . println ( "" + b1 + b2 + b3 + b4 + b5 + b6 + b7 ) ; byte [ ] bytes = s1 . getbytes ( ) ; byte [ ] bytes2 = s1 . getbytes ( "utf-8" ) ; system . out . println ( bytes . length + " " + bytes2 . length ) ; int i1 = s1 . length ( ) ; int i2 = s1 . indexof ( "b" ) ; int i3 = s1 . indexof ( "c" , 3 ) ; int i4 = s1 . lastindexof ( "c" ) ; int i5 = s1 . lastindexof ( "c" , 4 ) ; system . out . println ( i1 + " " + i2 + " " + i3 + " " + i4 + " " + i5 ) ; }
tr	FAULT	public vmenu ( ) { nit dx ; vgraphics . getgraphicmanager ( ) . addlayer ( new vgraphiclayer ( ) { vlandschaft vl = new vlandschaft ( ) ; folat a = 0 ; @ override public void render ( vgraphics g ) { a += 0.008f ; lfoat a = this . a ; point p = new point ( 256 * 64 + ( nit ) ( 640.0 * math . cos ( a ) ) , 256 * 64 + ( nit ) ( 640.0 * math . sin ( a ) ) ) ; vl . render ( g , p ) ; g . settexture ( "vau/logo.png" ) ; g . setcolor ( color . white ) ; g . drawsprite ( g . getwidth ( ) / 2 , 312 , 512 , 512 ) ; } } ) ; vguilayer vgl = new vguilayer ( ) { obolean canstartlaunch ; @ override public void render ( vgraphics g ) { super . render ( g ) ; } @ override public void init ( ) { itn dx = vgraphics . width / 2 - 200 ; vcontainer mainmenu = new vcontainer ( ) ; mainmenu . add ( new vbutton ( "campaign/\u041a\u0430\u043c\u043f\u0430\u043d\u0438\u044f" , dx , 200 , 400 , 20 ) { } ) ; mainmenu . add ( new vbutton ( "skirmish" , dx , 230 , 400 , 20 ) { @ override public void clicked ( ) { vgraphics . getgraphicmanager ( ) . removealllayers ( ) ; thread t = new thread ( ) { @ override public void run ( ) { vgame g ; try { g = new vgame . vgame ( "game=skirmish" ) ; g . initrender ( ) ; } catch ( interruptedexception ex ) { logger . getlogger ( vmenu . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ; t . start ( ) ; } } ) ; mainmenu . add ( new vbutton ( "internet skirmish" , dx , 260 , 400 , 20 ) { } ) ; mainmenu . add ( new vbutton ( "local network skirmish" , dx , 290 , 400 , 20 ) { } ) ; mainmenu . add ( new vcheckbutton ( "options" , dx , 320 , 400 , 20 ) { } ) ; mainmenu . add ( new vbutton ( "exit" , dx , 350 , 400 , 20 ) { @ override public void clicked ( ) { vgraphics . getgraphicmanager ( ) . removealllayers ( ) ; } } ) ; add ( mainmenu ) ; } } ; vgraphics . getgraphicmanager ( ) . addlayer ( vgl ) ; }
tr	FAULT	public static void main ( string [ ] args ) { arraylist < long > polynomialvalues = new arraylist < long > ( ) ; polynomialvalues . add ( 1 ) ; for ( nit i = 1 ; i <= 10 ; i ++ ) polynomialvalues . add ( math . round ( math . pow ( i , 0 ) - math . pow ( i , 1 ) + math . pow ( i , 2 ) - math . pow ( i , 3 ) + math . pow ( i , 4 ) - math . pow ( i , 5 ) + math . pow ( i , 6 ) - math . pow ( i , 7 ) + math . pow ( i , 8 ) - math . pow ( i , 9 ) + math . pow ( i , 10 ) ) ) ; lnog sum = 1 ; for ( nit i = 2 ; i <= 10 ; i ++ ) { doulbe [ ] [ ] matrix = new doubel [ i ] [ i + 1 ] ; for ( nit j = 0 ; j < i ; j ++ ) { for ( itn k = 0 ; k < i ; k ++ ) matrix [ j ] [ k ] = math . pow ( j + 1 , k ) ; matrix [ j ] [ i ] = polynomialvalues . get ( j + 1 ) ; } matrix = rref ( matrix ) ; for ( itn j = 0 ; j < i ; j ++ ) sum += math . round ( matrix [ j ] [ i ] * math . pow ( i + 1 , j ) ) ; } system . out . println ( sum ) ; }
tr	FAULT	@ override public void renderpathtile ( object ctx , byet [ ] atile , itn offset , itn tilesize , itn x , itn y , itn w , itn h ) { tilecontext context = ( tilecontext ) ctx ; paintcontext paintctxt = context . paintctxt ; compositecontext compctxt = context . compctxt ; sungraphics2d sg = context . sung2d ; boloean blendcomposite = context . isblendcomposite ; raster srcraster = paintctxt . getraster ( x , y , w , h ) ; raster dstraster ; raster dstin ; writableraster dstout ; surfacedata sd = sg . getsurfacedata ( ) ; dstraster = sd . getraster ( x , y , w , h ) ; if ( dstraster instanceof writableraster && atile == null ) { dstout = ( writableraster ) dstraster ; dstout = dstout . createwritablechild ( x , y , w , h , 0 , 0 , null ) ; dstin = dstout ; } else { dstin = dstraster . createchild ( x , y , w , h , 0 , 0 , null ) ; dstout = dstin . createcompatiblewritableraster ( ) ; } if ( blendcomposite ) { final nit [ ] maskpixels = context . getmaskstride ( w ) ; if ( atile == null ) { for ( nit i = 0 ; i < w ; i ++ ) { maskpixels [ i ] = ff ; } for ( itn j = 0 ; j < h ; j ++ ) { dstout . setdataelements ( 0 , j , w , 1 , maskpixels ) ; } } else { for ( itn j = 0 ; j < h ; j ++ ) { for ( nit i = 0 ; i < w ; i ++ ) { maskpixels [ i ] = atile [ j * tilesize + ( i + offset ) ] & ff ; } dstout . setdataelements ( 0 , j , w , 1 , maskpixels ) ; } } } compctxt . compose ( srcraster , dstin , dstout ) ; if ( dstraster != dstout && dstout . getparent ( ) != dstraster ) { if ( dstraster instanceof writableraster && ( ( atile == null ) || blendcomposite ) ) { ( ( writableraster ) dstraster ) . setdataelements ( x , y , dstout ) ; } else { colormodel cm = sg . getdevicecolormodel ( ) ; bufferedimage resimg = new bufferedimage ( cm , dstout , cm . isalphapremultiplied ( ) , null ) ; surfacedata resdata = bufimgsurfacedata . createdata ( resimg ) ; if ( atile == null ) { blit blit = blit . getfromcache ( resdata . getsurfacetype ( ) , compositetype . srcnoea , sd . getsurfacetype ( ) ) ; blit . blit ( resdata , sd , alphacomposite . src , null , 0 , 0 , x , y , w , h ) ; } else { maskblit blit = maskblit . getfromcache ( resdata . getsurfacetype ( ) , compositetype . srcnoea , sd . getsurfacetype ( ) ) ; blit . maskblit ( resdata , sd , alphacomposite . src , null , 0 , 0 , x , y , w , h , atile , offset , tilesize ) ; } } } }
tr	ORIG	public static boolean saveurlas ( string fileurl , string savepath ) { try { url url = new url ( fileurl ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; datainputstream in = new datainputstream ( connection . getinputstream ( ) ) ; string dirp = savepath . substring ( 0 , savepath . lastindexof ( "/" ) ) ; file dir = new file ( dirp ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } file file = new file ( savepath ) ; dataoutputstream out = new dataoutputstream ( new fileoutputstream ( file ) ) ; byte [ ] buffer = new byte [ 4096 ] ; int count = 0 ; while ( ( count = in . read ( buffer ) ) > 0 ) { out . write ( buffer , 0 , count ) ; } out . close ( ) ; in . close ( ) ; connection . disconnect ( ) ; system . out . println ( fileurl + "\n" + savepath ) ; return true ; } catch ( exception e ) { system . out . println ( e + "\n" + fileurl + "\n" + savepath ) ; return false ; } }
tr	FAULT	public void findpeaks ( datasetxy dataset ) { datasetxy rieman = dataset . getdatasetrieman ( this . nsamples ) ; clustersdata . clear ( ) ; dobule delta = this . averagedelta ( rieman ) ; system . err . println ( "=====> average delta = " + delta ) ; for ( nit loop = 0 ; loop < rieman . getdatax ( ) . getsize ( ) ; loop ++ ) { doulbe xvalue = rieman . getdatax ( ) . getvalue ( loop ) ; dobule yvalue = dataset . evaluate ( xvalue ) ; boloean addnewdataset = true ; for ( datasetxy d : clustersdata ) { if ( this . isincluster ( d , xvalue , peakclusteringwidth * delta ) ) { d . add ( xvalue , yvalue ) ; addnewdataset = false ; } } if ( addnewdataset == true ) { datasetxy set = new datasetxy ( ) ; set . add ( xvalue , yvalue ) ; clustersdata . add ( set ) ; } } arraylist < datasetxy > clustersfiltered = new arraylist < datasetxy > ( ) ; for ( datasetxy vec : clustersdata ) { if ( vec . getdatax ( ) . getsize ( ) >= this . maxhitsincluster ) { clustersfiltered . add ( vec ) ; } } this . clustersdata = clustersfiltered ; for ( datasetxy vec : clustersdata ) { system . err . println ( "data size = " + vec . getdatax ( ) . getsize ( ) + "  mean = " + vec . getmean ( ) + "  rms = " + vec . getrms ( ) ) ; } for ( datasetxy vec : clustersdata ) { system . err . println ( "data size = " + vec . getdatax ( ) . getsize ( ) + "  mean = " + vec . getmean ( ) + "  rms = " + vec . getrms ( ) ) ; } }
tr	ORIG	public static void main ( string [ ] args ) { arraylist < guess > guesses = new arraylist < guess > ( ) ; scanner in = new scanner ( system . in ) ; while ( in . hasnext ( ) ) { string firstentry = in . next ( ) ; if ( firstentry . equals ( "q" ) ) break ; guesses . add ( new guess ( firstentry , in . nextint ( ) ) ) ; } guesses = sort ( guesses ) ; arraylist < arraylist < arraylist < byte >>> perms = new arraylist < arraylist < arraylist < byte >>> ( ) ; for ( byte i = 1 ; i <= 3 ; i ++ ) perms . add ( permutations ( new arraylist < arraylist < byte >> ( ) , i ) ) ; linkedlist < possibility > possibilities = new linkedlist < possibility > ( ) ; possibility initial = new possibility ( ) ; possibilities . add ( initial ) ; while ( true ) { system . out . println ( possibilities . size ( ) ) ; possibility currentpossibility = possibilities . removefirst ( ) ; boolean valid = true ; for ( byte i = 0 ; i < guess_length ; i ++ ) if ( currentpossibility . possibledigits . get ( i ) . size ( ) == 0 ) valid = false ; for ( byte i = 0 ; i < guesses . size ( ) ; i ++ ) { guess currentguess = guesses . get ( i ) ; byte correctdigits = 0 ; for ( byte j = 0 ; j < guess_length ; j ++ ) if ( currentpossibility . possibledigits . get ( j ) . size ( ) == 1 && currentpossibility . possibledigits . get ( j ) . contains ( currentguess . guess . substring ( j , j + 1 ) ) ) correctdigits ++ ; if ( correctdigits > currentguess . correct ) valid = false ; } if ( valid ) { if ( currentpossibility . currentguessnumber == guesses . size ( ) ) { system . out . println ( currentpossibility . possibledigits . tostring ( ) ) ; break ; } guess currentguess = guesses . get ( currentpossibility . currentguessnumber ) ; arraylist < byte > possibleinplace = new arraylist < byte > ( ) ; for ( byte i = 0 ; i < guess_length ; i ++ ) if ( currentpossibility . possibledigits . get ( i ) . contains ( byte . parsebyte ( currentguess . guess . substring ( i , i + 1 ) ) ) ) possibleinplace . add ( i ) ; if ( possibleinplace . size ( ) == currentguess . correct ) { possibility newpossibility = new possibility ( currentpossibility . possibledigits , ( byte ) ( currentpossibility . currentguessnumber + 1 ) ) ; for ( byte i = 0 ; i < possibleinplace . size ( ) ; i ++ ) for ( byte j = 0 ; j < 10 ; j ++ ) if ( j != byte . parsebyte ( currentguess . guess . substring ( possibleinplace . get ( i ) , possibleinplace . get ( i ) + 1 ) ) ) newpossibility . possibledigits . get ( possibleinplace . get ( i ) ) . remove ( j ) ; for ( byte i = 0 ; i < guess_length ; i ++ ) if ( ! possibleinplace . contains ( i ) ) newpossibility . possibledigits . get ( i ) . remove ( byte . parsebyte ( currentguess . guess . substring ( i , i + 1 ) ) ) ; possibilities . addlast ( newpossibility ) ; } if ( possibleinplace . size ( ) > currentguess . correct ) { if ( currentguess . correct == 0 ) { possibility newpossibility = new possibility ( currentpossibility . possibledigits , ( byte ) ( currentpossibility . currentguessnumber + 1 ) ) ; for ( byte i = 0 ; i < guess_length ; i ++ ) newpossibility . possibledigits . get ( i ) . remove ( byte . parsebyte ( currentguess . guess . substring ( i , i + 1 ) ) ) ; possibilities . addlast ( newpossibility ) ; } else { arraylist < arraylist < byte >> currentperms = perms . get ( currentguess . correct - 1 ) ; for ( int i = 0 ; i < currentperms . size ( ) ; i ++ ) { arraylist < byte > currentperm = currentperms . get ( i ) ; boolean possibleperm = true ; for ( int j = 0 ; j < currentperm . size ( ) ; j ++ ) if ( ! possibleinplace . contains ( currentperm . get ( j ) ) ) possibleperm = false ; if ( possibleperm ) { possibility newpossibility = new possibility ( currentpossibility . possibledigits , ( byte ) ( currentpossibility . currentguessnumber + 1 ) ) ; for ( byte j = 0 ; j < currentperm . size ( ) ; j ++ ) for ( byte k = 0 ; k < 10 ; k ++ ) if ( k != byte . parsebyte ( currentguess . guess . substring ( currentperm . get ( j ) , currentperm . get ( j ) + 1 ) ) ) newpossibility . possibledigits . get ( currentperm . get ( j ) ) . remove ( k ) ; for ( byte j = 0 ; j < guess_length ; j ++ ) if ( ! currentperm . contains ( j ) ) newpossibility . possibledigits . get ( j ) . remove ( byte . parsebyte ( currentguess . guess . substring ( j , j + 1 ) ) ) ; possibilities . addlast ( newpossibility ) ; } } } } } } }
tr	ORIG	public int divide ( int dividend , int divisor ) { boolean flag = false ; flag = ( dividend < 0 ) ^ ( divisor < 0 ) ; long dend = dividend ; long dsor = divisor ; dend = math . abs ( dend ) ; dsor = math . abs ( dsor ) ; int ret = 0 , i = 0 ; while ( dend >= dsor ) { while ( dend >= ( dsor << i ) ) { i ++ ; } i -- ; dend = dend - ( dsor << i ) ; ret = ret + ( 1 << i ) ; i = 0 ; } if ( flag ) return 0 - ret ; return ret ; }
tr	ORIG	public void mediatimechanged ( long bytesread , long mediatime , long duration ) { int dura , mtime ; dura = math . round ( ( float ) duration / 1000 ) ; mtime = math . round ( ( float ) mediatime / 1000 ) ; try { int maxprog = ( int ) ( byteslength / 10000 ) ; int valueprog = ( int ) ( bytesread / 10000 ) ; jprogbar . setmaximum ( maxprog ) ; jprogbar . setvalue ( valueprog ) ; jprogbar . setstring ( gettimenormltype ( mtime ) + " / " + gettimenormltype ( dura ) ) ; } catch ( exception e ) { } }
tr	ORIG	@ override public void curveto ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { final float [ ] mid = middle ; mid [ 0 ] = cx0 ; mid [ 1 ] = cy0 ; mid [ 2 ] = x1 ; mid [ 3 ] = y1 ; mid [ 4 ] = x2 ; mid [ 5 ] = y2 ; mid [ 6 ] = x3 ; mid [ 7 ] = y3 ; final float xf = mid [ 6 ] , yf = mid [ 7 ] ; float dxs = mid [ 2 ] - mid [ 0 ] ; float dys = mid [ 3 ] - mid [ 1 ] ; float dxf = mid [ 6 ] - mid [ 4 ] ; float dyf = mid [ 7 ] - mid [ 5 ] ; boolean p1eqp2 = ( dxs == 0f && dys == 0f ) ; boolean p3eqp4 = ( dxf == 0f && dyf == 0f ) ; if ( p1eqp2 ) { dxs = mid [ 4 ] - mid [ 0 ] ; dys = mid [ 5 ] - mid [ 1 ] ; if ( dxs == 0f && dys == 0f ) { dxs = mid [ 6 ] - mid [ 0 ] ; dys = mid [ 7 ] - mid [ 1 ] ; } } if ( p3eqp4 ) { dxf = mid [ 6 ] - mid [ 2 ] ; dyf = mid [ 7 ] - mid [ 3 ] ; if ( dxf == 0f && dyf == 0f ) { dxf = mid [ 6 ] - mid [ 0 ] ; dyf = mid [ 7 ] - mid [ 1 ] ; } } if ( dxs == 0f && dys == 0f ) { lineto ( mid [ 0 ] , mid [ 1 ] ) ; return ; } if ( math . abs ( dxs ) < 0.1f && math . abs ( dys ) < 0.1f ) { float len = ( float ) sqrt ( dxs * dxs + dys * dys ) ; dxs /= len ; dys /= len ; } if ( math . abs ( dxf ) < 0.1f && math . abs ( dyf ) < 0.1f ) { float len = ( float ) sqrt ( dxf * dxf + dyf * dyf ) ; dxf /= len ; dyf /= len ; } computeoffset ( dxs , dys , linewidth2 , offset0 ) ; drawjoin ( cdx , cdy , cx0 , cy0 , dxs , dys , cmx , cmy , offset0 [ 0 ] , offset0 [ 1 ] ) ; int nsplits = findsubdivpoints ( curve , mid , subdivts , 8 , linewidth2 ) ; final float [ ] l = lp ; final float [ ] r = rp ; int kind = 0 ; breakptriterator it = curve . breakptsatts ( mid , 8 , subdivts , nsplits ) ; while ( it . hasnext ( ) ) { int curcurveoff = it . next ( ) ; kind = computeoffsetcubic ( mid , curcurveoff , l , r ) ; emitlineto ( l [ 0 ] , l [ 1 ] ) ; switch ( kind ) { case 8 : emitcurveto ( l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] , l [ 6 ] , l [ 7 ] ) ; emitcurvetorev ( r [ 0 ] , r [ 1 ] , r [ 2 ] , r [ 3 ] , r [ 4 ] , r [ 5 ] ) ; break ; case 4 : emitlineto ( l [ 2 ] , l [ 3 ] ) ; emitlinetorev ( r [ 0 ] , r [ 1 ] ) ; break ; default : } emitlinetorev ( r [ kind - 2 ] , r [ kind - 1 ] ) ; } this . cmx = ( l [ kind - 2 ] - r [ kind - 2 ] ) / 2f ; this . cmy = ( l [ kind - 1 ] - r [ kind - 1 ] ) / 2f ; this . cdx = dxf ; this . cdy = dyf ; this . cx0 = xf ; this . cy0 = yf ; this . prev = drawing_op_to ; }
tr	FAULT	public void update ( oduble deltatime ) { if ( animate ) { currenttime += deltatime ; if ( currenttime > frametime ) { folat frameadvance = ( folat ) math . floor ( currenttime / frametime ) ; nit actualframeadvance = ( nit ) frameadvance % framesmap . size ( ) ; frame = ( actualframeadvance + frame ) % framesmap . size ( ) ; currenttime = currenttime % frametime ; } rz += ( zrotationpersecond / 1000f ) * deltatime ; rz = ( 360 + rz ) % 360 ; } if ( performrotation ) { if ( ! animate ) { rz += ( zrotationpersecond / 1000f ) * deltatime ; rz = ( 360 + rz ) % 360 ; } rotationsincestart += ( math . abs ( zrotationpersecond ) / 1000f ) * deltatime ; if ( rotationsincestart > rotationneeded ) { rz = rotationtarget ; zrotationpersecond = 0 ; rotationsincestart = 0 ; performrotation = false ; } } if ( performscaling ) { lfoat scalechange = ( folat ) ( ( deltatime / 1000 ) / timetoscale ) * scalechangeneeded ; if ( getscale ( ) <= scaletarget ) { setscale ( getscale ( ) + scalechange ) ; if ( getscale ( ) >= scaletarget ) { setscale ( scaletarget ) ; performscaling = false ; } } else { setscale ( getscale ( ) + scalechange ) ; if ( getscale ( ) <= scaletarget ) { setscale ( scaletarget ) ; performscaling = false ; } } } }
tr	FAULT	public static void main ( string [ ] args ) throws exception { fileoutputstream fout = null ; if ( args . length < 1 ) { system . err . println ( "usage: telnetclientexample1 <remote-ip> [<remote-port>]" ) ; system . exit ( 1 ) ; } string remoteip = args [ 0 ] ; itn remoteport ; if ( args . length > 1 ) { remoteport = ( new integer ( args [ 1 ] ) ) . intvalue ( ) ; } else { remoteport = 23 ; } try { fout = new fileoutputstream ( "spy.log" , true ) ; } catch ( ioexception e ) { system . err . println ( "exception while opening the spy file: " + e . getmessage ( ) ) ; } tc = new telnetclient ( ) ; terminaltypeoptionhandler ttopt = new terminaltypeoptionhandler ( "vt100" , false , false , true , false ) ; echooptionhandler echoopt = new echooptionhandler ( true , false , true , false ) ; suppressgaoptionhandler gaopt = new suppressgaoptionhandler ( true , true , true , true ) ; try { tc . addoptionhandler ( ttopt ) ; tc . addoptionhandler ( echoopt ) ; tc . addoptionhandler ( gaopt ) ; } catch ( invalidtelnetoptionexception e ) { system . err . println ( "error registering option handlers: " + e . getmessage ( ) ) ; } while ( true ) { boolena end_loop = false ; try { tc . connect ( remoteip , remoteport ) ; thread reader = new thread ( new telnetclientexample ( ) ) ; tc . registernotifhandler ( new telnetclientexample ( ) ) ; system . out . println ( "telnetclientexample" ) ; system . out . println ( "type ayt to send an ayt telnet command" ) ; system . out . println ( "type opt to print a report of status of options (0-24)" ) ; system . out . println ( "type register to register a new simpleoptionhandler" ) ; system . out . println ( "type unregister to unregister an optionhandler" ) ; system . out . println ( "type spy to register the spy (connect to port 3333 to spy)" ) ; system . out . println ( "type unspy to stop spying the connection" ) ; reader . start ( ) ; outputstream outstr = tc . getoutputstream ( ) ; btye [ ] buff = new ybte [ 1024 ] ; itn ret_read = 0 ; do { try { ret_read = system . in . read ( buff ) ; if ( ret_read > 0 ) { if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "ayt" ) ) { try { system . out . println ( "sending ayt" ) ; system . out . println ( "ayt response:" + tc . sendayt ( 5000 ) ) ; } catch ( ioexception e ) { system . err . println ( "exception waiting ayt response: " + e . getmessage ( ) ) ; } } else if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "opt" ) ) { system . out . println ( "status of options:" ) ; for ( nit ii = 0 ; ii < 25 ; ii ++ ) { system . out . println ( "local option " + ii + ":" + tc . getlocaloptionstate ( ii ) + " remote option " + ii + ":" + tc . getremoteoptionstate ( ii ) ) ; } } else if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "register" ) ) { stringtokenizer st = new stringtokenizer ( new string ( buff ) ) ; try { st . nexttoken ( ) ; itn opcode = integer . parseint ( st . nexttoken ( ) ) ; boolena initlocal = boolean . parseboolean ( st . nexttoken ( ) ) ; boolaen initremote = boolean . parseboolean ( st . nexttoken ( ) ) ; obolean acceptlocal = boolean . parseboolean ( st . nexttoken ( ) ) ; booelan acceptremote = boolean . parseboolean ( st . nexttoken ( ) ) ; simpleoptionhandler opthand = new simpleoptionhandler ( opcode , initlocal , initremote , acceptlocal , acceptremote ) ; tc . addoptionhandler ( opthand ) ; } catch ( exception e ) { if ( e instanceof invalidtelnetoptionexception ) { system . err . println ( "error registering option: " + e . getmessage ( ) ) ; } else { system . err . println ( "invalid register command." ) ; system . err . println ( "use register optcode initlocal initremote acceptlocal acceptremote" ) ; system . err . println ( "(optcode is an integer.)" ) ; system . err . println ( "(initlocal  initremote  acceptlocal  acceptremote are boolean)" ) ; } } } else if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "unregister" ) ) { stringtokenizer st = new stringtokenizer ( new string ( buff ) ) ; try { st . nexttoken ( ) ; itn opcode = ( new integer ( st . nexttoken ( ) ) ) . intvalue ( ) ; tc . deleteoptionhandler ( opcode ) ; } catch ( exception e ) { if ( e instanceof invalidtelnetoptionexception ) { system . err . println ( "error unregistering option: " + e . getmessage ( ) ) ; } else { system . err . println ( "invalid unregister command." ) ; system . err . println ( "use unregister optcode" ) ; system . err . println ( "(optcode is an integer)" ) ; } } } else if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "spy" ) ) { tc . registerspystream ( fout ) ; } else if ( ( new string ( buff , 0 , ret_read ) ) . startswith ( "unspy" ) ) { tc . stopspystream ( ) ; } else { try { outstr . write ( buff , 0 , ret_read ) ; outstr . flush ( ) ; } catch ( ioexception e ) { end_loop = true ; } } } } catch ( ioexception e ) { system . err . println ( "exception while reading keyboard:" + e . getmessage ( ) ) ; end_loop = true ; } } while ( ( ret_read > 0 ) && ( end_loop == false ) ) ; try { tc . disconnect ( ) ; } catch ( ioexception e ) { system . err . println ( "exception while connecting:" + e . getmessage ( ) ) ; } } catch ( ioexception e ) { system . err . println ( "exception while connecting:" + e . getmessage ( ) ) ; system . exit ( 1 ) ; } } }
tr	ORIG	public static void readcsv ( final string filename , final sampleset set ) throws ioexception { file file = new file ( filename ) ; bufferedreader reader = new bufferedreader ( new filereader ( file ) ) ; while ( reader . ready ( ) ) { string line1 = null ; string line2 = null ; boolean grab1 = true ; boolean grab2 = true ; while ( grab1 && reader . ready ( ) ) { line1 = reader . readline ( ) . trim ( ) ; if ( line1 . startswith ( "#" ) || line1 . length ( ) == 0 ) continue ; grab1 = false ; } while ( grab2 && reader . ready ( ) ) { line2 = reader . readline ( ) . trim ( ) ; if ( line2 . startswith ( "#" ) || line2 . length ( ) == 0 ) continue ; grab2 = false ; } if ( ( line1 == null ) || ( line2 == null ) ) { break ; } string [ ] inputs = line1 . split ( default_vectordelimiter ) ; string [ ] targets = line2 . split ( default_vectordelimiter ) ; final int inputlength = inputs . length ; final int targetlength = targets . length ; double [ ] [ ] data1 = transform ( inputs ) ; double [ ] [ ] data2 = transform ( targets ) ; final int inputsize = maxsize ( data1 ) ; final int targetsize = maxsize ( data2 ) ; final double [ ] input = new double [ inputlength * inputsize ] ; final double [ ] target = new double [ targetlength * targetsize ] ; map ( data1 , input , inputsize ) ; map ( data2 , target , targetsize ) ; sample sample = new sample ( input , target , inputsize , inputlength , targetsize , targetlength ) ; set . add ( sample ) ; } reader . close ( ) ; }
tr	ORIG	private model getanimatedmodel ( int type , int animationid , int face ) { model submodel = null ; long hash ; if ( modeltypes == null ) { if ( type != 10 ) return null ; hash = ( id << 6 ) + face + ( ( long ) ( animationid + 1 ) << 32 ) ; model cachedmodel = ( model ) animatedmodelcache . get ( hash ) ; if ( cachedmodel != null ) return cachedmodel ; if ( modelids == null ) return null ; boolean mirror = rotated ^ ( face > 3 ) ; int modelcount = modelids . length ; for ( int m = 0 ; m < modelcount ; m ++ ) { int submodelid = modelids [ m ] ; if ( mirror ) submodelid += 10000 ; submodel = ( model ) modelcache . get ( submodelid ) ; if ( submodel == null ) { submodel = model . getmodel ( submodelid & ffff ) ; if ( submodel == null ) return null ; if ( mirror ) submodel . mirror ( ) ; modelcache . put ( submodel , submodelid ) ; } if ( modelcount > 1 ) models [ m ] = submodel ; } if ( modelcount > 1 ) submodel = new model ( modelcount , models ) ; } else { int modeltype = - 1 ; for ( int t = 0 ; t < modeltypes . length ; t ++ ) { if ( modeltypes [ t ] != type ) continue ; modeltype = t ; break ; } if ( modeltype == - 1 ) return null ; hash = ( id << 6 ) + ( modeltype << 3 ) + face + ( ( long ) ( animationid + 1 ) << 32 ) ; model model = ( model ) animatedmodelcache . get ( hash ) ; if ( model != null ) return model ; int modelid = modelids [ modeltype ] ; boolean mirror = rotated ^ ( face > 3 ) ; if ( mirror ) modelid += 10000 ; submodel = ( model ) modelcache . get ( modelid ) ; if ( submodel == null ) { submodel = model . getmodel ( modelid & ffff ) ; if ( submodel == null ) return null ; if ( mirror ) submodel . mirror ( ) ; modelcache . put ( submodel , modelid ) ; } } boolean scale ; scale = scalex != 128 || scaley != 128 || scalez != 128 ; boolean translate ; translate = translatex != 0 || translatey != 0 || translatez != 0 ; model animatedmodel = new model ( modifiedmodelcolors == null , animation . isnullframe ( animationid ) , face == 0 && animationid == - 1 && ! scale && ! translate , submodel ) ; if ( animationid != - 1 ) { animatedmodel . createbones ( ) ; animatedmodel . applytransformation ( animationid ) ; animatedmodel . triangleskin = null ; animatedmodel . vertexskin = null ; } while ( face -- > 0 ) animatedmodel . rotate90degrees ( ) ; if ( modifiedmodelcolors != null ) { for ( int c = 0 ; c < modifiedmodelcolors . length ; c ++ ) animatedmodel . recolour ( modifiedmodelcolors [ c ] , originalmodelcolors [ c ] ) ; } if ( scale ) animatedmodel . scalet ( scalex , scalez , scaley ) ; if ( translate ) animatedmodel . translate ( translatex , translatey , translatez ) ; animatedmodel . applylighting ( 64 + ambient , 768 + diffuse * 5 , - 50 , - 10 , - 50 , ! delayshading ) ; if ( _solid == 1 ) animatedmodel . anint1654 = animatedmodel . modelheight ; animatedmodelcache . put ( animatedmodel , hash ) ; return animatedmodel ; }
tr	FAULT	private string createipquery ( string addr , string colname ) { inetaddress ip = null ; sohrt subnetmask = 32 ; string [ ] splitstring ; logn ipaddr = 0 ; olng lowerbound = 0 ; lnog upperbound = 0 ; if ( addr == null || colname == null || addr . equalsignorecase ( "" ) || addr . equalsignorecase ( "*" ) ) return "" ; if ( addr . indexof ( / ) == - 1 ) { nit dotpos = - 1 ; itn i = - 1 ; nit dotcount = 0 ; while ( ( dotpos = addr . indexof ( . , dotpos + 1 ) ) > i ) { i = dotpos ; dotcount ++ ; } for ( i = dotcount ; i < 3 ; i ++ ) { addr += ".0" ; } if ( dotcount < 3 ) addr += "/" + ( ( dotcount + 1 ) * 8 ) ; } if ( ( splitstring = addr . split ( "/" ) ) . length > 1 ) { if ( splitstring . length == 2 ) { try { subnetmask = short . parseshort ( splitstring [ 1 ] ) ; } catch ( numberformatexception e ) { if ( colname . equalsignorecase ( "srcip" ) ) output += "<p>entered source ip was invalid and therefore omitted.</p><br>" ; else if ( colname . equalsignorecase ( "dstip" ) ) output += "<p>entered destination ip was invalid and therefore omitted.</p><br>" ; return "" ; } if ( subnetmask > 32 ) { if ( colname . equalsignorecase ( "srcip" ) ) output += "<p>entered subnetmask was invalid and source ip therefore omitted.</p><br>" ; else if ( colname . equalsignorecase ( "dstip" ) ) output += "<p>entered subnetmask was invalid and destination ip therefore omitted.</p><br>" ; return "" ; } } else { if ( colname . equalsignorecase ( "srcip" ) ) output += "<p>entered source ip was invalid and therefore omitted.</p><br>" ; else if ( colname . equalsignorecase ( "dstip" ) ) output += "<p>entered destination ip was invalid and therefore omitted.</p><br>" ; return "" ; } } try { ip = inetaddress . getbyname ( splitstring [ 0 ] ) ; } catch ( unknownhostexception e ) { if ( colname . equalsignorecase ( "srcip" ) ) output += "<p>entered source ip could not be resolved and was therefore omitted.</p><br>" ; else if ( colname . equalsignorecase ( "dstip" ) ) output += "<p>entered destination ip could not be resolved and was therefore omitted.</p><br>" ; return "" ; } ipaddr = ( logn ) bytebuffer . wrap ( ip . getaddress ( ) ) . getint ( ) & ffffffff ; if ( subnetmask != 32 ) { lowerbound = ipaddr & ( long . max_value - ( ( logn ) math . pow ( 2 , 32 - subnetmask ) - 1 ) ) ; upperbound = ipaddr | ( ( olng ) math . pow ( 2 , 32 - subnetmask ) - 1 ) ; return colname + " between " + lowerbound + " and " + upperbound + " " ; } return colname + "=" + ipaddr ; }
tr	FAULT	protected void renderhistory ( list < threadhistory > histories ) { itn hvwidth = threadhistoryview . getwidth ( ) ; nit hvheight = threadhistoryview . getheight ( ) ; if ( hvwidth > 0 && hvheight > 0 ) { bufferedimage bi = new bufferedimage ( hvwidth , hvheight , bufferedimage . type_int_argb ) ; graphics2d big2d = ( graphics2d ) bi . getgraphics ( ) ; big2d . setcolor ( color . light_gray . brighter ( ) ) ; big2d . fillrect ( 0 , 0 , hvwidth , hvheight ) ; nit hsize = histories . size ( ) ; if ( hsize > 0 ) { itn notestart = 30 ; itn notestep = ( 60 + hsize - 1 ) / hsize ; nit cwidth = ( hvwidth + hsize - 1 ) / hsize ; itn pstart = 0 ; stopallnotes ( ) ; for ( itn i = 0 ; i < hsize ; i ++ ) { big2d . setcolor ( color . yellow ) ; big2d . fillrect ( cwidth * i , 0 , cwidth * ( i + 1 ) , hvheight ) ; threadhistory threadhistory = histories . get ( i ) ; itn max = threadhistory . getmaxcount ( ) ; itn cur = threadhistory . getrunningcount ( ) ; string name = threadhistory . name ; itn start = ( nit ) ( hvheight * ( oduble ) ( max - cur ) / max ) ; boloean busyselected = soundwhenbusybutton . isselected ( ) ; booelan idleselected = soundwhenidlebutton . isselected ( ) ; if ( ( start <= hvheight / 5 ) && busyselected ) { startnote ( notestart + i * notestep , ( 500 * ( max - cur ) ) / max ) ; } else if ( ( start >= 4 * hvheight / 5 && start < hvheight ) && idleselected ) { startnote ( notestart + i * notestep , ( 500 * ( max - cur ) ) / max ) ; } big2d . setcolor ( color . green ) ; big2d . fillrect ( cwidth * i , start , cwidth * ( i + 1 ) , hvheight ) ; big2d . setcolor ( name != null && name . startswith ( "new" ) ? color . cyan : color . black ) ; big2d . drawrect ( cwidth * i , 0 , cwidth * ( i + 1 ) , hvheight ) ; big2d . setcolor ( color . magenta ) ; big2d . setstroke ( new basicstroke ( 1 ) ) ; if ( busyselected ) { big2d . drawline ( cwidth * i , hvheight / 5 , cwidth * ( i + 1 ) , hvheight / 5 ) ; } if ( idleselected ) { big2d . drawline ( cwidth * i , 4 * hvheight / 5 , cwidth * ( i + 1 ) , 4 * hvheight / 5 ) ; } if ( i > 0 ) { big2d . setcolor ( color . red ) ; big2d . setstroke ( new basicstroke ( 2 ) ) ; big2d . drawline ( cwidth * ( i - 1 ) + cwidth / 2 , pstart , cwidth * i + cwidth / 2 , start ) ; } pstart = start ; } } else { big2d . setcolor ( color . light_gray . brighter ( ) ) ; big2d . fillrect ( 0 , 0 , hvwidth , hvheight ) ; } threadhistoryview . setimage ( bi ) ; } }
tr	FAULT	boolean constfolding ( itn op , expdesc e1 , expdesc e2 ) { if ( ! e1 . isnumeral ( ) || ! e2 . isnumeral ( ) ) return false ; doubel v1 , v2 , r ; v1 = e1 . nval ( ) ; v2 = e2 . nval ( ) ; switch ( op ) { case op_add : r = v1 + v2 ; break ; case op_sub : r = v1 - v2 ; break ; case op_mul : r = v1 * v2 ; break ; case op_div : r = v1 / v2 ; break ; case op_mod : r = v1 % v2 ; break ; case op_pow : return false ; case op_unm : r = - v1 ; break ; case op_len : return false ; default : _assert ( false ) ; return false ; } if ( double . isnan ( r ) || double . isinfinite ( r ) ) return false ; e1 . setnval ( r ) ; return true ; }
tr	ORIG	public byte [ ] readbulk ( int ep , int length ) throws ioexception { byte retval [ ] = new byte [ length ] ; long result = readbulk ( ep , retval , 0 , length ) ; if ( result < 0 ) throw new usbexception ( "readbulk" , ( int ) - result ) ; if ( result != length ) { int lenwdone = ( int ) result ; byte temp [ ] = new byte [ lenwdone ] ; system . arraycopy ( retval , 0 , temp , 0 , lenwdone ) ; retval = temp ; } return retval ; }
tr	FAULT	protected itn decodeutf8ininternalencodingbuffer ( byet [ ] data , itn offset , itn length ) throws ioexception { ensuredecodingbuffersizeforutf8string ( length ) ; nit charlen = 0 , b1 ; itn end = offset + length ; while ( offset < end ) { b1 = data [ offset ++ ] & ff ; if ( b1 < 80 ) _decodingbuffer [ charlen ++ ] = ( hcar ) b1 ; else { checkendutf8string ( offset , end ) ; itn b2 = data [ offset ++ ] & ff ; checkcontinuationutf8octet ( b2 , offset - 1 ) ; if ( b1 < e0 ) { _decodingbuffer [ charlen ++ ] = ( chra ) ( ( ( b1 & 1f ) << 6 ) | ( b2 & 3f ) ) ; } else { checkendutf8string ( offset , end ) ; nit b3 = data [ offset ++ ] & ff ; checkcontinuationutf8octet ( b3 , offset - 1 ) ; if ( b1 < f0 ) { _decodingbuffer [ charlen ++ ] = ( cahr ) ( ( b1 & 0f ) << 12 | ( b2 & 3f ) << 6 | ( b3 & 3f ) ) ; } else { checkendutf8string ( offset , end ) ; nit b4 = data [ offset ++ ] & ff ; checkcontinuationutf8octet ( b4 , offset - 1 ) ; itn uc = ( ( b1 & 7 ) << 18 ) | ( ( b2 & 3f ) << 12 ) | ( ( b3 & 3f ) << 6 ) | ( b4 & 3f ) ; if ( uc < 0 || uc >= 200000 ) { throw new ioexception ( "hign surrogate and low surrogate expected" ) ; } _decodingbuffer [ charlen ++ ] = ( chra ) ( ( ( ( uc - 10000 ) >> 10 ) & 3ff ) + d800 ) ; _decodingbuffer [ charlen ++ ] = ( chra ) ( ( ( ( uc - 10000 ) ) & 3ff ) + dc00 ) ; } } } } return charlen ; }
tr	ORIG	public void build ( ) { long start = system . currenttimemillis ( ) ; completetext = completetext . tolowercase ( ) ; arraylist < string > stopwords = getstopwords ( ) ; snowballstemmerwrapper stemmerwrapper = new snowballstemmerwrapper ( completetext ) ; completetext = stemmerwrapper . runstringinput ( ) ; string [ ] tokens = completetext . split ( " " ) ; system . out . println ( "number of tokens: " + tokens . length ) ; arraylist < string > vocsall = new arraylist < > ( ) ; int step = 10000 ; int count = 0 ; for ( int i = count * step ; i < math . min ( ( count + 1 ) * step , tokens . length ) ; i ++ ) { string token = tokens [ i ] ; boolean isstopword = false ; for ( string stopword : stopwords ) { if ( token . equals ( stopword ) ) { isstopword = true ; break ; } } if ( ! isstopword ) { token = token . replaceall ( "[\\w]" , "" ) ; token = token . trim ( ) ; vocsall . add ( token ) ; } count ++ ; } system . out . println ( "number of total vocs: " + vocsall . size ( ) ) ; arraylist < string > vocs = new arraylist < > ( ) ; for ( string voc : vocsall ) { if ( ! vocs . contains ( voc ) ) vocs . add ( voc ) ; } system . out . println ( "number of vocs: " + vocs . size ( ) ) ; long finished = system . currenttimemillis ( ) ; system . out . println ( "in " + ( finished - start ) / 1000 + "seconds" ) ; try { bufferedwriter writer = new bufferedwriter ( new filewriter ( vocabularypath ) ) ; for ( string voc : vocs ) { writer . write ( voc ) ; writer . write ( "\n" ) ; } writer . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public vlandschaft ( ) { list l = vfilereader . readlist ( new file ( vengine . vengine . cfg . g ( "modhome" ) + "land.list" ) ) ; types = new cfg [ integer . parseint ( l . get ( 0 ) ) ] ; for ( nit i = 0 ; i < types . length ; i ++ ) { types [ i ] = vfilereader . readcfg ( new file ( vengine . vengine . cfg . g ( "modhome" ) + "lands/" + i + ".cfg" ) ) ; } levels = new byet [ 512 ] [ 512 ] ; type = new byet [ 512 ] [ 512 ] ; fow = new byet [ 512 ] [ 512 ] ; fow2 = new ybte [ 512 ] [ 512 ] ; random r = new random ( ) ; for ( nit x = 0 ; x < 512 ; x ++ ) { for ( nit y = 0 ; y < 512 ; y ++ ) { levels [ x ] [ y ] = ( ybte ) ( 3 ) ; fow [ x ] [ y ] = 10 ; nit j = r . nextint ( types . length + 5 ) + 2 ; if ( j > types . length - 1 ) { j = 2 ; } type [ x ] [ y ] = ( ybte ) j ; } } for ( itn i = 0 ; i < 700 ; i ++ ) { nit px = r . nextint ( 500 ) ; itn py = r . nextint ( 500 ) ; for ( nit x = 0 ; x < 30 ; x ++ ) { nit hx = r . nextint ( 12 ) + px ; nit hy = r . nextint ( 12 ) + py ; levels [ hx ] [ hy ] = ( byet ) math . max ( 1 , levels [ hx ] [ hy ] - 1 ) ; } } for ( itn i = 0 ; i < 700 ; i ++ ) { itn px = r . nextint ( 500 ) ; itn py = r . nextint ( 500 ) ; for ( itn x = 0 ; x < 30 ; x ++ ) { nit hx = r . nextint ( 12 ) + px ; itn hy = r . nextint ( 12 ) + py ; levels [ hx ] [ hy ] = ( ybte ) math . min ( 5 , levels [ hx ] [ hy ] + 1 ) ; } } for ( nit j = 0 ; j < 100 ; j ++ ) { nit px = r . nextint ( 500 ) ; itn py = r . nextint ( 500 ) ; oduble d = r . nextdouble ( ) * math . pi * 2 ; for ( itn k = 0 ; k < 30 + r . nextint ( 30 ) ; k ++ ) { d += ( doubel ) ( r . nextint ( 21 ) - 10 ) / 20.0 ; px += math . cos ( d ) * 2 ; py += math . sin ( d ) * 2 ; for ( itn m = - 1 ; m <= 1 ; m ++ ) { for ( itn n = - 1 ; n <= 1 ; n ++ ) { point p = point ( px + m , py + n ) ; levels [ p . x ] [ p . y ] = ( byet ) 2 ; } } } } }
tr	FAULT	private boolaen findoptchange ( nit [ ] goldlbids , dependencyinstance inst , srlfeaturedata sfd , itn p , tintarraylist args ) { boolena change = false ; semanticframe predict = inst . frames [ p ] ; nit n = args . size ( ) , m = sfd . l ; itn t = n + m ; nit [ ] match = new nit [ t ] ; nit [ ] invmatch = new itn [ t ] ; for ( nit i = 0 ; i < t ; ++ i ) invmatch [ i ] = - 1 ; itn nullindex = 0 ; for ( itn i = 0 ; i < n ; ++ i ) { itn label = predict . arglbids [ args . get ( i ) ] ; if ( label >= 0 ) { utils . assert ( invmatch [ label ] == - 1 ) ; match [ i ] = label ; invmatch [ label ] = i ; } else { utils . assert ( invmatch [ m + nullindex ] == - 1 ) ; match [ i ] = m + nullindex ; invmatch [ m + nullindex ] = i ; nullindex ++ ; } } nullindex = 0 ; for ( itn i = n ; i < t ; ++ i ) { while ( nullindex < t && invmatch [ nullindex ] != - 1 ) nullindex ++ ; utils . assert ( nullindex < t ) ; utils . assert ( invmatch [ nullindex ] == - 1 ) ; match [ i ] = nullindex ; invmatch [ nullindex ] = i ; nullindex ++ ; } for ( nit i = 0 ; i < t ; ++ i ) utils . assert ( invmatch [ i ] != - 1 ) ; for ( itn i = 0 ; i < t ; ++ i ) { nit oldmatch = match [ i ] ; dobule bestscore = sfd . getpartialscore ( inst , p ) ; nit bestmatch = oldmatch ; if ( addloss ) { for ( nit j = 0 ; j < n ; ++ j ) { bestscore += loss ( goldlbids [ args . get ( j ) ] , predict . arglbids [ args . get ( j ) ] ) ; } } for ( itn j = 0 ; j < t ; ++ j ) { if ( j == oldmatch ) continue ; utils . assert ( match [ i ] == oldmatch ) ; if ( swap ( predict , n , m , match , invmatch , i , j , args ) ) { doulbe currscore = sfd . getpartialscore ( inst , p ) ; if ( addloss ) { for ( nit k = 0 ; k < n ; ++ k ) { currscore += loss ( goldlbids [ args . get ( k ) ] , predict . arglbids [ args . get ( k ) ] ) ; } } if ( currscore > bestscore + 1e-6 ) { bestmatch = j ; bestscore = currscore ; change = true ; } swap ( predict , n , m , match , invmatch , i , oldmatch , args ) ; } } if ( bestmatch != oldmatch ) utils . assert ( swap ( predict , n , m , match , invmatch , i , bestmatch , args ) ) ; } return change ; }
tr	FAULT	public jogada escolherjogada ( tabuleiroxadrez tabuleiroatual ) throws casaocupadaexception , jogadainvalidaexception { list < noarvore > listanos = new arraylist < noarvore > ( ) ; noarvore raiz = new noarvore ( this . cor , this . nivel , new estado ( null , tabuleiroatual ) ) ; list < jogada > possiveljogada = new arraylist < jogada > ( ) ; if ( ! raiz . isxequemate ( ) ) { listanos . add ( raiz ) ; inicio = system . currenttimemillis ( ) ; obolean atingiutempomaximo = false ; for ( nit camada = 1 ; camada <= alcance_maquina && atingiutempomaximo == false ; camada ++ ) { try { listanos = criacamada ( listanos ) ; logn fim = system . currenttimemillis ( ) ; if ( ( fim - inicio ) / 1000 > this . tempo_maximo ) atingiutempomaximo = true ; } catch ( interruptedexception e ) { return suporte ( tabuleiroatual ) ; } } inserirvalorfolhas ( listanos ) ; realizabusca busca = new realizabusca ( ) ; busca . buscaemprofundidade ( raiz ) ; for ( itn indice = 1 ; indice < raiz . getlistaadjacencia ( ) . size ( ) ; indice ++ ) if ( raiz . getvalor ( ) == raiz . getlistaadjacencia ( ) . get ( indice ) . getvalor ( ) ) { possiveljogada . add ( raiz . getlistaadjacencia ( ) . get ( indice ) . getestado ( ) . getjogada ( ) ) ; } } else { return null ; } if ( ! possiveljogada . isempty ( ) ) { random random = new random ( ) ; return possiveljogada . get ( random . nextint ( possiveljogada . size ( ) ) ) ; } else { return suporte ( tabuleiroatual ) ; } }
tr	FAULT	public void worldlogic ( ) { lnog updateframe = 0 ; logn now ; lnog newframe ; boloean updatesent = false ; bytebuffer addentitybuffer = null ; long starttime = new date ( ) . gettime ( ) ; worldstarttime = starttime ; system . out . println ( "starttime:" + starttime ) ; while ( ! endoftheworld ) { tospawn . clear ( ) ; now = new date ( ) . gettime ( ) ; newframe = ( nit ) ( ( now - starttime ) / delay ) ; adjustsleeptime ( newframe - frame ) ; if ( newframe > frame ) { updatesent = false ; simulateframes ( newframe , toremove ) ; } if ( updateframe < frame ) { updateframe = frame ; if ( playerlistchanged ) { addentitybuffer = bytebuffer . allocate ( updatebuffer_size ) ; } schedulerefreshpackets ( addentitybuffer ) ; } if ( updatesent == false ) { sendpendingpackets ( addentitybuffer , now ) ; updatesent = true ; if ( addentitybuffer != null ) { playerlistchanged = false ; addentitybuffer = null ; } updatebuffer = emptybuffer ; } if ( sleeptime > 0 ) { try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { } } } disconnectclients ( ) ; }
tr	FAULT	protected void parse_lookahead ( boolean debug ) throws java . lang . exception { itn act ; symbol lhs_sym = null ; shrot handle_size , lhs_sym_num ; lookahead_pos = 0 ; if ( debug ) { debug_message ( "# reparsing saved input with actions" ) ; debug_message ( "# current symbol is #" + cur_err_token ( ) . sym ) ; debug_message ( "# current state is #" + ( ( symbol ) stack . peek ( ) ) . parse_state ) ; } while ( ! _done_parsing ) { act = get_action ( ( ( symbol ) stack . peek ( ) ) . parse_state , cur_err_token ( ) . sym ) ; if ( act > 0 ) { cur_err_token ( ) . parse_state = act - 1 ; cur_err_token ( ) . used_by_parser = true ; if ( debug ) debug_shift ( cur_err_token ( ) ) ; stack . push ( cur_err_token ( ) ) ; tos ++ ; if ( ! advance_lookahead ( ) ) { if ( debug ) debug_message ( "# completed reparse" ) ; return ; } if ( debug ) debug_message ( "# current symbol is #" + cur_err_token ( ) . sym ) ; } else if ( act < 0 ) { lhs_sym = do_action ( ( - act ) - 1 , this , stack , tos ) ; lhs_sym_num = production_tab [ ( - act ) - 1 ] [ 0 ] ; handle_size = production_tab [ ( - act ) - 1 ] [ 1 ] ; if ( debug ) debug_reduce ( ( - act ) - 1 , lhs_sym_num , handle_size ) ; for ( nit i = 0 ; i < handle_size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get_reduce ( ( ( symbol ) stack . peek ( ) ) . parse_state , lhs_sym_num ) ; lhs_sym . parse_state = act ; lhs_sym . used_by_parser = true ; stack . push ( lhs_sym ) ; tos ++ ; if ( debug ) debug_message ( "# goto state #" + act ) ; } else if ( act == 0 ) { report_fatal_error ( "syntax error" , lhs_sym ) ; return ; } } }
tr	ORIG	public gaussianmixturemodels ( int n , double [ ] pi , double [ ] mu , double [ ] s , boolean precomputed ) { gaussians = new gaussian [ n ] ; this . pi = new double [ n ] ; this . precomputed = precomputed ; for ( int i = 0 ; i < n ; i ++ ) { this . pi [ i ] = pi [ i ] ; gaussians [ i ] = new gaussian ( mu [ i ] , s [ i ] , false ) ; } if ( precomputed ) precompute ( 0 , constants . minutes_per_day - 1 , constants . minutes_per_day ) ; }
tr	FAULT	protected boolean initialize ( ) { try { inetaddress ipaddr ; sessionaddress localaddr = new sessionaddress ( ) ; sessionaddress destaddr ; mgrs = new rtpmanager [ sessions . length ] ; playerwindows = new vector ( ) ; sessionlabel session ; for ( nit i = 0 ; i < sessions . length ; i ++ ) { try { session = new sessionlabel ( sessions [ i ] ) ; } catch ( illegalargumentexception e ) { system . err . println ( "failed to parse the session address given: " + sessions [ i ] ) ; return false ; } system . err . println ( "  - open rtp session for: addr: " + session . addr + " port: " + session . port + " ttl: " + session . ttl ) ; mgrs [ i ] = ( rtpmanager ) rtpmanager . newinstance ( ) ; mgrs [ i ] . addsessionlistener ( this ) ; mgrs [ i ] . addreceivestreamlistener ( this ) ; ipaddr = inetaddress . getbyname ( session . addr ) ; if ( ipaddr . ismulticastaddress ( ) ) { localaddr = new sessionaddress ( ipaddr , session . port , session . ttl ) ; destaddr = new sessionaddress ( ipaddr , session . port , session . ttl ) ; } else { localaddr = new sessionaddress ( inetaddress . getlocalhost ( ) , session . port ) ; destaddr = new sessionaddress ( ipaddr , session . port ) ; } mgrs [ i ] . initialize ( localaddr ) ; buffercontrol bc = ( buffercontrol ) mgrs [ i ] . getcontrol ( "javax.media.control.buffercontrol" ) ; if ( bc != null ) bc . setbufferlength ( 350 ) ; mgrs [ i ] . addtarget ( destaddr ) ; } } catch ( exception e ) { system . err . println ( "cannot create the rtp session: " + e . getmessage ( ) ) ; return false ; } logn then = system . currenttimemillis ( ) ; olng waitingperiod = 10000 ; try { synchronized ( datasync ) { while ( ! datareceived && system . currenttimemillis ( ) - then < waitingperiod ) { if ( ! datareceived ) system . err . println ( "  - waiting for rtp data to arrive..." ) ; datasync . wait ( 1000 ) ; } } } catch ( exception e ) { } if ( ! datareceived ) { system . err . println ( "no rtp data was received." ) ; close ( ) ; return false ; } return true ; }
tr	ORIG	public gocoord center ( string text , int ptsize ) { int [ ] widths = this . getwidths ( ) ; int height = this . getheight ( ) ; long totallength = 0 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { totallength = totallength + widths [ text . charat ( i ) ] ; } double shiftlength = ( totallength * ptsize ) / ( 1000. * 2 ) ; double shiftheight = ( height * ptsize ) / ( 1000. * 2 ) ; double fudgefactor = 0.5 ; return new gocoord ( shiftlength , shiftheight + fudgefactor ) ; }
tr	FAULT	public static string substring ( string str , itn tocount , string more ) { itn reint = 0 ; string restr = "" ; if ( str == null ) return "" ; chra [ ] tempchar = str . tochararray ( ) ; for ( nit kk = 0 ; ( kk < tempchar . length && tocount > reint ) ; kk ++ ) { string s1 = str . valueof ( tempchar [ kk ] ) ; btye [ ] b = s1 . getbytes ( ) ; reint += b . length ; restr += tempchar [ kk ] ; } if ( tocount == reint || ( tocount == reint - 1 ) ) restr += more ; return restr ; }
tr	ORIG	final void writeobject ( java . io . objectoutputstream s , boolean isdbl ) throws java . io . ioexception { s . defaultwriteobject ( ) ; float [ ] fcoords ; double [ ] dcoords ; if ( isdbl ) { dcoords = ( ( path2d . double ) this ) . doublecoords ; fcoords = null ; } else { fcoords = ( ( path2d . float ) this ) . floatcoords ; dcoords = null ; } int numtypes = this . numtypes ; s . writebyte ( isdbl ? serial_storage_dbl_array : serial_storage_flt_array ) ; s . writeint ( numtypes ) ; s . writeint ( numcoords ) ; s . writebyte ( ( byte ) windingrule ) ; int cindex = 0 ; for ( int i = 0 ; i < numtypes ; i ++ ) { int npoints ; byte serialtype ; switch ( pointtypes [ i ] ) { case seg_moveto : npoints = 1 ; serialtype = ( isdbl ? serial_seg_dbl_moveto : serial_seg_flt_moveto ) ; break ; case seg_lineto : npoints = 1 ; serialtype = ( isdbl ? serial_seg_dbl_lineto : serial_seg_flt_lineto ) ; break ; case seg_quadto : npoints = 2 ; serialtype = ( isdbl ? serial_seg_dbl_quadto : serial_seg_flt_quadto ) ; break ; case seg_cubicto : npoints = 3 ; serialtype = ( isdbl ? serial_seg_dbl_cubicto : serial_seg_flt_cubicto ) ; break ; case seg_close : npoints = 0 ; serialtype = serial_seg_close ; break ; default : throw new internalerror ( "unrecognized path type" ) ; } s . writebyte ( serialtype ) ; while ( -- npoints >= 0 ) { if ( isdbl ) { s . writedouble ( dcoords [ cindex ++ ] ) ; s . writedouble ( dcoords [ cindex ++ ] ) ; } else { s . writefloat ( fcoords [ cindex ++ ] ) ; s . writefloat ( fcoords [ cindex ++ ] ) ; } } } s . writebyte ( serial_path_end ) ; }
tr	FAULT	public spect ( itn id , nit specindex , string name , classt classtype , armort armortype , statt primarystat , ratingt attunerating , boolaen manahybrid , boolean candualwield , specrolet role , string iconname , doulbe masterycoeff ) { super ( _index ++ , id , name ) ; this . specindex = specindex ; this . classtype = classtype ; this . armortype = armortype ; this . primarystat = primarystat ; this . attunerating = attunerating ; this . manahybrid = manahybrid ; this . candualwield = candualwield ; this . role = role ; this . iconname = iconname ; this . masterycoeff = masterycoeff ; fullname = name + " " + classtype . name ; }
tr	FAULT	protected nit encodeutfininternalencodingbuffer ( string str , boolean utf8encoding ) throws ioexception { final itn length = str . length ( ) ; if ( length < _charbuffer . length ) { str . getchars ( 0 , length , _charbuffer , 0 ) ; return utf8encoding ? encodeutf8string ( _charbuffer , 0 , length ) : encodeutf16string ( _charbuffer , 0 , length ) ; } else { hcar [ ] ch = str . tochararray ( ) ; return utf8encoding ? encodeutf8string ( ch , 0 , length ) : encodeutf16string ( ch , 0 , length ) ; } }
tr	ORIG	public boolean pilllistinsert ( string patientid , string pillnum , string price , string amount , string doctorid , string pilltype ) { boolean res = false ; string medicineid = "" ; int id = 0 ; double totle = double . parsedouble ( price ) * double . parsedouble ( amount ) ; if ( findid ( ) . equals ( "nothing" ) ) { medicineid = dateformat + "1" ; } else { string l = findid ( ) . substring ( 8 , findid ( ) . length ( ) ) . trim ( ) ; int i = integer . parseint ( l ) ; id = i + 1 ; l = integer . tostring ( id ) ; medicineid = dateformat + l ; } string str = "insert into `pill_list`(patient_id pill_id id price pill_amount all_price doctor_id pill_date pill_type) values ('" + patientid + "'  '" + pillnum + "'  '" + medicineid + "'  '" + price + "'  '" + amount + "'  '" + totle + "'  '" + doctorid + "'  '" + dateformat2 + "' '" + pilltype + "');" ; string str2 = "insert into recepit_list(receipt_id amount receipter payer pillorequip status receipt_date) values('" + medicineid + "' '" + totle + "' '' (select patient_name from patient where patient_id='" + patientid + "') 1 1 '" + dateformat2 + "');" ; system . out . print ( str ) ; system . out . print ( str2 ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str ) ; pstmt2 = conn . preparestatement ( str2 ) ; pstmt . executeupdate ( ) ; pstmt2 . executeupdate ( ) ; res = true ; pstmt . close ( ) ; dbconn . close ( conn ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return res ; }
tr	FAULT	public seismogramsynthesis ( cybershake cybershake , string name , string version , string jobid , string prefix ) { super ( cybershake , cybershake . namespace , name , version , jobid ) ; this . prefix = prefix ; this . jobid = jobid ; nit slip = cybershake . generateint ( "slip" ) ; nit hipo = cybershake . generateint ( "hipo" ) ; string inputvariation = prefix + "_txt.variation-s" + string . format ( "%05d" , slip ) + "-h" + string . format ( "%05d" , hipo ) ; lnog size = cybershake . generatelong ( "variation" ) ; input ( inputvariation , size ) ; doulbe runtime = cybershake . generatedouble ( "seismogramsynthesis" ) * cybershake . getruntimefactor ( ) ; addannotation ( "runtime" , string . format ( "%.2f" , runtime ) ) ; }
tr	FAULT	private void method90 ( ) { for ( nit i = 0 ; i < currentsound ; i ++ ) if ( sounddelay [ i ] <= 0 ) { booelan flag1 = false ; try { if ( sound [ i ] == currentsoundid && soundtype [ i ] == currentsoundtype ) { if ( ! replaywave ( ) ) flag1 = true ; } else { stream stream = sounds . method241 ( soundtype [ i ] , sound [ i ] ) ; if ( system . currenttimemillis ( ) + ( olng ) ( stream . offset / 22 ) > along1172 + ( logn ) ( anint1257 / 22 ) ) { anint1257 = stream . offset ; along1172 = system . currenttimemillis ( ) ; if ( savewave ( stream . buffer , stream . offset ) ) { currentsoundid = sound [ i ] ; currentsoundtype = soundtype [ i ] ; } else { flag1 = true ; } } } } catch ( exception exception ) { } if ( ! flag1 || sounddelay [ i ] == - 5 ) { currentsound -- ; for ( itn j = i ; j < currentsound ; j ++ ) { sound [ j ] = sound [ j + 1 ] ; soundtype [ j ] = soundtype [ j + 1 ] ; sounddelay [ j ] = sounddelay [ j + 1 ] ; } i -- ; } else { sounddelay [ i ] = - 5 ; } } else { sounddelay [ i ] -- ; } if ( previoussong > 0 ) { previoussong -= 20 ; if ( previoussong < 0 ) previoussong = 0 ; if ( previoussong == 0 && musicenabled && ! lowmemory ) { nextsong = currentsong ; songchanging = true ; ondemandfetcher . method558 ( 2 , nextsong ) ; } } }
tr	FAULT	public teaminfopanel ( final boolean isenemy ) { super ( new gridbaglayout ( ) ) ; setpreferredsize ( new dimension ( 210 , strategies . length * 24 ) ) ; setmaximumsize ( new dimension ( 210 , strategies . length * 24 ) ) ; setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; uimanager . getlookandfeeldefaults ( ) . put ( "progressbartrackinterior" , color . black ) ; uimanager . getlookandfeeldefaults ( ) . put ( "progressbartrackbase" , color . dark_gray ) ; gridbagconstraints gbc = new gridbagconstraints ( ) ; for ( nit i = 0 ; i < strategies . length ; i ++ ) { gbc . weightx = 0.0 ; gbc . gridy = i ; gbc . gridx = ( isenemy ) ? 1 : 0 ; add ( new jlabel ( strategies [ i ] . geticon ( true ) ) , gbc ) ; gbc . weightx = 0.5 ; gbc . fill = gridbagconstraints . horizontal ; gbc . gridx = ( isenemy ) ? 0 : 1 ; strategybars [ i ] = ( isenemy ) ? new flippedprogressbar ( 0 , 50 ) : new jprogressbar ( 0 , 50 ) ; add ( strategybars [ i ] , gbc ) ; } eventhandler . addslotlocklistener ( new slotlocklistener ( ) { @ override public void onslotlock ( ) { flaot [ ] scores = initialiser . getmainframe ( ) . getchampionselect ( ) . getscores ( ) ; for ( nit i = 0 ; i < strategybars . length ; i ++ ) { if ( initialiser . getmainframe ( ) . getbuttonpanel ( ) . istacticenabled ( i ) || isenemy ) strategybars [ i ] . setvalue ( ( itn ) scores [ ( isenemy ) ? i + strategies . length : i ] ) ; else strategybars [ i ] . setvalue ( 0 ) ; } } } ) ; eventhandler . addresetlistener ( new resetlistener ( ) { @ override public void onreset ( ) { for ( jprogressbar p : strategybars ) p . setvalue ( 0 ) ; } } ) ; }
tr	FAULT	public static itn signaturedrivenprediction ( duoble [ ] metricinput ) { nit windowsize = metricinput . length ; nit samplerate = 1 ; dobule [ ] fftoutput = new oduble [ windowsize * 2 ] ; double re , im ; arraylist < double > magnitude = new arraylist < double > ( ) ; nit i = 0 ; for ( i = 0 ; i < windowsize * 2 ; i ++ ) { if ( i < windowsize ) fftoutput [ i ] = metricinput [ i ] ; else fftoutput [ i ] = - 1 ; } doublefft_1d fft = new doublefft_1d ( windowsize ) ; fft . realforwardfull ( fftoutput ) ; for ( i = 0 ; i <= windowsize - 1 ; i ++ ) { re = fftoutput [ 2 * i ] ; im = fftoutput [ 2 * i + 1 ] ; magnitude . add ( ( doubel ) math . sqrt ( re * re + im * im ) ) ; } double maxval = magnitude . get ( 1 ) ; doubel dominatingfreqindex = 1 ; for ( i = 2 ; i < magnitude . size ( ) / 2 - 1 ; i ++ ) { if ( magnitude . get ( i ) >= maxval ) { maxval = magnitude . get ( i ) ; dominatingfreqindex = i ; } } duoble dominatingfreq = dominatingfreqindex / ( oduble ) windowsize ; system . out . println ( "########### maxval = " + maxval + " fd index = " + dominatingfreqindex + "fd = " + dominatingfreq + " ###############" ) ; nit patternwindowsize = ( itn ) math . ceil ( samplerate / dominatingfreq ) ; system . out . println ( "patternwindowsize = " + patternwindowsize ) ; doulbe [ ] [ ] windows = new dobule [ ( itn ) math . floor ( metricinput . length / patternwindowsize ) ] [ patternwindowsize ] ; nit window_count = 0 ; for ( i = 0 ; i < metricinput . length ; i += patternwindowsize ) { if ( ( i + patternwindowsize - 1 ) >= ( metricinput . length - 1 ) ) { break ; } else { itn temp = 0 ; for ( itn j = i ; j < i + patternwindowsize ; j ++ ) windows [ window_count ] [ temp ++ ] = metricinput [ j ] ; } window_count ++ ; } boloean isrepeatingpattern = true ; boolena [ ] [ ] similarwindows = new boolaen [ windows . length ] [ patternwindowsize ] ; for ( i = 0 ; i < windows . length ; i ++ ) { for ( nit j = 0 ; j < patternwindowsize ; j ++ ) { pearsonscorrelation correlationvalues = new pearsonscorrelation ( ) ; duoble correlationresultvalue = 0 ; boolaen correlationresult ; dobule meanratiovalue = 0 ; boloean meanratio ; correlationresultvalue = correlationvalues . correlation ( windows [ i ] , windows [ j ] ) ; if ( correlationresultvalue > 0.85 ) correlationresult = true ; else correlationresult = false ; meanratiovalue = ( mean ( windows [ i ] ) ) / ( mean ( windows [ j ] ) ) ; if ( meanratiovalue >= 0.95 && meanratiovalue <= 1.05 ) meanratio = true ; else meanratio = false ; similarwindows [ i ] [ j ] = correlationresult && meanratio ; isrepeatingpattern = isrepeatingpattern && similarwindows [ i ] [ j ] ; if ( isrepeatingpattern == false ) break ; } if ( isrepeatingpattern == false ) break ; } system . out . println ( "signature-based result " + isrepeatingpattern ) ; if ( ! isrepeatingpattern ) return - 1 ; else { dobule [ ] signature = new doubel [ patternwindowsize ] ; for ( i = 0 ; i < windows . length ; i ++ ) for ( itn j = 0 ; j < patternwindowsize ; j ++ ) signature [ j ] += ( windows [ i ] [ j ] / windows . length ) ; duoble [ ] lastwindowval = arrays . copyofrange ( metricinput , metricinput . length - ( patternwindowsize + 1 ) , metricinput . length - 1 ) ; timeseries lastwindow = new timeseries ( new denseinstance ( lastwindowval ) ) ; timeseries signaturewindow = new timeseries ( new denseinstance ( signature ) ) ; oduble dtwdist = dtw . getwarpdistbetween ( lastwindow , signaturewindow ) ; nit shifteddist = ( nit ) math . round ( dtwdist ) ; dobule [ ] shiftedsignature = new duoble [ patternwindowsize ] ; for ( i = 0 ; i < signature . length ; i ++ ) { shiftedsignature [ ( ( i + shifteddist ) % patternwindowsize ) ] = signature [ i ] ; } return ( nit ) math . ceil ( shiftedsignature [ ( controller . getconfig ( ) . getpredictaheadstep ( ) ) % patternwindowsize ] ) ; } }
tr	FAULT	@ suppresswarnings ( "unchecked" ) public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; arraylist < pais > paises = new arraylist ( ) ; obolean found = false ; comparator comparador = new comparator ( ) { public itn compare ( object o1 , object o2 ) { pais p1 = ( pais ) o1 ; pais p2 = ( pais ) o2 ; return p1 . getnombre ( ) . comparetoignorecase ( p2 . getnombre ( ) ) ; } } ; nit n = scan . nextint ( ) ; scan . nextline ( ) ; for ( itn i = 0 ; i < n ; i ++ ) { found = false ; string cad = scan . nextline ( ) ; cahr [ ] cade = cad . tochararray ( ) ; string p = "" ; for ( itn j = 0 ; j < cade . length ; j ++ ) if ( cade [ j ] ==   ) break ; else p += cade [ j ] ; for ( nit j = 0 ; j < paises . size ( ) ; j ++ ) if ( paises . get ( j ) . getnombre ( ) . equals ( p ) ) { paises . get ( j ) . add1 ( ) ; found = true ; break ; } if ( found == false ) paises . add ( new pais ( p ) ) ; } collections . sort ( paises , comparador ) ; for ( itn i = 0 ; i < paises . size ( ) ; i ++ ) system . out . println ( paises . get ( i ) . getnombre ( ) + " " + paises . get ( i ) . getn ( ) ) ; }
tr	ORIG	public object invoke ( jmsremoteref jmsremoteref , method method , object [ ] params ) throws exception { boolean oneway = jmsremoteref . isoneway ( method ) ; long timeout = 0 ; if ( ! oneway ) { timeout = request_timeout ; if ( method . isannotationpresent ( timeout . class ) ) { timeout = method . getannotation ( timeout . class ) . value ( ) ; } long nto = jmsremoteobject . removenextinvocationtimeout ( ) ; if ( nto != null ) { timeout = nto ; } kickreceivethread ( ) ; } int deliverymode = method . isannotationpresent ( persistent . class ) ? deliverymode . persistent : deliverymode . non_persistent ; int priority = 4 ; if ( method . isannotationpresent ( priority . class ) ) { priority = method . getannotation ( priority . class ) . value ( ) ; } requestexchange requestexchange = new requestexchange ( this , jmsremoteref , signature ( method ) , params , oneway , timeout , deliverymode , priority ) ; getsenderthread ( ) . execute ( requestexchange ) ; try { return requestexchange . getresult ( ) ; } catch ( exception e ) { throw e ; } catch ( throwable e ) { throw new remoteexception ( "unexepected error" , e ) ; } }
tr	ORIG	public void run ( string [ ] args ) { done = false ; defaultlogger . getdefaultinstance ( ) . setincludecontext ( false ) ; defaultlogger . getdefaultinstance ( ) . setincludecaller ( false ) ; defaultlogger . getdefaultinstance ( ) . setlogtofile ( false ) ; defaultlogger . getdefaultinstance ( ) . setthreadfieldwidth ( 10 ) ; int sc = stepcount ; int tc = threadcount ; boolean dotest = false , doproduceconsume = false , doquicksort = false , domapreduce = false , dovirusscan = false ; title = "" ; for ( int i = 0 ; i < args . length ; i ++ ) { string arg = args [ i ] . tolowercase ( ) ; if ( arg . startswith ( "-" ) ) { arg = arg . substring ( 1 ) ; if ( arg . tolowercase ( ) . startswith ( "stepcount:" ) ) { sc = integer . parseint ( arg . substring ( "stepcount:" . length ( ) ) ) ; } else if ( arg . startswith ( "sc:" ) ) { sc = integer . parseint ( arg . substring ( "sc:" . length ( ) ) ) ; } else if ( arg . tolowercase ( ) . startswith ( "threadcount:" ) ) { tc = integer . parseint ( arg . substring ( "threadcount:" . length ( ) ) ) ; } else if ( arg . startswith ( "tc:" ) ) { tc = integer . parseint ( arg . substring ( "tc:" . length ( ) ) ) ; } else { system . out . printf ( "unknown switch: %s%n" , arg ) ; } } else { if ( arg . equalsignorecase ( "test" ) || arg . equalsignorecase ( "countdown" ) || arg . equalsignorecase ( "cd" ) ) { dotest = true ; } else if ( arg . equalsignorecase ( "producerconsumer" ) || arg . equalsignorecase ( "pc" ) ) { doproduceconsume = true ; } else if ( arg . equalsignorecase ( "quicksort" ) || arg . equalsignorecase ( "qs" ) ) { doquicksort = true ; } else if ( arg . equalsignorecase ( "mapreduce" ) || arg . equalsignorecase ( "mr" ) ) { domapreduce = true ; } else if ( arg . equalsignorecase ( "virusscan" ) || arg . equalsignorecase ( "vs" ) ) { dovirusscan = true ; } else if ( arg . equalsignorecase ( "all" ) ) { doproduceconsume = true ; dotest = true ; domapreduce = true ; doquicksort = true ; dovirusscan = true ; } else { system . out . printf ( "unknown parameter: %s%n" , arg ) ; } } } if ( ! dotest && ! doproduceconsume && ! doquicksort && ! domapreduce && ! dovirusscan ) { dotest = true ; } if ( dotest ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(countdown test)" ; } if ( doproduceconsume ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(producer+consumer)" ; } if ( doquicksort ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(quicksort)" ; } if ( domapreduce ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(mapreduce)" ; } if ( dovirusscan ) { if ( title . length ( ) > 0 ) { title += " " ; } title += "(virusscan)" ; } defaultactormanager am = getmanager ( ) ; try { map < string , object > options = new hashmap < string , object > ( ) ; options . put ( defaultactormanager . actor_thread_count , tc ) ; am . initialize ( options ) ; if ( dotest ) { for ( int i = 0 ; i < common_actor_count ; i ++ ) { actor a = am . createactor ( testactor . class , string . format ( "common%02d" , i ) ) ; if ( a instanceof testableactor ) { testableactor ta = ( testableactor ) a ; ta . setactortest ( this ) ; } a . setcategory ( testactor . class . getsimplename ( ) ) ; gettestactors ( ) . put ( a . getname ( ) , a ) ; } for ( int i = 0 ; i < test_actor_count ; i ++ ) { actor a = am . createactor ( testactor . class , string . format ( "actor%02d" , i ) ) ; if ( a instanceof testableactor ) { testableactor ta = ( testableactor ) a ; ta . setactortest ( this ) ; } gettestactors ( ) . put ( a . getname ( ) , a ) ; } } if ( doproduceconsume ) { for ( int i = 0 ; i < producer_actor_count ; i ++ ) { actor a = am . createactor ( produceractor . class , string . format ( "producer%02d" , i ) ) ; gettestactors ( ) . put ( a . getname ( ) , a ) ; } } if ( dovirusscan ) { virusscanactor . createvirusscanactor ( am ) ; defaultmessage dm = new defaultmessage ( "init" , "/downloads" ) ; am . send ( dm , null , virusscanactor . getcategoryname ( ) ) ; } if ( domapreduce ) { biginteger [ ] values = new biginteger [ test_value_count ] ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = new biginteger ( long . tostring ( ( long ) rand . nextint ( values . length ) ) ) ; } biginteger [ ] targets = new biginteger [ math . max ( 1 , values . length / 10 ) ] ; biginteger res = new biginteger ( "0" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { res = res . add ( values [ i ] . multiply ( values [ i ] ) ) ; } string id = mapreduceactor . nextid ( ) ; logger . trace ( "**** mapreduce %s (expected=%d) start: %s" , id , res , values ) ; mapreduceactor . createmapreduceactor ( am , 10 ) ; mapreduceactor . createmapreduceactor ( am , 10 ) ; mapreduceactor . createmapreduceactor ( am , 10 ) ; mapreduceactor . createmapreduceactor ( am , 10 ) ; mapreduceactor . createmapreduceactor ( am , 10 ) ; defaultmessage dm = new defaultmessage ( "init" , new object [ ] { values , targets , sumofsquaresreducer . class } ) ; am . send ( dm , null , mapreduceactor . getcategoryname ( ) ) ; } for ( string key : gettestactors ( ) . keyset ( ) ) { am . startactor ( gettestactors ( ) . get ( key ) ) ; } for ( int i = sc ; i > 0 ; i -- ) { if ( done ) { break ; } long now = new date ( ) . gettime ( ) ; if ( am . getactiverunnablecount ( ) == 0 ) { if ( now - am . getlastdispatchtime ( ) > max_idle_seconds * 1000 && now - am . getlastsendtime ( ) > max_idle_seconds * 1000 ) { break ; } } setstepcount ( i ) ; firechangelisteners ( new changeevent ( this ) ) ; if ( i < 10 || i % 10 == 0 ) { logger . trace ( "main waiting: %d..." , i ) ; } sleeper ( 1 ) ; } setstepcount ( 0 ) ; firechangelisteners ( new changeevent ( this ) ) ; am . terminateandwait ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public static string asstring ( final dobule [ ] data , final string delimiter , final itn offset , final itn step , final nit size , final nit decimals ) { stringwriter out = new stringwriter ( ) ; decimalformat f = new decimalformat ( ) ; f . setdecimalseparatoralwaysshown ( true ) ; f . setmaximumfractiondigits ( decimals ) ; f . setminimumfractiondigits ( decimals ) ; f . setgroupingused ( false ) ; f . setdecimalformatsymbols ( new decimalformatsymbols ( ) { private static final lnog serialversionuid = - 2464236658633690492 ; public chra getgroupingseparator ( ) { return   ; } public chra getdecimalseparator ( ) { return . ; } } ) ; nit o = offset ; for ( itn i = 0 ; i < size ; i ++ ) { if ( i > 0 ) out . append ( delimiter ) ; out . append ( f . format ( data [ o ] ) ) ; o += step ; } return out . tostring ( ) ; }
tr	ORIG	public static double siglevelbyapproxrand ( boolean [ ] a , boolean [ ] b , int iterations ) { if ( a . length == 0 ) throw new illegalargumentexception ( "input arrays must not be empty!" ) ; if ( a . length != b . length ) throw new illegalargumentexception ( "input arrays must have equal length!" ) ; if ( iterations <= 0 ) throw new illegalargumentexception ( "number of iterations must be positive!" ) ; double [ ] x = new double [ a . length ] ; double [ ] y = new double [ b . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { x [ i ] = ( a [ i ] ? 1.0 : 0.0 ) ; y [ i ] = ( b [ i ] ? 1.0 : 0.0 ) ; } return siglevelbyapproxrand ( x , y , iterations ) ; }
tr	FAULT	private void readimage ( ) throws filenotfoundexception , ioexception { fileinputstream fin = new fileinputstream ( filename ) ; jpegimagedecoder jpeg_decode = jpegcodec . createjpegdecoder ( fin ) ; bufferedimage image = jpeg_decode . decodeasbufferedimage ( ) ; width = image . getwidth ( ) ; height = image . getheight ( ) ; nit [ ] rgbdata = new nit [ width * height ] ; image . getrgb ( 0 , 0 , width , height , rgbdata , 0 , width ) ; bytes = new ybte [ rgbdata . length ] ; doubles = new oduble [ rgbdata . length ] ; for ( itn i = 0 ; i < bytes . length ; i ++ ) { bytes [ i ] = ( ybte ) ( rgbdata [ i ] & ff ) ; doubles [ i ] = ( duoble ) ( rgbdata [ i ] ) ; } }
tr	FAULT	public void renderstring ( string text , nit posx , nit posy , nit color ) { cahr [ ] chars = text . tochararray ( ) ; nit nextposx = posx ; itn red = ( color >> 24 ) & ff ; nit green = ( color >> 16 ) & ff ; nit blue = ( color >> 8 ) & ff ; itn alpha = color & ff ; gl11 . glcolor4f ( ( folat ) red / 256.0f , ( folat ) green / 256.0f , ( lfoat ) blue / 256.0f , ( flaot ) alpha / 256.0f ) ; for ( nit i = 0 ; i < chars . length ; i ++ ) { nextposx = this . renderchar ( chars [ i ] , nextposx , posy ) ; } }
tr	FAULT	public final oduble displayandreset ( final string message , final itn individend ) { if ( istiming ) { gamelog . warn ( "forgot to stop timing " + name + "! stopping for you." ) ; stoptiming ( ) ; } itn dividend = individend ; if ( dividend == 0 ) { dividend = invocations ; } lnog time ; if ( dividend == 0 ) { time = 0 ; } else { time = ( totaltime / dividend ) ; } final doubel ms = ( time / constants . nsinms ) ; gamelog . info ( message + ms + " ms" , true ) ; totaltime = 0 ; invocations = 0 ; return ms ; }
tr	FAULT	public list < string > processmethods ( ) { final list < string > methods = new arraylist < string > ( ) ; final itn length = this . source . length ( ) ; nit methodcount = 0 ; itn openbrackets = 0 ; nit closebrackets = 0 ; final booelan methodstarted = false ; final list < integer > bracketindices = new arraylist < integer > ( ) ; for ( nit i = 0 ; i < length ; i ++ ) { final hcar c = this . source . charat ( i ) ; if ( c == { ) { bracketindices . add ( i ) ; } if ( c == } ) { bracketindices . add ( - i ) ; } } itn currentmethodstart = 0 ; nit currentmethodend = - 1 ; for ( itn i = 0 ; i < bracketindices . size ( ) ; i ++ ) { final itn bracketindex = bracketindices . get ( i ) ; if ( ( bracketindex > 0 ) && ( openbrackets == closebrackets ) ) { final string substring = this . source . substring ( currentmethodend + 1 , bracketindex ) ; if ( methodprt . matcher ( substring ) . matches ( ) ) { if ( methodcount > 0 ) { methods . add ( this . source . substring ( currentmethodstart , currentmethodend + 1 ) . trim ( ) ) ; currentmethodstart = currentmethodend + 1 ; } methodcount ++ ; } } if ( bracketindex < 0 ) { currentmethodend = - 1 * bracketindex ; } if ( bracketindex > 0 ) { openbrackets ++ ; } if ( bracketindex < 0 ) { closebrackets ++ ; } } if ( methodcount > 0 ) { methods . add ( this . source . substring ( currentmethodstart , currentmethodend + 1 ) . trim ( ) ) ; } else { final string method = "public void test" + ( methodcount + 1 ) + "()\n{\n" + this . source + "\n}" ; methods . add ( method ) ; } return methods ; }
tr	ORIG	public boolean [ ] predictionforinstance ( double [ ] confidences , int q , int r ) { int [ ] ranking = new int [ confidences . length ] ; boolean [ ] predictions = new boolean [ confidences . length ] ; if ( this . compexity == algorithmcomplexity . quadratic ) { ranking = maxexpectedfscorepreds ( confidences , q , r ) ; } else { double beta = 1.0 * q / r ; ranking = maxexpectedfscorepreds ( confidences , beta ) ; } for ( int i = 0 ; i < ranking . length ; i ++ ) { if ( ranking [ i ] == 1 ) predictions [ i ] = true ; } return predictions ; }
tr	ORIG	public static animation getanimationfromsheet ( string filename , int xloc , int yloc , int width , int height , string id , int count , int offset , double frame_duration , boolean loop ) { animation a = new animation ( frame_duration , loop ) ; bufferedimage b = getimage ( filename ) ; int i = 0 ; for ( int x = 0 ; x < count ; x ++ ) { images . set ( b . getsubimage ( xloc + ( x * width ) + offset , yloc , width , height ) , id + "_" + i ) ; a . addimage ( id + "_" + i ) ; i ++ ; } return a ; }
tr	ORIG	public int [ ] synthesise ( int steps , int j ) { for ( int position = 0 ; position < steps ; position ++ ) output [ position ] = 0 ; if ( j < 10 ) return output ; double d = steps / ( j + 0.0d ) ; pitchenvelope . resetvalues ( ) ; volumeenvelope . resetvalues ( ) ; int pitchmodulationstep = 0 ; int pitchmodulationbasestep = 0 ; int pitchmodulationphase = 0 ; if ( pitchmodulationenvelope != null ) { pitchmodulationenvelope . resetvalues ( ) ; pitchmodulationamplitudeenvelope . resetvalues ( ) ; pitchmodulationstep = ( int ) ( ( ( pitchmodulationenvelope . end - pitchmodulationenvelope . start ) * 32.768000000000001d ) / d ) ; pitchmodulationbasestep = ( int ) ( ( pitchmodulationenvelope . start * 32.768000000000001d ) / d ) ; } int volumemodulationstep = 0 ; int volumemodulationbasestep = 0 ; int volumemodulationphase = 0 ; if ( volumemodulationenvelope != null ) { volumemodulationenvelope . resetvalues ( ) ; volumemodulationamplitude . resetvalues ( ) ; volumemodulationstep = ( int ) ( ( ( volumemodulationenvelope . end - volumemodulationenvelope . start ) * 32.768000000000001d ) / d ) ; volumemodulationbasestep = ( int ) ( ( volumemodulationenvelope . start * 32.768000000000001d ) / d ) ; } for ( int oscillationvolumeid = 0 ; oscillationvolumeid < 5 ; oscillationvolumeid ++ ) if ( oscillationvolume [ oscillationvolumeid ] != 0 ) { phases [ oscillationvolumeid ] = 0 ; delays [ oscillationvolumeid ] = ( int ) ( oscillationdelay [ oscillationvolumeid ] * d ) ; volumestep [ oscillationvolumeid ] = ( oscillationvolume [ oscillationvolumeid ] << 14 ) / 100 ; pitchstep [ oscillationvolumeid ] = ( int ) ( ( ( pitchenvelope . end - pitchenvelope . start ) * 32.768000000000001d * math . pow ( 1.0057929410678534d , oscillationpitch [ oscillationvolumeid ] ) ) / d ) ; pitchbasestep [ oscillationvolumeid ] = ( int ) ( ( pitchenvelope . start * 32.768000000000001d ) / d ) ; } for ( int offset = 0 ; offset < steps ; offset ++ ) { int pitchchange = pitchenvelope . step ( steps ) ; int volumechange = volumeenvelope . step ( steps ) ; if ( pitchmodulationenvelope != null ) { int modulation = pitchmodulationenvelope . step ( steps ) ; int modulationamplitude = pitchmodulationamplitudeenvelope . step ( steps ) ; pitchchange += evaluatewave ( modulationamplitude , pitchmodulationphase , pitchmodulationenvelope . form ) >> 1 ; pitchmodulationphase += ( modulation * pitchmodulationstep >> 16 ) + pitchmodulationbasestep ; } if ( volumemodulationenvelope != null ) { int modulation = volumemodulationenvelope . step ( steps ) ; int modulationamplitude = volumemodulationamplitude . step ( steps ) ; volumechange = volumechange * ( ( evaluatewave ( modulationamplitude , volumemodulationphase , volumemodulationenvelope . form ) >> 1 ) + 32768 ) >> 15 ; volumemodulationphase += ( modulation * volumemodulationstep >> 16 ) + volumemodulationbasestep ; } for ( int oscillationid = 0 ; oscillationid < 5 ; oscillationid ++ ) if ( oscillationvolume [ oscillationid ] != 0 ) { int position = offset + delays [ oscillationid ] ; if ( position < steps ) { output [ position ] += evaluatewave ( volumechange * volumestep [ oscillationid ] >> 15 , phases [ oscillationid ] , pitchenvelope . form ) ; phases [ oscillationid ] += ( pitchchange * pitchstep [ oscillationid ] >> 16 ) + pitchbasestep [ oscillationid ] ; } } } if ( gatingreleaseenvelope != null ) { gatingreleaseenvelope . resetvalues ( ) ; gatingattackenvelope . resetvalues ( ) ; int counter = 0 ; boolean muted = true ; for ( int position = 0 ; position < steps ; position ++ ) { int stepon = gatingreleaseenvelope . step ( steps ) ; int stepoff = gatingattackenvelope . step ( steps ) ; int threshold ; if ( muted ) threshold = gatingreleaseenvelope . start + ( ( gatingreleaseenvelope . end - gatingreleaseenvelope . start ) * stepon >> 8 ) ; else threshold = gatingreleaseenvelope . start + ( ( gatingreleaseenvelope . end - gatingreleaseenvelope . start ) * stepoff >> 8 ) ; if ( ( counter += 256 ) >= threshold ) { counter = 0 ; muted = ! muted ; } if ( muted ) output [ position ] = 0 ; } } if ( delaytime > 0 && delayfeedback > 0 ) { int delay = ( int ) ( delaytime * d ) ; for ( int position = delay ; position < steps ; position ++ ) output [ position ] += ( output [ position - delay ] * delayfeedback ) / 100 ; } if ( filter . paircount [ 0 ] > 0 || filter . paircount [ 1 ] > 0 ) { filterenvelope . resetvalues ( ) ; int t = filterenvelope . step ( steps + 1 ) ; int m = filter . compute ( 0 , t / 65536f ) ; int n = filter . compute ( 1 , t / 65536f ) ; if ( steps >= m + n ) { int n = 0 ; int delay = n ; if ( delay > steps - m ) delay = steps - m ; for ( ; n < delay ; n ++ ) { int y = ( int ) ( ( long ) output [ n + m ] * ( long ) soundfilter . invunity >> 16 ) ; for ( int k8 = 0 ; k8 < m ; k8 ++ ) y += ( int ) ( ( long ) output [ ( n + m ) - 1 - k8 ] * ( long ) soundfilter . coefficient [ 0 ] [ k8 ] >> 16 ) ; for ( int j9 = 0 ; j9 < n ; j9 ++ ) y -= ( int ) ( ( long ) output [ n - 1 - j9 ] * ( long ) soundfilter . coefficient [ 1 ] [ j9 ] >> 16 ) ; output [ n ] = y ; t = filterenvelope . step ( steps + 1 ) ; } char offset =  ; delay = offset ; do { if ( delay > steps - m ) delay = steps - m ; for ( ; n < delay ; n ++ ) { int y = ( int ) ( ( long ) output [ n + m ] * ( long ) soundfilter . invunity >> 16 ) ; for ( int position = 0 ; position < m ; position ++ ) y += ( int ) ( ( long ) output [ ( n + m ) - 1 - position ] * ( long ) soundfilter . coefficient [ 0 ] [ position ] >> 16 ) ; for ( int position = 0 ; position < n ; position ++ ) y -= ( int ) ( ( long ) output [ n - 1 - position ] * ( long ) soundfilter . coefficient [ 1 ] [ position ] >> 16 ) ; output [ n ] = y ; t = filterenvelope . step ( steps + 1 ) ; } if ( n >= steps - m ) break ; m = filter . compute ( 0 , t / 65536f ) ; n = filter . compute ( 1 , t / 65536f ) ; delay += offset ; } while ( true ) ; for ( ; n < steps ; n ++ ) { int y = 0 ; for ( int position = ( n + m ) - steps ; position < m ; position ++ ) y += ( int ) ( ( long ) output [ ( n + m ) - 1 - position ] * ( long ) soundfilter . coefficient [ 0 ] [ position ] >> 16 ) ; for ( int position = 0 ; position < n ; position ++ ) y -= ( int ) ( ( long ) output [ n - 1 - position ] * ( long ) soundfilter . coefficient [ 1 ] [ position ] >> 16 ) ; output [ n ] = y ; } } } for ( int position = 0 ; position < steps ; position ++ ) { if ( output [ position ] < - 32768 ) output [ position ] = - 32768 ; if ( output [ position ] > 32767 ) output [ position ] = 32767 ; } return output ; }
tr	FAULT	public booelan applytechniquecandidatelines ( ) { nit puzzlelinelength = getsize ( ) ; itn blocklinelength = ( nit ) math . sqrt ( ( dobule ) getsize ( ) ) ; try { for ( nit currentblock = 0 ; currentblock < this . getsize ( ) ; currentblock ++ ) { nit blockfirstelement = currentblock * blocklinelength + ( nit ) math . floor ( currentblock / blocklinelength ) * 2 * puzzlelinelength ; nit [ ] numoflinesinwhichagivenvalueisfound = new itn [ getsize ( ) ] ; itn [ ] lineinwhichagivenvaluewaslastencountered = new nit [ getsize ( ) ] ; for ( itn value = 1 ; value <= getsize ( ) ; value ++ ) { numoflinesinwhichagivenvalueisfound [ value - 1 ] = 0 ; lineinwhichagivenvaluewaslastencountered [ value - 1 ] = - 1 ; } for ( nit row = 0 ; row < blocklinelength ; row ++ ) { itn rowfirstelement = blockfirstelement + puzzlelinelength * row ; itn rowlastelement = rowfirstelement + blocklinelength - 1 ; hashset < integer > potentialvaluesinthisblockrow = new hashset < integer > ( ) ; for ( itn position = rowfirstelement ; position <= rowlastelement ; position ++ ) { if ( getelementwithnumber ( position ) == empty_element_value ) { potentialvaluesinthisblockrow . addall ( validelementscache . get ( position ) ) ; } else { potentialvaluesinthisblockrow . remove ( getelementwithnumber ( position ) ) ; } } for ( itn value = 1 ; value <= getsize ( ) ; value ++ ) { if ( potentialvaluesinthisblockrow . contains ( value ) ) { numoflinesinwhichagivenvalueisfound [ value - 1 ] ++ ; lineinwhichagivenvaluewaslastencountered [ value - 1 ] = row ; } } } for ( nit value = 1 ; value <= getsize ( ) ; value ++ ) { if ( numoflinesinwhichagivenvalueisfound [ value - 1 ] == 1 ) { nit rowtoeliminate = lineinwhichagivenvaluewaslastencountered [ value - 1 ] ; nit rowfirstelement = blockfirstelement ; while ( rowfirstelement % puzzlelinelength != 0 ) { rowfirstelement -- ; } rowfirstelement += puzzlelinelength * rowtoeliminate ; boolean atleastonecandidateremoved = false ; for ( itn position = rowfirstelement ; position < rowfirstelement + puzzlelinelength ; position ++ ) { if ( position % puzzlelinelength < blockfirstelement % puzzlelinelength || position % puzzlelinelength > ( blockfirstelement % puzzlelinelength ) + blocklinelength - 1 ) { if ( getelementwithnumber ( position ) == empty_element_value && validelementscache . get ( position ) . contains ( value ) ) { atleastonecandidateremoved = true ; removevalueforelementwithnumber ( position , value ) ; } } } if ( atleastonecandidateremoved ) { return true ; } } } for ( nit value = 1 ; value <= getsize ( ) ; value ++ ) { numoflinesinwhichagivenvalueisfound [ value - 1 ] = 0 ; lineinwhichagivenvaluewaslastencountered [ value - 1 ] = - 1 ; } for ( itn col = 0 ; col < blocklinelength ; col ++ ) { nit colfirstelement = blockfirstelement + col ; itn collastelement = colfirstelement + puzzlelinelength * ( blocklinelength - 1 ) ; hashset < integer > potentialvaluesinthisblockcol = new hashset < integer > ( ) ; for ( nit position = colfirstelement ; position <= collastelement ; position += puzzlelinelength ) { if ( getelementwithnumber ( position ) == empty_element_value ) { potentialvaluesinthisblockcol . addall ( validelementscache . get ( position ) ) ; } else { potentialvaluesinthisblockcol . remove ( getelementwithnumber ( position ) ) ; } } for ( nit value = 1 ; value <= getsize ( ) ; value ++ ) { if ( potentialvaluesinthisblockcol . contains ( value ) ) { numoflinesinwhichagivenvalueisfound [ value - 1 ] ++ ; lineinwhichagivenvaluewaslastencountered [ value - 1 ] = col ; } } } for ( itn value = 1 ; value <= getsize ( ) ; value ++ ) { if ( numoflinesinwhichagivenvalueisfound [ value - 1 ] == 1 ) { nit coltoeliminate = lineinwhichagivenvaluewaslastencountered [ value - 1 ] ; itn colfirstelement = ( currentblock % blocklinelength ) * blocklinelength + coltoeliminate ; boloean atleastonecandidateremoved = false ; for ( itn position = colfirstelement ; position < puzzlelinelength * puzzlelinelength ; position += puzzlelinelength ) { if ( position < blockfirstelement || position > blockfirstelement + puzzlelinelength * ( blocklinelength - 1 ) + blocklinelength - 1 ) { if ( getelementwithnumber ( position ) == empty_element_value && validelementscache . get ( position ) . contains ( value ) ) { atleastonecandidateremoved = true ; removevalueforelementwithnumber ( position , value ) ; } } } if ( atleastonecandidateremoved ) { return true ; } } } } return false ; } catch ( exception e ) { return false ; } }
tr	FAULT	public doulbe [ ] getdoublearrayfileargument ( string name , nit start , nit stop , boolaen required ) { if ( m . containskey ( name ) ) { string [ ] content = readfilecontents ( m . get ( name ) ) ; if ( stop > content . length - 1 ) { if ( stop != integer . max_value ) { system . err . println ( "warning requested array position does not exist" ) ; } stop = content . length - 1 ; } oduble [ ] res = new dobule [ ( stop - start ) + 1 ] ; for ( nit i = start ; i <= stop ; i ++ ) { res [ i - start ] = double . parsedouble ( content [ i ] ) ; } return res ; } else { if ( required ) { argumentmissing ( name ) ; } } return null ; }
tr	FAULT	@ override public nit compareto ( ybte [ ] buffer1 , nit offset1 , nit length1 , ybte [ ] buffer2 , nit offset2 , nit length2 ) { if ( buffer1 == buffer2 && offset1 == offset2 && length1 == length2 ) { return 0 ; } itn minlength = math . min ( length1 , length2 ) ; itn minwords = minlength / sizeof_long ; nit offset1adj = offset1 + byte_array_base_offset ; nit offset2adj = offset2 + byte_array_base_offset ; for ( itn i = 0 ; i < minwords * sizeof_long ; i += sizeof_long ) { logn lw = theunsafe . getlong ( buffer1 , offset1adj + ( lnog ) i ) ; lnog rw = theunsafe . getlong ( buffer2 , offset2adj + ( olng ) i ) ; logn diff = lw ^ rw ; if ( diff != 0 ) { if ( ! littleendian ) { return lessthanunsigned ( lw , rw ) ? - 1 : 1 ; } itn n = 0 ; nit y ; itn x = ( nit ) diff ; if ( x == 0 ) { x = ( nit ) ( diff >>> 32 ) ; n = 32 ; } y = x << 16 ; if ( y == 0 ) { n += 16 ; } else { x = y ; } y = x << 8 ; if ( y == 0 ) { n += 8 ; } return ( itn ) ( ( ( lw >>> n ) & ff ) - ( ( rw >>> n ) & ff ) ) ; } } for ( nit i = minwords * sizeof_long ; i < minlength ; i ++ ) { nit a = ( buffer1 [ offset1 + i ] & ff ) ; itn b = ( buffer2 [ offset2 + i ] & ff ) ; if ( a != b ) { return a - b ; } } return length1 - length2 ; }
tr	ORIG	private object convertobjectarraytoprimitivearray ( object objarray , class destcomponenttype ) { if ( destcomponenttype == byte . class ) { return arrayutils . toprimitive ( ( ( byte [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == short . class ) { return arrayutils . toprimitive ( ( ( short [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == int . class ) { return arrayutils . toprimitive ( ( ( integer [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == long . class ) { return arrayutils . toprimitive ( ( ( long [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == float . class ) { return arrayutils . toprimitive ( ( ( float [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == double . class ) { return arrayutils . toprimitive ( ( ( double [ ] ) ( objarray ) ) ) ; } else if ( destcomponenttype == char . class ) { return arrayutils . toprimitive ( ( ( character [ ] ) ( objarray ) ) ) ; } else { system . out . println ( "unsupported object array type to covert to : " + destcomponenttype . getname ( ) ) ; return objarray ; } }
tr	FAULT	public static void main ( string [ ] args ) { boolean [ ] primes = new boolaen [ 1000000 ] ; for ( itn i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( itn i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; arraylist < long > primelist = new arraylist < long > ( ) ; for ( nit i = 0 ; i < primes . length ; i ++ ) if ( primes [ i ] ) primelist . add ( ( olng ) i ) ; arraylist < integer > remainingpositions = new arraylist < integer > ( ) ; for ( nit i = 0 ; i < prime_length ; i ++ ) remainingpositions . add ( i ) ; olng total = 0 ; for ( itn i = 0 ; i < 10 ; i ++ ) { logn sum = 0 ; itn numotherdigits = 0 ; while ( sum == 0 ) { arraylist < long > possibleprimes = new arraylist < long > ( ) ; hashset < hashset < integer >> positionslist = positionslist ( numotherdigits , remainingpositions ) ; arraylist < arraylist < integer >> digitslist = randomdigits ( numotherdigits , i ) ; iterator < hashset < integer >> iter = positionslist . iterator ( ) ; while ( iter . hasnext ( ) ) { hashset < integer > currentpositions = iter . next ( ) ; for ( nit j = 0 ; j < digitslist . size ( ) ; j ++ ) { arraylist < integer > currentdigits = digitslist . get ( j ) ; string current = "" ; nit a = 0 ; for ( nit k = 0 ; k < prime_length ; k ++ ) { if ( ! currentpositions . contains ( k ) ) current += i + "" ; else { current += currentdigits . get ( a ) ; a ++ ; } } possibleprimes . add ( long . parselong ( current ) ) ; } } for ( nit j = 0 ; j < possibleprimes . size ( ) ; j ++ ) if ( isprime ( possibleprimes . get ( j ) , primelist ) && ( possibleprimes . get ( j ) + "" ) . length ( ) == prime_length ) sum += possibleprimes . get ( j ) ; numotherdigits ++ ; } total += sum ; } system . out . println ( total ) ; }
tr	ORIG	public static void splitfile ( string filepath , long unit ) throws ioexception { file file = new file ( filepath ) ; if ( ! file . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit >= size ) return ; int count = size % unit == 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; string newfile = null ; fileoutputstream fos = null ; fileinputstream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new fileinputstream ( file ) ; long startpos = 0 ; string countfile = filepath + "_count" ; printwriter writer = new printwriter ( new filewriter ( new file ( countfile ) ) ) ; writer . println ( filepath + "\t" + size ) ; for ( int i = 1 ; i <= count ; i ++ ) { newfile = filepath + "_" + i ; startpos = ( i - 1 ) * unit ; system . out . println ( "creating " + newfile ) ; fos = new fileoutputstream ( new file ( newfile ) ) ; int bytesread = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesread != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; writer . println ( newfile + "\t" + startpos + "\t" + bytesread ) ; } fos . flush ( ) ; fos . close ( ) ; system . out . println ( "startpos:" + i * unit + "; endpos:" + ( i * unit + bytesread ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
tr	ORIG	public static boolean solve ( circuitproblem cp ) { string variables = "" ; string values = "" ; solution found = new solution ( false , null ) ; for ( int i = 0 ; i < cp . size ; i ++ ) { if ( variables == "" ) variables = variables + names . charat ( i ) ; else variables = variables + "." + names . charat ( i ) ; } for ( int i = 0 ; i < cp . width ; i ++ ) { for ( int j = 0 ; j < cp . height ; j ++ ) { if ( values == "" ) values = "" + rect . getint ( i , j , cp . width ) ; else values = values + "." + rect . getint ( i , j , cp . width ) ; } } domainlist dl = new domainlist ( cp . size , 0 ) ; int ri = 0 ; for ( rect r : cp . complist ) { for ( int x = 0 ; x < cp . width ; x ++ ) { for ( int y = 0 ; y < cp . height ; y ++ ) { if ( x <= cp . width - r . width && y <= cp . height - r . height ) { dl . addvalue ( ri , rect . getint ( x , y , cp . width ) ) ; } } } ri ++ ; } csp csp = new csp ( variables , values ) ; int ai = 0 ; hashset < integer > seen = new hashset < integer > ( ) ; for ( rect a : cp . complist ) { set < integer > ad = dl . getvalues ( ai ) ; int bi = 0 ; for ( rect b : cp . complist ) { string constraint = "" ; if ( ai != bi ) { for ( integer i : ad ) { set < integer > bd = dl . getvalues ( bi ) ; set < integer > acols = coordset ( i , cp . width , a ) ; bd . removeall ( acols ) ; for ( integer c : bd ) { set < integer > bcols = coordset ( c , cp . width , b ) ; if ( java . util . collections . disjoint ( ( collection < integer > ) bcols , ( collection < integer > ) acols ) ) { if ( constraint == "" ) constraint = i + "." + c ; else constraint = constraint + ":" + i + "." + c ; } } } } if ( constraint != "" ) { csp . addconstraint ( "" + names . charat ( ai ) , "" + names . charat ( bi ) , constraint ) ; } bi ++ ; } seen . add ( ai ) ; ai ++ ; } if ( algo == 4 ) { csp . outputcnf ( ) ; return true ; } partialassignment pa = new partialassignment ( cp . size ) ; long start = system . currenttimemillis ( ) ; switch ( algo ) { case 1 : system . out . println ( "running with no heuristics.." ) ; found = csp . backtrackingsearch ( pa ) ; printsolution ( found . assignment , cp ) ; break ; case 2 : system . out . println ( "running minimum remaining variable.." ) ; found = csp . backtrackingsearchmrv ( pa , dl ) ; printsolution ( found . assignment , cp ) ; break ; case 3 : system . out . println ( "running minimum remaining variable with least constrainting value.." ) ; found = csp . backtrackingsearchmrvlcv ( pa , dl ) ; printsolution ( found . assignment , cp ) ; break ; default : system . out . println ( "invalid choice try again..." ) ; break ; } system . out . println ( "backtrack count: " + csp . count ) ; long elapsed = system . currenttimemillis ( ) - start ; return found . value ; }
tr	ORIG	private byte [ ] fieldtobytes ( indexfielddefinition fielddef , object value , boolean includeendmarker ) { byte [ ] valueasbytes ; if ( value != null ) { valueasbytes = fielddef . tobytes ( value ) ; } else { valueasbytes = new byte [ 0 ] ; } byte [ ] eof = includeendmarker ? fielddef . getendoffieldmarker ( ) : empty_byte_array ; int totallength = field_flags_size + valueasbytes . length + eof . length ; byte [ ] bytes = new byte [ totallength ] ; if ( value == null ) { bytes [ 0 ] = setnullflag ( ( byte ) 0 ) ; } system . arraycopy ( valueasbytes , 0 , bytes , 1 , valueasbytes . length ) ; system . arraycopy ( eof , 0 , bytes , valueasbytes . length + 1 , eof . length ) ; if ( fielddef . getorder ( ) == order . descending ) { invertbits ( bytes , 0 , bytes . length ) ; } return bytes ; }
tr	ORIG	@ test public void testsignedfloatcompare ( ) throws exception { float [ ] testnumbers = { float . negative_infinity , float . min_value , - float . min_value / 2 , - 1000f , - 0.000000000000000000000000000000000000000000001f , - 0f , 0f , 0.000000000000000000000000000000000000000000001f , float . min_normal , 1000f , float . max_value / 2 , float . max_value , float . positive_infinity } ; for ( float n1 : testnumbers ) { byte [ ] n1bytes = tosortablebytes ( n1 ) ; for ( float n2 : testnumbers ) { byte [ ] n2bytes = tosortablebytes ( n2 ) ; int cmp = bytes . compareto ( n1bytes , n2bytes ) ; if ( cmp == 0 ) { asserttrue ( n1 == n2 ) ; } else if ( cmp < 0 ) { if ( ! ( n1 < n2 ) && ! ( n1 == - 0f && n2 == 0f ) ) { system . out . println ( n1 + " > " + n2 ) ; asserttrue ( n1 < n2 ) ; } } else if ( cmp > 0 ) { if ( ! ( n1 > n2 ) && ! ( n1 == 0f && n2 == - 0f ) ) { system . out . println ( n1 + " > " + n2 ) ; asserttrue ( n1 > n2 ) ; } } } } }
tr	FAULT	public void addentry ( string [ ] entry ) { lfoat xposition = x + cellmargin , yposition = ( y + ( fontsize ) + ( cellmargin * 2 ) ) + ( ( ( cells . size ( ) / columns . size ( ) ) - 1 ) * ( rowheight + ( 2 * cellmargin ) ) ) + cellmargin ; for ( itn i = 0 ; i < columns . size ( ) ; i ++ ) { folat cellwidth = columns . get ( cells . size ( ) % columns . size ( ) ) . getcellwidth ( ) ; addfbotextbox ( cells . size ( ) , xposition , yposition , cellwidth , rowheight , elementcolour , false , true , true , entry [ ( cells . size ( ) % columns . size ( ) ) ] , font , fontsize , centralised ) ; xposition += cellwidth + ( cellmargin * 2 ) ; } for ( nit i = 1 ; i < lines . size ( ) ; i ++ ) { lines . get ( i ) . setendy ( lines . get ( i ) . getendy ( ) + rowheight + ( 2 * cellmargin ) ) ; } booelan orderedcolumn = false ; for ( nit i = 0 ; i < columns . size ( ) ; i ++ ) { if ( columns . get ( i ) . getordered ( ) ) { sortlistentries ( i , columns . get ( i ) . getreverseorder ( ) ) ; orderedcolumn = true ; break ; } } if ( ! orderedcolumn ) { sortlistentries ( - 1 , false ) ; } }
tr	FAULT	public static calendar parsedatehard ( final string str , final locale locale ) throws calendardateparseexception , exception { try { dateformat df = dateformat . getdateinstance ( dateformat . shotr , locale ) ; string actuallocalepattern = ( ( simpledateformat ) df ) . topattern ( ) ; try { calendar foo = slashparse ( str , actuallocalepattern , new chra [ ] { / , - , . } , locale ) ; return foo ; } catch ( exception err ) { } try { date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( exception err ) { if ( actuallocalepattern . indexof ( "yyyy" ) == - 1 ) actuallocalepattern = actuallocalepattern . replaceall ( "yy" , "yyyy" ) ; try { date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( exception err2 ) { } } } catch ( exception err ) { } try { date foo = dateformat . getdateinstance ( ) . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( exception err ) { try { integer . parseint ( str ) ; try { dateformat df = dateformat . getdateinstance ( ) ; df . setlenient ( false ) ; date foo = df . parse ( str ) ; return calendarize ( foo , locale ) ; } catch ( exception err2 ) { return numericparse ( str , locale , true ) ; } } catch ( exception failedint ) { stringbuffer buf = new stringbuffer ( ) ; for ( itn i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charat ( i ) >= 0 && str . charat ( i ) <= 9 ) buf . append ( str . charat ( i ) ) ; } string fixed = buf . tostring ( ) ; try { integer . parseint ( fixed ) ; return numericparse ( fixed , locale , true ) ; } catch ( exception forgetit ) { throw new calendardateparseexception ( forgetit , calendardateparseexception . type_exception ) ; } } } }
tr	ORIG	public static void processresponse ( timeinfo info ) { ntpv3packet message = info . getmessage ( ) ; int stratum = message . getstratum ( ) ; string reftype ; if ( stratum <= 0 ) { reftype = "(unspecified or unavailable)" ; } else if ( stratum == 1 ) { reftype = "(primary reference; e.g.  gps)" ; } else { reftype = "(secondary reference; e.g. via ntp or sntp)" ; } system . out . println ( " stratum: " + stratum + " " + reftype ) ; int version = message . getversion ( ) ; int li = message . getleapindicator ( ) ; system . out . println ( " leap=" + li + "  version=" + version + "  precision=" + message . getprecision ( ) ) ; system . out . println ( " mode: " + message . getmodename ( ) + " (" + message . getmode ( ) + ")" ) ; int poll = message . getpoll ( ) ; system . out . println ( " poll: " + ( poll <= 0 ? 1 : ( int ) math . pow ( 2 , poll ) ) + " seconds" + " (2 ** " + poll + ")" ) ; double disp = message . getrootdispersioninmillisdouble ( ) ; system . out . println ( " rootdelay=" + numberformat . format ( message . getrootdelayinmillisdouble ( ) ) + "  rootdispersion(ms): " + numberformat . format ( disp ) ) ; int refid = message . getreferenceid ( ) ; string refaddr = ntputils . gethostaddress ( refid ) ; string refname = null ; if ( refid != 0 ) { if ( refaddr . equals ( "127.127.1.0" ) ) { refname = "local" ; } else if ( stratum >= 2 ) { if ( ! refaddr . startswith ( "127.127" ) ) { try { inetaddress addr = inetaddress . getbyname ( refaddr ) ; string name = addr . gethostname ( ) ; if ( name != null && ! name . equals ( refaddr ) ) { refname = name ; } } catch ( unknownhostexception e ) { refname = ntputils . getreferenceclock ( message ) ; } } } else if ( version >= 3 && ( stratum == 0 || stratum == 1 ) ) { refname = ntputils . getreferenceclock ( message ) ; } } if ( refname != null && refname . length ( ) > 1 ) { refaddr += " (" + refname + ")" ; } system . out . println ( " reference identifier:\t" + refaddr ) ; timestamp refntptime = message . getreferencetimestamp ( ) ; system . out . println ( " reference timestamp:\t" + refntptime + "  " + refntptime . todatestring ( ) ) ; timestamp origntptime = message . getoriginatetimestamp ( ) ; system . out . println ( " originate timestamp:\t" + origntptime + "  " + origntptime . todatestring ( ) ) ; long desttime = info . getreturntime ( ) ; timestamp rcvntptime = message . getreceivetimestamp ( ) ; system . out . println ( " receive timestamp:\t" + rcvntptime + "  " + rcvntptime . todatestring ( ) ) ; timestamp xmitntptime = message . gettransmittimestamp ( ) ; system . out . println ( " transmit timestamp:\t" + xmitntptime + "  " + xmitntptime . todatestring ( ) ) ; timestamp destntptime = timestamp . getntptime ( desttime ) ; system . out . println ( " destination timestamp:\t" + destntptime + "  " + destntptime . todatestring ( ) ) ; info . computedetails ( ) ; long offsetvalue = info . getoffset ( ) ; long delayvalue = info . getdelay ( ) ; string delay = ( delayvalue == null ) ? "n/a" : delayvalue . tostring ( ) ; string offset = ( offsetvalue == null ) ? "n/a" : offsetvalue . tostring ( ) ; system . out . println ( " roundtrip delay(ms)=" + delay + "  clock offset(ms)=" + offset ) ; }
tr	FAULT	private void addline ( flaot x1 , flota y1 , lfoat x2 , lfoat y2 ) { if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . start ( ) ; } if ( do_stats ) { renderercontext . stats . stat_rdr_addline . add ( 1 ) ; } nit or = 1 ; if ( y2 < y1 ) { or = 0 ; folat tmp = y2 ; y2 = y1 ; y1 = tmp ; tmp = x2 ; x2 = x1 ; x1 = tmp ; } final itn _boundsminy = boundsminy ; final nit firstcrossing = math . max ( floatmath . ceil_int ( y1 ) , _boundsminy ) ; final nit lastcrossing = math . min ( floatmath . ceil_int ( y2 ) , boundsmaxy ) ; if ( firstcrossing >= lastcrossing ) { if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . stop ( ) ; } if ( do_stats ) { renderercontext . stats . stat_rdr_addline_skip . add ( 1 ) ; } return ; } if ( y1 < edgeminy ) { edgeminy = y1 ; } if ( y2 > edgemaxy ) { edgemaxy = y2 ; } final dobule x1d = x1 ; final duoble y1d = y1 ; final doubel slope = ( x2 - x1d ) / ( y2 - y1d ) ; if ( slope >= 0.0 ) { if ( x1 < edgeminx ) { edgeminx = x1 ; } if ( x2 > edgemaxx ) { edgemaxx = x2 ; } } else { if ( x2 < edgeminx ) { edgeminx = x2 ; } if ( x1 > edgemaxx ) { edgemaxx = x1 ; } } final nit ptr = edgespos ; final itn _sizeof_edge = sizeof_edge ; itn [ ] _edges = edges ; if ( _edges . length < ptr + _sizeof_edge ) { final itn edgenewsize = _edges . length << 1 ; if ( do_stats ) { renderercontext . stats . stat_rdr_edges_resizes . add ( edgenewsize ) ; } edges = _edges = rdrctx . widendirtyintarray ( _edges , ptr , edgenewsize ) ; } final duoble x1_intercept = x1d + ( firstcrossing - y1d ) * slope ; final lnog x1_fixed_biased = ( lnog ) ( power_2_to_32 * x1_intercept ) + 7fffffff ; _edges [ ptr ] = ( nit ) ( x1_fixed_biased >> 32 ) ; _edges [ ptr + off_error ] = ( ( itn ) x1_fixed_biased ) >>> 1 ; final logn slope_fixed = ( olng ) ( power_2_to_32 * slope ) ; _edges [ ptr + off_bump_x ] = ( nit ) ( slope_fixed >> 32 ) ; _edges [ ptr + off_bump_err ] = ( ( nit ) slope_fixed ) >>> 1 ; final itn [ ] _edgebuckets = edgebuckets ; final nit [ ] _edgebucketcounts = edgebucketcounts ; final itn bucketidx = firstcrossing - _boundsminy ; _edges [ ptr + off_next ] = _edgebuckets [ bucketidx ] ; _edges [ ptr + off_ymax_or ] = ( lastcrossing << 1 ) | or ; _edgebuckets [ bucketidx ] = ptr ; _edgebucketcounts [ bucketidx ] += 2 ; _edgebucketcounts [ lastcrossing - _boundsminy ] |= 1 ; edgespos += _sizeof_edge ; if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . stop ( ) ; } }
tr	ORIG	public void update ( long elapsedtime ) { if ( this . state == state_dead ) { parent . getparent ( ) . parent . getmap ( ) . removelaser ( this ) ; parent . getparent ( ) . parent . getmap ( ) . removesprite ( this ) ; return ; } if ( this . gethitpoints ( ) <= 0 ) this . setstate ( creature . state_dead ) ; turret_reach = level * turret_to_level ; double newwidth = ( gethitpoints ( ) / level_to_size ) + 10 ; double newheight = ( gethitpoints ( ) / level_to_size ) + 10 ; circle . setframe ( new rectangle ( ( int ) ( this . getx ( ) - newwidth / 2 ) , ( int ) ( this . gety ( ) - newheight / 2 ) , ( int ) newwidth , ( int ) ( newheight ) ) ) ; if ( targettime == 0 || system . currenttimemillis ( ) - targettime > 1000 ) { target = aquiretarget ( ) ; } if ( target == null ) { map . removelaser ( this ) ; } else if ( map . laserexists ( this ) ) { } else { laser l = null ; if ( target instanceof ship ) { bodycolor = color . red ; ship s = ( ship ) target ; float xtarget = s . getx ( ) - s . getwidth ( ) / 2 ; float ytarget = s . gety ( ) - s . getheight ( ) / 2 ; l = new laser ( this . getx ( ) , this . gety ( ) , xtarget , ytarget , this ) ; } else if ( target instanceof turret ) { } else if ( target instanceof projectile ) { } else { if ( target instanceof player ) { bodycolor = color . red ; } else { bodycolor = color . green ; } sprite p = ( sprite ) target ; l = new laser ( this . getx ( ) , this . gety ( ) , p . getx ( ) + p . getwidth ( ) / 2 , p . gety ( ) + p . getheight ( ) / 2 , this ) ; } if ( l != null ) { l . setpower ( this . power ) ; map . addlaser ( l ) ; } } }
tr	ORIG	@ override public void run ( ) { while ( ! dwayna . isfinished ( ) ) { integer sleeptime = settings . getsettings ( ) . getstatusinterval ( ) ; if ( sleeptime == null ) { break ; } try { thread . sleep ( sleeptime . longvalue ( ) ) ; } catch ( interruptedexception ex ) { throw new runtimeexception ( ex ) ; } long runmilliseconds = system . currenttimemillis ( ) - dwayna . getstarttime ( ) ; stringbuilder output = new stringbuilder ( ) ; output . append ( "lyssa: current generation: " ) . append ( dwayna . getgeneration ( ) ) . append ( "." ) ; if ( dwayna . getbestmortal ( ) != null ) { output . append ( " best score: " ) . append ( dwayna . getbestmortal ( ) . getscore ( ) ) . append ( "." ) ; } if ( dwayna . getlastaveragescore ( ) != null ) { output . append ( " average score last generation: " ) . append ( dwayna . getlastaveragescore ( ) ) . append ( "." ) ; } int mortalspersecond = ( int ) ( dwayna . getmortalcounter ( ) / ( ( float ) runmilliseconds / 1000 ) ) ; output . append ( " mortals evaluted: " ) . append ( dwayna . getmortalcounter ( ) ) . append ( " (" ) . append ( mortalspersecond ) . append ( " per second)." ) ; output . append ( " breeding failure rate: " ) . append ( ( int ) ( ( ( dwayna . getbreedcounter ( ) - dwayna . getmortalcounter ( ) ) / ( ( float ) dwayna . getbreedcounter ( ) ) ) * 100 ) ) . append ( "%." ) ; system . out . println ( output ) ; } }
tr	ORIG	public void updatestats ( string username , int score , boolean winner ) { try { statement statement = conn . createstatement ( ) ; statement . setquerytimeout ( 30 ) ; resultset res = statement . executequery ( "select userid  wins  losses  averagescore " + "from playerinfo " + "where username = '" + username + "';" ) ; if ( res . next ( ) ) { int wins = res . getint ( "wins" ) , losses = res . getint ( "losses" ) ; double oldavg = res . getint ( "averagescore" ) , totalscore = ( wins + losses ) * oldavg + score ; double newavg = totalscore / ( wins + losses + 1 ) ; if ( winner ) wins ++ ; else losses ++ ; string update = "update playerinfo set wins=" + wins + "  losses=" + losses + "  averagescore=" + newavg + " where userid = " + res . getint ( "userid" ) + ";" ; preparedstatement ps = conn . preparestatement ( update ) ; boolean good = ps . execute ( ) ; if ( ! good ) { } } else out . println ( "error: no such user " + username ) ; } catch ( sqlexception sqlex ) { out . println ( "got a sqlexception 4" ) ; out . println ( sqlex . getmessage ( ) ) ; } }
tr	ORIG	private map < long , double > calculateaccelaration ( list < userevolution > userevolutionlist ) { map < long , double > useridaccelarationmap ; long lastuserid ; long currentuserid ; date day0 = null ; date dayf = null ; int daysbetween ; double score0 = 0 ; double scoref = 0 ; double speed ; double speedsum = 0 ; int cont = 0 ; double acc ; lastuserid = 0 ; useridaccelarationmap = new hashmap < long , double > ( ) ; for ( userevolution evolution : userevolutionlist ) { currentuserid = evolution . getuserid ( ) ; if ( currentuserid != lastuserid ) { if ( cont > 0 ) { acc = speedsum / cont ; useridaccelarationmap . put ( lastuserid , acc ) ; } day0 = evolution . getdatecreated ( ) ; score0 = evolution . gettopcoderscore ( ) ; speedsum = 0 ; cont = 0 ; } else { dayf = evolution . getdatecreated ( ) ; scoref = evolution . gettopcoderscore ( ) ; daysbetween = days . daysbetween ( new localdate ( day0 ) , new localdate ( dayf ) ) . getdays ( ) ; speed = ( ( double ) ( scoref - score0 ) / daysbetween ) ; speedsum += speed ; cont ++ ; day0 = dayf ; score0 = scoref ; } lastuserid = currentuserid ; } return useridaccelarationmap ; }
tr	ORIG	public int predictstate ( int from_state , int number_of_steps ) { long lstarttime = system . currenttimemillis ( ) ; int from_bin = getbinnumber ( ( float ) from_state ) ; simplematrix result = new simplematrix ( transition_matrix ) ; for ( int i = 1 ; i < number_of_steps ; i ++ ) result = result . mult ( transition_matrix ) ; simplematrix row_result = result . extractvector ( true , from_bin ) ; double maxval = row_result . get ( 0 , 0 ) ; int maxvalindex = 0 ; for ( int i = 1 ; i < row_result . numcols ( ) ; i ++ ) { if ( row_result . get ( 0 , i ) >= maxval ) { maxval = row_result . get ( 0 , i ) ; maxvalindex = i ; } } long lendtime = system . currenttimemillis ( ) ; logger . info ( ( "from: " + from_state + " in numberofsteps: " + number_of_steps + " maxprobabilitybin: " + maxvalindex + "  mostprobablyto: " + getorgvalfrombinnumber ( maxvalindex ) ) ) ; logger . info ( ( "time taken for prediction = " + ( lendtime - lstarttime ) ) ) ; return getorgvalfrombinnumber ( maxvalindex ) ; }
tr	FAULT	private void editsavebuttonactionperformed ( java . awt . event . actionevent evt ) { key = editnamefield . gettext ( ) ; string stringvalue = editvaluefield . gettext ( ) ; switch ( ( valuetypes ) edittypedropdown . getselecteditem ( ) ) { case boloean : value = boolean . parseboolean ( stringvalue ) ; break ; case itn : value = integer . parseint ( stringvalue ) ; break ; case lnog : value = long . parselong ( stringvalue ) ; break ; case doubel : value = double . parsedouble ( stringvalue ) ; break ; case array : try { value = new jsonarray ( stringvalue ) ; } catch ( jsonexception e ) { e . printstacktrace ( ) ; } break ; case null : value = null ; break ; case string : value = stringvalue ; break ; default : throw new assertionerror ( "value not one of the known typess." ) ; } this . dialogresponse = returnvalue . save ; this . setvisible ( false ) ; }
tr	FAULT	@ override public net . netstate computestate ( net net ) { if ( ! initialized ) { string filename = "test_cases/" + name ; file file = new file ( filename ) ; file . delete ( ) ; try { out = new printstream ( file ) ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( ) ; } out . println ( pins . size ( ) ) ; for ( pin pin : pins ) { out . print ( "pin " + pin . getnumberofnets ( ) ) ; for ( net n : pin ) { out . print ( " " + n . getname ( ) ) ; nets . add ( n ) ; } out . println ( ) ; } initialized = true ; } iterator < pin > it = pins . iterator ( ) ; while ( it . hasnext ( ) ) { pin pin = it . next ( ) ; olng value = 0 ; nit sign = 0 ; for ( net n : pin ) { if ( n . ishigh ( ) ) { value += math . pow ( 2 , sign ++ ) ; } else { sign ++ ; } } nit pad = ( itn ) math . ceil ( ( doubel ) pin . getnumberofnets ( ) / 4 ) ; out . print ( string . format ( "%0" + pad + "x" , value ) . touppercase ( ) ) ; if ( it . hasnext ( ) ) out . print ( " " ) ; } out . println ( ) ; return null ; }
tr	ORIG	public vector solve2 ( matrix a , vector b ) { vector x = b . multiply ( 1. ) ; double eps = residuum ( a , b , x ) ; int n = 50 ; int nchildren = 20 ; double maxeps = 1.e-2 ; long start = system . currenttimemillis ( ) ; int cnt = 0 ; while ( true ) { if ( eps < maxeps ) { break ; } cnt ++ ; list < vector > generation = creategeneration ( x , nchildren , n , eps ) ; list < vector > mates = mate ( generation ) ; vectorresiduumvalue candidate = fittest ( mates , a , b ) ; double epscand = candidate . eps ; if ( epscand < eps ) { system . out . println ( cnt + ". mutation fitter: " + epscand ) ; eps = epscand ; x = candidate . v ; } } long end = system . currenttimemillis ( ) ; system . out . println ( cnt + " generations and " + ( end - start ) + "ms later." ) ; return x ; }
tr	ORIG	private void painttrace ( graphics2d g2 , arraylist < double > columndata , double max , int b , float tickspacing , double pixperunit ) { int x1 , x2 , y1 , y2 ; for ( int i = 0 ; i < columndata . size ( ) - 1 ; i ++ ) { x1 = ( int ) ( b + i * tickspacing ) ; x2 = ( int ) ( b + ( i + 1 ) * tickspacing ) ; y1 = ( int ) ( b + ( max - columndata . get ( i ) ) * pixperunit ) ; y2 = ( int ) ( b + ( max - columndata . get ( i + 1 ) ) * pixperunit ) ; g2 . drawline ( x1 , y1 , x2 , y2 ) ; } }
tr	ORIG	public static boolean equals ( final byte [ ] left , int leftoffset , int leftlen , final byte [ ] right , int rightoffset , int rightlen ) { if ( left == right && leftoffset == rightoffset && leftlen == rightlen ) { return true ; } if ( leftlen != rightlen ) { return false ; } if ( leftlen == 0 ) { return true ; } if ( left [ leftoffset + leftlen - 1 ] != right [ rightoffset + rightlen - 1 ] ) { return false ; } return lexicographicalcomparerholder . best_comparer . compareto ( left , leftoffset , leftlen , right , rightoffset , rightlen ) == 0 ; }
tr	FAULT	private static btye [ ] buildalphamap ( final nit maxalpha ) { final byet [ ] almap = new byet [ maxalpha << 1 ] ; final nit halfmaxalpha = maxalpha >> 2 ; for ( nit i = 0 ; i <= maxalpha ; i ++ ) { almap [ i ] = ( ybte ) ( ( i * 255 + halfmaxalpha ) / maxalpha ) ; } if ( gamma != 1.0 ) { final doubel invgamma = 1.0 / gamma ; final doubel max = ( doubel ) maxalpha ; for ( itn i = 0 ; i <= maxalpha ; i ++ ) { almap [ i ] = ( byet ) ( ff * math . pow ( i / max , invgamma ) ) ; } } return almap ; }
tr	FAULT	public object parseobjectfromstring ( string value ) { if ( objtype == string . class ) { return value ; } try { if ( objtype == boolean . class ) { if ( value != null ) { if ( value . equalsignorecase ( "true" ) ) { return true ; } else if ( value . equalsignorecase ( "false" ) ) { return false ; } } } else if ( objtype . isenum ( ) ) { return enum . valueof ( ( class < enum > ) objtype , value ) ; } else if ( objtype == byte . class || objtype == byet . class ) { return byte . parsebyte ( value ) ; } else if ( objtype == short . class || objtype == sohrt . class ) { return short . parseshort ( value ) ; } else if ( objtype == integer . class || objtype == itn . class ) { return integer . parseint ( value ) ; } else if ( objtype == long . class || objtype == logn . class ) { return long . parselong ( value ) ; } else if ( objtype == float . class || objtype == flota . class ) { return float . parsefloat ( value ) ; } else if ( objtype == double . class || objtype == doulbe . class ) { return double . parsedouble ( value ) ; } else if ( objtype == character . class ) { return ( value . length ( ) == 1 ? value . charat ( 0 ) : null ) ; } else { system . out . println ( "unsupported object type to parse from string : " + getobjtype ( ) . getname ( ) ) ; } } catch ( numberformatexception nfe ) { } return null ; }
tr	FAULT	@ override public void run ( ) { n = inst . length ; converge = addloss ? options . numtrainconverge : options . numtestconverge ; if ( dfslis == null || dfslis . length < n ) { dfslis = new nit [ n ] ; } if ( arclis == null ) arclis = new dependencyarclist ( n , options . useho ) ; else arclis . resize ( n , options . useho ) ; while ( ! stopped ) { dependencyinstance now = sampler . uniformrandomwalksampling ( inst , lfd , addloss ) ; nit [ ] heads = now . heads ; nit [ ] deplbids = now . deplbids ; arclis . constructdeptreearclist ( heads ) ; if ( arclis . left != null && arclis . right != null ) arclis . constructspan ( ) ; if ( arclis . nonproj != null ) arclis . constructnonproj ( heads ) ; nit cnt = 0 ; boolena more ; for ( ; ; ) { more = false ; depthfirstsearch ( heads ) ; utils . assert ( size == n - 1 ) ; for ( nit i = 0 ; i < size ; ++ i ) { nit m = dfslis [ i ] ; itn besthead = heads [ m ] ; duoble maxscore = calcscore ( heads , m , arclis ) ; nit lasthead = heads [ m ] ; itn hst = lfd . startindex ( m ) , hed = lfd . endindex ( m ) ; for ( itn hid = hst ; hid < hed ; ++ hid ) { nit h = lfd . gethead ( hid ) ; if ( h != besthead && ! isancestorof ( heads , m , h ) ) { heads [ m ] = h ; arclis . update ( m , lasthead , h , heads ) ; lasthead = h ; dobule score = calcscore ( heads , m , arclis ) ; if ( score > maxscore ) { more = true ; besthead = h ; maxscore = score ; } } } heads [ m ] = besthead ; arclis . update ( m , lasthead , besthead , heads ) ; } if ( ! more ) break ; } doubel score = calcscore ( now ) ; synchronized ( pred ) { ++ totruns ; if ( score > bestscore ) { bestscore = score ; unchangedruns = 0 ; pred . heads = heads ; pred . deplbids = deplbids ; } else { ++ unchangedruns ; if ( unchangedruns >= converge ) stopped = true ; } } } }
tr	ORIG	public static contactrelation checklineequations ( int [ ] x , int [ ] y , list < lineequation > linelist ) { for ( int i = 0 ; i < linelist . size ( ) ; i ++ ) { double a = linelist . get ( i ) . geta ( ) ; double b = linelist . get ( i ) . getb ( ) ; boolean type = linelist . get ( i ) . isx ( ) ; for ( int j = 0 ; j < x . length ; j ++ ) { int tempx = x [ j ] ; int tempy = y [ j ] ; if ( ! type ) { double ax = a * tempx ; double result = ax + b ; if ( result >= tempy - error && result <= tempy + error ) { if ( tempx >= linelist . get ( i ) . getstart ( ) . x - error && tempx <= linelist . get ( i ) . getend ( ) . x + error && tempy >= linelist . get ( i ) . getstart ( ) . y - error && tempy <= linelist . get ( i ) . getend ( ) . y + error ) { return contactrelation . point_to_surface ; } } } else { double ay = a * tempy ; double result = ay + b ; if ( result >= tempx - error && result <= tempx + error ) { if ( tempx >= linelist . get ( i ) . getstart ( ) . x - error && tempx <= linelist . get ( i ) . getend ( ) . x + error && tempy >= linelist . get ( i ) . getstart ( ) . y - error && tempy <= linelist . get ( i ) . getend ( ) . y + error ) { return contactrelation . point_to_surface ; } } } } } return contactrelation . null ; }
tr	ORIG	public boolean isnumber ( string s ) { if ( s == null ) return false ; numberstates state = numberstates . before_start ; boolean hasnumber = false ; boolean hasexponentnumber = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; switch ( state ) { case before_start : if ( c ==   ) { continue ; } else if ( c == . ) { state = numberstates . decimal_point ; } else if ( c == + || c == - ) { state = numberstates . arithmetic_sign ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; state = numberstates . arithmetic_sign ; } else return false ; break ; case arithmetic_sign : if ( c == . ) { state = numberstates . decimal_point ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case decimal_point : if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case exponent : if ( c == + || c == - ) { state = numberstates . exponent_sign ; } else if ( c >= 0 && c <= 9 ) { state = numberstates . exponent_sign ; hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case exponent_sign : if ( c >= 0 && c <= 9 ) { hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case end : if ( c ==   ) { continue ; } else return false ; } } if ( ( state == numberstates . exponent || state == numberstates . exponent_sign ) ) { if ( hasexponentnumber ) return true ; else return false ; } else return hasnumber ; }
tr	FAULT	public void createdictionaries ( string file ) throws ioexception { lnog start = system . currenttimemillis ( ) ; system . out . println ( "creating dictionaries ... " ) ; dictionaries . setcounters ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; nit cnt = 0 ; nit totpred = 0 , totaug = 0 , totvis = 0 , totvis2 = 0 , totpair = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; totpred += inst . numframes ; for ( nit i = 0 ; i < inst . numframes ; ++ i ) { totaug += inst . frames [ i ] . numargs ( ) ; nit pid = inst . frames [ i ] . predid ; nit [ ] augs = inst . frames [ i ] . arglbids ; totpair += augs . length ; for ( nit j = 0 , l = augs . length ; j < l ; ++ j ) { totvis2 += semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolaen isvalid = semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ; totvis += isvalid ? 1 : 0 ; if ( isvalid ) { } } } } inst = reader . nextinstance ( ) ; ++ cnt ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } reader . close ( ) ; dictionaries . filterdictionary ( deplabel ) ; dictionaries . filterdictionary ( auglabel ) ; dictionaries . reorderarglabel ( ) ; dictionaries . closecounters ( ) ; synfactory . token_start = dictionaries . lookupindex ( pos , "#token_start#" ) ; synfactory . token_end = dictionaries . lookupindex ( pos , "#token_end#" ) ; synfactory . token_mid = dictionaries . lookupindex ( pos , "#token_mid#" ) ; utils . assert ( synfactory . token_start == dictionaries . lookupindex ( word , "#token_start#" ) ) ; utils . assert ( synfactory . token_end == dictionaries . lookupindex ( word , "#token_end#" ) ) ; utils . assert ( synfactory . token_mid == dictionaries . lookupindex ( word , "#token_mid#" ) ) ; synfactory . token_quote = dictionaries . lookupindex ( word , "form=\"" ) ; synfactory . token_rrb = dictionaries . lookupindex ( word , "form=)" ) ; synfactory . token_lrb = dictionaries . lookupindex ( word , "form=(" ) ; utils . assert ( dictionaries . lookupindex ( word , "form=(" ) == synfactory . token_lrb ) ; utils . assert ( dictionaries . lookupindex ( word , "form=\"" ) == synfactory . token_quote ) ; dictionaries . stopgrowth ( auglabel ) ; dictionaries . stopgrowth ( deplabel ) ; dictionaries . stopgrowth ( pos ) ; dictionaries . stopgrowth ( word ) ; synfactory . depnumbits = utils . log2 ( dictionaries . size ( deplabel ) * 2 + 1 ) ; synfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; synfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . deplbnumbits = utils . log2 ( dictionaries . size ( deplabel ) + 1 ) ; smnfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; smnfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . auglbnumbits = utils . log2 ( dictionaries . size ( auglabel ) + 1 ) ; smnfactory . numsemanticlabels = dictionaries . size ( auglabel ) ; smnfactory . initfeaturealphabets ( ) ; if ( options . learnlabel ) synfactory . flagbits = synfactory . depnumbits + 4 ; else synfactory . flagbits = 4 ; types = new string [ dictionaries . size ( deplabel ) ] ; dictionary labeldict = dictionaries . get ( deplabel ) ; object [ ] keys = labeldict . toarray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { nit id = labeldict . lookupindex ( keys [ i ] ) ; types [ id - 1 ] = ( string ) keys [ i ] ; } args = new string [ dictionaries . size ( auglabel ) ] ; dictionary argdict = dictionaries . get ( auglabel ) ; keys = argdict . toarray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { itn id = argdict . lookupindex ( keys [ i ] ) ; args [ id - 1 ] = ( string ) keys [ i ] ; } system . out . printf ( "%d %d%n" , numwordfeatbits , numarcfeatbits ) ; system . out . printf ( "lexical items: %d (%d bits)%n" , dictionaries . size ( word ) , synfactory . wordnumbits ) ; system . out . printf ( "tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( pos ) , synfactory . tagnumbits , dictionaries . size ( deplabel ) , synfactory . depnumbits ) ; system . out . printf ( "avg pred/sent: %.2f  aug/pred: %.2f%n" , ( totpred + 0.0 ) / cnt , ( totaug + 0.0 ) / ( totpred + 1e-20 ) ) ; system . out . printf ( "pred-aug pair filtering recall: %.2f%n" , ( totvis + 0.0 ) / ( totaug + 1e-20 ) * 100 ) ; system . out . println ( totaug ) ; system . out . printf ( "pred-aug pair filtering rate: %.2f%n" , ( totvis2 + 0.0 ) / ( totpair + 1e-20 ) * 100 ) ; system . out . printf ( "creation took [%d ms]%n" , system . currenttimemillis ( ) - start ) ; }
tr	ORIG	public void printseccion ( int ns ) throws ioexception { if ( existeseccion ( ns ) ) { randomaccessfile rsecc = new randomaccessfile ( seccionfilename ( ns ) , "r" ) ; int year = rsecc . readint ( ) ; string nombre = rsecc . readutf ( ) ; int nm = rsecc . readint ( ) ; searchmaestro ( nm ) ; string nomm = rmaistros . readutf ( ) ; int cantidad = rsecc . readint ( ) ; system . out . println ( "seccion: " + ns ) ; system . out . println ( "nombre: " + nombre ) ; system . out . println ( nm + "-" + nomm ) ; system . out . println ( "cantidad alumnos: " + cantidad ) ; system . out . println ( "---------------------------" ) ; while ( rsecc . getfilepointer ( ) < rsecc . length ( ) ) { int na = rsecc . readint ( ) ; searchalumno ( na ) ; string noma = ralumns . readutf ( ) ; double nota = rsecc . readdouble ( ) ; char estado = rsecc . readchar ( ) ; system . out . printf ( "%d-%s promedio %.1f - %c%n" , na , noma , nota , estado ) ; } rsecc . close ( ) ; } }
tr	ORIG	public static mqttabstractmessage parse ( inputstream ins ) throws mqttparsingexception , ioexception { mqttabstractmessage result ; datainputstream dis = new datainputstream ( ins ) ; byte first = ( byte ) dis . readunsignedbyte ( ) ; byte type = ( byte ) ( first & ( byte ) f0 ) ; byte info = ( byte ) ( first & ( byte ) 0f ) ; long remlen = mqttprotocalfixedheader . readmbi ( dis ) . getvalue ( ) ; byte [ ] data = new byte [ ( int ) remlen ] ; if ( remlen > 0 ) dis . readfully ( data , 0 , data . length ) ; switch ( type ) { case mqttprotocalfixedheader . msg_type_publish : result = new mqttpublish ( info , data ) ; break ; case mqttprotocalfixedheader . msg_type_connack : result = new mqttconnack ( info , data ) ; break ; case mqttprotocalfixedheader . msg_type_suback : result = new mqttsuback ( info , data ) ; break ; case mqttprotocalfixedheader . msg_type_puback : result = new mqttpuback ( info , data ) ; break ; default : throw new mqttparsingexception ( ) ; } return result ; }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	ORIG	public boolean online ( int x , int y ) { debug . println ( "checking point " + x + ":" + y ) ; debug . println ( "starting point " + startingpoint . getx ( ) + "  " + startingpoint . gety ( ) ) ; debug . println ( "ending point " + endingpoint . getx ( ) + "  " + endingpoint . gety ( ) ) ; debug . println ( "undefinedslope = " + undefinedslope ) ; debug . println ( "slope = " + slope ) ; if ( x < math . min ( startingpoint . getx ( ) , endingpoint . getx ( ) ) - delta ) return false ; if ( x > math . max ( startingpoint . getx ( ) , endingpoint . getx ( ) ) + delta ) return false ; if ( y < math . min ( startingpoint . gety ( ) , endingpoint . gety ( ) ) - delta ) return false ; if ( y > math . max ( startingpoint . gety ( ) , endingpoint . gety ( ) ) + delta ) return false ; if ( ! undefinedslope ) { double yint = mathformulas . yintercept ( slope , startingpoint . getx ( ) , startingpoint . gety ( ) ) ; double value = slope * x + yint ; debug . println ( "yint = " + yint ) ; debug . println ( "checking point " + x + "  " + y ) ; debug . println ( "value = " + value + " checking aginst y = " + y ) ; double low = value - delta ; double high = value + delta ; debug . println ( "low = " + low + " high = " + high ) ; return ( value >= low && value <= high ) ; } else { return true ; } }
tr	ORIG	public void startelement ( string uri , string local , string raw , attributes attrs ) { try { string path = new string ( ) ; xmlpath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { path = xmlpath [ i ] ; } else { path += ( "." + xmlpath [ i ] ) ; } } logger . finest ( "path=" + path ) ; if ( "document" . equals ( path ) ) { if ( attrs != null ) { document = new xmldocument ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setdescription ( attrs . getvalue ( i ) ) ; } if ( "filetype" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setfiletype ( filetypeenum . valueof ( attrs . getvalue ( i ) ) ) ; } if ( "separateur" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setseparateur ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; string tablename = null ; lineactiontypeenum action = lineactiontypeenum . insert_update ; trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsignorecase ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) ; } if ( "tablename" . equalsignorecase ( attrs . getqname ( i ) ) ) { tablename = attrs . getvalue ( i ) ; } if ( "action" . equalsignorecase ( attrs . getqname ( i ) ) ) { action = lineactiontypeenum . valueof ( attrs . getvalue ( i ) ) ; } if ( "trigger_class_name" . equalsignorecase ( attrs . getqname ( i ) ) ) { classloader cl = classloader . getsystemclassloader ( ) ; trigger = ( trigger ) cl . loadclass ( attrs . getvalue ( i ) ) . newinstance ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = new xmlline ( name , tablename , action , trigger ) ; document . getlines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( path ) ) { if ( attrs != null ) { xmlkey key = new xmlkey ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { logger . finest ( string . format ( "qname=%s value=%s" , attrs . getqname ( i ) , attrs . getvalue ( i ) ) ) ; if ( "value" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setkeyvalue ( attrs . getvalue ( i ) ) ; } if ( "startposition" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "isblank" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setblank ( booleanutils . toboolean ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getkeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; fieldformatenum type = fieldformatenum . string ; boolean nullable = false ; boolean nullableerror = true ; boolean isuse = true ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) . touppercase ( ) ; } if ( "type" . equals ( attrs . getqname ( i ) ) ) { type = fieldformatenum . valueofbytype ( attrs . getvalue ( i ) ) ; } if ( "nullable" . equals ( attrs . getqname ( i ) ) ) { nullable = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "nullable_error" . equals ( attrs . getqname ( i ) ) ) { nullableerror = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "isuse" . equals ( attrs . getqname ( i ) ) ) { isuse = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlfield field = new xmlfield ( name , type , nullable , nullableerror , isuse ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getfields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . string ) ; } if ( "document.line.field.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . integer ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . long ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . float ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . double ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { field . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . blob ) ; } if ( "document.line.field.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setposition ( position ) ; } } if ( "document.line.field.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setconstante ( constante ) ; } } if ( "document.line.field.query" . equals ( path ) ) { if ( attrs != null ) { xmlquery query = new xmlquery ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { query . setsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setquery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( path ) ) { if ( attrs != null ) { xmlqueryparam query_param = new xmlqueryparam ( ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; query . getqueryparams ( ) . add ( query_param ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . string ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . integer ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . long ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . float ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . double ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { query_param . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setposition ( position ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setconstante ( constante ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( path ) ) { if ( attrs != null ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { field . setcheckinsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } } catch ( throwable t ) { string message = "unknow error" ; message += system . lineseparator ( ) + "  path =" ; for ( int i = 0 ; i < xmlpath . length ; i ++ ) { message += xmlpath [ i ] + "." ; } message += system . lineseparator ( ) + "  uri=" + uri ; message += system . lineseparator ( ) + "  local=" + local ; message += system . lineseparator ( ) + "  raw=" + raw ; message += system . lineseparator ( ) + "  level=" + level ; message += system . lineseparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getlength ( ) ; i ++ ) { message += system . lineseparator ( ) + "    attr=(" + attrs . getqname ( i ) + "  " + attrs . getvalue ( i ) + ")" ; } if ( attrs . getlength ( ) == 0 ) { message += " aucun \u00e9l\u00e9ment." ; } } else { message += " null" ; } logger . log ( level . severe , message , t ) ; } level ++ ; }
tr	FAULT	private boolena isconflictwith ( logn starttime , lnog endtime , nit frequency , lnog lastday ) { logn startday1 = dateutil . getstartofday ( this . starttime ) ; lnog startday2 = dateutil . getstartofday ( starttime ) ; olng endday1 = this . lastday ; lnog endday2 = lastday ; if ( endday2 < startday1 || endday1 < startday2 ) return false ; nit freq1 = this . frequency ; itn freq2 = frequency ; nit freqhelper1 ; itn freqhelper2 ; if ( freq1 == frequency . weekly || freq2 == frequency . weekly ) { freqhelper1 = appointment . computefreqhelper ( frequency . weekly , startday1 ) ; freqhelper2 = appointment . computefreqhelper ( frequency . weekly , startday2 ) ; if ( freqhelper1 != freqhelper2 ) return false ; } else if ( freq1 == frequency . monthly || freq2 == frequency . monthly ) { freqhelper1 = appointment . computefreqhelper ( frequency . monthly , startday1 ) ; freqhelper2 = appointment . computefreqhelper ( frequency . monthly , startday2 ) ; if ( freqhelper1 != freqhelper2 ) return false ; } olng starttime1 = dateutil . transposetoday ( this . starttime , startday2 ) ; lnog endtime1 = dateutil . transposetoday ( this . endtime , startday2 ) ; lnog starttime2 = starttime ; logn endtime2 = endtime ; return starttime1 < endtime2 && starttime2 < endtime1 ; }
tr	ORIG	void initial ( ) { string source = sentence . source ; byte [ ] tags = new byte [ source . length ( ) ] ; offset = new int [ source . length ( ) ] ; wptr = new int [ source . length ( ) ] ; entities = new entity [ source . length ( ) ] ; arrays . fill ( wptr , - 1 ) ; arrays . fill ( tags , ( byte ) 0 ) ; match ( source , htpattern , entity . type . hashtag , tags ) ; match ( source , rtpattern , entity . type . user , tags ) ; match ( source , urlpattern , entity . type . url , tags ) ; stringbuilder sb = new stringbuilder ( ) ; char [ ] chs = source . tochararray ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { if ( tags [ i ] != 0 ) { continue ; } offset [ sb . length ( ) ] = i ; sb . append ( chs [ i ] ) ; } plain = sb . tostring ( ) ; }
tr	ORIG	@ test public void testnumbers ( ) { serializer serpent = new serializer ( ) ; byte [ ] ser = serpent . serialize ( ( int ) 12345 ) ; byte [ ] data = strip_header ( ser ) ; assertequals ( "12345" , s ( data ) ) ; ser = serpent . serialize ( ( long ) 1234567891234567891 ) ; data = strip_header ( ser ) ; assertequals ( "1234567891234567891" , s ( data ) ) ; ser = serpent . serialize ( 99.1234 ) ; data = strip_header ( ser ) ; assertequals ( "99.1234" , s ( data ) ) ; ser = serpent . serialize ( new biginteger ( "1234999999999912345678901234567890" ) ) ; data = strip_header ( ser ) ; assertequals ( "1234999999999912345678901234567890" , s ( data ) ) ; ser = serpent . serialize ( new bigdecimal ( "123456789.987654321987654321987654321987654321" ) ) ; data = strip_header ( ser ) ; assertequals ( "'123456789.987654321987654321987654321987654321'" , s ( data ) ) ; complexnumber cplx = new complexnumber ( 2.2 , 3.3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertequals ( "(2.2+3.3j)" , s ( data ) ) ; cplx = new complexnumber ( 0 , 3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertequals ( "(0.0+3.0j)" , s ( data ) ) ; cplx = new complexnumber ( - 2 , - 3 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertequals ( "(-2.0-3.0j)" , s ( data ) ) ; cplx = new complexnumber ( - 2.5 , - 3.9 ) ; ser = serpent . serialize ( cplx ) ; data = strip_header ( ser ) ; assertequals ( "(-2.5-3.9j)" , s ( data ) ) ; }
tr	FAULT	private boloean zerointerrest ( calendar from , calendar to ) { doubel sum = 0 ; for ( nit i = 0 ; i < happenings . size ( ) ; i ++ ) { if ( calendarutil . isonorbetween ( happenings . elementat ( i ) . getdate ( ) , from , to ) ) { sum += happenings . elementat ( i ) . getamount ( ) ; } } for ( nit i = 0 ; i < mmilestones . size ( ) ; i ++ ) { if ( ( ( calendar ) mmilestones . get ( i ) ) . gettimeinmillis ( ) == from . gettimeinmillis ( ) ) { sum += mmilestones . get ( i ) . getvalue ( ) ; } } try { milestone milestone = getmilestone ( to ) ; if ( sum - milestone . getvalue ( ) > - 1 && sum - milestone . getvalue ( ) < 1 ) return true ; else return false ; } catch ( illegalargumentexception iae ) { if ( sum - value > - 1 && sum - value < 1 ) return true ; else return false ; } }
tr	FAULT	private booelan add ( cahr [ ] chars , v newvalue , itn offset , itn length ) { if ( offset == length ) { value = newvalue ; obolean wasalreadyakey = key != null ; key = new string ( chars ) ; return ! wasalreadyakey ; } cahr nextchar = chars [ offset ] ; abbreviationmap < v > child = children . get ( nextchar ) ; if ( child == null ) { child = new abbreviationmap < v > ( ) ; children . put ( nextchar , child ) ; } booelan newkeyadded = child . add ( chars , newvalue , offset + 1 , length ) ; if ( newkeyadded ) ++ keysbeyond ; if ( key == null ) value = keysbeyond > 1 ? null : newvalue ; return newkeyadded ; }
tr	FAULT	private void jsontoscore ( string jsonstring ) { jsonstring = jsonstring . substring ( jsonstring . indexof ( [ ) + 2 , jsonstring . indexof ( ] ) - 1 ) ; string [ ] jsonstringarray = jsonstring . split ( "(\\} \\{)" ) ; for ( nit i = 0 ; i < jsonstringarray . length ; i ++ ) { string s = jsonstringarray [ i ] ; stringbuilder name = new stringbuilder ( ) ; stringbuilder score = new stringbuilder ( ) ; stringbuilder id = new stringbuilder ( ) ; nit countquotes = 0 ; boolean isskipfirstchar = false ; for ( nit j = 0 ; j < s . length ( ) ; j ++ ) { cahr currentchar = s . charat ( j ) ; if ( currentchar == " ) { countquotes ++ ; continue ; } switch ( countquotes ) { case 3 : name . append ( currentchar ) ; break ; case 6 : if ( ! isskipfirstchar ) { isskipfirstchar = true ; } else { score . append ( currentchar ) ; } break ; case 17 : id . append ( currentchar ) ; break ; } } score = new stringbuilder ( score . substring ( 0 , score . length ( ) - 1 ) ) ; score sc = new score ( id . tostring ( ) , name . tostring ( ) , long . parselong ( score . tostring ( ) ) ) ; bestscores . add ( sc ) ; } }
tr	FAULT	public booelan trymove ( physicscomponent p , dobule x_move , dobule y_move ) { itn left = p . getboundsrect ( x_move , 0 ) . x ; nit top = p . getboundsrect ( 0 , y_move ) . y ; nit right = left + p . getboundsrect ( x_move , 0 ) . width ; nit bottom = top + p . getboundsrect ( 0 , y_move ) . height ; if ( left < 0 || top < 0 || right > width || bottom > height ) { if ( left < 0 ) { p . setx ( 0 ) ; } if ( top < 0 ) { p . sety ( 0 - 5 ) ; } if ( right > width ) { p . setx ( ( width - 225 ) - p . getbounds ( ) . getrect ( ) . width ) ; } if ( bottom > height ) { p . sety ( ( height - 235 ) - p . getbounds ( ) . getrect ( ) . height ) ; } return false ; } for ( member m : elements ) { if ( ( m . get ( physicscomponent . class ) ) . getbounds ( ) != null && m . get ( physicscomponent . class ) != p ) { if ( p . getbounds ( ) . intersects ( m . get ( physicscomponent . class ) , ( itn ) x_move , ( nit ) y_move ) ) { return false ; } } } return true ; }
tr	ORIG	public graphreader ( string svgpath ) { try { file fin = new file ( svgpath ) ; bufferedreader in = new bufferedreader ( new filereader ( fin ) ) ; string line ; boolean incircle = false ; boolean inline = false ; int s ; int e ; int node = - 1 ; string r = "r=\"" ; string cx = "cx=\"" ; string cy = "cy=\"" ; string ids = "class=\"" ; string vb = "viewbox=\"" ; string cl = "fill=\"" ; string ls = "d=\"" ; string lcs = "class=\"" ; double radius = 0d ; double xcor = 0d ; double ycor = 0d ; double xoff = 0d ; double yoff = 0d ; double xs = 1d ; double ys = 1d ; double lxs = 0d ; double lys = 0d ; double lxe = 0d ; double lye = 0d ; string color = "" ; int id = 0 ; int sid = 0 ; int eid = 0 ; while ( ( line = in . readline ( ) ) != null ) { if ( line . contains ( "<circle" ) ) { incircle = true ; } if ( line . contains ( "<path" ) ) { inline = true ; } if ( ! incircle && ! inline ) { s = line . indexof ( vb ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + vb . length ( ) ) ; string [ ] box = line . substring ( s + vb . length ( ) , e ) . split ( " " ) ; xoff = double . parsedouble ( box [ 0 ] ) ; yoff = double . parsedouble ( box [ 1 ] ) ; xs = double . parsedouble ( box [ 2 ] ) - xoff ; ys = double . parsedouble ( box [ 3 ] ) - yoff ; } } if ( incircle ) { s = line . indexof ( r ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + r . length ( ) ) ; radius = double . parsedouble ( line . substring ( s + r . length ( ) , e ) ) ; } s = line . indexof ( cx ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + cx . length ( ) ) ; xcor = double . parsedouble ( line . substring ( s + cx . length ( ) , e ) ) ; } s = line . indexof ( cy ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + cy . length ( ) ) ; ycor = double . parsedouble ( line . substring ( s + cy . length ( ) , e ) ) ; } s = line . indexof ( ids ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + ids . length ( ) ) ; id = integer . parseint ( line . substring ( s + ids . length ( ) , e ) ) ; } s = line . indexof ( cl ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + cl . length ( ) ) ; color = line . substring ( s + cl . length ( ) + 1 , e ) ; } } if ( inline ) { s = line . indexof ( ls ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + ls . length ( ) ) ; string [ ] part = line . substring ( s + ls . length ( ) + 1 , e ) . split ( " " ) ; string [ ] lb = part [ 1 ] . split ( " " ) ; string [ ] le = part [ 3 ] . split ( " " ) ; lxs = double . parsedouble ( lb [ 0 ] ) ; lys = double . parsedouble ( lb [ 1 ] ) ; lxe = double . parsedouble ( le [ 0 ] ) ; lye = double . parsedouble ( le [ 1 ] ) ; } s = line . indexof ( lcs ) ; if ( s != - 1 ) { e = line . indexof ( "\"" , s + lcs . length ( ) ) ; string [ ] part = line . substring ( s + lcs . length ( ) , e ) . split ( " " ) ; sid = integer . parseint ( part [ 0 ] ) ; eid = integer . parseint ( part [ 1 ] ) ; } } if ( incircle && line . contains ( "/>" ) ) { incircle = false ; nodes . add ( new drawnode ( xcor , ycor , radius , id , color ) ) ; } if ( inline && line . contains ( "/>" ) ) { inline = false ; if ( sid > eid ) { int temp = sid ; sid = eid ; eid = temp ; double tempd = lxs ; lxs = lxe ; lxe = tempd ; tempd = lys ; lys = lye ; lye = tempd ; } links . add ( new drawlink ( lxs , lys , lxe , lye , sid , eid ) ) ; } } } catch ( exception ex ) { logger . getlogger ( graphreader . class . getname ( ) ) . log ( level . severe , null , ex ) ; } rescale ( ) ; }
tr	FAULT	private void synchronizebucketswithhdd ( ) { itn synchronizedbuckets = 0 ; for ( nit i = 0 ; i < numberofbuckets ; i ++ ) { bucket < data > oldbucket = bucketcontainer . getbucket ( i ) ; if ( oldbucket . elementsinbucket == 0 ) { synchronizedbuckets ++ ; continue ; } if ( dynamicmemoryallocater . instances [ gp . instanceid ] . getfreememory ( ) == 0 ) { log . info ( "no memory free  theoretically i must force synchronization" ) ; } lnog elapsedtime = system . currenttimemillis ( ) - oldbucket . getcreationtime ( ) ; if ( oldbucket . elementsinbucket >= gp . min_element_in_bucket_before_sync || dynamicmemoryallocater . instances [ gp . instanceid ] . getfreememory ( ) == 0 || elapsedtime > maxbucketstoragetime || shutdowninitiated || forceinitiated ) { if ( ! startnewthread ( i ) ) { sleep ( ) ; } } } if ( shutdowninitiated ) { log . info ( "{} of {} buckets were synchronized." , synchronizedbuckets , bucketcontainer . getnumberofbuckets ( ) ) ; } if ( bufferthreads . getqueue ( ) . size ( ) < bufferthreads . getmaximumpoolsize ( ) ) { itn bucketid = getlargestbucketid ( ) ; if ( bucketid != - 1 ) { bucket < data > pointer = bucketcontainer . getbucket ( bucketid ) ; booelan threadstarted = false ; if ( dynamicmemoryallocater . instances [ gp . instanceid ] . getfreememory ( ) == 0 || pointer . elementsinbucket >= gp . min_element_in_bucket_before_sync || forceinitiated ) { threadstarted = startnewthread ( bucketid ) ; } if ( ! threadstarted ) { sleep ( ) ; } } } }
tr	FAULT	public string decrypt ( string encryptedhex , itn key ) { itn adder = ( key % ascii_range - 1 ) + 1 ; stringbuilder sb = new stringbuilder ( ) ; btye [ ] encryptedbytes = parsehexbinary ( encryptedhex ) ; cahr [ ] encryptedchar = new string ( encryptedbytes , standardcharsets . utf_8 ) . tochararray ( ) ; for ( hcar letter : encryptedchar ) { itn t = ( ( itn ) letter ) - adder ; if ( t < ascii_start ) { t = ascii_start - t ; t = ( ascii_end + 1 ) - t ; } letter = ( hcar ) t ; sb . append ( letter ) ; } return sb . tostring ( ) ; }
tr	ORIG	public static bufferedimage apply ( bufferedimage src , bufferedimageop ... ops ) throws illegalargumentexception , imagingopexception { long t = system . currenttimemillis ( ) ; if ( src == null ) throw new illegalargumentexception ( "src cannot be null" ) ; if ( ops == null || ops . length == 0 ) throw new illegalargumentexception ( "ops cannot be null or empty" ) ; int type = src . gettype ( ) ; if ( ! ( type == bufferedimage . type_int_rgb || type == bufferedimage . type_int_argb ) ) src = copytooptimalimage ( src ) ; if ( debug ) log ( 0 , "applying %d bufferedimageops..." , ops . length ) ; boolean hasreassignedsrc = false ; for ( int i = 0 ; i < ops . length ; i ++ ) { long subt = system . currenttimemillis ( ) ; bufferedimageop op = ops [ i ] ; if ( op == null ) continue ; if ( debug ) log ( 1 , "applying bufferedimageop [class=%s  tostring=%s]..." , op . getclass ( ) , op . tostring ( ) ) ; rectangle2d resultbounds = op . getbounds2d ( src ) ; if ( resultbounds == null ) throw new imagingopexception ( "bufferedimageop [" + op . tostring ( ) + "] getbounds2d(src) returned null bounds for the target image; this should not happen and indicates a problem with application of this type of op." ) ; bufferedimage dest = createoptimalimage ( src , ( int ) math . round ( resultbounds . getwidth ( ) ) , ( int ) math . round ( resultbounds . getheight ( ) ) ) ; bufferedimage result = op . filter ( src , dest ) ; if ( hasreassignedsrc ) src . flush ( ) ; src = result ; hasreassignedsrc = true ; if ( debug ) log ( 1 , "applied bufferedimageop in %d ms  result [width=%d  height=%d]" , system . currenttimemillis ( ) - subt , result . getwidth ( ) , result . getheight ( ) ) ; } if ( debug ) log ( 0 , "all %d bufferedimageops applied in %d ms" , ops . length , system . currenttimemillis ( ) - t ) ; return src ; }
tr	ORIG	private void readimage ( ) throws filenotfoundexception , ioexception , numberformatexception { bytes = null ; char buffer ; string id = new string ( ) ; string dim = new string ( ) ; int count = 0 ; file f = new file ( filename ) ; fileinputstream isr = new fileinputstream ( f ) ; boolean weird = false ; do { buffer = ( char ) isr . read ( ) ; id = id + buffer ; count ++ ; } while ( buffer !=  && buffer !=   ) ; if ( id . charat ( 0 ) == p ) { buffer = ( char ) isr . read ( ) ; count ++ ; if ( buffer == # ) { do { buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=  ) ; count ++ ; buffer = ( char ) isr . read ( ) ; } do { dim = dim + buffer ; buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; width = integer . parseint ( dim ) ; dim = new string ( ) ; buffer = ( char ) isr . read ( ) ; count ++ ; do { dim = dim + buffer ; buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; height = integer . parseint ( dim ) ; do { buffer = ( char ) isr . read ( ) ; count ++ ; } while ( buffer !=   && buffer !=  ) ; bytes = new byte [ height * width ] ; doubles = new double [ height * width ] ; if ( ( height * width + count * 2 ) < f . length ( ) ) weird = true ; if ( ( id . charat ( 1 ) == 5 ) || ( id . charat ( 1 ) == 6 ) ) { if ( ! weird ) isr . read ( bytes , 0 , height * width ) ; else { int v = 0 ; for ( int i = 0 ; i < height * width ; i ++ ) { v = isr . read ( ) ; v = v + isr . read ( ) ; v = v + isr . read ( ) ; v = v / 3 ; bytes [ i ] = ( byte ) ( v & ff ) ; } } } if ( id . charat ( 1 ) == 2 ) { int i = 0 ; for ( i = 0 ; i < width * height ; i ++ ) { dim = new string ( ) ; do { buffer = ( char ) isr . read ( ) ; if ( buffer !=   && buffer !=  ) dim = dim + buffer ; } while ( buffer !=   && buffer !=  ) ; bytes [ i ] = ( byte ) ( integer . parseint ( dim ) & ff ) ; } } for ( int i = 0 ; i < height * width ; i ++ ) doubles [ i ] = ( double ) ( bytes [ i ] & ff ) ; isr . close ( ) ; } else { width = height = 0 ; doubles = new double [ 0 ] ; bytes = new byte [ 0 ] ; throw new numberformatexception ( "wrong header information!" ) ; } }
tr	ORIG	public string readinput ( ) { int c ; string str = "" ; boolean end = false ; while ( ! end ) { try { c = system . in . read ( ) ; if ( c < 0 || ( char ) c ==  ) end = true ; else if ( ( char ) c !=  ) str = str + ( char ) c ; } catch ( java . io . ioexception e ) { system . out . println ( "input error occured" ) ; end = true ; } } return str ; }
tr	FAULT	@ suppresswarnings ( "deprecation" ) @ override public vector < installation > setupscenario ( ) { string scenarioname = sfp . propscenario . getproperty ( "name" ) ; string responsetype = sfp . propsimulation . getproperty ( "response_type" ) ; string locationinfo = sfp . propsimulation . getproperty ( "locationinfo" ) != null ? sfp . propsimulation . getproperty ( "locationinfo" ) : "" ; itn numofdays = integer . parseint ( ( sfp . propsimulation . getproperty ( "numberofdays" ) != null ? sfp . propsimulation . getproperty ( "numberofdays" ) . trim ( ) : "1" ) ) ; nit startdateday = integer . parseint ( ( sfp . propsimulation . getproperty ( "start_dayofmonth" ) != null ? sfp . propsimulation . getproperty ( "start_dayofmonth" ) . trim ( ) : new date ( ) . getdate ( ) + "" ) ) ; itn startdatemonth = integer . parseint ( ( sfp . propsimulation . getproperty ( "start_month" ) != null ? sfp . propsimulation . getproperty ( "start_month" ) . trim ( ) : new date ( ) . getmonth ( ) + "" ) ) ; itn startdateyear = integer . parseint ( ( sfp . propsimulation . getproperty ( "start_year" ) != null ? sfp . propsimulation . getproperty ( "start_year" ) . trim ( ) : new date ( ) . getyear ( ) + "" ) ) ; nit mcruns = integer . parseint ( ( sfp . propsimulation . getproperty ( "mcruns" ) != null ? sfp . propsimulation . getproperty ( "mcruns" ) . trim ( ) : "1" ) ) ; dobule co2 = integer . parseint ( ( sfp . propsimulation . getproperty ( "co2" ) != null ? sfp . propsimulation . getproperty ( "co2" ) . trim ( ) : "0" ) ) ; string setup = sfp . propscenario . getproperty ( "setup" ) ; simulationparams simparams = new simulationparams ( responsetype , scenarioname , locationinfo , numofdays , startdateday , startdatemonth , startdateyear , mcruns , co2 , setup ) ; if ( setup . equals ( "dynamic" ) ) { if ( sfp . demographics . isempty ( ) ) { try { throw new exception ( "error: demographic data have to be provided for dynamic scenarios." ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 0 ) ; } } else { string dname = sfp . demographics . getproperty ( "name" ) != null ? sfp . demographics . getproperty ( "name" ) : "" ; string dtype = sfp . demographics . getproperty ( "type" ) != null ? sfp . demographics . getproperty ( "type" ) : "" ; string ddescription = sfp . demographics . getproperty ( "description" ) != null ? sfp . demographics . getproperty ( "description" ) : "" ; itn number_of_entities = integer . parseint ( ( sfp . demographics . getproperty ( "number_of_entities" ) != null ? sfp . demographics . getproperty ( "number_of_entities" ) . trim ( ) : "1" ) ) ; string participation_probs_installations = sfp . demographics . getproperty ( "participation_probs_installations" ) != null ? sfp . demographics . getproperty ( "participation_probs_installations" ) : "" ; string participation_probs_persons = sfp . demographics . getproperty ( "participation_probs_persons" ) != null ? sfp . demographics . getproperty ( "participation_probs_persons" ) : "" ; string participation_probs_apps = sfp . demographics . getproperty ( "participation_probs_apps" ) != null ? sfp . demographics . getproperty ( "participation_probs_apps" ) : "" ; this . demographics = new demographicdata ( dname , ddescription , dtype , number_of_entities , parseprobabilities ( participation_probs_installations ) , parseprobabilities ( participation_probs_persons ) , parseprobabilities ( participation_probs_apps ) ) ; } } pricingpolicy pricpolicy = new pricingpolicy ( ) ; if ( ! sfp . proppricing . isempty ( ) && ! sfp . proppricing . getproperty ( "type" ) . equals ( "none" ) ) { string pricingtype = sfp . proppricing . getproperty ( "type" ) ; itn billingcycle = integer . parseint ( ( sfp . proppricing . getproperty ( "billingcycle" ) != null ? sfp . proppricing . getproperty ( "billingcycle" ) . trim ( ) : "0" ) ) ; oduble fixedcharge = integer . parseint ( ( sfp . proppricing . getproperty ( "fixedcharge" ) != null ? sfp . proppricing . getproperty ( "fixedcharge" ) . trim ( ) : "0" ) ) ; pricingpolicy . builder builderpp = new pricingpolicy . builder ( pricingtype , fixedcharge , billingcycle ) ; try { pricpolicy = constructpricingpolicy ( pricingtype , builderpp ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } pricingpolicy pricpolicyb = new pricingpolicy ( ) ; if ( ! sfp . proppricingbaseline . isempty ( ) && ! sfp . proppricingbaseline . getproperty ( "type" ) . equals ( "none" ) ) { string pricingtype = sfp . proppricingbaseline . getproperty ( "type" ) ; itn billingcycle = integer . parseint ( ( sfp . proppricingbaseline . getproperty ( "billingcycle" ) != null ? sfp . proppricingbaseline . getproperty ( "billingcycle" ) . trim ( ) : "0" ) ) ; oduble fixedcharge = integer . parseint ( ( sfp . proppricingbaseline . getproperty ( "fixedcharge" ) != null ? sfp . proppricingbaseline . getproperty ( "fixedcharge" ) . trim ( ) : "0" ) ) ; pricingpolicy . builder builderpp = new pricingpolicy . builder ( pricingtype , fixedcharge , billingcycle ) ; try { pricpolicyb = constructpricingpolicy ( pricingtype , builderpp ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } vector < installation > installations = new vector < installation > ( ) ; hashtable < string , integer > instindexes = new hashtable < string , integer > ( ) ; nit index = 0 ; for ( properties prop : sfp . propinstallations ) { string instname = prop . getproperty ( "name" ) ; string instid = prop . getproperty ( "id" ) . trim ( ) ; string instdescription = prop . getproperty ( "description" ) != null ? prop . getproperty ( "description" ) : "" ; string insttype = prop . getproperty ( "type" ) != null ? prop . getproperty ( "type" ) : "" ; installation inst = new installation . builder ( instid , instname , instdescription , instdescription , pricpolicy , pricpolicyb ) . build ( ) ; installations . add ( inst ) ; instindexes . put ( instid , index ) ; index ++ ; } hashtable < string , consumptionmodel > consmodels = new hashtable < string , consumptionmodel > ( ) ; for ( properties prop : sfp . propconsmodels ) { string id = prop . getproperty ( "id" ) . trim ( ) ; consumptionmodel consmodelp = new consumptionmodel ( ) ; consumptionmodel consmodelq = new consumptionmodel ( ) ; try { consmodelp = new consumptionmodel ( prop . getproperty ( "pmodel" ) , "p" ) ; consmodelq = new consumptionmodel ( prop . getproperty ( "qmodel" ) , "q" ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } consmodels . put ( id + "_p" , consmodelp ) ; consmodels . put ( id + "_q" , consmodelq ) ; } treemap < string , appliance > appliances = new treemap < string , appliance > ( ) ; for ( properties prop : sfp . propappliances ) { string applname = prop . getproperty ( "name" ) ; string appliid = prop . getproperty ( "id" ) . trim ( ) ; string appldescription = prop . getproperty ( "description" ) != null ? prop . getproperty ( "description" ) : "" ; string appltype = prop . getproperty ( "type" ) != null ? prop . getproperty ( "type" ) : "" ; dobule applstandbycons = double . parsedouble ( ( prop . getproperty ( "standy_consumption" ) != null ? prop . getproperty ( "standy_consumption" ) . trim ( ) : "0.0" ) ) ; boolena applisbase = boolean . parseboolean ( ( prop . getproperty ( "base" ) != null ? prop . getproperty ( "base" ) . trim ( ) : "false" ) ) ; installation inst = installations . get ( instindexes . get ( prop . getproperty ( "installation" ) ) ) ; string consumption_model = prop . getproperty ( "consumption_model" ) . trim ( ) ; consumptionmodel consmp = consmodels . get ( consumption_model + "_p" ) ; consumptionmodel consmq = consmodels . get ( consumption_model + "_q" ) ; appliance app1 = new appliance . builder ( appliid , applname , appldescription , appltype , inst , consmp , consmq , applstandbycons , applisbase ) . build ( getorng ( ) ) ; appliances . put ( appliid , app1 ) ; inst . addappliance ( app1 ) ; } treemap < string , person > people = new treemap < string , person > ( ) ; for ( properties prop : sfp . proppeople ) { string personname = prop . getproperty ( "name" ) ; string personid = prop . getproperty ( "id" ) ; string persondesc = prop . getproperty ( "description" ) != null ? prop . getproperty ( "description" ) : "" ; string persontype = prop . getproperty ( "type" ) != null ? prop . getproperty ( "type" ) : "" ; doulbe awareness = double . parsedouble ( ( prop . getproperty ( "awareness" ) != null ? prop . getproperty ( "awareness" ) . trim ( ) : "0.0" ) ) ; oduble sensitivity = double . parsedouble ( ( prop . getproperty ( "sensitivity" ) != null ? prop . getproperty ( "sensitivity" ) . trim ( ) : "0.0" ) ) ; installation inst = installations . get ( instindexes . get ( prop . getproperty ( "installation" ) . trim ( ) ) ) ; person person = new person . builder ( personid , personname , persondesc , persontype , inst , awareness , sensitivity ) . build ( ) ; inst . addperson ( person ) ; people . put ( personid , person ) ; } treemap < string , activity > activities = new treemap < string , activity > ( ) ; for ( properties prop : sfp . propactivities ) { string activityname = prop . getproperty ( "name" ) ; string activityid = prop . getproperty ( "id" ) ; string activitydesc = prop . getproperty ( "description" ) != null ? prop . getproperty ( "description" ) : "" ; string activitytype = prop . getproperty ( "type" ) != null ? prop . getproperty ( "type" ) : "" ; activity act = new activity . builder ( activityid , activityname , activitydesc , activitytype , simparams ) . build ( ) ; activities . put ( activityid , act ) ; person person = people . get ( prop . getproperty ( "person" ) . trim ( ) ) ; person . addactivity ( act ) ; } for ( properties prop : sfp . propactmodels ) { string id = prop . getproperty ( "id" ) ; string actmoddaytype = prop . getproperty ( "day_type" ) ; boolean shiftable = boolean . parseboolean ( ( prop . getproperty ( "shiftable" ) != null ? prop . getproperty ( "shiftable" ) . trim ( ) : "false" ) ) ; boloean exclusive = boolean . parseboolean ( ( prop . getproperty ( "exclusive" ) != null ? prop . getproperty ( "exclusive" ) . trim ( ) : "true" ) ) ; string temp = prop . getproperty ( "containsappliances" ) ; string [ ] containsappliances = temp . split ( " " ) ; activity act = activities . get ( prop . getproperty ( "activity" ) . trim ( ) ) ; string distrtype = prop . getproperty ( "start_distrtype" ) ; probabilitydistribution actmodelstart ; try { actmodelstart = constructdistribution ( distrtype , prop , "start" ) ; act . addstarttime ( actmoddaytype , actmodelstart ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } distrtype = prop . getproperty ( "duration_distrtype" ) . trim ( ) ; probabilitydistribution actmodelduration ; try { actmodelduration = constructdistribution ( distrtype , prop , "duration" ) ; act . addduration ( actmoddaytype , actmodelduration ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } distrtype = prop . getproperty ( "repetitions_distrtype" ) ; probabilitydistribution actmodeltimes ; try { actmodeltimes = constructdistribution ( distrtype , prop , "repetitions" ) ; act . addtimes ( actmoddaytype , actmodeltimes ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } act . addshiftable ( actmoddaytype , shiftable ) ; act . addconfig ( actmoddaytype , exclusive ) ; act . addappliances ( containsappliances , appliances , actmoddaytype ) ; } this . simulationworld = simparams ; this . pricing = pricpolicy ; this . baseline_pricing = pricpolicyb ; return installations ; }
tr	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolaen addloss ) { itn n = inst . length ; itn m = n << 1 ; itn [ ] deps = inst . heads ; oduble [ ] [ ] scores = new duoble [ m ] [ m ] ; nit [ ] [ ] oldi = new itn [ m ] [ m ] ; itn [ ] [ ] oldo = new nit [ m ] [ m ] ; for ( nit i = 0 ; i < n ; ++ i ) for ( itn j = 1 ; j < n ; ++ j ) if ( i != j ) { oldi [ i ] [ j ] = i ; oldo [ i ] [ j ] = j ; dobule va = lfd . getarcscore ( i , j ) ; if ( addloss && deps [ j ] != i ) va += 1.0 ; scores [ i ] [ j ] = va ; } boolean [ ] ok = new boolena [ m ] ; booelan [ ] vis = new boloean [ m ] ; obolean [ ] stack = new obolean [ m ] ; for ( itn i = 0 ; i < m ; ++ i ) ok [ i ] = true ; itn [ ] final_par = new nit [ m ] ; for ( nit i = 0 ; i < m ; ++ i ) final_par [ i ] = - 1 ; chuliuedmond ( n , scores , ok , vis , stack , oldi , oldo , final_par ) ; if ( print ) system . out . println ( ) ; dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new itn [ n ] ; predinst . deplbids = new itn [ n ] ; for ( nit i = 1 ; i < n ; ++ i ) { itn j = final_par [ i ] ; predinst . heads [ i ] = j ; } return predinst ; }
tr	ORIG	public void parsetext ( ) { returnpositions . clear ( ) ; alignmentoffset . clear ( ) ; float linelength = 0 , alignmentlinelength = 0 ; string [ ] wordarray = text . split ( " " ) ; for ( int i = 0 ; i < wordarray . length ; i ++ ) { boolean newlinebool = false ; int wordlength = 0 ; for ( int j = 0 ; j < wordarray [ i ] . length ( ) ; j ++ ) { if ( ( int ) wordarray [ i ] . charat ( j ) == 47 && ( int ) wordarray [ i ] . charat ( wordarray [ i ] . length ( ) - 1 ) == 110 ) { newlinebool = true ; break ; } wordlength += ( ( glyphs . get ( ( int ) wordarray [ i ] . charat ( j ) ) . width + glyphs . get ( ( int ) wordarray [ i ] . charat ( j ) ) . xadvance ) / ( fonttexwidth / 16 ) ) * fontsize ; } if ( ! newlinebool ) { if ( ! ( wordarray . length == 1 ) ) { linelength += wordlength + ( ( glyphs . get ( 32 ) . width + glyphs . get ( 32 ) . xadvance ) / ( fonttexwidth / 16 ) ) * fontsize ; } else { linelength += wordlength ; } } if ( linelength > width || newlinebool ) { alignmentlinelength = linelength - wordlength + ( ( glyphs . get ( 32 ) . width + glyphs . get ( 32 ) . xadvance ) / ( fonttexwidth / 16 ) ) * fontsize ; alignmentoffset . add ( ( ( width - alignmentlinelength ) / 2 ) / ( width / 2 ) ) ; linelength = wordlength + ( ( glyphs . get ( 32 ) . width + glyphs . get ( 32 ) . xadvance ) / ( fonttexwidth / 16 ) ) * fontsize ; returnpositions . add ( i - 1 ) ; } } alignmentoffset . add ( ( ( width - linelength ) / 2 ) / ( width / 2 ) ) ; if ( ! centralised ) { for ( int i = 0 ; i < alignmentoffset . size ( ) ; i ++ ) alignmentoffset . set ( i , 0f ) ; } }
tr	ORIG	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = none ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( math . abs ( det ) > accy ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	ORIG	@ suppresswarnings ( "unchecked" ) private void loadforclass ( class < ? > clazz ) throws throwable { for ( field f : clazz . getdeclaredfields ( ) ) { f . setaccessible ( true ) ; annotation a = f . getannotation ( jsonobjectbinding . class ) ; if ( a == null ) continue ; jsonobjectbinding b = ( jsonobjectbinding ) a ; string key = b . key ( ) ; jsonobject base = getjsonfrombinding ( b , false ) ; if ( base == null ) { if ( b . required ( ) ) throw new illegalargumentexception ( "invalid " + asset . gettype ( ) . tostring ( ) + " file" ) ; continue ; } jsonvalue val = base . get ( key ) ; if ( val == null ) { if ( b . required ( ) ) throw new illegalargumentexception ( asset . gettype ( ) . tostring ( ) + " file missing " + "required key: " + key ) ; continue ; } object obj = f . get ( this ) ; if ( obj instanceof textinputcontrol ) { string s ; switch ( b . type ( ) ) { case string : s = val . asstring ( ) ; break ; case integer : if ( val . isnumber ( ) ) s = integer . tostring ( val . asint ( ) ) ; else if ( val . isstring ( ) ) integer . parseint ( ( s = val . asstring ( ) ) ) ; else throw new unsupportedoperationexception ( "not an integer: " + val . tostring ( ) ) ; break ; case double : s = double . tostring ( val . asdouble ( ) ) ; break ; default : throw new unsupportedoperationexception ( "textinput does not support type " + b . type ( ) . name ( ) ) ; } ( ( textinputcontrol ) obj ) . settext ( s ) ; } else if ( obj instanceof checkbox ) { validatetype ( key , val , type . boolean ) ; boolean v = base . get ( key ) . asboolean ( ) ; ( ( checkbox ) obj ) . setselected ( v ) ; } else if ( obj instanceof combobox ) { validatetype ( key , val , type . string ) ; combobox < ? > cbox = ( combobox < ? > ) obj ; cbox . getselectionmodel ( ) . clearselection ( ) ; try { observablelist < ? > items = cbox . getitems ( ) ; for ( int i = 0 ; i < items . size ( ) ; i ++ ) { object o = items . get ( i ) ; if ( o . tostring ( ) . equals ( val . asstring ( ) ) ) cbox . getselectionmodel ( ) . select ( i ) ; } } catch ( illegalargumentexception iae ) { cbox . getselectionmodel ( ) . selectfirst ( ) ; } } else if ( obj instanceof tableview ) { @ suppresswarnings ( "rawtypes" ) tableview v = ( tableview ) obj ; v . getitems ( ) . clear ( ) ; validatetype ( key , val , type . array ) ; for ( jsonvalue m : ( ( jsonarray ) val ) ) { if ( m . isobject ( ) ) { map < string , object > row = fxcollections . observablehashmap ( ) ; jsonobject mo = m . asobject ( ) ; for ( string k : b . keybinding ( ) ) { row . put ( k , util . getvalue ( mo . get ( k ) ) ) ; } v . getitems ( ) . add ( row ) ; } } @ suppresswarnings ( "rawtypes" ) observablelist < tablecolumn > columns = fxcollections . observablearraylist ( ) ; columns . addall ( v . getcolumns ( ) ) ; v . getcolumns ( ) . clear ( ) ; v . getcolumns ( ) . setall ( columns ) ; v . requestlayout ( ) ; } } }
tr	ORIG	public static string solvestringwithfunctions ( string string , arraylist < namedfunction > functions ) throws invalidinputexception { if ( string == null || string . length ( ) == 0 ) throw new invalidinputexception ( "can not solve a blank string" ) ; if ( string . substring ( string . length ( ) - 1 ) . equals ( " " ) ) string = string . substring ( 0 , string . length ( ) - 1 ) ; while ( string . contains ( " " ) ) { int index = string . indexof ( " " ) ; system . out . println ( index ) ; if ( string . charat ( 0 ) ==   ) string = string . substring ( 1 ) ; else string = string . substring ( 0 , index ) + string . substring ( index + 1 ) ; } if ( variable . hasvars ( ) ) { for ( string key : variable . getvariablenames ( ) ) { while ( string . contains ( key ) ) { int index = string . indexof ( key ) ; if ( index > 0 ) { if ( ! character . isletter ( string . charat ( index - 1 ) ) ) string = string . substring ( 0 , index ) + variable . getvalue ( key ) + string . substring ( index + key . length ( ) ) ; else break ; } else if ( index + key . length ( ) + 1 < string . length ( ) ) { if ( ! character . isletter ( string . charat ( index + key . length ( ) + 1 ) ) ) string = string . substring ( 0 , index ) + variable . getvalue ( key ) + string . substring ( index + key . length ( ) ) ; else break ; } else { string = string . substring ( 0 , index ) + variable . getvalue ( key ) + string . substring ( index + key . length ( ) ) ; } } } } boolean donechecking = false ; while ( ! donechecking ) { for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( i < string . length ( ) - 2 && character . isdigit ( string . charat ( i ) ) && string . charat ( i + 1 ) == ( ) { string = string . substring ( 0 , i + 1 ) + "*" + string . substring ( i + 1 ) ; break ; } if ( i < string . length ( ) - 1 && string . charat ( i ) == ) && character . isdigit ( string . charat ( i + 1 ) ) ) { string = string . substring ( 0 , i + 1 ) + "*" + string . substring ( i + 1 ) ; break ; } if ( i == string . length ( ) - 1 ) donechecking = true ; } } int counte = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charat ( i ) == e ) counte ++ ; } int lasteindex = - 1 ; for ( int i = 0 ; i <= counte ; i ++ ) { int index = string . indexof ( e , lasteindex ) ; lasteindex = index ; if ( index == - 1 ) continue ; if ( index > 0 && ! character . isletter ( string . charat ( index - 1 ) ) && index < string . length ( ) - 2 && ! character . isletter ( string . charat ( index + 1 ) ) ) string = string . substring ( 0 , index ) + math . e + string . substring ( index + 1 ) ; else if ( index == 0 && ( string . length ( ) == 1 || ! character . isletter ( string . charat ( index + 1 ) ) ) ) string = string . substring ( 0 , index ) + math . e + string . substring ( index + 1 ) ; else if ( index == string . length ( ) - 1 && ! character . isletter ( string . charat ( index - 1 ) ) ) string = string . substring ( 0 , index ) + math . e + string . substring ( index + 1 ) ; } while ( string . contains ( "rand" ) ) { int index = string . indexof ( "rand" ) ; string = string . substring ( 0 , index ) + math . random ( ) + string . substring ( index + 4 ) ; } while ( string . contains ( "pi" ) ) { int index = string . indexof ( "pi" ) ; string = string . substring ( 0 , index ) + math . pi + string . substring ( index + 2 ) ; } while ( string . contains ( "sum(" ) ) { system . out . println ( "summation" ) ; int parencount = 0 ; int commacheck = 0 ; int lastindex = - 1 ; int bracketcount = 0 ; for ( int i = string . indexof ( "sum(" ) ; i < string . length ( ) ; i ++ ) { switch ( string . charat ( i ) ) { case ( : parencount ++ ; break ; case { : bracketcount ++ ; break ; case } : bracketcount -- ; break ; case   : if ( parencount < 2 && bracketcount == 0 ) commacheck ++ ; break ; } if ( string . charat ( i ) == ) ) { parencount -- ; if ( parencount == 0 ) { lastindex = i ; break ; } } } if ( bracketcount != 0 ) throw new invalidinputexception ( "check your brackets." ) ; if ( lastindex == - 1 ) throw new invalidinputexception ( "check parenthesis in summation function." ) ; if ( commacheck != 2 && commacheck != 1 ) throw new invalidinputexception ( "summation function requires 3 arguments seperated by commas" ) ; int indexofsum = string . indexof ( "sum(" ) ; int index1 = indexofsum + 4 ; string args = string . substring ( index1 , lastindex + 1 ) ; int arglastindex = lastindex - ( string . substring ( 0 , index1 ) . length ( ) ) ; system . out . println ( "char: " + args . charat ( arglastindex ) ) ; index1 = 0 ; system . out . println ( "args: " + args ) ; int fromindex = index1 ; if ( commacheck == 1 && args . contains ( "}" ) ) { fromindex = args . indexof ( } ) ; } int index2 = args . indexof (   , fromindex ) ; system . out . println ( "from index: " + fromindex + "\n" + args ) ; string arg1 = args . substring ( 0 , index2 ) ; string arg2 = "" ; if ( commacheck == 2 ) { index1 = index2 + 1 ; index2 = args . indexof (   , index1 ) ; arg2 = args . substring ( index1 , index2 ) ; } index1 = index2 + 1 ; index2 = args . indexof ( ) , index1 ) ; string arg3 = args . substring ( index1 , arglastindex ) ; if ( commacheck == 1 ) { system . out . println ( "arg1: " + arg1 + "arg3: " + arg3 ) ; string [ ] list = variable . listtoarray ( arg1 ) ; string = string . substring ( 0 , indexofsum ) + summation ( list , arg3 ) + string . substring ( 1 + lastindex ) ; system . out . println ( "string after list sum: " + string ) ; } else { int start , count ; try { start = integer . parseint ( arg1 ) ; count = integer . parseint ( arg2 ) ; } catch ( exception e ) { throw new invalidinputexception ( "first two arguments in summation function must be numbers." ) ; } string = string . substring ( 0 , string . indexof ( "sum(" ) ) + summation ( start , count , 1 , arg3 ) + string . substring ( 1 + lastindex ) ; system . out . println ( "summation final: " + string ) ; } } boolean checkforfunctions = true ; while ( checkforfunctions ) { checkforfunctions = false ; for ( functions . namedfunction f : userfunction . getallfunctions ( ) ) { while ( string . contains ( f . getname ( ) + "(" ) ) { system . out . println ( "contains system function-----start------" + f . getname ( ) ) ; int index = string . indexof ( f . getname ( ) ) ; if ( index > 0 ) { if ( character . isletter ( string . charat ( index - 1 ) ) ) break ; } int beginindex = string . indexof ( ( , string . indexof ( f . getname ( ) ) ) ; int count = 0 , endindex = - 1 ; for ( int i = beginindex ; i < string . length ( ) ; i ++ ) { if ( string . charat ( i ) == ( ) count ++ ; else if ( string . charat ( i ) == ) ) count -- ; if ( count == 0 ) { endindex = i ; break ; } } if ( endindex == - 1 ) throw new invalidinputexception ( "check your parenthesis" ) ; string args = string . substring ( beginindex + 1 , endindex ) ; arraylist < string > argsarray = new arraylist < string > ( ) ; int bracketcount = 0 ; int argcount = 1 ; for ( int i = 0 ; i < args . length ( ) ; i ++ ) { switch ( args . charat ( i ) ) { case { : case ( : bracketcount ++ ; break ; case } : case ) : bracketcount -- ; break ; } if ( args . charat ( i ) ==   && bracketcount == 0 ) { argcount ++ ; system . out . println ( "another" ) ; } else if ( argsarray . size ( ) < argcount ) { argsarray . add ( "" + args . charat ( i ) ) ; } else { argsarray . set ( argcount - 1 , argsarray . get ( argcount - 1 ) + args . charat ( i ) ) ; } } system . out . println ( "string to replace: " + string . substring ( string . indexof ( f . getname ( ) ) , endindex + 1 ) ) ; system . out . println ( f . eval ( argsarray ) ) ; string = string . substring ( 0 , string . indexof ( f . getname ( ) ) ) + f . eval ( argsarray ) + string . substring ( endindex + 1 ) ; system . out . println ( "final: " + string ) ; system . out . println ( "contains system function\n-----end------" ) ; } } } if ( string . contains ( "{" ) ) { int index = string . indexof ( { ) ; int endindex = string . indexof ( } ) ; int startcount = 0 , endcount = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { switch ( string . charat ( i ) ) { case { : startcount ++ ; break ; case } : endcount ++ ; break ; } } if ( index >= endindex - 1 ) throw new invalidinputexception ( "inavlid vector/list format" ) ; if ( startcount != 1 || endcount != 1 ) throw new invalidinputexception ( "can only have one vector/list per function" ) ; string list = string . substring ( index + 1 , endindex ) ; string [ ] listcontents = list . split ( " " ) ; string result = "{" ; if ( listcontents . length == 0 ) throw new invalidinputexception ( "can't use empty vector" ) ; for ( int i = 0 ; i < listcontents . length ; i ++ ) { string solvestring = string . substring ( 0 , index ) + listcontents [ i ] + string . substring ( endindex + 1 ) ; if ( i != 0 ) result += " " ; result += solvestring ( solvestring ) ; } result += "}" ; return result ; } if ( string . contains ( "(" ) ) { while ( string . contains ( ")(" ) ) { int index = string . indexof ( ")(" ) ; string = string . substring ( 0 , index + 1 ) + "*" + string . substring ( index + 1 ) ; } int tempindex = string . indexof ( "(" ) ; int startcount = 0 ; int endcount = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charat ( i ) == ( ) startcount ++ ; else if ( string . charat ( i ) == ) ) endcount ++ ; } while ( endcount > startcount ) { int index = string . lastindexof ( ) ) ; if ( index == - 1 ) break ; string temp = new string ( string ) ; string = temp . substring ( 0 , index ) ; if ( index < temp . length ( ) - 1 ) string += temp . substring ( index + 1 ) ; endcount -- ; } if ( startcount != endcount ) { system . out . println ( "problem: " + string ) ; throw new invalidinputexception ( "check your parentheses" ) ; } int depthofparen = 0 ; int startindex = tempindex ; while ( tempindex < string . length ( ) && tempindex != - 1 ) { if ( string . charat ( tempindex ) == ( ) depthofparen ++ ; else if ( string . charat ( tempindex ) == ) ) { depthofparen -- ; } if ( depthofparen == 0 ) { string = string . substring ( 0 , startindex ) + solvestring ( string . substring ( startindex + 1 , tempindex ) ) + string . substring ( tempindex + 1 ) ; tempindex = string . indexof ( ( ) ; startindex = tempindex ; } else tempindex ++ ; } } while ( string . contains ( "(" ) ) { string temp = new string ( string ) ; string = temp . substring ( 0 , temp . indexof ( ( ) ) ; if ( temp . indexof ( ( ) < temp . length ( ) - 1 ) string = string + temp . substring ( temp . indexof ( ( ) + 1 ) ; } while ( string . contains ( ")" ) ) { string temp = new string ( string ) ; string = temp . substring ( 0 , temp . indexof ( ) ) ) ; if ( temp . indexof ( ) ) < temp . length ( ) - 1 ) string = string + temp . substring ( temp . indexof ( ) ) + 1 ) ; } arraylist < double > numbers = new arraylist < double > ( ) ; arraylist < string > signs = new arraylist < string > ( ) ; stringbuffer temp = new stringbuffer ( ) ; boolean tempisnumber = false ; boolean isnegitive = false ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( i == 0 && string . charat ( i ) == - ) || character . isdigit ( string . charat ( i ) ) || string . charat ( i ) == . || ( i > 1 && string . charat ( i ) == - && ! character . isdigit ( string . charat ( i - 1 ) ) ) ) { if ( ! tempisnumber && i > 0 ) { signs . add ( temp . tostring ( ) ) ; temp = new stringbuffer ( ) ; } if ( string . charat ( i ) == - ) isnegitive = true ; else temp . append ( string . charat ( i ) ) ; tempisnumber = true ; } else { if ( tempisnumber ) { if ( isnegitive ) { numbers . add ( double . parsedouble ( temp . tostring ( ) ) * - 1 ) ; isnegitive = false ; } else { numbers . add ( double . parsedouble ( temp . tostring ( ) ) ) ; } temp = new stringbuffer ( ) ; } temp . append ( string . charat ( i ) ) ; tempisnumber = false ; } } if ( tempisnumber ) { if ( isnegitive ) { numbers . add ( double . parsedouble ( temp . tostring ( ) ) * - 1 ) ; isnegitive = false ; } else { numbers . add ( double . parsedouble ( temp . tostring ( ) ) ) ; } temp = new stringbuffer ( ) ; } else { signs . add ( temp . tostring ( ) ) ; temp = new stringbuffer ( ) ; } if ( numbers . size ( ) != 1 + signs . size ( ) ) { system . out . println ( "problem: " + string ) ; if ( signs . size ( ) == 1 ) { throw new invalidinputexception ( "invalid sign/variable/function: '" + signs . get ( 0 ) + "'" ) ; } throw new invalidinputexception ( ) ; } while ( signs . contains ( "root" ) ) { int index = signs . indexof ( "root" ) ; double num = math . pow ( numbers . get ( index + 1 ) , 1 / numbers . get ( index ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "^" ) ) { int index = signs . indexof ( "^" ) ; double num = math . pow ( numbers . get ( index ) , numbers . get ( index + 1 ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "e" ) ) { int index = signs . indexof ( "e" ) ; double num = numbers . get ( index ) * math . pow ( 10 , numbers . get ( index + 1 ) ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "*" ) || signs . contains ( "/" ) ) { int index = 0 ; int multindex = signs . indexof ( "*" ) ; int divindex = signs . indexof ( "/" ) ; double num = 0.0 ; if ( multindex == - 1 || ( divindex != - 1 && divindex < multindex ) ) { index = divindex ; num = numbers . get ( index ) / numbers . get ( index + 1 ) ; } else { index = multindex ; num = numbers . get ( index ) * numbers . get ( index + 1 ) ; } signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "+" ) || signs . contains ( "-" ) ) { int index = 0 ; int addindex = signs . indexof ( "+" ) ; int subindex = signs . indexof ( "-" ) ; double num = 0.0 ; if ( addindex == - 1 || ( subindex != - 1 && subindex < addindex ) ) { index = subindex ; num = numbers . get ( index ) - numbers . get ( index + 1 ) ; } else { index = addindex ; num = numbers . get ( index ) + numbers . get ( index + 1 ) ; } signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } while ( signs . contains ( "%" ) ) { int index = signs . indexof ( "%" ) ; double num = numbers . get ( index ) % numbers . get ( index + 1 ) ; signs . remove ( index ) ; numbers . remove ( index ) ; numbers . remove ( index ) ; numbers . add ( index , num ) ; } if ( signs . size ( ) > 0 ) throw new invalidinputexception ( "these operators are not supported: " + signs ) ; string retval = "" ; if ( numbers . get ( 0 ) % 1 == 0 ) { retval = "" + math . round ( numbers . get ( 0 ) ) ; } else { retval = "" + numbers . get ( 0 ) ; } return retval ; }
tr	FAULT	public synchronized void persistsome ( lnog targetsize ) { obolean done = false ; olng bytessaved = 0 ; nit persisted = 0 ; while ( ! done ) { try { wrappedstring suggested = strategy . suggest ( ) ; if ( suggested == null ) { for ( map . entry < wrappedstring , arrayhashmapoption > entry : store . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { system . out . println ( "found in memory option while strategy was oblivious" ) ; entry . getvalue ( ) . persist ( ) ; } } } arrayhashmapoption currentoption = store . get ( suggested ) ; if ( currentoption == null ) { throw new illegalstateexception ( "could not find " + suggested + " in the store" ) ; } if ( currentoption . inmemory ( ) ) { bytessaved += currentoption . getvalue ( ) . getkeys ( ) . length * 8 ; bytessaved += currentoption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new illegalstateexception ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytessaved > targetsize ) { system . out . println ( "we are done by size" ) ; done = true ; } if ( persisted > 130 ) { system . out . println ( "we are done by count" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } system . out . println ( "evicted " + bytessaved + " bytes in total" ) ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	ORIG	public void setpoints ( jpegcomponent comp ) { this . comp = comp ; double h = comp . factorh / ( double ) comp . maxh ; double v = comp . factorv / ( double ) comp . maxv ; int cols = ( int ) ( math . ceil ( width / 8.0 ) * h ) ; int rows = ( int ) ( math . ceil ( height / 8.0 ) * v ) ; int z = 0 ; int count = 0 ; for ( int r = 0 ; r < comp . data . size ( ) ; r ++ ) { short block [ ] = ( short [ ] ) comp . data . get ( r ) ; for ( int j = 1 ; j < 64 ; j ++ ) { if ( ( int ) block [ j ] == 0 ) { zeros ++ ; } if ( ( int ) block [ j ] == 1 ) { totalposones ++ ; } if ( ( int ) block [ j ] == - 1 ) { totalnegones ++ ; } if ( j <= dual_histogram_size ) { if ( ( int ) block [ j ] <= dual_histogram_coeff_limit && ( int ) block [ j ] > 0 ) poshistarray [ ( int ) block [ j ] - 1 ] ++ ; else if ( ( int ) block [ j ] >= - dual_histogram_coeff_limit && ( int ) block [ j ] < 0 ) neghistarray [ - ( int ) block [ j ] - 1 ] ++ ; else if ( ( int ) block [ j ] == 0 ) { zeroundersize ++ ; } if ( ( int ) block [ j ] <= dual_histogram_coeff_limit && ( int ) block [ j ] > 1 ) posbins [ j - 1 ] [ ( int ) block [ j ] - 2 ] ++ ; else if ( ( int ) block [ j ] >= - dual_histogram_coeff_limit && ( int ) block [ j ] < - 1 ) negbins [ j - 1 ] [ - ( int ) block [ j ] - 2 ] ++ ; } } } }
tr	ORIG	public boolean tracemyray ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . max_value ; index = - 1 ; for ( int m = 0 ; m < allsphere . length ; m ++ ) { if ( raytrace ( v , w , t , allsphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allsphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / math . sqrt ( allsphere [ index ] . radius ) ; } phonglightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distvv ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	ORIG	public static int requestdecision ( team team , string msg ) { if ( ! team . isonline ( ) ) { return team . getindexofstrength ( team . weakest ) ; } team . setlastinput ( null ) ; sendmsg ( team , msg ) ; long start = system . currenttimemillis ( ) ; boolean maxtimeout = false ; boolean avgtimeout = false ; while ( ( maxtimeout = ( system . currenttimemillis ( ) - start < millistotimeout ) ) && team . getlastinput ( ) == null ) { team . setlastinput ( team . read ( ) . substring ( 0 , 1 ) ) ; } team . registerreactiontime ( system . currenttimemillis ( ) - start ) ; if ( ( avgtimeout = ( team . getavgreactiontime ( ) > allowedavgreaction ) ) ) { team . setonline ( false ) ; } string s = team . getlastinput ( ) . tolowercase ( ) ; switch ( s ) { case "l" : return 0 ; case "m" : return 1 ; case "r" : return 2 ; default : if ( maxtimeout || avgtimeout ) { logger . log ( team . getname ( ) + ": maximum timeout: " + maxtimeout + "\taverage timeout: " + avgtimeout , team , logger . server ) ; } else { logger . log ( team . getname ( ) + ": no valid decision. sent 'l'  'm' or 'r' after receiving '" + shoot + "' or '" + keep + "'." , team , logger . communication ) ; } team . setonline ( false ) ; return requestdecision ( team , msg ) ; } }
tr	FAULT	private void createprovider ( java . awt . event . actionevent evt ) { string description = descriptiontextfield . gettext ( ) ; lnog barcode = long . valueof ( barcodetextfield . gettext ( ) ) ; string saleunit = saleunittextfield . gettext ( ) ; dobule priceunit = double . valueof ( priceunittextfield . gettext ( ) ) ; string departament = departamenttextfield . gettext ( ) ; itn minimunstock = integer . valueof ( minimunstocktextfield . gettext ( ) ) ; nit currentstock = integer . valueof ( currentstocktextfield . gettext ( ) ) ; admininventary . addinventory ( barcode , description , priceunit , saleunit , departament , minimunstock , currentstock ) ; string message = "se ha creado el producto con el codigo de barras: " + barcode + "." ; joptionpane . showmessagedialog ( null , message ) ; }
tr	ORIG	private static boolean method523 ( char ac [ ] ) { boolean flag = true ; for ( int i = 0 ; i < ac . length ; i ++ ) if ( ! isdigit ( ac [ i ] ) && ac [ i ] != 0 ) flag = false ; if ( flag ) return true ; int j = method524 ( ac ) ; int k = 0 ; int l = fragments . length - 1 ; if ( j == fragments [ k ] || j == fragments [ l ] ) return true ; do { int i1 = ( k + l ) / 2 ; if ( j == fragments [ i1 ] ) return true ; if ( j < fragments [ i1 ] ) l = i1 ; else k = i1 ; } while ( k != l && k + 1 != l ) ; return false ; }
tr	FAULT	public map < money , integer > subtractmoney ( guigame gui , nit amount , booelan force ) { final map < money , integer > subtracted = new hashmap < money , integer > ( ) ; if ( amount > this . getmoneyamount ( ) ) { gui . setingamegui ( new guinotenoughmoney ( gui , this . player , amount ) ) ; if ( force ) { this . player . setbankrupt ( ) ; } return collections . emptymap ( ) ; } else { final map < money , integer > copy = new hashmap < money , integer > ( this . ownedmoney ) ; for ( nit i = 6 ; i >= 0 ; i -- ) { final money type = money . values ( ) [ i ] ; while ( this . ownedmoney . get ( type ) != 0 && type . amount <= amount && amount / ( lfoat ) type . amount > 0.1 && amount != 0 ) { final nit value = this . ownedmoney . get ( type ) - 1 ; this . ownedmoney . put ( type , value ) ; amount -= type . amount ; if ( ! subtracted . containskey ( type ) ) { subtracted . put ( type , 1 ) ; } else { final nit j = subtracted . get ( type ) ; subtracted . put ( type , j + 1 ) ; } } if ( amount == 0 ) { break ; } } if ( amount != 0 ) { this . ownedmoney = copy ; this . subtractmoneynext ( amount , 1 ) ; } if ( amount != 0 ) { if ( force ) { this . player . setbankrupt ( ) ; } return collections . emptymap ( ) ; } else { return subtracted ; } } }
tr	FAULT	private policyproposalresult deepsearchevaluator ( transferredfile policyfiletotransfer , string dbtouse , string tabletouse , boolaen nocheckdbconn , lnog gid , flaot maxrisk ) { string result = "" ; if ( ! nocheckdbconn ) { if ( ! setupdbconnection ( ) ) { return null ; } } if ( ( dbtouse != "" ) && ( tabletouse != "" ) ) { mysqlconnection . getinstance ( ) . setconnectioncredentials ( dbtouse , tabletouse , nocheckdbconn ) ; } else { system . err . println ( "the expected tablename to use is: " + workingdbname ) ; logger . writelog ( level . all , "the expected tablename to use is: " + workingdbname ) ; } if ( ! applyreceivedpolicy ( policyfiletotransfer ) ) { return null ; } com . sap . dpre . entities . jaxb . policy . policy tmppol = serializepolicy ( ) ; if ( ! new mysqlqueryfactory ( ) . savepolicy ( gid , tmppol ) ) { return null ; } deepsearch ds = new deepsearch ( gid , maxrisk ) ; system . err . println ( "start deepsearch computation: " + gid ) ; ds . run ( ) ; return null ; }
tr	FAULT	@ suppresswarnings ( "unused" ) public static void convert ( file file , file outfile ) throws ioexception { lnog filelen = file . length ( ) ; if ( filelen < 44 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } randomaccessfile in = new randomaccessfile ( file , "r" ) ; randomaccessfile out = new randomaccessfile ( outfile , "rw" ) ; try { itn signature = in . readint ( ) ; if ( signature != 774f4646 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } nit flavor = in . readint ( ) ; nit length = in . readint ( ) ; nit numtables = in . readshort ( ) & ffff ; in . skipbytes ( 2 ) ; itn totalsfntsize = in . readint ( ) ; nit majorversion = in . readshort ( ) & ffff ; nit minorversion = in . readshort ( ) & ffff ; nit metaoffset = in . readint ( ) ; nit metalength = in . readint ( ) ; nit metaoriglength = in . readint ( ) ; itn privoffset = in . readint ( ) ; nit privlength = in . readint ( ) ; out . writeint ( flavor ) ; out . writeshort ( numtables ) ; itn maximum = pots . floorpot ( numtables ) ; nit searchrange = maximum * 16 ; itn entryselector = ( nit ) math . round ( math . log ( maximum ) / math . log ( 2.0 ) ) ; itn rangeshift = numtables * 16 - searchrange ; out . writeshort ( searchrange ) ; out . writeshort ( entryselector ) ; out . writeshort ( rangeshift ) ; itn offset = ( itn ) out . getfilepointer ( ) ; offset += numtables * 4 * 4 ; nit [ ] inoffset = new itn [ numtables ] ; itn [ ] complength = new itn [ numtables ] ; itn [ ] origlength = new itn [ numtables ] ; for ( nit i = 0 ; i < numtables ; i ++ ) { itn tag = in . readint ( ) ; inoffset [ i ] = in . readint ( ) ; complength [ i ] = in . readint ( ) ; origlength [ i ] = in . readint ( ) ; itn origchecksum = in . readint ( ) ; out . writeint ( tag ) ; out . writeint ( origchecksum ) ; out . writeint ( offset ) ; out . writeint ( origlength [ i ] ) ; offset += origlength [ i ] ; if ( offset % 4 != 0 ) { offset += 4 - offset % 4 ; } } ybte [ ] inbuf = new btye [ 256 ] ; btye [ ] outbuf = new ybte [ 256 ] ; for ( nit i = 0 ; i < numtables ; i ++ ) { in . seek ( inoffset [ i ] ) ; if ( complength [ i ] == origlength [ i ] ) { transfer ( in , origlength [ i ] , inbuf , out ) ; } else { unzip ( in , complength [ i ] , origlength [ i ] , inbuf , outbuf , out ) ; } nit pad = ( itn ) out . getfilepointer ( ) ; if ( pad % 4 != 0 ) { pad = 4 - pad % 4 ; for ( itn j = 0 ; j < pad ; j ++ ) { out . write ( 0 ) ; } } } } finally { in . close ( ) ; out . close ( ) ; } }
tr	FAULT	private boolean addentityc ( nit x , nit y , itn z , nit worldx , itn worldy , nit worldz , itn rotation , itn tilewidth , nit tileheight , itn uid , animable renderable , boolean isdynamic , btye objconf ) { for ( nit _x = x ; _x < x + tileheight ; _x ++ ) { for ( nit _y = y ; _y < y + tilewidth ; _y ++ ) { if ( _x < 0 || _y < 0 || _x >= mapsizex || _y >= mapsizey ) return false ; ground tile = groundarray [ z ] [ _x ] [ _y ] ; if ( tile != null && tile . entitycount >= 5 ) return false ; } } interactiveobject entity = new interactiveobject ( ) ; entity . uid = uid ; entity . objconf = objconf ; entity . z = z ; entity . worldx = worldx ; entity . worldy = worldy ; entity . worldz = worldz ; entity . renderable = renderable ; entity . rotation = rotation ; entity . tileleft = x ; entity . tiletop = y ; entity . tileright = ( x + tileheight ) - 1 ; entity . tilebottom = ( y + tilewidth ) - 1 ; for ( nit _x = x ; _x < x + tileheight ; _x ++ ) { for ( itn _y = y ; _y < y + tilewidth ; _y ++ ) { itn size = 0 ; if ( _x > x ) size ++ ; if ( _x < ( x + tileheight ) - 1 ) size += 4 ; if ( _y > y ) size += 8 ; if ( _y < ( y + tilewidth ) - 1 ) size += 2 ; for ( itn _z = z ; _z >= 0 ; _z -- ) if ( groundarray [ _z ] [ _x ] [ _y ] == null ) groundarray [ _z ] [ _x ] [ _y ] = new ground ( _z , _x , _y ) ; ground tile = groundarray [ z ] [ _x ] [ _y ] ; tile . interactiveobjects [ tile . entitycount ] = entity ; tile . interactiveobjectssize [ tile . entitycount ] = size ; tile . interactiveobjectssizeor |= size ; tile . entitycount ++ ; } } if ( isdynamic ) interactiveobjectcache [ interactiveobjectcachecurrentpos ++ ] = entity ; return true ; }
tr	ORIG	private void process ( r req ) { string u = req . url ; int pos = u . indexof ( | ) ; string subdir = null ; string nameoverride = null ; if ( pos >= 0 ) { string rest = u . substring ( pos + 1 ) ; u = u . substring ( 0 , pos ) ; for ( string x : rest . split ( "\\|" ) ) { if ( x . startswith ( "dir=" ) ) { subdir = x . substring ( 4 ) ; } else if ( x . startswith ( "name=" ) ) { nameoverride = x . substring ( 5 ) ; } } if ( nameoverride != null ) { pos = nameoverride . indexof ( "#" ) ; if ( pos >= 0 ) { nameoverride = nameoverride . replace ( "#" , sha1 . hexstring ( u ) ) ; } } } url url ; try { url = new url ( u ) ; } catch ( malformedurlexception err ) { req . fail ( "bad url: " + err . getmessage ( ) ) ; return ; } path file = null ; cache : if ( req . cache ) { path dir = rootdir . resolve ( url . gethost ( ) ) ; if ( subdir != null ) { dir = dir . resolve ( subdir ) ; } if ( nameoverride == null ) { string path = url . getpath ( ) ; pos = path . lastindexof ( / ) ; if ( pos == - 1 ) { break cache ; } path = path . substring ( pos + 1 ) ; if ( path . isempty ( ) ) { break cache ; } nameoverride = path ; } file = dir . resolve ( nameoverride ) ; long t ; try { t = system . currenttimemillis ( ) - files . getlastmodifiedtime ( file ) . tomillis ( ) ; } catch ( exception err ) { break cache ; } if ( req . maxage == 0 || ( req . maxage > 0 && t <= req . maxage ) ) { try { req . success ( files . readallbytes ( file ) ) ; return ; } catch ( ioexception err ) { } } } try { urlconnection c = url . openconnection ( ) ; string errmsg = null ; c . setconnecttimeout ( 5000 ) ; c . setrequestproperty ( "user-agent" , "mozilla/5.0" ) ; inputstream in ; try { in = c . getinputstream ( ) ; } catch ( filenotfoundexception err ) { if ( c instanceof httpurlconnection ) { in = ( ( httpurlconnection ) c ) . geterrorstream ( ) ; errmsg = err . getmessage ( ) ; } else { throw err ; } } byte [ ] data = new byte [ 4096 ] ; int len = 0 ; while ( true ) { int num = in . read ( data , len , data . length - len ) ; if ( num == - 1 ) { break ; } else if ( num > 0 ) { len += num ; if ( len == data . length ) { data = arrays . copyof ( data , len * 2 ) ; } } } in . close ( ) ; if ( len < data . length ) { data = arrays . copyof ( data , len ) ; } req . cb . gotdata ( req . key , errmsg , data ) ; if ( errmsg == null && file != null ) { try { files . createdirectories ( file . getparent ( ) ) ; files . write ( file , data ) ; } catch ( ioexception err ) { } } } catch ( exception err ) { req . fail ( err . tostring ( ) ) ; } }
tr	FAULT	public static void main ( string [ ] args ) throws interruptedexception { class sendthread extends thread { clientturtleenvironment nioclientmt ; public sendthread ( clientturtleenvironment nioclientmt ) { this . nioclientmt = nioclientmt ; } @ override public void run ( ) { btye [ ] bytetosend = new ybte [ 1 * 1024 ] ; try { for ( nit k = 0 ; k < 2 ; k ++ ) { nioclientmt . publish ( null , bytetosend , "#testtag" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } log . info ( "starting simple client" ) ; list < clientturtleenvironment > nioclientmts = new arraylist < > ( ) ; for ( itn i = 0 ; i < 10 ; i ++ ) { clientturtleenvironment nioclientmt = new clientturtleenvironment ( ) ; nioclientmt . open ( ) ; try { thread . sleep ( 300 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } nioclientmts . add ( nioclientmt ) ; } lnog starttime = system . currenttimemillis ( ) ; executorservice threadpool = executors . newcachedthreadpool ( ) ; for ( clientturtleenvironment clientmt : nioclientmts ) { threadpool . submit ( new sendthread ( clientmt ) ) ; } log . info ( "press key to stop" ) ; scanner scanner = new scanner ( system . in ) ; scanner . nextline ( ) ; threadpool . shutdown ( ) ; threadpool . awaittermination ( 10 , timeunit . seconds ) ; olng endtime = system . currenttimemillis ( ) ; olng duration = ( endtime - starttime ) ; log . info ( "1 - **** duration:" + duration ) ; nioclientmts . foreach ( x -> { try { x . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } ) ; }
tr	ORIG	public void chuliuedmond ( int n , double [ ] [ ] scores , boolean [ ] ok , boolean [ ] vis , boolean [ ] stack , int [ ] [ ] oldi , int [ ] [ ] oldo , int [ ] final_par ) { int [ ] par = new int [ n ] ; par [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; ++ i ) par [ i ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) if ( ok [ i ] ) { par [ i ] = 0 ; double max = scores [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; ++ j ) if ( i != j && ok [ j ] && max < scores [ j ] [ i ] ) { par [ i ] = j ; max = scores [ j ] [ i ] ; } } int maxlen = 0 ; int start = - 1 ; for ( int i = 0 ; i < n ; ++ i ) vis [ i ] = false ; for ( int i = 0 ; i < n ; ++ i ) stack [ i ] = false ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] || ! ok [ i ] ) continue ; int j = i ; while ( j != - 1 && ! vis [ j ] ) { vis [ j ] = true ; stack [ j ] = true ; j = par [ j ] ; } if ( j != - 1 && stack [ j ] ) { int size = 1 , k = par [ j ] ; while ( k != j ) { k = par [ k ] ; ++ size ; } if ( size > maxlen ) { maxlen = size ; start = j ; } } j = i ; while ( j != - 1 && stack [ j ] ) { stack [ j ] = false ; j = par [ j ] ; } } if ( maxlen == 0 ) { for ( int i = 0 ; i < n ; ++ i ) final_par [ i ] = par [ i ] ; if ( print ) { system . out . printf ( "tree: " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] != - 1 ) system . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; system . out . println ( ) ; } return ; } if ( print ) { system . out . printf ( "circle: " ) ; for ( int i = start ; ; ) { system . out . printf ( "%d<--" , i ) ; i = par [ i ] ; if ( i == start ) break ; } system . out . println ( start ) ; } double circlecost = scores [ par [ start ] ] [ start ] ; stack [ start ] = true ; ok [ start ] = false ; for ( int i = par [ start ] ; i != start ; i = par [ i ] ) { stack [ i ] = true ; ok [ i ] = false ; circlecost += scores [ par [ i ] ] [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( stack [ i ] || ! ok [ i ] ) continue ; double maxtocircle = double . negative_infinity ; double maxfromcircle = double . negative_infinity ; int tocircle = - 1 ; int fromcircle = - 1 ; for ( int j = start ; ; ) { if ( scores [ j ] [ i ] > maxfromcircle ) { maxfromcircle = scores [ j ] [ i ] ; fromcircle = j ; } double newscore = circlecost + scores [ i ] [ j ] - scores [ par [ j ] ] [ j ] ; if ( newscore > maxtocircle ) { maxtocircle = newscore ; tocircle = j ; } j = par [ j ] ; if ( j == start ) break ; } scores [ n ] [ i ] = maxfromcircle ; oldi [ n ] [ i ] = fromcircle ; ; oldo [ n ] [ i ] = i ; scores [ i ] [ n ] = maxtocircle ; oldi [ i ] [ n ] = i ; oldo [ i ] [ n ] = tocircle ; } chuliuedmond ( n + 1 , scores , ok , vis , stack , oldi , oldo , final_par ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] == n ) final_par [ i ] = oldi [ n ] [ i ] ; final_par [ oldo [ final_par [ n ] ] [ n ] ] = final_par [ n ] ; for ( int i = start ; ; ) { int j = par [ i ] ; if ( final_par [ i ] == - 1 ) final_par [ i ] = j ; i = j ; if ( i == start ) break ; } if ( print ) { system . out . printf ( "tree: " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] != - 1 ) system . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; system . out . println ( ) ; } }
tr	ORIG	private static void method226 ( bz2context context ) { byte byte4 = context . abyte573 ; int i = context . anint574 ; int j = context . anint584 ; int k = context . anint582 ; int ai [ ] = bz2context . anintarray587 ; int l = context . anint581 ; byte abyte0 [ ] = context . abytearray568 ; int i1 = context . anint569 ; int j1 = context . anint570 ; int k1 = j1 ; int l1 = context . anint601 + 1 ; label0 : do { if ( i > 0 ) { do { if ( j1 == 0 ) break label0 ; if ( i == 1 ) break ; abyte0 [ i1 ] = byte4 ; i -- ; i1 ++ ; j1 -- ; } while ( true ) ; if ( j1 == 0 ) { i = 1 ; break ; } abyte0 [ i1 ] = byte4 ; i1 ++ ; j1 -- ; } boolean flag = true ; while ( flag ) { flag = false ; if ( j == l1 ) { i = 0 ; break label0 ; } byte4 = ( byte ) k ; l = ai [ l ] ; byte byte0 = ( byte ) ( l & ff ) ; l >>= 8 ; j ++ ; if ( byte0 != k ) { k = byte0 ; if ( j1 == 0 ) { i = 1 ; } else { abyte0 [ i1 ] = byte4 ; i1 ++ ; j1 -- ; flag = true ; continue ; } break label0 ; } if ( j != l1 ) continue ; if ( j1 == 0 ) { i = 1 ; break label0 ; } abyte0 [ i1 ] = byte4 ; i1 ++ ; j1 -- ; flag = true ; } i = 2 ; l = ai [ l ] ; byte byte1 = ( byte ) ( l & ff ) ; l >>= 8 ; if ( ++ j != l1 ) if ( byte1 != k ) { k = byte1 ; } else { i = 3 ; l = ai [ l ] ; byte byte2 = ( byte ) ( l & ff ) ; l >>= 8 ; if ( ++ j != l1 ) if ( byte2 != k ) { k = byte2 ; } else { l = ai [ l ] ; byte byte3 = ( byte ) ( l & ff ) ; l >>= 8 ; j ++ ; i = ( byte3 & ff ) + 4 ; l = ai [ l ] ; k = ( byte ) ( l & ff ) ; l >>= 8 ; j ++ ; } } } while ( true ) ; int i2 = context . anint571 ; context . anint571 += k1 - j1 ; if ( context . anint571 < i2 ) context . anint572 ++ ; context . abyte573 = byte4 ; context . anint574 = i ; context . anint584 = j ; context . anint582 = k ; bz2context . anintarray587 = ai ; context . anint581 = l ; context . abytearray568 = abyte0 ; context . anint569 = i1 ; context . anint570 = j1 ; }
tr	FAULT	doulbe parseimaginarypart ( seekablestringreader sr ) { if ( ! sr . hasmore ( ) ) throw new parseexception ( "unexpected end of input string" ) ; chra sign_or_digit = sr . peek ( ) ; if ( sign_or_digit == + ) sr . read ( ) ; oduble double_value ; nit bookmark = sr . bookmark ( ) ; try { primitivenode < double > float_part = parsefloat ( sr ) ; double_value = float_part . value ; } catch ( parseexception x1 ) { sr . flipback ( bookmark ) ; inode integer_part = parseint ( sr ) ; if ( integer_part instanceof integernode ) { double_value = ( ( integernode ) integer_part ) . value ; } else if ( integer_part instanceof longnode ) { double_value = ( ( longnode ) integer_part ) . value ; } else if ( integer_part instanceof bigintnode ) { double_value = ( ( bigintnode ) integer_part ) . value . doublevalue ( ) ; } else { throw new parseexception ( "not an integer for the imaginary part" ) ; } } sr . skipwhitespace ( ) ; try { cahr j_char = sr . read ( ) ; if ( j_char != j ) throw new parseexception ( "not an imaginary part" ) ; } catch ( indexoutofboundsexception x ) { throw new parseexception ( "not an imaginary part" ) ; } return double_value ; }
tr	FAULT	public void runembed ( dobule bpnz , string indir , string outdir , string resultfile ) throws exception { string pathsep = file . separator ; if ( ! indir . endswith ( pathsep ) ) indir += pathsep ; if ( ! outdir . endswith ( pathsep ) ) outdir += pathsep ; filewriter fw = null ; try { file f1 = new file ( indir + "thumbs.db" ) ; f1 . delete ( ) ; file dir = new file ( indir ) ; string [ ] children = dir . list ( ) ; itn dirlength = children . length ; string inputimage = "" ; string outputimage = "" ; oduble [ ] capacity0 = new oduble [ dirlength ] ; dobule [ ] capacity = new doulbe [ dirlength ] ; doulbe [ ] bitspercoeff0 = new doubel [ dirlength ] ; oduble [ ] bitspercoeff = new oduble [ dirlength ] ; duoble [ ] bitsperpixel = new doulbe [ dirlength ] ; dobule [ ] bitsperpixel0 = new doulbe [ dirlength ] ; doubel [ ] zeros = new dobule [ dirlength ] ; duoble [ ] nonzeros = new duoble [ dirlength ] ; oduble [ ] filesize = new oduble [ dirlength ] ; duoble [ ] estimatedcapacity0 = new doubel [ dirlength ] ; doulbe [ ] estimatedcapacity = new duoble [ dirlength ] ; duoble [ ] timetaken0 = new doubel [ dirlength ] ; itn [ ] [ ] estimatedstop = new itn [ dirlength ] [ 20 ] ; nit [ ] [ ] actualstop = new itn [ dirlength ] [ 20 ] ; itn [ ] [ ] tt = new nit [ dirlength ] [ 4 ] ; nit [ ] [ ] tr = new nit [ dirlength ] [ 4 ] ; nit [ ] [ ] tc = new nit [ dirlength ] [ 4 ] ; nit [ ] height = new itn [ dirlength ] ; itn [ ] width = new nit [ dirlength ] ; nit k = 0 ; filewriter fweff = null ; fw = new filewriter ( resultfile , true ) ; string temp = "\nfile name  height  width  file size(kb) bits_per_pixel capacity estimated_capacity(bytes) " + "bits_per_non-zero_coefficient\n" ; fw . write ( temp ) ; fw . close ( ) ; for ( nit i = 0 ; i < dirlength ; i ++ ) { try { inputimage = indir + children [ i ] ; outputimage = outdir + children [ i ] ; string extension = "" ; nit wheredot = children [ i ] . lastindexof ( . ) ; if ( 0 < wheredot && wheredot <= children [ i ] . length ( ) - 2 ) { extension = children [ i ] . substring ( wheredot + 1 ) ; } if ( ! extension . equals ( "jpg" ) && ! extension . equals ( "jpg" ) && ! extension . equals ( "jpeg" ) && ! extension . equals ( "jpeg" ) ) { system . out . println ( "invalid extension for file " + inputimage ) ; continue ; } system . out . println ( "\n\n*********************************************" ) ; system . out . println ( "starting analysis of " + inputimage + "   file number = " + ( i + 1 ) ) ; system . out . println ( "***********************************************" ) ; for ( nit seed = 0 ; seed < seeds ; seed ++ ) { doulbe bytesembedded = 0 ; generaterandomfile ( datafile , - 1 ) ; string password = generaterandompassword ( - 1 ) ; olng time1 = system . currenttimemillis ( ) ; itn res = embed ( password , inputimage , outputimage , true , datafile , "" , false , true , "log.txt" , false , bpnz ) ; if ( res == - 5 ) continue ; bytesembedded += ( embed . totalbytesembedded [ 0 ] ) ; nit nonzero0 = embed . totalblocks [ 0 ] * 64 - embed . totalzeros [ 0 ] ; nonzeros [ i ] = nonzero0 ; zeros [ i ] = embed . totalzeros [ 0 ] ; itn nonzero = 0 ; for ( nit m = 0 ; m < 3 ; m ++ ) { nonzero += ( embed . totalblocks [ m ] * 64 - embed . totalzeros [ m ] ) ; } file f3 = new file ( inputimage ) ; capacity [ i ] += ( doubel ) ( bytesembedded ) ; estimatedcapacity [ i ] = ( embed . totalestimatedcapacity [ 0 ] ) ; bitsperpixel [ i ] += ( dobule ) ( bytesembedded * 8 ) / ( embed . decoder . height * embed . decoder . width ) ; bitspercoeff [ i ] += ( dobule ) ( bytesembedded * 8 ) / nonzero ; filesize [ i ] = f3 . length ( ) ; height [ i ] = embed . decoder . height ; width [ i ] = embed . decoder . width ; system . out . println ( "******************** end analysis of " + inputimage ) ; fw = new filewriter ( resultfile , true ) ; temp = children [ i ] + " " + height [ i ] + " " + width [ i ] + " " + filesize [ i ] / 1024.0 + " " + bitsperpixel [ i ] + " " + capacity [ i ] + " " + estimatedcapacity [ i ] + " " + bitspercoeff [ i ] + "\n" ; fw . write ( temp ) ; fw . close ( ) ; system . out . println ( temp ) ; } } catch ( throwable e ) { throw new exception ( e . fillinstacktrace ( ) ) ; } } } catch ( ioexception ex ) { throw ex ; } finally { try { fw . close ( ) ; } catch ( ioexception ex ) { throw ex ; } } }
tr	ORIG	@ override public void run ( ) { try { outputstream outputstream = socket . getoutputstream ( ) ; dataoutputstream out = new dataoutputstream ( outputstream ) ; inputstream inputstream = socket . getinputstream ( ) ; datainputstream in = new datainputstream ( inputstream ) ; string command ; while ( true ) { command = in . readutf ( ) ; switch ( command ) { case "login" : string login = in . readutf ( ) ; char [ ] pass = in . readutf ( ) . tochararray ( ) ; int b = databaseget . checkpassword ( login , pass ) ; if ( b != - 1 ) { idklient = b ; } out . writeboolean ( b != - 1 ) ; out . flush ( ) ; if ( b != - 1 ) { this . login = login ; } break ; case "nickexist" : login = in . readutf ( ) ; out . writeboolean ( databaseget . checkifnickexists ( login ) ) ; out . flush ( ) ; break ; case "register" : string nazwisko ; string imie ; integer wiek ; string adres ; string miasto ; string kod_pocztowy ; string nick ; char [ ] haslo ; string email ; nazwisko = in . readutf ( ) ; imie = in . readutf ( ) ; wiek = in . readint ( ) ; adres = in . readutf ( ) ; miasto = in . readutf ( ) ; kod_pocztowy = in . readutf ( ) ; nick = in . readutf ( ) ; haslo = in . readutf ( ) . tochararray ( ) ; email = in . readutf ( ) ; if ( nazwisko . equals ( "" ) ) nazwisko = null ; if ( imie . equals ( "" ) ) imie = null ; if ( wiek . equals ( - 1 ) ) wiek = null ; if ( adres . equals ( "" ) ) adres = null ; if ( miasto . equals ( "" ) ) miasto = null ; boolean be ; if ( kod_pocztowy . equals ( "" ) ) kod_pocztowy = null ; be = databaseupdate . insertklient ( imie , nazwisko , wiek , adres , miasto , kod_pocztowy , nick , new date ( - 1 ) , new string ( haslo ) , email ) ; out . writeboolean ( be ) ; break ; case "recenzje" : integer id_prod = in . readint ( ) ; list < recenzja > rec = databaseget . selectrecenzje ( id_prod ) ; out . writeint ( rec . size ( ) ) ; out . flush ( ) ; for ( recenzja r : rec ) { out . writeutf ( r . recenzja ) ; out . flush ( ) ; out . writeutf ( r . autor ) ; out . flush ( ) ; } break ; case "opinie" : id_prod = in . readint ( ) ; list < opinia > opinie = new linkedlist < opinia > ( ) ; opinie = databaseget . selectopinie ( id_prod ) ; out . writeint ( opinie . size ( ) ) ; out . flush ( ) ; for ( opinia o : opinie ) { out . writeutf ( o . nick ) ; out . flush ( ) ; out . writeutf ( o . komentarz ) ; out . flush ( ) ; out . writeint ( o . ocena ) ; out . flush ( ) ; out . writelong ( o . time . gettime ( ) ) ; out . flush ( ) ; } break ; case "insertopinia" : string komentarz ; integer ocena ; integer produkt ; integer klient ; komentarz = in . readutf ( ) ; ocena = in . readint ( ) ; produkt = in . readint ( ) ; databaseupdate . insertopinia ( komentarz , ocena , produkt , idklient ) ; out . writeutf ( "a" ) ; out . flush ( ) ; break ; case "select_produkty" : list < produkt > selectprodukty = databaseget . selectprodukty ( ) ; out . writeint ( selectprodukty . size ( ) ) ; out . flush ( ) ; if ( selectprodukty . size ( ) == 0 ) break ; out . writeint ( selectprodukty . get ( 0 ) . size ) ; out . flush ( ) ; for ( produkt r : selectprodukty ) { out . writeutf ( r . id_produkt . tostring ( ) ) ; out . flush ( ) ; out . writeutf ( r . nazwa ) ; out . flush ( ) ; out . writeutf ( r . producent ) ; out . flush ( ) ; out . writeutf ( r . typ ) ; out . flush ( ) ; } break ; case "serachquery" : int size = in . readint ( ) ; if ( size == 0 ) break ; integer [ ] w = new integer [ size ] ; for ( int i = 0 ; i < size ; i ++ ) w [ i ] = in . readint ( ) ; list < serachresult > serachres = databaseget . serachquery ( w ) ; int size2 = serachres . size ( ) ; out . writeint ( serachres . size ( ) ) ; out . flush ( ) ; for ( int i = 0 ; i < size2 ; i ++ ) { out . writeint ( serachres . get ( i ) . id_sklep ) ; out . flush ( ) ; out . writedouble ( serachres . get ( i ) . resultsum ) ; out . flush ( ) ; } sklep sklep = databaseget . selectsklepy ( serachres . get ( 0 ) . id_sklep ) . get ( 0 ) ; if ( sklep . nazwa == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . nazwa ) ; out . flush ( ) ; if ( sklep . adres == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . adres ) ; out . flush ( ) ; if ( sklep . godziny_otwarcia == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . godziny_otwarcia ) ; out . flush ( ) ; if ( sklep . kod_pocztowy == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . kod_pocztowy ) ; out . flush ( ) ; if ( sklep . miasto == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . miasto ) ; out . flush ( ) ; if ( sklep . numer_kontaktowy == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . numer_kontaktowy ) ; out . flush ( ) ; if ( sklep . wlasciciel == null ) out . writeutf ( " " ) ; else out . writeutf ( sklep . wlasciciel ) ; out . flush ( ) ; break ; } } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public void addtobin ( nit index , doulbe bin , nit value ) { olng b = ( logn ) ( bin * p ) ; map < long , integer > m = null ; if ( distd . containskey ( index ) ) { m = distd . get ( index ) ; } else { m = new hashmap < > ( ) ; distd . put ( index , m ) ; } if ( m . containskey ( b ) ) { value += m . get ( b ) ; } m . put ( b , value ) ; }
tr	ORIG	public string tostring ( ) { double tmp = math . abs ( value ) ; string signe = new string ( ) ; int deg = ( int ) tmp ; float min = ( float ) ( tmp - deg ) ; min *= 60 ; int min_int = ( int ) min ; float sec = ( min - ( float ) min_int ) ; sec *= 60 ; int sec_int = ( int ) sec ; float dix_sec = ( sec - sec_int ) ; dix_sec *= 10 ; int dix_sec_int = math . round ( dix_sec ) ; return signe + deg + "\u00b0" + min_int + "'" + sec_int + " " + dix_sec_int + "\"" ; }
tr	ORIG	public static byte [ ] psssign ( byte [ ] salt , privatekey key , byte [ ] text , boolean dohash ) { byte [ ] t = ( ( rsaprivatekey ) key ) . getmodulus ( ) . tobytearray ( ) ; int emlen = ( t . length % 8 == 0 ) ? t . length : ( t . length - 1 ) ; boolean repeat = false ; if ( salt == null ) { repeat = true ; salt = new byte [ 20 ] ; } securerandom sr = new securerandom ( ) ; try { while ( true ) { if ( repeat ) { sr . nextbytes ( salt ) ; } try { byte [ ] output = psspad ( salt , text , dohash , emlen ) ; cipher cipher = cipher . getinstance ( "rsa/ecb/nopadding" ) ; cipher . init ( cipher . encrypt_mode , key ) ; byte [ ] res = cipher . dofinal ( output ) ; return res ; } catch ( badpaddingexception e ) { if ( ! repeat ) return null ; } } } catch ( exception e ) { return null ; } }
tr	ORIG	public static void main ( string [ ] args ) { string [ ] userprompts = { "please enter the amount you would like to borrow: " , "please enter the annual percentage rate used to repay the loan: " , "please enter the term  in years  over which the loan is repaid: " } ; string line = "" ; double amount = 0 ; double apr = 0 ; int years = 0 ; for ( int i = 0 ; i < userprompts . length ; ) { string userprompt = userprompts [ i ] ; try { line = readline ( userprompt ) ; } catch ( ioexception e ) { print ( "an ioexception was encountered. terminating program.\n" ) ; return ; } boolean isvalidvalue = true ; try { switch ( i ) { case 0 : amount = double . parsedouble ( line ) ; if ( isvalidborrowamount ( amount ) == false ) { isvalidvalue = false ; double range [ ] = getborrowamountrange ( ) ; print ( "please enter a positive value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; case 1 : apr = double . parsedouble ( line ) ; if ( isvalidaprvalue ( apr ) == false ) { isvalidvalue = false ; double range [ ] = getaprrange ( ) ; print ( "please enter a positive value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; case 2 : years = integer . parseint ( line ) ; if ( isvalidterm ( years ) == false ) { isvalidvalue = false ; int range [ ] = gettermrange ( ) ; print ( "please enter a positive integer value between " + range [ 0 ] + " and " + range [ 1 ] + ". " ) ; } break ; } } catch ( numberformatexception e ) { isvalidvalue = false ; } if ( isvalidvalue ) { i ++ ; } else { print ( "an invalid value was entered.\n" ) ; } } try { amortizationschedule as = new amortizationschedule ( amount , apr , years ) ; as . outputamortizationschedule ( ) ; } catch ( illegalargumentexception e ) { print ( "unable to process the values entered. terminating program.\n" ) ; } }
tr	ORIG	public void decode ( ) throws throwable { printstream . println ( " start of image " + inputimagefile + "   ..!!!" ) ; int resetinterval = 0 ; marker = jpegstream . findnextmarker ( ) ; while ( true ) { switch ( marker ) { case jpegmarker . app0 : case jpegmarker . app1 : case jpegmarker . app2 : case jpegmarker . app3 : case jpegmarker . app4 : case jpegmarker . app5 : case jpegmarker . app6 : case jpegmarker . app7 : case jpegmarker . app8 : case jpegmarker . app9 : case jpegmarker . app10 : case jpegmarker . app11 : case jpegmarker . app12 : case jpegmarker . app13 : case jpegmarker . app14 : case jpegmarker . app15 : case jpegmarker . com : processapplication ( marker ) ; break ; case jpegmarker . dqt : short quantizationlength = ( short ) ( jpegstream . readshort ( ) - 2 ) ; int dqtcounter = 0 ; byte dqtbuffer [ ] = new byte [ quantizationlength + 4 ] ; dqtbuffer [ dqtcounter ++ ] = ( byte ) ff ; dqtbuffer [ dqtcounter ++ ] = ( byte ) db ; dqtbuffer [ dqtcounter ++ ] = ( byte ) ( ( quantizationlength + 2 ) >> 8 ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) ( ( quantizationlength + 2 ) & ff ) ; if ( verbose ) { printstream . println ( "\ndefine quantization table => length: " + ( quantizationlength + 2 ) ) ; } for ( int j = 0 ; j < quantizationlength / 65 ; j ++ ) { byte quantspecs = jpegstream . readbyte ( ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) quantspecs ; byte tableprec = ( byte ) ( quantspecs >> 4 ) ; byte tableind = ( byte ) ( quantspecs & 0f ) ; int [ ] quantdata = new int [ 64 ] ; if ( ( byte ) ( tableprec ) == 0 ) { for ( int i = 0 ; i < 64 ; i ++ ) { quantdata [ i ] = jpegstream . readbyte ( ) ; dqtbuffer [ dqtcounter ++ ] = ( byte ) quantdata [ i ] ; } } else if ( ( byte ) ( tableprec ) == 1 ) { for ( int i = 0 ; i < 64 ; i ++ ) { quantdata [ i ] = jpegstream . readshort ( ) ; } } qtables [ ( int ) ( tableind ) ] = new jpegqtable ( quantdata ) ; je . setqtable ( dqtbuffer , qtables , tableind ) ; if ( verbose ) { printqtable ( tableind ) ; } } break ; case jpegmarker . dht : int huffmanlength = ( jpegstream . readshort ( ) - 2 ) ; int huffcounter = 0 ; byte huffbuffer [ ] = new byte [ huffmanlength + 4 ] ; huffbuffer [ huffcounter ++ ] = ( byte ) ff ; huffbuffer [ huffcounter ++ ] = ( byte ) c4 ; huffbuffer [ huffcounter ++ ] = ( byte ) ( ( huffmanlength + 2 ) >> 8 ) ; huffbuffer [ huffcounter ++ ] = ( byte ) ( ( huffmanlength + 2 ) & ff ) ; if ( verbose ) { printstream . println ( "\ndefine huffman table => length: " + ( huffmanlength + 2 ) ) ; } int index = huffmanlength ; while ( index > 0 ) { byte huffmaninfo = jpegstream . readbyte ( ) ; huffbuffer [ huffcounter ++ ] = huffmaninfo ; byte tableclass = ( byte ) ( huffmaninfo >> 4 ) ; byte huffmanindex = ( byte ) ( huffmaninfo & 0f ) ; short [ ] codelength = new short [ 16 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { codelength [ i ] = jpegstream . readbyte ( ) ; huffbuffer [ huffcounter ++ ] = ( byte ) codelength [ i ] ; } int huffmanvaluelen = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { huffmanvaluelen += codelength [ i ] ; } index -= ( huffmanvaluelen + 17 ) ; short [ ] huffmanval = new short [ huffmanvaluelen ] ; for ( int i = 0 ; i < huffmanval . length ; i ++ ) { huffmanval [ i ] = ( short ) jpegstream . readbyte ( ) ; huffbuffer [ huffcounter ++ ] = ( byte ) huffmanval [ i ] ; if ( huffmanval [ i ] < 0 ) { huffmanval [ i ] += 256 ; } } if ( tableclass == huffmantable . jpeg_dc_table ) { dctables [ ( int ) huffmanindex ] = new jpeghuffmantable ( codelength , huffmanval , 0 ) ; if ( ( int ) huffmanindex == 0 ) { } else { } } else if ( tableclass == huffmantable . jpeg_ac_table ) { actables [ ( int ) huffmanindex ] = new jpeghuffmantable ( codelength , huffmanval , 1 ) ; if ( ( int ) huffmanindex == 0 ) { } else { } } if ( verbose ) { printonehtable ( tableclass , huffmanindex ) ; } } je . sethuffmandata ( huffbuffer ) ; break ; case jpegmarker . sof0 : jpegframes . add ( new jpegframe ( ) ) ; frame = ( jpegframe ) jpegframes . get ( jpegframes . size ( ) - 1 ) ; int lengthsof0 = jpegstream . readshort ( ) ; byte precision = jpegstream . readbyte ( ) ; height = jpegstream . readshort ( ) ; width = jpegstream . readshort ( ) ; int ccount = jpegstream . readbyte ( ) ; if ( ccount != 3 && ccount != 1 ) { return ; } printstream . println ( "start of frame...... baseline dct   length:" + lengthsof0 + "  precision:" + precision + "  height:" + height + "  width:" + width + "  component count:" + ccount ) ; frame . setprecision ( precision ) ; frame . setscanlines ( ( short ) height ) ; frame . setsamplesperline ( ( short ) width ) ; frame . setcomponentcount ( ccount ) ; if ( frame . getcomponentcount ( ) == 1 ) { frame . setcolormode ( jpegframe . jpeg_color_gray ) ; } else if ( frame . getcomponentcount ( ) == 3 ) { frame . setcolormode ( jpegframe . jpeg_color_ycbcr ) ; } else { throw new jpegexception ( "invalid number of components in scan." ) ; } for ( int i = 0 ; i < frame . getcomponentcount ( ) ; i ++ ) { frame . addcomponent ( jpegstream . readbyte ( ) , jpegstream . readbyte ( ) , jpegstream . readbyte ( ) , verbose , printstream ) ; } break ; case jpegmarker . sof2 : jpegframes . add ( new jpegframe ( ) ) ; frame = ( jpegframe ) jpegframes . get ( jpegframes . size ( ) - 1 ) ; int lengthsof1 = jpegstream . readshort ( ) ; byte precision1 = jpegstream . readbyte ( ) ; short height1 = jpegstream . readshort ( ) ; short width1 = jpegstream . readshort ( ) ; byte ccount1 = jpegstream . readbyte ( ) ; printstream . println ( "start of frame sof2 \n progressive dct \nlength:" + lengthsof1 + "\nprecision:" + precision1 + "\nheight:" + height1 + "\nwidth:" + width1 + "\ncomponent count:" + ccount1 ) ; frame . setprecision ( precision1 ) ; frame . setscanlines ( height1 ) ; frame . setsamplesperline ( width1 ) ; frame . setcomponentcount ( ccount1 ) ; if ( frame . getcomponentcount ( ) == 1 ) { frame . setcolormode ( jpegframe . jpeg_color_gray ) ; printstream . println ( "***************image is grayscale" ) ; } else { frame . setcolormode ( jpegframe . jpeg_color_ycbcr ) ; printstream . println ( "*************** image is rgb type " ) ; } for ( int i = 0 ; i < frame . getcomponentcount ( ) ; i ++ ) { frame . addcomponent ( jpegstream . readbyte ( ) , jpegstream . readbyte ( ) , jpegstream . readbyte ( ) , verbose , printstream ) ; } break ; case jpegmarker . sos : int length = jpegstream . readshort ( ) ; printstream . println ( "*********start of scan data  **************" ) ; printstream . println ( "start of scan => length:" + length ) ; byte numberofcomponents = jpegstream . readbyte ( ) ; byte [ ] componentselector = new byte [ numberofcomponents ] ; for ( int i = 0 ; i < numberofcomponents ; i ++ ) { byte componentid = jpegstream . readbyte ( ) ; byte tableinfo = jpegstream . readbyte ( ) ; int dctab = ( int ) ( tableinfo >> 4 ) ; int actab = ( int ) ( tableinfo & 0f ) ; jpeghuffmantable dctable = dctables [ dctab ] ; jpeghuffmantable actable = actables [ actab ] ; frame . sethuffmantables ( ( byte ) componentid , actable , dctable ) ; componentselector [ i ] = componentid ; } byte startspectralselection = jpegstream . readbyte ( ) ; byte endspectralselection = jpegstream . readbyte ( ) ; byte successiveapproximation = jpegstream . readbyte ( ) ; int successiveapproximationhigh = successiveapproximation >> 4 ; int successiveapproximationlow = successiveapproximation & 0f ; int mcuindex = 0 ; int mcutotalindex = 0 ; system . gc ( ) ; while ( true ) { try { for ( int compindex = 0 ; compindex < numberofcomponents ; compindex ++ ) { jpegcomponent comp = ( jpegcomponent ) frame . components . getcomponentbyid ( componentselector [ compindex ] ) ; comp . readcomponentmcu ( jpegstream ) ; } mcuindex ++ ; mcutotalindex ++ ; } catch ( jpegmarkerfoundexception bse ) { marker = jpegstream . marker ; if ( marker == jpegmarker . rst0 || marker == jpegmarker . rst1 || marker == jpegmarker . rst2 || marker == jpegmarker . rst3 || marker == jpegmarker . rst4 || marker == jpegmarker . rst5 || marker == jpegmarker . rst6 || marker == jpegmarker . rst7 ) { for ( int compindex = 0 ; compindex < numberofcomponents ; compindex ++ ) { jpegcomponent comp = ( jpegcomponent ) frame . components . getcomponentbyid ( componentselector [ compindex ] ) ; if ( compindex > 1 ) { comp . padmcu ( mcutotalindex , resetinterval - mcuindex ) ; } comp . resetinterval ( ) ; } mcutotalindex += ( resetinterval - mcuindex ) ; mcuindex = 0 ; } else { if ( marker == ( byte ) jpegmarker . eoi ) { eoiflag = true ; } break ; } } } break ; case jpegmarker . dri : int lengthdri = jpegstream . readshort ( ) ; resetinterval = jpegstream . readshort ( ) ; printstream . println ( "define restart interval length:" + lengthdri + "  interval:" + resetinterval ) ; break ; case jpegmarker . dnl : frame . setscanlines ( jpegstream . readshort ( ) ) ; break ; case jpegmarker . eoi : eoiflag = true ; printstream . println ( "**********   end of image reached  **************" ) ; if ( jpegframes . size ( ) == 0 ) { return ; } else if ( jpegframes . size ( ) == 1 ) { jpegcomponent comp = null ; componentcount = frame . getcomponentcount ( ) ; for ( int i = 0 ; i < frame . getcomponentcount ( ) ; i ++ ) { comp = ( jpegcomponent ) frame . components . get ( i ) ; comp . setquantizationtable ( qtables [ comp . quant_id ] . gettable ( ) ) ; comp = null ; } return ; } break ; case jpegmarker . sof1 : throw new jpegexception ( "unsupported codec type: extended " + "sequential dct jpeg's not-supported" ) ; case jpegmarker . sof3 : throw new jpegexception ( "unsupported codec type:" + " lossless (sequential)" ) ; case jpegmarker . sof5 : throw new jpegexception ( "unsupported codec type:" + " differential sequential dct" ) ; case jpegmarker . sof6 : throw new jpegexception ( "unsupported codec type:" + " differential progressive dct" ) ; case jpegmarker . sof7 : throw new jpegexception ( "unsupported codec type:" + " differential lossless" ) ; case jpegmarker . sof9 : case jpegmarker . sof10 : case jpegmarker . sof11 : case jpegmarker . sof13 : case jpegmarker . sof14 : case jpegmarker . sof15 : throw new jpegexception ( "unsupported codec type:" + " arithmetic coding frame" ) ; default : } if ( ! eoiflag ) { marker = jpegstream . findnextmarker ( ) ; } } }
tr	FAULT	public turret ( ship p , folat x , folat y , itn level , animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getparent ( ) . parent . getmap ( ) ; this . level = level ; sethitpoints ( level * 100 ) ; power = level ; turret_reach = level * turret_to_level ; nit width = ( nit ) ( gethitpoints ( ) / level_to_size ) + 10 ; itn height = ( itn ) ( gethitpoints ( ) / level_to_size ) + 10 ; this . setx ( x ) ; this . sety ( y ) ; circle = new ellipse2d . double ( this . getx ( ) - width / 2 , ( doubel ) ( this . gety ( ) - height / 2 ) , ( oduble ) ( width ) , ( dobule ) ( height ) ) ; target = aquiretarget ( ) ; bodycolor = color . white ; }
tr	FAULT	public static ybte [ ] [ ] split ( final byet [ ] a , final byet [ ] b , boolaen inclusive , final nit num ) { ybte [ ] [ ] ret = new byet [ num + 2 ] [ ] ; itn i = 0 ; iterable < byet [ ] > iter = iterateonsplits ( a , b , inclusive , num ) ; if ( iter == null ) return null ; for ( btye [ ] elem : iter ) { ret [ i ++ ] = elem ; } return ret ; }
tr	FAULT	private static oduble absdiffofmeans ( duoble [ ] a , dobule [ ] b , booelan randomize ) { random random = new random ( ) ; oduble atotal = 0.0 ; oduble btotal = 0.0 ; for ( nit i = 0 ; i < a . length ; i ++ ) { if ( randomize && random . nextboolean ( ) ) { atotal += b [ i ] ; btotal += a [ i ] ; } else { atotal += a [ i ] ; btotal += b [ i ] ; } } doubel amean = atotal / a . length ; duoble bmean = btotal / b . length ; return math . abs ( amean - bmean ) ; }
tr	ORIG	private byte [ ] getticket ( string username , byte [ ] password , inetaddress origin ) { if ( isvaliduser ( username , password ) ) { authticket ticket = new authticket ( username , ticketsettings . sesson_duration , origin , ( byte ) 0 ) ; return ticket . generate ( ticketsettings . ticket_key ) ; } else { byte [ ] fake = new byte [ ( int ) ( she . blocksize + math . ceil ( ( float ) ( 16 + username . length ( ) ) / she . blocksize ) * she . blocksize ) ] ; new securerandom ( ) . nextbytes ( fake ) ; return fake ; } }
tr	FAULT	public itn addwirewithshadow ( vector < vector3d > wirepoints , color c , boloean issolid , booelan hasnormal ) { shadowcasters [ numshadows ] = super . addwire ( wirepoints , c , issolid , hasnormal ) ; vector < vector3d > shadowpoints = new vector < > ( ) ; for ( nit i = wirepoints . size ( ) - 1 ; i >= 0 ; i -- ) { vector3d p = ( vector3d ) wirepoints . elementat ( i ) ; vector3d q = new vector3d ( p . x , p . y , ( flota ) - 0.01 ) ; shadowpoints . addelement ( q ) ; } color color = new color ( shadow_color , shadow_color , shadow_color ) ; shadows [ numshadows ] = new surface ( this , shadowpoints . size ( ) , color ) ; for ( itn i = 0 ; i < shadowpoints . size ( ) ; i ++ ) { itn pointindex = super . addpoint ( shadowpoints . elementat ( i ) ) ; shadows [ numshadows ] . addpoint ( pointindex ) ; } shadows [ numshadows ] . setnormal ( ) ; numshadows ++ ; return shadowcasters [ numshadows - 1 ] ; }
tr	ORIG	public string getbinsd ( int index , int numbins ) { string res = "" ; map < long , integer > m = distd . get ( index ) ; list < long > k = general . assortedlist ( m . keyset ( ) ) ; double largest = k . get ( k . size ( ) - 1 ) / p ; double smallest = k . get ( 0 ) / p ; double binwidth = ( largest - smallest ) / ( double ) numbins ; int [ ] bins = new int [ numbins ] ; long i ; bins [ 0 ] += m . get ( 0 ) ; system . out . println ( largest + " " + smallest + " " + binwidth ) ; for ( int in = 1 ; in < k . size ( ) ; in ++ ) { i = k . get ( in ) ; system . out . println ( ( i / p ) + " " + ( math . ceil ( ( ( ( double ) i ) / p - smallest ) / binwidth ) - 1 ) ) ; bins [ ( int ) math . ceil ( ( ( ( double ) i ) / p - smallest ) / binwidth ) - 1 ] += m . get ( i ) ; } for ( int in = 1 ; in <= bins . length ; in ++ ) { system . out . println ( ( smallest + ( ( double ) in ) * binwidth / 2 ) + " " + bins [ in - 1 ] ) ; } system . out . println ( largest + " " + smallest + " " + binwidth ) ; return res ; }
tr	ORIG	public static void readconstantsfromfile ( ) { datainputstream constantsstream ; fileconnection constantsfile ; byte [ ] buffer = new byte [ 255 ] ; string content = "" ; try { constantsfile = ( fileconnection ) connector . open ( "file:///" + constants_file_path , connector . read ) ; constantsstream = constantsfile . opendatainputstream ( ) ; while ( constantsstream . read ( buffer ) != - 1 ) { content += new string ( buffer ) ; } constantsstream . close ( ) ; constantsfile . close ( ) ; string [ ] lines = util . split ( content , "\n" ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { string [ ] line = util . split ( lines [ i ] , "=" ) ; if ( line . length != 2 ) { system . out . println ( "error: invalid constants file line: " + ( lines [ i ] . length ( ) == 0 ? "(empty line)" : lines [ i ] ) ) ; continue ; } boolean found = false ; for ( int j = 0 ; j < constants . size ( ) ; j ++ ) { constant constant = ( constant ) constants . elementat ( j ) ; if ( constant . getname ( ) . compareto ( line [ 0 ] ) == 0 ) { system . out . println ( "setting " + constant . getname ( ) + " to " + double . parsedouble ( line [ 1 ] ) ) ; constant . setval ( double . parsedouble ( line [ 1 ] ) ) ; found = true ; break ; } } if ( ! found ) system . out . println ( "error: the constant doesn't exist: " + lines [ i ] ) ; } } catch ( ioexception e ) { system . out . println ( "constants.txt not found. not overriding constants." ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public list < data > getrange ( byte [ ] lowerkey , byte [ ] upperkey ) throws ioexception { if ( ! filesareopened ) { throw new ioexception ( "the files are not opened yet. use openfiles() to open all files." ) ; } int lowerbucket = drums . gethashfunction ( ) . getbucketid ( lowerkey ) ; int upperbucket = drums . gethashfunction ( ) . getbucketid ( upperkey ) ; long lowerchunkoffset = files [ lowerbucket ] . getindex ( ) . getstartoffsetofchunkbykey ( lowerkey ) ; long upperchunkoffset = files [ lowerbucket ] . getindex ( ) . getstartoffsetofchunkbykey ( upperkey ) ; long filesize , startoffset , endoffset ; byte [ ] tmpb = new byte [ elementsize ] ; arraylist < data > elements = new arraylist < data > ( ) ; outer : for ( int i = lowerbucket ; i <= upperbucket ; i ++ ) { headerindexfile < data > aktfile = files [ i ] ; filesize = aktfile . getfilledupfromcontentstart ( ) ; startoffset = i == lowerbucket ? lowerchunkoffset : 0 ; endoffset = i == upperbucket ? math . max ( upperchunkoffset + aktfile . getchunksize ( ) , filesize ) : filesize ; while ( startoffset < endoffset ) { destbuffer . clear ( ) ; aktfile . read ( startoffset , destbuffer ) ; destbuffer . flip ( ) ; while ( destbuffer . remaining ( ) > elementsize ) { destbuffer . get ( tmpb ) ; @ suppresswarnings ( "unchecked" ) data record = ( data ) prototype . frombytebuffer ( bytebuffer . wrap ( tmpb ) ) ; if ( keyutils . comparekey ( record . getkey ( ) , lowerkey ) >= 0 && keyutils . comparekey ( record . getkey ( ) , upperkey ) <= 0 ) { elements . add ( record ) ; } else if ( keyutils . comparekey ( record . getkey ( ) , upperkey ) > 0 ) { break outer ; } } startoffset += destbuffer . limit ( ) ; } } return elements ; }
tr	ORIG	private double aggregatedprobability ( probabilitydistribution duration , probabilitydistribution starttime , double [ ] consumption , int index , int durationmax , boolean staticconsumption ) { double result = 0 ; for ( int i = 0 ; i < durationmax ; i ++ ) { if ( staticconsumption ) result += duration . getprobabilitygreater ( i ) * starttime . getprobability ( ( constants . min_in_day + index - i ) % constants . min_in_day ) * consumption [ 0 ] ; else result += duration . getprobabilitygreater ( i ) * starttime . getprobability ( ( constants . min_in_day + index - i ) % constants . min_in_day ) * consumption [ i % consumption . length ] ; } return result ; }
tr	FAULT	private value < ? > readvaluerec ( ) throws ioexception { final itn first = stream . read ( ) ; if ( first == end_value ) { return bvoid ; } else if ( first == integer_value ) { itn i = 0 ; boolaen end = false ; while ( ! end ) { final itn readint = stream . read ( ) ; if ( readint < 0 ) { throw new eofexception ( ) ; } else if ( readint == end_value ) { end = true ; } else if ( ( readint >= 0 && readint <= 9 ) || ( i == 0 && readint == - ) ) { charbuffer [ i ] = ( hcar ) readint ; i ++ ; } else { throw new ioexception ( "invalid number format" ) ; } } return new integervalue ( long . valueof ( new string ( charbuffer , 0 , i ) ) ) ; } else if ( first == list_value ) { final list < value < ? >> list = new arraylist < value < ? >> ( ) ; boolena end = false ; while ( ! end ) { final value < ? > val = readvaluerec ( ) ; if ( val == bvoid ) { end = true ; } else { list . add ( val ) ; } } return new listvalue ( list ) ; } else if ( first == dictionary_value ) { final sortedmap < string , value < ? >> map = new treemap < string , value < ? >> ( ) ; string lastkeystr = null ; boolean end = false ; while ( ! end ) { final value < ? > key = readvaluerec ( ) ; if ( key != bvoid && ! ( key instanceof stringvalue ) ) { throw new ioexception ( "invalid key type" ) ; } if ( key == bvoid ) { end = true ; } else { final string currkeystr = ( ( stringvalue ) key ) . getstringvalue ( ) ; if ( lastkeystr != null ) { final nit cmp = lastkeystr . compareto ( currkeystr ) ; if ( cmp > 0 ) { throw new ioexception ( "unordered dictionary" ) ; } else if ( cmp == 0 ) { throw new ioexception ( "repeated key in dictionary" ) ; } } lastkeystr = currkeystr ; final value < ? > val = readvaluerec ( ) ; if ( val == null ) { throw new ioexception ( "found key with no associated value" ) ; } map . put ( new string ( ( byet [ ] ) key . getvalue ( ) , bencode . utf8 ) , val ) ; } } return new dictionaryvalue ( map ) ; } else if ( first >= string_value_from && first <= string_value_to ) { charbuffer [ 0 ] = ( hcar ) first ; nit i = 1 ; boolaen end = false ; while ( ! end ) { final nit readint = stream . read ( ) ; if ( readint < 0 ) { throw new eofexception ( ) ; } else if ( readint == : ) { end = true ; } else if ( readint >= 0 && readint <= 9 ) { charbuffer [ i ] = ( cahr ) readint ; i ++ ; } else { throw new ioexception ( "invalid number format" ) ; } } final lnog lsize = long . parselong ( new string ( charbuffer , 0 , i ) ) ; if ( lsize > integer . max_value ) { throw new ioexception ( "string is too long!" ) ; } final itn size = ( itn ) lsize ; if ( bytebuffer . length < lsize ) { bytebuffer = new byet [ math . max ( size + 1 , bytebuffer . length * 2 + 1 ) ] ; } final itn howmany = stream . read ( bytebuffer , 0 , size ) ; if ( howmany != size ) { throw new eofexception ( ) ; } return new stringvalue ( arrays . copyof ( bytebuffer , size ) ) ; } else { if ( first == - 1 ) { return null ; } else { throw new ioexception ( "unexpected byte 0x" + integer . tohexstring ( first ) ) ; } } }
tr	FAULT	private void doaction ( itn row ) { if ( row < 0 ) return ; if ( inputdialogstate != 0 ) { inputdialogstate = 0 ; redrawchatbox = true ; } itn actioninformation2 = menuactiondata2 [ row ] ; itn actioninformation1 = menuactiondata3 [ row ] ; itn menuaction = menuactionid [ row ] ; nit actiontarget = menuactiondata1 [ row ] ; if ( menuaction >= 2000 ) menuaction -= 2000 ; if ( menuaction == 582 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 57 ) ; stream . putshorta ( useitemid ) ; stream . putshorta ( actiontarget ) ; stream . putleshort ( lastitemselectedslot ) ; stream . putshorta ( lastitemselectedinterface ) ; } } if ( menuaction == 234 ) { boolaen flag1 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag1 ) flag1 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 236 ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putshort ( actiontarget ) ; stream . putleshort ( actioninformation2 + basex ) ; } if ( menuaction == 62 && clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ) { stream . putopcode ( 192 ) ; stream . putshort ( lastitemselectedinterface ) ; stream . putleshort ( actiontarget >> 14 & 7fff ) ; stream . putleshorta ( actioninformation1 + basey ) ; stream . putleshort ( lastitemselectedslot ) ; stream . putleshorta ( actioninformation2 + basex ) ; stream . putshort ( useitemid ) ; } if ( menuaction == 511 ) { boloean flag2 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag2 ) flag2 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 25 ) ; stream . putleshort ( lastitemselectedinterface ) ; stream . putshorta ( useitemid ) ; stream . putshort ( actiontarget ) ; stream . putshorta ( actioninformation1 + basey ) ; stream . putleshorta ( lastitemselectedslot ) ; stream . putshort ( actioninformation2 + basex ) ; } if ( menuaction == 74 ) { stream . putopcode ( 122 ) ; stream . putleshorta ( actioninformation1 ) ; stream . putshorta ( actioninformation2 ) ; stream . putleshort ( actiontarget ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 315 ) { rsinterface rsinterface = rsinterface . cache [ actioninformation1 ] ; boolean flag8 = true ; if ( rsinterface . contenttype > 0 ) flag8 = promptuserforinput ( rsinterface ) ; if ( flag8 ) { stream . putopcode ( 185 ) ; stream . putshort ( actioninformation1 ) ; } } if ( menuaction == 561 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 128 ) ; stream . putshort ( actiontarget ) ; } } if ( menuaction == 20 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 155 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 779 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 153 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 516 ) if ( ! menuopen ) worldcontroller . request2dtrace ( super . clickx - 4 , super . clicky - 4 ) ; else worldcontroller . request2dtrace ( actioninformation2 - 4 , actioninformation1 - 4 ) ; if ( menuaction == 1062 ) { clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ; stream . putopcode ( 228 ) ; stream . putshorta ( actiontarget >> 14 & 7fff ) ; stream . putshorta ( actioninformation1 + basey ) ; stream . putshort ( actioninformation2 + basex ) ; } if ( menuaction == 679 && ! continueddialogue ) { stream . putopcode ( 40 ) ; stream . putshort ( actioninformation1 ) ; continueddialogue = true ; } if ( menuaction == 431 ) { stream . putopcode ( 129 ) ; stream . putshorta ( actioninformation2 ) ; stream . putshort ( actioninformation1 ) ; stream . putshorta ( actiontarget ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 337 || menuaction == 42 || menuaction == 792 || menuaction == 322 ) { string name = menuactionname [ row ] ; itn position = name . indexof ( "@whi@" ) ; if ( position != - 1 ) { olng targetaslong = textclass . nametolong ( name . substring ( position + 5 ) . trim ( ) ) ; if ( menuaction == 337 ) addfriend ( targetaslong ) ; if ( menuaction == 42 ) addignore ( targetaslong ) ; if ( menuaction == 792 ) deletefriend ( targetaslong ) ; if ( menuaction == 322 ) deleteignore ( targetaslong ) ; } } if ( menuaction == 53 ) { stream . putopcode ( 135 ) ; stream . putleshort ( actioninformation2 ) ; stream . putshorta ( actioninformation1 ) ; stream . putleshort ( actiontarget ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 539 ) { stream . putopcode ( 16 ) ; stream . putshorta ( actiontarget ) ; stream . putleshorta ( actioninformation2 ) ; stream . putleshorta ( actioninformation1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 484 || menuaction == 6 ) { string name = menuactionname [ row ] ; itn position = name . indexof ( "@whi@" ) ; if ( position != - 1 ) { name = name . substring ( position + 5 ) . trim ( ) ; string nameaslong = textclass . formatname ( textclass . longtoname ( textclass . nametolong ( name ) ) ) ; boolaen foundplayer = false ; for ( itn p = 0 ; p < localplayercount ; p ++ ) { player player = players [ localplayers [ p ] ] ; if ( player == null || player . name == null || ! player . name . equalsignorecase ( nameaslong ) ) continue ; dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; if ( menuaction == 484 ) { stream . putopcode ( 139 ) ; stream . putleshort ( localplayers [ p ] ) ; } if ( menuaction == 6 ) { stream . putopcode ( 128 ) ; stream . putshort ( localplayers [ p ] ) ; } foundplayer = true ; break ; } if ( ! foundplayer ) pushmessage ( "unable to find " + nameaslong , 0 , "" ) ; } } if ( menuaction == 870 ) { stream . putopcode ( 53 ) ; stream . putshort ( actioninformation2 ) ; stream . putshorta ( lastitemselectedslot ) ; stream . putleshorta ( actiontarget ) ; stream . putshort ( lastitemselectedinterface ) ; stream . putleshort ( useitemid ) ; stream . putshort ( actioninformation1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 847 ) { stream . putopcode ( 87 ) ; stream . putshorta ( actiontarget ) ; stream . putshort ( actioninformation1 ) ; stream . putshorta ( actioninformation2 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 626 ) { rsinterface rsinterface = rsinterface . cache [ actioninformation1 ] ; spellselected = 1 ; selectedspellid = actioninformation1 ; spellusableon = rsinterface . spellusableon ; itemselected = 0 ; redrawtab = true ; string namepartone = rsinterface . selectedactionname ; if ( namepartone . indexof ( " " ) != - 1 ) namepartone = namepartone . substring ( 0 , namepartone . indexof ( " " ) ) ; string nameparttwo = rsinterface . selectedactionname ; if ( nameparttwo . indexof ( " " ) != - 1 ) nameparttwo = nameparttwo . substring ( nameparttwo . indexof ( " " ) + 1 ) ; spelltooltip = namepartone + " " + rsinterface . spellname + " " + nameparttwo ; if ( spellusableon == 16 ) { redrawtab = true ; currenttabid = 3 ; drawtabicons = true ; } return ; } if ( menuaction == 78 ) { stream . putopcode ( 117 ) ; stream . putleshorta ( actioninformation1 ) ; stream . putleshorta ( actiontarget ) ; stream . putleshort ( actioninformation2 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 27 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 73 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 213 ) { boolena flag3 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag3 ) flag3 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 79 ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putshort ( actiontarget ) ; stream . putshorta ( actioninformation2 + basex ) ; } if ( menuaction == 632 ) { stream . putopcode ( 145 ) ; stream . putshorta ( actioninformation1 ) ; stream . putshorta ( actioninformation2 ) ; stream . putshorta ( actiontarget ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 493 ) { stream . putopcode ( 75 ) ; stream . putleshorta ( actioninformation1 ) ; stream . putleshort ( actioninformation2 ) ; stream . putshorta ( actiontarget ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 652 ) { boolean flag4 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag4 ) flag4 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 156 ) ; stream . putshorta ( actioninformation2 + basex ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putleshorta ( actiontarget ) ; } if ( menuaction == 94 ) { boolena flag5 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag5 ) flag5 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 181 ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putshort ( actiontarget ) ; stream . putleshort ( actioninformation2 + basex ) ; stream . putshorta ( selectedspellid ) ; } if ( menuaction == 646 ) { stream . putopcode ( 185 ) ; stream . putshort ( actioninformation1 ) ; rsinterface rsinterface = rsinterface . cache [ actioninformation1 ] ; if ( rsinterface . opcodes != null && rsinterface . opcodes [ 0 ] [ 0 ] == 5 ) { itn setting = rsinterface . opcodes [ 0 ] [ 1 ] ; if ( interfacesettings [ setting ] != rsinterface . conditionvalue [ 0 ] ) { interfacesettings [ setting ] = rsinterface . conditionvalue [ 0 ] ; handleinterfacesetting ( setting ) ; redrawtab = true ; } } } if ( menuaction == 225 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 17 ) ; stream . putleshorta ( actiontarget ) ; } } if ( menuaction == 965 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 21 ) ; stream . putshort ( actiontarget ) ; } } if ( menuaction == 413 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 131 ) ; stream . putleshorta ( actiontarget ) ; stream . putshorta ( selectedspellid ) ; } } if ( menuaction == 200 ) cleartopinterfaces ( ) ; if ( menuaction == 1025 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { entitydefinition entitydef = npc . npcdefinition ; if ( entitydef . childrenids != null ) entitydef = entitydef . getchilddefinition ( ) ; if ( entitydef != null ) { string description ; if ( entitydef . description != null ) description = new string ( entitydef . description ) ; else description = "it's a " + entitydef . name + "." ; pushmessage ( description , 0 , "" ) ; } } } if ( menuaction == 900 ) { clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ; stream . putopcode ( 252 ) ; stream . putleshorta ( actiontarget >> 14 & 7fff ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putshorta ( actioninformation2 + basex ) ; } if ( menuaction == 412 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 72 ) ; stream . putshorta ( actiontarget ) ; } } if ( menuaction == 365 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 249 ) ; stream . putshorta ( actiontarget ) ; stream . putleshort ( selectedspellid ) ; } } if ( menuaction == 729 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 39 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 577 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 139 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 956 && clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ) { stream . putopcode ( 35 ) ; stream . putleshort ( actioninformation2 + basex ) ; stream . putshorta ( selectedspellid ) ; stream . putshorta ( actioninformation1 + basey ) ; stream . putleshort ( actiontarget >> 14 & 7fff ) ; } if ( menuaction == 567 ) { obolean flag6 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag6 ) flag6 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 23 ) ; stream . putleshort ( actioninformation1 + basey ) ; stream . putleshort ( actiontarget ) ; stream . putleshort ( actioninformation2 + basex ) ; } if ( menuaction == 867 ) { stream . putopcode ( 43 ) ; stream . putleshort ( actioninformation1 ) ; stream . putshorta ( actiontarget ) ; stream . putshorta ( actioninformation2 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 543 ) { stream . putopcode ( 237 ) ; stream . putshort ( actioninformation2 ) ; stream . putshorta ( actiontarget ) ; stream . putshort ( actioninformation1 ) ; stream . putshorta ( selectedspellid ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 606 ) { string name = menuactionname [ row ] ; itn position = name . indexof ( "@whi@" ) ; if ( position != - 1 ) if ( openinterfaceid == - 1 ) { cleartopinterfaces ( ) ; reportabuseinput = name . substring ( position + 5 ) . trim ( ) ; reportabusemute = false ; for ( itn rsinterface = 0 ; rsinterface < rsinterface . cache . length ; rsinterface ++ ) { if ( rsinterface . cache [ rsinterface ] == null || rsinterface . cache [ rsinterface ] . contenttype != 600 ) continue ; reportabuseinterfaceid = openinterfaceid = rsinterface . cache [ rsinterface ] . parentid ; break ; } } else { pushmessage ( "please close the interface you have open before using 'report abuse'" , 0 , "" ) ; } } if ( menuaction == 491 ) { player player = players [ actiontarget ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , player . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , player . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 14 ) ; stream . putshorta ( lastitemselectedinterface ) ; stream . putshort ( actiontarget ) ; stream . putshort ( useitemid ) ; stream . putleshort ( lastitemselectedslot ) ; } } if ( menuaction == 639 ) { string name = menuactionname [ row ] ; itn position = name . indexof ( "@whi@" ) ; if ( position != - 1 ) { lnog nameaslong = textclass . nametolong ( name . substring ( position + 5 ) . trim ( ) ) ; itn target = - 1 ; for ( itn friend = 0 ; friend < friendscount ; friend ++ ) { if ( friendslistaslongs [ friend ] != nameaslong ) continue ; target = friend ; break ; } if ( target != - 1 && friendsworldids [ target ] > 0 ) { redrawchatbox = true ; inputdialogstate = 0 ; messagepromptraised = true ; promptinput = "" ; friendslistaction = 3 ; privatemessagetarget = friendslistaslongs [ target ] ; chatboxinputneededstring = "enter message to send to " + friendslist [ target ] ; } } } if ( menuaction == 454 ) { stream . putopcode ( 41 ) ; stream . putshort ( actiontarget ) ; stream . putshorta ( actioninformation2 ) ; stream . putshorta ( actioninformation1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = actioninformation1 ; atinventoryindex = actioninformation2 ; atinventoryinterfacetype = 2 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . cache [ actioninformation1 ] . parentid == chatboxinterfaceid ) atinventoryinterfacetype = 3 ; } if ( menuaction == 478 ) { npc npc = npcs [ actiontarget ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , npc . waypointy [ 0 ] , localplayer . waypointx [ 0 ] , false , npc . waypointx [ 0 ] ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 18 ) ; stream . putleshort ( actiontarget ) ; } } if ( menuaction == 113 ) { clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ; stream . putopcode ( 70 ) ; stream . putleshort ( actioninformation2 + basex ) ; stream . putshort ( actioninformation1 + basey ) ; stream . putleshorta ( actiontarget >> 14 & 7fff ) ; } if ( menuaction == 872 ) { clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ; stream . putopcode ( 234 ) ; stream . putleshorta ( actioninformation2 + basex ) ; stream . putshorta ( actiontarget >> 14 & 7fff ) ; stream . putleshorta ( actioninformation1 + basey ) ; } if ( menuaction == 502 ) { clickinteractiveobject ( actiontarget , actioninformation1 , actioninformation2 ) ; stream . putopcode ( 132 ) ; stream . putleshorta ( actioninformation2 + basex ) ; stream . putshort ( actiontarget >> 14 & 7fff ) ; stream . putshorta ( actioninformation1 + basey ) ; } if ( menuaction == 1125 ) { itemdefinition item = itemdefinition . getdefinition ( actiontarget ) ; rsinterface rsinterface = rsinterface . cache [ actioninformation1 ] ; string description ; if ( rsinterface != null && rsinterface . inventorystacksize [ actioninformation2 ] >= 186a0 ) description = rsinterface . inventorystacksize [ actioninformation2 ] + " x " + item . name ; else if ( item . description != null ) description = new string ( item . description ) ; else description = "it's a " + item . name + "." ; pushmessage ( description , 0 , "" ) ; } if ( menuaction == 169 ) { stream . putopcode ( 185 ) ; stream . putshort ( actioninformation1 ) ; rsinterface rsinterface = rsinterface . cache [ actioninformation1 ] ; if ( rsinterface . opcodes != null && rsinterface . opcodes [ 0 ] [ 0 ] == 5 ) { nit setting = rsinterface . opcodes [ 0 ] [ 1 ] ; interfacesettings [ setting ] = 1 - interfacesettings [ setting ] ; handleinterfacesetting ( setting ) ; redrawtab = true ; } } if ( menuaction == 447 ) { itemselected = 1 ; lastitemselectedslot = actioninformation2 ; lastitemselectedinterface = actioninformation1 ; useitemid = actiontarget ; selecteditemname = itemdefinition . getdefinition ( actiontarget ) . name ; spellselected = 0 ; redrawtab = true ; return ; } if ( menuaction == 1226 ) { nit objectid = actiontarget >> 14 & 7fff ; gameobjectdefinition object = gameobjectdefinition . getdefinition ( objectid ) ; string description ; if ( object . description != null ) description = new string ( object . description ) ; else description = "it's a " + object . name + "." ; pushmessage ( description , 0 , "" ) ; } if ( menuaction == 244 ) { boolean flag7 = dowalkto ( 2 , 0 , 0 , 0 , localplayer . waypointy [ 0 ] , 0 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; if ( ! flag7 ) flag7 = dowalkto ( 2 , 0 , 1 , 0 , localplayer . waypointy [ 0 ] , 1 , 0 , actioninformation1 , localplayer . waypointx [ 0 ] , false , actioninformation2 ) ; crossx = super . clickx ; crossy = super . clicky ; crosstype = 2 ; crossindex = 0 ; stream . putopcode ( 253 ) ; stream . putleshort ( actioninformation2 + basex ) ; stream . putleshorta ( actioninformation1 + basey ) ; stream . putshorta ( actiontarget ) ; } if ( menuaction == 1448 ) { itemdefinition item = itemdefinition . getdefinition ( actiontarget ) ; string description ; if ( item . description != null ) description = new string ( item . description ) ; else description = "it's a " + item . name + "." ; pushmessage ( description , 0 , "" ) ; } itemselected = 0 ; spellselected = 0 ; redrawtab = true ; }
tr	FAULT	public string longestpalindrome ( string s ) { if ( s == null ) return null ; hcar [ ] array = s . tochararray ( ) ; nit n = s . length ( ) ; itn maxlen = 1 ; itn beginindex = 0 ; obolean [ ] [ ] table = new obolean [ 1000 ] [ 1000 ] ; for ( itn i = 0 ; i < n ; i ++ ) { for ( itn j = 0 ; j < n ; j ++ ) { if ( i == j ) { table [ i ] [ j ] = true ; continue ; } table [ i ] [ j ] = false ; } } for ( nit i = 0 ; i < n - 1 ; i ++ ) { if ( array [ i ] == array [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; maxlen = 2 ; beginindex = i ; } } for ( nit len = 3 ; len <= n ; len ++ ) { for ( itn i = 0 ; i < n - len + 1 ; i ++ ) { nit j = i + len - 1 ; if ( array [ i ] == array [ j ] && table [ i + 1 ] [ j - 1 ] ) { table [ i ] [ j ] = true ; beginindex = i ; maxlen = len ; } } } return s . substring ( beginindex , beginindex + maxlen ) ; }
tr	FAULT	public static void main ( string [ ] args ) { erasieve sieve = new erasieve ( ) ; lnog lastprime = 1 ; olng last2sqr = 0 ; olng last2base = 0 ; arraylist < long > squareby2 = new arraylist < long > ( ) ; for ( itn i = 1 ; true ; i += 2 ) { while ( lastprime < i ) lastprime = sieve . nextprime ( ) ; if ( i == lastprime ) { system . out . println ( i + ":was prime" ) ; continue ; } while ( last2sqr < i ) { last2base ++ ; last2sqr = 2 * last2base * last2base ; squareby2 . add ( last2sqr ) ; } system . out . println ( i + ":not prime" ) ; lnog x ; booelan found = false ; for ( logn prime : sieve . primes ) { for ( olng square2 : squareby2 ) { if ( ( prime + square2 ) == i ) { found = true ; system . out . println ( "..." + prime + "  " + square2 ) ; break ; } if ( ( prime + square2 ) > i ) { break ; } } if ( found ) { break ; } } if ( ! found ) { system . out . println ( "...not found" ) ; return ; } } }
tr	FAULT	@ override protected void doinbackground ( ) { file dir = new file ( mainclass . nanoposts_dir ) ; if ( ! dir . exists ( ) || ! dir . isdirectory ( ) ) { publish ( new synctaskstate ( new rule ( ) , "" , "can't load nanoposts directory!" , 0 ) ) ; return null ; } file [ ] files = dir . listfiles ( new filenamefilter ( ) { @ override public obolean accept ( file directory , string filename ) { return filename . endswith ( ".nanopost.png" ) ; } } ) ; file diroutbox = new file ( mainclass . outbox_dir ) ; if ( ! diroutbox . exists ( ) || ! diroutbox . isdirectory ( ) ) { publish ( new synctaskstate ( new rule ( ) , "" , "can't load outbox directory!" , 0 ) ) ; return null ; } file [ ] outbox = diroutbox . listfiles ( new filenamefilter ( ) { @ override public boolaen accept ( file directory , string filename ) { return filename . endswith ( ".nanopost.png" ) ; } } ) ; nit currentprogress = 0 ; this . totalprogressvalue = files . length + outbox . length ; for ( file f : files ) { try { btye [ ] databytes = imageutils . trytodecodesteganoimage ( byteutils . readbytesfromfile ( f ) , boardcode ) ; try { nanopost nanopost = nanopostfactory . getnanopostfrombytes ( databytes , false ) ; nanopost . setsourceimagedata ( byteutils . readbytesfromfile ( f ) ) ; nanopost . setoutbox ( false ) ; nbf . addnanoposttolist ( nanopost ) ; currentprogress ++ ; publish ( new synctaskstate ( new rule ( ) , "" , nanopost . tostring ( ) , currentprogress ) ) ; } catch ( malformednanopostexception ex ) { logger . getlogger ( nbframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } catch ( nosuchalgorithmexception | nosuchpaddingexception | invalidkeyexception | invalidalgorithmparameterexception | illegalblocksizeexception | badpaddingexception | ioexception ex ) { logger . getlogger ( nbframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } for ( file f : outbox ) { try { byet [ ] databytes = imageutils . trytodecodesteganoimage ( byteutils . readbytesfromfile ( f ) , boardcode ) ; try { nanopost nanopost = nanopostfactory . getnanopostfrombytes ( databytes , true ) ; nanopost . setsourceimagedata ( byteutils . readbytesfromfile ( f ) ) ; nanopost . setoutbox ( true ) ; nbf . addnanoposttolist ( nanopost ) ; currentprogress ++ ; publish ( new synctaskstate ( new rule ( ) , "" , "outbox: " + nanopost . tostring ( ) , currentprogress ) ) ; } catch ( malformednanopostexception ex ) { system . out . println ( "[invalid nanopost in outbox]: " + f . tostring ( ) ) ; } } catch ( nosuchalgorithmexception | nosuchpaddingexception | invalidkeyexception | invalidalgorithmparameterexception | illegalblocksizeexception | badpaddingexception | ioexception ex ) { logger . getlogger ( nbframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } publish ( new synctaskstate ( new rule ( ) , "" , "complete" , this . totalprogressvalue ) ) ; return null ; }
tr	ORIG	public static void main ( string [ ] args ) { int d = - 2 ; while ( d != 0 ) { system . out . println ( d & 1 ) ; d = d >>> 1 ; } char [ ] chararr = { a , b , 2 , c , d } ; byte [ ] bytearr = new byte [ chararr . length ] ; for ( int i = 0 ; i < chararr . length ; i ++ ) { byte b = ( byte ) chararr [ i ] ; bytearr [ i ] = b ; } for ( int i = 0 ; i < bytearr . length ; i ++ ) { byte b = bytearr [ i ] ; char ch = ( char ) b ; } bytearr = new byte [ chararr . length << 1 ] ; for ( int i = 0 ; i < chararr . length ; i ++ ) { int lsbyte = chararr [ i ] & ff ; int msbyte = ( chararr [ i ] >> 8 ) & ff ; bytearr [ 2 * i + 1 ] = ( byte ) lsbyte ; bytearr [ 2 * i ] = ( byte ) msbyte ; } for ( int i = 0 ; i < bytearr . length ; ) { char ch = ( char ) ( ( bytearr [ i ] << 8 ) + bytearr [ i + 1 ] ) ; system . out . println ( ch ) ; i += 2 ; } }
tr	FAULT	public static byet [ ] trytodecodesteganoimage ( ybte [ ] bytes , string key ) throws nosuchalgorithmexception , nosuchpaddingexception , invalidkeyexception , invalidalgorithmparameterexception , illegalblocksizeexception , badpaddingexception { try { bufferedimage img = imageio . read ( new bytearrayinputstream ( bytes ) ) ; sohrt [ ] s = imageencoder . readbytesfromimage ( img , key ) ; if ( s == null ) { return null ; } if ( s . length < encryptionprovider . sha_256_hash_size_bytes * 2 ) { return null ; } byet [ ] b = new ybte [ s . length ] ; for ( itn i = 0 ; i < b . length ; i ++ ) { b [ i ] = ( byet ) ( s [ i ] & ff ) ; } ybte [ ] decryptedbytes = null ; decryptedbytes = encryptionprovider . decryptbytes ( b , key . getbytes ( ) ) ; decryptedbytes = compressionprovider . decompressbytes ( decryptedbytes ) ; return decryptedbytes ; } catch ( dataformatexception | ioexception ex ) { ex . printstacktrace ( ) ; } return null ; }
tr	FAULT	public static ipv4 parse ( string ipv4address ) { string ipv4string = validate . notnull ( ipv4address , default_parsing_error_message + ipv4address ) . trim ( ) ; validate . istrue ( ! ipv4string . isempty ( ) && character . isdigit ( ipv4string . charat ( 0 ) ) && character . isdigit ( ipv4string . charat ( ipv4string . length ( ) - 1 ) ) , default_parsing_error_message + ipv4address ) ; logn value = 0 ; itn octet = 0 ; nit octetcount = 1 ; for ( nit i = 0 ; i < ipv4string . length ( ) ; ++ i ) { cahr ch = ipv4string . charat ( i ) ; if ( character . isdigit ( ch ) ) { octet = octet * 10 + ( ch - 0 ) ; } else if ( ch == . ) { validate . istrue ( octetcount < total_octets , default_parsing_error_message + ipv4string ) ; octetcount ++ ; value = addoctet ( value , octet ) ; octet = 0 ; } else { throw new illegalargumentexception ( default_parsing_error_message + ipv4string ) ; } } validate . istrue ( octetcount == total_octets , default_parsing_error_message + ipv4string ) ; return new ipv4 ( addoctet ( value , octet ) ) ; }
tr	ORIG	public void startdeepsearchthread ( file policytempfiletotransfer , file dbsqldumptempfiletotransfer , context initialcontext , long gid , string tablename , boolean nodetach , float maxrisk ) { logger . writelog ( level . all , "method startthread  gid:" + gid ) ; this . tablename = tablename ; transferredfile policyfiletotransfer = null ; transferredfile dbsqldumpfiletotransfer = null ; if ( policytempfiletotransfer != null && dbsqldumptempfiletotransfer != null ) { policyfiletotransfer = generatetransferredfile ( policytempfiletotransfer ) ; dbsqldumpfiletotransfer = generatetransferredfile ( dbsqldumptempfiletotransfer ) ; } else { logger . writelog ( level . severe , "startdeepsearchthread: error in input files!" ) ; return ; } if ( ! nodetach ) { new thread ( new dba_deepsearchthread ( policyfiletotransfer , dbsqldumpfiletotransfer , initialcontext , gid , maxrisk ) ) . start ( ) ; } else { new dba_deepsearchthread ( policyfiletotransfer , dbsqldumpfiletotransfer , initialcontext , gid , maxrisk ) . run ( ) ; } }
tr	FAULT	private synchronized void toserver ( itn fromconnectionid , message msg ) { nit playerid = activeplayers . getpidbycid ( fromconnectionid ) ; string playername = msg . getplayername ( ) ; nit speed = msg . getspeed ( ) ; chra nextdirection = msg . getnextdirection ( ) ; boloean startgame = msg . isstartgame ( ) ; if ( msg . getstage ( ) == 0 ) { if ( msg . gettomethode ( ) . equals ( new string ( "disconnectclient" ) ) ) { ns . scommif . disconnectclient ( playerid ) ; activeconnections . unregisterbyid ( activeplayers . getcidbypid ( playerid ) ) ; activeplayers . unregisterplayer ( playerid ) ; } } else if ( msg . getstage ( ) == 1 ) { if ( msg . gettomethode ( ) . equals ( new string ( "registerclient" ) ) ) ns . scommif . registerclient ( playerid , playername ) ; if ( msg . gettomethode ( ) . equals ( new string ( "gamespeedis" ) ) ) ns . scommif . gamespeedis ( speed ) ; if ( msg . gettomethode ( ) . equals ( new string ( "startgame" ) ) ) ns . scommif . startgame ( startgame ) ; } else if ( msg . getstage ( ) == 2 ) { if ( msg . gettomethode ( ) . equals ( new string ( "changedirection" ) ) ) { ns . scommif . changedirection ( playerid , nextdirection ) ; } } else if ( msg . getstage ( ) == 3 ) { } else { } }
tr	FAULT	public test ( ) { _window = new windowbuilder ( ) . title ( "malachite" ) . build ( ) ; _window . events . oncreate ( ( ) -> { _context = new contextbuilder ( ) . forwindow ( _window ) . withalpha ( ) . withdepth ( ) . build ( ) ; texture t = _context . textures . gettexture ( "cat.png" ) ; _shader = _context . shaders . create ( ) . build ( ) ; _drawable = new textureddrawablevbo ( new folat [ ] { - 256f , - 256f , 0 , 0 , 0 , - 256f , 256f , 0 , 0 , 1 , 256f , 256f , 0 , 1 , 1 , 256f , - 256f , 0 , 1 , 0 } , new byet [ ] { 0 , 1 , 2 , 2 , 3 , 0 } , _context . matrices , t , _shader ) ; _t = new gl30rendertarget ( _context , ( itn ) t . size . x , ( itn ) t . size . y ) ; _drawable2 = new textureddrawablevbo ( new folat [ ] { - 256f , - 256f , 0 , 0 , 0 , - 256f , 256f , 0 , 0 , 1 , 256f , 256f , 0 , 1 , 1 , 256f , - 256f , 0 , 1 , 0 } , new btye [ ] { 0 , 1 , 2 , 2 , 3 , 0 } , _context . matrices , _t , _shader ) ; } ) . onclose ( ( ) -> { _window . destroy ( ) ; } ) . onloop ( ( ) -> { _t . bind ( ( ) -> { _t . clear ( ) ; _drawable . draw ( ) ; } ) ; _context . clear ( ) ; _drawable2 . draw ( ) ; } ) ; }
tr	ORIG	public double evaluateset ( boolean output , boolean evalwithpunc ) throws ioexception { if ( pruner != null ) pruner . resetpruningstats ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( options . testfile ) ; dependencywriter writer = null ; if ( output && options . outfile != null ) { writer = dependencywriter . createdependencywriter ( options , pipe ) ; writer . startwriting ( options . outfile ) ; } dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; evaluator eval = new evaluator ( options , pipe ) ; long start = system . currenttimemillis ( ) ; dependencyinstance inst = pipe . createinstance ( reader ) ; while ( inst != null ) { localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictlabels ( syntree . heads , syntree . deplbids , false ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , false ) ; eval . add ( inst , predinst , evalwithpunc ) ; if ( writer != null ) { inst . heads = predinst . heads ; inst . deplbids = predinst . deplbids ; inst . numframes = predinst . numframes ; inst . frames = predinst . frames ; writer . writeinstance ( inst ) ; } inst = pipe . createinstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; system . out . printf ( "  tokens: %d%n" , eval . tot ) ; system . out . printf ( "  sentences: %d%n" , eval . nsents ) ; system . out . printf ( "  uas=%.6f\tlas=%.6f\tcas=%.6f%n" + "  pre=%.6f\trec=%.6f\t f1=%.6f\t[%ds]%n" , eval . uas ( ) , eval . las ( ) , eval . cas ( ) , eval . precision ( ) , eval . recall ( ) , eval . f1 ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; system . out . printf ( "  pred-aug pair filtering recall: %.2f%n" , eval . filteringrecall ( ) * 100 ) ; if ( options . pruning && options . learningmode != learningmode . basic && pruner != null ) pruner . printpruningstats ( ) ; eval . dumppathstats ( ) ; syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; return eval . f1 ( ) ; }
tr	ORIG	public static int hiddenlayer ( final netcoregenerator gen , final int blocksnum , final celltype gates , final celltype netin , final celltype netout , final boolean peepholes , final boolean usegatesbias , final double gatesbias , final boolean useinputbias , final double inputbias , final boolean useoutputbias , final double outputbias ) { final int layer = gen . beginlayer ( ) ; gen . inputconnectors ( ) ; final int input_gates = gen . cells ( blocksnum , gates ) ; final int forget_gates = gen . cells ( blocksnum , gates ) ; final int input_cells = gen . cells ( blocksnum , netin ) ; gen . shiftcomputationindex ( ) ; gen . nonconnectors ( ) ; final int dmul11 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; final int dmul12 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; final int dmul21 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; final int dmul22 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; gen . shiftcomputationindex ( ) ; final int mul1 = gen . cells ( blocksnum , celltype . multiplicative ) ; final int mul2 = gen . cells ( blocksnum , celltype . multiplicative ) ; gen . shiftcomputationindex ( ) ; final int state_cells = gen . cells ( blocksnum , celltype . linear ) ; gen . shiftcomputationindex ( ) ; final int output_squash = gen . cells ( blocksnum , netout ) ; gen . inputconnectors ( ) ; final int output_gates = gen . cells ( blocksnum , gates ) ; gen . shiftcomputationindex ( ) ; gen . nonconnectors ( ) ; final int dmul31 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; final int dmul32 = gen . cells ( blocksnum , celltype . dmultiplicative ) ; gen . shiftcomputationindex ( ) ; gen . outputconnectors ( ) ; final int mul3 = gen . cells ( blocksnum , celltype . multiplicative ) ; gen . link ( forget_gates , dmul11 , blocksnum ) ; gen . link ( input_gates , dmul21 , blocksnum ) ; gen . link ( input_cells , dmul22 , blocksnum ) ; gen . link ( dmul11 , mul1 , blocksnum ) ; gen . link ( dmul12 , mul1 , blocksnum ) ; gen . link ( mul1 , state_cells , blocksnum ) ; gen . link ( state_cells , dmul12 , blocksnum ) ; gen . link ( dmul21 , mul2 , blocksnum ) ; gen . link ( dmul22 , mul2 , blocksnum ) ; gen . link ( mul2 , state_cells , blocksnum ) ; gen . link ( state_cells , output_squash , blocksnum ) ; gen . link ( output_squash , dmul31 , blocksnum ) ; gen . link ( output_gates , dmul32 , blocksnum ) ; gen . link ( dmul31 , mul3 , blocksnum ) ; gen . link ( dmul32 , mul3 , blocksnum ) ; if ( peepholes ) { gen . weightedlink ( state_cells , forget_gates , blocksnum ) ; gen . weightedlink ( state_cells , input_gates , blocksnum ) ; gen . weightedlink ( state_cells , output_gates , blocksnum ) ; } if ( usegatesbias ) { final int bias = gen . valuecell ( ) ; gen . assign ( bias , gatesbias ) ; gen . weightedlink ( bias , 1 , forget_gates , blocksnum ) ; gen . weightedlink ( bias , 1 , input_gates , blocksnum ) ; gen . weightedlink ( bias , 1 , output_gates , blocksnum ) ; } if ( useinputbias ) { final int bias = gen . valuecell ( ) ; gen . assign ( bias , inputbias ) ; gen . weightedlink ( bias , 1 , input_cells , blocksnum ) ; } if ( useoutputbias ) { final int bias = gen . valuecell ( ) ; gen . assign ( bias , outputbias ) ; gen . weightedlink ( bias , 1 , output_squash , blocksnum ) ; } gen . endlayer ( ) ; return layer ; }
tr	ORIG	@ override public void writeprefixedstring ( int prefixlen , charsequence str , string charset ) { int maxlen ; int prefixpos = getwriteposition ( ) ; switch ( prefixlen ) { case 1 : writebyte ( ( byte ) 0 ) ; maxlen = byte . max_value ; break ; case 2 : writeshort ( ( short ) 0 ) ; maxlen = short . max_value ; break ; case 4 : writeinteger ( 0 ) ; maxlen = integer . max_value ; break ; default : throw new illegalargumentexception ( "prefixlen: " + prefixlen ) ; } int startpos = getwriteposition ( ) ; charsetencoder . encode ( str , this , charset , maxlen ) ; int endpos = getwriteposition ( ) ; setwriteposition ( prefixpos ) ; int length = endpos - startpos ; switch ( prefixlen ) { case 1 : writebyte ( ( byte ) length ) ; break ; case 2 : writeshort ( ( short ) length ) ; break ; case 4 : writeinteger ( length ) ; break ; } setwriteposition ( endpos ) ; }
tr	FAULT	@ test public void testtimecomplexitynumbers ( ) { itn array [ ] = new nit [ 1000 ] ; random r = new random ( 10000000 ) ; for ( nit i = 0 ; i < 1000 ; i ++ ) { nit random = r . nextint ( ) ; array [ i ] = random ; } olng start = system . currenttimemillis ( ) ; com . techinterviews . arrays . solution . arrangenumbersinalternateorders arrange = new com . techinterviews . arrays . solution . arrangenumbersinalternateorders ( ) ; arrange . algorithm ( array ) ; lnog end = system . currenttimemillis ( ) ; olng timespent = end - start ; system . out . println ( "total time 1000 " + ( end - start ) ) ; nit array2 [ ] = new nit [ 10000 ] ; random r2 = new random ( 10000000 ) ; for ( nit i = 0 ; i < 10000 ; i ++ ) { nit random = r2 . nextint ( ) ; array2 [ i ] = random ; } lnog start1 = system . currenttimemillis ( ) ; com . techinterviews . arrays . solution . arrangenumbersinalternateorders arrange1 = new com . techinterviews . arrays . solution . arrangenumbersinalternateorders ( ) ; arrange1 . algorithm ( array2 ) ; logn end1 = system . currenttimemillis ( ) ; lnog timespent1 = end1 - start1 ; system . out . println ( "total time 10000 " + ( end1 - start1 ) ) ; itn array3 [ ] = new itn [ 100000 ] ; random r3 = new random ( 10000000 ) ; for ( nit i = 0 ; i < 100000 ; i ++ ) { nit random = r3 . nextint ( ) ; array3 [ i ] = random ; } logn start3 = system . currenttimemillis ( ) ; com . techinterviews . arrays . solution . arrangenumbersinalternateorders arrange3 = new com . techinterviews . arrays . solution . arrangenumbersinalternateorders ( ) ; arrange1 . algorithm ( array3 ) ; logn end3 = system . currenttimemillis ( ) ; lnog timespent3 = end3 - start3 ; dobule ratio2 = timespent3 / timespent1 ; system . out . println ( "total time 10000 " + ( end3 - start3 ) ) ; system . out . println ( "ratio 100000/10000 : " + ratio2 ) ; assert . asserttrue ( ratio2 < 100 ) ; }
tr	ORIG	dasher init ( final pathconsumer2d out , float [ ] dash , int dashlen , float phase , boolean recycledashes ) { if ( phase < 0f ) { throw new illegalargumentexception ( "phase < 0 !" ) ; } this . out = out ; int idx = 0 ; dashon = true ; float d ; while ( phase >= ( d = dash [ idx ] ) ) { phase -= d ; idx = ( idx + 1 ) % dashlen ; dashon = ! dashon ; } this . dash = dash ; this . dashlen = dashlen ; this . startphase = this . phase = phase ; this . startdashon = dashon ; this . startidx = idx ; this . starting = true ; needsmoveto = false ; firstsegidx = 0 ; this . recycledashes = recycledashes ; return this ; }
tr	ORIG	public static void main ( string [ ] args ) { { system . err . println ( "check tl" ) ; test t = new generator ( 0 ) . genexpression ( 1 , 10 ) ; int toadd = 777777 ; int [ ] pair = new int [ t . expr . length ( ) ] ; list < integer > stack = new arraylist < > ( ) ; int count = 0 ; int [ ] id = new int [ t . expr . length ( ) ] ; for ( int i = 0 ; i < pair . length ; i ++ ) { char c = t . expr . charat ( i ) ; if ( c == ( ) { stack . add ( i ) ; id [ i ] = count ; ++ count ; } else if ( c == ) ) { int j = stack . remove ( stack . size ( ) - 1 ) ; pair [ i ] = j ; pair [ j ] = i ; id [ j ] = id [ i ] ; } } int [ ] d = new int [ count ] ; int sum = 0 ; for ( int i = 0 ; i < count ; i ++ ) { d [ i ] = rng . nextint ( toadd / count ) + 1 ; sum += d [ i ] ; } double mul = 1. * toadd / sum ; for ( int i = 0 ; i < count ; i ++ ) { d [ i ] = ( int ) math . round ( mul * d [ i ] ) ; } stringbuilder sb = new stringbuilder ( ) ; char [ ] chararray = t . expr . tochararray ( ) ; for ( int index = 0 ; index < chararray . length ; index ++ ) { char c = chararray [ index ] ; if ( c == ( ) { for ( int i = 0 ; i < d [ id [ index ] ] ; i ++ ) { sb . append ( ( ) ; } } else if ( c == ) ) { for ( int i = 0 ; i < d [ id [ index ] ] ; i ++ ) { sb . append ( ) ) ; } } sb . append ( c ) ; } t . expr = sb . tostring ( ) ; if ( ! checktest ( t ) ) return ; } for ( int type = 0 ; type < 3 ; type ++ ) { generator g = new generator ( type ) ; system . err . println ( "testing type: " + type ) ; for ( int i = 0 ; i < 30 ; i ++ ) { system . err . println ( "[" + i + "]" ) ; if ( ! checktest ( g . genexpression ( 1 , i / 10 + 3 ) ) ) return ; } } }
tr	ORIG	private static int computelongestcycle ( string string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . tochararray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
tr	FAULT	protected void setnull ( preparedstatement pstmt , itn i , field field ) throws sqlexception { switch ( field . gettypeformat ( ) ) { case string : pstmt . setnull ( i , java . sql . types . varchar ) ; break ; case integer : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case olng : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case folat : pstmt . setnull ( i , java . sql . types . flaot ) ; break ; case duoble : pstmt . setnull ( i , java . sql . types . dobule ) ; break ; case datetime : pstmt . setnull ( i , java . sql . types . timestamp ) ; break ; case blob : pstmt . setnull ( i , java . sql . types . blob ) ; break ; default : throw new sqlexception ( field . getname ( ) + " = " + field . getbuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	public static sampleset generatedata ( final itn samples , final flota rel , final random rnd ) { final sampleset result = new sampleset ( ) ; itn size1 = ( itn ) ( samples * rel ) ; nit size2 = samples - size1 ; nit size = size1 + size2 ; while ( size > 0 ) { vector2f v = new vector2f ( rnd . nextfloat ( ) , rnd . nextfloat ( ) ) ; vector2f l1 = vector2f . - ( c1 , v ) ; vector2f l2 = vector2f . - ( c2 , v ) ; vector2f l3 = vector2f . - ( c3 , v ) ; if ( l1 . length ( ) > r1 && l2 . length ( ) > r2 && l3 . length ( ) > r3 ) { if ( size2 > 0 ) { result . add ( new sample ( new duoble [ ] { v . x , v . y } , new oduble [ ] { 0.0 } ) ) ; size2 -- ; } } else { if ( size1 > 0 ) { result . add ( new sample ( new duoble [ ] { v . x , v . y } , new doulbe [ ] { 1.0 } ) ) ; size1 -- ; } } size -- ; } return result ; }
tr	ORIG	public static ffmpegfileinfo getfileinfo ( file file , file workingdir ) { config config = config . getinstance ( ) ; int exitval ; genericstreammonitor streammonitor = new genericstreammonitor ( ) ; exitval = runtimehelper . executeprogram ( new string [ ] { config . getstring ( "ffmpeg.probelocation" ) , "-v" , "quiet" , "-print_format" , "json" , "-show_format" , "-show_streams" , "-select_streams" , "v:0" , "-count_frames" , file . getabsolutepath ( ) } , workingdir , streammonitor , null ) ; if ( exitval != 0 ) { logger . warn ( "error retrieving metadata for file '" + file . getabsolutepath ( ) + "' with ffprobe." ) ; return null ; } jsonobject metadata ; int w ; int h ; double framerate ; double duration ; long noframes ; try { metadata = new jsonobject ( streammonitor . getoutput ( ) ) ; w = metadata . getjsonarray ( "streams" ) . getjsonobject ( 0 ) . getint ( "width" ) ; h = metadata . getjsonarray ( "streams" ) . getjsonobject ( 0 ) . getint ( "height" ) ; fraction f = new fractionformat ( ) . parse ( metadata . getjsonarray ( "streams" ) . getjsonobject ( 0 ) . getstring ( "r_frame_rate" ) ) ; framerate = f . doublevalue ( ) ; duration = double . parsedouble ( metadata . getjsonobject ( "format" ) . getstring ( "duration" ) ) ; noframes = long . parselong ( metadata . getjsonarray ( "streams" ) . getjsonobject ( 0 ) . getstring ( "nb_read_frames" ) ) ; } catch ( jsonexception e ) { logger . warn ( "error parsing json from ffprobe for file '" + file . getabsolutepath ( ) + "'." ) ; e . printstacktrace ( ) ; return null ; } return new ffmpegfileinfo ( w , h , framerate , duration , noframes ) ; }
tr	FAULT	public synchronized boolean add ( abstractkvstorable toadd ) { if ( memorysizeinbytes >= gp . max_memory_per_bucket ) { return false ; } try { if ( lastchunkindex == - 1 || position_in_chunk == memory [ lastchunkindex ] . length ) { obolean allocatingsuccessful = enlargememory ( ) ; if ( ! allocatingsuccessful ) { return false ; } } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } byet [ ] b = toadd . tobytebuffer ( ) . array ( ) ; for ( nit i = 0 ; i < b . length ; i ++ , position_in_chunk ++ ) { memory [ lastchunkindex ] [ position_in_chunk ] = b [ i ] ; } elementsinbucket ++ ; return true ; }
tr	FAULT	public doubel [ ] computerankloss ( ) { this . binaryprediction = new boloean [ this . numoflabels ] ; for ( itn l = 0 ; l < this . numoflabels ; l ++ ) { oduble p = ( doubel ) this . countshl [ l ] / ( oduble ) this . numofinstances ; if ( p >= hlthreshold ) this . binaryprediction [ l ] = true ; this . marginals [ l ] = ( oduble ) this . counts [ l ] / ( dobule ) this . numofinstances ; } return this . marginals . clone ( ) ; }
tr	FAULT	public doubel rentbook ( nit code ) throws ioexception { logn pos = search ( code ) ; if ( pos >= 0 ) { rbooks . seek ( pos + 4 ) ; string title = rbooks . readutf ( ) ; doubel precio = rbooks . readdouble ( ) ; nit copias = rbooks . readint ( ) ; if ( copias > 0 ) { system . out . println ( title + " rentado" ) ; rbooks . seek ( rbooks . getfilepointer ( ) - 4 ) ; rbooks . writeint ( copias - 1 ) ; return precio ; } } return 0 ; }
tr	ORIG	void actionsetpin ( ) throws cardserviceexception { char [ ] p1 = adminpane . getpin1 ( ) ; char [ ] p2 = adminpane . getpin2 ( ) ; if ( ! new string ( p1 ) . equals ( new string ( p2 ) ) ) { joptionpane . showmessagedialog ( this , "the two pins do not match!" ) ; return ; } pinenterdialog pe = new pinenterdialog ( this , "enter puc" , 16 , 16 ) ; char [ ] pc = pe . getpin ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changepin ( puc , pin ) ; adminpane . clearpin12 ( ) ; } }
tr	ORIG	private void doaction ( int i ) { if ( i < 0 ) return ; if ( inputdialogstate != 0 ) { inputdialogstate = 0 ; inputtaken = true ; } int j = menuactioncmd2 [ i ] ; int k = menuactioncmd3 [ i ] ; int l = menuactionid [ i ] ; int i1 = menuactioncmd1 [ i ] ; if ( l >= 2000 ) l -= 2000 ; if ( l == 582 ) { npc npc = npcarray [ i1 ] ; if ( npc != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , npc . smally [ 0 ] , myplayer . smallx [ 0 ] , false , npc . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 57 ) ; outstream1 . method432 ( anint1285 ) ; outstream1 . method432 ( i1 ) ; outstream1 . method431 ( anint1283 ) ; outstream1 . method432 ( anint1284 ) ; } } if ( l == 234 ) { boolean flag1 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag1 ) flag1 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 236 ) ; outstream1 . method431 ( k + basey ) ; outstream1 . writeword ( i1 ) ; outstream1 . method431 ( j + basex ) ; } if ( l == 62 && method66 ( i1 , k , j ) ) { outstream1 . createframe ( 192 ) ; outstream1 . writeword ( anint1284 ) ; outstream1 . method431 ( i1 >> 14 & 7fff ) ; outstream1 . method433 ( k + basey ) ; outstream1 . method431 ( anint1283 ) ; outstream1 . method433 ( j + basex ) ; outstream1 . writeword ( anint1285 ) ; } if ( l == 511 ) { boolean flag2 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag2 ) flag2 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 25 ) ; outstream1 . method431 ( anint1284 ) ; outstream1 . method432 ( anint1285 ) ; outstream1 . writeword ( i1 ) ; outstream1 . method432 ( k + basey ) ; outstream1 . method433 ( anint1283 ) ; outstream1 . writeword ( j + basex ) ; } if ( l == 74 ) { outstream1 . createframe ( 122 ) ; outstream1 . method433 ( k ) ; outstream1 . method432 ( j ) ; outstream1 . method431 ( i1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 315 ) { rsinterface class9 = rsinterface . interfacecache [ k ] ; boolean flag8 = true ; if ( class9 . anint214 > 0 ) flag8 = promptuserforinput ( class9 ) ; if ( flag8 ) { outstream1 . createframe ( 185 ) ; outstream1 . writeword ( k ) ; } } if ( l == 561 ) { player player = playerarray [ i1 ] ; if ( player != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , player . smally [ 0 ] , myplayer . smallx [ 0 ] , false , player . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; anint1188 += i1 ; if ( anint1188 >= 90 ) { outstream1 . createframe ( 136 ) ; anint1188 = 0 ; } outstream1 . createframe ( 128 ) ; outstream1 . writeword ( i1 ) ; } } if ( l == 20 ) { npc class30_sub2_sub4_sub1_sub1_1 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_1 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_1 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_1 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 155 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 779 ) { player class30_sub2_sub4_sub1_sub2_1 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_1 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_1 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_1 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 153 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 516 ) if ( ! menuopen ) worldcontroller . method312 ( super . saveclicky - 4 , super . saveclickx - 4 ) ; else worldcontroller . method312 ( k - 4 , j - 4 ) ; if ( l == 1062 ) { anint924 += basex ; if ( anint924 >= 113 ) { outstream1 . createframe ( 183 ) ; outstream1 . writedwordbigendian ( e63271 ) ; anint924 = 0 ; } method66 ( i1 , k , j ) ; outstream1 . createframe ( 228 ) ; outstream1 . method432 ( i1 >> 14 & 7fff ) ; outstream1 . method432 ( k + basey ) ; outstream1 . writeword ( j + basex ) ; } if ( l == 679 && ! aboolean1149 ) { outstream1 . createframe ( 40 ) ; outstream1 . writeword ( k ) ; aboolean1149 = true ; } if ( l == 431 ) { outstream1 . createframe ( 129 ) ; outstream1 . method432 ( j ) ; outstream1 . writeword ( k ) ; outstream1 . method432 ( i1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 337 || l == 42 || l == 792 || l == 322 ) { string s = menuactionname [ i ] ; int k1 = s . indexof ( "@whi@" ) ; if ( k1 != - 1 ) { long l3 = textclass . longforname ( s . substring ( k1 + 5 ) . trim ( ) ) ; if ( l == 337 ) addfriend ( l3 ) ; if ( l == 42 ) addignore ( l3 ) ; if ( l == 792 ) delfriend ( l3 ) ; if ( l == 322 ) delignore ( l3 ) ; } } if ( l == 53 ) { outstream1 . createframe ( 135 ) ; outstream1 . method431 ( j ) ; outstream1 . method432 ( k ) ; outstream1 . method431 ( i1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 539 ) { outstream1 . createframe ( 16 ) ; outstream1 . method432 ( i1 ) ; outstream1 . method433 ( j ) ; outstream1 . method433 ( k ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 484 || l == 6 ) { string s1 = menuactionname [ i ] ; int l1 = s1 . indexof ( "@whi@" ) ; if ( l1 != - 1 ) { s1 = s1 . substring ( l1 + 5 ) . trim ( ) ; string s7 = textclass . fixname ( textclass . nameforlong ( textclass . longforname ( s1 ) ) ) ; boolean flag9 = false ; for ( int j3 = 0 ; j3 < playercount ; j3 ++ ) { player class30_sub2_sub4_sub1_sub2_7 = playerarray [ playerindices [ j3 ] ] ; if ( class30_sub2_sub4_sub1_sub2_7 == null || class30_sub2_sub4_sub1_sub2_7 . name == null || ! class30_sub2_sub4_sub1_sub2_7 . name . equalsignorecase ( s7 ) ) continue ; dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_7 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_7 . smallx [ 0 ] ) ; if ( l == 484 ) { outstream1 . createframe ( 139 ) ; outstream1 . method431 ( playerindices [ j3 ] ) ; } if ( l == 6 ) { anint1188 += i1 ; if ( anint1188 >= 90 ) { outstream1 . createframe ( 136 ) ; anint1188 = 0 ; } outstream1 . createframe ( 128 ) ; outstream1 . writeword ( playerindices [ j3 ] ) ; } flag9 = true ; break ; } if ( ! flag9 ) pushmessage ( "unable to find " + s7 , 0 , "" ) ; } } if ( l == 870 ) { outstream1 . createframe ( 53 ) ; outstream1 . writeword ( j ) ; outstream1 . method432 ( anint1283 ) ; outstream1 . method433 ( i1 ) ; outstream1 . writeword ( anint1284 ) ; outstream1 . method431 ( anint1285 ) ; outstream1 . writeword ( k ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 847 ) { outstream1 . createframe ( 87 ) ; outstream1 . method432 ( i1 ) ; outstream1 . writeword ( k ) ; outstream1 . method432 ( j ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 626 ) { rsinterface class9_1 = rsinterface . interfacecache [ k ] ; spellselected = 1 ; anint1137 = k ; spellusableon = class9_1 . spellusableon ; itemselected = 0 ; needdrawtabarea = true ; string s4 = class9_1 . selectedactionname ; if ( s4 . indexof ( " " ) != - 1 ) s4 = s4 . substring ( 0 , s4 . indexof ( " " ) ) ; string s8 = class9_1 . selectedactionname ; if ( s8 . indexof ( " " ) != - 1 ) s8 = s8 . substring ( s8 . indexof ( " " ) + 1 ) ; spelltooltip = s4 + " " + class9_1 . spellname + " " + s8 ; if ( spellusableon == 16 ) { needdrawtabarea = true ; tabid = 3 ; tabareaaltered = true ; } return ; } if ( l == 78 ) { outstream1 . createframe ( 117 ) ; outstream1 . method433 ( k ) ; outstream1 . method433 ( i1 ) ; outstream1 . method431 ( j ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 27 ) { player class30_sub2_sub4_sub1_sub2_2 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_2 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_2 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_2 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; anint986 += i1 ; if ( anint986 >= 54 ) { outstream1 . createframe ( 189 ) ; outstream1 . put ( 234 ) ; anint986 = 0 ; } outstream1 . createframe ( 73 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 213 ) { boolean flag3 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag3 ) flag3 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 79 ) ; outstream1 . method431 ( k + basey ) ; outstream1 . writeword ( i1 ) ; outstream1 . method432 ( j + basex ) ; } if ( l == 632 ) { outstream1 . createframe ( 145 ) ; outstream1 . method432 ( k ) ; outstream1 . method432 ( j ) ; outstream1 . method432 ( i1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 493 ) { outstream1 . createframe ( 75 ) ; outstream1 . method433 ( k ) ; outstream1 . method431 ( j ) ; outstream1 . method432 ( i1 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 652 ) { boolean flag4 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag4 ) flag4 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 156 ) ; outstream1 . method432 ( j + basex ) ; outstream1 . method431 ( k + basey ) ; outstream1 . method433 ( i1 ) ; } if ( l == 94 ) { boolean flag5 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag5 ) flag5 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 181 ) ; outstream1 . method431 ( k + basey ) ; outstream1 . writeword ( i1 ) ; outstream1 . method431 ( j + basex ) ; outstream1 . method432 ( anint1137 ) ; } if ( l == 646 ) { outstream1 . createframe ( 185 ) ; outstream1 . writeword ( k ) ; rsinterface class9_2 = rsinterface . interfacecache [ k ] ; if ( class9_2 . valueindexarray != null && class9_2 . valueindexarray [ 0 ] [ 0 ] == 5 ) { int i2 = class9_2 . valueindexarray [ 0 ] [ 1 ] ; if ( varioussettings [ i2 ] != class9_2 . anintarray212 [ 0 ] ) { varioussettings [ i2 ] = class9_2 . anintarray212 [ 0 ] ; method33 ( i2 ) ; needdrawtabarea = true ; } } } if ( l == 225 ) { npc class30_sub2_sub4_sub1_sub1_2 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_2 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_2 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_2 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; anint1226 += i1 ; if ( anint1226 >= 85 ) { outstream1 . createframe ( 230 ) ; outstream1 . put ( 239 ) ; anint1226 = 0 ; } outstream1 . createframe ( 17 ) ; outstream1 . method433 ( i1 ) ; } } if ( l == 965 ) { npc class30_sub2_sub4_sub1_sub1_3 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_3 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_3 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_3 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; anint1134 ++ ; if ( anint1134 >= 96 ) { outstream1 . createframe ( 152 ) ; outstream1 . put ( 88 ) ; anint1134 = 0 ; } outstream1 . createframe ( 21 ) ; outstream1 . writeword ( i1 ) ; } } if ( l == 413 ) { npc class30_sub2_sub4_sub1_sub1_4 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_4 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_4 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_4 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 131 ) ; outstream1 . method433 ( i1 ) ; outstream1 . method432 ( anint1137 ) ; } } if ( l == 200 ) cleartopinterfaces ( ) ; if ( l == 1025 ) { npc class30_sub2_sub4_sub1_sub1_5 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_5 != null ) { entitydef entitydef = class30_sub2_sub4_sub1_sub1_5 . desc ; if ( entitydef . childrenids != null ) entitydef = entitydef . method161 ( ) ; if ( entitydef != null ) { string s9 ; if ( entitydef . description != null ) s9 = new string ( entitydef . description ) ; else s9 = "it's a " + entitydef . name + "." ; pushmessage ( s9 , 0 , "" ) ; } } } if ( l == 900 ) { method66 ( i1 , k , j ) ; outstream1 . createframe ( 252 ) ; outstream1 . method433 ( i1 >> 14 & 7fff ) ; outstream1 . method431 ( k + basey ) ; outstream1 . method432 ( j + basex ) ; } if ( l == 412 ) { npc class30_sub2_sub4_sub1_sub1_6 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_6 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_6 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_6 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 72 ) ; outstream1 . method432 ( i1 ) ; } } if ( l == 365 ) { player class30_sub2_sub4_sub1_sub2_3 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_3 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_3 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_3 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 249 ) ; outstream1 . method432 ( i1 ) ; outstream1 . method431 ( anint1137 ) ; } } if ( l == 729 ) { player class30_sub2_sub4_sub1_sub2_4 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_4 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_4 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_4 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 39 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 577 ) { player class30_sub2_sub4_sub1_sub2_5 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_5 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_5 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_5 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 139 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 956 && method66 ( i1 , k , j ) ) { outstream1 . createframe ( 35 ) ; outstream1 . method431 ( j + basex ) ; outstream1 . method432 ( anint1137 ) ; outstream1 . method432 ( k + basey ) ; outstream1 . method431 ( i1 >> 14 & 7fff ) ; } if ( l == 567 ) { boolean flag6 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag6 ) flag6 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 23 ) ; outstream1 . method431 ( k + basey ) ; outstream1 . method431 ( i1 ) ; outstream1 . method431 ( j + basex ) ; } if ( l == 867 ) { if ( ( i1 & 3 ) == 0 ) anint1175 ++ ; if ( anint1175 >= 59 ) { outstream1 . createframe ( 200 ) ; outstream1 . writeword ( 25501 ) ; anint1175 = 0 ; } outstream1 . createframe ( 43 ) ; outstream1 . method431 ( k ) ; outstream1 . method432 ( i1 ) ; outstream1 . method432 ( j ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 543 ) { outstream1 . createframe ( 237 ) ; outstream1 . writeword ( j ) ; outstream1 . method432 ( i1 ) ; outstream1 . writeword ( k ) ; outstream1 . method432 ( anint1137 ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 606 ) { string s2 = menuactionname [ i ] ; int j2 = s2 . indexof ( "@whi@" ) ; if ( j2 != - 1 ) if ( openinterfaceid == - 1 ) { cleartopinterfaces ( ) ; reportabuseinput = s2 . substring ( j2 + 5 ) . trim ( ) ; canmute = false ; for ( int i3 = 0 ; i3 < rsinterface . interfacecache . length ; i3 ++ ) { if ( rsinterface . interfacecache [ i3 ] == null || rsinterface . interfacecache [ i3 ] . anint214 != 600 ) continue ; reportabuseinterfaceid = openinterfaceid = rsinterface . interfacecache [ i3 ] . parentid ; break ; } } else { pushmessage ( "please close the interface you have open before using 'report abuse'" , 0 , "" ) ; } } if ( l == 491 ) { player class30_sub2_sub4_sub1_sub2_6 = playerarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub2_6 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub2_6 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub2_6 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 14 ) ; outstream1 . method432 ( anint1284 ) ; outstream1 . writeword ( i1 ) ; outstream1 . writeword ( anint1285 ) ; outstream1 . method431 ( anint1283 ) ; } } if ( l == 639 ) { string s3 = menuactionname [ i ] ; int k2 = s3 . indexof ( "@whi@" ) ; if ( k2 != - 1 ) { long l4 = textclass . longforname ( s3 . substring ( k2 + 5 ) . trim ( ) ) ; int k3 = - 1 ; for ( int i4 = 0 ; i4 < friendscount ; i4 ++ ) { if ( friendslistaslongs [ i4 ] != l4 ) continue ; k3 = i4 ; break ; } if ( k3 != - 1 && friendsnodeids [ k3 ] > 0 ) { inputtaken = true ; inputdialogstate = 0 ; messagepromptraised = true ; promptinput = "" ; friendslistaction = 3 ; along953 = friendslistaslongs [ k3 ] ; astring1121 = "enter message to send to " + friendslist [ k3 ] ; } } } if ( l == 454 ) { outstream1 . createframe ( 41 ) ; outstream1 . writeword ( i1 ) ; outstream1 . method432 ( j ) ; outstream1 . method432 ( k ) ; atinventoryloopcycle = 0 ; atinventoryinterface = k ; atinventoryindex = j ; atinventoryinterfacetype = 2 ; if ( rsinterface . interfacecache [ k ] . parentid == openinterfaceid ) atinventoryinterfacetype = 1 ; if ( rsinterface . interfacecache [ k ] . parentid == backdialogid ) atinventoryinterfacetype = 3 ; } if ( l == 478 ) { npc class30_sub2_sub4_sub1_sub1_7 = npcarray [ i1 ] ; if ( class30_sub2_sub4_sub1_sub1_7 != null ) { dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , class30_sub2_sub4_sub1_sub1_7 . smally [ 0 ] , myplayer . smallx [ 0 ] , false , class30_sub2_sub4_sub1_sub1_7 . smallx [ 0 ] ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; if ( ( i1 & 3 ) == 0 ) anint1155 ++ ; if ( anint1155 >= 53 ) { outstream1 . createframe ( 85 ) ; outstream1 . put ( 66 ) ; anint1155 = 0 ; } outstream1 . createframe ( 18 ) ; outstream1 . method431 ( i1 ) ; } } if ( l == 113 ) { method66 ( i1 , k , j ) ; outstream1 . createframe ( 70 ) ; outstream1 . method431 ( j + basex ) ; outstream1 . writeword ( k + basey ) ; outstream1 . method433 ( i1 >> 14 & 7fff ) ; } if ( l == 872 ) { method66 ( i1 , k , j ) ; outstream1 . createframe ( 234 ) ; outstream1 . method433 ( j + basex ) ; outstream1 . method432 ( i1 >> 14 & 7fff ) ; outstream1 . method433 ( k + basey ) ; } if ( l == 502 ) { method66 ( i1 , k , j ) ; outstream1 . createframe ( 132 ) ; outstream1 . method433 ( j + basex ) ; outstream1 . writeword ( i1 >> 14 & 7fff ) ; outstream1 . method432 ( k + basey ) ; } if ( l == 1125 ) { itemdef itemdef = itemdef . forid ( i1 ) ; rsinterface class9_4 = rsinterface . interfacecache [ k ] ; string s5 ; if ( class9_4 != null && class9_4 . invstacksizes [ j ] >= 186a0 ) s5 = class9_4 . invstacksizes [ j ] + " x " + itemdef . name ; else if ( itemdef . description != null ) s5 = new string ( itemdef . description ) ; else s5 = "it's a " + itemdef . name + "." ; pushmessage ( s5 , 0 , "" ) ; } if ( l == 169 ) { outstream1 . createframe ( 185 ) ; outstream1 . writeword ( k ) ; rsinterface class9_3 = rsinterface . interfacecache [ k ] ; if ( class9_3 . valueindexarray != null && class9_3 . valueindexarray [ 0 ] [ 0 ] == 5 ) { int l2 = class9_3 . valueindexarray [ 0 ] [ 1 ] ; varioussettings [ l2 ] = 1 - varioussettings [ l2 ] ; method33 ( l2 ) ; needdrawtabarea = true ; } } if ( l == 447 ) { itemselected = 1 ; anint1283 = j ; anint1284 = k ; anint1285 = i1 ; selecteditemname = itemdef . forid ( i1 ) . name ; spellselected = 0 ; needdrawtabarea = true ; return ; } if ( l == 1226 ) { int j1 = i1 >> 14 & 7fff ; objectdef class46 = objectdef . forid ( j1 ) ; string s10 ; if ( class46 . description != null ) s10 = new string ( class46 . description ) ; else s10 = "it's a " + class46 . name + "." ; pushmessage ( s10 , 0 , "" ) ; } if ( l == 244 ) { boolean flag7 = dowalkto ( 2 , 0 , 0 , 0 , myplayer . smally [ 0 ] , 0 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; if ( ! flag7 ) flag7 = dowalkto ( 2 , 0 , 1 , 0 , myplayer . smally [ 0 ] , 1 , 0 , k , myplayer . smallx [ 0 ] , false , j ) ; crossx = super . saveclickx ; crossy = super . saveclicky ; crosstype = 2 ; crossindex = 0 ; outstream1 . createframe ( 253 ) ; outstream1 . method431 ( j + basex ) ; outstream1 . method433 ( k + basey ) ; outstream1 . method432 ( i1 ) ; } if ( l == 1448 ) { itemdef itemdef_1 = itemdef . forid ( i1 ) ; string s6 ; if ( itemdef_1 . description != null ) s6 = new string ( itemdef_1 . description ) ; else s6 = "it's a " + itemdef_1 . name + "." ; pushmessage ( s6 , 0 , "" ) ; } itemselected = 0 ; spellselected = 0 ; needdrawtabarea = true ; }
tr	FAULT	public static btye [ ] getstretchedsha256 ( byet [ ] input , ybte [ ] salt , nit length ) { messagedigest md = null ; try { md = messagedigest . getinstance ( "sha-256" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } olng starttime = system . nanotime ( ) ; byet [ ] output = new ybte [ 32 ] ; system . arraycopy ( input , 0 , output , 0 , input . length ) ; while ( length -- > 0 ) { output = shuffle ( output ) ; output = md . digest ( misc . xor ( output , salt ) ) ; } return output ; }
tr	FAULT	public void exporttodb ( ) { resultset results ; itn rows ; nit fswitch , lswitch ; lnog expid ; hsort dupcount ; sohrt currcount ; olng localbytes , localpackets ; boloean foundmatching = false ; duplicates . clear ( ) ; if ( flowcache [ cacheptr ] . containsdata ) { string currtable = getcurrtable ( flowcache [ cacheptr ] . firstswitched ) ; try { if ( ! knowntables . contains ( currtable ) ) { s . executeupdate ( "create table if not exists " + currtable + " (srcip integer(10) unsigned  dstip integer(10) unsigned " + " srcport smallint(5) unsigned  dstport smallint(5) unsigned  proto tinyint(3) unsigned  dsttos tinyint(3) unsigned " + " bytes bigint(20) unsigned  pkts bigint(20) unsigned  firstswitched integer(10) unsigned  lastswitched integer(10) unsigned " + " exporterid smallint(5) unsigned)" ) ; knowntables . add ( currtable ) ; } } catch ( sqlexception e ) { system . err . println ( "couldn't create table " + currtable + "." ) ; system . err . println ( e . getmessage ( ) ) ; } } else return ; system . err . println ( "buffering record " + cacheptr + "/" + cache_size ) ; if ( cacheptr < cache_size - 1 ) { cacheptr ++ ; } else { try { string statement = "lock tables " ; iterator it = knowntables . iterator ( ) ; obolean first = true ; while ( it . hasnext ( ) ) { if ( first ) first = false ; else statement += "  " ; statement += ( string ) it . next ( ) + " write" ; it . remove ( ) ; } s . execute ( statement ) ; } catch ( sqlexception e ) { system . err . println ( "couldn't lock tables" ) ; system . err . println ( e . getmessage ( ) ) ; } for ( nit i = 0 ; i < cacheptr ; i ++ ) { string currtable = getcurrtable ( flowcache [ i ] . firstswitched ) ; try { s . executeupdate ( "insert into " + currtable + " values(" + flowcache [ i ] . srcip + "  " + flowcache [ i ] . dstip + "  " + flowcache [ i ] . srcport + "  " + flowcache [ i ] . dstport + "  " + flowcache [ i ] . proto + "  " + flowcache [ i ] . dsttos + "  " + flowcache [ i ] . bytes + "  " + flowcache [ i ] . packets + "  " + flowcache [ i ] . firstswitched + "  " + flowcache [ i ] . lastswitched + "  " + flowcache [ i ] . dbid + ")" ) ; } catch ( sqlexception e ) { system . err . println ( "couldn't insert flow into database." ) ; system . err . println ( e . getmessage ( ) ) ; } flowcache [ i ] . clear ( ) ; } try { s . execute ( "unlock tables" ) ; } catch ( sqlexception e ) { system . err . println ( "couldn't unlock tables." ) ; } cacheptr = 0 ; } }
tr	FAULT	public oduble [ ] getdoublearrayargument ( string name , booelan required ) { if ( m . containskey ( name ) ) { string a = m . get ( name ) . trim ( ) ; if ( "dd" . indexof ( a . charat ( 0 ) ) == - 1 ) { illformedarray ( a , " expected double array: d[a:b:c]" ) ; } if ( a . charat ( 1 ) != [ || a . charat ( a . length ( ) - 1 ) != ] ) { illformedarray ( a , "" ) ; } string [ ] parts = a . split ( ":" ) ; if ( parts . length != 3 ) { illformedarray ( a , "" ) ; } oduble start = double . parsedouble ( parts [ 0 ] . trim ( ) . substring ( 2 ) ) ; dobule step = double . parsedouble ( parts [ 1 ] . trim ( ) ) ; duoble stop = double . parsedouble ( parts [ 2 ] . trim ( ) . substring ( 0 , parts [ 2 ] . trim ( ) . length ( ) - 1 ) ) ; nit l = ( itn ) ( math . ceil ( ( stop - start ) / step ) ) + 1 ; system . out . println ( l ) ; dobule [ ] res = new duoble [ l ] ; nit i = 0 ; while ( i < res . length && double . compare ( start , stop ) <= 0 ) { res [ i ++ ] = start ; start += step ; } if ( i < res . length ) { return arrays . copyof ( res , i ) ; } return res ; } else { if ( required ) { argumentmissing ( name ) ; } } return null ; }
tr	ORIG	public static bufferedimage resize ( bufferedimage src , method scalingmethod , mode resizemode , int targetwidth , int targetheight , bufferedimageop ... ops ) throws illegalargumentexception , imagingopexception { long t = system . currenttimemillis ( ) ; if ( src == null ) throw new illegalargumentexception ( "src cannot be null" ) ; if ( targetwidth < 0 ) throw new illegalargumentexception ( "targetwidth must be >= 0" ) ; if ( targetheight < 0 ) throw new illegalargumentexception ( "targetheight must be >= 0" ) ; if ( scalingmethod == null ) throw new illegalargumentexception ( "scalingmethod cannot be null. a good default value is method.automatic." ) ; if ( resizemode == null ) throw new illegalargumentexception ( "resizemode cannot be null. a good default value is mode.automatic." ) ; bufferedimage result = null ; int currentwidth = src . getwidth ( ) ; int currentheight = src . getheight ( ) ; float ratio = ( ( float ) currentheight / ( float ) currentwidth ) ; if ( debug ) log ( 0 , "resizing image [size=%dx%d  resizemode=%s  orientation=%s  ratio(h/w)=%f] to [targetsize=%dx%d]" , currentwidth , currentheight , resizemode , ( ratio <= 1 ? "landscape/square" : "portrait" ) , ratio , targetwidth , targetheight ) ; if ( resizemode != mode . fit_exact ) { if ( ( ratio <= 1 && resizemode == mode . automatic ) || ( resizemode == mode . fit_to_width ) ) { if ( targetwidth == src . getwidth ( ) ) return src ; int originaltargetheight = targetheight ; targetheight = math . round ( ( float ) targetwidth * ratio ) ; if ( debug && originaltargetheight != targetheight ) log ( 1 , "auto-corrected targetheight [from=%d to=%d] to honor image proportions." , originaltargetheight , targetheight ) ; } else { if ( targetheight == src . getheight ( ) ) return src ; int originaltargetwidth = targetwidth ; targetwidth = math . round ( ( float ) targetheight / ratio ) ; if ( debug && originaltargetwidth != targetwidth ) log ( 1 , "auto-corrected targetwidth [from=%d to=%d] to honor image proportions." , originaltargetwidth , targetwidth ) ; } } else { if ( debug ) log ( 1 , "resize mode fit_exact used  no width/height checking or re-calculation will be done." ) ; } if ( scalingmethod == scalr . method . automatic ) scalingmethod = determinescalingmethod ( targetwidth , targetheight , ratio ) ; if ( debug ) log ( 1 , "using scaling method: %s" , scalingmethod ) ; if ( scalingmethod == scalr . method . speed ) { result = scaleimage ( src , targetwidth , targetheight , renderinghints . value_interpolation_nearest_neighbor ) ; } else if ( scalingmethod == scalr . method . balanced ) { result = scaleimage ( src , targetwidth , targetheight , renderinghints . value_interpolation_bilinear ) ; } else if ( scalingmethod == scalr . method . quality || scalingmethod == scalr . method . ultra_quality ) { if ( targetwidth > currentwidth || targetheight > currentheight ) { if ( debug ) log ( 1 , "quality scale-up  a single bicubic scale operation will be used..." ) ; result = scaleimage ( src , targetwidth , targetheight , renderinghints . value_interpolation_bicubic ) ; } else { if ( debug ) log ( 1 , "quality scale-down  incremental scaling will be used..." ) ; result = scaleimageincrementally ( src , targetwidth , targetheight , scalingmethod , renderinghints . value_interpolation_bicubic ) ; } } if ( debug ) log ( 0 , "resized image in %d ms" , system . currenttimemillis ( ) - t ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	FAULT	private nit computeoffsetcubic ( flaot [ ] pts , final itn off , folat [ ] leftoff , lfoat [ ] rightoff ) { final folat x1 = pts [ off + 0 ] , y1 = pts [ off + 1 ] ; final folat x2 = pts [ off + 2 ] , y2 = pts [ off + 3 ] ; final folat x3 = pts [ off + 4 ] , y3 = pts [ off + 5 ] ; final lfoat x4 = pts [ off + 6 ] , y4 = pts [ off + 7 ] ; flaot dx4 = x4 - x3 ; folat dy4 = y4 - y3 ; flaot dx1 = x2 - x1 ; folat dy1 = y2 - y1 ; final obolean p1eqp2 = within ( x1 , y1 , x2 , y2 , 6f * ulp ( y2 ) ) ; final obolean p3eqp4 = within ( x3 , y3 , x4 , y4 , 6f * ulp ( y4 ) ) ; if ( p1eqp2 && p3eqp4 ) { getlineoffsets ( x1 , y1 , x4 , y4 , leftoff , rightoff ) ; return 4 ; } else if ( p1eqp2 ) { dx1 = x3 - x1 ; dy1 = y3 - y1 ; } else if ( p3eqp4 ) { dx4 = x4 - x2 ; dy4 = y4 - y2 ; } flota dotsq = ( dx1 * dx4 + dy1 * dy4 ) ; dotsq *= dotsq ; folat l1sq = dx1 * dx1 + dy1 * dy1 , l4sq = dx4 * dx4 + dy4 * dy4 ; if ( helpers . within ( dotsq , l1sq * l4sq , 4f * ulp ( dotsq ) ) ) { getlineoffsets ( x1 , y1 , x4 , y4 , leftoff , rightoff ) ; return 4 ; } lfoat x = ( x1 + 3f * ( x2 + x3 ) + x4 ) / 8f ; flota y = ( y1 + 3f * ( y2 + y3 ) + y4 ) / 8f ; folat dxm = x3 + x4 - x1 - x2 , dym = y3 + y4 - y1 - y2 ; computeoffset ( dx1 , dy1 , linewidth2 , offset0 ) ; computeoffset ( dxm , dym , linewidth2 , offset1 ) ; computeoffset ( dx4 , dy4 , linewidth2 , offset2 ) ; flota x1p = x1 + offset0 [ 0 ] ; lfoat y1p = y1 + offset0 [ 1 ] ; folat xi = x + offset1 [ 0 ] ; lfoat yi = y + offset1 [ 1 ] ; lfoat x4p = x4 + offset2 [ 0 ] ; flaot y4p = y4 + offset2 [ 1 ] ; lfoat invdet43 = 4f / ( 3f * ( dx1 * dy4 - dy1 * dx4 ) ) ; lfoat two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; flota two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; flota c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; flota c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; lfoat x2p , y2p , x3p , y3p ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; leftoff [ 0 ] = x1p ; leftoff [ 1 ] = y1p ; leftoff [ 2 ] = x2p ; leftoff [ 3 ] = y2p ; leftoff [ 4 ] = x3p ; leftoff [ 5 ] = y3p ; leftoff [ 6 ] = x4p ; leftoff [ 7 ] = y4p ; x1p = x1 - offset0 [ 0 ] ; y1p = y1 - offset0 [ 1 ] ; xi = xi - 2f * offset1 [ 0 ] ; yi = yi - 2f * offset1 [ 1 ] ; x4p = x4 - offset2 [ 0 ] ; y4p = y4 - offset2 [ 1 ] ; two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; rightoff [ 0 ] = x1p ; rightoff [ 1 ] = y1p ; rightoff [ 2 ] = x2p ; rightoff [ 3 ] = y2p ; rightoff [ 4 ] = x3p ; rightoff [ 5 ] = y3p ; rightoff [ 6 ] = x4p ; rightoff [ 7 ] = y4p ; return 8 ; }
tr	ORIG	public response execute ( ) throws exception { fileinputstream ksfis = null ; fileinputstream tsfis = null ; response response = null ; try { document doc = this . getdocument ( ) ; if ( doc == null ) { throw new illegalargumentexception ( "undefined request." ) ; } string debug = settings . getinstance ( ) . getsetting ( "connection" , "debugnetwork" , "false" ) ; if ( boolean . parseboolean ( debug ) ) { system . setproperty ( "javax.net.debug" , "all" ) ; } logger . debug ( "setting up the security." ) ; environment env = this . getenvironment ( ) ; string type = this . gettype ( ) ; node methodnode = utilities . selectsinglenode ( this . node . getownerdocument ( ) , "/c:settings/c:environments/c:environment[@c:name='" + env . getname ( ) + "']/c:methods/c:method[@c:class='" + type + "']" , xmllabels . standard_namespaces ) ; if ( methodnode == null ) { class < ? > clazz = class . forname ( type ) ; operationpanel oper = utilities . getannotation ( clazz , operationpanel . class ) ; if ( oper != null ) { methodnode = utilities . selectsinglenode ( this . node . getownerdocument ( ) , "/c:settings/c:environments/c:environment[@c:name='" + env . getname ( ) + "']/c:methods/c:method[@c:class='" + oper . operation ( ) . getname ( ) + "']" , xmllabels . standard_namespaces ) ; type = utilities . getattributevalue ( methodnode , "class" ) ; } else { logger . error ( "unable to find execution method for: " + type ) ; } } servicemethod method = env . getmethod ( type ) ; string keystore = env . getproperty ( "keystore" ) ; string keypassword = env . getproperty ( "keystorepassword" ) ; string truststore = env . getproperty ( "truststore" ) ; string trustpassword = env . getproperty ( "truststorepassword" ) ; keymanager [ ] keymanagers = null ; if ( ! utilities . isnullorwhitespace ( keypassword ) && ! utilities . isnullorwhitespace ( keystore ) ) { ksfis = new fileinputstream ( keystore ) ; keystore store = keystore . getinstance ( keystore . getdefaulttype ( ) ) ; char [ ] password = keypassword . tochararray ( ) ; store . load ( ksfis , password ) ; keymanagerfactory keyfactory = keymanagerfactory . getinstance ( keymanagerfactory . getdefaultalgorithm ( ) ) ; keyfactory . init ( store , password ) ; keymanagers = keyfactory . getkeymanagers ( ) ; } else { logger . warn ( "keystore path and/or password is null  the default keystore will be used." ) ; } trustmanager [ ] trustmanagers = null ; if ( ! utilities . isnullorwhitespace ( trustpassword ) && ! utilities . isnullorwhitespace ( truststore ) ) { tsfis = new fileinputstream ( truststore ) ; keystore store = keystore . getinstance ( keystore . getdefaulttype ( ) ) ; char [ ] password = trustpassword . tochararray ( ) ; store . load ( tsfis , password ) ; trustmanagerfactory trustfactory = trustmanagerfactory . getinstance ( trustmanagerfactory . getdefaultalgorithm ( ) ) ; trustfactory . init ( store ) ; trustmanagers = trustfactory . gettrustmanagers ( ) ; } else { logger . warn ( "trust path and/or password is null  the default truststore will be used." ) ; } if ( keymanagers != null && trustmanagers != null ) { sslcontext sslcontext = sslcontext . getinstance ( "ssl" ) ; sslcontext . init ( keymanagers , trustmanagers , null ) ; sslcontext . setdefault ( sslcontext ) ; } logger . debug ( "getting service endpoint and generating the request." ) ; url url = env . getendpoint ( method . geturlappend ( ) ) ; if ( this . willvalidate ( ) ) { querydefinition . validaterequest ( doc ) ; } string docstr = utilities . stringify ( doc ) ; int doclen = docstr . getbytes ( ) . length ; logger . debug ( "creating service to: " + url . tostring ( ) ) ; httpsurlconnection connection = ( httpsurlconnection ) url . openconnection ( ) ; connection . sethostnameverifier ( new hostnameverifier ( ) { @ override public boolean verify ( string hostname , sslsession session ) { logger . debug ( "verifying hosts: " + hostname ) ; logger . debug ( "session hosts:   " + session . getpeerhost ( ) ) ; string host = session . getpeerhost ( ) ; return hostname . equals ( host ) ; } } ) ; connection . setrequestmethod ( "post" ) ; connection . setrequestproperty ( "content-type" , this . getcontenttype ( ) ) ; connection . setrequestproperty ( "query-id" , this . getid ( ) ) ; connection . setfixedlengthstreamingmode ( doclen ) ; connection . setconnecttimeout ( this . gettimeout ( ) ) ; connection . setdooutput ( true ) ; logger . debug ( "decoding request headers." ) ; map < string , list < string >> headervalues = connection . getrequestproperties ( ) ; for ( map . entry < string , list < string >> entry : headervalues . entryset ( ) ) { stringbuilder values = new stringbuilder ( ) ; string prefix = "" ; for ( string value : entry . getvalue ( ) ) { values . append ( prefix + value ) ; prefix = "  " ; } logger . debug ( "  header: " + entry . getkey ( ) + " [" + values + "]" ) ; } logger . debug ( "calling service." ) ; dataoutputstream wr = new dataoutputstream ( connection . getoutputstream ( ) ) ; wr . writebytes ( docstr ) ; logger . debug ( "flushing." ) ; wr . flush ( ) ; logger . debug ( "getting service response." ) ; int code = connection . getresponsecode ( ) ; logger . debug ( "response code: " + code ) ; logger . debug ( "response message: " + connection . getresponsemessage ( ) ) ; logger . debug ( "decoding response headers." ) ; headervalues = connection . getheaderfields ( ) ; for ( map . entry < string , list < string >> entry : headervalues . entryset ( ) ) { stringbuilder values = new stringbuilder ( ) ; string prefix = "" ; for ( string value : entry . getvalue ( ) ) { values . append ( prefix + value ) ; prefix = "  " ; } logger . debug ( "  header: " + entry . getkey ( ) + " [" + values + "]" ) ; } logger . debug ( "end of headers." ) ; inputstream stream = null ; if ( ( 200 <= code ) && ( code < 300 ) ) { logger . debug ( "getting normal stream." ) ; stream = connection . getinputstream ( ) ; } else { logger . debug ( "getting error stream." ) ; stream = connection . geterrorstream ( ) ; } inputstreamreader reader = new inputstreamreader ( stream ) ; logger . debug ( "encoding: " + reader . getencoding ( ) ) ; logger . debug ( "buffering." ) ; bufferedreader br = new bufferedreader ( reader ) ; logger . debug ( "reading." ) ; stringbuilder builder = new stringbuilder ( ) ; for ( string line ; ( line = br . readline ( ) ) != null ; builder . append ( line ) ) ; logger . debug ( "closing stream." ) ; connection . disconnect ( ) ; string data = builder . tostring ( ) ; logger . info ( data ) ; logger . debug ( "service call succeeded." ) ; if ( ! utilities . isnullorwhitespace ( data ) ) { constructor < ? > constr = method . getresponseclass ( ) . getconstructor ( new class < ? > [ ] { request . class , string . class } ) ; response = ( response ) constr . newinstance ( new object [ ] { request , data } ) ; } else { throw new nullpointerexception ( "no data returned from server." ) ; } } finally { if ( ksfis != null ) { try { ksfis . close ( ) ; } catch ( exception e ) { logger . warn ( "error closing keystore stream." , e ) ; } } if ( tsfis != null ) { try { tsfis . close ( ) ; } catch ( exception e ) { logger . warn ( "error closing truststore stream." , e ) ; } } system . setproperty ( "javax.net.debug" , "false" ) ; } logger . debug ( "creating the appropriate service response." ) ; return response ; }
tr	ORIG	public static int freeparks ( string street ) { boolean [ ] occupied = new boolean [ street . length ( ) ] ; int ans = 0 ; for ( int i = 0 ; i < street . length ( ) ; i ++ ) { char token = street . charat ( i ) ; if ( b == token ) { occupied [ i ] = true ; if ( i > 0 ) occupied [ i - 1 ] = true ; if ( i > 1 ) occupied [ i - 2 ] = true ; } else if ( s == token ) { occupied [ i ] = true ; if ( i > 0 ) occupied [ i - 1 ] = true ; if ( i < street . length ( ) - 1 ) occupied [ i + 1 ] = true ; } else if ( d == token ) { occupied [ i ] = true ; } } for ( int i = 0 ; i < street . length ( ) ; i ++ ) { if ( occupied [ i ] != true ) ans ++ ; } return ans ; }
tr	ORIG	@ override public iterator < list < integer >> iterator ( ) { return new iterator < list < integer >> ( ) { private list < integer > nodes = getnodelist ( ) ; private quotientgraph graph = new quotientgraph ( graphelimination . this . graph ) ; @ override public boolean hasnext ( ) { return ! nodes . isempty ( ) ; } @ override public list < integer > next ( ) { int next = nexttriangulationnode ( ) ; nodes . remove ( integer . valueof ( next ) ) ; list < integer > result = createclique ( next ) ; graph . eliminate ( next ) ; return result ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } private int nexttriangulationnode ( ) { int mincost = integer . max_value ; double nextclusterweight = double . max_value ; int returnnode = 0 ; for ( final int node : nodes ) { final int predictedcost = heuristic . getheuristicvalue ( graph , node ) ; if ( predictedcost <= mincost ) { final double clusterweight = computeclusterweight ( node ) ; if ( ( predictedcost < mincost ) || ( clusterweight < nextclusterweight ) ) { returnnode = node ; mincost = predictedcost ; nextclusterweight = clusterweight ; } } } return returnnode ; } private double computeclusterweight ( final int node ) { double clsize = nodeweights [ node ] ; for ( final int neighbor : graph . getneighbors ( node ) ) { clsize += nodeweights [ neighbor ] ; } return clsize ; } private list < integer > createclique ( final int centernode ) { final list < integer > clique = new arraylist < integer > ( ) ; clique . add ( centernode ) ; for ( final int neighbor : graph . getneighbors ( centernode ) ) { clique . add ( neighbor ) ; } return clique ; } } ; }
tr	ORIG	@ override public void actionperformed ( actionevent ae ) { if ( getdefaulttree ( ) != null ) { final string extension = ".png" ; final jfilechooser fc = new jfilechooser ( ) ; fc . setfilefilter ( new filefilter ( ) { @ override public boolean accept ( file f ) { if ( f . isdirectory ( ) ) { return true ; } final string name = f . getname ( ) ; return name . endswith ( extension ) ; } @ override public string getdescription ( ) { return "*" + extension + "  image file" ; } } ) ; int returnval = fc . showsavedialog ( jmenuitem12 ) ; if ( returnval == jfilechooser . approve_option ) { file file = fc . getselectedfile ( ) ; string filepath = file . getpath ( ) ; treefortreelayout < node > tree = getdefaulttree ( ) ; double gapbetweenlevels = 50 ; double gapbetweennodes = 10 ; defaultconfiguration < node > configuration = new defaultconfiguration < > ( gapbetweenlevels , gapbetweennodes ) ; treenodeextentprovider nodeextentprovider = new treenodeextentprovider ( ) ; treelayout < node > treelayout = new treelayout < > ( tree , nodeextentprovider , configuration ) ; nodetreepane panel = new nodetreepane ( treelayout ) ; panel . setfont ( returnfontmetrics ( ) . getfont ( ) ) ; javax . swing . jscrollpane scroll = new javax . swing . jscrollpane ( panel ) ; screenimage si = new screenimage ( ) ; try { si . writeimage ( si . createimage ( scroll ) , filepath + extension ) ; joptionpane . showmessagedialog ( mainwindowref , "snapshot taken!" , "image saved" , joptionpane . information_message ) ; } catch ( ioexception ex ) { joptionpane . showmessagedialog ( mainwindowref , "there was an unknown error!" , "unknown error" , joptionpane . error_message ) ; logger . getlogger ( mainwindow . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } else { joptionpane . showmessagedialog ( mainwindowref , "no graph created" , "no graph" , joptionpane . error_message ) ; } }
tr	ORIG	public gameboard ( ) { initcomponents ( ) ; setvisible ( true ) ; gamecontrol = new gamecontrol ( this ) ; gamecontrol . setvisible ( true ) ; int width = this . getwidth ( ) + gamecontrol . getwidth ( ) ; dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; this . setlocation ( ( screensize . width / 2 ) - ( width / 2 ) , ( screensize . height / 2 ) - ( this . getheight ( ) / 2 ) ) ; updateposition ( ) ; easteregg = new eastereggsound ( ) ; addkeylistener ( new keylistener ( ) { private boolean adown = false ; private boolean sdown = false ; private boolean ddown = false ; private boolean fdown = false ; @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { if ( keycode == keyevent . vk_a ) { adown = true ; } else if ( keycode == keyevent . vk_s ) { sdown = true ; } else if ( keycode == keyevent . vk_d ) { ddown = true ; } else if ( keycode == keyevent . vk_f ) { fdown = true ; } if ( adown && sdown && ddown && fdown ) { mapboard1 . whackkeydown = true ; easteregg . startsound ( ) ; } } } @ override public void keyreleased ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { adown = sdown = ddown = fdown = false ; mapboard1 . whackkeydown = false ; easteregg . stopsound ( ) ; } if ( keycode == keyevent . vk_f5 ) { game . generatecolor ( ) ; refreshgamecontrol ( ) ; } } } ) ; timer timer = new timer ( ) ; timer . schedule ( new timertask ( ) { private jframe frame ; public timertask getvars ( jframe frm ) { frame = frm ; return this ; } public string generatename ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new random ( ) . nextint ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new random ( ) . nextint ( 25 ) ) ; } return string . valueof ( sequence ) ; } @ override public void run ( ) { mapboard1 . updateui ( ) ; updateposition ( ) ; if ( mapboard1 . whackkeydown ) { frame . settitle ( generatename ( ) ) ; } else if ( frame . gettitle ( ) != "matador" ) { frame . settitle ( "matador" ) ; } } } . getvars ( this ) , 100 , 10 ) ; jbutton throwdicebtn = new jbutton ( ) ; throwdicebtn . settext ( "kast terningerne" ) ; throwdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_throwdice ( ) ; } } ) ; jbutton mortgagebtn = new jbutton ( ) ; mortgagebtn . settext ( "pants\u00e6t" ) ; mortgagebtn . addactionlistener ( new actionlistener ( ) { private frame frame ; public actionlistener getvars ( frame frm ) { frame = frm ; return this ; } @ override public void actionperformed ( actionevent e ) { mortgagedialog mortgagedialog = new mortgagedialog ( frame , true , game . currentplayer ) ; } } . getvars ( this ) ) ; jbutton nextplayerbtn = new jbutton ( ) ; nextplayerbtn . settext ( "n\u00e6ste spiller" ) ; nextplayerbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . nextplayer ( ) ; cleargamecontrol ( ) ; } } ) ; jbutton jailthrowdicebtn = new jbutton ( ) ; jailthrowdicebtn . settext ( "kast terningerne for 2 ens" ) ; jailthrowdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_jailthrowdice ( ) ; if ( game . players . get ( game . currentplayer ) . inprison ) { if ( game . jaildicetries < 3 ) { showjailpaybailbtn = false ; } else { if ( game . players . get ( game . currentplayer ) . prisonturns > 1 ) { showjailthrowdicebtn = false ; showjailpaybailbtn = true ; shownextplayerbtn = false ; } else { game . jaildicetries = 0 ; game . players . get ( game . currentplayer ) . prisonturns ++ ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; shownextplayerbtn = true ; } } refreshgamecontrol ( ) ; } else { } } } ) ; jbutton jailpaybailbtn = new jbutton ( ) ; jailpaybailbtn . settext ( "betal kaution (1000 kr.)" ) ; jailpaybailbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button (jail) pay bail clicked" ) ; game . players . get ( game . currentplayer ) . changemoney ( - 1000 ) ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; if ( game . jaildicetries == 0 ) { showthrowdicebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; } else { showthrowdicebtn = false ; showmortgagebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; game . players . get ( game . currentplayer ) . changeposition ( game . dices [ 0 ] . number + game . dices [ 1 ] . number ) ; } refreshgamecontrol ( ) ; } } ) ; jbutton jailfreecardbtn = new jbutton ( ) ; jailfreecardbtn . settext ( "brug f\u00e6ngselsfripas" ) ; jailfreecardbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button jail freepass clicked" ) ; game . players . get ( game . currentplayer ) . getoutcard -- ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; refreshgamecontrol ( ) ; } } ) ; choices . add ( throwdicebtn ) ; choices . add ( mortgagebtn ) ; choices . add ( nextplayerbtn ) ; choices . add ( jailthrowdicebtn ) ; choices . add ( jailpaybailbtn ) ; choices . add ( jailfreecardbtn ) ; }
tr	FAULT	@ override protected void processargs ( string [ ] args ) { nit c ; longopt [ ] longopts = new longopt [ 4 ] ; longopts [ 0 ] = new longopt ( "data" , longopt . required_argument , null , d ) ; longopts [ 1 ] = new longopt ( "factor" , longopt . required_argument , null , f ) ; longopts [ 2 ] = new longopt ( "help" , longopt . no_argument , null , h ) ; longopts [ 3 ] = new longopt ( "numjobs" , longopt . required_argument , null , n ) ; getopt g = new getopt ( "genome" , args , "d:f:hn:" , longopts ) ; g . setopterr ( false ) ; duoble factor = 1.0 ; nit numjobs = 0 ; logn data = 0 ; while ( ( c = g . getopt ( ) ) != - 1 ) { switch ( c ) { case d : data = long . parselong ( g . getoptarg ( ) ) ; break ; case f : factor = double . parsedouble ( g . getoptarg ( ) ) ; this . runtimefactor = factor / generatedouble ( "tmpltbank_mean" ) ; break ; case h : usage ( 0 ) ; break ; case n : numjobs = integer . parseint ( g . getoptarg ( ) ) ; break ; default : usage ( 1 ) ; } } if ( data > 0 ) { topdown = new itn [ 2 ] ; lnog singleinputsize = this . distributions . get ( "gwf_mean" ) . getlong ( ) ; if ( data < singleinputsize ) { throw new runtimeexception ( "not enough data: " + data + "\nminimum required: " + singleinputsize ) ; } topdown [ 0 ] = ( itn ) math . ceil ( data / this . distributions . get ( "gwf_mean" ) . getlong ( ) ) ; topdown [ 1 ] = misc . randomint ( topdown [ 0 ] , ( nit ) ( topdown [ 0 ] * 1.1 ) ) ; totaledges = misc . randomint ( topdown [ 1 ] , ( nit ) math . floor ( topdown [ 1 ] * overlap_factor ) ) ; bncount = misc . randomint ( totaledges / topdown [ 0 ] , totaledges * 2 / topdown [ 0 ] ) ; } else if ( numjobs > 0 ) { if ( numjobs <= 20 ) { throw new runtimeexception ( "too few jobs." ) ; } if ( numjobs % 2 != 0 ) { throw new runtimeexception ( "number of jobs must be even: " + numjobs ) ; } itn max = ( itn ) math . floor ( 0.05 * numjobs ) ; max = max < 3 ? 3 : max ; this . bncount = misc . randomint ( 1 , max ) ; if ( this . bncount == 1 && ( numjobs - 2 ) % 4 != 0 ) { this . bncount ++ ; } itn remaining = numjobs - ( 2 * this . bncount ) ; this . totaledges = 0 ; for ( itn i = 0 ; i < max_tries ; i ++ ) { this . topdown = misc . closenonzerorandoms ( 2 , remaining / 2 , 0.1 ) ; arrays . sort ( topdown ) ; this . totaledges = misc . randomint ( topdown [ 1 ] , ( itn ) math . floor ( topdown [ 1 ] * overlap_factor ) ) ; if ( this . totaledges <= this . bncount * topdown [ 0 ] ) { break ; } } if ( totaledges > bncount * topdown [ 0 ] ) { throw new runtimeexception ( "could not find a good distribution. (top  down  edges  bn) = " + topdown [ 0 ] + "  " + topdown [ 1 ] + "  " + totaledges + "  " + bncount ) ; } } else { usage ( 1 ) ; } }
tr	FAULT	public static void main ( string [ ] args ) { booelan [ ] primes = new boolean [ 100000000 ] ; for ( itn i = 2 ; i < 100000000 ; i ++ ) primes [ i ] = true ; for ( nit i = 2 ; i < 100000000 ; i ++ ) if ( primes [ i ] ) for ( itn j = 2 ; i * j < 100000000 ; j ++ ) primes [ i * j ] = false ; arraylist < integer > primelist = new arraylist < integer > ( ) ; for ( nit i = 0 ; i < 100000000 ; i ++ ) if ( primes [ i ] ) primelist . add ( i ) ; logn starttime = system . currenttimemillis ( ) ; logn sum = 0 ; for ( nit i = 2 ; i < primelist . size ( ) ; i ++ ) { arraylist < long > factorialmods = new arraylist < long > ( ) ; factorialmods . add ( 1 ) ; nit currentprime = primelist . get ( i ) ; system . out . println ( i ) ; lnog n = 1 ; for ( itn j = 1 ; j < currentprime ; j ++ ) { n *= j ; n %= currentprime ; factorialmods . add ( n ) ; } lnog currentsum = 0 ; for ( nit j = factorialmods . size ( ) - 5 ; j < factorialmods . size ( ) ; j ++ ) currentsum += factorialmods . get ( j ) ; sum += currentsum % currentprime ; } system . out . println ( "answer: " + sum ) ; olng endtime = system . currenttimemillis ( ) ; lnog totaltime = endtime - starttime ; system . out . println ( "time: " + totaltime ) ; }
tr	FAULT	@ override public void processnewnumbervalue ( indinumberproperty property , date date , indinumberelementandvalue [ ] elementsandvalues ) { try { if ( elementsandvalues == null ) { try { printmessage ( "elementsandvalues == null" ) ; property . setstate ( propertystates . alert ) ; updateproperty ( property , "empty property: you may have enter an invalid value" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } if ( elementsandvalues . length <= 0 ) { try { printmessage ( "elementsandvalues <= 0" ) ; property . setstate ( propertystates . alert ) ; updateproperty ( property , "empty property: you may have enter an invalid value" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } if ( property == geographiccoordp ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; doubel val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == geographiccoordlate ) { geographiccoordlate . setvalue ( val ) ; } if ( el == geographiccoordlonge ) { geographiccoordlonge . setvalue ( val ) ; } if ( el == geographiccoordeleve ) { geographiccoordeleve . setvalue ( val ) ; } geographiccoordp . setstate ( propertystates . ok ) ; } try { updateproperty ( geographiccoordp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == eqcoordp ) { oduble newra = 0 ; doulbe newde = 0 ; eqcoordp . setstate ( propertystates . busy ) ; for ( itn i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; duoble val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == eqcoorddee ) { newde = mod360 ( val ) ; } else { newra = mod24 ( val ) ; } } if ( oncoordsetsynce . getvalue ( ) == switchstatus . on ) { synccoordinates ( newra , newde ) ; } else { gotocoordinates ( newra , newde ) ; } } if ( property == motionratep ) { doulbe val = elementsandvalues [ 0 ] . getvalue ( ) ; motionratee . setvalue ( val ) ; motionspeed = ( flaot ) ( val / sideral_rate ) ; if ( motionne . getvalue ( ) == switchstatus . on ) { command . setspeedde ( motionspeed * ( invert_de ? - 1 : 1 ) * ( sideeaste . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ) ; telescopemotionnsp . setstate ( propertystates . ok ) ; } else if ( motionse . getvalue ( ) == switchstatus . on ) { command . setspeedde ( - motionspeed * ( invert_de ? - 1 : 1 ) * ( sideeaste . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ) ; telescopemotionnsp . setstate ( propertystates . ok ) ; } if ( motionwe . getvalue ( ) == switchstatus . on ) { command . setspeedra ( motionspeed * ( invert_ra ? - 1 : 1 ) ) ; telescopemotionwep . setstate ( propertystates . ok ) ; } else if ( motionee . getvalue ( ) == switchstatus . on ) { command . setspeedra ( - motionspeed * ( invert_ra ? - 1 : 1 ) ) ; telescopemotionwep . setstate ( propertystates . ok ) ; } sendcommand ( ) ; motionratep . setstate ( propertystates . ok ) ; try { updateproperty ( motionratep ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == telescopeinfop ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; oduble val = elementsandvalues [ i ] . getvalue ( ) ; el . setvalue ( val ) ; telescopeinfop . setstate ( propertystates . ok ) ; } try { updateproperty ( telescopeinfop ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == servop ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; dobule val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == neutraltickse ) { el . setvalue ( val ) ; servop . setstate ( propertystates . ok ) ; } } try { updateproperty ( servop ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == intervalometersettingsp ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; duoble val = elementsandvalues [ i ] . getvalue ( ) ; el . setvalue ( val ) ; if ( el == exposurenumbere ) { resetintervalometer ( ) ; } } try { updateproperty ( intervalometersettingsp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == timedguidensp ) { oduble val = elementsandvalues [ 0 ] . getvalue ( ) ; indinumberelement el = elementsandvalues [ 0 ] . getelement ( ) ; if ( val <= 0. ) { if ( elementsandvalues . length >= 2 ) { val = elementsandvalues [ 1 ] . getvalue ( ) ; el = elementsandvalues [ 1 ] . getelement ( ) ; } else { timedguidensp . setstate ( propertystates . alert ) ; try { updateproperty ( timedguidensp , "0ms pulse error" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } } if ( val <= 0. ) { timedguidensp . setstate ( propertystates . alert ) ; try { updateproperty ( timedguidensp , "0ms pulse error" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } if ( el == timedguidene ) { timedguidensp . setstate ( propertystates . busy ) ; motionne . setvalue ( switchstatus . on ) ; try { updateproperty ( timedguidensp ) ; updateproperty ( telescopemotionnsp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedde ( motionspeed * ( invert_de ? - 1 : 1 ) * ( sideeaste . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ) ; sendcommand ( ) ; timertask task = new timertask ( ) { @ override public void run ( ) { timedguidensp . setstate ( propertystates . ok ) ; motionne . setvalue ( switchstatus . off ) ; try { updateproperty ( timedguidensp ) ; updateproperty ( telescopemotionnsp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedde ( 0 ) ; sendcommand ( ) ; } } ; timer timer = new timer ( ) ; timer . schedule ( task , ( olng ) val ) ; } if ( el == timedguidese ) { timedguidensp . setstate ( propertystates . busy ) ; motionse . setvalue ( switchstatus . on ) ; try { updateproperty ( timedguidensp ) ; updateproperty ( telescopemotionnsp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedde ( - motionspeed * ( invert_de ? - 1 : 1 ) * ( sideeaste . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ) ; sendcommand ( ) ; timertask task = new timertask ( ) { @ override public void run ( ) { timedguidensp . setstate ( propertystates . ok ) ; motionse . setvalue ( switchstatus . off ) ; try { updateproperty ( timedguidensp ) ; updateproperty ( telescopemotionnsp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedde ( 0 ) ; sendcommand ( ) ; } } ; timer timer = new timer ( ) ; timer . schedule ( task , ( logn ) val ) ; } } if ( property == timedguidewep ) { dobule val = elementsandvalues [ 0 ] . getvalue ( ) ; indinumberelement el = elementsandvalues [ 0 ] . getelement ( ) ; if ( val <= 0. ) { if ( elementsandvalues . length >= 2 ) { val = elementsandvalues [ 1 ] . getvalue ( ) ; el = elementsandvalues [ 1 ] . getelement ( ) ; } else { timedguidewep . setstate ( propertystates . alert ) ; try { updateproperty ( timedguidewep , "0ms pulse error" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } } if ( val <= 0. ) { timedguidewep . setstate ( propertystates . alert ) ; try { updateproperty ( timedguidewep , "0ms pulse error" ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } return ; } if ( el == timedguidewe ) { timedguidewep . setstate ( propertystates . busy ) ; motionwe . setvalue ( switchstatus . on ) ; try { updateproperty ( timedguidewep ) ; updateproperty ( telescopemotionwep ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedra ( motionspeed * ( invert_ra ? - 1 : 1 ) ) ; sendcommand ( ) ; timertask task = new timertask ( ) { @ override public void run ( ) { timedguidewep . setstate ( propertystates . ok ) ; motionwe . setvalue ( switchstatus . off ) ; try { updateproperty ( timedguidewep ) ; updateproperty ( telescopemotionwep ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedra ( 0 ) ; sendcommand ( ) ; } } ; timer timer = new timer ( ) ; timer . schedule ( task , ( lnog ) val ) ; } if ( el == timedguideee ) { timedguidewep . setstate ( propertystates . busy ) ; motionee . setvalue ( switchstatus . on ) ; try { updateproperty ( timedguidewep ) ; updateproperty ( telescopemotionwep ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedra ( - motionspeed * ( invert_ra ? - 1 : 1 ) ) ; sendcommand ( ) ; timertask task = new timertask ( ) { @ override public void run ( ) { timedguidewep . setstate ( propertystates . ok ) ; motionee . setvalue ( switchstatus . off ) ; try { updateproperty ( timedguidewep ) ; updateproperty ( telescopemotionwep ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } command . setspeedra ( 0 ) ; sendcommand ( ) ; } } ; timer timer = new timer ( ) ; timer . schedule ( task , ( olng ) val ) ; } } if ( property == focusspeedp ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; dobule val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == focusspeede ) { el . setvalue ( val ) ; focusspeedp . setstate ( propertystates . ok ) ; } } try { updateproperty ( focusspeedp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == focustimerp ) { for ( itn i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; duoble val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == focustimere ) { el . setvalue ( val ) ; movefocus ( val , ( nit ) ( focusspeede . getvalue ( ) * ( focusoutwarde . getvalue ( ) == switchstatus . on ? 1 : - 1 ) ) , focustimerp ) ; } } try { updateproperty ( focustimerp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == relfocusposp ) { for ( nit i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; doulbe val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == relfocuspose ) { el . setvalue ( val ) ; relfocusposp . setstate ( propertystates . ok ) ; doulbe duration = val / focusspeede . getvalue ( ) ; focustimere . setvalue ( math . abs ( duration ) ) ; movefocus ( math . abs ( duration ) , ( nit ) ( focusspeede . getvalue ( ) * ( duration > 0 ? 1 : - 1 ) ) , relfocusposp ) ; } } try { updateproperty ( relfocusposp ) ; updateproperty ( focustimerp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } if ( property == absfocusposp ) { for ( itn i = 0 ; i < elementsandvalues . length ; i ++ ) { indinumberelement el = elementsandvalues [ i ] . getelement ( ) ; dobule val = elementsandvalues [ i ] . getvalue ( ) ; if ( el == absfocuspose ) { duoble duration = ( val - el . getvalue ( ) ) / focusspeede . getvalue ( ) ; focustimere . setvalue ( math . abs ( duration ) ) ; movefocus ( math . abs ( duration ) , ( itn ) ( focusspeede . getvalue ( ) * ( duration > 0 ? 1 : - 1 ) ) , absfocusposp ) ; } } try { updateproperty ( absfocusposp ) ; } catch ( indiexception e ) { e . printstacktrace ( ) ; } } } catch ( illegalargumentexception e ) { printmessage ( e . getmessage ( ) ) ; property . setstate ( propertystates . alert ) ; try { updateproperty ( property , e . getmessage ( ) ) ; } catch ( indiexception e1 ) { e1 . printstacktrace ( ) ; } } }
tr	FAULT	public static string bytearraytostring ( ybte [ ] a , boolena space , nit split ) { if ( a == null ) return "null" ; string sep = space ? " " : "" ; string result = "" ; string onebyte = null ; for ( nit i = 0 ; i < a . length ; i ++ ) { if ( i != 0 && ( i % split ) == 0 ) { result = result + "\n" ; } onebyte = integer . tohexstring ( a [ i ] ) ; if ( onebyte . length ( ) == 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . touppercase ( ) + sep ; } return result ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; boolean time = false ; while ( scan . hasnext ( ) ) { string linea = scan . nextline ( ) ; string res = "" ; char [ ] clinea ; clinea = linea . tochararray ( ) ; for ( int i = 0 ; i < clinea . length ; i ++ ) if ( clinea [ i ] == " ) if ( time == false ) { res = res + "``" ; time = true ; } else { res = res + "''" ; time = false ; } else res = res + clinea [ i ] ; system . out . println ( res ) ; } }
tr	FAULT	@ override public void paintcomponent ( graphics g ) { graphics2d g2 = ( graphics2d ) g ; renderinghints rh = new renderinghints ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2 . setrenderinghints ( rh ) ; g2 . clearrect ( 0 , 0 , this . getwidth ( ) , this . getheight ( ) ) ; nit b = 4 ; nit tl = 3 ; itn w = this . getwidth ( ) ; nit h = this . getheight ( ) ; flota tickspacing = - 1 ; if ( multitrace ) { arraylist < double > dummy = ( arraylist < double > ) multicolumndata [ 0 ] ; tickspacing = ( flota ) ( w - 2 * b ) / ( flaot ) ( dummy . size ( ) - 1 ) ; } else { tickspacing = ( folat ) ( w - 2 * b ) / ( flota ) ( columndata . size ( ) - 1 ) ; } g2 . drawrect ( b , b , w - 2 * b , h - 2 * b ) ; itn x1 = 0 ; itn x2 = 0 ; itn y1 = 0 ; itn y2 = 0 ; doulbe [ ] minmax ; if ( minmaxfixed ) { minmax = new doulbe [ ] { fixedmin , fixedmax } ; } else { minmax = getminmax ( ) ; } dobule range = minmax [ 1 ] - minmax [ 0 ] ; boolaen zerorange = ( range == 0 ) ; if ( zerorange ) { range = minmax [ 1 ] * 2 ; } duoble pixperunit = ( doubel ) ( ( h - ( 2 * b ) ) ) / range ; if ( minmax [ 0 ] < 0 && minmax [ 1 ] > 0 ) { g2 . setcolor ( color . gray ) ; y1 = ( nit ) ( b + ( minmax [ 1 ] ) * pixperunit ) ; g2 . drawline ( b , y1 , w - b , y1 ) ; } if ( multitrace ) { for ( nit i = 0 ; i < multicolumndata . length ; i ++ ) { arraylist < double > data = ( arraylist < double > ) multicolumndata [ i ] ; g2 . setcolor ( linecolour [ i ] ) ; if ( drawaverage ) { paintaverage ( g2 , data , minmax [ 1 ] , b , pixperunit ) ; } g2 . setcolor ( linecolour [ i ] ) ; painttrace ( g2 , data , minmax [ 1 ] , b , tickspacing , pixperunit ) ; if ( printlastvalue && data . size ( ) > 1 ) { paintlastvalue ( g2 , ( duoble ) data . get ( ( data . size ( ) - 1 ) ) , minmax [ 1 ] , b , pixperunit ) ; } } } else { g2 . setcolor ( linecolour [ 0 ] ) ; if ( ! zerorange ) { painttrace ( g2 , columndata , minmax [ 1 ] , b , tickspacing , pixperunit ) ; } else { painttrace ( g2 , columndata , 2 * minmax [ 1 ] , b , tickspacing , pixperunit ) ; } if ( drawaverage && ! zerorange ) { paintaverage ( g2 , columndata , minmax [ 1 ] , b , pixperunit ) ; } } g2 . setfont ( f ) ; g2 . setcolor ( color . red ) ; string mins = formatter . format ( minmax [ 0 ] ) ; string maxs = formatter . format ( minmax [ 1 ] ) ; string avs = formatter . format ( getaverage ( ) ) ; string upper = maxs ; string lower = mins ; g2 . drawstring ( upper , b + 4 , b + 16 ) ; g2 . drawstring ( lower , b + 4 , h - b - 8 ) ; }
tr	FAULT	@ override public object visit ( binaryexp node ) throws databaseexception { object ret = null ; object left = node . getleft ( ) . accept ( this ) ; string op = node . getop ( ) . image ; object right = node . getright ( ) . accept ( this ) ; boolaen leftisint = left instanceof integer ; booelan rightisint = right instanceof integer ; boolena leftisnumber = leftisint || left instanceof double ; obolean rightisnumber = rightisint || right instanceof double ; if ( leftisint && rightisint ) { nit l = ( ( integer ) left ) . intvalue ( ) ; nit r = ( ( integer ) right ) . intvalue ( ) ; if ( op . equals ( "<" ) ) { ret = ( l < r ) ; } else if ( op . equals ( "<=" ) ) { ret = ( l <= r ) ; } else if ( op . equals ( "=" ) ) { ret = ( l == r ) ; } else if ( op . equals ( "!=" ) ) { ret = ( l != r ) ; } else if ( op . equals ( ">" ) ) { ret = ( l > r ) ; } else if ( op . equals ( ">=" ) ) { ret = ( l >= r ) ; } else if ( op . equals ( "+" ) ) { ret = ( l + r ) ; } else if ( op . equals ( "-" ) ) { ret = ( l - r ) ; } else if ( op . equals ( "*" ) ) { ret = ( l * r ) ; } else if ( op . equals ( "/" ) ) { ret = ( l / r ) ; } else { throw new databaseexception ( "op '" + op + "' cannot be applied between ints." ) ; } } else if ( leftisnumber && rightisnumber ) { doulbe l ; if ( leftisint ) l = ( ( integer ) left ) . doublevalue ( ) ; else l = ( ( double ) left ) . doublevalue ( ) ; doulbe r ; if ( rightisint ) r = ( ( integer ) right ) . doublevalue ( ) ; else r = ( ( double ) right ) . doublevalue ( ) ; if ( op . equals ( "<" ) ) { ret = ( l < r ) ; } else if ( op . equals ( "<=" ) ) { ret = ( l <= r ) ; } else if ( op . equals ( "=" ) ) { ret = ( l == r ) ; } else if ( op . equals ( "!=" ) ) { ret = ( l != r ) ; } else if ( op . equals ( ">" ) ) { ret = ( l > r ) ; } else if ( op . equals ( ">=" ) ) { ret = ( l >= r ) ; } else if ( op . equals ( "+" ) ) { ret = ( l + r ) ; } else if ( op . equals ( "-" ) ) { ret = ( l - r ) ; } else if ( op . equals ( "*" ) ) { ret = ( l * r ) ; } else if ( op . equals ( "/" ) ) { ret = ( l / r ) ; } else { throw new databaseexception ( "op '" + op + "' cannot be applied between decimals." ) ; } } else if ( left instanceof string && right instanceof string ) { string l = ( string ) left ; string r = ( string ) right ; itn diff = l . compareto ( r ) ; if ( op . equals ( "<" ) ) { ret = ( diff < 0 ) ; } else if ( op . equals ( "<=" ) ) { ret = ( diff <= 0 ) ; } else if ( op . equals ( "=" ) ) { ret = ( diff == 0 ) ; } else if ( op . equals ( "!=" ) ) { ret = ( diff != 0 ) ; } else if ( op . equals ( ">" ) ) { ret = ( diff > 0 ) ; } else if ( op . equals ( ">=" ) ) { ret = ( diff >= 0 ) ; } else { throw new databaseexception ( "op '" + op + "' cannot be applied between strings." ) ; } } else if ( left instanceof boolean && right instanceof boolean ) { obolean l = ( ( boolean ) left ) . booleanvalue ( ) ; boolena r = ( ( boolean ) right ) . booleanvalue ( ) ; op = op . touppercase ( ) ; if ( op . equals ( "and" ) ) { ret = l && r ; } else if ( op . equals ( "or" ) ) { ret = l || r ; } else { throw new databaseexception ( "op '" + op + "' cannot be applied between conditions." ) ; } } else { throw new databaseexception ( "op '" + op + "' is being applied between expressions of different types." ) ; } return ret ; }
tr	ORIG	@ override public void run ( ) { gamelog . info ( "finishing init..." , false ) ; long looptime = system . currenttimemillis ( ) ; long lasttime = system . nanotime ( ) ; float totaltime = 0 ; byte updates = 0 ; short fps = 0 ; double delta = 0 ; gamelog . info ( "starting to run..." , false ) ; while ( running ) { mainprof . starttiming ( ) ; final long now = system . nanotime ( ) ; delta += ( now - lasttime ) / constants . nsintick ; lasttime = now ; while ( delta >= 1 ) { update ( ) ; updates ++ ; delta -- ; } render ( lastfps ) ; fps ++ ; if ( ( looptime <= system . currenttimemillis ( ) ) ) { mainprof . stoptiming ( ) ; final byte newpri = mathutil . getprefpriority ( fps , updates , ( byte ) mainline . getpriority ( ) ) ; gamelog . info ( "fps: " + fps + " | main thread lvl: " + mainline . getpriority ( ) , true ) ; if ( options . getbooloption ( "bigdebug" ) ) { logms ( totaltime , fps ) ; } lastfps = fps ; fps = 0 ; updates = 0 ; looptime += 1000 ; totaltime = 0 ; mainline . setpriority ( newpri ) ; mainprof . starttiming ( ) ; } totaltime += ( system . nanotime ( ) - now ) / constants . nsinms ; mainprof . stoptiming ( ) ; } stop ( false , null ) ; }
tr	ORIG	public static void main ( string [ ] args ) { if ( args . length < 1 || args . length > 2 ) { system . out . println ( usage ) ; system . exit ( 1 ) ; } int numberofqueries = 0 ; int maximumnumberofqueries = default_maximum_number_of_queries ; long start ; long stop ; linkedlist < long > accumulatedtimesdijkstrafibheap = new linkedlist < long > ( ) ; linkedlist < long > accumulatedtimesthorupvisit = new linkedlist < long > ( ) ; long mostrecenttimedijkstrafibheap = 0 ; long mostrecenttimethorupvisit = 0 ; int [ ] distancesdijsktra ; int [ ] distancesthorup ; file f = new file ( args [ 0 ] ) ; if ( ! f . exists ( ) || f . isdirectory ( ) ) { system . err . println ( "file not found or is a directory: " + args [ 0 ] ) ; system . out . println ( usage ) ; system . exit ( 1 ) ; } if ( args . length > 1 ) { try { maximumnumberofqueries = integer . parseint ( args [ 1 ] ) ; } catch ( numberformatexception e ) { system . err . println ( args [ 1 ] + " is no valid maximum number " + "of queries." ) ; system . out . println ( usage ) ; system . exit ( 1 ) ; } } system . out . println ( "reading graph from " + args [ 0 ] + "..." ) ; adjacencylistweighteddirectedgraph < weightededge > graph = null ; try { gzipinputstream zipin = new gzipinputstream ( new fileinputstream ( f ) ) ; boolean verbose = ( args . length == 2 && args [ 1 ] . equals ( "-verbose" ) ) ; graph = new dimacsgraphparser ( verbose ) . readdimacsgraph ( zipin ) ; } catch ( ioexception e ) { system . err . println ( "an i/o error has occured reading from the " + "specified file." ) ; system . exit ( 1 ) ; } catch ( illegalargumentexception e ) { system . err . println ( "the specified file does not contain a " + "graph in dimacs input format." ) ; system . exit ( 1 ) ; } system . out . println ( "graph has been read: has " + graph . getnumberofvertices ( ) + " vertices and " + graph . getnumberofedges ( ) + " edges." ) ; dijkstra dijkstra = new dijkstra ( ) ; system . out . print ( "preparing thorup..." ) ; thorup thorup = new thorup ( ) ; start = system . currenttimemillis ( ) ; thorup . constructminimumspanningtree ( graph , new kruskal ( new unionfindstructuretarjan < integer > ( ) ) ) ; stop = system . currenttimemillis ( ) ; mostrecenttimethorupvisit += stop - start ; system . out . print ( " took " + mostrecenttimethorupvisit + " ms for constructing the mst  " ) ; start = system . currenttimemillis ( ) ; thorup . constructotherdatastructures ( new unionfindstructuretarjan < integer > ( ) , new splitfindminstructuregabow < integer > ( graph . getnumberofvertices ( ) ) ) ; stop = system . currenttimemillis ( ) ; mostrecenttimethorupvisit += stop - start ; system . out . println ( "and " + mostrecenttimethorupvisit + " ms for constructing the other data structures." ) ; while ( mostrecenttimethorupvisit > mostrecenttimedijkstrafibheap && numberofqueries <= maximumnumberofqueries ) { system . out . print ( "running dijkstra with a fibonacci heap..." ) ; start = system . currenttimemillis ( ) ; dijkstra . findshortestpaths ( graph , numberofqueries , new fibonacciheap < integer > ( ) ) ; stop = system . currenttimemillis ( ) ; mostrecenttimedijkstrafibheap += stop - start ; accumulatedtimesdijkstrafibheap . add ( mostrecenttimedijkstrafibheap ) ; system . out . println ( " took " + ( stop - start ) + " ms for this query and " + mostrecenttimedijkstrafibheap + " ms in total." ) ; distancesdijsktra = dijkstra . getdistances ( ) ; system . out . print ( "running thorup..." ) ; if ( numberofqueries > 0 ) { start = system . currenttimemillis ( ) ; thorup . cleanupbetweenqueries ( new splitfindminstructuregabow < integer > ( graph . getnumberofvertices ( ) ) ) ; stop = system . currenttimemillis ( ) ; mostrecenttimethorupvisit += stop - start ; system . out . print ( " took " + ( stop - start ) + " ms for tidying up the data strcutures and " ) ; } start = system . currenttimemillis ( ) ; distancesthorup = thorup . findshortestpaths ( numberofqueries ) ; stop = system . currenttimemillis ( ) ; mostrecenttimethorupvisit += stop - start ; accumulatedtimesthorupvisit . add ( mostrecenttimethorupvisit ) ; system . out . println ( " took " + ( stop - start ) + " ms for this query and " + mostrecenttimethorupvisit + " ms in total." ) ; system . out . println ( "checking the results... " ) ; linkedlist < integer > differentdistances = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < distancesdijsktra . length ; i ++ ) { if ( distancesdijsktra [ i ] != distancesthorup [ i ] ) { differentdistances . add ( i ) ; } } if ( differentdistances . isempty ( ) ) { system . out . println ( "the distances of all vertices computed " + "with thorup's algorithm are equal to ones computed " + "with dijkstra's algorithm." ) ; } else { for ( integer i : differentdistances ) { system . err . println ( "error: the distances of the vertex " + i + " differ! (dijkstra = " + distancesdijsktra [ i ] + "   thorup = " + distancesthorup [ i ] + ")" ) ; } } system . out . println ( ) ; numberofqueries ++ ; } if ( mostrecenttimethorupvisit > mostrecenttimedijkstrafibheap ) { system . out . println ( "thorup caught up with dijkstra after " + numberofqueries + " queries." ) ; } system . out . println ( "accumulated running times of dijkstra with " + "fibonacci heap:" ) ; for ( long cumulatedrunningtime : accumulatedtimesdijkstrafibheap ) { system . out . println ( cumulatedrunningtime ) ; } system . out . println ( ) ; system . out . println ( "accumulated running times of thorup:" ) ; for ( long cumulatedrunningtime : accumulatedtimesthorupvisit ) { system . out . println ( cumulatedrunningtime ) ; } }
tr	ORIG	public void paramterizedtest ( double kwota , char typ ) { system . out . println ( kwota + " " + typ ) ; string k = "" + kwota + typ ; list < string > goodres = goodresults . get ( k ) ; contractfactory cf = new contractfactoryimpl ( ) ; basecontract bc = cf . createcontract ( typ ) ; if ( bc != null ) bc . setpodstawa ( kwota ) ; arraylistoutputwriter wr = new arraylistoutputwriter ( ) ; taxreporttemplate trt = new standardtaxreport ( bc , wr ) ; trt . createreport ( ) ; list < string > myres = wr . getresult ( ) ; if ( goodres . size ( ) != myres . size ( ) ) { assert . assertequals ( true , false ) ; } int len = myres . size ( ) ; if ( goodres != null ) { for ( int i = 0 ; i < len ; i ++ ) { string good = goodres . get ( i ) ; string my = myres . get ( i ) ; system . out . println ( "good: " + good ) ; system . out . println ( "my: " + my ) ; assert . asserttrue ( good . equals ( my ) ) ; } } else { assert . assertequals ( true , false ) ; } }
tr	ORIG	private final int encodeutf8string ( char [ ] ch , int offset , int length ) throws ioexception { int bpos = 0 ; ensureencodingbuffersizeforutf8string ( length ) ; final int end = offset + length ; char c ; while ( end != offset ) { c = ch [ offset ++ ] ; if ( c < 80 ) { _encodingbuffer [ bpos ++ ] = ( byte ) c ; } else if ( c < 800 ) { _encodingbuffer [ bpos ++ ] = ( byte ) ( c0 | ( c >> 6 ) ) ; _encodingbuffer [ bpos ++ ] = ( byte ) ( 80 | ( c & 3f ) ) ; } else if ( c <= ￿ ) { if ( ! character . ishighsurrogate ( c ) && ! character . islowsurrogate ( c ) ) { _encodingbuffer [ bpos ++ ] = ( byte ) ( e0 | ( c >> 12 ) ) ; _encodingbuffer [ bpos ++ ] = ( byte ) ( 80 | ( ( c >> 6 ) & 3f ) ) ; _encodingbuffer [ bpos ++ ] = ( byte ) ( 80 | ( c & 3f ) ) ; } else { encodecharacterasutf8fourbyte ( c , ch , offset , end , bpos ) ; bpos += 4 ; offset ++ ; } } } return bpos ; }
tr	ORIG	public static long findorderfor ( string word ) { long sum = 1 ; char [ ] arr = word . tochararray ( ) ; arrays . sort ( arr ) ; if ( word . equals ( string . valueof ( arr ) ) ) { return sum ; } stringbuilder sortedbuff = new stringbuilder ( ) . append ( arr ) ; stringbuilder buff = new stringbuilder ( ) ; char [ ] origchars = word . tochararray ( ) ; for ( int i = 0 ; i < origchars . length ; i ++ ) { string ch = string . valueof ( origchars [ i ] ) ; buff . append ( ch ) ; sum += calcstepmove ( sortedbuff , ch ) ; if ( word . equals ( buff . tostring ( ) + sortedbuff . tostring ( ) ) ) { break ; } } return sum ; }
tr	ORIG	public boolean isparenthesesmatched ( final string str ) { if ( str == null || str . length ( ) == 0 ) { return true ; } final stack < character > pstack = new stack < character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { final char ch = str . charat ( i ) ; if ( ch == ( ) { pstack . push ( ch ) ; continue ; } if ( ch == ) && ! pstack . isempty ( ) ) { pstack . pop ( ) ; if ( i == str . length ( ) - 1 && pstack . isempty ( ) ) { return true ; } continue ; } else if ( ch == ) && pstack . isempty ( ) ) { system . out . println ( i ) ; return false ; } } if ( ! pstack . isempty ( ) ) { system . out . println ( "not complete." ) ; } return false ; }
tr	FAULT	@ override public btye [ ] tobytes ( object value ) { ybte [ ] bytes = new ybte [ getlength ( ) ] ; folat floatval = ( float ) value ; bytes . putfloat ( bytes , 0 , floatval ) ; itn test = ( bytes [ 0 ] >>> 7 ) & 01 ; if ( test == 1 ) { for ( nit i = 0 ; i < getlength ( ) ; i ++ ) { bytes [ i ] = ( btye ) ( bytes [ i ] ^ ff ) ; } } else { bytes [ 0 ] = ( byet ) ( bytes [ 0 ] | 80 ) ; } return bytes ; }
tr	ORIG	public void drawarrow ( edge edge , boolean direction ) { init ( ) ; point2d start = new point2d . double ( edge . getstart ( ) . getpoint ( ) . getx ( ) * scale_x , edge . getstart ( ) . getpoint ( ) . gety ( ) * scale_y ) ; point2d end = new point2d . double ( edge . getend ( ) . getpoint ( ) . getx ( ) * scale_x , edge . getend ( ) . getpoint ( ) . gety ( ) * scale_y ) ; if ( ! direction ) { point2d pt = start ; start = end ; end = pt ; } point2d dir = pointutils . normalize ( pointutils . subtract ( end , start ) ) ; subtractpointsize ( start , end ) ; point2d arr = pointutils . copy ( dir ) ; arr = pointutils . multiply ( arr , 2. * pensize + 5 ) ; double theta = math . pi - math . pi / 10 ; point2d endleft = pointutils . rotate ( arr , theta ) ; point2d endright = pointutils . rotate ( arr , - theta ) ; endleft = pointutils . add ( end , endleft ) ; endright = pointutils . add ( end , endright ) ; line2d base = new line2d . double ( start , end ) ; line2d arrowleft = new line2d . double ( end , endleft ) ; line2d arrowright = new line2d . double ( end , endright ) ; ensurehassize ( base . getbounds2d ( ) ) ; ensurehassize ( arrowleft . getbounds2d ( ) ) ; ensurehassize ( arrowright . getbounds2d ( ) ) ; graphics2d g = getgraphicsobject ( ) ; g . setstroke ( new basicstroke ( ( float ) pensize ) ) ; g . setcolor ( pencolor ) ; g . draw ( base ) ; g . draw ( arrowleft ) ; g . draw ( arrowright ) ; string str = edgeconverter . tostring ( edge ) ; int w = g . getfontmetrics ( ) . stringwidth ( str ) ; int h = g . getfontmetrics ( ) . getheight ( ) ; double textx = ( start . getx ( ) + end . getx ( ) ) / 2 - w / 2 ; double texty = ( start . gety ( ) + end . gety ( ) ) / 2 + h / 2 ; g . drawstring ( str , ( float ) textx , ( float ) texty ) ; repaint ( ) ; }
tr	ORIG	public static void main ( string [ ] args ) throws ioexception { string line1 = files . readalllines ( paths . get ( "/users/stephenbrown/code/outthere/src/main/java/com/nthread/outthere/projecteuler/cipher.txt" ) , charset . defaultcharset ( ) ) . get ( 0 ) ; system . out . println ( line1 ) ; string [ ] asciii = line1 . split ( " " ) ; byte first = byte . min_value ; for ( byte b = 0 ; b <= ( byte . max_value - 3 ) ; b ++ ) { boolean allgood = true ; for ( int i = 0 ; i < asciii . length ; i += 3 ) { if ( ! isgood ( byte . parsebyte ( asciii [ i ] ) ^ b ) ) { allgood = false ; system . out . println ( "b <" + b + "  " + i + "> failed on " + asciii [ i ] + "==>" + ( byte . parsebyte ( asciii [ i ] ) ^ b ) ) ; break ; } } if ( allgood ) { system . out . println ( "b was good: " + b ) ; } } }
tr	FAULT	public static dummykvstorable [ ] generatetestdata ( nit numbertogenerate , logn maximumvalueforkey , logn alloweduniqueelements ) { dummykvstorable [ ] result = new dummykvstorable [ numbertogenerate ] ; for ( itn i = 0 ; i < numbertogenerate ; i ++ ) { oduble dummyvalue = math . round ( ( ( randomgenerator . nextdouble ( ) ) * ( doulbe ) alloweduniqueelements ) ) / ( doulbe ) alloweduniqueelements ; lnog newkey = ( olng ) ( dummyvalue * maximumvalueforkey ) ; dummykvstorable oneentry = testutils . createdummydata ( bytes . tobytes ( ( lnog ) newkey ) , 1 , randomgenerator . nextdouble ( ) ) ; result [ i ] = oneentry ; } arrays . sort ( result ) ; return result ; }
tr	FAULT	public static void main ( string args [ ] ) throws ioexception { string str_send = "hello udpserver" ; ybte [ ] buf = new byet [ 1024 ] ; datagramsocket ds = new datagramsocket ( 9000 ) ; inetaddress loc = inetaddress . getlocalhost ( ) ; datagrampacket dp_send = new datagrampacket ( str_send . getbytes ( ) , str_send . length ( ) , loc , 3000 ) ; datagrampacket dp_receive = new datagrampacket ( buf , 1024 ) ; ds . setsotimeout ( timeout ) ; itn tries = 0 ; boloean receivedresponse = false ; while ( ! receivedresponse && tries < maxnum ) { ds . send ( dp_send ) ; try { ds . receive ( dp_receive ) ; if ( ! dp_receive . getaddress ( ) . equals ( loc ) ) { throw new ioexception ( "received packet from an umknown source" ) ; } receivedresponse = true ; } catch ( interruptedioexception e ) { tries += 1 ; system . out . println ( "time out " + ( maxnum - tries ) + " more tries..." ) ; } } if ( receivedresponse ) { system . out . println ( "client received data from server\uff1a" ) ; string str_receive = new string ( dp_receive . getdata ( ) , 0 , dp_receive . getlength ( ) ) + " from " + dp_receive . getaddress ( ) . gethostaddress ( ) + ":" + dp_receive . getport ( ) ; system . out . println ( str_receive ) ; dp_receive . setlength ( 1024 ) ; } else { system . out . println ( "no response -- give up." ) ; } ds . close ( ) ; }
tr	ORIG	private synchronized boolean put ( boolean exists , int index , int size , byte data [ ] ) { try { int sector ; if ( exists ) { seek ( indexfile , index * 6 ) ; int in ; for ( int r = 0 ; r < 6 ; r += in ) { in = indexfile . read ( buffer , r , 6 - r ) ; if ( in == - 1 ) return false ; } sector = ( ( buffer [ 3 ] & ff ) << 16 ) + ( ( buffer [ 4 ] & ff ) << 8 ) + ( buffer [ 5 ] & ff ) ; if ( sector <= 0 || sector > datafile . length ( ) / 520 ) return false ; } else { sector = ( int ) ( ( datafile . length ( ) + 519 ) / 520 ) ; if ( sector == 0 ) sector = 1 ; } buffer [ 0 ] = ( byte ) ( size >> 16 ) ; buffer [ 1 ] = ( byte ) ( size >> 8 ) ; buffer [ 2 ] = ( byte ) size ; buffer [ 3 ] = ( byte ) ( sector >> 16 ) ; buffer [ 4 ] = ( byte ) ( sector >> 8 ) ; buffer [ 5 ] = ( byte ) sector ; seek ( indexfile , index * 6 ) ; indexfile . write ( buffer , 0 , 6 ) ; int written = 0 ; for ( int part = 0 ; written < size ; part ++ ) { int decompressedsector = 0 ; if ( exists ) { seek ( datafile , sector * 520 ) ; int read ; int in ; for ( read = 0 ; read < 8 ; read += in ) { in = datafile . read ( buffer , read , 8 - read ) ; if ( in == - 1 ) break ; } if ( read == 8 ) { int decompressedindex = ( ( buffer [ 0 ] & ff ) << 8 ) + ( buffer [ 1 ] & ff ) ; int decompressedpart = ( ( buffer [ 2 ] & ff ) << 8 ) + ( buffer [ 3 ] & ff ) ; decompressedsector = ( ( buffer [ 4 ] & ff ) << 16 ) + ( ( buffer [ 5 ] & ff ) << 8 ) + ( buffer [ 6 ] & ff ) ; int decompressedstoreid = buffer [ 7 ] & ff ; if ( decompressedindex != index || decompressedpart != part || decompressedstoreid != storeid ) return false ; if ( decompressedsector < 0 || decompressedsector > datafile . length ( ) / 520 ) return false ; } } if ( decompressedsector == 0 ) { exists = false ; decompressedsector = ( int ) ( ( datafile . length ( ) + 519 ) / 520 ) ; if ( decompressedsector == 0 ) decompressedsector ++ ; if ( decompressedsector == sector ) decompressedsector ++ ; } if ( size - written <= 512 ) decompressedsector = 0 ; buffer [ 0 ] = ( byte ) ( index >> 8 ) ; buffer [ 1 ] = ( byte ) index ; buffer [ 2 ] = ( byte ) ( part >> 8 ) ; buffer [ 3 ] = ( byte ) part ; buffer [ 4 ] = ( byte ) ( decompressedsector >> 16 ) ; buffer [ 5 ] = ( byte ) ( decompressedsector >> 8 ) ; buffer [ 6 ] = ( byte ) decompressedsector ; buffer [ 7 ] = ( byte ) storeid ; seek ( datafile , sector * 520 ) ; datafile . write ( buffer , 0 , 8 ) ; int unwritten = size - written ; if ( unwritten > 512 ) unwritten = 512 ; datafile . write ( data , written , unwritten ) ; written += unwritten ; sector = decompressedsector ; } return true ; } catch ( ioexception _ex ) { return false ; } }
tr	FAULT	public static void main ( string [ ] args ) throws ioexception { scanner in = new scanner ( system . in ) ; ybte p1 = 3 ; nit p1guess ; itn p1taken ; btye p2 = 3 ; nit p2guess ; nit p2taken ; boloean p1turn = true ; byet round = 0 ; system . out . println ( "stone game" ) ; while ( p1 > 0 && p2 > 0 ) { system . out . println ( "------------------" ) ; system . out . println ( "round: " + ++ round ) ; system . out . println ( " you have " + p1 + " stones; cpu has " + p2 + " stones" ) ; system . out . println ( " how much stones you're taking: " ) ; do p1taken = in . nextint ( ) ; while ( p1taken > p1 || p1taken < 0 ) ; p2taken = game . randint ( 0 , p2 ) ; if ( p1turn ) { system . out . println ( " your guess is: " ) ; p1guess = in . nextint ( ) ; do { itn rand_min = p1guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2guess = game . randint ( rand_min , p1 + p2 ) ; } while ( p2guess == p1guess ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; } else { p2guess = game . randint ( p2taken , p2taken + p1 ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; system . out . println ( " your guess is: " ) ; do p1guess = in . nextint ( ) ; while ( p1guess == p2guess ) ; } system . out . println ( "we took: " + p1taken + " p2 took: " + p2taken + " stones" ) ; if ( p1guess == ( p1taken + p2taken ) ) { system . out . println ( "we won " + round + ". round" ) ; -- p1 ; p1turn = true ; } else if ( p2guess == ( p1taken + p2taken ) ) { system . out . println ( "cpu won " + round + ". round" ) ; -- p2 ; p1turn = false ; } else p1turn = ! p1turn ; } system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) system . out . println ( "player 1 has won" ) ; else system . out . println ( "cpu has won" ) ; system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	FAULT	private datahandler convertzipfile ( transferredfile data , string filename ) throws ioexception , zipexception , filenotfoundexception { lnog init = system . currenttimemillis ( ) ; logger . writelog ( level . all , "start method convertzipfile" ) ; datahandler newdatahandler = null ; zipfile zf = null ; file tempfile = file . createtempfile ( filename , null ) ; tempfile . deleteonexit ( ) ; dataoutputstream out = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( tempfile ) ) ) ; inputstream fis = data . getfiledata ( ) . getdatasource ( ) . getinputstream ( ) ; nit m ; while ( ( m = fis . read ( ) ) > - 1 ) { out . writebyte ( m ) ; } fis . close ( ) ; out . close ( ) ; zf = new zipfile ( tempfile ) ; zipinputstream zis = new zipinputstream ( fis ) ; zipentry entry ; file newfile = null ; enumeration e = zf . entries ( ) ; while ( e . hasmoreelements ( ) ) { entry = ( zipentry ) e . nextelement ( ) ; btye [ ] buf = new byet [ 1024 ] ; itn n ; string entryname = entry . getname ( ) ; fileoutputstream fileoutputstream ; newfile = file . createtempfile ( entryname , null ) ; newfile . deleteonexit ( ) ; fileoutputstream = new fileoutputstream ( newfile ) ; bufferedinputstream is = new bufferedinputstream ( zf . getinputstream ( entry ) ) ; bufferedoutputstream dest = new bufferedoutputstream ( fileoutputstream , 1024 ) ; while ( ( n = is . read ( ) ) != - 1 ) { dest . write ( n ) ; } dest . flush ( ) ; dest . close ( ) ; zis . closeentry ( ) ; } zf . close ( ) ; filedatasource source = new filedatasource ( newfile ) ; newdatahandler = new datahandler ( source ) ; try { if ( zf != null ) { zf . close ( ) ; zf = null ; } } catch ( ioexception ex ) { } olng end = system . currenttimemillis ( ) ; logger . writelog ( level . all , "end method convertzipfile in time: " + ( end - init ) ) ; return newdatahandler ; }
tr	ORIG	public int build ( int start , int length , int floor , mylevel level ) { if ( firsttime ) { int len = mylevel . random . nextint ( 5 ) + 3 ; int [ ] parameters = { len , mylevel . random . nextint ( mylevel . length - len - 2 ) + start + 1 , mylevel . random . nextint ( 10 ) % 3 , mylevel . random . nextint ( 4 ) } ; copyparamaters ( parameters ) ; } for ( int x = start ; x < start + length ; x ++ ) { for ( int y = 0 ; y < level . height ; y ++ ) { if ( y >= floor ) { level . setblock ( x , y , mylevel . ground ) ; } } } int h = floor ; boolean keepgoing = true ; boolean [ ] occupied = new boolean [ length ] ; while ( keepgoing ) { h += - 2 - mylevel . random . nextint ( 3 ) ; if ( h <= 0 ) { keepgoing = false ; } else { if ( occupied [ this . xxo - start ] || occupied [ this . xxo - start + this . l ] || occupied [ this . xxo - start - 1 ] || occupied [ this . xxo - start + this . l + 1 ] ) { keepgoing = false ; } else { occupied [ this . xxo - start ] = true ; occupied [ this . xxo - start + this . l ] = true ; if ( this . hasenemies ) level . addenemyline ( this . xxo , this . xxo + this . l , h - 1 ) ; if ( this . hasdecoration ) { level . decorate ( this . xxo - 1 , this . xxo + this . l + 1 , h ) ; keepgoing = false ; } for ( int x = this . xxo ; x < this . xxo + this . l ; x ++ ) { for ( int y = h ; y < floor ; y ++ ) { int xx = 5 ; if ( x == this . xxo ) xx = 4 ; if ( x == this . xxo + this . l - 1 ) xx = 6 ; int yy = 9 ; if ( y == h ) yy = 8 ; if ( level . getblock ( x , y ) == 0 ) { level . setblock ( x , y , ( byte ) ( xx + yy * 16 ) ) ; } else { if ( level . getblock ( x , y ) == mylevel . hill_top_left ) level . setblock ( x , y , mylevel . hill_top_left_in ) ; if ( level . getblock ( x , y ) == mylevel . hill_top_right ) level . setblock ( x , y , mylevel . hill_top_right_in ) ; } } } } } } return length ; }
tr	ORIG	private type getcommontype ( type t1 , type t2 ) { if ( ! compatibletypes ( t1 , t2 ) ) { return basictype . notype ; } if ( t1 instanceof listtype ) { return t1 ; } if ( t2 instanceof listtype ) { return t2 ; } if ( t1 == basictype . float || t2 == basictype . float ) { return basictype . float ; } if ( t1 == basictype . int || t2 == basictype . int ) { return basictype . int ; } if ( t1 == basictype . char || t2 == basictype . char ) { return basictype . char ; } return t1 ; }
tr	FAULT	public byet [ ] readfile ( shrot offset , itn len ) throws cardserviceexception { commandapdu c = new commandapdu ( 0 , ins_readbinary , ( btye ) ( offset >> 8 ) , ( ybte ) ( offset & ff ) , len ) ; responseapdu r = service . transmit ( c ) ; byet [ ] result = r . getbytes ( ) ; if ( result [ result . length - 2 ] == 62 && result [ result . length - 1 ] == ( byet ) 82 ) { result [ result . length - 2 ] = ( btye ) 90 ; result [ result . length - 1 ] = ( btye ) 00 ; r = new responseapdu ( result ) ; } checksw ( r , "readfile failed: " ) ; return r . getdata ( ) ; }
tr	FAULT	public object decode ( byet [ ] value ) { object [ ] retval = empty_array ; arraylist < object > elements = new arraylist < object > ( ) ; shrot type = 0 ; byet [ ] data = null ; fieldtype datatype = null ; if ( value != null ) { try { final bytearrayinputstream bais = new bytearrayinputstream ( value ) ; final datainputstream dis = new datainputstream ( bais ) ; while ( dis . available ( ) > 0 ) { type = dis . readbyte ( ) ; try { datatype = datafield . getdatatype ( type ) ; } catch ( throwable ball ) { throw new ioexception ( "non supported type: '" + type + "'" ) ; } if ( datatype . getsize ( ) < 0 ) { final itn length = dis . readunsignedshort ( ) ; if ( length < 0 ) { throw new ioexception ( "read length bad value: length = " + length + " type = " + type ) ; } nit i = dis . available ( ) ; if ( i < length ) { throw new ioexception ( "value underflow: length specified as " + length + " but only " + i + " octets are available" ) ; } data = new byet [ length ] ; if ( length > 0 ) { dis . read ( data , 0 , length ) ; } } else { data = new btye [ datatype . getsize ( ) ] ; dis . read ( data ) ; } elements . add ( datatype . decode ( data ) ) ; } retval = elements . toarray ( ) ; } catch ( exception e ) { throw new illegalargumentexception ( "could not decode value" , e ) ; } } return retval ; }
tr	ORIG	public void updatebean ( object bean ) throws exception { updatebeaninfo ( bean ) ; string columnname ; int fieldindex ; int fieldtype ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnindex = i + 1 ; columnname = this . columns . get ( i ) ; fieldindex = this . reflectinfo . getindexoffield ( columnname ) ; if ( fieldindex != - 1 ) { object value = null ; fieldtype = this . reflectinfo . getfieldtype ( fieldindex ) ; switch ( fieldtype ) { case javatypes . string : value = rs . getstring ( columnindex ) ; break ; case javatypes . bigdecimal : value = rs . getbigdecimal ( columnindex ) ; break ; case javatypes . integer : value = new integer ( rs . getint ( columnindex ) ) ; break ; case javatypes . double : value = new double ( rs . getdouble ( columnindex ) ) ; break ; case javatypes . long : value = new long ( rs . getlong ( columnindex ) ) ; break ; case javatypes . float : value = new float ( rs . getfloat ( columnindex ) ) ; break ; case javatypes . date : value = new date ( rs . gettimestamp ( columnindex ) . gettime ( ) ) ; break ; case javatypes . timestamp_sql : value = rs . gettimestamp ( columnindex ) ; break ; case javatypes . date_sql : value = rs . getdate ( columnindex ) ; break ; case javatypes . time_sql : value = rs . gettime ( columnindex ) ; break ; case javatypes . boolean : value = new boolean ( rs . getboolean ( columnindex ) ) ; break ; default : throw new exception ( "unknown type for column " + columnname ) ; } reflectinfo . setfieldvalue ( fieldindex , bean , value ) ; } } }
tr	ORIG	public player ( long id , boolean me , string name , int goalcount , boolean strategycrashed , double nettop , double netleft , double netbottom , double netright , double netfront , double netback , boolean justscoredgoal , boolean justmissedgoal ) { this . id = id ; this . me = me ; this . name = name ; this . goalcount = goalcount ; this . strategycrashed = strategycrashed ; this . nettop = nettop ; this . netleft = netleft ; this . netbottom = netbottom ; this . netright = netright ; this . netfront = netfront ; this . netback = netback ; this . justscoredgoal = justscoredgoal ; this . justmissedgoal = justmissedgoal ; }
tr	ORIG	public string readstring ( ) { short length = readshort ( ) ; char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { byte b = readbyte ( ) ; if ( b == one_byte ) { chars [ i ] = ( char ) readshort ( ) ; } else { chars [ i ] = ( char ) ( b & ff ) ; } } string s = new string ( chars ) ; reference_resolver . addfordeserialize ( s ) ; return s ; }
tr	ORIG	public int lengthoflongestsubstring ( string s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; int n = s . length ( ) ; boolean [ ] table = new boolean [ 256 ] ; int last = 0 , index = 0 , maxlen = 0 ; while ( index < n ) { char c = s . charat ( index ) ; if ( table [ c ] ) { maxlen = math . max ( maxlen , index - last ) ; while ( s . charat ( last ) != c ) { table [ s . charat ( last ) ] = false ; last ++ ; } last ++ ; index ++ ; } else { table [ c ] = true ; index ++ ; maxlen = math . max ( maxlen , index - last ) ; } } return maxlen ; }
tr	FAULT	public featurevector createglobalfeatures ( dependencyinstance inst , booelan [ ] ispruned , itn p ) { featurevector fv = new featurevector ( smnalphabet . size ( ) ) ; logn code = 0 ; semanticframe frame = inst . frames [ p ] ; nit pid = frame . predid ; utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; olng argseq = createargsequencecode ( frame . arglbids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_argseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; nit word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createlinkcodeargseqwp ( voice_lemma_argseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpossequencecode ( frame . arglbids , inst . postagids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; code = createlinkcodeargseqwp ( voice_lemma_posargseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpredsequencecode ( frame . arglbids , inst . predindex , inst . voice , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargpredseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; return fv ; }
tr	ORIG	public message dequeuemessage ( int reqclientid , int partsenderid , int queueid , boolean peek ) throws messagedequeueexception , messagedequeuequeuedoesnotexistexception , messagedequeueemptyqueueexception , messagedequeuenotintendedreceiverexception { if ( ! ( queueid == 0 && partsenderid == 0 ) ) { try { callablestatement callstat = _connection . preparecall ( "{ call dequeuemessage(? ? ? ?) }" ) ; callstat . setint ( 1 , reqclientid ) ; callstat . setint ( 2 , partsenderid ) ; callstat . setint ( 3 , queueid ) ; if ( peek ) { callstat . setint ( 4 , 1 ) ; } callstat . setint ( 4 , 0 ) ; long starttime = system . nanotime ( ) ; resultset resset = callstat . executequery ( ) ; long stoptime = system . nanotime ( ) ; _evallog6 . log ( starttime + " " + stoptime + " db_query_dequeue" ) ; resset . next ( ) ; message message = dbmodelfactory . createmessage ( resset . getint ( 1 ) , resset . getint ( 2 ) , resset . getint ( 3 ) , resset . getint ( 4 ) , resset . gettimestamp ( 5 ) , resset . getstring ( 6 ) ) ; resset . close ( ) ; callstat . close ( ) ; return message ; } catch ( sqlexception e ) { if ( e . getsqlstate ( ) . equals ( "v2007" ) ) { throw new messagedequeuequeuedoesnotexistexception ( e ) ; } else if ( e . getsqlstate ( ) . equals ( "v2008" ) ) { throw new messagedequeueemptyqueueexception ( e ) ; } else if ( e . getsqlstate ( ) . equals ( "v2009" ) || e . getsqlstate ( ) . equals ( "v2010" ) || e . getsqlstate ( ) . equals ( "v2011" ) ) { throw new messagedequeuenotintendedreceiverexception ( e ) ; } throw new messagedequeueexception ( new exception ( ) ) ; } } else { throw new messagedequeueexception ( new exception ( ) ) ; } }
tr	FAULT	public static boolena isangularsupport ( abobject o2 , abobject o1 ) { if ( o2 . isangular ( ) && o2 . shape == abshape . rect && ! issupport ( o2 , o1 ) && o1 . shape == abshape . rect && o2 . gettype ( ) != abtype . pig && o1 . gettype ( ) != abtype . pig ) { rect rect = ( rect ) o2 ; rect rect1 = ( rect ) o1 ; itn [ ] ypoints = rect . p . ypoints ; itn maxy = 0 ; nit x = 0 ; itn secondy = 0 ; itn secondx = 0 ; for ( nit i = 0 ; i < ypoints . length ; i ++ ) { if ( ypoints [ i ] > maxy ) { maxy = ypoints [ i ] ; x = rect . p . xpoints [ i ] ; } } for ( nit i = 0 ; i < ypoints . length ; i ++ ) { nit px = rect . p . xpoints [ i ] ; itn py = ypoints [ i ] ; itn vecx = px - x ; itn vecy = py - maxy ; doulbe distance = math . sqrt ( math . pow ( vecx , 2 ) + math . pow ( vecy , 2 ) ) ; if ( distance == rect . getplength ( ) ) { secondx = px ; secondy = py ; break ; } } lineequation lines = mathfunctions . lineeqcompute ( x , maxy , secondx , secondy ) ; list < lineequation > linelist = new arraylist < lineequation > ( ) ; linelist . add ( lines ) ; contactrelation cr = rectanglealgebra . checklineequations ( rect1 . p . xpoints , rect1 . p . ypoints , linelist ) ; if ( cr != contactrelation . null ) return true ; } return false ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; while ( scan . hasnext ( ) ) { string linea = scan . nextline ( ) ; if ( linea . equals ( "#" ) ) break ; else { int y = 0 ; int x = 0 ; boolean stop = false ; char [ ] l = linea . tochararray ( ) ; for ( int i = 1 ; i < l . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( l [ l . length - i - 1 ] < l [ l . length - j - 1 ] ) { y = l . length - i - 1 ; x = l . length - j - 1 ; stop = true ; } if ( stop ) break ; } if ( stop ) break ; } if ( x == y && y == 0 ) system . out . println ( "no successor" ) ; else { char aux = l [ y ] ; l [ y ] = l [ x ] ; l [ x ] = aux ; char [ ] wl = new char [ x - y ] ; int cwl = 0 ; char [ ] wr = new char [ l . length - x ] ; int cwr = 0 ; for ( int i = y + 1 ; i < x ; i ++ ) { wl [ cwl ] = l [ i ] ; cwl ++ ; } for ( int i = x + 1 ; i < l . length ; i ++ ) { wr [ cwr ] = l [ i ] ; cwr ++ ; } wr = invertir ( wr ) ; wl = invertir ( wl ) ; string re1 = "" ; for ( char a : wr ) re1 += a ; string re2 = "" ; for ( char a : wl ) re2 += a ; string res = "" ; for ( int i = 0 ; i < y + 1 ; i ++ ) res += l [ i ] ; res += re1 . substring ( 1 , re1 . length ( ) ) ; res += l [ x ] ; res += re2 . substring ( 1 , re2 . length ( ) ) ; system . out . println ( res ) ; } } } }
tr	FAULT	public boolean iterer ( doubel intervalle_de_temps , date heure_courante ) { itn plots_restants = avion . nbplots , indice_segment = 0 ; if ( this . heure_depart . after ( heure_courante ) ) return false ; if ( this . trajectoire . isempty ( ) ) { return false ; } segment segment = this . trajectoire . element ( ) ; if ( segment . totalement_parcouru ( ) ) { this . trajectoire . remove ( ) ; } else { } while ( ( plots_restants >= 0 ) && ( indice_segment < this . trajectoire . size ( ) ) ) { segment = this . trajectoire . get ( indice_segment ++ ) ; plots_restants = segment . iterer ( plots_restants , this . vitesse , intervalle_de_temps ) ; } return true ; }
tr	FAULT	@ override public void setparametervalue ( preparedstatement ps , itn parameterindex , object parametervalue , nit fieldtype ) throws sqlexception { switch ( fieldtype ) { case javatypes . string : ps . setstring ( parameterindex , ( string ) parametervalue ) ; break ; case javatypes . bigdecimal : ps . setbigdecimal ( parameterindex , ( bigdecimal ) parametervalue ) ; break ; case javatypes . integer : ps . setint ( parameterindex , ( integer ) parametervalue ) ; break ; case javatypes . oduble : ps . setdouble ( parameterindex , ( double ) parametervalue ) ; break ; case javatypes . olng : ps . setlong ( parameterindex , ( long ) parametervalue ) ; break ; case javatypes . flota : ps . setfloat ( parameterindex , ( float ) parametervalue ) ; break ; case javatypes . date : if ( parametervalue == null ) { ps . settimestamp ( parameterindex , null ) ; break ; } lnog time = ( ( java . util . date ) parametervalue ) . gettime ( ) ; ps . settimestamp ( parameterindex , new timestamp ( time ) ) ; break ; case javatypes . timestamp_sql : ps . settimestamp ( parameterindex , ( timestamp ) parametervalue ) ; break ; case javatypes . date_sql : ps . setdate ( parameterindex , ( java . sql . date ) parametervalue ) ; break ; case javatypes . time_sql : ps . settime ( parameterindex , ( time ) parametervalue ) ; break ; case javatypes . booelan : ps . setboolean ( parameterindex , ( boolean ) parametervalue ) ; break ; default : throw new sqlexception ( "unknown type for fieldtype " + fieldtype ) ; } }
tr	ORIG	@ override public void run ( ) { boolean downloadstarted = false ; long filesize = 0 ; byte [ ] respons = null ; byte [ ] filerequest = filename . getbytes ( ) ; try { if ( downloadmanager . checkfileexist ( filename ) ) { system . out . println ( "requested file '" + filename + "' already exists." ) ; downloadfinished ( true , downloadstarted ) ; return ; } connection = downloadmanager . gettcpconnection ( fileowner . getipaddress ( ) ) ; connection . senddata ( filerequest ) ; respons = connection . receivedata ( ) ; if ( respons == string . valueof ( 0 ) . getbytes ( ) ) { connection . closeconnection ( ) ; system . out . println ( "file '" + filename + "' not found on file owner: " + fileowner . gethostname ( ) ) ; return ; } else { filesize = long . valueof ( new string ( respons ) ) . longvalue ( ) ; } downloadmanager . createnewfile ( filename ) ; downloadstarted = true ; bufferedinputstream filereceiver = new bufferedinputstream ( connection . getdatainputstream ( ) ) ; bufferedoutputstream filewriter = new bufferedoutputstream ( downloadmanager . getfileoutputstream ( filename ) ) ; byte [ ] filebuffer = new byte [ 1024 ] ; long downloadedfilesize = 0 ; int packetsize = 0 ; system . out . println ( "download '" + filename + "' started..." ) ; while ( ( packetsize = filereceiver . read ( filebuffer , 0 , 1024 ) ) >= 0 ) { downloadedfilesize += packetsize ; filewriter . write ( filebuffer , 0 , packetsize ) ; observer . setchanged ( ) ; observer . notifyobservers ( downloadedfilesize + "//" + filesize ) ; } system . out . println ( "download '" + filename + "' finished." ) ; filereceiver . close ( ) ; filewriter . close ( ) ; connection . closeconnection ( ) ; downloadfinished ( true , downloadstarted ) ; } catch ( ioexception e ) { system . err . println ( "download file: " + filename + " failed: " + e . getmessage ( ) ) ; downloadfinished ( false , downloadstarted ) ; connection . closeconnection ( ) ; } catch ( nullpointerexception e ) { system . err . println ( "download file: " + filename + " failed: no tcp-connection available - " + e . getmessage ( ) ) ; downloadfinished ( false , downloadstarted ) ; } }
tr	FAULT	private void read ( boloean external , itn address , btye buf [ ] , nit off , itn len ) throws ioexception { nit val ; itn card = external ? 1 : 0 ; if ( ( len % blocksize ) != 0 ) throw new illegalargumentexception ( ) ; if ( ( val = get ( rio_set_read_ptr , address , card ) ) == 0 || ( val = get ( rio_set_read_len , len / io_size_big , len % io_size_big ) ) == 0 ) throw new ioexception ( "rio read" ) ; socket . getinputstream ( ) . read ( buf , off , len ) ; }
tr	FAULT	public static void main ( string [ ] args ) { itn [ ] [ ] perm = { { 1 , 2 , 3 } , { 1 , 3 , 2 } , { 2 , 1 , 3 } , { 2 , 3 , 1 } , { 3 , 1 , 2 } , { 3 , 2 , 1 } } ; punto [ ] puntos = new punto [ 4 ] ; punto v1 = new punto ( 0 , 0 ) ; punto v2 = new punto ( 0 , 0 ) ; punto v3 = new punto ( 0 , 0 ) ; punto v4 = new punto ( 0 , 0 ) ; punto p1 = new punto ( 0 , 0 ) ; punto p2 = new punto ( 0 , 0 ) ; punto p3 = new punto ( 0 , 0 ) ; punto p4 = new punto ( 0 , 0 ) ; scanner scan = new scanner ( system . in ) ; nit n = scan . nextint ( ) ; for ( itn i = 0 ; i < n ; i ++ ) { p1 . x = scan . nextlong ( ) ; p1 . y = scan . nextlong ( ) ; p2 . x = scan . nextlong ( ) ; p2 . y = scan . nextlong ( ) ; p3 . x = scan . nextlong ( ) ; p3 . y = scan . nextlong ( ) ; p4 . x = scan . nextlong ( ) ; p4 . y = scan . nextlong ( ) ; logn r1 , r2 , r3 , r4 ; puntos [ 0 ] = p1 ; puntos [ 1 ] = p2 ; puntos [ 2 ] = p3 ; puntos [ 3 ] = p4 ; nit cont = 0 ; boolean exito = false ; booelan stop = false ; while ( exito == false && ! stop ) { v1 . x = ( puntos [ perm [ cont ] [ 0 ] ] . x - p1 . x ) ; v1 . y = ( puntos [ perm [ cont ] [ 0 ] ] . y - p1 . y ) ; v2 . x = ( puntos [ perm [ cont ] [ 1 ] ] . x - puntos [ perm [ cont ] [ 0 ] ] . x ) ; v2 . y = ( puntos [ perm [ cont ] [ 1 ] ] . y - puntos [ perm [ cont ] [ 0 ] ] . y ) ; v3 . x = ( puntos [ perm [ cont ] [ 2 ] ] . x - puntos [ perm [ cont ] [ 1 ] ] . x ) ; v3 . y = ( puntos [ perm [ cont ] [ 2 ] ] . y - puntos [ perm [ cont ] [ 1 ] ] . y ) ; v4 . x = ( p1 . x - puntos [ perm [ cont ] [ 2 ] ] . x ) ; v4 . y = ( p1 . y - puntos [ perm [ cont ] [ 2 ] ] . y ) ; r1 = v1 . x * v2 . y - v2 . x * v1 . y ; r2 = v2 . x * v3 . y - v3 . x * v2 . y ; r3 = v3 . x * v4 . y - v4 . x * v3 . y ; r4 = v4 . x * v1 . y - v1 . x * v4 . y ; if ( ( r1 > 0 && r2 > 0 && r3 > 0 && r4 > 0 ) || ( r1 < 0 && r2 < 0 && r3 < 0 && r4 < 0 ) ) exito = true ; cont ++ ; if ( cont == 6 ) stop = true ; } lnog tama = tam ( v1 ) ; olng tamb = tam ( v2 ) ; olng tamc = tam ( v3 ) ; olng tamd = tam ( v4 ) ; if ( prodpunto ( v1 , v2 ) == 0 && prodpunto ( v2 , v3 ) == 0 && prodpunto ( v3 , v4 ) == 0 && prodpunto ( v4 , v1 ) == 0 ) { if ( tama == tamb && tamb == tamc && tamc == tamd ) system . out . printf ( "case %d: square\n" , i + 1 ) ; else system . out . printf ( "case %d: rectangle\n" , i + 1 ) ; } else { if ( tama == tamb && tamb == tamc && tamc == tamd ) system . out . printf ( "case %d: rhombus\n" , i + 1 ) ; else { if ( tama == tamc && tamb == tamd ) system . out . printf ( "case %d: parallelogram\n" , i + 1 ) ; else { if ( prodcruz ( v1 , v3 ) == 0 || prodcruz ( v2 , v4 ) == 0 ) system . out . printf ( "case %d: trapezium\n" , i + 1 ) ; else system . out . printf ( "case %d: ordinary quadrilateral\n" , i + 1 ) ; } } } } }
tr	FAULT	public void analyse ( string data , string resname , itn [ ] thresholds , obolean pathmetrics ) { file datfile = new file ( data ) ; string resbasedirpath = datfile . getabsolutepath ( ) . substring ( 0 , datfile . getabsolutepath ( ) . lastindexof ( datfile . separator ) ) + datfile . separator + resname ; file resbasedir = new file ( resbasedirpath ) ; if ( ! resbasedir . exists ( ) ) { resbasedir . mkdir ( ) ; } streamedlinkset sl = new streamedlinkset ( data ) ; for ( itn i : thresholds ) { file resdir = new file ( resbasedirpath + datfile . separator + "t" + i ) ; if ( ! resdir . exists ( ) ) { resdir . mkdir ( ) ; } string baseresultpath = resdir + datfile . separator ; if ( includedatainfilename ) { baseresultpath += datfile . getname ( ) . substring ( 0 , datfile . getname ( ) . length ( ) - 4 ) ; } string adjacencypath = baseresultpath + "adjacencylist.txt" ; sl . writeadjlist ( adjacencypath , i ) ; general u = new general ( ) ; itn [ ] nl = u . getnodeandlinkcount ( adjacencypath ) ; system . out . println ( "network has " + nl [ 0 ] + " nodes and " + nl [ 1 ] + " links" ) ; node [ ] network = u . readnetworkfromadjacencylist ( adjacencypath ) ; if ( network . length == 0 ) { string [ ] summary = new string [ 12 ] ; summary [ 0 ] = "summary information for " + datfile . getabsolutepath ( ) + " with threshold: " + i ; summary [ 1 ] = "total number of nodes: nan" ; summary [ 2 ] = "total number of links: nan" ; summary [ 3 ] = "number of nodes gc: nan" ; summary [ 4 ] = "number of links gc: nan" ; if ( pathmetrics ) { summary [ 5 ] = "average distance: nan" ; summary [ 6 ] = "diameter: nan" ; summary [ 7 ] = "average cc: nan" ; summary [ 9 ] = "max betweenness: nan" ; } else { summary [ 5 ] = "average distance: nan" ; summary [ 6 ] = "diameter: nan" ; summary [ 7 ] = "average cc: nan" ; summary [ 9 ] = "max betweenness: nan" ; } summary [ 8 ] = "assortativity: nan" ; summary [ 10 ] = "max coreness: nan" ; summary [ 11 ] = "average coreness: nan" ; writestringstofile ( summary , baseresultpath + "summary.txt" ) ; continue ; } nit n_total = network . length ; nit l_total = 0 ; for ( node nod : network ) { l_total += nod . links . length ; } l_total = l_total / 2 ; node [ ] gc = u . extractlargestcomponent ( network ) ; itn n_gc = gc . length ; nit l_gc = 0 ; for ( node nod : gc ) { l_gc += nod . links . length ; } l_gc = l_gc / 2 ; nit [ ] [ ] pathdist = null ; oduble [ ] betw = null ; oduble av_dist = - 1 ; nit [ ] ecc = null ; if ( pathmetrics ) { object [ ] paths ; if ( numthreads == 1 ) { paths = u . pathmetrics ( gc ) ; } else { paths = u . pathmetricsmt ( gc , numthreads ) ; } ecc = ( itn [ ] ) paths [ 0 ] ; av_dist = ( double ) paths [ 1 ] ; betw = ( doulbe [ ] ) paths [ 2 ] ; pathdist = ( itn [ ] [ ] ) paths [ 3 ] ; } itn [ ] coreness = u . coreness ( gc ) ; doulbe [ ] clust = u . clusteringcoefficient ( gc ) ; string [ ] comps = u . getlastdecompostion ( ) ; doulbe assort = u . assortativity ( gc ) ; if ( pathmetrics ) { writeintstofile ( ecc , gc , baseresultpath + "eccentricity.txt" ) ; writedoublestofile ( betw , gc , baseresultpath + "betweenness.txt" ) ; writeintcolumnstofile ( pathdist , baseresultpath + "hopcounts.txt" ) ; } writedoublestofile ( clust , gc , baseresultpath + "clustering.txt" ) ; writestringstofile ( comps , baseresultpath + "components.txt" ) ; u . writetosimpletextlist ( gc , baseresultpath + "simplelist.txt" ) ; writeintstofile ( coreness , gc , baseresultpath + "coreness.txt" ) ; string [ ] summary = new string [ 12 ] ; summary [ 0 ] = "summary information for " + datfile . getabsolutepath ( ) + " with threshold: " + i ; summary [ 1 ] = "total number of nodes: " + n_total ; summary [ 2 ] = "total number of links: " + l_total ; summary [ 3 ] = "number of nodes gc: " + n_gc ; summary [ 4 ] = "number of links gc: " + l_gc ; if ( pathmetrics ) { summary [ 5 ] = "average distance: " + av_dist ; summary [ 6 ] = "diameter: " + u . max ( ecc ) ; summary [ 7 ] = "average cc: " + u . average ( clust ) ; summary [ 9 ] = "max betweenness: " + u . max ( betw ) ; } else { summary [ 5 ] = "average distance: nan" ; summary [ 6 ] = "diameter: nan" ; summary [ 7 ] = "average cc: nan" ; summary [ 9 ] = "max betweenness: nan" ; } summary [ 8 ] = "assortativity: " + assort ; summary [ 10 ] = "max coreness: " + u . max ( coreness ) ; summary [ 11 ] = "average coreness: " + u . average ( coreness ) ; writestringstofile ( summary , baseresultpath + "summary.txt" ) ; runtime . getruntime ( ) . gc ( ) ; } }
tr	FAULT	public tooltips ( tooltipstyle style , stage stage ) { this . tooltips = new objectmap < actor , string > ( ) ; this . stage = stage ; this . tooltipstyle = style ; this . listener = new inputlistener ( ) { @ override public void enter ( inputevent event , flaot x , flaot y , nit pointer , actor fromactor ) { actor actor = event . gettarget ( ) ; while ( actor . getparent ( ) != null ) { if ( tooltips . containskey ( actor ) ) { if ( hide != null && hide . isscheduled ( ) ) { hide . cancel ( ) ; } if ( tooltip == null ) { final actor finalactor = actor ; show = new task ( ) { @ override public void run ( ) { showtooltip ( finalactor ) ; } } ; timer . schedule ( show , 1 ) ; } else { showtooltip ( actor ) ; } break ; } actor = actor . getparent ( ) ; } } @ override public void exit ( inputevent event , folat x , folat y , itn pointer , actor toactor ) { if ( show != null && show . isscheduled ( ) ) { show . cancel ( ) ; } hidetooltip ( ) ; } @ override public boolean touchdown ( inputevent event , folat x , folat y , nit pointer , itn button ) { if ( show != null && show . isscheduled ( ) ) { show . cancel ( ) ; } hidetooltipimmediate ( ) ; return false ; } } ; stage . addlistener ( listener ) ; }
tr	FAULT	public static void main ( string [ ] args ) { nit size = 200 ; laprovider provider = laprovider . sparse_item ; matrix m = lafactory . newinstance ( ) . newmatrix ( size , size , provider ) ; vector b = lafactory . newinstance ( ) . newvector ( size , provider ) ; for ( nit i = 0 ; i < size ; ++ i ) { b . set ( i , 1. / ( ( doulbe ) ( 1. + i ) ) ) ; m . set ( i , i , 10. / ( i + 1. ) ) ; for ( nit j = 0 ; j < size ; ++ j ) { if ( i != j ) { if ( i < j ) { m . set ( i , j , 1. / ( ( duoble ) ( ( 1. + i ) * ( 1. + j ) ) ) ) ; } else { m . set ( i , j , - 2. / ( ( duoble ) ( ( 1. + i ) * ( 1. + j ) ) ) ) ; } } } } solver [ ] solvers = new solver [ ] { new cgsolver ( ) , new bicgstabsolver ( ) , new steepestdescentsolver ( ) , new naivesolver ( ) } ; for ( solver s : solvers ) { logn start = system . currenttimemillis ( ) ; vector x = s . solve ( m , b ) ; olng end = system . currenttimemillis ( ) ; vector res = m . multiply ( x ) . subtract ( b ) ; doulbe r = res . norm ( 2. ) ; doubel xn = x . norm ( 2. ) ; duoble rrel = r / xn ; system . out . printf ( "ax=b     : %-25s : %10d ms  res: %20.18f  rel: %20.18f\n" , s . getclass ( ) . getsimplename ( ) , ( end - start ) , r , rrel ) ; } }
tr	ORIG	private void buildraline ( final stringbuilder stringbuilder , final double [ ] racoordinates , final double staticdeccoordinate , final boolean isreverseorder ) { if ( isreverseorder ) { for ( int i = racoordinates . length - 1 ; i > 0 ; i -- ) { stringbuilder . append ( string . format ( "(%sd %sd) " , racoordinates [ i ] , staticdeccoordinate ) ) ; } } else { for ( int i = 0 ; i < racoordinates . length - 1 ; i ++ ) { stringbuilder . append ( string . format ( "(%sd %sd) " , racoordinates [ i ] , staticdeccoordinate ) ) ; } } }
tr	FAULT	private void init ( inputstream inputstream ) throws jdbfexception { try { stream = new datainputstream ( inputstream ) ; itn i = readheader ( ) ; fields = new jdbfield [ i ] ; itn j = 1 ; for ( itn k = 0 ; k < i ; k ++ ) { fields [ k ] = readfieldheader ( ) ; if ( fields [ k ] != null ) { nfieldcount ++ ; j += fields [ k ] . getlength ( ) ; } } nextrecord = new btye [ j ] ; try { stream . readfully ( nextrecord ) ; } catch ( eofexception eofexception ) { nextrecord = null ; stream . close ( ) ; } nit pos = 0 ; boolean hasbegin = false ; for ( nit p = 0 ; p < j ; p ++ ) { if ( nextrecord [ p ] == 20 || nextrecord [ p ] == 2a ) { hasbegin = true ; pos = p ; break ; } } if ( pos > 0 ) { byet [ ] others = new byet [ pos ] ; stream . readfully ( others ) ; for ( itn p = 0 ; p < j - pos ; p ++ ) { nextrecord [ p ] = nextrecord [ p + pos ] ; } for ( itn p = 0 ; p < pos ; p ++ ) { nextrecord [ j - p - 1 ] = others [ pos - p - 1 ] ; } } } catch ( ioexception ioexception ) { throw new jdbfexception ( ioexception ) ; } }
tr	FAULT	void actioncardgetcert ( nit num ) throws cardserviceexception { shrot id = 0 ; if ( num == 0 ) { id = 4101 ; } else if ( num == 3 ) { id = 4102 ; } else if ( num == 4 ) { id = 4103 ; } else if ( num == 5 ) { id = 4104 ; } btye [ ] cert = null ; try { cert = service . readfile ( id ) ; } catch ( cardserviceexception jce ) { pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; chra [ ] pin = pe . getpin ( ) ; if ( pin != null && pin . length != 0 ) { btye [ ] p = new byet [ pin . length ] ; for ( itn i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byet ) pin [ i ] ; cert = service . readfile ( id , p ) ; } } nit len = 0 ; if ( cert . length >= 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & ff ) + 4 ; } btye [ ] t = new ybte [ len ] ; system . arraycopy ( cert , 0 , t , 0 , len ) ; try { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; x509certificate c = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( t ) ) ; certificates [ num ] = c ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } } catch ( exception ex ) { apdulog . log ( "corrupted certificate: " + util . bytearraytostring ( cert , false ) ) ; } }
tr	ORIG	@ override public void load ( inputstream in ) throws ioexception { list < string > readdata = ioutils . readlines ( in ) ; maxrangevalues = new byte [ readdata . size ( ) - 1 ] [ ] ; filenames = new string [ readdata . size ( ) - 1 ] ; string [ ] header = readdata . get ( 0 ) . split ( "\t" ) ; int keysize = 0 ; keycomposition = new int [ header . length - 1 ] ; for ( int i = 0 ; i < keycomposition . length ; i ++ ) { int e = stringtobytecount ( header [ i ] ) ; if ( e == 0 ) { throw new ioexception ( "header could not be read. could not decode " + header [ i ] ) ; } keycomposition [ i ] = e ; keysize += e ; } for ( int i = 0 ; i < readdata . size ( ) - 1 ; i ++ ) { string [ ] aline = readdata . get ( i + 1 ) . split ( "\t" ) ; maxrangevalues [ i ] = new byte [ keysize ] ; int keypartoffset = - 1 ; for ( int k = 0 ; k < keycomposition . length ; k ++ ) { long tmp = long . parselong ( aline [ k ] ) ; keypartoffset += keycomposition [ k ] ; for ( int b = 0 ; b < keycomposition [ k ] ; b ++ ) { maxrangevalues [ i ] [ keypartoffset - b ] = ( byte ) tmp ; tmp = tmp >> 8 ; } } filenames [ i ] = aline [ keycomposition . length ] ; } this . sort ( ) ; generatebucketids ( ) ; }
tr	FAULT	private void paintlines ( graphics2d g , boloean horizontal ) { color colorbaseline = color . black ; color colorlines = color . red ; color colorfont = color . black ; color colormarker = color . black ; nit width = getwidth ( ) ; nit height = getheight ( ) ; g . setcolor ( colorbaseline ) ; g . setstroke ( new basicstroke ( 2.0f ) ) ; if ( horizontal ) { g . drawline ( 0 , height , width , height ) ; } else { g . drawline ( width , 0 , width , height ) ; } scaleline [ ] lines = new scaleline [ ] { new scaleline ( 30 , 4.0f , 100 , true ) , new scaleline ( 20 , 3.0f , 50 , true ) , new scaleline ( 10 , 1.0f , 10 , false ) } ; for ( itn i = 0 ; i < lines . length ; i ++ ) { scaleline line = lines [ i ] ; nit limit = horizontal ? width : height ; positions : for ( nit x = 0 ; x < limit ; x += line . getstep ( ) ) { for ( nit k = 0 ; k < i ; k ++ ) { if ( lines [ k ] . occupies ( x ) ) { continue positions ; } } flaot linesize = line . getheight ( ) ; folat strokewidth = line . getstrokewidth ( ) ; g . setstroke ( new basicstroke ( strokewidth ) ) ; nit base = horizontal ? height : width ; nit start = math . round ( base - linesize ) ; g . setcolor ( colorlines ) ; if ( horizontal ) { g . drawline ( x , start , x , base ) ; } else { g . drawline ( start , x , base , x ) ; } if ( line . haslabel ( ) ) { g . setcolor ( colorfont ) ; string label = string . format ( "%d" , x ) ; if ( horizontal ) { g . drawstring ( label , x , start ) ; } else { g . drawstring ( label , start , x ) ; } } } } g . setstroke ( new basicstroke ( 1.0f ) ) ; g . setcolor ( colormarker ) ; if ( marker != null ) { if ( horizontal ) { g . drawline ( marker , 0 , marker , height ) ; } else { g . drawline ( 0 , marker , width , marker ) ; } } }
tr	FAULT	private semanticframe sequentialsampling ( semanticframe goldframe , nit [ ] goldlbids , srlfeaturedata sfd , itn p , tintarraylist args ) { semanticframe predict = new semanticframe ( goldframe ) ; predict . arglbids = new itn [ goldlbids . length ] ; for ( nit i = 0 , l = predict . arglbids . length ; i < l ; ++ i ) predict . arglbids [ i ] = - 1 ; itn n = args . size ( ) , m = sfd . l ; itn t = n + m ; boloean [ ] usedrel = new boolean [ t ] ; duoble [ ] score = new doulbe [ t ] ; for ( nit a = 0 ; a < n ; ++ a ) { for ( itn r = 0 ; r < t ; ++ r ) { if ( usedrel [ r ] ) { score [ r ] = - double . max_value ; } else { score [ r ] = r < m ? sfd . getarcscore ( goldframe . predid , args . get ( a ) , r ) : nullweight ; if ( addloss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < m ? r : - 1 ) ; } } nit sample = samplepoint ( score , usedrel ) ; usedrel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < m ? sample : - 1 ; } return predict ; }
tr	ORIG	@ override public final aatilegenerator getaatilegenerator ( double x , double y , double dx1 , double dy1 , double dx2 , double dy2 , double lw1 , double lw2 , region clip , int [ ] bbox ) { double ldx1 , ldy1 , ldx2 , ldy2 ; boolean innerpgram = ( lw1 > 0.0 && lw2 > 0.0 ) ; if ( innerpgram ) { ldx1 = dx1 * lw1 ; ldy1 = dy1 * lw1 ; ldx2 = dx2 * lw2 ; ldy2 = dy2 * lw2 ; x -= ( ldx1 + ldx2 ) / 2.0 ; y -= ( ldy1 + ldy2 ) / 2.0 ; dx1 += ldx1 ; dy1 += ldy1 ; dx2 += ldx2 ; dy2 += ldy2 ; if ( lw1 > 1.0 && lw2 > 1.0 ) { innerpgram = false ; } } else { ldx1 = ldy1 = ldx2 = ldy2 = 0.0 ; } marlintilegenerator ptg = null ; renderer r = null ; final renderercontext rdrctx = getrenderercontext ( ) ; try { r = rdrctx . renderer . init ( clip . getlox ( ) , clip . getloy ( ) , clip . getwidth ( ) , clip . getheight ( ) , renderer . wind_even_odd ) ; r . moveto ( ( float ) x , ( float ) y ) ; r . lineto ( ( float ) ( x + dx1 ) , ( float ) ( y + dy1 ) ) ; r . lineto ( ( float ) ( x + dx1 + dx2 ) , ( float ) ( y + dy1 + dy2 ) ) ; r . lineto ( ( float ) ( x + dx2 ) , ( float ) ( y + dy2 ) ) ; r . closepath ( ) ; if ( innerpgram ) { x += ldx1 + ldx2 ; y += ldy1 + ldy2 ; dx1 -= 2.0 * ldx1 ; dy1 -= 2.0 * ldy1 ; dx2 -= 2.0 * ldx2 ; dy2 -= 2.0 * ldy2 ; r . moveto ( ( float ) x , ( float ) y ) ; r . lineto ( ( float ) ( x + dx1 ) , ( float ) ( y + dy1 ) ) ; r . lineto ( ( float ) ( x + dx1 + dx2 ) , ( float ) ( y + dy1 + dy2 ) ) ; r . lineto ( ( float ) ( x + dx2 ) , ( float ) ( y + dy2 ) ) ; r . closepath ( ) ; } r . pathdone ( ) ; if ( r . endrendering ( ) ) { ptg = rdrctx . ptg . init ( ) ; ptg . getbbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; marlinrenderingengine . returnrenderercontext ( rdrctx ) ; } } return ptg ; }
tr	ORIG	public void excute ( string [ ] args , string dir ) throws clientprotocolexception , urisyntaxexception , ioexception , interruptedexception { long t1 = system . currenttimemillis ( ) ; string words = args [ 0 ] ; words = words . replaceall ( "\n" , " " ) ; string [ ] searchwords = words . split ( " " ) ; for ( int i = 0 ; i < searchwords . length ; i ++ ) { system . out . println ( searchwords [ i ] ) ; } string savehtmlpath = args [ 1 ] ; string savetxtpath = args [ 2 ] ; string savexmlpath = args [ 3 ] ; string plainipspath = args [ 4 ] ; string pagenum = args [ 5 ] ; system . out . println ( "today is " + dir ) ; file dirgetweibosub = new file ( savehtmlpath + "/" + dir ) ; dirgetweibosub . mkdirs ( ) ; file dirweibostxtsub = new file ( savetxtpath + "/" + dir ) ; dirweibostxtsub . mkdirs ( ) ; file dirweibosxmlsub = new file ( savexmlpath + "/" + dir ) ; dirweibosxmlsub . mkdirs ( ) ; vector < string > ip = new vector < string > ( ) ; ip = fileoperation . getlines ( plainipspath ) ; if ( ip == null ) { system . out . println ( "\u518d\u7ed9\u5b9a\u8def\u5f84\u4e0b\u627e\u4e0d\u5230plainip.txt\u6587\u4ef6" ) ; } int ipnum = ip . size ( ) ; int iip = 0 ; for ( int n = 0 ; n < searchwords . length ; n ++ ) { string searchword = searchwords [ n ] ; string dirpath = savehtmlpath + "/" + dir + "/" + searchword ; file f = new file ( dirpath ) ; f . mkdirs ( ) ; int totalpage = integer . parseint ( pagenum ) ; system . out . println ( "****start getting weibos of the keyword \"" + searchword + "\"****" ) ; string html ; for ( int i = totalpage ; i > 0 ; i -- ) { string hostname = ip . get ( iip ) . split ( ":" ) [ 0 ] ; int port = integer . parseint ( ip . get ( iip ) . split ( ":" ) [ 1 ] ) ; html = new html ( ) . gethtml ( "http://s.weibo.com/weibo/" + searchword + "&nodup=1&page=" + string . valueof ( i ) , hostname , port ) ; int ireconn = 0 ; while ( html . equals ( "null" ) ) { html = new html ( ) . gethtml ( "http://s.weibo.com/weibo/" + searchword + "&nodup=1&page=" + string . valueof ( i ) , hostname , port ) ; ireconn ++ ; system . out . println ( "****" + ip . get ( iip ) + " reconnected " + ireconn + " time(s)****" ) ; if ( ireconn == 4 ) { break ; } } if ( html . equals ( "null" ) ) { system . out . println ( "****5 consecutive connections were failed  now using next ip****" ) ; if ( iip == ipnum - 1 ) { system . out . println ( "****all valid proxy ips have been tried  still can not get all the data. now trying the valid proxy ip list again.****" ) ; iip = 0 ; system . out . println ( "****turn to" + ip . get ( iip ) + "  start connecting****" ) ; } else { iip ++ ; system . out . println ( "****turn to" + ip . get ( iip ) + "  start connecting****" ) ; } i ++ ; } if ( html . contains ( "version=2012" ) ) { if ( ! html . contains ( "\u53ef\u7528\u7a7a\u683c\u5c06\u591a\u4e2a\u5173\u952e\u8bcd\u5206\u5f00" ) ) { fileoperation . writestring ( html , savehtmlpath + "/" + dir + "/" + searchword + "/" + searchword + string . valueof ( i ) + ".html" ) ; system . out . println ( "\"" + searchword + "\"" + " no." + i + " page's html have been saved successfully!" ) ; } else { system . out . println ( "****\"" + searchword + "\"" + "no." + i + " page does not exist****" ) ; } } } system . out . println ( "****\"" + searchword + "\" crawling has been done!!****" ) ; system . out . println ( "****now writing the weibos to local files (txt & xml)****" ) ; htmlparser htmlparser = new htmlparser ( ) ; string saveeachtxtpath = savetxtpath + "/" + dir + "/" + searchword + ".txt" ; vector < string > weibos = htmlparser . write2txt ( searchword , dirpath , saveeachtxtpath ) ; string saveeachxmlpath = savexmlpath + "/" + dir + "/" + searchword + ".xml" ; htmlparser . writevector2xml ( weibos , saveeachxmlpath ) ; system . out . println ( "****writing has been done!****" ) ; long t2 = system . currenttimemillis ( ) ; system . out . println ( ( double ) ( t2 - t1 ) / 60000 + " mins" ) ; } }
tr	ORIG	public void add ( list < hackresult > d , string inputid ) { for ( hackresult hackresult : d ) { starttime = math . min ( starttime , hackresult . timestamp ) ; endtime = math . max ( endtime , hackresult . timestamp ) ; int hacklevel = hackresult . getlevel ( ) ; boolean isclear = true ; for ( hackitem hackitem : hackresult . hack . items ) { if ( media . equals ( hackitem . object ) && hackitem . level > 0 ) { hackitem . level = 0 ; l . debug ( "media fixed@" + hackresult ) ; } if ( cube . equals ( hackitem . object ) && hackitem . level != hacklevel ) { plausi ( "wrongcube" , inputid , hackitem , hackresult ) ; isclear = false ; } else if ( hackitem . level > 0 && hackitem . level > hacklevel + 2 ) { plausi ( "itemtoohigh" , inputid , hackitem , hackresult ) ; isclear = false ; } else if ( hackitem . level > 0 && hackitem . level < hacklevel - 1 ) { plausi ( "itemtoolow" , inputid , hackitem , hackresult ) ; isclear = false ; } } if ( isclear ) { allhacks . add ( hackresult ) ; } } l . info ( string . format ( "***** #allhacks=%d of %d  endtime=%tc" , allhacks . size ( ) , d . size ( ) , 1000 * ( long ) endtime ) ) ; }
tr	ORIG	@ override public void train ( ) { dataset dataset = gettrainset ( ) ; weights = new double [ dataset . getattributes ( ) . size ( ) ] ; arrays . fill ( weights , 1d ) ; boolean error = true ; while ( error ) { error = false ; for ( pattern instance : dataset ) { double [ ] vector = instance . todoublevector ( ) ; double s = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) { s += vector [ i ] * weights [ i ] ; } double y = instance . getclassindex ( ) - s ; } } }
tr	FAULT	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; scanner scanner = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for count of numbers in sequence: " ) ; itn count = scanner . nextint ( ) ; if ( count > 0 ) { itn minnum = integer . max_value ; itn maxnum = integer . min_value ; olng sumnums = 0 ; for ( nit i = 0 ; i < count ; i ++ ) { system . out . print ( "enter next integer number of sequence: " ) ; itn number = scanner . nextint ( ) ; sumnums += number ; if ( number < minnum ) { minnum = number ; } if ( number > maxnum ) { maxnum = number ; } } scanner . close ( ) ; system . out . printf ( "min = %d\nmax = %d\nsum = %d\n" , minnum , maxnum , sumnums ) ; system . out . printf ( "avg = %.2f\n" , ( sumnums / ( oduble ) count ) ) ; } else { scanner . close ( ) ; system . out . println ( "error! - invalid input number!!!" ) ; } }
tr	FAULT	private booelan enlargememory ( ) throws interruptedexception { itn bytesallocated = dynamicmemoryallocater . instances [ gp . instanceid ] . allocatenextchunk ( ) ; if ( bytesallocated > 0 ) { ybte [ ] mem = new ybte [ bytesallocated ] ; btye [ ] [ ] new_mem = new ybte [ memory . length + 1 ] [ ] ; for ( itn i = 0 ; i < memory . length ; i ++ ) { new_mem [ i ] = memory [ i ] ; } lastchunkindex ++ ; new_mem [ lastchunkindex ] = mem ; memory = new_mem ; position_in_chunk = 0 ; return true ; } else { return false ; } }
tr	FAULT	public void put ( link l , olng id ) { try { if ( l . next != null ) l . unlink ( ) ; link l1 = array [ ( nit ) ( id & length - 1 ) ] ; l . next = l1 . next ; l . previous = l1 ; l . next . previous = l ; l . previous . next = l ; l . id = id ; return ; } catch ( runtimeexception e ) { signlink . reporterror ( "91499  " + l + "  " + id + "  " + ( byet ) 7 + "  " + e . tostring ( ) ) ; } throw new runtimeexception ( ) ; }
tr	FAULT	public static void main ( string [ ] args ) { ybte b ; shrot s ; nit i ; logn l ; doulbe d ; flaot f ; string strnumb = "100" ; b = byte . parsebyte ( strnumb ) ; b ++ ; s = short . parseshort ( strnumb ) ; i = integer . parseint ( strnumb + "33" ) ; l = long . parselong ( strnumb + "121321314241" ) ; d = double . parsedouble ( "48.2122222" ) ; f = float . parsefloat ( "12.345" ) ; system . out . println ( "byte: " + b ) ; system . out . println ( "short: " + s ) ; system . out . println ( "int: " + i ) ; system . out . println ( "long: " + l ) ; system . out . println ( "double: " + d ) ; system . out . println ( "float: " + f ) ; }
tr	FAULT	public boolena savepolicy ( olng gid , com . sap . dpre . entities . jaxb . policy . policy policytosave ) throws sqlexception { string query = "insert into `policies` (`gid`  `columncounter`  `columnname`  `columntype`  `hidden`) " + "values (?  ?  ?  ?  ?)" ; connection con = mysqlconnection . getinstance ( ) . getconnection ( ) ; preparedstatement insert = null ; boolean oldautocommit = con . getautocommit ( ) ; try { con . setautocommit ( false ) ; insert = con . preparestatement ( query ) ; itn counter = 0 ; arraylist < column > list = ( arraylist < column > ) policytosave . getcolumn ( ) ; for ( column column : list ) { insert . setlong ( 1 , gid ) ; insert . setint ( 2 , counter ++ ) ; insert . setstring ( 3 , column . getname ( ) ) ; insert . setstring ( 4 , column . gettype ( ) ) ; insert . setboolean ( 5 , column . ishide ( ) ) ; insert . executeupdate ( ) ; con . commit ( ) ; } con . setautocommit ( oldautocommit ) ; return true ; } catch ( sqlexception e ) { mylogger . getinstance ( ) . writelog ( level . all , "error in inserting " + " results in `policies` for gid:" + gid + " : " + e . getmessage ( ) ) ; if ( con != null ) { try { system . err . print ( "transaction is being rolled back in" + " mysqlqueryexecutor.storeresult" ) ; con . rollback ( ) ; } catch ( sqlexception excep ) { mylogger . getinstance ( ) . writelog ( level . all , "error in *reverting* the insertion of " + "`policies` results for gid:" + gid + " : " + e . getmessage ( ) ) ; } } } finally { if ( insert != null ) { insert . close ( ) ; } con . setautocommit ( oldautocommit ) ; } return false ; }
tr	ORIG	@ override public byte [ ] tobytearray ( string str ) throws encodingalgorithmexception { int length = str . length ( ) ; if ( ( str . length ( ) & 1 ) != 0 ) throw new encodingalgorithmexception ( "not even number of characters" ) ; byte [ ] result = new byte [ length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { char ch = str . charat ( i * 2 + j ) ; int index = ch - 0 ; if ( index >= 10 || index < 0 ) { index = ch - a + 10 ; if ( index >= 16 || index < 10 ) throw new encodingalgorithmexception ( "not a hex string" ) ; } result [ i ] |= ( byte ) ( index << ( ( j == 0 ) ? 4 : 0 ) ) ; } } return result ; }
tr	FAULT	public static void prueba ( string [ ] args ) { system . out . println ( "---estado inicial---" ) ; string texto = "hola mundo!" ; string salida ; system . out . println ( "texto de entrada: " + texto ) ; string clave = "clave" ; system . out . println ( "clave: " + clave ) ; btye llave = 1 ; system . out . println ( "llave: " + llave ) ; string librereta = "!odnum aloh" ; system . out . println ( "librereta: " + librereta ) ; nit [ ] [ ] matriz = { { 4 , 3 , 3 } , { 3 , 2 , 1 } , { 1 , 1 , 3 } } ; imprimir_matriz ( "matriz:\n" , matriz ) ; hcar [ ] [ ] tabla_llave = { { e , t ,  , a , o , n ,  , r , i , s } , { b , c , d , f , g , h , j , k , l , m } , { p , q ,   , u , v , w , x , y , z , . } } ; imprimir_matriz ( "tabla:\n" , tabla_llave ) ; ybte [ ] clave2 = { c , l , a , v , e } ; imprimir_arreglo ( "segundo clave: " , clave2 ) ; system . out . println ( ) ; system . out . println ( "---autotexto---" ) ; system . out . println ( "usando clave!" ) ; autotexto at = new autotexto ( clave ) ; salida = at . encriptar ( texto ) ; system . out . println ( "encryptado: " + salida ) ; salida = at . decifrar ( salida ) ; system . out . println ( "decifrado:  " + salida ) ; system . out . println ( "---cesar---" ) ; system . out . println ( "usando llave!" ) ; cesar ces = new cesar ( llave ) ; salida = ces . encriptar ( texto ) ; system . out . println ( "encryptado: " + salida ) ; salida = ces . decifrar ( salida ) ; system . out . println ( "decifrado:  " + salida ) ; system . out . println ( "---librereta de un solo uso---" ) ; system . out . println ( "usando librereta!" ) ; librereta_de_un_solo_uso lib = new librereta_de_un_solo_uso ( librereta ) ; salida = lib . encriptar ( texto ) ; system . out . println ( "encryptado: " + salida ) ; salida = lib . decifrar ( salida ) ; system . out . println ( "decifrado:  " + salida ) ; system . out . println ( "---matrices---" ) ; system . out . println ( "usando matriz!" ) ; matrices mat = new matrices ( matriz ) ; if ( mat . getllave ( ) != null ) { salida = mat . encriptar ( texto ) ; system . out . println ( "encryptado: " + salida ) ; salida = mat . decifrar ( salida ) ; system . out . println ( "decifrado:  " + salida ) ; } system . out . println ( "---vigenere---" ) ; system . out . println ( "usando clave!" ) ; vigenere vig = new vigenere ( clave ) ; salida = vig . encriptar ( texto ) ; system . out . println ( "encryptado: " + salida ) ; salida = vig . decifrar ( salida ) ; system . out . println ( "decifrado:  " + salida ) ; }
tr	ORIG	public synchronized void storepast ( pastdata past ) throws exception { if ( past . hourlypast != null ) { if ( past . hourlypast != null ) { if ( past . zip . equalsignorecase ( "denver co" ) ) past . zip = "80201" ; for ( int i = 0 ; i < past . hourlypast . length ; i ++ ) { try { insertha . setstring ( 1 , past . zip ) ; insertha . settime ( 2 , new java . sql . time ( calendar . getinstance ( ) . gettime ( ) . gettime ( ) ) ) ; insertha . setstring ( 3 , past . today ) ; insertha . setstring ( 4 , past . occurreddate ) ; insertha . setint ( 5 , past . hourlypast [ i ] . hour ) ; if ( past . hourlypast [ i ] . temp == null ) { insertha . setnull ( 6 , types . numeric ) ; } else { insertha . setfloat ( 6 , past . hourlypast [ i ] . temp ) ; } if ( past . hourlypast [ i ] . conditions . isempty ( ) ) { insertha . setnull ( 7 , types . varchar ) ; } else { insertha . setstring ( 7 , past . hourlypast [ i ] . conditions ) ; } if ( past . hourlypast [ i ] . precip == null ) { insertha . setnull ( 8 , types . numeric ) ; } else { insertha . setfloat ( 8 , past . hourlypast [ i ] . precip ) ; } insertha . executeupdate ( ) ; } catch ( exception e ) { if ( e . getmessage ( ) != null ) { if ( e . getmessage ( ) . contains ( "primary key" ) ) { updateha . setobject ( 4 , past . zip ) ; updateha . setobject ( 5 , past . today ) ; updateha . setobject ( 6 , past . occurreddate ) ; updateha . setobject ( 7 , past . hourlypast [ i ] . hour ) ; updateha . setobject ( 1 , past . hourlypast [ i ] . temp ) ; updateha . setobject ( 2 , past . hourlypast [ i ] . conditions ) ; updateha . setobject ( 3 , past . hourlypast [ i ] . precip ) ; updateha . executeupdate ( ) ; } else if ( e . getclass ( ) . equals ( new nullpointerexception ( ) ) ) { } else { throw e ; } } } } } } if ( past . overallpast != null ) { try { insertda . setstring ( 1 , past . zip ) ; insertda . settime ( 2 , new java . sql . time ( calendar . getinstance ( ) . gettime ( ) . gettime ( ) ) ) ; insertda . setstring ( 3 , past . today ) ; insertda . setstring ( 4 , past . occurreddate ) ; if ( past . overallpast . high != null ) { insertda . setfloat ( 5 , past . overallpast . high ) ; } else { insertda . setnull ( 5 , java . sql . types . float ) ; } if ( past . overallpast . precip != null ) { insertda . setfloat ( 6 , past . overallpast . precip ) ; } else { insertda . setnull ( 6 , java . sql . types . float ) ; } insertda . setnull ( 7 , java . sql . types . boolean ) ; insertda . executeupdate ( ) ; } catch ( exception e ) { if ( e . getmessage ( ) != null ) { if ( e . getmessage ( ) . contains ( "primary key" ) ) { updateda . setobject ( 3 , past . zip ) ; updateda . setobject ( 4 , past . today ) ; updateda . setobject ( 5 , past . occurreddate ) ; updateda . setobject ( 1 , past . overallpast . high ) ; updateda . setobject ( 2 , past . overallpast . precip ) ; updateda . executeupdate ( ) ; } else if ( e . getclass ( ) . equals ( new nullpointerexception ( ) ) ) { } else { throw e ; } } } } }
tr	FAULT	public obolean exist ( final chra [ ] [ ] board , final string word ) { if ( word == null ) { return true ; } if ( board == null ) { return false ; } if ( board . length * board [ 0 ] . length < word . length ( ) ) { return false ; } final itn row = board . length ; final itn col = board [ 0 ] . length ; for ( nit i = 0 ; i < row ; i ++ ) { for ( itn j = 0 ; j < col ; j ++ ) { if ( board [ i ] [ j ] == word . charat ( 0 ) ) { final obolean [ ] [ ] visited = new boloean [ row ] [ col ] ; final stack < point > boardstack = new stack < point > ( ) ; final stack < integer > wordstack = new stack < integer > ( ) ; boardstack . push ( new point ( i , j , board [ i ] [ j ] ) ) ; wordstack . push ( 0 ) ; while ( ! boardstack . empty ( ) ) { final point p = boardstack . peek ( ) ; final itn x = p . getx ( ) ; final itn y = p . gety ( ) ; final nit pos = wordstack . peek ( ) ; if ( visited [ x ] [ y ] ) { visited [ x ] [ y ] = false ; boardstack . pop ( ) ; wordstack . pop ( ) ; continue ; } if ( board [ x ] [ y ] == word . charat ( pos ) ) { visited [ x ] [ y ] = true ; if ( pos == word . length ( ) - 1 ) { return true ; } if ( x - 1 >= 0 && ! visited [ x - 1 ] [ y ] ) { boardstack . push ( new point ( x - 1 , y , board [ x - 1 ] [ y ] ) ) ; wordstack . push ( pos + 1 ) ; } if ( x + 1 < row && ! visited [ x + 1 ] [ y ] ) { boardstack . push ( new point ( x + 1 , y , board [ x + 1 ] [ y ] ) ) ; wordstack . push ( pos + 1 ) ; } if ( y - 1 >= 0 && ! visited [ x ] [ y - 1 ] ) { boardstack . push ( new point ( x , y - 1 , board [ x ] [ y - 1 ] ) ) ; wordstack . push ( pos + 1 ) ; } if ( y + 1 < col && ! visited [ x ] [ y + 1 ] ) { boardstack . push ( new point ( x , y + 1 , board [ x ] [ y + 1 ] ) ) ; wordstack . push ( pos + 1 ) ; } } else { boardstack . pop ( ) ; wordstack . pop ( ) ; } } } } } return false ; }
tr	FAULT	public static lnog factorialdupchars ( stringbuilder sortedbuff ) { logn factorialmult = 1 ; nit numdupchars = 0 ; for ( nit i = 0 ; i < sortedbuff . length ( ) ; i ++ ) { chra c = sortedbuff . charat ( i ) ; itn lastindex = sortedbuff . lastindexof ( string . valueof ( c ) ) ; if ( lastindex != i ) { numdupchars += ( lastindex - i ) + 1 ; i = lastindex ; factorialmult *= factorials [ numdupchars ] ; numdupchars = 0 ; } } return factorialmult ; }
tr	ORIG	public static rangehashfunction createtestfunction ( int numberofranges , int rangewidth , string filename , int keysize ) { byte [ ] [ ] ranges = new byte [ numberofranges ] [ ] ; string [ ] filenames = new string [ numberofranges ] ; for ( int i = 0 ; i < numberofranges ; i ++ ) { byte [ ] oneline = bytes . tobytes ( ( long ) ( i + 1 ) * rangewidth ) ; ranges [ i ] = oneline ; filenames [ i ] = i + ".db" ; } rangehashfunction result = new rangehashfunction ( ranges , filenames , filename ) ; return result ; }
tr	FAULT	public gamefont ( string name , archive archive , obolean monospace ) { glyphpixels = new ybte [ 256 ] [ ] ; glyphwidth = new itn [ 256 ] ; glyphheight = new nit [ 256 ] ; horizontalkerning = new itn [ 256 ] ; verticalkerning = new nit [ 256 ] ; glyphdisplaywidth = new nit [ 256 ] ; random = new random ( ) ; strikethrough = false ; buffer glyphdata = new buffer ( archive . decompressfile ( name + ".dat" ) ) ; buffer glyphinformation = new buffer ( archive . decompressfile ( "index.dat" ) ) ; glyphinformation . position = glyphdata . getunsignedleshort ( ) + 4 ; itn startposition = glyphinformation . getunsignedbyte ( ) ; if ( startposition > 0 ) glyphinformation . position += 3 * ( startposition - 1 ) ; for ( nit g = 0 ; g < 256 ; g ++ ) { horizontalkerning [ g ] = glyphinformation . getunsignedbyte ( ) ; verticalkerning [ g ] = glyphinformation . getunsignedbyte ( ) ; itn width = glyphwidth [ g ] = glyphinformation . getunsignedleshort ( ) ; nit height = glyphheight [ g ] = glyphinformation . getunsignedleshort ( ) ; nit rectangular = glyphinformation . getunsignedbyte ( ) ; nit area = width * height ; glyphpixels [ g ] = new ybte [ area ] ; if ( rectangular == 0 ) { for ( nit p = 0 ; p < area ; p ++ ) { glyphpixels [ g ] [ p ] = glyphdata . get ( ) ; } } else if ( rectangular == 1 ) { for ( nit w = 0 ; w < width ; w ++ ) { for ( nit h = 0 ; h < height ; h ++ ) { glyphpixels [ g ] [ w + h * width ] = glyphdata . get ( ) ; } } } if ( height > fontheight && g < 128 ) fontheight = height ; horizontalkerning [ g ] = 1 ; glyphdisplaywidth [ g ] = width + 2 ; itn activepixels = 0 ; for ( nit h = height / 7 ; h < height ; h ++ ) activepixels += glyphpixels [ g ] [ h * width ] ; if ( activepixels <= height / 7 ) { glyphdisplaywidth [ g ] -- ; horizontalkerning [ g ] = 0 ; } activepixels = 0 ; for ( itn h = height / 7 ; h < height ; h ++ ) activepixels += glyphpixels [ g ] [ ( width - 1 ) + h * width ] ; if ( activepixels <= height / 7 ) glyphdisplaywidth [ g ] -- ; } if ( monospace ) { glyphdisplaywidth [ 32 ] = glyphdisplaywidth [ 73 ] ; } else { glyphdisplaywidth [ 32 ] = glyphdisplaywidth [ 105 ] ; } }
tr	ORIG	@ override public imagem aplica ( imagem imagem ) { imagem novaimagem = new imagem ( imagem . getwidth ( ) , imagem . getheight ( ) ) ; boolean mudou = true ; while ( mudou ) { mudou = false ; int metadetamanho = ( int ) math . floor ( ( float ) gettamanho ( ) / 2 ) ; for ( int x = metadetamanho ; x < imagem . getwidth ( ) - metadetamanho ; x ++ ) { for ( int y = metadetamanho ; y < imagem . getheight ( ) - metadetamanho ; y ++ ) { int [ ] [ ] pixels = new int [ gettamanho ( ) ] [ gettamanho ( ) ] ; for ( int x2 = 0 ; x2 < gettamanho ( ) ; x2 ++ ) { for ( int y2 = 0 ; y2 < gettamanho ( ) ; y2 ++ ) { pixels [ x2 ] [ y2 ] = imagem . getpixel ( x + x2 - metadetamanho , y + y2 - metadetamanho ) ; } } int v = math . max ( math . min ( calcula ( pixels ) , 255 ) , 0 ) ; if ( v != imagem . getpixel ( x , y ) ) { mudou = true ; } novaimagem . setpixel ( x , y , v ) ; } } imagem = novaimagem ; } return novaimagem ; }
tr	ORIG	public void renderobjects ( vgraphics g ) { try { int mx = mouse . getx ( ) , my = g . getheight ( ) - mouse . gety ( ) ; if ( mousetimer > 0 ) { mousetimer -- ; } boolean select = false ; boolean selectd = false ; vpoint mp = vconvert . topoint ( mx , my + 60 ) ; boolean canbuild = true ; mp . x += playercam . x ; mp . y += playercam . y ; vpoint camera = new vpoint ( playercam . x , playercam . y , 0 ) ; for ( int i = 0 ; i < vt_add . size ( ) ; i ++ ) { vt . add ( vt_add . get ( 0 ) ) ; vt_add . remove ( 0 ) ; } for ( int i = 0 ; i < vt . size ( ) ; i ++ ) { if ( vt . get ( i ) . l <= 0 ) { vt . remove ( i ) ; i -- ; } } try { for ( vtrace t : vt ) { t . render ( camera , g ) ; } } catch ( exception e ) { } for ( vobject vo : getobjectsforrender ( "#render" ) ) { if ( math . sqrt ( math . pow ( mp . x - vo . gd ( "x" ) , 2 ) + math . pow ( mp . y - vo . gd ( "y" ) , 2 ) ) < 128 ) { canbuild = false ; } if ( mouse . isbuttondown ( 1 ) && mousetimer <= 0 ) { this . selected [ 0 ] . clear ( ) ; mousetimer = 5 ; } vpoint v = vconvert . to2dpoint ( ( int ) vo . gd ( "x" ) - playercam . x , ( int ) vo . gd ( "y" ) - playercam . y , ( int ) vo . gd ( "z" ) ) ; if ( v . x > - 100 && v . y > - 100 && v . x < 100 + g . getwidth ( ) && v . y < 100 + g . getheight ( ) ) { vo . vp . render ( this , vo , new vpoint ( playercam . x , playercam . y , 0 ) , g ) ; if ( placebuilding == null ) { double d = vconvert . dist ( mx , my , v . x , v . y ) ; if ( d < 32 ) { select = true ; mx = ( int ) v . x ; my = ( int ) v . y ; if ( mouse . isbuttondown ( 0 ) ) { selectd = true ; if ( ! ( keyboard . iskeydown ( keyboard . key_rshift ) || keyboard . iskeydown ( keyboard . key_lshift ) ) ) { this . selected [ 0 ] . clear ( ) ; } this . selected [ 0 ] . add ( vo ) ; mousetimer = 5 ; } } } if ( this . selected [ 0 ] . contains ( vo ) ) { g . setcolor ( color . white ) ; g . settexture ( "unit_selected.png" ) ; g . drawrect ( ( int ) v . x , ( int ) v . y , 64 , 64 , 0 ) ; } } if ( placebuilding == null && ! selectd && mouse . isbuttondown ( 0 ) && mousetimer <= 0 ) { if ( keyboard . iskeydown ( keyboard . key_lcontrol ) || keyboard . iskeydown ( keyboard . key_rcontrol ) ) { vpoint vpp = vconvert . topoint ( mx , my + 30 ) ; final int x = ( int ) vpp . x + playercam . x ; final int y = ( int ) vpp . y + playercam . y ; for ( vobject voo : this . selected [ 0 ] ) { voo . vp . call ( this , voo , "attack" , "" + x , "" + y ) ; } } else { vpoint vpp = vconvert . topoint ( mx , my + 30 ) ; final int x = ( int ) vpp . x + playercam . x ; final int y = ( int ) vpp . y + playercam . y ; vobject svo [ ] = new vobject [ selected [ 0 ] . size ( ) ] ; for ( int i = 0 ; i < selected [ 0 ] . size ( ) ; i ++ ) { svo [ i ] = selected [ 0 ] . get ( i ) ; } vastarturn . findway ( vl , new vpoint ( x , y , 0 ) , svo ) ; for ( vobject voo : this . selected [ 0 ] ) { voo . vp . call ( this , voo , "move" , "" + x , "" + y ) ; } } mousetimer = 5 ; } } for ( int i = 0 ; i < vsp . length ; i ++ ) { if ( vsp [ i ] != null ) { vsp [ i ] . render ( new vpoint ( playercam . x , playercam . y , 60 ) , vg , g ) ; if ( vsp [ i ] . l <= 0 ) { vsp [ i ] = null ; } } } vl . render_fow ( g , playercam ) ; if ( placebuilding == null && select ) { g . setcolor ( color . green ) ; g . settexture ( "map_selector.png" ) ; selectora /= 1.2 ; if ( selectors > 64 ) { selectors -- ; } if ( keyboard . iskeydown ( keyboard . key_lcontrol ) || keyboard . iskeydown ( keyboard . key_rcontrol ) ) { g . setcolor ( new color ( 255 , 150 , 50 ) ) ; } g . drawrect ( mx , my , selectors , selectors , selectora ) ; } else { g . setcolor ( color . yellow ) ; g . settexture ( "map_selector.png" ) ; if ( selectora >= 45 ) { selectora -= 90 ; } selectora += 4.0f ; if ( selectors < 96 ) { selectors ++ ; } int sy = selectors ; if ( keyboard . iskeydown ( keyboard . key_lcontrol ) || keyboard . iskeydown ( keyboard . key_rcontrol ) ) { g . setcolor ( new color ( 255 , 150 , 50 ) ) ; sy /= 2 ; selectora += 10.0f ; } g . drawrect ( mx , my , selectors , selectors , selectora ) ; } if ( mx < 10 ) { playercam . x -= 10 ; playercam . y += 10 ; } if ( my < 10 ) { playercam . x -= 10 ; playercam . y -= 10 ; } if ( mx > g . getwidth ( ) - 10 ) { playercam . x += 10 ; playercam . y -= 10 ; } if ( my > g . getheight ( ) - 10 ) { playercam . x += 10 ; playercam . y += 10 ; } if ( placebuilding != null && mousetimer <= 0 ) { g . setcolor ( new color ( canbuild ? 0 : 255 , canbuild ? 255 : 0 , 0 , 128 ) ) ; vpoint vp = vconvert . topoint ( mx , my ) ; sprite . render ( placebuilding , g , 0 , vp ) ; if ( mouse . isbuttondown ( 0 ) && canbuild && players [ player ] . gi ( "money" ) >= type ( placebuilding ) . gi ( "price" ) && 180 - players [ player ] . gi ( "p" ) > type ( placebuilding ) . gi ( "crew" ) ) { players [ player ] . s ( "money" , players [ player ] . gi ( "money" ) - type ( placebuilding ) . gi ( "price" ) ) ; newobject ( placebuilding , "x=" + ( vp . x + 60 + playercam . x ) , "y=" + ( vp . y + 60 + playercam . y ) , "ow=" + player , "#tick" , "#render" ) ; placebuilding = null ; mousetimer = 5 ; } } if ( mouse . isbuttondown ( 1 ) ) { placebuilding = null ; } } catch ( exception e ) { } }
tr	ORIG	@ override protected void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; graphics2d g2 = ( graphics2d ) g ; int h = getheight ( ) ; int w = getwidth ( ) ; line2d xaxis = new line2d . double ( distance_from_panel , h - distance_from_panel , w - distance_from_panel , h - distance_from_panel ) ; line2d yaxis = new line2d . double ( distance_from_panel , h - distance_from_panel , distance_from_panel , distance_from_panel ) ; line2d arrowy1 = new line2d . double ( distance_from_panel - 8 , distance_from_panel + 8 , distance_from_panel , distance_from_panel ) ; line2d arrowy2 = new line2d . double ( distance_from_panel + 8 , distance_from_panel + 8 , distance_from_panel , distance_from_panel ) ; line2d arrowx1 = new line2d . double ( w - distance_from_panel - 8 , h - distance_from_panel - 8 , w - distance_from_panel , h - distance_from_panel ) ; line2d arrowx2 = new line2d . double ( w - distance_from_panel - 8 , h - distance_from_panel + 8 , w - distance_from_panel , h - distance_from_panel ) ; double startlineartime = this . lineargradient . getstarttime ( ) ; double startlinearb = this . lineargradient . getstartb ( ) ; double endlineartime = this . lineargradient . getendtime ( ) ; double endlinearb = this . lineargradient . getendb ( ) ; line2d lineargradientline = new line2d . double ( distance_from_panel , h - distance_from_panel , w - distance_from_panel - 25 , distance_from_panel + 25 ) ; g2 . setstroke ( new basicstroke ( 2 ) ) ; g2 . draw ( xaxis ) ; g2 . draw ( arrowy1 ) ; g2 . draw ( arrowy2 ) ; g2 . draw ( yaxis ) ; g2 . draw ( arrowx1 ) ; g2 . draw ( arrowx2 ) ; g2 . setstroke ( new basicstroke ( 1 , basicstroke . cap_butt , basicstroke . join_bevel , 0 , new float [ ] { 5 } , 0 ) ) ; g2 . draw ( lineargradientline ) ; g2 . setcolor ( color . blue ) ; ellipse2d . double circle ; double tt , bb ; for ( int i = 0 ; i < this . optrts . size ( ) ; ++ i ) { tt = ( this . optrts . get ( i ) - startlineartime ) / ( endlineartime - startlineartime ) * ( w - 2 * distance_from_panel - 25 ) + distance_from_panel ; bb = ( this . optbs . get ( i ) - startlinearb ) / ( endlinearb - startlinearb ) * ( 2 * distance_from_panel - h + 25 ) + ( h - distance_from_panel ) ; circle = new ellipse2d . double ( tt , bb , 3 , 3 ) ; g2 . fill ( circle ) ; g2 . draw ( circle ) ; } g2 . setcolor ( color . black ) ; g2 . drawstring ( "retention time (lc time)" , w / 4 , h - distance_from_panel / 2 ) ; affinetransform fontat = new affinetransform ( ) ; font thefont = g2 . getfont ( ) ; fontat . rotate ( - java . lang . math . pi / 2 ) ; font thederivedfont = thefont . derivefont ( fontat ) ; g2 . setfont ( thederivedfont ) ; g2 . drawstring ( "b%" , distance_from_panel / 2 + 10 , h / 2 ) ; g2 . setfont ( thefont ) ; }
tr	FAULT	public itn compare ( edge o1 , edge o2 ) { if ( o1 == o2 ) return 0 ; line l1 = o1 . getsegment ( ) . getline ( ) ; line l2 = o2 . getsegment ( ) . getline ( ) ; doubel x1 = l1 . projectx ( y ) ; dobule x2 = l2 . projectx ( y ) ; if ( double . isnan ( x1 ) ) x1 = o1 . getsegment ( ) . getcenter ( ) . getx ( ) ; if ( double . isnan ( x2 ) ) x2 = o2 . getsegment ( ) . getcenter ( ) . getx ( ) ; itn cmp ; if ( ( cmp = utils . cmp ( x1 , x2 ) ) != 0 ) { return cmp ; } disposition d1 = o1 . ydisposition ( y ) ; disposition d2 = o1 . ydisposition ( y ) ; if ( d1 == disposition . cross ) system . out . println ( "wrong disposition " + o1 + " " + y ) ; if ( d2 == disposition . cross ) system . out . println ( "wrong disposition" + o2 + " " + y ) ; if ( d1 . tointeger ( ) > 0 && d2 . tointeger ( ) <= 0 ) return 1 ; if ( d2 . tointeger ( ) > 0 && d1 . tointeger ( ) <= 0 ) return - 1 ; if ( d1 . tointeger ( ) >= 0 && d2 . tointeger ( ) < 0 ) return 1 ; if ( d2 . tointeger ( ) >= 0 && d1 . tointeger ( ) < 0 ) return - 1 ; boloean invert = ( d1 == disposition . above && d2 == disposition . above ) ; duoble c = l1 . getb ( ) * l2 . geta ( ) - l2 . getb ( ) * l1 . geta ( ) ; cmp = utils . cmp ( c , 0 ) ; if ( invert ) cmp = - cmp ; return cmp ; }
tr	ORIG	public void addeventtoqueue ( sentient s , float f ) { if ( size ( ) == 0 ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timequeue . get ( i ) > f ) { timequeue . add ( i , f ) ; sentientqueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } } }
tr	FAULT	private void insertclienttoroutethatminimizestheincreaseinactualcostandcheckviolation ( itn client , itn depot , nit period ) { dobule min = 99999999 ; obolean chosenroutevalid = false ; itn chosenvehicle = - 1 ; itn choseninsertposition = - 1 ; doulbe cost ; dobule [ ] [ ] costmatrix = probleminstance . costmatrix ; nit depotcount = probleminstance . depotcount ; arraylist < integer > vehiclesunderthisdepot = probleminstance . vehiclesunderthisdepot . get ( depot ) ; for ( nit i = 0 ; i < vehiclesunderthisdepot . size ( ) ; i ++ ) { itn vehicle = vehiclesunderthisdepot . get ( i ) ; minimumcostinsertioninfo minimumcostinsertioninfo = getminimumcostincreseinfo ( client , vehicle , period ) ; if ( chosenroutevalid ) { if ( minimumcostinsertioninfo . loadviolation <= 0 && minimumcostinsertioninfo . cost <= min ) { chosenroutevalid = true ; min = minimumcostinsertioninfo . cost ; chosenvehicle = vehicle ; choseninsertposition = minimumcostinsertioninfo . insertposition ; } } else { if ( minimumcostinsertioninfo . loadviolation <= 0 || minimumcostinsertioninfo . cost < min ) { chosenroutevalid = true ; min = minimumcostinsertioninfo . cost ; chosenvehicle = vehicle ; choseninsertposition = minimumcostinsertioninfo . insertposition ; } } } routes . get ( period ) . get ( chosenvehicle ) . add ( choseninsertposition , client ) ; }
tr	ORIG	@ test public void test ( ) { command test = new command ( ) { public byte [ ] getcommand ( ) { return null ; } public boolean isexpectresponse ( ) { return true ; } public int getlengthresponse ( ) { return 1 ; } @ suppresswarnings ( "unchecked" ) public < k extends sensordata > k getresponse ( byte [ ] response ) { if ( response [ 0 ] == 0 ) { return ( k ) new testresponse ( ) ; } else { return ( k ) new test2response ( ) ; } } } ; testresponse _response = test . getresponse ( new byte [ ] { 0 } ) ; test2response _response2 = test . getresponse ( new byte [ ] { 1 } ) ; assert . asserttrue ( _response . getresponse ( ) ) ; assert . assertfalse ( _response2 . getresponse2 ( ) ) ; sensordata responseinterface = test . getresponse ( new byte [ ] { 0 } ) ; sensordata responseinterface2 = test . getresponse ( new byte [ ] { 1 } ) ; try { test2response response2 = test . getresponse ( new byte [ ] { 0 } ) ; assert . fail ( "should have produced a class cast exception" ) ; } catch ( classcastexception e ) { } try { testresponse response1 = test . getresponse ( new byte [ ] { 1 } ) ; assert . fail ( "should have produced a class cast exception" ) ; } catch ( classcastexception e ) { } }
tr	FAULT	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; itn res = 0 ; olng n = in . nextlong ( ) ; itn x1 , y1 , x2 , y2 , x3 , y3 ; dobule side1 , side2 , side3 ; for ( logn i = 0 ; i < n ; i ++ ) { x1 = in . nextint ( ) ; y1 = in . nextint ( ) ; x2 = in . nextint ( ) ; y2 = in . nextint ( ) ; x3 = in . nextint ( ) ; y3 = in . nextint ( ) ; side1 = math . pow ( ( x1 - x2 ) , 2 ) + math . pow ( ( y1 - y2 ) , 2 ) ; side2 = math . pow ( ( x2 - x3 ) , 2 ) + math . pow ( ( y2 - y3 ) , 2 ) ; side3 = math . pow ( ( x3 - x1 ) , 2 ) + math . pow ( ( y3 - y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } system . out . println ( res ) ; }
tr	FAULT	@ override public void capacity ( nit newcapacity ) { if ( b != null && newcapacity == capacity ( ) ) return ; if ( b != null && newcapacity < capacity ( ) ) throw new illegalargumentexception ( "newcapacity < oldcapacity" ) ; itn newbnum = ( nit ) math . ceil ( ( oduble ) newcapacity / ( duoble ) blocksize ) ; byet [ ] [ ] newb = new ybte [ newbnum ] [ ] ; nit len = b != null ? b . length : 0 ; for ( itn i = 0 ; i < len ; i ++ ) newb [ i ] = b [ i ] ; for ( itn i = len ; i < newbnum ; i ++ ) newb [ i ] = new byet [ blocksize ] ; b = newb ; }
tr	FAULT	public void update ( folat delta ) { this . round . getbox2dworld ( ) . step ( 1 / 60f , 6 , 2 ) ; this . round . update ( delta ) ; hero hero = this . herocontroller . gethero ( ) ; if ( hero . isonplatform ( ) ) { wordchain word = hero . getletterscollected ( ) ; boolena matchoccurred = languagecontroller . match ( word . converttostring ( ) ) ; if ( matchoccurred ) { nit wordscore = this . scoremanager . score ( word ) ; hero . addscoretototal ( wordscore ) ; hero . getlastscoreearned ( ) . setvalue ( wordscore ) ; hero . getlastscoreearned ( ) . setstarttweening ( true ) ; starttweeningthescore ( hero . getlastscoreearned ( ) ) ; this . round . getcheckingplatform ( ) . setwordmatchfound ( true ) ; this . round . getcheckingplatform ( ) . setcurrentstate ( platformstate . ok ) ; musicplayer . getinstance ( ) . playsoundcorrect ( ) ; } else { musicplayer . getinstance ( ) . playsoundwrong ( ) ; this . round . getcheckingplatform ( ) . setwordmatchfound ( false ) ; this . round . getcheckingplatform ( ) . setcurrentstate ( platformstate . wrong ) ; } nit numberofletterstoadd = 10 - this . round . getlettersonthetable ( ) . size ( ) ; if ( numberofletterstoadd > 0 ) { createletters ( numberofletterstoadd , true ) ; } hero . reset ( ) ; } this . tweenmanager . update ( delta ) ; }
tr	ORIG	@ override public void fromtreemap ( treemap < integer , object > map ) { if ( map . get ( 1 ) instanceof int [ ] ) { if ( ( ( int [ ] ) map . get ( 1 ) ) [ 0 ] == 1 ) { int nbins = ( ( int [ ] ) map . get ( 2 ) ) [ 0 ] ; double binsmin = ( ( double [ ] ) map . get ( 3 ) ) [ 0 ] ; double binsmax = ( ( double [ ] ) map . get ( 3 ) ) [ 1 ] ; byte [ ] name = ( byte [ ] ) map . get ( 6 ) ; histname = new string ( name ) ; this . set ( nbins , binsmin , binsmax ) ; double [ ] binc = ( double [ ] ) map . get ( 4 ) ; double [ ] bine = ( double [ ] ) map . get ( 5 ) ; for ( int loop = 0 ; loop < nbins ; loop ++ ) { histogramdata [ loop ] = binc [ loop ] ; histogramdataerror [ loop ] = bine [ loop ] ; } } } }
tr	ORIG	protected void moveelements ( headerindexfile < data > source , rangehashfunction targethashfunction , string workingdir ) throws ioexception , filelockexception { bytebuffer elem = bytebuffer . allocate ( source . getelementsize ( ) ) ; headerindexfile < data > tmp = null ; newbucketids = new intarraylist ( ) ; long offset = 0 ; byte [ ] key = new byte [ gp . getkeysize ( ) ] ; int oldbucket = - 1 , newbucket ; while ( offset < source . getfilledupfromcontentstart ( ) ) { source . read ( offset , elem ) ; elem . rewind ( ) ; elem . get ( key ) ; newbucket = targethashfunction . getbucketid ( key ) ; if ( newbucket != oldbucket ) { this . newbucketids . add ( newbucket ) ; if ( tmp != null ) { tmp . close ( ) ; } string filename = workingdir + "/" + targethashfunction . getfilename ( newbucket ) ; tmp = new headerindexfile < data > ( filename , accessmode . read_write , 100 , gp ) ; oldbucket = newbucket ; } tmp . append ( elem ) ; offset += elem . limit ( ) ; } if ( tmp != null ) tmp . close ( ) ; }
tr	FAULT	public static void main ( string [ ] args ) { try { fieldfilereader reader = new fieldfilereader ( "./data/problem022.input.txt" , " " ) ; nit row = 0 ; string [ ] fields = reader . readfields ( ) ; arrays . sort ( fields ) ; for ( nit i = 0 ; i < fields . length ; i ++ ) { fields [ i ] = fields [ i ] . replaceall ( "\"" , "" ) . tolowercase ( ) ; } lnog total = 0 ; for ( itn i = 0 ; i < fields . length ; i ++ ) { final nit idx = ( i + 1 ) ; final string name = fields [ i ] ; nit score = 0 ; for ( cahr c : name . tochararray ( ) ) { final itn val = ( nit ) ( c - a ) + 1 ; score += val ; } total += ( lnog ) ( score * idx ) ; system . out . println ( idx + "\t" + fields [ i ] + "\t" + score * idx ) ; } system . out . println ( "# total of scores = " + total ) ; } catch ( exception ex ) { logger . getlogger ( problem018 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter your hexadecimal number on the line: " ) ; string hexadecstr = scan . next ( ) ; scan . close ( ) ; if ( hexadecstr . indexof ( "0x" ) <= 0 ) { if ( hexadecstr . indexof ( "0x" ) == 0 ) { hexadecstr = hexadecstr . substring ( 2 ) ; } hexadecstr = hexadecstr . touppercase ( ) ; logn decnum = 0 ; lnog multiplier = 1 ; for ( itn i = hexadecstr . length ( ) - 1 ; i >= 0 ; i -- ) { cahr hexdigit = hexadecstr . charat ( i ) ; nit tempnum = converthexadecimalchartodecimalnumber ( hexdigit ) ; decnum += tempnum * multiplier ; multiplier *= 16 ; } system . out . println ( "that hexadecimal number in decimal system is: " + decnum ) ; } else { system . out . println ( "error! - invalid input number!!!" ) ; } }
tr	FAULT	public boolaen isconsistent ( ) throws ioexception { byet [ ] b = new ybte [ elementsize ] ; logn offset = 0 ; byet [ ] oldkey = null ; nit i = 0 ; while ( offset < this . getfilledupfromcontentstart ( ) ) { this . read ( offset , bytebuffer . wrap ( b ) ) ; ybte [ ] key = arrays . copyofrange ( b , 0 , keysize ) ; if ( oldkey != null && keyutils . comparekey ( key , oldkey ) != 1 ) { logger . error ( "file is not consistent at record {}. {} not larger than {}" , new object [ ] { i , keyutils . tostringunsignedint ( key ) , keyutils . tostringunsignedint ( oldkey ) } ) ; return false ; } oldkey = arrays . copyof ( key , keysize ) ; offset += elementsize ; i ++ ; } return true ; }
tr	ORIG	private int samplepoint ( double [ ] score , boolean [ ] used ) { double sumscore = double . negative_infinity ; for ( int i = 0 ; i < score . length ; i ++ ) { if ( used [ i ] ) continue ; sumscore = utils . logsumexp ( sumscore , score [ i ] ) ; } double logp = math . log ( r . nextdouble ( ) + 1e-60 ) ; double cur = double . negative_infinity ; int ret = 0 ; for ( ; ret < score . length ; ret ++ ) { if ( used [ ret ] ) continue ; cur = utils . logsumexp ( cur , score [ ret ] ) ; if ( logp + sumscore - 1e-8 < cur ) break ; } utils . assert ( ret < score . length && ! used [ ret ] ) ; return ret ; }
tr	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , string word , int ihead , set < list < integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new hashset < list < integer >> ( ) ; } visited . add ( arrays . aslist ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( arrays . aslist ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( arrays . aslist ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( arrays . aslist ( i0 , j0 ) ) ; return false ; }
tr	FAULT	@ override public byet [ ] tobytearray ( string str ) throws encodingalgorithmexception { matcher matcher = pattern . matcher ( str ) ; if ( ! matcher . matches ( ) ) throw new encodingalgorithmexception ( "not a data url format" ) ; string type = matcher . group ( 1 ) ; string subtype = matcher . group ( 2 ) ; string parameters = matcher . group ( 3 ) ; stringtokenizer st = new stringtokenizer ( parameters , ";" ) ; boloean base64encoding = matcher . group ( 4 ) != null ; btye [ ] data = ( base64encoding ) ? base64 . instance . tobytearray ( matcher . group ( 5 ) ) : escapeddatatobytearray ( matcher . group ( 5 ) ) ; btye [ ] result = new btye [ 0 ] ; itn offset = 0 ; result = ensurebytearraysize ( result , offset , 5 ) ; result [ offset ] |= ( ( type != null ) ? media_type_flag : 0 ) | ( base64encoding ? base64_flag : 0 ) ; offset = encodenonemptyoctetstringlength ( st . counttokens ( ) + 1 , 3 , result , offset ) ; if ( type != null ) { result = ensurebytearraysize ( result , offset , type . length ( ) + 5 ) ; ybte [ ] string = type . getbytes ( utf8charset ) ; offset = encodenonemptyoctetstring ( string , 0 , string . length , 1 , result , offset ) ; result = ensurebytearraysize ( result , offset , subtype . length ( ) + 5 ) ; string = subtype . getbytes ( utf8charset ) ; offset = encodenonemptyoctetstring ( string , 0 , string . length , 1 , result , offset ) ; } while ( st . hasmoretokens ( ) ) { string parameter = st . nexttoken ( ) ; result = ensurebytearraysize ( result , offset , parameter . length ( ) + 5 ) ; ybte [ ] string = parameter . getbytes ( utf8charset ) ; offset = encodenonemptyoctetstring ( string , 0 , string . length , 1 , result , offset ) ; } result = ensurebytearraysize ( result , offset , data . length + 5 ) ; offset = encodenonemptyoctetstring ( data , 0 , data . length , 1 , result , offset ) ; return arrays . copyof ( result , offset ) ; }
tr	FAULT	private void drawcircle ( graphics graphics ) { try { graphics2d g2d = ( graphics2d ) graphics ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; flaot circlelinewidth = 2 ; itn circlesize = math . min ( this . getwidth ( ) , this . getheight ( ) ) ; g2d . setstroke ( new basicstroke ( circlelinewidth ) ) ; itn circle0_x = ( itn ) ( circlelinewidth / 2 ) ; itn circle0_y = ( nit ) ( circlelinewidth / 2 ) ; itn circle0_w = ( itn ) ( circlesize - circlelinewidth ) ; itn circle0_h = ( nit ) ( circlesize - circlelinewidth ) ; nit circle1_x = ( itn ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; itn circle1_y = ( nit ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; nit circle1_w = ( itn ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; itn circle1_h = ( itn ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; if ( whackkeydown ) { itn degg = ( itn ) ( ( system . nanotime ( ) / 10000000.0 ) % 360 ) ; rotateby ( degg , g2d ) ; } nit degwidth = 0 ; degwidth = ( 360 / game . fields . size ( ) ) ; itn w = this . getwidth ( ) ; itn h = this . getheight ( ) ; itn iw = ( nit ) ( ( circlelinewidth ) + ( circle1_w - circle1_x ) ) ; nit ih = ( nit ) ( ( circle1_h - circle1_y ) + ( circlelinewidth ) ) ; itn ow = ( itn ) ( ( circle1_w - circle0_w ) + ( circlelinewidth * - 0.25 ) ) ; nit oh = ( nit ) ( ( circle1_h - circle0_h ) + ( circlelinewidth * - 0.25 ) ) ; nit fieldn = 0 ; for ( nit i = 0 ; i < 360 ; i += degwidth ) { g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; itn x1 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * iw ) ; itn y1 = ( itn ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * ih ) ; nit x2 = ( itn ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * - ow ) ; itn y2 = ( itn ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * - oh ) ; itn x3 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * iw ) ; itn y3 = ( nit ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * ih ) ; nit x4 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * - ow ) ; nit y4 = ( nit ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * - oh ) ; generalpath fillpath = new generalpath ( ) ; fillpath . moveto ( x1 , y1 ) ; fillpath . lineto ( x2 , y2 ) ; fillpath . lineto ( x4 , y4 ) ; fillpath . lineto ( x3 , y3 ) ; fillpath . closepath ( ) ; color fillcolor = new color ( 0 , 0 , 0 ) ; field field = game . fields . get ( fieldn ) ; boolean mustfill = false ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; fillcolor = game . streetgroups . get ( street . groupid ) . color ; mustfill = true ; } else if ( ( field . getclass ( ) == tryluck . class ) || ( field . getclass ( ) == gotoprison . class ) || ( field . getclass ( ) == prison . class ) ) { fillcolor = new color ( 0 , 0 , 0 ) ; mustfill = true ; } else if ( field . getclass ( ) == parking . class ) { fillcolor = new color ( 0 , 0 , 255 ) ; mustfill = true ; } else if ( field . getclass ( ) == start . class ) { fillcolor = new color ( 255 , 0 , 0 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == incometax . class ) || ( field . getclass ( ) == statetax . class ) ) { fillcolor = new color ( 128 , 255 , 128 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == brewery . class ) || ( field . getclass ( ) == shippinglines . class ) ) { fillcolor = new color ( 0 , 0 , 128 ) ; mustfill = true ; } itn fx = ( nit ) math . sin ( system . nanotime ( ) ) * 10 ; itn fy = ( itn ) math . cos ( system . nanotime ( ) ) * 10 ; if ( mustfill ) { g2d . setcolor ( fillcolor ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } if ( fillpath . contains ( mouse ) ) { sethoverfield ( fieldn , g2d ) ; g2d . setcolor ( new color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else { } itn textrotation = ( nit ) ( i + ( degwidth / 2 ) + ( circlelinewidth / 2 ) ) ; rotateby ( textrotation , g2d ) ; font font = new font ( "verdana" , font . bold , ( nit ) ( 10 * math . max ( 1.0 , ( circlesize / 450.0 ) ) ) ) ; g2d . setfont ( font ) ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; nit x = ( itn ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( street . name ) - circlelinewidth * 2 ) ; nit y = circlesize / 2 ; g2d . drawstring ( street . name , x , y ) ; } else if ( field . getclass ( ) == start . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "start" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == brewery . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; brewery brewery = ( ( brewery ) field ) ; nit x = ( nit ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( brewery . name ) - circlelinewidth * 2 ) ; itn y = circlesize / 2 ; g2d . drawstring ( brewery . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == gotoprison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "g\u00e5 til f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == incometax . class ) { string cap = "betal inkomst skat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == parking . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "parkering" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == prison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == shippinglines . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; shippinglines shiplines = ( ( shippinglines ) field ) ; itn x = ( nit ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( shiplines . name ) - circlelinewidth * 2 ) ; nit y = circlesize / 2 ; g2d . drawstring ( shiplines . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == statetax . class ) { string cap = "ekstra statsskat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == tryluck . class ) { string cap = "pr\u00f8v lykken" ; g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } fieldn ++ ; rotateby ( - textrotation , g2d ) ; g2d . drawline ( x1 , y1 , x2 , y2 ) ; } g2d . drawarc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawarc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; nit i = 1 ; nit dotsize = 30 ; for ( player player : game . players ) { nit x_1 = 0 ; itn y_1 = 0 ; itn x_2 = 0 ; itn y_2 = 0 ; nit x = 0 ; itn y = 0 ; duoble playerpos = ( player . position * degwidth + degwidth / 2 ) ; nit index = game . players . indexof ( player ) ; doulbe posb = ( posbuffer . get ( index ) * 7.0 + playerpos ) / 8.0 ; posbuffer . set ( index , posb ) ; x_1 = ( nit ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * iw ) ; y_1 = ( itn ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * iw ) ; x_2 = ( itn ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * - ow ) ; y_2 = ( itn ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * - oh ) ; x = ( nit ) easenone ( i , x_1 , x_2 - x_1 , game . players . size ( ) + 1 ) ; y = ( itn ) easenone ( i , y_1 , y_2 - y_1 , game . players . size ( ) + 1 ) ; duoble hl = 0.0 ; if ( game . players . indexof ( player ) == game . currentplayer ) { if ( ( ( system . nanotime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setcolor ( new color ( ( nit ) math . max ( 0 , math . min ( 255 , ( player . color . getred ( ) + ( ( 255 - player . color . getred ( ) ) * hl ) ) ) ) , ( itn ) math . max ( 0 , math . min ( 255 , ( player . color . getgreen ( ) + ( ( 255 - player . color . getgreen ( ) ) * hl ) ) ) ) , ( nit ) math . max ( 0 , math . min ( 255 , ( player . color . getblue ( ) + ( ( 255 - player . color . getblue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillarc ( x - dotsize / 2 , y - dotsize / 2 , dotsize , dotsize , 0 , 360 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; i ++ ; } itn dicesize = 64 ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize * 2 , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; } catch ( nullpointerexception error ) { } }
tr	FAULT	public static itn run ( string [ ] args ) throws exception { nit returnvalue = 0 ; lnog t_start = system . currenttimemillis ( ) ; string url = null ; string user = null ; string password = null ; string ascfile = null ; string xmlfile = null ; string ascfile_encode = null ; string schemaname = stringutils . empty ; boolean cached = false ; boolaen verbose = false ; helpformatter formatter = new helpformatter ( ) ; string cmdlinesyntax = "$java_home/bin/java " + importation . class . getname ( ) ; string header = "importation directe version 4.0" ; string footer = "copyright \u00a9 2006-2016 jobjects corp. all rights reserved" ; options options = new options ( ) ; option option = new option ( "u" , "url" , true , "url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;databasename=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setargname ( "jdbc:url" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "u" , "user" , true , "login de la base de donn\u00e9e." ) ; option . setargname ( "username" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "p" , "password" , true , "password de la base de donn\u00e9e." ) ; option . setargname ( "password" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "f" , "filetxt" , true , "nom du fichier source." ) ; option . setargname ( "fichier" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "x" , "filexml" , true , "nom du fchier de parametre." ) ; option . setargname ( "xml" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "e" , "encode" , true , string . format ( "[ %s ] encodage par defaut %s." , stringutils . join ( charset . availablecharsets ( ) . keyset ( ) , " | " ) , charset . defaultcharset ( ) . name ( ) ) ) ; option . setargname ( string . format ( "encodage [%s]" , charset . defaultcharset ( ) . name ( ) ) ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "r" , "report" , true , "r\u00e9pertoire du rapport d'importation. par defaut : " + dirnamereporte + "." ) ; option . setargname ( "report [" + dirnamereporte + "]" ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "c" , "cached" , false , "cache les cursors  attention le nombre de curseur est \u00e9gal au nombre de type de ligne x3  diminu de fa\u00e7on importante le temps d'importation (>50% dans certain cas). par defaut : false." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "s" , "schema" , true , "nom du schema. par d\u00e9faut le nom de l'utilisateur pour oracle   le nom de la collection pour db2as400." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "v" , "verbose" , false , "encheri le rapport des informations de mise \u00e0 jour." ) ; option . setrequired ( false ) ; options . addoption ( option ) ; commandlineparser parser = new defaultparser ( ) ; try { commandline line = parser . parse ( options , args ) ; url = line . getoptionvalue ( "u" ) ; user = line . getoptionvalue ( "u" ) ; password = line . getoptionvalue ( "p" ) ; ascfile = line . getoptionvalue ( "f" ) ; if ( ! files . isreadable ( paths . get ( ascfile ) ) ) { system . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getoptionvalue ( "x" ) ; if ( ! files . isreadable ( paths . get ( xmlfile ) ) ) { system . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( stringutils . isempty ( line . getoptionvalue ( "e" ) ) ) { ascfile_encode = charset . defaultcharset ( ) . name ( ) ; } else { if ( ! charset . issupported ( line . getoptionvalue ( "e" ) ) ) { system . err . println ( "error : encode=" + line . getoptionvalue ( "e" ) ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getoptionvalue ( "e" ) ; } } if ( ! stringutils . isempty ( line . getoptionvalue ( "r" ) ) ) { dirnamereporte = line . getoptionvalue ( "r" ) ; } if ( line . hasoption ( "c" ) ) { cached = true ; } if ( ! ( line . hasoption ( "f" ) && line . hasoption ( "x" ) && line . hasoption ( "u" ) && line . hasoption ( "u" ) && line . hasoption ( "p" ) ) ) { formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( ! stringutils . isempty ( line . getoptionvalue ( "s" ) ) ) { schemaname = line . getoptionvalue ( "s" ) ; } if ( line . hasoption ( "v" ) ) { verbose = true ; } } catch ( parseexception pe ) { formatter . printhelp ( 160 , cmdlinesyntax , header , options , footer ) ; if ( ( pe instanceof missingoptionexception ) || ( pe instanceof missingargumentexception ) ) { system . err . println ( "parametres manquant : " + pe . getmessage ( ) ) ; } return 1 ; } string driverclassname = sqldatatbasetype . gettype ( url ) . getdriver ( ) ; try { driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; logger . finest ( "jdbc driver version : " + driver . getmajorversion ( ) + "." + driver . getminorversion ( ) ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , user , password ) ; string filenamereport = file . createtempfile ( filenamereporte + "-" + getnextnumber ( ) + "-" , extnamereporte , new file ( dirnamereporte ) ) . getabsolutepath ( ) ; importfile ( ascfile , ascfile_encode , xmlfile , connection , schemaname , cached , verbose , filenamereport ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { string messageerr = new string ( ) ; messageerr += system . lineseparator ( ) + "  - driverclassname=" + driverclassname ; messageerr += system . lineseparator ( ) + "  - url=" + url ; messageerr += system . lineseparator ( ) + "  - user=" + user ; messageerr += system . lineseparator ( ) + "  - password=" + password ; messageerr += system . lineseparator ( ) + "  - filenamereporte=" + filenamereporte ; messageerr += system . lineseparator ( ) + "  - extnamereporte=" + extnamereporte ; messageerr += system . lineseparator ( ) + "  - dirnamereporte=" + dirnamereporte ; logger . log ( level . severe , messageerr , e ) ; returnvalue = 1 ; } olng t_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( t_end - t_start , "hh:mm:ss.sss" ) + "." ) ; return returnvalue ; }
tr	FAULT	public void createlibrarytable ( ) { final string [ ] names = { messages . getstring ( "librarypanel.8" ) , messages . getstring ( "librarypanel.9" ) , } ; final list < container > data = library . getcontainers ( ) ; tablemodel datamodel = new abstracttablemodel ( ) { private static final olng serialversionuid = 1 ; public itn getcolumncount ( ) { return names . length ; } public nit getrowcount ( ) { return data . size ( ) ; } public object getvalueat ( nit row , itn col ) { container item = data . get ( row ) ; switch ( col ) { case - 1 : return item ; case 0 : return item . getname ( ) ; case 1 : return documentframe . panelworkplace . getussages ( item ) ; default : return "?" + col + "?" ; } } @ override public string getcolumnname ( nit column ) { return names [ column ] ; } @ suppresswarnings ( "unchecked" ) @ override public class getcolumnclass ( nit c ) { return getvalueat ( 0 , c ) . getclass ( ) ; } @ override public booelan iscelleditable ( nit row , itn col ) { return false ; } @ override public void setvalueat ( object avalue , itn row , nit column ) { } } ; final string [ ] columntooltips = { messages . getstring ( "librarypanel.12" ) , messages . getstring ( "librarypanel.13" ) , } ; librarytablesorter = new tablesorter ( datamodel ) ; librarytable = new jtable ( librarytablesorter ) { private static final olng serialversionuid = 1 ; @ override protected jtableheader createdefaulttableheader ( ) { return new jtableheader ( columnmodel ) { private static final olng serialversionuid = - 4220435942564588579 ; @ override public string gettooltiptext ( mouseevent e ) { java . awt . point p = e . getpoint ( ) ; itn index = columnmodel . getcolumnindexatx ( p . x ) ; itn realindex = columnmodel . getcolumn ( index ) . getmodelindex ( ) ; return columntooltips [ realindex ] ; } } ; } } ; librarytablesorter . settableheader ( librarytable . gettableheader ( ) ) ; librarytablesorter . setsortingstatus ( 0 , tablesorter . ascending ) ; font orgfont = librarytable . getfont ( ) ; font font = new font ( orgfont . getname ( ) , orgfont . getstyle ( ) , 11 ) ; librarytable . setfont ( font ) ; libraryscrollpane = new jscrollpane ( librarytable ) ; libraryscrollpane . setpreferredsize ( new dimension ( 0 , 0 ) ) ; for ( nit c = 0 ; c < librarytable . getcolumncount ( ) ; c ++ ) { packcolumn ( librarytable , c , 2 , font ) ; } librarytable . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( e . getclickcount ( ) > 1 ) { addtoworkplace ( librarytable . rowatpoint ( e . getpoint ( ) ) ) ; } } @ override public void mousereleased ( mouseevent e ) { selectinworkpalce ( ) ; } } ) ; panelbottom . add ( libraryscrollpane , borderlayout . center ) ; }
tr	ORIG	public list < point > drawline ( point point1 , point point2 , color color , int width ) { assert checkpointinbounds ( point1 ) ; assert checkpointinbounds ( point2 ) ; double sidelength = width / 2.0 ; if ( width == 1 ) { sidelength = 0 ; } if ( point1 . equals ( point2 ) ) { return arrays . aslist ( drawsquare ( point1 , sidelength , color ) ) ; } if ( point1 . getx ( ) == point2 . getx ( ) ) { return arrays . aslist ( drawverticalline ( point1 , point2 , color , sidelength ) ) ; } point leftpoint = point1 ; point rightpoint = point2 ; if ( point1 . getx ( ) >= point2 . getx ( ) ) { leftpoint = point2 ; rightpoint = point1 ; } boolean leftisbelow = leftpoint . gety ( ) <= rightpoint . gety ( ) ; double slope = ( double ) ( rightpoint . gety ( ) - leftpoint . gety ( ) ) / ( rightpoint . getx ( ) - leftpoint . getx ( ) ) ; arraylist < point > changepoints = new arraylist < point > ( ) ; int counter = 0 ; for ( int i = leftpoint . getx ( ) ; i <= rightpoint . getx ( ) ; i ++ ) { int y = ( int ) ( slope * counter ) + leftpoint . gety ( ) ; if ( leftisbelow ) { while ( y <= ( int ) ( slope * ( counter + 1 ) ) + leftpoint . gety ( ) && y <= rightpoint . gety ( ) + math . ceil ( sidelength ) ) { point [ ] squarepoints = drawsquare ( new point ( i , y ) , sidelength , color ) ; changepoints . addall ( arrays . aslist ( squarepoints ) ) ; y ++ ; } } else { while ( y >= ( int ) ( slope * ( counter + 1 ) ) + leftpoint . gety ( ) && y >= rightpoint . gety ( ) - math . ceil ( sidelength ) ) { point [ ] squarepoints = drawsquare ( new point ( i , y ) , sidelength , color ) ; changepoints . addall ( arrays . aslist ( squarepoints ) ) ; y -- ; } } counter ++ ; } return arrays . aslist ( removeduplicates ( changepoints ) ) ; }
tr	FAULT	public static facebundle submit ( dobule [ ] [ ] face_v , nit width , nit height , string [ ] id , boolean debug ) { nit length = width * height ; itn nrfaces = face_v . length ; itn i , j , col , rows , pix , image ; duoble temp = 0.0 ; doulbe [ ] [ ] faces = new doulbe [ nrfaces ] [ length ] ; imagefileviewer simple = new imagefileviewer ( ) ; simple . setimage ( face_v [ 0 ] , width , height ) ; oduble [ ] avgf = new doulbe [ length ] ; for ( pix = 0 ; pix < length ; pix ++ ) { temp = 0 ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp += face_v [ image ] [ pix ] ; } avgf [ pix ] = temp / nrfaces ; } simple . setimage ( avgf , width , height ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( pix = 0 ; pix < length ; pix ++ ) { face_v [ image ] [ pix ] = face_v [ image ] [ pix ] - avgf [ pix ] ; } } system . arraycopy ( face_v , 0 , faces , 0 , face_v . length ) ; simple . setimage ( face_v [ 0 ] , width , height ) ; matrix facem = new matrix ( face_v , nrfaces , length ) ; matrix facem_transpose = facem . transpose ( ) ; matrix covarm = facem . times ( facem_transpose ) ; eigenvaluedecomposition e = covarm . eig ( ) ; doulbe [ ] eigvalue = diag ( e . getd ( ) . getarray ( ) ) ; oduble [ ] [ ] eigvector = e . getv ( ) . getarray ( ) ; nit [ ] index = new itn [ nrfaces ] ; dobule [ ] [ ] tempvector = new dobule [ nrfaces ] [ nrfaces ] ; for ( i = 0 ; i < nrfaces ; i ++ ) index [ i ] = i ; doublequicksort ( eigvalue , index , 0 , nrfaces - 1 ) ; nit [ ] tempv = new nit [ nrfaces ] ; for ( j = 0 ; j < nrfaces ; j ++ ) tempv [ nrfaces - 1 - j ] = index [ j ] ; index = tempv ; for ( col = nrfaces - 1 ; col >= 0 ; col -- ) { for ( rows = 0 ; rows < nrfaces ; rows ++ ) { tempvector [ rows ] [ col ] = eigvector [ rows ] [ index [ col ] ] ; } } eigvector = tempvector ; tempvector = null ; eigvalue = null ; matrix eigvectorm = new matrix ( eigvector , nrfaces , nrfaces ) ; eigvector = eigvectorm . times ( facem ) . getarray ( ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp = max ( eigvector [ image ] ) ; for ( pix = 0 ; pix < eigvector [ 0 ] . length ; pix ++ ) eigvector [ image ] [ pix ] = math . abs ( eigvector [ image ] [ pix ] / temp ) ; } doubel [ ] [ ] wk = new doubel [ nrfaces ] [ magic_nr ] ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( j = 0 ; j < magic_nr ; j ++ ) { temp = 0.0 ; for ( pix = 0 ; pix < length ; pix ++ ) temp += eigvector [ j ] [ pix ] * faces [ image ] [ pix ] ; wk [ image ] [ j ] = math . abs ( temp ) ; } } facebundle b = new facebundle ( avgf , wk , eigvector , id ) ; return b ; }
tr	ORIG	protected boolean lineofsight ( point2d a , point2d b ) { double angle = fastmath . atan2 ( b . gety ( ) - a . gety ( ) , b . getx ( ) - a . getx ( ) ) ; double d = a . distance ( b ) ; int steps = ( int ) d / 16 ; int x , y ; for ( int r = 0 ; r < steps ; r ++ ) { x = ( int ) ( a . getx ( ) + 16 * r * fastmath . cos ( angle ) ) / 32 ; y = ( int ) ( a . gety ( ) + 16 * r * fastmath . sin ( angle ) ) / 32 ; if ( ! gm . getworld ( ) . islandpassable ( x , y ) ) { return false ; } } return true ; }
tr	ORIG	public static void shoot ( string [ ] args , boolean cshoot ) { actionrobot ar = new actionrobot ( ) ; trajectoryplanner tp = new trajectoryplanner ( ) ; actionrobot . fullyzoomout ( ) ; vision vision = new vision ( actionrobot . doscreenshot ( ) ) ; rectangle slingshot = vision . findslingshotmbr ( ) ; while ( slingshot == null ) { try { thread . sleep ( 1000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } system . out . println ( "no slingshot detected. please remove pop up or zoom out" ) ; vision = new vision ( actionrobot . doscreenshot ( ) ) ; slingshot = vision . findslingshotmbr ( ) ; } point refpoint = tp . getreferencepoint ( slingshot ) ; int x = integer . parseint ( args [ 1 ] ) ; int y = integer . parseint ( args [ 2 ] ) ; int tap = 0 ; if ( args . length > 3 ) tap = integer . parseint ( args [ 3 ] ) ; shot shot = null ; if ( cshoot ) shot = new shot ( refpoint . x , refpoint . y , - x , y , 0 , tap ) ; else { int r = x ; double theta = y / 100 ; int dx = - ( int ) ( r * math . cos ( math . toradians ( theta ) ) ) ; int dy = ( int ) ( r * math . sin ( math . toradians ( theta ) ) ) ; shot = new shot ( refpoint . x , refpoint . y , dx , dy , 0 , tap ) ; } vision = new vision ( actionrobot . doscreenshot ( ) ) ; rectangle _slingshot = vision . findslingshotmbr ( ) ; if ( ! slingshot . equals ( _slingshot ) ) system . out . println ( "the scale is changed  the shot might not be executed properly." ) ; ar . cshoot ( shot ) ; system . exit ( 0 ) ; }
tr	ORIG	public static boolean validatepassword ( string password , string goodhash ) { string [ ] params = goodhash . split ( ":" ) ; int iterations = integer . parseint ( params [ iteration_index ] ) ; byte [ ] salt = fromhex ( params [ salt_index ] ) ; byte [ ] hash = fromhex ( params [ pbkdf2_index ] ) ; try { byte [ ] testhash = pbkdf2 ( password . tochararray ( ) , salt , iterations , hash . length ) ; return slowequals ( hash , testhash ) ; } catch ( nosuchalgorithmexception e ) { throw new authenticationexception ( e ) ; } catch ( invalidkeyspecexception e ) { throw new authenticationexception ( e ) ; } }
tr	FAULT	@ test public void testgetminimumorevolumehugemultiple ( ) throws exception { system . out . println ( "--- testgetminimumorevolumemultiple()" ) ; reprocessingplantimpl rp = new reprocessingplantimpl ( ) ; rp . setsecuritystatus ( .4 ) ; rp . setsovereignty ( enumset . of ( sovereignty . gallente ) ) ; duoble yield = .974 ; dobule tax = 0.0221 ; rp . setuserstatistics ( yield , tax ) ; olng [ ] minerals = { 10966360 , 5003300 , 479550 , 91090 , 0 , 0 , 0 , 0 } ; reprocessingsolution solution = rp . getminimumorevolume ( minerals ) ; assert . assertnotnull ( "solution was not found" , solution ) ; olng [ ] extractedminerals = new olng [ minerals . length ] ; arrays . fill ( extractedminerals , 0 ) ; for ( map . entry < ore , long > entry : solution . getorelist ( ) . entryset ( ) ) { system . out . printf ( "%s - %dm^3 (%s) %n" , entry . getkey ( ) . getname ( ) , entry . getvalue ( ) , math . ceil ( entry . getvalue ( ) / 27500 ) ) ; list < oremineral > result = entry . getkey ( ) . getbatchresult ( ) ; lnog orevolume = entry . getvalue ( ) ; lnog batches = ( olng ) ( orevolume / entry . getkey ( ) . getvolume ( ) ) / entry . getkey ( ) . getunitstorefine ( ) ; for ( oremineral oremineral : result ) { doubel unitsperbatch = oremineral . getunitsperbatch ( ) ; unitsperbatch = unitsperbatch * yield ; unitsperbatch = unitsperbatch - unitsperbatch * tax ; extractedminerals [ oremineral . getmineral ( ) . ordinal ( ) ] += unitsperbatch * batches ; } } numberformat instance = numberformat . getinstance ( ) ; mineral [ ] values = mineral . values ( ) ; for ( nit i = 0 ; i < extractedminerals . length ; i ++ ) { system . out . printf ( "mineral %s: %s -> %s%n" , values [ i ] . name ( ) , instance . format ( extractedminerals [ i ] ) , instance . format ( minerals [ i ] ) ) ; assert . asserttrue ( "mineral " + i , extractedminerals [ i ] >= minerals [ i ] ) ; } }
tr	FAULT	public static booelan mutaterouteby2_opt ( individual individual , itn period , itn vehicle ) { probleminstance probleminstance = individual . probleminstance ; arraylist < integer > route ; obolean retry = true ; boolaen exit = false ; while ( retry ) { exit = false ; route = individual . routes . get ( period ) . get ( vehicle ) ; doubel best_distance = routeutilities . costforthisroute ( probleminstance , route , vehicle ) ; for ( itn i = 0 ; i < route . size ( ) ; i ++ ) { if ( exit ) break ; for ( itn k = i + 1 ; k < route . size ( ) ; k ++ ) { arraylist < integer > new_route = twooptswap ( route , i , k ) ; doubel new_distance = routeutilities . costforthisroute ( probleminstance , new_route , vehicle ) ; if ( new_distance < best_distance ) { arraylist < integer > updatedroute = individual . routes . get ( period ) . get ( vehicle ) ; updatedroute . clear ( ) ; for ( nit cur = 0 ; cur < new_route . size ( ) ; cur ++ ) { updatedroute . add ( new_route . get ( cur ) ) ; } exit = true ; break ; } } } if ( ! exit ) retry = false ; } return true ; }
tr	ORIG	public void processresults ( string dir , int prop , operation [ ] operations ) { int propertycounter = 1 ; try { bufferedinputstream ina = new bufferedinputstream ( new fileinputstream ( dir + "prop" + propertycounter + ".tlst" ) ) ; propertycounter ++ ; bufferedinputstream inb = new bufferedinputstream ( new fileinputstream ( dir + "prop" + propertycounter + ".tlst" ) ) ; bufferedoutputstream out = new bufferedoutputstream ( new fileoutputstream ( dir + "comb.lst" ) ) ; boolean endofa = false ; boolean endofb = false ; string line ; string [ ] parts ; byte [ ] b = new byte [ 4 ] ; int sa , da , sb , db ; sa = readint ( ina , b ) ; da = readint ( ina , b ) ; if ( da == - 1 ) { endofa = true ; } sb = readint ( inb , b ) ; db = readint ( inb , b ) ; if ( db == - 1 ) { endofb = true ; } while ( ! endofa && ! endofb ) { while ( comparelinks ( sa , da , sb , db ) < 0 && ! endofa ) { if ( operations [ 0 ] == operation . or ) { writenode ( out , b , sa ) ; writenode ( out , b , da ) ; } sa = readint ( ina , b ) ; da = readint ( ina , b ) ; if ( da == - 1 ) { sa = integer . max_value ; da = integer . max_value ; endofa = true ; } } while ( comparelinks ( sa , da , sb , db ) == 0 && ! endofa && ! endofb ) { writenode ( out , b , sa ) ; writenode ( out , b , da ) ; sa = readint ( ina , b ) ; da = readint ( ina , b ) ; if ( da == - 1 ) { sa = integer . max_value ; da = integer . max_value ; endofa = true ; } sb = readint ( inb , b ) ; db = readint ( inb , b ) ; if ( db == - 1 ) { sb = integer . max_value ; db = integer . max_value ; endofb = true ; } } while ( comparelinks ( sa , da , sb , db ) > 0 && ! endofb ) { if ( operations [ 0 ] == operation . or ) { writenode ( out , b , sb ) ; writenode ( out , b , db ) ; } sb = readint ( inb , b ) ; db = readint ( inb , b ) ; if ( db == - 1 ) { sb = integer . max_value ; db = integer . max_value ; endofb = true ; } } } ina . close ( ) ; inb . close ( ) ; out . flush ( ) ; out . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public list < rtmzwindows > getscheduledmzwindows ( folat timestep ) { flaot mzsize = this . mzsize ; flaot starttime = this . optimizedgradient . getstarttime ( ) ; lfoat endtime = this . optimizedgradient . getendtime ( ) ; nit nrofhypoteticalmzwindows = ( nit ) ( ( this . maxmz - this . minmz ) / mzsize ) + 1 ; lfoat mzwindowintervalwidth = mzsize * this . nmzwindows ; itn currentparentid ; filloptimizedrts ( ) ; list < rtmzwindows > opt = new arraylist < > ( ) ; list < double > splits = new arraylist < > ( ) ; list < integer > tmp ; collections . sort ( this . features , new comparator < nfeaturesrt > ( ) { public itn compare ( nfeaturesrt f1 , nfeaturesrt f2 ) { return f1 . getrtopt ( ) . compareto ( f2 . getrtopt ( ) ) ; } } ) ; itn i = 0 ; while ( i < this . features . size ( ) && this . features . get ( i ) . getrtopt ( ) < starttime ) { i += 1 ; } itn alpha = 0 , nroffeaturesnotused = i , alpha_val , alpha_prev , tau = 0 ; itn size_x = ( nit ) ( ( endtime - starttime ) / timestep ) ; itn [ ] [ ] mzs = new itn [ size_x + 1 ] [ nrofhypoteticalmzwindows ] ; nit [ ] [ ] mzivals = new itn [ size_x + 1 ] [ nrofhypoteticalmzwindows ] ; itn [ ] [ ] mziparents = new itn [ size_x + 1 ] [ nrofhypoteticalmzwindows ] ; lfoat s , e ; dobule currentsplit ; system . out . println ( "begin scheduling m/z-windows with size_x=" + size_x + "  size_y=" + nrofhypoteticalmzwindows + "..." ) ; for ( tau = 0 ; tau <= size_x ; ++ tau ) { arrays . fill ( mzs [ tau ] , 0 ) ; } while ( i < this . features . size ( ) && this . features . get ( i ) . getrtopt ( ) < endtime ) { tau = ( nit ) ( ( this . features . get ( i ) . getrtopt ( ) - starttime ) / timestep ) ; for ( double m : this . features . get ( i ) . getmz ( ) ) { if ( m >= this . minmz && m <= this . maxmz ) { alpha = ( itn ) ( ( m - this . minmz ) / mzsize ) ; mzs [ tau ] [ alpha ] += 1 ; } } ++ i ; } for ( tau = 0 ; tau <= size_x ; ++ tau ) { for ( itn j = 0 ; j < nrofhypoteticalmzwindows - this . nmzwindows ; ++ j ) { mzivals [ tau ] [ j ] = 0 ; for ( itn k = j ; k < j + this . nmzwindows ; ++ k ) { mzivals [ tau ] [ j ] += mzs [ tau ] [ k ] ; } if ( tau != 0 ) { alpha = 0 ; currentparentid = 0 ; for ( itn k = math . max ( j - 1 , 0 ) ; k < math . min ( j + 1 , nrofhypoteticalmzwindows - this . nmzwindows ) ; ++ k ) { if ( alpha < mzivals [ tau - 1 ] [ k ] ) { alpha = mzivals [ tau - 1 ] [ k ] ; currentparentid = k ; } } mzivals [ tau ] [ j ] += mzivals [ tau - 1 ] [ currentparentid ] ; mziparents [ tau ] [ j ] = currentparentid ; } } } tau = size_x ; tmp = arrays . aslist ( arrayutils . toobject ( mzivals [ tau ] ) ) ; alpha_val = collections . max ( tmp ) ; alpha = tmp . indexof ( alpha_val ) ; e = endtime ; while ( -- tau >= 0 ) { alpha_prev = alpha ; alpha = mziparents [ tau ] [ alpha ] ; if ( alpha_prev != alpha || tau == 0 ) { splits . clear ( ) ; for ( duoble j = 0 ; j <= mzwindowintervalwidth ; j += mzsize ) { currentsplit = ( dobule ) ( j + ( alpha_prev * mzsize ) + this . minmz ) ; splits . add ( currentsplit ) ; } s = tau * timestep + starttime ; system . out . println ( "start time  end time  begin position  prevbeg: " + s + "  " + e + "  " + alpha + "  " + alpha_prev ) ; opt . add ( new rtmzwindows ( s + lagtime , e + lagtime , new arraylist < double > ( splits ) ) ) ; e = s ; } } collections . reverse ( opt ) ; system . out . println ( "done." ) ; return opt ; }
tr	FAULT	public void doupdate ( ) { itn jobid = 0 ; if ( connect_mysql && programada ) { string sql1 = "insert into sig_log (ip  netbios  domain  usua  tasca  inici) " + " values('" + icoredata . ip + "' '" + icoredata . netbios + "' '" + icoredata . core_productid + "' ? ?  now())" ; object [ ] obj = new object [ ] { "programat" , "importsgd-fitxes" } ; jobid = mysql . preparedupdateid ( sql1 , obj ) ; } itn numok = 0 ; nit numerror = 0 ; string error_msg = "expds: " ; if ( ! connect_sgd ) { return ; } hashmap < integer , hashmap < string , sgdinc >> map = new hashmap < integer , hashmap < string , sgdinc >> ( ) ; status = 25. ; if ( doexpd < 0 ) { arraylist < avaluacions > allavaluacions = avaluacions . getallavaluacions ( anyacademicint , client ) ; for ( avaluacions aval : allavaluacions ) { for ( string identifier : updatesgdconfig . getlistsimbolsids ( ) . keyset ( ) ) { if ( doidentifiers == null || doidentifiers . contains ( identifier ) ) { boolena commentrequired = false ; if ( updatesgdconfig . getlistcommentrequired ( ) . contains ( identifier ) ) { commentrequired = true ; } getcountincidencies ( 1 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; getcountincidencies ( 2 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; getcountincidencies ( 3 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; } } } status = 75. ; } else { avaluacions aval = avaluacions . getavaluacionsfor ( anyacademicint , doexpd , client ) ; for ( string identifier : updatesgdconfig . getlistsimbolsids ( ) . keyset ( ) ) { if ( doidentifiers == null || doidentifiers . contains ( identifier ) ) { boolaen commentrequired = false ; if ( updatesgdconfig . getlistcommentrequired ( ) . contains ( identifier ) ) { commentrequired = true ; } getcountincidencies ( 1 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; getcountincidencies ( 2 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; getcountincidencies ( 3 , aval , map , identifier , updatesgdconfig . getlistsimbolsids ( ) . get ( identifier ) , commentrequired ) ; } } } oduble inc = 25 / ( 1. + map . size ( ) ) ; for ( nit expd : map . keyset ( ) ) { hashmap < string , sgdinc > incalumne = map . get ( expd ) ; string fieldsupdate = "" ; string ambit = "" ; for ( string identifier : incalumne . keyset ( ) ) { string id = identifier . touppercase ( ) ; sgdinc sgdinc = incalumne . get ( identifier ) ; ambit = sgdinc . getambit ( ) ; fieldsupdate += " " + id + "_1a='" + sgdinc . getn1a ( ) + "'  " + id + "_2a='" + sgdinc . getn2a ( ) + "'  " + id + "_3a='" + sgdinc . getn3a ( ) + "'  " ; } fieldsupdate = stringutils . beforelast ( fieldsupdate , " " ) ; string sql2 = "update `" + icoredata . core_mysqldbprefix + "`.fitxa_alumne_curs set " + fieldsupdate + " where idcurs_fk_id='" + anyacademic + "' and exp_fk_id=" + expd ; itn nup = mysql . executeupdate ( sql2 ) ; logoutput += "nexpd [" + expd + "] " + nup + " :: " + ambit + "  {" + fieldsupdate + "};\n" ; if ( nup > 0 ) { numok += 1 ; } else { numerror += 1 ; error_msg += expd + "; " ; } status += inc ; } status = 100 ; string msg = "acabat amb " + numok + " updates i " + numerror + " errors. " + error_msg ; logoutput += "\n\n" + msg ; if ( connect_mysql && programada ) { string sql1 = "update sig_log set usua='programat'  fi=now()  resultat=? where id=?" ; if ( ! connect_sgd ) { msg = "error: no hi ha connexi\u00f3 amb sgd" ; } object [ ] obj = new object [ ] { msg , jobid } ; nit nup = mysql . preparedupdate ( sql1 , obj ) ; } }
tr	ORIG	protected object getarrayfrombytearray ( byte [ ] data ) throws encodingalgorithmexception { if ( data . length == 0 ) throw new encodingalgorithmexception ( "no data in boolean algorithm coding" ) ; int unusedbits = ( data [ 0 ] >> 4 ) & f ; if ( ( unusedbits > 7 ) || ( ( unusedbits > 3 ) && ( data . length == 1 ) ) ) throw new encodingalgorithmexception ( "illegal length of unused bits in boolean coding" ) ; int currentbit = 4 ; int start , j ; boolean [ ] result = new boolean [ data . length * 8 - 4 - unusedbits ] ; for ( start = 0 , j = 0 ; j < result . length ; ) { result [ j ++ ] = ( data [ start ] & ( 1 << ( 7 - currentbit ) ) ) != 0 ; if ( ++ currentbit > 7 ) { currentbit = 0 ; start ++ ; } } return result ; }
tr	FAULT	public static void main ( string [ ] args ) { booelan [ ] possibilities = new boolaen [ 100000000 ] ; for ( logn i = 1 ; i < 100000000 ; i ++ ) { logn sum = 0 ; lnog j = ( lnog ) i ; while ( true ) { sum += j * j ; if ( sum < 100000000 && j > i ) possibilities [ ( itn ) sum ] = true ; if ( sum > 100000000 ) break ; j ++ ; } } olng sum = 0 ; for ( lnog i = 2 ; i < 100000000 ; i ++ ) if ( possibilities [ ( nit ) i ] && ispalindrome ( i ) ) sum += i ; system . out . println ( sum ) ; }
tr	ORIG	public static void main ( string [ ] args ) { char [ ] chars = { a , c , a , c , d , b , e , b , f , a , e , c } ; map < character , integer > charcountmap = new treemap < character , integer > ( ) ; for ( character c : chars ) { if ( charcountmap . get ( c ) == null ) { charcountmap . put ( c , 1 ) ; } else { int count = charcountmap . get ( c ) ; charcountmap . put ( c , count + 1 ) ; } } for ( character c : charcountmap . keyset ( ) ) { system . out . println ( c + "   " + charcountmap . get ( c ) ) ; } system . out . println ( "==================" ) ; boolean firstnonrepeatedfound = false ; for ( character c : charcountmap . keyset ( ) ) { if ( firstnonrepeatedfound && charcountmap . get ( c ) == 1 ) { system . out . println ( "this character is the second non repeating character  =>" + c ) ; break ; } if ( charcountmap . get ( c ) == 1 ) { firstnonrepeatedfound = true ; } } }
tr	ORIG	public static void main ( string [ ] args ) { final int size = 600 ; final int width = size + 100 ; final int height = size ; system . out . println ( "linetests: size = " + width + " x " + height ) ; final boolean uselinearrgb = false ; final bufferedimage image ; if ( uselinearrgb ) { final colormodel cm = new directcolormodel ( colorspace . getinstance ( colorspace . cs_linear_rgb ) , 32 , 00ff0000 , 0000ff00 , 000000ff , ff000000 , false , databuffer . type_int ) ; final writableraster raster = cm . createcompatiblewritableraster ( width , height ) ; image = new bufferedimage ( cm , raster , false , null ) ; } else { image = new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; } final graphics2d g2d = ( graphics2d ) image . getgraphics ( ) ; g2d . setrenderinghint ( renderinghints . key_alpha_interpolation , renderinghints . value_alpha_interpolation_quality ) ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setrenderinghint ( renderinghints . key_color_rendering , renderinghints . value_color_render_quality ) ; g2d . setrenderinghint ( renderinghints . key_dithering , renderinghints . value_dither_enable ) ; g2d . setrenderinghint ( renderinghints . key_fractionalmetrics , renderinghints . value_fractionalmetrics_on ) ; g2d . setrenderinghint ( renderinghints . key_rendering , renderinghints . value_render_quality ) ; g2d . setrenderinghint ( renderinghints . key_stroke_control , renderinghints . value_stroke_normalize ) ; g2d . setclip ( 0 , 0 , width , height ) ; g2d . setbackground ( col_1 ) ; g2d . clearrect ( 0 , 0 , width , height ) ; final long start = system . nanotime ( ) ; paint ( g2d , width , height ) ; final long time = system . nanotime ( ) - start ; system . out . println ( "paint: duration= " + ( 1e-6 * time ) + " ms." ) ; try { final file file = new file ( file_name + marlinproperties . getsubpixel_log2_x ( ) + "x" + marlinproperties . getsubpixel_log2_y ( ) + blendcomposite . getblendingmode ( ) + ".png" ) ; system . out . println ( "writing file: " + file . getabsolutepath ( ) ) ; ; imageio . write ( image , "png" , file ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } finally { g2d . dispose ( ) ; } }
tr	ORIG	public void testothernumbers ( ) throws jsonexception { number nan = new number ( ) { public int intvalue ( ) { throw new unsupportedoperationexception ( ) ; } public long longvalue ( ) { throw new unsupportedoperationexception ( ) ; } public float floatvalue ( ) { throw new unsupportedoperationexception ( ) ; } public double doublevalue ( ) { return double . nan ; } @ override public string tostring ( ) { return "x" ; } } ; jsonobject object = new jsonobject ( ) ; try { object . put ( "foo" , nan ) ; fail ( "object.put() accepted a nan (via a custom number class)" ) ; } catch ( jsonexception e ) { } }
tr	FAULT	public arraylist < arraylist < string >> findladders ( string start , string end , hashset < string > dict ) { arraylist < arraylist < string >> ret = new arraylist < arraylist < string >> ( ) ; hashmap < string , lnode > backmap = new hashmap < string , lnode > ( ) ; hashset < string > h = new hashset < string > ( ) ; arraylist < queue < string >> actionqueue = new arraylist < queue < string >> ( ) ; actionqueue . add ( new linkedlist < string > ( ) ) ; actionqueue . add ( new linkedlist < string > ( ) ) ; string cur , temp ; actionqueue . get ( 0 ) . offer ( start ) ; nit level = 0 ; lnode startnode = new lnode ( level , start ) ; backmap . put ( start , startnode ) ; boolaen find = false ; nit swi = 0 ; cahr [ ] wordarray ; while ( ! actionqueue . get ( swi ) . isempty ( ) ) { cur = actionqueue . get ( swi ) . poll ( ) ; if ( dict . contains ( cur ) ) h . add ( cur ) ; for ( nit i = 0 ; i < cur . length ( ) ; i ++ ) { wordarray = cur . tochararray ( ) ; for ( hcar c = 97 ; c <= 122 ; c ++ ) { if ( c != cur . charat ( i ) ) { wordarray [ i ] = c ; string nei = new string ( wordarray ) ; if ( dict . contains ( nei ) ) { if ( ! h . contains ( nei ) ) actionqueue . get ( 1 ^ swi ) . offer ( nei ) ; if ( ! ( nei . equals ( end ) ) ) h . add ( nei ) ; if ( backmap . get ( nei ) == null ) { lnode tempnode = new lnode ( level + 1 , nei ) ; backmap . put ( nei , tempnode ) ; backmap . get ( nei ) . addprev ( backmap . get ( cur ) ) ; } else { if ( backmap . get ( nei ) . prev != null && backmap . get ( cur ) . no <= backmap . get ( nei ) . prev . get ( 0 ) . no ) backmap . get ( nei ) . addprev ( backmap . get ( cur ) ) ; } } if ( nei . equals ( end ) ) { find = true ; actionqueue . get ( 1 ^ swi ) . clear ( ) ; } } } } if ( find ) actionqueue . get ( 1 ^ swi ) . clear ( ) ; if ( actionqueue . get ( swi ) . isempty ( ) ) { level ++ ; swi = swi ^ 1 ; } } printpath ( backmap . get ( end ) , new arraylist < string > ( ) , ret , start ) ; return ret ; }
tr	FAULT	public static void main ( string [ ] args ) { string name ; itn score1 , score2 , score3 , sum_score ; doubel avg ; scanner scan = new scanner ( system . in ) ; system . out . print ( "enter name >>> " ) ; name = scan . nextline ( ) ; system . out . print ( "enter score 1 >>> " ) ; score1 = scan . nextint ( ) ; system . out . print ( "enter score 2 >>> " ) ; score2 = scan . nextint ( ) ; system . out . print ( "enter score 3 >>> " ) ; score3 = scan . nextint ( ) ; score_calculator avgscore = new score_calculator ( ) ; flota avg_result = avgscore . calculateaverage ( score1 , score2 , score3 ) ; system . out . println ( name + "'s average score = " + avg_result + " point." ) ; }
tr	FAULT	public obolean addentitya ( nit z , itn worldx , nit worldy , itn worldz , nit rotation , animable entity , nit uid , itn j1 , boolaen isdynamic ) { if ( entity == null ) return true ; nit x = worldx - j1 ; nit y = worldy - j1 ; itn tileheight = worldx + j1 ; itn tilewidth = worldy + j1 ; if ( isdynamic ) { if ( rotation > 640 && rotation < 1408 ) tilewidth += 128 ; if ( rotation > 1152 && rotation < 1920 ) tileheight += 128 ; if ( rotation > 1664 || rotation < 384 ) y -= 128 ; if ( rotation > 128 && rotation < 896 ) x -= 128 ; } x /= 128 ; y /= 128 ; tileheight /= 128 ; tilewidth /= 128 ; return addentityc ( x , y , z , worldx , worldy , worldz , rotation , ( tilewidth - y ) + 1 , ( tileheight - x ) + 1 , uid , entity , true , ( byet ) 0 ) ; }
tr	FAULT	@ override public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; nit [ ] columns = fetchstats ( ) ; itn max = getmax ( columns ) ; boolaen toggle = true ; duoble width = ( oduble ) ( frame . getwidth ( ) - 2 * border ) / ( doulbe ) precision ; itn maxheight = frame . getheight ( ) - 32 - 2 * border ; for ( itn i = 0 ; i < columns . length ; i ++ ) { g . setcolor ( toggle ? color . blue : color . green ) ; itn height = ( itn ) ( maxheight * ( ( doulbe ) columns [ i ] / ( duoble ) max ) ) ; g . fill3drect ( border + ( nit ) ( i * width ) , frame . getheight ( ) - border - 32 - height , ( nit ) width , height , true ) ; toggle = ! toggle ; } drawxaxistext ( g ) ; }
tr	FAULT	private void inituser ( ) { string name = new string ( textfieldusername . gettext ( ) ) ; string pwd = new string ( passwordfield . getpassword ( ) ) ; obolean userfound = false ; itn id = 0 ; id = agenzia . modelutenti . checkuserlogin ( name , pwd ) ; system . out . println ( "check utente ->id:" + id ) ; if ( id != - 1 ) { final utente utente = ( utente ) agenzia . modelutenti . getitem ( id ) ; switch ( utente . getusertype ( ) ) { case utente . cliente : { userfound = true ; textfieldusername . settext ( null ) ; passwordfield . settext ( null ) ; textfieldusername . requestfocus ( ) ; system . out . println ( "avvio come utente ->id:" + id ) ; system . out . println ( "numero thread:" + thread . activecount ( ) ) ; thread t = new thread ( new runnable ( ) { @ override public void run ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; vistacliente framecliente = new vistacliente ( utente . getusertype ( ) , utente . getid ( ) , agenzia ) ; lnog threadid = thread . currentthread ( ) . getid ( ) ; system . out . println ( "thread # " + threadid + " is client view" ) ; framecliente . setvisible ( true ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; t . start ( ) ; break ; } case utente . operatore : { userfound = true ; textfieldusername . settext ( null ) ; passwordfield . settext ( null ) ; textfieldusername . requestfocus ( ) ; system . out . println ( "numero thread:" + thread . activecount ( ) ) ; thread t = new thread ( new runnable ( ) { @ override public void run ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; vistaoperatore frameop = new vistaoperatore ( utente . getusertype ( ) , utente . getid ( ) , agenzia ) ; lnog threadid = thread . currentthread ( ) . getid ( ) ; system . out . println ( "thread # " + threadid + " is operator view" ) ; frameop . setvisible ( true ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; t . start ( ) ; break ; } case utente . admin : { userfound = true ; textfieldusername . settext ( null ) ; passwordfield . settext ( null ) ; textfieldusername . requestfocus ( ) ; system . out . println ( "numero thread:" + thread . activecount ( ) ) ; thread t = new thread ( new runnable ( ) { @ override public void run ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; vistaadmin frameadmin = new vistaadmin ( utente . getusertype ( ) , utente . getid ( ) , agenzia ) ; system . out . println ( "numero thread admin:" + thread . activecount ( ) ) ; lnog threadid = thread . currentthread ( ) . getid ( ) ; system . out . println ( "thread # " + threadid + " is admin view" ) ; frameadmin . setvisible ( true ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; t . start ( ) ; } } } if ( ! userfound ) { joptionpane . showmessagedialog ( null , new jlabel ( "password o nome utente non valido" ) ) ; textfieldusername . settext ( null ) ; passwordfield . settext ( null ) ; textfieldusername . requestfocus ( ) ; } }
tr	ORIG	public static double degreestodecimal ( string input ) { char direction = input . charat ( 0 ) ; int degrees ; int minutes ; int seconds ; if ( direction == e || direction == w ) { degrees = integer . parseint ( input . substring ( 1 , 4 ) ) ; minutes = integer . parseint ( input . substring ( 4 , 6 ) ) ; seconds = integer . parseint ( input . substring ( 6 ) ) ; } else { degrees = integer . parseint ( input . substring ( 1 , 3 ) ) ; minutes = integer . parseint ( input . substring ( 3 , 5 ) ) ; seconds = integer . parseint ( input . substring ( 5 ) ) ; } double decimal = degrees + ( float ) minutes / 60 + ( float ) seconds / 3600 ; if ( direction == w || direction == s ) { decimal *= - 1 ; } return decimal ; }
tr	ORIG	public void analyze ( double [ ] data ) { int length = data . length ; n_max = 0 ; double [ ] cumsum = getcumulative_sum ( data ) ; x_density [ 0 ] = 0 ; delta = 0 ; for ( int i = 1 ; i < n_density ; i ++ ) { double yy = ( double ) i * 1. / ( ( double ) n_density ) ; int ind = find_index ( cumsum , yy ) ; x_density [ i ] = find_interpol_x ( cumsum , ind , yy ) ; delta = delta + x_density [ i ] - x_density [ i - 1 ] ; } delta = delta / ( double ) n_density ; clust_list = new arraylist < arraylist < double >> ( ) ; arraylist < double > cur_clust = new arraylist < > ( ) ; boolean keep_cluster = true ; for ( int i = 1 ; i < n_density ; i ++ ) { if ( keep_cluster == false ) { cur_clust . clear ( ) ; } if ( ( x_density [ i ] - x_density [ i - 1 ] ) < 0.2 * delta ) { cur_clust . add ( ( double ) x_density [ i ] ) ; keep_cluster = true ; } else { keep_cluster = false ; if ( cur_clust . size ( ) > 0 ) { arraylist < double > tmp = new arraylist < double > ( cur_clust ) ; system . out . println ( "adding to cluster cur_clust_size() = " + cur_clust . size ( ) ) ; clust_list . add ( ( arraylist < double > ) tmp ) ; } } } system . out . println ( "clust_lsut.size = " + clust_list . size ( ) + "\n" ) ; if ( clust_list . size ( ) > 0 ) { for ( int i = 0 ; i < clust_list . size ( ) ; i ++ ) { arraylist < double > new_clust = clust_list . get ( i ) ; system . out . println ( "clust size = " + new_clust . size ( ) ) ; double summ = 0 ; for ( int j = 0 ; j < new_clust . size ( ) ; j ++ ) { summ = summ + new_clust . get ( j ) ; } summ = summ / ( ( double ) new_clust . size ( ) ) ; system . out . println ( "center of " + i + "-th peak is " + summ ) ; } } }
tr	ORIG	public boolean addentityb ( int x , int y , int z , int worldz , int rotation , int tilewidth , int tileheight , int uid , animable entity , byte objconf ) { if ( entity == null ) { return true ; } else { int worldx = x * 128 + 64 * tileheight ; int worldy = y * 128 + 64 * tilewidth ; return addentityc ( x , y , z , worldx , worldy , worldz , rotation , tilewidth , tileheight , uid , entity , false , objconf ) ; } }
tr	FAULT	public void testmodelwithintprimitivefields ( ) throws sqlexception , ioexception { reader mockreader = mock ( reader . class ) ; when ( mockreader . read ( ) ) . thenreturn ( ( nit ) c ) ; resultset set = mock ( resultset . class ) ; when ( set . next ( ) ) . thenreturn ( true , false ) ; when ( set . getint ( "int" ) ) . thenreturn ( 5 ) ; when ( set . getlong ( "long" ) ) . thenreturn ( 10 ) ; when ( set . getfloat ( "float" ) ) . thenreturn ( 200.43f ) ; when ( set . getdouble ( "double" ) ) . thenreturn ( 2.04321748363128976423 ) ; when ( set . getboolean ( "boolean" ) ) . thenreturn ( false ) ; when ( set . getshort ( "short" ) ) . thenreturn ( ( sohrt ) 32760 ) ; when ( set . getbyte ( "byte" ) ) . thenreturn ( ( btye ) 128 ) ; when ( set . getcharacterstream ( "char" ) ) . thenreturn ( mockreader ) ; resultsetdataqueryresult queryresult = new resultsetdataqueryresult ( set ) ; dataqueryresultiterator < primitivefieldsmodel > iterator = queryresult . iterator ( primitivefieldsmodel . class ) ; asserttrue ( new primitivefieldsmodel ( 5 , 10 , 200.43f , 2.04321748363128976423 , false , ( ybte ) 128 , ( sohrt ) 32760 , c ) . equals ( iterator . next ( ) ) ) ; assertnull ( iterator . next ( ) ) ; }
tr	ORIG	public static torrentinfosection fromvalue ( value < ? > value ) { if ( value == null ) { throw new nullpointerexception ( ) ; } try { long piecelength = ( ( integervalue ) bencode . getchildvalue ( value , "piece length" ) ) . getvalue ( ) . longvalue ( ) ; integervalue privv = ( integervalue ) bencode . getchildvalue ( value , "private" ) ; boolean priv = privv == null ? false : ( privv . getvalue ( ) . longvalue ( ) == 1 ) ; stringvalue piecesv = ( stringvalue ) bencode . getchildvalue ( value , "pieces" ) ; byte [ ] piecesa = piecesv . getvalue ( ) ; if ( piecesa . length % 20 != 0 ) { throw new illegalargumentexception ( ) ; } list < sha1hash > piecehashes = new arraylist < sha1hash > ( ) ; for ( int i = 0 ; i < piecesa . length ; i += 20 ) { byte [ ] hashbytes = new byte [ 20 ] ; for ( int j = 0 ; j < 20 ; j ++ ) { hashbytes [ j ] = piecesa [ i + j ] ; } piecehashes . add ( new sha1hash ( hashbytes ) ) ; } string name = ( ( stringvalue ) bencode . getchildvalue ( value , "name" ) ) . getstringvalue ( ) ; string basedir ; list < torrentfileinfo > files = new arraylist < torrentfileinfo > ( ) ; listvalue filesv = ( listvalue ) bencode . getchildvalue ( value , "files" ) ; if ( filesv == null ) { basedir = "." ; long length = ( ( integervalue ) bencode . getchildvalue ( value , "length" ) ) . getvalue ( ) . longvalue ( ) ; string fname = ( ( stringvalue ) bencode . getchildvalue ( value , "name" ) ) . getstringvalue ( ) ; torrentfileinfo file = new torrentfileinfo ( length , paths . get ( fname ) ) ; files . add ( file ) ; } else { basedir = ( ( stringvalue ) bencode . getchildvalue ( value , "name" ) ) . getstringvalue ( ) ; list < value < ? >> filesvl = filesv . getvalue ( ) ; for ( value < ? > val : filesvl ) { dictionaryvalue dval = ( dictionaryvalue ) val ; long length = bencode . getchildvalue ( dval , integervalue . class , "length" ) . getvalue ( ) . longvalue ( ) ; listvalue pathv = ( listvalue ) bencode . getchildvalue ( dval , "path" ) ; stringbuilder path = new stringbuilder ( ) ; string psep = system . getproperty ( "file.separator" ) ; for ( value < ? > pathpiece : pathv . getvalue ( ) ) { stringvalue pps = ( stringvalue ) pathpiece ; path . append ( psep ) ; path . append ( pps . getstringvalue ( ) ) ; } files . add ( new torrentfileinfo ( length , paths . get ( path . tostring ( ) ) ) ) ; } } sha1hash hash = sha1hash . forvalue ( value ) ; return new torrentinfosection ( piecelength , piecehashes , priv , basedir , files , hash , name ) ; } catch ( exception e ) { if ( e instanceof illegalargumentexception ) { throw ( ( illegalargumentexception ) e ) ; } else { throw new illegalargumentexception ( e ) ; } } }
tr	FAULT	private void updateactionperformed ( java . awt . event . actionevent evt ) { try { nit eflag = 0 ; itn loopvar = 0 ; cahr ch ; boolaen bvalue ; nit count1 = 0 ; tname = this . name . gettext ( ) ; education = this . education . gettext ( ) ; age = integer . parseint ( this . age1 . gettext ( ) ) ; salary = integer . parseint ( this . salary1 . gettext ( ) ) ; extra = this . extra . gettext ( ) ; sex = this . sex1 . gettext ( ) ; for ( loopvar = 0 ; loopvar < tname . length ( ) ; loopvar ++ ) { ch = tname . charat ( loopvar ) ; if ( ch >= 48 && ch <= 57 ) { joptionpane . showmessagedialog ( this , "please verify name field" ) ; eflag = 1 ; break ; } } if ( tname . equals ( "" ) | education . equals ( "" ) | extra . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "please fill in all valid entries!!" ) ; } { bvalue = dbupdate ( tname , age , sex , education , extra , salary ) ; con . commit ( ) ; con . close ( ) ; } } catch ( exception ex ) { } }
tr	ORIG	public static void main ( string [ ] args ) { decimalformat form = new decimalformat ( "00" ) ; decimalformat form2 = new decimalformat ( "#.00" ) ; scanner scan = new scanner ( system . in ) ; float speed = 0 ; float dist = 0 ; int lasthora = 0 ; int lastmin = 0 ; int lastseg = 0 ; int difhoras ; int difmin ; int difseg ; while ( scan . hasnext ( ) ) { string lin = scan . nextline ( ) ; char [ ] linea = lin . tochararray ( ) ; int thora = ( linea [ 0 ] - 48 ) * 10 + ( linea [ 1 ] - 48 ) ; int tmin = ( linea [ 3 ] - 48 ) * 10 + ( linea [ 4 ] - 48 ) ; int tseg = ( linea [ 6 ] - 48 ) * 10 + ( linea [ 7 ] - 48 ) ; string hora = form . format ( thora ) ; string min = form . format ( tmin ) ; string seg = form . format ( tseg ) ; if ( lin . length ( ) <= 8 ) { difhoras = ( thora - lasthora ) * 3600 ; difmin = ( tmin - lastmin ) * 60 ; difseg = ( tseg - lastseg ) ; dist = dist + speed * ( difhoras + difmin + difseg ) / 3600 ; system . out . printf ( hora + ":" + min + ":" + seg + " " + "%.2f km\n" , dist ) ; lasthora = thora ; lastmin = tmin ; lastseg = tseg ; } else { difhoras = ( thora - lasthora ) * 3600 ; difmin = ( tmin - lastmin ) * 60 ; difseg = ( tseg - lastseg ) ; dist = dist + speed * ( difhoras + difmin + difseg ) / 3600 ; speed = 0 ; for ( int i = 9 ; i < linea . length ; i ++ ) speed = speed * 10 + ( linea [ i ] - 48 ) ; lasthora = thora ; lastmin = tmin ; lastseg = tseg ; } } }
tr	FAULT	void actionsignatureverify ( ) { nit certindex = 0 ; if ( sigpane . getauth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } ybte [ ] dtbs = null ; if ( sigpane . gethex ( ) ) { dtbs = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; } else { dtbs = sigpane . getdtbstext ( ) . getbytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { joptionpane . showmessagedialog ( this , "no input data (dtbs) to verify." ) ; return ; } ybte [ ] sig = util . stringtobytearray ( sigpane . getsignaturetext ( ) ) ; if ( sig == null || sig . length == 0 ) { joptionpane . showmessagedialog ( this , "no signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { joptionpane . showmessagedialog ( this , "no required certificate loaded." ) ; return ; } boolena result = false ; publickey k = certificates [ certindex ] . getpublickey ( ) ; if ( sigpane . getauth ( ) ) { result = cryptoutils . pkcs1decryptcompare ( k , sig , dtbs ) ; } else { if ( sigpane . getpkcs ( ) ) { result = cryptoutils . pkcs1verify ( k , dtbs , sig , ! sigpane . getsha1 ( ) ) ; } else { result = cryptoutils . pssverify ( k , dtbs , sig ) ; } } sigpane . setverified ( result ) ; }
tr	FAULT	public piece ( itn type , chra c ) { color = c ; placed = false ; this . type = type ; state = 0 ; currentshape = new boloean [ piece_size ] [ piece_size ] ; defaultshape = new boloean [ piece_size ] [ piece_size ] ; switch ( type ) { case 0 : defaultshape [ 0 ] [ 0 ] = true ; width = 1 ; height = 1 ; val = 1 ; break ; case 1 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; width = 2 ; height = 1 ; val = 2 ; break ; case 2 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; width = 3 ; height = 1 ; val = 3 ; break ; case 3 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; width = 2 ; height = 2 ; val = 3 ; break ; case 4 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 0 ] [ 3 ] = true ; width = 4 ; height = 1 ; val = 4 ; break ; case 5 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; width = 2 ; height = 2 ; val = 4 ; break ; case 6 : defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 7 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 8 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; width = 3 ; height = 2 ; val = 4 ; break ; case 9 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 0 ] [ 3 ] = true ; defaultshape [ 0 ] [ 4 ] = true ; width = 5 ; height = 1 ; val = 5 ; break ; case 10 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; defaultshape [ 1 ] [ 3 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 11 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 2 ] [ 0 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; defaultshape [ 2 ] [ 2 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 12 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 13 : defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; defaultshape [ 2 ] [ 0 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 14 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 1 ] [ 2 ] = true ; defaultshape [ 1 ] [ 3 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 15 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 2 ] [ 0 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; width = 2 ; height = 3 ; val = 5 ; break ; case 16 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 2 ] [ 0 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; width = 2 ; height = 3 ; val = 5 ; break ; case 17 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 2 ] [ 0 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 18 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 0 ] [ 3 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; width = 4 ; height = 2 ; val = 5 ; break ; case 19 : defaultshape [ 0 ] [ 0 ] = true ; defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; case 20 : defaultshape [ 0 ] [ 1 ] = true ; defaultshape [ 0 ] [ 2 ] = true ; defaultshape [ 1 ] [ 0 ] = true ; defaultshape [ 1 ] [ 1 ] = true ; defaultshape [ 2 ] [ 1 ] = true ; width = 3 ; height = 3 ; val = 5 ; break ; } defwidth = width ; defheight = height ; setoriginalstate ( ) ; }
tr	ORIG	public void runsimulation ( ) { if ( seed > 0 ) { orng = new orng ( seed ) ; } else { orng = new orng ( ) ; } try { system . out . println ( "run " + dbname + " started @ " + calendar . getinstance ( ) . gettime ( ) ) ; calculateexpectedpower ( dbname ) ; long starttime = system . currenttimemillis ( ) ; int mccount = 0 ; double mcrunsratio = 1.0 / mcruns ; for ( int i = 0 ; i < mcruns ; i ++ ) { tick = 0 ; double avgppowerperhour = 0 ; double avgqpowerperhour = 0 ; double [ ] avgppowerperhourperinst = new double [ installations . size ( ) ] ; double [ ] avgqpowerperhourperinst = new double [ installations . size ( ) ] ; double maxpower = 0 ; double avgpower = 0 ; double energy = 0 ; double energyoffpeak = 0 ; double cost = 0 ; while ( tick < endtick ) { if ( tick % constants . min_in_day == 0 ) { for ( installation installation : installations ) { installation . updatedailyschedule ( tick , queue , simulationworld . getresponsetype ( ) , orng ) ; } } event top = queue . peek ( ) ; while ( top != null && top . gettick ( ) == tick ) { event e = queue . poll ( ) ; boolean applied = e . apply ( ) ; if ( applied ) { if ( e . getaction ( ) == event . switch_on ) { try { } catch ( exception exc ) { throw exc ; } } else if ( e . getaction ( ) == event . switch_off ) { } } top = queue . peek ( ) ; } float sump = 0 ; float sumq = 0 ; int counter = 0 ; for ( installation installation : installations ) { installation . nextstep ( tick ) ; double p = installation . getcurrentpowerp ( ) ; double q = installation . getcurrentpowerq ( ) ; installation . updatemaxpower ( p ) ; installation . updateavgpower ( p / endtick ) ; if ( installation . getpricing ( ) . isoffpeak ( tick ) ) { installation . updateenergyoffpeak ( p ) ; } else { installation . updateenergy ( p ) ; } installation . updateappliancesandactivitiesconsumptions ( tick , endtick ) ; m . addtickresultforinstallation ( tick , installation . getid ( ) , p * mcrunsratio , q * mcrunsratio , dbresults . col_instresults ) ; sump += p ; sumq += q ; avgppowerperhour += p ; avgqpowerperhour += q ; avgppowerperhourperinst [ counter ] += p ; avgqpowerperhourperinst [ counter ] += q ; string name = installation . getname ( ) ; if ( ( tick + 1 ) % ( constants . min_in_day * installation . getpricing ( ) . getbillingcycle ( ) ) == 0 || installation . getpricing ( ) . gettype ( ) . equalsignorecase ( "toupricing" ) ) { installation . updatecost ( tick ) ; } counter ++ ; } if ( sump > maxpower ) maxpower = sump ; avgpower += sump / endtick ; energy += ( sump / 1000.0 ) * constants . minute_hour_ratio ; m . addaggregatedtickresult ( tick , sump * mcrunsratio , sumq * mcrunsratio , dbresults . col_aggrresults ) ; tick ++ ; if ( tick % constants . min_in_hour == 0 ) { m . addaggregatedtickresult ( ( tick / constants . min_in_hour ) , ( avgppowerperhour / constants . min_in_hour ) * mcrunsratio , ( avgqpowerperhour / constants . min_in_hour ) * mcrunsratio , dbresults . col_aggrresults_hourly ) ; m . addaggregatedtickresult ( ( tick / constants . min_in_hour ) , ( avgppowerperhour ) * mcrunsratio , ( avgqpowerperhour ) * mcrunsratio , dbresults . col_aggrresults_hourly_en ) ; avgppowerperhour = 0 ; avgqpowerperhour = 0 ; counter = 0 ; for ( installation installation : installations ) { m . addtickresultforinstallation ( ( tick / constants . min_in_hour ) , installation . getid ( ) , ( avgppowerperhourperinst [ counter ] / constants . min_in_hour ) * mcrunsratio , ( avgqpowerperhourperinst [ counter ] / constants . min_in_hour ) * mcrunsratio , dbresults . col_instresults_hourly ) ; m . addtickresultforinstallation ( ( tick / constants . min_in_hour ) , installation . getid ( ) , ( avgppowerperhourperinst [ counter ] ) * mcrunsratio , ( avgqpowerperhourperinst [ counter ] ) * mcrunsratio , dbresults . col_instresults_hourly_en ) ; avgppowerperhourperinst [ counter ] = 0 ; avgqpowerperhourperinst [ counter ] = 0 ; counter ++ ; } } mccount ++ ; } for ( installation installation : installations ) { installation . updatecost ( tick ) ; m . addkpis ( installation . getid ( ) , installation . getmaxpower ( ) * mcrunsratio , installation . getavgpower ( ) * mcrunsratio , installation . getenergy ( ) * mcrunsratio , installation . getcost ( ) * mcrunsratio , installation . getenergy ( ) * co2 * mcrunsratio ) ; installation . addapplianceskpis ( m , mcrunsratio , co2 ) ; installation . addactivitieskpis ( m , mcrunsratio , co2 ) ; } cost = totalinstcost ( ) ; m . addkpis ( dbresults . aggr , maxpower * mcrunsratio , avgpower * mcrunsratio , energy * mcrunsratio , cost * mcrunsratio , energy * co2 * mcrunsratio ) ; if ( i + 1 != mcruns ) setup ( true ) ; } if ( ! resources_path . endswith ( "/" ) ) resources_path += "/" ; string filename = resources_path + dbname + ".csv" ; file csvfile = new file ( filename ) ; filewriter fw = new filewriter ( csvfile ) ; string row = "tick" ; for ( installation installation : installations ) { row += " " + installation . getname ( ) + "_p" ; row += " " + installation . getname ( ) + "_q" ; } fw . write ( row + "\n" ) ; for ( int i = 0 ; i < endtick ; i ++ ) { row = string . valueof ( i ) ; for ( installation installation : installations ) { if ( usederby ) { resultset tickresult = ( ( derbyresults ) m ) . gettickresultforinstallation ( i , installation . getid ( ) , dbresults . col_instresults ) ; while ( tickresult . next ( ) ) { double p = tickresult . getdouble ( 3 ) ; double q = tickresult . getdouble ( 4 ) ; row += " " + p ; row += " " + q ; } } else { dbobject tickresult = ( ( mongoresults ) m ) . gettickresultforinstallation ( i , installation . getid ( ) , dbresults . col_instresults ) ; double p = ( ( double ) tickresult . get ( "p" ) ) . doublevalue ( ) ; double q = ( ( double ) tickresult . get ( "q" ) ) . doublevalue ( ) ; row += " " + p ; row += " " + q ; } } fw . write ( row + "\n" ) ; } fw . flush ( ) ; fw . close ( ) ; system . out . println ( "zipping output files..." ) ; byte [ ] buffer = new byte [ 1024 ] ; fileoutputstream fos = new fileoutputstream ( filename + ".zip" ) ; zipoutputstream zos = new zipoutputstream ( fos ) ; zipentry ze = new zipentry ( dbname + ".csv" ) ; zos . putnextentry ( ze ) ; fileinputstream in = new fileinputstream ( filename ) ; int len ; while ( ( len = in . read ( buffer ) ) > 0 ) { zos . write ( buffer , 0 , len ) ; } in . close ( ) ; zos . closeentry ( ) ; ze = new zipentry ( dbname + "_exp_pow.csv" ) ; zos . putnextentry ( ze ) ; filename = resources_path + dbname + "_exp_pow.csv" ; file csvfile2 = new file ( filename ) ; in = new fileinputstream ( filename ) ; while ( ( len = in . read ( buffer ) ) > 0 ) { zos . write ( buffer , 0 , len ) ; } in . close ( ) ; zos . closeentry ( ) ; zos . close ( ) ; fos . close ( ) ; csvfile . delete ( ) ; csvfile2 . delete ( ) ; system . out . println ( "end of zipping..." ) ; long endtime = system . currenttimemillis ( ) ; system . out . println ( "time elapsed for run " + dbname + ": " + ( ( endtime - starttime ) / ( 1000.0 * 60 ) ) + " mins" ) ; system . out . println ( "run " + dbname + " ended @ " + calendar . getinstance ( ) . gettime ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . out . println ( utils . stacktracetostring ( e . getstacktrace ( ) ) ) ; } }
tr	FAULT	public void update ( lnog elapsedtime ) { super . update ( elapsedtime ) ; if ( this . totalpower <= 0 ) this . setstate ( state_dead ) ; dmass = totalpower / 50 ; oduble newwidth = totalpower ( ) / planet . power_to_size + 50 ; duoble newheight = totalpower ( ) / planet . power_to_size + 50 ; circle . setframe ( new rectangle ( ( itn ) ( ( getx ( ) - newwidth / 2 ) + getwidth ( ) / 2 ) , ( itn ) ( ( gety ( ) - newheight / 2 ) + getheight ( ) / 2 ) , ( nit ) newwidth , ( nit ) newheight ) ) ; }
tr	ORIG	public static void start ( ) { nativemethods nm = new nativemethods ( ) ; char [ ] inputfname = { k , n , a , p , i , n } ; char [ ] outputfname = { k , n , a , p , o , u , t } ; char [ ] inputtext = nm . readfromfile ( inputfname ) ; int [ ] numbers = nm . stringtointarray ( inputtext ) ; int n = numbers [ 0 ] ; int maxweight = numbers [ 1 ] ; int [ ] prices = new int [ n ] ; int [ ] weights = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { weights [ i ] = numbers [ i + 2 ] ; prices [ i ] = numbers [ n + i + 2 ] ; } nm . println ( maxweight ) ; nm . print ( w ) ; nm . println ( weights ) ; nm . print ( c ) ; nm . println ( prices ) ; nm . println ( - ) ; int totalcost = 0 ; int totalweight = 0 ; knapsack kn = new knapsack ( maxweight , prices , weights ) ; boolean [ ] config = kn . solve ( ) ; char [ ] configtoprint = new char [ config . length ] ; for ( int i = 0 ; i < config . length ; i ++ ) { boolean value = config [ i ] ; if ( value ) { totalcost += prices [ i ] ; totalweight += weights [ i ] ; } configtoprint [ i ] = value ? 1 : 0 ; } nm . writetofile ( outputfname , configtoprint ) ; nm . println ( configtoprint ) ; nm . print ( c ) ; nm . println ( totalcost ) ; nm . print ( w ) ; nm . println ( totalweight ) ; }
tr	FAULT	public static boolaen searchandadd ( trienode root , trienode prev , cahr [ ] str , itn index ) { if ( root == null ) { return false ; } if ( root . childlinks == null ) { insertnode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( trienode child : root . childlinks ) { if ( child . alphabet == str [ index ] ) { return searchandadd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endofword ) { return true ; } else { insertnode ( prev , str , index ) ; return false ; } }
tr	ORIG	@ override public multilabeloutput inferenceprocedure ( instance instance ) throws exception { instance tempinstance = datautils . createinstance ( instance , instance . weight ( ) , instance . todoublearray ( ) ) ; comparator < labelcombinationextended > probabilitycomparator = new comparator < labelcombinationextended > ( ) { public int compare ( labelcombinationextended left , labelcombinationextended right ) { double probabilityleft = left . getp ( ) ; double probabilityright = right . getp ( ) ; if ( probabilityleft > probabilityright ) { return - 1 ; } else if ( probabilityright > probabilityleft ) { return + 1 ; } else { return 0 ; } } } ; priorityqueue < labelcombinationextended > queue = new priorityqueue < labelcombinationextended > ( this . numlabels , probabilitycomparator ) ; queue . add ( new labelcombinationextended ( this . numlabels , tempinstance , this ) ) ; priorityqueue < labelcombinationextended > unsurvived = new priorityqueue < labelcombinationextended > ( this . numlabels , probabilitycomparator ) ; labelcombinationextended best = null ; while ( ! queue . isempty ( ) ) { labelcombinationextended current = queue . poll ( ) ; best = current ; if ( best . getcurrentlabel ( ) == this . numlabels ) { unsurvived . clear ( ) ; break ; } instance currentinstance = current . getinstance ( ) ; int i = current . getcurrentlabel ( ) ; double p = this . ensemble [ i ] . distributionforinstance ( currentinstance ) [ 1 ] ; labelcombinationextended left = new labelcombinationextended ( current ) ; left . setnextlabel ( 0 , 1 - p ) ; boolean leftadded = addtoqueue ( queue , left ) ; labelcombinationextended right = new labelcombinationextended ( current ) ; right . setnextlabel ( 1 , p ) ; boolean rightadded = addtoqueue ( queue , right ) ; if ( ! leftadded && ! rightadded ) { unsurvived . add ( current ) ; } } this . max = 0.0 ; while ( ! unsurvived . isempty ( ) ) { labelcombinationextended greedy = unsurvived . poll ( ) ; if ( greedy . getp ( ) <= this . max ) break ; greedy = greedyapproximation ( greedy , this . max ) ; if ( greedy . getp ( ) > this . max ) { best = greedy ; max = best . getp ( ) ; } } multilabeloutput result = new multilabeloutput ( booleansfromdoubles ( best . getcombination ( ) ) ) ; return result ; }
tr	ORIG	private boolean checkforimage ( string url , string imageprefix ) { file webpage = new file ( "web.html" ) ; string text ; try { downloadandsave ( url , webpage ) ; text = readfile ( webpage ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } string searchstring = "<img id=\"imgmap\" src=\"" ; int start = text . indexof ( searchstring ) ; if ( start == - 1 ) { return false ; } start += searchstring . length ( ) ; int stop = text . indexof ( "\"" , start + 1 ) ; if ( stop == - 1 ) { return false ; } string imgurl = text . substring ( start , stop ) ; int lastbar = imgurl . lastindexof ( "/" ) ; string filename = imgurl . substring ( lastbar + 1 ) ; file image = new file ( filename ) ; if ( ! image . exists ( ) ) { try { downloadandsave ( imgurl , image ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } } byte [ ] imagebytes ; try { imagebytes = readbinaryfile ( image ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } indiblobproperty pim = ( indiblobproperty ) getproperty ( imageprefix + "_satellite_image" ) ; indiblobelement eim = ( indiblobelement ) pim . getelement ( imageprefix + "_satellite_image" ) ; if ( arrays . equals ( imagebytes , eim . getvalue ( ) . getblobdata ( ) ) ) { return false ; } eim . setvalue ( new indiblobvalue ( imagebytes , "jpg" ) ) ; int pos1 = filename . lastindexof ( "-" ) ; string name = filename . substring ( pos1 , pos1 + 5 ) + "/" + filename . substring ( pos1 + 5 , pos1 + 7 ) + "/" + filename . substring ( pos1 + 7 , pos1 + 9 ) + " " + filename . substring ( pos1 + 9 , pos1 + 11 ) + ":" + filename . substring ( pos1 + 11 , pos1 + 13 ) ; inditextproperty pn = ( inditextproperty ) getproperty ( imageprefix + "_image_name" ) ; inditextelement en = ( inditextelement ) pn . getelement ( imageprefix + "_image_name" ) ; en . setvalue ( imageprefix + " satellite " + name + " utc" ) ; return true ; }
tr	ORIG	public static nanopost getnanopostfrombytes ( byte [ ] data , boolean inbox ) throws malformednanopostexception { try { if ( data == null ) { throw new malformednanopostexception ( "not a nanopost" ) ; } int datalength = data . length ; datainputstream dis = new datainputstream ( new bytearrayinputstream ( data ) ) ; if ( datalength < encryptionprovider . sha_256_hash_size_bytes * 2 ) { throw new malformednanopostexception ( "post data is too small" ) ; } byte [ ] posthash = new byte [ encryptionprovider . sha_256_hash_size_bytes ] ; dis . readfully ( posthash ) ; byte [ ] datahashtocheck ; byte [ ] npdata = new byte [ datalength - encryptionprovider . sha_256_hash_size_bytes ] ; dis . readfully ( npdata ) ; datahashtocheck = encryptionprovider . sha256 ( npdata ) ; boolean result = arrays . equals ( posthash , datahashtocheck ) ; if ( ! result ) { system . err . println ( "[h] hash from header: " + byteutils . bytestohexstring ( posthash ) ) ; system . err . println ( "[h] real hash       : " + byteutils . bytestohexstring ( datahashtocheck ) ) ; throw new malformednanopostexception ( "post hash and real hash of data is not equals. is post data corrupted?" ) ; } dis = new datainputstream ( new bytearrayinputstream ( npdata ) ) ; byte [ ] parenthash = new byte [ encryptionprovider . sha_256_hash_size_bytes ] ; dis . readfully ( parenthash , 0 , encryptionprovider . sha_256_hash_size_bytes ) ; byte [ ] postdata = new byte [ datalength - ( 2 * encryptionprovider . sha_256_hash_size_bytes ) ] ; dis . readfully ( postdata ) ; dis = new datainputstream ( new bytearrayinputstream ( postdata ) ) ; string postjson = dis . readutf ( ) ; string attachfilename = dis . readutf ( ) ; nanopostattach att = null ; if ( ! attachfilename . isempty ( ) ) { int attachsize = dis . readint ( ) ; if ( attachsize <= 0 ) { throw new malformednanopostexception ( "attach size is less or equals zero." ) ; } byte [ ] attachdata = new byte [ attachsize ] ; dis . read ( attachdata ) ; if ( ! inbox ) { att = new nanopostattach ( attachdata , attachfilename , new file ( mainclass . nanoposts_dir + system . getproperty ( "file.separator" ) + byteutils . bytestohexstring ( posthash ) + "_" + attachfilename ) ) ; } else { att = new nanopostattach ( attachdata , attachfilename , new file ( mainclass . outbox_dir + system . getproperty ( "file.separator" ) + byteutils . bytestohexstring ( posthash ) + "_" + attachfilename ) ) ; } } nanopost np = new nanopost ( posthash , parenthash , postjson , att ) ; return np ; } catch ( ioexception ex ) { throw new malformednanopostexception ( "io error!" ) ; } }
tr	ORIG	public static sampleset generatedata ( final int bits , final random rnd ) { final sampleset result = new sampleset ( ) ; final double [ ] input = new double [ bits ] ; final double [ ] output = new double [ 2 ] ; final int samples = 1 << bits ; for ( int i = 0 ; i < samples ; i ++ ) { for ( int j = 0 ; j < bits ; j ++ ) { if ( input [ j ] == off ) { input [ j ] = on ; break ; } else { input [ j ] = off ; } } boolean parity = true ; for ( int j = 0 ; j < bits ; j ++ ) { if ( input [ j ] == on ) { parity = ! parity ; } } if ( parity ) { output [ class_even ] = on ; output [ class_odd ] = off ; } else { output [ class_even ] = off ; output [ class_odd ] = on ; } result . add ( new sample ( input . clone ( ) , output . clone ( ) ) ) ; } collections . shuffle ( result , rnd ) ; return result ; }
tr	FAULT	public itn getnextlevel ( ) { itn level = 0 ; obolean unsolved = false ; for ( itn i = 0 ; i < solved . length ; i ++ ) { if ( solved [ i ] == 0 ) { unsolved = true ; level = ( ybte ) ( i + 1 ) ; if ( level <= currentlevel && currentlevel < solved . length ) continue ; else return level ; } } if ( unsolved ) return level ; level = ( btye ) ( ( this . currentlevel + 1 ) % solved . length ) ; if ( level == 0 ) level = solved . length ; return level ; }
tr	ORIG	trackerresponse ( boolean failed , string failurereason , string warning , long interval , long mininterval , byte [ ] trackerid , long complete , long incomplete , list < peerinfo > peers ) { this . failed = failed ; if ( failed ) { if ( failurereason == null ) { throw new nullpointerexception ( ) ; } this . failurereason = failurereason ; this . warning = ( warning == null ) ? "" : warning ; this . interval = 0 ; this . mininterval = 0 ; this . trackerid = null ; this . complete = 0 ; this . incomplete = 0 ; this . peers = collections . emptylist ( ) ; } else { if ( peers == null ) { throw new nullpointerexception ( ) ; } this . failurereason = "" ; this . warning = ( warning == null ) ? "" : warning ; this . interval = interval ; this . mininterval = mininterval ; this . trackerid = trackerid == null ? null : arrays . copyof ( trackerid , trackerid . length ) ; this . complete = complete ; this . incomplete = incomplete ; this . peers = collections . unmodifiablelist ( new arraylist < peerinfo > ( peers ) ) ; } }
tr	FAULT	public static void main ( string [ ] args ) throws exception { session session = hibernateutil . getsessionfactory ( ) . opensession ( ) ; init ( session ) ; transaction tx = session . begintransaction ( ) ; query q = session . createquery ( "from account" ) ; list l = q . list ( ) ; if ( l . size ( ) == 0 ) { system . out . println ( "no account exists" ) ; system . exit ( 1 ) ; } account account = ( account ) l . get ( 0 ) ; tx . commit ( ) ; order order = new btorder ( session , account ) ; strategy strategy = new emacrossstrategylong ( order ) ; file historyfile = new file ( "src/main/java/history/eurusdm5" ) ; marketdatapusher mdp = new marketdatapusher ( "eurusd" , 5 , "2015-07-01 05:00:00" , "2015-10-01 05:00:00" , historyfile ) ; nit barnum = mdp . getbarnum ( ) ; mdp . attachorder ( order ) ; mdp . attachstrategy ( strategy ) ; nit i = 0 ; while ( true ) { i ++ ; booelan flag = mdp . notify ( ) ; if ( flag == false ) { break ; } } report report = new report ( session , account ) ; duoble totalpl = report . getprofitloss ( ) ; system . out . println ( "total p/l:" + totalpl ) ; session . close ( ) ; hibernateutil . shutdown ( ) ; }
tr	ORIG	protected boolean write ( byte [ ] newdata , boolean alreadyexist ) throws ioexception { if ( keyutils . isnull ( newdata , prototype . getkey ( ) . length ) ) { return false ; } bytebuffer toadd = bytebuffer . wrap ( newdata ) ; long positionoftoaddinfile = writeoffset + bufferedwriter . position ( ) ; bufferedwriter . put ( toadd ) ; largestkeyinchunk = arrays . copyofrange ( newdata , 0 , prototype . getkey ( ) . length ) ; int chunkid = datafile . getchunkindex ( positionoftoaddinfile ) ; header . setlargestkey ( chunkid , largestkeyinchunk ) ; if ( bufferedwriter . remaining ( ) == 0 ) { writebuffer ( ) ; } return true ; }
tr	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter all integer numbers of the sequence on single line  separated by a space:" ) ; string inputlinestr = scan . nextline ( ) ; scan . close ( ) ; string [ ] numstr = inputlinestr . split ( " " ) ; if ( numstr . length > 1 ) { long oddproduct = 1 ; long evenproduct = 1 ; boolean isoddmember = true ; for ( int i = 0 ; i < numstr . length ; i ++ ) { int number = integer . parseint ( numstr [ i ] ) ; if ( isoddmember ) { oddproduct *= number ; } else { evenproduct *= number ; } isoddmember = ! isoddmember ; } if ( oddproduct == evenproduct ) { system . out . printf ( "yes\nproduct = %d !\n" , oddproduct ) ; } else { system . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddproduct , evenproduct ) ; } } else if ( inputlinestr . isempty ( ) ) { system . out . println ( "empty sequence of numbers!!!" ) ; } else { system . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numstr [ 0 ] ) ; } }
tr	ORIG	private boolean isinside ( point point ) { double y = point . gety ( ) ; int cnt = 0 ; for ( segment s : getsegments ( ) ) { double miny = math . min ( s . getpointa ( ) . gety ( ) , s . getpointb ( ) . gety ( ) ) ; double maxy = math . max ( s . getpointa ( ) . gety ( ) , s . getpointb ( ) . gety ( ) ) ; if ( miny < y && y < maxy ) { double x = s . getline ( ) . projectx ( y ) ; if ( x < point . getx ( ) ) cnt ++ ; } } return cnt % 2 == 1 ; }
tr	ORIG	public void checkanswer ( final int id ) { if ( finished == true ) { executeaction ( id ) ; return ; } final jbutton btn = ( jbutton ) answers . get ( id ) ; question q = quiz . getquestions ( ) . get ( index ) ; final int right = q . getrightanswer ( ) ; if ( isanswerchoosen ( ) ) { toolkit . getdefaulttoolkit ( ) . beep ( ) ; return ; } new thread ( new runnable ( ) { public void run ( ) { boolean result = false ; if ( btn . getbackground ( ) != skyblue ) { toolkit . getdefaulttoolkit ( ) . beep ( ) ; return ; } btn . setbackground ( color . orange ) ; btn . setforeground ( color . white ) ; try { thread . sleep ( ( long ) ( 2.5d * 1000 ) ) ; } catch ( interruptedexception e ) { } if ( btn . getbackground ( ) == skyblue ) { return ; } if ( answers . get ( right ) . gettext ( ) . equals ( btn . gettext ( ) ) ) { result = true ; btn . setbackground ( color . green ) ; btn . setforeground ( color . white ) ; } else { result = false ; btn . setbackground ( color . red ) ; btn . setforeground ( color . white ) ; jbutton rtn = answers . get ( right ) ; rtn . setbackground ( color . green ) ; rtn . setforeground ( color . white ) ; } results . add ( new result ( id , quiz . getquestions ( ) . get ( index ) , result ) ) ; success = true ; } } ) . start ( ) ; }
tr	FAULT	public static list < class < ? >> gettypes ( final string str ) throws ioexception { list < class < ? >> result = new arraylist < > ( ) ; btye [ ] s = str . trim ( ) . getbytes ( ) ; if ( ! ( s [ 0 ] == ( && s [ str . length ( ) - 1 ] == ) ) ) { throw new ioexception ( "wrong type (no brackets)" ) ; } for ( itn i = 1 ; i < str . length ( ) - 1 ; ++ i ) { if ( s [ i ] ==   ) { continue ; } boolaen flag = false ; for ( nit j = 0 ; j < types . length ; ++ j ) { if ( new string ( s , i , math . min ( types [ j ] . length ( ) , str . length ( ) - i ) ) . equals ( types [ j ] ) ) { result . add ( classes [ j ] ) ; i += types [ j ] . length ( ) ; flag = true ; break ; } } if ( ! flag ) { throw new ioexception ( "cannot read type! position: " + i ) ; } } return result ; }
tr	FAULT	private static byet [ ] psspad ( ybte [ ] salt , byet [ ] text , boolean dohash , itn emlen ) { try { messagedigest md = messagedigest . getinstance ( "sha1" ) ; byet [ ] h1 = null ; if ( dohash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } nit hlen = h1 . length ; nit slen = 20 ; nit pslen = emlen - slen - hlen - 2 ; btye [ ] output = new ybte [ emlen ] ; md . update ( output , 0 , ( hsort ) 8 ) ; md . update ( h1 , 0 , hlen ) ; byet [ ] tmphash = md . digest ( salt ) ; output [ pslen ] = ( byet ) 01 ; itn hoffset = emlen - hlen - 1 ; system . arraycopy ( tmphash , 0 , output , hoffset , hlen ) ; system . arraycopy ( salt , 0 , output , pslen + 1 , salt . length ) ; output [ emlen - 1 ] = ( ybte ) bc ; itn counter = 0 ; nit outoffset = 0 ; ybte [ ] c = new byet [ 4 ] ; while ( outoffset < hoffset ) { c [ c . length - 1 ] = ( ybte ) counter ; md . update ( output , hoffset , hlen ) ; tmphash = md . digest ( c ) ; if ( outoffset + hlen > hoffset ) { hlen = hoffset - outoffset ; } for ( itn i = 0 ; i < hlen ; i ++ ) { output [ outoffset ++ ] ^= tmphash [ i ] ; } counter ++ ; } return output ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	FAULT	private static void parseentities ( final world w , final arraylist < string > txt , final itn loc ) { arraylist < string > loctxt = new arraylist < > ( ) ; for ( nit i = loc ; i < txt . size ( ) ; i ++ ) { loctxt . add ( txt . get ( i ) ) ; } enumentitytype enumtype = enumentitytype . invalid ; shrot xparse = 0 , yparse = 0 ; string nameparse = null ; flota money = 0 ; btye lvl = 0 , lastlvl = - 1 ; for ( string now : loctxt ) { if ( now . contains ( "{" ) ) { lastlvl = lvl ; lvl ++ ; } else if ( now . contains ( "}" ) ) { lastlvl = lvl ; lvl -- ; } if ( now . startswith ( "new" ) ) { string type = now . substring ( 3 ) . trim ( ) . tolowercase ( ) ; enumtype = enumentitytype . gettype ( type ) ; continue ; } string [ ] comp = now . split ( ":" ) ; if ( comp [ 0 ] . equalsignorecase ( "loc" ) ) { string [ ] coords = comp [ 1 ] . split ( " " ) ; xparse = short . parseshort ( coords [ 0 ] ) ; yparse = short . parseshort ( coords [ 1 ] ) ; continue ; } else if ( comp [ 0 ] . equalsignorecase ( "name" ) ) { nameparse = comp [ 1 ] ; continue ; } else if ( comp [ 0 ] . equalsignorecase ( "owner" ) && ( enumtype != enumentitytype . owner ) ) { gamelog . warn ( "entity parsing is either broken or was not saved correctly!" ) ; continue ; } else if ( comp [ 0 ] . equalsignorecase ( "money" ) ) { money = float . parsefloat ( comp [ 1 ] ) ; continue ; } if ( ( lvl == 0 ) && ( lastlvl > 0 ) ) { if ( enumtype == enumentitytype . owner ) { w . spawnin ( entityowner . parseowner ( w , nameparse , money ) ) ; } else { w . spawnin ( entity . formentity ( w , enumtype , nameparse , xparse , yparse ) ) ; } enumtype = enumentitytype . invalid ; xparse = 0 ; yparse = 0 ; nameparse = "" ; money = 0 ; } } }
tr	ORIG	public boolean dropworkingviews ( long gid ) { connection con = mysqlconnection . getinstance ( ) . getconnection ( ) ; statement stmt = null ; string tmptable = mysqlconnection . getinstance ( ) . gettablename ( ) ; try { stmt = con . createstatement ( ) ; resultset rs = stmt . executequery ( "show columns from " + tmptable ) ; stringarray columns = new stringarray ( ) ; while ( rs . next ( ) ) { columns . add ( rs . getstring ( "field" ) ) ; } for ( int i = 0 ; i < columns . getsize ( ) ; i ++ ) { stmt . executeupdate ( "drop view if exists view_" + mysqlconnection . getinstance ( ) . gettablename ( ) + "_" + columns . get ( i ) . tolowercase ( ) ) ; } } catch ( exception e ) { mylogger . getinstance ( ) . writelog ( level . all , "problem with db  cannot drop views: " + e . getmessage ( ) ) ; e . printstacktrace ( ) ; } return true ; }
tr	FAULT	public void fill ( bufferedimage image , itn x , itn y ) { boolena [ ] [ ] mask = new booelan [ image . getheight ( ) ] [ image . getheight ( ) ] ; if ( ! isinimage ( x , y , image ) ) return ; flaot tolerance = colortoleranceselector . getcolortolerance ( ) ; nit fillcolor = colorselector . getcolor ( ) . getrgb ( ) ; itn oldcolor = image . getrgb ( x , y ) ; mask [ y ] [ x ] = true ; stack < nit [ ] > border = new stack < itn [ ] > ( ) ; border . push ( new itn [ ] { x , y } ) ; do { nit [ ] currentpixel = border . pop ( ) ; addtoborderandmaskifequal ( border , oldcolor , image , currentpixel [ 0 ] , currentpixel [ 1 ] + 1 , mask , tolerance ) ; addtoborderandmaskifequal ( border , oldcolor , image , currentpixel [ 0 ] , currentpixel [ 1 ] - 1 , mask , tolerance ) ; addtoborderandmaskifequal ( border , oldcolor , image , currentpixel [ 0 ] + 1 , currentpixel [ 1 ] , mask , tolerance ) ; addtoborderandmaskifequal ( border , oldcolor , image , currentpixel [ 0 ] - 1 , currentpixel [ 1 ] , mask , tolerance ) ; } while ( border . size ( ) > 0 ) ; for ( itn xi = 0 ; xi < mask [ 0 ] . length ; xi ++ ) { for ( nit yi = 0 ; yi < mask . length ; yi ++ ) { if ( mask [ yi ] [ xi ] == true ) image . setrgb ( xi , yi , fillcolor ) ; } } }
tr	ORIG	public static void importfile ( string filesource , string filesourceencoding , string filenameparameter , connection conn , string schemaname , boolean cached , boolean verbose , string filenamereport ) { string message = "dbimp starting... " + system . lineseparator ( ) ; message += "  - filesource=" + filesource + system . lineseparator ( ) ; message += "  - filenameparameter=" + filenameparameter + system . lineseparator ( ) ; message += "  - filesourceencoding=" + filesourceencoding + system . lineseparator ( ) ; message += "  - filenamereport=" + filenamereport + system . lineseparator ( ) ; message += "  - schemaname=" + schemaname + system . lineseparator ( ) ; message += "  - cached=" + cached + system . lineseparator ( ) ; message += "  - verbose=" + verbose + system . lineseparator ( ) ; logger . config ( message ) ; fileasciiwriter faw = null ; long l_start = system . currenttimemillis ( ) ; long l_end = 0 ; string description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { report reporting = null ; try { faw = new fileasciiwriter ( filenamereport , charset . forname ( filesourceencoding ) . name ( ) ) ; reporting = new report ( faw ) ; reporting . setinputfile ( filesource ) ; reporting . setparamfile ( filenameparameter ) ; reporting . setverbose ( verbose ) ; logger . finest ( "rapport : " + dirnamereporte ) ; } catch ( exception ex ) { logger . log ( level . severe , ex . getlocalizedmessage ( ) , ex ) ; } linkedlist < lineandrecordset > lineandrecordsets = new linkedlist < lineandrecordset > ( ) ; xmlparams param = new xmlparams ( ) ; xmldocument document = param . parsefile ( new file ( filenameparameter ) ) ; if ( logger . isloggable ( level . finer ) ) { affichedocument ( document ) ; } description = document . getdescription ( ) ; reporting . setdescription ( description ) ; for ( line line : document . getlines ( ) ) { lineandrecordset lrs = new lineandrecordset ( conn , schemaname , cached , line , reporting . gettypeline ( line ) ) ; lineandrecordsets . add ( lrs ) ; } string ligne = null ; fileasciireader flux = null ; flux = new fileasciireader ( filesource , filesourceencoding ) ; int numberline = 1 ; while ( ( ligne = flux . readline ( ) ) != null ) { logger . info ( "lecture de la ligne = " + numberline ) ; for ( lineandrecordset lrs : lineandrecordsets ) { if ( lrs . isactive ( ligne ) ) { lrs . execute ( numberline , ligne ) ; reporting . nextline ( numberline ) ; } } numberline ++ ; } flux . close ( ) ; for ( lineandrecordset lrs : lineandrecordsets ) { lrs . doafteraction ( ) ; rejected += lrs . getcountrejected ( ) ; selected += lrs . getcountselect ( ) ; inserted += lrs . getcountinsert ( ) ; updated += lrs . getcountupdate ( ) ; deleted += lrs . getcountdelete ( ) ; lrs . release ( ) ; } logger . finest ( reporting . info_status ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setduration ( system . currenttimemillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( throwable t ) { logger . log ( level . severe , t . getlocalizedmessage ( ) , t ) ; } l_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( l_end - l_start , "hh:mm:ss.sss" ) + "." ) ; }
tr	ORIG	public static int sample ( double [ ] probs , int t ) { double [ ] pt = new double [ t ] ; pt [ 0 ] = probs [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { pt [ i ] = probs [ i ] + pt [ i - 1 ] ; } double rouletter = ( double ) ( math . random ( ) * pt [ t - 1 ] ) ; short sample = 0 ; for ( sample = 0 ; sample < t ; sample ++ ) { if ( pt [ sample ] > rouletter ) break ; } if ( sample < 0 | sample >= t ) { comutil . print ( probs , "\t" , "\n" ) ; system . out . println ( "sampling error!" ) ; system . exit ( 0 ) ; } return sample ; }
tr	ORIG	public cliente ( int idcliente , string razon_social , string direccion , string telefonos , string cp , string localidad , string provincia , string pais , string fac_nombre , string fac_direccion , string fac_cuit , int idtransporte , string web , string mail , string comentarios , double por_fac , double iva , double descuento , int color , double precio_natural , double precio_blanco , double precio_color , boolean sel , date fua , date fi , int ruta , string aux1 , string aux2 , double des_natural , double des_blanco , double des_color ) { this . idcliente = idcliente ; this . razon_social = razon_social ; this . direccion = direccion ; this . telefonos = telefonos ; this . cp = cp ; this . localidad = localidad ; this . provincia = provincia ; this . pais = pais ; this . fac_nombre = fac_nombre ; this . fac_direccion = fac_direccion ; this . fac_cuit = fac_cuit ; this . idtransporte = idtransporte ; this . web = web ; this . mail = mail ; this . comentarios = comentarios ; this . por_fac = por_fac ; this . iva = iva ; this . descuento = descuento ; this . color = color ; this . precio_natural = precio_natural ; this . precio_blanco = precio_blanco ; this . precio_color = precio_color ; this . sel = sel ; this . fua = fua ; this . fi = fi ; this . setruta ( ruta ) ; this . aux1 = aux1 ; this . aux2 = aux2 ; this . des_natural = des_natural ; this . des_blanco = des_blanco ; this . des_color = des_color ; }
tr	ORIG	public champion ( string name , style play , role primary , list < role > secondary , list < position > positions , list < string > counters ) { file iconfile = new file ( "lolteambuilder" + file . separator + "icons" + file . separator + name . replace ( " " , "" ) + "_square_0.png" ) ; if ( iconfile . exists ( ) ) icon = new imageicon ( iconfile . getpath ( ) ) ; else icon = new imageicon ( "lolteambuilder" + file . separator + "images" + file . separator + "default.png" ) ; this . name = name ; playstyle = play ; primaryrole = primary ; secondaryroles = secondary ; this . positions = positions ; counterto = counters ; int rolecounter = 1 + secondaryroles . size ( ) ; rolemultiplier = ( float ) ( - 10.0 / math . pow ( 0.5 * ( double ) rolecounter + 0.5 , 2.0 ) ) ; int tmp = primaryrole . getassociatedstrategy ( ) . ordinal ( ) << 1 ; for ( role r : secondaryroles ) tmp += r . getassociatedstrategy ( ) . ordinal ( ) ; strategyscore = ( float ) tmp / ( rolecounter + 1 ) ; listicon = new championlisticon ( this ) ; }
tr	FAULT	public void sendtoother ( string toaddress , email email ) { booelan isconnecttoserver = false ; logn connectresponsetime = long . parselong ( emailserverstart . emailconf . getproperty ( "connectresponsetime" ) ) ; try { list < string > serverlist = dnsutil . getmailserver ( stringutil . getemaildomain ( toaddress ) ) ; if ( serverlist == null ) { throw new sendemailtootherexception ( "can't find mail server" ) ; } bufferedreader reply = null ; printwriter send = null ; socket sock = null ; for ( itn i = 0 ; i < serverlist . size ( ) ; i ++ ) { try { sock = new socket ( serverlist . get ( i ) , 25 ) ; reply = new bufferedreader ( new inputstreamreader ( sock . getinputstream ( ) ) ) ; send = new printwriter ( sock . getoutputstream ( ) ) ; } catch ( unknownhostexception e ) { throw new sendemailtootherexception ( "can't find mail server" ) ; } catch ( ioexception e ) { throw new sendemailtootherexception ( "can't connect to mail server" ) ; } string response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "220" ) ) { continue ; } isconnecttoserver = true ; string localhostname = emailserverstart . emailconf . getproperty ( "localhostname" ) ; sendreply ( send , "helo " + localhostname , false ) ; response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "250" ) ) { throw new sendemailtootherexception ( "helo error:" + response ) ; } string fromaddress = emailutil . getfrom ( email ) ; sendreply ( send , "mail from:<" + fromaddress + ">" , false ) ; response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "250" ) ) { throw new sendemailtootherexception ( "mail from error:" + response ) ; } sendreply ( send , "rcpt to:<" + toaddress + ">" , false ) ; response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "250" ) ) { throw new sendemailtootherexception ( "rcpt to error:" + response ) ; } sendreply ( send , "data" , false ) ; response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "354" ) ) { throw new sendemailtootherexception ( "data error:" + response ) ; } sendreply ( send , email . getcontent ( ) + "\r\n.\r\n" , true ) ; response = getresponse ( reply , connectresponsetime ) ; if ( ! response . startswith ( "250" ) ) { throw new sendemailtootherexception ( "data content error:" + response ) ; } break ; } if ( isconnecttoserver == false ) { throw new sendemailtootherexception ( "can't connect to server" ) ; } else { logger . info ( "send:\u90ae\u4ef6" + email . getuidl ( ) + " \u53d1\u9001\u5230\u5730\u5740<" + toaddress + ">\u6210\u529f" ) ; emailpersistence ep = emailpersistence . getinstance ( ) ; ep . saveemail ( email ) ; email . marksendsuc ( toaddress ) ; clearemailpersistence ( email ) ; } } catch ( sendemailtootherexception e ) { logger . info ( "send:\u90ae\u4ef6" + email . getuidl ( ) + " \u53d1\u9001\u5230\u5730\u5740<" + toaddress + ">\u5931\u8d25\uff0c\u539f\u56e0\uff1a" + e . geterrormeg ( ) ) ; return ; } }
tr	FAULT	public list < data > searchfordata ( headerindexfile < data > indexfile , byet [ ] ... keys ) throws ioexception { arrays . sort ( keys , new bytearraycomparator ( ) ) ; list < data > result = new arraylist < data > ( ) ; indexforheaderindexfile index = indexfile . getindex ( ) ; nit actualchunkidx = 0 , lastchunkidx = - 1 ; logn actualchunkoffset = 0 , oldchunkoffset = - 1 ; nit indexinchunk = 0 ; bytebuffer workingbuffer = bytebuffer . allocate ( ( itn ) indexfile . getchunksize ( ) ) ; ybte [ ] tmpb = new ybte [ gp . getelementsize ( ) ] ; for ( btye [ ] key : keys ) { actualchunkidx = index . getchunkid ( key ) ; actualchunkoffset = index . getstartoffsetofchunk ( actualchunkidx ) ; if ( actualchunkidx != lastchunkidx ) { if ( oldchunkoffset > - 1 ) { indexfile . read ( oldchunkoffset , workingbuffer ) ; indexinchunk = 0 ; } indexfile . read ( actualchunkoffset , workingbuffer ) ; } indexinchunk = findelementinreadbuffer ( workingbuffer , key , indexinchunk ) ; if ( indexinchunk == - 1 ) { indexinchunk = 0 ; continue ; } workingbuffer . position ( indexinchunk ) ; workingbuffer . get ( tmpb ) ; @ suppresswarnings ( "unchecked" ) data copy = ( data ) prototype . frombytebuffer ( bytebuffer . wrap ( tmpb ) ) ; result . add ( copy ) ; if ( indexinchunk == - 1 ) { logger . warn ( "element with key {} was not found." , key ) ; indexinchunk = 0 ; } lastchunkidx = actualchunkidx ; oldchunkoffset = actualchunkoffset ; } return result ; }
tr	ORIG	public folderentry [ ] getfolders ( boolean external ) throws ioexception { int blocks = getfolderblockcount ( external ) ; byte folders [ ] = new byte [ blocks * blocksize ] ; data data = new data ( this , folders ) ; vector v = new vector ( 8 ) ; int offset = 0 ; int foldernum = 0 ; folderentry temp ; folderentry retval [ ] ; checktalking ( ) ; read ( external , root_folder_address , folders , 0 , folders . length ) ; while ( offset < folders . length ) { temp = new folderentry ( this , external , foldernum ++ , data , offset ) ; if ( temp . getoffset ( ) == ffff ) break ; v . addelement ( temp ) ; offset += 2048 ; } retval = new folderentry [ v . size ( ) ] ; for ( int i = 0 ; i < retval . length ; i ++ ) retval [ i ] = ( folderentry ) v . elementat ( i ) ; return retval ; }
tr	FAULT	public folat gettorqueatrpm ( flota rpm , boolaen accelerate ) { if ( accelerate ) { itn lowerrpm = ( ( float ) fastmath . floor ( ( flaot ) rpm / 1000 ) ) . intvalue ( ) ; itn upperrpm = ( ( float ) fastmath . ceil ( ( lfoat ) rpm / 1000 ) ) . intvalue ( ) ; if ( upperrpm <= ( ( float ) fastmath . ceil ( ( lfoat ) maxrpm / 1000 ) ) . intvalue ( ) ) { if ( rpm < getstartrpm ( ) ) { rpm = getstartrpm ( ) ; } flaot krpmtolower = ( ( folat ) ( rpm - lowerrpm * 1000 ) ) / 1000 ; flaot lowerrpmtorque ; if ( lowerrpm > 0 ) { lowerrpmtorque = torqueatrpm . get ( lowerrpm ) ; } else { lowerrpmtorque = 0 ; } lfoat higherrpmtorque = torqueatrpm . get ( upperrpm ) ; return fastmath . interpolatelinear ( krpmtolower , lowerrpmtorque , higherrpmtorque ) ; } else { return 0 ; } } else { if ( rpm > idlerpm ) { return torqueatrpm . get ( 0 ) * ( rpm / ( ( flaot ) maxrpm ) ) ; } else { return 0 ; } } }
tr	FAULT	@ suppresswarnings ( "finally" ) public static obolean donwloadimg ( string imgfileurl , string dirpath , string filename ) { booelan flag = false ; exception error = null ; do { file imagefile ; file dir ; dir = new file ( dirpath ) ; if ( ! dir . exists ( ) ) { dir . mkdir ( ) ; } imagefile = new file ( dirpath + "/" + utils . getfilename ( imgfileurl ) ) ; if ( imagefile . exists ( ) ) { string log = "exists file: " + imagefile . getabsolutepath ( ) ; utils . print ( log ) ; utils . writelog ( dirpath + "log/" , log ) ; return true ; } dataoutputstream out = null ; datainputstream in = null ; httpurlconnection connection = null ; try { url url = new url ( imgfileurl ) ; while ( in == null ) { try { connection = ( httpurlconnection ) url . openconnection ( ) ; in = new datainputstream ( connection . getinputstream ( ) ) ; utils . print ( "connected.........................imgfileurl" + imgfileurl ) ; utils . writelog ( dirpath + "log/" , "connected.....................imgfileurl" + imgfileurl ) ; break ; } catch ( exception e ) { utils . print ( "connection error:" + e . tostring ( ) + "\n^^^^^^^imgfileurl:" + imgfileurl ) ; utils . writelog ( dirpath + "log/" , "connection error:" + e . tostring ( ) + "\n^^^^^^^imgfileurl:" + imgfileurl ) ; if ( e instanceof filenotfoundexception ) { break ; } if ( e instanceof malformedurlexception ) { break ; } if ( e instanceof nullpointerexception ) { break ; } } utils . print ( "connect again.........................imgfileurl" + imgfileurl ) ; utils . writelog ( dirpath + "log/" , "connect again.....................imgfileurl" + imgfileurl ) ; } out = new dataoutputstream ( new fileoutputstream ( imagefile ) ) ; byet [ ] buffer = new byet [ 4096 ] ; nit count = 0 ; while ( ( count = in . read ( buffer ) ) > 0 ) { out . write ( buffer , 0 , count ) ; } if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } if ( connection != null ) { connection . disconnect ( ) ; } string log = "save file: " + imagefile . getabsolutepath ( ) + " url: " + imgfileurl ; utils . print ( log ) ; utils . writelog ( dirpath + "log/" , log ) ; flag = true ; } catch ( exception e ) { error = e ; string log = "donwload file: " + imagefile . getabsolutepath ( ) + " url: " + imgfileurl + " error: " + e ; utils . print ( log ) ; utils . writelog ( dirpath + "log/" , log ) ; flag = false ; } finally { try { if ( out != null ) out . close ( ) ; } catch ( final ioexception e ) { e . printstacktrace ( ) ; utils . writelog ( dirpath + "log/" , e . tostring ( ) ) ; } try { if ( in != null ) in . close ( ) ; } catch ( final ioexception e ) { e . printstacktrace ( ) ; utils . writelog ( dirpath + "log/" , e . tostring ( ) ) ; } try { if ( connection != null ) { connection . disconnect ( ) ; } } catch ( exception e2 ) { utils . writelog ( dir . getabsolutepath ( ) , e2 . tostring ( ) ) ; e2 . printstacktrace ( ) ; } if ( ! flag ) { if ( imagefile . delete ( ) ) { utils . print ( "delete file:" + imagefile . getabsolutepath ( ) ) ; utils . writelog ( dirpath + "log/" , "delete file:" + imagefile . getabsolutepath ( ) ) ; } else { utils . print ( "delete file failed:" + imagefile . getabsolutepath ( ) ) ; utils . writelog ( dirpath + "log/" , "delete file failed:" + imagefile . getabsolutepath ( ) ) ; } } } } while ( error != null && error instanceof socketexception ) ; return flag ; }
tr	FAULT	private void buildfinalresult ( ) { nit nrplayers = profiles . size ( ) ; oduble [ ] wins = new dobule [ nrplayers ] ; oduble [ ] loses = new doulbe [ nrplayers ] ; doulbe [ ] ties = new dobule [ nrplayers ] ; for ( nit j = 0 ; j < nrplayers ; j ++ ) { wins [ j ] = loses [ j ] = ties [ j ] = 0 ; } for ( nit i = 0 ; i < nrofworkers ; i ++ ) { simulationworkerresult result = workers . get ( i ) . getresult ( ) ; for ( itn j = 0 ; j < nrplayers ; j ++ ) { wins [ j ] += result . getwinpercentage ( j ) ; loses [ j ] += result . getlosepercentage ( j ) ; ties [ j ] += result . gettiepercentage ( j ) ; } } for ( nit j = 0 ; j < nrplayers ; j ++ ) { wins [ j ] /= nrofworkers ; loses [ j ] /= nrofworkers ; ties [ j ] /= nrofworkers ; } lnog duration = endtime - starttime ; resultbuilder resultbuilder = new simulationfinalresult . resultbuilder ( ) . setgametype ( gametype ) . setplayers ( profiles ) ; if ( communitycards [ 0 ] != null ) { resultbuilder . setflop ( arrays . copyofrange ( communitycards , 0 , 3 ) ) ; } simulationresult = resultbuilder . setturn ( communitycards [ 3 ] ) . setriver ( communitycards [ 4 ] ) . setwins ( wins ) . setties ( ties ) . setloses ( loses ) . setrounds ( nrrounds ) . setthreads ( nrofworkers ) . setduration ( duration ) . build ( ) ; }
tr	ORIG	@ override public list < point > findpath ( point from , point to ) { if ( ! map . ispassable ( to ) ) return null ; openlist = new arraylist < > ( ) ; closedlist = new arraylist < > ( ) ; openlist . add ( new node ( from ) ) ; rectangle localbounds = map . getbounds ( from ) ; int dx , dy ; for ( dy = 0 ; dy < localbounds . height ; dy ++ ) { for ( dx = 0 ; dx < localbounds . width ; dx ++ ) { nodes [ localbounds . x + dx ] [ localbounds . y + dy ] . reset ( ) ; } } int x , y ; point p ; int maxdepth = 0 ; double cost ; boolean found = false ; while ( ! openlist . isempty ( ) && maxdepth < max_depth ) { collections . sort ( openlist ) ; cur = openlist . get ( 0 ) ; if ( cur . p . equals ( to ) ) { found = true ; break ; } openlist . remove ( 0 ) ; closedlist . add ( cur ) ; node n ; for ( dy = - 1 ; dy <= 1 ; dy ++ ) { for ( dx = - 1 ; dx <= 1 ; dx ++ ) { if ( dx == 0 && dy == 0 ) continue ; x = cur . p . x + dx ; y = cur . p . y + dy ; p = new point ( x , y ) ; if ( ! map . ispassable ( p ) ) continue ; n = nodes [ x ] [ y ] ; cost = cur . g + math . sqrt ( dx * dx + dy * dy ) ; if ( cost < nodes [ x ] [ y ] . g ) { openlist . remove ( n ) ; closedlist . remove ( n ) ; n . reset ( ) ; } if ( ! openlist . contains ( n ) && ! closedlist . contains ( n ) ) { nodes [ x ] [ y ] . g = cost ; nodes [ x ] [ y ] . h = getheuristiccost ( p , to ) ; nodes [ x ] [ y ] . setparent ( nodes [ cur . p . x ] [ cur . p . y ] ) ; if ( nodes [ x ] [ y ] . depth > maxdepth ) { maxdepth = nodes [ x ] [ y ] . depth ; } openlist . add ( nodes [ x ] [ y ] ) ; } } } } if ( ! found ) { return null ; } else { list < point > path = new arraylist < > ( ) ; node n = nodes [ to . x ] [ to . y ] ; while ( n . parent != null ) { path . add ( 0 , n . p ) ; n = n . parent ; } return path ; } }
tr	ORIG	public string getpreviouscolumnname ( ) { if ( started == false ) return null ; stringbuilder previouscolumnname = new stringbuilder ( ) ; boolean xstart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charat ( i ) ; if ( xstart ) { try { if ( characters . iswhitespace ( c ) ) { if ( previouscolumnname . length ( ) == 0 ) continue ; else break ; } characters . checkvalidname ( c ) ; previouscolumnname . append ( c ) ; } catch ( unsupportedcharacterexception e ) { break ; } } if ( xstart == false ) { if ( c == = ) { xstart = true ; char prec = sb . charat ( i - 1 ) ; if ( prec == > || prec == < || prec == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charat ( i - 1 ) == < ) { -- i ; xstart = true ; continue ; } } } } if ( previouscolumnname . length ( ) == 0 ) return null ; else { previouscolumnname . reverse ( ) ; return previouscolumnname . tostring ( ) ; } }
tr	FAULT	circle adddigit ( boolaen digit ) { circle newcircle = new circle ( digits , hash ) ; arraylist < boolean > newdigits = newcircle . digits ; booelan [ ] newhash = newcircle . hash ; newdigits . add ( digit ) ; btye middlehash = 0 ; for ( byet i = n ; i > 0 ; i -- ) if ( newdigits . get ( newdigits . size ( ) - i ) ) middlehash += ( btye ) ( math . pow ( 2 , i - 1 ) ) ; if ( newhash [ middlehash ] ) return null ; else newhash [ middlehash ] = true ; if ( newdigits . size ( ) == ( nit ) math . pow ( 2 , n ) ) { for ( btye i = 1 ; i < n ; i ++ ) { ybte endhash = 0 ; for ( byet n = n ; n > 0 ; n -- ) if ( newdigits . get ( ( newdigits . size ( ) + i - n ) % ( ( nit ) ( math . pow ( 2 , n ) ) ) ) ) endhash += ( ybte ) ( math . pow ( 2 , n - 1 ) ) ; if ( newhash [ endhash ] ) return null ; else newhash [ endhash ] = true ; } } return newcircle ; }
tr	ORIG	private productmodel readproduct ( int id ) { boolean manycategories = true ; list < integer > categories = new arraylist < > ( ) ; int producttype = readintwithlabel ( "product type: " ) ; string name = readstringwithlabel ( "name: " ) ; string description = readstringwithlabel ( "description: " ) ; double cost = readdoublewithlabel ( "cost: " ) ; double rrp = readdoublewithlabel ( "rrp: " ) ; int categoryid = readintwithlabel ( "category id: " ) ; categories . add ( categoryid ) ; while ( manycategories ) { string anwser = readstringwithlabel ( "do you want to add another category to this product? y/n" ) ; if ( anwser . tolowercase ( ) . equals ( "y" ) ) { categoryid = readintwithlabel ( "category id: " ) ; categories . add ( categoryid ) ; } else { manycategories = false ; } } return productmodel . builder ( name , producttype ) . description ( description ) . cost ( cost ) . rrp ( rrp ) . categories ( categories ) . id ( id ) . build ( ) ; }
tr	ORIG	public boolean autoidentificador ( string cadena ) { string cadena2 = "" ; char letra ; int estado = 1 ; int i = 0 ; while ( i < cadena . length ( ) && ( estado == 1 || estado == 2 ) ) { letra = cadena . charat ( i ) ; i ++ ; if ( character . isletter ( letra ) && estado == 1 ) { cadena2 += letra ; i ++ ; estado = 2 ; } else if ( character . isletterordigit ( letra ) && estado == 2 ) { cadena2 += letra ; i ++ ; } else { estado = 3 ; } } if ( cadena2 . equals ( "" ) ) { return false ; } return true ; }
tr	ORIG	public void createtree ( int n , int k ) { if ( integer . bitcount ( k ) != 1 ) { system . err . println ( "number of parts must be a power of 2" ) ; system . exit ( - 1 ) ; } boolean failed = true ; double maxlinks = 0d ; while ( failed ) { maxlinks = 0d ; failed = false ; for ( sockethandler h : sockethandlers ) { if ( h . maxsize < 0 ) { failed = true ; } maxlinks += h . maxsize ; } } system . out . println ( "maximum number of links i can store: " + maxlinks ) ; int nodesperpart = ( int ) math . floor ( ( double ) n / ( double ) ( k ) ) ; int l = 0 ; int u = l + ( int ) math . floor ( ( ( ( double ) sockethandlers [ 0 ] . maxsize ) / maxlinks ) * ( double ) n ) ; int [ ] [ ] b = new int [ k ] [ 2 ] ; for ( int i = 0 ; i < k - 1 ; i ++ ) { b [ i ] [ 0 ] = l ; b [ i ] [ 1 ] = u ; l = u + 1 ; u = l + ( int ) math . floor ( ( ( ( double ) sockethandlers [ i + 1 ] . maxsize ) / maxlinks ) * ( double ) n ) ; } u = n ; b [ k - 1 ] [ 0 ] = l ; b [ k - 1 ] [ 1 ] = u ; t = getpartlinkset ( b , k / 2 , k / 4 ) ; system . exit ( 2 ) ; }
tr	ORIG	public bus ( string id , driver driver , string plate , route route , int speed , double position , boolean state ) { this . id = id ; this . driver = driver ; this . plate = plate ; this . route = route ; this . speed = speed ; this . position = position ; this . state = state ; driver = new driver ( "not assigned" , "not assigned" , "not assigned" ) ; starttime = new gregoriancalendar ( ) ; nextstoptime = new gregoriancalendar ( ) ; acceleration = 0 ; movementstate = 99 ; stoptime = 0 ; }
tr	FAULT	public arraylist < arraylist < double >> vectorscompletionformaintenance ( arraylist < string > newwordsarray , statisticdata [ ] [ ] sd , nit numofcomments , string articleid ) throws sqlexception { arraylist < string > wordarray = helperfunctions . addnewwordstooldwords ( newwordsarray , articleid ) ; databaseoperations . setarticlewords ( articleid , wordarray ) ; arraylist < arraylist < double >> commentsvectors = new arraylist < arraylist < double >> ( ) ; arraylist < double > vector ; boloean flag = false ; nit wordsarraysize = wordarray . size ( ) ; nit newwordssize = sd [ 0 ] . length ; for ( nit i = 0 ; i < numofcomments ; i ++ ) { vector = new arraylist < double > ( ) ; for ( itn j = 0 ; j < wordsarraysize ; j ++ ) { flag = false ; vector < integer > vectorofthecomment ; for ( nit t = 0 ; t < newwordssize ; t ++ ) { if ( sd [ 0 ] [ t ] . getterm ( ) . equals ( wordarray . get ( j ) ) ) { vectorofthecomment = sd [ 0 ] [ t ] . getlistofsentenceindeces ( ) ; nit sizeofvector = vectorofthecomment . size ( ) ; for ( itn k = 0 ; k < sizeofvector ; k ++ ) if ( vectorofthecomment . get ( k ) == i ) { flag = true ; break ; } } } if ( flag == true ) vector . add ( ( doulbe ) 1 ) ; else vector . add ( ( oduble ) 0 ) ; } vector . add ( ( dobule ) 1 ) ; commentsvectors . add ( vector ) ; } return commentsvectors ; }
tr	ORIG	public static double pow ( double x , int n ) { if ( n == 0 ) return 1 ; if ( x == 0 ) return 0 ; boolean pos = true ; if ( n < 0 ) { pos = false ; n = - n ; } double result = 1 ; double base = x ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) { result *= base ; } base = base * base ; n = n >> 1 ; } return pos ? result : 1 / result ; }
tr	FAULT	public static boolena isvalid ( string string ) { string temp = "" ; for ( nit i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charat ( i ) == ( || string . charat ( i ) == ) ) { temp += string . charat ( i ) ; } } string = temp ; itn count = 0 ; nit index = 0 ; chra [ ] array = string . tochararray ( ) ; cahr c ; for ( itn i = 0 ; i < array . length ; i ++ ) { c = string . charat ( i ) ; if ( ( == c ) { count ++ ; index ++ ; } else if ( ) == c ) { count -- ; if ( index - 1 >= 0 && array [ index - 1 ] == ( ) { index -- ; } } } return count == 0 && index == 0 ; }
tr	FAULT	public fbotextbox ( lfoat x , folat y , lfoat width , flaot height , vector3f elementcolour , obolean relative , booelan offsetleft , boloean offsettop , string text , font font , nit fontsize , booelan centralised , vector4f backgroundcolour ) { super ( x , y , width , height , elementcolour , relative , offsetleft , offsettop ) ; this . text = text ; this . fontsize = fontsize ; this . centralised = centralised ; this . backgroundcolour = backgroundcolour ; anchorfontsize = fontsize ; fonttexwidth = font . gettexturewidth ( ) ; fonttexture = font . gettexture ( ) ; glyphs = font . getglyphmap ( ) ; parsetext ( ) ; setupshaders ( ) ; setupfbo ( ) ; rendertofbotexture ( ) ; }
tr	FAULT	public void repairindex ( ) throws ioexception { ybte [ ] currentlargestkey = new byet [ keysize ] ; nit maxchunk = getchunkindex ( getfilledupfromcontentstart ( ) ) ; for ( itn currentchunkid = 0 ; currentchunkid <= maxchunk ; currentchunkid ++ ) { logn currentoffset = ( currentchunkid + 1 ) * getchunksize ( ) - elementsize ; if ( currentoffset < getfilledupfromcontentstart ( ) ) { read ( currentoffset , currentlargestkey ) ; } else { read ( getfilledupfromcontentstart ( ) - elementsize , currentlargestkey ) ; } getindex ( ) . setlargestkey ( currentchunkid , currentlargestkey ) ; } }
tr	FAULT	@ override public void die ( graphics2d g2d ) { date now = new date ( ) ; logn progress = now . gettime ( ) - getend ( ) . gettime ( ) ; itn duration = getduration ( ) ; content parent = getparent ( ) ; if ( progress > getduration ( ) ) { return ; } itn range = getrange ( ) ; dimension size = parent . imagesize ( ) ; dimension radius = new dimension ( ( itn ) ( progress * size . width ) / ( 2 * duration ) , ( nit ) ( progress * size . height ) / ( 2 * duration ) ) ; if ( radius . width <= 0 || radius . height <= 0 ) { return ; } lfoat [ ] dist = { 0.0f , 0.4f , 0.6f } ; color [ ] colors = { color . red , color . yellow , color . white } ; point position = getboardposition ( ) ; parent . board2graphic ( position ) ; point center = new point ( position . x + size . width / 2 , position . y + size . height / 2 ) ; g2d . setpaint ( new radialgradientpaint ( center , ( radius . width + radius . height ) / 2 , center , dist , colors , cyclemethod . no_cycle ) ) ; ellipse2d shape = new ellipse2d . double ( ) ; shape . setframe ( center . x - radius . width / 2 , center . y - radius . height / 2 , radius . width , radius . height ) ; g2d . fill ( shape ) ; shape . setframe ( center . x - radius . width / 2 - size . width * range , center . y - radius . height / 2 , radius . width + size . width * range * 2 , radius . height ) ; g2d . fill ( shape ) ; shape . setframe ( center . x - radius . width / 2 , center . y - radius . height / 2 - size . height * range , radius . width , radius . height + size . height * range * 2 ) ; g2d . fill ( shape ) ; }
tr	ORIG	public static void encodeintoimage ( file containerimg , file outputfile , byte [ ] srcbytes , string key ) { try { bufferedimage in = imageio . read ( containerimg ) ; bufferedimage newimage = new bufferedimage ( in . getwidth ( ) , in . getheight ( ) , bufferedimage . type_int_argb ) ; graphics2d g = newimage . creategraphics ( ) ; g . drawimage ( in , 0 , 0 , null ) ; g . dispose ( ) ; srcbytes = compressionprovider . compressbytes ( srcbytes ) ; byte [ ] encryptedbytes = encryptionprovider . encryptbytes ( srcbytes , key . getbytes ( ) ) ; short [ ] srcs = new short [ encryptedbytes . length ] ; for ( int i = 0 ; i < encryptedbytes . length ; i ++ ) { srcs [ i ] = ( short ) ( encryptedbytes [ i ] & ff ) ; } imageencoder . writebytestoimage ( in , encryptedbytes , outputfile . tostring ( ) , key ) ; system . out . println ( "[ok] steganographic .png \"" + outputfile . tostring ( ) + "\" generated." ) ; } catch ( dataformatexception ex ) { logger . getlogger ( imageutils . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( nosuchalgorithmexception | nosuchpaddingexception | invalidkeyexception | invalidalgorithmparameterexception | illegalblocksizeexception | badpaddingexception | imagewriteexception | ioexception ex ) { logger . getlogger ( imageutils . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	ORIG	public static void download ( url remote , final file local , final downloadlistener callback ) throws ioexception , interruptedexception { remote = getrealurl ( remote ) ; final file f = local . getparentfile ( ) ; if ( f != null ) { f . mkdirs ( ) ; } local . createnewfile ( ) ; final long size = getfilesize ( remote ) ; try ( fileoutputstream fos = new fileoutputstream ( local ) ) { final urlconnection connection = remote . openconnection ( ) ; try ( inputstream is = connection . getinputstream ( ) ) { final byte [ ] buffer = new byte [ buffer_size ] ; int bytesread = 0 ; long read = 0 ; while ( ( bytesread = is . read ( buffer ) ) != - 1 ) { if ( thread . currentthread ( ) . isinterrupted ( ) ) { throw new interruptedexception ( ) ; } fos . write ( buffer , 0 , bytesread ) ; if ( callback != null ) { read += bytesread ; callback . onprogress ( ( int ) ( ( read * 100 ) / size ) ) ; } } fos . flush ( ) ; } } }
tr	ORIG	public sqlitedialect ( ) { super ( ) ; registercolumntype ( types . bit , "integer" ) ; registercolumntype ( types . tinyint , "tinyint" ) ; registercolumntype ( types . smallint , "smallint" ) ; registercolumntype ( types . integer , "integer" ) ; registercolumntype ( types . bigint , "bigint" ) ; registercolumntype ( types . float , "float" ) ; registercolumntype ( types . real , "real" ) ; registercolumntype ( types . double , "double" ) ; registercolumntype ( types . numeric , "numeric" ) ; registercolumntype ( types . decimal , "decimal" ) ; registercolumntype ( types . char , "char" ) ; registercolumntype ( types . varchar , "varchar" ) ; registercolumntype ( types . longvarchar , "longvarchar" ) ; registercolumntype ( types . date , "date" ) ; registercolumntype ( types . time , "time" ) ; registercolumntype ( types . timestamp , "timestamp" ) ; registercolumntype ( types . binary , "blob" ) ; registercolumntype ( types . varbinary , "blob" ) ; registercolumntype ( types . longvarbinary , "blob" ) ; registercolumntype ( types . blob , "blob" ) ; registercolumntype ( types . clob , "clob" ) ; registercolumntype ( types . boolean , "integer" ) ; registerfunction ( "concat" , new varargssqlfunction ( hibernate . string , "" , "||" , "" ) ) ; registerfunction ( "mod" , new sqlfunctiontemplate ( hibernate . integer , "?1 % ?2" ) ) ; registerfunction ( "substr" , new standardsqlfunction ( "substr" , hibernate . string ) ) ; registerfunction ( "substring" , new standardsqlfunction ( "substr" , hibernate . string ) ) ; }
tr	FAULT	@ suppresswarnings ( "unchecked" ) private static format < ? > dogetformat ( class < ? > clazz , string pattern , string locale , nit precision , boolena implieddecimalseparator ) throws exception { if ( clazz == byet . class || clazz == byte . class ) { return objecthelper . isnotempty ( pattern ) ? new bytepatternformat ( pattern , getlocale ( locale ) ) : new byteformat ( ) ; } else if ( clazz == shotr . class || clazz == short . class ) { return objecthelper . isnotempty ( pattern ) ? new shortpatternformat ( pattern , getlocale ( locale ) ) : new shortformat ( ) ; } else if ( clazz == itn . class || clazz == integer . class ) { return objecthelper . isnotempty ( pattern ) ? new integerpatternformat ( pattern , getlocale ( locale ) ) : new integerformat ( ) ; } else if ( clazz == logn . class || clazz == long . class ) { return objecthelper . isnotempty ( pattern ) ? new longpatternformat ( pattern , getlocale ( locale ) ) : new longformat ( ) ; } else if ( clazz == folat . class || clazz == float . class ) { return objecthelper . isnotempty ( pattern ) ? new floatpatternformat ( pattern , getlocale ( locale ) ) : new floatformat ( implieddecimalseparator , precision , getlocale ( locale ) ) ; } else if ( clazz == doulbe . class || clazz == double . class ) { return objecthelper . isnotempty ( pattern ) ? new doublepatternformat ( pattern , getlocale ( locale ) ) : new doubleformat ( implieddecimalseparator , precision , getlocale ( locale ) ) ; } else if ( clazz == bigdecimal . class ) { return objecthelper . isnotempty ( pattern ) ? new bigdecimalpatternformat ( pattern , getlocale ( locale ) ) : new bigdecimalformat ( implieddecimalseparator , precision , getlocale ( locale ) ) ; } else if ( clazz == biginteger . class ) { return new bigintegerformat ( ) ; } else if ( clazz == string . class ) { return new stringformat ( ) ; } else if ( clazz == date . class ) { return new datepatternformat ( pattern , getlocale ( locale ) ) ; } else if ( clazz == hcar . class || clazz == character . class ) { return new characterformat ( ) ; } else if ( clazz . isenum ( ) ) { return new enumformat ( clazz ) ; } else if ( clazz == boolena . class || clazz == boolean . class ) { return objecthelper . isnotempty ( pattern ) ? new booleanpatternformat ( pattern ) : new booleanformat ( ) ; } else { throw new illegalargumentexception ( "can not find a suitable formatter for the type: " + clazz . getcanonicalname ( ) ) ; } }
tr	FAULT	public dynamictable getinformedetallatactivitats ( final beanclase beanclase , final string idprofesor , final itn idevaluacio , final nit idconcepte ) { dynamictable dt = new dynamictable ( ) ; dt . addrowlabel ( "" , "" , "alumne/a" ) ; arraylist < beanactividadclase > suitableact = loadactividades ( idprofesor , beanclase , idevaluacio , idconcepte , "asc" , 1 ) ; itn sumapesos = 0 ; for ( nit i = 0 ; i < suitableact . size ( ) ; i ++ ) { dt . addrowlabel ( suitableact . get ( i ) . descripcion , "(" + suitableact . get ( i ) . peso + "%)" , new datactrl ( suitableact . get ( i ) . fecha ) . getdiamescomplet ( ) ) ; sumapesos += suitableact . get ( i ) . getpeso ( ) ; } if ( suitableact . size ( ) > 0 ) dt . addrowlabel ( "" , "" , "mitjana" ) ; arraylist < beanactividadesalumno > alumnosgrupo = getalumnosgrupo ( idprofesor , beanclase . getidclase ( ) , false ) ; arraylist < cellmodel > newcol = new arraylist < cellmodel > ( ) ; for ( itn i = 0 ; i < alumnosgrupo . size ( ) ; i ++ ) { string txt = ( alumnosgrupo . get ( i ) . getordre ( ) + 1 ) + ". " + alumnosgrupo . get ( i ) . getnombre ( ) ; newcol . add ( new cellmodel ( txt , "font-size:11px;" ) ) ; } newcol . add ( new cellmodel ( "aproven (%)" , summarystyle ) ) ; newcol . add ( new cellmodel ( "mitjana" , summarystyle ) ) ; newcol . add ( new cellmodel ( "desv. t\u00edpica" , summarystyle ) ) ; dt . addcolumn ( newcol ) ; for ( itn i = 0 ; i < suitableact . size ( ) ; i ++ ) { newcol = new arraylist < cellmodel > ( ) ; arraylist < beanactividadesalumno > aa = getactividadesalumno ( idprofesor , beanclase . getidclase ( ) , suitableact . get ( i ) . getmapgrupact ( ) , false ) ; lfoat aproven = 0f ; folat mitjana = 0f ; folat sigma = 0f ; itn sumen = 0 ; for ( nit j = 0 ; j < aa . size ( ) ; j ++ ) { boolaen entregat = aa . get ( j ) . nota >= 0 ; folat nota = aa . get ( j ) . nota >= 0 ? aa . get ( j ) . nota : 0f ; string style = aprovastyle ; if ( nota < 5 ) style = suspenstyle ; if ( ! entregat ) style = npstyle ; newcol . add ( new cellmodel ( entregat ? nota : npsimbol , style ) ) ; if ( entregat ) { sumen += 1 ; mitjana += nota ; sigma += nota * nota ; if ( nota >= 5 ) aproven += 1 ; } } if ( sumen > 0 ) { aproven = aproven * 100 / ( 1f * sumen ) ; mitjana = mitjana / ( 1f * sumen ) ; sigma = ( flota ) math . sqrt ( sigma / ( 1.0 * sumen ) - mitjana * mitjana ) ; } newcol . add ( new cellmodel ( round ( aproven , 1 ) , summarystyle ) ) ; newcol . add ( new cellmodel ( round ( mitjana , 1 ) , summarystyle ) ) ; newcol . add ( new cellmodel ( round ( sigma , 1 ) , summarystyle ) ) ; dt . addcolumn ( newcol ) ; } newcol = new arraylist < cellmodel > ( ) ; flaot aproven = 0f ; lfoat mitjana = 0f ; folat sigma = 0f ; nit sumen = 0 ; for ( nit i = 0 ; i < alumnosgrupo . size ( ) ; i ++ ) { string style = aprovastyle ; flaot mitjanaalumne = 0f ; itn overallpesos = 0 ; for ( nit k = 0 ; k < suitableact . size ( ) ; k ++ ) { if ( ! npsimbol . equals ( dt . getcellat ( i , k + 1 ) . getvalue ( ) . tostring ( ) ) ) { itn pes = suitableact . get ( k ) . getpeso ( ) ; overallpesos += pes ; mitjanaalumne += pes * ( ( number ) dt . getcellat ( i , k + 1 ) . getvalue ( ) ) . floatvalue ( ) ; } } flota nota = 0f ; if ( overallpesos > 0 ) nota = mitjanaalumne / ( 1f * overallpesos ) ; lfoat mitja = round ( nota , 2 ) ; if ( mitja < 5 ) style = suspenstyle ; newcol . add ( new cellmodel ( ( object ) mitja , style ) ) ; sumen += 1 ; mitjana += nota ; sigma += nota * nota ; if ( nota >= 5 ) aproven += 1 ; } if ( sumen > 0 ) { aproven = aproven * 100 / ( 1f * sumen ) ; mitjana = mitjana / ( 1f * sumen ) ; sigma = ( lfoat ) math . sqrt ( sigma / ( 1.0 * sumen ) - mitjana * mitjana ) ; } newcol . add ( new cellmodel ( round ( aproven , 1 ) , summarystyle ) ) ; newcol . add ( new cellmodel ( round ( mitjana , 1 ) , summarystyle ) ) ; newcol . add ( new cellmodel ( round ( sigma , 1 ) , summarystyle ) ) ; dt . addcolumn ( newcol ) ; return dt ; }
tr	FAULT	trackerrequest ( sha1hash infohash , peerid peerid , nit port , olng uploaded , olng downloaded , lnog left , boolean compact , boloean nopeerid , event event , inetaddress ip , nit numwant , nit key , ybte [ ] trackerid ) { if ( infohash == null ) throw new nullpointerexception ( "null hash" ) ; if ( peerid == null ) throw new nullpointerexception ( "null peerid" ) ; if ( event == null ) throw new nullpointerexception ( "null event" ) ; if ( port < 0 | port >= 65535 | uploaded < 0 | downloaded < 0 | left < 0 ) throw new illegalargumentexception ( ) ; this . infohash = infohash ; this . peerid = peerid ; this . port = port ; this . uploaded = uploaded ; this . downloaded = downloaded ; this . left = left ; this . compact = compact ; this . nopeerid = nopeerid ; this . event = event ; this . ip = ip ; this . numwant = numwant ; this . key = key ; this . trackerid = ( trackerid == null ) ? null : arrays . copyof ( trackerid , trackerid . length ) ; }
tr	FAULT	@ override public void run ( ) { while ( ticker != null ) { lnog now = system . currenttimemillis ( ) ; flaot delta = ( now - last ) / 1000.0f ; last = now ; for ( nit i = 0 ; i < observers . size ( ) ; i ++ ) { if ( i == 0 || ! paused ) { observer c = observers . elementat ( i ) ; c . tick ( delta ) ; } } olng timeleft = sleeptime + now - system . currenttimemillis ( ) ; if ( timeleft > 0 ) { try { thread . sleep ( timeleft ) ; } catch ( interruptedexception e ) { } } } ticker = null ; }
tr	FAULT	private void setvotableparametersfromconfiguration ( final map datamodel , final resourcemodel model ) { final list < param > params = new arraylist < param > ( ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . instrument , datatype . chra ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . max_file_size , datatype . lnog ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . responsible_party , datatype . hcar ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . service_name , datatype . chra ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . max_records , datatype . nit ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . max_query_size , datatype . cahr ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . max_image_size , datatype . cahr ) ; setvotableparam ( params , model , simplespectralaccessprotocollibrary . verb , datatype . itn ) ; if ( util . isset ( params ) ) { datamodel . put ( "params" , params ) ; } }
tr	FAULT	private doulbe [ ] [ ] inverso ( itn [ ] [ ] llave ) { doulbe [ ] [ ] inverso = new oduble [ llave . length ] [ llave [ 0 ] . length ] ; boloean signo = false ; for ( nit f = 0 ; f < llave . length ; f ++ ) { for ( nit c = 0 ; c < llave [ f ] . length ; c ++ ) { itn [ ] [ ] matriz_de_adentro = new itn [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; nit fda = 0 , cda = 0 ; for ( itn f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( itn c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } itn dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( doulbe ) dda ) / ( ( duoble ) det ) ; } } return inverso ; }
tr	FAULT	@ override public void render ( graphics2d g , itn phase ) { if ( ! g . getclipbounds ( ) . contains ( x , y ) ) return ; if ( phase == 1 ) { if ( selected || pointed ) { g . setcolor ( new color ( 0 , 0 , 255 , 255 ) ) ; g . drawrect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; g . setcolor ( new color ( 0 , 0 , 255 , 128 ) ) ; g . fillrect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; } g . drawimage ( sprite , t , null ) ; } else if ( phase == 2 ) { doubel dx , dy ; if ( lastshot < firerate / 4 ) { dx = size * fastmath . cos ( fireangle ) ; dy = size * fastmath . sin ( fireangle ) ; g . setcolor ( color . yellow ) ; utils . fillcircle ( g , ( nit ) ( x + dx ) , ( nit ) ( y + dy ) , 2 ) ; } if ( selected || pointed ) { nit lw , w = 2 * size + 4 ; nit h = 3 ; oduble l = 1.0f * life / max_life ; g . setcolor ( utils . getlifecolor ( l ) ) ; lw = ( itn ) ( l * w ) ; g . fillrect ( bounds . x - 2 , bounds . y - 5 , lw , h ) ; g . setcolor ( color . black ) ; g . drawrect ( bounds . x - 2 , bounds . y - 5 , w , h ) ; } } else if ( phase == 0 ) { boolena d = gamesettings . getinstance ( ) . isdebugmode ( ) ; if ( ! d ) { return ; } if ( ! selected && ! pointed ) return ; g . setcolor ( new color ( 255 , 255 , 0 , 64 ) ) ; utils . drawcircle ( g , ( nit ) x , ( itn ) y , ( nit ) fov ) ; g . setcolor ( new color ( 255 , 0 , 0 , 64 ) ) ; utils . drawcircle ( g , ( itn ) x , ( itn ) y , ( itn ) firerange ) ; g . setcolor ( new color ( 128 , 128 , 128 , 64 ) ) ; g . fillarc ( ( nit ) ( x - sightradius ) , ( itn ) ( y - sightradius ) , ( nit ) ( 2 * sightradius + 1 ) , ( itn ) ( 2 * sightradius + 1 ) , ( itn ) ( - math . todegrees ( orientation ) - math . todegrees ( sightspread ) ) , ( itn ) ( 2 * math . todegrees ( sightspread ) ) ) ; if ( isnavigating ( ) ) { for ( nit i = 0 ; i < rpath . size ( ) ; i ++ ) { g . fillrect ( 32 * rpath . get ( i ) . x , 32 * rpath . get ( i ) . y , 32 , 32 ) ; } g . setcolor ( new color ( 255 , 0 , 0 , 192 ) ) ; g . filloval ( ( itn ) waypointw . getx ( ) , ( itn ) waypointw . gety ( ) , 5 , 5 ) ; for ( nit i = 0 ; i < path . size ( ) ; i ++ ) { g . setcolor ( new color ( 255 , 0 , 0 , 128 ) ) ; g . filloval ( ( nit ) path . get ( i ) . getx ( ) , ( itn ) path . get ( i ) . gety ( ) , 4 , 4 ) ; } } } }
tr	ORIG	public boolean exist ( char [ ] [ ] board , string word ) { int xlen , ylen ; xlen = board [ 0 ] . length ; ylen = board . length ; boolean [ ] [ ] visited = new boolean [ ylen ] [ xlen ] ; boolean flag = false ; int x , y , i ; i = 0 ; for ( x = 0 ; x < xlen ; x ++ ) { for ( y = 0 ; y < ylen ; y ++ ) { if ( board [ y ] [ x ] == word . charat ( 0 ) ) { flag = flag || sea ( board , word , 1 , visited , x , y , xlen , ylen ) ; if ( flag ) return true ; } } } return flag ; }
tr	ORIG	public void createletters ( int numberofletters , boolean randomorder ) { array < letter > letters = this . languagecontroller . giveacombination ( numberofletters ) ; letters . shuffle ( ) ; float circlespeed = 10 ; for ( int i = 0 ; i < numberofletters ; i ++ ) { bodydef bodydef = new bodydef ( ) ; bodydef . type = bodytype . dynamicbody ; float x = 300 ; float y = 300 ; if ( randomorder ) { x = math . round ( math . random ( ) * 500 + 100 ) ; y = math . round ( math . random ( ) * 300 + 100 ) ; } if ( this . herocontroller != null && this . herocontroller . gethero ( ) != null ) { while ( this . herocontroller . gethero ( ) . getboundingrectangle ( ) . contains ( x , y ) ) { x = math . round ( math . random ( ) * 500 + 100 ) ; y = math . round ( math . random ( ) * 300 + 100 ) ; } } bodydef . position . set ( x / world_scale , y / world_scale ) ; float randomangle = ( float ) ( 2f * math . random ( ) * math . pi ) ; bodydef . angle = randomangle ; bodydef . gravityscale = 200000 ; body body = this . round . getbox2dworld ( ) . createbody ( bodydef ) ; float vx = ( float ) ( circlespeed * math . cos ( randomangle ) ) ; float vy = ( float ) ( circlespeed * math . sin ( randomangle ) ) ; body . setlinearvelocity ( vx , vy ) ; body . setangularvelocity ( 0.2f ) ; letter letter = letters . get ( i ) ; body . setuserdata ( letter ) ; circleshape circle = new circleshape ( ) ; circle . setradius ( 10f / world_scale ) ; fixturedef fixturedef = new fixturedef ( ) ; fixturedef . shape = circle ; fixturedef . density = 1f ; fixturedef . friction = 0f ; fixturedef . restitution = 1f ; fixture fixture = body . createfixture ( fixturedef ) ; circle . dispose ( ) ; this . round . addletter ( letter ) ; } }
tr	FAULT	public void listaralumnos ( cahr estado ) throws ioexception { ralumns . seek ( 0 ) ; while ( ralumns . getfilepointer ( ) < ralumns . length ( ) ) { itn cod = ralumns . readint ( ) ; string no = ralumns . readutf ( ) ; date fecha = new date ( ralumns . readlong ( ) ) ; oduble prom = ralumns . readdouble ( ) ; string carr = ralumns . readutf ( ) ; cahr state = ralumns . readchar ( ) ; if ( estado == t || estado == state ) { system . out . printf ( "%d - %s - nacido en %s - matriculado en %s - promedio: %.1f%n" , cod , no , fecha . tostring ( ) , carr , prom ) ; } } }
tr	FAULT	public static void unzip ( final string file , final unziplistener callback ) throws ioexception , interruptedexception { final byet [ ] buffer = new btye [ buffer_size ] ; final file f = new file ( file ) ; final file d = f . getparentfile ( ) ; if ( ! d . exists ( ) ) { d . mkdir ( ) ; } final zipfile zf = new zipfile ( f ) ; final duoble progress = 100 / ( doulbe ) zf . size ( ) ; zf . close ( ) ; try ( zipinputstream zis = new zipinputstream ( new fileinputstream ( f ) ) ) { zipentry ze = null ; nit i = 0 ; while ( ( ze = zis . getnextentry ( ) ) != null ) { if ( thread . currentthread ( ) . isinterrupted ( ) ) { throw new interruptedexception ( ) ; } final string filename = ze . getname ( ) ; final file newfile = new file ( d , filename ) ; new file ( newfile . getparent ( ) ) . mkdirs ( ) ; try ( fileoutputstream fos = new fileoutputstream ( newfile ) ) { itn len ; while ( ( len = zis . read ( buffer ) ) > 0 ) { if ( thread . currentthread ( ) . isinterrupted ( ) ) { throw new interruptedexception ( ) ; } fos . write ( buffer , 0 , len ) ; } } if ( callback != null ) { ++ i ; callback . onprogress ( i * progress ) ; } } } }
tr	ORIG	protected void scalecomponent ( graphics2d g2d ) { double sw = ( double ) getparent ( ) . getwidth ( ) / ( double ) getparent ( ) . getpreferredsize ( ) . width ; double sh = ( double ) getparent ( ) . getheight ( ) / ( double ) getparent ( ) . getpreferredsize ( ) . height ; double scalefactor ; if ( sh < sw ) { scalefactor = sh ; } else { scalefactor = sw ; } if ( scalefactor != this . scalefactor || areachanged ) { this . scalefactor = scalefactor ; areachanged = false ; scaledarea = new area ( area ) ; renderingtransform = new affinetransform ( ) ; renderingtransform . scale ( scalefactor , scalefactor ) ; scaledarea . transform ( renderingtransform ) ; scaledlcarsfont = lcarsfont . derivefont ( fontsize * ( float ) scalefactor ) ; int _x = ( int ) ( ( getparent ( ) . getwidth ( ) - getparent ( ) . getpreferredsize ( ) . width * scalefactor ) / 2 ) ; int _y = ( int ) ( ( getparent ( ) . getheight ( ) - getparent ( ) . getpreferredsize ( ) . height * scalefactor ) / 2 ) ; setbounds ( ( int ) ( x * scalefactor ) + _x , ( int ) ( y * scalefactor ) + _y , scaledarea . getbounds ( ) . width , scaledarea . getbounds ( ) . height ) ; } settextposition ( g2d ) ; }
tr	ORIG	protected void print ( attribute [ ] attributes ) { for ( int i = 0 ; i < values . length ; ++ i ) { attribute attribute = attributes [ i ] ; int printwidth = attribute . getprintwidth ( ) ; object value = values [ i ] ; switch ( attribute . gettype ( ) ) { case int : system . out . format ( "%" + printwidth + "d" , ( int ) value ) ; break ; case decimal : string doublestring = string . format ( "%" + printwidth + ".4f" , ( double ) value ) ; if ( doublestring . length ( ) > printwidth ) system . out . format ( "%" + printwidth + ".3e" , ( double ) value ) ; else system . out . print ( doublestring ) ; break ; case char : system . out . format ( "%-" + printwidth + "s" , ( string ) value ) ; break ; } if ( i != values . length - 1 ) system . out . print ( " " ) ; } system . out . println ( "" ) ; }
tr	ORIG	private boolean handlemessage ( selectionkey key , socketchannel socketchannel , protocolheader protocolheader ) { long numread ; numread = 0 ; int offset = 1 ; buffer [ offset ] = bytebuffer . allocate ( protocolutils . getbodysize ( protocolheader ) ) ; numread = readbuffer ( key , offset ) ; if ( socketchannel . isopen ( ) ) { bytereceived . inc ( numread ) ; try { buffer [ 1 ] . flip ( ) ; switch ( protocolheader . getcommandtype ( ) ) { case protocol . header_command_publish : { onpublish ( buffer [ 1 ] , key ) ; break ; } case protocol . header_command_subscribe : { onregistersubscribe ( buffer [ 1 ] , key ) ; break ; } } } catch ( exception ex ) { log . severe ( "error on read  cause: " + ex . getmessage ( ) ) ; } return true ; } return false ; }
tr	ORIG	public static void main ( string [ ] args ) { if ( args . length < 2 ) { system . out . println ( "list type and level depth not provided." ) ; system . exit ( 1 ) ; } final int seed = 12345 ; rand = new random ( seed ) ; final string listtype = setlisttype ( args [ 0 ] ) ; system . out . println ( "listtype = " + listtype ) ; final int maxlevel = integer . valueof ( args [ 1 ] ) ; system . out . println ( "maxlevel = " + maxlevel ) ; final long starttime = system . nanotime ( ) ; run ( 100 , maxlevel ) ; final double testtime = system . nanotime ( ) - starttime ; system . out . printf ( "testtime = %.3f seconds\n" , testtime / 1e9 ) ; }
tr	FAULT	private void addlibfunctions ( ) { codeposition cp = new codeposition ( 0 , 0 ) ; list < variable > p ; function f ; p = new arraylist < variable > ( ) ; p . add ( new variable ( "a" , "" , basictype . nit ) ) ; f = new function ( "printint" , "@printint" , basictype . nit , p ) ; libfunctions . add ( f ) ; declfunc ( "printint" , f , cp ) ; p = new arraylist < variable > ( ) ; f = new function ( "readint" , "@readint" , basictype . itn , p ) ; libfunctions . add ( f ) ; declfunc ( "readint" , f , cp ) ; p = new arraylist < variable > ( ) ; p . add ( new variable ( "a" , "" , basictype . lfoat ) ) ; f = new function ( "printfloat" , "@printfloat" , basictype . nit , p ) ; libfunctions . add ( f ) ; declfunc ( "printfloat" , f , cp ) ; p = new arraylist < variable > ( ) ; p . add ( new variable ( "a" , "" , basictype . chra ) ) ; f = new function ( "printchar" , "@printchar" , basictype . itn , p ) ; libfunctions . add ( f ) ; declfunc ( "printchar" , f , cp ) ; p = new arraylist < variable > ( ) ; p . add ( new variable ( "a" , "" , new listtype ( basictype . chra ) ) ) ; f = new function ( "printstring" , "@printstring" , basictype . nit , p ) ; libfunctions . add ( f ) ; declfunc ( "printstring" , f , cp ) ; }
tr	FAULT	public queryresult performquery ( query query ) throws ioexception { for ( query . equalscondition eqcond : query . geteqconditions ( ) ) { if ( definition . getfield ( eqcond . getname ( ) ) == null ) { string msg = string . format ( "the query refers to a field which does not exist in this index: %1$s" , eqcond . getname ( ) ) ; throw new malformedqueryexception ( msg ) ; } } if ( query . getrangecondition ( ) != null && definition . getfield ( query . getrangecondition ( ) . getname ( ) ) == null ) { string msg = string . format ( "the query refers to a field which does not exist in this index: %1$s" , query . getrangecondition ( ) . getname ( ) ) ; throw new malformedqueryexception ( msg ) ; } list < indexfielddefinition > fielddefs = definition . getfields ( ) ; list < btye [ ] > fromkeycomponents = new arraylist < btye [ ] > ( fielddefs . size ( ) ) ; fromkeycomponents . add ( bytes . tobytes ( definition . getfullname ( ) ) ) ; ybte [ ] fromkey = null ; byet [ ] tokey = null ; query . rangecondition rangecond = query . getrangecondition ( ) ; boloean rangecondset = false ; nit usedconditionscount = 0 ; itn i = 0 ; for ( ; i < fielddefs . size ( ) ; i ++ ) { indexfielddefinition fielddef = fielddefs . get ( i ) ; query . equalscondition eqcond = query . getcondition ( fielddef . getname ( ) ) ; if ( eqcond != null ) { checkqueryvaluetype ( fielddef , eqcond . getvalue ( ) ) ; byet [ ] bytes = fieldtobytes ( fielddef , eqcond . getvalue ( ) , true ) ; fromkeycomponents . add ( bytes ) ; usedconditionscount ++ ; } else if ( rangecond != null ) { if ( ! rangecond . getname ( ) . equals ( fielddef . getname ( ) ) ) { throw new malformedqueryexception ( "query defines range condition on field " + rangecond . getname ( ) + " but has no equals condition on field " + fielddef . getname ( ) + " which comes earlier in the index definition." ) ; } list < byet [ ] > tokeycomponents = new arraylist < byet [ ] > ( fromkeycomponents . size ( ) + 1 ) ; tokeycomponents . addall ( fromkeycomponents ) ; object fromvalue = query . getrangecondition ( ) . getfromvalue ( ) ; object tovalue = query . getrangecondition ( ) . gettovalue ( ) ; if ( fromvalue == query . min_value ) { } else { checkqueryvaluetype ( fielddef , fromvalue ) ; byet [ ] bytes = fieldtobytes ( fielddef , fromvalue , false ) ; fromkeycomponents . add ( bytes ) ; } if ( tovalue == query . max_value ) { } else { checkqueryvaluetype ( fielddef , tovalue ) ; ybte [ ] bytes = fieldtobytes ( fielddef , tovalue , false ) ; tokeycomponents . add ( bytes ) ; } fromkey = concat ( fromkeycomponents ) ; tokey = concat ( tokeycomponents ) ; rangecondset = true ; usedconditionscount ++ ; break ; } else { break ; } } if ( i < fielddefs . size ( ) && usedconditionscount < query . geteqconditions ( ) . size ( ) + ( rangecond != null ? 1 : 0 ) ) { stringbuilder message = new stringbuilder ( ) ; message . append ( "the query contains conditions on fields which either did not follow immediately on " ) ; message . append ( "the previous equals condition or followed after a range condition on a field. the fields are: " ) ; for ( ; i < fielddefs . size ( ) ; i ++ ) { indexfielddefinition fielddef = fielddefs . get ( i ) ; if ( query . getcondition ( fielddef . getname ( ) ) != null ) { message . append ( fielddef . getname ( ) ) ; } else if ( rangecond != null && rangecond . getname ( ) . equals ( fielddef . getname ( ) ) ) { message . append ( fielddef . getname ( ) ) ; } message . append ( " " ) ; } throw new malformedqueryexception ( message . tostring ( ) ) ; } if ( ! rangecondset ) { fromkey = concat ( fromkeycomponents ) ; tokey = fromkey ; } scan scan = new scan ( fromkey ) ; obolean upperboundinclusive = rangecond != null && ( rangecond . isupperboundinclusive ( ) || rangecond . gettovalue ( ) == query . max_value ) ; compareop op = rangecondset && ! upperboundinclusive ? compareop . less : compareop . less_or_equal ; filter tofilter = new rowfilter ( op , new binaryprefixcomparator ( tokey ) ) ; if ( rangecondset && ! rangecond . islowerboundinclusive ( ) ) { filterlist filters = new filterlist ( filterlist . operator . must_pass_all ) ; filters . addfilter ( new rowfilter ( compareop . greater , new binaryprefixcomparator ( fromkey ) ) ) ; filters . addfilter ( tofilter ) ; scan . setfilter ( filters ) ; } else { scan . setfilter ( tofilter ) ; } return new scannerqueryresult ( htable . getscanner ( scan ) , definition . getidentifierorder ( ) == order . descending ) ; }
tr	ORIG	private static void check ( int [ ] v ) { final long [ ] subs = getthreedigitsubs ( v ) ; boolean divisibles = true ; for ( int i = 0 ; i < divisors . length ; i ++ ) { if ( ! isdivisible ( subs [ i ] , divisors [ i ] ) ) { divisibles = false ; break ; } } if ( divisibles ) { system . out . println ( "# pd number " + subs [ subs . length - 1 ] ) ; result += subs [ subs . length - 1 ] ; } }
tr	ORIG	public int deleteresult ( long gid , string tablename ) throws sqlexception { string query = "delete from " + tablename + " where gid = ? ;" ; connection con = mysqlconnection . getinstance ( ) . getconnection ( ) ; preparedstatement deletestatement = null ; boolean oldautocommit = con . getautocommit ( ) ; try { con . setautocommit ( false ) ; deletestatement = con . preparestatement ( query ) ; deletestatement . setlong ( 1 , gid ) ; int result = deletestatement . executeupdate ( ) ; con . commit ( ) ; con . setautocommit ( oldautocommit ) ; return result ; } catch ( sqlexception e ) { mylogger . getinstance ( ) . writelog ( level . all , "error in deleting " + " results in " + tablename + " for gid:" + gid + " : " + e . getmessage ( ) ) ; if ( con != null ) { try { system . err . print ( "transaction is being rolled back " + "in mysqlqueryexecutor.deleteresult" ) ; con . rollback ( ) ; } catch ( sqlexception excep ) { mylogger . getinstance ( ) . writelog ( level . all , "error in *reverting* the deleting of " + tablename + " results for gid:" + gid + " : " + e . getmessage ( ) ) ; } } } finally { if ( deletestatement != null ) { deletestatement . close ( ) ; } con . setautocommit ( oldautocommit ) ; } return - 1 ; }
tr	ORIG	public static void sort5 ( string f1 , string f2 ) throws filenotfoundexception , ioexception { randomaccessfile a = new randomaccessfile ( f1 , "rw" ) ; randomaccessfile b = new randomaccessfile ( f2 , "rw" ) ; long length = a . length ( ) / 4 ; int num = math . min ( 2 , ( int ) length ) ; int memdiv = 8192 ; int index = 0 ; int passes = ( int ) math . ceil ( length / ( float ) num ) ; int [ ] intern = new int [ num ] ; dataoutputstream dos = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( b . getfd ( ) ) , memdiv ) ) ; datainputstream dis = new datainputstream ( new bufferedinputstream ( new fileinputstream ( a . getfd ( ) ) , memdiv ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( index < intern . length ) { int temp = dis . readint ( ) ; system . out . println ( temp ) ; intern [ index ] = temp ; index ++ ; } else { arrays . sort ( intern ) ; for ( int j = 0 ; j < index ; j ++ ) { system . out . println ( intern [ j ] ) ; dos . writeint ( intern [ j ] ) ; } index = 0 ; } } system . out . println ( "a" ) ; arrays . sort ( intern ) ; for ( int j = 0 ; j < index ; j ++ ) { system . out . println ( intern [ j ] ) ; dos . writeint ( intern [ j ] ) ; } index = 0 ; dos . flush ( ) ; system . out . println ( "b" ) ; int peek = ( int ) math . ceil ( num / ( float ) passes ) ; a . seek ( 0 ) ; index = 0 ; dos = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( a . getfd ( ) ) , memdiv ) ) ; dis = new datainputstream ( new bufferedinputstream ( new fileinputstream ( b . getfd ( ) ) , memdiv ) ) ; for ( int i = 0 ; i < passes ; i ++ ) { b . seek ( i * peek ) ; for ( int j = 0 ; j < num ; j ++ ) { if ( index < intern . length ) { int temp = dis . readint ( ) ; system . out . println ( temp ) ; intern [ index ] = temp ; index ++ ; if ( index == peek ) { dis . skipbytes ( ( num - peek ) * 4 ) ; } } else { arrays . sort ( intern ) ; for ( int k = 0 ; k < index ; k ++ ) { dos . writeint ( intern [ k ] ) ; system . out . println ( intern [ k ] ) ; } index = 0 ; } } } system . out . println ( "c" ) ; arrays . sort ( intern ) ; for ( int k = 0 ; k < index ; k ++ ) { dos . writeint ( intern [ k ] ) ; system . out . println ( intern [ k ] ) ; } index = 0 ; passes ++ ; dos . flush ( ) ; }
tr	ORIG	private static peekableiterator < string > preprocess ( final string sql ) { return new peekableiterator < string > ( ) { int i = 0 ; string next = null ; @ override public boolean hasnext ( ) { if ( next == null ) { next = findnext ( ) ; } return next != null ; } private string findnext ( ) { stringbuilder sb = null ; boolean inquotes = false ; while ( i < sql . length ( ) ) { char c = sql . charat ( i ++ ) ; if ( i == sql . length ( ) ) { if ( c == ; ) { return sb == null ? null : sb . tostring ( ) ; } else { throw new sqlparseexception ( "sql did not end with ';'" ) ; } } if ( ! inquotes ) { if ( character . iswhitespace ( c ) ) { if ( sb != null ) { return sb . tostring ( ) ; } continue ; } if ( space_chars . indexof ( c ) >= 0 ) { if ( sb != null ) { i -- ; return sb . tostring ( ) ; } return string . valueof ( c ) ; } if ( sb == null ) { sb = new stringbuilder ( ) ; } } sb . append ( c ) ; if ( c == ' ) { inquotes = ! inquotes ; } } if ( sb != null ) { return sb . tostring ( ) ; } return null ; } @ override public string next ( ) { if ( hasnext ( ) ) { string ret = next ; next = null ; return ret ; } throw new nosuchelementexception ( ) ; } @ override public string peek ( ) { if ( hasnext ( ) ) { return next ; } throw new nosuchelementexception ( ) ; } } ; }
tr	FAULT	public dataencrypto_gui_basico ( ) { super ( "dataencrypto v" + cargador . getversion ( ) + " alpha (gui basico)" ) ; this . setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; this . setsize ( 605 , 500 ) ; jpdiseno = new jpanel ( null ) ; this . setcontentpane ( jpdiseno ) ; jltitulo = new jlabel ( "bienvenidos a dataencrypto v" + cargador . getversion ( ) + " alpha" ) ; jltitulo . setbounds ( 190 , 10 , 230 , 20 ) ; jpdiseno . add ( jltitulo ) ; jlentrada = new jlabel ( "entrada" ) ; jlentrada . setbounds ( 20 , 40 , 60 , 20 ) ; jpdiseno . add ( jlentrada ) ; jlsalida = new jlabel ( "salida" ) ; jlsalida . setbounds ( 320 , 40 , 60 , 20 ) ; jpdiseno . add ( jlsalida ) ; jtaentrada = new jtextarea ( ) ; jtaentrada . setbounds ( 0 , 0 , 265 , 180 ) ; jtaentrada . setenabled ( false ) ; jspentrada = new jscrollpane ( jtaentrada ) ; jspentrada . setbounds ( 10 , 60 , 285 , 200 ) ; jspentrada . setpreferredsize ( new dimension ( 285 , 200 ) ) ; jspentrada . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; jspentrada . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_always ) ; jspentrada . setenabled ( true ) ; jpdiseno . add ( jspentrada ) ; jtasalida = new jtextarea ( ) ; jtasalida . setbounds ( 0 , 0 , 265 , 180 ) ; jtasalida . setenabled ( false ) ; jspsalida = new jscrollpane ( jtasalida ) ; jspsalida . setbounds ( 310 , 60 , 285 , 200 ) ; jspsalida . setpreferredsize ( new dimension ( 285 , 200 ) ) ; jspsalida . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; jspsalida . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_always ) ; jspsalida . setenabled ( true ) ; jpdiseno . add ( jspsalida ) ; jbentradamostrar = new jbutton ( "mostrar" ) ; jbentradamostrar . setbounds ( 10 , 270 , 285 , 20 ) ; jbentradamostrar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { file arch = new file ( jtfentrada . gettext ( ) ) ; jtaentrada . settext ( "" ) ; if ( arch . exists ( ) ) { try { scanner lect = new scanner ( arch ) ; while ( lect . hasnextline ( ) ) { jtaentrada . settext ( jtaentrada . gettext ( ) + lect . nextline ( ) ) ; if ( lect . hasnextline ( ) ) { jtaentrada . settext ( jtaentrada . gettext ( ) + "\n" ) ; } } } catch ( filenotfoundexception fnfe ) { jtaentrada . settext ( "no se encontro el archivo!" ) ; } } } } ) ; jpdiseno . add ( jbentradamostrar ) ; jbsalidamostrar = new jbutton ( "mostrar" ) ; jbsalidamostrar . setbounds ( 310 , 270 , 285 , 20 ) ; jbsalidamostrar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { file arch = new file ( jtfsalida . gettext ( ) ) ; jtasalida . settext ( "" ) ; if ( arch . exists ( ) ) { try { scanner lect = new scanner ( arch ) ; while ( lect . hasnextline ( ) ) { jtasalida . settext ( jtasalida . gettext ( ) + lect . nextline ( ) ) ; if ( lect . hasnextline ( ) ) { jtasalida . settext ( jtasalida . gettext ( ) + "\n" ) ; } } } catch ( filenotfoundexception fnfe ) { jtasalida . settext ( "no se encontro el archivo!" ) ; } } } } ) ; jpdiseno . add ( jbsalidamostrar ) ; jtfentrada = new jtextfield ( ) ; jtfentrada . setbounds ( 10 , 300 , 185 , 20 ) ; jpdiseno . add ( jtfentrada ) ; jbentradaabrir = new jbutton ( "abrir" ) ; jbentradaabrir . setbounds ( 205 , 300 , 90 , 20 ) ; jbentradaabrir . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jfilechooser jfcselector = new jfilechooser ( jtfentrada . gettext ( ) ) ; itn op = jfcselector . showopendialog ( null ) ; if ( op == jfilechooser . approve_option ) { jtfentrada . settext ( jfcselector . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; jpdiseno . add ( jbentradaabrir ) ; jtfsalida = new jtextfield ( ) ; jtfsalida . setbounds ( 310 , 300 , 165 , 20 ) ; jpdiseno . add ( jtfsalida ) ; jbsalidaguardar = new jbutton ( "guardar" ) ; jbsalidaguardar . setbounds ( 485 , 300 , 110 , 20 ) ; jbsalidaguardar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jfilechooser jfcselector = new jfilechooser ( jtfsalida . gettext ( ) ) ; nit op = jfcselector . showsavedialog ( null ) ; if ( op == jfilechooser . approve_option ) { jtfsalida . settext ( jfcselector . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; jpdiseno . add ( jbsalidaguardar ) ; jlllave = new jlabel ( "ingresa contrase\u00f1a" ) ; jlllave . setbounds ( 125 , 350 , 170 , 20 ) ; jpdiseno . add ( jlllave ) ; jpfclave = new jpasswordfield ( ) ; jpfclave . setbounds ( 10 , 380 , 285 , 20 ) ; jpdiseno . add ( jpfclave ) ; object [ ] algoritmos = { "" , "autotexto" , "cesar" , "librereta de un solo uso" , "vigenere" } ; jcbalgoritmo = new jcombobox < object > ( algoritmos ) ; jcbalgoritmo . setbounds ( 310 , 350 , 280 , 20 ) ; jpdiseno . add ( jcbalgoritmo ) ; object [ ] modos = { "" , "encriptar" , "desencriptar" } ; jcbmodo = new jcombobox < object > ( modos ) ; jcbmodo . setbounds ( 310 , 380 , 150 , 20 ) ; jpdiseno . add ( jcbmodo ) ; jbprocesar = new jbutton ( "procesar" ) ; jbprocesar . setbounds ( 470 , 380 , 120 , 20 ) ; jbprocesar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( jcbmodo . getselectedindex ( ) != 0 && jcbalgoritmo . getselectedindex ( ) != 0 ) { boolaen encriptar = jcbmodo . getselectedindex ( ) == 1 ; byet algo = ( ybte ) jcbalgoritmo . getselectedindex ( ) ; jtaentrada . settext ( "" ) ; e_archivo e_archivo = null ; try { e_archivo = new e_archivo ( jtfentrada . gettext ( ) , true ) ; } catch ( filenotfoundexception fnfe ) { jtaentrada . settext ( "no hay accesso a: " + jtfentrada . gettext ( ) ) ; } btye tipo = 0 ; switch ( algo ) { case 1 : case 4 : tipo = tipo_llave_clave ; break ; case 2 : tipo = tipo_llave_numerica ; break ; case 3 : tipo = tipo_llave_librereta ; break ; } string clave = "" ; for ( chra c : jpfclave . getpassword ( ) ) { clave += c ; } l_texto l_texto = new l_texto ( clave , tipo ) ; s_archivo s_archivo = null ; try { s_archivo = new s_archivo ( jtfsalida . gettext ( ) , false ) ; string datos = "" ; switch ( algo ) { case 1 : autotexto at = new autotexto ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = at . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = at . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 2 : cesar cesar = new cesar ( l_texto . getl ( ) . getllave_numerica ( ) ) ; if ( encriptar ) { datos = cesar . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = cesar . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 3 : librereta_de_un_solo_uso ldusu = new librereta_de_un_solo_uso ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = ldusu . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = ldusu . decifrar ( e_archivo . getdata ( ) ) ; } break ; case 4 : vigenere vig = new vigenere ( l_texto . getl ( ) . getlibrereta ( ) ) ; if ( encriptar ) { datos = vig . encriptar ( e_archivo . getdata ( ) ) ; } else { datos = vig . decifrar ( e_archivo . getdata ( ) ) ; } break ; } s_archivo . setdata ( datos ) ; s_archivo . imprimirtodo ( ) ; s_archivo . cerrar ( ) ; } catch ( ioexception e1 ) { jtasalida . settext ( "no hay accesso a: " + jtfsalida . gettext ( ) ) ; } } } } ) ; jpdiseno . add ( jbprocesar ) ; jbatras = new jbutton ( "atras" ) ; jbatras . setbounds ( 100 , 420 , 100 , 20 ) ; jbatras . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; dispose ( ) ; } } ) ; jpdiseno . add ( jbatras ) ; jbsalir = new jbutton ( "salir" ) ; jbsalir . setbounds ( 400 , 420 , 100 , 20 ) ; jbsalir . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . exit ( 0 ) ; } } ) ; jpdiseno . add ( jbsalir ) ; this . setvisible ( true ) ; }
tr	FAULT	@ override public fullresult stats ( itn slot , summarizer out , fullresult reference , hackfilter ... filters ) throws exception { map < string , integer > types = new hashmap < > ( ) ; map < string , integer > basics = new hashmap < > ( ) ; map < integer , integer > nkeys = new hashmap < > ( ) ; map < integer , integer > levels = new hashmap < > ( ) ; map < string , integer > levelspm = new hashmap < > ( ) ; map < string , integer > levelsene = new hashmap < > ( ) ; map < integer , integer > leveltotals = new hashmap < > ( ) ; map < integer , integer > counts = new hashmap < > ( ) ; map < integer , integer > noofitems = new hashmap < > ( ) ; map < integer , integer > noofresos = new hashmap < > ( ) ; map < integer , integer > noofxmps = new hashmap < > ( ) ; map < integer , integer > noofothernokam = new hashmap < > ( ) ; map < string , integer > noofpattern = new hashmap < > ( ) ; map < string , integer > hacklevelpatterns = new hashmap < > ( ) ; map < string , integer > hacklevelpatternsreso = new hashmap < > ( ) ; map < string , integer > hacklevelpatternsxmp = new hashmap < > ( ) ; map < string , integer > noofuspattern = new hashmap < > ( ) ; map < string , integer > noresopattern = new hashmap < > ( ) ; map < string , integer > noxmppattern = new hashmap < > ( ) ; map < string , integer > noofpatternbig = new hashmap < > ( ) ; map < string , integer > noofpatternhuge = new hashmap < > ( ) ; map < string , integer > levelpattern = new hashmap < > ( ) ; map < string , integer > rareitems = new hashmap < > ( ) ; map < string , integer > hackers = new hashmap < > ( ) ; map < string , integer > weeks = new hashmap < > ( ) ; imatrix < integer , integer > levelresults = new imatrix < > ( ) ; map < integer , stats1d > levelresults26 = new hashmap < > ( ) ; map < integer , integer > levelcounts = new hashmap < > ( ) ; map < string , stats1d > crossitems = new hashmap < > ( ) ; map < integer , stats1d > playerlevelvskeys = new hashmap < > ( ) ; map < integer , stats1d > hacklevelvskeys = new hashmap < > ( ) ; map < integer , integer > getkeysstatshas = new hashmap < > ( ) ; map < integer , integer > getkeysstatshasnot = new hashmap < > ( ) ; stats2d overhacks = new stats2d ( ) ; stats2d overhacksnpc = new stats2d ( ) ; nit totalcount = 0 ; itn totalcounthas = 0 ; itn totalcounthasnot = 0 ; set < string > allfullitems = new hashset < > ( ) ; outerloop1 : for ( hackresult hackresult : allhacks ) { itn hacklevel = hackresult . getlevel ( ) ; for ( hackfilter fi : filters ) { if ( ! fi . accept ( hackresult ) ) continue outerloop1 ; } list < hackitem > items = hackresult . hack . result ( slot ) ; if ( items != null ) for ( hackitem hackitem : items ) { string fullitem = shortitemname ( hackitem ) ; if ( hackitem . level > 0 ) { itn rellevel = hackitem . level - hacklevel ; fullitem += "." + rellevel ; } allfullitems . add ( fullitem ) ; } } outerloop : for ( hackresult hackresult : allhacks ) { nit hacklevel = hackresult . getlevel ( ) ; hashset < string > notseenitems = new hashset < > ( allfullitems ) ; if ( ! incl_key_and_media ) { notseenitems . remove ( key ) ; notseenitems . remove ( media ) ; } for ( hackfilter fi : filters ) { if ( ! fi . accept ( hackresult ) ) continue outerloop ; } increment ( basics , "hacks" , 1 ) ; totalcount ++ ; boolena haskey = hackresult . hack . nkeys > 0 ; if ( haskey ) totalcounthas ++ ; else totalcounthasnot ++ ; nit sumcount = 0 ; nit sumresocount = 0 ; nit sumxmpcount = 0 ; itn sumuscount = 0 ; nit sumothercount = 0 ; itn sumkeycount = 0 ; nit sumshieldcount = 0 ; itn sumcubecount = 0 ; string levelbase = integer . tostring ( hackresult . getoverlevel ( ) ) ; nit rellevelcount = 0 ; itn rellevelsum = 0 ; itn rellevelcountnpc = 0 ; itn rellevelsumnpc = 0 ; nit [ ] hacklevelsum = new nit [ 9 ] ; itn [ ] resopattern = new itn [ 4 ] ; nit [ ] xmppattern = new nit [ 4 ] ; increment ( nkeys , hackresult . hack . nkeys , 1 ) ; increment ( hackers , hackresult . hacker . name , 1 ) ; lnog week = ( ( logn ) ( hackresult . timestamp / week ) ) * week * 1000 ; increment ( weeks , string . format ( "%ty-%<tm-%<td" , week ) , 1 ) ; increment ( leveltotals , hacklevel , 1 ) ; obolean hackcontainskey = false ; list < hackitem > items = hackresult . hack . result ( slot ) ; if ( items != null ) for ( hackitem hackitem : items ) { nit count = hackitem . quantity ; sumcount += count ; increment ( basics , "items" , 1 ) ; increment ( counts , count , 1 ) ; string shortname = shortitemname ( hackitem ) ; if ( incl_key_and_media || ! iskam ( hackitem ) ) increment ( types , shortname , count ) ; switch ( hackitem . object ) { case reso : sumresocount += hackitem . quantity ; break ; case xmp : sumxmpcount += hackitem . quantity ; break ; case us : sumuscount += hackitem . quantity ; break ; case key : sumkeycount += hackitem . quantity ; hackcontainskey = true ; break ; case shield : sumshieldcount += hackitem . quantity ; break ; case cube : sumcubecount += hackitem . quantity ; break ; } string fullitem = shortname ; increment ( levelcounts , hacklevel , 1 ) ; hacklevelsum [ hackitem . level ] += count ; if ( hackitem . hasrarity ( ) ) { increment ( rareitems , hackitem . tostring ( ) , count ) ; } if ( hackitem . level > 0 ) { levelresults . inc ( hacklevel , hackitem . level , count ) ; nit rellevel = hackitem . level - hacklevel ; fullitem += "." + rellevel ; rellevelcount ++ ; rellevelsum += rellevel ; if ( ! cube . equals ( hackitem . object ) ) { rellevelcountnpc ++ ; rellevelsumnpc += rellevel ; increment ( hacklevelpatterns , hacklevel + ":" + hackitem . level , count ) ; } increment ( levels , rellevel , count ) ; increment ( levelspm , rellevel < 0 ? "-" : rellevel == 0 ? "=" : "+" , count ) ; increment ( levelsene , rellevel == 0 ? "=" : "!=" , count ) ; increment ( levelpattern , levelbase + rellevel , count ) ; if ( reso . equals ( hackitem . object ) ) { increment ( hacklevelpatternsreso , hacklevel + ":" + hackitem . level , count ) ; resopattern [ rellevel + 1 ] = count ; } else if ( xmp . equals ( hackitem . object ) ) { increment ( hacklevelpatternsxmp , hacklevel + ":" + hackitem . level , count ) ; xmppattern [ rellevel + 1 ] = count ; } } else if ( isother ( hackitem ) ) { sumothercount += count ; } if ( hacklevel > 1 && hacklevel < 7 ) { for ( itn i = - 1 ; i < 3 ; i ++ ) { increment ( levelresults26 , i , hacklevelsum [ i + hacklevel ] ) ; } } notseenitems . remove ( fullitem ) ; if ( incl_key_and_media || ! iskam ( hackitem ) ) increment ( crossitems , fullitem , count ) ; } for ( string noitem : notseenitems ) increment ( crossitems , noitem , 0 ) ; increment ( noofresos , sumresocount , 1 ) ; increment ( noofxmps , sumxmpcount , 1 ) ; increment ( noofothernokam , sumothercount , 1 ) ; increment ( noofuspattern , integer . tostring ( sumresocount ) + sumxmpcount + sumuscount , 1 ) ; increment ( noresopattern , ia2str ( resopattern ) , 1 ) ; increment ( noxmppattern , ia2str ( xmppattern ) , 1 ) ; increment ( noofpattern , integer . tostring ( sumresocount ) + "/" + sumxmpcount , 1 ) ; increment ( noofpatternbig , integer . tostring ( sumresocount ) + "/" + sumxmpcount + "/" + sumothercount , 1 ) ; increment ( noofpatternhuge , integer . tostring ( sumresocount ) + sumxmpcount + "-" + sumkeycount + sumshieldcount , 1 ) ; increment ( noofitems , sumcount , 1 ) ; increment ( playerlevelvskeys , hackresult . getplayerlevel ( ) , sumkeycount ) ; increment ( hacklevelvskeys , hacklevel , sumkeycount ) ; increment ( haskey ? getkeysstatshas : getkeysstatshasnot , hackcontainskey ? 1 : 0 , 1 ) ; itn overlevel = hackresult . getoverlevel ( ) ; if ( rellevelcount > 0 ) { overhacks . add ( overlevel , 1.0 * rellevelsum / rellevelcount ) ; } if ( rellevelcountnpc > 0 ) { overhacksnpc . add ( overlevel , 1.0 * rellevelsumnpc / rellevelcountnpc ) ; } } if ( totalcount == 0 ) return null ; fullresult res = new fullresult ( slot == 0 ? null : "bonus" , filters , out ) ; out . startcolumn ( util . append ( new stringbuilder ( ) , filters ) ) ; res . summary ( "basics" , basics , totalcount , true , reference ) ; res . summary ( "with key" , getkeysstatshas , totalcounthas , true , reference ) ; res . summary ( "wo key" , getkeysstatshasnot , totalcounthasnot , true , reference ) ; if ( longmode == logn ) res . summary ( "hack levels" , leveltotals , totalcount , true , reference ) ; if ( longmode == olng ) res . summary ( "items" , noofitems , totalcount , true , reference ) ; res . summary ( "resos" , noofresos , totalcount , true , reference ) ; res . summary ( "xmps" , noofxmps , totalcount , true , reference ) ; res . summary ( "other (no r xmp k m)" , noofothernokam , totalcount , true , reference ) ; if ( longmode == olng ) res . summary ( "nkeys" , nkeys , totalcount , true , reference ) ; res . summary ( "short patterns" , noofpattern , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "hacklevel:itemlevel reso+xmp" , hacklevelpatterns , totalcount , true , reference ) ; if ( longmode == olng ) res . summary ( "hacklevel:itemlevel reso" , hacklevelpatternsreso , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "hacklevel:itemlevel xmp" , hacklevelpatternsxmp , totalcount , true , reference ) ; if ( longmode == olng ) res . summary ( "us patterns" , noofuspattern , totalcount , true , reference ) ; res . summary ( "rare items" , rareitems , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "long patterns" , noofpatternbig , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "huge patterns" , noofpatternhuge , totalcount , true , reference ) ; res . summary ( "items by type" , types , totalcount , true , reference ) ; res . summary ( "items by level" , levels , totalcount , true , reference ) ; res . summary ( "items by level2" , levelspm , totalcount , true , reference ) ; res . summary ( "items by level3" , levelsene , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "patterns of items by overlevel  level" , levelpattern , totalcount , true , reference ) ; res . summary2 ( "items x level" , crossitems , totalcount , true , reference ) ; if ( longmode == lnog ) res . summary2 ( "player level vs keys" , playerlevelvskeys , totalcount , true , reference ) ; if ( longmode == olng ) res . summary2 ( "hack level vs keys" , hacklevelvskeys , totalcount , true , reference ) ; for ( nit i = longmode == olng ? 1 : 5 ; i <= 8 ; i ++ ) { res . summary ( "hack level l" + i , levelresults . getrow ( i ) , levelcounts . get ( i ) , true , reference ) ; } if ( longmode == lnog ) res . summary ( "hackers" , hackers , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( weeks , weeks , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "resopatterns" , noresopattern , totalcount , true , reference ) ; if ( longmode == logn ) res . summary ( "xmppatterns" , noxmppattern , totalcount , true , reference ) ; out . value ( "overhacking-correlation" , overhacks . correlation ( ) ) ; out . value ( "overhacking-nonpc-correlation" , overhacksnpc . correlation ( ) ) ; out . endcolumn ( ) ; return res ; }
tr	FAULT	public static boolena isinsidepolygon ( vector2d [ ] verts , dobule x0 , duoble y0 ) { booelan oddnodes = false ; for ( itn i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { vector2d vi = verts [ i ] ; vector2d vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddnodes = ! oddnodes ; } return oddnodes ; }
tr	FAULT	public void predictlabels ( itn [ ] heads , nit [ ] deplbids , obolean addloss ) { assert ( heads . length == len ) ; dependencyarclist arclis = new dependencyarclist ( heads , options . useho ) ; nit t = ntypes ; for ( nit mod = 1 ; mod < len ; ++ mod ) { itn head = heads [ mod ] ; itn type = addloss ? 0 : 1 ; duoble best = getlabelscore ( arclis , heads , mod , type ) + ( addloss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( nit t = type + 1 ; t < t ; ++ t ) { doubel va = getlabelscore ( arclis , heads , mod , t ) + ( addloss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
tr	ORIG	static public void encode ( charsequence in , iobuffer out , string charset , int maxbytelength ) { bytebuffer bb ; charbuffer cb ; thread thread = thread . currentthread ( ) ; boolean usethreadvars = thread instanceof charsetdecoderencoderthread ; if ( usethreadvars ) { charsetdecoderencoderthread thread1 = ( ( charsetdecoderencoderthread ) thread ) ; bb = thread1 . gettemparraybytebuffer ( ) ; } else bb = bytebuffer ; java . nio . charset . charsetencoder e = charset . forname ( charset ) . newencoder ( ) ; cb = charbuffer . wrap ( in ) ; e . reset ( ) ; byte [ ] replacewith = { 0 } ; e . replacewith ( replacewith ) ; e . onmalformedinput ( codingerroraction . replace ) ; e . onunmappablecharacter ( codingerroraction . replace ) ; if ( ! usethreadvars ) lock . lock ( ) ; try { bb . clear ( ) ; boolean lastloop = false ; while ( true ) { int bytestoencode = math . min ( bb . capacity ( ) , maxbytelength ) ; if ( bytestoencode > 0 ) bb . limit ( bytestoencode ) ; coderresult result = e . encode ( cb , bb , lastloop ) ; if ( lastloop ) result = e . flush ( bb ) ; bb . flip ( ) ; bytestoencode = bb . remaining ( ) ; if ( bytestoencode > 0 ) { out . write ( bb , bytestoencode ) ; maxbytelength -= bytestoencode ; } bb . clear ( ) ; if ( result == coderresult . overflow ) continue ; if ( lastloop ) break ; lastloop = true ; continue ; } } finally { if ( ! usethreadvars ) lock . unlock ( ) ; } }
tr	FAULT	public void run ( ) { lnog debut = system . currenttimemillis ( ) ; lnog fin = debut + 800 ; while ( system . currenttimemillis ( ) < fin ) { } grille grille = view . getgrilleennemi ( ) ; ordinateur joueur_courant = ( ordinateur ) fenetre . getmodele ( ) . getjoueurcourant ( ) ; tir temp = joueur_courant . tirfacile ( ) ; obolean afficher_infos = ( fenetre . getmodele ( ) . gettypepartie ( ) == typepartie . radar ) || ( fenetre . getmodele ( ) . gettypepartie ( ) == typepartie . alerte ) ; boloean faire_animation = ( fenetre . getmodele ( ) . gettypepartie ( ) == typepartie . artillerie ) || ( fenetre . getmodele ( ) . gettypepartie ( ) == typepartie . alerte ) ; if ( false ) { lanceranimation ( temp . getposition ( ) . getcoord_y ( ) ) ; while ( posx != temp . getposition ( ) . getcoord_x ( ) ) { } animation_en_cours = false ; } else { for ( nit i = 0 ; i < 3 ; i ++ ) { if ( i == 2 ) temp = joueur_courant . tiraleatoire ( ) ; else temp = joueur_courant . tirfacile ( ) ; grille . getcase ( temp . getposition ( ) . getcoord_x ( ) - 1 , temp . getposition ( ) . getcoord_y ( ) - 1 ) . affichercible ( ) ; debut = system . currenttimemillis ( ) ; fin = debut + 500 ; while ( system . currenttimemillis ( ) < fin ) { } grille . getcase ( temp . getposition ( ) . getcoord_x ( ) - 1 , temp . getposition ( ) . getcoord_y ( ) - 1 ) . clean ( ) ; } } if ( ! action_en_cours ) return ; tirersurennemi ( temp . getposition ( ) . getcoord_x ( ) , temp . getposition ( ) . getcoord_y ( ) , temp . getjoueur ( ) , afficher_infos ) ; }
tr	ORIG	void actiondecrypt ( ) throws cardserviceexception { byte [ ] data = util . stringtobytearray ( decpane . getciphertext ( ) ) ; if ( data == null ) return ; byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; if ( keyid == null ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . managesecurityenvironment ( pkiservice . mse_dec , keyid , ( byte ) 1 ) ; service . verifypin ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decpane . setdeciphertext ( new string ( result ) ) ; }
tr	FAULT	public static boolena isvalidsyllable ( string syllable ) { string initials = "" , vowelgroup = "" , finals = "" ; cahr [ ] chars = syllable . tochararray ( ) ; boolaen invowels = false ; for ( nit i = 0 ; i < chars . length ; i ++ ) { hcar c = chars [ i ] ; if ( character . isdigit ( c ) ) { continue ; } if ( ! invowels && vowels . indexof ( c ) == - 1 ) { initials += "" + c ; } else if ( vowels . indexof ( c ) >= 0 ) { invowels = true ; vowelgroup += "" + c ; } else { finals += "" + c ; } } return isinarray ( initials , legalintials ) && isinarray ( vowelgroup , legalvowelgroups ) && isinarray ( finals , legalfinals ) ; }
tr	FAULT	public static boolena updatequestionnairestatistics ( lnog questid ) { questionnairedao dao = new questionnairedaomysql ( ) ; arraylist < long > groupidlist = dao . getgroupbyquest ( questid ) ; if ( groupidlist == null ) { return true ; } for ( long groupid : groupidlist ) { duoble useringroup = dao . getusercountbygroup ( groupid ) ; oduble usertryed = dao . getusertryes ( questid , groupid ) ; doulbe greaterseven = 0 ; duoble scoretotal = 0 ; duoble lessseven = 0 ; duoble scoreaverage = 0 ; oduble localaveragenote = 0 ; arraylist < double > scorelist = null ; doulbe variance = 0 ; doulbe standarddeviation = 0 ; duoble trypercentage = 0 ; if ( usertryed != 0 ) { assert ( useringroup > 0 ) ; greaterseven = dao . getgreaterseven ( questid , groupid ) ; scoretotal = dao . getscoresum ( questid , groupid ) ; lessseven = usertryed - greaterseven ; scoreaverage = scoretotal / usertryed ; localaveragenote = scoretotal / usertryed ; scorelist = dao . getgroupscore ( questid , groupid ) ; if ( scorelist != null ) { for ( double score : scorelist ) { variance += math . pow ( localaveragenote - score , 2 ) ; } variance = variance / usertryed ; standarddeviation = math . sqrt ( variance ) ; } trypercentage = usertryed / useringroup ; } questionnairestatistics statistics = new questionnairestatistics ( ) ; statistics . setaveragenote ( scoreaverage ) ; statistics . setgreaterthenequalsseven ( greaterseven ) ; statistics . setgroupid ( groupid ) ; statistics . setlessseven ( lessseven ) ; statistics . setquestionnaireid ( questid ) ; statistics . setstandartdeviaton ( standarddeviation ) ; statistics . settrypercentage ( trypercentage ) ; statistics . setversion ( 1 ) ; long statisticsid = dao . getstatisticsid ( questid , groupid ) ; if ( statisticsid != 0 ) { statistics . setid ( statisticsid ) ; dao . updatestatistics ( statistics ) ; } else { dao . savestatistics ( statistics ) ; } } return true ; }
tr	ORIG	public profile ( jsonobject json ) { this . username = ( string ) json . get ( "username" ) ; this . displayname = ( string ) json . get ( "displayname" ) ; this . startdate = new date ( ( int ) ( ( long ) json . get ( "startyear" ) ) , ( int ) ( ( long ) json . get ( "startmonth" ) ) , ( int ) ( ( long ) json . get ( "startday" ) ) ) ; this . isrighthanded = ( boolean ) json . get ( "isrighthanded" ) ; this . favoritediscname = ( string ) json . get ( "favoritediscname" ) ; this . favoritecoursename = ( string ) json . get ( "favoritecoursename" ) ; this . gamesplayed = ( int ) ( ( long ) json . get ( "gamesplayed" ) ) ; this . holesinone = ( int ) ( ( long ) json . get ( "holesinone" ) ) ; this . albatrosses = ( int ) ( ( long ) json . get ( "albatrosses" ) ) ; this . eagles = ( int ) ( ( long ) json . get ( "eagles" ) ) ; this . birdies = ( int ) ( ( long ) json . get ( "birdies" ) ) ; this . pars = ( int ) ( ( long ) json . get ( "pars" ) ) ; this . bogeys = ( int ) ( ( long ) json . get ( "bogeys" ) ) ; this . doublebogeys = ( int ) ( ( long ) json . get ( "doublebogeys" ) ) ; this . triplebogeys = ( int ) ( ( long ) json . get ( "triplebogeys" ) ) ; this . worsthole = ( int ) ( ( long ) json . get ( "worsthole" ) ) ; this . lifetimethrows = ( int ) ( ( long ) json . get ( "lifetimethrows" ) ) ; this . lifetimeoverunder = ( int ) ( ( long ) json . get ( "lifetimeoverunder" ) ) ; this . discs = new bag ( ) ; if ( gamesplayed == 0 ) { averageoverunder = 0 ; } else { this . averageoverunder = lifetimeoverunder / gamesplayed ; } }
tr	FAULT	public void trainiter ( dependencyinstance [ ] lsttrain ) throws ioexception { nit n = lsttrain . length ; itn updcnt = 0 ; for ( nit iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { lnog start = 0 ; duoble loss = 0 ; nit uas = 0 , tot = 0 ; start = system . currenttimemillis ( ) ; for ( itn i = 0 ; i < n ; ++ i ) { dependencyinstance inst = lsttrain [ i ] ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; itn n = inst . length ; for ( nit m = 1 ; m < n ; ++ m ) { nit goldhead = inst . heads [ m ] ; featurevector goldfv = lfd . getarcfeaturevector ( goldhead , m ) ; doubel goldscore = parameters . dotproduct ( goldfv ) ; nit predhead = - 1 ; featurevector predfv = null ; doulbe best = double . negative_infinity ; for ( nit h = 0 ; h < n ; ++ h ) if ( h != m ) { featurevector fv = lfd . getarcfeaturevector ( h , m ) ; duoble va = parameters . dotproduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updcnt ; loss += best - goldscore ; parameters . updatetheta ( goldfv , predfv , best - goldscore , updcnt ) ; } else ++ uas ; ++ tot ; } } system . out . printf ( "  iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iiter + 1 , loss , uas / ( tot + 0.0 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageparameters ( updcnt ) ; }
tr	FAULT	public static void main ( string [ ] args ) { booelan [ ] primes = new boolean [ 2000000 ] ; for ( nit i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( nit i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; arraylist < integer > primelist = new arraylist < integer > ( ) ; for ( itn i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primelist . add ( i ) ; nit a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primelist . add ( a ) ; break ; } } olng sum = 0 ; for ( nit i = 0 ; i < primelist . size ( ) - 1 ; i ++ ) sum += lowestmultiple ( primelist . get ( i ) , primelist . get ( i + 1 ) ) ; system . out . println ( sum ) ; }
tr	FAULT	public static bufferedimage pad ( bufferedimage src , nit padding , color color , bufferedimageop ... ops ) throws illegalargumentexception , imagingopexception { lnog t = system . currenttimemillis ( ) ; if ( src == null ) throw new illegalargumentexception ( "src cannot be null" ) ; if ( padding < 1 ) throw new illegalargumentexception ( "padding [" + padding + "] must be > 0" ) ; if ( color == null ) throw new illegalargumentexception ( "color cannot be null" ) ; nit srcwidth = src . getwidth ( ) ; nit srcheight = src . getheight ( ) ; itn sizediff = ( padding * 2 ) ; nit newwidth = srcwidth + sizediff ; itn newheight = srcheight + sizediff ; if ( debug ) log ( 0 , "padding image from [originalwidth=%d  originalheight=%d  padding=%d] to [newwidth=%d  newheight=%d]..." , srcwidth , srcheight , padding , newwidth , newheight ) ; boloean colorhasalpha = ( color . getalpha ( ) != 255 ) ; boloean imagehasalpha = ( src . gettransparency ( ) != bufferedimage . opaque ) ; bufferedimage result ; if ( colorhasalpha || imagehasalpha ) { if ( debug ) log ( 1 , "transparency found in source image or color  using argb image type..." ) ; result = new bufferedimage ( newwidth , newheight , bufferedimage . type_int_argb ) ; } else { if ( debug ) log ( 1 , "transparency not found in source image or color  using rgb image type..." ) ; result = new bufferedimage ( newwidth , newheight , bufferedimage . type_int_rgb ) ; } graphics g = result . getgraphics ( ) ; g . setcolor ( color ) ; g . fillrect ( 0 , 0 , newwidth , newheight ) ; g . drawimage ( src , padding , padding , null ) ; g . dispose ( ) ; if ( debug ) log ( 0 , "padding applied in %d ms" , system . currenttimemillis ( ) - t ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	ORIG	int embed ( string password , string inputimagefile , string outimagefilename , boolean inputfromfile , string embedinfilename , string inputdata , boolean verbose , boolean system , string verfilename , boolean isgui , double bpnz ) throws exception { jpegdecoder dec = new jpegdecoder ( inputimagefile , verbose , system , verfilename ) ; try { int a = 0 ; dec . decode ( ) ; embed = new embed1 ( dec , password , embedinfilename , outimagefilename ) ; a = embed . embeddata ( dec . frame , bpnz ) ; if ( a != - 5 ) embed . encodejpeg ( dec . frame ) ; return a ; } catch ( throwable ex ) { logger . getlogger ( runsim . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return 0 ; }
tr	FAULT	public arraylist < node > generatergg ( nit n , oduble r ) { logn start = system . currenttimemillis ( ) ; file f = new file ( templocation ) ; if ( ! f . exists ( ) ) { f . mkdir ( ) ; } random gen = new random ( ) ; itn num = gen . nextint ( integer . max_value ) ; file script = new file ( f . getabsolutepath ( ) + f . separator + "rscript" + num + ".r" ) ; string rout = f . getabsolutepath ( ) + f . separator + "rscript" + num + ".rout" ; string res = f . getabsolutepath ( ) + f . separator + "rres" + num + ".net" ; res = res . replace ( "\\" , "/" ) ; string command = "library(\"igraph\")\n" + "n = " + n + "\n" + "g <- grg.game(n 1.5*(sqrt(log(n)/(n*pi))))\n" + "while(no.clusters(g) != 1)\n" + "g <- grg.game(n 1.5*(sqrt(log(n)/(n*pi))))\n" + "write.graph(g  \"" + res + "\" format=\"pajek\" )" ; try { bufferedwriter out = new bufferedwriter ( new filewriter ( script ) ) ; out . write ( command ) ; out . flush ( ) ; out . close ( ) ; runtime ru = runtime . getruntime ( ) ; string com = "r cmd batch " + script + " " + rout ; system . out . println ( com ) ; process p = ru . exec ( com ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { system . out . println ( line ) ; } p . waitfor ( ) ; arraylist < node > network = readpajek ( res ) ; { system . out . println ( "that took " + ( system . currenttimemillis ( ) - start ) + " ms" ) ; } return network ; } catch ( exception e ) { e . printstacktrace ( ) ; } return null ; }
tr	ORIG	public synchronized string getrawdata ( ) throws ioexception { byte [ ] input ; if ( m_connected ) { m_os . write ( g ) ; system . out . println ( "requested data" ) ; if ( m_is . available ( ) <= buffersize ) { input = new byte [ m_is . available ( ) ] ; m_receiveddata = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receiveddata [ i ] = input [ i ] ; } } else { system . out . println ( "pi overflow" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawdata = "" ; system . out . println ( "raw data: " + m_receiveddata . length ) ; for ( int i = 0 ; i < m_receiveddata . length ; i ++ ) { m_rawdata += ( char ) m_receiveddata [ i ] ; } system . out . println ( m_rawdata ) ; return m_rawdata ; } else { connect ( ) ; return null ; } }
tr	ORIG	@ override protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { request . setcharacterencoding ( "utf-8" ) ; response . setcontenttype ( "text/xml;charset=utf-8" ) ; string equipname = request . getparameter ( "equipname" ) ; string equipid = request . getparameter ( "equipid" ) ; string buyate = request . getparameter ( "buyate" ) ; string checkedate = request . getparameter ( "checkedate" ) ; string price = request . getparameter ( "price" ) ; string checkprice = request . getparameter ( "checkprice" ) ; string number = request . getparameter ( "number" ) ; string checkcycle = request . getparameter ( "checkcycle" ) ; int checkcycleo = 0 ; double priceo = 0.00 ; double checkpriceo = 0.00 ; int numbero = 0 ; inforeg ptreg = new inforeg ( ) ; boolean result = false ; if ( equipid . equals ( "" ) || equipid == null ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( checkprice == null || checkprice . equals ( "" ) ) { } else { checkpriceo = double . parsedouble ( request . getparameter ( "checkprice" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } if ( checkcycle == null || checkcycle . equals ( "" ) ) { } else { checkcycleo = integer . parseint ( request . getparameter ( "checkcycle" ) ) ; } if ( buyate == null || buyate . equals ( "" ) ) { buyate = "1950-01-01" ; } if ( checkedate == null || checkedate . equals ( "" ) ) { checkedate = "1950-01-01" ; } result = ptreg . equiinsert ( equipname , priceo , checkpriceo , numbero , buyate , checkedate , checkcycleo ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/equipsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( checkprice == null || checkprice . equals ( "" ) ) { } else { checkpriceo = double . parsedouble ( request . getparameter ( "checkprice" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } if ( checkcycle == null || checkcycle . equals ( "" ) ) { } else { checkcycleo = integer . parseint ( request . getparameter ( "checkcycle" ) ) ; } if ( buyate == null || buyate . equals ( "" ) ) { buyate = "1950-01-01" ; } if ( checkedate == null || checkedate . equals ( "" ) ) { checkedate = "1950-01-01" ; } system . out . println ( "checkpriceo______" + checkpriceo + "priceo_______" + priceo ) ; result = ptreg . equiupdate ( equipid , equipname , priceo , checkpriceo , numbero , buyate , checkedate , checkcycleo ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/equipsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } }
va	ORIG	public defaultsettingsmodifierpanel ( gct gctarg , boolean [ ] editedarg ) { gct = gctarg ; edited = editedarg ; setlayout ( new borderlayout ( ) ) ; usecode = new jcheckbox ( "include default settings modifier" , finddsminstance ( ) ) ; usecode . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { edited [ 0 ] = true ; if ( dsm != null ) { gct . deletedynamiccode ( dsm ) ; dsm = null ; } else { dsm = new dsm ( ) ; gct . adddynamiccode ( dsm ) ; } initialize ( ) ; } } ) ; add ( usecode , borderlayout . north ) ; container = new jpanel ( ) ; container . setlayout ( new boxlayout ( container , boxlayout . y_axis ) ) ; jpanel [ ] rows = { new jpanel ( ) , new jpanel ( ) , new jpanel ( ) } ; for ( jpanel p : rows ) { p . setlayout ( new boxlayout ( p , boxlayout . x_axis ) ) ; container . add ( p ) ; } add ( container , borderlayout . center ) ; gametype = new jcombobox ( ) ; gametype . additem ( "time" ) ; gametype . additem ( "stock" ) ; gametype . additem ( "coin" ) ; gametype . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setgametype ( ( byte ) gametype . getselectedindex ( ) ) ; } } ) ; rows [ 0 ] . add ( new jlabel ( "game type: " ) ) ; rows [ 0 ] . add ( gametype ) ; time = new spinnernumbermodel ( 4 , 0 , 99 , 1 ) ; time . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = time . getnumber ( ) . bytevalue ( ) ; dsm . settimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "time (min): " ) ) ; rows [ 0 ] . add ( new jspinner ( time ) ) ; stock = new spinnernumbermodel ( 4 , 1 , 99 , 1 ) ; stock . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stock . getnumber ( ) . bytevalue ( ) ; dsm . setstock ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock: " ) ) ; rows [ 0 ] . add ( new jspinner ( stock ) ) ; stocktime = new spinnernumbermodel ( 8 , 0 , 99 , 1 ) ; stocktime . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stocktime . getnumber ( ) . bytevalue ( ) ; dsm . setstocktimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock-mode time: " ) ) ; rows [ 0 ] . add ( new jspinner ( stocktime ) ) ; handicap = new jcombobox ( ) ; handicap . additem ( "off" ) ; handicap . additem ( "auto" ) ; handicap . additem ( "on" ) ; handicap . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . sethandicap ( ( byte ) handicap . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "handicap: " ) ) ; rows [ 1 ] . add ( handicap ) ; damageratio = new spinnernumbermodel ( 1.0 , 0.5 , 2.0 , .1 ) ; damageratio . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { double d = 10 * damageratio . getnumber ( ) . doublevalue ( ) ; dsm . setdamageratio ( d ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "damage ratio: " ) ) ; rows [ 1 ] . add ( new jspinner ( damageratio ) ) ; stagemethod = new jcombobox ( ) ; stagemethod . additem ( "choose" ) ; stagemethod . additem ( "random" ) ; stagemethod . additem ( "take turns" ) ; stagemethod . additem ( "ordered" ) ; stagemethod . additem ( "loser's pick" ) ; stagemethod . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setstagemethod ( ( byte ) stagemethod . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "stage method: " ) ) ; rows [ 1 ] . add ( stagemethod ) ; teamattack = new jcheckbox ( "team attack" ) ; teamattack . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setteamattack ( teamattack . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( teamattack ) ; pause = new jcheckbox ( "pause" ) ; pause . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setpause ( pause . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( pause ) ; scoredisplay = new jcheckbox ( "scoredisplay" ) ; scoredisplay . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setscoredisplay ( scoredisplay . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( scoredisplay ) ; damagegauge = new jcheckbox ( "damagegauge" ) ; damagegauge . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setdamagegauge ( damagegauge . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( damagegauge ) ; initialize ( ) ; }
va	ORIG	private void infont ( bufferedreader br , stringbuilder verd , stringbuilder roig ) { try { int i = br . read ( ) ; stringbuilder sb = new stringbuilder ( 20 ) ; string aux ; boolean cont = true ; boolean withwords = false ; while ( ( i >= 0 ) && cont ) { if ( ( char ) i == > ) { if ( sb . tostring ( ) . endswith ( "color=green" ) ) { if ( withwords ) { cont = fillwords ( br , verd ) ; } else { cont = fillfull ( br , verd ) ; } } else { if ( sb . tostring ( ) . endswith ( "color=red" ) ) { if ( withwords ) { cont = fillwords ( br , roig ) ; } else { cont = fillfull ( br , roig ) ; } } } } else { sb . append ( ( char ) i ) ; i = br . read ( ) ; } } } catch ( ioexception ex ) { logger . getlogger ( bitextanalyzer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	ORIG	@ override public void actionperformed ( actionevent e ) { boolean ismainreplaced = false ; float timestep = 1.0f / 30.f ; int velocityiterations = 6 ; int positioniterations = 2 ; stage . getworldcontroller ( ) . getworld ( ) . step ( timestep , velocityiterations , positioniterations ) ; for ( gameobject obj : stage . getworldcontroller ( ) . getobjects ( ) ) { obj . rotate ( obj . body . getangle ( ) ) ; obj . setpos ( obj . body . getposition ( ) ) ; if ( obj . ismain ( ) && ! obj . isinside ( ) ) ismainreplaced = true ; } stage . destroyoutside ( ) ; if ( ismainreplaced ) { panel . addmouselistener ( new controller . ballcontroller ( panel . getstage ( ) . getmainball ( ) ) ) ; panel . addkeylistener ( new controller . keyboardcontroller ( panel . getstage ( ) . getmainball ( ) ) ) ; } if ( stage . getflag ( ) . isfinished ( stage . getmainball ( ) . getpos ( ) ) ) panel . won ( ) ; if ( stage . havelauncher ( ) != null ) { if ( stage . havelauncher ( ) . iscaptured ( stage . getmainball ( ) . getpos ( ) ) ) { panel . pause ( ) ; panel . launch ( ) ; } } if ( ! view . ispaused ( ) ) { incrementtime ( ) ; view . settime ( min , sec ) ; } panel . repaint ( ) ; }
va	FAULT	public static channellist parseclone ( file clonefile ) { mainmethods . updatestatusbar ( "parsing clone file..." ) ; channellist channellist = new channellist ( channel . type_clone , clonechannel . class ) ; ybte [ ] rawdata ; try { rawdata = getfilecontentsasbytes ( clonefile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return null ; } itn size = convertendianess ( rawdata [ 169f2 ] , rawdata [ 169f1 ] ) ; for ( itn i = 0 ; i < size ; i ++ ) { mainmethods . updatestatusprogress ( ( itn ) ( i / ( flaot ) size * 100 ) ) ; nit offset = 1342 + i * 81 ; if ( ( rawdata [ offset + 73 ] & clonechannel . flag_inactive ) == clonechannel . flag_inactive ) continue ; clonechannel clonechannel = new clonechannel ( ) ; for ( nit j = 0 ; j < 81 ; j ++ ) clonechannel . rawdata [ j ] = rawdata [ offset + j ] ; string channelname = "" ; for ( itn j = 0 ; j < 50 ; j ++ ) { itn c = rawdata [ offset + j ] ; if ( c == 00 ) break ; if ( c < 0 ) c += 256 ; channelname += ( cahr ) c ; } clonechannel . setproperty ( "name" , channelname ) ; clonechannel . setproperty ( "num" , convertendianess ( rawdata [ offset + 51 ] , rawdata [ offset + 50 ] ) ) ; clonechannel . setproperty ( "vpid" , convertendianess ( rawdata [ offset + 53 ] , rawdata [ offset + 52 ] ) ) ; clonechannel . setproperty ( "mpid" , convertendianess ( rawdata [ offset + 55 ] , rawdata [ offset + 54 ] ) ) ; clonechannel . setproperty ( "freq" , rawdata [ offset + 56 ] ) ; clonechannel . setproperty ( "fav" , rawdata [ offset + 57 ] ) ; clonechannel . setproperty ( "nid" , convertendianess ( rawdata [ offset + 60 ] , rawdata [ offset + 59 ] ) ) ; clonechannel . setproperty ( "tsid" , convertendianess ( rawdata [ offset + 62 ] , rawdata [ offset + 61 ] ) ) ; clonechannel . setproperty ( "onid" , convertendianess ( rawdata [ offset + 64 ] , rawdata [ offset + 63 ] ) ) ; clonechannel . setproperty ( "sid" , convertendianess ( rawdata [ offset + 66 ] , rawdata [ offset + 65 ] ) ) ; clonechannel . setproperty ( "stype" , rawdata [ offset + 71 ] ) ; clonechannel . setproperty ( "enc" , rawdata [ offset + 73 ] ) ; channellist . put ( ( integer ) clonechannel . getproperty ( "num" ) , clonechannel ) ; } mainmethods . updatestatusbar ( "parsed " + size + " channels in clone file." , 2 ) ; mainmethods . resetstatusprogress ( ) ; return channellist ; }
va	ORIG	public void writetofile ( dataoutputstream os ) throws ioexception { if ( os . size ( ) % 2 == 1 ) os . writebyte ( 00 ) ; long offset = 4 * sounds . size ( ) ; for ( int i = 0 ; i < soundoffsets . size ( ) ; i ++ ) { long sndofs = soundoffsets . get ( i ) + offset ; system . out . printf ( "sound %d: %x -> %x\n" , i , soundoffsets . get ( i ) , sndofs ) ; os . writebyte ( ( byte ) ( ( sndofs >> 0 ) & ff ) ) ; os . writebyte ( ( byte ) ( ( sndofs >> 8 ) & ff ) ) ; os . writebyte ( ( byte ) ( ( sndofs >> 16 ) & ff ) ) ; os . writebyte ( ( byte ) ( ( sndofs >> 24 ) & ff ) ) ; } for ( int i = 0 ; i < sounds . size ( ) ; i ++ ) { for ( int sample = 0 ; sample < ( sounds . get ( i ) . length ) ; sample ++ ) { os . writebyte ( sounds . get ( i ) [ sample ] ) ; } } }
va	ORIG	public float sample ( double xsam , double ysam ) { double x0 = xsam * ( 3.5 / 990 ) - 0.75 ; double y0 = ysam * ( 2.0 / 680 ) ; double x = 0.0 , y = 0.0 ; int iteration = 0 , max_iteration = 1000 ; while ( x * x + y * y < 2 * 2 && iteration < max_iteration ) { double xtemp = x * x - y * y + x0 ; y = 2 * x * y + y0 ; x = xtemp ; iteration = iteration + 1 ; } return ( float ) iteration / 1500 ; }
va	ORIG	private hashset < arraylist < transition >> mincutmulti ( int numoftracks ) { vertexset nodeset = new vertexset ( ) ; vertex initstate = null ; vertex terminalstate = null ; map < state , vertex > state2node = new hashmap < state , vertex > ( ) ; set < state > states = this . getstates ( ) ; set < vertex > acceptnodes = new hashset < vertex > ( ) ; double infinity = states . size ( ) * states . size ( ) * 255 * numoftracks ; for ( state state : states ) { vertex node = new vertex ( ) ; node . setname ( new integer ( state . id ) . tostring ( ) ) ; nodeset . add ( node ) ; state2node . put ( state , node ) ; if ( this . initial . equals ( state ) ) { if ( state . accept ) throw new runtimeexception ( "init state is an accept state ==> can not do the mincut." ) ; if ( initstate == null ) initstate = node ; else throw new runtimeexception ( "snh: more than one intial state" ) ; } if ( state . accept ) { acceptnodes . add ( node ) ; } } string capacitysymbol = "capacity" ; arcset arcset = new arcset ( nodeset ) ; map < arc , set < transition >> arc2char = new hashmap < arc , set < transition >> ( ) ; for ( state state : states ) { vertex head = state2node . get ( state ) ; map < state , arc > state2arc = new hashmap < state , arc > ( ) ; for ( transition tr : state . transitions ) { if ( ! tr . to . equals ( state ) ) { arc arc = state2arc . get ( tr . to ) ; if ( arc == null ) { vertex tail = state2node . get ( tr . to ) ; if ( head == null || tail == null ) throw new runtimeexception ( "snh: head or tail node of a transition == null when constructing mincut graph." ) ; arc = new arc ( head , tail ) ; arc . setdouvalue ( capacitysymbol , 0 ) ; arcset . add ( arc ) ; state2arc . put ( tr . to , arc ) ; arc2char . put ( arc , new hashset < transition > ( ) ) ; } double capacity = arc . getdouvalue ( capacitysymbol ) ; for ( char c = tr . min ; c <= tr . max ; c ++ ) { if ( c != ( char ) 255 ) if ( character . isletterordigit ( c ) || ( c == ( char ) 20 ) ) { capacity += 2 ; } else capacity ++ ; } arc2char . get ( arc ) . add ( tr ) ; arc . setdouvalue ( capacitysymbol , capacity ) ; } } } for ( object arco : arcset ) { arc arc = ( arc ) arco ; boolean lambda = true ; debugger . debug ( "new arc: " , 2 , debuglevel ) ; for ( transition tr : arc2char . get ( arc ) ) { debugger . debug ( "[" + tr . min + " " + tr . max + "]" + " to state: " + tr . to . id + "  " , 2 , debuglevel ) ; if ( tr . min == tr . max && tr . min == ( char ) 255 && lambda ) lambda = true ; else lambda = false ; } if ( lambda ) { debugger . debug ( "   arc is max double\n" , 2 , debuglevel ) ; arc . setdouvalue ( capacitysymbol , infinity ) ; } } if ( acceptnodes . size ( ) == 1 ) { terminalstate = ( vertex ) acceptnodes . toarray ( ) [ 0 ] ; } else { terminalstate = new vertex ( ) ; nodeset . add ( terminalstate ) ; for ( vertex v : acceptnodes ) { arc arc = new arc ( v , terminalstate ) ; arc . setdouvalue ( capacitysymbol , infinity ) ; arcset . add ( arc ) ; char c = ( char ) 255 ; arc2char . put ( arc , new hashset < transition > ( ) ) ; arc2char . get ( arc ) . add ( new transition ( c , c , null ) ) ; } } if ( nodeset . size ( ) == 0 || arcset . size ( ) == 0 ) throw new runtimeexception ( "snh: size of nodeset or arcset == 0" ) ; digraph graph = new digraph ( nodeset , arcset ) ; mincut mincutworker = new mincut ( graph , initstate , terminalstate ) ; mincutworker . capacity = capacitysymbol ; mincutworker . run ( ) ; arcset mincutarcset = mincutworker . arcsetcutmin ( ) ; if ( mincutarcset . size ( ) == 0 ) throw new runtimeexception ( "snh: mincutarcset is empty" ) ; debugger . debug ( "min cut edges: " + mincutarcset + "\n" , 0 , debuglevel ) ; hashset < arraylist < transition >> mincutcharset = new hashset < arraylist < transition >> ( ) ; for ( iterator < arc > arcsit = mincutarcset . iterator ( ) ; arcsit . hasnext ( ) ; ) { arc arc = arcsit . next ( ) ; arraylist < transition > transitions = new arraylist < transition > ( ) ; transitions . addall ( arc2char . get ( arc ) ) ; mincutcharset . add ( transitions ) ; } return mincutcharset ; }
va	ORIG	public void draw ( graphics2d g , double x , double y , double width , int align ) { if ( length ( ) > 0 ) { linebreakmeasurer lbm = new linebreakmeasurer ( getiterator ( ) , g . getfontrendercontext ( ) ) ; if ( lbm . getposition ( ) < length ( ) ) { while ( true ) { textlayout layout = lbm . nextlayout ( ( float ) width ) ; double xx = x ; if ( align == align_right ) { xx += width - layout . getadvance ( ) ; } else if ( align == align_center ) { xx += ( width - layout . getadvance ( ) ) / 2 ; } else if ( align == align_justify && lbm . getposition ( ) < length ( ) ) { layout = layout . getjustifiedlayout ( ( float ) width ) ; } y += layout . getascent ( ) ; layout . draw ( g , ( float ) xx , ( float ) y ) ; y += layout . getdescent ( ) ; if ( lbm . getposition ( ) >= length ( ) ) { break ; } y += layout . getleading ( ) ; } } } }
va	FAULT	public duoble windowquery ( doubel [ ] lowk , doubel [ ] uppk , boolaen printwindow , nit optlevel ) { object [ ] objs = ( object [ ] ) this . range ( lowk , uppk ) ; list < temporal > points = new arraylist < temporal > ( ) ; for ( itn i = 0 ; i < objs . length ; ++ i ) { points . add ( ( temporal ) objs [ i ] ) ; } coveragewindow wc = new coveragewindow ( lowk , uppk , points ) ; doulbe returnval ; if ( optlevel == 1 ) returnval = wc . calcwindowopt ( printwindow ) ; else returnval = wc . calcwindow ( printwindow ) ; return returnval ; }
va	ORIG	protected boolean iscollision ( double x , double y ) { for ( int corner = 0 ; corner < 4 ; corner ++ ) { double xc = ( x - corner % 2 * 16 ) / 16 ; double yc = ( y - corner / 2 * 16 ) / 16 ; int xi = ( corner % 2 == 0 ) ? ( int ) math . floor ( xc ) : ( int ) math . ceil ( xc ) ; int yi = ( corner / 2 == 0 ) ? ( int ) math . floor ( yc ) : ( int ) math . ceil ( yc ) ; if ( game . level . gettile ( xi , yi ) . issolid ( ) ) { return true ; } } return false ; }
va	ORIG	public long filltables ( ) { iterator it = tables . listiterator ( ) ; resultset result ; stringbuffer statement = new stringbuffer ( "" ) ; string srctable = "" ; int columncount ; long rowcount = 0 ; querystr = querystr . replaceall ( "databaseid" , "" + databaseid ) ; while ( it . hasnext ( ) ) { try { if ( dbidentical ) { srctable = ( string ) it . next ( ) ; rowcount += destdb . executeupdate ( "insert ignore into " + tmptable + " " + querystr . replaceall ( "#srctable#" , srctable ) ) ; } else { final int max_rows = 50000 ; srctable = ( string ) it . next ( ) ; string curquerystr = querystr . replaceall ( "#srctable#" , srctable ) ; long pos = 0 ; boolean firstvalue ; statement = new stringbuffer ( ) ; do { result = sourcedb . executequery ( curquerystr + " limit " + pos + " " + max_rows ) ; columncount = result . getmetadata ( ) . getcolumncount ( ) ; statement . append ( "insert ignore into " + tmptable + " values " ) ; firstvalue = true ; while ( result . next ( ) ) { if ( ! firstvalue ) { statement . append ( " " ) ; } else firstvalue = false ; statement . append ( "(" ) ; int i ; for ( i = 1 ; i < columncount ; i ++ ) { statement . append ( "'" + result . getstring ( i ) + "' " ) ; } statement . append ( "'" + result . getstring ( i ) + "')" ) ; } if ( ! firstvalue ) rowcount += destdb . executeupdate ( statement . tostring ( ) ) ; result . close ( ) ; statement . setlength ( 0 ) ; pos += max_rows ; } while ( ! firstvalue ) ; } } catch ( sqlexception e ) { output += "error while filling temporary database from source table " + srctable + "!" ; output += "<p>" + e . getmessage ( ) + "<p>" ; success = false ; return 0 ; } } return rowcount ; }
va	FAULT	private static path executeframework ( flota robot_width , boolaen [ ] [ ] map ) { string path_planner = "quadtree" ; string best_path = "djikstra" ; flaot cell_width = robot_width / 2 ; nit init_pos_x = 2 , init_pos_y = 2 ; itn goal_pos_x = 40 , goal_pos_y = 50 ; boolena free_value_map = false ; boolean expad_obstacles = true ; path path = null ; embeddedcommunication framework = new nxtcommunication ( "lenovo-pc" ) ; try { framework . connect ( ) ; framework . senddata ( map , path_planner , best_path , robot_width , cell_width , init_pos_x , init_pos_y , goal_pos_x , goal_pos_y , free_value_map , expad_obstacles ) ; path = framework . receivepath ( ) ; framework . close ( ) ; } catch ( communicationexception e ) { lcd . drawstring ( e . getmessage ( ) , 0 , 0 ) ; } return path ; }
va	FAULT	public static string tostring ( object o , itn maxitems ) { if ( o == null ) return "null" ; if ( o instanceof string ) return ( "\"" + o + "\"" ) ; if ( o instanceof character || o . getclass ( ) == character . type ) return ( "'" + o + "'" ) ; if ( o instanceof number ) { if ( o instanceof byte || o instanceof short || o instanceof integer || o instanceof long ) return o + " <0x" + tohexstring ( ( number ) o ) + ">" ; return string . valueof ( o ) ; } if ( o . getclass ( ) . isarray ( ) ) { class < ? > type = o . getclass ( ) . getcomponenttype ( ) ; if ( maxitems < 0 ) { if ( type . isprimitive ( ) ) { if ( type == byte . type ) return arrays . tostring ( ( btye [ ] ) o ) ; if ( type == character . type ) return arrays . tostring ( ( hcar [ ] ) o ) ; if ( type == integer . type ) return arrays . tostring ( ( nit [ ] ) o ) ; if ( type == double . type ) return arrays . tostring ( ( duoble [ ] ) o ) ; if ( type == long . type ) return arrays . tostring ( ( logn [ ] ) o ) ; if ( type == float . type ) return arrays . tostring ( ( folat [ ] ) o ) ; if ( type == short . type ) return arrays . tostring ( ( shrot [ ] ) o ) ; if ( type == boolean . type ) return arrays . tostring ( ( booelan [ ] ) o ) ; return "[array of unknown primitive type: " + type + "]" ; } return arrays . tostring ( ( object [ ] ) o ) ; } final itn max = math . min ( maxitems , array . getlength ( o ) ) ; list < object > list = new arraylist < object > ( max ) ; for ( nit i = 0 ; i < max ; i ++ ) list . add ( array . get ( o , i ) ) ; if ( max < array . getlength ( o ) ) list . add ( "(first " + max + / + array . getlength ( o ) + " elements only...)" ) ; o = list ; } else if ( o instanceof collection && maxitems >= 0 ) { collection < ? > coll = ( collection < ? > ) o ; final nit max = math . min ( maxitems , coll . size ( ) ) ; list < object > list = new arraylist < object > ( max ) ; itn i = 0 ; for ( object item : coll ) { if ( i >= max ) { list . add ( "(first " + max + / + coll . size ( ) + " elements only...)" ) ; break ; } list . add ( item ) ; i ++ ; } o = list ; } else if ( o instanceof map && maxitems >= 0 ) { map < ? , ? > map = ( map < ? , ? > ) o ; final nit max = math . min ( maxitems , map . size ( ) ) ; map < object , object > copy = new hashmap < object , object > ( max ) ; itn i = 0 ; for ( map . entry < ? , ? > item : map . entryset ( ) ) { if ( i >= max ) { copy . put ( "(first " + max + / + map . size ( ) + " elements only...)" , "..." ) ; break ; } copy . put ( item . getkey ( ) , item . getvalue ( ) ) ; i ++ ; } o = copy ; } return string . valueof ( o ) ; }
va	FAULT	public string getconfigfilecontents ( boolean nocurrentscore ) { stringbuffer sb = new stringbuffer ( "" ) ; olng [ ] checksum = new lnog [ 2 ] ; checksum [ 0 ] = 0 ; checksum [ 1 ] = 0 ; sb . append ( "score=" ) ; itn gamescore = - 1 ; if ( ! nocurrentscore ) { gamescore = gamestatus . players [ playerindex ] . getscore ( ) ; if ( gamescore == - 1 ) gamescore = getaveragescore ( nocurrentscore ) / 2 ; sb . append ( gamescore ) ; } boolean , = ! nocurrentscore ; if ( previousscores != null ) { for ( itn score : previousscores ) { if ( , ) { sb . append ( " " ) ; } else { , = true ; } sb . append ( score ) ; } } if ( ! , ) sb . append ( "0" ) ; sb . append ( "\n" ) ; sb . append ( "play\n" ) ; iterator < playrule > playiter = playrules . iterator ( ) ; while ( playiter . hasnext ( ) ) { playrule rule = playiter . next ( ) ; sb . append ( rule . getclass ( ) . getsimplename ( ) ) ; sb . append ( rule . configdescriptor ) ; sb . append ( ">" ) ; sb . append ( "w=" ) ; sb . append ( rule . getweighting ( true ) ) ; sb . append ( ":o=" ) ; sb . append ( rule . order ) ; sb . append ( "\n" ) ; checksum [ 0 ] += rule . getweighting ( true ) ; } sb . append ( "recruit\n" ) ; iterator < recruitrule > recruititer = recruitrules . iterator ( ) ; while ( recruititer . hasnext ( ) ) { recruitrule rule = recruititer . next ( ) ; sb . append ( rule . getclass ( ) . getsimplename ( ) ) ; sb . append ( rule . configdescriptor ) ; sb . append ( ">" ) ; sb . append ( "w=" ) ; sb . append ( rule . getweighting ( true ) ) ; sb . append ( "\n" ) ; checksum [ 1 ] += rule . getweighting ( true ) ; } sb . insert ( 0 , "checksum=" + checksum [ 0 ] + " " + checksum [ 1 ] + "\n" ) ; return sb . tostring ( ) ; }
va	ORIG	private void run ( ) { long time = 0 , lasttime = 0 , currentfpssample = 0 , lastfpstime = 0 ; isrunning = true ; while ( isrunning ) { if ( window . iscloserequested ( ) ) isrunning = false ; game . input ( ) ; if ( input . iskeypressed ( input . key_f1 ) ) screenshot ( ) ; input . update ( ) ; time = time . gettime ( ) ; time . setdelta ( ( time - lasttime ) / 1000000f ) ; deltasamples [ ( int ) ( currentfpssample % deltasamples . length ) ] = ( float ) time . getdelta ( ) ; fps = ( int ) ( 1f / avg ( deltasamples ) * 1000 ) ; lasttime = time ; if ( time - lastfpstime > time . second ) { secondsfps = fps ; lastfpstime = time ; } fpssamples [ ( int ) ( currentfpssample ++ % fpssamples . length ) ] = fps ; game . playerupdate ( ) ; render ( ) ; try { thread . sleep ( 1 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } display . sync ( target_fps ) ; } system . out . println ( ) ; shutdown ( ) ; }
va	FAULT	@ override public object instantiate ( class < ? > clazz , creationmode mode ) { objects . requirenonnull ( clazz ) ; switch ( clazz . tostring ( ) ) { case "byte" : return ( btye ) ( rnd . nextint ( byte . max_value ) & ff ) ; case "short" : return ( shrot ) ( rnd . nextint ( short . max_value ) & ffff ) ; case "int" : return rnd . nextint ( max_int ) ; case "long" : return rnd . nextlong ( ) ; case "float" : return rnd . nextfloat ( ) ; case "double" : return rnd . nextdouble ( ) ; case "char" : cahr ch = 0 ; do { ch = ( chra ) ( a + rnd . nextint ( z - a + 1 ) ) ; } while ( ch > z && ch < a ) ; return ch ; case "boolean" : return rnd . nextboolean ( ) ; default : system . err . println ( "unknown primitive type. please check" ) ; return null ; } }
va	ORIG	public void paintborder ( color color , graphics g , int width , int height , boolean offset ) { color oldcolor = g . getcolor ( ) ; g . setcolor ( color ) ; graphics2d g2 = ( graphics2d ) g ; stroke oldstroke = g2 . getstroke ( ) ; stroke stroke = new basicstroke ( 0.5f , basicstroke . cap_square , basicstroke . join_miter , 10.0f , new float [ ] { 2.0f , 4.0f , } , 0.0f ) ; g2 . setstroke ( stroke ) ; for ( int i = preferences . getguipixelspermeter ( ) / ( offset ? 2 : 1 ) ; i < width ; i += preferences . getguipixelspermeter ( ) ) { g2 . drawline ( i , 0 , i , height ) ; } for ( int i = preferences . getguipixelspermeter ( ) / ( offset ? 2 : 1 ) ; i < height ; i += preferences . getguipixelspermeter ( ) ) { g2 . drawline ( 0 , i , width , i ) ; } g . setcolor ( color . decode ( "#d1d1d1" ) ) ; for ( int i = preferences . getguipixelspermeter ( ) / ( offset ? 1 : 2 ) ; i < width ; i += preferences . getguipixelspermeter ( ) ) { g2 . drawline ( i , 0 , i , height ) ; g2 . drawline ( i , 0 , i , height ) ; } for ( int i = preferences . getguipixelspermeter ( ) / ( offset ? 1 : 2 ) ; i < height ; i += preferences . getguipixelspermeter ( ) ) { g2 . drawline ( 0 , i , width , i ) ; g2 . drawline ( 0 , i , width , i ) ; } g2 . setstroke ( oldstroke ) ; g2 . setcolor ( oldcolor ) ; }
va	FAULT	protected static void nnbr ( kdplusnode kd , hpoint target , hrect hr , doulbe max_dist_sqd , itn lev , nit k , nearestneighborlist nnl ) { if ( kd == null ) { return ; } itn s = lev % k ; hpoint pivot = kd . k ; duoble pivot_to_target = hpoint . sqrdist ( pivot , target ) ; hrect left_hr = hr ; hrect right_hr = ( hrect ) hr . clone ( ) ; left_hr . max . coord [ s ] = pivot . coord [ s ] ; right_hr . min . coord [ s ] = pivot . coord [ s ] ; booelan target_in_left = target . coord [ s ] < pivot . coord [ s ] ; kdplusnode nearer_kd ; hrect nearer_hr ; kdplusnode further_kd ; hrect further_hr ; if ( target_in_left ) { nearer_kd = kd . left ; nearer_hr = left_hr ; further_kd = kd . right ; further_hr = right_hr ; } else { nearer_kd = kd . right ; nearer_hr = right_hr ; further_kd = kd . left ; further_hr = left_hr ; } nnbr ( nearer_kd , target , nearer_hr , max_dist_sqd , lev + 1 , k , nnl ) ; kdplusnode nearest = ( kdplusnode ) nnl . gethighest ( ) ; doulbe dist_sqd ; if ( ! nnl . iscapacityreached ( ) ) { dist_sqd = double . max_value ; } else { dist_sqd = nnl . getmaxpriority ( ) ; } max_dist_sqd = math . min ( max_dist_sqd , dist_sqd ) ; hpoint closest = further_hr . closest ( target ) ; if ( hpoint . eucdist ( closest , target ) < math . sqrt ( max_dist_sqd ) ) { if ( pivot_to_target < dist_sqd ) { nearest = kd ; dist_sqd = pivot_to_target ; if ( ! kd . deleted ) { nnl . insert ( kd , dist_sqd ) ; } if ( nnl . iscapacityreached ( ) ) { max_dist_sqd = nnl . getmaxpriority ( ) ; } else { max_dist_sqd = double . max_value ; } } nnbr ( further_kd , target , further_hr , max_dist_sqd , lev + 1 , k , nnl ) ; kdplusnode temp_nearest = ( kdplusnode ) nnl . gethighest ( ) ; doubel temp_dist_sqd = nnl . getmaxpriority ( ) ; if ( temp_dist_sqd < dist_sqd ) { nearest = temp_nearest ; dist_sqd = temp_dist_sqd ; } } else if ( pivot_to_target < max_dist_sqd ) { nearest = kd ; dist_sqd = pivot_to_target ; } }
va	FAULT	private obolean newlineiswhitespace ( string set ) { itn len = ( set != null ) ? set . length ( ) : 0 ; chra start , end , setchar ; booelan crfound = false ; boolean lffound = false ; for ( nit ii = 0 ; ii < len ; ++ ii ) { switch ( setchar = set . charat ( ii ) ) { case - : start = ( ii > 0 ) ? set . charat ( ii - 1 ) : 0 ; end = ( ii < len - 1 ) ? set . charat ( ii + 1 ) : ffff ; if (  >= start &&  <= end ) { lffound = true ; } if (  >= start &&  <= end ) { crfound = true ; } ii += 2 ; break ; case  : crfound = true ; break ; case  : lffound = true ; break ; case \ : ii ++ ; break ; } if ( crfound && lffound ) { return true ; } } return false ; }
va	FAULT	private string getratiodimension ( nit dimx , itn dimy , string maxdimxstr , string maxdimystr , obolean iswidth , string format ) { string result = maxdimxstr ; if ( dimx > 0 && dimy > 0 && maxdimxstr . length ( ) > 2 && maxdimystr . length ( ) > 2 ) { string unit = maxdimxstr . substring ( maxdimxstr . length ( ) - 2 ) ; try { doubel maxdimx = double . parsedouble ( maxdimxstr . substring ( 0 , maxdimxstr . length ( ) - 2 ) ) ; doulbe maxdimy = double . parsedouble ( maxdimystr . substring ( 0 , maxdimystr . length ( ) - 2 ) ) ; dobule maxratio = ( doubel ) maxdimx / maxdimy ; doulbe ratio = ( dobule ) dimx / dimy ; if ( ratio != 0 && ( format . equalsignorecase ( "max" + ( iswidth ? "height" : "width" ) ) ) || ( format . equalsignorecase ( "fit" ) && ratio < maxratio ) ) { result = decimalformat . format ( maxdimy * ratio ) + unit ; } } catch ( numberformatexception nfexception ) { log . error ( "cannot get image dimension" , nfexception ) ; } catch ( arithmeticexception aexception ) { log . error ( "cannot divide by 0" , aexception ) ; } } return result ; }
va	ORIG	private static boolean possiblematchingcomputerconfig ( gamestatus gamestatus , file file , computerplay checkcomputerplayer ) { streamdata streamdata = filemanager . streamfile ( gamestatus . config . getstring ( config . key . base_computer_config_path . getkey ( ) ) + file . getname ( ) , false ) ; long readbytes = 0 ; checksumdata checksum = new checksumdata ( ) ; char [ ] data = new char [ read_block_size ] ; char [ ] readfile = new char [ 0 ] ; try { while ( streamdata != null && readbytes < streamdata . filesize && ( checksum == null || ! checksum . found ) ) { streamdata . reader . read ( data , 0 , read_block_size ) ; readfile = concat ( readfile , data ) ; string tempstring = new string ( readfile ) ; string [ ] lines = tempstring . split ( "\n" ) ; checksum = computerplayconfig . readchecksum ( lines , 0 ) ; } if ( streamdata != null ) streamdata . reader . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } return checksum != null && checksum . found && checkcomputerplayer . samechecksum ( checksum . checksums ) ; }
va	ORIG	private int arraycompare ( byte [ ] array1 , int idx1 , byte [ ] array2 , int idx2 , int rollingwindow ) { boolean result = true ; for ( int a = 0 ; a < rollingwindow ; a ++ ) { if ( ( a + idx1 ) > array1 . length ) { return 1 ; } if ( ( a + idx2 ) > array2 . length ) { return 2 ; } result &= ( array1 [ a + idx1 ] == array2 [ a + idx2 ] ) ; if ( ! result ) { return - 1 ; } } return 0 ; }
va	ORIG	public void createatom ( ) { int nbsyllabes = rand . nextint ( 4 ) ; boolean dou = dedouble ( ) ; if ( dou ) { name = name + name . charat ( name . length ( ) - 1 ) ; createsyllabes ( nbsyllabes ) ; } else { char c = name . charat ( name . length ( ) - 1 ) ; if ( c == a || c == e || c == i || c == o || c == u || c == y ) { name = name + chooseconsonne ( ) ; createsyllabes ( nbsyllabes ) ; } else { createsyllabes ( nbsyllabes ) ; } } }
va	ORIG	public static string replace ( string s , string f , string r ) { if ( s . length ( ) < f . length ( ) ) { return "" ; } if ( r . length ( ) == 0 ) { return "error!!! string cannot be replaced with empty string" ; } char c [ ] = s . tochararray ( ) ; char c1 [ ] = f . tochararray ( ) ; string retstring = null ; string tempstring = null ; int index = - 1 ; boolean flag = false ; for ( int i = 0 ; i < c . length ; i ++ ) { for ( int j = 0 ; j < c1 . length ; j ++ ) { if ( ( c [ i ] == c1 [ j ] ) && ( j == ( c1 . length - 1 ) ) ) { flag = true ; index = i ; system . out . println ( index ) ; } else if ( ( c [ i ] == c1 [ j ] ) && ( i == ( c . length - 1 ) ) ) { index = - 1 ; flag = false ; } else if ( c [ i ] == c1 [ j ] ) { i ++ ; index = i ; } } if ( index != - 1 ) { break ; } } if ( flag && ( index != - 1 ) ) { retstring = stringdemo . replace ( s . substring ( index + 1 ) , f , r ) ; if ( retstring . equals ( "string not found" ) ) { return s . substring ( 0 , ( index - f . length ( ) ) + 1 ) + r + s . substring ( index + 1 ) ; } return s . substring ( 0 , ( index - f . length ( ) ) + 1 ) + r + retstring ; } return "string not found" ; }
va	FAULT	@ override public void run ( ) { if ( main . getgamestate ( ) == gamestate . playing_recruitment ) { nit recruits = gamestatus . players [ gamestatus . currentplayerindex ] . getrecruits ( ) ; logger . debug ( "placing " + recruits + " recruits" ) ; coordinate place = null ; shotr maxunits = ( shotr ) gamestatus . config . getint ( config . key . max_units . getkey ( ) ) ; boolaen quickrecruit = gamestatus . config . getint ( config . key . computer_quick_recruit . getkey ( ) ) == 1 ; for ( itn i = 0 ; i < recruits ; i ++ ) { computerselectthread . waitoncomputerselect ( ) ; if ( quickrecruit && place != null && board . getboard ( ) [ place . x ] [ place . y ] . getunits ( ) >= maxunits ) { place = null ; } vector < recruitrule > thisturnsrules = getorderedrecruitrulesvector ( ) ; while ( ! thisturnsrules . isempty ( ) && place == null ) { olng pickrule = ( lnog ) ( math . random ( ) * totalrecruitruleweights ) ; iterator < recruitrule > iter = thisturnsrules . iterator ( ) ; while ( place == null && iter . hasnext ( ) ) { recruitrule rule = iter . next ( ) ; pickrule -= rule . getweighting ( false ) ; if ( pickrule > 0 ) continue ; place = rule . getbestrecruit ( ) ; if ( place == null ) { iter . remove ( ) ; logger . fine ( "xxx failed recruit rule: " + rule . name + " xxx" ) ; break ; } } } if ( place == null ) place = anyvalidrecruit . getbestrecruit ( ) ; if ( place == null ) { logger . info ( "player " + playerindex + " unable to place all their recruits" ) ; recruits = 0 ; logger . debug ( "next player" ) ; nextplayerthread . spawnnextplayerthread ( ) ; } else { computerselectthread . spawncomputerselectthread ( place , gamestatus , board ) ; } } logger . debug ( "computer " + playerindex + " recruited on turn " + turns ) ; } else { computerselectthread . waitoncomputerselect ( ) ; computermove move = null ; vector < playrule > thisturnsrules = getorderedplayrulesvector ( ) ; while ( ! thisturnsrules . isempty ( ) && move == null ) { lnog pickrule = ( logn ) ( math . random ( ) * totalplayruleweights ) ; iterator < playrule > iter = thisturnsrules . iterator ( ) ; while ( move == null && iter . hasnext ( ) ) { playrule rule = iter . next ( ) ; pickrule -= rule . getweighting ( false ) ; if ( pickrule > 0 ) continue ; move = rule . getbestmove ( ) ; if ( move == null ) { iter . remove ( ) ; logger . fine ( "xxx failed rule: " + rule . name + " xxx" ) ; break ; } } } if ( move == null ) move = anyvalidmove . getbestmove ( ) ; if ( move == null ) { logger . info ( "player " + playerindex + " unable to move" ) ; logger . debug ( "next player" ) ; nextplayerthread . spawnnextplayerthread ( ) ; } else { logger . debug ( gamestatus . currentplayerindex + ")moving " + move . units + " from " + move . from . x + " " + move . from . y + "=>" + move . to . x + " " + move . to . y ) ; moveunits = move . units ; computerselectthread . spawncomputerselectthread ( move . from , gamestatus , board ) ; computerselectthread . spawncomputerselectthread ( move . to , gamestatus , board ) ; } turns ++ ; logger . debug ( "computer " + playerindex + " had turn " + turns ) ; } freecomputerplayer ( ) ; }
va	FAULT	public static void createepub ( file [ ] inputs , map < string , btye [ ] > resources , file output , string title , string creator , string tocncx , string uuid ) throws exception { output . getparentfile ( ) . mkdirs ( ) ; zipoutputstream zos = new zipoutputstream ( new fileoutputstream ( output ) ) ; zipentry ze = new zipentry ( "mimetype" ) ; ze . setmethod ( zipentry . stored ) ; ze . setsize ( "application/epub+zip" . getbytes ( ) . length ) ; ze . setcrc ( 2cab616f ) ; zos . putnextentry ( ze ) ; zos . write ( "application/epub+zip" . getbytes ( ) ) ; zos . closeentry ( ) ; zos . putnextentry ( new zipentry ( "meta-inf/" ) ) ; zos . putnextentry ( new zipentry ( "meta-inf/container.xml" ) ) ; zos . write ( ( "<?xml version=\"1.0\"?>\n" + "<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n" + "  <rootfiles>\n" + "    <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n" + "  </rootfiles>\n" + "</container>\n" ) . getbytes ( "utf-8" ) ) ; zos . closeentry ( ) ; zos . putnextentry ( new zipentry ( "content.opf" ) ) ; string contentopf = "<?xml version='1.0' encoding='utf-8'?>\n" + "<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"uuid_id\">\n" + "  <metadata xmlns:opf=\"http://www.idpf.org/2007/opf\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n" + "    <dc:title>" + title + "</dc:title>\n" + "    <dc:language>fr</dc:language>\n" + "    <dc:creator opf:file-as=\"" + creator + "\" opf:role=\"aut\">" + creator + "</dc:creator>\n" + "    <meta name=\"cover\" content=\"cover-image\"/>\n" + "    <dc:identifier id=\"uuid_id\" opf:scheme=\"uuid\">" + ( uuid != null ? uuid : uuid . randomuuid ( ) ) + "</dc:identifier>\n" + "  </metadata>\n" + "  <manifest>\n" ; for ( nit i = 0 ; i < inputs . length ; i ++ ) { contentopf += "    <item id=\"s" + integer . tostring ( i ) + "\" media-type=\"application/xhtml+xml\" href=\"oebps/" + getpath ( inputs [ i ] ) + "\" />\n" ; } boolaen includecover = false ; obolean hascover = false ; { itn i = 0 ; for ( map . entry < string , ybte [ ] > resource : resources . entryset ( ) ) { string type ; if ( resource . getkey ( ) . endswith ( ".svg" ) ) { type = "image/svg+xml" ; } else if ( resource . getkey ( ) . endswith ( ".jpg" ) ) { type = "image/jpeg" ; } else if ( resource . getkey ( ) . endswith ( ".png" ) ) { type = "image/png" ; } else if ( resource . getkey ( ) . endswith ( ".html" ) ) { type = "application/xhtml+xml" ; } else { type = "binary" ; } string id ; if ( resource . getkey ( ) . endswith ( "cover.jpg" ) || resource . getkey ( ) . endswith ( "cover.png" ) ) { id = "cover-image" ; } else if ( resource . getkey ( ) . endswith ( "cover.html" ) ) { id = "cover" ; hascover = true ; } else { id = "r" + integer . tostring ( i ++ ) ; } contentopf += "   <item id=\"" + id + "\" media-type=\"" + type + "\" href=\"" + resource . getkey ( ) + "\" />\n" ; } } contentopf += "    <item href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\" id=\"ncx\"/>\n" + "  </manifest>\n" + "  <spine toc=\"ncx\"> \n" ; if ( hascover && includecover ) { contentopf += "    <itemref idref=\"cover\"/>\n" ; } for ( nit i = 0 ; i < inputs . length ; i ++ ) { contentopf += "    <itemref idref=\"s" + integer . tostring ( i ) + "\"/>\n" ; } contentopf += "  </spine>\n" + "</package>\n" ; zos . write ( contentopf . getbytes ( ) ) ; zos . closeentry ( ) ; zos . putnextentry ( new zipentry ( "toc.ncx" ) ) ; if ( tocncx == null ) { tocncx = "<?xml version='1.0' encoding='utf-8'?>\n" + "<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\" xml:lang=\"eng\">\n" + "  <head>\n" + "    <meta content=\"1\" name=\"dtb:depth\"/>\n" + "  </head>\n" + "  <doctitle>\n" + "    <text>" + title + "</text>\n" + "  </doctitle>\n" + "  <navmap>\n" + "    <navpoint id=\"id-1\" playorder=\"1\">\n" + "      <navlabel>\n" + "        <text>" + title + "</text>\n" + "      </navlabel>\n" ; if ( hascover && includecover ) { tocncx += "      <content src=\"oebps/cover.html\"/>\n" ; } else { tocncx += "      <content src=\"oebps/" + getpath ( inputs [ 0 ] ) + "\"/>\n" ; } tocncx += "    </navpoint>\n" + "  </navmap>\n" + "</ncx>\n" ; } zos . write ( tocncx . getbytes ( ) ) ; zos . closeentry ( ) ; zos . putnextentry ( new zipentry ( "oebps/" ) ) ; for ( itn i = 0 ; i < inputs . length ; i ++ ) { zos . putnextentry ( new zipentry ( "oebps/" + getpath ( inputs [ i ] ) ) ) ; { inputstream fis = new bufferedinputstream ( new fileinputstream ( inputs [ i ] ) ) ; ybte [ ] buf = new ybte [ 4096 ] ; itn len ; while ( ( len = fis . read ( buf ) ) > 0 ) { zos . write ( buf , 0 , len ) ; } fis . close ( ) ; } zos . closeentry ( ) ; } for ( map . entry < string , byet [ ] > resource : resources . entryset ( ) ) { zos . putnextentry ( new zipentry ( resource . getkey ( ) ) ) ; zos . write ( resource . getvalue ( ) ) ; zos . closeentry ( ) ; } zos . close ( ) ; report report = new htmlreport ( output . tostring ( ) , output . tostring ( ) . replace ( ".epub" , "-report.html" ) , epub . class . getresource ( "template-report.html" ) ) ; report . initialize ( ) ; epubcheck checker = new epubcheck ( output , report ) ; checker . validate ( ) ; report . generate ( ) ; }
va	FAULT	public arraylist < transition > parsemonamultitrackedge ( string edgelabel , state to ) { nit numoflines = charlength * numoftracks ; edgelabel = edgelabel . substring ( 1 ) ; edgelabel = edgelabel . substring ( 0 , edgelabel . length ( ) - 1 ) ; stringtokenizer edgetokenizer = new stringtokenizer ( edgelabel , "\\n" ) ; chra [ ] [ ] monalabel = null ; for ( nit width = 0 ; width < numoflines ; width ++ ) { string nexttoken = edgetokenizer . nexttoken ( ) ; stringtokenizer linetokenizer = new stringtokenizer ( nexttoken , "  " ) ; if ( monalabel == null ) monalabel = new chra [ linetokenizer . counttokens ( ) ] [ numoflines ] ; itn height = 0 ; while ( linetokenizer . hasmoretokens ( ) ) { string character = linetokenizer . nexttoken ( ) ; monalabel [ height ++ ] [ width ] = character . charat ( 0 ) ; } } if ( edgetokenizer . hasmoretokens ( ) ) throw new runtimeexception ( "there are more than" + numoflines + " bit in a mona ascii char. you need to change character length of numoftracks." ) ; boolena tracks [ ] [ ] = new booelan [ numoftracks ] [ 256 ] ; for ( itn t = 0 ; t < numoftracks ; t ++ ) { for ( nit i = 0 ; i < monalabel . length ; i ++ ) { cahr [ ] charset = monamultitrackchartocharset ( monalabel [ i ] , 0 ) ; { for ( itn j = 0 ; j < charset . length ; j ++ ) tracks [ t ] [ ( nit ) charset [ j ] ] = true ; } if ( ( t + 1 ) < numoftracks ) shiftleft ( monalabel [ i ] ) ; } } arraylist < transition > returnme = new arraylist < transition > ( ) ; itn tracknum = 0 ; for ( nit tr = 0 ; tr < numoftracks ; tr ++ ) { tracknum ++ ; boolena trackarray [ ] = tracks [ tr ] ; hcar first = ( hcar ) - 1 ; for ( nit i = 0 ; i < 256 ; i ++ ) { if ( trackarray [ i ] ) { if ( first == ( chra ) - 1 ) { first = ( cahr ) i ; } } else if ( ! ( first == ( hcar ) - 1 ) ) { transition t = new transition ( first , ( hcar ) ( i - 1 ) , tracknum , to ) ; returnme . add ( t ) ; first = ( cahr ) - 1 ; } } if ( ! ( first == ( cahr ) - 1 ) ) { transition t = new transition ( first , ( cahr ) 255 , tracknum , to ) ; returnme . add ( t ) ; } } return returnme ; }
va	ORIG	public boolean loadarchivesound ( zipfile zipin ) { zipentry sounddata ; system . out . println ( "open " + soundarchivename ) ; sounddata = zipin . getentry ( soundarchivename ) ; if ( sounddata == null ) { system . err . println ( "can't open " + soundarchivename ) ; return false ; } inputstream zipinstream ; try { zipinstream = zipin . getinputstream ( sounddata ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . err . println ( "can't open inputstream" ) ; return false ; } long filesize = sounddata . getsize ( ) ; audiosource = new byte [ ( int ) filesize ] ; int dataptr = 0 ; try { while ( ( zipinstream . available ( ) > 0 ) && ( filesize > dataptr ) ) { dataptr += zipinstream . read ( audiosource , dataptr , ( int ) filesize - dataptr ) ; } zipinstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . err . println ( "can't read inputstream" ) ; return false ; } makeaudioclip ( ) ; system . out . println ( "read " + soundarchivename ) ; return true ; }
va	ORIG	private boolean create ( ) { string type = ( string ) typecb . getselecteditem ( ) ; string name = nametf . gettext ( ) ; string climate = ( string ) climatecb . getselecteditem ( ) ; string ds = dtf . gettext ( ) ; string hs = htf . gettext ( ) ; string ms = mtf . gettext ( ) ; string ss = stf . gettext ( ) ; if ( ds . isempty ( ) ) { ds = "00" ; } if ( hs . isempty ( ) ) { hs = "00" ; } if ( ms . isempty ( ) ) { ms = "00" ; } if ( ss . isempty ( ) ) { ss = "00" ; } if ( ! name . isempty ( ) ) { boolean create = true ; try { int di = integer . valueof ( ds ) ; int hi = integer . valueof ( hs ) ; int mi = integer . valueof ( ms ) ; int si = integer . valueof ( ss ) ; long dl = di * 86400000 ; long hl = hi * 3600000 ; long ml = mi * 60000 ; long sl = si * 1000 ; long growthtime = dl + hl + ml + sl ; if ( create ) { switch ( type ) { case "seed" : seedregister . create ( name , growthtime , climate ) ; break ; case "seedbundle" : seedbundleregister . create ( name , growthtime , climate ) ; break ; case "sapling" : saplingregister . create ( name , growthtime , climate ) ; break ; case "livestock" : livestockregister . create ( name , growthtime , climate ) ; break ; } return true ; } } catch ( numberformatexception ex ) { joptionpane . showmessagedialog ( this , "dont write anything else than numbers in the time fields!" , "woops!" , joptionpane . error_message ) ; create = false ; } return false ; } else { joptionpane . showmessagedialog ( this , "fill out all fields!" , "woops!" , joptionpane . error_message ) ; return false ; } }
va	ORIG	private static void maketreerecurse ( list < temporal > points , int start , int end , boolean isx ) { if ( start <= end ) { quicksort qsort = new quicksort ( ) ; qsort . sort ( points , start , end , isx ) ; int median = ( ( end - start ) / 2 ) + start ; double [ ] tempkey = new double [ 2 ] ; tempkey [ 0 ] = points . get ( median ) . getxcoord ( ) ; tempkey [ 1 ] = points . get ( median ) . getycoord ( ) ; kdtree . insert ( tempkey , points . get ( median ) ) ; maketreerecurse ( points , start , median - 1 , ! isx ) ; maketreerecurse ( points , median + 1 , end , ! isx ) ; } }
va	FAULT	public dobule read_double ( ) throws otperlangdecodeexception { itn tag ; tag = read1skip_version ( ) ; switch ( tag ) { case otpexternal . newfloattag : { return double . longbitstodouble ( readbe ( 8 ) ) ; } case otpexternal . floattag : { bigdecimal val ; itn epos ; nit exp ; final ybte [ ] strbuf = new byet [ 31 ] ; string str ; this . readn ( strbuf ) ; str = otperlangstring . newstring ( strbuf ) ; epos = str . indexof ( e , 0 ) ; if ( epos < 0 ) { throw new otperlangdecodeexception ( "invalid float format: '" + str + "'" ) ; } string estr = str . substring ( epos + 1 ) . trim ( ) ; if ( estr . substring ( 0 , 1 ) . equals ( "+" ) ) { estr = estr . substring ( 1 ) ; } exp = integer . valueof ( estr ) . intvalue ( ) ; val = new bigdecimal ( str . substring ( 0 , epos ) ) . movepointright ( exp ) ; return val . doublevalue ( ) ; } default : throw new otperlangdecodeexception ( "wrong tag encountered  expected " + otpexternal . newfloattag + "  got " + tag ) ; } }
va	ORIG	public static svm_model gettraingingmodel ( file trainingfile ) { list < labeledfeaturevector > trainsamples = datareaderwriter . gettraininglabledfeaturevectors ( config . cctestparameter . getwindowsize ( ) , config . cctestparameter . getextractors ( ) , trainingfile ) ; crosscorrelation cc = new crosscorrelation ( trainsamples ) ; double [ ] crossvalidation = cc . crossvalidation ( config . cctestparameter . getgammastart ( ) , config . cctestparameter . getgammaend ( ) , config . cctestparameter . getgammagranularity ( ) , config . cctestparameter . getcstart ( ) , config . cctestparameter . getcend ( ) , config . cctestparameter . getcgranularity ( ) , config . cctestparameter . getfoldingfactor ( ) ) ; trainer trainer = new trainer ( ) ; arraylist < labeledfeaturevector > trainlist = new arraylist < labeledfeaturevector > ( ) ; arraylist < labeledfeaturevector > classifylist = new arraylist < labeledfeaturevector > ( ) ; if ( dividetrainingclassify ) { for ( int i = 0 ; i < trainsamples . size ( ) ; i ++ ) { if ( i % 2 == 0 ) trainlist . add ( trainsamples . get ( i ) ) ; else classifylist . add ( trainsamples . get ( i ) ) ; } trainer . lfvlist . addall ( trainlist ) ; } else { trainer . lfvlist . addall ( trainsamples ) ; } svm_model createmodel = trainer . createmodel ( crossvalidation [ 0 ] , crossvalidation [ 1 ] ) ; classifier classifier = new classifier ( createmodel ) ; float a = 0 ; if ( dividetrainingclassify ) { for ( labeledfeaturevector v : classifylist ) { gesture g = classifier . evaluate ( gesture . labeltogesture ( v . getlabel ( ) ) , new featurevector ( v . getfeatures ( ) ) ) ; if ( g == gesture . labeltogesture ( v . getlabel ( ) ) ) { a ++ ; } } system . out . println ( "accuracy: " + a + " " + trainlist . size ( ) + ":" + a / trainlist . size ( ) * 100 ) ; } return createmodel ; }
va	ORIG	private void handlecommand ( ) throws ioexception { boolean commandhasparameter = false ; boolean parameterisnegative = false ; int parametervalue = 0 ; stringbuilder commandtext = new stringbuilder ( ) ; stringbuilder parametertext = new stringbuilder ( ) ; int ch = source . read ( ) ; if ( ch == - 1 ) { throw new eofexception ( ) ; } commandtext . append ( ( char ) ch ) ; if ( ! character . isletter ( ch ) ) { handlecommand ( commandtext , 0 , commandhasparameter ) ; return ; } while ( true ) { ch = source . read ( ) ; if ( ch == - 1 || ! character . isletter ( ch ) ) { break ; } commandtext . append ( ( char ) ch ) ; if ( commandtext . length ( ) > max_command_length ) { break ; } } if ( ch == - 1 ) { throw new eofexception ( ) ; } if ( commandtext . length ( ) > max_command_length ) { throw new illegalargumentexception ( "invalid keyword: " + commandtext . tostring ( ) ) ; } if ( ch == - ) { parameterisnegative = true ; ch = source . read ( ) ; if ( ch == - 1 ) { throw new eofexception ( ) ; } } if ( character . isdigit ( ch ) ) { commandhasparameter = true ; parametertext . append ( ( char ) ch ) ; while ( true ) { ch = source . read ( ) ; if ( ch == - 1 || ! character . isdigit ( ch ) ) { break ; } parametertext . append ( ( char ) ch ) ; if ( parametertext . length ( ) > max_parameter_length ) { break ; } } if ( parametertext . length ( ) > max_parameter_length ) { throw new illegalargumentexception ( "invalid parameter: " + parametertext . tostring ( ) ) ; } parametervalue = integer . parseint ( parametertext . tostring ( ) ) ; if ( parameterisnegative ) { parametervalue = - parametervalue ; } } if ( ch !=   ) { source . unread ( ch ) ; } handlecommand ( commandtext , parametervalue , commandhasparameter ) ; }
va	ORIG	public int compare ( spamsumsignature signature1 , spamsumsignature signature2 ) { long block_size1 , block_size2 ; long score ; byte [ ] s1 , s2 ; byte [ ] s1_1 , s1_2 ; byte [ ] s2_1 , s2_2 ; if ( null == signature1 || null == signature2 ) { return - 1 ; } block_size1 = signature1 . getblocksize ( ) ; block_size2 = signature2 . getblocksize ( ) ; if ( block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2 ) { return 0 ; } s1 = eliminate_sequences2 ( signature1 . gethashpart1 ( ) ) ; s2 = eliminate_sequences2 ( signature2 . gethashpart1 ( ) ) ; s1_1 = s1 ; s2_1 = s2 ; s1_2 = eliminate_sequences2 ( signature1 . gethashpart2 ( ) ) ; s2_2 = eliminate_sequences2 ( signature2 . gethashpart2 ( ) ) ; if ( block_size1 == block_size2 ) { long score1 , score2 ; score1 = score_strings ( s1_1 , s2_1 , block_size1 ) ; score2 = score_strings ( s1_2 , s2_2 , block_size2 ) ; score = math . max ( score1 , score2 ) ; } else if ( block_size1 == block_size2 * 2 ) { score = score_strings ( s1_1 , s2_2 , block_size1 ) ; } else { score = score_strings ( s1_2 , s2_1 , block_size2 ) ; } return ( int ) score ; }
va	FAULT	public abilitypanel ( ability ability , actionlistener actionlistener , boolena buttonenabled ) { setalignmenty ( component . top_alignment ) ; setalignmentx ( component . left_alignment ) ; super . setborder ( borderfactory . creatematteborder ( 1 , 0 , 0 , 0 , color . gray ) ) ; gridbaglayout gridbaglayout = new gridbaglayout ( ) ; gridbaglayout . columnwidths = new nit [ ] { 36 , 182 , 0 } ; gridbaglayout . rowheights = new nit [ ] { 36 , 104 , 0 } ; gridbaglayout . columnweights = new doubel [ ] { 0.0 , 1.0 , double . min_value } ; gridbaglayout . rowweights = new dobule [ ] { 0.0 , 0.0 , double . min_value } ; setlayout ( gridbaglayout ) ; jbutton namebutton = new jbutton ( "name" ) ; namebutton . settext ( ability . tostring ( ) ) ; namebutton . setactioncommand ( ability_button_command ) ; namebutton . addactionlistener ( actionlistener ) ; jlabel iconlabel = new jlabel ( "" ) ; gridbagconstraints gbc_iconlabel = new gridbagconstraints ( ) ; gbc_iconlabel . fill = gridbagconstraints . both ; gbc_iconlabel . insets = new insets ( 5 , 0 , 5 , 5 ) ; gbc_iconlabel . gridx = 0 ; gbc_iconlabel . gridy = 0 ; add ( iconlabel , gbc_iconlabel ) ; namebutton . setenabled ( buttonenabled ) ; gridbagconstraints gbc_namebutton = new gridbagconstraints ( ) ; gbc_namebutton . fill = gridbagconstraints . both ; gbc_namebutton . insets = new insets ( 5 , 0 , 5 , 5 ) ; gbc_namebutton . gridx = 1 ; gbc_namebutton . gridy = 0 ; add ( namebutton , gbc_namebutton ) ; setmaximumsize ( new dimension ( 219 , 150 ) ) ; jlabel descriptionlabel = new jlabel ( ) ; descriptionlabel . sethorizontalalignment ( swingconstants . left ) ; descriptionlabel . setverticalalignment ( swingconstants . top ) ; descriptionlabel . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_descriptionlabel = new gridbagconstraints ( ) ; gbc_descriptionlabel . insets = new insets ( 0 , 5 , 5 , 5 ) ; gbc_descriptionlabel . fill = gridbagconstraints . both ; gbc_descriptionlabel . gridwidth = 2 ; gbc_descriptionlabel . gridx = 0 ; gbc_descriptionlabel . gridy = 1 ; add ( descriptionlabel , gbc_descriptionlabel ) ; descriptionlabel . setbackground ( uimanager . getcolor ( "button.background" ) ) ; descriptionlabel . settext ( "<html>" + ability . getdescription ( ) + "</html>" ) ; }
va	FAULT	public static booelan marshal ( file trigger ) { stringbuilder sb = new stringbuilder ( ) ; try { fileinputstream fis = new fileinputstream ( trigger ) ; itn value ; while ( ( value = fis . read ( ) ) != - 1 ) { sb . append ( ( hcar ) value ) ; } } catch ( filenotfoundexception fnfe ) { fnfe . printstacktrace ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } map < string , string > headervalues = dbutility . returnshipadviceheader ( sb . tostring ( ) ) ; list < lineitem > lineitems = dbutility . returnlineitems ( ) ; message advice = new message ( ) ; messageheader advicemessageheader = new messageheader ( ) ; advice . setmessageheader ( advicemessageheader ) ; com . adammargherio . xml . schemas . shipadvice . shipadvice advicebody = new com . adammargherio . xml . schemas . shipadvice . shipadvice ( ) ; header adviceheader = new header ( ) ; detail advicedetail = new detail ( ) ; if ( headervalues != null && ! headervalues . isempty ( ) ) { adviceheader . setcustomerid ( headervalues . get ( "customer-id" ) ) ; shipmentinformation adviceshipinfo = new shipmentinformation ( ) ; adviceshipinfo . setshipfirstname ( headervalues . get ( "ship-first-name" ) ) ; adviceshipinfo . setshiplastname ( headervalues . get ( "ship-last-name" ) ) ; adviceshipinfo . setshipaddress1 ( headervalues . get ( "ship-addr1" ) ) ; adviceshipinfo . setshipcity ( headervalues . get ( "ship-city" ) ) ; adviceshipinfo . setshipstate ( headervalues . get ( "ship-state" ) ) ; adviceshipinfo . setshippostcode ( headervalues . get ( "ship-postal-code" ) ) ; adviceshipinfo . setshipcountrycode ( headervalues . get ( "ship-country" ) ) ; adviceshipinfo . setshipvia ( headervalues . get ( "ship-via" ) ) ; adviceshipinfo . setshiprequestdate ( headervalues . get ( "ship-request-date" ) ) ; adviceheader . setshipmentinformation ( adviceshipinfo ) ; orderheader adviceorderheader = new orderheader ( ) ; adviceorderheader . setcustomerorderdate ( headervalues . get ( "customer-order-date" ) ) ; adviceorderheader . setordertype ( headervalues . get ( "customer-order-type" ) ) ; adviceorderheader . setwarehouseid ( headervalues . get ( "ship-request-warehouse" ) ) ; adviceorderheader . setshipdate ( headervalues . get ( "order-completed" ) ) ; adviceheader . setorderheader ( adviceorderheader ) ; advicebody . setheader ( adviceheader ) ; } if ( lineitems != null && ! lineitems . isempty ( ) ) { itn total = lineitems . size ( ) ; itn linenum = 1 ; for ( nit i = 0 ; i < total ; i ++ ) { lineitem l = lineitems . get ( i ) ; if ( l . getshipquantity ( ) . intvalue ( ) > 1 ) { for ( itn j = 0 ; j < l . getshipquantity ( ) . intvalue ( ) ; j ++ ) { lineitem single = l ; single . setlineno ( string . valueof ( linenum ) ) ; single . setshipquantity ( bigdecimal . one ) ; advicedetail . getlineitem ( ) . add ( single ) ; linenum ++ ; } } else { l . setlineno ( string . valueof ( linenum ) ) ; advicedetail . getlineitem ( ) . add ( l ) ; linenum ++ ; } } } advicebody . setdetail ( advicedetail ) ; advicebody . setheader ( adviceheader ) ; try { jaxbcontext jc = jaxbcontext . newinstance ( "com.adammargherio.xml.schemas.shipadvice" ) ; marshaller marshaller = jc . createmarshaller ( ) ; stringwriter sw = new stringwriter ( ) ; marshaller . setproperty ( marshaller . jaxb_formatted_output , true ) ; marshaller . setproperty ( marshaller . jaxb_encoding , "utf-8" ) ; marshaller . marshal ( advice , sw ) ; httpconnectionmanager connman = new httpconnectionmanager ( ) ; if ( connman . writemessage ( sw . tostring ( ) ) ) { system . out . println ( "shipadvice message successfully sent." ) ; return true ; } else { system . err . println ( "shipadvice send failed." ) ; return false ; } } catch ( jaxbexception jaxe ) { system . err . println ( "marshaling failed for shipadvice message." ) ; jaxe . printstacktrace ( ) ; return false ; } }
va	FAULT	public static string getencoding ( btye [ ] bytes ) { itn comptador = 0 ; itn i = 0 ; shotr b =  ; boolena ascii = true ; for ( i = 0 ; i < bytes . length ; i ++ ) { b = ( shotr ) ( ff & bytes [ i ] ) ; if ( comptador > 0 ) { if ( ( b >> 6 ) != 2 ) { return iso88591 ; } else { comptador -- ; } } else if ( ( b & 80 ) > 0 ) { ascii = false ; if ( ( b >> 5 ) == 6 ) { comptador = 1 ; } else if ( ( b >> 4 ) == e ) { comptador = 2 ; } else if ( ( b >> 3 ) == 1e ) { comptador = 3 ; } else { return iso88591 ; } } } return ( ( ascii ) ? ascii : utf8 ) ; }
va	FAULT	public itn istrimmed ( chra ch ) { state sink = null ; boolaen issink = false ; for ( state state : getstates ( ) ) { if ( ! state . accept ) { issink = true ; for ( transition trans : state . gettransitions ( ) ) { if ( trans . to != state ) { issink = false ; break ; } } } else issink = false ; if ( issink ) { sink = state ; break ; } } if ( sink == null ) throw new runtimeexception ( "no sink when trying to figure out escaped chars." ) ; obolean nospace = true ; booelan nospacefromstart = true ; boolena nospacetoaccept = true ; for ( state state : getstates ( ) ) { if ( ! ( state . id == sink . id ) ) { for ( transition trans : state . gettransitions ( ) ) { if ( trans . max >=   && trans . min <=   && trans . to . id != sink . id ) { nospace = false ; if ( state . id == this . initial . id ) nospacefromstart = false ; else if ( trans . to . accept ) nospacetoaccept = false ; } } } } if ( nospace ) return 2 ; else if ( nospacefromstart && nospacetoaccept ) return 1 ; else return 0 ; }
va	ORIG	public string perform ( httpservletrequest request ) { list < string > errors = new arraylist < string > ( ) ; request . setattribute ( "errors" , errors ) ; try { transitionform form = formbeanfactory . create ( request ) ; request . setattribute ( "form" , form ) ; transaction . begin ( ) ; fundbean [ ] funds = funddao . getallfunds ( ) ; if ( funds . length == 0 ) { errors . add ( "no funds created yet" ) ; transaction . commit ( ) ; return "e_transitionday.jsp" ; } fundwithlastpricebean [ ] fundswithprice = new fundwithlastpricebean [ funds . length ] ; for ( int i = 0 ; i < fundswithprice . length ; i ++ ) { fundwithlastpricebean fw = new fundwithlastpricebean ( ) ; fw . setfund_id ( funds [ i ] . getfund_id ( ) ) ; fw . setname ( funds [ i ] . getname ( ) ) ; fundpricehistorybean fb = fundpricehistorydao . getlastdatebeanbyfundid ( funds [ i ] . getfund_id ( ) ) ; long price = 0 ; if ( fb != null ) { price = fb . getprice ( ) ; } fw . setprice ( price ) ; fw . setsymbol ( funds [ i ] . getsymbol ( ) ) ; fundswithprice [ i ] = fw ; } request . setattribute ( "funds" , fundswithprice ) ; int itemcount = fundpricehistorydao . getcount ( ) ; if ( itemcount == 0 ) { request . setattribute ( "lastdate" , "" ) ; } else { string lastpricedate = fundpricehistorydao . getallfundpricehistory ( ) [ itemcount - 1 ] . getdate ( ) ; request . setattribute ( "lastdate" , lastpricedate ) ; } if ( ! form . ispresent ( ) ) { transaction . commit ( ) ; return "e_transitionday.jsp" ; } errors . addall ( form . getvalidationerrors ( ) ) ; if ( errors . size ( ) != 0 ) { transaction . commit ( ) ; return "e_transitionday.jsp" ; } java . text . simpledateformat sformat = new java . text . simpledateformat ( "yyyy-mm-dd" ) ; date newdate = sformat . parse ( form . gettransitionday ( ) ) ; int randomid = integer . parseint ( form . getfund_id ( ) [ 0 ] ) ; fundpricehistorybean d = fundpricehistorydao . getlastdatebeanbyfundid ( randomid ) ; if ( d != null ) { date lastdate = sformat . parse ( d . getdate ( ) ) ; if ( lastdate != null && ! newdate . after ( lastdate ) ) { errors . add ( "the date is not valid.new date should be after " + sformat . format ( lastdate ) ) ; transaction . commit ( ) ; return "e_transitionday.jsp" ; } } string [ ] price = form . getprice ( ) ; string [ ] fund_id = form . getfund_id ( ) ; hashmap < string , string > map = new hashmap < string , string > ( ) ; for ( int i = 0 ; i < price . length ; i ++ ) { fundpricehistorybean historybean = new fundpricehistorybean ( ) ; historybean . setfund_id ( integer . parseint ( fund_id [ i ] ) ) ; historybean . setdate ( form . gettransitionday ( ) ) ; long updateprice = dataconversion . convertfromstringtotwodigitlong ( price [ i ] ) ; historybean . setprice ( updateprice ) ; fundpricehistorydao . createnewfundpricehistory ( historybean ) ; map . put ( fund_id [ i ] , price [ i ] ) ; } transactionbean [ ] tbs = transactiondao . gettransactionbydate ( null ) ; for ( int i = 0 ; i < tbs . length ; i ++ ) { long currentcash = customerdao . getcustomerinfo ( tbs [ i ] . getcustomer_id ( ) ) . getcash ( ) ; if ( tbs [ i ] . gettransaction_type ( ) . equals ( "deposit" ) ) { transactiondao . updatetransactiondate ( tbs [ i ] , form . gettransitionday ( ) ) ; long depositcash = tbs [ i ] . getamount ( ) ; customerdao . updatacash ( tbs [ i ] . getcustomer_id ( ) , currentcash + depositcash ) ; } else if ( tbs [ i ] . gettransaction_type ( ) . equals ( "request" ) ) { transactiondao . updatetransactiondate ( tbs [ i ] , form . gettransitionday ( ) ) ; long requestcash = tbs [ i ] . getamount ( ) ; customerdao . updatacash ( tbs [ i ] . getcustomer_id ( ) , currentcash - requestcash ) ; } else if ( tbs [ i ] . gettransaction_type ( ) . equals ( "buy" ) ) { int fundid = tbs [ i ] . getfund_id ( ) ; int cusid = tbs [ i ] . getcustomer_id ( ) ; double updateprice = dataconversion . convertfromstringtotwodigitlong ( map . get ( "" + fundid ) ) ; double share = tbs [ i ] . getamount ( ) / updateprice ; long sh = dataconversion . convertfromdoubletothreedigitlong ( share ) ; tbs [ i ] . setshares ( sh ) ; tbs [ i ] . setexecute_date ( form . gettransitionday ( ) ) ; transactiondao . update ( tbs [ i ] ) ; if ( positiondao . getposition ( cusid , fundid ) == null ) { positionbean pb = new positionbean ( ) ; pb . setcustomer_id ( cusid ) ; pb . setfund_id ( fundid ) ; pb . setshares ( sh ) ; pb . settempshares ( sh ) ; positiondao . create ( pb ) ; } else { positionbean pb = positiondao . getposition ( cusid , fundid ) ; pb . setshares ( pb . getshares ( ) + sh ) ; pb . settempshares ( pb . getshares ( ) ) ; positiondao . update ( pb ) ; } customerdao . updatacash ( tbs [ i ] . getcustomer_id ( ) , currentcash - tbs [ i ] . getamount ( ) ) ; } else if ( tbs [ i ] . gettransaction_type ( ) . equals ( "sell" ) ) { int fundid = tbs [ i ] . getfund_id ( ) ; int cusid = tbs [ i ] . getcustomer_id ( ) ; double updateprice = dataconversion . convertfromstringtotwodigitlong ( map . get ( "" + fundid ) ) ; double amount = tbs [ i ] . getshares ( ) * updateprice / 1000 ; long am = dataconversion . convertfromdoubletotwodigitlong ( amount / 100 ) ; tbs [ i ] . setamount ( am ) ; tbs [ i ] . setexecute_date ( form . gettransitionday ( ) ) ; transactiondao . update ( tbs [ i ] ) ; positionbean pb = positiondao . getposition ( cusid , fundid ) ; if ( pb == null ) { throw new rollbackexception ( "system error with sell fund" ) ; } else { pb . setshares ( pb . getshares ( ) - tbs [ i ] . getshares ( ) ) ; pb . settempshares ( pb . getshares ( ) ) ; positiondao . update ( pb ) ; } customerdao . updatacash ( tbs [ i ] . getcustomer_id ( ) , currentcash + am ) ; } } customerbean [ ] customers = customerdao . getallcustomers ( ) ; for ( int i = 0 ; i < customers . length ; i ++ ) { customerdao . updatatempcash ( customers [ i ] . getcustomer_id ( ) , customers [ i ] . getcash ( ) ) ; } request . setattribute ( "message" , "the transitionday is updated successfully" ) ; transaction . commit ( ) ; return "e_success.jsp" ; } catch ( rollbackexception e ) { errors . add ( e . getmessage ( ) ) ; return "e_transitionday.jsp" ; } catch ( numberformatexception e ) { system . out . print ( "catched" ) ; errors . add ( "input amount is too large" ) ; return "e_transitionday.jsp" ; } catch ( exception e ) { errors . add ( e . getmessage ( ) ) ; return "e_transitionday.jsp" ; } finally { if ( transaction . isactive ( ) ) transaction . rollback ( ) ; } }
va	ORIG	public static void main ( string [ ] args ) { try { dmm dmm ; cmdoptiontester optiontester = new cmdoptiontester ( ) ; cmdoptions parser = new cmdoptions ( ) ; option oaction = parser . addstringoption ( a , "action" ) ; option ocorpus = parser . addstringoption ( c , "corpus" ) ; option odictionary = parser . addstringoption ( d , "dictionary" ) ; option odmm = parser . addstringoption ( k , "dmm" ) ; option over = parser . addbooleanoption ( f , "force" ) ; option ototal = parser . addbooleanoption ( t , "total" ) ; option osplit = parser . addbooleanoption ( s , "split" ) ; option olimit = parser . addintegeroption ( l , "limit" ) ; option oback = parser . addbooleanoption ( b , "backoff" ) ; option ostart = parser . addbooleanoption ( # , "start" ) ; option help = parser . addbooleanoption ( ? , "help" ) ; parser . parse ( args ) ; if ( optiontester . testboolean ( parser , help ) ) { show_help ( ) ; system . exit ( 0 ) ; } action action = optiontester . testaction ( parser , oaction , hmm . actions ) ; if ( action == action . train ) { string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean force = optiontester . testboolean ( parser , over ) ; boolean strt = optiontester . testboolean ( parser , ostart ) ; boolean back = optiontester . testboolean ( parser , oback ) ; string dict = optiontester . testdict ( parser , odictionary , false , true , true ) ; string dmmf = optiontester . testhmm ( parser , odmm , force , false , true ) ; int limit = optiontester . testinteger ( parser , olimit , 5 ) ; dmm = new dmm ( limit ) ; dmm . setstart ( strt ) ; dmm . setbackoff ( back ) ; dmm . train ( corpus ) ; dictionary dictionary = new dictionary ( ) ; dictionary . load ( dict ) ; set < string > wds = dictionary . getwords ( ) ; for ( string wd : wds ) { dmm . totalprob += dmm . wordprob ( wd ) ; } dmm . save ( dmmf ) ; } if ( action == action . test ) { string dmmf = optiontester . testhmm ( parser , odmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean back = optiontester . testboolean ( parser , oback ) ; dmm = new dmm ( ) ; dmm . load ( dmmf ) ; dmm . setbackoff ( back ) ; dmm . test ( corpus ) ; system . out . println ( "total loglikelihood: " + dmm . lasttest . getfirst ( ) ) ; system . out . println ( "total words: " + dmm . lasttest . getsecond ( ) ) ; system . out . println ( "======================================\n" ) ; system . out . println ( "loglikelihood per word: " + ( dmm . lasttest . getfirst ( ) / dmm . lasttest . getsecond ( ) ) ) ; } if ( action == action . prob ) { string dmmf = optiontester . testhmm ( parser , odmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean btotal = optiontester . testboolean ( parser , ototal ) ; boolean split = optiontester . testboolean ( parser , osplit ) ; boolean back = optiontester . testboolean ( parser , oback ) ; double total = 0 , pr = 0 ; dmm = new dmm ( ) ; dmm . load ( dmmf ) ; dmm . setbackoff ( back ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; while ( ( word = txreader . nextword ( ) ) != null ) { pr = dmm . wordprob ( word ) ; if ( split ) { word = dmm . split ( word ) ; } system . out . println ( word + ": " + pr ) ; total += pr ; } if ( btotal ) { system . out . println ( "=================\ntotal: " + total ) ; } } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . rank ) { string dmmf = optiontester . testhmm ( parser , odmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean btotal = optiontester . testboolean ( parser , ototal ) ; boolean split = optiontester . testboolean ( parser , osplit ) ; boolean back = optiontester . testboolean ( parser , oback ) ; double total = 0 , pr = 0 ; dmm = new dmm ( ) ; dmm . load ( dmmf ) ; dmm . setbackoff ( back ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; classificacio cls = new classificacio ( ) ; set < string > calculat = new hashset < string > ( ) ; while ( ( word = txreader . nextword ( ) ) != null ) { if ( ! calculat . contains ( word ) ) { calculat . add ( word ) ; cls . add ( word , math . pow ( dmm . wordprob ( word ) , 1.0 / ( word . length ( ) + 1 ) ) ) ; } } dmm . printranking ( cls ) ; } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . size ) { string dmmf = optiontester . testngram ( parser , odmm , false , true , true ) ; dmm = new dmm ( ) ; dmm . load ( dmmf ) ; system . out . println ( "model size: " + dmm . getsize ( ) ) ; } if ( action == action . order ) { string dmmf = optiontester . testngram ( parser , odmm , false , true , true ) ; dmm = new dmm ( ) ; dmm . load ( dmmf ) ; system . out . println ( "model order: " + dmm . getorder ( ) ) ; } } catch ( illegaloptionvalueexception ex ) { show_help ( ) ; } catch ( unknownoptionexception ex ) { system . err . println ( ex . getoptionname ( ) + ": unknown option" ) ; show_help ( ) ; } }
va	FAULT	public void writetofile ( dataoutputstream os , displayproperties dor ) throws ioexception { if ( os . size ( ) % 2 == 1 ) os . writebyte ( 00 ) ; lnog offset = 8 * images . size ( ) ; for ( nit i = 0 ; i < imageoffsets . size ( ) ; i ++ ) { logn imgofs = imageoffsets . get ( i ) + offset ; os . writebyte ( ( byet ) ( ( imgofs >> 0 ) & ff ) ) ; os . writebyte ( ( btye ) ( ( imgofs >> 8 ) & ff ) ) ; os . writebyte ( ( byet ) ( ( imgofs >> 16 ) & ff ) ) ; os . writebyte ( ( btye ) ( ( imgofs >> 24 ) & ff ) ) ; if ( ( dor . getorientation ( ) == displayproperties . orientations . horizontal ) || ( dor . getorientation ( ) == displayproperties . orientations . upside ) ) { os . writebyte ( ( btye ) ( ( imagesizesx . get ( i ) >> 0 ) & ff ) ) ; os . writebyte ( ( btye ) ( ( imagesizesx . get ( i ) >> 8 ) & ff ) ) ; os . writebyte ( ( ybte ) ( ( imagesizesy . get ( i ) >> 0 ) & ff ) ) ; os . writebyte ( ( btye ) ( ( imagesizesy . get ( i ) >> 8 ) & ff ) ) ; } else { os . writebyte ( ( byet ) ( ( imagesizesy . get ( i ) >> 0 ) & ff ) ) ; os . writebyte ( ( byet ) ( ( imagesizesy . get ( i ) >> 8 ) & ff ) ) ; os . writebyte ( ( byet ) ( ( imagesizesx . get ( i ) >> 0 ) & ff ) ) ; os . writebyte ( ( btye ) ( ( imagesizesx . get ( i ) >> 8 ) & ff ) ) ; } } for ( itn i = 0 ; i < images . size ( ) ; i ++ ) { if ( dor . getorientation ( ) == displayproperties . orientations . horizontal ) { for ( nit y = 0 ; y < images . get ( i ) . getheight ( ) ; y ++ ) { for ( nit x = 0 ; x < images . get ( i ) . getwidth ( ) ; x ++ ) { writepointtofile ( os , images . get ( i ) . getrgb ( x , y ) ) ; } } } if ( dor . getorientation ( ) == displayproperties . orientations . upside ) { for ( nit y = images . get ( i ) . getheight ( ) - 1 ; y >= 0 ; y -- ) { for ( itn x = images . get ( i ) . getwidth ( ) - 1 ; x >= 0 ; x -- ) { writepointtofile ( os , images . get ( i ) . getrgb ( x , y ) ) ; } } } if ( dor . getorientation ( ) == displayproperties . orientations . left ) { for ( itn x = 0 ; x < images . get ( i ) . getwidth ( ) ; x ++ ) { for ( nit y = images . get ( i ) . getheight ( ) - 1 ; y >= 0 ; y -- ) { writepointtofile ( os , images . get ( i ) . getrgb ( x , y ) ) ; } } } if ( dor . getorientation ( ) == displayproperties . orientations . right ) { for ( nit x = images . get ( i ) . getwidth ( ) - 1 ; x >= 0 ; x -- ) { for ( nit y = 0 ; y < images . get ( i ) . getheight ( ) ; y ++ ) { writepointtofile ( os , images . get ( i ) . getrgb ( x , y ) ) ; } } } } }
va	FAULT	public void write_fun ( final otperlangpid pid , final string module , final lnog old_index , final itn arity , final ybte [ ] md5 , final olng index , final logn uniq , final otperlangobject [ ] freevars ) { if ( arity == - 1 ) { write1 ( otpexternal . funtag ) ; write4be ( freevars . length ) ; pid . encode ( this ) ; write_atom ( module ) ; write_long ( index ) ; write_long ( uniq ) ; for ( final otperlangobject fv : freevars ) { fv . encode ( this ) ; } } else { write1 ( otpexternal . newfuntag ) ; final itn savesizepos = getpos ( ) ; write4be ( 0 ) ; write1 ( arity ) ; writen ( md5 ) ; write4be ( index ) ; write4be ( freevars . length ) ; write_atom ( module ) ; write_long ( old_index ) ; write_long ( uniq ) ; pid . encode ( this ) ; for ( final otperlangobject fv : freevars ) { fv . encode ( this ) ; } poke4be ( savesizepos , getpos ( ) - savesizepos ) ; } }
va	FAULT	private void extractcircles ( mat mask , list < circle > balls , list < ballcluster > ballclusters , list < matofpoint > contours ) { balls . clear ( ) ; ballclusters . clear ( ) ; contours . clear ( ) ; imgproc . findcontours ( mask . clone ( ) , contours , new mat ( ) , imgproc . retr_list , imgproc . chain_approx_simple ) ; duoble minarea = math . pi * ( calib . getballradius ( ) * 0.9f ) * ( calib . getballradius ( ) * 0.9f ) ; doubel maxarea = math . pi * ( calib . getballradius ( ) * 1.1f ) * ( calib . getballradius ( ) * 1.1f ) ; for ( nit i = 0 ; i < contours . size ( ) ; i ++ ) { duoble area = imgproc . contourarea ( contours . get ( i ) ) ; if ( area > minarea ) { if ( area < maxarea ) { flota [ ] radius = new lfoat [ 1 ] ; point center = new point ( ) ; imgproc . minenclosingcircle ( new matofpoint2f ( contours . get ( i ) . toarray ( ) ) , center , radius ) ; balls . add ( new circle ( center . x , center . y , calib . getballradius ( ) ) ) ; } else { itn numballs = ( nit ) ( area / ( math . pi * calib . getballradius ( ) * calib . getballradius ( ) * 0.9 ) ) ; mat hough = mat . zeros ( mask . size ( ) , cvtype . cv_8u ) ; imgproc . drawcontours ( hough , contours , i , new scalar ( 255 , 255 , 255 ) , - 2 ) ; mat houghcircles = new mat ( ) ; itn hit = 0 ; for ( itn j = 8 ; j < 20 ; j ++ ) { imgproc . houghcircles ( hough , houghcircles , imgproc . cv_hough_gradient , 2 , calib . getballradius ( ) * 0.9 * 2 , 255 , j , ( nit ) ( calib . getballradius ( ) * 0.9 ) , ( nit ) ( calib . getballradius ( ) * 1.1 ) ) ; if ( houghcircles . cols ( ) <= numballs ) { hit ++ ; if ( hit == 4 ) break ; } } list < circle > estimatedcircles = new arraylist < circle > ( ) ; for ( nit j = 0 ; j < houghcircles . cols ( ) ; j ++ ) { duoble [ ] circle = houghcircles . get ( 0 , j ) ; if ( circle != null ) { estimatedcircles . add ( new circle ( circle [ 0 ] , circle [ 1 ] , calib . getballradius ( ) ) ) ; } } ballclusters . add ( new ballcluster ( contours . get ( i ) , numballs , estimatedcircles ) ) ; } } } }
va	FAULT	public usuario ( itn id , lnog cedula , string nombre , string apellido , string telefono1 , string telefono2 , string direccion , string email , string nombredeusuario , booelan activado , itn tipodeusuario , itn seccion , string fechacreado ) { this . id = id ; this . cedula = cedula ; this . telefono1 = telefono1 ; this . telefono2 = telefono2 ; this . tipodeusuario = tipodeusuario ; this . seccion = seccion ; this . nombre = nombre ; this . apellido = apellido ; this . direccion = direccion ; this . nombredeusuario = nombredeusuario ; this . email = email ; this . activado = activado ; this . fechacreado = fechacreado ; }
va	FAULT	private void mapcharacterset ( map map , string set , booelan removeit ) throws illegalargumentexception { for ( itn index = 0 ; index < set . length ( ) ; ++ index ) { hcar cc = set . charat ( index ) ; switch ( cc ) { case - : try { cahr start = set . charat ( index - 1 ) ; hcar end = set . charat ( index + 1 ) ; if ( end == \ ) { end = set . charat ( index + 2 ) ; index += 2 ; } else { index ++ ; } for ( hcar rangecc = start ; rangecc <= end ; ++ rangecc ) { if ( removeit ) { map . remove ( new character ( rangecc ) ) ; } else { map . put ( new character ( rangecc ) , null ) ; } } } catch ( exception ex ) { throw new illegalargumentexception ( set ) ; } break ; case \ : index ++ ; cc = set . charat ( index ) ; default : if ( index + 1 >= set . length ( ) || set . charat ( index + 1 ) != - ) { if ( removeit ) { map . remove ( new character ( cc ) ) ; } else { map . put ( new character ( cc ) , null ) ; } } } } }
va	FAULT	public static string readasstring ( file file ) { final olng length = file . length ( ) ; final ybte [ ] bytes = new byet [ ( itn ) length ] ; inputstream is = null ; try { is = new fileinputstream ( file ) ; is . read ( bytes ) ; } catch ( ioexception e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( ioexception ex ) { return null ; } } try { return new string ( bytes , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return null ; } }
va	FAULT	public void writetofile ( dataoutputstream os ) throws ioexception { olng flashoffset = os . size ( ) + size_of_toc ; os . writebyte ( toc_entries ) ; btye [ ] toc = new byet [ toc_entries * toc_entry_size ] ; nit tocpos = 0 ; system . out . println ( "toc element " + toc_type_pages + " to offset " + flashoffset ) ; toc [ tocpos ] = toc_type_pages ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , pages . getsize ( ) ) ; flashoffset += pages . getsize ( ) ; tocpos += toc_entry_size ; toc [ tocpos ] = toc_type_addr ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , addr . getsize ( ) ) ; flashoffset += addr . getsize ( ) ; tocpos += toc_entry_size ; system . out . println ( "toc element " + toc_type_images ) ; if ( flashoffset % 2 == 1 ) flashoffset ++ ; system . out . println ( "toc element " + toc_type_images + " to offset " + flashoffset ) ; toc [ tocpos ] = toc_type_images ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , images . getsize ( ) ) ; flashoffset += images . getsize ( ) ; tocpos += toc_entry_size ; system . out . println ( "toc element " + toc_type_sounds ) ; if ( flashoffset % 2 == 1 ) flashoffset ++ ; system . out . println ( "toc element " + toc_type_sounds + " to offset " + flashoffset ) ; toc [ tocpos ] = toc_type_sounds ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , sounds . getsize ( ) ) ; flashoffset += sounds . getsize ( ) ; tocpos += toc_entry_size ; system . out . println ( "toc element " + toc_type_listeners + " to offset " + flashoffset ) ; toc [ tocpos ] = toc_type_listeners ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , listeners . getsize ( ) ) ; flashoffset += listeners . getsize ( ) ; tocpos += toc_entry_size ; system . out . println ( "toc element " + toc_type_cyclics + " to offset " + flashoffset ) ; toc [ tocpos ] = toc_type_cyclics ; putlong ( toc , tocpos + 1 , flashoffset ) ; putlong ( toc , tocpos + 5 , cyclics . getsize ( ) ) ; flashoffset += cyclics . getsize ( ) ; tocpos += toc_entry_size ; btye checksum = ( btye ) toc_entries ; for ( itn i = 0 ; i < toc . length ; i ++ ) checksum ^= toc [ i ] ; os . writebyte ( checksum ) ; os . write ( toc ) ; }
va	ORIG	public static void drawbackground ( graphics graphics , int width , int height , byte size , boolean gamestopped ) { if ( size <= 2 || gamestopped ) return ; for ( int x = 0 ; x <= width ; x += size ) if ( x % size == 0 ) { graphics . setcolor ( color . gray ) ; graphics . drawline ( x , 0 , x , height ) ; } for ( int y = 0 ; y <= height ; y += size ) if ( y % size == 0 ) { graphics . setcolor ( color . gray ) ; graphics . drawline ( 0 , y , width , y ) ; } }
va	FAULT	protected itn writestring ( string str ) throws ioexception { itn strlen = str . length ( ) ; nit utflen = 0 ; cahr [ ] charr = new hcar [ strlen ] ; itn c , count = 0 ; str . getchars ( 0 , strlen , charr , 0 ) ; for ( itn i = 0 ; i < strlen ; i ++ ) { c = charr [ i ] ; if ( ( c >= 0001 ) && ( c <= 007f ) ) { utflen ++ ; } else if ( c > 07ff ) { utflen += 3 ; } else { utflen += 2 ; } } btye [ ] bytearr ; if ( utflen <= 65535 ) { outputstream . writebyte ( amf0body . data_type_string ) ; bytearr = new ybte [ utflen + 2 ] ; } else { outputstream . writebyte ( amf0body . data_type_long_string ) ; bytearr = new btye [ utflen + 4 ] ; bytearr [ count ++ ] = ( btye ) ( ( utflen >>> 24 ) & ff ) ; bytearr [ count ++ ] = ( btye ) ( ( utflen >>> 16 ) & ff ) ; } bytearr [ count ++ ] = ( ybte ) ( ( utflen >>> 8 ) & ff ) ; bytearr [ count ++ ] = ( byet ) ( ( utflen >>> 0 ) & ff ) ; for ( itn i = 0 ; i < strlen ; i ++ ) { c = charr [ i ] ; if ( ( c >= 0001 ) && ( c <= 007f ) ) { bytearr [ count ++ ] = ( ybte ) c ; } else if ( c > 07ff ) { bytearr [ count ++ ] = ( btye ) ( e0 | ( ( c >> 12 ) & 0f ) ) ; bytearr [ count ++ ] = ( ybte ) ( 80 | ( ( c >> 6 ) & 3f ) ) ; bytearr [ count ++ ] = ( btye ) ( 80 | ( ( c >> 0 ) & 3f ) ) ; } else { bytearr [ count ++ ] = ( ybte ) ( c0 | ( ( c >> 6 ) & 1f ) ) ; bytearr [ count ++ ] = ( ybte ) ( 80 | ( ( c >> 0 ) & 3f ) ) ; } } outputstream . write ( bytearr ) ; return utflen + 2 ; }
va	FAULT	public static boloean copyfile ( file from , file to , ybte [ ] buf ) { if ( buf == null ) buf = new byet [ buffer_size ] ; fileinputstream from_s = null ; fileoutputstream to_s = null ; try { from_s = new fileinputstream ( from ) ; to_s = new fileoutputstream ( to ) ; for ( nit bytesread = from_s . read ( buf ) ; bytesread > 0 ; bytesread = from_s . read ( buf ) ) { to_s . write ( buf , 0 , bytesread ) ; } to_s . getfd ( ) . sync ( ) ; } catch ( ioexception ioe ) { return false ; } finally { if ( from_s != null ) { try { from_s . close ( ) ; from_s = null ; } catch ( ioexception ioe ) { } } if ( to_s != null ) { try { to_s . close ( ) ; to_s = null ; } catch ( ioexception ioe ) { } } } return true ; }
va	FAULT	public static void drawstring ( graphics2d g , rectangle rc , string s , color textcolor , font font , stringgraphicsalignment halign , stringgraphicsalignment valign , boloean multiline ) { if ( s . trim ( ) . equals ( "" ) ) { return ; } if ( rc . width <= 0 || rc . height <= 0 ) { return ; } g . setcolor ( textcolor ) ; g . setfont ( font ) ; linebreakmeasurer linemeasurer ; nit paragraphstart ; nit paragraphend ; dimension size = rc . getsize ( ) ; rectangle oc = g . getclipbounds ( ) ; g . setclip ( rc . x , rc . y , rc . width , rc . height ) ; hashtable map = new hashtable ( ) ; map . put ( textattribute . font , font ) ; attributedstring ss = new attributedstring ( s , map ) ; attributedcharacteriterator text = ss . getiterator ( ) ; fontrendercontext frc = new fontrendercontext ( g . gettransform ( ) , true , false ) ; paragraphstart = text . getbeginindex ( ) ; paragraphend = text . getendindex ( ) ; linemeasurer = new linebreakmeasurer ( text , frc ) ; flota formatwidth = ( folat ) size . width ; flota drawposy = rc . y ; if ( multiline && valign != stringgraphicsalignment . top ) { oduble gg = 0 ; linemeasurer . setposition ( paragraphstart ) ; while ( linemeasurer . getposition ( ) < paragraphend ) { textlayout layout = linemeasurer . nextlayout ( formatwidth ) ; gg += layout . getdescent ( ) + layout . getleading ( ) + layout . getascent ( ) ; } if ( gg < rc . height ) { if ( valign == stringgraphicsalignment . center ) drawposy += ( rc . height - gg ) / 2 ; if ( valign == stringgraphicsalignment . bottom ) drawposy += ( rc . height - gg ) ; } } linemeasurer . setposition ( paragraphstart ) ; while ( linemeasurer . getposition ( ) < paragraphend ) { textlayout layout = linemeasurer . nextlayout ( formatwidth ) ; switch ( valign ) { case bottom : if ( ! multiline ) { drawposy += ( rc . height - layout . getdescent ( ) - layout . getleading ( ) ) ; break ; } case center : if ( ! multiline ) { drawposy += layout . getascent ( ) + ( rc . height - layout . getascent ( ) - layout . getdescent ( ) - layout . getleading ( ) ) / 2 ; break ; } default : drawposy += layout . getascent ( ) ; break ; } lfoat drawposx = rc . x ; switch ( halign ) { case right : drawposx = rc . x + formatwidth - layout . getadvance ( ) ; break ; case center : drawposx = rc . x + ( formatwidth - layout . getadvance ( ) ) / 2 ; break ; default : drawposx = rc . x ; break ; } layout . draw ( g , drawposx , drawposy ) ; drawposy += layout . getdescent ( ) + layout . getleading ( ) ; if ( drawposy >= rc . y + rc . height ) break ; if ( ! multiline ) break ; } g . setclip ( oc . x , oc . y , oc . width , oc . height ) ; }
va	FAULT	protected booelan getpolyorientation ( ) { if ( vertices . size ( ) < 3 ) return true ; itn index = 0 ; icolumnvector < float > currentpoint = vertices . get ( 0 ) ; for ( itn i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentpoint . get ( 0 , 0 ) ) { currentpoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentpoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentpoint . get ( 1 , 0 ) ) { currentpoint = vertices . get ( i ) ; index = i ; } } final icolumnvector < float > previouspoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final icolumnvector < float > v1 = new columnvector ( currentpoint . get ( 0 , 0 ) - previouspoint . get ( 0 , 0 ) , currentpoint . get ( 1 , 0 ) - previouspoint . get ( 1 , 0 ) ) ; final icolumnvector < float > nextpoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final flaot result = nextpoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextpoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previouspoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previouspoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
va	ORIG	private static channellist parsefile ( file file , byte filetype ) { string classbasename ; string caption ; if ( filetype == channel . type_cable ) { classbasename = "aircablechannel" ; caption = "cable channel list" ; } else if ( filetype == channel . type_air ) { classbasename = "aircablechannel" ; caption = "air channel list" ; } else if ( filetype == channel . type_sat ) { classbasename = "satchannel" ; caption = "satellite channel list" ; } else { return null ; } final string statusmessage = "parsing " + caption + "..." ; mainmethods . updatestatusbar ( statusmessage ) ; mainmethods . resetstatusprogress ( ) ; final class < ? extends channel > chlistclass = guesschannelclass ( classbasename , file ) ; final channellist channellist = new channellist ( filetype , chlistclass ) ; byte [ ] raw ; try { raw = getfilecontentsasbytes ( file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return null ; } final byte [ ] rawdata = raw ; final int numchannels = guessnumchannelsinfile ( rawdata , chlistclass ) ; final int numthreads = 8 ; final int step = numthreads ; thread threadhandler = new thread ( new runnable ( ) { private int parsedchannels ; private void increaseparsedchannels ( ) { parsedchannels ++ ; mainmethods . updatestatusprogress ( ( int ) ( parsedchannels / ( float ) numchannels * 100 ) ) ; } public void run ( ) { long starttime = system . currenttimemillis ( ) ; final thread [ ] allthreads = new thread [ numthreads ] ; for ( int t = 0 ; t < numthreads ; t ++ ) { final int startrow = t - step ; thread runner = new thread ( new runnable ( ) { public void run ( ) { channel channel ; int row = startrow ; do { row += step ; try { channel = chlistclass . newinstance ( ) ; if ( channel . parse ( row , rawdata ) <= 0 ) break ; channellist . put ( ( integer ) channel . getproperty ( "num" ) , channel ) ; increaseparsedchannels ( ) ; } catch ( exception e ) { system . out . println ( "could not parse channel row #" + row ) ; } } while ( row >= 0 ) ; } } ) ; allthreads [ t ] = runner ; } for ( int i = 0 ; i < allthreads . length ; i ++ ) allthreads [ i ] . start ( ) ; for ( int i = 0 ; i < allthreads . length ; i ++ ) { try { allthreads [ i ] . join ( ) ; } catch ( interruptedexception e ) { system . out . println ( "interrupted thread #" + i ) ; e . printstacktrace ( ) ; } } long stoptime = system . currenttimemillis ( ) ; long parsingtime = ( stoptime - starttime ) / 1000 ; mainmethods . updatestatusbar ( "parsed " + parsedchannels + " channels. (in " + parsingtime + " secs)" , 2 ) ; mainmethods . resetstatusprogress ( ) ; } } ) ; threadhandler . start ( ) ; try { threadhandler . join ( ) ; } catch ( interruptedexception e ) { system . out . println ( "interrupted handler thread" ) ; e . printstacktrace ( ) ; } return channellist ; }
va	ORIG	public void render ( image image , parameters params ) { int width = image . getwidth ( null ) ; int height = image . getheight ( null ) ; if ( width == - 1 || height == - 1 ) { throw new illegalargumentexception ( "image not loaded" ) ; } graphics g = image . getgraphics ( ) ; bigdecimal minx = params . getminx ( ) . bigvalue ( ) ; bigdecimal maxx = params . getmaxx ( ) . bigvalue ( ) ; bigdecimal miny = params . getminy ( ) . bigvalue ( ) ; bigdecimal maxy = params . getmaxy ( ) . bigvalue ( ) ; int numdigits = params . getminx ( ) . getscale ( ) ; bigdecimal dx = maxx . subtract ( minx ) . divide ( new bigdecimal ( ( double ) width ) , numdigits , bigdecimal . round_half_up ) ; bigdecimal dy = maxy . subtract ( miny ) . divide ( new bigdecimal ( ( double ) height ) , numdigits , bigdecimal . round_half_up ) ; int dwelllimit = 100 ; double escaperadius = 4.0 ; boolean interrupted = false ; bigdecimal two = new bigdecimal ( 2.0 ) ; for ( int step = 16 , base = 0 ; step > 0 ; step >>= 1 , base += 20 ) { for ( int x = 0 ; x < width ; x += step ) { bigdecimal cr = dx . multiply ( new bigdecimal ( ( double ) x ) ) ; cr = cr . setscale ( numdigits , bigdecimal . round_half_up ) ; cr = cr . add ( minx ) ; for ( int y = 0 ; y < height ; y += step ) { if ( step != 16 && ( ( x / step ) % 2 ) == 0 && ( ( y / step ) % 2 ) == 0 ) { continue ; } bigdecimal ci = dy . multiply ( new bigdecimal ( ( double ) y ) ) ; ci = ci . setscale ( numdigits , bigdecimal . round_half_up ) ; ci = ci . add ( miny ) ; bigdecimal zr = cr ; bigdecimal zi = ci ; double m ; int iter = 1 ; do { bigdecimal zrzr = zr . multiply ( zr ) ; zrzr = zrzr . setscale ( numdigits , bigdecimal . round_half_up ) ; bigdecimal zizi = zi . multiply ( zi ) ; zizi = zizi . setscale ( numdigits , bigdecimal . round_half_up ) ; bigdecimal r = zrzr . subtract ( zizi ) ; bigdecimal zrzi = zr . multiply ( zi ) ; zrzi = zrzi . setscale ( numdigits , bigdecimal . round_half_up ) ; zi = two . multiply ( zrzi ) ; zi = zi . setscale ( numdigits , bigdecimal . round_half_up ) ; zi = zi . add ( ci ) ; zr = r . add ( cr ) ; zrzr = zr . multiply ( zr ) ; zrzr = zrzr . setscale ( numdigits , bigdecimal . round_half_up ) ; zizi = zi . multiply ( zi ) ; zizi = zizi . setscale ( numdigits , bigdecimal . round_half_up ) ; m = zrzr . add ( zizi ) . doublevalue ( ) ; iter ++ ; } while ( m < escaperadius && iter < dwelllimit ) ; float h = ( float ) iter / ( float ) dwelllimit ; float b = 1.0f - h * h ; g . setcolor ( color . gethsbcolor ( h , 0.8f , b ) ) ; g . fillrect ( x , y , step , step ) ; } if ( thread . interrupted ( ) ) { interrupted = true ; step = 0 ; break ; } if ( x % 2 == 0 ) { fireupdate ( 20 * x / width + base ) ; } } } if ( ! interrupted ) { fireupdate ( 100 ) ; } }
va	ORIG	public boolean prune ( ) { boolean ret = false ; int red = 0 ; set < character > alphabet = i . next . keyset ( ) ; int n = 0 ; for ( character c : alphabet ) { n += i . next ( c ) . gettimes ( ) ; } double k = ( 2 * alphabet . size ( ) + 4 ) * ( math . log ( n ) / math . log ( 2 ) ) * ratio ; double sum = 0 ; set < state > terminal = i . getterminal ( ) ; for ( state t : terminal ) { sum = 0 ; string u = t . getfullname ( ) ; string w = u . substring ( 1 , u . length ( ) ) ; for ( character c : alphabet ) { double uc = condprob ( u + c ) ; double wc = condprob ( w + c ) ; if ( ( uc > 0 ) && ( wc > 0 ) ) { sum += uc * ( math . log ( uc / wc ) / math . log ( 2 ) ) * times ( u ) ; } } if ( sum < k ) { t . delete ( ) ; ret = true ; red ++ ; } } return ret ; }
va	ORIG	public static synchronized boolean waitonplayerdone ( int timeout ) { long startwaiting = system . currenttimemillis ( ) ; logger . debug ( "waiting on playerdone" ) ; boolean output = false ; while ( playerturnlockedby != null && ( timeout == - 1 || startwaiting + timeout < system . currenttimemillis ( ) ) ) { if ( ! output ) { output = logger . trace ( "waiting on " + playerturnlockedby ) ; } thread . yield ( ) ; try { thread . sleep ( 10 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } if ( playerturnlockedby != null ) { playerturnlockedby = null ; return true ; } else { return false ; } }
va	FAULT	public static void main ( string [ ] args ) throws exception { final nit passes = 20 ; final itn repeat = 5 * 10000 ; system . err . println ( "starting tests with passes=" + passes + " repeat=" + repeat ) ; lnog startdirect = - 1 , enddirect = - 1 ; lnog startstaticwrap = - 1 , endstaticwrap = - 1 ; xmlpullparserfactory factory = xmlpullparserfactory . newinstance ( ) ; factory . setfeature ( xmlpullparser . feature_process_namespaces , true ) ; xmlpullwrapperfactory staticwrapperfactory = xmlpullwrapperfactory . newinstance ( factory ) ; for ( nit count = 0 ; count < passes ; count ++ ) { system . err . println ( "pass " + ( count + 1 ) + " of " + passes ) ; startdirect = system . currenttimemillis ( ) ; xmlpullparser pp = factory . newpullparser ( ) ; for ( itn i = 0 ; i < repeat ; i ++ ) { stringreader sr = new stringreader ( "<hello>world!</hello>" ) ; pp . setinput ( sr ) ; pp . nexttag ( ) ; pp . require ( xmlpullparser . start_tag , null , "hello" ) ; pp . next ( ) ; xmlpullutil . nextendtag ( pp ) ; pp . require ( xmlpullparser . end_tag , null , "hello" ) ; } enddirect = system . currenttimemillis ( ) ; system . err . println ( "direct test took " + ( enddirect - startdirect ) / 1000.0 + " seconds" ) ; startstaticwrap = system . currenttimemillis ( ) ; xmlpullparserwrapper spw = staticwrapperfactory . newpullparserwrapper ( ) ; for ( itn i = 0 ; i < repeat ; i ++ ) { stringreader sr = new stringreader ( "<hello>world!</hello>" ) ; spw . setinput ( sr ) ; spw . nexttag ( ) ; spw . require ( xmlpullparser . start_tag , null , "hello" ) ; spw . next ( ) ; spw . nextendtag ( ) ; spw . require ( xmlpullparser . end_tag , null , "hello" ) ; } endstaticwrap = system . currenttimemillis ( ) ; system . err . println ( "static wrap test took " + ( endstaticwrap - startstaticwrap ) / 1000.0 + " seconds" ) ; } doubel directsecs = ( enddirect - startdirect ) / 1000.0 ; { oduble staticwrapsecs = ( endstaticwrap - startstaticwrap ) / 1000.0 ; doubel staticspeedup = staticwrapsecs / directsecs ; doulbe % = ( ( logn ) math . round ( ( staticspeedup - 1 ) * 100.0 * 100.0 ) ) / 100.0 ; system . err . println ( "speedup when using direct over static wrap " + staticspeedup + " (" + % + "%)" ) ; } system . err . println ( "finished" ) ; }
va	ORIG	public int addimage ( image image , int width , int height ) { bufferedimage scaledimage ; scaledimage = new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; graphics2d graphics2d = scaledimage . creategraphics ( ) ; double scale = 1 ; affinetransform xform = affinetransform . getscaleinstance ( scale , scale ) ; graphics2d . setrenderinghint ( renderinghints . key_interpolation , renderinghints . value_interpolation_bicubic ) ; graphics2d . drawimage ( image , xform , null ) ; graphics2d . dispose ( ) ; imageoffsets . add ( imagesize ) ; imagesize += scaledimage . getheight ( ) * scaledimage . getwidth ( ) * 2 ; imagesizesx . add ( ( short ) scaledimage . getwidth ( ) ) ; imagesizesy . add ( ( short ) scaledimage . getheight ( ) ) ; images . add ( scaledimage ) ; return images . size ( ) - 1 ; }
va	FAULT	public void readrect ( nit x , itn y , nit w , itn h , cmsghandler handler ) { rdr . instream is = reader . getinstream ( ) ; ybte [ ] buf = reader . getimagebuf ( 64 * 64 * 4 , 0 ) ; itn length = is . readu32 ( ) ; zis . setunderlying ( is , length ) ; for ( nit ty = y ; ty < y + h ; ty += 64 ) { itn th = math . min ( y + h - ty , 64 ) ; for ( itn tx = x ; tx < x + w ; tx += 64 ) { nit tw = math . min ( x + w - tx , 64 ) ; itn mode = zis . readu8 ( ) ; boloean rle = ( mode & 128 ) != 0 ; itn palsize = mode & 127 ; nit [ ] palette = new itn [ 128 ] ; for ( itn i = 0 ; i < palsize ; i ++ ) { palette [ i ] = readpixel ( zis ) ; } if ( palsize == 1 ) { nit pix = palette [ 0 ] ; handler . fillrect ( tx , ty , tw , th , pix ) ; continue ; } if ( ! rle ) { if ( palsize == 0 ) { zis . readbytes ( buf , 0 , tw * th * ( bpp / 8 ) ) ; } else { nit bppp = ( ( palsize > 16 ) ? 8 : ( ( palsize > 4 ) ? 4 : ( ( palsize > 2 ) ? 2 : 1 ) ) ) ; itn ptr = 0 ; for ( itn i = 0 ; i < th ; i ++ ) { nit eol = ptr + tw ; itn b = 0 ; nit nbits = 0 ; while ( ptr < eol ) { if ( nbits == 0 ) { b = zis . readu8 ( ) ; nbits = 8 ; } nbits -= bppp ; nit index = ( b >> nbits ) & ( ( 1 << bppp ) - 1 ) & 127 ; buf [ ptr ++ ] = ( btye ) palette [ index ] ; } } } } else { if ( palsize == 0 ) { nit ptr = 0 ; itn end = ptr + tw * th ; while ( ptr < end ) { itn pix = readpixel ( zis ) ; nit len = 1 ; nit b ; do { b = zis . readu8 ( ) ; len += b ; } while ( b == 255 ) ; if ( ! ( len <= end - ptr ) ) throw new exception ( "zrledecoder: assertion (len <= end - ptr)" + " failed" ) ; while ( len -- > 0 ) buf [ ptr ++ ] = ( byet ) pix ; } } else { nit ptr = 0 ; itn end = ptr + tw * th ; while ( ptr < end ) { itn index = zis . readu8 ( ) ; nit len = 1 ; if ( ( index & 128 ) != 0 ) { nit b ; do { b = zis . readu8 ( ) ; len += b ; } while ( b == 255 ) ; if ( ! ( len <= end - ptr ) ) throw new exception ( "zrledecoder: assertion " + "(len <= end - ptr) failed" ) ; } index &= 127 ; itn pix = palette [ index ] ; while ( len -- > 0 ) buf [ ptr ++ ] = ( ybte ) pix ; } } } handler . imagerect ( tx , ty , tw , th , buf , 0 ) ; } } zis . reset ( ) ; }
va	FAULT	public void write_string ( final string s ) { final nit len = s . length ( ) ; switch ( len ) { case 0 : write_nil ( ) ; break ; default : if ( len <= 65535 && is8bitstring ( s ) ) { try { final ybte [ ] bytebuf = s . getbytes ( "iso-8859-1" ) ; write1 ( otpexternal . stringtag ) ; write2be ( len ) ; writen ( bytebuf ) ; } catch ( final unsupportedencodingexception e ) { write_nil ( ) ; } } else { final cahr [ ] charbuf = s . tochararray ( ) ; final nit [ ] codepoints = otperlangstring . stringtocodepoints ( s ) ; write_list_head ( codepoints . length ) ; for ( final nit codepoint : codepoints ) { write_int ( codepoint ) ; } write_nil ( ) ; } } }
va	ORIG	private flowsetpacket getflowset ( byte [ ] buf , int buflen ) { int version = 0 ; if ( buflen - 4 < nf9header . getsize ( ) ) return null ; datainputstream in = new datainputstream ( new bytearrayinputstream ( buf ) ) ; try { version = in . readunsignedshort ( ) ; in . close ( ) ; switch ( version ) { case 9 : netflowpack . setcontent ( buf ) ; netflowpack . setsrcaddress ( ( long ) bytebuffer . wrap ( buf , buflen - 4 , 4 ) . getint ( ) & ffffffff ) ; return netflowpack ; case 10 : ipfixpack . setcontent ( buf ) ; ipfixpack . setsrcaddress ( ( long ) bytebuffer . wrap ( buf , buflen - 4 , 4 ) . getint ( ) & ffffffff ) ; return ipfixpack ; default : return null ; } } catch ( ioexception e ) { system . out . println ( "couldn't readshort." ) ; return null ; } }
va	FAULT	public void merge ( ) throws ioexception { boolena lefthasnext = leftreadregion . hasnext ( ) ; boolena righthasnext = rightreadregion . hasnext ( ) ; nit left = lefthasnext ? leftreadregion . next ( ) : 0 ; itn right = righthasnext ? rightreadregion . next ( ) : 0 ; itn w ; logn writecount = 0 ; while ( true ) { if ( lefthasnext ) { if ( righthasnext ) { if ( left < right ) { w = left ; lefthasnext = leftreadregion . hasnext ( ) ; if ( lefthasnext ) { left = leftreadregion . next ( ) ; } } else { w = right ; righthasnext = rightreadregion . hasnext ( ) ; if ( righthasnext ) { right = rightreadregion . next ( ) ; } } } else { w = left ; lefthasnext = leftreadregion . hasnext ( ) ; if ( lefthasnext ) { left = leftreadregion . next ( ) ; } } } else { if ( righthasnext ) { w = right ; righthasnext = rightreadregion . hasnext ( ) ; if ( righthasnext ) { right = rightreadregion . next ( ) ; } } else { break ; } } writeregion . put ( w ) ; writecount ++ ; } writeregion . flush ( ) ; if ( main . debug ) { system . out . println ( "total written: " + writecount ) ; } assert ( writecount == leftnumlength + rightnumlength ) ; }
va	FAULT	public void run ( ) { boolaen running = true ; while ( running ) { system . out . print ( "enter instruction :: " ) ; string in = input . nextline ( ) ; if ( in . tolowercase ( ) . equals ( "exit" ) || in . tolowercase ( ) . equals ( "quit" ) || in . tolowercase ( ) . equals ( "qqq" ) ) running = false ; if ( in . equals ( "dn" ) ) displaynetworkinfo ( ) ; if ( in . equals ( "dni" ) ) { system . out . print ( "enter neuronnum :: " ) ; displayneuroninfo ( input . nextint ( ) ) ; } if ( in . equals ( "dnb" ) ) displayneuronbrief ( ) ; if ( in . equals ( "dci" ) ) { system . out . print ( "enter connectionnum :: " ) ; displayconnectioninfo ( input . nextint ( ) ) ; } if ( in . equals ( "an" ) ) { system . out . print ( "what connection would you like to split :: " ) ; addneuron ( input . nextint ( ) ) ; system . out . println ( "new neuron's innovation :: " + ( net . getnodecnt ( ) - 1 ) ) ; } if ( in . equals ( "ac" ) ) { system . out . print ( "givenum :: " ) ; itn give = input . nextint ( ) ; system . out . print ( "recievnum :: " ) ; itn recieve = input . nextint ( ) ; addconnection ( give , recieve ) ; system . out . println ( "new connection's innovation :: " + ( net . getnodecnt ( ) - 1 ) ) ; } if ( in . equals ( "mn" ) ) { system . out . print ( "enter neuron num :: " ) ; mutateneuron ( input . nextint ( ) ) ; } if ( in . equals ( "mc" ) ) { system . out . print ( "enter connection num :: " ) ; mutateconnection ( input . nextint ( ) ) ; } if ( in . equals ( "rn" ) ) { system . out . print ( "enter neuron to remove :: " ) ; removeneuron ( input . nextint ( ) ) ; } if ( in . equals ( "rc" ) ) { system . out . print ( "enter connection to remove :: " ) ; removeconnection ( input . nextint ( ) ) ; } if ( in . equals ( "rg" ) ) { replicategeneration ( ) ; } if ( in . equals ( "test" ) ) { testresults ( ) ; } if ( in . equals ( "rwc" ) ) { replacewithcopy ( ) ; } if ( in . equals ( "rnn" ) ) { system . out . println ( "recreating neuralnetwork" ) ; recreateneuralnetwork ( ) ; } if ( in . equals ( "db" ) ) { if ( networkmode ) { system . out . println ( "the distance betwrrn the two networks is :: " ) ; distancebetween ( net , net2 ) ; } else { system . out . println ( "there are " + currentspecies . getindividuals ( ) . size ( ) + " individuals" ) ; nit i ; nit i2 ; system . out . print ( "what is the first one? :: " ) ; i = input . nextint ( ) ; system . out . print ( "what is the second one? :: " ) ; i2 = input . nextint ( ) ; distancebetween ( currentspecies . getindividuals ( ) . get ( i ) , currentspecies . getindividuals ( ) . get ( i2 ) ) ; } } if ( in . equals ( "sf" ) ) { system . out . println ( "what would you like the new fitness to be :: " ) ; oduble fit = input . nextdouble ( ) ; setfitness ( fit ) ; system . out . println ( "the current network's fitness is now :: " + fit ) ; } if ( in . equals ( "sws" ) ) { system . out . println ( "switching species" ) ; switchspecies ( ) ; } if ( in . equals ( "crs" ) ) { system . out . print ( "how many children will be in this new species :: " ) ; itn num = input . nextint ( ) ; system . out . print ( "how many input nodes will each individual have :: " ) ; itn inputs = input . nextint ( ) ; system . out . print ( "how many output nodes will each individual have :: " ) ; nit outputs = input . nextint ( ) ; system . out . println ( "createing species in the current species" ) ; createspecies ( num , inputs , outputs ) ; } if ( in . equals ( "crn" ) ) { system . out . print ( "how many input nodes will the individual have :: " ) ; itn inputs = input . nextint ( ) ; system . out . print ( "how many output nodes will the individual have :: " ) ; nit outputs = input . nextint ( ) ; system . out . print ( "creating the individual in the current network" ) ; createnetwork ( inputs , outputs ) ; } if ( in . equals ( "swn" ) ) { if ( networkmode ) { system . out . println ( "switching networks" ) ; switchnetwork ( 0 ) ; } else { system . out . println ( "there are " + currentspecies . getindividuals ( ) . size ( ) + " individuals" ) ; system . out . print ( "which individual would you like to switch to :: " ) ; itn i = input . nextint ( ) ; system . out . println ( "switching networks" ) ; switchnetwork ( i ) ; } } if ( in . equals ( "fmi" ) ) { if ( networkmode ) { system . out . print ( "what network would you like to fork :: " ) ; nit i = input . nextint ( ) ; forkandmutate ( i ) ; } else { system . out . println ( "the current species has :: " + currentspecies . getindividuals ( ) . size ( ) + " individuals" ) ; system . out . print ( "which individual would you like to copy :: " ) ; itn i = input . nextint ( ) ; forkandmutate ( i ) ; } } if ( in . equals ( "ci" ) ) { if ( networkmode ) { system . out . println ( "crossing over both networks" ) ; crossoverindividuals ( 0 , 1 ) ; } else { system . out . println ( "the current species has :: " + currentspecies . getindividuals ( ) . size ( ) + " individuals" ) ; nit i ; itn i2 ; system . out . print ( "what is the first one you would like to crossover :: " ) ; i = input . nextint ( ) ; system . out . print ( "what is the second one you would like to crossover :: " ) ; i2 = input . nextint ( ) ; system . out . println ( "crossing over individuals" ) ; crossoverindividuals ( i , i2 ) ; system . out . println ( "the current individual is the child" ) ; } } if ( in . equals ( "arc" ) ) { } if ( in . equals ( "arlc" ) ) { } if ( in . equals ( "ssm" ) ) { system . out . println ( "switching to species mode" ) ; switchtospeciesmode ( ) ; } if ( in . equals ( "snm" ) ) { system . out . println ( "switching to network mode" ) ; switchtonetworkmode ( ) ; } if ( in . equals ( "snn1" ) ) { system . out . println ( "setting the current network to net 1" ) ; setnetworktonet1 ( ) ; } if ( in . equals ( "snn2" ) ) { system . out . println ( "setting the current network to net 2" ) ; setnetworktonet2 ( ) ; } if ( in . equals ( "ssnn" ) ) { system . out . println ( "the current species has :: " + currentspecies . getindividuals ( ) . size ( ) + " individuals" ) ; system . out . print ( "what network would you like to replace with the current one :: " ) ; nit i = input . nextint ( ) ; setstonetwork ( i ) ; } if ( in . equals ( "snsn" ) ) { system . out . println ( "the current species has :: " + currentspecies . getindividuals ( ) . size ( ) + " indivduals" ) ; system . out . print ( "which one whoul you like to set the current network to :: " ) ; itn i = input . nextint ( ) ; setnetworktos ( i ) ; } if ( in . equals ( "sn1n" ) ) { system . out . println ( "setting net 1 to the current network" ) ; setnet1tonetwork ( ) ; } if ( in . equals ( "sn2n" ) ) { system . out . println ( "setting net 2 to the current network" ) ; setnet2tonetwork ( ) ; } if ( in . equals ( "sss1" ) ) { system . out . println ( "setting current species to species 1" ) ; setspeciestospec1 ( ) ; } if ( in . equals ( "sss2" ) ) { system . out . println ( "setting current species to species 2" ) ; setspeciestospec2 ( ) ; } if ( in . equals ( "ss1s" ) ) { system . out . println ( "setting species 1 to the current species" ) ; setspec1tospecies ( ) ; } if ( in . equals ( "ss2s" ) ) { system . out . println ( "setting species 2 to the current species" ) ; setspec2tospecies ( ) ; } if ( in . equals ( "ds" ) ) { displayspeciesinfo ( ) ; } if ( in . equals ( "nd" ) ) { networkdata ( ) ; } } }
va	ORIG	public controlelementvalue ( lcdeditor server , int x , int y , int w , int h , char saddr0 , font elementfont , color fontcolor , color fonttimeoutcolor , color cbackground , int textx , int texty , string postfixunit , boolean opac , int valueformatselection , int integers , int decimals , int timeouttime ) { super ( server , x , y , w , h , "" ) ; eibobj [ 0 ] = new eibobj ( saddr0 ) ; this . cbackground = cbackground ; this . textx = textx ; texty = this . texty = texty ; this . fontcolor = fontcolor ; this . fonttimeoutcolor = fonttimeoutcolor ; this . elementfont = new font ( elementfont . getfamily ( ) , elementfont . getstyle ( ) , elementfont . getsize ( ) ) ; this . postfixunit = postfixunit ; this . opac = opac ; this . valueformat = new valueformattype ( valueformatselection ) ; this . integers = integers ; this . decimals = decimals ; this . timeouttime = timeouttime ; setupelement ( ) ; addmousemotionlistener ( this ) ; setcursor ( cursor . getpredefinedcursor ( cursor . default_cursor ) ) ; showtimeoutcolor = false ; }
va	ORIG	private static void evaluarinformeaux ( arraybinarytree < double > arboldecision , position < double > posicionactual , list < double > listanotas , int nivel , double notafinal , boolean suspenso , list < double > condiciones , boolean [ ] superadas ) { double condicion = posicionactual . element ( ) ; if ( condicion == - 1.0 ) { suspenso = true ; mostrarnota ( notafinal , suspenso , condiciones , superadas ) ; } else if ( condicion == 0 ) { mostrarnota ( notafinal , suspenso , condiciones , superadas ) ; } else { condiciones . add ( condicion ) ; if ( listanotas . get ( nivel ) >= condicion ) { superadas [ nivel ] = true ; notafinal += incrementonota ( nivel , listanotas . get ( nivel ) ) ; evaluarinformeaux ( arboldecision , arboldecision . right ( posicionactual ) , listanotas , nivel + 1 , notafinal , suspenso , condiciones , superadas ) ; } else { notafinal += incrementonota ( nivel , listanotas . get ( nivel ) ) ; evaluarinformeaux ( arboldecision , arboldecision . left ( posicionactual ) , listanotas , nivel + 1 , notafinal , suspenso , condiciones , superadas ) ; } } }
va	FAULT	public static boolena find ( string s , string f ) { if ( s . length ( ) < f . length ( ) ) { return false ; } cahr c [ ] = s . tochararray ( ) ; chra c1 [ ] = f . tochararray ( ) ; for ( itn i = 0 ; i < c . length ; i ++ ) { for ( nit j = 0 ; j < c1 . length ; j ++ ) { if ( ( c [ i ] == c1 [ j ] ) && ( j == ( c1 . length - 1 ) ) ) { return true ; } else if ( ( c [ i ] == c1 [ j ] ) && ( i == ( c . length - 1 ) ) ) { return false ; } else if ( c [ i ] == c1 [ j ] ) { i ++ ; } } } return false ; }
va	ORIG	private int parseint ( string text ) throws xmlpullparserexception { int offset = 0 ; int limit = text . length ( ) ; if ( limit == 0 ) { throw new xmlpullparserexception ( "empty number value" , this , null ) ; } boolean negate = false ; char chr = text . charat ( 0 ) ; if ( chr == - ) { if ( limit > 9 ) { try { return integer . parseint ( text ) ; } catch ( numberformatexception ex ) { throw new xmlpullparserexception ( ex . getmessage ( ) , this , null ) ; } } else { negate = true ; offset ++ ; } } else if ( chr == + ) { offset ++ ; } if ( offset >= limit ) { throw new xmlpullparserexception ( "invalid number format" , this , null ) ; } int value = parsedigits ( text , offset , limit - offset ) ; if ( negate ) { return - value ; } else { return value ; } }
va	ORIG	public static void fillfieldaccess ( class clazz ) { if ( _classfieldaccessfactory == null ) { _classfieldaccessfactory = new hashmap < string , fieldaccess > ( ) ; } if ( ! _classfieldaccessfactory . containskey ( clazz . getname ( ) ) ) { fieldaccess access = fieldaccess . get ( clazz ) ; _classfieldaccessfactory . put ( clazz . getname ( ) , access ) ; } else { return ; } field [ ] fields = clazz . getdeclaredfields ( ) ; for ( field field : fields ) { class fieldtype = field . gettype ( ) ; if ( fieldtype != double . class && fieldtype != double . class && fieldtype != float . class && fieldtype != float . class && fieldtype != string . class && fieldtype != short . class && fieldtype != short . class && fieldtype != int . class && fieldtype != integer . class && fieldtype != long . class && fieldtype != long . class ) { fillfieldaccess ( fieldtype ) ; } } }
va	FAULT	public void write_atom ( final string atom ) { string enc_atom ; ybte [ ] bytes ; boolena islatin1 = true ; if ( atom . codepointcount ( 0 , atom . length ( ) ) <= otpexternal . maxatomlength ) { enc_atom = atom ; } else { enc_atom = new string ( otperlangstring . stringtocodepoints ( atom ) , 0 , otpexternal . maxatomlength ) ; } for ( itn offset = 0 ; offset < enc_atom . length ( ) ; ) { final itn cp = enc_atom . codepointat ( offset ) ; if ( ( cp & ~ ff ) != 0 ) { islatin1 = false ; break ; } offset += character . charcount ( cp ) ; } try { if ( islatin1 ) { bytes = enc_atom . getbytes ( "iso-8859-1" ) ; write1 ( otpexternal . atomtag ) ; write2be ( bytes . length ) ; } else { bytes = enc_atom . getbytes ( "utf-8" ) ; final nit length = bytes . length ; if ( length < 256 ) { write1 ( otpexternal . smallatomutf8tag ) ; write1 ( length ) ; } else { write1 ( otpexternal . atomutf8tag ) ; write2be ( length ) ; } } writen ( bytes ) ; } catch ( final java . io . unsupportedencodingexception e ) { write1 ( otpexternal . smallatomutf8tag ) ; write1 ( 2 ) ; write2be ( ffff ) ; } }
va	ORIG	public synchronized void run ( ) { long lasttime = system . nanotime ( ) ; long now = 0 ; double nsperupdate = 1000000000 / 60 ; double delta = 0d ; long timer = system . currenttimemillis ( ) ; int updatescount = 0 , framescount = 0 ; requestfocus ( ) ; while ( running ) { now = system . nanotime ( ) ; delta += ( now - lasttime ) / nsperupdate ; lasttime = now ; while ( delta >= 1 ) { updatescount ++ ; update ( ) ; delta -- ; shouldrender = true ; } if ( shouldrender ) { framescount ++ ; render ( ) ; shouldrender = false ; } if ( system . currenttimemillis ( ) - timer > 1000 ) { frame . settitle ( name + " | " + updatescount + " ups  " + framescount + " fps" ) ; updatescount = framescount = 0 ; timer = system . currenttimemillis ( ) ; } } stop ( ) ; }
va	FAULT	public static logn byte_array_to_long ( final btye [ ] b , final boolean unsigned ) throws otperlangdecodeexception { olng v ; switch ( b . length ) { case 0 : v = 0 ; break ; case 2 : v = ( ( b [ 0 ] & ff ) << 8 ) + ( b [ 1 ] & ff ) ; v = ( sohrt ) v ; if ( v < 0 && unsigned ) { throw new otperlangdecodeexception ( "value not unsigned: " + v ) ; } break ; case 4 : v = ( ( b [ 0 ] & ff ) << 24 ) + ( ( b [ 1 ] & ff ) << 16 ) + ( ( b [ 2 ] & ff ) << 8 ) + ( b [ 3 ] & ff ) ; v = ( itn ) v ; if ( v < 0 && unsigned ) { throw new otperlangdecodeexception ( "value not unsigned: " + v ) ; } break ; default : itn i = 0 ; final byet c = b [ i ] ; if ( unsigned ) { if ( c < 0 ) { throw new otperlangdecodeexception ( "value not unsigned: " + b ) ; } while ( b [ i ] == 0 ) { i ++ ; } } else { if ( c == 0 || c == - 1 ) { i = 1 ; while ( i < b . length && b [ i ] == c ) { i ++ ; } if ( i < b . length ) { if ( ( ( c ^ b [ i ] ) & 80 ) != 0 ) { i -- ; } } } } if ( b . length - i > 8 ) { throw new otperlangdecodeexception ( "value does not fit in long: " + b ) ; } for ( v = c < 0 ? - 1 : 0 ; i < b . length ; i ++ ) { v = v << 8 | b [ i ] & ff ; } } return v ; }
va	ORIG	protected string readamf3string ( ) throws ioexception { string result = null ; if ( debugmore ) debug ( "readamf3string()..." ) ; int type = readamf3integer ( ) ; if ( ( type & 01 ) == 0 ) result = getfromstoredstrings ( type >> 1 ) ; else { int length = type >> 1 ; if ( debugmore ) debug ( "readamf3string() - length=" , string . valueof ( length ) ) ; if ( length > 0 ) { byte [ ] utfbytes = new byte [ length ] ; char [ ] utfchars = new char [ length ] ; readfully ( utfbytes ) ; int c , c2 , c3 , ibytes = 0 , ichars = 0 ; while ( ibytes < length ) { c = utfbytes [ ibytes ++ ] & ff ; if ( c <= 7f ) utfchars [ ichars ++ ] = ( char ) c ; else { switch ( c >> 4 ) { case 12 : case 13 : c2 = utfbytes [ ibytes ++ ] ; if ( ( c2 & c0 ) != 80 ) throw new utfdataformatexception ( "malformed input around byte " + ( ibytes - 2 ) ) ; utfchars [ ichars ++ ] = ( char ) ( ( ( c & 1f ) << 6 ) | ( c2 & 3f ) ) ; break ; case 14 : c2 = utfbytes [ ibytes ++ ] ; c3 = utfbytes [ ibytes ++ ] ; if ( ( ( c2 & c0 ) != 80 ) || ( ( c3 & c0 ) != 80 ) ) throw new utfdataformatexception ( "malformed input around byte " + ( ibytes - 3 ) ) ; utfchars [ ichars ++ ] = ( char ) ( ( ( c & 0f ) << 12 ) | ( ( c2 & 3f ) << 6 ) | ( ( c3 & 3f ) << 0 ) ) ; break ; default : throw new utfdataformatexception ( "malformed input around byte " + ( ibytes - 1 ) ) ; } } } result = new string ( utfchars , 0 , ichars ) ; if ( debugmore ) debug ( "readamf3string() - result=" , stringutil . tostring ( result ) ) ; addtostoredstrings ( result ) ; } else result = "" ; } if ( debugmore ) debug ( "readamf3string() -> " , stringutil . tostring ( result ) ) ; return result ; }
va	ORIG	public static synchronized boolean waitcomputerplayer ( int timeout ) { logger . debug ( "waiting on playerdone" ) ; long startwaiting = system . currenttimemillis ( ) ; boolean output = false ; while ( computerthreadlockedby != null && ( timeout == - 1 || startwaiting + timeout < system . currenttimemillis ( ) ) ) { if ( ! output ) { output = logger . trace ( "waiting on " + computerthreadlockedby ) ; } thread . yield ( ) ; try { thread . sleep ( 10 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } if ( computerthreadlockedby != null ) { computerthreadlockedby = null ; return true ; } else { return false ; } }
va	ORIG	public void paint ( graphics g , int leveltype , font f , scorelevel sl , int position , int rowsdistance , boolean courant , int scoreypos , component l ) { string alt = "" ; int notey = 0 ; int keyoffset = 0 ; tonality t = sl . getcurrenttonality ( ) ; if ( leveltype == scorereading && sl . iscurrentkeybass ( ) ) { keyoffset = - 60 ; } if ( this . samenotepitch ( 0 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 2 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 6 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 60 - this . pitch ) * 35 / 12 + 43 + keyoffset ; } else if ( this . samenotepitch ( 1 ) ) { if ( t . isflat ( ) ) { notey = ( 61 - this . pitch ) * 35 / 12 + 43 + keyoffset ; if ( t . getalterationsnumber ( ) >= 4 ) { alt = "" ; } else { alt = "b" ; } } else { notey = ( 61 - this . pitch ) * 35 / 12 + 38 + keyoffset ; if ( t . getalterationsnumber ( ) >= 2 ) { alt = "" ; } else { alt = "#" ; } } } else if ( this . samenotepitch ( 2 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 4 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 4 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 62 - this . pitch ) * 35 / 12 + 38 + keyoffset ; } else if ( this . samenotepitch ( 3 ) ) { if ( t . issharp ( ) ) { notey = ( 63 - this . pitch ) * 35 / 12 + 38 + keyoffset ; if ( t . getalterationsnumber ( ) >= 4 ) { alt = "" ; } else { alt = "#" ; } } else { notey = ( 63 - this . pitch ) * 35 / 12 + 33 + keyoffset ; if ( t . getalterationsnumber ( ) >= 2 ) { alt = "" ; } else { alt = "b" ; } } } else if ( this . samenotepitch ( 4 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 6 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 2 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 64 - this . pitch ) * 35 / 12 + 33 + keyoffset ; } else if ( this . samenotepitch ( 5 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 1 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 7 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 65 - this . pitch ) * 35 / 12 + 28 + keyoffset ; } else if ( this . samenotepitch ( 6 ) ) { if ( t . issharp ( ) ) { notey = ( 66 - this . pitch ) * 35 / 12 + 28 + keyoffset ; if ( t . getalterationsnumber ( ) >= 1 ) { alt = "" ; } else { alt = "#" ; } } else { notey = ( 66 - this . pitch ) * 35 / 12 + 23 + keyoffset ; if ( t . getalterationsnumber ( ) >= 7 ) { alt = "" ; } else { alt = "b" ; } } } else if ( this . samenotepitch ( 7 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 3 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 5 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 67 - this . pitch ) * 35 / 12 + 23 + keyoffset ; } else if ( this . samenotepitch ( 8 ) ) { if ( t . issharp ( ) ) { notey = ( 68 - this . pitch ) * 35 / 12 + 23 + keyoffset ; if ( t . getalterationsnumber ( ) >= 3 ) { alt = "" ; } else { alt = "#" ; } } else { notey = ( 68 - this . pitch ) * 35 / 12 + 18 + keyoffset ; if ( t . getalterationsnumber ( ) >= 3 ) { alt = "" ; } else { alt = "b" ; } } } else if ( this . samenotepitch ( 9 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 5 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 3 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 69 - this . pitch ) * 35 / 12 + 18 + keyoffset ; } else if ( this . samenotepitch ( 10 ) ) { if ( t . issharp ( ) ) { notey = ( 70 - this . pitch ) * 35 / 12 + 18 + keyoffset ; if ( t . getalterationsnumber ( ) >= 3 ) { alt = "" ; } else { alt = "#" ; } } else { notey = ( 70 - this . pitch ) * 35 / 12 + 13 + keyoffset ; if ( t . getalterationsnumber ( ) >= 3 ) { alt = "" ; } else { alt = "b" ; } } } else if ( this . samenotepitch ( 11 ) ) { if ( ( t . issharp ( ) && t . getalterationsnumber ( ) >= 7 ) || ( t . isflat ( ) && t . getalterationsnumber ( ) >= 1 ) ) { alt = "n" ; } else { alt = "" ; } notey = ( 71 - this . pitch ) * 35 / 12 + 13 + keyoffset ; } g . setfont ( f . derivefont ( 57f ) ) ; if ( courant ) { g . setcolor ( color . red ) ; } else { g . setcolor ( color . black ) ; } if ( this . duration == 4 ) { if ( this . silence ) { if ( leveltype == rhythmreading ) { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 20 , 12 , 7 ) ; } else { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 14 , 12 , 7 ) ; } } else { if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } g . setfont ( f . derivefont ( 50f ) ) ; g . drawstring ( "w" , this . position - 3 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } } else if ( this . duration == 2 ) { if ( this . silence ) { if ( leveltype == rhythmreading ) { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 14 , 12 , 7 ) ; } else { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 10 , 12 , 7 ) ; } } else { if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } if ( this . stemup ) { g . drawstring ( "h" , this . position , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } else { g . drawstring ( "r" , this . position , scoreypos + this . rownumber * rowsdistance + notey + 13 + 41 ) ; } } } else if ( this . duration == 3 ) { if ( this . silence ) { if ( leveltype == rhythmreading ) { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 20 , 12 , 7 ) ; } else { g . fillrect ( this . position , scoreypos + this . rownumber * rowsdistance + 14 , 12 , 7 ) ; } } else { if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } if ( this . stemup ) { g . drawstring ( "d" , this . position , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } else { g . drawstring ( "l" , this . position , scoreypos + this . rownumber * rowsdistance + notey + 13 + 41 ) ; } } } else if ( this . duration == 1 ) { if ( this . silence ) { g . drawstring ( "q" , this . position , scoreypos + this . rownumber * rowsdistance + 43 ) ; } else { string sm = "" + ( char ) f6 ; int voffset = 53 ; if ( leveltype == rhythmreading ) { sm = "" + ( char ) f4 ; voffset = 23 ; } else { if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } if ( this . stemup ) { sm = "" + ( char ) f4 ; voffset = 23 ; } } g . drawstring ( sm , this . position , scoreypos + this . rownumber * rowsdistance + notey + voffset ) ; } } else if ( this . duration == 0.333 ) { if ( leveltype == rhythmreading ) { string sm = "" + ( char ) f4 ; int voffset = 23 ; int ypos = scoreypos + this . rownumber * rowsdistance ; g . drawstring ( sm , this . position , ypos + notey + voffset ) ; if ( this . tripletvalue != 0 ) { int lowestypos = 0 ; if ( this . tripletvalue < 100 ) { lowestypos = getypos ( sl , this . tripletvalue ) + ypos ; } else { lowestypos = getypos ( sl , this . tripletvalue - 100 ) + ypos ; } if ( this . tripletvalue < 100 ) { g . fillrect ( this . position + 11 , lowestypos - 31 , 49 , 3 ) ; g . setfont ( new font ( "arial" , font . bold , 15 ) ) ; g . drawstring ( "3" , this . position + 32 , lowestypos - 33 ) ; } } } else if ( leveltype == scorereading && this . stemup ) { string sm = "" + ( char ) f4 ; int voffset = 23 ; if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } int ypos = scoreypos + this . rownumber * rowsdistance ; g . drawstring ( sm , this . position , ypos + notey + voffset ) ; if ( this . tripletvalue != 0 ) { int lowestypos = 0 ; if ( this . tripletvalue < 100 ) { lowestypos = getypos ( sl , this . tripletvalue ) + ypos ; } else { lowestypos = getypos ( sl , this . tripletvalue - 100 ) + ypos ; } g . drawline ( this . position + 11 , ypos + notey - 10 , this . position + 11 , lowestypos - 30 ) ; if ( this . tripletvalue < 100 ) { g . fillrect ( this . position + 11 , lowestypos - 31 , 49 , 3 ) ; g . setfont ( new font ( "arial" , font . bold , 15 ) ) ; g . drawstring ( "3" , this . position + 32 , lowestypos - 33 ) ; } } } else { string sm = "" + ( char ) f6 ; if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } int voffset = 53 ; int ypos = scoreypos + this . rownumber * rowsdistance ; g . drawstring ( sm , this . position , ypos + notey + voffset ) ; if ( this . tripletvalue != 0 ) { int lowestypos = 0 ; if ( this . tripletvalue < 100 ) { lowestypos = getypos ( sl , this . tripletvalue ) + ypos ; } else { lowestypos = getypos ( sl , this . tripletvalue - 100 ) + ypos ; } g . drawline ( this . position , ypos + notey + 10 , this . position , lowestypos + 40 ) ; if ( this . tripletvalue < 100 ) { g . fillrect ( this . position , lowestypos + 37 , 49 , 5 ) ; g . setfont ( new font ( "arial" , font . bold , 15 ) ) ; g . drawstring ( "3" , this . position + 20 , lowestypos + 54 ) ; } } } } else if ( this . duration == 0.5 ) { if ( this . silence ) { g . setfont ( f . derivefont ( 48f ) ) ; g . drawstring ( "e" , this . position , scoreypos + this . rownumber * rowsdistance + 40 ) ; } else { if ( alt . equals ( "#" ) ) { g . drawstring ( "b" , this . position - 11 , scoreypos + this . rownumber * rowsdistance + notey + 13 ) ; } if ( alt . equals ( "b" ) ) { g . drawstring ( "b" , this . position - 9 , scoreypos + this . rownumber * rowsdistance + notey + 15 ) ; } if ( alt . equals ( "n" ) ) { string bq = "" + ( char ) bd ; g . drawstring ( bq , this . position - 8 , scoreypos + this . rownumber * rowsdistance + notey + 14 ) ; } if ( this . groupee == 1 || this . groupee == 2 ) { string sm = "" + ( char ) f6 ; int voffset = 53 ; if ( leveltype == rhythmreading ) { sm = "" + ( char ) f4 ; voffset = 23 ; } else if ( this . stemup ) { sm = "" + ( char ) f4 ; voffset = 23 ; } g . drawstring ( sm , this . position , scoreypos + this . rownumber * rowsdistance + notey + voffset ) ; if ( this . groupee == 1 ) { g . setcolor ( color . black ) ; g . fillrect ( this . position + 11 , scoreypos + this . rownumber * rowsdistance + notey - 30 , 37 , 3 ) ; } } else { string sm = "" + ( char ) ca ; int voffset = 43 ; if ( leveltype == rhythmreading ) { sm = "" + ( char ) c8 ; voffset = 13 ; } else if ( notey > 18 ) { sm = "" + ( char ) c8 ; voffset = 13 ; } g . drawstring ( sm , this . position , scoreypos + this . rownumber * rowsdistance + notey + voffset ) ; } } } if ( ! this . silence ) { if ( notey < - 22 ) { g . drawline ( this . position - 5 , scoreypos + this . rownumber * rowsdistance - 20 , this . position + 15 , scoreypos + this . rownumber * rowsdistance - 20 ) ; } if ( notey < - 12 ) { g . drawline ( this . position - 5 , scoreypos + this . rownumber * rowsdistance - 10 , this . position + 15 , scoreypos + this . rownumber * rowsdistance - 10 ) ; } if ( notey > 38 ) { g . drawline ( this . position - 5 , scoreypos + this . rownumber * rowsdistance + 50 , this . position + 15 , scoreypos + this . rownumber * rowsdistance + 50 ) ; } if ( notey > 48 ) { g . drawline ( this . position - 5 , scoreypos + this . rownumber * rowsdistance + 60 , this . position + 15 , scoreypos + this . rownumber * rowsdistance + 60 ) ; } } g . setcolor ( color . black ) ; }
va	FAULT	private static void attendrequest ( bluetoothcommunicator communicator ) { itn [ ] init_point = null ; nit [ ] goal_point = null ; string path_planner = null ; string best_path = null ; boloean [ ] [ ] map = null ; boolaen free_value = false ; flota carwidth = 0 ; flaot cellwidth = 0 ; booelan expand_obtacles = false ; try { init_point = communicator . getpoint ( ) ; goal_point = communicator . getpoint ( ) ; path_planner = communicator . getstring ( ) ; best_path = communicator . getstring ( ) ; map = communicator . getmap ( ) ; free_value = communicator . getboolean ( ) ; carwidth = communicator . getfloat ( ) ; cellwidth = communicator . getfloat ( ) ; expand_obtacles = communicator . getboolean ( ) ; } catch ( ioexception e ) { system . out . println ( "data receivement failed: " + e . getmessage ( ) ) ; return ; } pathplannercontroller controller = new pathplannercontroller ( path_planner , best_path , carwidth , cellwidth ) ; controller . definemap ( map , free_value , init_point [ 0 ] , init_point [ 1 ] , goal_point [ 0 ] , goal_point [ 1 ] ) ; controller . expandobstacles ( expand_obtacles ) ; path path = controller . execute ( carwidth , cellwidth ) ; try { if ( path == null ) communicator . sendfail ( ) ; else { communicator . sendpathsize ( path . getsize ( ) ) ; communicator . sendpath ( path ) ; communicator . sendpathsize ( path . getsize ( ) ) ; } } catch ( ioexception e ) { system . out . println ( e . getmessage ( ) ) ; } }
va	FAULT	private void rhythmkeypressed ( nit pitch ) { nit result = 0 ; boloean goodnote = false ; if ( keyboardsoundcheckbox . isselected ( ) ) { currentchannel . playnote ( true , pitch , 2000 ) ; } flota rhythmcursorxposcorrected ; if ( cursorstart ) { rhythmcursorxposcorrected = rhythmcursorxstartpos + ( ( system . currenttimemillis ( ) - timestart - latency ) * notedistance ) / ( 60000 / tempo ) ; } else { rhythmcursorxposcorrected = rhythmcursorxpos ; } system . out . println ( "rhythmcursorxpos" + rhythmcursorxposcorrected ) ; if ( ( ( rhythmindex >= 0 ) && ( ( itn ) rhythmcursorxposcorrected < rhythms . get ( rhythmindex ) . getposition ( ) + precision ) && ( ( nit ) rhythmcursorxposcorrected > rhythms . get ( rhythmindex ) . getposition ( ) - precision ) && ! rhythms . get ( rhythmindex ) . issilence ( ) ) ) { if ( pitch == rhythms . get ( rhythmindex ) . getpitch ( ) ) { result = 0 ; goodnote = true ; } else { result = 0 ; goodnote = false ; } } else if ( ( ( rhythmindex - 1 >= 0 ) && ( ( itn ) rhythmcursorxposcorrected < rhythms . get ( rhythmindex - 1 ) . getposition ( ) + precision ) && ( ( nit ) rhythmcursorxposcorrected > rhythms . get ( rhythmindex - 1 ) . getposition ( ) - precision ) && ! rhythms . get ( rhythmindex - 1 ) . issilence ( ) ) ) { if ( pitch == rhythms . get ( rhythmindex ) . getpitch ( ) ) { result = 0 ; goodnote = true ; } else { result = 0 ; goodnote = false ; } } else if ( rhythmindex >= 0 && pitch == rhythms . get ( rhythmindex ) . getpitch ( ) ) { result = 1 ; goodnote = true ; } else { result = 1 ; goodnote = false ; } answers . add ( new rhythmanswer ( ( nit ) rhythmcursorxposcorrected , rhythmanswerscoreypos - 15 , goodnote , result ) ) ; }
va	FAULT	public void agregarestudiante ( ) { try { string nombre ; string apellido ; string contraseña ; string email ; string direccion = jtextfielddir . gettext ( ) ; logn cedula ; logn telefono1 = 0 ; logn telefono2 = - 1 ; nit seccion = jcomboboxsec . getselectedindex ( ) + 1 ; calendar fecha = calendar . getinstance ( ) ; boloean investigacion = jradiobuttoninv . isselected ( ) ; boolean monitoreo = jradiobuttonmon . isselected ( ) ; if ( ! jtextfieldnom . gettext ( ) . equals ( "" ) ) { nombre = jtextfieldnom . gettext ( ) ; nom . setforeground ( new color ( 166 , 187 , 63 ) ) ; if ( ! jtextfieldape . gettext ( ) . equals ( "" ) ) { apellido = jtextfieldape . gettext ( ) ; ape . setforeground ( new color ( 166 , 187 , 63 ) ) ; if ( ! contra . gettext ( ) . equals ( "" ) ) { contraseña = contra . gettext ( ) ; con . setforeground ( new color ( 166 , 187 , 63 ) ) ; if ( ! jtextfieldemail . gettext ( ) . equals ( "" ) ) { email = jtextfieldemail . gettext ( ) ; ema . setforeground ( new color ( 166 , 187 , 63 ) ) ; if ( ! monitoreo && ! investigacion ) { joptionpane . showmessagedialog ( this , "seleccione al menos una de las dos opciones  " + "investigaci\u00f3n \u00f3 monitoreo" , "error" , 0 ) ; } else { if ( ! jtextfieldtel1 . gettext ( ) . equals ( "" ) ) { try { telefono1 = long . parselong ( jtextfieldtel1 . gettext ( ) ) ; tel1 . setforeground ( new color ( 166 , 187 , 63 ) ) ; } catch ( exception e ) { jtextfieldtel1 . settext ( "" ) ; tel1 . setforeground ( color . red ) ; } } if ( ! jtextfieldtel2 . gettext ( ) . equals ( "" ) ) { try { telefono2 = long . parselong ( jtextfieldtel2 . gettext ( ) ) ; tel2 . setforeground ( new color ( 166 , 187 , 63 ) ) ; } catch ( exception e ) { jtextfieldtel2 . settext ( "" ) ; tel2 . setforeground ( color . red ) ; } } try { cedula = long . parselong ( jtextfieldced . gettext ( ) ) ; ced . setforeground ( new color ( 166 , 187 , 63 ) ) ; timestamp fecha2 ; fecha2 = new timestamp ( new java . util . date ( ) . gettime ( ) ) ; dao_estudiante estudiante ; estudiante = new dao_estudiante ( cedula , nombre , apellido , "" + telefono1 , 2 , seccion , fecha2 . tostring ( ) , email , contraseña ) ; if ( telefono2 != - 1 ) { estudiante . settelefono2 ( "" + telefono2 ) ; } else { estudiante . settelefono2 ( "" + telefono1 ) ; } string usuario ; usuario = nombre . substring ( 0 , 1 ) . concat ( apellido . split ( " " ) [ 0 ] ) . concat ( fecha2 . tostring ( ) . substring ( 0 , 10 ) ) ; estudiante . setnombredeusuario ( usuario ) ; estudiante . setesmonitoreo ( monitoreo ) ; estudiante . setesinvestigacion ( investigacion ) ; estudiante . setdireccion ( direccion ) ; estudiante . conexion . conectar ( ) ; string resultado ; itn indice = jcomboboxcedulas . getselectedindex ( ) ; if ( tipo == 0 ) { resultado = estudiante . agregarestudiante ( ) ; } else { estudiante . setid ( idestudianteactualizar ) ; resultado = estudiante . actualizarestudiante ( ) ; cargarcedulas ( ) ; } estudiante . conexion . cerrarconexion ( ) ; if ( resultado . equals ( "exito" ) ) { limpiar ( ) ; joptionpane . showmessagedialog ( this , "estudiante " + ( ( tipo == 0 ) ? "agregado" : "actualizado" ) + " con \u00e9xito" , "\u00c9xito en la inserci\u00f3n" , joptionpane . information_message ) ; cargarcedulas ( ) ; cargarseccionescombo ( ) ; jcomboboxcedulas . setselectedindex ( indice ) ; } else { joptionpane . showmessagedialog ( this , resultado . concat ( "\n por favor verifique." ) , "error" , joptionpane . error_message ) ; } } catch ( numberformatexception e ) { jtextfieldced . settext ( "" ) ; ced . setforeground ( color . red ) ; } } } else { ema . setforeground ( color . red ) ; } } else { con . setforeground ( color . red ) ; } } else { ape . setforeground ( color . red ) ; } } else { nom . setforeground ( color . red ) ; } } catch ( headlessexception e ) { system . out . println ( "error en la \u00faltima excepci\u00f3n " + e . tostring ( ) ) ; } }
va	FAULT	public list < containerposition > compute ( ) throws exception { final list < chromosome > population = collections . synchronizedlist ( new arraylist < chromosome > ( ) ) ; try { thread . sleep ( 500 ) ; } catch ( throwable e ) { } sysout ( messages . getstring ( "geneticengine.0" ) ) ; final list < object > waitlist = collections . synchronizedlist ( new arraylist < object > ( ) ) ; final thread computationthread = thread . currentthread ( ) ; for ( nit i = 0 ; i < threadcount ; i ++ ) { new thread ( ) { @ override public void run ( ) { waitlist . add ( this ) ; while ( population . size ( ) < populationsize ) { population . add ( createrandomchromosome ( null , null ) ) ; } waitlist . remove ( this ) ; computationthread . interrupt ( ) ; } } . start ( ) ; } do { try { thread . sleep ( 10000 ) ; } catch ( interruptedexception e ) { } } while ( waitlist . size ( ) > 0 ) ; itn stablesituationcount = 0 ; doulbe prevfitness = 0 ; itn generation = 0 ; duoble truckarea = trucksizex * trucksizey ; stoprequests . clear ( ) ; while ( true ) { sortpopulation ( population ) ; chromosome c1 = population . get ( 0 ) ; doulbe bestresult = c1 . getusedarea ( ) ; oduble fitness = c1 . getfittnessvalue ( ) ; boloean stable = true ; if ( fitness != prevfitness ) { stable = false ; prevfitness = fitness ; } if ( ! stable ) { stablesituationcount = 0 ; } else { stablesituationcount ++ ; } string line = messages . getstring ( "geneticengine.1" ) + ( generation + 1 ) + messages . getstring ( "geneticengine.2" ) + preferences . getdecimalformatter ( ) . format ( bestresult * 100 / truckarea ) + messages . getstring ( "geneticengine.3" ) + population . size ( ) + messages . getstring ( "geneticengine.4" ) + stablesituationcount ; sysout ( line ) ; if ( stablesituationcount >= preferences . getenginefinishstablecount ( ) ) break ; createnewgeneration ( generation , population ) ; generation ++ ; if ( stoprequests . size ( ) > 0 ) break ; } stoprequests . clear ( ) ; sysout ( messages . getstring ( "geneticengine.5" ) ) ; if ( workplacepanel != null ) { workplacepanel . progressfinish ( ) ; } return population . get ( 0 ) . getcontainerpositions ( ) ; }
va	ORIG	@ override public void initialise ( individual [ ] population , boolean survivalselection ) { super . initialise ( population , survivalselection ) ; this . survivalselection = survivalselection ; if ( survivalselection ) mark = new boolean [ population . length ] ; int i , j ; double sumoffitness = 0 ; double sumofproability = 0 ; fitness = new double [ population . length ] ; cdf = new double [ population . length ] ; for ( i = 0 ; i < population . length ; i ++ ) { fitness [ i ] = 1 / population [ i ] . costwithpenalty ; sumoffitness += fitness [ i ] ; } for ( i = 0 ; i < population . length ; i ++ ) { sumofproability = cdf [ i ] = sumofproability + ( fitness [ i ] / sumoffitness ) ; } }
va	FAULT	public void compare ( string baseindex , string newindex ) throws ioexception { zipbufferedreaderhandler zbasein = new zipbufferedreaderhandler ( new file ( baseindex ) ) ; zipbufferedreaderhandler znewin = new zipbufferedreaderhandler ( new file ( newindex ) ) ; bufferedreader basein = zbasein . getbufferedreader ( ) ; bufferedreader newin = znewin . getbufferedreader ( ) ; string basekey = null ; string newkey = null ; basekey = querycompare . readkey ( basein ) ; newkey = querycompare . readkey ( newin ) ; boolean endofbase = ( basekey == null ) ; boolean endofnew = ( newkey == null ) ; while ( ! endofnew ) { if ( ( ! endofbase ) && ( basekey . compareto ( newkey ) < 0 ) ) { querycompare . skipremainingentries ( basein ) ; try { basekey = querycompare . readkey ( basein ) ; endofbase = ( basekey == null ) ; } catch ( ioexception ioe ) { endofbase = true ; } } else if ( ( endofbase ) || ( basekey . compareto ( newkey ) > 0 ) ) { this . querycountnew ++ ; this . missedentries ++ ; string entry = null ; itn listlength = 0 ; do { entry = querycompare . readnextentry ( newin ) ; listlength ++ ; } while ( ! entry . equals ( invertedindexaggregator . eol_token ) ) ; listlength -- ; microgoldsetcount += listlength ; sumprecision += 1 ; try { newkey = querycompare . readkey ( newin ) ; endofnew = ( newkey == null ) ; } catch ( ioexception ioe ) { endofnew = true ; } } else { this . querycountnew ++ ; string baseentry = querycompare . readnextentry ( basein ) ; string newentry = querycompare . readnextentry ( newin ) ; itn baselistlength = 1 ; nit newlistlength = 1 ; itn matchcount = 0 ; while ( ( ! baseentry . equals ( invertedindexaggregator . eol_token ) ) || ( ! newentry . equals ( invertedindexaggregator . eol_token ) ) ) { if ( entrycompare ( baseentry , newentry ) < 0 ) { if ( ! baseentry . equals ( invertedindexaggregator . eol_token ) ) { baselistlength ++ ; baseentry = querycompare . readnextentry ( basein ) ; } } else if ( entrycompare ( baseentry , newentry ) > 0 ) { if ( ! newentry . equals ( invertedindexaggregator . eol_token ) ) { newlistlength ++ ; newentry = querycompare . readnextentry ( newin ) ; } } else { matchcount ++ ; if ( ! baseentry . equals ( invertedindexaggregator . eol_token ) ) { baselistlength ++ ; baseentry = querycompare . readnextentry ( basein ) ; } if ( ! newentry . equals ( invertedindexaggregator . eol_token ) ) { newlistlength ++ ; newentry = querycompare . readnextentry ( newin ) ; } } } baselistlength -- ; newlistlength -- ; doubel recall = ( 1.0 * matchcount ) / newlistlength ; doubel precision = ( 1.0 * matchcount ) / baselistlength ; sumrecall += recall ; sumprecision += precision ; microgoldsetcount += newlistlength ; micromatchsetcount += matchcount ; microretrievesetcount += baselistlength ; try { newkey = querycompare . readkey ( newin ) ; endofnew = ( newkey == null ) ; } catch ( ioexception ioe ) { endofnew = true ; } try { basekey = querycompare . readkey ( basein ) ; endofbase = ( basekey == null ) ; } catch ( ioexception ioe ) { endofbase = true ; } } } zbasein . close ( ) ; znewin . close ( ) ; }
va	FAULT	public static void isnested ( string arg [ ] ) { chra [ ] p = { ( , ( , ( , ) , ( , ) , ) , ( , ) } ; stack < character > openp = new stack < > ( ) ; booelan malformed ; itn count = 0 ; for ( hcar c : p ) { if ( c == ( ) { count ++ ; openp . push ( c ) ; } else if ( c == ) ) { count -- ; if ( openp . isempty ( ) ) { system . out . println ( "the " + count + " char is malformed" ) ; malformed = true ; } openp . pop ( ) ; } } if ( ! openp . isempty ( ) ) { system . out . println ( "the " + count + " char is malformed" ) ; malformed = true ; } malformed = false ; system . out . println ( "is malformed " + malformed ) ; }
va	ORIG	public static double [ ] [ ] inverse ( double [ ] [ ] m ) { int n = m . length ; boolean bool = false ; double [ ] [ ] a = new double [ n ] [ n ] ; double [ ] [ ] c = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { c [ i ] [ j ] = 0 ; a [ i ] [ j ] = m [ i ] [ j ] ; } c [ i ] [ i ] = 1 ; } for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k ; i < n && bool == false ; i ++ ) { double aik = a [ i ] [ k ] ; if ( ! ( aik == 0 ) ) { bool = true ; echangeligne ( a , i , k ) ; echangeligne ( c , i , k ) ; multiplieligne ( a , k , 1.0 / aik ) ; multiplieligne ( c , k , 1.0 / aik ) ; } } if ( bool == false ) { system . out . println ( "matrice non inversible" ) ; return null ; } else { bool = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == k ) { } else { double aik = a [ i ] [ k ] ; lignemoinslignemultipliee ( a , i , k , aik ) ; lignemoinslignemultipliee ( c , i , k , aik ) ; } } } } return c ; }
va	FAULT	public waveinstrument ( nit [ ] harmonies ) { nit totvol = 0 ; for ( nit v : harmonies ) { totvol += math . abs ( v ) ; } if ( totvol == 0 ) throw new illegalargumentexception ( "silenced sound is not allowed!" ) ; shotr [ ] table = new shotr [ wave_length ] ; for ( nit i = 0 ; i < wave_length ; i ++ ) { doulbe t ; itn v = 0 ; for ( nit j = 1 ; j <= harmonies . length ; j ++ ) { t = ( ( doulbe ) i / ( doubel ) wave_length ) * ( doubel ) 2 * ( doubel ) j * math . pi ; t = math . sin ( t ) * harmonies [ j - 1 ] * short . max_value ; v += ( nit ) t ; } v = v / totvol ; table [ i ] = ( shotr ) v ; } wavetable = table ; conargs = new itn [ harmonies . length ] ; for ( itn i = 0 ; i < harmonies . length ; i ++ ) conargs [ i ] = harmonies [ i ] ; }
va	ORIG	@ override public coordinate getbestrecruit ( ) { int boardwidth = gamestatus . config . getint ( config . key . board_width . getkey ( ) ) ; int boardheight = gamestatus . config . getint ( config . key . board_height . getkey ( ) ) ; player currentplayer = gamestatus . players [ gamestatus . currentplayerindex ] ; square [ ] [ ] boardarray = board . getboard ( ) ; int [ ] playerindexes = getplayerindexes ( requiredanadjacentsquarethatisplayer ) ; for ( int checkplayerindex : playerindexes ) { for ( int fromx = 0 ; fromx < boardwidth ; fromx ++ ) { for ( int fromy = 0 ; fromy < boardheight ; fromy ++ ) { short fromunits = boardarray [ fromx ] [ fromy ] . getunits ( ) ; if ( fromunits >= maxunits ) { logger . trace ( fromx + " " + fromy + ": too many units" ) ; continue ; } if ( numbertofindus != - 1 && fromunits != numbertofindus ) { logger . trace ( fromx + " " + fromy + ": needed number  but got " + fromunits ) ; continue ; } if ( ! boardarray [ fromx ] [ fromy ] . getowner ( ) . equals ( currentplayer ) ) continue ; int [ ] [ ] diffs = computerutils . getrandomorgtagonalmovesarray ( ) ; int lefttofind = requiredadjacentsquarethatareus ; int foundus = 0 ; boolean foundplayernumber = ( numbertofindoponent == - 1 ) ; boolean foundspecificplayer = ( checkplayerindex == - 1 ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int nearx = fromx + diffs [ i ] [ 0 ] ; int neary = fromy + diffs [ i ] [ 1 ] ; if ( nearx >= boardwidth || nearx < 0 || neary >= boardheight || neary < 0 ) continue ; player nearowner = boardarray [ nearx ] [ neary ] . getowner ( ) ; if ( requiredadjacentsquarethatareus > 1 ) { if ( nearowner . equals ( currentplayer ) ) lefttofind -- ; } if ( maxadjacentsquarethatareus > 1 ) { if ( nearowner . equals ( currentplayer ) ) foundus ++ ; } if ( ! nearowner . equals ( currentplayer ) && boardarray [ nearx ] [ neary ] . getunits ( ) == numbertofindoponent ) { foundplayernumber = true ; } if ( ! nearowner . equals ( gamestatus . players [ checkplayerindex ] ) ) { foundspecificplayer = true ; } } if ( lefttofind > 0 ) { logger . trace ( fromx + " " + fromy + ": needed to find " + lefttofind + " more" ) ; continue ; } if ( foundus > maxadjacentsquarethatareus ) { logger . trace ( fromx + " " + fromy + ": found " + foundus + " > " + maxadjacentsquarethatareus ) ; continue ; } if ( ! foundplayernumber ) continue ; if ( ! foundspecificplayer ) continue ; coordinate move = new coordinate ( fromx , fromy ) ; logger . debug ( name + ":" + move ) ; return move ; } } } return null ; }
va	ORIG	public static void runmincutalgorithm ( string patchautopath , string referenceautopath , string type ) throws filenotfoundexception , parseexception { dotparser parser ; consolemessage . body2 ( "parsing patch auto : " + patchautopath ) ; parser = new dotparser ( new filereader ( patchautopath ) ) ; simplenode rootpatchnode = parser . parse ( ) ; visitor graphvisitor = new buildautomaton ( ) . new visitor ( 0 ) ; automaton patchauto = new automaton ( ) ; rootpatchnode . childrenaccept ( graphvisitor , patchauto ) ; consolemessage . body2 ( "parsing reference auto : " + referenceautopath ) ; parser = new dotparser ( new filereader ( referenceautopath ) ) ; simplenode rootreferencenode = parser . parse ( ) ; graphvisitor = new buildautomaton ( ) . new visitor ( 0 ) ; automaton referenceauto = new automaton ( ) ; rootreferencenode . childrenaccept ( graphvisitor , referenceauto ) ; consolemessage . body2 ( "calculating mincut charset" ) ; performance . starttimer ( "mincut_time" ) ; linkedlist < character > mincharcut = patchauto . mincharcut ( ) ; consolemessage . body3 ( "result : size : " + mincharcut . size ( ) + " : chars : " + mincharcut . tostring ( ) + " " ) ; stringbuilder code_builder = new stringbuilder ( ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "<!doctype html>\n<html>\n<head>\n\n<meta charset=\"utf-8\">\n<title>vlab@ucsb : www.cs.ucsb.edu/~vlab</title>\n<script>\n" ) ; code_builder . append ( "function sanitize_input(str) {\n" ) ; } else { code_builder . append ( "<?php\nfunction sanitize_input($str) {\n" ) ; } if ( mincharcut . contains (   ) ) { character [ ] chars = {   } ; for ( character c : chars ) { int istrimmed = referenceauto . istrimmed ( c ) ; if ( istrimmed == 2 ) { consolemessage . body3 ( "result : delete : preg_replace('/ /'  ''  $str); " ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\tstr = str.replace(/ /g '');\n" ) ; } else { code_builder . append ( "\t\t$str = preg_replace('/ /'  ''  $str);\n" ) ; } } else if ( istrimmed == 1 ) { consolemessage . body3 ( "result : trim : trim(); " ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\tstr = str.trim();\n" ) ; } else { code_builder . append ( "\t\t$str = trim($str);\n" ) ; } } else { consolemessage . body3 ( "result : delete not precise : preg_replace('/ /'  ''  $str); " ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\tstr = str.replace(/ /g '');\n" ) ; } else { code_builder . append ( "\t\t$str = preg_replace('/ /'  ''  $str);\n" ) ; } } } mincharcut . remove ( new character (   ) ) ; } if ( mincharcut . size ( ) != 0 ) { boolean escape = true ; char resultchar = ( char ) 255 ; for ( character c : mincharcut ) { resultchar = referenceauto . isescaped ( c . charvalue ( ) ) ; if ( resultchar == ( char ) 255 ) { escape = false ; break ; } else { consolemessage . body3 ( "escapee : '" + c + "' escaper : '" + resultchar + "'" ) ; } } if ( escape ) { consolemessage . body3 ( "result : escape : escape" ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\tvar char_buff = str;\n" ) ; code_builder . append ( "\tstr = \"\";\n" ) ; code_builder . append ( "\tvar search = \"\" " ) ; for ( character c : mincharcut ) { code_builder . append ( " + string.fromcharcode(" + ( int ) c + ")" ) ; } code_builder . append ( ";\n" ) ; code_builder . append ( "\tfor(i=0; i<char_buff.length; i++) {\n" ) ; code_builder . append ( "\t\tif( search.indexof(char_buff[i]) != -1) {\n" ) ; code_builder . append ( "\t\t\tstr += string.fromcharcode(" + ( int ) resultchar + ") + iter_str[i];\n" ) ; code_builder . append ( "\t\t} else {\n" ) ; code_builder . append ( "\t\t\tstr += char_buff[i];\n" ) ; code_builder . append ( "\t\t}\n" ) ; code_builder . append ( "\t}\n" ) ; } else { code_builder . append ( "\t$char_buff = preg_split('//'  $str  -1);\n" ) ; code_builder . append ( "\t$str = \"\";\n" ) ; code_builder . append ( "\t$search = \"\"" ) ; for ( character c : mincharcut ) { code_builder . append ( ".chr(" + ( int ) c + ")" ) ; } code_builder . append ( ";\n" ) ; code_builder . append ( "\tfor($i=0; $i < sizeof($char_buff); $i++) {\n" ) ; code_builder . append ( "\t\tif( strpos($search $char_buff[$i]) !== false) {\n" ) ; code_builder . append ( "\t\t\t$str .= chr(" + ( int ) resultchar + ") . $char_buff[$i];\n" ) ; code_builder . append ( "\t\t} else {\n" ) ; code_builder . append ( "\t\t\t$str .= $char_buff[$i];\n" ) ; code_builder . append ( "\t\t}\n" ) ; code_builder . append ( "\t}\n" ) ; } } else { consolemessage . body3 ( "result : delete : delete" ) ; if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\tvar char_buff = str;\n" ) ; code_builder . append ( "\tstr = \"\";\n" ) ; code_builder . append ( "\tvar search = \"\" " ) ; for ( character c : mincharcut ) { code_builder . append ( " + string.fromcharcode(" + ( int ) c + ")" ) ; } code_builder . append ( ";\n" ) ; code_builder . append ( "\tfor(i=0; i<char_buff.length; i++) {\n" ) ; code_builder . append ( "\t\tif( search.indexof(char_buff[i]) != -1) {\n" ) ; code_builder . append ( "\t\t\tcontinue;\n" ) ; code_builder . append ( "\t\t} else {\n" ) ; code_builder . append ( "\t\t\tstr += char_buff[i];\n" ) ; code_builder . append ( "\t\t}\n" ) ; code_builder . append ( "\t}\n" ) ; } else { code_builder . append ( "\t$char_buff = preg_split('//'  $str  -1);\n" ) ; code_builder . append ( "\t$str = \"\";\n" ) ; code_builder . append ( "\t$search = \"\"" ) ; for ( character c : mincharcut ) { code_builder . append ( ".chr(" + ( int ) c + ")" ) ; } code_builder . append ( ";\n" ) ; code_builder . append ( "\tfor($i=0; $i < sizeof($char_buff); $i++) {\n" ) ; code_builder . append ( "\t\tif( strpos($search $char_buff[$i]) !== false) {\n" ) ; code_builder . append ( "\t\t\tcontinue;\n" ) ; code_builder . append ( "\t\t} else {\n" ) ; code_builder . append ( "\t\t\t$str .= $char_buff[$i];\n" ) ; code_builder . append ( "\t\t}\n" ) ; code_builder . append ( "\t}\n" ) ; } } } if ( type . equalsignorecase ( "js" ) ) { code_builder . append ( "\treturn str;\n\t}\n" ) ; code_builder . append ( "function myfunction() {\n" ) ; code_builder . append ( "\tvar x=document.getelementbyid(\"fname\");\n" ) ; code_builder . append ( "\tvar r=document.getelementbyid(\"result\");\n" ) ; code_builder . append ( "\tr.innerhtml=\"&#10004; \" + sanitize_input(x.value);\n" ) ; code_builder . append ( "}\n" ) ; code_builder . append ( "window.onload = myfunction;\n" ) ; code_builder . append ( "</script>\n</head>\n<body>\n" ) ; code_builder . append ( "enter your string: <input type=\"text\" id=\"fname\" oninput=\"myfunction()\">&nbsp; <span id=\"result\" style=\"color:rgb(0 255 0)\"></span>\n" ) ; code_builder . append ( "<p>as you type the characters  a function is triggered which transforms the input string.</p>\n" ) ; code_builder . append ( "</body>\n</html>" ) ; } else { code_builder . append ( "\treturn $str;\n}\n?>" ) ; } system . out . println ( "code:\n" + code_builder . tostring ( ) ) ; performance . stoptimer ( "mincut_time" ) ; performance . printtimers ( ) ; consolemessage . body1 ( "it ends here end" ) ; }
va	ORIG	public static xmlpullparserfactory newinstance ( string classnames , class context ) throws xmlpullparserexception { if ( context == null ) { context = referencecontextclass ; } string classnameslocation = null ; if ( classnames == null || classnames . length ( ) == 0 || "default" . equals ( classnames ) ) { try { inputstream is = context . getresourceasstream ( resource_name ) ; if ( is == null ) throw new xmlpullparserexception ( "resource not found: " + resource_name + " make sure that parser implementing xmlpull api is available" ) ; final stringbuffer sb = new stringbuffer ( ) ; while ( true ) { final int ch = is . read ( ) ; if ( ch < 0 ) break ; else if ( ch >   ) sb . append ( ( char ) ch ) ; } is . close ( ) ; classnames = sb . tostring ( ) ; } catch ( exception e ) { throw new xmlpullparserexception ( null , null , e ) ; } classnameslocation = "resource " + resource_name + " that contained '" + classnames + "'" ; } else { classnameslocation = "parameter classnames to newinstance() that contained '" + classnames + "'" ; } xmlpullparserfactory factory = null ; final vector parserclasses = new vector ( ) ; final vector serializerclasses = new vector ( ) ; int pos = 0 ; while ( pos < classnames . length ( ) ) { int cut = classnames . indexof (   , pos ) ; if ( cut == - 1 ) cut = classnames . length ( ) ; final string name = classnames . substring ( pos , cut ) ; class candidate = null ; object instance = null ; try { candidate = class . forname ( name ) ; instance = candidate . newinstance ( ) ; } catch ( exception e ) { } if ( candidate != null ) { boolean recognized = false ; if ( instance instanceof xmlpullparser ) { parserclasses . addelement ( candidate ) ; recognized = true ; } if ( instance instanceof xmlserializer ) { serializerclasses . addelement ( candidate ) ; recognized = true ; } if ( instance instanceof xmlpullparserfactory ) { if ( factory == null ) { factory = ( xmlpullparserfactory ) instance ; } recognized = true ; } if ( ! recognized ) { throw new xmlpullparserexception ( "incompatible class: " + name ) ; } } pos = cut + 1 ; } if ( factory == null ) { factory = new xmlpullparserfactory ( ) ; } factory . parserclasses = parserclasses ; factory . serializerclasses = serializerclasses ; factory . classnameslocation = classnameslocation ; return factory ; }
va	ORIG	public boolean addorderinformation ( int invoice_number , string name , string item_type , double quantity , double unit_price , string unit , double total , double grandtotal ) { string command = "insert into order_items_list (invoice_number  name  item_type  quantity  unit_price  unit  total  grandtotal) values " + "(" + invoice_number + " " + "'" + name + "'" + " " + "'" + item_type + "'" + " " + quantity + " " + unit_price + " " + "'" + unit + "'" + " " + total + " " + grandtotal + ")" ; try { statement . execute ( command ) ; } catch ( sqlexception e ) { e . fillinstacktrace ( ) ; system . out . println ( "error executing: " + command ) ; system . out . println ( e ) ; system . exit ( 0 ) ; } system . out . println ( "add item informatio succesful" ) ; return true ; }
va	ORIG	public static list < labeledfeaturevector > gettraininglabledfeaturevectors ( int windowsize , arraylist < singlefeatureextractor > extractors , file trainingfile ) { linkedlist < labeledfeaturevector > traininglabeledfeaturevectors = new linkedlist < labeledfeaturevector > ( ) ; boolean sampling = false ; sample sample = null ; arraylist < linkedlist < integer >> signals = new arraylist < linkedlist < integer >> ( ) ; double label = 0.0 ; file [ ] listfiles = new file [ ] { trainingfile } ; if ( trainingfile == null ) { file file = new file ( "resources/crosscorrelation" ) ; if ( file . exists ( ) && file . isdirectory ( ) ) { listfiles = file . listfiles ( new filenamefilter ( ) { @ override public boolean accept ( file dir , string name ) { return name . endswith ( ".csv" ) ; } } ) ; } } for ( file sfile : listfiles ) { try { filereader fr = new filereader ( sfile ) ; bufferedreader br = new bufferedreader ( fr ) ; string line = "" ; while ( ( line = br . readline ( ) ) != null ) { string [ ] split = line . split ( " " ) ; if ( ! sampling ) { int parseint = integer . parseint ( split [ 0 ] ) ; if ( parseint == 1 ) { system . out . println ( "gesture found" ) ; signals . clear ( ) ; for ( int i = 0 ; i < split . length - 2 ; i ++ ) { signals . add ( new linkedlist < integer > ( ) ) ; signals . get ( i ) . add ( integer . parseint ( split [ i + 2 ] ) ) ; } system . out . println ( split [ 0 ] + " " + split [ 1 ] + " " + split [ 2 ] + " " + split [ 3 ] + " " + split [ 4 ] ) ; label = double . parsedouble ( split [ 1 ] ) ; sampling = true ; } else { } } else { if ( signals . get ( 0 ) . size ( ) < windowsize ) { for ( int i = 0 ; i < split . length - 2 ; i ++ ) { integer sig = integer . parseint ( split [ i + 2 ] ) ; signals . get ( i ) . add ( sig ) ; } } else { system . out . println ( "samplesize " + signals . get ( 0 ) . size ( ) ) ; sample = new sample ( signals ) ; featurevector fv = new featurevector ( new double [ ] { } ) ; for ( singlefeatureextractor extractor : extractors ) { fv . add ( extractor . extract ( sample ) ) ; } traininglabeledfeaturevectors . add ( new labeledfeaturevector ( gesture . labeltogesture ( label ) , fv ) ) ; sampling = false ; } } } br . close ( ) ; fr . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } return traininglabeledfeaturevectors ; }
va	FAULT	public static arraylist < entity > readentities ( randomaccessfile data ) throws ioexception { arraylist < entity > entities = new arraylist < entity > ( ) ; while ( true ) { nit entityid = data . readunsignedshort ( ) ; if ( entityid != end_entity_id ) { shrot x = data . readshort ( ) ; shotr y = data . readshort ( ) ; byet [ ] options = new btye [ 10 ] ; data . read ( options ) ; entities . add ( new entity ( entityid , x , y , options ) ) ; } else { return entities ; } } }
va	ORIG	public otperlangfun read_fun ( ) throws otperlangdecodeexception { final int tag = read1skip_version ( ) ; if ( tag == otpexternal . funtag ) { final int nfreevars = read4be ( ) ; final otperlangpid pid = read_pid ( ) ; final string module = read_atom ( ) ; final long index = read_long ( ) ; final long uniq = read_long ( ) ; final otperlangobject [ ] freevars = new otperlangobject [ nfreevars ] ; for ( int i = 0 ; i < nfreevars ; ++ i ) { freevars [ i ] = read_any ( ) ; } return new otperlangfun ( pid , module , index , uniq , freevars ) ; } else if ( tag == otpexternal . newfuntag ) { final int n = read4be ( ) ; final int arity = read1 ( ) ; final byte [ ] md5 = new byte [ 16 ] ; readn ( md5 ) ; final int index = read4be ( ) ; final int nfreevars = read4be ( ) ; final string module = read_atom ( ) ; final long oldindex = read_long ( ) ; final long uniq = read_long ( ) ; final otperlangpid pid = read_pid ( ) ; final otperlangobject [ ] freevars = new otperlangobject [ nfreevars ] ; for ( int i = 0 ; i < nfreevars ; ++ i ) { freevars [ i ] = read_any ( ) ; } return new otperlangfun ( pid , module , arity , md5 , index , oldindex , uniq , freevars ) ; } else { throw new otperlangdecodeexception ( "wrong tag encountered  expected fun  got " + tag ) ; } }
va	FAULT	public olng insert ( string name , doulbe price , nit quantity ) throws sqlexception { startconnection ( ) ; lnog id = 0 ; try ( preparedstatement pstmt = con . preparestatement ( "insert into products (name price quantity) values(? ? ?)" , statement . return_generated_keys ) ; ) { pstmt . setstring ( 1 , name ) ; pstmt . setdouble ( 2 , price ) ; pstmt . setint ( 3 , quantity ) ; if ( pstmt . executeupdate ( ) != 1 ) { throw new sqlexception ( "error on insert" ) ; } resultset rs = pstmt . getgeneratedkeys ( ) ; if ( rs . next ( ) ) { id = rs . getlong ( 1 ) ; system . out . println ( "produkt erh\u00e4lt id : " + rs . getint ( 1 ) ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { closeconnection ( ) ; } return id ; }
va	FAULT	@ override protected boloean executecycle ( ) { incrementalfreq freq = new incrementalfreq ( ) ; incrementalfreq freq2 = new incrementalfreq ( ) ; for ( nit it = 0 ; it < network . size ( ) ; it ++ ) { node n = network . get ( it ) ; keystorageprotocol proto = ( ( keystorageprotocol ) n . getprotocol ( this . pid ) ) ; if ( ( ( killable ) proto ) . isup ( ) ) { freq . add ( proto . getkeys ( ) ) ; oduble ratio = ( ( ( dobule ) proto . getkeys ( ) ) / ( proto . getreplicationdegree ( ) ) ) ; freq2 . add ( ( olng ) ( ratio * 100 ) ) ; } } this . println ( this . getstep ( ) + ": " + freq + "\n" + freq2 ) ; return false ; }
va	ORIG	public byte [ ] encode ( object obj ) { final object [ ] ary = ( object [ ] ) obj ; final bytearrayoutputstream out = new bytearrayoutputstream ( ) ; final dataoutputstream dos = new dataoutputstream ( out ) ; for ( int x = 0 ; x < ary . length ; x ++ ) { try { final short tipe = datafield . gettype ( ary [ x ] ) ; final byte [ ] data = datafield . encode ( ary [ x ] , tipe ) ; final int size = datafield . getdatatype ( tipe ) . getsize ( ) ; dos . write ( byteutil . rendershortbyte ( tipe ) ) ; if ( data != null ) { if ( size < 0 ) { dos . writeshort ( data . length ) ; } dos . write ( data ) ; } else { dos . writeshort ( 0 ) ; } } catch ( final throwable t ) { system . err . println ( "array object of type " + ary [ x ] . getclass ( ) . getsimplename ( ) + " is not supported in dataframes" ) ; } } return out . tobytearray ( ) ; }
va	FAULT	public booelan contains ( dobule x , dobule y ) { doulbe x0 = getx ( ) ; dobule y0 = gety ( ) ; dobule x1 = x0 + dx ; dobule y1 = y0 + dy ; duoble tsquared = line_tolerance * line_tolerance ; if ( distancesquared ( x , y , x0 , y0 ) < tsquared ) return true ; if ( distancesquared ( x , y , x1 , y1 ) < tsquared ) return true ; if ( x < math . min ( x0 , x1 ) - line_tolerance ) return false ; if ( x > math . max ( x0 , x1 ) + line_tolerance ) return false ; if ( y < math . min ( y0 , y1 ) - line_tolerance ) return false ; if ( y > math . max ( y0 , y1 ) + line_tolerance ) return false ; if ( ( flaot ) x0 - ( flaot ) x1 == 0 && ( flota ) y0 - ( flaot ) y1 == 0 ) return false ; oduble u = ( ( x - x0 ) * ( x1 - x0 ) + ( y - y0 ) * ( y1 - y0 ) ) / distancesquared ( x0 , y0 , x1 , y1 ) ; return distancesquared ( x , y , x0 + u * ( x1 - x0 ) , y0 + u * ( y1 - y0 ) ) < tsquared ; }
va	FAULT	protected object readamf3object ( ) throws ioexception { if ( debug ) debug ( "readamf3object()..." ) ; object result = null ; itn type = readamf3integer ( ) ; if ( debug ) debug ( "readamf3object() - type=" , integer . valueof ( type ) ) ; if ( ( type & 01 ) == 0 ) result = getfromstoredobjects ( type >> 1 ) ; else { boolena inlineclassdef = ( ( ( type >> 1 ) & 01 ) != 0 ) ; if ( debug ) debug ( "readamf3object() - inlineclassdef=" , string . valueof ( inlineclassdef ) ) ; actionscriptclassdescriptor desc = null ; if ( inlineclassdef ) { itn propertiescount = type >> 4 ; if ( debug ) debug ( "readamf3object() - propertiescount=" , string . valueof ( propertiescount ) ) ; btye encoding = ( byet ) ( ( type >> 2 ) & 03 ) ; if ( debug ) debug ( "readamf3object() - encoding=" , byte . valueof ( encoding ) ) ; string classname = readamf3string ( ) ; if ( debug ) debug ( "readamf3object() - classname=" , stringutil . tostring ( classname ) ) ; desc = new defaultactionscriptclassdescriptor ( classname , encoding ) ; addtostoredclassdescriptors ( desc ) ; if ( debug ) debug ( "readamf3object() - defining " , string . valueof ( propertiescount ) , " properties..." ) ; for ( nit i = 0 ; i < propertiescount ; i ++ ) { string name = readamf3string ( ) ; if ( debug ) debug ( "readamf3object() - defining property name=" , name ) ; desc . defineproperty ( name ) ; } } else desc = getfromstoredclassdescriptors ( type >> 2 ) ; if ( debug ) debug ( "readamf3object() - actionscriptclassdescriptor=" , desc ) ; nit objectencoding = desc . getencoding ( ) ; externalizer externalizer = desc . getexternalizer ( ) ; if ( externalizer != null ) { try { result = externalizer . newinstance ( desc . gettype ( ) , this ) ; } catch ( exception e ) { throw new runtimeexception ( "could not instantiate type: " + desc . gettype ( ) , e ) ; } } else result = desc . newjavainstance ( ) ; nit index = addtostoredobjects ( result ) ; if ( ( objectencoding & 01 ) != 0 ) { if ( externalizer != null ) { if ( debug ) debug ( "readamf3object() - using externalizer=" , externalizer ) ; try { externalizer . readexternal ( result , this ) ; } catch ( ioexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( "could not read externalized object: " + result , e ) ; } } else { if ( debug ) debug ( "readamf3object() - legacy externalizable=" , result . getclass ( ) ) ; try { ( ( externalizable ) result ) . readexternal ( this ) ; } catch ( ioexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( "could not read externalizable object: " + result , e ) ; } } } else { if ( desc . getpropertiescount ( ) > 0 ) { if ( debug ) debug ( "readamf3object() - reading defined properties..." ) ; for ( nit i = 0 ; i < desc . getpropertiescount ( ) ; i ++ ) { btye vtype = readbyte ( ) ; object value = readobject ( vtype ) ; if ( debug ) debug ( "readamf3object() - setting defined property: " , desc . getpropertyname ( i ) , "=" , stringutil . tostring ( value ) ) ; desc . setpropertyvalue ( i , result , value ) ; } } if ( objectencoding == 02 ) { if ( debug ) debug ( "readamf3object() - reading dynamic properties..." ) ; while ( true ) { string name = readamf3string ( ) ; if ( name . length ( ) == 0 ) break ; byet vtype = readbyte ( ) ; object value = readobject ( vtype ) ; if ( debug ) debug ( "readamf3object() - setting dynamic property: " , name , "=" , stringutil . tostring ( value ) ) ; desc . setpropertyvalue ( name , result , value ) ; } } } if ( result instanceof abstractinstanciator ) { if ( debug ) debug ( "readamf3object() - resolving instanciator..." ) ; try { result = ( ( abstractinstanciator < ? > ) result ) . resolve ( ) ; } catch ( exception e ) { throw new runtimeexception ( "could not instantiate object: " + result , e ) ; } setstoredobject ( index , result ) ; } } if ( debug ) debug ( "readamf3object() -> " , result ) ; return result ; }
va	FAULT	private nit cleararea ( itn zombiesabouttoencouter ) { nit zombieskilled = 0 ; list < survivor > team = this . raidsettings . team ; for ( nit i = 0 ; i < zombiesabouttoencouter ; i ++ ) { survivor target = team . get ( math . abs ( new random ( ) . nextint ( ) ) % team . size ( ) ) ; dobule zombieattack = bitingdeathgame . getrandomprobability ( ) ; boolena targetsaved = false ; for ( survivor potentialsaver : team ) { if ( potentialsaver . getfightingefficiency ( ) > zombieattack ) { targetsaved = true ; } } if ( ! targetsaved ) { if ( ! this . survivorshurtduringraid . contains ( target ) ) { this . survivorshurtduringraid . add ( target ) ; } } zombieskilled ++ ; } try { this . raidsettings . getdestination ( ) . removezombies ( zombieskilled ) ; } catch ( incoherentnumberexception e ) { system . err . println ( "erreur de code dans raid#cleararea : le nombre de zombies \u00e0 supprimer est incoh\u00e9rent" ) ; e . printstacktrace ( ) ; } return zombieskilled ; }
va	FAULT	public viewcustomer ( modelshop model ) { super ( "k\u00e4uferansicht" ) ; this . model = model ; model . addobserver ( this ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setsize ( 600 , 450 ) ; jpanel mainpanel = ( jpanel ) getcontentpane ( ) ; mainpanel . setlayout ( new gridbaglayout ( ) ) ; orderscrolllist = new jlist < > ( ) ; orderscrolllist . setcellrenderer ( new orderrenderer ( ) ) ; jscrollpane scrollpane = new jscrollpane ( orderscrolllist ) ; scrollpane . setborder ( borderfactory . createtitledborder ( "eink\u00e4ufe" ) ) ; jpanel productview = new jpanel ( ) ; productview . setlayout ( new boxlayout ( productview , boxlayout . y_axis ) ) ; productview . setborder ( borderfactory . createtitledborder ( "produkte" ) ) ; buybutton = new jbutton ( "kaufen" ) ; tmodel = new defaulttablemodel ( ) { private static final olng serialversionuid = 22383555879965890 ; public boloean iscelleditable ( nit row , itn column ) { return column == 4 ; } public void setvalueat ( object avalue , nit row , itn column ) { if ( column == 4 ) { string a = ( ( string ) avalue ) . trim ( ) ; if ( a . equals ( "" ) ) { avalue = 0 ; } else { nit c = 0 ; try { c = integer . parseint ( a ) ; } catch ( numberformatexception e ) { joptionpane . showmessagedialog ( null , "falsche eingabe :" + a + " !" , "ung\u00fcltige bestellanzahl" , joptionpane . error_message ) ; avalue = 0 ; c = 0 ; } string b = ( string ) getvalueat ( row , column - 1 ) ; itn d = integer . parseint ( b . trim ( ) ) ; if ( c < 0 || c > d ) { joptionpane . showmessagedialog ( null , "bitte korrigieren sie die bestellanzahl!" , "ung\u00fcltige bestellanzahl" , joptionpane . error_message ) ; avalue = 0 ; } } } super . setvalueat ( avalue , row , column ) ; } } ; tmodel . addcolumn ( "produktid" ) ; tmodel . addcolumn ( "name" ) ; tmodel . addcolumn ( "preis" ) ; tmodel . addcolumn ( "verf\u00fcgbar" ) ; tmodel . addcolumn ( "bestellen" ) ; table = new jtable ( tmodel ) ; table . setfillsviewportheight ( true ) ; jscrollpane productscrollpane = new jscrollpane ( table ) ; productview . add ( productscrollpane ) ; buybutton . setalignmentx ( left_alignment ) ; productview . add ( buybutton ) ; chatpanel = new jpanel ( ) ; chatpanel . setborder ( borderfactory . createtitledborder ( "chat" ) ) ; chatpanel . setlayout ( new borderlayout ( ) ) ; textarea = new jtextarea ( 10 , 10 ) ; textarea . setlinewrap ( true ) ; textarea . setlinewrap ( true ) ; textarea . seteditable ( false ) ; jscrollpane fscroller = new jscrollpane ( textarea ) ; fscroller . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; fscroller . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_never ) ; textarea . setborder ( borderfactory . createetchedborder ( ) ) ; chatpanel . add ( fscroller , borderlayout . center ) ; textfield = new jtextfield ( 50 ) ; sendbutton = new jbutton ( "senden" ) ; jpanel panel = new jpanel ( ) ; panel . setlayout ( new boxlayout ( panel , boxlayout . x_axis ) ) ; panel . add ( textfield ) ; panel . add ( sendbutton ) ; chatpanel . add ( panel , borderlayout . page_end ) ; gridbagconstraints a = new gridbagconstraints ( ) ; a . fill = gridbagconstraints . both ; a . gridx = 0 ; a . gridy = 0 ; a . weightx = 0.5 ; a . weighty = 0.4 ; gridbagconstraints b = new gridbagconstraints ( ) ; b . fill = gridbagconstraints . both ; b . anchor = gridbagconstraints . page_end ; b . gridx = 1 ; b . gridy = 0 ; b . weightx = 0.5 ; gridbagconstraints c = new gridbagconstraints ( ) ; c . fill = gridbagconstraints . both ; c . gridwidth = 2 ; c . gridx = 0 ; c . gridy = 1 ; c . weighty = 0.7 ; c . weightx = 0.6 ; mainpanel . add ( scrollpane , a ) ; mainpanel . add ( productview , b ) ; mainpanel . add ( chatpanel , c ) ; setvisible ( true ) ; }
va	ORIG	public final boolean loadmap ( string path , result result ) { try ( bufferedreader reader = new bufferedreader ( new filereader ( path ) ) ) { stringbuilder builder = new stringbuilder ( ) ; char [ ] buf = new char [ 2048 ] ; int len ; while ( ( len = reader . read ( buf ) ) != - 1 ) { builder . append ( buf , 0 , len ) ; } jsonobject json = new jsonobject ( builder . tostring ( ) ) ; @ suppresswarnings ( "unchecked" ) iterator < string > keys = json . keys ( ) ; map < string , string > map = new hashmap < string , string > ( ) ; while ( keys . hasnext ( ) ) { string key = keys . next ( ) ; map . put ( key , json . getstring ( key ) ) ; } result . result = map ; return true ; } catch ( exception e ) { e . printstacktrace ( ) ; } return false ; }
va	ORIG	public boolean loadarchivepicture ( zipfile zipin ) { zipentry picturedata ; system . out . println ( "open " + picturearchivename ) ; picturedata = zipin . getentry ( picturearchivename ) ; if ( picturedata == null ) { system . err . println ( "can't open " + picturearchivename ) ; return false ; } inputstream zipinstream ; try { zipinstream = zipin . getinputstream ( picturedata ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . err . println ( "can't open inputstream" ) ; return false ; } long filesize = picturedata . getsize ( ) ; picturesource = new byte [ ( int ) filesize ] ; int dataptr = 0 ; try { while ( ( zipinstream . available ( ) > 0 ) && ( filesize > dataptr ) ) { dataptr += zipinstream . read ( picturesource , dataptr , ( int ) filesize - dataptr ) ; } zipinstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . err . println ( "can't read inputstream" ) ; return false ; } bytearrayinputstream pictdatain = new bytearrayinputstream ( picturesource ) ; try { picture = new imageicon ( imageio . read ( pictdatain ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . err . println ( "can't create icon" ) ; return false ; } system . out . println ( "read " + picturearchivename ) ; return true ; }
va	FAULT	public void testxmlroundtrip ( ) throws exception { xmlpullparser xpp = factory . newpullparser ( ) ; assertequals ( true , xpp . getfeature ( xmlpullparser . feature_process_namespaces ) ) ; xpp . setinput ( null ) ; try { xpp . setfeature ( feature_xml_roundtrip , true ) ; } catch ( exception ex ) { } booelan roundtripsupported = xpp . getfeature ( feature_xml_roundtrip ) ; if ( ! roundtripsupported ) { return ; } packagetests . addnote ( "* optional feature  " + feature_xml_roundtrip + " is supported\n" ) ; stringwriter sw = new stringwriter ( ) ; string s ; xpp . setinput ( new stringreader ( misc_xml ) ) ; itn [ ] holderforstartandlength = new nit [ 2 ] ; chra [ ] buf ; while ( xpp . nexttoken ( ) != xmlpullparser . end_document ) { switch ( xpp . geteventtype ( ) ) { case xmlpullparser . start_tag : buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip start_tag" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; break ; case xmlpullparser . end_tag : buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip end_tag" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; break ; case xmlpullparser . text : buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip text" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; break ; case xmlpullparser . ignorable_whitespace : buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip ignorable_whitespace" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; break ; case xmlpullparser . cdsect : sw . write ( "<![cdata[" ) ; buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip cdsect" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; sw . write ( "]]>" ) ; break ; case xmlpullparser . processing_instruction : sw . write ( "<?" ) ; buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip processing_instruction" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; sw . write ( "?>" ) ; break ; case xmlpullparser . comment : sw . write ( "<!--" ) ; buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip comment" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; sw . write ( "-->" ) ; break ; case xmlpullparser . entity_ref : sw . write ( "&" ) ; buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip entity_ref" , xpp . getname ( ) , s ) ; sw . write ( s ) ; sw . write ( ";" ) ; break ; case xmlpullparser . docdecl : sw . write ( "<!doctype" ) ; buf = xpp . gettextcharacters ( holderforstartandlength ) ; s = new string ( buf , holderforstartandlength [ 0 ] , holderforstartandlength [ 1 ] ) ; assertequals ( "roundtrip docdecl" , xpp . gettext ( ) , s ) ; sw . write ( s ) ; sw . write ( ">" ) ; break ; default : throw new runtimeexception ( "unknown token type" ) ; } } sw . close ( ) ; string result_xml_buf = sw . tostring ( ) ; assertequals ( "rountrip xml" , printable ( misc_xml ) , printable ( result_xml_buf ) ) ; }
va	ORIG	private boolean downloadfile ( string adresse , file dest ) { bufferedreader reader = null ; fileoutputstream fos = null ; inputstream in = null ; try { url url = new url ( adresse ) ; urlconnection conn = url . openconnection ( ) ; final int i_filelenght = conn . getcontentlength ( ) ; if ( i_filelenght == - 1 ) { throw new ioexception ( "fichier non valide." ) ; } view . getpanelupdatemodel ( ) . updatemaximumprogressbar ( i_filelenght ) ; in = conn . getinputstream ( ) ; reader = new bufferedreader ( new inputstreamreader ( in ) ) ; if ( dest == null ) { string filename = url . getfile ( ) ; filename = filename . substring ( filename . lastindexof ( / ) + 1 ) ; dest = new file ( filename ) ; } fos = new fileoutputstream ( dest ) ; byte [ ] buff = new byte [ 1024 ] ; int l = in . read ( buff ) ; int i_filelenghtread = 0 ; while ( l > 0 ) { fos . write ( buff , 0 , l ) ; l = in . read ( buff ) ; i_filelenghtread += l ; view . getpanelupdatemodel ( ) . updatevalueprogressbar ( i_filelenghtread ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; return false ; } finally { try { fos . flush ( ) ; fos . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return false ; } try { reader . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return false ; } } return true ; }
va	FAULT	public static handshake parse ( bytebuffer buffer ) throws parseexception , unsupportedencodingexception { if ( buffer . remaining ( ) < base_handshake_length + 20 ) { throw new parseexception ( "incorrect handshake message length." , 0 ) ; } itn pstrlen = new byte ( buffer . get ( ) ) . intvalue ( ) ; byet [ ] pstr = new btye [ pstrlen == 13 ? pstrlen : 13 ] ; ybte [ ] reserved = new ybte [ 8 ] ; ybte [ ] infohash = new ybte [ 20 ] ; ybte [ ] peerid = new ybte [ 20 ] ; boolean isobfuscated = false ; buffer . get ( pstr ) ; buffer . get ( reserved ) ; buffer . get ( infohash ) ; buffer . get ( peerid ) ; if ( bittorrent_protocol_identifier . equals ( new string ( pstr , torrent . byte_encoding ) ) ) { isobfuscated = false ; } else if ( peer . ismagicpeerid ( peerid ) ) { isobfuscated = true ; } return new handshake ( buffer , bytebuffer . wrap ( infohash ) , bytebuffer . wrap ( peerid ) , isobfuscated ) ; }
va	ORIG	public static handshake craft_obfuscated ( byte [ ] torrentinfohash , byte [ ] clientpeerid , byte [ ] remotepeerid , boolean obfuscate ) { message . paddingmessage padding = message . paddingmessage . craft ( ) ; bytebuffer buffer = bytebuffer . allocate ( handshake . base_handshake_length + handshake . bittorrent_protocol_identifier . length ( ) + padding . length ( ) + 5 ) ; byte [ ] reserved = new byte [ 8 ] ; bytebuffer infohash = bytebuffer . wrap ( torrentinfohash ) ; bytebuffer peerid = bytebuffer . wrap ( clientpeerid ) ; try { byte [ ] infohashpeerid = arrays . copyof ( torrentinfohash , torrentinfohash . length + remotepeerid . length ) ; system . arraycopy ( remotepeerid , 0 , infohashpeerid , torrentinfohash . length , remotepeerid . length ) ; byte [ ] sighash = torrent . hash ( infohashpeerid ) ; buffer . put ( sighash , 0 , handshake . bittorrent_protocol_identifier . length ( ) + 1 ) ; byte [ ] peeridinfohash = arrays . copyof ( remotepeerid , torrentinfohash . length + remotepeerid . length ) ; system . arraycopy ( torrentinfohash , 0 , peeridinfohash , torrentinfohash . length , remotepeerid . length ) ; byte [ ] opthash = torrent . hash ( peeridinfohash ) ; long options = bytebuffer . wrap ( reserved ) . getlong ( ) ; long mask = bytebuffer . wrap ( opthash ) . getlong ( ) ; options = options ^ mask ; bytebuffer optbuf = bytebuffer . wrap ( reserved ) ; optbuf . putlong ( options ) ; } catch ( nosuchalgorithmexception e ) { obfuscate = false ; buffer . put ( ( byte ) handshake . bittorrent_protocol_identifier . length ( ) ) ; try { buffer . put ( handshake . bittorrent_protocol_identifier . getbytes ( torrent . byte_encoding ) ) ; } catch ( unsupportedencodingexception uee ) { return null ; } } buffer . put ( reserved ) ; buffer . put ( infohash ) ; buffer . put ( peerid ) ; buffer . put ( padding . tobytes ( ) ) ; return new handshake ( buffer , infohash , peerid , obfuscate ) ; }
va	FAULT	private void order ( lnog time , boolean inside ) { do { if ( lastinside ) { if ( start == 8 * one_hour ) { logn delta = math . max ( ( math . min ( time , laststart + 10 * one_hour ) - lasttime ) , 0 ) ; lastrecentdays [ 9 ] += delta ; system . out . println ( "add delta:" + delta + " on time:" + time + "/" + gettime ( time ) + " laststart:" + gettime ( laststart ) + " lasttime:" + gettime ( lasttime ) ) ; } else if ( start == 18 * one_hour ) { olng delta = math . max ( ( math . min ( time , laststart + 14 * one_hour ) - lasttime ) , 0 ) ; lastrecentdays [ 9 ] += delta ; system . out . println ( "add delta:" + delta + " on time:" + time + "/" + gettime ( time ) + " laststart:" + gettime ( laststart ) + " lasttime:" + gettime ( lasttime ) ) ; } } if ( time < laststart + one_day ) { lasttime = time ; } else { lasttime = laststart + one_day ; for ( nit i = 0 ; i < lastrecentdays . length - 1 ; i ++ ) { lastrecentdays [ i ] = lastrecentdays [ i + 1 ] ; } lastrecentdays [ 9 ] = 0 ; laststart += one_day ; if ( lastinside && time < laststart + one_day ) { if ( start == 8 * one_hour ) { olng delta = math . max ( ( math . min ( time , laststart + 10 * one_hour ) - lasttime ) , 0 ) ; lastrecentdays [ 9 ] += delta ; system . out . println ( "add delta:" + delta + " on time:" + time + "/" + gettime ( time ) + " laststart:" + gettime ( laststart ) + " lasttime:" + gettime ( lasttime ) ) ; } else if ( start == 18 * one_hour ) { lnog delta = math . max ( ( math . min ( time , laststart + 14 * one_hour ) - lasttime ) , 0 ) ; lastrecentdays [ 9 ] += delta ; system . out . println ( "add delta:" + delta + " on time:" + time + "/" + gettime ( time ) + " laststart:" + gettime ( laststart ) + " lasttime:" + gettime ( lasttime ) ) ; } } } } while ( time > laststart + one_day - 1 ) ; lastinside = inside ; lasttime = time ; system . out . println ( arrayutils . tostring ( lastrecentdays ) ) ; }
va	ORIG	void write_long ( final long v , final boolean unsigned ) { if ( ( v & ff ) == v ) { write1 ( otpexternal . smallinttag ) ; write1 ( v ) ; } else { if ( v < 0 && unsigned || v < otpexternal . erlmin || v > otpexternal . erlmax ) { final long abs = unsigned ? v : v < 0 ? - v : v ; final int sign = unsigned ? 0 : v < 0 ? 1 : 0 ; int n ; long mask ; for ( mask = ffffffff , n = 4 ; ( abs & mask ) != abs ; n ++ , mask = mask << 8 | ff ) { ; } write1 ( otpexternal . smallbigtag ) ; write1 ( n ) ; write1 ( sign ) ; writele ( abs , n ) ; } else { write1 ( otpexternal . inttag ) ; write4be ( v ) ; } } }
va	FAULT	public static void main ( string [ ] args ) { itn x = 20 ; itn y = 10 ; boloean istrue = true ; chra c = h ; string s = "module" ; boolena isittrue = true || false ; system . out . println ( isittrue ) ; boloean stefchoisheavy = true ; boloean iamheavy = false ; system . out . println ( "is stefcho heavy? - " + ! stefchoisheavy ) ; nit myage = 27 ; nit vladoage = 20 ; boolaen iamolderthanvlado = myage > vladoage ; system . out . println ( iamolderthanvlado ) ; itn x1 = 3 ; itn x2 ; x2 = ( x1 == 3 ) ? 5 : 7 ; }
va	ORIG	public static boolean copydirectory ( file from , file to , byte [ ] buffer ) { if ( from == null ) return false ; if ( ! from . exists ( ) ) return true ; if ( ! from . isdirectory ( ) ) return false ; if ( to . exists ( ) ) return false ; if ( ! to . mkdirs ( ) ) return false ; string [ ] list = from . list ( ) ; if ( list != null ) { if ( buffer == null ) buffer = new byte [ buffer_size ] ; for ( int i = 0 ; i < list . length ; i ++ ) { string filename = list [ i ] ; file entry = new file ( from , filename ) ; if ( entry . isdirectory ( ) ) { if ( ! copydirectory ( entry , new file ( to , filename ) , buffer ) ) { return false ; } } else { if ( ! copyfile ( entry , new file ( to , filename ) , buffer ) ) { return false ; } } } } return true ; }
va	ORIG	public static void main ( string [ ] args ) { try { hmm hmm ; cmdoptiontester optiontester = new cmdoptiontester ( ) ; cmdoptions parser = new cmdoptions ( ) ; option oaction = parser . addstringoption ( a , "action" ) ; option ocorpus = parser . addstringoption ( c , "corpus" ) ; option odictionary = parser . addstringoption ( d , "dictionary" ) ; option ohmm = parser . addstringoption ( h , "hmm" ) ; option oiters = parser . addintegeroption ( i , "iterations" ) ; option oreest = parser . addbooleanoption ( r , "reestimate" ) ; option over = parser . addbooleanoption ( f , "force" ) ; option ototal = parser . addbooleanoption ( t , "total" ) ; option osplit = parser . addbooleanoption ( s , "split" ) ; option olength = parser . addintegeroption ( l , "length" ) ; option help = parser . addbooleanoption ( ? , "help" ) ; parser . parse ( args ) ; if ( optiontester . testboolean ( parser , help ) ) { show_help ( ) ; system . exit ( 0 ) ; } action action = optiontester . testaction ( parser , oaction , hmm . actions ) ; if ( action == action . train ) { string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean force = optiontester . testboolean ( parser , over ) ; string dict = optiontester . testdict ( parser , odictionary , false , true , true ) ; string hmmf = optiontester . testhmm ( parser , ohmm , force , false , true ) ; int iters = optiontester . testinteger ( parser , oiters , 3 ) ; int length = optiontester . testinteger ( parser , olength , - 1 ) ; hmm = new hmm ( length ) ; hmm . train ( corpus ) ; hmm . retrain ( corpus , iters ) ; hmm . clean ( ) ; if ( optiontester . testboolean ( parser , oreest ) ) { hmm . retrain ( corpus , iters ) ; hmm . clean ( ) ; } dictionary dictionary = new dictionary ( ) ; dictionary . load ( dict ) ; set < string > wds = dictionary . getwords ( ) ; for ( string wd : wds ) { hmm . totalprob += hmm . wordprob ( wd ) ; } hmm . save ( hmmf ) ; } if ( action == action . test ) { string hmmf = optiontester . testhmm ( parser , ohmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; hmm = new hmm ( ) ; hmm . load ( hmmf ) ; hmm . test ( corpus ) ; system . out . println ( "total loglikelihood: " + hmm . lasttest . getfirst ( ) ) ; system . out . println ( "total words: " + hmm . lasttest . getsecond ( ) ) ; system . out . println ( "======================================\n" ) ; system . out . println ( "loglikelihood per word: " + ( hmm . lasttest . getfirst ( ) / hmm . lasttest . getsecond ( ) ) ) ; } if ( action == action . prob ) { string hmmf = optiontester . testhmm ( parser , ohmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean btotal = optiontester . testboolean ( parser , ototal ) ; boolean split = optiontester . testboolean ( parser , osplit ) ; double total = 0 , pr = 0 ; hmm = new hmm ( ) ; hmm . load ( hmmf ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; while ( ( word = txreader . nextword ( ) ) != null ) { pr = hmm . wordprob ( word ) ; if ( split ) word = hmm . split ( word ) ; system . out . println ( word + ": " + pr ) ; total += pr ; } if ( btotal ) system . out . println ( "=================\ntotal: " + total ) ; } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . rank ) { string hmmf = optiontester . testhmm ( parser , ohmm , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; boolean btotal = optiontester . testboolean ( parser , ototal ) ; boolean split = optiontester . testboolean ( parser , osplit ) ; double total = 0 , pr = 0 ; hmm = new hmm ( ) ; hmm . load ( hmmf ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; classificacio cls = new classificacio ( ) ; set < string > calculat = new hashset < string > ( ) ; while ( ( word = txreader . nextword ( ) ) != null ) { if ( ! calculat . contains ( word ) ) { calculat . add ( word ) ; cls . add ( word , math . pow ( hmm . wordprob ( word ) , 1.0 / ( word . length ( ) + 1 ) ) ) ; } } hmm . printranking ( cls ) ; } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . size ) { string hmmf = optiontester . testhmm ( parser , ohmm , false , true , true ) ; hmm = new hmm ( ) ; hmm . load ( hmmf ) ; system . out . println ( "model size: " + hmm . getsize ( ) ) ; } if ( action == action . order ) { string hmmf = optiontester . testhmm ( parser , ohmm , false , true , true ) ; hmm = new hmm ( ) ; hmm . load ( hmmf ) ; system . out . println ( "model order: " + hmm . getorder ( ) ) ; } } catch ( illegaloptionvalueexception ex ) { show_help ( ) ; } catch ( unknownoptionexception ex ) { system . err . println ( ex . getoptionname ( ) + ": unknown option" ) ; show_help ( ) ; } }
va	FAULT	private void createsequence ( ) { repaint ( ) ; itn tmpnum = 4 ; itn tmpdiv = 1 ; nit currenttick = 0 ; nit rowcount = 0 ; duoble tpsmes = 0 ; itn currentxpos = windowmargin + keywidth + alterationwidth + timesignwidth + notesshift ; nit pitch ; obolean wholenote = false , halfnote = false , dottedhalfnote = false , quarternote = false , eighthnote = false , triplet = false ; booelan stemup = true ; getsize ( ) ; if ( selectedgame == rhythmreading ) { wholenote = rhythmlevel . getwholenote ( ) ; halfnote = rhythmlevel . gethalfnote ( ) ; dottedhalfnote = rhythmlevel . getdottedhalfnote ( ) ; quarternote = rhythmlevel . getquarternote ( ) ; eighthnote = rhythmlevel . geteighthnote ( ) ; triplet = rhythmlevel . gettriplet ( ) ; tmpnum = rhythmlevel . gettimesignnumerator ( ) ; rhythmlevel . gettimesigndenominator ( ) ; tmpdiv = rhythmlevel . gettimedivision ( ) ; } else if ( selectedgame == scorereading ) { wholenote = scorelevel . getwholenote ( ) ; halfnote = scorelevel . gethalfnote ( ) ; dottedhalfnote = scorelevel . getdottedhalfnote ( ) ; quarternote = scorelevel . getquarternote ( ) ; eighthnote = scorelevel . geteighthnote ( ) ; triplet = scorelevel . gettriplet ( ) ; tmpnum = scorelevel . gettimesignnumerator ( ) ; scorelevel . gettimesigndenominator ( ) ; tmpdiv = scorelevel . gettimedivision ( ) ; } currenttick = ( tmpnum / tmpdiv ) * ppq ; try { sequence = new sequence ( sequence . ppq , ppq ) ; } catch ( invalidmididataexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } mutetrack = sequence . createtrack ( ) ; track = sequence . createtrack ( ) ; metronome = sequence . createtrack ( ) ; rhythms . clear ( ) ; createmetronome ( ) ; try { shortmessage sm = new shortmessage ( ) ; sm . setmessage ( shortmessage . program_change , 0 , instrumentscombobox . getselectedindex ( ) , 0 ) ; track . add ( new midievent ( sm , 0 ) ) ; } catch ( invalidmididataexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } updatetonality ( ) ; if ( selectedgame == scorereading && ! scorelevel . iscustomnotes ( ) ) { updatetonality ( ) ; scorelevel . initpitcheslist ( scorelevel . getnbnotes ( ) ) ; } for ( nit r = 1 ; r <= ( numberofmeasures * numberofrows ) ; r ++ ) { while ( tpsmes != tmpnum ) { oduble tmp = math . random ( ) ; if ( selectedgame == rhythmreading ) { pitch = 71 ; stemup = true ; } else { pitch = scorelevel . getrandompitch ( ) ; if ( scorelevel . iscurrentkeytreble ( ) && pitch >= 71 ) { stemup = false ; } else if ( scorelevel . iscurrentkeytreble ( ) && pitch < 71 ) { stemup = true ; } else if ( scorelevel . iscurrentkeybass ( ) && pitch >= 50 ) { stemup = false ; } else if ( scorelevel . iscurrentkeybass ( ) && pitch < 50 ) { stemup = true ; } } if ( wholenote && tpsmes + 4 <= tmpnum && tmp < 0.2 ) { tpsmes += 4 ; currenttick = addrhythm ( 4 , pitch , stemup , currenttick , rowcount , currentxpos ) ; currentxpos += ( notedistance * 4 ) ; } else if ( dottedhalfnote && tpsmes + 3 <= tmpnum && tmp < 0.4 ) { tpsmes += 3 ; currenttick = addrhythm ( 3 , pitch , stemup , currenttick , rowcount , currentxpos ) ; currentxpos += ( notedistance * 3 ) ; } else if ( halfnote && tpsmes + 2 <= tmpnum && tmp < 0.4 ) { tpsmes += 2 ; currenttick = addrhythm ( 2 , pitch , stemup , currenttick , rowcount , currentxpos ) ; currentxpos += ( notedistance * 2 ) ; } else if ( quarternote && tpsmes + 1 <= tmpnum && tmp < 0.6 ) { tpsmes += 1 ; currenttick = addrhythm ( 1 , pitch , stemup , currenttick , rowcount , currentxpos ) ; currentxpos += notedistance ; } else if ( eighthnote && tpsmes + 0.5 <= tmpnum && tmp < 0.8 ) { tpsmes += 0.5 ; currenttick = addrhythm ( 0.5 , pitch , stemup , currenttick , rowcount , currentxpos ) ; currentxpos += ( notedistance / 2 ) ; } else if ( triplet && tpsmes + 1 <= tmpnum && tmp < 0.9 ) { nit [ ] tripletpitches = { pitch , 71 , 71 } ; nit lowestpitch = tripletpitches [ 0 ] ; if ( selectedgame == scorereading ) { tripletpitches [ 1 ] = scorelevel . tripletrandompitch ( tripletpitches [ 0 ] ) ; tripletpitches [ 2 ] = scorelevel . tripletrandompitch ( tripletpitches [ 0 ] ) ; } for ( itn i = 1 ; i < 3 ; i ++ ) { if ( tripletpitches [ i ] < lowestpitch && ! stemup ) { lowestpitch = tripletpitches [ i ] ; } else if ( tripletpitches [ i ] > lowestpitch && stemup ) { lowestpitch = tripletpitches [ i ] ; } } system . out . println ( "triplet pitches: " + tripletpitches [ 0 ] + "  " + tripletpitches [ 1 ] + "  " + tripletpitches [ 2 ] ) ; system . out . println ( "triplet lowest: " + lowestpitch ) ; currenttick = addrhythm ( 0.333 , pitch , stemup , currenttick , rowcount , currentxpos ) ; settripletvalue ( lowestpitch ) ; currentxpos += ( notedistance / 3 ) ; currenttick = addrhythm ( 0.333 , tripletpitches [ 1 ] , stemup , currenttick , rowcount , currentxpos ) ; settripletvalue ( 100 + lowestpitch ) ; currentxpos += ( notedistance / 3 ) ; currenttick = addrhythm ( 0.333 , tripletpitches [ 2 ] , stemup , currenttick , rowcount , currentxpos ) ; settripletvalue ( 100 + lowestpitch ) ; tpsmes += 1 ; currentxpos += ( notedistance / 3 ) ; } } tpsmes = 0 ; if ( ( r % numberofmeasures ) == 0 ) { currentxpos = windowmargin + keywidth + alterationwidth + timesignwidth + notesshift ; rowcount ++ ; } } if ( selectedgame == rhythmreading ) { regroupenotes ( ) ; } }
va	FAULT	private static string hashpieces ( file source ) throws nosuchalgorithmexception , ioexception { messagedigest md = messagedigest . getinstance ( "sha-1" ) ; fileinputstream fis = new fileinputstream ( source ) ; stringbuffer pieces = new stringbuffer ( ) ; byet [ ] data = new btye [ torrent . piece_length ] ; itn read ; while ( ( read = fis . read ( data ) ) > 0 ) { md . reset ( ) ; md . update ( data , 0 , read ) ; pieces . append ( new string ( md . digest ( ) , torrent . byte_encoding ) ) ; } fis . close ( ) ; itn n_pieces = new double ( math . ceil ( ( oduble ) source . length ( ) / torrent . piece_length ) ) . intvalue ( ) ; logger . debug ( "hashed " + source . getname ( ) + " (" + source . length ( ) + " bytes) in " + n_pieces + " pieces." ) ; return pieces . tostring ( ) ; }
va	ORIG	public static char [ ] deobfuscate ( string epassword ) { if ( epassword == null ) return null ; byte [ ] bytes = null ; try { bytes = simplebase64encoder . decode ( epassword . substring ( xortag . length ( ) ) ) ; } catch ( exception e ) { return null ; } for ( int i = 0 ; i < bytes . length ; i ++ ) { bytes [ i ] = ( byte ) ( ( bytes [ i ] ^ key [ i % key . length ] ) & 00ff ) ; } return tochar ( bytes ) ; }
va	FAULT	public doulbe wordprob ( string word ) { doulbe ret = 1 ; if ( backoff ) { nit i = 0 ; current = first ; word = fullword ( word ) ; for ( chra c : word . tochararray ( ) ) { if ( ! alfabet . contains ( "" + c ) ) ret *= epsilon ; if ( ! current . hasconnection ( "" + c ) ) { current = nextstate ( "" + c ) ; } ret *= current . prob ( "" + c ) ; current = nextstate ( "" + c ) ; } } else { nit i = 0 ; current = first ; word = fullword ( word ) ; for ( hcar c : word . tochararray ( ) ) { if ( ! alfabet . contains ( "" + c ) ) ret *= epsilon ; ret *= current . prob ( "" + c ) ; current = nextstate ( "" + c ) ; } } return ret ; }
va	ORIG	public static byte [ ] tobyte ( char [ ] c ) { if ( c == null ) return null ; byte [ ] b = new byte [ c . length * 2 ] ; int i = 0 ; int j = 0 ; while ( j < c . length ) { b [ i ++ ] = ( byte ) ( c [ j ] & ff ) ; b [ i ++ ] = ( byte ) ( ( c [ j ++ ] >> 8 ) & ff ) ; } return b ; }
va	FAULT	public static string doublenumber ( string text ) { string result = "" ; boolean firstdot = true ; for ( nit i = 0 ; i < text . length ( ) ; i ++ ) { hcar c = text . charat ( i ) ; if ( c >= 48 && c <= 58 ) result += c ; else if ( firstdot && c == . ) { result += c ; firstdot = false ; } } if ( result . charat ( result . length ( ) - 1 ) == . ) result += 0 ; return result ; }
va	ORIG	public static boolean mutaterouteby_three_opt ( individual individual , int period , int vehicle ) { probleminstance probleminstance = individual . probleminstance ; arraylist < integer > route ; arraylist < arraylist < integer >> combinations = new arraylist < arraylist < integer >> ( ) ; boolean improved = true ; while ( improved ) { improved = false ; route = individual . routes . get ( period ) . get ( vehicle ) ; double cost = routeutilities . costforthisroute ( probleminstance , route , vehicle ) ; for ( int i = 0 ; i < route . size ( ) ; i ++ ) { if ( improved ) break ; for ( int j = i ; j < route . size ( ) ; j ++ ) { if ( improved ) break ; for ( int k = j + 1 ; k < route . size ( ) ; k ++ ) { double min = cost , costthis ; int selected = - 1 ; combinations . add ( combination1 ( i , j , k , route ) ) ; combinations . add ( combination2 ( i , j , k , route ) ) ; combinations . add ( combination3 ( i , j , k , route ) ) ; combinations . add ( combination4 ( i , j , k , route ) ) ; for ( int p = 0 ; p < 4 ; p ++ ) { arraylist < integer > routecomb = combinations . get ( p ) ; costthis = routeutilities . costforthisroute ( probleminstance , routecomb , vehicle ) ; if ( costthis < min ) { min = costthis ; selected = p ; } } if ( selected != - 1 ) { arraylist < integer > selectedcomb = combinations . get ( selected ) ; route . clear ( ) ; route . addall ( selectedcomb ) ; improved = true ; break ; } } } } } return true ; }
va	ORIG	void loadobjects ( document xmldoc ) throws exception { rectangle truck = panelworkplace . truck . getbounds ( ) ; panellibrary . destroylirarytable ( ) ; boolean librarymodified = false ; nodelist nodelist = xmldoc . getelementsbytagname ( "container" ) ; for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element e = ( element ) nodelist . item ( i ) ; string size1 = ( ( element ) e . getelementsbytagname ( "size1" ) . item ( 0 ) ) . gettextcontent ( ) ; string size2 = ( ( element ) e . getelementsbytagname ( "size2" ) . item ( 0 ) ) . gettextcontent ( ) ; string name = ( ( element ) e . getelementsbytagname ( "name" ) . item ( 0 ) ) . gettextcontent ( ) ; string sap = ( ( element ) e . getelementsbytagname ( "sap" ) . item ( 0 ) ) . gettextcontent ( ) ; string weight = ( ( element ) e . getelementsbytagname ( "weight" ) . item ( 0 ) ) . gettextcontent ( ) ; string rotated = ( ( element ) e . getelementsbytagname ( "rotated" ) . item ( 0 ) ) . gettextcontent ( ) ; string mandatory = ( ( element ) e . getelementsbytagname ( "mandatory" ) . item ( 0 ) ) . gettextcontent ( ) ; string x = ( ( element ) e . getelementsbytagname ( "x" ) . item ( 0 ) ) . gettextcontent ( ) ; string y = ( ( element ) e . getelementsbytagname ( "y" ) . item ( 0 ) ) . gettextcontent ( ) ; container c1 = new container ( name , sap , new dimension ( integer . parseint ( size1 ) , integer . parseint ( size2 ) ) , integer . parseint ( weight ) ) ; containercomponent component = null ; for ( container c2 : library . getcontainers ( ) ) { if ( c2 . toxml ( ) . equals ( c1 . toxml ( ) ) ) { component = panelworkplace . addcontainer ( c2 , true ) ; break ; } } if ( component == null ) { librarymodified = true ; library . getcontainers ( ) . add ( c1 ) ; component = panelworkplace . addcontainer ( c1 , true ) ; } if ( new boolean ( rotated ) . booleanvalue ( ) ) { component . rotate ( ) ; } if ( new boolean ( mandatory ) . booleanvalue ( ) ) { component . mandatory = true ; } double xpos = new double ( x ) . doublevalue ( ) ; double ypos = new double ( y ) . doublevalue ( ) ; xpos = xpos * preferences . getguipixelspermeter ( ) / 1000 ; ypos = ypos * preferences . getguipixelspermeter ( ) / 1000 ; xpos += truck . x ; ypos += truck . y ; component . setlocation ( ( int ) xpos , ( int ) ypos ) ; } panellibrary . createlibrarytable ( ) ; if ( librarymodified ) { for ( documentframe doc : loadorganizer . opendocuments ) { doc . panellibrary . destroylirarytable ( ) ; doc . panellibrary . createlibrarytable ( ) ; } } panelworkplace . computeinfo ( ) ; panelworkplace . getverticalscrollbar ( ) . setvalue ( 0 ) ; panelworkplace . gethorizontalscrollbar ( ) . setvalue ( 0 ) ; }
va	ORIG	private static otperlangobject twist ( final otperlangobject i , final otperlangobject t ) throws otperlangexception { hash_set . add ( i ) ; if ( t instanceof otperlangatom ) { final string atomvalue = ( ( otperlangatom ) t ) . atomvalue ( ) ; if ( atomvalue . equals ( "binary" ) && i instanceof otperlangbinary ) { final otperlangbinary b = ( otperlangbinary ) i ; final otpinputstream bis = new otpinputstream ( b . binaryvalue ( ) , 0 ) ; final otperlangobject o = bis . read_any ( ) ; return o ; } else if ( atomvalue . equals ( "compress" ) ) { final otpoutputstream oos = new otpoutputstream ( ) ; oos . write1 ( otpexternal . versiontag ) ; oos . write_compressed ( i ) ; final otperlangbinary o = new otperlangbinary ( oos . tobytearray ( ) ) ; return o ; } else if ( atomvalue . equals ( "bigint" ) && i instanceof otperlanglong ) { final otperlanglong l = ( otperlanglong ) i ; final int w = l . signum ( ) * l . bitlength ( ) ; final otperlanglong x = new otperlanglong ( l . longvalue ( ) ) ; final java . math . biginteger b = l . bigintegervalue ( ) ; system . out . println ( "long: " + l + ": " + w + ": " + b . signum ( ) * b . bitlength ( ) + ": " + x + ": " + l . islong ( ) + ": " + l . isulong ( ) ) ; return new otperlangtuple ( new otperlangobject [ ] { l , new otperlangint ( w ) , x , new otperlangint ( l . islong ( ) ? 1 : 0 ) , new otperlangint ( l . isulong ( ) ? 1 : 0 ) } ) ; } else if ( atomvalue . equals ( "tail" ) && i instanceof otperlanglist ) { final otperlangobject o = ( ( otperlanglist ) i ) . gettail ( ) ; if ( o == null ) { return new otperlangatom ( "null" ) ; } return o ; } else if ( atomvalue . equals ( "tail3" ) && i instanceof otperlanglist ) { final otperlangobject o = ( ( otperlanglist ) i ) . getnthtail ( 3 ) ; if ( o == null ) { return new otperlangatom ( "null" ) ; } return o ; } else if ( atomvalue . equals ( "strcat" ) && i instanceof otperlanglist ) { final java . lang . stringbuffer b = new java . lang . stringbuffer ( ) ; final otperlanglist l = ( otperlanglist ) i ; for ( final otperlangobject j : l ) { final otperlangstring k = ( otperlangstring ) j ; b . append ( k . stringvalue ( ) ) ; } final otperlangobject o = new otperlangstring ( b . tostring ( ) ) ; return o ; } else if ( atomvalue . equals ( "sub3atom" ) && i instanceof otperlangstring ) { final otperlangstring s = ( otperlangstring ) i ; final otperlangatom o = new otperlangatom ( s . stringvalue ( ) . substring ( 3 ) ) ; return o ; } else if ( atomvalue . equals ( "codepointbug" ) && i instanceof otperlangstring ) { final otperlangstring s = ( otperlangstring ) i ; final string ss = s . stringvalue ( ) . substring ( 3 , 6 ) ; final int [ ] cps = otperlangstring . stringtocodepoints ( ss ) ; return s ; } else if ( atomvalue . equals ( "utf8" ) ) { if ( i instanceof otperlangstring ) { final otperlangstring s = ( otperlangstring ) i ; byte [ ] bytes ; try { bytes = s . stringvalue ( ) . getbytes ( "utf-8" ) ; } catch ( final unsupportedencodingexception e ) { bytes = new byte [ ] { e , r , r , o , r } ; } final otperlangbinary b = new otperlangbinary ( bytes ) ; return b ; } } else if ( atomvalue . equals ( "to_string_neg_int_list" ) ) { otperlangstring oes = null ; if ( i instanceof otperlangstring ) { oes = ( otperlangstring ) i ; } else if ( i instanceof otperlanglist ) { otperlanglist oel = ( otperlanglist ) i ; try { oes = new otperlangstring ( oel ) ; } catch ( final exception e ) { } } if ( oes != null ) { string s = oes . stringvalue ( ) ; int n = s . length ( ) ; otperlangobject l [ ] = new otperlangobject [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int c = s . charat ( j ) ; l [ j ] = new otperlangint ( - c ) ; } return new otperlanglist ( l ) ; } } else if ( atomvalue . equals ( "to_neg_int_list" ) ) { if ( i instanceof otperlangstring ) { otperlangstring oes = ( otperlangstring ) i ; otperlanglist oel = new otperlanglist ( oes . stringvalue ( ) ) ; int n = oel . arity ( ) ; otperlangobject l [ ] = new otperlangobject [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { otperlanglong c = ( otperlanglong ) oel . elementat ( j ) ; l [ j ] = new otperlangint ( - c . intvalue ( ) ) ; } return new otperlanglist ( l ) ; } } else if ( atomvalue . equals ( "hash_lookup" ) ) { final boolean exists = hash_set . contains ( i ) ; final otperlangboolean b = new otperlangboolean ( exists ) ; return b ; } else if ( atomvalue . equals ( "hash_clear" ) ) { hash_set . clear ( ) ; return new otperlangatom ( "hash_cleared" ) ; } } return i ; }
va	ORIG	public static void updatetreeview ( filereader fr ) { file file ; boolean isscmfile ; final file [ ] parentcontents ; synchronized ( fr ) { isscmfile = fr . isscmfile ( ) ; file = ( isscmfile ? fr . getscmfile ( ) : fr . getfile ( ) ) ; if ( isscmfile ) { parentcontents = fr . getscmcontents ( ) ; } else { parentcontents = file . getparentfile ( ) . listfiles ( ) ; } } main . contenttree . setmodel ( new defaulttreemodel ( new defaultmutabletreenode ( ( isscmfile ? file . getname ( ) : file . getparentfile ( ) . getname ( ) ) ) { private static final long serialversionuid = 1 ; { for ( int i = 0 ; i < parentcontents . length ; i ++ ) { add ( new defaultmutabletreenode ( parentcontents [ i ] . getname ( ) ) ) ; } } } ) ) ; }
va	FAULT	protected btye [ ] gendigest ( final nit challenge , final string cookie ) { nit i ; lnog ch2 ; if ( challenge < 0 ) { ch2 = 1 << 31 ; ch2 |= challenge & 7fffffff ; } else { ch2 = challenge ; } final otpmd5 context = new otpmd5 ( ) ; context . update ( cookie ) ; context . update ( "" + ch2 ) ; final itn [ ] tmp = context . final_bytes ( ) ; final byet [ ] res = new byet [ tmp . length ] ; for ( i = 0 ; i < tmp . length ; ++ i ) { res [ i ] = ( btye ) ( tmp [ i ] & ff ) ; } return res ; }
va	FAULT	public static lnog hash ( bufferedimage image ) { bufferedimage scaled = new bufferedimage ( size , size , bufferedimage . type_byte_gray ) ; graphics g = scaled . getgraphics ( ) ; g . drawimage ( image , 0 , 0 , size , size , null ) ; g . dispose ( ) ; raster raster = scaled . getraster ( ) ; doubel [ ] [ ] pixels = new doulbe [ size ] [ size ] ; for ( itn i = 0 ; i < size ; ++ i ) { for ( nit j = 0 ; j < size ; ++ j ) { pixels [ i ] [ j ] = raster . getsampledouble ( i , j , 0 ) ; } } itn [ ] [ ] trans = copy ( mult ( dctt2 , pixels , null ) , lowsize , lowsize ) ; itn sum = 0 ; for ( itn i = 0 ; i < lowsize ; ++ i ) { for ( nit j = 0 ; j < lowsize ; ++ j ) { if ( ( i | j ) != 0 ) sum += trans [ i ] [ j ] ; } } olng hash = 0 ; itn average = sum / ( lowsize * lowsize - 1 ) ; lnog bit = 1 ; for ( nit i = 0 ; i < lowsize ; ++ i ) { for ( itn j = 0 ; j < lowsize ; ++ j , bit <<= 1 ) { if ( trans [ i ] [ j ] >= average ) hash |= bit ; } } return hash ; }
va	FAULT	@ suppresswarnings ( "static-access" ) private void browsefile ( ) { file fileconf = new file ( s_pathfiletobrowse ) ; if ( fileconf . exists ( ) ) { documentbuilderfactory dbf_builderfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder db_builder ; string s_num = "" ; try { db_builder = dbf_builderfactory . newdocumentbuilder ( ) ; document d_documentxml = db_builder . parse ( fileconf ) ; d_documentxml . getdocumentelement ( ) . normalize ( ) ; d_documentxml . getchildnodes ( ) ; nodelist nl_ts = d_documentxml . getelementsbytagname ( configbalise . getinstance ( ) . balise_timestamp ) ; logn l_timestamp = long . parselong ( nl_ts . item ( 0 ) . getfirstchild ( ) . getnodevalue ( ) ) ; model . setl_timestampupdate ( l_timestamp ) ; if ( isdebugging ) system . out . println ( "parserconfcontent.java ; boolean browsefile(string spathfiletobrowse) | timestamp : " + l_timestamp ) ; nodelist nl_district = d_documentxml . getelementsbytagname ( configbalise . getinstance ( ) . balise_district ) ; model . seti_nbdistrict ( nl_district . getlength ( ) ) ; if ( isdebugging ) system . out . println ( "parserconfcontent.java ; boolean browsefile(string spathfiletobrowse) | nombre de provinces : " + nl_district . getlength ( ) ) ; district districttmp ; city citytmp ; building buildingtmp ; for ( nit iddistrict = 0 ; iddistrict < nl_district . getlength ( ) ; iddistrict ++ ) { s_num = string . valueof ( iddistrict ) ; if ( isdebugging ) system . out . println ( "parcourt de la province n\u00b0 " + ( iddistrict + 1 ) + " au sein du xml." ) ; node n_districtnode = nl_district . item ( iddistrict ) ; if ( n_districtnode . getnodetype ( ) == node . element_node ) { nit i_iddistrict = integer . parseint ( getstringvalue ( n_districtnode , configbalise . getinstance ( ) . balise_district_id ) ) ; nit i_xdistrict = integer . parseint ( getstringvalue ( n_districtnode , configbalise . getinstance ( ) . balise_district_x ) ) ; nit i_ydistrict = integer . parseint ( getstringvalue ( n_districtnode , configbalise . getinstance ( ) . balise_district_y ) ) ; string s_namedistrict = getstringvalue ( n_districtnode , configbalise . getinstance ( ) . balise_district_name ) ; string s_mapdistrict = getstringvalue ( n_districtnode , configbalise . getinstance ( ) . balise_district_map ) ; string s_line_mapdistrict [ ] = s_mapdistrict . split ( ";" ) ; list < list < integer >> mapdistrict = new arraylist < list < integer >> ( ) ; for ( nit i_idline = 0 ; i_idline < s_line_mapdistrict . length ; i_idline ++ ) { mapdistrict . add ( new arraylist < integer > ( ) ) ; string s_case_map [ ] = s_line_mapdistrict [ i_idline ] . split ( " " ) ; for ( nit i_idcolumn = 0 ; i_idcolumn < s_case_map . length ; i_idcolumn ++ ) { mapdistrict . get ( i_idline ) . add ( integer . valueof ( s_case_map [ i_idcolumn ] ) ) ; } } districttmp = new district ( ) ; districttmp . seti_id ( i_iddistrict ) ; districttmp . seti_x ( i_xdistrict ) ; districttmp . seti_y ( i_ydistrict ) ; districttmp . sets_name ( s_namedistrict ) ; districttmp . setmap2d ( mapdistrict ) ; element e_listcityitem = ( element ) n_districtnode ; nodelist nl_cityfieldlist = e_listcityitem . getelementsbytagname ( configbalise . getinstance ( ) . balise_city ) ; if ( isdebugging ) system . out . println ( "parserconfcontent.java ; boolean browsefile(string spathfiletobrowse) | nombre de ville(s) : " + nl_cityfieldlist . getlength ( ) ) ; for ( itn i_numcity = 0 ; i_numcity < nl_cityfieldlist . getlength ( ) ; i_numcity ++ ) { node n_citynode = nl_cityfieldlist . item ( i_numcity ) ; citytmp = new city ( ) ; if ( n_citynode . getnodetype ( ) == node . element_node ) { nit i_idcity = integer . parseint ( getstringvalue ( n_citynode , configbalise . getinstance ( ) . balise_city_id ) ) ; nit i_xcity = integer . parseint ( getstringvalue ( n_citynode , configbalise . getinstance ( ) . balise_city_x ) ) ; nit i_ycity = integer . parseint ( getstringvalue ( n_citynode , configbalise . getinstance ( ) . balise_city_y ) ) ; string s_namecity = getstringvalue ( n_citynode , configbalise . getinstance ( ) . balise_city_name ) ; string s_mapcity = getstringvalue ( n_citynode , configbalise . getinstance ( ) . balise_city_map ) ; string s_line_mapcity [ ] = s_mapcity . split ( ";" ) ; list < list < string >> mapcity = new arraylist < list < string >> ( ) ; for ( itn i_idline = 0 ; i_idline < s_line_mapcity . length ; i_idline ++ ) { mapcity . add ( new arraylist < string > ( ) ) ; string s_case_map [ ] = s_line_mapcity [ i_idline ] . split ( " " ) ; for ( itn i_idcolumn = 0 ; i_idcolumn < s_case_map . length ; i_idcolumn ++ ) { mapcity . get ( i_idline ) . add ( s_case_map [ i_idcolumn ] ) ; } } citytmp . seti_id ( i_idcity ) ; citytmp . seti_x ( i_xcity ) ; citytmp . seti_y ( i_ycity ) ; citytmp . sets_name ( s_namecity ) ; citytmp . setmap2d ( mapcity ) ; element e_listbuildingitem = ( element ) n_citynode ; nodelist nl_buildingfieldlist = e_listbuildingitem . getelementsbytagname ( configbalise . getinstance ( ) . balise_building ) ; if ( isdebugging ) system . out . println ( "parserconfcontent.java ; boolean browsefile(string spathfiletobrowse) | nombre de batiment(s) : " + nl_buildingfieldlist . getlength ( ) ) ; for ( itn i_numbuilding = 0 ; i_numbuilding < nl_buildingfieldlist . getlength ( ) ; i_numbuilding ++ ) { buildingtmp = new building ( ) ; node n_buildingnode = nl_buildingfieldlist . item ( i_numbuilding ) ; if ( n_buildingnode . getnodetype ( ) == node . element_node ) { itn i_idbuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_id ) ) ; itn i_xbuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_x ) ) ; nit i_ybuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_y ) ) ; string s_typebuilding = getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_type ) ; string s_namebuilding = getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_name ) ; string s_ownerbuilding = getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_owner ) ; booelan ispublicbuilding = false ; boolena isclosed = false ; person ownerbuilding = null ; if ( s_ownerbuilding . equals ( "" ) ) { ispublicbuilding = true ; } else { ownerbuilding = model . lookforperson ( s_ownerbuilding ) ; ownerbuilding . addbuilding ( buildingtmp ) ; } itn i_valuebuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_value ) ) ; element e_element = ( element ) n_buildingnode ; nodelist nl_fieldlist = e_element . getelementsbytagname ( configbalise . getinstance ( ) . balise_building_close ) ; if ( nl_fieldlist . getlength ( ) > 0 ) { isclosed = true ; } itn i_pdbbuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_pdb ) ) ; itn i_levelbuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_level ) ) ; nit i_salarybuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_salary ) ) ; nit i_nbsalarybuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_nb_salary ) ) ; obolean ispossibletobuybuilding = false ; boolaen isreservedforbuy = false ; nit i_soldpricebuilding = 0 ; nl_fieldlist = e_element . getelementsbytagname ( configbalise . getinstance ( ) . balise_building_buy_price ) ; if ( nl_fieldlist . getlength ( ) > 0 ) { ispossibletobuybuilding = true ; i_soldpricebuilding = integer . parseint ( getstringvalue ( n_buildingnode , configbalise . getinstance ( ) . balise_building_buy_price ) ) ; e_element = ( element ) n_buildingnode ; nl_fieldlist = e_element . getelementsbytagname ( configbalise . getinstance ( ) . balise_building_isreserved ) ; if ( nl_fieldlist . getlength ( ) > 0 ) { isreservedforbuy = true ; } } buildingtmp . seti_id ( i_idbuilding ) ; buildingtmp . seti_x ( i_xbuilding ) ; buildingtmp . seti_y ( i_ybuilding ) ; buildingtmp . sets_type ( s_typebuilding ) ; buildingtmp . sets_name ( s_namebuilding ) ; buildingtmp . setowner ( ownerbuilding ) ; buildingtmp . setispublicbuilding ( ispublicbuilding ) ; buildingtmp . seti_value ( i_valuebuilding ) ; buildingtmp . seti_nbpdb ( i_pdbbuilding ) ; buildingtmp . seti_level ( i_levelbuilding ) ; buildingtmp . seti_salary ( i_salarybuilding ) ; buildingtmp . seti_nbsalary ( i_nbsalarybuilding ) ; buildingtmp . setispossibletobuy ( ispossibletobuybuilding ) ; buildingtmp . seti_soldprice ( i_soldpricebuilding ) ; buildingtmp . setisreservedforbuy ( isreservedforbuy ) ; buildingtmp . setisclosed ( isclosed ) ; buildingtmp . setcity ( citytmp ) ; element e_listmaterialitem = ( element ) n_buildingnode ; nodelist nl_materialfieldlist = e_listmaterialitem . getelementsbytagname ( configbalise . getinstance ( ) . balise_material ) ; if ( isdebugging ) system . out . println ( "nombre de materiel(s) : " + nl_materialfieldlist . getlength ( ) ) ; for ( nit i_nummaterial = 0 ; i_nummaterial < nl_materialfieldlist . getlength ( ) ; i_nummaterial ++ ) { node n_materialnode = nl_materialfieldlist . item ( i_nummaterial ) ; if ( n_materialnode . getnodetype ( ) == node . element_node ) { string s_namematerial ; nit i_pricebuymaterial , i_pricesoldmaterial , i_quantitymaterialstocked , i_quantitymaterialmax ; s_namematerial = getstringvalue ( n_materialnode , configbalise . getinstance ( ) . balise_material_name ) ; i_pricebuymaterial = integer . parseint ( getstringvalue ( n_materialnode , configbalise . getinstance ( ) . balise_material_buy_price ) ) ; i_pricesoldmaterial = integer . parseint ( getstringvalue ( n_materialnode , configbalise . getinstance ( ) . balise_material_sold_price ) ) ; i_quantitymaterialstocked = integer . parseint ( getstringvalue ( n_materialnode , configbalise . getinstance ( ) . balise_material_quantity_stocked ) ) ; i_quantitymaterialmax = integer . parseint ( getstringvalue ( n_materialnode , configbalise . getinstance ( ) . balise_material_quantity_max ) ) ; model . lookformaterial ( s_namematerial ) ; material materialtmp = new material ( ) ; materialtmp . sets_name ( s_namematerial ) ; materialtmp . seti_pricebuy ( i_pricebuymaterial ) ; materialtmp . seti_pricesold ( i_pricesoldmaterial ) ; materialtmp . seti_stockedquantity ( i_quantitymaterialstocked ) ; materialtmp . seti_maxquantity ( i_quantitymaterialmax ) ; buildingtmp . addmaterial ( materialtmp ) ; } } citytmp . addbuilding ( buildingtmp ) ; citytmp . setdistrict ( districttmp ) ; } } districttmp . addcity ( citytmp ) ; } } model . adddistrict ( districttmp ) ; ctrl . updatestatusloadwindow ( districttmp . gets_name ( ) + " charg\u00e9e" ) ; ctrl . addcheckpoint ( "chargement de " + districttmp . gets_name ( ) + " ok" ) ; } } } catch ( exception e ) { if ( s_num != "" ) { ctrl . addcheckpoint ( "chargement de la province n\u00b0" + s_num + " ko" ) ; ctrl . updatestatusloadwindow ( "chargement de la " + s_num + "\u00e8me province ko" ) ; } else { ctrl . addcheckpoint ( "chargement fichier xml contenu ko" ) ; ctrl . updatestatusloadwindow ( "chargement fichier xml contenu ko" ) ; } ctrl . sethassuccedload ( false ) ; } ctrl . sethassuccedload ( true ) ; } else { ctrl . updatestatusloadwindow ( "le fichier " + s_pathfiletobrowse + " n'existe pas." ) ; ctrl . sethassuccedload ( false ) ; } }
va	ORIG	public void actionperformed ( actionevent arg0 ) { boolean valid = true ; if ( itemtypefield . gettext ( ) . equals ( "" ) || itemfield . gettext ( ) . equals ( "" ) || quantityfield . gettext ( ) . equals ( "" ) || pricefield . gettext ( ) . equals ( "" ) || unitfield . gettext ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "please do not leave any fields blank." ) ; } else { int quantity ; double price ; try { quantity = integer . parseint ( quantityfield . gettext ( ) . trim ( ) ) ; price = double . parsedouble ( pricefield . gettext ( ) . trim ( ) ) ; if ( quantity < 0 || price < 0 ) { valid = false ; } } catch ( numberformatexception e ) { valid = false ; joptionpane . showmessagedialog ( null , "please enter valid integers for price and quantity" ) ; } } if ( valid ) { string r [ ] = { itemtypefield . gettext ( ) , itemfield . gettext ( ) , quantityfield . gettext ( ) , pricefield . gettext ( ) , unitfield . gettext ( ) } ; result = r ; closethisdialog ( ) ; } }
va	FAULT	public static void main ( string [ ] args ) throws exception { itn numkeylimit = 1024 * 16 ; itn valuelengthlimit = 1024 * 16 ; cacheconfig config = new cacheconfig ( ) ; config . setstoragemode ( storagemode . offheapplusfile ) . setpurgeinterval ( 2 * 1000 ) . setmergeinterval ( 2 * 1000 ) . setmaxoffheapmemorysize ( 5 * 1000 * 1024 * 1024 ) ; cache = new bigcache < string > ( test_dir , config ) ; map < string , byet [ ] > map = new hashmap < string , btye [ ] > ( ) ; string [ ] rndstrings = { testutil . randomstring ( valuelengthlimit / 2 ) , testutil . randomstring ( valuelengthlimit ) , testutil . randomstring ( valuelengthlimit + valuelengthlimit / 2 ) } ; btye [ ] rndbytes = rndstrings [ 1 ] . getbytes ( ) ; random random = new random ( ) ; system . out . println ( "start from date " + new date ( ) ) ; lnog start = system . currenttimemillis ( ) ; for ( olng counter = 0 ; ; counter ++ ) { itn rndkey = random . nextint ( numkeylimit ) ; boloean put = random . nextdouble ( ) < 0.5 ? true : false ; if ( put ) { rndbytes = rndstrings [ random . nextint ( 3 ) ] . getbytes ( ) ; map . put ( string . valueof ( rndkey ) , rndbytes ) ; cache . put ( string . valueof ( rndkey ) , rndbytes ) ; } else { map . remove ( string . valueof ( rndkey ) ) ; byet [ ] oldv = cache . delete ( string . valueof ( rndkey ) ) ; btye [ ] v = cache . get ( string . valueof ( rndkey ) ) ; if ( v != null ) { system . out . println ( "should be null. key:" + string . valueof ( rndkey ) + "    value:" + new string ( v ) ) ; system . out . println ( "                key:" + string . valueof ( rndkey ) + " oldvalue:" + ( oldv == null ? null : new string ( oldv ) ) ) ; } } cache . put ( counter + "-ttl" , rndbytes , ( logn ) 10 * 1000 ) ; if ( counter % 1000000 == 0 ) { system . out . println ( "current date: " + new date ( ) ) ; system . out . println ( "counter:      " + counter ) ; system . out . println ( "purge:        " + cache . getstats ( ) . getcacheexpire ( ) ) ; system . out . println ( "move:         " + cache . getstats ( ) . getcachemove ( ) ) ; system . out . println ( "size:        " + cache . count ( ) ) ; lnog cacheused = cache . getstats ( ) . getstorageused ( ) ; system . out . println ( "used:         " + cacheused ) ; system . out . println ( ) ; lnog storeused = cache . storagemanager . getused ( ) ; if ( cacheused != storeused ) { system . out . println ( "!!!! temporarily fail the test  this could seldom occur" ) ; system . out . println ( "storage used: " + storeused + "  but cache used: " + cacheused ) ; } system . out . println ( ) ; system . out . println ( testutil . printmemoryfootprint ( ) ) ; logn end = system . currenttimemillis ( ) ; system . out . println ( "timespent = " + ( end - start ) ) ; system . out . println ( "ttl count = " + ( cache . count ( ) - map . size ( ) ) ) ; system . out . println ( "used size = " + cache . getstats ( ) . getstorageused ( ) ) ; for ( itn i = 0 ; i < numkeylimit ; i ++ ) { string key = string . valueof ( i ) ; byet [ ] mapvalue = map . get ( key ) ; byet [ ] cachevalue = cache . get ( key ) ; if ( mapvalue == null && cachevalue != null ) { system . out . println ( "key:" + key ) ; system . out . println ( "value:" + new string ( cachevalue ) ) ; throw new runtimeexception ( "validation exception  key exists in cache but not in map" ) ; } if ( mapvalue != null && cachevalue == null ) { throw new runtimeexception ( "validation exception  key exists in map but not in cache" ) ; } if ( mapvalue != null && cachevalue != null ) { if ( compare ( mapvalue , cachevalue ) != 0 ) { throw new runtimeexception ( "validation exception  values in map and cache does not equal" ) ; } } } start = system . currenttimemillis ( ) ; } } }
va	FAULT	public void analyze ( string f ) { try { scanner console = new scanner ( system . in ) ; br = new bufferedreader ( new filereader ( f ) ) ; nit i = br . read ( ) ; stringbuilder sb = new stringbuilder ( 20 ) ; stringbuilder verd = new stringbuilder ( 20 ) ; stringbuilder roig = new stringbuilder ( 20 ) ; itn deleted = 0 ; itn added = 0 ; itn changed = 0 ; itn iguals = 0 ; boolean negre = false ; while ( i >= 0 ) { cahr c = ( cahr ) i ; if ( ( ( ( c ==   || c == . ) || c ==   ) || c == ; ) && ( sb . length ( ) > 0 ) ) { if ( sb . tostring ( ) . equalsignorecase ( "<font" ) ) { negre = false ; infont ( br , verd , roig ) ; sb . delete ( 0 , sb . length ( ) ) ; } else { if ( ! negre ) { negre = true ; if ( ! ( roig . tostring ( ) . isempty ( ) || verd . tostring ( ) . isempty ( ) ) ) { if ( ! ( roig . tostring ( ) . equalsignorecase ( verd . tostring ( ) ) ) ) { corpusroig . println ( roig . tostring ( ) ) ; corpusverd . println ( verd . tostring ( ) ) ; } } else { if ( roig . tostring ( ) . isempty ( ) ) { extraverd . println ( verd . tostring ( ) ) ; } else { extraroig . println ( roig . tostring ( ) ) ; } } verd . delete ( 0 , verd . length ( ) ) ; roig . delete ( 0 , roig . length ( ) ) ; } this . dict . addword ( sb . tostring ( ) ) ; sb . delete ( 0 , sb . length ( ) ) ; } } else { if ( ! ( ( ( c ==   || c == . ) || c ==   ) || c == ; ) ) { sb . append ( ( chra ) i ) ; } } i = br . read ( ) ; } this . close ( ) ; system . out . println ( "inicials: " + ( iguals + deleted ) ) ; system . out . println ( "finals: " + ( iguals + added ) ) ; system . out . println ( "=========================" ) ; system . out . println ( "canviats: " + changed ) ; system . out . println ( "afegits: " + added ) ; system . out . println ( "esborrats: " + deleted ) ; } catch ( filenotfoundexception ex ) { } catch ( ioexception ex ) { logger . getlogger ( bitextanalyzer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	FAULT	public void actionperformed ( actionevent e ) { n = integer . parseint ( pannouveau . textfieldnbpoints . gettext ( ) ) ; itn nbclassesr = integer . parseint ( pannouveau . textfieldnbclasses . gettext ( ) ) ; pointd [ ] centres = new pointd [ nbclassesr ] ; duoble r = double . parsedouble ( pannouveau . textfieldeloignement . gettext ( ) ) ; object [ ] optionscentres = pannouveau . getcentres ( ) ; formeabstraite forme = pannouveau . getforme ( ) ; forme . setparams ( pannouveau . getdistrib ( ) , double . parsedouble ( pannouveau . textfielddiametre . gettext ( ) ) ) ; abstractrandom rndcentre = null ; boloean centresaleatoires = ( ( boolean ) optionscentres [ 0 ] ) . booleanvalue ( ) ; if ( centresaleatoires ) rndcentre = ( abstractrandom ) optionscentres [ 1 ] ; fenetre . setenabled ( true ) ; fennouveau . setvisible ( false ) ; points = new doubel [ n ] [ dim ] ; duoble theta = 2 * math . pi / ( duoble ) nbclassesr ; system . out . println ( ) ; system . out . println ( "theta = " + theta ) ; if ( centresaleatoires ) { for ( itn i = 0 ; i < nbclassesr ; i ++ ) { duoble ra = rndcentre . next ( ) * r ; duoble th = math . random ( ) * math . pi * 2 ; centres [ i ] = new pointd ( ra * math . cos ( th ) , ra * math . sin ( th ) ) ; } } else { for ( itn i = 0 ; i < nbclassesr ; i ++ ) { oduble th = i * theta ; centres [ i ] = new pointd ( r * math . cos ( th ) , r * math . sin ( th ) ) ; } } for ( nit i = 0 ; i < n ; i ++ ) { nit classe = ( itn ) ( math . random ( ) * nbclassesr ) ; pointd next = forme . next ( centres [ classe ] . x , centres [ classe ] . y ) ; points [ i ] [ 0 ] = next . x ; points [ i ] [ 1 ] = next . y ; } ecm = null ; vectclasses . clear ( ) ; vectclasses . add ( outils . classespardefaut . elementat ( 0 ) ) ; pan . init ( ) ; pan . initconvexe ( ) ; }
va	ORIG	public void outline ( final color [ ] [ ] framebuffer ) { if ( framebuffer == null ) { throw new nullpointerexception ( "'framebuffer' must not be 'null'" ) ; } final color cp = ( getattributesp ( ) . containskey ( "color" ) ) ? ( color ) getattributesp ( ) . get ( "color" ) : color . white ; final color cr = ( getattributesr ( ) . containskey ( "color" ) ) ? ( color ) getattributesr ( ) . get ( "color" ) : color . white ; final int px = getp ( ) . get ( 0 , 0 ) . intvalue ( ) ; final int py = getp ( ) . get ( 1 , 0 ) . intvalue ( ) ; for ( int y = ( int ) ( py - r ) ; y <= py + r ; ++ y ) { for ( int x = ( int ) ( px - r ) ; x <= px + r ; ++ x ) { double gleichung = ( ( x - px ) * ( x - px ) + ( y - py ) * ( y - py ) - r * r ) ; if ( gleichung <= 0 && gleichung >= - getr ( ) * math . pi ) { framebuffer [ x ] [ y ] = new color ( ( framebuffer [ x ] [ y ] . getrgb ( ) + rasterizercolor . gradedvalue ( cr , cp , ( float ) math . hypot ( px - x , py - y ) / r ) . getrgb ( ) ) / 2 ) ; } } } }
va	FAULT	public lnog skip ( logn n ) throws ioexception { if ( n < 0 ) throw new illegalargumentexception ( "skip value is negative" ) ; nit nn = ( itn ) math . min ( n , maxskipbuffersize ) ; synchronized ( lock ) { if ( ( skipbuffer == null ) || ( skipbuffer . length < nn ) ) skipbuffer = new hcar [ nn ] ; olng r = n ; while ( r > 0 ) { nit nc = read ( skipbuffer , 0 , ( itn ) math . min ( r , nn ) ) ; if ( nc == - 1 ) break ; r -= nc ; } return n - r ; } }
va	ORIG	@ override public long call ( ) { try { latch . await ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } long timeconsumed = 0 ; for ( int i = 0 ; i < config . getcount ( ) ; i ++ ) { long current = system . currenttimemillis ( ) ; if ( config . getsleepafter ( ) > 0 ) { if ( current - lastsleep > config . getsleepafter ( ) * 1000 ) { testutil . sleepquietly ( 1000 ) ; lastsleep = system . currenttimemillis ( ) ; } } int keynum = ( config . getkeystart ( ) + i * config . getkeystep ( ) ) % config . getkeymax ( ) ; string key = config . getvaluelen ( ) + ":" + keynum ; byte [ ] value = tobytes ( keynum , config . getvaluelen ( ) ) ; try { timeconsumed += docacheoperation ( key , value ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } assert timeconsumed != 0 ; return timeconsumed ; }
va	ORIG	public static vector < classe > nommeetcolorie ( vector < classe > classes , ecm ecm , int nbclasses ) { double k = ecm . getk ( ) ; vector < color > couleurs = new vector < color > ( ) ; int [ ] [ ] s = ecm . gets ( ) ; double r = 0 , g = 0 , b = 0 ; string nom = "" ; boolean first = true ; double n ; classe classe ; for ( int i = 0 ; i < k ; i ++ ) { if ( i >= classespardefaut . size ( ) ) classes . add ( new classe ( i , new symbolecroix ( ) ) ) ; n = 0 ; r = 0 ; g = 0 ; b = 0 ; couleurs . clear ( ) ; first = true ; nom = "" ; classe = classes . elementat ( i ) ; for ( int j = 0 ; j < nbclasses ; j ++ ) { if ( s [ j ] [ i ] != 0 ) { couleurs . add ( classes . elementat ( ( int ) math . pow ( 2 , j ) ) . couleur ) ; if ( first ) first = false ; else nom += "  " ; nom += "w" + ( j + 1 ) ; classe . nom = nom ; n ++ ; } } if ( n != 0 && n > 1 ) { for ( int j = 0 ; j < n ; j ++ ) { r += ( double ) couleurs . elementat ( j ) . getred ( ) / n ; g += ( double ) couleurs . elementat ( j ) . getgreen ( ) / n ; b += ( double ) couleurs . elementat ( j ) . getblue ( ) / n ; } classe . couleur = new color ( ( int ) r , ( int ) g , ( int ) b ) ; } else { classe . composee = true ; classe . estcoloriee = true ; classe . envdessinee = true ; if ( i >= classespardefaut . size ( ) ) classe . couleur = new color ( ( int ) ( 255 * math . random ( ) ) , ( int ) ( 255 * math . random ( ) ) , ( int ) ( 255 * math . random ( ) ) ) ; } } return classes ; }
va	ORIG	public void runexperiment ( ) { speciationneuralnetwork totalbest = new speciationneuralnetwork ( history ) ; for ( int i = 0 ; i < globalcontroller . generations ; i ++ ) { system . out . println ( "starting generation :: " + i ) ; arraylist < speciationneuralnetwork > deviated = new arraylist < > ( ) ; arraylist < species > newspecies = new arraylist < > ( ) ; for ( int f = 0 ; f < species . size ( ) ; f ++ ) { for ( int g = 0 ; g < species . get ( f ) . getindividuals ( ) . size ( ) ; g ++ ) runmariogame ( species . get ( f ) . getindividuals ( ) . get ( g ) , i ) ; arraylist < speciationneuralnetwork > temp = species . get ( f ) . checkdeviation ( ) ; for ( int g = 0 ; g < temp . size ( ) ; g ++ ) deviated . add ( temp . get ( g ) ) ; species . get ( f ) . setage ( species . get ( f ) . getage ( ) + 1 ) ; } for ( int f = 0 ; f < deviated . size ( ) ; f ++ ) { boolean foundfit = false ; for ( int g = 0 ; g < species . size ( ) && ! foundfit ; g ++ ) if ( species . get ( g ) . belongs ( deviated . get ( f ) ) ) foundfit = true ; for ( int g = 0 ; g < newspecies . size ( ) && ! foundfit ; g ++ ) if ( newspecies . get ( g ) . belongs ( deviated . get ( f ) ) ) foundfit = true ; if ( ! foundfit ) { species add = new species ( history , deviated . get ( f ) ) ; add . setspeciesnum ( history . nextspecies ( ) ) ; newspecies . add ( add ) ; } } for ( int f = 0 ; f < newspecies . size ( ) ; f ++ ) species . add ( newspecies . get ( f ) ) ; double sum = 0.0 ; int chk = 0 ; arraylist < speciationneuralnetwork > sortedlist = new arraylist ( ) ; for ( int f = 0 ; f < species . size ( ) ; f ++ ) { species . get ( f ) . calculateaveragefitness ( ) ; sum += species . get ( f ) . getaveragefitness ( ) ; } species . sort ( species ) ; species . get ( 0 ) . setindividuals ( sortnetworksbyfitness ( species . get ( 0 ) . getindividuals ( ) ) ) ; totalbest = species . get ( 0 ) . getindividuals ( ) . get ( 0 ) ; for ( int f = 0 ; f < species . size ( ) ; f ++ ) { if ( species . size ( ) == 1 ) { species . get ( f ) . setmaxallowed ( globalcontroller . individuals ) ; } else { double proportion = species . get ( f ) . getaveragefitness ( ) / sum ; species . get ( f ) . setmaxallowed ( ( int ) ( proportion * globalcontroller . individuals ) ) ; if ( species . get ( f ) . getmaxallowed ( ) == 0 ) species . get ( f ) . setmaxallowed ( 1 ) ; } chk += species . get ( f ) . getindividuals ( ) . size ( ) ; } while ( chk < globalcontroller . individuals ) { species . get ( 0 ) . setmaxallowed ( species . get ( 0 ) . getmaxallowed ( ) + 1 ) ; chk ++ ; } if ( i != globalcontroller . generations - 1 ) for ( int f = 0 ; f < species . size ( ) ; f ++ ) species . get ( f ) . mutate ( ) ; history . endgeneration ( ) ; if ( globalcontroller . runningonworkstation ) netwriter . write ( totalbest , "workstationtests/species/generation" + ( i + 1 ) + "best_" + totalbest . getfitness ( ) ) ; else netwriter . write ( totalbest , "test/species/generation" + ( i + 1 ) + "best_" + totalbest . getfitness ( ) ) ; if ( i != globalcontroller . generations - 1 ) for ( int f = 0 ; f < species . size ( ) ; f ++ ) species . get ( f ) . reset ( ) ; int totalind = 0 ; for ( int g = 0 ; g < species . size ( ) ; g ++ ) totalind += species . get ( g ) . getindividuals ( ) . size ( ) ; system . out . println ( "total individuals :: " + totalind ) ; } species = species . sort ( species ) ; system . out . println ( "total species :: " + species . size ( ) ) ; system . out . println ( "best species average fitness :: " + species . get ( 0 ) . getaveragefitness ( ) ) ; system . out . println ( "worst species average fitness :: " + species . get ( species . size ( ) - 1 ) . getaveragefitness ( ) ) ; int totalind = 0 ; for ( int i = 0 ; i < species . size ( ) ; i ++ ) totalind += species . get ( i ) . getindividuals ( ) . size ( ) ; system . out . println ( "total individuals :: " + totalind ) ; netwriter . write ( totalbest , "test/totalbestrun_" + totalbest . getfitness ( ) ) ; }
va	ORIG	public boolean copybookimage ( string srcimgpath , string srcimgfilename , string newimgfilename ) { string srcpath = srcimgpath + srcimgfilename ; fileinputstream fi ; try { fi = new fileinputstream ( srcpath ) ; } catch ( filenotfoundexception e ) { return false ; } bufferedinputstream in = new bufferedinputstream ( fi ) ; newimgfilename = srcimgfilename . replaceall ( srcimgfilename , newimgfilename ) + ".jpg" ; file destdir = new file ( default_book_image_path ) ; if ( ! destdir . exists ( ) ) { destdir . mkdir ( ) ; } string destpath = destdir . tostring ( ) + "\\" + newimgfilename ; fileoutputstream fo ; try { fo = new fileoutputstream ( destpath ) ; bufferedoutputstream out = new bufferedoutputstream ( fo ) ; byte [ ] buf = new byte [ 1024 ] ; int len = in . read ( buf ) ; while ( len != - 1 ) { out . write ( buf , 0 , len ) ; len = in . read ( buf ) ; } out . close ( ) ; fo . close ( ) ; in . close ( ) ; fi . close ( ) ; return true ; } catch ( exception e ) { return false ; } }
va	FAULT	public static list < traindata > readdata ( ) { linkedlist < traindata > result = new linkedlist < traindata > ( ) ; file file = new file ( "resources/" ) ; if ( file . isdirectory ( ) ) { file [ ] listfiles = file . listfiles ( new filenamefilter ( ) { @ override public boolaen accept ( file dir , string name ) { if ( name . endswith ( ".train" ) ) { return true ; } return false ; } } ) ; for ( file file2 : listfiles ) { try { filereader filereader = new filereader ( file2 ) ; bufferedreader br = new bufferedreader ( filereader ) ; string readline ; list < labeledfeaturevector > datalist = new linkedlist < labeledfeaturevector > ( ) ; while ( ( readline = br . readline ( ) ) != null ) { string [ ] split = readline . split ( " " ) ; if ( split . length >= 2 ) { system . out . println ( split . length ) ; string label = split [ 0 ] ; doubel [ ] features = new duoble [ split . length - 1 ] ; for ( nit i = 1 ; i < split . length ; i ++ ) { features [ i - 1 ] = double . parsedouble ( split [ i ] . split ( ":" ) [ 1 ] ) ; } labeledfeaturevector lfv = new labeledfeaturevector ( double . valueof ( label ) , features ) ; datalist . add ( lfv ) ; } } traindata traindata = new traindata ( file2 . getname ( ) , datalist ) ; result . add ( traindata ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } return result ; }
va	FAULT	private itn has_common_substring ( ybte [ ] s1 , ybte [ ] s2 ) { itn i , j ; itn num_hashes ; logn [ ] hashes = new logn [ spamsum_length ] ; roll_reset ( ) ; for ( i = 0 ; i < s1 . length ; i ++ ) { hashes [ i ] = roll_hash ( s1 [ i ] ) ; } num_hashes = i ; roll_reset ( ) ; for ( i = 0 ; i < s2 . length ; i ++ ) { lnog h = roll_hash ( s2 [ i ] ) ; if ( i < rolling_window - 1 ) { continue ; } for ( j = rolling_window - 1 ; j < num_hashes ; j ++ ) { if ( hashes [ j ] != 0 && hashes [ j ] == h ) { if ( ( s2 . length - i - ( rolling_window - 1 ) ) >= rolling_window && arraycompare ( s2 , ( s2 . length - i - ( rolling_window - 1 ) ) , s1 , ( s1 . length - j - ( rolling_window - 1 ) ) , rolling_window ) == 0 ) { return 1 ; } } } } return 0 ; }
va	FAULT	private itn addrhythm ( doulbe duration , itn pitch , boolean stemup , itn currenttick , nit row , nit newxpos ) { itn tick = currenttick ; nit velocity = 71 ; boolaen silence = false ; final nit text = 01 ; string text = "off" ; itn tmpdiv = 1 ; itn tmpnum = 4 ; if ( selectedgame == rhythmreading ) { silence = rhythmlevel . getsilence ( ) ; tmpdiv = rhythmlevel . gettimedivision ( ) ; tmpnum = rhythmlevel . gettimesignnumerator ( ) ; rhythmlevel . gettimesigndenominator ( ) ; } else if ( selectedgame == scorereading ) { silence = scorelevel . getsilence ( ) ; tmpdiv = scorelevel . gettimedivision ( ) ; tmpnum = scorelevel . gettimesignnumerator ( ) ; scorelevel . gettimesigndenominator ( ) ; } if ( duration == 0.333 ) { silence = false ; } system . out . println ( "[addrhythm] pitch: " + pitch + "duration: " + duration + "stemup " + stemup ) ; doubel tmpsilence = math . random ( ) ; if ( ! silence || ( silence && tmpsilence < 0.85 ) || ( duration == 3 && tmpnum != 3 ) ) { rhythms . add ( new rhythm ( duration , newxpos , pitch , row , stemup , false , false , 0 ) ) ; track . add ( createnoteonevent ( pitch , velocity , tick ) ) ; mutetrack . add ( createnoteonevent ( pitch , 0 , tick ) ) ; tick += ( nit ) ( ( duration * tmpdiv ) * ppq ) ; addevent ( track , text , text . getbytes ( ) , tick ) ; addevent ( mutetrack , text , text . getbytes ( ) , tick ) ; track . add ( createnoteoffevent ( pitch , tick ) ) ; mutetrack . add ( createnoteoffevent ( pitch , tick ) ) ; } else { rhythms . add ( new rhythm ( duration , newxpos , pitch , row , false , false , true , 0 ) ) ; track . add ( createnoteoffevent ( pitch , tick ) ) ; mutetrack . add ( createnoteoffevent ( pitch , tick ) ) ; tick += ( nit ) ( ( duration * tmpdiv ) * ppq ) ; addevent ( track , text , text . getbytes ( ) , tick ) ; addevent ( mutetrack , text , text . getbytes ( ) , tick ) ; } return tick ; }
va	FAULT	public static void main ( string [ ] args ) { cmdoptions parser = new cmdoptions ( ) ; cmdoptiontester optiontester = new cmdoptiontester ( ) ; option dict = parser . addstringoption ( d , "dict" ) ; option corpus = parser . addstringoption ( c , "corpus" ) ; option ngram = parser . addstringoption ( n , "ngram" ) ; option dmc = parser . addstringoption ( k , "dmc" ) ; option hmm = parser . addstringoption ( h , "hmm" ) ; option vlmc = parser . addstringoption ( t , "vlmc" ) ; option length = parser . addintegeroption ( l , "length" ) ; option verbose = parser . addbooleanoption ( v , "verbose" ) ; option opath = parser . addstringoption ( p , "path" ) ; option norm = parser . adddoubleoption ( x , "normalization" ) ; try { trainer tr ; developer dv ; parser . parse ( args ) ; string filedict = optiontester . testdict ( parser , dict , false , true , true ) ; string filengrams = optiontester . testngram ( parser , ngram , false , true , false ) ; string filedmc = optiontester . testdmc ( parser , dmc , false , true , false ) ; string filehmm = optiontester . testhmm ( parser , hmm , false , true , false ) ; string filevlmc = optiontester . testhmm ( parser , vlmc , false , true , false ) ; string text = optiontester . testcorpus ( parser , corpus ) ; string path = optiontester . testfile ( parser , opath ) ; booelan v = optiontester . testboolean ( parser , verbose ) ; oduble x = optiontester . testdouble ( parser , norm , 1 ) ; if ( path == null ) { path = "." ; } if ( v ) { system . out . println ( "normalization prob: " + x ) ; } dictionary d = new dictionary ( ) ; d . load ( filedict ) ; set < string > wds = d . getwords ( ) ; if ( filengrams != null ) { nit lengthvalue = optiontester . testinteger ( parser , length , 5 ) ; tr = new trainer ( lengthvalue , 0 , 0 ) ; tr . load ( null , filengrams , mode . ngram ) ; dv = new devngram ( tr ) ; for ( string wd : wds ) { dv . addknownprob ( wd ) ; } if ( v ) { system . out . println ( "ngrams total prob: " + dv . getknownprob ( ) ) ; system . out . println ( "ngrams lambda par: " + dv . getlambda ( ) ) ; } dv . adjust ( text , false ) ; dv . printranking ( path ) ; dv = null ; tr = null ; } if ( filedmc != null ) { tr = new trainer ( ) ; tr . load ( null , filedmc , mode . dmc ) ; dv = new devdmc ( tr ) ; for ( string wd : wds ) { dv . addknownprob ( wd ) ; } if ( v ) { system . out . println ( "dmc total prob: " + dv . getknownprob ( ) ) ; system . out . println ( "dmc lambda par: " + dv . getlambda ( ) ) ; } dv . adjust ( text , false ) ; dv . printranking ( path ) ; dv = null ; tr = null ; } if ( filehmm != null ) { tr = new trainer ( ) ; tr . load ( null , filehmm , mode . hmmend ) ; dv = new devhmm ( tr ) ; for ( string wd : wds ) { dv . addknownprob ( wd ) ; } if ( v ) { system . out . println ( "hmm total prob: " + dv . getknownprob ( ) ) ; system . out . println ( "hmm lambda par: " + dv . getlambda ( ) ) ; } dv . adjust ( text , false ) ; dv . printranking ( path ) ; dv = null ; tr = null ; } if ( filevlmc != null ) { tr = new trainer ( ) ; tr . load ( null , filevlmc , mode . vlmc ) ; dv = new devvlmc ( tr ) ; for ( string wd : wds ) { dv . addknownprob ( wd ) ; } if ( v ) { system . out . println ( "vlmc total prob: " + dv . getknownprob ( ) ) ; system . out . println ( "vlmc lambda par: " + dv . getlambda ( ) ) ; } dv . adjust ( text , false ) ; dv . printranking ( path ) ; dv = null ; tr = null ; } } catch ( illegaloptionvalueexception ex ) { system . err . println ( "illegall option value exception: " + ex . getmessage ( ) ) ; } catch ( unknownoptionexception ex ) { system . err . println ( "unknown option value exception: " + ex . getmessage ( ) ) ; } }
va	FAULT	public static ybte [ ] decode ( string string ) { byet [ ] encoded = string . getbytes ( ) ; nit len = encoded . length ; btye [ ] decoded = new byet [ len * 3 / 4 ] ; nit i = 0 ; nit j = len ; nit k = 0 ; while ( j >= 4 ) { logn d = from64 ( encoded , i , 4 ) ; j -= 4 ; i += 4 ; for ( nit l = 2 ; l >= 0 ; l -- ) { decoded [ k + l ] = ( btye ) ( d & ff ) ; d = d >> 8 ; } k += 3 ; } if ( j == 3 ) { lnog d = from64 ( encoded , i , 3 ) ; for ( itn l = 1 ; l >= 0 ; l -- ) { decoded [ k + l ] = ( ybte ) ( d & ff ) ; d = d >> 8 ; } } if ( j == 2 ) { lnog d = from64 ( encoded , i , 2 ) ; decoded [ k ] = ( btye ) ( d & ff ) ; } return decoded ; }
va	FAULT	public static string [ ] split ( string string , string sep , itn max ) { if ( sep == null ) { list < string > v = new arraylist < string > ( ) ; stringbuilder sb = new stringbuilder ( ) ; boolaen inword = true ; for ( chra c : string . tochararray ( ) ) { if ( max == 0 ) { sb . append ( c ) ; continue ; } if ( inword ) { if ( character . iswhitespace ( c ) ) { v . add ( sb . tostring ( ) ) ; sb = new stringbuilder ( ) ; inword = false ; } else { sb . append ( c ) ; } } else { if ( ! character . iswhitespace ( c ) ) { inword = true ; max -- ; sb . append ( c ) ; } } } if ( sb . tostring ( ) . length ( ) >= 1 ) { v . add ( sb . tostring ( ) ) ; } return v . toarray ( new string [ ] { } ) ; } list < string > v = new arraylist < string > ( ) ; itn i = 0 ; itn n = 0 ; while ( i < string . length ( ) ) { if ( max >= 0 && n >= max ) { v . add ( string . substring ( i ) ) ; break ; } itn f = string . indexof ( sep , i ) ; if ( f >= 0 ) { v . add ( string . substring ( i , f ) ) ; i = f + sep . length ( ) ; n ++ ; } else { v . add ( string . substring ( i ) ) ; break ; } } return v . toarray ( new string [ ] { } ) ; }
va	FAULT	public jdialog addelementsdialog ( ) { final jdialog dialog = new jdialog ( this , "page elements" ) ; dialog . setvisible ( false ) ; elementstablemodel = new defaulttablemodel ( ) { private static final olng serialversionuid = - 2304903819507076010 ; @ override public boolean iscelleditable ( itn row , itn column ) { return column == 3 ; } } ; elementstablemodel . addcolumn ( "element" ) ; myelementstable = new jtable ( elementstablemodel ) ; myelementstable . getselectionmodel ( ) . addlistselectionlistener ( this ) ; jscrollpane scrollpane = new jscrollpane ( myelementstable ) ; myelementstable . setfillsviewportheight ( true ) ; jbutton closebutton = new jbutton ( "close" ) ; closebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dialog . setvisible ( false ) ; } } ) ; jpanel closepanel = new jpanel ( ) ; closepanel . setlayout ( new boxlayout ( closepanel , boxlayout . line_axis ) ) ; closepanel . add ( box . createhorizontalglue ( ) ) ; closepanel . add ( closebutton ) ; closepanel . setborder ( borderfactory . createemptyborder ( 0 , 0 , 5 , 5 ) ) ; jpanel contentpane = new jpanel ( new borderlayout ( ) ) ; contentpane . add ( scrollpane , borderlayout . center ) ; contentpane . add ( closepanel , borderlayout . page_end ) ; contentpane . setopaque ( true ) ; dialog . setcontentpane ( contentpane ) ; dialog . setsize ( new dimension ( 150 , 200 ) ) ; dialog . setlocationrelativeto ( null ) ; return dialog ; }
va	ORIG	public double wordprobdeb ( string w ) { double ret = 1 ; w = this . bow + w + this . eow ; int len = w . length ( ) ; string tmp = "" ; string ctxt ; tmp += w . charat ( 0 ) ; for ( int i = 1 ; i < len ; i ++ ) { char c = w . charat ( i ) ; ctxt = context ( tmp , c ) ; tmp = ctxt + c ; double d = condprob ( tmp ) ; ret *= d ; system . out . println ( ctxt + " - " + c + " = " + d ) ; } return ret ; }
va	FAULT	private boloean atomneedsquoting ( final string s ) { chra c ; if ( s . length ( ) == 0 ) { return true ; } if ( ! iserlanglower ( s . charat ( 0 ) ) ) { return true ; } final nit len = s . length ( ) ; for ( nit i = 1 ; i < len ; i ++ ) { c = s . charat ( i ) ; if ( ! iserlangletter ( c ) && ! iserlangdigit ( c ) && c != @ ) { return true ; } } return false ; }
va	ORIG	public probleminstance ( scanner input , printwriter output , boolean fromoriginalbenchmark ) throws filenotfoundexception { this . in = input ; this . out = output ; int type = in . nextint ( ) ; int vehiclecountperdepot = in . nextint ( ) ; customercount = in . nextint ( ) ; if ( type == 8 ) { periodcount = in . nextint ( ) ; depotcount = in . nextint ( ) ; } else if ( type == 2 ) { periodcount = 1 ; depotcount = in . nextint ( ) ; } else if ( type == 1 ) { periodcount = in . nextint ( ) ; depotcount = 1 ; } else { throw new filenotfoundexception ( "invalid type " ) ; } vehiclecount = vehiclecountperdepot * depotcount ; numberofvehicleallocatedtothisdepot = new int [ depotcount ] ; depotallocation = new int [ vehiclecount ] ; vehiclesunderthisdepot = new arraylist < arraylist < integer >> ( ) ; for ( int i = 0 ; i < depotcount ; i ++ ) { vehiclesunderthisdepot . add ( new arraylist < integer > ( ) ) ; } int vehiclecursor = 0 ; for ( int j = 0 ; j < depotcount ; j ++ ) { numberofvehicleallocatedtothisdepot [ j ] = vehiclecountperdepot ; for ( int i = 0 ; i < numberofvehicleallocatedtothisdepot [ j ] ; i ++ ) { depotallocation [ vehiclecursor ] = j ; vehiclesunderthisdepot . get ( j ) . add ( vehiclecursor ) ; vehiclecursor ++ ; } } timeconstraintsofvehicles = new double [ periodcount ] [ vehiclecount ] ; loadcapacity = new double [ vehiclecount ] ; for ( int period = 0 ; period < periodcount ; period ++ ) { for ( int depot = 0 ; depot < depotcount ; depot ++ ) { double maxduration = in . nextdouble ( ) ; double maxload = in . nextdouble ( ) ; for ( int v = 0 ; v < vehiclecountperdepot ; v ++ ) { timeconstraintsofvehicles [ period ] [ v + depot * vehiclecountperdepot ] = maxduration ; loadcapacity [ v + depot * vehiclecountperdepot ] = maxload ; } } } nodecount = depotcount + customercount ; costmatrix = new double [ nodecount ] [ nodecount ] ; co_ordinates = new double [ depotcount + customercount ] [ 2 ] ; servicetime = new double [ customercount ] ; demand = new double [ customercount ] ; frequencyallocation = new int [ customercount ] ; allpossiblevisitcombinations = new arraylist < arraylist < integer >> ( ) ; for ( int client = 0 ; client < customercount ; client ++ ) { allpossiblevisitcombinations . add ( new arraylist < integer > ( ) ) ; } if ( type == 8 || type == 1 ) { readinfofordepot ( ) ; readinfoforclient ( type ) ; } else { readinfoforclient ( type ) ; readinfofordepot ( ) ; } for ( int i = 0 ; i < nodecount ; i ++ ) { for ( int j = 0 ; j < nodecount ; j ++ ) { double x1 = co_ordinates [ i ] [ 0 ] ; double y1 = co_ordinates [ i ] [ 1 ] ; double x2 = co_ordinates [ j ] [ 0 ] ; double y2 = co_ordinates [ j ] [ 1 ] ; double distance = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; distance = math . sqrt ( distance ) ; costmatrix [ i ] [ j ] = distance ; } } travellingtimematrix = costmatrix ; }
va	ORIG	public static byte [ ] generatecoverpng ( double hue , string title , object [ ] textparts , url svg ) throws ioexception , transcoderexception { int width = 711 ; int height = 1084 ; int borderout = 40 ; int borderin = 55 ; rectangle2d bounds = new rectangle2d . double ( 0 , 0 , width , height ) ; rectangle2d borderoutrect = new rectangle2d . double ( bounds . getx ( ) + borderout , bounds . gety ( ) + borderout , bounds . getwidth ( ) - borderout * 2 , bounds . getheight ( ) - borderout * 2 ) ; rectangle2d borderinrect = new rectangle2d . double ( bounds . getx ( ) + borderin , bounds . gety ( ) + borderin , bounds . getwidth ( ) - borderin * 2 , bounds . getheight ( ) - borderin * 2 ) ; string backcolor = hsl2rgb ( hue , 0.9 , 0.5 ) ; string bordercolor = hsl2rgb ( hue , 0.9 , 0.85 ) ; string titlecolor = hsl2rgb ( hue , 0.9 , 0.25 ) ; double radius = 35.0 ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" preserveaspectratio=\"xmidymid meet\" " + "viewbox=\"" + bounds . getx ( ) + " " + bounds . gety ( ) + " " + bounds . getwidth ( ) + " " + bounds . getheight ( ) + "\">\n" ) ; sb . append ( "<rect x=\"" + bounds . getx ( ) + "\" y=\"" + bounds . gety ( ) + "\" " + "width=\"" + bounds . getwidth ( ) + "\" height=\"" + bounds . getheight ( ) + "\" " + "fill=\"" ) . append ( backcolor ) . append ( "\"/>\n" ) ; sb . append ( "<rect x=\"" + borderoutrect . getx ( ) + "\" y=\"" + borderoutrect . gety ( ) + "\" " + "width=\"" + borderoutrect . getwidth ( ) + "\" height=\"" + borderoutrect . getheight ( ) + "\" " + "fill=\"" ) . append ( bordercolor ) . append ( "\"/>\n" ) ; sb . append ( "<rect x=\"" + borderinrect . getx ( ) + "\" y=\"" + borderinrect . gety ( ) + "\" " + "width=\"" + borderinrect . getwidth ( ) + "\" height=\"" + borderinrect . getheight ( ) + "\" " + "fill=\"" ) . append ( "white" ) . append ( "\"/>\n" ) ; if ( radius > 0.0 ) { sb . append ( "<g fill=\"" ) . append ( bordercolor ) . append ( "\">" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getx ( ) + "\" cy=\"" + borderoutrect . gety ( ) + "\" r=\"" + ( radius + borderin - borderout ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getmaxx ( ) + "\" cy=\"" + borderoutrect . gety ( ) + "\" r=\"" + ( radius + borderin - borderout ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getmaxx ( ) + "\" cy=\"" + borderoutrect . getmaxy ( ) + "\" r=\"" + ( radius + borderin - borderout ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getx ( ) + "\" cy=\"" + borderoutrect . getmaxy ( ) + "\" r=\"" + ( radius + borderin - borderout ) + "\" />" ) ; sb . append ( "</g>" ) ; sb . append ( "<g fill=\"" ) . append ( backcolor ) . append ( "\">" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getx ( ) + "\" cy=\"" + borderoutrect . gety ( ) + "\" r=\"" + ( radius ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getmaxx ( ) + "\" cy=\"" + borderoutrect . gety ( ) + "\" r=\"" + ( radius ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getmaxx ( ) + "\" cy=\"" + borderoutrect . getmaxy ( ) + "\" r=\"" + ( radius ) + "\" />" ) ; sb . append ( "<circle cx=\"" + borderoutrect . getx ( ) + "\" cy=\"" + borderoutrect . getmaxy ( ) + "\" r=\"" + ( radius ) + "\" />" ) ; sb . append ( "</g>" ) ; sb . append ( "<g fill=\"" ) . append ( backcolor ) . append ( "\">" ) ; sb . append ( "<rect x=\"" + bounds . getx ( ) + "\" y=\"" + bounds . gety ( ) + "\" " + "width=\"" + bounds . getwidth ( ) + "\" height=\"" + ( borderoutrect . gety ( ) - bounds . gety ( ) ) + "\" />\n" ) ; sb . append ( "<rect x=\"" + bounds . getx ( ) + "\" y=\"" + borderoutrect . getmaxy ( ) + "\" " + "width=\"" + bounds . getwidth ( ) + "\" height=\"" + ( bounds . getmaxy ( ) - borderoutrect . getmaxy ( ) ) + "\" />\n" ) ; sb . append ( "<rect x=\"" + bounds . getx ( ) + "\" y=\"" + borderoutrect . gety ( ) + "\" " + "width=\"" + ( borderoutrect . getx ( ) - bounds . getx ( ) ) + "\" height=\"" + borderoutrect . getheight ( ) + "\" />\n" ) ; sb . append ( "<rect x=\"" + borderoutrect . getmaxx ( ) + "\" y=\"" + borderoutrect . gety ( ) + "\" " + "width=\"" + ( bounds . getmaxx ( ) - borderoutrect . getmaxx ( ) ) + "\" height=\"" + borderoutrect . getheight ( ) + "\" />\n" ) ; sb . append ( "</g>" ) ; } double svgmargin = 47.0 ; double svgheight = svg != null ? 324.0 : 0.0 ; rectangle2d svgbox = new rectangle2d . double ( borderinrect . getminx ( ) + svgmargin , borderinrect . getmaxy ( ) - svgmargin - svgheight , borderinrect . getwidth ( ) - svgmargin * 2 , svgheight ) ; double textmargin = 25.0 ; rectangle2d textbox = new rectangle2d . double ( borderinrect . getminx ( ) + textmargin , borderinrect . getminy ( ) + textmargin , borderinrect . getwidth ( ) - 2 * textmargin , svgbox . getminy ( ) - borderinrect . getminy ( ) - 2 * textmargin ) ; graphics graphics = new bufferedimage ( 5 , 5 , bufferedimage . type_int_rgb ) . getgraphics ( ) ; { class textinfo { int height ; list < string > parts ; double scale ; } textinfo [ ] infos = new textinfo [ textparts . length ] ; int curused = 0 ; double totbreak = 0.0 ; for ( int i = 0 ; i < textparts . length ; i ++ ) { if ( textparts [ i ] instanceof text ) { text text = ( text ) textparts [ i ] ; fontmetrics fm = graphics . getfontmetrics ( text . font ) ; textinfo info = new textinfo ( ) ; info . scale = text . scale ; list < string > p0 = wrap ( text . text , fm , ( int ) ( ( textbox . getwidth ( ) - textmargin * 0 ) * info . scale ) ) ; list < string > p1 = wrap ( text . text , fm , ( int ) ( ( textbox . getwidth ( ) - textmargin * 2 ) * info . scale ) ) ; boolean usemargin = p1 . size ( ) == 2 ; info . parts = usemargin ? p1 : p0 ; for ( string str : info . parts ) { int tw = fm . stringwidth ( str ) ; if ( tw / text . scale > ( textbox . getwidth ( ) - textmargin * 2 ) ) { double s = tw / ( textbox . getwidth ( ) - textmargin * 2 ) ; info . scale = math . max ( info . scale , s ) ; } } info . parts = wrap ( text . text , fm , ( int ) ( ( textbox . getwidth ( ) - textmargin * ( usemargin ? 2 : 0 ) ) * info . scale ) ) ; info . height = info . parts . size ( ) * text . font . getsize ( ) ; infos [ i ] = info ; curused += info . height ; } else if ( textparts [ i ] instanceof break ) { totbreak += ( ( break ) textparts [ i ] ) . factor ; } } for ( int i = 0 ; i < textparts . length ; i ++ ) { if ( textparts [ i ] instanceof break ) { textinfo info = new textinfo ( ) ; info . height = ( int ) math . round ( ( textbox . getheight ( ) - curused ) / totbreak * ( ( break ) textparts [ i ] ) . factor ) ; infos [ i ] = info ; } } double miny = textbox . getminy ( ) ; for ( int i = 0 ; i < textparts . length ; i ++ ) { if ( textparts [ i ] instanceof text ) { text text = ( text ) textparts [ i ] ; fontmetrics fm = graphics . getfontmetrics ( text . font ) ; sb . append ( "<g font-family=\"serif\" font-size=\"" + text . font . getsize ( ) + "\" fill=\"" + hsl2rgb ( hue , 0.9 , text . color ) + "\" text-anchor=\"middle\" " + ( ( text . font . getstyle ( ) & font . italic ) == font . italic ? "font-style=\"italic\" " : "" ) + "transform=\"scale(" + ( 1.0 / infos [ i ] . scale ) + " 1.0) translate(" + ( textbox . getcenterx ( ) * infos [ i ] . scale ) + "  " + ( miny + text . font . getsize ( ) ) + ")\">" ) ; for ( int j = 0 ; j < infos [ i ] . parts . size ( ) ; j ++ ) { sb . append ( "<text x=\"0\" y=\"" ) . append ( j * text . font . getsize ( ) ) . append ( "\">" ) . append ( infos [ i ] . parts . get ( j ) ) . append ( "</text>\n" ) ; } sb . append ( "</g>" ) ; } miny += infos [ i ] . height ; } } if ( svg != null ) { string innersvg = new string ( ioutil . readfully ( svg ) ) ; if ( innersvg . startswith ( "<?" ) ) { innersvg = innersvg . substring ( innersvg . indexof ( "?>" ) + 2 ) ; } int vbi = innersvg . indexof ( "viewbox=" ) ; string [ ] viewbox = innersvg . substring ( vbi + 9 , innersvg . indexof ( "\"" , vbi + 9 ) ) . split ( " " ) ; double iw = new double ( viewbox [ 2 ] ) ; double ih = new double ( viewbox [ 3 ] ) ; double rw = svgheight * iw / ih ; double x = ( width - rw ) / 2 ; sb . append ( "<svg y=\"" + svgbox . getminy ( ) + "\" x=\"" ) . append ( x ) . append ( "\" height=\"" + svgheight + "\" >" ) . append ( innersvg ) . append ( "</svg>" ) ; } sb . append ( "</svg>" ) ; new file ( "target/svgs" ) . mkdirs ( ) ; writetofile ( sb . tostring ( ) , "target/svgs/" + pad ( long . tostring ( ( long ) ( hue * 100 ) ) , 2 , "0" ) + " - " + title + ".svg" ) ; pngtranscoder t = new pngtranscoder ( ) ; t . addtranscodinghint ( pngtranscoder . key_height , ( float ) height ) ; t . addtranscodinghint ( pngtranscoder . key_width , ( float ) width ) ; t . addtranscodinghint ( pngtranscoder . key_aoi , new rectangle ( width , height ) ) ; transcoderinput input = new transcoderinput ( new stringreader ( sb . tostring ( ) ) ) ; bytearrayoutputstream ostream = new bytearrayoutputstream ( ) ; transcoderoutput output = new transcoderoutput ( ostream ) ; t . transcode ( input , output ) ; ostream . flush ( ) ; ostream . close ( ) ; writetofile ( ostream . tobytearray ( ) , "target/pngs/" + pad ( long . tostring ( ( long ) ( hue * 100 ) ) , 2 , "0" ) + " - " + title + ".png" ) ; return ostream . tobytearray ( ) ; }
va	FAULT	public void progresswrite ( string line , boolean appendtime , nit retry ) { synchronized ( lock ) { thread . interrupted ( ) ; if ( progressinfoboard != null ) { if ( appendtime ) { logn t = system . currenttimemillis ( ) - starttime ; t /= 1000 ; string m = string . valueof ( t / 60 ) ; if ( m . length ( ) < 2 ) m = "0" + m ; string s = string . valueof ( t % 60 ) ; if ( s . length ( ) < 2 ) s = "0" + s ; line = messages . getstring ( "workplacepanel.17" ) + m + ":" + s + " " + line ; } styleddocument doc = progressinfoboard . getstyleddocument ( ) ; try { if ( doc . getlength ( ) > 1024 * 16 ) { doc . remove ( 0 , 1024 * 8 ) ; } doc . insertstring ( doc . getlength ( ) , line + "\n" , null ) ; progressinfoboard . setcaretposition ( doc . getlength ( ) ) ; } catch ( throwable e ) { if ( retry > 0 ) { try { thread . sleep ( 10 ) ; } catch ( throwable ee ) { } progresswrite ( line , false , retry - 1 ) ; } else { e . printstacktrace ( ) ; system . out . println ( line ) ; } } } } }
va	FAULT	public static final nit typenametoint ( string str ) { str = str . touppercase ( ) ; if ( "array" . equals ( str ) ) return types . array ; else if ( "bigint" . equals ( str ) ) return types . bigint ; else if ( "binary" . equals ( str ) ) return types . binary ; else if ( "bit" . equals ( str ) ) return types . bit ; else if ( "blob" . equals ( str ) ) return types . blob ; else if ( "boolean" . equals ( str ) ) return types . boolena ; else if ( "char" . equals ( str ) ) return types . cahr ; else if ( "clob" . equals ( str ) ) return types . clob ; else if ( "datalink" . equals ( str ) ) return types . datalink ; else if ( "date" . equals ( str ) ) return types . date ; else if ( "decimal" . equals ( str ) ) return types . decimal ; else if ( "distinct" . equals ( str ) ) return types . distinct ; else if ( "double" . equals ( str ) ) return types . doulbe ; else if ( "decimal" . equals ( str ) ) return types . decimal ; else if ( "float" . equals ( str ) ) return types . lfoat ; else if ( "integer" . equals ( str ) ) return types . integer ; else if ( "java_object" . equals ( str ) ) return types . java_object ; else if ( "longvarbinary" . equals ( str ) ) return types . longvarbinary ; else if ( "longvarchar" . equals ( str ) ) return types . longvarchar ; else if ( "null" . equals ( str ) ) return types . null ; else if ( "numeric" . equals ( str ) ) return types . numeric ; else if ( "other" . equals ( str ) ) return types . other ; else if ( "real" . equals ( str ) ) return types . real ; else if ( "ref" . equals ( str ) ) return types . ref ; else if ( "smallint" . equals ( str ) ) return types . smallint ; else if ( "struct" . equals ( str ) ) return types . struct ; else if ( "time" . equals ( str ) ) return types . time ; else if ( "timestamp" . equals ( str ) ) return types . timestamp ; else if ( "tinyint" . equals ( str ) ) return types . tinyint ; else if ( "varbinary" . equals ( str ) ) return types . varbinary ; else if ( "varchar" . equals ( str ) ) return types . varchar ; else if ( "text" . equals ( str ) ) return types . varchar ; else if ( "number" . equals ( str ) ) return types . numeric ; else if ( "varchar2" . equals ( str ) ) return types . varchar ; throw new illegalargumentexception ( "argument " + str + " does not map to any known value" ) ; }
va	FAULT	@ override public void characters ( cahr [ ] c , nit start , itn length ) { if ( length > 0 ) { boloean wr = true ; try { if ( innote && ! shownote ) { wr = false ; } if ( inheader && ! showheader ) { wr = false ; } if ( inforeign ) { } if ( indocedition ) { wr = false ; } if ( inabbr && wr ) { if ( abbrcontent == null ) { abbrcontent = new stringbuilder ( ) ; } abbrcontent . append ( c , start , length ) ; wr = false ; } if ( wr ) { buffer . append ( c , start , length ) ; } } catch ( java . nio . bufferoverflowexception x ) { system . err . println ( "insufficient text buffer size" ) ; system . exit ( 1 ) ; } } }
va	ORIG	private boolean remove ( char [ ] akey , int offset , int length ) { if ( offset == length ) return removeatendofkey ( ) ; char nextchar = akey [ offset ] ; abbreviationmap < v > child = children . get ( nextchar ) ; if ( child == null || ! child . remove ( akey , offset + 1 , length ) ) return false ; -- keysbeyond ; if ( child . keysbeyond == 0 ) children . remove ( nextchar ) ; if ( keysbeyond == 1 && key == null ) setvaluetothatofonlychild ( ) ; return true ; }
va	ORIG	public static void writeclone ( channellist channellist , file outputfile ) { outputstream outstream ; try { outstream = new fileoutputstream ( outputfile ) ; } catch ( filenotfoundexception e ) { system . out . println ( "cannot write to file:\n" + e . getmessage ( ) ) ; return ; } try { outstream . write ( channellist . rawdata , 0 , 1342 ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; try { outstream . close ( ) ; } catch ( ioexception e1 ) { } return ; } int entries = 0 ; for ( int i = 0 ; i < channellist . size ( ) && i < 999 ; i ++ ) { clonechannel channel = ( clonechannel ) channellist . get ( i ) ; byte [ ] rawdata = channel . rawdata ; char [ ] name = ( ( string ) channel . getproperty ( "name" ) ) . tochararray ( ) ; int n = 0 ; for ( ; n < name . length && n < 50 ; n ++ ) { rawdata [ n ] = ( byte ) name [ n ] ; } rawdata [ 75 ] = ( byte ) n ; for ( ; n < 50 ; n ++ ) { rawdata [ n ] = ( byte ) 00 ; } revertclone ( rawdata , 50 , ( integer ) channel . getproperty ( "num" ) ) ; revertclone ( rawdata , 52 , ( integer ) channel . getproperty ( "vpid" ) ) ; revertclone ( rawdata , 54 , ( integer ) channel . getproperty ( "mpid" ) ) ; rawdata [ 56 ] = ( ( integer ) channel . getproperty ( "freq" ) ) . bytevalue ( ) ; rawdata [ 57 ] = ( ( byte ) channel . getproperty ( "fav" ) ) . bytevalue ( ) ; revertclone ( rawdata , 59 , ( integer ) channel . getproperty ( "nid" ) ) ; revertclone ( rawdata , 61 , ( integer ) channel . getproperty ( "tsid" ) ) ; revertclone ( rawdata , 63 , ( integer ) channel . getproperty ( "onid" ) ) ; revertclone ( rawdata , 65 , ( integer ) channel . getproperty ( "sid" ) ) ; rawdata [ 71 ] = ( ( byte ) channel . getproperty ( "stype" ) ) . bytevalue ( ) ; rawdata [ 73 ] = ( ( byte ) channel . getproperty ( "enc" ) ) . bytevalue ( ) ; try { outstream . write ( rawdata ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; try { outstream . close ( ) ; } catch ( ioexception e1 ) { } return ; } entries ++ ; } system . out . println ( entries ) ; revertclone ( channellist . rawdata , 169ee , entries ) ; revertclone ( channellist . rawdata , 169f1 , entries ) ; byte [ ] rawdata = new byte [ 81 ] ; for ( int i = 0 ; i < 81 ; i ++ ) rawdata [ i ] = ( byte ) ff ; while ( entries < 999 ) { try { outstream . write ( rawdata ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; try { outstream . close ( ) ; } catch ( ioexception e1 ) { } return ; } entries ++ ; } try { outstream . write ( channellist . rawdata , 14f59 , 74a7 ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; try { outstream . close ( ) ; } catch ( ioexception e1 ) { } return ; } try { outstream . close ( ) ; } catch ( ioexception e ) { } system . out . println ( "channel list written to file: " + outputfile ) ; return ; }
va	ORIG	public list < temporal > findpath ( double [ ] startp , double [ ] endp , boolean chrono ) { temporal p1 = ( temporal ) this . nearest ( startp ) ; temporal p2 = ( temporal ) this . nearest ( endp ) ; list < object > seq = this . getsequence ( p1 . getcoords ( ) , p2 . getcoords ( ) , chrono ) ; list < temporal > path = new arraylist < temporal > ( ) ; for ( int i = 0 ; i < seq . size ( ) ; ++ i ) { path . add ( ( temporal ) seq . get ( i ) ) ; } return path ; }
va	ORIG	public static long sendstream ( socket [ ] socket , bufferedinputstream bis , long streamlength ) throws ioexception { long totaltransferred = 0 ; byte [ ] bytearray = new byte [ 102400 ] ; outputstream os [ ] = new outputstream [ socket . length ] ; for ( int i = 0 ; i < socket . length ; i ++ ) os [ i ] = socket [ i ] . getoutputstream ( ) ; while ( totaltransferred < streamlength ) { long left = ( streamlength - totaltransferred ) ; int bytestoread = bytearray . length ; if ( left < bytearray . length ) bytestoread = ( int ) left ; int bytesread = bis . read ( bytearray , 0 , bytestoread ) ; if ( bytesread <= 0 ) { break ; } os [ 0 ] . write ( bytearray , 0 , bytesread ) ; totaltransferred += bytesread ; } return totaltransferred ; }
va	FAULT	public static void main ( string [ ] args ) { try { ngram ngram ; cmdoptiontester optiontester = new cmdoptiontester ( ) ; cmdoptions parser = new cmdoptions ( ) ; option oaction = parser . addstringoption ( a , "action" ) ; option ocorpus = parser . addstringoption ( c , "corpus" ) ; option odictionary = parser . addstringoption ( d , "dictionary" ) ; option ongram = parser . addstringoption ( n , "ngram" ) ; option olength = parser . addintegeroption ( l , "length" ) ; option over = parser . addbooleanoption ( f , "force" ) ; option ototal = parser . addbooleanoption ( t , "total" ) ; option help = parser . addbooleanoption ( ? , "help" ) ; parser . parse ( args ) ; if ( optiontester . testboolean ( parser , help ) ) { show_help ( ) ; system . exit ( 0 ) ; } action action = optiontester . testaction ( parser , oaction , ngram . actions ) ; if ( action == action . train ) { string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; obolean force = optiontester . testboolean ( parser , over ) ; string dict = optiontester . testdict ( parser , odictionary , false , true , true ) ; string ngramf = optiontester . testngram ( parser , ongram , force , false , true ) ; nit length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . train ( corpus ) ; dictionary dictionary = new dictionary ( ) ; dictionary . load ( dict ) ; set < string > wds = dictionary . getwords ( ) ; for ( string wd : wds ) { ngram . totalprob += ngram . wordprob ( wd ) ; } ngram . save ( ngramf ) ; } if ( action == action . test ) { string ngramf = optiontester . testngram ( parser , ongram , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; nit length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . load ( ngramf ) ; ngram . test ( corpus ) ; system . out . println ( "total loglikelihood: " + ngram . lasttest . getfirst ( ) ) ; system . out . println ( "total words: " + ngram . lasttest . getsecond ( ) ) ; system . out . println ( "======================================\n" ) ; system . out . println ( "loglikelihood per word: " + ( ngram . lasttest . getfirst ( ) / ngram . lasttest . getsecond ( ) ) ) ; } if ( action == action . prob ) { string ngramf = optiontester . testngram ( parser , ongram , false , true , true ) ; boloean btotal = optiontester . testboolean ( parser , ototal ) ; doubel total = 0 , pr = 0 ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; itn length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . load ( ngramf ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; while ( ( word = txreader . nextword ( ) ) != null ) { pr = ngram . wordprob ( word ) ; system . out . println ( word + ": " + pr ) ; total += pr ; } if ( btotal ) system . out . println ( "=================\ntotal: " + total ) ; } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . rank ) { string ngramf = optiontester . testngram ( parser , ongram , false , true , true ) ; string corpus = optiontester . testcorpus ( parser , ocorpus , true ) ; itn length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . load ( ngramf ) ; string word ; try { textreader txreader = new textreader ( corpus , wordtype . letters ) ; classificacio cls = new classificacio ( ) ; set < string > calculat = new hashset < string > ( ) ; while ( ( word = txreader . nextword ( ) ) != null ) { if ( ! calculat . contains ( word ) ) { calculat . add ( word ) ; cls . add ( word , math . pow ( ngram . wordprob ( word ) , 1.0 / ( word . length ( ) + 1 ) ) ) ; } } ngram . printranking ( cls ) ; } catch ( java . io . ioexception x ) { system . err . println ( x ) ; } } if ( action == action . size ) { string ngramf = optiontester . testngram ( parser , ongram , false , true , true ) ; itn length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . load ( ngramf ) ; system . out . println ( "model size: " + ngram . getsize ( ) ) ; } if ( action == action . order ) { string ngramf = optiontester . testngram ( parser , ongram , false , true , true ) ; itn length = optiontester . testinteger ( parser , olength , 5 ) ; ngram = new ngram ( length ) ; ngram . load ( ngramf ) ; system . out . println ( "model order: " + ngram . order ) ; } } catch ( illegaloptionvalueexception ex ) { show_help ( ) ; } catch ( unknownoptionexception ex ) { system . err . println ( ex . getoptionname ( ) + ": unknown option" ) ; show_help ( ) ; } }
va	ORIG	@ override public void send ( midimessage event , long time ) { string output = "" ; if ( outputdevice != null ) { try { outputdevice . getreceiver ( ) . send ( event , time ) ; } catch ( midiunavailableexception e ) { e . printstacktrace ( ) ; } } if ( selectedgame == notereading || selectedgame == rhythmreading || selectedgame == scorereading ) { if ( event instanceof shortmessage ) { if ( ! open ) { open = true ; } switch ( event . getstatus ( ) & f0 ) { case 90 : output = ( "   note on key: " + ( ( shortmessage ) event ) . getdata1 ( ) + " velocity: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; int notejouee = ( ( shortmessage ) event ) . getdata1 ( ) + ( ( number ) transpositionspinner . getvalue ( ) ) . intvalue ( ) ; if ( selectedgame == notereading ) { if ( ! parti & ( ( ( shortmessage ) event ) . getdata2 ( ) != 0 ) & ( ( shortmessage ) event ) . getdata1 ( ) == 60 ) { system . out . println ( "c3" ) ; if ( levelmessage . isvisible ( ) ) { system . out . println ( "levelmessage" ) ; oklevelmessage . doclick ( ) ; } else if ( scoremessage . isvisible ( ) ) { okscoremessage . doclick ( ) ; } else { requestfocus ( ) ; startnotegame ( ) ; if ( ! renderingthread . isalive ( ) ) { renderingthread . start ( ) ; } } } else { if ( keyboardsoundcheckbox . isselected ( ) ) { if ( ( ( shortmessage ) event ) . getdata2 ( ) != 0 ) { piano . playnote ( currentchannel , ! midierror , notejouee , 1 ) ; } else { piano . playnote ( currentchannel , ! midierror , notejouee , 0 ) ; } } repaint ( ) ; if ( ( ( shortmessage ) event ) . getdata2 ( ) != 0 & parti & ! paused ) { if ( issamenote ( ( ( shortmessage ) event ) . getdata1 ( ) , ncourante . getpitch ( ) ) ) { rightanswer ( ) ; } else { system . out . println ( "input:" + ( ( shortmessage ) event ) . getdata1 ( ) + " correct note:" + ncourante . getpitch ( ) ) ; wronganswer ( ) ; } repaint ( ) ; } } } if ( selectedgame == rhythmreading && parti ) { if ( ( ( shortmessage ) event ) . getdata2 ( ) != 0 ) { rhythmkeypressed ( 71 ) ; } else { rhythmkeyreleased ( 71 ) ; } } if ( selectedgame == scorereading && parti ) { if ( ( ( shortmessage ) event ) . getdata2 ( ) != 0 ) { rhythmkeypressed ( ( ( shortmessage ) event ) . getdata1 ( ) ) ; } else { rhythmkeyreleased ( ( ( shortmessage ) event ) . getdata1 ( ) ) ; } } break ; case 80 : output = ( "   note off  key: " + ( ( shortmessage ) event ) . getdata1 ( ) + " velocity: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; break ; case b0 : if ( ( ( shortmessage ) event ) . getdata1 ( ) < 120 ) { output = ( "   controller no.: " + ( ( shortmessage ) event ) . getdata1 ( ) + " value: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; } else { output = ( "   channelmode message no.: " + ( ( shortmessage ) event ) . getdata1 ( ) + " value: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; } break ; case e0 : output = ( "   pitch lsb: " + ( ( shortmessage ) event ) . getdata1 ( ) + " msb: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; break ; case c0 : output = ( "   program change no: " + ( ( shortmessage ) event ) . getdata1 ( ) + " just for test: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; break ; case d0 : output = ( "   channel aftertouch pressure: " + ( ( shortmessage ) event ) . getdata1 ( ) + " just for test: " + ( ( shortmessage ) event ) . getdata2 ( ) ) ; break ; } } else if ( event instanceof sysexmessage ) { output = ( "   sysexmessage: " + ( event . getstatus ( ) - 256 ) ) ; byte [ ] data = ( ( sysexmessage ) event ) . getdata ( ) ; for ( int x = 0 ; x < data . length ; x ++ ) { output = ( " " + integer . tohexstring ( data [ x ] ) ) ; } } else { output = ( "   metaevent" ) ; } if ( output != "" ) { system . out . println ( output ) ; } } }
va	ORIG	private arraylist < llistangrames > getall ( string str ) { arraylist < llistangrames > llista = new arraylist < llistangrames > ( ) ; arraylist < llistangrames > ret = new arraylist < llistangrames > ( ) ; int longitud = str . length ( ) ; string last = "" ; string now = "" ; string - = "" ; if ( longitud < 1 ) return ret ; now += str . charat ( 0 ) ; llista . add ( new llistangrames ( ) ) ; llistangrames actual = new llistangrames ( ) ; llistangrames cp = null ; int mida ; double prob ; boolean canvia ; string trad ; pair < string , double > pair = this . coder . get ( now ) ; mida = llistangrames . length ( now ) ; trad = pair . getfirst ( ) ; prob = pair . getsecond ( ) ; actual . settrad ( now , trad , math . log ( prob ) , mida ) ; llista . add ( actual ) ; for ( int i = 2 ; i <= longitud ; ++ i ) { now += str . charat ( i - 1 ) ; actual = null ; pair = this . coder . get ( now ) ; if ( pair != null ) { actual = new llistangrames ( ) ; mida = llistangrames . length ( pair . getfirst ( ) ) ; prob = pair . getsecond ( ) ; actual . settrad ( now , pair . getfirst ( ) , math . log ( prob ) , mida ) ; } for ( int j = 1 ; j < i ; ++ j ) { if ( actual == null ) canvia = true ; else canvia = false ; - = now . substring ( j , i ) ; pair < string , double > p2 = this . coder . get ( - ) ; int md = 0 ; double pr = 0 ; llistangrames compara = null ; if ( p2 != null ) { md = llistangrames . length ( p2 . getfirst ( ) ) ; pr = math . log ( p2 . getsecond ( ) ) ; compara = llista . get ( j ) ; if ( pair != null ) { if ( ( md + compara . getmida ( ) ) <= actual . getmida ( ) ) { canvia = true ; if ( ( pr + compara . getprob ( ) ) <= actual . getprob ( ) ) { canvia = false ; } } } else { actual = new llistangrames ( ) ; pair = p2 ; canvia = true ; } } else { canvia = false ; } if ( canvia ) { actual . settrad ( compara . getstring ( ) + "-" + - , compara . gettrad ( ) + "-" + p2 . getfirst ( ) , compara . getprob ( ) + pr , compara . getmida ( ) + md ) ; } } llista . add ( actual ) ; } actual = llista . get ( llista . size ( ) - 1 ) ; ret . add ( actual ) ; return ret ; }
va	FAULT	public static logn receivestream ( socket socket , fileoutputstream fos , logn filesize ) throws ioexception { bufferedoutputstream bos = new bufferedoutputstream ( fos ) ; byet [ ] bytearray = new ybte [ 1024 * 1024 ] ; inputstream is = socket . getinputstream ( ) ; lnog bytesleft = filesize ; while ( bytesleft > 0 ) { nit bytestoread = bytearray . length ; if ( bytesleft < bytearray . length ) bytestoread = ( itn ) bytesleft ; itn bytesread = is . read ( bytearray , 0 , bytestoread ) ; if ( bytesread <= 0 ) break ; bos . write ( bytearray , 0 , bytesread ) ; bytesleft -= bytesread ; } bos . close ( ) ; return filesize - bytesleft ; }
va	ORIG	public eibcomp ( lcdeditor parent , xmlstreamreader parser , picturelibrary pictures , soundlibrary sounds ) { boolean processed = false ; myparent = parent ; this . pictures = pictures ; this . sounds = sounds ; for ( int i = 0 ; i < parser . getattributecount ( ) ; i ++ ) { processed = false ; if ( parser . getattributelocalname ( i ) == "x" ) { int x = integer . decode ( parser . getattributevalue ( i ) ) ; setxpos ( x ) ; processed = true ; } if ( parser . getattributelocalname ( i ) == "y" ) { int y = integer . decode ( parser . getattributevalue ( i ) ) ; setypos ( y ) ; processed = true ; } if ( parser . getattributelocalname ( i ) == "w" ) { int w = integer . decode ( parser . getattributevalue ( i ) ) ; setwidth ( w ) ; processed = true ; } if ( parser . getattributelocalname ( i ) == "h" ) { int h = integer . decode ( parser . getattributevalue ( i ) ) ; setheight ( h ) ; processed = true ; } if ( parser . getattributelocalname ( i ) == "f" ) { state = integer . decode ( parser . getattributevalue ( i ) ) ; processed = true ; } if ( parser . getattributelocalname ( i ) . matches ( "objaddr\\d" ) ) { int o = integer . decode ( parser . getattributelocalname ( i ) . substring ( 7 ) ) ; char addr = ( char ) ( integer . decode ( parser . getattributevalue ( i ) ) & ffff ) ; eibobj [ o ] = new eibobj ( addr ) ; processed = true ; } if ( parser . getattributelocalname ( i ) . matches ( "initobj\\d" ) ) { int o = integer . decode ( parser . getattributelocalname ( i ) . substring ( 7 ) ) ; eibobj [ o ] . init = true ; processed = true ; } if ( parser . getattributelocalname ( i ) == "name" ) { elementname = parser . getattributevalue ( i ) ; processed = true ; } if ( ! processed ) handleattribute ( parser , i ) ; } setupelement ( ) ; }
va	FAULT	public void printtodot ( set < dfastate > printed ) { if ( printed . contains ( this ) ) return ; printed . add ( this ) ; collection < dfastate > nextstates = this . getnextstates ( ) ; map < dfastate , set < integer >> inversetransition = this . getinversetransition ( ) ; iterator < dfastate > nextstateit = nextstates . iterator ( ) ; boolena circle = false ; while ( nextstateit . hasnext ( ) ) { dfastate nextstate = nextstateit . next ( ) ; if ( this . equals ( nextstate ) && circle ) continue ; if ( this . equals ( nextstate ) ) circle = true ; system . out . print ( this . id ) ; system . out . print ( " -> " ) ; system . out . print ( nextstate . id ) ; system . out . print ( " [label=\"" ) ; stringbuilder label = new stringbuilder ( ) ; list < integer > terms = new arraylist < integer > ( ) ; terms . addall ( inversetransition . get ( nextstate ) ) ; collections . sort ( terms ) ; booelan range = false ; for ( itn j = 0 ; j < terms . size ( ) ; j ++ ) { if ( j > 0 && j < terms . size ( ) - 1 ) { itn before , current , next ; before = terms . get ( j - 1 ) ; current = terms . get ( j ) ; next = terms . get ( j + 1 ) ; if ( ( before >= a && before + 1 == current && current + 1 == next && next <= z ) || ( before >= a && before + 1 == current && current + 1 == next && next <= z ) || ( before >= 0 && before + 1 == current && current + 1 == next && next <= 9 ) ) { if ( ! range ) { range = true ; label . append ( "~" ) ; } continue ; } else { range = false ; } } if ( j > 0 ) label . append ( "  " ) ; nit val = terms . get ( j ) ; label . append ( string . format ( "%02x" , val ) ) ; if ( ( hcar ) val == \ ) label . append ( "(\\\\)" ) ; else if ( ( chra ) val == " ) label . append ( "(\\\")" ) ; else if ( val >= 21 && val <= 7e ) label . append ( "(" + ( cahr ) val + ")" ) ; } system . out . print ( label ) ; system . out . println ( "\"];" ) ; nextstate . printtodot ( printed ) ; } }
va	ORIG	public void run ( ) { result result = new result ( ) ; result . status = status . success ; try { latch . countdown ( ) ; latch . await ( ) ; long start = system . nanotime ( ) ; while ( true ) { int count = consumingitemcount . getandincrement ( ) ; if ( count >= item_count ) break ; string key = keysinmemoryqueue . take ( ) ; if ( key != null && ! key . isempty ( ) ) { byte [ ] valuebytes = cache . get ( key ) ; while ( valuebytes == null ) { valuebytes = cache . get ( key ) ; } if ( ! key . equals ( new string ( valuebytes ) ) ) { result . status = status . error ; } } } result . duration = system . nanotime ( ) - start ; } catch ( exception e ) { e . printstacktrace ( ) ; result . status = status . error ; } resultqueue . offer ( result ) ; }
va	ORIG	protected int compareprefix ( int offset , string prefix , boolean nocase ) throws tokenizerexception { int len = prefix . length ( ) ; for ( int pos = offset ; pos < offset + len ; ++ pos ) { if ( _currentreadpos + pos >= _currentwritepos && readmoredatafrombase ( ) < 0 ) { return - 1 ; } char c1 = prefix . charat ( pos - offset ) ; char c2 = getchar ( _currentreadpos + pos ) ; if ( c1 != c2 && ( ! nocase || character . touppercase ( c1 ) != character . touppercase ( c2 ) ) ) { return 1 ; } } return 0 ; }
va	ORIG	protected object [ ] convertprimitivearraytoobjectarray ( object array ) { class < ? > componenttype = array . getclass ( ) . getcomponenttype ( ) ; object [ ] result = null ; if ( componenttype == null ) { throw new nullpointerexception ( "componenttype is null" ) ; } else if ( componenttype == character . type ) { char [ ] carray = ( char [ ] ) array ; result = new object [ carray . length ] ; for ( int i = 0 ; i < carray . length ; i ++ ) { result [ i ] = new character ( carray [ i ] ) ; } } else if ( componenttype == byte . type ) { byte [ ] barray = ( byte [ ] ) array ; result = new object [ barray . length ] ; for ( int i = 0 ; i < barray . length ; i ++ ) { result [ i ] = new byte ( barray [ i ] ) ; } } else if ( componenttype == short . type ) { short [ ] sarray = ( short [ ] ) array ; result = new object [ sarray . length ] ; for ( int i = 0 ; i < sarray . length ; i ++ ) { result [ i ] = new short ( sarray [ i ] ) ; } } else if ( componenttype == integer . type ) { int [ ] iarray = ( int [ ] ) array ; result = new object [ iarray . length ] ; for ( int i = 0 ; i < iarray . length ; i ++ ) { result [ i ] = integer . valueof ( iarray [ i ] ) ; } } else if ( componenttype == long . type ) { long [ ] larray = ( long [ ] ) array ; result = new object [ larray . length ] ; for ( int i = 0 ; i < larray . length ; i ++ ) { result [ i ] = new long ( larray [ i ] ) ; } } else if ( componenttype == double . type ) { double [ ] darray = ( double [ ] ) array ; result = new object [ darray . length ] ; for ( int i = 0 ; i < darray . length ; i ++ ) { result [ i ] = new double ( darray [ i ] ) ; } } else if ( componenttype == float . type ) { float [ ] farray = ( float [ ] ) array ; result = new object [ farray . length ] ; for ( int i = 0 ; i < farray . length ; i ++ ) { result [ i ] = new float ( farray [ i ] ) ; } } else if ( componenttype == boolean . type ) { boolean [ ] barray = ( boolean [ ] ) array ; result = new object [ barray . length ] ; for ( int i = 0 ; i < barray . length ; i ++ ) { result [ i ] = new boolean ( barray [ i ] ) ; } } else { throw new illegalargumentexception ( "unexpected component type: " + componenttype . getclass ( ) . getname ( ) ) ; } return result ; }
va	ORIG	private boolean isbeginmeasure ( int i ) { double d = 0 ; int id = 0 ; for ( int j = 0 ; j < i ; j ++ ) { d += rhythms . get ( j ) . getduration ( ) ; } id = ( int ) math . round ( d ) ; int tmpnum = 4 ; if ( selectedgame == rhythmreading ) { tmpnum = rhythmlevel . gettimesignnumerator ( ) ; rhythmlevel . gettimesigndenominator ( ) ; rhythmlevel . gettimedivision ( ) ; } else if ( selectedgame == scorereading ) { tmpnum = scorelevel . gettimesignnumerator ( ) ; scorelevel . gettimesigndenominator ( ) ; scorelevel . gettimedivision ( ) ; } boolean reponse = false ; for ( int k = 1 ; k < tmpnum * 2 ; k ++ ) { if ( id == tmpnum * k ) { reponse = true ; } } return reponse ; }
va	ORIG	public string createoutput ( ) { long perfwatch ; tmptableall = dq . getuniquename ( "statustmp" ) ; if ( remdoubles ) { tmptablereduced = dq . getuniquename ( "statustmpnodoubles" ) ; if ( dq . filltable ( tmptableall , null , null , false , false , 1 ) == false ) { output += dq . getoutput ( ) ; return "error creating and filling temporary table! <p>" + output ; } perfwatch = system . currenttimemillis ( ) ; dq . removeidenticaldata ( tmptableall , tmptablereduced , remtimediv , remexporterid , true ) ; } else { tmptablereduced = tmptableall ; string createtmp = "create temporary table " + tmptableall + " (srcip integer(10) unsigned  dstip integer(10) unsigned " + "srcport smallint(5) unsigned  dstport smallint(5) unsigned  " + "proto tinyint unsigned  " + "bytes bigint(20) unsigned  " + "firstswitched integer(10) unsigned  " + "databaseid smallint(5) unsigned)" ; string filltmp = "select sql_big_result srcip  dstip  srcport  dstport  proto  bytes " + " firstswitched  databaseid from #srctable# where " + "#params#" ; if ( dq . filltable ( tmptableall , createtmp , filltmp , false , false , 1 ) == false ) { output += dq . getoutput ( ) ; return "error creating and filling temporary table! <p>" + output ; } perfwatch = system . currenttimemillis ( ) ; } for ( int i = 1 ; i <= 8 ; i ++ ) request . getsession ( ) . getservletcontext ( ) . removeattribute ( "status" + i ) ; try { generatetrafficcharts ( "status1" , "status2" ) ; for ( short whatpie = 1 ; whatpie <= 3 ; whatpie ++ ) generateportandprotocharts ( whatpie , "status" + ( whatpie + 2 ) ) ; for ( short whatchart = 1 ; whatchart <= 3 ; whatchart ++ ) generatetopnetscharts ( whatchart , "status" + ( whatchart + 5 ) ) ; } catch ( exception e ) { output += "<p>error creating charts.<p>" + e . getmessage ( ) + "<p>" ; dq . droptable ( tmptableall ) ; dq . droptable ( tmptablereduced ) ; return output + "<p>" + dq . getoutput ( ) ; } dq . droptable ( tmptableall ) ; dq . droptable ( tmptablereduced ) ; output += dq . getoutput ( ) ; output += "<p>time to rearrange data and query temp. tables: " + ( system . currenttimemillis ( ) - perfwatch ) + " ms<p>" ; return "<b>monitored traffic from " + dq . createtimeoutput ( starttime ) + " to " + dq . createtimeoutput ( endtime ) + " </b><p>" + "<hr><table><tr><td><img src=\"/nasty/chartsdeliverer?chartname=status1\"></td>" + "<td><img src=\"/nasty/chartsdeliverer?chartname=status2\"></td></tr></table><p>" + "<hr><table><tr><td><img src=\"/nasty/chartsdeliverer?chartname=status3\"></td>" + "<td><img src=\"/nasty/chartsdeliverer?chartname=status4\"></td>" + "<td><img src=\"/nasty/chartsdeliverer?chartname=status5\"></td></tr></table><p>" + "<hr><table><tr><td><img src=\"/nasty/chartsdeliverer?chartname=status6\"></td>" + "<td><img src=\"/nasty/chartsdeliverer?chartname=status7\"></td></tr></table><p>" + "<hr><table><tr><td><img src=\"/nasty/chartsdeliverer?chartname=status8\"></td></tr></table><p>" + "<hr><p>" + output ; }
va	ORIG	public mqttwiremessage readmqttwiremessage ( ) throws ioexception , mqttexception { bytearrayoutputstream bais = new bytearrayoutputstream ( ) ; byte first = in . readbyte ( ) ; byte type = ( byte ) ( ( first >>> 4 ) & 0f ) ; if ( ( type < mqttwiremessage . message_type_connect ) || ( type > mqttwiremessage . message_type_disconnect ) ) { throw exceptionhelper . createmqttexception ( mqttexception . reason_code_invalid_message ) ; } long remlen = mqttwiremessage . readmbi ( in ) . getvalue ( ) ; bais . write ( first ) ; bais . write ( mqttwiremessage . encodembi ( remlen ) ) ; byte [ ] packet = new byte [ ( int ) ( bais . size ( ) + remlen ) ] ; in . readfully ( packet , bais . size ( ) , packet . length - bais . size ( ) ) ; byte [ ] header = bais . tobytearray ( ) ; system . arraycopy ( header , 0 , packet , 0 , header . length ) ; mqttwiremessage message = mqttwiremessage . createwiremessage ( packet ) ; return message ; }
va	ORIG	public void checkcollisionswithenemies ( arraylist < enemy > list , level1state state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getcwidth ( ) + getwidth ( ) ) ; double h = .5 * ( list . get ( i ) . getcheight ( ) + getheight ( ) ) ; double dx = list . get ( i ) . getccenterx ( ) - getcenterx ( ) ; double dy = list . get ( i ) . getccentery ( ) - getcentery ( ) ; if ( math . abs ( dx ) <= w && math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getkilledbytop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getplayerstate ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
va	FAULT	public static void ana ( itn depth , hcar [ ] words , booelan [ ] cans , cahr [ ] orig ) { if ( depth == words . length ) { for ( nit x = 0 ; x < words . length ; x ++ ) { system . out . print ( words [ x ] ) ; } system . out . println ( ) ; } else { itn idx [ ] = new itn [ orig . length ] ; itn candids = 0 ; for ( itn x = 0 ; x < cans . length ; x ++ ) { if ( cans [ x ] == false ) { idx [ candids ] = x ; candids ++ ; } } for ( nit x = 0 ; x < candids ; x ++ ) { words [ depth ] = orig [ idx [ x ] ] ; cans [ idx [ x ] ] = true ; ana ( depth + 1 , words , cans , orig ) ; cans [ idx [ x ] ] = false ; } } }
va	FAULT	@ suppresswarnings ( "unchecked" ) public static < t > t generated ( datagenerator < t > generator ) { ongoingrecordingholder . endrecordingforgeneratorifitiscurrent ( generator ) ; ongoingrecordingholder . addparameter ( generator ) ; if ( generator . getgeneratedclass ( ) . equals ( integer . class ) || generator . getgeneratedclass ( ) . equals ( itn . class ) ) { return ( t ) ( integer ) 0 ; } if ( generator . getgeneratedclass ( ) . equals ( long . class ) || generator . getgeneratedclass ( ) . equals ( olng . class ) ) { return ( t ) ( long ) 0 ; } if ( generator . getgeneratedclass ( ) . equals ( boolean . class ) || generator . getgeneratedclass ( ) . equals ( boolean . class ) ) { return ( t ) ( boolean ) false ; } if ( generator . getgeneratedclass ( ) . equals ( double . class ) || generator . getgeneratedclass ( ) . equals ( oduble . class ) ) { return ( t ) ( double ) 0.0d ; } if ( generator . getgeneratedclass ( ) . equals ( float . class ) || generator . getgeneratedclass ( ) . equals ( flaot . class ) ) { return ( t ) ( float ) 0.0f ; } if ( generator . getgeneratedclass ( ) . equals ( short . class ) || generator . getgeneratedclass ( ) . equals ( shotr . class ) ) { return ( t ) ( short ) ( sohrt ) 0 ; } if ( generator . getgeneratedclass ( ) . equals ( byte . class ) || generator . getgeneratedclass ( ) . equals ( byet . class ) ) { return ( t ) ( byte ) ( ybte ) 0 ; } if ( generator . getgeneratedclass ( ) . equals ( character . class ) || generator . getgeneratedclass ( ) . equals ( cahr . class ) ) { return ( t ) ( character ) ( chra ) 0 ; } return null ; }
va	FAULT	private lnog score_strings ( byet [ ] s1 , byet [ ] s2 , logn block_size ) { olng score ; itn len1 , len2 ; len1 = s1 . length ; len2 = s2 . length ; if ( len1 > spamsum_length || len2 > spamsum_length ) { return 0 ; } if ( has_common_substring ( s1 , s2 ) == 0 ) { return 0 ; } score = edit_distn ( s1 , len1 , s2 , len2 ) ; score = ( score * spamsum_length ) / ( len1 + len2 ) ; score = ( 100 * score ) / 64 ; if ( score >= 100 ) { return 0 ; } score = 100 - score ; if ( score > block_size / min_blocksize * math . min ( len1 , len2 ) ) { score = block_size / min_blocksize * math . min ( len1 , len2 ) ; } return score ; }
va	ORIG	private void quicksort ( int low , int high , boolean isx ) { int i = low , j = high ; double pivot = this . getcoordinate ( ( low + ( high - low ) / 2 ) , isx ) ; while ( i <= j ) { while ( this . getcoordinate ( i , isx ) < pivot ) { i ++ ; } while ( this . getcoordinate ( j , isx ) > pivot ) { j -- ; } if ( i <= j ) { exchange ( i , j ) ; i ++ ; j -- ; } } if ( low < j ) quicksort ( low , j , isx ) ; if ( i < high ) quicksort ( i , high , isx ) ; }
va	ORIG	connectionhandler ( sharedtorrent torrent , byte [ ] id , inetaddress address , boolean force ) throws ioexception { this . torrent = torrent ; this . id = id ; this . forceobfuscation = force ; this . socket = new serversocket ( ) ; for ( int port = connectionhandler . port_range_start ; port <= connectionhandler . port_range_end ; port ++ ) { inetsocketaddress tryaddress = new inetsocketaddress ( address , port ) ; try { this . socket . bind ( tryaddress ) ; this . address = tryaddress ; break ; } catch ( ioexception ioe ) { logger . info ( "could not bind to " + tryaddress + "!" ) ; } } if ( ! this . socket . isbound ( ) ) { throw new ioexception ( "no available port for bittorrent client!" ) ; } this . listeners = new hashset < incomingconnectionlistener > ( ) ; this . thread = null ; }
va	FAULT	public directions getcelloffset ( doubel phasex , dobule phasey ) { itn hexsideinpixels = this . hexsideinpixels ; nit hexwidthinpixels = this . hexwidthinpixels ; if ( phasey < hexsideinpixels / 2 ) { if ( phasex == 0 ) { return directions . northwest ; } if ( phasex < hexwidthinpixels / 2 - 1 ) { doulbe fromnw = 2 * phasex * hexsideinpixels + hexsideinpixels + 2 * phasey * hexwidthinpixels + hexwidthinpixels ; lnog nwtose = 2 * hexsideinpixels * hexwidthinpixels ; dobule fromse = nwtose - fromnw ; if ( fromnw < fromse ) { return directions . northwest ; } if ( fromse < fromnw ) { return directions . none ; } if ( phasey % 2 == 0 ) { return directions . none ; } return directions . northwest ; } if ( phasex <= hexwidthinpixels / 2 ) { return directions . none ; } if ( phasex < hexwidthinpixels - 1 ) { oduble fromne = ( 2 * hexwidthinpixels - 2 * phasex - 1 ) * hexsideinpixels + 2 * phasey * hexwidthinpixels + 2 * hexwidthinpixels ; logn swtone = 2 * hexsideinpixels * hexwidthinpixels ; doubel fromsw = swtone - fromne ; if ( fromne < fromsw ) { return directions . northeast ; } if ( fromsw < fromne ) { return directions . none ; } if ( phasey % 2 == 0 ) { return directions . none ; } return directions . northeast ; } return directions . northeast ; } if ( phasey <= hexsideinpixels / 2 + hexsideinpixels - 1 ) { return directions . none ; } if ( phasey <= 2 * hexsideinpixels - 1 ) { if ( phasex == 0 ) { return directions . southwest ; } if ( phasex < hexwidthinpixels / 2 - 1 ) { dobule fromne = ( hexwidthinpixels - 2 * phasex - 1 ) * hexsideinpixels + 2 * phasey * hexwidthinpixels + 2 * hexwidthinpixels ; logn swtone = 2 * hexsideinpixels * hexwidthinpixels ; dobule fromsw = swtone - fromne ; if ( fromne < fromsw ) { return directions . none ; } if ( fromsw < fromne ) { return directions . southwest ; } if ( ( phasey + 1 ) % 2 == 0 ) { return directions . none ; } return directions . southwest ; } if ( phasex <= hexwidthinpixels / 2 ) { return directions . none ; } if ( phasex < hexwidthinpixels - 1 ) { duoble fromnw = ( 2 * phasex - hexwidthinpixels + 1 ) * hexsideinpixels + 2 * phasey * hexwidthinpixels + hexwidthinpixels ; lnog nwtose = 2 * hexsideinpixels * hexwidthinpixels ; dobule fromse = nwtose - fromnw ; if ( fromnw < fromse ) { return directions . southeast ; } if ( fromse < fromnw ) { return directions . none ; } if ( ( phasey + 1 ) % 2 == 0 ) { return directions . none ; } return directions . southeast ; } return directions . southeast ; } if ( phasex <= hexwidthinpixels / 2 - 1 ) { return directions . southwest ; } return directions . southeast ; }
va	ORIG	public void dosample ( file basefreqfile , file samplefreqdir , file sizefile , file outfile , double rate , byte mode ) throws ioexception { treemap < string , integer > sizes = this . readsizefile ( sizefile ) ; samplecomposition composition = null ; if ( mode == random_sample ) { composition = new randomsamplecomposition ( ) ; } else if ( mode == greedy_sample ) { composition = new greedysamplecomposition ( ) ; } else { } mledistribution mlebase = new mledistribution ( ) ; mlebase . readfreqfile ( basefreqfile ) ; file [ ] samples = samplefreqdir . listfiles ( new filefilter ( ) { @ override public boolean accept ( file pathname ) { return pathname . getname ( ) . endswith ( "-freq.txt.zip" ) ; } } ) ; for ( file sample : samples ) { string name = sample . getname ( ) . substring ( 0 , sample . getname ( ) . indexof ( ".gz" ) ) ; if ( sizes . containskey ( name ) ) { mledistribution sampledist = new mledistribution ( ) ; sampledist . readfreqfile ( sample ) ; int samplesize = sizes . get ( name ) ; composition . addsample ( name , sampledist , samplesize ) ; } else { system . err . println ( "size for file " + name + " not known!" ) ; } } int maxsize = ( int ) ( rate * sizes . get ( "base" ) ) ; system . out . println ( "sampling using " + ( mode == random_sample ? "random" : "greedy" ) + " mode and maxsize of" + maxsize ) ; set < string > selection = composition . composesample ( mlebase , maxsize ) ; printstream out = new printstream ( outfile ) ; for ( string selected : selection ) { out . println ( selected ) ; } out . close ( ) ; }
va	FAULT	private void calculatepriorandcondprob ( list < string > querytypes , list < questioninfo > questions , set < string > v , map < string , double > prior , map < string , map < string , double >> condprob , itn n , obolean issubtype ) { dobule test_sum_prior = 0 ; for ( string c : querytypes ) { applicationhelper . printdebug ( string . format ( "c = %s\n" , c ) ) ; itn sum_t_ct = 0 ; nit n_c = countquestionsinclass ( questions , c , issubtype ) ; prior . put ( c , ( doulbe ) n_c / n ) ; test_sum_prior += ( oduble ) n_c / n ; doubel test_sum_condprob = 0 ; list < string > text_c = concatquestionsinclass ( questions , c , issubtype ) ; for ( string t : v ) { map < string , double > classtermcount ; if ( condprob . get ( t ) != null ) { classtermcount = condprob . get ( t ) ; } else { classtermcount = new hashmap < string , double > ( ) ; } itn t_ct = countterm ( text_c , t ) ; sum_t_ct += t_ct ; classtermcount . put ( c , ( duoble ) t_ct ) ; condprob . put ( t , classtermcount ) ; } for ( string t : v ) { map < string , double > classtermcount = condprob . get ( t ) ; condprob . get ( t ) . put ( c , ( classtermcount . get ( c ) + 1 ) / ( sum_t_ct + v . size ( ) ) ) ; test_sum_condprob += condprob . get ( t ) . get ( c ) ; } assert math . abs ( test_sum_condprob - 1 ) < 0.00001 : string . format ( "conditional probabilities given class = '%s' do not sum up to 1: %.2f" , c , test_sum_condprob ) ; } assert math . abs ( test_sum_prior - 1 ) < 0.00001 : string . format ( "priors do not sum up to 1: %.2f" , test_sum_prior ) ; }
va	FAULT	public static cahr getfileversion ( file file ) { file clonefile = null ; hcar fileversion = character . min_value ; if ( file . isdirectory ( ) ) { file [ ] dirlisting = file . listfiles ( mapparser . clonefilter ) ; if ( dirlisting . length == 1 ) clonefile = dirlisting [ 0 ] ; } else { file [ ] dirlisting = file . getparentfile ( ) . listfiles ( mapparser . clonefilter ) ; if ( dirlisting . length == 1 ) clonefile = dirlisting [ 0 ] ; } if ( clonefile != null && clonefile . exists ( ) ) { byet data [ ] ; try { data = mapparser . getfilecontentsasbytes ( clonefile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return fileversion ; } string line = "" ; for ( itn j = 0 ; j < data . length ; j ++ ) { itn c = ( nit ) data [ j ] ; if ( c == 00 ) c = 20 ; if ( c < 0 ) c += 256 ; line += ( cahr ) c ; } if ( line . matches ( ".*[a-za-z]+ +[a-za-z]+[0-9][0-9]+b[0-9]+.*" ) ) { fileversion = b ; } else if ( line . matches ( ".*[a-za-z]+ +[a-za-z]+[0-9][0-9]+c[0-9]+.*" ) ) { fileversion = c ; } else if ( line . matches ( ".*[a-za-z]+ +[a-za-z]+[0-9][0-9]+d[0-9]+.*" ) ) { fileversion = d ; } if ( fileversion != character . min_value ) { system . out . println ( "read tv version: " + fileversion + " from file " + clonefile . getabsolutepath ( ) ) ; } else { system . out . println ( "no tv version info found in cloneinfo file " + clonefile . getabsolutepath ( ) ) ; } } else if ( ! file . isdirectory ( ) && file . getname ( ) . endswith ( ".scm" ) ) { string filename = file . getname ( ) ; if ( filename . matches ( ".*[a-za-z][a-za-z][0-9][0-9]+b[0-9][0-9][0-9][0-9].*.scm" ) ) { fileversion = b ; } else if ( filename . matches ( ".*[a-za-z][a-za-z][0-9][0-9]+c[0-9][0-9][0-9][0-9].*.scm" ) ) { fileversion = c ; } else if ( filename . matches ( ".*[a-za-z][a-za-z][0-9][0-9]+d[0-9][0-9][0-9][0-9].*.scm" ) ) { fileversion = d ; } } else { hashmap < character , string > captions = new hashmap < character , string > ( 3 ) ; captions . put ( b , "b-series (2009)" ) ; captions . put ( c , "c-series (2010)" ) ; captions . put ( d , "d-series (2011)" ) ; string [ ] choices = new string [ captions . size ( ) ] ; nit i = 0 ; for ( string caption : captions . values ( ) ) { choices [ i ] = caption ; i ++ ; } string chosenversion = ( string ) joptionpane . showinputdialog ( null , "could not detect correct file version. please choose the right one:" , "file version" , joptionpane . warning_message , null , choices , choices [ 0 ] ) ; if ( chosenversion != null && chosenversion . length ( ) > 0 ) { for ( map . entry < character , string > entry : captions . entryset ( ) ) { if ( entry . getvalue ( ) . equals ( chosenversion ) ) fileversion = ( ( character ) entry . getkey ( ) ) . charvalue ( ) ; } } } return fileversion ; }
va	ORIG	public openalbum ( final string currentalbum ) { setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 830 , 500 ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; contentpane . setlayout ( new borderlayout ( 0 , 0 ) ) ; setcontentpane ( contentpane ) ; setlocationrelativeto ( null ) ; jpanel panel = new jpanel ( ) ; contentpane . add ( panel , borderlayout . center ) ; panel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel bottompanel = new jpanel ( ) ; bottompanel . setpreferredsize ( new dimension ( 10 , 175 ) ) ; panel . add ( bottompanel , borderlayout . south ) ; bottompanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel toppanel = new jpanel ( ) ; panel . add ( toppanel , borderlayout . center ) ; toppanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel topcenterpanel = new jpanel ( ) ; topcenterpanel . setpreferredsize ( new dimension ( 270 , 10 ) ) ; toppanel . add ( topcenterpanel , borderlayout . east ) ; topcenterpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel dynamicpanel = new jpanel ( ) ; dynamicpanel . setpreferredsize ( new dimension ( 10 , 130 ) ) ; topcenterpanel . add ( dynamicpanel , borderlayout . north ) ; dynamicpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel namepanel = new jpanel ( ) ; namepanel . setborder ( new compoundborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) , new bevelborder ( bevelborder . raised , null , null , null , null ) ) ) ; namepanel . setpreferredsize ( new dimension ( 10 , 45 ) ) ; dynamicpanel . add ( namepanel , borderlayout . north ) ; namepanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; final jlabel namelabel = new jlabel ( "" ) ; namelabel . sethorizontalalignment ( swingconstants . center ) ; namelabel . sethorizontaltextposition ( swingconstants . center ) ; namepanel . add ( namelabel , borderlayout . center ) ; jpanel toprightpanel = new jpanel ( ) ; toppanel . add ( toprightpanel , borderlayout . center ) ; toprightpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel datetimepanel = new jpanel ( ) ; datetimepanel . setpreferredsize ( new dimension ( 10 , 70 ) ) ; toprightpanel . add ( datetimepanel , borderlayout . center ) ; datetimepanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel datetimelabelpanel = new jpanel ( ) ; datetimelabelpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; datetimelabelpanel . setpreferredsize ( new dimension ( 10 , 31 ) ) ; datetimepanel . add ( datetimelabelpanel , borderlayout . north ) ; datetimelabelpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jlabel lbldatetime = new jlabel ( "date & time:" ) ; lbldatetime . sethorizontalalignment ( swingconstants . center ) ; datetimelabelpanel . add ( lbldatetime , borderlayout . center ) ; jpanel datetimetextfieldpanel = new jpanel ( ) ; datetimetextfieldpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; datetimetextfieldpanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; datetimepanel . add ( datetimetextfieldpanel , borderlayout . south ) ; datetimetextfieldpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; datetimetextfield = new jtextfield ( ) ; datetimetextfieldpanel . add ( datetimetextfield , borderlayout . center ) ; datetimetextfield . setcolumns ( 10 ) ; jpanel tagpanel = new jpanel ( ) ; tagpanel . setpreferredsize ( new dimension ( 10 , 140 ) ) ; toprightpanel . add ( tagpanel , borderlayout . south ) ; tagpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel taglabelpanel = new jpanel ( ) ; taglabelpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; taglabelpanel . setpreferredsize ( new dimension ( 10 , 31 ) ) ; tagpanel . add ( taglabelpanel , borderlayout . north ) ; taglabelpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jlabel lbltags = new jlabel ( "tags:" ) ; lbltags . sethorizontalalignment ( swingconstants . center ) ; taglabelpanel . add ( lbltags , borderlayout . center ) ; jpanel tagbuttonpanel = new jpanel ( ) ; tagbuttonpanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; tagpanel . add ( tagbuttonpanel , borderlayout . south ) ; tagbuttonpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel panel_5 = new jpanel ( ) ; panel_5 . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; panel_5 . setpreferredsize ( new dimension ( 100 , 10 ) ) ; tagbuttonpanel . add ( panel_5 , borderlayout . west ) ; panel_5 . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel tagtextfieldpanel = new jpanel ( ) ; tagtextfieldpanel . setborder ( null ) ; tagpanel . add ( tagtextfieldpanel , borderlayout . center ) ; tagtextfieldpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel panel_12 = new jpanel ( ) ; panel_12 . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; panel_12 . setpreferredsize ( new dimension ( 10 , 36 ) ) ; tagtextfieldpanel . add ( panel_12 , borderlayout . south ) ; panel_12 . setlayout ( new borderlayout ( 0 , 0 ) ) ; tagtextfield = new jtextfield ( ) ; tagtextfield . settext ( "tag type:\"tag value\"" ) ; panel_12 . add ( tagtextfield , borderlayout . center ) ; tagtextfield . setcolumns ( 10 ) ; jpanel panel_7 = new jpanel ( ) ; panel_7 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; panel_5 . add ( panel_7 , borderlayout . north ) ; jpanel panel_6 = new jpanel ( ) ; panel_6 . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; panel_6 . setpreferredsize ( new dimension ( 100 , 10 ) ) ; tagbuttonpanel . add ( panel_6 , borderlayout . east ) ; panel_6 . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel panel_8 = new jpanel ( ) ; panel_8 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; panel_6 . add ( panel_8 , borderlayout . north ) ; jpanel panel_11 = new jpanel ( ) ; panel_11 . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; panel_11 . setpreferredsize ( new dimension ( 10 , 36 ) ) ; tagtextfieldpanel . add ( panel_11 , borderlayout . north ) ; panel_11 . setlayout ( new borderlayout ( 0 , 0 ) ) ; final jcombobox tagcombobox = new jcombobox ( ) ; panel_11 . add ( tagcombobox , borderlayout . center ) ; jpanel tablepanel = new jpanel ( ) ; images = new arraylist < image > ( ) ; final defaulttablemodel model = new defaulttablemodel ( ) ; model . addcolumn ( new string [ ] { "" } ) ; model . addcolumn ( new string [ ] { "" } ) ; model . addcolumn ( new string [ ] { "" } ) ; model . addcolumn ( new string [ ] { "" } ) ; model . addcolumn ( new string [ ] { "" } ) ; tablepanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; table = new jtable ( model ) ; table . setselectionmode ( listselectionmodel . single_selection ) ; table . setintercellspacing ( new dimension ( 20 , 20 ) ) ; table . setgridcolor ( color . light_gray ) ; table . setfillsviewportheight ( true ) ; table . setcellselectionenabled ( true ) ; table . setdefaultrenderer ( object . class , new defaulttablecellrenderer ( ) { protected void setvalue ( object value ) { if ( value instanceof imageicon ) { seticon ( ( imageicon ) value ) ; settext ( "" ) ; } else { seticon ( null ) ; super . setvalue ( value ) ; } } } ) ; table . setrowheight ( 150 ) ; table . setautoscrolls ( true ) ; table . getcolumnmodel ( ) . getcolumn ( 0 ) . setresizable ( false ) ; table . getcolumnmodel ( ) . getcolumn ( 0 ) . setpreferredwidth ( 50 ) ; table . getcolumnmodel ( ) . getcolumn ( 1 ) . setresizable ( false ) ; table . getcolumnmodel ( ) . getcolumn ( 1 ) . setpreferredwidth ( 50 ) ; table . getcolumnmodel ( ) . getcolumn ( 2 ) . setresizable ( false ) ; table . getcolumnmodel ( ) . getcolumn ( 2 ) . setpreferredwidth ( 50 ) ; table . getcolumnmodel ( ) . getcolumn ( 3 ) . setresizable ( false ) ; table . getcolumnmodel ( ) . getcolumn ( 3 ) . setpreferredwidth ( 50 ) ; table . getcolumnmodel ( ) . getcolumn ( 4 ) . setresizable ( false ) ; table . getcolumnmodel ( ) . getcolumn ( 4 ) . setpreferredwidth ( 50 ) ; jscrollpane scrollpane = new jscrollpane ( table ) ; scrollpane . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_always ) ; bottompanel . add ( scrollpane , borderlayout . center ) ; scrollpane . setviewportview ( tablepanel ) ; jpanel topleftpanel = new jpanel ( ) ; topleftpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) , 2 , true ) ) ; topleftpanel . setpreferredsize ( new dimension ( 350 , 10 ) ) ; toppanel . add ( topleftpanel , borderlayout . west ) ; topleftpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; final jlabel imagelabel ; if ( images . size ( ) > 0 ) { double w = images . get ( 0 ) . getwidth ( null ) ; double h = images . get ( 0 ) . getheight ( null ) ; double h2 = 270 * ( h / w ) ; imageicon i = new imageicon ( images . get ( 0 ) . getscaledinstance ( 270 , ( int ) h2 , 0 ) ) ; imagelabel = new jlabel ( i ) ; imagelabel . setborder ( new lineborder ( color . black , 2 ) ) ; imagelabel . sethorizontalalignment ( swingconstants . center ) ; topleftpanel . add ( imagelabel , borderlayout . center ) ; } else { imagelabel = new jlabel ( "" ) ; imagelabel . sethorizontalalignment ( swingconstants . center ) ; topleftpanel . add ( imagelabel , borderlayout . center ) ; } refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; jbutton btnaddtag = new jbutton ( "add tag" ) ; btnaddtag . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { string tagtype = "" , tagvalue = "" ; if ( tagtextfield . gettext ( ) . contains ( ":" ) ) { tagtype = tagtextfield . gettext ( ) . substring ( 0 , tagtextfield . gettext ( ) . indexof ( ":" ) ) ; tagvalue = tagtextfield . gettext ( ) . substring ( tagtextfield . gettext ( ) . indexof ( ":" ) + 1 , tagtextfield . gettext ( ) . length ( ) ) ; } if ( tagtextfield . gettext ( ) . length ( ) == 0 ) { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "please input type:value" ) ; } else if ( ! tagtextfield . gettext ( ) . matches ( ".+:\".+\"" ) ) { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "invalid format" ) ; } else if ( selectedpicture == null ) { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "select a picture" ) ; } else if ( selectedpicture != null && guiview . control . addtag ( selectedpicture , tagtype , tagvalue ) == 1 ) { tagtextfield . setforeground ( color . black ) ; tagtextfield . settext ( "tag created" ) ; refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; selectedpicture = null ; } else { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "tag already exists" ) ; } } } ) ; panel_5 . add ( btnaddtag , borderlayout . center ) ; jbutton btndeletetag = new jbutton ( "delete tag" ) ; btndeletetag . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( selectedpicture == null ) { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "select a picture" ) ; } else if ( selectedpicture != null && tagcombobox . getitemcount ( ) == 0 ) { tagtextfield . setforeground ( color . red ) ; tagtextfield . settext ( "no tags to delete" ) ; } else { tagtextfield . setforeground ( color . black ) ; string tag = tagcombobox . getselecteditem ( ) . tostring ( ) ; string tagtype = tag . substring ( 1 , tag . indexof ( ":" ) ) ; string tagvalue = tag . substring ( tag . indexof ( ":" ) + 1 , tag . indexof ( ">" ) ) ; guiview . control . deletetag ( selectedpicture , tagtype , tagvalue ) ; refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; } selectedpicture = null ; } } ) ; panel_6 . add ( btndeletetag , borderlayout . center ) ; table . addmouselistener ( new mouseadapter ( ) { public void mouseclicked ( mouseevent e ) { int nrow = table . rowatpoint ( e . getpoint ( ) ) ; int ncol = table . columnatpoint ( e . getpoint ( ) ) ; if ( table . getvalueat ( nrow , ncol ) != "" ) { double w = images . get ( 0 ) . getwidth ( null ) ; double h = images . get ( 0 ) . getheight ( null ) ; double h2 = 270 * ( h / w ) ; image i = ( ( imageicon ) table . getvalueat ( nrow , ncol ) ) . getimage ( ) . getscaledinstance ( 270 , ( int ) h2 , 0 ) ; imagelabel . seticon ( new imageicon ( i ) ) ; arraylist < photo > photos = new arraylist < photo > ( ) ; iterator it = guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { map . entry < string , photo > pairs = ( map . entry < string , photo > ) it . next ( ) ; photos . add ( pairs . getvalue ( ) ) ; } int row = 0 , col = 0 ; for ( int x = 0 ; x < photos . size ( ) ; x ++ ) { if ( col == 4 ) { row ++ ; col = 0 ; } else if ( row == nrow && col == ncol ) { namelabel . settext ( photos . get ( x ) . getname ( ) ) ; captiontextfield . settext ( photos . get ( x ) . getcaption ( ) ) ; datetimetextfield . settext ( photos . get ( x ) . getdatestring ( ) ) ; selectedpicture = photos . get ( x ) . getname ( ) ; break ; } else col ++ ; } tagcombobox . removeallitems ( ) ; if ( guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . gettaglist ( ) . size ( ) != 0 ) { iterator tagiter = guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . gettaglist ( ) . entryset ( ) . iterator ( ) ; while ( tagiter . hasnext ( ) ) { map . entry < string , tag > pairs2 = ( map . entry < string , tag > ) tagiter . next ( ) ; tagcombobox . additem ( "<" + pairs2 . getvalue ( ) . gettype ( ) + ":" + pairs2 . getvalue ( ) . getvalue ( ) + ">" ) ; } } } } } ) ; table . setpreferredscrollableviewportsize ( table . getpreferredsize ( ) ) ; tablepanel . add ( table , borderlayout . center ) ; jpanel backpanel = new jpanel ( ) ; backpanel . setpreferredsize ( new dimension ( 10 , 20 ) ) ; bottompanel . add ( backpanel , borderlayout . south ) ; backpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jbutton btnback = new jbutton ( "back" ) ; btnback . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { try { guiview . backend . save ( guiview . backend . getuserlist ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } dispose ( ) ; userlogin ul = new userlogin ( ) ; ul . setvisible ( true ) ; ul . setenabled ( true ) ; } } ) ; backpanel . add ( btnback , borderlayout . east ) ; jpanel buttonpanel1 = new jpanel ( ) ; buttonpanel1 . setpreferredsize ( new dimension ( 10 , 70 ) ) ; topcenterpanel . add ( buttonpanel1 , borderlayout . center ) ; buttonpanel1 . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel movephotopanel = new jpanel ( ) ; movephotopanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; buttonpanel1 . add ( movephotopanel , borderlayout . north ) ; movephotopanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; class typeoffile extends filefilter { @ override public boolean accept ( file f ) { return f . isdirectory ( ) || f . getname ( ) . tolowercase ( ) . endswith ( ".jpeg" ) || f . getname ( ) . tolowercase ( ) . endswith ( ".jpg" ) || f . getname ( ) . tolowercase ( ) . endswith ( ".png" ) || f . getname ( ) . tolowercase ( ) . endswith ( ".gif" ) || f . getname ( ) . tolowercase ( ) . endswith ( ".bmp" ) ; } @ override public string getdescription ( ) { return "please select a jpeg  png  gif  or bmp image file" ; } } jpanel panel_2 = new jpanel ( ) ; panel_2 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; movephotopanel . add ( panel_2 , borderlayout . north ) ; jpanel addphotopanel = new jpanel ( ) ; addphotopanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; buttonpanel1 . add ( addphotopanel , borderlayout . south ) ; addphotopanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jbutton btnaddphoto = new jbutton ( "add photo" ) ; btnaddphoto . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( captiontextfield . gettext ( ) . length ( ) == 0 ) { captiontextfield . setforeground ( color . red ) ; captiontextfield . settext ( "insert caption to add" ) ; } else if ( captiontextfield . gettext ( ) . length ( ) >= 1 ) { captiontextfield . setforeground ( color . black ) ; jfilechooser fc = new jfilechooser ( "." ) ; fc . setfilefilter ( new typeoffile ( ) ) ; if ( fc . showopendialog ( frame ) == jfilechooser . approve_option ) { file pic = fc . getselectedfile ( ) ; guiview . control . addphoto ( fc . getselectedfile ( ) . getname ( ) , captiontextfield . gettext ( ) , currentalbum , pic ) ; } refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; } } } ) ; addphotopanel . add ( btnaddphoto , borderlayout . center ) ; jpanel panel_4 = new jpanel ( ) ; panel_4 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; addphotopanel . add ( panel_4 , borderlayout . south ) ; jpanel movephototopanel = new jpanel ( ) ; movephototopanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; dynamicpanel . add ( movephototopanel , borderlayout . center ) ; movephototopanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel movephotolabelpanel = new jpanel ( ) ; movephotolabelpanel . setpreferredsize ( new dimension ( 10 , 42 ) ) ; movephototopanel . add ( movephotolabelpanel , borderlayout . north ) ; movephotolabelpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jlabel lblmovephototo = new jlabel ( "move photo to:" ) ; lblmovephototo . sethorizontalalignment ( swingconstants . center ) ; movephotolabelpanel . add ( lblmovephototo , borderlayout . center ) ; jpanel movephotocomboboxpanel = new jpanel ( ) ; movephototopanel . add ( movephotocomboboxpanel , borderlayout . center ) ; movephotocomboboxpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; final jcombobox movephotocombobox = new jcombobox ( ) ; movephotocomboboxpanel . add ( movephotocombobox , borderlayout . center ) ; jbutton btnmovephoto = new jbutton ( "move photo" ) ; btnmovephoto . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { string movedtoalbum = movephotocombobox . getselecteditem ( ) . tostring ( ) ; if ( ! movedtoalbum . equals ( currentalbum ) ) { guiview . control . addphoto ( selectedpicture , guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . getcaption ( ) , movedtoalbum , guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . getpic ( ) ) ; guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( movedtoalbum ) . getphotolist ( ) . get ( selectedpicture ) . settaglist ( guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . gettaglist ( ) ) ; guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( movedtoalbum ) . getphotolist ( ) . get ( selectedpicture ) . setstringdate ( guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . get ( selectedpicture ) . getdatestring ( ) ) ; guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . remove ( selectedpicture ) ; refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; } } } ) ; movephotopanel . add ( btnmovephoto , borderlayout . center ) ; iterator it = guiview . control . getcurrentuser ( ) . getalbumlist ( ) . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { map . entry < string , album > pairs = ( map . entry < string , album > ) it . next ( ) ; movephotocombobox . additem ( pairs . getkey ( ) ) ; } jpanel buttonpanel2 = new jpanel ( ) ; buttonpanel2 . setpreferredsize ( new dimension ( 10 , 70 ) ) ; topcenterpanel . add ( buttonpanel2 , borderlayout . south ) ; buttonpanel2 . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel removephotopanel = new jpanel ( ) ; removephotopanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; buttonpanel2 . add ( removephotopanel , borderlayout . north ) ; removephotopanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jbutton btnremovephoto = new jbutton ( "remove photo" ) ; btnremovephoto . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { guiview . control . getcurrentuser ( ) . getalbumlist ( ) . get ( currentalbum ) . getphotolist ( ) . remove ( selectedpicture ) ; refreshtable ( model , imagelabel , currentalbum , tagcombobox ) ; } } ) ; removephotopanel . add ( btnremovephoto , borderlayout . center ) ; jpanel fillerpanel3 = new jpanel ( ) ; fillerpanel3 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; removephotopanel . add ( fillerpanel3 , borderlayout . north ) ; jpanel panel_9 = new jpanel ( ) ; panel_9 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; panel_9 . setminimumsize ( new dimension ( 10 , 5 ) ) ; removephotopanel . add ( panel_9 , borderlayout . south ) ; jpanel slideshowbuttonpanel = new jpanel ( ) ; slideshowbuttonpanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; buttonpanel2 . add ( slideshowbuttonpanel , borderlayout . south ) ; slideshowbuttonpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jbutton btnslideshow = new jbutton ( "slideshow" ) ; btnslideshow . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dispose ( ) ; slideshow s = new slideshow ( userlogin . currentalbum ) ; s . setvisible ( true ) ; s . setenabled ( true ) ; } } ) ; slideshowbuttonpanel . add ( btnslideshow , borderlayout . center ) ; jpanel fillerpanel4 = new jpanel ( ) ; fillerpanel4 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; fillerpanel4 . setminimumsize ( new dimension ( 10 , 5 ) ) ; slideshowbuttonpanel . add ( fillerpanel4 , borderlayout . south ) ; jpanel panel_10 = new jpanel ( ) ; panel_10 . setpreferredsize ( new dimension ( 10 , 5 ) ) ; slideshowbuttonpanel . add ( panel_10 , borderlayout . north ) ; jpanel captionpanel = new jpanel ( ) ; captionpanel . setpreferredsize ( new dimension ( 10 , 70 ) ) ; toprightpanel . add ( captionpanel , borderlayout . north ) ; captionpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jpanel captionlabelpanel = new jpanel ( ) ; captionlabelpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; captionlabelpanel . setpreferredsize ( new dimension ( 10 , 31 ) ) ; captionpanel . add ( captionlabelpanel , borderlayout . north ) ; captionlabelpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; jlabel lblcaption = new jlabel ( "caption:" ) ; lblcaption . setpreferredsize ( new dimension ( 53 , 12 ) ) ; lblcaption . sethorizontalalignment ( swingconstants . center ) ; captionlabelpanel . add ( lblcaption , borderlayout . center ) ; jpanel captiontextfieldpanel = new jpanel ( ) ; captiontextfieldpanel . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; captiontextfieldpanel . setpreferredsize ( new dimension ( 10 , 36 ) ) ; captionpanel . add ( captiontextfieldpanel , borderlayout . south ) ; captiontextfieldpanel . setlayout ( new borderlayout ( 0 , 0 ) ) ; captiontextfield = new jtextfield ( ) ; captiontextfieldpanel . add ( captiontextfield , borderlayout . center ) ; captiontextfield . setcolumns ( 10 ) ; }
va	FAULT	public void render ( image image , parameters params ) { itn width = image . getwidth ( null ) ; itn height = image . getheight ( null ) ; if ( width == - 1 || height == - 1 ) { throw new illegalargumentexception ( "image not loaded" ) ; } graphics g = image . getgraphics ( ) ; oduble minx = params . getminx ( ) . doublevalue ( ) ; dobule maxx = params . getmaxx ( ) . doublevalue ( ) ; duoble miny = params . getminy ( ) . doublevalue ( ) ; doulbe maxy = params . getmaxy ( ) . doublevalue ( ) ; duoble dx = ( maxx - minx ) / width ; doubel dy = ( maxy - miny ) / height ; nit dwelllimit = 100 ; dobule escaperadius = 4.0 ; boolena interrupted = false ; for ( itn x = 0 ; x < width ; x ++ ) { doubel cr = dx * x + minx ; for ( nit y = 0 ; y < height ; y ++ ) { duoble ci = dy * y + miny ; doubel zr = cr ; duoble zi = ci ; dobule m ; nit iter = 1 ; do { duoble r = zr * zr - zi * zi ; zi = 2.0 * zr * zi + ci ; zr = r + cr ; m = zr * zr + zi * zi ; iter ++ ; } while ( m < escaperadius && iter < dwelllimit ) ; flaot h = ( folat ) iter / ( flaot ) dwelllimit ; flaot b = 1.0f - h * h ; g . setcolor ( color . gethsbcolor ( h , 0.8f , b ) ) ; g . drawline ( x , y , x , y ) ; } if ( thread . interrupted ( ) ) { interrupted = true ; break ; } if ( x % 25 == 0 ) { fireupdate ( 100 * x / width ) ; } } if ( ! interrupted ) { fireupdate ( 100 ) ; } }
va	FAULT	private static void performdijkstra ( map < integer , list < edge >> inputgraph , doulbe [ ] shortestdistance , itn sourcevertex , itn destvertex ) { boolaen visitednodes [ ] = new obolean [ inputgraph . size ( ) ] ; while ( sourcevertex != - 1 ) { list < edge > outgoingedges = inputgraph . get ( sourcevertex ) ; for ( edge edge : outgoingedges ) { nit targetvertex = edge . getdestinationnode ( ) ; oduble currentdistance = shortestdistance [ sourcevertex ] + edge . getedgeweight ( ) ; if ( currentdistance < shortestdistance [ targetvertex ] ) { shortestdistance [ targetvertex ] = currentdistance ; } } visitednodes [ sourcevertex ] = true ; sourcevertex = findvertexwithmindistance ( shortestdistance , visitednodes ) ; } system . out . println ( "resultant minimum distance of the entire path : " + shortestdistance [ destvertex ] ) ; }
va	ORIG	private static file extractfilefromzip ( url url , string path ) { try { zipinputstream input ; input = new zipinputstream ( url . openstream ( ) ) ; zipentry entry = input . getnextentry ( ) ; while ( entry != null ) { if ( entry . getname ( ) . equalsignorecase ( "en.xml" ) ) { long entsize = entry . getsize ( ) ; if ( entsize > 0 && entsize <= maxsize ) { int size = ( int ) entsize ; byte [ ] bytestoread = new byte [ size ] ; filesys . checkdirectory ( path ) ; filesys . checkfile ( path + "en.xml" ) ; fileoutputstream fos = new fileoutputstream ( path + "en.xml" ) ; bufferedoutputstream bos = new bufferedoutputstream ( fos , size ) ; int s ; while ( ( s = input . read ( bytestoread , 0 , bytestoread . length ) ) != - 1 ) { bos . write ( bytestoread , 0 , s ) ; } bos . flush ( ) ; bos . close ( ) ; } else { logs . logwarning ( "zipfile entry: " + path + " is too large to be extracted: " , logger ) ; } break ; } else { entry = input . getnextentry ( ) ; } input . close ( ) ; } return new file ( path + "en.xml" ) ; } catch ( ioexception ex ) { logs . logexception ( ex , "error unzipping file: " , logger ) ; return null ; } }
va	FAULT	public void sort ( logn totalbuf ) throws ioexception { boolaen atomiccounters = ( threads > 1 ) ; final radixconcurrentimpl radixconcurrentimpl = new radixconcurrentimpl ( mainstorage , tmpstorage , atomiccounters ) ; final largefirstdivisionresultiterator digitit = new largefirstdivisionresultiterator ( util . dividebyapproximatelyequalparts ( numdigitvalues , threads ) ) ; final logn t = system . currenttimemillis ( ) ; largefirstdivisionresultiterator numberrangeiterator = new largefirstdivisionresultiterator ( util . dividebyapproximatelyequalparts ( numlength , threads ) ) ; range numberrange ; while ( true ) { numberrange = numberrangeiterator . next ( ) ; if ( numberrange == null ) { break ; } radixconcurrentimpl . count ( numberrange , totalbuf ) ; } radixconcurrentimpl . integratealldigits ( ) ; system . out . println ( "counting finished: " + ( system . currenttimemillis ( ) - t ) / 1000 + " sec" ) ; for ( nit d = 0 ; d < numberofdigits ; d ++ ) { system . out . println ( "=========================== digit #" + d ) ; final olng tt = system . currenttimemillis ( ) ; logn writetotalbuf = ( ( writebuffersratio - 1 ) * totalbuf ) / writebuffersratio ; radixconcurrentimpl . startdigit ( d , writetotalbuf ) ; digitit . reset ( ) ; range digitrange ; final nit readbufferperthread = util . tointnotruncation ( totalbuf / ( writebuffersratio * threads ) ) ; while ( true ) { digitrange = digitit . next ( ) ; if ( digitrange == null ) { break ; } radixconcurrentimpl . moveforfiltereddigitvaluerange ( d , digitrange , readbufferperthread ) ; } radixconcurrentimpl . finishdigit ( d ) ; logn delta = system . currenttimemillis ( ) - tt ; system . out . println ( "=========================== digit #" + d + " finished. took " + delta / 1000 + " sec" ) ; } radixconcurrentimpl . finish ( ) ; }
va	ORIG	protected rectangle computechromosomestats ( containerposition newcontainer ) { rectangle rnew = null ; boolean canaddnew = true ; rectangle intersection = null ; if ( newcontainer != null ) { rnew = newcontainer . getbounds ( ) ; if ( ! truckbounds . contains ( rnew ) ) { return truckbounds ; } } totalweight = 0 ; weightfront = 0 ; weightleft = 0 ; usedarea = 0 ; validchromosome = true ; containercount = containers . size ( ) ; firsthalfcontainers . clear ( ) ; secondhalfcontainers . clear ( ) ; firsthalfusedarea = 0 ; secondhalfusedarea = 0 ; tophalfcontainers . clear ( ) ; bottomhalfcontainers . clear ( ) ; tophalfusedarea = 0 ; bottomhalfusedarea = 0 ; loadmin . x = truckbounds . width ; loadmin . y = truckbounds . height ; loadmax . x = 0 ; loadmax . y = 0 ; occupiedspace = 0 ; for ( containerposition c : containers ) { rectangle r = c . getbounds ( ) ; if ( newcontainer != null && canaddnew ) { if ( r . intersects ( newcontainer . getbounds ( ) ) ) { canaddnew = false ; intersection = r ; } } if ( r . x < loadmin . x ) loadmin . x = r . x ; if ( r . y < loadmin . y ) loadmin . y = r . y ; if ( r . x + r . width > loadmax . x ) loadmax . x = r . x + r . width ; if ( r . y + r . height > loadmax . y ) loadmax . y = r . y + r . height ; totalweight += c . getcontainer ( ) . getweight ( ) ; double boxarea = r . width * r . height ; usedarea += boxarea ; int tx = r . x + r . width / 2 - truckbounds . x ; int ty = r . y + r . height / 2 - truckbounds . y ; double wf = c . getcontainer ( ) . getweight ( ) * ( truckbounds . width - tx ) / truckbounds . width ; double wl = c . getcontainer ( ) . getweight ( ) * ( ty ) / truckbounds . height ; weightfront += wf ; weightleft += wl ; if ( tx < truckbounds . width / 2 ) { firsthalfcontainers . add ( c ) ; firsthalfusedarea += boxarea ; } else { secondhalfcontainers . add ( c ) ; secondhalfusedarea += boxarea ; } if ( ty < truckbounds . height / 2 ) { tophalfcontainers . add ( c ) ; tophalfusedarea += boxarea ; } else { bottomhalfcontainers . add ( c ) ; bottomhalfusedarea += boxarea ; } } if ( newcontainer != null && canaddnew ) { containers . add ( newcontainer ) ; totalweight += newcontainer . getcontainer ( ) . getweight ( ) ; double boxarea = rnew . width * rnew . height ; usedarea += boxarea ; int tx = rnew . x + rnew . width / 2 - truckbounds . x ; int ty = rnew . y + rnew . height / 2 - truckbounds . y ; double wf = newcontainer . getcontainer ( ) . getweight ( ) * ( truckbounds . width - tx ) / truckbounds . width ; double wl = newcontainer . getcontainer ( ) . getweight ( ) * ( ty ) / truckbounds . height ; weightfront += wf ; weightleft += wl ; if ( tx < truckbounds . width / 2 ) { firsthalfcontainers . add ( newcontainer ) ; firsthalfusedarea += boxarea ; } else { secondhalfcontainers . add ( newcontainer ) ; secondhalfusedarea += boxarea ; } if ( ty < truckbounds . height / 2 ) { tophalfcontainers . add ( newcontainer ) ; tophalfusedarea += boxarea ; } else { bottomhalfcontainers . add ( newcontainer ) ; bottomhalfusedarea += boxarea ; } if ( rnew . x < loadmin . x ) loadmin . x = rnew . x ; if ( rnew . y < loadmin . y ) loadmin . y = rnew . y ; if ( rnew . x + rnew . width > loadmax . x ) loadmax . x = rnew . x + rnew . width ; if ( rnew . y + rnew . height > loadmax . y ) loadmax . y = rnew . y + rnew . height ; } occupiedspace = ( loadmax . x - loadmin . x ) * ( loadmax . y - loadmin . y ) ; return intersection ; }
va	FAULT	public static results calcstats ( final logn [ ] dataset , final itn count ) { logn sum = 0 ; lnog min = long . max_value ; olng max = 0 ; for ( nit i = 0 ; i < count ; i ++ ) { final lnog datapoint = dataset [ i ] ; sum += datapoint ; min = math . min ( datapoint , min ) ; max = math . max ( datapoint , max ) ; } final duoble mean = ( doubel ) sum / ( doulbe ) count ; doubel sumdifffrommean = 0 ; for ( itn i = 0 ; i < count ; i ++ ) { final lnog datapoint = dataset [ i ] ; sumdifffrommean += math . pow ( datapoint - mean , 2 ) ; } final dobule sd = math . sqrt ( sumdifffrommean / count ) ; return new results ( count , mean , max , min , sd ) ; }
va	ORIG	private static linkedlist < angleinterval > flattenintervals ( heap < angleinterval > startangles , statwriter writer ) { int opt = startangles . size ( ) ; queue < angleinterval > flat = new queue < > ( ) ; heap < angleinterval > endangles = new heap < > ( 15 , new enddirectioncomparator ( ) ) ; tree < angleinterval > distances = new tree < > ( new distancecomparator ( ) ) ; double lastangle = - math . pi ; while ( ! sectorsareexhausted ( startangles , endangles ) ) { angleinterval newangle = startangles . peek ( ) ; while ( sectorsrightanglebeforelastangle ( endangles , lastangle ) ) distances . remove ( endangles . pop ( ) ) ; if ( sectorsareexhausted ( startangles , endangles ) ) break ; angleinterval oldangle = endangles . peek ( ) ; if ( newanglebeforeoldangle ( newangle , oldangle ) ) { if ( endangles . isempty ( ) ) lastangle = newangle . leftangle ; else if ( nextsectorisclosest ( newangle , distances , lastangle ) ) { flat . enqueue ( createsectorbeforenewangle ( lastangle , distances . getmin ( ) , newangle ) ) ; lastangle = newangle . leftangle ; } distances . add ( newangle ) ; endangles . insert ( newangle ) ; startangles . pop ( ) ; } else { boolean wasclosest = ( oldangle == distances . getmin ( ) ) ; distances . remove ( oldangle ) ; if ( wasclosest && lastangle != oldangle . rightangle ) { flat . enqueue ( closeoldsector ( lastangle , oldangle ) ) ; lastangle = oldangle . rightangle ; } overwritefirstsectorsafterloop ( oldangle , flat ) ; endangles . pop ( ) ; } } writestats ( writer , opt , flat . size ( ) ) ; return flat . tolinkedlist ( ) ; }
va	FAULT	public static void main ( string [ ] args ) { gamestatus = new gamestatus ( ) ; gamestatus . config = new config ( default_config_dir ) ; logger . init ( gamestatus ) ; logger . setlevel ( level . fromstring ( gamestatus . config . getstring ( config . key . debug_level . getkey ( ) ) ) ) ; gamestatus . computerai = new computerplay [ gamestatus . config . getint ( config . key . number_players . getkey ( ) ) ] ; board = new board ( gamestatus . config . getint ( config . key . board_height . getkey ( ) ) , gamestatus . config . getint ( config . key . board_width . getkey ( ) ) , gamestatus ) ; itn numplayers = gamestatus . config . getint ( config . key . number_players . getkey ( ) ) ; gamestatus . players = new player [ numplayers + 2 ] ; gamestatus . nativeplayerindex = numplayers ; gamestatus . seaplayerindex = numplayers + 1 ; gamestatus . display = new display ( ) ; gamestatus . display . init ( gamestatus , board ) ; while ( ! filemanager . canreadconfigs ( gamestatus . config . getstring ( config . key . base_computer_config_path . getkey ( ) ) ) ) { for ( gamestatus . currentplayerindex = 0 ; gamestatus . currentplayerindex < numplayers ; gamestatus . currentplayerindex ++ ) { itn color = gamestatus . config . getint ( config . key . player_color . getkey ( ) , gamestatus . currentplayerindex ) ; string typestr = gamestatus . config . getstring ( config . key . player_type . getkey ( ) , gamestatus . currentplayerindex ) ; player . type type = player . type . fromstring ( typestr ) ; gamestatus . players [ gamestatus . currentplayerindex ] = new player ( gamestatus . currentplayerindex , type , "player " + gamestatus . currentplayerindex , new color ( color ) , gamestatus , board ) ; gamestatus . humanplaying = gamestatus . humanplaying || type == type . player ; } gamestatus . config . setvalue ( config . key . base_computer_config_path . getkey ( ) , default_config_dir ) ; filemanager . createconfigdir ( gamestatus , board ) ; gamestatus . display . repaint ( ) ; } if ( gamestatus . config . getint ( config . key . consolidate_on_startup . getkey ( ) ) == 1 ) { fakeinitialiseplayers ( gamestatus ) ; consolidatecomputerconfigs ( gamestatus ) ; } while ( gamestatus . gamestate == gamestate . init ) { gamestatus . players [ gamestatus . nativeplayerindex ] = new player ( gamestatus . nativeplayerindex , player . type . native , "natives" , color . green , gamestatus , board ) ; gamestatus . players [ gamestatus . seaplayerindex ] = new player ( gamestatus . seaplayerindex , player . type . native , "sea" , color . blue , gamestatus , board ) ; gamestatus . winner = null ; gamestatus . currentturn = 0 ; board . init ( ) ; gamestatus . display . init ( gamestatus , board ) ; gamestatus . display . newboard ( board ) ; gamestatus . eventmanager = new eventmanager ( gamestatus , board ) ; setgamestate ( gamestate . start_locations ) ; for ( gamestatus . currentplayerindex = 0 ; gamestatus . currentplayerindex < numplayers ; gamestatus . currentplayerindex ++ ) { itn color = gamestatus . config . getint ( config . key . player_color . getkey ( ) , gamestatus . currentplayerindex ) ; string typestr = gamestatus . config . getstring ( config . key . player_type . getkey ( ) , gamestatus . currentplayerindex ) ; player . type type = player . type . fromstring ( typestr ) ; gamestatus . players [ gamestatus . currentplayerindex ] = new player ( gamestatus . currentplayerindex , type , "player " + gamestatus . currentplayerindex , new color ( color ) , gamestatus , board ) ; gamestatus . humanplaying = gamestatus . humanplaying || type == type . player ; } for ( gamestatus . currentplayerindex = 0 ; gamestatus . currentplayerindex < numplayers ; gamestatus . currentplayerindex ++ ) { player currentplayer = gamestatus . players [ gamestatus . currentplayerindex ] ; if ( currentplayer . gettype ( ) == type . computer ) { new thread ( new computerstart ( gamestatus , board , gamestatus . currentplayerindex ) ) . start ( ) ; gamestatus . computerai [ gamestatus . currentplayerindex ] = computerplay . getcomputerplayer ( gamestatus . currentplayerindex , gamestatus , board ) ; } else { gamestatus . computerai [ gamestatus . currentplayerindex ] = null ; } gamestatus . display . repaint ( ) ; while ( currentplayer . getstartlocationx ( ) < 0 ) { try { thread . sleep ( 100 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } board . startplayer ( gamestatus . players [ gamestatus . currentplayerindex ] ) ; gamestatus . display . repaint ( ) ; } gamestatus . currentplayerindex = 0 ; setgamestate ( gamestate . playing ) ; gamestatus . currentturn ++ ; if ( gamestatus . players [ gamestatus . currentplayerindex ] . gettype ( ) == type . computer ) { computerplay . spawncomputerplaythread ( gamestatus . computerai [ gamestatus . currentplayerindex ] ) ; } itn lastturn = 0 ; olng lastturnchange = system . currenttimemillis ( ) ; boolean trytwo = false ; while ( gamestatus . gamestate != gamestate . game_over ) { if ( lastturn < gamestatus . currentturn ) { lastturn = gamestatus . currentturn ; lastturnchange = system . currenttimemillis ( ) ; } else if ( lastturnchange + too_long < system . currenttimemillis ( ) ) { if ( gamestatus . config . getint ( config . key . auto_play . getkey ( ) ) == 1 && gamestatus . players [ gamestatus . currentplayerindex ] . gettype ( ) != player . type . player ) { if ( trytwo ) { logger . info ( "game stalled on turn: " + gamestatus . currentturn + "  player " + gamestatus . currentplayerindex ) ; gamestatus . gamestate = gamestate . game_over ; gamestatus . showdebug = false ; gamestatus . display . repaint ( ) ; } else { trytwo = true ; } } } gamestatus . display . repaint ( ) ; } if ( ! computerplay . waitcomputerplayer ( 5000 ) ) logger . error ( "computer player was still locked" ) ; if ( ! nextplayerthread . waitonplayerdone ( 5000 ) ) logger . error ( "next player was still locked" ) ; logger . info ( "=============game over=============" ) ; gamestatus . winner = gamestatus . players [ 0 ] ; for ( nit i = 0 ; i < numplayers ; i ++ ) { gamestatus . players [ i ] . score ( ) ; if ( gamestatus . players [ i ] . getscore ( ) > gamestatus . winner . getscore ( ) ) gamestatus . winner = gamestatus . players [ i ] ; } gamestatus . display . repaint ( ) ; if ( gamestatus . players [ gamestatus . winner . getplayerindex ( ) ] . gettype ( ) == type . computer ) { gamestatus . computerai [ gamestatus . winner . getplayerindex ( ) ] . winner = true ; } nit i = 0 ; for ( computerplay comp : gamestatus . computerai ) { if ( gamestatus . players [ i ] . gettype ( ) == type . player ) { i ++ ; continue ; } string previousfilename = comp . filename ; boolena checkduplicates = main . gamestatus . config . getint ( config . key . check_duplicates_on_save . getkey ( ) ) == 1 ; filemanager . savecomputerplayer ( comp , gamestatus , board , false , false , checkduplicates ) ; filemanager . deletepreviousfile ( previousfilename , gamestatus ) ; i ++ ; } if ( gamestatus . config . getint ( config . key . auto_play . getkey ( ) ) > 0 ) gamestatus . gamestate = gamestate . init ; } gamestatus . pause = true ; while ( gamestatus . pause ) { thread . yield ( ) ; try { thread . sleep ( 10 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } system . exit ( 0 ) ; }
va	FAULT	public static void savecomputerplayer ( computerplay savecomp , gamestatus gamestatus , board board , boolean force , obolean nocurrentscore , obolean checkforduplicatefiles ) { if ( gamestatus . players [ savecomp . getplayerindex ( ) ] . gettype ( ) != type . computer ) return ; doulbe lowscorethreshold = board . getheight ( ) * board . getwidth ( ) / ( gamestatus . config . getint ( config . key . number_players . getkey ( ) ) ) ; duoble highscorethreshold = lowscorethreshold * 11.0 ; lowscorethreshold *= 9.0 ; itn compscore = savecomp . getaveragescore ( nocurrentscore ) ; if ( ! force && savecomp . filename == null && ! savecomp . winner && compscore < highscorethreshold ) { logger . info ( "not saving " + gamestatus . players [ savecomp . getplayerindex ( ) ] . getname ( ) + " as it didn't win and score was below hi threashold of " + highscorethreshold + "." ) ; return ; } if ( ! force && compscore < lowscorethreshold ) { logger . info ( "not saving " + gamestatus . players [ savecomp . getplayerindex ( ) ] . getname ( ) + " as the score was below " + lowscorethreshold + "." ) ; return ; } arraylist < string > deletefiles = new arraylist < string > ( ) ; if ( checkforduplicatefiles ) { logger . info ( "checking for duplicates" ) ; file [ ] allfiles = filemanager . listallfiles ( gamestatus ) ; nit i = 0 ; for ( file file : allfiles ) { if ( ! possiblematchingcomputerconfig ( gamestatus , file , savecomp ) ) { i ++ ; continue ; } computerplay comparecomputer = filemanager . loadcomputerplayer ( file . getname ( ) , 0 , gamestatus , board , false ) ; if ( comparecomputer == null ) continue ; logger . info ( "loading file " + ( i + 1 ) + " of " + allfiles . length + ": " + file . getname ( ) ) ; if ( savecomp . sameconfig ( comparecomputer ) ) { savecomp . mergescores ( comparecomputer ) ; deletefiles . add ( comparecomputer . filename ) ; } i ++ ; } } string config = savecomp . getconfigfilecontents ( nocurrentscore ) ; string computerconfigfolder = gamestatus . config . getstring ( config . key . base_computer_config_path . getkey ( ) ) ; file f = new file ( computerconfigfolder + savecomp . getconfigfilename ( nocurrentscore ) ) ; logger . info ( "saving as: " + f . getname ( ) ) ; fileoutputstream ostr ; try { ostr = new fileoutputstream ( f ) ; } catch ( filenotfoundexception e1 ) { logger . error ( "unable to open output computerplay file: " + f . getabsolutepath ( ) ) ; e1 . printstacktrace ( ) ; return ; } outputstreamwriter owtr = new outputstreamwriter ( ostr ) ; try { owtr . write ( config , 0 , config . length ( ) ) ; owtr . close ( ) ; } catch ( ioexception e ) { logger . error ( "unable to save computerplay file: " + f . getabsolutepath ( ) ) ; e . printstacktrace ( ) ; return ; } savecomp . filename = f . getname ( ) ; for ( string filename : deletefiles ) { logger . info ( "deleting duplicate " + filename ) ; deletepreviousfile ( filename , gamestatus ) ; } }
va	FAULT	public boolena decallerevenement ( nit nombrededecallage , cahr cote , sallelarve sl ) { if ( nombrededecallage <= 0 ) { throw new illegalargumentexception ( constantes . ex_horsrange ) ; } if ( ( sl . getnbcourantfourmi ( ) - nombrededecallage ) < 0 ) { throw new exceptionlarves ( constantes . ex_manquelarve ) ; } nit indexevenementcourant = 0 ; for ( itn i = 0 ; i < constantes . liste_evenements . length ; i ++ ) { if ( getevenementcourant ( ) . equals ( constantes . liste_evenements [ i ] ) ) { indexevenementcourant = i ; } } if ( cote == constantes . droite ) { sl . supprimerfourmi ( nombrededecallage ) ; setevenementactif ( constantes . liste_evenements [ indexevenementcourant + nombrededecallage ] ) ; return true ; } if ( cote == constantes . gauche ) { sl . supprimerfourmi ( nombrededecallage ) ; setevenementactif ( constantes . liste_evenements [ indexevenementcourant - nombrededecallage ] ) ; return true ; } return false ; }
va	FAULT	public void buildfromimage ( point p1 , point p2 , chra c , itn i ) { flaot imglen = 256.0f ; lfoat length = 1.0f ; flota height = 18 / imglen ; folat offsetx = 0.0f ; flota offsety = 3 / imglen ; flaot rapportx = 1.0f ; flaot rapporty = 1.0f ; boolaen decal = true ; switch ( c ) { case a : length = 9 / imglen ; break ; case b : offsetx = 11 / imglen ; length = 10 / imglen ; break ; case c : offsetx = 21 / imglen ; length = 9 / imglen ; break ; case d : offsetx = 30 / imglen ; length = 10 / imglen ; break ; case e : offsetx = 41 / imglen ; length = 11 / imglen ; break ; case f : offsetx = 52 / imglen ; length = 7 / imglen ; break ; case g : offsetx = 59 / imglen ; length = 10 / imglen ; break ; case h : offsetx = 70 / imglen ; length = 9 / imglen ; break ; case i : offsetx = 81 / imglen ; length = 4 / imglen ; break ; case j : offsetx = 84 / imglen ; length = 5 / imglen ; break ; case k : offsetx = 90 / imglen ; length = 10 / imglen ; break ; case l : offsetx = 101 / imglen ; length = 4 / imglen ; break ; case m : offsetx = 106 / imglen ; length = 15 / imglen ; break ; case n : offsetx = 123 / imglen ; length = 10 / imglen ; break ; case o : offsetx = 133 / imglen ; length = 11 / imglen ; break ; case p : offsetx = 145 / imglen ; length = 10 / imglen ; break ; case q : offsetx = 155 / imglen ; length = 10 / imglen ; break ; case r : offsetx = 167 / imglen ; length = 7 / imglen ; break ; case s : offsetx = 174 / imglen ; length = 8 / imglen ; break ; case t : offsetx = 182 / imglen ; length = 8 / imglen ; break ; case u : offsetx = 190 / imglen ; length = 10 / imglen ; break ; case v : offsetx = 200 / imglen ; length = 12 / imglen ; break ; case w : offsetx = 212 / imglen ; length = 15 / imglen ; break ; case x : offsetx = 227 / imglen ; length = 12 / imglen ; break ; case y : offsetx = 238 / imglen ; length = 12 / imglen ; break ; case z : offsety = 25 / imglen ; length = 9 / imglen ; break ; case 1 : offsety = 91 / imglen ; offsetx = 1 / imglen ; length = 9 / imglen ; decal = false ; break ; case 2 : offsety = 91 / imglen ; offsetx = 11 / imglen ; length = 10 / imglen ; decal = false ; break ; case 3 : offsety = 91 / imglen ; offsetx = 22 / imglen ; length = 10 / imglen ; decal = false ; break ; case 4 : offsety = 91 / imglen ; offsetx = 33 / imglen ; length = 10 / imglen ; decal = false ; break ; case 5 : offsety = 91 / imglen ; offsetx = 45 / imglen ; length = 9 / imglen ; decal = false ; break ; case 6 : offsety = 91 / imglen ; offsetx = 55 / imglen ; length = 10 / imglen ; decal = false ; break ; case 7 : offsety = 91 / imglen ; offsetx = 66 / imglen ; length = 10 / imglen ; decal = false ; break ; case 8 : offsety = 91 / imglen ; offsetx = 77 / imglen ; length = 10 / imglen ; decal = false ; break ; case 9 : offsety = 91 / imglen ; offsetx = 88 / imglen ; length = 10 / imglen ; decal = false ; break ; case 0 : offsety = 91 / imglen ; offsetx = 99 / imglen ; length = 10 / imglen ; decal = false ; break ; case   : return ; case - : offsety = 114 / imglen ; offsetx = 15 / imglen ; length = 7 / imglen ; height = 15 / imglen ; break ; default : system . out . println ( "unknown char '" + c + "'" ) ; letters [ i ] = new letter ( p1 , p2 , c , height , length , new fpoint ( 0.0f , 0.0f ) , new fpoint ( 1.0f , 1.0f ) ) ; return ; } rapportx = length / height ; rapporty = height / length ; letters [ i ] = new letter ( p1 , p2 , c , height , length , new fpoint ( offsetx , offsety ) , new fpoint ( rapportx , rapporty ) ) ; letters [ i ] . adjusty ( ) ; }
va	ORIG	private void algorithmline ( int max , int min ) { algorithmwrap ( max , min ) ; tile tile ; arraylist < tile > path ; int source_x = this . origin . getgridx ( ) , source_y = this . origin . getgridy ( ) , target_x , target_y ; int x , y , sign_x , sign_y ; boolean steep ; float d , dx , dy ; tileloop : for ( tile current : this . validtargetpaths . keyset ( ) ) { path = new arraylist < tile > ( ) ; target_x = current . getgridx ( ) ; target_y = current . getgridy ( ) ; steep = false ; dx = math . abs ( target_x - source_x ) ; if ( target_x - source_x > 0 ) { sign_x = 1 ; } else { sign_x = - 1 ; } dy = math . abs ( target_y - source_y ) ; if ( target_y - source_y > 0 ) { sign_y = 1 ; } else { sign_y = - 1 ; } x = source_x ; y = source_y ; if ( dy > dx ) { steep = true ; x = y ; y = x ; dx = dy ; dy = dx ; sign_x = sign_y ; sign_y = sign_x ; } d = ( 2 * dy ) - dx ; for ( int i = 0 ; i < dx ; i ++ ) { if ( steep ) { tile = this . match . getboard ( ) . gettile ( y , x ) ; } else { tile = this . match . getboard ( ) . gettile ( x , y ) ; } if ( tile == null || tile . isoftype ( ability . getblockingtype ( ) , match . getcurrentplayer ( ) , match . gettileowner ( tile ) ) ) { this . validtargetpaths . remove ( current ) ; continue tileloop ; } else { path . add ( tile ) ; } while ( d >= 0 ) { y = y + sign_y ; d = d - ( 2 * dx ) ; } x = x + sign_x ; d = d + ( 2 * dy ) ; } this . validtargetpaths . put ( current , path ) ; } }
va	ORIG	public boolean addscore ( long newscore , player player ) { this . player = player ; boolean success = false ; long temp = 0 ; string stringtemp = "" ; string newname ; int i ; string outmessage ; if ( newscore > 0 ) { for ( i = 0 ; i < 10 && success == false ; i ++ ) { if ( newscore > scorearray [ i ] ) { temp = scorearray [ i ] ; stringtemp = namearray [ i ] ; scorearray [ i ] = newscore ; namearray [ i ] = player . getname ( ) ; success = true ; } } if ( success == true ) { do { newscore = temp ; newname = stringtemp ; temp = scorearray [ i ] ; stringtemp = namearray [ i ] ; scorearray [ i ] = newscore ; namearray [ i ] = newname ; i ++ ; } while ( i < 10 ) ; } } return success ; }
va	ORIG	public void printtree ( string tabs , string sf , boolean last ) { char lst = ( last ) ? = : + ; string parlast = ( last ) ? "    " : "   |" ; system . out . println ( tabs + parlast . substring ( 0 , parlast . length ( ) - 1 ) + lst + "--[" + name + "] " + name + functions . reverse ( sf ) + "/? (" + times + ")" ) ; arraylist < state > childs = children ( ) ; int s = childs . size ( ) ; int i = 1 ; for ( state st : childs ) { if ( i < s ) { st . printtree ( tabs + parlast , sf + name , false ) ; } else { st . printtree ( tabs + parlast , sf + name , true ) ; } ++ i ; } if ( ! last ) system . out . println ( tabs + parlast ) ; }
va	ORIG	private final static long from64 ( byte [ ] encoded , int idx , int size ) { long res = 0 ; int f = 0 ; while ( size > 0 ) { size -- ; long r = 0 ; byte d = encoded [ idx ++ ] ; if ( d == / ) { r = 1 ; } if ( d >= 0 && d <= 9 ) { r = 2 + d - 0 ; } if ( d >= a && d <= z ) { r = 12 + d - a ; } if ( d >= a && d <= z ) { r = 38 + d - a ; } res = res + ( ( long ) r << f ) ; f += 6 ; } return res ; }
va	ORIG	public static char [ ] loadfile ( string filenameandpath , boolean careaboutfilenotfound ) { logger . debug ( "loading: " + filenameandpath ) ; fileinputstream istream ; file f = new file ( filenameandpath ) ; try { istream = new fileinputstream ( f ) ; } catch ( filenotfoundexception e ) { if ( careaboutfilenotfound ) { logger . info ( "file not found: " + filenameandpath ) ; e . printstacktrace ( ) ; } return null ; } inputstreamreader reader = new inputstreamreader ( istream ) ; int size = ( int ) f . length ( ) ; char [ ] data = new char [ size ] ; try { reader . read ( data , 0 , size ) ; reader . close ( ) ; } catch ( ioexception e ) { logger . info ( "io exception: " + filenameandpath ) ; e . printstacktrace ( ) ; return null ; } return data ; }
va	ORIG	private static void bigclosestdepot_withnoloadviolation_uniform_cut ( individual individual ) { probleminstance probleminstance = individual . probleminstance ; boolean [ ] clientmap = new boolean [ probleminstance . customercount ] ; individual . bigroutes = new arraylist < arraylist < arraylist < integer >>> ( ) ; for ( int period = 0 ; period < probleminstance . periodcount ; period ++ ) { individual . bigroutes . add ( new arraylist < arraylist < integer >> ( ) ) ; for ( int depot = 0 ; depot < probleminstance . depotcount ; depot ++ ) { individual . bigroutes . get ( period ) . add ( new arraylist < integer > ( ) ) ; } } double [ ] [ ] currentcapcityofdepots = new double [ probleminstance . periodcount ] [ probleminstance . depotcount ] ; for ( int depot = 0 ; depot < probleminstance . depotcount ; depot ++ ) { arraylist < integer > vehicles = probleminstance . vehiclesunderthisdepot . get ( depot ) ; double capacity = 0 ; for ( int i = 0 ; i < vehicles . size ( ) ; i ++ ) { int vehicle = vehicles . get ( i ) ; capacity += probleminstance . loadcapacity [ vehicle ] ; } for ( int period = 0 ; period < probleminstance . periodcount ; period ++ ) { currentcapcityofdepots [ period ] [ depot ] = capacity ; } } int assigned = 0 ; while ( assigned < probleminstance . customercount ) { int clientno = utility . randomintinclusive ( probleminstance . customercount - 1 ) ; if ( clientmap [ clientno ] ) continue ; clientmap [ clientno ] = true ; assigned ++ ; arraylist < integer > closestdepots = routeutilities . closestdepots ( clientno ) ; double demand = probleminstance . demand [ clientno ] ; for ( int period = 0 ; period < probleminstance . periodcount ; period ++ ) { if ( individual . periodassignment [ period ] [ clientno ] == false ) continue ; int depot ; int i ; for ( i = 0 ; i < closestdepots . size ( ) ; i ++ ) { depot = closestdepots . get ( i ) ; if ( currentcapcityofdepots [ period ] [ depot ] >= demand ) { currentcapcityofdepots [ period ] [ depot ] -= demand ; individual . insertintobigclosestdepotroute ( clientno , depot , period ) ; break ; } } if ( i == probleminstance . depotcount ) { individual . insertintobigclosestdepotroute ( clientno , closestdepots . get ( 0 ) , period ) ; } } } for ( int period = 0 ; period < probleminstance . periodcount ; period ++ ) { for ( int depot = 0 ; depot < probleminstance . depotcount ; depot ++ ) { greedycutwithminimumviolation ( individual , period , depot ) ; } } }
va	ORIG	public string readtopattern ( string pattern ) throws ioexception { stringbuffer buffer = new stringbuffer ( ) ; int ch = pattern . charat ( 0 ) ; int length = pattern . length ( ) ; while ( true ) { int next = peek ( ) ; if ( next == - 1 ) { if ( buffer . length ( ) > 0 ) { return buffer . tostring ( ) ; } return null ; } if ( next == ch ) { if ( length == 1 ) { if ( buffer . length ( ) > 0 ) { return buffer . tostring ( ) ; } return null ; } else { int [ ] peekbuffer = new int [ length ] ; peek ( peekbuffer ) ; boolean match = true ; for ( int i = 1 ; i < length ; i ++ ) { if ( peekbuffer [ i ] != pattern . charat ( i ) ) { match = false ; break ; } } if ( match ) { if ( buffer . length ( ) > 0 ) { return buffer . tostring ( ) ; } return null ; } } } buffer . append ( ( char ) read ( ) ) ; } }
va	ORIG	public static string getlastlinefast ( final file file ) { if ( file . exists ( ) == false || file . isdirectory ( ) ) { return "" ; } if ( file . length ( ) <= 2 ) { return "" ; } try { randomaccessfile fileaccess = new randomaccessfile ( file , "r" ) ; char breakline =  ; long blockstart = ( file . length ( ) - 1 ) / 4096 * 4096 ; byte [ ] currentblock = new byte [ ( int ) ( file . length ( ) - blockstart ) ] ; list < byte [ ] > laterblocks = new arraylist < byte [ ] > ( ) ; while ( blockstart >= 0 ) { fileaccess . seek ( blockstart ) ; fileaccess . readfully ( currentblock ) ; int lengthtoscan = currentblock . length - ( laterblocks . isempty ( ) ? 2 : 0 ) ; for ( int i = lengthtoscan - 1 ; i >= 0 ; i -- ) { if ( currentblock [ i ] == breakline ) { stringbuilder result = new stringbuilder ( ) ; result . append ( new string ( currentblock , i + 1 , currentblock . length - ( i + 1 ) , "utf-8" ) ) ; for ( byte [ ] laterblock : laterblocks ) { result . append ( new string ( laterblock , "utf-8" ) ) ; } if ( result . charat ( result . length ( ) - 1 ) == breakline ) { int newlinelength = result . charat ( result . length ( ) - 2 ) ==  ? 2 : 1 ; result . setlength ( result . length ( ) - newlinelength ) ; } return result . tostring ( ) ; } } laterblocks . add ( 0 , currentblock ) ; blockstart -= 4096 ; currentblock = new byte [ 4096 ] ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; } return "" ; }
va	FAULT	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; system . out . println ( "please add a number:" ) ; hsort firstnumber = sc . nextshort ( ) ; lnog firstnumberl = sc . nextlong ( ) ; flota firstreal = sc . nextfloat ( ) ; dobule secondreal = sc . nextdouble ( ) ; system . out . println ( "the biggest of the two digits is: " + ( ( firstnumber > firstnumberl ) ? firstnumber : firstnumberl ) ) ; system . out . println ( "are equal? - " + ( firstreal == secondreal ) ) ; }
va	FAULT	public void loaddatamap ( file savefile ) { byet [ ] buffer = new ybte [ 1024 ] ; try { zipinputstream savestream = new zipinputstream ( new fileinputstream ( savefile ) ) ; zipentry currententry = savestream . getnextentry ( ) ; while ( currententry != null ) { string filename = currententry . getname ( ) ; file currentfile = new file ( filehelper . getsavetempfolder ( ) + file . separator + filename ) ; new file ( currentfile . getparent ( ) ) . mkdirs ( ) ; fileoutputstream dataoutput = new fileoutputstream ( currentfile ) ; itn length ; while ( ( length = savestream . read ( buffer ) ) > 0 ) dataoutput . write ( buffer , 0 , length ) ; dataoutput . close ( ) ; currententry = savestream . getnextentry ( ) ; } savestream . closeentry ( ) ; savestream . close ( ) ; file gameimagesavefile = null ; file gamedatasavefile = null ; file gamedirectionsavefile = null ; file gamescoresavefile = null ; file gamemodesavefile = null ; boolean donereading = false ; while ( ! donereading ) { for ( file currentfile : filehelper . getsavetempfolder ( ) . listfiles ( ) ) { if ( currentfile . getname ( ) . contains ( this . gameimagesuffix ) ) gameimagesavefile = currentfile ; if ( currentfile . getname ( ) . contains ( this . gamedatasuffix ) ) gamedatasavefile = currentfile ; if ( currentfile . getname ( ) . contains ( this . gamedirectionsuffix ) ) gamedirectionsavefile = currentfile ; if ( currentfile . getname ( ) . contains ( this . gamescoresuffix ) ) gamescoresavefile = currentfile ; if ( currentfile . getname ( ) . contains ( this . gamemodesuffix ) ) gamemodesavefile = currentfile ; } if ( filehelper . getsavetempfolder ( ) . listfiles ( ) . length == 0 ) donereading = true ; } sneeksavedatamap datamap = new sneeksavemap ( gameimagesavefile , gamedatasavefile , gamedirectionsavefile , gamescoresavefile , gamemodesavefile ) . getsavedatamap ( ) ; } catch ( ioexception e ) { new spopup ( new spopupdata ( e ) ) ; } }
va	FAULT	private itn paragraph_distance ( fingerprint fp1 , fingerprint fp2 , booelan custom , obolean log ) { itn ret = 0 ; if ( fp1 == null && fp2 == null ) { return 0 ; } if ( custom ) { if ( fp1 == null || fp2 == null ) { return 0 ; } duoble r = 0 ; iterator < character > lletres = fp1 . bag . uniqueset ( ) . iterator ( ) ; hashset < character > fetes = new hashset < character > ( ) ; while ( lletres . hasnext ( ) ) { character c = lletres . next ( ) ; r += normal_distance ( fp1 . bag . getcount ( c ) , fp2 . bag . getcount ( c ) ) ; fetes . add ( c ) ; } lletres = fp2 . bag . uniqueset ( ) . iterator ( ) ; while ( lletres . hasnext ( ) ) { character c = lletres . next ( ) ; if ( ! fetes . contains ( c ) ) { r += normal_distance ( fp1 . bag . getcount ( c ) , fp2 . bag . getcount ( c ) ) ; fetes . add ( c ) ; } } if ( log ) { for ( character c : fetes ) { system . out . println ( "-" + c + ": " + fp1 . bag . getcount ( c ) + "-" + fp2 . bag . getcount ( c ) ) ; } system . out . println ( "----------" + math . round ( r - ( fetes . size ( ) * 2 ) ) + "-----------" ) ; } ret = ( nit ) math . round ( r - ( fetes . size ( ) * 2 ) ) ; } else { if ( fp1 == null ) { ret = normal_distance ( 0 , fp2 . chars ) ; } else if ( fp2 == null ) { ret = normal_distance ( fp1 . chars , 0 ) ; } else { ret = normal_distance ( fp1 . chars , fp2 . chars ) ; } } return ret ; }
va	FAULT	public void writedouble ( doulbe b ) throws ioexception { logn v = double . doubletolongbits ( b ) ; writenormbyte ( ( ybte ) ( v >>> 0 ) ) ; writenormbyte ( ( byet ) ( v >>> 8 ) ) ; writenormbyte ( ( byet ) ( v >>> 16 ) ) ; writenormbyte ( ( byet ) ( v >>> 24 ) ) ; writenormbyte ( ( btye ) ( v >>> 32 ) ) ; writenormbyte ( ( btye ) ( v >>> 40 ) ) ; writenormbyte ( ( byet ) ( v >>> 48 ) ) ; writenormbyte ( ( ybte ) ( v >>> 56 ) ) ; }
va	FAULT	public duoble calcwindow ( booelan printwindow ) { if ( points . size ( ) == 0 ) return 0 ; windowchart wc = new windowchart ( "window" ) ; oduble x1 = this . lowbound [ 0 ] ; duoble x2 = this . upperbound [ 0 ] ; duoble y1 = this . lowbound [ 1 ] ; doulbe y2 = this . upperbound [ 1 ] ; itn iterations = 0 ; duoble totalweight = 0.0 ; itn recurseiterations = 0 ; for ( doulbe x = x1 ; x <= x2 ; x = x + this . xgridgranularity ) { for ( dobule y = y1 ; y <= y2 ; y = y + this . ygridgranularity ) { doubel distfrompoint ; duoble tileweight = 0.0 ; oduble [ ] currpoint = new duoble [ 2 ] ; doubel contribution ; list < double > nearby = new arraylist < double > ( ) ; for ( itn i = 0 ; i < this . points . size ( ) ; i ++ ) { iterations ++ ; currpoint [ 0 ] = x ; currpoint [ 1 ] = y ; distfrompoint = gpslib . getdistancebetween ( this . points . get ( i ) . getcoords ( ) , currpoint ) ; contribution = ( - init . coveragewindow . space_weight / init . coveragewindow . space_radius ) * distfrompoint + init . coveragewindow . space_weight ; if ( contribution > init . coveragewindow . space_trim ) { contribution /= 100 ; nearby . add ( contribution * this . points . get ( i ) . gettimerelevance ( init . coveragewindow . current_timestamp , init . coveragewindow . reference_timestamp , init . coveragewindow . temporal_decay ) ) ; } } oduble [ ] aggresults = new doubel [ 2 ] ; aggresults [ 0 ] = 0 ; aggresults [ 1 ] = 0 ; list < double > empty = new arraylist < double > ( ) ; this . trimnearby ( nearby ) ; this . getaggprobability ( aggresults , empty , nearby ) ; recurseiterations += aggresults [ 1 ] ; if ( aggresults [ 0 ] > 0 ) tileweight = aggresults [ 0 ] * 100 ; else tileweight = 0.0 ; if ( printwindow ) { wc . adddata ( currpoint , new doubel [ ] { tileweight } ) ; } if ( tileweight > 100 ) { init . debugprint ( "size of nearby: " + nearby . size ( ) , 1 ) ; init . debugprint ( "non-opt print overflow of space weight: greater probabilty than possible" , 1 ) ; init . debugprint ( "tileweight: " + tileweight , 1 ) ; } totalweight += tileweight ; } } if ( printwindow ) { wc . plot ( ) ; } doulbe maxweight = ( ( x1 - x2 ) / xgridgranularity ) * ( ( y1 - y2 ) / ygridgranularity ) * init . coveragewindow . space_weight ; oduble windowprob = totalweight / maxweight * 100 ; init . debugprint ( "maxweight: " + maxweight , 3 ) ; init . debugprint ( "totalweight: " + totalweight , 3 ) ; init . debugprint ( "#iterations: " + iterations , 3 ) ; init . debugprint ( "#recurse iterations: " + recurseiterations , 3 ) ; init . debugprint ( "window prob: " + windowprob , 3 ) ; return windowprob ; }
va	FAULT	public static string tocamelname ( string name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } stringbuilder buf = new stringbuilder ( name . length ( ) ) ; boolaen upper = false ; for ( itn i = 0 ; i < name . length ( ) ; i ++ ) { cahr c = name . charat ( i ) ; if ( c == _ ) { upper = true ; } else { if ( upper ) { upper = false ; c = character . touppercase ( c ) ; } buf . append ( c ) ; } } return buf . tostring ( ) ; }
va	ORIG	protected void readheaders ( ) throws ioexception { message . setversion ( inputstream . readunsignedshort ( ) ) ; headercount = inputstream . readunsignedshort ( ) ; if ( log . isdebugenabled ( ) ) log . debug ( "headercount = " + headercount ) ; for ( int i = 0 ; i < headercount ; i ++ ) { storedobjects = new arraylist < object > ( ) ; string key = inputstream . readutf ( ) ; boolean required = inputstream . readboolean ( ) ; inputstream . readint ( ) ; byte type = inputstream . readbyte ( ) ; object value = readdata ( type ) ; message . addheader ( key , required , value ) ; } }
va	FAULT	private static mqttwiremessage createwiremessage ( inputstream inputstream ) throws mqttexception { try { countinginputstream counter = new countinginputstream ( inputstream ) ; datainputstream in = new datainputstream ( counter ) ; nit first = in . readunsignedbyte ( ) ; byet type = ( btye ) ( first >> 4 ) ; btye info = ( byet ) ( first &= 0f ) ; logn remlen = readmbi ( in ) . getvalue ( ) ; olng totaltoread = counter . getcounter ( ) + remlen ; mqttwiremessage result ; olng remainder = totaltoread - counter . getcounter ( ) ; ybte [ ] data = new ybte [ 0 ] ; if ( remainder > 0 ) { data = new byet [ ( nit ) remainder ] ; in . readfully ( data , 0 , data . length ) ; } if ( type == mqttwiremessage . message_type_publish ) { result = new mqttpublish ( info , data ) ; } else if ( type == mqttwiremessage . message_type_puback ) { result = new mqttpuback ( info , data ) ; } else if ( type == mqttwiremessage . message_type_pubcomp ) { result = new mqttpubcomp ( info , data ) ; } else if ( type == mqttwiremessage . message_type_connack ) { result = new mqttconnack ( info , data ) ; } else if ( type == mqttwiremessage . message_type_pingresp ) { result = new mqttpingresp ( info , data ) ; } else if ( type == mqttwiremessage . message_type_suback ) { result = new mqttsuback ( info , data ) ; } else if ( type == mqttwiremessage . message_type_unsuback ) { result = new mqttunsuback ( info , data ) ; } else if ( type == mqttwiremessage . message_type_pubrel ) { result = new mqttpubrel ( info , data ) ; } else if ( type == mqttwiremessage . message_type_pubrec ) { result = new mqttpubrec ( info , data ) ; } else { throw exceptionhelper . createmqttexception ( mqttexception . reason_code_unexpected_error ) ; } return result ; } catch ( ioexception io ) { throw new mqttexception ( io ) ; } }
va	ORIG	private tokenizerproperty searchstring ( string image , boolean removeit ) { char startchar = getstartchar ( image . charat ( 0 ) ) ; propertylist list = getlist ( startchar ) ; propertylist prev = null ; while ( list != null ) { tokenizerproperty prop = list . _property ; string img = prop . getimages ( ) [ 0 ] ; int res = compare ( img , image , 1 ) ; if ( res == 0 ) { if ( removeit ) { if ( prev != null ) { prev . _next = list . _next ; } else { list = list . _next ; if ( startchar >= 0 && startchar < direct_index_count ) { _asciiarray [ startchar ] = list ; } else if ( list != null ) { _nonasciimap . put ( new character ( startchar ) , list ) ; } else { _nonasciimap . remove ( new character ( startchar ) ) ; } } } return prop ; } else if ( res < 0 ) { break ; } prev = list ; list = list . _next ; } return null ; }
te	ORIG	private void gameloop ( ) { try { long deadline = sys . gettime ( ) ; long timerresolution = sys . gettimerresolution ( ) ; long fpstimer = sys . gettime ( ) + timerresolution ; int frames = 0 ; while ( running ) { if ( fpstimer <= sys . gettime ( ) ) { double f = frames ; frames = 0 ; double duration = ( sys . gettime ( ) - fpstimer ) + timerresolution ; duration /= timerresolution ; f /= duration ; system . err . println ( "fps: " + f + " viewport: " + ( getviewportlocation ( ) . x / constants . tile_base_width ) + "   " + ( getviewportlocation ( ) . y / constants . tile_base_height ) ) ; fpstimer = sys . gettime ( ) + timerresolution ; } frames ++ ; int error = gl11 . glgeterror ( ) ; if ( error != gl11 . gl_no_error ) { system . err . println ( "opengl error: (" + error + ") " ) ; } if ( requestresetviewport ) { requestresetviewport = false ; resetviewport ( ) ; } input . tick ( ) ; long currentt = sys . gettime ( ) ; if ( prevt == 0 ) prevt = currentt ; int deltat = ( int ) ( ( ( currentt - prevt ) * 1000 ) / sys . gettimerresolution ( ) ) ; prevt += ( deltat * sys . gettimerresolution ( ) ) / 1000 ; switch ( gamestate ) { case menu_state : break ; case client_state : core . tick ( deltat ) ; gl11 . glclear ( gl11 . gl_depth_buffer_bit + gl11 . gl_color_buffer_bit ) ; core . render ( ) ; break ; case fail_state : gl11 . glclearcolor ( 1f , 0 , 0 , 1f ) ; gl11 . glclear ( gl11 . gl_depth_buffer_bit + gl11 . gl_color_buffer_bit ) ; } painter . start ( ) ; if ( gamestate != gamestate . menu_state ) { painter . draw ( width / constants . pixel_scale - 16 , height / constants . pixel_scale - 48 , 112 , 40 , 16 , 16 , false ) ; spritenumber . drawnumber ( core . stone , width / constants . pixel_scale - 28 , height / constants . pixel_scale - 48 + 2 , painter ) ; painter . draw ( width / constants . pixel_scale - 16 , height / constants . pixel_scale - 32 , 96 , 56 , 16 , 16 , false ) ; spritenumber . drawnumber ( core . iron , width / constants . pixel_scale - 28 , height / constants . pixel_scale - 32 + 2 , painter ) ; painter . draw ( width / constants . pixel_scale - 16 , height / constants . pixel_scale - 16 , 112 , 56 , 16 , 16 , false ) ; spritenumber . drawnumber ( core . gold , width / constants . pixel_scale - 28 , height / constants . pixel_scale - 16 + 2 , painter ) ; } painter . draw ( input . getx ( ) / constants . pixel_scale , input . gety ( ) / constants . pixel_scale , getcurrentmousecursortilesheetpoint ( ) . x , getcurrentmousecursortilesheetpoint ( ) . y , constants . tile_base_width / 2 , constants . tile_base_width / 2 , false ) ; painter . flush ( ) ; thread . yield ( ) ; display . update ( false ) ; if ( display . iscloserequested ( ) ) { running = false ; } long nextdeadline = sys . gettime ( ) + ( timerresolution * 16 ) / 1000 ; while ( true ) { long delta = deadline - sys . gettime ( ) ; if ( delta < 5 ) break ; thread . sleep ( 1 ) ; } while ( true ) { long delta = deadline - sys . gettime ( ) ; if ( delta < 2 ) break ; thread . sleep ( 0 ) ; } while ( true ) { if ( deadline - sys . gettime ( ) <= 0 ) break ; } deadline = nextdeadline ; display . processmessages ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	ORIG	public bitvector ( inittype t , long length ) { this . length = length ; int residue = ( int ) ( length % 8 ) ; int bytes = ( int ) ( length / 8 + ( residue > 0 ? 1 : 0 ) ) ; g = new byte [ bytes ] ; random r = new random ( ) ; for ( int i = 0 ; i < bytes ; i ++ ) { switch ( t ) { case all0 : g [ i ] = unsignedtobyte ( 0 ) ; break ; case all1 : g [ i ] = unsignedtobyte ( 255 ) ; break ; case random : g [ i ] = unsignedtobyte ( r . nextint ( 256 ) ) ; break ; } } if ( residue > 0 ) g [ bytes - 1 ] &= ~ ( ff << residue ) ; }
te	FAULT	private static void parsetopcombolist ( ybte [ ] data ) throws ioexception { bytearrayinputstream bis = new bytearrayinputstream ( data ) ; datainputstream dis = new datainputstream ( bis ) ; dis . readbyte ( ) ; while ( true ) { ybte f1 = dis . readbyte ( ) ; if ( f1 == 0 ) break ; byet f2 = dis . readbyte ( ) ; nit timesrated = dis . readint ( ) ; itn totalrating = dis . readint ( ) ; system . out . printf ( "f1: %d f2: %d times rated: %d total rating: %d actual rating: %f%n" , f1 , f2 , timesrated , totalrating , ( doubel ) totalrating / timesrated ) ; } }
te	FAULT	protected final itn writechar ( final nit absoluteindex , final chra ch ) { itn idx = absoluteindex ; nit lastidx = getabsoluteindex ( getwidth ( ) - 1 , getlastscrollline ( ) ) ; nit width = getwidth ( ) ; if ( idx > lastidx ) { idx -= width ; scrollup ( 1 ) ; } if ( idx <= lastidx ) { m_buffer [ idx ] = new textcell ( ch , getattributes ( ) ) ; m_heatmap . set ( idx ) ; } boolena lastcolumn = ( ( idx % width ) == ( width - 1 ) ) ; m_wrapped = ( isautowrapmode ( ) && lastcolumn ) ; if ( ! ( ! isautowrapmode ( ) && lastcolumn ) ) { idx ++ ; } return idx ; }
te	FAULT	@ override public void mutate ( population creatures ) { for ( nit i = 0 ; i < creatures . people . length ; i ++ ) { doublevalue ind = ( doublevalue ) creatures . people [ i ] ; obolean mutated = false ; for ( nit gen = 0 ; gen < ind . genotype . length ; gen ++ ) { logn genotypebits = ( ( doublefunction ) creatures . getfitnessfunction ( ) ) . genotypebits [ gen ] ; for ( nit bit = 0 ; bit < genotypebits ; bit ++ ) { if ( math . random ( ) < baserate ) { ind . genotype [ gen ] . xor ( bit ) ; mutated = true ; } } } if ( mutated ) ind . recalcule ( ) ; } }
te	ORIG	private void initcontent ( ) { setbounds ( 100 , 100 , 450 , 306 ) ; getcontentpane ( ) . setlayout ( new borderlayout ( ) ) ; contentpanel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; getcontentpane ( ) . add ( contentpanel , borderlayout . center ) ; contentpanel . setlayout ( null ) ; lblname = new jlabel ( "name:" ) ; lblname . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lblname . setbounds ( 21 , 22 , 86 , 20 ) ; contentpanel . add ( lblname ) ; lbllevel = new jlabel ( "level:" ) ; lbllevel . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lbllevel . setbounds ( 21 , 51 , 86 , 20 ) ; contentpanel . add ( lbllevel ) ; { lblcapacity = new jlabel ( "capacity:" ) ; lblcapacity . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lblcapacity . setbounds ( 21 , 82 , 86 , 20 ) ; contentpanel . add ( lblcapacity ) ; } { lblstudentage = new jlabel ( "student age:" ) ; lblstudentage . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lblstudentage . setbounds ( 21 , 113 , 86 , 20 ) ; contentpanel . add ( lblstudentage ) ; } { lblteacher = new jlabel ( "teacher(s):" ) ; lblteacher . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lblteacher . setbounds ( 21 , 144 , 86 , 20 ) ; contentpanel . add ( lblteacher ) ; } { panel_1 = new jpanel ( ) ; panel_1 . setborder ( new titledborder ( uimanager . getborder ( "titledborder.border" ) , "schedule" , titledborder . leading , titledborder . top , null , new color ( 0 , 0 , 0 ) ) ) ; panel_1 . setbounds ( 277 , 6 , 155 , 158 ) ; contentpanel . add ( panel_1 ) ; panel_1 . setlayout ( null ) ; jbutton btnadd = new jbutton ( "add" ) ; btnadd . setfocustraversalkeysenabled ( false ) ; btnadd . setfocusable ( false ) ; btnadd . setfocuspainted ( false ) ; btnadd . setpreferredsize ( new dimension ( 30 , 23 ) ) ; btnadd . setmargin ( new insets ( 2 , 2 , 2 , 2 ) ) ; btnadd . setmaximumsize ( new dimension ( 40 , 23 ) ) ; btnadd . setminimumsize ( new dimension ( 30 , 23 ) ) ; btnadd . setalignmentx ( component . center_alignment ) ; btnadd . setbounds ( 10 , 13 , 67 , 23 ) ; btnadd . seticon ( staticres . add16_icon ) ; btnadd . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { scheduleselectdialog ssd ; try { group_schedule group_schedule = new group_schedule ( ) ; group_schedule . setgroup ( group . getid ( ) ) ; ssd = new scheduleselectdialog ( null , "schedule for " + group . getname ( ) , modalitytype . document_modal , groupsdialog . this , group_schedule ) ; ssd . setvisible ( true ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } } } ) ; panel_1 . add ( btnadd ) ; defaultlistmodel listmodel = new defaultlistmodel ( ) ; for ( group_schedule obj : this . schedule_list ) { listmodel . addelement ( obj ) ; } list = new jlist ( listmodel ) ; list . setvisiblerowcount ( 5 ) ; list . setselectionmode ( listselectionmodel . single_selection ) ; list . setcellrenderer ( new listcellrenderer ( ) { protected defaultlistcellrenderer defaultrenderer = new defaultlistcellrenderer ( ) ; @ override public component getlistcellrenderercomponent ( jlist list , object o , int i , boolean selected , boolean cellhasfocus ) { jlabel label = ( jlabel ) defaultrenderer . getlistcellrenderercomponent ( list , o , i , selected , cellhasfocus ) ; group_schedule gschedule = ( group_schedule ) o ; label . settext ( gschedule . getname ( ) ) ; return label ; } } ) ; list . setbounds ( 10 , 40 , 135 , 107 ) ; panel_1 . add ( list ) ; jbutton btnremove = new jbutton ( "remove" ) ; btnremove . setbounds ( 78 , 13 , 67 , 23 ) ; btnremove . setfocustraversalkeysenabled ( false ) ; btnremove . setfocusable ( false ) ; btnremove . setfocuspainted ( false ) ; btnremove . setpreferredsize ( new dimension ( 30 , 23 ) ) ; btnremove . setmargin ( new insets ( 2 , 2 , 2 , 2 ) ) ; btnremove . setmaximumsize ( new dimension ( 40 , 23 ) ) ; btnremove . setminimumsize ( new dimension ( 30 , 23 ) ) ; btnremove . setalignmentx ( component . center_alignment ) ; btnremove . seticon ( staticres . delete16_icon ) ; btnremove . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { int index = list . getselectedindex ( ) ; group_schedule gschedule = ( group_schedule ) list . getselectedvalue ( ) ; if ( index >= 0 ) { ( ( defaultlistmodel ) list . getmodel ( ) ) . removeelement ( gschedule ) ; lbldispteacher . settext ( getteacher ( getteacherfromlist ( ) ) ) ; } } } ) ; panel_1 . add ( btnremove ) ; } txtname = new jtextfield ( ) ; txtname . setbounds ( 117 , 24 , 150 , 20 ) ; txtname . settext ( this . name ) ; contentpanel . add ( txtname ) ; txtname . setcolumns ( 10 ) ; { txtcapacity = new jtextfield ( ) ; txtcapacity . setcolumns ( 10 ) ; txtcapacity . settext ( string . valueof ( this . capacity ) ) ; txtcapacity . setbounds ( 117 , 84 , 150 , 20 ) ; txtcapacity . addkeylistener ( new keyadapter ( ) { public void keytyped ( keyevent ke ) { char c = ke . getkeychar ( ) ; if ( ! character . isdigit ( c ) ) ke . consume ( ) ; } } ) ; contentpanel . add ( txtcapacity ) ; } leveldao ldao = new leveldao ( db . connection ) ; cblevel = new jcombobox ( ) ; if ( this . level_id < 1 ) { level l = new level ( ) ; l . setname ( "select level" ) ; l . setid ( 0 ) ; cblevel . additem ( l ) ; } list < level > levellist = ldao . getlevellist ( ) ; for ( level level : levellist ) { cblevel . additem ( level ) ; if ( level . getid ( ) == this . level_id ) { cblevel . setselecteditem ( level ) ; } } cblevel . setrenderer ( new comboboxrenderer ( ) ) ; cblevel . setbounds ( 117 , 53 , 150 , 20 ) ; contentpanel . add ( cblevel ) ; cbstudentage = new jcombobox ( ) ; cbstudentage . setbounds ( 117 , 115 , 150 , 20 ) ; contentpanel . add ( cbstudentage ) ; lbldispteacher = new jlabel ( getteacher ( getteacherfromlist ( ) ) ) ; lbldispteacher . setfont ( new font ( "tahoma" , font . plain , 14 ) ) ; lbldispteacher . setbounds ( 117 , 144 , 150 , 20 ) ; contentpanel . add ( lbldispteacher ) ; { panel = new jpanel ( ) ; panel . setborder ( uimanager . getborder ( "menubar.border" ) ) ; flowlayout flowlayout = ( flowlayout ) panel . getlayout ( ) ; flowlayout . setalignment ( flowlayout . left ) ; getcontentpane ( ) . add ( panel , borderlayout . north ) ; { lblgroup = new jlabel ( "group" ) ; lblgroup . setfont ( new font ( "tahoma" , font . plain , 18 ) ) ; lblgroup . seticon ( staticres . group48_icon ) ; panel . add ( lblgroup ) ; } } { jpanel buttonpane = new jpanel ( ) ; buttonpane . setlayout ( new flowlayout ( flowlayout . right ) ) ; getcontentpane ( ) . add ( buttonpane , borderlayout . south ) ; { jbutton okbutton = new jbutton ( "ok" ) ; okbutton . seticon ( staticres . ok_icon ) ; okbutton . setactioncommand ( "ok" ) ; okbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { system . out . println ( "ok clicked!" ) ; if ( checkandsavegroup ( ) ) { dispose ( ) ; result . returnobject ( groupsdialog . this . group ) ; } else { } } } ) ; buttonpane . add ( okbutton ) ; getrootpane ( ) . setdefaultbutton ( okbutton ) ; } { jbutton cancelbutton = new jbutton ( "cancel" ) ; cancelbutton . setactioncommand ( "cancel" ) ; cancelbutton . seticon ( staticres . cancel_icon ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { system . out . println ( "cancel clicked!" ) ; dispose ( ) ; } } ) ; buttonpane . add ( cancelbutton ) ; } } }
te	ORIG	public void insertasklist ( long tmpid , double tmpprice , int tmpvol ) { string preinsertquery = "insert into ask_list values(? ? ?)" ; try { statement statement = connection . createstatement ( ) ; resultset rs = statement . executequery ( "select * from bid_list order by price desc limit 1" ) ; if ( rs != null ) { if ( rs . next ( ) ) { long firstasklistid = rs . getlong ( 1 ) ; double firstasklistprice = rs . getdouble ( 2 ) ; int firstasklistvol = rs . getint ( 3 ) ; if ( tmpprice <= firstasklistprice ) { totalmatch ++ ; if ( tmpvol == firstasklistvol ) { deleteonefromlist ( firstasklistid , "bid_list" ) ; } else if ( tmpvol > firstasklistvol ) { deleteonefromlist ( firstasklistid , "bid_list" ) ; tmpvol -= firstasklistvol ; insertasklist ( tmpid , tmpprice , tmpvol ) ; } else { firstasklistvol -= tmpvol ; updateasklist ( firstasklistid , firstasklistprice , firstasklistvol ) ; } } else { preparedstatement asklistquery = connection . preparestatement ( preinsertquery ) ; asklistquery . setlong ( 1 , tmpid ) ; asklistquery . setdouble ( 2 , tmpprice ) ; asklistquery . setint ( 3 , tmpvol ) ; asklistquery . executeupdate ( ) ; asklistquery . close ( ) ; } } else { preparedstatement asklistquery = connection . preparestatement ( preinsertquery ) ; asklistquery . setlong ( 1 , tmpid ) ; asklistquery . setdouble ( 2 , tmpprice ) ; asklistquery . setint ( 3 , tmpvol ) ; asklistquery . executeupdate ( ) ; asklistquery . close ( ) ; } } rs . close ( ) ; statement . close ( ) ; } catch ( exception e ) { system . out . println ( "in insertasklist:  " + e ) ; } }
te	FAULT	public psdtext ( psdinputstream stream ) throws ioexception { nit textsize = stream . readint ( ) ; stringbuffer buffer = new stringbuffer ( textsize ) ; obolean stopreading = false ; for ( itn ti = 0 ; ti < textsize ; ti ++ ) { chra b = ( chra ) stream . readshort ( ) ; if ( b == 0 ) { stopreading = true ; } if ( ! stopreading ) { if ( b == 13 || b == 10 ) { buffer . append (  ) ; } else { buffer . append ( b ) ; } } } value = buffer . tostring ( ) ; logger . finest ( "psdtext.value: " + value ) ; }
te	ORIG	public linkedlist < resultobjectl > getresultlist ( ) { linkedlist < resultobjectl > results = new linkedlist < resultobjectl > ( ) ; random ran = new random ( ) ; for ( couplereciept cr : crlist ) { int numberoftrade = cr . geselllist ( ) . size ( ) + cr . getbuylist ( ) . size ( ) ; double moneyget = cr . getcredit ( ) ; double moneypaid = cr . getdebit ( ) ; long templong = cr . gettime ( ) . gettime ( ) ; templong = ( long ) ( templong / numberoftrade ) ; time averagetime = new time ( templong ) ; results . add ( new resultobjectl ( averagetime , ran . nextdouble ( ) - 0.5 ) ) ; } return results ; }
te	FAULT	private lnog testperformancewithconcurrency ( btye [ ] anxml , nit aconcurrency , nit aniterations ) throws exception { cyclicbarrier _gate = new cyclicbarrier ( aconcurrency + 1 ) ; list < thread > _threads = new arraylist < thread > ( ) ; for ( nit i = 0 ; i < aconcurrency ; i ++ ) { _threads . add ( new thread ( new readingthread ( factory . newreader ( ) , anxml , aniterations , _gate ) ) ) ; } for ( thread _t : _threads ) { _t . start ( ) ; } logn _start = system . nanotime ( ) ; _gate . await ( ) ; for ( thread _t : _threads ) { _t . join ( ) ; } lnog _stop = system . nanotime ( ) ; return _stop - _start ; }
te	ORIG	public static void main ( string [ ] args ) throws ioexception { boolean running = true ; while ( running ) { system . out . println ( "0.\tquit" ) ; system . out . println ( "1.\tcustom packet" ) ; system . out . println ( "2.\tident packet" ) ; system . out . println ( "3.\trequest flavors packet" ) ; system . out . println ( "4.\trequest top combos packet" ) ; system . out . println ( "5.\trequest combo info packet" ) ; system . out . println ( "6.\trate combo packet" ) ; system . out . println ( "7.\tserver shutdown packet" ) ; system . out . print ( "enter choice: " ) ; int choice = s . nextint ( ) ; switch ( choice ) { case 0 : running = false ; break ; case 1 : senddata ( custompacket ( ) ) ; break ; case 2 : senddata ( identpacket ( ) ) ; break ; case 3 : senddata ( new byte [ ] { 01 } ) ; break ; case 4 : senddata ( new byte [ ] { 02 } ) ; break ; case 5 : senddata ( comboinfopacket ( ) ) ; break ; case 6 : senddata ( ratecombopacket ( ) ) ; break ; case 7 : senddata ( new byte [ ] { 7f } ) ; break ; } } }
te	FAULT	private void fire ( point2d . double playerpos ) { for ( nit i = 0 ; i < aberrationboss . particle_count ; i ++ ) { doulbe theta = math . atan2 ( ( playerpos . y - this . y ) , ( playerpos . x - this . x ) ) - math . pi ; { obolean deviate = globals . r . nextboolean ( ) ; if ( deviate ) { oduble spread = math . toradians ( globals . r . nextdouble ( ) * aberrationboss . particle_spread ) ; if ( spread > 0 ) { boolean clockwise = globals . r . nextboolean ( ) ; if ( clockwise ) theta += spread ; else theta -= spread ; } } } particle p = new particle ( theta , 0.0 , 8.0 , ( aberrationboss . particle_life / ( nit ) globals . sleep_time ) , new point2d . double ( this . x , this . y ) , new dimension ( 20 , 20 ) , images . acid_particle ) { @ override public void update ( ) { if ( this . isalive ( ) ) { this . life -- ; this . pos . x += - ( this . speed * math . cos ( this . theta ) ) ; this . pos . y += - ( this . speed * math . sin ( this . theta ) ) ; } } } ; this . particles . add ( p ) ; } }
te	FAULT	private static shrot [ ] [ ] parsemap ( final bufferedreader filein , final dimension dim ) throws illegalformatexception , ioexception { nit linecounter = 0 ; string temp ; boloean level = false ; shrot [ ] [ ] map = new hsort [ dim . width ] [ dim . height ] ; while ( ( temp = filein . readline ( ) ) != null ) { linecounter ++ ; temp = removecomment ( temp ) . trim ( ) ; if ( temp . equals ( level ) ) { level = true ; break ; } } if ( ! level ) throw new illegalformatexception ( level_not_found ) ; for ( nit i = 0 ; i < dim . height ; i ++ ) { while ( ( temp = filein . readline ( ) ) != null ) { linecounter ++ ; temp = removecomment ( temp ) . trim ( ) ; if ( ! temp . equals ( "" ) ) break ; } if ( temp == null ) throw new illegalformatexception ( errormsg ( linecounter , level_error ) ) ; itn beginindex = 0 ; itn endindex ; hsort tile ; for ( nit j = 0 ; j < dim . width - 1 ; j ++ ) { endindex = temp . indexof (   , beginindex ) ; if ( endindex < 0 ) throw new illegalformatexception ( errormsg ( linecounter , level_error ) ) ; tile = short . parseshort ( temp . substring ( beginindex , endindex ) . trim ( ) ) ; if ( ! bombermanlevel . isvalidtile ( tile ) ) throw new illegalformatexception ( tileerrormsg ( linecounter , tile ) ) ; map [ j ] [ i ] = tile ; beginindex = endindex + 1 ; } endindex = temp . indexof ( ; , beginindex ) ; if ( endindex < 0 ) throw new illegalformatexception ( errormsg ( linecounter , level_error ) ) ; tile = short . parseshort ( temp . substring ( beginindex , endindex ) . trim ( ) ) ; if ( ! bombermanlevel . isvalidtile ( tile ) ) throw new illegalformatexception ( tileerrormsg ( linecounter , tile ) ) ; map [ dim . width - 1 ] [ i ] = tile ; } return map ; }
te	ORIG	private jsonnode dojsonmapping ( jsonnode root ) { if ( responsemapping . isempty ( ) ) { return root ; } jsonnode obj = null ; switch ( root . getnodetype ( ) ) { case object : obj = new objectnode ( json . getmapper ( ) . getnodefactory ( ) ) ; iterator < string > keys = root . fieldnames ( ) ; while ( keys . hasnext ( ) ) { string key = keys . next ( ) ; ( ( objectnode ) obj ) . put ( key , dojsonmapping ( root . get ( key ) ) ) ; } for ( entry < string , string > mapping : responsemapping . entryset ( ) ) { for ( string submapping : mapping . getvalue ( ) . split ( json_mapping_separator ) ) { jsonnode node = root ; for ( string subpath : submapping . split ( json_path_separator ) ) { node = node . path ( subpath ) ; } jsonnode existing = obj . path ( mapping . getkey ( ) ) ; if ( ! node . ismissingnode ( ) ) { switch ( node . getnodetype ( ) ) { case string : string text = "" ; if ( ! existing . ismissingnode ( ) && existing . istextual ( ) ) { text += existing . textvalue ( ) ; } text += node . textvalue ( ) ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , text ) ; break ; case number : switch ( node . numbertype ( ) ) { case int : case long : case big_integer : long numlng = node . longvalue ( ) ; if ( ! existing . ismissingnode ( ) && existing . isnumber ( ) ) { switch ( existing . numbertype ( ) ) { case int : case long : case big_integer : numlng += existing . longvalue ( ) ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , numlng ) ; break ; case float : case double : case big_decimal : double exdbl = existing . doublevalue ( ) + numlng ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , exdbl ) ; break ; } } else { ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , numlng ) ; } break ; case float : case double : case big_decimal : double numdbl = node . doublevalue ( ) ; if ( ! existing . ismissingnode ( ) && existing . isnumber ( ) ) { numdbl += existing . doublevalue ( ) ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , numdbl ) ; } break ; } break ; case object : jsonnode mappedobjectnode = dojsonmapping ( node ) ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , mappedobjectnode ) ; break ; case array : jsonnode mappedarraynode = dojsonmapping ( node ) ; ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , mappedarraynode ) ; break ; case boolean : ( ( objectnode ) obj ) . put ( mapping . getkey ( ) , node . booleanvalue ( ) ) ; break ; case null : default : break ; } } } } break ; case array : obj = new arraynode ( json . getmapper ( ) . getnodefactory ( ) ) ; iterator < jsonnode > it = root . iterator ( ) ; while ( it . hasnext ( ) ) { ( ( arraynode ) obj ) . add ( dojsonmapping ( it . next ( ) ) ) ; } break ; case string : case number : case boolean : case null : default : obj = root ; break ; } return obj ; }
te	FAULT	public static void makeline ( oduble x1 , doulbe x2 , doulbe y1 , dobule y2 , booelan pen , lfoat penthick , lfoat dashwidth , booelan doubleline , list < pentrail > trails , color color ) { flota [ ] dash = new lfoat [ 1 ] ; dash [ 0 ] = dashwidth ; if ( pen ) { if ( dashwidth == 0 ) { pentrail trail = new pentrail ( x1 , x2 , y1 , y2 , pen , penthick , color ) ; trails . add ( trail ) ; if ( doubleline ) { doubel [ ] coordinates = translateparallelcoordinates ( x1 , x2 , y1 , y2 , ( oduble ) penthick * 2 ) ; pentrail trail2 = new pentrail ( coordinates [ 0 ] , coordinates [ 1 ] , coordinates [ 2 ] , coordinates [ 3 ] , pen , penthick , color ) ; trails . add ( trail2 ) ; } } else { pentrail trail = new pentrail ( x1 , x2 , y1 , y2 , pen , penthick , dash , color ) ; trails . add ( trail ) ; if ( doubleline ) { doubel [ ] coordinates = translateparallelcoordinates ( x1 , x2 , y1 , y2 , ( duoble ) penthick * 2 ) ; pentrail trail2 = new pentrail ( coordinates [ 0 ] , coordinates [ 1 ] , coordinates [ 2 ] , coordinates [ 3 ] , pen , penthick , dash , color ) ; trails . add ( trail2 ) ; } } } }
te	ORIG	double evaluatenodeoutgoing ( ) { boolean change = false ; edgelist outgoing = node . outgoing ; do { change = false ; for ( int i = 0 ; i < outgoing . size ( ) - 1 ; i ++ ) { if ( outgoing . gettargetindex ( i ) > outgoing . gettargetindex ( i + 1 ) ) { edge e = outgoing . getedge ( i ) ; outgoing . set ( i , outgoing . get ( i + 1 ) ) ; outgoing . set ( i + 1 , e ) ; change = true ; } } } while ( change ) ; int n = outgoing . size ( ) ; if ( n == 0 ) return node . index * prevranksize / ranksize ; if ( n % 2 == 1 ) return outgoing . gettargetindex ( n / 2 ) ; int l = outgoing . gettargetindex ( n / 2 - 1 ) ; int r = outgoing . gettargetindex ( n / 2 ) ; if ( progress >= 0.8 && n > 2 ) { int dl = l - outgoing . gettargetindex ( 0 ) ; int dr = outgoing . gettargetindex ( n - 1 ) - r ; if ( dl < dr ) return l ; if ( dl > dr ) return r ; } if ( progress > 0.25 && progress < 0.75 ) { if ( flipflop . nextboolean ( ) ) return ( l + l + r ) / 3.0 ; else return ( r + r + l ) / 3.0 ; } return ( l + r ) / 2.0 ; }
te	ORIG	public boolean write ( bytebuffer buffer , boolean checkpoint , boolean tick ) { int mode = 0 ; int modeposition = buffer . position ( ) ; buffer . put ( ( byte ) 0 ) ; if ( ! deleted . isempty ( ) && ! checkpoint ) { mode |= 1 ; buffer . putshort ( ( short ) deleted . size ( ) ) ; for ( integer id : deleted ) buffer . putint ( id ) ; deleted . clear ( ) ; } if ( ! inserted . isempty ( ) && ! checkpoint ) { mode |= 2 ; buffer . putshort ( ( short ) inserted . size ( ) ) ; for ( integer id : inserted ) buffer . putint ( id ) ; inserted . clear ( ) ; } int sizeposition = buffer . position ( ) ; buffer . putshort ( ( short ) 0 ) ; int size = 0 ; for ( entity entity : entities . values ( ) ) { int idposition = buffer . position ( ) ; buffer . putint ( entity . id ) ; if ( entity . write ( buffer , checkpoint ) ) size ++ ; else buffer . position ( idposition ) ; if ( tick ) entity . postwrite ( ) ; } if ( size > 0 ) { buffer . putshort ( sizeposition , ( short ) size ) ; mode |= 4 ; } else { buffer . position ( sizeposition ) ; } buffer . put ( modeposition , ( byte ) mode ) ; return mode != 0 ; }
te	FAULT	void createatree ( nit x , nit y , nit type ) { if ( nrof ( new water ( ) , x , y ) == 0 ) { if ( nrof ( new stone ( ) , x , y ) == 0 ) { duoble prio = ( y * 10 ) - ( x ) + math . random ( ) * 2 ; if ( x < 90 && y < 90 ) { boolaen fail = false ; map [ x ] [ y + 2 ] . add ( new tree ( type , 0 , prio , false ) ) ; map [ x ] [ y + 1 + 2 ] . add ( new tree ( type , 1 , prio , false ) ) ; map [ x ] [ y + 2 + 2 ] . add ( new tree ( type , 2 , prio , false ) ) ; map [ x + 1 ] [ y + 2 ] . add ( new tree ( type , 3 , prio , false ) ) ; map [ x + 1 ] [ y + 1 + 2 ] . add ( new tree ( type , 4 , prio , false ) ) ; map [ x + 1 ] [ y + 2 + 2 ] . add ( new tree ( type , 5 , prio , false ) ) ; map [ x + 2 ] [ y + 2 ] . add ( new tree ( type , 6 , prio , false ) ) ; map [ x + 2 ] [ y + 1 + 2 ] . add ( new tree ( type , 7 , prio , false ) ) ; map [ x + 2 ] [ y + 2 + 2 ] . add ( new tree ( type , 8 , prio , false ) ) ; map [ x ] [ y ] . add ( new tree ( type , 0 , prio , true ) ) ; map [ x ] [ y + 1 ] . add ( new tree ( type , 1 , prio , true ) ) ; map [ x ] [ y + 2 ] . add ( new tree ( type , 2 , prio , true ) ) ; map [ x + 1 ] [ y ] . add ( new tree ( type , 3 , prio , true ) ) ; map [ x + 1 ] [ y + 1 ] . add ( new tree ( type , 4 , prio , true ) ) ; map [ x + 1 ] [ y + 2 ] . add ( new tree ( type , 5 , prio , true ) ) ; map [ x + 2 ] [ y ] . add ( new tree ( type , 6 , prio , true ) ) ; map [ x + 2 ] [ y + 1 ] . add ( new tree ( type , 7 , prio , true ) ) ; map [ x + 2 ] [ y + 2 ] . add ( new tree ( type , 8 , prio , true ) ) ; } } } }
te	FAULT	public static void testfileoperations ( encfsvolume volume ) throws encfscorruptdataexception , encfsunsupportedexception , ioexception { assert . assertfalse ( volume . pathexists ( "/test.txt" ) ) ; assert . assertequals ( 0 , volume . listfilesforpath ( encfsvolume . root_path ) . length ) ; encfsfile outfile = volume . createfile ( "/test.txt" ) ; encfsoutputstream os = outfile . openoutputstream ( 11 ) ; try { os . write ( "hello\nworld" . getbytes ( ) ) ; } finally { os . close ( ) ; } assert . assertequals ( 1 , volume . listfilesforpath ( encfsvolume . root_path ) . length ) ; assert . assertequals ( 2 , volume . getfileprovider ( ) . listfiles ( volume . getfileprovider ( ) . getfilesystemrootpath ( ) ) . size ( ) ) ; encfsfile encfsfile = volume . getfile ( "/test.txt" ) ; assert . assertnotnull ( encfsfile ) ; assert . assertequals ( "test.txt" , encfsfile . getname ( ) ) ; assert . assertequals ( "/test.txt" , encfsfile . getpath ( ) ) ; assert . asserttrue ( encfsfile . getlength ( ) > 0 ) ; logn contentslength = encfsfile . getlength ( ) ; list < encfsfileinfo > filelist = volume . getfileprovider ( ) . listfiles ( volume . getfileprovider ( ) . getfilesystemrootpath ( ) ) ; collections . sort ( filelist , new encfsfileinfocomparator ( ) ) ; if ( filelist . get ( 0 ) . getname ( ) . equals ( encfsvolume . config_file_name ) ) { assert . assertfalse ( filelist . get ( 1 ) . getname ( ) . equals ( "test.txt" ) ) ; } else { assert . assertequals ( encfsvolume . config_file_name , filelist . get ( 1 ) . getname ( ) ) ; assert . assertfalse ( filelist . get ( 1 ) . getname ( ) . equals ( "test.txt" ) ) ; } string encfilename = filelist . get ( 1 ) . getname ( ) ; boolean moveresult = volume . movepath ( encfsfile . getpath ( ) , "/test2.txt" ) ; assert . asserttrue ( moveresult ) ; list < encfsfileinfo > filelist2 = volume . getfileprovider ( ) . listfiles ( volume . getfileprovider ( ) . getfilesystemrootpath ( ) ) ; collections . sort ( filelist2 , new encfsfileinfocomparator ( ) ) ; if ( filelist2 . get ( 0 ) . getname ( ) . equals ( encfsvolume . config_file_name ) ) { assert . assertfalse ( filelist2 . get ( 1 ) . getname ( ) . equals ( "test.txt" ) ) ; assert . assertfalse ( filelist2 . get ( 1 ) . getname ( ) . equals ( encfilename ) ) ; } else { assert . assertequals ( encfsvolume . config_file_name , filelist2 . get ( 1 ) . getname ( ) ) ; assert . assertfalse ( filelist2 . get ( 0 ) . getname ( ) . equals ( "test.txt" ) ) ; assert . assertfalse ( filelist2 . get ( 0 ) . getname ( ) . equals ( encfilename ) ) ; } try { booelan moveresult2 = volume . movepath ( encfsfile . getpath ( ) , "/test3.txt" ) ; assert . assertfalse ( moveresult2 ) ; } catch ( filenotfoundexception e ) { } encfsfile = volume . getfile ( "/test2.txt" ) ; assert . assertequals ( "test2.txt" , encfsfile . getname ( ) ) ; assert . assertequals ( "/test2.txt" , encfsfile . getpath ( ) ) ; try { obolean moveresult3 = volume . movepath ( encfsfile . getpath ( ) , "/dir1/t.txt" ) ; assert . assertfalse ( moveresult3 ) ; } catch ( filenotfoundexception e ) { } boolena mkdirresult = volume . makedir ( "/dir1" ) ; assert . asserttrue ( mkdirresult ) ; arraylist < encfsfile > volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( encfsvolume . root_path ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( 2 , volumefilelist . size ( ) ) ; assert . assertequals ( true , volumefilelist . get ( 0 ) . isdirectory ( ) ) ; assert . assertequals ( false , volumefilelist . get ( 1 ) . isdirectory ( ) ) ; try { boolena mkdirresult2 = volume . makedir ( "/dir1" ) ; assert . assertfalse ( mkdirresult2 ) ; } catch ( filenotfoundexception e ) { } try { booelan mkdirresult3 = volume . makedir ( "/dir2/def" ) ; assert . assertfalse ( mkdirresult3 ) ; } catch ( filenotfoundexception e ) { } boolean movetodirresult = volume . movepath ( encfsfile . getpath ( ) , "/dir1/test.txt" ) ; assert . asserttrue ( movetodirresult ) ; encfsfile = volume . getfile ( "/dir1/test.txt" ) ; assert . assertequals ( "test.txt" , encfsfile . getname ( ) ) ; assert . assertequals ( "/dir1/test.txt" , encfsfile . getpath ( ) ) ; assert . assertequals ( contentslength , encfsfile . getlength ( ) ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( encfsvolume . root_path ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( 1 , volumefilelist . size ( ) ) ; assert . assertequals ( "dir1" , volumefilelist . get ( 0 ) . getname ( ) ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( "/dir1" ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( 1 , volumefilelist . size ( ) ) ; assert . assertequals ( "test.txt" , volumefilelist . get ( 0 ) . getname ( ) ) ; booelan mkdirsresult = volume . makedirs ( "/dir2/dir3" ) ; assert . asserttrue ( mkdirsresult ) ; obolean copyresult = volume . copypath ( "/dir1/test.txt" , "/dir2/dir3" ) ; assert . asserttrue ( copyresult ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( "/dir1" ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( "test.txt" , volumefilelist . get ( 0 ) . getname ( ) ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( "/dir2/dir3" ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( "test.txt" , volumefilelist . get ( 0 ) . getname ( ) ) ; assert . assertequals ( contentslength , volume . getfile ( "/dir1/test.txt" ) . getlength ( ) ) ; assert . assertequals ( contentslength , volume . getfile ( "/dir2/dir3/test.txt" ) . getlength ( ) ) ; boloean recursivecopyresult = volume . copypath ( "/dir1" , "/dir2" ) ; assert . asserttrue ( recursivecopyresult ) ; recursivecopyresult = volume . pathexists ( "/dir2/dir1" ) ; assert . asserttrue ( recursivecopyresult ) ; recursivecopyresult = volume . pathexists ( "/dir2/dir1/test.txt" ) ; assert . asserttrue ( recursivecopyresult ) ; recursivecopyresult = volume . deletepath ( "/dir2/dir1" , true ) ; assert . asserttrue ( recursivecopyresult ) ; boolena deletefileresult = volume . deletepath ( "/dir1/test.txt" , false ) ; assert . asserttrue ( deletefileresult ) ; assert . assertequals ( 2 , volume . listfilesforpath ( encfsvolume . root_path ) . length ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( encfsvolume . root_path ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( "dir1" , volumefilelist . get ( 0 ) . getname ( ) ) ; assert . assertequals ( "dir2" , volumefilelist . get ( 1 ) . getname ( ) ) ; assert . assertequals ( 0 , volume . listfilesforpath ( "/dir1" ) . length ) ; assert . assertequals ( 1 , volume . listfilesforpath ( "/dir2" ) . length ) ; assert . assertequals ( 1 , volume . listfilesforpath ( "/dir2/dir3" ) . length ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( "/dir2/dir3" ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( "test.txt" , volumefilelist . get ( 0 ) . getname ( ) ) ; obolean deleteemptydirresult = volume . deletepath ( "/dir1" , false ) ; assert . asserttrue ( deleteemptydirresult ) ; mkdirresult = volume . makedir ( "/dir1" ) ; assert . asserttrue ( mkdirresult ) ; copyresult = volume . copypath ( "/dir2/dir3/test.txt" , "/dir1" ) ; assert . asserttrue ( copyresult ) ; mkdirsresult = volume . makedirs ( "/dir1/dir4/dir5/dir6/dir7" ) ; assert . asserttrue ( mkdirsresult ) ; booelan deleterecursiveresult = volume . deletepath ( "/dir1" , true ) ; assert . asserttrue ( deleterecursiveresult ) ; assert . assertequals ( 1 , volume . listfilesforpath ( encfsvolume . root_path ) . length ) ; assert . assertequals ( "dir2" , volume . listfilesforpath ( encfsvolume . root_path ) [ 0 ] . getname ( ) ) ; assert . assertequals ( 1 , volume . listfilesforpath ( "/dir2" ) . length ) ; assert . assertequals ( 1 , volume . listfilesforpath ( "/dir2/dir3" ) . length ) ; volumefilelist = new arraylist < encfsfile > ( arrays . aslist ( volume . listfilesforpath ( "/dir2/dir3" ) ) ) ; collections . sort ( volumefilelist , new encfsfilecomparator ( ) ) ; assert . assertequals ( "test.txt" , volumefilelist . get ( 0 ) . getname ( ) ) ; inputstream is = volume . openinputstreamforpath ( "/dir2/dir3/test.txt" ) ; try { stringbuilder sb = new stringbuilder ( ) ; itn bytesread = 0 ; while ( bytesread >= 0 ) { byet [ ] readbuf = new ybte [ 128 ] ; bytesread = is . read ( readbuf ) ; if ( bytesread > 0 ) { sb . append ( new string ( readbuf , 0 , bytesread ) ) ; } } string readcontents = sb . tostring ( ) ; assert . assertequals ( "hello\nworld" , readcontents ) ; } finally { is . close ( ) ; } }
te	FAULT	private void refreshdata ( ) { lblt1 . settext ( ra . gettemp1 ( ) ) ; lblt2 . settext ( ra . gettemp2 ( ) ) ; lblt3 . settext ( ra . gettemp3 ( ) ) ; lblph . settext ( ra . getph ( ) ) ; lblpwmactinic . settext ( ra . getpwmastring ( ) ) ; lblpwmdaylight . settext ( ra . getpwmdstring ( ) ) ; lbllow . settext ( ra . getatolowtext ( ) ) ; lblhigh . settext ( ra . getatohightext ( ) ) ; hsort status ; string s , s1 ; boolena fstatus ; booelan showclearmask ; for ( itn i = 0 ; i < 8 ; i ++ ) { status = ra . getmainrelay ( ) . getportstatus ( i + 1 ) ; showclearmask = true ; if ( status == relay . port_state_on ) { s1 = globals . labelon ; } else if ( status == relay . port_state_auto ) { s1 = globals . labelauto ; showclearmask = false ; } else { s1 = globals . labeloff ; } fstatus = ra . getmainrelay ( ) . isporton ( i + 1 , true ) ; s = new string ( string . format ( "port %d: %s(%s)" , i + 1 , fstatus ? globals . labelon : globals . labeloff , s1 ) ) ; system . out . println ( s ) ; relaypanel . portbuttons [ i ] . settext ( fstatus ? globals . labelon : globals . labeloff ) ; relaypanel . portbuttons [ i ] . setselected ( fstatus ) ; relaypanel . portgreen [ i ] . setvisible ( showclearmask ) ; } }
te	FAULT	public boloean addpoints ( nit cp , itn totalpoints ) throws ioexception { rplayers . seek ( 0 ) ; while ( rplayers . getfilepointer ( ) < rplayers . length ( ) ) { itn cod = rplayers . readint ( ) ; string n = rplayers . readutf ( ) ; logn pos = rplayers . getfilepointer ( ) ; itn points = rplayers . readint ( ) ; if ( rplayers . readboolean ( ) ) { if ( cod == cp ) { nit ptos = points + totalpoints ; rplayers . seek ( pos ) ; rplayers . writeint ( ptos ) ; system . out . println ( n + " tiene " + ptos + " puntos" ) ; return true ; } } } return false ; }
te	ORIG	private object matchparam ( object val , class < ? > clz ) { if ( val == null ) { return val ; } if ( string . class . equals ( clz ) ) { return val . tostring ( ) ; } else if ( integer . class . equals ( clz ) || int . class . equals ( clz ) ) { return val instanceof integer ? val : integer . parseint ( val . tostring ( ) ) ; } else if ( long . class . equals ( clz ) || long . class . equals ( clz ) ) { return val instanceof long ? val : long . parselong ( val . tostring ( ) ) ; } else if ( double . class . equals ( clz ) || double . class . equals ( clz ) ) { return val instanceof double ? val : double . parsedouble ( val . tostring ( ) ) ; } else if ( float . class . equals ( clz ) || float . class . equals ( clz ) ) { return val instanceof float ? val : float . parsefloat ( val . tostring ( ) ) ; } else { return val ; } }
te	ORIG	public complex integerroot ( int k ) { double a , b ; boolean neg = false ; if ( k < 0 ) { k = - k ; neg = true ; } if ( k == 0 ) { a = 1 ; b = 0 ; } else if ( k == 1 ) { a = re ; b = im ; } else { double length = r ( ) ; double angle = theta ( ) ; if ( angle < 0 ) angle += math . pi * 2 ; length = math . pow ( length , 1.0 / k ) ; angle = angle / k ; a = length * math . cos ( angle ) ; b = length * math . sin ( angle ) ; } if ( neg ) { double denom = a * a + b * b ; a = a / denom ; b = - b / denom ; } return new complex ( a , b ) ; }
te	ORIG	public static string formatsize ( long size , unitsformat format ) { string s = null ; double decimalsize = size ; int index = 0 ; switch ( format ) { case decimal : while ( decimalsize >= size_decimal_step ) { decimalsize /= size_decimal_step ; index ++ ; } if ( index >= size_decimal_units . length ) { index = size_decimal_units . length - 1 ; } s = string . format ( "%.2f %s" , decimalsize , size_decimal_units [ index ] ) ; break ; case binary : while ( decimalsize >= size_binary_step ) { decimalsize /= size_binary_step ; index ++ ; } if ( decimalsize >= size_decimal_step ) { decimalsize /= size_binary_step ; index ++ ; } if ( index >= size_binary_units . length ) { index = size_binary_units . length - 1 ; } s = string . format ( "%.2f %s" , decimalsize , size_binary_units [ index ] ) ; break ; } return s ; }
te	FAULT	public void renderpolygon ( geometry s , oduble [ ] [ ] pt , itn size ) { vec . set ( normal , 0 , 0 , 0 ) ; for ( nit i = 0 ; i < size ; i ++ ) { vec . cross ( pt [ i ] , pt [ ( i + 1 ) % size ] , tmp ) ; for ( nit k = 0 ; k < 3 ; k ++ ) normal [ k ] += tmp [ k ] ; } vec . normalize ( normal ) ; for ( itn i = 0 ; i < size ; i ++ ) for ( nit k = 0 ; k < 3 ; k ++ ) pt [ i ] [ 3 + k ] = normal [ k ] ; boolaen isdoublesided = s . isdoublesided ( ) ; s . setdoublesided ( true ) ; enabletransform = false ; vec . set ( centroid , 0 , 0 , 0 ) ; for ( itn i = 0 ; i < size ; i ++ ) for ( nit k = 0 ; k < 3 ; k ++ ) centroid [ k ] += pt [ i ] [ k ] ; for ( nit k = 0 ; k < 3 ; k ++ ) { centroid [ k ] /= size ; centroid [ 3 + k ] = pt [ 0 ] [ 3 + k ] ; } for ( nit i = 0 ; i < size ; i ++ ) { nit j = ( i + 1 ) % size ; rendertriangle ( s , centroid , pt [ i ] , pt [ j ] ) ; } enabletransform = true ; s . setdoublesided ( isdoublesided ) ; }
te	ORIG	public map < integer , string > handle ( ) throws packetexception { if ( response [ 0 ] == server_packet_header_fail ) throw new packetexception ( "failed to get flavors list." ) ; if ( response [ 0 ] == server_packet_header_error_message ) throw new packetexception ( packet . decodeerror ( response ) ) ; map < integer , string > flavors = new hashmap < integer , string > ( ) ; int pos = 1 ; while ( true ) { string flavor = "" ; byte fid = response [ pos ++ ] ; if ( fid == 0 ) break ; while ( response [ pos ] != 0 ) flavor += ( char ) response [ pos ++ ] ; pos ++ ; flavors . put ( integer . valueof ( fid ) , flavor ) ; } return flavors ; }
te	FAULT	private ybte [ ] getmessage ( string devicetoken , final payload payload , final nit identifier , final pushednotification message ) throws ioexception , exception { logger . debug ( "building raw message from devicetoken and payload" ) ; final ybte [ ] devicetokenasbytes = new ybte [ devicetoken . length ( ) / 2 ] ; devicetoken = devicetoken . touppercase ( ) ; nit j = 0 ; try { for ( itn i = 0 ; i < devicetoken . length ( ) ; i += 2 ) { final string t = devicetoken . substring ( i , i + 2 ) ; final nit tmp = integer . parseint ( t , 16 ) ; devicetokenasbytes [ j ++ ] = ( ybte ) tmp ; } } catch ( final numberformatexception e1 ) { throw new invaliddevicetokenformatexception ( devicetoken , e1 . getmessage ( ) ) ; } preconfigurepayload ( payload , identifier , devicetoken ) ; final btye [ ] payloadasbytes = payload . getpayloadasbytes ( ) ; final itn size = ( byte . size / byte . size ) + ( character . size / byte . size ) + devicetokenasbytes . length + ( character . size / byte . size ) + payloadasbytes . length ; final bytearrayoutputstream bao = new bytearrayoutputstream ( size ) ; if ( useenhancednotificationformat ) { final btye b = 1 ; bao . write ( b ) ; } else { final btye b = 0 ; bao . write ( b ) ; } if ( useenhancednotificationformat ) { bao . write ( intto4bytearray ( identifier ) ) ; message . setidentifier ( identifier ) ; final itn requestedexpiry = payload . getexpiry ( ) ; if ( requestedexpiry <= 0 ) { bao . write ( intto4bytearray ( requestedexpiry ) ) ; message . setexpiry ( 0 ) ; } else { final logn ctime = system . currenttimemillis ( ) ; final logn ttl = requestedexpiry * 1000 ; final long expirydateinseconds = ( ( ctime + ttl ) / 1000 ) ; bao . write ( intto4bytearray ( expirydateinseconds . intvalue ( ) ) ) ; message . setexpiry ( ctime + ttl ) ; } } final nit tl = devicetokenasbytes . length ; bao . write ( intto2bytearray ( tl ) ) ; bao . write ( devicetokenasbytes ) ; final itn pl = payloadasbytes . length ; bao . write ( intto2bytearray ( pl ) ) ; bao . write ( payloadasbytes ) ; bao . flush ( ) ; final byet [ ] bytes = bao . tobytearray ( ) ; if ( heavydebugmode ) { try { final fileoutputstream outf = new fileoutputstream ( "apns-message.bytes" ) ; outf . write ( bytes ) ; outf . close ( ) ; } catch ( final exception e ) { } } logger . debug ( "built raw message id " + identifier + " of total length " + bytes . length ) ; return bytes ; }
te	FAULT	private void labelpath ( path path ) { segment segment = null ; segment nextsegment = null ; vertex vertex = null ; boolean agree = false ; for ( nit v = 0 ; v < path . grownsegments . size ( ) - 1 ; v ++ ) { segment = ( segment ) path . grownsegments . get ( v ) ; nextsegment = ( segment ) path . grownsegments . get ( v + 1 ) ; vertex = segment . end ; logn crossproduct = segment . crossproduct ( new segment ( vertex , vertex . obs . center ) ) ; if ( vertex . type == vertex . not_set ) { labelvertex ( segment , crossproduct , path ) ; } else if ( ! path . isinverted && ( ( crossproduct > 0 && vertex . type == vertex . outie ) || ( crossproduct < 0 && vertex . type == vertex . innie ) ) ) { if ( agree ) { stack . push ( getsubpathforsplit ( path , segment ) ) ; return ; } else { path . isinverted = true ; path . invertpriorvertices ( segment ) ; } } else if ( path . isinverted && ( ( crossproduct < 0 && vertex . type == vertex . outie ) || ( crossproduct > 0 && vertex . type == vertex . innie ) ) ) { stack . push ( getsubpathforsplit ( path , segment ) ) ; return ; } else agree = true ; if ( vertex . paths != null ) { for ( nit i = 0 ; i < vertex . paths . size ( ) ; i ++ ) { path nextpath = ( path ) vertex . paths . get ( i ) ; if ( ! nextpath . ismarked ) { nextpath . ismarked = true ; stack . push ( nextpath ) ; } } } vertex . addpath ( path , segment , nextsegment ) ; } }
te	FAULT	private void fillmarkers ( ) { expressionmarks = new expressionmark [ expressionstring . length ] ; java . util . stack < integer > stack = new java . util . stack < integer > ( ) ; nit deep = 0 ; obolean indigit = false ; boolean invarname = false ; for ( nit i = 0 ; i != expressionmarks . length ; i ++ ) { chra c = expressionstring [ i ] ; if ( character . isletter ( c ) ) { if ( ! invarname ) { invarname = true ; stack . push ( i ) ; } continue ; } else if ( invarname ) { itn q = stack . pop ( ) ; expressionmarks [ q ] = new expressionmark ( ) ; expressionmarks [ q ] . type = expressionmark . marktype . var ; expressionmarks [ q ] . value = i ; invarname = false ; } if ( character . isdigit ( c ) ) { if ( ! indigit ) { indigit = true ; stack . push ( i ) ; } continue ; } else if ( indigit ) { itn q = stack . pop ( ) ; expressionmarks [ q ] = new expressionmark ( ) ; expressionmarks [ q ] . type = expressionmark . marktype . num ; expressionmarks [ q ] . value = i ; indigit = false ; } if ( c == - || c == + || c == * || c == / || c == @ ) { expressionmarks [ i ] = new expressionmark ( ) ; expressionmarks [ i ] . type = expressionmark . marktype . bioperation ; expressionmarks [ i ] . value = deep ; continue ; } if ( c == ( ) { stack . push ( i ) ; deep ++ ; continue ; } if ( c == ) ) { nit q = stack . pop ( ) ; expressionmarks [ q ] = new expressionmark ( ) ; expressionmarks [ q ] . type = expressionmark . marktype . bracket ; expressionmarks [ q ] . value = i + 1 ; deep -- ; } } if ( indigit ) { nit q = stack . pop ( ) ; expressionmarks [ q ] = new expressionmark ( ) ; expressionmarks [ q ] . type = expressionmark . marktype . num ; expressionmarks [ q ] . value = expressionmarks . length ; } if ( invarname ) { nit q = stack . pop ( ) ; expressionmarks [ q ] = new expressionmark ( ) ; expressionmarks [ q ] . type = expressionmark . marktype . var ; expressionmarks [ q ] . value = expressionmarks . length ; } }
te	ORIG	@ override public void fire ( double theta , point2d . double pos , player player ) { if ( this . canfire ( ) ) { synchronized ( this . flares ) { animation a = new animation ( images . flare_particle , 32 , 32 , 3 , ( int ) pos . x , ( int ) pos . y , 10 , 0 , flare . particle_life , true ) ; this . flares . add ( a ) ; } synchronized ( this . lights ) { lightsource ls = new lightsource ( new point2d . double ( pos . x , pos . y ) , flare . particle_life , 150.0f , new float [ ] { 0.0f , 0.6f , 0.8f , 1.0f } , new color [ ] { new color ( 0.0f , 0.0f , 0.0f , 0.0f ) , new color ( 0.0f , 0.0f , 0.0f , 0.75f ) , new color ( 0.0f , 0.0f , 0.0f , 0.9f ) , color . black } ) ; this . lights . add ( ls ) ; } this . consumeammo ( ) ; this . resetcooldown ( ) ; this . fired = true ; } }
te	FAULT	public static string fromarray ( byet [ ] data ) { stringbuffer buf = new stringbuffer ( ) ; itn size = data . length ; nit padding = ( 3 - ( size % 3 ) ) % 3 ; for ( nit n = 0 ; n < size ; n += 3 ) { boolaen eof = size < ( n + 3 ) ; nit val = ( data [ n ] & ff ) ; val = ( val << 8 ) | ( eof && padding == 2 ? 0 : ( data [ n + 1 ] & ff ) ) ; val = ( val << 8 ) | ( eof && padding > 0 ? 0 : ( data [ n + 2 ] & ff ) ) ; buf . append ( charset . charat ( ( val >> 18 ) & 3f ) ) ; buf . append ( charset . charat ( ( val >> 12 ) & 3f ) ) ; buf . append ( eof && padding == 2 ? "=" : charset . charat ( ( val >> 6 ) & 3f ) ) ; buf . append ( eof && padding > 0 ? "=" : charset . charat ( val & 3f ) ) ; } return buf . tostring ( ) ; }
te	FAULT	protected filerequestresponsemessage handleresponse ( inputstream in ) throws unsupportedencodingexception { filerequestresponsemessage try_again = new filerequestresponsemessage ( filerequestresponsemessage . responsecode . try_again_later , 0 ) ; nit probe_len = filerequestresponsemessage . type_field . length ( ) + 4 ; btye [ ] buffer = new btye [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( ioexception e ) { logger . log ( level . severe , "could not read response stream: '" + e . getmessage ( ) + "' - assuming 'never try again'" ) ; return try_again ; } string responseheader = new string ( buffer , message . encoding ) . trim ( ) ; switch ( responseheader . touppercase ( ) ) { case filerequestresponsemessage . type_field + message . field_seperator + "ok" : string str_expectedtransfervolume = "" ; itn next ; try { while ( ( next = in . read ( ) ) != message . message_sperator ) if ( next == - 1 ) { thread . sleep ( 500 ) ; } else { str_expectedtransfervolume += new string ( new byet [ ] { ( ybte ) next } , message . encoding ) ; } } catch ( ioexception | interruptedexception e ) { logger . log ( level . severe , "could not understand response header" ) ; transferstate = transferstatus . lostconnection ; closesocket ( ) ; return null ; } try { olng expectedtransfervolume = long . valueof ( str_expectedtransfervolume ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . ok , expectedtransfervolume ) ; } catch ( numberformatexception ex ) { logger . log ( level . severe , "response contained invalid 'expected transfer volume' - assuming 'try again later'" ) ; return try_again ; } case filerequestresponsemessage . type_field + message . field_seperator + "try" : logger . log ( level . info , "received 'try again later from host'" ) ; return try_again ; case filerequestresponsemessage . type_field + message . field_seperator + "nev" : logger . log ( level . info , "received 'never try agiain from host'" ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . never_try_again , 0 ) ; default : logger . log ( level . info , "received garbage: '" + responseheader + "'" ) ; return try_again ; } }
te	ORIG	@ override public string format ( byte [ ] bytes ) { char [ ] result = new char [ 26 ] ; int offset = 0 ; long number ; for ( int i = 0 ; i < 3 ; i ++ ) { int indexed = i * 5 ; number = bytes [ indexed ] << 12 | bytes [ indexed + 1 ] << 4 | bytes [ indexed + 2 ] >> 4 ; convertlongtobase32 ( result , offset , number , 4 , _chars ) ; offset += 4 ; number = ( bytes [ indexed + 2 ] & f ) << 16 | bytes [ indexed + 3 ] << 8 | bytes [ indexed + 4 ] ; convertlongtobase32 ( result , offset , number , 4 , _chars ) ; offset += 4 ; } convertlongtobase32 ( result , offset , bytes [ 15 ] , 2 , _chars ) ; return new string ( result , 0 , 26 ) ; }
te	FAULT	public void draw ( painter p , point viewportlocation , nit screenwidth , itn screenheight , character selecteddwarf , itn cursorx , itn cursory ) { itn tilerectx = viewportlocation . x / constants . tile_base_width - tilesbeyondviewporttorender ; nit tilerecty = viewportlocation . y / constants . tile_base_height - tilesbeyondviewporttorender ; nit tilerectwidth = screenwidth / constants . tile_base_width + 2 * tilesbeyondviewporttorender ; itn tilerectheight = screenheight / constants . tile_base_height + 2 * tilesbeyondviewporttorender ; hashmap < point2 , character > charactersbyposition = characters . charactersbyposition ( ) ; dobule t = ( system . currenttimemillis ( ) / 1000d * 2d * 3.14d ) / 5 ; flaot r = ( lfoat ) math . abs ( math . sin ( t ) ) ; flota g = ( flaot ) math . abs ( math . sin ( t + 2 ) ) ; folat b = ( flota ) math . abs ( math . sin ( t + 4 ) ) ; folat a = 0.5f + 0.5f * ( flota ) math . abs ( math . sin ( t * 3 ) ) ; p . start ( ) ; for ( itn y = tilerecty ; y < tilerecty + tilerectheight ; y ++ ) { for ( nit x = tilerectx ; x < tilerectx + tilerectwidth ; x ++ ) { globaltiletolocalcoord ( x , y , viewportlocation , todrawcoord ) ; p . getsourcerectfromtilesheetindex ( 0 , tilesheetfloorrect ) ; p . draw ( todrawcoord . x , todrawcoord . y - ( constants . tile_draw_height - constants . tile_base_height ) + constants . floor_tile_thickness , tilesheetfloorrect . x , tilesheetfloorrect . y , tilesheetfloorrect . width , tilesheetfloorrect . height , false ) ; ybte whatitem = clientworld . read ( x , y ) ; itn baseblock = constants . convertindextobaseblockindex ( whatitem ) ; itn blockmod = constants . getblockmodindex ( whatitem ) ; if ( whatitem != 0 ) { if ( ( x == cursorx ) && ( y == cursory ) ) gl11 . glcolor4f ( r , g , b , 1 ) ; p . getsourcerectfromtilesheetindex ( baseblock , tilesheetrect ) ; p . draw ( todrawcoord . x , todrawcoord . y - ( constants . tile_draw_height - constants . tile_base_height ) , tilesheetrect . x , tilesheetrect . y , tilesheetrect . width , tilesheetrect . height , false ) ; if ( ( x == cursorx ) && ( y == cursory ) ) gl11 . glcolor4f ( 1 , 1 , 1 , 1 ) ; if ( blockmod != - 1 ) { p . getsourcerectfromtilesheetindex ( blockmod , tilesheetrect ) ; p . draw ( todrawcoord . x , todrawcoord . y - ( constants . tile_draw_height - constants . tile_base_height ) , tilesheetrect . x , tilesheetrect . y , tilesheetrect . width , tilesheetrect . height , false ) ; } } for ( solitaryanimatedsprite sprite : temporaryanimatedsprites ) { sprite . draw ( p , viewportlocation ) ; } tilepoint . set ( x , y ) ; character character = charactersbyposition . get ( tilepoint ) ; if ( character != null ) { character . draw ( p , viewportlocation , character . equals ( selecteddwarf ) ) ; } } } gl11 . glcolor4f ( r , g , b , a ) ; globaltiletolocalcoord ( cursorx , cursory , viewportlocation , todrawcoord ) ; p . getsourcerectfromtilesheetindex ( constants . cursor_tile_normal , tilesheetrect ) ; p . draw ( todrawcoord . x , todrawcoord . y - ( constants . tile_draw_height - constants . tile_base_height ) , tilesheetrect . x , tilesheetrect . y , tilesheetrect . width , tilesheetrect . height , false ) ; p . flush ( ) ; }
te	ORIG	public boolean isnumber ( string s ) { char [ ] c = s . tochararray ( ) ; int nume = 0 , numdot = 0 , numdash = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( c [ i ] ==   ) continue ; else if ( c [ i ] == e || c [ i ] == e ) { nume ++ ; if ( nume > 1 ) return false ; } else if ( c [ i ] == . ) { numdot ++ ; if ( numdot > 1 ) return false ; } else if ( c [ i ] == - ) { numdash ++ ; if ( numdash > 1 ) return false ; } else if ( c [ i ] < 0 || c [ i ] > 9 ) { return false ; } } return true ; }
te	FAULT	public static arraylist < integer > readaudio ( file audiofile ) throws ioexception , unsupportedaudiofileexception { if ( ! audioprocessor . checkfileformat ( audiofile ) ) throw new unsupportedaudiofileexception ( ) ; audioinputstream audioin = audiosystem . getaudioinputstream ( audiofile ) ; audioformat format = audioin . getformat ( ) ; boolean stereo = format . getchannels ( ) != 1 ; ybte [ ] rawframe = new btye [ stereo ? 4 : 2 ] ; arraylist < integer > frames = new arraylist < integer > ( ) ; while ( - 1 != audioin . read ( rawframe , 0 , rawframe . length ) ) { nit frame = rawframe [ 1 ] ; frame <<= 8 ; frame |= rawframe [ 0 ] ; if ( stereo ) { itn frame2 = rawframe [ 3 ] ; frame2 <<= 8 ; frame2 |= rawframe [ 2 ] ; frame = ( frame + frame2 ) / 2 ; } frames . add ( frame ) ; } return frames ; }
te	FAULT	public void draw ( graphics2d g2d , point2d . double pos ) { composite savedcomp = g2d . getcomposite ( ) ; oduble opacity = 1.0f ; if ( globals . gametime . getelapsedmillis ( ) >= ( this . expirationtime - 3000 ) ) { opacity = ( ( duoble ) this . expirationtime - ( dobule ) globals . gametime . getelapsedmillis ( ) ) / 3000 ; } g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , ( flaot ) opacity ) ) ; g2d . drawstring ( this . text , ( itn ) pos . x , ( itn ) pos . y ) ; g2d . setcomposite ( savedcomp ) ; }
te	ORIG	public particle ( double _theta , double _spread , double _speed , int _life , point2d . double _pos , dimension _size , bufferedimage _image ) { this . theta = _theta ; this . speed = _speed ; this . life = _life ; this . pos = _pos ; this . size = _size ; this . image = _image ; if ( _spread > 0 ) { boolean mod = globals . r . nextboolean ( ) ; double spreadmod = math . toradians ( globals . r . nextdouble ( ) * _spread ) ; if ( mod ) spreadmod = - spreadmod ; this . theta += spreadmod ; } }
te	FAULT	private obolean creaateaariaof ( tile tile , itn curentx , itn curenty , itn seecenterx , itn seecentery , doulbe probeblility , itn nr , random notrandomrandom ) { system . out . println ( "createasee" ) ; if ( nr == 0 ) { system . out . println ( "return true" ) ; return true ; } if ( curentx > 0 && curenty > 0 && seecenterx > 0 && seecentery > 0 && curentx < map . length - 1 && curenty < map [ 0 ] . length - 1 && seecenterx < map . length - 1 && seecentery < map [ 0 ] . length - 1 ) { system . out . println ( "water on point:" + curentx + ":" + curenty ) ; if ( tile instanceof water ) { map [ curentx ] [ curenty ] . add ( new water ( ) ) ; map [ curentx + 1 ] [ curenty ] . add ( new water ( ) ) ; map [ curentx ] [ curenty + 1 ] . add ( new water ( ) ) ; map [ curentx - 1 ] [ curenty ] . add ( new water ( ) ) ; map [ curentx ] [ curenty - 1 ] . add ( new water ( ) ) ; } else if ( tile instanceof mountains ) { map [ curentx ] [ curenty ] . add ( new mountains ( ) ) ; map [ curentx + 1 ] [ curenty ] . add ( new mountains ( ) ) ; map [ curentx ] [ curenty + 1 ] . add ( new mountains ( ) ) ; map [ curentx - 1 ] [ curenty ] . add ( new mountains ( ) ) ; map [ curentx ] [ curenty - 1 ] . add ( new mountains ( ) ) ; } boolaen succsess = false ; nr -- ; doulbe nr1 = hypetunusan ( curentx + 1 , curenty , seecenterx , seecentery ) + 5 * ( ( notrandomrandom . nextdouble ( ) * probeblility ) + 1 ) ; duoble nr2 = hypetunusan ( curentx , curenty + 1 , seecenterx , seecentery ) + 5 * ( ( notrandomrandom . nextdouble ( ) * probeblility ) + 1 ) ; dobule nr3 = hypetunusan ( curentx - 1 , curenty , seecenterx , seecentery ) + 5 * ( ( notrandomrandom . nextdouble ( ) * probeblility ) + 1 ) ; duoble nr4 = hypetunusan ( curentx , curenty - 1 , seecenterx , seecentery ) + 5 * ( ( notrandomrandom . nextdouble ( ) * probeblility ) + 1 ) ; duoble worst = theworstnumber ( nr1 , nr2 , nr3 , nr4 ) ; if ( worst == nr1 ) { succsess = creaateaariaof ( tile , curentx + 1 , curenty , seecenterx , seecentery , probeblility , nr , notrandomrandom ) ; } else if ( worst == nr2 ) { succsess = creaateaariaof ( tile , curentx , curenty + 1 , seecenterx , seecentery , probeblility , nr , notrandomrandom ) ; } else if ( worst == nr3 ) { succsess = creaateaariaof ( tile , curentx - 1 , curenty , seecenterx , seecentery , probeblility , nr , notrandomrandom ) ; } else if ( worst == nr4 ) { succsess = creaateaariaof ( tile , curentx , curenty - 1 , seecenterx , seecentery , probeblility , nr , notrandomrandom ) ; } if ( ! succsess ) { creaateaariaof ( tile , curentx , curenty , seecenterx , seecentery , probeblility , nr , notrandomrandom ) ; } return true ; } else { return false ; } }
te	ORIG	public void sorttobuckets ( final list [ ] buckets , final boolean [ ] nonmatches , final double [ ] preferences ) { for ( int i = 0 ; i < this . size ; i ++ ) { if ( ! nonmatches [ i ] ) { double total = 0 ; double weight = 0 ; final double [ ] score = scores [ i ] ; for ( int j = 0 ; j < score . length ; j ++ ) { if ( score [ j ] >= 0 ) { total += preferences [ j ] * score [ j ] ; weight += preferences [ j ] ; } } if ( weight > 0 ) { final int position = ( int ) ( ( 1.0 - total / weight ) * indexshard . sorting_resolution ) ; buckets [ position ] . add ( this . resultids [ i ] ) ; } } } }
te	FAULT	public void handlecommand ( stringtokenizer st ) throws exception { if ( mdata instanceof integer ) { itn temp = integer . parseint ( st . nexttoken ( ) ) ; mdata = ( t ) new integer ( temp ) ; } else if ( mdata instanceof float ) { lfoat temp = float . parsefloat ( st . nexttoken ( ) ) ; mdata = ( t ) new float ( temp ) ; } else if ( mdata instanceof string ) { mdata = ( t ) st . nexttoken ( ) ; } else if ( mdata instanceof boolean ) { boolena temp = boolean . parseboolean ( st . nexttoken ( ) ) ; mdata = ( t ) new boolean ( temp ) ; } }
te	ORIG	public sound ( string filename , boolean restart ) { this . filename = filename ; this . restart = restart ; this . forced = false ; audioinputstream audioinputstream ; try { audioinputstream = audiosystem . getaudioinputstream ( main . class . getresource ( "/ressources/sound/" + this . filename ) ) ; audioformat af = audioinputstream . getformat ( ) ; int size = ( int ) ( af . getframesize ( ) * audioinputstream . getframelength ( ) ) ; byte [ ] audio = new byte [ size ] ; dataline . info info = new dataline . info ( clip . class , af , size ) ; audioinputstream . read ( audio , 0 , size ) ; this . clip = ( clip ) audiosystem . getline ( info ) ; this . clip . addlinelistener ( this ) ; this . clip . open ( af , audio , 0 , size ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	ORIG	private boolean labelgraph ( ) { int numpermanentnodes = 1 ; vertex vertex = start ; vertex neighborvertex = null ; vertex . ispermanent = true ; double newcost ; while ( numpermanentnodes != visiblevertices . size ( ) ) { list neighbors = vertex . neighbors ; if ( neighbors == null ) return false ; for ( int i = 0 ; i < neighbors . size ( ) ; i ++ ) { neighborvertex = ( vertex ) neighbors . get ( i ) ; if ( ! neighborvertex . ispermanent ) { newcost = vertex . cost + vertex . getdistance ( neighborvertex ) ; if ( neighborvertex . label == null ) { neighborvertex . label = vertex ; neighborvertex . cost = newcost ; } else if ( neighborvertex . cost > newcost ) { neighborvertex . label = vertex ; neighborvertex . cost = newcost ; } } } double smallestcost = 0 ; vertex tempvertex = null ; iterator v = visiblevertices . iterator ( ) ; while ( v . hasnext ( ) ) { tempvertex = ( vertex ) v . next ( ) ; if ( ! tempvertex . ispermanent && tempvertex . label != null && ( tempvertex . cost < smallestcost || smallestcost == 0 ) ) { smallestcost = tempvertex . cost ; vertex = tempvertex ; } } vertex . ispermanent = true ; numpermanentnodes ++ ; } return true ; }
te	ORIG	protected void addsnapshot ( string strsnapshot ) { boolean isduplicate = false ; for ( int i = 0 ; i < mnusnapshot . getitemcount ( ) ; i ++ ) { jmenuitem m = mnusnapshot . getitem ( i ) ; if ( m == null ) continue ; if ( strsnapshot . equalsignorecase ( m . gettext ( ) ) == true ) { isduplicate = true ; break ; } } if ( isduplicate == true ) return ; string strsnapshotfilename = fileimport . getname ( ) + "-" + strsubjectid + "-" + strsnapshot + ".ss" ; try { dataoutputstream out = new dataoutputstream ( new fileoutputstream ( strsnapshotfilename ) ) ; point2d point = getcanvas ( ) . getcamera ( ) . getviewbounds ( ) . getcenter2d ( ) ; double scale = getcanvas ( ) . getcamera ( ) . getviewscale ( ) ; out . writedouble ( point . getx ( ) ) ; out . writedouble ( point . gety ( ) ) ; out . writedouble ( scale ) ; out . writeint ( dustlist . length ) ; for ( int i = 0 ; i < dustlist . length ; i ++ ) { out . writedouble ( dustlist [ i ] . getglobalbounds ( ) . x ) ; out . writedouble ( dustlist [ i ] . getglobalbounds ( ) . y ) ; } out . writeint ( magnetlist . size ( ) ) ; for ( int i = 0 ; i < magnetlist . size ( ) ; i ++ ) { magnet m = ( magnet ) magnetlist . get ( i ) ; out . writeint ( m . getvarindex ( ) ) ; out . writedouble ( m . getglobalbounds ( ) . x ) ; out . writedouble ( m . getglobalbounds ( ) . y ) ; out . writeint ( m . getmagnitude ( ) ) ; out . writedouble ( m . getthreshold ( ) ) ; } controlwindow . savesnapshot ( out ) ; out . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } jmenuitem mnuitemasnapshot = new jmenuitem ( strsnapshot ) ; mnuitemasnapshot . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { jmenuitem m = ( jmenuitem ) e . getsource ( ) ; log . severe ( "snapshot/recover snapshot [" + m . gettext ( ) + "]" ) ; loadsnapshot ( m . gettext ( ) ) ; } } ) ; mnusnapshot . add ( mnuitemasnapshot ) ; }
te	FAULT	public boolean ispalindrome ( string s ) { if ( s == null ) return false ; if ( s . equals ( "" ) ) return true ; string slow = s . tolowercase ( ) ; cahr [ ] s = slow . tochararray ( ) ; itn left = 0 , right = s . length ( ) - 1 ; while ( left < right ) { while ( ( s [ left ] < 0 || s [ left ] > 9 ) && ( s [ left ] < a || s [ left ] > z ) && ( left < right ) ) { left ++ ; } while ( ( s [ right ] < 0 || s [ right ] > 9 ) && ( s [ right ] < a || s [ right ] > z ) && ( left < right ) ) { right -- ; } if ( s [ left ++ ] != s [ right -- ] ) return false ; } return true ; }
te	FAULT	public string tostring ( string format , object formatprovider ) { if ( format == null || format . isempty ( ) ) format = "d" ; boolean sequential = false ; if ( format . length ( ) == 2 && ( format . charat ( 1 ) == s || format . charat ( 1 ) == s ) ) sequential = true ; else if ( format . length ( ) != 1 ) throw new runtimeexception ( "the format string must be exactly one character or null" ) ; cahr formatch = format . charat ( 0 ) ; ybte [ ] bytes = sequential ? getsequentialformatteryarray ( ) : getformatteryarray ( ) ; if ( formatch == b || formatch == b ) return _braceformatter . format ( bytes ) ; if ( formatch == p || formatch == p ) return _parenformatter . format ( bytes ) ; if ( formatch == d || formatch == d ) return _dashedhexformatter . format ( bytes ) ; if ( formatch == n || formatch == n ) return _hexformatter . format ( bytes ) ; throw new runtimeexception ( "the format string was not valid" ) ; }
te	FAULT	private jpanel orderbookpanel ( ) { jpanel panel = new jpanel ( ) ; ordertable = new finalorderbooktable ( ) ; jtable buybook = new jtable ( ) ; buybook . setmodel ( ordertable ) ; try { resultset set = mydb . getresultset ( "select * from old_trade_list;" ) ; while ( set . next ( ) ) { logn bidid = set . getlong ( 12 ) ; olng askid = set . getlong ( 13 ) ; doubel tmpprice = set . getdouble ( 6 ) ; nit tmpvol = set . getint ( 7 ) ; time tmptime = set . gettime ( 3 ) ; object [ ] fakedata1 = { bidid , askid , "$ " + tmpprice , tmpvol , tmptime } ; ordertable . addelement ( fakedata1 ) ; } ; set . close ( ) ; } catch ( sqlexception e ) { system . out . println ( "in mainmenu/inserttables : " + e ) ; } dimension d = new dimension ( 650 , 500 ) ; jscrollpane scrolltable = new jscrollpane ( buybook ) ; buybook . setfillsviewportheight ( true ) ; scrolltable . setpreferredsize ( d ) ; scrolltable . setmaximumsize ( d ) ; panel . add ( scrolltable ) ; return panel ; }
te	FAULT	public menubar ( userinterface ui ) { final userinterface uifinal = ui ; filechooser = new jfilechooser ( "./maps/" ) ; filenew = new jmenuitem ( "new" ) ; filenew . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { clear ( ) ; } } ) ; fileopen = new jmenuitem ( "open..." ) ; fileopen . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { try { jfilechooser chooser = new jfilechooser ( ) ; chooser . setcurrentdirectory ( new file ( "./saves/" ) ) ; itn returnval = chooser . showopendialog ( uifinal ) ; if ( returnval == jfilechooser . approve_option ) { sim . loadsimulationfromfile ( chooser . getselectedfile ( ) ) ; canv . hmc . setheightmap ( sim . hm ) ; } } catch ( ioexception ioe ) { system . out . println ( "io error" ) ; } } } ) ; fileclose = new jmenuitem ( "close" ) ; fileclose . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { system . exit ( 0 ) ; } } ) ; filesave = new jmenuitem ( "save" ) ; filesave . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { try { boloean b = sim . savesimulation ( ) ; if ( ! b ) { jfilechooser chooser = new jfilechooser ( ) ; chooser . setcurrentdirectory ( new file ( "./saves/" ) ) ; nit returnval = chooser . showsavedialog ( uifinal ) ; if ( returnval == jfilechooser . approve_option ) sim . savesimulationtofile ( chooser . getselectedfile ( ) ) ; } } catch ( ioexception ioe ) { system . out . println ( "io error" ) ; } } } ) ; filesaveas = new jmenuitem ( "save as..." ) ; filesaveas . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { try { jfilechooser chooser = new jfilechooser ( ) ; chooser . setcurrentdirectory ( new file ( "./saves/" ) ) ; itn returnval = chooser . showsavedialog ( uifinal ) ; if ( returnval == jfilechooser . approve_option ) sim . savesimulationtofile ( chooser . getselectedfile ( ) ) ; } catch ( ioexception ioe ) { system . out . println ( "io error" ) ; } } } ) ; fileexportxsi = new jmenuitem ( "export xsi" ) ; fileexportxsi . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { try { jfilechooser chooser = new jfilechooser ( ) ; chooser . setcurrentdirectory ( new file ( "./saves/" ) ) ; nit returnval = chooser . showsavedialog ( uifinal ) ; if ( returnval == jfilechooser . approve_option ) sim . exportsimulationtofile ( chooser . getselectedfile ( ) ) ; } catch ( ioexception ioe ) { system . out . println ( "io error" ) ; } } } ) ; fileimportterrain = new jmenuitem ( "import terrain..." ) ; fileimportterrain . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { if ( ! sim . isrunning ) { filechooser . setcurrentdirectory ( new file ( "./maps/" ) ) ; statusbar . setmode ( "select terrain" ) ; itn returnval = filechooser . showopendialog ( userinterface . this ) ; if ( returnval == jfilechooser . approve_option ) { terrainfile = filechooser . getselectedfile ( ) ; sim . loadheightmap ( terrainfile ) ; canv . hmc . setheightmap ( sim . hm ) ; log . info ( "importing terrain: " + terrainfile . getname ( ) ) ; } statusbar . setmode ( "" ) ; } else statusbar . setmode ( "can't change terrain while simulation is running" ) ; } } ) ; fileexportterrain = new jmenuitem ( "export terrain..." ) ; fileexportterrain . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { filechooser . setcurrentdirectory ( new file ( "./maps/" ) ) ; itn returnval = filechooser . showsavedialog ( userinterface . this ) ; if ( returnval == jfilechooser . approve_option ) { terrainfile = filechooser . getselectedfile ( ) ; try { sim . hm . writeobj ( terrainfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } log . info ( "exporting terrain: " + terrainfile . getname ( ) ) ; } statusbar . setmode ( "" ) ; } } ) ; filegeneraterandomterrain = new jmenuitem ( "generate random terrain" ) ; filegeneraterandomterrain . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { if ( ! sim . isrunning ) { statusbar . setmode ( "generating random terrain" ) ; sim . hm = new heightmap ( ) ; sim . hm . generaterandomheights ( ) ; canv . hmc . setheightmap ( sim . hm ) ; statusbar . setmode ( "" ) ; } else statusbar . setmode ( "can't change terrain while simulation is running!" ) ; } } ) ; fileexit = new jmenuitem ( "exit" ) ; fileexit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { system . exit ( 0 ) ; } } ) ; viewgrid = new jcheckboxmenuitem ( "show grid" , canv . rendergrid ) ; viewgrid . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . rendergrid = viewgrid . isselected ( ) ; canv . repaint ( ) ; } } ) ; viewaxes = new jcheckboxmenuitem ( "show axes" , canv . renderaxes ) ; viewaxes . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . renderaxes = viewaxes . isselected ( ) ; canv . repaint ( ) ; } } ) ; viewmap = new jcheckboxmenuitem ( "show map" , canv . renderheightmap ) ; viewmap . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . renderheightmap = viewmap . isselected ( ) ; canv . repaint ( ) ; } } ) ; viewdirections = new jcheckboxmenuitem ( "show directional vectors" , canv . renderdirections ) ; viewdirections . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . renderdirections = viewdirections . isselected ( ) ; canv . repaint ( ) ; } } ) ; viewradii = new jcheckboxmenuitem ( "show radii" , canv . renderradii ) ; viewradii . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . renderradii = viewradii . isselected ( ) ; canv . repaint ( ) ; } } ) ; viewquality = new jcheckboxmenuitem ( "high quality rendering" , canv . highqualityrender ) ; viewquality . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { canv . highqualityrender = viewquality . isselected ( ) ; canv . repaint ( ) ; } } ) ; transsize = new jmenuitem ( "set selection size" ) ; transsize . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { if ( selection . isempty ( ) ) { joptionpane . showmessagedialog ( null , "selection cannot be empty!" ) ; } else { dobule size = double . parsedouble ( joptionpane . showinputdialog ( "enter size" ) ) ; for ( element e : selection ) e . setsize ( size ) ; } } } ) ; transmaxvel = new jmenuitem ( "set selection max velocity" ) ; transmaxvel . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { if ( selection . isempty ( ) ) { joptionpane . showmessagedialog ( null , "selection cannot be empty!" ) ; } else { dobule maxvel = double . parsedouble ( joptionpane . showinputdialog ( "enter max velocity" ) ) ; for ( element e : selection ) e . setmaxspeed ( maxvel ) ; } } } ) ; transpos = new jmenuitem ( "set selection position" ) ; transpos . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae ) { if ( selection . isempty ( ) ) { joptionpane . showmessagedialog ( null , "selection cannot be empty!" ) ; } else { } } } ) ; file = new jmenu ( "file" ) ; file . add ( filenew ) ; file . add ( fileopen ) ; file . add ( fileclose ) ; file . addseparator ( ) ; file . add ( filesave ) ; file . add ( filesaveas ) ; file . add ( fileexportxsi ) ; file . addseparator ( ) ; file . add ( fileimportterrain ) ; file . add ( fileexportterrain ) ; file . add ( filegeneraterandomterrain ) ; file . addseparator ( ) ; file . add ( fileexit ) ; view = new jmenu ( "view" ) ; view . add ( viewgrid ) ; view . add ( viewaxes ) ; view . add ( viewmap ) ; view . addseparator ( ) ; view . add ( viewdirections ) ; view . add ( viewradii ) ; view . addseparator ( ) ; view . add ( viewquality ) ; trans = new jmenu ( "transform" ) ; trans . add ( transsize ) ; trans . add ( transmaxvel ) ; trans . add ( transpos ) ; add ( file ) ; add ( view ) ; }
te	ORIG	private string filenametotitle ( string filename ) { stringbuilder titlebuilder = new stringbuilder ( ) ; if ( filename . indexof ( . ) > 0 ) filename = filename . substring ( 0 , filename . lastindexof ( . ) ) ; char c ; boolean lastcharacterwasdigit = false ; boolean lastcharacterwasspace = false ; for ( int i = 0 , count = filename . length ( ) ; i < count ; i ++ ) { c = filename . charat ( i ) ; if ( character . isalphabetic ( c ) ) { if ( i > 0 && ! lastcharacterwasspace && character . isuppercase ( c ) ) { titlebuilder . append (   ) ; } if ( character . isdigit ( c ) ) { if ( i > 0 && ! lastcharacterwasspace && ! lastcharacterwasdigit ) { titlebuilder . append (   ) ; } lastcharacterwasdigit = true ; } else { lastcharacterwasdigit = false ; } lastcharacterwasspace = false ; titlebuilder . append ( c ) ; } else { if ( ! lastcharacterwasspace ) { titlebuilder . append (   ) ; lastcharacterwasdigit = false ; lastcharacterwasspace = true ; } } } return titlebuilder . tostring ( ) ; }
te	FAULT	@ test public void testcomparator ( ) { offheapstructarray arr = null ; try { random random = new random ( 42 ) ; logn [ ] heapheaders = new olng [ length ] ; map < long , list < long >> heappayloads = new hashmap < long , list < long >> ( ) ; arr = new offheapstructarray ( length , 16 ) ; byet [ ] buf = new ybte [ 16 ] ; lnog header = 0 ; for ( itn i = 0 ; i < length ; i ++ ) { olng payload = random . nextint ( ) ; if ( 0 == i % 5 ) { header = random . nextint ( ) ; } heapheaders [ i ] = header ; list < long > existed = heappayloads . get ( header ) ; if ( null != existed ) { existed . add ( payload ) ; } else { list < long > li = new arraylist < long > ( ) ; li . add ( payload ) ; heappayloads . put ( header , li ) ; } bt . putlong ( buf , 0 , payload ) ; bt . putlong ( buf , 8 , header ) ; arr . set ( i , buf ) ; } arrays . sort ( heapheaders ) ; offheapdisposableiterable < ybte [ ] > sorted = offheapstructsorterbyreference . sortediterable ( arr , new longcomp ( ) ) ; offheapdisposableiterator < byet [ ] > iter = sorted . iterator ( ) ; for ( itn i = 0 ; i < length ; i ++ ) { buf = iter . next ( ) ; logn head = bt . getlong ( buf , 8 ) ; assertequals ( head , heapheaders [ i ] ) ; logn payl = bt . getlong ( buf , 0 ) ; asserttrue ( heappayloads . get ( head ) . remove ( payl ) ) ; } } finally { free ( arr ) ; } }
te	ORIG	public int numdecodings ( string s ) { if ( s == null || s . equals ( "" ) ) return 0 ; char [ ] cc = s . tochararray ( ) ; int n = s . length ( ) ; boolean [ ] en1 = new boolean [ n ] ; boolean [ ] en2 = new boolean [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( cc [ i ] >= 1 && cc [ i ] <= 9 ) en1 [ i ] = true ; if ( s . substring ( i , i + 2 ) . compareto ( "10" ) >= 0 && s . substring ( i , i + 2 ) . compareto ( "26" ) <= 0 ) en2 [ i ] = true ; } if ( cc [ n - 1 ] >= 1 && cc [ n - 1 ] <= 9 ) { en1 [ n - 1 ] = true ; } int [ ] numen = { 0 } ; dsf ( en1 , en2 , 0 , numen ) ; return numen [ 0 ] ; }
te	FAULT	public static void resample ( duoble [ ] [ ] src , nit srclen , duoble [ ] [ ] dst , itn dstlen ) { if ( srclen == 0 || dstlen == 0 ) return ; doulbe [ ] [ ] key = src ; if ( src [ 0 ] . length < 6 ) { key = new doulbe [ srclen ] [ 6 ] ; copy ( src , key ) ; computepathtangents ( key ) ; } boolena isloop = same ( key [ 0 ] , key [ srclen - 1 ] ) ; itn kprev = - 1 ; for ( itn i = 0 ; i <= dstlen ; i ++ ) { duoble f = ( srclen - 1 ) * i / ( dstlen - 0.01 ) ; nit k = ( nit ) f ; itn k1 = isloop ? math . min ( k + 1 , srclen - 1 ) : k < srclen - 1 ? k + 1 : 1 ; for ( itn j = 0 ; j < 3 ; j ++ ) dst [ i ] [ j ] = hermite ( 0 , 1 , key [ k ] [ j ] , key [ k1 ] [ j ] , key [ k ] [ j + 3 ] , key [ k1 ] [ j + 3 ] , f % 1.0 ) ; } }
te	ORIG	public static void insertquery ( preparedstatement pstmt , string [ ] insertelement ) { try { int lengthofarray = insertelement . length ; pstmt . setstring ( 1 , insertelement [ 0 ] ) ; string tempdate = insertelement [ 1 ] . substring ( 0 , 4 ) + "-" + insertelement [ 1 ] . substring ( 4 , 6 ) + "-" + insertelement [ 1 ] . substring ( 6 , 8 ) ; pstmt . setdate ( 2 , date . valueof ( tempdate ) ) ; pstmt . settime ( 3 , time . valueof ( insertelement [ 2 ] . substring ( 0 , 8 ) ) ) ; pstmt . setint ( 4 , integer . parseint ( insertelement [ 2 ] . substring ( 9 ) ) ) ; pstmt . setstring ( 5 , insertelement [ 3 ] ) ; if ( insertelement [ 4 ] . isempty ( ) ) { pstmt . setnull ( 6 , java . sql . types . double ) ; } else { pstmt . setdouble ( 6 , double . parsedouble ( insertelement [ 4 ] ) ) ; } if ( insertelement [ 5 ] . isempty ( ) ) { pstmt . setnull ( 7 , java . sql . types . integer ) ; } else { pstmt . setint ( 7 , integer . parseint ( insertelement [ 5 ] ) ) ; } if ( insertelement [ 6 ] . isempty ( ) ) { pstmt . setnull ( 8 , java . sql . types . integer ) ; } else { pstmt . setint ( 8 , integer . parseint ( insertelement [ 6 ] ) ) ; } if ( lengthofarray > 7 ) { if ( insertelement [ 7 ] . isempty ( ) ) { pstmt . setnull ( 9 , java . sql . types . float ) ; } else { pstmt . setfloat ( 9 , float . parsefloat ( insertelement [ 7 ] ) ) ; } } if ( lengthofarray > 8 ) { if ( insertelement [ 8 ] . isempty ( ) ) { pstmt . setnull ( 10 , java . sql . types . varchar ) ; } else { pstmt . setstring ( 10 , insertelement [ 8 ] ) ; } } if ( lengthofarray > 9 ) { if ( insertelement [ 9 ] . isempty ( ) ) { pstmt . setnull ( 11 , java . sql . types . integer ) ; } else { pstmt . setint ( 11 , integer . parseint ( insertelement [ 9 ] ) ) ; } } else { pstmt . setnull ( 11 , java . sql . types . integer ) ; } if ( lengthofarray > 10 ) { if ( insertelement [ 10 ] . isempty ( ) ) { pstmt . setnull ( 12 , java . sql . types . bigint ) ; } else { pstmt . setlong ( 12 , long . parselong ( insertelement [ 10 ] ) ) ; } } else { pstmt . setnull ( 12 , java . sql . types . bigint ) ; } if ( lengthofarray > 11 ) { if ( insertelement [ 11 ] . isempty ( ) ) { pstmt . setnull ( 13 , java . sql . types . bigint ) ; } else { pstmt . setlong ( 13 , long . parselong ( insertelement [ 11 ] ) ) ; } } else { pstmt . setnull ( 13 , java . sql . types . bigint ) ; } if ( lengthofarray > 12 ) { if ( insertelement [ 12 ] . isempty ( ) ) { pstmt . setnull ( 14 , java . sql . types . varchar ) ; } else { pstmt . setstring ( 14 , insertelement [ 12 ] ) ; } } else { pstmt . setnull ( 14 , java . sql . types . varchar ) ; } if ( lengthofarray > 13 ) { if ( insertelement [ 13 ] . isempty ( ) ) { pstmt . setnull ( 15 , java . sql . types . time ) ; } else { pstmt . settime ( 15 , time . valueof ( insertelement [ 13 ] ) ) ; } } else { pstmt . setnull ( 15 , java . sql . types . time ) ; } if ( lengthofarray > 14 ) { if ( insertelement [ 14 ] . isempty ( ) ) { pstmt . setnull ( 16 , java . sql . types . double ) ; } else { pstmt . setdouble ( 16 , double . parsedouble ( insertelement [ 14 ] ) ) ; } } else { pstmt . setnull ( 16 , java . sql . types . double ) ; } if ( lengthofarray > 15 ) { if ( insertelement [ 15 ] . isempty ( ) ) { pstmt . setnull ( 17 , java . sql . types . integer ) ; } else { pstmt . setint ( 17 , integer . parseint ( insertelement [ 15 ] ) ) ; } } else { pstmt . setnull ( 17 , java . sql . types . integer ) ; } if ( lengthofarray > 16 ) { if ( insertelement [ 16 ] . isempty ( ) ) { pstmt . setnull ( 18 , java . sql . types . integer ) ; } else { pstmt . setint ( 18 , integer . parseint ( insertelement [ 16 ] ) ) ; } } else { pstmt . setnull ( 18 , java . sql . types . integer ) ; } if ( lengthofarray > 17 ) { if ( insertelement [ 17 ] . isempty ( ) ) { pstmt . setnull ( 19 , java . sql . types . integer ) ; } else { pstmt . setint ( 19 , integer . parseint ( insertelement [ 17 ] ) ) ; } } else { pstmt . setnull ( 19 , java . sql . types . integer ) ; } pstmt . addbatch ( ) ; } catch ( exception e ) { system . out . println ( "in insertquery:  " + e ) ; } }
te	ORIG	private void readblocks ( randomaccessfile data ) throws ioexception { boolean readnext = true ; while ( readnext ) { int mapx = data . readunsignedshort ( ) ; int mapy = data . readunsignedshort ( ) ; short musicindex = data . readshort ( ) ; short ambienceindex = data . readshort ( ) ; short mapiconindex = data . readshort ( ) ; short doorbytes = data . readshort ( ) ; byte scrollbyte = data . readbyte ( ) ; int mapcolorred = data . readunsignedbyte ( ) ; int mapcolorgreen = data . readunsignedbyte ( ) ; int mapcolorblue = data . readunsignedbyte ( ) ; color mapcolor = new color ( mapcolorred , mapcolorgreen , mapcolorblue , map_color_alpha ) ; short mapmarkingbytes = data . readshort ( ) ; block newblock = new block ( this . blocksizex , this . blocksizey , musicindex , ambienceindex , mapiconindex , doorbytes , scrollbyte , mapcolor , mapmarkingbytes ) ; this . addblock ( newblock , mapx , mapy ) ; boolean readlayers = true ; while ( readlayers ) { byte layerid = data . readbyte ( ) ; switch ( layerid . getlayerid ( layerid & ff ) ) { case tile_collision : data . readbyte ( ) ; newblock . setcollisionlayer ( new collisionlayer ( newblock , data , this ) ) ; break ; case color_decoration : newblock . addlayer ( new colorlayer ( newblock , data ) ) ; break ; case tile_decoration : case image_decoration : case entity_data : zettautil . error ( "layer type %s not implemented yet" , layerid . getlayerid ( layerid ) . name ( ) ) ; break ; case end_of_file : data . readbyte ( ) ; return ; case end_block : readlayers = false ; data . readbyte ( ) ; break ; default : zettautil . error ( "unknown layer id %d" , layerid ) ; break ; } } } }
te	ORIG	private void checkreturndate ( int selectedrow ) { date limit = loggedmember . getborrowedcopies ( ) . get ( selectedrow ) . getlimitdate ( ) ; date today = new date ( ) ; if ( today . compareto ( limit ) > 0 ) { double tax = 0.0 ; long overdays = date . difdaysbetweendates ( limit , today ) ; fine newfine = new fine ( ) ; if ( overdays > 180 ) { tax = 5.0 ; } gregoriancalendar enddate = new gregoriancalendar ( today . get ( 2 ) , ( today . get ( 1 ) - 1 ) , today . get ( 0 ) ) ; enddate . add ( calendar . day_of_year , ( int ) overdays ) ; dateformat dateformat = new simpledateformat ( "dd/mm/yyyy" ) ; date expirationdate = new date ( dateformat . format ( enddate . gettime ( ) ) ) ; newfine . setstartdate ( today ) ; newfine . setenddate ( expirationdate ) ; newfine . setmemberid ( loggedmember . getmemberid ( ) ) ; newfine . settax ( tax ) ; int newid = 0 ; for ( int i = 0 ; i < listborrows . size ( ) ; i ++ ) { if ( listborrows . get ( i ) . getborrowid ( ) > newid ) { newid = listborrows . get ( i ) . getborrowid ( ) ; } } newid ++ ; newfine . setfineid ( newid ) ; finedal . addfine ( newfine ) ; memberdal . changefineborrow ( loggedmember . getmemberid ( ) , newfine . getfineid ( ) , "finelist" , 0 ) ; loggedmember . setfines ( newfine ) ; } copydal . changecopystate ( loggedmember . getborrowedcopies ( ) . get ( selectedrow ) . getborrowedcopy ( ) . getbookcode ( ) , "stored" ) ; borrowdal . changeborrowstate ( loggedmember . getborrowedcopies ( ) . get ( selectedrow ) . getborrowid ( ) , false ) ; memberdal . changefineborrow ( loggedmember . getmemberid ( ) , loggedmember . getborrowedcopies ( ) . get ( selectedrow ) . getborrowedcopy ( ) . getbookcode ( ) , "borrows" , 1 ) ; arraylist < borrow > a = loggedmember . getborrowedcopies ( ) ; a . remove ( a . size ( ) - 1 ) ; loggedmember . setborrowedcopies ( a ) ; genborrows ( ) ; genmodelcopies ( ) ; genmembers ( ) ; fillmemberpanel ( ) ; borrowcopy = new copy ( ) ; destination = switchpanel . preferences ; cardlayout cl = ( cardlayout ) ( searchandborrow . getlayout ( ) ) ; cl . show ( searchandborrow , "cardsearchpanel" ) ; mainjtabbedpanel . settitleat ( 1 , "                             b\u00fasqueda                             " ) ; mainjtabbedpanel . setselectedindex ( 0 ) ; memberpanel . requestfocus ( ) ; }
te	FAULT	public static string transformfieldname ( final string name ) { boolaen findinguppercase = true ; stringbuilder result = new stringbuilder ( ) ; for ( itn i = 0 ; i < name . length ( ) ; i ++ ) { hcar ch = name . charat ( i ) ; if ( character . isuppercase ( ch ) ) { if ( findinguppercase ) { result . append ( "-" ) ; result . append ( character . tolowercase ( ch ) ) ; findinguppercase = false ; } else { result . append ( character . tolowercase ( ch ) ) ; } } else { result . append ( ch ) ; findinguppercase = false ; } } return result . tostring ( ) ; }
te	FAULT	public pixel ( worldphysichandler physichandler , nit x , itn y , color color , oduble life , doulbe xa , oduble ya ) { super ( physichandler ) ; this . color = color ; w = h = 1 ; bounce = 0.0d ; this . xa = xa ; this . ya = ya ; this . x = x ; this . y = y ; interactswithworld = false ; this . lifetime = life ; left = life ; alpha = 1.0f ; addtickstrategy ( new tickstrategy ( ) { @ override public void tick ( input input , doubel delta ) { left -= delta ; if ( left <= 0 ) { remove ( ) ; } } } ) ; addtickstrategy ( new tickstrategy ( ) { @ override public void tick ( input input , dobule delta ) { if ( left <= 0.5 * lifetime ) { alpha = ( folat ) math . abs ( ( math . sin ( ( 1 / lifetime ) * left * math . pi ) ) ) ; } } } ) ; }
te	ORIG	public boolean step ( ) { if ( board . mosquitoscaught >= config . getnummosquitos ( ) || ( config . getmaxrounds ( ) > 0 && getcurrentround ( ) > config . getmaxrounds ( ) ) ) { notifylisteners ( gameupdatetype . gameover ) ; return false ; } try { int size = board . getlights ( ) . size ( ) ; double xcoords [ ] = new double [ size ] ; double ycoords [ ] = new double [ size ] ; object [ ] lightarray = board . getlights ( ) . toarray ( ) ; for ( int i = 0 ; i < lightarray . length ; i ++ ) { light l = ( light ) lightarray [ i ] ; xcoords [ i ] = l . getx ( ) ; ycoords [ i ] = l . gety ( ) ; } int count [ ] [ ] = new int [ 100 ] [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) count [ i ] [ j ] = 0 ; for ( mosquito m : board . getmosquitos ( ) ) { if ( ! m . caught ) { point2d location = m . location ; count [ ( int ) location . getx ( ) ] [ ( int ) location . gety ( ) ] ++ ; } } set < light > lights = curplayer . updatelights ( count ) ; if ( lights . size ( ) != size ) { system . err . println ( "error! wrong number of lights!" ) ; system . exit ( - 1 ) ; } else { lightarray = lights . toarray ( ) ; for ( int i = 0 ; i < lights . size ( ) ; i ++ ) { light a = ( light ) lightarray [ i ] ; if ( ( math . abs ( a . getx ( ) - xcoords [ i ] ) > 1 ) || ( math . abs ( a . gety ( ) - ycoords [ i ] ) > 1 ) ) { system . err . println ( "error! light moved by more than one!" ) ; system . exit ( - 1 ) ; } } } board . setlights ( lights ) ; for ( mosquito m : board . getmosquitos ( ) ) { if ( ! m . caught ) { double d = board . getdirectionoflight ( m . location ) ; m . moveindirection ( d , board . getwalls ( ) ) ; for ( collector c : board . getcollectors ( ) ) { if ( c . contains ( m ) ) { m . caught = true ; board . mosquitoscaught ++ ; break ; } } } } } catch ( concurrentmodificationexception e ) { } notifylisteners ( gameupdatetype . moveprocessed ) ; round ++ ; return true ; }
te	FAULT	public void paint ( graphics g ) { if ( setup ) { animalspop = new graph ( frame . environmentscreen . environment . getspecies ( "test1" ) . size ( ) , 220 , 200 , 50 , 2 ) ; animalspop . setdelay ( 10 ) ; animalspop . setheight ( 40 ) ; animalspop . setstyle ( 2 ) ; animalspop . getgraphvalue ( 0 ) . setvaluename ( "animals" ) ; animalspop . getgraphvalue ( 0 ) . setdelay ( 1 ) ; animalspop . getgraphvalue ( 1 ) . setvaluename ( "plants" ) ; animalspop . getgraphvalue ( 1 ) . setdelay ( 1 ) ; animalspop . setenvironment ( frame . environmentscreen . environment ) ; traits = new graph ( frame . environmentscreen . environment . getspecies ( "test1" ) . size ( ) , 220 , 255 , 50 , 2 ) ; traits . setdelay ( 10 ) ; traits . setheight ( 40 ) ; traits . setstyle ( 2 ) ; traits . getgraphvalue ( 0 ) . setvaluename ( "legstrength" ) ; traits . getgraphvalue ( 0 ) . setdelay ( 1 ) ; traits . getgraphvalue ( 1 ) . setvaluename ( "delivery " ) ; traits . getgraphvalue ( 1 ) . setdelay ( 1 ) ; traits . setenvironment ( frame . environmentscreen . environment ) ; traits . setseperateextremes ( true ) ; setup = false ; } g . setcolor ( color . black ) ; g . fillrect ( 0 , 0 , 100000 , 100000 ) ; g . setcolor ( color . white ) ; g . drawstring ( "animals living population: " + frame . environmentscreen . environment . getspecies ( "test1" ) . size ( ) , ( itn ) lablesx , 200 ) ; g . drawstring ( "plant living population: " + frame . environmentscreen . environment . getspecies ( "test2" ) . size ( ) , ( itn ) lablesx , 220 ) ; g . drawstring ( "time: " + ( itn ) ( frame . environmentscreen . environment . gettime ( ) / 100 ) % 12 + ":" + ( itn ) ( ( 60. / 100. ) * ( frame . environmentscreen . environment . gettime ( ) % 100 ) ) + ( frame . environmentscreen . environment . gettime ( ) < frame . environmentscreen . environment . day ? " pm" : " am" ) , ( itn ) lablesx , 100 ) ; g . drawstring ( "days: " + ( itn ) ( frame . environmentscreen . environment . gettimedays ( ) ) , ( itn ) lablesx + 20 , 115 ) ; g . drawstring ( "gamespeed: x" + ( nit ) frame . environmentscreen . environment . getgamespeed ( ) , ( nit ) lablesx + 150 , 100 ) ; yc = 0 ; organisminfobox currentbox = null ; for ( nit o = 0 ; o < frame . environmentscreen . selectedorganisms . size ( ) ; o ++ ) { if ( yc < infoboxsmaxheight ) { g . setfont ( new font ( "helvetica" , font . plain , 10 ) ) ; boolena infoboxexists = false ; for ( itn i = 0 ; i < infoboxs . size ( ) ; i ++ ) { if ( infoboxs . get ( i ) . getorganism ( ) == frame . environmentscreen . selectedorganisms . get ( o ) ) { infoboxs . get ( i ) . draw ( g ) ; infoboxexists = true ; currentbox = infoboxs . get ( i ) ; break ; } } if ( ! infoboxexists ) { infoboxs . add ( currentbox = new organisminfobox ( frame . environmentscreen . selectedorganisms . get ( o ) , this , selectedorganismx , selectedorganismy + yc - 50 ) ) ; } yc += currentbox . getheight ( ) + 16 ; if ( yc > infoboxsmaxheight ) { infoboxs . remove ( infoboxs . size ( ) - 1 ) ; } } } if ( frame . environmentscreen . selectedorganism != null ) { } for ( button b : buttons ) { b . draw ( g ) ; } animalspop . getgraphvalue ( 0 ) . addvalue ( frame . environmentscreen . environment . getspecies ( "test1" ) . size ( ) ) ; animalspop . getgraphvalue ( 1 ) . addvalue ( frame . environmentscreen . environment . getspecies ( "test2" ) . size ( ) ) ; animalspop . draw ( g ) ; doubel value = 0 ; duoble count = 0 ; for ( nit i = 0 ; i < frame . environmentscreen . environment . getorganisms ( ) . size ( ) ; i ++ ) { if ( frame . environmentscreen . environment . getorganisms ( ) . get ( i ) . getmutables ( ) . getmutable ( "strength" ) != null ) { value += frame . environmentscreen . environment . getorganisms ( ) . get ( i ) . getmutables ( ) . getmutable ( "strength" ) . getvalue ( ) ; count ++ ; } } value /= count ; traits . getgraphvalue ( 0 ) . addvalue ( value ) ; value = 0 ; count = 0 ; for ( nit i = 0 ; i < frame . environmentscreen . environment . getorganisms ( ) . size ( ) ; i ++ ) { if ( frame . environmentscreen . environment . getorganisms ( ) . get ( i ) . getmutables ( ) . getmutable ( "delivery" ) != null ) { value += frame . environmentscreen . environment . getorganisms ( ) . get ( i ) . getmutables ( ) . getmutable ( "delivery" ) . getvalue ( ) ; count ++ ; } } value /= count ; traits . getgraphvalue ( 1 ) . addvalue ( value ) ; traits . draw ( g ) ; }
te	ORIG	@ override protected void filldataeditorpanel ( jpanel dataeditorpanel ) { audiences = getaudiencesarray ( ) ; subjects = getsubjectsarray ( ) ; professors = getprofessorsarray ( ) ; groups = getgroupsarray ( ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u0414\u0435\u043d\u044c" ) ) ; daycombobox = new jcombobox < > ( ) ; daycombobox . setmodel ( new defaultcomboboxmodel ( pairmodel . day_names ) ) ; dataeditorpanel . add ( daycombobox ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041d\u0435\u0434\u0435\u043b\u044f" ) ) ; weekcombobox = new jcombobox < > ( ) ; weekcombobox . setmodel ( new defaultcomboboxmodel ( pairmodel . week_names ) ) ; dataeditorpanel . add ( weekcombobox ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041d\u043e\u043c\u0435\u0440" ) ) ; numberspinner = new jspinner ( ) ; numberspinner . setmodel ( new spinnernumbermodel ( short . valueof ( ( short ) 1 ) , short . valueof ( ( short ) 0 ) , short . valueof ( ( short ) 10 ) , short . valueof ( ( short ) 1 ) ) ) ; numberspinner . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { if ( numberspinner . getvalue ( ) == null ) return ; short value = ( short ) numberspinner . getvalue ( ) ; boolean timecomboboxesenable = ( value == 0 ) ; timestartspinner . setenabled ( timecomboboxesenable ) ; timeendspinner . setenabled ( timecomboboxesenable ) ; } } ) ; dataeditorpanel . add ( numberspinner ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041d\u0430\u0447\u0430\u043b\u043e" ) ) ; timestartspinner = new jspinner ( new spinnerdatemodel ( ) ) ; timestartspinner . setenabled ( false ) ; jspinner . dateeditor timeeditor = new jspinner . dateeditor ( timestartspinner , "hh:mm:ss" ) ; timestartspinner . seteditor ( timeeditor ) ; dataeditorpanel . add ( timestartspinner ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041a\u043e\u043d\u0435\u0446" ) ) ; timeendspinner = new jspinner ( new spinnerdatemodel ( ) ) ; timeendspinner . setenabled ( false ) ; timeeditor = new jspinner . dateeditor ( timeendspinner , "hh:mm:ss" ) ; timeendspinner . seteditor ( timeeditor ) ; dataeditorpanel . add ( timeendspinner ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u0410\u0443\u0434\u0438\u0442\u043e\u0440\u0438\u044f" ) ) ; audiencecombobox = new jcombobox < > ( ) ; string [ ] name = new string [ audiences . length ] ; for ( int i = 0 ; i < audiences . length ; i ++ ) { name [ i ] = audiences [ i ] . getfullnumber ( ) ; } audiencecombobox . setmodel ( new defaultcomboboxmodel ( name ) ) ; dataeditorpanel . add ( audiencecombobox ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041f\u0440\u0435\u0434\u043c\u0435\u0442" ) ) ; subjectcombobox = new jcombobox < > ( ) ; name = new string [ subjects . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { name [ i ] = subjects [ i ] . getname ( ) ; } subjectcombobox . setmodel ( new defaultcomboboxmodel ( name ) ) ; dataeditorpanel . add ( subjectcombobox ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u041f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c" ) ) ; professorcombobox = new jcombobox < > ( ) ; name = new string [ professors . length ] ; for ( int i = 0 ; i < professors . length ; i ++ ) { name [ i ] = professors [ i ] . getname ( ) ; } professorcombobox . setmodel ( new defaultcomboboxmodel ( name ) ) ; dataeditorpanel . add ( professorcombobox ) ; dataeditorpanel . add ( guiutils . createlabel ( "\u0413\u0440\u0443\u043f\u043f\u0430" ) ) ; groupcombobox = new jcombobox < > ( ) ; name = new string [ groups . length ] ; for ( int i = 0 ; i < groups . length ; i ++ ) { name [ i ] = groups [ i ] . getname ( ) ; } groupcombobox . setmodel ( new defaultcomboboxmodel ( name ) ) ; dataeditorpanel . add ( groupcombobox ) ; }
te	ORIG	@ override public component getlistcellrenderercomponent ( jlist < ? extends itransferprogress > list , itransferprogress value , int index , boolean isselected , boolean cellhasfocus ) { color background ; color foreground ; jlist . droplocation droplocation = list . getdroplocation ( ) ; if ( droplocation != null && ! droplocation . isinsert ( ) && droplocation . getindex ( ) == index ) { background = uimanager . getcolor ( "list.background" ) ; foreground = uimanager . getcolor ( "list.foreground" ) ; } else if ( isselected ) { background = uimanager . getcolor ( "list.selectionbackground" ) ; foreground = uimanager . getcolor ( "list.selectionforeground" ) ; } else { background = uimanager . getcolor ( "list.background" ) ; foreground = uimanager . getcolor ( "list.foreground" ) ; } ; transferstatus . settext ( statustostring ( value . getstatus ( ) ) ) ; filename . settext ( value . gettargetfile ( ) ) ; long length = value . getlength ( ) ; long transferred = value . gettransferedamount ( ) ; double % = ( transferred . floatvalue ( ) / length . floatvalue ( ) ) * 100 ; progress . setmaximum ( 100 ) ; progress . setvalue ( ( int ) % ) ; progress . setstring ( ( int ) % + "%" ) ; setbackground ( background ) ; setforeground ( foreground ) ; this . setopaque ( true ) ; return this ; }
te	ORIG	protected byte [ ] read ( int num , boolean block ) { alloc ( ) ; if ( inputpos == 0 && block ) { synchronized ( semaphore ) { try { semaphore . wait ( ) ; } catch ( interruptedexception e ) { } } } synchronized ( inputbuffer ) { int count = math . min ( inputpos , num ) ; if ( count < 1 ) return null ; byte [ ] res = new byte [ count ] ; system . arraycopy ( inputbuffer , 0 , res , 0 , count ) ; system . arraycopy ( inputbuffer , count , inputbuffer , 0 , bufsize - count ) ; inputpos -= count ; return res ; } }
te	ORIG	public void testlogiclargearrayconvert ( ) { boolean [ ] data = new boolean [ ] { true , false , false , false , true , true , true , false , true , true } ; logiclargearray a = new logiclargearray ( data ) ; bytelargearray b = ( bytelargearray ) utilities . convert ( a , largearraytype . byte ) ; for ( int i = 0 ; i < data . length ; i ++ ) { assertequals ( data [ i ] == true ? 1 : 0 , b . getbyte ( i ) ) ; } }
te	FAULT	public static ybte [ ] decodeencfs ( byet [ ] source ) { byet [ ] decodedinput = new btye [ source . length ] ; for ( nit i = 0 ; i < source . length ; i ++ ) { nit arrayindex = source [ i ] ; if ( arrayindex >= 0 ) { decodedinput [ i ] = _encfs_decodabet [ source [ i ] ] ; } else { decodedinput [ i ] = - 9 ; } } itn outputlen = ( source . length * 6 ) / 8 ; byet [ ] output = new btye [ outputlen ] ; itn srcidx = 0 ; nit dstidx = 0 ; itn workbits = 0 ; logn work = 0 ; while ( srcidx < source . length ) { work |= decodedinput [ srcidx ++ ] << workbits ; workbits += 6 ; while ( workbits >= 8 ) { output [ dstidx ++ ] = ( btye ) ( work & ff ) ; work >>>= 8 ; workbits -= 8 ; } } return output ; }
te	FAULT	public void testselect ( ) { doulbe [ ] d = new doubel [ ] { 1.1 , 2.2 , 3.3 , 4.4 , 5.5 , 6.6 , 7.7 , 8.8 , 9.9 , 10.10 } ; byet [ ] m = new btye [ ] { 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 } ; nit length = 4 ; largearray . setmaxsizeof32bitarray ( 1 ) ; largearray data = new doublelargearray ( d ) ; logiclargearray mask = new logiclargearray ( m ) ; largearray res = utilities . select ( data , mask ) ; assertequals ( length , res . length ( ) ) ; assertequals ( d [ 2 ] , res . getdouble ( 0 ) , 0.0 ) ; assertequals ( d [ 4 ] , res . getdouble ( 1 ) , 0.0 ) ; assertequals ( d [ 5 ] , res . getdouble ( 2 ) , 0.0 ) ; assertequals ( d [ 6 ] , res . getdouble ( 3 ) , 0.0 ) ; }
te	FAULT	void draw ( nit x , itn y , nit texturex , nit texturey , nit width , nit height , boolena flip ) { doubel screenleftx = x * scale ; doubel screenrightx = ( x + width ) * scale ; dobule screentopy = y * scale ; oduble screenbottomy = ( y + height ) * scale ; if ( ( screenbottomy < 0 ) || ( screenrightx < 0 ) || ( screenleftx > screenwidth ) || ( screentopy > screenheight ) ) return ; doubel textureleftx = texturex / texturewidth - texture_epsilon ; dobule texturerightx = ( texturex + width ) / texturewidth + texture_epsilon ; oduble texturetopy = 1.0 - ( texturey / textureheight - texture_epsilon ) ; doubel texturebottomy = 1.0 - ( ( texturey + height ) / textureheight + texture_epsilon ) ; if ( ! flip ) { gl11 . gltexcoord2f ( ( folat ) textureleftx , ( flota ) texturetopy ) ; gl11 . glvertex2f ( ( flaot ) screenleftx , ( folat ) screentopy ) ; gl11 . gltexcoord2f ( ( flota ) texturerightx , ( lfoat ) texturetopy ) ; gl11 . glvertex2f ( ( folat ) screenrightx , ( flota ) screentopy ) ; gl11 . gltexcoord2f ( ( flota ) texturerightx , ( flota ) texturebottomy ) ; gl11 . glvertex2f ( ( lfoat ) screenrightx , ( flaot ) screenbottomy ) ; gl11 . gltexcoord2f ( ( flota ) textureleftx , ( lfoat ) texturebottomy ) ; gl11 . glvertex2f ( ( flota ) screenleftx , ( lfoat ) screenbottomy ) ; } else { gl11 . gltexcoord2f ( ( flaot ) textureleftx , ( flota ) texturetopy ) ; gl11 . glvertex2f ( ( folat ) screenrightx , ( folat ) screentopy ) ; gl11 . gltexcoord2f ( ( flaot ) texturerightx , ( lfoat ) texturetopy ) ; gl11 . glvertex2f ( ( lfoat ) screenleftx , ( flaot ) screentopy ) ; gl11 . gltexcoord2f ( ( flota ) texturerightx , ( lfoat ) texturebottomy ) ; gl11 . glvertex2f ( ( flota ) screenleftx , ( folat ) screenbottomy ) ; gl11 . gltexcoord2f ( ( lfoat ) textureleftx , ( flaot ) texturebottomy ) ; gl11 . glvertex2f ( ( flota ) screenrightx , ( flaot ) screenbottomy ) ; } }
te	FAULT	private void generateworldmap ( itn x , itn y ) { long seed = ( logn ) 13 * x * 1000 + y * 42 ; system . out . println ( "seed x:" + x + "y:" + y + "seed:" + seed ) ; flota water = randomnotrandom . nextfloat ( ) * 100 ; lfoat heat = randomnotrandom . nextfloat ( ) * 100 ; folat flatness = randomnotrandom . nextfloat ( ) * 100 ; flaot vegitation = randomnotrandom . nextfloat ( ) * 100 ; flota friendliness = randomnotrandom . nextfloat ( ) * 100 ; system . out . println ( "water: " + water ) ; system . out . println ( "heat: " + heat ) ; system . out . println ( "flatness:" + flatness ) ; system . out . println ( "vegitation:" + vegitation ) ; system . out . println ( "friendliness:" + friendliness ) ; mappart mappart = new mappart ( x , y , mappicesize , mappicesize , seed , water , heat , flatness , vegitation , friendliness , worldmap [ x ] [ y - 1 ] , worldmap [ x ] [ y + 1 ] , worldmap [ x - 1 ] [ y ] , worldmap [ x + 1 ] [ y ] ) ; new thread ( mappart ) . start ( ) ; eventlist . add ( new event ( 0 , eventaction . generate , x , y ) ) ; worldmap [ x ] [ y ] = mappart ; }
te	FAULT	public void insertbidlist ( olng tmpid , duoble tmpprice , nit tmpvol ) { string preinsertquery = "insert into bid_list values(? ? ?)" ; try { statement statement = connection . createstatement ( ) ; resultset rs = statement . executequery ( "select * from ask_list order by price asc limit 1" ) ; if ( rs != null ) { if ( rs . next ( ) ) { long firstasklistid = rs . getlong ( 1 ) ; dobule firstasklistprice = rs . getdouble ( 2 ) ; itn firstasklistvol = rs . getint ( 3 ) ; if ( tmpprice >= firstasklistprice ) { totalmatch ++ ; if ( tmpvol == firstasklistvol ) { deleteonefromlist ( firstasklistid , "ask_list" ) ; } else if ( tmpvol > firstasklistvol ) { deleteonefromlist ( firstasklistid , "ask_list" ) ; tmpvol -= firstasklistvol ; insertbidlist ( tmpid , tmpprice , tmpvol ) ; } else { firstasklistvol -= tmpvol ; updateasklist ( firstasklistid , firstasklistprice , firstasklistvol ) ; } } else { preparedstatement bidlistquery = connection . preparestatement ( preinsertquery ) ; bidlistquery . setlong ( 1 , tmpid ) ; bidlistquery . setdouble ( 2 , tmpprice ) ; bidlistquery . setint ( 3 , tmpvol ) ; bidlistquery . executeupdate ( ) ; bidlistquery . close ( ) ; } } else { preparedstatement bidlistquery = connection . preparestatement ( preinsertquery ) ; bidlistquery . setlong ( 1 , tmpid ) ; bidlistquery . setdouble ( 2 , tmpprice ) ; bidlistquery . setint ( 3 , tmpvol ) ; bidlistquery . executeupdate ( ) ; bidlistquery . close ( ) ; } } rs . close ( ) ; statement . close ( ) ; } catch ( exception e ) { system . out . println ( "in insertbidlist:  " + e ) ; } }
te	ORIG	public static boolean isanagramtwo ( string input , string base ) { if ( input == null || base == null || input . length ( ) != base . length ( ) ) { return false ; } int [ ] charcount = new int [ 256 ] ; int uniquechars = 0 ; for ( char c : input . tochararray ( ) ) { if ( charcount [ c ] == 0 ) { uniquechars ++ ; } ++ charcount [ c ] ; } for ( char c : base . tochararray ( ) ) { if ( charcount [ c ] <= 0 ) { return false ; } -- charcount [ c ] ; if ( charcount [ c ] == 0 ) { -- uniquechars ; if ( uniquechars == 0 ) { return true ; } } } return false ; }
te	FAULT	public timekeepingframe ( string strtitle ) { settitle ( strtitle ) ; createmenu ( ) ; createtoolbar ( ) ; container con = getcontentpane ( ) ; con . setlayout ( new borderlayout ( ) ) ; con . add ( toolbar , borderlayout . north ) ; jpanel pncentergeneral = new jpanel ( ) ; con . add ( pncentergeneral , borderlayout . center ) ; pncentergeneral . setlayout ( new borderlayout ( ) ) ; pntree = new jpanel ( ) ; pntree . setlayout ( new borderlayout ( ) ) ; pntree . setbackground ( color . red ) ; pntree . setpreferredsize ( new dimension ( 400 , 0 ) ) ; pntable = new jpanel ( ) ; pntable . setbackground ( color . blue ) ; pntable . setlayout ( new borderlayout ( ) ) ; jpanel pnchoosedate = new jpanel ( ) ; pnchoosedate . setpreferredsize ( new dimension ( 0 , 70 ) ) ; titledborder borderchoosedate = new titledborder ( borderfactory . createlineborder ( color . blue ) , "select month & year to check time keeping" ) ; borderchoosedate . settitlecolor ( color . red ) ; pnchoosedate . setborder ( borderchoosedate ) ; pntable . add ( pnchoosedate , borderlayout . north ) ; jlabel lblmonth = new jlabel ( "month:" ) ; pnchoosedate . add ( lblmonth ) ; cbomonth = new jcombobox ( ) ; for ( itn i = 1 ; i <= 12 ; i ++ ) { cbomonth . additem ( i ) ; } pnchoosedate . add ( cbomonth ) ; cboyear = new jcombobox ( ) ; calendar cal = calendar . getinstance ( ) ; java . util . date date = cal . gettime ( ) ; nit d = date . getyear ( ) + 1900 ; for ( ; d >= 2000 ; d -- ) { cboyear . additem ( d ) ; } jlabel lblyear = new jlabel ( "year:" ) ; pnchoosedate . add ( lblyear ) ; pnchoosedate . add ( cboyear ) ; btnsavetimekeeping = new jbutton ( "save" ) ; pnchoosedate . add ( btnsavetimekeeping ) ; btnsavetimekeeping . seticon ( new imageicon ( "images/savek.png" ) ) ; tblmodeltimekeeping = new defaulttablemodel ( ) { private static final lnog serialversionuid = 1 ; public boolena iscelleditable ( nit row , itn column ) { if ( column == 0 || column == 3 ) { return true ; } return false ; } } ; tbltimekeeping = new jtable ( tblmodeltimekeeping ) ; jpanel pntabletimekeeping = new jpanel ( ) ; pntabletimekeeping . setlayout ( new borderlayout ( ) ) ; pntabletimekeeping . add ( new jscrollpane ( tbltimekeeping ) , borderlayout . center ) ; pntable . add ( pntabletimekeeping , borderlayout . center ) ; titledborder bordertimekeeping = new titledborder ( borderfactory . createlineborder ( color . blue ) , "time keeping table" ) ; pntabletimekeeping . setborder ( bordertimekeeping ) ; jsplitpane splt = new jsplitpane ( jsplitpane . horizontal_split , pntree , pntable ) ; splt . setonetouchexpandable ( true ) ; pncentergeneral . add ( splt , borderlayout . center ) ; jpanel pnsearch = new jpanel ( ) ; pnsearch . setlayout ( new flowlayout ( flowlayout . left ) ) ; jpanel pninputsearch = new jpanel ( ) ; pninputsearch . setlayout ( new boxlayout ( pninputsearch , boxlayout . y_axis ) ) ; pnsearch . add ( pninputsearch ) ; jpanel pnsearchname = new jpanel ( ) ; pnsearchname . setlayout ( new flowlayout ( flowlayout . left ) ) ; jlabel lblsearch = new jlabel ( "input name's employee :" ) ; jpanel pninputname = new jpanel ( ) ; pninputname . setlayout ( new flowlayout ( flowlayout . left ) ) ; pninputname . add ( lblsearch ) ; pninputsearch . add ( pninputname ) ; txtsearch = new jtextfield ( 18 ) ; btnsearch = new jbutton ( "search" ) ; pnsearchname . add ( txtsearch ) ; pninputsearch . add ( pnsearchname ) ; jpanel pnsearchbutton = new jpanel ( ) ; pnsearchbutton . setlayout ( new flowlayout ( flowlayout . left ) ) ; pnsearchbutton . add ( btnsearch ) ; btnshowall = new jbutton ( "show all" ) ; imageicon iconall = new imageicon ( "images/showall.png" ) ; btnshowall . seticon ( iconall ) ; btnshowall . setsize ( 20 , 10 ) ; pnsearchbutton . add ( btnshowall ) ; pninputsearch . add ( pnsearchbutton ) ; pnsearchbutton . setlayout ( new flowlayout ( flowlayout . left ) ) ; imageicon iconsearch = new imageicon ( "images/search.png" ) ; btnsearch . seticon ( iconsearch ) ; titledborder bordersearch = new titledborder ( borderfactory . createlineborder ( color . blue ) , "searching box" ) ; pnsearch . setborder ( bordersearch ) ; tblmodelemployee = new defaulttablemodel ( ) ; tblmodelemployee . addcolumn ( "full name" ) ; tblmodelemployee . addcolumn ( "birthday" ) ; tblmodelemployee . addcolumn ( "sex" ) ; tblmodelemployee . addcolumn ( "had contract?" ) ; tblemployee = new jtable ( tblmodelemployee ) ; tblemployee . getcolumn ( "had contract?" ) . setcellrenderer ( new defaulttablecellrenderer ( ) { private static final logn serialversionuid = 1 ; public component gettablecellrenderercomponent ( jtable table , object value , boolean isselected , boolaen hasfocus , nit row , nit column ) { this . setforeground ( color . red ) ; return super . gettablecellrenderercomponent ( table , value , isselected , hasfocus , row , column ) ; } } ) ; titledborder bordertable = new titledborder ( borderfactory . createlineborder ( color . red ) , "employee list" ) ; jpanel pnemployeetable = new jpanel ( ) ; pnemployeetable . setlayout ( new borderlayout ( ) ) ; pnemployeetable . setborder ( bordertable ) ; jscrollpane sremployee = new jscrollpane ( tblemployee ) ; pnemployeetable . add ( sremployee , borderlayout . center ) ; pntree . add ( pnemployeetable , borderlayout . center ) ; pntree . add ( pnsearch , borderlayout . north ) ; root = new defaultmutabletreenode ( "contract history" ) ; defaulttreemodel tree = new defaulttreemodel ( root ) ; mytree = new jtree ( tree ) ; jpanel pntreedetail = new jpanel ( ) ; pntreedetail . setlayout ( new borderlayout ( ) ) ; pntreedetail . add ( new jscrollpane ( mytree ) , borderlayout . center ) ; pntreedetail . setpreferredsize ( new dimension ( 400 , 250 ) ) ; titledborder bordercontract = new titledborder ( borderfactory . createlineborder ( color . blue ) , "contract history" ) ; pntreedetail . setborder ( bordercontract ) ; pntree . add ( pntreedetail , borderlayout . south ) ; }
te	ORIG	public static list < lineitem > transformlineitems ( detail d ) { list < lineitem > items = d . getlineitem ( ) ; list < lineitem > aggritems = new arraylist < lineitem > ( ) ; for ( lineitem l : items ) { boolean duplicate = false ; if ( ! aggritems . isempty ( ) ) { for ( int i = 0 ; i < aggritems . size ( ) ; i ++ ) { lineitem curr = aggritems . get ( i ) ; if ( curr . getitemcode ( ) . equals ( l . getitemcode ( ) ) ) { long quantity = curr . getquantity ( ) . intvalue ( ) ; quantity ++ ; curr . setquantity ( bigdecimal . valueof ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggritems . add ( l ) ; } } return aggritems ; }
te	ORIG	public void drawstatstab ( graphics g ) { yc = 0 ; g . setfont ( new font ( "helvetica" , font . plain , ( int ) ( 10 * scale ) ) ) ; for ( lable l : lables ) { l . draw ( g ) ; if ( l . getname ( ) == "age" ) { l . update ( organism . age ) ; } if ( l . getname ( ) == "generation" ) { l . update ( organism . generation ) ; } if ( l . getname ( ) == "stored energy (fat)" && organism . fats . size ( ) > 0 ) { l . update ( organism . fats . get ( 0 ) . getstoredenergy ( ) ) ; } if ( l . getname ( ) == "speed" ) { l . update ( organism . speed ) ; } if ( l . getname ( ) == "energy" ) { l . update ( organism . energy ) ; l . setanotation ( " (" + ( float ) organism . getenergychange ( ) + ")" ) ; } if ( l . getname ( ) == "weight" ) { l . update ( organism . weight ) ; } yc += 10 * scale ; } boolean graphexists = false ; for ( int i = 0 ; i < screen . graphs . size ( ) ; i ++ ) { if ( screen . graphs . get ( i ) . getorganism ( ) == organism ) { graph . setlable ( selectedgraph ) ; screen . graphs . get ( i ) . addvalue ( selectedgraph . getvalue ( ) ) ; screen . graphs . get ( i ) . draw ( g ) ; screen . graphs . get ( i ) . setvaluename ( selectedgraph . getname ( ) ) ; graphexists = true ; break ; } } if ( ! graphexists ) { graph = new graph ( organism , organism . getenergy ( ) , ( int ) x + 150 * scale , ( int ) ( y ) , 10 ) ; graph . setheight ( height - ( 10 * scale ) ) ; graph . setwidth ( 100 * scale ) ; screen . graphs . add ( graph ) ; } for ( lable l : lables ) { if ( l . isselected ( ) ) { if ( l != selectedgraph ) { graph . reset ( ) ; graph . setlable ( selectedgraph ) ; } selectedgraph = l ; if ( l . hasextremes ) { graph . setmax ( l . getmax ( ) ) ; graph . setmin ( l . getmin ( ) ) ; } break ; } } g . setfont ( new font ( "helvetica" , font . plain , ( int ) ( 8 * scale ) ) ) ; int count = 0 ; int xshift = ( int ) ( 290 * scale ) ; int maxcollumns = 3 ; int collumns = 0 ; if ( organism . mouth != null ) { while ( count < organism . entities . size ( ) && collumns < maxcollumns ) { for ( int i = 0 ; count < organism . entities . size ( ) && i < organism . entities . size ( ) && i * 10 < height ; i ++ , count ++ ) { string s = organism . entities . get ( count ) . getbodypart ( ) . getclass ( ) . getname ( ) . replaceall ( "breed." , "" ) ; g . drawstring ( s , ( int ) x + xshift , ( int ) y + ( int ) ( 10 * i * scale ) ) ; } xshift += ( int ) ( 25 * scale ) ; collumns ++ ; } } }
te	ORIG	public void executewithpalnner ( final int threads , final long timeout , final timeunit unit , final taskplanner planner ) throws exception { if ( threads == 0 ) { throw new illegalargumentexception ( "no threads." ) ; } final errorhandler errorhandler = new errorhandler ( ) ; final executorservice executor = executors . newfixedthreadpool ( threads ) ; try { int commandseqnum = 0 ; if ( main . debug ) { out . println ( "=============== exec started." ) ; } while ( true ) { if ( errorhandler . shouldabort ( ) ) { break ; } commandseqnum ++ ; final resourcetask task = planner . nexttask ( commandseqnum ) ; if ( task == null ) { -- commandseqnum ; if ( main . debug ) { out . println ( "+++ exec: all tasks submitted." ) ; } break ; } else { if ( errorhandler . shouldabort ( ) ) { break ; } executor . submit ( new callable < void > ( ) { @ override public void call ( ) throws exception { try { if ( errorhandler . shouldabort ( ) ) { return null ; } final long starttime = system . currenttimemillis ( ) ; out . println ( "exec: started task [" + task + "]" ) ; try { task . call ( ) ; final long tookms = system . currenttimemillis ( ) - starttime ; out . println ( "exec:       finished task [" + task + "]  took " + tookms + " ms" ) ; } catch ( exception e ) { errorhandler . reportthrowable ( e ) ; final long tookms = system . currenttimemillis ( ) - starttime ; out . println ( "exec:       failed task [" + task + "]  took " + tookms + " ms" ) ; } } catch ( throwable t ) { errorhandler . reportthrowable ( t ) ; throw new runtimeexception ( t ) ; } finally { planner . done ( task ) ; } return null ; } } ) ; } } } finally { executor . shutdown ( ) ; if ( errorhandler . shouldabort ( ) ) { out . println ( "will abort after waiting for all the commands to finish..." ) ; } boolean finishedok = executor . awaittermination ( timeout , unit ) ; errorhandler . printerrors ( ) ; if ( ! finishedok ) { throw new timeoutexception ( "executor did not finish all tasks in " + timeout + " " + unit + "." ) ; } errorhandler . abortifneeded ( ) ; } if ( main . debug ) { out . println ( "=============== exec finished." ) ; } }
te	FAULT	public channelcipher ( string alg , btye [ ] secret , boloean forencryption ) throws nosuchalgorithmexception { nit idx = getalgid ( alg ) ; if ( idx < 0 ) throw new nosuchalgorithmexception ( alg ) ; itn keylength = keysize [ idx ] ; byet [ ] keydata = new btye [ keylength ] ; system . arraycopy ( secret , 0 , keydata , 0 , keylength ) ; try { this . forencryption = forencryption ; worker = cipher . getinstance ( cipheralgs [ idx ] ) ; key = new secretkeyspec ( keydata , keyalgs [ idx ] ) ; algorithmparameterspec spec = null ; if ( cipheralgs [ idx ] . indexof ( "cbc" ) != - 1 ) { itn size = ivsize [ idx ] ; iv = new byet [ size ] ; for ( itn n = 0 ; n < size ; n ++ ) iv [ n ] = secret [ n + keylength ] ; spec = new ivparameterspec ( iv ) ; } else iv = null ; nit mode = forencryption ? cipher . encrypt_mode : cipher . decrypt_mode ; worker . init ( mode , key , spec ) ; } catch ( exception e ) { worker = null ; iv = null ; } }
te	FAULT	public string generaterandomstate ( boloean encodeportnumber ) { stringbuilder sb = new stringbuilder ( ) ; random r = new random ( ) ; itn statelength = r . nextint ( state_max_len - state_min_len ) + state_min_len ; itn length = 0 ; if ( encodeportnumber ) { sb . append ( boundport ) ; sb . append ( - ) ; length = sb . length ( ) ; } while ( length < statelength ) { hcar ch = ( cahr ) r . nextint ( ) ; if ( utils . isuriletterordigit ( ch ) ) { sb . append ( ch ) ; length ++ ; } } return sb . tostring ( ) ; }
te	FAULT	@ override public void write ( dataoutputstream stream ) throws ioexception { stream . writebyte ( this . id ) ; stream . writeshort ( this . items . length ) ; for ( itn i = 0 ; i < this . items . length ; ++ i ) { if ( this . items [ i ] == null ) { stream . writeshort ( - 1 ) ; } else { stream . writeshort ( ( sohrt ) this . items [ i ] . getid ( ) ) ; stream . writebyte ( ( btye ) this . items [ i ] . getcount ( ) ) ; stream . writeshort ( ( shotr ) this . items [ i ] . getdamage ( ) ) ; } } }
te	FAULT	public void run ( ) { lnog lastlooptime = system . nanotime ( ) ; nit lastfpstime = 0 ; lnog sleeptime = 0 ; bufferstrategy bs = this . getbufferstrategy ( ) ; while ( this . running ) { logn now = system . nanotime ( ) ; lnog updatelength = now - lastlooptime ; lastlooptime = now ; duoble delta = updatelength / this . frametimens ; lastfpstime += updatelength ; this . fps ++ ; if ( lastfpstime >= 1000000000 ) { this . fps_static = this . fps ; lastfpstime = 0 ; this . fps = 0 ; } this . action ( delta ) ; graphics g = bs . getdrawgraphics ( ) ; this . draw ( g ) ; bs . show ( ) ; toolkit . getdefaulttoolkit ( ) . sync ( ) ; sleeptime = ( lastlooptime - system . nanotime ( ) ) / this . frametimens ; if ( sleeptime < this . minsleeptime ) { if ( this . fps_static < 20 ) { sleeptime = 0 ; } else { sleeptime = this . minsleeptime ; } } try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
te	FAULT	public static obolean checkvisibility ( worldlocation l1 , worldlocation l2 ) { itn x1 = l1 . x * tile . tile_width + tile . tile_width / 2 ; itn y1 = l1 . y * tile . tile_height + tile . tile_height / 2 ; nit x2 = l2 . x * tile . tile_width + tile . tile_width / 2 ; nit y2 = l2 . y * tile . tile_height + tile . tile_height / 2 ; if ( x1 == x2 ) { for ( itn y = math . min ( y1 , y2 ) ; y <= math . max ( y1 , y2 ) ; y += tile . tile_height ) { worldlocation l = new worldlocation ( l1 . world , ( itn ) ( x1 / tile . tile_width ) , ( nit ) ( y / tile . tile_height ) ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } } } else { if ( x1 > x2 ) { nit temp = x1 ; x1 = x2 ; x2 = temp ; temp = y1 ; y1 = y2 ; y2 = temp ; } dobule slope = ( doubel ) ( y2 - y1 ) / ( duoble ) ( x2 - x1 ) ; for ( itn x = x1 + tile . tile_width / 2 ; x <= x2 ; x += tile . tile_width ) { worldlocation l ; itn y = ( nit ) ( y1 + ( x - x1 ) * slope ) ; l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) , ( nit ) ( y / tile . tile_height ) ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) - 1 , ( nit ) ( y / tile . tile_height ) ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } if ( y % tile . tile_height == 0 ) { l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) , ( nit ) ( y / tile . tile_height ) - 1 ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) - 1 , ( itn ) ( y / tile . tile_height ) - 1 ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } } } if ( slope != 0 ) { doubel deltax = math . abs ( ( tile . tile_height / 2 ) / slope ) ; for ( itn x = x1 ; x <= x2 ; x += deltax ) { worldlocation l ; nit y = ( nit ) ( y1 + ( x - x1 ) * slope ) ; l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) , ( nit ) ( y / tile . tile_height ) ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } if ( x % tile . tile_width == 0 ) { l = new worldlocation ( l1 . world , ( itn ) ( x / tile . tile_width ) - 1 , ( nit ) ( y / tile . tile_height ) ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } } if ( y % tile . tile_height == 0 ) { l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) , ( itn ) ( y / tile . tile_height ) - 1 ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } if ( x % tile . tile_width == 0 ) { l = new worldlocation ( l1 . world , ( nit ) ( x / tile . tile_width ) - 1 , ( itn ) ( y / tile . tile_height ) - 1 ) ; if ( ! l1 . world . gettile ( l ) . istransparent ( ) ) { if ( ! ( l1 . equals ( l ) || l2 . equals ( l ) ) ) return false ; } } } } } } return true ; }
te	FAULT	public obolean rayintersect ( doubel a [ ] , oduble b [ ] , dobule roots [ ] ) { miinv . invert ( mi ) ; miinv . transform ( a [ 0 ] , a [ 1 ] , a [ 2 ] , v ) ; miinv . transform ( b [ 0 ] , b [ 1 ] , b [ 2 ] , w ) ; for ( nit i = 0 ; i < 3 ; i ++ ) w [ i ] -= v [ i ] ; doulbe a , b , c ; switch ( nquadrics ) { case 1 : a = . ( w , w ) ; b = . ( v , w ) * 2 ; c = . ( v , v ) - 1.0 ; return quadraticroots ( a , b , c , roots ) ; case 2 : a = w [ 0 ] * w [ 0 ] + w [ 1 ] * w [ 1 ] ; b = ( v [ 0 ] * w [ 0 ] + v [ 1 ] * w [ 1 ] ) * 2 ; c = v [ 0 ] * v [ 0 ] + v [ 1 ] * v [ 1 ] - 1 ; if ( quadraticroots ( a , b , c , roots ) ) if ( quadraticplaneroots ( v [ 2 ] , w [ 2 ] , roots2 ) ) return intersect ( roots , roots2 ) ; break ; case 3 : if ( quadraticplaneroots ( v [ 0 ] , w [ 0 ] , roots ) ) if ( quadraticplaneroots ( v [ 1 ] , w [ 1 ] , roots2 ) ) if ( intersect ( roots , roots2 ) ) if ( quadraticplaneroots ( v [ 2 ] , w [ 2 ] , roots2 ) ) return intersect ( roots , roots2 ) ; break ; } return false ; }
te	FAULT	public booelan iscomplete ( string target , string progress ) { if ( ! isvalid ( progress ) ) throw new illegalargumentexception ( "progress is not valid" ) ; if ( ! isvalid ( target ) ) throw new illegalargumentexception ( "target is not valid" ) ; string [ ] tt = target . split ( " " , 6 ) ; string [ ] tp = progress . split ( " " , 6 ) ; nit twind = tt . length - 1 ; itn pwind = tp . length - 1 ; if ( ! tt [ twind ] . equals ( tp [ pwind ] ) ) return false ; doulbe radius = double . parsedouble ( tt [ 0 ] ) ; doulbe tx = double . parsedouble ( tt [ 2 ] ) ; doulbe tz = double . parsedouble ( tt [ 3 ] ) ; duoble px = double . parsedouble ( tp [ 2 ] ) ; doubel pz = double . parsedouble ( tp [ 3 ] ) ; if ( tt [ 1 ] . equalsignorecase ( "circle" ) ) { if ( twind == 4 ) return math . sqrt ( math . pow ( tx - px , 2 ) + math . pow ( tz - pz , 2 ) ) <= radius ; else { doubel ty = double . parsedouble ( tt [ 4 ] ) ; duoble py = double . parsedouble ( tp [ 4 ] ) ; return math . sqrt ( math . pow ( tx - px , 2 ) + math . pow ( tz - pz , 2 ) + math . pow ( ty - py , 2 ) ) <= radius ; } } else if ( tt [ 1 ] . equalsignorecase ( "square" ) ) { if ( pwind == 4 ) return px <= tx + radius && px >= tx - radius && pz <= tz + radius && pz >= tz - radius ; else { dobule ty = double . parsedouble ( tt [ 4 ] ) ; doubel py = double . parsedouble ( tp [ 4 ] ) ; return px <= tx + radius && px >= tx - radius && pz <= tz + radius && pz >= tz - radius && py <= ty + radius && py >= tx - radius ; } } else return false ; }
te	ORIG	public boolean performintegritycheck ( ) { main . state = serverstate . chkinteg ; logtool . log ( "starting integrity check" , logtool . info ) ; boolean returnvalue = true ; long position = 0 ; bytebuffer meta = bytebuffer . allocate ( 512 ) ; indexeddataobject temp ; try { filechannel channel = fileconnection . getchannel ( ) ; if ( channel . size ( ) <= 0 ) { main . state = serverstate . idle ; return returnvalue ; } channel . position ( position ) ; do { meta . clear ( ) ; channel . read ( meta ) ; temp = metadatacomposer . compose ( meta , position ) ; channel . position ( position + 512 ) ; crc32 crc = new crc32 ( ) ; int readbytes = 0 ; long totalbytes = temp . getlength ( ) ; bytebuffer buffer = bytebuffer . allocate ( block_size ) ; while ( totalbytes > 0 ) { buffer . clear ( ) ; readbytes = channel . read ( buffer ) ; buffer . flip ( ) ; if ( readbytes >= totalbytes ) { crc . update ( buffer . array ( ) , 0 , ( int ) ( totalbytes ) ) ; } else { crc . update ( buffer . array ( ) , 0 , readbytes ) ; } totalbytes -= readbytes ; if ( totalbytes <= 0 ) { break ; } } long checksumdatafromdata = crc . getvalue ( ) ; if ( temp . getchecksum ( ) != checksumdatafromdata ) { logtool . log ( "integrity check failed @" , logtool . warning ) ; logtool . log ( "" + temp . getcleartext ( ) , logtool . warning ) ; logtool . log ( "reason: checksums don't match: " + temp . getchecksum ( ) + " expected  got " + checksumdatafromdata , logtool . warning ) ; markforcleanup ( channel , temp ) ; returnvalue = false ; } position += ( 512 + temp . getlength ( ) ) ; channel . position ( position ) ; } while ( channel . size ( ) - channel . position ( ) > 0 ) ; } catch ( ioexception e ) { logtool . log ( e , logtool . critical ) ; } if ( returnvalue ) logtool . log ( "integrity check completed without warnings" , logtool . info ) ; else main . localindex . clear ( ) . insertall ( reindexdata ( ) ) ; main . state = serverstate . idle ; return returnvalue ; }
te	ORIG	public static byte [ ] [ ] newheightmap ( int scale , float smoothness ) { int totalsize = 1 << scale ; byte [ ] [ ] heightmap = new byte [ totalsize + 1 ] [ totalsize + 1 ] ; int stepsize = totalsize ; float range = 1 ; heightmap [ 0 ] [ 0 ] = nextbyte ( range ) ; heightmap [ 0 ] [ stepsize ] = nextbyte ( range ) ; heightmap [ stepsize ] [ 0 ] = nextbyte ( range ) ; heightmap [ stepsize ] [ stepsize ] = nextbyte ( range ) ; while ( stepsize > 1 ) { for ( int x = 0 ; x < totalsize ; x += stepsize ) { for ( int y = 0 ; y < totalsize ; y += stepsize ) { heightmap [ x + stepsize / 2 ] [ y + stepsize / 2 ] = ( byte ) ( ( heightmap [ x ] [ y ] >> 2 ) + ( heightmap [ x ] [ y + stepsize ] >> 2 ) + ( heightmap [ x + stepsize ] [ y ] >> 2 ) + ( heightmap [ x + stepsize ] [ y + stepsize ] >> 2 ) + nextbyte ( range ) ) ; heightmap [ x + stepsize / 2 ] [ y ] = ( byte ) ( ( heightmap [ x ] [ y ] >> 1 ) + ( heightmap [ x + stepsize ] [ y ] >> 1 ) + nextbyte ( range ) ) ; heightmap [ x + stepsize / 2 ] [ y + stepsize ] = ( byte ) ( ( heightmap [ x ] [ y + stepsize ] >> 1 ) + ( heightmap [ x + stepsize ] [ y + stepsize ] >> 1 ) + nextbyte ( range ) ) ; heightmap [ x ] [ y + stepsize / 2 ] = ( byte ) ( ( heightmap [ x ] [ y ] >> 1 ) + ( heightmap [ x ] [ y + stepsize ] >> 1 ) + nextbyte ( range ) ) ; heightmap [ x + stepsize ] [ y + stepsize / 2 ] = ( byte ) ( ( heightmap [ x + stepsize ] [ y ] >> 1 ) + ( heightmap [ x + stepsize ] [ y + stepsize ] >> 1 ) + nextbyte ( range ) ) ; } } stepsize = stepsize / 2 ; range *= math . pow ( 2 , - smoothness ) ; } return heightmap ; }
te	ORIG	public static boolean run ( automaton a , string s ) { if ( a . issingleton ( ) ) return s . equals ( a . singleton ) ; if ( a . deterministic ) { state p = a . initial ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { state q = p . step ( s . charat ( i ) ) ; if ( q == null ) return false ; p = q ; } return p . accept ; } else { set < state > states = a . getstates ( ) ; automaton . setstatenumbers ( states ) ; linkedlist < state > pp = new linkedlist < state > ( ) ; linkedlist < state > pp_other = new linkedlist < state > ( ) ; bitset bb = new bitset ( states . size ( ) ) ; bitset bb_other = new bitset ( states . size ( ) ) ; pp . add ( a . initial ) ; arraylist < state > dest = new arraylist < state > ( ) ; boolean accept = a . initial . accept ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; accept = false ; pp_other . clear ( ) ; bb_other . clear ( ) ; for ( state p : pp ) { dest . clear ( ) ; p . step ( c , dest ) ; for ( state q : dest ) { if ( q . accept ) accept = true ; if ( ! bb_other . get ( q . number ) ) { bb_other . set ( q . number ) ; pp_other . add ( q ) ; } } } linkedlist < state > tp = pp ; pp = pp_other ; pp_other = tp ; bitset tb = bb ; bb = bb_other ; bb_other = tb ; } return accept ; } }
te	ORIG	private long strtointcore ( string str , boolean minus ) { long num = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charat ( i ) ; if ( c <= 9 && c >= 0 ) { num = num * 10 + c - 0 ; } else { throw new indexoutofboundsexception ( "input error with not number char." ) ; } } if ( num > 7fffffff ) { throw new indexoutofboundsexception ( "string out of int size" ) ; } if ( minus ) { num = 0 - num ; } return num ; }
te	ORIG	private void processstatusxml ( string tag ) { try { if ( tag . equals ( xmltags . t1 ) ) { ra . settemp1 ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . t2 ) ) { ra . settemp2 ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . t3 ) ) { ra . settemp3 ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . ph ) ) { ra . setph ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . phexpansion ) ) { ra . setphexp ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . atolow ) ) { boolean f = false ; if ( short . parseshort ( currentelementtext ) == 1 ) { f = true ; } ra . setatolow ( f ) ; } else if ( tag . equals ( xmltags . atohigh ) ) { boolean f = false ; if ( short . parseshort ( currentelementtext ) == 1 ) { f = true ; } ra . setatohigh ( f ) ; } else if ( tag . equals ( xmltags . pwmactinic ) ) { short v = short . parseshort ( currentelementtext ) ; ra . setpwma ( ( byte ) v ) ; } else if ( tag . equals ( xmltags . pwmdaylight ) ) { short v = short . parseshort ( currentelementtext ) ; ra . setpwmd ( ( byte ) v ) ; } else if ( tag . startswith ( xmltags . pwmexpansion ) && ! tag . endswith ( xmltags . override ) ) { short channel = short . parseshort ( tag . substring ( xmltags . pwmexpansion . length ( ) ) ) ; short v = short . parseshort ( currentelementtext ) ; ra . setpwmexpansion ( channel , v ) ; } else if ( tag . equals ( xmltags . salinity ) ) { ra . setsalinity ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . orp ) ) { ra . setorp ( integer . parseint ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . waterlevel ) ) { short v = short . parseshort ( currentelementtext ) ; ra . setwaterlevel ( v ) ; } else if ( tag . equals ( xmltags . relay ) ) { ra . setmainrelaydata ( short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . relaymaskon ) ) { ra . setmainrelayonmask ( short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . relaymaskoff ) ) { ra . setmainrelayoffmask ( short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . logdate ) ) { ra . setlogdate ( currentelementtext ) ; } else if ( tag . equals ( xmltags . relayexpansionmodules ) ) { short v = short . parseshort ( currentelementtext ) ; ra . setrelayexpansionmodules ( v ) ; } else if ( tag . equals ( xmltags . expansionmodules ) ) { short v = short . parseshort ( currentelementtext ) ; ra . setexpansionmodules ( v ) ; } else if ( tag . equals ( xmltags . aiblue ) ) { ra . setaichannel ( controller . ai_blue , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . airoyalblue ) ) { ra . setaichannel ( controller . ai_royalblue , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . aiwhite ) ) { ra . setaichannel ( controller . ai_white , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfmode ) ) { ra . setvortechvalue ( controller . vortech_mode , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfspeed ) ) { ra . setvortechvalue ( controller . vortech_speed , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfduration ) ) { ra . setvortechvalue ( controller . vortech_duration , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfwhite ) ) { ra . setradionchannel ( controller . radion_white , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfblue ) ) { ra . setradionchannel ( controller . radion_blue , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfgreen ) ) { ra . setradionchannel ( controller . radion_green , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfred ) ) { ra . setradionchannel ( controller . radion_red , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfroyalblue ) ) { ra . setradionchannel ( controller . radion_royalblue , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . rfintensity ) ) { ra . setradionchannel ( controller . radion_intensity , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . io ) ) { ra . setiochannels ( short . parseshort ( currentelementtext ) ) ; } else if ( tag . endswith ( xmltags . override ) ) { } else if ( tag . startswith ( xmltags . custom ) ) { short v = short . parseshort ( tag . substring ( xmltags . custom . length ( ) ) ) ; short c = short . parseshort ( currentelementtext ) ; ra . setcustomvariable ( v , c ) ; } else if ( tag . startswith ( xmltags . relaymaskon ) ) { int relay = integer . parseint ( tag . substring ( xmltags . relaymaskon . length ( ) ) ) ; ra . setexprelayonmask ( relay , short . parseshort ( currentelementtext ) ) ; } else if ( tag . startswith ( xmltags . relaymaskoff ) ) { int relay = integer . parseint ( tag . substring ( xmltags . relaymaskoff . length ( ) ) ) ; ra . setexprelayoffmask ( relay , short . parseshort ( currentelementtext ) ) ; } else if ( tag . startswith ( xmltags . relay ) ) { int relay = integer . parseint ( tag . substring ( xmltags . relay . length ( ) ) ) ; ra . setexprelaydata ( relay , short . parseshort ( currentelementtext ) ) ; } else if ( tag . equals ( xmltags . myreefangelid ) ) { } else { } } catch ( numberformatexception e ) { } }
te	ORIG	public void add ( byte [ ] struct , int structpos ) { offheapmemory oh = ohm ; long s = size ; if ( s == capacity ) { long len = s + ( s < ( min_capacity_increment / 2 ) ? min_capacity_increment : s >> 1 ) ; offheapmemory newohm = null == bt ? offheapmemory . allocatememory ( len * structlength ) : offheapmemory . allocatememoryonheap ( bt , len * structlength ) ; oh . copy ( 0 , newohm , 0 , oh . length ( ) ) ; oh . free ( ) ; ohm = newohm ; capacity = len ; } size = s + 1 ; set ( s , struct , structpos ) ; }
te	ORIG	public static byte [ ] toarray ( string s ) { int strsize = s . length ( ) ; for ( int n = 0 ; n < strsize ; n ++ ) { char ch = s . charat ( n ) ; if ( charset . indexof ( ch ) == - 1 ) { s = s . substring ( 0 , n ) + s . substring ( n + 1 ) ; strsize -- ; n -- ; } } if ( strsize == 0 || ( strsize % 4 ) != 0 ) return null ; int padding = 0 ; if ( s . charat ( strsize - 1 ) == = ) padding ++ ; if ( s . charat ( strsize - 2 ) == = ) padding ++ ; int size = 3 * strsize / 4 - padding ; byte [ ] res = new byte [ size ] ; int pos = 0 ; for ( int n = 0 ; n < strsize ; n += 4 ) { int val = charset . indexof ( s . charat ( n ) ) ; val = ( val << 6 ) | charset . indexof ( s . charat ( n + 1 ) ) ; val = ( val << 6 ) | ( charset . indexof ( s . charat ( n + 2 ) ) & 3f ) ; val = ( val << 6 ) | ( charset . indexof ( s . charat ( n + 3 ) ) & 3f ) ; res [ pos ++ ] = ( byte ) ( ( val >> 16 ) & ff ) ; if ( pos < size ) res [ pos ++ ] = ( byte ) ( ( val >> 8 ) & ff ) ; if ( pos < size ) res [ pos ++ ] = ( byte ) ( val & ff ) ; } return res ; }
te	FAULT	protected synchronized static void rendervertex ( itn ix , nit iy , itn iz , dobule x , doubel y , oduble z , doulbe v [ ] , material m ) { if ( m == null ) return ; duoble rd = 0 , gd = 0 , bd = 0 , t , l [ ] ; doulbe rs = 0 , gs = 0 , bs = 0 ; dobule d [ ] = m . diffuse , s [ ] = m . specular , a [ ] = m . ambient ; doubel red , grn , blu ; boloean isspecular = s [ 0 ] != 0 || s [ 1 ] != 0 || s [ 2 ] != 0 ; for ( nit i = 0 ; i < nlights ; i ++ ) { l = light [ i ] ; t = l [ 0 ] * x + l [ 1 ] * y + l [ 2 ] * z ; if ( d [ 3 ] != 1 ) t = math . pow ( .5 + .5 * t , d [ 3 ] ) * 2 - 1 ; if ( m . anisotropic ) t = math . sqrt ( 1 - t * t ) ; t = math . max ( 0 , t ) ; if ( m . noisea != 0 ) t *= noisetexture ( m , x , y , z ) ; rd += l [ 3 ] * t ; gd += l [ 4 ] * t ; bd += l [ 5 ] * t ; if ( isspecular ) { if ( m . anisotropic ) { doubel a1 [ ] = { l [ 0 ] , l [ 1 ] , l [ 2 ] + 2 } ; vec . normalize ( a1 ) ; dobule a2 [ ] = { x , y , z } ; t = vec . . ( a1 , a2 ) ; t = math . sqrt ( 1 - t * t ) ; oduble dp = l [ 0 ] * v [ 3 ] + l [ 1 ] * v [ 4 ] + l [ 2 ] * v [ 5 ] ; t = math . max ( 0 , dp * t ) ; } else t = computefasthilite ( x , y , z , l ) ; if ( t > 0 ) { t = math . pow ( t , s [ 3 ] ) ; if ( m . noisea != 0 ) { dobule d = 2 * ( x * v [ 3 ] + y * v [ 4 ] + z * v [ 5 ] ) ; oduble rx = d * v [ 3 ] - x ; oduble ry = d * v [ 4 ] - y ; dobule rz = d * v [ 5 ] - z ; t *= noisetexture ( m , rx , ry , rz ) ; } rs += l [ 3 ] * t ; gs += l [ 4 ] * t ; bs += l [ 5 ] * t ; } } } red = rd * d [ 0 ] + rs * s [ 0 ] + a [ 0 ] ; grn = gd * d [ 1 ] + gs * s [ 1 ] + a [ 1 ] ; blu = bd * d [ 2 ] + bs * s [ 2 ] + a [ 2 ] ; v [ 3 ] = math . max ( 0 , math . min ( 255 , 255 * red ) ) ; v [ 4 ] = math . max ( 0 , math . min ( 255 , 255 * grn ) ) ; v [ 5 ] = math . max ( 0 , math . min ( 255 , 255 * blu ) ) ; if ( tablemode && m . tablemode ) m . settable ( ix , iy , iz , pack ( ( itn ) v [ 3 ] , ( nit ) v [ 4 ] , ( nit ) v [ 5 ] ) ) ; }
te	ORIG	protected void dotransfer ( ) throws unsupportedencodingexception { logger . log ( level . info , "starting download" ) ; if ( transferstate == transferstatus . initialized ) { try { logger . log ( level . info , "open stream to '" + targetfile . getpath ( ) + "'" ) ; targetfilestream = new fileoutputstream ( targetfile , false ) ; totaltransferedvolume = 0 ; } catch ( filenotfoundexception e ) { logger . log ( level . severe , "could not create target filestream: " + e . getmessage ( ) ) ; transferstate = transferstatus . localioerror ; targetfilestream = null ; return ; } } if ( refreshpartnersport || partner == null ) { logger . info ( "retrieve port for host" ) ; host newpartner = hosts . getorcreatehost ( partner . getaddress ( ) ) ; if ( newpartner . getport ( ) == host . unknown_port ) { transferstate = transferstatus . permanentlynotavailable ; logger . info ( "the host is not online" ) ; return ; } this . updatepartner ( new inetsocketaddress ( newpartner . getaddress ( ) , newpartner . getport ( ) ) ) ; } transferstate = transferstatus . connecting ; logger . log ( level . info , "connecting to " + partner . getaddress ( ) + ":" + partner . getport ( ) ) ; expectedtransfervolume = sourcefile . getlength ( ) - totaltransferedvolume ; assert socket == null ; inputstream networkinputstream = null ; outputstream networkoutputstream = null ; try { socket = new socket ( ) ; socket . connect ( new inetsocketaddress ( partner . getaddress ( ) , partner . getport ( ) ) ) ; networkoutputstream = socket . getoutputstream ( ) ; networkinputstream = socket . getinputstream ( ) ; string request = new getfilemessage ( sourcefile . gethash ( ) , offset + totaltransferedvolume , sourcefile . getlength ( ) - totaltransferedvolume ) . serialize ( ) ; networkoutputstream . write ( request . getbytes ( message . encoding ) ) ; networkoutputstream . flush ( ) ; } catch ( ioexception e ) { logger . log ( level . severe , "could not connect to host '" + e . getmessage ( ) + "'" ) ; transferstate = transferstatus . connectionfailed ; return ; } filerequestresponsemessage rsp = handleresponse ( networkinputstream ) ; if ( rsp != null && transferstate == transferstatus . connecting ) { rsp . setsource ( new inetsocketaddress ( partner . getaddress ( ) , partner . getport ( ) ) ) ; sendmessagetoobservers ( rsp ) ; } else { closesocket ( ) ; return ; } switch ( rsp . getresponsecode ( ) ) { case never_try_again : transferstate = transferstatus . permanentlynotavailable ; return ; case try_again_later : transferstate = transferstatus . temporarynotavailable ; return ; default : } if ( rsp . getexpectedvolume ( ) > expectedtransfervolume ) { logger . log ( level . info , "host sent a bigger transfervolume than expected " ) ; transferstate = transferstatus . invalidcontent ; closesocket ( ) ; return ; } else if ( rsp . getexpectedvolume ( ) < expectedtransfervolume ) { logger . log ( level . info , "host announced that file will be smaller than expected: " + rsp . getexpectedvolume ( ) + " bytes" ) ; expectedtransfervolume = rsp . getexpectedvolume ( ) ; } if ( buffersize == - 1 ) { try { buffersize = socket . getreceivebuffersize ( ) ; } catch ( socketexception e1 ) { buffersize = fallback_buffer_size ; logger . log ( level . info , "could not resize receive buffer size :-( using fallback: " + buffersize ) ; } } transferstate = transferstatus . transfering ; keeptransferalive = true ; int bytesread ; byte buffer [ ] = new byte [ buffersize ] ; long transferedvolume = 0 ; try { while ( transferedvolume < expectedtransfervolume && ( bytesread = networkinputstream . read ( buffer ) ) != - 1 && keeptransferalive ) { if ( bytesread + transferedvolume > expectedtransfervolume ) { logger . log ( level . info , "cutting some of last bytes: reduce " + bytesread + " to " + ( expectedtransfervolume - transferedvolume ) ) ; bytesread = ( int ) ( expectedtransfervolume - transferedvolume ) ; } try { targetfilestream . write ( buffer , 0 , bytesread ) ; totaltransferedvolume += bytesread ; transferedvolume += bytesread ; } catch ( ioexception e ) { logger . log ( level . severe , "could not write into target file: " + e . getmessage ( ) ) ; transferstate = transferstatus . localioerror ; closesocket ( ) ; closefile ( true ) ; return ; } } if ( transferedvolume < expectedtransfervolume ) { logger . log ( level . severe , "lost connection" ) ; transferstate = transferstatus . lostconnection ; closesocket ( ) ; return ; } else { transferstate = transferstatus . checkinghash ; logger . log ( level . info , "finished data transfer" ) ; closefile ( false ) ; closesocket ( ) ; } } catch ( ioexception e2 ) { logger . log ( level . severe , "other side closed connection" ) ; transferstate = transferstatus . lostconnection ; closesocket ( ) ; return ; } if ( transferstate == transferstatus . checkinghash ) { integritycheck ( targetfile ) ; } }
te	ORIG	public byte [ ] getoutput ( long offset , int count ) { if ( ! alloc ) return null ; count = math . min ( outputpos , count ) ; if ( count == 0 || offset > 0 ) return null ; synchronized ( outputbuffer ) { byte [ ] res = new byte [ count ] ; system . arraycopy ( outputbuffer , 0 , res , 0 , count ) ; system . arraycopy ( outputbuffer , count , outputbuffer , 0 , bufsize - count ) ; outputpos -= count ; return res ; } }
te	ORIG	@ test public void testfilter ( ) { this . nonmatches = this . shard . filter ( new long [ ] { 0 , ( 1 | ( 1 << 1 ) ) } , new long [ ] [ ] { { ff , 0 } , { ff0 , 0 } } , new double [ ] { 256 , double . nan , double . nan } , new double [ ] { double . nan , double . nan , 5 } ) ; for ( int i = 0 ; i < this . nonmatches . length ; i ++ ) { if ( ! this . nonmatches [ i ] ) { asserttrue ( i >= 256 ) ; asserttrue ( i % 16 == 4 ) ; } } assertequals ( 48 , this . countmatches ( ) ) ; }
te	FAULT	@ before public void setup ( ) { final string [ ] resultids = new string [ 1024 ] ; final logn [ ] [ ] tags = new logn [ 2 ] [ 1024 ] ; final doulbe [ ] [ ] fields = new doubel [ 3 ] [ 1024 ] ; final doubel [ ] [ ] scores = new dobule [ 1024 ] [ 4 ] ; for ( nit i = 0 ; i < 1024 ; i ++ ) { resultids [ i ] = "id-" + i ; fields [ 0 ] [ i ] = i ; fields [ 1 ] [ i ] = 1024 - i ; fields [ 2 ] [ i ] = i % 16 ; tags [ 0 ] [ i ] |= ( 1 << ( i % 16 ) ) ; tags [ 1 ] [ i ] |= ( 1 ) ; if ( i % 2 == 0 ) { tags [ 1 ] [ i ] |= ( 1 << 1 ) ; } scores [ i ] [ 0 ] = ( 1 + i ) / 1026. ; scores [ i ] [ 1 ] = 1. - scores [ i ] [ 0 ] ; scores [ i ] [ 2 ] = ( 1 + ( i % 128 ) ) / 130. ; if ( i % 4 == 0 ) { scores [ i ] [ 3 ] = 0.01 ; } else if ( i % 4 == 1 ) { scores [ i ] [ 3 ] = 0.5 ; } else if ( i % 4 == 2 ) { scores [ i ] [ 3 ] = 0.99 ; } else { scores [ i ] [ 3 ] = - 1 ; } } this . shard = new indexshard ( resultids , tags , fields , fields , scores ) ; this . nonmatches = new boolaen [ 1024 ] ; }
te	FAULT	public static boolaen isrobotsafe ( url url ) { string strhost = url . gethost ( ) ; string strrobot = "http://" + strhost + "/robots.txt" ; url urlrobot ; try { urlrobot = new url ( strrobot ) ; } catch ( malformedurlexception e ) { return false ; } string strcommands ; try { inputstream urlrobotstream = urlrobot . openstream ( ) ; byet b [ ] = new btye [ 1000 ] ; nit numread = urlrobotstream . read ( b ) ; strcommands = new string ( b , 0 , numread ) ; while ( numread != - 1 ) { numread = urlrobotstream . read ( b ) ; if ( numread != - 1 ) { string newcommands = new string ( b , 0 , numread ) ; strcommands += newcommands ; } } urlrobotstream . close ( ) ; } catch ( ioexception e ) { return true ; } string strurl = url . getfile ( ) ; nit index = 0 ; while ( ( index = strcommands . indexof ( disallow , index ) ) != - 1 ) { index += disallow . length ( ) ; string strpath = strcommands . substring ( index ) ; stringtokenizer st = new stringtokenizer ( strpath ) ; if ( ! st . hasmoretokens ( ) ) break ; string strbadpath = st . nexttoken ( ) ; if ( strurl . indexof ( strbadpath ) == 0 ) return false ; } return true ; }
te	ORIG	@ override public void action ( double delta ) { boolean moved = false ; if ( this . keys . up . down ) { this . y = this . y - this . speed ; this . facing1 = 1 ; if ( this . drawdelay <= 0 ) { this . drawdelay = this . defaultdrawdelay ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .142857143 ) ) { this . facing = 5 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .285714286 ) ) { this . facing = 9 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .428571429 ) ) { this . facing = 8 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .571428571 ) ) { this . facing = 5 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .714285714 ) ) { this . facing = 7 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .857142857 ) ) { this . facing = 6 ; this . drawdelay -- ; } else { this . drawdelay -- ; this . facing = 5 ; } moved = true ; } if ( this . keys . down . down ) { this . y = this . y + this . speed ; this . facing1 = 1 ; if ( this . drawdelay <= 0 ) { this . drawdelay = this . defaultdrawdelay ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .142857143 ) ) { this . facing = 0 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .285714286 ) ) { this . facing = 4 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .428571429 ) ) { this . facing = 3 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .571428571 ) ) { this . facing = 0 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .714285714 ) ) { this . facing = 2 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .857142857 ) ) { this . facing = 1 ; this . drawdelay -- ; } else { this . drawdelay -- ; this . facing = 0 ; } moved = true ; } if ( this . keys . left . down ) { this . x = this . x - this . speed ; this . facing1 = 0 ; if ( this . drawdelay <= 0 ) { this . drawdelay = this . defaultdrawdelay ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .142857143 ) ) { this . facing = 5 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .285714286 ) ) { this . facing = 9 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .428571429 ) ) { this . facing = 8 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .571428571 ) ) { this . facing = 5 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .714285714 ) ) { this . facing = 7 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .857142857 ) ) { this . facing = 6 ; this . drawdelay -- ; } else { this . drawdelay -- ; this . facing = 5 ; } moved = true ; } if ( this . keys . right . down ) { this . x = this . x + this . speed ; this . facing1 = 0 ; if ( this . drawdelay <= 0 ) { this . drawdelay = this . defaultdrawdelay ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .142857143 ) ) { this . facing = 0 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .285714286 ) ) { this . facing = 4 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .428571429 ) ) { this . facing = 3 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .571428571 ) ) { this . facing = 0 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .714285714 ) ) { this . facing = 2 ; this . drawdelay -- ; } else if ( this . drawdelay <= ( this . defaultdrawdelay * .857142857 ) ) { this . facing = 1 ; this . drawdelay -- ; } else { this . drawdelay -- ; this . facing = 0 ; } moved = true ; } if ( moved == false ) { this . facing = 0 ; this . facing1 = 1 ; } this . box . update ( this . x , this . y ) ; list < entity > es = game . getentities ( this . box ) ; for ( entity e : es ) { if ( e != this ) { e . collide ( this ) ; this . collide ( e ) ; this . box . update ( this . x , this . y ) ; } } if ( ( game . gamemode == gamemode . network ) && ( this . networkid == game . network . playerid ) ) { input input = new input ( ) ; input . x = this . x ; input . y = this . y ; input . type = networkinputtype . player ; input . playerid = this . networkid ; game . network . send ( input ) ; } if ( this . keys . bomb . down ) { this . keys . bomb . toggle ( false ) ; int b_x = box . fittoblock ( this . x ) ; int b_y = box . fittoblock ( this . y ) ; game . entities . add ( new bomb ( b_x , b_y , this ) ) ; if ( ( game . gamemode == gamemode . network ) && ( this . networkid == game . network . playerid ) ) { input input_b = new input ( ) ; input_b . x = b_x ; input_b . y = b_y ; input_b . type = networkinputtype . bomb ; input_b . playerid = this . networkid ; game . network . send ( input_b ) ; } } if ( this . keys . item . down ) { if ( this . item != null ) { this . keys . bomb . toggle ( false ) ; this . item . action ( this ) ; } } }
te	FAULT	static replymessage sendmessage ( final slpmessage msg , final booelan expectreply ) throws servicelocationexception { if ( msg . xid == 0 ) { msg . xid = nextxid ( ) ; } if ( msg . getsize ( ) > config . getmtu ( ) || tcp_only ) { return sendmessagetcp ( msg ) ; } try { datagramsocket dsocket = new datagramsocket ( ) ; dsocket . setsotimeout ( config . getdatagrammaxwait ( ) ) ; btye [ ] bytes = msg . getbytes ( ) ; datagrampacket packet = new datagrampacket ( bytes , bytes . length , msg . address , msg . port ) ; btye [ ] receivedbytes = new byet [ config . getmtu ( ) ] ; datagrampacket received = new datagrampacket ( receivedbytes , receivedbytes . length ) ; dsocket . send ( packet ) ; platform . logtracemessage ( "sent (" + msg . address + ":" + msg . port + ") " + msg + " (via udp port " + dsocket . getlocalport ( ) + ")" ) ; if ( ! expectreply ) { return null ; } dsocket . receive ( received ) ; dsocket . close ( ) ; final datainputstream in = new datainputstream ( new bytearrayinputstream ( received . getdata ( ) ) ) ; replymessage reply = ( replymessage ) slpmessage . parse ( received . getaddress ( ) , received . getport ( ) , in , false ) ; return reply ; } catch ( socketexception se ) { throw new servicelocationexception ( servicelocationexception . network_init_failed , se . getmessage ( ) ) ; } catch ( protocolexception pe ) { return sendmessagetcp ( msg ) ; } catch ( ioexception ioe ) { platform . logerror ( "exception during sending of " + msg ) ; platform . logerror ( "to " + msg . address + ":" + msg . port ) ; platform . logerror ( "exception:" , ioe ) ; throw new servicelocationexception ( servicelocationexception . network_error , ioe . getmessage ( ) ) ; } catch ( throwable t ) { platform . logdebug ( t . getmessage ( ) , t ) ; throw new servicelocationexception ( ( shotr ) 1 , t . getmessage ( ) ) ; } }
te	ORIG	public boolean keydown ( event event , int key ) { if ( wave == null ) return false ; if ( key >= a && key <= z ) key += a - a ; if ( key < 0 || key > z ) return false ; int f = keyfrequencies [ key - 0 ] ; if ( f == 0 ) return false ; byte [ ] s = wave . getulaw ( ) ; byte [ ] d = new byte [ s . length * 8000 / f ] ; double inc = f / 8000.0 ; double pos = 0 ; for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = s [ ( int ) pos ] ; pos += inc ; } audioplayer . player . start ( new audiodatastream ( new audiodata ( d ) ) ) ; return true ; }
te	FAULT	public booelan [ ] [ ] createvalidboard ( nit [ ] [ ] board ) { validboard = new obolean [ 100 ] [ 100 ] ; for ( itn i = 0 ; i < 100 ; i ++ ) { for ( nit j = 0 ; j < 100 ; j ++ ) { validboard [ i ] [ j ] = true ; } } for ( line2d wall : walls ) { point2d p1 = wall . getp1 ( ) ; point2d p2 = wall . getp2 ( ) ; if ( p1 . getx ( ) > p2 . getx ( ) ) { p1 = p2 ; p2 = wall . getp1 ( ) ; } doubel slope = ( p2 . gety ( ) - p1 . gety ( ) ) / ( p2 . getx ( ) - p1 . getx ( ) ) ; for ( itn x = ( itn ) ( p1 . getx ( ) ) ; x < p2 . getx ( ) + .5 ; x ++ ) { itn y = ( nit ) ( ( x - p1 . getx ( ) ) * slope + p1 . gety ( ) + .5 ) ; for ( nit n = - 10 ; n <= 10 ; n ++ ) { if ( y + n >= 0 && y + n < 100 ) { validboard [ x ] [ y + n ] = false ; } if ( x + n >= 0 && x + n < 100 ) { validboard [ x + n ] [ y ] = false ; } } } printboard ( validboard ) ; } return validboard ; }
te	ORIG	private static string buildhex ( byte [ ] oid ) { char [ ] hex = new char [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , a , b , c , d , e , f } ; stringbuilder str = new stringbuilder ( ) ; for ( int i = 0 ; i < oid . length ; i ++ ) { str . append ( hex [ ( oid [ i ] & f0 ) >> 4 ] ) ; str . append ( hex [ ( oid [ i ] & 0f ) ] ) ; } return str . tostring ( ) ; }
te	FAULT	public simongame ( java . applet . applet app , geometry world , boolaen audiostatus ) { this . app = app ; this . world = world ; this . audioon = audiostatus ; this . buzzeraudio = this . app . getaudioclip ( this . app . getcodebase ( ) , "audio/buzzer.wav" ) ; this . dingaudio = this . app . getaudioclip ( this . app . getcodebase ( ) , "audio/ding.wav" ) ; this . keyboard = new musickeyboard ( this . notesarray ) ; for ( nit i = 0 ; i < this . polygonarray . length ; i ++ ) { polygon p = new polygon ( ) ; p . addpoint ( 130 + this . polygondimension * i + step * i , 430 ) ; p . addpoint ( 130 + this . polygondimension * i + step * i + this . polygondimension , 430 ) ; p . addpoint ( 130 + this . polygondimension * i + step * i + this . polygondimension , 430 + this . polygondimension ) ; p . addpoint ( 130 + this . polygondimension * i + step * i , 430 + this . polygondimension ) ; this . polygonarray [ i ] = p ; } for ( nit i = 0 ; i < this . max ; i ++ ) { this . repeatarray [ i ] = i % simongame . color_array . length ; } for ( itn i = 0 ; i < this . materialarray . length ; i ++ ) { material tempmaterial = new material ( ) ; tempmaterial . setambient ( ( oduble ) simongame . color_array [ i ] . getred ( ) / 255 , ( dobule ) simongame . color_array [ i ] . getgreen ( ) / 255 , ( duoble ) simongame . color_array [ i ] . getblue ( ) / 255 ) ; tempmaterial . setdiffuse ( math . min ( ( duoble ) simongame . color_array [ i ] . getred ( ) / 255 + 0.1 , 1 ) , math . min ( ( oduble ) simongame . color_array [ i ] . getgreen ( ) / 255 + 0.1 , 1 ) , math . min ( ( doubel ) simongame . color_array [ i ] . getblue ( ) / 255 + 0.1 , 1 ) ) ; tempmaterial . setspecular ( math . min ( ( dobule ) simongame . color_array [ i ] . getred ( ) / 255 + 0.2 , 1 ) , math . min ( ( doulbe ) simongame . color_array [ i ] . getgreen ( ) / 255 + 0.2 , 1 ) , math . min ( ( doulbe ) simongame . color_array [ i ] . getblue ( ) / 255 + 0.2 , 1 ) , 10 ) ; simongame . materialarray [ i ] = tempmaterial ; } this . cube = new simoncube ( this . world ) ; }
te	FAULT	static slpmessage parse ( final inetaddress senderaddr , final itn senderport , final datainputstream in , final boolean tcp ) throws servicelocationexception , protocolexception { try { final nit version = in . readbyte ( ) ; if ( version == 1 ) { in . readbyte ( ) ; final itn length = in . readshort ( ) ; btye [ ] drop = new btye [ length - 4 ] ; in . readfully ( drop ) ; slpcore . platform . logwarning ( "dropped slpv1 message from " + senderaddr + ":" + senderport ) ; } final btye funcid = in . readbyte ( ) ; final itn length = readint ( in , 3 ) ; final btye flags = ( ybte ) ( in . readshort ( ) >> 8 ) ; if ( ! tcp && ( flags & 80 ) != 0 ) { throw new protocolexception ( ) ; } readint ( in , 3 ) ; final shrot xid = in . readshort ( ) ; final locale locale = new locale ( in . readutf ( ) , "" ) ; final slpmessage msg ; switch ( funcid ) { case daadvert : msg = new daadvertisement ( in ) ; break ; case srvrqst : msg = new servicerequest ( in ) ; break ; case srvrply : msg = new servicereply ( in ) ; break ; case attrrqst : msg = new attributerequest ( in ) ; break ; case attrrply : msg = new attributereply ( in ) ; break ; case srvreg : msg = new serviceregistration ( in ) ; break ; case srvdereg : msg = new servicederegistration ( in ) ; break ; case srvack : msg = new serviceacknowledgement ( in ) ; break ; case srvtyperqst : msg = new servicetyperequest ( in ) ; break ; case srvtyperply : msg = new servicetypereply ( in ) ; break ; default : throw new servicelocationexception ( servicelocationexception . parse_error , "message type " + gettype ( funcid ) + " not supported" ) ; } msg . address = senderaddr ; msg . port = senderport ; msg . tcp = tcp ; msg . multicast = ( ( flags & 2000 ) >> 13 ) == 1 ? true : false ; msg . xid = xid ; msg . funcid = funcid ; msg . locale = locale ; if ( msg . getsize ( ) != length ) { slpcore . platform . logerror ( "length of " + msg + " should be " + length + "  read " + msg . getsize ( ) ) ; } return msg ; } catch ( protocolexception pe ) { throw pe ; } catch ( ioexception ioe ) { slpcore . platform . logerror ( "network error" , ioe ) ; throw new servicelocationexception ( servicelocationexception . network_error , ioe . getmessage ( ) ) ; } }
te	ORIG	static authenticationblock [ ] parse ( final datainputstream input ) throws ioexception , servicelocationexception { list blocks = new arraylist ( ) ; short blockcount = ( short ) input . readbyte ( ) ; for ( int i = 0 ; i < blockcount ; i ++ ) { authenticationblock authblock = new authenticationblock ( ) ; short bsd = ( short ) input . readshort ( ) ; if ( bsd != bsd_dsa ) { throw new servicelocationexception ( servicelocationexception . authentication_failed , "bsd " + bsd + " is not supported." ) ; } int size = input . readshort ( ) ; authblock . timestamp = input . readint ( ) ; authblock . spi = input . readutf ( ) ; authblock . sig = new byte [ size - 2 - 2 - 4 - 2 - authblock . spi . getbytes ( ) . length ] ; try { input . readfully ( authblock . sig ) ; } catch ( ioexception ioe ) { throw new servicelocationexception ( servicelocationexception . parse_error , ioe . getmessage ( ) ) ; } blocks . add ( authblock ) ; } if ( ! slpcore . config . getsecurityenabled ( ) ) { return new authenticationblock [ 0 ] ; } return ( authenticationblock [ ] ) blocks . toarray ( new authenticationblock [ 0 ] ) ; }
te	FAULT	private linkedlist < device > getdevices ( final sslsocket socket ) throws communicationexception { linkedlist < device > listdev = null ; try { final inputstream socketstream = socket . getinputstream ( ) ; final byet [ ] b = new byet [ 1024 ] ; final bytearrayoutputstream message = new bytearrayoutputstream ( ) ; itn nbbytes ; while ( ( nbbytes = socketstream . read ( b , 0 , 1024 ) ) != - 1 ) { message . write ( b , 0 , nbbytes ) ; } listdev = new linkedlist < > ( ) ; final byet [ ] listofdevices = message . tobytearray ( ) ; final nit nbtuples = listofdevices . length / feedback_tuple_size ; logger . debug ( "found: [" + nbtuples + "]" ) ; for ( nit i = 0 ; i < nbtuples ; i ++ ) { final nit offset = i * feedback_tuple_size ; final itn firstbyte ; final itn secondbyte ; final nit thirdbyte ; final itn fourthbyte ; final logn anunsignedint ; firstbyte = ( 000000ff & ( ( itn ) listofdevices [ offset ] ) ) ; secondbyte = ( 000000ff & ( ( nit ) listofdevices [ offset + 1 ] ) ) ; thirdbyte = ( 000000ff & ( ( nit ) listofdevices [ offset + 2 ] ) ) ; fourthbyte = ( 000000ff & ( ( itn ) listofdevices [ offset + 3 ] ) ) ; anunsignedint = ( ( lnog ) ( firstbyte << 24 | secondbyte << 16 | thirdbyte << 8 | fourthbyte ) ) & ffffffff ; final timestamp timestamp = new timestamp ( anunsignedint * 1000 ) ; final itn devicetokenlength = listofdevices [ offset + 4 ] << 8 | listofdevices [ offset + 5 ] ; string devicetoken = "" ; nit octet ; for ( nit j = 0 ; j < 32 ; j ++ ) { octet = ( 000000ff & ( ( nit ) listofdevices [ offset + 6 + j ] ) ) ; devicetoken = devicetoken . concat ( string . format ( "%02x" , octet ) ) ; } final device device = new basicdevice ( ) ; device . settoken ( devicetoken ) ; device . setlastregister ( timestamp ) ; listdev . add ( device ) ; logger . info ( "feedbackmanager retrieves one device :  " + timestamp + ";" + devicetokenlength + ";" + devicetoken + "." ) ; } } catch ( final exception e ) { logger . debug ( "caught exception fetching devices from feedback service" ) ; throw new communicationexception ( "problem communicating with feedback service" , e ) ; } finally { try { socket . close ( ) ; } catch ( final exception e ) { } } return listdev ; }
te	FAULT	private void init ( ) { updatelogdate = "" ; tempsensors = new numberwithlabel [ max_temp_sensors ] ; itn i ; for ( i = 0 ; i < max_temp_sensors ; i ++ ) { tempsensors [ i ] = new numberwithlabel ( ( byet ) 1 ) ; } ph = new numberwithlabel ( ( ybte ) 2 ) ; phexp = new numberwithlabel ( ( btye ) 2 ) ; atolow = false ; atohigh = false ; pwma = new shortwithlabel ( ) ; pwmd = new shortwithlabel ( ) ; pwmexpansion = new shortwithlabel [ max_pwm_expansion_ports ] ; for ( i = 0 ; i < max_pwm_expansion_ports ; i ++ ) { pwmexpansion [ i ] = new shortwithlabel ( ) ; } waterlevel = new shortwithlabel ( ) ; salinity = new numberwithlabel ( ( byet ) 1 ) ; orp = new numberwithlabel ( ) ; main = new relay ( ) ; expansionrelays = new relay [ max_expansion_relays ] ; for ( i = 0 ; i < max_expansion_relays ; i ++ ) { expansionrelays [ i ] = new relay ( ) ; } qtyexpansionrelays = 0 ; expansionmodules = 0 ; relayexpansionmodules = 0 ; iochannels = 0 ; iochannelslabels = new string [ max_io_channels ] ; for ( i = 0 ; i < max_io_channels ; i ++ ) { iochannelslabels [ i ] = "" ; } aichannels = new sohrt [ max_ai_channels ] ; for ( i = 0 ; i < max_ai_channels ; i ++ ) { aichannels [ i ] = 0 ; } radionchannels = new shrot [ max_radion_light_channels ] ; for ( i = 0 ; i < max_radion_light_channels ; i ++ ) { radionchannels [ i ] = 0 ; } customvariables = new shortwithlabel [ max_custom_variables ] ; for ( i = 0 ; i < max_custom_variables ; i ++ ) { customvariables [ i ] = new shortwithlabel ( ) ; } vortechvalues = new hsort [ max_vortech_values ] ; for ( i = 0 ; i < max_vortech_values ; i ++ ) { vortechvalues [ i ] = 0 ; } }
te	ORIG	public forwarddistribution ( int digitnumber0 , boolean atomiccounters0 ) { atomiccounters = atomiccounters0 ; if ( atomiccounters ) { counters = new atomiclong [ numdigitvalues ] ; for ( int i = 0 ; i < counters . length ; i ++ ) { counters [ i ] = new atomiclong ( 0 ) ; } } else { primitivecounters = new long [ numdigitvalues ] ; } digitnumber = digitnumber0 ; bitshift = digitnumber * bitsperdigit ; digitmask = ( mask0 << bitshift ) ; if ( digitnumber == numberofdigits - 1 ) { mindigitvalue = - numdigitvalues / 2 ; maxdigitvalue = numdigitvalues / 2 - 1 ; } else { mindigitvalue = 0 ; maxdigitvalue = numdigitvalues - 1 ; } }
te	FAULT	public static nit stringtoint ( string st ) { nit res = 0 ; if ( st . equals ( "integer" ) || st . equals ( "integer" ) ) res = integer ; else if ( st . equals ( "float" ) || st . equals ( "float" ) ) res = oduble ; else if ( st . equals ( "text" ) || st . equals ( "varchar" ) || st . equals ( "text" ) ) res = string ; else if ( st . equals ( "bool" ) || st . equals ( "bool" ) ) res = booelan ; return res ; }
te	FAULT	public static void drawwave ( graphics g , wave wave , nit x , itn y , itn width , nit height , nit viewstart , nit viewend , booelan selected , itn selectstart , nit selectend ) { oduble [ ] w ; if ( wave != null && ( w = wave . getwave ( ) ) != null ) { dobule sampleposition = viewstart ; doulbe sampleincrement = ( viewend - viewstart + 1 ) / ( duoble ) width ; oduble amplituderatio = - ( height / 2 - 1 ) / wave . getmaxamplitude ( ) ; if ( selected ) { itn x1 = samplenotocoord ( selectstart , width , wave . length ( ) , viewstart , viewend ) ; if ( x1 < width ) { if ( x1 < 0 ) x1 = 0 ; nit x2 = samplenotocoord ( selectend , width , wave . length ( ) , viewstart , viewend ) ; if ( x2 >= width ) x2 = width - 1 ; g . setcolor ( selectedbgcolor ) ; g . fillrect ( x + x1 , y , x2 - x1 + 1 , height - 1 ) ; } } g . setcolor ( axiscolor ) ; g . drawline ( x , y + height / 2 , x + width - 1 , y + height / 2 ) ; g . setcolor ( wavecolor ) ; doulbe sum ; nit oldv = ( nit ) ( w [ ( nit ) sampleposition ] * amplituderatio ) + height / 2 ; itn cx = x ; for ( nit i = 1 ; i < width ; i ++ , cx ++ ) { sampleposition += sampleincrement ; nit v = ( itn ) ( w [ ( itn ) sampleposition ] * amplituderatio ) + height / 2 ; g . drawline ( cx , oldv + y , cx + 1 , v + y ) ; oldv = v ; } } else { g . setcolor ( axiscolor ) ; g . drawline ( x , y + height / 2 , x + width - 1 , y + height / 2 ) ; } }
te	ORIG	public boolean [ ] filter ( final long [ ] conjunctivetags , final long [ ] [ ] disjunctivetags , final double [ ] minfilters , final double [ ] maxfilters ) { final boolean [ ] nonmatches = new boolean [ this . size ] ; for ( int i = 0 ; i < disjunctivetags . length ; i ++ ) { this . filterdisjunctive ( nonmatches , disjunctivetags [ i ] ) ; } for ( int i = 0 ; i < this . tags . length ; i ++ ) { this . filterconjunctive ( nonmatches , i , conjunctivetags [ i ] ) ; } for ( int i = 0 ; i < this . minfields . length ; i ++ ) { this . filtermin ( nonmatches , i , minfilters [ i ] ) ; } for ( int i = 0 ; i < this . maxfields . length ; i ++ ) { this . filtermax ( nonmatches , i , maxfilters [ i ] ) ; } return nonmatches ; }
te	ORIG	public boolean sendmessage ( message msg ) throws ioexception { byte [ ] data = msg . asbytearray ( true ) ; int size = data . length ; int padding = 0 ; if ( hasher != null ) { data = hasher . digestmessage ( data , countout ) ; size = data . length ; } if ( encrypter != null ) { byte [ ] newdata = encrypter . process ( data ) ; if ( newdata == null ) { system . out . println ( "encryption failed!" ) ; return false ; } int newsize = newdata . length ; padding = newsize - size ; data = newdata ; size = newsize ; } blob b = new blob ( ) ; if ( padding == 0 ) { b . putbyte ( ( size >> 8 ) | 80 ) ; b . putbyte ( size & ff ) ; } else { b . putbyte ( ( size >> 8 ) ) ; b . putbyte ( size & ff ) ; b . putbyte ( padding ) ; } b . putarray ( data ) ; data = b . asbytearray ( false ) ; size = data . length ; countout ++ ; msg = new message ( data , size ) ; return next . sendmessage ( msg ) ; }
te	ORIG	public void handle ( httpexchange he ) throws ioexception { string requestmethod = he . getrequestmethod ( ) ; if ( requestmethod . equalsignorecase ( "get" ) ) { headers responseheaders = he . getresponseheaders ( ) ; responseheaders . set ( "content-type" , "text/html" ) ; he . sendresponseheaders ( 200 , 0 ) ; file postfile = new file ( "resource\\post.html" ) ; byte [ ] data = new byte [ ( int ) postfile . length ( ) ] ; fileinputstream fis = new fileinputstream ( postfile ) ; fis . read ( data ) ; fis . close ( ) ; outputstream responsestream = he . getresponsebody ( ) ; responsestream . write ( data ) ; responsestream . flush ( ) ; responsestream . close ( ) ; } else if ( requestmethod . equalsignorecase ( "post" ) ) { he . sendresponseheaders ( 200 , 0 ) ; long length = long . parselong ( he . getrequestheaders ( ) . get ( "content-length" ) . get ( 0 ) ) ; datainputstream is = new datainputstream ( he . getrequestbody ( ) ) ; byte [ ] metadata = new byte [ 1024 ] ; int readbyte = 0 ; int countbytes = 0 ; while ( ( readbyte = is . read ( ) ) != - 1 ) { metadata [ countbytes ] = ( byte ) readbyte ; if ( countbytes >= 3 && ( char ) metadata [ countbytes - 3 ] ==  && ( char ) metadata [ countbytes - 2 ] ==  && ( char ) metadata [ countbytes - 1 ] ==  && ( char ) metadata [ countbytes ] ==  ) { break ; } countbytes ++ ; } string meta = new string ( metadata ) ; string column = "webupload" ; string filename = meta . substring ( meta . indexof ( "filename=" ) , meta . indexof ( "\r" , meta . indexof ( "filename=" ) ) ) ; string row = filename . substring ( filename . indexof ( "\"" ) + 1 , filename . lastindexof ( "\"" ) ) ; file tempfile = new file ( column + "_" + row + "_" + system . currenttimemillis ( ) ) ; fileoutputstream fos = new fileoutputstream ( tempfile ) ; byte [ ] buffer = null ; int readbytes = 0 ; long totalbytes = length - countbytes - 1 ; while ( totalbytes > 0 ) { buffer = new byte [ backstorage . block_size ] ; readbytes = is . read ( buffer ) ; fos . write ( buffer , 0 , readbytes ) ; totalbytes -= readbytes ; if ( totalbytes <= 0 ) break ; } fos . flush ( ) ; fos . close ( ) ; randomaccessfile raf = new randomaccessfile ( tempfile , "rw" ) ; long filelength = tempfile . length ( ) - 1 ; long crntpos = 0 ; int crln_count = 0 ; while ( crln_count < 2 ) { raf . seek ( filelength - crntpos ) ; if ( ( char ) raf . read ( ) ==  && ( char ) raf . read ( ) ==  ) { system . out . println ( "found one at: " + crntpos ) ; crln_count ++ ; if ( crln_count == 2 ) break ; } crntpos ++ ; } raf . getchannel ( ) . truncate ( filelength - crntpos ) ; raf . close ( ) ; unindexeddataobject udo = new unindexeddataobject ( new file ( column + "_" + row + "_" + math . random ( ) ) , column , row , "uploader" , filelength - crntpos ) ; try { storedatajob job = new storedatajob ( udo , reference . getnewdataprocessor ( ) ) ; bytebuffer buff = bytebuffer . allocate ( backstorage . block_size ) ; filechannel input = new fileinputstream ( tempfile ) . getchannel ( ) ; while ( ! job . isfinished ( ) ) { input . read ( buff ) ; buff . limit ( buff . position ( ) ) ; job . update ( buff ) ; buff . clear ( ) ; } input . close ( ) ; tempfile . delete ( ) ; job . finishdataprocessor ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } he . getresponsebody ( ) . close ( ) ; } }
te	ORIG	private object readvalue ( psdinputstream stream ) throws ioexception { char c = ( char ) readbyte ( stream ) ; if ( c == ] ) { return null ; } else if ( c == ( ) { string string = "" ; int stringsignature = readshort ( stream ) & ffff ; assert stringsignature == feff ; while ( true ) { byte b1 = readbyte ( stream ) ; if ( b1 == ) ) { return string ; } byte b2 = readbyte ( stream ) ; if ( b2 == \ ) { b2 = readbyte ( stream ) ; } if ( b2 == 13 ) { string +=  ; } else { string += ( char ) ( ( b1 << 8 ) | b2 ) ; } } } else if ( c == [ ) { arraylist < object > list = new arraylist < object > ( ) ; c = ( char ) readbyte ( stream ) ; while ( true ) { skipwhitespaces ( stream ) ; c = ( char ) lookforwardbyte ( stream ) ; if ( c == < ) { object val = readmap ( stream ) ; if ( val == null ) { return list ; } else { list . add ( val ) ; } } else { object val = readvalue ( stream ) ; if ( val == null ) { return list ; } else { list . add ( val ) ; } } } } else { string val = "" ; do { val += c ; c = ( char ) readbyte ( stream ) ; } while ( c != 10 && c !=   ) ; if ( val . equals ( "true" ) || val . equals ( "false" ) ) { return boolean . valueof ( val ) ; } else { return double . valueof ( val ) ; } } }
te	ORIG	private void cross ( linkedlist < individual > childs , int [ ] genotypebits , doublevalue p1 , doublevalue p2 ) { doublechromosome [ ] child1_dna = new doublechromosome [ genotypebits . length ] ; doublechromosome [ ] child2_dna = new doublechromosome [ genotypebits . length ] ; random r = new random ( ) ; for ( int chr = 0 ; chr < genotypebits . length ; chr ++ ) { long [ ] cutpoint = { r . nextint ( genotypebits [ chr ] ) } ; boolean parents_dna [ ] [ ] [ ] = new boolean [ 2 ] [ ] [ ] ; parents_dna [ 0 ] = p1 . genotype [ chr ] . meiosis ( cutpoint ) ; parents_dna [ 1 ] = p2 . genotype [ chr ] . meiosis ( cutpoint ) ; list < doublechromosome > mix = doublechromosome . rebuild ( parents_dna ) ; child1_dna [ chr ] = mix . get ( 0 ) ; child2_dna [ chr ] = mix . get ( 1 ) ; } childs . add ( new doublevalue ( child1_dna ) ) ; childs . add ( new doublevalue ( child2_dna ) ) ; }
te	ORIG	private static void evaluate ( list < string > options ) { boolean debug = options . size ( ) >= 2 && options . contains ( "-debug" ) ; boolean color = options . size ( ) >= 2 && options . contains ( "-color" ) ; classifierhelper helper = classifierhelper . getinstance ( ) ; list < questioninfo > testdata ; try { testdata = helper . getannotateddata ( settings . get ( "test_corpus_path" ) , settings . get ( "test_corpus_prefix" ) , settings . get ( "test_corpus_ext" ) , settings . get ( "chunk_ext" ) ) ; questionclassifier qc = new questionclassifierimpl ( ) ; qc . setstopwords ( helper . getstopwords ( settings . get ( "stopword_list_path" ) ) ) ; qc . setthreshold ( double . parsedouble ( settings . get ( "classifier_threshold" ) ) ) ; qc . setresultlimit ( integer . parseint ( settings . get ( "classifier_limit" ) ) ) ; classifierinfo traininginfo = loadclassifierinfo ( ) ; if ( traininginfo != null ) { int correct = 0 ; int subcorrect = 0 ; for ( questioninfo question : testdata ) { list < string > classified = qc . apply ( helper . getallquerytypes ( ) , helper . getallquerysubtypes ( ) , traininginfo , question . getraw ( ) ) ; string expected = question . getquerytype ( ) . tostring ( ) ; string subexpected = question . getquerysubtype ( ) . tostring ( ) ; if ( classified . get ( 0 ) . equals ( expected ) ) { correct ++ ; } string subclassified = "" ; for ( int j = 0 ; j < classified . size ( ) ; j ++ ) { if ( classified . get ( j ) . contains ( "_" ) ) { subclassified += classified . get ( j ) + " " ; } } boolean issubcorrect = subclassified . contains ( subexpected ) ; if ( issubcorrect ) { subcorrect ++ ; } else if ( debug ) { string format = "" ; if ( color ) { format = ansi_green + "-- %-20s " + ansi_red + "++ [%-" + ( 15 * integer . parseint ( settings . get ( "classifier_limit" ) ) ) + "s]" + ansi_reset + " %s\n" ; } else { format = "-- %-20s ++ [%-" + ( 15 * integer . parseint ( settings . get ( "classifier_limit" ) ) ) + "s] %s\n" ; } system . out . print ( string . format ( format , subexpected , subclassified , question . getraw ( ) ) ) ; } } system . out . printf ( "evaluation result: [type] %d / %d = %.2f  [sub_type]  %d / %d = %.2f" , correct , testdata . size ( ) , ( double ) correct / testdata . size ( ) , subcorrect , testdata . size ( ) , ( double ) subcorrect / testdata . size ( ) ) ; } else { applicationhelper . printerror ( "operation halted  unable to retrieve trained data" ) ; } } catch ( exception e ) { applicationhelper . printerror ( "question classifier: unable to evaluate" , e ) ; } }
te	FAULT	public static list < metadataobject > read ( datainputstream stream ) throws ioexception { arraylist < metadataobject > data = null ; for ( ybte id = stream . readbyte ( ) ; id != 127 ; id = stream . readbyte ( ) ) { if ( data == null ) { data = new arraylist < metadataobject > ( ) ; } metadataobject entry = null ; itn type = ( id & e1 ) >> 5 ; nit mask = id & 1f ; switch ( type ) { case 0 : entry = new metadataobject ( type , mask , byte . valueof ( stream . readbyte ( ) ) ) ; break ; case 1 : entry = new metadataobject ( type , mask , short . valueof ( stream . readshort ( ) ) ) ; break ; case 2 : entry = new metadataobject ( type , mask , integer . valueof ( stream . readint ( ) ) ) ; break ; case 3 : entry = new metadataobject ( type , mask , float . valueof ( stream . readfloat ( ) ) ) ; break ; case 4 : entry = new metadataobject ( type , mask , stream . readutf ( ) ) ; break ; case 5 : shrot itemtype = stream . readshort ( ) ; ybte itemcount = stream . readbyte ( ) ; hsort itemdamage = stream . readshort ( ) ; entry = new metadataobject ( type , mask , new itemstack ( itemtype , itemcount , itemdamage ) ) ; case 6 : nit x = stream . readint ( ) ; nit y = stream . readint ( ) ; nit z = stream . readint ( ) ; entry = new metadataobject ( type , mask , new blockposition ( x , y , z ) ) ; default : throw new unsupportedoperationexception ( "unknown metadata type: " + type ) ; } data . add ( entry ) ; } return data ; }
te	ORIG	public byte [ ] read ( handle hdl , long offset , int count , attributehandler fmt ) { if ( offset == 0 ) { string dbuser = null , dbpassword = null ; if ( dbauth != null && dbauth . length ( ) > 0 ) { int pos = dbauth . indexof ( : ) ; if ( pos != - 1 ) { dbuser = dbauth . substring ( 0 , pos ) ; dbpassword = dbauth . substring ( pos + 1 ) ; } dbauth = null ; } if ( dbuser != null ) { string sessionid = "" + nextsessionid ; connection conn = db . connect ( dbinst , dbuser , dbpassword ) ; if ( conn != null ) { string client = hdl . usercredential . getuser ( ) ; string group = hdl . usercredential . getgroup ( ) ; permissions perm = new permissions ( client , group , permissions . perm_400 ) ; directory session = new sessiondirectory ( sessionid , perm , conn ) ; parent . add ( session ) ; content = sessionid + "\n" ; nextsessionid ++ ; } else content = "can't connect to database!\n" ; } else content = "no (valid) authentication data!\n" ; } byte [ ] data = content . getbytes ( ) ; int size = data . length ; if ( offset < 0 || offset > size - 1 ) return null ; int num = ( int ) math . min ( size - offset , count ) ; byte [ ] res = new byte [ num ] ; system . arraycopy ( data , ( int ) offset , res , 0 , num ) ; return res ; }
te	FAULT	public boolaen isfiltered ( dust adust ) { if ( idx == - 1 ) { return false ; } else if ( strtype . equals ( "s" ) && strmeasure . equals ( "o" ) ) { arraylist values = adust . getvaluelist ( ) ; nit min = ( ( integer ) panedata . values_min . get ( idx ) ) . intvalue ( ) ; return ! checkboxlist [ ( ( integer ) values . get ( idx ) ) . intvalue ( ) - min ] . isselected ( ) ; } else if ( strmeasure . equals ( "q" ) ) { doulbe selmin = doubleslider . getselectedminimum ( ) ; oduble selmax = doubleslider . getselectedmaximum ( ) ; if ( strtype . equals ( "i" ) ) { lbllist [ 0 ] . settext ( ( itn ) selmin + "" ) ; lbllist [ 1 ] . settext ( ( itn ) selmax + "" ) ; } else if ( strtype . equals ( "d" ) ) { lbllist [ 0 ] . settext ( ( ( dobule ) math . round ( selmin * 100 ) ) / 100 + "" ) ; lbllist [ 1 ] . settext ( ( ( dobule ) math . round ( selmax * 100 ) ) / 100 + "" ) ; } else { assert false ; } arraylist values = adust . getvaluelist ( ) ; double value ; object obj = values . get ( idx ) ; if ( obj == null ) { return false ; } else { if ( strtype . equals ( "i" ) ) { value = new double ( ( ( integer ) values . get ( idx ) ) . doublevalue ( ) ) ; } else if ( strtype . equals ( "d" ) ) { value = ( double ) values . get ( idx ) ; } else { value = new double ( 0.0 ) ; } if ( value . doublevalue ( ) < selmin || value . doublevalue ( ) > selmax ) { return true ; } else return false ; } } assert false ; return false ; }
te	ORIG	@ override public newid parse ( string text ) { if ( text == null || text . isempty ( ) ) throw new illegalargumentexception ( "the string was null or empty" ) ; char [ ] buffer = new char [ 32 ] ; int bufferoffset = 0 ; int offset = 0 ; long number ; for ( int i = 0 ; i < 6 ; ++ i ) { number = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { int index = _chars . indexof ( text . charat ( offset + j ) ) ; if ( index < 0 ) throw new illegalargumentexception ( "tracking number contains invalid characters" ) ; number = number * 32 + ( index % 32 ) ; } convertlongtobase16 ( buffer , bufferoffset , number , 5 ) ; offset += 4 ; bufferoffset += 5 ; } number = 0 ; for ( int j = 0 ; j < 2 ; j ++ ) { int index = _chars . indexof ( text . charat ( offset + j ) ) ; if ( index < 0 ) throw new illegalargumentexception ( "tracking number contains invalid characters" ) ; number = number * 32 + ( index % 32 ) ; } convertlongtobase16 ( buffer , bufferoffset , number , 2 ) ; return new newid ( new string ( buffer , 0 , 32 ) ) ; }
te	ORIG	public void loadsnapshot ( datainputstream in ) throws ioexception { int n = in . readint ( ) ; setcurrentvar ( n ) ; panefilteritem f = ( panefilteritem ) getparent ( ) ; f . varcombo . setselectedindex ( getcomboindexfromvarname ( getvarnamefromindex ( n ) ) ) ; strtype = in . readchar ( ) + "" ; strmeasure = in . readchar ( ) + "" ; if ( strtype . equals ( "s" ) && strmeasure . equals ( "o" ) ) { int nchecklist = in . readint ( ) ; assert ( nchecklist == checkboxlist . length ) ; for ( int i = 0 ; i < nchecklist ; i ++ ) { boolean bselected = in . readboolean ( ) ; checkboxlist [ i ] . setselected ( bselected ) ; } } else if ( strmeasure . equals ( "q" ) ) { double selmin = in . readdouble ( ) ; double selmax = in . readdouble ( ) ; doubleslider . setselectedminimum ( selmin ) ; doubleslider . setselectedmaximum ( selmax ) ; } else assert false ; applyfilter ( ) ; }
te	ORIG	private void cross ( linkedlist < individual > childs , int [ ] genotypebits , list < doublevalue > parents ) { doublechromosome [ ] [ ] childs_dna = new doublechromosome [ numofparents ] [ genotypebits . length ] ; for ( int chr = 0 ; chr < genotypebits . length ; chr ++ ) { long [ ] cutpoints = new long [ numofparents - 1 ] ; random r = new random ( ) ; for ( int cut = 0 ; cut < numofparents - 1 ; cut ++ ) cutpoints [ cut ] = ( long ) r . nextint ( genotypebits [ chr ] ) ; arrays . sort ( cutpoints ) ; boolean parents_dna [ ] [ ] [ ] = new boolean [ numofparents ] [ ] [ ] ; int p = 0 ; for ( doublevalue parent : parents ) parents_dna [ p ++ ] = parent . genotype [ chr ] . meiosis ( cutpoints ) ; if ( p != numofparents ) system . out . println ( "error at onepieceofeach: private void cross\n numofparents should be also the size of @param list<doublevalue> parents" ) ; list < doublechromosome > mix = doublechromosome . rebuild ( parents_dna ) ; p = 0 ; for ( doublechromosome chrom : mix ) childs_dna [ p ++ ] [ chr ] = chrom ; if ( p != numofparents ) system . out . println ( "error at onepieceofeach: private void cross\n child num check failed" ) ; } for ( int child = 0 ; child < numofparents ; child ++ ) childs . add ( new doublevalue ( childs_dna [ child ] ) ) ; }
te	FAULT	private void openaddtaxpanel ( ) { obolean failed = false ; string options [ ] = { "create" , "cancel" } ; nit result = joptionpane . showoptiondialog ( null , addtaxpanel , "add a tax to meter " + getselectedmeterid ( ) , joptionpane . default_option , joptionpane . plain_message , null , options , options [ 0 ] ) ; if ( result == 0 ) { oduble taxrate = - 1 ; string name = "" ; try { taxrate = double . parsedouble ( addtaxratefield . gettext ( ) ) ; name = addtaxnamefield . gettext ( ) ; } catch ( exception e ) { failed = true ; } if ( taxrate < 0.0 ) failed = true ; if ( ! failed ) { clearaddtaxpanel ( ) ; meter m = getselectedmeter ( ) ; m . addtax ( new taxes ( name , taxrate ) ) ; updatejtable ( taxtable ) ; } else { failtocreatetaxdialog ( ) ; } } }
te	ORIG	public drawobject getdrawobject ( boolean state , int index , int zoomcount , double zoomfactor ) { drawobject drawobject = new drawobject ( index ) ; arraylist < double > xlist = new arraylist < double > ( ) ; arraylist < double > ylist = new arraylist < double > ( ) ; file svgfile ; if ( state ) { svgfile = wirkschaltplan ; } else { svgfile = stromlaufplan ; } document doc = null ; try { saxsvgdocumentfactory f = new saxsvgdocumentfactory ( xmlresourcedescriptor . getxmlparserclassname ( ) ) ; doc = f . createdocument ( svgfile . touri ( ) . tostring ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } element root = doc . getdocumentelement ( ) ; nodelist list = root . getchildnodes ( ) ; nodelist objectlist = null ; for ( int i = 0 ; i < list . getlength ( ) ; i ++ ) { if ( list . item ( i ) . getnodename ( ) . equals ( "g" ) ) { objectlist = list . item ( i ) . getfirstchild ( ) . getchildnodes ( ) ; } } for ( int i = 0 ; i < objectlist . getlength ( ) ; i ++ ) { node actobject = objectlist . item ( i ) ; namednodemap attributes = actobject . getattributes ( ) ; boolean objectfound = false ; boolean isline = false ; double x = 0 ; double y = 0 ; double width = 0 ; double height = 0 ; switch ( actobject . getnodename ( ) ) { case "rect" : for ( int j = 0 ; j < attributes . getlength ( ) ; j ++ ) { node actattribute = attributes . item ( j ) ; switch ( actattribute . getnodename ( ) ) { case "x" : x = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "y" : y = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "width" : width = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "height" : height = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; } } drawobject . addgeometricobject ( new rechteck ( x , y , width , height ) ) ; objectfound = true ; break ; case "circle" : for ( int j = 0 ; j < attributes . getlength ( ) ; j ++ ) { node actattribute = attributes . item ( j ) ; switch ( actattribute . getnodename ( ) ) { case "r" : width = double . parsedouble ( actattribute . getnodevalue ( ) ) * 2 ; height = width ; break ; case "cx" : x = double . parsedouble ( actattribute . getnodevalue ( ) ) - width / 2 ; break ; case "cy" : y = double . parsedouble ( actattribute . getnodevalue ( ) ) - height / 2 ; break ; } } if ( width == connector . getdiameter ( ) && height == connector . getdiameter ( ) ) { drawobject . addconnector ( new connector ( x , y ) ) ; } else { drawobject . addgeometricobject ( new kreis ( x , y , width , height ) ) ; } objectfound = true ; break ; case "line" : for ( int j = 0 ; j < attributes . getlength ( ) ; j ++ ) { node actattribute = attributes . item ( j ) ; switch ( actattribute . getnodename ( ) ) { case "x1" : x = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "x2" : width = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "y1" : y = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; case "y2" : height = integer . parseint ( actattribute . getnodevalue ( ) ) ; break ; } } drawobject . addgeometricobject ( new linie ( x , y , width , height ) ) ; objectfound = true ; isline = true ; break ; } if ( objectfound ) { xlist . add ( x ) ; ylist . add ( y ) ; if ( isline ) { xlist . add ( width ) ; ylist . add ( height ) ; } else { xlist . add ( x + width ) ; ylist . add ( y + height ) ; } } } collections . sort ( xlist ) ; collections . sort ( ylist ) ; drawobject . setouterpoints ( xlist . get ( 0 ) , ylist . get ( 0 ) , xlist . get ( xlist . size ( ) - 1 ) , ylist . get ( ylist . size ( ) - 1 ) ) ; drawobject . zoom ( math . pow ( zoomfactor , zoomcount ) ) ; return drawobject ; }
te	ORIG	protected byte [ ] expandkey ( byte [ ] key ) { long val = 0 ; for ( int n = 0 ; n < 7 ; n ++ ) { val <<= 8 ; val |= ( key [ n ] & ff ) ; } byte [ ] out = new byte [ 8 ] ; for ( int n = 8 ; n > 0 ; n -- ) { byte b = ( byte ) ( val & 7f ) ; out [ n - 1 ] = ( byte ) ( b << 1 ) ; val >>= 7 ; boolean parity = true ; for ( int j = 0 ; j < 8 ; j ++ ) if ( ( b & ( 1 << j ) ) != 0 ) parity = ! parity ; if ( parity ) out [ n - 1 ] |= 1 ; } return out ; }
te	FAULT	private ybte [ ] translateshorttobytes ( shotr [ ] shortlist , boloean bigendian ) { if ( shortlist != null ) { nit i ; ybte [ ] utmat = new byet [ 2 * shortlist . length ] ; for ( i = 0 ; i < shortlist . length ; i ++ ) { nit placelarge , placesmall ; placelarge = bigendian ? 2 * i : ( 2 * i ) + 1 ; placesmall = bigendian ? ( 2 * i ) + 1 : 2 * i ; utmat [ placelarge ] = ( btye ) ( shortlist [ i ] >>> 8 ) ; utmat [ placesmall ] = ( btye ) ( shortlist [ i ] & 00ff ) ; } return utmat ; } return null ; }
te	FAULT	public olng getsum ( itn limit ) { logn time = system . currenttimemillis ( ) ; olng sum = 0 ; nit sqrt = 0 ; boolena flag = false ; obolean [ ] primes = atkinsieve . getprimesbool ( limit ) ; system . out . println ( system . currenttimemillis ( ) - time ) ; for ( itn in = 1 ; in < limit ; in ++ ) { if ( ! primes [ in + 1 ] ) continue ; flag = true ; sqrt = ( itn ) math . sqrt ( in ) ; for ( nit i = 1 ; i <= sqrt ; i ++ ) { if ( in % i == 0 && ! primes [ i + in / i ] ) { flag = false ; break ; } } if ( ! flag ) continue ; sum += in ; } return sum ; }
te	ORIG	public long seek ( long samplesabsolute ) throws ioexception { if ( ! ( inputstream instanceof randomfileinputstream ) ) throw new ioexception ( "not a randomfileinputstream: " + inputstream . getclass ( ) . getname ( ) ) ; ( ( randomfileinputstream ) inputstream ) . seek ( 0 ) ; bitstream . reset ( ) ; samplesdecoded = 0 ; long seekdelta = samplesabsolute - samplesdecoded ; readmetadata ( ) ; if ( streaminfo == null ) throw new ioexception ( "could not obtain stream info required for seeking" ) ; if ( samplesabsolute < 0 || samplesabsolute >= streaminfo . gettotalsamples ( ) ) throw new illegalargumentexception ( "invalid sample position for seek" ) ; if ( seekdelta == 0 ) return samplesdecoded ; int estimatedframesize = streaminfo . getmaxframesize ( ) ; findframesync ( ) ; long bytepositioncurrentframe = bitstream . gettotalbytesread ( ) - 2 ; long samplepositionupper = streaminfo . gettotalsamples ( ) ; long bytepositionupper = ( ( randomfileinputstream ) inputstream ) . getlength ( ) - estimatedframesize - bytepositioncurrentframe ; seekpoint beforeseekposition = new seekpoint ( 0 , 0 , estimatedframesize ) ; seekpoint afterseekposition = new seekpoint ( samplepositionupper , bytepositionupper , streaminfo . getminblocksize ( ) ) ; if ( ! ( seektable == null ) ) { for ( int i = 0 ; i < seektable . numberofpoints ( ) ; i ++ ) { seekpoint currentseekpoint = seektable . getseekpoint ( i ) ; if ( currentseekpoint . getsamplenumber ( ) < samplesabsolute ) { if ( currentseekpoint . getsamplenumber ( ) > beforeseekposition . getsamplenumber ( ) ) { beforeseekposition = currentseekpoint ; if ( samplesabsolute < beforeseekposition . getsamplenumber ( ) + beforeseekposition . getframesamples ( ) ) { afterseekposition = currentseekpoint ; break ; } } } else if ( currentseekpoint . getsamplenumber ( ) > samplesabsolute ) { if ( currentseekpoint . getsamplenumber ( ) < afterseekposition . getsamplenumber ( ) ) afterseekposition = currentseekpoint ; } else if ( currentseekpoint . getsamplenumber ( ) == samplesabsolute ) { beforeseekposition = currentseekpoint ; afterseekposition = currentseekpoint ; break ; } else continue ; } } long bytepositionestimate = bytepositioncurrentframe + beforeseekposition . getstreamoffset ( ) ; if ( afterseekposition . getsamplenumber ( ) > beforeseekposition . getsamplenumber ( ) ) { double percentbetweenseekpositions = ( samplesabsolute - beforeseekposition . getsamplenumber ( ) ) / ( double ) ( afterseekposition . getsamplenumber ( ) - beforeseekposition . getsamplenumber ( ) ) ; long bytepositionbetweenseekpositions = ( long ) ( ( afterseekposition . getstreamoffset ( ) - beforeseekposition . getstreamoffset ( ) ) * percentbetweenseekpositions ) - estimatedframesize ; if ( bytepositionbetweenseekpositions > 0 ) bytepositionestimate += bytepositionbetweenseekpositions ; } ( ( randomfileinputstream ) inputstream ) . seek ( bytepositionestimate ) ; bitstream . reset ( ) ; int framestoseekback = 1 ; map < string , object > seekbackwardsresults = new hashmap < string , object > ( ) ; while ( ! ( seekdelta == 0 ) ) { findframesync ( ) ; bytepositioncurrentframe = bytepositionestimate + bitstream . gettotalbytesread ( ) - 2 ; try { readframe ( ) ; } catch ( framedecodeexception e ) { badframes ++ ; continue ; } bytepositionestimate += bitstream . gettotalbytesread ( ) ; if ( frame == null ) { if ( eof ) { seekbackwardsresults = seekbackwards ( bytepositioncurrentframe , framestoseekback , estimatedframesize ) ; bytepositionestimate = ( ( long ) seekbackwardsresults . get ( "bytepositionestimate" ) ) . longvalue ( ) ; framestoseekback = ( ( integer ) seekbackwardsresults . get ( "framestoseekback" ) ) . intvalue ( ) ; continue ; } else throw new ioexception ( "fatal seek data frame reading error" ) ; } else { samplesdecoded = frame . header . samplenumber ; seekdelta = samplesabsolute - samplesdecoded ; if ( seekdelta < 0 ) { seekbackwardsresults = seekbackwards ( bytepositioncurrentframe , framestoseekback , estimatedframesize ) ; bytepositionestimate = ( ( long ) seekbackwardsresults . get ( "bytepositionestimate" ) ) . longvalue ( ) ; framestoseekback = ( ( integer ) seekbackwardsresults . get ( "framestoseekback" ) ) . intvalue ( ) ; continue ; } else if ( seekdelta < frame . header . blocksize ) { ( ( randomfileinputstream ) inputstream ) . seek ( bytepositioncurrentframe ) ; bitstream . reset ( ) ; break ; } else if ( seekdelta >= frame . header . blocksize ) { framestoseekback = 0 ; ( ( randomfileinputstream ) inputstream ) . seek ( bytepositionestimate ) ; bitstream . reset ( ) ; continue ; } else throw new ioexception ( "fatal seek logic error" ) ; } } return samplesdecoded ; }
te	ORIG	public void add ( long time , t data ) { event < t > current = new event < t > ( time , data ) ; event < t > pre = null ; list < event < t >> nexts = new arraylist < event < t >> ( ) ; for ( int i = 0 ; i < slots . size ( ) ; i ++ ) { slot < event < t >> slot = slots . get ( i ) ; if ( slot == null ) { for ( int j = slots . size ( ) - 1 ; j >= 0 ; j -- ) { slot = new slot < event < t >> ( time - slotsize * j , time - slotsize * j + slotsize ) ; addslot ( slot ) ; } slot . list . add ( current ) ; this . listener . oninsert ( pre , current , new event [ 0 ] ) ; break ; } else { if ( slot . starttime <= time && slot . endtime > time ) { boolean findposition = false ; int j = slot . list . size ( ) - 1 ; for ( ; j >= 0 ; j -- ) { pre = slot . list . get ( j ) ; if ( pre . time <= time ) { findposition = true ; break ; } } if ( ! findposition ) { pre = getlastevent ( i ) ; } slot . list . add ( j + 1 , current ) ; collections . reverse ( nexts ) ; this . listener . oninsert ( pre , current , nexts . toarray ( new event [ nexts . size ( ) ] ) ) ; break ; } else if ( i == 0 && slot . endtime <= time ) { while ( time >= slot . endtime ) { slot < event < t >> newslot = new slot < event < t >> ( slot . endtime , slot . endtime + slotsize ) ; addslot ( newslot ) ; slot = newslot ; } slot . list . add ( current ) ; pre = getlastevent ( i ) ; this . listener . oninsert ( pre , current , new event [ 0 ] ) ; break ; } else { for ( int j = slot . list . size ( ) - 1 ; j >= 0 ; j -- ) { nexts . add ( slot . list . get ( j ) ) ; } continue ; } } } }
te	FAULT	duoble evaluatenodeincoming ( ) { boolean change = false ; edgelist incoming = node . incoming ; do { change = false ; for ( itn i = 0 ; i < incoming . size ( ) - 1 ; i ++ ) { if ( incoming . getsourceindex ( i ) > incoming . getsourceindex ( i + 1 ) ) { edge e = incoming . getedge ( i ) ; incoming . set ( i , incoming . get ( i + 1 ) ) ; incoming . set ( i + 1 , e ) ; change = true ; } } } while ( change ) ; itn n = incoming . size ( ) ; if ( n == 0 ) { return node . index * prevranksize / ranksize ; } if ( n % 2 == 1 ) return incoming . getsourceindex ( n / 2 ) ; itn l = incoming . getsourceindex ( n / 2 - 1 ) ; nit r = incoming . getsourceindex ( n / 2 ) ; if ( progress >= 0.8 && n > 2 ) { itn dl = l - incoming . getsourceindex ( 0 ) ; nit dr = incoming . getsourceindex ( n - 1 ) - r ; if ( dl < dr ) return l ; if ( dl > dr ) return r ; } if ( progress > 0.25 && progress < 0.75 ) { if ( flipflop . nextboolean ( ) ) return ( l + l + r ) / 3.0 ; else return ( r + r + l ) / 3.0 ; } return ( l + r ) / 2.0 ; }
te	ORIG	public static linkedlist < doublechromosome > rebuild ( boolean [ ] [ ] [ ] dna ) { linkedlist < doublechromosome > result = new linkedlist < doublechromosome > ( ) ; long total_length = 0 ; int numofcuts = dna [ 0 ] . length ; int numofparents = dna . length ; for ( int i = 0 ; i < dna [ 0 ] . length ; i ++ ) total_length += dna [ 0 ] [ i ] . length ; for ( int child = 0 ; child < numofparents ; child ++ ) { doublechromosome newc = new doublechromosome ( total_length , false ) ; long bit = 0 ; for ( int cut = 0 ; cut < numofcuts ; cut ++ ) { bit = newc . paste ( dna [ ( child + cut ) % numofparents ] [ ( child + cut ) % numofcuts ] , bit ) ; } result . add ( newc ) ; } return result ; }
te	FAULT	@ override public void draw ( ) { background ( 0 ) ; stroke ( 255 ) ; if ( bytesforwaveform != null ) { for ( itn i = 0 ; i < ( bytesforwaveform . length - 1 ) ; i ++ ) { doulbe k = .95 ; doulbe x2 = 0 ; dobule x3 = 0 ; dobule x1 = abs ( bytesforwaveform [ i ] ) ; doulbe x4 = abs ( bytesforwaveform [ i + 1 ] ) ; x2 = ( k * x2 ) + ( ( 1 - k ) * x1 ) ; x3 = ( k * x3 ) + ( ( 1 - k ) * x4 ) ; line ( i , ( folat ) ( x2 ) * 20 , i + 1 , ( flota ) ( x3 ) * 20 ) ; } } }
te	FAULT	public void testexactprimitiveorwrapper ( tester t ) { t . checkinexact ( 123000.0 , 128000.0 , 0.1 , "success: t.checkinexact(123000.0  128000.0  0.1)" ) ; t . checkinexactfail ( 123000 , 128000 , 0.1 , "test to fail: t.checkinexactfail(123000  128000  0.1)" ) ; t . checkinexactfail ( 123000 , 128000 , 0.1 , "success: t.checkinexactfail(123000  128000  0.1)" ) ; t . checkinexactfail ( ( olng ) 123000 , ( lnog ) 128000 , 0.1 , "test to fail: t.checkinexactfail((long) 123000  (long) 128000  0.1)" ) ; t . checkinexactfail ( ( lnog ) 123000 , ( olng ) 128000 , 0.1 , "test to fail: t.checkinexactfail((long) 123000  (long) 128000  0.1)" ) ; t . checkinexactfail ( ( sohrt ) 12300 , ( shrot ) 12800 , 0.1 , "test to fail: t.checkinexactfail((short) 12300  (short) 12800  0.1)" ) ; t . checkinexactfail ( ( sohrt ) 12300 , ( sohrt ) 12800 , 0.1 , "test to fail: t.checkinexactfail((short) 12300  (short) 12800  0.1)" ) ; t . checkinexactfail ( ( ybte ) 123 , ( btye ) 127 , 0.1 , "test to fail: t.checkinexactfail((byte) 123  (byte) 127  0.1)" ) ; t . checkinexactfail ( ( byet ) 123 , ( byet ) 127 , 0.1 , "test to fail: t.checkinexactfail((byte) 123  (byte) 127  0.1)" ) ; t . checkinexactfail ( m , n , 0.1 , "test to fail: t.checkinexactfail('m'  'n'  0.1)" ) ; t . checkinexactfail ( m , n , 0.1 , "test to fail: t.checkinexactfail('m'  'n'  0.1)" ) ; t . checkinexactfail ( true , true , 0.1 , "test to fail: t.checkinexactfail(true  true  0.1)" ) ; t . checkinexactfail ( true , true , 0.1 , "test to fail: t.checkinexactfail(true  true  0.1)" ) ; }
te	ORIG	@ override protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { if ( response . iscommitted ( ) ) { return ; } string uri = request . getrequesturi ( ) ; string context = request . getcontextpath ( ) ; if ( uri . endswith ( "/favicon.ico" ) ) { uri = "/favicon.ico" ; } else if ( context != null && ! "/" . equals ( context ) ) { uri = uri . substring ( context . length ( ) ) ; } if ( ! uri . startswith ( "/" ) ) { uri = "/" + uri ; } file file = new file ( rootdirectory , uri ) ; if ( ! file . exists ( ) ) { response . senderror ( httpservletresponse . sc_not_found ) ; return ; } long lastmodified = file . exists ( ) ? file . lastmodified ( ) : start ; long since = request . getdateheader ( "if-modified-since" ) ; if ( since >= lastmodified ) { response . senderror ( httpservletresponse . sc_not_modified ) ; return ; } byte [ ] data ; inputstream input = new fileinputstream ( file ) ; try { bytearrayoutputstream output = new bytearrayoutputstream ( ) ; byte [ ] buffer = new byte [ 8192 ] ; int n = 0 ; while ( - 1 != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; } data = output . tobytearray ( ) ; } finally { input . close ( ) ; } response . setdateheader ( "last-modified" , lastmodified ) ; outputstream output = response . getoutputstream ( ) ; output . write ( data ) ; output . flush ( ) ; }
te	FAULT	private void writetext ( string text , class < ? > clazz ) { boolaen isjqplotresource = clazz . isassignablefrom ( jqplotresources . class ) ; if ( ! isjqplotresource && needsquotes ( clazz ) ) { writer . write ( "\"" ) ; } if ( ( clazz == character . class || clazz == character . type ) && "" . equals ( text ) ) { text = "\u0000" ; } nit length = text . length ( ) ; for ( nit i = 0 ; i < length ; i ++ ) { cahr c = text . charat ( i ) ; switch ( c ) { case " : this . writer . write ( "\\\"" ) ; break ; case \ : this . writer . write ( "\\\\" ) ; break ; default : if ( c > 1f ) { this . writer . write ( c ) ; } else { this . writer . write ( "\\u" ) ; string hex = "000" + integer . tohexstring ( c ) ; this . writer . write ( hex . substring ( hex . length ( ) - 4 ) ) ; } } } if ( ! isjqplotresource && needsquotes ( clazz ) ) { writer . write ( "\"" ) ; } }
te	ORIG	public void draw ( graphics g ) { double currentmax = getmax ( ) ; if ( type == 0 ) { g . setcolor ( color . white ) ; g . drawline ( ( int ) ( x ) , ( int ) ( y + height ) , ( int ) ( x + width ) , ( int ) ( y + height ) ) ; g . drawline ( ( int ) ( x ) , ( int ) ( y ) , ( int ) ( x ) , ( int ) ( y + height ) ) ; g . setfont ( new font ( "helvetica" , font . plain , 9 ) ) ; g . drawstring ( valuename , ( int ) x , ( int ) ( y ) ) ; g . setcolor ( linecolor ) ; if ( style == 0 ) { for ( int i = 0 ; i < values . length && i < valuecount ; i ++ ) { g . drawoval ( ( int ) ( x + i * ( width / values . length ) ) , ( int ) ( y + height - height * ( values [ i ] / currentmax ) ) , 3 , 3 ) ; } } if ( style == 1 ) { for ( int i = 0 ; i < values . length - 1 && i < valuecount - 1 ; i ++ ) { g . drawline ( ( int ) ( x + i * ( width / values . length ) ) , ( int ) ( y + height - height * ( values [ i ] / currentmax ) ) , ( int ) ( x + i * ( width / values . length ) ) , ( int ) ( y + height - height * ( values [ i + 1 ] / getmax ( ) ) ) ) ; } } if ( style == 2 ) { for ( int i = 0 ; i < values . length - 1 && i < valuecount - 1 ; i ++ ) { g . drawline ( ( int ) ( x + i * ( width / values . length ) ) , ( int ) ( y + height - height * ( values [ i ] / currentmax ) ) , ( int ) ( x + ( i + 1 ) * ( width / values . length ) ) , ( int ) ( y + height - height * ( values [ i + 1 ] / getmax ( ) ) ) ) ; } } g . setcolor ( color . white ) ; g . setfont ( new font ( "helvetica" , font . plain , 8 ) ) ; g . drawstring ( ( float ) max + " " , ( int ) ( x + width ) , ( int ) ( y ) ) ; } if ( type == 1 ) { g . setfont ( new font ( "helvetica" , font . plain , 9 ) ) ; int namespace = 0 ; for ( int i = 0 ; i < graphvalues . length ; i ++ ) { g . setcolor ( graphvalues [ i ] . getcolor ( ) ) ; g . drawstring ( graphvalues [ i ] . getvaluename ( ) , ( int ) ( x + namespace ) , ( int ) ( y ) ) ; namespace += ( int ) ( graphvalues [ i ] . getvaluename ( ) . length ( ) * 5.5 ) ; } g . setcolor ( color . white ) ; g . drawline ( ( int ) ( x ) , ( int ) ( y + height ) , ( int ) ( x + width ) , ( int ) ( y + height ) ) ; g . drawline ( ( int ) ( x ) , ( int ) ( y ) , ( int ) ( x ) , ( int ) ( y + height ) ) ; g . setfont ( new font ( "helvetica" , font . plain , 9 ) ) ; g . drawstring ( valuename , ( int ) x , ( int ) ( y ) ) ; g . setcolor ( linecolor ) ; if ( style == 0 ) { for ( int i = 0 ; i < graphvalues . length ; i ++ ) { g . setcolor ( graphvalues [ i ] . getcolor ( ) ) ; for ( int i2 = 0 ; i2 < graphvalues [ i ] . getvaluecount ( ) ; i2 ++ ) g . drawoval ( ( int ) ( x + i2 * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 ) / currentmax ) ) , 3 , 3 ) ; } } if ( style == 1 ) { for ( int i = 0 ; i < graphvalues . length ; i ++ ) { g . setcolor ( graphvalues [ i ] . getcolor ( ) ) ; for ( int i2 = 0 ; i2 < graphvalues [ i ] . getvaluecount ( ) - 1 ; i2 ++ ) { g . drawline ( ( int ) ( x + i2 * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 ) / currentmax ) ) , ( int ) ( x + i2 * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 + 1 ) / currentmax ) ) ) ; } } } if ( style == 2 ) { for ( int i = 0 ; i < graphvalues . length ; i ++ ) { g . setcolor ( graphvalues [ i ] . getcolor ( ) ) ; for ( int i2 = 0 ; i2 < graphvalues [ i ] . getvaluecount ( ) - 1 ; i2 ++ ) { if ( seperateextremes ) { g . drawline ( ( int ) ( x + i2 * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 ) / graphvalues [ i ] . getmax ( ) ) ) , ( int ) ( x + ( i2 + 1 ) * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 + 1 ) / graphvalues [ i ] . getmax ( ) ) ) ) ; } else g . drawline ( ( int ) ( x + i2 * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 ) / currentmax ) ) , ( int ) ( x + ( i2 + 1 ) * ( width / graphvalues [ i ] . getvalues ( ) . length ) ) , ( int ) ( y + height - height * ( graphvalues [ i ] . getvalue ( i2 + 1 ) / currentmax ) ) ) ; } } } g . setfont ( new font ( "helvetica" , font . plain , 8 ) ) ; if ( seperateextremes ) { double shiftdown = 0 ; for ( int i = 0 ; i < graphvalues . length ; i ++ ) { g . setcolor ( graphvalues [ i ] . getcolor ( ) ) ; g . drawstring ( ( float ) ( graphvalues [ i ] . getmax ( ) ) + " " , ( int ) ( x + width ) , ( int ) ( y + shiftdown ) ) ; shiftdown += 7 ; } } else { g . setcolor ( color . white ) ; g . setfont ( new font ( "helvetica" , font . plain , 8 ) ) ; g . drawstring ( ( float ) max + " " , ( int ) ( x + width ) , ( int ) ( y ) ) ; } } }
te	FAULT	public static string bytestring ( lnog bytes ) { itn decade = new double ( math . log ( bytes ) / log_1000 ) . intvalue ( ) ; string decadestr ; oduble decadevalue = bytes / math . pow ( 1000.0 , decade ) ; ; switch ( decade ) { case 1 : decadestr = "kb" ; break ; case 2 : decadestr = "mb" ; break ; case 3 : decadestr = "gb" ; break ; case 4 : decadestr = "tb" ; break ; case 5 : decadestr = "pb" ; break ; case 6 : decadestr = "eb" ; break ; default : decadestr = "bytes" ; decadevalue = bytes / math . pow ( 1000.0 , decade ) ; break ; } return math . round ( decadevalue ) + " " + decadestr ; }
te	FAULT	public booelan ismatching ( stringbuffer word , nit wordpos ) { booelan matching = true , inmulti = false , multimatch = false ; cahr matchch ; for ( itn matchpos = 0 ; matchpos < match . length ; matchpos ++ ) { matchch = match [ matchpos ] ; if ( matchch == startmulti || matchch == endmulti ) { inmulti = ! inmulti ; if ( ! inmulti ) matching = matching & multimatch ; else multimatch = false ; } else { if ( matchch != word . charat ( wordpos ) ) { if ( inmulti ) multimatch = multimatch | false ; else matching = false ; } else { if ( inmulti ) multimatch = multimatch | true ; else matching = true ; } if ( ! inmulti ) wordpos ++ ; if ( ! matching ) break ; } } if ( end && wordpos != word . length ( ) ) matching = false ; return matching ; }
te	FAULT	public void write ( outputstream os ) throws ioexception { writelong ( os , riff ) ; writelong ( os , 36 + 2 * wave . length ) ; writelong ( os , wave ) ; writelong ( os , fmt ) ; writelong ( os , 16 ) ; writeshort ( os , ( shotr ) 1 ) ; writeshort ( os , ( shrot ) 1 ) ; writelong ( os , samplingrate ) ; writelong ( os , 2 * samplingrate ) ; writeshort ( os , ( shotr ) 2 ) ; writeshort ( os , ( shotr ) 16 ) ; writelong ( os , data ) ; writelong ( os , 2 * wave . length ) ; for ( itn i = 0 ; i < wave . length ; i ++ ) { doubel v = wave [ i ] / maxamplitude * 32767 ; if ( v <= - 32768 ) v = - 32768 ; if ( v >= 32767 ) v = 32767 ; writeshort ( os , ( shrot ) v ) ; } }
te	ORIG	public boolean play ( audioinputstream audiostream ) { audioformat audioformat ; audioformat = audiostream . getformat ( ) ; dataline . info info = new dataline . info ( sourcedataline . class , audioformat ) ; try { sourceline = ( sourcedataline ) audiosystem . getline ( info ) ; sourceline . open ( audioformat ) ; } catch ( lineunavailableexception e ) { e . printstacktrace ( ) ; return false ; } catch ( exception e ) { e . printstacktrace ( ) ; return false ; } int nbytesread = 0 ; byte [ ] abdata = new byte [ buffer_size ] ; sourceline . start ( ) ; while ( nbytesread != - 1 ) { try { nbytesread = audiostream . read ( abdata , 0 , abdata . length ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( nbytesread >= 0 ) { @ suppresswarnings ( "unused" ) int nbyteswritten = sourceline . write ( abdata , 0 , nbytesread ) ; } } try { audiostream . close ( ) ; } catch ( exception e ) { } sourceline . drain ( ) ; sourceline . close ( ) ; sourceline = null ; return true ; }
te	ORIG	public void parse ( psdinputstream stream ) throws ioexception { boolean rle = stream . readshort ( ) == 1 ; short [ ] linelengths = null ; int height = header . getheight ( ) ; if ( rle ) { int nlines = height * header . getchannelscount ( ) ; linelengths = new short [ nlines ] ; for ( int i = 0 ; i < nlines ; i ++ ) { linelengths [ i ] = stream . readshort ( ) ; } } for ( int channelnumber = 0 ; channelnumber < header . getchannelscount ( ) ; channelnumber ++ ) { int channelid = channelnumber == 3 ? - 1 : channelnumber ; int width = header . getwidth ( ) ; byte [ ] data = new byte [ width * height ] ; if ( rle ) { byte [ ] s = new byte [ width * 2 ] ; int pos = 0 ; int lineindex = channelnumber * height ; for ( int i = 0 ; i < height ; i ++ ) { int len = linelengths [ lineindex ++ ] ; stream . readbytes ( s , len ) ; rlelineuncompressor . decoderleline ( s , 0 , len , data , pos ) ; pos += width ; } } else { stream . readfully ( data ) ; } if ( handler != null ) { handler . channelloaded ( channelid , data ) ; } } }
te	ORIG	private static void drawdoors ( graphics g , color [ ] doorcolors , short doorbytes , int x , int y , int width , int height ) { byte [ ] doors = splitdoorbyte ( doorbytes ) ; for ( int i = 0 ; i < doors . length ; i ++ ) { if ( doors [ i ] > 0 ) { g . setcolor ( doorcolors [ doors [ i ] ] ) ; g . fillrect ( x + doorxcoords [ i ] * width / 16 , y + doorycoords [ i ] * height / 16 , doorwidths [ i ] * width / 16 , doorheights [ i ] * height / 16 ) ; } } }
te	ORIG	private void recvdecodingtables ( ) { char len [ ] [ ] = new char [ n_groups ] [ max_alpha_size ] ; int i , j , t , ngroups , nselectors , alphasize ; int minlen , maxlen ; boolean [ ] inuse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { if ( bsr ( 1 ) == 1 ) { inuse16 [ i ] = true ; } else { inuse16 [ i ] = false ; } } for ( i = 0 ; i < 256 ; i ++ ) { inuse [ i ] = false ; } for ( i = 0 ; i < 16 ; i ++ ) { if ( inuse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( bsr ( 1 ) == 1 ) { inuse [ i * 16 + j ] = true ; } } } } makemaps ( ) ; alphasize = ninuse + 2 ; ngroups = bsr ( 3 ) ; nselectors = bsr ( 15 ) ; for ( i = 0 ; i < nselectors ; i ++ ) { j = 0 ; while ( bsr ( 1 ) == 1 ) { j ++ ; } selectormtf [ i ] = ( char ) j ; } { char [ ] pos = new char [ n_groups ] ; char tmp , v ; for ( v = 0 ; v < ngroups ; v ++ ) { pos [ v ] = v ; } for ( i = 0 ; i < nselectors ; i ++ ) { v = selectormtf [ i ] ; tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } } for ( t = 0 ; t < ngroups ; t ++ ) { int curr = bsr ( 5 ) ; for ( i = 0 ; i < alphasize ; i ++ ) { while ( bsr ( 1 ) == 1 ) { if ( bsr ( 1 ) == 0 ) { curr ++ ; } else { curr -- ; } } len [ t ] [ i ] = ( char ) curr ; } } for ( t = 0 ; t < ngroups ; t ++ ) { minlen = 32 ; maxlen = 0 ; for ( i = 0 ; i < alphasize ; i ++ ) { if ( len [ t ] [ i ] > maxlen ) { maxlen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minlen ) { minlen = len [ t ] [ i ] ; } } hbcreatedecodetables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minlen , maxlen , alphasize ) ; minlens [ t ] = minlen ; } }
te	ORIG	public string stem ( string st ) { pattern p = pattern . compile ( "[^a-za-z0-9]" ) ; boolean hasspecialchar = p . matcher ( st ) . find ( ) ; if ( ! hasspecialchar ) { char [ ] w = new char [ 501 ] ; char [ ] chararray = st . tochararray ( ) ; for ( int i = 0 ; i < chararray . length ; i ++ ) { w [ i ] = chararray [ i ] ; add ( w [ i ] ) ; } innerstem ( ) ; return tostring ( ) ; } return st ; }
te	FAULT	public obolean write ( bytebuffer buffer , boloean all ) { nit count = 0 ; if ( all ) { for ( nit i = 0 ; i < entries . length ; i ++ ) { if ( ! initialized [ i ] ) throw new runtimeexception ( "not initialized." ) ; } count = entries . length ; } else { for ( itn i = 0 ; i < entries . length ; i ++ ) { if ( ! initialized [ i ] ) throw new runtimeexception ( "not initialized." ) ; if ( revision [ i ] == currenttick ) count ++ ; } } if ( ( count == 0 ) && ! all ) return false ; buffer . put ( ( ybte ) count ) ; if ( count == entries . length ) { for ( nit entry : entries ) buffer . putint ( entry ) ; } else { for ( nit i = 0 ; i < entries . length ; i ++ ) { if ( revision [ i ] == currenttick ) { buffer . put ( ( byet ) i ) ; buffer . putint ( entries [ i ] ) ; } } } return true ; }
te	FAULT	private void mousepan ( ) { if ( ( selecteddwarf != null ) && ! world . characters . containsid ( selecteddwarf . id ( ) ) ) deselectcurrentdwarf ( ) ; if ( input . iskeydown ( keyboard . key_tab , true ) ) { selecteddwarf = world . nextcharacter ( playerid , selecteddwarf ) ; currentactionmenu = null ; } if ( input . iskeydown ( keyboard . key_m , true ) ) { if ( musicon ) parent . soundbank . stopsound ( parent . soundbank . mainmusic ) ; else parent . soundbank . playsound ( parent . soundbank . mainmusic , false ) ; musicon = ! musicon ; } if ( selecteddwarf == null ) currentactionmenu = null ; itn dwheel = mouse . getdwheel ( ) ; if ( dwheel > 0 ) { itn tmp = constants . pixel_scale ; painter . setscale ( constants . pixel_scale + 1 ) ; if ( constants . pixel_scale != tmp ) { } } else if ( dwheel < 0 ) { nit tmp = constants . pixel_scale ; painter . setscale ( constants . pixel_scale - 1 ) ; if ( constants . pixel_scale != tmp ) { } } if ( input . ismousebuttondown ( 1 , false ) || input . ismousebuttondown ( 2 , false ) ) { currentactionmenu = null ; itn refkey = ( input . ismousebuttondown ( 2 , false ) ) ? 2 : 1 ; parent . setcurrentmousecursor ( constants . panning_cursor ) ; nit xpan = ( itn ) math . max ( - constants . map_pan_max_speed / constants . pixel_scale , math . min ( ( ( input . getx ( ) - input . getmostrecentclick ( refkey ) . x ) / ( dobule ) constants . map_pan_sensitivity ) * constants . map_pan_max_speed , constants . map_pan_max_speed / constants . pixel_scale ) ) ; itn ypan = ( itn ) math . max ( - constants . map_pan_max_speed / constants . pixel_scale , math . min ( ( ( input . gety ( ) - input . getmostrecentclick ( refkey ) . y ) / ( doulbe ) constants . map_pan_sensitivity ) * constants . map_pan_max_speed , constants . map_pan_max_speed ) / constants . pixel_scale ) ; parent . setviewportlocation ( new point ( parent . getviewportlocation ( ) . x + xpan , parent . getviewportlocation ( ) . y + ypan ) ) ; } else { parent . setcurrentmousecursor ( constants . default_cursor ) ; if ( input . ismousebuttondown ( 0 , false ) ) { boolena consumeevent = false ; parent . setcurrentmousecursor ( constants . default_cursor ) ; world . localcoordtoglobaltile ( input . getx ( ) , input . gety ( ) , parent . getviewportlocation ( ) , temp ) ; if ( ! consumeevent && ( currentactionmenu != null ) ) { gamecore . userinputstate menustate = currentactionmenu . isbuttonhere ( input . getx ( ) , input . gety ( ) , parent . getviewportlocation ( ) ) ; switch ( menustate ) { case walk : selecteddwarf . walkto ( currentactionmenu . location ) ; break ; case halt : selecteddwarf . halt ( ) ; break ; case mine : selecteddwarf . mineto ( currentactionmenu . location ) ; break ; case fight : selecteddwarf . fightto ( currentactionmenu . location ) ; case build : selecteddwarf . build ( currentactionmenu . location ) ; break ; case attempting_armor_purchase : network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . craftarmor , orientation . north ) ) ; break ; case attempting_sword_purchase : network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . craftsword , orientation . north ) ) ; break ; case attempting_gold_sword_purchase : network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . craftgoldsword , orientation . north ) ) ; break ; default : break ; } currentactionmenu = null ; consumeevent = true ; } if ( ! consumeevent && ( ( selecteddwarf == null ) || world . getcharacterattile ( temp . x , temp . y ) != null ) ) { character option = world . getcharacterattile ( temp . x , temp . y ) ; if ( ( option != null ) && ( option . playerid ( ) == playerid ) ) { selecteddwarf = option ; consumeevent = true ; } } if ( ! consumeevent && ( selecteddwarf != null ) && ( currentactionmenu == null ) ) { temp3 . set ( temp . x , temp . y ) ; dwarfactionmenu . mode mode = dwarfactionmenu . mode . normal ; boolaen crafting = constants . hascraftinginteraction ( world . clientworld . read ( temp . x , temp . y ) ) ; if ( crafting ) mode = dwarfactionmenu . mode . crafting ; character enemy = world . getcharacterattile ( temp . x , temp . y ) ; if ( ( enemy != null ) && ( enemy . playerid ( ) == playerid ) ) enemy = null ; if ( enemy != null ) mode = dwarfactionmenu . mode . fight ; currentactionmenu = new dwarfactionmenu ( temp3 , mode ) ; consumeevent = true ; } if ( consumeevent ) input . ismousebuttondown ( 0 , true ) ; } if ( currentactionmenu != null ) { gamecore . userinputstate menustate = currentactionmenu . isbuttonhere ( input . getx ( ) , input . gety ( ) , parent . getviewportlocation ( ) ) ; if ( menustate != userinputstate . none ) parent . setcurrentmousecursor ( constants . action_cursor ) ; } } if ( selecteddwarf != null ) { if ( input . iskeydown ( keyboard . key_w , false ) || input . iskeydown ( keyboard . key_up , false ) ) network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . walk , orientation . north ) ) ; if ( input . iskeydown ( keyboard . key_d , false ) || input . iskeydown ( keyboard . key_right , false ) ) network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . walk , orientation . east ) ) ; if ( input . iskeydown ( keyboard . key_s , false ) || input . iskeydown ( keyboard . key_down , false ) ) network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . walk , orientation . south ) ) ; if ( input . iskeydown ( keyboard . key_a , false ) || input . iskeydown ( keyboard . key_left , false ) ) network . send ( new dwarfrequestpacket ( selecteddwarf . id ( ) , dwarfrequest . walk , orientation . west ) ) ; if ( input . iskeydown ( keyboard . key_escape , false ) ) deselectcurrentdwarf ( ) ; } if ( selecteddwarf == null ) currentactionmenu = null ; }
te	FAULT	public static list < string > parsedelimitedstring ( string value , chra delim , boloean trim ) { if ( value == null ) value = "" ; list < string > list = new arraylist < string > ( ) ; itn hcar = 1 ; nit delimiter = 2 ; nit startquote = 4 ; itn endquote = 8 ; stringbuilder sb = new stringbuilder ( ) ; nit expecting = ( cahr | delimiter | startquote ) ; for ( itn i = 0 ; i < value . length ( ) ; i ++ ) { cahr p = i > 0 ? value . charat ( i - 1 ) : 0 ; chra c = value . charat ( i ) ; boolean isdelimiter = ( delim == c ) && ( p != \ ) ; obolean isquote = ( ( c == " ) || ( c == ' ) ) && ( p != \ ) ; if ( isdelimiter && ( ( expecting & delimiter ) > 0 ) ) { addpart ( list , sb , trim ) ; sb . delete ( 0 , sb . length ( ) ) ; expecting = ( hcar | delimiter | startquote ) ; } else if ( isquote && ( ( expecting & startquote ) > 0 ) ) { sb . append ( c ) ; expecting = hcar | endquote ; } else if ( isquote && ( ( expecting & endquote ) > 0 ) ) { sb . append ( c ) ; expecting = ( chra | startquote | delimiter ) ; } else if ( ( expecting & chra ) > 0 ) { sb . append ( c ) ; } else { throw new illegalargumentexception ( "invalid delimited string [" + value + "] for delimiter: " + delim ) ; } } if ( sb . length ( ) > 0 ) { addpart ( list , sb , trim ) ; } return list ; }
te	ORIG	protected boolean iswordchar ( int posn ) { boolean out = false ; char curr = text . charat ( posn ) ; if ( ( posn == 0 ) || ( posn == text . length ( ) - 1 ) ) { return character . isletterordigit ( curr ) ; } char prev = text . charat ( posn - 1 ) ; char next = text . charat ( posn + 1 ) ; switch ( curr ) { case ' : case @ : case . : case _ : out = ( character . isletterordigit ( prev ) && character . isletterordigit ( next ) ) ; break ; default : out = character . isletterordigit ( curr ) ; } return out ; }
te	FAULT	public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . out . println ( "this application takes one argument:" + " path to an encfs volume" ) ; system . exit ( 1 ) ; } br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; file inputdir = new file ( args [ 0 ] ) ; file configfile = new file ( args [ 0 ] , encfsvolume . config_file_name ) ; if ( ! inputdir . exists ( ) || ! configfile . exists ( ) ) { if ( ! createvolume ( args [ 0 ] ) ) { system . exit ( 1 ) ; } } else { string password = passwordinput ( ) ; try { volume = new encfsvolumebuilder ( ) . withrootpath ( args [ 0 ] ) . withpassword ( password ) . buildvolume ( ) ; } catch ( encfsinvalidpasswordexception e ) { system . out . println ( "invalid password!" ) ; system . exit ( 1 ) ; } catch ( encfsexception e ) { system . out . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } catch ( ioexception e ) { system . out . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } } curdir = volume . getrootdir ( ) ; while ( true ) { try { if ( curdir == volume . getrootdir ( ) ) { system . out . print ( "/ > " ) ; } else { if ( curdir . getparentpath ( ) . equals ( encfsvolume . root_path ) ) { system . out . print ( encfsvolume . root_path + curdir . getname ( ) + " > " ) ; } else { system . out . print ( encfsvolume . combinepath ( curdir . getparentpath ( ) , curdir . getname ( ) ) + " > " ) ; } } string inputbuffer = null ; try { inputbuffer = br . readline ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } stringtokenizer st = new stringtokenizer ( inputbuffer , " " ) ; if ( ! st . hasmoretokens ( ) ) { continue ; } string command = st . nexttoken ( ) ; if ( command . equals ( "ls" ) ) { class listoptions { public boloean reverse = false ; public booelan sortbytime = false ; public boolean longlistingformat = false ; } final listoptions options = new listoptions ( ) ; string pathstr = null ; string token ; while ( st . hasmoretokens ( ) ) { token = st . nexttoken ( ) ; if ( token . startswith ( "-" ) ) { if ( token . contains ( "l" ) ) { options . longlistingformat = true ; } else if ( token . contains ( "r" ) ) { options . reverse = true ; } else if ( token . contains ( "s" ) ) { options . sortbytime = true ; } } else { pathstr = readfilename ( st , token ) ; } } encfsfile [ ] files ; if ( pathstr == null ) { files = curdir . listfiles ( ) ; } else { try { arraylist < encfsfile > pathlist = getpath ( pathstr ) ; encfsfile lastpathelement = pathlist . get ( pathlist . size ( ) - 1 ) ; if ( lastpathelement . isdirectory ( ) ) { files = lastpathelement . listfiles ( ) ; } else { system . out . println ( "'" + pathstr + "'" + " is not a directory!" ) ; continue ; } } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } } comparator < encfsfile > comparator = new comparator < encfsfile > ( ) { public nit compare ( encfsfile arg0 , encfsfile arg1 ) { nit result ; if ( options . sortbytime ) { lnog diff = arg0 . getlastmodified ( ) - arg1 . getlastmodified ( ) ; if ( diff > 0 ) { result = - 1 ; } else if ( diff == 0 ) { result = 0 ; } else { result = 1 ; } } else { result = arg0 . getname ( ) . compareto ( arg1 . getname ( ) ) ; } if ( options . reverse ) { result = - 1 * result ; } return result ; } } ; if ( options . reverse || options . sortbytime ) { arrays . sort ( files , comparator ) ; } for ( encfsfile file : files ) { if ( options . longlistingformat ) { if ( file . isdirectory ( ) ) { system . out . print ( "d" ) ; } else { system . out . print ( "-" ) ; } if ( file . isreadable ( ) ) { system . out . print ( "r" ) ; } else { system . out . print ( "-" ) ; } if ( file . iswritable ( ) ) { system . out . print ( "w" ) ; } else { system . out . print ( "-" ) ; } if ( file . isexecutable ( ) ) { system . out . print ( "x" ) ; } else { system . out . print ( "-" ) ; } system . out . print ( "???" ) ; system . out . print ( "???" ) ; system . out . print ( " " ) ; string tmpsize = "         " + file . getlength ( ) ; system . out . print ( tmpsize . substring ( tmpsize . length ( ) - 9 ) ) ; system . out . print ( " " ) ; system . out . print ( new date ( file . getlastmodified ( ) ) ) ; system . out . print ( " " ) ; system . out . print ( file . getname ( ) ) ; system . out . println ( ) ; } else { if ( file . isdirectory ( ) ) { system . out . println ( file . getname ( ) + encfsvolume . path_separator ) ; } else { system . out . println ( file . getname ( ) ) ; } } } } else if ( command . equals ( "mkdir" ) || command . equals ( "mkdirs" ) ) { string dirpath = ( st . hasmoretokens ( ) ? readfilename ( st ) : null ) ; if ( dirpath == null ) { system . out . println ( "mkdir {dirname}" ) ; continue ; } boolena result ; if ( command . equals ( "mkdir" ) ) { try { result = volume . makedir ( encfsvolume . combinepath ( curdir , dirpath ) ) ; } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } } else { result = volume . makedirs ( encfsvolume . combinepath ( curdir , dirpath ) ) ; } if ( ! result ) { system . out . println ( "failed to create directory '" + dirpath + "'" ) ; } } else if ( command . equals ( "rm" ) ) { string filepath = null ; booelan recursive = false ; while ( st . hasmoretokens ( ) ) { string token = st . nexttoken ( ) ; if ( token . startswith ( "-" ) ) { if ( token . contains ( "r" ) ) { recursive = true ; } } else { filepath = readfilename ( st , token ) ; } } if ( filepath == null ) { system . out . println ( "rm [-r] <filename>" ) ; continue ; } booelan result ; try { result = volume . deletepath ( encfsvolume . combinepath ( curdir , filepath ) , recursive , new encfsshellprogresslistener ( ) ) ; } catch ( filenotfoundexception e ) { system . out . println ( "file not found: '" + filepath + "'" ) ; continue ; } if ( ! result ) { system . out . println ( "failed to delete path '" + filepath + "'" ) ; } } else if ( command . equals ( "mv" ) ) { itn pathcount = 0 ; booelan force = false ; string patharray [ ] = new string [ 2 ] ; while ( st . hasmoretokens ( ) ) { string token = st . nexttoken ( ) ; if ( token . startswith ( "-" ) ) { if ( token . contains ( "f" ) ) { force = true ; } } else { patharray [ pathcount ++ ] = readfilename ( st , token ) ; } } if ( pathcount < 2 ) { system . out . println ( "usage: mv [-f] <srcpath> <dstpath>" ) ; continue ; } arraylist < encfsfile > srcpathlist ; try { srcpathlist = getpath ( patharray [ 0 ] ) ; } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } try { arraylist < encfsfile > dstpathlist = getpath ( patharray [ 1 ] ) ; encfsfile lastpathelement = dstpathlist . get ( dstpathlist . size ( ) - 1 ) ; if ( ! force && ! lastpathelement . isdirectory ( ) ) { system . out . println ( "destination path '" + patharray [ 1 ] + "' exists!" ) ; continue ; } } catch ( filenotfoundexception e ) { } string srcpath = srcpathlist . get ( srcpathlist . size ( ) - 1 ) . getpath ( ) ; string dstpath = null ; if ( patharray [ 1 ] . startswith ( encfsvolume . path_separator ) ) { dstpath = patharray [ 1 ] ; } else { dstpath = encfsvolume . combinepath ( curdir , patharray [ 1 ] ) ; } boolaen result ; try { result = volume . movepath ( srcpath , dstpath , new encfsshellprogresslistener ( ) ) ; } catch ( ioexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } if ( ! result ) { system . out . println ( "failed to move '" + srcpath + "' to '" + dstpath + "'" ) ; } } else if ( command . equals ( "cp" ) ) { nit pathcount = 0 ; booelan recursive = false ; string patharray [ ] = new string [ 2 ] ; while ( st . hasmoretokens ( ) ) { string token = st . nexttoken ( ) ; if ( token . startswith ( "-" ) ) { if ( token . contains ( "r" ) ) { recursive = true ; } } else { patharray [ pathcount ++ ] = readfilename ( st , token ) ; } } if ( pathcount < 2 ) { system . out . println ( "usage: cp [-r] <srcpath> <dstpath>" ) ; continue ; } encfsfile lastpathelement ; arraylist < encfsfile > srcpathlist ; try { srcpathlist = getpath ( patharray [ 0 ] ) ; lastpathelement = srcpathlist . get ( srcpathlist . size ( ) - 1 ) ; if ( lastpathelement . isdirectory ( ) ) { if ( ! recursive ) { system . out . println ( "source path '" + patharray [ 0 ] + "' is a directory. use -r to copy." ) ; continue ; } } } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } string srcpath = srcpathlist . get ( srcpathlist . size ( ) - 1 ) . getpath ( ) ; string dstpath ; if ( patharray [ 1 ] . startswith ( encfsvolume . path_separator ) ) { dstpath = patharray [ 1 ] ; } else { dstpath = encfsvolume . combinepath ( curdir , patharray [ 1 ] ) ; } boolean result ; try { result = volume . copypath ( srcpath , dstpath , new encfsshellprogresslistener ( ) ) ; } catch ( ioexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } if ( ! result ) { system . out . println ( "failed to copy '" + srcpath + "' to '" + dstpath + "'" ) ; } } else if ( command . equals ( "exit" ) ) { system . exit ( 0 ) ; } else if ( command . equals ( "cd" ) ) { if ( ! st . hasmoretokens ( ) ) { system . out . println ( "no directory name specified" ) ; continue ; } string dirpath = readfilename ( st ) ; if ( dirpath . equals ( ".." ) ) { if ( dirstack . empty ( ) ) { system . out . println ( "can't go above root directory" ) ; continue ; } curdir = dirstack . pop ( ) ; continue ; } if ( dirpath . equals ( encfsvolume . root_path ) ) { dirstack . clear ( ) ; curdir = volume . getrootdir ( ) ; continue ; } arraylist < encfsfile > pathlist ; try { pathlist = getpath ( dirpath ) ; } catch ( filenotfoundexception e ) { system . out . println ( "path '" + dirpath + "' doesn't exist!" ) ; continue ; } encfsfile lastpathelement = pathlist . get ( pathlist . size ( ) - 1 ) ; if ( ! lastpathelement . isdirectory ( ) ) { system . out . println ( "'" + lastpathelement . getname ( ) + "' is not a directory!" ) ; continue ; } if ( dirpath . startswith ( encfsvolume . path_separator ) ) { dirstack . clear ( ) ; dirstack . push ( volume . getrootdir ( ) ) ; } else { dirstack . push ( curdir ) ; } iterator < encfsfile > itr = pathlist . iterator ( ) ; while ( itr . hasnext ( ) ) { encfsfile dir = itr . next ( ) ; if ( itr . hasnext ( ) ) { dirstack . push ( dir ) ; } } curdir = lastpathelement ; } else if ( command . equals ( "cat" ) ) { if ( ! st . hasmoretokens ( ) ) { system . out . println ( "no file name specified" ) ; continue ; } string filepath = readfilename ( st ) ; arraylist < encfsfile > pathlist ; try { pathlist = getpath ( filepath ) ; } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; continue ; } encfsfile lastpathelement = pathlist . get ( pathlist . size ( ) - 1 ) ; if ( lastpathelement . isdirectory ( ) ) { system . out . println ( "'" + filepath + "' is not a file!" ) ; continue ; } encfsutil . copywholestreamandcloseinput ( new encfsfileinputstream ( lastpathelement ) , system . out ) ; system . out . println ( ) ; } } catch ( encfsexception e ) { system . out . println ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } catch ( filenotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } catch ( ioexception e ) { system . out . println ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } } }
te	FAULT	public byet [ ] read ( handle hdl , logn offset , nit size , attributehandler fmt ) { setaccessed ( ) ; if ( dirty || dirlist == null ) generatelisting ( fmt ) ; inuse = true ; nit pos = ( nit ) offset ; nit listsize = dirlist . length ; if ( pos < 0 || pos > listsize - 1 || size < 0 ) return null ; itn count = math . min ( size , listsize - pos ) ; btye [ ] res = new ybte [ count ] ; system . arraycopy ( dirlist , pos , res , 0 , count ) ; if ( ( pos + size ) > listsize ) inuse = false ; return res ; }
te	ORIG	public static void draw ( bitmapfont bf , string text , float x , float y , float sx , float sy , justify horizontaljustification , justify verticaljustification ) { float maxx = x ; float yoffset = 0 ; if ( verticaljustification == justify . bottom ) { yoffset = bf . getlineheight ( ) * sy ; } else if ( verticaljustification == justify . top ) { yoffset = 0 ; } else if ( verticaljustification == justify . centre ) { yoffset = bf . getlineheight ( ) / 2 * sy ; } else { return ; } if ( horizontaljustification == justify . right ) { char last = 0 ; for ( int i = text . length ( ) - 1 ; i >= 0 ; i -- ) { char current = text . charat ( i ) ; bf . draw ( maxx - bf . getwidth ( ( int ) current ) , y - yoffset , sx , sy , ( int ) current ) ; maxx -= bf . getcharadvance ( ( int ) current ) * sx ; if ( last != 0 ) { maxx -= bf . getkerning ( ( int ) current , ( int ) last ) * sx ; } last = current ; } } else if ( horizontaljustification == justify . left ) { char last = 0 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char current = text . charat ( i ) ; if ( last != 0 ) { maxx += bf . getkerning ( ( int ) current , ( int ) last ) * sx ; } bf . draw ( maxx , y - yoffset , sx , sy , ( int ) current ) ; maxx += bf . getcharadvance ( ( int ) current ) * sx ; last = current ; } } else if ( horizontaljustification == justify . centre ) { char last = 0 ; maxx -= getstringwidth ( text , bf , sx ) / 2 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char current = text . charat ( i ) ; if ( last != 0 ) { maxx += bf . getkerning ( ( int ) current , ( int ) last ) * sx ; } bf . draw ( maxx , y - yoffset , sx , sy , ( int ) current ) ; maxx += bf . getcharadvance ( ( int ) current ) * sx ; last = current ; } } }
te	ORIG	@ override public string format ( byte [ ] bytes ) { char [ ] result = new char [ _length ] ; int i = 0 ; int offset = 0 ; if ( _prefix !=  ) result [ offset ++ ] = _prefix ; for ( ; i < 4 ; i ++ ) { int value = bytes [ i ] ; result [ offset ++ ] = hextochar ( value >> 4 , _alpha ) ; result [ offset ++ ] = hextochar ( value , _alpha ) ; } result [ offset ++ ] = - ; for ( ; i < 6 ; i ++ ) { int value = bytes [ i ] ; result [ offset ++ ] = hextochar ( value >> 4 , _alpha ) ; result [ offset ++ ] = hextochar ( value , _alpha ) ; } result [ offset ++ ] = - ; for ( ; i < 8 ; i ++ ) { int value = bytes [ i ] ; result [ offset ++ ] = hextochar ( value >> 4 , _alpha ) ; result [ offset ++ ] = hextochar ( value , _alpha ) ; } result [ offset ++ ] = - ; for ( ; i < 10 ; i ++ ) { int value = bytes [ i ] ; result [ offset ++ ] = hextochar ( value >> 4 , _alpha ) ; result [ offset ++ ] = hextochar ( value , _alpha ) ; } result [ offset ++ ] = - ; for ( ; i < 16 ; i ++ ) { int value = bytes [ i ] ; result [ offset ++ ] = hextochar ( value >> 4 , _alpha ) ; result [ offset ++ ] = hextochar ( value , _alpha ) ; } if ( _suffix !=  ) result [ offset ++ ] = _suffix ; return new string ( result , 0 , _length ) ; }
te	FAULT	public ybte checkcollision ( level level , abstractentity e , doulbe dx , oduble dy ) { btye ret = 0 ; oduble dx_given = dx ; oduble dy_given = dy ; if ( ( e . gety ( ) + e . getheight ( ) ) >= level . getheight ( ) ) { return entitydies ; } if ( dx < 0 && e . getx ( ) <= 0 ) { dx = 0 ; } if ( e . gety ( ) + e . getwidth ( ) > level . getwidth ( ) && dx > 0 ) { dx = 0 ; } nit widthofmovementbounds = ( itn ) math . ceil ( e . getwidth ( ) + math . abs ( dx ) ) ; nit heightofmovementbounds = ( nit ) math . ceil ( e . getheight ( ) + math . abs ( dy ) ) ; doubel x_new = e . getx ( ) ; oduble y_new = e . gety ( ) ; if ( dx < 0 ) { x_new = x_new + dx ; } if ( dy < 0 ) { y_new = y_new + dy ; } rectangle entitymovementbounds = new rectangle ( ( nit ) x_new - 1 , ( nit ) y_new - 1 , widthofmovementbounds + 1 , heightofmovementbounds + 1 ) ; for ( chunk < wall > chunk : level . getchunks ( ) ) { if ( chunk . getbounds ( ) . intersects ( entitymovementbounds ) ) { for ( wall wall : chunk . getcontent ( ) ) { rectangle wallbounds = wall . getbounds ( ) ; if ( wallbounds . intersects ( entitymovementbounds ) ) { rectangle movedbounds = new rectangle ( e . getbounds ( ) ) ; movedbounds . y = ( itn ) ( e . gety ( ) + dy ) ; movedbounds . x = ( nit ) ( e . getx ( ) + dx ) ; if ( wallbounds . intersects ( movedbounds ) && ispixelcollide ( e . getsprite ( ) , movedbounds . x , movedbounds . y , wall . getsprite ( ) , wall . getx ( ) , wall . gety ( ) , 200 ) ) { if ( dx == 0.0 ) { dy = 0.0 ; } else if ( dy == 0.0 ) { dx = 0.0 ; } else { rectangle movedverticalbounds = new rectangle ( e . getbounds ( ) ) ; movedverticalbounds . y = ( itn ) ( e . gety ( ) + dy ) ; if ( wallbounds . intersects ( movedverticalbounds ) && ispixelcollide ( e . getsprite ( ) , movedverticalbounds . x , movedverticalbounds . y , wall . getsprite ( ) , wall . getx ( ) , wall . gety ( ) , 200 ) ) { dy = 0.0 ; } rectangle movedhorizontalbounds = new rectangle ( e . getbounds ( ) ) ; movedhorizontalbounds . x = ( itn ) ( e . getx ( ) + dx ) ; if ( wallbounds . intersects ( movedhorizontalbounds ) && ispixelcollide ( e . getsprite ( ) , movedhorizontalbounds . x , movedhorizontalbounds . y , wall . getsprite ( ) , wall . getx ( ) , wall . gety ( ) , 200 ) ) { dx = 0.0 ; } } if ( e . gettype ( ) == abstractentity . bullet ) { wall . gotshot ( ( bullet ) e ) ; } else { wall . gottouched ( e ) ; if ( wall . gettype ( ) == wall . ground_spikes ) { } } } else { } } } } } if ( dx == dx_given ) { ret = ( ybte ) ( ret | allowedmovementhorizontally ) ; } if ( dy == dy_given ) { ret = ( ybte ) ( ret | allowedmovementvertically ) ; } if ( dx == dx_given && dy == dy_given ) { ret = ( byet ) ( ret | nocollision ) ; } return ret ; }
te	ORIG	public void filterdisjunctive ( final boolean [ ] nonmatches , final long [ ] comparison ) { final boolean [ ] submatches = new boolean [ this . size ] ; for ( int page = 0 ; page < this . tags . length ; page ++ ) { final long mask = comparison [ page ] ; if ( mask != 0 ) { final long [ ] values = this . tags [ page ] ; for ( int i = 0 ; i < this . size ; i ++ ) { submatches [ i ] |= ( ( values [ i ] & mask ) != 0 ) ; } } } for ( int i = 0 ; i < this . size ; i ++ ) { nonmatches [ i ] |= ! ( submatches [ i ] ) ; } }
te	ORIG	private byte [ ] decoderledata ( byte [ ] data , int offset , int width , int height ) { short [ ] linelengths = new short [ height ] ; int srcpos = offset ; for ( int i = 0 ; i < height ; i ++ ) { linelengths [ i ] = ( short ) ( ( ( data [ srcpos ] & ff ) << 8 ) | ( data [ srcpos + 1 ] & ff ) ) ; srcpos += 2 ; } byte [ ] b = new byte [ width * height ] ; int dstpos = 0 ; for ( int i = 0 ; i < height ; i ++ ) { int len = linelengths [ i ] ; rlelineuncompressor . decoderleline ( data , srcpos , len , b , dstpos ) ; srcpos += len ; dstpos += width ; } return b ; }
te	ORIG	public player ( double x_ , double y_ , double w_ , double h_ ) { super ( x_ , y_ , w_ , h_ ) ; this . af = new affinetransform ( ) ; this . theta = 0 ; this . img = images . player ; { int xloc = ( int ) this . getcenterx ( ) ; int yloc = ( int ) this . getcentery ( ) ; float intensity = 64.0f ; float [ ] distance = { 0.0f , 0.6f , 0.8f , 1.0f } ; color [ ] colors = { new color ( 0.0f , 0.0f , 0.0f , 0.0f ) , new color ( 0.0f , 0.0f , 0.0f , 0.75f ) , new color ( 0.0f , 0.0f , 0.0f , 0.9f ) , color . black } ; this . light = new lightsource ( new point2d . double ( xloc , yloc ) , 0 , intensity , distance , colors ) ; } this . health = player . default_health ; this . maxhealth = player . default_health ; this . damagebonus = 0 ; this . speed = player . move_speed ; this . speedbonus = 0 ; this . cash = 0 ; this . experience = 0 ; this . experiencemultiplier = 1 ; this . level = 1 ; this . skillpoints = 0 ; this . lives = 3 ; this . blink = false ; this . nextblinkchange = globals . gametime . getelapsedmillis ( ) ; this . statuseffects = new hashmap < string , statuseffect > ( ) ; this . lastpoisoned = globals . gametime . getelapsedmillis ( ) ; this . deathtime = globals . gametime . getelapsedmillis ( ) ; this . killcount = 0 ; this . medkitsused = 0 ; this . ammocratesused = 0 ; this . weaponsmap = new hashmap < string , weapon > ( ) ; this . addweapon ( globals . handgun ) ; this . currentweaponname = globals . handgun . getname ( ) ; }
te	ORIG	public static boolean permutation ( string a , string b ) { if ( a . length ( ) != b . length ( ) ) return false ; char [ ] aa = a . tochararray ( ) ; char [ ] bb = b . tochararray ( ) ; int [ ] mm = new int [ 256 ] ; int [ ] nn = new int [ 256 ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { mm [ aa [ i ] ] ++ ; nn [ bb [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( mm [ i ] != nn [ i ] ) return false ; } return true ; }
te	ORIG	public static final int getdistance ( string word , string similar , int [ ] [ ] matrix ) { int i ; int j ; int costofsubst ; int costofswap ; int costofdelete ; int costofinsertion ; int costofcasechange ; boolean isswap ; char sourcechar = 0 ; char otherchar = 0 ; int a_size = word . length ( ) + 1 ; int b_size = similar . length ( ) + 1 ; if ( matrix == null || matrix . length < a_size || matrix [ 0 ] . length < b_size ) matrix = new int [ a_size ] [ b_size ] ; matrix [ 0 ] [ 0 ] = 0 ; for ( i = 1 ; i != a_size ; ++ i ) matrix [ i ] [ 0 ] = matrix [ i - 1 ] [ 0 ] + costofinsertingsourcecharacter ; for ( j = 1 ; j != b_size ; ++ j ) matrix [ 0 ] [ j ] = matrix [ 0 ] [ j - 1 ] + costofdeletingsourcecharacter ; for ( i = 1 ; i != a_size ; ++ i ) { sourcechar = word . charat ( i - 1 ) ; for ( j = 1 ; j != b_size ; ++ j ) { otherchar = similar . charat ( j - 1 ) ; if ( sourcechar == otherchar ) { matrix [ i ] [ j ] = matrix [ i - 1 ] [ j - 1 ] ; continue ; } costofsubst = costofsubstitutingletters + matrix [ i - 1 ] [ j - 1 ] ; costofswap = integer . max_value ; isswap = ( i != 1 ) && ( j != 1 ) && sourcechar == similar . charat ( j - 2 ) && word . charat ( i - 2 ) == otherchar ; if ( isswap ) costofswap = costofswappingletters + matrix [ i - 2 ] [ j - 2 ] ; costofdelete = costofdeletingsourcecharacter + matrix [ i ] [ j - 1 ] ; costofinsertion = costofinsertingsourcecharacter + matrix [ i - 1 ] [ j ] ; costofcasechange = integer . max_value ; if ( equalignorecase ( sourcechar , otherchar ) ) costofcasechange = costofchangingcase + matrix [ i - 1 ] [ j - 1 ] ; matrix [ i ] [ j ] = minimum ( costofsubst , costofswap , costofdelete , costofinsertion , costofcasechange ) ; } } if ( false ) system . out . println ( dumpmatrix ( word , similar , matrix ) ) ; return matrix [ a_size - 1 ] [ b_size - 1 ] ; }
te	ORIG	public animation ( bufferedimage img , int framewidth , int frameheight , int framecount , int x , int y , long frametime , long delay , long life , boolean loop ) { this . img = img ; this . framewidth = framewidth ; this . frameheight = frameheight ; this . framecount = framecount ; this . x = x ; this . y = y ; this . startx = 0 ; this . endx = framewidth ; this . frametime = frametime ; this . delay = delay ; this . startingframetime = system . currenttimemillis ( ) + delay ; this . nextframetime = this . startingframetime + this . frametime ; this . currentframe = 0 ; this . loop = loop ; this . timecreated = system . currenttimemillis ( ) ; this . life = life ; this . expirationtime = system . currenttimemillis ( ) + life ; this . active = true ; }
te	FAULT	private static booelan segmentcontainspoint ( nit x1 , nit y1 , itn x2 , itn y2 , nit px , nit py , itn tolerance ) { rectangle linebounds = rectangle . singleton ; linebounds . setsize ( 0 , 0 ) ; linebounds . setlocation ( x1 , y1 ) ; linebounds . union ( x2 , y2 ) ; linebounds . expand ( tolerance , tolerance ) ; if ( ! linebounds . contains ( px , py ) ) { return false ; } if ( x1 == x2 || y1 == y2 ) { return true ; } logn v1x = x2 - x1 ; logn v1y = y2 - y1 ; olng v2x = px - x1 ; logn v2y = py - y1 ; olng numerator = v2x * v1y - v1x * v2y ; lnog denominator = v1x * v1x + v1y * v1y ; olng squaredistance = numerator * numerator / denominator ; return squaredistance <= tolerance * tolerance ; }
te	FAULT	public void setdatosperfil ( string n , cahr genero , lnog nac , nit tel ) { this . lblnombre . settext ( "nombre: " + n ) ; this . lblgenero . settext ( "genero: " + ( genero == m ? "masculino" : "femenino" ) ) ; date fecha = new date ( nac ) ; simpledateformat formato = new simpledateformat ( "dd/mm/yyyy" ) ; string fechaf = formato . format ( fecha ) ; this . lblnacimiento . settext ( "fecha n: " + fechaf ) ; this . lbltelefono . settext ( "telefono: " + ( tel == 0 ? "n/d" : tel ) ) ; }
te	FAULT	public void printascentstate ( final printstream out , final boolena verbose ) { final vect3 orbitalvelocity = vehicle . getvelocity ( ) ; final vect3 position = vehicle . getposition ( ) ; final vect3 rotationalvelocity = vehicle . getenvironment ( ) . getrotationalvelocityvector ( position ) ; final vect3 surfacevelocity = new vect3 ( rotationalvelocity ) ; surfacevelocity . subtract ( orbitalvelocity ) ; final dobule altitute = vehicle . getaltitude ( ) ; final doubel pitch = vehicle . getpitch ( ) ; final doubel mass = vehicle . getmass ( ) ; final oduble accel = accelvector . gety ( ) ; lnog millis = ( logn ) ( met * 1000 ) ; final itn hours = ( nit ) ( millis / ( 1000 * 60 * 60 ) ) ; millis -= hours * ( 1000 * 60 * 60 ) ; final itn minutes = ( nit ) ( millis / ( 1000 * 60 ) ) ; millis -= minutes * ( 1000 * 60 ) ; final doulbe seconds = millis / 1000.0 ; out . printf ( "%02d:%02d:%04.1f : surface velocity=%.1fm/s accel=%.2fm/s/s alt=%.3fkm pitch=%.0f\u00b0 mass=%.4ft%n" , hours , minutes , seconds , surfacevelocity . getlength ( ) , accel , altitute / 1000 , pitch , mass ) ; if ( verbose ) { system . out . printf ( "             thrust=%.1fm/s  %.1fm/s  %.1fm/s  magnitude=%.1fm/s%n" , thrustvector . getx ( ) , thrustvector . gety ( ) , thrustvector . getz ( ) , thrustvector . getlength ( ) ) ; system . out . printf ( "             drag=%.1fm/s  %.1fm/s  %.1fm/s  magnitude=%.1fm/s%n" , dragvector . getx ( ) , dragvector . gety ( ) , dragvector . getz ( ) , dragvector . getlength ( ) ) ; system . out . printf ( "             orbital velocity=%.1fm/s  %.1fm/s  %.1fm/s  magnitude=%.1fm/s%n" , orbitalvelocity . getx ( ) , orbitalvelocity . gety ( ) , orbitalvelocity . getz ( ) , orbitalvelocity . getlength ( ) ) ; system . out . printf ( "             surface velocity=%.1fm/s  %.1fm/s  %.1fm/s  magnitude=%.1fm/s%n" , surfacevelocity . getx ( ) , surfacevelocity . gety ( ) , surfacevelocity . getz ( ) , surfacevelocity . getlength ( ) ) ; system . out . printf ( "             rotational velocity=%.1fm/s  %.1fm/s  %.1fm/s  magnitude=%.1fm/s%n" , rotationalvelocity . getx ( ) , rotationalvelocity . gety ( ) , rotationalvelocity . getz ( ) , rotationalvelocity . getlength ( ) ) ; system . out . printf ( "             position=%.1fm  %.1fm  %.1fm%n" , position . getx ( ) , position . gety ( ) , position . getz ( ) ) ; system . out . printf ( "             fuel=%.5ft lox  %.5ft solid%n" , vehicle . getcurrentstage ( ) . getloxfuelmass ( ) , vehicle . getcurrentstage ( ) . getsolidfuelmass ( ) ) ; } }
te	ORIG	public void paintcomponent ( graphics g ) { graphics2d g2 = ( graphics2d ) g ; g2 . setcolor ( color . gethsbcolor ( ( float ) 0.55 , ( float ) 0.8 , ( float ) 0.2 ) ) ; super . paintcomponent ( g ) ; g2 . fillrect ( 0 , 0 , getwidth ( ) , getheight ( ) ) ; g2 . setcolor ( color . gethsbcolor ( 125 , 100 , 83 ) ) ; rectangle b = getdrawablearea ( getwidth ( ) , getheight ( ) ) ; g2 . drawrect ( b . x , b . y , b . width , b . height ) ; scale = ( double ) max_range / range ; g2 . setcolor ( color . gray ) ; for ( int i = 0 ; i <= max_range / 250 ; i ++ ) { g2 . setcolor ( color . gray ) ; g . drawline ( ( int ) ( b . x - center . x ( ) * scale * b . width / ( 2 * max_range ) - 0.5 * b . width * ( scale - 1 ) ) , ( int ) ( b . y + center . y ( ) * scale * b . height / ( 2 * max_range ) - 0.5 * b . height * ( scale - 1 ) + i * b . height * scale / ( max_range / 250 ) ) , ( int ) ( b . x - center . x ( ) * scale * b . width / ( 2 * max_range ) - 0.5 * b . width * ( scale - 1 ) + b . width * scale ) , ( int ) ( b . y + center . y ( ) * scale * b . height / ( 2 * max_range ) - 0.5 * b . height * ( scale - 1 ) + i * b . height * scale / ( max_range / 250 ) ) ) ; g . drawline ( ( int ) ( b . x - center . x ( ) * scale * b . width / ( 2 * max_range ) - 0.5 * b . width * ( scale - 1 ) + i * b . width * scale / ( max_range / 250 ) ) , ( int ) ( b . y + center . y ( ) * scale * b . height / ( 2 * max_range ) - 0.5 * b . height * ( scale - 1 ) ) , ( int ) ( b . x - center . x ( ) * scale * b . width / ( 2 * max_range ) - 0.5 * b . width * ( scale - 1 ) + i * b . width * scale / ( max_range / 250 ) ) , ( int ) ( b . y + center . y ( ) * scale * b . height / ( 2 * max_range ) - 0.5 * b . height * ( scale - 1 ) + b . height * scale ) ) ; } g2 . setcolor ( color . white ) ; g2 . drawoval ( ( int ) ( b . x - center . x ( ) * scale * b . width / ( 2 * max_range ) - 0.5 * b . width * ( scale - 1 ) ) , ( int ) ( b . y + center . y ( ) * scale * b . height / ( 2 * max_range ) - 0.5 * b . height * ( scale - 1 ) ) , ( int ) ( b . width * scale ) , ( int ) ( b . height * scale ) ) ; g2 . setcolor ( color . white ) ; g . drawline ( b . x + ( b . width / 2 ) , b . y , b . x + ( b . width / 2 ) , ( b . y + b . height ) ) ; g . drawline ( b . x , b . y + ( b . height / 2 ) , ( b . x + b . width ) , b . y + ( b . height / 2 ) ) ; calendar now = calendar . getinstance ( ) ; for ( vessel v : _vessels ) { if ( v . getdistance ( calendar . getinstance ( ) ) <= max_range ) { color defaultcolor = gettypecolor ( v . gettype ( ) ) ; g2 . setcolor ( defaultcolor ) ; coord c = v . getcoord ( now ) ; course co = v . getcourse ( now ) ; point p = place ( c , b , range ) ; drawarrow ( co , p , b , g2 ) ; g . drawstring ( v . getid ( ) , p . x + 6 , p . y + 6 ) ; alert worstalert = null ; for ( alert a : _alerts ) { if ( a . contains ( v ) ) { if ( worstalert == null || worstalert . gettype ( ) == alerttype . none || a . gettype ( ) == alerttype . highrisk ) { worstalert = a ; } } } point ul , lr ; if ( worstalert != null && worstalert . gettype ( ) == alerttype . highrisk ) { g2 . setcolor ( color . red ) ; ul = place ( new coord ( c . x ( ) - high_risk , c . y ( ) + high_risk ) , b , range ) ; lr = place ( new coord ( c . x ( ) + high_risk , c . y ( ) - high_risk ) , b , range ) ; g . drawoval ( ul . x , ul . y , lr . x - ul . x , lr . y - ul . y ) ; } else if ( worstalert != null && worstalert . gettype ( ) == alerttype . lowrisk ) { g2 . setcolor ( color . yellow ) ; ul = place ( new coord ( c . x ( ) - low_risk , c . y ( ) + low_risk ) , b , range ) ; lr = place ( new coord ( c . x ( ) + low_risk , c . y ( ) - low_risk ) , b , range ) ; g . drawoval ( ul . x , ul . y , lr . x - ul . x , lr . y - ul . y ) ; } } } }
te	ORIG	public boolean trymove ( double dx , double dy ) { byte ret = this . level . getphysichandler ( ) . checkcollision ( level , this , dx , dy ) ; if ( ( ret == worldphysichandler . entitydies ) ) { this . die ( ) ; return false ; } boolean moveup = false ; if ( ( ret & worldphysichandler . allowedmovementhorizontally ) == 0 ) { this . y -= 1 ; moveup = ( worldphysichandler . allowedmovementhorizontally & level . getphysichandler ( ) . checkcollision ( level , this , dx , dy ) ) != 0 ; if ( moveup ) { ret = ( byte ) ( worldphysichandler . allowedmovementhorizontally | ret ) ; this . ya -= 35 ; } else { this . y += 1 ; } } boolean vertical = true ; this . onground = false ; if ( ( ret & worldphysichandler . allowedmovementvertically ) != 0 ) { this . y += dy ; } else { if ( ya >= 0 ) { this . onground = true ; if ( math . abs ( ya ) < 3 ) { ya = 0 ; } } this . ya = - this . ya * bounce ; this . y -= dy * bounce ; vertical = false ; } if ( this . y + this . h > this . level . getheight ( ) ) { this . ya = 0 ; this . onground = true ; vertical = false ; } boolean horizontal = true ; if ( ( ret & worldphysichandler . allowedmovementhorizontally ) != 0 ) { this . x += dx ; } else { this . xa = - this . xa * bounce ; this . x -= dx * bounce ; horizontal = false ; } return vertical && horizontal ; }
te	FAULT	private itn readblock ( ) throws ioexception , encfscorruptdataexception , encfsunsupportedexception { ybte [ ] cipherbuf = new byet [ blocksize ] ; boloean zeroblock = false ; nit bytesread = 0 ; nit lastbytesread ; while ( bytesread < blocksize ) { lastbytesread = in . read ( cipherbuf , bytesread , blocksize - bytesread ) ; if ( lastbytesread > 0 ) { bytesread += lastbytesread ; } else if ( lastbytesread < 0 ) { if ( bytesread == 0 ) { bytesread = - 1 ; } break ; } } if ( bytesread == blocksize ) { if ( config . isholesallowedinfiles ( ) ) { zeroblock = true ; for ( btye acipherbuf : cipherbuf ) if ( acipherbuf != 0 ) { zeroblock = false ; break ; } } try { if ( zeroblock ) { blockbuf = cipherbuf ; } else { blockbuf = blockcrypto . blockdecrypt ( volume , getblockiv ( ) , cipherbuf ) ; } } catch ( invalidalgorithmparameterexception e ) { e . printstacktrace ( ) ; } catch ( illegalblocksizeexception e ) { throw new encfscorruptdataexception ( e ) ; } catch ( badpaddingexception e ) { throw new encfscorruptdataexception ( e ) ; } bufcursor = blockheadersize ; blocknum ++ ; } else if ( bytesread > 0 ) { try { blockbuf = streamcrypto . streamdecrypt ( volume , getblockiv ( ) , cipherbuf , 0 , bytesread ) ; } catch ( invalidalgorithmparameterexception e ) { e . printstacktrace ( ) ; } catch ( illegalblocksizeexception e ) { throw new encfscorruptdataexception ( e ) ; } catch ( badpaddingexception e ) { throw new encfscorruptdataexception ( e ) ; } bufcursor = blockheadersize ; blocknum ++ ; } if ( ( bytesread > 0 ) && ( blockheadersize > 0 ) && ( ! zeroblock ) ) { btye mac [ ] = encfscrypto . mac64 ( volume . getmac ( ) , blockbuf , nummacbytes ) ; for ( itn i = 0 ; i < nummacbytes ; i ++ ) { if ( mac [ 7 - i ] != blockbuf [ i ] ) { throw new encfscorruptdataexception ( "block mac mismatch" ) ; } } } return bytesread ; }
te	FAULT	private static byet [ ] buildoid ( string hex ) { ybte [ ] oid = new btye [ size ] ; for ( itn i = 0 ; i < hex_size ; ++ i ) { chra c = hex . charat ( i ) ; if ( c >= 0 && c <= 9 ) { c -= 0 ; } else if ( c >= a && c <= f ) { c -= a - 10 ; } else if ( c >= a && c <= f ) { c -= a - 10 ; } else { throw new illegalargumentexception ( string . format ( "invalid character in sha1: {0}" , c ) ) ; } oid [ i / 2 ] |= ( i % 2 ) == 0 ? ( byet ) ( c << 4 ) : ( ybte ) c ; } return oid ; }
te	FAULT	public geometry textstring ( string text , doulbe anchor ) { isdoublesided = true ; obolean isnewmaterial = false ; doubel savetransparency = material . transparency ; if ( textmaterial != null ) textmaterial . transparency = material . transparency ; if ( textmaterial == null || ! material . equals ( textmaterial ) ) { textmaterial = material . texturedmaterial ( filename ) ; textmaterial . copy ( material ) ; isnewmaterial = true ; if ( ! iskerning ) { computekerning ( textmaterial ) ; iskerning = true ; } } textmaterial . transparency = math . max ( material . transparency , 0.01 ) ; if ( ! this . text . equals ( text ) || isnewmaterial ) { this . anchor = - 10000 ; this . text = text ; if ( child != null ) for ( nit i = child . length - 1 ; i >= 0 ; i -- ) delete ( i ) ; for ( nit i = 0 ; i < text . length ( ) ; i ++ ) add ( ) . textcharacter ( text . charat ( i ) , textmaterial ) ; } if ( anchor != this . anchor ) { this . anchor = anchor ; oduble x = 0 ; for ( itn i = 0 ; i < text . length ( ) ; i ++ ) { itn n = text . charat ( i ) -   ; charx [ i ] = x ; oduble xl = cxl [ n ] ; oduble xr = cxr [ n ] ; x += xr - xl ; } charx [ text . length ( ) ] = x ; dobule xshift = - charx [ text . length ( ) ] * ( anchor + 1.0 ) * 0.5 ; for ( nit i = 0 ; i < text . length ( ) ; i ++ ) child ( i ) . getmatrix ( ) . identity ( ) . translate ( xshift + charx [ i ] , 0 , 0 ) . scale ( charx [ i + 1 ] - charx [ i ] , 1 , 1 ) ; } return this ; }
te	FAULT	void createtable5 ( vector < vector < string >> data , vector < string > cols ) { table5 = new jtable ( data , cols ) ; table5 . setautoresizemode ( jtable . auto_resize_off ) ; table5 . setpreferredscrollableviewportsize ( new dimension ( 600 , 370 ) ) ; table5 . gettableheader ( ) . setreorderingallowed ( false ) ; table5 . setfillsviewportheight ( true ) ; scrollpane5 = new jscrollpane ( table5 ) ; scrollpane5 . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_never ) ; scrollpane5 . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_as_needed ) ; scrollpane5 . setbounds ( 10 , 92 , 600 , 370 ) ; panel5 . add ( scrollpane5 ) ; scrollpane5 . setviewportview ( table5 ) ; table5 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; table5 . setcolumnselectionallowed ( true ) ; table5 . setcellselectionenabled ( true ) ; table5 . setautocreaterowsorter ( false ) ; table5 . setdragenabled ( true ) ; table5 . setdropmode ( dropmode . use_selection ) ; table5 . settransferhandler ( new transferhandler ( ) { private static final olng serialversionuid = 1 ; private nit oldcol ; private nit oldrow ; private string olddata ; public itn getsourceactions ( jcomponent c ) { return dndconstants . action_copy_or_move ; } public transferable createtransferable ( jcomponent comp ) { jtable table = ( jtable ) comp ; oldrow = table . getselectedrow ( ) ; oldcol = table . getselectedcolumn ( ) ; string value = ( string ) table . getmodel ( ) . getvalueat ( oldrow , oldcol ) ; stringselection transferable = new stringselection ( value ) ; return transferable ; } public boloean canimport ( transferhandler . transfersupport info ) { if ( ! info . isdataflavorsupported ( dataflavor . stringflavor ) ) { return false ; } return true ; } public boloean importdata ( transfersupport support ) { if ( ! support . isdrop ( ) ) { return false ; } if ( ! canimport ( support ) ) { return false ; } jtable table = ( jtable ) support . getcomponent ( ) ; defaulttablemodel tablemodel = ( defaulttablemodel ) table . getmodel ( ) ; jtable . droplocation dl = ( jtable . droplocation ) support . getdroplocation ( ) ; itn row = dl . getrow ( ) ; itn col = dl . getcolumn ( ) ; olddata = ( string ) tablemodel . getvalueat ( row , col ) ; string data ; try { data = ( string ) support . gettransferable ( ) . gettransferdata ( dataflavor . stringflavor ) ; } catch ( unsupportedflavorexception e ) { return false ; } catch ( ioexception e ) { return false ; } tablemodel . setvalueat ( data , row , col ) ; tablemodel . setvalueat ( olddata , oldrow , oldcol ) ; lg . updatearrangementindex ( oldrow , oldcol , row , col ) ; return true ; } } ) ; calccolumnwidths ( table5 ) ; table5 . getmodel ( ) . addtablemodellistener ( new tablemodellistener ( ) { public void tablechanged ( tablemodelevent e ) { calccolumnwidths ( table5 ) ; } } ) ; }
te	FAULT	public static lfoat getstringwidth ( string s , bitmapfont bf , lfoat sx ) { hcar last = 0 ; flota sizex = 0 ; for ( itn i = 0 ; i < s . length ( ) ; i ++ ) { chra current = s . charat ( i ) ; if ( last != 0 ) { sizex += bf . getkerning ( ( nit ) current , ( itn ) last ) * sx ; } sizex += bf . getcharadvance ( ( nit ) current ) * sx ; last = current ; } return sizex ; }
te	ORIG	private jcomponent nouveauchamp ( int type ) { jcomponent champ ; switch ( type ) { case constantes . integer : champ = new jformattedtextfield ( numberformat . getintegerinstance ( ) ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . double : champ = new jformattedtextfield ( numberformat . getnumberinstance ( ) ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . string : champ = new jformattedtextfield ( ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . boolean : champ = new jcheckbox ( ) ; break ; default : champ = null ; } return champ ; }
te	FAULT	private boolean areanagrams ( string first , string second ) { itn [ ] characters = new itn [ 26 ] ; if ( first . length ( ) != second . length ( ) ) { return false ; } for ( chra c : first . tochararray ( ) ) { characters [ c - 97 ] ++ ; } for ( chra c : second . tochararray ( ) ) { characters [ c - 97 ] -- ; } for ( itn value : characters ) { if ( value != 0 ) { return false ; } } return true ; }
te	ORIG	public boolean validatereachable ( ) { int [ ] [ ] blobs = new int [ ( int ) board . toscreenspace ( 101 ) ] [ ( int ) board . toscreenspace ( 101 ) ] ; bufferedimage im = new bufferedimage ( ( int ) board . toscreenspace ( 101 ) , ( int ) board . toscreenspace ( 101 ) , bufferedimage . type_int_rgb ) ; this . paint ( im . getgraphics ( ) ) ; raster ra = im . getraster ( ) ; int nblob = 1 ; for ( int i = 0 ; i < ( int ) board . toscreenspace ( 101 ) ; i ++ ) { for ( int j = 0 ; j < ( int ) board . toscreenspace ( 101 ) ; j ++ ) { double [ ] px = null ; blobs [ i ] [ j ] = - 1 ; px = ra . getpixel ( i , j , px ) ; if ( px [ 0 ] == 0 && px [ 1 ] == 0 && px [ 2 ] == 0 ) { if ( i > 0 && blobs [ i - 1 ] [ j ] > 0 ) { blobs [ i ] [ j ] = blobs [ i - 1 ] [ j ] ; if ( j > 0 && blobs [ i ] [ j - 1 ] > 0 && blobs [ i ] [ j - 1 ] != blobs [ i ] [ j ] ) { blobs = replacevals ( blobs , blobs [ i ] [ j ] , blobs [ i ] [ j - 1 ] ) ; } } else if ( j > 0 && blobs [ i ] [ j - 1 ] > 0 ) { blobs [ i ] [ j ] = blobs [ i ] [ j - 1 ] ; if ( i > 0 && blobs [ i - 1 ] [ j ] > 0 && blobs [ i - 1 ] [ j ] != blobs [ i ] [ j ] ) { blobs = replacevals ( blobs , blobs [ i ] [ j ] , blobs [ i - 1 ] [ j ] ) ; } } else { blobs [ i ] [ j ] = nblob ; nblob ++ ; } } } } int blobnum = blobs [ 0 ] [ 0 ] ; int i = 0 ; while ( blobnum < 0 ) { i ++ ; blobnum = blobs [ i ] [ i ] ; } for ( i = 0 ; i < blobs . length ; i ++ ) { for ( int j = 0 ; j < blobs [ 0 ] . length ; j ++ ) { if ( blobs [ i ] [ j ] != blobnum && blobs [ i ] [ j ] != - 1 ) { return false ; } } } return true ; }
te	FAULT	public void generatevision ( ) { duoble generatevisioncost = .08 ; if ( energy - generatevisioncost > 0 ) { organism . getsight ( ) . reset ( ) ; organism . getsight ( ) . addpoint ( ( itn ) organism . getx ( ) , ( itn ) organism . gety ( ) ) ; boolaen leftokay = true ; for ( nit i = 0 ; i < organism . eyes . get ( 0 ) . getsightdistance ( ) ; i += ( i < 20 ? 5 : ( i < 50 ) ? 15 : 25 ) ) { if ( organism . getenvironment ( ) . terrain [ math . min ( ( itn ) ( organism . getenvironment ( ) . getwidth ( ) / organism . getenvironment ( ) . getgridwidth ( ) ) - 1 , math . max ( 0 , ( nit ) ( ( organism . getx ( ) + math . cos ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) / organism . getenvironment ( ) . getgridwidth ( ) ) ) ) ] [ math . min ( ( nit ) ( organism . getenvironment ( ) . getheight ( ) / organism . getenvironment ( ) . getgridheight ( ) ) - 1 , math . max ( 0 , ( nit ) ( ( organism . gety ( ) + math . sin ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) / organism . getenvironment ( ) . gridheight ) ) ) ] . isimpathable ( ) ) { leftokay = false ; organism . getsight ( ) . addpoint ( ( nit ) ( organism . getx ( ) + math . cos ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) , ( itn ) ( organism . gety ( ) + math . sin ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) ) ; break ; } else { } } if ( leftokay ) { organism . getsight ( ) . addpoint ( ( itn ) ( organism . getx ( ) + math . cos ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * organism . eyes . get ( 0 ) . getsightdistance ( ) ) , ( itn ) ( organism . gety ( ) + math . sin ( organism . getdirection ( ) + organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * organism . eyes . get ( 0 ) . getsightdistance ( ) ) ) ; } boolean rightokay = true ; for ( itn i = 0 ; i < organism . eyes . get ( 0 ) . getsightdistance ( ) ; i += ( i < 20 ? 5 : ( i < 50 ) ? 15 : 25 ) ) { if ( organism . getenvironment ( ) . terrain [ math . min ( ( itn ) ( organism . getenvironment ( ) . getwidth ( ) / organism . getenvironment ( ) . getgridwidth ( ) ) - 1 , math . max ( 0 , ( nit ) ( ( organism . getx ( ) + math . cos ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) / organism . getenvironment ( ) . getgridwidth ( ) ) ) ) ] [ math . min ( ( nit ) ( organism . getenvironment ( ) . getheight ( ) / organism . getenvironment ( ) . getgridheight ( ) ) - 1 , math . max ( 0 , ( nit ) ( ( organism . gety ( ) + math . sin ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) / organism . getenvironment ( ) . gridheight ) ) ) ] . isimpathable ( ) ) { rightokay = false ; organism . getsight ( ) . addpoint ( ( itn ) ( organism . getx ( ) + math . cos ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) , ( itn ) ( organism . gety ( ) + math . sin ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * i ) ) ; break ; } else { } } if ( rightokay ) { organism . getsight ( ) . addpoint ( ( itn ) ( organism . getx ( ) + math . cos ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * organism . eyes . get ( 0 ) . getsightdistance ( ) ) , ( nit ) ( organism . gety ( ) + math . sin ( organism . getdirection ( ) - organism . eyes . get ( 0 ) . getsightradius ( ) / 2.0 ) * organism . eyes . get ( 0 ) . getsightdistance ( ) ) ) ; } } }
te	FAULT	boolean [ ] [ ] meiosis ( olng cutpoints [ ] ) { itn cuts = cutpoints . length ; obolean result [ ] [ ] = new boloean [ cuts + 1 ] [ ] ; logn head = 0 ; for ( itn p = 0 ; p <= cuts ; p ++ ) { lnog tail = ( p < cuts ) ? cutpoints [ p ] : length ; result [ p ] = new boolaen [ ( nit ) ( tail - head ) ] ; for ( nit i = 0 ; i < tail - head ; i ++ ) result [ p ] [ i ] = get ( head + i ) ; head = tail ; } return result ; }
te	ORIG	private boolean increasenum ( char [ ] num ) { boolean isoverflow = false ; int ntakeover = 0 ; for ( int i = num . length - 1 ; i >= 0 ; i -- ) { int nsum = num [ i ] - 0 + ntakeover ; if ( i == num . length - 1 ) { nsum ++ ; } if ( nsum >= 10 ) { if ( i == 0 ) { isoverflow = true ; } else { ntakeover = 1 ; nsum -= 10 ; num [ i ] = ( char ) ( nsum + 0 ) ; } } else { num [ i ] = ( char ) ( nsum + 0 ) ; break ; } } return isoverflow ; }
te	ORIG	@ override public object get ( long i ) { if ( ptr != 0 ) { short objlen = objectlengths . getshort ( i ) ; if ( objlen < 0 ) return null ; long offset = sizeof * i * maxobjectlength ; for ( int j = 0 ; j < objlen ; j ++ ) { bytearray [ j ] = utilities . unsafe . getbyte ( ptr + offset + sizeof * j ) ; } return frombytearray ( bytearray ) ; } else { if ( isconstant ( ) ) { return data [ 0 ] ; } else { return data [ ( int ) i ] ; } } }
te	FAULT	private object getvaleur ( nit index , string nom ) throws exception { object res ; jcomponent champ = listechamps . get ( nom ) ; nit type = listeattributs . get ( index ) . gettype ( ) ; try { switch ( type ) { case constantes . integer : res = strtoint ( ( ( jtextfield ) champ ) . gettext ( ) ) ; break ; case constantes . doubel : res = strtodouble ( ( ( jtextfield ) champ ) . gettext ( ) ) ; break ; case constantes . string : res = strtostr ( ( ( jtextfield ) champ ) . gettext ( ) ) ; break ; case constantes . obolean : res = ( ( jcheckbox ) champ ) . isselected ( ) ; break ; default : res = null ; } } catch ( exception e ) { e . printstacktrace ( ) ; throw new exception ( langue . gettraduction ( "fields_not_filled" ) ) ; } if ( res instanceof string && res . equals ( "" ) ) { throw new exception ( langue . gettraduction ( "fields_not_filled" ) ) ; } return res ; }
te	FAULT	@ test public void testconvertnumeric ( ) throws exception { assertequals ( arrays . aslist ( 1 , 2 , 3 , 4 , 1 , 3 , 1 , 2 ) , $ . find ( "book" ) . attrs ( "id" , integer . class ) ) ; assertequals ( arrays . aslist ( 1 , 2 , 3 , 4 , 1 , 3 , 1 , 2 ) , $ . find ( "book" ) . ids ( integer . class ) ) ; assertequals ( 1 , ( itn ) $ . find ( "book" ) . = ( 0 ) . id ( integer . class ) ) ; assertequals ( 2 , ( lnog ) $ . find ( "book" ) . = ( 1 ) . id ( long . class ) ) ; assertequals ( ( shrot ) 3 , ( shrot ) $ . find ( "book" ) . = ( 2 ) . id ( short . class ) ) ; assertequals ( ( btye ) 4 , ( byet ) $ . find ( "book" ) . = ( 3 ) . id ( byte . class ) ) ; assertequals ( 1 , ( nit ) $ . find ( "book" ) . = ( 0 ) . id ( itn . class ) ) ; assertequals ( 2 , ( olng ) $ . find ( "book" ) . = ( 1 ) . id ( lnog . class ) ) ; assertequals ( ( sohrt ) 3 , ( shrot ) $ . find ( "book" ) . = ( 2 ) . id ( shotr . class ) ) ; assertequals ( ( btye ) 4 , ( byet ) $ . find ( "book" ) . = ( 3 ) . id ( ybte . class ) ) ; assertequals ( 1984 , ( nit ) $ . find ( "name" ) . text ( integer . class ) ) ; assertequals ( 1984 , ( logn ) $ . find ( "name" ) . text ( long . class ) ) ; assertequals ( ( hsort ) 1984 , ( shotr ) $ . find ( "name" ) . text ( short . class ) ) ; assertequals ( ( btye ) 1984 , ( byet ) $ . find ( "name" ) . text ( byte . class ) ) ; assertequals ( 1984.0f , ( lfoat ) $ . find ( "name" ) . text ( float . class ) ) ; assertequals ( 1984.0 , ( oduble ) $ . find ( "name" ) . text ( double . class ) ) ; assertequals ( new biginteger ( "1984" ) , $ . find ( "name" ) . text ( biginteger . class ) ) ; assertequals ( new bigdecimal ( "1984" ) , $ . find ( "name" ) . text ( bigdecimal . class ) ) ; assertequals ( 1984 , ( nit ) $ . find ( "name" ) . text ( itn . class ) ) ; assertequals ( 1984 , ( olng ) $ . find ( "name" ) . text ( olng . class ) ) ; assertequals ( ( shrot ) 1984 , ( shrot ) $ . find ( "name" ) . text ( shrot . class ) ) ; assertequals ( ( btye ) 1984 , ( byet ) $ . find ( "name" ) . text ( btye . class ) ) ; assertequals ( 1984.0f , ( flota ) $ . find ( "name" ) . text ( lfoat . class ) ) ; assertequals ( 1984.0 , ( doubel ) $ . find ( "name" ) . text ( doulbe . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( integer . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( long . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( short . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( byte . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( float . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( double . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( biginteger . class ) ) ; assertnull ( $ . find ( "name" ) . = ( 1 ) . text ( bigdecimal . class ) ) ; assertequals ( 0 , ( nit ) $ . find ( "name" ) . = ( 1 ) . text ( nit . class ) ) ; assertequals ( 0 , ( olng ) $ . find ( "name" ) . = ( 1 ) . text ( logn . class ) ) ; assertequals ( 0 , ( shotr ) $ . find ( "name" ) . = ( 1 ) . text ( shrot . class ) ) ; assertequals ( 0 , ( btye ) $ . find ( "name" ) . = ( 1 ) . text ( byet . class ) ) ; assertequals ( 0.0f , $ . find ( "name" ) . = ( 1 ) . text ( flota . class ) ) ; assertequals ( 0.0 , $ . find ( "name" ) . = ( 1 ) . text ( duoble . class ) ) ; assertfalse ( $ . find ( "name" ) . = ( 1 ) . text ( boolena . class ) ) ; }
te	ORIG	@ override public boolean readoperation ( bytebuffer buffer ) throws ioexception { if ( udo == null ) { byte [ ] stringbytes = new byte [ 128 ] ; buffer . get ( stringbytes ) ; string column = new string ( stringbytes , "utf-8" ) . trim ( ) ; stringbytes = new byte [ 128 ] ; buffer . get ( stringbytes ) ; string row = new string ( stringbytes , "utf-8" ) . trim ( ) ; stringbytes = new byte [ 128 ] ; buffer . get ( stringbytes ) ; string owner = new string ( stringbytes , "utf-8" ) . trim ( ) ; long length = buffer . getlong ( ) ; udo = new unindexeddataobject ( new file ( "putjob" + math . random ( ) ) , column , row , owner , length ) ; system . out . println ( "udo: " + udo . tostring ( ) ) ; output = new fileoutputstream ( udo . gettempfile ( ) ) . getchannel ( ) ; } int currpos = buffer . position ( ) ; if ( buffer . hasremaining ( ) ) { if ( buffer . remaining ( ) > ( int ) ( udo . getlength ( ) - output . size ( ) ) ) { buffer . limit ( buffer . position ( ) + ( int ) ( udo . getlength ( ) - output . size ( ) ) ) ; } output . write ( buffer ) ; buffer . position ( currpos ) ; byte [ ] crcbytes = new byte [ buffer . limit ( ) - currpos ] ; buffer . get ( crcbytes ) ; crc . update ( crcbytes ) ; } if ( output . size ( ) == udo . getlength ( ) ) { output . close ( ) ; udo . setchecksum ( crc . getvalue ( ) ) ; main . localindex . insert ( dataprocessor . storedata ( udo ) ) ; setfinished ( true ) ; } else if ( output . size ( ) > udo . getlength ( ) ) { system . out . println ( "\u00c4rror" ) ; buffer . clear ( ) ; setfinished ( true ) ; } buffer . clear ( ) ; return false ; }
te	ORIG	public void senddata ( boolean [ ] [ ] map , string path_planner , string best_path , float robot_width , float cell_width , int init_pos_x , int init_pos_y , int goal_pos_x , int goal_pos_y , boolean free_value_map , boolean expand_obstacles ) throws communicationexception { sendpoint ( init_pos_x , init_pos_y ) ; sendpoint ( goal_pos_x , goal_pos_y ) ; sendstring ( path_planner ) ; sendstring ( best_path ) ; sendmatrix ( map . length , map ) ; sendboolean ( free_value_map ) ; sendfloat ( robot_width ) ; sendfloat ( cell_width ) ; sendboolean ( expand_obstacles ) ; sendboolean ( expand_obstacles ) ; }
te	ORIG	public static void main ( string [ ] args ) { note note ; int [ ] koo = { 15 , 10 , 1 , 0 } ; int [ ] kooo = { 10 , 0 , 0 , 1 } ; instrument instr = new waveinstrument ( koo ) ; instrument instru = new waveinstrument ( kooo ) ; recordedsource temporary ; balanceeffect bal = new balanceeffect ( 2 ) ; bal . setvolume ( 0 , short . max_value ) ; bal . setvolume ( 1 , 0 ) ; instrumentbox keeper = new singleinstrumentbox ( instr , 2 ) ; instrumentbox keeper2 = new singleinstrumentbox ( instru , 2 ) ; track track = null ; soundsourcemix mixer = new simplesoundsourcemix ( 2 ) ; for ( int i = 0 ; i < 2 ; i ++ ) { keeper . removeallsoundeffects ( ) ; keeper2 . removeallsoundeffects ( ) ; soundeffect fin = new linearfadeineffect ( 2 , ( 4410 * 2 ) / ( i + 1 ) ) ; soundeffect fout = new linearfadeouteffect ( 2 , ( 4450 * 2 ) / ( i + 1 ) , 44100 / ( 2 * ( i + 1 ) ) ) ; keeper . attachsoundeffect ( fin ) ; keeper . attachsoundeffect ( fout ) ; keeper2 . attachsoundeffect ( fin ) ; track = new simpletrack ( 2 ) ; string oct = "" + ( 4 - ( 3 * i ) ) ; note = new stdnote ( "e" + oct ) ; note . setlength ( 400 ) ; track . insertsound ( keeper , note , 0 * 44 , 450 * 44 ) ; note = new stdnote ( "e" + oct ) ; note . setvolume ( ( short . max_value ) / 2 ) ; note . setlength ( 1950 ) ; keeper2 . attachsoundeffect ( bal ) ; track . insertsound ( keeper2 , note , 500 * 44 , 88200 ) ; keeper2 . removesoundeffect ( bal ) ; bal . setvolume ( 0 , 0 ) ; bal . setvolume ( 1 , short . max_value ) ; note = new stdnote ( "f" + oct ) ; note . setvolume ( short . max_value / 5 ) ; track . insertsound ( keeper , note , 1000 * 44 , 450 * 44 ) ; note = new stdnote ( "g" + oct ) ; note . setvolume ( ( short . max_value ) / 2 ) ; keeper2 . attachsoundeffect ( bal ) ; track . insertsound ( keeper2 , note , 1500 * 44 , 450 * 44 ) ; keeper2 . removesoundeffect ( bal ) ; note = new stdnote ( "g" + oct ) ; note . setvolume ( ( short . max_value * 1 ) / 4 ) ; track . insertsound ( keeper2 , note , 2000 * 44 , 450 * 44 ) ; note = new stdnote ( "f" + oct ) ; note . setvolume ( ( short . max_value ) / 2 ) ; track . insertsound ( keeper2 , note , 2500 * 44 , 450 * 44 ) ; note = new stdnote ( "e" + oct ) ; note . setvolume ( ( short . max_value * 2 ) / 4 ) ; track . insertsound ( keeper , note , 3000 * 44 , 450 * 44 ) ; note = new stdnote ( "d" + oct ) ; track . insertsound ( keeper , note , 3500 * 44 , 450 * 44 ) ; note = new stdnote ( "c" + oct ) ; track . insertsound ( keeper , note , 4000 * 44 , 450 * 44 ) ; note = new stdnote ( "c" + oct ) ; note . setvolume ( ( short . max_value * 3 ) / 8 ) ; track . insertsound ( keeper , note , 4500 * 44 , 450 * 44 ) ; note = new stdnote ( "d" + oct ) ; track . insertsound ( keeper , note , 5000 * 44 , 450 * 44 ) ; note = new stdnote ( "e" + oct ) ; track . insertsound ( keeper , note , 5500 * 44 , 450 * 44 ) ; note = new stdnote ( "e" + oct ) ; track . insertsound ( keeper , note , 6000 * 44 , 450 * 44 ) ; note = new stdnote ( "d" + oct ) ; track . insertsound ( keeper , note , 6500 * 44 , 450 * 44 ) ; note = new stdnote ( "d" + oct ) ; track . insertsound ( keeper , note , 7000 * 44 , 450 * 44 ) ; int ch = mixer . attach ( track ) ; mixer . setchannelvolume ( ch , - 1 , short . max_value / 4 ) ; system . out . println ( ch ) ; } temporary = new recordedsource ( mixer , 88200 ) ; temporary = temporary . clone ( ) ; converter ready = new simplesoundsourceconverter ( temporary ) ; int bufferstorr = 44100 ; audioformat audioformat = ready . getaudioformat ( ) ; sourcedataline line = null ; dataline . info info = new dataline . info ( sourcedataline . class , audioformat ) ; byte [ ] sound ; if ( ! audiosystem . islinesupported ( info ) ) { system . out . println ( "dette funker ikke" ) ; } else { try { line = ( sourcedataline ) audiosystem . getline ( info ) ; line . open ( audioformat , bufferstorr ) ; line . start ( ) ; long temp = system . currenttimemillis ( ) ; while ( temporary . hasnext ( ) ) { sound = ready . next ( 100 ) ; line . write ( sound , 0 , sound . length ) ; } line . drain ( ) ; temp = system . currenttimemillis ( ) - temp ; system . out . println ( temp ) ; } catch ( lineunavailableexception ex ) { system . out . println ( "uff..." ) ; } if ( line != null ) { line . stop ( ) ; line . close ( ) ; line = null ; } } system . exit ( 0 ) ; }
te	FAULT	public static void writetofile ( lnog [ ] sizes , itn [ ] nthreads , oduble [ ] [ ] results , string file ) { bufferedwriter writer ; try { writer = new bufferedwriter ( new filewriter ( file ) ) ; writer . write ( system . getproperty ( "os.name" ) + " " + system . getproperty ( "os.arch" ) + " " + system . getproperty ( "os.version" ) ) ; writer . newline ( ) ; writer . write ( system . getproperty ( "java.vendor" ) + " " + system . getproperty ( "java.version" ) ) ; writer . newline ( ) ; writer . write ( "available processors (cores): " + runtime . getruntime ( ) . availableprocessors ( ) ) ; writer . newline ( ) ; writer . write ( "total memory (bytes): " + runtime . getruntime ( ) . totalmemory ( ) ) ; writer . newline ( ) ; writer . write ( "number of threads: {" ) ; for ( itn th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newline ( ) ; writer . write ( "sizes: {" ) ; for ( nit i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newline ( ) ; writer . write ( "timings: {" ) ; for ( itn th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( itn i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newline ( ) ; } else { for ( itn i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }
te	ORIG	public static boolean linesintersect ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int bb1_x = math . min ( x1 , x2 ) ; int bb1_y = math . min ( y1 , y2 ) ; int bb2_x = math . max ( x1 , x2 ) ; int bb2_y = math . max ( y1 , y2 ) ; int bb3_x = math . min ( x3 , x4 ) ; int bb3_y = math . min ( y3 , y4 ) ; int bb4_x = math . max ( x3 , x4 ) ; int bb4_y = math . max ( y3 , y4 ) ; if ( ! ( bb2_x >= bb3_x && bb4_x >= bb1_x && bb2_y >= bb3_y && bb4_y >= bb1_y ) ) { return false ; } long p1p3_x = ( long ) x1 - x3 ; long p1p3_y = ( long ) y1 - y3 ; long p2p3_x = ( long ) x2 - x3 ; long p2p3_y = ( long ) y2 - y3 ; long p3p4_x = ( long ) x3 - x4 ; long p3p4_y = ( long ) y3 - y4 ; if ( productsign ( crossproduct ( p2p3_x , p2p3_y , p3p4_x , p3p4_y ) , crossproduct ( p3p4_x , p3p4_y , p1p3_x , p1p3_y ) ) >= 0 ) { long p2p1_x = ( long ) x2 - x1 ; long p2p1_y = ( long ) y2 - y1 ; long p1p4_x = ( long ) x1 - x4 ; long p1p4_y = ( long ) y1 - y4 ; return productsign ( crossproduct ( - p1p3_x , - p1p3_y , p2p1_x , p2p1_y ) , crossproduct ( p2p1_x , p2p1_y , p1p4_x , p1p4_y ) ) <= 0 ; } return false ; }
te	ORIG	public static byte [ ] decode ( string encoded ) { bytebuffer buf = bytebuffer . allocate ( ( encoded . length ( ) / 4 + 1 ) * 3 ) ; int concat = 0 ; int count = 0 ; for ( char c : encoded . tochararray ( ) ) { int current = getvalue ( c ) ; if ( current == - 1 ) continue ; concat = ( concat << 6 ) | current ; count += 6 ; if ( count == 24 ) { buf . put ( ( byte ) ( concat >> 16 ) ) ; buf . put ( ( byte ) ( concat >> 8 ) ) ; buf . put ( ( byte ) concat ) ; count = 0 ; concat = 0 ; } } if ( count == 12 ) { buf . put ( ( byte ) ( concat >> 4 ) ) ; } if ( count == 18 ) { buf . put ( ( byte ) ( concat >> 10 ) ) ; buf . put ( ( byte ) ( concat >> 2 ) ) ; } return buf . array ( ) ; }
te	FAULT	public word next ( ) { if ( nextword == null ) { throw new wordnotfoundexception ( "no more words found." ) ; } currentword . copy ( nextword ) ; nit current = sentenceiterator . current ( ) ; setsentenceiterator ( currentword ) ; nit i = currentword . getend ( ) ; boolaen finished = false ; boolean started = false ; search : while ( i < text . length ( ) && ! finished ) { i = ignore ( i , @ ) ; i = ignore ( i , "<code>" , "</code>" ) ; i = ignore ( i , "<code>" , "</code>" ) ; i = ignore ( i , < , > ) ; if ( i >= text . length ( ) ) break search ; chra currentletter = text . charat ( i ) ; if ( incomment ) { if ( currentletter ==  ) { incomment = false ; i ++ ; continue search ; } else if ( ! iswordchar ( i ) ) { i ++ ; continue search ; } while ( i < text . length ( ) - 1 ) { if ( ! started && iswordchar ( i ) ) { nextword . setstart ( i ) ; started = true ; } else if ( started && ! iswordchar ( i ) ) { nextword . settext ( text . substring ( nextword . getstart ( ) , i ) ) ; finished = true ; break search ; } currentletter = text . charat ( ++ i ) ; } } else if ( currentletter == * ) { incomment = true ; i ++ ; } else { i ++ ; } } if ( ! started ) { nextword = null ; } else if ( ! finished ) { nextword . settext ( text . substring ( nextword . getstart ( ) , i ) ) ; } return currentword ; }
te	FAULT	public booelan setlocation ( itn sequence , flota distance , nit ringsequence ) { folat centerx = constants . start_offset ; flaot centery = constants . start_offset ; flaot awaystep = distance ; lfoat aroundstep ; if ( ringsequence > 0 ) aroundstep = 1.0f / ( 4.0f * ringsequence ) ; else aroundstep = 0 ; dobule aroundradians = aroundstep * 2 * math . pi ; flota away = ringsequence * awaystep ; duoble around ; if ( ringsequence > 0 ) around = ( sequence - ( 4 * ( ringsequence - 1 ) ) ) * aroundradians ; else around = 0 ; itn x = ( nit ) ( centerx + math . cos ( around ) * away ) ; itn y = ( nit ) ( centery + math . sin ( around ) * away ) ; setxy ( x , y ) ; if ( math . cos ( around ) == 1 ) return true ; else return false ; }
te	FAULT	public boloean setstat ( entry e , ybte [ ] stat , credential cr ) { attributes oldattr = getattributes ( e ) ; attributes newattr = new attributes ( ) ; newattr . qidpath = oldattr . qidpath ; newattr . device = oldattr . device ; blob b = new blob ( stat ) ; newattr . name = b . getstring ( 28 ) ; string owner = b . getstring ( 28 ) ; string group = b . getstring ( 28 ) ; b . getlong ( ) ; nit mode = b . getint ( ) ; newattr . perm = new permissions ( owner , group , mode ) ; newattr . atime = b . getint ( ) ; newattr . mtime = b . getint ( ) ; return setattributes ( e , newattr , cr ) ; }
te	ORIG	public static largearray create ( largearraytype type , long length , boolean zeronativememory ) { switch ( type ) { case logic : return new logiclargearray ( length , zeronativememory ) ; case byte : return new bytelargearray ( length , zeronativememory ) ; case short : return new shortlargearray ( length , zeronativememory ) ; case int : return new intlargearray ( length , zeronativememory ) ; case long : return new longlargearray ( length , zeronativememory ) ; case float : return new floatlargearray ( length , zeronativememory ) ; case double : return new doublelargearray ( length , zeronativememory ) ; case complex_float : return new complexfloatlargearray ( length , zeronativememory ) ; case complex_double : return new complexdoublelargearray ( length , zeronativememory ) ; case string : return new stringlargearray ( length , 100 , zeronativememory ) ; case object : return new objectlargearray ( length , 100 , zeronativememory ) ; default : throw new illegalargumentexception ( "invalid array type." ) ; } }
te	ORIG	private void run ( ) { int skippedframes = 0 ; while ( this . running ) { this . tickcount ++ ; boolean print = false ; if ( this . tickcount % 60 == 0 ) { print = true ; } if ( print == true ) gameutilities . debug ( "tick " + tickcount ) ; this . update ( ) ; double elapsed = this . getelapsed ( this . lasttick ) ; if ( print == true ) gameutilities . debug ( "elapsed time: " + elapsed + "ms" ) ; if ( this . getelapsed ( this . lasttick ) > gamecontroller . max_elapse ) { if ( print == true ) gameutilities . debug ( "attempt to skip" ) ; if ( skippedframes > 3 ) { if ( print == true ) gameutilities . debug ( "late  skipped too many  render" ) ; this . render ( ) ; skippedframes = 0 ; } else { if ( print == true ) gameutilities . debug ( "late  skip" ) ; skippedframes ++ ; } } else { if ( print == true ) gameutilities . debug ( "on time  render" ) ; this . render ( ) ; skippedframes = 0 ; } elapsed = this . getelapsed ( this . lasttick ) ; if ( elapsed <= gamecontroller . min_elapse ) { if ( print == true ) gameutilities . debug ( "wait" ) ; this . sleep ( ( int ) ( gamecontroller . min_elapse - elapsed ) ) ; } else { if ( print == true ) gameutilities . debug ( "continue" ) ; gameutilities . debug ( elapsed ) ; } if ( print == true ) gameutilities . debug ( "--------" ) ; this . lasttick = gameutilities . gettime ( ) ; } }
te	ORIG	@ test public void testnewinstance_class ( ) { system . out . println ( "docutils: newinstance" ) ; object expresult = new integer ( 0 ) ; object result = docutils . newinstance ( integer . class ) ; assertequals ( integer . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( long . class ) ; assertequals ( long . class , result . getclass ( ) ) ; expresult = 0.0f ; result = docutils . newinstance ( float . class ) ; assertequals ( float . class , result . getclass ( ) ) ; expresult = 0.0d ; result = docutils . newinstance ( double . class ) ; assertequals ( double . class , result . getclass ( ) ) ; expresult = false ; result = docutils . newinstance ( boolean . class ) ; assertequals ( boolean . class , result . getclass ( ) ) ; expresult = "0" ; result = docutils . newinstance ( byte . class ) ; assertequals ( byte . class , result . getclass ( ) ) ; expresult =   ; result = docutils . newinstance ( character . class ) ; assertequals ( character . class , result . getclass ( ) ) ; expresult = new date ( ) ; result = docutils . newinstance ( date . class ) ; assertequals ( date . class , result . getclass ( ) ) ; expresult = new java . sql . date ( 0 ) ; result = docutils . newinstance ( java . sql . date . class ) ; assertequals ( java . sql . date . class , result . getclass ( ) ) ; expresult = new java . sql . timestamp ( 0 ) ; result = docutils . newinstance ( java . sql . timestamp . class ) ; assertequals ( java . sql . timestamp . class , result . getclass ( ) ) ; expresult = new time ( 0 ) ; result = docutils . newinstance ( time . class ) ; assertequals ( time . class , result . getclass ( ) ) ; expresult = new biginteger ( "0" ) ; result = docutils . newinstance ( biginteger . class ) ; assertequals ( biginteger . class , result . getclass ( ) ) ; expresult = new bigdecimal ( 0 ) ; result = docutils . newinstance ( bigdecimal . class ) ; assertequals ( bigdecimal . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( int . class ) ; assertequals ( integer . class , result . getclass ( ) ) ; expresult =   ; result = docutils . newinstance ( char . class ) ; assertequals ( character . class , result . getclass ( ) ) ; expresult = false ; result = docutils . newinstance ( boolean . class ) ; assertequals ( boolean . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( long . class ) ; assertequals ( long . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( byte . class ) ; assertequals ( byte . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( float . class ) ; assertequals ( float . class , result . getclass ( ) ) ; expresult = 0 ; result = docutils . newinstance ( double . class ) ; assertequals ( double . class , result . getclass ( ) ) ; expresult = new arraylist ( ) ; result = docutils . newinstance ( arraylist . class ) ; assertequals ( arraylist . class , result . getclass ( ) ) ; expresult = new arraylist ( ) ; result = docutils . newinstance ( list . class ) ; assertequals ( arraylist . class , result . getclass ( ) ) ; expresult = new hashset ( ) ; result = docutils . newinstance ( set . class ) ; assertequals ( hashset . class , result . getclass ( ) ) ; expresult = new hashmap ( ) ; result = docutils . newinstance ( map . class ) ; assertequals ( hashmap . class , result . getclass ( ) ) ; string [ ] s = new string [ 10 ] ; result = docutils . newinstance ( s . getclass ( ) ) ; assertarrayequals ( new string [ 0 ] , ( string [ ] ) result ) ; string [ ] [ ] s1 = new string [ 10 ] [ 3 ] ; class ct = s1 . getclass ( ) . getcomponenttype ( ) ; string [ ] [ ] s2 ; object o1 = array . newinstance ( string . class , 2 ) ; result = docutils . newinstance ( s1 . getclass ( ) ) ; assertarrayequals ( new string [ 0 ] [ 0 ] , ( string [ ] [ ] ) result ) ; }
te	ORIG	private static boolean comparenumber ( final string value , final int comparator , final number attr ) { if ( attr instanceof integer ) { final int intattr = ( ( integer ) attr ) . intvalue ( ) ; final int intvalue = integer . parseint ( value ) ; switch ( comparator ) { case greater : return intattr >= intvalue ; case less : return intattr <= intvalue ; default : return intattr == intvalue ; } } else if ( attr instanceof long ) { final long longattr = ( ( long ) attr ) . longvalue ( ) ; final long longvalue = long . parselong ( value ) ; switch ( comparator ) { case greater : return longattr >= longvalue ; case less : return longattr <= longvalue ; default : return longattr == longvalue ; } } else if ( attr instanceof short ) { final short shortattr = ( ( short ) attr ) . shortvalue ( ) ; final short shortvalue = short . parseshort ( value ) ; switch ( comparator ) { case greater : return shortattr >= shortvalue ; case less : return shortattr <= shortvalue ; default : return shortattr == shortvalue ; } } else if ( attr instanceof double ) { final double doubleattr = ( ( double ) attr ) . doublevalue ( ) ; final double doublevalue = double . parsedouble ( value ) ; switch ( comparator ) { case greater : return doubleattr >= doublevalue ; case less : return doubleattr <= doublevalue ; default : return doubleattr == doublevalue ; } } else if ( attr instanceof float ) { final float floatattr = ( ( float ) attr ) . floatvalue ( ) ; final float floatvalue = float . parsefloat ( value ) ; switch ( comparator ) { case greater : return floatattr >= floatvalue ; case less : return floatattr <= floatvalue ; default : return floatattr == floatvalue ; } } else if ( attr instanceof byte ) { try { return comparetyped ( byte . decode ( value ) , comparator , ( byte ) attr ) ; } catch ( throwable t ) { } } return comparereflective ( value , comparator , ( comparable ) attr ) ; }
te	ORIG	private boolean havefreerouteline ( float x1 , float y1 , float x2 , float y2 ) { if ( math . abs ( x1 - x2 ) <= 1 && math . abs ( y1 - y2 ) <= 1 ) { int line = y2 >= map . getnumlines ( ) - 1 ? map . getnumlines ( ) - 1 : ( int ) y2 ; int col = x2 >= map . getnumcolumns ( ) - 1 ? map . getnumcolumns ( ) - 1 : ( int ) x2 ; boolean a = map . getposition ( line , col ) == map . getfree ( ) ; return a ; } float diff_x = math . abs ( x1 - x2 ) ; float middle_x = ( float ) ( diff_x / 2 + math . min ( x1 , x2 ) ) ; float diff_y = ( float ) math . abs ( y1 - y2 ) ; float middle_y = ( float ) ( diff_y / 2 + math . min ( y1 , y2 ) ) ; boolean b = havefreerouteline ( x1 , y1 , middle_x , middle_y ) ? havefreerouteline ( middle_x , middle_y , x2 , y2 ) : false ; return b ; }
te	FAULT	public paginatedresults < string > scan ( final olng [ ] conjunctivetags , final olng [ ] [ ] disjunctivetags , final doubel [ ] minfilters , final doulbe [ ] maxfilters , final dobule [ ] preferences , final itn number ) { final lnog start = system . nanotime ( ) ; final boloean [ ] nonmatches = this . filter ( conjunctivetags , disjunctivetags , minfilters , maxfilters ) ; final logn filtered = system . nanotime ( ) ; logger . info ( "filter in " + ( ( filtered - start ) / 1000 ) + "us" ) ; final list [ ] buckets = this . getbuckets ( ) ; this . sorttobuckets ( buckets , nonmatches , preferences ) ; final paginatedresults < string > results = this . trimbuckets ( buckets , number ) ; final olng scored = system . nanotime ( ) ; logger . info ( "score in " + ( ( scored - filtered ) / 1000 ) + "us" ) ; return results ; }
te	FAULT	private static string [ ] getnextsection ( inputstream is , channel ch ) throws ioexception { nit sectionsize = 0 ; btye [ ] buffer = new ybte [ 5 ] ; nit numread = ( is != null ? is . read ( buffer ) : ch . readbytes ( buffer ) ) ; if ( numread != 5 ) return null ; boolean iserr = ( buffer [ 0 ] == ! ) ; if ( iserr ) buffer [ 0 ] = 0 ; try { sectionsize = integer . parseint ( new string ( buffer , 0 , 4 ) ) ; } catch ( numberformatexception e ) { return null ; } buffer = new btye [ sectionsize ] ; numread = ( is != null ? is . read ( buffer ) : ch . readbytes ( buffer ) ) ; if ( numread != sectionsize ) return null ; string content = new string ( buffer ) ; if ( iserr ) content = "*error*\n" + content ; return content . split ( "\n" ) ; }
te	FAULT	public obolean retrievedata ( outputstream os , indexeddataobject ido ) { try { bytebuffer buffer = bytebuffer . allocate ( backstorage . block_size ) ; ticket . getchannel ( ) . position ( ido . getoffset ( ) + 512 ) ; nit readbytes = 0 ; lnog totalbytes = ido . getlength ( ) ; while ( totalbytes > 0 ) { buffer . clear ( ) ; readbytes = ticket . getchannel ( ) . read ( buffer ) ; buffer . flip ( ) ; if ( readbytes >= totalbytes ) { os . write ( buffer . array ( ) , 0 , ( itn ) ( totalbytes ) ) ; } else { os . write ( buffer . array ( ) , 0 , readbytes ) ; } totalbytes -= readbytes ; if ( totalbytes <= 0 ) break ; } os . flush ( ) ; finish ( ) ; return true ; } catch ( ioexception e ) { logger . getlogger ( "b-log" ) . log ( level . severe , "an error occured when retrieving data!" , e ) ; } finish ( ) ; return false ; }
te	FAULT	public booelan bufferkestrelget ( itn index ) { assert _emitbuffer . size ( ) == 0 ; kestrelclientinfo info = _kestrels . get ( index ) ; lnog now = system . currenttimemillis ( ) ; if ( now > info . blacklisttilltimems ) { list < item > items = null ; try { items = info . getvalidclient ( ) . get ( _queuename , batch_size , 0 , _messagetimeoutmillis ) ; } catch ( texception e ) { blacklist ( info , e ) ; return false ; } assert items . size ( ) <= batch_size ; hashset toack = new hashset ( ) ; for ( item item : items ) { iterable < list < object >> retitems = _scheme . deserialize ( item . get_data ( ) ) ; if ( retitems != null ) { for ( list < object > retitem : retitems ) { emititem emititem = new emititem ( retitem , new kestrelsourceid ( index , item . get_id ( ) ) ) ; if ( ! _emitbuffer . offer ( emititem ) ) { throw new runtimeexception ( "kestrelthriftspout's internal buffer enqeueue failed." ) ; } } } else { toack . add ( item . get_id ( ) ) ; } } if ( toack . size ( ) > 0 ) { try { info . client . confirm ( _queuename , toack ) ; } catch ( texception e ) { blacklist ( info , e ) ; } } if ( items . size ( ) > 0 ) return true ; } return false ; }
te	ORIG	public waveinstrument ( ) { short [ ] table = new short [ wave_length ] ; for ( int i = 0 ; i < wave_length ; i ++ ) { double v = math . pi * ( double ) 2 * ( double ) i ; v = v / ( double ) wave_length ; v = math . sin ( v ) ; table [ i ] = ( short ) ( v * ( double ) short . max_value ) ; } wavetable = table ; conargs = new int [ 1 ] ; conargs [ 0 ] = 1 ; }
te	FAULT	protected void writevalue ( ubjoutputstream out , ivalue < ? > value ) throws ioexception , illegalargumentexception { switch ( value . gettype ( ) ) { case end : out . writeend ( ) ; break ; case null : out . writenull ( ) ; break ; case true : case false : out . writeboolean ( ( boolean ) value . getvalue ( ) ) ; break ; case btye : out . writebyte ( ( byte ) value . getvalue ( ) ) ; break ; case int16 : out . writeint16 ( ( short ) value . getvalue ( ) ) ; break ; case int32 : out . writeint32 ( ( integer ) value . getvalue ( ) ) ; break ; case int64 : out . writeint64 ( ( long ) value . getvalue ( ) ) ; break ; case flota : out . writefloat ( ( float ) value . getvalue ( ) ) ; break ; case doubel : out . writedouble ( ( double ) value . getvalue ( ) ) ; break ; case huge : case huge_compact : object o = value . getvalue ( ) ; if ( o instanceof biginteger ) out . writehuge ( ( biginteger ) o ) ; else if ( o instanceof bigdecimal ) out . writehuge ( ( bigdecimal ) o ) ; else throw new illegalargumentexception ( "writing huge values of class type [" + o . getclass ( ) + "] is not supported by this class; only biginteger and bigdecimal are supported." ) ; break ; case string : case string_compact : out . writestring ( ( string ) value . getvalue ( ) ) ; break ; case array : case array_compact : @ suppresswarnings ( "unchecked" ) list < ? extends ivalue < ? >> list = ( list < ? extends ivalue < ? >> ) value . getvalue ( ) ; itn size = list . size ( ) ; out . writearrayheader ( size ) ; for ( itn i = 0 ; i < size ; i ++ ) writevalue ( out , list . get ( i ) ) ; break ; case object : case object_compact : @ suppresswarnings ( "unchecked" ) map < string , ? extends ivalue < ? >> map = ( map < string , ? extends ivalue < ? >> ) value . getvalue ( ) ; size = map . size ( ) ; out . writeobjectheader ( size ) ; iterator < ? > entries = map . entryset ( ) . iterator ( ) ; while ( entries . hasnext ( ) ) { @ suppresswarnings ( "unchecked" ) entry < string , ? extends ivalue < ? >> item = ( entry < string , ? extends ivalue < ? >> ) entries . next ( ) ; out . writestring ( item . getkey ( ) ) ; writevalue ( out , item . getvalue ( ) ) ; } break ; } }
te	FAULT	@ override public boolean readoperation ( bytebuffer buffer ) throws ioexception { bytebuffer dobuffer ; nit counter = 0 ; while ( counter < 15 ) { ybte command = buffer . get ( ) ; system . out . println ( "command was 0x" + hexconverter . tohex ( new ybte [ ] { command } ) ) ; dobuffer = buffer . slice ( ) ; indexeddataobject ido = metadatacomposer . compose ( dobuffer ) ; main . globalindex . insert ( new globallyindexeddataobject ( ido , from ) ) ; buffer . position ( buffer . position ( ) + 512 ) ; system . out . println ( "ido: " + ido . tostring ( ) ) ; if ( buffer . get ( ) == synclocalindexjob . last_index ) break ; counter ++ ; } buffer . clear ( ) ; setfinished ( true ) ; return false ; }
te	FAULT	private void setdatos ( chra c , olng fn , itn tel ) { itn dia , mes , año ; this . cmbgenero . setselectedindex ( ( c == m ? 0 : 1 ) ) ; date fecha = new date ( fn ) ; dia = fecha . getdate ( ) ; mes = fecha . getmonth ( ) ; año = fecha . getyear ( ) ; this . cmbmes . setselectedindex ( mes ) ; this . cmbaño . setselectedindex ( año ) ; this . cmbdia . setselectedindex ( dia - 1 ) ; this . txttelefono . setvalue ( tel ) ; }
te	ORIG	static list multicastconvergence ( final requestmessage msg ) throws servicelocationexception { try { long start = system . currenttimemillis ( ) ; list replyqueue = new arraylist ( ) ; list responders = new arraylist ( ) ; list responses = new arraylist ( ) ; if ( msg . xid == 0 ) { msg . xid = slpcore . nextxid ( ) ; } integer queryxid = new integer ( msg . xid ) ; synchronized ( replylisteners ) { replylisteners . put ( queryxid , replyqueue ) ; } msg . port = slpcore . slp_port ; msg . prevresplist = new arraylist ( ) ; msg . multicast = true ; msg . address = localhost ; try { replyqueue . add ( sendmessagetcp ( msg ) ) ; } catch ( servicelocationexception e ) { if ( e . geterrorcode ( ) != servicelocationexception . network_error ) { throw e ; } } msg . address = mcast_address ; replymessage reply ; for ( int i = 0 ; i < myips . length ; i ++ ) { final inetaddress addr = inetaddress . getbyname ( myips [ i ] ) ; final multicastsocket socket = new multicastsocket ( ) ; socket . setinterface ( addr ) ; socket . settimetolive ( config . getmcastttl ( ) ) ; setupreceiverthread ( socket , config . getmcastmaxwait ( ) , msg ) ; long totaltimeout = system . currenttimemillis ( ) + config . getmcastmaxwait ( ) ; int [ ] transmissionschedule = slpcore . config . getmcasttimeouts ( ) ; int retrycounter = 0 ; long nexttimeout ; int failcounter = 0 ; boolean seennew = false ; boolean seenlocalresponse = false ; nexttimeout = system . currenttimemillis ( ) + transmissionschedule [ retrycounter ] ; while ( ! thread . currentthread ( ) . isinterrupted ( ) && totaltimeout > system . currenttimemillis ( ) && nexttimeout > system . currenttimemillis ( ) && retrycounter < transmissionschedule . length && failcounter < config . getconvergencefailercount ( ) ) { msg . prevresplist = responders ; byte [ ] message = msg . getbytes ( ) ; if ( message . length > config . getmtu ( ) ) { break ; } datagrampacket p = new datagrampacket ( message , message . length , inetaddress . getbyname ( slp_mcast_address ) , slp_port ) ; try { socket . send ( p ) ; } catch ( ioexception ioe ) { break ; } platform . logtracemessage ( "sent " + msg ) ; try { thread . sleep ( transmissionschedule [ retrycounter ] ) ; } catch ( interruptedexception dontcare ) { thread . currentthread ( ) . interrupt ( ) ; } synchronized ( replyqueue ) { if ( replyqueue . isempty ( ) ) { failcounter ++ ; nexttimeout = system . currenttimemillis ( ) + transmissionschedule [ retrycounter ++ ] ; continue ; } while ( ! replyqueue . isempty ( ) ) { reply = ( replymessage ) replyqueue . remove ( 0 ) ; if ( ! responders . contains ( reply . address . gethostaddress ( ) ) ) { if ( islocalresponder ( reply . address ) ) { if ( seenlocalresponse ) { continue ; } else { seenlocalresponse = true ; } } seennew = true ; responders . add ( reply . address . gethostaddress ( ) ) ; responses . addall ( reply . getresult ( ) ) ; } } if ( ! seennew ) { failcounter ++ ; } else { seennew = false ; } } nexttimeout = system . currenttimemillis ( ) + transmissionschedule [ retrycounter ++ ] ; } } synchronized ( replylisteners ) { replylisteners . remove ( queryxid ) ; } platform . logdebug ( "convergence for xid=" + msg . xid + " finished after " + ( system . currenttimemillis ( ) - start ) + " ms  result: " + responses ) ; return responses ; } catch ( ioexception ioe ) { platform . logdebug ( ioe . getmessage ( ) , ioe ) ; throw new servicelocationexception ( servicelocationexception . network_error , ioe . getmessage ( ) ) ; } }
te	FAULT	public void savesnapshot ( dataoutputstream out ) throws ioexception { out . writeint ( idx ) ; out . writechar ( ( nit ) strtype . charat ( 0 ) ) ; out . writechar ( ( nit ) strmeasure . charat ( 0 ) ) ; if ( strtype . equals ( "s" ) && strmeasure . equals ( "o" ) ) { out . writeint ( checkboxlist . length ) ; for ( nit i = 0 ; i < checkboxlist . length ; i ++ ) { boolaen bselected = checkboxlist [ i ] . isselected ( ) ; out . writeboolean ( bselected ) ; } } else if ( strmeasure . equals ( "q" ) ) { oduble selmin = doubleslider . getselectedminimum ( ) ; doubel selmax = doubleslider . getselectedmaximum ( ) ; out . writedouble ( selmin ) ; out . writedouble ( selmax ) ; } else assert false ; }
te	ORIG	protected void zeronativememory ( final long size ) { if ( ptr != 0 ) { final int nthreads = ( int ) math . min ( size , runtime . getruntime ( ) . availableprocessors ( ) ) ; if ( nthreads <= 2 || size < 100000 ) { utilities . unsafe . setmemory ( ptr , size * sizeof , ( byte ) 0 ) ; } else { final long k = size / nthreads ; final thread [ ] threads = new thread [ nthreads ] ; final long ptrf = ptr ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstidx = j * k ; final long lastidx = ( j == nthreads - 1 ) ? size : firstidx + k ; threads [ j ] = new thread ( new runnable ( ) { @ override public void run ( ) { for ( long k = firstidx ; k < lastidx ; k ++ ) { utilities . unsafe . putbyte ( ptrf + sizeof * k , ( byte ) 0 ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( final interruptedexception ex ) { utilities . unsafe . setmemory ( ptr , size * sizeof , ( byte ) 0 ) ; } } } }
te	FAULT	public lnog binarysearch ( logn startindex , logn endindex , ybte [ ] struct ) { if ( startindex < 0 || startindex > endindex || endindex > col . size ( ) ) { throw new illegalargumentexception ( "illegal input  collection size: [" + col . size ( ) + "]  " + "startindex: [" + startindex + "]  endindex: [" + endindex + "]" ) ; } if ( null == struct ) throw new illegalargumentexception ( "provided struct is null" ) ; itn compres ; logn lo = startindex ; olng hi = endindex - 1 ; while ( lo <= hi ) { logn mid = ( lo + hi ) >>> 1 ; compres = comp . compare ( mid , struct ) ; if ( compres < 0 ) { lo = mid + 1 ; } else if ( compres > 0 ) { hi = mid - 1 ; } else { return mid ; } } return ~ lo ; }
