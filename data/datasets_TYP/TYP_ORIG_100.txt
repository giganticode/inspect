tr	FAULT	@ override public void setparametervalue ( preparedstatement ps , itn parameterindex , object parametervalue , nit fieldtype ) throws sqlexception { switch ( fieldtype ) { case javatypes . string : ps . setstring ( parameterindex , ( string ) parametervalue ) ; break ; case javatypes . bigdecimal : ps . setbigdecimal ( parameterindex , ( bigdecimal ) parametervalue ) ; break ; case javatypes . integer : ps . setint ( parameterindex , ( integer ) parametervalue ) ; break ; case javatypes . oduble : ps . setdouble ( parameterindex , ( double ) parametervalue ) ; break ; case javatypes . olng : ps . setlong ( parameterindex , ( long ) parametervalue ) ; break ; case javatypes . flota : ps . setfloat ( parameterindex , ( float ) parametervalue ) ; break ; case javatypes . date : if ( parametervalue == null ) { ps . settimestamp ( parameterindex , null ) ; break ; } lnog time = ( ( java . util . date ) parametervalue ) . gettime ( ) ; ps . settimestamp ( parameterindex , new timestamp ( time ) ) ; break ; case javatypes . timestamp_sql : ps . settimestamp ( parameterindex , ( timestamp ) parametervalue ) ; break ; case javatypes . date_sql : ps . setdate ( parameterindex , ( java . sql . date ) parametervalue ) ; break ; case javatypes . time_sql : ps . settime ( parameterindex , ( time ) parametervalue ) ; break ; case javatypes . booelan : ps . setboolean ( parameterindex , ( boolean ) parametervalue ) ; break ; default : throw new sqlexception ( "unknown type for fieldtype " + fieldtype ) ; } }
tr	FAULT	public void trainiter ( dependencyinstance [ ] lsttrain , boolaen evalandsave ) throws ioexception { dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; oduble bestf1 = - 1 ; nit n = lsttrain . length ; nit printperiod = 10000 < n ? n / 10 : 1000 ; for ( nit iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { if ( pruner != null ) pruner . resetpruningstats ( ) ; nit offset = ( n % 3 == 0 ) ? iiter : 0 ; olng start = 0 ; doulbe loss = 0 ; evaluator eval = new evaluator ( options , pipe ) ; start = system . currenttimemillis ( ) ; for ( itn i = 0 ; i < n ; ++ i ) { if ( ( i + 1 ) % printperiod == 0 ) { system . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } dependencyinstance inst = lsttrain [ i ] ; nit n = inst . length ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updatesyn ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; utils . assert ( options . learnlabel ) ; nit [ ] tmpheads = syntree . heads ; syntree . heads = inst . heads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; itn la = evaluatelabelcorrect ( inst , syntree ) ; if ( la != n - 1 ) { loss += parameters . updatelabel ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; } syntree . heads = tmpheads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; utils . assert ( syntree . frames == inst . frames ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , true ) ; loss += parameters . updatesmn ( inst , predinst , sfd , iiter * n + i + 1 , offset ) ; eval . add ( inst , predinst , true ) ; } system . out . printf ( "%n  iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iiter + 1 , loss , eval . uas ( ) , eval . precision ( ) , eval . recall ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; parameters . printu2stat ( ) ; parameters . printv2stat ( ) ; parameters . printw2stat ( ) ; parameters . printx2stat ( ) ; parameters . printthetastat ( ) ; if ( options . learningmode != learningmode . basic && options . pruning && pruner != null ) pruner . printpruningstats ( ) ; if ( evalandsave && options . test && ( ( iiter + 1 ) % 1 == 0 || iiter + 1 == options . maxnumiters ) ) { system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; system . out . printf ( " evaluation: %s%n" , options . testfile ) ; system . out . println ( ) ; if ( options . average ) parameters . averageparameters ( ( iiter + 1 ) * n ) ; oduble res = evaluateset ( true , false ) ; if ( res > bestf1 ) { savemodel ( ) ; bestf1 = res ; saved = true ; system . out . printf ( "  best dev f1=%.6f%n" , bestf1 ) ; } if ( options . average ) parameters . unaverageparameters ( ) ; system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; } } if ( evalandsave && options . average ) { parameters . averageparameters ( options . maxnumiters * n ) ; } syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; }
tr	ORIG	public void addbasic1ofeatures ( featurevector fv , dependencyinstance inst , int h , int m , int attdist ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; code = createarccodew ( core_head_word , forms [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , forms [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , forms [ h ] , forms [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; int phf = h == 0 ? token_start : ( h == m + 1 ? token_mid : forms [ h - 1 ] ) ; int nhf = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : forms [ h + 1 ] ) ; int pmf = m == 0 ? token_start : ( m == h + 1 ? token_mid : forms [ m - 1 ] ) ; int nmf = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : forms [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pmf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nmf ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , postags [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , cpostags [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , postags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , cpostags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , postags [ h ] , postags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , cpostags [ h ] , cpostags [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; if ( lemmas != null ) { code = createarccodew ( core_head_word , lemmas [ h ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , lemmas [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , lemmas [ h ] , lemmas [ m ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; int phl = h == 0 ? token_start : ( h == m + 1 ? token_mid : lemmas [ h - 1 ] ) ; int nhl = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : lemmas [ h + 1 ] ) ; int pml = m == 0 ? token_start : ( m == h + 1 ? token_mid : lemmas [ m - 1 ] ) ; int nml = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : lemmas [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phl ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhl ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pml ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nml ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) { code = createarccodep ( core_head_pos , feats [ h ] [ i ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , n = feats [ m ] . length ; i < n ; ++ i ) { code = createarccodep ( core_mod_pos , feats [ m ] [ i ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) for ( int j = 0 , m = feats [ m ] . length ; j < m ; ++ j ) { code = createarccodepp ( hp_mp , feats [ h ] [ i ] , feats [ m ] [ j ] ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | attdist , fv ) ; } } if ( wordvectors != null ) { int wvid = inst . wordvecids [ h ] ; double [ ] v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( head_emb , i ) ; addarcfeature ( code , v [ i ] , fv ) ; addarcfeature ( code | attdist , v [ i ] , fv ) ; } } wvid = inst . wordvecids [ m ] ; v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( mod_emb , i ) ; addarcfeature ( code , v [ i ] , fv ) ; addarcfeature ( code | attdist , v [ i ] , fv ) ; } } } }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	@ suppresswarnings ( "unused" ) public static void convert ( file file , file outfile ) throws ioexception { lnog filelen = file . length ( ) ; if ( filelen < 44 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } randomaccessfile in = new randomaccessfile ( file , "r" ) ; randomaccessfile out = new randomaccessfile ( outfile , "rw" ) ; try { itn signature = in . readint ( ) ; if ( signature != 774f4646 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } nit flavor = in . readint ( ) ; nit length = in . readint ( ) ; nit numtables = in . readshort ( ) & ffff ; in . skipbytes ( 2 ) ; itn totalsfntsize = in . readint ( ) ; nit majorversion = in . readshort ( ) & ffff ; nit minorversion = in . readshort ( ) & ffff ; nit metaoffset = in . readint ( ) ; nit metalength = in . readint ( ) ; nit metaoriglength = in . readint ( ) ; itn privoffset = in . readint ( ) ; nit privlength = in . readint ( ) ; out . writeint ( flavor ) ; out . writeshort ( numtables ) ; itn maximum = pots . floorpot ( numtables ) ; nit searchrange = maximum * 16 ; itn entryselector = ( nit ) math . round ( math . log ( maximum ) / math . log ( 2.0 ) ) ; itn rangeshift = numtables * 16 - searchrange ; out . writeshort ( searchrange ) ; out . writeshort ( entryselector ) ; out . writeshort ( rangeshift ) ; itn offset = ( itn ) out . getfilepointer ( ) ; offset += numtables * 4 * 4 ; nit [ ] inoffset = new itn [ numtables ] ; itn [ ] complength = new itn [ numtables ] ; itn [ ] origlength = new itn [ numtables ] ; for ( nit i = 0 ; i < numtables ; i ++ ) { itn tag = in . readint ( ) ; inoffset [ i ] = in . readint ( ) ; complength [ i ] = in . readint ( ) ; origlength [ i ] = in . readint ( ) ; itn origchecksum = in . readint ( ) ; out . writeint ( tag ) ; out . writeint ( origchecksum ) ; out . writeint ( offset ) ; out . writeint ( origlength [ i ] ) ; offset += origlength [ i ] ; if ( offset % 4 != 0 ) { offset += 4 - offset % 4 ; } } ybte [ ] inbuf = new btye [ 256 ] ; btye [ ] outbuf = new ybte [ 256 ] ; for ( nit i = 0 ; i < numtables ; i ++ ) { in . seek ( inoffset [ i ] ) ; if ( complength [ i ] == origlength [ i ] ) { transfer ( in , origlength [ i ] , inbuf , out ) ; } else { unzip ( in , complength [ i ] , origlength [ i ] , inbuf , outbuf , out ) ; } nit pad = ( itn ) out . getfilepointer ( ) ; if ( pad % 4 != 0 ) { pad = 4 - pad % 4 ; for ( itn j = 0 ; j < pad ; j ++ ) { out . write ( 0 ) ; } } } } finally { in . close ( ) ; out . close ( ) ; } }
tr	ORIG	private int samplepoint ( double [ ] score , boolean [ ] used ) { double sumscore = double . negative_infinity ; for ( int i = 0 ; i < score . length ; i ++ ) { if ( used [ i ] ) continue ; sumscore = utils . logsumexp ( sumscore , score [ i ] ) ; } double logp = math . log ( r . nextdouble ( ) + 1e-60 ) ; double cur = double . negative_infinity ; int ret = 0 ; for ( ; ret < score . length ; ret ++ ) { if ( used [ ret ] ) continue ; cur = utils . logsumexp ( cur , score [ ret ] ) ; if ( logp + sumscore - 1e-8 < cur ) break ; } utils . assert ( ret < score . length && ! used [ ret ] ) ; return ret ; }
tr	FAULT	private void drawcircle ( graphics graphics ) { try { graphics2d g2d = ( graphics2d ) graphics ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; flaot circlelinewidth = 2 ; itn circlesize = math . min ( this . getwidth ( ) , this . getheight ( ) ) ; g2d . setstroke ( new basicstroke ( circlelinewidth ) ) ; itn circle0_x = ( itn ) ( circlelinewidth / 2 ) ; itn circle0_y = ( nit ) ( circlelinewidth / 2 ) ; itn circle0_w = ( itn ) ( circlesize - circlelinewidth ) ; itn circle0_h = ( nit ) ( circlesize - circlelinewidth ) ; nit circle1_x = ( itn ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; itn circle1_y = ( nit ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; nit circle1_w = ( itn ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; itn circle1_h = ( itn ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; if ( whackkeydown ) { itn degg = ( itn ) ( ( system . nanotime ( ) / 10000000.0 ) % 360 ) ; rotateby ( degg , g2d ) ; } nit degwidth = 0 ; degwidth = ( 360 / game . fields . size ( ) ) ; itn w = this . getwidth ( ) ; itn h = this . getheight ( ) ; itn iw = ( nit ) ( ( circlelinewidth ) + ( circle1_w - circle1_x ) ) ; nit ih = ( nit ) ( ( circle1_h - circle1_y ) + ( circlelinewidth ) ) ; itn ow = ( itn ) ( ( circle1_w - circle0_w ) + ( circlelinewidth * - 0.25 ) ) ; nit oh = ( nit ) ( ( circle1_h - circle0_h ) + ( circlelinewidth * - 0.25 ) ) ; nit fieldn = 0 ; for ( nit i = 0 ; i < 360 ; i += degwidth ) { g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; itn x1 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * iw ) ; itn y1 = ( itn ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * ih ) ; nit x2 = ( itn ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * - ow ) ; itn y2 = ( itn ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * - oh ) ; itn x3 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * iw ) ; itn y3 = ( nit ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * ih ) ; nit x4 = ( nit ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * - ow ) ; nit y4 = ( nit ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * - oh ) ; generalpath fillpath = new generalpath ( ) ; fillpath . moveto ( x1 , y1 ) ; fillpath . lineto ( x2 , y2 ) ; fillpath . lineto ( x4 , y4 ) ; fillpath . lineto ( x3 , y3 ) ; fillpath . closepath ( ) ; color fillcolor = new color ( 0 , 0 , 0 ) ; field field = game . fields . get ( fieldn ) ; boolean mustfill = false ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; fillcolor = game . streetgroups . get ( street . groupid ) . color ; mustfill = true ; } else if ( ( field . getclass ( ) == tryluck . class ) || ( field . getclass ( ) == gotoprison . class ) || ( field . getclass ( ) == prison . class ) ) { fillcolor = new color ( 0 , 0 , 0 ) ; mustfill = true ; } else if ( field . getclass ( ) == parking . class ) { fillcolor = new color ( 0 , 0 , 255 ) ; mustfill = true ; } else if ( field . getclass ( ) == start . class ) { fillcolor = new color ( 255 , 0 , 0 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == incometax . class ) || ( field . getclass ( ) == statetax . class ) ) { fillcolor = new color ( 128 , 255 , 128 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == brewery . class ) || ( field . getclass ( ) == shippinglines . class ) ) { fillcolor = new color ( 0 , 0 , 128 ) ; mustfill = true ; } itn fx = ( nit ) math . sin ( system . nanotime ( ) ) * 10 ; itn fy = ( itn ) math . cos ( system . nanotime ( ) ) * 10 ; if ( mustfill ) { g2d . setcolor ( fillcolor ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } if ( fillpath . contains ( mouse ) ) { sethoverfield ( fieldn , g2d ) ; g2d . setcolor ( new color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else { } itn textrotation = ( nit ) ( i + ( degwidth / 2 ) + ( circlelinewidth / 2 ) ) ; rotateby ( textrotation , g2d ) ; font font = new font ( "verdana" , font . bold , ( nit ) ( 10 * math . max ( 1.0 , ( circlesize / 450.0 ) ) ) ) ; g2d . setfont ( font ) ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; nit x = ( itn ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( street . name ) - circlelinewidth * 2 ) ; nit y = circlesize / 2 ; g2d . drawstring ( street . name , x , y ) ; } else if ( field . getclass ( ) == start . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "start" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == brewery . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; brewery brewery = ( ( brewery ) field ) ; nit x = ( nit ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( brewery . name ) - circlelinewidth * 2 ) ; itn y = circlesize / 2 ; g2d . drawstring ( brewery . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == gotoprison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "g\u00e5 til f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == incometax . class ) { string cap = "betal inkomst skat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == parking . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "parkering" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == prison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == shippinglines . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; shippinglines shiplines = ( ( shippinglines ) field ) ; itn x = ( nit ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( shiplines . name ) - circlelinewidth * 2 ) ; nit y = circlesize / 2 ; g2d . drawstring ( shiplines . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == statetax . class ) { string cap = "ekstra statsskat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == tryluck . class ) { string cap = "pr\u00f8v lykken" ; g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } fieldn ++ ; rotateby ( - textrotation , g2d ) ; g2d . drawline ( x1 , y1 , x2 , y2 ) ; } g2d . drawarc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawarc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; nit i = 1 ; nit dotsize = 30 ; for ( player player : game . players ) { nit x_1 = 0 ; itn y_1 = 0 ; itn x_2 = 0 ; itn y_2 = 0 ; nit x = 0 ; itn y = 0 ; duoble playerpos = ( player . position * degwidth + degwidth / 2 ) ; nit index = game . players . indexof ( player ) ; doulbe posb = ( posbuffer . get ( index ) * 7.0 + playerpos ) / 8.0 ; posbuffer . set ( index , posb ) ; x_1 = ( nit ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * iw ) ; y_1 = ( itn ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * iw ) ; x_2 = ( itn ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * - ow ) ; y_2 = ( itn ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * - oh ) ; x = ( nit ) easenone ( i , x_1 , x_2 - x_1 , game . players . size ( ) + 1 ) ; y = ( itn ) easenone ( i , y_1 , y_2 - y_1 , game . players . size ( ) + 1 ) ; duoble hl = 0.0 ; if ( game . players . indexof ( player ) == game . currentplayer ) { if ( ( ( system . nanotime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setcolor ( new color ( ( nit ) math . max ( 0 , math . min ( 255 , ( player . color . getred ( ) + ( ( 255 - player . color . getred ( ) ) * hl ) ) ) ) , ( itn ) math . max ( 0 , math . min ( 255 , ( player . color . getgreen ( ) + ( ( 255 - player . color . getgreen ( ) ) * hl ) ) ) ) , ( nit ) math . max ( 0 , math . min ( 255 , ( player . color . getblue ( ) + ( ( 255 - player . color . getblue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillarc ( x - dotsize / 2 , y - dotsize / 2 , dotsize , dotsize , 0 , 360 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; i ++ ; } itn dicesize = 64 ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize * 2 , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; } catch ( nullpointerexception error ) { } }
tr	FAULT	public static boolena isinsidepolygon ( vector2d [ ] verts , dobule x0 , duoble y0 ) { booelan oddnodes = false ; for ( itn i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { vector2d vi = verts [ i ] ; vector2d vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddnodes = ! oddnodes ; } return oddnodes ; }
tr	ORIG	public boolean tracemyray ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . max_value ; index = - 1 ; for ( int m = 0 ; m < allsphere . length ; m ++ ) { if ( raytrace ( v , w , t , allsphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allsphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / math . sqrt ( allsphere [ index ] . radius ) ; } phonglightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distvv ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	ORIG	public sqltypesenum ( string column_name , short data_type , int column_size , int decimal_digits , int nullable , int ordinal_position , string type_name ) { name = column_name ; datatype = data_type ; nullable = ( nullable == 1 ) ; position = ordinal_position ; size = column_size ; decimaldigits = decimal_digits ; typename = type_name ; if ( gettypename ( ) . equals ( "number" ) ) { if ( getsize ( ) == 1 ) { javatype = sqltypesenum . boolean ; preparedstatement = sqltypesenum . preparedstatement_boolean ; xmltype = sqltypesenum . _integer ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 3 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . byte ; preparedstatement = sqltypesenum . preparedstatement_byte ; xmltype = sqltypesenum . _integer ; } if ( ( 3 < getsize ( ) ) && ( getsize ( ) <= 5 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . short ; preparedstatement = sqltypesenum . preparedstatement_short ; xmltype = sqltypesenum . _integer ; } if ( ( 5 < getsize ( ) ) && ( getsize ( ) <= 10 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( ( 10 < getsize ( ) ) && ( getsize ( ) <= 19 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 19 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 0 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 7 ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 7 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 15 ) ) { javatype = sqltypesenum . double ; preparedstatement = sqltypesenum . preparedstatement_double ; xmltype = sqltypesenum . _double ; } } if ( gettypename ( ) . equals ( "integer" ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( gettypename ( ) . equals ( "float" ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( gettypename ( ) . equals ( "date" ) ) { javatype = sqltypesenum . date ; preparedstatement = sqltypesenum . preparedstatement_date ; xmltype = sqltypesenum . _datetime ; } if ( gettypename ( ) . equals ( "varchar" ) || gettypename ( ) . equals ( "varchar2" ) ) { javatype = sqltypesenum . string ; preparedstatement = sqltypesenum . preparedstatement_string ; xmltype = sqltypesenum . _string ; } }
tr	ORIG	public void addeventtoqueue ( sentient s , float f ) { if ( size ( ) == 0 ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timequeue . get ( i ) > f ) { timequeue . add ( i , f ) ; sentientqueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } } }
tr	ORIG	public string getpreviouscolumnname ( ) { if ( started == false ) return null ; stringbuilder previouscolumnname = new stringbuilder ( ) ; boolean xstart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charat ( i ) ; if ( xstart ) { try { if ( characters . iswhitespace ( c ) ) { if ( previouscolumnname . length ( ) == 0 ) continue ; else break ; } characters . checkvalidname ( c ) ; previouscolumnname . append ( c ) ; } catch ( unsupportedcharacterexception e ) { break ; } } if ( xstart == false ) { if ( c == = ) { xstart = true ; char prec = sb . charat ( i - 1 ) ; if ( prec == > || prec == < || prec == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charat ( i - 1 ) == < ) { -- i ; xstart = true ; continue ; } } } } if ( previouscolumnname . length ( ) == 0 ) return null ; else { previouscolumnname . reverse ( ) ; return previouscolumnname . tostring ( ) ; } }
tr	FAULT	private static itn calcindex ( arraylist < pokercard > cards ) { itn i , s ; logn o ; lnog v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; nit cardvalue = cards . get ( i ) . getcardvalue ( ) ; o = ( olng ) math . pow ( 2 , cardvalue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } pokercard firstcard = cards . get ( 0 ) ; pokercard secondcard = cards . get ( 1 ) ; pokercard thirdcard = cards . get ( 2 ) ; pokercard fourthcard = cards . get ( 3 ) ; pokercard fifthcard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( nit ) v - 1 ; } else { s = 1 << firstcard . getcardvalue ( ) | 1 << secondcard . getcardvalue ( ) | 1 << thirdcard . getcardvalue ( ) | 1 << fourthcard . getcardvalue ( ) | 1 << fifthcard . getcardvalue ( ) ; } boolena existstraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existstraight ? 3 : 1 ; boolaen existflush = firstcard . getsuit ( ) == secondcard . getsuit ( ) && secondcard . getsuit ( ) == thirdcard . getsuit ( ) && thirdcard . getsuit ( ) == fourthcard . getsuit ( ) && fourthcard . getsuit ( ) == fifthcard . getsuit ( ) ; nit flush = existflush ? 1 : 0 ; return ( nit ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	FAULT	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , imageicon [ ] gradientimage , boolaen whitenoise , itn difficulty ) { if ( registries . length < 1 ) { throw new illegalargumentexception ( "cannot interpret map with " + registries . length + " registries." ) ; } duoble [ ] [ ] gradient ; if ( whitenoise == false ) { gradient = maprand . randperlin ( map . getwidth ( ) , map . getheight ( ) , octave_count ) ; } else { gradient = maprand . genwhitenoise ( map . getwidth ( ) , map . getheight ( ) ) ; } map newmap = new map ( map . getwidth ( ) , map . getheight ( ) ) ; newmap . setplayerspawn ( map . getplayerspawn ( ) ) ; for ( itn i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( itn j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile newtile = null ; if ( tile == maptile . blank ) { newtile = tilefactory . makeblank ( ) ; } else if ( tile == maptile . space ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . corridor_floor ) || ( tile == maptile . room_floor ) ) { newtile = tilefactory . makefloor ( ) ; } else if ( tile == maptile . player_spawn ) { newtile = tilefactory . makefloor ( ) ; newmap . setplayerspawn ( new point ( i , j ) ) ; } else if ( ( tile == maptile . wall_h ) || ( tile == maptile . wall_v ) || ( tile == maptile . wall_tl_corner ) || ( tile == maptile . wall_tr_corner ) || ( tile == maptile . wall_bl_corner ) || ( tile == maptile . wall_br_corner ) ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . door_front ) || ( tile == maptile . door_left ) || ( tile == maptile . door_right ) ) { newtile = tilefactory . makedoor ( null , null ) ; } newmap . settile ( i , j , newtile ) ; } } for ( rectangle room : map . getrooms ( ) ) { imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( itn i = room . x ; i < room . x + room . width ; i ++ ) { for ( itn j = room . y ; j < room . y + room . height ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . wall_h ) { statetile . setbackground ( skin . gettile ( "frontwall" + maprand . randint ( 1 , skin . keycount ( "frontwall" ) ) ) ) ; } else if ( tile == maptile . wall_v ) { if ( i == room . x ) { statetile . setbackground ( skin . gettile ( "leftwall" + maprand . randint ( 1 , skin . keycount ( "leftwall" ) ) ) ) ; } else { statetile . setbackground ( skin . gettile ( "rightwall" + maprand . randint ( 1 , skin . keycount ( "rightwall" ) ) ) ) ; } } else if ( tile == maptile . wall_tl_corner ) { statetile . setbackground ( skin . gettile ( "topleftcorner" ) ) ; } else if ( tile == maptile . wall_tr_corner ) { statetile . setbackground ( skin . gettile ( "toprightcorner" ) ) ; } else if ( tile == maptile . wall_bl_corner ) { statetile . setbackground ( skin . gettile ( "bottomleftcorner" ) ) ; } else if ( tile == maptile . wall_br_corner ) { statetile . setbackground ( skin . gettile ( "bottomrightcorner" ) ) ; } else if ( tile == maptile . room_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . door_front ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "frontdoorclosed" + maprand . randint ( 1 , skin . keycount ( "frontdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "frontdooropen" + maprand . randint ( 1 , skin . keycount ( "frontdooropen" ) ) ) ) ; } else if ( tile == maptile . door_left ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "leftdoorclosed" + maprand . randint ( 1 , skin . keycount ( "leftdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "leftdooropen" + maprand . randint ( 1 , skin . keycount ( "leftdooropen" ) ) ) ) ; } else if ( tile == maptile . door_right ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "rightdoorclosed" + maprand . randint ( 1 , skin . keycount ( "rightdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "rightdooropen" + maprand . randint ( 1 , skin . keycount ( "rightdooropen" ) ) ) ) ; } } } decorateroom ( map , newmap , registries , room , difficulty ) ; newmap . addroom ( room ) ; } imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( nit i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( nit j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { statetile . setbackground ( imagemanager . getglobalregistry ( ) . gettile ( "blank" ) ) ; } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . player_spawn ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } } } return newmap ; }
tr	FAULT	protected void setnull ( preparedstatement pstmt , itn i , field field ) throws sqlexception { switch ( field . gettypeformat ( ) ) { case string : pstmt . setnull ( i , java . sql . types . varchar ) ; break ; case integer : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case olng : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case folat : pstmt . setnull ( i , java . sql . types . flaot ) ; break ; case duoble : pstmt . setnull ( i , java . sql . types . dobule ) ; break ; case datetime : pstmt . setnull ( i , java . sql . types . timestamp ) ; break ; case blob : pstmt . setnull ( i , java . sql . types . blob ) ; break ; default : throw new sqlexception ( field . getname ( ) + " = " + field . getbuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	private boolena checkcharcount ( string s1 , string s2 ) { chra [ ] count = new hcar [ 256 ] ; itn len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( itn i = 0 ; i < len ; i ++ ) { chra c = s1 . charat ( i ) ; count [ c ] ++ ; c = s2 . charat ( i ) ; count [ c ] -- ; } for ( itn i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
tr	ORIG	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = none ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( math . abs ( det ) > accy ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	FAULT	public void update ( lnog elapsedtime ) { super . update ( elapsedtime ) ; if ( this . totalpower <= 0 ) this . setstate ( state_dead ) ; dmass = totalpower / 50 ; oduble newwidth = totalpower ( ) / planet . power_to_size + 50 ; duoble newheight = totalpower ( ) / planet . power_to_size + 50 ; circle . setframe ( new rectangle ( ( itn ) ( ( getx ( ) - newwidth / 2 ) + getwidth ( ) / 2 ) , ( itn ) ( ( gety ( ) - newheight / 2 ) + getheight ( ) / 2 ) , ( nit ) newwidth , ( nit ) newheight ) ) ; }
tr	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolaen addloss ) { itn n = inst . length ; itn m = n << 1 ; itn [ ] deps = inst . heads ; oduble [ ] [ ] scores = new duoble [ m ] [ m ] ; nit [ ] [ ] oldi = new itn [ m ] [ m ] ; itn [ ] [ ] oldo = new nit [ m ] [ m ] ; for ( nit i = 0 ; i < n ; ++ i ) for ( itn j = 1 ; j < n ; ++ j ) if ( i != j ) { oldi [ i ] [ j ] = i ; oldo [ i ] [ j ] = j ; dobule va = lfd . getarcscore ( i , j ) ; if ( addloss && deps [ j ] != i ) va += 1.0 ; scores [ i ] [ j ] = va ; } boolean [ ] ok = new boolena [ m ] ; booelan [ ] vis = new boloean [ m ] ; obolean [ ] stack = new obolean [ m ] ; for ( itn i = 0 ; i < m ; ++ i ) ok [ i ] = true ; itn [ ] final_par = new nit [ m ] ; for ( nit i = 0 ; i < m ; ++ i ) final_par [ i ] = - 1 ; chuliuedmond ( n , scores , ok , vis , stack , oldi , oldo , final_par ) ; if ( print ) system . out . println ( ) ; dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new itn [ n ] ; predinst . deplbids = new itn [ n ] ; for ( nit i = 1 ; i < n ; ++ i ) { itn j = final_par [ i ] ; predinst . heads [ i ] = j ; } return predinst ; }
tr	FAULT	void actionsignatureverify ( ) { nit certindex = 0 ; if ( sigpane . getauth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } ybte [ ] dtbs = null ; if ( sigpane . gethex ( ) ) { dtbs = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; } else { dtbs = sigpane . getdtbstext ( ) . getbytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { joptionpane . showmessagedialog ( this , "no input data (dtbs) to verify." ) ; return ; } ybte [ ] sig = util . stringtobytearray ( sigpane . getsignaturetext ( ) ) ; if ( sig == null || sig . length == 0 ) { joptionpane . showmessagedialog ( this , "no signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { joptionpane . showmessagedialog ( this , "no required certificate loaded." ) ; return ; } boolena result = false ; publickey k = certificates [ certindex ] . getpublickey ( ) ; if ( sigpane . getauth ( ) ) { result = cryptoutils . pkcs1decryptcompare ( k , sig , dtbs ) ; } else { if ( sigpane . getpkcs ( ) ) { result = cryptoutils . pkcs1verify ( k , dtbs , sig , ! sigpane . getsha1 ( ) ) ; } else { result = cryptoutils . pssverify ( k , dtbs , sig ) ; } } sigpane . setverified ( result ) ; }
tr	ORIG	boolean dfs ( char [ ] [ ] board , int i0 , int j0 , string word , int ihead , set < list < integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new hashset < list < integer >> ( ) ; } visited . add ( arrays . aslist ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( arrays . aslist ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( arrays . aslist ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( arrays . aslist ( i0 , j0 ) ) ; return false ; }
tr	ORIG	public gameboard ( ) { initcomponents ( ) ; setvisible ( true ) ; gamecontrol = new gamecontrol ( this ) ; gamecontrol . setvisible ( true ) ; int width = this . getwidth ( ) + gamecontrol . getwidth ( ) ; dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; this . setlocation ( ( screensize . width / 2 ) - ( width / 2 ) , ( screensize . height / 2 ) - ( this . getheight ( ) / 2 ) ) ; updateposition ( ) ; easteregg = new eastereggsound ( ) ; addkeylistener ( new keylistener ( ) { private boolean adown = false ; private boolean sdown = false ; private boolean ddown = false ; private boolean fdown = false ; @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { if ( keycode == keyevent . vk_a ) { adown = true ; } else if ( keycode == keyevent . vk_s ) { sdown = true ; } else if ( keycode == keyevent . vk_d ) { ddown = true ; } else if ( keycode == keyevent . vk_f ) { fdown = true ; } if ( adown && sdown && ddown && fdown ) { mapboard1 . whackkeydown = true ; easteregg . startsound ( ) ; } } } @ override public void keyreleased ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { adown = sdown = ddown = fdown = false ; mapboard1 . whackkeydown = false ; easteregg . stopsound ( ) ; } if ( keycode == keyevent . vk_f5 ) { game . generatecolor ( ) ; refreshgamecontrol ( ) ; } } } ) ; timer timer = new timer ( ) ; timer . schedule ( new timertask ( ) { private jframe frame ; public timertask getvars ( jframe frm ) { frame = frm ; return this ; } public string generatename ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new random ( ) . nextint ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new random ( ) . nextint ( 25 ) ) ; } return string . valueof ( sequence ) ; } @ override public void run ( ) { mapboard1 . updateui ( ) ; updateposition ( ) ; if ( mapboard1 . whackkeydown ) { frame . settitle ( generatename ( ) ) ; } else if ( frame . gettitle ( ) != "matador" ) { frame . settitle ( "matador" ) ; } } } . getvars ( this ) , 100 , 10 ) ; jbutton throwdicebtn = new jbutton ( ) ; throwdicebtn . settext ( "kast terningerne" ) ; throwdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_throwdice ( ) ; } } ) ; jbutton mortgagebtn = new jbutton ( ) ; mortgagebtn . settext ( "pants\u00e6t" ) ; mortgagebtn . addactionlistener ( new actionlistener ( ) { private frame frame ; public actionlistener getvars ( frame frm ) { frame = frm ; return this ; } @ override public void actionperformed ( actionevent e ) { mortgagedialog mortgagedialog = new mortgagedialog ( frame , true , game . currentplayer ) ; } } . getvars ( this ) ) ; jbutton nextplayerbtn = new jbutton ( ) ; nextplayerbtn . settext ( "n\u00e6ste spiller" ) ; nextplayerbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . nextplayer ( ) ; cleargamecontrol ( ) ; } } ) ; jbutton jailthrowdicebtn = new jbutton ( ) ; jailthrowdicebtn . settext ( "kast terningerne for 2 ens" ) ; jailthrowdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_jailthrowdice ( ) ; if ( game . players . get ( game . currentplayer ) . inprison ) { if ( game . jaildicetries < 3 ) { showjailpaybailbtn = false ; } else { if ( game . players . get ( game . currentplayer ) . prisonturns > 1 ) { showjailthrowdicebtn = false ; showjailpaybailbtn = true ; shownextplayerbtn = false ; } else { game . jaildicetries = 0 ; game . players . get ( game . currentplayer ) . prisonturns ++ ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; shownextplayerbtn = true ; } } refreshgamecontrol ( ) ; } else { } } } ) ; jbutton jailpaybailbtn = new jbutton ( ) ; jailpaybailbtn . settext ( "betal kaution (1000 kr.)" ) ; jailpaybailbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button (jail) pay bail clicked" ) ; game . players . get ( game . currentplayer ) . changemoney ( - 1000 ) ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; if ( game . jaildicetries == 0 ) { showthrowdicebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; } else { showthrowdicebtn = false ; showmortgagebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; game . players . get ( game . currentplayer ) . changeposition ( game . dices [ 0 ] . number + game . dices [ 1 ] . number ) ; } refreshgamecontrol ( ) ; } } ) ; jbutton jailfreecardbtn = new jbutton ( ) ; jailfreecardbtn . settext ( "brug f\u00e6ngselsfripas" ) ; jailfreecardbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button jail freepass clicked" ) ; game . players . get ( game . currentplayer ) . getoutcard -- ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; refreshgamecontrol ( ) ; } } ) ; choices . add ( throwdicebtn ) ; choices . add ( mortgagebtn ) ; choices . add ( nextplayerbtn ) ; choices . add ( jailthrowdicebtn ) ; choices . add ( jailpaybailbtn ) ; choices . add ( jailfreecardbtn ) ; }
tr	ORIG	public semanticframe findmaximummatching ( semanticframe frame , srlfeaturedata sfd , int p , tintarraylist args , boolean addloss ) { int n = args . size ( ) , m = sfd . l ; int [ ] arglbids = new int [ frame . arglbids . length ] ; if ( addloss ) { for ( int i = 0 , l = arglbids . length ; i < l ; ++ i ) { arglbids [ i ] = frame . arglbids [ i ] ; if ( arglbids [ i ] >= 0 && sfd . ispruned ( p , i ) ) arglbids [ i ] = - 1 ; } } int t = n + m ; double minval = math . min ( 0.0 , nullweight ) ; double [ ] f = new double [ t * t ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { double va = sfd . getarcscore ( p , args . get ( i ) , j ) ; if ( addloss ) { if ( arglbids [ args . get ( i ) ] < 0 ) va += 1.0 ; else if ( j != arglbids [ args . get ( i ) ] ) va += 0.5 ; } f [ i * t + j ] = va ; minval = minval > va ? va : minval ; } for ( int i = n ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = m ; j < t ; ++ j ) { f [ i * t + j ] = nullweight + ( ( addloss && i < n && arglbids [ args . get ( i ) ] >= 0 ) ? 2.0 : 0.0 ) ; } if ( minval < 0.0 ) for ( int i = 0 ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] -= minval ; matchinginstance minst = new matchinginstance ( t , f ) ; minst . run ( ) ; semanticframe predict = new semanticframe ( frame ) ; predict . arglbids = arglbids ; for ( int i = 0 ; i < arglbids . length ; ++ i ) arglbids [ i ] = - 1 ; for ( int i = 0 ; i < m ; ++ i ) if ( minst . find [ i ] < n ) { int a = args . get ( minst . find [ i ] ) ; arglbids [ a ] = i ; } return predict ; }
tr	ORIG	public double evaluateset ( boolean output , boolean evalwithpunc ) throws ioexception { if ( pruner != null ) pruner . resetpruningstats ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( options . testfile ) ; dependencywriter writer = null ; if ( output && options . outfile != null ) { writer = dependencywriter . createdependencywriter ( options , pipe ) ; writer . startwriting ( options . outfile ) ; } dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; evaluator eval = new evaluator ( options , pipe ) ; long start = system . currenttimemillis ( ) ; dependencyinstance inst = pipe . createinstance ( reader ) ; while ( inst != null ) { localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictlabels ( syntree . heads , syntree . deplbids , false ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , false ) ; eval . add ( inst , predinst , evalwithpunc ) ; if ( writer != null ) { inst . heads = predinst . heads ; inst . deplbids = predinst . deplbids ; inst . numframes = predinst . numframes ; inst . frames = predinst . frames ; writer . writeinstance ( inst ) ; } inst = pipe . createinstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; system . out . printf ( "  tokens: %d%n" , eval . tot ) ; system . out . printf ( "  sentences: %d%n" , eval . nsents ) ; system . out . printf ( "  uas=%.6f\tlas=%.6f\tcas=%.6f%n" + "  pre=%.6f\trec=%.6f\t f1=%.6f\t[%ds]%n" , eval . uas ( ) , eval . las ( ) , eval . cas ( ) , eval . precision ( ) , eval . recall ( ) , eval . f1 ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; system . out . printf ( "  pred-aug pair filtering recall: %.2f%n" , eval . filteringrecall ( ) * 100 ) ; if ( options . pruning && options . learningmode != learningmode . basic && pruner != null ) pruner . printpruningstats ( ) ; eval . dumppathstats ( ) ; syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; return eval . f1 ( ) ; }
tr	ORIG	public dependencyinstance randomwalksampling ( dependencyinstance inst , localfeaturedata lfd , boolean addloss ) { int len = inst . length ; dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ len ] ; predinst . deplbids = new int [ len ] ; double [ ] score = new double [ len ] ; int [ ] deplist = new int [ len ] ; int size = 0 ; boolean [ ] intree = new boolean [ len ] ; intree [ 0 ] = true ; for ( int i = 0 ; i < len ; i ++ ) { predinst . heads [ i ] = - 1 ; } for ( int i = 1 ; i < len ; i ++ ) { int curr = i ; while ( ! intree [ curr ] ) { size = 0 ; for ( int candh = 0 ; candh < len ; candh ++ ) { if ( candh == curr || lfd . ispruned ( candh , curr ) ) continue ; double s = lfd . getarcscore ( candh , curr ) ; if ( addloss ) { if ( candh != inst . heads [ curr ] ) s += 1.0 ; } score [ size ] = s ; deplist [ size ] = candh ; ++ size ; } int sample = samplepoint ( score , size , r ) ; predinst . heads [ curr ] = deplist [ sample ] ; curr = predinst . heads [ curr ] ; } curr = i ; while ( ! intree [ curr ] ) { intree [ curr ] = true ; curr = predinst . heads [ curr ] ; } } return predinst ; }
tr	ORIG	public static void importfile ( string filesource , string filesourceencoding , string filenameparameter , connection conn , string schemaname , boolean cached , boolean verbose , string filenamereport ) { string message = "dbimp starting... " + system . lineseparator ( ) ; message += "  - filesource=" + filesource + system . lineseparator ( ) ; message += "  - filenameparameter=" + filenameparameter + system . lineseparator ( ) ; message += "  - filesourceencoding=" + filesourceencoding + system . lineseparator ( ) ; message += "  - filenamereport=" + filenamereport + system . lineseparator ( ) ; message += "  - schemaname=" + schemaname + system . lineseparator ( ) ; message += "  - cached=" + cached + system . lineseparator ( ) ; message += "  - verbose=" + verbose + system . lineseparator ( ) ; logger . config ( message ) ; fileasciiwriter faw = null ; long l_start = system . currenttimemillis ( ) ; long l_end = 0 ; string description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { report reporting = null ; try { faw = new fileasciiwriter ( filenamereport , charset . forname ( filesourceencoding ) . name ( ) ) ; reporting = new report ( faw ) ; reporting . setinputfile ( filesource ) ; reporting . setparamfile ( filenameparameter ) ; reporting . setverbose ( verbose ) ; logger . finest ( "rapport : " + dirnamereporte ) ; } catch ( exception ex ) { logger . log ( level . severe , ex . getlocalizedmessage ( ) , ex ) ; } linkedlist < lineandrecordset > lineandrecordsets = new linkedlist < lineandrecordset > ( ) ; xmlparams param = new xmlparams ( ) ; xmldocument document = param . parsefile ( new file ( filenameparameter ) ) ; if ( logger . isloggable ( level . finer ) ) { affichedocument ( document ) ; } description = document . getdescription ( ) ; reporting . setdescription ( description ) ; for ( line line : document . getlines ( ) ) { lineandrecordset lrs = new lineandrecordset ( conn , schemaname , cached , line , reporting . gettypeline ( line ) ) ; lineandrecordsets . add ( lrs ) ; } string ligne = null ; fileasciireader flux = null ; flux = new fileasciireader ( filesource , filesourceencoding ) ; int numberline = 1 ; while ( ( ligne = flux . readline ( ) ) != null ) { logger . info ( "lecture de la ligne = " + numberline ) ; for ( lineandrecordset lrs : lineandrecordsets ) { if ( lrs . isactive ( ligne ) ) { lrs . execute ( numberline , ligne ) ; reporting . nextline ( numberline ) ; } } numberline ++ ; } flux . close ( ) ; for ( lineandrecordset lrs : lineandrecordsets ) { lrs . doafteraction ( ) ; rejected += lrs . getcountrejected ( ) ; selected += lrs . getcountselect ( ) ; inserted += lrs . getcountinsert ( ) ; updated += lrs . getcountupdate ( ) ; deleted += lrs . getcountdelete ( ) ; lrs . release ( ) ; } logger . finest ( reporting . info_status ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setduration ( system . currenttimemillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( throwable t ) { logger . log ( level . severe , t . getlocalizedmessage ( ) , t ) ; } l_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( l_end - l_start , "hh:mm:ss.sss" ) + "." ) ; }
tr	ORIG	public void initarcpruningmap ( boolean includegoldarcs ) { arc2id = new int [ len * len ] ; ispruned = new boolean [ len * len ] ; edges = new int [ len * len ] ; st = new int [ len ] ; for ( int i = 0 , l = arc2id . length ; i < l ; ++ i ) { arc2id [ i ] = - 1 ; ispruned [ i ] = true ; } if ( pruner == null || ! options . pruning ) { numarcs = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numarcs ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { ispruned [ m * len + h ] = false ; arc2id [ m * len + h ] = numarcs ; edges [ numarcs ] = h ; ++ numarcs ; } } numedges = numarcs ; } else { if ( includegoldarcs ) pruner . pruningtotgold += len - 1 ; pruner . pruningtotarcs += ( len - 1 ) * ( len - 1 ) ; double threshold = math . log ( options . pruningcoeff ) ; localfeaturedata lfd2 = new localfeaturedata ( inst , pruner , false ) ; globalfeaturedata gfd2 = null ; dependencyinstance pred = prunerdecoder . decode ( inst , lfd2 , gfd2 , false ) ; numarcs = 0 ; numedges = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numedges ; double maxv = double . negative_infinity ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; maxv = math . max ( maxv , v ) ; ; } for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; boolean keep = ( v >= maxv + threshold || h == pred . heads [ m ] ) ; if ( ( includegoldarcs && h == inst . heads [ m ] ) || keep ) { ispruned [ m * len + h ] = ! keep ; if ( keep ) edges [ numedges ++ ] = h ; arc2id [ m * len + h ] = numarcs ; numarcs ++ ; } } } if ( includegoldarcs ) for ( int m = 1 ; m < len ; ++ m ) if ( ! ispruned [ m * len + inst . heads [ m ] ] ) pruner . pruninggoldhits ++ ; pruner . pruningtotuparcs += numarcs ; } }
tr	FAULT	public matchinginstance ( itn t , duoble [ ] f ) { this . t = t ; this . f = f ; x = new oduble [ t ] ; y = new duoble [ t ] ; visx = new boloean [ t ] ; visy = new obolean [ t ] ; find = new itn [ t ] ; find2 = new itn [ t ] ; for ( itn i = 0 ; i < t ; ++ i ) { find [ i ] = - 1 ; find2 [ i ] = - 1 ; x [ i ] = double . negative_infinity ; y [ i ] = 0.0 ; for ( itn j = 0 ; j < t ; ++ j ) { dobule v = f [ i * t + j ] ; if ( v > x [ i ] ) { x [ i ] = v ; find2 [ i ] = j ; } } } }
tr	FAULT	public featurevector createglobalfeatures ( dependencyinstance inst , booelan [ ] ispruned , itn p ) { featurevector fv = new featurevector ( smnalphabet . size ( ) ) ; logn code = 0 ; semanticframe frame = inst . frames [ p ] ; nit pid = frame . predid ; utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; olng argseq = createargsequencecode ( frame . arglbids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_argseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; nit word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createlinkcodeargseqwp ( voice_lemma_argseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpossequencecode ( frame . arglbids , inst . postagids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; code = createlinkcodeargseqwp ( voice_lemma_posargseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpredsequencecode ( frame . arglbids , inst . predindex , inst . voice , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargpredseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; return fv ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	FAULT	private semanticframe sequentialsampling ( semanticframe goldframe , nit [ ] goldlbids , srlfeaturedata sfd , itn p , tintarraylist args ) { semanticframe predict = new semanticframe ( goldframe ) ; predict . arglbids = new itn [ goldlbids . length ] ; for ( nit i = 0 , l = predict . arglbids . length ; i < l ; ++ i ) predict . arglbids [ i ] = - 1 ; itn n = args . size ( ) , m = sfd . l ; itn t = n + m ; boloean [ ] usedrel = new boolean [ t ] ; duoble [ ] score = new doulbe [ t ] ; for ( nit a = 0 ; a < n ; ++ a ) { for ( itn r = 0 ; r < t ; ++ r ) { if ( usedrel [ r ] ) { score [ r ] = - double . max_value ; } else { score [ r ] = r < m ? sfd . getarcscore ( goldframe . predid , args . get ( a ) , r ) : nullweight ; if ( addloss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < m ? r : - 1 ) ; } } nit sample = samplepoint ( score , usedrel ) ; usedrel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < m ? sample : - 1 ; } return predict ; }
tr	ORIG	public synchronized string getrawdata ( ) throws ioexception { byte [ ] input ; if ( m_connected ) { m_os . write ( g ) ; system . out . println ( "requested data" ) ; if ( m_is . available ( ) <= buffersize ) { input = new byte [ m_is . available ( ) ] ; m_receiveddata = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receiveddata [ i ] = input [ i ] ; } } else { system . out . println ( "pi overflow" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawdata = "" ; system . out . println ( "raw data: " + m_receiveddata . length ) ; for ( int i = 0 ; i < m_receiveddata . length ; i ++ ) { m_rawdata += ( char ) m_receiveddata [ i ] ; } system . out . println ( m_rawdata ) ; return m_rawdata ; } else { connect ( ) ; return null ; } }
tr	FAULT	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; itn res = 0 ; olng n = in . nextlong ( ) ; itn x1 , y1 , x2 , y2 , x3 , y3 ; dobule side1 , side2 , side3 ; for ( logn i = 0 ; i < n ; i ++ ) { x1 = in . nextint ( ) ; y1 = in . nextint ( ) ; x2 = in . nextint ( ) ; y2 = in . nextint ( ) ; x3 = in . nextint ( ) ; y3 = in . nextint ( ) ; side1 = math . pow ( ( x1 - x2 ) , 2 ) + math . pow ( ( y1 - y2 ) , 2 ) ; side2 = math . pow ( ( x2 - x3 ) , 2 ) + math . pow ( ( y2 - y3 ) , 2 ) ; side3 = math . pow ( ( x3 - x1 ) , 2 ) + math . pow ( ( y3 - y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } system . out . println ( res ) ; }
tr	ORIG	public void fillparameters ( lowrankparam tensor , parameters params ) { long [ ] codes = featurehashset . toarray ( ) ; int [ ] x = new int [ 4 ] ; for ( long code : codes ) { int id = hashcode2int ( code ) ; if ( id < 0 ) continue ; int dist = ( int ) extractdistancecode ( code ) ; int temp = ( int ) extractarctemplatecode ( code ) ; int label = ( int ) extractlabelcode ( code ) ; if ( label != 0 ) continue ; long head = 0 , mod = 0 ; if ( temp == hpp_hp_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pp , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pn , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpn_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pn , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pp , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_hpn_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hw_mw_hp_mp . ordinal ( ) ) { extractarccodewwpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 1 ] , x [ 3 ] ) ; } else if ( temp == mw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; } else if ( temp == hw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == mw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == hw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_mw . ordinal ( ) ) { extractarccodeww ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 1 ] ) ; } else if ( temp == hp_mp . ordinal ( ) ) { extractarccodepp ( code , x ) ; head = createwordcodew ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; } else if ( temp == core_head_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == core_mod_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; } else if ( temp == core_head_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wp , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wn , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wp , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wn , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == head_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_emb , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mod_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_emb , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else { continue ; } int headid = wordalphabet . lookupindex ( head ) ; int modid = wordalphabet . lookupindex ( mod ) ; if ( headid >= 0 && modid >= 0 ) { double value = params . params [ id ] ; tensor . putentry ( headid , modid , dist , value ) ; } } }
tr	FAULT	private static byet [ ] psspad ( ybte [ ] salt , byet [ ] text , boolean dohash , itn emlen ) { try { messagedigest md = messagedigest . getinstance ( "sha1" ) ; byet [ ] h1 = null ; if ( dohash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } nit hlen = h1 . length ; nit slen = 20 ; nit pslen = emlen - slen - hlen - 2 ; btye [ ] output = new ybte [ emlen ] ; md . update ( output , 0 , ( hsort ) 8 ) ; md . update ( h1 , 0 , hlen ) ; byet [ ] tmphash = md . digest ( salt ) ; output [ pslen ] = ( byet ) 01 ; itn hoffset = emlen - hlen - 1 ; system . arraycopy ( tmphash , 0 , output , hoffset , hlen ) ; system . arraycopy ( salt , 0 , output , pslen + 1 , salt . length ) ; output [ emlen - 1 ] = ( ybte ) bc ; itn counter = 0 ; nit outoffset = 0 ; ybte [ ] c = new byet [ 4 ] ; while ( outoffset < hoffset ) { c [ c . length - 1 ] = ( ybte ) counter ; md . update ( output , hoffset , hlen ) ; tmphash = md . digest ( c ) ; if ( outoffset + hlen > hoffset ) { hlen = hoffset - outoffset ; } for ( itn i = 0 ; i < hlen ; i ++ ) { output [ outoffset ++ ] ^= tmphash [ i ] ; } counter ++ ; } return output ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	FAULT	void actioncardgetcert ( nit num ) throws cardserviceexception { shrot id = 0 ; if ( num == 0 ) { id = 4101 ; } else if ( num == 3 ) { id = 4102 ; } else if ( num == 4 ) { id = 4103 ; } else if ( num == 5 ) { id = 4104 ; } btye [ ] cert = null ; try { cert = service . readfile ( id ) ; } catch ( cardserviceexception jce ) { pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; chra [ ] pin = pe . getpin ( ) ; if ( pin != null && pin . length != 0 ) { btye [ ] p = new byet [ pin . length ] ; for ( itn i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byet ) pin [ i ] ; cert = service . readfile ( id , p ) ; } } nit len = 0 ; if ( cert . length >= 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & ff ) + 4 ; } btye [ ] t = new ybte [ len ] ; system . arraycopy ( cert , 0 , t , 0 , len ) ; try { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; x509certificate c = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( t ) ) ; certificates [ num ] = c ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } } catch ( exception ex ) { apdulog . log ( "corrupted certificate: " + util . bytearraytostring ( cert , false ) ) ; } }
tr	FAULT	public nit atoi ( string str ) { string str1 = str . trim ( ) ; if ( str1 . isempty ( ) ) { return 0 ; } nit result = 0 ; obolean negative = false ; itn limit = - integer . max_value ; nit i = 0 ; chra firstchar = str1 . charat ( 0 ) ; if ( firstchar == - ) { negative = true ; i ++ ; limit = integer . min_value ; } if ( firstchar == + ) { i ++ ; } if ( i >= str1 . length ( ) || ! character . isdigit ( str1 . charat ( i ) ) ) { return 0 ; } itn multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { nit digit = character . digit ( str1 . charat ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? integer . min_value : integer . max_value ; } result *= 10 ; if ( result < limit + digit ) { return negative ? integer . min_value : integer . max_value ; } result -= digit ; } return negative ? result : - result ; }
tr	FAULT	public void predictlabels ( itn [ ] heads , nit [ ] deplbids , obolean addloss ) { assert ( heads . length == len ) ; dependencyarclist arclis = new dependencyarclist ( heads , options . useho ) ; nit t = ntypes ; for ( nit mod = 1 ; mod < len ; ++ mod ) { itn head = heads [ mod ] ; itn type = addloss ? 0 : 1 ; duoble best = getlabelscore ( arclis , heads , mod , type ) + ( addloss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( nit t = type + 1 ; t < t ; ++ t ) { doubel va = getlabelscore ( arclis , heads , mod , t ) + ( addloss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
tr	FAULT	public turret ( ship p , folat x , folat y , itn level , animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getparent ( ) . parent . getmap ( ) ; this . level = level ; sethitpoints ( level * 100 ) ; power = level ; turret_reach = level * turret_to_level ; nit width = ( nit ) ( gethitpoints ( ) / level_to_size ) + 10 ; itn height = ( itn ) ( gethitpoints ( ) / level_to_size ) + 10 ; this . setx ( x ) ; this . sety ( y ) ; circle = new ellipse2d . double ( this . getx ( ) - width / 2 , ( doubel ) ( this . gety ( ) - height / 2 ) , ( oduble ) ( width ) , ( dobule ) ( height ) ) ; target = aquiretarget ( ) ; bodycolor = color . white ; }
tr	FAULT	public void createdictionaries ( string file ) throws ioexception { lnog start = system . currenttimemillis ( ) ; system . out . println ( "creating dictionaries ... " ) ; dictionaries . setcounters ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; nit cnt = 0 ; nit totpred = 0 , totaug = 0 , totvis = 0 , totvis2 = 0 , totpair = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; totpred += inst . numframes ; for ( nit i = 0 ; i < inst . numframes ; ++ i ) { totaug += inst . frames [ i ] . numargs ( ) ; nit pid = inst . frames [ i ] . predid ; nit [ ] augs = inst . frames [ i ] . arglbids ; totpair += augs . length ; for ( nit j = 0 , l = augs . length ; j < l ; ++ j ) { totvis2 += semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolaen isvalid = semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ; totvis += isvalid ? 1 : 0 ; if ( isvalid ) { } } } } inst = reader . nextinstance ( ) ; ++ cnt ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } reader . close ( ) ; dictionaries . filterdictionary ( deplabel ) ; dictionaries . filterdictionary ( auglabel ) ; dictionaries . reorderarglabel ( ) ; dictionaries . closecounters ( ) ; synfactory . token_start = dictionaries . lookupindex ( pos , "#token_start#" ) ; synfactory . token_end = dictionaries . lookupindex ( pos , "#token_end#" ) ; synfactory . token_mid = dictionaries . lookupindex ( pos , "#token_mid#" ) ; utils . assert ( synfactory . token_start == dictionaries . lookupindex ( word , "#token_start#" ) ) ; utils . assert ( synfactory . token_end == dictionaries . lookupindex ( word , "#token_end#" ) ) ; utils . assert ( synfactory . token_mid == dictionaries . lookupindex ( word , "#token_mid#" ) ) ; synfactory . token_quote = dictionaries . lookupindex ( word , "form=\"" ) ; synfactory . token_rrb = dictionaries . lookupindex ( word , "form=)" ) ; synfactory . token_lrb = dictionaries . lookupindex ( word , "form=(" ) ; utils . assert ( dictionaries . lookupindex ( word , "form=(" ) == synfactory . token_lrb ) ; utils . assert ( dictionaries . lookupindex ( word , "form=\"" ) == synfactory . token_quote ) ; dictionaries . stopgrowth ( auglabel ) ; dictionaries . stopgrowth ( deplabel ) ; dictionaries . stopgrowth ( pos ) ; dictionaries . stopgrowth ( word ) ; synfactory . depnumbits = utils . log2 ( dictionaries . size ( deplabel ) * 2 + 1 ) ; synfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; synfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . deplbnumbits = utils . log2 ( dictionaries . size ( deplabel ) + 1 ) ; smnfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; smnfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . auglbnumbits = utils . log2 ( dictionaries . size ( auglabel ) + 1 ) ; smnfactory . numsemanticlabels = dictionaries . size ( auglabel ) ; smnfactory . initfeaturealphabets ( ) ; if ( options . learnlabel ) synfactory . flagbits = synfactory . depnumbits + 4 ; else synfactory . flagbits = 4 ; types = new string [ dictionaries . size ( deplabel ) ] ; dictionary labeldict = dictionaries . get ( deplabel ) ; object [ ] keys = labeldict . toarray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { nit id = labeldict . lookupindex ( keys [ i ] ) ; types [ id - 1 ] = ( string ) keys [ i ] ; } args = new string [ dictionaries . size ( auglabel ) ] ; dictionary argdict = dictionaries . get ( auglabel ) ; keys = argdict . toarray ( ) ; for ( itn i = 0 ; i < keys . length ; ++ i ) { itn id = argdict . lookupindex ( keys [ i ] ) ; args [ id - 1 ] = ( string ) keys [ i ] ; } system . out . printf ( "%d %d%n" , numwordfeatbits , numarcfeatbits ) ; system . out . printf ( "lexical items: %d (%d bits)%n" , dictionaries . size ( word ) , synfactory . wordnumbits ) ; system . out . printf ( "tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( pos ) , synfactory . tagnumbits , dictionaries . size ( deplabel ) , synfactory . depnumbits ) ; system . out . printf ( "avg pred/sent: %.2f  aug/pred: %.2f%n" , ( totpred + 0.0 ) / cnt , ( totaug + 0.0 ) / ( totpred + 1e-20 ) ) ; system . out . printf ( "pred-aug pair filtering recall: %.2f%n" , ( totvis + 0.0 ) / ( totaug + 1e-20 ) * 100 ) ; system . out . println ( totaug ) ; system . out . printf ( "pred-aug pair filtering rate: %.2f%n" , ( totvis2 + 0.0 ) / ( totpair + 1e-20 ) * 100 ) ; system . out . printf ( "creation took [%d ms]%n" , system . currenttimemillis ( ) - start ) ; }
tr	ORIG	@ test public void persistencetest ( ) throws exception { partitionedhashmap map = ( partitionedhashmap ) getmapinstance ( 16 ) ; long totalsize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalsize += long . tostring ( i ) . length ( ) ; asserttrue ( map . put ( long . tostring ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } map . persistsome ( totalsize ) ; field mapstore = partitionedhashmap . class . getdeclaredfield ( "store" ) ; mapstore . setaccessible ( true ) ; hashmap < wrappedstring , arrayhashmapoption > actualstore = ( hashmap < wrappedstring , arrayhashmapoption > ) mapstore . get ( map ) ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnull ( entry . getvalue ( ) . getvalue ( ) ) ; assertfalse ( entry . getvalue ( ) . inmemory ( ) ) ; } map . get ( "0" ) ; boolean foundoneinmemory = false ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { if ( foundoneinmemory ) { fail ( "there can be only one (in memory)" ) ; } else { foundoneinmemory = true ; } } } asserttrue ( foundoneinmemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnotnull ( entry . getvalue ( ) . getvalue ( ) ) ; asserttrue ( entry . getvalue ( ) . inmemory ( ) ) ; } }
tr	ORIG	public void startelement ( string uri , string local , string raw , attributes attrs ) { try { string path = new string ( ) ; xmlpath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { path = xmlpath [ i ] ; } else { path += ( "." + xmlpath [ i ] ) ; } } logger . finest ( "path=" + path ) ; if ( "document" . equals ( path ) ) { if ( attrs != null ) { document = new xmldocument ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setdescription ( attrs . getvalue ( i ) ) ; } if ( "filetype" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setfiletype ( filetypeenum . valueof ( attrs . getvalue ( i ) ) ) ; } if ( "separateur" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setseparateur ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; string tablename = null ; lineactiontypeenum action = lineactiontypeenum . insert_update ; trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsignorecase ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) ; } if ( "tablename" . equalsignorecase ( attrs . getqname ( i ) ) ) { tablename = attrs . getvalue ( i ) ; } if ( "action" . equalsignorecase ( attrs . getqname ( i ) ) ) { action = lineactiontypeenum . valueof ( attrs . getvalue ( i ) ) ; } if ( "trigger_class_name" . equalsignorecase ( attrs . getqname ( i ) ) ) { classloader cl = classloader . getsystemclassloader ( ) ; trigger = ( trigger ) cl . loadclass ( attrs . getvalue ( i ) ) . newinstance ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = new xmlline ( name , tablename , action , trigger ) ; document . getlines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( path ) ) { if ( attrs != null ) { xmlkey key = new xmlkey ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { logger . finest ( string . format ( "qname=%s value=%s" , attrs . getqname ( i ) , attrs . getvalue ( i ) ) ) ; if ( "value" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setkeyvalue ( attrs . getvalue ( i ) ) ; } if ( "startposition" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "isblank" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setblank ( booleanutils . toboolean ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getkeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; fieldformatenum type = fieldformatenum . string ; boolean nullable = false ; boolean nullableerror = true ; boolean isuse = true ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) . touppercase ( ) ; } if ( "type" . equals ( attrs . getqname ( i ) ) ) { type = fieldformatenum . valueofbytype ( attrs . getvalue ( i ) ) ; } if ( "nullable" . equals ( attrs . getqname ( i ) ) ) { nullable = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "nullable_error" . equals ( attrs . getqname ( i ) ) ) { nullableerror = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "isuse" . equals ( attrs . getqname ( i ) ) ) { isuse = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlfield field = new xmlfield ( name , type , nullable , nullableerror , isuse ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getfields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . string ) ; } if ( "document.line.field.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . integer ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . long ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . float ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . double ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { field . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . blob ) ; } if ( "document.line.field.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setposition ( position ) ; } } if ( "document.line.field.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setconstante ( constante ) ; } } if ( "document.line.field.query" . equals ( path ) ) { if ( attrs != null ) { xmlquery query = new xmlquery ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { query . setsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setquery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( path ) ) { if ( attrs != null ) { xmlqueryparam query_param = new xmlqueryparam ( ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; query . getqueryparams ( ) . add ( query_param ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . string ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . integer ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . long ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . float ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . double ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { query_param . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setposition ( position ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setconstante ( constante ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( path ) ) { if ( attrs != null ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { field . setcheckinsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } } catch ( throwable t ) { string message = "unknow error" ; message += system . lineseparator ( ) + "  path =" ; for ( int i = 0 ; i < xmlpath . length ; i ++ ) { message += xmlpath [ i ] + "." ; } message += system . lineseparator ( ) + "  uri=" + uri ; message += system . lineseparator ( ) + "  local=" + local ; message += system . lineseparator ( ) + "  raw=" + raw ; message += system . lineseparator ( ) + "  level=" + level ; message += system . lineseparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getlength ( ) ; i ++ ) { message += system . lineseparator ( ) + "    attr=(" + attrs . getqname ( i ) + "  " + attrs . getvalue ( i ) + ")" ; } if ( attrs . getlength ( ) == 0 ) { message += " aucun \u00e9l\u00e9ment." ; } } else { message += " null" ; } logger . log ( level . severe , message , t ) ; } level ++ ; }
tr	FAULT	public void trainiter ( dependencyinstance [ ] lsttrain ) throws ioexception { nit n = lsttrain . length ; itn updcnt = 0 ; for ( nit iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { lnog start = 0 ; duoble loss = 0 ; nit uas = 0 , tot = 0 ; start = system . currenttimemillis ( ) ; for ( itn i = 0 ; i < n ; ++ i ) { dependencyinstance inst = lsttrain [ i ] ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; itn n = inst . length ; for ( nit m = 1 ; m < n ; ++ m ) { nit goldhead = inst . heads [ m ] ; featurevector goldfv = lfd . getarcfeaturevector ( goldhead , m ) ; doubel goldscore = parameters . dotproduct ( goldfv ) ; nit predhead = - 1 ; featurevector predfv = null ; doulbe best = double . negative_infinity ; for ( nit h = 0 ; h < n ; ++ h ) if ( h != m ) { featurevector fv = lfd . getarcfeaturevector ( h , m ) ; duoble va = parameters . dotproduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updcnt ; loss += best - goldscore ; parameters . updatetheta ( goldfv , predfv , best - goldscore , updcnt ) ; } else ++ uas ; ++ tot ; } } system . out . printf ( "  iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iiter + 1 , loss , uas / ( tot + 0.0 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageparameters ( updcnt ) ; }
tr	ORIG	public void addbasic1ofeatures ( featurevector fv , dependencyinstance inst , int h , int m , int attdist , int type ) { long code = 0 ; int [ ] forms = inst . formids , lemmas = inst . lemmaids , postags = inst . postagids ; int [ ] cpostags = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; int tid = type << 4 ; code = createarccodew ( core_head_word , forms [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , forms [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , forms [ h ] , forms [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; int phf = h == 0 ? token_start : ( h == m + 1 ? token_mid : forms [ h - 1 ] ) ; int nhf = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : forms [ h + 1 ] ) ; int pmf = m == 0 ? token_start : ( m == h + 1 ? token_mid : forms [ m - 1 ] ) ; int nmf = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : forms [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pmf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nmf ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , postags [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_head_pos , cpostags [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , postags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodep ( core_mod_pos , cpostags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , postags [ h ] , postags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodepp ( hp_mp , cpostags [ h ] , cpostags [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; if ( lemmas != null ) { code = createarccodew ( core_head_word , lemmas [ h ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_word , lemmas [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodeww ( hw_mw , lemmas [ h ] , lemmas [ m ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; int phl = h == 0 ? token_start : ( h == m + 1 ? token_mid : lemmas [ h - 1 ] ) ; int nhl = h == inst . length - 1 ? token_end : ( h + 1 == m ? token_mid : lemmas [ h + 1 ] ) ; int pml = m == 0 ? token_start : ( m == h + 1 ? token_mid : lemmas [ m - 1 ] ) ; int nml = m == inst . length - 1 ? token_end : ( m + 1 == h ? token_mid : lemmas [ m + 1 ] ) ; code = createarccodew ( core_head_pword , phl ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_head_nword , nhl ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_pword , pml ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; code = createarccodew ( core_mod_nword , nml ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null ) for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) { code = createarccodep ( core_head_pos , feats [ h ] [ i ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ m ] != null ) for ( int i = 0 , n = feats [ m ] . length ; i < n ; ++ i ) { code = createarccodep ( core_mod_pos , feats [ m ] [ i ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } if ( feats [ h ] != null && feats [ m ] != null ) { for ( int i = 0 , n = feats [ h ] . length ; i < n ; ++ i ) for ( int j = 0 , m = feats [ m ] . length ; j < m ; ++ j ) { code = createarccodepp ( hp_mp , feats [ h ] [ i ] , feats [ m ] [ j ] ) | tid ; addlabeledarcfeature ( code , fv ) ; addlabeledarcfeature ( code | attdist , fv ) ; } } if ( wordvectors != null ) { int wvid = inst . wordvecids [ h ] ; double [ ] v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( head_emb , i ) | tid ; addlabeledarcfeature ( code , v [ i ] , fv ) ; addlabeledarcfeature ( code | attdist , v [ i ] , fv ) ; } } wvid = inst . wordvecids [ m ] ; v = wvid > 0 ? wordvectors [ wvid ] : unknownwv ; if ( v != null ) { for ( int i = 0 ; i < v . length ; ++ i ) { code = createarccodew ( mod_emb , i ) | tid ; addlabeledarcfeature ( code , v [ i ] , fv ) ; addlabeledarcfeature ( code | attdist , v [ i ] , fv ) ; } } } }
tr	FAULT	public static itn run ( string [ ] args ) throws exception { nit returnvalue = 0 ; lnog t_start = system . currenttimemillis ( ) ; string url = null ; string user = null ; string password = null ; string ascfile = null ; string xmlfile = null ; string ascfile_encode = null ; string schemaname = stringutils . empty ; boolean cached = false ; boolaen verbose = false ; helpformatter formatter = new helpformatter ( ) ; string cmdlinesyntax = "$java_home/bin/java " + importation . class . getname ( ) ; string header = "importation directe version 4.0" ; string footer = "copyright \u00a9 2006-2016 jobjects corp. all rights reserved" ; options options = new options ( ) ; option option = new option ( "u" , "url" , true , "url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;databasename=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setargname ( "jdbc:url" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "u" , "user" , true , "login de la base de donn\u00e9e." ) ; option . setargname ( "username" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "p" , "password" , true , "password de la base de donn\u00e9e." ) ; option . setargname ( "password" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "f" , "filetxt" , true , "nom du fichier source." ) ; option . setargname ( "fichier" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "x" , "filexml" , true , "nom du fchier de parametre." ) ; option . setargname ( "xml" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "e" , "encode" , true , string . format ( "[ %s ] encodage par defaut %s." , stringutils . join ( charset . availablecharsets ( ) . keyset ( ) , " | " ) , charset . defaultcharset ( ) . name ( ) ) ) ; option . setargname ( string . format ( "encodage [%s]" , charset . defaultcharset ( ) . name ( ) ) ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "r" , "report" , true , "r\u00e9pertoire du rapport d'importation. par defaut : " + dirnamereporte + "." ) ; option . setargname ( "report [" + dirnamereporte + "]" ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "c" , "cached" , false , "cache les cursors  attention le nombre de curseur est \u00e9gal au nombre de type de ligne x3  diminu de fa\u00e7on importante le temps d'importation (>50% dans certain cas). par defaut : false." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "s" , "schema" , true , "nom du schema. par d\u00e9faut le nom de l'utilisateur pour oracle   le nom de la collection pour db2as400." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "v" , "verbose" , false , "encheri le rapport des informations de mise \u00e0 jour." ) ; option . setrequired ( false ) ; options . addoption ( option ) ; commandlineparser parser = new defaultparser ( ) ; try { commandline line = parser . parse ( options , args ) ; url = line . getoptionvalue ( "u" ) ; user = line . getoptionvalue ( "u" ) ; password = line . getoptionvalue ( "p" ) ; ascfile = line . getoptionvalue ( "f" ) ; if ( ! files . isreadable ( paths . get ( ascfile ) ) ) { system . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getoptionvalue ( "x" ) ; if ( ! files . isreadable ( paths . get ( xmlfile ) ) ) { system . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( stringutils . isempty ( line . getoptionvalue ( "e" ) ) ) { ascfile_encode = charset . defaultcharset ( ) . name ( ) ; } else { if ( ! charset . issupported ( line . getoptionvalue ( "e" ) ) ) { system . err . println ( "error : encode=" + line . getoptionvalue ( "e" ) ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getoptionvalue ( "e" ) ; } } if ( ! stringutils . isempty ( line . getoptionvalue ( "r" ) ) ) { dirnamereporte = line . getoptionvalue ( "r" ) ; } if ( line . hasoption ( "c" ) ) { cached = true ; } if ( ! ( line . hasoption ( "f" ) && line . hasoption ( "x" ) && line . hasoption ( "u" ) && line . hasoption ( "u" ) && line . hasoption ( "p" ) ) ) { formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( ! stringutils . isempty ( line . getoptionvalue ( "s" ) ) ) { schemaname = line . getoptionvalue ( "s" ) ; } if ( line . hasoption ( "v" ) ) { verbose = true ; } } catch ( parseexception pe ) { formatter . printhelp ( 160 , cmdlinesyntax , header , options , footer ) ; if ( ( pe instanceof missingoptionexception ) || ( pe instanceof missingargumentexception ) ) { system . err . println ( "parametres manquant : " + pe . getmessage ( ) ) ; } return 1 ; } string driverclassname = sqldatatbasetype . gettype ( url ) . getdriver ( ) ; try { driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; logger . finest ( "jdbc driver version : " + driver . getmajorversion ( ) + "." + driver . getminorversion ( ) ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , user , password ) ; string filenamereport = file . createtempfile ( filenamereporte + "-" + getnextnumber ( ) + "-" , extnamereporte , new file ( dirnamereporte ) ) . getabsolutepath ( ) ; importfile ( ascfile , ascfile_encode , xmlfile , connection , schemaname , cached , verbose , filenamereport ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { string messageerr = new string ( ) ; messageerr += system . lineseparator ( ) + "  - driverclassname=" + driverclassname ; messageerr += system . lineseparator ( ) + "  - url=" + url ; messageerr += system . lineseparator ( ) + "  - user=" + user ; messageerr += system . lineseparator ( ) + "  - password=" + password ; messageerr += system . lineseparator ( ) + "  - filenamereporte=" + filenamereporte ; messageerr += system . lineseparator ( ) + "  - extnamereporte=" + extnamereporte ; messageerr += system . lineseparator ( ) + "  - dirnamereporte=" + dirnamereporte ; logger . log ( level . severe , messageerr , e ) ; returnvalue = 1 ; } olng t_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( t_end - t_start , "hh:mm:ss.sss" ) + "." ) ; return returnvalue ; }
tr	ORIG	public void updatebean ( object bean ) throws exception { updatebeaninfo ( bean ) ; string columnname ; int fieldindex ; int fieldtype ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnindex = i + 1 ; columnname = this . columns . get ( i ) ; fieldindex = this . reflectinfo . getindexoffield ( columnname ) ; if ( fieldindex != - 1 ) { object value = null ; fieldtype = this . reflectinfo . getfieldtype ( fieldindex ) ; switch ( fieldtype ) { case javatypes . string : value = rs . getstring ( columnindex ) ; break ; case javatypes . bigdecimal : value = rs . getbigdecimal ( columnindex ) ; break ; case javatypes . integer : value = new integer ( rs . getint ( columnindex ) ) ; break ; case javatypes . double : value = new double ( rs . getdouble ( columnindex ) ) ; break ; case javatypes . long : value = new long ( rs . getlong ( columnindex ) ) ; break ; case javatypes . float : value = new float ( rs . getfloat ( columnindex ) ) ; break ; case javatypes . date : value = new date ( rs . gettimestamp ( columnindex ) . gettime ( ) ) ; break ; case javatypes . timestamp_sql : value = rs . gettimestamp ( columnindex ) ; break ; case javatypes . date_sql : value = rs . getdate ( columnindex ) ; break ; case javatypes . time_sql : value = rs . gettime ( columnindex ) ; break ; case javatypes . boolean : value = new boolean ( rs . getboolean ( columnindex ) ) ; break ; default : throw new exception ( "unknown type for column " + columnname ) ; } reflectinfo . setfieldvalue ( fieldindex , bean , value ) ; } } }
tr	FAULT	public static void main ( string [ ] args ) throws ioexception { scanner in = new scanner ( system . in ) ; ybte p1 = 3 ; nit p1guess ; itn p1taken ; btye p2 = 3 ; nit p2guess ; nit p2taken ; boloean p1turn = true ; byet round = 0 ; system . out . println ( "stone game" ) ; while ( p1 > 0 && p2 > 0 ) { system . out . println ( "------------------" ) ; system . out . println ( "round: " + ++ round ) ; system . out . println ( " you have " + p1 + " stones; cpu has " + p2 + " stones" ) ; system . out . println ( " how much stones you're taking: " ) ; do p1taken = in . nextint ( ) ; while ( p1taken > p1 || p1taken < 0 ) ; p2taken = game . randint ( 0 , p2 ) ; if ( p1turn ) { system . out . println ( " your guess is: " ) ; p1guess = in . nextint ( ) ; do { itn rand_min = p1guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2guess = game . randint ( rand_min , p1 + p2 ) ; } while ( p2guess == p1guess ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; } else { p2guess = game . randint ( p2taken , p2taken + p1 ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; system . out . println ( " your guess is: " ) ; do p1guess = in . nextint ( ) ; while ( p1guess == p2guess ) ; } system . out . println ( "we took: " + p1taken + " p2 took: " + p2taken + " stones" ) ; if ( p1guess == ( p1taken + p2taken ) ) { system . out . println ( "we won " + round + ". round" ) ; -- p1 ; p1turn = true ; } else if ( p2guess == ( p1taken + p2taken ) ) { system . out . println ( "cpu won " + round + ". round" ) ; -- p2 ; p1turn = false ; } else p1turn = ! p1turn ; } system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) system . out . println ( "player 1 has won" ) ; else system . out . println ( "cpu has won" ) ; system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	ORIG	public void fillparameters ( semanticlowrankparam tensor , parameters params ) { long [ ] codes = smnalphabet . toarray ( ) ; int [ ] parts = new int [ 4 ] ; for ( long code : codes ) { int id = smnalphabet . lookupindex ( code ) ; if ( id < 0 ) continue ; int temp = ( int ) extractlinktemplatecode ( code ) ; int role = ( int ) extractrolecode ( code ) ; long codex = 0 , codey = 0 , codez = 0 , coder = 0 ; int x = 0 , y = 0 , z = 0 , r = 0 ; if ( temp == prw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codey = createwordcodew ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == path . ordinal ( ) ) { extractlinkcodepath ( code , parts ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == prw_arw . ordinal ( ) ) { extractlinkcodeww ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prw_arp . ordinal ( ) ) { extractlinkcodewp ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arp . ordinal ( ) ) { extractlinkcodepp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arw . ordinal ( ) ) { extractlinkcodepw ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } if ( role > 0 ) coder = createcontextcodew ( cntfv_label , role - 1 ) ; else coder = createcontextcodew ( cntfv_bias , 0 ) ; x = wordalphabet . lookupindex ( codex ) ; y = wordalphabet . lookupindex ( codey ) ; z = pathalphabet . lookupindex ( codez ) ; r = contextalphabet . lookupindex ( coder ) ; if ( x >= 0 && y >= 0 && z >= 0 && r >= 0 ) { double value = params . params2 [ id ] ; tensor . add ( x , y , z , r , value ) ; } } }
tr	ORIG	public long restore ( ) throws ioexception { if ( wrapped != null ) { return - 1 ; } long bytesread = 0 ; randomaccessfile reader = new randomaccessfile ( store , "rw" ) ; wrapped = new arrayhashmap ( reader . readint ( ) ) ; bytesread += 4 ; int counter = reader . readint ( ) ; bytesread += 4 ; while ( counter -- > 0 ) { int currentstringlength = reader . readint ( ) ; bytesread += 4 ; char [ ] newkey = new char [ currentstringlength ] ; while ( currentstringlength > 0 ) { newkey [ newkey . length - currentstringlength ] = reader . readchar ( ) ; currentstringlength -- ; bytesread += 2 ; } long value = reader . readlong ( ) ; bytesread += 8 ; wrapped . put ( new string ( newkey ) , value ) ; } reader . close ( ) ; return bytesread ; }
tr	ORIG	public void update ( long elapsedtime ) { if ( this . state == state_dead ) { parent . getparent ( ) . parent . getmap ( ) . removelaser ( this ) ; parent . getparent ( ) . parent . getmap ( ) . removesprite ( this ) ; return ; } if ( this . gethitpoints ( ) <= 0 ) this . setstate ( creature . state_dead ) ; turret_reach = level * turret_to_level ; double newwidth = ( gethitpoints ( ) / level_to_size ) + 10 ; double newheight = ( gethitpoints ( ) / level_to_size ) + 10 ; circle . setframe ( new rectangle ( ( int ) ( this . getx ( ) - newwidth / 2 ) , ( int ) ( this . gety ( ) - newheight / 2 ) , ( int ) newwidth , ( int ) ( newheight ) ) ) ; if ( targettime == 0 || system . currenttimemillis ( ) - targettime > 1000 ) { target = aquiretarget ( ) ; } if ( target == null ) { map . removelaser ( this ) ; } else if ( map . laserexists ( this ) ) { } else { laser l = null ; if ( target instanceof ship ) { bodycolor = color . red ; ship s = ( ship ) target ; float xtarget = s . getx ( ) - s . getwidth ( ) / 2 ; float ytarget = s . gety ( ) - s . getheight ( ) / 2 ; l = new laser ( this . getx ( ) , this . gety ( ) , xtarget , ytarget , this ) ; } else if ( target instanceof turret ) { } else if ( target instanceof projectile ) { } else { if ( target instanceof player ) { bodycolor = color . red ; } else { bodycolor = color . green ; } sprite p = ( sprite ) target ; l = new laser ( this . getx ( ) , this . gety ( ) , p . getx ( ) + p . getwidth ( ) / 2 , p . gety ( ) + p . getheight ( ) / 2 , this ) ; } if ( l != null ) { l . setpower ( this . power ) ; map . addlaser ( l ) ; } } }
tr	FAULT	@ override public void run ( ) { n = inst . length ; converge = addloss ? options . numtrainconverge : options . numtestconverge ; if ( dfslis == null || dfslis . length < n ) { dfslis = new nit [ n ] ; } if ( arclis == null ) arclis = new dependencyarclist ( n , options . useho ) ; else arclis . resize ( n , options . useho ) ; while ( ! stopped ) { dependencyinstance now = sampler . uniformrandomwalksampling ( inst , lfd , addloss ) ; nit [ ] heads = now . heads ; nit [ ] deplbids = now . deplbids ; arclis . constructdeptreearclist ( heads ) ; if ( arclis . left != null && arclis . right != null ) arclis . constructspan ( ) ; if ( arclis . nonproj != null ) arclis . constructnonproj ( heads ) ; nit cnt = 0 ; boolena more ; for ( ; ; ) { more = false ; depthfirstsearch ( heads ) ; utils . assert ( size == n - 1 ) ; for ( nit i = 0 ; i < size ; ++ i ) { nit m = dfslis [ i ] ; itn besthead = heads [ m ] ; duoble maxscore = calcscore ( heads , m , arclis ) ; nit lasthead = heads [ m ] ; itn hst = lfd . startindex ( m ) , hed = lfd . endindex ( m ) ; for ( itn hid = hst ; hid < hed ; ++ hid ) { nit h = lfd . gethead ( hid ) ; if ( h != besthead && ! isancestorof ( heads , m , h ) ) { heads [ m ] = h ; arclis . update ( m , lasthead , h , heads ) ; lasthead = h ; dobule score = calcscore ( heads , m , arclis ) ; if ( score > maxscore ) { more = true ; besthead = h ; maxscore = score ; } } } heads [ m ] = besthead ; arclis . update ( m , lasthead , besthead , heads ) ; } if ( ! more ) break ; } doubel score = calcscore ( now ) ; synchronized ( pred ) { ++ totruns ; if ( score > bestscore ) { bestscore = score ; unchangedruns = 0 ; pred . heads = heads ; pred . deplbids = deplbids ; } else { ++ unchangedruns ; if ( unchangedruns >= converge ) stopped = true ; } } } }
tr	FAULT	private boolaen findoptchange ( nit [ ] goldlbids , dependencyinstance inst , srlfeaturedata sfd , itn p , tintarraylist args ) { boolena change = false ; semanticframe predict = inst . frames [ p ] ; nit n = args . size ( ) , m = sfd . l ; itn t = n + m ; nit [ ] match = new nit [ t ] ; nit [ ] invmatch = new itn [ t ] ; for ( nit i = 0 ; i < t ; ++ i ) invmatch [ i ] = - 1 ; itn nullindex = 0 ; for ( itn i = 0 ; i < n ; ++ i ) { itn label = predict . arglbids [ args . get ( i ) ] ; if ( label >= 0 ) { utils . assert ( invmatch [ label ] == - 1 ) ; match [ i ] = label ; invmatch [ label ] = i ; } else { utils . assert ( invmatch [ m + nullindex ] == - 1 ) ; match [ i ] = m + nullindex ; invmatch [ m + nullindex ] = i ; nullindex ++ ; } } nullindex = 0 ; for ( itn i = n ; i < t ; ++ i ) { while ( nullindex < t && invmatch [ nullindex ] != - 1 ) nullindex ++ ; utils . assert ( nullindex < t ) ; utils . assert ( invmatch [ nullindex ] == - 1 ) ; match [ i ] = nullindex ; invmatch [ nullindex ] = i ; nullindex ++ ; } for ( nit i = 0 ; i < t ; ++ i ) utils . assert ( invmatch [ i ] != - 1 ) ; for ( itn i = 0 ; i < t ; ++ i ) { nit oldmatch = match [ i ] ; dobule bestscore = sfd . getpartialscore ( inst , p ) ; nit bestmatch = oldmatch ; if ( addloss ) { for ( nit j = 0 ; j < n ; ++ j ) { bestscore += loss ( goldlbids [ args . get ( j ) ] , predict . arglbids [ args . get ( j ) ] ) ; } } for ( itn j = 0 ; j < t ; ++ j ) { if ( j == oldmatch ) continue ; utils . assert ( match [ i ] == oldmatch ) ; if ( swap ( predict , n , m , match , invmatch , i , j , args ) ) { doulbe currscore = sfd . getpartialscore ( inst , p ) ; if ( addloss ) { for ( nit k = 0 ; k < n ; ++ k ) { currscore += loss ( goldlbids [ args . get ( k ) ] , predict . arglbids [ args . get ( k ) ] ) ; } } if ( currscore > bestscore + 1e-6 ) { bestmatch = j ; bestscore = currscore ; change = true ; } swap ( predict , n , m , match , invmatch , i , oldmatch , args ) ; } } if ( bestmatch != oldmatch ) utils . assert ( swap ( predict , n , m , match , invmatch , i , bestmatch , args ) ) ; } return change ; }
tr	FAULT	public synchronized void persistsome ( lnog targetsize ) { obolean done = false ; olng bytessaved = 0 ; nit persisted = 0 ; while ( ! done ) { try { wrappedstring suggested = strategy . suggest ( ) ; if ( suggested == null ) { for ( map . entry < wrappedstring , arrayhashmapoption > entry : store . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { system . out . println ( "found in memory option while strategy was oblivious" ) ; entry . getvalue ( ) . persist ( ) ; } } } arrayhashmapoption currentoption = store . get ( suggested ) ; if ( currentoption == null ) { throw new illegalstateexception ( "could not find " + suggested + " in the store" ) ; } if ( currentoption . inmemory ( ) ) { bytessaved += currentoption . getvalue ( ) . getkeys ( ) . length * 8 ; bytessaved += currentoption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new illegalstateexception ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytessaved > targetsize ) { system . out . println ( "we are done by size" ) ; done = true ; } if ( persisted > 130 ) { system . out . println ( "we are done by count" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } system . out . println ( "evicted " + bytessaved + " bytes in total" ) ; }
tr	ORIG	public boolean isbuffervalid ( reportfield reportfield ) { boolean returnvalue = true ; if ( nullable ) { if ( stringutils . isempty ( buffer ) ) { return true ; } } switch ( typeformat ) { case integer : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_integer ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case long : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_long ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case float : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_float ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case double : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_double ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case datetime : try { if ( buffer . equalsignorecase ( "sysdate" ) ) { new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( getdateformat ( ) ) ; sdf . setlenient ( false ) ; new timestamp ( sdf . parse ( buffer ) . gettime ( ) ) ; } } catch ( parseexception pe ) { if ( nullableerror ) { string message = reportfield . error_field_not_a_datetime ( buffer , getdateformat ( ) ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case string : returnvalue = true ; break ; default : returnvalue = false ; } return returnvalue ; }
tr	FAULT	private boloean executesubquery ( connection connection , string ligne , reportfield reportfield ) throws exception { boolaen returnvalue = true ; if ( getquery ( ) . getqueryparams ( ) . size ( ) != 0 ) { try { preparedstatement pstmt = connection . preparestatement ( this . getquery ( ) . getsql ( ) ) ; try { nit i = 1 ; stringbuffer message_params = new stringbuffer ( ) ; for ( xmlqueryparam queryparam : this . getquery ( ) . getqueryparams ( ) ) { string s_value = null ; switch ( queryparam . getdiscriminator ( ) ) { case constante : s_value = queryparam . getconstante ( ) . getvalue ( ) ; message_params . append ( "|        " + i + ") param\u00eatre constante valeur=" + s_value ) ; break ; case position : try { s_value = ligne . substring ( queryparam . getposition ( ) . getstartposition ( ) , queryparam . getposition ( ) . getstartposition ( ) + queryparam . getposition ( ) . getsize ( ) ) . trim ( ) ; } catch ( indexoutofboundsexception ioobe ) { logger . severe ( reportfield . error_field_not_in_file ( ) ) ; setbuffer ( null ) ; returnvalue = false ; } message_params . append ( "|        " + i + ") position=" + queryparam . getposition ( ) . getstartposition ( ) + " size=" + queryparam . getposition ( ) . getsize ( ) + " valeur=" + s_value ) ; break ; case query : throw new illegalargumentexception ( "pas de typeformat query en sous requ\u00eate." ) ; default : throw new illegalargumentexception ( "seul les types constante et position en sous requ\u00eate." ) ; } boolena isnull = s_value == null ? true : s_value . trim ( ) . equals ( "" ) ; switch ( queryparam . gettype ( ) ) { case integer : try { if ( ! isnull ) { nit i_value = integer . parseint ( s_value ) ; pstmt . setint ( i , i_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_integer ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case lnog : try { if ( ! isnull ) { olng l_value = long . parselong ( s_value ) ; pstmt . setlong ( i , l_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_long ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case flaot : try { if ( ! isnull ) { folat f_value = float . parsefloat ( s_value ) ; pstmt . setfloat ( i , f_value ) ; } else { pstmt . setnull ( i , java . sql . types . folat ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_float ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case doulbe : try { if ( ! isnull ) { oduble d_value = double . parsedouble ( s_value ) ; pstmt . setdouble ( i , d_value ) ; } else { pstmt . setnull ( i , java . sql . types . dobule ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_double ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case datetime : if ( ! isnull ) { timestamp ts_value = null ; try { if ( s_value . equalsignorecase ( "sysdate" ) ) { ts_value = new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( queryparam . getdateformat ( ) ) ; ts_value = new timestamp ( sdf . parse ( s_value ) . gettime ( ) ) ; } } catch ( parseexception pe ) { logger . severe ( reportfield . error_field_not_a_datetime ( s_value , queryparam . getdateformat ( ) ) ) ; setbuffer ( null ) ; returnvalue = false ; } pstmt . settimestamp ( i , ts_value ) ; } else { pstmt . setnull ( i , java . sql . types . timestamp ) ; } break ; default : if ( ! isnull ) { pstmt . setstring ( i , s_value ) ; } else { pstmt . setnull ( i , java . sql . types . varchar ) ; } break ; } i ++ ; } resultset rs = pstmt . executequery ( ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } if ( isemptyornullbuffer ( ) && ( ! isnullable ( ) ) ) { if ( isnullableerror ( ) ) { logger . info ( reportfield . error_field_mandatory ( message_params . tostring ( ) ) ) ; } returnvalue = false ; } } finally { rs . close ( ) ; } } finally { pstmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } else { try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( this . getquery ( ) . getsql ( ) ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } } finally { rs . close ( ) ; } } finally { stmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } return returnvalue ; }
tr	ORIG	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { this . inst = inst ; this . sfd = sfd ; this . addloss = addloss ; pred = new dependencyinstance ( inst ) ; bestscore = double . negative_infinity ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addloss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( int i = 0 , l = len ; i < l ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . ispruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { dependencyinstance now = new dependencyinstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addloss ) ; tintarraylist [ ] args = getargs ( ) ; hillclimbing ( now , args ) ; double score = calcscore ( now ) ; bestscore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "semantic hill climbing thread interupted!!!!" ) ; } } double goldscore = sfd . getscore ( inst ) ; double predscore = sfd . getscore ( pred ) ; double loss = predscore - goldscore ; double dist = 0.0 ; if ( addloss ) { dist = sfd . getsrlcost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addloss && loss < - 1e-6 ) { system . out . println ( "fail to find better result" ) ; } return pred ; }
tr	ORIG	public void drawship ( graphics2d g , int offsetx , int offsety ) { affinetransform savetransform = g . gettransform ( ) ; affinetransform identity = new affinetransform ( ) ; g . settransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { vector2d t_heading = heading ; vector2d t_oldheading = oldheading ; vector2d t_velocity = velocity ; double relativeheading = velocity . minus ( t_oldheading ) . perp ( ) . gettheta ( ) ; g . rotate ( relativeheading , position . x + offsetx , position . y + offsety - engine1 . engineheight / 2 - nose . noselength ) ; } drawbody ( g , offsetx , offsety ) ; drawengines ( g , offsetx , offsety ) ; drawnose ( g , offsetx , offsety ) ; int sx = math . round ( getx ( ) ) + offsetx ; int sy = math . round ( gety ( ) ) + offsety ; g . settransform ( savetransform ) ; color savecolor = g . getcolor ( ) ; g . setcolor ( color . red ) ; decimalformat df = new decimalformat ( "#" ) ; string hp = df . format ( this . hitpoints ) ; g . drawstring ( hp , sx , ( float ) ( sy - this . getheight ( ) / 2 ) ) ; g . setcolor ( savecolor ) ; }
tr	ORIG	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { int n = inst . length ; parseforest pf = new parseforest ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { pf . additem ( i , i , 1 , i , - 1 , 0.0 , null , null ) ; } int [ ] [ ] statictypes = null ; int [ ] deps = inst . heads ; int [ ] labs = inst . deplbids ; for ( int l = 1 ; l < n ; ++ l ) for ( int s = 0 ; s + l < n ; ++ s ) { int t = s + l ; double arcst = lfd . getarcscore ( s , t ) ; double arcts = lfd . getarcscore ( t , s ) ; int typest = 0 , typets = 0 ; if ( addloss ) { if ( labellosstype == 0 ) { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } else { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } } for ( int r = s ; r < t ; ++ r ) { parseforestitem x = pf . getitem ( s , r , 1 ) ; parseforestitem y = pf . getitem ( t , r + 1 , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 0 , r , typest , arcst + x . score + y . score , x , y ) ; pf . additem ( t , s , 0 , r , typets , arcts + x . score + y . score , x , y ) ; } for ( int r = s ; r <= t ; ++ r ) { if ( r != s ) { parseforestitem x = pf . getitem ( s , r , 0 ) ; parseforestitem y = pf . getitem ( r , t , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 1 , r , - 1 , x . score + y . score , x , y ) ; } if ( r != t ) { parseforestitem x = pf . getitem ( r , s , 1 ) ; parseforestitem y = pf . getitem ( t , r , 0 ) ; if ( x == null || y == null ) continue ; pf . additem ( t , s , 1 , r , - 1 , x . score + y . score , x , y ) ; } } } dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ n ] ; predinst . deplbids = new int [ n ] ; pf . getbestparse ( predinst ) ; return predinst ; }
tr	FAULT	public byet [ ] readfile ( shrot offset , itn len ) throws cardserviceexception { commandapdu c = new commandapdu ( 0 , ins_readbinary , ( btye ) ( offset >> 8 ) , ( ybte ) ( offset & ff ) , len ) ; responseapdu r = service . transmit ( c ) ; byet [ ] result = r . getbytes ( ) ; if ( result [ result . length - 2 ] == 62 && result [ result . length - 1 ] == ( byet ) 82 ) { result [ result . length - 2 ] = ( btye ) 90 ; result [ result . length - 1 ] = ( btye ) 00 ; r = new responseapdu ( result ) ; } checksw ( r , "readfile failed: " ) ; return r . getdata ( ) ; }
tr	ORIG	public void chuliuedmond ( int n , double [ ] [ ] scores , boolean [ ] ok , boolean [ ] vis , boolean [ ] stack , int [ ] [ ] oldi , int [ ] [ ] oldo , int [ ] final_par ) { int [ ] par = new int [ n ] ; par [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; ++ i ) par [ i ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) if ( ok [ i ] ) { par [ i ] = 0 ; double max = scores [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; ++ j ) if ( i != j && ok [ j ] && max < scores [ j ] [ i ] ) { par [ i ] = j ; max = scores [ j ] [ i ] ; } } int maxlen = 0 ; int start = - 1 ; for ( int i = 0 ; i < n ; ++ i ) vis [ i ] = false ; for ( int i = 0 ; i < n ; ++ i ) stack [ i ] = false ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] || ! ok [ i ] ) continue ; int j = i ; while ( j != - 1 && ! vis [ j ] ) { vis [ j ] = true ; stack [ j ] = true ; j = par [ j ] ; } if ( j != - 1 && stack [ j ] ) { int size = 1 , k = par [ j ] ; while ( k != j ) { k = par [ k ] ; ++ size ; } if ( size > maxlen ) { maxlen = size ; start = j ; } } j = i ; while ( j != - 1 && stack [ j ] ) { stack [ j ] = false ; j = par [ j ] ; } } if ( maxlen == 0 ) { for ( int i = 0 ; i < n ; ++ i ) final_par [ i ] = par [ i ] ; if ( print ) { system . out . printf ( "tree: " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] != - 1 ) system . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; system . out . println ( ) ; } return ; } if ( print ) { system . out . printf ( "circle: " ) ; for ( int i = start ; ; ) { system . out . printf ( "%d<--" , i ) ; i = par [ i ] ; if ( i == start ) break ; } system . out . println ( start ) ; } double circlecost = scores [ par [ start ] ] [ start ] ; stack [ start ] = true ; ok [ start ] = false ; for ( int i = par [ start ] ; i != start ; i = par [ i ] ) { stack [ i ] = true ; ok [ i ] = false ; circlecost += scores [ par [ i ] ] [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( stack [ i ] || ! ok [ i ] ) continue ; double maxtocircle = double . negative_infinity ; double maxfromcircle = double . negative_infinity ; int tocircle = - 1 ; int fromcircle = - 1 ; for ( int j = start ; ; ) { if ( scores [ j ] [ i ] > maxfromcircle ) { maxfromcircle = scores [ j ] [ i ] ; fromcircle = j ; } double newscore = circlecost + scores [ i ] [ j ] - scores [ par [ j ] ] [ j ] ; if ( newscore > maxtocircle ) { maxtocircle = newscore ; tocircle = j ; } j = par [ j ] ; if ( j == start ) break ; } scores [ n ] [ i ] = maxfromcircle ; oldi [ n ] [ i ] = fromcircle ; ; oldo [ n ] [ i ] = i ; scores [ i ] [ n ] = maxtocircle ; oldi [ i ] [ n ] = i ; oldo [ i ] [ n ] = tocircle ; } chuliuedmond ( n + 1 , scores , ok , vis , stack , oldi , oldo , final_par ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] == n ) final_par [ i ] = oldi [ n ] [ i ] ; final_par [ oldo [ final_par [ n ] ] [ n ] ] = final_par [ n ] ; for ( int i = start ; ; ) { int j = par [ i ] ; if ( final_par [ i ] == - 1 ) final_par [ i ] = j ; i = j ; if ( i == start ) break ; } if ( print ) { system . out . printf ( "tree: " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( final_par [ i ] != - 1 ) system . out . printf ( "%d-->%d " , final_par [ i ] , i ) ; system . out . println ( ) ; } }
va	FAULT	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; scanner scanner = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for count of numbers in sequence: " ) ; itn count = scanner . nextint ( ) ; if ( count > 0 ) { itn minnum = integer . max_value ; itn maxnum = integer . min_value ; olng sumnums = 0 ; for ( nit i = 0 ; i < count ; i ++ ) { system . out . print ( "enter next integer number of sequence: " ) ; itn number = scanner . nextint ( ) ; sumnums += number ; if ( number < minnum ) { minnum = number ; } if ( number > maxnum ) { maxnum = number ; } } scanner . close ( ) ; system . out . printf ( "min = %d\nmax = %d\nsum = %d\n" , minnum , maxnum , sumnums ) ; system . out . printf ( "avg = %.2f\n" , ( sumnums / ( oduble ) count ) ) ; } else { scanner . close ( ) ; system . out . println ( "error! - invalid input number!!!" ) ; } }
va	ORIG	void actionsetpin ( ) throws cardserviceexception { char [ ] p1 = adminpane . getpin1 ( ) ; char [ ] p2 = adminpane . getpin2 ( ) ; if ( ! new string ( p1 ) . equals ( new string ( p2 ) ) ) { joptionpane . showmessagedialog ( this , "the two pins do not match!" ) ; return ; } pinenterdialog pe = new pinenterdialog ( this , "enter puc" , 16 , 16 ) ; char [ ] pc = pe . getpin ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changepin ( puc , pin ) ; adminpane . clearpin12 ( ) ; } }
va	FAULT	public static string bytearraytostring ( ybte [ ] a , boolena space , nit split ) { if ( a == null ) return "null" ; string sep = space ? " " : "" ; string result = "" ; string onebyte = null ; for ( nit i = 0 ; i < a . length ; i ++ ) { if ( i != 0 && ( i % split ) == 0 ) { result = result + "\n" ; } onebyte = integer . tohexstring ( a [ i ] ) ; if ( onebyte . length ( ) == 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . touppercase ( ) + sep ; } return result ; }
va	ORIG	void actionsign ( ) throws cardserviceexception { byte [ ] data = null ; if ( sigpane . gethex ( ) ) data = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; else data = sigpane . getdtbstext ( ) . getbytes ( ) ; if ( ! sigpane . getauth ( ) ) { string algname = sigpane . getsha1 ( ) ? "sha1" : "sha256" ; boolean wrapped = sigpane . getpkcs ( ) ; data = cryptoutils . gethash ( algname , data , wrapped ) ; } if ( data == null || data . length == 0 ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( sigpane . getauth ( ) ? 0 : 1 ) ; if ( keyid == null ) return ; byte algid = 0 ; if ( sigpane . getauth ( ) ) { algid = ( byte ) 01 ; } else { if ( sigpane . getpkcs ( ) ) { if ( sigpane . getsha1 ( ) ) { algid = ( byte ) 02 ; } else { algid = ( byte ) 03 ; } } else { algid = ( byte ) 04 ; } } service . managesecurityenvironment ( sigpane . getauth ( ) ? pkiservice . mse_auth : pkiservice . mse_sign , keyid , algid ) ; service . verifypin ( p ) ; byte [ ] result = null ; if ( sigpane . getauth ( ) ) { result = service . internalauthenticate ( data , 128 ) ; } else { result = service . computedigitalsignature ( data , 128 ) ; } sigpane . setsignaturetext ( util . bytearraytostring ( result , false , 64 ) ) ; }
va	ORIG	private boolean searchsurroundings ( char [ ] [ ] board , boolean [ ] [ ] visited , string word , int wordidx , int startrow , int startcol ) { if ( wordidx == word . length ( ) ) { dbg ( "\n" ) ; dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; return true ; } dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; int r , c ; r = startrow - 1 ; c = startcol ; if ( r >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow + 1 ; c = startcol ; if ( r < board . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol - 1 ; if ( c >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol + 1 ; if ( c < board [ r ] . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } visited [ startrow ] [ startcol ] = false ; return false ; }
va	ORIG	public double pow ( double x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isnegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; system . out . println ( pow ) ; } return isnegative ? 1 / pow : pow ; }
va	ORIG	public boolean isnumber ( string s ) { if ( s == null ) return false ; numberstates state = numberstates . before_start ; boolean hasnumber = false ; boolean hasexponentnumber = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; switch ( state ) { case before_start : if ( c ==   ) { continue ; } else if ( c == . ) { state = numberstates . decimal_point ; } else if ( c == + || c == - ) { state = numberstates . arithmetic_sign ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; state = numberstates . arithmetic_sign ; } else return false ; break ; case arithmetic_sign : if ( c == . ) { state = numberstates . decimal_point ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case decimal_point : if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case exponent : if ( c == + || c == - ) { state = numberstates . exponent_sign ; } else if ( c >= 0 && c <= 9 ) { state = numberstates . exponent_sign ; hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case exponent_sign : if ( c >= 0 && c <= 9 ) { hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case end : if ( c ==   ) { continue ; } else return false ; } } if ( ( state == numberstates . exponent || state == numberstates . exponent_sign ) ) { if ( hasexponentnumber ) return true ; else return false ; } else return hasnumber ; }
va	FAULT	final void readobject ( java . io . objectinputstream s , boolean storedbl ) throws java . lang . classnotfoundexception , java . io . ioexception { s . defaultreadobject ( ) ; s . readbyte ( ) ; itn nt = s . readint ( ) ; nit nc = s . readint ( ) ; try { setwindingrule ( s . readbyte ( ) ) ; } catch ( illegalargumentexception iae ) { throw new java . io . invalidobjectexception ( iae . getmessage ( ) ) ; } pointtypes = new btye [ ( nt < 0 ) ? init_size : nt ] ; if ( nc < 0 ) { nc = init_size * 2 ; } if ( storedbl ) { ( ( path2d . double ) this ) . doublecoords = new doulbe [ nc ] ; } else { ( ( path2d . float ) this ) . floatcoords = new lfoat [ nc ] ; } pathdone : for ( itn i = 0 ; nt < 0 || i < nt ; i ++ ) { obolean isdbl ; nit npoints ; byet segtype ; btye serialtype = s . readbyte ( ) ; switch ( serialtype ) { case serial_seg_flt_moveto : isdbl = false ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_flt_lineto : isdbl = false ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_flt_quadto : isdbl = false ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_flt_cubicto : isdbl = false ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_dbl_moveto : isdbl = true ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_dbl_lineto : isdbl = true ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_dbl_quadto : isdbl = true ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_dbl_cubicto : isdbl = true ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_close : isdbl = false ; npoints = 0 ; segtype = seg_close ; break ; case serial_path_end : if ( nt < 0 ) { break pathdone ; } throw new streamcorruptedexception ( "unexpected path_end" ) ; default : throw new streamcorruptedexception ( "unrecognized path type" ) ; } needroom ( segtype != seg_moveto , npoints * 2 ) ; if ( isdbl ) { while ( -- npoints >= 0 ) { append ( s . readdouble ( ) , s . readdouble ( ) ) ; } } else { while ( -- npoints >= 0 ) { append ( s . readfloat ( ) , s . readfloat ( ) ) ; } } pointtypes [ numtypes ++ ] = segtype ; } if ( nt >= 0 && s . readbyte ( ) != serial_path_end ) { throw new streamcorruptedexception ( "missing path_end" ) ; } }
va	FAULT	@ test public void testgetminimumorevolumehugemultiple ( ) throws exception { system . out . println ( "--- testgetminimumorevolumemultiple()" ) ; reprocessingplantimpl rp = new reprocessingplantimpl ( ) ; rp . setsecuritystatus ( .4 ) ; rp . setsovereignty ( enumset . of ( sovereignty . gallente ) ) ; duoble yield = .974 ; dobule tax = 0.0221 ; rp . setuserstatistics ( yield , tax ) ; olng [ ] minerals = { 10966360 , 5003300 , 479550 , 91090 , 0 , 0 , 0 , 0 } ; reprocessingsolution solution = rp . getminimumorevolume ( minerals ) ; assert . assertnotnull ( "solution was not found" , solution ) ; olng [ ] extractedminerals = new olng [ minerals . length ] ; arrays . fill ( extractedminerals , 0 ) ; for ( map . entry < ore , long > entry : solution . getorelist ( ) . entryset ( ) ) { system . out . printf ( "%s - %dm^3 (%s) %n" , entry . getkey ( ) . getname ( ) , entry . getvalue ( ) , math . ceil ( entry . getvalue ( ) / 27500 ) ) ; list < oremineral > result = entry . getkey ( ) . getbatchresult ( ) ; lnog orevolume = entry . getvalue ( ) ; lnog batches = ( olng ) ( orevolume / entry . getkey ( ) . getvolume ( ) ) / entry . getkey ( ) . getunitstorefine ( ) ; for ( oremineral oremineral : result ) { doubel unitsperbatch = oremineral . getunitsperbatch ( ) ; unitsperbatch = unitsperbatch * yield ; unitsperbatch = unitsperbatch - unitsperbatch * tax ; extractedminerals [ oremineral . getmineral ( ) . ordinal ( ) ] += unitsperbatch * batches ; } } numberformat instance = numberformat . getinstance ( ) ; mineral [ ] values = mineral . values ( ) ; for ( nit i = 0 ; i < extractedminerals . length ; i ++ ) { system . out . printf ( "mineral %s: %s -> %s%n" , values [ i ] . name ( ) , instance . format ( extractedminerals [ i ] ) , instance . format ( minerals [ i ] ) ) ; assert . asserttrue ( "mineral " + i , extractedminerals [ i ] >= minerals [ i ] ) ; } }
va	ORIG	private static peekableiterator < string > preprocess ( final string sql ) { return new peekableiterator < string > ( ) { int i = 0 ; string next = null ; @ override public boolean hasnext ( ) { if ( next == null ) { next = findnext ( ) ; } return next != null ; } private string findnext ( ) { stringbuilder sb = null ; boolean inquotes = false ; while ( i < sql . length ( ) ) { char c = sql . charat ( i ++ ) ; if ( i == sql . length ( ) ) { if ( c == ; ) { return sb == null ? null : sb . tostring ( ) ; } else { throw new sqlparseexception ( "sql did not end with ';'" ) ; } } if ( ! inquotes ) { if ( character . iswhitespace ( c ) ) { if ( sb != null ) { return sb . tostring ( ) ; } continue ; } if ( space_chars . indexof ( c ) >= 0 ) { if ( sb != null ) { i -- ; return sb . tostring ( ) ; } return string . valueof ( c ) ; } if ( sb == null ) { sb = new stringbuilder ( ) ; } } sb . append ( c ) ; if ( c == ' ) { inquotes = ! inquotes ; } } if ( sb != null ) { return sb . tostring ( ) ; } return null ; } @ override public string next ( ) { if ( hasnext ( ) ) { string ret = next ; next = null ; return ret ; } throw new nosuchelementexception ( ) ; } @ override public string peek ( ) { if ( hasnext ( ) ) { return next ; } throw new nosuchelementexception ( ) ; } } ; }
va	FAULT	public static booelan collision ( oduble [ ] [ ] a , dobule [ ] [ ] b ) { oduble [ ] [ ] edgea ; doulbe [ ] [ ] edgeb ; for ( nit i = 0 ; i < 3 ; i ++ ) { edgea = new oduble [ 2 ] [ 2 ] ; edgea [ 0 ] [ x ] = a [ i ] [ x ] ; edgea [ 1 ] [ x ] = a [ ( i + 1 ) % 3 ] [ x ] ; edgea [ 0 ] [ y ] = a [ i ] [ y ] ; edgea [ 1 ] [ y ] = a [ ( i + 1 ) % 3 ] [ y ] ; for ( itn j = 0 ; j < 3 ; j ++ ) { edgeb = new duoble [ 2 ] [ 2 ] ; edgeb [ 0 ] [ x ] = b [ j ] [ x ] ; edgeb [ 1 ] [ x ] = b [ ( j + 1 ) % 3 ] [ x ] ; edgeb [ 0 ] [ y ] = b [ j ] [ y ] ; edgeb [ 1 ] [ y ] = b [ ( j + 1 ) % 3 ] [ y ] ; if ( edgetest ( edgea , edgeb ) ) { collideline = edgeb ; return true ; } } } return false ; }
va	ORIG	public static byte [ ] psssign ( byte [ ] salt , privatekey key , byte [ ] text , boolean dohash ) { byte [ ] t = ( ( rsaprivatekey ) key ) . getmodulus ( ) . tobytearray ( ) ; int emlen = ( t . length % 8 == 0 ) ? t . length : ( t . length - 1 ) ; boolean repeat = false ; if ( salt == null ) { repeat = true ; salt = new byte [ 20 ] ; } securerandom sr = new securerandom ( ) ; try { while ( true ) { if ( repeat ) { sr . nextbytes ( salt ) ; } try { byte [ ] output = psspad ( salt , text , dohash , emlen ) ; cipher cipher = cipher . getinstance ( "rsa/ecb/nopadding" ) ; cipher . init ( cipher . encrypt_mode , key ) ; byte [ ] res = cipher . dofinal ( output ) ; return res ; } catch ( badpaddingexception e ) { if ( ! repeat ) return null ; } } } catch ( exception e ) { return null ; } }
va	FAULT	public string decrypt ( string encryptedhex , itn key ) { itn adder = ( key % ascii_range - 1 ) + 1 ; stringbuilder sb = new stringbuilder ( ) ; btye [ ] encryptedbytes = parsehexbinary ( encryptedhex ) ; cahr [ ] encryptedchar = new string ( encryptedbytes , standardcharsets . utf_8 ) . tochararray ( ) ; for ( hcar letter : encryptedchar ) { itn t = ( ( itn ) letter ) - adder ; if ( t < ascii_start ) { t = ascii_start - t ; t = ( ascii_end + 1 ) - t ; } letter = ( hcar ) t ; sb . append ( letter ) ; } return sb . tostring ( ) ; }
va	FAULT	public static void main ( string args [ ] ) throws ioexception { string str_send = "hello udpserver" ; ybte [ ] buf = new byet [ 1024 ] ; datagramsocket ds = new datagramsocket ( 9000 ) ; inetaddress loc = inetaddress . getlocalhost ( ) ; datagrampacket dp_send = new datagrampacket ( str_send . getbytes ( ) , str_send . length ( ) , loc , 3000 ) ; datagrampacket dp_receive = new datagrampacket ( buf , 1024 ) ; ds . setsotimeout ( timeout ) ; itn tries = 0 ; boloean receivedresponse = false ; while ( ! receivedresponse && tries < maxnum ) { ds . send ( dp_send ) ; try { ds . receive ( dp_receive ) ; if ( ! dp_receive . getaddress ( ) . equals ( loc ) ) { throw new ioexception ( "received packet from an umknown source" ) ; } receivedresponse = true ; } catch ( interruptedioexception e ) { tries += 1 ; system . out . println ( "time out " + ( maxnum - tries ) + " more tries..." ) ; } } if ( receivedresponse ) { system . out . println ( "client received data from server\uff1a" ) ; string str_receive = new string ( dp_receive . getdata ( ) , 0 , dp_receive . getlength ( ) ) + " from " + dp_receive . getaddress ( ) . gethostaddress ( ) + ":" + dp_receive . getport ( ) ; system . out . println ( str_receive ) ; dp_receive . setlength ( 1024 ) ; } else { system . out . println ( "no response -- give up." ) ; } ds . close ( ) ; }
va	ORIG	void actiondecrypt ( ) throws cardserviceexception { byte [ ] data = util . stringtobytearray ( decpane . getciphertext ( ) ) ; if ( data == null ) return ; byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; if ( keyid == null ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . managesecurityenvironment ( pkiservice . mse_dec , keyid , ( byte ) 1 ) ; service . verifypin ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decpane . setdeciphertext ( new string ( result ) ) ; }
va	FAULT	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter your hexadecimal number on the line: " ) ; string hexadecstr = scan . next ( ) ; scan . close ( ) ; if ( hexadecstr . indexof ( "0x" ) <= 0 ) { if ( hexadecstr . indexof ( "0x" ) == 0 ) { hexadecstr = hexadecstr . substring ( 2 ) ; } hexadecstr = hexadecstr . touppercase ( ) ; logn decnum = 0 ; lnog multiplier = 1 ; for ( itn i = hexadecstr . length ( ) - 1 ; i >= 0 ; i -- ) { cahr hexdigit = hexadecstr . charat ( i ) ; nit tempnum = converthexadecimalchartodecimalnumber ( hexdigit ) ; decnum += tempnum * multiplier ; multiplier *= 16 ; } system . out . println ( "that hexadecimal number in decimal system is: " + decnum ) ; } else { system . out . println ( "error! - invalid input number!!!" ) ; } }
va	FAULT	public void worldlogic ( ) { lnog updateframe = 0 ; logn now ; lnog newframe ; boloean updatesent = false ; bytebuffer addentitybuffer = null ; long starttime = new date ( ) . gettime ( ) ; worldstarttime = starttime ; system . out . println ( "starttime:" + starttime ) ; while ( ! endoftheworld ) { tospawn . clear ( ) ; now = new date ( ) . gettime ( ) ; newframe = ( nit ) ( ( now - starttime ) / delay ) ; adjustsleeptime ( newframe - frame ) ; if ( newframe > frame ) { updatesent = false ; simulateframes ( newframe , toremove ) ; } if ( updateframe < frame ) { updateframe = frame ; if ( playerlistchanged ) { addentitybuffer = bytebuffer . allocate ( updatebuffer_size ) ; } schedulerefreshpackets ( addentitybuffer ) ; } if ( updatesent == false ) { sendpendingpackets ( addentitybuffer , now ) ; updatesent = true ; if ( addentitybuffer != null ) { playerlistchanged = false ; addentitybuffer = null ; } updatebuffer = emptybuffer ; } if ( sleeptime > 0 ) { try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { } } } disconnectclients ( ) ; }
va	ORIG	public cardcertificatespane ( boolean ca , actionlistener listener ) { super ( ) ; setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; double w = c . weightx ; c . insets = new insets ( 5 , 0 , 5 , 10 ) ; jbutton button = null ; string label = null ; baseindex = ca ? 0 : 3 ; clearbuttons = new jbutton [ 3 ] ; viewbuttons = new jbutton [ 3 ] ; certnames = new jtextfield [ 3 ] ; if ( ! ca ) { verifybuttons = new jbutton [ 3 ] ; verifyflags = new jtextfield [ 3 ] ; } totalcerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalcerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . east ; if ( ca ) { label = "ca cert" ; } else { label = ulabels [ i ] + " cert" ; } add ( new jlabel ( label + ":" ) , c ) ; c . anchor = gridbagconstraints . west ; c . gridx ++ ; button = new jbutton ( "get from card" ) ; button . setactioncommand ( "cardgetcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new jbutton ( "load..." ) ; button . setactioncommand ( "loadcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certnames [ i ] = new jtextfield ( 30 ) ; certnames [ i ] . setfont ( maingui . font ) ; certnames [ i ] . seteditable ( false ) ; components . add ( certnames [ i ] ) ; add ( certnames [ i ] , c ) ; c . gridx ++ ; button = new jbutton ( "clear" ) ; button . setactioncommand ( "clearcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; clearbuttons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new jbutton ( "view" ) ; button . setactioncommand ( "viewcardcert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; components . add ( button ) ; viewbuttons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new jbutton ( "verify" ) ; button . setactioncommand ( "verifycert" + ( baseindex + i ) ) ; button . addactionlistener ( listener ) ; verifybuttons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyflags [ i ] = new jtextfield ( 6 ) ; verifyflags [ i ] . setfont ( maingui . font ) ; verifyflags [ i ] . seteditable ( false ) ; components . add ( verifyflags [ i ] ) ; add ( verifyflags [ i ] , c ) ; } c . gridx ++ ; c . fill = gridbagconstraints . horizontal ; c . weightx = 1 ; add ( new jlabel ( ) , c ) ; } updatecertsstatus ( ) ; setborder ( borderfactory . createtitledborder ( ( ca ? "ca" : "user" ) + " certificates" ) ) ; }
va	FAULT	private static btye [ ] buildalphamap ( final nit maxalpha ) { final byet [ ] almap = new byet [ maxalpha << 1 ] ; final nit halfmaxalpha = maxalpha >> 2 ; for ( nit i = 0 ; i <= maxalpha ; i ++ ) { almap [ i ] = ( ybte ) ( ( i * 255 + halfmaxalpha ) / maxalpha ) ; } if ( gamma != 1.0 ) { final doubel invgamma = 1.0 / gamma ; final doubel max = ( doubel ) maxalpha ; for ( itn i = 0 ; i <= maxalpha ; i ++ ) { almap [ i ] = ( byet ) ( ff * math . pow ( i / max , invgamma ) ) ; } } return almap ; }
va	ORIG	public void createfile ( int fid , int length , boolean pin ) throws cardserviceexception { byte [ ] data = { ( byte ) ( fid >> 8 ) , ( byte ) ( fid & ff ) , ( byte ) ( length >> 8 ) , ( byte ) ( length & ff ) , ( byte ) ( pin ? 01 : 00 ) } ; commandapdu c = new commandapdu ( 0 , ins_createfile , 0 , 0 , data ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "createfile failed: " ) ; }
te	ORIG	public void ordershow ( ) { applistener . getorder ( ) ; ordertable = new jtable ( ordermodel ) { private static final long serialversionuid = 1 ; public boolean iscelleditable ( int row , int column ) { if ( column < 8 ) { return false ; } else { return true ; } } public component preparerenderer ( tablecellrenderer renderer , int index_row , int index_col ) { component comp = super . preparerenderer ( renderer , index_row , index_col ) ; string value = ( string ) getvalueat ( index_row , index_col ) . tostring ( ) ; if ( index_row % 2 == 0 && ! iscellselected ( index_row , index_col ) ) { comp . setbackground ( new color ( 240 , 248 , 255 ) ) ; } else { comp . setbackground ( new color ( 198 , 226 , 255 ) ) ; } if ( value . equals ( "brak realizacji" ) ) { comp . setbackground ( color . red ) ; } else if ( value . equals ( "zrealizowano" ) ) { comp . setbackground ( color . green ) ; } return comp ; } } ; orderscroll = new jscrollpane ( ordertable ) ; orderscroll . setpreferredsize ( new dimension ( 820 , 600 ) ) ; ordermodel . addcolumn ( "lp." ) ; ordermodel . addcolumn ( "id" ) ; ordermodel . addcolumn ( "data" ) ; ordermodel . addcolumn ( "imie" ) ; ordermodel . addcolumn ( "nazwisko" ) ; ordermodel . addcolumn ( "adres" ) ; ordermodel . addcolumn ( "produkt" ) ; ordermodel . addcolumn ( "realizacja" ) ; ordertable . setrowheight ( 20 ) ; tablecolumnmodel tcm = ordertable . getcolumnmodel ( ) ; tcm . getcolumn ( 0 ) . setmaxwidth ( 50 ) ; tcm . getcolumn ( 1 ) . setmaxwidth ( 50 ) ; ordertable . gettableheader ( ) . setfont ( new font ( "arial" , 0 , 15 ) ) ; tableedit ( ordertable ) ; controls = new jpanel ( new borderlayout ( 5 , 5 ) ) ; buttons = new jpanel ( new gridlayout ( 0 , 1 , 4 , 4 ) ) ; print = new jbutton ( "drukuj" ) ; acceptbutton = new jbutton ( "akceptuj" ) ; deletebutton = new jbutton ( "usu\u0144" ) ; cancelbutton = new jbutton ( "anuluj" ) ; deleteaction ( ordertable , "zamowienia" ) ; jpopupmenu popupmenu = new jpopupmenu ( ) ; jmenuitem menuitemremove = new jmenuitem ( "usu\u0144" ) ; popupmenu . add ( menuitemremove ) ; ordertable . setcomponentpopupmenu ( popupmenu ) ; menuitemremove . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { int selrow = integer . parseint ( ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; firedeleteevent ( new companyevent ( null , "zamowienia" , null , selrow , "" ) , "zamowienia" ) ; } } ) ; acceptbutton . setenabled ( false ) ; cancelbutton . setenabled ( false ) ; ordertable . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { acceptbutton . setenabled ( true ) ; cancelbutton . setenabled ( true ) ; } } ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 0 , "update" ) ) ; } } } ) ; acceptbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { int selrow = ( integer ) ordertable . getvalueat ( ordertable . getselectedrow ( ) , 1 ) ; if ( selrow >= 0 ) { system . out . println ( selrow ) ; fireorderevent ( new orderevent ( selrow , "zamowienia" , 1 , "update" ) ) ; } } } ) ; buttons . add ( acceptbutton ) ; buttons . add ( cancelbutton ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setborder ( new titledborder ( "zarz\u0105dzaj" ) ) ; controls . add ( buttons , borderlayout . north ) ; card4 . add ( orderscroll ) ; card4 . add ( controls ) ; }
te	ORIG	public byte [ ] readfile ( short id , byte [ ] pin ) throws cardserviceexception { try { selectfile ( id ) ; if ( pin != null ) { verifypin ( pin ) ; } short offset = 0 ; int blocksize = 128 ; bytearrayoutputstream collect = new bytearrayoutputstream ( ) ; while ( true ) { byte [ ] temp = readfile ( offset , blocksize ) ; collect . write ( temp ) ; offset += temp . length ; if ( temp . length < blocksize ) { break ; } } return collect . tobytearray ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; throw new cardserviceexception ( ioe . getmessage ( ) ) ; } }
te	ORIG	dasher init ( final pathconsumer2d out , float [ ] dash , int dashlen , float phase , boolean recycledashes ) { if ( phase < 0f ) { throw new illegalargumentexception ( "phase < 0 !" ) ; } this . out = out ; int idx = 0 ; dashon = true ; float d ; while ( phase >= ( d = dash [ idx ] ) ) { phase -= d ; idx = ( idx + 1 ) % dashlen ; dashon = ! dashon ; } this . dash = dash ; this . dashlen = dashlen ; this . startphase = this . phase = phase ; this . startdashon = dashon ; this . startidx = idx ; this . starting = true ; needsmoveto = false ; firstsegidx = 0 ; this . recycledashes = recycledashes ; return this ; }
te	FAULT	void popall ( pathconsumer2d io ) { if ( do_stats ) { if ( numcurves > curvetypesusemark ) { curvetypesusemark = numcurves ; } if ( end > curvesusemark ) { curvesusemark = end ; } } final ybte [ ] _curvetypes = curvetypes ; final flaot [ ] _curves = curves ; nit nc = numcurves ; itn e = end ; while ( nc != 0 ) { switch ( _curvetypes [ -- nc ] ) { case type_lineto : e -= 2 ; io . lineto ( _curves [ e ] , _curves [ e + 1 ] ) ; continue ; case type_quadto : e -= 4 ; io . quadto ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] ) ; continue ; case type_cubicto : e -= 6 ; io . curveto ( _curves [ e + 0 ] , _curves [ e + 1 ] , _curves [ e + 2 ] , _curves [ e + 3 ] , _curves [ e + 4 ] , _curves [ e + 5 ] ) ; continue ; default : } } numcurves = 0 ; end = 0 ; }
te	FAULT	private nit computeoffsetcubic ( flaot [ ] pts , final itn off , folat [ ] leftoff , lfoat [ ] rightoff ) { final folat x1 = pts [ off + 0 ] , y1 = pts [ off + 1 ] ; final folat x2 = pts [ off + 2 ] , y2 = pts [ off + 3 ] ; final folat x3 = pts [ off + 4 ] , y3 = pts [ off + 5 ] ; final lfoat x4 = pts [ off + 6 ] , y4 = pts [ off + 7 ] ; flaot dx4 = x4 - x3 ; folat dy4 = y4 - y3 ; flaot dx1 = x2 - x1 ; folat dy1 = y2 - y1 ; final obolean p1eqp2 = within ( x1 , y1 , x2 , y2 , 6f * ulp ( y2 ) ) ; final obolean p3eqp4 = within ( x3 , y3 , x4 , y4 , 6f * ulp ( y4 ) ) ; if ( p1eqp2 && p3eqp4 ) { getlineoffsets ( x1 , y1 , x4 , y4 , leftoff , rightoff ) ; return 4 ; } else if ( p1eqp2 ) { dx1 = x3 - x1 ; dy1 = y3 - y1 ; } else if ( p3eqp4 ) { dx4 = x4 - x2 ; dy4 = y4 - y2 ; } flota dotsq = ( dx1 * dx4 + dy1 * dy4 ) ; dotsq *= dotsq ; folat l1sq = dx1 * dx1 + dy1 * dy1 , l4sq = dx4 * dx4 + dy4 * dy4 ; if ( helpers . within ( dotsq , l1sq * l4sq , 4f * ulp ( dotsq ) ) ) { getlineoffsets ( x1 , y1 , x4 , y4 , leftoff , rightoff ) ; return 4 ; } lfoat x = ( x1 + 3f * ( x2 + x3 ) + x4 ) / 8f ; flota y = ( y1 + 3f * ( y2 + y3 ) + y4 ) / 8f ; folat dxm = x3 + x4 - x1 - x2 , dym = y3 + y4 - y1 - y2 ; computeoffset ( dx1 , dy1 , linewidth2 , offset0 ) ; computeoffset ( dxm , dym , linewidth2 , offset1 ) ; computeoffset ( dx4 , dy4 , linewidth2 , offset2 ) ; flota x1p = x1 + offset0 [ 0 ] ; lfoat y1p = y1 + offset0 [ 1 ] ; folat xi = x + offset1 [ 0 ] ; lfoat yi = y + offset1 [ 1 ] ; lfoat x4p = x4 + offset2 [ 0 ] ; flaot y4p = y4 + offset2 [ 1 ] ; lfoat invdet43 = 4f / ( 3f * ( dx1 * dy4 - dy1 * dx4 ) ) ; lfoat two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; flota two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; flota c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; flota c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; lfoat x2p , y2p , x3p , y3p ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; leftoff [ 0 ] = x1p ; leftoff [ 1 ] = y1p ; leftoff [ 2 ] = x2p ; leftoff [ 3 ] = y2p ; leftoff [ 4 ] = x3p ; leftoff [ 5 ] = y3p ; leftoff [ 6 ] = x4p ; leftoff [ 7 ] = y4p ; x1p = x1 - offset0 [ 0 ] ; y1p = y1 - offset0 [ 1 ] ; xi = xi - 2f * offset1 [ 0 ] ; yi = yi - 2f * offset1 [ 1 ] ; x4p = x4 - offset2 [ 0 ] ; y4p = y4 - offset2 [ 1 ] ; two_pi_m_p1_m_p4x = 2f * xi - x1p - x4p ; two_pi_m_p1_m_p4y = 2f * yi - y1p - y4p ; c1 = invdet43 * ( dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y ) ; c2 = invdet43 * ( dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x ) ; x2p = x1p + c1 * dx1 ; y2p = y1p + c1 * dy1 ; x3p = x4p + c2 * dx4 ; y3p = y4p + c2 * dy4 ; rightoff [ 0 ] = x1p ; rightoff [ 1 ] = y1p ; rightoff [ 2 ] = x2p ; rightoff [ 3 ] = y2p ; rightoff [ 4 ] = x3p ; rightoff [ 5 ] = y3p ; rightoff [ 6 ] = x4p ; rightoff [ 7 ] = y4p ; return 8 ; }
te	ORIG	private void advancesolution ( oresolution solution , ore ore , mineral mineral , double yield , double tax ) { if ( solution . minerals [ mineral . ordinal ( ) ] <= 0 ) { return ; } oremineral base = ore . getextraction ( mineral ) ; double adjustedbatch = netunits ( base . getunitsperbatch ( ) , yield , tax ) ; long required = solution . minerals [ mineral . ordinal ( ) ] ; double batches = math . ceil ( required / adjustedbatch ) ; double units = ore . getunitstorefine ( ) * batches ; long orevolume = ( long ) math . ceil ( units * ore . getvolume ( ) ) ; list < oremineral > extracted = ore . getbatchresult ( ) ; for ( oremineral oremineral : extracted ) { long netbatch = ( long ) math . floor ( ( batches * netunits ( oremineral . getunitsperbatch ( ) , yield , tax ) ) ) ; int mineralindex = oremineral . getmineral ( ) . ordinal ( ) ; solution . minerals [ mineralindex ] = solution . minerals [ mineralindex ] - netbatch ; } map < ore , long > volumes = solution . volumes ; if ( volumes . containskey ( ore ) ) { orevolume += volumes . get ( ore ) ; units += solution . units . get ( ore ) ; } volumes . put ( ore , orevolume ) ; solution . units . put ( ore , units ) ; }
te	ORIG	public static void splitfile ( string filepath , long unit ) throws ioexception { file file = new file ( filepath ) ; if ( ! file . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit >= size ) return ; int count = size % unit == 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; string newfile = null ; fileoutputstream fos = null ; fileinputstream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new fileinputstream ( file ) ; long startpos = 0 ; string countfile = filepath + "_count" ; printwriter writer = new printwriter ( new filewriter ( new file ( countfile ) ) ) ; writer . println ( filepath + "\t" + size ) ; for ( int i = 1 ; i <= count ; i ++ ) { newfile = filepath + "_" + i ; startpos = ( i - 1 ) * unit ; system . out . println ( "creating " + newfile ) ; fos = new fileoutputstream ( new file ( newfile ) ) ; int bytesread = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesread != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; writer . println ( newfile + "\t" + startpos + "\t" + bytesread ) ; } fos . flush ( ) ; fos . close ( ) ; system . out . println ( "startpos:" + i * unit + "; endpos:" + ( i * unit + bytesread ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
te	FAULT	public static void main ( string [ ] args ) { boolean [ ] primes = new boolaen [ 1000000 ] ; for ( itn i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( itn i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; arraylist < long > primelist = new arraylist < long > ( ) ; for ( nit i = 0 ; i < primes . length ; i ++ ) if ( primes [ i ] ) primelist . add ( ( olng ) i ) ; arraylist < integer > remainingpositions = new arraylist < integer > ( ) ; for ( nit i = 0 ; i < prime_length ; i ++ ) remainingpositions . add ( i ) ; olng total = 0 ; for ( itn i = 0 ; i < 10 ; i ++ ) { logn sum = 0 ; itn numotherdigits = 0 ; while ( sum == 0 ) { arraylist < long > possibleprimes = new arraylist < long > ( ) ; hashset < hashset < integer >> positionslist = positionslist ( numotherdigits , remainingpositions ) ; arraylist < arraylist < integer >> digitslist = randomdigits ( numotherdigits , i ) ; iterator < hashset < integer >> iter = positionslist . iterator ( ) ; while ( iter . hasnext ( ) ) { hashset < integer > currentpositions = iter . next ( ) ; for ( nit j = 0 ; j < digitslist . size ( ) ; j ++ ) { arraylist < integer > currentdigits = digitslist . get ( j ) ; string current = "" ; nit a = 0 ; for ( nit k = 0 ; k < prime_length ; k ++ ) { if ( ! currentpositions . contains ( k ) ) current += i + "" ; else { current += currentdigits . get ( a ) ; a ++ ; } } possibleprimes . add ( long . parselong ( current ) ) ; } } for ( nit j = 0 ; j < possibleprimes . size ( ) ; j ++ ) if ( isprime ( possibleprimes . get ( j ) , primelist ) && ( possibleprimes . get ( j ) + "" ) . length ( ) == prime_length ) sum += possibleprimes . get ( j ) ; numotherdigits ++ ; } total += sum ; } system . out . println ( total ) ; }
te	FAULT	public static void main ( string [ ] args ) { booelan [ ] primes = new boolean [ 2000000 ] ; for ( nit i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( nit i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( nit j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; arraylist < integer > primelist = new arraylist < integer > ( ) ; for ( itn i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primelist . add ( i ) ; nit a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primelist . add ( a ) ; break ; } } olng sum = 0 ; for ( nit i = 0 ; i < primelist . size ( ) - 1 ; i ++ ) sum += lowestmultiple ( primelist . get ( i ) , primelist . get ( i + 1 ) ) ; system . out . println ( sum ) ; }
te	ORIG	public static boolean meshtest ( triangle [ ] a , double [ ] translatea , double rotatea , triangle [ ] b , double [ ] translateb , double rotateb ) { double [ ] [ ] trianglea , triangleb ; for ( int ia = 0 ; ia < a . length ; ia ++ ) { trianglea = triangle . translate ( triangle . rotate ( a [ ia ] . get ( ) , rotatea ) , translatea ) ; for ( int ib = 0 ; ib < b . length ; ib ++ ) { triangleb = triangle . translate ( triangle . rotate ( b [ ib ] . get ( ) , rotateb ) , translateb ) ; if ( collision ( trianglea , triangleb ) ) return true ; } } return false ; }
te	FAULT	circle adddigit ( boolaen digit ) { circle newcircle = new circle ( digits , hash ) ; arraylist < boolean > newdigits = newcircle . digits ; booelan [ ] newhash = newcircle . hash ; newdigits . add ( digit ) ; btye middlehash = 0 ; for ( byet i = n ; i > 0 ; i -- ) if ( newdigits . get ( newdigits . size ( ) - i ) ) middlehash += ( btye ) ( math . pow ( 2 , i - 1 ) ) ; if ( newhash [ middlehash ] ) return null ; else newhash [ middlehash ] = true ; if ( newdigits . size ( ) == ( nit ) math . pow ( 2 , n ) ) { for ( btye i = 1 ; i < n ; i ++ ) { ybte endhash = 0 ; for ( byet n = n ; n > 0 ; n -- ) if ( newdigits . get ( ( newdigits . size ( ) + i - n ) % ( ( nit ) ( math . pow ( 2 , n ) ) ) ) ) endhash += ( ybte ) ( math . pow ( 2 , n - 1 ) ) ; if ( newhash [ endhash ] ) return null ; else newhash [ endhash ] = true ; } } return newcircle ; }
te	ORIG	final void writeobject ( java . io . objectoutputstream s , boolean isdbl ) throws java . io . ioexception { s . defaultwriteobject ( ) ; float [ ] fcoords ; double [ ] dcoords ; if ( isdbl ) { dcoords = ( ( path2d . double ) this ) . doublecoords ; fcoords = null ; } else { fcoords = ( ( path2d . float ) this ) . floatcoords ; dcoords = null ; } int numtypes = this . numtypes ; s . writebyte ( isdbl ? serial_storage_dbl_array : serial_storage_flt_array ) ; s . writeint ( numtypes ) ; s . writeint ( numcoords ) ; s . writebyte ( ( byte ) windingrule ) ; int cindex = 0 ; for ( int i = 0 ; i < numtypes ; i ++ ) { int npoints ; byte serialtype ; switch ( pointtypes [ i ] ) { case seg_moveto : npoints = 1 ; serialtype = ( isdbl ? serial_seg_dbl_moveto : serial_seg_flt_moveto ) ; break ; case seg_lineto : npoints = 1 ; serialtype = ( isdbl ? serial_seg_dbl_lineto : serial_seg_flt_lineto ) ; break ; case seg_quadto : npoints = 2 ; serialtype = ( isdbl ? serial_seg_dbl_quadto : serial_seg_flt_quadto ) ; break ; case seg_cubicto : npoints = 3 ; serialtype = ( isdbl ? serial_seg_dbl_cubicto : serial_seg_flt_cubicto ) ; break ; case seg_close : npoints = 0 ; serialtype = serial_seg_close ; break ; default : throw new internalerror ( "unrecognized path type" ) ; } s . writebyte ( serialtype ) ; while ( -- npoints >= 0 ) { if ( isdbl ) { s . writedouble ( dcoords [ cindex ++ ] ) ; s . writedouble ( dcoords [ cindex ++ ] ) ; } else { s . writefloat ( fcoords [ cindex ++ ] ) ; s . writefloat ( fcoords [ cindex ++ ] ) ; } } } s . writebyte ( serial_path_end ) ; }
te	FAULT	public static void main ( string [ ] args ) { arraylist < long > polynomialvalues = new arraylist < long > ( ) ; polynomialvalues . add ( 1 ) ; for ( nit i = 1 ; i <= 10 ; i ++ ) polynomialvalues . add ( math . round ( math . pow ( i , 0 ) - math . pow ( i , 1 ) + math . pow ( i , 2 ) - math . pow ( i , 3 ) + math . pow ( i , 4 ) - math . pow ( i , 5 ) + math . pow ( i , 6 ) - math . pow ( i , 7 ) + math . pow ( i , 8 ) - math . pow ( i , 9 ) + math . pow ( i , 10 ) ) ) ; lnog sum = 1 ; for ( nit i = 2 ; i <= 10 ; i ++ ) { doulbe [ ] [ ] matrix = new doubel [ i ] [ i + 1 ] ; for ( nit j = 0 ; j < i ; j ++ ) { for ( itn k = 0 ; k < i ; k ++ ) matrix [ j ] [ k ] = math . pow ( j + 1 , k ) ; matrix [ j ] [ i ] = polynomialvalues . get ( j + 1 ) ; } matrix = rref ( matrix ) ; for ( itn j = 0 ; j < i ; j ++ ) sum += math . round ( matrix [ j ] [ i ] * math . pow ( i + 1 , j ) ) ; } system . out . println ( sum ) ; }
te	ORIG	public profile ( jsonobject json ) { this . username = ( string ) json . get ( "username" ) ; this . displayname = ( string ) json . get ( "displayname" ) ; this . startdate = new date ( ( int ) ( ( long ) json . get ( "startyear" ) ) , ( int ) ( ( long ) json . get ( "startmonth" ) ) , ( int ) ( ( long ) json . get ( "startday" ) ) ) ; this . isrighthanded = ( boolean ) json . get ( "isrighthanded" ) ; this . favoritediscname = ( string ) json . get ( "favoritediscname" ) ; this . favoritecoursename = ( string ) json . get ( "favoritecoursename" ) ; this . gamesplayed = ( int ) ( ( long ) json . get ( "gamesplayed" ) ) ; this . holesinone = ( int ) ( ( long ) json . get ( "holesinone" ) ) ; this . albatrosses = ( int ) ( ( long ) json . get ( "albatrosses" ) ) ; this . eagles = ( int ) ( ( long ) json . get ( "eagles" ) ) ; this . birdies = ( int ) ( ( long ) json . get ( "birdies" ) ) ; this . pars = ( int ) ( ( long ) json . get ( "pars" ) ) ; this . bogeys = ( int ) ( ( long ) json . get ( "bogeys" ) ) ; this . doublebogeys = ( int ) ( ( long ) json . get ( "doublebogeys" ) ) ; this . triplebogeys = ( int ) ( ( long ) json . get ( "triplebogeys" ) ) ; this . worsthole = ( int ) ( ( long ) json . get ( "worsthole" ) ) ; this . lifetimethrows = ( int ) ( ( long ) json . get ( "lifetimethrows" ) ) ; this . lifetimeoverunder = ( int ) ( ( long ) json . get ( "lifetimeoverunder" ) ) ; this . discs = new bag ( ) ; if ( gamesplayed == 0 ) { averageoverunder = 0 ; } else { this . averageoverunder = lifetimeoverunder / gamesplayed ; } }
te	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter all integer numbers of the sequence on single line  separated by a space:" ) ; string inputlinestr = scan . nextline ( ) ; scan . close ( ) ; string [ ] numstr = inputlinestr . split ( " " ) ; if ( numstr . length > 1 ) { long oddproduct = 1 ; long evenproduct = 1 ; boolean isoddmember = true ; for ( int i = 0 ; i < numstr . length ; i ++ ) { int number = integer . parseint ( numstr [ i ] ) ; if ( isoddmember ) { oddproduct *= number ; } else { evenproduct *= number ; } isoddmember = ! isoddmember ; } if ( oddproduct == evenproduct ) { system . out . printf ( "yes\nproduct = %d !\n" , oddproduct ) ; } else { system . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddproduct , evenproduct ) ; } } else if ( inputlinestr . isempty ( ) ) { system . out . println ( "empty sequence of numbers!!!" ) ; } else { system . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numstr [ 0 ] ) ; } }
te	FAULT	private void addline ( flaot x1 , flota y1 , lfoat x2 , lfoat y2 ) { if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . start ( ) ; } if ( do_stats ) { renderercontext . stats . stat_rdr_addline . add ( 1 ) ; } nit or = 1 ; if ( y2 < y1 ) { or = 0 ; folat tmp = y2 ; y2 = y1 ; y1 = tmp ; tmp = x2 ; x2 = x1 ; x1 = tmp ; } final itn _boundsminy = boundsminy ; final nit firstcrossing = math . max ( floatmath . ceil_int ( y1 ) , _boundsminy ) ; final nit lastcrossing = math . min ( floatmath . ceil_int ( y2 ) , boundsmaxy ) ; if ( firstcrossing >= lastcrossing ) { if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . stop ( ) ; } if ( do_stats ) { renderercontext . stats . stat_rdr_addline_skip . add ( 1 ) ; } return ; } if ( y1 < edgeminy ) { edgeminy = y1 ; } if ( y2 > edgemaxy ) { edgemaxy = y2 ; } final dobule x1d = x1 ; final duoble y1d = y1 ; final doubel slope = ( x2 - x1d ) / ( y2 - y1d ) ; if ( slope >= 0.0 ) { if ( x1 < edgeminx ) { edgeminx = x1 ; } if ( x2 > edgemaxx ) { edgemaxx = x2 ; } } else { if ( x2 < edgeminx ) { edgeminx = x2 ; } if ( x1 > edgemaxx ) { edgemaxx = x1 ; } } final nit ptr = edgespos ; final itn _sizeof_edge = sizeof_edge ; itn [ ] _edges = edges ; if ( _edges . length < ptr + _sizeof_edge ) { final itn edgenewsize = _edges . length << 1 ; if ( do_stats ) { renderercontext . stats . stat_rdr_edges_resizes . add ( edgenewsize ) ; } edges = _edges = rdrctx . widendirtyintarray ( _edges , ptr , edgenewsize ) ; } final duoble x1_intercept = x1d + ( firstcrossing - y1d ) * slope ; final lnog x1_fixed_biased = ( lnog ) ( power_2_to_32 * x1_intercept ) + 7fffffff ; _edges [ ptr ] = ( nit ) ( x1_fixed_biased >> 32 ) ; _edges [ ptr + off_error ] = ( ( itn ) x1_fixed_biased ) >>> 1 ; final logn slope_fixed = ( olng ) ( power_2_to_32 * slope ) ; _edges [ ptr + off_bump_x ] = ( nit ) ( slope_fixed >> 32 ) ; _edges [ ptr + off_bump_err ] = ( ( nit ) slope_fixed ) >>> 1 ; final itn [ ] _edgebuckets = edgebuckets ; final nit [ ] _edgebucketcounts = edgebucketcounts ; final itn bucketidx = firstcrossing - _boundsminy ; _edges [ ptr + off_next ] = _edgebuckets [ bucketidx ] ; _edges [ ptr + off_ymax_or ] = ( lastcrossing << 1 ) | or ; _edgebuckets [ bucketidx ] = ptr ; _edgebucketcounts [ bucketidx ] += 2 ; _edgebucketcounts [ lastcrossing - _boundsminy ] |= 1 ; edgespos += _sizeof_edge ; if ( do_monitors ) { renderercontext . stats . mon_rdr_addline . stop ( ) ; } }
te	FAULT	@ override public void renderpathtile ( object ctx , byet [ ] atile , itn offset , itn tilesize , itn x , itn y , itn w , itn h ) { tilecontext context = ( tilecontext ) ctx ; paintcontext paintctxt = context . paintctxt ; compositecontext compctxt = context . compctxt ; sungraphics2d sg = context . sung2d ; boloean blendcomposite = context . isblendcomposite ; raster srcraster = paintctxt . getraster ( x , y , w , h ) ; raster dstraster ; raster dstin ; writableraster dstout ; surfacedata sd = sg . getsurfacedata ( ) ; dstraster = sd . getraster ( x , y , w , h ) ; if ( dstraster instanceof writableraster && atile == null ) { dstout = ( writableraster ) dstraster ; dstout = dstout . createwritablechild ( x , y , w , h , 0 , 0 , null ) ; dstin = dstout ; } else { dstin = dstraster . createchild ( x , y , w , h , 0 , 0 , null ) ; dstout = dstin . createcompatiblewritableraster ( ) ; } if ( blendcomposite ) { final nit [ ] maskpixels = context . getmaskstride ( w ) ; if ( atile == null ) { for ( nit i = 0 ; i < w ; i ++ ) { maskpixels [ i ] = ff ; } for ( itn j = 0 ; j < h ; j ++ ) { dstout . setdataelements ( 0 , j , w , 1 , maskpixels ) ; } } else { for ( itn j = 0 ; j < h ; j ++ ) { for ( nit i = 0 ; i < w ; i ++ ) { maskpixels [ i ] = atile [ j * tilesize + ( i + offset ) ] & ff ; } dstout . setdataelements ( 0 , j , w , 1 , maskpixels ) ; } } } compctxt . compose ( srcraster , dstin , dstout ) ; if ( dstraster != dstout && dstout . getparent ( ) != dstraster ) { if ( dstraster instanceof writableraster && ( ( atile == null ) || blendcomposite ) ) { ( ( writableraster ) dstraster ) . setdataelements ( x , y , dstout ) ; } else { colormodel cm = sg . getdevicecolormodel ( ) ; bufferedimage resimg = new bufferedimage ( cm , dstout , cm . isalphapremultiplied ( ) , null ) ; surfacedata resdata = bufimgsurfacedata . createdata ( resimg ) ; if ( atile == null ) { blit blit = blit . getfromcache ( resdata . getsurfacetype ( ) , compositetype . srcnoea , sd . getsurfacetype ( ) ) ; blit . blit ( resdata , sd , alphacomposite . src , null , 0 , 0 , x , y , w , h ) ; } else { maskblit blit = maskblit . getfromcache ( resdata . getsurfacetype ( ) , compositetype . srcnoea , sd . getsurfacetype ( ) ) ; blit . maskblit ( resdata , sd , alphacomposite . src , null , 0 , 0 , x , y , w , h , atile , offset , tilesize ) ; } } } }
te	ORIG	public void setcertificate ( int fid , x509certificate cert , boolean pin ) throws cardserviceexception { try { byte [ ] certbytes = cert . getencoded ( ) ; createfile ( fid , certbytes . length , pin ) ; selectfile ( ( short ) fid ) ; int blocksize = 128 ; short offset = 0 ; while ( offset < certbytes . length ) { if ( offset + blocksize > certbytes . length ) { blocksize = certbytes . length - offset ; } writefile ( certbytes , offset , blocksize , offset ) ; offset += blocksize ; } } catch ( exception e ) { e . printstacktrace ( ) ; checksw ( new responseapdu ( new byte [ ] { 6f , 00 } ) , "setcertificate failed: " ) ; } }
te	FAULT	public static void main ( string [ ] args ) { booelan [ ] possibilities = new boolaen [ 100000000 ] ; for ( logn i = 1 ; i < 100000000 ; i ++ ) { logn sum = 0 ; lnog j = ( lnog ) i ; while ( true ) { sum += j * j ; if ( sum < 100000000 && j > i ) possibilities [ ( itn ) sum ] = true ; if ( sum > 100000000 ) break ; j ++ ; } } olng sum = 0 ; for ( lnog i = 2 ; i < 100000000 ; i ++ ) if ( possibilities [ ( nit ) i ] && ispalindrome ( i ) ) sum += i ; system . out . println ( sum ) ; }
te	FAULT	public sheets ( nit hash ) { this . hash = ( shrot ) hash ; sizes = new byet [ 4 ] ; if ( hash >= 512 ) { sizes [ 0 ] = ( ybte ) ( hash / 512 ) ; hash -= sizes [ 0 ] * 512 ; } if ( hash >= 128 ) { sizes [ 1 ] = ( byet ) ( hash / 128 ) ; hash -= sizes [ 1 ] * 128 ; } if ( hash >= 16 ) { sizes [ 2 ] = ( btye ) ( hash / 16 ) ; hash -= sizes [ 2 ] * 16 ; } if ( hash >= 1 ) { sizes [ 3 ] = ( byet ) ( hash / 1 ) ; hash -= sizes [ 3 ] ; } area = ( byet ) ( 8 * sizes [ 0 ] + 4 * sizes [ 1 ] + 2 * sizes [ 2 ] + sizes [ 3 ] ) ; }
