tr	E	public static int calcDef ( int row , int col , boolean isPieceWhite ) { int total = 0 ; int topleft , topright , bottomleft , bottomright ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft , isPieceWhite ) ; } else { total += 10 ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft , isPieceWhite ) ; } else { total += 10 ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright , isPieceWhite ) ; } else { total += 10 ; } return total ; }
tr	A	public static String padInt ( int aval , int alen , String apad ) { String buf = Integer . toString ( aval ) ; while ( buf . length ( ) < alen ) buf = apad + buf ; return ( buf ) ; }
tr	B	@ Override public void inputProcess ( ) { if ( Key . UP . isPressed ( ) ) { setScale ( getScale ( ) * 2 ) ; } if ( Key . DOWN . isPressed ( ) ) { setScale ( getScale ( ) / 2 ) ; } if ( Key . LEFT . isPressed ( ) ) { setAngle ( getAngle ( ) + 5f ) ; } if ( Key . RIGHT . isPressed ( ) ) { setAngle ( getAngle ( ) - 5f ) ; } }
tr	D	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING + calcDef ( r , c , false , ds ) ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT + calcDef ( r , c , false , ds ) ; } return 0 ; }
tr	C	@ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 + " kb" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; }
tr	E	public static void main ( String [ ] args ) throws SerialPortException { Configuration . setRobot ( new Capra6 ( ) ) ; final MotorController controller = new MotorController ( ) ; controller . setConnectionlistener ( new ConnectionListener ( ) { @ Override public void onConnect ( ) { System . out . println ( "Motors connected" ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { controller . setVelocity ( 0.4 , 0 ) ; Thread . sleep ( 30000 ) ; controller . setVelocity ( 0 , 0 ) ; } catch ( Exception e ) { } } } ) . start ( ) ; } @ Override public void onDisconnect ( ) { System . out . println ( "Lost connection" ) ; } } ) ; controller . setPositionListener ( new PositionListener ( ) { @ Override public void onNewPosition ( Position position , long timestamp ) { } } ) ; controller . setStatusListener ( new StatusListener ( ) { @ Override public void onNewStatus ( Status [ ] status ) { } } ) ; controller . setTemperatureListener ( new TemperatureListener ( ) { @ Override public void onNewTemperature ( int [ ] temperature ) { } } ) ; controller . init ( ) ; try { Thread . sleep ( 99999999 ) ; } catch ( InterruptedException e ) { } controller . disconnect ( ) ; }
tr	B	public Ball launch ( Point point , int size ) { p2 = point ; return new BallGravity ( p1 . x - size / 2 , p1 . y - size / 2 , ( int ) ( p1 . getX ( ) - p2 . getX ( ) ) / 3 , ( int ) ( p1 . getY ( ) - p2 . getY ( ) ) / 3 , size ) ; }
tr	D	public LoginScreen ( ) { super ( ) ; gridPane . add ( userName , 0 , 0 ) ; userName . setPromptText ( "Username" ) ; gridPane . setVgap ( 15 ) ; gridPane . add ( password , 0 , 1 ) ; password . setPromptText ( "password" ) ; userName . setPrefHeight ( 50 ) ; password . setPrefHeight ( 50 ) ; gridPane . add ( submitBtn , 0 , 2 ) ; submitBtn . setPrefSize ( 450 , 100 ) ; gridPane . setAlignment ( Pos . CENTER ) ; this . setCenter ( gridPane ) ; this . setStyle ( "-fx-background-color: #090a0c linear-gradient(#6B7E8F 0%  #495561 20%  #4A5766 100%) linear-gradient(#53626F  #3E4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitBtn . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) != null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	D	public static String [ ] [ ] loadCategories ( ) throws SQLException { ResultSet rsCat ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from categories order by displayOrder" ; rsCat = conn . createStatement ( ) . executeQuery ( sql ) ; rsCat . last ( ) ; String categoriesLoad [ ] [ ] = new String [ rsCat . getRow ( ) ] [ 3 ] ; rsCat . beforeFirst ( ) ; while ( rsCat . next ( ) ) { categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 0 ] = rsCat . getString ( "catagoryId" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 1 ] = rsCat . getString ( "category_name" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 2 ] = rsCat . getString ( "displayOrder" ) ; } return categoriesLoad ; } }
tr	E	@ Override public void handle ( final ActionEvent e ) { BookController bookCtrl = new BookController ( ) ; if ( dest != null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; if ( dest == null ) { result = bookCtrl . createBookWithParameters ( textFieldName . getText ( ) , textFieldAuthor . getText ( ) , textFieldYear . getText ( ) , cb . getValue ( ) , null , description . getText ( ) ) ; } else { result = bookCtrl . createBookWithParameters ( textFieldName . getText ( ) , textFieldAuthor . getText ( ) , textFieldYear . getText ( ) , cb . getValue ( ) , dest . getPath ( ) , description . getText ( ) ) ; } if ( result . equals ( "Creation succeed" ) ) { if ( file != null ) { gridPane . getChildren ( ) . remove ( 15 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	D	@ Override public synchronized boolean putIfAbsent ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for putIfAbsent() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . putIfAbsent ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	D	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	A	public void mousePressed ( final MouseEvent e ) { pressPoints . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
tr	E	@ Test public void testeProdutoInserido ( ) { Produto p1 = new Produto ( ) ; Produto p2 = new Produto ( ) ; Produto p3 = new Produto ( ) ; Produto p4 = new Produto ( ) ; Produto p5 = new Produto ( ) ; Produto p6 = new Produto ( ) ; p1 . setId ( 1337 ) ; p2 . setId ( 1338 ) ; p3 . setId ( 1339 ) ; p4 . setId ( 1340 ) ; p5 . setId ( 1341 ) ; p6 . setId ( 1342 ) ; ArrayList < Produto > novo = new ArrayList < Produto > ( ) ; ArrayList < Produto > antigo = new ArrayList < Produto > ( ) ; antigo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 ) ) ; novo . addAll ( Arrays . asList ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; ArrayList < Produto > aAdicionar = new ArrayList < Produto > ( ) ; aAdicionar . add ( p5 ) ; aAdicionar . add ( p6 ) ; ArrayList < Produto > retornado = ListaUtils . listaAdicionarProduto ( novo , antigo ) ; assertEquals ( aAdicionar , retornado ) ; }
tr	C	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	B	@ Override protected void dead ( ) { super . dead ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { getParentScene ( ) . shoot ( new BasicEffect ( getParentScene ( ) , this ) ) ; } ( ( EDFScene ) getParentScene ( ) ) . addMoney ( 10 ) ; }
tr	E	private void onPaint ( final PaintEvent e ) { final GC gc = e . gc ; gc . setForeground ( getForeground ( ) ) ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product != null ) { messageRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; } Rectangle messageRect = parseRect ( messageRectString ) ; final int borderRight = messageRect . x ; final int borderBottom = messageRect . y ; final String copyRight = Messages . App_Splash_Copyright ; final int textHeight = gc . textExtent ( copyRight ) . y ; final String version = "Version " + ApplicationVersion . getVersionSimple ( ) ; final Point versionExtent = gc . textExtent ( version ) ; final String qualifier = ApplicationVersion . getVersionQualifier ( ) ; final Point qualifierExtent = gc . textExtent ( qualifier ) ; gc . setFont ( new Font ( gc . getDevice ( ) , "Arial" , 10 , SWT . BOLD ) ) ; gc . drawText ( version , borderRight + versionExtent . x , borderBottom + versionExtent . y + qualifierExtent . y , true ) ; gc . drawText ( qualifier , borderRight + qualifierExtent . x , borderBottom + versionExtent . y , true ) ; gc . drawText ( copyRight , messageRect . x , messageRect . y + textHeight , true ) ; }
tr	D	@ Test public void testEvict ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . evict ( "1" ) ; assertNull ( topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; topK . evict ( "2" ) ; assertNull ( topK . suggest ( ) ) ; topK . evict ( "2" ) ; assertNull ( topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; }
tr	E	public int maximumGap_bucket ( int [ ] num ) { if ( num . length < 2 ) return 0 ; int max = findMinMax ( num , 1 ) ; int min = findMinMax ( num , - 1 ) ; int buckets = num . length - 1 ; double step = ( max - min + 0.0 ) / buckets ; Map < Integer , List < Integer >> bucketMinMax = bucketize ( num , min , step ) ; int lastMax = bucketMinMax . get ( 0 ) . size ( ) > 1 ? bucketMinMax . get ( 0 ) . get ( 1 ) : bucketMinMax . get ( 0 ) . get ( 0 ) ; int maxGap = lastMax - min ; for ( int i = 1 ; i < buckets ; i ++ ) { List < Integer > list = bucketMinMax . get ( i ) ; if ( list != null && list . size ( ) > 0 ) { maxGap = Math . max ( maxGap , list . get ( 0 ) - lastMax ) ; lastMax = list . size ( ) > 1 ? list . get ( 1 ) : list . get ( 0 ) ; } } return maxGap ; }
tr	A	@ Override public void disposeAfter ( float seconds ) { disposeTimer = ( int ) ( FPS * seconds ) ; }
tr	E	public boolean loadBuffer ( Connection connection , String ligne , ReportField reportField ) { boolean returnValue = true ; try { switch ( this . getDiscriminator ( ) ) { case CONSTANTE : buffer = getConstante ( ) . getValue ( ) ; break ; case POSITION : try { buffer = getPosition ( ) . getValue ( ligne ) ; returnValue = isBufferValid ( reportField ) ; } catch ( IndexOutOfBoundsException ioobe ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; LOGGER . log ( Level . SEVERE , reportField . ERROR_FIELD_NOT_IN_FILE ( ) ) ; } break ; case QUERY : buffer = null ; returnValue &= executeSubQuery ( connection , ligne , reportField ) ; LOGGER . finest ( "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; break ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " , ex ) ; returnValue = false ; } if ( buffer != null ) { buffer = buffer . trim ( ) ; } return returnValue ; }
tr	A	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	A	public String makeKey ( ) { String retstr = testgroupid + "|" + testid ; return ( retstr ) ; }
tr	A	public static boolean anyKeyPressed ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_PRESSED ) { return true ; } } return false ; }
tr	C	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	A	public File getFile ( ) { if ( fFileDir == null || fFileName == null ) return null ; else return new File ( fFileDir + File . separator + fFileName ) ; }
tr	D	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
tr	E	public StatResultSet parseStat ( String exportedName ) throws IOException { log . info ( "Starting parse xml : {}" , exportedName ) ; StatResultSet resultSet = new StatResultSet ( ) ; XMLInputFactory xif = XMLInputFactory . newInstance ( ) ; XMLStreamReader xsr = null ; try { xsr = xif . createXMLStreamReader ( new FileReader ( exportedName ) ) ; xsr . nextTag ( ) ; JAXBContext jaxbContext = JAXBContext . newInstance ( StatRow . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; List < StatRow > rowList = new ArrayList < > ( ) ; while ( xsr . nextTag ( ) == XMLStreamConstants . START_ELEMENT ) { StatRow aRow = ( StatRow ) jaxbUnmarshaller . unmarshal ( xsr ) ; rowList . add ( aRow ) ; } log . info ( "Parsing is done got {} rows" , rowList . size ( ) ) ; resultSet . setRows ( rowList ) ; } catch ( XMLStreamException e ) { log . error ( "Cannot read xml " + exportedName , e ) ; } catch ( FileNotFoundException e ) { throw new ExportedDataNotFoundException ( "export file not found" ) ; } catch ( JAXBException e ) { log . error ( "Cannot parse xml " + exportedName , e ) ; } finally { try { if ( xsr != null ) { xsr . close ( ) ; } } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } return resultSet ; }
tr	B	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	C	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	B	public final Texture loadTexture ( final String imagePath ) { AlphaBlend . AlphaBlend . config ( ) ; try { return loadTexture ( ImageIO . read ( new FileInputStream ( imagePath ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	A	public void setDbUrl ( String aurl ) { if ( ! dbUrl . equals ( aurl ) ) { shutDown ( ) ; dbUrl = aurl ; } }
tr	E	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	C	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	B	public void copyList ( CStringList alist ) { this . clear ( ) ; for ( int idx = 0 ; idx < alist . getCount ( ) ; idx ++ ) { this . addItem ( alist . getString ( idx ) , alist . getItem ( idx ) ) ; } }
tr	E	private int miniMax ( NodeLVL5 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	B	@ Override public boolean isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { case FRIEND_TEAM : return target . getTeam ( ) == TEAM . ENEMY_TEAM ; case ENEMY_TEAM : return target . getTeam ( ) == TEAM . FRIEND_TEAM ; default : return false ; } }
tr	A	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	D	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	A	public String getYmdStr ( ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( shotdate ) ) ; }
tr	C	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	B	public Ball ( int x , int y , int vx , int vy , int size ) { this . x = x ; this . y = y ; this . vx = vx ; this . vy = vy ; this . size = size ; this . pong = Applet . newAudioClip ( getClass ( ) . getResource ( "../mediaResources/pong.wav" ) ) ; this . color = Color . blue ; }
tr	D	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO recordsitestat (uniquevisitor  uniquevisitordate  " + "pageview  pageviewdate  visit  visitdate  site_id) VALUES (?  ?  ?  ?  ?  ?  ?)" ; PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , recordSiteStatModel . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , recordSiteStatModel . getPageView ( ) ) ; ps . setLong ( 4 , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , recordSiteStatModel . getVisit ( ) ) ; ps . setLong ( 6 , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , recordSiteStatModel . getSite ( ) . getId ( ) ) ; log . trace ( "Prepared statement created as" + ps . toString ( ) ) ; log . debug ( "ps: {}" , ps . toString ( ) ) ; return ps ; }
tr	B	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectResultItem>\n" ) ; retstr . append ( "<ExpectTxt>" + expecttxt + "</ExpectTxt>\n" ) ; retstr . append ( "<ResultTxt>" + expecttxt + "</ResultTxt>\n" ) ; retstr . append ( "</ExpectResultItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	D	public void setZeroes ( int [ ] [ ] matrix ) { Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] == 0 ) { rows . add ( i ) ; cols . add ( j ) ; } } } for ( int r : rows ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { matrix [ r ] [ j ] = 0 ; } } for ( int c : cols ) { for ( int j = 0 ; j < matrix . length ; j ++ ) { matrix [ j ] [ c ] = 0 ; } } }
tr	E	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) { protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; } protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; } protected boolean setSourceLibrary ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/nextlife.txt" ; return setSourceWeb ( u ) ; } protected boolean setSourceThreeStar ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/competition.txt" ; return setSourceWeb ( u ) ; } private boolean setSourceWeb ( String url ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; } } ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
tr	C	public static void addURL ( URL u ) throws IOException { URLClassLoader sysLoader = ( URLClassLoader ) ClassLoader . getSystemClassLoader ( ) ; for ( URL url : sysLoader . getURLs ( ) ) { if ( url . toString ( ) . equalsIgnoreCase ( u . toString ( ) ) ) { logger . log ( Level . INFO , "URL {0} is already in the CLASSPATH" , u ) ; return ; } } class sysclass = URLClassLoader . class ; try { Method method = sysclass . getDeclaredMethod ( "addURL" , parameters ) ; method . setAccessible ( true ) ; method . invoke ( sysLoader , new Object [ ] { u } ) ; } catch ( NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException t ) { t . printStackTrace ( ) ; throw new IOException ( "Error  could not add URL to system classloader" ) ; } }
tr	E	public Point getTileCollision ( Sprite sprite , float newX , float newY ) { float fromX = Math . min ( sprite . getX ( ) , newX ) ; float fromY = Math . min ( sprite . getY ( ) , newY ) ; float toX = Math . max ( sprite . getX ( ) , newX ) ; float toY = Math . max ( sprite . getY ( ) , newY ) ; int fromTileX = TileMapRenderer . pixelsToTiles ( fromX ) ; int fromTileY = TileMapRenderer . pixelsToTiles ( fromY ) ; int toTileX = TileMapRenderer . pixelsToTiles ( toX + sprite . getWidth ( ) - 1 ) ; int toTileY = TileMapRenderer . pixelsToTiles ( toY + sprite . getHeight ( ) - 1 ) ; for ( int x = fromTileX ; x <= toTileX ; x ++ ) { for ( int y = fromTileY ; y <= toTileY ; y ++ ) { if ( x < 0 || x >= map . getWidth ( ) || map . getTile ( x , y ) != null ) { pointCache . setLocation ( x , y ) ; return pointCache ; } } } return null ; }
tr	D	private void list ( Connection conn ) { System . out . println ( "############# list ##########" ) ; QueryUtil qu = qm . createQueryUtil ( "selectAll" ) ; try { qu . setConnection ( conn ) ; qu . executeQuery ( ) ; System . out . println ( "--bean list " ) ; List < User > userList = qu . list ( User . class ) ; System . out . println ( "user list size=" + userList . size ( ) ) ; System . out . println ( userList . get ( 0 ) . getUserName ( ) ) ; qu . executeQuery ( ) ; System . out . println ( "--object list " ) ; List < Object [ ] > objectArrayList = qu . listArray ( ) ; System . out . println ( "array list size=" + objectArrayList . size ( ) ) ; System . out . println ( objectArrayList . get ( 0 ) [ 1 ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { qu . closeJust ( ) ; } }
tr	A	public File getFile ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFile ( ) ; } catch ( Exception e ) { return null ; } }
tr	C	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	A	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
tr	E	@ Override public void handle ( ActionEvent event ) { customerCtrl = new CustomerController ( ) ; List < Customer > customerList = customerCtrl . findCustomerWithParameters ( txtFieldFirstname . getText ( ) , txtFieldLastname . getText ( ) , txtFieldZipCode . getText ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; flowPane . setVgap ( 5 ) ; flowPane . setHgap ( 5 ) ; if ( customerList != null ) { for ( Customer customer : customerList ) { Button btn1 = new Button ( "" ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:img/icons/customer.png" ) ) ) ; btn1 . setOnAction ( new customerInfoHandler ( customer ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( customer . getName ( ) . toString ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	D	public HBox searchBar ( ) { HBox hbox = new HBox ( ) ; hbox . setSpacing ( 5 ) ; hbox . getStyleClass ( ) . add ( "hbox-search-bar" ) ; hbox . getChildren ( ) . add ( new Label ( "FirstName" ) ) ; txtFieldFirstname . setPromptText ( "First Name" ) ; hbox . getChildren ( ) . add ( txtFieldFirstname ) ; hbox . getChildren ( ) . add ( new Label ( "LastName" ) ) ; txtFieldLastname . setPromptText ( "Last Name" ) ; hbox . getChildren ( ) . add ( txtFieldLastname ) ; hbox . getChildren ( ) . add ( new Label ( "ZipCode" ) ) ; txtFieldZipCode . setPromptText ( "Zip Code" ) ; hbox . getChildren ( ) . add ( txtFieldZipCode ) ; hbox . setStyle ( "-fx-padding: 10px;" ) ; Button searchButton = new Button ( "Search" ) ; hbox . getChildren ( ) . add ( searchButton ) ; searchButton . setOnAction ( new searchHandler ( ) ) ; return hbox ; }
tr	A	public static FPSManager getInstance ( ) { if ( instance == null ) { instance = new FPSManager ( ) ; } return instance ; }
tr	C	@ Test public void generatesProxyCorrectly ( ) { final int value = 10 ; final String expectedMethodName = ServiceInterface . class . getMethods ( ) [ 0 ] . getName ( ) ; final Object [ ] args = { value } ; context . checking ( new Expectations ( ) { { oneOf ( serviceCaller ) . call ( args , expectedMethodName , serviceAddress , void . TYPE ) ; will ( returnValue ( null ) ) ; } } ) ; ServiceInterface ft = proxyMaker . make ( serviceAddress , ServiceInterface . class ) . service ( ) ; ft . call ( value ) ; context . assertIsSatisfied ( ) ; }
tr	E	public void monsterAction ( Monster monster ) { if ( lineOfSight ( monster , player . getLocation ( ) ) ) { ArrayList < Point > directions = new ArrayList < Point > ( 2 ) ; Tile location = monster . getLocation ( ) ; Tile playerTile = player . getLocation ( ) ; if ( location . getRow ( ) > playerTile . getRow ( ) ) directions . add ( new Point ( 0 , - 1 ) ) ; if ( location . getRow ( ) < playerTile . getRow ( ) ) directions . add ( new Point ( 0 , 1 ) ) ; if ( location . getColumn ( ) < playerTile . getColumn ( ) ) directions . add ( new Point ( 1 , 0 ) ) ; if ( location . getColumn ( ) > playerTile . getColumn ( ) ) directions . add ( new Point ( - 1 , 0 ) ) ; int random = MapRand . randInt ( directions . size ( ) - 1 ) ; moveSentient ( monster , directions . get ( random ) . x , directions . get ( random ) . y ) ; } else { moveRandomly ( monster ) ; } }
tr	E	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) != null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
tr	B	public static String getFCname ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FNAME ] ) ; else return ( "" ) ; }
tr	B	@ Override public void update ( ) { super . update ( ) ; switch ( stageState ) { case READY : startCaption . show ( ) ; endCaption . hide ( ) ; break ; case PLAYING : startCaption . hide ( ) ; endCaption . hide ( ) ; break ; case CLEAR : startCaption . hide ( ) ; endCaption . show ( ) ; break ; } }
tr	E	private ArrayList < Object > getListFromUrl ( String strUrl , int tipo ) { try { URL url = new URL ( "http://dls98:8181" + strUrl ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( conn . getResponseCode ( ) != 200 ) { return new ArrayList < Object > ( ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; String total = "" ; while ( ( output = br . readLine ( ) ) != null ) { total += output ; } JsonArray lista = ( JsonArray ) ( new JsonParser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == CLIENTE ) return ClienteUtils . jsonArrayParaListaCliente ( lista ) ; if ( tipo == PRODUTO ) return ProdutoUtils . jsonArrayParaListaProduto ( lista ) ; if ( tipo == PEDIDO ) return PedidoUtils . jsonArrayParaListaPedido ( lista ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	B	public CRunTest ( CAppProps aprops , CDbConnMan alocman , CDbConnMan aremman , String agroup , String atest , String afc1 , String afc2 , int runoption ) { super ( ) ; locconnman = alocman ; remconnman = aremman ; props = aprops ; testgrpid = agroup ; testid = atest ; fc1 = afc1 ; fc2 = afc2 ; fcrunoption = runoption ; }
tr	D	public void projectPoint ( double [ ] xyz , double [ ] pxy , double [ ] [ ] [ ] lights ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; vertexColor ( xyz , lights ) ; pxy [ 2 ] = ( 255 * Math . pow ( RGB [ 0 ] , 0.45 ) ) ; pxy [ 3 ] = ( 255 * Math . pow ( RGB [ 1 ] , 0.45 ) ) ; pxy [ 4 ] = ( 255 * Math . pow ( RGB [ 2 ] , 0.45 ) ) ; pxy [ 5 ] = ( int ) ( FL * z / ( FL - z ) ) ; }
tr	B	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) != null ) { if ( line . startsWith ( aBoundary ) ) break ; sbuf . append ( line + "\r\n" ) ; } if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	E	private static void SLDouble ( Player P ) { ShippingLines SL = ( ShippingLines ) Game . fields . get ( P . Position ) ; int Owner = SL . Owner ; if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int cnt = SL . CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt == 1 ) { int Pay ; Pay = - 500 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt == 2 ) { int Pay ; Pay = - 1000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt == 3 ) { int Pay ; Pay = - 2000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt == 4 ) { int Pay ; Pay = - 4000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } } } }
tr	B	@ Override public void render ( ) { glLoadIdentity ( ) ; setTranslate ( this ) ; setGlColor4f ( getColor ( ) , 1f ) ; glRotatef ( ( float ) jitenAngle , 0 , 0 , 1 ) ; drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; }
tr	D	@ Test public void testSanity ( ) throws Exception { File storeDir = new File ( "target/foo" ) ; storeDir . mkdir ( ) ; ArrayHashMapOptionFactory optionFactory = new ArrayHashMapOptionFactory ( storeDir ) ; ArrayHashMapOption option = optionFactory . wrap ( new ArrayHashMap ( 3 ) , "000" ) ; assertTrue ( option . inMemory ( ) ) ; String reallyLongString = "@@@@@@@@@@@@@@@@@FFFFFFFFFFFFf\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long fooValue = new long ( 1333243243243243211 ) ; option . getValue ( ) . put ( reallyLongString , fooValue ) ; assertTrue ( option . inMemory ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; assertTrue ( option . inMemory ( ) ) ; option . persist ( ) ; assertFalse ( option . inMemory ( ) ) ; assertNull ( option . getValue ( ) ) ; option . restore ( ) ; assertTrue ( option . inMemory ( ) ) ; assertNotNull ( option . getValue ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; }
tr	B	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; myitem . nonadmdate . setTime ( myitem . nonadmdate . getTime ( ) + adiff ) ; } }
tr	A	public String getModDateStr ( ) { if ( moddate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
tr	D	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
tr	E	@ Test public void test ( ) { int n , k ; n = 3 ; k = 1 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; n = 3 ; k = 2 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; n = 3 ; k = 3 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; n = 3 ; k = 4 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; n = 3 ; k = 5 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; n = 3 ; k = 6 ; System . out . println ( "n = " + n + "  k = " + k + "; result = " + getPermutation ( n , k ) ) ; }
tr	C	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	A	public static float random ( final float min , final float max ) { float dist = max - min ; return ( float ) ( Math . random ( ) * dist + min ) ; }
tr	C	private void updatePieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) ) whites ++ ; else if ( Draughts . isBlack ( piece ) ) blacks ++ ; } String status = "" + whites + " - " + blacks ; numberOfPiecesLabel . setText ( status ) ; }
tr	C	public FlowerCharacter ( Texture texture ) { setTexture ( texture ) ; setWidth ( DEFAULT_WIDTH ) ; setHeight ( DEFAULT_HEIGHT ) ; setX ( RANDOM . nextInt ( WIDTH + getWidth ( ) * 2 ) - getWidth ( ) ) ; setY ( - getHeight ( ) ) ; setScale ( random ( 0.3f , 2.0f ) ) ; setAngle ( RANDOM . nextInt ( 360 ) ) ; setAlpha ( 0.7f ) ; setColor ( generateCosmosColor ( ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . UNLIMITED ) ; setVx ( random ( - 0.1f , 0.4f ) ) ; setVy ( getScale ( ) * 2 ) ; setVAngle ( 4f ) ; }
tr	B	public void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( speed , nabiki ) ; } }
tr	C	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	A	public String getDescByCode ( String acode ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
tr	D	@ Transactional ( propagation = Propagation . REQUIRES_NEW , readOnly = false ) public void batchInsert ( final List < SiteStatModel > siteStatModelList ) { String sql = "INSERT IGNORE INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return siteStatModelList . size ( ) ; } } ) ; }
tr	E	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
tr	E	public int getValue ( ) { int total = 0 ; int leftWhite = 0 ; int middleWhite = 0 ; int rightWhite = 0 ; int leftBlack = 0 ; int middleBlack = 0 ; int rightBlack = 0 ; int pieces = 0 ; int blackKings = 0 ; int whiteKings = 0 ; for ( int c = 0 ; c <= 9 ; c ++ ) { for ( int r = 0 ; r <= 9 ; r ++ ) { switch ( ds . getPiece ( r , c ) ) { case 0 : break ; case 1 : total += white ? 150 : 100 ; total += white ? 0 : 45 - r * 5 ; total += white ? PLAYGROUND [ r ] [ c ] : 0 ; break ; case 2 : total -= white ? 100 : 150 ; total -= white ? r * 10 : 0 ; total -= white ? 0 : PLAYGROUND [ 9 - r ] [ 9 - c ] ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : break ; } } } return total ; }
tr	A	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	E	public static boolean overlaps ( Rectangle r1 , Rectangle r2 ) { if ( r1 . contains ( r2 . getLocation ( ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x , r2 . y + r2 . height ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y + r2 . height ) ) ) { return true ; } if ( r2 . contains ( r1 . getLocation ( ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x , r1 . y + r1 . height ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y + r1 . height ) ) ) { return true ; } return false ; }
tr	D	private void prepareNext ( ) { String nextLine = null ; try { nextLine = in . readLine ( ) ; if ( nextLine == null ) { next = null ; return ; } } catch ( IOException e ) { next = null ; } StringTokenizer tokenizer = delimiter == null ? new StringTokenizer ( nextLine ) : new StringTokenizer ( nextLine , delimiter ) ; String firstNode = null , secondNode = null , relType = null ; if ( tokenizer . hasMoreTokens ( ) ) { firstNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { secondNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { relType = tokenizer . nextToken ( ) ; } next = new ParseResult < String > ( firstNode , secondNode , relType ) ; }
tr	E	private SearchTask getComputerMove ( final Player currentPlayer , final S gs , final Game game ) { SearchTask < M , long , S > searchTask ; final Timer timer = new Timer ( ) ; final int maxTime = timeSlider . getValue ( ) ; searchTask = new TimedSearchTask < M , long , S > ( currentPlayer , gs , maxTime ) { private long MIN_DELAY = 1500 ; @ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } } } ; timer . start ( ) ; searchTask . execute ( ) ; return searchTask ; }
tr	B	FilePart ( String name , ServletInputStream in , String boundary , String contentType , String fileName , String filePath ) throws IOException { super ( name ) ; this . fileName = fileName ; this . filePath = filePath ; this . contentType = contentType ; partInput = new PartInputStream ( in , boundary ) ; }
tr	B	public static String showStatusHead ( String forecasterA , String forecasterB ) { String retstr = "<tr>\n" ; retstr = retstr + "<th class='result'>Test Case</th>\n" ; retstr = retstr + "<th colspan='3' class='result'>" + forecasterA + "</th>\n" ; retstr = retstr + "<th colspan='3' class='result'>" + forecasterB + "</th>\n" ; retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	B	public ShootingStarCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ) ; setX ( WIDTH ) ; setY ( HEIGHT ) ; setVx ( - 3 ) ; setVy ( - 2 ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setMoveModeX ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setMoveModeY ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setColor ( Color . yellow ) ; }
tr	A	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	C	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	C	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	A	@ Override public < T extends GameObject > T add ( T go ) { bookingObjects . add ( go ) ; return go ; }
tr	A	@ Override public void hitEffectTo ( ShootingObject target ) { hittedObjects . add ( target ) ; target . damage ( getPower ( ) ) ; }
tr	C	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	B	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	B	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
tr	D	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
tr	D	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	C	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	D	private void list1MouseClicked ( java . awt . event . MouseEvent evt ) { selected = list1 . getSelectedIndex ( ) ; textField1 . setText ( itemsLoad [ selected ] [ 0 ] ) ; textField2 . setText ( itemsLoad [ selected ] [ 1 ] ) ; jComboBox1 . setSelectedIndex ( Integer . parseInt ( categories [ Integer . parseInt ( itemsLoad [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) - 1 ) ; System . out . println ( categories [ Integer . parseInt ( itemsLoad [ selected ] [ 2 ] ) - 1 ] [ 0 ] ) ; textField3 . setText ( itemsLoad [ selected ] [ 3 ] ) ; jComboBox2 . setSelectedIndex ( Integer . parseInt ( itemsLoad [ selected ] [ 4 ] ) ) ; textField4 . setText ( itemsLoad [ selected ] [ 5 ] ) ; }
tr	B	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && getDisposeTimer ( ) % ( FPS / 4 ) == 0 ) { shoot ( new Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
tr	B	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; for ( GameObject go : gameObjects ) { go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; gameObjects . remove ( go ) ; } } }
tr	A	@ Override public int getX ( int x , int width ) { return x - ( width / 2 ) ; }
tr	B	@ Override public void inputProcess ( ) { switch ( stageState ) { case READY : if ( Key . SPACE . isPressed ( ) ) { stageState = StageState . PLAYING ; } break ; case PLAYING : if ( currentStage . isClear ( ) ) { stageState = StageState . CLEAR ; } break ; case CLEAR : if ( Key . SPACE . isPressed ( ) ) { nextStage ( ) ; stageState = StageState . READY ; } break ; } }
tr	C	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	D	private void gameInfo ( ) { if ( p1 . getPoints ( ) == p2 . getPoints ( ) ) { System . out . println ( "DRAW" ) ; } else if ( p1 . getPoints ( ) > Game . GOAL && p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( "You both fired up" ) ; System . out . println ( " But " + ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P2" : "P1" ) + " is closer to " + GOAL ) ; } else if ( p1 . getPoints ( ) > Game . GOAL || p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( ( ( p1 . getPoints ( ) > Game . GOAL ) ? "P2" : "P1" ) + " won this match." ) ; } else { System . out . println ( ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P1" : "P2" ) + "won this match" ) ; } }
tr	D	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
tr	E	@ Test public void testResize ( ) { ArrayHashMap map = new ArrayHashMap ( 5 ) ; int size = 198 ; Object [ ] toInsert = new Object [ size ] ; for ( int i = 0 ; i < size ; i += 2 ) { toInsert [ i ] = Integer . toString ( i ) ; toInsert [ i + 1 ] = new long ( i + 1 ) ; assertTrue ( map . putIfAbsent ( ( String ) toInsert [ i ] , ( long ) toInsert [ i + 1 ] ) ) ; assertEquals ( i / 2 + 1 , map . size ( ) ) ; } Set < String > keys = map . keySet ( ) ; assertEquals ( size / 2 , keys . size ( ) ) ; for ( int i = 0 ; i < size / 2 ; i ++ ) { String key = ( String ) toInsert [ i * 2 ] ; assertTrue ( keys . contains ( key ) ) ; assertEquals ( toInsert [ i * 2 + 1 ] , map . get ( key ) ) ; } }
tr	A	public ShootingWeaponCharacter ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , 0f ) ; this . owner = owner ; this . equipLR = equipLR ; this . remainBullet = getMaxCharge ( ) ; }
tr	C	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	A	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
tr	E	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<TestCaseItem>\n" ) ; retstr . append ( "<TestGroup>" + testgroupid + "</TestGroup>\n" ) ; retstr . append ( "<TestTitle>" + testtitle + "</TestTitle>\n" ) ; retstr . append ( "<TestDesc>" + testdesc + "</TestDesc>\n" ) ; retstr . append ( "<TestNotes>" + testnote + "</TestNotes>\n" ) ; retstr . append ( "<CreateBy>" + createby + "</CreateBy>\n" ) ; retstr . append ( "<BaseDate>" + dtfmt . format ( basedate ) + "</BaseDate>\n" ) ; retstr . append ( "<LastName>" + lastname + "</LastName>\n" ) ; retstr . append ( "<FirstName>" + firstname + "</FirstName>\n" ) ; retstr . append ( "<BirthDate>" + dtfmt . format ( birthdate ) + "</BirthDate>\n" ) ; retstr . append ( "<GenderCd>" + gendercd + "</GenderCd>\n" ) ; retstr . append ( shotlist . exportList ( ) ) ; retstr . append ( nonadmlist . exportList ( ) ) ; retstr . append ( ereslist . exportList ( ) ) ; retstr . append ( edoselist . exportList ( ) ) ; retstr . append ( "</TestCaseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	B	long write ( OutputStream out ) throws IOException { long size = 0 ; int read ; byte [ ] buf = new byte [ 8 * 1024 ] ; while ( ( read = partInput . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	A	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { astream . defaultReadObject ( ) ; theConnection = null ; }
tr	A	private String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = aLine . substring ( index + 9 ) ; boundary = "--" + boundary ; return boundary ; }
tr	C	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; JRadioButton fourStar = new JRadioButton ( Strings . BUTTON_SOURCE_FOURSTAR , true ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( fourStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( fourStar ) ; }
tr	C	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	A	public RotateShootingCharacter ( ShootingScene scene , float power , float hp ) { super ( scene , power , hp ) ; }
tr	C	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result != - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result == fBuff . length ) ; if ( sbuf . length ( ) == 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	A	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir ) throws IOException { this ( aRequest , aSaveDir , DefMaxPostSize ) ; }
tr	D	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	B	public StarCharacter ( StarCharacter parentStar , String caption , float scale , Color color , double koten , double jiten ) { this . parentStar = parentStar ; setTexture ( TextTextureMaker . createText ( caption , FontDef . RICTY_48 ) ) ; setScale ( scale ) ; setColor ( color ) ; this . kotenSpeed = koten ; this . jitenSpeed = jiten ; }
tr	D	private RecordArticleStatDayModel updateRecordArticleStatDay ( RecordArticleStatDayModel recordArticleStatDayModel ) { String sql = "UPDATE recordarticlestatday SET uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordArticleStatDayModel . getUniqueVisitor ( ) , recordArticleStatDayModel . getUniqueVisitorArticleId ( ) , recordArticleStatDayModel . getUniqueVisitorArticleTitle ( ) , recordArticleStatDayModel . getUniqueVisitorArticleUrl ( ) , recordArticleStatDayModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordArticleStatDayModel . getPageView ( ) , recordArticleStatDayModel . getPageViewArticleId ( ) , recordArticleStatDayModel . getPageViewArticleTitle ( ) , recordArticleStatDayModel . getPageViewArticleUrl ( ) , recordArticleStatDayModel . getPageViewDate ( ) . getMillis ( ) , recordArticleStatDayModel . getVisit ( ) , recordArticleStatDayModel . getVisitArticleId ( ) , recordArticleStatDayModel . getVisitArticleTitle ( ) , recordArticleStatDayModel . getVisitArticleUrl ( ) , recordArticleStatDayModel . getVisitDate ( ) . getMillis ( ) , recordArticleStatDayModel . getSite ( ) . getId ( ) , recordArticleStatDayModel . getId ( ) ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordArticleStatDayModel . getId ( ) ) ; } return recordArticleStatDayModel ; }
tr	A	public void mouseMoved ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
tr	C	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	B	protected void dbSetCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . char ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	D	public String createCustomerWithParameters ( String firstname , String lastname , String number , String street , String city , String zipcode , Date date ) { if ( firstname . equals ( "" ) & lastname . equals ( "" ) ) { return "the customer name is empty" ; } if ( firstname . equals ( "" ) ) { return "the customer firstname is empty" ; } if ( lastname . equals ( "" ) ) { return "the customer lastname is empty" ; } if ( number . equals ( "" ) ) { return " the customer adress is empty" ; } if ( ! IntegerUtil . isInteger ( zipcode ) ) { return "zipcode is not integer" ; } int zipInt = Integer . parseInt ( zipcode ) ; if ( customerService . createCustomerWithParameters ( firstname . toLowerCase ( ) , lastname . toLowerCase ( ) , number , street . toLowerCase ( ) , city . toLowerCase ( ) , zipInt , date ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	B	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { Statement stmt = theConnection . createStatement ( ) ; String sqlstr = "Select count(*) from " + dbTableNm ; stmt . executeQuery ( sqlstr ) ; stmt . close ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	C	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
tr	E	public static double [ ] [ ] randPerlin ( int width , int height , int octaveCount ) { double [ ] [ ] baseNoise = genWhiteNoise ( width , height ) ; double [ ] [ ] [ ] smoothNoise = new double [ octaveCount ] [ ] [ ] ; double persistance = 0.5f ; for ( int i = 0 ; i < octaveCount ; i ++ ) { smoothNoise [ i ] = GenerateSmoothNoise ( baseNoise , i ) ; } double [ ] [ ] perlinNoise = new double [ width ] [ height ] ; double amplitude = 1.0f ; double totalAmplitude = 0.0f ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] += smoothNoise [ octave ] [ i ] [ j ] * amplitude ; } } } for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] /= totalAmplitude ; } } return perlinNoise ; }
tr	B	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	A	@ Override public void disable ( ) { enable = false ; hide ( ) ; setVx ( 0 ) ; setVy ( 0 ) ; setVAlpha ( 0 ) ; setVScale ( 0 ) ; }
tr	A	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	B	@ Override public GameCharacterObject setAngle ( float angle ) { super . setAngle ( angle ) ; double theta = Math . toRadians ( - angle ) ; setX ( CENTER_X + getElevation ( ) * ( float ) Math . sin ( theta ) ) ; setY ( CENTER_Y + getElevation ( ) * ( float ) Math . cos ( theta ) ) ; return this ; }
tr	A	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem == null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	B	public BasicEffect ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter ) ; setScale ( random ( 0.5f , 2f ) ) ; setColor ( shooter . getColor ( ) ) ; float tmp = RANDOM . nextInt ( 360 ) ; setVx ( 3 * ( float ) sin ( tmp ) * random ( 0.2f , 1f ) ) ; setVy ( 3 * ( float ) cos ( tmp ) * random ( 0.2f , 1f ) ) ; setAngle ( tmp ) ; }
tr	E	@ Override public void setParameterValue ( PreparedStatement ps , int parameterIndex , Object parameterValue ) throws SQLException { if ( parameterValue instanceof String ) ps . setString ( parameterIndex , ( String ) parameterValue ) ; else if ( parameterValue instanceof Integer ) ps . setInt ( parameterIndex , ( ( Integer ) parameterValue ) . intValue ( ) ) ; else if ( parameterValue instanceof BigDecimal ) ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; else if ( parameterValue instanceof double ) ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Timestamp ) ps . setTimestamp ( parameterIndex , ( java . sql . Timestamp ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Time ) ps . setTime ( parameterIndex , ( java . sql . Time ) parameterValue ) ; else if ( parameterValue instanceof java . sql . Date ) ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; else if ( parameterValue instanceof java . util . Date ) { long time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new java . sql . Timestamp ( time ) ) ; } else ps . setObject ( parameterIndex , parameterValue ) ; }
tr	A	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	C	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 1 } , { - 1 , 0 , 1 } , { 1 , 0 , 1 } , { 0 , - 1 , 1 } , { - 1 , 0 , 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } , { 3 , 4 , 5 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	C	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	C	@ Test public void testTransitions ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "3" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . hit ( "1" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
tr	C	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( false ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
tr	A	private static String left ( String text , int length ) { String result = text + "                                              " ; result = result . substring ( 0 , length ) ; return "| " + result ; }
tr	E	private static double slowexp ( final double x , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double facts [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; split ( x , xs ) ; ys [ 0 ] = ys [ 1 ] = 0.0 ; for ( int i = 19 ; i >= 0 ; i -- ) { splitMult ( xs , ys , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; split ( FACT [ i ] , as ) ; splitReciprocal ( as , facts ) ; splitAdd ( ys , facts , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; } return ys [ 0 ] + ys [ 1 ] ; }
tr	C	public String showDisplay ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + myitem . expecttxt + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . resulttxt + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	D	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "startTime" , jTextField1 . getText ( ) . toString ( ) ) ; map . put ( "endTime" , jTextField2 . getText ( ) . toString ( ) ) ; Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\SalesLog.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	A	public String makeNewId ( String aprefix , int alen ) { return ( makeNewId ( "" , aprefix , alen ) ) ; }
tr	B	public void init ( ) throws ServletException { dbconn . CDbProps props = new dbconn . CDbProps ( ) ; CDbConnMan dbconnman = new CDbConnMan ( props . DbConfigFile , props . ErrorLogFile ) ; ServletContext scontext = this . getServletContext ( ) ; scontext . setAttribute ( "DbConnMan" , dbconnman ) ; CDbConnMan remconnman = new CDbConnMan ( props . RemConfigFile , props . ErrorLogFile ) ; scontext . setAttribute ( "RemConnMan" , remconnman ) ; CForecasters fcinfo = new CForecasters ( dbconnman . getConnection ( ) ) ; }
tr	E	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	E	private void renderEnabledState ( Graphics2D context ) { context . setColor ( this . getColor ( ) ) ; context . fillRect ( this . getX ( ) + this . getWidth ( ) / 2 , this . getY ( ) + this . getBorderSize ( ) , this . getWidth ( ) / 2 - this . getBorderSize ( ) , this . getHeight ( ) - 2 * this . getBorderSize ( ) ) ; context . setColor ( this . getClickedColor ( ) ) ; context . fillRect ( this . getX ( ) + this . getBorderSize ( ) , this . getY ( ) + this . getBorderSize ( ) , this . getWidth ( ) / 2 - this . getBorderSize ( ) , this . getHeight ( ) - 2 * this . getBorderSize ( ) ) ; context . setColor ( this . getColor ( ) ) ; this . label . setText ( "1" ) ; this . label . horizontalAlignCenter ( this . getY ( ) , this . getY ( ) + this . getHeight ( ) ) ; this . label . verticalAlignCenter ( this . getX ( ) , this . getX ( ) + this . getWidth ( ) / 2 ) ; this . label . render ( context ) ; }
tr	A	@ Override public void shoot ( ShootingBulletCharacter bullet ) { bullet . setParentScene ( parentScene ) ; parentScene . shoot ( bullet ) ; }
tr	B	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TNonAdminTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	C	@ Override public void run ( ) { ReferenceQueue < byte [ ] > q = new ReferenceQueue < byte [ ] > ( ) ; SoftReference < byte [ ] > r = new SoftReference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { System . out . println ( " +++ Trying to remove" ) ; q . remove ( ) ; System . out . println ( " +++ removed" ) ; } catch ( InterruptedException e ) { System . out . println ( "----------------> Interrupted" ) ; return ; } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; }
tr	E	public void addFrame ( boolean [ ] [ ] world ) throws IOException { BufferedImage image = makeFrame ( world ) ; try { IIOMetadataNode node = new IIOMetadataNode ( "javax_imageio_gif_image_1.0" ) ; IIOMetadataNode extension = new IIOMetadataNode ( "GraphicControlExtension" ) ; extension . setAttribute ( "disposalMethod" , "none" ) ; extension . setAttribute ( "userInputFlag" , "FALSE" ) ; extension . setAttribute ( "transparentColorFlag" , "FALSE" ) ; extension . setAttribute ( "delayTime" , "1" ) ; extension . setAttribute ( "transparentColorIndex" , "255" ) ; node . appendChild ( extension ) ; IIOMetadataNode appExtensions = new IIOMetadataNode ( "ApplicationExtensions" ) ; IIOMetadataNode appExtension = new IIOMetadataNode ( "ApplicationExtension" ) ; appExtension . setAttribute ( "applicationID" , "NETSCAPE" ) ; appExtension . setAttribute ( "authenticationCode" , "2.0" ) ; byte [ ] b = "!\u00FF\u000BNETSCAPE2.0\u0003\u0001\u0000\u0000\u0000" . getBytes ( ) ; appExtension . setUserObject ( b ) ; appExtensions . appendChild ( appExtension ) ; node . appendChild ( appExtensions ) ; IIOMetadata metadata ; metadata = writer . getDefaultImageMetadata ( new ImageTypeSpecifier ( image ) , null ) ; metadata . mergeTree ( "javax_imageio_gif_image_1.0" , node ) ; IIOImage t = new IIOImage ( image , null , metadata ) ; writer . writeToSequence ( t , null ) ; } catch ( IIOInvalidTreeException e ) { throw new IOException ( e ) ; } }
tr	E	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays" + " From TNonAdminTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CNonadItem myitem = new CNonadItem ( ) ; myitem . nonadmid = rset . getString ( 1 ) ; myitem . nonadmdate = rset . getDate ( 2 ) ; myitem . seriescd = rset . getString ( 3 ) ; myitem . reasoncd = rset . getString ( 4 ) ; myitem . nageyears = rset . getInt ( 5 ) ; myitem . nagemonths = rset . getInt ( 6 ) ; myitem . nageweeks = rset . getInt ( 7 ) ; myitem . nagedays = rset . getInt ( 8 ) ; this . addItem ( myitem . nonadmid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbReadList cannot read list. " , ex ) ; } }
tr	B	public CNonadItem ( ) { nonadmid = "" ; nonadmdate = new Date ( ) ; seriescd = CAppConsts . TagNoValue ; reasoncd = CAppConsts . TagNoValue ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; nageyears = 0 ; nagemonths = 0 ; nageweeks = 0 ; nagedays = 0 ; }
tr	C	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 0 , 0 , 0 , - 1 } , { 0 , 1 , 0 , 0 , 0 , - 1 } , { - 1 , 0 , 0 , 0 , 0 , - 1 } , { 1 , 0 , 1 , 0 , 0 , - 1 } , { 0 , - 1 , 1 , 0 , 0 , - 1 } , { - 1 , 0 , 1 , 0 , 0 , - 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	E	public String createSQL ( ) throws SQLException { String returnValue = "select " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) { continue ; } if ( first ) { first = false ; returnValue += field . getName ( ) ; } else { returnValue += ( "  " + field . getName ( ) ) ; } } returnValue += ( " from " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) ) ; if ( first ) { LOGGER . severe ( "Error no field with type BLOB." ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } returnValue += " for update" ; return returnValue ; }
tr	A	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( basedate ) ) ; }
tr	C	int alphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	C	public void render ( Graphics g ) { double time2 = System . currentTimeMillis ( ) / 1000.0 ; if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; projectPoint ( center , actualcenter ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; indi ( g , 10 * Math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * Math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * Math . sin ( time2 ) ) ; }
tr	B	@ Override public void update ( ) { inputProcess ( ) ; updateWind ( ) ; addFlowerIfNecessary ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { FlowerCharacter flower = ( FlowerCharacter ) ite . next ( ) ; flower . update ( wind ) ; if ( flower . canDispose ( ) ) { ite . remove ( ) ; } } }
tr	B	public void setTestResult ( CEvalItem aitem ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aitem . seriescd ) ) { myitem . setTestResult ( aitem ) ; return ; } } }
tr	E	public void displayDbProperties ( ) { java . sql . DatabaseMetaData dm = null ; java . sql . ResultSet rs = null ; try { con = this . getConnection ( ) ; if ( con != null ) { dm = con . getMetaData ( ) ; LOGGER . finest ( "Driver Information" ) ; LOGGER . finest ( "\tDriver Name: " + dm . getDriverName ( ) ) ; LOGGER . finest ( "\tDriver Version: " + dm . getDriverVersion ( ) ) ; LOGGER . finest ( "\nDatabase Information " ) ; LOGGER . finest ( "\tDatabase Name: " + dm . getDatabaseProductName ( ) ) ; LOGGER . finest ( "\tDatabase Version: " + dm . getDatabaseProductVersion ( ) ) ; LOGGER . finest ( "Avalilable Catalogs " ) ; rs = dm . getCatalogs ( ) ; while ( rs . next ( ) ) { LOGGER . finest ( "\tcatalog: " + rs . getString ( 1 ) ) ; } rs . close ( ) ; rs = null ; closeConnection ( ) ; } else LOGGER . severe ( "Error: No active Connection" ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; } dm = null ; }
tr	A	public String getString ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	D	public static void basicDialog ( String string ) { dialog = new Stage ( ) ; dialog . initStyle ( StageStyle . UTILITY ) ; GridPane group = new GridPane ( ) ; group . add ( new Label ( string + "       " ) , 0 , 0 ) ; Scene scene = new Scene ( group ) ; dialog . setScene ( scene ) ; Button button = new Button ( "Close" ) ; group . add ( new Label ( ) , 0 , 1 ) ; group . add ( button , 0 , 2 ) ; dialog . sizeToScene ( ) ; dialog . setHeight ( 100 ) ; dialog . show ( ) ; button . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { dialog . close ( ) ; } } ) ; }
tr	D	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	B	public void destroy ( ) { ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; dbconnman . shutdown ( ) ; scontext . removeAttribute ( "DbConnMan" ) ; CDbConnMan actconnman = ( CDbConnMan ) scontext . getAttribute ( "ActConnMan" ) ; actconnman . shutdown ( ) ; scontext . removeAttribute ( "ActConnMan" ) ; actconnman . drivercleanup ( ) ; }
tr	E	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position != 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
tr	B	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
tr	A	public Date parseDate ( String adstr ) { Date mydate = new Date ( 0 ) ; try { mydate = dtfmt . parse ( adstr ) ; } catch ( Exception ex ) { } return ( mydate ) ; }
tr	A	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	A	public void initTestResults ( ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . testresult = CAppConsts . StatusNone ; } }
tr	C	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL7 node = new NodeLVL7 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 6 ; int finishedDepth = 6 ; while ( true ) { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "#LVL7: Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; this . value = this . lastScore ; } return bestMove ; }
tr	D	private void train ( InputIterable < String > trainData ) { int firstHash = 1 ; int secondHash = - 1 ; int firstInsertCount = 0 ; int secondInsertCount = 0 ; WrappedObject first , second ; for ( ParseResult < String > row : trainData ) { first = new WrappedObject ( row . getFirstNode ( ) ) ; second = new WrappedObject ( row . getSecondNode ( ) ) ; if ( ! hash . containsKey ( first ) ) { if ( firstInsertCount > 10000 ) { firstInsertCount = 0 ; firstHash ++ ; } else { firstInsertCount ++ ; } hash . put ( first , firstHash ) ; } if ( ! hash . containsKey ( second ) ) { if ( secondInsertCount > 10000 ) { secondInsertCount = 0 ; secondHash -- ; } else { secondInsertCount ++ ; } hash . put ( second , secondHash ) ; } } }
tr	E	public int evalKing ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getPiece ( r + 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getPiece ( r + 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getPiece ( r - 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getPiece ( r - 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
tr	D	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; ErrMsgEcho = props . getProperty ( "ErrMsgEcho" ) . equals ( "true" ) ; ConfDir = AppDir + props . getProperty ( "ConfDir" ) ; LogDir = AppDir + props . getProperty ( "LogDir" ) ; ImportDir = AppDir + props . getProperty ( "ImportDir" ) ; ErrorLogFile = LogDir + props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	A	public String getContentType ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getContentType ( ) ; } catch ( Exception e ) { return null ; } }
tr	C	@ Test public void callsServicePassedAsParameter ( ) { ServiceAddress remoteServiceAddress = new ServiceAddress ( "localhost" , port , serviceName ) ; RemoteService remoteService = proxyMaker . make ( remoteServiceAddress , RemoteService . class ) . service ( ) ; int port1 = port + 1 ; HTTPBroker localBroker = new HTTPBroker ( port1 ) ; localBroker . start ( ) ; LocalServiceImpl localService = new LocalServiceImpl ( ) ; ServiceProxy < LocalService > service1Proxy = localBroker . registerService ( "serviceName1" , localService , LocalService . class ) ; Result result = remoteService . callWithProxy ( service1Proxy , 10 ) ; assertThat ( result . param1 , is ( localService . result . param1 ) ) ; assertThat ( result . param2 , is ( localService . result . param2 ) ) ; localBroker . stop ( ) ; localBroker . join ( ) ; }
tr	B	public void draw ( Graphics g ) { g . setColor ( Color . black ) ; g . drawLine ( ( int ) p1 . getX ( ) , ( int ) p1 . getY ( ) , ( int ) p2 . getX ( ) , ( int ) p2 . getY ( ) ) ; }
tr	D	@ Override public RecordArticleStatAllTimeModel mapRow ( ResultSet resultSet , int i ) throws SQLException { RecordArticleStatAllTimeModel recordArticleStatAllTimeModel = new RecordArticleStatAllTimeModel ( ) ; recordArticleStatAllTimeModel . setId ( resultSet . getLong ( "id" ) ) ; recordArticleStatAllTimeModel . setUniqueVisitor ( resultSet . getInt ( "uniquevisitor" ) ) ; recordArticleStatAllTimeModel . setUniqueVisitorArticleId ( resultSet . getString ( "uniquevisitorarticleid" ) ) ; recordArticleStatAllTimeModel . setUniqueVisitorArticleTitle ( resultSet . getString ( "uniquevisitorarticletitle" ) ) ; recordArticleStatAllTimeModel . setUniqueVisitorArticleUrl ( resultSet . getString ( "uniquevisitorarticleurl" ) ) ; recordArticleStatAllTimeModel . setPageView ( resultSet . getInt ( "pageview" ) ) ; recordArticleStatAllTimeModel . setPageViewArticleId ( resultSet . getString ( "pageviewarticleid" ) ) ; recordArticleStatAllTimeModel . setPageViewArticleTitle ( resultSet . getString ( "pageviewarticletitle" ) ) ; recordArticleStatAllTimeModel . setPageViewArticleUrl ( resultSet . getString ( "pageviewarticleurl" ) ) ; recordArticleStatAllTimeModel . setVisit ( resultSet . getInt ( "visit" ) ) ; recordArticleStatAllTimeModel . setVisitArticleId ( resultSet . getString ( "visitarticleid" ) ) ; recordArticleStatAllTimeModel . setVisitArticleTitle ( resultSet . getString ( "visitarticletitle" ) ) ; recordArticleStatAllTimeModel . setVisitArticleUrl ( resultSet . getString ( "visitarticleurl" ) ) ; recordArticleStatAllTimeModel . setSite ( siteDao . findById ( resultSet . getLong ( "site_id" ) ) ) ; return recordArticleStatAllTimeModel ; }
tr	A	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
tr	D	public static int getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( name . equals ( "int" ) || name . equals ( "java.lang.Integer" ) ) return INTEGER ; if ( name . equals ( "double" ) || name . equals ( "java.lang.Double" ) ) return double ; if ( name . equals ( "long" ) || name . equals ( "java.lang.Long" ) ) return long ; if ( name . equals ( "float" ) || name . equals ( "java.lang.Float" ) ) return float ; if ( name . equals ( "java.util.Date" ) ) return DATE ; if ( name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return boolean ; return - 1 ; }
tr	D	ArrayList < String > wordBreakDFS ( String s , Set < String > dict ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result . add ( head ) ; break ; } if ( cache . containsKey ( tail ) ) { tmpList = cache . get ( tail ) ; } else { tmpList = wordBreakDFS ( tail , dict ) ; } for ( String ss : tmpList ) { result . add ( head + " " + ss ) ; } } } cache . put ( s , result ) ; return result ; }
tr	E	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int cnt = CountBrewery ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt == 1 ) { int Pay ; Pay = 100 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 2 ) { int Pay ; Pay = 200 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	D	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	A	@ Override public float damage ( float damage ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
tr	C	@ Override public void update ( ) { inputProcess ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; if ( go instanceof StarCharacter ) { ( ( StarCharacter ) go ) . update ( getTimeScale ( ) ) ; } else { go . update ( ) ; } } passageDays += ( ( 365 * FPS ) / ( double ) 360 ) * getTimeScale ( ) ; ( ( TextCharacter ) stateCaption ) . updateText ( getStateString ( ) ) ; }
tr	E	public Vector2D wander ( ) { double wanderRadius = 250 ; double wanderDistance = 1000 ; double wanderJitter = .02 ; double r1 = ( r . nextDouble ( ) * 2 ) - 1 ; double r2 = ( r . nextDouble ( ) * 2 ) - 1 ; Vector2D wanderTarget = new Vector2D ( r1 * wanderJitter , r2 * wanderJitter ) ; wanderTarget = wanderTarget . unitVector ( ) ; wanderTarget = wanderTarget . scalarMult ( wanderRadius ) ; parent . side = parent . heading . perp ( ) ; Vector2D targetLocal = wanderTarget . + ( new Vector2D ( wanderDistance , 0 ) ) ; maths . Vector2D targetLocal_maths = new maths . Vector2D ( targetLocal . x , targetLocal . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( targetLocal_maths , heading_maths , side_maths , pos_maths ) ; Vector2D targetWorld = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D newVel = targetWorld . minus ( parent . position ) ; return newVel ; }
tr	E	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n == 0 ) || ( ( double ) j / n == 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } setFaces ( ) ; }
tr	C	@ Override public void hit ( K key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } Node < K > previous = findPrevious ( key ) ; if ( previous == null ) { Node < K > toInsert = new Node < K > ( ) ; toInsert . content = key ; toInsert . next = head . next ; head . next = toInsert ; if ( lru == head ) { lru = toInsert ; } } else { Node < K > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
tr	D	private void ButtonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { try { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; ButtonSaveDelete . setVisible ( false ) ; DbUtil . deleteUser ( list1 . getSelectedItem ( ) . toString ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	C	public Hoge ( LR lr , ShootingWeaponCharacter weapon ) { setWeapon ( weapon ) ; setX ( Commons . CENTER_X + ( 165 * lr . signum ( ) ) ) ; setY ( 40 ) ; weaponView . setX ( getX ( ) ) . setY ( getY ( ) + 5 ) . setWidth ( weapon . getWidth ( ) ) . setHeight ( weapon . getHeight ( ) ) . setScale ( 2 ) . setColor ( weapon . getColor ( ) ) ; remainBulletView . setX ( getX ( ) ) . setY ( getY ( ) - 25 ) . setScale ( 0.3f ) . setColor ( Color . white ) ; }
tr	C	public String buildWaiverStr ( Connection aconn , int achild , int ashot ) { CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; String retstr = "line~" + Integer . toString ( ashot ) + "^" + "child_waiver_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "series_id~" + seriesmap . mapCode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	E	public void run ( ) { while ( true ) { this . lastLoop = Timer . getTime ( ) ; if ( this . updater != null ) { this . updater . update ( ) ; } int height = this . getWindow ( ) . getHeight ( ) ; int width = this . getWindow ( ) . getWidth ( ) ; Graphics2D context = this . getWindow ( ) . getGraphicsContext ( ) ; context . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; context . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; context . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; context . setColor ( Color . black ) ; context . fillRect ( 0 , 0 , width , height ) ; if ( this . renderer != null ) { this . renderer . render ( context ) ; } this . getWindow ( ) . repaint ( ) ; long delta = this . lastLoop + this . delay - Timer . getTime ( ) ; if ( delta > 0 ) { Timer . sleep ( delta ) ; } } }
tr	A	public void shoot ( ) { if ( remainBullet <= 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
tr	B	@ Override public void update ( ) { thita += 1 / ( float ) FPS ; setX ( CENTER_X + 100 * ( float ) sin ( thita ) ) ; setY ( CENTER_Y + 100 * ( float ) cos ( thita ) ) ; damageUpdate ( ) ; super . update ( ) ; }
tr	A	public String getFilesystemName ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFilesystemName ( ) ; } catch ( Exception e ) { return null ; } }
tr	D	public static String unescapeHtmlAndCapitalizeAndReplaceDash ( String inputText ) { if ( StringUtils . isEmpty ( inputText ) ) { return inputText ; } String cleanText ; cleanText = StringEscapeUtils . unescapeHtml ( inputText ) ; cleanText = cleanText . replaceAll ( "-" , " " ) ; cleanText = cleanText . replaceFirst ( "^\\s" , "" ) ; if ( Character . isLetter ( cleanText . charAt ( 0 ) ) ) { cleanText = StringUtils . capitalize ( cleanText ) ; } else { char [ ] stringArray = cleanText . toCharArray ( ) ; for ( int i = 0 ; i < cleanText . length ( ) ; i ++ ) { if ( Character . isLetter ( cleanText . charAt ( i ) ) ) { stringArray [ i ] = Character . toUpperCase ( stringArray [ i ] ) ; cleanText = new String ( stringArray ) ; break ; } } } return cleanText ; }
tr	D	public MapBoard ( ) { initComponents ( ) ; mouse = new Point ( - 1 , - 1 ) ; addMouseMotionListener ( new MouseMotionListener ( ) { @ Override public void mouseDragged ( MouseEvent e ) { } @ Override public void mouseMoved ( MouseEvent e ) { mouse = e . getPoint ( ) ; } } ) ; try { posBuffer = new ArrayList < > ( ) ; for ( int i = 0 ; i < Game . players . size ( ) ; i ++ ) { posBuffer . add ( 0.0 ) ; } } catch ( NullPointerException err ) { System . out . println ( "Error: " + err . getMessage ( ) ) ; } try { diceimg = ImageIO . read ( new File ( "images/DICE.png" ) ) ; } catch ( IOException ex ) { System . out . println ( "Could not find image..." ) ; Logger . getLogger ( MapBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	A	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	B	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ExpectResultList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectResultList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	E	private void updateBookListView ( ) { for ( Book book : bookList ) { if ( book . getAvailibility ( ) ) { Button btn1 = new Button ( "" ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:" + book . getCover ( ) ) ) ) ; btn1 . setCursor ( Cursor . default ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( book . getName ( ) ) ; label . setCursor ( Cursor . default ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; Button removeBookBtn = new Button ( "Remove" ) ; removeBookBtn . setTranslateY ( - 65 ) ; removeBookBtn . setPrefWidth ( 120 ) ; removeBookBtn . setStyle ( "-fx-background-color: linear-gradient(#b21200 0%  #c21400 100%);-fx-text-fill: white;" + "-fx-background-radius: 0;" ) ; removeBookBtn . setOnMouseClicked ( new bookRemoveHandler ( book ) ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . getChildren ( ) . add ( removeBookBtn ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	B	@ Override public void update ( ) { if ( FPSManager . totalFrame ( ) % 45 == 0 ) { pressStartText . toggleVisible ( ) ; } if ( ! Key . ESCAPE . isPressed ( ) && Key . anyKeyPressed ( ) ) { GameSceneManager . getInstance ( ) . changeSceneIfNotNull ( nextScene ) ; } }
tr	C	public static void findLoop ( long world ) { long [ ] history = new long [ 100 ] ; history [ 0 ] = world ; for ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] == history [ j ] ) { System . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	B	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	E	public int minPathSum ( int [ ] [ ] grid ) { int m = grid . length ; int n = grid [ 0 ] . length ; int [ ] [ ] P = new int [ m ] [ n ] ; P [ 0 ] [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { P [ i ] [ 0 ] = P [ i - 1 ] [ 0 ] + grid [ i ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { P [ 0 ] [ i ] = P [ 0 ] [ i - 1 ] + grid [ 0 ] [ i ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int up = P [ i - 1 ] [ j ] + grid [ i ] [ j ] ; int left = P [ i ] [ j - 1 ] + grid [ i ] [ j ] ; P [ i ] [ j ] = Math . min ( up , left ) ; } } return P [ m - 1 ] [ n - 1 ] ; }
tr	B	@ Override public void run ( ) { FPSManager fpsManager = FPSManager . getInstance ( ) ; while ( ! Display . isCloseRequested ( ) ) { initBuffer ( ) ; Key . update ( ) ; sceneManager . update ( ) ; sceneManager . render ( ) ; fpsManager . update ( ) ; } }
tr	C	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; DbConfigFile = props . getProperty ( "DbConfigFile" ) ; RemConfigFile = props . getProperty ( "RemConfigFile" ) ; DebugLogFile = props . getProperty ( "DebugLogFile" ) ; ErrorLogFile = props . getProperty ( "ErrorLogFile" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	E	private void setTableContent ( ) { Object [ ] [ ] data = new Object [ this . presenter . getModel ( ) . getCards ( ) . size ( ) ] [ 5 ] ; int count = 0 ; for ( Card card : this . presenter . getModel ( ) . getCards ( ) ) { data [ count ] [ 0 ] = card . getBox ( ) ; data [ count ] [ 1 ] = card . getQuestion ( ) ; data [ count ] [ 2 ] = card . getAnswer ( ) ; data [ count ] [ 3 ] = card . getStatisticCountWrong ( ) ; data [ count ] [ 4 ] = card . getStatisticCountRight ( ) ; count ++ ; } String box = TranslationManager . getinstance ( ) . getText ( "box" ) ; String question = TranslationManager . getinstance ( ) . getText ( "question" ) ; String answer = TranslationManager . getinstance ( ) . getText ( "answer" ) ; String countWrong = TranslationManager . getinstance ( ) . getText ( "countWrong" ) ; String countRight = TranslationManager . getinstance ( ) . getText ( "countRight" ) ; String [ ] columnNames = { box , question , answer , countWrong , countRight } ; TableModel model = new DefaultTableModel ( data , columnNames ) ; this . table . setModel ( model ) ; }
tr	A	public LimitedServletInputStream ( ServletInputStream in , int totalExpected ) { this . in = in ; this . totalExpected = totalExpected ; }
tr	D	private void ButtonSaveNewActionPerformed ( java . awt . event . ActionEvent evt ) { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField1 . setEditable ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; ButtonSaveNew . setVisible ( false ) ; DbUtil . addUser ( jTextField1 . getText ( ) , jTextField2 . getText ( ) , jComboBox1 . getSelectedIndex ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	B	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingBulletCharacter ) { return ( T ) addShootingCharacter ( ( ShootingBulletCharacter ) go ) ; } if ( go instanceof ShootingObjectImpl ) { return ( T ) addShootingCharacter ( ( ShootingObjectImpl ) go ) ; } return super . add ( go ) ; }
tr	E	private ArrayList < String > dfs ( String s , int n ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList , key ; if ( n == 0 ) return result ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; key = new ArrayList < String > ( ) ; key . add ( tail ) ; key . add ( n - 1 + "" ) ; if ( isValid ( head ) ) { if ( tail . length ( ) == 0 ) { if ( n == 1 ) result . add ( head ) ; break ; } if ( cache . containsKey ( key ) ) { tmpList = cache . get ( key ) ; } else { tmpList = dfs ( tail , n - 1 ) ; } for ( String ss : tmpList ) { result . add ( head + "." + ss ) ; } } } key = new ArrayList < String > ( ) ; key . add ( s ) ; key . add ( n + "" ) ; cache . put ( key , result ) ; return result ; }
tr	E	public static String convertColumnName ( String columnNameInSQL ) { char [ ] chs = columnNameInSQL . toCharArray ( ) ; char [ ] result = new char [ chs . length ] ; char pre = 0 ; int j = 0 ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( i == 0 ) { if ( ch >= A && ch <= Z ) ch = ( char ) ( ch + 32 ) ; pre = ch ; continue ; } if ( pre == _ ) { if ( ( ch >= a && ch <= z ) ) { ch = ( char ) ( ch - 32 ) ; } else if ( ch >= A && ch <= Z ) { ; } else result [ j ++ ] = pre ; } else if ( ch >= A && ch <= Z ) { ch = ( char ) ( ch + 32 ) ; result [ j ++ ] = pre ; } else { result [ j ++ ] = pre ; } pre = ch ; } result [ j ++ ] = pre ; return String . valueOf ( result , 0 , j ) ; }
tr	E	private synchronized void start ( ) throws Exception { BufferedReader readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; InputIterable < String > iterable = new CSVInputIterable ( readMe ) ; Hasher hasher = new TrainableTwoStreamHasher ( iterable ) ; WrappedString . setHasher ( hasher ) ; readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; iterable = new CSVInputIterable ( readMe ) ; ArrayHashMapOptionFactory fac = new ArrayHashMapOptionFactory ( new File ( "target/testRun" ) ) ; LeastRecentlyUsed < WrappedString > strategy = new LeastRecentlyUsed < WrappedString > ( ) ; store = new PartitionedHashMap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( ParseResult < String > result : iterable ) { if ( line % 25000 == 0 ) { System . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getFirstNode ( ) ) == null ) { store . put ( result . getFirstNode ( ) , line ) ; } if ( store . get ( result . getSecondNode ( ) ) == null ) { store . put ( result . getSecondNode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
tr	D	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	E	public XmlDocument parseFile ( File file ) throws SAXException { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; factory . setValidating ( true ) ; SAXParser parser = factory . newSAXParser ( ) ; error_in_xml = false ; parser . parse ( file , this ) ; ValidatorFactory validatorFactory = Validation . buildDefaultValidatorFactory ( ) ; Validator validator = validatorFactory . getValidator ( ) ; Set < ConstraintViolation < XmlDocument >> violations = validator . validate ( document ) ; StringBuffer sb = new StringBuffer ( ) ; for ( ConstraintViolation < XmlDocument > violation : violations ) { sb . append ( String . format ( "%s: %s%n" , violation . getPropertyPath ( ) , violation . getMessage ( ) ) ) ; sb . append ( System . lineSeparator ( ) ) ; } LOGGER . log ( Level . SEVERE , "Validation du xml : " + sb . toString ( ) ) ; if ( error_in_xml ) { LOGGER . log ( Level . SEVERE , "Error in the file " + file ) ; } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Unknow error with the file " + file , e ) ; throw new SAXException ( e ) ; } return document ; }
tr	E	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) != this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) != this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) != this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	D	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	A	public CStringList ( ) { mystrings = new ArrayList < String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = false ; wasfound = false ; }
tr	B	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power , float hp ) { super ( parentScene , power , hp ) ; this . shooter = shooter ; this . remainRange = getBulletRange ( ) ; setTeam ( shooter . getTeam ( ) ) ; setX ( shooter . getX ( ) ) ; setY ( shooter . getY ( ) ) ; setWidth ( getBulletSize ( ) ) ; setHeight ( getBulletSize ( ) ) ; setTexture ( getBulletTexture ( ) ) ; }
tr	E	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } setFaces ( ) ; }
tr	A	public CDosevItem ( ) { shotid = "" ; dosenum = 0 ; validflag = "" ; invalidcd = "" ; }
tr	C	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( ltop ) ; }
tr	E	private static void splitReciprocal ( final double in [ ] , final double result [ ] ) { final double b = 1.0 / 4194304.0 ; final double a = 1.0 - b ; if ( in [ 0 ] == 0.0 ) { in [ 0 ] = in [ 1 ] ; in [ 1 ] = 0.0 ; } result [ 0 ] = a / in [ 0 ] ; result [ 1 ] = ( b * in [ 0 ] - a * in [ 1 ] ) / ( in [ 0 ] * in [ 0 ] + in [ 0 ] * in [ 1 ] ) ; if ( result [ 1 ] != result [ 1 ] ) { result [ 1 ] = 0.0 ; } resplit ( result ) ; for ( int i = 0 ; i < 2 ; i ++ ) { double err = 1.0 - result [ 0 ] * in [ 0 ] - result [ 0 ] * in [ 1 ] - result [ 1 ] * in [ 0 ] - result [ 1 ] * in [ 1 ] ; err = err * ( result [ 0 ] + result [ 1 ] ) ; result [ 1 ] += err ; } }
tr	C	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	E	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	B	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws IOException { if ( fNumRead >= fNumExpected ) { return - 1 ; } else { int result = fInStream . readLine ( aBuff , aOff , aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
tr	E	public static Point randPerimeter ( Rectangle r ) { if ( r . height <= 1 ) { return randPoint ( r ) ; } int perimeter = ( 2 * r . width ) + ( 2 * ( r . height - 2 ) ) ; int index = randInt ( perimeter - 1 ) ; if ( index < r . width ) { return new Point ( r . x + index , r . y ) ; } else if ( index < ( r . width + r . height - 2 ) ) { return new Point ( r . x , r . y + 1 + ( index - r . width ) ) ; } else if ( index < ( r . width + 2 * ( r . height - 2 ) ) ) { return new Point ( r . x + r . width - 1 , r . y + 1 + ( index - ( r . width + ( r . height - 2 ) ) ) ) ; } else if ( index < perimeter ) { return new Point ( r . x + ( index - ( r . width + 2 * ( r . height - 2 ) ) ) , r . y + r . height - 1 ) ; } return null ; }
tr	A	@ Override public GameCharacterObject setWidth ( int width ) { assert ( width % 2 == 0 ) : "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . width = width ; return this ; }
tr	C	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	D	public void initFrame ( double time ) { count = count + 1 ; for ( int i = 0 ; i < pixInverse . length ; i ++ ) { pixInverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballBearing . getMatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotateZ ( Math . PI * time / 2 ) ; m = | . getMatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotateY ( Math . PI / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getMatrix ( ) . identity ( ) ; setVertices ( world ) ; maketraps ( ) ; }
tr	D	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	D	private void createBooksIcon ( List < Book > list ) { if ( list != null ) { for ( Book book : list ) { Button btn1 = new Button ( "" ) ; btn1 . setOnAction ( new bookInfoHandler ( book ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:" + book . getCover ( ) ) ) ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( book . getName ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	E	@ Override public RecordArticleStatDayModel mapRow ( ResultSet rs , int i ) throws SQLException { RecordArticleStatDayModel model = new RecordArticleStatDayModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setUniqueVisitorArticleId ( rs . getString ( "uniquevisitorarticleid" ) ) ; model . setUniqueVisitorArticleTitle ( rs . getString ( "uniquevisitorarticletitle" ) ) ; model . setUniqueVisitorArticleUrl ( rs . getString ( "uniquevisitorarticleurl" ) ) ; model . setUniqueVisitorDate ( new DateTime ( rs . getLong ( "uniquevisitordate" ) ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setPageViewArticleId ( rs . getString ( "pageviewarticleid" ) ) ; model . setPageViewArticleTitle ( rs . getString ( "pageviewarticletitle" ) ) ; model . setPageViewArticleUrl ( rs . getString ( "pageviewarticleurl" ) ) ; model . setPageViewDate ( new DateTime ( rs . getLong ( "pageviewdate" ) ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setVisitArticleId ( rs . getString ( "visitarticleid" ) ) ; model . setVisitArticleTitle ( rs . getString ( "visitarticletitle" ) ) ; model . setVisitArticleUrl ( rs . getString ( "visitarticleurl" ) ) ; model . setVisitDate ( new DateTime ( rs . getLong ( "visitdate" ) ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
tr	B	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) == 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	A	private BackGroundColor ( float red , float green , float blue , float alpha ) { this . red = red ; this . green = green ; this . blue = blue ; this . alpha = alpha ; }
tr	D	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p != null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p != null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev != null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
tr	D	@ Override public Object call ( Object [ ] params , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { String encodedCall = encoder . encode ( params ) ; String url = "http://" + serviceAddress . hostName + ":" + serviceAddress . port + "/" + serviceAddress . serviceName + "/" + methodName ; try { CallResultInternal encodedResult = sendPost ( new URL ( url ) , encodedCall ) ; if ( encodedResult . errorCode == CallResultInternal . NO_ERROR ) { if ( encodedResult . encodedResult . isEmpty ( ) ) { return null ; } return encoder . decode ( encodedResult . encodedResult , returnType ) ; } else { ExceptionWrapper result = encoder . decode ( encodedResult . encodedResult , ExceptionWrapper . class ) ; throw makeException ( encodedResult . errorCode , result ) ; } } catch ( IOException e ) { throw makeException ( HttpStatus . BAD_REQUEST_400 , new ExceptionWrapper ( "Malformed URL: " + url , "" ) ) ; } }
tr	B	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = currentFrameTime_ns - prevFrameTime_ns ; calculatedFPS = ( ( double ) ( currentFrame ) / realElapsedTime_ns ) * 1000000000 ; currentFrame = 0 ; fpsCalcInterval_ns = 0 ; prevFrameTime_ns = currentFrameTime_ns ; } updateDisplay ( ) ; }
tr	B	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = ( ( ServletInputStream ) in ) . readLine ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	D	public Map < String , float > askVar ( ) { String varName ; float value ; Map < String , float > vars = new HashMap < > ( ) ; Scanner in = new Scanner ( System . in ) ; System . out . println ( "Enter a random variable: " ) ; varName = in . nextLine ( ) ; System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; boolean loop = true ; Scanner sc = new Scanner ( System . in ) ; while ( loop ) { System . out . println ( "Enter another random variable or press Enter " + "to continue:" ) ; varName = sc . nextLine ( ) ; if ( varName . equals ( "" ) ) { break ; } System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; } return vars ; }
tr	E	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
tr	C	private void fillTable ( List < Game > schedule ) { TableModel model = new DefaultTableModel ( new String [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( Game game : schedule ) { model . setValueAt ( game . first . getName ( ) , row , 0 ) ; model . setValueAt ( game . second . getName ( ) , row , 1 ) ; model . setValueAt ( game . getResult ( ) , row , 2 ) ; row = row + 1 ; } gamesTable . setModel ( model ) ; if ( model . getRowCount ( ) > 0 ) { gamesTable . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } }
tr	C	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	A	public int read ( ) throws IOException { if ( totalRead >= totalExpected ) { return - 1 ; } return in . read ( ) ; }
tr	A	public String getParameter ( String aName ) { try { String param = ( String ) fParameters . get ( aName ) ; if ( param . equals ( "" ) ) return null ; return param ; } catch ( Exception e ) { return null ; } }
tr	A	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	B	public static void setGlColor4f ( final Color color , final float alpha ) { if ( color == null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	E	public Query readQuery ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; String query = readQueryLine ( ) ; String queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; Query result ; int , = query . indexOf ( "|" ) ; String pair , var , val ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { pair = query . substring ( , + 1 , nextComma ) ; , = nextComma ; } else { pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; } var = pair . substring ( 0 , pair . indexOf ( "=" ) ) ; val = pair . substring ( pair . indexOf ( "=" ) + 1 ) ; map . put ( var , val ) ; if ( nextComma == - 1 ) { break ; } } result = new Query ( queryVar , map ) ; return result ; }
tr	C	@ Before public void setUp ( ) { context = new JUnit4Mockery ( ) ; service = context . mock ( ServiceInterface . class ) ; serviceAddress = new ServiceAddress ( "hostName" , 1234 , "serviceName" ) ; expectedJson = "{\"hostName\":\"hostName\" " + "\"port\":1234 \"serviceName\":\"serviceName\"}" ; gson = JsonParserBuilder . build ( new ServiceProxyMaker ( new ServiceCaller ( ) { @ Override public Object call ( Object [ ] args , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { service . call ( ( int ) ( args [ 0 ] ) ) ; return null ; } } ) ) ; }
tr	E	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TNonAdminTbl (TestGroupId TestId NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays)" + " Values (? ? ? ? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . nonadmid ) ; stmt . setDate ( 4 , new java . sql . Date ( myitem . nonadmdate . getTime ( ) ) ) ; stmt . setString ( 5 , myitem . seriescd ) ; stmt . setString ( 6 , myitem . reasoncd ) ; stmt . setInt ( 7 , myitem . nageyears ) ; stmt . setInt ( 8 , myitem . nagemonths ) ; stmt . setInt ( 9 , myitem . nageweeks ) ; stmt . setInt ( 10 , myitem . nagedays ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbWriteList cannot write list. " , ex ) ; } }
tr	B	public void modifyDates ( Date abirthdt ) { Date lastdt = new Date ( abirthdt . getTime ( ) ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CShotItem myitem = ( CShotItem ) this . getItem ( idx ) ; } }
tr	D	public void batchInsert ( final List < RecordSiteStatModel > recordSiteStatModelList ) { String sql = "INSERT INTO recordsitestat (uniquevisitor  uniquevisitordate  " + "pageview  pageviewdate  visit  visitdate  site_id) VALUES (?  ?  ?  ?  ?  ?  ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return recordSiteStatModelList . size ( ) ; } } ) ; }
tr	D	public String createBookWithParameters ( String name , String author , String year , BookType bookType , String cover , String description ) { int yearToInt = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } String str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! IntegerUtil . isInteger ( year ) ) { return "the year must be valid" ; } else { yearToInt = Integer . parseInt ( year ) ; } if ( cover == null ) { cover = Book . DEFAULT_IMG_PATH ; } if ( bookService . createBookWithParameters ( name . toLowerCase ( ) , str [ 0 ] , str [ 1 ] , yearToInt , bookType , cover , description ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	D	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
tr	D	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	A	public void makeItem ( CEvalItem aitem ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . copyItem ( aitem ) ; myitem . evalid = this . makeNewId ( "res" , 6 ) ; this . addItem ( myitem . evalid , myitem ) ; }
tr	D	@ Test public void testSubquery ( ) throws ParsingException { QueryMap qm = QueryFactory . createQueryMap ( "test.sql" ) ; Query main = qm . getQuery ( "main" ) ; assertArrayEquals ( new String [ ] { "name" , "id" } , main . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . text ) ; Query sub1 = qm . getQuery ( main , "sub1" ) ; assertArrayEquals ( new String [ ] { "name" , "city" , "id" } , sub1 . parameters ) ; assertEquals ( "select id  ?   zip  ?   email\nfrom tb where id=?  and zip is not null" , sub1 . text ) ; Query sub2 = qm . getQuery ( main , "sub2" ) ; assertArrayEquals ( new String [ ] { "name" , "id" , "email" } , sub2 . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub2 . text ) ; Query sub12 = qm . getQuery ( main , "sub2" , "sub1" ) ; assertArrayEquals ( new String [ ] { "name" , "city" , "id" , "email" } , sub12 . parameters ) ; assertEquals ( "select id  ?   zip  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub12 . text ) ; }
tr	D	public ArrayList < Integer > inorderTraversal ( TreeNode root ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; Deque < TreeNode > stack = new ArrayDeque < TreeNode > ( ) ; Set < TreeNode > set = new HashSet < TreeNode > ( ) ; stack . push ( root ) ; while ( stack . size ( ) > 0 ) { TreeNode node = stack . peek ( ) ; if ( node . left != null && ! set . contains ( node . left ) ) { stack . push ( node . left ) ; continue ; } node = stack . pop ( ) ; set . add ( node ) ; result . add ( node . val ) ; if ( node . right != null ) { stack . push ( node . right ) ; } } return result ; }
tr	C	public < T > ServiceProxy < T > registerService ( final T service , final String serviceName , class < T > interfaceClass ) { checkNotRegistered ( serviceName ) ; try { final String address = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; ServiceProxyImpl < T > serviceProxy = new ServiceProxyImpl < > ( new ServiceAddress ( address , broker . getPort ( ) , serviceName ) , service , interfaceClass ) ; services . put ( serviceName , serviceProxy ) ; return serviceProxy ; } catch ( UnknownHostException shouldNeverHappen ) { throw new RuntimeException ( shouldNeverHappen ) ; } }
tr	A	public ShootingEffectCharacter ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter , 0 ) ; disposeAfter ( getLifeTime ( ) ) ; setTeam ( TEAM . NO_TEAM ) ; }
tr	C	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
tr	E	public void initComponents ( ) { this . getContentPane ( ) . setBackground ( Color . WHITE ) ; this . topic = new JTextPane ( ) ; this . scrollPane = new JScrollPane ( table ) ; table . setPreferredScrollableViewportSize ( new Dimension ( 400 , 0 ) ) ; super . setBackground ( Color . WHITE ) ; super . setResizable ( false ) ; super . setSize ( 500 , 500 ) ; super . setVisible ( true ) ; super . setLayout ( null ) ; scrollPane . setBounds ( 50 , 80 , 400 , 350 ) ; topic . setEditable ( false ) ; SimpleAttributeSet set = new SimpleAttributeSet ( ) ; StyleConstants . setAlignment ( set , StyleConstants . ALIGN_LEFT ) ; StyleConstants . setFontFamily ( set , "Times New Roman" ) ; StyleConstants . setFontSize ( set , 30 ) ; StyleConstants . setItalic ( set , true ) ; StyleConstants . setBold ( set , true ) ; topic . setParagraphAttributes ( set , true ) ; topic . setBackground ( Color . WHITE ) ; topic . setBounds ( 50 , 20 , 200 , 50 ) ; topic . setText ( "Topic" ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_ALWAYS ) ; super . add ( scrollPane ) ; super . add ( topic ) ; }
tr	A	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx >= 0 ) delItem ( idx ) ; }
tr	D	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current == null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	E	private ResponseListener < ReportActualPositionResponse > createPositionListener ( final CountDownLatch latch ) { return new ResponseListener < ReportActualPositionResponse > ( ) { @ Override public void onResponse ( ReportActualPositionResponse response ) { double [ ] displacement = new double [ motors . length ] ; for ( int i = 0 ; i < motors . length ; i ++ ) { Motor motor = motors [ i ] ; int count = response . getEncoderCount ( ) [ i ] ; if ( i >= motors . length / 2 ) count = - count ; double lastPosition = motor . getPosition ( ) ; motor . setEncoderCount ( count ) ; motor . setPosition ( MotorUtils . countsToDistance ( count ) ) ; displacement [ i ] = motor . getPosition ( ) - lastPosition ; } double left = displacement [ displacement . length / 2 ] ; double right = displacement [ 0 ] ; if ( left != 0 && right != 0 ) { getPosition ( ) . move ( left , right ) ; if ( positionListener != null ) positionListener . onNewPosition ( getPosition ( ) , response . getTimestamp ( ) ) ; } latch . countDown ( ) ; } } ; }
tr	B	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p + characterSize / 2 < 0 ) { p = displayBorder - p ; } else if ( displayBorder < p - characterSize / 2 ) { p = - p + displayBorder ; } return p ; }
tr	A	public String getBirthDateStr ( ) { if ( birthdate == null || birthdate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( birthdate ) ) ; }
tr	E	public void applyfog ( int [ ] rgb , double dist , double [ ] v ) { double k = 0.05 ; double [ ] fogcolor = { 150 , 150 , 150 } ; double a = Math . pow ( 2 , - k * dist ) ; double fx = ( ( double ) v [ 0 ] - W / 2 ) / W ; double fy = ( ( double ) v [ 1 ] - H / 2 ) / H ; double temp = Math . sin ( ImprovedNoise . noise ( 4 * fx , 4 * fy , time * 1000 ) ) ; rgb [ 0 ] = ( int ) ( ( ( 1 - a ) * rgb [ 0 ] + a * fogcolor [ 0 ] ) * temp ) ; rgb [ 1 ] = ( int ) ( ( ( 1 - a ) * rgb [ 1 ] + a * fogcolor [ 1 ] ) * temp ) ; rgb [ 2 ] = ( int ) ( ( ( 1 - a ) * rgb [ 2 ] + a * fogcolor [ 2 ] ) * temp ) ; }
tr	B	public void setMetaData ( String atable , String acode , String adesc , String asort , String amastbl , String amasfld ) { setTableNm ( atable ) ; setCodeFld ( acode ) ; setDescFld ( adesc ) ; setSortFld ( asort ) ; setMastTbl ( amastbl ) ; setMastFld ( amasfld ) ; }
tr	C	public static void main ( String [ ] args ) { int [ ] [ ] i = new int [ 2 ] [ 2 ] ; int [ ] [ ] j = { i [ 1 ] , { 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; int [ ] [ ] [ ] k = { i , j } ; System . out . println ( k [ 0 ] [ 1 ] [ 0 ] ++ ) ; System . out . println ( ++ k [ 1 ] [ 0 ] [ 0 ] ) ; System . out . println ( i [ 1 ] [ 0 ] ) ; System . out . println ( -- j [ 0 ] [ 0 ] ) ; }
tr	B	public MyShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "tokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( getHeight ( ) ) ; setColor ( new Color ( 0.6f , 0.6f , 1f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
tr	C	private void setPlugins ( String pluginName , List < P > players , final List < P > enabledPlayers ) { groupCheckBox . setText ( pluginName ) ; groupCheckBox . setSelected ( true ) ; for ( final P p : players ) { final JCheckBox checkBox = new JCheckBox ( p . getName ( ) ) ; checkBox . setSelected ( true ) ; checkBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( checkBox . isSelected ( ) ) { enabledPlayers . add ( p ) ; } else { enabledPlayers . remove ( p ) ; } } } ) ; playerPanel . add ( checkBox ) ; enabledPlayers . add ( p ) ; } }
tr	B	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures >= loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	C	@ Override public long remove ( String key ) { int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; while ( keys [ offset ] != null ) { if ( keys [ offset ] . equals ( key ) ) { long toReturn = values [ offset ] ; keys [ offset ] = Tombstone ; size -- ; return toReturn ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return null ; } } return null ; }
tr	B	protected void dbSetDecimalParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . DECIMAL ) ; } else { java . math . BigDecimal tmpval = new java . math . BigDecimal ( astr ) ; astmt . setBigDecimal ( anum , tmpval ) ; } }
tr	E	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	E	private void merge ( int [ ] A , int start , int mid , int end , AtomicInteger inversionCount ) { int nL = mid - start + 1 ; int nR = end - mid ; int [ ] L = new int [ nL + 1 ] ; int [ ] R = new int [ nR + 1 ] ; L [ nL ] = Integer . MAX_VALUE ; R [ nR ] = Integer . MAX_VALUE ; System . arraycopy ( A , start , L , 0 , nL ) ; System . arraycopy ( A , mid + 1 , R , 0 , nR ) ; int l = 0 , r = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( L [ l ] < R [ r ] ) { A [ i ] = L [ l ] ; l ++ ; } else { A [ i ] = R [ r ] ; r ++ ; int count = inversionCount . get ( ) ; count += nL - l ; inversionCount . set ( count ) ; } } }
tr	E	@ Test public void manyInsertsCompareWithJavaUtilHashMap ( ) { SimpleMap < String , long > map = getMapInstance ( 5 ) ; HashMap < String , long > check = new HashMap < String , long > ( ) ; for ( long i = - 1000 ; i < 300000 ; i ++ ) { assertTrue ( map . put ( long . toHexString ( i ) , i ) ) ; check . put ( long . toHexString ( i ) , i ) ; } assertEquals ( check . size ( ) , map . size ( ) ) ; int first = 0 , second = 0 ; for ( String key : map . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; first ++ ; } Set < String > unique = new HashSet < String > ( ) ; for ( String key : map . keySet ( ) ) { assertTrue ( unique . add ( key ) ) ; } for ( String key : check . keySet ( ) ) { assertEquals ( check . get ( key ) , map . get ( key ) ) ; second ++ ; } assertEquals ( check . size ( ) , first ) ; assertEquals ( map . size ( ) , second ) ; assertEquals ( first , second ) ; }
tr	E	private static double [ ] [ ] GenerateSmoothNoise ( double [ ] [ ] baseNoise , int octave ) { int width = baseNoise . length ; int height = baseNoise [ 0 ] . length ; double [ ] [ ] smoothNoise = new double [ width ] [ height ] ; int samplePeriod = 1 << octave ; double sampleFrequency = 1.0f / samplePeriod ; for ( int i = 0 ; i < width ; i ++ ) { int sample_i0 = ( i / samplePeriod ) * samplePeriod ; int sample_i1 = ( sample_i0 + samplePeriod ) % width ; double horizontal_blend = ( i - sample_i0 ) * sampleFrequency ; for ( int j = 0 ; j < height ; j ++ ) { int sample_j0 = ( j / samplePeriod ) * samplePeriod ; int sample_j1 = ( sample_j0 + samplePeriod ) % height ; double vertical_blend = ( j - sample_j0 ) * sampleFrequency ; double top = Interpolate ( baseNoise [ sample_i0 ] [ sample_j0 ] , baseNoise [ sample_i1 ] [ sample_j0 ] , horizontal_blend ) ; double bottom = Interpolate ( baseNoise [ sample_i0 ] [ sample_j1 ] , baseNoise [ sample_i1 ] [ sample_j1 ] , horizontal_blend ) ; smoothNoise [ i ] [ j ] = Interpolate ( top , bottom , vertical_blend ) ; } } return smoothNoise ; }
tr	A	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power ) { this ( parentScene , shooter , power , 1 ) ; }
tr	D	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
tr	A	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName != null ) { size = write ( out ) ; } return size ; }
tr	C	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getIndex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	E	private int miniMax ( NodeLVL4 node , int depth , int alpha , int beta ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { stopped = false ; return node . getValue ( ) ; } if ( ! ds . isWhiteToMove ( ) ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	C	public static void main ( String [ ] args ) { HTTPBroker broker = new HTTPBroker ( 6666 ) ; broker . start ( ) ; ServiceProxy < ClientService > localService = broker . registerService ( "client" , new ClientServiceImpl ( ) , ClientService . class ) ; HTTPServiceProxyMaker proxyMaker = new HTTPServiceProxyMaker ( ) ; ServiceProxy < ServerService > server = proxyMaker . make ( new ServiceAddress ( "localhost" , 9999 , "server" ) , ServerService . class ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { System . out . println ( server . service ( ) . callServer ( localService , i ) ) ; } broker . stop ( ) ; }
tr	D	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove == null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
tr	C	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	C	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	B	public EDFStageController ( ShootingScene edf ) { currentStage = add ( new EDFStage ( edf ) ) ; startCaption = add ( new TextCharacter ( "STAGE 1 START" ) ) ; endCaption = add ( new TextCharacter ( "CLEAR!" ) ) ; startCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; endCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; }
tr	A	public CForecasters ( Connection aconn ) { fcasterinfo = new String [ MAXFC ] [ FDESC + 1 ] ; dbLoadList ( aconn ) ; }
tr	C	public int getNumAnswers ( String [ ] lines ) { String first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexOf ( " " ) ) ; int answers = 0 ; for ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i ] . indexOf ( " " ) ; String current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
tr	A	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	E	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int res = 0 ; long N = in . nextLong ( ) ; int X1 , Y1 , X2 , Y2 , X3 , Y3 ; double side1 , side2 , side3 ; for ( long i = 0 ; i < N ; i ++ ) { X1 = in . nextInt ( ) ; Y1 = in . nextInt ( ) ; X2 = in . nextInt ( ) ; Y2 = in . nextInt ( ) ; X3 = in . nextInt ( ) ; Y3 = in . nextInt ( ) ; side1 = Math . pow ( ( X1 - X2 ) , 2 ) + Math . pow ( ( Y1 - Y2 ) , 2 ) ; side2 = Math . pow ( ( X2 - X3 ) , 2 ) + Math . pow ( ( Y2 - Y3 ) , 2 ) ; side3 = Math . pow ( ( X3 - X1 ) , 2 ) + Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } System . out . println ( res ) ; }
tr	E	@ Override public String format ( LogRecord record ) { String loggerName = record . getLoggerName ( ) ; if ( loggerName == null ) { loggerName = "root" ; } StringBuilder output = new StringBuilder ( ) . append ( "[" ) . append ( record . getLevel ( ) ) . append ( ] ) . append ( " " + format . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " : " ) . append ( "..." + StringUtils . substringAfterLast ( record . getSourceClassName ( ) , "org.jobjects." ) + "." + record . getSourceMethodName ( ) + "()" ) . append ( " : " ) ; if ( record . getParameters ( ) != null ) { output . append ( MessageFormat . format ( record . getMessage ( ) , record . getParameters ( ) ) ) ; } else { output . append ( record . getMessage ( ) ) ; } if ( record . getThrown ( ) != null ) { output . append ( System . lineSeparator ( ) ) ; output . append ( ExceptionUtils . getStackTrace ( record . getThrown ( ) ) ) ; } output . append ( System . lineSeparator ( ) ) ; return output . toString ( ) ; }
tr	A	public String getShotAge ( Date abirth ) { String daystr = getShotAgeDays ( abirth ) ; String wkstr = getShotAgeWeeks ( abirth ) ; String mnstr = getShotAgeMonths ( abirth ) ; String retstr = daystr + wkstr + mnstr ; return ( retstr ) ; }
tr	B	private static void setPreSettingsFor2DGame ( ) { glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_CULL_FACE ) ; glCullFace ( GL_BACK ) ; glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; glOrtho ( 0 , WIDTH , 0 , HEIGHT , - DEPTH / 2 , DEPTH / 2 ) ; glMatrixMode ( GL_MODELVIEW ) ; AlphaBlend . AlphaBlend . config ( ) ; }
tr	B	public boolean isSeriesDose ( String aseries ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( myitem . seriescd . equals ( aseries ) ) { return ( true ) ; } } return ( false ) ; }
tr	C	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	E	private void buttonSaveEditActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; jComboBox1 . setEnabled ( false ) ; jComboBox2 . setEnabled ( false ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; try { DbUtil . editItems ( textField1 . getText ( ) , textField2 . getText ( ) , Integer . parseInt ( categories [ jComboBox1 . getSelectedIndex ( ) ] [ 0 ] ) , double . parseDouble ( textField3 . getText ( ) ) , jComboBox2 . getSelectedIndex ( ) , Integer . parseInt ( textField4 . getText ( ) ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; jComboBox1 . removeAllItems ( ) ; try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	A	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	E	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	B	public static void main ( final String [ ] args ) { initialize ( ) ; GameSceneManager sceneMaster = GameSceneManager . getInstance ( ) ; try { new GameLoop ( sceneMaster ) . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sceneMaster . dispose ( ) ; Display . destroy ( ) ; System . exit ( 0 ) ; } }
tr	E	@ Transactional ( propagation = Propagation . REQUIRES_NEW , readOnly = false ) public void batchInsert ( final List < ArticleStatModel > articleStatModelList ) { String sql = "INSERT IGNORE INTO articlestat (uniquevisitor  pageview  visit  date articleid  articletitle articleurl site_id) VALUES (?  ?  ?  ? ?  ? ? ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { ArticleStatModel model = articleStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return articleStatModelList . size ( ) ; } } ) ; }
tr	C	public void printQuery ( String queryVar , Map < String , float > vars ) { System . out . print ( "P( " + queryVar + " | " ) ; Set < String > keySet = vars . keySet ( ) ; Iterator < String > keySetIterator = keySet . iterator ( ) ; String key = keySetIterator . next ( ) ; System . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keySetIterator . hasNext ( ) ) { key = keySetIterator . next ( ) ; System . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } System . out . print ( ")" ) ; }
tr	E	public void initialize ( ) { world = new Geometry ( H , W ) ; ballBearing = new Geometry ( H , W ) ; | = new Geometry ( H , W ) ; wheel = new Geometry ( H , W ) ; zbuffer = new double [ pix . length ] ; for ( int i = 0 ; i < pix . length ; i ++ ) zbuffer [ i ] = - 10 ; material . setAmbient ( new double [ ] { 0.38 , 0.15 , 0.03 } ) ; material . setDiffuse ( new double [ ] { 0.5 , 0.4 , 0.0 } ) ; material . setSpecular ( new double [ ] { 0.8 , 0.8 , 0.0 } ) ; material . setSpecularPower ( 10 ) ; ballBearing . Makesphere ( 50 , 50 ) ; ballBearing . material = material ; allShapes . add ( ballBearing ) ; world . add ( ballBearing ) ; for ( Geometry shapes : allShapes ) { shapes . makeTriangles ( ) ; shapes . trapazoids = new ArrayList < double [ ] [ ] > ( shapes . triangles . size ( ) * 2 ) ; for ( int i = 0 ; i < shapes . triangles . size ( ) * 2 ; i ++ ) { shapes . trapazoids . add ( new double [ 4 ] [ 6 ] ) ; } } }
tr	D	private void CancelActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( false ) ; textField1 . setEnabled ( false ) ; textField1 . setText ( "" ) ; textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField2 . setText ( "" ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField3 . setText ( "" ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; textField4 . setText ( "" ) ; jComboBox1 . setEnabled ( false ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setEnabled ( false ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; }
tr	D	public List < String > seperateTables ( List < String > data , List < Integer > lineNums ) { List tables = new ArrayList < String > ( ) ; for ( int k = 0 ; k < lineNums . size ( ) ; k ++ ) { int start = lineNums . get ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; String [ ] entry = new String [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } String [ ] blub = ( String [ ] ) tables . get ( 0 ) ; return tables ; }
tr	C	public static void main ( String [ ] args ) { try { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( "You haven't entered any arguments." ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Something to do with the play method." ) ; } }
tr	C	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { groupCheckBox = new JCheckBox ( ) ; jScrollPane2 = new JScrollPane ( ) ; playerPanel = new JPanel ( ) ; filler1 = new Box . Filler ( new Dimension ( 5 , 0 ) , new Dimension ( 15 , 0 ) , new Dimension ( 5 , 0 ) ) ; setLayout ( new BorderLayout ( ) ) ; groupCheckBox . setText ( "group name" ) ; groupCheckBox . setEnabled ( false ) ; add ( groupCheckBox , BorderLayout . NORTH ) ; jScrollPane2 . setBorder ( null ) ; playerPanel . setLayout ( new BoxLayout ( playerPanel , BoxLayout . Y_AXIS ) ) ; jScrollPane2 . setViewportView ( playerPanel ) ; add ( jScrollPane2 , BorderLayout . CENTER ) ; add ( filler1 , BorderLayout . WEST ) ; }
tr	C	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { return ; } setScale ( getScale ( ) + getVScale ( ) ) ; setAngle ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	A	PartInputStream ( ServletInputStream in , String boundary ) throws IOException { super ( in ) ; this . boundary = boundary ; }
tr	E	public static double [ ] circle_circle_p ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = NONE ; double dx = cx1 - cx0 ; double dy = cy1 - cy0 ; double distSQ = dx * dx + dy * dy ; if ( distSQ > ACCY ) { double r0SQ = r0 * r0 ; double r1SQ = r1 * r1 ; double diffRSQ = ( r1SQ - r0SQ ) ; double root = 2 * ( r1SQ + r0SQ ) * distSQ - distSQ * distSQ - diffRSQ * diffRSQ ; if ( root > - ACCY ) { double distINV = 0.5f / distSQ ; double scl = 0.5f - diffRSQ * distINV ; double x = dx * scl + cx0 ; double y = dy * scl + cy0 ; if ( root < ACCY ) { result = new double [ ] { x , y } ; } else { root = distINV * Math . sqrt ( root ) ; double xfac = dx * root ; double yfac = dy * root ; result = new double [ ] { x - yfac , y + xfac , x + yfac , y - xfac } ; } } } return result ; }
tr	D	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	D	public int evalBlackPiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c == 9 || c == 0 ) { total += param3 ; } if ( bottomLeft == 0 ) { total += param5 ; } else if ( bottomRight == 0 ) { total += param5 ; } total += r * param7 ; if ( r < 3 ) { total += param9 ; } if ( r > 6 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent == 0 ) ? param11 : 0 ; total += PLAYGROUND [ 9 - r ] [ 9 - c ] ; return total ; }
tr	C	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	D	@ SuppressWarnings ( "unchecked" ) public List < Customer > getCustomerByParameters ( String firstname , String lastname , int zipcode ) { if ( zipcode == 0 ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%')" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; } Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%') and zipcode=:zipcode" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setInteger ( "zipcode" , zipcode ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; }
tr	B	public TestEnemyShip ( ShootingScene scene ) { super ( scene , 1 ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "DotTokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( HEIGHT - getHeight ( ) ) ; setColor ( new Color ( 1f , 0.6f , 0.6f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
tr	A	public void setLastRunFC1 ( ) { fc1result = edoselist . getTestStatus ( ) ; fc1rundt = new Date ( ) ; }
tr	B	public EDFScene ( ) { BackGroundColor . BLACK . set ( ) ; characterController = add ( new EDFCharacterController ( ) ) ; stageController = add ( new EDFStageController ( this ) ) ; add ( new EDFMoneyCaption ( this ) ) ; add ( new EDFWeaponCaption ( characterController ) ) ; }
tr	B	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	D	@ Test public void manyInsertsCompareWithJavaUtilHashMap ( ) { ArrayHashMap map = new ArrayHashMap ( 5 ) ; HashMap < String , long > check = new HashMap < String , long > ( ) ; for ( long i = - 1000 ; i < 300000 ; i ++ ) { assertTrue ( map . put ( long . toHexString ( i ) , i ) ) ; check . put ( long . toHexString ( i ) , i ) ; } assertEquals ( check . size ( ) , map . size ( ) ) ; for ( String key : map . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; } for ( String key : check . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; } }
tr	A	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
tr	E	protected void updateMetaData ( ) throws SQLException { if ( this . columns != null ) return ; this . types = query . getTypes ( ) ; if ( this . types != null ) { this . columns = query . getColumns ( ) ; return ; } synchronized ( query ) { this . types = query . getTypes ( ) ; if ( this . types != null ) { this . columns = query . getColumns ( ) ; } else { ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; String [ ] columnNames = new String [ columnCount ] ; int [ ] columnTypes = new int [ columnCount ] ; for ( int i = 0 ; i < columnCount ; i ++ ) { int index = i + 1 ; columnNames [ i ] = convertColumnName ( meta . getColumnName ( index ) ) ; columnTypes [ i ] = meta . getColumnType ( index ) ; } this . columns = MetaInfoMap . getOrPutColumns ( new ReadOnlyArray < String > ( columnNames ) ) ; this . types = MetaInfoMap . getOrPutTypes ( new ReadOnlyInts ( columnTypes ) ) ; query . setMetaData ( columns , types ) ; } } }
tr	C	private void train ( Iterable < K > trainData ) { System . out . println ( "Training..." ) ; long start = System . currentTimeMillis ( ) ; long position = 0 ; List < long > current ; for ( K datum : trainData ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new LinkedList < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } System . out . println ( "Done  took " + ( System . currentTimeMillis ( ) - start ) / 1000 + " ms" ) ; }
tr	E	@ Override public void update ( ) { if ( this . lastAlphaUpdate == 0 ) { this . lastAlphaUpdate = Timer . getTime ( ) ; } if ( Timer . getTime ( ) - this . lastAlphaUpdate >= 75 ) { if ( this . increaseAlpha ) { this . alpha += 0.04f ; if ( this . alpha >= 1.0f ) { this . alpha = 1.0f ; this . increaseAlpha = false ; } } else { this . alpha -= 0.04f ; if ( this . alpha <= 0.0f ) { this . alpha = 0.0f ; this . increaseAlpha = true ; } } this . lastAlphaUpdate = Timer . getTime ( ) ; } int width = GameWindow . getInstance ( ) . getWidth ( ) ; int height = GameWindow . getInstance ( ) . getHeight ( ) ; this . firstTitleLabel . verticalAlignCenter ( 0 , width ) ; this . secondTitleLabel . setY ( this . firstTitleLabel . getY ( ) + 10 ) ; this . secondTitleLabel . verticalAlignCenter ( 0 , width ) ; this . pressSpaceLabel . setY ( height * 9 / 10 - this . pressSpaceLabel . getHeight ( ) / 2 ) ; this . pressSpaceLabel . verticalAlignCenter ( 0 , width ) ; if ( Keyboard . isPressed ( KeyEvent . VK_SPACE ) ) { Game . getInstance ( ) . loadScene ( Scene . SCENE_MENU ) ; } }
tr	D	public ArrayList < Integer > grayCode ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; ArrayList < Integer > codes = init ( n ) ; result . add ( 0 ) ; Set < ArrayList < Integer >> cache = new HashSet < ArrayList < Integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; while ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { ArrayList < Integer > newCodes = changeOneBit ( codes , i ) ; if ( cache . contains ( newCodes ) ) { i -- ; } else { codes = newCodes ; cache . add ( codes ) ; result . add ( codesToNumber ( codes ) ) ; break ; } } } return result ; }
tr	A	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	A	public String getFC2ResultStr ( ) { if ( fc2result == null ) { return ( "" ) ; } return ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
tr	A	private void fill ( ) throws IOException { int i = in . read ( buf , 0 , buf . length ) ; if ( i > 0 ) { pos = 0 ; count = i ; } }
tr	D	@ SuppressWarnings ( "unchecked" ) public List < Book > getBooksByParameters ( String name , String author , int year , String bookType , String series , boolean availibility ) { Transaction readTransaction = session . beginTransaction ( ) ; if ( year == 0 ) { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } else { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and year = :year and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setInteger ( "year" , year ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } }
tr	A	public int available ( ) throws IOException { int avail = ( count - pos - 2 ) + in . available ( ) ; return ( avail < 0 ? 0 : avail ) ; }
tr	D	public static void print ( int indent , Node node ) { if ( node instanceof Comment ) { printIndent ( indent , "// " + ( ( Comment ) node ) . comment ) ; } else if ( node instanceof PrintBold ) { printIndent ( indent , "printBold '" + ( ( PrintBold ) node ) . message + "'" ) ; } else if ( node instanceof Print ) { printIndent ( indent , "print '" + ( ( Print ) node ) . message + "'" ) ; } else if ( node instanceof Block ) { printIndent ( indent , "begin" ) ; print ( indent + 1 , ( ( Block ) node ) . first ) ; print ( indent + 1 , ( ( Block ) node ) . second ) ; printIndent ( indent , "end" ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
tr	C	public boolean isSubset ( String [ ] subset , String [ ] set ) { for ( String subElem : subset ) { if ( subElem . equals ( subset [ 0 ] ) ) { continue ; } if ( subElem . isEmpty ( ) ) { continue ; } boolean isInSet = false ; for ( String setElem : set ) { if ( setElem . isEmpty ( ) ) { continue ; } if ( subElem . equals ( setElem ) ) { isInSet = true ; } } if ( ! isInSet ) { return false ; } } return true ; }
tr	B	public String makeDataDrop ( ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) getItem ( idx ) ; retstr = retstr + CCodeDesc . TokDropBegRec + myitem . mastval + CCodeDesc . TokDropSepRec + myitem . codeval + CCodeDesc . TokDropSepRec + myitem . descval + CCodeDesc . TokDropSepRec + CCodeDesc . TokDropEndRec ; } return ( retstr ) ; }
tr	A	public MultipartStreamHandler ( ServletInputStream aStream , String aBoundary , int aExpected ) { this . fInStream = aStream ; this . fBoundary = aBoundary ; this . fNumExpected = aExpected ; }
tr	D	@ Test public void testSetFieldValue ( ) throws Exception { ReflectInfo info = ReflectUtil . buildReflectInfo ( User . class ) ; final double amountNew = amountOld + 100 ; final String idNew = idOld + "new" ; final String userNameNew = userNameOld + "new" ; final Timestamp createdNew = new Timestamp ( 2000 ) ; info . setFieldValue ( 0 , u , amountNew ) ; assertEquals ( amountNew , u . getAmount ( ) . doubleValue ( ) , 0 ) ; info . setFieldValue ( 3 , u , idNew ) ; assertEquals ( idNew , u . getId ( ) ) ; info . setFieldValue ( 5 , u , userNameNew ) ; assertEquals ( userNameNew , u . getUserName ( ) ) ; info . setFieldValue ( 1 , u , createdNew ) ; assertEquals ( createdNew , u . getCreated ( ) ) ; }
tr	D	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	B	private String extractContentType ( String aLine ) throws IOException { String contentType = null ; String myline = aLine . toLowerCase ( ) ; if ( myline . startsWith ( "content-type" ) ) { int start = myline . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Corrupt content type: " + aLine ) ; contentType = myline . substring ( start + 1 ) ; } else if ( myline . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ) ; return contentType ; }
tr	B	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == null ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else { setTranslate ( * . parentStar ) ; glRotatef ( ( float ) * . kotenAngle , 0 , 0 , 1 ) ; glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; glRotatef ( ( float ) - * . kotenAngle , 0 , 0 , 1 ) ; } }
tr	D	private void buttonLoginActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! textUser . getText ( ) . isEmpty ( ) && ! textPassword . getText ( ) . isEmpty ( ) ) { try { DbUtil login = new DbUtil ( textUser . getText ( ) , textPassword . getText ( ) ) ; String [ ] loggedin = login . logIn ( ) ; if ( loggedin [ 0 ] . equals ( "true" ) ) { Sales sales = new Sales ( loggedin ) ; sales . pack ( ) ; sales . setVisible ( true ) ; this . setVisible ( false ) ; } } catch ( SQLException ex ) { Logger . getLogger ( LOGIN . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { if ( textUser . getText ( ) . isEmpty ( ) ) { textUser . setBackground ( Color . red ) ; } if ( textPassword . getText ( ) . isEmpty ( ) ) { textPassword . setBackground ( Color . red ) ; } } }
tr	D	public static void GA_JailThrowDice ( ) { if ( JailDiceTries < 3 ) { Player player = players . get ( currentPlayer ) ; dices [ 0 ] . throw ( ) ; dices [ 1 ] . throw ( ) ; if ( dices [ 0 ] . number == dices [ 1 ] . number ) { player . InPrison = false ; player . PrisonTurns = 0 ; player . ChangePosition ( ( dices [ 0 ] . number + dices [ 1 ] . number ) ) ; Game . fields . get ( player . Position ) . Lands ( player ) ; gameboard . showJailFreeCardBtn = false ; gameboard . showJailPayBailBtn = false ; gameboard . showJailThrowDiceBtn = false ; gameboard . showMortgageBtn = false ; gameboard . showNextPlayerBtn = true ; gameboard . showThrowDiceBtn = false ; gameboard . refreshGameControl ( ) ; } else { JailDiceTries ++ ; } } else { } }
tr	D	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp = b ; b = c ; c = temp ; } else { double [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { double [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp ; temp = b ; b = a ; a = temp ; } else { double [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	C	@ Override public void update ( ) { setAngle ( owner . getAngle ( ) ) ; super . update ( ) ; double theta = Math . toRadians ( getAngle ( ) ) ; setX ( owner . getX ( ) + ( 5 * ( float ) Math . sin ( - theta ) ) ) ; setY ( owner . getY ( ) + ( 5 * ( float ) Math . cos ( - theta ) ) ) ; setX ( getX ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . cos ( theta ) ) ) ; setY ( getY ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . sin ( theta ) ) ) ; remainShootDelayFrame -- ; }
tr	C	public QueryProcess ( ) throws FileNotFoundException { Query query = readQuery ( ) ; queryVar = query . getQueryVar ( ) ; conditions = query . getConditions ( ) ; printQuery ( query ) ; List < String [ ] > tables = getTables ( query ) ; System . out . println ( "-----" ) ; System . out . println ( "Printing tables in QueryProcess..." ) ; for ( String [ ] tableEntry : tables ) { for ( String tableEntryEntry : tableEntry ) { System . out . println ( tableEntryEntry ) ; } } if ( checkConditions ( tables . get ( 0 ) ) ) { System . out . println ( "true" ) ; } else { System . out . println ( "false" ) ; } }
tr	E	private JTabbedPane createShipMenu ( ) { JTabbedPane menu = new JTabbedPane ( ) ; JComponent panel1 = makeShipSliderMenu ( ) ; menu . addTab ( "Ship Adjustments" , null , panel1 , "Adjust Ship Specs" ) ; menu . setMnemonicAt ( 0 , KeyEvent . VK_1 ) ; JComponent panel2 = makeTextPanel ( "Panel #2" ) ; menu . addTab ( "Tab 2" , null , panel2 , "Does twice as much nothing" ) ; menu . setMnemonicAt ( 1 , KeyEvent . VK_2 ) ; JComponent panel3 = makeTextPanel ( "Panel #3" ) ; menu . addTab ( "Tab 3" , null , panel3 , "Still does nothing" ) ; menu . setMnemonicAt ( 2 , KeyEvent . VK_3 ) ; JComponent panel4 = makeTextPanel ( "Panel #4 (has a preferred size of 410 x 50)." ) ; panel4 . setPreferredSize ( new Dimension ( 200 , 100 ) ) ; menu . addTab ( "Tab 4" , null , panel4 , "Does nothing at all" ) ; menu . setMnemonicAt ( 3 , KeyEvent . VK_4 ) ; Border border = BorderFactory . createLineBorder ( Color . black ) ; menu . setBorder ( border ) ; menu . setVisible ( false ) ; menu . setSize ( menu . getPreferredSize ( ) ) ; menu . setDoubleBuffered ( true ) ; return menu ; }
tr	C	HelloActionWorld2 ( ) { super ( "Hello Action" ) ; final JLabel label ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = new JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ActionListener ( ) { private int count = 0 ; public void actionPerformed ( ActionEvent e ) { count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; } } ) ; setSize ( 320 , 240 ) ; }
tr	E	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn == null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	A	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	D	public void batchUpdate ( final List < RecordSiteStatModel > recordSiteStatModelList ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? WHERE id = ?" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; ps . setLong ( 8 , model . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return recordSiteStatModelList . size ( ) ; } } ) ; }
tr	D	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
tr	E	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	A	public Object getObject ( String astr ) { int idx = getIndex ( astr ) ; if ( idx < 0 ) return ( null ) ; return ( getItem ( idx ) ) ; }
tr	C	public String buildTiterStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildTiterStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	D	public void initialize ( ) { world = new Geometry ( H , W ) ; ballBearing = new Geometry ( H , W ) ; | = new Geometry ( H , W ) ; zbuffer = new double [ pix . length ] ; for ( int i = 0 ; i < pix . length ; i ++ ) zbuffer [ i ] = - 10 ; ballBearing . Makesphere ( 25 , 25 ) ; | . MakeCylinder ( 25 , 25 ) ; ; allShapes . add ( ballBearing ) ; allShapes . add ( | ) ; world . add ( ballBearing ) ; ballBearing . add ( | ) ; for ( Geometry shapes : allShapes ) { shapes . makeTriangles ( ) ; shapes . trapazoids = new ArrayList < double [ ] [ ] > ( shapes . triangles . size ( ) * 2 ) ; for ( int i = 0 ; i < shapes . triangles . size ( ) * 2 ; i ++ ) { shapes . trapazoids . add ( new double [ 4 ] [ 6 ] ) ; } } }
tr	B	public EDFShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTexture ( new TextureLoader ( ) . loadTexture ( TEXTURE_PATH ) ) ; setColor ( new Color ( 0f , 0.8f , 1f ) ) ; setY ( ELEVATION ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setElevation ( ELEVATION ) ; }
tr	E	public static boolean line_box_xywh ( double lx0 , double ly0 , double lx1 , double ly1 , double rx0 , double ry0 , double rWidth , double rHeight ) { int out1 , out2 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rWidth , rHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rWidth , rHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { double x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { double y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
tr	B	public void damageUpdate ( ) { if ( ! damaging ) { return ; } dmgVibMove *= 0.95f ; dmgVibThita += 1 ; setX ( getPixcelX ( ) + dmgVibMove * ( float ) sin ( dmgVibThita ) ) ; if ( dmgVibMove < 0.5 ) { damaging = false ; } }
tr	B	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	D	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && c <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( i != 0 && ( ! exp || s . charAt ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
tr	C	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	E	public static String showLine ( int nbLigne , Line xmlline ) { String returnValue = "Ligne(" + nbLigne + ") :" + System . lineSeparator ( ) ; for ( Field field : xmlline . getFields ( ) ) { try { switch ( field . getDiscriminator ( ) ) { case POSITION : returnValue += ( "  " + field . getName ( ) + "(" + field . getPosition ( ) . getStartposition ( ) + "  " + field . getPosition ( ) . getSize ( ) + ") = \"" ) ; returnValue += field . getBuffer ( ) ; returnValue += ( "\"" + System . lineSeparator ( ) ) ; break ; case CONSTANTE : returnValue += ( "  " + field . getName ( ) + "(cste) = \"" ) ; returnValue += field . getConstante ( ) . getValue ( ) ; returnValue += ( "\"" + System . lineSeparator ( ) ) ; break ; case QUERY : returnValue += ( "  " + field . getName ( ) + "(query) = \"" ) ; returnValue += field . getQuery ( ) . getSql ( ) ; returnValue += ( "\"" + System . lineSeparator ( ) ) ; break ; } } catch ( Exception exinternal ) { returnValue += ( "  " + field . getName ( ) + " (unkown error)" + System . lineSeparator ( ) ) ; } } return returnValue ; }
tr	D	public long persist ( ) throws IOException { if ( wrapped == null ) { return - 1 ; } long bytesWritten = 0 ; RandomAccessFile writer = new RandomAccessFile ( store , "rw" ) ; writer . setLength ( 0 ) ; writer . writeInt ( wrapped . getKeys ( ) . length ) ; bytesWritten += 4 ; writer . writeInt ( wrapped . size ( ) ) ; bytesWritten += 4 ; String currentKey ; for ( int i = 0 ; i < wrapped . getKeys ( ) . length ; i ++ ) { currentKey = wrapped . getKeys ( ) [ i ] ; if ( currentKey == null || ArrayHashMap . Tombstone . equals ( currentKey ) ) continue ; writer . writeInt ( currentKey . length ( ) ) ; bytesWritten += 4 ; writer . writeChars ( currentKey ) ; bytesWritten += currentKey . length ( ) * 2 ; writer . writeLong ( wrapped . getValues ( ) [ i ] ) ; bytesWritten += 8 ; } wrapped = null ; writer . close ( ) ; return bytesWritten ; }
tr	B	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	A	public ScreenShotCharacter ( ) { setTexture ( new TextureLoader ( ) . getScreenShot ( ) ) ; setWidth ( WIDTH ) ; setHeight ( HEIGHT ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; }
tr	E	public synchronized String getRawData ( ) throws IOException { byte [ ] input ; if ( m_connected ) { m_os . write ( G ) ; System . out . println ( "Requested Data" ) ; if ( m_is . available ( ) <= bufferSize ) { input = new byte [ m_is . available ( ) ] ; m_receivedData = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receivedData [ i ] = input [ i ] ; } } else { System . out . println ( "PI OVERFLOW" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawData = "" ; System . out . println ( "Raw Data: " + m_receivedData . length ) ; for ( int i = 0 ; i < m_receivedData . length ; i ++ ) { m_rawData += ( char ) m_receivedData [ i ] ; } System . out . println ( m_rawData ) ; return m_rawData ; } else { connect ( ) ; return null ; } }
tr	D	@ Override public void handle ( final ActionEvent e ) { CustomerController customerCtrl = new CustomerController ( ) ; if ( dest != null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; Date current = new Date ( new GregorianCalendar ( ) . getTime ( ) . getTime ( ) ) ; result = customerCtrl . createCustomerWithParameters ( firstNameTf . getText ( ) , lastNameTf . getText ( ) , numberTf . getText ( ) , streetTf . getText ( ) , cityTf . getText ( ) , zipCodeTf . getText ( ) , current ) ; if ( result . equals ( "Creation succeed" ) ) { if ( file != null ) { gridPane . getChildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	B	public void draw ( Graphics g ) { for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { Rain rain = it . next ( ) ; if ( rain . isEnd ( length ) ) { it . remove ( ) ; continue ; } rain . draw ( g , speed , nabiki , length ) ; } }
tr	B	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . acceldate . setTime ( myitem . acceldate . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
tr	C	public MxMemoryTracker ( ) { observers = new LinkedList < MemoryObserver > ( ) ; MemoryPoolMXBean heap = null ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) { if ( pool . getType ( ) == MemoryType . HEAP && pool . isUsageThresholdSupported ( ) ) { heap = pool ; break ; } } if ( heap == null ) { throw new RuntimeException ( "Could not locate a suitable memory pool" ) ; } heap . setUsageThreshold ( ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; System . out . println ( "Gonna put the threshold mark at " + ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; }
tr	C	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 + " kb" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; } } ) ; running . setDaemon ( true ) ; running . start ( ) ; }
tr	B	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
tr	A	public boolean isRoleAdmin ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) ) ; }
tr	C	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	C	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	D	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; char q ; for ( int r = 0 ; r < k ; r ++ ) { String path = input . next ( ) ; int count = 0 , y = 0 , x ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { q = path . charAt ( i ) ; x = 0 ; if ( q == . ) { while ( q != # ) { x ++ ; q = path . charAt ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } System . out . println ( count ) ; } }
tr	E	synchronized public void setSeed ( int [ ] array ) { if ( array . length == 0 ) throw new IllegalArgumentException ( "Array length must be greater than zero" ) ; int i , j , k ; setSeed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( N > array . length ? N : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } if ( j >= array . length ) j = 0 ; } for ( k = N - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } } mt [ 0 ] = 80000000 ; }
tr	A	@ Override protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	C	public void run ( ) { if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	C	public String exportList ( Connection aconn ) { StringBuilder retstr = new StringBuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; retstr . append ( "<TestCaseList xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"TestCaseList.xsd\">\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( idx ) ; CTestItem testitem = new CTestItem ( ) ; testitem . copyItem ( myitem ) ; testitem . dbReadDetail ( aconn ) ; retstr . append ( testitem . exportItem ( ) ) ; } retstr . append ( "</TestCaseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	A	public String getFC1ResultStr ( ) { if ( fc1result == null ) { return ( "" ) ; } return ( fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	E	private Map createMap ( ) { ImageRegistry [ ] skinWrap = { skin } ; super . setPlayerSpawn ( SPAWN_POINT ) ; Map newMap = MapInterpreter . interpretMap ( this , skinWrap , MONSTER_TIER ) ; newMap . setPlayerSpawn ( SPAWN_POINT ) ; Rectangle placement = MONSTER_RECT ; for ( int i = 0 ; i < MONSTER_COUNT ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( this . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) == false ) { Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( MONSTER_TIER ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } } Point tempPt = TELEPORT_ITEM_POINT ; newMap . getTile ( tempPt . x , tempPt . y ) . addItem ( Controller . getInstance ( ) . creator . createArmour ( "personal teleport" ) ) ; return newMap ; }
tr	C	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	E	public void render ( Graphics2D context ) { Color color = context . getColor ( ) ; Stroke stroke = context . getStroke ( ) ; if ( this . isClicked ( ) ) { context . setColor ( this . clickedColor ) ; } else if ( this . isHighlighted ( ) ) { context . setColor ( this . highlightColor ) ; } else { context . setColor ( this . color ) ; } context . setStroke ( new BasicStroke ( this . getBorderSize ( ) ) ) ; context . drawRect ( this . getX ( ) + this . getBorderSize ( ) / 2 , this . getY ( ) + this . getBorderSize ( ) / 2 , this . getWidth ( ) - this . getBorderSize ( ) , this . getHeight ( ) - this . getBorderSize ( ) ) ; context . setColor ( this . color ) ; this . label . verticalAlignCenter ( this . getX ( ) , this . getX ( ) + this . getWidth ( ) ) ; this . label . horizontalAlignCenter ( this . getY ( ) - 8 , this . getY ( ) + this . getHeight ( ) ) ; this . label . render ( context ) ; context . setColor ( color ) ; context . setStroke ( stroke ) ; }
tr	B	public CEvalItem ( ) { evalid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = "" ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; }
tr	C	@ Override public synchronized long get ( String key ) { WrappedString toGet = new WrappedString ( key ) ; strategy . hit ( toGet ) ; ArrayHashMapOption temp = store . get ( toGet ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for get() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long toReturn = temp . getValue ( ) . get ( key ) ; return toReturn ; }
tr	C	@ Override public synchronized long remove ( String key ) { WrappedString toRemove = new WrappedString ( key ) ; strategy . remove ( toRemove ) ; ArrayHashMapOption temp = store . get ( toRemove ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } size -= temp . getValue ( ) . size ( ) ; long toReturn = temp . getValue ( ) . remove ( key ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	C	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
tr	B	public String unmapCode ( String aval ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CMapItem myitem = ( CMapItem ) this . getItem ( idx ) ; if ( myitem . mapval . equals ( aval ) ) return ( myitem . codeval ) ; } return ( CAppConsts . TagNoValue ) ; }
tr	C	public void copyItem ( CEvalItem aitem ) { evalid = aitem . evalid ; seriescd = aitem . seriescd ; resultcd = aitem . resultcd ; doseord = aitem . doseord ; acceldate . setTime ( aitem . acceldate . getTime ( ) ) ; recomdate . setTime ( aitem . recomdate . getTime ( ) ) ; overduedate . setTime ( aitem . overduedate . getTime ( ) ) ; if ( resultcd . equals ( CAppConsts . ResComplete ) || resultcd . equals ( CAppConsts . ResImmune ) ) { doseord = 0 ; acceldate . setTime ( 0 ) ; recomdate . setTime ( 0 ) ; overduedate . setTime ( 0 ) ; } }
tr	B	public BallGravity ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; Random rnd = new Random ( ) ; this . color = new Color ( rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) ) ; }
tr	A	public static String postpadStr ( String astr , String apad , int alen ) { String rstr = astr ; while ( rstr . length ( ) < alen ) rstr = rstr + apad ; return ( rstr ) ; }
tr	B	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	E	public static boolean line_circle ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fSQ = f * f ; double gSQ = g * g ; double fgSQ = fSQ + gSQ ; double rSQ = r * r ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double xc1 = cx - x1 ; double yc1 = cy - y1 ; boolean lineInside = xc0 * xc0 + yc0 * yc0 < rSQ && xc1 * xc1 + yc1 * yc1 < rSQ ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgSQ - fygx * fygx ; if ( root > ACCY && ! lineInside ) { double fxgy = f * xc0 + g * yc0 ; double t = fxgy / fgSQ ; if ( t >= 0 && t <= 1 ) return true ; if ( ( xc0 * xc0 + yc0 * yc0 < rSQ ) || ( xc1 * xc1 + yc1 * yc1 < rSQ ) ) return true ; } return false ; }
tr	B	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . doFinal ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return null ; } }
tr	C	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; int , = query . indexOf ( "|" ) ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { String pair = query . substring ( , + 1 , nextComma ) ; addToMap ( pair ) ; , = nextComma ; } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
tr	A	public String getFC2RunDtStr ( ) { if ( fc2rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	C	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	D	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( true ) ; textField1 . setEnabled ( true ) ; textField2 . setEditable ( true ) ; textField2 . setEnabled ( true ) ; textField3 . setEditable ( true ) ; textField3 . setEnabled ( true ) ; textField4 . setEditable ( true ) ; textField4 . setEnabled ( true ) ; jComboBox1 . setEnabled ( true ) ; jComboBox2 . setEnabled ( true ) ; textField1 . setText ( "" ) ; textField2 . setText ( "" ) ; textField3 . setText ( "" ) ; textField4 . setText ( "" ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( false ) ; jButton1 . setVisible ( false ) ; jButton2 . setVisible ( false ) ; jButton3 . setVisible ( false ) ; Cancel . setVisible ( true ) ; buttonSaveAdd . setVisible ( true ) ; }
tr	D	private void initMenu ( ) { JPanel titlePanel = new JPanel ( ) ; this . add ( titlePanel ) ; JLabel title = new JLabel ( "Card Counting Training" ) ; titlePanel . add ( title ) ; JPanel inputPanel = new JPanel ( ) ; this . add ( inputPanel ) ; input = new JTextField ( 2 ) ; input . setText ( "6" ) ; inputPanel . add ( input ) ; JPanel startPanel = new JPanel ( ) ; this . add ( startPanel ) ; JButton startBtn = new JButton ( "START" ) ; getRootPane ( ) . setDefaultButton ( startBtn ) ; startPanel . add ( startBtn ) ; startBtn . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { game . runGame ( byte . parseByte ( input . getText ( ) ) ) ; } catch ( Exception ex ) { game . runGame ( ( byte ) 6 ) ; } finally { initGameForm ( ) ; } } } ) ; this . pack ( ) ; setInTheMiddle ( ) ; }
tr	B	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
tr	A	@ Override public void update ( ) { super . update ( ) ; remainRange -= sqrt ( pow ( getVX ( ) , 2 ) + pow ( getVY ( ) , 2 ) ) ; if ( remainRange <= 0 ) { setDispose ( ) ; } }
tr	D	@ Override public boolean put ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value . longValue ( ) ) { return false ; } else { values [ offset ] = value . longValue ( ) ; return true ; } } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; checkResize ( reprobes ) ; return true ; }
tr	D	@ Override public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { String sql = "INSERT INTO articlestat (uniquevisitor  pageview  visit  date  articleid  articletitle  " + "articleurl  site_id) VALUES (?  ?  ?  ?  ?  ?  ?  ?)" ; PreparedStatement ps = con . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; return ps ; }
tr	E	public static void main ( String [ ] args ) { List < Pattern > results = null ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
tr	B	public DotTestCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "dotTokiIcon.png" ) ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; setColor ( Color . red ) ; }
tr	C	public static void main ( String [ ] args ) { GuiLife gui = new GuiLife ( ) ; try { String url = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/life.txt" ; List < Pattern > list = PatternLoader . loadFromURL ( url ) ; gui . patternPanel . setPatterns ( list ) ; World w = gui . controlPanel . initialiseWorld ( list . get ( 1 ) ) ; gui . gamePanel . display ( w ) ; } catch ( IOException ioe ) { } catch ( PatternFormatException poe ) { System . out . println ( poe . getMessage ( ) ) ; } gui . setVisible ( true ) ; }
tr	C	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
tr	B	public CParseXml ( ) { super ( ) ; curstr = "" ; testcaselist = new CTestList ( ) ; testcaseitem = new CTestItem ( ) ; shotitem = new CShotItem ( ) ; nonaditem = new CNonadItem ( ) ; expresitem = new CTextItem ( ) ; expdoseitem = new CDoseItem ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	C	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
tr	E	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	A	private static String left ( Date date , int length ) { if ( date == null ) { return left ( "" , length ) ; } return left ( sdf . format ( date ) , length ) ; }
tr	E	public void handle ( MouseEvent me ) { Timeline timeline = new Timeline ( ) ; if ( isResized ) { timeline . setAutoReverse ( true ) ; timeline . getKeyFrames ( ) . addAll ( new KeyFrame ( Duration . ZERO , new KeyValue ( lateral . translateXProperty ( ) , 0 ) ) , new KeyFrame ( new Duration ( 5 ) , new KeyValue ( lateral . translateXProperty ( ) , 0 ) ) ) ; timeline . playFromStart ( ) ; isResized = false ; } else { timeline . getKeyFrames ( ) . addAll ( new KeyFrame ( Duration . ZERO , new KeyValue ( lateral . translateXProperty ( ) , 0 ) ) , new KeyFrame ( new Duration ( 5 ) , new KeyValue ( lateral . translateXProperty ( ) , 0 ) ) ) ; timeline . playFromStart ( ) ; isResized = true ; } timeline . setOnFinished ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { if ( isResized ) { System . out . println ( "here" ) ; vBox . setVisible ( false ) ; vBox . setPrefWidth ( 0 ) ; } else { vBox . setVisible ( true ) ; vBox . setPrefWidth ( 150 ) ; } } } ) ; }
tr	A	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	B	public EDFEnemy ( ShootingScene parentScene , float bornAngle , LR lr ) { super ( parentScene , POWER , HP ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setElevation ( WIDTH / 2 ) ; setVElevation ( - FALL_SPEED ) ; setAngle ( bornAngle ) ; setVAngle ( ROTATE_SPEED * lr . signum ( ) ) ; setTexture ( TEXTURE ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setColor ( Color . orange ) ; }
tr	E	Move rootAlphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL3 count:" + count ) ; count = 0 ; if ( bestMove == null ) { if ( depth <= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
tr	D	public static void main ( String [ ] args ) { Sample ex = new Sample ( ) ; Connection conn = null ; try { ex . init ( ) ; ex . testSQL ( ) ; ex . testSubSQL ( ) ; conn = ex . getConnection ( ) ; ex . deleteAll ( conn ) ; ex . select ( conn ) ; ex . insertIfEmpty ( conn ) ; ex . select ( conn ) ; ex . basicSelect ( conn ) ; ex . list ( conn ) ; ex . select ( conn ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "me" , 1 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 1000 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 2 ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; } QueryUtil . closeConnection ( conn ) ; }
tr	D	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	E	public static Weapon createWeaponFromReader ( String weaponString ) { String [ ] values = weaponString . split ( " " ) ; Weapon weapon = new Weapon ( ) ; try { weapon . setName ( values [ 0 ] ) ; weapon . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; weapon . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; weapon . setMinDamage ( Integer . parseInt ( values [ 3 ] ) ) ; weapon . setMaxDamage ( Integer . parseInt ( values [ 4 ] ) ) ; weapon . setDamageMsg ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; weapon = Weapon . applySpecialTraits ( weapon , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading weapon object" ) ; if ( weapon . getName ( ) != null ) System . out . println ( weapon . getName ( ) + " has some incorrect parameter." ) ; return null ; } return weapon ; }
tr	B	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<NonAdminItem>\n" ) ; retstr . append ( "<NonadmDate>" + dtfmt . format ( nonadmdate ) + "</NonadmDate>\n" ) ; retstr . append ( "<AntSeriesCd>" + seriescd + "</AntSeriesCd>\n" ) ; retstr . append ( "<ReasonCd>" + reasoncd + "</ReasonCd>\n" ) ; retstr . append ( "</NonAdminItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	D	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	D	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { image = new TextureLoader ( ) . createImageData ( width , height ) ; g = image . createGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , height - 3 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	E	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
tr	D	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
tr	D	int binarySearchRotated ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( A [ start ] <= A [ mid ] ) { if ( target >= A [ start ] && target < A [ mid ] ) return binarySearch ( A , target , start , mid - 1 ) ; else return binarySearchRotated ( A , target , mid + 1 , end ) ; } else { if ( target > A [ mid ] && target <= A [ end ] ) return binarySearch ( A , target , mid + 1 , end ) ; else return binarySearchRotated ( A , target , start , mid - 1 ) ; } }
tr	E	public static Food createFoodFromReader ( String foodString ) { String [ ] values = foodString . split ( " " ) ; Food food = new Food ( ) ; try { food . setName ( values [ 0 ] ) ; food . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; food . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; food . setNutrition ( Integer . parseInt ( values [ 3 ] ) ) ; food . setTurnsToEat ( Integer . parseInt ( values [ 4 ] ) ) ; food . setEatMessage ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; food = Food . applySpecialTraits ( food , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading food object" ) ; if ( food . getName ( ) != null ) System . out . println ( food . getName ( ) + " has some incorrect parameter." ) ; return null ; } return food ; }
tr	A	public void close ( ) throws IOException { if ( ! eof ) { while ( read ( buf , 0 , buf . length ) != - 1 ) ; } }
tr	C	@ Test public void testRemove ( ) { ReplacementStrategy < String > strategy = new LeastRecentlyUsed < String > ( ) ; strategy . remove ( "foo" ) ; strategy . hit ( "foo" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . remove ( "foo" ) ; strategy . evict ( "foo" ) ; assertNull ( strategy . suggest ( ) ) ; strategy . hit ( "bar" ) ; strategy . hit ( "bar2" ) ; strategy . remove ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; strategy . evict ( "bar" ) ; strategy . remove ( "bar" ) ; assertEquals ( "bar2" , strategy . suggest ( ) ) ; }
tr	B	public void draw ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Composite curComp = g2 . getComposite ( ) ; g2 . setComposite ( composite ) ; g2 . setColor ( color ) ; g2 . fillOval ( ( int ) x , ( int ) y , size , size ) ; g2 . setComposite ( curComp ) ; }
tr	B	public String buildShotStr ( int achild , int ashot ) { String shotstr = "line~" + Integer . toString ( ashot ) + "^" + "shot_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "shot_dt~" + getYmdStr ( ) + "^" + "vaccine_cd~" + vaccinecd + "^" + "mfr_cd~" + mfrcd + "^" ; return ( shotstr ) ; }
tr	D	public void drawMyFigure ( Graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawLine ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
tr	E	@ Override public void init ( final Shell splash ) { super . init ( splash ) ; Activator . setSplashHandler ( this ) ; String progressRectString = null ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product != null ) { progressRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; messageRectString = product . getProperty ( IProductConstants . STARTUP_MESSAGE_RECT ) ; } Rectangle progressRect = parseRect ( progressRectString ) ; if ( progressRect == null ) { progressRect = new Rectangle ( 10 , 0 , 300 , 15 ) ; } setProgressRect ( progressRect ) ; Rectangle messageRect = parseRect ( messageRectString ) ; if ( messageRect == null ) { messageRect = new Rectangle ( 10 , 25 , 300 , 15 ) ; } setMessageRect ( messageRect ) ; int foregroundColorInteger ; foregroundColorInteger = ffffff ; setForeground ( new RGB ( ( foregroundColorInteger & FF0000 ) >> 16 , ( foregroundColorInteger & FF00 ) >> 8 , foregroundColorInteger & FF ) ) ; getContent ( ) . addPaintListener ( new PaintListener ( ) { public void paintControl ( final PaintEvent e ) { onPaint ( e ) ; } } ) ; }
tr	A	public ShootingObjectImpl ( ShootingScene scene , float power ) { this . parentScene = scene ; this . power = power ; this . undead = true ; }
tr	E	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = rset . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
tr	A	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; setTexture ( null ) ; } }
tr	D	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	C	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	A	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	B	public void move ( ) { if ( Key . UP . isPressing ( ) ) vy -= accele ; if ( Key . DOWN . isPressing ( ) ) vy += accele ; if ( Key . LEFT . isPressing ( ) ) vx -= accele ; if ( Key . RIGHT . isPressing ( ) ) vx += accele ; super . move ( ) ; }
tr	E	public void render ( Graphics2D context ) { Font contextFont = context . getFont ( ) ; context . setColor ( this . textColor ) ; if ( Os . isWindows ( ) ) { this . setText ( this . getText ( ) . replace ( "\u00E4" , "ae" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00FC" , "ue" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00F6" , "oe" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00DF" , "ss" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00C4" , "Ae" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00DC" , "Ue" ) ) ; this . setText ( this . getText ( ) . replace ( "\u00D6" , "Oe" ) ) ; } context . setFont ( this . getFont ( ) ) ; context . drawString ( this . text , this . getX ( ) , this . getY ( ) ) ; context . setFont ( contextFont ) ; }
tr	E	public String createSQL ( ) throws SQLException { String returnValue = "select " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( first ) { first = false ; returnValue += field . getName ( ) ; } else { returnValue += ( "  " + field . getName ( ) ) ; } } returnValue += ( " from " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) ) ; if ( first ) { LOGGER . severe ( "Error no field" ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } return returnValue ; }
tr	C	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	C	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	B	private void processRightMove ( ) { if ( ! RIGHT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( - DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) - ROTATE_SPEED ) ; }
tr	D	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	D	private CallResultInternal sendPost ( URL url , String encodedCall ) throws IOException { HttpURLConnection httpcon = ( HttpURLConnection ) url . openConnection ( ) ; httpcon . setDoOutput ( true ) ; httpcon . setRequestProperty ( "Content-Type" , encoder . contentType ( ) ) ; httpcon . setRequestProperty ( "Accept" , encoder . contentType ( ) ) ; httpcon . setRequestMethod ( "POST" ) ; final OutputStreamWriter osw = new OutputStreamWriter ( httpcon . getOutputStream ( ) , encoder . charset ( ) ) ; osw . write ( encodedCall ) ; osw . close ( ) ; int responseCode = httpcon . getResponseCode ( ) ; if ( HttpStatus . isClientError ( responseCode ) || HttpStatus . isServerError ( responseCode ) ) { return new CallResultInternal ( responseCode , readString ( httpcon . getErrorStream ( ) ) ) ; } return new CallResultInternal ( CallResultInternal . NO_ERROR , readString ( httpcon . getInputStream ( ) ) ) ; }
tr	B	public String buildShotStr ( int achild ) { String shotstr = "" ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; shotstr = shotstr + shot . buildShotStr ( achild , shotnum ) ; shotnum ++ ; } return ( shotstr ) ; }
tr	C	@ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	E	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	C	protected void resize ( ) { inResize = true ; String [ ] oldKeys = keys ; long [ ] oldValues = values ; keys = new String [ oldKeys . length * 2 ] ; values = new long [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ++ ) { String key = oldKeys [ i ] ; if ( key == null || key == Tombstone ) { continue ; } put ( key , oldValues [ i ] ) ; } inResize = false ; }
tr	B	public String getStatusStyle ( String astatus ) { if ( CAppConsts . StatusPass . equals ( astatus ) ) { return ( CAppConsts . StylePass ) ; } if ( CAppConsts . StatusFail . equals ( astatus ) ) { return ( CAppConsts . StyleFail ) ; } return ( CAppConsts . StyleNone ) ; }
tr	C	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame == null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , gs ) ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
tr	D	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp = b ; b = c ; c = temp ; } else { int [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { int [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp ; temp = b ; b = a ; a = temp ; } else { int [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	B	public BasicBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter , BULLET_POWER ) ; setColor ( Color . white ) ; double theta = Math . toRadians ( - getShooter ( ) . getAngle ( ) ) ; setVx ( SPEED * ( float ) Math . sin ( theta ) ) ; setVy ( SPEED * ( float ) Math . cos ( theta ) ) ; setVAngle ( 12 ) ; }
tr	B	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
tr	B	@ Override public void update ( ) { frame ++ ; for ( Iterator < SpawnData > ite = spawns . iterator ( ) ; ite . hasNext ( ) ; ) { SpawnData data = ite . next ( ) ; if ( data . canSpawn ( frame ) ) { doSpawn ( data ) ; ite . remove ( ) ; } } }
tr	C	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	B	@ Override public void inputProcess ( ) { if ( Key . UP . isPressing ( ) ) { flowerBornPerSecond = min ( flowerBornPerSecond + 1 , MAX_FLOWERS_PER_SECOND ) ; } if ( Key . DOWN . isPressing ( ) ) { flowerBornPerSecond = max ( flowerBornPerSecond - 1 , MIN_FLOWERS_PER_SECOND ) ; } if ( Key . LEFT . isPressed ( ) ) { maxWind -= V_WIND ; } if ( Key . RIGHT . isPressed ( ) ) { maxWind += V_WIND ; } }
tr	D	public void MakeSquare ( ) { double vertices [ ] [ ] = { { 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , - 1 , 1 , 0 , 0 , 1 } , { 1 , - 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , 1 , - 1 , 0 , 0 , - 1 } , { 1 , - 1 , - 1 , 0 , 0 , - 1 } , { - 1 , - 1 , - 1 , 0 , 0 , - 1 } , } ; int faces [ ] [ ] = { { 0 , 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	A	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	C	public void move ( ) { x += vx ; y += vy ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; pong . play ( ) ; if ( x < 0 ) x = - x ; if ( x + size > WIDTH ) x -= x + size - WIDTH ; } if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; pong . play ( ) ; if ( y < 0 ) y = - y ; if ( y + size > HEIGHT ) y -= y + size - HEIGHT ; } }
tr	C	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon != null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
tr	D	public static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin . start ( ) ; LOG . log ( Level . INFO , "adding plugin {0}!" , plugin . getName ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no plugins were found!!" ) ; } } catch ( ServiceConfigurationError | Exception e ) { LOG . log ( Level . SEVERE , "service configuration error {0}" , e . toString ( ) ) ; } return result ; }
tr	B	public void dbReadDetail ( Connection aconn ) { shotlist . dbReadList ( aconn , testgroupid , testid ) ; nonadmlist . dbReadList ( aconn , testgroupid , testid ) ; ereslist . dbReadList ( aconn , testgroupid , testid ) ; edoselist . dbReadList ( aconn , testgroupid , testid ) ; evallist . dbReadList ( aconn , testgroupid , testid ) ; dosevlist . dbReadList ( aconn , testgroupid , testid ) ; }
tr	E	public CTestItem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new Date ( 0 ) ; birthdate = new Date ( birthdate . getTime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new Date ( ) ; moddate = new Date ( ) ; basedate = new Date ( ) ; testresult = CAppConsts . StatusNone ; resultnotes = "" ; fc1 = "" ; fc1result = CAppConsts . StatusNone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = CAppConsts . StatusNone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new CShotList ( ) ; nonadmlist = new CNonadList ( ) ; ereslist = new CTextList ( ) ; edoselist = new CDoseList ( ) ; evallist = new CEvalList ( ) ; dosevlist = new CDosevList ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	E	public String toString ( ) { String str = "\u5BAB\u5E72:" + getGongGan ( ) + "\n" + "\u5BAB\u652F:" + getGongZhi ( ) + "\n" + "\u5341\u4E8C\u5BAB:" + shiErGong + "\n" + "\u5927\u9650\u5341\u4E8C\u5BAB:" + daYunShiErGong + "\n" + "\u5927\u9650:" + startDaXian + "-" + endDaXian + "\n" + "\u6B63\u66DC:" ; for ( int i = 0 ; i < zhengYaoList . size ( ) ; i ++ ) { str += zhengYaoList . get ( i ) + " " ; } str += "\n\u8F85\u66DC:" ; for ( int i = 0 ; i < fuYaoList . size ( ) ; i ++ ) { str += fuYaoList . get ( i ) + " " ; } str += "\n\u6742\u66DC:" ; for ( int i = 0 ; i < zaYaoList . size ( ) ; i ++ ) { str += zaYaoList . get ( i ) + " " ; } str += "\n\u957F\u751F\u5341\u4E8C\u795E:" + changShengShen + "\n" + "\u535A\u58EB\u5341\u4E8C\u795E:" + boShiShen + "\n" + "\u592A\u5C81\u5341\u4E8C\u795E:" + taiSuiShen + "\n" ; str += "\u8FD0\u66DC:" ; for ( int i = 0 ; i < yunYaoList . size ( ) ; i ++ ) { str += yunYaoList . get ( i ) + " " ; } str += "\n" ; return str ; }
tr	C	public String getTestStatus ( ) { String mystat = CAppConsts . StatusNone ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( CAppConsts . StatusFail . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusFail ) ; } else if ( CAppConsts . StatusNone . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusNone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	D	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	A	public TextCharacter ( String text , FontDef fontDef ) { this . fontDef = fontDef ; updateText ( text ) ; }
tr	A	@ Override public float damage ( float damage ) { if ( undead ) { return float . MAX_VALUE ; } hp -= damage ; if ( hp < 0 ) { hp = 0 ; } return hp ; }
tr	D	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	B	public EDFEnemy spawnTo ( ShootingScene parentScene ) { try { return enemyClass . getConstructor ( ShootingScene . class , float . class , LR . class ) . newInstance ( parentScene , angle , rotateLR ) ; } catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { System . err . println ( "\u30A8\u30E9\u30FC\uFF1A\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u547C\u3073\u51FA\u305B\u307E\u305B\u3093" ) ; e . printStackTrace ( ) ; } return null ; }
tr	E	private int miniMax ( NodeLVL6 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	C	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	E	public boolean TraceMyRay ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . MAX_VALUE ; index = - 1 ; for ( int m = 0 ; m < allSphere . length ; m ++ ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allSphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / Math . sqrt ( allSphere [ index ] . radius ) ; } PhongLightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distVV ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	D	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	D	public void drawMyFigure ( Graphics g , int w , int h , Matrix m ) { this . w = w ; this . h = h ; for ( int f = 0 ; f < faces . length ; f ++ ) { for ( int f2 = 0 ; f2 < faces [ f ] . length ; f2 ++ ) { int i = faces [ f ] [ f2 ] ; int j = faces [ f ] [ ( f2 + 1 ) % faces [ f ] . length ] ; m . transform ( vertices [ j ] , point1 ) ; m . transform ( vertices [ i ] , point0 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } } }
tr	B	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
tr	E	public void updateText ( ) { Highlighter . HighlightPainter hpPainter = new DefaultHighlighter . DefaultHighlightPainter ( player . hpColor ( ) ) ; Highlighter . HighlightPainter nutritionPainter = new DefaultHighlighter . DefaultHighlightPainter ( player . hungerColor ( ) ) ; int hpStartMarker = 0 ; int hpEndMarker = 0 ; int nutritionStartMarker = 0 ; int nutritionEndMarker = 0 ; String text = "Player: " ; text += "HP = " ; hpStartMarker = text . length ( ) ; text += player . getCurrentHP ( ) ; hpEndMarker = text . length ( ) ; text += "  Strength = " + player . getStrength ( ) ; text += "  Dexterity = " + player . getDexterity ( ) ; text += "  Armour: " + player . getACBonus ( ) ; text += "  Nutrition = " ; nutritionStartMarker = text . length ( ) ; text += player . hungerText ( ) ; nutritionEndMarker = text . length ( ) ; text += "  XP = " + player . getXP ( ) ; setText ( text ) ; try { this . getHighlighter ( ) . addHighlight ( hpStartMarker , hpEndMarker , hpPainter ) ; this . getHighlighter ( ) . addHighlight ( nutritionStartMarker , nutritionEndMarker , nutritionPainter ) ; } catch ( BadLocationException e ) { } }
tr	A	@ Override public void update ( ) { super . update ( ) ; setElevation ( getElevation ( ) + getvElevation ( ) ) ; }
tr	D	private void buttonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; jComboBox1 . setEnabled ( false ) ; jComboBox2 . setEnabled ( false ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; list1 . removeAll ( ) ; jComboBox1 . removeAllItems ( ) ; try { DbUtil . deleteItem ( textField1 . getText ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	C	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectDoseItem>\n" ) ; retstr . append ( "<SeriesCd>" + seriescd + "</SeriesCd>\n" ) ; retstr . append ( "<ResultCd>" + resultcd + "</ResultCd>\n" ) ; retstr . append ( "<NextDoseNum>" + Integer . toString ( doseord ) + "</NextDoseNum>\n" ) ; retstr . append ( "<AccelDate>" + dtfmt . format ( acceldate ) + "</AccelDate>\n" ) ; retstr . append ( "<RecomDate>" + dtfmt . format ( recomdate ) + "</RecomDate>\n" ) ; retstr . append ( "<OverdueDate>" + dtfmt . format ( overduedate ) + "</OverdueDate>\n" ) ; retstr . append ( "</ExpectDoseItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	D	private void initPreGameMenu ( ) { topPanel = new JPanel ( ) ; this . add ( topPanel ) ; middlePanel = new JPanel ( ) ; this . add ( middlePanel ) ; topPanel . setLayout ( new BoxLayout ( topPanel , BoxLayout . LINE_AXIS ) ) ; middlePanel . setLayout ( new BoxLayout ( middlePanel , BoxLayout . LINE_AXIS ) ) ; timerOption = new JCheckBox ( "Timer" , true ) ; middlePanel . add ( timerOption ) ; acceptButton = new JButton ( "START" ) ; acceptButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { setRules ( ) ; getContentPane ( ) . removeAll ( ) ; initGame ( ) ; } } ) ; topPanel . add ( acceptButton ) ; acceptButton . setHorizontalAlignment ( SwingConstants . RIGHT ) ; this . getRootPane ( ) . setDefaultButton ( acceptButton ) ; this . pack ( ) ; this . setInTheMiddle ( ) ; }
tr	C	@ Override public Object [ ] decode ( String callParametersString , Type [ ] parameterTypes ) { if ( callParametersString . isEmpty ( ) && parameterTypes . length == 0 ) { return new Object [ 0 ] ; } JsonArray parametersArray = jsonParser . parse ( callParametersString ) . getAsJsonArray ( ) ; Object [ ] result = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { result [ i ] = gson . fromJson ( parametersArray . get ( i ) , TypeToken . get ( ( Type ) parameterTypes [ i ] ) . getType ( ) ) ; } return result ; }
tr	C	public EDFEarth ( ShootingScene scene ) { super ( scene , float . MAX_VALUE , 10 ) ; setTexture ( TextTextureMaker . createText ( "\u25CB" , FontDef . RICTY_64 ) ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setVAngle ( JITEN ) ; setColor ( COLOR ) ; hpCaption = new TextCharacter ( getHpText ( ) ) ; hpCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.3f ) . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
tr	D	public static int calcDef ( int row , int col , boolean white , DraughtsState ds ) { int total = 0 ; int topleft = 10 , topright = 10 , bottomleft = 10 , bottomright = 10 ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft ) ; } if ( row > 0 && col < 9 ) { topright = ds . getPiece ( row - 1 , col + 1 ) ; total += addDef ( topright ) ; } if ( row < 9 && col > 0 ) { bottomleft = ds . getPiece ( row + 1 , col - 1 ) ; total += addDef ( bottomleft ) ; } if ( row < 9 && col < 9 ) { bottomright = ds . getPiece ( row + 1 , col + 1 ) ; total += addDef ( bottomright ) ; } return total ; }
tr	B	public EDFMoneyCaption ( EDFScene edfScene ) { super ( getCaption ( edfScene . getMoney ( ) ) ) ; this . scene = edfScene ; setBasePont ( GameCharacterBasePoint . LEFTTOP ) ; setScale ( 0.4f ) ; setX ( 5 ) ; setY ( HEIGHT - 5 ) ; setColor ( Color . orange . brighter ( ) ) ; }
tr	A	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
tr	A	public ShootingObjectImpl ( ShootingScene scene , float power , float hp ) { this . parentScene = scene ; this . power = power ; this . hp = hp ; }
tr	E	public static Vector2D line_line_p ( Vector2D v0 , Vector2D v1 , Vector2D v2 , Vector2D v3 ) { Vector2D intercept = null ; double f1 = ( v1 . x - v0 . x ) ; double g1 = ( v1 . y - v0 . y ) ; double f2 = ( v3 . x - v2 . x ) ; double g2 = ( v3 . y - v2 . y ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( v2 . y - v0 . y ) - g2 * ( v2 . x - v0 . x ) ) / det ; double t = ( f1 * ( v2 . y - v0 . y ) - g1 * ( v2 . x - v0 . x ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) intercept = new Vector2D ( v0 . x + f1 * s , v0 . y + g1 * s ) ; } return intercept ; }
tr	D	private void jButton4ActionPerformed ( java . awt . event . ActionEvent evt ) { try { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "startTime" , jTextField1 . getText ( ) . toString ( ) ) ; map . put ( "endTime" , jTextField2 . getText ( ) . toString ( ) ) ; Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\Tax.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	B	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	C	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	A	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" , "" , "" , "" ) ; }
tr	A	public String getShotDateStr ( ) { if ( shotdate . getTime ( ) == 0 ) return ( "" ) ; return ( mdyfmt . format ( shotdate ) ) ; }
tr	B	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	B	public int getStatusCnt ( String astat ) { int statcnt = 0 ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; if ( myitem . testresult . equals ( astat ) ) { statcnt ++ ; } } return ( statcnt ) ; }
tr	D	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	D	@ Override public boolean putIfAbsent ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	A	public static Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . intVal == intVal ) { return key ; } } return null ; }
tr	A	@ Override public GameCharacterObject setVAlpha ( float vAlpha ) { if ( vAlpha > 1f ) { vAlpha = 1f ; } if ( vAlpha < 0f ) { vAlpha = 0f ; } this . vAlpha = vAlpha ; return this ; }
tr	A	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) == 0 ) { return null ; } else { return releasePoints . remove ( 0 ) ; } }
tr	A	@ Override public void render ( ) { if ( ! isEnable ( ) ) { return ; } draw ( ) ; }
tr	B	public EDFCharacterController ( ) { BackGroundColor . BLACK . set ( ) ; earth = add ( new EDFEarth ( this ) ) ; ship = add ( new EDFShip ( this ) ) ; ship . equipLeft ( new BasicWeapon ( this , ship , LR . LEFT ) ) ; ship . equipRight ( new BasicWeapon ( this , ship , LR . RIGHT ) ) ; }
tr	A	public int read ( byte b [ ] ) throws IOException { return read ( b , 0 , b . length ) ; }
tr	D	public static Node compile ( Node node ) { if ( node instanceof Comment ) { return node ; } else if ( node instanceof PrintBold ) { return new Block ( new Print ( "**" ) , new Block ( new Print ( ( ( PrintBold ) node ) . message ) , new Print ( "**" ) ) ) ; } else if ( node instanceof Print ) { return node ; } else if ( node instanceof Block ) { Block block = ( Block ) node ; boolean fc = block . first instanceof Comment ; boolean sc = block . second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return compile ( block . second ) ; if ( sc ) return compile ( block . first ) ; return new Block ( compile ( block . first ) , compile ( block . second ) ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; return null ; } }
tr	B	public BasicWeapon ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , owner , equipLR ) ; setTexture ( WEAPON_TEXTURE ) ; setHeight ( 20 ) ; setWidth ( 10 ) ; setColor ( Color . white ) ; setTeam ( owner . getTeam ( ) ) ; }
tr	B	private void updateWind ( ) { if ( ( maxWind < 0 && wind < maxWind ) || ( 0 < maxWind && maxWind < wind ) ) { wind += - maxWind / ( FPS * 2 ) ; } else { wind += maxWind / ( FPS * 2 ) ; } }
tr	B	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
tr	B	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	E	protected void fillWallRoom ( Rectangle r ) { for ( int h = r . x ; h <= r . x + r . width - 1 ; h ++ ) { grid [ h ] [ r . y ] = MapTile . WALL_H ; grid [ h ] [ r . y + r . height - 1 ] = MapTile . WALL_H ; } for ( int v = r . y ; v < r . y + r . height - 1 ; v ++ ) { grid [ r . x ] [ v ] = MapTile . WALL_V ; grid [ r . x + r . width - 1 ] [ v ] = MapTile . WALL_V ; } grid [ r . x ] [ r . y ] = MapTile . WALL_TL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y ] = MapTile . WALL_TR_CORNER ; grid [ r . x ] [ r . y + r . height - 1 ] = MapTile . WALL_BL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y + r . height - 1 ] = MapTile . WALL_BR_CORNER ; }
tr	D	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate" + " From TSeriesEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . evalid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; myitem . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; this . addItem ( myitem . evalid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbReadList cannot read list. " , ex ) ; } }
tr	A	UploadedFile ( String aFileDir , String aFileName , String aContType ) { this . fFileDir = aFileDir ; this . fFileName = aFileName ; this . fContType = aContType ; }
tr	D	public static void main ( String [ ] args ) { System . out . println ( DemoCasting2 . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	B	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	A	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	A	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
tr	D	@ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries == 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; }
tr	D	public void projectPoint ( double [ ] xyz , double [ ] pxy ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; double nx = xyz [ 3 ] ; double ny = xyz [ 4 ] ; double nz = xyz [ 5 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; pxy [ 2 ] = ( nx + 1 ) * 255 / 2 ; pxy [ 3 ] = ( ny + 1 ) * 255 / 2 ; pxy [ 4 ] = ( nz + 1 ) * 255 / 2 ; pxy [ 5 ] = ( int ) ( FL * z / ( FL - z ) ) ; }
tr	B	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	C	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	C	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	A	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	B	public GameOverScene ( GameScene gameoverScene ) { add ( new ScreenShotCharacter ( ) ) ; gameoverScene . dispose ( ) ; add ( new TextCharacter ( "-GAME OVER-" ) ) . setX ( CENTER_X ) . setY ( CENTER_Y + 70 ) . setColor ( Color . red ) . setScale ( 0.5f ) ; add ( new TextCharacter ( "press enter to reset" ) ) . setX ( CENTER_X ) . setY ( CENTER_Y + 50 ) . setColor ( Color . red ) . setScale ( 0.3f ) ; }
tr	C	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result != - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result == buf . length ) ; if ( sbuf . length ( ) == 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) ==  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	E	public String getPreviousColumnName ( ) { if ( started == false ) return null ; StringBuilder previousColumnName = new StringBuilder ( ) ; boolean xStart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charAt ( i ) ; if ( xStart ) { try { if ( Characters . isWhiteSpace ( c ) ) { if ( previousColumnName . length ( ) == 0 ) continue ; else break ; } Characters . checkValidName ( c ) ; previousColumnName . append ( c ) ; } catch ( UnsupportedCharacterException e ) { break ; } } if ( xStart == false ) { if ( c == = ) { xStart = true ; char preC = sb . charAt ( i - 1 ) ; if ( preC == > || preC == < || preC == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charAt ( i - 1 ) == < ) { -- i ; xStart = true ; continue ; } } } } if ( previousColumnName . length ( ) == 0 ) return null ; else { previousColumnName . reverse ( ) ; return previousColumnName . toString ( ) ; } }
tr	C	private void checkHit ( ) { List < ShootingObject > soList = new LinkedList < > ( ) ; soList . addAll ( enemieCharas ) ; soList . addAll ( friendlieCharas ) ; soList . addAll ( bullets ) ; for ( int i = 0 ; i < soList . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < soList . size ( ) ; j ++ ) { soList . get ( i ) . checkHitAndAction ( soList . get ( j ) ) ; } } }
tr	A	public CMapCode ( Connection aconn , String atable , String acode , String amap , int atype ) { super ( true ) ; tablenm = atable ; codefld = acode ; mapfld = amap ; maptyp = atype ; dbReadList ( aconn ) ; }
tr	E	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
tr	B	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr . length ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	B	@ Override public boolean checkHitAndAction ( ShootingObject target ) { if ( ! isEnemyForces ( target ) || hittedObjects . contains ( target ) || ! checkHit ( target ) ) { return false ; } hitEffectTo ( target ) ; target . hitEffectTo ( this ) ; return true ; }
tr	C	public static void drawTexture ( final Texture texture , final int width , final int height ) { texture . bind ( ) ; glBegin ( GL_QUADS ) ; texture . point ( texture . getWidth ( ) , 0 ) ; glVertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glVertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getHeight ( ) ) ; glVertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getWidth ( ) , texture . getHeight ( ) ) ; glVertex3f ( width / 2 , - height / 2 , 0 ) ; glEnd ( ) ; }
tr	A	public static String getToken ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( abuf ) ; return ( abuf . substring ( 0 , sep ) ) ; }
tr	D	@ SuppressWarnings ( { "unused" , "resource" } ) public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; BigDecimal N = new BigDecimal ( 8.0 ) ; BigDecimal K = new BigDecimal ( 8.0 ) ; BigDecimal Check = new BigDecimal ( 0.0 ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { N = in . nextBigDecimal ( ) ; K = in . nextBigDecimal ( ) ; try { BigDecimal R [ ] = N . divideAndRemainder ( K ) ; System . out . println ( R [ 0 ] + " " + R [ 1 ] ) ; } catch ( Exception e ) { System . out . println ( "0 " + N ) ; } } }
tr	B	private void updateObjects ( ) { for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; ite . remove ( ) ; friendlieCharas . remove ( go ) ; enemieCharas . remove ( go ) ; bullets . remove ( go ) ; } } }
tr	D	@ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } }
tr	A	public String getFC1RunDtStr ( ) { if ( fc1rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc1rundt ) ) ; }
tr	C	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
tr	C	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( x + width / 2 < 0 || x - width / 2 > WIDTH ) ) { setDispose ( ) ; } y = yMoveMode . move ( HEIGHT , height , y , vy ) ; if ( yMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( y + height / 2 < 0 || y - height / 2 > HEIGHT ) ) { setDispose ( ) ; } }
tr	D	@ Test public void sanityCheck ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "1" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
tr	B	private static void updatePressOrRelease ( ) { while ( Keyboard . next ( ) ) { Key key = Key . valueOf ( Keyboard . getEventKey ( ) ) ; if ( key == null ) { continue ; } if ( Keyboard . getEventKeyState ( ) ) { key . state = STATE_PRESSED ; } else { key . state = STATE_RELEASED ; } } }
tr	C	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	A	@ Override public void render ( ) { for ( GameObject go : gameObjects ) { go . render ( ) ; } }
tr	E	private int miniMax ( NodeLVL7 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	A	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { return p + vp ; }
tr	C	@ Override public boolean putIfAbsent ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	A	@ Override public void dispose ( ) { addBookingObjects ( ) ; for ( GameObject go : gameObjects ) { go . dispose ( ) ; } }
tr	A	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; }
tr	E	public static String [ ] [ ] loadItems ( ) throws SQLException { ResultSet rsItems ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from products" ; rsItems = conn . createStatement ( ) . executeQuery ( sql ) ; rsItems . last ( ) ; String items [ ] [ ] = new String [ rsItems . getRow ( ) ] [ 6 ] ; rsItems . beforeFirst ( ) ; while ( rsItems . next ( ) ) { items [ rsItems . getRow ( ) - 1 ] [ 0 ] = rsItems . getString ( "barcode" ) ; items [ rsItems . getRow ( ) - 1 ] [ 1 ] = rsItems . getString ( "product_Name" ) ; items [ rsItems . getRow ( ) - 1 ] [ 2 ] = rsItems . getString ( "categoryid" ) ; items [ rsItems . getRow ( ) - 1 ] [ 3 ] = rsItems . getString ( "price" ) ; items [ rsItems . getRow ( ) - 1 ] [ 4 ] = rsItems . getString ( "taxable" ) ; items [ rsItems . getRow ( ) - 1 ] [ 5 ] = rsItems . getString ( "display_Order" ) ; } return items ; } }
tr	A	public void mouseReleased ( final MouseEvent e ) { releasePoints . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
tr	D	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = ( int ) ( col * colScale ) ; int rowPos = ( int ) ( row * rowScale ) ; int nextCol = ( int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	A	protected void appendItem ( String astr , Object aobj ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; }
tr	B	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
tr	E	public static ReflectInfo buildReflectInfo ( class < ? > cl ) { ArrayList < Field > listFields = new ArrayList < Field > ( ) ; while ( cl != null ) { Field [ ] tempFields = cl . getDeclaredFields ( ) ; for ( Field field : tempFields ) { if ( field . isAccessible ( ) == false ) field . setAccessible ( true ) ; listFields . add ( field ) ; } cl = cl . getSuperclass ( ) ; if ( cl == null || cl . equals ( Object . class ) ) break ; } Collections . sort ( listFields , FIELD_COMPARATOR ) ; Field [ ] fields = new Field [ listFields . size ( ) ] ; int [ ] types = new int [ listFields . size ( ) ] ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = listFields . get ( i ) ; fields [ i ] = field ; types [ i ] = JavaTypes . getType ( field . getType ( ) . getName ( ) ) ; } return new ReflectInfo ( cl . getName ( ) , fields , types ) ; }
tr	D	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	D	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	E	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	C	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	E	public static < P extends Player , Plugin extends PlayerPlugin < P >> List < P > showDialog ( Component component , List < Plugin > plugins ) { List < P > enabledPlayers = new ArrayList < > ( ) ; Map < String , List < P >> map = new HashMap < > ( ) ; for ( Plugin plugin : plugins ) { List < P > players = plugin . getPlayers ( ) ; List < P > list = map . get ( plugin . getName ( ) ) ; if ( list == null ) { list = new ArrayList < P > ( ) ; map . put ( plugin . getName ( ) , list ) ; } list . addAll ( players ) ; } JPanel allPluginsPanel = new JPanel ( ) ; allPluginsPanel . setLayout ( new BoxLayout ( allPluginsPanel , BoxLayout . Y_AXIS ) ) ; for ( String pluginName : map . keySet ( ) ) { PluginSelectionPanel panel = new PluginSelectionPanel ( ) ; panel . setPlugins ( pluginName , map . get ( pluginName ) , enabledPlayers ) ; allPluginsPanel . add ( panel ) ; } int option = JOptionPane . showConfirmDialog ( component , allPluginsPanel , "select players" , OK_CANCEL_OPTION , PLAIN_MESSAGE ) ; if ( option == OK_OPTION ) { return enabledPlayers ; } else { return null ; } }
tr	E	public void makeMove ( ) { if ( isActive ( ) ) { if ( ! canMove ( ) ) { if ( Timer . getTime ( ) - last > 500 ) { if ( getDice ( ) . isLocked ( ) ) { this . getDice ( ) . unlock ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } if ( this . getDice ( ) . getLastNumber ( ) != 0 ) { rollCount -- ; if ( rollCount == 0 ) { getDice ( ) . lock ( ) ; } } } last = Timer . getTime ( ) ; } } else { for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . isClicked ( ) && gameFigure . canMove ( getDice ( ) . getLastNumber ( ) ) ) { gameFigure . move ( getDice ( ) . getLastNumber ( ) ) ; rollCount -- ; if ( canRollDiceAgain ( ) ) { getDice ( ) . unlock ( ) ; rollCount = 1 ; } getDice ( ) . reset ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } break ; } } } } }
tr	E	@ Override public Pane getPane ( ) { Image iconAddUser = new Image ( "file:img/customer-icon-add.png" ) ; Image iconFindUser = new Image ( "file:img/customer-icon-find.png" ) ; ImageView iconimgAddUser = new ImageView ( iconAddUser ) ; Button buttonAddUser = new Button ( "Create a customer" , iconimgAddUser ) ; buttonAddUser . setContentDisplay ( ContentDisplay . LEFT ) ; buttonAddUser . setPrefSize ( 650 , 150 ) ; buttonAddUser . getStyleClass ( ) . add ( "big-text" ) ; ImageView iconimgFindUser = new ImageView ( iconFindUser ) ; Button buttonFindUser = new Button ( "Find a customer" , iconimgFindUser ) ; buttonFindUser . setContentDisplay ( ContentDisplay . LEFT ) ; buttonFindUser . setPrefSize ( 650 , 150 ) ; buttonFindUser . getStyleClass ( ) . add ( "big-text" ) ; buttonAddUser . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent e ) { screenController . setScreen ( "USER_CREATION_SCREEN" ) ; } } ) ; buttonFindUser . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent e ) { screenController . setScreen ( "USER_FIND_SCREEN" ) ; } } ) ; VBox vBox = new VBox ( ) ; vBox . setAlignment ( Pos . CENTER ) ; vBox . getChildren ( ) . addAll ( buttonAddUser , buttonFindUser ) ; vBox . getStyleClass ( ) . add ( "background-style" ) ; vBox . setSpacing ( 5 ) ; return vBox ; }
tr	B	public CShotItem ( ) { shotid = "" ; shotdate = new Date ( ) ; vaccinecd = CAppConsts . TagNoValue ; mfrcd = CAppConsts . TagNoValue ; mdyfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; vacnote = "" ; vageyears = 0 ; vagemonths = 0 ; vageweeks = 0 ; vagedays = 0 ; }
tr	D	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	C	public static void criarClientePadraoParaTeste ( ) { XMLGregorianCalendar today = null ; try { today = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( 2008 , 10 , 1 ) ) ; } catch ( DatatypeConfigurationException e ) { e . printStackTrace ( ) ; } Cliente c1 = new Cliente ( ) ; c1 . setCelular ( "999999999" ) ; c1 . setId ( ( long ) 1 ) ; c1 . setNome ( "TESTEID28" ) ; c1 . setCpf ( "111.111.111-11" ) ; c1 . setEmail ( "joaninha@teste.com" ) ; c1 . setDataNascimento ( today ) ; adicionarNovosClientesNaCaptacaoParaTeste ( c1 ) ; }
tr	B	private String extractContentType ( String line ) throws IOException { String contentType = null ; String origline = line ; line = origline . toLowerCase ( ) ; if ( line . startsWith ( "content-type" ) ) { int start = line . indexOf ( " " ) ; if ( start == - 1 ) throw new IOException ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	B	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add ( go ) ; if ( go instanceof ShootingBulletCharacter ) { bullets . add ( ( ShootingBulletCharacter ) go ) ; } else if ( go . getTeam ( ) == TEAM . FRIEND_TEAM ) { friendlieCharas . add ( go ) ; } else if ( go . getTeam ( ) == TEAM . ENEMY_TEAM ) { enemieCharas . add ( go ) ; } return go ; }
tr	A	public void reset ( ) { try { valid = false ; theConnection . close ( ) ; theConnection = makeConnection ( ) ; valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , e ) ; } }
tr	A	public void setDbClass ( String adbclass ) { try { class . forName ( adbclass ) ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error loading class:" , e ) ; } }
tr	D	public RandomListNode copyRandomList ( RandomListNode head ) { if ( head == null ) return null ; RandomListNode p = head , p1 ; while ( p != null ) { p1 = new RandomListNode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p . next ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } RandomListNode dummy = new RandomListNode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
tr	E	@ Override public void receiveData ( byte [ ] dataBuffer , final int byteCount ) { final int [ ] rawData = convertToIntArray ( dataBuffer , byteCount ) ; executor . submit ( new Runnable ( ) { @ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event == null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending != null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ) ; if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; }
tr	D	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	E	private JTabbedPane createBuildMenu ( ) { JTabbedPane menu = new JTabbedPane ( ) ; JComponent panel1 = makeBuildMenu ( ) ; menu . addTab ( "Build" , null , panel1 , "Build Useful Tools" ) ; menu . setMnemonicAt ( 0 , KeyEvent . VK_1 ) ; JComponent panel2 = makeTextPanel ( "Panel #2" ) ; menu . addTab ( "Tab 2" , null , panel2 , "Does twice as much nothing" ) ; menu . setMnemonicAt ( 1 , KeyEvent . VK_2 ) ; JComponent panel3 = makeTextPanel ( "Panel #3" ) ; menu . addTab ( "Tab 3" , null , panel3 , "Still does nothing" ) ; menu . setMnemonicAt ( 2 , KeyEvent . VK_3 ) ; JComponent panel4 = makeTextPanel ( "Panel #4 (has a preferred size of 410 x 50)." ) ; panel4 . setPreferredSize ( new Dimension ( 200 , 100 ) ) ; menu . addTab ( "Tab 4" , null , panel4 , "Does nothing at all" ) ; menu . setMnemonicAt ( 3 , KeyEvent . VK_4 ) ; Border border = BorderFactory . createLineBorder ( Color . black ) ; menu . setBorder ( border ) ; menu . setVisible ( false ) ; menu . setSize ( menu . getPreferredSize ( ) ) ; menu . setLocation ( ( screen . getWidth ( ) - menu . getWidth ( ) ) / 2 , ( screen . getHeight ( ) - menu . getHeight ( ) ) / 2 ) ; menu . setDoubleBuffered ( true ) ; return menu ; }
tr	C	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 2 , 0 , 1 , 0 , 0 , - 1 } , { 0 , 2 , 1 , 0 , 0 , - 1 } , { - 2 , 0 , 1 , 0 , 0 , - 1 } , { 1 , 0 , 1 , 0 , 0 , - 1 } , { 0 , - 1 , 1 , 0 , 0 , - 1 } , { - 1 , 0 , 1 , 0 , 0 , - 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	E	public void loadFile ( String type , ArrayList < String > list , String file , String [ ] headers ) throws IOException { BufferedReader in = null ; in = new BufferedReader ( new FileReader ( file ) ) ; String line = in . readLine ( ) ; if ( ! headersMatch ( headers , line ) ) { System . out . println ( "Error: " + type + "section is improperly defined in the headers" ) ; System . exit ( 0 ) ; } String entity = in . readLine ( ) ; while ( entity != null ) { if ( type . equals ( "Food" ) ) { if ( validFood ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Weapon" ) ) { if ( validWeapon ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Armour" ) ) { if ( validArmour ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Monster" ) ) { if ( validMonster ( entity ) ) list . add ( entity ) ; } entity = in . readLine ( ) ; } in . close ( ) ; }
tr	A	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( aidx , aobj ) ; }
tr	C	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { MemoryMXBean mbean = ManagementFactory . getMemoryMXBean ( ) ; NotificationEmitter emitter = ( NotificationEmitter ) mbean ; emitter . addNotificationListener ( new NotificationListener ( ) { @ Override public void handleNotification ( Notification notification , Object handback ) { if ( notification . getType ( ) . equals ( MemoryNotificationInfo . MEMORY_THRESHOLD_EXCEEDED ) ) { for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } } } } , null , null ) ; } } ) ; running . setDaemon ( true ) ; running . start ( ) ; }
tr	A	public String makeOptions ( String acode ) { return ( makeOptions ( CAppConsts . TagNoValue , acode ) ) ; }
tr	B	@ Override public void update ( ) { if ( scene . getLeftWeapon ( ) != left . weapon ) { left . setWeapon ( scene . getLeftWeapon ( ) ) ; } if ( scene . getRightWeapon ( ) != right . weapon ) { right . setWeapon ( scene . getRightWeapon ( ) ) ; } left . update ( ) ; right . update ( ) ; }
tr	E	public String INFO_STATUS ( String status , int selected , int inserted , int updated , int deleted , int rejected ) { String returnValue = null ; internalBuffer . append ( System . lineSeparator ( ) ) ; internalBuffer . append ( "+=============================================================================+" ) ; internalBuffer . append ( System . lineSeparator ( ) ) ; internalBuffer . append ( "|" ) ; internalBuffer . append ( System . lineSeparator ( ) ) ; returnValue = RessourceReporting . getString ( "INFO_STATUS" , new Object [ ] { status } ) + System . lineSeparator ( ) ; returnValue += RessourceReporting . getString ( "INFO_STATUS_SELECT" , new Object [ ] { new Integer ( selected ) } ) + System . lineSeparator ( ) ; returnValue += RessourceReporting . getString ( "INFO_STATUS_INSERT" , new Object [ ] { new Integer ( inserted ) } ) + System . lineSeparator ( ) ; returnValue += RessourceReporting . getString ( "INFO_STATUS_UPDATE" , new Object [ ] { new Integer ( updated ) } ) + System . lineSeparator ( ) ; returnValue += RessourceReporting . getString ( "INFO_STATUS_DELETE" , new Object [ ] { new Integer ( deleted ) } ) + System . lineSeparator ( ) ; LOGGER . finest ( returnValue ) ; internalBuffer . append ( returnValue ) ; return returnValue ; }
tr	C	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) != null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	C	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } this . lastScore = tempScore ; return tempMove ; }
tr	E	@ Test public void testExtquery ( ) throws ParsingException { QueryMap qm = QueryFactory . createQueryMap ( "test.sql" ) ; MainQuery main = ( MainQuery ) qm . getQuery ( "main" ) ; assertArrayEquals ( new String [ ] { "name" , "id" } , main . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . getText ( ) ) ; assertEquals ( 2 , main . sizeOfExtQueries ( ) ) ; ExtQuery [ ] extQs = main . getExtQueries ( ) ; ExtQuery ex1 = extQs [ 0 ] ; assertEquals ( "sub1" , ex1 . id ) ; assertEquals ( "  zip  ? " , ex1 . getText ( ) ) ; assertArrayEquals ( new String [ ] { "city" } , ex1 . parameters ) ; assertEquals ( 1 , ex1 . beginParameter ) ; assertEquals ( 13 , ex1 . beginPosition ) ; ExtQuery ex2 = extQs [ 1 ] ; assertEquals ( "sub2" , ex2 . id ) ; assertEquals ( "and email =? " , ex2 . getText ( ) ) ; assertArrayEquals ( new String [ ] { "email" } , ex2 . parameters ) ; assertEquals ( 2 , ex2 . beginParameter ) ; assertEquals ( 40 , ex2 . beginPosition ) ; }
tr	A	public void resetSize ( ) { setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; }
tr	D	public String addBinary ( String a , String b ) { StringBuilder builder = new StringBuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charAt ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charAt ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . toString ( ) ; }
tr	E	public static double [ ] box_box_p ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , double by0 , double bx1 , double by1 ) { double [ ] result = NONE ; double topA = FastMath . min ( ay0 , ay1 ) ; double botA = FastMath . max ( ay0 , ay1 ) ; double leftA = FastMath . min ( ax0 , ax1 ) ; double rightA = FastMath . max ( ax0 , ax1 ) ; double topB = FastMath . min ( by0 , by1 ) ; double botB = FastMath . max ( by0 , by1 ) ; double leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA <= topB || botB <= topA || rightA <= leftB || rightB <= leftA ) return result ; double leftO = ( leftA < leftB ) ? leftB : leftA ; double rightO = ( rightA > rightB ) ? rightB : rightA ; double botO = ( botA > botB ) ? botB : botA ; double topO = ( topA < topB ) ? topB : topA ; result = new double [ ] { leftO , topO , rightO , botO } ; return result ; }
tr	C	@ Test public void testSanity ( ) { ReplacementStrategy < String > strategy = new LeastRecentlyUsed < String > ( ) ; assertNull ( strategy . suggest ( ) ) ; strategy . hit ( "foo" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . hit ( "bar" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . evict ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; strategy . evict ( "bar" ) ; assertNull ( strategy . suggest ( ) ) ; }
tr	A	public MultipartParser ( HttpServletRequest req , int maxSize ) throws IOException { this ( req , maxSize , true , true ) ; }
tr	B	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ShotItem>\n" ) ; retstr . append ( "<ShotDate>" + mdyfmt . format ( shotdate ) + "</ShotDate>\n" ) ; retstr . append ( "<VaccineCd>" + vaccinecd + "</VaccineCd>\n" ) ; retstr . append ( "<MfrCd>" + mfrcd + "</MfrCd>\n" ) ; retstr . append ( "</ShotItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	D	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 1 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
tr	E	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new Font ( "Sanserif" , Font . BOLD , fontHeight = w / 20 ) ; } g . setFont ( font ) ; g . setColor ( bgColor ) ; g . fillRect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setColor ( i == I ? isMouseDown ? Color . blue : hoverColor : Color . white ) ; g . fillRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setColor ( Color . black ) ; g . drawRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawString ( "CDEFGABC" . substring ( i , i + 1 ) , x ( i ) - fontHeight / 3 , h / 2 + fontHeight / 3 ) ; } g . drawString ( Instrument . name ( id ) , fontHeight / 6 , fontHeight ) ; }
tr	E	public boolean isCollision ( Sprite s1 , Sprite s2 ) { if ( s1 == s2 ) { return false ; } if ( s1 instanceof Creature && ! ( ( Creature ) s1 ) . isAlive ( ) ) { return false ; } if ( s2 instanceof Creature && ! ( ( Creature ) s2 ) . isAlive ( ) ) { return false ; } if ( s1 instanceof Laser && s2 instanceof Planet ) { Laser l = ( Laser ) s1 ; Planet p = ( Planet ) s2 ; if ( l . getLine ( ) . intersects ( p . circle . getBounds2D ( ) ) ) { return true ; } else { return false ; } } int s1x = Math . round ( s1 . getX ( ) ) ; int s1y = Math . round ( s1 . getY ( ) ) ; int s2x = Math . round ( s2 . getX ( ) ) ; int s2y = Math . round ( s2 . getY ( ) ) ; return ( s1x < s2x + s2 . getWidth ( ) && s2x < s1x + s1 . getWidth ( ) && s1y < s2y + s2 . getHeight ( ) && s2y < s1y + s1 . getHeight ( ) ) ; }
tr	E	public void actionPerformed ( ActionEvent ae2 ) { list1 . add ( String . valueOf ( itemsArray [ buttonIndex ] [ 1 ] ) ) ; subTotal += double . parseDouble ( itemsArray [ buttonIndex ] [ 3 ] ) ; if ( itemsArray [ 4 ] . equals ( "1" ) ) { taxSubtotal += double . parseDouble ( itemsArray [ buttonIndex ] [ 3 ] ) ; } taxTotalCalculated = taxSubtotal * ( taxRate / 100 ) ; amountDueCalculated = ( taxTotalCalculated + subTotal ) - ( amountPaidEntry + discountEntry ) ; amountDue . setText ( decim . format ( amountDueCalculated ) . toString ( ) ) ; subTotals . setText ( decim . format ( subTotal ) . toString ( ) ) ; taxTotal . setText ( decim . format ( taxSubtotal * taxRate / 100 ) . toString ( ) ) ; total . setText ( decim . format ( subTotal + taxTotalCalculated ) . toString ( ) ) ; action . add ( itemsArray ) ; jPanel2 . setVisible ( true ) ; jPanel3 . setVisible ( false ) ; jPanel3 . removeAll ( ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; }
tr	E	public void move ( ) { if ( Key . LEFT . isPressing ( ) ) { vx -= ACCELE ; } if ( Key . RIGHT . isPressing ( ) ) { vx += ACCELE ; } if ( ( y + size == HEIGHT ) && ( vy < SIKII ) && ( Key . SPACE . isPressing ( ) ) ) { vy -= new Random ( ) . nextInt ( 20 ) ; } x += vx ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; vx *= X_HANSYA ; pong . play ( ) ; if ( x < 0 ) { x = - x ; } if ( x + size > WIDTH ) { x -= x + size - ( WIDTH ) ; } } vy += VG ; y += vy ; if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; vy *= Y_HANSYA ; vx *= X_KOROGARI ; if ( y < 0 ) { y = - y ; pong . play ( ) ; } if ( y + size > HEIGHT ) { y -= y + size - ( HEIGHT ) ; if ( Math . abs ( vy ) > SIKII ) { pong . play ( ) ; } } } }
tr	B	private static int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i = pos ; while ( i < end ) { if ( b [ i ++ ] ==  ) return i - pos ; } return - 1 ; }
tr	D	public void initialize ( ) { m1 = new Material ( ) ; m2 = new Material ( ) ; m1 . setSpecularPower ( 10 ) ; m2 . setSpecularPower ( 10 ) ; m1 . setAmbient ( new double [ ] { 0.6 , 0.2 , 0.3 } ) ; m1 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setSpecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m2 . setAmbient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setSpecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; for ( int i = 0 ; i < lights . length ; i ++ ) { normalize ( lights [ i ] [ 0 ] ) ; normalize ( lights [ i ] [ 1 ] ) ; } }
tr	C	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 == 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	A	@ Override public void update ( ) { addBookingObjects ( ) ; inputProcess ( ) ; checkHit ( ) ; updateObjects ( ) ; }
tr	C	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { String qstr = "Select PassHash From UserTbl Where UserId=?" ; PreparedStatement pstmt = aconn . prepareStatement ( qstr ) ; pstmt . setString ( 1 , auser ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( rset . next ( ) ) { curhash = rset . getString ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
va	B	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
va	E	public void drawShip ( Graphics2D g , int offsetX , int offsetY ) { AffineTransform saveTransform = g . getTransform ( ) ; AffineTransform identity = new AffineTransform ( ) ; g . setTransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { Vector2D t_heading = heading ; Vector2D t_oldheading = oldheading ; Vector2D t_velocity = velocity ; double relativeHeading = velocity . minus ( t_oldheading ) . perp ( ) . getTheta ( ) ; g . rotate ( relativeHeading , position . x + offsetX , position . y + offsetY - engine1 . engineHeight / 2 - nose . noseLength ) ; } drawBody ( g , offsetX , offsetY ) ; drawEngines ( g , offsetX , offsetY ) ; drawNose ( g , offsetX , offsetY ) ; int sx = Math . round ( getX ( ) ) + offsetX ; int sy = Math . round ( getY ( ) ) + offsetY ; g . setTransform ( saveTransform ) ; Color saveColor = g . getColor ( ) ; g . setColor ( Color . red ) ; DecimalFormat df = new DecimalFormat ( "#" ) ; String hp = df . format ( this . hitpoints ) ; g . drawString ( hp , sx , ( float ) ( sy - this . getHeight ( ) / 2 ) ) ; g . setColor ( saveColor ) ; }
va	C	@ Test public void testDayLigthSaving ( ) { String dateString = "2012-03-25 00:00:00" ; DateTimeFormatter dtf = DateTimeFormat . forPattern ( "yyyy-MM-dd HH:mm:ss" ) ; DateTime startOfDay = dtf . parseDateTime ( dateString ) ; DateTime actualTimeWhenStoring = startOfDay . plusHours ( 2 ) ; int hourOfDay = actualTimeWhenStoring . getHourOfDay ( ) ; int hourOffset = startOfDay . plusHours ( hourOfDay ) . getHourOfDay ( ) ; System . out . println ( "Hour of day:" + hourOfDay ) ; System . out . println ( "Offset hour:" + hourOffset ) ; int timeToSave = hourOfDay ; if ( hourOffset != hourOfDay ) { timeToSave = ( hourOfDay + ( hourOfDay - hourOffset ) ) ; } System . out . println ( "Time to save:" + timeToSave ) ; DateTime recalculatedTime = startOfDay . plusHours ( timeToSave ) ; System . out . println ( "Hour of time 'read' from db:" + recalculatedTime . getHourOfDay ( ) ) ; }
va	C	@ Override public void checkAnswer ( String answer ) { long curTime = new Date ( ) . getTime ( ) ; long spentTime = curTime - this . cardShown ; curBox = this . model . getBox ( ) ; if ( this . model . check ( answer ) ) { if ( this . model . getSpentTime ( ) < spentTime ) { this . view . answerRightSlow ( ) ; } else { this . view . answerRightFast ( ) ; } this . model . setSpentTime ( spentTime ) ; } else { this . view . answerWrong ( ) ; } this . onCheckCard . refresh ( ) ; }
va	C	@ Override public ArticleStatModel mapRow ( ResultSet rs , int rowNum ) throws SQLException { ArticleStatModel model = new ArticleStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setDate ( new DateTime ( rs . getLong ( "date" ) ) ) ; model . setArticleId ( rs . getString ( "articleid" ) ) ; model . setArticleTitle ( rs . getString ( "articletitle" ) ) ; model . setArticleUrl ( rs . getString ( "articleurl" ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
va	C	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; itemsLoad = DbUtil . loadItems ( ) ; categories = DbUtil . loadCategories ( ) ; ArrayList catList = new ArrayList ( ) ; for ( String [ ] categorie : categories ) { jComboBox1 . addItem ( categorie [ 1 ] ) ; } for ( int i = 0 ; i < itemsLoad . length ; i ++ ) { list1 . add ( itemsLoad [ i ] [ 1 ] ) ; } buttonSaveAdd . setVisible ( false ) ; buttonSaveEdit . setVisible ( false ) ; buttonSaveDelete . setVisible ( false ) ; Cancel . setVisible ( false ) ; }
va	A	private void addFlowerIfNecessary ( ) { if ( FPSManager . totalFrame ( ) % ( FPS / flowerBornPerSecond ) == 0 ) { add ( new FlowerCharacter ( flowerTexture ) ) ; } }
va	E	public List < Integer > inorderTraversal ( TreeNode root ) { Stack < TreeNode > first = new Stack < TreeNode > ( ) ; Stack < TreeNode > second = new Stack < TreeNode > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; first . add ( root ) ; while ( ! first . isEmpty ( ) || ! second . isEmpty ( ) ) { System . out . print ( first . isEmpty ( ) ) ; System . out . println ( second . isEmpty ( ) ) ; if ( ! first . isEmpty ( ) ) { root = first . pop ( ) ; if ( root . left != null ) { first . add ( root . left ) ; } second . add ( root ) ; } else if ( ! second . isEmpty ( ) ) { root = second . pop ( ) ; result . add ( root . val ) ; dbg ( root . val ) ; if ( root . right != null ) first . add ( root . right ) ; } } return result ; }
va	D	private static void addMonstersRoom ( MapGenerator map , Map newMap , Rectangle room , int tier , int count ) { Rectangle placement = MapRand . innerRectangle ( room ) ; for ( int i = 0 ; i < count ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( map . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) ) continue ; Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( tier ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } }
va	E	public List < Interval > merge ( List < Interval > intervals ) { if ( intervals == null || intervals . size ( ) < 2 ) return intervals ; Collections . sort ( intervals , new Comparator < Interval > ( ) { @ Override public int compare ( Interval i1 , Interval i2 ) { if ( i1 . start < i2 . start ) return - 1 ; else if ( i1 . start == i2 . start ) return 0 ; else return 1 ; } } ) ; Interval curr = new Interval ( intervals . get ( 0 ) . start , intervals . get ( 0 ) . end ) ; List < Interval > result = new ArrayList < Interval > ( ) ; for ( int i = 1 ; i < intervals . size ( ) ; i ++ ) { Interval next = intervals . get ( i ) ; if ( curr . end >= next . end ) { } else if ( curr . end >= next . start && curr . end < next . end ) { curr . end = next . end ; } else if ( curr . end < next . start ) { result . add ( curr ) ; curr = new Interval ( next . start , next . end ) ; } } result . add ( curr ) ; return result ; }
va	A	private void updateDisplay ( ) { Display . update ( ) ; Display . sync ( FPS ) ; Display . setTitle ( "FRAME:" + String . valueOf ( cycleFrame ( ) ) + "FPS:" + floatTo0d0 ( calculatedFPS ) ) ; }
va	D	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
va	A	public static GameSceneManager getInstance ( ) { if ( null == instance ) { instance = new GameSceneManager ( ) ; } return instance ; }
va	B	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return false ; } else { boolean tmp = PackedLong . get ( world , ( col + row * 8 ) ) ; return tmp ; } }
va	B	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	E	public double getSRLCost ( DependencyInstance goldinst , DependencyInstance predinst ) { SemanticFrame [ ] gold = goldinst . frames , pred = predinst . frames ; Utils . assert ( gold . length == pred . length ) ; double dis = 0 ; for ( int i = 0 , N = gold . length ; i < N ; ++ i ) { Utils . assert ( gold [ i ] . predid == pred [ i ] . predid ) ; int pid = gold [ i ] . predid ; int [ ] ga = gold [ i ] . arglbids , pa = pred [ i ] . arglbids ; for ( int j = 0 , L = ga . length ; j < L ; ++ j ) { int garg = ga [ j ] ; if ( garg >= 0 && ! SemanticFeatureFactory . isValidPredAugPair ( predinst , pid , j ) ) garg = - 1 ; if ( garg != pa [ j ] ) { if ( garg < 0 ) dis += 1.0 ; else if ( pa [ j ] < 0 ) dis += 2.0 ; else dis += 0.5 ; } } } return dis ; }
va	B	public static void play ( World world ) throws IOException { WorldViewer viewer = new WorldViewer ( ) ; int userResponse = 0 ; Writer w = new OutputStreamWriter ( System . out ) ; while ( userResponse != q ) { viewer . show ( world ) ; world . print ( w ) ; userResponse = System . in . read ( ) ; world = world . nextGeneration ( 0 ) ; } }
va	C	private void jButton2ActionPerformed ( java . awt . event . ActionEvent evt ) { try { Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\Products.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , null , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	E	public FeatureVector createPPFeatureVector ( DependencyInstance inst , int gp , int par , int c ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int HC = posA [ gp ] ; int MC = posA [ c ] ; int HL = lemma [ gp ] ; int ML = lemma [ c ] ; int PL = lemma [ par ] ; long code = 0 ; code = createArcCodePP ( PP_HC_MC , HC , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( PP_HL_MC , HL , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( PP_HC_ML , ML , HC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( PP_HL_ML , HL , ML ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( PP_PL_HC_MC , PL , HC , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( PP_PL_HL_MC , PL , HL , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( PP_PL_HC_ML , PL , ML , HC ) ; addArcFeature ( code , fv ) ; return fv ; }
va	C	private RecordArticleStatAllTimeModel updateRecordArticleStatAllTime ( RecordArticleStatAllTimeModel model ) { String sql = "UPDATE recordarticlestatalltime SET  uniquevisitor=?  uniquevisitorarticleid=?   uniquevisitorarticletitle=?  uniquevisitorarticleurl=?  pageview=? " + "pageviewarticleid=?  pageviewarticletitle=?  pageviewarticleurl=?  visit=?  visitarticleid=?  visitarticletitle=?  visitarticleurl=?  site_id=? WHERE id = ?" ; jdbcTemplate . update ( sql , model . getUniqueVisitor ( ) , model . getUniqueVisitorArticleId ( ) , model . getUniqueVisitorArticleTitle ( ) , model . getUniqueVisitorArticleUrl ( ) , model . getPageView ( ) , model . getPageViewArticleId ( ) , model . getPageViewArticleTitle ( ) , model . getPageViewArticleUrl ( ) , model . getVisit ( ) , model . getVisitArticleId ( ) , model . getVisitArticleTitle ( ) , model . getVisitArticleUrl ( ) , model . getSite ( ) . getId ( ) , model . getId ( ) ) ; return model ; }
va	D	public void moveRandomly ( Sentient s ) { ArrayList < Point > directions = new ArrayList < Point > ( 4 ) ; Tile location = s . getLocation ( ) ; if ( location . getRow ( ) > 0 ) directions . add ( new Point ( 0 , - 1 ) ) ; if ( location . getRow ( ) < map . getHeight ( ) - 1 ) directions . add ( new Point ( 0 , 1 ) ) ; if ( location . getColumn ( ) < map . getWidth ( ) - 1 ) directions . add ( new Point ( 1 , 0 ) ) ; if ( location . getColumn ( ) > 0 ) directions . add ( new Point ( - 1 , 0 ) ) ; int random = MapRand . randInt ( directions . size ( ) - 1 ) ; moveSentient ( s , directions . get ( random ) . x , directions . get ( random ) . y ) ; }
va	D	public void render ( Graphics2D context ) { Color color = context . getColor ( ) ; Stroke stroke = context . getStroke ( ) ; if ( this . isClicked ( ) ) { context . setColor ( this . getClickedColor ( ) ) ; } else { context . setColor ( this . getColor ( ) ) ; } context . setStroke ( new BasicStroke ( this . getBorderSize ( ) ) ) ; context . drawRect ( this . getX ( ) + this . getBorderSize ( ) / 2 , this . getY ( ) + this . getBorderSize ( ) / 2 , this . getWidth ( ) - this . getBorderSize ( ) , this . getHeight ( ) - this . getBorderSize ( ) ) ; if ( this . state ) { this . renderEnabledState ( context ) ; } else { this . renderDisabledState ( context ) ; } context . setColor ( color ) ; context . setStroke ( stroke ) ; }
va	C	@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndNumb ; i ++ ) { if ( i == rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; }
va	D	private static int getNextNumber ( ) { int returnValue = 0 ; String filePath = SystemUtils . USER_HOME + SystemUtils . FILE_SEPARATOR + ".reportnumber.asc" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { FileAsciiReader fileAsciiReader = new FileAsciiReader ( filePath ) ; String chaine = fileAsciiReader . readLine ( ) ; fileAsciiReader . close ( ) ; fileAsciiReader = null ; if ( StringUtils . isNumeric ( chaine ) ) { returnValue = Integer . parseInt ( chaine ) ; } } catch ( IOException e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } } try { FileAsciiWriter fileAsciiWriter = new FileAsciiWriter ( filePath ) ; fileAsciiWriter . write ( "" + ( ++ returnValue ) ) ; fileAsciiWriter . close ( ) ; fileAsciiWriter = null ; } catch ( IOException e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } LOGGER . config ( "filePath=" + filePath + " => " + returnValue ) ; return returnValue ; }
va	A	private void doSpawn ( SpawnData spawnData ) { spawnedEnemies . add ( parentScene . add ( spawnData . spawnTo ( parentScene ) ) ) ; }
va	B	public void print ( Writer w ) { PrintWriter pw = new PrintWriter ( w ) ; pw . println ( "-" ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { pw . print ( getCell ( col , row ) ? "#" : "_" ) ; } pw . println ( ) ; } pw . flush ( ) ; }
va	C	private void buttoonNewOrderActionPerformed ( java . awt . event . ActionEvent evt ) { try { DbUtil . salesUpdate ( userName , subTotal , taxTotalCalculated , discountEntry , amountPaidEntry ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } subTotal = 0.00 ; taxSubtotal = 0.00 ; taxTotalCalculated = 0.00 ; amountDueCalculated = 0.00 ; amountPaidEntry = 0.00 ; discountEntry = 0.00 ; list1 . removeAll ( ) ; taxTotal . setText ( "0.00" ) ; subTotals . setText ( "0.00" ) ; total . setText ( "0.00" ) ; discount . setText ( "0.00" ) ; amountPaid . setText ( "0.00" ) ; amountDue . setText ( "0.00" ) ; }
va	E	public JPanel makeShipSliderMenu ( ) { JPanel sliderMenu = new JPanel ( new GridLayout ( 0 , 1 ) ) ; JSlider levelSlider = createShipSlider ( "level" ) ; JSlider totalPowerSlider = createShipSlider ( "totalPower" ) ; JSlider powerSlider = createShipSlider ( "power" ) ; JSlider speedSlider = createShipSlider ( "speed" ) ; JSlider hitpointSlider = createShipSlider ( "hitpoint" ) ; JLabel levelLabel = new JLabel ( "Level" ) ; JLabel totalPointsLabel = new JLabel ( "Total Power" ) ; JLabel powerLabel = new JLabel ( "Power" ) ; JLabel speedLabel = new JLabel ( "Speed" ) ; JLabel hitpointLabel = new JLabel ( "Hit Points" ) ; levelLabel . setDoubleBuffered ( true ) ; totalPointsLabel . setDoubleBuffered ( true ) ; powerLabel . setDoubleBuffered ( true ) ; speedLabel . setDoubleBuffered ( true ) ; hitpointLabel . setDoubleBuffered ( true ) ; sliderMenu . setDoubleBuffered ( true ) ; sliderMenu . add ( levelLabel ) ; sliderMenu . add ( levelSlider ) ; sliderMenu . add ( totalPointsLabel ) ; sliderMenu . add ( totalPowerSlider ) ; sliderMenu . add ( powerLabel ) ; sliderMenu . add ( powerSlider ) ; sliderMenu . add ( speedLabel ) ; sliderMenu . add ( speedSlider ) ; sliderMenu . add ( hitpointLabel ) ; sliderMenu . add ( hitpointSlider ) ; sliderMenu . setDoubleBuffered ( true ) ; return sliderMenu ; }
va	D	public void drawMap ( Map map ) { clearDisplay ( ) ; this . currentMap = map ; for ( int i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getHeight ( ) ; j ++ ) { drawTile ( map . getTile ( i , j ) . getBackground ( ) , i , j ) ; if ( currentMap . getTile ( i , j ) . isVisible ( ) ) { drawTile ( map . getTile ( i , j ) . getTopItemImage ( ) , i , j ) ; drawTile ( map . getTile ( i , j ) . getOccupantImage ( ) , i , j ) ; } } } this . width = map . getWidth ( ) * TILE_SIZE ; this . height = map . getHeight ( ) * TILE_SIZE ; this . setPreferredSize ( new java . awt . Dimension ( width , height ) ) ; repaintSuper ( ) ; }
va	D	public static Holdable createHoldableFromReader ( String itemString ) { String [ ] values = itemString . split ( " " ) ; Holdable item = new Holdable ( ) ; try { item . setName ( values [ 0 ] ) ; item . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; item . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; if ( values . length == 4 && values [ 3 ] != "" ) { String [ ] specials = values [ 3 ] . split ( " " ) ; item = Holdable . applySpecialTraits ( item , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading misc object" ) ; if ( item . getName ( ) != null ) System . out . println ( item . getName ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
va	D	@ Test ( groups = "MaSuite" ) public void importFileCsv ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.csv" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.csv" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "ISO-8859-1" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename-csv.xml" ) . toURI ( ) ) . getAbsolutePath ( ) ; boolean cached = false ; boolean verbose = true ; String fileNameReport = File . createTempFile ( "imp" , ".txt" ) . getAbsolutePath ( ) ; LOGGER . fine ( "fileNameReport=" + fileNameReport ) ; Importation . importFile ( fileSource , fileSourceEncoding , fileNameParameter , conn , DerbyConstantes . SCHEMA_NAME , cached , verbose , fileNameReport ) ; assert . assertTrue ( true ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	B	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
va	D	public boolean isActive ( String ligne ) { boolean returnValue = true ; String buffer = null ; for ( Key key : xmlline . getKeys ( ) ) { if ( ! key . isBlank ( ) ) { if ( ( key . getStartposition ( ) > ligne . length ( ) ) || ( ( key . getStartposition ( ) + key . getSize ( ) ) > ligne . length ( ) ) ) { returnValue &= false ; break ; } else { buffer = key . getValue ( ligne ) ; returnValue &= buffer . equals ( key . getKeyValue ( ) ) ; } } else { buffer = key . getValue ( ligne ) ; returnValue &= ! ( key . isBlank ( ) ^ StringUtils . isEmpty ( buffer . trim ( ) ) ) ; } } return returnValue ; }
va	D	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 50 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 35 ) ; this . backgroundImage = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . header = new TELabel ( "Menu" , 0 , 50 , titleFont ) ; this . btnCollection = new TECollectionVertical ( 0 , 0 , 20 ) ; this . btnCollection . addView ( new TEButton ( "Play" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; this . btnCollection . addView ( new TEButton ( "Credits" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; }
va	B	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	C	public static void main ( String [ ] args ) { int a , b , c = 0 ; Scanner in = new Scanner ( System . in ) ; System . out . println ( "enter two numbers to be divided" ) ; try { a = in . nextInt ( ) ; } catch ( InputMismatchException e ) { a = 0 ; in . next ( ) ; } try { b = in . nextInt ( ) ; } catch ( InputMismatchException e ) { b = 0 ; } try { c = a / b ; } catch ( ArithmeticException e ) { System . out . println ( "denominator cant be zero" ) ; } System . out . println ( a + " divided by " + b + " is " + c ) ; }
va	B	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	C	@ Override public void updateViewFromModel ( ) { this . language . removeAll ( ) ; ArrayList < String > languages = TranslationManager . getinstance ( ) . getLanguages ( ) ; for ( String language : languages ) { JMenuItem lm = new JMenuItem ( TranslationManager . getinstance ( ) . getText ( language ) ) ; lm . setActionCommand ( language ) ; lm . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuChooseLanguageActionPerformed ( evt ) ; } } ) ; this . language . add ( lm ) ; } this . liste . setListData ( presenter . getModel ( ) . getTopics ( ) . toArray ( ) ) ; }
va	D	private InteractionEvent parsePacket ( int base , int value ) { if ( value >= 129 ) { return HitEvent . singleHitOuter ( value - 128 ) ; } if ( value >= 97 ) { return HitEvent . tripleHit ( value - 96 ) ; } if ( value >= 65 ) { return HitEvent . doubleHit ( value - 64 ) ; } if ( value == 57 ) { return HitEvent . singleHitInner ( 25 ) ; } if ( value >= 33 ) { return HitEvent . singleHitInner ( value - 32 ) ; } if ( value == 4 ) { return ButtonEvent . bounceOut ( ) ; } if ( value == 3 ) { return ButtonEvent . dartMissed ( ) ; } if ( value == 1 ) { return ButtonEvent . nextPlayer ( ) ; } if ( value == 0 ) { return new ConfirmationEvent ( ) ; } return null ; }
va	B	public OutputAnimatedGif ( String file ) throws IOException { this . output = new FileImageOutputStream ( new File ( file ) ) ; this . writer = ImageIO . getImageWritersByMIMEType ( "image/gif" ) . next ( ) ; this . writer . setOutput ( output ) ; this . writer . prepareWriteSequence ( null ) ; }
va	B	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
va	E	public static PokerHandComparer resolveTieHand ( ArrayList < PokerCard > cards , ArrayList < PokerCard > newCards , int rank ) { Map < Integer , String > pokerHelper = PokerHelper . getPokerRank ( ) ; String rankDescription = pokerHelper . get ( rank ) ; if ( rankDescription == PokerRankingCatalog . CARTA_ALTA ) { return highCard ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . PAREJA ) { return pair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . DOBLE_PAREJA ) { return doublePair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . TRIO ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . COLOR ) { return color ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . FULL_HOUSE ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . POKER ) { return poker ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_DE_COLOR ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_REAL ) { return straight ( cards , newCards ) ; } return null ; }
va	C	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; while ( nextCard == null ) { nextCard = this . model . getTopic ( ) . getRandomCard ( boxToCheck ) ; if ( firstLoop ) { boxToCheck = 0 ; firstLoop = false ; } else { boxToCheck += 1 ; } if ( boxToCheck > Application . boxCount ) { break ; } } this . model = nextCard ; this . cardShown = new Date ( ) . getTime ( ) ; this . view . cardChanged ( ) ; }
va	C	private void jButtonBoxActionPerformed ( java . awt . event . ActionEvent evt ) { int box = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( presenter . getModel ( ) . getCardCount ( box ) == 0 ) { JOptionPane . showMessageDialog ( null , noCardsInBox ) ; } else { if ( beatTheClockCheckBox . isSelected ( ) ) { getPresenter ( ) . startChallenge ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } else { getPresenter ( ) . openCard ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } } }
va	E	public FeatureVector getLabeledFeatureDifference ( DependencyInstance gold , DependencyInstance pred ) { assert ( gold . heads == pred . heads ) ; if ( ! options . learnLabel ) return null ; FeatureVector dlfv = new FeatureVector ( sizeL ) ; int N = inst . length ; int [ ] actDeps = gold . heads ; int [ ] actLabs = gold . deplbids ; int [ ] predDeps = pred . heads ; int [ ] predLabs = pred . deplbids ; DependencyArcList arcLis = new DependencyArcList ( gold . heads , options . useHO ) ; for ( int mod = 1 ; mod < N ; ++ mod ) { int type = actLabs [ mod ] ; int type2 = predLabs [ mod ] ; int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head != head2 || type != type2 ) { int toR = head < mod ? 1 : 0 ; int toR2 = head2 < mod ? 1 : 0 ; dlfv . addEntries ( getLabelFeature ( arcLis , actDeps , mod , type ) ) ; dlfv . addEntries ( getLabelFeature ( arcLis , predDeps , mod , type2 ) , - 1.0 ) ; } } return dlfv ; }
va	A	public EDFWeaponCaption ( EDFCharacterController edfCharacterController ) { this . scene = edfCharacterController ; left = new Hoge ( LR . LEFT , edfCharacterController . getLeftWeapon ( ) ) ; right = new Hoge ( LR . RIGHT , edfCharacterController . getRightWeapon ( ) ) ; }
va	E	public void run ( ) { for ( int k = 0 ; k < T ; ++ k ) { for ( ; ; ) { for ( int i = 0 ; i < T ; ++ i ) visx [ i ] = false ; for ( int i = 0 ; i < T ; ++ i ) visy [ i ] = false ; if ( findPath ( k ) ) break ; double minVal = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) for ( int j = 0 ; j < T ; ++ j ) if ( ! visy [ j ] ) { double va = x [ i ] + y [ j ] - f [ i * T + j ] ; minVal = minVal > va ? va : minVal ; } Utils . assert ( minVal > 0.0 && minVal != double . POSITIVE_INFINITY ) ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) x [ i ] -= minVal ; for ( int i = 0 ; i < T ; ++ i ) if ( visy [ i ] ) y [ i ] += minVal ; } } }
va	B	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
va	C	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( true ) ; textField2 . setEnabled ( true ) ; textField3 . setEditable ( true ) ; textField3 . setEnabled ( true ) ; textField4 . setEditable ( true ) ; textField4 . setEnabled ( true ) ; jComboBox1 . setEnabled ( true ) ; jComboBox2 . setEnabled ( true ) ; list1 . setEnabled ( false ) ; jButton1 . setVisible ( false ) ; jButton2 . setVisible ( false ) ; jButton3 . setVisible ( false ) ; buttonSaveEdit . setVisible ( true ) ; Cancel . setVisible ( true ) ; }
va	B	private static Font createFont ( FontDef fontDef ) { try { InputStream is = new FileInputStream ( fontDef . filePath ) ; return Font . createFont ( Font . TRUETYPE_FONT , is ) . deriveFont ( fontDef . size ) ; } catch ( FontFormatException | IOException e ) { e . printStackTrace ( ) ; return null ; } }
va	B	public final Texture loadTexture ( final ByteBuffer buffer , int width , int height ) { try { return loadTexture ( writePixels ( buffer , width , height ) ) ; } catch ( IOException e ) { System . err . println ( ) ; e . printStackTrace ( ) ; return null ; } }
va	A	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
va	D	@ Override public String getValue ( String ligne ) { String returnValue = null ; switch ( filetype ) { case FILE_TEXT : returnValue = StringUtils . substring ( ligne , getStartposition ( ) , getStartposition ( ) + getSize ( ) ) ; break ; case FILE_CSV : String separatorChar = StringUtils . defaultString ( separateur , " " ) ; String [ ] champs = StringUtils . split ( ligne , separatorChar ) ; returnValue = champs [ getStartposition ( ) ] ; break ; default : StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Type de fichier :" ) . append ( filetype ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Startposition" ) . append ( getStartposition ( ) ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Size" ) . append ( getSize ( ) ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Ligne :" ) . append ( ligne ) ; throw new IllegalArgumentException ( sb . toString ( ) ) ; } return returnValue ; }
va	C	public static void userUpdate ( String editUserName , String editPassword , int level ) throws SQLException { String sql ; Connection conn = DbConnect . Connect ( ) ; System . out . println ( editPassword ) ; if ( editPassword . equals ( "*********" ) ) { sql = "UPDATE users SET level=" + level + " WHERE username ='" + editUserName + "'" ; } else { sql = "UPDATE users SET password='" + editPassword + "' level=" + level + " WHERE username ='" + editUserName + "'" ; } System . out . println ( sql ) ; conn . createStatement ( ) . executeUpdate ( sql ) ; }
va	E	public void addCore1OBigramFeatures ( FeatureVector fv , int head , int headP , int mod , int modP , int attDist , int type ) { long code = 0 ; int tid = type << 4 ; code = createArcCodeWWPP ( HW_MW_HP_MP , head , mod , headP , modP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWPP ( MW_HP_MP , mod , headP , modP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWPP ( HW_HP_MP , head , headP , modP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( MW_HP , mod , headP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( HW_MP , head , modP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( HW_HP , head , headP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( MW_MP , mod , modP ) | tid ; addLabeledArcFeature ( code , fv ) ; addLabeledArcFeature ( code | attDist , fv ) ; }
va	C	private void moveImportedFile ( String exportFileLocation , String fileName ) { try { File doneFolder = new File ( exportFileLocation + "article_done" ) ; if ( ! doneFolder . exists ( ) ) { doneFolder . mkdir ( ) ; } String sourceFilePath = exportFileLocation + fileName ; String doneLocation = exportFileLocation + "article_done" + File . separator + fileName ; File sourceFile = new File ( sourceFilePath ) ; if ( sourceFile . exists ( ) ) { if ( sourceFile . renameTo ( new File ( doneLocation ) ) ) { log . debug ( "Import done move file {} to done dir" , fileName ) ; } else { throw new MoveFileException ( "Can not move finish article file to done folder" ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	B	public static void main ( String [ ] args ) { System . out . print ( "C" ) ; try { a ( ) ; } catch ( Exception e ) { System . out . print ( e . getMessage ( ) ) ; } System . out . println ( "A" ) ; }
va	B	public boolean getCell ( int col , int row ) { if ( row < 0 || row >= width ) return false ; if ( col < 0 || col >= height ) return false ; return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; }
va	A	public void equipLeft ( BasicWeapon weapon ) { if ( leftWeapon != null ) { leftWeapon . dispose ( ) ; } leftWeapon = getParentScene ( ) . add ( weapon ) ; }
va	C	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; }
va	D	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue ) { if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) == Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
va	C	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; PreparedStatement ps = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; return ps ; }
va	E	public LocalFeatureData ( DependencyInstance inst , DependencyParser parser , boolean indexGoldArcs ) { this . inst = inst ; pipe = parser . pipe ; options = parser . options ; parameters = parser . parameters ; pruner = parser . pruner ; prunerDecoder = pruner == null ? null : DependencyDecoder . createDependencyDecoder ( pruner . options ) ; Utils . assert ( pruner == null || pruner . options . learningMode == LearningMode . Basic ) ; len = inst . length ; ntypes = pipe . types . length ; rank = options . R ; size = pipe . synFactory . numArcFeats ; sizeL = pipe . synFactory . numLabeledArcFeats ; gamma = options . gamma ; gammaLabel = options . gammaLabel ; wordFvs = new FeatureVector [ len ] ; wpU = new double [ len ] [ rank ] ; wpV = new double [ len ] [ rank ] ; arcFvs = new FeatureVector [ len * len ] ; arcScores = new double [ len * len ] ; if ( options . learningMode != LearningMode . Basic ) { initArcPruningMap ( indexGoldArcs ) ; initHighOrderFeatureTables ( ) ; } initFirstOrderTables ( ) ; }
va	A	public boolean isClear ( ) { if ( ! spawns . isEmpty ( ) ) { return false ; } for ( EDFEnemy enemy : spawnedEnemies ) { if ( ! enemy . isDisposed ( ) ) { return false ; } } return true ; }
va	A	@ Override public void dispose ( ) { left . dispose ( ) ; right . dispose ( ) ; }
va	A	private boolean checkGameover ( ) { if ( characterController . earthArrive ( ) ) { return false ; } GameSceneManager . getInstance ( ) . gameover ( ) ; return true ; }
va	E	private Execution parseUpdate ( Iterator < String > parts ) throws SqlParseException { String tableName = parts . next ( ) ; Table table = database . get ( tableName ) ; assertNextToken ( "set" , parts ) ; Map < String , Value > values = new HashMap < > ( ) ; String currentCol = null ; int i = 0 ; while ( parts . hasNext ( ) ) { String part = parts . next ( ) ; if ( "where" . equals ( part ) ) { break ; } switch ( i ++ % 4 ) { case 0 : currentCol = part ; break ; case 1 : assertToken ( "=" , part ) ; break ; case 2 : values . put ( currentCol , parseValue ( part , currentCol , table ) ) ; break ; case 3 : assertToken ( " " , part ) ; break ; default : throw new AssertionError ( ) ; } } if ( values . isEmpty ( ) ) { throw new SqlParseException ( "Must update at least one column in UPDATE statment" ) ; } Predicate < Tuple > predicate = parsePredicate ( parts ) ; return Execution . forModification ( ( ) -> { return Modification . update ( table . update ( values , predicate ) ) ; } ) ; }
va	C	@ Override public void confirm ( ) { if ( this . model . getAnswer ( ) . equals ( "" ) || this . model . getQuestion ( ) . equals ( "" ) ) { this . view . fieldsNotSet ( ) ; } else { this . model . getTopic ( ) . addCard ( this . model ) ; Card card = new CardImpl ( ) ; card . setTopic ( this . model . getTopic ( ) ) ; this . model = card ; this . view . updateViewFromModel ( ) ; this . onConfirm . refresh ( ) ; } }
va	E	private void drawBody ( Graphics2D g , int offsetX , int offsetY ) { Point2D . double p1 = body . body . get ( 0 ) ; Point2D . double p2 = body . body . get ( 1 ) ; Point2D . double p3 = body . body . get ( 2 ) ; Point2D . double p4 = body . body . get ( 3 ) ; g . drawLine ( ( int ) p1 . x + offsetX , ( int ) p1 . y + offsetY , ( int ) p2 . x + offsetX , ( int ) p2 . y + offsetY ) ; g . drawLine ( ( int ) p2 . x + offsetX , ( int ) p2 . y + offsetY , ( int ) p3 . x + offsetX , ( int ) p3 . y + offsetY ) ; g . drawLine ( ( int ) p3 . x + offsetX , ( int ) p3 . y + offsetY , ( int ) p4 . x + offsetX , ( int ) p4 . y + offsetY ) ; g . drawLine ( ( int ) p4 . x + offsetX , ( int ) p4 . y + offsetY , ( int ) p1 . x + offsetX , ( int ) p1 . y + offsetY ) ; }
va	D	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x >= 0 ) && ( x < width ) ) && ( ( y >= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] == MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] != MapTile . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
va	E	public int numDecodings ( String s ) { int total , singleEnds , doubleEnds ; if ( s == null || s . equals ( "" ) ) return 0 ; if ( s . length ( ) == 1 ) { if ( s . charAt ( 0 ) < 1 || s . charAt ( 0 ) > 9 ) return 0 ; else return 1 ; } char currChar , prevChar = s . charAt ( 0 ) ; singleEnds = 1 ; doubleEnds = 0 ; total = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { currChar = s . charAt ( i ) ; if ( currChar == 0 && prevChar != 0 ) { total -= doubleEnds ; doubleEnds = total ; singleEnds = 0 ; } else if ( currChar >= 1 && currChar <= 9 ) { if ( prevChar == 0 && singleEnds != 0 ) return 0 ; int combined = ( prevChar - 0 ) * 10 + currChar - 0 ; if ( combined <= 26 && combined >= 1 ) { total += singleEnds ; doubleEnds = singleEnds ; singleEnds = total - doubleEnds ; } else { singleEnds = total ; doubleEnds = 0 ; } } else return 0 ; prevChar = currChar ; } return total ; }
va	D	private GameText ( ) { File textFolder = new File ( TEXT_FOLDER ) ; if ( ( textFolder . exists ( ) ) && ( textFolder . isDirectory ( ) ) ) { File [ ] fileList = textFolder . listFiles ( ) ; for ( int i = 0 ; i < fileList . length ; i ++ ) { if ( fileList [ i ] . isFile ( ) ) { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( fileList [ i ] ) ; br = new BufferedReader ( fs ) ; String complete = "" ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { complete = complete + nextLine + "\n" ; nextLine = br . readLine ( ) ; } textMapping . put ( fileList [ i ] . getName ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { System . out . println ( "Warning! Failed to add a text file." ) ; e . printStackTrace ( ) ; } } } } }
va	A	@ Override public void render ( ) { weaponView . render ( ) ; remainBulletView . render ( ) ; }
va	E	public String addBinary ( String a , String b ) { if ( a == null || b == null ) return null ; int lena = a . length ( ) , lenb = b . length ( ) ; if ( lena < lenb ) { lenb = lena ; lena = b . length ( ) ; String tmp = a ; a = b ; b = tmp ; } char [ ] result = new char [ lena ] ; int carry = 0 ; for ( int i = lena - 1 ; i >= 0 ; i -- ) { int add = carry + a . charAt ( i ) - 0 ; if ( i >= lena - lenb ) add += b . charAt ( i - lena + lenb ) - 0 ; if ( ( char ) ( add % 2 ) > 0 ) result [ i ] = 1 ; else result [ i ] = 0 ; carry = add / 2 ; } if ( carry > 0 ) return "1" + new String ( result ) ; else return new String ( result ) ; }
va	B	private TestArrayWorld nextGeneration ( ) { TestArrayWorld world = new TestArrayWorld ( this ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	E	@ Override public void run ( ) { converge = options . numHcConverge ; earlyStop = options . earlyStop ; double goldScore = - double . MAX_VALUE ; if ( addLoss ) { goldScore = calcScore ( inst ) ; } DependencyInstance now = new DependencyInstance ( inst ) ; while ( ! stopped ) { SemanticFrame [ ] predFrames = new SemanticFrame [ numframes ] ; SemanticFrame [ ] frames = inst . frames ; TIntArrayList [ ] args = getArgs ( ) ; for ( int i = 0 ; i < numframes ; ++ i ) { predFrames [ i ] = sequentialSampling ( frames [ i ] , goldlbids [ i ] , sfd , i , args [ i ] ) ; } now . frames = predFrames ; hillClimbing ( now , args ) ; double score = calcScore ( now ) ; synchronized ( pred ) { ++ totRuns ; if ( score > bestScore ) { bestScore = score ; if ( addLoss && unchangedRuns >= earlyStop + options . numHcThreads && bestScore >= goldScore + 1e-6 ) System . out . print ( "(" + unchangedRuns + ") " ) ; unchangedRuns = 0 ; pred . frames = now . frames ; } else { ++ unchangedRuns ; if ( unchangedRuns >= converge ) stopped = true ; if ( addLoss && unchangedRuns >= earlyStop && bestScore >= goldScore + 1e-6 ) stopped = true ; } } } }
va	C	public static void main ( String [ ] args ) { DatagramPacket pac ; byte [ ] msg ; int PORT = 7 ; try { DatagramSocket s = new DatagramSocket ( ) ; InetAddress ad = InetAddress . getByName ( "127.0.0.1" ) ; while ( true ) { msg = new byte [ 50 ] ; System . out . println ( "Enter: " ) ; System . in . read ( msg ) ; pac = new DatagramPacket ( msg , 50 , ad , PORT ) ; s . send ( pac ) ; msg = new byte [ 50 ] ; pac = new DatagramPacket ( msg , 50 ) ; s . receive ( pac ) ; System . out . println ( msg ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	C	public static String [ ] [ ] getUsers ( ) throws SQLException { ResultSet rsUsers ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from users" ; rsUsers = conn . createStatement ( ) . executeQuery ( sql ) ; rsUsers . last ( ) ; String users [ ] [ ] = new String [ rsUsers . getRow ( ) ] [ 2 ] ; rsUsers . beforeFirst ( ) ; while ( rsUsers . next ( ) ) { users [ rsUsers . getRow ( ) - 1 ] [ 0 ] = rsUsers . getString ( "username" ) ; users [ rsUsers . getRow ( ) - 1 ] [ 1 ] = rsUsers . getString ( "level" ) ; } return users ; } }
va	D	public static void init ( ) { driveTrain = new DriveTrain ( ) ; feeder = new Feeder ( ) ; shooter = new Shooter ( ) ; compressor = new PurpleCompressor ( ) ; feederSolenoid = new FeederSolenoid ( ) ; driveSolenoid = new DriveSolenoid ( ) ; oi = new OI ( ) ; SmartDashboard . putData ( "Toggle Feeder" , new ToggleFeeder ( ) ) ; SmartDashboard . putData ( "Manage Feeder" , new ManageFeeder ( ) ) ; SmartDashboard . putData ( "Reverse Feeder" , new ReverseFeeder ( ) ) ; SmartDashboard . putBoolean ( "ShooterIsIn" , true ) ; SmartDashboard . putData ( "EncodersReset" , new EncodersReset ( ) ) ; SmartDashboard . putNumber ( "LeftEncoder" , driveTrain . left . getD ( ) ) ; SmartDashboard . putNumber ( "RightEncoder" , driveTrain . right . getD ( ) ) ; SmartDashboard . putNumber ( "LeftDriveScale" , driveTrain . leftScale ) ; SmartDashboard . putNumber ( "RightDriveScale" , driveTrain . rightScale ) ; }
va	E	private Predicate < Tuple > parsePredicate ( Iterator < String > parts ) throws SqlParseException { String part = parts . next ( ) ; if ( "not" . equals ( part ) ) { return parsePredicate ( parts ) . negate ( ) ; } if ( "(" . equals ( part ) ) { Predicate < Tuple > left = parsePredicate ( parts ) ; boolean and = parseAndOr ( parts ) ; Predicate < Tuple > right = parsePredicate ( parts ) ; assertNextToken ( ")" , parts ) ; return and ? left . and ( right ) : left . or ( right ) ; } String colName = part ; List < PredicatePart > pps = new ArrayList < > ( ) ; String val = null ; while ( parts . hasNext ( ) ) { part = parts . next ( ) ; PredicatePart pp = PredicatePart . PARTS . get ( part ) ; if ( pp != null ) { pps . add ( pp ) ; } else { val = part ; break ; } } PredicateType type = PredicateType . PARTS_MAP . get ( pps ) ; if ( type == null ) { throw new SqlParseException ( "Unknown predicate in WHERE clause" ) ; } return type . makePredicate ( colName , val ) ; }
va	C	@ Override public void updateViewFromModel ( ) { this . topicname . setText ( this . presenter . getModel ( ) . getTopic ( ) . getName ( ) ) ; this . boxnumber . setText ( Integer . toString ( this . presenter . getModel ( ) . getBox ( ) ) ) ; this . questionWord . setText ( this . presenter . getModel ( ) . getQuestion ( ) ) ; this . lastTime . setText ( long . toString ( this . presenter . getModel ( ) . getSpentTime ( ) ) + " ms" ) ; this . curTime . setText ( 0 + " ms" ) ; }
va	A	@ Override public void render ( ) { super . render ( ) ; hpCaption . render ( ) ; }
va	D	public BasicInfo ( Date birthday , int s , int curYear ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( birthday ) ; yinLi = birthday ; year = calendar . get ( Calendar . YEAR ) ; month = calendar . get ( Calendar . MONTH ) ; day = calendar . get ( Calendar . DAY_OF_MONTH ) ; hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; sex = s ; age = curYear - year + 1 ; shiChen = ShiChenBiao . getShiChenByHour ( hour ) ; tianGan = LiuShiJiaZiBiao . getTianGanByYear ( year ) ; diZhi = LiuShiJiaZiBiao . getDiZhiByYear ( year ) ; yinYang = LiuShiJiaZiBiao . getYinYangByYear ( year ) ; mingZhu = MingShenZhuBiao . mingZhuBiao [ diZhi ] ; shenZhu = MingShenZhuBiao . shenZhuBiao [ diZhi ] ; nowTianGan = LiuShiJiaZiBiao . getTianGanByYear ( curYear ) ; nowDiZhi = LiuShiJiaZiBiao . getDiZhiByYear ( curYear ) ; }
va	A	public void equipRight ( BasicWeapon weapon ) { if ( rightWeapon != null ) { rightWeapon . dispose ( ) ; } rightWeapon = getParentScene ( ) . add ( weapon ) ; }
va	D	private void renderDisabledState ( Graphics2D context ) { context . setColor ( this . getColor ( ) ) ; context . fillRect ( this . getX ( ) + this . getBorderSize ( ) , this . getY ( ) + this . getBorderSize ( ) , this . getWidth ( ) / 2 - this . getBorderSize ( ) , this . getHeight ( ) - 2 * this . getBorderSize ( ) ) ; this . label . setText ( "0" ) ; this . label . horizontalAlignCenter ( this . getY ( ) , this . getY ( ) + this . getHeight ( ) ) ; this . label . verticalAlignCenter ( this . getX ( ) + this . getWidth ( ) / 2 , this . getX ( ) + this . getWidth ( ) ) ; this . label . render ( context ) ; }
va	D	protected void makeActions ( IWorkbenchWindow window ) { register ( ActionFactory . QUIT . create ( window ) ) ; register ( ActionFactory . OPEN_NEW_WINDOW . create ( window ) ) ; register ( ActionFactory . EDIT_ACTION_SETS . create ( window ) ) ; register ( ActionFactory . PREFERENCES . create ( window ) ) ; register ( ActionFactory . SAVE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . RESET_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_ALL_PERSPECTIVES . create ( window ) ) ; IWorkbenchAction help = ActionFactory . DYNAMIC_HELP . create ( window ) ; help . setText ( Messages . App_Action_Help ) ; register ( help ) ; IWorkbenchAction intro = ActionFactory . INTRO . create ( window ) ; intro . setText ( Messages . App_Action_Intro ) ; register ( intro ) ; IWorkbenchAction about = ActionFactory . ABOUT . create ( window ) ; about . setText ( Messages . App_Action_About ) ; register ( about ) ; }
va	B	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; create ( world , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; }
va	A	private void moveStart ( float huga ) { dashSpeed = huga ; dashStartFrame = FPSManager . totalFrame ( ) ; }
va	B	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; }
va	C	private void jMenuItemExportProfileActionPerformed ( java . awt . event . ActionEvent evt ) { String name = liste . getSelectedValue ( ) . toString ( ) ; if ( name != "" && name != null ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer topic" , "topic" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showSaveDialog ( null ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".topic" ) ) { path = path + ".topic" ; } getPresenter ( ) . exportTopic ( name , path ) ; } } }
va	D	@ Override public void update ( ) { super . update ( ) ; Point destination = toPixel ( getBoardPosition ( ) ) ; if ( Math . abs ( destination . x - getX ( ) ) > 1 || Math . abs ( destination . y - getY ( ) ) > 1 ) { float dx = 0 ; float dy = 0 ; long tmp = Timer . getTime ( ) - last ; dx = ( float ) easeInOut ( tmp , getX ( ) , destination . x - getX ( ) , 600 ) ; dy = ( float ) easeInOut ( tmp , getY ( ) , destination . y - getY ( ) , 600 ) ; setLocation ( dx , dy ) ; } else { setLocation ( destination . x , destination . y ) ; last = 0 ; } }
va	B	public void insert ( char x ) { hp . add ( x ) ; for ( int i = hp . size ( ) - 1 ; x > hp . get ( ( i - 1 ) / 2 ) ; i = ( i - 1 ) / 2 ) { hp . set ( i , hp . get ( ( i - 1 ) / 2 ) ) ; hp . set ( ( i - 1 ) / 2 , x ) ; } }
va	B	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
va	A	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.5f , 0.8f ) ) ; }
va	C	public static String [ ] logIn ( ) throws SQLException { String [ ] loggedIn = new String [ 3 ] ; try { try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from users where username='" + userName + "' and password ='" + password + "'" ; ResultSet rs = conn . createStatement ( ) . executeQuery ( sql ) ; if ( rs . next ( ) ) { loggedIn [ 0 ] = "true" ; loggedIn [ 1 ] = userName ; loggedIn [ 2 ] = rs . getString ( "level" ) ; } else { loggedIn [ 0 ] = "false" ; System . out . println ( "Nope didnt work" ) ; } conn . close ( ) ; } return loggedIn ; } catch ( SQLException e ) { } return loggedIn ; }
va	D	public void wizardMode ( ) { if ( JOptionPane . showConfirmDialog ( null , "Activate Wizard Mode? (This will set your score to 0)" , "Wizard Mode" , JOptionPane . YES_NO_OPTION ) == JOptionPane . YES_OPTION ) { player . setWizardUsed ( true ) ; player . setCurrentHP ( 9999 ) ; player . setMaxHP ( 9999 ) ; player . setNaturalAC ( 50 ) ; player . setAttackBonus ( 50 ) ; player . setBaseDamage ( 100 ) ; player . setStrength ( 100 ) ; player . setDexterity ( 20 ) ; player . increaseNutrition ( 90000 ) ; EntityCreator creator = Controller . getInstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . addItem ( creator . createFood ( "spice" ) ) ; player . addItem ( creator . createArmour ( "space marine armour" ) ) ; player . addItem ( creator . createWeapon ( "lightsaber" ) ) ; Controller . getInstance ( ) . updatePlayerStatus ( ) ; println ( "By the Power of Grayskull  I HAVE THE POWER." ) ; } }
va	D	public void fieldOfView ( boolean visible ) { Point start = new Point ( player . getLocation ( ) . getColumn ( ) - player . getSightRange ( ) , player . getLocation ( ) . getRow ( ) - player . getSightRange ( ) ) ; for ( int i = 0 ; i < player . getSightRange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getSightRange ( ) * 2 ; j ++ ) { Point target = new Point ( start . x + i , start . y + j ) ; if ( map . boundaryCheck ( target ) ) { if ( lineOfSight ( player , map . getTile ( target ) ) ) { Tile tile = map . getTile ( target ) ; tile . setDiscovered ( true ) ; tile . setVisible ( visible ) ; if ( tile . getOccupant ( ) != null ) tile . getOccupant ( ) . setInSight ( visible ) ; messenger . updateTile ( target ) ; } } } } }
va	D	@ Test public void testUndoOfNextPlayerEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; Player p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == one ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; int c = game . getScores ( ) . get ( two ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 301   was" + c , c == 301 ) ; }
va	C	private void jMenuItemSaveProfileAsActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer profile" , "profile" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showDialog ( null , "Speichere Profil" ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".profile" ) ) { path = path + ".profile" ; } getPresenter ( ) . saveProfile ( path ) ; } }
va	A	private void processLeftMove ( ) { if ( ! LEFT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) + ROTATE_SPEED ) ; }
va	D	@ Override public void onResponse ( ReportActualPositionResponse response ) { double [ ] displacement = new double [ motors . length ] ; for ( int i = 0 ; i < motors . length ; i ++ ) { Motor motor = motors [ i ] ; int count = response . getEncoderCount ( ) [ i ] ; if ( i >= motors . length / 2 ) count = - count ; double lastPosition = motor . getPosition ( ) ; motor . setEncoderCount ( count ) ; motor . setPosition ( MotorUtils . countsToDistance ( count ) ) ; displacement [ i ] = motor . getPosition ( ) - lastPosition ; } double left = displacement [ displacement . length / 2 ] ; double right = displacement [ 0 ] ; if ( left != 0 && right != 0 ) { getPosition ( ) . move ( left , right ) ; if ( positionListener != null ) positionListener . onNewPosition ( getPosition ( ) , response . getTimestamp ( ) ) ; } latch . countDown ( ) ; }
va	D	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
va	E	public int [ ] findPPArg ( int [ ] heads , SpecialPos [ ] specialPos , DependencyArcList arclis , int arg ) { int st = arclis . startIndex ( arg ) ; int ed = arclis . endIndex ( arg ) ; int c = st == ed ? - 1 : arclis . get ( st ) ; int c2 = - 1 ; if ( c != - 1 && specialPos [ c ] == SpecialPos . C ) { if ( ccDepType == 0 ) { c2 = findRightNearestChild ( arclis , c , c ) ; c = findLeftNearestChild ( arclis , c , c ) ; } else if ( ccDepType == 1 ) { } else if ( ccDepType == 2 ) { c = findRightNearestChild ( arclis , arg , c ) ; } } int len = 0 ; int head = heads [ arg ] ; if ( c != - 1 && c != head ) len ++ ; if ( c2 != - 1 && c2 != head ) len ++ ; int [ ] ret = new int [ len ] ; len = 0 ; if ( c != - 1 && c != head ) { ret [ len ] = c ; len ++ ; } if ( c2 != - 1 && c2 != head ) { ret [ len ] = c2 ; len ++ ; } return ret ; }
va	D	@ Override public void update ( ) { int width = Game . getInstance ( ) . getWindow ( ) . getWidth ( ) ; int height = Game . getInstance ( ) . getWindow ( ) . getHeight ( ) ; this . header . verticalAlignCenter ( 0 , width ) ; this . btnCollection . verticalAlignCenter ( 0 , width ) ; this . btnCollection . horizontalAlignCenter ( 0 , height ) ; int counter = 0 ; this . btnCollection . update ( ) ; for ( TEView view : this . btnCollection . getCollection ( ) ) { TEButton btn = ( TEButton ) view ; if ( btn . isClicked ( ) ) { switch ( counter ) { case 0 : Game . getInstance ( ) . loadScene ( Scene . SCENE_SETTINGS ) ; return ; case 1 : Game . getInstance ( ) . loadScene ( SCENE_CREDITS ) ; return ; } } counter ++ ; } }
va	C	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; users = DbUtil . getUsers ( ) ; for ( int i = 0 ; i < users . length ; i ++ ) { if ( users [ i ] [ 1 ] . equals ( "1" ) ) { list1 . add ( users [ i ] [ 0 ] ) ; } else { list1 . add ( users [ i ] [ 0 ] ) ; } } ButtonSaveEdit . setVisible ( false ) ; ButtonSaveNew . setVisible ( false ) ; ButtonSaveDelete . setVisible ( false ) ; }
va	B	private AgingWorld ( AgingWorld w ) { super ( w ) ; world = new int [ w . getHeight ( ) ] [ w . getWidth ( ) ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
va	E	public FeatureVector createNeighborFeatureVector ( DependencyInstance s , int par , int id , int left , int right ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int HP = s . postagids [ id ] ; int HC = s . cpostagids [ id ] ; int HL = s . lemmaids != null ? s . lemmaids [ id ] : s . formids [ id ] ; int GC = s . cpostagids [ par ] ; int GL = s . lemmaids != null ? s . lemmaids [ par ] : s . formids [ par ] ; long code = 0 ; code = createArcCodePPP ( NB_HP_LC_RC , HP , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodePPP ( NB_HC_LC_RC , HC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( NB_HL_LC_RC , HL , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodePPPP ( NB_GC_HC_LC_RC , GC , HC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPPP ( NB_GC_HL_LC_RC , HL , GC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPPP ( NB_GL_HC_LC_RC , GL , HC , left , right ) ; addArcFeature ( code , fv ) ; return fv ; }
va	B	private boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	C	public static String [ ] loadCompanySetup ( ) throws SQLException { String [ ] setup = new String [ 5 ] ; ResultSet rsSetup ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from company_setup limit 1" ; rsSetup = conn . createStatement ( ) . executeQuery ( sql ) ; rsSetup . next ( ) ; setup [ 0 ] = rsSetup . getString ( "business_number" ) ; setup [ 1 ] = rsSetup . getString ( "company_name" ) ; setup [ 2 ] = rsSetup . getString ( "company_address" ) ; setup [ 3 ] = rsSetup . getString ( "company_phone" ) ; setup [ 4 ] = rsSetup . getString ( "tax_rate" ) ; return setup ; } }
va	C	@ Override public boolean check ( String answer ) { this . statisticDateLastLearned = new java . util . Date ( ) . getTime ( ) ; if ( answer . equals ( this . answer ) ) { this . statisticCountRight += 1 ; this . moveUp ( ) ; System . out . println ( "answer true" ) ; System . out . println ( "Count right: " + statisticCountRight ) ; return true ; } System . out . println ( "answer false" ) ; this . statisticCountWrong += 1 ; this . setBox ( 1 ) ; System . out . println ( "Count wrong " + statisticCountWrong ) ; return false ; }
va	C	public static void main ( String aa [ ] ) { int [ ] array = new int [ 5 ] ; for ( int i = 4 ; i < 9 ; i ++ ) { array [ i - 4 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) System . out . print ( array [ i ] ) ; System . out . println ( ) ; array = rotate ( array , 2 ) ; for ( int i = 0 ; i < array . length ; i ++ ) System . out . print ( array [ i ] ) ; }
va	B	private static List < Pattern > getResults ( String path ) throws IOException , PatternFormatException { List < Pattern > results = null ; if ( path . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( path ) ; } else { results = PatternLoader . loadFromDisk ( path ) ; } return results ; }
va	A	public FlowerStormScene ( ) { BackGroundColor . WHITE . set ( ) ; flowerTexture = new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ; }
va	E	private JPanel createDialogMenu ( ) { JPanel configPanel = new JPanel ( new GridLayout ( 5 , 2 , 2 , 2 ) ) ; addActionConfig ( configPanel , parent . moveLeft ) ; addActionConfig ( configPanel , parent . moveRight ) ; JPanel bottomPanel = new JPanel ( new FlowLayout ( ) ) ; okButton = new JButton ( "OK" ) ; okButton . setFocusable ( false ) ; okButton . addActionListener ( this ) ; bottomPanel . add ( okButton ) ; JPanel topPanel = new JPanel ( new FlowLayout ( ) ) ; topPanel . add ( new JLabel ( KEYBOARD_INSTRUCTIONS ) ) ; Border border = BorderFactory . createLineBorder ( Color . black ) ; dialog = new JPanel ( new BorderLayout ( ) ) ; dialog . add ( topPanel , BorderLayout . NORTH ) ; dialog . add ( configPanel , BorderLayout . CENTER ) ; dialog . add ( bottomPanel , BorderLayout . SOUTH ) ; dialog . setBorder ( border ) ; dialog . setVisible ( false ) ; dialog . setSize ( dialog . getPreferredSize ( ) ) ; dialog . setLocation ( ( screen . getWidth ( ) - dialog . getWidth ( ) ) / 2 , ( screen . getHeight ( ) - dialog . getHeight ( ) ) / 2 ) ; return dialog ; }
va	C	@ Override public RecordSiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { RecordSiteStatModel model = new RecordSiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setUniqueVisitorDate ( new DateTime ( rs . getLong ( "uniquevisitordate" ) ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setPageViewDate ( new DateTime ( rs . getLong ( "pageviewdate" ) ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setVisitDate ( new DateTime ( rs . getLong ( "visitdate" ) ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
va	D	public GameWindow ( String title , int width , int height ) { this . frame = new JFrame ( title ) ; JPanel panel = ( JPanel ) this . frame . getContentPane ( ) ; panel . setPreferredSize ( new Dimension ( width , height ) ) ; setBounds ( 0 , 0 , width , height ) ; panel . add ( this ) ; this . setIgnoreRepaint ( true ) ; this . frame . setResizable ( false ) ; this . frame . setVisible ( true ) ; this . frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; this . frame . pack ( ) ; this . frame . setLocationRelativeTo ( null ) ; this . requestFocus ( ) ; this . createBufferStrategy ( 2 ) ; this . strategy = this . getBufferStrategy ( ) ; }
va	A	private SceneCollection ( Key trigger , class < ? extends GameScene > callClass ) { this . trigger = trigger ; this . sceneClass = callClass ; }
va	A	@ Override public void inputProcess ( ) { processLeftMove ( ) ; processRightMove ( ) ; rocessBackToEarth ( ) ; processShoot ( ) ; }
va	B	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
va	A	@ Override public void update ( ) { super . update ( ) ; updateText ( getCaption ( scene . getMoney ( ) ) ) ; }
va	B	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
va	A	private static void createDisplay ( ) { try { Display . setDisplayMode ( new DisplayMode ( WINDOW_WIDTH , WINDOW_HEIGHT ) ) ; Display . setTitle ( PRODUCT_TITLE ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; } }
va	E	public Engine ( Ship parent , int engineNum ) { this . parent = parent ; this . engineNum = engineNum ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; int totalPoints = parent . speed + ( parent . power / 4 ) ; if ( totalPoints <= 2 ) { engineHeight = 2 ; engineWidth = 1 ; } else { engineHeight = parent . map ( totalPoints , 1 , 1250 , 2 , 24 ) ; engineWidth = parent . map ( totalPoints , 1 , 1250 , 2 , 6 ) ; } engineHeight *= Ship . PIXEL_PER_UNIT ; engineWidth *= Ship . PIXEL_PER_UNIT ; if ( engineNum == 0 ) { eAtt = parent . body . e1Att ; } else { eAtt = parent . body . e2Att ; } engine = new ArrayList < Point2D . double > ( ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; }
va	A	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == null ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
va	A	@ Override public void update ( ) { if ( checkPause ( ) || checkGameover ( ) ) { return ; } super . update ( ) ; }
va	D	public void start ( ) { if ( ! isStarted ( ) ) { try { Properties p = new Properties ( ) ; p . setProperty ( DerbyConstantes . USER , DerbyConstantes . USER_VALUE ) ; p . setProperty ( DerbyConstantes . PASSWORD , DerbyConstantes . PASSWORD_VALUE ) ; p . setProperty ( "create" , "true" ) ; Connection conn = DriverManager . getConnection ( DerbyConstantes . URL , p ) ; Properties p2 = new Properties ( ) ; p2 . setProperty ( DerbyConstantes . USER , DerbyConstantes . USER_VALUE ) ; p2 . setProperty ( DerbyConstantes . PASSWORD , DerbyConstantes . PASSWORD_VALUE ) ; Connection conn2 = DriverManager . getConnection ( DerbyConstantes . URL , p2 ) ; conn2 . close ( ) ; CreateSchema . createSchema ( conn , DerbyConstantes . SCHEMA_NAME ) ; conn . close ( ) ; setStarted ( true ) ; LOGGER . log ( Level . INFO , "Derby is started." ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Erreur non pr\u00E9vu : " , e ) ; } } else { LOGGER . log ( Level . WARNING , "Derby is even started." ) ; } }
va	B	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return cells [ row ] [ col ] ; } else { return false ; } }
va	E	@ Override public Set < Entry < K , V >> entrySet ( ) { return new AbstractSet < Entry < K , V >> ( ) { @ Override public Iterator < Entry < K , V >> iterator ( ) { final Iterator < K > keyIt = keys . iterator ( ) ; return new Iterator < Entry < K , V >> ( ) { Entry < K , V > next = null ; @ Override public boolean hasNext ( ) { if ( next == null ) { if ( keyIt . hasNext ( ) ) { K key = keyIt . next ( ) ; next = new AbstractMap . SimpleImmutableEntry < > ( key , map . get ( key ) ) ; return true ; } return false ; } return true ; } @ Override public Entry < K , V > next ( ) { if ( hasNext ( ) ) { Entry < K , V > ret = next ; next = null ; return ret ; } throw new NoSuchElementException ( ) ; } } ; } @ Override public int size ( ) { return OrderedSubsetUnmodifiableMap . this . size ( ) ; } } ; }
va	D	public String writeEnd ( ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|  ---------------------------------------------------------------------------+" ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|" ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_SELECT" ) + "     : " + nbSelected ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_INSERT" ) + "      : " + nbInsert ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_UPDATE" ) + "      : " + nbUpdate ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_DELETE" ) + "     : " + nbDelete ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|" ) ; return sb . toString ( ) ; }
va	E	private FeatureVector getdW ( int k , LocalFeatureData lfd , int [ ] actDeps , int [ ] predDeps ) { double [ ] [ ] wpU = lfd . wpU , wpV = lfd . wpV ; FeatureVector [ ] wordFvs = lfd . wordFvs ; int L = wordFvs . length ; double [ ] dW = new double [ D ] ; for ( int mod = 1 ; mod < L ; ++ mod ) { int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head == head2 ) continue ; int d = getBinnedDistance ( head - mod ) ; int d2 = getBinnedDistance ( head2 - mod ) ; double dotu = wpU [ head ] [ k ] ; double dotu2 = wpU [ head2 ] [ k ] ; double dotv = wpV [ mod ] [ k ] ; dW [ 0 ] += ( dotu - dotu2 ) * dotv ; dW [ d ] += dotu * dotv ; dW [ d2 ] -= dotu2 * dotv ; } FeatureVector dW2 = new FeatureVector ( D ) ; for ( int i = 0 ; i < D ; ++ i ) dW2 . addEntry ( i , dW [ i ] ) ; return dW2 ; }
va	B	@ Override public ArrayWorld nextGeneration ( ) { ArrayWorld world = new ArrayWorld ( this ) ; for ( int row = 0 ; row < world . getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < world . getHeight ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	B	public static void main ( String [ ] args ) { char c ; MaxHeap h = new MaxHeap ( h , "CAMBRIDGEALGORITHMS" ) ; c = h . getMax ( ) ; System . out . println ( c ) ; h . insert ( Z ) ; h . insert ( A ) ; c = h . getMax ( ) ; System . out . println ( c ) ; c = h . getMax ( ) ; System . out . println ( c ) ; }
va	C	@ Override public void open ( ) { TranslationManager . getinstance ( ) . addListener ( this ) ; translate ( ) ; setVisible ( true ) ; this . answerField . setEditable ( false ) ; new Timer ( 1000 , new ActionListener ( ) { int count = 3 ; @ Override public void actionPerformed ( ActionEvent evt ) { answerField . setText ( "Ready in: " + Integer . toString ( count ) ) ; if ( count <= - 1 ) { ( ( Timer ) evt . getSource ( ) ) . stop ( ) ; presenter . nextCard ( ) ; answerField . setText ( "" ) ; answerField . setEditable ( true ) ; answerField . requestFocus ( ) ; timer . start ( ) ; } count -= 1 ; } } ) . start ( ) ; }
va	A	private Color getCaptionColor ( float hp ) { return new Color ( 255 , ( int ) ( hp * 17.5 ) , ( int ) ( hp * 17.5 ) ) ; }
va	A	@ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingObject ) { return characterController . add ( go ) ; } return super . add ( go ) ; }
va	B	private int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	E	public void shouldSelectColumnsNotAllAliasedColumnsRepeatedWithAlias ( ) { Relation all = parser . parse ( "select baz one  foo  bar three  baz  foo two  bar four from table_1;" ) . executeQuery ( ) ; Object [ ] [ ] expectedTable = new Object [ ] [ ] { { "testing" , 15.46 , 17 , "testing" , 15.46 , 17 } , { "foo" , 13.0 , 27 , "foo" , 13.0 , 27 } , { "this" , 57735.12 , 1 , "this" , 57735.12 , 1 } , { "is" , 0.0007 , 3486978 , "is" , 0.0007 , 3486978 } , { "testing" , 1556.345 , 8975 , "testing" , 1556.345 , 8975 } } ; Map < String , ColumnDefinition > newColDefs = new LinkedHashMap < > ( ) ; newColDefs . put ( "one" , colDefs . get ( "baz" ) ) ; newColDefs . put ( "foo" , colDefs . get ( "foo" ) ) ; newColDefs . put ( "three" , colDefs . get ( "bar" ) ) ; newColDefs . put ( "baz" , colDefs . get ( "baz" ) ) ; newColDefs . put ( "two" , colDefs . get ( "foo" ) ) ; newColDefs . put ( "four" , colDefs . get ( "bar" ) ) ; assertRelationsEqual ( all , toRelation ( newColDefs , expectedTable ) ) ; }
va	E	public void filterDictionary ( DictionaryTypes tag , float % ) { int t = tag . ordinal ( ) ; int [ ] values = counters [ t ] . values ( ) ; int n = values . length ; Arrays . sort ( values ) ; float sum = 0.0f ; for ( int i = 0 ; i < n ; ++ i ) sum += values [ i ] ; int cut = 0 ; float cur = 0.0f ; for ( int i = n - 1 ; i >= 0 ; -- i ) { cur += values [ i ] ; if ( cur >= sum * % ) { cut = values [ i ] ; break ; } } Dictionary filtered = new Dictionary ( ) ; initDict ( tag , filtered ) ; for ( Object obj : dicts [ t ] . toArray ( ) ) { int id = dicts [ t ] . lookupIndex ( obj ) ; int value = counters [ t ] . get ( id ) ; if ( value > cut ) { filtered . lookupIndex ( ( String ) obj ) ; } } System . out . println ( "Filtered " + tag + " (" + dicts [ t ] . size ( ) + "-->" + filtered . size ( ) + ")" ) ; dicts [ t ] = filtered ; }
va	A	public void update ( float wind ) { setX ( getX ( ) + ( wind * getScale ( ) ) ) ; if ( getPixcelY ( ) > HEIGHT + getHeight ( ) / 2 ) { setDispose ( ) ; } super . update ( ) ; }
va	A	private String getRemainBullet ( ShootingWeaponCharacter weapon ) { return weapon . getRemainBullet ( ) + " / " + weapon . getMaxCharge ( ) ; }
va	A	private void processDash ( ) { setAngle ( getAngle ( ) + dashSpeed ) ; dashSpeed -= ( dashSpeed * 0.1 ) + Math . signum ( dashSpeed ) * 0.1 ; if ( Math . abs ( dashSpeed ) < 0.1 ) { dashSpeed = 0 ; } }
va	B	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
va	D	public static Rectangle rectFromPoints ( Point p1 , Point p2 ) { if ( p1 . x > p2 . x ) { Point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y <= p2 . y ) { return new Rectangle ( p1 . x , p1 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new Rectangle ( p1 . x , p2 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
va	E	public String addString ( String s1 , String s2 ) { StringBuilder builder = new StringBuilder ( ) ; if ( s1 . length ( ) > s2 . length ( ) ) { String tmp = s1 ; s1 = s2 ; s2 = tmp ; } int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int carry = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int sum = ( s1 . charAt ( i ) - 0 ) + ( s2 . charAt ( len2 - len1 + i ) - 0 ) + carry ; builder . append ( sum % 10 ) ; carry = sum / 10 ; } for ( int i = len2 - len1 - 1 ; i >= 0 ; i -- ) { int sum = s2 . charAt ( i ) - 0 + carry ; builder . append ( sum % 10 ) ; carry = sum / 10 ; } if ( carry > 0 ) builder . append ( carry ) ; builder . reverse ( ) ; return builder . toString ( ) ; }
va	E	private static List < ? extends Tuple > toList ( Object [ ] [ ] table ) { List < Tuple > list = new ArrayList < > ( table . length ) ; for ( Object [ ] aTable : table ) { List < Value > row = new ArrayList < > ( aTable . length ) ; for ( Object val : aTable ) { if ( val instanceof DataType ) { row . add ( Value . nullOf ( ( DataType ) val ) ) ; } else if ( val instanceof float || val instanceof double ) { row . add ( Value . of ( ( ( Number ) val ) . doubleValue ( ) ) ) ; } else if ( val instanceof Integer || val instanceof long ) { row . add ( Value . of ( ( ( Number ) val ) . longValue ( ) ) ) ; } else if ( val instanceof String ) { row . add ( Value . of ( val . toString ( ) ) ) ; } else { throw new IllegalArgumentException ( "Unsupported value type: " + val . getClass ( ) ) ; } } list . add ( new SimpleListTuple ( row ) ) ; } return list ; }
va	C	@ Override public void confirm ( ) { Profile profile = ProfileManager . getInstance ( ) . getProfile ( ) ; if ( this . model . getName ( ) . equals ( "" ) ) { this . view . fieldsNotSet ( ) ; } else { if ( profile . getTopic ( this . model . getName ( ) ) == null ) { profile . addTopic ( this . model ) ; this . view . close ( ) ; this . onConfirm . run ( ) ; } else { this . view . duplicateTopic ( ) ; } } }
va	D	public void linkRoom ( Map linkMap ) { Point stair1 = STAIR_POINT ; Point stair2 ; Rectangle [ ] rooms2 = linkMap . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( linkMap . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( linkMap . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) == true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } this . map . setTile ( stair1 . x , stair1 . y , new StairTile ( this . map , linkMap , stair1 , stair2 , true ) ) ; linkMap . setTile ( stair2 . x , stair2 . y , new StairTile ( linkMap , this . map , stair2 , stair1 ) ) ; }
va	E	public double updateLabel ( DependencyInstance gold , DependencyInstance pred , LocalFeatureData lfd , GlobalFeatureData gfd , int updCnt , int offset ) { int N = gold . length ; int [ ] actDeps = gold . heads ; int [ ] actLabs = gold . deplbids ; int [ ] predDeps = pred . heads ; int [ ] predLabs = pred . deplbids ; double Fi = getLabelDis ( actDeps , actLabs , predDeps , predLabs ) ; FeatureVector dtl = lfd . getLabeledFeatureDifference ( gold , pred ) ; double loss = - dtl . dotProduct ( paramsL ) + Fi ; double l2norm = dtl . Squaredl2NormUnsafe ( ) ; double alpha = loss / l2norm ; alpha = Math . min ( synC , alpha ) ; if ( alpha > 0 ) { double coeff = alpha ; double coeff2 = coeff * updCnt ; for ( int i = 0 , K = dtl . size ( ) ; i < K ; ++ i ) { int x = dtl . x ( i ) ; double z = dtl . value ( i ) ; paramsL [ x ] += coeff * z ; totalL [ x ] += coeff2 * z ; } } return loss ; }
va	A	@ Override public void inputProcess ( ) { if ( Key . O . isPressed ( ) ) { GameSceneManager . getInstance ( ) . gameover ( ) ; } }
va	C	private void editButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String test = list1 . getSelectedItem ( ) ; String descChange = jTextField1 . getText ( ) ; int ordChange = Integer . parseInt ( jTextField2 . getText ( ) ) ; try { DbUtil . editCat ( test , descChange , ordChange ) ; list1 . removeAll ( ) ; onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Cat . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	A	private void setWeapon ( ShootingWeaponCharacter weapon ) { this . weapon = weapon ; currentRemainBullet = weapon . getRemainBullet ( ) ; weaponView . setTexture ( weapon . getTexture ( ) ) ; remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; }
va	A	private static void setLwjglNativeLibrary ( ) { System . setProperty ( LWJGL_NATIVE_PROPERTY_NAME , new File ( WINDOWS_NATIVE_FOLDER_STRING ) . getAbsolutePath ( ) ) ; }
va	B	public static Texture create ( String str , Color color , FontDef fontDef ) { Font font = FontCollector . getFont ( fontDef ) ; float width = ( fontDef . size / 2 ) * getByteLength ( str ) ; float height = fontDef . size ; return createText ( str , color , font , width , height ) ; }
va	A	public static GameScene scanChangeScene ( ) { for ( SceneCollection scene : SceneCollection . values ( ) ) { if ( scene . trigger . isPressed ( ) ) { return scene . newInstance ( ) ; } } return null ; }
va	E	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
va	E	public DependencyInstance uniformRandomWalkSampling ( DependencyInstance inst , LocalFeatureData lfd , boolean addLoss ) { int len = inst . length ; DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new int [ len ] ; predInst . deplbids = new int [ len ] ; boolean [ ] inTree = new boolean [ len ] ; inTree [ 0 ] = true ; for ( int i = 0 ; i < len ; i ++ ) { predInst . heads [ i ] = - 1 ; } for ( int i = 1 ; i < len ; i ++ ) { int curr = i ; while ( ! inTree [ curr ] ) { int st = lfd . startIndex ( curr ) ; int size = lfd . endIndex ( curr ) - st ; int sample = r . nextInt ( size ) ; predInst . heads [ curr ] = lfd . getHead ( st + sample ) ; curr = predInst . heads [ curr ] ; } curr = i ; while ( ! inTree [ curr ] ) { inTree [ curr ] = true ; curr = predInst . heads [ curr ] ; } } return predInst ; }
va	E	public char [ ] findSameSubArray ( char [ ] input ) { if ( input == null ) return null ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; int maxD = 0 , sum = 0 , maxStart = - 1 , maxEnd = - 1 ; map . put ( 0 , 0 ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == * ) sum ++ ; else sum -- ; if ( map . containsKey ( sum ) ) { int d = i - map . get ( sum ) + 1 ; if ( d > maxD ) { maxD = d ; maxStart = map . get ( sum ) ; maxEnd = i ; } } else { map . put ( sum , i + 1 ) ; } } char [ ] result ; if ( maxStart != - 1 ) { result = new char [ maxD ] ; for ( int i = maxStart ; i <= maxEnd ; i ++ ) { result [ i - maxStart ] = input [ i ] ; } } else result = new char [ 0 ] ; return result ; }
va	C	private void jButton2ActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( true ) ; textField2 . setEnabled ( true ) ; textField3 . setEditable ( true ) ; textField3 . setEnabled ( true ) ; textField4 . setEditable ( true ) ; textField4 . setEnabled ( true ) ; jComboBox1 . setEnabled ( true ) ; jComboBox2 . setEnabled ( true ) ; list1 . setEnabled ( false ) ; jButton1 . setVisible ( false ) ; jButton2 . setVisible ( false ) ; jButton3 . setVisible ( false ) ; Cancel . setVisible ( true ) ; buttonSaveDelete . setVisible ( true ) ; }
va	B	public final BufferedImage createImageData ( final int width , final int height ) { WritableRaster raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , width , height , 4 , null ) ; BufferedImage bufferedImage = new BufferedImage ( glAlphaColorModel , raster , true , new Hashtable < > ( ) ) ; return bufferedImage ; }
va	C	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { ArticleStatModel model = articleStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; }
va	D	public void startGame ( final AbstractGame game ) throws GameAlreadyActiveException { synchronized ( this ) { if ( this . activeGame != null ) { throw new GameAlreadyActiveException ( ) ; } this . activeGame = game ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameStarted ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . registerListener ( game ) ; engine . start ( ) ; } catch ( InitializationException | AlreadyRunningException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } ) ; }
va	D	protected void setNull ( PreparedStatement pstmt , int i , Field field ) throws SQLException { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; break ; case INTEGER : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case long : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case float : pstmt . setNull ( i , java . sql . Types . float ) ; break ; case double : pstmt . setNull ( i , java . sql . Types . double ) ; break ; case DATETIME : pstmt . setNull ( i , java . sql . Types . TIMESTAMP ) ; break ; case BLOB : pstmt . setNull ( i , java . sql . Types . BLOB ) ; break ; default : throw new SQLException ( field . getName ( ) + " = " + field . getBuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
va	D	private Rectangle parseRect ( final String string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastPos = 0 ; try { int i = string . indexOf (   , lastPos ) ; x = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; y = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; w = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; h = Integer . parseInt ( string . substring ( lastPos ) ) ; } catch ( final RuntimeException e ) { return null ; } return new Rectangle ( x , y , w , h ) ; }
va	C	public void calculateSiteStatRecord ( ) { log . info ( "Starting calculateSiteStatRecord" ) ; long firstDayInLong = siteStatDao . findFirstDateTime ( ) ; long lastDayInLong = siteStatDao . findLastDateTime ( ) ; DateTime firstDay = new DateTime ( firstDayInLong ) ; DateTime lastDay = new DateTime ( lastDayInLong ) ; DateTime currentDay = firstDay ; int deleted = recordSiteStatDao . deleteAllSiteStatRecord ( ) ; log . info ( "Clear all data in sitestatrecord deleted {} records" , deleted ) ; calculateRecordForSiteStat ( lastDay . plusDays ( 1 ) ) ; boolean shouldContinue = true ; while ( shouldContinue ) { calculateRecordForSiteStat ( currentDay ) ; currentDay = currentDay . plusDays ( 1 ) ; if ( currentDay . getMillis ( ) > lastDay . toDateMidnight ( ) . toDateTime ( ) . getMillis ( ) ) { shouldContinue = false ; } } log . info ( "calculateSiteStatRecord finished" ) ; }
va	A	@ Override public void render ( ) { left . render ( ) ; right . render ( ) ; }
va	B	public static void store ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { if ( i < 2 ) { fib [ i ] = 1 ; } else { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } }
va	C	@ Override public void updateViewFromModel ( ) { topicname . setText ( presenter . getModel ( ) . getName ( ) ) ; cardnummber1 . setText ( Integer . toString ( presenter . getModel ( ) . getCardCount ( 1 ) ) ) ; cardnummber2 . setText ( Integer . toString ( presenter . getModel ( ) . getCardCount ( 2 ) ) ) ; cardnummber3 . setText ( Integer . toString ( presenter . getModel ( ) . getCardCount ( 3 ) ) ) ; cardnummber4 . setText ( Integer . toString ( presenter . getModel ( ) . getCardCount ( 4 ) ) ) ; cardnummber5 . setText ( Integer . toString ( presenter . getModel ( ) . getCardCount ( 5 ) ) ) ; }
va	D	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException ) { final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 ] ) ; final Object o = causeMethod . invoke ( exception , new Object [ 0 ] ) ; if ( o instanceof Throwable ) { cause = ( Throwable ) o ; } } catch ( final NoSuchMethodException e ) { } catch ( final IllegalArgumentException e ) { } catch ( final IllegalAccessException e ) { } catch ( final InvocationTargetException e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
va	A	@ Override public void update ( ) { if ( currentRemainBullet != weapon . getRemainBullet ( ) ) { remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; currentRemainBullet = weapon . getRemainBullet ( ) ; } }
va	B	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
va	C	@ Override public SiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { SiteStatModel model = new SiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setPageView ( rs . getInt ( "pageview" ) ) ; model . setVisit ( rs . getInt ( "visit" ) ) ; model . setHour ( new DateTime ( rs . getLong ( "hour" ) ) ) ; model . setVideo ( rs . getInt ( "video" ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
va	E	public FeatureVector createTripsFeatureVector ( DependencyInstance inst , int par , int ch1 , int ch2 ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; int dirFlag = ( ( ( ( par < ch1 ? 0 : 1 ) << 1 ) | ( par < ch2 ? 0 : 1 ) ) << 1 ) | 1 ; int HP = pos [ par ] ; int SP = ch1 == par ? TOKEN_START : pos [ ch1 ] ; int MP = pos [ ch2 ] ; int HC = posA [ par ] ; int SC = ch1 == par ? TOKEN_START : posA [ ch1 ] ; int MC = posA [ ch2 ] ; long code = 0 ; code = createArcCodePPP ( HP_SP_MP , HP , SP , MP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | dirFlag , fv ) ; code = createArcCodePPP ( HC_SC_MC , HC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | dirFlag , fv ) ; addTurboSib ( inst , par , ch1 , ch2 , dirFlag , fv ) ; return fv ; }
va	C	public static void main ( String [ ] args ) { int a , b , c ; Scanner in = new Scanner ( System . in ) ; System . out . println ( "enter two numbers to be divided" ) ; a = in . nextInt ( ) ; b = in . nextInt ( ) ; try { c = a / b ; } catch ( ArithmeticException e ) { System . out . println ( "denominator cant be zero" ) ; c = - 1 ; } System . out . println ( a + " divided by " + b + " is " + c ) ; }
va	E	public void initHighOrderFeatureTables ( ) { if ( options . useCS ) { trips = new double [ numarcs * len ] ; Arrays . fill ( trips , null ) ; sib = new double [ len * len ] ; Arrays . fill ( sib , null ) ; } if ( options . useGP ) { gpc = new double [ numarcs * len ] ; Arrays . fill ( gpc , null ) ; } if ( options . useHB ) { headbi = new double [ numarcs * len ] ; Arrays . fill ( headbi , null ) ; } if ( options . useGS ) { gpsib = new double [ numarcs * len * len ] ; Arrays . fill ( gpsib , null ) ; } if ( options . useTS ) { trisib = new double [ numarcs * len * len ] ; Arrays . fill ( trisib , null ) ; } if ( options . useGGP ) { ggpc = new double [ numarcs * numarcs ] ; Arrays . fill ( ggpc , null ) ; } if ( options . usePSC ) { psc = new double [ numarcs * numarcs ] ; Arrays . fill ( psc , null ) ; } }
va	B	@ Override protected WorldImpl nextGeneration ( ) { PackedWorld world = new PackedWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; row ++ ) { for ( int col = 0 ; col < getWidth ( ) ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	B	public static void create ( boolean [ ] [ ] world , int iter , String file ) throws Exception { OutputAnimatedGif gif = new OutputAnimatedGif ( file ) ; for ( int i = 0 ; i < iter ; i ++ ) { gif . addFrame ( world ) ; world = nextGeneration ( world ) ; } }
va	E	private void initFirstOrderTables ( ) { for ( int i = 0 ; i < len ; ++ i ) { wordFvs [ i ] = pipe . synFactory . createWordFeatures ( inst , i ) ; parameters . projectU ( wordFvs [ i ] , wpU [ i ] ) ; parameters . projectV ( wordFvs [ i ] , wpV [ i ] ) ; } boolean nopruning = ! options . pruning || pruner == null || options . learningMode == LearningMode . Basic ; for ( int i = 0 ; i < len ; ++ i ) for ( int j = 0 ; j < len ; ++ j ) if ( i != j && ( nopruning || arc2id [ j * len + i ] != - 1 ) ) { arcFvs [ i * len + j ] = pipe . synFactory . createArcFeatures ( inst , i , j ) ; arcScores [ i * len + j ] = parameters . dotProduct ( arcFvs [ i * len + j ] ) * gamma + parameters . dotProduct ( wpU [ i ] , wpV [ j ] , i - j ) * ( 1 - gamma ) ; } }
va	B	public final Texture getScreenShot ( ) { glReadBuffer ( GL_FRONT ) ; int width = WINDOW_WIDTH ; int height = WINDOW_HEIGHT ; int bpp = 4 ; ByteBuffer buffer = BufferUtils . createByteBuffer ( width * height * bpp ) ; glReadPixels ( 0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE , buffer ) ; return loadTexture ( buffer , width , height ) ; }
va	A	public SpawnData ( class < ? extends EDFEnemy > enemyClass , long spawnFrame , float angle , LR rotateLR ) { this . enemyClass = enemyClass ; this . spawnFrame = spawnFrame ; this . angle = angle ; this . rotateLR = rotateLR ; }
va	B	private TestPackedWorld nextGeneration ( ) { TestPackedWorld world = new TestPackedWorld ( this ) ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { world . setCell ( col , row , computeCell ( col , row ) ) ; } } return world ; }
va	E	public void addCore1OBigramFeatures ( FeatureVector fv , int head , int headP , int mod , int modP , int attDist ) { long code = 0 ; code = createArcCodeWWPP ( HW_MW_HP_MP , head , mod , headP , modP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWPP ( MW_HP_MP , mod , headP , modP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWPP ( HW_HP_MP , head , headP , modP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( MW_HP , mod , headP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( HW_MP , head , modP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( HW_HP , head , headP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; code = createArcCodeWP ( MW_MP , mod , modP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | attDist , fv ) ; }
va	A	@ Override public void update ( ) { changeSceneIfNotNull ( SceneCollection . scanChangeScene ( ) ) ; currentScene . update ( ) ; }
va	B	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
va	E	private void playPoker ( ) { if ( listPokerPlayers . getModel ( ) != null && listPokerPlayers . getModel ( ) . getSize ( ) >= 2 ) { try { String bigBlind = this . txtBigBlind . getText ( ) ; if ( Validators . isNumeric ( bigBlind ) ) { int startBigBlind = Integer . parseInt ( bigBlind ) ; ArrayList < Player > players = this . getPlayers ( ) ; ArrayList < String > playerCantPlay = Validators . somePlayerHasSalaryLessThanBigBlind ( players , startBigBlind ) ; if ( playerCantPlay . isEmpty ( ) ) { ArrayList < String > playerNames = this . getPlayerNamesAsList ( players ) ; TexasHoldemGame game = new TexasHoldemGame ( playerNames , startBigBlind ) ; game . setVisible ( true ) ; } else { JOptionPane . showInputDialog ( new JFrame ( ) , "No es posible iniciar el juego  los siguientes jugadores tienen un salario menor a la ciega grande" , "Error al Iniciar el juego" , JOptionPane . ERROR_MESSAGE , null , playerCantPlay . toArray ( ) , playerCantPlay . toArray ( ) [ 0 ] ) ; playerCantPlay . toArray ( ) ; } } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "El valor ingresado no es un numero " , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "Se necesita un minimo de dos jugadores para iniciar la partida" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
va	D	@ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event == null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending != null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ) ; if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } }
va	C	public static void main ( String [ ] args ) { String msg ; try { Socket c = new Socket ( "127.0.0.1" , 5001 ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( c . getInputStream ( ) ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( c . getOutputStream ( ) ) ) ; Scanner clientinput = new Scanner ( System . in ) ; while ( true ) { System . out . println ( "Enter:" ) ; msg = clientinput . nextLine ( ) ; out . println ( msg ) ; out . flush ( ) ; msg = in . readLine ( ) ; System . out . println ( msg ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	D	@ Test public void shouldCreateInnerSingleHit ( ) { InteractionEvent result = handler . createEvent ( new int [ ] { Integer . parseInt ( "02" , 16 ) , Integer . parseInt ( "28" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) } ) ; assert . assertThat ( result , is ( instanceof ( PointEvent . class ) ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . getMultiplier ( ) , is ( 1 ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . getBaseNumber ( ) , is ( 8 ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . isOuterRing ( ) , is ( not ( true ) ) ) ; }
va	D	public static Point randRectEdge ( Rectangle r , RectangleSide side ) { Point result = null ; if ( side == RectangleSide . TOP ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side == RectangleSide . BOTTOM ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y + r . height - 1 ) ; } else if ( side == RectangleSide . LEFT ) { result = new Point ( r . x , randInt ( r . y , r . y + r . height - 1 ) ) ; } else if ( side == RectangleSide . RIGHT ) { result = new Point ( r . x + r . width - 1 , randInt ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
va	A	@ Override public void update ( ) { super . update ( ) ; hpCaption . updateText ( getHpText ( ) ) ; hpCaption . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
va	E	private String findNext ( ) { StringBuilder sb = null ; boolean inQuotes = false ; while ( i < sql . length ( ) ) { char c = sql . charAt ( i ++ ) ; if ( i == sql . length ( ) ) { if ( c == ; ) { return sb == null ? null : sb . toString ( ) ; } else { throw new SqlParseException ( "SQL did not end with ';'" ) ; } } if ( ! inQuotes ) { if ( Character . isWhitespace ( c ) ) { if ( sb != null ) { return sb . toString ( ) ; } continue ; } if ( SPACE_CHARS . indexOf ( c ) >= 0 ) { if ( sb != null ) { i -- ; return sb . toString ( ) ; } return String . valueOf ( c ) ; } if ( sb == null ) { sb = new StringBuilder ( ) ; } } sb . append ( c ) ; if ( c == ' ) { inQuotes = ! inQuotes ; } } if ( sb != null ) { return sb . toString ( ) ; } return null ; }
va	D	@ Test ( groups = "MaSuite" ) public void parseFile ( ) { try { XmlParams xmlParams = new XmlParams ( ) ; URL url = class . class . getResource ( "/org/jobjects/dbimp/userfilename-asc.xml" ) ; XmlDocument xmld = xmlParams . parseFile ( new File ( url . toURI ( ) ) ) ; StringBuffer sb = new StringBuffer ( ) ; LinkedList < Line > lines = xmld . getLines ( ) ; for ( Line xmlLine : lines ) { sb . append ( xmlLine . getName ( ) + System . lineSeparator ( ) ) ; for ( Field field : xmlLine . getFields ( ) ) { XmlField xmlField = ( XmlField ) field ; sb . append ( "- " + xmlField . getName ( ) + " (" + xmlField . getTypeFormat ( ) + ")" + System . lineSeparator ( ) ) ; } } LOGGER . info ( sb . toString ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	C	private RecordSiteStatModel updateRecordSiteStat ( RecordSiteStatModel recordSiteStatModel ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordSiteStatModel . getUniqueVisitor ( ) , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordSiteStatModel . getPageView ( ) , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) , recordSiteStatModel . getVisit ( ) , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) , recordSiteStatModel . getSite ( ) . getId ( ) , recordSiteStatModel . getId ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordSiteStatModel . getId ( ) ) ; } return recordSiteStatModel ; }
va	A	@ Override public void dispose ( ) { super . dispose ( ) ; weaponView . dispose ( ) ; remainBulletView . dispose ( ) ; }
va	A	private GameScene newInstance ( ) { try { return sceneClass . newInstance ( ) ; } catch ( InstantiationException | IllegalAccessException e ) { System . err . println ( sceneClass . getName ( ) + " \u30AF\u30E9\u30B9\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3067\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" ) ; e . printStackTrace ( ) ; return null ; } }
va	E	public Nose ( Ship parent ) { this . parent = parent ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; engine1X = parent . engine1 . engine . get ( 0 ) . x ; engine2X = parent . engine2 . engine . get ( 0 ) . x ; engineTopY = parent . engine1 . engine . get ( 0 ) . y ; double lengthPoints = parent . speed ; double radiusPoints = ( parent . speed / 4 ) + parent . power ; if ( lengthPoints <= 1 ) { noseLength = 1 ; } else { noseLength = parent . map ( lengthPoints , 1 , 1000 , 2 , 6 ) ; } if ( radiusPoints <= 2 ) { noseRadius = 1 ; } else { noseRadius = parent . map ( radiusPoints , 1 , 1000 , 2 , 12 ) ; } noseLength *= Ship . PIXEL_PER_UNIT ; noseRadius *= Ship . PIXEL_PER_UNIT ; noseX = xorigin ; noseY = engineTopY - noseLength ; noseLine1 = new Line2D . double ( engine1X , engineTopY , noseX , noseY ) ; noseLine2 = new Line2D . double ( engine2X , engineTopY , noseX , noseY ) ; saucer = new Ellipse2D . double ( noseX - ( noseRadius / 2 ) , noseY - ( noseRadius / 2 ) , noseRadius , noseRadius ) ; }
va	D	Dimension getLayoutSize ( Container target , boolean doPreferred ) { Dimension dim = new Dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getComponentCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Component component = target . getComponent ( i ) ; if ( component . isVisible ( ) ) { Rectangle r = getComponentBounds ( component , doPreferred ) ; dim . width = Math . max ( dim . width , r . x + r . width ) ; dim . height = Math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
va	B	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
va	A	@ Override public void update ( ) { setVx ( getVX ( ) * 0.95f ) ; setVy ( getVY ( ) * 0.95f ) ; super . update ( ) ; }
va	E	@ Override public Relation select ( Relation in ) { Tuple sample = in . getValues ( ) . findFirst ( ) . get ( ) ; Map < String , ColumnDefinition > colDefs = new LinkedHashMap < > ( in . getColumnDefinitions ( ) ) ; Map < String , Value > aggregatedValues = new HashMap < > ( ) ; sample . getColumnNames ( ) . forEach ( colName -> { aggregatedValues . put ( colName , sample . select ( colName ) ) ; } ) ; functions . forEach ( ( colName , function ) -> { Value aggregatedVal = function . aggregate ( colName , in . getValues ( ) ) ; aggregatedValues . put ( colName , aggregatedVal ) ; colDefs . put ( colName , function . getColumnDefinition ( ) ) ; } ) ; Tuple theTuple = new AbstractTuple ( ) { @ Override protected Value doSelect ( String colName ) { return aggregatedValues . get ( colName ) ; } @ Override public Map < String , ColumnDefinition > getColumnDefinitions ( ) { return colDefs ; } } ; return new Relation ( ) { @ Override public Stream < ? extends Tuple > getValues ( ) { return Stream . of ( theTuple ) ; } @ Override public Map < String , ColumnDefinition > getColumnDefinitions ( ) { return colDefs ; } } ; }
va	E	public DependencyInstance [ ] createInstances ( String file ) throws IOException { long start = System . currentTimeMillis ( ) ; System . out . print ( "Creating instances ... " ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; LinkedList < DependencyInstance > < = new LinkedList < DependencyInstance > ( ) ; DependencyInstance inst = reader . nextInstance ( ) ; int cnt = 0 ; while ( inst != null ) { inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; < . add ( new DependencyInstance ( inst ) ) ; inst = reader . nextInstance ( ) ; cnt ++ ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; if ( cnt % 1000 == 0 ) System . out . printf ( "%d " , cnt ) ; } reader . close ( ) ; closeAlphabets ( ) ; DependencyInstance [ ] insts = new DependencyInstance [ < . size ( ) ] ; int N = 0 ; for ( DependencyInstance p : < ) { insts [ N ++ ] = p ; } System . out . printf ( "%d [%d ms]%n" , cnt , System . currentTimeMillis ( ) - start ) ; return insts ; }
te	A	public static void reset ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { fib [ i ] = 0 ; } }
te	A	public static void main ( String [ ] args ) { String [ ] tmp = args [ 0 ] . split ( "x" ) ; long tmp1 = long . parseLong ( tmp [ 1 ] , 16 ) ; findLoop ( tmp1 ) ; }
te	E	public static void main ( String [ ] args ) { SearchInsertPosition o = new SearchInsertPosition ( ) ; System . out . println ( "2\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 } , 5 ) ) ; System . out . println ( "1\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 } , 2 ) ) ; System . out . println ( "4\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 } , 7 ) ) ; System . out . println ( "0\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 } , 0 ) ) ; System . out . println ( "0\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 , 7 } , 0 ) ) ; System . out . println ( "1\t" + o . searchInsert ( new int [ ] { 1 , 3 , 5 , 6 , 7 } , 2 ) ) ; }
te	D	public Vector2D offsetPursuit ( Sprite leader , Vector2D offset ) { maths . Vector2D offset_maths = new maths . Vector2D ( offset . x , offset . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( offset_maths , heading_maths , side_maths , pos_maths ) ; Vector2D worldOffsetPos = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D toOffset = worldOffsetPos . minus ( parent . position ) ; double lookAheadTime = toOffset . length ( ) / ( parent . dMaxSpeed + leader . dMaxSpeed ) ; Vector2D newVel = arrive ( leader . velocity . scalarMult ( lookAheadTime ) . + ( worldOffsetPos ) , Deceleration . FAST ) ; return newVel ; }
te	B	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
te	B	@ Override protected WorldImpl nextGeneration ( ) { WorldImpl nextWorld = new AgingWorld ( this ) ; for ( int row = 0 ; row < getHeight ( ) ; ++ row ) { for ( int col = 0 ; col < getWidth ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
te	B	public static ArrayList < Produto > listaAdicionarProduto ( ArrayList < Produto > nova , ArrayList < Produto > antiga ) { ArrayList < Produto > list = new ArrayList < Produto > ( ) ; for ( Produto a : nova ) { boolean existe = false ; for ( Produto b : antiga ) { if ( igual ( a , b ) ) existe = true ; } if ( ! existe ) list . add ( a ) ; } return list ; }
te	C	public static void main ( String [ ] aa ) { try { InputStream in = ( new FileInputStream ( "" + aa [ 0 ] + "" ) ) ; OutputStream f0 = new FileOutputStream ( "" + rep ( aa [ 0 ] ) + "" ) ; Scanner input = new Scanner ( in ) ; while ( input . hasNext ( ) ) { String test = input . nextLine ( ) ; test = rep ( test ) ; test = test + "\n" ; byte buf [ ] = test . getBytes ( ) ; f0 . write ( buf ) ; } in . close ( ) ; f0 . close ( ) ; } catch ( Exception ex ) { System . out . println ( ex ) ; } }
te	E	@ Override public void layoutContainer ( Container cont ) { final int MARGIN = 4 ; final int w = getWidth ( ) ; final int h = getHeight ( ) ; int x = MARGIN * 3 ; int y = MARGIN ; int hh = 24 ; int ww = 40 ; mFamilyLabel . setBounds ( x , y , ww , hh ) ; x += ww + MARGIN * 2 ; ww = Math . min ( w - x - MARGIN , 160 ) ; mFamilyField . setBounds ( x , y , ww , hh ) ; y += hh + MARGIN ; x = MARGIN ; hh *= 2 ; mNoticeLabel . setBounds ( x + MARGIN , y , w - MARGIN * 4 , hh ) ; y += hh + MARGIN ; hh = h - y - MARGIN * 2 - 34 ; mFontStacker . setBounds ( x , y , w - MARGIN * 2 , hh ) ; y += hh + MARGIN ; ww = 80 ; hh = 34 ; mCancelButton . setBounds ( x , y , ww , hh ) ; mOkButton . setBounds ( w - ww - MARGIN , y , ww , hh ) ; }
te	C	public static void generateColor ( ) { ArrayList < Color > usedColors = new ArrayList < > ( ) ; int divisor = 3 ; for ( Player player : players ) { Color tmp ; Random rand = new Random ( ) ; boolean breakLoop ; while ( true ) { breakLoop = true ; tmp = new Color ( rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor ) ; for ( Color c : usedColors ) { if ( c . getRGB ( ) == tmp . getRGB ( ) ) { breakLoop = false ; } } if ( breakLoop ) break ; } player . Color = new Color ( tmp . getRGB ( ) ) ; } }
te	E	private ListNode mergeSortList ( ListNode head , int len ) { if ( len <= 1 ) { return head ; } int leftLen = len / 2 ; int rightLen = len - leftLen ; ListNode middle = head ; for ( int i = 0 ; i < leftLen - 1 ; i ++ ) { middle = middle . next ; } ListNode tmp = middle . next ; middle . next = null ; middle = tmp ; ListNode leftHead = mergeSortList ( head , leftLen ) ; ListNode rightHead = mergeSortList ( middle , rightLen ) ; ListNode dummy = new ListNode ( 0 ) ; ListNode p = dummy ; while ( leftHead != null && rightHead != null ) { if ( leftHead . val > rightHead . val ) { p . next = rightHead ; rightHead = rightHead . next ; } else { p . next = leftHead ; leftHead = leftHead . next ; } p = p . next ; } if ( leftHead != null ) { p . next = leftHead ; } else { p . next = rightHead ; } return dummy . next ; }
te	E	public void resize ( int leftX , int rightX , int topY , int bottomY , int tile ) { for ( int i = 0 ; i < layers . size ( ) ; i ++ ) { if ( leftX > 0 ) layers . get ( i ) . expandLeft ( leftX , 0 ) ; if ( rightX > 0 ) layers . get ( i ) . expandRight ( rightX , 0 ) ; if ( topY > 0 ) layers . get ( i ) . expandTop ( topY , 0 ) ; if ( bottomY > 0 ) layers . get ( i ) . expandBottom ( bottomY , 0 ) ; if ( leftX < 0 ) layers . get ( i ) . reduceLeft ( - leftX ) ; if ( rightX < 0 ) layers . get ( i ) . reduceRight ( - rightX ) ; if ( topY < 0 ) layers . get ( i ) . reduceTop ( - topY ) ; if ( bottomY < 0 ) layers . get ( i ) . reduceBottom ( - bottomY ) ; } this . setModified ( true ) ; }
te	D	public void updateTheta ( FeatureVector gold , FeatureVector pred , double loss , int updCnt ) { FeatureVector fv = new FeatureVector ( size ) ; fv . addEntries ( gold ) ; fv . addEntries ( pred , - 1.0 ) ; double l2norm = fv . Squaredl2NormUnsafe ( ) ; double alpha = loss / l2norm ; alpha = Math . min ( synC , alpha ) ; if ( alpha > 0 ) { double coeff = alpha , coeff2 = coeff * updCnt ; for ( int i = 0 , K = fv . size ( ) ; i < K ; ++ i ) { int x = fv . x ( i ) ; double z = fv . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } } }
te	C	@ Override public void actionPerformed ( ActionEvent e ) { Game . GA_JailThrowDice ( ) ; if ( Game . players . get ( Game . currentPlayer ) . InPrison ) { if ( Game . JailDiceTries < 3 ) { showJailPayBailBtn = false ; } else { if ( Game . players . get ( Game . currentPlayer ) . PrisonTurns > 1 ) { showJailThrowDiceBtn = false ; showJailPayBailBtn = true ; showNextPlayerBtn = false ; } else { Game . JailDiceTries = 0 ; Game . players . get ( Game . currentPlayer ) . PrisonTurns ++ ; showJailThrowDiceBtn = false ; showJailPayBailBtn = false ; showNextPlayerBtn = true ; } } refreshGameControl ( ) ; } else { } }
te	D	public static boolean box_box ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , double by0 , double bx1 , double by1 ) { double topA = FastMath . min ( ay0 , ay1 ) ; double botA = FastMath . max ( ay0 , ay1 ) ; double leftA = FastMath . min ( ax0 , ax1 ) ; double rightA = FastMath . max ( ax0 , ax1 ) ; double topB = FastMath . min ( by0 , by1 ) ; double botB = FastMath . max ( by0 , by1 ) ; double leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA <= topB || botB <= topA || rightA <= leftB || rightB <= leftA ) return false ; return true ; }
te	B	@ RequestWrapper ( localName = "delete" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Delete" ) @ WebMethod @ ResponseWrapper ( localName = "deleteResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteResponse" ) public void delete ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	D	public boolean isCollision ( Ship s1 , Sprite s2 ) { if ( s1 instanceof Ship && ! ( ( Ship ) s1 ) . isAlive ( ) ) { return false ; } if ( s2 instanceof Creature && ! ( ( Creature ) s2 ) . isAlive ( ) ) { return false ; } int s1x = Math . round ( s1 . getX ( ) ) ; int s1y = Math . round ( s1 . getY ( ) ) ; int s2x = Math . round ( s2 . getX ( ) ) ; int s2y = Math . round ( s2 . getY ( ) ) ; return ( s1x < s2x + s2 . getWidth ( ) && s2x < s1x + s1 . getWidth ( ) && s1y < s2y + s2 . getHeight ( ) && s2y < s1y + s1 . getHeight ( ) ) ; }
te	D	public void move ( double l , double r ) { double elapsed = ( System . currentTimeMillis ( ) - lastTime ) / 1000.0 ; double d = ( l + r ) / 2.0 ; double th = ( r - l ) / Configuration . getRobot ( ) . getWidth ( ) ; double x = Math . cos ( th ) * d ; double y = - Math . sin ( th ) * d ; this . lastTime = System . currentTimeMillis ( ) ; this . dx = d / elapsed ; this . dr = th / elapsed ; this . x = this . x + ( Math . cos ( this . yaw ) * x - Math . sin ( this . yaw ) * y ) ; this . y = this . y + ( Math . sin ( this . yaw ) * x + Math . cos ( this . yaw ) * y ) ; if ( th != 0 ) this . yaw = this . yaw + th ; }
te	C	private QueryMapHelper ( ) { Properties p = new Properties ( ) ; URL url = null ; String filePath = "dq.properties" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { url = file . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return ; } } else { url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; } if ( url == null ) { throw new RuntimeException ( "can not find the file " + filePath ) ; } try { p . load ( url . openStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } loadFiles ( p ) ; }
te	D	public void evaluateDependencies ( DependencyInstance gold , DependencyInstance pred , boolean evalWithPunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , N = gold . length ; i < N ; ++ i ) { if ( ! evalWithPunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) continue ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnLabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnLabel ) ? 1 : 0 ; }
te	C	@ Override public void putChar ( char c ) throws ParsingException { switch ( c ) { case Characters . SPACE : context . putSpace ( ) ; break ; case Characters . SEPARATOR : context . putSeparator ( ) ; break ; case Characters . END : context . putEnd ( ) ; break ; case Characters . PARAMETER : context . putParameter ( ) ; break ; case Characters . SUB_ID : context . putSubId ( ) ; break ; case Characters . TAB : context . putTab ( ) ; break ; case Characters . NEWLINE : context . putNewLine ( ) ; ++ rowNum ; colNum = 0 ; break ; default : context . putChar ( c ) ; break ; } postProcess ( c ) ; }
te	A	public Rain ( Point point ) { this . point = point ; int cl = 100 + RANDOM . nextInt ( 150 ) ; color = new Color ( cl , cl , 255 ) ; }
te	A	public static long get ( int i ) { if ( i < fib . length && i > - 1 ) { return fib [ i ] ; } else { return - 1 ; } }
te	E	public int threeSumClosest ( int [ ] num , int target ) { Arrays . sort ( num ) ; int n = num . length ; if ( n < 3 ) { int sum = 0 ; for ( int i : num ) { sum += i ; } return sum ; } int closest = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { closest += num [ i ] ; } for ( int i = 0 ; i <= n - 3 ; i ++ ) { int a = num [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c == target ) { return target ; } else if ( a + b + c > target ) { end -- ; } else { start ++ ; } if ( Math . abs ( a + b + c - target ) < Math . abs ( closest - target ) ) { closest = a + b + c ; } } } return closest ; }
te	B	@ Override public boolean getCell ( int col , int row ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { return ( cells >> ( row * 8 + col ) & 1 ) == 1 ; } else { return false ; } }
te	E	private void jTextField2AncestorAdded ( javax . swing . event . AncestorEvent evt ) { for ( int i = 2 ; i < 8 ; i ++ ) { if ( "null" . equals ( Lista_meta [ i ] ) ) { Lista_meta [ i ] = "Desconocido" ; } } jTextField5 . setText ( Lista_meta [ 1 ] ) ; jTextField1 . setText ( Lista_meta [ 2 ] ) ; jTextField2 . setText ( Lista_meta [ 5 ] ) ; jTextField3 . setText ( Lista_meta [ 4 ] ) ; if ( "0" . equals ( Lista_meta [ 3 ] ) ) { jTextField4 . setText ( "Desconocido" ) ; } else { jTextField4 . setText ( Lista_meta [ 3 ] ) ; } jTextField7 . setText ( Lista_meta [ 6 ] ) ; jTextField6 . setText ( Lista_meta [ 7 ] ) ; try { ImageIcon icon = new ImageIcon ( Lista_meta [ 8 ] ) ; Icon icono = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( jLabel10 . getWidth ( ) , jLabel10 . getHeight ( ) , Image . SCALE_DEFAULT ) ) ; jLabel10 . setIcon ( icono ) ; } catch ( java . lang . NullPointerException e ) { } }
te	A	public TextTestCharacter ( ) { super ( getTestText ( ) ) ; this . setBasePont ( GameCharacterBasePoint . LEFTTOP ) . setColor ( Color . green . darker ( ) ) . setX ( 5 ) . setY ( HEIGHT - 5 ) ; }
te	C	public void setMap ( Map < String , ? > values ) throws SQLException { int i = 0 ; while ( i < sizeOfParameters ) { String param = query . getParameter ( i ) ; if ( values . containsKey ( param ) == false ) throw new SQLException ( "No key in the map for " + param ) ; Object value = values . get ( param ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , e ) ; } } }
te	C	public static void dump ( Node node ) { if ( node instanceof Comment ) { System . out . print ( node ) ; } else if ( node instanceof PrintBold ) { System . out . print ( node ) ; } else if ( node instanceof Print ) { System . out . print ( node ) ; } else if ( node instanceof Block ) { System . out . print ( ( Block ) node + ":" ) ; dump ( ( ( Block ) node ) . first ) ; System . out . print (   ) ; dump ( ( ( Block ) node ) . second ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
te	B	@ Test public void testeProdutoIgual ( ) { Cliente c1 = new Cliente ( ) ; c1 . setId ( ( long ) 1 ) ; Cliente c2 = new Cliente ( ) ; c2 . setId ( ( long ) 1 ) ; assertTrue ( ListaUtils . igual ( c1 , c2 ) ) ; }
te	B	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ height ] [ width ] ; for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = 1000 ; } }
te	C	public static String convertJavaName ( String javaName ) { char [ ] chs = javaName . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( ch >= A && ch <= Z ) { sb . append ( _ ) ; sb . append ( ( char ) ( ch + 32 ) ) ; } else sb . append ( ch ) ; } return sb . toString ( ) ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.GetResponse" ) public soa32 . resources . cliente . Cliente get ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	B	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
te	B	private void resetWorld ( ) { Pattern current = patternPanel . getCurrentPattern ( ) ; world = null ; if ( current != null ) { try { world = controlPanel . initialiseWorld ( current ) ; } catch ( PatternFormatException e ) { JOptionPane . showMessageDialog ( this , "Error initialising world" , "An error occurred when initialising the world. " + e . getMessage ( ) , JOptionPane . ERROR_MESSAGE ) ; } } gamePanel . display ( world ) ; repaint ( ) ; }
te	E	public static void main ( String [ ] args ) throws IOException { if ( args . length == 4 && args [ 1 ] . equals ( "-apduOut" ) ) { try { String fname = args [ 2 ] ; PrintStream ps = new PrintStream ( new FileOutputStream ( fname ) ) ; PKIService service = new PKIService ( new DummyAcceptingCardService ( ps ) ) ; PKIAppletEvent event = new PKIAppletEvent ( PKIAppletEvent . INSERTED , service ) ; String [ ] newArgs = new String [ args . length - 2 ] ; for ( int i = 0 ; i < newArgs . length ; i ++ ) { newArgs [ 0 ] = args [ 0 ] ; newArgs [ 1 ] = args [ 3 ] ; } BatchWriter writer = new BatchWriter ( newArgs ) ; writer . pkiAppletInserted ( event ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } else { PKIAppletManager manager = PKIAppletManager . getInstance ( ) ; manager . addPKIAppletListener ( new BatchWriter ( args ) ) ; CardManager cm = CardManager . getInstance ( ) ; for ( CardTerminal t : cm . getTerminals ( ) ) { cm . startPolling ( t ) ; } } }
te	A	private static double mantissaToDecimal ( long mantissabits ) { long one = 0010000000000000 ; return ( double ) ( mantissabits + one ) / ( double ) one ; }
te	A	public void update ( int speed , int nabiki ) { point . move ( point . x + nabiki , point . y + speed ) ; }
te	A	@ Override public float damage ( float damage ) { for ( int i = 0 ; i < 3 ; i ++ ) { shoot ( new BasicEffect ( getParentScene ( ) , this ) ) ; } return super . damage ( damage ) ; }
te	D	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
te	E	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( "JTable" ) ; frame . setSize ( new Dimension ( 600 , 400 ) ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLocationRelativeTo ( null ) ; ImageIcon img = new ImageIcon ( "suley_black3.png" ) ; frame . setIconImage ( img . getImage ( ) ) ; frame . setLayout ( new GridBagLayout ( ) ) ; final JLabel label = new JLabel ( "logo" , new ImageIcon ( "suley2.png" ) , JLabel . RIGHT ) ; JPanel panel = new JPanel ( ) ; panel . add ( label ) ; final JPopupMenu popup = new JPopupMenu ( ) ; popup . add ( new JMenuItem ( "add" ) ) ; popup . add ( new JMenuItem ( "copy" ) ) ; label . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent event ) { if ( SwingUtilities . isRightMouseButton ( event ) ) popup . show ( label , event . getX ( ) , event . getY ( ) ) ; } } ) ; frame . setContentPane ( panel ) ; frame . setVisible ( true ) ; frame . pack ( ) ; }
te	A	public BallKeyMove ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; this . color = Color . red ; }
te	C	@ Test public void testCreateQueryMap ( ) throws ParsingException { QueryMap qm = QueryFactory . createQueryMap ( "path.sql" ) ; assertEquals ( 3 , qm . sizeOfMainQueries ( ) ) ; assertEquals ( 0 , qm . sizeOfSubQueries ( ) ) ; Query list0 = qm . getQuery ( "list0" ) ; assertEquals ( "select 1 from x \n" , list0 . getText ( ) ) ; Query list00 = qm . getQuery ( "list00" ) ; assertEquals ( "select 0 from x" , list00 . getText ( ) ) ; Query list = qm . getQuery ( "list" ) ; String expected = "select 11111\t\t\n" + "\n" + "/*\n" + " Above query missed ';' at the end.\n" + " so the parser thinks there is no list2 below\n" + " but only one id 'list' containing below llist2.\n" + " see warning.\n" + " */\n" + "\n" + "list2:select 2222" ; assertEquals ( expected , list . getText ( ) ) ; }
te	D	@ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "OCHN(" ) ; builder . append ( type ) ; builder . append ( " " ) ; builder . append ( byte . toString ( channel ) ) ; builder . append ( " " ) ; builder . append ( parity ) ; builder . append ( " " ) ; builder . append ( Integer . toString ( baud ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( stopBits ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( dataBits ) ) ; builder . append ( " " ) ; builder . append ( mode ) ; builder . append ( ")" ) ; return builder . toString ( ) ; }
te	B	public Integer getValue ( ) { int total = 0 ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c ) ; } } if ( ds . isWhiteToMove ( ) ) { return total ; } else { return - total ; } }
te	A	public TestBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter , BULLET_POWER ) ; setColor ( generateCosmosColor ( ) ) ; setVx ( random ( - 0.5f , 0.5f ) ) ; setVy ( ySpeed ) ; setVAngle ( 12 ) ; }
te	A	public static void main ( String [ ] args ) throws Exception { play ( long . decode ( args [ 0 ] ) ) ; }
te	A	public static Texture createText ( String str , FontDef fontDef ) { return create ( str , Color . white , fontDef ) ; }
te	D	private void normalDiscover ( ) { ArrayList possibleTargets = getPossibleTargets ( ) ; if ( possibleTargets . isEmpty ( ) ) { Random r = new Random ( System . currentTimeMillis ( ) ) ; int xLim = TileMapRenderer . tilesToPixels ( ( ( Ship ) ( this . parent ) ) . getParent ( ) . parent . getMap ( ) . getWidth ( ) ) ; int yLim = TileMapRenderer . tilesToPixels ( ( ( Ship ) ( this . parent ) ) . getParent ( ) . parent . getMap ( ) . getHeight ( ) ) ; int randX = r . nextInt ( xLim - 10 ) + 10 ; int randY = r . nextInt ( yLim - 10 ) + 10 ; targetLocation = new Vector ( randX , randY ) ; currentState = STATE_MOVETO ; } else { target = getClosestTarget ( possibleTargets ) ; targetLocation = new Vector ( ( int ) target . getX ( ) , ( int ) target . getY ( ) ) ; currentState = STATE_FOLLOW ; } }
te	C	public void removeNode ( E e ) { if ( e == head ) { if ( e == tail ) { head = null ; tail = null ; } else { head = e . getNext ( ) ; head . setPrevios ( null ) ; e . setNext ( null ) ; } } else if ( e == tail ) { tail = tail . getPrevios ( ) ; tail . setNext ( null ) ; e . setPrevios ( null ) ; } else { unlinkInternal ( e ) ; unlink ( e ) ; } }
te	E	public int minCut ( String s ) { int len = s . length ( ) ; int [ ] D = new int [ len + 1 ] ; boolean [ ] [ ] P = new boolean [ len ] [ len ] ; for ( int i = 0 ; i <= len ; i ++ ) { D [ i ] = len - i ; } for ( int i = 0 ; i < len ; i ++ ) for ( int j = 0 ; j < len ; j ++ ) P [ i ] [ j ] = false ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < len ; j ++ ) { if ( ( s . charAt ( i ) == s . charAt ( j ) ) && ( ( j - i < 2 ) || ( P [ i + 1 ] [ j - 1 ] == true ) ) ) { P [ i ] [ j ] = true ; D [ i ] = Math . min ( D [ i ] , D [ j + 1 ] + 1 ) ; } } System . out . println ( D [ i ] ) ; } return D [ 0 ] - 1 ; }
te	E	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
te	C	StringBuilder toStringBuilder ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "id :" ) ; sb . append ( id ) ; sb . append (  ) ; sb . append ( "text :" ) ; sb . append ( text ) ; sb . append (  ) ; sb . append ( "paramters : " ) ; sb . append ( sizeOfParameters ( ) ) ; sb . append (  ) ; if ( parameters != null ) { for ( String param : parameters ) { sb . append ( param ) ; sb . append (   ) ; } sb . append (  ) ; } return sb ; }
te	C	public boolean isAnagram ( String par , String chil ) { int i ; int parent [ ] = new int [ 27 ] ; int child [ ] = new int [ 27 ] ; for ( i = 0 ; i < par . length ( ) ; i ++ ) { parent [ ( par . charAt ( i ) - 97 ) ] ++ ; } for ( i = 0 ; i < chil . length ( ) ; i ++ ) { child [ ( chil . charAt ( i ) - 97 ) ] ++ ; } i = 0 ; while ( i < 27 ) { if ( parent [ i ] >= child [ i ] ) i ++ ; else return false ; } return true ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "create" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Create" ) @ WebMethod @ ResponseWrapper ( localName = "createResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.CreateResponse" ) public java . lang . long create ( @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . cliente . Cliente entity ) ;
te	E	public void actionPerformed ( ActionEvent e ) { String [ ] columns = { "Action:" , "Key shortcut:" , "Alt. key shortcut:" } ; Object [ ] [ ] rows = { { "Paint" , "LMB" , "" } , { "Pick a tile" , "RMB" , "" } , { "Select level area" , "Shift + drag LMB" , "" } , { "Cut selection" , "Ctrl + X" , "" } , { "Copy selection" , "Ctrl + C" , "Ctrl + Insert" } , { "Paste selection" , "Ctrl + V" , "Shift + Insert" } , { "Delete selection" , "Delete" , "" } , { "Undo action" , "Ctrl + Z" , "" } , { "Move tile picker left" , "A" , "" } , { "Move tile picker right" , "D" , "" } , { "Move tile picker up" , "W" , "" } , { "Move tile picker down" , "S" , "" } , { "Draw on BGD" , "1" , "" } , { "Draw on MGD" , "2" , "" } , { "Draw on FGD" , "3" , "" } , { "Toggle show BGD" , "Ctrl + 1" , "" } , { "Toggle show MGD" , "Ctrl + 2" , "" } , { "Toggle show FGD" , "Ctrl + 3" , "" } , { "Swap object direction" , "F" , "" } , { "Launch level" , "F5" , "" } , { "Reload editor data" , "CTRL + R" , "" } } ; TableModel model = new DefaultTableModel ( rows , columns ) ; JOptionPane . showMessageDialog ( helpShortcuts , new JScrollPane ( new JTable ( model ) ) , "Key shortcuts" , JOptionPane . PLAIN_MESSAGE ) ; }
te	C	public static void exec ( Node node ) { if ( node instanceof Comment ) { } else if ( node instanceof PrintBold ) { System . out . println ( "**" + ( ( PrintBold ) node ) . message + "**" ) ; } else if ( node instanceof Print ) { System . out . println ( ( ( Print ) node ) . message ) ; } else if ( node instanceof Block ) { exec ( ( ( Block ) node ) . first ) ; exec ( ( ( Block ) node ) . second ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
te	D	public static Vector2D line_line_infinite ( Vector2D v0 , Vector2D v1 , Vector2D v2 , Vector2D v3 ) { Vector2D intercept = null ; double f1 = ( v1 . x - v0 . x ) ; double g1 = ( v1 . y - v0 . y ) ; double f2 = ( v3 . x - v2 . x ) ; double g2 = ( v3 . y - v2 . y ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( v2 . y - v0 . y ) - g2 * ( v2 . x - v0 . x ) ) / det ; intercept = new Vector2D ( v0 . x + f1 * s , v0 . y + g1 * s ) ; } return intercept ; }
te	E	public int longestValidParentheses ( String s ) { if ( s == null || s . length ( ) < 2 || s . indexOf ( ")" ) == - 1 ) { return 0 ; } int ret = 0 ; int [ ] len = new int [ s . length ( ) + 1 ] ; len [ 0 ] = 0 ; len [ 1 ] = 0 ; for ( int i = 2 ; i <= s . length ( ) ; i ++ ) { if ( s . charAt ( i - 1 ) == ( ) { len [ i ] = 0 ; } else { if ( s . charAt ( i - 2 ) == ( ) { len [ i ] = len [ i - 2 ] + 2 ; } else { if ( ( i - 2 - len [ i - 1 ] ) >= 0 && s . charAt ( i - 2 - len [ i - 1 ] ) == ( ) { len [ i ] = len [ i - 2 - len [ i - 1 ] ] + len [ i - 1 ] + 2 ; } else { len [ i ] = 0 ; } } } ret = len [ i ] > ret ? len [ i ] : ret ; } return ret ; }
te	D	private void drawNose ( Graphics2D g , int offsetX , int offsetY ) { Line2D noseLine1 = nose . noseLine1 ; Line2D noseLine2 = nose . noseLine2 ; Ellipse2D saucer = nose . saucer ; g . drawLine ( ( int ) noseLine1 . getX1 ( ) + offsetX , ( int ) noseLine1 . getY1 ( ) + offsetY , ( int ) noseLine1 . getX2 ( ) + offsetX , ( int ) noseLine1 . getY2 ( ) + offsetY ) ; g . drawLine ( ( int ) noseLine2 . getX1 ( ) + offsetX , ( int ) noseLine2 . getY1 ( ) + offsetY , ( int ) noseLine2 . getX2 ( ) + offsetX , ( int ) noseLine2 . getY2 ( ) + offsetY ) ; g . fillArc ( ( int ) saucer . getX ( ) + offsetX , ( int ) saucer . getY ( ) + offsetY , ( int ) saucer . getWidth ( ) , ( int ) saucer . getHeight ( ) , 0 , 360 ) ; }
te	A	public ShootingTestScene ( ) { BackGroundColor . BLACK . set ( ) ; add ( new MyShip ( this ) ) ; add ( new TestEnemyShip ( this ) ) ; }
te	B	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
te	D	public void predictLabels ( int [ ] heads , int [ ] deplbids , boolean addLoss ) { assert ( heads . length == len ) ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; int T = ntypes ; for ( int mod = 1 ; mod < len ; ++ mod ) { int head = heads [ mod ] ; int type = addLoss ? 0 : 1 ; double best = getLabelScore ( arcLis , heads , mod , type ) + ( addLoss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( int t = type + 1 ; t < T ; ++ t ) { double va = getLabelScore ( arcLis , heads , mod , t ) + ( addLoss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
te	D	public void drawSprite ( Graphics2D g , int offsetX , int offsetY ) { AffineTransform saveTransform = g . getTransform ( ) ; AffineTransform identity = new AffineTransform ( ) ; g . setTransform ( identity ) ; g . rotate ( orientation , offsetX , offsetY ) ; g . setTransform ( saveTransform ) ; oldBody = new Ellipse2D . double ( this . position . x , this . position . y , 25 , 25 ) ; double middleX = ( int ) oldBody . getX ( ) + offsetX + ( int ) oldBody . getWidth ( ) / 2 ; double middleY = ( int ) oldBody . getY ( ) + offsetY + ( int ) oldBody . getHeight ( ) / 2 ; Vector2D endLine = new Vector2D ( middleX , middleY + 50 ) ; g . rotate ( orientation , middleX , middleY ) ; body . drawGamePolygon ( g , offsetX , offsetY ) ; g . setTransform ( saveTransform ) ; drawTestGui ( g ) ; }
te	D	public static double [ ] line_line_infinite ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double [ ] result = NONE ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; result = new double [ ] { x0 + f1 * s , y0 + g1 * s } ; } return result ; }
te	D	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ) { double hiPrec [ ] = new double [ 2 ] ; final double lores = log ( xpa , hiPrec ) ; if ( double . isInfinite ( lores ) ) { return lores ; } double fx1 = xpb / xpa ; double epsilon = 0.5 * fx1 + 1.0 ; epsilon = epsilon * fx1 ; return epsilon + hiPrec [ 1 ] + hiPrec [ 0 ] ; } double y = x * 0.333333333333333 - 0.5 ; y = y * x + 1.0 ; y = y * x ; return y ; }
te	E	private void cycleOrder ( int [ ] [ ] matrix , int startR , int startC , int endR , int endC , List < Integer > result ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result . add ( matrix [ startR ] [ i ] ) ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result . add ( matrix [ i ] [ startC ] ) ; } else { for ( int i = startC ; i <= endC ; i ++ ) result . add ( matrix [ startR ] [ i ] ) ; for ( int i = startR + 1 ; i <= endR ; i ++ ) result . add ( matrix [ i ] [ endC ] ) ; for ( int i = endC - 1 ; i >= startC ; i -- ) result . add ( matrix [ endR ] [ i ] ) ; for ( int i = endR - 1 ; i >= startR + 1 ; i -- ) result . add ( matrix [ i ] [ startC ] ) ; } }
te	C	public static void main ( String [ ] args ) throws Exception { int count = 0 ; PreparedStatement st = Data2 . connect ( ) . prepareStatement ( "insert into emp2 values(? ?)" ) ; try { for ( int i = 11 ; i < 22 ; i ++ ) { st . setInt ( 1 , i ) ; st . setString ( 2 , ( "char)i+(char)i+1" ) ) ; if ( st . executeUpdate ( ) == 1 ) { count ++ ; } } } catch ( Exception e ) { } System . out . println ( count + " Rows added" ) ; }
te	B	private JSlider createNewSlider ( int min , int max , int start , String s ) { Box panel = Box . createHorizontalBox ( ) ; add ( panel ) ; panel . add ( new JLabel ( s ) ) ; JSlider slider = new JSlider ( min , max , start ) ; panel . add ( slider ) ; return slider ; }
te	D	@ Override public void run ( ) { CountDownLatch latch = null ; long lastExtraRequestTime = 0 ; try { while ( fetchStatus ) { if ( System . currentTimeMillis ( ) - lastExtraRequestTime >= EXTRA_INFO_DELAY ) { lastExtraRequestTime = System . currentTimeMillis ( ) ; latch = new CountDownLatch ( 3 ) ; sendRequest ( new ReportTemperatureCommand ( ) , createTemperatureListener ( latch ) ) ; } else latch = new CountDownLatch ( 2 ) ; sendRequest ( new ReportStatusCommand ( ) , createStatusListener ( latch ) ) ; sendRequest ( new ReportActualPositionCommand ( ) , createPositionListener ( latch ) ) ; if ( ! latch . await ( ROBOT_TIMEOUT , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onConnect ( ) ; } } } catch ( Exception ex ) { if ( ex . getClass ( ) == TimeoutException . class ) { if ( connected ) System . err . println ( "Connection to the motors timed out" ) ; } else ex . printStackTrace ( ) ; reset ( ) ; } }
te	E	public boolean closeLevel ( ) { boolean leave = false ; if ( mapPanel != null && mapPanel . level != null && mapPanel . level . isModified ( ) ) { int choice = JOptionPane . showConfirmDialog ( fileChooser , "Store the changes to \"" + mapPanel . level . getLevelName ( ) + "\"?" , "" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( choice == JOptionPane . YES_OPTION ) { if ( mapPanel . level . getFilePath ( ) != null ) { mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; } else { fileChooser . addChoosableFileFilter ( levelFilter ) ; fileChooser . setFileFilter ( levelFilter ) ; int choice2 = fileChooser . showSaveDialog ( fileChooser ) ; fileChooser . removeChoosableFileFilter ( levelFilter ) ; if ( choice2 == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; mapPanel . level . setFilePath ( file ) ; mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; leave = true ; } } } else if ( choice == JOptionPane . NO_OPTION ) { leave = true ; } } else { leave = true ; } return leave ; }
te	C	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex == - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
te	A	@ Override public void render ( ) { setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; super . render ( ) ; }
te	E	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { try { leer_archivo cancionesActualizadas = new leer_archivo ( 100 ) ; String [ ] lista_p = cancionesActualizadas . leer_archivo1 ( "Lista_canciones.txt" ) ; File TXTactualizado = new File ( "Lista_canciones.txt" ) ; TXTactualizado . createNewFile ( ) ; FileWriter TXTactualizadoEscritura = new FileWriter ( TXTactualizado ) ; BufferedWriter TXTactualizadoEscribir = new BufferedWriter ( TXTactualizadoEscritura ) ; int i = 0 ; boolean espacio = false ; while ( lista_p [ i ] != null ) { if ( Lista_meta [ 1 ] . equals ( lista_p [ i ] ) || lista_p [ i ] . equals ( "" ) ) { } else { espacio = true ; TXTactualizadoEscribir . write ( lista_p [ i ] ) ; } if ( espacio ) { TXTactualizadoEscribir . newLine ( ) ; } espacio = false ; i ++ ; } TXTactualizadoEscribir . close ( ) ; File eliminarTXT = new File ( Lista_meta [ 1 ] + ".txt" ) ; eliminarTXT . delete ( ) ; JOptionPane . showMessageDialog ( frame , "La cancion ha sido eliminada exitosamente" ) ; dispose ( ) ; InterfazPrincipal ob = new InterfazPrincipal ( ) ; ob . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	D	public void update ( long elapsedTime ) { totalPowerLimit = level * 3 ; if ( totalPower >= totalPowerLimit ) { totalPower = totalPowerLimit ; } Vector2D steeringForce = steering . calculate ( velocity ) ; steeringForce . truncate ( .0001 ) ; Vector2D acceleration = steeringForce . scalarDiv ( dMass ) ; velocity = velocity . + ( acceleration . scalarMult ( elapsedTime ) ) ; velocity . truncate ( dMaxSpeed ) ; position = position . + ( velocity . scalarMult ( elapsedTime ) ) ; if ( velocity . length ( ) > .03 ) { oldheading = heading ; heading = velocity . unitVector ( ) ; } side = heading . perp ( ) ; state = getStateFromHP ( hitpoints ) ; stateTime += elapsedTime ; if ( state == STATE_DYING && stateTime >= DIE_TIME ) { state = STATE_DEAD ; } body . update ( ) ; engine1 . update ( ) ; engine2 . update ( ) ; nose . update ( ) ; float maxSpeed = ( float ) map ( speed , 1 , 1000 , .05 , .6 ) ; setMaxSpeed ( maxSpeed ) ; }
te	C	public List < Book > getBooksByParameters ( String name , String authorName , String year , String bookType , String series , String availibility ) { boolean available = false ; int yearInt = 0 ; if ( ! IntegerUtil . isInteger ( year ) || year . equals ( "" ) ) { yearInt = 0 ; } else { yearInt = Integer . parseInt ( year ) ; } if ( availibility . equals ( "available" ) ) { available = true ; } else if ( availibility . equals ( "not available" ) ) { available = false ; } List < Book > list = bookService . getBooksByParameters ( name . toLowerCase ( ) , authorName , yearInt , bookType , series . toLowerCase ( ) , available ) ; return list ; }
te	E	public ImgTemplate ( String fileName , int w , int h ) { try { File file = new File ( Data . getDataDirectory ( ) + "/data/gfx/obj/" + fileName ) ; BufferedImage tmpImg = ImageIO . read ( file ) ; this . image = new BufferedImage ( tmpImg . getWidth ( ) , tmpImg . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; this . image . getGraphics ( ) . drawImage ( tmpImg , 0 , 0 , null ) ; WritableRaster raster = this . image . getRaster ( ) ; for ( int j = 0 ; j < this . image . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < this . image . getWidth ( ) ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } this . tileW = w ; this . tileH = h ; } catch ( IOException ioe ) { System . out . printf ( "Failed to load file: %s\n" , fileName ) ; } }
te	D	public GlobalFeatureData ( LocalFeatureData lfd ) { this . lfd = lfd ; pipe = lfd . pipe ; synFactory = pipe . synFactory ; if ( lfd . options . useHO ) { cn = new double [ lfd . len * ( MAX_CHILD_NUM + 1 ) * ( MAX_CHILD_NUM + 1 ) ] ; Arrays . fill ( cn , null ) ; span = new double [ lfd . len * 2 * 2 * ( MAX_SPAN_LENGTH + 1 ) ] ; Arrays . fill ( span , null ) ; nb = new double [ lfd . numarcs * ( pipe . dictionaries . size ( POS ) + 1 ) * ( pipe . dictionaries . size ( POS ) + 1 ) ] ; Arrays . fill ( nb , null ) ; ppcc1 = new double [ lfd . len * lfd . len * lfd . len ] ; Arrays . fill ( ppcc1 , null ) ; cc2 = new double [ lfd . len * lfd . len * lfd . len ] ; Arrays . fill ( cc2 , null ) ; } }
te	E	public int minimumTotal ( List < List < Integer >> triangle ) { if ( triangle == null ) return 0 ; int level = triangle . size ( ) ; ArrayList < Integer > sum = new ArrayList < Integer > ( triangle . get ( triangle . size ( ) - 1 ) ) ; int [ ] tmp = new int [ sum . size ( ) ] ; for ( int l = triangle . size ( ) - 2 ; l >= 0 ; l -- ) { List < Integer > curr = triangle . get ( l ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) { int min = Math . min ( curr . get ( i ) + sum . get ( i ) , curr . get ( i ) + sum . get ( i + 1 ) ) ; tmp [ i ] = min ; System . out . print ( tmp [ i ] ) ; System . out . print ( "  " ) ; } System . out . println ( ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) sum . set ( i , tmp [ i ] ) ; } return sum . get ( 0 ) ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.ListResponse" ) public java . util . List < soa32 . resources . cliente . Cliente > list ( ) ;
te	A	private static float getByteLength ( String str ) { try { return str . getBytes ( "Shift-JIS" ) . length ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return - 1 ; }
te	C	private void loadFiles ( Properties pro ) { Enumeration < Object > enu = pro . keys ( ) ; while ( enu . hasMoreElements ( ) ) { String key = ( String ) enu . nextElement ( ) ; if ( key . contains ( "." ) == false ) { String filePath = pro . getProperty ( key ) . trim ( ) ; String cachId = key + ".size" ; int cacheSize = 0 ; if ( pro . contains ( cachId ) ) { cacheSize = Integer . parseInt ( ( String ) pro . get ( cachId ) ) ; } try { QueryMap qm = QueryFactory . createQueryMap ( filePath , cacheSize ) ; maps . put ( key , qm ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; return ; } } } }
te	E	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR , int endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
te	D	public Laser ( double x1 , double y1 , double x2 , double y2 , Object p ) { super ( null , null ) ; lastUpdate = System . currentTimeMillis ( ) ; collisionSpriteTimes = new HashMap < Sprite , long > ( ) ; line = new Line2D . double ( x1 , y1 , x2 , y2 ) ; parent = p ; if ( parent instanceof Ship ) { power = ( ( Ship ) parent ) . getPower ( ) ; } else { power = ( ( Turret ) parent ) . power ; } width = mapPowerToWidth ( power ) ; float red = ( float ) Ship . map ( power , 0 , 1000 , 0 , 1 ) ; float blue = ( float ) Ship . map ( power , 0 , 1000 , 1 , 0 ) ; float green = ( float ) Ship . map ( power , 0 , 1000 , 1 , 0 ) ; System . out . println ( "Color: " + red + ":" + blue ) ; color = new Color ( red , blue , green ) ; }
te	C	Query getOrCreateSubQuery ( MainQuery mainQuery , String newId , String ... subIds ) { int count = countSub . get ( ) ; Query oldOne = null ; oldOne = subQueries . get ( newId ) ; if ( count == countSub . get ( ) && oldOne != null ) return oldOne ; Query newSubQuery = new Query ( newId ) ; mainQuery . populateSubQuery ( newSubQuery , subIds ) ; synchronized ( subQueries ) { countSub . incrementAndGet ( ) ; oldOne = subQueries . get ( newId ) ; if ( oldOne != null ) return oldOne ; subQueries . put ( newId , newSubQuery ) ; return newSubQuery ; } }
te	B	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
te	A	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( 1 << position ) ; } else { packed &= ~ ( 1 << position ) ; } return packed ; }
te	C	public static void copyFile ( File source , File dest ) throws IOException { InputStream input = null ; OutputStream output = null ; try { input = new FileInputStream ( source ) ; output = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead ; while ( ( bytesRead = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , bytesRead ) ; } } finally { input . close ( ) ; output . close ( ) ; } }
te	E	private void initDataBase ( boolean clearOldDateBase ) throws SQLException { Statement s = null ; try { s = conn . createStatement ( ) ; for ( class < ? > daoClass : DaoClassList ) { BaseDao < ? > dao = ( BaseDao < ? > ) daoClass . getField ( "manager" ) . get ( null ) ; String sql = String . format ( "SELECT COUNT(*) as CNT FROM sqlite_master where type='table' and name='%s';" , dao . getTableName ( ) ) ; ResultSet rs = s . executeQuery ( sql ) ; rs . next ( ) ; int tableCount = rs . getInt ( "CNT" ) ; if ( tableCount > 0 && clearOldDateBase ) { s . executeUpdate ( "drop table if exists " + dao . getTableName ( ) + ";" ) ; tableCount = 0 ; } if ( tableCount == 0 ) { String sqlCreateTable = dao . createTableSql ( ) ; String sqlCreateIndex = String . format ( "CREATE UNIQUE INDEX %s ON %s (id)" , dao . getTableName ( ) + "_index" , dao . getTableName ( ) ) ; printSql ( sqlCreateTable ) ; s . execute ( sqlCreateTable ) ; printSql ( sqlCreateIndex ) ; s . execute ( sqlCreateIndex ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { s . close ( ) ; } }
te	E	private void backThreadRunLoop ( ) throws IOException { Task task ; try { task = taskQueue . get ( ) ; } catch ( InterruptedException e1 ) { return ; } if ( isIndexOutOfSourceList ( task . targetIndex ) ) { return ; } S source = sourceList . get ( task . targetIndex ) ; InputStream is = null ; Image image = null ; try { is = source . getInputStream ( ) ; if ( is != null ) { is = new InterruptInputStream ( is , task . targetIndex ) ; setStartTask ( ) ; image = ImageIO . read ( is ) ; } } catch ( RuntimeException e ) { loadedImageFail ( task . targetIndex ) ; throw e ; } catch ( IOException e ) { loadedImageFail ( task . targetIndex ) ; throw e ; } finally { try { if ( image == null ) { image = FailImage ; } synchronized ( windowLock ) { insertImageToWindow ( image , toWindowIndex ( task . targetIndex ) ) ; } loadedImage ( image , task . targetIndex ) ; } finally { setWaitingTask ( ) ; if ( is != null ) { is . close ( ) ; } } } }
te	D	public static double hypot ( final double x , final double y ) { if ( double . isInfinite ( x ) || double . isInfinite ( y ) ) { return double . POSITIVE_INFINITY ; } else if ( double . isNaN ( x ) || double . isNaN ( y ) ) { return double . NaN ; } else { final int expX = getExponent ( x ) ; final int expY = getExponent ( y ) ; if ( expX > expY + 27 ) { return abs ( x ) ; } else if ( expY > expX + 27 ) { return abs ( y ) ; } else { final int middleExp = ( expX + expY ) / 2 ; final double scaledX = scalb ( x , - middleExp ) ; final double scaledY = scalb ( y , - middleExp ) ; final double scaledH = sqrt ( scaledX * scaledX + scaledY * scaledY ) ; return scalb ( scaledH , middleExp ) ; } } }
te	D	@ Override public DependencyInstance decode ( DependencyInstance inst , LocalFeatureData lfd , GlobalFeatureData gfd , boolean addLoss ) { this . inst = inst ; this . lfd = lfd ; this . gfd = gfd ; this . addLoss = addLoss ; bestScore = double . NEGATIVE_INFINITY ; pred = new DependencyInstance ( inst ) ; pred . heads = null ; totRuns = 0 ; unchangedRuns = 0 ; stopped = false ; for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingService . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingService . take ( ) ; } catch ( InterruptedException e ) { System . out . println ( "Hill climbing thread interupted!!!!" ) ; } } return pred ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.ListResponse" ) public java . util . List < soa32 . resources . notaFiscal . NotaFiscal > list ( ) ;
te	E	public void testFont ( Font font ) { BufferedImage im = new BufferedImage ( mW , mH , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = ( Graphics2D ) im . getGraphics ( ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , mW , mH ) ; g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g . setColor ( Color . BLACK ) ; font = font . deriveFont ( mSize ) ; g . setFont ( font ) ; int h = g . getFontMetrics ( ) . getHeight ( ) ; h = ( int ) Math . max ( h , mSize ) ; g . drawString ( "ABCDEFGHI" , 10 , h ) ; g . drawString ( "JKLMNOPQR" , 10 , h * 2 ) ; g . drawString ( "STUVWXYZ" , 10 , h * 3 ) ; g . drawString ( "abcdefghi" , 10 , h * 4 ) ; g . drawString ( "jklmnopqr" , 10 , h * 5 ) ; g . drawString ( "stuvwxyz" , 10 , h * 6 ) ; if ( mPanel != null ) { mPanel . setImage ( im ) ; mPanel . repaint ( ) ; } else { mPanel = new ImagePanel ( im ) ; mFrame = ImagePanel . frameImagePanel ( mPanel ) ; mFrame . setVisible ( true ) ; } }
te	A	public static void b ( ) throws Exception { System . out . print ( "T" ) ; if ( 1 + 2 + 3 == 6 ) throw new Exception ( "1" ) ; System . out . print ( "V" ) ; }
te	C	public static int size ( Node node ) { if ( node instanceof Comment ) { return 0 ; } else if ( node instanceof PrintBold ) { return ( ( PrintBold ) node ) . message . length ( ) ; } else if ( node instanceof Print ) { return ( ( Print ) node ) . message . length ( ) ; } else if ( node instanceof Block ) { return size ( ( ( Block ) node ) . first ) + size ( ( ( Block ) node ) . second ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; return 0 ; } }
te	A	public final void dispose ( ) { if ( 0 < textureID ) { glDeleteTextures ( textureID ) ; textureID = - 1 ; } }
te	E	public static boolean transferFont ( File inDir , File inFile , File outDir , FontTester tester ) { if ( inDir == null ) { inDir = inFile . getParentFile ( ) ; } String relPath = getRelativePath ( inDir , inFile . getParentFile ( ) , true ) ; outDir = new File ( outDir , relPath ) ; FileGarbage kill = new FileGarbage ( ) ; kill . addFile ( outDir , false ) ; try { for ( File file : FontUnpacker . unpack ( inFile , kill ) ) { FontFormat format = FontFormat . forFile ( file ) ; if ( format == FontFormat . NONE ) { continue ; } File newFile = new File ( outDir , file . getName ( ) ) ; if ( newFile . exists ( ) ) { continue ; } try { System . out . println ( file . getPath ( ) ) ; Font font = Font . createFont ( format . awtType ( ) , file ) ; if ( tester != null ) { tester . testFont ( font ) ; } if ( ! outDir . exists ( ) ) { outDir . mkdirs ( ) ; } NativeFiles . copy ( file , newFile ) ; kill . remove ( outDir ) ; } catch ( Exception ex ) { } } } catch ( Exception exc ) { kill . empty ( ) ; } return true ; }
te	A	public static boolean get ( long packed , int position ) { packed >>= position ; long check = packed & 1 ; return ( check == 1 ) ; }
te	D	private static double expint ( int p , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; xs [ 0 ] = 2.718281828459045 ; xs [ 1 ] = 1.4456468917292502E-16 ; split ( 1.0 , ys ) ; while ( p > 0 ) { if ( ( p & 1 ) != 0 ) { quadMult ( ys , xs , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } quadMult ( xs , xs , as ) ; xs [ 0 ] = as [ 0 ] ; xs [ 1 ] = as [ 1 ] ; p >>= 1 ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; resplit ( result ) ; } return ys [ 0 ] + ys [ 1 ] ; }
te	E	public boolean isScramble ( String s1 , String s2 ) { if ( s1 == null && s1 == null ) return true ; else if ( s1 == null || s1 == null ) return false ; if ( s1 . length ( ) == 0 && s1 . length ( ) == 0 ) return true ; if ( s1 . length ( ) == 1 && s2 . length ( ) == 1 ) if ( s1 . equals ( s2 ) ) return true ; else return false ; if ( checkCharCount ( s1 , s2 ) ) { for ( int i = 1 ; i < s1 . length ( ) ; i ++ ) { if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( 0 , i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( i ) ) ) return true ; if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( s2 . length ( ) - i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( 0 , s2 . length ( ) - i ) ) ) return true ; } } return false ; }
te	C	@ SuppressWarnings ( "unused" ) public static void main ( String aa [ ] ) { ThisKeyword o = new ThisKeyword ( ) ; o . disp ( ) ; ThisKeyword o1 = new ThisKeyword ( ) ; System . out . println ( "value of p=" + p + "and q=" + q ) ; ThisKeyword o2 = new ThisKeyword ( 50 ) ; System . out . println ( "value of p=" + p + "and q=" + q ) ; ThisKeyword o3 = new ThisKeyword ( 200 , 300 ) ; System . out . println ( "value of p=" + p + "and q=" + q ) ; }
te	E	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; final JTextArea textArea = new JTextArea ( ) ; frame . add ( textArea ) ; frame . setSize ( 400 , 200 ) ; frame . setVisible ( true ) ; frame . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { String string = textArea . getText ( ) ; System . out . println ( string ) ; File file = new File ( "text.txt" ) ; try { StringReader stringReader = new StringReader ( string ) ; BufferedReader bufferedReader = new BufferedReader ( stringReader ) ; FileWriter fileWriter = new FileWriter ( file ) ; BufferedWriter bufferedWriter = new BufferedWriter ( fileWriter ) ; for ( String line = bufferedReader . readLine ( ) ; line != null ; line = bufferedReader . readLine ( ) ) { bufferedWriter . write ( line ) ; bufferedWriter . newLine ( ) ; } bufferedReader . close ( ) ; bufferedWriter . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } ) ; }
te	C	@ Override public void visit ( Block block ) { boolean fc = block . first instanceof Comment ; boolean sc = block . second instanceof Comment ; if ( fc && sc ) { result = new Comment ( "Cannot compile this." ) ; return ; } if ( fc ) { block . second . accept ( this ) ; return ; } ; if ( sc ) { block . first . accept ( this ) ; return ; } block . first . accept ( this ) ; Node tempResult = result ; block . second . accept ( this ) ; result = new Block ( tempResult , result ) ; }
te	D	public Image rotateImage ( Image im , double angle ) { BufferedImage image = ( BufferedImage ) im ; double sin = Math . abs ( Math . sin ( angle ) ) , cos = Math . abs ( Math . cos ( angle ) ) ; int w = image . getWidth ( ) , h = image . getHeight ( ) ; int neww = ( int ) Math . floor ( w * cos + h * sin ) , newh = ( int ) Math . floor ( h * cos + w * sin ) ; BufferedImage result = gc . createCompatibleImage ( neww , newh , Transparency . BITMASK ) ; Graphics2D g = result . createGraphics ( ) ; g . translate ( ( neww - w ) / 2 , ( newh - h ) / 2 ) ; g . rotate ( angle , w / 2 , h / 2 ) ; g . drawRenderedImage ( image , null ) ; g . dispose ( ) ; return result ; }
te	B	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < getHeight ( ) && col >= 0 && col < getWidth ( ) ) { cells [ row ] [ col ] = alive ; } }
te	C	@ SuppressWarnings ( "unchecked" ) public List < Author > getAuthorByParameters ( String firstname , String lastname , String birthdate , String biography ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Author where firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT('%'  :lastname  '%') and birthdate LIKE CONCAT ('%'  :birthdate  '%') and biography LIKE CONCAT ('%'  :biography  '%') " ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setString ( "birthdate" , birthdate ) . setString ( "biography" , biography ) ; List < Author > listAuthorsByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listAuthorsByParameters ; }
te	D	private void init ( GameManager p ) { parent = p ; this . screen = p . screen ; this . inputManager = p . inputManager ; configButton = createButton ( "config" , "Change Settings" ) ; frame = screen . getFullScreenWindow ( ) ; inputs = new ArrayList ( ) ; tabbedMainMenu = createMainMenu ( ) ; tabbedBuildMenu = createBuildMenu ( ) ; displayMainMenu = false ; NullRepaintManager . install ( ) ; Container contentPane = frame . getContentPane ( ) ; if ( contentPane instanceof JComponent ) { ( ( JComponent ) contentPane ) . setOpaque ( false ) ; } contentPane . setLayout ( new FlowLayout ( FlowLayout . LEFT ) ) ; contentPane . add ( configButton ) ; frame . validate ( ) ; screen . getFullScreenWindow ( ) . getLayeredPane ( ) . add ( tabbedMainMenu , JLayeredPane . MODAL_LAYER ) ; screen . getFullScreenWindow ( ) . getLayeredPane ( ) . add ( tabbedBuildMenu , JLayeredPane . MODAL_LAYER ) ; }
te	B	public void setPatterns ( List < Pattern > list ) { ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; }
te	A	public TestScene ( ) { BackGroundColor . WHITE . set ( ) ; add ( new DotTestCharacter ( ) ) ; add ( new TextTestCharacter ( ) ) ; }
te	C	public static AnnotationConfiguration getConfig ( ) { if ( config == null ) { config = new AnnotationConfiguration ( ) ; config . addAnnotatedClass ( Administrator . class ) ; config . addAnnotatedClass ( Author . class ) ; config . addAnnotatedClass ( Book . class ) ; config . addAnnotatedClass ( Borrowing . class ) ; config . addAnnotatedClass ( Customer . class ) ; config . addAnnotatedClass ( BookSeries . class ) ; config . addAnnotatedClass ( Editor . class ) ; config . addAnnotatedClass ( Theme . class ) ; config . configure ( "dataAccessLayer/hibernateConfig/connection.cfg.xml" ) ; } return config ; }
te	D	public void loadRocketSprites ( ) { rocketSprites = new ArrayList ( ) ; ArrayList anims = new ArrayList ( ) ; for ( int i = 0 ; i < rocketImages . size ( ) ; i ++ ) { Animation a = new Animation ( ) ; for ( int j = 0 ; j < rocketImages . get ( i ) . size ( ) ; j ++ ) { a . addFrame ( ( Image ) rocketImages . get ( i ) . get ( j ) , 200 ) ; } Animation [ ] a_array = new Animation [ 360 ] ; for ( int j = 0 ; j < 360 ; j ++ ) { a_array [ j ] = rotateAnimation ( a , Math . toRadians ( j + 1 ) ) ; } Sprite s = new Projectile ( a_array , 0 ) ; rocketSprites . add ( s ) ; } }
te	E	public static void main ( String args [ ] ) { Connection c = null ; Statement stmt = null ; try { class . forName ( "org.sqlite.JDBC" ) ; c = DriverManager . getConnection ( "jdbc:sqlite:test.db" ) ; c . setAutoCommit ( false ) ; System . out . println ( "Opened database successfully" ) ; stmt = c . createStatement ( ) ; String sql = "INSERT INTO COMPANY (ID NAME AGE ADDRESS SALARY) " + "VALUES (1  'Paul'  32  'California'  20000.00 );" ; stmt . executeUpdate ( sql ) ; sql = "INSERT INTO COMPANY (ID NAME AGE ADDRESS SALARY) " + "VALUES (2  'Allen'  25  'Texas'  15000.00 );" ; stmt . executeUpdate ( sql ) ; sql = "INSERT INTO COMPANY (ID NAME AGE ADDRESS SALARY) " + "VALUES (3  'Teddy'  23  'Norway'  20000.00 );" ; stmt . executeUpdate ( sql ) ; sql = "INSERT INTO COMPANY (ID NAME AGE ADDRESS SALARY) " + "VALUES (4  'Mark'  25  'Rich-Mond '  65000.00 );" ; stmt . executeUpdate ( sql ) ; stmt . close ( ) ; c . commit ( ) ; c . close ( ) ; } catch ( Exception e ) { System . err . println ( e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ) ; System . exit ( 0 ) ; } System . out . println ( "Records created successfully" ) ; }
te	B	private JComponent createControlPanel ( ) { controlPanel = new ControlPanel ( ) { protected void onSpeedChange ( int value ) { playTimer . setDelay ( 1 + ( 100 - value ) * 10 ) ; } protected void onStepChange ( int value ) { timeStep = value ; } protected void onZoomChange ( int value ) { gamePanel . setZoom ( value ) ; } } ; addBorder ( controlPanel , Strings . PANEL_CONTROL ) ; return controlPanel ; }
te	C	public boolean createBorrow ( int idUSer , int idBook ) { Book book = daoBook . find ( idBook ) ; Customer customer = daoCustomer . find ( idUSer ) ; if ( book == null || customer == null ) { return false ; } if ( ! book . getAvailibility ( ) ) { return false ; } Borrowing borrow = new Borrowing ( 50.0 , DateUtil . getCurrentDate ( ) , null ) ; book . setAvailibility ( false ) ; borrow . setBook ( book ) ; daoBook . update ( book ) ; borrow . setCustomer ( customer ) ; return daoBorrow . create ( borrow ) ; }
te	E	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
te	D	public static boolean isInsideTriangle ( double aX , double aY , double bX , double bY , double cX , double cY , double pX , double pY ) { double ax , ay , bx , by , cx , cy , apx , apy , bpx , bpy , cpx , cpy ; double cCROSSap , bCROSScp , aCROSSbp ; ax = cX - bX ; ay = cY - bY ; bx = aX - cX ; by = aY - cY ; cx = bX - aX ; cy = bY - aY ; apx = pX - aX ; apy = pY - aY ; bpx = pX - bX ; bpy = pY - bY ; cpx = pX - cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx * cpy - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
te	D	public void filter ( byte [ ] samples , int offset , int length ) { if ( source == null || listener == null ) { return ; } float dx = ( source . getX ( ) - listener . getX ( ) ) ; float dy = ( source . getY ( ) - listener . getY ( ) ) ; float distance = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float newVolume = ( maxDistance - distance ) / maxDistance ; if ( newVolume <= 0 ) { newVolume = 0 ; } int shift = 0 ; for ( int i = offset ; i < offset + length ; i += 2 ) { float volume = newVolume ; if ( shift < NUM_SHIFTING_SAMPLES ) { volume = lastVolume + ( newVolume - lastVolume ) * shift / NUM_SHIFTING_SAMPLES ; shift ++ ; } short oldSample = getSample ( samples , i ) ; short newSample = ( short ) ( oldSample * volume ) ; setSample ( samples , i , newSample ) ; } lastVolume = newVolume ; }
te	A	@ Override public float damage ( float damage ) { damaging = true ; dmgVibMove = 5 ; dmgVibThita = 0 ; return super . damage ( damage ) ; }
te	C	@ SuppressWarnings ( "resource" ) public static void main ( String [ ] args ) { int L , R , K ; Scanner in = new Scanner ( System . in ) ; long N = in . nextLong ( ) ; long Q = in . nextLong ( ) ; while ( N > 0 ) { A . add ( in . nextInt ( ) ) ; N -- ; } while ( Q >= 0 ) { L = in . nextInt ( ) ; R = in . nextInt ( ) ; K = in . nextInt ( ) ; Cal ( L , R , K ) ; Q -- ; } }
te	D	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
te	C	private MenuBar createTopMenu ( ) { final MenuBar menuBar = new MenuBar ( ) ; menuBar . getStyleClass ( ) . add ( "top-menu-style" ) ; final MenuItem menu13 = MenuItemBuilder . create ( ) . text ( "Quit" ) . accelerator ( KeyCombination . keyCombination ( "Shortcut+Q" ) ) . build ( ) ; menu13 . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { System . exit ( 0 ) ; } } ) ; Menu menu1 = MenuBuilder . create ( ) . text ( "File" ) . items ( menu13 ) . build ( ) ; menuBar . getMenus ( ) . addAll ( menu1 ) ; return menuBar ; }
te	C	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; for ( int m = 0 ; m < k ; m ++ ) { int n = input . nextInt ( ) ; int a [ ] = new int [ n + 1 ] ; int digit = 1 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextInt ( ) ; Factor ( a [ i ] ) ; digit = digit * a [ i ] ; } Factor ( digit ) ; System . out . println ( fa . size ( ) ) ; fa . clear ( ) ; } }
te	B	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
te	A	public void swapL ( int i ) { char tmp = hp . get ( i ) ; hp . set ( i , hp . get ( 2 * i + 1 ) ) ; hp . set ( 2 * i + 1 , tmp ) ; }
te	E	private void load ( File fileName ) throws IOException { FileRead fp = new FileRead ( fileName ) ; if ( fp != null ) { LevelLayer curElem = null ; while ( fp . hasNext ( ) ) { switch ( fp . getNext ( ) ) { case "COLLISION" : collision = new Collision ( fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "LAYER" : curElem = new LevelLayer ( this ) ; layers . push ( curElem ) ; curElem . load ( Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "IMG" : curElem . load ( Data . getDataDirectory ( ) + "/data/gfx/tileset/" + fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) ) ; curElem . load ( fp ) ; break ; case "OBJECTS" : loadObjects ( fp ) ; break ; default : break ; } } if ( layers . size ( ) == 0 ) { throw new IOException ( "No level layers found in:\n" + fileName + "\nPerhaps it is not a valid level file?" ) ; } } fp . close ( ) ; }
te	E	public static String decodeSW ( byte [ ] apdu ) { if ( apdu == null || apdu . length < 2 ) return "Unknown" ; if ( apdu [ apdu . length - 2 ] == 6c ) { int num = apdu [ apdu . length - 1 ] & ff ; return "Le incorrect" + ( num > 0 ? ": " + num + " bytes available" : "" ) ; } int sw = ( ( apdu [ apdu . length - 2 ] & FF ) << 8 ) + ( apdu [ apdu . length - 1 ] & ff ) ; switch ( sw ) { case 9000 : return "Status OK" ; case 6282 : return "End of file" ; case 6882 : return "Secure messaging not supported" ; case 6982 : return "Security status not satisfied" ; case 6986 : return "No EF selected" ; case 6A82 : return "No SFI found in current DF / file not found" ; case 6A86 : return "Incorrect P1/P2" ; case 6E00 : return "Invalid CLA" ; case 6700 : return "Wrong length" ; case 6A80 : return "Wrong data" ; case 6300 : return "PIN verification failed" ; case 6983 : return "PIN / PUC blocked" ; case 6D00 : return "INS not supported" ; case 6985 : return "Conditions not satisfied" ; case 6A88 : return "Key not found / selected" ; case 6A81 : return "Algorithm not supported" ; case 6883 : return "Last command expected" ; case 6984 : return "Wrong key use" ; default : return "Unknown" ; } }
te	B	private static void listarClientes ( ) { ArrayList < Cliente > listaCliente = ( ArrayList < Cliente > ) ClienteUtils . criaClienteResourcePortType ( ) . list ( ) ; System . out . println ( "listagem do nome dos clientes:" ) ; for ( Cliente cliente : listaCliente ) { System . out . println ( cliente . getId ( ) ) ; } }
te	A	public final void bind ( ) { glBindTexture ( target , textureID ) ; glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ; glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ; }
te	C	@ Override public void handle ( MouseEvent mouseEvent ) { if ( mouseEvent . getButton ( ) . equals ( MouseButton . PRIMARY ) ) { if ( mouseEvent . getClickCount ( ) == 2 ) { book . setAvailibility ( false ) ; daoBook . update ( book ) ; DialogUtil . basicDialog ( "Book : " + book . getName ( ) + " deleted" ) ; bookList = bookCtrl . getBooksByParameters ( txtFieldName . getText ( ) , txtFieldAuthor . getText ( ) , txtFieldYear . getText ( ) , comboBookType . getValue ( ) . toString ( ) , seriesTf . getText ( ) , comboAvailable . getValue ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; updateBookListView ( ) ; } } }
te	E	public void crear ( String nombre , String direccion ) throws ID3Exception , IOException { File texto = new File ( nombre + ".txt" ) ; texto . createNewFile ( ) ; FileWriter manejarTextoEscritura = new FileWriter ( texto ) ; MetaDatos p = new MetaDatos ( direccion ) ; Extraer_imgen_allbum Album_can = new Extraer_imgen_allbum ( ) ; Escribir_por_linea = new PrintWriter ( manejarTextoEscritura ) ; Escribir_por_linea . println ( direccion ) ; Escribir_por_linea . println ( nombre ) ; Escribir_por_linea . println ( p . getArtista ( ) ) ; Escribir_por_linea . println ( p . getAnno ( ) ) ; Escribir_por_linea . println ( p . getTitulo ( ) ) ; Escribir_por_linea . println ( p . getAlbum ( ) ) ; Escribir_por_linea . println ( p . getGenero ( ) ) ; Escribir_por_linea . println ( p . Duracion ( ) ) ; Escribir_por_linea . println ( Album_can . ObtenerImagen ( direccion , nombre ) ) ; manejarTextoEscritura . close ( ) ; File miDir = new File ( "." ) ; Ruta = miDir . getCanonicalPath ( ) + "/Lista_canciones.txt" ; File Archivo = new File ( Ruta ) ; Bandera = Archivo . exists ( ) ; FileWriter Escribir = new FileWriter ( Archivo , Bandera ) ; Escribir . write ( "\n" ) ; Escribir . write ( nombre ) ; Escribir . close ( ) ; }
te	C	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int Pay ; Pay = Taxes [ 0 ] ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; ( Game . players . get ( Owner ) ) . ChangeMoney ( Pay ) ; } } }
te	D	private void checkLaserCollisionsWithSprites ( Laser laser ) { LinkedList < Sprite > oldSprites = map . getSprites ( ) ; LinkedList < Sprite > sprites = ( LinkedList < Sprite > ) oldSprites . clone ( ) ; for ( int i = 0 ; i < map . getAIShips ( ) . size ( ) ; i ++ ) { sprites . add ( map . getAIShips ( ) . get ( i ) ) ; } for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; if ( sprite instanceof Planet ) { Planet planet = ( Planet ) sprite ; if ( isCollision ( laser , planet ) ) collideLaserWithSprite ( laser , planet ) ; } else if ( sprite instanceof Ship ) { Ship ship = ( Ship ) sprite ; if ( isCollision ( laser , ship ) ) collideLaserWithSprite ( laser , ship ) ; } else if ( sprite instanceof Turret ) { Turret t = ( Turret ) sprite ; } } }
te	D	public Turret ( Ship p , float x , float y , int level , Animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getParent ( ) . parent . getMap ( ) ; this . level = level ; setHitpoints ( level * 100 ) ; power = level ; TURRET_REACH = level * TURRET_TO_LEVEL ; int width = ( int ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; int height = ( int ) ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; this . setX ( x ) ; this . setY ( y ) ; circle = new Ellipse2D . double ( this . getX ( ) - width / 2 , ( double ) ( this . getY ( ) - height / 2 ) , ( double ) ( width ) , ( double ) ( height ) ) ; target = aquireTarget ( ) ; bodyColor = Color . white ; }
te	C	@ Override public void keyPressed ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( ( keycode == KeyEvent . VK_A ) || ( keycode == KeyEvent . VK_S ) || ( keycode == KeyEvent . VK_D ) || ( keycode == KeyEvent . VK_F ) ) { if ( keycode == KeyEvent . VK_A ) { aDown = true ; } else if ( keycode == KeyEvent . VK_S ) { sDown = true ; } else if ( keycode == KeyEvent . VK_D ) { dDown = true ; } else if ( keycode == KeyEvent . VK_F ) { fDown = true ; } if ( aDown && sDown && dDown && fDown ) { mapBoard1 . whackKeyDown = true ; easteregg . startSound ( ) ; } } }
te	B	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
te	A	public final void point ( final int srcX , final int srcY ) { float tx = 1.0f * srcX / texWidth ; float ty = 1.0f * srcY / texHeight ; glTexCoord2f ( tx , ty ) ; }
te	A	public static void play ( long world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	D	public double getSRLCost ( SemanticFrame [ ] gold , SemanticFrame [ ] pred ) { Utils . assert ( gold . length == pred . length ) ; double dis = 0 ; for ( int i = 0 , N = gold . length ; i < N ; ++ i ) { Utils . assert ( gold [ i ] . predid == pred [ i ] . predid ) ; int [ ] ga = gold [ i ] . arglbids , pa = pred [ i ] . arglbids ; for ( int j = 0 , L = ga . length ; j < L ; ++ j ) { if ( isPruned ( gold [ i ] . predid , j ) ) continue ; int garg = ga [ j ] ; if ( garg != pa [ j ] ) { if ( garg < 0 ) dis += 1.0 ; else if ( pa [ j ] < 0 ) dis += 2.0 ; else dis += 0.5 ; } } } return dis ; }
te	C	public static void main ( String [ ] args ) { System . out . println ( DemoCasting . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; Visitor . print ( 0 , prog ) ; System . out . println ( "--------------" ) ; Visitor . exec ( prog ) ; System . out . println ( "--------------" ) ; System . out . println ( Visitor . size ( prog ) ) ; System . out . println ( "--------------" ) ; Visitor . dump ( prog ) ; System . out . println ( ) ; Visitor . dump ( Visitor . compile ( prog ) ) ; System . out . println ( ) ; }
te	B	@ RequestWrapper ( localName = "deleteAll" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.DeleteAll" ) @ WebMethod @ ResponseWrapper ( localName = "deleteAllResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.DeleteAllResponse" ) public void deleteAll ( @ WebParam ( name = "ids" , targetNamespace = "" ) java . util . List < java . lang . long > ids ) ;
te	B	protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; }
te	E	public FontPanel ( FontHandle font ) { mFont = font ; setLayout ( this ) ; mEnableBox = new JCheckBox ( ) ; mEnableBox . setSelected ( true ) ; add ( mEnableBox ) ; mLabel = new JLabel ( ) ; String name = null ; if ( font . font ( ) != null ) name = font . font ( ) . getName ( ) ; if ( name == null || name . length ( ) == 0 ) name = font . file ( ) . getName ( ) ; mLabel . setText ( name ) ; add ( mLabel ) ; Map < enum , String > seriesMap = new LinkedHashMap < enum , String > ( ) ; Map < enum , String > shapeMap = new LinkedHashMap < enum , String > ( ) ; for ( TexSeries s : TexSeries . values ( ) ) { seriesMap . put ( s , s . code ( ) ) ; } for ( TexShapes s : TexShapes . values ( ) ) { shapeMap . put ( s , s . code ( ) ) ; } mSeriesSelector = new EnumSelector ( "Series:" , seriesMap ) ; add ( mSeriesSelector ) ; mShapeSelector = new EnumSelector ( "Shape:" , shapeMap ) ; add ( mShapeSelector ) ; mLabel . setOpaque ( false ) ; setOpaque ( true ) ; }
te	D	public synchronized Response sendRequest ( int address , RequestCommand command , int timeout ) throws SerialPortException , TimeoutException { final CountDownLatch latch = new CountDownLatch ( 1 ) ; ResponseListener < Response > listener = new ResponseListener < Response > ( ) { @ Override public void onResponse ( Response response ) { lastResponse = response ; latch . countDown ( ) ; } } ; subscribe ( listener , command . getResponseType ( ) ) ; send ( ( char ) ( BCAST_ADDRESS + address ) + command . toString ( ) ) ; try { if ( latch . await ( timeout , TimeUnit . MILLISECONDS ) ) return lastResponse ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } unsubscribe ( listener , command . getResponseType ( ) ) ; throw new TimeoutException ( ) ; }
te	C	@ SuppressWarnings ( "rawtypes" ) public static void main ( String [ ] args ) { Map < Integer , String > map1 = new TreeMap < Integer , String > ( ) ; map1 . put ( 101 , "this" ) ; map1 . put ( 103 , "is" ) ; map1 . put ( 102 , "TreeMap" ) ; System . out . println ( map1 ) ; Set set = map1 . entrySet ( ) ; Iterator itr = set . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry g = ( Map . Entry ) itr . next ( ) ; System . out . println ( g . getKey ( ) + " " + g . getValue ( ) ) ; } }
te	B	public static int addDef ( int piece ) { if ( piece == DraughtsState . WHITEKING || piece == DraughtsState . WHITEPIECE ) { return 5 ; } if ( piece == DraughtsState . BLACKKING || piece == DraughtsState . BLACKPIECE ) { return - 5 ; } return 0 ; }
te	A	private static int get2Fold ( final int fold ) { int ret = 2 ; while ( ret < fold ) { ret *= 2 ; } return ret ; }
te	A	MaxHeap ( char name , String str ) { heapName = name ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { insert ( str . charAt ( i ) ) ; } }
te	B	HelloActionWorld ( ) { super ( "Hello Action" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; label = new JLabel ( "Button unpressed" ) ; add ( label ) ; JButton button = new JButton ( "Press me" ) ; add ( button ) ; button . addActionListener ( new ButtonAction ( ) ) ; setSize ( 320 , 240 ) ; }
te	B	public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } }
te	A	public TitleScene ( ) { BackGroundColor . WHITE . set ( ) ; pressStartText = add ( new TextCharacter ( "PRESS START!" ) ) ; pressStartText . setColor ( Color . blue ) . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) ; }
te	B	private static void listarNotasFiscais ( ) { ArrayList < NotaFiscal > listaNota = ( ArrayList < NotaFiscal > ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; System . out . println ( "listagem do numero das notas fiscais:" ) ; for ( NotaFiscal notaFiscal : listaNota ) { System . out . println ( notaFiscal . getId ( ) ) ; } }
te	E	public void selectDB ( ) { System . out . println ( "Opene" ) ; try { class . forName ( "org.sqlite.JDBC" ) ; connect = DriverManager . getConnection ( "jdbc:sqlite:" + nameDateBase ) ; stmt = connect . createStatement ( ) ; connect . setAutoCommit ( false ) ; System . out . println ( "Opened database successfully" ) ; stmt = connect . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT * FROM " + nameTable + ";" ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; String town = rs . getString ( "TOWN" ) ; System . out . println ( "ID = " + id ) ; System . out . println ( "TOWN = " + town ) ; System . out . println ( ) ; } rs . close ( ) ; stmt . close ( ) ; connect . close ( ) ; } catch ( Exception e ) { System . err . println ( e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ) ; System . exit ( 0 ) ; } System . out . println ( "Operation done successfully" ) ; }
te	A	public void draw ( Graphics g , int speed , int nabiki , int length ) { g . setColor ( color ) ; g . drawLine ( point . x , point . y , point . x + nabiki , point . y + length ) ; }
te	D	public static boolean line_line ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; return ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) ; } return false ; }
te	E	public void run ( ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; double width = srcImage . getWidth ( ) ; double height = srcImage . getHeight ( ) ; double m = 0 ; if ( width > height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; } else if ( width <= height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width / width ; width = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width ; height = height * m ; } Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( int ) width , ( int ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; fullImage . setIcon ( imageIcon ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } }
te	E	public ImageIcon call ( ) throws Exception { FileInputStream fileInput = new FileInputStream ( imagePath ) ; ImageInputStream imageInput = ImageIO . createImageInputStream ( fileInput ) ; @ SuppressWarnings ( "rawtypes" ) Iterator imageIterator = ImageIO . getImageReaders ( imageInput ) ; if ( ! imageIterator . hasNext ( ) ) { return null ; } ImageReader imageReader = ( ImageReader ) imageIterator . next ( ) ; ImageReadParam imageParameters = imageReader . getDefaultReadParam ( ) ; imageReader . setInput ( imageInput , true , true ) ; double m = 0 ; if ( imageReader . getWidth ( 0 ) > imageReader . getHeight ( 0 ) ) { m = ( double ) imageReader . getWidth ( 0 ) / constant ; } else if ( imageReader . getWidth ( 0 ) <= imageReader . getHeight ( 0 ) ) { m = ( double ) imageReader . getHeight ( 0 ) / constant ; } m = m + 0.5 ; if ( m < 1.0 ) { m = 1.0 ; } imageParameters . setSourceSubsampling ( ( int ) m , ( int ) m , 0 , 0 ) ; BufferedImage image = imageReader . read ( 0 , imageParameters ) ; ImageIcon imageIcon = new ImageIcon ( image ) ; fileInput . close ( ) ; imageInput . close ( ) ; return imageIcon ; }
te	C	public static void main ( String [ ] args ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; Connection con = DriverManager . getConnection ( "jdbc:mysql://localhost:3308/data" , "root" , "" ) ; Statement st = con . createStatement ( ) ; ResultSet rs = st . executeQuery ( "select * from emp" ) ; while ( rs . next ( ) ) { System . out . println ( rs . getInt ( 1 ) + "  " + rs . getString ( 2 ) ) ; } con . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	D	public void update ( long elapsedTime ) { ShipV2 player = ( ShipV2 ) map . getPlayer ( ) ; JTabbedPane tabbelShipMenu = menu . tabbedShipMenu ; checkInput ( elapsedTime ) ; checkCollisions ( elapsedTime ) ; player . update ( elapsedTime ) ; map . updateSpriteV2 ( elapsedTime ) ; LinkedList < Sprite > sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; if ( sprite instanceof Creature ) { Creature creature = ( Creature ) sprite ; if ( creature . getState ( ) == Creature . STATE_DEAD ) { sprites . remove ( i ) ; } else { updateCreature ( creature , elapsedTime ) ; } } sprite . update ( elapsedTime ) ; } }
te	E	public int [ ] searchRange0 ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] == target ) { for ( int i = mid - 1 ; i >= - 1 ; i -- ) { if ( i == - 1 || nums [ i ] != target ) { pos [ 0 ] = i + 1 ; break ; } } for ( int i = mid + 1 ; i <= nums . length ; i ++ ) { if ( i == nums . length || nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
te	C	@ Override public int compareTo ( ReadOnlyArray < E > o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . es . length - o . es . length ; if ( diff != 0 ) return diff ; for ( int i = 0 ; i < this . es . length ; i ++ ) { diff = this . es [ i ] . compareTo ( o . es [ i ] ) ; if ( diff != 0 ) return diff ; } return 0 ; }
te	B	@ Test public void testeClienteIgual ( ) { Produto p1 = new Produto ( ) ; p1 . setId ( ( long ) 1 ) ; Produto p2 = new Produto ( ) ; p2 . setId ( ( long ) 1 ) ; assertTrue ( ListaUtils . igual ( p1 , p2 ) ) ; }
te	B	public GuiLife ( ) { super ( "GuiLife" ) ; setSize ( 640 , 480 ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BorderLayout ( ) ) ; JComponent optionsPanel = createOptionsPanel ( ) ; add ( optionsPanel , BorderLayout . WEST ) ; JComponent gamePanel = createGamePanel ( ) ; add ( gamePanel , BorderLayout . CENTER ) ; }
te	D	public Response addChar ( byte c ) { if ( c == ( byte ) c2 ) { if ( sb . length ( ) != 0 ) reset ( ) ; } else { if ( source == - 1 ) { source = ( c & FF ) - SerialCom . BCAST_ADDRESS ; timestamp = System . currentTimeMillis ( ) ; } else { sb . append ( ( char ) c ) ; if ( currentResponse == null ) { String responseString = sb . toString ( ) ; for ( RequestCommand comm : commandTypes ) if ( comm . isResponse ( responseString ) ) currentResponse = comm . createResponse ( source , timestamp ) ; } else { if ( currentResponse . isValid ( sb . toString ( ) ) ) { currentResponse . parse ( sb . toString ( ) ) ; Response r = currentResponse ; reset ( ) ; return r ; } } } } return null ; }
te	C	@ Override public int compareTo ( ReadOnlyInts o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff != 0 ) return diff ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff != 0 ) return diff ; } return 0 ; }
te	A	private FontDef ( String filePath , float size ) { this . filePath = filePath ; this . size = size ; }
te	C	private void jTable1KeyPressed ( java . awt . event . KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case VK_DOWN : if ( ( jTable1 . getSelectedRow ( ) + 1 ) == jTable1 . getRowCount ( ) ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . addRow ( new Object [ ] { "Ny spiller" } ) ; } break ; case VK_DELETE : if ( jTable1 . getSelectedRow ( ) > 0 ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . removeRow ( jTable1 . getSelectedRow ( ) ) ; } break ; } }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "update" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.Update" ) @ WebMethod @ ResponseWrapper ( localName = "updateResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.UpdateResponse" ) public soa32 . resources . cliente . Cliente update ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id , @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . cliente . Cliente entity ) ;
te	D	private FeatureVector getdV ( int k , LocalFeatureData lfd , int [ ] actDeps , int [ ] predDeps ) { double [ ] [ ] wpU = lfd . wpU ; FeatureVector [ ] wordFvs = lfd . wordFvs ; int L = wordFvs . length ; FeatureVector dV = new FeatureVector ( M ) ; for ( int mod = 1 ; mod < L ; ++ mod ) { int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head == head2 ) continue ; int d = getBinnedDistance ( head - mod ) ; int d2 = getBinnedDistance ( head2 - mod ) ; double dotu = wpU [ head ] [ k ] ; double dotu2 = wpU [ head2 ] [ k ] ; dV . addEntries ( wordFvs [ mod ] , dotu * ( W [ k ] [ 0 ] + W [ k ] [ d ] ) - dotu2 * ( W [ k ] [ 0 ] + W [ k ] [ d2 ] ) ) ; } return dV ; }
te	A	public static void a ( ) throws Exception { System . out . print ( "S" ) ; b ( ) ; System . out . print ( "J" ) ; }
te	B	public static List < Pattern > load ( Reader r ) throws IOException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMessage ( ) ) ; } } return resultList ; }
te	B	public static ArrayList < Cliente > listaAdicionarCliente ( ArrayList < Cliente > nova , ArrayList < Cliente > antiga ) { ArrayList < Cliente > list = new ArrayList < Cliente > ( ) ; for ( Cliente a : nova ) { boolean existe = false ; for ( Cliente b : antiga ) { if ( igual ( a , b ) ) existe = true ; } if ( ! existe ) list . add ( a ) ; } return list ; }
te	E	public String convert1 ( String s , int numRows ) { if ( s . isEmpty ( ) ) { return "" ; } if ( s . length ( ) <= numRows ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { if ( i % 2 == 0 ) { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; j += ( numRows + numRows / 2 ) ; } } else { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; int next = j + ( numRows - ( i + 1 ) ) + numRows / 2 ; if ( next < s . length ( ) ) { sb . append ( s . charAt ( next ) ) ; } j += ( numRows + numRows / 2 ) ; } } } return sb . toString ( ) ; }
te	D	private ArrayList < Creature > getPossibleTargets ( ) { ArrayList < Creature > possibleTargets = new ArrayList < Creature > ( ) ; TileMap map = ( ( Ship ) parent ) . getParent ( ) . parent . getMap ( ) ; LinkedList sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distanceBetween ( ( Creature ) sprites . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( ( Creature ) sprites . get ( i ) ) ; } } ArrayList < Ship > aiShips = map . getAIShips ( ) ; for ( int i = 0 ; i < aiShips . size ( ) ; i ++ ) { if ( aiShips . get ( i ) != this . parent && distanceBetween ( aiShips . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( aiShips . get ( i ) ) ; } } return possibleTargets ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "list" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.List" ) @ WebMethod @ ResponseWrapper ( localName = "listResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.ListResponse" ) public java . util . List < soa32 . resources . produto . Produto > list ( ) ;
te	E	public String longestPalindrome ( String s ) { if ( s . isEmpty ( ) ) { return null ; } if ( s . length ( ) == 1 ) { return s ; } int start = 0 , len = 0 ; for ( int i = 0 ; i < s . length ( ) ; ) { if ( ( s . length ( ) - i ) < len / 2 ) { break ; } int p = i , q = i ; while ( q < s . length ( ) - 1 && s . charAt ( q + 1 ) == s . charAt ( i ) ) { q ++ ; } i = q + 1 ; while ( p > 0 && q < s . length ( ) - 1 && s . charAt ( p - 1 ) == s . charAt ( q + 1 ) ) { p -- ; q ++ ; } int newLen = q - p + 1 ; if ( newLen > len ) { start = p ; len = newLen ; } } return s . substring ( start , start + len ) ; }
te	E	public int atoi ( String str ) { String str1 = str . trim ( ) ; if ( str1 . isEmpty ( ) ) { return 0 ; } int result = 0 ; boolean negative = false ; int limit = - Integer . MAX_VALUE ; int i = 0 ; char firstChar = str1 . charAt ( 0 ) ; if ( firstChar == - ) { negative = true ; i ++ ; limit = Integer . MIN_VALUE ; } if ( firstChar == + ) { i ++ ; } if ( i >= str1 . length ( ) || ! Character . isDigit ( str1 . charAt ( i ) ) ) { return 0 ; } int multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { int digit = Character . digit ( str1 . charAt ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result *= 10 ; if ( result < limit + digit ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result -= digit ; } return negative ? result : - result ; }
te	C	private void postProcess ( char c ) throws ParsingException { ++ colNum ; String subFile = context . getSubFile ( ) ; if ( subFile != null ) { logger . info ( "Found a nested sub file. it will process " + subFile ) ; context . setSubFile ( null ) ; int beforeSizeOfMainQueries = context . sizeOfMainQuery ( ) ; int beforeSizeOfExtQueries = context . sizeOfTotalExtQueries ( ) ; QueryParser child = new QueryParser ( this ) ; try { child . parse ( new URL ( this . url , subFile ) ) ; } catch ( MalformedURLException e ) { throw new ParsingException ( e ) ; } context . setFileInfo ( this ) ; offsetTotalMainQueries += ( context . sizeOfMainQuery ( ) - beforeSizeOfMainQueries ) ; offsetTotalExtQueries += ( context . sizeOfTotalExtQueries ( ) - beforeSizeOfExtQueries ) ; } }
te	E	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 600 , 400 ) ; frame . setTitle ( "This is title form..." ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setBackground ( Color . BLUE ) ; sleep ( 3000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; frame . setResizable ( false ) ; frame . setState ( JFrame . ICONIFIED ) ; sleep ( 3000 ) ; frame . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; sleep ( 3000 ) ; frame . setExtendedState ( JFrame . NORMAL ) ; frame . setBackground ( Color . BLUE ) ; frame . addMouseListener ( new MouseListener ( ) { @ Override public void mouseReleased ( MouseEvent e ) { System . out . println ( "mouseReleased" ) ; } @ Override public void mousePressed ( MouseEvent e ) { System . out . println ( "mousePressed" ) ; } @ Override public void mouseExited ( MouseEvent e ) { System . out . println ( "mouseExited" ) ; } @ Override public void mouseEntered ( MouseEvent e ) { System . out . println ( "mouseEntered " ) ; } @ Override public void mouseClicked ( MouseEvent e ) { System . out . println ( "mouseClicked " ) ; } } ) ; }
te	D	public void updateAI ( long timeElapsed ) { if ( parent instanceof AIShip ) { if ( currentState == STATE_DISCOVER ) { discover ( ) ; } else if ( currentState == STATE_ATTACK ) { attack ( target ) ; } else if ( currentState == STATE_DEFEND ) { defend ( target ) ; } else if ( currentState == STATE_FOLLOW ) { Vector v = new Vector ( ) ; v . add ( target . getX ( ) ) ; v . add ( target . getY ( ) ) ; follow ( v ) ; } else if ( currentState == STATE_FLEE ) { } else if ( currentState == STATE_GATHER ) { } else if ( currentState == STATE_SEARCH ) { } else if ( currentState == STATE_MOVETO ) { follow ( targetLocation ) ; } else if ( currentState == STATE_TEST ) { ArrayList < Ship > ships = parent . parent . parent . getMap ( ) . getAIShips ( ) ; if ( ships . indexOf ( parent ) == 0 ) { } else { } } } }
te	D	public static double [ ] line_line_p ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double [ ] result = NONE ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) result = new double [ ] { x0 + f1 * s , y0 + g1 * s } ; } return result ; }
te	A	public void swapR ( int i ) { char tmp = hp . get ( i ) ; hp . set ( i , hp . get ( 2 * i + 2 ) ) ; hp . set ( 2 * i + 2 , tmp ) ; }
te	A	public static void main ( String [ ] args ) { store ( ) ; System . out . println ( fib . length ) ; }
te	E	void actionSetPIN ( ) throws CardServiceException { char [ ] p1 = adminPane . getPIN1 ( ) ; char [ ] p2 = adminPane . getPIN2 ( ) ; if ( ! new String ( p1 ) . equals ( new String ( p2 ) ) ) { JOptionPane . showMessageDialog ( this , "The two PINs do not match!" ) ; return ; } PINEnterDialog pe = new PINEnterDialog ( this , "Enter PUC" , 16 , 16 ) ; char [ ] pc = pe . getPIN ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changePIN ( puc , pin ) ; adminPane . clearPIN12 ( ) ; } }
te	A	public Texture ( final int target , final int textureID ) { this . target = target ; this . textureID = textureID ; this . isAlphaPremultiplied = true ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.GetResponse" ) public soa32 . resources . notaFiscal . NotaFiscal get ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	C	@ Override public void visit ( Block block ) { boolean fc = block . first instanceof Comment ; boolean sc = block . second instanceof Comment ; if ( fc && sc ) { result = new Comment ( "Cannot compile this." ) ; return ; } if ( fc ) { visit ( block . second ) ; return ; } ; if ( sc ) { visit ( block . first ) ; return ; } visit ( block . first ) ; Node tempResult = result ; visit ( block . second ) ; result = new Block ( tempResult , result ) ; }
te	A	public void update ( double timeScale ) { jitenAngle += ( ( 365 * FPS ) / jitenSpeed ) * timeScale ; kotenAngle += ( FPS / kotenSpeed ) * timeScale ; }
te	D	public void addItem ( int s , int t , int comp , int r , int type , double value , ParseForestItem left , ParseForestItem right ) { if ( chart [ s ] [ t ] [ comp ] [ K - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ K - 1 ] . score ) { ParseForestItem item = new ParseForestItem ( s , t , comp , r , type , value , left , right ) ; int i = K - 1 ; while ( i > 0 && ( chart [ s ] [ t ] [ comp ] [ i - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ i - 1 ] . score ) ) { chart [ s ] [ t ] [ comp ] [ i ] = chart [ s ] [ t ] [ comp ] [ i - 1 ] ; -- i ; } chart [ s ] [ t ] [ comp ] [ i ] = item ; } }
te	E	public Notebook ( ) { getContentPane ( ) . add ( content ) ; scrollPane = new JScrollPane ( content ) ; getContentPane ( ) . add ( scrollPane , "Center" ) ; for ( menu_count = 0 ; menu_count < menu . length ; menu_count ++ ) { nbMenuBar . add ( menu [ menu_count ] ) ; menu [ menu_count ] . addActionListener ( this ) ; while ( ( menu_count == 0 ) && ( menuitem_count < File_Item . length ) ) { menu [ 0 ] . add ( File_Item [ menuitem_count ] ) ; File_Item [ menuitem_count ] . addActionListener ( this ) ; menuitem_count ++ ; } menuitem_count = 0 ; while ( ( menu_count == 1 ) && ( menuitem_count < Edit_Item . length ) ) { menu [ 1 ] . add ( Edit_Item [ menuitem_count ] ) ; Edit_Item [ menuitem_count ] . addActionListener ( this ) ; menuitem_count ++ ; } } menu [ 3 ] . add ( Abt_Item ) ; menu [ 2 ] . add ( Font_Item ) ; Abt_Item . addActionListener ( this ) ; Font_Item . addActionListener ( this ) ; setJMenuBar ( nbMenuBar ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; }
te	A	public final Texture loadTexture ( final String imagePath , final ClassLoader classLoader ) throws IOException { return loadTexture ( ImageIO . read ( classLoader . getResourceAsStream ( imagePath ) ) ) ; }
te	A	@ Override public void hitEffectTo ( ShootingObject target ) { super . hitEffectTo ( target ) ; this . setTarget ( target ) ; shoot ( new Effect ( getParentScene ( ) , target ) ) ; }
te	A	public static void main ( String [ ] args ) { System . out . println ( parseAndRep ( args ) ) ; }
te	B	@ RequestWrapper ( localName = "deleteAll" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteAll" ) @ WebMethod @ ResponseWrapper ( localName = "deleteAllResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.cliente.DeleteAllResponse" ) public void deleteAll ( @ WebParam ( name = "ids" , targetNamespace = "" ) java . util . List < java . lang . long > ids ) ;
te	C	private static int transform ( String ai , String bi ) { if ( ai . length ( ) <= 0 || bi . length ( ) <= 0 ) { return 0 ; } else { String m1 = ai . substring ( 0 , ai . length ( ) - 1 ) ; String n1 = bi . substring ( 0 , bi . length ( ) - 1 ) ; return 1 + min ( transform ( m1 , bi ) , transform ( ai , n1 ) , transform ( m1 , n1 ) ) ; } }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "get" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.Get" ) @ WebMethod @ ResponseWrapper ( localName = "getResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.produto.GetResponse" ) public soa32 . resources . produto . Produto get ( @ WebParam ( name = "id" , targetNamespace = "" ) java . lang . long id ) ;
te	B	private static void listarProdutos ( ) { ArrayList < Produto > listaProduto = ( ArrayList < Produto > ) ProdutoUtils . criaProdutoResourcePortType ( ) . list ( ) ; System . out . println ( "listagem do numero dos produtos:" ) ; for ( Produto produto : listaProduto ) { System . out . println ( produto . getTamanho ( ) ) ; } }
te	A	@ Override public void update ( ) { updateText ( getTestText ( ) ) ; super . update ( ) ; }
te	A	public final Texture loadTexture ( final BufferedImage image ) throws IOException { return loadTexture ( image , GL_TEXTURE_2D , GL_RGBA , GL_LINEAR , GL_LINEAR ) ; }
te	B	@ WebResult ( name = "return" , targetNamespace = "" ) @ RequestWrapper ( localName = "create" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.Create" ) @ WebMethod @ ResponseWrapper ( localName = "createResponse" , targetNamespace = "http://resource.faturamento.soa32/" , className = "soa32.resources.notaFiscal.CreateResponse" ) public java . lang . long create ( @ WebParam ( name = "entity" , targetNamespace = "" ) soa32 . resources . notaFiscal . NotaFiscal entity ) ;
