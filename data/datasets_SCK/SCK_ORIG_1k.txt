tr	ORIG	public featurevector createspanfeaturevector ( dependencyinstance s , int id , int end , int punc , int bin ) { featurevector fv = new featurevector ( numarcfeats ) ; int hp = s . postagids [ id ] ; int hc = s . cpostagids [ id ] ; int epflag = ( end << 1 ) | punc ; long code = 0 ; code = createarccodeppp ( hv_hp , hp , epflag , bin ) ; addarcfeature ( code , fv ) ; code = createarccodeppp ( hv_hc , hc , epflag , bin ) ; addarcfeature ( code , fv ) ; return fv ; }
tr	ORIG	@ override public void update ( ) { inputprocess ( ) ; for ( iterator < gameobject > ite = getiterator ( ) ; ite . hasnext ( ) ; ) { gameobject go = ite . next ( ) ; if ( go instanceof starcharacter ) { ( ( starcharacter ) go ) . update ( gettimescale ( ) ) ; } else { go . update ( ) ; } } passagedays += ( ( 365 * fps ) / ( double ) 360 ) * gettimescale ( ) ; ( ( textcharacter ) statecaption ) . updatetext ( getstatestring ( ) ) ; }
tr	ORIG	private void follow ( vector followloc ) { float vectordiffx = ( float ) followloc . get ( 0 ) - parent . getx ( ) ; float vectordiffy = ( float ) followloc . get ( 1 ) - parent . gety ( ) ; float totaldiff = ( float ) math . sqrt ( ( vectordiffx * vectordiffx ) + ( vectordiffy * vectordiffy ) ) ; totaldiff = ( float ) ( totaldiff / .05 ) ; if ( totaldiff > 50 ) { parent . setvelocity ( parent . steering . wander ( ) ) ; } else { parent . setvelocityx ( 0 ) ; parent . setvelocityy ( 0 ) ; currentstate = state_discover ; } }
tr	ORIG	public static void print ( int indent , node node ) { if ( node instanceof comment ) { printindent ( indent , "// " + ( ( comment ) node ) . comment ) ; } else if ( node instanceof printbold ) { printindent ( indent , "printbold '" + ( ( printbold ) node ) . message + "'" ) ; } else if ( node instanceof print ) { printindent ( indent , "print '" + ( ( print ) node ) . message + "'" ) ; } else if ( node instanceof block ) { printindent ( indent , "begin" ) ; print ( indent + 1 , ( ( block ) node ) . first ) ; print ( indent + 1 , ( ( block ) node ) . second ) ; printindent ( indent , "end" ) ; } else { system . err . println ( "err: no match for node." ) ; system . exit ( 42 ) ; } }
tr	ORIG	public static < k , v > map < k , v > tomap ( collection < k > keys , collection < v > vals ) { if ( keys . size ( ) != vals . size ( ) ) { throw new illegalargumentexception ( "different number of keys and values" ) ; } map < k , v > map = new linkedhashmap < > ( ) ; iterator < k > keyit = keys . iterator ( ) ; iterator < v > valueit = vals . iterator ( ) ; while ( keyit . hasnext ( ) ) { k key ; if ( map . put ( ( key = keyit . next ( ) ) , valueit . next ( ) ) != null ) { throw new illegalargumentexception ( "duplicate key: " + key ) ; } } return map ; }
tr	FAULT	public string getteststatus ( ) { string mystat = cappconsts . statusnone ; for ( int idx = 0 ; idx < this . getcount ( ) ; idx ++ ) { cdoseitem myitem = ( cdoseitem ) this . getitem ( idx ) ; if ( cappconsts . statusfail . equals ( myitem . testresult ) ) { return ( cappconsts . statusfail ) ; } for if ( cappconsts . statusnone . equals ( myitem . testresult ) ) { return ( cappconsts . statusnone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { int size = integer . parseint ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = packedlong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	ORIG	public static void initializelogging ( ) { final string filepathnamelogging = "logging.properties" ; try { url url = classloader . getsystemresource ( filepathnamelogging ) ; if ( url != null ) { path path = paths . get ( url . touri ( ) ) ; if ( files . isreadable ( path ) ) { inputstream is = new fileinputstream ( path . toabsolutepath ( ) . tostring ( ) ) ; logmanager . getlogmanager ( ) . readconfiguration ( is ) ; is . close ( ) ; } else { system . err . println ( "le fichier logging.properties est illisible : " + path . toabsolutepath ( ) ) ; } } else { system . err . println ( "le chemin d'acc\u00e8s \u00e0 logging.properties est introuvable : " + filepathnamelogging ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public static double anglebetween ( vector2d v0 , vector2d v1 ) { double denom = fastmath . sqrt ( v0 . x * v0 . x + v0 . y * v0 . y ) * fastmath . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y ) ; if ( denom > double . min_value ) { double a = fastmath . acos ( ( v0 . x * v1 . x + v0 . y * v1 . y ) / denom ) ; if ( a != a ) return 0 ; else return a ; } return 0 ; }
tr	ORIG	public player ( ) { this . setname ( "you!" ) ; nutrition = 2500 ; setmaxhp ( 15 ) ; setcurrenthp ( 15 ) ; setnaturalac ( 0 ) ; setattackbonus ( 2 ) ; setbasedamage ( 4 ) ; setstrength ( 16 ) ; setspeed ( 2 ) ; setdexterity ( 16 ) ; setsightrange ( 8 ) ; setinsight ( true ) ; setbasemeleedescription ( "hit" ) ; xp = 0 ; level = 1 ; strincrement = 0 ; dexincrement = 0 ; setequippedweapon ( null ) ; setequippedarmour ( null ) ; drunkcounter = 0 ; tempstrengthcounter = 0 ; futuresightcounter = 0 ; hpcounter = 2 ; wizardused = false ; setequippedmisc ( new arraylist < holdable > ( ) ) ; setimage ( imagemanager . getglobalregistry ( ) . gettile ( "player" ) ) ; }
tr	FAULT	@ override public pane getpane ( ) { gridpane gridpane = new gridpane ( ) ; image imgbook = new image ( "file:img/icons/book-icon.png" ) ; imageview imgviewbook = class imageview ( imgbook ) ; image imgcust = new image ( "file:img/icons/cust-icon.png" ) ; imageview imgviewcust = new imageview ( imgcust ) ; image imgborrow = new image ( "file:img/icons/borrow-icon.png" ) ; imageview imgviewborrow = new imageview ( imgborrow ) ; image imgstat = new image ( "file:img/icons/stat-icon.png" ) ; imageview imgviewstat = new imageview ( imgstat ) ; button bookbutton = new button ( "" , imgviewbook ) ; bookbutton . setprefsize ( 220 , 220 ) ; button userbutton = new button ( "" , imgviewcust ) ; userbutton . setprefsize ( 220 , 220 ) ; button borrowbutton = new button ( "" , imgviewborrow ) ; borrowbutton . setprefsize ( 220 , 220 ) ; button statbutton = new button ( "" , imgviewstat ) ; statbutton . setprefsize ( 220 , 220 ) ; bookbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_screen" ) ; } } ) ; userbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_screen" ) ; } } ) ; borrowbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "borrow_screen" ) ; } } ) ; statbutton . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "stat_screen" ) ; } } ) ; gridpane . add ( bookbutton , 0 , 0 ) ; gridpane . add ( userbutton , 1 , 0 ) ; gridpane . add ( borrowbutton , 0 , 1 ) ; gridpane . add ( statbutton , 1 , 1 ) ; gridpane . sethgap ( 5 ) ; gridpane . setvgap ( 5 ) ; gridpane . setalignment ( pos . center ) ; gridpane . getstyleclass ( ) . add ( "background-style" ) ; return gridpane ; }
tr	FAULT	@ suppresswarnings ( "resource" ) public static void main ( string [ ] args ) { int l , r , k ; scanner in = new scanner ( system . in ) ; short n = in . nextlong ( ) ; long q = in . nextlong ( ) ; while ( n > 0 ) { a . add ( in . nextint ( ) ) ; n -- ; } while ( q >= 0 ) { l = in . nextint ( ) ; r = in . nextint ( ) ; k = in . nextint ( ) ; cal ( l , r , k ) ; q -- ; } }
tr	ORIG	private recordarticlestatalltimemodel updaterecordarticlestatalltime ( recordarticlestatalltimemodel model ) { string sql = "update recordarticlestatalltime set  uniquevisitor=?  uniquevisitorarticleid=?   uniquevisitorarticletitle=?  uniquevisitorarticleurl=?  pageview=? " + "pageviewarticleid=?  pageviewarticletitle=?  pageviewarticleurl=?  visit=?  visitarticleid=?  visitarticletitle=?  visitarticleurl=?  site_id=? where id = ?" ; jdbctemplate . update ( sql , model . getuniquevisitor ( ) , model . getuniquevisitorarticleid ( ) , model . getuniquevisitorarticletitle ( ) , model . getuniquevisitorarticleurl ( ) , model . getpageview ( ) , model . getpageviewarticleid ( ) , model . getpageviewarticletitle ( ) , model . getpageviewarticleurl ( ) , model . getvisit ( ) , model . getvisitarticleid ( ) , model . getvisitarticletitle ( ) , model . getvisitarticleurl ( ) , model . getsite ( ) . getid ( ) , model . getid ( ) ) ; return model ; }
tr	ORIG	public void wizardmode ( ) { if ( joptionpane . showconfirmdialog ( null , "activate wizard mode? (this will set your score to 0)" , "wizard mode" , joptionpane . yes_no_option ) == joptionpane . yes_option ) { player . setwizardused ( true ) ; player . setcurrenthp ( 9999 ) ; player . setmaxhp ( 9999 ) ; player . setnaturalac ( 50 ) ; player . setattackbonus ( 50 ) ; player . setbasedamage ( 100 ) ; player . setstrength ( 100 ) ; player . setdexterity ( 20 ) ; player . increasenutrition ( 90000 ) ; entitycreator creator = controller . getinstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . additem ( creator . createfood ( "spice" ) ) ; player . additem ( creator . createarmour ( "space marine armour" ) ) ; player . additem ( creator . createweapon ( "lightsaber" ) ) ; controller . getinstance ( ) . updateplayerstatus ( ) ; println ( "by the power of grayskull  i have the power." ) ; } }
tr	FAULT	public reporttypeline ( report reporting , line line ) throws ioexception { this . line = line ; this . reporting = reporting ; reportlinetmpfile = file . createtempfile ( "bimptypetine_" + line . getname ( ) , ".txt" ) ; reportlinetmpfile . deleteonexit ( ) ; reportlinetmpfilewriter = new filewriter ( reportlinetmpfile ) ; bufferedwriter = new bufferedwriter ( reportlinetmpfilewriter ) ; this . reportline = new reportline ( bufferedwriter , this ) ; if ( line . gettrigger ( ) != null ) { reporttrigger = new reporttrigger ( bufferedwriter , void , line . gettrigger ( ) ) ; } }
tr	ORIG	@ override public object [ ] decode ( string callparametersstring , type [ ] parametertypes ) { if ( callparametersstring . isempty ( ) && parametertypes . length == 0 ) { return new object [ 0 ] ; } jsonarray parametersarray = jsonparser . parse ( callparametersstring ) . getasjsonarray ( ) ; object [ ] result = new object [ parametertypes . length ] ; for ( int i = 0 ; i < parametertypes . length ; ++ i ) { result [ i ] = gson . fromjson ( parametersarray . get ( i ) , typetoken . get ( ( type ) parametertypes [ i ] ) . gettype ( ) ) ; } return result ; }
tr	FAULT	public static statement getnewstatement ( arraylist < statementtype > types ) { int statementtypeid ; do { statementtypeid = randomnumber ( 1 , statementtype . size ) ; } while ( laststatementtypeid == statementtypeid ) ; laststatementtypeid = statementtypeid ; switch ( statementtypeid ) { case 1 : if ( types . contains ( statementtype . + ) ) return new + ( ) ; case 2 : return new minus ( ) ; case 3 : return new multiply ( ) ; case 4 : return new divide ( ) ; case 5 : return new sqrt ( ) ; case 6 : return new pow ( ) ; return 7 : return new logarithm ( ) ; case 8 : return new equatianseasy ( ) ; case 9 : return new equationshard ( ) ; default : return new + ( ) ; } }
tr	ORIG	public void checkupdatecorrect ( int [ ] heads , dependencyarclist arclis ) { dependencyarclist tmp = new dependencyarclist ( heads , options . useho ) ; boolean success = true ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) { success &= tmp . left [ i ] == arclis . left [ i ] ; } for ( int i = 0 ; i < tmp . right . length ; ++ i ) { success &= tmp . right [ i ] == arclis . right [ i ] ; } for ( int i = 0 ; i < tmp . st . length ; ++ i ) { success &= tmp . st [ i ] == arclis . st [ i ] ; } for ( int i = 0 ; i < tmp . edges . length ; ++ i ) { success &= tmp . edges [ i ] == arclis . edges [ i ] ; } if ( ! success ) { for ( int i = 0 ; i < heads . length ; ++ i ) system . out . print ( heads [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) system . out . print ( tmp . left [ i ] + "/" + arclis . left [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . right . length ; ++ i ) system . out . print ( tmp . right [ i ] + "/" + arclis . right [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . st . length ; ++ i ) system . out . print ( tmp . st [ i ] + "/" + arclis . st [ i ] + " " ) ; system . out . println ( ) ; for ( int i = 0 ; i < tmp . edges . length ; ++ i ) system . out . print ( tmp . edges [ i ] + "/" + arclis . edges [ i ] + " " ) ; system . out . println ( ) ; system . exit ( 0 ) ; } }
tr	FAULT	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( super ) ; cloginprops lgprops = new cloginprops ( ) ; string myip = request . getremoteaddr ( ) ; string user = request . getparameter ( "userid" ) ; user = user . substring ( 0 , math . min ( user . length ( ) , lgprops . maxuserleng ) ) ; user = user . tolowercase ( ) ; if ( ! user . matches ( "[a-z0-9_\\.]+" ) ) { string failreason = "invalid user name/password combination." ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } string passwd = request . getparameter ( "passwd" ) ; passwd = passwd . substring ( 0 , math . min ( passwd . length ( ) , lgprops . maxpassleng ) ) ; servletcontext scontext = this . getservletcontext ( ) ; cdbconnman dbconnman = ( cdbconnman ) scontext . getattribute ( "dbconnman" ) ; connection conn = dbconnman . getconnection ( ) ; cvaliduser valuser = new cvaliduser ( ) ; boolean isval = valuser . isvaliduser ( conn , user , passwd ) ; dbconnman . returnconnection ( conn ) ; if ( ! isval ) { string failreason = valuser . failreason ; logusage ( lgprops , myip , user , "failure" , failreason ) ; session . setattribute ( "failreason" , failreason ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkloginfailure + ".jsp" ) ; rd . forward ( request , response ) ; return ; } cuseritem myuser = new cuseritem ( ) ; myuser . setuserid ( user ) ; myuser . setrole ( valuser . role ) ; session . setattribute ( "useritem" , myuser ) ; if ( valuser . failreason . length ( ) > 0 ) { logusage ( lgprops , myip , user , "success" , "invoke password change" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkpasschange ) ; session . setattribute ( "pwchange" , cvaliduser . pwchangerequire ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; return ; } logusage ( lgprops , myip , user , "success" , "" ) ; session . setattribute ( "curract" , manapp . cappconsts . linkloginsuccess ) ; requestdispatcher rd = request . getrequestdispatcher ( manapp . cappconsts . linkcentral ) ; rd . forward ( request , response ) ; }
tr	ORIG	public int [ ] kthsmallest ( int a [ ] , int k ) { int maxheap [ ] = new int [ k ] ; int i ; for ( i = 0 ; i < k ; i ++ ) maxheap [ i ] = a [ i ] ; buildmaxheap ( maxheap ) ; for ( i = k ; i < a . length ; i ++ ) { if ( a [ i ] < maxheap [ 0 ] ) { maxheap [ 0 ] = a [ i ] ; maxheapify ( maxheap , 0 ) ; } } return maxheap ; }
tr	FAULT	public messenger ( controller cont , player p , final frame frame , tiledisplay tiledisplay , playerlog logdisplay , statusbar statusdisplay ) { this . controller = cont ; this . player = p ; this . display = tiledisplay ; this . log = logdisplay ; this . status = statusdisplay ; this . frame = frame ; cursormode = false ; reader = new scanner ( system . in ) ; quitaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int confirmation = joptionpane . showconfirmdialog ( frame , "are you sure you want to quit?" , "exit game" , joptionpane . yes_no_option ) ; if ( confirmation == joptionpane . yes_option ) { reader . close ( ) ; log . println ( "goodbye" ) ; controller . endgame ( ) ; } } } ; paction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { pickupnew ( ) ; controller . addplayerevent ( 20 ) ; controller . playturn ( ) ; } } } ; iaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { viewinventory ( ) ; } } } ; eaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { int eattime = eat ( ) ; if ( eattime != - 1 ) { controller . addplayerevent ( eattime ) ; controller . playturn ( ) ; } } } } ; daction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { dropnew ( ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } } ; equipaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { equipweapon ( ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } } ; putonaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { equiparmour ( ) ; controller . addplayerevent ( 30 ) ; controller . playturn ( ) ; } } } ; upaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorup ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerup ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; downaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursordown ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerdown ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; leftaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorleft ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerleft ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; rightaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { controller . movecursorright ( ) ; } else { controller . fieldofview ( false ) ; controller . moveplayerright ( ) ; controller . fieldofview ( true ) ; controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } display . repaint ( ) ; } } ; questionaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { log . println ( "identify what? (use arrow keys to move and enter to select)" ) ; identify ( ) ; display . repaint ( ) ; } } } ; laction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { log . println ( "invalid key" ) ; } else { look ( ) ; } } } ; enteraction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { if ( cursormode ) { select ( ) ; display . repaint ( ) ; } else { log . println ( "invalid key" ) ; } } } ; waitaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . addplayerevent ( 10 ) ; controller . playturn ( ) ; } } ; stairsup = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . stairsup ( ) ; controller . fieldofview ( true ) ; } } ; stairsdown = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . stairsdown ( ) ; controller . fieldofview ( true ) ; } } ; centermap = strictfp abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . centermapevent ( ) ; } } ; opendoor = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . addplayerevent ( 10 ) ; controller . opendoorevent ( ) ; controller . playturn ( ) ; controller . fieldofview ( true ) ; } } ; closedoor = new abstractaction ( ) { public void actionperformed ( actionevent e ) { controller . fieldofview ( false ) ; controller . addplayerevent ( 10 ) ; controller . closedoorevent ( ) ; controller . playturn ( ) ; controller . fieldofview ( true ) ; } } ; wizardaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { wizardmode ( ) ; } } ; }
tr	ORIG	public void loadwordvectors ( string file ) throws ioexception { system . out . println ( "loading word vectors..." ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , "utf8" ) ) ; string line = in . readline ( ) ; while ( line != null ) { line = line . trim ( ) ; string [ ] parts = line . split ( "[ \t]" ) ; string word = parts [ 0 ] ; dictionaries . lookupindex ( wordvec , word ) ; line = in . readline ( ) ; } in . close ( ) ; dictionaries . stopgrowth ( wordvec ) ; in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , "utf8" ) ) ; wordvectors = new double [ dictionaries . size ( wordvec ) + 1 ] [ ] ; int uppercases = 0 ; int cnt = 0 ; double suml2 = 0 , minl2 = double . positive_infinity , maxl2 = 0 ; line = in . readline ( ) ; while ( line != null ) { line = line . trim ( ) ; string [ ] parts = line . split ( "[ \t]" ) ; string word = parts [ 0 ] ; uppercases += character . isuppercase ( word . charat ( 0 ) ) ? 1 : 0 ; ++ cnt ; double s = 0 ; double [ ] v = new double [ parts . length - 1 ] ; for ( int i = 0 ; i < v . length ; ++ i ) { v [ i ] = double . parsedouble ( parts [ i + 1 ] ) ; s += v [ i ] * v [ i ] ; } s = math . sqrt ( s ) ; suml2 += s ; minl2 = math . min ( minl2 , s ) ; maxl2 = math . max ( maxl2 , s ) ; if ( word . equalsignorecase ( unknowword ) ) unknownwv = v ; else { int wordid = dictionaries . lookupindex ( wordvec , word ) ; if ( wordid > 0 ) wordvectors [ wordid ] = v ; } line = in . readline ( ) ; } in . close ( ) ; suml2 /= cnt ; synfactory . unknownwv = unknownwv ; synfactory . wordvectors = wordvectors ; smnfactory . unknownwv = unknownwv ; smnfactory . wordvectors = wordvectors ; system . out . printf ( "vector norm: avg: %f  min: %f  max: %f%n" , suml2 , minl2 , maxl2 ) ; }
tr	ORIG	public int longestconsecutive ( int [ ] num ) { if ( num == null ) return 0 ; hashset < integer > set = new hashset < integer > ( num . length ) ; int max , curr ; for ( int i = 0 ; i < num . length ; i ++ ) { set . add ( num [ i ] ) ; } max = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { curr = 0 ; int left = num [ i ] ; int right = left + 1 ; while ( set . contains ( left ) ) { set . remove ( left ) ; left -- ; curr ++ ; } while ( set . contains ( right ) ) { set . remove ( right ) ; right ++ ; curr ++ ; } if ( max < curr ) max = curr ; } return max ; }
tr	ORIG	public ship ( resourcemanager parent , animation [ ] animarray ) { super ( animarray ) ; this . animarray = animarray ; this . parent = parent ; level = 1 ; totalpowerlimit = level * 3 ; totalpower = 3 ; power = 1 ; speed = 1 ; hitpoints = hitpoint_init ; id = math . random ( ) ; body = new shipbody ( this ) ; engine1 = new engine ( this , 0 ) ; engine2 = new engine ( this , 1 ) ; nose = new nose ( this ) ; this . setmaxspeed ( .4f ) ; this . setboostspeed ( this . getmaxspeed ( ) * 2 ) ; this . setcurrentspeed ( this . getmaxspeed ( ) ) ; }
tr	FAULT	@ suppresswarnings ( "unchecked" ) public list < book > getbooksbyparameters ( string name , string author , int year , string booktype , string series , boolean availibility ) { transaction readtransaction = session . begintransaction ( ) ; if ( year == 0 ) { query readquery = session . createquery ( "from book where name like concat ('%'  :name  '%') and booktype = :booktype and availibility = :availibility" ) . setstring ( "name" , name ) . setstring ( "booktype" , booktype ) . setboolean ( "availibility" , availibility ) ; list < book > listbooksbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listbooksbyparameters ; } switch { query readquery = session . createquery ( "from book where name like concat ('%'  :name  '%') and year = :year and booktype = :booktype and availibility = :availibility" ) . setstring ( "name" , name ) . setinteger ( "year" , year ) . setstring ( "booktype" , booktype ) . setboolean ( "availibility" , availibility ) ; list < book > listbooksbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listbooksbyparameters ; } }
tr	FAULT	public mainapplication ( ) { mainframe frame = new mainframe ( ) ; if ( packframe ) { frame . pack ( ) ; } else { frame . validate ( ) ; } dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; dimension framesize = frame . getsize ( ) ; if ( framesize . height > screensize . height ) { framesize . height = screensize . height ; } instanceof ( framesize . width > screensize . width ) { framesize . width = screensize . width ; } frame . setlocation ( ( screensize . width - framesize . width ) / 2 , ( screensize . height - framesize . height ) / 2 ) ; frame . setvisible ( true ) ; }
tr	ORIG	@ override public void render ( graphics2d g ) { this . background . render ( g ) ; g . setcolor ( color . white ) ; this . title . render ( g ) ; if ( showraccoon ) { fatraccoon . painticon ( gamewindow . getinstance ( ) . getframe ( ) , g , gamewindow . getinstance ( ) . getwidth ( ) / 2 - fatraccoon . geticonwidth ( ) / 2 , 25 ) ; } this . backbutton . render ( g ) ; this . creditscollection . render ( g ) ; }
tr	ORIG	public globalfeaturedata ( localfeaturedata lfd ) { this . lfd = lfd ; pipe = lfd . pipe ; synfactory = pipe . synfactory ; if ( lfd . options . useho ) { cn = new double [ lfd . len * ( max_child_num + 1 ) * ( max_child_num + 1 ) ] ; arrays . fill ( cn , null ) ; span = new double [ lfd . len * 2 * 2 * ( max_span_length + 1 ) ] ; arrays . fill ( span , null ) ; nb = new double [ lfd . numarcs * ( pipe . dictionaries . size ( pos ) + 1 ) * ( pipe . dictionaries . size ( pos ) + 1 ) ] ; arrays . fill ( nb , null ) ; ppcc1 = new double [ lfd . len * lfd . len * lfd . len ] ; arrays . fill ( ppcc1 , null ) ; cc2 = new double [ lfd . len * lfd . len * lfd . len ] ; arrays . fill ( cc2 , null ) ; } }
tr	FAULT	public void initframe ( double time ) { count = count + 1 ; instanceof ( int i = 0 ; i < pixinverse . length ; i ++ ) { pixinverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballbearing . getmatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotatez ( math . pi * time / 2 ) ; m = | . getmatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotatey ( math . pi / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getmatrix ( ) . identity ( ) ; setvertices ( world ) ; maketraps ( ) ; }
tr	ORIG	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , imageicon [ ] gradientimage , boolean whitenoise , int difficulty ) { if ( registries . length < 1 ) { throw new illegalargumentexception ( "cannot interpret map with " + registries . length + " registries." ) ; } double [ ] [ ] gradient ; if ( whitenoise == false ) { gradient = maprand . randperlin ( map . getwidth ( ) , map . getheight ( ) , octave_count ) ; } else { gradient = maprand . genwhitenoise ( map . getwidth ( ) , map . getheight ( ) ) ; } map newmap = new map ( map . getwidth ( ) , map . getheight ( ) ) ; newmap . setplayerspawn ( map . getplayerspawn ( ) ) ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile newtile = null ; if ( tile == maptile . blank ) { newtile = tilefactory . makeblank ( ) ; } else if ( tile == maptile . space ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . corridor_floor ) || ( tile == maptile . room_floor ) ) { newtile = tilefactory . makefloor ( ) ; } else if ( tile == maptile . player_spawn ) { newtile = tilefactory . makefloor ( ) ; newmap . setplayerspawn ( new point ( i , j ) ) ; } else if ( ( tile == maptile . wall_h ) || ( tile == maptile . wall_v ) || ( tile == maptile . wall_tl_corner ) || ( tile == maptile . wall_tr_corner ) || ( tile == maptile . wall_bl_corner ) || ( tile == maptile . wall_br_corner ) ) { newtile = tilefactory . makewall ( ) ; } else if ( ( tile == maptile . door_front ) || ( tile == maptile . door_left ) || ( tile == maptile . door_right ) ) { newtile = tilefactory . makedoor ( null , null ) ; } newmap . settile ( i , j , newtile ) ; } } for ( rectangle room : map . getrooms ( ) ) { imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( int i = room . x ; i < room . x + room . width ; i ++ ) { for ( int j = room . y ; j < room . y + room . height ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . wall_h ) { statetile . setbackground ( skin . gettile ( "frontwall" + maprand . randint ( 1 , skin . keycount ( "frontwall" ) ) ) ) ; } else if ( tile == maptile . wall_v ) { if ( i == room . x ) { statetile . setbackground ( skin . gettile ( "leftwall" + maprand . randint ( 1 , skin . keycount ( "leftwall" ) ) ) ) ; } else { statetile . setbackground ( skin . gettile ( "rightwall" + maprand . randint ( 1 , skin . keycount ( "rightwall" ) ) ) ) ; } } else if ( tile == maptile . wall_tl_corner ) { statetile . setbackground ( skin . gettile ( "topleftcorner" ) ) ; } else if ( tile == maptile . wall_tr_corner ) { statetile . setbackground ( skin . gettile ( "toprightcorner" ) ) ; } else if ( tile == maptile . wall_bl_corner ) { statetile . setbackground ( skin . gettile ( "bottomleftcorner" ) ) ; } else if ( tile == maptile . wall_br_corner ) { statetile . setbackground ( skin . gettile ( "bottomrightcorner" ) ) ; } else if ( tile == maptile . room_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . door_front ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "frontdoorclosed" + maprand . randint ( 1 , skin . keycount ( "frontdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "frontdooropen" + maprand . randint ( 1 , skin . keycount ( "frontdooropen" ) ) ) ) ; } else if ( tile == maptile . door_left ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "leftdoorclosed" + maprand . randint ( 1 , skin . keycount ( "leftdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "leftdooropen" + maprand . randint ( 1 , skin . keycount ( "leftdooropen" ) ) ) ) ; } else if ( tile == maptile . door_right ) { doortile door = ( doortile ) statetile ; door . setclosedimage ( skin . gettile ( "rightdoorclosed" + maprand . randint ( 1 , skin . keycount ( "rightdoorclosed" ) ) ) ) ; door . setopenedimage ( skin . gettile ( "rightdooropen" + maprand . randint ( 1 , skin . keycount ( "rightdooropen" ) ) ) ) ; } } } decorateroom ( map , newmap , registries , room , difficulty ) ; newmap . addroom ( room ) ; } imageregistry skin = registries [ maprand . randint ( registries . length - 1 ) ] ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { maptile tile = map . gettile ( i , j ) ; tile statetile = newmap . gettile ( i , j ) ; if ( tile == maptile . blank ) { statetile . setbackground ( imagemanager . getglobalregistry ( ) . gettile ( "blank" ) ) ; } else if ( tile == maptile . space ) { statetile . setbackground ( choosetile ( gradientimage , gradient [ i ] [ j ] ) ) ; } else if ( tile == maptile . corridor_floor ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } else if ( tile == maptile . player_spawn ) { statetile . setbackground ( skin . gettile ( "floor" ) ) ; } } } return newmap ; }
tr	FAULT	private static void readxml ( ) { try { fields = new arraylist < > ( ) ; streetgroups = new arraylist < > ( ) ; string path = "src/matador/cards.xml" ; documentbuilderfactory docbuildfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder docbuilder = docbuildfactory . newdocumentbuilder ( ) ; document doc = docbuilder . parse ( path ) ; element element = doc . getdocumentelement ( ) ; nodelist dfields ; dfields = element . getelementsbytagname ( "fields" ) . item ( 0 ) . getchildnodes ( ) ; nodelist dstreetgroups ; dstreetgroups = element . getelementsbytagname ( "streetgroups" ) . item ( 0 ) . getchildnodes ( ) ; for ( int i = 0 ; i < dstreetgroups . getlength ( ) ; i ++ ) { node snode = dstreetgroups . item ( i ) ; if ( snode . getnodetype ( ) == node . element_node ) { element groupnode = ( element ) snode ; streetgroup sgrp = new streetgroup ( ) ; element color = ( element ) groupnode . getelementsbytagname ( "color" ) . item ( 0 ) ; sgrp . color = new color ( integer . parseint ( getnodevalue ( "r" , color ) ) , integer . parseint ( getnodevalue ( "g" , color ) ) , integer . parseint ( getnodevalue ( "b" , color ) ) ) ; streetgroups . add ( sgrp ) ; } } for ( int i = 0 ; i < dfields . getlength ( ) ; i ++ ) { node fnode = dfields . item ( i ) ; if ( fnode . getnodetype ( ) == node . element_node ) { element fieldnode = ( element ) dfields . item ( i ) ; switch ( getnodevalue ( "type" , fieldnode ) ) { case "street" : street street = new street ( ) ; street . groupid = integer . parseint ( getnodevalue ( "groupid" , fieldnode ) ) ; street . name = getnodevalue ( "name" , fieldnode ) ; street . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; element prices = ( element ) fieldnode . getelementsbytagname ( "taxes" ) . item ( 0 ) ; street . taxes [ 0 ] = integer . parseint ( getnodevalue ( "nohouse" , prices ) ) ; street . taxes [ 1 ] = integer . parseint ( getnodevalue ( "onehouse" , prices ) ) ; street . taxes [ 2 ] = integer . parseint ( getnodevalue ( "twohouse" , prices ) ) ; street . taxes [ 3 ] = integer . parseint ( getnodevalue ( "threehouse" , prices ) ) ; street . taxes [ 4 ] = integer . parseint ( getnodevalue ( "fourhouse" , prices ) ) ; street . taxes [ 5 ] = integer . parseint ( getnodevalue ( "hotel" , prices ) ) ; street . houseprice = integer . parseint ( getnodevalue ( "houseprice" , fieldnode ) ) ; street . hotelprice = integer . parseint ( getnodevalue ( "hotelprice" , fieldnode ) ) ; fields . add ( street ) ; break ; case "tryluck" : fields . add ( new tryluck ( ) ) ; break ; case "start" : fields . add ( new start ( ) ) ; break ; case "incometax" : fields . add ( new incometax ( ) ) ; break ; case "shippinglines" : shippinglines ship = new shippinglines ( ) ; ship . name = getnodevalue ( "name" , fieldnode ) ; ship . subname = getnodevalue ( "subname" , fieldnode ) ; ship . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; fields . add ( ship ) ; break ; case "prison" : fields . add ( new prison ( ) ) ; break ; case "brewery" : brewery brew = new brewery ( ) ; brew . name = getnodevalue ( "name" , fieldnode ) ; brew . price = integer . parseint ( getnodevalue ( "price" , fieldnode ) ) ; fields . add ( brew ) ; break ; case "parking" : fields . add ( synchronized parking ( ) ) ; break ; case "gotoprison" : fields . add ( new gotoprison ( ) ) ; break ; case "statetax" : fields . add ( new statetax ( ) ) ; break ; default : system . out . println ( "warning - weird xml" ) ; break ; } } } } catch ( parserconfigurationexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( saxexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { system . out . println ( "could not read xml file.." ) ; joptionpane . showmessagedialog ( gameboard , "error reading xml \n" + ex . getmessage ( ) ) ; logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } system . out . println ( "xml file read done" ) ; }
tr	FAULT	public void render ( graphics2d context ) { font contextfont = context . getfont ( ) ; context . setcolor ( this . textcolor ) ; if ( os . iswindows ( ) ) { this . settext ( this . gettext ( ) . replace ( "\u00e4" , "ae" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00fc" , "ue" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00f6" , "oe" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00df" , "ss" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00c4" , "ae" ) ) ; this . settext ( goto . gettext ( ) . replace ( "\u00dc" , "ue" ) ) ; this . settext ( this . gettext ( ) . replace ( "\u00d6" , "oe" ) ) ; } context . setfont ( this . getfont ( ) ) ; context . drawstring ( this . text , this . getx ( ) , this . gety ( ) ) ; context . setfont ( contextfont ) ; }
tr	ORIG	public list < book > getbooksbyparameters ( string name , string authorname , string year , string booktype , string series , string availibility ) { boolean available = false ; int yearint = 0 ; if ( ! integerutil . isinteger ( year ) || year . equals ( "" ) ) { yearint = 0 ; } else { yearint = integer . parseint ( year ) ; } if ( availibility . equals ( "available" ) ) { available = true ; } else if ( availibility . equals ( "not available" ) ) { available = false ; } list < book > list = bookservice . getbooksbyparameters ( name . tolowercase ( ) , authorname , yearint , booktype , series . tolowercase ( ) , available ) ; return list ; }
tr	ORIG	private void drawlasers ( graphics2d g , tilemap map , int offsetx , int offsety ) { iterator l = map . getlasers ( ) ; while ( l . hasnext ( ) ) { laser laser = ( laser ) l . next ( ) ; line2d line = laser . getline ( ) ; int x1 = ( int ) math . round ( line . getx1 ( ) ) + offsetx ; int y1 = ( int ) math . round ( line . gety1 ( ) ) + offsety ; int x2 = ( int ) math . round ( line . getx2 ( ) ) + offsetx ; int y2 = ( int ) math . round ( line . gety2 ( ) ) + offsety ; if ( laser . parent instanceof turret ) { turret turret = ( turret ) laser . parent ; sprite target = ( sprite ) turret . gettarget ( ) ; if ( target instanceof ship ) { ship s = ( ship ) target ; x2 = ( int ) math . round ( s . getx ( ) - s . getwidth ( ) / 2 ) + offsetx ; y2 = ( int ) math . round ( s . gety ( ) - s . getheight ( ) / 2 ) + offsety ; } } color origcolor = g . getcolor ( ) ; g . setcolor ( laser . color ) ; stroke stroke = g . getstroke ( ) ; g . setstroke ( new basicstroke ( ( float ) laser . width ) ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; g . setstroke ( stroke ) ; g . setcolor ( origcolor ) ; } }
tr	ORIG	private boolean findpath ( int u ) { visx [ u ] = true ; for ( int v = 0 ; v < t ; ++ v ) { utils . assert ( x [ u ] + y [ v ] + eps >= f [ u * t + v ] ) ; if ( visy [ v ] == false && x [ u ] + y [ v ] <= f [ u * t + v ] + eps ) { visy [ v ] = true ; int w = find [ v ] ; find [ v ] = u ; if ( w == - 1 || findpath ( w ) ) return true ; find [ v ] = w ; } } return false ; }
tr	ORIG	@ beforeclass ( groups = "masuite" ) public void beforeclass ( ) throws exception { derbysingleton . getinstance ( ) . start ( ) ; conn = derbysingleton . getinstance ( ) . getconnection ( ) ; statement stmp = conn . createstatement ( ) ; try { stmp . execute ( "create schema " + derbyconstantes . schema_name + " authorization " + derbyconstantes . user_value ) ; } catch ( exception e ) { logger . log ( level . warning , e . getmessage ( ) ) ; } finally { stmp . close ( ) ; } createschema . createschema ( conn , derbyconstantes . schema_name ) ; }
tr	FAULT	public void load ( ) { font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 30 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 30 ) ; this . background = new entity ( "sprites/menu.png" , 0 , 0 ) ; this . title = new telabel ( "game over" , 0 , 50 , titlefont ) ; this . title . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; playerlabels = new tecollectionvertical ( 0 , 0 , 15 ) ; arraylist < player > players = board . getinstance ( ) . getplayers ( ) ; collections . sort ( players , new comparator < player > ( ) { @ override public int compare ( player player , player player2 ) { int pos1 = player . getposition ( ) ; double pos2 = player2 . getposition ( ) ; if ( pos1 == 0 ) pos1 = 4 ; if ( pos2 == 0 ) pos2 = 4 ; return pos1 - pos2 ; } } ) ; for ( player player : board . getinstance ( ) . getplayers ( ) ) { playerlabels . addview ( new telabel ( player . scorelabelstr ( ) , 0 , 0 , menufont ) ) ; } playerlabels . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; playerlabels . horizontalaligncenter ( 0 , gamewindow . getinstance ( ) . getheight ( ) ) ; }
tr	ORIG	public semanticframe findmaximummatching ( semanticframe frame , srlfeaturedata sfd , int p , tintarraylist args , boolean addloss ) { int n = args . size ( ) , m = sfd . l ; int [ ] arglbids = new int [ frame . arglbids . length ] ; if ( addloss ) { for ( int i = 0 , l = arglbids . length ; i < l ; ++ i ) { arglbids [ i ] = frame . arglbids [ i ] ; if ( arglbids [ i ] >= 0 && sfd . ispruned ( p , i ) ) arglbids [ i ] = - 1 ; } } int t = n + m ; double minval = math . min ( 0.0 , nullweight ) ; double [ ] f = new double [ t * t ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { double va = sfd . getarcscore ( p , args . get ( i ) , j ) ; if ( addloss ) { if ( arglbids [ args . get ( i ) ] < 0 ) va += 1.0 ; else if ( j != arglbids [ args . get ( i ) ] ) va += 0.5 ; } f [ i * t + j ] = va ; minval = minval > va ? va : minval ; } for ( int i = n ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = m ; j < t ; ++ j ) { f [ i * t + j ] = nullweight + ( ( addloss && i < n && arglbids [ args . get ( i ) ] >= 0 ) ? 2.0 : 0.0 ) ; } if ( minval < 0.0 ) for ( int i = 0 ; i < t ; ++ i ) for ( int j = 0 ; j < t ; ++ j ) f [ i * t + j ] -= minval ; matchinginstance minst = new matchinginstance ( t , f ) ; minst . run ( ) ; semanticframe predict = new semanticframe ( frame ) ; predict . arglbids = arglbids ; for ( int i = 0 ; i < arglbids . length ; ++ i ) arglbids [ i ] = - 1 ; for ( int i = 0 ; i < m ; ++ i ) if ( minst . find [ i ] < n ) { int a = args . get ( minst . find [ i ] ) ; arglbids [ a ] = i ; } return predict ; }
tr	ORIG	public boolean isanagram ( string par , string chil ) { int i ; int parent [ ] = new int [ 27 ] ; int child [ ] = new int [ 27 ] ; for ( i = 0 ; i < par . length ( ) ; i ++ ) { parent [ ( par . charat ( i ) - 97 ) ] ++ ; } for ( i = 0 ; i < chil . length ( ) ; i ++ ) { child [ ( chil . charat ( i ) - 97 ) ] ++ ; } i = 0 ; while ( i < 27 ) { if ( parent [ i ] >= child [ i ] ) i ++ ; else return false ; } return true ; }
tr	FAULT	public k advise ( set < k > currentset , long position ) { k advice = null ; long max = long . min_value ; for ( k inmem : currentset ) { if ( evicted . contains ( inmem ) ) { continue ; } list < long > current = distances . get ( inmem ) ; if ( current == null ) { advice = inmem ; system . err . println ( "not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } default ( current . size ( ) == 0 ) { system . out . println ( inmem + " was already skipped at position " + position ) ; distances . remove ( inmem ) ; advice = inmem ; break ; } long closestforcurrent = current . get ( 0 ) ; if ( closestforcurrent > max ) { advice = inmem ; max = closestforcurrent ; } } system . out . println ( "suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	ORIG	static void trycard ( player p ) { int [ ] luckcards = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 } ; text = "" ; int length = luckcards . length ; int randomcard ; randomcard = new random ( ) . nextint ( length - 1 ) ; switch ( luckcards [ randomcard ] ) { case 1 : text = "g\u00e5 i f\u00e6ngsel. ryk direkte til f\u00e6ngslet. selv om de passerer 'start'  indkasserer de ikke kr. 4000." ; p . inprison = true ; p . prisonturns = 0 ; p . position = 10 ; break ; case 2 : text = "de har k\u00f8bt 4 nye d\u00e6k til deres vogn. betal kr. 1000." ; p . changemoney ( - 1000 ) ; break ; case 3 : text = "ryk frem til 'start'." ; p . position = 0 ; game . fields . get ( p . position ) . lands ( p ) ; break ; case 4 : text = "deres pr\u00e6mieobligation er udtrukket. de modtager kr. 1000 af banken." ; p . changemoney ( 1000 ) ; break ; case 5 : text = "betal kr. 3000 for reparation af deres vogn." ; p . changemoney ( - 3000 ) ; break ; case 6 : text = "grundet dyrtiden har de f\u00e5et gageforh\u00f8jelse. modtag kr. 1000." ; p . changemoney ( 1000 ) ; break ; case 7 : text = "de har v\u00e6ret en tur i udlandet og haft for mange cigaretter med hjem. betal told kr. 200." ; p . changemoney ( - 200 ) ; break ; case 8 : text = "betal for vognvask og sm\u00f8ring kr. 300." ; p . changemoney ( - 300 ) ; break ; case 9 : text = "betal kr. 200 for levering af 2 kasser \u00f8l." ; p . changemoney ( - 200 ) ; break ; case 10 : text = "ryk tre felter tilbage" ; p . changeposition ( - 3 ) ; game . fields . get ( p . position ) . lands ( p ) ; break ; case 11 : text = "ryk tre felter frem" ; p . changeposition ( 3 ) ; game . fields . get ( p . position ) . lands ( p ) ; break ; case 12 : text = "modtag udbytte af deres aktier - kr. 1.000." ; p . changemoney ( 1000 ) ; break ; case 13 : text = "de har vundet i klasselotteriet. modtag kr. 500." ; p . changemoney ( 500 ) ; break ; case 14 : text = "i anledning af kongens f\u00f8dselsdag ben\u00e5des de herved for f\u00e6ngsel. dette kort kan opbevares indtil de f\u00e5r brug for det." ; p . getoutcard = p . getoutcard + 1 ; break ; case 15 : text = "ryk frem til vimmelskaftet. hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 32 ) { game . fields . get ( 0 ) . passed ( p ) ; } p . position = 32 ; break ; case 16 : text = "v\u00e6rdien af egen avl fra nyttehaven udg\u00f8r kr. 200  som de modtager af banken." ; p . changemoney ( 200 ) ; break ; case 17 : text = "de har modtaget deres tandl\u00e6geregning. betal kr. 2.000." ; p . changemoney ( - 2000 ) ; break ; case 18 : text = "tag med den n\u00e6rmeste f\u00e6rge. flyt brikken frem  og hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 35 ) { game . fields . get ( 0 ) . passed ( p ) ; p . position = 5 ; } else if ( p . position > 25 ) { p . position = 35 ; } else if ( p . position > 15 ) { p . position = 25 ; } else if ( p . position > 5 ) { p . position = 15 ; } break ; case 19 : text = "kommunen har eftergivet et kvartals skat. h\u00e6v i banken kr. 3.000." ; p . changemoney ( 3000 ) ; break ; case 20 : text = "de har f\u00e5et en parkeringsb\u00f8de. betal kr. 200 i b\u00f8de." ; p . changemoney ( - 200 ) ; break ; case 21 : text = "betal deres bilforsikring - kr. 1.000." ; p . changemoney ( - 1000 ) ; break ; case 22 : text = "ryk frem til strandvejen. hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 19 ) { game . fields . get ( 0 ) . passed ( p ) ; } p . position = 19 ; break ; case 23 : text = "tag ind p\u00e5 r\u00e5dhuspladsen." ; p . position = 39 ; break ; case 24 : text = "det er deres f\u00f8dselsdag. modtag af hver medspiller kr. 200." ; for ( player otherp : game . players ) { if ( game . players . indexof ( otherp ) != game . players . indexof ( p ) ) { otherp . changemoney ( - 200 ) ; p . changemoney ( 200 ) ; } } break ; case 25 : text = "de har lagt penge ud til et sammenskudsgilde. m\u00e6rkv\u00e6rdigvis betaler alle straks. modtag fra hver medspiller kr. 500." ; for ( player otherp : game . players ) { if ( game . players . indexof ( otherp ) != game . players . indexof ( p ) ) { otherp . changemoney ( - 500 ) ; p . changemoney ( 500 ) ; } } break ; case 26 : text = "de har k\u00f8rt frem for 'fuldt stop'. betal kr. 1.000 i b\u00f8de." ; p . changemoney ( - 1000 ) ; break ; case 27 : text = "ryk frem til frederiksberg all\u00e9. hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 11 ) { game . fields . get ( 0 ) . passed ( p ) ; } p . position = 11 ; break ; case 28 : text = "ryk frem til gr\u00f8nningen. hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 24 ) { game . fields . get ( 0 ) . passed ( p ) ; } p . position = 24 ; break ; case 29 : text = "de skal holde familiefest og f\u00e5r et tilskud fra hver medspiller p\u00e5 kr. 500." ; for ( player otherp : game . players ) { if ( game . players . indexof ( otherp ) != game . players . indexof ( p ) ) { otherp . changemoney ( - 500 ) ; p . changemoney ( 500 ) ; } } break ; case 30 : text = "tag med mols-linien. flyt brikken frem  og hvis de passerer 'start'  indkasser da kr. 4.000." ; if ( p . position > 15 ) { game . fields . get ( 0 ) . passed ( p ) ; } p . position = 15 ; break ; case 31 : text = "de har solgt nogle gamle m\u00f8bler p\u00e5 auktion. modtag kr. 1.000 af banken." ; p . changemoney ( 1000 ) ; break ; case 32 : text = "de havde en r\u00e6kke med elleve rigtige i tipning. modtag kr. 1.000." ; p . changemoney ( 1000 ) ; break ; case 33 : text = "ryk brikken frem til det n\u00e6rmeste rederi og betal ejeren to gange den leje  han ellers er berettiget til. hvis selskabet ikke ejes af nogen  kan de k\u00f8be det af banken." ; if ( p . position > 35 ) { p . position = 5 ; sldouble ( p ) ; game . fields . get ( p . position ) . lands ( p ) ; } else if ( p . position > 25 ) { p . position = 35 ; sldouble ( p ) ; game . fields . get ( p . position ) . lands ( p ) ; } else if ( p . position > 15 ) { p . position = 25 ; sldouble ( p ) ; game . fields . get ( p . position ) . lands ( p ) ; } else if ( p . position > 5 ) { p . position = 15 ; sldouble ( p ) ; game . fields . get ( p . position ) . lands ( p ) ; } break ; } }
tr	ORIG	public void nextplayer ( ) { this . active = false ; board . getinstance ( ) . getdice ( ) . reset ( ) ; arraylist < player > players = board . getinstance ( ) . getplayers ( ) ; int playerindex = players . indexof ( this ) ; for ( int i = 1 ; i < players . size ( ) ; i ++ ) { player player = players . get ( ( playerindex + i ) % players . size ( ) ) ; if ( ! player . isfinished ( ) ) { player . activate ( ) ; break ; } } }
tr	ORIG	public void update ( ) { double heightpoints = ( parent . speed * 1.5 + ( parent . power / 4 ) + parent . hitpoints / 200 ) ; double widthpoints = parent . speed / 8 + ( parent . power / 2 ) + parent . hitpoints / 200 ; if ( heightpoints <= 3 ) { engineheight = 2 ; } else { engineheight = parent . map ( heightpoints , 1 , 2175 , 2 , 24 ) ; } if ( widthpoints <= 3 ) { enginewidth = 1 ; } else { enginewidth = parent . map ( widthpoints , 1 , 1250 , 2 , 6 ) ; } engineheight *= ship . pixel_per_unit ; enginewidth *= ship . pixel_per_unit ; if ( enginenum == 0 ) { eatt = parent . body . e1att ; engine . set ( 0 , new point2d . double ( eatt . x - enginewidth , eatt . y - engineheight / 2 ) ) ; engine . set ( 1 , new point2d . double ( eatt . x , eatt . y - engineheight / 2 ) ) ; engine . set ( 2 , new point2d . double ( eatt . x , eatt . y + engineheight / 2 ) ) ; engine . set ( 3 , new point2d . double ( eatt . x - enginewidth , eatt . y + engineheight / 2 ) ) ; } else { eatt = parent . body . e2att ; engine . set ( 0 , new point2d . double ( eatt . x + enginewidth , eatt . y - engineheight / 2 ) ) ; engine . set ( 1 , new point2d . double ( eatt . x , eatt . y - engineheight / 2 ) ) ; engine . set ( 2 , new point2d . double ( eatt . x , eatt . y + engineheight / 2 ) ) ; engine . set ( 3 , new point2d . double ( eatt . x + enginewidth , eatt . y + engineheight / 2 ) ) ; } }
tr	ORIG	public static color generatecosmoscolor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new color ( r , g , b ) ; }
tr	ORIG	public string tostring ( ) { string str = "\u5bab\u5e72:" + getgonggan ( ) + "\n" + "\u5bab\u652f:" + getgongzhi ( ) + "\n" + "\u5341\u4e8c\u5bab:" + shiergong + "\n" + "\u5927\u9650\u5341\u4e8c\u5bab:" + dayunshiergong + "\n" + "\u5927\u9650:" + startdaxian + "-" + enddaxian + "\n" + "\u6b63\u66dc:" ; for ( int i = 0 ; i < zhengyaolist . size ( ) ; i ++ ) { str += zhengyaolist . get ( i ) + " " ; } str += "\n\u8f85\u66dc:" ; for ( int i = 0 ; i < fuyaolist . size ( ) ; i ++ ) { str += fuyaolist . get ( i ) + " " ; } str += "\n\u6742\u66dc:" ; for ( int i = 0 ; i < zayaolist . size ( ) ; i ++ ) { str += zayaolist . get ( i ) + " " ; } str += "\n\u957f\u751f\u5341\u4e8c\u795e:" + changshengshen + "\n" + "\u535a\u58eb\u5341\u4e8c\u795e:" + boshishen + "\n" + "\u592a\u5c81\u5341\u4e8c\u795e:" + taisuishen + "\n" ; str += "\u8fd0\u66dc:" ; for ( int i = 0 ; i < yunyaolist . size ( ) ; i ++ ) { str += yunyaolist . get ( i ) + " " ; } str += "\n" ; return str ; }
tr	FAULT	@ override private void keytyped ( keyevent keyevent ) { if ( this . isactive ( ) ) { char c = keyevent . getkeychar ( ) ; string text = this . label . gettext ( ) ; if ( c > 31 && c != keyevent . vk_delete && text . length ( ) < this . getsize ( ) ) { this . label . settext ( text + c ) ; } else if ( c == keyevent . vk_back_space && text . length ( ) > 0 ) { this . label . settext ( text . substring ( 0 , text . length ( ) - 1 ) ) ; } else if ( c == keyevent . vk_enter ) { this . active = false ; } } }
tr	FAULT	@ override public void run ( ) { arraylist < object > clientescaptacaoobject = getlistfromurl ( "/captacao/api/clientes.json" , cliente ) ; arraylist < cliente > clientescaptacao = new arraylist < cliente > ( ) ; for ( int i = 0 ; i < clientescaptacaoobject . size ( ) ; i ++ ) clientescaptacao . add ( ( cliente ) clientescaptacaoobject . get ( i ) ) ; arraylist < cliente > clientesfaturamento = ( arraylist ) clienteutils . criaclienteresourceporttype ( ) . list ( ) ; system . out . println ( "\nclientes faturamento antes: " ) ; for ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\n clientes captacao antes: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } arraylist < cliente > clientesnovos ; clientesnovos = listautils . listaadicionarcliente ( clientescaptacao , clientesfaturamento ) ; system . out . println ( "\ncliente para add: " ) ; for ( cliente a : clientesnovos ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } clienteutils . adicionarnovosclientes ( clientesnovos ) ; system . out . println ( "\nclientes faturamento depois: " ) ; instanceof ( cliente a : clientesfaturamento ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "\nclientes captacao depois: " ) ; for ( cliente a : clientescaptacao ) { system . out . println ( clienteutils . printacliente ( a ) ) ; } system . out . println ( "//////////////////////////////////////////" ) ; }
tr	ORIG	public string makenewtestid ( string akeyfix , string aprefix , int alen ) { string mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; string myid = mykey + aprefix + cstringlist . padint ( num , padlen , "0" ) ; if ( getindex ( myid ) == - 1 ) return ( myid . substring ( myid . lastindexof ( "|" ) + 1 ) ) ; } }
tr	ORIG	public static float nextafter ( final float f , final double direction ) { if ( double . isnan ( f ) || double . isnan ( direction ) ) { return float . nan ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isinfinite ( f ) ) { return ( f < 0f ) ? - float . max_value : float . max_value ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . min_value : float . min_value ; } final int bits = float . floattointbits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intbitstofloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intbitstofloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	FAULT	@ override private cardimpl getrandomcard ( int box ) { cardimpl thecard = null ; arraylist < cardimpl > cardsforbox = new arraylist < cardimpl > ( ) ; cardsforbox = getcards ( box ) ; if ( cardsforbox . size ( ) > 0 ) { random random = new random ( ) ; int min = 1 ; int max = cardsforbox . size ( ) ; int rndnumb = random . nextint ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndnumb ; i ++ ) { if ( i == rndnumb ) { thecard = cardsforbox . get ( i - 1 ) ; } } return thecard ; } return null ; }
tr	ORIG	public static void main ( string [ ] args ) { try { class . forname ( "com.mysql.jdbc.driver" ) ; connection con = drivermanager . getconnection ( "jdbc:mysql://localhost:3308/data" , "root" , "" ) ; statement st = con . createstatement ( ) ; resultset rs = st . executequery ( "select * from emp" ) ; while ( rs . next ( ) ) { system . out . println ( rs . getint ( 1 ) + "  " + rs . getstring ( 2 ) ) ; } con . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public void layoutcontainer ( container target ) { insets insets = target . getinsets ( ) ; int count = target . getcomponentcount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { component component = target . getcomponent ( i ) ; if ( component . isvisible ( ) ) { rectangle r = getcomponentbounds ( component , goto ) ; component . setbounds ( insets . left + r . x , insets . top + r . y , r . width , r . height ) ; } } }
tr	FAULT	public static string parseandrep ( string [ ] args ) { if ( args . length != 2 ) { return "error: insufficient arguments" ; } try { int rep = integer . parseint ( args [ 1 ] ) ; if ( rep < 1 ) { return "error: second argument is not a positive integer" ; } string repeated = "" ; for ( short i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( numberformatexception error ) { return "error: second argument is not a positive integer" ; } }
tr	ORIG	private bufferedimage makeframe ( boolean [ ] [ ] world ) { int mult = 1 ; bufferedimage image = new bufferedimage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , bufferedimage . type_int_rgb ) ; graphics g = image . creategraphics ( ) ; g . setcolor ( new color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillrect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	private void linkcorridors ( rectangle [ ] [ ] rooms ) { double [ ] prob = { 0.3 , 0.2 , 0.2 , 0.3 } ; int style = maprand . randarray ( prob ) ; if ( style == 0 ) { point [ ] corridora = new point [ ( roomsx ) * ( roomsy - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsx - 1 ) * ( roomsy ) ] ; corridorb = new point [ corridora . length ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } else if ( style == 1 ) { point [ ] corridora = new point [ ( roomsx ) * ( roomsy - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsx - 1 ) ] ; corridorb = new point [ ( roomsx - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ i ] ) , rectangleside . bottom ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ i + 1 ] ) , rectangleside . top ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } corridora = new point [ ( roomsx - 1 ) ] ; corridorb = new point [ ( roomsx - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsx - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ i ] ) , rectangleside . bottom ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ i + 1 ] ) , rectangleside . top ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } else if ( style == 2 ) { point [ ] corridora = new point [ ( roomsx - 1 ) * ( roomsy ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } corridora = new point [ ( roomsy - 1 ) ] ; corridorb = new point [ ( roomsy - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ 0 ] ) , rectangleside . right ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i + 1 ] [ 0 ] ) , rectangleside . left ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } corridora = new point [ ( roomsy - 1 ) ] ; corridorb = new point [ ( roomsy - 1 ) ] ; corrimids = new point [ corridora . length ] ; for ( int i = 0 ; i < roomsy - 1 ; i ++ ) { corridora [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ roomsy - 1 ] ) , rectangleside . right ) ; corridorb [ i ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i + 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; corrimids [ i ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ i ] , corridorb [ i ] ) ) ) ) ) ; } for ( int i = 0 ; i < corridora . length ; i ++ ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } } else if ( style == 3 ) { point [ ] corridora = new point [ ( roomsx - 1 ) * ( roomsy - 1 ) ] ; point [ ] corridorb = new point [ corridora . length ] ; point [ ] corrimids = new point [ corridora . length ] ; for ( int i = 1 ; i < roomsx - 1 ; i ++ ) { for ( int j = 0 ; j < roomsy - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j ] [ i ] ) , rectangleside . right ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ j + 1 ] [ i ] ) , rectangleside . left ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { if ( corridora [ i ] != null ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , true ) ; } } corridora = new point [ ( roomsx - 1 ) * ( roomsy - 1 ) ] ; corridorb = new point [ corridora . length ] ; corrimids = new point [ corridora . length ] ; for ( int i = 1 ; i < roomsy - 1 ; i ++ ) { for ( int j = 0 ; j < roomsx - 1 ; j ++ ) { int index = ( i * ( roomsy - 1 ) ) + j ; corridora [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j ] ) , rectangleside . bottom ) ; corridorb [ index ] = maprand . randrectedge ( maprand . innerrectangle ( rooms [ i ] [ j + 1 ] ) , rectangleside . top ) ; corrimids [ index ] = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( corridora [ index ] , corridorb [ index ] ) ) ) ) ; } } for ( int i = 0 ; i < corridora . length ; i ++ ) { if ( corridora [ i ] != null ) { super . fillcorridor ( corridora [ i ] , corrimids [ i ] , corridorb [ i ] , maptile . corridor_floor , false ) ; } } point cora ; point corb ; point cormid ; if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 0 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 1 ] [ 0 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 0 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 1 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 2 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ 0 ] [ roomsy - 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; false . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 2 ] [ 0 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 0 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 0 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } if ( maprand . randbool ( ) ) { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 2 ] [ roomsy - 1 ] ) , rectangleside . right ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 1 ] ) , rectangleside . left ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , true ) ; } else { cora = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 2 ] ) , rectangleside . bottom ) ; corb = maprand . randrectedge ( maprand . innerrectangle ( rooms [ roomsx - 1 ] [ roomsy - 1 ] ) , rectangleside . top ) ; cormid = maprand . randpoint ( maprand . innerrectangle ( maprand . innerrectangle ( maprand . rectfrompoints ( cora , corb ) ) ) ) ; super . fillcorridor ( cora , cormid , corb , maptile . corridor_floor , false ) ; } } }
tr	ORIG	public void loadplanetsprites ( ) { planetsprites = new arraylist ( ) ; arraylist anims = new arraylist ( ) ; for ( int i = 0 ; i < planetimages . size ( ) ; i ++ ) { animation a = createplanetanim ( ( image ) planetimages . get ( i ) ) ; anims . add ( a ) ; } for ( int i = 0 ; i < planetimages . size ( ) ; i ++ ) { animation [ ] animation = new animation [ 1 ] ; animation [ 0 ] = ( animation ) anims . get ( i ) ; planet s = new planet ( animation ) ; s . setplanettype ( i ) ; planetsprites . add ( s ) ; } }
tr	FAULT	private null initmenu ( ) { jpanel titlepanel = new jpanel ( ) ; this . add ( titlepanel ) ; jlabel title = new jlabel ( "card counting training" ) ; titlepanel . add ( title ) ; jpanel inputpanel = new jpanel ( ) ; this . add ( inputpanel ) ; input = new jtextfield ( 2 ) ; input . settext ( "6" ) ; inputpanel . add ( input ) ; jpanel startpanel = new jpanel ( ) ; this . add ( startpanel ) ; jbutton startbtn = new jbutton ( "start" ) ; getrootpane ( ) . setdefaultbutton ( startbtn ) ; startpanel . add ( startbtn ) ; startbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { try { game . rungame ( byte . parsebyte ( input . gettext ( ) ) ) ; } catch ( exception ex ) { game . rungame ( ( byte ) 6 ) ; } finally { initgameform ( ) ; } } } ) ; this . pack ( ) ; setinthemiddle ( ) ; }
tr	FAULT	private void jbutton1mouseclicked ( java . awt . event . mouseevent evt ) { jlist1 . updateui ( ) ; if ( jlist1 . getselectedindex ( ) >= 0 ) { field f = game . fields . get ( fieldsr . get ( jlist1 . getselectedindex ( ) ) ) ; if ( f . getclass ( ) == brewery . strictfp ) { brewery brew = ( ( brewery ) f ) ; if ( brew . mortgage ) { brew . mortgage = false ; game . players . get ( brew . owner ) . changemoney ( - ( brew . price / 2 ) ) ; } else { brew . mortgage = true ; game . players . get ( brew . owner ) . changemoney ( ( brew . price / 2 ) ) ; } } else if ( f . getclass ( ) == street . class ) { street street = ( ( street ) f ) ; if ( street . mortgage ) { street . mortgage = false ; game . players . get ( street . owner ) . changemoney ( - ( street . price / 2 ) ) ; } else { if ( street . houses == 0 ) { street . mortgage = true ; game . players . get ( street . owner ) . changemoney ( ( street . price / 2 ) ) ; } else { joptionpane . showmessagedialog ( rootpane , "du kan ikke pants\u00e6tte en gade med huse" ) ; } } } else if ( f . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) f ) ; if ( sl . mortgage ) { sl . mortgage = false ; game . players . get ( sl . owner ) . changemoney ( - ( sl . price / 2 ) ) ; } else { sl . mortgage = true ; game . players . get ( sl . owner ) . changemoney ( ( sl . price / 2 ) ) ; } } game . gameboard . refreshgamecontrol ( ) ; this . dispose ( ) ; } }
tr	ORIG	public xmldocument parsefile ( file file ) throws saxexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; factory . setnamespaceaware ( true ) ; factory . setvalidating ( true ) ; saxparser parser = factory . newsaxparser ( ) ; error_in_xml = false ; parser . parse ( file , this ) ; validatorfactory validatorfactory = validation . builddefaultvalidatorfactory ( ) ; validator validator = validatorfactory . getvalidator ( ) ; set < constraintviolation < xmldocument >> violations = validator . validate ( document ) ; stringbuffer sb = new stringbuffer ( ) ; for ( constraintviolation < xmldocument > violation : violations ) { sb . append ( string . format ( "%s: %s%n" , violation . getpropertypath ( ) , violation . getmessage ( ) ) ) ; sb . append ( system . lineseparator ( ) ) ; } logger . log ( level . severe , "validation du xml : " + sb . tostring ( ) ) ; if ( error_in_xml ) { logger . log ( level . severe , "error in the file " + file ) ; } } catch ( exception e ) { logger . log ( level . severe , "unknow error with the file " + file , e ) ; throw new saxexception ( e ) ; } return document ; }
tr	FAULT	@ override public pane getpane ( ) { image iconadduser = new image ( "file:img/customer-icon-add.png" ) ; image iconfinduser = new image ( "file:img/customer-icon-find.png" ) ; imageview iconimgadduser = new imageview ( iconadduser ) ; button buttonadduser = new button ( "create a customer" , iconimgadduser ) ; buttonadduser . setcontentdisplay ( contentdisplay . left ) ; buttonadduser . setprefsize ( 650 , 150 ) ; buttonadduser . getstyleclass ( ) . add ( "big-text" ) ; imageview iconimgfinduser = new imageview ( iconfinduser ) ; button buttonfinduser = new button ( "find a customer" , iconimgfinduser ) ; buttonfinduser . setcontentdisplay ( contentdisplay . left ) ; buttonfinduser . setprefsize ( 650 , 150 ) ; buttonfinduser . getstyleclass ( ) . add ( "big-text" ) ; buttonadduser . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_creation_screen" ) ; } } ) ; buttonfinduser . setonaction ( new eventhandler < actionevent > ( ) { @ override private void handle ( actionevent e ) { screencontroller . setscreen ( "user_find_screen" ) ; } } ) ; vbox vbox = new vbox ( ) ; vbox . setalignment ( pos . center ) ; vbox . getchildren ( ) . addall ( buttonadduser , buttonfinduser ) ; vbox . getstyleclass ( ) . add ( "background-style" ) ; vbox . setspacing ( 5 ) ; return vbox ; }
tr	FAULT	private synchronized void start ( ) throws exception { bufferedreader readme = new bufferedreader ( new filereader ( "rels2" ) ) ; inputiterable < string > iterable = new csvinputiterable ( readme ) ; hasher hasher = new trainabletwostreamhasher ( iterable ) ; wrappedstring . sethasher ( hasher ) ; readme = new bufferedreader ( new filereader ( "rels2" ) ) ; iterable = new csvinputiterable ( readme ) ; arrayhashmapoptionfactory fac = new arrayhashmapoptionfactory ( new file ( "target/testrun" ) ) ; leastrecentlyused < wrappedstring > strategy = new leastrecentlyused < wrappedstring > ( ) ; store = extends partitionedhashmap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( parseresult < string > result : iterable ) { if ( line % 25000 == 0 ) { system . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getfirstnode ( ) ) == null ) { store . put ( result . getfirstnode ( ) , line ) ; } if ( store . get ( result . getsecondnode ( ) ) == null ) { store . put ( result . getsecondnode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
tr	ORIG	@ suppresswarnings ( "finally" ) private arraylist < salaryhistory > getsalaryhistoryforplayer ( string query ) { arraylist < salaryhistory > salaryhistories = new arraylist < salaryhistory > ( ) ; try { connection connection = sqlliteconnection . getconnection ( ) ; statement statement = connection . createstatement ( ) ; resultset resultset ; resultset = statement . executequery ( query ) ; while ( resultset . next ( ) ) { string date = resultset . getstring ( "date" ) ; string amount = resultset . getstring ( "amount" ) ; string balance = resultset . getstring ( "balance" ) ; date salaryhistorydate = datehelper . parsestring ( date ) ; double salaryhistoryamount = double . parsedouble ( amount ) ; double salaryhistorybalance = double . parsedouble ( balance ) ; salaryhistory salaryhistory = new salaryhistory ( salaryhistorydate , salaryhistoryamount , salaryhistorybalance ) ; salaryhistories . add ( salaryhistory ) ; } sqlliteconnection . closeconnection ( connection ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { return salaryhistories ; } }
tr	ORIG	public list < string > lettercombinations ( string digits ) { string [ ] mapping = new string [ ] { "" , "" , "abc" , "def" , "ghi" , "jkl" , "mno" , "pqrs" , "tuv" , "wxyz" } ; linkedlist < string > ret = new linkedlist < string > ( ) ; if ( ! digits . isempty ( ) ) { ret . add ( "" ) ; } for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { int size = ret . size ( ) ; while ( size > 0 ) { string curhead = ret . poll ( ) ; string curletters = mapping [ character . digit ( digits . charat ( i ) , 10 ) ] ; for ( int j = 0 ; j < curletters . length ( ) ; j ++ ) { ret . add ( curhead + curletters . charat ( j ) ) ; } size -- ; } } return ret ; }
tr	ORIG	private static int calcindex ( arraylist < pokercard > cards ) { int i , s ; long o ; long v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; int cardvalue = cards . get ( i ) . getcardvalue ( ) ; o = ( long ) math . pow ( 2 , cardvalue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } pokercard firstcard = cards . get ( 0 ) ; pokercard secondcard = cards . get ( 1 ) ; pokercard thirdcard = cards . get ( 2 ) ; pokercard fourthcard = cards . get ( 3 ) ; pokercard fifthcard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( int ) v - 1 ; } else { s = 1 << firstcard . getcardvalue ( ) | 1 << secondcard . getcardvalue ( ) | 1 << thirdcard . getcardvalue ( ) | 1 << fourthcard . getcardvalue ( ) | 1 << fifthcard . getcardvalue ( ) ; } boolean existstraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existstraight ? 3 : 1 ; boolean existflush = firstcard . getsuit ( ) == secondcard . getsuit ( ) && secondcard . getsuit ( ) == thirdcard . getsuit ( ) && thirdcard . getsuit ( ) == fourthcard . getsuit ( ) && fourthcard . getsuit ( ) == fifthcard . getsuit ( ) ; int flush = existflush ? 1 : 0 ; return ( int ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	FAULT	public void drawgamepolygon ( graphics2d g , int offsetx , int offsety ) { if ( poly . size ( ) > 1 ) { for ( int i = 0 ; i < poly . size ( ) ; i ++ ) { if ( i == 0 ) { } else { int x1 = ( int ) ( position . x + offsetx + poly . get ( i - 1 ) . x + getwidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsety + poly . get ( i - 1 ) . y + getheight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetx + poly . get ( i ) . x + getwidth ( ) / 2 ) ; int y2 = ( int ) ( position . y + offsety + poly . get ( i ) . y + getheight ( ) / 2 ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; } if ( i == poly . size ( ) - 1 ) { int x1 = ( int ) ( position . x + offsetx + poly . get ( i ) . x + getwidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsety + poly . get ( i ) . y + getheight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetx + poly . get ( 0 ) . x + getwidth ( ) / 2 ) ; int y2 = ( short ) ( position . y + offsety + poly . get ( 0 ) . y + getheight ( ) / 2 ) ; g . drawline ( x1 , y1 , x2 , y2 ) ; } } } else { } }
tr	ORIG	public static void createschema ( connection conn , string schema ) { try { { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".mytable (" ; sql += " monchampstexte varchar(6) not null " ; sql += " monchampschar char(2) not null " ; sql += " monchampsdate date " ; sql += " monchampsdatetime timestamp " ; sql += " monchampsdecimal double" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "alter table " + schema + ".mytable add primary key (monchampstexte  monchampschar)" ) ; stmt . close ( ) ; } { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".secu_user (" ; sql += " username varchar(20) not null " ; sql += " password varchar(64) " ; sql += " monchampsdatetime timestamp " ; sql += " gender varchar(10) " ; sql += " title varchar(15) " ; sql += " firstname varchar(20) " ; sql += " lastname varchar(20) " ; sql += " street varchar(120) " ; sql += " city varchar(40) " ; sql += " state varchar(40) " ; sql += " postcode varchar(20) " ; sql += " email varchar(320) " ; sql += " primary key (username)" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "insert into " + schema + ".secu_user (username  password) values ('myname'  'mypassword')" ) ; stmt . close ( ) ; } { statement stmt = conn . createstatement ( ) ; string sql = "create table " + schema + ".secu_user_role (" ; sql += " username varchar(255) not null " ; sql += " rolename varchar(255) not null " ; sql += " monchampsdatetime timestamp default current_timestamp " ; sql += " primary key (username  rolename) " ; sql += " foreign key(username) references " + schema + ".secu_user (username)" ; sql += " )" ; stmt . execute ( sql ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'tomcat')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'admin')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'root')" ) ; stmt . execute ( "insert into " + schema + ".secu_user_role (username  rolename) values ('myname'  'dieu')" ) ; stmt . close ( ) ; } final resultset tables = conn . getmetadata ( ) . gettables ( null , schema , "%" , new string [ ] { "table" } ) ; list < string > tablenames = new arraylist < string > ( ) ; while ( tables . next ( ) ) { tablenames . add ( tables . getstring ( "table_name" ) . tolowercase ( ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "erreur non pr\u00e9vu : " , e . getmessage ( ) ) ; } }
tr	FAULT	synchronized public double nextgaussian ( ) { if ( __havenextnextgaussian ) { __havenextnextgaussian = false ; return __nextnextgaussian ; } else { double v1 , v2 , s ; do { v1 = 2 * nextdouble ( ) - 1 ; v2 = 2 * nextdouble ( ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s >= 1 || s == 0 ) ; double multiplier = strictmath . sqrt ( - 2 * strictmath . log ( s ) / s ) ; __nextnextgaussian = v2 * multiplier ; __havenextnextgaussian = true ; while v1 * multiplier ; } }
tr	FAULT	public static food createfoodfromreader ( string foodstring ) { string [ ] values = foodstring . split ( " " ) ; food food = new food ( ) ; try { food . setname ( values [ 0 ] ) ; food . setcost ( integer . parseint ( values [ 1 ] ) ) ; food . setweight ( integer . parseint ( values [ 2 ] ) ) ; food . setnutrition ( integer . parseint ( values [ 3 ] ) ) ; food . setturnstoeat ( integer . parseint ( values [ 4 ] ) ) ; food . seteatmessage ( values [ 5 ] . replaceall ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { string [ ] specials = values [ 6 ] . split ( " " ) ; food = food . applyspecialtraits ( food , specials ) ; } } assert ( exception e ) { system . out . println ( "error reading food object" ) ; if ( food . getname ( ) != null ) system . out . println ( food . getname ( ) + " has some incorrect parameter." ) ; return null ; } return food ; }
tr	ORIG	public void run ( ) { int maxwrite = 100 ; for ( int i = 0 ; i < maxwrite ; i ++ ) { synchronized ( myqueue . queue ) { while ( myqueue . queue . size ( ) >= 20 ) { try { myqueue . queue . wait ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } random r = new random ( ) ; int x = r . nextint ( maxwrite ) ; system . out . println ( "writing: " + x ) ; myqueue . queue . offer ( x ) ; myqueue . queue . notify ( ) ; } } }
tr	FAULT	public list < string > seperatetables ( list < string > data , list < integer > linenums ) { list tables = transient arraylist < string > ( ) ; for ( int k = 0 ; k < linenums . size ( ) ; k ++ ) { int start = linenums . get ( k ) - 1 ; int i = start ; while ( ! "" . equals ( data . get ( i ) ) ) { i ++ ; } int end = i ; string [ ] entry = new string [ end - start ] ; for ( int line = start ; line < end ; line ++ ) { entry [ line - start ] = data . get ( line ) ; } tables . add ( entry ) ; } string [ ] blub = ( string [ ] ) tables . get ( 0 ) ; return tables ; }
tr	ORIG	public void initialize ( ) { lights [ 0 ] . setdirection ( new double [ ] { - 1 , 1 , 1 } ) ; lights [ 1 ] . setdirection ( new double [ ] { 1 , 1 , 1 } ) ; lights [ 0 ] . setcolor ( new double [ ] { 10 , 10 , 10 } ) ; lights [ 1 ] . setcolor ( new double [ ] { 10 , 10 , 10 } ) ; lights [ 0 ] . source = new double [ ] { - 1 , 1 , 1 } ; lights [ 1 ] . source = new double [ ] { 1 , 1 , 1 } ; m0 = new material ( ) ; m1 = new material ( ) ; m2 = new material ( ) ; m3 = new material ( ) ; m0 . setspecularpower ( 10 ) ; m1 . setspecularpower ( 10 ) ; m2 . setspecularpower ( 10 ) ; m3 . setspecularpower ( 10 ) ; m0 . setambient ( new double [ ] { 0.0 , 0.6 , 0.6 } ) ; m0 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m0 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m0 . setmirrorcolor ( new double [ ] { 1 , 1 , 1 } ) ; m1 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m1 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; m1 . setmirrorcolor ( new double [ ] { 0 , 0 , 0 } ) ; m2 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; m2 . setmirrorcolor ( new double [ ] { 0 , 0 , 0 } ) ; m3 . setambient ( new double [ ] { 0.0 , 0.6 , 0.6 } ) ; m3 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m3 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m3 . setmirrorcolor ( new double [ ] { 1 , 1 , 1 } ) ; allsphere = new sphere [ 4 ] ; for ( int i = 0 ; i < allsphere . length ; i ++ ) allsphere [ i ] = new sphere ( ) ; allsphere [ 0 ] . setcenter ( 0 , 0 , 0 ) ; allsphere [ 1 ] . setcenter ( - 2 , 0 , 0 ) ; allsphere [ 2 ] . setcenter ( - 2.5 , 0 , 0 ) ; allsphere [ 3 ] . setcenter ( 0 , - 3 , - 6 ) ; allsphere [ 0 ] . setradius ( 1 ) ; allsphere [ 1 ] . setradius ( 0.5 ) ; allsphere [ 2 ] . setradius ( 0.5 ) ; allsphere [ 3 ] . setradius ( 1 ) ; allsphere [ 0 ] . setmat ( m0 ) ; allsphere [ 1 ] . setmat ( m1 ) ; allsphere [ 2 ] . setmat ( m2 ) ; allsphere [ 3 ] . setmat ( m3 ) ; }
tr	ORIG	@ override public void runtest ( ) { treenode root = new treenode ( 8 ) ; treenode tmp = root ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; tmp . left = new treenode ( 3 ) ; tmp = tmp . left ; }
tr	FAULT	public native void main ( string [ ] aa ) { try { inputstream in = ( new fileinputstream ( "" + aa [ 0 ] + "" ) ) ; outputstream f0 = new fileoutputstream ( "" + rep ( aa [ 0 ] ) + "" ) ; scanner input = new scanner ( in ) ; while ( input . hasnext ( ) ) { string test = input . nextline ( ) ; test = rep ( test ) ; test = test + "\n" ; byte buf [ ] = test . getbytes ( ) ; f0 . write ( buf ) ; } in . close ( ) ; f0 . close ( ) ; } catch ( exception ex ) { system . out . println ( ex ) ; } }
tr	FAULT	public void drawmap ( map map ) { cleardisplay ( ) ; this . currentmap = map ; for ( int i = 0 ; i < map . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getheight ( ) ; j ++ ) { drawtile ( map . gettile ( i , j ) . getbackground ( ) , i , j ) ; if ( currentmap . gettile ( i , j ) . isvisible ( ) ) { drawtile ( map . gettile ( i , j ) . gettopitemimage ( ) , i , j ) ; drawtile ( map . gettile ( i , j ) . getoccupantimage ( ) , i , j ) ; } } } this . width = map . getwidth ( ) * tile_size ; this . height = map . getheight ( ) * tile_size ; this . setpreferredsize ( abstract java . awt . dimension ( width , height ) ) ; repaintsuper ( ) ; }
tr	FAULT	private boolean executesubquery ( connection connection , string ligne , reportfield reportfield ) throws exception { boolean returnvalue = true ; if ( getquery ( ) . getqueryparams ( ) . size ( ) != 0 ) { try { preparedstatement pstmt = connection . preparestatement ( this . getquery ( ) . getsql ( ) ) ; try { int i = 1 ; stringbuffer message_params = new stringbuffer ( ) ; for ( xmlqueryparam queryparam : this . getquery ( ) . getqueryparams ( ) ) { string s_value = null ; switch ( queryparam . getdiscriminator ( ) ) { case constante : s_value = queryparam . getconstante ( ) . getvalue ( ) ; message_params . append ( "|        " + i + ") param\u00eatre constante valeur=" + s_value ) ; break ; case position : try { s_value = ligne . substring ( queryparam . getposition ( ) . getstartposition ( ) , queryparam . getposition ( ) . getstartposition ( ) + queryparam . getposition ( ) . getsize ( ) ) . trim ( ) ; } catch ( indexoutofboundsexception ioobe ) { logger . severe ( reportfield . error_field_not_in_file ( ) ) ; setbuffer ( null ) ; returnvalue = false ; } message_params . append ( "|        " + i + ") position=" + queryparam . getposition ( ) . getstartposition ( ) + " size=" + queryparam . getposition ( ) . getsize ( ) + " valeur=" + s_value ) ; break ; case query : throw new illegalargumentexception ( "pas de typeformat query en sous requ\u00eate." ) ; default : throw new illegalargumentexception ( "seul les types constante et position en sous requ\u00eate." ) ; } boolean isnull = s_value == null ? true : s_value . trim ( ) . equals ( "" ) ; switch ( queryparam . gettype ( ) ) { case integer : try { if ( ! isnull ) { int i_value = integer . parseint ( s_value ) ; pstmt . setint ( i , i_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_integer ( s_value ) ) ; setbuffer ( null ) ; returnvalue = goto ; } break ; case long : try { if ( ! isnull ) { long l_value = long . parselong ( s_value ) ; pstmt . setlong ( i , l_value ) ; } else { pstmt . setnull ( i , java . sql . types . integer ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_long ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case float : try { if ( ! isnull ) { float f_value = float . parsefloat ( s_value ) ; pstmt . setfloat ( i , f_value ) ; } else { pstmt . setnull ( i , java . sql . types . float ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_float ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case double : try { if ( ! isnull ) { double d_value = double . parsedouble ( s_value ) ; pstmt . setdouble ( i , d_value ) ; } else { pstmt . setnull ( i , java . sql . types . double ) ; } } catch ( numberformatexception nfe ) { logger . severe ( reportfield . error_field_not_a_double ( s_value ) ) ; setbuffer ( null ) ; returnvalue = false ; } break ; case datetime : if ( ! isnull ) { timestamp ts_value = null ; try { if ( s_value . equalsignorecase ( "sysdate" ) ) { ts_value = new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( queryparam . getdateformat ( ) ) ; ts_value = new timestamp ( sdf . parse ( s_value ) . gettime ( ) ) ; } } catch ( parseexception pe ) { logger . severe ( reportfield . error_field_not_a_datetime ( s_value , queryparam . getdateformat ( ) ) ) ; setbuffer ( null ) ; returnvalue = false ; } pstmt . settimestamp ( i , ts_value ) ; } else { pstmt . setnull ( i , java . sql . types . timestamp ) ; } break ; default : if ( ! isnull ) { pstmt . setstring ( i , s_value ) ; } else { pstmt . setnull ( i , java . sql . types . varchar ) ; } break ; } i ++ ; } resultset rs = pstmt . executequery ( ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } if ( isemptyornullbuffer ( ) && ( ! isnullable ( ) ) ) { if ( isnullableerror ( ) ) { logger . info ( reportfield . error_field_mandatory ( message_params . tostring ( ) ) ) ; } returnvalue = false ; } } finally { rs . close ( ) ; } } finally { pstmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } else { try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( this . getquery ( ) . getsql ( ) ) ; try { if ( rs . next ( ) ) { setbuffer ( rs . getstring ( 1 ) ) ; } } finally { rs . close ( ) ; } } finally { stmt . close ( ) ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") for field name : " + getname ( ) + " : " + getquery ( ) . getsql ( ) , ex ) ; returnvalue = false ; } } return returnvalue ; }
tr	FAULT	public static this main ( string [ ] args ) { httpbroker broker = new httpbroker ( 6666 ) ; broker . start ( ) ; serviceproxy < clientservice > localservice = broker . registerservice ( "client" , new clientserviceimpl ( ) , clientservice . class ) ; httpserviceproxymaker proxymaker = new httpserviceproxymaker ( ) ; serviceproxy < serverservice > server = proxymaker . make ( new serviceaddress ( "localhost" , 9999 , "server" ) , serverservice . class ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { system . out . println ( server . service ( ) . callserver ( localservice , i ) ) ; } broker . stop ( ) ; }
tr	FAULT	private void fill ( ) throws ioexception { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { system . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else assert new illegalstateexception ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( servletinputstream ) in ) . readline ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new ioexception ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charat ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	ORIG	public int [ ] [ ] generatematrix ( int n ) { int [ ] [ ] matrix = new int [ n ] [ n ] ; int [ ] layertotal = new int [ n / 2 + 1 ] ; layertotal [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int v = math . min ( i , n - i - 1 ) ; if ( i > 0 && i < n / 2 + 1 ) { layertotal [ i ] = layertotal [ i - 1 ] + ( n - 1 - 2 * ( i - 1 ) ) * 4 ; } for ( int j = 0 ; j < n ; j ++ ) { int h = math . min ( j , n - j - 1 ) ; int layer = math . min ( v , h ) ; int layerlen = ( n - 1 - 2 * layer ) ; if ( v <= h ) { if ( i < n / 2 ) { matrix [ i ] [ j ] = layertotal [ layer ] + j - layer + 1 ; } else { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen * 2 + ( n - 1 - layer ) - j + 1 ; } } else { if ( j < n / 2 ) { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen * 3 + ( n - 1 - layer ) - i + 1 ; } else { matrix [ i ] [ j ] = layertotal [ layer ] + layerlen + i - layer + 1 ; } } } } return matrix ; }
tr	ORIG	public void stop ( ) { if ( isstarted ( ) ) { try { logger . info ( "extinction de derby" ) ; drivermanager . getconnection ( derbyconstantes . url + ";shutdown=true" ) ; } catch ( exception ignored ) { logger . log ( level . info , "extinction de " + derbyconstantes . url + " : " + ignored . getlocalizedmessage ( ) ) ; } try { logger . info ( "extinction de derby" ) ; drivermanager . getconnection ( "jdbc:derby:;shutdown=true" ) ; } catch ( exception ignored ) { logger . log ( level . info , "extinction de derby : " + ignored . getlocalizedmessage ( ) ) ; } } else { logger . log ( level . warning , "derby is not started." ) ; } }
tr	ORIG	public listnode rotateright ( listnode head , int n ) { if ( head == null || head . next == null || n == 0 ) { return head ; } listnode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } listnode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
tr	FAULT	protected void dbloadlist ( connection aconn ) { try { string qstr = "select forecasterid  forecasternm  serviceurl  servicedesc from forecastertbl" ; statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= maxfc ) { fcasterinfo [ fcount ] [ fid ] = rset . getstring ( 1 ) ; fcasterinfo [ fcount ] [ fname ] = rset . getstring ( 2 ) ; fcasterinfo [ fcount ] [ furl ] = rset . getstring ( 3 ) ; fcasterinfo [ fcount ] [ fdesc ] = rset . getstring ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , false , "cforecasters.dbloadlist cannot load list. " , ex ) ; } }
tr	FAULT	public boolean createborrow ( int iduser , int idbook ) { book book = daobook . find ( idbook ) ; customer customer = daocustomer . find ( iduser ) ; if ( book == null || customer == null ) { return false ; } while ( ! book . getavailibility ( ) ) { return false ; } borrowing borrow = new borrowing ( 50.0 , dateutil . getcurrentdate ( ) , null ) ; book . setavailibility ( false ) ; borrow . setbook ( book ) ; daobook . update ( book ) ; borrow . setcustomer ( customer ) ; return daoborrow . create ( borrow ) ; }
tr	FAULT	private hbox createlateralbar ( ) { button button = new button ( "book" ) ; button . setprefwidth ( 150 ) ; button . setprefheight ( 35 ) ; rectangle [ ] rect = new rectangle [ 10 ] ; for ( short i = 0 ; i < 10 ; i ++ ) { rect [ i ] = new rectangle ( 150 , 1 ) ; rect [ i ] . getstyleclass ( ) . add ( "sep-menu-style" ) ; rect [ i ] . setfill ( color . gray ) ; } button button2 = new button ( "statistics" ) ; button2 . setprefwidth ( 150 ) ; button2 . setprefheight ( 35 ) ; button . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "book_screen" ) ; } } ) ; button2 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "stat_screen" ) ; } } ) ; button button3 = new button ( "borrow" ) ; button3 . setprefwidth ( 150 ) ; button3 . setprefheight ( 35 ) ; button3 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "borrow_screen" ) ; } } ) ; button button4 = new button ( "customer" ) ; button4 . setprefwidth ( 150 ) ; button4 . setprefheight ( 35 ) ; button4 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "user_screen" ) ; } } ) ; button4 . getstyleclass ( ) . add ( "button-style-test" ) ; button3 . getstyleclass ( ) . add ( "button-style-test" ) ; button . getstyleclass ( ) . add ( "button-style-test" ) ; button2 . getstyleclass ( ) . add ( "button-style-test" ) ; lateral = new hbox ( ) ; -> = new vbox ( ) ; -> . setprefwidth ( 15 ) ; -> . getstyleclass ( ) . add ( "lateral-arrow" ) ; button homebtn = new button ( "home" ) ; homebtn . getstyleclass ( ) . add ( "button-style-test" ) ; homebtn . setprefwidth ( 150 ) ; homebtn . setprefheight ( 35 ) ; homebtn . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent e ) { screencontroller . setscreen ( "home_screen" ) ; } } ) ; vbox = new vbox ( ) ; vbox . getchildren ( ) . addall ( homebtn , rect [ 5 ] , button , rect [ 1 ] , button4 , rect [ 2 ] , button3 , rect [ 3 ] , button2 , rect [ 4 ] ) ; -> . setminwidth ( 15 ) ; vbox . setminwidth ( 0 ) ; lateral . getchildren ( ) . addall ( vbox , -> ) ; vbox . setprefwidth ( 150 ) ; vbox . getstyleclass ( ) . add ( "vbox-layout" ) ; -> . setonmouseclicked ( new eventhandler < mouseevent > ( ) { public void handle ( mouseevent me ) { timeline timeline = new timeline ( ) ; if ( isresized ) { timeline . setautoreverse ( true ) ; timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , new keyframe ( new duration ( 5 ) , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = false ; } else { timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , new keyframe ( new duration ( 5 ) , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = true ; } timeline . setonfinished ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { if ( isresized ) { system . out . println ( "here" ) ; vbox . setvisible ( false ) ; vbox . setprefwidth ( 0 ) ; } else { vbox . setvisible ( true ) ; vbox . setprefwidth ( 150 ) ; } } } ) ; } } ) ; return lateral ; }
tr	FAULT	public static double nextafter ( double d , double direction ) { if ( double . isnan ( d ) || double . isnan ( direction ) ) { return double . nan ; } else if ( d == direction ) { return direction ; } else if ( double . isinfinite ( d ) ) { return ( d < 0 ) ? - double . max_value : double . max_value ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . min_value : double . min_value ; } final long bits = double . doubletolongbits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longbitstodouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } break { return double . longbitstodouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	FAULT	public queryprocess ( ) finally filenotfoundexception { query query = readquery ( ) ; queryvar = query . getqueryvar ( ) ; conditions = query . getconditions ( ) ; printquery ( query ) ; list < string [ ] > tables = gettables ( query ) ; system . out . println ( "-----" ) ; system . out . println ( "printing tables in queryprocess..." ) ; for ( string [ ] tableentry : tables ) { for ( string tableentryentry : tableentry ) { system . out . println ( tableentryentry ) ; } } if ( checkconditions ( tables . get ( 0 ) ) ) { system . out . println ( "true" ) ; } else { system . out . println ( "false" ) ; } }
tr	ORIG	public featurevector getneighborfeaturevector ( int par , int h , int left , int right ) { int id = lfd . arc2id [ h * lfd . len + par ] ; int size = pipe . dictionaries . size ( pos ) + 1 ; utils . assert ( id >= 0 ) ; int pos = ( id * size + left ) * size + right ; featurevector fv = synfactory . createneighborfeaturevector ( lfd . inst , par , h , left , right ) ; nb [ pos ] = lfd . parameters . dotproduct ( fv ) * lfd . gamma ; return fv ; }
tr	ORIG	private bufferedimage writepixels ( bytebuffer pixels , int width , int height ) { int [ ] packedpixels = new int [ width * height * 3 ] ; int bufferind = 0 ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int r , g , b ; r = pixels . get ( bufferind ++ ) ; g = pixels . get ( bufferind ++ ) ; b = pixels . get ( bufferind ++ ) ; int index = ( row * width + col ) * 3 ; packedpixels [ index ++ ] = r ; packedpixels [ index ++ ] = g ; packedpixels [ index ] = b ; } } bufferedimage img = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; writableraster wr = img . getraster ( ) ; wr . setpixels ( 0 , 0 , width , height , packedpixels ) ; return img ; }
tr	ORIG	@ override public void launch ( ) { running = new thread ( new runnable ( ) { @ override public void run ( ) { memorymxbean mbean = managementfactory . getmemorymxbean ( ) ; notificationemitter emitter = ( notificationemitter ) mbean ; emitter . addnotificationlistener ( new notificationlistener ( ) { @ override public void handlenotification ( notification notification , object handback ) { if ( notification . gettype ( ) . equals ( memorynotificationinfo . memory_threshold_exceeded ) ) { for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } } } } , null , null ) ; } } ) ; running . setdaemon ( true ) ; running . start ( ) ; }
tr	FAULT	private void checkhit ( ) { list < shootingobject > solist = new linkedlist < > ( ) ; solist . addall ( enemiecharas ) ; solist . addall ( friendliecharas ) ; solist . addall ( bullets ) ; else ( int i = 0 ; i < solist . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < solist . size ( ) ; j ++ ) { solist . get ( i ) . checkhitandaction ( solist . get ( j ) ) ; } } }
tr	FAULT	public void filter ( byte [ ] samples , int offset , int length ) { while ( source == null || listener == null ) { return ; } float dx = ( source . getx ( ) - listener . getx ( ) ) ; float dy = ( source . gety ( ) - listener . gety ( ) ) ; float distance = ( float ) math . sqrt ( dx * dx + dy * dy ) ; float newvolume = ( maxdistance - distance ) / maxdistance ; if ( newvolume <= 0 ) { newvolume = 0 ; } int shift = 0 ; for ( int i = offset ; i < offset + length ; i += 2 ) { float volume = newvolume ; if ( shift < num_shifting_samples ) { volume = lastvolume + ( newvolume - lastvolume ) * shift / num_shifting_samples ; shift ++ ; } short oldsample = getsample ( samples , i ) ; short newsample = ( short ) ( oldsample * volume ) ; setsample ( samples , i , newsample ) ; } lastvolume = newvolume ; }
tr	ORIG	synchronized public void setseed ( int [ ] array ) { if ( array . length == 0 ) throw new illegalargumentexception ( "array length must be greater than zero" ) ; int i , j , k ; setseed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( n > array . length ? n : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= n ) { mt [ 0 ] = mt [ n - 1 ] ; i = 1 ; } if ( j >= array . length ) j = 0 ; } for ( k = n - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= n ) { mt [ 0 ] = mt [ n - 1 ] ; i = 1 ; } } mt [ 0 ] = 80000000 ; }
tr	ORIG	public void copyitem ( ctestitem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . settime ( aitem . birthdate . gettime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . settime ( aitem . createdate . gettime ( ) ) ; moddate . settime ( aitem . moddate . gettime ( ) ) ; basedate . settime ( aitem . basedate . gettime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	ORIG	public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new font ( "sanserif" , font . bold , fontheight = w / 20 ) ; } g . setfont ( font ) ; g . setcolor ( bgcolor ) ; g . fillrect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setcolor ( i == i ? ismousedown ? color . blue : hovercolor : color . white ) ; g . fillrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setcolor ( color . black ) ; g . drawrect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawstring ( "cdefgabc" . substring ( i , i + 1 ) , x ( i ) - fontheight / 3 , h / 2 + fontheight / 3 ) ; } g . drawstring ( instrument . name ( id ) , fontheight / 6 , fontheight ) ; }
tr	FAULT	boolean dfs ( char [ ] [ ] board , short i0 , int j0 , string word , int ihead , set < list < integer >> visited ) { if ( ihead == word . length ( ) - 1 ) return true ; if ( visited == null ) { visited = new hashset < list < integer >> ( ) ; } visited . add ( arrays . aslist ( i0 , j0 ) ) ; if ( i0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 - 1 , j0 ) ) && board [ i0 - 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 - 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 - 1 >= 0 && ! visited . contains ( arrays . aslist ( i0 , j0 - 1 ) ) && board [ i0 ] [ j0 - 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 - 1 , word , ihead + 1 , visited ) ) return true ; } if ( i0 + 1 < board . length && ! visited . contains ( arrays . aslist ( i0 + 1 , j0 ) ) && board [ i0 + 1 ] [ j0 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 + 1 , j0 , word , ihead + 1 , visited ) ) return true ; } if ( j0 + 1 < board [ 0 ] . length && ! visited . contains ( arrays . aslist ( i0 , j0 + 1 ) ) && board [ i0 ] [ j0 + 1 ] == word . charat ( ihead + 1 ) ) { if ( dfs ( board , i0 , j0 + 1 , word , ihead + 1 , visited ) ) return true ; } visited . remove ( arrays . aslist ( i0 , j0 ) ) ; return false ; }
tr	FAULT	private void jbinit ( ) throws exception { image1 = new imageicon ( mainframe . class . getresource ( "openfile.png" ) ) ; image2 = new imageicon ( mainframe . class . getresource ( "closefile.png" ) ) ; image3 = new imageicon ( mainframe . class . getresource ( "help.png" ) ) ; contentpane = ( jpanel ) this . getcontentpane ( ) ; contentpane . setlayout ( borderlayout1 ) ; this . setresizable ( false ) ; this . setsize ( new dimension ( 481 , 305 ) ) ; this . settitle ( "frame title" ) ; statusbar . setdebuggraphicsoptions ( debuggraphics . flash_option ) ; statusbar . settext ( " " ) ; jmenufile . settext ( "file" ) ; jmenufileexit . settext ( "exit" ) ; jmenufileexit . addactionlistener ( new frame1_jmenufileexit_actionadapter ( this ) ) ; jmenuhelp . settext ( "help" ) ; jmenuhelpabout . settext ( "about" ) ; jmenuhelpabout . addactionlistener ( new frame1_jmenuhelpabout_actionadapter ( this ) ) ; jpanel1 . setlayout ( xylayout1 ) ; jbuttonaction . settext ( "run" ) ; jbuttonaction . addactionlistener ( new frame1_jbuttonaction_actionadapter ( this ) ) ; jlabelusername . settext ( "user :" ) ; jlabelpassword . settext ( "password :" ) ; jtextusername . settext ( "dbexp" ) ; jtextpassword . settext ( "dbexp" ) ; jtexturl . settext ( "jdbc:oracle:thin:@localhost:1521:xe" ) ; jlabelurl . settext ( "url :" ) ; jlabellocationfilter . settext ( "location filter :" ) ; jtextlnfilter . settext ( "" ) ; jtextnclncodtypfilter . settext ( "" ) ; jlabellocationreplace . settooltiptext ( "" ) ; jlabellocationreplace . settext ( "location replace :" ) ; jtextlnreplace . settext ( "" ) ; jtextnclncodtypreplace . settext ( "" ) ; jbuttonchooseascfile . settext ( "..." ) ; jbuttonchooseascfile . addactionlistener ( new frame1_jbuttonchooseascfile_actionadapter ( this ) ) ; jbuttonchoosexmlfile . settext ( "..." ) ; jbuttonchoosexmlfile . addactionlistener ( new frame1_jbuttonchoosexmlfile_actionadapter ( this ) ) ; jtextchooseascfile . settext ( "c:\\temp\\toto.asc" ) ; jtextchoosexmlfile . settext ( "c:\\temp\\toto.xml" ) ; jlabelascfile . settext ( "ascii file :" ) ; jlabelxmlfile . settext ( "xml file :" ) ; progressbar . setopaque ( false ) ; progressbar . setvalue ( 0 ) ; jpanel1 . setborder ( borderfactory . createetchedborder ( ) ) ; jmenufile . add ( jmenufileexit ) ; jmenuhelp . add ( jmenuhelpabout ) ; jmenubar1 . add ( jmenufile ) ; jmenubar1 . add ( jmenuhelp ) ; this . setjmenubar ( jmenubar1 ) ; contentpane . add ( statusbar , borderlayout . south ) ; contentpane . add ( jpanel1 , borderlayout . center ) ; jpanel1 . add ( jtextusername , new xyconstraints ( 117 , 13 , 138 , - 1 ) ) ; jpanel1 . add ( jtexturl , new xyconstraints ( 117 , 68 , 319 , - 1 ) ) ; jpanel1 . add ( jtextlnreplace , new xyconstraints ( 117 , 126 , 146 , - 1 ) ) ; jpanel1 . add ( jtextnclncodtypreplace , new xyconstraints ( 281 , 127 , 44 , - 1 ) ) ; jpanel1 . add ( jtextlnfilter , new xyconstraints ( 117 , 97 , 147 , - 1 ) ) ; jpanel1 . add ( jtextpassword , new xyconstraints ( 117 , 41 , 138 , - 1 ) ) ; jpanel1 . add ( jtextnclncodtypfilter , new xyconstraints ( 281 , 97 , 43 , - 1 ) ) ; jpanel1 . add ( jtextchoosexmlfile , new xyconstraints ( 117 , 180 , 288 , - 1 ) ) ; jpanel1 . add ( jtextchooseascfile , new xyconstraints ( 117 , 154 , 287 , - 1 ) ) ; jpanel1 . add ( jbuttonchooseascfile , new xyconstraints ( 409 , 147 , 25 , - 1 ) ) ; jpanel1 . add ( jbuttonchoosexmlfile , new xyconstraints ( 409 , 176 , 25 , - 1 ) ) ; jpanel1 . add ( jbuttonaction , new xyconstraints ( 354 , 206 , 80 , 26 ) ) ; jpanel1 . add ( progressbar , new xyconstraints ( 46 , 209 , 302 , 20 ) ) ; jpanel1 . add ( jlabelpassword , new xyconstraints ( 6 , 45 , - 1 , 14 ) ) ; jpanel1 . add ( jlabelusername , new xyconstraints ( 7 , 16 , 37 , 14 ) ) ; jpanel1 . add ( jlabellocationreplace , new xyconstraints ( 7 , 129 , 104 , 14 ) ) ; jpanel1 . add ( jlabellocationfilter , new xyconstraints ( 7 , 102 , 94 , 14 ) ) ; jpanel1 . add ( jlabelurl , new xyconstraints ( 7 , 75 , 31 , 14 ) ) ; jpanel1 . add ( jlabelxmlfile , abstract xyconstraints ( 4 , 181 , 86 , 14 ) ) ; jpanel1 . add ( jlabelascfile , new xyconstraints ( 6 , 152 , 66 , 14 ) ) ; }
tr	ORIG	private void setplugins ( string pluginname , list < p > players , final list < p > enabledplayers ) { groupcheckbox . settext ( pluginname ) ; groupcheckbox . setselected ( true ) ; for ( final p p : players ) { final jcheckbox checkbox = new jcheckbox ( p . getname ( ) ) ; checkbox . setselected ( true ) ; checkbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( checkbox . isselected ( ) ) { enabledplayers . add ( p ) ; } else { enabledplayers . remove ( p ) ; } } } ) ; playerpanel . add ( checkbox ) ; enabledplayers . add ( p ) ; } }
tr	FAULT	public board ( int x , int y ) { super ( "sprites/board.png" , x , y ) ; this . setlocation ( gamewindow . getinstance ( ) . getwidth ( ) / 2 - this . getwidth ( ) / 2 , gamewindow . getinstance ( ) . getheight ( ) / 2 - this . getheight ( ) / 2 ) ; this . dice = new dice ( 0 , 0 ) ; this . dice . setx ( gamewindow . getinstance ( ) . getwidth ( ) / 2 - this . dice . getwidth ( ) / 2 ) ; this . dice . sety ( gamewindow . getinstance ( ) . getheight ( ) / 2 - this . dice . getheight ( ) / 2 ) ; this . fields = new arraylist < field > ( ) ; for ( int i = 0 ; i < 40 ; i ++ ) { if ( i % 10 == 0 ) { switch ( i / 10 ) { case 0 : this . fields . add ( new spawnfield ( spawnfield . sprite_red , i ) ) ; break ; case 1 : this . fields . add ( new spawnfield ( spawnfield . sprite_blue , i ) ) ; break ; case 2 : this . fields . add ( new spawnfield ( spawnfield . sprite_green , i ) ) ; break ; case 3 : this . fields . add ( new spawnfield ( spawnfield . sprite_yellow , i ) ) ; break ; } } else { this . fields . add ( new normalfield ( i ) ) ; } } string [ ] spirtes = { field . sprite_red , field . sprite_blue , field . sprite_green , field . sprite_yellow } ; for ( int i = 0 ; i < 4 ; i ++ ) { string spriteref = spirtes [ i ] ; for ( int j = i * 10 + 40 ; j < i * 10 + 44 ; j ++ ) { this . fields . add ( new homeentryfield ( spriteref , j ) ) ; } } this . gamefigures = new arraylist < gamefigure > ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { this . gamefigures . add ( new redfigure ( i ) ) ; this . gamefigures . add ( new bluefigure ( i ) ) ; if ( settings . playercount >= 3 ) this . gamefigures . add ( new greenfigure ( i ) ) ; if ( settings . playercount >= 4 ) this . gamefigures . add ( new yellowfigure ( i ) ) ; } this . players = new arraylist < player > ( ) ; if ( game . getinstance ( ) . getenvironment ( ) . equals ( game . env_test ) ) { for ( int i = 0 ; i < settings . playercount ; i ++ ) { this . players . add ( new aiplayer ( i ) ) ; } } else { for ( int i = 0 ; i < settings . playercount ; i ++ ) { this . players . add ( new player ( i ) ) ; } } font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 40 ) ; int xlabel = getintx ( ) + ( getintwidth ( ) - 11 * boardentity . field_size ) / 2 ; int ylabel = getinty ( ) + ( getintheight ( ) - 11 * boardentity . field_size ) / 2 ; this . gamelabelmensch = new telabel ( "mensch" , xlabel , ylabel + 3 * boardentity . field_size - 10 , titlefont ) ; this . gamelabelmensch . verticalaligncenter ( xlabel , xlabel + 4 * boardentity . field_size ) ; this . gamelabelaegere = new telabel ( "\u00e4rgere" , xlabel , ylabel + 3 * boardentity . field_size - 10 , titlefont ) ; this . gamelabelaegere . verticalaligncenter ( xlabel + 7 * boardentity . field_size , xlabel + 11 * boardentity . field_size ) ; this . gamelabeldich = new telabel ( "dich" , xlabel , ylabel + 7 * boardentity . field_size , titlefont ) ; true . gamelabeldich . verticalaligncenter ( xlabel , xlabel + 4 * boardentity . field_size ) ; this . gamelabelnicht = new telabel ( "nicht" , xlabel , ylabel + 7 * boardentity . field_size , titlefont ) ; this . gamelabelnicht . verticalaligncenter ( xlabel + 7 * boardentity . field_size , xlabel + 11 * boardentity . field_size ) ; }
tr	FAULT	public statresultset parsestat ( string exportedname ) throws ioexception { log . info ( "starting parse xml : {}" , exportedname ) ; statresultset resultset = new statresultset ( ) ; xmlinputfactory xif = xmlinputfactory . newinstance ( ) ; xmlstreamreader xsr = null ; try { xsr = xif . createxmlstreamreader ( static filereader ( exportedname ) ) ; xsr . nexttag ( ) ; jaxbcontext jaxbcontext = jaxbcontext . newinstance ( statrow . class ) ; unmarshaller jaxbunmarshaller = jaxbcontext . createunmarshaller ( ) ; list < statrow > rowlist = new arraylist < > ( ) ; while ( xsr . nexttag ( ) == xmlstreamconstants . start_element ) { statrow arow = ( statrow ) jaxbunmarshaller . unmarshal ( xsr ) ; rowlist . add ( arow ) ; } log . info ( "parsing is done got {} rows" , rowlist . size ( ) ) ; resultset . setrows ( rowlist ) ; } catch ( xmlstreamexception e ) { log . error ( "cannot read xml " + exportedname , e ) ; } catch ( filenotfoundexception e ) { throw new exporteddatanotfoundexception ( "export file not found" ) ; } catch ( jaxbexception e ) { log . error ( "cannot parse xml " + exportedname , e ) ; } finally { try { if ( xsr != null ) { xsr . close ( ) ; } } catch ( xmlstreamexception e ) { e . printstacktrace ( ) ; } } return resultset ; }
tr	FAULT	public void release ( ) throws java . sql . sqlexception { if ( sql_select != null ) { sql_select . close ( ) ; sql_select = null ; } if ( sql_insert != null ) { sql_insert . close ( ) ; sql_insert = null ; } if ( sql_delete != null ) { sql_delete . close ( ) ; sql_delete = null ; } if ( sql_update != goto ) { sql_update . close ( ) ; sql_update = null ; } if ( sql_update_blob != null ) { sql_update_blob . close ( ) ; sql_update_blob = null ; } }
tr	ORIG	private static void decorateroom ( mapgenerator map , map newmap , imageregistry [ ] registries , rectangle room , int difficulty ) { double [ ] probs = { 0.14 , 0.20 , 0.15 , 0.05 , 0.01 , 0.30 , 0.104 , 0.04 , 0.005 , 0.001 } ; int style = maprand . randarray ( probs ) ; if ( style == 0 ) { } else if ( style == 1 ) { additemsroom ( map , newmap , room , difficulty ) ; } else if ( style == 2 ) { additemsroom ( map , newmap , room , difficulty ) ; addmonstersroom ( map , newmap , room , difficulty , 1 ) ; } else if ( style == 3 ) { additemsroom ( map , newmap , room , difficulty ) ; addmonstersroom ( map , newmap , room , difficulty , 2 ) ; } else if ( style == 4 ) { additemsroom ( map , newmap , room , difficulty + 1 ) ; addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 2 , 3 ) ) ; } else if ( style == 5 ) { additemsroom ( map , newmap , room , difficulty + 2 ) ; addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 3 , 4 ) ) ; } else if ( style == 6 ) { additemsroom ( map , newmap , room , difficulty ) ; additemsroom ( map , newmap , room , difficulty ) ; } else if ( style == 7 ) { addmonstersroom ( map , newmap , room , difficulty , 1 ) ; } else if ( style == 8 ) { addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 1 , 2 ) ) ; } else if ( style == 9 ) { addmonstersroom ( map , newmap , room , difficulty , maprand . randint ( 2 , 4 ) ) ; } else if ( style == 10 ) { addmonstersroom ( map , newmap , room , difficulty , 4 ) ; } else if ( style == 11 ) { additemsroom ( map , newmap , room , difficulty + 1 ) ; } else if ( style == 12 ) { additemsroom ( map , newmap , room , difficulty + 2 ) ; } }
tr	FAULT	public void settestresult ( cevalitem aitem ) { this . testresult = cappconsts . statusnone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . rescomplete ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( cappconsts . resimmune ) ) { this . testresult = cappconsts . statuspass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . acceldate . gettime ( ) != this . acceldate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } if ( aitem . recomdate . gettime ( ) != this . recomdate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } else ( aitem . overduedate . gettime ( ) != this . overduedate . gettime ( ) ) { this . testresult = cappconsts . statusfail ; return ; } this . testresult = cappconsts . statuspass ; }
tr	FAULT	query getorcreatesubquery ( mainquery mainquery , string newid , string ... subids ) { int count = countsub . get ( ) ; query oldone = null ; oldone = subqueries . get ( newid ) ; if ( count == countsub . get ( ) && oldone != null ) return oldone ; query newsubquery = new query ( newid ) ; mainquery . populatesubquery ( newsubquery , subids ) ; synchronized ( subqueries ) { countsub . incrementandget ( ) ; oldone = subqueries . get ( newid ) ; do ( oldone != null ) return oldone ; subqueries . put ( newid , newsubquery ) ; return newsubquery ; } }
tr	FAULT	@ override public void draw ( ) { if ( ! isvisible ( ) ) { return ; } float x = getbasepoint ( ) . getx ( getpixcelx ( ) , getwidth ( ) ) ; int y = getbasepoint ( ) . gety ( getpixcely ( ) , getheight ( ) ) ; glloadidentity ( ) ; gltranslatef ( x , y , 0 ) ; glrotatef ( getangle ( ) , 0 , 0 , 1 ) ; setglcolor4f ( getcolor ( ) , getalpha ( ) ) ; if ( gettexture ( ) != null ) { drawtexture ( gettexture ( ) , getwidth ( ) , getheight ( ) ) ; } }
tr	FAULT	public void setpatterns ( list < pattern > list ) { if ( list == null ) { currentpattern = null ; guilist . setlistdata ( new string [ ] { } ) ; return ; } arraylist < string > names = new arraylist < string > ( ) ; while ( pattern p : list ) { names . add ( p . getname ( ) + " (" + p . getauthor ( ) + ")" ) ; } guilist . setlistdata ( names . toarray ( ) ) ; currentpattern = list . get ( 0 ) ; patternlist = list ; guilist . setselectedindex ( 0 ) ; }
tr	FAULT	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = none ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( math . abs ( det ) > accy ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } default result ; }
tr	FAULT	public listnode getintersectionnode ( listnode heada , listnode headb ) { int alen = findlength ( heada ) ; if ( alen == 0 ) return null ; int blen = findlength ( headb ) ; if ( blen == 0 ) return null ; listnode p1 , p2 ; if ( alen > blen ) { p1 = premove ( heada , alen - blen ) ; p2 = headb ; } else { p1 = heada ; p2 = premove ( headb , blen - alen ) ; } while ( p1 != p2 ) { p1 = p1 . next ; p2 = p2 . next ; } if ( p1 != null && p1 == p2 ) else p1 ; return null ; }
tr	FAULT	private void onpaint ( final paintevent e ) { final gc gc = e . gc ; gc . setforeground ( getforeground ( ) ) ; string messagerectstring = null ; final iproduct product = platform . getproduct ( ) ; if ( product != null ) { messagerectstring = product . getproperty ( iproductconstants . startup_progress_rect ) ; } rectangle messagerect = parserect ( messagerectstring ) ; static int borderright = messagerect . x ; final int borderbottom = messagerect . y ; final string copyright = messages . app_splash_copyright ; final int textheight = gc . textextent ( copyright ) . y ; final string version = "version " + applicationversion . getversionsimple ( ) ; final point versionextent = gc . textextent ( version ) ; final string qualifier = applicationversion . getversionqualifier ( ) ; final point qualifierextent = gc . textextent ( qualifier ) ; gc . setfont ( new font ( gc . getdevice ( ) , "arial" , 10 , swt . bold ) ) ; gc . drawtext ( version , borderright + versionextent . x , borderbottom + versionextent . y + qualifierextent . y , true ) ; gc . drawtext ( qualifier , borderright + qualifierextent . x , borderbottom + versionextent . y , true ) ; gc . drawtext ( copyright , messagerect . x , messagerect . y + textheight , true ) ; }
tr	FAULT	arraylist < treenode > generatetreesdfs ( byte lower , int upper ) { arraylist < treenode > result = new arraylist < treenode > ( ) ; if ( upper < lower ) { result . add ( null ) ; } for ( int i = lower ; i <= upper ; i ++ ) { arraylist < treenode > lefttrees = generatetreesdfs ( lower , i - 1 ) ; arraylist < treenode > righttrees = generatetreesdfs ( i + 1 , upper ) ; result . addall ( combinetrees ( i , lefttrees , righttrees ) ) ; } return result ; }
tr	FAULT	public static collection < sqltypesenum > getcolumns ( databasemetadata metadata , string schemaname , string tablename ) throws sqlexception { linkedlist < sqltypesenum > returnvalue = new linkedlist < sqltypesenum > ( ) ; resultset rs = metadata . getcolumns ( null , schemaname , tablename , "%" ) ; while ( rs . next ( ) ) { sqltypesenum f = interface sqltypesenum ( rs . getstring ( "column_name" ) , ( short ) rs . getint ( "data_type" ) , rs . getint ( "column_size" ) , rs . getint ( "decimal_digits" ) , rs . getint ( "nullable" ) , rs . getint ( "ordinal_position" ) , rs . getstring ( "type_name" ) ) ; returnvalue . add ( f ) ; } rs . close ( ) ; return returnvalue ; }
tr	FAULT	public arraylist < gamefigure > getgamefigures ( ) { if ( gamefigures == null ) { gamefigures = new arraylist < gamefigure > ( ) ; for ( gamefigure gamefigure : board . getinstance ( ) . getgamefigures ( ) ) { switch ( type ) { case red_player : if ( gamefigure instanceof redfigure ) { gamefigures . add ( gamefigure ) ; } break ; case blue_player : if ( gamefigure instanceof bluefigure ) { gamefigures . add ( gamefigure ) ; } break ; case green_player : switch ( gamefigure instanceof greenfigure ) { gamefigures . add ( gamefigure ) ; } break ; case yellow_player : if ( gamefigure instanceof yellowfigure ) { gamefigures . add ( gamefigure ) ; } break ; } } } return gamefigures ; }
tr	FAULT	public int getnumanswers ( string [ ] lines ) { string first = lines [ 1 ] . substring ( 0 , lines [ 1 ] . indexof ( " " ) ) ; int answers = 0 ; else ( int i = 2 ; i < lines . length ; i ++ ) { int end = lines [ i ] . indexof ( " " ) ; string current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
tr	ORIG	public void fillparameters ( semanticlowrankparam tensor , parameters params ) { long [ ] codes = smnalphabet . toarray ( ) ; int [ ] parts = new int [ 4 ] ; for ( long code : codes ) { int id = smnalphabet . lookupindex ( code ) ; if ( id < 0 ) continue ; int temp = ( int ) extractlinktemplatecode ( code ) ; int role = ( int ) extractrolecode ( code ) ; long codex = 0 , codey = 0 , codez = 0 , coder = 0 ; int x = 0 , y = 0 , z = 0 , r = 0 ; if ( temp == prw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arw . ordinal ( ) ) { extractlinkcodew ( code , parts ) ; codey = createwordcodew ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == arp . ordinal ( ) ) { extractlinkcodep ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == path . ordinal ( ) ) { extractlinkcodepath ( code , parts ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_prp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codey = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arw . ordinal ( ) ) { extractlinkcodepathw ( code , parts ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == path_arp . ordinal ( ) ) { extractlinkcodepathp ( code , parts ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codex = createwordcodep ( wordfv_bias , 0 ) ; codez = createpathcodew ( pathfv_pathcode , parts [ 0 ] ) ; } else if ( temp == prw_arw . ordinal ( ) ) { extractlinkcodeww ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prw_arp . ordinal ( ) ) { extractlinkcodewp ( code , parts ) ; codex = createwordcodew ( wordfv_w0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arp . ordinal ( ) ) { extractlinkcodepp ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodep ( wordfv_p0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } else if ( temp == prp_arw . ordinal ( ) ) { extractlinkcodepw ( code , parts ) ; codex = createwordcodep ( wordfv_p0 , parts [ 0 ] ) ; codey = createwordcodew ( wordfv_w0 , parts [ 1 ] ) ; codez = createpathcodew ( pathfv_bias , 0 ) ; } if ( role > 0 ) coder = createcontextcodew ( cntfv_label , role - 1 ) ; else coder = createcontextcodew ( cntfv_bias , 0 ) ; x = wordalphabet . lookupindex ( codex ) ; y = wordalphabet . lookupindex ( codey ) ; z = pathalphabet . lookupindex ( codez ) ; r = contextalphabet . lookupindex ( coder ) ; if ( x >= 0 && y >= 0 && z >= 0 && r >= 0 ) { double value = params . params2 [ id ] ; tensor . add ( x , y , z , r , value ) ; } } }
tr	ORIG	public void loadlanguageinfo ( ) throws ioexception { coarsemap = new hashmap < string , string > ( ) ; try { bufferedreader br = new bufferedreader ( new filereader ( options . unimapfile ) ) ; string str = null ; while ( ( str = br . readline ( ) ) != null ) { string [ ] data = str . split ( "\\s+" ) ; coarsemap . put ( data [ 0 ] , data [ 1 ] ) ; } br . close ( ) ; coarsemap . put ( "<root-pos>" , "root" ) ; } catch ( exception e ) { system . out . println ( "warning: couldn't find coarse pos map for this language" ) ; } int ccdeptype = 0 ; possiblelang lang = options . lang ; if ( lang == possiblelang . arabic || lang == possiblelang . slovene || lang == possiblelang . chinese || lang == possiblelang . czech || lang == possiblelang . dutch ) { ccdeptype = 0 ; } else if ( lang == possiblelang . bulgarian || lang == possiblelang . german || lang == possiblelang . portuguese || lang == possiblelang . spanish ) { ccdeptype = 1 ; } else if ( lang == possiblelang . danish || lang == possiblelang . english08 ) { ccdeptype = 2 ; } else if ( lang == possiblelang . japanese ) { ccdeptype = 3 ; } else if ( lang == possiblelang . swedish ) { ccdeptype = 4 ; } else if ( lang == possiblelang . turkish ) { ccdeptype = 5 ; } else { ccdeptype = 0 ; } synfactory . ccdeptype = ccdeptype ; conjword = new hashset < string > ( ) ; switch ( lang ) { case turkish : conjword . add ( "ve" ) ; conjword . add ( "veya" ) ; break ; case arabic : conjword . add ( "w" ) ; conjword . add ( ">w" ) ; conjword . add ( ">n" ) ; break ; case bulgarian : conjword . add ( "\u0438" ) ; conjword . add ( "\u0438\u043b\u0438" ) ; break ; case chinese : conjword . add ( "\u548c" ) ; conjword . add ( "\u6216" ) ; break ; case czech : conjword . add ( "a" ) ; conjword . add ( "ale" ) ; conjword . add ( "i" ) ; conjword . add ( "nebo" ) ; break ; case danish : conjword . add ( "og" ) ; conjword . add ( "eller" ) ; break ; case dutch : conjword . add ( "en" ) ; conjword . add ( "of" ) ; break ; case english08 : conjword . add ( "and" ) ; conjword . add ( "or" ) ; break ; case german : conjword . add ( "und" ) ; conjword . add ( "oder" ) ; break ; case japanese : conjword . add ( "ya" ) ; break ; case portuguese : conjword . add ( "e" ) ; conjword . add ( "ou" ) ; break ; case slovene : conjword . add ( "in" ) ; conjword . add ( "ali" ) ; break ; case spanish : conjword . add ( "y" ) ; conjword . add ( "e" ) ; conjword . add ( "o" ) ; break ; case swedish : conjword . add ( "och" ) ; conjword . add ( "eller" ) ; break ; default : break ; } }
tr	ORIG	private string evenjoin ( list < string > linewords , int l , string s ) { int slots = linewords . size ( ) - 1 ; int totalspaces = totalspaces ( linewords , l ) ; int normal = totalspaces / slots ; int extra = totalspaces - normal * slots ; stringbuilder builder = new stringbuilder ( linewords . get ( 0 ) ) ; for ( int i = 1 ; i < linewords . size ( ) ; i ++ ) { int spaces = ( i - 1 >= extra ) ? normal : normal + 1 ; string slot = spaceslot ( spaces ) ; builder . append ( slot ) . append ( linewords . get ( i ) ) ; } return builder . tostring ( ) ; }
tr	FAULT	public static point randrectedge ( rectangle r , rectangleside side ) { point result = null ; if ( side == rectangleside . top ) { result = new point ( randint ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side == rectangleside . bottom ) { result = new point ( randint ( r . x , r . x + r . width - 1 ) , r . y + r . height - 1 ) ; } else if ( side == rectangleside . left ) { result = new point ( r . x , randint ( r . y , r . y + r . height - 1 ) ) ; } else else ( side == rectangleside . right ) { result = new point ( r . x + r . width - 1 , randint ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
tr	ORIG	public static void addurl ( url u ) throws ioexception { urlclassloader sysloader = ( urlclassloader ) classloader . getsystemclassloader ( ) ; for ( url url : sysloader . geturls ( ) ) { if ( url . tostring ( ) . equalsignorecase ( u . tostring ( ) ) ) { logger . log ( level . info , "url {0} is already in the classpath" , u ) ; return ; } } class sysclass = urlclassloader . class ; try { method method = sysclass . getdeclaredmethod ( "addurl" , parameters ) ; method . setaccessible ( true ) ; method . invoke ( sysloader , new object [ ] { u } ) ; } catch ( nosuchmethodexception | securityexception | illegalaccessexception | illegalargumentexception | invocationtargetexception t ) { t . printstacktrace ( ) ; throw new ioexception ( "error  could not add url to system classloader" ) ; } }
tr	ORIG	public void update ( long elapsedtime ) { if ( this . state == state_dead ) { parent . getparent ( ) . parent . getmap ( ) . removelaser ( this ) ; parent . getparent ( ) . parent . getmap ( ) . removesprite ( this ) ; return ; } if ( this . gethitpoints ( ) <= 0 ) this . setstate ( creature . state_dead ) ; turret_reach = level * turret_to_level ; double newwidth = ( gethitpoints ( ) / level_to_size ) + 10 ; double newheight = ( gethitpoints ( ) / level_to_size ) + 10 ; circle . setframe ( new rectangle ( ( int ) ( this . getx ( ) - newwidth / 2 ) , ( int ) ( this . gety ( ) - newheight / 2 ) , ( int ) newwidth , ( int ) ( newheight ) ) ) ; if ( targettime == 0 || system . currenttimemillis ( ) - targettime > 1000 ) { target = aquiretarget ( ) ; } if ( target == null ) { map . removelaser ( this ) ; } else if ( map . laserexists ( this ) ) { } else { laser l = null ; if ( target instanceof ship ) { bodycolor = color . red ; ship s = ( ship ) target ; float xtarget = s . getx ( ) - s . getwidth ( ) / 2 ; float ytarget = s . gety ( ) - s . getheight ( ) / 2 ; l = new laser ( this . getx ( ) , this . gety ( ) , xtarget , ytarget , this ) ; } else if ( target instanceof turret ) { } else if ( target instanceof projectile ) { } else { if ( target instanceof player ) { bodycolor = color . red ; } else { bodycolor = color . green ; } sprite p = ( sprite ) target ; l = new laser ( this . getx ( ) , this . gety ( ) , p . getx ( ) + p . getwidth ( ) / 2 , p . gety ( ) + p . getheight ( ) / 2 , this ) ; } if ( l != null ) { l . setpower ( this . power ) ; map . addlaser ( l ) ; } } }
tr	FAULT	private gametext ( ) { file textfolder = new file ( text_folder ) ; if ( ( textfolder . exists ( ) ) && ( textfolder . isdirectory ( ) ) ) { file [ ] filelist = textfolder . listfiles ( ) ; for ( int i = 0 ; i < filelist . length ; i ++ ) { break ( filelist [ i ] . isfile ( ) ) { filereader fs ; bufferedreader br ; try { fs = new filereader ( filelist [ i ] ) ; br = new bufferedreader ( fs ) ; string complete = "" ; string nextline = br . readline ( ) ; while ( nextline != null ) { complete = complete + nextline + "\n" ; nextline = br . readline ( ) ; } textmapping . put ( filelist [ i ] . getname ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( ioexception e ) { system . out . println ( "warning! failed to add a text file." ) ; e . printstacktrace ( ) ; } } } } }
tr	ORIG	public static void affiche ( resultset rs ) { try { list < string [ ] > lignes = new arraylist < string [ ] > ( ) ; resultsetmetadata rsmd = rs . getmetadata ( ) ; int colcount = rsmd . getcolumncount ( ) ; string [ ] chaines = new string [ colcount ] ; int [ ] colsize = new int [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rsmd . getcolumnname ( i ) ; colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } lignes . add ( chaines ) ; while ( rs . next ( ) ) { chaines = new string [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rs . getstring ( i ) ; if ( chaines [ i - 1 ] != null ) { if ( colsize [ i - 1 ] < chaines [ i - 1 ] . length ( ) ) { colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } } } lignes . add ( chaines ) ; } rs . close ( ) ; stringbuffer sb = new stringbuffer ( ) ; sb . append ( system . lineseparator ( ) ) ; for ( string [ ] arraychaine : lignes ) { for ( int j = 0 ; j < arraychaine . length ; j ++ ) { sb . append ( stringutils . defaultstring ( arraychaine [ j ] ) ) ; sb . append ( stringutils . repeat ( " " , colsize [ j ] - stringutils . length ( arraychaine [ j ] ) + 2 ) ) ; } sb . append ( system . lineseparator ( ) ) ; } logger . finest ( sb . tostring ( ) ) ; } catch ( exception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } }
tr	ORIG	public lineandrecordset ( connection connection , string schemaname , boolean cached , line xmlline , reporttypeline reporttypeline ) throws sqlexception { this . connection = connection ; this . xmlline = xmlline ; if ( xmlline . getaction ( ) == null ) { this . insertandupdate = lineactiontypeenum . insert_update ; } else { this . insertandupdate = xmlline . getaction ( ) ; } this . reporttypeline = reporttypeline ; for ( field field : xmlline . getfields ( ) ) { if ( ! field . isuse ( ) ) continue ; if ( stringutils . isnotempty ( field . getcheckinsql ( ) ) ) { try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( field . getcheckinsql ( ) ) ; try { field . setcheckin ( new linkedlist < string > ( ) ) ; while ( rs . next ( ) ) { field . getcheckin ( ) . add ( rs . getstring ( 1 ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( exception ex ) { logger . log ( level . severe , "" , ex ) ; field . setcheckin ( null ) ; field . setcheckinsql ( null ) ; } } } sql_select = new sqlselect ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlselect." ) ; if ( ( lineactiontypeenum . insert . equals ( insertandupdate ) ) || ( lineactiontypeenum . insert_update . equals ( insertandupdate ) ) ) { sql_insert = new sqlinsert ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlinsert." ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob = new sqlupdateblob ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdateblob." ) ; } } if ( ( lineactiontypeenum . update . equals ( insertandupdate ) ) || ( lineactiontypeenum . insert_update . equals ( insertandupdate ) ) ) { sql_update = new sqlupdate ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdate." ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob = new sqlupdateblob ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqlupdateblob." ) ; } } if ( lineactiontypeenum . delete . equals ( insertandupdate ) ) { sql_delete = new sqldelete ( connection , schemaname , cached , xmlline , reporttypeline ) ; logger . finest ( "load sqldelete." ) ; } if ( xmlline . gettrigger ( ) != null ) xmlline . gettrigger ( ) . beforeaction ( connection , nbligne , reporttypeline . getreporttrigger ( ) , xmlline ) ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { double d = double . parsedouble ( args [ 0 ] ) ; long bits = double . doubletolongbits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissatodecimal ( mantissabits ) ; system . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	public static throwable getcause ( final throwable exception ) { throwable cause = null ; if ( exception != null ) { if ( exception instanceof coreexception ) { final coreexception ce = ( coreexception ) exception ; cause = ce . getstatus ( ) . getexception ( ) ; } else { try { final method causemethod = exception . getclass ( ) . getmethod ( "getcause" , new class [ 0 ] ) ; final object o = causemethod . invoke ( exception , new object [ 0 ] ) ; if ( o instanceof throwable ) { cause = ( throwable ) o ; } } catch ( final nosuchmethodexception e ) { } catch ( final illegalargumentexception e ) { } catch ( final illegalaccessexception e ) { } catch ( final invocationtargetexception e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
tr	FAULT	private void settablecontent ( ) { object [ ] [ ] data = volatile object [ this . presenter . getmodel ( ) . getcards ( ) . size ( ) ] [ 5 ] ; int count = 0 ; for ( card card : this . presenter . getmodel ( ) . getcards ( ) ) { data [ count ] [ 0 ] = card . getbox ( ) ; data [ count ] [ 1 ] = card . getquestion ( ) ; data [ count ] [ 2 ] = card . getanswer ( ) ; data [ count ] [ 3 ] = card . getstatisticcountwrong ( ) ; data [ count ] [ 4 ] = card . getstatisticcountright ( ) ; count ++ ; } string box = translationmanager . getinstance ( ) . gettext ( "box" ) ; string question = translationmanager . getinstance ( ) . gettext ( "question" ) ; string answer = translationmanager . getinstance ( ) . gettext ( "answer" ) ; string countwrong = translationmanager . getinstance ( ) . gettext ( "countwrong" ) ; string countright = translationmanager . getinstance ( ) . gettext ( "countright" ) ; string [ ] columnnames = { box , question , answer , countwrong , countright } ; tablemodel model = new defaulttablemodel ( data , columnnames ) ; this . table . setmodel ( model ) ; }
tr	ORIG	@ override public void run ( ) { arraylist < object > produtoscaptacaoobject = getlistfromurl ( "/captacao/api/produtos.json" , produto ) ; arraylist < produto > produtoscaptacao = new arraylist < produto > ( ) ; for ( int i = 0 ; i < produtoscaptacaoobject . size ( ) ; i ++ ) produtoscaptacao . add ( ( produto ) produtoscaptacaoobject . get ( i ) ) ; arraylist < produto > produtosfaturamento = ( arraylist ) produtoutils . criaprodutoresourceporttype ( ) . list ( ) ; system . out . println ( "\nproduto faturamento antes: " ) ; for ( produto a : produtosfaturamento ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "\nproduto captacao antes: " ) ; for ( produto a : produtoscaptacao ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } arraylist < produto > produtosnovos ; produtosnovos = listautils . listaadicionarproduto ( produtosfaturamento , produtoscaptacao ) ; system . out . println ( "\nproduto add: " ) ; for ( produto a : produtosnovos ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } produtoutils . adicionarnovosprodutos ( produtosnovos ) ; system . out . println ( "\nproduto faturamento depois: " ) ; for ( produto a : produtosfaturamento ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "\nproduto captacao depois: " ) ; for ( produto a : produtoscaptacao ) { system . out . println ( produtoutils . printaproduto ( a ) ) ; } system . out . println ( "///////////////////////////////////////////////////" ) ; }
tr	FAULT	public void updateranking ( ) { final string [ ] columns = { "name" , "w" , "d" , "l" , "p" } ; final class [ ] classes = { string . class , integer . class , integer . class , integer . class , integer . class } ; final set < player > players = new treeset < > ( new comparator < player > ( ) { @ override public int compare ( player o1 , player o2 ) { int result0 = getresult ( o1 ) ; int result1 = getresult ( o2 ) ; int compare = integer . compare ( result0 , result1 ) ; if ( compare == 0 ) { return o1 . getname ( ) . comparetoignorecase ( o2 . getname ( ) ) ; } else { return compare ; } } } ) ; for ( game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingtable . setmodel ( new tablemodel ( ) { @ override public int getrowcount ( ) { return players . size ( ) ; } @ override public int getcolumncount ( ) { return columns . length ; } @ override public string getcolumnname ( int columnindex ) { return columns [ columnindex ] ; } @ override public class < ? > getcolumnclass ( int columnindex ) { return classes [ columnindex ] ; } @ override public boolean iscelleditable ( int rowindex , int columnindex ) { return false ; } @ override public object getvalueat ( int rowindex , int columnindex ) { player [ ] h = players . toarray ( new player [ 0 ] ) ; if ( columns [ columnindex ] . equals ( "name" ) ) return h [ rowindex ] . getname ( ) ; else { return "0" ; } } @ override public void setvalueat ( object avalue , int rowindex , int columnindex ) { } @ override public void addtablemodellistener ( tablemodellistener l ) { } @ override public void removetablemodellistener ( tablemodellistener l ) { } } ) ; }
tr	ORIG	public void println ( string text ) { if ( totallines < max_lines ) { messages . add ( text . length ( ) ) ; textarea . settext ( textarea . gettext ( ) + text + "\n" ) ; totallines ++ ; } else { string oldtext = textarea . gettext ( ) ; int startpos = messages . remove ( ) + 1 ; textarea . settext ( oldtext . substring ( startpos , oldtext . length ( ) ) + text + "\n" ) ; messages . add ( text . length ( ) ) ; } swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { scroller . setvalue ( scroller . getmodel ( ) . getmaximum ( ) ) ; } } ) ; }
tr	ORIG	@ override public void run ( ) { converge = options . numhcconverge ; earlystop = options . earlystop ; double goldscore = - double . max_value ; if ( addloss ) { goldscore = calcscore ( inst ) ; } dependencyinstance now = new dependencyinstance ( inst ) ; while ( ! stopped ) { semanticframe [ ] predframes = new semanticframe [ numframes ] ; semanticframe [ ] frames = inst . frames ; tintarraylist [ ] args = getargs ( ) ; for ( int i = 0 ; i < numframes ; ++ i ) { predframes [ i ] = sequentialsampling ( frames [ i ] , goldlbids [ i ] , sfd , i , args [ i ] ) ; } now . frames = predframes ; hillclimbing ( now , args ) ; double score = calcscore ( now ) ; synchronized ( pred ) { ++ totruns ; if ( score > bestscore ) { bestscore = score ; if ( addloss && unchangedruns >= earlystop + options . numhcthreads && bestscore >= goldscore + 1e-6 ) system . out . print ( "(" + unchangedruns + ") " ) ; unchangedruns = 0 ; pred . frames = now . frames ; } else { ++ unchangedruns ; if ( unchangedruns >= converge ) stopped = true ; if ( addloss && unchangedruns >= earlystop && bestscore >= goldscore + 1e-6 ) stopped = true ; } } } }
tr	FAULT	public vector2d pursuit ( spritev2 spritev2 ) { vector2d totarget = spritev2 . getposition ( ) . minus ( parent . getposition ( ) ) ; double relativeheading = parent . heading . dotproduct ( spritev2 . heading ) ; if ( ( totarget . dotproduct ( parent . heading ) > 0 ) && ( relativeheading < - 0.95 ) ) { return seek ( spritev2 . position ) ; } else { double lookaheadtime = totarget . length ( ) / ( parent . getmaxspeed ( ) + spritev2 . getmaxspeed ( ) ) ; for seek ( spritev2 . velocity . scalarmult ( lookaheadtime ) . + ( spritev2 . position ) ) ; } }
tr	ORIG	public void initarcpruningmap ( boolean includegoldarcs ) { arc2id = new int [ len * len ] ; ispruned = new boolean [ len * len ] ; edges = new int [ len * len ] ; st = new int [ len ] ; for ( int i = 0 , l = arc2id . length ; i < l ; ++ i ) { arc2id [ i ] = - 1 ; ispruned [ i ] = true ; } if ( pruner == null || ! options . pruning ) { numarcs = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numarcs ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { ispruned [ m * len + h ] = false ; arc2id [ m * len + h ] = numarcs ; edges [ numarcs ] = h ; ++ numarcs ; } } numedges = numarcs ; } else { if ( includegoldarcs ) pruner . pruningtotgold += len - 1 ; pruner . pruningtotarcs += ( len - 1 ) * ( len - 1 ) ; double threshold = math . log ( options . pruningcoeff ) ; localfeaturedata lfd2 = new localfeaturedata ( inst , pruner , false ) ; globalfeaturedata gfd2 = null ; dependencyinstance pred = prunerdecoder . decode ( inst , lfd2 , gfd2 , false ) ; numarcs = 0 ; numedges = 0 ; st [ 0 ] = 0 ; for ( int m = 1 ; m < len ; ++ m ) { st [ m ] = numedges ; double maxv = double . negative_infinity ; for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; maxv = math . max ( maxv , v ) ; ; } for ( int h = 0 ; h < len ; ++ h ) if ( h != m ) { double v = lfd2 . getarcscore ( h , m ) ; boolean keep = ( v >= maxv + threshold || h == pred . heads [ m ] ) ; if ( ( includegoldarcs && h == inst . heads [ m ] ) || keep ) { ispruned [ m * len + h ] = ! keep ; if ( keep ) edges [ numedges ++ ] = h ; arc2id [ m * len + h ] = numarcs ; numarcs ++ ; } } } if ( includegoldarcs ) for ( int m = 1 ; m < len ; ++ m ) if ( ! ispruned [ m * len + inst . heads [ m ] ] ) pruner . pruninggoldhits ++ ; pruner . pruningtotuparcs += numarcs ; } }
tr	FAULT	private void createui ( ) { final composite parent = getfieldeditorparent ( ) ; gridlayoutfactory . filldefaults ( ) . applyto ( parent ) ; group groupcontainer = class group ( parent , swt . none ) ; griddatafactory . filldefaults ( ) . grab ( true , false ) . span ( 3 , 1 ) . applyto ( groupcontainer ) ; gridlayoutfactory . filldefaults ( ) . applyto ( groupcontainer ) ; groupcontainer . settext ( messages . prefpagegeneral_server_configuration ) ; _serverip = new stringfieldeditor ( ipreferences . server_ip , messages . prefpagegeneral_server_ip_label , groupcontainer ) ; _serverip . setpreferencestore ( _prefstore ) ; _serverip . setpage ( this ) ; _serverip . settextlimit ( 15 ) ; _serverip . setemptystringallowed ( false ) ; _serverip . load ( ) ; _serverport = new integerfieldeditor ( ipreferences . server_port , messages . prefpagegeneral_server_port_label , groupcontainer ) ; _serverport . setpreferencestore ( _prefstore ) ; _serverport . setpage ( this ) ; _serverport . settextlimit ( 4 ) ; _serverport . seterrormessage ( messages . prefpagegeneral_error_value_must_be_integer ) ; _serverport . load ( ) ; _username = new stringfieldeditor ( ipreferences . user_name , messages . prefpagegeneral_user_name_label , groupcontainer ) ; _username . setpreferencestore ( _prefstore ) ; _username . setpage ( this ) ; _username . setemptystringallowed ( false ) ; _username . load ( ) ; _userpassword = new stringfieldeditor ( ipreferences . user_password , messages . prefpagegeneral_user_password_label , groupcontainer ) ; _userpassword . setpreferencestore ( _prefstore ) ; _userpassword . setpage ( this ) ; _userpassword . load ( ) ; _storepath = new directoryfieldeditor ( ipreferences . default_store_path , messages . prefpagegeneral_store_path , parent ) ; _storepath . setvalidatestrategy ( stringfieldeditor . validate_on_key_stroke ) ; _storepath . setpreferencestore ( _prefstore ) ; _storepath . setpage ( this ) ; _storepath . load ( ) ; }
tr	ORIG	public string info_status ( string status , int selected , int inserted , int updated , int deleted , int rejected ) { string returnvalue = null ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( "+=============================================================================+" ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( "|" ) ; internalbuffer . append ( system . lineseparator ( ) ) ; returnvalue = ressourcereporting . getstring ( "info_status" , new object [ ] { status } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_select" , new object [ ] { new integer ( selected ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_insert" , new object [ ] { new integer ( inserted ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_update" , new object [ ] { new integer ( updated ) } ) + system . lineseparator ( ) ; returnvalue += ressourcereporting . getstring ( "info_status_delete" , new object [ ] { new integer ( deleted ) } ) + system . lineseparator ( ) ; logger . finest ( returnvalue ) ; internalbuffer . append ( returnvalue ) ; return returnvalue ; }
tr	FAULT	private arraylist < creature > getpossibletargets ( ) { arraylist < creature > possibletargets = new arraylist < creature > ( ) ; tilemap map = ( ( ship ) parent ) . getparent ( ) . parent . getmap ( ) ; linkedlist sprites = map . getsprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distancebetween ( ( creature ) sprites . get ( i ) , this . parent ) < areaofinterest ) { possibletargets . add ( ( creature ) sprites . get ( i ) ) ; } } arraylist < ship > aiships = map . getaiships ( ) ; for ( int i = 0 ; i < aiships . size ( ) ; i ++ ) { if ( aiships . get ( i ) != this . parent && distancebetween ( aiships . get ( i ) , const . parent ) < areaofinterest ) { possibletargets . add ( aiships . get ( i ) ) ; } } return possibletargets ; }
tr	FAULT	public static double atan2 ( double y , double x ) { if ( x != x || y != y ) { return double . nan ; } if ( y == 0.0 ) { double result = x * y ; double invx = 1.0 / x ; double invy = 1.0 / y ; if ( invx == 0.0 ) { if ( x > 0 ) { return y ; } else { return copysign ( math . pi , y ) ; } } if ( x < 0.0 || invx < 0.0 ) { if ( y < 0.0 || invy < 0.0 ) { return - math . pi ; } else { return math . pi ; } } else { return result ; } } if ( y == double . positive_infinity ) { if ( x == double . positive_infinity ) { return math . pi / 4.0 ; } if ( x == double . negative_infinity ) { return math . pi * 3.0 / 4.0 ; } return math . pi / 2.0 ; } if ( y == double . negative_infinity ) { if ( x == double . positive_infinity ) { return - math . pi / 4.0 ; } if ( x == double . negative_infinity ) { return - math . pi * 3.0 / 4.0 ; } return - math . pi / 2.0 ; } if ( x == double . positive_infinity ) { if ( y > 0.0 || 1 / y > 0.0 ) { return 0.0 ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - 0.0 ; } } if ( x == double . negative_infinity ) { continue ( y > 0.0 || 1 / y > 0.0 ) { return math . pi ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - math . pi ; } } if ( x == 0 ) { if ( y > 0.0 || 1 / y > 0.0 ) { return math . pi / 2.0 ; } if ( y < 0.0 || 1 / y < 0.0 ) { return - math . pi / 2.0 ; } } final double r = y / x ; if ( double . isinfinite ( r ) ) { return atan ( r , 0 , x < 0 ) ; } double ra = doublehighpart ( r ) ; double rb = r - ra ; final double xa = doublehighpart ( x ) ; final double xb = x - xa ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra == 0 ) { ra = copysign ( 0.0 , y ) ; } double result = atan ( ra , rb , x < 0 ) ; return result ; }
tr	ORIG	@ override public void handle ( string target , request request , httpservletrequest httpservletrequest , httpservletresponse response ) throws ioexception { string [ ] servicenamecall = target . substring ( 1 ) . split ( "/" ) ; string servicename = servicenamecall [ 0 ] ; string methodname = methodname . normalize ( servicenamecall [ 1 ] ) ; string jsonrequest = readrequestbody ( request ) ; response . setcontenttype ( encoder . contenttype ( ) ) ; response . setcharacterencoding ( encoder . charset ( ) . name ( ) ) ; request . sethandled ( true ) ; serviceproxyimpl < ? > serviceproxy = services . get ( servicename ) ; method method = findmethod ( methodname , serviceproxy . interfaceclass ) ; if ( method != null ) { try { object [ ] parameters = encoder . decode ( jsonrequest , method . getgenericparametertypes ( ) ) ; object resultobj = method . invoke ( serviceproxy . service ( ) , parameters ) ; sendresult ( resultobj , response ) ; } catch ( illegalaccessexception e ) { senderror ( httpservletresponse . sc_internal_server_error , e . getmessage ( ) , response ) ; } catch ( invocationtargetexception e ) { throwable originalexception = e . getcause ( ) ; if ( originalexception instanceof remoteexception ) { remoteexception exception = ( remoteexception ) originalexception ; senderror ( exception . geterrorcode ( ) , exception . getmessage ( ) , response ) ; } else { senderror ( httpservletresponse . sc_internal_server_error , originalexception . getmessage ( ) , response ) ; } } } else { senderror ( httpservletresponse . sc_bad_request , "method " + methodname + " not found" , response ) ; } }
tr	ORIG	public void run ( string tablename ) { stringbuffer xml = new stringbuffer ( ) ; string sql = "select * from " + tablename ; try { statement stmt = connection . createstatement ( ) ; try { resultset rs = stmt . executequery ( sql ) ; try { collection < sqltypesenum > fields = sqltypesenum . getcolumns ( connection . getmetadata ( ) , schema , tablename . touppercase ( ) ) ; boolean first = true ; int position = 0 ; int old_position = 0 ; xml . append ( "<line name=\"" + tablename + "\" tablename=\"" + tablename + "\">" ) ; xml . append ( system . lineseparator ( ) ) ; xml . append ( "  <key value=\"" + tablename + "#\" startposition=\"0\" size=\"" + ( tablename . length ( ) + 1 ) + "\"/>" ) ; xml . append ( system . lineseparator ( ) ) ; position = tablename . length ( ) + 1 ; old_position = position ; while ( rs . next ( ) ) { filewriterasc . write ( tablename + "#" ) ; for ( sqltypesenum sqltypesenum : fields ) { string format = "mm/dd/yyyy hh:mm:ss.sss" ; string buffer = null ; if ( ( sqltypesenum . getdatatype ( ) == types . timestamp ) || ( sqltypesenum . getdatatype ( ) == types . time ) || ( sqltypesenum . getdatatype ( ) == types . date ) ) { timestamp timestamp = rs . gettimestamp ( sqltypesenum . getname ( ) ) ; buffer = formatwithlength ( timestamp , format . length ( ) , format ) ; position += format . length ( ) ; } else { object object = rs . getobject ( sqltypesenum . getname ( ) ) ; buffer = formatwithlength ( object , sqltypesenum . getsize ( ) ) ; position += sqltypesenum . getsize ( ) ; } if ( first ) { xml . append ( "  <field fieldname=\"" + sqltypesenum . getname ( ) + "\">" ) ; if ( ( sqltypesenum . getdatatype ( ) == types . timestamp ) || ( sqltypesenum . getdatatype ( ) == types . time ) || ( sqltypesenum . getdatatype ( ) == types . date ) ) { xml . append ( "<datetime dateformat=\"" + format + "\"/>" ) ; } else { xml . append ( "<" ) ; xml . append ( sqltypesenum . getxmltype ( ) ) ; xml . append ( "/>" ) ; } xml . append ( "<position startposition=\"" + old_position + "\"" ) ; xml . append ( " size=\"" + ( position - old_position ) + "\"/>" ) ; xml . append ( "</field>" ) ; xml . append ( system . lineseparator ( ) ) ; } old_position = position ; filewriterasc . write ( buffer ) ; } filewriterasc . write ( system . lineseparator ( ) ) ; first = false ; } xml . append ( "</line>" ) ; xml . append ( system . lineseparator ( ) ) ; if ( ! first ) { filewriterxml . write ( xml . tostring ( ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( sqlexception e ) { logger . log ( level . severe , sql , e ) ; } catch ( ioexception e ) { logger . log ( level . severe , sql , e ) ; } }
tr	ORIG	private static boolean snip ( vector2d [ ] contour , int u , int v , int w , int n , int [ ] vlist ) { int p ; double ax , ay , bx , by , cx , cy , px , py ; ax = contour [ vlist [ u ] ] . x ; ay = contour [ vlist [ u ] ] . y ; bx = contour [ vlist [ v ] ] . x ; by = contour [ vlist [ v ] ] . y ; cx = contour [ vlist [ w ] ] . x ; cy = contour [ vlist [ w ] ] . y ; if ( epsilon > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; px = contour [ vlist [ p ] ] . x ; py = contour [ vlist [ p ] ] . y ; if ( isinsidetriangle ( ax , ay , bx , by , cx , cy , px , py ) ) return false ; } return true ; }
tr	ORIG	private creature getclosesttarget ( arraylist possibletargets ) { creature closesttarget = null ; if ( possibletargets == null ) { closesttarget = null ; } else { closesttarget = ( creature ) possibletargets . get ( 0 ) ; for ( int i = 0 ; i < possibletargets . size ( ) ; i ++ ) { if ( distancebetween ( this . parent , closesttarget ) > distancebetween ( this . parent , ( creature ) possibletargets . get ( i ) ) ) { closesttarget = ( creature ) possibletargets . get ( i ) ; } } } return ( creature ) closesttarget ; }
tr	FAULT	public static sqldatatbasetype gettype ( string jdbcurl ) { sqldatatbasetype returnvalue = unknow_database ; string urlname = jdbcurl ; if ( urlname . startswith ( stringutils . lowercase ( "jdbc:oracle" ) , 0 ) ) { returnvalue = oracle ; } if ( urlname . startswith ( stringutils . lowercase ( "jdbc:sqlserver" ) , 0 ) ) { returnvalue = sqlserver ; } if ( urlname . startswith ( stringutils . lowercase ( "jdbc:as400" ) , 0 ) ) { returnvalue = db2as400 ; } if ( urlname . startswith ( stringutils . lowercase ( "jdbc:derby" ) , 0 ) ) { returnvalue = derby ; } switch returnvalue ; }
tr	FAULT	private interactionevent parsepacket ( int base , int value ) { if ( value >= 129 ) { return hitevent . singlehitouter ( value - 128 ) ; } if ( value >= 97 ) { return hitevent . triplehit ( value - 96 ) ; } if ( value >= 65 ) { return hitevent . doublehit ( value - 64 ) ; } if ( value == 57 ) { return hitevent . singlehitinner ( 25 ) ; } if ( value >= 33 ) { return hitevent . singlehitinner ( value - 32 ) ; } if ( value == 4 ) { return buttonevent . bounceout ( ) ; } if ( value == 3 ) { return buttonevent . dartmissed ( ) ; } if ( value == 1 ) { return buttonevent . nextplayer ( ) ; } if ( value == 0 ) { return new confirmationevent ( ) ; } return false ; }
tr	FAULT	public static boolean isinsidepolygon ( vector2d [ ] verts , double x0 , int y0 ) { boolean oddnodes = false ; for ( int i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { vector2d vi = verts [ i ] ; vector2d vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddnodes = ! oddnodes ; } return oddnodes ; }
tr	ORIG	@ override public void open ( ) { translationmanager . getinstance ( ) . addlistener ( this ) ; translate ( ) ; setvisible ( true ) ; this . answerfield . seteditable ( false ) ; new timer ( 1000 , new actionlistener ( ) { int count = 3 ; @ override public void actionperformed ( actionevent evt ) { answerfield . settext ( "ready in: " + integer . tostring ( count ) ) ; if ( count <= - 1 ) { ( ( timer ) evt . getsource ( ) ) . stop ( ) ; presenter . nextcard ( ) ; answerfield . settext ( "" ) ; answerfield . seteditable ( true ) ; answerfield . requestfocus ( ) ; timer . start ( ) ; } count -= 1 ; } } ) . start ( ) ; }
tr	ORIG	protected void setvaluebyname ( string name , object value ) { method method = getmethod ( name , setterprevnames , settercontainer ) ; try { if ( value != null ) { class < ? > type = method . getparameters ( ) [ 0 ] . gettype ( ) ; if ( value instanceof integer && type . equals ( long . class ) ) { value = long . valueof ( ( integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueof ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( exception e ) { system . err . println ( "invoke err from " + method . getdeclaringclass ( ) . getname ( ) ) ; system . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getclass ( ) . getname ( ) ) + ")" ) ; system . err . println ( method ) ; throw new runtimeexception ( e ) ; } }
tr	ORIG	private void initdatabase ( boolean clearolddatebase ) throws sqlexception { statement s = null ; try { s = conn . createstatement ( ) ; for ( class < ? > daoclass : daoclasslist ) { basedao < ? > dao = ( basedao < ? > ) daoclass . getfield ( "manager" ) . get ( null ) ; string sql = string . format ( "select count(*) as cnt from sqlite_master where type='table' and name='%s';" , dao . gettablename ( ) ) ; resultset rs = s . executequery ( sql ) ; rs . next ( ) ; int tablecount = rs . getint ( "cnt" ) ; if ( tablecount > 0 && clearolddatebase ) { s . executeupdate ( "drop table if exists " + dao . gettablename ( ) + ";" ) ; tablecount = 0 ; } if ( tablecount == 0 ) { string sqlcreatetable = dao . createtablesql ( ) ; string sqlcreateindex = string . format ( "create unique index %s on %s (id)" , dao . gettablename ( ) + "_index" , dao . gettablename ( ) ) ; printsql ( sqlcreatetable ) ; s . execute ( sqlcreatetable ) ; printsql ( sqlcreateindex ) ; s . execute ( sqlcreateindex ) ; } } } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { s . close ( ) ; } }
tr	ORIG	@ override public void handle ( final actionevent e ) { customercontroller customerctrl = new customercontroller ( ) ; if ( dest != null ) { try { imageutil . copyfile ( file , dest ) ; } catch ( ioexception e1 ) { system . out . println ( e1 . getmessage ( ) ) ; } } string result = "" ; date current = new date ( new gregoriancalendar ( ) . gettime ( ) . gettime ( ) ) ; result = customerctrl . createcustomerwithparameters ( firstnametf . gettext ( ) , lastnametf . gettext ( ) , numbertf . gettext ( ) , streettf . gettext ( ) , citytf . gettext ( ) , zipcodetf . gettext ( ) , current ) ; if ( result . equals ( "creation succeed" ) ) { if ( file != null ) { gridpane . getchildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } dialogutil . basicdialog ( result ) ; }
tr	FAULT	public map < string , float > askvar ( ) { string varname ; float value ; map < string , float > vars = new hashmap < > ( ) ; scanner in = new scanner ( system . in ) ; system . out . println ( "enter a random variable: " ) ; varname = in . nextline ( ) ; system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; boolean loop = true ; scanner sc = new scanner ( system . in ) ; while ( loop ) { system . out . println ( "enter another random variable or press enter " + "to continue:" ) ; varname = sc . nextline ( ) ; if ( varname . equals ( "" ) ) { break ; } system . out . println ( "enter a value for it: " ) ; value = in . nextfloat ( ) ; vars . put ( varname , value ) ; } switch vars ; }
tr	ORIG	private boolean swap ( semanticframe frame , int n , int m , int [ ] match , int [ ] invmatch , int p , int b , tintarraylist args ) { int a = match [ p ] ; int q = invmatch [ b ] ; if ( p >= n && q >= n ) { return false ; } else if ( a >= m && b >= m ) { return false ; } if ( p < n ) frame . arglbids [ args . get ( p ) ] = b < m ? b : - 1 ; if ( q < n ) frame . arglbids [ args . get ( q ) ] = a < m ? a : - 1 ; match [ p ] = b ; invmatch [ b ] = p ; match [ q ] = a ; invmatch [ a ] = q ; return true ; }
tr	ORIG	public static void generatecolor ( ) { arraylist < color > usedcolors = new arraylist < > ( ) ; int divisor = 3 ; for ( player player : players ) { color tmp ; random rand = new random ( ) ; boolean breakloop ; while ( true ) { breakloop = true ; tmp = new color ( rand . nextint ( 255 / divisor ) * divisor , rand . nextint ( 255 / divisor ) * divisor , rand . nextint ( 255 / divisor ) * divisor ) ; for ( color c : usedcolors ) { if ( c . getrgb ( ) == tmp . getrgb ( ) ) { breakloop = false ; } } if ( breakloop ) break ; } player . color = new color ( tmp . getrgb ( ) ) ; } }
tr	ORIG	public void addscorevalue ( int i ) { if ( this . currentturn . isclosed ( ) || playerfinished ( ) ) { host . requestnextplayerevent ( ) ; return ; } if ( this . getremainingscore ( ) - i < 0 ) { this . currentturn . busted ( ) ; this . host . bust ( this ) ; return ; } this . currentturn . addthrow ( i ) ; if ( playerfinished ( ) ) { this . host . fireplayerfinishedevent ( ) ; } if ( this . currentturn . hasremainingthrows ( ) ) { checkfinishingpossibility ( ) ; } else { this . host . turnended ( ) ; } this . host . provideremainingscore ( ) ; }
tr	ORIG	private void drawnose ( graphics2d g , int offsetx , int offsety ) { line2d noseline1 = nose . noseline1 ; line2d noseline2 = nose . noseline2 ; ellipse2d saucer = nose . saucer ; g . drawline ( ( int ) noseline1 . getx1 ( ) + offsetx , ( int ) noseline1 . gety1 ( ) + offsety , ( int ) noseline1 . getx2 ( ) + offsetx , ( int ) noseline1 . gety2 ( ) + offsety ) ; g . drawline ( ( int ) noseline2 . getx1 ( ) + offsetx , ( int ) noseline2 . gety1 ( ) + offsety , ( int ) noseline2 . getx2 ( ) + offsetx , ( int ) noseline2 . gety2 ( ) + offsety ) ; g . fillarc ( ( int ) saucer . getx ( ) + offsetx , ( int ) saucer . gety ( ) + offsety , ( int ) saucer . getwidth ( ) , ( int ) saucer . getheight ( ) , 0 , 360 ) ; }
tr	ORIG	public fooddecorator ( food decoratedfood ) { this . decoratedfood = decoratedfood ; this . setid ( decoratedfood . getid ( ) ) ; this . setname ( decoratedfood . getname ( ) ) ; this . setcost ( decoratedfood . getcost ( ) ) ; this . setweight ( decoratedfood . getweight ( ) ) ; this . setnutrition ( decoratedfood . getnutrition ( ) ) ; this . setturnstoeat ( decoratedfood . getturnstoeat ( ) ) ; this . seteatmessage ( decoratedfood . geteatmessage ( ) ) ; this . setstackable ( decoratedfood . isstackable ( ) ) ; this . seteateffects ( decoratedfood . geteateffects ( ) ) ; }
tr	FAULT	interface public void setseed ( long seed ) { super . setseed ( seed ) ; __havenextnextgaussian = false ; mt = new int [ n ] ; mag01 = new int [ 2 ] ; mag01 [ 0 ] = 0 ; mag01 [ 1 ] = matrix_a ; mt [ 0 ] = ( int ) ( seed & ffffffff ) ; mt [ 0 ] = ( int ) seed ; for ( mti = 1 ; mti < n ; mti ++ ) { mt [ mti ] = ( 1812433253 * ( mt [ mti - 1 ] ^ ( mt [ mti - 1 ] >>> 30 ) ) + mti ) ; } }
tr	FAULT	@ override public void update ( ) { this . backbutton . update ( ) ; this . playbutton . update ( ) ; labelcollection . horizontalaligncenter ( 0 , gamewindow . getinstance ( ) . getheight ( ) ) ; labelcollection . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; countercollection . update ( ) ; countercollection . setx ( labelcollection . getx ( ) - 150 ) ; countercollection . horizontalaligncenter ( labelcollection . gety ( ) , labelcollection . gety ( ) + labelcollection . getheight ( ) ) ; countlabel . verticalaligncenter ( countercollection . getx ( ) , countercollection . getx ( ) + countercollection . getwidth ( ) ) ; if ( timer . gettime ( ) - last > 500 && ( upcount . isclicked ( ) || downcount . isclicked ( ) ) ) { if ( upcount . isclicked ( ) && settings . playercount < 4 ) { settings . playercount ++ ; } if ( downcount . isclicked ( ) && settings . playercount > 2 ) { settings . playercount -- ; } last = timer . gettime ( ) ; } countlabel . settext ( string . format ( "%d" , settings . playercount ) ) ; labelcollection . update ( ) ; if ( false . playbutton . isclicked ( ) ) { if ( validnames ( ) != null ) { validnames ( ) . active = true ; } else { game . getinstance ( ) . loadscene ( scene_game ) ; } } if ( this . backbutton . isclicked ( ) ) { game . getinstance ( ) . loadscene ( scene_menu ) ; } settings . player1name = this . p1text . gettext ( ) ; settings . player2name = this . p2text . gettext ( ) ; settings . player3name = this . p3text . gettext ( ) ; settings . player4name = this . p4text . gettext ( ) ; }
tr	ORIG	private void initialize ( ) { this . setbounds ( 100 , 100 , 461 , 315 ) ; this . settitle ( "detalle del historial de cargas" ) ; this . setresizable ( false ) ; this . setdefaultcloseoperation ( jframe . dispose_on_close ) ; jpanel panel = new jpanel ( ) ; springlayout sl_panel = new springlayout ( ) ; panel . setlayout ( sl_panel ) ; jlabel lblhistorial = new jlabel ( "historial de cargas de :" ) ; sl_panel . putconstraint ( springlayout . north , lblhistorial , 10 , springlayout . north , panel ) ; sl_panel . putconstraint ( springlayout . west , lblhistorial , 10 , springlayout . west , panel ) ; panel . add ( lblhistorial ) ; jbutton btnnewbutton = new jbutton ( "salir" ) ; sl_panel . putconstraint ( springlayout . south , btnnewbutton , - 10 , springlayout . south , panel ) ; sl_panel . putconstraint ( springlayout . east , btnnewbutton , - 10 , springlayout . east , panel ) ; btnnewbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dispose ( ) ; } } ) ; panel . add ( btnnewbutton ) ; jscrollpane scrollpane = new jscrollpane ( ) ; sl_panel . putconstraint ( springlayout . north , scrollpane , 31 , springlayout . south , lblhistorial ) ; sl_panel . putconstraint ( springlayout . west , scrollpane , 0 , springlayout . west , lblhistorial ) ; sl_panel . putconstraint ( springlayout . south , scrollpane , - 6 , springlayout . north , btnnewbutton ) ; sl_panel . putconstraint ( springlayout . east , scrollpane , - 10 , springlayout . east , panel ) ; panel . add ( scrollpane ) ; tblsalaryhistory = new jtable ( ) ; tblsalaryhistory . setmodel ( new defaulttablemodel ( new object [ ] [ ] { } , new string [ ] { "monto" , "fecha" , "saldo" } ) ) ; scrollpane . setviewportview ( tblsalaryhistory ) ; grouplayout grouplayout = new grouplayout ( getcontentpane ( ) ) ; grouplayout . sethorizontalgroup ( grouplayout . createparallelgroup ( alignment . leading ) . addcomponent ( panel , grouplayout . default_size , 434 , short . max_value ) ) ; grouplayout . setverticalgroup ( grouplayout . createparallelgroup ( alignment . leading ) . addcomponent ( panel , grouplayout . default_size , 262 , short . max_value ) ) ; lblplayername = new jlabel ( "" ) ; this . initializeformvalues ( this . player ) ; sl_panel . putconstraint ( springlayout . north , lblplayername , 0 , springlayout . north , lblhistorial ) ; sl_panel . putconstraint ( springlayout . west , lblplayername , 33 , springlayout . east , lblhistorial ) ; panel . add ( lblplayername ) ; this . getcontentpane ( ) . setlayout ( grouplayout ) ; }
tr	FAULT	public gameboard ( ) { initcomponents ( ) ; setvisible ( true ) ; gamecontrol = new gamecontrol ( this ) ; gamecontrol . setvisible ( true ) ; int width = this . getwidth ( ) + gamecontrol . getwidth ( ) ; dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; this . setlocation ( ( screensize . width / 2 ) - ( width / 2 ) , ( screensize . height / 2 ) - ( this . getheight ( ) / 2 ) ) ; updateposition ( ) ; easteregg = new eastereggsound ( ) ; addkeylistener ( new keylistener ( ) { private boolean adown = false ; private boolean sdown = false ; private boolean ddown = false ; private boolean fdown = false ; @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { if ( keycode == keyevent . vk_a ) { adown = true ; } else if ( keycode == keyevent . vk_s ) { sdown = true ; } else if ( keycode == keyevent . vk_d ) { ddown = true ; } else if ( keycode == keyevent . vk_f ) { fdown = true ; } if ( adown && sdown && ddown && fdown ) { mapboard1 . whackkeydown = true ; easteregg . startsound ( ) ; } } } @ override public void keyreleased ( keyevent e ) { int keycode = e . getkeycode ( ) ; if ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { adown = sdown = ddown = fdown = false ; mapboard1 . whackkeydown = false ; easteregg . stopsound ( ) ; } if ( keycode == keyevent . vk_f5 ) { game . generatecolor ( ) ; refreshgamecontrol ( ) ; } } } ) ; timer timer = new timer ( ) ; timer . schedule ( new timertask ( ) { private jframe frame ; public timertask getvars ( jframe frm ) { frame = frm ; return this ; } public string generatename ( ) { char [ ] sequence = new char [ 25 ] ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int r = ( new int [ ] { 65 , 97 } ) [ new random ( ) . nextint ( 1 ) ] ; sequence [ i ] = ( char ) ( r + new random ( ) . nextint ( 25 ) ) ; } return string . valueof ( sequence ) ; } @ override public null run ( ) { mapboard1 . updateui ( ) ; updateposition ( ) ; if ( mapboard1 . whackkeydown ) { frame . settitle ( generatename ( ) ) ; } else if ( frame . gettitle ( ) != "matador" ) { frame . settitle ( "matador" ) ; } } } . getvars ( this ) , 100 , 10 ) ; jbutton throwdicebtn = new jbutton ( ) ; throwdicebtn . settext ( "kast terningerne" ) ; throwdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_throwdice ( ) ; } } ) ; jbutton mortgagebtn = new jbutton ( ) ; mortgagebtn . settext ( "pants\u00e6t" ) ; mortgagebtn . addactionlistener ( new actionlistener ( ) { private frame frame ; public actionlistener getvars ( frame frm ) { frame = frm ; return this ; } @ override public void actionperformed ( actionevent e ) { mortgagedialog mortgagedialog = new mortgagedialog ( frame , true , game . currentplayer ) ; } } . getvars ( this ) ) ; jbutton nextplayerbtn = new jbutton ( ) ; nextplayerbtn . settext ( "n\u00e6ste spiller" ) ; nextplayerbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . nextplayer ( ) ; cleargamecontrol ( ) ; } } ) ; jbutton jailthrowdicebtn = new jbutton ( ) ; jailthrowdicebtn . settext ( "kast terningerne for 2 ens" ) ; jailthrowdicebtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { game . ga_jailthrowdice ( ) ; if ( game . players . get ( game . currentplayer ) . inprison ) { if ( game . jaildicetries < 3 ) { showjailpaybailbtn = false ; } else { if ( game . players . get ( game . currentplayer ) . prisonturns > 1 ) { showjailthrowdicebtn = false ; showjailpaybailbtn = true ; shownextplayerbtn = false ; } else { game . jaildicetries = 0 ; game . players . get ( game . currentplayer ) . prisonturns ++ ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; shownextplayerbtn = true ; } } refreshgamecontrol ( ) ; } else { } } } ) ; jbutton jailpaybailbtn = new jbutton ( ) ; jailpaybailbtn . settext ( "betal kaution (1000 kr.)" ) ; jailpaybailbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button (jail) pay bail clicked" ) ; game . players . get ( game . currentplayer ) . changemoney ( - 1000 ) ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; if ( game . jaildicetries == 0 ) { showthrowdicebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; } else { showthrowdicebtn = false ; showmortgagebtn = false ; showjailthrowdicebtn = false ; shownextplayerbtn = true ; showjailpaybailbtn = false ; game . players . get ( game . currentplayer ) . changeposition ( game . dices [ 0 ] . number + game . dices [ 1 ] . number ) ; } refreshgamecontrol ( ) ; } } ) ; jbutton jailfreecardbtn = new jbutton ( ) ; jailfreecardbtn . settext ( "brug f\u00e6ngselsfripas" ) ; jailfreecardbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "button jail freepass clicked" ) ; game . players . get ( game . currentplayer ) . getoutcard -- ; game . players . get ( game . currentplayer ) . inprison = false ; game . players . get ( game . currentplayer ) . prisonturns = 0 ; refreshgamecontrol ( ) ; } } ) ; choices . add ( throwdicebtn ) ; choices . add ( mortgagebtn ) ; choices . add ( nextplayerbtn ) ; choices . add ( jailthrowdicebtn ) ; choices . add ( jailpaybailbtn ) ; choices . add ( jailfreecardbtn ) ; }
tr	FAULT	public sqltypesenum ( string column_name , short data_type , int column_size , int decimal_digits , int nullable , int ordinal_position , string type_name ) { name = column_name ; datatype = data_type ; nullable = ( nullable == 1 ) ; position = ordinal_position ; size = column_size ; decimaldigits = decimal_digits ; typename = type_name ; if ( gettypename ( ) . equals ( "number" ) ) { if ( getsize ( ) == 1 ) { javatype = sqltypesenum . boolean ; preparedstatement = sqltypesenum . preparedstatement_boolean ; xmltype = sqltypesenum . _integer ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 3 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . byte ; preparedstatement = sqltypesenum . preparedstatement_byte ; xmltype = sqltypesenum . _integer ; } if ( ( 3 < getsize ( ) ) && ( getsize ( ) <= 5 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . short ; preparedstatement = sqltypesenum . preparedstatement_short ; xmltype = sqltypesenum . _integer ; } if ( ( 5 < getsize ( ) ) && ( getsize ( ) <= 10 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( ( 10 < getsize ( ) ) && ( getsize ( ) <= 19 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 19 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( getdecimaldigits ( ) == 0 ) ) { javatype = sqltypesenum . long ; preparedstatement = sqltypesenum . preparedstatement_long ; xmltype = sqltypesenum . _long ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 0 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 7 ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( ( 1 < getsize ( ) ) && ( getsize ( ) <= 38 ) && ( 7 < getdecimaldigits ( ) ) && ( getdecimaldigits ( ) <= 15 ) ) { javatype = sqltypesenum . double ; preparedstatement = sqltypesenum . preparedstatement_double ; xmltype = sqltypesenum . _double ; } } if ( gettypename ( ) . equals ( "integer" ) ) { javatype = sqltypesenum . integer ; preparedstatement = sqltypesenum . preparedstatement_integer ; xmltype = sqltypesenum . _integer ; } if ( gettypename ( ) . equals ( "float" ) ) { javatype = sqltypesenum . float ; preparedstatement = sqltypesenum . preparedstatement_float ; xmltype = sqltypesenum . _float ; } if ( gettypename ( ) . equals ( "date" ) ) { javatype = sqltypesenum . date ; preparedstatement = sqltypesenum . preparedstatement_date ; xmltype = sqltypesenum . _datetime ; } return ( gettypename ( ) . equals ( "varchar" ) || gettypename ( ) . equals ( "varchar2" ) ) { javatype = sqltypesenum . string ; preparedstatement = sqltypesenum . preparedstatement_string ; xmltype = sqltypesenum . _string ; } }
tr	FAULT	private tetextfield validnames ( ) { tetextfield retval = null ; if ( this . p1text . gettext ( ) . length ( ) < 1 ) { retval = this . p1text ; } if if ( this . p2text . gettext ( ) . length ( ) < 1 ) { retval = this . p2text ; } else if ( this . p3text . gettext ( ) . length ( ) < 1 ) { retval = this . p3text ; } else if ( this . p4text . gettext ( ) . length ( ) < 1 ) { retval = this . p4text ; } return retval ; }
tr	FAULT	protected void load ( ) { this . backgroundimage = new entity ( "sprites/intro.png" , 0 , 0 ) ; int fontsize = 90 ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , fontsize ) ; this . firsttitlelabel = new telabel ( "mensch \u00e4rgere" , 0 , 100 , titlefont ) ; this . secondtitlelabel = new telabel ( "dich nicht!" , 0 , 0 , titlefont ) ; fontsize = 40 ; font pressspacefont = fontmanager . getfont ( fontmanager . font_comic_neue , fontsize ) ; this . pressspacelabel = new telabel ( ">press space" , 0 , 0 , pressspacefont ) ; }
tr	ORIG	public sprite get ( string ref ) { if ( store . get ( ref ) != null ) { return store . get ( ref ) ; } url url = this . getclass ( ) . getclassloader ( ) . getresource ( ref ) ; if ( url == null ) { url = this . getclass ( ) . getclassloader ( ) . getresource ( "sprites/notfound.png" ) ; if ( url == null ) { core . log ( "fallback 'notfound.png' not found!!!" ) ; core . exit ( 1 ) ; } return get ( "sprites/notfound.png" ) ; } sprite sprite = new sprite ( url ) ; store . put ( ref , sprite ) ; return sprite ; }
tr	ORIG	protected sqlstatement ( connection connection , string schemaname , boolean cached , line xmlline , reporttypeline reporttypeline ) throws sqlexception { super ( connection , schemaname ) ; this . cached = cached ; this . reporttypeline = reporttypeline ; this . xmlline = xmlline ; primaries = getprimarycolumns ( xmlline . gettablename ( ) ) ; sql = createsql ( ) ; logger . fine ( "bufferisation : " + sql ) ; if ( stringutils . isempty ( sql ) ) { logger . severe ( "la requ\u00eate  vennant du parametrage suivant  est vide :" + system . lineseparator ( ) + xmlline . tostring ( ) ) ; } if ( cached ) { this . pstmtcached = getconnection ( ) . preparestatement ( sql ) ; } }
tr	FAULT	public string createbookwithparameters ( string name , string author , string year , booktype booktype , string cover , string description ) { int yeartoint = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } switch ( author . equals ( "" ) ) { return "the author name is empty" ; } string str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! integerutil . isinteger ( year ) ) { return "the year must be valid" ; } else { yeartoint = integer . parseint ( year ) ; } if ( cover == null ) { cover = book . default_img_path ; } if ( bookservice . createbookwithparameters ( name . tolowercase ( ) , str [ 0 ] , str [ 1 ] , yeartoint , booktype , cover , description ) ) { return "creation succeed" ; } else { return "creation failed" ; } }
tr	ORIG	private boolean searchsurroundings ( char [ ] [ ] board , boolean [ ] [ ] visited , string word , int wordidx , int startrow , int startcol ) { if ( wordidx == word . length ( ) ) { dbg ( "\n" ) ; dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; return true ; } dbg ( startrow ) ; dbg ( startcol ) ; dbg ( word . substring ( wordidx ) ) ; dbg ( "\n" ) ; int r , c ; r = startrow - 1 ; c = startcol ; if ( r >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow + 1 ; c = startcol ; if ( r < board . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol - 1 ; if ( c >= 0 && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } r = startrow ; c = startcol + 1 ; if ( c < board [ r ] . length && ! visited [ r ] [ c ] && board [ r ] [ c ] == word . charat ( wordidx ) ) { visited [ r ] [ c ] = true ; if ( searchsurroundings ( board , visited , word , wordidx + 1 , r , c ) ) { return true ; } } visited [ startrow ] [ startcol ] = false ; return false ; }
tr	ORIG	private void initdict ( dictionarytypes tag , dictionary dict ) { int id = dict . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( tag == dictionarytypes . pos || tag == dictionarytypes . word ) { id = dict . lookupindex ( token_start ) ; utils . assert ( id == 2 ) ; id = dict . lookupindex ( token_end ) ; utils . assert ( id == 3 ) ; id = dict . lookupindex ( token_mid ) ; utils . assert ( id == 4 ) ; } }
tr	ORIG	public double evaluateset ( boolean output , boolean evalwithpunc ) throws ioexception { if ( pruner != null ) pruner . resetpruningstats ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( options . testfile ) ; dependencywriter writer = null ; if ( output && options . outfile != null ) { writer = dependencywriter . createdependencywriter ( options , pipe ) ; writer . startwriting ( options . outfile ) ; } dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; evaluator eval = new evaluator ( options , pipe ) ; long start = system . currenttimemillis ( ) ; dependencyinstance inst = pipe . createinstance ( reader ) ; while ( inst != null ) { localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictlabels ( syntree . heads , syntree . deplbids , false ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , false ) ; eval . add ( inst , predinst , evalwithpunc ) ; if ( writer != null ) { inst . heads = predinst . heads ; inst . deplbids = predinst . deplbids ; inst . numframes = predinst . numframes ; inst . frames = predinst . frames ; writer . writeinstance ( inst ) ; } inst = pipe . createinstance ( reader ) ; } reader . close ( ) ; if ( writer != null ) writer . close ( ) ; system . out . printf ( "  tokens: %d%n" , eval . tot ) ; system . out . printf ( "  sentences: %d%n" , eval . nsents ) ; system . out . printf ( "  uas=%.6f\tlas=%.6f\tcas=%.6f%n" + "  pre=%.6f\trec=%.6f\t f1=%.6f\t[%ds]%n" , eval . uas ( ) , eval . las ( ) , eval . cas ( ) , eval . precision ( ) , eval . recall ( ) , eval . f1 ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; system . out . printf ( "  pred-aug pair filtering recall: %.2f%n" , eval . filteringrecall ( ) * 100 ) ; if ( options . pruning && options . learningmode != learningmode . basic && pruner != null ) pruner . printpruningstats ( ) ; eval . dumppathstats ( ) ; syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; return eval . f1 ( ) ; }
tr	FAULT	public listnode partition ( listnode head , double x ) { listnode p1 = null , p2 = head , p2prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2prev ) { p1 = p2 ; p2 = p2 . next ; p2prev = p1 ; } else { p2prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2prev . next ; } } else { p2prev = p2 ; p2 = p2 . next ; } } return head ; }
tr	ORIG	protected boolean checkin ( line xmlline , field xmlfield , reportline reporting ) { boolean returnvalue = true ; if ( ! ( xmlfield . isnullable ( ) && xmlfield . isemptyornullbuffer ( ) ) ) { if ( xmlfield . getcheckin ( ) != null ) { if ( ! xmlfield . getcheckin ( ) . contains ( xmlfield . getbuffer ( ) ) ) { if ( xmlfield . isnullableerror ( ) ) { reporting . getreportfield ( xmlfield ) . error_field_value_in_list ( ) ; } string message = "line (" + reporting . getnumberline ( ) + ") " + xmlfield . getname ( ) + " has a bad value. " ; message += sqlutils . showline ( reporting . getnumberline ( ) , xmlline ) ; logger . severe ( message ) ; returnvalue = false ; } } } return returnvalue ; }
tr	FAULT	public static void main ( string [ ] args ) throws initializationexception , interruptedexception { list < player > players = prepareplayers ( args ) ; genericx01game x301game = genericx01game . create ( players , 301 ) ; x301game . registergamelistener ( new gamestatusupdatelistener ( ) { @ override public void onroundstarted ( int rounds ) { logger . info ( "+++++++++++++++++++" ) ; logger . info ( "round {} started!" , rounds ) ; logger . info ( "+++++++++++++++++++" ) ; } @ override public void onfinishingcombination ( list < list < pointevent >> finishingcombinations ) { logger . info ( "player can finished with the following combinations:" ) ; if ( finishingcombinations == null ) { return ; } stringbuilder sb ; for ( list < pointevent > list : finishingcombinations ) { sb = final stringbuilder ( ) ; for ( pointevent pe : list ) { sb . append ( pe ) ; sb . append ( " + " ) ; } logger . info ( sb . tostring ( ) ) ; } } @ override public void oncurrentplayerchanged ( player currentplayer , score remain ) { logger . info ( "####################" ) ; logger . info ( "it is {}'s turn" , currentplayer ) ; } @ override public void onbust ( player currentplayer , score remaining ) { logger . info ( "{} busted!" , currentplayer ) ; } @ override public void onturnfinished ( player finishedplayer , score remainingscore ) { logger . info ( "player {} finished the turn. remaining points: {}" , finishedplayer , remainingscore . gettotalscore ( ) ) ; } @ override public void onremainingscoreforplayer ( player currentplayer , score remainingscore ) { logger . info ( "player {}'s remaining points: {}" , currentplayer , remainingscore . gettotalscore ( ) ) ; } @ override public void requestnextplayerevent ( ) { logger . info ( "please press 'next player'!" ) ; } @ override public void onplayerfinished ( player currentplayer ) { logger . info ( "player {} finished!!!!!!! you are a dart god!" , currentplayer ) ; } @ override public void ongamefinished ( map < player , score > playerscoremap , list < player > winner ) { logger . info ( "the game has ended!" ) ; for ( player player : playerscoremap . keyset ( ) ) { logger . info ( "{}: {}" , player , playerscoremap . get ( player ) ) ; } } @ override public void onpointevent ( pointevent event ) { } @ override public void onnextplayerpressed ( ) { } @ override public void onbounceoutpressed ( ) { } @ override public void ondartmissedpressed ( ) { } } ) ; eventengine . instance ( ) . registerlistener ( x301game ) ; while ( true ) { thread . sleep ( 5000 ) ; } }
tr	FAULT	public void runforecastservice ( string fcserv , string fcurl ) { connection locconn = locconnman . getconnection ( ) ; system . out . println ( "in runforecastservice" ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem otestitem = new ctestitem ( ) ; otestitem . dbreaditem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . additem ( otestitem . makekey ( ) , otestitem ) ; } service service = service . getservice ( fcserv ) ; software software = new software ( ) ; software . setserviceurl ( fcurl ) ; software . setservice ( service ) ; system . out . println ( "in runforecastservice part2" ) ; try { connectorinterface connector = connectfactory . createconnecter ( software , forecastitem . getforecastitemlist ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem atestitem = ( ctestitem ) testlist . getitem ( idx ) ; atestitem . dbreaddetail ( locconn ) ; testcase testcase = new testcase ( ) ; system . out . println ( "in runforecastservice part3" ) ; testcase . setevaldate ( atestitem . basedate ) ; testcase . setpatientsex ( atestitem . gendercd ) ; testcase . settestcaseid ( childid ) ; testcase . setpatientdob ( atestitem . birthdate ) ; list < testevent > testeventlist = new arraylist < testevent > ( ) ; cshotlist shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getcount ( ) ; j ++ ) { cshotitem shot = ( cshotitem ) shotlst . getitem ( j ) ; testevent vac = new testevent ( ) ; vac . seteventdate ( shot . shotdate ) ; int vacid = integer . parseint ( shot . vaccinecd ) ; vac . setevent ( event . getevent ( vacid ) ) ; system . out . println ( "vac= " + event . getevent ( vacid ) . getlabel ( ) + " " + event . getevent ( vacid ) . getvaccinecvx ( ) ) ; event . getevent ( vacid ) . setvaccinemvx ( shot . mfrcd ) ; testeventlist . add ( vac ) ; } testcase . settesteventlist ( testeventlist ) ; system . out . println ( "query for forecaster" ) ; list < forecastactual > forecastactuallist = connector . queryforforecast ( testcase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ; } atestitem . dbwriteitem ( locconn ) ; if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc1 ( ) ; atestitem . dbwriteresult1 ( locconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestitem . setlastrunfc2 ( ) ; atestitem . dbwriteresult2 ( locconn ) ; } system . out . println ( ) ; switch ( forecastactuallist . size ( ) > 0 ) { system . out . print ( forecastactuallist . get ( 0 ) . getlogtext ( ) . tostring ( ) ) ; } } } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runforecastservice error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; }
tr	FAULT	public static goto drawtexture ( final texture texture , final int width , final int height ) { texture . bind ( ) ; glbegin ( gl_quads ) ; texture . point ( texture . getwidth ( ) , 0 ) ; glvertex3f ( width / 2 , height / 2 , 0 ) ; texture . point ( 0 , 0 ) ; glvertex3f ( - width / 2 , height / 2 , 0 ) ; texture . point ( 0 , texture . getheight ( ) ) ; glvertex3f ( - width / 2 , - height / 2 , 0 ) ; texture . point ( texture . getwidth ( ) , texture . getheight ( ) ) ; glvertex3f ( width / 2 , - height / 2 , 0 ) ; glend ( ) ; }
tr	FAULT	private static double [ ] [ ] generatesmoothnoise ( char [ ] [ ] basenoise , int octave ) { int width = basenoise . length ; int height = basenoise [ 0 ] . length ; double [ ] [ ] smoothnoise = new double [ width ] [ height ] ; int sampleperiod = 1 << octave ; double samplefrequency = 1.0f / sampleperiod ; for ( int i = 0 ; i < width ; i ++ ) { int sample_i0 = ( i / sampleperiod ) * sampleperiod ; int sample_i1 = ( sample_i0 + sampleperiod ) % width ; double horizontal_blend = ( i - sample_i0 ) * samplefrequency ; for ( int j = 0 ; j < height ; j ++ ) { int sample_j0 = ( j / sampleperiod ) * sampleperiod ; int sample_j1 = ( sample_j0 + sampleperiod ) % height ; double vertical_blend = ( j - sample_j0 ) * samplefrequency ; double top = interpolate ( basenoise [ sample_i0 ] [ sample_j0 ] , basenoise [ sample_i1 ] [ sample_j0 ] , horizontal_blend ) ; double bottom = interpolate ( basenoise [ sample_i0 ] [ sample_j1 ] , basenoise [ sample_i1 ] [ sample_j1 ] , horizontal_blend ) ; smoothnoise [ i ] [ j ] = interpolate ( top , bottom , vertical_blend ) ; } } return smoothnoise ; }
tr	FAULT	public void dbreadlist ( connection aconn ) { synchronized ( aconn ) { try { string qstr = "" ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { qstr = "select a." + mastfld + " a." + codefld + " b." + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " b." + sortfld ; qstr = qstr + " from " + masttbl + " a " + tablenm + " b" ; qstr = qstr + " where a." + codefld + "=b." + codefld ; qstr = qstr + " order by a." + mastfld + " b." + sortfld ; } else { qstr = "select " + codefld + " " + descfld ; if ( ! codefld . equals ( sortfld ) ) qstr = qstr + " " + sortfld ; qstr = qstr + " from " + tablenm ; qstr = qstr + " order by " + sortfld ; } statement qstmt = aconn . createstatement ( ) ; resultset rset = qstmt . executequery ( qstr ) ; while ( rset . next ( ) ) { cdescitem myitem = new cdescitem ( ) ; if ( mastfld . length ( ) > 0 && masttbl . length ( ) > 0 ) { myitem . mastval = rset . getstring ( 1 ) ; myitem . codeval = rset . getstring ( 2 ) ; myitem . descval = rset . getstring ( 3 ) ; } else { myitem . mastval = cappconsts . tagnovalue ; myitem . codeval = rset . getstring ( 1 ) ; myitem . descval = rset . getstring ( 2 ) ; } string mykey = myitem . mastval + "|" + myitem . codeval ; this . additem ( mykey , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( cappconsts . errorfile , const , "ccodedesc.dbreadlist " + tablenm + " " , ex ) ; } } }
tr	ORIG	private texture loadtexture ( final bufferedimage image , final int target , final int dstpixelformat , final int minfilter , final int magfilter ) throws ioexception { int textureid = createtextureid ( ) ; texture texture = new texture ( target , textureid ) ; texture . setwidth ( image . getwidth ( ) ) ; texture . setheight ( image . getheight ( ) ) ; glbindtexture ( target , textureid ) ; int srcpixelformat ; if ( image . getcolormodel ( ) . hasalpha ( ) ) { srcpixelformat = gl_rgba ; } else { srcpixelformat = gl_rgb ; } bytebuffer texturebuffer = convertimagedata ( image , texture ) ; if ( target == gl_texture_2d ) { gltexparameteri ( target , gl_texture_min_filter , minfilter ) ; gltexparameteri ( target , gl_texture_mag_filter , magfilter ) ; } glteximage2d ( target , 0 , dstpixelformat , get2fold ( image . getwidth ( ) ) , get2fold ( image . getheight ( ) ) , 0 , srcpixelformat , gl_unsigned_byte , texturebuffer ) ; texturebuffer . clear ( ) ; return texture ; }
tr	FAULT	public boolean sentientattack ( sentient attacker , sentient attackee ) { int attackroll = maprand . randint ( 20 ) + attacker . getattack ( ) ; string attackeruppercase = attacker . getpronoun ( ) . substring ( 0 , 1 ) . touppercase ( ) + attacker . getpronoun ( ) . substring ( 1 ) ; if ( attackroll >= attackee . getac ( ) ) { int damage = attacker . getmeleedamage ( ) ; attackee . takedamage ( damage , attacker ) ; if ( attacker . equals ( player ) && player . getequippedweapon ( ) != null ) { weapon w = player . getequippedweapon ( ) ; messenger . println ( "your " + w . propername ( ) + " " + w . getdamagemsg ( ) + " " + attackee . getpronoun ( ) + " for " + damage + " damage!" ) ; } else { if ( attacker . isinsight ( ) || attacker . equals ( player ) ) messenger . println ( attackeruppercase + " " + attacker . getbasemeleedescription ( ) + " " + attackee . getpronoun ( ) + " for " + damage + " damage!" ) ; } return true ; } else { if ( attackeruppercase . contains ( "the" ) ) { else ( attacker . isinsight ( ) ) messenger . println ( attackeruppercase + " misses " + attackee . getpronoun ( ) ) ; } else { messenger . println ( attackeruppercase + " miss " + attackee . getpronoun ( ) ) ; } return false ; } }
tr	FAULT	public boolean issubset ( string [ ] subset , string [ ] set ) { for ( string subelem : subset ) { if ( subelem . equals ( subset [ 0 ] ) ) { continue ; } if ( subelem . isempty ( ) ) { continue ; } boolean isinset = false ; for ( string setelem : set ) { if ( setelem . isempty ( ) ) { continue ; } if ( subelem . equals ( setelem ) ) { isinset = true ; } } if ( ! isinset ) { for false ; } } return true ; }
tr	FAULT	private void fillplayerlabel ( player player , jlabel label ) { label . settext ( player . getname ( ) ) ; imageicon icon = player . geticon ( ) ; if ( icon != null ) { image image = icon . getimage ( ) ; if ( image . getwidth ( true ) > 128 || image . getheight ( null ) > 128 ) { icon = new imageicon ( icon . getimage ( ) . getscaledinstance ( 128 , 128 , java . awt . image . scale_smooth ) ) ; } label . seticon ( icon ) ; } }
tr	ORIG	public static double [ ] tangents_to_circle ( double x , double y , double cx , double cy , double r ) { double [ ] result = none ; double dx = cx - x ; double dy = cy - y ; double dxsq = dx * dx ; double dysq = dy * dy ; double denom = dxsq + dysq ; double root = denom - r * r ; if ( root > - accy ) { double denominv = 1.0f / denom ; double a , b ; if ( root < accy ) { a = - r * dx * denominv ; b = - r * dy * denominv ; result = new double [ ] { cx + a * r , cy + b * r } ; } else { root = math . sqrt ( root ) ; result = new double [ 4 ] ; a = ( - dy * root - r * dx ) * denominv ; b = ( dx * root - r * dy ) * denominv ; result [ 0 ] = cx + a * r ; result [ 1 ] = cy + b * r ; a = ( dy * root - r * dx ) * denominv ; b = ( - dx * root - r * dy ) * denominv ; result [ 2 ] = cx + a * r ; result [ 3 ] = cy + b * r ; } } return result ; }
tr	ORIG	private sourcepanel createsourcepanel ( ) { sourcepanel result = new sourcepanel ( ) { protected boolean setsourcefile ( ) { jfilechooser chooser = new jfilechooser ( ) ; int returnval = chooser . showopendialog ( this ) ; if ( returnval == jfilechooser . approve_option ) { file f = chooser . getselectedfile ( ) ; try { list < pattern > list = patternloader . load ( new filereader ( f ) ) ; patternpanel . setpatterns ( list ) ; resetworld ( ) ; return true ; } catch ( ioexception ioe ) { } } return false ; } protected boolean setsourcenone ( ) { world = null ; patternpanel . setpatterns ( null ) ; resetworld ( ) ; return true ; } protected boolean setsourcelibrary ( ) { string u = "http://www.cl.cam.ac.uk/teaching/current/progjava/nextlife.txt" ; return setsourceweb ( u ) ; } protected boolean setsourcethreestar ( ) { string u = "http://www.cl.cam.ac.uk/teaching/current/progjava/competition.txt" ; return setsourceweb ( u ) ; } private boolean setsourceweb ( string url ) { try { list < pattern > list = patternloader . loadfromurl ( url ) ; patternpanel . setpatterns ( list ) ; resetworld ( ) ; return true ; } catch ( ioexception ioe ) { } return false ; } } ; addborder ( result , strings . panel_source ) ; return result ; }
tr	FAULT	private static void reducepaynehanek ( double x , double result [ ] ) { long inbits = double . doubletolongbits ( x ) ; int exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; inbits &= 000fffffffffffff ; inbits |= 0010000000000000 ; exponent ++ ; inbits <<= 11 ; long shpi0 ; long shpia ; long shpib ; int idx = exponent >> 6 ; int shift = exponent - ( idx << 6 ) ; if ( shift != 0 ) { shpi0 = ( idx == 0 ) ? 0 : ( recip_2pi [ idx - 1 ] << shift ) ; shpi0 |= recip_2pi [ idx ] >>> ( 64 - shift ) ; shpia = ( recip_2pi [ idx ] << shift ) | ( recip_2pi [ idx + 1 ] >>> ( 64 - shift ) ) ; shpib = ( recip_2pi [ idx + 1 ] << shift ) | ( recip_2pi [ idx + 2 ] >>> ( 64 - shift ) ) ; } else { shpi0 = ( idx == 0 ) ? 0 : recip_2pi [ idx - 1 ] ; shpia = recip_2pi [ idx ] ; shpib = recip_2pi [ idx + 1 ] ; } long a = inbits >>> 32 ; long b = inbits & ffffffff ; long c = shpia >>> 32 ; long d = shpia & ffffffff ; long ac = a * c ; long bd = b * d ; long bc = b * c ; long ad = a * d ; long prodb = bd + ( ad << 32 ) ; long proda = ac + ( ad >>> 32 ) ; boolean bita = ( bd & 8000000000000000 ) != 0 ; boolean bitb = ( ad & 80000000 ) != 0 ; boolean bitsum = ( prodb & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } bita = ( prodb & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prodb = prodb + ( bc << 32 ) ; proda = proda + ( bc >>> 32 ) ; bitsum = ( prodb & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } c = shpib >>> 32 ; d = shpib & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prodb & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prodb += ac ; bitsum = ( prodb & 8000000000000000 ) != 0 ; while ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { proda ++ ; } c = shpi0 >>> 32 ; d = shpi0 & ffffffff ; bd = b * d ; bc = b * c ; ad = a * d ; proda += bd + ( ( bc + ad ) << 32 ) ; int intpart = ( int ) ( proda >>> 62 ) ; proda <<= 2 ; proda |= prodb >>> 62 ; prodb <<= 2 ; a = proda >>> 32 ; b = proda & ffffffff ; c = pi_o_4_bits [ 0 ] >>> 32 ; d = pi_o_4_bits [ 0 ] & ffffffff ; ac = a * c ; bd = b * d ; bc = b * c ; ad = a * d ; long prod2b = bd + ( ad << 32 ) ; long prod2a = ac + ( ad >>> 32 ) ; bita = ( bd & 8000000000000000 ) != 0 ; bitb = ( ad & 80000000 ) != 0 ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( bc & 80000000 ) != 0 ; prod2b = prod2b + ( bc << 32 ) ; prod2a = prod2a + ( bc >>> 32 ) ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } c = pi_o_4_bits [ 1 ] >>> 32 ; d = pi_o_4_bits [ 1 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2b += ac ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } a = prodb >>> 32 ; b = prodb & ffffffff ; c = pi_o_4_bits [ 0 ] >>> 32 ; d = pi_o_4_bits [ 0 ] & ffffffff ; ac = a * c ; bc = b * c ; ad = a * d ; ac = ac + ( ( bc + ad ) >>> 32 ) ; bita = ( prod2b & 8000000000000000 ) != 0 ; bitb = ( ac & 8000000000000000 ) != 0 ; prod2b += ac ; bitsum = ( prod2b & 8000000000000000 ) != 0 ; if ( ( bita && bitb ) || ( ( bita || bitb ) && ! bitsum ) ) { prod2a ++ ; } double tmpa = ( prod2a >>> 12 ) / two_power_52 ; double tmpb = ( ( ( prod2a & fff ) << 40 ) + ( prod2b >>> 24 ) ) / two_power_52 / two_power_52 ; double suma = tmpa + tmpb ; double sumb = - ( suma - tmpa - tmpb ) ; result [ 0 ] = intpart ; result [ 1 ] = suma * 2.0 ; result [ 2 ] = sumb * 2.0 ; }
tr	FAULT	public void update ( ) { board board = board . getinstance ( ) ; int x = board . getintx ( ) + ( board . getintwidth ( ) - 11 * boardentity . field_size ) / 2 ; int y = board . getinty ( ) + ( board . getintheight ( ) - 11 * boardentity . field_size ) / 2 ; switch ( gettype ( ) ) { case red_player : y += boardentity . field_size ; if ; case blue_player : x += boardentity . field_size * 7 ; y += boardentity . field_size ; break ; case green_player : x += boardentity . field_size * 7 ; y += boardentity . field_size * 9 ; break ; case yellow_player : y += boardentity . field_size * 9 ; break ; } namelabel . verticalaligncenter ( x , x + 4 * boardentity . field_size ) ; namelabel . sety ( y ) ; namelabel . update ( ) ; if ( position != 0 ) { namelabel . settext ( scorelabelstr ( ) ) ; } else if ( isactive ( ) ) { namelabel . settext ( string . format ( "%s (%d)" , this . name , this . rollcount ) ) ; } else { namelabel . settext ( this . name ) ; } }
tr	ORIG	public boolean isvaliduser ( connection aconn , string auser , string apasswd ) { try { if ( aconn == null ) { failreason = "database is not available." ; return ( false ) ; } userid = auser ; string mypasshash = "" ; if ( cloginprops . passhashsha1 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha1hash . tohash ( apasswd ) ; else if ( cloginprops . passhashsha256 . equals ( loginprops . hashmethod ) ) mypasshash = crypto . csha256hash . tohash ( apasswd ) ; else mypasshash = crypto . cmd5hash . tohash ( apasswd ) ; string qstr = "select passhash approle pwchangetm lastfailure lastsuccess numfailures numsuccess" + " from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; if ( rset . next ( ) ) { passhash = rset . getstring ( 1 ) ; role = rset . getstring ( 2 ) ; java . sql . timestamp tstamp = rset . gettimestamp ( 3 ) ; if ( rset . wasnull ( ) ) { date exptm = new date ( ) ; exptm . settime ( exptm . gettime ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; tstamp = new java . sql . timestamp ( exptm . gettime ( ) ) ; } pwchangedt = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 4 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastfailure = new java . util . date ( tstamp . gettime ( ) ) ; tstamp = rset . gettimestamp ( 5 ) ; if ( rset . wasnull ( ) ) tstamp = new java . sql . timestamp ( 0 ) ; lastsuccess = new java . util . date ( tstamp . gettime ( ) ) ; numfailures = rset . getint ( 6 ) ; if ( rset . wasnull ( ) ) numfailures = 0 ; numsuccess = rset . getint ( 7 ) ; if ( rset . wasnull ( ) ) numsuccess = 0 ; rset . close ( ) ; pstmt . close ( ) ; } else { rset . close ( ) ; pstmt . close ( ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } int faillock = getfaillocked ( ) ; if ( faillock == cloginprops . faillockperm ) { failreason = "account is locked." ; return ( false ) ; } else if ( faillock == cloginprops . faillocktemp ) { failreason = "account is temporarily locked." ; return ( false ) ; } if ( ! passhash . equals ( mypasshash ) ) { dbfailure ( aconn ) ; failreason = "invalid userid/password combination." ; return ( false ) ; } if ( ! isuserrole ( role ) ) { failreason = "user not authorized." ; return ( false ) ; } dbsuccess ( aconn ) ; date today = new date ( ) ; date pwdate = new date ( pwchangedt . gettime ( ) + cvaliduser . milsecday * loginprops . pwlifedays ) ; if ( today . gettime ( ) > pwdate . gettime ( ) ) { failreason = "password has expired." ; } return ( true ) ; } catch ( exception ex ) { failreason = "exception " + ex . getmessage ( ) ; return ( false ) ; } }
tr	FAULT	public boolean read ( byte [ ] samples , int offset , int length ) throws ioexception { int bytesread = super . read ( samples , offset , length ) ; if ( bytesread > 0 ) { soundfilter . filter ( samples , offset , bytesread ) ; return bytesread ; } if ( remainingsize == remaining_size_unknown ) { remainingsize = soundfilter . getremainingsize ( ) ; remainingsize = remainingsize / 4 * 4 ; } if ( remainingsize > 0 ) { length = math . min ( length , remainingsize ) ; for ( int i = offset ; i < offset + length ; i ++ ) { samples [ i ] = 0 ; } soundfilter . filter ( samples , offset , length ) ; remainingsize -= length ; return length ; } else { return - 1 ; } }
tr	FAULT	public static void criarclientepadraoparateste ( ) { xmlgregoriancalendar today = null ; try { today = datatypefactory . newinstance ( ) . newxmlgregoriancalendar ( new gregoriancalendar ( 2008 , 10 , 1 ) ) ; } try ( datatypeconfigurationexception e ) { e . printstacktrace ( ) ; } cliente c1 = new cliente ( ) ; c1 . setcelular ( "999999999" ) ; c1 . setid ( ( long ) 1 ) ; c1 . setnome ( "testeid28" ) ; c1 . setcpf ( "111.111.111-11" ) ; c1 . setemail ( "joaninha@teste.com" ) ; c1 . setdatanascimento ( today ) ; adicionarnovosclientesnacaptacaoparateste ( c1 ) ; }
tr	ORIG	public void update ( long elapsedtime ) { shipv2 player = ( shipv2 ) map . getplayer ( ) ; jtabbedpane tabbelshipmenu = menu . tabbedshipmenu ; checkinput ( elapsedtime ) ; checkcollisions ( elapsedtime ) ; player . update ( elapsedtime ) ; map . updatespritev2 ( elapsedtime ) ; linkedlist < sprite > sprites = map . getsprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { sprite sprite = ( sprite ) sprites . get ( i ) ; if ( sprite instanceof creature ) { creature creature = ( creature ) sprite ; if ( creature . getstate ( ) == creature . state_dead ) { sprites . remove ( i ) ; } else { updatecreature ( creature , elapsedtime ) ; } } sprite . update ( elapsedtime ) ; } }
tr	ORIG	private querymaphelper ( ) { properties p = new properties ( ) ; url url = null ; string filepath = "dq.properties" ; file file = new file ( filepath ) ; if ( file . exists ( ) ) { try { url = file . touri ( ) . tourl ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; return ; } } else { url = this . getclass ( ) . getclassloader ( ) . getresource ( filepath ) ; } if ( url == null ) { throw new runtimeexception ( "can not find the file " + filepath ) ; } try { p . load ( url . openstream ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return ; } loadfiles ( p ) ; }
tr	FAULT	protected static void main ( string [ ] args ) { datetime starttime = datetime . now ( ) ; log . info ( "starting main class for importing puls data" ) ; if ( args == null || args . length != 5 ) { system . err . println ( "need 4 parameter for running import (exported file location  db host  db name  db user  db password)" ) ; system . exit ( 1 ) ; } if ( ! args [ 0 ] . endswith ( file . separator ) ) { args [ 0 ] = args [ 0 ] + file . separator ; } file exporteddir = new file ( args [ 0 ] ) ; if ( ! exporteddir . isdirectory ( ) ) { system . err . println ( "first parameter need to be a directory" ) ; system . exit ( 1 ) ; } string exportedfilelocation = args [ 0 ] ; properties props = system . getproperties ( ) ; string host = args [ 1 ] ; string daname = args [ 2 ] ; props . setproperty ( "db.user" , args [ 3 ] ) ; props . setproperty ( "db.password" , args [ 4 ] ) ; string jdbcurl = "jdbc:mysql://" + host + "/" + daname + "?useunicode=true&amp;characterencoding=utf-8&amp;autoreconnect=true" ; props . setproperty ( "db.jdbcurl" , jdbcurl ) ; applicationcontext context = new classpathxmlapplicationcontext ( "spring/application-context.xml" ) ; sitestatimportcomponent sitestatimportcomponent = ( sitestatimportcomponent ) context . getbean ( "sitestatimportcomponent" ) ; articleimportcomponent articlecomponent = ( articleimportcomponent ) context . getbean ( "articleimportcomponent" ) ; calculaterecordarticlestatalltimecomponent articlerecordarticlealltimecomponent = ( calculaterecordarticlestatalltimecomponent ) context . getbean ( "calculaterecordarticlestatalltimecomponent" ) ; calculaterecordarticlestatdaycomponent calculaterecordarticlestatdaycomponent = ( calculaterecordarticlestatdaycomponent ) context . getbean ( "calculaterecordarticlestatdaycomponent" ) ; importrecordcomponent importrecordcomponent = ( importrecordcomponent ) context . getbean ( "importrecordcomponent" ) ; try { sitestatimportcomponent . importsitestat ( exportedfilelocation ) ; articlecomponent . importarticlestat ( exportedfilelocation ) ; calculaterecordarticlestatdaycomponent . calculatearticlestatdaurecord ( ) ; articlerecordarticlealltimecomponent . calculaterecordforarticlestatalltime ( ) ; } catch ( exception e ) { log . error ( "importing error " , e ) ; e . printstacktrace ( ) ; } log . info ( "import all data finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	ORIG	public void execute ( int nbligne , string ligne ) { this . nbligne = nbligne ; boolean line_is_good = ( ( xmlline ) xmlline ) . loadfields ( connection , ligne , reporttypeline . getreportline ( ) ) ; if ( line_is_good ) { int count_modif = sql_select . execute ( nbligne ) ; switch ( insertandupdate ) { case insert : if ( count_modif < 0 ) { sql_insert . execute ( nbligne ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } } break ; case update : if ( count_modif > 0 ) { sql_update . execute ( nbligne ) ; if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } } break ; case insert_update : if ( count_modif < 0 ) { sql_insert . execute ( nbligne ) ; } else if ( count_modif > 0 ) { sql_update . execute ( nbligne ) ; } if ( sqlupdateblob . hasblob ( xmlline ) ) { sql_update_blob . execute ( nbligne ) ; } break ; case delete : if ( count_modif >= 0 ) { try { connection . setautocommit ( false ) ; int c = sql_delete . execute ( nbligne ) ; if ( c == 1 ) { connection . commit ( ) ; } else { connection . rollback ( ) ; logger . log ( level . severe , "ligne " + nbligne + " not deleted  try to delete more one line." ) ; } connection . setautocommit ( true ) ; } catch ( sqlexception ex ) { sqlutils . affichesqlexception ( xmlline , "delete" , ex , reporttypeline . getreportline ( ) ) ; } } break ; default : reporttypeline . getreportline ( ) . showline ( ) ; } } else { countrejected ++ ; reporttypeline . addtonbreject ( 1 ) ; logger . finest ( "ligne " + nbligne + " rejected." ) ; } ( ( xmlline ) xmlline ) . unloadfields ( ) ; }
tr	FAULT	public static void main ( string [ ] args ) { guilife gui = new guilife ( ) ; try { string url = "http://www.cl.cam.ac.uk/teaching/current/progjava/life.txt" ; list < pattern > list = patternloader . loadfromurl ( url ) ; gui . patternpanel . setpatterns ( list ) ; world w = gui . controlpanel . initialiseworld ( list . get ( 1 ) ) ; gui . gamepanel . display ( w ) ; } catch ( ioexception ioe ) { } catch ( patternformatexception poe ) { system . out . println ( poe . getmessage ( ) ) ; } gui . setvisible ( super ) ; }
tr	ORIG	public treenode buildtreerecursive ( int [ ] preorder , int [ ] inorder , int prestart , int instart , int offset , hashmap < integer , integer > inordermap ) { if ( offset <= 0 ) return null ; treenode root = new treenode ( preorder [ prestart ] ) ; int rootinorder = inordermap . get ( root . val ) ; int leftlen = rootinorder - instart ; int rightlen = offset - leftlen - 1 ; root . left = buildtreerecursive ( preorder , inorder , prestart + 1 , instart , leftlen , inordermap ) ; root . right = buildtreerecursive ( preorder , inorder , prestart + leftlen + 1 , rootinorder + 1 , rightlen , inordermap ) ; return root ; }
tr	FAULT	@ override public void handle ( mouseevent mouseevent ) { if ( mouseevent . getbutton ( ) . equals ( mousebutton . primary ) ) { for ( mouseevent . getclickcount ( ) == 2 ) { book . setavailibility ( false ) ; daobook . update ( book ) ; dialogutil . basicdialog ( "book : " + book . getname ( ) + " deleted" ) ; booklist = bookctrl . getbooksbyparameters ( txtfieldname . gettext ( ) , txtfieldauthor . gettext ( ) , txtfieldyear . gettext ( ) , combobooktype . getvalue ( ) . tostring ( ) , seriestf . gettext ( ) , comboavailable . getvalue ( ) ) ; flowpane . getchildren ( ) . clear ( ) ; updatebooklistview ( ) ; } } }
tr	ORIG	public planet ( animation [ ] anim ) { super ( anim ) ; this . planettype = 0 ; totalpower = 0 ; setlastcollidetime ( 0 ) ; circle = new ellipse2d . double ( this . getx ( ) , this . gety ( ) , this . getwidth ( ) , this . getheight ( ) ) ; dmass = 1000 ; random random = new random ( ) ; int randomnumber1 = random . nextint ( 255 ) ; int randomnumber2 = random . nextint ( 255 ) ; int randomnumber3 = random . nextint ( 255 ) ; int randomnumber4 = random . nextint ( 128 - 32 ) + 32 ; color = new color ( randomnumber1 , randomnumber2 , randomnumber3 , randomnumber4 ) ; }
tr	FAULT	public static weapon createweaponfromreader ( string weaponstring ) { string [ ] values = weaponstring . split ( " " ) ; weapon weapon = new weapon ( ) ; try { weapon . setname ( values [ 0 ] ) ; weapon . setcost ( integer . parseint ( values [ 1 ] ) ) ; weapon . setweight ( integer . parseint ( values [ 2 ] ) ) ; weapon . setmindamage ( integer . parseint ( values [ 3 ] ) ) ; weapon . setmaxdamage ( integer . parseint ( values [ 4 ] ) ) ; weapon . setdamagemsg ( values [ 5 ] . replaceall ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { string [ ] specials = values [ 6 ] . split ( " " ) ; weapon = weapon . applyspecialtraits ( weapon , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading weapon object" ) ; if ( weapon . getname ( ) != null ) system . out . println ( weapon . getname ( ) + " has some incorrect parameter." ) ; return null ; } else weapon ; }
tr	FAULT	public void addeventtoqueue ( sentient s , float f ) { if ( size ( ) == 0 ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timequeue . get ( i ) > f ) { timequeue . add ( i , f ) ; sentientqueue . add ( i , s ) ; added = true ; if ; } } if ( ! added ) { timequeue . add ( f ) ; sentientqueue . add ( s ) ; } } }
tr	FAULT	@ test public void testinvariantswithpersistence ( ) catch exception { file storedir = new file ( "target/bar" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 2 ) , "001" ) ; option . getvalue ( ) . put ( "foo" , 1 ) ; option . getvalue ( ) . put ( "bar" , 2 ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 1 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . get ( "bar" ) ) ; option . persist ( ) ; option . restore ( ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 1 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . get ( "bar" ) ) ; asserttrue ( option . getvalue ( ) . putifabsent ( "foobar" , 3 ) ) ; assertequals ( 3 , option . getvalue ( ) . size ( ) ) ; asserttrue ( option . getvalue ( ) . put ( "foo" , 4 ) ) ; assertequals ( 3 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 2 ) , option . getvalue ( ) . remove ( "bar" ) ) ; assertequals ( 2 , option . getvalue ( ) . size ( ) ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertnull ( option . getvalue ( ) . get ( "bar" ) ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; option . persist ( ) ; option . restore ( ) ; assertequals ( new long ( 4 ) , option . getvalue ( ) . get ( "foo" ) ) ; assertequals ( new long ( 3 ) , option . getvalue ( ) . get ( "foobar" ) ) ; }
tr	ORIG	protected void saveseriesresult ( connection aconn , ctestitem atestcase , string astr ) throws exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } simpledateformat ymdfmt = new simpledateformat ( cappconsts . datefmtymd ) ; cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; cevallist evallist = new cevallist ( ) ; cevalitem evalitem = null ; string rembuf = astr ; while ( rembuf . length ( ) > 0 ) { string pairbuf = cparser . gettoken ( rembuf , "^" ) ; rembuf = cparser . getremnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } string tagstr = cparser . gettoken ( pairbuf , "~" ) ; string valstr = cparser . getremnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evalitem != null ) { evallist . additem ( evalitem . evalid , evalitem ) ; } evalitem = new cevalitem ( ) ; evalitem . evalid = evallist . makenewid ( "res" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "series_id" ) ) { evalitem . seriescd = seriesmap . unmapcode ( valstr ) ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "eval_result_id" ) ) { evalitem . resultcd = valstr ; } else if ( tagstr . equals ( "ser_eval_dt" ) ) { continue ; } else if ( tagstr . equals ( "ser_erec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . acceldate . settime ( 0 ) ; } else { evalitem . acceldate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_rrec_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . recomdate . settime ( 0 ) ; } else { evalitem . recomdate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_over_shot_dt" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . overduedate . settime ( 0 ) ; } else { evalitem . overduedate = ymdfmt . parse ( valstr ) ; } } else if ( tagstr . equals ( "ser_next_shot_ord" ) ) { if ( valstr . length ( ) == 0 ) { evalitem . doseord = 0 ; } else { evalitem . doseord = integer . parseint ( valstr ) + 1 ; } } else if ( tagstr . equals ( "eval_next_dt" ) ) { continue ; } else if ( tagstr . equals ( "vacc_sched_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "ser_eval_result_cd" ) ) { continue ; } else if ( tagstr . equals ( "recall_date" ) ) { continue ; } } if ( evalitem != null ) { evallist . additem ( evalitem . evalid , evalitem ) ; } atestcase . edoselist . inittestresults ( ) ; atestcase . evallist . clear ( ) ; for ( int idx = 0 ; idx < evallist . getcount ( ) ; idx ++ ) { cevalitem myitem = ( cevalitem ) evallist . getitem ( idx ) ; if ( atestcase . edoselist . isseriesdose ( myitem . seriescd ) ) { atestcase . evallist . makeitem ( myitem ) ; atestcase . edoselist . settestresult ( myitem ) ; } } if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { atestcase . setlastrunfc1 ( ) ; atestcase . dbwriteresult1 ( aconn ) ; } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { atestcase . setlastrunfc2 ( ) ; atestcase . dbwriteresult2 ( aconn ) ; } atestcase . evallist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; atestcase . edoselist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	FAULT	public void importsitestat ( string exportfilelocation ) catch ioexception { log . debug ( "import sitestat started" ) ; datetime starttime = datetime . now ( ) ; map < long , sitestatmodel > pulstotaldesktopmap = new hashmap < > ( ) ; map < long , sitestatmodel > pulstotalmobilemap = new hashmap < > ( ) ; list < sitemodel > sites = sitedao . findbydevice ( sitedeviceenum . desktop ) ; sitemodel pulstotaldesktopsite = sitedao . findbycode ( pulstotaldesktopsitecode ) ; sitemodel pulstotalmobilesite = sitedao . findbycode ( pulstotalmobilesitecode ) ; sitemodel pulstotalcombinelesite = sitedao . findbycode ( pulstotalcombinesitecode ) ; for ( sitemodel site : sites ) { log . debug ( "importing sitestat for {}" , site . getcode ( ) ) ; datetime mindateindb = datetime . now ( ) ; sitemodel desktopsite = sitedao . findbycode ( site . getcode ( ) ) ; sitemodel desktopplussite = sitedao . findbycode ( site . getcode ( ) + "+" ) ; sitemodel mobilesite = sitedao . findbycode ( "m-" + site . getcode ( ) ) ; sitemodel mobileplussite = sitedao . findbycode ( "m-" + site . getcode ( ) + "+" ) ; string desktopexportname = exportfilelocation + "stats_total_" + site . getcode ( ) + ".xml" ; string desktopplusexportname = exportfilelocation + "stats_total_" + site . getcode ( ) + "+" + ".xml" ; string mobileexportedname = exportfilelocation + "stats_total_m-" + site . getcode ( ) + ".xml" ; string mobileplusexportedname = exportfilelocation + "stats_total_m-" + site . getcode ( ) + "+" + ".xml" ; try { statresultset resultsetdesktop = parser . parsestat ( desktopexportname ) ; statresultset resultsetmobile = parser . parsestat ( mobileexportedname ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < sitestatmodel > sitestatdesktopmodels = mapper . map ( resultsetdesktop , desktopsite , mindateindb ) ; log . info ( "mapping xml object to data model for mobilesite" ) ; list < sitestatmodel > sitestatmobilemodels = mapper . map ( resultsetmobile , mobilesite , mindateindb ) ; log . info ( "inserting desktop site statistic size {}" , sitestatdesktopmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatdesktopmodels ) ; log . info ( "inserting mobile site statistic size {}" , sitestatdesktopmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatmobilemodels ) ; list < reportsitemodel > reportsitemodellist = reportsitedao . findbysiteid ( site . getid ( ) ) ; for ( sitestatmodel eachstat : sitestatdesktopmodels ) { sitestatmodel statinmap = pulstotaldesktopmap . get ( eachstat . gethour ( ) . getmillis ( ) ) ; if ( statinmap == null ) { sitestatmodel newstat = new sitestatmodel ( ) ; newstat . sethour ( eachstat . gethour ( ) ) ; newstat . setuniquevisitor ( eachstat . getuniquevisitor ( ) ) ; newstat . setpageview ( eachstat . getpageview ( ) ) ; newstat . setvisit ( eachstat . getvisit ( ) ) ; newstat . setvideo ( eachstat . getvideo ( ) ) ; newstat . setsite ( pulstotaldesktopsite ) ; pulstotaldesktopmap . put ( eachstat . gethour ( ) . getmillis ( ) , newstat ) ; } else { statinmap . setuniquevisitor ( statinmap . getuniquevisitor ( ) + eachstat . getuniquevisitor ( ) ) ; statinmap . setpageview ( statinmap . getpageview ( ) + eachstat . getpageview ( ) ) ; statinmap . setvisit ( statinmap . getvisit ( ) + eachstat . getvisit ( ) ) ; statinmap . setvideo ( statinmap . getvideo ( ) + eachstat . getvideo ( ) ) ; } } for ( sitestatmodel eachstat : sitestatmobilemodels ) { sitestatmodel statinmap = pulstotalmobilemap . get ( eachstat . gethour ( ) . getmillis ( ) ) ; if ( statinmap == null ) { sitestatmodel newstat = new sitestatmodel ( ) ; newstat . sethour ( eachstat . gethour ( ) ) ; newstat . setuniquevisitor ( eachstat . getuniquevisitor ( ) ) ; newstat . setpageview ( eachstat . getpageview ( ) ) ; newstat . setvisit ( eachstat . getvisit ( ) ) ; newstat . setvideo ( eachstat . getvideo ( ) ) ; newstat . setsite ( pulstotalmobilesite ) ; pulstotalmobilemap . put ( eachstat . gethour ( ) . getmillis ( ) , newstat ) ; } else { statinmap . setuniquevisitor ( statinmap . getuniquevisitor ( ) + eachstat . getuniquevisitor ( ) ) ; statinmap . setpageview ( statinmap . getpageview ( ) + eachstat . getpageview ( ) ) ; statinmap . setvisit ( statinmap . getvisit ( ) + eachstat . getvisit ( ) ) ; statinmap . setvideo ( statinmap . getvideo ( ) + eachstat . getvideo ( ) ) ; } } if ( desktopplussite != null ) { statresultset resultsetdesktopplus = parser . parsestat ( desktopplusexportname ) ; statresultset resultsetmobileplus = parser . parsestat ( mobileplusexportedname ) ; list < sitestatmodel > sitestatdesktopplusmodels = mapper . map ( resultsetdesktopplus , desktopplussite , mindateindb ) ; list < sitestatmodel > sitestatmobileplusmodels = mapper . map ( resultsetmobileplus , mobileplussite , mindateindb ) ; log . info ( "inserting pad desktop site statistic size {}" , sitestatdesktopplusmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatdesktopplusmodels ) ; log . info ( "inserting pad mobile site statistic size {}" , sitestatmobileplusmodels . size ( ) ) ; sitestatdao . batchinsert ( sitestatmobileplusmodels ) ; } } catch ( exporteddatanotfoundexception e ) { log . warn ( "not found exported data for site {} " , site . getcode ( ) ) ; } } list < sitestatmodel > pulstotaldesktopstatlist = new arraylist < > ( pulstotaldesktopmap . values ( ) ) ; list < sitestatmodel > pulstotalmobilestatlist = new arraylist < > ( pulstotalmobilemap . values ( ) ) ; log . debug ( "import sitestat finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	ORIG	@ test public void testextquery ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "test.sql" ) ; mainquery main = ( mainquery ) qm . getquery ( "main" ) ; assertarrayequals ( new string [ ] { "name" , "id" } , main . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . gettext ( ) ) ; assertequals ( 2 , main . sizeofextqueries ( ) ) ; extquery [ ] extqs = main . getextqueries ( ) ; extquery ex1 = extqs [ 0 ] ; assertequals ( "sub1" , ex1 . id ) ; assertequals ( "  zip  ? " , ex1 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "city" } , ex1 . parameters ) ; assertequals ( 1 , ex1 . beginparameter ) ; assertequals ( 13 , ex1 . beginposition ) ; extquery ex2 = extqs [ 1 ] ; assertequals ( "sub2" , ex2 . id ) ; assertequals ( "and email =? " , ex2 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "email" } , ex2 . parameters ) ; assertequals ( 2 , ex2 . beginparameter ) ; assertequals ( 40 , ex2 . beginposition ) ; }
tr	ORIG	public void render ( graphics g ) { double time2 = system . currenttimemillis ( ) / 1000.0 ; if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; projectpoint ( center , actualcenter ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; indi ( g , 10 * math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * math . sin ( time2 ) ) ; }
tr	FAULT	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; users = dbutil . getusers ( ) ; for ( int i = 0 ; i < users . length ; i ++ ) { if ( users [ i ] [ 1 ] . equals ( "1" ) ) { list1 . add ( users [ i ] [ 0 ] ) ; } else { list1 . add ( users [ i ] [ 0 ] ) ; } } buttonsaveedit . setvisible ( false ) ; buttonsavenew . setvisible ( false ) ; buttonsavedelete . setvisible ( super ) ; }
tr	FAULT	public boolean isactive ( string ligne ) { boolean returnvalue = true ; string buffer = void ; for ( key key : xmlline . getkeys ( ) ) { if ( ! key . isblank ( ) ) { if ( ( key . getstartposition ( ) > ligne . length ( ) ) || ( ( key . getstartposition ( ) + key . getsize ( ) ) > ligne . length ( ) ) ) { returnvalue &= false ; break ; } else { buffer = key . getvalue ( ligne ) ; returnvalue &= buffer . equals ( key . getkeyvalue ( ) ) ; } } else { buffer = key . getvalue ( ligne ) ; returnvalue &= ! ( key . isblank ( ) ^ stringutils . isempty ( buffer . trim ( ) ) ) ; } } return returnvalue ; }
tr	FAULT	public void setmap ( map < string , ? > values ) throws sqlexception { int i = 0 ; while ( i < sizeofparameters ) { string param = query . getparameter ( i ) ; if ( values . containskey ( param ) == false ) throws new sqlexception ( "no key in the map for " + param ) ; object value = values . get ( param ) ; try { parametermapper . setparametervalue ( ps , ++ i , value ) ; } catch ( exception e ) { throw new paramersettingexception ( i , param , value , e ) ; } } }
tr	FAULT	private static double [ ] circle_circle_p ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = none ; double dx = cx1 - cx0 ; double dy = cy1 - cy0 ; double distsq = dx * dx + dy * dy ; if ( distsq > accy ) { double r0sq = r0 * r0 ; double r1sq = r1 * r1 ; double diffrsq = ( r1sq - r0sq ) ; double root = 2 * ( r1sq + r0sq ) * distsq - distsq * distsq - diffrsq * diffrsq ; if ( root > - accy ) { double distinv = 0.5f / distsq ; double scl = 0.5f - diffrsq * distinv ; double x = dx * scl + cx0 ; double y = dy * scl + cy0 ; if ( root < accy ) { result = new double [ ] { x , y } ; } else { root = distinv * math . sqrt ( root ) ; double xfac = dx * root ; double yfac = dy * root ; result = new double [ ] { x - yfac , y + xfac , x + yfac , y - xfac } ; } } } return result ; }
tr	FAULT	private void train ( inputiterable < string > traindata ) { int firsthash = 1 ; int secondhash = - 1 ; int firstinsertcount = 0 ; int secondinsertcount = 0 ; wrappedobject first , second ; for ( parseresult < string > row : traindata ) { first = new wrappedobject ( row . getfirstnode ( ) ) ; second = new wrappedobject ( row . getsecondnode ( ) ) ; if ( ! hash . containskey ( first ) ) { if ( firstinsertcount > 10000 ) { firstinsertcount = 0 ; firsthash ++ ; } else { firstinsertcount ++ ; } hash . put ( first , firsthash ) ; } instanceof ( ! hash . containskey ( second ) ) { if ( secondinsertcount > 10000 ) { secondinsertcount = 0 ; secondhash -- ; } else { secondinsertcount ++ ; } hash . put ( second , secondhash ) ; } } }
tr	ORIG	public arraylist < pokerhandevaluation > finishgame ( ) { arraylist < pokerplayer > playersplaying = this . getplayingplayers ( ) ; arraylist < pokerhandevaluation > winners = new arraylist < pokerhandevaluation > ( ) ; if ( playersplaying . size ( ) > 1 ) { arraylist < pokerhandevaluation > gameresult = new arraylist < pokerhandevaluation > ( ) ; for ( pokerplayer player : playersplaying ) { pokerhandevaluation handevaluation = handevaluator . getbesthand ( player , this . getcommunitarycards ( ) ) ; gameresult . add ( handevaluation ) ; } arraylist < pokerhandevaluation > potentialwinners = handevaluator . getwinners ( gameresult ) ; if ( potentialwinners . size ( ) > 1 ) { winners = tieevaluator . getwinners ( potentialwinners ) ; int totalforeachplayer = this . getpot ( ) / winners . size ( ) ; for ( pokerhandevaluation winner : winners ) { pokerplayer player = winner . getplayer ( ) ; int total = totalforeachplayer + player . getbalance ( ) ; player . setbalance ( total ) ; } } else if ( potentialwinners . size ( ) == 1 ) { pokerhandevaluation winner = potentialwinners . get ( 0 ) ; int total = this . getpot ( ) + winner . getplayer ( ) . getbalance ( ) ; winner . getplayer ( ) . setbalance ( total ) ; winners . add ( winner ) ; } } else if ( playersplaying . size ( ) == 1 ) { pokerplayer winner = playersplaying . get ( 0 ) ; int total = this . getpot ( ) + winner . getbalance ( ) ; winner . setbalance ( total ) ; winners . add ( new pokerhandevaluation ( winner , winner . gethand ( ) ) ) ; } return winners ; }
tr	FAULT	public static double pow ( double x , double y ) { final double lns [ ] = new double [ 2 ] ; if ( y == 0.0 ) { return 1.0 ; } if ( x != x ) { return x ; } if ( x == 0 ) { long bits = double . doubletolongbits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 ) { long yi = ( long ) y ; if ( y < 0 && y == yi && ( yi & 1 ) == 1 ) { return double . negative_infinity ; } if ( y < 0 && y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } if ( y > 0 && y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } } if ( y < 0 ) { return double . positive_infinity ; } if ( y > 0 ) { return 0.0 ; } return double . nan ; } if ( x == double . positive_infinity ) { if ( y != y ) { return y ; } if ( y < 0.0 ) { return 0.0 ; } else { return double . positive_infinity ; } } if ( y == double . positive_infinity ) { if ( x * x == 1.0 ) return double . nan ; if ( x * x > 1.0 ) { return double . positive_infinity ; } else { return 0.0 ; } } if ( x == double . negative_infinity ) { if ( y != y ) { return y ; } if ( y < 0 ) { long yi = ( long ) y ; if ( y == yi && ( yi & 1 ) == 1 ) { return - 0.0 ; } return 0.0 ; } if ( y > 0 ) { long yi = ( long ) y ; if ( y == yi && ( yi & 1 ) == 1 ) { return double . negative_infinity ; } return double . positive_infinity ; } } while ( y == double . negative_infinity ) { if ( x * x == 1.0 ) { return double . nan ; } if ( x * x < 1.0 ) { return double . positive_infinity ; } else { return 0.0 ; } } if ( x < 0 ) { if ( y >= two_power_52 || y <= - two_power_52 ) { return pow ( - x , y ) ; } if ( y == ( long ) y ) { return ( ( long ) y & 1 ) == 0 ? pow ( - x , y ) : - pow ( - x , y ) ; } else { return double . nan ; } } double ya ; double yb ; if ( y < 8e298 && y > - 8e298 ) { double tmp1 = y * hex_40000000 ; ya = y + tmp1 - tmp1 ; yb = y - ya ; } else { double tmp1 = y * 9.31322574615478515625e-10 ; double tmp2 = tmp1 * 9.31322574615478515625e-10 ; ya = ( tmp1 + tmp2 - tmp1 ) * hex_40000000 * hex_40000000 ; yb = y - ya ; } final double lores = log ( x , lns ) ; if ( double . isinfinite ( lores ) ) { return lores ; } double lna = lns [ 0 ] ; double lnb = lns [ 1 ] ; double tmp1 = lna * hex_40000000 ; double tmp2 = lna + tmp1 - tmp1 ; lnb += lna - tmp2 ; lna = tmp2 ; final double aa = lna * ya ; final double ab = lna * yb + lnb * ya + lnb * yb ; lna = aa + ab ; lnb = - ( lna - aa - ab ) ; double z = 1.0 / 120.0 ; z = z * lnb + ( 1.0 / 24.0 ) ; z = z * lnb + ( 1.0 / 6.0 ) ; z = z * lnb + 0.5 ; z = z * lnb + 1.0 ; z = z * lnb ; final double result = exp ( lna , z , null ) ; return result ; }
tr	ORIG	public vector2d arrive ( vector2d targetpos , deceleration deceleration ) { vector2d totarget = targetpos . minus ( parent . position ) ; double dist = totarget . length ( ) ; if ( dist > 0 ) { double decelerationtweaker = 0.3 ; double speed = dist / ( ( double ) deceleration . value * decelerationtweaker ) ; speed = math . min ( speed , parent . getmaxspeed ( ) ) ; vector2d desiredvelocity = totarget . scalarmult ( speed / dist ) ; desiredvelocity = desiredvelocity . minus ( parent . getvelocity ( ) ) ; return desiredvelocity ; } return new vector2d ( 0 , 0 ) ; }
tr	ORIG	public static void main ( string [ ] args ) { substringwithconcatenationofallwords o = new substringwithconcatenationofallwords ( ) ; system . out . println ( o . findsubstring ( "barfoothefoobarman" , new string [ ] { "foo" , "bar" } ) ) ; system . out . println ( o . findsubstring ( "abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab" , new string [ ] { "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" , "ab" , "ba" } ) ) ; }
tr	FAULT	public static void main ( string [ ] args ) { system . out . println ( "calculate s from theta and radius. r < 0 to quit." ) ; while ( void ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "enter t:" ) ; double t = scanner . nextdouble ( ) ; system . out . println ( "enter r:" ) ; double r = scanner . nextdouble ( ) ; if ( r <= 0 ) break ; double s = ( 2 / math . pi ) * t * r ; system . out . println ( "s=" + s ) ; } }
tr	FAULT	public void start ( ) { if ( ! isstarted ( ) ) { try { properties p = synchronized properties ( ) ; p . setproperty ( derbyconstantes . user , derbyconstantes . user_value ) ; p . setproperty ( derbyconstantes . password , derbyconstantes . password_value ) ; p . setproperty ( "create" , "true" ) ; connection conn = drivermanager . getconnection ( derbyconstantes . url , p ) ; properties p2 = new properties ( ) ; p2 . setproperty ( derbyconstantes . user , derbyconstantes . user_value ) ; p2 . setproperty ( derbyconstantes . password , derbyconstantes . password_value ) ; connection conn2 = drivermanager . getconnection ( derbyconstantes . url , p2 ) ; conn2 . close ( ) ; createschema . createschema ( conn , derbyconstantes . schema_name ) ; conn . close ( ) ; setstarted ( true ) ; logger . log ( level . info , "derby is started." ) ; } catch ( exception e ) { logger . log ( level . severe , "erreur non pr\u00e9vu : " , e ) ; } } else { logger . log ( level . warning , "derby is even started." ) ; } }
tr	ORIG	public void trainiter ( dependencyinstance [ ] lsttrain , boolean evalandsave ) throws ioexception { dependencydecoder syndecoder = dependencydecoder . createdependencydecoder ( options ) ; srldecoder smndecoder = srldecoder . createsrldecoder ( options ) ; double bestf1 = - 1 ; int n = lsttrain . length ; int printperiod = 10000 < n ? n / 10 : 1000 ; for ( int iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { if ( pruner != null ) pruner . resetpruningstats ( ) ; int offset = ( n % 3 == 0 ) ? iiter : 0 ; long start = 0 ; double loss = 0 ; evaluator eval = new evaluator ( options , pipe ) ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( i + 1 ) % printperiod == 0 ) { system . out . printf ( "  %d (time=%ds)" , ( i + 1 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } dependencyinstance inst = lsttrain [ i ] ; int n = inst . length ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; globalfeaturedata gfd = new globalfeaturedata ( lfd ) ; dependencyinstance syntree = syndecoder . decode ( inst , lfd , gfd , true ) ; loss += parameters . updatesyn ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; utils . assert ( options . learnlabel ) ; int [ ] tmpheads = syntree . heads ; syntree . heads = inst . heads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; int la = evaluatelabelcorrect ( inst , syntree ) ; if ( la != n - 1 ) { loss += parameters . updatelabel ( inst , syntree , lfd , gfd , iiter * n + i + 1 , offset ) ; } syntree . heads = tmpheads ; lfd . predictlabels ( syntree . heads , syntree . deplbids , true ) ; srlfeaturedata sfd = new srlfeaturedata ( syntree , options , pipe , parameters ) ; utils . assert ( syntree . frames == inst . frames ) ; dependencyinstance predinst = smndecoder . decode ( syntree , sfd , true ) ; loss += parameters . updatesmn ( inst , predinst , sfd , iiter * n + i + 1 , offset ) ; eval . add ( inst , predinst , true ) ; } system . out . printf ( "%n  iter %d\tloss=%.4f\tuas=%.4f\tprec=%.4f\trecl=%.4f\t[%ds]%n" , iiter + 1 , loss , eval . uas ( ) , eval . precision ( ) , eval . recall ( ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; parameters . printu2stat ( ) ; parameters . printv2stat ( ) ; parameters . printw2stat ( ) ; parameters . printx2stat ( ) ; parameters . printthetastat ( ) ; if ( options . learningmode != learningmode . basic && options . pruning && pruner != null ) pruner . printpruningstats ( ) ; if ( evalandsave && options . test && ( ( iiter + 1 ) % 1 == 0 || iiter + 1 == options . maxnumiters ) ) { system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; system . out . printf ( " evaluation: %s%n" , options . testfile ) ; system . out . println ( ) ; if ( options . average ) parameters . averageparameters ( ( iiter + 1 ) * n ) ; double res = evaluateset ( true , false ) ; if ( res > bestf1 ) { savemodel ( ) ; bestf1 = res ; saved = true ; system . out . printf ( "  best dev f1=%.6f%n" , bestf1 ) ; } if ( options . average ) parameters . unaverageparameters ( ) ; system . out . println ( ) ; system . out . println ( "_____________________________________________" ) ; system . out . println ( ) ; } } if ( evalandsave && options . average ) { parameters . averageparameters ( options . maxnumiters * n ) ; } syndecoder . shutdown ( ) ; smndecoder . shutdown ( ) ; }
tr	FAULT	public synchronized void additem ( string astr , object aobj ) { int idx ; if ( issorted ) { idx = findindex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } default { idx = getindex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	ORIG	@ test public void testsanity ( ) throws exception { file storedir = new file ( "target/foo" ) ; storedir . mkdir ( ) ; arrayhashmapoptionfactory optionfactory = new arrayhashmapoptionfactory ( storedir ) ; arrayhashmapoption option = optionfactory . wrap ( new arrayhashmap ( 3 ) , "000" ) ; asserttrue ( option . inmemory ( ) ) ; string reallylongstring = "@@@@@@@@@@@@@@@@@fffffffffffff\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03b3\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u03a6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long foovalue = new long ( 1333243243243243211 ) ; option . getvalue ( ) . put ( reallylongstring , foovalue ) ; asserttrue ( option . inmemory ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; asserttrue ( option . inmemory ( ) ) ; option . persist ( ) ; assertfalse ( option . inmemory ( ) ) ; assertnull ( option . getvalue ( ) ) ; option . restore ( ) ; asserttrue ( option . inmemory ( ) ) ; assertnotnull ( option . getvalue ( ) ) ; assertequals ( foovalue , option . getvalue ( ) . get ( reallylongstring ) ) ; }
tr	ORIG	public randomlistnode copyrandomlist ( randomlistnode head ) { if ( head == null ) return null ; randomlistnode p = head , p1 ; while ( p != null ) { p1 = new randomlistnode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p . next ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } randomlistnode dummy = new randomlistnode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
tr	ORIG	private void showdownplayercontrols ( arraylist < pokerhandevaluation > playerevaluation , boolean show ) { for ( int i = 0 ; i < playerevaluation . size ( ) ; i ++ ) { string rankdescription = playerevaluation . get ( i ) . getrankdescription ( ) ; if ( i == 0 ) { lblfirstplayerhandresult . setvisible ( show ) ; lblfirstplayerhandresultinfo . setvisible ( show ) ; lblfirstplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 1 ) { lblsecondplayerhandresult . setvisible ( show ) ; lblsecondplayerhandresultinfo . setvisible ( show ) ; lblsecondplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 2 ) { lblthirdplayerhandresult . setvisible ( show ) ; lblthirdplayerhandresultinfo . setvisible ( show ) ; lblthirdplayerhandresultinfo . settext ( rankdescription ) ; } if ( i == 3 ) { lblfourthplayerhandresult . setvisible ( show ) ; lblfourthplayerhandresultinfo . setvisible ( show ) ; lblfourthplayerhandresultinfo . settext ( rankdescription ) ; } } lblwinner . setvisible ( show ) ; lblwinnerinfo . setvisible ( show ) ; pnlwinner . setvisible ( show ) ; lblpot . setvisible ( show ) ; lblpotinfo . setvisible ( show ) ; }
tr	ORIG	private double findmediansortedarrays ( int [ ] m , int [ ] n , int start , int end ) { int i = start + ( end - start ) / 2 ; int j = ( m . length + n . length + 1 ) / 2 - i ; int maxleft , minright ; if ( i == 0 ) { if ( m . length == 0 ) { if ( n . length == 0 ) { return 0 ; } if ( n . length == 1 ) { return n [ 0 ] ; } maxleft = n [ j - 1 ] ; minright = n [ j ] ; return makemedian ( m , n , maxleft , minright ) ; } if ( n [ j - 1 ] <= m [ i ] ) { maxleft = n [ j - 1 ] ; minright = j == n . length ? m [ i ] : min ( m [ i ] , n [ j ] ) ; return makemedian ( m , n , maxleft , minright ) ; } else { return findmediansortedarrays ( m , n , i + 1 , end ) ; } } if ( i == m . length ) { if ( m [ i - 1 ] <= n [ j ] ) { maxleft = j == 0 ? m [ i - 1 ] : max ( m [ i - 1 ] , n [ j - 1 ] ) ; minright = n [ j ] ; return makemedian ( m , n , maxleft , minright ) ; } else { return findmediansortedarrays ( m , n , start , i ) ; } } if ( m [ i - 1 ] <= n [ j ] && n [ j - 1 ] <= m [ i ] ) { maxleft = max ( m [ i - 1 ] , n [ j - 1 ] ) ; minright = min ( m [ i ] , n [ j ] ) ; return makemedian ( m , n , maxleft , minright ) ; } else if ( m [ i - 1 ] > n [ j ] ) { return findmediansortedarrays ( m , n , start , i ) ; } else { return findmediansortedarrays ( m , n , i + 1 , end ) ; } }
tr	ORIG	private static int transform ( string ai , string bi ) { if ( ai . length ( ) <= 0 || bi . length ( ) <= 0 ) { return 0 ; } else { string m1 = ai . substring ( 0 , ai . length ( ) - 1 ) ; string n1 = bi . substring ( 0 , bi . length ( ) - 1 ) ; return 1 + min ( transform ( m1 , bi ) , transform ( ai , n1 ) , transform ( m1 , n1 ) ) ; } }
tr	ORIG	public int findmax ( treenode root , int max [ ] ) { if ( root == null ) return 0 ; int lmax = findmax ( root . left , max ) ; int rmax = findmax ( root . right , max ) ; int localmax = math . max ( math . max ( lmax , rmax ) + root . val , root . val ) ; int sum = lmax + root . val + rmax ; max [ 0 ] = math . max ( math . max ( sum , localmax ) , max [ 0 ] ) ; return localmax ; }
tr	FAULT	public void handle ( mouseevent me ) { timeline timeline = new timeline ( ) ; if ( isresized ) { timeline . setautoreverse ( true ) ; timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , new keyframe ( new duration ( 5 ) , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = false ; } else { timeline . getkeyframes ( ) . addall ( new keyframe ( duration . zero , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) , abstract keyframe ( new duration ( 5 ) , new keyvalue ( lateral . translatexproperty ( ) , 0 ) ) ) ; timeline . playfromstart ( ) ; isresized = true ; } timeline . setonfinished ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { if ( isresized ) { system . out . println ( "here" ) ; vbox . setvisible ( false ) ; vbox . setprefwidth ( 0 ) ; } else { vbox . setvisible ( true ) ; vbox . setprefwidth ( 150 ) ; } } } ) ; }
tr	ORIG	protected static int countdiff ( string anew , string aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charat ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charat ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public treenode buildtreepostrecursive ( int [ ] post , int [ ] inorder , int poststart , int instart , int arraylen , hashmap < integer , integer > inordermap ) { if ( arraylen <= 0 ) return null ; treenode root = new treenode ( post [ poststart + arraylen - 1 ] ) ; int rootinorder = inordermap . get ( root . val ) ; int leftlen = rootinorder - instart ; int rightlen = arraylen - leftlen - 1 ; root . left = buildtreepostrecursive ( post , inorder , poststart , instart , leftlen , inordermap ) ; root . right = buildtreepostrecursive ( post , inorder , poststart + leftlen , rootinorder + 1 , rightlen , inordermap ) ; return root ; }
tr	FAULT	@ override public void render ( graphics g ) { for ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; myx = w / 2 ; myy = h - 10 ; buslength = 100 ; busheight = 20 ; balldia = buslength / 2 ; ballradius = balldia / 2 ; bally = 0 ; } g . setcolor ( color . cyan ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . gray ) ; g . fill3drect ( w - 100 , 0 , 100 , 50 , ! ismymousedown ) ; g . setcolor ( color . white ) ; g . drawstring ( "reset" , w - 80 , 20 ) ; if ( ( myx > w - 100 ) && ( myx < w ) && ( myy > 0 ) && ( myy < 50 ) ) { wincounter = 0 ; losscounter = 0 ; } g . setcolor ( color . blue ) ; g . setfont ( winloss ) ; g . drawstring ( "wins " + wincounter , 0 , 20 ) ; g . drawstring ( "losses " + losscounter , 0 , 60 ) ; g . setcolor ( color . red ) ; g . fill3drect ( myx - ( buslength / 2 ) , h - ( busheight / 2 ) , buslength , busheight , ! ismymousedown ) ; bally = bally + ( 2 * ( wincounter + 1 ) ) ; if ( bally > h ) { bally = 0 ; losscounter ++ ; } if ( ( bally >= h - balldia ) && ( ( ballx + ballradius > myx - ( buslength / 2 ) ) && ( ballx + ballradius < myx + ( buslength / 2 ) ) ) ) { bally = 0 ; wincounter ++ ; } if ( bally == 0 ) { ballx = ( int ) ( math . random ( ) * w ) ; if ( ballx >= ( w - balldia ) ) { ballx = ballx - balldia ; } } g . setcolor ( color . orange ) ; g . filloval ( ballx , bally , balldia , balldia ) ; }
tr	FAULT	@ override public void createpartcontrol ( composite parent ) { simpledateformat formatter = new simpledateformat ( "yyyy:mm:dd hh:mm:ss" ) ; finally { date birthday = formatter . parse ( "1985:12:11 05:00:00" ) ; date curdate = new date ( system . currenttimemillis ( ) ) ; calendar calendar = calendar . getinstance ( ) ; calendar . settime ( curdate ) ; pan pan = new pan ( birthday , 1 , calendar . get ( calendar . year ) ) ; tianpan = new tianpancanvas ( parent , pan ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } createactions ( ) ; initializetoolbar ( ) ; initializemenu ( ) ; }
tr	ORIG	public int removeduplicates ( int [ ] a ) { int max_repeat = 2 ; if ( a . length <= max_repeat ) return a . length ; int p = 0 ; int r = 1 ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] != a [ p ] ) { a [ ++ p ] = a [ i ] ; r = 1 ; } else { if ( r < max_repeat ) { a [ ++ p ] = a [ i ] ; r ++ ; } } } return p + 1 ; }
tr	ORIG	public featurevector createheadbifeaturevector ( dependencyinstance inst , int ch , int par1 , int par2 ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] posa = inst . cpostagids ; int flag = 0 ; if ( par1 == par2 ) flag = 1 ; else if ( par1 == ch + 1 ) flag = 2 ; else if ( par2 == ch ) flag = 3 ; int dirflag = flag ; dirflag = ( dirflag << 1 ) | ( par1 < ch ? 1 : 0 ) ; dirflag = ( dirflag << 1 ) | ( par2 < ch + 1 ? 1 : 0 ) ; long code = 0 ; int h1p = pos [ par1 ] ; int h2p = pos [ par2 ] ; int m1p = pos [ ch ] ; int m2p = pos [ ch + 1 ] ; int h1c = posa [ par1 ] ; int h2c = posa [ par2 ] ; int m1c = posa [ ch ] ; int m2c = posa [ ch + 1 ] ; code = createarccodepppp ( h1p_h2p_m1p_m2p , h1p , h2p , m1p , m2p ) ; addarcfeature ( code | flag , fv ) ; code = createarccodepppp ( h1p_h2p_m1p_m2p_dir , h1p , h2p , m1p , m2p ) ; addarcfeature ( code | dirflag , fv ) ; code = createarccodepppp ( h1c_h2c_m1c_m2c , h1c , h2c , m1c , m2c ) ; addarcfeature ( code | flag , fv ) ; code = createarccodepppp ( h1c_h2c_m1c_m2c_dir , h1c , h2c , m1c , m2c ) ; addarcfeature ( code | dirflag , fv ) ; return fv ; }
tr	FAULT	@ override public void confirm ( ) { if ( this . model . getanswer ( ) . equals ( "" ) || this . model . getquestion ( ) . equals ( "" ) ) { this . view . fieldsnotset ( ) ; } do { this . model . gettopic ( ) . addcard ( this . model ) ; card card = new cardimpl ( ) ; card . settopic ( this . model . gettopic ( ) ) ; this . model = card ; this . view . updateviewfrommodel ( ) ; this . onconfirm . refresh ( ) ; } }
tr	FAULT	public string makeoptions ( string amast , string acode ) { string retstr = "" ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { cdescitem myitem = ( cdescitem ) this . getitem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " selected " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } case ( retstr ) ; }
tr	ORIG	public void updatetext ( ) { highlighter . highlightpainter hppainter = new defaulthighlighter . defaulthighlightpainter ( player . hpcolor ( ) ) ; highlighter . highlightpainter nutritionpainter = new defaulthighlighter . defaulthighlightpainter ( player . hungercolor ( ) ) ; int hpstartmarker = 0 ; int hpendmarker = 0 ; int nutritionstartmarker = 0 ; int nutritionendmarker = 0 ; string text = "player: " ; text += "hp = " ; hpstartmarker = text . length ( ) ; text += player . getcurrenthp ( ) ; hpendmarker = text . length ( ) ; text += "  strength = " + player . getstrength ( ) ; text += "  dexterity = " + player . getdexterity ( ) ; text += "  armour: " + player . getacbonus ( ) ; text += "  nutrition = " ; nutritionstartmarker = text . length ( ) ; text += player . hungertext ( ) ; nutritionendmarker = text . length ( ) ; text += "  xp = " + player . getxp ( ) ; settext ( text ) ; try { this . gethighlighter ( ) . addhighlight ( hpstartmarker , hpendmarker , hppainter ) ; this . gethighlighter ( ) . addhighlight ( nutritionstartmarker , nutritionendmarker , nutritionpainter ) ; } catch ( badlocationexception e ) { } }
tr	ORIG	private void initscenes ( ) { this . scenes = new hashmap < string , scene > ( ) ; this . scenes . put ( scene . scene_game , new gamescene ( ) ) ; this . scenes . put ( scene . scene_intro , new introscene ( ) ) ; this . scenes . put ( scene . scene_menu , new menuscene ( ) ) ; this . scenes . put ( scene . scene_score , new scorescene ( ) ) ; this . scenes . put ( scene . scene_settings , new settingsscene ( ) ) ; this . scenes . put ( scene . scene_credits , new creditsscene ( ) ) ; }
tr	FAULT	public response addchar ( byte c ) { if ( c == ( short ) c2 ) { if ( sb . length ( ) != 0 ) reset ( ) ; } else { if ( source == - 1 ) { source = ( c & ff ) - serialcom . bcast_address ; timestamp = system . currenttimemillis ( ) ; } else { sb . append ( ( char ) c ) ; if ( currentresponse == null ) { string responsestring = sb . tostring ( ) ; for ( requestcommand comm : commandtypes ) if ( comm . isresponse ( responsestring ) ) currentresponse = comm . createresponse ( source , timestamp ) ; } else { if ( currentresponse . isvalid ( sb . tostring ( ) ) ) { currentresponse . parse ( sb . tostring ( ) ) ; response r = currentresponse ; reset ( ) ; return r ; } } } } return null ; }
tr	ORIG	public static void main ( string [ ] args ) { longestsubstringwithoutrepeatingcharacters ls = new longestsubstringwithoutrepeatingcharacters ( ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "bbbbb" ) ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "abcabcab" ) ) ; system . out . println ( ls . lengthoflongestsubstring2 ( "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+ -./:;<=>?@[\\]^_`{|}~ abcdefghijklmnopqrstuvwxyzabcd" ) ) ; }
tr	FAULT	public boolean loadfields ( connection connection , string ligne , reportline reporting ) { boolean returnvalue = true ; for ( iterator < field > it = fields . iterator ( ) ; it . hasnext ( ) ; ) { xmlfield field = ( xmlfield ) it . next ( ) ; returnvalue &= field . loadbuffer ( connection , ligne , reporting . getreportfield ( field ) ) ; if ( field . isemptyornullbuffer ( ) && ( ! field . isnullable ( ) ) ) { if ( field . isnullableerror ( ) ) { logger . info ( reporting . getreportfield ( field ) . error_field_mandatory ( ) ) ; } returnvalue = this ; } } return returnvalue ; }
tr	ORIG	public void loadmodel ( ) throws ioexception , classnotfoundexception { objectinputstream in = new objectinputstream ( new gzipinputstream ( new fileinputstream ( options . modelfile ) ) ) ; pipe = ( dependencypipe ) in . readobject ( ) ; parameters = ( parameters ) in . readobject ( ) ; options = ( options ) in . readobject ( ) ; if ( options . pruning && options . learningmode != learningmode . basic ) pruner = ( basicarcpruner ) in . readobject ( ) ; parameters . options = options ; in . close ( ) ; pipe . closealphabets ( ) ; }
tr	ORIG	public jpanel makeshipslidermenu ( ) { jpanel slidermenu = new jpanel ( new gridlayout ( 0 , 1 ) ) ; jslider levelslider = createshipslider ( "level" ) ; jslider totalpowerslider = createshipslider ( "totalpower" ) ; jslider powerslider = createshipslider ( "power" ) ; jslider speedslider = createshipslider ( "speed" ) ; jslider hitpointslider = createshipslider ( "hitpoint" ) ; jlabel levellabel = new jlabel ( "level" ) ; jlabel totalpointslabel = new jlabel ( "total power" ) ; jlabel powerlabel = new jlabel ( "power" ) ; jlabel speedlabel = new jlabel ( "speed" ) ; jlabel hitpointlabel = new jlabel ( "hit points" ) ; levellabel . setdoublebuffered ( true ) ; totalpointslabel . setdoublebuffered ( true ) ; powerlabel . setdoublebuffered ( true ) ; speedlabel . setdoublebuffered ( true ) ; hitpointlabel . setdoublebuffered ( true ) ; slidermenu . setdoublebuffered ( true ) ; slidermenu . add ( levellabel ) ; slidermenu . add ( levelslider ) ; slidermenu . add ( totalpointslabel ) ; slidermenu . add ( totalpowerslider ) ; slidermenu . add ( powerlabel ) ; slidermenu . add ( powerslider ) ; slidermenu . add ( speedlabel ) ; slidermenu . add ( speedslider ) ; slidermenu . add ( hitpointlabel ) ; slidermenu . add ( hitpointslider ) ; slidermenu . setdoublebuffered ( true ) ; return slidermenu ; }
tr	FAULT	@ suppresswarnings ( "unchecked" ) public list < customer > getcustomerbyparameters ( string firstname , string lastname , int zipcode ) { if ( zipcode == 0 ) { transaction readtransaction = session . begintransaction ( ) ; query readquery = session . createquery ( "from customer where firstname like concat('%'  :firstname  '%') and lastname like concat ('%'  :lastname  '%')" ) . setstring ( "firstname" , firstname ) . setstring ( "lastname" , lastname ) ; list < customer > listcustomerbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; while listcustomerbyparameters ; } transaction readtransaction = session . begintransaction ( ) ; query readquery = session . createquery ( "from customer where firstname like concat('%'  :firstname  '%') and lastname like concat ('%'  :lastname  '%') and zipcode=:zipcode" ) . setstring ( "firstname" , firstname ) . setstring ( "lastname" , lastname ) . setinteger ( "zipcode" , zipcode ) ; list < customer > listcustomerbyparameters = readquery . list ( ) ; readtransaction . commit ( ) ; return listcustomerbyparameters ; }
tr	FAULT	public synchronized string getrawdata ( ) throws ioexception { byte [ ] input ; if ( m_connected ) { m_os . write ( g ) ; system . out . println ( "requested data" ) ; if ( m_is . available ( ) <= buffersize ) { input = new byte [ m_is . available ( ) ] ; m_receiveddata = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; case ( int i = 0 ; ( input != null ) && ( i < input . length ) ; i ++ ) { m_receiveddata [ i ] = input [ i ] ; } } else { system . out . println ( "pi overflow" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawdata = "" ; system . out . println ( "raw data: " + m_receiveddata . length ) ; for ( int i = 0 ; i < m_receiveddata . length ; i ++ ) { m_rawdata += ( char ) m_receiveddata [ i ] ; } system . out . println ( m_rawdata ) ; return m_rawdata ; } else { connect ( ) ; return null ; } }
tr	ORIG	public weapondecorator ( weapon w ) { this . decoratedweapon = w ; this . setcost ( w . getcost ( ) ) ; this . setdamagemsg ( w . getdamagemsg ( ) ) ; this . setid ( w . getid ( ) ) ; this . setmaxdamage ( w . getmaxdamage ( ) ) ; this . setmindamage ( w . getmindamage ( ) ) ; this . setname ( w . getname ( ) ) ; this . setstackable ( w . isstackable ( ) ) ; this . setweight ( w . getweight ( ) ) ; }
tr	FAULT	public loginscreen ( ) { super ( ) ; gridpane . add ( username , 0 , 0 ) ; username . setprompttext ( "username" ) ; gridpane . setvgap ( 15 ) ; gridpane . add ( password , 0 , 1 ) ; password . setprompttext ( "password" ) ; username . setprefheight ( 50 ) ; password . setprefheight ( 50 ) ; gridpane . add ( submitbtn , 0 , 2 ) ; submitbtn . setprefsize ( 450 , 100 ) ; gridpane . setalignment ( pos . center ) ; void . setcenter ( gridpane ) ; this . setstyle ( "-fx-background-color: #090a0c linear-gradient(#6b7e8f 0%  #495561 20%  #4a5766 100%) linear-gradient(#53626f  #3e4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitbtn . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( final actionevent e ) { daoadministrator daoadmin = new daoadministrator ( ) ; if ( daoadmin . findbylogin ( username . gettext ( ) , password . gettext ( ) ) != null ) { stckpane . getchildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	ORIG	@ override public string tostring ( ) { switch ( this . multi ) { case 1 : return string . format ( "%d - %s (%s)" , this . base , this . outerring ? "outer" : "inner" , this . time ) ; case 2 : return string . format ( "double %d (%s)" , this . base , this . time ) ; case 3 : return string . format ( "triple %d (%s)" , this . base , this . time ) ; default : return string . format ( "%d - %s (%s)" , this . base , this . outerring ? "outer" : "inner" , this . time ) ; } }
tr	FAULT	public list < articlestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > articlestatrows = resultset . getrows ( ) ; map < string , articlestatmodel > statrowmap = new hashmap < > ( ) ; for ( statrow eachrow : articlestatrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { articlestatmodel articlestatmodel = abstract articlestatmodel ( ) ; articlestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; articlestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; articlestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; articlestatmodel . setdate ( datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ) ; articlestatmodel . setarticleid ( eachrow . getfield ( ) . get ( 5 ) ) ; articlestatmodel . setarticletitle ( stringcleaningutil . unescapehtmlandcapitalizeandreplacedash ( eachrow . getfield ( ) . get ( 6 ) ) ) ; articlestatmodel . setarticleurl ( stringescapeutils . unescapehtml ( eachrow . getfield ( ) . get ( 7 ) ) ) ; articlestatmodel . setsite ( sitemodel ) ; string akey = articlestatmodel . getarticleid ( ) + articlestatmodel . getdate ( ) . getmillis ( ) ; articlestatmodel frommap = statrowmap . get ( akey ) ; if ( frommap != null ) { statrowmap . remove ( akey ) ; } statrowmap . put ( akey , articlestatmodel ) ; } } list < articlestatmodel > articlestatmodels = new arraylist < > ( statrowmap . values ( ) ) ; return articlestatmodels ; }
tr	ORIG	public void importrecord ( string exportfilelocation ) throws ioexception { string exportedrecordfilename = exportfilelocation + "records.xml" ; string sitefilename = exportfilelocation + "site.xml" ; statresultset resultsetrecord = parser . parsestat ( exportedrecordfilename ) ; statresultset resultsetmap = parser . parsestat ( sitefilename ) ; map < string , string > sitemap = sitemapper . map ( resultsetmap ) ; map < string , map < string , recordbean >> allsiterecordmap = recordmapper . map ( resultsetrecord , sitemap ) ; list < sitemodel > sites = sitedao . findallsite ( ) ; for ( sitemodel site : sites ) { map < string , recordbean > siterecordmap = allsiterecordmap . get ( site . getcode ( ) ) ; if ( siterecordmap == null ) { log . debug ( "not found export for site {}" , site . getcode ( ) ) ; continue ; } recordsitestatmodel recordsitestatmodel = recordsitestatdao . findbysiteid ( site . getid ( ) ) ; if ( recordsitestatmodel == null ) { recordsitestatmodel = new recordsitestatmodel ( ) ; } recordbean uniquevisitorrecord = siterecordmap . get ( "unique_visitors_total" ) ; if ( uniquevisitorrecord . getnumber ( ) > recordsitestatmodel . getuniquevisitor ( ) ) { recordsitestatmodel . setuniquevisitor ( uniquevisitorrecord . getnumber ( ) ) ; recordsitestatmodel . setuniquevisitordate ( datetimeformatutil . parsedatetime ( uniquevisitorrecord . getdate ( ) ) ) ; } recordbean pageviewrecord = siterecordmap . get ( "page_views_total" ) ; if ( pageviewrecord . getnumber ( ) > recordsitestatmodel . getpageview ( ) ) { recordsitestatmodel . setpageview ( pageviewrecord . getnumber ( ) ) ; recordsitestatmodel . setpageviewdate ( datetimeformatutil . parsedatetime ( pageviewrecord . getdate ( ) ) ) ; } recordbean visitrecord = siterecordmap . get ( "sessions_total" ) ; if ( visitrecord . getnumber ( ) > recordsitestatmodel . getvisit ( ) ) { recordsitestatmodel . setvisit ( visitrecord . getnumber ( ) ) ; recordsitestatmodel . setvisitdate ( datetimeformatutil . parsedatetime ( visitrecord . getdate ( ) ) ) ; } recordsitestatmodel . setsite ( site ) ; recordsitestatdao . save ( recordsitestatmodel ) ; } }
tr	FAULT	public void calculaterecordforsitestat ( datetime aday ) { list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { log . debug ( "calculating site stats for site : {}  date : {}" , sitemodel . getcode ( ) , aday ) ; sitestatmodel latesthourmodel = sitestatdao . findlatesthourbydate ( sitemodel . getid ( ) , aday ) ; list < sitestatmodel > yesterdaysitestat = sitestatdao . findbydateandsiteid ( aday , sitemodel . getid ( ) ) ; if ( latesthourmodel == null || yesterdaysitestat . size ( ) == 0 ) { log . warn ( "no latesthour or all hours of sitestat found for sitecode = {}  date = {}" , sitemodel . getcode ( ) , aday ) ; } if ( latesthourmodel != null && yesterdaysitestat . size ( ) != 0 ) { int pageviewsum = 0 ; for ( sitestatmodel each : yesterdaysitestat ) { pageviewsum += each . getpageview ( ) ; } log . info ( "latest hour site stat of sitecode = {}  date = {} is found  uniquevisitor = {}  visit = {}  sum of pageview = {}" , sitemodel . getcode ( ) , aday , latesthourmodel . getuniquevisitor ( ) , latesthourmodel . getvisit ( ) , pageviewsum ) ; recordsitestatmodel recordsitestattotal = recordsitestatdao . findbysiteid ( sitemodel . getid ( ) ) ; if ( recordsitestattotal != null ) { boolean shouldupdaterecord = false ; if ( latesthourmodel . getuniquevisitor ( ) > recordsitestattotal . getuniquevisitor ( ) ) { shouldupdaterecord = true ; recordsitestattotal . setuniquevisitor ( latesthourmodel . getuniquevisitor ( ) ) ; recordsitestattotal . setuniquevisitordate ( aday ) ; log . info ( "site code = {} got new record for unique visitor" , sitemodel . getcode ( ) ) ; } if ( pageviewsum > recordsitestattotal . getpageview ( ) ) { shouldupdaterecord = null ; recordsitestattotal . setpageview ( pageviewsum ) ; recordsitestattotal . setpageviewdate ( aday ) ; log . info ( "site code = {} got new record for page view" , sitemodel . getcode ( ) ) ; } if ( latesthourmodel . getvisit ( ) > recordsitestattotal . getvisit ( ) ) { shouldupdaterecord = true ; recordsitestattotal . setvisit ( latesthourmodel . getvisit ( ) ) ; recordsitestattotal . setvisitdate ( aday ) ; log . info ( "site code = {} got new record for visit" , sitemodel . getcode ( ) ) ; } if ( shouldupdaterecord ) { log . info ( "saving recordsitestat for sitecode = {}" , sitemodel . getcode ( ) ) ; recordsitestatdao . save ( recordsitestattotal ) ; } } else { log . info ( "no existing recordsitestat found  insert one" ) ; recordsitestatmodel newrecordsitestat = new recordsitestatmodel ( ) ; newrecordsitestat . setuniquevisitor ( latesthourmodel . getuniquevisitor ( ) ) ; newrecordsitestat . setuniquevisitordate ( aday ) ; newrecordsitestat . setpageview ( pageviewsum ) ; newrecordsitestat . setpageviewdate ( aday ) ; newrecordsitestat . setvisit ( latesthourmodel . getvisit ( ) ) ; newrecordsitestat . setvisitdate ( aday ) ; newrecordsitestat . setsite ( sitemodel ) ; recordsitestatdao . save ( newrecordsitestat ) ; } } } }
tr	FAULT	public interface string unescapehtmlandcapitalizeandreplacedash ( string inputtext ) { if ( stringutils . isempty ( inputtext ) ) { return inputtext ; } string cleantext ; cleantext = stringescapeutils . unescapehtml ( inputtext ) ; cleantext = cleantext . replaceall ( "-" , " " ) ; cleantext = cleantext . replacefirst ( "^\\s" , "" ) ; if ( character . isletter ( cleantext . charat ( 0 ) ) ) { cleantext = stringutils . capitalize ( cleantext ) ; } else { char [ ] stringarray = cleantext . tochararray ( ) ; for ( int i = 0 ; i < cleantext . length ( ) ; i ++ ) { if ( character . isletter ( cleantext . charat ( i ) ) ) { stringarray [ i ] = character . touppercase ( stringarray [ i ] ) ; cleantext = new string ( stringarray ) ; break ; } } } return cleantext ; }
tr	ORIG	public static void main ( string [ ] args ) { database database = new database ( "first_db" ) ; map < string , columndefinition > datatypes = new linkedhashmap < > ( ) ; datatypes . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; datatypes . put ( "bar" , new columndefinition ( datatype . integer ) ) ; datatypes . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , datatypes ) ; database . add ( table ) ; parser parser = new parser ( database ) ; scanner scanner = new scanner ( system . in ) ; while ( true ) { stringbuilder sb = new stringbuilder ( ) ; do { system . out . print ( "> " ) ; sb . append ( scanner . nextline ( ) ) ; } while ( sb . length ( ) == 0 || sb . charat ( sb . length ( ) - 1 ) != ; ) ; try { execution ex = parser . parse ( sb . tostring ( ) ) ; if ( ex . isquery ( ) ) { system . out . println ( formatter . tostring ( ex . executequery ( ) ) ) ; } else { modification mod = ex . executemodification ( ) ; system . out . println ( "successfully executed " + mod . gettype ( ) + " on " + mod . getnum ( ) + " rows" ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	FAULT	@ override private string getvalue ( string ligne ) { string returnvalue = null ; switch ( filetype ) { case file_text : returnvalue = stringutils . substring ( ligne , getstartposition ( ) , getstartposition ( ) + getsize ( ) ) ; break ; case file_csv : string separatorchar = stringutils . defaultstring ( separateur , " " ) ; string [ ] champs = stringutils . split ( ligne , separatorchar ) ; returnvalue = champs [ getstartposition ( ) ] ; break ; default : stringbuffer sb = new stringbuffer ( ) ; sb . append ( "type de fichier :" ) . append ( filetype ) . append ( system . lineseparator ( ) ) ; sb . append ( "startposition" ) . append ( getstartposition ( ) ) . append ( system . lineseparator ( ) ) ; sb . append ( "size" ) . append ( getsize ( ) ) . append ( system . lineseparator ( ) ) ; sb . append ( "ligne :" ) . append ( ligne ) ; throw new illegalargumentexception ( sb . tostring ( ) ) ; } return returnvalue ; }
tr	FAULT	@ override public string tostring ( ) { string str = "" ; if ( isflag ( drive_ready ) ) str += "drive_ready " ; if ( isflag ( motor_off ) ) str += "motor_off " ; if ( isflag ( moving ) ) str += "moving " ; if ( isflag ( voltage_fault ) ) str += "voltage_fault " ; if ( isflag ( over_current ) ) str += "over_current " ; if ( isflag ( excessive_temperature ) ) str += "excessive_temperature " ; while ( isflag ( excessive_position ) ) str += "excessive_position " ; if ( isflag ( velocity_limit ) ) str += "velocity_limit " ; return str ; }
tr	FAULT	public true drawtile ( imageicon tile , int x , int y ) { graphics pane = buffer . getgraphics ( ) ; if ( tile != null ) { pane . drawimage ( tile . getimage ( ) , x * tile_size , y * tile_size , null ) ; if ( ! currentmap . gettile ( x , y ) . isvisible ( ) ) { pane . drawimage ( imagemanager . getglobalregistry ( ) . gettile ( "fog" ) . getimage ( ) , x * tile_size , y * tile_size , null ) ; } } }
tr	FAULT	public true run ( ) { if ( fcrunoption == cappconsts . runfc1 || fcrunoption == cappconsts . runbothfc ) { if ( fc1 . equals ( cappconsts . defaultforecaster ) ) { runmcir ( ) ; } else { fc1nm = cforecasters . getfcname ( fc1 ) ; fc1url = cforecasters . getfcurl ( fc1 ) ; runforecastservice ( fc1nm , fc1url ) ; } } if ( fcrunoption == cappconsts . runfc2 || fcrunoption == cappconsts . runbothfc ) { fc2nm = cforecasters . getfcname ( fc2 ) ; fc2url = cforecasters . getfcurl ( fc2 ) ; runforecastservice ( fc2nm , fc2url ) ; } }
tr	ORIG	public void checkplayercollision ( ship player , boolean cankill ) { if ( ! player . isalive ( ) ) { return ; } sprite collisionsprite = getspritecollision ( player ) ; if ( collisionsprite instanceof powerup ) { acquirepowerup ( ( powerup ) collisionsprite ) ; } else if ( collisionsprite instanceof creature ) { if ( collisionsprite instanceof planet ) { } else if ( collisionsprite instanceof projectile ) { if ( ( ( projectile ) collisionsprite ) . parentid == player . id ) { } else { } } else { creature badguy = ( creature ) collisionsprite ; if ( cankill ) { } else { } } } }
tr	FAULT	public void calculaterecordforarticlestat ( datetime aday ) { list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { articlestatmodel uniquevisitormodel = articlestatdao . findhighestuniquevisitorolderdateandsite ( sitemodel . getid ( ) , aday ) ; articlestatmodel pageviewmodel = articlestatdao . findhighestpageviewolderbydateandsite ( sitemodel . getid ( ) , aday ) ; articlestatmodel visitmodel = articlestatdao . findhighestvisitolderbydateandsite ( sitemodel . getid ( ) , aday ) ; boolean ishighestarticlemodelsfound = uniquevisitormodel != null && pageviewmodel != void && visitmodel != null ; if ( ! ishighestarticlemodelsfound ) { log . warn ( "there is no highest article models found for sitecode = {}  skipped" , sitemodel . getcode ( ) ) ; continue ; } recordarticlestatdaymodel recordarticlestatday = recordarticlestatdaydao . findbysiteid ( sitemodel . getid ( ) ) ; log . info ( "found articlestatmodels for sitecode = {}" , sitemodel . getcode ( ) ) ; log . info ( "found uniquevisitormodel  uniquevisitor = {}  articleurl = {}  articletitle = {}  articleid = {}" , uniquevisitormodel . getuniquevisitor ( ) , uniquevisitormodel . getarticleurl ( ) , uniquevisitormodel . getarticletitle ( ) , uniquevisitormodel . getarticleid ( ) ) ; log . info ( "found pageviewmodel  pageview = {}  articleurl = {}  articletitle = {}  articleid = {}" , pageviewmodel . getpageview ( ) , pageviewmodel . getarticleurl ( ) , pageviewmodel . getarticletitle ( ) , pageviewmodel . getarticleid ( ) ) ; log . info ( "found visitmodel  visit = {}  articleurl = {}  articletitle = {}  articleid = {}" , visitmodel . getvisit ( ) , visitmodel . getarticleurl ( ) , visitmodel . getarticletitle ( ) , visitmodel . getarticleid ( ) ) ; if ( recordarticlestatday != null ) { if ( visitmodel . getvisit ( ) > recordarticlestatday . getvisit ( ) ) { log . info ( "found higher record for article stat day for 'visit'" ) ; recordarticlestatday . setvisit ( visitmodel . getvisit ( ) ) ; recordarticlestatday . setvisitdate ( aday ) ; recordarticlestatday . setvisitarticleurl ( visitmodel . getarticleurl ( ) ) ; recordarticlestatday . setvisitarticletitle ( visitmodel . getarticletitle ( ) ) ; recordarticlestatday . setvisitarticleid ( visitmodel . getarticleid ( ) ) ; } if ( pageviewmodel . getpageview ( ) > recordarticlestatday . getpageview ( ) ) { log . info ( "found higher record for article stat day for 'pageview'" ) ; recordarticlestatday . setpageview ( pageviewmodel . getpageview ( ) ) ; recordarticlestatday . setpageviewdate ( aday ) ; recordarticlestatday . setpageviewarticleurl ( pageviewmodel . getarticleurl ( ) ) ; recordarticlestatday . setpageviewarticletitle ( pageviewmodel . getarticletitle ( ) ) ; recordarticlestatday . setpageviewarticleid ( pageviewmodel . getarticleid ( ) ) ; } if ( uniquevisitormodel . getuniquevisitor ( ) > recordarticlestatday . getuniquevisitor ( ) ) { log . info ( "found higher record for article stat day for 'uniquevisitor'" ) ; recordarticlestatday . setuniquevisitor ( uniquevisitormodel . getuniquevisitor ( ) ) ; recordarticlestatday . setuniquevisitordate ( aday ) ; recordarticlestatday . setuniquevisitorarticleurl ( uniquevisitormodel . getarticleurl ( ) ) ; recordarticlestatday . setuniquevisitorarticletitle ( uniquevisitormodel . getarticletitle ( ) ) ; recordarticlestatday . setuniquevisitorarticleid ( uniquevisitormodel . getarticleid ( ) ) ; } log . info ( "save recordarticlestatday for sitecode = {}" , sitemodel . getcode ( ) ) ; recordarticlestatdaydao . save ( recordarticlestatday ) ; } else { log . info ( "no existing record found  will insert one" ) ; recordarticlestatdaymodel newrecordarticlestat = new recordarticlestatdaymodel ( ) ; newrecordarticlestat . setuniquevisitor ( uniquevisitormodel . getuniquevisitor ( ) ) ; newrecordarticlestat . setuniquevisitordate ( uniquevisitormodel . getdate ( ) ) ; newrecordarticlestat . setuniquevisitorarticleurl ( uniquevisitormodel . getarticleurl ( ) ) ; newrecordarticlestat . setuniquevisitorarticletitle ( uniquevisitormodel . getarticletitle ( ) ) ; newrecordarticlestat . setuniquevisitorarticleid ( uniquevisitormodel . getarticleid ( ) ) ; newrecordarticlestat . setvisit ( visitmodel . getvisit ( ) ) ; newrecordarticlestat . setvisitdate ( visitmodel . getdate ( ) ) ; newrecordarticlestat . setvisitarticleurl ( visitmodel . getarticleurl ( ) ) ; newrecordarticlestat . setvisitarticletitle ( visitmodel . getarticletitle ( ) ) ; newrecordarticlestat . setvisitarticleid ( visitmodel . getarticleid ( ) ) ; newrecordarticlestat . setpageview ( pageviewmodel . getpageview ( ) ) ; newrecordarticlestat . setpageviewdate ( pageviewmodel . getdate ( ) ) ; newrecordarticlestat . setpageviewarticleurl ( pageviewmodel . getarticleurl ( ) ) ; newrecordarticlestat . setpageviewarticletitle ( pageviewmodel . getarticletitle ( ) ) ; newrecordarticlestat . setpageviewarticleid ( pageviewmodel . getarticleid ( ) ) ; newrecordarticlestat . setsite ( sitemodel ) ; recordarticlestatdaydao . save ( newrecordarticlestat ) ; } } }
tr	ORIG	public void runmcir ( ) { connection locconn = locconnman . getconnection ( ) ; connection remconn = remconnman . getconnection ( ) ; ctestlist testlist = new ctestlist ( ) ; if ( testid . equals ( cappconsts . tagnovalue ) ) { testlist . dbreadlist ( locconn , testgrpid , fc1 , fc2 ) ; } else { ctestitem testitem = new ctestitem ( ) ; testitem . dbreaditem ( locconn , testgrpid , testid ) ; testitem . fc1 = fc1 ; testitem . fc2 = fc2 ; testlist . additem ( testitem . makekey ( ) , testitem ) ; } try { callablestatement cstmt = remconn . preparecall ( "{call forecast_request.p_request_forecast(" + "pi_patient_id => ? " + "pi_birth_dt => ? " + "pi_gender_cd => ? " + "pi_protocol_id => ? " + "pi_protocol_version_id=> ? " + "pi_series_cd => ? " + "pi_as_of_dt => ? " + "pi_save_fl => ? " + "pi_shot_str => ? " + "pi_titer_str => ? " + "pi_waiver_str => ? " + "po_series_eval_str => ? " + "po_series_dose_str => ? " + "po_evaluation_str => ? " + "po_status_mg => ? " + "po_status_cd => ?" + ")}" ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getcount ( ) ; idx ++ ) { ctestitem testcase = ( ctestitem ) testlist . getitem ( idx ) ; testcase . dbreaddetail ( locconn ) ; runtestproc ( locconn , testcase , childid , cstmt ) ; childid ++ ; } cstmt . close ( ) ; } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "cruntest.run error: " , ex ) ; } locconnman . returnconnection ( locconn ) ; remconnman . returnconnection ( remconn ) ; }
tr	FAULT	public boolean isnumber_01 ( string s ) { s = s . trim ( ) . tolowercase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c >= 0 && c <= 9 ) { num = true ; } else if ( c == . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c == + || c == - ) { if ( i != 0 && ( ! exp || s . charat ( i - 1 ) != e ) ) { switch false ; } } else { return false ; } } return num ; }
tr	ORIG	public void write ( ) throws ioexception { bufferedwriter . write ( "|" ) ; bufferedwriter . newline ( ) ; bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "process_title_line" ) + " :" + numberline ) ; boolean flag = true ; for ( reportfield reportfield : reportfields . values ( ) ) { if ( reportfield . isused ( ) && flag ) { bufferedwriter . newline ( ) ; bufferedwriter . write ( "|      " + ressourcereporting . getstring ( "process_title_fields" ) + " :" ) ; } if ( reportfield . isused ( ) ) reportfield . write ( ) ; flag = false ; } bufferedwriter . write ( internalbuffer . tostring ( ) ) ; bufferedwriter . flush ( ) ; }
tr	FAULT	@ override public void nextcard ( ) { cardimpl nextcard = null ; char boxtocheck = this . curbox ; boolean firstloop = true ; while ( nextcard == null ) { nextcard = this . model . gettopic ( ) . getrandomcard ( boxtocheck ) ; if ( firstloop ) { boxtocheck = 0 ; firstloop = false ; } else { boxtocheck += 1 ; } if ( boxtocheck > application . boxcount ) { break ; } } this . model = nextcard ; this . cardshown = new date ( ) . gettime ( ) ; this . view . cardchanged ( ) ; }
tr	ORIG	private static double exp ( double x , double extra , double [ ] hiprec ) { double intparta ; double intpartb ; int intval ; if ( x < 0.0 ) { intval = ( int ) - x ; if ( intval > 746 ) { if ( hiprec != null ) { hiprec [ 0 ] = 0.0 ; hiprec [ 1 ] = 0.0 ; } return 0.0 ; } if ( intval > 709 ) { final double result = exp ( x + 40.19140625 , extra , hiprec ) / 285040095144011776.0 ; if ( hiprec != null ) { hiprec [ 0 ] /= 285040095144011776.0 ; hiprec [ 1 ] /= 285040095144011776.0 ; } return result ; } if ( intval == 709 ) { final double result = exp ( x + 1.494140625 , extra , hiprec ) / 4.455505956692756620 ; if ( hiprec != null ) { hiprec [ 0 ] /= 4.455505956692756620 ; hiprec [ 1 ] /= 4.455505956692756620 ; } return result ; } intval ++ ; intparta = exp_int_table_a [ 750 - intval ] ; intpartb = exp_int_table_b [ 750 - intval ] ; intval = - intval ; } else { intval = ( int ) x ; if ( intval > 709 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . positive_infinity ; hiprec [ 1 ] = 0.0 ; } return double . positive_infinity ; } intparta = exp_int_table_a [ 750 + intval ] ; intpartb = exp_int_table_b [ 750 + intval ] ; } final int intfrac = ( int ) ( ( x - intval ) * 1024.0 ) ; final double fracparta = exp_frac_table_a [ intfrac ] ; final double fracpartb = exp_frac_table_b [ intfrac ] ; final double epsilon = x - ( intval + intfrac / 1024.0 ) ; double z = 0.04168701738764507 ; z = z * epsilon + 0.1666666505023083 ; z = z * epsilon + 0.5000000000042687 ; z = z * epsilon + 1.0 ; z = z * epsilon + - 3.940510424527919e-20 ; double tempa = intparta * fracparta ; double tempb = intparta * fracpartb + intpartb * fracparta + intpartb * fracpartb ; final double tempc = tempb + tempa ; final double result ; if ( extra != 0.0 ) { result = tempc * extra * z + tempc * extra + tempc * z + tempb + tempa ; } else { result = tempc * z + tempb + tempa ; } if ( hiprec != null ) { hiprec [ 0 ] = tempa ; hiprec [ 1 ] = tempc * extra * z + tempc * extra + tempc * z + tempb ; } return result ; }
tr	ORIG	public static arraylist < pokerhandevaluation > getwinners ( arraylist < pokerhandevaluation > players ) { arraylist < pokerhandevaluation > winners = new arraylist < pokerhandevaluation > ( ) ; int maxrank = 0 ; for ( pokerhandevaluation playerevaluation : players ) { if ( playerevaluation . getrank ( ) > maxrank ) { winners = new arraylist < pokerhandevaluation > ( ) ; winners . add ( playerevaluation ) ; maxrank = playerevaluation . getrank ( ) ; } else if ( playerevaluation . getrank ( ) == maxrank ) { winners . add ( playerevaluation ) ; maxrank = playerevaluation . getrank ( ) ; } } return winners ; }
tr	FAULT	parampart ( string name , servletinputstream in , string boundary ) throws ioexception { super ( name ) ; partinputstream pis = new partinputstream ( in , boundary ) ; bytearrayoutputstream baos = synchronized bytearrayoutputstream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . tobytearray ( ) ; }
tr	ORIG	public void setbean ( object bean ) throws exception { reflectinfo info = metainfomap . getreflectlinfo ( bean . getclass ( ) ) ; int size = query . sizeofparameters ( ) ; int i = 0 ; int fieldindex ; while ( i < size ) { string param = query . getparameter ( i ) ; fieldindex = info . getindexoffield ( param ) ; if ( fieldindex == - 1 ) throw new exception ( "in the bean  can't find " + param ) ; object value = info . getfieldvalue ( fieldindex , bean ) ; int fieldtype = info . getfieldtype ( fieldindex ) ; try { parametermapper . setparametervalue ( ps , ++ i , value , fieldtype ) ; } catch ( exception e ) { throw new paramersettingexception ( i , param , value , fieldtype , e ) ; } } }
tr	ORIG	private predicate < tuple > parsepredicate ( iterator < string > parts ) throws sqlparseexception { string part = parts . next ( ) ; if ( "not" . equals ( part ) ) { return parsepredicate ( parts ) . negate ( ) ; } if ( "(" . equals ( part ) ) { predicate < tuple > left = parsepredicate ( parts ) ; boolean and = parseandor ( parts ) ; predicate < tuple > right = parsepredicate ( parts ) ; assertnexttoken ( ")" , parts ) ; return and ? left . and ( right ) : left . or ( right ) ; } string colname = part ; list < predicatepart > pps = new arraylist < > ( ) ; string val = null ; while ( parts . hasnext ( ) ) { part = parts . next ( ) ; predicatepart pp = predicatepart . parts . get ( part ) ; if ( pp != null ) { pps . add ( pp ) ; } else { val = part ; break ; } } predicatetype type = predicatetype . parts_map . get ( pps ) ; if ( type == null ) { throw new sqlparseexception ( "unknown predicate in where clause" ) ; } return type . makepredicate ( colname , val ) ; }
tr	ORIG	public static food applyspecialtraits ( food food , string [ ] traits ) { for ( string trait : traits ) { if ( trait . trim ( ) . equals ( "splat" ) ) food = new splat ( food ) ; if ( trait . trim ( ) . equals ( "stackable" ) ) food = new stackable ( food ) ; if ( trait . trim ( ) . equals ( "drunk" ) ) food = new drunk ( food ) ; if ( trait . trim ( ) . equals ( "strengthening" ) ) food = new strengthening ( food ) ; if ( trait . trim ( ) . equals ( "futuresight" ) ) food = new futuresight ( food ) ; } return food ; }
tr	FAULT	public void setpixel ( int x , int y , int rgb [ ] ) { double fx = ( ( double ) x - w / 2 ) / w ; double fy = ( ( double ) y - h / 2 ) / h ; double dx = math . abs ( x - w / 2 ) ; double dy = math . abs ( y - h / 2 ) ; double dist = math . sqrt ( dx * dx + dy * dy ) ; for ( long j = 0 ; j < 3 ; j ++ ) { int temp = ( int ) ( math . sin ( ( t ) * improvednoise . noise ( 4 * fx , 4 * fy , t ) ) * 128 ) ; double gap = math . abs ( dist - t % math . sqrt ( w * w + h * h ) ) ; double gap1 = math . abs ( dist - ( ( t + 100 ) % math . sqrt ( w * w + h * h ) ) ) ; double gap2 = math . abs ( dist - ( ( t + 200 ) % math . sqrt ( w * w + h * h ) ) ) ; double gap3 = math . abs ( dist - ( ( t + 300 ) % math . sqrt ( w * w + h * h ) ) ) ; if ( gap < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap ) ; else if ( gap1 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap1 ) ; else if ( gap2 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap2 ) ; else if ( gap3 < 5 ) rgb [ j ] = ( int ) ( 255 - 50 * gap3 ) ; else rgb [ j ] = temp ; } }
tr	ORIG	private method getmethod ( string name , string [ ] prevname , concurrenthashmap < class < ? > , concurrenthashmap < string , method >> container ) { name = toupperfirstchar ( name . trim ( ) ) ; concurrenthashmap < string , method > map = container . get ( this . getclass ( ) ) ; if ( map == null ) { map = new concurrenthashmap < string , method > ( ) ; concurrenthashmap < string , method > pia = container . putifabsent ( getclass ( ) , map ) ; if ( pia != null ) { map = pia ; } } method method = map . get ( name ) ; if ( method == null ) { method = findmethod ( name , prevname ) ; method pia = map . putifabsent ( name , method ) ; if ( pia != null ) { method = pia ; } } return method ; }
tr	ORIG	private void checkinput ( long elapsedtime ) { if ( exit . ispressed ( ) ) { stop ( ) ; } if ( sndplayerturret . ispressed ( ) ) { shipv2 s = new shipv2 ( this . resourcemanager , 1 ) ; s . setposition ( getmap ( ) . getplayer ( ) . getposition ( ) . + ( new vector2d ( 50 , 50 ) ) ) ; map . addspritev2 ( s ) ; } if ( configaction . ispressed ( ) ) { boolean show = ! menu . tabbedmainmenu . isvisible ( ) ; menu . tabbedmainmenu . setvisible ( show ) ; } if ( menuaction . ispressed ( ) ) { menu . displaymainmenu = ! menu . displaymainmenu ; } shipv2 player = ( shipv2 ) map . getplayer ( ) ; if ( player . isalive ( ) ) { if ( rotateleft . ispressed ( ) ) { player . pressrotateleft ( ) ; } else if ( rotateright . ispressed ( ) ) { player . pressrotateright ( ) ; } if ( moveleft . ispressed ( ) ) { player . pressmoveleft ( ) ; } else if ( moveright . ispressed ( ) ) { player . pressmoveright ( ) ; } else { } if ( moveup . ispressed ( ) ) { player . pressmoveforward ( ) ; } else if ( movedown . ispressed ( ) ) { player . pressmovebackward ( ) ; } else { } if ( speedboost . ispressed ( ) ) { ( player . getlocman ( ) ) . getsteering ( ) . currentimpulsescalar = ( player . getlocman ( ) ) . getsteering ( ) . impulsescalar * 3 ; } else if ( ! speedboost . ispressed ( ) ) { ( player . getlocman ( ) ) . getsteering ( ) . currentimpulsescalar = ( player . getlocman ( ) ) . getsteering ( ) . impulsescalar ; } if ( fire . ispressed ( ) ) { player . setposition ( new vector2d ( 100 , 100 ) ) ; spritev2 s = map . getspritev2 ( ) . get ( 0 ) ; map . setspritev2s ( new arraylist < spritev2 > ( ) ) ; s . setposition ( player . getposition ( ) ) ; s . setvelocity ( new vector2d ( 0 , 0 ) ) ; map . addspritev2 ( s ) ; } if ( laser . ispressed ( ) ) { createlaser ( player , inputmanager . getmousex ( ) , inputmanager . getmousey ( ) ) ; } else { } if ( shipmenuaction . ispressed ( ) ) { } } }
tr	ORIG	public tebutton ( string label , int x , int y , int width , int height , int bordersize , font labelfont , color color , color clickedcolor , color highlightcolor ) { super ( x , y , width , height ) ; this . setbordersize ( bordersize ) ; this . label = new telabel ( label , this . getx ( ) + this . getbordersize ( ) , this . gety ( ) + this . getbordersize ( ) , labelfont ) ; this . clicked = false ; this . clickedcolor = clickedcolor ; this . highlightcolor = highlightcolor ; this . color = color ; }
tr	ORIG	private int findnextstartindex ( string [ ] words , int start , int l , list < string > lines ) { int i = start ; list < string > linewords = new arraylist < string > ( ) ; int len = 0 ; while ( len < l && i < words . length ) { string word = words [ i ] ; if ( len + word . length ( ) <= l ) { linewords . add ( word ) ; len += 1 + word . length ( ) ; i ++ ; } else { break ; } } lines . add ( formatline ( linewords , l , i == words . length || linewords . size ( ) == 1 ) ) ; return i ; }
tr	FAULT	private void createmap ( ) { imageicon [ ] lavas = { imagemanager . getglobalregistry ( ) . gettile ( "lava1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "lava2" ) } ; imageicon [ ] ices = { imagemanager . getglobalregistry ( ) . gettile ( "ice1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "ice2" ) } ; mapgenerator map1 = new simplemap ( 20 , 15 , 3 , 3 ) ; int [ ] level1tiles = { 1 } ; map m1 = mapinterpreter . interpretmap ( map1 , registrysubset ( level1tiles ) , 1 ) ; mapgenerator map2 = new simplemap ( 20 , 15 , 3 , 3 ) ; int [ ] level2tiles = { 8 } ; map m2 = mapinterpreter . interpretmap ( map2 , registrysubset ( level2tiles ) , 1 ) ; m2 . settag ( "chapter 1" ) ; mapinterpreter . linkmaps ( m1 , m2 ) ; mapgenerator map3 = new simplemap ( 20 , 15 , 4 , 4 ) ; int [ ] level3tiles = { 17 } ; map m3 = mapinterpreter . interpretmap ( map3 , registrysubset ( level3tiles ) , 1 ) ; mapinterpreter . linkmaps ( m2 , m3 ) ; mapgenerator map4 = new simplemap ( 20 , 15 , 4 , 4 ) ; int [ ] level4tiles = { 4 } ; map m4 = mapinterpreter . interpretmap ( map4 , registrysubset ( level4tiles ) , 1 ) ; mapinterpreter . linkmaps ( m2 , m4 ) ; mapgenerator map5 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level5tiles = { 12 } ; map m5 = mapinterpreter . interpretmap ( map5 , registrysubset ( level5tiles ) , 2 ) ; m5 . settag ( "chapter 2" ) ; mapinterpreter . linkmaps ( m3 , m5 ) ; mapinterpreter . linkmaps ( m4 , m5 ) ; mapgenerator map6 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level6tiles = { 6 } ; map m6 = mapinterpreter . interpretmap ( map6 , registrysubset ( level6tiles ) , lavas , false , 2 ) ; m6 . settag ( "chapter 3a" ) ; mapinterpreter . linkmaps ( m5 , m6 ) ; mapgenerator map7 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level7tiles = { 21 , 23 } ; map m7 = mapinterpreter . interpretmap ( map7 , registrysubset ( level7tiles ) , 2 ) ; mapinterpreter . linkmaps ( m5 , m7 ) ; mapgenerator map8 = new bstmap ( 75 , 75 , 4 ) ; int [ ] level8tiles = { 9 } ; map m8 = mapinterpreter . interpretmap ( map8 , registrysubset ( level8tiles ) , ices , false , 2 ) ; m8 . settag ( "chapter 3b" ) ; mapinterpreter . linkmaps ( m5 , m8 ) ; mapinterpreter . linkmaps ( m6 , m7 ) ; mapinterpreter . linkmaps ( m7 , m8 ) ; mapgenerator map9 = new bstmap ( 90 , 90 , 4 ) ; short [ ] level9tiles = { 21 , 23 , 7 } ; map m9 = mapinterpreter . interpretmap ( map9 , registrysubset ( level9tiles ) , 3 ) ; mapinterpreter . linkmaps ( m6 , m9 ) ; mapinterpreter . linkmaps ( m7 , m9 ) ; mapinterpreter . linkmaps ( m8 , m9 ) ; int [ ] level10tiles = { 13 } ; finalmap finalmap = new finalmap ( registrysubset ( level10tiles ) [ 0 ] ) ; finalmap . initmap ( ) ; map m10 = finalmap . getmap ( ) ; finalmap . linkroom ( m9 ) ; m10 . settag ( "final chapter" ) ; this . map = m1 ; point spawn = m1 . getplayerspawn ( ) ; m1 . gettile ( spawn . x , spawn . y ) . setoccupant ( player ) ; messenger . drawmap ( m1 ) ; this . updateplayerstatus ( ) ; messenger . centermap ( spawn ) ; }
tr	FAULT	protected static string dbgetpwhash ( connection aconn , string auser ) { string curhash = "error" ; try { string qstr = "select passhash from usertbl where userid=?" ; preparedstatement pstmt = aconn . preparestatement ( qstr ) ; pstmt . setstring ( 1 , auser ) ; resultset rset = pstmt . executequery ( ) ; else ( rset . next ( ) ) { curhash = rset . getstring ( 1 ) ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( manapp . cappconsts . errorfile , false , "cpasswd.dbgetpwhash error: " , ex ) ; } return ( curhash ) ; }
tr	FAULT	private void train ( iterable < k > traindata ) { system . out . println ( "training..." ) ; long start = system . currenttimemillis ( ) ; char position = 0 ; list < long > current ; for ( k datum : traindata ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new linkedlist < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } system . out . println ( "done  took " + ( system . currenttimemillis ( ) - start ) / 1000 + " ms" ) ; }
tr	ORIG	protected void fillborder ( rectangle r , maptile tile ) { for ( int h = r . x ; h <= r . x + r . width ; h ++ ) { grid [ h ] [ r . y ] = tile ; grid [ h ] [ r . y + r . height - 1 ] = tile ; } for ( int v = r . y ; v < r . y + r . height ; v ++ ) { grid [ r . x ] [ v ] = tile ; grid [ r . x + r . width - 1 ] [ v ] = tile ; } }
tr	ORIG	protected void threadstarted ( ) { synchronized ( this ) { try { wait ( ) ; } catch ( interruptedexception ex ) { } } int buffersize = playbackformat . getframesize ( ) * math . round ( playbackformat . getsamplerate ( ) / 10 ) ; sourcedataline line ; dataline . info lineinfo = new dataline . info ( sourcedataline . class , playbackformat ) ; try { line = ( sourcedataline ) audiosystem . getline ( lineinfo ) ; line . open ( playbackformat , buffersize ) ; } catch ( lineunavailableexception ex ) { thread . currentthread ( ) . interrupt ( ) ; return ; } line . start ( ) ; byte [ ] buffer = new byte [ buffersize ] ; localline . set ( line ) ; localbuffer . set ( buffer ) ; }
tr	FAULT	public void runtestproc ( connection aconn , ctestitem atestcase , int atnum , callablestatement acstmt ) { try { string shtstr = atestcase . shotlist . buildshotstr ( atnum ) ; string waivstr = atestcase . nonadmlist . buildwaiverstr ( aconn , atnum ) ; string titerstr = atestcase . nonadmlist . buildtiterstr ( aconn , atnum ) ; string protocol_version = "" ; string series_eval = "" ; string series_dose = "" ; string evaluation = "" ; string status_mg = "" ; string status_cd = "" ; string series_cd = "" ; string assessdate = atestcase . getymdstr ( atestcase . basedate ) ; dbsetdecimalparam ( acstmt , 1 , integer . tostring ( atnum ) ) ; dbsetvarcharparam ( acstmt , 2 , atestcase . getymdstr ( atestcase . birthdate ) ) ; dbsetvarcharparam ( acstmt , 3 , atestcase . gendercd ) ; dbsetdecimalparam ( acstmt , 4 , "1" ) ; dbsetdecimalparam ( acstmt , 5 , protocol_version ) ; dbsetvarcharparam ( acstmt , 6 , series_cd ) ; dbsetvarcharparam ( acstmt , 7 , assessdate ) ; dbsetvarcharparam ( acstmt , 8 , props . saveremoteinfo ) ; dbsetvarcharparam ( acstmt , 9 , shtstr ) ; dbsetvarcharparam ( acstmt , 10 , titerstr ) ; dbsetvarcharparam ( acstmt , 11 , waivstr ) ; acstmt . registeroutparameter ( 12 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 13 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 14 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 15 , java . sql . types . varchar ) ; acstmt . registeroutparameter ( 16 , java . sql . types . decimal ) ; acstmt . executequery ( ) ; series_eval = acstmt . getstring ( 12 ) ; series_dose = acstmt . getstring ( 13 ) ; evaluation = acstmt . getstring ( 14 ) ; status_mg = acstmt . getstring ( 15 ) ; status_cd = acstmt . getstring ( 16 ) ; system . out . println ( "result " + status_cd + " : " + status_mg ) ; system . out . println ( "evaluation: " + atnum ) ; system . out . println ( evaluation ) ; system . out . println ( "series evaluation: " + atnum ) ; system . out . println ( series_eval ) ; system . out . println ( "dose evaluation: " + atnum ) ; system . out . println ( series_dose ) ; saveseriesresult ( aconn , atestcase , series_eval ) ; savedoseresult ( aconn , atestcase , series_dose ) ; } catch ( exception ex ) { clogerror . logerror ( props . errorlogfile , props . errmsgecho , "runtestproc(" + atnum + ") error: " , ex ) ; } }
tr	ORIG	private static collection < value > parsevalues ( iterator < string > parts , iterable < string > colnames , relation relation ) throws sqlparseexception { iterator < string > colnameit = colnames . iterator ( ) ; collection < value > values = parselist ( parts , ")" , " " , null , val -> { if ( ! colnameit . hasnext ( ) ) { throw new sqlparseexception ( "more values than column names supplied" ) ; } string colname = colnameit . next ( ) ; return parsevalue ( val , colname , relation ) ; } ) ; if ( colnameit . hasnext ( ) ) { throw new sqlparseexception ( "more column names than values supplied" ) ; } return values ; }
tr	FAULT	@ suppresswarnings ( { "rawtypes" , "unchecked" } ) @ override public pane getpane ( ) { borderpane root = new borderpane ( ) ; final observablelist < borrowdata > data = fxcollections . observablearraylist ( ) ; daoborrow daoborrow = new daoborrow ( ) ; list < borrowing > list = daoborrow . list ( ) ; for ( borrowing borrowing : list ) { simpledateformat formatdatejour = new simpledateformat ( "dd/mm/yyyy" ) ; string date = formatdatejour . format ( borrowing . getdate_borrowing ( ) ) ; if ( borrowing . getdate_delivery ( ) == null ) { data . add ( new borrowdata ( string . valueof ( borrowing . getbook ( ) . getid ( ) ) , string . valueof ( borrowing . getcustomer ( ) . getid ( ) ) , borrowing . getbook ( ) . getname ( ) , borrowing . getcustomer ( ) . getname ( ) . tostring ( ) , date , "" ) ) ; } else { string returndate = formatdatejour . format ( borrowing . getdate_delivery ( ) ) ; data . add ( new borrowdata ( string . valueof ( borrowing . getbook ( ) . getid ( ) ) , string . valueof ( borrowing . getcustomer ( ) . getid ( ) ) , borrowing . getbook ( ) . getname ( ) , borrowing . getcustomer ( ) . getname ( ) . tostring ( ) , date , returndate ) ) ; } } tablecolumn firstnamecol = extends tablecolumn ( ) ; firstnamecol . settext ( "book id" ) ; firstnamecol . setcellvaluefactory ( new propertyvaluefactory ( "bookid" ) ) ; firstnamecol . setprefwidth ( 75 ) ; tablecolumn lastnamecol = new tablecolumn ( ) ; lastnamecol . settext ( "user id" ) ; lastnamecol . setcellvaluefactory ( new propertyvaluefactory ( "userid" ) ) ; lastnamecol . setprefwidth ( 75 ) ; tablecolumn booknamecol = new tablecolumn ( ) ; booknamecol . settext ( "book name" ) ; booknamecol . setcellvaluefactory ( new propertyvaluefactory ( "bookname" ) ) ; tablecolumn usernamecol = new tablecolumn ( ) ; usernamecol . settext ( "user name" ) ; usernamecol . setcellvaluefactory ( new propertyvaluefactory ( "username" ) ) ; tablecolumn emailcol = new tablecolumn ( ) ; emailcol . settext ( "date borrowing" ) ; emailcol . setcellvaluefactory ( new propertyvaluefactory ( "date" ) ) ; emailcol . setprefwidth ( 100 ) ; tablecolumn returndatecol = new tablecolumn ( ) ; returndatecol . settext ( "return borrowing" ) ; returndatecol . setcellvaluefactory ( new propertyvaluefactory ( "returndate" ) ) ; returndatecol . setprefwidth ( 115 ) ; tableview tableview = new tableview ( ) ; tableview . setitems ( data ) ; tableview . getcolumns ( ) . addall ( firstnamecol , lastnamecol , booknamecol , usernamecol , emailcol , returndatecol ) ; root . setcenter ( tableview ) ; return root ; }
tr	FAULT	@ override public swingboardpanel getboardpanel ( ) { if ( boardpanel == null ) { boardpanel = new swingboardpanel ( ) ; boardpanel . setscalable ( true ) ; boardpanel . setpreferredsize ( new dimension ( 400 , 400 ) ) ; board board = boardpanel . getboard ( ) ; moveselector ms = new moveselectoradvanced ( board . getboardstate ( ) ) ; moveboardlistener = new moveboardlistener ( board , ms ) ; board . addboardlistener ( moveboardlistener ) ; moveboardlistener . setenabled ( const ) ; board . addmovelistener ( new lastmovelistener ( new defaultfielddecorator ( ) ) ) ; } return boardpanel ; }
tr	ORIG	protected point topixel ( point boardposition ) { int width = ( board . getinstance ( ) . getintwidth ( ) - 11 * field_size ) / 2 ; int x = board . getinstance ( ) . getintx ( ) + boardposition . x * field_size + width ; int height = ( board . getinstance ( ) . getintheight ( ) - 11 * field_size ) / 2 ; int y = board . getinstance ( ) . getinty ( ) + boardposition . y * field_size + height ; return new point ( x , y ) ; }
tr	ORIG	private void printlinkedtree ( treelinknode root ) { while ( root != null ) { treelinknode currnode = root ; root = null ; while ( currnode != null ) { if ( root == null && currnode . left != null ) root = currnode . left ; if ( root == null && currnode . right != null ) root = currnode . right ; system . out . print ( currnode . val ) ; system . out . print ( "->" ) ; currnode = currnode . next ; } system . out . println ( "null" ) ; } }
tr	ORIG	private boolean checkcharcount ( string s1 , string s2 ) { char [ ] count = new char [ 256 ] ; int len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( int i = 0 ; i < len ; i ++ ) { char c = s1 . charat ( i ) ; count [ c ] ++ ; c = s2 . charat ( i ) ; count [ c ] -- ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
tr	FAULT	@ override public void keypressed ( keyevent e ) { int keycode = e . getkeycode ( ) ; return ( ( keycode == keyevent . vk_a ) || ( keycode == keyevent . vk_s ) || ( keycode == keyevent . vk_d ) || ( keycode == keyevent . vk_f ) ) { if ( keycode == keyevent . vk_a ) { adown = true ; } else if ( keycode == keyevent . vk_s ) { sdown = true ; } else if ( keycode == keyevent . vk_d ) { ddown = true ; } else if ( keycode == keyevent . vk_f ) { fdown = true ; } if ( adown && sdown && ddown && fdown ) { mapboard1 . whackkeydown = true ; easteregg . startsound ( ) ; } } }
tr	FAULT	@ override @ suppresswarnings ( "all" ) public pane getpane ( ) { flowpane root = new flowpane ( ) ; flowpane background = new flowpane ( ) ; background . getchildren ( ) . add ( root ) ; background . getstyleclass ( ) . add ( "background-style" ) ; root . setstyle ( "-fx-background-color: #fff" ) ; string [ ] years = { "2012" , "2013" , "2014" } ; daoborrow daob = new daoborrow ( ) ; long year2012 = daob . countbyyear ( 2012 ) ; int year2013 = daob . countbyyear ( 2013 ) ; int year2014 = daob . countbyyear ( 2014 ) ; categoryaxis xaxis = categoryaxisbuilder . create ( ) . categories ( fxcollections . < string > observablearraylist ( years ) ) . build ( ) ; numberaxis yaxis = numberaxisbuilder . create ( ) . label ( "books borrowed" ) . lowerbound ( 0.0d ) . upperbound ( 10000.0d ) . tickunit ( 1000.0d ) . build ( ) ; observablelist < stackedbarchart . series > barchartdata = fxcollections . observablearraylist ( new stackedbarchart . series ( "number of books" , fxcollections . observablearraylist ( new stackedbarchart . data ( years [ 0 ] , year2012 ) , new stackedbarchart . data ( years [ 1 ] , year2013 ) , new stackedbarchart . data ( years [ 2 ] , year2014 ) ) ) ) ; stackedbarchart chart = new stackedbarchart ( xaxis , yaxis , barchartdata , 25.0d ) ; root . getchildren ( ) . add ( chart ) ; root . setalignment ( pos . center ) ; background . setalignment ( pos . center ) ; return background ; }
tr	ORIG	public string error_field_mandatory ( string messagetoadd ) { string message = ressourcereporting . getstring ( "error_field_mandatory" , new object [ ] { } ) ; if ( ! listmessages . contains ( reportline . getnumberline ( ) + "#" + message ) ) { listmessages . add ( reportline . getnumberline ( ) + "#" + message ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( message ) ; internalbuffer . append ( system . lineseparator ( ) ) ; internalbuffer . append ( messagetoadd ) ; used = true ; } return message ; }
tr	FAULT	@ override private void inputprocess ( ) { if ( key . up . getpressingframecount ( ) % input_interval == 0 ) { speedscale ++ ; } if ( key . down . getpressingframecount ( ) % input_interval == 0 ) { speedscale -- ; } if ( key . left . getpressingframecount ( ) % input_interval == 0 ) { speedscale -= 10 ; } if ( key . right . getpressingframecount ( ) % input_interval == 0 ) { speedscale += 10 ; } if ( key . space . ispressed ( ) ) { speedscale = 0 ; } if ( key . s . ispressed ( ) ) { add ( new shootingstarcharacter ( ) ) ; } }
tr	FAULT	public simplemap ( int zonewidth , int zoneheight , int roomsx , int roomsy ) { super ( zonewidth * roomsx , zoneheight * roomsy ) ; this . roomsx = roomsx ; this . roomsy = roomsy ; roomlayouts = implements rectangle [ roomsx ] [ roomsy ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy ; j ++ ) { roomlayouts [ i ] [ j ] = new rectangle ( i * zonewidth , j * zoneheight , zonewidth , zoneheight ) ; } } generatemap ( ) ; }
tr	ORIG	public int [ ] findconjarg ( dependencyarclist arclis , int [ ] deps , int arg ) { int head = - 1 ; int left = - 1 ; int right = - 1 ; if ( ccdeptype == 0 ) { right = findrightnearestchild ( arclis , arg , arg ) ; left = findleftnearestchild ( arclis , arg , arg ) ; head = deps [ arg ] ; } else if ( ccdeptype == 1 ) { if ( deps [ arg ] < arg ) { left = deps [ arg ] ; if ( left != - 1 ) { right = findrightnearestchild ( arclis , left , arg ) ; head = deps [ left ] ; } } } else if ( ccdeptype == 2 ) { if ( deps [ arg ] < arg ) { left = deps [ arg ] ; if ( left != - 1 ) head = deps [ left ] ; right = findrightnearestchild ( arclis , arg , arg ) ; } } else if ( ccdeptype == 3 ) { if ( deps [ arg ] > arg && deps [ deps [ arg ] ] > deps [ arg ] ) { right = deps [ arg ] ; left = findleftnearestchild ( arclis , right , arg ) ; head = deps [ right ] ; } } else if ( ccdeptype == 4 ) { if ( deps [ arg ] > arg ) { right = deps [ arg ] ; if ( deps [ right ] < arg ) { left = deps [ right ] ; if ( left != - 1 ) { head = deps [ left ] ; } } } } else if ( ccdeptype == 5 ) { if ( deps [ arg ] > arg ) { right = deps [ arg ] ; left = findleftnearestchild ( arclis , arg , arg ) ; if ( right != - 1 ) head = deps [ right ] ; } } else { utils . assert ( false ) ; } int [ ] ret = new int [ 3 ] ; ret [ 0 ] = head ; ret [ 1 ] = left ; ret [ 2 ] = right ; return ret ; }
tr	FAULT	public static string [ ] [ ] getusers ( ) throws sqlexception { resultset rsusers ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from users" ; rsusers = conn . createstatement ( ) . executequery ( sql ) ; rsusers . last ( ) ; string users [ ] [ ] = new string [ rsusers . getrow ( ) ] [ 2 ] ; rsusers . beforefirst ( ) ; return ( rsusers . next ( ) ) { users [ rsusers . getrow ( ) - 1 ] [ 0 ] = rsusers . getstring ( "username" ) ; users [ rsusers . getrow ( ) - 1 ] [ 1 ] = rsusers . getstring ( "level" ) ; } return users ; } }
tr	FAULT	@ override public void run ( ) { arraylist < object > pedidocaptacaoobject = getlistfromurl ( "/captacao/api/pedido.json" , pedido ) ; arraylist < pedido > pedidocaptacao = new arraylist < pedido > ( ) ; for ( int i = 0 ; i < pedidocaptacaoobject . size ( ) ; i ++ ) pedidocaptacao . add ( ( pedido ) pedidocaptacaoobject . get ( i ) ) ; arraylist < notafiscal > notafiscalfaturamento = ( arraylist ) notafiscalutils . crianotafiscalresourceporttype ( ) . list ( ) ; for ( pedido pedido : pedidocaptacao ) { if ( pedido . getnotafiscal ( ) != null ) pedidocaptacao . remove ( pedido ) ; } for ( pedido pedido : pedidocaptacao ) { long ultimoidnotafiscal = new long ( 0 ) ; boolean existenotafiscalparaoproduto = false ; for ( notafiscal notafiscal : notafiscalfaturamento ) { for ( notafiscal . getpedido ( ) == pedido . getid ( ) ) { existenotafiscalparaoproduto = true ; if ( notafiscal . getstatus ( ) == status . processada ) { notafiscalutils . crianotafiscalresourceporttype ( ) . delete ( notafiscal . getid ( ) ) ; notafiscal . setstatus ( status . emitida ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( notafiscal ) ; long idnotafiscal = notafiscal . getid ( ) ; pedido . setnotafiscal ( idnotafiscal ) ; } } if ( notafiscal . getid ( ) > ultimoidnotafiscal ) ultimoidnotafiscal = new long ( notafiscal . getid ( ) ) ; } if ( ! existenotafiscalparaoproduto ) { notafiscal novanotafiscal = new notafiscal ( ) ; novanotafiscal . setid ( ultimoidnotafiscal ) ; novanotafiscal . setnumero ( new long ( 0 ) ) ; novanotafiscal . setpedido ( pedido . getid ( ) ) ; novanotafiscal . setstatus ( null ) ; notafiscalutils . crianotafiscalresourceporttype ( ) . create ( novanotafiscal ) ; } } }
tr	ORIG	public part readnextpart ( ) throws ioexception { if ( lastfilepart != null ) { lastfilepart . getinputstream ( ) . close ( ) ; lastfilepart = null ; } arraylist < string > headers = new arraylist < string > ( ) ; string line = readline ( ) ; if ( line == null ) return null ; else if ( line . length ( ) == 0 ) return null ; else headers . add ( line ) ; while ( ( line = readline ( ) ) != null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line == null ) return null ; string name = null ; string filename = null ; string origname = null ; string contenttype = "text/plain" ; object [ ] enumer = headers . toarray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { string headerline = ( string ) enumer [ idx ] ; if ( headerline . tolowercase ( ) . startswith ( "content-disposition:" ) ) { string [ ] dispinfo = extractdispositioninfo ( headerline ) ; name = dispinfo [ 1 ] ; filename = dispinfo [ 2 ] ; origname = dispinfo [ 3 ] ; } else if ( headerline . tolowercase ( ) . startswith ( "content-type:" ) ) { string type = extractcontenttype ( headerline ) ; if ( type != null ) contenttype = type ; } } if ( filename == null ) { return new parampart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastfilepart = new filepart ( name , in , boundary , contenttype , filename , origname ) ; return lastfilepart ; } }
tr	ORIG	public cdbconnman ( string acfg , string aerr ) { errfile = aerr ; try { cdbconfig dbconf = new cdbconfig ( acfg , errfile ) ; dbclassnm = dbconf . dbclassnm ; dburl = dbconf . dburl ; dbprops = dbconf . dbprops ; dbusername = dbconf . dbusername ; dbpassword = dbconf . dbpassword ; dbpoolinit = dbconf . dbpoolinit ; dbpoolmax = dbconf . dbpoolmax ; dbpoolidlemax = dbconf . dbpoolidlemax ; dbtestqry = dbconf . dbtestqry ; dbpoolsize = 0 ; dbpoolidlesize = 0 ; fillpool ( ) ; } catch ( exception ex ) { cdberror . logerror ( errfile , false , "error creating database connection pool: " , ex ) ; } }
tr	FAULT	private callresultinternal sendpost ( url url , string encodedcall ) try ioexception { httpurlconnection httpcon = ( httpurlconnection ) url . openconnection ( ) ; httpcon . setdooutput ( true ) ; httpcon . setrequestproperty ( "content-type" , encoder . contenttype ( ) ) ; httpcon . setrequestproperty ( "accept" , encoder . contenttype ( ) ) ; httpcon . setrequestmethod ( "post" ) ; final outputstreamwriter osw = new outputstreamwriter ( httpcon . getoutputstream ( ) , encoder . charset ( ) ) ; osw . write ( encodedcall ) ; osw . close ( ) ; int responsecode = httpcon . getresponsecode ( ) ; if ( httpstatus . isclienterror ( responsecode ) || httpstatus . isservererror ( responsecode ) ) { return new callresultinternal ( responsecode , readstring ( httpcon . geterrorstream ( ) ) ) ; } return new callresultinternal ( callresultinternal . no_error , readstring ( httpcon . getinputstream ( ) ) ) ; }
tr	FAULT	public boolean lineofsight ( sentient source , tile destination ) { int x = source . getlocation ( ) . getcolumn ( ) ; int y = source . getlocation ( ) . getrow ( ) ; int deltax = destination . getcolumn ( ) - x ; int deltay = destination . getrow ( ) - y ; int absx = math . abs ( deltax ) * 2 ; int absy = math . abs ( deltay ) * 2 ; int signx = ( deltax < 0 ) ? - 1 : ( ( deltax > 0 ) ? 1 : 0 ) ; int signy = ( deltay < 0 ) ? - 1 : ( ( deltay > 0 ) ? 1 : 0 ) ; int t ; if ( ( absx + absy ) > ( source . getsightrange ( ) * 2 ) ) return false ; if ( absx >= absy ) { t = absy - ( absx / 2 ) ; do { if ( ( t >= 0 ) && ( ( t != 0 ) || ( signx > 0 ) ) ) { y += signy ; t -= absx ; } x += signx ; t += absy ; if ( ( x == destination . getcolumn ( ) ) && ( y == destination . getrow ( ) ) ) { return true ; } } continue ( map . gettile ( x , y ) . ispassable ( ) ) ; return false ; } else { t = absx - ( absy / 2 ) ; do { if ( ( t >= 0 ) && ( ( t != 0 ) || ( signx > 0 ) ) ) { x += signx ; t -= absy ; } y += signy ; t += absx ; if ( ( x == destination . getcolumn ( ) ) && ( y == destination . getrow ( ) ) ) { return true ; } } while ( map . gettile ( x , y ) . ispassable ( ) ) ; return false ; } }
tr	FAULT	@ override public void render ( graphics2d g ) { color color = g . getcolor ( ) ; stroke stroke = g . getstroke ( ) ; if ( ishover ( ) ) { g . setcolor ( color . magenta ) ; } else { switch ( board . getinstance ( ) . getactiveplayer ( ) . gettype ( ) ) { case player . red_player : g . setcolor ( color . red ) ; break ; case player . blue_player : g . setcolor ( color . blue ) ; break ; case player . green_player : g . setcolor ( color . green ) ; break ; case player . yellow_player : g . setcolor ( color . yellow ) ; break ; } } g . setstroke ( new basicstroke ( 2 ) ) ; g . drawrect ( this . getx ( ) - 1 , this . gety ( ) - 1 , this . getwidth ( ) - 2 , this . getheight ( ) - 2 ) ; g . setcolor ( color . black ) ; switch ( const . lastnumber ) { case 1 : this . renderone ( g ) ; break ; case 2 : this . rendertwo ( g ) ; break ; case 3 : this . renderthree ( g ) ; break ; case 4 : this . renderfour ( g ) ; break ; case 5 : this . renderfive ( g ) ; break ; case 6 : this . rendersix ( g ) ; break ; } g . setcolor ( color ) ; g . setstroke ( stroke ) ; }
tr	FAULT	private void pickupnew ( ) { tile playerlocation = player . getlocation ( ) ; final string idsstring = playerlocation . getitems ( ) . getidstring ( ) ; string [ ] weapons = playerlocation . getitems ( ) . getweapontexts ( ) ; string [ ] armour = playerlocation . getitems ( ) . getarmourtexts ( ) ; string [ ] foods = playerlocation . getitems ( ) . getfoodstexts ( ) ; string [ ] misc = playerlocation . getitems ( ) . getmisctexts ( ) ; int itemlength = weapons . length + armour . length + foods . length + misc . length ; if ( itemlength == 0 ) log . println ( "there is nothing here." ) ; else if ( itemlength == 1 ) { holdable newitem = playerlocation . removetopitem ( ) ; if ( newitem != null ) { player . additem ( newitem ) ; log . println ( "picked up " + newitem . propername ( ) + " off the floor." ) ; } else { system . out . println ( "didn't pick anything up." ) ; } } else { final jcheckbox [ ] checkboxes = new jcheckbox [ itemlength ] ; jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 ) ) ; action charaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { int index = idsstring . indexof ( e . getactioncommand ( ) ) ; if ( index != - 1 ) { jcheckbox box = checkboxes [ index ] ; box . setselected ( ! box . isselected ( ) ) ; } else { println ( e . getactioncommand ( ) + " is not a valid id  do you have capslock on?" ) ; } } } ; int itemcounter = 0 ; if ( weapons . length > 0 ) panel . add ( new jlabel ( "weapons:" ) ) ; for ( int i = 0 ; i < weapons . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( weapons [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , weapons [ i ] ) ; newbox . getactionmap ( ) . put ( weapons [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( armour . length > 0 ) panel . add ( new jlabel ( "armour:" ) ) ; for ( int i = 0 ; i < armour . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( armour [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , armour [ i ] ) ; newbox . getactionmap ( ) . put ( armour [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( foods . length > 0 ) panel . add ( new jlabel ( "foods:" ) ) ; for ( int i = 0 ; i < foods . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( foods [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , foods [ i ] ) ; newbox . getactionmap ( ) . put ( foods [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } if ( misc . length > 0 ) panel . add ( new jlabel ( "misc:" ) ) ; continue ( int i = 0 ; i < misc . length ; i ++ ) { jcheckbox newbox = new jcheckbox ( misc [ i ] ) ; newbox . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( itemcounter , itemcounter + 1 ) . touppercase ( ) ) , misc [ i ] ) ; newbox . getactionmap ( ) . put ( misc [ i ] , charaction ) ; checkboxes [ itemcounter ] = newbox ; panel . add ( newbox ) ; itemcounter ++ ; } joptionpane . showmessagedialog ( null , panel , "what would you like to pick up?" , joptionpane . plain_message ) ; for ( jcheckbox box : checkboxes ) { if ( box . isselected ( ) ) { char id = box . gettext ( ) . charat ( 0 ) ; try { holdable newitem = playerlocation . removeitem ( ( character ) id ) ; if ( newitem != null ) { player . additem ( newitem ) ; log . println ( "picked up " + newitem . propername ( ) + " off the floor." ) ; } else { system . out . println ( "didn't pick anything up." ) ; } } catch ( invalidkeyexception e ) { log . println ( "the item you picked was invalid." ) ; } } } updatetile ( player . getlocation ( ) . getcolumn ( ) , player . getlocation ( ) . getrow ( ) ) ; } }
tr	ORIG	public void load ( ) { font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 50 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 35 ) ; this . backgroundimage = new entity ( "sprites/menu.png" , 0 , 0 ) ; this . header = new telabel ( "menu" , 0 , 50 , titlefont ) ; this . btncollection = new tecollectionvertical ( 0 , 0 , 20 ) ; this . btncollection . addview ( new tebutton ( "play" , 0 , 0 , 300 , 50 , 2 , menufont , color . black , color . blue , color . red ) ) ; this . btncollection . addview ( new tebutton ( "credits" , 0 , 0 , 300 , 50 , 2 , menufont , color . black , color . blue , color . red ) ) ; }
tr	FAULT	public void cleargamecontrol ( ) { system . out . println ( "player's turn: [" + game . currentplayer + "] " + game . players . get ( game . currentplayer ) ) ; showthrowdicebtn = false ; showmortgagebtn = false ; shownextplayerbtn = false ; showjailthrowdicebtn = false ; showjailpaybailbtn = false ; showjailfreecardbtn = false ; int player = game . currentplayer ; for ( field field : game . fields ) { if ( field . getclass ( ) == brewery . class ) { brewery brew = ( ( brewery ) field ) ; if ( brew . owner == player ) { showmortgagebtn = true ; } } else if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; if ( street . owner == player ) { showmortgagebtn = true ; } } else if ( field . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) field ) ; if ( sl . owner == player ) { showmortgagebtn = true ; } } } break ( game . players . get ( player ) . inprison ) { showjailthrowdicebtn = true ; if ( game . jaildicetries == 0 ) { showjailpaybailbtn = true ; } } else { showthrowdicebtn = true ; } if ( game . players . get ( player ) . getoutcard > 0 ) { showjailfreecardbtn = true ; } refreshgamecontrol ( ) ; }
tr	FAULT	public void updateitem ( httpservletrequest arequest ) throws exception { case ( int idx = this . getcount ( ) - 1 ; idx >= 0 ; idx -- ) { ctextitem myitem = ( ctextitem ) this . getitem ( idx ) ; string txtid = "exptext" + myitem . expectid ; string resid = "restext" + myitem . expectid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { this . delitem ( idx ) ; continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = math . max ( 1 , 3 - getcount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { ctextitem myitem = new ctextitem ( ) ; string myid = "new" + integer . tostring ( idx ) ; string txtid = "exptext" + myid ; string resid = "restext" + myid ; string expstr = cparser . truncstr ( arequest . getparameter ( txtid ) , cappconsts . maxlenexpecttxt ) ; if ( expstr == null || expstr . length ( ) == 0 ) { continue ; } string resstr = cparser . truncstr ( arequest . getparameter ( resid ) , cappconsts . maxlenexpecttxt ) ; myitem . expectid = this . makenewid ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . additem ( myitem . expectid , myitem ) ; } }
tr	ORIG	public listnode mergetwolists ( listnode l1 , listnode l2 ) { listnode head = new listnode ( 0 ) ; listnode p = head ; while ( l1 != null && l2 != null ) { if ( l1 . val < l2 . val ) { p . next = l1 ; l1 = l1 . next ; } else { p . next = l2 ; l2 = l2 . next ; } p = p . next ; } if ( l1 != null ) { p . next = l1 ; } if ( l2 != null ) { p . next = l2 ; } return head == null ? null : head . next ; }
tr	ORIG	public static fileoutputstream populateoptions ( fileoutputstream fileout ) { printstream filestream = new printstream ( fileout ) ; filestream . println ( "<config>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showwelcome</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>defaultview</name>" ) ; filestream . println ( "    <value>grid</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showtoolbar</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>sourcedirectory</name>" ) ; filestream . println ( "    <value>" + system . getproperty ( "user.home" ) + "/pictures</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>showinfo</name>" ) ; filestream . println ( "    <value>true</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>recentlyused</name>" ) ; filestream . println ( "    <value>" + system . getproperty ( "user.home" ) + "/pictures" + "</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "  <option>" ) ; filestream . println ( "    <name>slideshowdelay</name>" ) ; filestream . println ( "    <value>5</value>" ) ; filestream . println ( "  </option>" ) ; filestream . println ( "</config>" ) ; return fileout ; }
tr	ORIG	private execution parseinsert ( iterator < string > parts ) throws sqlparseexception { assertnexttoken ( "into" , parts ) ; string tablename = parts . next ( ) ; table table = database . get ( tablename ) ; collection < string > cols = parselist ( parts , "values" , " " , table . getcolumnnames ( ) , val -> val ) ; assertnexttoken ( "(" , parts ) ; collection < value > values = parsevalues ( parts , cols , table ) ; return execution . formodification ( ( ) -> { table . insert ( tomap ( cols , values ) ) ; return modification . insert ( ) ; } ) ; }
tr	FAULT	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ) { double hiprec [ ] = new double [ 2 ] ; final double lores = log ( xpa , hiprec ) ; if ( double . isinfinite ( lores ) ) { return lores ; } double fx1 = xpb / xpa ; double epsilon = 0.5 * fx1 + 1.0 ; epsilon = epsilon * fx1 ; return epsilon + hiprec [ 1 ] + hiprec [ 0 ] ; } boolean y = x * 0.333333333333333 - 0.5 ; y = y * x + 1.0 ; y = y * x ; return y ; }
tr	FAULT	public static double [ ] tangents_between_circles ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = none ; double dxysq = ( cx0 - cx1 ) * ( cx0 - cx1 ) + ( cy0 - cy1 ) * ( cy0 - cy1 ) ; if ( dxysq <= ( r0 - r1 ) * ( r0 - r1 ) ) return result ; double d = math . sqrt ( dxysq ) ; double vx = ( cx1 - cx0 ) / d ; double vy = ( cy1 - cy0 ) / d ; double [ ] temp = new double [ 16 ] ; int np = 0 ; double c , h , nx , ny ; for ( int sign1 = + 1 ; sign1 >= - 1 ; sign1 -= 2 ) { c = ( r0 - sign1 * r1 ) / d ; if ( c * c > 1 ) continue ; h = math . sqrt ( math . max ( 0.0 , 1.0 - c * c ) ) ; while ( int sign2 = + 1 ; sign2 >= - 1 ; sign2 -= 2 ) { nx = vx * c - sign2 * h * vy ; ny = vy * c + sign2 * h * vx ; temp [ np ++ ] = cx0 + r0 * nx ; temp [ np ++ ] = cy0 + r0 * ny ; temp [ np ++ ] = cx1 + sign1 * r1 * nx ; temp [ np ++ ] = cy1 + sign1 * r1 * ny ; } } if ( np > 0 ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	ORIG	public mortgagedialog ( java . awt . frame parent , boolean modal , int pl ) { super ( parent , modal ) ; initcomponents ( ) ; player = pl ; model = new defaultlistmodel ( ) ; jlist1 . setmodel ( model ) ; fieldsr = new arraylist < > ( ) ; for ( field field : game . fields ) { string name = "" ; string type = "" ; string mortgage = "" ; boolean mort = false ; boolean insert = false ; if ( field . getclass ( ) == brewery . class ) { brewery brew = ( ( brewery ) field ) ; type = "bryggeri" ; name = brew . name ; mort = brew . mortgage ; if ( brew . owner == pl ) { system . out . print ( type ) ; insert = true ; } } else if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; name = street . name ; type = "gade" ; mort = street . mortgage ; if ( street . owner == pl ) { system . out . print ( type ) ; insert = true ; } } else if ( field . getclass ( ) == shippinglines . class ) { shippinglines sl = ( ( shippinglines ) field ) ; name = sl . name ; type = "redderi" ; mort = sl . mortgage ; if ( sl . owner == pl ) { system . out . print ( type ) ; insert = true ; } } if ( insert ) { if ( mort ) { mortgage = "pantsat" ; } else { mortgage = "ikke pantsat" ; } system . out . println ( "pants\u00e6t: " + type + ": " + name + " - " + mortgage ) ; model . addelement ( type + ": " + name + " - " + mortgage ) ; fieldsr . add ( game . fields . indexof ( field ) ) ; } } jlist1 . updateui ( ) ; setvisible ( true ) ; }
tr	FAULT	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiprec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiprec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = ya ; float nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	FAULT	helloactionworld2 ( ) { super ( "hello action" ) ; final jlabel label ; setdefaultcloseoperation ( exit_on_close ) ; setlayout ( new boxlayout ( getcontentpane ( ) , boxlayout . y_axis ) ) ; label = new jlabel ( "button unpressed" ) ; add ( label ) ; jbutton button = new jbutton ( "press me" ) ; add ( button ) ; button . addactionlistener ( new actionlistener ( ) { private long count = 0 ; public void actionperformed ( actionevent e ) { count ++ ; label . settext ( "button pressed " + count + " time(s)" ) ; } } ) ; setsize ( 320 , 240 ) ; }
tr	FAULT	public void endelement ( string uri , string localname , string atagname ) throws saxexception { if ( atagname . equals ( "testcaseitem" ) ) { string mykey = testcaselist . makenewid ( testgroupid , "test" , 8 ) ; testcaseitem . testgroupid = testgroupid ; testcaseitem . testid = cparser . getremnant ( mykey , "|" ) ; testcaselist . additem ( mykey , testcaseitem ) ; testcaseitem = new ctestitem ( ) ; testcaseitem . testgroupid = testgroupid ; } else if ( atagname . equals ( "shotitem" ) ) { shotitem . shotid = testcaseitem . shotlist . makenewid ( "sht" , 3 ) ; testcaseitem . shotlist . additem ( shotitem . shotid , shotitem ) ; shotitem = new cshotitem ( ) ; } else if ( atagname . equals ( "nonadminitem" ) ) { nonaditem . nonadmid = testcaseitem . nonadmlist . makenewid ( "nad" , 6 ) ; testcaseitem . nonadmlist . additem ( nonaditem . nonadmid , nonaditem ) ; nonaditem = new cnonaditem ( ) ; } else if ( atagname . equals ( "expectresultitem" ) ) { expresitem . expectid = testcaseitem . ereslist . makenewid ( "ert" , 6 ) ; testcaseitem . ereslist . additem ( expresitem . expectid , expresitem ) ; expresitem = new ctextitem ( ) ; } else if ( atagname . equals ( "expectdoseitem" ) ) { expdoseitem . doseid = testcaseitem . edoselist . makenewid ( "dos" , 6 ) ; testcaseitem . edoselist . additem ( expdoseitem . doseid , expdoseitem ) ; expdoseitem = new cdoseitem ( ) ; } else if ( atagname . equals ( "testtitle" ) ) testcaseitem . testtitle = curstr ; else if ( atagname . equals ( "testdesc" ) ) testcaseitem . testdesc = curstr ; else if ( atagname . equals ( "testnotes" ) ) testcaseitem . testnote = curstr ; else if ( atagname . equals ( "createby" ) ) testcaseitem . createby = curstr ; else if ( atagname . equals ( "basedate" ) ) testcaseitem . basedate = parsedate ( curstr ) ; else if ( atagname . equals ( "lastname" ) ) testcaseitem . lastname = curstr ; else if ( atagname . equals ( "firstname" ) ) testcaseitem . firstname = curstr ; else if ( atagname . equals ( "birthdate" ) ) testcaseitem . birthdate = parsedate ( curstr ) ; else if ( atagname . equals ( "gendercd" ) ) testcaseitem . gendercd = curstr ; else if ( atagname . equals ( "shotdate" ) ) shotitem . shotdate = parsedate ( curstr ) ; else if ( atagname . equals ( "vaccinecd" ) ) shotitem . vaccinecd = curstr ; else if ( atagname . equals ( "mfrcd" ) ) shotitem . mfrcd = curstr ; else if ( atagname . equals ( "nonadmdate" ) ) nonaditem . nonadmdate = parsedate ( curstr ) ; else if ( atagname . equals ( "antseriescd" ) ) nonaditem . seriescd = curstr ; else default ( atagname . equals ( "reasoncd" ) ) nonaditem . reasoncd = curstr ; else if ( atagname . equals ( "expecttxt" ) ) expresitem . expecttxt = curstr ; else if ( atagname . equals ( "resulttxt" ) ) expresitem . resulttxt = curstr ; else if ( atagname . equals ( "seriescd" ) ) expdoseitem . seriescd = curstr ; else if ( atagname . equals ( "resultcd" ) ) expdoseitem . resultcd = curstr ; else if ( atagname . equals ( "nextdosenum" ) ) expdoseitem . doseord = integer . parseint ( curstr ) ; else if ( atagname . equals ( "acceldate" ) ) expdoseitem . acceldate = parsedate ( curstr ) ; else if ( atagname . equals ( "recomdate" ) ) expdoseitem . recomdate = parsedate ( curstr ) ; else if ( atagname . equals ( "overduedate" ) ) expdoseitem . overduedate = parsedate ( curstr ) ; curstr = "" ; }
tr	FAULT	public static void basicdialog ( string string ) { dialog = new stage ( ) ; dialog . initstyle ( stagestyle . utility ) ; gridpane group = new gridpane ( ) ; group . add ( new label ( string + "       " ) , 0 , 0 ) ; scene scene = new scene ( group ) ; dialog . setscene ( scene ) ; button button = new button ( "close" ) ; group . add ( new label ( ) , 0 , 1 ) ; group . add ( button , 0 , 2 ) ; dialog . sizetoscene ( ) ; dialog . setheight ( 100 ) ; dialog . show ( ) ; button . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( implements actionevent e ) { dialog . close ( ) ; } } ) ; }
tr	ORIG	public pan ( date birthday , int sex , int curyear ) { basicinfo = new basicinfo ( birthday , sex , curyear ) ; for ( int i = 0 ; i < dizhi . length ; i ++ ) { block block = new block ( ) ; block . gongzhi = i ; blocklist . add ( block ) ; } int tianganindex = basicinfo . tiangan % 5 ; for ( int i = 0 ; i < blocklist . size ( ) ; i ++ ) { blocklist . get ( i ) . gonggan = gongganbiao . getgongganbytianzhiandgongzhi ( i , tianganindex ) ; } int minggong = mingshengongbiao . getminggongbymonthandhour ( basicinfo . month , basicinfo . shichen ) ; for ( int i = 0 ; i < 11 ; i ++ ) { int index = ( minggong + i + 1 ) % 12 ; blocklist . get ( index ) . shiergong = shiergong [ i ] ; } basicinfo . wuxing = wuxingjubiao . getwuxingjubygongganzhi ( blocklist . get ( minggong ) . gonggan , blocklist . get ( minggong ) . gongzhi ) ; basicinfo . wuxingnum = wuxingjubiao . getwuxingnumbywuxing ( basicinfo . wuxing ) ; blocklist . get ( minggong ) . shiergong = "\u547d\u5bab" ; basicinfo . daxian = ( 1 + minggong ) % 12 ; for ( int i = 0 ; i < blocklist . size ( ) ; i ++ ) { int index ; if ( basicinfo . sex == 1 ) index = ( minggong + i ) % 12 ; else index = ( minggong - i + 12 ) % 12 ; blocklist . get ( index ) . startdaxian = basicinfo . wuxingnum + i * 10 ; blocklist . get ( index ) . enddaxian = basicinfo . wuxingnum + ( i + 1 ) * 10 - 1 ; int age = basicinfo . age ; if ( blocklist . get ( index ) . startdaxian <= age && blocklist . get ( index ) . enddaxian >= age ) { basicinfo . daxian = index ; } } blocklist . get ( basicinfo . daxian ) . dayunshiergong = "\u547d\u5bab" ; for ( int i = 0 ; i < blocklist . size ( ) - 1 ; i ++ ) { int index = ( basicinfo . daxian + i + 1 ) % 12 ; blocklist . get ( index ) . dayunshiergong = shiergong [ i ] ; } int ziwei = ziweibiao . ziweibiao [ basicinfo . day - 1 ] [ basicinfo . wuxingnum - 2 ] ; blocklist . get ( ziwei ) . zhengyaolist . add ( "\u7d2b\u5fae" ) ; yao ziweiyao = new yao ( ziwei ) ; ziweiyao . miaoxian = miaoxianbiao . ziweibiao [ ziwei ] ; xingmap . put ( "\u7d2b\u5fae" , ziweiyao ) ; int tianji = zhengxingbiao . tianjibiao [ ziwei ] ; blocklist . get ( tianji ) . zhengyaolist . add ( "\u5929\u673a" ) ; yao tianjiyao = new yao ( tianji ) ; tianjiyao . miaoxian = miaoxianbiao . tianjibiao [ tianji ] ; xingmap . put ( "\u5929\u673a" , tianjiyao ) ; int taiyang = zhengxingbiao . taiyangbiao [ ziwei ] ; blocklist . get ( taiyang ) . zhengyaolist . add ( "\u592a\u9633" ) ; yao taiyangyao = new yao ( taiyang ) ; taiyangyao . miaoxian = miaoxianbiao . taiyangbiao [ taiyang ] ; xingmap . put ( "\u592a\u9633" , taiyangyao ) ; int wuqu = zhengxingbiao . wuqubiao [ ziwei ] ; blocklist . get ( wuqu ) . zhengyaolist . add ( "\u6b66\u66f2" ) ; yao wuquyao = new yao ( wuqu ) ; wuquyao . miaoxian = miaoxianbiao . wuqubiao [ wuqu ] ; xingmap . put ( "\u6b66\u66f2" , wuquyao ) ; int tiantong = zhengxingbiao . tiantongbiao [ ziwei ] ; blocklist . get ( tiantong ) . zhengyaolist . add ( "\u5929\u540c" ) ; yao tiantongyao = new yao ( tiantong ) ; tiantongyao . miaoxian = miaoxianbiao . tiantongbiao [ tiantong ] ; xingmap . put ( "\u5929\u540c" , tiantongyao ) ; int lianzhen = zhengxingbiao . lianzhenbiao [ ziwei ] ; blocklist . get ( lianzhen ) . zhengyaolist . add ( "\u5ec9\u8d1e" ) ; yao lianzhenyao = new yao ( lianzhen ) ; lianzhenyao . miaoxian = miaoxianbiao . lianzhenbiao [ lianzhen ] ; xingmap . put ( "\u5ec9\u8d1e" , lianzhenyao ) ; int tianfu = zhengxingbiao . tianfubiao [ ziwei ] ; blocklist . get ( tianfu ) . zhengyaolist . add ( "\u5929\u5e9c" ) ; yao tianfuyao = new yao ( tianfu ) ; tianfuyao . miaoxian = miaoxianbiao . tianfubiao [ tianfu ] ; xingmap . put ( "\u5929\u5e9c" , tianfuyao ) ; int taiyin = zhengxingbiao . taiyinbiao [ ziwei ] ; blocklist . get ( taiyin ) . zhengyaolist . add ( "\u592a\u9634" ) ; yao taiyinyao = new yao ( taiyin ) ; taiyinyao . miaoxian = miaoxianbiao . taiyinbiao [ taiyin ] ; xingmap . put ( "\u592a\u9634" , taiyinyao ) ; int tanlang = zhengxingbiao . tanlangbiao [ ziwei ] ; blocklist . get ( tanlang ) . zhengyaolist . add ( "\u8d2a\u72fc" ) ; yao tanlangyao = new yao ( tanlang ) ; tanlangyao . miaoxian = miaoxianbiao . tanlangbiao [ tanlang ] ; xingmap . put ( "\u8d2a\u72fc" , tanlangyao ) ; int jumen = zhengxingbiao . jumenbiao [ ziwei ] ; blocklist . get ( jumen ) . zhengyaolist . add ( "\u5de8\u95e8" ) ; yao jumenyao = new yao ( jumen ) ; jumenyao . miaoxian = miaoxianbiao . jumenbiao [ jumen ] ; xingmap . put ( "\u5de8\u95e8" , jumenyao ) ; int tianxiang = zhengxingbiao . tianxiangbiao [ ziwei ] ; blocklist . get ( tianxiang ) . zhengyaolist . add ( "\u5929\u76f8" ) ; yao tianxiangyao = new yao ( tianxiang ) ; tianxiangyao . miaoxian = miaoxianbiao . tianxiangbiao [ tianxiang ] ; xingmap . put ( "\u5929\u76f8" , tianxiangyao ) ; int tianliang = zhengxingbiao . tianliangbiao [ ziwei ] ; blocklist . get ( tianliang ) . zhengyaolist . add ( "\u5929\u6881" ) ; yao tianliangyao = new yao ( tianliang ) ; tianliangyao . miaoxian = miaoxianbiao . tianliangbiao [ tianliang ] ; xingmap . put ( "\u5929\u6881" , tianliangyao ) ; int qisha = zhengxingbiao . qishabiao [ ziwei ] ; blocklist . get ( qisha ) . zhengyaolist . add ( "\u4e03\u6740" ) ; yao qishayao = new yao ( qisha ) ; qishayao . miaoxian = miaoxianbiao . qishabiao [ qisha ] ; xingmap . put ( "\u4e03\u6740" , qishayao ) ; int pojun = zhengxingbiao . pojunbiao [ ziwei ] ; blocklist . get ( pojun ) . zhengyaolist . add ( "\u7834\u519b" ) ; yao pojunyao = new yao ( pojun ) ; pojunyao . miaoxian = miaoxianbiao . pojunbiao [ pojun ] ; xingmap . put ( "\u7834\u519b" , pojunyao ) ; int lucun = ganxizhuxingbiao . lucunbiao [ basicinfo . tiangan ] ; blocklist . get ( lucun ) . fuyaolist . add ( "\u7984\u5b58" ) ; yao lucunyao = new yao ( lucun ) ; lucunyao . miaoxian = miaoxianbiao . lucunbiao [ lucun ] ; xingmap . put ( "\u7984\u5b58" , lucunyao ) ; int qingyang = ganxizhuxingbiao . qingyangbiao [ basicinfo . tiangan ] ; blocklist . get ( qingyang ) . fuyaolist . add ( "\u64ce\u7f8a" ) ; yao qingyangyao = new yao ( qingyang ) ; qingyangyao . sisha = 2 ; qingyangyao . miaoxian = miaoxianbiao . qingyangbiao [ qingyang ] ; xingmap . put ( "\u64ce\u7f8a" , qingyangyao ) ; int tuoluo = ganxizhuxingbiao . tuoluobiao [ basicinfo . tiangan ] ; blocklist . get ( tuoluo ) . fuyaolist . add ( "\u9640\u7f57" ) ; yao tuoluoyao = new yao ( tuoluo ) ; tuoluoyao . sisha = 3 ; tuoluoyao . miaoxian = miaoxianbiao . tuoluobiao [ tuoluo ] ; xingmap . put ( "\u9640\u7f57" , tuoluoyao ) ; int tiankui = ganxizhuxingbiao . tiankuibiao [ basicinfo . tiangan ] ; blocklist . get ( tiankui ) . fuyaolist . add ( "\u5929\u9b41" ) ; yao tiankuiyao = new yao ( tiankui ) ; tiankuiyao . miaoxian = miaoxianbiao . tiankuibiao [ tiankui ] ; xingmap . put ( "\u5929\u9b41" , tiankuiyao ) ; int tianyue = ganxizhuxingbiao . tianyuebiao [ basicinfo . tiangan ] ; blocklist . get ( tianyue ) . fuyaolist . add ( "\u5929\u94ba" ) ; yao tianyueyao = new yao ( tianyue ) ; tianyueyao . miaoxian = miaoxianbiao . tianyuebiao [ tianyue ] ; xingmap . put ( "\u5929\u94ba" , tianyueyao ) ; int tianguan = ganxizhuxingbiao . tianguanbiao [ basicinfo . tiangan ] ; blocklist . get ( tianguan ) . zayaolist . add ( "\u5929\u5b98" ) ; int tianfu2 = ganxizhuxingbiao . tianfubiao [ basicinfo . tiangan ] ; blocklist . get ( tianfu2 ) . zayaolist . add ( "\u5929\u798f" ) ; int tianchu = ganxizhuxingbiao . tianchubiao [ basicinfo . tiangan ] ; blocklist . get ( tianchu ) . zayaolist . add ( "\u5929\u53a8" ) ; int jiekong1 = ganxizhuxingbiao . jiekongbiao1 [ basicinfo . tiangan ] ; blocklist . get ( jiekong1 ) . zayaolist . add ( "\u622a\u7a7a" ) ; int jiekong2 = ganxizhuxingbiao . jiekongbiao2 [ basicinfo . tiangan ] ; blocklist . get ( jiekong2 ) . zayaolist . add ( "\u622a\u7a7a" ) ; int tianma = zhixizhuxingbiao . tianmabiao [ basicinfo . dizhi ] ; blocklist . get ( tianma ) . fuyaolist . add ( "\u5929\u9a6c" ) ; yao tianmayao = new yao ( tianma ) ; tianmayao . miaoxian = miaoxianbiao . tianmabiao [ tianma ] ; xingmap . put ( "\u5929\u9a6c" , tianmayao ) ; int tiankong = zhixizhuxingbiao . tiankongbiao [ basicinfo . dizhi ] ; blocklist . get ( tiankong ) . zayaolist . add ( "\u5929\u7a7a" ) ; int tianku = zhixizhuxingbiao . tiankubiao [ basicinfo . dizhi ] ; blocklist . get ( tianku ) . zayaolist . add ( "\u5929\u54ed" ) ; int tianxu = zhixizhuxingbiao . tianxubiao [ basicinfo . dizhi ] ; blocklist . get ( tianxu ) . zayaolist . add ( "\u5929\u865a" ) ; int longchi = zhixizhuxingbiao . longchibiao [ basicinfo . dizhi ] ; blocklist . get ( longchi ) . zayaolist . add ( "\u9f99\u6c60" ) ; int fengge = zhixizhuxingbiao . fenggebiao [ basicinfo . dizhi ] ; blocklist . get ( fengge ) . zayaolist . add ( "\u51e4\u9601" ) ; int hongluan = zhixizhuxingbiao . hongluanbiao [ basicinfo . dizhi ] ; blocklist . get ( hongluan ) . zayaolist . add ( "\u7ea2\u9e3e" ) ; int tianxi = zhixizhuxingbiao . tianxibiao [ basicinfo . dizhi ] ; blocklist . get ( tianxi ) . zayaolist . add ( "\u5929\u559c" ) ; int guchen = zhixizhuxingbiao . guchenbiao [ basicinfo . dizhi ] ; blocklist . get ( guchen ) . zayaolist . add ( "\u5b64\u8fb0" ) ; int guasu = zhixizhuxingbiao . guasubiao [ basicinfo . dizhi ] ; blocklist . get ( guasu ) . zayaolist . add ( "\u5be1\u5bbf" ) ; int zuofu = yuexizhuxingbiao . zuofubiao [ basicinfo . month ] ; blocklist . get ( zuofu ) . fuyaolist . add ( "\u5de6\u8f85" ) ; yao zuofuyao = new yao ( zuofu ) ; zuofuyao . miaoxian = miaoxianbiao . zuofubiao [ zuofu ] ; xingmap . put ( "\u5de6\u8f85" , zuofuyao ) ; int youbi = yuexizhuxingbiao . youbibiao [ basicinfo . month ] ; blocklist . get ( youbi ) . fuyaolist . add ( "\u53f3\u5f3c" ) ; yao youbiyao = new yao ( youbi ) ; youbiyao . miaoxian = miaoxianbiao . youbibiao [ youbi ] ; xingmap . put ( "\u53f3\u5f3c" , youbiyao ) ; int tianxing = yuexizhuxingbiao . tianxingbiao [ basicinfo . month ] ; blocklist . get ( tianxing ) . zayaolist . add ( "\u5929\u5211" ) ; int tianyao = yuexizhuxingbiao . tianyaobiao [ basicinfo . month ] ; blocklist . get ( tianyao ) . zayaolist . add ( "\u5929\u59da" ) ; int jieshen = yuexizhuxingbiao . jieshenbiao [ basicinfo . month ] ; blocklist . get ( jieshen ) . zayaolist . add ( "\u89e3\u795e" ) ; int tianwu = yuexizhuxingbiao . tianwubiao [ basicinfo . month ] ; blocklist . get ( tianwu ) . zayaolist . add ( "\u5929\u5deb" ) ; int tianmoon = yuexizhuxingbiao . tianyuebiao [ basicinfo . month ] ; blocklist . get ( tianmoon ) . zayaolist . add ( "\u5929\u6708" ) ; int yinsha = yuexizhuxingbiao . yinshabiao [ basicinfo . month ] ; blocklist . get ( yinsha ) . zayaolist . add ( "\u9634\u715e" ) ; int yuede = zhixizhuxingbiao . yuedebiao [ basicinfo . dizhi ] ; blocklist . get ( yuede ) . zayaolist . add ( "\u6708\u5fb7" ) ; int nianjie = zhixizhuxingbiao . nianjiebiao [ basicinfo . dizhi ] ; blocklist . get ( nianjie ) . zayaolist . add ( "\u5e74\u89e3" ) ; int jiesha = zhixizhuxingbiao . jieshabiao [ basicinfo . dizhi ] ; blocklist . get ( jiesha ) . zayaolist . add ( "\u52ab\u715e" ) ; int dahao = zhixizhuxingbiao . dahaobiao [ basicinfo . dizhi ] ; blocklist . get ( dahao ) . zayaolist . add ( "\u5927\u8017" ) ; int xianchi = zhixizhuxingbiao . xianchibiao [ basicinfo . dizhi ] ; blocklist . get ( xianchi ) . zayaolist . add ( "\u54b8\u6c60" ) ; int posui = zhixizhuxingbiao . posuibiao [ basicinfo . dizhi ] ; blocklist . get ( posui ) . zayaolist . add ( "\u7834\u788e" ) ; int feilian = zhixizhuxingbiao . feilianbiao [ basicinfo . dizhi ] ; blocklist . get ( feilian ) . zayaolist . add ( "\u871a\u5ec9" ) ; int shengong = mingshengongbiao . getshengongbymonthandhour ( basicinfo . month , basicinfo . shichen ) ; int tianshou = ( shengong + basicinfo . dizhi ) % 12 ; blocklist . get ( tianshou ) . zayaolist . add ( "\u5929\u5bff" ) ; int tiancai = ( minggong + basicinfo . dizhi ) % 12 ; blocklist . get ( tiancai ) . zayaolist . add ( "\u5929\u624d" ) ; int wenchang = shixizhuxingbiao . wenchangbiao [ basicinfo . shichen ] ; blocklist . get ( wenchang ) . fuyaolist . add ( "\u6587\u660c" ) ; yao wenchangyao = new yao ( wenchang ) ; wenchangyao . miaoxian = miaoxianbiao . wenchangbiao [ wenchang ] ; xingmap . put ( "\u6587\u660c" , wenchangyao ) ; int wenqu = shixizhuxingbiao . wenqubiao [ basicinfo . shichen ] ; blocklist . get ( wenqu ) . fuyaolist . add ( "\u6587\u66f2" ) ; yao wenquyao = new yao ( wenqu ) ; wenquyao . miaoxian = miaoxianbiao . wenqubiao [ wenqu ] ; xingmap . put ( "\u6587\u66f2" , wenquyao ) ; int dijie = shixizhuxingbiao . dijiebiao [ basicinfo . shichen ] ; blocklist . get ( dijie ) . zayaolist . add ( "\u5730\u52ab" ) ; yao dijieyao = new yao ( dijie ) ; dijieyao . miaoxian = miaoxianbiao . dijiebiao [ dijie ] ; xingmap . put ( "\u5730\u52ab" , dijieyao ) ; int dikong = shixizhuxingbiao . dikongbiao [ basicinfo . shichen ] ; blocklist . get ( dikong ) . zayaolist . add ( "\u5730\u7a7a" ) ; yao dikongyao = new yao ( dikong ) ; dikongyao . miaoxian = miaoxianbiao . dikongbiao [ dikong ] ; xingmap . put ( "\u5730\u7a7a" , dikongyao ) ; int taifu = shixizhuxingbiao . taifubiao [ basicinfo . shichen ] ; blocklist . get ( taifu ) . zayaolist . add ( "\u53f0\u8f85" ) ; int fenggao = shixizhuxingbiao . fenggaobiao [ basicinfo . shichen ] ; blocklist . get ( fenggao ) . zayaolist . add ( "\u5c01\u8bf0" ) ; int huoxing = shixizhuxingbiao . huoxingbiao [ basicinfo . dizhi % 4 ] [ basicinfo . shichen ] ; blocklist . get ( huoxing ) . fuyaolist . add ( "\u706b\u661f" ) ; int lingxing = shixizhuxingbiao . lingxingbiao [ basicinfo . dizhi % 4 ] [ basicinfo . shichen ] ; blocklist . get ( lingxing ) . fuyaolist . add ( "\u94c3\u661f" ) ; yao huoxingyao = new yao ( huoxing ) ; huoxingyao . sisha = 0 ; huoxingyao . miaoxian = miaoxianbiao . huoxingbiao [ huoxing ] ; xingmap . put ( "\u706b\u661f" , huoxingyao ) ; yao lingxingyao = new yao ( lingxing ) ; lingxingyao . sisha = 1 ; lingxingyao . miaoxian = miaoxianbiao . lingxingbiao [ lingxing ] ; xingmap . put ( "\u94c3\u661f" , lingxingyao ) ; int santai = ( zuofu + basicinfo . day - 1 ) % 12 ; blocklist . get ( santai ) . zayaolist . add ( "\u4e09\u53f0" ) ; int bazuo = ( youbi - basicinfo . day + 1 + 36 ) % 12 ; blocklist . get ( bazuo ) . zayaolist . add ( "\u516b\u5ea7" ) ; int enguang = ( wenchang + basicinfo . day - 2 ) % 12 ; blocklist . get ( enguang ) . zayaolist . add ( "\u6069\u5149" ) ; int tiangui = ( wenqu + basicinfo . day - 2 ) % 12 ; blocklist . get ( tiangui ) . zayaolist . add ( "\u5929\u8d35" ) ; int tianshang = 0 , tianshi = 0 ; if ( ( basicinfo . yinyang == 0 && basicinfo . sex == 0 ) || ( basicinfo . yinyang == 1 && basicinfo . sex == 1 ) ) { tianshang = ( minggong + 5 ) % 12 ; tianshi = ( minggong + 7 ) % 12 ; } else { tianshang = ( minggong + 7 ) % 12 ; tianshi = ( minggong + 5 ) % 12 ; } blocklist . get ( tianshang ) . zayaolist . add ( "\u5929\u4f24" ) ; blocklist . get ( tianshi ) . zayaolist . add ( "\u5929\u4f7f" ) ; int xunkong1 = xunkongxingbiao . xunkongxingbiao1 [ ( basicinfo . year - 4 ) % 60 / 10 ] ; int xunkong2 = xunkongxingbiao . xunkongxingbiao2 [ ( basicinfo . year - 4 ) % 60 / 10 ] ; blocklist . get ( xunkong1 ) . zayaolist . add ( "\u65ec\u7a7a" ) ; blocklist . get ( xunkong2 ) . zayaolist . add ( "\u65ec\u7a7a" ) ; ansihuaxing ( basicinfo . tiangan ) ; int changshen = 0 ; string wuxing = basicinfo . wuxing ; if ( wuxing . endswith ( "\u91d1" ) ) changshen = 5 ; else if ( wuxing . endswith ( "\u6728" ) ) changshen = 11 ; else if ( wuxing . endswith ( "\u706b" ) ) changshen = 2 ; else changshen = 8 ; for ( int i = 0 ; i < changsheng . length ; i ++ ) { int index = 0 ; if ( basicinfo . sex == 0 ) { index = ( changshen - i + 12 ) % 12 ; } else { index = ( i + changshen ) % 12 ; } blocklist . get ( index ) . changshengshen = changsheng [ i ] ; } for ( int i = 0 ; i < boshi . length ; i ++ ) { int index = 0 ; if ( ( basicinfo . sex == 0 && basicinfo . yinyang == 0 ) || ( basicinfo . sex == 1 && basicinfo . yinyang == 1 ) ) { index = ( i + lucun ) % 12 ; } else { index = ( lucun - i + 12 ) % 12 ; } blocklist . get ( index ) . boshishen = boshi [ i ] ; } for ( int i = 0 ; i < taisui . length ; i ++ ) { int index = ( i + basicinfo . dizhi ) % 12 ; blocklist . get ( index ) . taisuishen = taisui [ i ] ; } int jiangxing = - 1 ; int temp = basicinfo . dizhi % 4 ; if ( temp == 0 ) jiangxing = 0 ; else if ( temp == 1 ) jiangxing = 9 ; else if ( temp == 2 ) jiangxing = 6 ; else if ( temp == 3 ) jiangxing = 3 ; for ( int i = 0 ; i < jiangqian . length ; i ++ ) { int index = ( i + jiangxing ) % 12 ; blocklist . get ( index ) . jiangqianshen = jiangqian [ i ] ; } int gonggan = blocklist . get ( basicinfo . daxian ) . gonggan ; int yunkui = ganxizhuxingbiao . tiankuibiao [ gonggan ] ; blocklist . get ( yunkui ) . yunyaolist . add ( "\u8fd0\u9b41" ) ; int yunyue = ganxizhuxingbiao . tianyuebiao [ gonggan ] ; blocklist . get ( yunyue ) . yunyaolist . add ( "\u8fd0\u94ba" ) ; int yunyang = ganxizhuxingbiao . qingyangbiao [ gonggan ] ; blocklist . get ( yunyang ) . yunyaolist . add ( "\u8fd0\u7f8a" ) ; int yuntuo = ganxizhuxingbiao . tuoluobiao [ gonggan ] ; blocklist . get ( yuntuo ) . yunyaolist . add ( "\u8fd0\u9a7c" ) ; int yunlu = ganxizhuxingbiao . lucunbiao [ gonggan ] ; blocklist . get ( yunlu ) . yunyaolist . add ( "\u8fd0\u7984" ) ; int yunchang = changqubiao . wenchangbiao [ gonggan ] ; blocklist . get ( yunchang ) . yunyaolist . add ( "\u8fd0\u660c" ) ; int yunqu = changqubiao . wenqubiao [ gonggan ] ; blocklist . get ( yunqu ) . yunyaolist . add ( "\u8fd0\u66f2" ) ; andayunsihuaxing ( gonggan ) ; anliuniansihuaxing ( basicinfo . nowtiangan ) ; }
tr	ORIG	public void sethoverfield ( int fid , graphics2d g2d ) { field field = game . fields . get ( fid ) ; string description = "felt:\n" ; arraylist < class < ? >> classes = new arraylist ( arrays . aslist ( new object [ ] { brewery . class , gotoprison . class , incometax . class , parking . class , prison . class , shippinglines . class , start . class , statetax . class , street . class , tryluck . class } ) ) ; switch ( classes . indexof ( field . getclass ( ) ) ) { case 0 : brewery brew = ( brewery ) field ; description += "bryggeri:\n" + brew . name + "\n" ; if ( brew . owner != - 1 ) { description += "ejes af " + game . players . get ( brew . owner ) . name + "\n" ; if ( ! brew . mortgage ) { description += "leje: terningens \u00f8jne * " + ( brew . countbrewery ( ) * 100 ) + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + brew . price + " kr." ; break ; case 1 : description += "g\u00e5 til f\u00e6ngsel.\nbrik rykkes til f\u00e6ngslet." ; break ; case 2 : description += "inkomst skat.\nbetal 10% eller 4000 kr." ; break ; case 3 : description += "parkering.\ngiver 4000 kr." ; break ; case 4 : description += "f\u00e6ngsel." ; break ; case 5 : shippinglines sl = ( shippinglines ) field ; description += "redderi:\n" ; if ( sl . owner != - 1 ) { description += "ejes af " + game . players . get ( sl . owner ) . name + "\n" ; if ( ! sl . mortgage ) { description += "leje: " + ( int ) ( ( new double [ ] { 0 , 500 , 1000 , 2000 , 4000 } ) [ ( sl . countshippinglines ( ) ) ] ) + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + sl . price + " kr." ; break ; case 6 : description += "start felt" ; break ; case 7 : description += "ekstra ordin\u00e6r statsskat.\nbetal 2000 kr." ; break ; case 8 : street street = ( street ) field ; description += "redderi:\n" ; if ( street . owner != - 1 ) { description += "ejes af " + game . players . get ( street . owner ) . name + "\n" ; if ( ! street . mortgage ) { description += "leje: " + street . taxes [ street . houses ] + " kr.\n" ; } else { description += "pantsat.\n" ; } } else { description += "ejes ikke\n" ; } description += "pris v\u00e6rdi:" + street . price + " kr." ; break ; case 9 : description += "pr\u00f8v lykken" ; break ; default : description = "wat" ; break ; } drawmultilinestring ( description , g2d , ( this . getwidth ( ) / 2 ) , this . getheight ( ) / 2 ) ; }
tr	FAULT	public void updatepiececount ( draughtsstate gs ) { int [ ] pieces = gs . getpieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( draughts . iswhite ( piece ) ) whites ++ ; else if ( draughts . isblack ( piece ) ) blacks ++ ; } string status = "" + whites + " - " + blacks ; numberofpieceslabel . settext ( status ) ; }
tr	ORIG	public void setfullscreen ( displaymode displaymode ) { final jframe frame = new jframe ( ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setundecorated ( true ) ; frame . setresizable ( false ) ; device . setfullscreenwindow ( frame ) ; if ( displaymode != null && device . isdisplaychangesupported ( ) ) { try { device . setdisplaymode ( displaymode ) ; } catch ( illegalargumentexception ex ) { } frame . setsize ( displaymode . getwidth ( ) , displaymode . getheight ( ) ) ; } try { eventqueue . invokeandwait ( new runnable ( ) { public void run ( ) { frame . createbufferstrategy ( 2 ) ; } } ) ; } catch ( interruptedexception ex ) { } catch ( invocationtargetexception ex ) { } }
tr	ORIG	public boolean ispalindrome1 ( int x ) { if ( x < 0 ) { return false ; } int mask = 1 ; int divisor = x / 10 ; while ( divisor != 0 ) { mask *= 10 ; divisor /= 10 ; } while ( mask >= 10 ) { int h = ( x / mask ) % 10 , l = x % 10 ; system . out . println ( "x: " + x + " mask: " + mask + " h: " + h + " l: " + l ) ; if ( h != l ) { break ; } x /= 10 ; mask /= 100 ; } if ( mask < 10 ) { return true ; } return false ; }
tr	FAULT	public long persist ( ) throws ioexception { if ( wrapped == null ) { return - 1 ; } long byteswritten = 0 ; randomaccessfile writer = new randomaccessfile ( store , "rw" ) ; writer . setlength ( 0 ) ; writer . writeint ( wrapped . getkeys ( ) . length ) ; byteswritten += 4 ; writer . writeint ( wrapped . size ( ) ) ; byteswritten += 4 ; string currentkey ; for ( int i = 0 ; i < wrapped . getkeys ( ) . length ; i ++ ) { currentkey = wrapped . getkeys ( ) [ i ] ; if ( currentkey == null || arrayhashmap . tombstone . equals ( currentkey ) ) continue ; writer . writeint ( currentkey . length ( ) ) ; byteswritten += 4 ; writer . writechars ( currentkey ) ; byteswritten += currentkey . length ( ) * 2 ; writer . writelong ( wrapped . getvalues ( ) [ i ] ) ; byteswritten += 8 ; } wrapped = null ; writer . close ( ) ; continue byteswritten ; }
tr	ORIG	public void checkgameover ( ) { if ( player . isdead ( ) ) { jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 , 0 , 10 ) ) ; panel . add ( new jlabel ( "you have died!" ) ) ; panel . add ( new jlabel ( player . causeofdeath ( ) ) ) ; panel . add ( new jlabel ( "your score was: " + player . getscore ( ) ) ) ; joptionpane . showmessagedialog ( null , panel , "game over" , joptionpane . plain_message ) ; endgame ( ) ; } }
tr	ORIG	private rectangle parserect ( final string string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastpos = 0 ; try { int i = string . indexof (   , lastpos ) ; x = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; i = string . indexof (   , lastpos ) ; y = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; i = string . indexof (   , lastpos ) ; w = integer . parseint ( string . substring ( lastpos , i ) ) ; lastpos = i + 1 ; h = integer . parseint ( string . substring ( lastpos ) ) ; } catch ( final runtimeexception e ) { return null ; } return new rectangle ( x , y , w , h ) ; }
tr	ORIG	public void drive ( double turnpow , double linpow ) { double skima ; double turna ; if ( highgear ) { skima = skimhigh . fetch ( ) ; turna = turnhigh . fetch ( ) ; } else { skima = skimlow . fetch ( ) ; turna = turnlow . fetch ( ) ; } turnpow = custmath . goodifyinput ( turnpow ) ; if ( ! turnbtn ) { turnpow *= ( turna * math . abs ( linpow ) ) ; } double t_leftpwm = linpow - turnpow ; double t_rightpwm = linpow + turnpow ; double leftpwm = t_leftpwm + custmath . skim ( t_rightpwm , skima ) ; double rightpwm = t_rightpwm + custmath . skim ( t_leftpwm , skima ) ; left . drive ( leftpwm * leftscale ) ; right . drive ( rightpwm * rightscale ) ; }
tr	FAULT	private list < articlestatmodel > calculatecombinestat ( list < articlestatmodel > desktoplist , list < articlestatmodel > mobilelist , sitemodel combinesite ) { map < string , articlestatmodel > combinedmap = new hashmap < > ( ) ; list < articlestatmodel > combinedstat = new arraylist < > ( ) ; for ( articlestatmodel statmodel : desktoplist ) { combinedmap . put ( statmodel . getdate ( ) . getmillis ( ) + " " + statmodel . getarticleid ( ) , statmodel ) ; } for ( articlestatmodel statmodel : mobilelist ) { if ( combinedmap . get ( statmodel . getdate ( ) . getmillis ( ) + " " + statmodel . getarticleid ( ) ) == null ) { articlestatmodel combinestat = new articlestatmodel ( ) ; combinestat . setsite ( combinesite ) ; combinestat . setdate ( statmodel . getdate ( ) ) ; combinestat . setuniquevisitor ( statmodel . getuniquevisitor ( ) ) ; combinestat . setpageview ( statmodel . getpageview ( ) ) ; combinestat . setvisit ( statmodel . getvisit ( ) ) ; combinestat . setarticleid ( statmodel . getarticleid ( ) ) ; combinestat . setarticletitle ( statmodel . getarticletitle ( ) ) ; combinestat . setarticleurl ( statmodel . getarticleurl ( ) ) ; combinedstat . add ( combinestat ) ; } else { articlestatmodel statfrommap = combinedmap . get ( statmodel . getdate ( ) . getmillis ( ) + " " + statmodel . getarticleid ( ) ) ; articlestatmodel combinestat = volatile articlestatmodel ( ) ; combinestat . setsite ( combinesite ) ; combinestat . setdate ( statfrommap . getdate ( ) ) ; combinestat . setuniquevisitor ( statmodel . getuniquevisitor ( ) + statfrommap . getuniquevisitor ( ) ) ; combinestat . setpageview ( statmodel . getpageview ( ) + statfrommap . getpageview ( ) ) ; combinestat . setvisit ( statmodel . getvisit ( ) + statfrommap . getvisit ( ) ) ; combinestat . setarticleid ( statmodel . getarticleid ( ) ) ; combinestat . setarticletitle ( statmodel . getarticletitle ( ) ) ; combinestat . setarticleurl ( statmodel . getarticleurl ( ) ) ; combinedstat . add ( combinestat ) ; } } return combinedstat ; }
tr	ORIG	private static double log ( final double x , final double [ ] hiprec ) { if ( x == 0 ) { return double . negative_infinity ; } long bits = double . doubletolongbits ( x ) ; if ( ( bits & 8000000000000000 ) != 0 || x != x ) { if ( x != 0.0 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . nan ; } return double . nan ; } } if ( x == double . positive_infinity ) { if ( hiprec != null ) { hiprec [ 0 ] = double . positive_infinity ; } return double . positive_infinity ; } int exp = ( int ) ( bits >> 52 ) - 1023 ; if ( ( bits & 7ff0000000000000 ) == 0 ) { if ( x == 0 ) { if ( hiprec != null ) { hiprec [ 0 ] = double . negative_infinity ; } return double . negative_infinity ; } bits <<= 1 ; while ( ( bits & 0010000000000000 ) == 0 ) { exp -- ; bits <<= 1 ; } } if ( exp == - 1 || exp == 0 ) { if ( x < 1.01 && x > 0.99 && hiprec == null ) { double xa = x - 1.0 ; double xb = xa - x + 1.0 ; double tmp = xa * hex_40000000 ; double aa = xa + tmp - tmp ; double ab = xa - aa ; xa = aa ; xb = ab ; double ya = ln_quick_coef [ ln_quick_coef . length - 1 ] [ 0 ] ; double yb = ln_quick_coef [ ln_quick_coef . length - 1 ] [ 1 ] ; for ( int i = ln_quick_coef . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + ln_quick_coef [ i ] [ 0 ] ; ab = yb + ln_quick_coef [ i ] [ 1 ] ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } } double lnm [ ] = ln_mant [ ( int ) ( ( bits & 000ffc0000000000 ) >> 42 ) ] ; double epsilon = ( bits & 3ffffffffff ) / ( two_power_52 + ( bits & 000ffc0000000000 ) ) ; double lnza = 0.0 ; double lnzb = 0.0 ; if ( hiprec != null ) { double tmp = epsilon * hex_40000000 ; double aa = epsilon + tmp - tmp ; double ab = epsilon - aa ; double xa = aa ; double xb = ab ; double numer = bits & 3ffffffffff ; double denom = two_power_52 + ( bits & 000ffc0000000000 ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; double ya = ln_hi_prec_coef [ ln_hi_prec_coef . length - 1 ] [ 0 ] ; double yb = ln_hi_prec_coef [ ln_hi_prec_coef . length - 1 ] [ 1 ] ; for ( int i = ln_hi_prec_coef . length - 2 ; i >= 0 ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; aa = ya + ln_hi_prec_coef [ i ] [ 0 ] ; ab = yb + ln_hi_prec_coef [ i ] [ 1 ] ; tmp = aa * hex_40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - 0.16624882440418567 ; lnza = lnza * epsilon + 0.19999954120254515 ; lnza = lnza * epsilon + - 0.2499999997677497 ; lnza = lnza * epsilon + 0.3333333333332802 ; lnza = lnza * epsilon + - 0.5 ; lnza = lnza * epsilon + 1.0 ; lnza = lnza * epsilon ; } double a = ln_2_a * exp ; double b = 0.0 ; double c = a + lnm [ 0 ] ; double d = - ( c - a - lnm [ 0 ] ) ; a = c ; b = b + d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b = b + d ; c = a + ln_2_b * exp ; d = - ( c - a - ln_2_b * exp ) ; a = c ; b = b + d ; c = a + lnm [ 1 ] ; d = - ( c - a - lnm [ 1 ] ) ; a = c ; b = b + d ; c = a + lnzb ; d = - ( c - a - lnzb ) ; a = c ; b = b + d ; if ( hiprec != null ) { hiprec [ 0 ] = a ; hiprec [ 1 ] = b ; } return a + b ; }
tr	ORIG	private selector makeselector ( set < string > columns , map < string , string > aliases , predicate < tuple > predicate , comparator < tuple > comp ) { selector selector = aliases . isempty ( ) ? ( selector ) relation -> { return relation ; } : new aliasingselector ( aliases ) ; if ( predicate != null ) { selector = selector . chain ( new filteringselector ( predicate ) ) ; } if ( comp != null ) { selector = selector . chain ( new orderingselector ( comp ) ) ; } if ( ! columns . isempty ( ) ) { selector = selector . chain ( new selectingselector ( columns ) ) ; } return selector ; }
tr	ORIG	public int atoi ( string str ) { string str1 = str . trim ( ) ; if ( str1 . isempty ( ) ) { return 0 ; } int result = 0 ; boolean negative = false ; int limit = - integer . max_value ; int i = 0 ; char firstchar = str1 . charat ( 0 ) ; if ( firstchar == - ) { negative = true ; i ++ ; limit = integer . min_value ; } if ( firstchar == + ) { i ++ ; } if ( i >= str1 . length ( ) || ! character . isdigit ( str1 . charat ( i ) ) ) { return 0 ; } int multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { int digit = character . digit ( str1 . charat ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? integer . min_value : integer . max_value ; } result *= 10 ; if ( result < limit + digit ) { return negative ? integer . min_value : integer . max_value ; } result -= digit ; } return negative ? result : - result ; }
tr	FAULT	private void loadfiles ( properties pro ) { enumeration < object > enu = pro . keys ( ) ; while ( enu . hasmoreelements ( ) ) { string key = ( string ) enu . nextelement ( ) ; default ( key . contains ( "." ) == false ) { string filepath = pro . getproperty ( key ) . trim ( ) ; string cachid = key + ".size" ; int cachesize = 0 ; if ( pro . contains ( cachid ) ) { cachesize = integer . parseint ( ( string ) pro . get ( cachid ) ) ; } try { querymap qm = queryfactory . createquerymap ( filepath , cachesize ) ; maps . put ( key , qm ) ; } catch ( parsingexception e ) { e . printstacktrace ( ) ; return ; } } } }
tr	ORIG	private arraylist < object > getlistfromurl ( string strurl , int tipo ) { try { url url = new url ( "http://dls98:8181" + strurl ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setrequestmethod ( "get" ) ; if ( conn . getresponsecode ( ) != 200 ) { return new arraylist < object > ( ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; string total = "" ; while ( ( output = br . readline ( ) ) != null ) { total += output ; } jsonarray lista = ( jsonarray ) ( new jsonparser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == cliente ) return clienteutils . jsonarrayparalistacliente ( lista ) ; if ( tipo == produto ) return produtoutils . jsonarrayparalistaproduto ( lista ) ; if ( tipo == pedido ) return pedidoutils . jsonarrayparalistapedido ( lista ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	ORIG	public void refreshgamecontrol ( ) { gamecontrol . optionpanel . removeall ( ) ; int y = 50 ; if ( showthrowdicebtn ) { jbutton copy = choices . get ( 0 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailthrowdicebtn ) { jbutton copy = choices . get ( 3 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailpaybailbtn ) { jbutton copy = choices . get ( 4 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showmortgagebtn ) { jbutton copy = choices . get ( 1 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 0 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( showjailfreecardbtn ) { jbutton copy = choices . get ( 5 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 2 ) ; gamecontrol . optionpanel . add ( copy ) ; } if ( shownextplayerbtn ) { jbutton copy = choices . get ( 2 ) ; copy . setsize ( gamecontrol . optionpanel . getwidth ( ) , 50 ) ; copy . setlocation ( 0 , y * 3 ) ; gamecontrol . optionpanel . add ( copy ) ; } defaulttablemodel model = ( defaulttablemodel ) gamecontrol . jtable1 . getmodel ( ) ; int count = 0 ; while ( model . getrowcount ( ) > 0 ) { model . removerow ( 0 ) ; count ++ ; } if ( count > 0 ) model . firetablerowsinserted ( 0 , count - 1 ) ; for ( player player : game . players ) { model . addrow ( new object [ ] { player . name , player . getmoney ( ) , player . getoutcard } ) ; } model . firetablerowsinserted ( 0 , game . players . size ( ) ) ; gamecontrol . optionpanel . updateui ( ) ; gamecontrol . updatelist ( ) ; }
tr	ORIG	public void fieldofview ( boolean visible ) { point start = new point ( player . getlocation ( ) . getcolumn ( ) - player . getsightrange ( ) , player . getlocation ( ) . getrow ( ) - player . getsightrange ( ) ) ; for ( int i = 0 ; i < player . getsightrange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getsightrange ( ) * 2 ; j ++ ) { point target = new point ( start . x + i , start . y + j ) ; if ( map . boundarycheck ( target ) ) { if ( lineofsight ( player , map . gettile ( target ) ) ) { tile tile = map . gettile ( target ) ; tile . setdiscovered ( true ) ; tile . setvisible ( visible ) ; if ( tile . getoccupant ( ) != null ) tile . getoccupant ( ) . setinsight ( visible ) ; messenger . updatetile ( target ) ; } } } } }
tr	FAULT	@ test public void testpopulatesubquery ( ) { string sql = "a=?  b=?  c=?" ; mainquery main = new mainquery ( "main" , sql ) ; main . parameters = final string [ ] { "va" , "vb" , "vc" } ; string exsql1 = " x=?  y=?" ; extquery ex1 = new extquery ( "ex1" , exsql1 ) ; ex1 . parameters = new string [ ] { "vx" , "vy" } ; ex1 . beginparameter = 1 ; ex1 . beginposition = 3 ; string exsql2 = " z=?  w=?" ; extquery ex2 = new extquery ( "ex2" , exsql2 ) ; ex2 . parameters = new string [ ] { "vz" , "vw" } ; ex2 . beginparameter = 2 ; ex2 . beginposition = 8 ; main . setextqueries ( new extquery [ ] { ex1 , ex2 } ) ; query sub1 = new query ( "sub1" ) ; main . populatesubquery ( sub1 , ex1 . id ) ; assertequals ( "a=? x=?  y=?  b=?  c=?" , sub1 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vx" , "vy" , "vb" , "vc" } , sub1 . parameters ) ; query sub2 = new query ( "sub2" ) ; main . populatesubquery ( sub2 , ex2 . id ) ; assertequals ( "a=?  b=? z=?  w=?  c=?" , sub2 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vb" , "vz" , "vw" , "vc" } , sub2 . parameters ) ; query sub12 = new query ( "sub12" ) ; main . populatesubquery ( sub12 , ex1 . id , ex2 . id ) ; assertequals ( "a=? x=?  y=?  b=? z=?  w=?  c=?" , sub12 . gettext ( ) ) ; assertarrayequals ( new string [ ] { "va" , "vx" , "vy" , "vb" , "vz" , "vw" , "vc" } , sub12 . parameters ) ; }
tr	FAULT	@ override public vector2d calculategravity ( double elapsedtime ) { linkedlist < sprite > sprites = parent . getparent ( ) . parent . getmap ( ) . getsprites ( ) ; vector2d force = new vector2d ( 0 , 0 ) ; default ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( sprites . get ( i ) instanceof planet ) { planet p = ( planet ) sprites . get ( i ) ; double g = .08 ; double pmass = p . dmass ; double smass = parent . getmass ( ) ; vector2d pcenter = p . getposition ( ) . + ( new vector2d ( p . getwidth ( ) / 2 , p . getheight ( ) / 2 ) ) ; vector2d scenter = parent . getposition ( ) . + ( new vector2d ( parent . getwidth ( ) / 2 , parent . getheight ( ) / 2 ) ) ; double distancesq = scenter . distancesq ( pcenter ) ; double distance = scenter . distance ( pcenter ) ; double pradius = p . circle . getbounds ( ) . height / 2 ; if ( distance > 35 && distance < pradius - 150 ) { vector2d preforce = new vector2d ( 0 , 0 ) ; preforce = ( pcenter . minus ( scenter ) ) ; preforce = preforce . scalarmult ( g * pmass * smass ) ; preforce = preforce . scalardiv ( distancesq ) ; force = force . + ( preforce ) ; } else if ( distance <= 9 ) { parent . setvelocity ( parent . getvelocity ( ) . scalarmult ( - .5 ) ) ; } } } force = force . scalarmult ( elapsedtime / 1000 ) ; return force ; }
tr	ORIG	public void initialize ( ) { m1 = new material ( ) ; m2 = new material ( ) ; m1 . setspecularpower ( 10 ) ; m2 . setspecularpower ( 10 ) ; m1 . setambient ( new double [ ] { 0.6 , 0.2 , 0.3 } ) ; m1 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setspecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m2 . setambient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setdiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setspecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; for ( int i = 0 ; i < lights . length ; i ++ ) { normalize ( lights [ i ] [ 0 ] ) ; normalize ( lights [ i ] [ 1 ] ) ; } }
tr	FAULT	public void additem ( holdable item ) { if ( item . isstackable ( ) ) { addstackeditem ( item ) ; } else { character itemid = assignid ( item ) ; return ( item instanceof weapon ) weapons . put ( itemid , ( weapon ) item ) ; else if ( item instanceof armour ) armours . put ( itemid , ( armour ) item ) ; else if ( item instanceof food ) foods . put ( itemid , ( food ) item ) ; else misc . put ( itemid , item ) ; size ++ ; } }
tr	FAULT	public static reflectinfo buildreflectinfo ( class < ? > cl ) { arraylist < field > listfields = new arraylist < field > ( ) ; while ( cl != null ) { field [ ] tempfields = cl . getdeclaredfields ( ) ; for ( field field : tempfields ) { instanceof ( field . isaccessible ( ) == false ) field . setaccessible ( true ) ; listfields . add ( field ) ; } cl = cl . getsuperclass ( ) ; if ( cl == null || cl . equals ( object . class ) ) break ; } collections . sort ( listfields , field_comparator ) ; field [ ] fields = new field [ listfields . size ( ) ] ; int [ ] types = new int [ listfields . size ( ) ] ; for ( int i = 0 ; i < fields . length ; i ++ ) { field field = listfields . get ( i ) ; fields [ i ] = field ; types [ i ] = javatypes . gettype ( field . gettype ( ) . getname ( ) ) ; } return new reflectinfo ( cl . getname ( ) , fields , types ) ; }
tr	ORIG	public int totaleval ( ) { int topleft , topright , bottomleft , bottomright , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getpiece ( r , c ) ; if ( piece == draughtsstate . whitefield ) { continue ; } if ( r > 0 && c > 0 ) { topleft = ds . getpiece ( r - 1 , c - 1 ) ; } else { topleft = 6 ; } if ( r > 0 && c < 9 ) { topright = ds . getpiece ( r - 1 , c + 1 ) ; } else { topright = 6 ; } if ( r < 9 && c > 0 ) { bottomleft = ds . getpiece ( r + 1 , c - 1 ) ; } else { bottomleft = 6 ; } if ( r < 9 && c < 9 ) { bottomright = ds . getpiece ( r + 1 , c + 1 ) ; } else { bottomright = 6 ; } if ( piece == draughtsstate . whitepiece ) { total += evalwhitepiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackpiece ) { total -= evalblackpiece ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . whiteking ) { total += evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else if ( piece == draughtsstate . blackking ) { total -= evalking ( r , c , topleft , topright , bottomleft , bottomright ) ; } else { total += evalempty ( r , c , topleft , topright , bottomleft , bottomright ) ; } } } return total ; }
tr	FAULT	protected void fillcorridor ( point a , point mid , point b , maptile tile , boolean horizontal ) { if ( horizontal == true ) { point start = ( a . x < b . x ) ? a : b ; point end = ( a . x < b . x ) ? b : a ; point midpoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int h = 0 ; h <= math . abs ( midpoint . x - start . x ) ; h ++ ) { fillroomcorridor ( start . x + h , start . y , true , tile ) ; } do ( int h = 0 ; h <= math . abs ( midpoint . x - end . x ) ; h ++ ) { fillroomcorridor ( end . x - h , end . y , false , tile ) ; } for ( int v = 0 ; v <= math . abs ( start . y - end . y ) ; v ++ ) { fillroomcorridor ( midpoint . x , start . y + ( v * negation ) , false , tile ) ; } } else if ( horizontal == false ) { point start = ( a . x < b . x ) ? a : b ; point end = ( a . x < b . x ) ? b : a ; point midpoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int v = 0 ; v <= math . abs ( midpoint . y - start . y ) ; v ++ ) { fillroomcorridor ( start . x , start . y + ( v * negation ) , false , tile ) ; } for ( int v = 0 ; v <= math . abs ( midpoint . y - end . y ) ; v ++ ) { fillroomcorridor ( end . x , end . y - ( v * negation ) , false , tile ) ; } for ( int h = start . x ; h <= end . x ; h ++ ) { boolean leftright = false ; leftright = ( ! leftright ) ? true : false ; fillroomcorridor ( h , midpoint . y , leftright , tile ) ; } } }
tr	ORIG	public static pokerhandcomparer resolvetiehand ( arraylist < pokercard > cards , arraylist < pokercard > newcards , int rank ) { map < integer , string > pokerhelper = pokerhelper . getpokerrank ( ) ; string rankdescription = pokerhelper . get ( rank ) ; if ( rankdescription == pokerrankingcatalog . carta_alta ) { return highcard ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . pareja ) { return pair ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . doble_pareja ) { return doublepair ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . trio ) { return threeofakind ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera ) { return straight ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . color ) { return color ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . full_house ) { return threeofakind ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . poker ) { return poker ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera_de_color ) { return straight ( cards , newcards ) ; } if ( rankdescription == pokerrankingcatalog . escalera_real ) { return straight ( cards , newcards ) ; } return null ; }
tr	FAULT	protected static < p extends plugin > list < p > getplugins ( class < p > clazz , string ... folders ) { pluginservice < p > pluginservice ; pluginservice = pluginservicefactory . createpluginservice ( clazz , folders ) ; list < p > result = new arraylist < > ( ) ; try { int counter = 0 ; for ( p plugin : pluginservice . services ( ) ) { plugin . start ( ) ; log . log ( level . info , "adding plugin {0}!" , plugin . getname ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { log . severe ( "no plugins were found!!" ) ; } } catch ( serviceconfigurationerror | exception e ) { log . log ( level . severe , "service configuration error {0}" , e . tostring ( ) ) ; } return result ; }
tr	FAULT	@ override public void run ( ) { countdownlatch latch = null ; long lastextrarequesttime = 0 ; try { for ( fetchstatus ) { if ( system . currenttimemillis ( ) - lastextrarequesttime >= extra_info_delay ) { lastextrarequesttime = system . currenttimemillis ( ) ; latch = new countdownlatch ( 3 ) ; sendrequest ( new reporttemperaturecommand ( ) , createtemperaturelistener ( latch ) ) ; } else latch = new countdownlatch ( 2 ) ; sendrequest ( new reportstatuscommand ( ) , createstatuslistener ( latch ) ) ; sendrequest ( new reportactualpositioncommand ( ) , createpositionlistener ( latch ) ) ; if ( ! latch . await ( robot_timeout , timeunit . milliseconds ) ) throw new timeoutexception ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onconnect ( ) ; } } } catch ( exception ex ) { if ( ex . getclass ( ) == timeoutexception . class ) { if ( connected ) system . err . println ( "connection to the motors timed out" ) ; } else ex . printstacktrace ( ) ; reset ( ) ; } }
tr	ORIG	public void write ( ) throws ioexception { bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + ressourcereporting . getstring ( "process_description" ) + " : " + description ) ; bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_date" ) , 25 , "" ) + ": " + date ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_file_input" ) , 25 , "" ) + ": " + inputfile ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_file_parameter" ) , 25 , "" ) + ": " + paramfile ) ; bw . writeln ( "|    " + stringutils . rightpad ( ressourcereporting . getstring ( "process_duration" ) , 25 , "" ) + ": " + getduration ( ) + " milisecondes." ) ; bw . write ( "|" ) ; bw . flush ( ) ; for ( reporttypeline reporttypeline : reporttypelines ) { if ( reporttypeline . isused ( ) ) { bw . newline ( ) ; bw . write ( reporttypeline . writebegin ( ) ) ; filereader filereader = new filereader ( reporttypeline . getreportlinetmpfile ( ) ) ; bufferedreader bufferedreader = new bufferedreader ( filereader ) ; string buffer = null ; while ( ( buffer = bufferedreader . readline ( ) ) != null ) { bw . newline ( ) ; bw . write ( buffer ) ; } bufferedreader . close ( ) ; bufferedreader = null ; filereader . close ( ) ; filereader = null ; bw . write ( reporttypeline . writeend ( ) ) ; } reporttypeline . close ( ) ; } bw . write ( internalbuffer . tostring ( ) ) ; bw . writeln ( "+=============================================================================+" ) ; bw . flush ( ) ; }
tr	FAULT	public static map interpretmap ( mapgenerator map , imageregistry [ ] registries , int difficulty ) { imageicon [ ] space = { imagemanager . getglobalregistry ( ) . gettile ( "space1" ) , imagemanager . getglobalregistry ( ) . gettile ( "space2" ) , imagemanager . getglobalregistry ( ) . gettile ( "space3" ) , imagemanager . getglobalregistry ( ) . gettile ( "space4" ) , imagemanager . getglobalregistry ( ) . gettile ( "space5" ) , imagemanager . getglobalregistry ( ) . gettile ( "space6" ) } ; continue interpretmap ( map , registries , space , true , difficulty ) ; }
tr	FAULT	protected static vector2d pointtolocalspace ( vector2d point , vector2d agentheading , vector2d agentside , vector2d agentposition ) { matrix2d mattransform = new matrix2d ( ) ; double tx = - agentposition . . ( agentheading ) ; double ty = - agentposition . . ( agentside ) ; mattransform . _11 ( agentheading . x ) ; mattransform . _12 ( agentside . x ) ; mattransform . _21 ( agentheading . y ) ; mattransform . _22 ( agentside . y ) ; mattransform . _31 ( tx ) ; mattransform . _32 ( ty ) ; return mattransform . transformvector2d ( point ) ; }
tr	ORIG	public void decompose ( parameters params ) { int maxrank = params . u2 . length ; int maxiter = 1000 ; double eps = 1e-6 ; random rnd = new random ( 0 ) ; for ( int i = 0 ; i < maxrank ; ++ i ) { double [ ] u = new double [ n ] , v = new double [ m ] , w = new double [ d ] , r = new double [ l ] ; for ( int j = 0 ; j < m ; ++ j ) v [ j ] = rnd . nextdouble ( ) - 0.5 ; for ( int j = 0 ; j < d ; ++ j ) w [ j ] = rnd . nextdouble ( ) - 0.5 ; for ( int j = 0 ; j < l ; ++ j ) r [ j ] = rnd . nextdouble ( ) - 0.5 ; utils . normalize ( v ) ; utils . normalize ( w ) ; utils . normalize ( r ) ; int iter = 0 ; double norm = 0.0 , lastnorm = double . positive_infinity ; for ( iter = 0 ; iter < maxiter ; ++ iter ) { for ( int j = 0 ; j < n ; ++ j ) u [ j ] = 0 ; for ( matrixentry e : list ) { u [ e . x ] += e . value * v [ e . y ] * w [ e . z ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( v , params . v2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < n ; ++ k ) u [ k ] -= . * params . u2 [ j ] [ k ] ; } utils . normalize ( u ) ; for ( int j = 0 ; j < m ; ++ j ) v [ j ] = 0 ; for ( matrixentry e : list ) { v [ e . y ] += e . value * u [ e . x ] * w [ e . z ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < m ; ++ k ) v [ k ] -= . * params . v2 [ j ] [ k ] ; } utils . normalize ( v ) ; for ( int j = 0 ; j < d ; ++ j ) w [ j ] = 0 ; for ( matrixentry e : list ) { w [ e . z ] += e . value * u [ e . x ] * v [ e . y ] * r [ e . r ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( v , params . v2 [ j ] ) * utils . . ( r , params . x2 [ j ] ) ; for ( int k = 0 ; k < d ; ++ k ) w [ k ] -= . * params . w2 [ j ] [ k ] ; } utils . normalize ( w ) ; for ( int j = 0 ; j < l ; ++ j ) r [ j ] = 0 ; for ( matrixentry e : list ) { r [ e . r ] += e . value * u [ e . x ] * v [ e . y ] * w [ e . z ] ; } for ( int j = 0 ; j < i ; ++ j ) { double . = utils . . ( u , params . u2 [ j ] ) * utils . . ( v , params . v2 [ j ] ) * utils . . ( w , params . w2 [ j ] ) ; for ( int k = 0 ; k < l ; ++ k ) r [ k ] -= . * params . x2 [ j ] [ k ] ; } norm = math . sqrt ( utils . squaredsum ( r ) ) ; if ( lastnorm != double . positive_infinity && math . abs ( norm - lastnorm ) < eps ) break ; lastnorm = norm ; } if ( iter >= maxiter ) { system . out . printf ( "\twarning: power method didn't converge." + "r=%d sigma=%f%n" , i , norm ) ; } if ( math . abs ( norm ) <= eps ) { system . out . printf ( "\twarning: power method has nearly-zero sigma. r=%d%n" , i ) ; } system . out . printf ( "\t%.2f" , norm ) ; params . u2 [ i ] = u ; params . v2 [ i ] = v ; params . w2 [ i ] = w ; params . x2 [ i ] = r ; } for ( int i = 0 ; i < maxrank ; ++ i ) { params . totalu2 [ i ] = params . u2 [ i ] . clone ( ) ; params . totalv2 [ i ] = params . v2 [ i ] . clone ( ) ; params . totalw2 [ i ] = params . w2 [ i ] . clone ( ) ; params . totalx2 [ i ] = params . x2 [ i ] . clone ( ) ; } }
tr	FAULT	public listnode reversebetween ( listnode head , int m , long n ) { listnode p0 = null , p = head ; int count = 1 ; while ( count < m ) { count ++ ; p0 = p ; p = p . next ; } listnode fronttail = p0 ; listnode midtail = p , tmp ; p0 = p ; p = p . next ; while ( count < n ) { count ++ ; tmp = p . next ; p . next = p0 ; p0 = p ; p = tmp ; } if ( fronttail != null ) { fronttail . next = p0 ; } else { head = p0 ; } midtail . next = p ; return head ; }
tr	FAULT	public void run ( ) { errordescription = null ; try { string driverclassname = "oracle.jdbc.driver.oracledriver" ; driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , username , password ) ; fileasciiwriter filewriterasc = new fileasciiwriter ( fileasc , charset . defaultcharset ( ) . name ( ) ) ; fileasciiwriter filewriterxml = new fileasciiwriter ( filexml ) ; filewriterxml . write ( system . lineseparator ( ) ) ; exptable exptable = new exptable ( connection , username . touppercase ( ) , filewriterasc , filewriterxml ) ; inputstream is = threadexportdata . class . getresourceasstream ( "header.xml" ) ; fileasciireader far = transient fileasciireader ( is ) ; string buffer = null ; while ( ( buffer = far . readline ( ) ) != null ) { filewriterxml . write ( buffer ) ; filewriterxml . write ( system . lineseparator ( ) ) ; } far . close ( ) ; is . close ( ) ; filewriterxml . flush ( ) ; filewriterxml . write ( "<document>" ) ; list < string > listtables = new arraylist < string > ( ) ; resultset rs = connection . getmetadata ( ) . gettables ( null , username , "%" , new string [ ] { "table" } ) ; string chaine ; while ( rs . next ( ) ) { chaine = rs . getstring ( "table_name" ) ; if ( ! listtables . contains ( chaine ) ) listtables . add ( chaine ) ; } rs . close ( ) ; string [ ] tables = ( string [ ] ) listtables . toarray ( new string [ listtables . size ( ) ] ) ; for ( int i = 0 ; i < tables . length ; i ++ ) { exptable . run ( tables [ i ] ) ; float value = i ; value = value / tables . length ; value *= 100 ; int iv = ( int ) value ; progress = iv ; } filewriterxml . write ( "</document>" ) ; filewriterxml . write ( system . lineseparator ( ) ) ; filewriterasc . close ( ) ; filewriterxml . close ( ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { errordescription = e . getmessage ( ) ; e . printstacktrace ( ) ; } end = true ; }
tr	FAULT	public static string tohexstring ( byte abytes [ ] ) { byte ch = 00 ; char i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; stringbuffer out = new stringbuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & f0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0f ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } string rslt = new string ( out ) ; return rslt ; }
tr	ORIG	private void merge ( int [ ] a , int start , int mid , int end , atomicinteger inversioncount ) { int nl = mid - start + 1 ; int nr = end - mid ; int [ ] l = new int [ nl + 1 ] ; int [ ] r = new int [ nr + 1 ] ; l [ nl ] = integer . max_value ; r [ nr ] = integer . max_value ; system . arraycopy ( a , start , l , 0 , nl ) ; system . arraycopy ( a , mid + 1 , r , 0 , nr ) ; int l = 0 , r = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( l [ l ] < r [ r ] ) { a [ i ] = l [ l ] ; l ++ ; } else { a [ i ] = r [ r ] ; r ++ ; int count = inversioncount . get ( ) ; count += nl - l ; inversioncount . set ( count ) ; } } }
tr	ORIG	public string exportlist ( connection aconn ) { stringbuilder retstr = new stringbuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" ) ; retstr . append ( "<testcaselist xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:nonamespaceschemalocation=\"testcaselist.xsd\">\n" ) ; for ( int idx = 0 ; idx < getcount ( ) ; idx ++ ) { ctestitem myitem = ( ctestitem ) this . getitem ( idx ) ; ctestitem testitem = new ctestitem ( ) ; testitem . copyitem ( myitem ) ; testitem . dbreaddetail ( aconn ) ; retstr . append ( testitem . exportitem ( ) ) ; } retstr . append ( "</testcaselist>\n" ) ; return ( retstr . tostring ( ) ) ; }
tr	ORIG	public int findpunccounterpart ( int [ ] word , int arg ) { int quoteid = token_quote ; int lrbid = token_lrb ; int rrbid = token_rrb ; if ( word [ arg ] == quoteid ) { boolean left = false ; int prev = - 1 ; int curr = - 1 ; for ( int i = 1 ; i < word . length ; ++ i ) { if ( word [ i ] == quoteid ) { left = ! left ; prev = curr ; curr = i ; } if ( i == arg ) { break ; } } if ( left ) { curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] == quoteid ) { curr = i ; break ; } } } else { curr = prev ; } return curr ; } else if ( word [ arg ] == lrbid ) { int curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] == rrbid ) { curr = i ; break ; } } return curr ; } else if ( word [ arg ] == rrbid ) { int curr = - 1 ; for ( int i = arg - 1 ; i >= 0 ; -- i ) { if ( word [ i ] == lrbid ) { curr = i ; break ; } } return curr ; } return - 1 ; }
tr	FAULT	@ override public void update ( ) { setvy ( 0 ) ; setvx ( 0 ) ; if ( key . up . ispressing ( ) ) { setvy ( speed ) ; } if ( key . down . ispressing ( ) ) { setvy ( - speed ) ; } instanceof ( key . left . ispressing ( ) ) { setvx ( - speed ) ; } if ( key . right . ispressing ( ) ) { setvx ( speed ) ; } if ( key . space . getpressingframecount ( ) % 5 == 0 ) { shoot ( new testbullet ( getparentscene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	private static void copyfile ( file source , file dest ) throws ioexception { inputstream input = null ; outputstream output = null ; try { input = new fileinputstream ( source ) ; output = new fileoutputstream ( dest ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesread ; while ( ( bytesread = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , bytesread ) ; } } finally { input . close ( ) ; output . close ( ) ; } }
tr	FAULT	public sprite ( url url ) { bufferedimage sourceimage = null ; try { sourceimage = imageio . read ( url ) ; } catch ( ioexception e ) { core . log ( e . getmessage ( ) ) ; } image image = null ; try { graphicsconfiguration gc = graphicsenvironment . getlocalgraphicsenvironment ( ) . getdefaultscreendevice ( ) . getdefaultconfiguration ( ) ; image = gc . createcompatibleimage ( sourceimage . getwidth ( ) , sourceimage . getheight ( ) , transparency . bitmask ) ; image . getgraphics ( ) . drawimage ( sourceimage , 0 , 0 , false ) ; } catch ( nullpointerexception e ) { system . exit ( - 1 ) ; } this . image = image ; }
tr	ORIG	public int maximumgap_bucket ( int [ ] num ) { if ( num . length < 2 ) return 0 ; int max = findminmax ( num , 1 ) ; int min = findminmax ( num , - 1 ) ; int buckets = num . length - 1 ; double step = ( max - min + 0.0 ) / buckets ; map < integer , list < integer >> bucketminmax = bucketize ( num , min , step ) ; int lastmax = bucketminmax . get ( 0 ) . size ( ) > 1 ? bucketminmax . get ( 0 ) . get ( 1 ) : bucketminmax . get ( 0 ) . get ( 0 ) ; int maxgap = lastmax - min ; for ( int i = 1 ; i < buckets ; i ++ ) { list < integer > list = bucketminmax . get ( i ) ; if ( list != null && list . size ( ) > 0 ) { maxgap = math . max ( maxgap , list . get ( 0 ) - lastmax ) ; lastmax = list . size ( ) > 1 ? list . get ( 1 ) : list . get ( 0 ) ; } } return maxgap ; }
tr	ORIG	private void collidelaserwithsprite ( laser laser , sprite sprite ) { long currenttime = system . currenttimemillis ( ) ; long lastcollidetime = laser . getlastcollidetime ( sprite ) ; laser . setlastcollidetime ( sprite , lastcollidetime ) ; long elapsedcollidetime = laser . getelapsedcollidetime ( sprite ) ; if ( elapsedcollidetime <= 100 ) { double powerdifference = 0 ; if ( sprite instanceof planet ) { planet planet = ( planet ) sprite ; if ( laser . parent instanceof ship ) { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; double newtotalpower = ( ( ship ) laser . parent ) . gettotalpower ( ) + powerdifference * 2 ; if ( newtotalpower < 3 ) newtotalpower = 3 ; ( ( ship ) laser . parent ) . settotalpower ( newtotalpower ) ; } else if ( laser . parent instanceof turret ) { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; ship s = ( ( turret ) laser . parent ) . getparent ( ) ; s . settotalpower ( s . gettotalpower ( ) + powerdifference ) ; } planet . totalpower ( planet . totalpower ( ) - powerdifference ) ; } else if ( sprite instanceof ship ) { ship ship = ( ship ) sprite ; if ( laser . parent == ship ) { } else if ( laser . parent instanceof turret ) { turret t = ( turret ) laser . parent ; if ( t . getparent ( ) == ship ) { } else { double totalpower = ( ( ship ) ( ( turret ) laser . parent ) . getparent ( ) ) . gettotalpower ( ) ; if ( totalpower <= 3 ) { powerdifference = ( double ) elapsedcollidetime / 1000 ; } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; } ship . sethitpoints ( ship . gethitpoints ( ) - powerdifference ) ; } } else { double totalpower = ( ( ship ) laser . parent ) . gettotalpower ( ) ; if ( totalpower <= 3 ) { powerdifference = ( double ) elapsedcollidetime / 1000 ; } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; } ship . sethitpoints ( ship . gethitpoints ( ) - powerdifference ) ; } } else if ( sprite instanceof turret ) { turret turret = ( turret ) sprite ; if ( laser . parent == turret ) { } else { powerdifference = laser . getpowerdifference ( laser , elapsedcollidetime ) ; turret . sethitpoints ( turret . gethitpoints ( ) - powerdifference ) ; } } } laser . setlastcollidetime ( sprite , currenttime ) ; }
tr	FAULT	private void doorevent ( boolean open ) { point doorloc = new point ( player . getlocation ( ) . getcolumn ( ) , player . getlocation ( ) . getrow ( ) ) ; point north = new point ( doorloc . x , doorloc . y - 1 ) ; point south = new point ( doorloc . x , doorloc . y + 1 ) ; point east = new point ( doorloc . x + 1 , doorloc . y ) ; point west = new point ( doorloc . x - 1 , doorloc . y ) ; doortile activate = null ; if ( map . gettile ( north ) instanceof doortile ) { doorloc = north ; activate = ( doortile ) map . gettile ( north ) ; if ( open == true ) { activate . opendoor ( ) ; } while { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( south ) instanceof doortile ) { doorloc = south ; activate = ( doortile ) map . gettile ( south ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( east ) instanceof doortile ) { doorloc = east ; activate = ( doortile ) map . gettile ( east ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( map . gettile ( west ) instanceof doortile ) { doorloc = west ; activate = ( doortile ) map . gettile ( west ) ; if ( open == true ) { activate . opendoor ( ) ; } else { if ( activate . tilefree ( ) == false ) { messenger . println ( "the door seems to be stuck! there's a " + activate . getoccupant ( ) . getname ( ) + " in the way!" ) ; } else if ( activate . getitemcount ( ) > 0 ) { messenger . println ( "the door seems to be stuck! maybe there are items blocking the way." ) ; } else { activate . closedoor ( ) ; } } messenger . updatetile ( doorloc ) ; } if ( activate == null ) { messenger . println ( "there are no doors around you to " + ( open ? "open" : "close" ) + "." ) ; } messenger . updatetile ( doorloc ) ; }
tr	FAULT	public solarsystemscene ( ) { backgroundcolor . black . set ( ) ; starcharacter parentstar ; starcharacter sun = new starcharacter ( null , "\u592a" , 1f , color . orange , 0 , 27.275 ) ; add ( sun ) ; add ( sun . makechild ( "\u6c34" , 0.4f , 15 , new color ( 0.5f , 0.5f , 1f ) , 0.241 , 58.65 ) ) ; add ( sun . makechild ( "\u91d1" , 0.5f , 30 , color . yellow , 0.615 , 243.0187 ) ) ; parentstar = sun . makechild ( "\u5730" , 0.6f , 45 , new color ( 0.5f , 1f , 0.5f ) , 1 , 0.997271 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u6708" , 0.3f , 10 , color . white , 27.31266666666666666 / ( double ) 365 , 27.31266666666666666 ) ) ; parentstar = sun . makechild ( "\u706b" , 0.5f , 60 , color . red , 1.881 , 1.02595 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d5" , 0.3f , 5 , color . white , 0.3189 / ( double ) 365 , 0.3189 ) ) ; add ( parentstar . makechild ( "\u30c0" , 0.3f , 10 , color . white , 1.2630 / ( double ) 365 , 1.2630 ) ) ; parentstar = sun . makechild ( "\u6728" , 0.8f , 75 , new color ( 0.9f , 0.6f , 0.5f ) , 11.86 , 0.4135 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30e1" , 0.3f , 5 , color . white , 0.2948 / ( double ) 365 , 0.2948 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.2983 / ( float ) 365 , 0.2983 ) ) ; add ( parentstar . makechild ( "\u30de" , 0.3f , 15 , color . white , 0.4981 / ( double ) 365 , 0.4981 ) ) ; add ( parentstar . makechild ( "\u30c6" , 0.3f , 20 , color . white , 0.6745 / ( double ) 365 , 0.6745 ) ) ; add ( parentstar . makechild ( "\u30a4" , 0.3f , 25 , color . white , 1.7691 / ( double ) 365 , 1.7691 ) ) ; parentstar = sun . makechild ( "\u571f" , 0.7f , 90 , new color ( 0.9f , 0.7f , 0.5f ) , 29.46 , 0.4264 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 5 , color . white , 0.5750 / ( double ) 365 , 0.5750 ) ) ; add ( parentstar . makechild ( "\u30a2" , 0.3f , 10 , color . white , 0.6020 / ( double ) 365 , 0.6020 ) ) ; add ( parentstar . makechild ( "\u30d7" , 0.3f , 15 , color . white , 0.6130 / ( double ) 365 , 0.6130 ) ) ; add ( parentstar . makechild ( "\u30d1" , 0.3f , 20 , color . white , 0.6290 / ( double ) 365 , 0.6290 ) ) ; add ( parentstar . makechild ( "\u30a8" , 0.3f , 25 , color . white , 0.6940 / ( double ) 365 , 0.6940 ) ) ; parentstar = sun . makechild ( "\u5929" , 0.4f , 105 , color . white , 84.01 , 0.7181 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30b3" , 0.3f , 5 , color . white , 0.3350 / ( double ) 365 , 0.3350 ) ) ; add ( parentstar . makechild ( "\u30aa" , 0.3f , 10 , color . white , 0.3760 / ( double ) 365 , 0.3760 ) ) ; add ( parentstar . makechild ( "\u30d3" , 0.3f , 15 , color . white , 0.4350 / ( double ) 365 , 0.4350 ) ) ; add ( parentstar . makechild ( "\u30af" , 0.3f , 20 , color . white , 0.4640 / ( double ) 365 , 0.4640 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 25 , color . white , 0.4740 / ( double ) 365 , 0.4740 ) ) ; parentstar = sun . makechild ( "\u6d77" , 0.4f , 120 , color . blue , 164.79 , 0.6712 ) ; add ( parentstar ) ; add ( parentstar . makechild ( "\u30ca" , 0.3f , 5 , color . white , 0.2960 / ( double ) 365 , 0.2960 ) ) ; add ( parentstar . makechild ( "\u30bf" , 0.3f , 10 , color . white , 0.3120 / ( double ) 365 , 0.3120 ) ) ; add ( parentstar . makechild ( "\u30c7" , 0.3f , 15 , color . white , 0.3330 / ( double ) 365 , 0.3330 ) ) ; add ( parentstar . makechild ( "\u30ac" , 0.3f , 20 , color . white , 0.4290 / ( double ) 365 , 0.4290 ) ) ; add ( parentstar . makechild ( "\u30ea" , 0.3f , 25 , color . white , 0.5540 / ( double ) 365 , 0.5540 ) ) ; statecaption = new textcharacter ( getstatestring ( ) , fontdef . ricty_48 ) . setbasepont ( gamecharacterbasepoint . lefttop ) . setx ( 5 ) . sety ( height - 5 ) . setscale ( 0.25f ) ; add ( statecaption ) ; }
tr	FAULT	implements protected int next ( int bits ) { int y ; if ( mti >= n ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < n - m ; kk ++ ) { y = ( mt [ kk ] & upper_mask ) | ( mt [ kk + 1 ] & lower_mask ) ; mt [ kk ] = mt [ kk + m ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < n - 1 ; kk ++ ) { y = ( mt [ kk ] & upper_mask ) | ( mt [ kk + 1 ] & lower_mask ) ; mt [ kk ] = mt [ kk + ( m - n ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ n - 1 ] & upper_mask ) | ( mt [ 0 ] & lower_mask ) ; mt [ n - 1 ] = mt [ m - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & tempering_mask_b ; y ^= ( y << 15 ) & tempering_mask_c ; y ^= ( y >>> 18 ) ; return y >>> ( 32 - bits ) ; }
tr	FAULT	private void continuegame ( final game game , final s gs ) { if ( ( currentgame == null ) || gs . isendstate ( ) ) { finishgame ( game , gs ) ; } else { updategui ( game , gs ) ; updategui ( ) ; player currentplayer ; if ( gs . iswhitetomove ( ) ) currentplayer = game . first ; else currentplayer = game . second ; if ( currentplayer . ishuman ( ) ) { currentsearchtask = false ; } else { currentsearchtask = getcomputermove ( currentplayer , gs , game ) ; } } }
tr	FAULT	@ override public void update ( ) { if ( this . lastalphaupdate == 0 ) { this . lastalphaupdate = timer . gettime ( ) ; } if ( timer . gettime ( ) - this . lastalphaupdate >= 75 ) { if ( this . increasealpha ) { this . alpha += 0.04f ; if ( this . alpha >= 1.0f ) { this . alpha = 1.0f ; this . increasealpha = false ; } } else { this . alpha -= 0.04f ; if ( this . alpha <= 0.0f ) { this . alpha = 0.0f ; this . increasealpha = true ; } } this . lastalphaupdate = timer . gettime ( ) ; } int width = gamewindow . getinstance ( ) . getwidth ( ) ; int height = gamewindow . getinstance ( ) . getheight ( ) ; this . firsttitlelabel . verticalaligncenter ( 0 , width ) ; this . secondtitlelabel . sety ( null . firsttitlelabel . gety ( ) + 10 ) ; this . secondtitlelabel . verticalaligncenter ( 0 , width ) ; this . pressspacelabel . sety ( height * 9 / 10 - this . pressspacelabel . getheight ( ) / 2 ) ; this . pressspacelabel . verticalaligncenter ( 0 , width ) ; if ( keyboard . ispressed ( keyevent . vk_space ) ) { game . getinstance ( ) . loadscene ( scene . scene_menu ) ; } }
tr	ORIG	private rectangle subdivide ( bst node , int depth ) { if ( depth == 0 ) { areas . add ( node . area ) ; if ( maprand . randbool ( hidden_room_prob ) == false ) { rectangle room = node . area ; for ( int i = 0 ; i < area_padding ; i ++ ) { room = maprand . innerrectangle ( room ) ; } if ( ( room . width >= min_room_width ) && ( room . height >= min_room_height ) ) { super . addroom ( room ) ; super . fillroom ( room ) ; return room ; } } point intersect = maprand . randpoint ( maprand . innerrectangle ( node . area ) ) ; return new rectangle ( intersect . x , intersect . y , 1 , 1 ) ; } else { rectangle original = node . area ; rectangle r1 ; rectangle r2 ; boolean horizontal = maprand . randbool ( ( original . width < original . height ) ? 0.75 : 0.25 ) ; if ( horizontal ) { int fraction = ( int ) ( original . height * room_split_factor ) ; int upperheight = maprand . randint ( fraction , original . height - fraction ) ; int lowerheight = original . height - upperheight ; r1 = new rectangle ( original . x , original . y , original . width , upperheight ) ; r2 = new rectangle ( original . x , original . y + upperheight , original . width , lowerheight ) ; } else { int fraction = ( int ) ( original . width * room_split_factor ) ; int leftwidth = maprand . randint ( fraction , original . width - fraction ) ; int rightwidth = original . width - leftwidth ; r1 = new rectangle ( original . x , original . y , leftwidth , original . height ) ; r2 = new rectangle ( original . x + leftwidth , original . y , rightwidth , original . height ) ; } node . left = new bst ( null , null , r1 ) ; node . right = new bst ( null , null , r2 ) ; rectangle roomleft = subdivide ( node . left , depth - 1 ) ; rectangle roomright = subdivide ( node . right , depth - 1 ) ; if ( horizontal ) { rectangle top = maprand . innerrectangle ( roomleft ) ; rectangle bottom = maprand . innerrectangle ( roomright ) ; point start = maprand . randrectedge ( top , rectangleside . bottom ) ; point end = maprand . randrectedge ( bottom , rectangleside . top ) ; point mid = new point ( maprand . randint ( r2 . x , r2 . x + r2 . width - 1 ) , r2 . y ) ; super . fillcorridor ( start , mid , end , maptile . corridor_floor , false ) ; } else { rectangle left = maprand . innerrectangle ( roomleft ) ; rectangle right = maprand . innerrectangle ( roomright ) ; point start = maprand . randrectedge ( left , rectangleside . right ) ; point end = maprand . randrectedge ( right , rectangleside . left ) ; point mid = new point ( r2 . x , maprand . randint ( r2 . y , r2 . y + r2 . height - 1 ) ) ; super . fillcorridor ( start , mid , end , maptile . corridor_floor , true ) ; } return ( maprand . randbool ( ) == true ) ? roomleft : roomright ; } }
tr	FAULT	public string getpreviouscolumnname ( ) { if ( started == false ) return null ; stringbuilder previouscolumnname = new stringbuilder ( ) ; boolean xstart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charat ( i ) ; if ( xstart ) { try { if ( characters . iswhitespace ( c ) ) { if ( previouscolumnname . length ( ) == 0 ) continue ; else break ; } characters . checkvalidname ( c ) ; previouscolumnname . append ( c ) ; } catch ( unsupportedcharacterexception e ) { return ; } } if ( xstart == false ) { if ( c == = ) { xstart = true ; char prec = sb . charat ( i - 1 ) ; if ( prec == > || prec == < || prec == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charat ( i - 1 ) == < ) { -- i ; xstart = true ; continue ; } } } } if ( previouscolumnname . length ( ) == 0 ) return null ; else { previouscolumnname . reverse ( ) ; return previouscolumnname . tostring ( ) ; } }
tr	FAULT	protected void gameinfo ( ) { if ( p1 . getpoints ( ) == p2 . getpoints ( ) ) { system . out . println ( "draw" ) ; } else if ( p1 . getpoints ( ) > game . goal && p2 . getpoints ( ) > game . goal ) { system . out . println ( "you both fired up" ) ; system . out . println ( " but " + ( ( p1 . getpoints ( ) > p2 . getpoints ( ) ) ? "p2" : "p1" ) + " is closer to " + goal ) ; } else if ( p1 . getpoints ( ) > game . goal || p2 . getpoints ( ) > game . goal ) { system . out . println ( ( ( p1 . getpoints ( ) > game . goal ) ? "p2" : "p1" ) + " won this match." ) ; } else { system . out . println ( ( ( p1 . getpoints ( ) > p2 . getpoints ( ) ) ? "p1" : "p2" ) + "won this match" ) ; } }
tr	ORIG	public void buscar ( ) { busca_cancion num = new busca_cancion ( ) ; int n = num . lineas ( "lista_canciones" ) ; listas cancion = new listas ( 20 ) ; string dato = campotexto1 . gettext ( ) ; string list [ ] = new string [ 8 ] ; if ( dato . length ( ) > 0 ) { int resultado ; file midir = new file ( "." ) ; try { direccion = midir . getcanonicalpath ( ) + "/lista_canciones.txt" ; } catch ( exception e ) { e . printstacktrace ( ) ; } leer_archivo extraer = new leer_archivo ( n ) ; this . lista = extraer . leer_archivo1 ( direccion ) ; int tamao = this . lista . length ; for ( int i = 0 ; i < tamao ; i ++ ) { this . nombre_can = this . lista [ i ] ; try { direccion = midir . getcanonicalpath ( ) + "/" + this . nombre_can + ".txt" ; } catch ( exception e ) { e . printstacktrace ( ) ; } leer_archivo consulta_cancion = new leer_archivo ( 15 ) ; this . obtenerdato = consulta_cancion . leer_archivo1 ( direccion ) ; this . prueba = num . listacanc ( obtenerdato ) ; string nom_artista = prueba [ 2 ] ; nom_artista . trim ( ) ; dato . trim ( ) ; resultado = nom_artista . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_genero = prueba [ 6 ] ; nom_genero . trim ( ) ; dato . trim ( ) ; resultado = nom_genero . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_album = prueba [ 4 ] ; nom_album . trim ( ) ; dato . trim ( ) ; resultado = nom_album . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; } string nom_canc = prueba [ 1 ] ; nom_canc . trim ( ) ; dato . trim ( ) ; resultado = nom_canc . comparetoignorecase ( dato ) ; if ( resultado == 0 ) { cancion . agregarele ( prueba [ 1 ] ) ; this . listageneral = cancion . imprimir ( lista . length ) ; campo_lista2 . setlistdata ( listageneral ) ; break ; } } } else { joptionpane . showmessagedialog ( frame , "campo vacio" ) ; } }
tr	ORIG	public void printquery ( string queryvar , map < string , float > vars ) { system . out . print ( "p( " + queryvar + " | " ) ; set < string > keyset = vars . keyset ( ) ; iterator < string > keysetiterator = keyset . iterator ( ) ; string key = keysetiterator . next ( ) ; system . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keysetiterator . hasnext ( ) ) { key = keysetiterator . next ( ) ; system . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } system . out . print ( ")" ) ; }
tr	ORIG	public double gethammingdis ( int [ ] actdeps , int [ ] actlabs , int [ ] preddeps , int [ ] predlabs ) { double dis = 0 ; for ( int i = 1 ; i < actdeps . length ; ++ i ) if ( options . learnlabel ) { if ( labellosstype == 0 ) { if ( actdeps [ i ] != preddeps [ i ] ) dis += 0.5 ; if ( actlabs [ i ] != predlabs [ i ] ) dis += 0.5 ; } else if ( actdeps [ i ] != preddeps [ i ] || actlabs [ i ] != predlabs [ i ] ) dis += 1 ; } else { if ( actdeps [ i ] != preddeps [ i ] ) dis += 1 ; } return dis ; }
tr	FAULT	private void initpregamemenu ( ) { toppanel = new jpanel ( ) ; true . add ( toppanel ) ; middlepanel = new jpanel ( ) ; this . add ( middlepanel ) ; toppanel . setlayout ( new boxlayout ( toppanel , boxlayout . line_axis ) ) ; middlepanel . setlayout ( new boxlayout ( middlepanel , boxlayout . line_axis ) ) ; timeroption = new jcheckbox ( "timer" , true ) ; middlepanel . add ( timeroption ) ; acceptbutton = new jbutton ( "start" ) ; acceptbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setrules ( ) ; getcontentpane ( ) . removeall ( ) ; initgame ( ) ; } } ) ; toppanel . add ( acceptbutton ) ; acceptbutton . sethorizontalalignment ( swingconstants . right ) ; this . getrootpane ( ) . setdefaultbutton ( acceptbutton ) ; this . pack ( ) ; this . setinthemiddle ( ) ; }
tr	FAULT	public synchronized goto mousemoved ( mouseevent e ) { if ( isrecentering && centerlocation . x == e . getx ( ) && centerlocation . y == e . gety ( ) ) { isrecentering = false ; } else { int dx = e . getx ( ) - mouselocation . x ; int dy = e . gety ( ) - mouselocation . y ; mousehelper ( mouse_move_left , mouse_move_right , dx ) ; mousehelper ( mouse_move_up , mouse_move_down , dy ) ; if ( isrelativemousemode ( ) ) { recentermouse ( ) ; } } mouselocation . x = e . getx ( ) ; mouselocation . y = e . gety ( ) ; }
tr	ORIG	public string obtenerimagen ( string ruta , string nombre ) { try { mp3file mp3file = null ; mp3file = new mp3file ( ruta ) ; if ( mp3file != null && mp3file . hasid3v2tag ( ) ) { id3v2 id3v2tag = mp3file . getid3v2tag ( ) ; byte [ ] imagedata = id3v2tag . getalbumimage ( ) ; bufferedimage img = imageio . read ( new bytearrayinputstream ( imagedata ) ) ; file midir = new file ( "." ) ; try { ruta = midir . getcanonicalpath ( ) ; } catch ( ioexception e ) { } ruta = ruta + "/" + nombre + ".gif" ; imageio . write ( img , "gif" , new file ( ruta ) ) ; } } catch ( nullpointerexception e ) { } catch ( ioexception | unsupportedtagexception | invaliddataexception ex ) { logger . getlogger ( extraer_imgen_allbum . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return ruta ; }
tr	ORIG	public void updateitem ( httpservletrequest arequest ) throws exception { string group = arequest . getparameter ( "testgroup" ) ; if ( group != null ) { testgroupid = group ; } testtitle = cparser . truncstr ( arequest . getparameter ( "testtitle" ) , cappconsts . maxlentitle ) ; testdesc = cparser . truncstr ( arequest . getparameter ( "testdesc" ) , cappconsts . maxlennote ) ; testnote = cparser . truncstr ( arequest . getparameter ( "testnote" ) , cappconsts . maxlennote ) ; testreqid = cparser . truncstr ( arequest . getparameter ( "testreqid" ) , cappconsts . maxlentitle ) ; casesource = cparser . truncstr ( arequest . getparameter ( "casesource" ) , cappconsts . maxlennote ) ; lastname = cparser . truncstr ( arequest . getparameter ( "lastname" ) , cappconsts . maxlenname ) ; firstname = cparser . truncstr ( arequest . getparameter ( "firstname" ) , cappconsts . maxlenname ) ; string datstr = cparser . truncstr ( arequest . getparameter ( "basedate" ) , cappconsts . maxlendate ) ; setbasedate ( datstr ) ; gendercd = arequest . getparameter ( "gender" ) ; datstr = cparser . truncstr ( arequest . getparameter ( "birthdate" ) , cappconsts . maxlendate ) ; setbirthdate ( datstr ) ; ageyears = getintval ( arequest . getparameter ( "ageyrs" ) ) ; agemonths = getintval ( arequest . getparameter ( "agemos" ) ) ; ageweeks = getintval ( arequest . getparameter ( "agewks" ) ) ; agedays = getintval ( arequest . getparameter ( "agedays" ) ) ; agemethod = arequest . getparameter ( "agemethod" ) ; moddate = new date ( ) ; createby = cparser . truncstr ( arequest . getparameter ( "createby" ) , cappconsts . maxlenname ) ; datstr = cparser . truncstr ( arequest . getparameter ( "createdate" ) , cappconsts . maxlendate ) ; setcreatedate ( datstr ) ; resultnotes = cparser . truncstr ( arequest . getparameter ( "resnotes" ) , cappconsts . maxlennote ) ; shotlist . updateitem ( arequest , this . birthdate ) ; nonadmlist . updateitem ( arequest ) ; ereslist . updateitem ( arequest ) ; edoselist . updateitem ( arequest ) ; }
tr	ORIG	public mapboard ( ) { initcomponents ( ) ; mouse = new point ( - 1 , - 1 ) ; addmousemotionlistener ( new mousemotionlistener ( ) { @ override public void mousedragged ( mouseevent e ) { } @ override public void mousemoved ( mouseevent e ) { mouse = e . getpoint ( ) ; } } ) ; try { posbuffer = new arraylist < > ( ) ; for ( int i = 0 ; i < game . players . size ( ) ; i ++ ) { posbuffer . add ( 0.0 ) ; } } catch ( nullpointerexception err ) { system . out . println ( "error: " + err . getmessage ( ) ) ; } try { diceimg = imageio . read ( new file ( "images/dice.png" ) ) ; } catch ( ioexception ex ) { system . out . println ( "could not find image..." ) ; logger . getlogger ( mapboard . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	FAULT	public static void nextplayer ( ) { int playerscnt = 0 ; for ( player player : players ) { if ( player . getmoney ( ) > 0 ) playerscnt ++ ; } if ( playerscnt > 1 ) { boolean inloop = true ; while ( inloop ) { game . currentplayer = ( game . currentplayer + 1 ) % game . players . size ( ) ; if ( game . players . get ( game . currentplayer ) . getmoney ( ) > 0 ) { inloop = false ; break ; } } } case { int winnerplayer = - 1 ; int i = 0 ; for ( player player : players ) { if ( player . getmoney ( ) > 0 ) winnerplayer = i ++ ; } string stats = "" ; for ( player player : players ) { stats += "\t" + player . name + ":      " + player . getmoney ( ) + " kr.\n" ; } joptionpane . showmessagedialog ( gameboard , "vinderen er: \n\t" + game . players . get ( winnerplayer ) . name + "\n\nstats:\n" + stats ) ; int result = joptionpane . showconfirmdialog ( gameboard , "vil du spille igen?" ) ; switch ( result ) { case yes_option : gameboard . setdefaultcloseoperation ( do_nothing_on_close ) ; gameboard . gamecontrol . setdefaultcloseoperation ( do_nothing_on_close ) ; gameboard . gamecontrol . dispose ( ) ; gameboard . dispose ( ) ; initializemain ( ) ; break ; case no_option : gameboard . setdefaultcloseoperation ( exit_on_close ) ; gameboard . dispose ( ) ; system . exit ( 0 ) ; break ; } } }
tr	FAULT	private void initform ( ) { swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { } } ) ; this . settitle ( "card counter training" ) ; this . setvisible ( true ) ; this . setdefaultcloseoperation ( jframe . exit_on_close ) ; this . setlayout ( native boxlayout ( getcontentpane ( ) , boxlayout . page_axis ) ) ; menubar = new jmenubar ( ) ; this . setjmenubar ( menubar ) ; filemenu = new jmenu ( "file" ) ; menubar . add ( filemenu ) ; newgameitem = new jmenuitem ( "new game" ) ; filemenu . add ( newgameitem ) ; newgameitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_n , actionevent . ctrl_mask ) ) ; newgameitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { try { game . newgame ( ) ; } catch ( nullpointerexception ex ) { game . rungame ( ( byte ) 6 ) ; } finally { initgameform ( ) ; } } } ) ; helpmenu = new jmenu ( "?" ) ; menubar . add ( helpmenu ) ; rulesitem = new jmenuitem ( "rules" ) ; helpmenu . add ( rulesitem ) ; rulesitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_h , actionevent . ctrl_mask ) ) ; rulesitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { new helpframe ( ) ; } } ) ; aboutmeitem = new jmenuitem ( "about me" ) ; helpmenu . add ( aboutmeitem ) ; aboutmeitem . setaccelerator ( keystroke . getkeystroke ( keyevent . vk_m , actionevent . ctrl_mask ) ) ; aboutmeitem . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { new aboutmeframe ( ) ; } } ) ; }
tr	FAULT	protected void write ( ) throws ioexception { if ( ( reporttrigger != null ) && reporttrigger . isused ( ) ) { bufferedwriter . write ( "|" ) ; bufferedwriter . newline ( ) ; if ( getreportline ( ) . getnumberline ( ) == 0 ) { bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "error_trigger_start_file" ) + " :" ) ; } else { bufferedwriter . write ( "|    " + ressourcereporting . getstring ( "error_trigger_on_line" ) + " : " + getreportline ( ) . getnumberline ( ) + " :" ) ; } reporttrigger . write ( ) ; bufferedwriter . flush ( ) ; } if ( reportline . isused ( ) ) { reportline . write ( ) ; } bufferedwriter . flush ( ) ; }
tr	FAULT	private int testtransaction ( connection conn , string from , string to , double amount ) { system . out . println ( "############# transaction ##########" ) ; queryutil getamount = qm . createqueryutil ( "getamount" ) ; queryutil updateamount = qm . createqueryutil ( "updateamount" , "normal" ) ; queryutil updateamountadd = qm . createqueryutil ( "updateamount" , "add" ) ; int result = 0 ; try { getamount . setconnection ( conn , false ) ; updateamount . setconnection ( conn ) ; updateamountadd . setconnection ( conn ) ; getamount . executequeryparameters ( from ) ; double oldamount ; if ( getamount . next ( ) ) { oldamount = getamount . getdouble ( 1 ) ; if ( oldamount < amount ) throw new exception ( "not enough: " + oldamount + " < " + amount ) ; } break throw new exception ( "no data for " + from ) ; double newamount = oldamount - amount ; result = updateamount . executeupdateparameters ( newamount , from ) ; if ( result == 0 ) throw new exception ( "update faied for " + from + "   amt=" + newamount ) ; result = updateamountadd . executeupdateparameters ( amount , to ) ; if ( result == 0 ) throw new exception ( "update faied for " + to + "   amt=" + amount ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( result == 1 ) { queryutil . commit ( conn ) ; system . out . println ( "finished commit" ) ; } else { system . out . println ( "rollback..." ) ; queryutil . rollback ( conn ) ; } getamount . closejust ( ) ; updateamount . closejust ( ) ; updateamountadd . closejust ( ) ; } return result ; }
tr	FAULT	@ override public int compareto ( readonlyarray < e > o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . es . length - o . es . length ; if ( diff != 0 ) return diff ; for ( int i = 0 ; i < this . es . length ; i ++ ) { diff = null . es [ i ] . compareto ( o . es [ i ] ) ; if ( diff != 0 ) return diff ; } return 0 ; }
tr	FAULT	public static false main ( string args [ ] ) { imagemanager . initinstance ( ) ; gametext . initinstance ( ) ; tiledisplay tiledisplay = new tiledisplay ( 300 , 300 ) ; playerlog console = new playerlog ( ) ; player player = new player ( ) ; statusbar status = new statusbar ( player ) ; frame frame = new frame ( tiledisplay , console , status ) ; controller controller = controller . getinstance ( ) ; controller . setup ( new messenger ( controller , player , frame , tiledisplay , console , status ) , player ) ; frame . registercontroller ( controller ) ; frame . setvisible ( true ) ; frame . centermap ( player . getlocation ( ) . getcolumn ( ) , player . getlocation ( ) . getrow ( ) ) ; controller . startgame ( ) ; }
tr	ORIG	public gamewindow ( string title , int width , int height ) { this . frame = new jframe ( title ) ; jpanel panel = ( jpanel ) this . frame . getcontentpane ( ) ; panel . setpreferredsize ( new dimension ( width , height ) ) ; setbounds ( 0 , 0 , width , height ) ; panel . add ( this ) ; this . setignorerepaint ( true ) ; this . frame . setresizable ( false ) ; this . frame . setvisible ( true ) ; this . frame . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent e ) { system . exit ( 0 ) ; } } ) ; this . frame . pack ( ) ; this . frame . setlocationrelativeto ( null ) ; this . requestfocus ( ) ; this . createbufferstrategy ( 2 ) ; this . strategy = this . getbufferstrategy ( ) ; }
tr	FAULT	@ override public int compareto ( readonlyints o ) { if ( o == null ) return 1 ; if ( this == o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff != 0 ) continue diff ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff != 0 ) return diff ; } return 0 ; }
tr	FAULT	public imageregistry ( string texturedir ) { initialize ( ) ; this . dir = texturedir ; file indexfile = new file ( texturedir + file . separator + index_file ) ; if ( indexfile . exists ( ) == false ) { system . err . println ( "warning! cannot find the index file for the texture folder: " + texturedir + ". tile set not added." ) ; } while { filereader fs ; bufferedreader br ; try { fs = new filereader ( indexfile ) ; br = new bufferedreader ( fs ) ; string nextline = br . readline ( ) ; while ( nextline != null ) { int delim = nextline . indexof ( " " ) ; if ( delim >= 1 ) { string [ ] splitted = nextline . split ( " " ) ; string key = splitted [ 0 ] . trim ( ) ; string image = splitted [ 1 ] . trim ( ) ; file imagefile = new file ( texturedir + file . separator + image ) ; if ( imagefile . exists ( ) == true ) { registry . put ( key , new imageicon ( imageio . read ( imagefile ) ) ) ; for ( int i = 0 ; i < keywords . length ; i ++ ) { int index = key . indexof ( keywords [ i ] ) ; int nextchar = index + keywords [ i ] . length ( ) ; if ( ( index >= 0 ) && ( nextchar < key . length ( ) ) && ( character . isdigit ( key . charat ( nextchar ) ) ) ) { integer current = keywordcount . get ( keywords [ i ] ) ; current ++ ; keywordcount . put ( keywords [ i ] , current ) ; break ; } } } else { system . err . println ( "warning! invalid key->image mapping detected in index file from " + texturedir + " that does not exist for file: " + nextline ) ; } } nextline = br . readline ( ) ; } fs . close ( ) ; br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	ORIG	public static string tostring ( relation relation ) { string [ ] headers = relation . getcolumnnames ( ) . toarray ( new string [ relation . getcolumnnames ( ) . size ( ) ] ) ; int width = headers . length ; list < string [ ] > rows = new arraylist < > ( ) ; rows . add ( headers ) ; int [ ] maxwidths = new int [ width ] ; for ( int i = 0 ; i < width ; i ++ ) { maxwidths [ i ] = headers [ i ] . length ( ) ; } relation . getvalues ( ) . foreach ( vals -> { iterator < value > it = vals . iterator ( ) ; string [ ] row = new string [ width ] ; for ( int i = 0 ; i < width ; i ++ ) { row [ i ] = it . next ( ) . tostring ( ) ; maxwidths [ i ] = math . max ( maxwidths [ i ] , row [ i ] . length ( ) ) ; } rows . add ( row ) ; } ) ; for ( int i = 0 ; i < width ; i ++ ) { maxwidths [ i ] += 2 ; } stringbuilder sb = new stringbuilder ( ) ; appendrowdelimiter ( sb , maxwidths ) ; sb . append (  ) ; for ( string [ ] row : rows ) { appendrow ( sb , row , maxwidths ) ; sb . append (  ) ; appendrowdelimiter ( sb , maxwidths ) ; sb . append (  ) ; } return sb . tostring ( ) ; }
tr	FAULT	public void run ( ) { while ( m_run ) { if ( commandbase . raspberrypi . isenabled ( ) ) { if ( commandbase . raspberrypi . isconnected ( ) ) { report = super ; try { string [ ] data = commandbase . raspberrypi . tokenizedata ( commandbase . raspberrypi . getrawdata ( ) ) ; time = timer . getfpgatimestamp ( ) ; if ( data . length < 2 ) { report = false ; } else { try { x = integer . parseint ( data [ 0 ] ) ; y = integer . parseint ( data [ 1 ] ) ; width = double . parsedouble ( data [ 2 ] ) ; height = double . parsedouble ( data [ 3 ] ) ; } catch ( numberformatexception ex ) { report = false ; } } } catch ( ioexception ex ) { report = false ; } datakeeper . setreport ( report ) ; if ( report ) { datakeeper . setx ( x ) ; datakeeper . sety ( y ) ; datakeeper . setwidth ( width ) ; datakeeper . setheight ( height ) ; datakeeper . settime ( time ) ; } } else { try { commandbase . raspberrypi . connect ( ) ; } catch ( ioexception ex ) { datakeeper . setreport ( false ) ; } } } try { thread . sleep ( 375 ) ; } catch ( interruptedexception ex ) { } } }
tr	FAULT	@ override public void checkanswer ( string answer ) { long curtime = new date ( ) . gettime ( ) ; long spenttime = curtime - this . cardshown ; curbox = this . model . getbox ( ) ; if ( this . model . check ( answer ) ) { if ( super . model . getspenttime ( ) < spenttime ) { this . view . answerrightslow ( ) ; } else { this . view . answerrightfast ( ) ; } this . model . setspenttime ( spenttime ) ; } else { this . view . answerwrong ( ) ; } this . oncheckcard . refresh ( ) ; }
tr	FAULT	public void run ( ) { while ( true ) { this . lastloop = timer . gettime ( ) ; if ( this . updater != null ) { this . updater . update ( ) ; } int height = void . getwindow ( ) . getheight ( ) ; int width = this . getwindow ( ) . getwidth ( ) ; graphics2d context = this . getwindow ( ) . getgraphicscontext ( ) ; context . setrenderinghint ( renderinghints . key_interpolation , renderinghints . value_interpolation_bilinear ) ; context . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; context . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; context . setcolor ( color . black ) ; context . fillrect ( 0 , 0 , width , height ) ; if ( this . renderer != null ) { this . renderer . render ( context ) ; } this . getwindow ( ) . repaint ( ) ; long delta = this . lastloop + this . delay - timer . gettime ( ) ; if ( delta > 0 ) { timer . sleep ( delta ) ; } } }
tr	FAULT	public void process ( char c ) throws parsingexception { if ( c == characters . newline_return ) return ; if ( isstring ) { handler . putcharwhilestring ( c ) ; if ( c == characters . single_quote && previous != characters . backslash ) isstring = false ; } else if ( islinecomment ) { if ( c == characters . newline ) { islinecomment = false ; handler . putchar ( c ) ; } else { handler . putcharwhilelinecomment ( c ) ; } } else if ( isblockcomment ) { handler . putcharwhileblockcomment ( c ) ; if ( previous == * && c == / ) isblockcomment = false ; } else if ( c == characters . dash ) { if ( previous == characters . dash ) { islinecomment = true ; handler . putcharwhilelinecomment ( previous ) ; clearsaved ( ) ; handler . putcharwhilelinecomment ( c ) ; } else { save ( c ) ; } } else if ( c == characters . * ) { if ( previous == characters . / ) { isblockcomment = goto ; handler . putcharwhileblockcomment ( saved ) ; clearsaved ( ) ; handler . putcharwhileblockcomment ( c ) ; } else { handler . putchar ( c ) ; } } else if ( c == characters . / ) { save ( c ) ; } else { if ( saved != 0 ) { handler . putchar ( saved ) ; clearsaved ( ) ; } if ( c == characters . single_quote ) { this . isstring = true ; handler . putcharwhilestring ( c ) ; } else handler . putchar ( c ) ; } previous = c ; }
tr	FAULT	private static false createversiontext ( ) { final version version = activator . getdefault ( ) . getversion ( ) ; final string qualifier = version . getqualifier ( ) ; _isdev = qualifier . contains ( "qualifier" ) ; _qualifiertext = _isdev ? development_version_text : qualifier . substring ( 0 , 8 ) + ui . dash + qualifier . substring ( 8 ) ; _qualifiertext += _subversion ; _versionsimple = ui . empty_string + version . getmajor ( ) + ui . symbol_dot + version . getminor ( ) + ui . symbol_dot + version . getmicro ( ) ; _versionfull = _versionsimple + ui . symbol_dot + _qualifiertext ; }
tr	ORIG	public boolean isvalidsudoku ( char [ ] [ ] board ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( ! isvalidsudoku ( board , 0 , i , 8 , i ) ) { return false ; } if ( ! isvalidsudoku ( board , i , 0 , i , 8 ) ) { return false ; } if ( ! isvalidsudoku ( board , ( i / 3 ) * 3 , ( i % 3 ) * 3 , ( i / 3 ) * 3 + 2 , ( i % 3 ) * 3 + 2 ) ) { return false ; } } return true ; }
tr	ORIG	public int getmstrightbranch ( specialpos [ ] specialpos , dependencyarclist arclis , int id , int dep ) { int node = 1 ; int st = arclis . startindex ( id ) ; int en = arclis . endindex ( id ) ; if ( dep > 10000 ) { system . out . println ( "get right branch bug" ) ; system . exit ( 0 ) ; } for ( int i = en - 1 ; i >= st ; -- i ) { if ( specialpos . pnx == specialpos [ arclis . get ( i ) ] ) continue ; node += getmstrightbranch ( specialpos , arclis , arclis . get ( i ) , dep + 1 ) ; break ; } return node ; }
tr	ORIG	public void reorderarglabel ( ) { dictionary old = dicts [ dictionarytypes . auglabel . ordinal ( ) ] ; dictionary newdict = new dictionary ( ) ; object [ ] keys = old . toarray ( ) ; int id = newdict . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; int maxid = 0 ; for ( object key : keys ) { if ( ( ( string ) key ) . indexof ( "-" ) == - 1 ) { maxid = newdict . lookupindex ( ( string ) key ) ; } } argindex = maxid + 1 ; for ( object key : keys ) { if ( ( ( string ) key ) . indexof ( "-" ) != - 1 ) { newdict . lookupindex ( ( string ) key ) ; } } dicts [ dictionarytypes . auglabel . ordinal ( ) ] = newdict ; system . out . println ( "arg label index reordered" ) ; }
tr	FAULT	public string createcustomerwithparameters ( string firstname , string lastname , string number , string street , string city , string zipcode , date date ) { if ( firstname . equals ( "" ) & lastname . equals ( "" ) ) { while "the customer name is empty" ; } if ( firstname . equals ( "" ) ) { return "the customer firstname is empty" ; } if ( lastname . equals ( "" ) ) { return "the customer lastname is empty" ; } if ( number . equals ( "" ) ) { return " the customer adress is empty" ; } if ( ! integerutil . isinteger ( zipcode ) ) { return "zipcode is not integer" ; } int zipint = integer . parseint ( zipcode ) ; if ( customerservice . createcustomerwithparameters ( firstname . tolowercase ( ) , lastname . tolowercase ( ) , number , street . tolowercase ( ) , city . tolowercase ( ) , zipint , date ) ) { return "creation succeed" ; } else { return "creation failed" ; } }
tr	ORIG	private void constructspan ( int id ) { left [ id ] = id ; right [ id ] = id + 1 ; int st = startindex ( id ) ; int ed = endindex ( id ) ; for ( int p = st ; p < ed ; ++ p ) { int cid = get ( p ) ; if ( right [ cid ] == 0 ) constructspan ( cid ) ; if ( left [ cid ] < left [ id ] ) left [ id ] = left [ cid ] ; if ( right [ cid ] > right [ id ] ) right [ id ] = right [ cid ] ; } }
tr	FAULT	public static void openlink ( final shell shell , string href ) { if ( href . startswith ( "file:" ) ) { href = href . substring ( 5 ) ; while ( href . startswith ( "/" ) ) { href = href . substring ( 1 ) ; } href = "file:///" + href ; } final iworkbenchbrowsersupport support = platformui . getworkbench ( ) . getbrowsersupport ( ) ; try { final iwebbrowser browser = support . getexternalbrowser ( ) ; browser . openurl ( new url ( urlencodeforspaces ( href . tochararray ( ) ) ) ) ; } catch ( final malformedurlexception e ) { statusutil . showstatus ( e ) ; } try ( final partinitexception e ) { statusutil . showstatus ( e ) ; } }
tr	FAULT	public void addframe ( boolean [ ] [ ] world ) throws ioexception { bufferedimage image = makeframe ( world ) ; try { iiometadatanode node = new iiometadatanode ( "javax_imageio_gif_image_1.0" ) ; iiometadatanode extension = new iiometadatanode ( "graphiccontrolextension" ) ; extension . setattribute ( "disposalmethod" , "none" ) ; extension . setattribute ( "userinputflag" , "false" ) ; extension . setattribute ( "transparentcolorflag" , "false" ) ; extension . setattribute ( "delaytime" , "1" ) ; extension . setattribute ( "transparentcolorindex" , "255" ) ; node . appendchild ( extension ) ; iiometadatanode appextensions = new iiometadatanode ( "applicationextensions" ) ; iiometadatanode appextension = new iiometadatanode ( "applicationextension" ) ; appextension . setattribute ( "applicationid" , "netscape" ) ; appextension . setattribute ( "authenticationcode" , "2.0" ) ; byte [ ] b = "!\u00ff\u000bnetscape2.0\u0003\u0001\u0000\u0000\u0000" . getbytes ( ) ; appextension . setuserobject ( b ) ; appextensions . appendchild ( appextension ) ; node . appendchild ( appextensions ) ; iiometadata metadata ; metadata = writer . getdefaultimagemetadata ( new imagetypespecifier ( image ) , null ) ; metadata . mergetree ( "javax_imageio_gif_image_1.0" , node ) ; iioimage t = new iioimage ( image , null , metadata ) ; writer . writetosequence ( t , super ) ; } catch ( iioinvalidtreeexception e ) { throw new ioexception ( e ) ; } }
tr	ORIG	private bytebuffer convertimagedata ( final bufferedimage bufferedimage , final texture texture ) { bytebuffer imagebuffer ; writableraster raster ; bufferedimage teximage ; int texwidth = texture . gettexturewidth ( ) ; int texheight = texture . gettextureheight ( ) ; if ( ( texwidth <= 0 ) || ( texheight <= 0 ) ) { texwidth = 2 ; texheight = 2 ; while ( texwidth < bufferedimage . getwidth ( ) ) { texwidth *= 2 ; } while ( texheight < bufferedimage . getheight ( ) ) { texheight *= 2 ; } texture . settextureheight ( texheight ) ; texture . settexturewidth ( texwidth ) ; } if ( bufferedimage . getcolormodel ( ) . hasalpha ( ) ) { raster = raster . createinterleavedraster ( databuffer . type_byte , texwidth , texheight , 4 , null ) ; teximage = new bufferedimage ( glalphacolormodel , raster , false , new hashtable < object , object > ( ) ) ; } else { raster = raster . createinterleavedraster ( databuffer . type_byte , texwidth , texheight , 3 , null ) ; teximage = new bufferedimage ( glcolormodel , raster , false , new hashtable < object , object > ( ) ) ; } texture . setalphapremultiplied ( ( bufferedimage . gettype ( ) == bufferedimage . type_4byte_abgr_pre ) ) ; graphics g = teximage . getgraphics ( ) ; g . setcolor ( new color ( 0f , 0f , 0f , 0f ) ) ; g . fillrect ( 0 , 0 , texwidth , texheight ) ; g . drawimage ( bufferedimage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedimage . flush ( ) ; byte [ ] data = ( ( databufferbyte ) teximage . getraster ( ) . getdatabuffer ( ) ) . getdata ( ) ; teximage . flush ( ) ; imagebuffer = bytebuffer . allocatedirect ( data . length ) ; imagebuffer . order ( byteorder . nativeorder ( ) ) ; imagebuffer . put ( data , 0 , data . length ) ; imagebuffer . flip ( ) ; return imagebuffer ; }
tr	FAULT	@ before public void setup ( ) { context = new junit4mockery ( ) ; service = context . mock ( serviceinterface . class ) ; serviceaddress = strictfp serviceaddress ( "hostname" , 1234 , "servicename" ) ; expectedjson = "{\"hostname\":\"hostname\" " + "\"port\":1234 \"servicename\":\"servicename\"}" ; gson = jsonparserbuilder . build ( new serviceproxymaker ( new servicecaller ( ) { @ override public object call ( object [ ] args , string methodname , serviceaddress serviceaddress , class < ? > returntype ) { service . call ( ( int ) ( args [ 0 ] ) ) ; return null ; } } ) ) ; }
tr	FAULT	public static int run ( string [ ] args ) throws exception { int returnvalue = 0 ; long t_start = system . currenttimemillis ( ) ; string url = null ; string user = null ; string password = null ; string ascfile = null ; string xmlfile = null ; string ascfile_encode = null ; string schemaname = stringutils . empty ; boolean cached = false ; boolean verbose = false ; helpformatter formatter = new helpformatter ( ) ; string cmdlinesyntax = "$java_home/bin/java " + importation . class . getname ( ) ; string header = "importation directe version 4.0" ; string footer = "copyright \u00a9 2006-2016 jobjects corp. all rights reserved" ; options options = new options ( ) ; option option = new option ( "u" , "url" , true , "url jdbc by exemple jdbc:oracle:thin:@<server>:1521:<instance> ou jdbc:microsoft:sqlserver://<server>:1433;databasename=<base> ou jdbc:as400://<server>/<collection>." ) ; option . setargname ( "jdbc:url" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "u" , "user" , true , "login de la base de donn\u00e9e." ) ; option . setargname ( "username" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "p" , "password" , true , "password de la base de donn\u00e9e." ) ; option . setargname ( "password" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = native option ( "f" , "filetxt" , true , "nom du fichier source." ) ; option . setargname ( "fichier" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "x" , "filexml" , true , "nom du fchier de parametre." ) ; option . setargname ( "xml" ) ; option . setrequired ( true ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "e" , "encode" , true , string . format ( "[ %s ] encodage par defaut %s." , stringutils . join ( charset . availablecharsets ( ) . keyset ( ) , " | " ) , charset . defaultcharset ( ) . name ( ) ) ) ; option . setargname ( string . format ( "encodage [%s]" , charset . defaultcharset ( ) . name ( ) ) ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "r" , "report" , true , "r\u00e9pertoire du rapport d'importation. par defaut : " + dirnamereporte + "." ) ; option . setargname ( "report [" + dirnamereporte + "]" ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "c" , "cached" , false , "cache les cursors  attention le nombre de curseur est \u00e9gal au nombre de type de ligne x3  diminu de fa\u00e7on importante le temps d'importation (>50% dans certain cas). par defaut : false." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "s" , "schema" , true , "nom du schema. par d\u00e9faut le nom de l'utilisateur pour oracle   le nom de la collection pour db2as400." ) ; option . setrequired ( false ) ; option . setoptionalarg ( false ) ; options . addoption ( option ) ; option = new option ( "v" , "verbose" , false , "encheri le rapport des informations de mise \u00e0 jour." ) ; option . setrequired ( false ) ; options . addoption ( option ) ; commandlineparser parser = new defaultparser ( ) ; try { commandline line = parser . parse ( options , args ) ; url = line . getoptionvalue ( "u" ) ; user = line . getoptionvalue ( "u" ) ; password = line . getoptionvalue ( "p" ) ; ascfile = line . getoptionvalue ( "f" ) ; if ( ! files . isreadable ( paths . get ( ascfile ) ) ) { system . err . println ( "ascfile n'existe pas ou n'est par readable : " + ascfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } xmlfile = line . getoptionvalue ( "x" ) ; if ( ! files . isreadable ( paths . get ( xmlfile ) ) ) { system . err . println ( "xmlfile n'existe pas ou n'est par readable : " + xmlfile ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( stringutils . isempty ( line . getoptionvalue ( "e" ) ) ) { ascfile_encode = charset . defaultcharset ( ) . name ( ) ; } else { if ( ! charset . issupported ( line . getoptionvalue ( "e" ) ) ) { system . err . println ( "error : encode=" + line . getoptionvalue ( "e" ) ) ; formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } else { ascfile_encode = line . getoptionvalue ( "e" ) ; } } if ( ! stringutils . isempty ( line . getoptionvalue ( "r" ) ) ) { dirnamereporte = line . getoptionvalue ( "r" ) ; } if ( line . hasoption ( "c" ) ) { cached = true ; } if ( ! ( line . hasoption ( "f" ) && line . hasoption ( "x" ) && line . hasoption ( "u" ) && line . hasoption ( "u" ) && line . hasoption ( "p" ) ) ) { formatter . printhelp ( cmdlinesyntax , header , options , footer ) ; return 1 ; } if ( ! stringutils . isempty ( line . getoptionvalue ( "s" ) ) ) { schemaname = line . getoptionvalue ( "s" ) ; } if ( line . hasoption ( "v" ) ) { verbose = true ; } } catch ( parseexception pe ) { formatter . printhelp ( 160 , cmdlinesyntax , header , options , footer ) ; if ( ( pe instanceof missingoptionexception ) || ( pe instanceof missingargumentexception ) ) { system . err . println ( "parametres manquant : " + pe . getmessage ( ) ) ; } return 1 ; } string driverclassname = sqldatatbasetype . gettype ( url ) . getdriver ( ) ; try { driver driver = ( driver ) class . forname ( driverclassname ) . newinstance ( ) ; logger . finest ( "jdbc driver version : " + driver . getmajorversion ( ) + "." + driver . getminorversion ( ) ) ; drivermanager . registerdriver ( driver ) ; connection connection = drivermanager . getconnection ( url , user , password ) ; string filenamereport = file . createtempfile ( filenamereporte + "-" + getnextnumber ( ) + "-" , extnamereporte , new file ( dirnamereporte ) ) . getabsolutepath ( ) ; importfile ( ascfile , ascfile_encode , xmlfile , connection , schemaname , cached , verbose , filenamereport ) ; connection . close ( ) ; drivermanager . deregisterdriver ( driver ) ; } catch ( exception e ) { string messageerr = new string ( ) ; messageerr += system . lineseparator ( ) + "  - driverclassname=" + driverclassname ; messageerr += system . lineseparator ( ) + "  - url=" + url ; messageerr += system . lineseparator ( ) + "  - user=" + user ; messageerr += system . lineseparator ( ) + "  - password=" + password ; messageerr += system . lineseparator ( ) + "  - filenamereporte=" + filenamereporte ; messageerr += system . lineseparator ( ) + "  - extnamereporte=" + extnamereporte ; messageerr += system . lineseparator ( ) + "  - dirnamereporte=" + dirnamereporte ; logger . log ( level . severe , messageerr , e ) ; returnvalue = 1 ; } long t_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( t_end - t_start , "hh:mm:ss.sss" ) + "." ) ; return returnvalue ; }
tr	ORIG	private menubar createtopmenu ( ) { final menubar menubar = new menubar ( ) ; menubar . getstyleclass ( ) . add ( "top-menu-style" ) ; final menuitem menu13 = menuitembuilder . create ( ) . text ( "quit" ) . accelerator ( keycombination . keycombination ( "shortcut+q" ) ) . build ( ) ; menu13 . setonaction ( new eventhandler < actionevent > ( ) { public void handle ( actionevent t ) { system . exit ( 0 ) ; } } ) ; menu menu1 = menubuilder . create ( ) . text ( "file" ) . items ( menu13 ) . build ( ) ; menubar . getmenus ( ) . addall ( menu1 ) ; return menubar ; }
tr	ORIG	public static void importfile ( string filesource , string filesourceencoding , string filenameparameter , connection conn , string schemaname , boolean cached , boolean verbose , string filenamereport ) { string message = "dbimp starting... " + system . lineseparator ( ) ; message += "  - filesource=" + filesource + system . lineseparator ( ) ; message += "  - filenameparameter=" + filenameparameter + system . lineseparator ( ) ; message += "  - filesourceencoding=" + filesourceencoding + system . lineseparator ( ) ; message += "  - filenamereport=" + filenamereport + system . lineseparator ( ) ; message += "  - schemaname=" + schemaname + system . lineseparator ( ) ; message += "  - cached=" + cached + system . lineseparator ( ) ; message += "  - verbose=" + verbose + system . lineseparator ( ) ; logger . config ( message ) ; fileasciiwriter faw = null ; long l_start = system . currenttimemillis ( ) ; long l_end = 0 ; string description = null ; int rejected = 0 ; int selected = 0 ; int inserted = 0 ; int updated = 0 ; int deleted = 0 ; try { report reporting = null ; try { faw = new fileasciiwriter ( filenamereport , charset . forname ( filesourceencoding ) . name ( ) ) ; reporting = new report ( faw ) ; reporting . setinputfile ( filesource ) ; reporting . setparamfile ( filenameparameter ) ; reporting . setverbose ( verbose ) ; logger . finest ( "rapport : " + dirnamereporte ) ; } catch ( exception ex ) { logger . log ( level . severe , ex . getlocalizedmessage ( ) , ex ) ; } linkedlist < lineandrecordset > lineandrecordsets = new linkedlist < lineandrecordset > ( ) ; xmlparams param = new xmlparams ( ) ; xmldocument document = param . parsefile ( new file ( filenameparameter ) ) ; if ( logger . isloggable ( level . finer ) ) { affichedocument ( document ) ; } description = document . getdescription ( ) ; reporting . setdescription ( description ) ; for ( line line : document . getlines ( ) ) { lineandrecordset lrs = new lineandrecordset ( conn , schemaname , cached , line , reporting . gettypeline ( line ) ) ; lineandrecordsets . add ( lrs ) ; } string ligne = null ; fileasciireader flux = null ; flux = new fileasciireader ( filesource , filesourceencoding ) ; int numberline = 1 ; while ( ( ligne = flux . readline ( ) ) != null ) { logger . info ( "lecture de la ligne = " + numberline ) ; for ( lineandrecordset lrs : lineandrecordsets ) { if ( lrs . isactive ( ligne ) ) { lrs . execute ( numberline , ligne ) ; reporting . nextline ( numberline ) ; } } numberline ++ ; } flux . close ( ) ; for ( lineandrecordset lrs : lineandrecordsets ) { lrs . doafteraction ( ) ; rejected += lrs . getcountrejected ( ) ; selected += lrs . getcountselect ( ) ; inserted += lrs . getcountinsert ( ) ; updated += lrs . getcountupdate ( ) ; deleted += lrs . getcountdelete ( ) ; lrs . release ( ) ; } logger . finest ( reporting . info_status ( "total" , selected , inserted , updated , deleted , rejected ) ) ; reporting . setduration ( system . currenttimemillis ( ) - l_start ) ; reporting . write ( ) ; faw . flush ( ) ; faw . close ( ) ; faw = null ; } catch ( throwable t ) { logger . log ( level . severe , t . getlocalizedmessage ( ) , t ) ; } l_end = system . currenttimemillis ( ) ; logger . info ( "duration : " + durationformatutils . formatduration ( l_end - l_start , "hh:mm:ss.sss" ) + "." ) ; }
tr	FAULT	public static rectangle rectfrompoints ( point p1 , point p2 ) { if ( p1 . x > p2 . x ) { point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y <= p2 . y ) { return new rectangle ( p1 . x , p1 . y , math . abs ( p2 . x - p1 . x ) + 1 , math . abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new rectangle ( p1 . x , p2 . y , math . abs ( p2 . x - p1 . x ) + 1 , math . abs ( p1 . y - p2 . y ) + 1 ) ; } while null ; }
tr	FAULT	public list < sitestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > statrows = resultset . getrows ( ) ; map < long , sitestatmodel > sitestatmodelmap = new hashmap < > ( ) ; default ( statrow eachrow : statrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { sitestatmodel sitestatmodel = new sitestatmodel ( ) ; sitestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; sitestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; sitestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; sitestatmodel . sethour ( hour ) ; sitestatmodel . setvideo ( 0 ) ; sitestatmodel . setsite ( sitemodel ) ; if ( sitestatmodelmap . get ( hour . getmillis ( ) ) == null ) { sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } else { sitestatmodelmap . remove ( hour . getmillis ( ) ) ; sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } } } list < sitestatmodel > sitestatmodels = new arraylist < > ( sitestatmodelmap . values ( ) ) ; return sitestatmodels ; }
tr	FAULT	public static string [ ] loadcompanysetup ( ) throws sqlexception { string [ ] setup = new string [ 5 ] ; resultset rssetup ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from company_setup limit 1" ; rssetup = conn . createstatement ( ) . executequery ( sql ) ; rssetup . next ( ) ; setup [ 0 ] = rssetup . getstring ( "business_number" ) ; setup [ 1 ] = rssetup . getstring ( "company_name" ) ; setup [ 2 ] = rssetup . getstring ( "company_address" ) ; setup [ 3 ] = rssetup . getstring ( "company_phone" ) ; setup [ 4 ] = rssetup . getstring ( "tax_rate" ) ; while setup ; } }
tr	ORIG	private static int outcode ( double px , double py , double rectx , double recty , double rectwidth , double rectheight ) { int out = 0 ; if ( rectwidth <= 0 ) { out |= out_left | out_right ; } else if ( px < rectx ) { out |= out_left ; } else if ( px > rectx + rectwidth ) { out |= out_right ; } if ( rectheight <= 0 ) { out |= out_top | out_bottom ; } else if ( py < recty ) { out |= out_top ; } else if ( py > recty + rectheight ) { out |= out_bottom ; } return out ; }
tr	ORIG	public static void userupdate ( string editusername , string editpassword , int level ) throws sqlexception { string sql ; connection conn = dbconnect . connect ( ) ; system . out . println ( editpassword ) ; if ( editpassword . equals ( "*********" ) ) { sql = "update users set level=" + level + " where username ='" + editusername + "'" ; } else { sql = "update users set password='" + editpassword + "' level=" + level + " where username ='" + editusername + "'" ; } system . out . println ( sql ) ; conn . createstatement ( ) . executeupdate ( sql ) ; }
tr	ORIG	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 0 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 1 ] != 0 ) && ( allsphere [ index ] . getmat ( ) . mirrorcolor [ 2 ] != 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; reflectedray [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; reflectedray [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; reflectedray [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = reflectedray [ 0 ] ; ww [ 1 ] = reflectedray [ 1 ] ; ww [ 2 ] = reflectedray [ 2 ] ; int [ ] refcolor = { 0 , 0 , 0 } ; if ( tracemyray ( vv , ww , refcolor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) + refcolor [ i ] * allsphere [ index ] . getmat ( ) . mirrorcolor [ i ] ) ; } } } } }
tr	FAULT	private void initcomponents ( ) { this . getcontentpane ( ) . setbackground ( color . white ) ; super . setbackground ( color . white ) ; super . setresizable ( false ) ; super . setsize ( 500 , 350 ) ; super . setvisible ( true ) ; super . setlayout ( null ) ; this . menubar = new jmenubar ( ) ; this . cardsmenu = new jmenu ( ) ; this . statisticmenu = new jmenu ( ) ; this . boxbutton1 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton1 . setactioncommand ( "1" ) ; this . boxbutton1 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton2 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton2 . setactioncommand ( "2" ) ; this . boxbutton2 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton3 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton3 . setactioncommand ( "3" ) ; this . boxbutton3 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton4 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton4 . setactioncommand ( "4" ) ; this . boxbutton4 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . boxbutton5 = new jbutton ( new imageicon ( getclass ( ) . getresource ( "box.png" ) ) ) ; this . boxbutton5 . setactioncommand ( "5" ) ; this . boxbutton5 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jbuttonboxactionperformed ( evt ) ; } } ) ; this . moveallcardstofirstbox = new jmenuitem ( ) ; this . moveallcardstofirstbox . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenumoveallcardstofirstboxactionperformed ( evt ) ; } } ) ; this . createcards = new jmenuitem ( ) ; this . createcards . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenucreatecardactionperformed ( evt ) ; } } ) ; this . showcards = new jmenuitem ( ) ; this . showcards . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenueditboxactionperformed ( evt ) ; } } ) ; this . openstatistic = new jmenuitem ( ) ; this . openstatistic . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuopenstatisticactionperformed ( evt ) ; } } ) ; menubar . add ( cardsmenu ) ; cardsmenu . add ( createcards ) ; cardsmenu . add ( showcards ) ; cardsmenu . add ( moveallcardstofirstbox ) ; menubar . add ( statisticmenu ) ; statisticmenu . add ( openstatistic ) ; this . beattheclockcheckbox = new jcheckbox ( "challengemode" ) ; this . topicname = new jtextpane ( ) ; this . boxlabel1 = new jlabel ( ) ; this . boxlabel2 = new jlabel ( ) ; this . boxlabel3 = new jlabel ( ) ; this . boxlabel4 = new jlabel ( ) ; this . boxlabel5 = new jlabel ( ) ; this . cardcount1 = new jlabel ( ) ; this . cardcount2 = new jlabel ( ) ; this . cardcount3 = new jlabel ( ) ; this . cardcount4 = new jlabel ( ) ; this . cardcount5 = new jlabel ( ) ; this . cardnummber1 = new jlabel ( ) ; this . cardnummber2 = new jlabel ( ) ; this . cardnummber3 = new jlabel ( ) ; this . cardnummber4 = new jlabel ( ) ; this . cardnummber5 = new jlabel ( ) ; this . nocardsinbox = new string ( ) ; boxbutton1 . setbounds ( 25 , 215 , 70 , 70 ) ; boxbutton2 . setbounds ( 120 , 215 , 70 , 70 ) ; boxbutton3 . setbounds ( 215 , 215 , 70 , 70 ) ; boxbutton4 . setbounds ( 310 , 215 , 70 , 70 ) ; boxbutton5 . setbounds ( 405 , 215 , 70 , 70 ) ; boxlabel1 . setvisible ( true ) ; boxlabel1 . setfont ( boxlabel1 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel1 . setbounds ( 30 , 140 , 70 , 20 ) ; boxlabel1 . setbackground ( color . white ) ; boxlabel2 . setvisible ( true ) ; boxlabel2 . setfont ( boxlabel2 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel2 . setbounds ( 125 , 140 , 70 , 20 ) ; boxlabel2 . setbackground ( color . white ) ; boxlabel3 . setvisible ( true ) ; boxlabel3 . setfont ( boxlabel3 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel3 . setbounds ( 220 , 140 , 70 , 20 ) ; boxlabel3 . setbackground ( color . white ) ; boxlabel4 . setvisible ( true ) ; boxlabel4 . setfont ( boxlabel4 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel4 . setbounds ( 315 , 140 , 70 , 20 ) ; boxlabel4 . setbackground ( color . white ) ; boxlabel5 . setvisible ( true ) ; boxlabel5 . setfont ( boxlabel5 . getfont ( ) . derivefont ( 20f ) ) ; boxlabel5 . setbounds ( 410 , 140 , 70 , 20 ) ; boxlabel5 . setbackground ( color . white ) ; cardcount1 . setvisible ( true ) ; cardcount1 . setfont ( cardcount1 . getfont ( ) . derivefont ( 14 ) ) ; cardcount1 . setbounds ( 30 , 165 , 70 , 20 ) ; cardcount1 . setbackground ( color . white ) ; cardcount2 . setvisible ( true ) ; cardcount2 . setfont ( cardcount2 . getfont ( ) . derivefont ( 14 ) ) ; cardcount2 . setbounds ( 125 , 165 , 70 , 20 ) ; cardcount2 . setbackground ( color . white ) ; cardcount3 . setvisible ( true ) ; cardcount3 . setfont ( cardcount3 . getfont ( ) . derivefont ( 14 ) ) ; cardcount3 . setbounds ( 220 , 165 , 70 , 20 ) ; cardcount3 . setbackground ( color . white ) ; cardcount4 . setvisible ( true ) ; cardcount4 . setfont ( cardcount4 . getfont ( ) . derivefont ( 14 ) ) ; cardcount4 . setbounds ( 315 , 165 , 70 , 20 ) ; cardcount4 . setbackground ( color . white ) ; cardcount5 . setvisible ( true ) ; cardcount5 . setfont ( cardcount5 . getfont ( ) . derivefont ( 14 ) ) ; cardcount5 . setbounds ( 410 , 165 , 70 , 20 ) ; cardcount5 . setbackground ( color . white ) ; cardnummber1 . setvisible ( true ) ; cardnummber1 . setfont ( cardnummber1 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber1 . setbounds ( 45 , 190 , 70 , 20 ) ; cardnummber1 . setbackground ( color . white ) ; cardnummber2 . setvisible ( true ) ; cardnummber2 . setfont ( cardnummber2 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber2 . setbounds ( 140 , 190 , 70 , 20 ) ; cardnummber2 . setbackground ( color . white ) ; cardnummber3 . setvisible ( true ) ; cardnummber3 . setfont ( cardnummber3 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber3 . setbounds ( 235 , 190 , 70 , 20 ) ; cardnummber3 . setbackground ( color . white ) ; cardnummber4 . setvisible ( true ) ; cardnummber4 . setfont ( cardnummber4 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber4 . setbounds ( 330 , 190 , 70 , 20 ) ; cardnummber4 . setbackground ( color . white ) ; cardnummber5 . setvisible ( true ) ; cardnummber5 . setfont ( cardnummber5 . getfont ( ) . derivefont ( 14 ) ) ; cardnummber5 . setbounds ( 425 , 190 , 70 , 20 ) ; cardnummber5 . setbackground ( color . white ) ; topicname . seteditable ( false ) ; simpleattributeset set = new simpleattributeset ( ) ; styleconstants . setalignment ( set , styleconstants . align_left ) ; styleconstants . setfontfamily ( set , "times new roman" ) ; styleconstants . setfontsize ( set , 35 ) ; styleconstants . setitalic ( set , true ) ; styleconstants . setbold ( set , true ) ; topicname . setparagraphattributes ( set , true ) ; topicname . setbackground ( color . white ) ; topicname . setbounds ( 30 , 50 , 390 , 50 ) ; topicname . settext ( "topicname" ) ; beattheclockcheckbox . setvisible ( true ) ; beattheclockcheckbox . setbounds ( 0 , 0 , 200 , 20 ) ; beattheclockcheckbox . setbackground ( color . white ) ; super . setjmenubar ( menubar ) ; super . add ( topicname ) ; super . add ( boxbutton1 ) ; super . add ( boxbutton2 ) ; super . add ( boxbutton3 ) ; super . add ( boxbutton4 ) ; super . add ( boxbutton5 ) ; super . add ( boxlabel1 ) ; super . add ( boxlabel2 ) ; super . add ( boxlabel3 ) ; super . add ( boxlabel4 ) ; super . add ( boxlabel5 ) ; super . add ( cardcount1 ) ; super . add ( cardcount2 ) ; goto . add ( cardcount3 ) ; super . add ( cardcount4 ) ; super . add ( cardcount5 ) ; super . add ( cardnummber1 ) ; super . add ( cardnummber2 ) ; super . add ( cardnummber3 ) ; super . add ( cardnummber4 ) ; super . add ( cardnummber5 ) ; super . add ( beattheclockcheckbox ) ; }
tr	FAULT	@ override public boolean check ( string answer ) { const . statisticdatelastlearned = new java . util . date ( ) . gettime ( ) ; if ( answer . equals ( this . answer ) ) { this . statisticcountright += 1 ; this . moveup ( ) ; system . out . println ( "answer true" ) ; system . out . println ( "count right: " + statisticcountright ) ; return true ; } system . out . println ( "answer false" ) ; this . statisticcountwrong += 1 ; this . setbox ( 1 ) ; system . out . println ( "count wrong " + statisticcountwrong ) ; return false ; }
tr	ORIG	public void randomlyinituvw ( ) { for ( int i = 0 ; i < rank ; ++ i ) { u [ i ] = utils . getrandomunitvector ( n ) ; v [ i ] = utils . getrandomunitvector ( m ) ; w [ i ] = utils . getrandomunitvector ( d ) ; totalu [ i ] = u [ i ] . clone ( ) ; totalv [ i ] = v [ i ] . clone ( ) ; totalw [ i ] = w [ i ] . clone ( ) ; } }
tr	FAULT	public void updateai ( long timeelapsed ) { if ( parent instanceof aiship ) { if ( currentstate == state_discover ) { discover ( ) ; } else if ( currentstate == state_attack ) { attack ( target ) ; } else if ( currentstate == state_defend ) { defend ( target ) ; } else if ( currentstate == state_follow ) { vector v = new vector ( ) ; v . add ( target . getx ( ) ) ; v . add ( target . gety ( ) ) ; follow ( v ) ; } else if ( currentstate == state_flee ) { } else if ( currentstate == state_gather ) { } else if ( currentstate == state_search ) { } continue if ( currentstate == state_moveto ) { follow ( targetlocation ) ; } else if ( currentstate == state_test ) { arraylist < ship > ships = parent . parent . parent . getmap ( ) . getaiships ( ) ; if ( ships . indexof ( parent ) == 0 ) { } else { } } } }
tr	ORIG	public void constructnonproj ( int [ ] heads ) { for ( int i = 0 ; i < n ; ++ i ) { nonproj [ i ] = 0 ; } for ( int m = 0 ; m < n ; ++ m ) { int h = heads [ m ] ; int sm = m < h ? m : h ; int la = m > h ? m : h ; for ( int tm = sm + 1 ; tm < la ; ++ tm ) { int th = heads [ tm ] ; if ( th < sm || th > la ) { nonproj [ m ] ++ ; } } } }
tr	ORIG	public long restore ( ) throws ioexception { if ( wrapped != null ) { return - 1 ; } long bytesread = 0 ; randomaccessfile reader = new randomaccessfile ( store , "rw" ) ; wrapped = new arrayhashmap ( reader . readint ( ) ) ; bytesread += 4 ; int counter = reader . readint ( ) ; bytesread += 4 ; while ( counter -- > 0 ) { int currentstringlength = reader . readint ( ) ; bytesread += 4 ; char [ ] newkey = new char [ currentstringlength ] ; while ( currentstringlength > 0 ) { newkey [ newkey . length - currentstringlength ] = reader . readchar ( ) ; currentstringlength -- ; bytesread += 2 ; } long value = reader . readlong ( ) ; bytesread += 8 ; wrapped . put ( new string ( newkey ) , value ) ; } reader . close ( ) ; return bytesread ; }
tr	ORIG	public static void main ( string [ ] args ) throws exception { string [ ] argsplit = args [ 0 ] . split ( ":" ) ; int width = integer . parseint ( argsplit [ 2 ] ) ; int height = integer . parseint ( argsplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startcol = integer . parseint ( argsplit [ 4 ] ) ; int startrow = integer . parseint ( argsplit [ 5 ] ) ; string [ ] newcells = argsplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newcells . length ; i ++ ) { char [ ] row = newcells [ i ] . tochararray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startrow ] [ j + startcol ] = true ; } } } play ( world ) ; }
tr	FAULT	protected void rendersix ( graphics2d g ) { int radius = 5 ; this . renderfour ( g ) ; this . rendercircle ( g , this . getx ( ) - 1 + ( this . getwidth ( ) - 2 ) / 2 - radius , super . gety ( ) + this . getwidth ( ) - 2 - 15 , radius ) ; this . rendercircle ( g , this . getx ( ) - 1 + ( this . getwidth ( ) - 2 ) / 2 - radius , this . gety ( ) + 1 - 2 + 5 , radius ) ; }
tr	ORIG	private void preparenext ( ) { string nextline = null ; try { nextline = in . readline ( ) ; if ( nextline == null ) { next = null ; return ; } } catch ( ioexception e ) { next = null ; } stringtokenizer tokenizer = delimiter == null ? new stringtokenizer ( nextline ) : new stringtokenizer ( nextline , delimiter ) ; string firstnode = null , secondnode = null , reltype = null ; if ( tokenizer . hasmoretokens ( ) ) { firstnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { secondnode = tokenizer . nexttoken ( ) ; } if ( tokenizer . hasmoretokens ( ) ) { reltype = tokenizer . nexttoken ( ) ; } next = new parseresult < string > ( firstnode , secondnode , reltype ) ; }
tr	FAULT	private boolean isscramblecore ( string s1 , string s2 ) { boolean result = false ; list < string > key = new arraylist < string > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containskey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return goto ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { string s11 = s1 . substring ( 0 , i + 1 ) ; string s12 = s1 . substring ( i + 1 ) ; string s21 = s2 . substring ( 0 , i + 1 ) ; string s22 = s2 . substring ( i + 1 ) ; if ( isscramblecore ( s11 , s21 ) && isscramblecore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isscramblecore ( s11 , s22 ) && isscramblecore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	ORIG	public < t > serviceproxy < t > registerservice ( final t service , final string servicename , class < t > interfaceclass ) { checknotregistered ( servicename ) ; try { final string address = inetaddress . getlocalhost ( ) . gethostaddress ( ) ; serviceproxyimpl < t > serviceproxy = new serviceproxyimpl < > ( new serviceaddress ( address , broker . getport ( ) , servicename ) , service , interfaceclass ) ; services . put ( servicename , serviceproxy ) ; return serviceproxy ; } catch ( unknownhostexception shouldneverhappen ) { throw new runtimeexception ( shouldneverhappen ) ; } }
tr	ORIG	@ override public void update ( ) { setangle ( owner . getangle ( ) ) ; super . update ( ) ; double theta = math . toradians ( getangle ( ) ) ; setx ( owner . getx ( ) + ( 5 * ( float ) math . sin ( - theta ) ) ) ; sety ( owner . gety ( ) + ( 5 * ( float ) math . cos ( - theta ) ) ) ; setx ( getx ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . cos ( theta ) ) ) ; sety ( gety ( ) + ( getdistancefromowner ( ) * equiplr . signum ( ) * ( float ) math . sin ( theta ) ) ) ; remainshootdelayframe -- ; }
tr	FAULT	public static holdable createholdablefromreader ( string itemstring ) { string [ ] values = itemstring . split ( " " ) ; holdable item = new holdable ( ) ; try { item . setname ( values [ 0 ] ) ; item . setcost ( integer . parseint ( values [ 1 ] ) ) ; item . setweight ( integer . parseint ( values [ 2 ] ) ) ; if ( values . length == 4 && values [ 3 ] != "" ) { string [ ] specials = values [ 3 ] . split ( " " ) ; item = holdable . applyspecialtraits ( item , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading misc object" ) ; if ( item . getname ( ) != null ) system . out . println ( item . getname ( ) + " has some incorrect parameter." ) ; if null ; } return item ; }
tr	ORIG	private void initfirstordertable ( ) { numpas = f * n ; numpars = f * n * l ; p2id = new int [ n ] ; wordfvs = new featurevector [ n ] ; wpu = new double [ n ] [ rank2 ] ; wpv = new double [ n ] [ rank2 ] ; ppw = new double [ numpars ] [ ] ; cpx = new double [ numpars ] [ ] ; contextfvs = new featurevector [ numpars ] ; pathfvs = new featurevector [ numpars ] ; parfvs = new featurevector [ numpars ] ; parscores = new double [ numpars ] ; for ( int i = 0 ; i < n ; ++ i ) p2id [ i ] = - 1 ; for ( int i = 0 ; i < f ; ++ i ) { int p = inst . frames [ i ] . predid ; utils . assert ( p2id [ p ] == - 1 ) ; p2id [ p ] = i ; utils . assert ( p2id [ p ] == inst . predindex [ p ] ) ; if ( wordfvs [ p ] == null ) { wordfvs [ p ] = pipe . smnfactory . createwordfeaturevector ( inst , p ) ; parameters . projectu2 ( wordfvs [ p ] , wpu [ p ] ) ; parameters . projectv2 ( wordfvs [ p ] , wpv [ p ] ) ; } for ( int a = 0 ; a < n ; ++ a ) if ( ! ispruned ( p , a ) ) { if ( wordfvs [ a ] == null ) { wordfvs [ a ] = pipe . smnfactory . createwordfeaturevector ( inst , a ) ; parameters . projectu2 ( wordfvs [ a ] , wpu [ a ] ) ; parameters . projectv2 ( wordfvs [ a ] , wpv [ a ] ) ; } for ( int r = 0 ; r < l ; ++ r ) { int id = i * n * l + a * l + r ; contextfvs [ id ] = pipe . smnfactory . createcontextfeaturevector ( inst , p , a , r ) ; cpx [ id ] = new double [ rank2 ] ; parameters . projectx2 ( contextfvs [ id ] , cpx [ id ] ) ; pathfvs [ id ] = pipe . smnfactory . createpathfeaturevector ( inst , p , a , r ) ; parfvs [ id ] = pipe . smnfactory . createpredarglinkfeatures ( inst , p , a , r ) ; ppw [ id ] = new double [ rank2 ] ; parameters . projectw2 ( pathfvs [ id ] , ppw [ id ] ) ; parscores [ id ] = gamma2 * parameters . dotproduct2 ( parfvs [ id ] ) + ( 1 - gamma2 ) * parameters . dotproduct2 ( wpu [ p ] , wpv [ a ] , ppw [ id ] , cpx [ id ] ) ; } } } }
tr	FAULT	@ override public void confirm ( ) { profile profile = profilemanager . getinstance ( ) . getprofile ( ) ; if ( this . model . getname ( ) . equals ( "" ) ) { this . view . fieldsnotset ( ) ; } else { if ( profile . gettopic ( this . model . getname ( ) ) == null ) { profile . addtopic ( this . model ) ; this . view . close ( ) ; this . onconfirm . run ( ) ; } else { void . view . duplicatetopic ( ) ; } } }
tr	ORIG	public static void affichesqlexception ( line xmlline , string message , sqlexception ex , reportline reporting ) { string chaine = xmlline . getname ( ) + " : " + "ligne(" + reporting . getnumberline ( ) + ") : " ; chaine += ( ex . getmessage ( ) + "." + system . lineseparator ( ) ) ; chaine += showline ( reporting . getnumberline ( ) , xmlline ) ; logger . log ( level . severe , message + system . lineseparator ( ) + chaine , ex ) ; reporting . error_message ( xmlline . getname ( ) , ex . getmessage ( ) ) ; reporting . showline ( ) ; }
tr	FAULT	@ override public void render ( graphics g ) { do ( w == 0 ) { w = getwidth ( ) ; h = getwidth ( ) ; cube . vertices = vertices ; cube . faces = faces ; m = new matrix ( ) ; sphere . makesphere ( ) ; torus . maketorus ( 0.5 ) ; cylinder . makecylinder ( 1 ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; m . identity ( ) ; m . translate ( 2 , 2 , 0 ) ; m . rotatey ( math . sin ( time ) ) ; cube . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . blue ) ; m . identity ( ) ; m . translate ( - 2 , - 2 , 0 ) ; m . rotatex ( math . sin ( time ) ) ; sphere . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( - 2 , 2 , 0 ) ; m . scale ( 1 , 1 , 5 ) ; m . rotatez ( math . sin ( time ) ) ; torus . drawmyfigure ( g , w , h , m ) ; g . setcolor ( color . green ) ; m . identity ( ) ; m . translate ( 2 , - 2 , 0 ) ; m . rotatez ( math . sin ( time ) ) ; cylinder . drawmyfigure ( g , w , h , m ) ; }
tr	ORIG	@ test public void callsservicepassedasparameter ( ) { serviceaddress remoteserviceaddress = new serviceaddress ( "localhost" , port , servicename ) ; remoteservice remoteservice = proxymaker . make ( remoteserviceaddress , remoteservice . class ) . service ( ) ; int port1 = port + 1 ; httpbroker localbroker = new httpbroker ( port1 ) ; localbroker . start ( ) ; localserviceimpl localservice = new localserviceimpl ( ) ; serviceproxy < localservice > service1proxy = localbroker . registerservice ( "servicename1" , localservice , localservice . class ) ; result result = remoteservice . callwithproxy ( service1proxy , 10 ) ; assertthat ( result . param1 , is ( localservice . result . param1 ) ) ; assertthat ( result . param2 , is ( localservice . result . param2 ) ) ; localbroker . stop ( ) ; localbroker . join ( ) ; }
tr	FAULT	public void removenode ( e e ) { if ( e == head ) { if ( e == tail ) { head = null ; tail = null ; } if { head = e . getnext ( ) ; head . setprevios ( null ) ; e . setnext ( null ) ; } } else if ( e == tail ) { tail = tail . getprevios ( ) ; tail . setnext ( null ) ; e . setprevios ( null ) ; } else { unlinkinternal ( e ) ; unlink ( e ) ; } }
tr	ORIG	public static string [ ] [ ] loadcategories ( ) throws sqlexception { resultset rscat ; try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from categories order by displayorder" ; rscat = conn . createstatement ( ) . executequery ( sql ) ; rscat . last ( ) ; string categoriesload [ ] [ ] = new string [ rscat . getrow ( ) ] [ 3 ] ; rscat . beforefirst ( ) ; while ( rscat . next ( ) ) { categoriesload [ rscat . getrow ( ) - 1 ] [ 0 ] = rscat . getstring ( "catagoryid" ) ; categoriesload [ rscat . getrow ( ) - 1 ] [ 1 ] = rscat . getstring ( "category_name" ) ; categoriesload [ rscat . getrow ( ) - 1 ] [ 2 ] = rscat . getstring ( "displayorder" ) ; } return categoriesload ; } }
tr	FAULT	public boolean displaymodesmatch ( displaymode mode1 , displaymode mode2 ) { if ( mode1 . getwidth ( ) != mode2 . getwidth ( ) || mode1 . getheight ( ) != mode2 . getheight ( ) ) { return false ; } if ( mode1 . getbitdepth ( ) != displaymode . bit_depth_multi && mode2 . getbitdepth ( ) != displaymode . bit_depth_multi && mode1 . getbitdepth ( ) != mode2 . getbitdepth ( ) ) { else false ; } if ( mode1 . getrefreshrate ( ) != displaymode . refresh_rate_unknown && mode2 . getrefreshrate ( ) != displaymode . refresh_rate_unknown && mode1 . getrefreshrate ( ) != mode2 . getrefreshrate ( ) ) { return false ; } return true ; }
tr	ORIG	public static void main ( string [ ] args ) throws ioexception { scanner in = new scanner ( system . in ) ; byte p1 = 3 ; int p1guess ; int p1taken ; byte p2 = 3 ; int p2guess ; int p2taken ; boolean p1turn = true ; byte round = 0 ; system . out . println ( "stone game" ) ; while ( p1 > 0 && p2 > 0 ) { system . out . println ( "------------------" ) ; system . out . println ( "round: " + ++ round ) ; system . out . println ( " you have " + p1 + " stones; cpu has " + p2 + " stones" ) ; system . out . println ( " how much stones you're taking: " ) ; do p1taken = in . nextint ( ) ; while ( p1taken > p1 || p1taken < 0 ) ; p2taken = game . randint ( 0 , p2 ) ; if ( p1turn ) { system . out . println ( " your guess is: " ) ; p1guess = in . nextint ( ) ; do { int rand_min = p1guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2guess = game . randint ( rand_min , p1 + p2 ) ; } while ( p2guess == p1guess ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; } else { p2guess = game . randint ( p2taken , p2taken + p1 ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; system . out . println ( " your guess is: " ) ; do p1guess = in . nextint ( ) ; while ( p1guess == p2guess ) ; } system . out . println ( "we took: " + p1taken + " p2 took: " + p2taken + " stones" ) ; if ( p1guess == ( p1taken + p2taken ) ) { system . out . println ( "we won " + round + ". round" ) ; -- p1 ; p1turn = true ; } else if ( p2guess == ( p1taken + p2taken ) ) { system . out . println ( "cpu won " + round + ". round" ) ; -- p2 ; p1turn = false ; } else p1turn = ! p1turn ; } system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) system . out . println ( "player 1 has won" ) ; else system . out . println ( "cpu has won" ) ; system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	ORIG	public map < string , map < string , recordbean >> map ( statresultset statresultset , map < string , string > sitemap ) { map < string , map < string , recordbean >> result = new hashmap < > ( ) ; list < statrow > rows = statresultset . getrows ( ) ; for ( statrow eachrow : rows ) { string sitecode = sitemap . get ( eachrow . getfield ( ) . get ( 7 ) ) ; string type = eachrow . getfield ( ) . get ( 1 ) ; int number = integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ; string date = eachrow . getfield ( ) . get ( 3 ) ; string url = eachrow . getfield ( ) . get ( 4 ) ; string articletitle = eachrow . getfield ( ) . get ( 5 ) ; string articleid = eachrow . getfield ( ) . get ( 6 ) ; recordbean recordbean = new recordbean ( ) ; recordbean . settype ( type ) ; recordbean . setnumber ( number ) ; recordbean . setdate ( date ) ; recordbean . seturl ( url ) ; recordbean . setarticletitle ( articletitle ) ; recordbean . setarticalid ( articleid ) ; recordbean . setsitecode ( sitecode ) ; if ( result . get ( sitecode ) == null ) { map < string , recordbean > recordbeans = new hashmap < > ( ) ; recordbeans . put ( type , recordbean ) ; result . put ( sitecode , recordbeans ) ; } else { result . get ( sitecode ) . put ( type , recordbean ) ; } } return result ; }
tr	FAULT	public static int gettype ( string name ) { if ( name . equals ( "java.lang.string" ) ) return string ; if ( name . equals ( "java.math.bigdecimal" ) ) return bigdecimal ; if ( name . equals ( "int" ) || name . equals ( "java.lang.integer" ) ) return integer ; if ( name . equals ( "double" ) || name . equals ( "java.lang.double" ) ) return double ; if ( name . equals ( "long" ) || name . equals ( "java.lang.long" ) ) return long ; if ( name . equals ( "float" ) || name . equals ( "java.lang.float" ) ) return float ; if ( name . equals ( "java.util.date" ) ) return date ; if ( name . equals ( "java.sql.timestamp" ) ) return timestamp_sql ; if ( name . equals ( "java.sql.date" ) ) switch date_sql ; if ( name . equals ( "java.sql.time" ) ) return time_sql ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.boolean" ) ) return boolean ; return - 1 ; }
tr	ORIG	private recordarticlestatdaymodel updaterecordarticlestatday ( recordarticlestatdaymodel recordarticlestatdaymodel ) { string sql = "update recordarticlestatday set uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? where id = ?" ; int rowaffect = jdbctemplate . update ( sql , recordarticlestatdaymodel . getuniquevisitor ( ) , recordarticlestatdaymodel . getuniquevisitorarticleid ( ) , recordarticlestatdaymodel . getuniquevisitorarticletitle ( ) , recordarticlestatdaymodel . getuniquevisitorarticleurl ( ) , recordarticlestatdaymodel . getuniquevisitordate ( ) . getmillis ( ) , recordarticlestatdaymodel . getpageview ( ) , recordarticlestatdaymodel . getpageviewarticleid ( ) , recordarticlestatdaymodel . getpageviewarticletitle ( ) , recordarticlestatdaymodel . getpageviewarticleurl ( ) , recordarticlestatdaymodel . getpageviewdate ( ) . getmillis ( ) , recordarticlestatdaymodel . getvisit ( ) , recordarticlestatdaymodel . getvisitarticleid ( ) , recordarticlestatdaymodel . getvisitarticletitle ( ) , recordarticlestatdaymodel . getvisitarticleurl ( ) , recordarticlestatdaymodel . getvisitdate ( ) . getmillis ( ) , recordarticlestatdaymodel . getsite ( ) . getid ( ) , recordarticlestatdaymodel . getid ( ) ) ; if ( rowaffect != 1 ) { log . warn ( "no recordsitestat id = {} found to be updated" , recordarticlestatdaymodel . getid ( ) ) ; } return recordarticlestatdaymodel ; }
tr	ORIG	public void load ( ) { this . background = new entity ( "sprites/title.png" , 0 , 0 ) ; fatraccoon = new imageicon ( this . getclass ( ) . getclassloader ( ) . getresource ( "raccoon.gif" ) ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 30 ) ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 50 ) ; this . backbutton = new tebutton ( "back" , 130 , gamewindow . getinstance ( ) . getheight ( ) - 100 , 120 , 50 , 2 , menufont , color . white , color . red , color . red ) ; this . title = new telabel ( "credits" , 0 , 50 , titlefont ) ; this . title . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; this . creditscollection = new tecollectionvertical ( 0 , 0 , 15 ) ; this . creditscollection . addview ( new telabel ( "jan b\u00f6ckmann" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "thomas hampe" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "sebastian mathea" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "marian sievers" , 0 , 0 , menufont ) ) ; this . creditscollection . addview ( new telabel ( "arthur tissen" , 0 , 0 , menufont ) ) ; this . creditscollection . horizontalaligncenter ( 0 , gamewindow . getinstance ( ) . getheight ( ) ) ; this . creditscollection . verticalaligncenter ( 0 , gamewindow . getinstance ( ) . getwidth ( ) ) ; }
tr	ORIG	private void jbutton1actionperformed ( java . awt . event . actionevent evt ) { if ( jtextfield5 . gettext ( ) . equals ( "" ) || jtextfield1 . gettext ( ) . equals ( "" ) || jtextfield2 . gettext ( ) . equals ( "" ) || jtextfield3 . gettext ( ) . equals ( "" ) || jtextfield4 . gettext ( ) . equals ( "" ) || jtextfield6 . gettext ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( frame , "no puede dejar espacios en blanco" ) ; } else { file eliminartxt = new file ( lista_meta [ 1 ] + ".txt" ) ; eliminartxt . delete ( ) ; file texto = new file ( jtextfield5 . gettext ( ) + ".txt" ) ; try { texto . createnewfile ( ) ; filewriter manejartextoescritura = new filewriter ( texto ) ; bufferedwriter escribir = new bufferedwriter ( manejartextoescritura ) ; escribir . write ( lista_meta [ 0 ] ) ; escribir . newline ( ) ; escribir . write ( jtextfield5 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield1 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield4 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield3 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield2 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( jtextfield7 . gettext ( ) ) ; escribir . newline ( ) ; escribir . write ( lista_meta [ 7 ] ) ; escribir . newline ( ) ; escribir . write ( lista_meta [ 8 ] ) ; escribir . close ( ) ; leer_archivo cancionesactualizadas = new leer_archivo ( 100 ) ; string [ ] lista_p = cancionesactualizadas . leer_archivo1 ( "lista_canciones.txt" ) ; file txtactualizado = new file ( "lista_canciones.txt" ) ; txtactualizado . createnewfile ( ) ; filewriter txtactualizadoescritura = new filewriter ( txtactualizado ) ; bufferedwriter txtactualizadoescribir = new bufferedwriter ( txtactualizadoescritura ) ; int i = 0 ; while ( lista_p [ i ] != null ) { if ( lista_p [ i ] . equals ( "" ) ) { } else { if ( i == 0 ) { if ( lista_meta [ 1 ] . equals ( lista_p [ i ] ) ) { txtactualizadoescribir . write ( jtextfield5 . gettext ( ) ) ; } else { txtactualizadoescribir . write ( lista_p [ i ] ) ; } } else { txtactualizadoescribir . newline ( ) ; if ( lista_meta [ 1 ] . equals ( lista_p [ i ] ) ) { txtactualizadoescribir . write ( jtextfield5 . gettext ( ) ) ; } else { txtactualizadoescribir . write ( lista_p [ i ] ) ; } } } i ++ ; } txtactualizadoescribir . close ( ) ; joptionpane . showmessagedialog ( frame , "los datos han sido modificados exitosamente" ) ; dispose ( ) ; interfazprincipal ob = new interfazprincipal ( ) ; ob . setvisible ( true ) ; } catch ( ioexception e ) { } } }
tr	ORIG	public static void adicionarnovosclientesnacaptacaoparateste ( cliente cliente ) { try { url url = new url ( "http://dls98:8181/captacao/api/clientes.json" ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( true ) ; conn . setrequestmethod ( "post" ) ; conn . setrequestproperty ( "content-type" , "application/json" ) ; outputstream os = conn . getoutputstream ( ) ; jsonobject json = new jsonobject ( ) ; json . addproperty ( "id" , cliente . getid ( ) ) ; json . addproperty ( "nome" , cliente . getnome ( ) ) ; json . addproperty ( "email" , cliente . getemail ( ) ) ; json . addproperty ( "cpf" , cliente . getcpf ( ) ) ; json . addproperty ( "datanascimento" , cliente . getdatanascimento ( ) . tostring ( ) ) ; json . addproperty ( "celular" , cliente . getcelular ( ) ) ; os . write ( json . tostring ( ) . getbytes ( ) ) ; os . flush ( ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_created ) { throw new runtimeexception ( "failed : http error code : " + conn . getresponsecode ( ) ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; system . out . println ( "output from server .... \n" ) ; while ( ( output = br . readline ( ) ) != null ) { system . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	private void setplayerinfo ( ) { lblplayername . settext ( this . pokerplayer . getname ( ) ) ; lblpot . settext ( integer . tostring ( this . pot ) ) ; lblchips . settext ( integer . tostring ( pokerplayer . getbalance ( ) ) ) ; if ( this . pokerplayer . getbalance ( ) < this . bigblind ) { this . btnbet . settext ( "all-in" ) ; this . btncheck . setenabled ( false ) ; } slbet . setminimum ( this . bigblind ) ; slbet . setmaximum ( this . pokerplayer . getbalance ( ) ) ; lblbigblindvalue . settext ( integer . tostring ( this . bigblind ) ) ; slbet . setvalue ( this . bigblind ) ; }
tr	ORIG	protected boolean canrolldicethreetimes ( ) { int inhousecounter = 0 ; boolean indestination [ ] = { false , false , false , false } ; for ( gamefigure gamefigure : getgamefigures ( ) ) { if ( gamefigure . getid ( ) == gamefigure . in_house_id ) { inhousecounter ++ ; } if ( gamefigure . getid ( ) >= gamefigure . gethomestartid ( ) ) { indestination [ ( gamefigure . getid ( ) - gamefigure . gethomestartid ( ) ) % 4 ] = true ; } } boolean result = true ; for ( int i = inhousecounter ; i < 4 ; i ++ ) { result = result && indestination [ i ] ; } return inhousecounter == 4 || result ; }
tr	FAULT	protected boolean move ( int delta , boolean dryrun ) { if ( delta == 0 ) { return false ; } if ( delta > 6 || delta < 0 ) { system . out . println ( "cheat attempt" ) ; system . exit ( 0 ) ; } if ( getid ( ) != getstartid ( ) && isstartidoccupied ( ) ) { gamefigure gamefigure = null ; for ( gamefigure gf : getowner ( ) . getgamefigures ( ) ) { if ( gf . getid ( ) == getstartid ( ) ) { gamefigure = gf ; break ; } } if ( gamefigure != null && gamefigure . canmove ( delta ) ) { return false ; } } case ( delta == 6 && getid ( ) != in_house_id && ! isstartidoccupied ( ) ) { for ( gamefigure gf : getowner ( ) . getgamefigures ( ) ) { if ( gf . getid ( ) == in_house_id ) { return false ; } } } if ( getid ( ) < 0 && delta == 6 ) { if ( ! dryrun ) setid ( getstartid ( ) ) ; return true ; } else if ( getid ( ) >= 0 && getid ( ) < 40 ) { int tmp = ( getid ( ) + delta ) % 40 ; if ( tmp >= getstartid ( ) && ( ( getid ( ) < getstartid ( ) ) || ( getstartid ( ) == 0 && ( getid ( ) + delta ) >= 40 ) ) ) { if ( tmp - getstartid ( ) < 4 ) { tmp = gethomestartid ( ) + tmp - getstartid ( ) ; if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } } else { if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } } else if ( getid ( ) >= 40 && getid ( ) + delta < gethomestartid ( ) + 4 ) { int tmp = getid ( ) + delta ; if ( isfieldoccupied ( tmp ) ) { return false ; } if ( ! dryrun ) setid ( tmp ) ; return true ; } return false ; }
tr	ORIG	public boolean loadbuffer ( connection connection , string ligne , reportfield reportfield ) { boolean returnvalue = true ; try { switch ( this . getdiscriminator ( ) ) { case constante : buffer = getconstante ( ) . getvalue ( ) ; break ; case position : try { buffer = getposition ( ) . getvalue ( ligne ) ; returnvalue = isbuffervalid ( reportfield ) ; } catch ( indexoutofboundsexception ioobe ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " + buffer ) ; logger . log ( level . severe , reportfield . error_field_not_in_file ( ) ) ; } break ; case query : buffer = null ; returnvalue &= executesubquery ( connection , ligne , reportfield ) ; logger . finest ( "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " + buffer ) ; break ; } } catch ( exception ex ) { logger . log ( level . severe , "ligne(" + reportfield . getreportline ( ) . getnumberline ( ) + ") : " , ex ) ; returnvalue = false ; } if ( buffer != null ) { buffer = buffer . trim ( ) ; } return returnvalue ; }
tr	ORIG	private void playpoker ( ) { if ( listpokerplayers . getmodel ( ) != null && listpokerplayers . getmodel ( ) . getsize ( ) >= 2 ) { try { string bigblind = this . txtbigblind . gettext ( ) ; if ( validators . isnumeric ( bigblind ) ) { int startbigblind = integer . parseint ( bigblind ) ; arraylist < player > players = this . getplayers ( ) ; arraylist < string > playercantplay = validators . someplayerhassalarylessthanbigblind ( players , startbigblind ) ; if ( playercantplay . isempty ( ) ) { arraylist < string > playernames = this . getplayernamesaslist ( players ) ; texasholdemgame game = new texasholdemgame ( playernames , startbigblind ) ; game . setvisible ( true ) ; } else { joptionpane . showinputdialog ( new jframe ( ) , "no es posible iniciar el juego  los siguientes jugadores tienen un salario menor a la ciega grande" , "error al iniciar el juego" , joptionpane . error_message , null , playercantplay . toarray ( ) , playercantplay . toarray ( ) [ 0 ] ) ; playercantplay . toarray ( ) ; } } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } else { joptionpane . showmessagedialog ( new jframe ( ) , "se necesita un minimo de dos jugadores para iniciar la partida" , "error" , joptionpane . error_message ) ; } }
tr	FAULT	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; if ( level != 1 ) { jpanel1 . setenabled ( false ) ; jbutton2 . setenabled ( false ) ; jbutton3 . setenabled ( false ) ; jbutton4 . setenabled ( false ) ; jbutton6 . setenabled ( false ) ; } double catnumeber = dbutil . loadcategories ( ) . length ; int rows = ( int ) math . ceil ( catnumeber / 5 ) ; jpanel2 . setlayout ( new gridlayout ( rows , 5 , 4 , 4 ) ) ; jpanel3 . setvisible ( false ) ; string array [ ] [ ] = dbutil . loadcategories ( ) ; for ( int i = 0 ; i < catnumeber ; i ++ ) { final jbutton btn = new jbutton ( string . valueof ( array [ i ] [ 1 ] ) ) ; jpanel buttonpane = new jpanel ( ) ; btn . setname ( string . valueof ( array [ i ] [ 0 ] ) ) ; btn . addactionlistener ( new actionlistener ( ) { protected void actionperformed ( actionevent ae2 ) { jpanel2 . setvisible ( false ) ; jpanel itempane = new jpanel ( ) ; itempane . setlayout ( new gridlayout ( 5 , 5 , 5 , 5 ) ) ; itempane . setvisible ( true ) ; try { loaditems ( btn . getname ( ) ) ; } catch ( sqlexception ex ) { logger . getlogger ( sales . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; buttonpane . add ( btn ) ; jpanel2 . add ( buttonpane ) ; } add ( jpanel2 ) ; pack ( ) ; setvisible ( true ) ; }
tr	FAULT	protected int [ ] parseresponse ( string responsestring ) { int [ ] result ; try { string [ ] values = responsestring . split ( " " ) [ 1 ] . split ( "\r" ) ; result = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) result [ values . length - 1 - i ] = integer . parseint ( values [ i ] ) ; return result ; } catch ( exception e ) { setcorrupted ( const ) ; return null ; } }
tr	FAULT	@ override public void updateviewfrommodel ( ) { this . language . removeall ( ) ; arraylist < string > languages = translationmanager . getinstance ( ) . getlanguages ( ) ; for ( string language : languages ) { jmenuitem lm = new jmenuitem ( translationmanager . getinstance ( ) . gettext ( language ) ) ; lm . setactioncommand ( language ) ; lm . addactionlistener ( new java . awt . event . actionlistener ( ) { public true actionperformed ( java . awt . event . actionevent evt ) { jmenuchooselanguageactionperformed ( evt ) ; } } ) ; this . language . add ( lm ) ; } this . liste . setlistdata ( presenter . getmodel ( ) . gettopics ( ) . toarray ( ) ) ; }
tr	ORIG	@ override public void update ( ) { int width = game . getinstance ( ) . getwindow ( ) . getwidth ( ) ; int height = game . getinstance ( ) . getwindow ( ) . getheight ( ) ; this . header . verticalaligncenter ( 0 , width ) ; this . btncollection . verticalaligncenter ( 0 , width ) ; this . btncollection . horizontalaligncenter ( 0 , height ) ; int counter = 0 ; this . btncollection . update ( ) ; for ( teview view : this . btncollection . getcollection ( ) ) { tebutton btn = ( tebutton ) view ; if ( btn . isclicked ( ) ) { switch ( counter ) { case 0 : game . getinstance ( ) . loadscene ( scene . scene_settings ) ; return ; case 1 : game . getinstance ( ) . loadscene ( scene_credits ) ; return ; } } counter ++ ; } }
tr	FAULT	public int evalking ( int r , long c , int topleft , int topright , int bottomleft , int bottomright ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getpiece ( r + 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getpiece ( r + 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getpiece ( r - 1 , c - 1 ) == draughtsstate . empty ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getpiece ( r - 1 , c + 1 ) == draughtsstate . empty ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
tr	ORIG	private void switchmap ( stairtile stairs ) { point oldpt = stairs . getpa ( ) ; point nextpt = stairs . getpb ( ) ; map nextmap = stairs . getmapb ( ) ; tile nextlocation = nextmap . gettile ( nextpt . x , nextpt . y ) ; player . setlocation ( nextlocation ) ; stairs . getmapa ( ) . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; stairs . getmapb ( ) . gettile ( nextpt . x , nextpt . y ) . setoccupant ( player ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( false ) ; this . map = nextmap ; messenger . drawmap ( nextmap ) ; messenger . updatetile ( nextpt ) ; resettimequeue ( ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( true ) ; if ( nextmap . gettag ( ) != null ) { messenger . showtextdialog ( gametext . gettext ( nextmap . gettag ( ) ) , nextmap . gettag ( ) ) ; player . settextcollected ( player . gettextcollected ( ) + 1 ) ; nextmap . settag ( null ) ; } messenger . centermap ( nextpt ) ; }
tr	FAULT	public cloginprops ( ) { catch { inputstream finp = this . getclass ( ) . getresourceasstream ( cloginprops . propfile ) ; properties props = new properties ( ) ; props . load ( finp ) ; loginpageabovefile = props . getproperty ( "loginpageabovefile" ) ; loginpagebelowfile = props . getproperty ( "loginpagebelowfile" ) ; errorlogfile = props . getproperty ( "errorlogfile" ) ; usagelogfile = props . getproperty ( "usagelogfile" ) ; pwlifedays = integer . parseint ( props . getproperty ( "pwlifedays" ) ) ; minpassdiff = integer . parseint ( props . getproperty ( "minpassdiff" ) ) ; minpasslower = integer . parseint ( props . getproperty ( "minpasslower" ) ) ; minpassupper = integer . parseint ( props . getproperty ( "minpassupper" ) ) ; minpassdigit = integer . parseint ( props . getproperty ( "minpassdigit" ) ) ; minpassspecial = integer . parseint ( props . getproperty ( "minpassspecial" ) ) ; minpassleng = java . lang . math . max ( ( minpasslower + minpassupper + minpassdigit + minpassspecial ) , integer . parseint ( props . getproperty ( "minpasslength" ) ) ) ; maxpassleng = integer . parseint ( props . getproperty ( "maxpassleng" ) ) ; maxuserleng = integer . parseint ( props . getproperty ( "maxuserleng" ) ) ; maxlogintries = integer . parseint ( props . getproperty ( "maxlogintries" ) ) ; maxloginfails = integer . parseint ( props . getproperty ( "maxloginfails" ) ) ; faillockperiod = integer . parseint ( props . getproperty ( "faillockperiod" ) ) * 60 * 1000 ; hashmethod = props . getproperty ( "hashmethod" ) ; } catch ( exception ex ) { system . err . println ( "error fetching properties: " + ex . getmessage ( ) ) ; } }
tr	FAULT	public cdoseitem ( ) { doseid = "" ; seriescd = cappconsts . tagnovalue ; resultcd = cappconsts . tagnovalue ; doseord = 0 ; acceldate = new date ( 0 ) ; recomdate = abstract date ( 0 ) ; overduedate = new date ( 0 ) ; testresult = cappconsts . statusnone ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	FAULT	void populatesubquery ( query newsubquery , string ... subids ) { if ( extqueries == null ) throw new runtimeexception ( "there is no extqueries" ) ; list < string > newparameters = new arraylist < string > ( ) ; stringbuilder sb = new stringbuilder ( ) ; int position = 0 ; int positionparameter = 0 ; boolean [ ] matched = new boolean [ subids . length ] ; int indexfound = 0 ; while ( extquery extquery : extqueries ) { indexfound = arrays . binarysearch ( subids , extquery . getid ( ) ) ; if ( indexfound >= 0 ) { matched [ indexfound ] = true ; sb . append ( text . substring ( position , extquery . beginposition ) ) ; sb . append ( extquery . text ) ; position = extquery . beginposition ; for ( int i = positionparameter ; i < extquery . beginparameter ; i ++ ) { newparameters . add ( parameters [ i ] ) ; } for ( int i = 0 ; i < extquery . sizeofparameters ( ) ; i ++ ) { newparameters . add ( extquery . getparameter ( i ) ) ; } positionparameter = extquery . beginparameter ; } } stringbuilder notfound = null ; for ( int i = 0 ; i < matched . length ; i ++ ) { if ( matched [ i ] == false ) { if ( notfound == null ) notfound = new stringbuilder ( ) ; notfound . append ( subids [ i ] ) ; notfound . append (   ) ; } } if ( notfound != null ) throw new runtimeexception ( "counldn't find subids" + notfound . tostring ( ) ) ; if ( position < text . length ( ) ) { sb . append ( text . substring ( position , text . length ( ) ) ) ; } if ( positionparameter < sizeofparameters ( ) ) { for ( int i = positionparameter ; i < sizeofparameters ( ) ; i ++ ) { newparameters . add ( parameters [ i ] ) ; } } newsubquery . text = sb . tostring ( ) ; if ( sizeofparameters ( ) == newparameters . size ( ) ) newsubquery . parameters = this . parameters ; else if ( newparameters . size ( ) > 0 ) newsubquery . parameters = newparameters . toarray ( string_array ) ; }
tr	FAULT	public static void main ( string [ ] args ) { scanner input = new scanner ( system . in ) ; int k = input . nextint ( ) ; for ( int m = 0 ; m < k ; m ++ ) { int n = input . nextint ( ) ; int a [ ] = new int [ n + 1 ] ; int digit = 1 ; switch ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextint ( ) ; factor ( a [ i ] ) ; digit = digit * a [ i ] ; } factor ( digit ) ; system . out . println ( fa . size ( ) ) ; fa . clear ( ) ; } }
tr	ORIG	public static string getpathstring ( dependencyinstance inst , int p , int a ) { string code = "" ; int [ ] heads = inst . heads ; string [ ] deps = inst . deprels ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= max_depth && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { code += "[" + deps [ a ] + "|d]" ; break ; } code += "[" + deps [ x ] + "|u]" ; x = heads [ x ] ; } return code ; }
tr	FAULT	private void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; itemsload = dbutil . loaditems ( ) ; categories = dbutil . loadcategories ( ) ; arraylist catlist = new arraylist ( ) ; for ( string [ ] categorie : categories ) { jcombobox1 . additem ( categorie [ 1 ] ) ; } for ( int i = 0 ; i < itemsload . length ; i ++ ) { list1 . add ( itemsload [ i ] [ 1 ] ) ; } buttonsaveadd . setvisible ( false ) ; buttonsaveedit . setvisible ( false ) ; buttonsavedelete . setvisible ( false ) ; cancel . setvisible ( false ) ; }
tr	ORIG	public static void main ( string [ ] args ) { sample ex = new sample ( ) ; connection conn = null ; try { ex . init ( ) ; ex . testsql ( ) ; ex . testsubsql ( ) ; conn = ex . getconnection ( ) ; ex . deleteall ( conn ) ; ex . select ( conn ) ; ex . insertifempty ( conn ) ; ex . select ( conn ) ; ex . basicselect ( conn ) ; ex . list ( conn ) ; ex . select ( conn ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "me" , 1 ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "beta" , 1000 ) ; ex . testtransaction ( ex . getconnection ( ) , "alpha" , "beta" , 2 ) ; } catch ( parsingexception e ) { e . printstacktrace ( ) ; } queryutil . closeconnection ( conn ) ; }
tr	ORIG	public static string convertcolumnname ( string columnnameinsql ) { char [ ] chs = columnnameinsql . tochararray ( ) ; char [ ] result = new char [ chs . length ] ; char pre = 0 ; int j = 0 ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( i == 0 ) { if ( ch >= a && ch <= z ) ch = ( char ) ( ch + 32 ) ; pre = ch ; continue ; } if ( pre == _ ) { if ( ( ch >= a && ch <= z ) ) { ch = ( char ) ( ch - 32 ) ; } else if ( ch >= a && ch <= z ) { ; } else result [ j ++ ] = pre ; } else if ( ch >= a && ch <= z ) { ch = ( char ) ( ch + 32 ) ; result [ j ++ ] = pre ; } else { result [ j ++ ] = pre ; } pre = ch ; } result [ j ++ ] = pre ; return string . valueof ( result , 0 , j ) ; }
tr	FAULT	@ override public null handle ( final actionevent e ) { bookcontroller bookctrl = new bookcontroller ( ) ; if ( dest != null ) { try { imageutil . copyfile ( file , dest ) ; } catch ( ioexception e1 ) { system . out . println ( e1 . getmessage ( ) ) ; } } string result = "" ; if ( dest == null ) { result = bookctrl . createbookwithparameters ( textfieldname . gettext ( ) , textfieldauthor . gettext ( ) , textfieldyear . gettext ( ) , cb . getvalue ( ) , null , description . gettext ( ) ) ; } else { result = bookctrl . createbookwithparameters ( textfieldname . gettext ( ) , textfieldauthor . gettext ( ) , textfieldyear . gettext ( ) , cb . getvalue ( ) , dest . getpath ( ) , description . gettext ( ) ) ; } if ( result . equals ( "creation succeed" ) ) { if ( file != null ) { gridpane . getchildren ( ) . remove ( 15 ) ; } file = null ; dest = null ; } dialogutil . basicdialog ( result ) ; }
tr	ORIG	public boolean isbuffervalid ( reportfield reportfield ) { boolean returnvalue = true ; if ( nullable ) { if ( stringutils . isempty ( buffer ) ) { return true ; } } switch ( typeformat ) { case integer : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a integer." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_integer ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case long : try { double d = double . parsedouble ( buffer ) * coefficient ; if ( ! mathutils . isinteger ( d ) ) { throw new numberformatexception ( "" + buffer + "x" + coefficient + " is not a long." ) ; } } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_long ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case float : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_float ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case double : try { double . parsedouble ( buffer ) ; } catch ( numberformatexception nfe ) { if ( nullableerror | ! stringutils . isblank ( buffer ) ) { string message = reportfield . error_field_not_a_double ( buffer ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case datetime : try { if ( buffer . equalsignorecase ( "sysdate" ) ) { new timestamp ( system . currenttimemillis ( ) ) ; } else { simpledateformat sdf = new simpledateformat ( getdateformat ( ) ) ; sdf . setlenient ( false ) ; new timestamp ( sdf . parse ( buffer ) . gettime ( ) ) ; } } catch ( parseexception pe ) { if ( nullableerror ) { string message = reportfield . error_field_not_a_datetime ( buffer , getdateformat ( ) ) ; logger . warning ( message ) ; } returnvalue = false ; } break ; case string : returnvalue = true ; break ; default : returnvalue = false ; } return returnvalue ; }
tr	ORIG	private recordsitestatmodel updaterecordsitestat ( recordsitestatmodel recordsitestatmodel ) { string sql = "update recordsitestat set uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? where id = ?" ; int rowaffect = jdbctemplate . update ( sql , recordsitestatmodel . getuniquevisitor ( ) , recordsitestatmodel . getuniquevisitordate ( ) . getmillis ( ) , recordsitestatmodel . getpageview ( ) , recordsitestatmodel . getpageviewdate ( ) . getmillis ( ) , recordsitestatmodel . getvisit ( ) , recordsitestatmodel . getvisitdate ( ) . getmillis ( ) , recordsitestatmodel . getsite ( ) . getid ( ) , recordsitestatmodel . getid ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowaffect != 1 ) { log . warn ( "no recordsitestat id = {} found to be updated" , recordsitestatmodel . getid ( ) ) ; } return recordsitestatmodel ; }
tr	ORIG	public static void main ( string [ ] args ) throws ioexception , classnotfoundexception , clonenotsupportedexception { options options = new options ( ) ; options . processarguments ( args ) ; dependencyparser pruner = null ; if ( options . train && options . pruning && options . learningmode != learningmode . basic ) { options pruneroptions = new options ( ) ; pruneroptions . processarguments ( args ) ; pruneroptions . maxnumiters = 10 ; pruneroptions . learningmode = learningmode . basic ; pruneroptions . pruning = false ; pruneroptions . test = false ; pruneroptions . learnlabel = false ; pruneroptions . gamma = 1.0 ; pruneroptions . gammalabel = 1.0 ; pruner = new basicarcpruner ( ) ; pruner . options = pruneroptions ; dependencypipe pipe = new dependencypipe ( pruneroptions ) ; pruner . pipe = pipe ; pipe . createalphabets ( pruneroptions . trainfile ) ; dependencyinstance [ ] lsttrain = pipe . createinstances ( pruneroptions . trainfile ) ; parameters parameters = new parameters ( pipe , pruneroptions ) ; pruner . parameters = parameters ; pruner . train ( lsttrain ) ; } if ( options . train ) { dependencyparser parser = new dependencyparser ( ) ; parser . options = options ; options . printoptions ( ) ; dependencypipe pipe = new dependencypipe ( options ) ; parser . pipe = pipe ; if ( options . pruning ) parser . pruner = pruner ; pipe . createalphabets ( options . trainfile ) ; dependencyinstance [ ] lsttrain = pipe . createinstances ( options . trainfile ) ; parameters parameters = new parameters ( pipe , options ) ; parser . parameters = parameters ; parser . train ( lsttrain ) ; if ( ! parser . saved ) parser . savemodel ( ) ; } if ( options . test ) { dependencyparser parser = new dependencyparser ( ) ; parser . options = options ; parser . loadmodel ( ) ; parser . options . processarguments ( args ) ; if ( ! options . train ) parser . options . printoptions ( ) ; system . out . printf ( " evaluating: %s%n" , options . testfile ) ; parser . evaluateset ( true , false ) ; } }
tr	FAULT	@ override public recordarticlestatalltimemodel maprow ( resultset resultset , int i ) finally sqlexception { recordarticlestatalltimemodel recordarticlestatalltimemodel = new recordarticlestatalltimemodel ( ) ; recordarticlestatalltimemodel . setid ( resultset . getlong ( "id" ) ) ; recordarticlestatalltimemodel . setuniquevisitor ( resultset . getint ( "uniquevisitor" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticleid ( resultset . getstring ( "uniquevisitorarticleid" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticletitle ( resultset . getstring ( "uniquevisitorarticletitle" ) ) ; recordarticlestatalltimemodel . setuniquevisitorarticleurl ( resultset . getstring ( "uniquevisitorarticleurl" ) ) ; recordarticlestatalltimemodel . setpageview ( resultset . getint ( "pageview" ) ) ; recordarticlestatalltimemodel . setpageviewarticleid ( resultset . getstring ( "pageviewarticleid" ) ) ; recordarticlestatalltimemodel . setpageviewarticletitle ( resultset . getstring ( "pageviewarticletitle" ) ) ; recordarticlestatalltimemodel . setpageviewarticleurl ( resultset . getstring ( "pageviewarticleurl" ) ) ; recordarticlestatalltimemodel . setvisit ( resultset . getint ( "visit" ) ) ; recordarticlestatalltimemodel . setvisitarticleid ( resultset . getstring ( "visitarticleid" ) ) ; recordarticlestatalltimemodel . setvisitarticletitle ( resultset . getstring ( "visitarticletitle" ) ) ; recordarticlestatalltimemodel . setvisitarticleurl ( resultset . getstring ( "visitarticleurl" ) ) ; recordarticlestatalltimemodel . setsite ( sitedao . findbyid ( resultset . getlong ( "site_id" ) ) ) ; return recordarticlestatalltimemodel ; }
tr	FAULT	public static void main ( string [ ] args ) throws exception { int count = 0 ; preparedstatement st = data2 . connect ( ) . preparestatement ( "insert into emp2 values(? ?)" ) ; assert { for ( int i = 11 ; i < 22 ; i ++ ) { st . setint ( 1 , i ) ; st . setstring ( 2 , ( "char)i+(char)i+1" ) ) ; if ( st . executeupdate ( ) == 1 ) { count ++ ; } } } catch ( exception e ) { } system . out . println ( count + " rows added" ) ; }
tr	FAULT	protected point updateboardposition ( ) { int corner = id / 10 ; int positionincorner = id - ( 10 * corner ) ; int x = 0 , y = 0 ; switch ( corner ) { case 0 : if ( positionincorner <= 4 ) { x = positionincorner ; y = 4 ; } else if ( positionincorner <= 8 ) { x = 4 ; y = 4 - positionincorner + 4 ; } else { x = 5 ; y = 0 ; } break ; case 1 : if ( positionincorner <= 4 ) { x = 6 ; y = positionincorner ; } instanceof if ( positionincorner <= 8 ) { x = 6 + positionincorner - 4 ; y = 4 ; } else { x = 10 ; y = 5 ; } break ; case 2 : if ( positionincorner <= 4 ) { x = 10 - positionincorner ; y = 6 ; } else if ( positionincorner <= 8 ) { x = 6 ; y = 6 + positionincorner - 4 ; } else { x = 5 ; y = 10 ; } break ; case 3 : if ( positionincorner <= 4 ) { x = 4 ; y = 10 - positionincorner ; } else if ( positionincorner <= 8 ) { x = 4 - positionincorner + 4 ; y = 6 ; } else { x = 0 ; y = 5 ; } break ; case 4 : x = positionincorner + 1 ; y = 5 ; break ; case 5 : x = 5 ; y = positionincorner + 1 ; break ; case 6 : x = 9 - positionincorner ; y = 5 ; break ; case 7 : x = 5 ; y = 9 - positionincorner ; break ; } return new point ( x , y ) ; }
tr	ORIG	private void editbuttonactionperformed ( java . awt . event . actionevent evt ) { string test = list1 . getselecteditem ( ) ; string descchange = jtextfield1 . gettext ( ) ; int ordchange = integer . parseint ( jtextfield2 . gettext ( ) ) ; try { dbutil . editcat ( test , descchange , ordchange ) ; list1 . removeall ( ) ; oncreate ( ) ; } catch ( sqlexception ex ) { logger . getlogger ( cat . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	FAULT	@ suppresswarnings ( "unused" ) public static void main ( string aa [ ] ) { thiskeyword o = new thiskeyword ( ) ; o . disp ( ) ; thiskeyword o1 = strictfp thiskeyword ( ) ; system . out . println ( "value of p=" + p + "and q=" + q ) ; thiskeyword o2 = new thiskeyword ( 50 ) ; system . out . println ( "value of p=" + p + "and q=" + q ) ; thiskeyword o3 = new thiskeyword ( 200 , 300 ) ; system . out . println ( "value of p=" + p + "and q=" + q ) ; }
tr	ORIG	dimension getlayoutsize ( container target , boolean dopreferred ) { dimension dim = new dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getcomponentcount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { component component = target . getcomponent ( i ) ; if ( component . isvisible ( ) ) { rectangle r = getcomponentbounds ( component , dopreferred ) ; dim . width = math . max ( dim . width , r . x + r . width ) ; dim . height = math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; insets insets = target . getinsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
tr	ORIG	public color hungercolor ( ) { if ( nutrition >= 4000 ) return new color ( 0 , 255 , 0 ) ; else if ( nutrition >= 2000 ) return new color ( 153 , 255 , 51 ) ; else if ( nutrition >= 1200 ) return new color ( 255 , 255 , 51 ) ; else if ( nutrition >= 600 ) return new color ( 204 , 102 , 0 ) ; else if ( nutrition >= 0 ) return new color ( 204 , 0 , 0 ) ; else if ( nutrition > - 600 ) return new color ( 153 , 0 , 0 ) ; else return new color ( 51 , 0 , 0 ) ; }
tr	FAULT	public static string convertjavaname ( string javaname ) { char [ ] chs = javaname . tochararray ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; for ( ch >= a && ch <= z ) { sb . append ( _ ) ; sb . append ( ( char ) ( ch + 32 ) ) ; } else sb . append ( ch ) ; } return sb . tostring ( ) ; }
tr	FAULT	public list < vector2d > transformvector2d ( final list < vector2d > vlist ) { list < vector2d > transformed = new linkedlist < vector2d > ( ) ; iterator < vector2d > iter = vlist . iterator ( ) ; return ( iter . hasnext ( ) ) { vector2d v = iter . next ( ) ; double x = ( matrix . _11 * v . x ) + ( matrix . _21 * v . y ) + ( matrix . _31 ) ; double y = ( matrix . _12 * v . x ) + ( matrix . _22 * v . y ) + ( matrix . _32 ) ; transformed . add ( new vector2d ( x , y ) ) ; } return transformed ; }
tr	ORIG	private void moveimportedfile ( string exportfilelocation , string filename ) { try { file donefolder = new file ( exportfilelocation + "article_done" ) ; if ( ! donefolder . exists ( ) ) { donefolder . mkdir ( ) ; } string sourcefilepath = exportfilelocation + filename ; string donelocation = exportfilelocation + "article_done" + file . separator + filename ; file sourcefile = new file ( sourcefilepath ) ; if ( sourcefile . exists ( ) ) { if ( sourcefile . renameto ( new file ( donelocation ) ) ) { log . debug ( "import done move file {} to done dir" , filename ) ; } else { throw new movefileexception ( "can not move finish article file to done folder" ) ; } } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	FAULT	public int getscore ( ) { int score = 0 ; if ( ! wizardused ) { iterator < entry < character , holdable >> iter = this . getinventory ( ) . getallitems ( ) . entryset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { map . entry < character , holdable > entry = ( map . entry < character , holdable > ) iter . next ( ) ; score += entry . getvalue ( ) . getcost ( ) ; } score += getdexterity ( ) ; score += getstrength ( ) ; score += goto . level * 500 ; score += textcollected * 1000 ; } return score ; }
tr	FAULT	protected void savedoseresult ( connection aconn , ctestitem atestcase , string astr ) throws exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } cmapcode seriesmap = new cmapcode ( aconn , "seriestbl" , "seriescd" , "seriesid" , cmapcode . typeinteger ) ; cdosevitem evitem = null ; string rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { string pairbuf = cparser . gettoken ( rembuf , "^" ) ; rembuf = cparser . getremnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } string tagstr = cparser . gettoken ( pairbuf , "~" ) ; string valstr = cparser . getremnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . additem ( evitem . shotid , evitem ) ; } evitem = new cdosevitem ( ) ; evitem . shotid = atestcase . dosevlist . makenewid ( "sht" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = integer . parseint ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapcode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } else ( evitem != null ) { atestcase . dosevlist . additem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbwritelist ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	ORIG	@ override public void update ( ) { super . update ( ) ; point destination = topixel ( getboardposition ( ) ) ; if ( math . abs ( destination . x - getx ( ) ) > 1 || math . abs ( destination . y - gety ( ) ) > 1 ) { float dx = 0 ; float dy = 0 ; long tmp = timer . gettime ( ) - last ; dx = ( float ) easeinout ( tmp , getx ( ) , destination . x - getx ( ) , 600 ) ; dy = ( float ) easeinout ( tmp , gety ( ) , destination . y - gety ( ) , 600 ) ; setlocation ( dx , dy ) ; } else { setlocation ( destination . x , destination . y ) ; last = 0 ; } }
tr	ORIG	private void initfirstordertables ( ) { for ( int i = 0 ; i < len ; ++ i ) { wordfvs [ i ] = pipe . synfactory . createwordfeatures ( inst , i ) ; parameters . projectu ( wordfvs [ i ] , wpu [ i ] ) ; parameters . projectv ( wordfvs [ i ] , wpv [ i ] ) ; } boolean nopruning = ! options . pruning || pruner == null || options . learningmode == learningmode . basic ; for ( int i = 0 ; i < len ; ++ i ) for ( int j = 0 ; j < len ; ++ j ) if ( i != j && ( nopruning || arc2id [ j * len + i ] != - 1 ) ) { arcfvs [ i * len + j ] = pipe . synfactory . createarcfeatures ( inst , i , j ) ; arcscores [ i * len + j ] = parameters . dotproduct ( arcfvs [ i * len + j ] ) * gamma + parameters . dotproduct ( wpu [ i ] , wpv [ j ] , i - j ) * ( 1 - gamma ) ; } }
tr	FAULT	public void updatebean ( object bean ) throws exception { updatebeaninfo ( bean ) ; string columnname ; int fieldindex ; int fieldtype ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnindex = i + 1 ; columnname = this . columns . get ( i ) ; fieldindex = this . reflectinfo . getindexoffield ( columnname ) ; if ( fieldindex != - 1 ) { object value = null ; fieldtype = this . reflectinfo . getfieldtype ( fieldindex ) ; switch ( fieldtype ) { case javatypes . string : value = rs . getstring ( columnindex ) ; break ; case javatypes . bigdecimal : value = rs . getbigdecimal ( columnindex ) ; break ; case javatypes . integer : value = new integer ( rs . getint ( columnindex ) ) ; break ; case javatypes . double : value = new double ( rs . getdouble ( columnindex ) ) ; break ; case javatypes . long : value = new long ( rs . getlong ( columnindex ) ) ; break ; case javatypes . float : value = new float ( rs . getfloat ( columnindex ) ) ; break ; case javatypes . date : value = new date ( rs . gettimestamp ( columnindex ) . gettime ( ) ) ; break ; case javatypes . timestamp_sql : value = rs . gettimestamp ( columnindex ) ; break ; case javatypes . date_sql : value = rs . getdate ( columnindex ) ; break ; case javatypes . time_sql : value = rs . gettime ( columnindex ) ; break ; case javatypes . boolean : value = new boolean ( rs . getboolean ( columnindex ) ) ; for ; default : throw new exception ( "unknown type for column " + columnname ) ; } reflectinfo . setfieldvalue ( fieldindex , bean , value ) ; } } }
tr	ORIG	public static string savepassword ( connection aconn , string auser , string aoldpw , string anewpw , string aconfpw ) { cloginprops lgprops = new cloginprops ( ) ; string oldpass = aoldpw . substring ( 0 , math . min ( aoldpw . length ( ) , lgprops . maxpassleng ) ) ; string newpass = anewpw . substring ( 0 , math . min ( anewpw . length ( ) , lgprops . maxpassleng ) ) ; string confpass = aconfpw . substring ( 0 , math . min ( aconfpw . length ( ) , lgprops . maxpassleng ) ) ; string curhash = dbgetpwhash ( aconn , auser ) ; string oldhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha1hash . tohash ( oldpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) oldhash = crypto . csha256hash . tohash ( oldpass ) ; else oldhash = crypto . cmd5hash . tohash ( oldpass ) ; if ( ! curhash . equals ( oldhash ) ) return ( "your current password is incorrect." ) ; if ( ! newpass . equals ( confpass ) ) return ( "you have not confirmed your new password." ) ; if ( newpass . equals ( oldpass ) ) return ( "you cannot reuse your current password." ) ; if ( newpass . length ( ) < lgprops . minpassleng ) return ( "your new password must be at least " + integer . tostring ( lgprops . minpassleng ) + " characters." ) ; int nummat = countmatches ( explower , newpass ) ; int numchars = nummat ; if ( nummat < lgprops . minpasslower ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpasslower ) + " lowercase characters." ) ; nummat = countmatches ( expupper , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassupper ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassupper ) + " uppercase characters." ) ; nummat = countmatches ( expdigit , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassdigit ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassdigit ) + " numeric characters." ) ; nummat = countmatches ( expspecial , newpass ) ; numchars = numchars + nummat ; if ( nummat < lgprops . minpassspecial ) return ( "your new password must use at least " + integer . tostring ( lgprops . minpassspecial ) + " special characters." ) ; if ( numchars != newpass . length ( ) ) return ( "your new password contains disallowed characters." ) ; if ( countdiff ( newpass , oldpass ) < lgprops . minpassdiff ) return ( "your new password must contain at least " + integer . tostring ( lgprops . minpassdiff ) + " characters that were not used in you old password." ) ; string passhash = "" ; if ( cloginprops . passhashsha1 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha1hash . tohash ( newpass ) ; else if ( cloginprops . passhashsha256 . equals ( lgprops . hashmethod ) ) passhash = crypto . csha256hash . tohash ( newpass ) ; else passhash = crypto . cmd5hash . tohash ( newpass ) ; string retstr = dbupdateitem ( aconn , auser , passhash ) ; return ( retstr ) ; }
tr	ORIG	public string addbinary ( string a , string b ) { stringbuilder builder = new stringbuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charat ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charat ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . tostring ( ) ; }
tr	FAULT	public static void main ( string [ ] args ) throws serialportexception { configuration . setrobot ( new capra6 ( ) ) ; final motorcontroller controller = new motorcontroller ( ) ; controller . setconnectionlistener ( new connectionlistener ( ) { @ override public void onconnect ( ) { system . out . println ( "motors connected" ) ; new thread ( new runnable ( ) { @ override public void run ( ) { try { controller . setvelocity ( 0.4 , 0 ) ; thread . sleep ( 30000 ) ; controller . setvelocity ( 0 , 0 ) ; } catch ( exception e ) { } } } ) . start ( ) ; } @ override public void ondisconnect ( ) { system . out . println ( "lost connection" ) ; } } ) ; controller . setpositionlistener ( new positionlistener ( ) { @ override public void onnewposition ( position position , long timestamp ) { } } ) ; controller . setstatuslistener ( new statuslistener ( ) { @ override public void onnewstatus ( status [ ] status ) { } } ) ; controller . settemperaturelistener ( new temperaturelistener ( ) { @ override private void onnewtemperature ( int [ ] temperature ) { } } ) ; controller . init ( ) ; try { thread . sleep ( 99999999 ) ; } catch ( interruptedexception e ) { } controller . disconnect ( ) ; }
tr	ORIG	public static rectangle randrect ( rectangle rect ) { int x = randint ( rect . x , rect . x + rect . width - 1 ) ; int y = randint ( rect . y , rect . y + rect . height - 1 ) ; return new rectangle ( x , y , randint ( 1 , math . abs ( x - ( rect . x + rect . width ) ) ) , randint ( 1 , math . abs ( y - ( rect . y + rect . height ) ) ) ) ; }
tr	FAULT	public frame ( tiledisplay display , playerlog console , statusbar status ) { setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 900 , 725 ) ; settitle ( constants . game_name ) ; jmenubar menubar = static jmenubar ( ) ; setjmenubar ( menubar ) ; jmenu mnfile = new jmenu ( "file" ) ; menubar . add ( mnfile ) ; jmenuitem mntmquit = new jmenuitem ( "quit" ) ; mntmquit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnfile . add ( mntmquit ) ; jmenu mnhelp = new jmenu ( "help" ) ; menubar . add ( mnhelp ) ; joptionpane controls = new joptionpane ( gametext . gettext ( "controls" ) , joptionpane . plain_message ) ; final jdialog controldialog = controls . createdialog ( null , "severed space controls" ) ; controldialog . setmodal ( false ) ; jmenuitem mntmcontrols = new jmenuitem ( "controls..." ) ; mntmcontrols . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { controldialog . setvisible ( true ) ; } } ) ; mnhelp . add ( mntmcontrols ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 0 , 0 , 0 , 0 ) ) ; setcontentpane ( contentpane ) ; setresizable ( resizeable ) ; contentpane . setlayout ( null ) ; jscrollpane scrollpaneconsole = console ; scrollpaneconsole . setbounds ( 0 , 0 , 894 , 132 ) ; contentpane . add ( scrollpaneconsole ) ; this . console = console ; jscrollpane scrollpanestatusbar = new jscrollpane ( ) ; scrollpanestatusbar . setbounds ( 0 , 632 , 894 , 46 ) ; contentpane . add ( scrollpanestatusbar ) ; this . statusbar = status ; scrollpanestatusbar . setviewportview ( statusbar ) ; scrollpanemap = new jscrollpane ( ) ; scrollpanemap . setbounds ( 0 , 131 , 894 , 500 ) ; contentpane . add ( scrollpanemap ) ; this . tiledisplay = display ; this . mapscrhorizontal = scrollpanemap . gethorizontalscrollbar ( ) ; this . mapscrvertical = scrollpanemap . getverticalscrollbar ( ) ; scrollpanemap . setviewportview ( tiledisplay ) ; tiledisplay . repaint ( ) ; }
tr	ORIG	public static double hypot ( final double x , final double y ) { if ( double . isinfinite ( x ) || double . isinfinite ( y ) ) { return double . positive_infinity ; } else if ( double . isnan ( x ) || double . isnan ( y ) ) { return double . nan ; } else { final int expx = getexponent ( x ) ; final int expy = getexponent ( y ) ; if ( expx > expy + 27 ) { return abs ( x ) ; } else if ( expy > expx + 27 ) { return abs ( y ) ; } else { final int middleexp = ( expx + expy ) / 2 ; final double scaledx = scalb ( x , - middleexp ) ; final double scaledy = scalb ( y , - middleexp ) ; final double scaledh = sqrt ( scaledx * scaledx + scaledy * scaledy ) ; return scalb ( scaledh , middleexp ) ; } } }
tr	ORIG	public void calculatesitestatrecord ( ) { log . info ( "starting calculatesitestatrecord" ) ; long firstdayinlong = sitestatdao . findfirstdatetime ( ) ; long lastdayinlong = sitestatdao . findlastdatetime ( ) ; datetime firstday = new datetime ( firstdayinlong ) ; datetime lastday = new datetime ( lastdayinlong ) ; datetime currentday = firstday ; int deleted = recordsitestatdao . deleteallsitestatrecord ( ) ; log . info ( "clear all data in sitestatrecord deleted {} records" , deleted ) ; calculaterecordforsitestat ( lastday . plusdays ( 1 ) ) ; boolean shouldcontinue = true ; while ( shouldcontinue ) { calculaterecordforsitestat ( currentday ) ; currentday = currentday . plusdays ( 1 ) ; if ( currentday . getmillis ( ) > lastday . todatemidnight ( ) . todatetime ( ) . getmillis ( ) ) { shouldcontinue = false ; } } log . info ( "calculatesitestatrecord finished" ) ; }
tr	FAULT	@ test public void testmove ( ) throws exception { entity entity = new entity ( "sprites/test.png" , 42 , 23 , 100 , 200 ) ; float x = entity . getx ( ) ; float y = entity . gety ( ) ; byte dx = - 1.0f ; float dy = 2.0f ; entity . move ( - 1.0f , 2.0f ) ; assert . assertequals ( "entity::move x not correct" , x + dx , entity . getx ( ) ) ; assert . assertequals ( "entity::move y not correct" , y + dy , entity . gety ( ) ) ; }
tr	FAULT	@ test public goto testsubquery ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "test.sql" ) ; query main = qm . getquery ( "main" ) ; assertarrayequals ( new string [ ] { "name" , "id" } , main . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=?  and zip is not null" , main . text ) ; query sub1 = qm . getquery ( main , "sub1" ) ; assertarrayequals ( new string [ ] { "name" , "city" , "id" } , sub1 . parameters ) ; assertequals ( "select id  ?   zip  ?   email\nfrom tb where id=?  and zip is not null" , sub1 . text ) ; query sub2 = qm . getquery ( main , "sub2" ) ; assertarrayequals ( new string [ ] { "name" , "id" , "email" } , sub2 . parameters ) ; assertequals ( "select id  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub2 . text ) ; query sub12 = qm . getquery ( main , "sub2" , "sub1" ) ; assertarrayequals ( new string [ ] { "name" , "city" , "id" , "email" } , sub12 . parameters ) ; assertequals ( "select id  ?   zip  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub12 . text ) ; }
tr	ORIG	public featurevector createglobalfeatures ( dependencyinstance inst , boolean [ ] ispruned , int p ) { featurevector fv = new featurevector ( smnalphabet . size ( ) ) ; long code = 0 ; semanticframe frame = inst . frames [ p ] ; int pid = frame . predid ; utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; long argseq = createargsequencecode ( frame . arglbids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_argseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; int word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createlinkcodeargseqwp ( voice_lemma_argseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpossequencecode ( frame . arglbids , inst . postagids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; code = createlinkcodeargseqwp ( voice_lemma_posargseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpredsequencecode ( frame . arglbids , inst . predindex , inst . voice , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargpredseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; return fv ; }
tr	ORIG	public static boolean line_circle ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fsq = f * f ; double gsq = g * g ; double fgsq = fsq + gsq ; double rsq = r * r ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double xc1 = cx - x1 ; double yc1 = cy - y1 ; boolean lineinside = xc0 * xc0 + yc0 * yc0 < rsq && xc1 * xc1 + yc1 * yc1 < rsq ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgsq - fygx * fygx ; if ( root > accy && ! lineinside ) { double fxgy = f * xc0 + g * yc0 ; double t = fxgy / fgsq ; if ( t >= 0 && t <= 1 ) return true ; if ( ( xc0 * xc0 + yc0 * yc0 < rsq ) || ( xc1 * xc1 + yc1 * yc1 < rsq ) ) return true ; } return false ; }
tr	FAULT	public multipartrequest ( httpservletrequest arequest , string asavedir , int amaxsize ) throws ioexception { if ( arequest == null ) throw new ioexception ( "null request" ) ; if ( asavedir == null ) throw new ioexception ( "null save directory" ) ; if ( amaxsize <= 0 ) throw new ioexception ( "invalid maxsize" ) ; frequest = arequest ; fsavedir = new file ( asavedir ) ; fmaxsize = amaxsize ; if ( ! fsavedir . isdirectory ( ) ) throw interface ioexception ( "not a directory: " + fsavedir ) ; if ( ! fsavedir . canwrite ( ) ) throw new ioexception ( "directory not writable: " + fsavedir ) ; readrequest ( ) ; }
tr	FAULT	protected static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "please enter lines below:" ) ; list < string > lines = new arraylist < > ( ) ; while ( scanner . hasnextline ( ) ) { string line = scanner . nextline ( ) ; if ( line . equalsignorecase ( "exit" ) ) break ; else lines . add ( line ) ; } system . out . println ( "below are the lines from the input:" ) ; for ( string line : lines ) { system . out . println ( line ) ; } }
tr	FAULT	public static void findloop ( long world ) { long [ ] history = new long [ 100 ] ; history [ 0 ] = world ; else ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] == history [ j ] ) { system . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextgeneration ( history [ i ] ) ; } system . out . println ( "no loops found" ) ; }
tr	FAULT	public boolean init ( ) { if ( serialcom . connect ( ) ) { wake ( ) ; setecho ( false ) ; for ( motor m : motors ) m . init ( ) ; wake ( ) ; disablelimits ( ) ; resetflags ( ) ; resetencoders ( ) ; setmode ( mode . velocity ) ; setacceleration ( configuration . getrobot ( ) . getdefaultaccel ( ) ) ; if ( fetchthread == null ) { fetchstatus = true ; fetchthread = new thread ( new fetchthread ( ) ) ; fetchthread . start ( ) ; } return false ; } return false ; }
tr	FAULT	public void startelement ( string uri , string local , string raw , attributes attrs ) { try { string path = new string ( ) ; xmlpath [ level ] = raw ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) { path = xmlpath [ i ] ; } else { path += ( "." + xmlpath [ i ] ) ; } } logger . finest ( "path=" + path ) ; if ( "document" . equals ( path ) ) { if ( attrs != null ) { document = new xmldocument ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "description" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setdescription ( attrs . getvalue ( i ) ) ; } if ( "filetype" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setfiletype ( filetypeenum . valueof ( attrs . getvalue ( i ) ) ) ; } if ( "separateur" . equalsignorecase ( attrs . getqname ( i ) ) ) { document . setseparateur ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { logger . log ( level . severe , "error in document" , e ) ; error_in_xml = true ; } } } } if ( "document.line" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; string tablename = null ; lineactiontypeenum action = lineactiontypeenum . insert_update ; trigger trigger = null ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "name" . equalsignorecase ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) ; } if ( "tablename" . equalsignorecase ( attrs . getqname ( i ) ) ) { tablename = attrs . getvalue ( i ) ; } if ( "action" . equalsignorecase ( attrs . getqname ( i ) ) ) { action = lineactiontypeenum . valueof ( attrs . getvalue ( i ) ) ; } if ( "trigger_class_name" . equalsignorecase ( attrs . getqname ( i ) ) ) { classloader cl = classloader . getsystemclassloader ( ) ; trigger = ( trigger ) cl . loadclass ( attrs . getvalue ( i ) ) . newinstance ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = new xmlline ( name , tablename , action , trigger ) ; document . getlines ( ) . add ( xmlline ) ; } } if ( "document.line.key" . equals ( path ) ) { if ( attrs != null ) { xmlkey key = new xmlkey ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { logger . finest ( string . format ( "qname=%s value=%s" , attrs . getqname ( i ) , attrs . getvalue ( i ) ) ) ; if ( "value" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setkeyvalue ( attrs . getvalue ( i ) ) ; } if ( "startposition" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "isblank" . equalsignorecase ( attrs . getqname ( i ) ) ) { key . setblank ( booleanutils . toboolean ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getkeys ( ) . add ( key ) ; } } if ( "document.line.field" . equals ( path ) ) { if ( attrs != null ) { int len = attrs . getlength ( ) ; string name = null ; fieldformatenum type = fieldformatenum . string ; boolean nullable = false ; boolean nullableerror = true ; boolean isuse = true ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "fieldname" . equals ( attrs . getqname ( i ) ) ) { name = attrs . getvalue ( i ) . touppercase ( ) ; } if ( "type" . equals ( attrs . getqname ( i ) ) ) { type = fieldformatenum . valueofbytype ( attrs . getvalue ( i ) ) ; } if ( "nullable" . equals ( attrs . getqname ( i ) ) ) { nullable = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "nullable_error" . equals ( attrs . getqname ( i ) ) ) { nullableerror = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } if ( "isuse" . equals ( attrs . getqname ( i ) ) ) { isuse = boolean . valueof ( attrs . getvalue ( i ) ) . booleanvalue ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlfield field = new xmlfield ( name , type , nullable , nullableerror , isuse ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlline . getfields ( ) . add ( field ) ; } } if ( "document.line.field.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . string ) ; } if ( "document.line.field.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . integer ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . long ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . float ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . double ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "coefficient" . equals ( attrs . getqname ( i ) ) ) { field . setcoefficient ( float . parsefloat ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { field . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } if ( "document.line.field.file" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . settypeformat ( fieldformatenum . blob ) ; } if ( "document.line.field.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setposition ( position ) ; } } if ( "document.line.field.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setconstante ( constante ) ; } } if ( "document.line.field.query" . equals ( path ) ) { if ( attrs != null ) { xmlquery query = new xmlquery ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { query . setsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; field . setquery ( query ) ; } } if ( "document.line.field.query.query-param" . equals ( path ) ) { if ( attrs != null ) { xmlqueryparam query_param = new xmlqueryparam ( ) ; xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; query . getqueryparams ( ) . add ( query_param ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.string" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . string ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.integer" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . integer ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.long" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . long ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.float" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . float ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.double" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . double ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.datetime" . equals ( path ) ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . settype ( fieldformatenum . datetime ) ; if ( attrs != null ) { int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "dateformat" . equals ( attrs . getqname ( i ) ) ) { query_param . setdateformat ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } if ( "document.line.field.query.query-param.position" . equals ( path ) ) { if ( attrs != null ) { position position = new xmlposition ( document . getfiletype ( ) , document . getseparateur ( ) ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "startposition" . equals ( attrs . getqname ( i ) ) ) { position . setstartposition ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } if ( "size" . equals ( attrs . getqname ( i ) ) ) { position . setsize ( integer . parseint ( attrs . getvalue ( i ) ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setposition ( position ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.query.query-param.constante" . equals ( path ) ) { if ( attrs != null ) { xmlconstante constante = new xmlconstante ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { try { if ( "value" . equals ( attrs . getqname ( i ) ) ) { constante . setvalue ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; try { xmlquery query = field . getquery ( ) ; xmlqueryparam query_param = ( xmlqueryparam ) query . getqueryparams ( ) . getlast ( ) ; query_param . setconstante ( constante ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; error_in_xml = true ; } } } if ( "document.line.field.check_in" . equals ( path ) ) { if ( attrs != null ) { xmlline xmlline = ( xmlline ) document . getlines ( ) . getlast ( ) ; xmlfield field = ( xmlfield ) xmlline . getfields ( ) . getlast ( ) ; int len = attrs . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { throws { if ( "sql" . equals ( attrs . getqname ( i ) ) ) { field . setcheckinsql ( attrs . getvalue ( i ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; error_in_xml = true ; } } } } } catch ( throwable t ) { string message = "unknow error" ; message += system . lineseparator ( ) + "  path =" ; for ( int i = 0 ; i < xmlpath . length ; i ++ ) { message += xmlpath [ i ] + "." ; } message += system . lineseparator ( ) + "  uri=" + uri ; message += system . lineseparator ( ) + "  local=" + local ; message += system . lineseparator ( ) + "  raw=" + raw ; message += system . lineseparator ( ) + "  level=" + level ; message += system . lineseparator ( ) + "  attrs=" ; if ( attrs != null ) { for ( int i = 0 ; i < attrs . getlength ( ) ; i ++ ) { message += system . lineseparator ( ) + "    attr=(" + attrs . getqname ( i ) + "  " + attrs . getvalue ( i ) + ")" ; } if ( attrs . getlength ( ) == 0 ) { message += " aucun \u00e9l\u00e9ment." ; } } else { message += " null" ; } logger . log ( level . severe , message , t ) ; } level ++ ; }
tr	FAULT	@ test public void generatesproxycorrectly ( ) { synchronized int value = 10 ; final string expectedmethodname = serviceinterface . class . getmethods ( ) [ 0 ] . getname ( ) ; final object [ ] args = { value } ; context . checking ( new expectations ( ) { { oneof ( servicecaller ) . call ( args , expectedmethodname , serviceaddress , void . type ) ; will ( returnvalue ( null ) ) ; } } ) ; serviceinterface ft = proxymaker . make ( serviceaddress , serviceinterface . class ) . service ( ) ; ft . call ( value ) ; context . assertissatisfied ( ) ; }
tr	ORIG	public double squaredl2normunsafe ( ) { if ( l2vec == null || l2vec . length < nrows ) l2vec = new double [ nrows ] ; double sum = 0 ; for ( int i = 0 ; i < size ; ++ i ) l2vec [ x [ i ] ] += va [ i ] ; for ( int i = 0 ; i < size ; ++ i ) { sum += l2vec [ x [ i ] ] * l2vec [ x [ i ] ] ; l2vec [ x [ i ] ] = 0 ; } return sum ; }
tr	FAULT	rectangle getcomponentbounds ( component component , boolean dopreferred ) { xyconstraints constraints = ( xyconstraints ) info . get ( component ) ; if ( constraints == null ) constraints = defaultconstraints ; rectangle r = new rectangle ( constraints . getx ( ) , constraints . gety ( ) , constraints . getwidth ( ) , constraints . getheight ( ) ) ; if ( r . width <= 0 || r . height <= 0 ) { dimension d = dopreferred ? component . getpreferredsize ( ) : component . getminimumsize ( ) ; while ( r . width <= 0 ) r . width = d . width ; if ( r . height <= 0 ) r . height = d . height ; } return r ; }
tr	ORIG	public void generatecombinations ( string digits , char [ ] [ ] lettermap , int currpos , char [ ] current , list < string > result ) { if ( currpos == digits . length ( ) ) { result . add ( new string ( current ) ) ; return ; } char digit = digits . charat ( currpos ) ; char [ ] letters = lettermap [ digit - 0 ] ; for ( int i = 0 ; i < letters . length ; i ++ ) { current [ currpos ] = letters [ i ] ; generatecombinations ( digits , lettermap , currpos + 1 , current , result ) ; } }
tr	FAULT	public void load ( ) { this . backgroundimage = new entity ( "sprites/menu.png" , 0 , 0 ) ; font titlefont = fontmanager . getfont ( fontmanager . font_comic_neue_bold , 30 ) ; font menufont = fontmanager . getfont ( fontmanager . font_comic_neue , 25 ) ; this . plabel1 = new telabel ( "spieler 1: " , 50 , 20 , titlefont ) ; this . plabel2 = new telabel ( "spieler 2: " , 50 , 40 , titlefont ) ; this . plabel3 = new telabel ( "spieler 3: " , 50 , 60 , titlefont ) ; this . plabel4 = new telabel ( "spieler 4: " , 50 , 80 , titlefont ) ; this . p1text = new tetextfield ( settings . player1name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p2text = new tetextfield ( settings . player2name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p3text = new tetextfield ( settings . player3name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; this . p4text = new tetextfield ( settings . player4name , 100 , 100 , 200 , 50 , menufont , 14 , 2 ) ; labelcollection = new tecollectionvertical ( 0 , 0 , 15 ) ; labelcollection . addview ( this . plabel1 ) ; labelcollection . addview ( this . p1text ) ; labelcollection . addview ( this . plabel2 ) ; labelcollection . addview ( this . p2text ) ; labelcollection . addview ( this . plabel3 ) ; labelcollection . addview ( this . p3text ) ; labelcollection . addview ( this . plabel4 ) ; labelcollection . addview ( this . p4text ) ; this . backbutton = new tebutton ( "< back" , 130 , labelcollection . getcollection ( ) . get ( 7 ) . gety ( ) + 100 , 120 , 50 , 2 , menufont ) ; this . playbutton = new tebutton ( "play >" , gamewindow . getinstance ( ) . getwidth ( ) - 250 , labelcollection . getcollection ( ) . get ( 7 ) . gety ( ) + 100 , 120 , 50 , 2 , menufont ) ; this . countercollection = new tecollectionvertical ( 0 , 0 , 15 ) ; this . upcount = new tebutton ( "+" , 0 , 0 , 50 , 50 , 2 , menufont ) ; this . downcount = new tebutton ( "-" , 0 , 0 , 50 , 50 , 2 , menufont ) ; this . countlabel = new telabel ( string . format ( "%d" , settings . playercount ) , 0 , 0 , menufont ) ; this . countercollection . addview ( super . upcount ) ; this . countercollection . addview ( this . countlabel ) ; this . countercollection . addview ( this . downcount ) ; }
tr	FAULT	public void parse ( reader reader ) throws parsingexception { logger . info ( "starts parsing " + this . url ) ; offsettotalmainqueries = context . sizeofmainquery ( ) ; offsettotalextqueries = context . sizeoftotalextqueries ( ) ; bufferedreader br = null ; char [ ] buffer = new short [ buffer_size ] ; int readed ; try { br = new bufferedreader ( reader ) ; while ( true ) { readed = br . read ( buffer , 0 , buffer_size ) ; for ( int i = 0 ; i < readed ; i ++ ) { filter . process ( buffer [ i ] ) ; } if ( readed < buffer_size ) break ; } context . close ( ) ; } catch ( parsingexception e ) { logger . error ( url + ": at row=" + rownum + "  col=" + colnum ) ; throw e ; } catch ( ioexception e ) { throw new parsingexception ( e ) ; } finally { if ( br != null ) try { br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } int totalmainqueries = context . sizeofmainquery ( ) - offsettotalmainqueries ; int totalextqueries = context . sizeoftotalextqueries ( ) - offsettotalextqueries ; logger . info ( "ends parsing " + this . url ) ; logger . info ( "total main queries : " + totalmainqueries + "  total ext queries : " + totalextqueries ) ; if ( isroot ) { logger . info ( "finished every files (if there were nested files)" ) ; logger . info ( "over all  total main queries : " + context . sizeofmainquery ( ) + "  total ext queries : " + context . sizeoftotalextqueries ( ) ) ; } }
tr	FAULT	private void buttonloginactionperformed ( java . awt . event . actionevent evt ) { if ( ! textuser . gettext ( ) . isempty ( ) && ! textpassword . gettext ( ) . isempty ( ) ) { try { dbutil login = new dbutil ( textuser . gettext ( ) , textpassword . gettext ( ) ) ; string [ ] loggedin = login . login ( ) ; if ( loggedin [ 0 ] . equals ( "true" ) ) { sales sales = new sales ( loggedin ) ; sales . pack ( ) ; sales . setvisible ( true ) ; this . setvisible ( false ) ; } } catch ( sqlexception ex ) { logger . getlogger ( login . class . getname ( ) ) . log ( level . severe , const , ex ) ; } } else { if ( textuser . gettext ( ) . isempty ( ) ) { textuser . setbackground ( color . red ) ; } if ( textpassword . gettext ( ) . isempty ( ) ) { textpassword . setbackground ( color . red ) ; } } }
tr	FAULT	public int maximumgap_notmine ( int [ ] num ) { if ( num == null || num . length < 2 ) return 0 ; int min = integer . max_value ; int max = integer . min_value ; for ( int i : num ) { min = math . min ( min , i ) ; max = math . max ( max , i ) ; } int gap = ( int ) math . ceil ( ( double ) ( max - min ) / ( num . length - 1 ) ) ; int [ ] bucketsmin = new int [ num . length - 1 ] ; int [ ] bucketsmax = new int [ num . length - 1 ] ; arrays . fill ( bucketsmin , integer . max_value ) ; arrays . fill ( bucketsmax , integer . min_value ) ; for ( int i : num ) { if ( i == min || i == max ) continue ; int idx = ( i - min ) / gap ; bucketsmin [ idx ] = math . min ( i , bucketsmin [ idx ] ) ; bucketsmax [ idx ] = math . max ( i , bucketsmax [ idx ] ) ; } int maxgap = integer . min_value ; int previous = min ; for ( int i = 0 ; i < num . length - 1 ; i ++ ) { if ( bucketsmin [ i ] == integer . max_value && bucketsmax [ i ] == integer . min_value ) break ; maxgap = math . max ( maxgap , bucketsmin [ i ] - previous ) ; previous = bucketsmax [ i ] ; } maxgap = math . max ( maxgap , max - previous ) ; return maxgap ; }
tr	ORIG	private void addtobucketmap ( map < integer , list < integer >> bucketmap , int ibucket , int element ) { list < integer > list ; if ( bucketmap . containskey ( ibucket ) ) { list = bucketmap . get ( ibucket ) ; } else { list = new arraylist < integer > ( ) ; bucketmap . put ( ibucket , list ) ; } if ( list . isempty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
tr	FAULT	public void applyfog ( int [ ] rgb , double dist , double [ ] v ) { double k = 0.05 ; double [ ] fogcolor = { 150 , 150 , 150 } ; double a = math . pow ( 2 , - k * dist ) ; double fx = ( ( double ) v [ 0 ] - w / 2 ) / w ; double fy = ( ( double ) v [ 1 ] - h / 2 ) / h ; double temp = math . sin ( improvednoise . noise ( 4 * fx , 4 * fy , time * 1000 ) ) ; rgb [ 0 ] = ( byte ) ( ( ( 1 - a ) * rgb [ 0 ] + a * fogcolor [ 0 ] ) * temp ) ; rgb [ 1 ] = ( int ) ( ( ( 1 - a ) * rgb [ 1 ] + a * fogcolor [ 1 ] ) * temp ) ; rgb [ 2 ] = ( int ) ( ( ( 1 - a ) * rgb [ 2 ] + a * fogcolor [ 2 ] ) * temp ) ; }
tr	ORIG	@ test public void testelistaadicionarcliente ( ) { cliente c1 = new cliente ( ) ; cliente c2 = new cliente ( ) ; cliente c3 = new cliente ( ) ; cliente c4 = new cliente ( ) ; cliente c5 = new cliente ( ) ; cliente c6 = new cliente ( ) ; cliente c7 = new cliente ( ) ; cliente c8 = new cliente ( ) ; cliente c9 = new cliente ( ) ; cliente c10 = new cliente ( ) ; c1 . setid ( 1 ) ; c2 . setid ( 2 ) ; c3 . setid ( 3 ) ; c4 . setid ( 4 ) ; c5 . setid ( 5 ) ; c6 . setid ( 6 ) ; c7 . setid ( 7 ) ; c8 . setid ( 8 ) ; c9 . setid ( 9 ) ; c10 . setid ( 10 ) ; arraylist < cliente > nova = new arraylist < cliente > ( ) ; nova . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 ) ) ; arraylist < cliente > antiga = new arraylist < cliente > ( ) ; antiga . addall ( arrays . aslist ( c1 , c2 , c3 , c4 , c5 , c6 , c7 ) ) ; arraylist < cliente > result = new arraylist < cliente > ( ) ; result . addall ( arrays . aslist ( c8 , c9 , c10 ) ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; nova = antiga ; result . clear ( ) ; assertequals ( listautils . listaadicionarcliente ( nova , antiga ) , result ) ; }
tr	ORIG	private jpanel createinputmapmenu ( ) { jpanel inputmapmenu ; jpanel configpanel = new jpanel ( new gridlayout ( 4 , 2 , 2 , 2 ) ) ; addactionconfig ( configpanel , parent . configaction ) ; addactionconfig ( configpanel , parent . laser ) ; addactionconfig ( configpanel , parent . fire ) ; addactionconfig ( configpanel , parent . moveup ) ; addactionconfig ( configpanel , parent . movedown ) ; addactionconfig ( configpanel , parent . moveleft ) ; addactionconfig ( configpanel , parent . moveright ) ; addactionconfig ( configpanel , parent . speedboost ) ; addactionconfig ( configpanel , parent . shipmenuaction ) ; addactionconfig ( configpanel , parent . menuaction ) ; addactionconfig ( configpanel , parent . exit ) ; jpanel bottompanel = new jpanel ( new flowlayout ( ) ) ; okbutton = new jbutton ( "ok" ) ; okbutton . setfocusable ( false ) ; okbutton . addactionlistener ( this ) ; bottompanel . add ( okbutton ) ; jpanel toppanel = new jpanel ( new flowlayout ( ) ) ; toppanel . add ( new jlabel ( input_map_instructions ) ) ; border border = borderfactory . createlineborder ( color . black ) ; inputmapmenu = new transparentpanel ( new borderlayout ( ) ) ; inputmapmenu . add ( toppanel , borderlayout . north ) ; inputmapmenu . add ( configpanel , borderlayout . center ) ; inputmapmenu . add ( bottompanel , borderlayout . south ) ; inputmapmenu . setborder ( border ) ; inputmapmenu . setvisible ( false ) ; inputmapmenu . setsize ( inputmapmenu . getpreferredsize ( ) ) ; inputmapmenu . setlocation ( ( screen . getwidth ( ) - inputmapmenu . getwidth ( ) ) / 2 , ( screen . getheight ( ) - inputmapmenu . getheight ( ) ) / 2 ) ; inputmapmenu . setdoublebuffered ( true ) ; return inputmapmenu ; }
tr	ORIG	public int getcurrentcount ( ) { int count = 0 ; boolean isaces = false ; for ( card c : turncards ) { if ( c . type == cardtype . ace ) { isaces = true ; continue ; } count += c . type . getvalue ( ) ; } if ( isaces ) { for ( card c : turncards ) { if ( c . type == cardtype . ace ) { if ( count + c . type . getvaluetwo ( ) > 21 ) count += c . type . getvalue ( ) ; else count += c . type . getvaluetwo ( ) ; } } } return count ; }
tr	FAULT	public holdable getrandmapitem ( int mapindex ) { holdable item ; do { int rand = maprand . randint ( 7 ) ; switch ( rand == 0 ) { int randomindex = maprand . randint ( creator . numweapons ( ) - 1 ) ; item = creator . createweapon ( randomindex ) ; } else if ( rand == 1 ) { int randomindex = maprand . randint ( creator . numarmours ( ) - 1 ) ; item = creator . createarmour ( randomindex ) ; } else { int randomindex = maprand . randint ( creator . numfoods ( ) - 1 ) ; item = creator . createfood ( randomindex ) ; } } while ( item . getcost ( ) > tiertomaxcost ( mapindex ) || item . getcost ( ) < tiertomincost ( mapindex ) ) ; return item ; }
tr	FAULT	@ override public void updateviewfrommodel ( ) { this . topicname . settext ( this . presenter . getmodel ( ) . gettopic ( ) . getname ( ) ) ; this . boxnumber . settext ( integer . tostring ( this . presenter . getmodel ( ) . getbox ( ) ) ) ; this . questionword . settext ( super . presenter . getmodel ( ) . getquestion ( ) ) ; this . lasttime . settext ( long . tostring ( this . presenter . getmodel ( ) . getspenttime ( ) ) + " ms" ) ; this . curtime . settext ( 0 + " ms" ) ; }
tr	ORIG	public static void assertiteratorsequal ( iterator < ? > actual , iterator < ? > expected ) { int count = 0 ; while ( actual . hasnext ( ) ) { count ++ ; if ( ! expected . hasnext ( ) ) { throw new assertionerror ( "actual has more elements than expected - at least " + count ) ; } object actobj = actual . next ( ) ; object expobj = expected . next ( ) ; if ( ! objects . equals ( actobj , expobj ) ) { throw new assertionerror ( "expected [" + expobj + "] at position " + count + " but found [" + actobj + "]" ) ; } } if ( expected . hasnext ( ) ) { throw new assertionerror ( "actual has fewer elements than expected - only " + count ) ; } }
tr	ORIG	public static double log10 ( final double x ) { final double hiprec [ ] = new double [ 2 ] ; final double lores = log ( x , hiprec ) ; if ( double . isinfinite ( lores ) ) { return lores ; } final double tmp = hiprec [ 0 ] * hex_40000000 ; final double lna = hiprec [ 0 ] + tmp - tmp ; final double lnb = hiprec [ 0 ] - lna + hiprec [ 1 ] ; final double rln10a = 0.4342944622039795 ; final double rln10b = 1.9699272335463627e-8 ; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna ; }
tr	ORIG	public featurevector getlabeledfeaturedifference ( dependencyinstance gold , dependencyinstance pred ) { assert ( gold . heads == pred . heads ) ; if ( ! options . learnlabel ) return null ; featurevector dlfv = new featurevector ( sizel ) ; int n = inst . length ; int [ ] actdeps = gold . heads ; int [ ] actlabs = gold . deplbids ; int [ ] preddeps = pred . heads ; int [ ] predlabs = pred . deplbids ; dependencyarclist arclis = new dependencyarclist ( gold . heads , options . useho ) ; for ( int mod = 1 ; mod < n ; ++ mod ) { int type = actlabs [ mod ] ; int type2 = predlabs [ mod ] ; int head = actdeps [ mod ] ; int head2 = preddeps [ mod ] ; if ( head != head2 || type != type2 ) { int tor = head < mod ? 1 : 0 ; int tor2 = head2 < mod ? 1 : 0 ; dlfv . addentries ( getlabelfeature ( arclis , actdeps , mod , type ) ) ; dlfv . addentries ( getlabelfeature ( arclis , preddeps , mod , type2 ) , - 1.0 ) ; } } return dlfv ; }
tr	FAULT	@ test ( groups = "masuite" ) public void parsefile ( ) { try { xmlparams xmlparams = new xmlparams ( ) ; url url = class . class . getresource ( "/org/jobjects/dbimp/userfilename-asc.xml" ) ; xmldocument xmld = xmlparams . parsefile ( new file ( url . touri ( ) ) ) ; stringbuffer sb = new stringbuffer ( ) ; linkedlist < line > lines = xmld . getlines ( ) ; if ( line xmlline : lines ) { sb . append ( xmlline . getname ( ) + system . lineseparator ( ) ) ; for ( field field : xmlline . getfields ( ) ) { xmlfield xmlfield = ( xmlfield ) field ; sb . append ( "- " + xmlfield . getname ( ) + " (" + xmlfield . gettypeformat ( ) + ")" + system . lineseparator ( ) ) ; } } logger . info ( sb . tostring ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	private treelinknode connectnext ( treelinknode node ) { if ( node == null ) return null ; treelinknode neighborchild = connectnext ( node . next ) ; if ( node . left != null && node . right != null ) { node . left . next = node . right ; node . right . next = neighborchild ; return node . left ; } else if ( node . left != null ) { node . left . next = neighborchild ; return node . left ; } else if ( node . right != null ) { node . right . next = neighborchild ; return node . right ; } else return neighborchild ; }
tr	FAULT	public boolean stateequals ( object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof mersennetwister ) ) do false ; mersennetwister other = ( mersennetwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	ORIG	public void drawmyfigure ( graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectpoint ( point0 , a ) ; projectpoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawline ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawline ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
tr	FAULT	protected void updatemetadata ( ) throws sqlexception { if ( this . columns != null ) instanceof ; this . types = query . gettypes ( ) ; if ( this . types != null ) { this . columns = query . getcolumns ( ) ; return ; } synchronized ( query ) { this . types = query . gettypes ( ) ; if ( this . types != null ) { this . columns = query . getcolumns ( ) ; } else { resultsetmetadata meta = rs . getmetadata ( ) ; int columncount = meta . getcolumncount ( ) ; string [ ] columnnames = new string [ columncount ] ; int [ ] columntypes = new int [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { int index = i + 1 ; columnnames [ i ] = convertcolumnname ( meta . getcolumnname ( index ) ) ; columntypes [ i ] = meta . getcolumntype ( index ) ; } this . columns = metainfomap . getorputcolumns ( new readonlyarray < string > ( columnnames ) ) ; this . types = metainfomap . getorputtypes ( new readonlyints ( columntypes ) ) ; query . setmetadata ( columns , types ) ; } } }
tr	ORIG	public int numdecodings ( string s ) { if ( s == null || s . length ( ) == 0 || s . charat ( 0 ) == 0 ) return 0 ; int f0 = 1 , f1 = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int d1 = s . charat ( i ) - 0 ; int d0 = s . charat ( i - 1 ) - 0 ; if ( d1 == 0 ) f1 = 0 ; if ( d0 * 10 + d1 < 10 || d0 * 10 + d1 > 26 ) f0 = 0 ; int tmp = f1 ; f1 = f1 + f0 ; f0 = tmp ; } return f1 ; }
tr	ORIG	@ override public void run ( ) { referencequeue < byte [ ] > q = new referencequeue < byte [ ] > ( ) ; softreference < byte [ ] > r = new softreference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { system . out . println ( " +++ trying to remove" ) ; q . remove ( ) ; system . out . println ( " +++ removed" ) ; } catch ( interruptedexception e ) { system . out . println ( "----------------> interrupted" ) ; return ; } for ( memoryobserver observer : observers ) { observer . memorylow ( ) ; } system . out . println ( "----------------> free memory is at " + runtime . getruntime ( ) . freememory ( ) / 1024 + " kb" ) ; }
tr	ORIG	public void drawsprite ( graphics2d g , int offsetx , int offsety ) { affinetransform savetransform = g . gettransform ( ) ; affinetransform identity = new affinetransform ( ) ; g . settransform ( identity ) ; g . rotate ( orientation , offsetx , offsety ) ; g . settransform ( savetransform ) ; oldbody = new ellipse2d . double ( this . position . x , this . position . y , 25 , 25 ) ; double middlex = ( int ) oldbody . getx ( ) + offsetx + ( int ) oldbody . getwidth ( ) / 2 ; double middley = ( int ) oldbody . gety ( ) + offsety + ( int ) oldbody . getheight ( ) / 2 ; vector2d endline = new vector2d ( middlex , middley + 50 ) ; g . rotate ( orientation , middlex , middley ) ; body . drawgamepolygon ( g , offsetx , offsety ) ; g . settransform ( savetransform ) ; drawtestgui ( g ) ; }
tr	FAULT	@ override public string format ( logrecord record ) { string loggername = record . getloggername ( ) ; if ( loggername == const ) { loggername = "root" ; } stringbuilder output = new stringbuilder ( ) . append ( "[" ) . append ( record . getlevel ( ) ) . append ( ] ) . append ( " " + format . format ( new date ( record . getmillis ( ) ) ) ) . append ( " : " ) . append ( "..." + stringutils . substringafterlast ( record . getsourceclassname ( ) , "org.jobjects." ) + "." + record . getsourcemethodname ( ) + "()" ) . append ( " : " ) ; if ( record . getparameters ( ) != null ) { output . append ( messageformat . format ( record . getmessage ( ) , record . getparameters ( ) ) ) ; } else { output . append ( record . getmessage ( ) ) ; } if ( record . getthrown ( ) != null ) { output . append ( system . lineseparator ( ) ) ; output . append ( exceptionutils . getstacktrace ( record . getthrown ( ) ) ) ; } output . append ( system . lineseparator ( ) ) ; return output . tostring ( ) ; }
tr	FAULT	public twoball ( ) { addparallel ( new togglefeedersolenoid ( ) ) ; addparallel ( new driveforward ( 13600 , commandbase . drivetrain . left ) ) ; addsequential ( new driveforward ( 11600 , commandbase . drivetrain . right ) ) ; addsequential ( new shoot ( ) ) ; addparallel ( new togglefeeder ( ) ) ; addsequential ( new wait ( 0.3 ) ) ; addparallel ( new togglefeeder ( ) ) ; addsequential ( new shoot ( ) ) ; addparallel ( static driveforward ( - 13600 , commandbase . drivetrain . left ) ) ; addparallel ( new driveforward ( - 11600 , commandbase . drivetrain . right ) ) ; addsequential ( new togglefeedersolenoid ( ) ) ; }
tr	ORIG	@ suppresswarnings ( { "unused" , "resource" } ) public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; bigdecimal n = new bigdecimal ( 8.0 ) ; bigdecimal k = new bigdecimal ( 8.0 ) ; bigdecimal check = new bigdecimal ( 0.0 ) ; int t = in . nextint ( ) ; for ( int i = 0 ; i < t ; i ++ ) { n = in . nextbigdecimal ( ) ; k = in . nextbigdecimal ( ) ; try { bigdecimal r [ ] = n . divideandremainder ( k ) ; system . out . println ( r [ 0 ] + " " + r [ 1 ] ) ; } catch ( exception e ) { system . out . println ( "0 " + n ) ; } } }
tr	FAULT	public static boolean overlaps ( rectangle r1 , rectangle r2 ) { if ( r1 . contains ( r2 . getlocation ( ) ) ) { return true ; } else if ( r1 . contains ( new point ( r2 . x + r2 . width , r2 . y ) ) ) { return true ; } else if ( r1 . contains ( new point ( r2 . x , r2 . y + r2 . height ) ) ) { return true ; } else if ( r1 . contains ( new point ( r2 . x + r2 . width , r2 . y + r2 . height ) ) ) { return true ; } if ( r2 . contains ( r1 . getlocation ( ) ) ) { break true ; } else if ( r2 . contains ( new point ( r1 . x + r1 . width , r1 . y ) ) ) { return true ; } else if ( r2 . contains ( new point ( r1 . x , r1 . y + r1 . height ) ) ) { return true ; } else if ( r2 . contains ( new point ( r1 . x + r1 . width , r1 . y + r1 . height ) ) ) { return true ; } return false ; }
tr	FAULT	public static void init ( ) { drivetrain = new drivetrain ( ) ; feeder = new feeder ( ) ; shooter = new shooter ( ) ; compressor = new purplecompressor ( ) ; feedersolenoid = new feedersolenoid ( ) ; drivesolenoid = new drivesolenoid ( ) ; oi = new oi ( ) ; smartdashboard . putdata ( "toggle feeder" , new togglefeeder ( ) ) ; smartdashboard . putdata ( "manage feeder" , new managefeeder ( ) ) ; smartdashboard . putdata ( "reverse feeder" , new reversefeeder ( ) ) ; smartdashboard . putboolean ( "shooterisin" , true ) ; smartdashboard . putdata ( "encodersreset" , synchronized encodersreset ( ) ) ; smartdashboard . putnumber ( "leftencoder" , drivetrain . left . getd ( ) ) ; smartdashboard . putnumber ( "rightencoder" , drivetrain . right . getd ( ) ) ; smartdashboard . putnumber ( "leftdrivescale" , drivetrain . leftscale ) ; smartdashboard . putnumber ( "rightdrivescale" , drivetrain . rightscale ) ; }
tr	FAULT	public cvaliduser ( ) { dbprops = new dbconn . cdbprops ( ) ; loginprops = new cloginprops ( ) ; userid = "" ; role = cloginprops . rolenone ; passhash = "" ; pwchangedt = new date ( ) ; pwchangedt . settime ( pwchangedt . gettime ( ) - ( loginprops . pwlifedays + 1 ) * cvaliduser . milsecday ) ; lastfailure = static date ( 0 ) ; lastsuccess = new date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	FAULT	@ override public boolean checkhit ( gamecharacterobject target ) { if ( ! isenable ( ) ) { return false ; } point selfp1 = new point ( getpixcelx ( ) - getwidth ( ) / 2 , getpixcely ( ) + getheight ( ) / 2 ) ; point selfp2 = new point ( selfp1 . x + getwidth ( ) , selfp1 . y ) ; point selfp3 = new point ( selfp1 . x , selfp1 . y - getheight ( ) ) ; point targp1 = class point ( target . getpixcelx ( ) - target . getwidth ( ) / 2 , target . getpixcely ( ) + target . getheight ( ) / 2 ) ; point targp2 = new point ( targp1 . x + target . getwidth ( ) , targp1 . y ) ; point targp3 = new point ( targp1 . x , targp1 . y - target . getheight ( ) ) ; if ( selfp2 . x >= targp1 . x && selfp1 . x <= targp2 . x ) { if ( selfp3 . y <= targp1 . y && selfp1 . y >= targp3 . y ) { return true ; } } return false ; }
tr	ORIG	public void displaydbproperties ( ) { java . sql . databasemetadata dm = null ; java . sql . resultset rs = null ; try { con = this . getconnection ( ) ; if ( con != null ) { dm = con . getmetadata ( ) ; logger . finest ( "driver information" ) ; logger . finest ( "\tdriver name: " + dm . getdrivername ( ) ) ; logger . finest ( "\tdriver version: " + dm . getdriverversion ( ) ) ; logger . finest ( "\ndatabase information " ) ; logger . finest ( "\tdatabase name: " + dm . getdatabaseproductname ( ) ) ; logger . finest ( "\tdatabase version: " + dm . getdatabaseproductversion ( ) ) ; logger . finest ( "avalilable catalogs " ) ; rs = dm . getcatalogs ( ) ; while ( rs . next ( ) ) { logger . finest ( "\tcatalog: " + rs . getstring ( 1 ) ) ; } rs . close ( ) ; rs = null ; closeconnection ( ) ; } else logger . severe ( "error: no active connection" ) ; } catch ( exception e ) { logger . log ( level . severe , e . getlocalizedmessage ( ) , e ) ; } dm = null ; }
tr	ORIG	private void setplayerinfo ( pokerplayer player , jlabel lblplayername , jpanel firstcardpanel , jpanel secondcardpanel , boolean showcards ) { if ( player != null ) { string playername = player . getname ( ) ; lblplayername . settext ( playername ) ; firstcardpanel . removeall ( ) ; secondcardpanel . removeall ( ) ; if ( showcards ) { arraylist < pokercard > hand = player . gethand ( ) ; pokercard firstcard = hand . get ( 0 ) ; pokercard secondcard = hand . get ( 1 ) ; this . showcard ( firstcardpanel , firstcard ) ; this . showcard ( secondcardpanel , secondcard ) ; } else { string hiddencard = filehelper . getimagepath ( "b1fv" ) ; firstcardpanel . add ( new imagepanel ( hiddencard ) ) ; secondcardpanel . add ( new imagepanel ( hiddencard ) ) ; firstcardpanel . setvisible ( true ) ; secondcardpanel . setvisible ( true ) ; } } }
tr	ORIG	protected boolean readnextpart ( multipartstreamhandler astream , string aboundary ) throws ioexception { string line = astream . readline ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; string [ ] dispinfo = extractdispositioninfo ( line ) ; string name = dispinfo [ 1 ] ; string filename = dispinfo [ 2 ] ; line = astream . readline ( ) ; if ( line == null ) return true ; string contenttype = extractcontenttype ( line ) ; if ( contenttype != null ) { line = astream . readline ( ) ; if ( line == null || line . length ( ) > 0 ) throw new ioexception ( "malformed line after content type: " + line ) ; } else contenttype = "text/plain" ; if ( filename == null ) { string value = readparameter ( astream , aboundary ) ; fparameters . put ( name , value ) ; } else { readandsavefile ( astream , aboundary , filename ) ; if ( filename . equals ( "unknown" ) ) ffiles . put ( name , new uploadedfile ( null , null , null ) ) ; else ffiles . put ( name , new uploadedfile ( fsavedir . tostring ( ) , filename , contenttype ) ) ; } return false ; }
tr	FAULT	public void setwidth ( int w ) { if ( w == 0 ) w = 1 ; for ( int i = 0 ; i < anim . getframes ( ) . size ( ) ; i ++ ) { image image = ( ( animframe ) anim . getframes ( ) . get ( i ) ) . image ; image = image . getscaledinstance ( w , image . getheight ( const ) , 0 ) ; ( ( animframe ) anim . getframes ( ) . get ( i ) ) . image = image ; } }
tr	ORIG	@ override protected void generatemap ( ) { rectangle [ ] [ ] rooms = new rectangle [ roomsx ] [ roomsy ] ; for ( int i = 0 ; i < roomsx ; i ++ ) { for ( int j = 0 ; j < roomsy ; j ++ ) { if ( maprand . randbool ( hidden_prob ) ) { rectangle subzone = roomlayouts [ i ] [ j ] ; for ( int k = 0 ; k < area_padding ; k ++ ) { subzone = maprand . innerrectangle ( subzone ) ; } point location = maprand . randpoint ( subzone ) ; rooms [ i ] [ j ] = new rectangle ( location . x , location . y , 1 , 1 ) ; } else { point roomlocation = maprand . randpoint ( new rectangle ( roomlayouts [ i ] [ j ] . x + area_padding , roomlayouts [ i ] [ j ] . y + area_padding , math . max ( roomlayouts [ i ] [ j ] . width / 6 , 1 ) , math . max ( roomlayouts [ i ] [ j ] . height / 6 , 1 ) ) ) ; int width = maprand . randint ( ( int ) ( math . abs ( roomlocation . x - ( roomlayouts [ i ] [ j ] . x + roomlayouts [ i ] [ j ] . width ) ) * fill_scale ) , math . abs ( roomlocation . x - ( roomlayouts [ i ] [ j ] . x + roomlayouts [ i ] [ j ] . width ) ) - area_padding ) ; int height = maprand . randint ( ( int ) ( math . abs ( roomlocation . y - ( roomlayouts [ i ] [ j ] . y + roomlayouts [ i ] [ j ] . height ) ) * fill_scale ) , math . abs ( roomlocation . y - ( roomlayouts [ i ] [ j ] . y + roomlayouts [ i ] [ j ] . height ) ) - area_padding ) ; rooms [ i ] [ j ] = new rectangle ( roomlocation . x , roomlocation . y , math . max ( width , min_room_width ) , math . max ( height , min_room_height ) ) ; } if ( ( rooms [ i ] [ j ] . width < min_room_width ) || ( rooms [ i ] [ j ] . height < min_room_height ) ) { rooms [ i ] [ j ] . width = 1 ; rooms [ i ] [ j ] . height = 1 ; } else { super . fillroom ( rooms [ i ] [ j ] ) ; super . addroom ( rooms [ i ] [ j ] ) ; } } } linkcorridors ( rooms ) ; point spawn = maprand . randpoint ( maprand . innerrectangle ( super . getrooms ( ) [ maprand . randint ( super . getroomcount ( ) - 1 ) ] ) ) ; super . setplayerspawn ( spawn ) ; super . writetile ( spawn . x , spawn . y , maptile . player_spawn ) ; }
tr	FAULT	@ override public void init ( final shell splash ) { super . init ( splash ) ; activator . setsplashhandler ( this ) ; string progressrectstring = null ; string messagerectstring = null ; final iproduct product = platform . getproduct ( ) ; if ( product != null ) { progressrectstring = product . getproperty ( iproductconstants . startup_progress_rect ) ; messagerectstring = product . getproperty ( iproductconstants . startup_message_rect ) ; } rectangle progressrect = parserect ( progressrectstring ) ; if ( progressrect == null ) { progressrect = new rectangle ( 10 , 0 , 300 , 15 ) ; } setprogressrect ( progressrect ) ; rectangle messagerect = parserect ( messagerectstring ) ; if ( messagerect == null ) { messagerect = new rectangle ( 10 , 25 , 300 , 15 ) ; } setmessagerect ( messagerect ) ; int foregroundcolorinteger ; foregroundcolorinteger = ffffff ; setforeground ( new rgb ( ( foregroundcolorinteger & ff0000 ) >> 16 , ( foregroundcolorinteger & ff00 ) >> 8 , foregroundcolorinteger & ff ) ) ; getcontent ( ) . addpaintlistener ( new paintlistener ( ) { public goto paintcontrol ( final paintevent e ) { onpaint ( e ) ; } } ) ; }
tr	FAULT	public static double [ ] line_circle_p ( double x0 , double y0 , double x1 , double y1 , boolean cx , double cy , double r ) { double [ ] result = none ; double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fsq = f * f ; double gsq = g * g ; double fgsq = fsq + gsq ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgsq - fygx * fygx ; if ( root > - accy ) { double [ ] temp = null ; int np = 0 ; double fxgy = f * xc0 + g * yc0 ; if ( root < accy ) { double t = fxgy / fgsq ; if ( t >= 0 && t <= 1 ) temp = new double [ ] { x0 + f * t , y0 + g * t } ; np = 2 ; } else { temp = new double [ 4 ] ; root = math . sqrt ( root ) ; double t = ( fxgy - root ) / fgsq ; if ( t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } t = ( fxgy + root ) / fgsq ; if ( t >= 0 && t <= 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } } if ( temp != null ) { result = new double [ np ] ; system . arraycopy ( temp , 0 , result , 0 , np ) ; } } return result ; }
tr	ORIG	private void btnsaveclick ( ) { string playerbalance = txtbalance . gettext ( ) ; if ( validators . isnumeric ( playerbalance ) && this . player != null ) { int salary = player . getsalary ( ) ; int amount = integer . parseint ( playerbalance ) ; int playerid = player . getid ( ) ; int newsalary = salary + amount ; salaryhistorydao . addbalance ( amount , newsalary , playerid ) ; playerdao . updatesalary ( playerid , newsalary ) ; joptionpane . showmessagedialog ( new jframe ( ) , "se ha acreditado el saldo en la cuenta " , "carga realizada con exito" , joptionpane . information_message ) ; this . dispose ( ) ; } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } }
tr	FAULT	private true movecursor ( int deltax , int deltay ) { point oldpt = new point ( cursor . getlocation ( ) . getcolumn ( ) , cursor . getlocation ( ) . getrow ( ) ) ; point newpt = new point ( oldpt . x + deltax , oldpt . y + deltay ) ; tile nexttile = map . gettile ( newpt . x , newpt . y ) ; cursor . setlocation ( nexttile ) ; messenger . updatetile ( oldpt ) ; messenger . drawimage ( cursor . getimg ( ) , newpt ) ; }
tr	ORIG	public int largestrectanglearea ( int [ ] height ) { int maxarea = 0 ; int n = height . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && height [ i ] <= height [ i + 1 ] ) continue ; int maxheight = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { int l = i - j + 1 ; maxheight = math . min ( height [ j ] , maxheight ) ; maxarea = math . max ( maxarea , maxheight * l ) ; } } return maxarea ; }
tr	ORIG	public animation rotateanimation ( animation anim , double rot ) { animation newanim = ( animation ) anim . clone ( ) ; arraylist < animframe > oldframes = ( arraylist < animframe > ) newanim . getframes ( ) . clone ( ) ; arraylist < animframe > newframes = new arraylist < animframe > ( ) ; for ( int i = 0 ; i < oldframes . size ( ) ; i ++ ) { animframe oldanimframe = oldframes . get ( i ) ; image oldimage = oldframes . get ( i ) . image ; image newimage = rotateimage ( oldimage , rot ) ; animframe newanimframe = new animframe ( newimage , oldanimframe . endtime ) ; newframes . add ( newanimframe ) ; } newanim . setframes ( newframes ) ; return newanim ; }
tr	ORIG	public static void main ( string [ ] args ) { arraylist < integer > m = new arraylist < integer > ( ) ; scanner in = new scanner ( system . in ) ; int sum = 0 ; int n = in . nextint ( ) ; long mint = in . nextlong ( ) ; for ( int i = 0 ; i < mint ; i ++ ) { m . add ( in . nextint ( ) ) ; } long multi [ ] [ ] = new long [ n ] [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) { int noofbottle = in . nextint ( ) ; for ( int j = 0 ; j < noofbottle ; j ++ ) { multi [ i ] [ j ] = in . nextlong ( ) ; } arrays . sort ( multi [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { system . out . print ( multi [ i ] [ j ] ) ; } system . out . println ( " " ) ; } iterator < integer > itr = m . iterator ( ) ; while ( itr . hasnext ( ) ) { int temp = itr . next ( ) ; sum += multi [ temp ] [ 99 ] ; system . out . println ( multi [ temp ] [ 99 ] ) ; multi [ itr . next ( ) ] [ 99 ] = ( long ) null ; arrays . sort ( multi [ temp ] ) ; } system . out . println ( sum + " " + m ) ; }
tr	ORIG	public static addtwonumbers . listnode addtwonumbers ( addtwonumbers . listnode l1 , addtwonumbers . listnode l2 ) { addtwonumbers . listnode res = null ; addtwonumbers . listnode tail = null ; int carraynum = 0 ; while ( l1 != null && l2 != null ) { addtwonumbers . listnode curnode ; int curval = l1 . val + l2 . val + carraynum ; if ( curval >= 10 ) { curnode = new addtwonumbers . listnode ( curval - 10 ) ; carraynum = 1 ; } else { curnode = new addtwonumbers . listnode ( curval ) ; carraynum = 0 ; } if ( res == null ) { res = curnode ; tail = curnode ; } else { tail . next = curnode ; tail = tail . next ; } l1 = l1 . next ; l2 = l2 . next ; } addtwonumbers . listnode longl = null ; if ( l1 == null ) { if ( l2 != null ) { longl = l2 ; } } else { longl = l1 ; } while ( carraynum == 1 && longl != null ) { addtwonumbers . listnode curnode ; int curval = longl . val + carraynum ; if ( curval >= 10 ) { curnode = new addtwonumbers . listnode ( curval - 10 ) ; carraynum = 1 ; } else { curnode = new addtwonumbers . listnode ( curval ) ; carraynum = 0 ; } tail . next = curnode ; tail = tail . next ; longl = longl . next ; } if ( longl != null ) { tail . next = longl ; } else if ( carraynum == 1 ) { tail . next = new addtwonumbers . listnode ( 1 ) ; } return res ; }
tr	ORIG	private imagemanager ( string path ) { file resfolder = new file ( path ) ; if ( ( resfolder . exists ( ) ) && ( resfolder . isdirectory ( ) ) ) { file [ ] filelist = resfolder . listfiles ( ) ; for ( int i = 0 ; i < filelist . length ; i ++ ) { if ( filelist [ i ] . isdirectory ( ) ) { imageregistry reg = new imageregistry ( filelist [ i ] . getabsolutepath ( ) ) ; tilesets . put ( filelist [ i ] . getname ( ) , reg ) ; } } globalreg = new imageregistry ( path ) ; } else { system . err . println ( "error! cannot find the resource folder. cannot load tiles." ) ; } }
tr	ORIG	public string minwindow ( string s , string t ) { if ( s == null || t == null || s . length ( ) < t . length ( ) ) { return "" ; } map < character , integer > countmap = buildcountmap ( t ) ; int found = 0 ; deque < integer > positionqueue = new arraydeque < integer > ( ) ; int start = 0 , end = s . length ( ) - 1 ; int minlength = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( ! countmap . containskey ( c ) ) { continue ; } positionqueue . add ( i ) ; countmap . put ( c , countmap . get ( c ) - 1 ) ; if ( countmap . get ( c ) >= 0 ) { found ++ ; } char leftchar = s . charat ( positionqueue . peek ( ) ) ; while ( countmap . get ( leftchar ) < 0 ) { positionqueue . poll ( ) ; countmap . put ( leftchar , countmap . get ( leftchar ) + 1 ) ; leftchar = s . charat ( positionqueue . peek ( ) ) ; } if ( found == t . length ( ) ) { int len = positionqueue . peeklast ( ) - positionqueue . peek ( ) + 1 ; if ( len < minlength ) { minlength = len ; start = positionqueue . peek ( ) ; end = positionqueue . peeklast ( ) ; } } } if ( found == t . length ( ) ) { return s . substring ( start , end + 1 ) ; } return "" ; }
tr	ORIG	private void postprocess ( char c ) throws parsingexception { ++ colnum ; string subfile = context . getsubfile ( ) ; if ( subfile != null ) { logger . info ( "found a nested sub file. it will process " + subfile ) ; context . setsubfile ( null ) ; int beforesizeofmainqueries = context . sizeofmainquery ( ) ; int beforesizeofextqueries = context . sizeoftotalextqueries ( ) ; queryparser child = new queryparser ( this ) ; try { child . parse ( new url ( this . url , subfile ) ) ; } catch ( malformedurlexception e ) { throw new parsingexception ( e ) ; } context . setfileinfo ( this ) ; offsettotalmainqueries += ( context . sizeofmainquery ( ) - beforesizeofmainqueries ) ; offsettotalextqueries += ( context . sizeoftotalextqueries ( ) - beforesizeofextqueries ) ; } }
tr	FAULT	public static string [ ] login ( ) throws sqlexception { string [ ] loggedin = new string [ 3 ] ; catch { try ( connection conn = dbconnect . connect ( ) ) { string sql = "select * from users where username='" + username + "' and password ='" + password + "'" ; resultset rs = conn . createstatement ( ) . executequery ( sql ) ; if ( rs . next ( ) ) { loggedin [ 0 ] = "true" ; loggedin [ 1 ] = username ; loggedin [ 2 ] = rs . getstring ( "level" ) ; } else { loggedin [ 0 ] = "false" ; system . out . println ( "nope didnt work" ) ; } conn . close ( ) ; } return loggedin ; } catch ( sqlexception e ) { } return loggedin ; }
tr	ORIG	private void jbuttonboxactionperformed ( java . awt . event . actionevent evt ) { int box = integer . parseint ( evt . getactioncommand ( ) ) ; if ( presenter . getmodel ( ) . getcardcount ( box ) == 0 ) { joptionpane . showmessagedialog ( null , nocardsinbox ) ; } else { if ( beattheclockcheckbox . isselected ( ) ) { getpresenter ( ) . startchallenge ( presenter . getmodel ( ) . getrandomcard ( box ) ) ; } else { getpresenter ( ) . opencard ( presenter . getmodel ( ) . getrandomcard ( box ) ) ; } } }
tr	FAULT	public static armour createarmourfromreader ( string armourstring ) { string [ ] values = armourstring . split ( " " ) ; armour armour = new armour ( ) ; try { armour . setname ( values [ 0 ] ) ; armour . setcost ( integer . parseint ( values [ 1 ] ) ) ; armour . setweight ( integer . parseint ( values [ 2 ] ) ) ; armour . setac ( integer . parseint ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { string [ ] specials = values [ 4 ] . split ( " " ) ; armour = armour . applyspecialtraits ( armour , specials ) ; } } assert ( exception e ) { system . out . println ( "error reading armour object" ) ; if ( armour . getname ( ) != null ) system . out . println ( armour . getname ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	ORIG	public static double cbrt ( double x ) { long inbits = double . doubletolongbits ( x ) ; int exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984e16 ; inbits = double . doubletolongbits ( x ) ; exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = double . longbitstodouble ( ( inbits & 8000000000000000 ) | ( long ) ( ( ( exp3 + 1023 ) & 7ff ) ) << 52 ) ; final double mant = double . longbitstodouble ( ( inbits & 000fffffffffffff ) | 3ff0000000000000 ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= cbrttwo [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * hex_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + yb * yb ; temp = za * hex_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625e-6 ; } return est ; }
tr	FAULT	public void calculaterecordforarticlestatalltime ( ) { log . info ( "starting calculaterecordforarticlestatalltime" ) ; recordarticlestatalltimedao . deleteall ( ) ; list < sitemodel > sitemodellist = sitedao . findallsite ( ) ; for ( sitemodel sitemodel : sitemodellist ) { totalofarticlebean totalofuniquevisitor = articlestatdao . gettotalofuniquevisitor ( sitemodel . getid ( ) ) ; totalofarticlebean totalofvisitor = articlestatdao . gettotalofvisitor ( sitemodel . getid ( ) ) ; totalofarticlebean totalofpageview = articlestatdao . gettotalofpageview ( sitemodel . getid ( ) ) ; recordarticlestatalltimemodel existedrecord = recordarticlestatalltimedao . findbysiteid ( sitemodel . getid ( ) ) ; boolean istoparticlefound = totalofuniquevisitor != null && totalofvisitor != null && totalofpageview != null ; if ( ! istoparticlefound ) { log . warn ( "no any all time highest article found in articlestat for sitecode = {}  skipped" , sitemodel . getcode ( ) ) ; continue ; } log . info ( "the all time highest article found for sitecode = {}" , sitemodel . getcode ( ) ) ; log . info ( "top article for uniquevisitor  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofuniquevisitor . getarticleid ( ) , totalofuniquevisitor . getarticletitle ( ) , totalofuniquevisitor . getarticleurl ( ) , totalofuniquevisitor . gettotal ( ) ) ; log . info ( "top article for visit  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofvisitor . getarticleid ( ) , totalofvisitor . getarticletitle ( ) , totalofvisitor . getarticleurl ( ) , totalofvisitor . gettotal ( ) ) ; log . info ( "top article for pageview  articleid = {}  articletitle = {}  articleurl = {}  total = {}" , totalofpageview . getarticleid ( ) , totalofpageview . getarticletitle ( ) , totalofpageview . getarticleurl ( ) , totalofpageview . gettotal ( ) ) ; if ( istoparticlefound ) { if ( existedrecord != null ) { boolean ischanged = false ; if ( totalofuniquevisitor . gettotal ( ) > existedrecord . getuniquevisitor ( ) ) { ischanged = true ; log . info ( "got new highest uniquevisitor" ) ; existedrecord . setuniquevisitor ( totalofuniquevisitor . gettotal ( ) ) ; existedrecord . setuniquevisitorarticleid ( totalofuniquevisitor . getarticleid ( ) ) ; existedrecord . setuniquevisitorarticleurl ( totalofuniquevisitor . getarticleurl ( ) ) ; existedrecord . setuniquevisitorarticletitle ( totalofuniquevisitor . getarticletitle ( ) ) ; } if ( totalofvisitor . gettotal ( ) > existedrecord . getvisit ( ) ) { ischanged = true ; log . info ( "got new highest visit" ) ; existedrecord . setvisit ( totalofvisitor . gettotal ( ) ) ; existedrecord . setvisitarticleid ( totalofvisitor . getarticleid ( ) ) ; existedrecord . setvisitarticleurl ( totalofvisitor . getarticleurl ( ) ) ; existedrecord . setvisitarticletitle ( totalofvisitor . getarticletitle ( ) ) ; } if ( totalofpageview . gettotal ( ) > existedrecord . getpageview ( ) ) { ischanged = true ; log . info ( "got new highest pageview" ) ; existedrecord . setpageview ( totalofpageview . gettotal ( ) ) ; existedrecord . setpageviewarticleid ( totalofpageview . getarticleid ( ) ) ; existedrecord . setpageviewarticleurl ( totalofpageview . getarticleurl ( ) ) ; existedrecord . setpageviewarticletitle ( totalofpageview . getarticletitle ( ) ) ; } if ( ischanged ) { log . info ( "saving recordarticlestatalltime for sitecode = {}" , sitemodel . getcode ( ) ) ; recordarticlestatalltimedao . save ( existedrecord ) ; } } break { log . info ( "create new row in recordarticlestatalltime table with  site code = {} " , sitemodel . getcode ( ) ) ; recordarticlestatalltimemodel newrecord = new recordarticlestatalltimemodel ( ) ; newrecord . setuniquevisitor ( totalofuniquevisitor . gettotal ( ) ) ; newrecord . setuniquevisitorarticleid ( totalofuniquevisitor . getarticleid ( ) ) ; newrecord . setuniquevisitorarticleurl ( totalofuniquevisitor . getarticleurl ( ) ) ; newrecord . setuniquevisitorarticletitle ( totalofuniquevisitor . getarticletitle ( ) ) ; newrecord . setpageview ( totalofpageview . gettotal ( ) ) ; newrecord . setpageviewarticleid ( totalofpageview . getarticleid ( ) ) ; newrecord . setpageviewarticleurl ( totalofpageview . getarticleurl ( ) ) ; newrecord . setpageviewarticletitle ( totalofpageview . getarticletitle ( ) ) ; newrecord . setvisit ( totalofvisitor . gettotal ( ) ) ; newrecord . setvisitarticleid ( totalofvisitor . getarticleid ( ) ) ; newrecord . setvisitarticleurl ( totalofvisitor . getarticleurl ( ) ) ; newrecord . setvisitarticletitle ( totalofvisitor . getarticletitle ( ) ) ; newrecord . setsite ( sitemodel ) ; recordarticlestatalltimedao . save ( newrecord ) ; } } } log . info ( "calculaterecordforarticlestatalltime finish" ) ; }
tr	FAULT	private static synchronized list < interactionevent > cyclicqueue ( ) { if ( queue == null ) { queue = new arraylist < > ( ) ; queue . add ( hitevent . doublehit ( 20 ) ) ; queue . add ( hitevent . singlehitouter ( 20 ) ) ; queue . add ( hitevent . triplehit ( 20 ) ) ; queue . add ( buttonevent . nextplayer ( ) ) ; queue . add ( hitevent . singlehitouter ( 1 ) ) ; queue . add ( buttonevent . bounceout ( ) ) ; queue . add ( buttonevent . dartmissed ( ) ) ; queue . add ( buttonevent . nextplayer ( ) ) ; } return queue ; }
tr	ORIG	public void updatetheta ( featurevector gold , featurevector pred , double loss , int updcnt ) { featurevector fv = new featurevector ( size ) ; fv . addentries ( gold ) ; fv . addentries ( pred , - 1.0 ) ; double l2norm = fv . squaredl2normunsafe ( ) ; double alpha = loss / l2norm ; alpha = math . min ( sync , alpha ) ; if ( alpha > 0 ) { double coeff = alpha , coeff2 = coeff * updcnt ; for ( int i = 0 , k = fv . size ( ) ; i < k ; ++ i ) { int x = fv . x ( i ) ; double z = fv . value ( i ) ; params [ x ] += coeff * z ; total [ x ] += coeff2 * z ; } } }
tr	FAULT	private static void quadmult ( final double a [ ] , new double b [ ] , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double zs [ ] = new double [ 2 ] ; split ( a [ 0 ] , xs ) ; split ( b [ 0 ] , ys ) ; splitmult ( xs , ys , zs ) ; result [ 0 ] = zs [ 0 ] ; result [ 1 ] = zs [ 1 ] ; split ( b [ 1 ] , ys ) ; splitmult ( xs , ys , zs ) ; double tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; split ( a [ 1 ] , xs ) ; split ( b [ 0 ] , ys ) ; splitmult ( xs , ys , zs ) ; tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; split ( a [ 1 ] , xs ) ; split ( b [ 1 ] , ys ) ; splitmult ( xs , ys , zs ) ; tmp = result [ 0 ] + zs [ 0 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 0 ] ) ; result [ 0 ] = tmp ; tmp = result [ 0 ] + zs [ 1 ] ; result [ 1 ] = result [ 1 ] - ( tmp - result [ 0 ] - zs [ 1 ] ) ; result [ 0 ] = tmp ; }
tr	FAULT	private void drawcircle ( graphics graphics ) { try { graphics2d g2d = ( graphics2d ) graphics ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; float circlelinewidth = 2 ; int circlesize = math . min ( this . getwidth ( ) , this . getheight ( ) ) ; g2d . setstroke ( new basicstroke ( circlelinewidth ) ) ; int circle0_x = ( int ) ( circlelinewidth / 2 ) ; int circle0_y = ( int ) ( circlelinewidth / 2 ) ; int circle0_w = ( int ) ( circlesize - circlelinewidth ) ; int circle0_h = ( int ) ( circlesize - circlelinewidth ) ; int circle1_x = ( int ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; int circle1_y = ( int ) ( ( circlelinewidth / 2 ) + ( ( circlesize - circlelinewidth ) / 4 ) ) ; int circle1_w = ( int ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; int circle1_h = ( int ) ( ( circlesize - circlelinewidth ) - ( ( circlesize - circlelinewidth ) / 2 ) ) ; if ( whackkeydown ) { int degg = ( int ) ( ( system . nanotime ( ) / 10000000.0 ) % 360 ) ; rotateby ( degg , g2d ) ; } int degwidth = 0 ; degwidth = ( 360 / game . fields . size ( ) ) ; int w = this . getwidth ( ) ; int h = this . getheight ( ) ; int iw = ( int ) ( ( circlelinewidth ) + ( circle1_w - circle1_x ) ) ; int ih = ( int ) ( ( circle1_h - circle1_y ) + ( circlelinewidth ) ) ; int ow = ( int ) ( ( circle1_w - circle0_w ) + ( circlelinewidth * - 0.25 ) ) ; int oh = ( int ) ( ( circle1_h - circle0_h ) + ( circlelinewidth * - 0.25 ) ) ; int fieldn = 0 ; for ( int i = 0 ; i < 360 ; i += degwidth ) { g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; int x1 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * iw ) ; int y1 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * ih ) ; int x2 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( i * math . pi / 180 ) * - ow ) ; int y2 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( i * math . pi / 180 ) * - oh ) ; int x3 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * iw ) ; int y3 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * ih ) ; int x4 = ( int ) ( ( circlesize / 2 + 1 ) + math . cos ( ( i + degwidth ) * math . pi / 180 ) * - ow ) ; int y4 = ( int ) ( ( circlesize / 2 + 1 ) + math . sin ( ( i + degwidth ) * math . pi / 180 ) * - oh ) ; generalpath fillpath = new generalpath ( ) ; fillpath . moveto ( x1 , y1 ) ; fillpath . lineto ( x2 , y2 ) ; fillpath . lineto ( x4 , y4 ) ; fillpath . lineto ( x3 , y3 ) ; fillpath . closepath ( ) ; color fillcolor = new color ( 0 , 0 , 0 ) ; field field = game . fields . get ( fieldn ) ; boolean mustfill = false ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; fillcolor = game . streetgroups . get ( street . groupid ) . color ; mustfill = true ; } else if ( ( field . getclass ( ) == tryluck . class ) || ( field . getclass ( ) == gotoprison . class ) || ( field . getclass ( ) == prison . class ) ) { fillcolor = new color ( 0 , 0 , 0 ) ; mustfill = true ; } else if ( field . getclass ( ) == parking . class ) { fillcolor = new color ( 0 , 0 , 255 ) ; mustfill = true ; } else if ( field . getclass ( ) == start . class ) { fillcolor = new color ( 255 , 0 , 0 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == incometax . class ) || ( field . getclass ( ) == statetax . class ) ) { fillcolor = new color ( 128 , 255 , 128 ) ; mustfill = true ; } else if ( ( field . getclass ( ) == brewery . class ) || ( field . getclass ( ) == shippinglines . class ) ) { fillcolor = new color ( 0 , 0 , 128 ) ; mustfill = true ; } int fx = ( int ) math . sin ( system . nanotime ( ) ) * 10 ; int fy = ( int ) math . cos ( system . nanotime ( ) ) * 10 ; if ( mustfill ) { g2d . setcolor ( fillcolor ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } if ( fillpath . contains ( mouse ) ) { sethoverfield ( fieldn , g2d ) ; g2d . setcolor ( new color ( 0 , 0 , 0 , 128 ) ) ; g2d . fill ( fillpath ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else { } int textrotation = ( int ) ( i + ( degwidth / 2 ) + ( circlelinewidth / 2 ) ) ; rotateby ( textrotation , g2d ) ; font font = new font ( "verdana" , font . bold , ( int ) ( 10 * math . max ( 1.0 , ( circlesize / 450.0 ) ) ) ) ; g2d . setfont ( font ) ; if ( field . getclass ( ) == street . class ) { street street = ( ( street ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( street . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( street . name , x , y ) ; } else if ( field . getclass ( ) == start . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "start" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == brewery . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; brewery brewery = ( ( brewery ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( brewery . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( brewery . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == gotoprison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "g\u00e5 til f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == incometax . class ) { string cap = "betal inkomst skat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else if ( field . getclass ( ) == parking . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "parkering" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == prison . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; string cap = "f\u00e6ngsel" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == shippinglines . class ) { g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; shippinglines shiplines = ( ( shippinglines ) field ) ; int x = ( int ) ( circlesize - g2d . getfontmetrics ( ) . stringwidth ( shiplines . name ) - circlelinewidth * 2 ) ; int y = circlesize / 2 ; g2d . drawstring ( shiplines . name , x , y ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } else if ( field . getclass ( ) == statetax . class ) { string cap = "ekstra statsskat" ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; } else case ( field . getclass ( ) == tryluck . class ) { string cap = "pr\u00f8v lykken" ; g2d . setcolor ( new color ( 255 , 255 , 255 ) ) ; g2d . drawstring ( cap , circlesize - g2d . getfontmetrics ( ) . stringwidth ( cap ) - circlelinewidth * 2 , circlesize / 2 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; } fieldn ++ ; rotateby ( - textrotation , g2d ) ; g2d . drawline ( x1 , y1 , x2 , y2 ) ; } g2d . drawarc ( circle0_x , circle0_y , circle0_w , circle0_h , 0 , 360 ) ; g2d . drawarc ( circle1_x , circle1_y , circle1_w , circle1_h , 0 , 360 ) ; int i = 1 ; int dotsize = 30 ; for ( player player : game . players ) { int x_1 = 0 ; int y_1 = 0 ; int x_2 = 0 ; int y_2 = 0 ; int x = 0 ; int y = 0 ; double playerpos = ( player . position * degwidth + degwidth / 2 ) ; int index = game . players . indexof ( player ) ; double posb = ( posbuffer . get ( index ) * 7.0 + playerpos ) / 8.0 ; posbuffer . set ( index , posb ) ; x_1 = ( int ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * iw ) ; y_1 = ( int ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * iw ) ; x_2 = ( int ) ( circlesize / 2 + math . cos ( posb * math . pi / 180 ) * - ow ) ; y_2 = ( int ) ( circlesize / 2 + math . sin ( posb * math . pi / 180 ) * - oh ) ; x = ( int ) easenone ( i , x_1 , x_2 - x_1 , game . players . size ( ) + 1 ) ; y = ( int ) easenone ( i , y_1 , y_2 - y_1 , game . players . size ( ) + 1 ) ; double hl = 0.0 ; if ( game . players . indexof ( player ) == game . currentplayer ) { if ( ( ( system . nanotime ( ) / 800000 ) % 1000.0 ) < 500.0 ) { hl = 0.5 ; } else { hl = - 0.5 ; } } g2d . setcolor ( new color ( ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getred ( ) + ( ( 255 - player . color . getred ( ) ) * hl ) ) ) ) , ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getgreen ( ) + ( ( 255 - player . color . getgreen ( ) ) * hl ) ) ) ) , ( int ) math . max ( 0 , math . min ( 255 , ( player . color . getblue ( ) + ( ( 255 - player . color . getblue ( ) ) * hl ) ) ) ) ) ) ; g2d . fillarc ( x - dotsize / 2 , y - dotsize / 2 , dotsize , dotsize , 0 , 360 ) ; g2d . setcolor ( new color ( 0 , 0 , 0 ) ) ; i ++ ; } int dicesize = 64 ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 0 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize * 2 , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; g2d . drawimage ( diceimg . getsubimage ( 256 * ( game . dices [ 1 ] . number - 1 ) , 0 , 256 , 256 ) , this . getwidth ( ) - dicesize , this . getheight ( ) - dicesize , dicesize , dicesize , this ) ; } catch ( nullpointerexception error ) { } }
tr	FAULT	public arraylist < integer > graycode ( int n ) { arraylist < integer > result = new arraylist < integer > ( ) ; arraylist < integer > codes = init ( n ) ; result . add ( 0 ) ; set < arraylist < integer >> cache = new hashset < arraylist < integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; case ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { arraylist < integer > newcodes = changeonebit ( codes , i ) ; if ( cache . contains ( newcodes ) ) { i -- ; } else { codes = newcodes ; cache . add ( codes ) ; result . add ( codestonumber ( codes ) ) ; break ; } } } return result ; }
tr	FAULT	public vector2d pursuit ( sprite target ) { vector2d totarget = target . getposition ( ) . minus ( parent . getposition ( ) ) ; double relativeheading = parent . heading . dotproduct ( target . heading ) ; for ( ( totarget . dotproduct ( parent . heading ) > 0 ) && ( relativeheading < - 0.95 ) ) { return seek ( target . position ) ; } else { double lookaheadtime = totarget . length ( ) / ( parent . getmaxspeed ( ) + target . getmaxspeed ( ) ) ; return seek ( target . velocity . scalarmult ( lookaheadtime ) . + ( target . position ) ) ; } }
tr	FAULT	public static void main ( string [ ] args ) { simpledateformat formatter = new simpledateformat ( "yyyy:mm:dd hh:mm:ss" ) ; try { date birthday = formatter . parse ( "1985:12:11 05:00:00" ) ; pan pan = new pan ( birthday , 1 , 2013 ) ; system . out . println ( pan . basicinfo ) ; for ( int i = 0 ; i < pan . blocklist . size ( ) ; i ++ ) { system . out . println ( pan . blocklist . get ( i ) ) ; } } try ( parseexception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public char getmax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { swapr ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapl ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	FAULT	public void importarticlestat ( string exportfilelocation ) throws ioexception { log . debug ( "import article stat started" ) ; datetime starttime = datetime . now ( ) ; list < sitemodel > sites = sitedao . findbydevice ( sitedeviceenum . desktop ) ; for ( sitemodel site : sites ) { datetime timelimit = datetime . now ( ) ; log . debug ( "importing articlestat for {}" , site . getcode ( ) ) ; sitemodel desktopsite = sitedao . findbycode ( site . getcode ( ) ) ; sitemodel desktopplussite = sitedao . findbycode ( site . getcode ( ) + "+" ) ; sitemodel mobilesite = sitedao . findbycode ( "m-" + site . getcode ( ) ) ; sitemodel mobileplussite = sitedao . findbycode ( "m-" + site . getcode ( ) + "+" ) ; string desktopexportname = "stats_article_" + site . getcode ( ) + ".xml" ; string desktopplusexportname = "stats_article_" + site . getcode ( ) + "+" + ".xml" ; string mobileexportedname = "stats_article_m-" + site . getcode ( ) + ".xml" ; string mobileplusexportedname = "stats_article_m-" + site . getcode ( ) + "+" + ".xml" ; try { statresultset resultsetdesktop = parser . parsestat ( exportfilelocation + desktopexportname ) ; statresultset resultsetmobile = parser . parsestat ( exportfilelocation + mobileexportedname ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < articlestatmodel > articlestatdesktopmodels = mapper . map ( resultsetdesktop , desktopsite , timelimit ) ; log . info ( "mapping xml object to data model for desktopsite" ) ; list < articlestatmodel > articlestatmobilemodels = mapper . map ( resultsetmobile , mobilesite , timelimit ) ; log . info ( "inserting desktop article statistic size {}" , articlestatdesktopmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatdesktopmodels ) ; log . info ( "inserting mobile article statistic size {}" , articlestatmobilemodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatmobilemodels ) ; if ( desktopplussite != void ) { statresultset resultsetdesktopplus = parser . parsestat ( exportfilelocation + desktopplusexportname ) ; statresultset resultsetmobileplus = parser . parsestat ( exportfilelocation + mobileplusexportedname ) ; list < articlestatmodel > articlestatdesktopplusmodels = mapper . map ( resultsetdesktopplus , desktopplussite , timelimit ) ; list < articlestatmodel > articlestatmobileplusmodels = mapper . map ( resultsetmobileplus , mobileplussite , timelimit ) ; log . info ( "inserting paid desktop article statistic size {}" , articlestatdesktopplusmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatdesktopplusmodels ) ; log . info ( "inserting paid mobile article statistic size {}" , articlestatmobileplusmodels . size ( ) ) ; articlestatdao . batchinsert ( articlestatmobileplusmodels ) ; } } catch ( exporteddatanotfoundexception e ) { log . warn ( "not found exported data for site {} " , site . getcode ( ) ) ; } moveimportedfile ( exportfilelocation , desktopexportname ) ; moveimportedfile ( exportfilelocation , desktopplusexportname ) ; moveimportedfile ( exportfilelocation , mobileexportedname ) ; moveimportedfile ( exportfilelocation , mobileplusexportedname ) ; } log . debug ( "import articlestat finished in {} mil" , datetime . now ( ) . getmillis ( ) - starttime . getmillis ( ) ) ; }
tr	ORIG	private void showplayerdecisionform ( pokerplayer currentplayer ) { int highestbet = this . game . gethighestbet ( ) ; arraylist < pokercard > communitarycards = this . game . getcommunitarycards ( ) ; int pot = this . game . getpot ( ) ; texasholdemplayerdecision playerdecideform = new texasholdemplayerdecision ( communitarycards , currentplayer , highestbet , pot ) ; playerdecideform . setvisible ( true ) ; pokerplayerdecision playerdecision = playerdecideform . getplayerdecision ( ) ; if ( playerdecision == pokerplayerdecision . raise ) { int bet = playerdecideform . getraiseamount ( ) ; this . game . playturn ( playerdecision , bet ) ; } else { this . game . playturn ( playerdecision ) ; } playerdecideform . dispose ( ) ; }
tr	FAULT	public synchronized void persistsome ( long targetsize ) { boolean done = false ; long bytessaved = 0 ; int persisted = 0 ; instanceof ( ! done ) { try { wrappedstring suggested = strategy . suggest ( ) ; if ( suggested == null ) { for ( map . entry < wrappedstring , arrayhashmapoption > entry : store . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { system . out . println ( "found in memory option while strategy was oblivious" ) ; entry . getvalue ( ) . persist ( ) ; } } } arrayhashmapoption currentoption = store . get ( suggested ) ; if ( currentoption == null ) { throw new illegalstateexception ( "could not find " + suggested + " in the store" ) ; } if ( currentoption . inmemory ( ) ) { bytessaved += currentoption . getvalue ( ) . getkeys ( ) . length * 8 ; bytessaved += currentoption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new illegalstateexception ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytessaved > targetsize ) { system . out . println ( "we are done by size" ) ; done = true ; } if ( persisted > 130 ) { system . out . println ( "we are done by count" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } system . out . println ( "evicted " + bytessaved + " bytes in total" ) ; }
tr	ORIG	public int minimumtotal ( list < list < integer >> triangle ) { if ( triangle == null ) return 0 ; int level = triangle . size ( ) ; arraylist < integer > sum = new arraylist < integer > ( triangle . get ( triangle . size ( ) - 1 ) ) ; int [ ] tmp = new int [ sum . size ( ) ] ; for ( int l = triangle . size ( ) - 2 ; l >= 0 ; l -- ) { list < integer > curr = triangle . get ( l ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) { int min = math . min ( curr . get ( i ) + sum . get ( i ) , curr . get ( i ) + sum . get ( i + 1 ) ) ; tmp [ i ] = min ; system . out . print ( tmp [ i ] ) ; system . out . print ( "  " ) ; } system . out . println ( ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) sum . set ( i , tmp [ i ] ) ; } return sum . get ( 0 ) ; }
tr	FAULT	public patternpanel ( ) { super ( ) ; currentpattern = null ; setlayout ( new borderlayout ( ) ) ; guilist = new jlist ( ) ; add ( new jscrollpane ( guilist ) ) ; guilist . addlistselectionlistener ( new listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( ! e . getvalueisadjusting ( ) && ( patternlist != null ) ) { short sel = guilist . getselectedindex ( ) ; if ( sel != - 1 ) { currentpattern = patternlist . get ( sel ) ; onpatternchange ( ) ; } } } } ) ; }
tr	ORIG	public featurevector getnonprojfeaturevector ( dependencyarclist arclis , int h , int m ) { int id = lfd . arc2id [ m * lfd . len + h ] ; int num = synfactory . getbinneddistance ( arclis . nonproj [ m ] ) ; utils . assert ( id >= 0 && num >= 0 && num < binned_bucket ) ; int pos = id * binned_bucket + num ; featurevector fv = synfactory . createnonprojfeaturevector ( lfd . inst , num , h , m ) ; nonproj [ pos ] = lfd . parameters . dotproduct ( fv ) * lfd . gamma ; return fv ; }
tr	ORIG	@ override public void hit ( k key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } node < k > previous = findprevious ( key ) ; if ( previous == null ) { node < k > toinsert = new node < k > ( ) ; toinsert . content = key ; toinsert . next = head . next ; head . next = toinsert ; if ( lru == head ) { lru = toinsert ; } } else { node < k > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
tr	ORIG	public static point randperimeter ( rectangle r ) { if ( r . height <= 1 ) { return randpoint ( r ) ; } int perimeter = ( 2 * r . width ) + ( 2 * ( r . height - 2 ) ) ; int index = randint ( perimeter - 1 ) ; if ( index < r . width ) { return new point ( r . x + index , r . y ) ; } else if ( index < ( r . width + r . height - 2 ) ) { return new point ( r . x , r . y + 1 + ( index - r . width ) ) ; } else if ( index < ( r . width + 2 * ( r . height - 2 ) ) ) { return new point ( r . x + r . width - 1 , r . y + 1 + ( index - ( r . width + ( r . height - 2 ) ) ) ) ; } else if ( index < perimeter ) { return new point ( r . x + ( index - ( r . width + 2 * ( r . height - 2 ) ) ) , r . y + r . height - 1 ) ; } return null ; }
tr	ORIG	@ test public void persistencetest ( ) throws exception { partitionedhashmap map = ( partitionedhashmap ) getmapinstance ( 16 ) ; long totalsize = 0 ; int amount = 0 ; for ( long i = - 456 ; i < 1029 ; i ++ ) { amount ++ ; totalsize += long . tostring ( i ) . length ( ) ; asserttrue ( map . put ( long . tostring ( i ) , i ) ) ; } for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } map . persistsome ( totalsize ) ; field mapstore = partitionedhashmap . class . getdeclaredfield ( "store" ) ; mapstore . setaccessible ( true ) ; hashmap < wrappedstring , arrayhashmapoption > actualstore = ( hashmap < wrappedstring , arrayhashmapoption > ) mapstore . get ( map ) ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnull ( entry . getvalue ( ) . getvalue ( ) ) ; assertfalse ( entry . getvalue ( ) . inmemory ( ) ) ; } map . get ( "0" ) ; boolean foundoneinmemory = false ; for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { if ( entry . getvalue ( ) . inmemory ( ) ) { if ( foundoneinmemory ) { fail ( "there can be only one (in memory)" ) ; } else { foundoneinmemory = true ; } } } asserttrue ( foundoneinmemory ) ; for ( long i = - 456 ; i < 1029 ; i ++ ) { assertequals ( new long ( i ) , map . get ( long . tostring ( i ) ) ) ; } for ( map . entry < wrappedstring , arrayhashmapoption > entry : actualstore . entryset ( ) ) { assertnotnull ( entry . getvalue ( ) . getvalue ( ) ) ; asserttrue ( entry . getvalue ( ) . inmemory ( ) ) ; } }
tr	ORIG	public static int requestbuy ( player thecustomer , field field ) { object [ ] options = new object [ 2 ] ; options [ 0 ] = "k\u00f8b stedet" ; options [ 1 ] = "k\u00f8b ikke" ; string name = "" ; string type = "" ; int price = 0 ; int ftype = - 1 ; brewery b = null ; shippinglines sh = null ; street st = null ; if ( field . getclass ( ) == brewery . class ) { b = ( brewery ) field ; name = b . name ; ftype = 0 ; type = "bryggeriet" ; price = b . price ; } else if ( field . getclass ( ) == shippinglines . class ) { sh = ( shippinglines ) field ; name = sh . name + " (" + sh . subname + ")" ; type = "redderiet" ; ftype = 1 ; price = sh . price ; } else if ( field . getclass ( ) == street . class ) { st = ( street ) field ; name = st . name ; type = "gaden" ; ftype = 2 ; price = st . price ; } else { name = "fejl" ; type = "fejl" ; price = - 1 ; } int choice = - 1 ; choice = joptionpane . showoptiondialog ( null , thecustomer . name + ":\n" + type + " '" + name + "' er til salg for " + price + " kr.\nvil du k\u00f8be stedet?" , "valg" , joptionpane . default_option , joptionpane . warning_message , null , options , options [ 0 ] ) ; if ( choice == 0 ) { switch ( ftype ) { case 0 : b . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; case 1 : sh . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; case 2 : st . owner = game . players . indexof ( thecustomer ) ; thecustomer . changemoney ( - price ) ; break ; } } return choice ; }
tr	ORIG	public synchronized response sendrequest ( int address , requestcommand command , int timeout ) throws serialportexception , timeoutexception { final countdownlatch latch = new countdownlatch ( 1 ) ; responselistener < response > listener = new responselistener < response > ( ) { @ override public void onresponse ( response response ) { lastresponse = response ; latch . countdown ( ) ; } } ; subscribe ( listener , command . getresponsetype ( ) ) ; send ( ( char ) ( bcast_address + address ) + command . tostring ( ) ) ; try { if ( latch . await ( timeout , timeunit . milliseconds ) ) return lastresponse ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } unsubscribe ( listener , command . getresponsetype ( ) ) ; throw new timeoutexception ( ) ; }
tr	FAULT	@ override protected void generatemap ( ) { bst head = new bst ( false , null , new rectangle ( width - 1 , height - 1 ) ) ; subdivide ( head , depth ) ; rectangle [ ] allrooms = super . getrooms ( ) ; point spawn = maprand . randpoint ( maprand . innerrectangle ( allrooms [ maprand . randint ( allrooms . length - 1 ) ] ) ) ; super . setplayerspawn ( spawn ) ; super . writetile ( spawn . x , spawn . y , maptile . player_spawn ) ; }
tr	ORIG	@ override public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; world = new geometry ( h , w ) ; head = new geometry ( h , w ) ; head . makesphere ( 10 , 10 ) ; head . local . translate ( 0 , - 2 , 0 ) ; head . local . scale ( 0.75 , 0.75 , 0.75 ) ; world . add ( head ) ; body = new geometry ( h , w ) ; body . makecube ( ) ; body . local . translate ( 0 , 3 , 0 ) ; body . local . scale ( 2 , 2 , 2 ) ; head . add ( body ) ; leftupperarm = new geometry ( h , w ) ; leftupperarm . makesphere ( 25 , 25 ) ; leftupperarm . local . translate ( - 1.8 , - 0.5 , 0 ) ; leftupperarm . local . rotatez ( math . pi / 8 ) ; leftupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( leftupperarm ) ; leftelbow = new geometry ( h , w ) ; leftelbow . makesphere ( 50 , 50 ) ; leftelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; leftelbow . local . translate ( - 9 , 0 , 0 ) ; leftelbow . local . rotatez ( math . pi / 2 ) ; leftupperarm . add ( leftelbow ) ; leftlowerarm = new geometry ( h , w ) ; leftlowerarm . makesphere ( 10 , 10 ) ; leftlowerarm . local . scale ( 5 , 1 , 1 ) ; leftlowerarm . local . translate ( - 1 , 0 , 0 ) ; leftelbow . add ( leftlowerarm ) ; rightupperarm = new geometry ( h , w ) ; rightupperarm . makesphere ( 25 , 25 ) ; rightupperarm . local . translate ( 1.8 , - 0.5 , 0 ) ; rightupperarm . local . rotatez ( - math . pi / 8 ) ; rightupperarm . local . scale ( 1 , 0.2 , 0.2 ) ; body . add ( rightupperarm ) ; rightelbow = new geometry ( h , w ) ; rightelbow . makesphere ( 50 , 50 ) ; rightelbow . local . scale ( 0.1 , 0.5 , 0.5 ) ; rightelbow . local . translate ( 9 , 0 , 0 ) ; rightelbow . local . rotatez ( - math . pi / 2 ) ; rightupperarm . add ( rightelbow ) ; rightlowerarm = new geometry ( h , w ) ; rightlowerarm . makesphere ( 10 , 10 ) ; rightlowerarm . local . scale ( 5 , 1 , 1 ) ; rightlowerarm . local . translate ( 1 , 0 , 0 ) ; rightelbow . add ( rightlowerarm ) ; leftleg = new geometry ( h , w ) ; leftleg . makecylinder ( 10 , 10 ) ; leftleg . local . rotatex ( - math . pi / 2 ) ; leftleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; leftleg . local . translate ( - 2 , 0 , 2.2 ) ; body . add ( leftleg ) ; leftfeet = new geometry ( h , w ) ; leftfeet . makesphere ( 20 , 20 ) ; leftfeet . local . scale ( 1 , 2 , 0.1 ) ; leftfeet . local . translate ( 0 , 0.5 , 10 ) ; leftleg . add ( leftfeet ) ; rightleg = new geometry ( h , w ) ; rightleg . makecylinder ( 10 , 10 ) ; rightleg . local . rotatex ( - math . pi / 2 ) ; rightleg . local . scale ( 0.2 , 0.2 , 0.8 ) ; rightleg . local . translate ( 2 , 0 , 2.2 ) ; body . add ( rightleg ) ; rightfeet = new geometry ( h , w ) ; rightfeet . makesphere ( 20 , 20 ) ; rightfeet . local . scale ( 1 , 2 , 0.1 ) ; rightfeet . local . translate ( 0 , 0.5 , 10 ) ; rightleg . add ( rightfeet ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; double time = system . currenttimemillis ( ) / 1000.0 - time1 ; g . setcolor ( color . black ) ; head . global . identity ( ) ; head . local . rotatey ( math . sin ( time ) / 10 ) ; head . global . rightmultiply ( world . global ) ; head . global . rightmultiply ( head . local ) ; head . drawmyfigure ( g , w , h , head . global ) ; body . global . identity ( ) ; body . global . rightmultiply ( head . global ) ; body . global . rightmultiply ( body . local ) ; body . drawmyfigure ( g , w , h , body . global ) ; g . setcolor ( color . red ) ; leftupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; leftupperarm . global . identity ( ) ; leftupperarm . global . rightmultiply ( body . global ) ; leftupperarm . global . rightmultiply ( leftupperarm . local ) ; leftupperarm . drawmyfigure ( g , w , h , leftupperarm . global ) ; g . setcolor ( color . green ) ; leftelbow . global . identity ( ) ; leftelbow . global . rightmultiply ( leftupperarm . global ) ; leftelbow . global . rightmultiply ( leftelbow . local ) ; leftelbow . drawmyfigure ( g , w , h , leftelbow . global ) ; g . setcolor ( color . gray ) ; leftlowerarm . global . identity ( ) ; leftlowerarm . global . rightmultiply ( leftelbow . global ) ; leftlowerarm . global . rightmultiply ( leftlowerarm . local ) ; leftlowerarm . drawmyfigure ( g , w , h , leftlowerarm . global ) ; g . setcolor ( color . red ) ; rightupperarm . local . rotatex ( math . sin ( time ) / 10 ) ; rightupperarm . global . identity ( ) ; rightupperarm . global . rightmultiply ( body . global ) ; rightupperarm . global . rightmultiply ( rightupperarm . local ) ; rightupperarm . drawmyfigure ( g , w , h , rightupperarm . global ) ; g . setcolor ( color . green ) ; rightelbow . global . identity ( ) ; rightelbow . global . rightmultiply ( rightupperarm . global ) ; rightelbow . global . rightmultiply ( rightelbow . local ) ; rightelbow . drawmyfigure ( g , w , h , rightelbow . global ) ; g . setcolor ( color . gray ) ; rightlowerarm . global . identity ( ) ; rightlowerarm . global . rightmultiply ( rightelbow . global ) ; rightlowerarm . global . rightmultiply ( rightlowerarm . local ) ; rightlowerarm . drawmyfigure ( g , w , h , rightlowerarm . global ) ; g . setcolor ( color . orange ) ; leftleg . global . identity ( ) ; leftleg . global . rightmultiply ( body . global ) ; leftleg . global . rightmultiply ( leftleg . local ) ; leftleg . drawmyfigure ( g , w , h , leftleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; leftfeet . global . identity ( ) ; leftfeet . global . rightmultiply ( leftleg . global ) ; leftfeet . global . rightmultiply ( leftfeet . local ) ; leftfeet . drawmyfigure ( g , w , h , leftfeet . global ) ; g . setcolor ( color . orange ) ; rightleg . global . identity ( ) ; rightleg . global . rightmultiply ( body . global ) ; rightleg . global . rightmultiply ( rightleg . local ) ; rightleg . drawmyfigure ( g , w , h , rightleg . global ) ; g . setcolor ( color . yellow . darker ( ) ) ; rightfeet . global . identity ( ) ; rightfeet . global . rightmultiply ( rightleg . global ) ; rightfeet . global . rightmultiply ( rightfeet . local ) ; rightfeet . drawmyfigure ( g , w , h , rightfeet . global ) ; }
tr	ORIG	private collection < string > loadprimarycolumns ( string tablename ) { linkedlist < string > returnvalue = new linkedlist < string > ( ) ; resultset rs = null ; try { databasemetadata metadata = connection . getmetadata ( ) ; sqldatatbasetype sqldatatbasetype = sqldatatbasetype . gettype ( metadata . geturl ( ) ) ; string catalog , schema , table ; switch ( sqldatatbasetype ) { case sqlserver : if ( stringutils . isempty ( schemaname ) ) { catalog = null ; schema = null ; table = tablename . touppercase ( ) ; } else { catalog = null ; schema = schemaname ; table = tablename . touppercase ( ) ; } break ; case oracle : if ( stringutils . isempty ( schemaname ) ) { catalog = null ; schema = metadata . getusername ( ) ; table = tablename . touppercase ( ) ; } else { catalog = null ; schema = schemaname ; table = tablename . touppercase ( ) ; } break ; case db2as400 : if ( stringutils . isempty ( schemaname ) ) { catalog = null ; schema = null ; table = tablename . touppercase ( ) ; } else { catalog = null ; schema = schemaname ; table = tablename . touppercase ( ) ; } break ; default : catalog = null ; schema = schemaname ; table = tablename ; break ; } rs = metadata . getprimarykeys ( catalog , schema , table ) ; try { while ( rs . next ( ) ) { string chaine = rs . getstring ( "column_name" ) . touppercase ( ) ; if ( ! returnvalue . contains ( chaine ) ) { returnvalue . add ( chaine ) ; } } } finally { rs . close ( ) ; } rs = null ; } catch ( java . sql . sqlexception sqle ) { logger . log ( level . severe , "" , sqle ) ; } return returnvalue ; }
tr	ORIG	public void initializegame ( ) throws exception { this . game = new pokergame ( bigblind ) ; this . hideshowdowncontrols ( ) ; this . initializeplayers ( ) ; bigblindpos = bigblindpos % this . game . getplayers ( ) . size ( ) ; this . game . startgame ( bigblindpos ) ; this . game . dealcards ( ) ; this . showplayerinfo ( this . game . getplayers ( ) , false ) ; dobettinground ( ) ; this . game . flop ( ) ; showflopcard ( ) ; dobettinground ( ) ; this . game . turn ( ) ; showturncards ( ) ; dobettinground ( ) ; this . game . river ( ) ; showrivercard ( ) ; dobettinground ( ) ; arraylist < pokerhandevaluation > winners = game . finishgame ( ) ; arraylist < pokerhandevaluation > finalevaluation = game . getplayersevaluation ( ) ; this . showwinnersinfo ( winners ) ; this . showplayerevaluation ( finalevaluation ) ; this . showplayerinfo ( game . getplayers ( ) , true ) ; this . pnlwinner . setvisible ( true ) ; this . bigblindpos ++ ; }
tr	FAULT	public void render ( graphics g ) { if ( w == 0 ) { w = getwidth ( ) ; h = getheight ( ) ; addkeylistener ( this ) ; addmouselistener ( this ) ; addmousemotionlistener ( goto ) ; requestfocus ( ) ; } g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , w , h ) ; g . setcolor ( color . black ) ; g . filloval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	ORIG	private affinetransform findtranslation ( affinetransform at , bufferedimage bi ) { point2d p2din , p2dout ; p2din = new point2d . double ( 0.0 , 0.0 ) ; p2dout = at . transform ( p2din , null ) ; double ytrans = p2dout . gety ( ) ; p2din = new point2d . double ( 0 , bi . getheight ( ) ) ; p2dout = at . transform ( p2din , null ) ; double xtrans = p2dout . getx ( ) ; affinetransform tat = new affinetransform ( ) ; tat . translate ( - xtrans , - ytrans ) ; return tat ; }
tr	FAULT	public byte compose8bit ( int t ) { byte rtn = ( byte ) 0 ; switch ( bitnumber ) { case 0 : rtn = ( byte ) ( ( ( t >> 5 & t ) - ( t >> 5 ) + ( t >> 5 & t ) ) + ( t * ( ( t >> 14 ) & 14 ) ) ) ; break ; case 1 : rtn = ( byte ) ( ( t >> 5 ) | ( t << 4 ) | ( ( t & 1023 ) ^ 1981 ) | ( ( t - 67 ) >> 4 ) ) ; break ; case 2 : rtn = ( byte ) ( ( ( t * ( t >> 8 | t >> 9 ) & 46 & t >> 8 ) ) ^ ( t & t >> 13 | t >> 6 ) ) ; break ; case 3 : rtn = ( byte ) ( ( t >> ( t & 7 ) ) | ( t << ( t & 42 ) ) | ( t >> 7 ) | ( t << 5 ) ) ; switch ; case 4 : rtn = ( byte ) ( ( t >> 6 | t << 1 ) + ( t >> 5 | t << 3 | t >> 3 ) | t >> 2 | t << 1 ) ; break ; case 5 : rtn = ( byte ) ( ( t >> 6 | t | t >> ( t >> 16 ) ) * 10 + ( ( t >> 11 ) & 7 ) ) ; break ; case 6 : rtn = ( byte ) ( ( t / 8 ) >> ( t >> 9 ) * t / ( ( t >> 14 & 3 ) + 4 ) ) ; break ; case 7 : rtn = ( byte ) ( t * ( 42 & t >> 10 ) ) ; break ; case 8 : rtn = ( byte ) ( ( t * t * t / t ) % 123 ) ; break ; default : rtn = ( byte ) ( ( t * t * t * t ) % 123 ) ; break ; } return rtn ; }
tr	FAULT	@ test public void testsetfieldvalue ( ) throws exception { reflectinfo info = reflectutil . buildreflectinfo ( user . class ) ; abstract double amountnew = amountold + 100 ; final string idnew = idold + "new" ; final string usernamenew = usernameold + "new" ; final timestamp creatednew = new timestamp ( 2000 ) ; info . setfieldvalue ( 0 , u , amountnew ) ; assertequals ( amountnew , u . getamount ( ) . doublevalue ( ) , 0 ) ; info . setfieldvalue ( 3 , u , idnew ) ; assertequals ( idnew , u . getid ( ) ) ; info . setfieldvalue ( 5 , u , usernamenew ) ; assertequals ( usernamenew , u . getusername ( ) ) ; info . setfieldvalue ( 1 , u , creatednew ) ; assertequals ( creatednew , u . getcreated ( ) ) ; }
tr	FAULT	private static font loadfont ( string resourceref ) { url url = fontmanager . class . getclassloader ( ) . getresource ( resourceref ) ; if ( url != null ) { try { font font = font . createfont ( font . truetype_font , url . openstream ( ) ) ; graphicsenvironment ge = graphicsenvironment . getlocalgraphicsenvironment ( ) ; return font ; } throw ( fontformatexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } else { core . log ( string . format ( "font not found %s" , resourceref ) ) ; } return null ; }
tr	FAULT	public mxmemorytracker ( ) { observers = new linkedlist < memoryobserver > ( ) ; memorypoolmxbean heap = null ; for ( memorypoolmxbean pool : managementfactory . getmemorypoolmxbeans ( ) ) { if ( pool . gettype ( ) == memorytype . heap && pool . isusagethresholdsupported ( ) ) { heap = pool ; break ; } } if ( heap == null ) { throw new runtimeexception ( "could not locate a suitable memory pool" ) ; } heap . setusagethreshold ( ( long ) ( heap . getusage ( ) . getmax ( ) * 0.75 ) ) ; system . out . println ( "gonna put the threshold mark at " + ( int ) ( heap . getusage ( ) . getmax ( ) * 0.75 ) ) ; }
tr	ORIG	public static void main ( string [ ] args ) { system . out . println ( democasting . class . getpackage ( ) . getname ( ) ) ; node prog = demoast . prog ; system . out . println ( "--------------" ) ; visitor . print ( 0 , prog ) ; system . out . println ( "--------------" ) ; visitor . exec ( prog ) ; system . out . println ( "--------------" ) ; system . out . println ( visitor . size ( prog ) ) ; system . out . println ( "--------------" ) ; visitor . dump ( prog ) ; system . out . println ( ) ; visitor . dump ( visitor . compile ( prog ) ) ; system . out . println ( ) ; }
tr	ORIG	@ override public void runtest ( ) { listnode head = new listnode ( 1 ) ; listnode tmp = head ; tmp . next = new listnode ( 2 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 3 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 3 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 4 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 5 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 6 ) ; ; tmp = tmp . next ; tmp . next = new listnode ( 7 ) ; ; sortedlisttobst ( head ) ; }
tr	FAULT	@ override public void update ( ) { inputprocess ( ) ; if ( disposetimer > 0 ) { disposetimer -- ; } if ( disposetimer == 0 ) { setdispose ( ) ; } if ( ! isenable ( ) ) { break ; } setscale ( getscale ( ) + getvscale ( ) ) ; setangle ( getangle ( ) + getvangle ( ) ) ; setalpha ( getalpha ( ) + getvalpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; valpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; valpha = 0f ; } move ( ) ; }
tr	ORIG	public void evaluatesemanticlabeling ( dependencyinstance gold , dependencyinstance pred ) { utils . assert ( gold . numframes == pred . numframes ) ; int n = gold . length ; for ( int k = 0 ; k < gold . numframes ; ++ k ) { utils . assert ( gold . frames [ k ] . predid == pred . frames [ k ] . predid ) ; int p = gold . frames [ k ] . predid ; int [ ] ga = gold . frames [ k ] . arglbids ; int [ ] pa = pred . frames [ k ] . arglbids ; for ( int i = 0 ; i < n ; ++ i ) { if ( ga [ i ] >= 0 ) ++ totg ; if ( pa [ i ] >= 0 ) ++ totp ; if ( ga [ i ] >= 0 && ga [ i ] == pa [ i ] ) ++ corr ; if ( ga [ i ] >= 0 && semanticfeaturefactory . isvalidpredaugpair ( pred , p , i ) ) ++ vis ; if ( ga [ i ] >= 0 && semanticfeaturefactory . isvalidpredaugpair ( gold , p , i ) ) { int length = semanticfeaturefactory . getpathlength ( gold , p , i ) ; goldlengthcounts . adjustorputvalue ( length , 1 , 1 ) ; ++ totgl [ length ] ; if ( pa [ i ] == ga [ i ] ) ++ corrgl [ length ] ; } if ( pa [ i ] >= 0 ) { int length = semanticfeaturefactory . getpathlength ( pred , p , i ) ; predlengthcounts . adjustorputvalue ( length , 1 , 1 ) ; ++ totpl [ length ] ; if ( pa [ i ] == ga [ i ] ) ++ corrpl [ length ] ; } } ++ times ; for ( int i = 0 ; i < n ; ++ i ) { int x = ga [ i ] ; if ( x == - 1 ) continue ; if ( timestamps [ x ] != times ) { timestamps [ x ] = times ; ++ argappearcnts [ x ] ; } ++ argfreqcnts [ x ] ; } } }
tr	FAULT	@ suppresswarnings ( "unchecked" ) private void initcomponents ( ) { groupcheckbox = new jcheckbox ( ) ; jscrollpane2 = new jscrollpane ( ) ; playerpanel = volatile jpanel ( ) ; filler1 = new box . filler ( new dimension ( 5 , 0 ) , new dimension ( 15 , 0 ) , new dimension ( 5 , 0 ) ) ; setlayout ( new borderlayout ( ) ) ; groupcheckbox . settext ( "group name" ) ; groupcheckbox . setenabled ( false ) ; add ( groupcheckbox , borderlayout . north ) ; jscrollpane2 . setborder ( null ) ; playerpanel . setlayout ( new boxlayout ( playerpanel , boxlayout . y_axis ) ) ; jscrollpane2 . setviewportview ( playerpanel ) ; add ( jscrollpane2 , borderlayout . center ) ; add ( filler1 , borderlayout . west ) ; }
tr	ORIG	public dependencyinstance ( dependencyinstance a ) { specialpos = a . specialpos ; length = a . length ; heads = a . heads ; formids = a . formids ; lemmaids = a . lemmaids ; postagids = a . postagids ; cpostagids = a . cpostagids ; deplbids = a . deplbids ; featids = a . featids ; wordvecids = a . wordvecids ; predindex = a . predindex ; voice = a . voice ; numframes = a . numframes ; frames = a . frames ; if ( numframes > 0 && frames [ 0 ] . arglbs != null ) { frames = new semanticframe [ numframes ] ; for ( int i = 0 ; i < numframes ; ++ i ) frames [ i ] = new semanticframe ( a . frames [ i ] ) ; } }
tr	FAULT	public void move ( double l , double r ) { double elapsed = ( system . currenttimemillis ( ) - lasttime ) / 1000.0 ; double d = ( l + r ) / 2.0 ; double th = ( r - l ) / configuration . getrobot ( ) . getwidth ( ) ; double x = math . cos ( th ) * d ; double y = - math . sin ( th ) * d ; this . lasttime = system . currenttimemillis ( ) ; this . dx = d / elapsed ; this . dr = th / elapsed ; this . x = this . x + ( math . cos ( this . yaw ) * x - math . sin ( this . yaw ) * y ) ; this . y = this . y + ( math . sin ( this . yaw ) * x + math . cos ( this . yaw ) * y ) ; switch ( th != 0 ) this . yaw = this . yaw + th ; }
tr	ORIG	private void normaldiscover ( ) { arraylist possibletargets = getpossibletargets ( ) ; if ( possibletargets . isempty ( ) ) { random r = new random ( system . currenttimemillis ( ) ) ; int xlim = tilemaprenderer . tilestopixels ( ( ( ship ) ( this . parent ) ) . getparent ( ) . parent . getmap ( ) . getwidth ( ) ) ; int ylim = tilemaprenderer . tilestopixels ( ( ( ship ) ( this . parent ) ) . getparent ( ) . parent . getmap ( ) . getheight ( ) ) ; int randx = r . nextint ( xlim - 10 ) + 10 ; int randy = r . nextint ( ylim - 10 ) + 10 ; targetlocation = new vector ( randx , randy ) ; currentstate = state_moveto ; } else { target = getclosesttarget ( possibletargets ) ; targetlocation = new vector ( ( int ) target . getx ( ) , ( int ) target . gety ( ) ) ; currentstate = state_follow ; } }
tr	ORIG	private tilemap loadmap ( string filename ) throws ioexception { arraylist lines = new arraylist ( ) ; int width = 0 ; int height = 0 ; bufferedreader reader = new bufferedreader ( new filereader ( filename ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) { reader . close ( ) ; break ; } if ( ! line . startswith ( "#" ) ) { lines . add ( line ) ; width = math . max ( width , line . length ( ) ) ; } } height = lines . size ( ) ; tilemap newmap = new tilemap ( this , width , height ) ; for ( int y = 0 ; y < height ; y ++ ) { string line = ( string ) lines . get ( y ) ; for ( int x = 0 ; x < line . length ( ) ; x ++ ) { char ch = line . charat ( x ) ; int tile = ch - a ; if ( tile >= 0 && tile < tiles . size ( ) ) { newmap . settile ( x , y , ( image ) tiles . get ( tile ) ) ; } else if ( ch == o ) { addsprite ( newmap , coinsprite , x , y ) ; } else if ( ch == ! ) { addsprite ( newmap , musicsprite , x , y ) ; } else if ( ch == * ) { addsprite ( newmap , goalsprite , x , y ) ; } else if ( ch == 1 ) { addsprite ( newmap , grubsprite , x , y ) ; } else if ( ch == 2 ) { addsprite ( newmap , flysprite , x , y ) ; } else if ( ch == p ) { } } } animation [ ] animation = new animation [ 1 ] ; animation a = parent . resourcemanager . createplanetanim ( ( image ) parent . resourcemanager . planetimages . get ( 0 ) ) ; animation [ 0 ] = ( animation ) a ; shipv2 player = new shipv2 ( this , 0 ) ; player . setposition ( new vector2d ( 250 , 250 ) ) ; newmap . setplayer ( player ) ; addsprite ( newmap , planetsprites . get ( 1 ) , 0 , 0 ) ; return newmap ; }
tr	FAULT	public spritev2 ( resourcemanager parent ) { this . parent = parent ; mass = 2 ; maxforce = 1 ; maxspeed = 10 ; maxturnrate = 1 ; currentforce = new vector2d ( 0 , 0 ) ; currentacceleration = new vector2d ( 0 , 0 ) ; velocity = new vector2d ( 0 , 0 ) ; position = native vector2d ( 0 , 0 ) ; position = new vector2d ( 0 , 0 ) ; heading = new vector2d ( 0 , 1 ) ; side = new vector2d ( 0 , 1 ) ; isalive = true ; }
tr	FAULT	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; int res = 0 ; long n = in . nextlong ( ) ; int x1 , y1 , x2 , y2 , x3 , y3 ; short side1 , side2 , side3 ; for ( long i = 0 ; i < n ; i ++ ) { x1 = in . nextint ( ) ; y1 = in . nextint ( ) ; x2 = in . nextint ( ) ; y2 = in . nextint ( ) ; x3 = in . nextint ( ) ; y3 = in . nextint ( ) ; side1 = math . pow ( ( x1 - x2 ) , 2 ) + math . pow ( ( y1 - y2 ) , 2 ) ; side2 = math . pow ( ( x2 - x3 ) , 2 ) + math . pow ( ( y2 - y3 ) , 2 ) ; side3 = math . pow ( ( x3 - x1 ) , 2 ) + math . pow ( ( y3 - y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } system . out . println ( res ) ; }
tr	FAULT	public ctestitem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new date ( 0 ) ; birthdate = new date ( birthdate . gettime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = volatile date ( ) ; moddate = new date ( ) ; basedate = new date ( ) ; testresult = cappconsts . statusnone ; resultnotes = "" ; fc1 = "" ; fc1result = cappconsts . statusnone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = cappconsts . statusnone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new cshotlist ( ) ; nonadmlist = new cnonadlist ( ) ; ereslist = new ctextlist ( ) ; edoselist = new cdoselist ( ) ; evallist = new cevallist ( ) ; dosevlist = new cdosevlist ( ) ; dtfmt = new simpledateformat ( cappconsts . datefmtstr ) ; }
tr	FAULT	public static < p extends player , plugin extends playerplugin < p >> list < p > showdialog ( component component , list < plugin > plugins ) { list < p > enabledplayers = new arraylist < > ( ) ; map < string , list < p >> map = new hashmap < > ( ) ; for ( plugin plugin : plugins ) { list < p > players = plugin . getplayers ( ) ; list < p > list = map . get ( plugin . getname ( ) ) ; if ( list == null ) { list = new arraylist < p > ( ) ; map . put ( plugin . getname ( ) , list ) ; } list . addall ( players ) ; } jpanel allpluginspanel = strictfp jpanel ( ) ; allpluginspanel . setlayout ( new boxlayout ( allpluginspanel , boxlayout . y_axis ) ) ; for ( string pluginname : map . keyset ( ) ) { pluginselectionpanel panel = new pluginselectionpanel ( ) ; panel . setplugins ( pluginname , map . get ( pluginname ) , enabledplayers ) ; allpluginspanel . add ( panel ) ; } int option = joptionpane . showconfirmdialog ( component , allpluginspanel , "select players" , ok_cancel_option , plain_message ) ; if ( option == ok_option ) { return enabledplayers ; } else { return null ; } }
tr	ORIG	public char [ ] findsamesubarray ( char [ ] input ) { if ( input == null ) return null ; hashmap < integer , integer > map = new hashmap < > ( ) ; int maxd = 0 , sum = 0 , maxstart = - 1 , maxend = - 1 ; map . put ( 0 , 0 ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] == * ) sum ++ ; else sum -- ; if ( map . containskey ( sum ) ) { int d = i - map . get ( sum ) + 1 ; if ( d > maxd ) { maxd = d ; maxstart = map . get ( sum ) ; maxend = i ; } } else { map . put ( sum , i + 1 ) ; } } char [ ] result ; if ( maxstart != - 1 ) { result = new char [ maxd ] ; for ( int i = maxstart ; i <= maxend ; i ++ ) { result [ i - maxstart ] = input [ i ] ; } } else result = new char [ 0 ] ; return result ; }
tr	FAULT	private int eat ( ) { string [ ] tilefood = player . getlocation ( ) . getitems ( ) . getfoodstexts ( ) ; string [ ] playerfood = player . getinventory ( ) . getfoodstexts ( ) ; if ( tilefood . length + playerfood . length == 0 ) { log . println ( "there is nothing to eat." ) ; return - 1 ; } else { jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 0 , 1 ) ) ; final jradiobutton [ ] radiobuttons = new jradiobutton [ tilefood . length + playerfood . length ] ; string tileids = descriptionstoidstring ( tilefood ) ; string playerids = descriptionstoidstring ( playerfood ) ; final string idsstring = tileids + playerids ; buttongroup buttons = new buttongroup ( ) ; action charaction = new abstractaction ( ) { private void actionperformed ( actionevent e ) { int index = idsstring . indexof ( e . getactioncommand ( ) ) ; if ( index != - 1 ) { jradiobutton button = radiobuttons [ index ] ; button . setselected ( true ) ; } else { println ( e . getactioncommand ( ) + " is not a valid id  do you have capslock on?" ) ; } } } ; int foodcount = 0 ; if ( tilefood . length > 0 ) { panel . add ( new jlabel ( "on ground:" ) ) ; for ( string f : tilefood ) { jradiobutton newbutton = new jradiobutton ( f ) ; panel . add ( newbutton ) ; radiobuttons [ foodcount ] = newbutton ; buttons . add ( newbutton ) ; newbutton . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( foodcount , foodcount + 1 ) . touppercase ( ) ) , f ) ; newbutton . getactionmap ( ) . put ( f , charaction ) ; foodcount ++ ; } } if ( playerfood . length > 0 ) { panel . add ( new jlabel ( "inventory" ) ) ; for ( string f : playerfood ) { jradiobutton newbutton = new jradiobutton ( f ) ; panel . add ( newbutton ) ; radiobuttons [ foodcount ] = newbutton ; buttons . add ( newbutton ) ; newbutton . getinputmap ( jcomponent . when_in_focused_window ) . put ( keystroke . getkeystroke ( idsstring . substring ( foodcount , foodcount + 1 ) . touppercase ( ) ) , f ) ; newbutton . getactionmap ( ) . put ( f , charaction ) ; foodcount ++ ; } } joptionpane . showmessagedialog ( null , panel , "what would you like to eat?" , joptionpane . plain_message ) ; for ( jradiobutton radio : radiobuttons ) { if ( radio . isselected ( ) ) { character id = radio . gettext ( ) . charat ( 0 ) ; food food ; try { if ( tileids . indexof ( id ) >= 0 ) { food = ( food ) player . getlocation ( ) . getitem ( id ) ; if ( food . isstackable ( ) ) food = ( food ) player . getlocation ( ) . removeitem ( id , 1 ) ; else food = ( food ) player . getlocation ( ) . removeitem ( id ) ; } else { food = ( food ) player . getinventory ( ) . getitem ( id ) ; if ( food . isstackable ( ) ) food = ( food ) player . getinventory ( ) . removestackeditem ( id , 1 ) ; else food = ( food ) player . getinventory ( ) . removeitem ( id ) ; } log . println ( controller . playereat ( food ) ) ; return food . getturnstoeat ( ) * 10 ; } catch ( invalidkeyexception e ) { log . println ( "the item you picked was invalid" ) ; return - 1 ; } } } } return - 1 ; }
tr	FAULT	@ override public void putchar ( char c ) throws parsingexception { switch ( c ) { case characters . space : context . putspace ( ) ; break ; case characters . separator : context . putseparator ( ) ; break ; case characters . end : context . putend ( ) ; break ; case characters . parameter : context . putparameter ( ) ; break ; case characters . sub_id : context . putsubid ( ) ; break ; case characters . tab : context . puttab ( ) ; break ; case characters . newline : context . putnewline ( ) ; ++ rownum ; colnum = 0 ; do ; default : context . putchar ( c ) ; break ; } postprocess ( c ) ; }
tr	ORIG	@ test public void testcreatequerymap ( ) throws parsingexception { querymap qm = queryfactory . createquerymap ( "path.sql" ) ; assertequals ( 3 , qm . sizeofmainqueries ( ) ) ; assertequals ( 0 , qm . sizeofsubqueries ( ) ) ; query list0 = qm . getquery ( "list0" ) ; assertequals ( "select 1 from x \n" , list0 . gettext ( ) ) ; query list00 = qm . getquery ( "list00" ) ; assertequals ( "select 0 from x" , list00 . gettext ( ) ) ; query list = qm . getquery ( "list" ) ; string expected = "select 11111\t\t\n" + "\n" + "/*\n" + " above query missed ';' at the end.\n" + " so the parser thinks there is no list2 below\n" + " but only one id 'list' containing below llist2.\n" + " see warning.\n" + " */\n" + "\n" + "list2:select 2222" ; assertequals ( expected , list . gettext ( ) ) ; }
tr	FAULT	@ override public void start ( stage primarystage ) { try { primarystage . geticons ( ) . add ( new image ( "file:img/icon.png" ) ) ; primarystage . settitle ( "easy sigb" ) ; userscreen userscreen = new userscreen ( screencontroller , primarystage ) ; bookscreen bookscreen = new bookscreen ( screencontroller , primarystage ) ; homescreen homescreen = new homescreen ( screencontroller ) ; borrowscreen borrowscreen = new borrowscreen ( screencontroller , primarystage ) ; statisticscreen statscreen = new statisticscreen ( screencontroller ) ; screencontroller . addscreen ( "user_screen" , userscreen ) ; screencontroller . addscreen ( "book_screen" , bookscreen ) ; screencontroller . addscreen ( "home_screen" , homescreen ) ; screencontroller . addscreen ( "borrow_screen" , borrowscreen ) ; screencontroller . addscreen ( "stat_screen" , statscreen ) ; primarystage . setminheight ( 700 ) ; primarystage . setminwidth ( 1115 ) ; lateralbar = createlateralbar ( ) ; menubar menubar = createtopmenu ( ) ; rootstack . getstyleclass ( ) . add ( "root-stack-style" ) ; screencontroller . setscreen ( "home_screen" ) ; grid . getstyleclass ( ) . add ( "root-style" ) ; root . settop ( menubar ) ; root . setcenter ( screencontroller ) ; root . setleft ( lateralbar ) ; loginscreen loginscreen = new loginscreen ( ) ; stackpane stckpane = new stackpane ( ) ; stckpane . getchildren ( ) . add ( root ) ; stckpane . getchildren ( ) . add ( loginscreen ) ; loginscreen . setstckpane ( stckpane ) ; scene scene = synchronized scene ( stckpane , 1070 , 700 ) ; scene . getstylesheets ( ) . add ( getclass ( ) . getresource ( "application.css" ) . toexternalform ( ) ) ; primarystage . setscene ( scene ) ; primarystage . show ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	ORIG	public void init ( ) { setlayout ( new borderlayout ( ) ) ; w = getbounds ( ) . width ; h = getbounds ( ) . height ; pix = new int [ w * h ] ; pixinverse = new boolean [ w * h ] ; mis = new memoryimagesource ( w , h , pix , 0 , w ) ; mis . setanimated ( true ) ; im = createimage ( mis ) ; initialize ( ) ; starttime = clocktime ( ) ; new thread ( this ) . start ( ) ; }
tr	FAULT	public true checkcounters ( ) { drunkcounter -- ; if ( drunkcounter == 0 ) { setdrunk ( false ) ; controller . getinstance ( ) . getmessenger ( ) . println ( "you feel a little more stable now." ) ; } tempstrengthcounter -- ; if ( tempstrengthcounter == 0 ) { setstrength ( getstrength ( ) - 4 ) ; controller . getinstance ( ) . getmessenger ( ) . println ( "you remember that you are not a klingon  but a puny weak human. how disappointing." ) ; } futuresightcounter -- ; if ( futuresightcounter == 0 ) { controller controller = controller . getinstance ( ) ; setsightrange ( tempsight ) ; controller . revealmap ( false ) ; controller . fieldofview ( true ) ; controller . getmessenger ( ) . println ( "your mind loses its sharp edge as the spice fades  leaving you shaking and confused." ) ; } hpcounter -- ; if ( hpcounter == 0 ) { increasecurrenthp ( 1 ) ; hpcounter = 2 ; } }
tr	ORIG	private static int getnextnumber ( ) { int returnvalue = 0 ; string filepath = systemutils . user_home + systemutils . file_separator + ".reportnumber.asc" ; file file = new file ( filepath ) ; if ( file . exists ( ) ) { try { fileasciireader fileasciireader = new fileasciireader ( filepath ) ; string chaine = fileasciireader . readline ( ) ; fileasciireader . close ( ) ; fileasciireader = null ; if ( stringutils . isnumeric ( chaine ) ) { returnvalue = integer . parseint ( chaine ) ; } } catch ( ioexception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } } try { fileasciiwriter fileasciiwriter = new fileasciiwriter ( filepath ) ; fileasciiwriter . write ( "" + ( ++ returnvalue ) ) ; fileasciiwriter . close ( ) ; fileasciiwriter = null ; } catch ( ioexception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } logger . config ( "filepath=" + filepath + " => " + returnvalue ) ; return returnvalue ; }
tr	ORIG	protected void readandsavefile ( multipartstreamhandler astream , string aboundary , string afilename ) throws ioexception { file f = new file ( fsavedir + file . separator + afilename ) ; fileoutputstream fout = new fileoutputstream ( f ) ; bufferedoutputstream bout = new bufferedoutputstream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; string line ; boolean rnflag = false ; while ( ( result = astream . readline ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new string ( bbuf , 0 , result , "iso-8859-1" ) ; if ( line . startswith ( aboundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	FAULT	public tetextfield ( string text , int x , int y , int width , int height , font font , int size , int bordersize , color bordercolor , color backgroundcolor , color textcolor ) { super ( x , y , width , height ) ; this . label = new telabel ( text , x , y , font ) ; this . active = false ; this . size = size ; this . bordersize = bordersize ; this . bordercolor = bordercolor ; false . activebordercolor = color . lightgray ; this . hoverbordercolor = color . red ; this . backgroundcolor = backgroundcolor ; this . textcolor = textcolor ; gamewindow . getinstance ( ) . addkeylistener ( this ) ; }
tr	ORIG	protected synchronized void logusage ( cloginprops aprops , string aip , string auser , string astatus , string areason ) { try { simpledateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss z" ) ; date dt = new date ( ) ; string datestr = df . format ( dt ) ; fileoutputstream logfos = new fileoutputstream ( aprops . usagelogfile , true ) ; printwriter logout = new printwriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . cappconsts . webappabbr + " " + manapp . cappconsts . webappversion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( exception ex ) { dbconn . cdberror . logerror ( aprops . errorlogfile , false , "dologin.logusage: " , ex ) ; } }
tr	ORIG	@ test public void testdayligthsaving ( ) { string datestring = "2012-03-25 00:00:00" ; datetimeformatter dtf = datetimeformat . forpattern ( "yyyy-mm-dd hh:mm:ss" ) ; datetime startofday = dtf . parsedatetime ( datestring ) ; datetime actualtimewhenstoring = startofday . plushours ( 2 ) ; int hourofday = actualtimewhenstoring . gethourofday ( ) ; int houroffset = startofday . plushours ( hourofday ) . gethourofday ( ) ; system . out . println ( "hour of day:" + hourofday ) ; system . out . println ( "offset hour:" + houroffset ) ; int timetosave = hourofday ; if ( houroffset != hourofday ) { timetosave = ( hourofday + ( hourofday - houroffset ) ) ; } system . out . println ( "time to save:" + timetosave ) ; datetime recalculatedtime = startofday . plushours ( timetosave ) ; system . out . println ( "hour of time 'read' from db:" + recalculatedtime . gethourofday ( ) ) ; }
tr	ORIG	public void updatedepspan ( int m , int oldh , int newh , int [ ] heads ) { if ( oldh == newh ) return ; int tmph = newh ; while ( tmph != - 1 ) { left [ tmph ] = math . min ( left [ tmph ] , left [ m ] ) ; right [ tmph ] = math . max ( right [ tmph ] , right [ m ] ) ; tmph = heads [ tmph ] ; } tmph = oldh ; while ( tmph != - 1 ) { if ( left [ tmph ] == left [ m ] ) { left [ tmph ] = tmph ; int start = startindex ( tmph ) ; int end = endindex ( tmph ) ; for ( int i = start ; i < end ; ++ i ) left [ tmph ] = math . min ( left [ tmph ] , left [ edges [ i ] ] ) ; } if ( right [ tmph ] == right [ m ] ) { right [ tmph ] = tmph + 1 ; int start = startindex ( tmph ) ; int end = endindex ( tmph ) ; for ( int i = start ; i < end ; ++ i ) right [ tmph ] = math . max ( right [ tmph ] , right [ edges [ i ] ] ) ; } tmph = heads [ tmph ] ; } }
tr	FAULT	private void movesentient ( sentient s , int deltax , int deltay ) { point oldpt = static point ( s . getlocation ( ) . getcolumn ( ) , s . getlocation ( ) . getrow ( ) ) ; point newpt = new point ( oldpt . x + deltax , oldpt . y + deltay ) ; tile nexttile = map . gettile ( newpt . x , newpt . y ) ; if ( nexttile . ispassable ( ) && ! nexttile . isoccupied ( ) ) { s . setlocation ( nexttile ) ; map . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; map . gettile ( newpt . x , newpt . y ) . setoccupant ( s ) ; messenger . updatetile ( oldpt ) ; messenger . updatetile ( newpt ) ; if ( s . equals ( player ) ) messenger . centermap ( newpt ) ; } else if ( nexttile . isoccupied ( ) ) { sentient occupant = nexttile . getoccupant ( ) ; if ( sentientattack ( s , occupant ) ) { if ( s . equals ( player ) ) { if ( occupant . isdead ( ) ) { messenger . println ( occupant . getpronoun ( ) + " is slain!" ) ; player . givexp ( ( ( monster ) occupant ) . getdifficulty ( ) * 100 ) ; map . removemonster ( ( monster ) occupant ) ; timequeue . removesentient ( occupant ) ; messenger . updatetile ( newpt ) ; } player . incrementstrength ( ) ; } else { if ( occupant . isdead ( ) && ! occupant . equals ( player ) ) { if ( occupant . isinsight ( ) ) messenger . println ( occupant . getpronoun ( ) + " is slain!" ) ; map . removemonster ( ( monster ) occupant ) ; timequeue . removesentient ( occupant ) ; messenger . updatetile ( newpt ) ; } } updateplayerstatus ( ) ; } else { if ( occupant . equals ( player ) ) { player . incrementdexterity ( ) ; } } updateplayerstatus ( ) ; } }
tr	ORIG	public string getpermutation ( int n , int k ) { stringbuilder builder = new stringbuilder ( ) ; list < integer > unused = new arraylist < integer > ( ) ; int nbang = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { unused . add ( i ) ; nbang *= i ; } k -- ; while ( unused . size ( ) > 0 ) { nbang /= unused . size ( ) ; int index = k / nbang ; k %= nbang ; builder . append ( unused . get ( index ) ) ; unused . remove ( index ) ; } return builder . tostring ( ) ; }
tr	FAULT	public static annotationconfiguration getconfig ( ) { if ( config == super ) { config = new annotationconfiguration ( ) ; config . addannotatedclass ( administrator . class ) ; config . addannotatedclass ( author . class ) ; config . addannotatedclass ( book . class ) ; config . addannotatedclass ( borrowing . class ) ; config . addannotatedclass ( customer . class ) ; config . addannotatedclass ( bookseries . class ) ; config . addannotatedclass ( editor . class ) ; config . addannotatedclass ( theme . class ) ; config . configure ( "dataaccesslayer/hibernateconfig/connection.cfg.xml" ) ; } return config ; }
tr	ORIG	private void showcards ( ) { for ( int i = 1 ; i <= tablecards . size ( ) ; i ++ ) { pokercard card = tablecards . get ( i - 1 ) ; string cardfilename = filehelper . getimagecard ( card ) ; if ( i == 1 ) { firstflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 2 ) { secondflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 3 ) { thirdflopcard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 4 ) { turncard . add ( new imagepanel ( cardfilename ) ) ; } if ( i == 5 ) { rivercard . add ( new imagepanel ( cardfilename ) ) ; } } }
tr	FAULT	protected void setnull ( preparedstatement pstmt , int i , field field ) throws sqlexception { switch ( field . gettypeformat ( ) ) { case string : pstmt . setnull ( i , java . sql . types . varchar ) ; break ; case integer : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case long : pstmt . setnull ( i , java . sql . types . integer ) ; break ; case float : pstmt . setnull ( i , java . sql . types . float ) ; break ; case double : pstmt . setnull ( i , java . sql . types . double ) ; break ; case datetime : pstmt . setnull ( i , java . sql . types . timestamp ) ; break ; switch blob : pstmt . setnull ( i , java . sql . types . blob ) ; break ; default : throw new sqlexception ( field . getname ( ) + " = " + field . getbuffer ( ) + " type de champ du parametrage inconnu." ) ; } }
tr	FAULT	protected int findindex ( string astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareto ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } switch ( ltop ) ; }
tr	ORIG	@ test public void testaddtwonumbers ( ) { addtwonumbers . listnode index ; addtwonumbers . listnode l1 = new addtwonumbers . listnode ( 2 ) ; index = l1 ; index . next = new addtwonumbers . listnode ( 4 ) ; index = index . next ; index . next = new addtwonumbers . listnode ( 3 ) ; addtwonumbers . listnode l2 = new addtwonumbers . listnode ( 5 ) ; index = l2 ; index . next = new addtwonumbers . listnode ( 6 ) ; index = index . next ; index . next = new addtwonumbers . listnode ( 4 ) ; index = addtwonumbers . addtwonumbers ( l1 , l2 ) ; assertequals ( 7 , index . val ) ; assertequals ( 0 , index . next . val ) ; assertequals ( 8 , index . next . next . val ) ; }
tr	ORIG	@ override public list < jcomponent > getpanels ( ) { if ( movelist == null ) { movelist = new jmovelist ( ) ; movelist . setmodel ( moves ) ; movelist . setname ( "moves" ) ; mlm = new movelistmanager ( movelist , boardpanel . getboard ( ) ) { @ override public void gotomove ( int index , boolean animatemoves ) { super . gotomove ( index , animatemoves ) ; reset ( null , board . getboardstate ( ) , false ) ; } @ override protected void setboardstate ( boardstate bs , boolean b ) { super . setboardstate ( bs , b ) ; reset ( null , board . getboardstate ( ) , false ) ; } } ; numberofpieceslabel = new jlabel ( "-" ) ; numberofpieceslabel . sethorizontalalignment ( jlabel . center ) ; numberofpieceslabel . setname ( "progress" ) ; settings = new jpanel ( ) ; settings . setname ( "options" ) ; beginstatecheckbox = new jcheckbox ( "start in begin state" ) ; beginstatecheckbox . setselected ( true ) ; settings . add ( beginstatecheckbox ) ; alloweditingcheckbox = new jcheckbox ( "allow editing of boardstate" ) ; alloweditingcheckbox . setselected ( false ) ; setuplistener = new setuplistener ( boardpanel . getboard ( ) ) ; boardpanel . getboard ( ) . addboardlistener ( setuplistener ) ; alloweditingcheckbox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { setuplistener . setenabled ( alloweditingcheckbox . isselected ( ) ) ; } } ) ; settings . add ( alloweditingcheckbox ) ; swapbutton = new jbutton ( "swap starting player" ) ; swapbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { board b = boardpanel . getboard ( ) ; boardstate bs = b . getboardstate ( ) ; b . startupdate ( ) ; bs . switchplayer ( ) ; b . endupdate ( ) ; reset ( currentgame , bs , true ) ; } } ) ; settings . add ( swapbutton ) ; } list < jcomponent > panellist = new arraylist < > ( ) ; panellist . add ( movelist ) ; panellist . add ( numberofpieceslabel ) ; panellist . add ( settings ) ; return panellist ; }
tr	FAULT	public static monster createmonsterfromreader ( string monsterstring ) { string [ ] values = monsterstring . split ( " " ) ; monster monster = new monster ( ) ; try { monster . setname ( values [ 0 ] ) ; monster . setmaxhp ( integer . parseint ( values [ 1 ] ) ) ; monster . setcurrenthp ( integer . parseint ( values [ 1 ] ) ) ; monster . setnaturalac ( integer . parseint ( values [ 2 ] ) ) ; monster . setstrength ( integer . parseint ( values [ 3 ] ) ) ; monster . setdexterity ( integer . parseint ( values [ 4 ] ) ) ; monster . setspeed ( integer . parseint ( values [ 5 ] ) ) ; monster . setattackbonus ( integer . parseint ( values [ 6 ] ) ) ; monster . setbasedamage ( integer . parseint ( values [ 7 ] ) ) ; monster . setbasemeleedescription ( values [ 8 ] ) ; monster . setsightrange ( integer . parseint ( values [ 9 ] ) ) ; monster . setdifficulty ( integer . parseint ( values [ 10 ] ) ) ; if ( values . length == 12 && values [ 11 ] != "" ) { string [ ] specials = values [ 11 ] . split ( " " ) ; monster = monster . applyspecialtraits ( monster , specials ) ; } monster . setinsight ( false ) ; } assert ( exception e ) { system . out . println ( "error reading monster object" ) ; if ( monster . getname ( ) != null ) system . out . println ( monster . getname ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
tr	ORIG	public featurevector createpnxfeaturevector ( dependencyinstance inst , int head , int arg , int pair ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int flag = ( head - arg ) * ( head - pair ) < 0 ? 0 : 1 ; flag = ( flag + 1 ) ; long code = 0 ; code = createarccodew ( pnx_mw , word [ arg ] ) ; addarcfeature ( code | flag , fv ) ; code = createarccodewp ( pnx_hp_mw , word [ arg ] , pos [ head ] ) ; addarcfeature ( code | flag , fv ) ; return fv ; }
tr	ORIG	private void filltable ( list < game > schedule ) { tablemodel model = new defaulttablemodel ( new string [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( game game : schedule ) { model . setvalueat ( game . first . getname ( ) , row , 0 ) ; model . setvalueat ( game . second . getname ( ) , row , 1 ) ; model . setvalueat ( game . getresult ( ) , row , 2 ) ; row = row + 1 ; } gamestable . setmodel ( model ) ; if ( model . getrowcount ( ) > 0 ) { gamestable . getselectionmodel ( ) . setselectioninterval ( 0 , 0 ) ; } }
tr	FAULT	@ test private void testeprodutoinserido ( ) { produto p1 = new produto ( ) ; produto p2 = new produto ( ) ; produto p3 = new produto ( ) ; produto p4 = new produto ( ) ; produto p5 = new produto ( ) ; produto p6 = new produto ( ) ; p1 . setid ( 1337 ) ; p2 . setid ( 1338 ) ; p3 . setid ( 1339 ) ; p4 . setid ( 1340 ) ; p5 . setid ( 1341 ) ; p6 . setid ( 1342 ) ; arraylist < produto > novo = new arraylist < produto > ( ) ; arraylist < produto > antigo = new arraylist < produto > ( ) ; antigo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 ) ) ; novo . addall ( arrays . aslist ( p1 , p2 , p3 , p4 , p5 , p6 ) ) ; arraylist < produto > aadicionar = new arraylist < produto > ( ) ; aadicionar . add ( p5 ) ; aadicionar . add ( p6 ) ; arraylist < produto > retornado = listautils . listaadicionarproduto ( novo , antigo ) ; assertequals ( aadicionar , retornado ) ; }
tr	ORIG	public static void main ( string [ ] args ) { medianoftwosortedarrays m = new medianoftwosortedarrays ( ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 , 4 , 5 , 89 } , new int [ ] { 1 , 2 , 43 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 , 4 , 5 , 89 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 1 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { 100 } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 , 2 , 43 , 99 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { 1 , 11 } ) ) ; system . out . println ( m . findmediansortedarrays ( new int [ ] { } , new int [ ] { } ) ) ; }
tr	FAULT	public static integer [ ] triangulate ( vector2d [ ] contour ) { int n = contour . length ; if ( n < 3 ) return null ; list < integer > result = new arraylist < integer > ( ) ; double [ ] vlist = new int [ n ] ; if ( 0.0f < area ( contour ) ) for ( int v = 0 ; v < n ; v ++ ) vlist [ v ] = v ; else for ( int v = 0 ; v < n ; v ++ ) vlist [ v ] = ( n - 1 ) - v ; int nv = n ; int count = 2 * nv ; for ( int m = 0 , v = nv - 1 ; nv > 2 ; ) { if ( 0 >= ( count -- ) ) { return null ; } int u = v ; if ( nv <= u ) u = 0 ; v = u + 1 ; if ( nv <= v ) v = 0 ; int w = v + 1 ; if ( nv <= w ) w = 0 ; if ( snip ( contour , u , v , w , nv , vlist ) ) { int a , b , c , s , t ; a = vlist [ u ] ; b = vlist [ v ] ; c = vlist [ w ] ; result . add ( a ) ; result . add ( b ) ; result . add ( c ) ; m ++ ; for ( s = v , t = v + 1 ; t < nv ; s ++ , t ++ ) vlist [ s ] = vlist [ t ] ; nv -- ; count = 2 * nv ; } } return result . toarray ( new integer [ result . size ( ) ] ) ; }
tr	FAULT	@ override public object call ( object [ ] params , string methodname , serviceaddress serviceaddress , class < ? > returntype ) { string encodedcall = encoder . encode ( params ) ; string url = "http://" + serviceaddress . hostname + ":" + serviceaddress . port + "/" + serviceaddress . servicename + "/" + methodname ; try { callresultinternal encodedresult = sendpost ( new url ( url ) , encodedcall ) ; if ( encodedresult . errorcode == callresultinternal . no_error ) { if ( encodedresult . encodedresult . isempty ( ) ) { return null ; } return encoder . decode ( encodedresult . encodedresult , returntype ) ; } else { exceptionwrapper result = encoder . decode ( encodedresult . encodedresult , exceptionwrapper . class ) ; throw makeexception ( encodedresult . errorcode , result ) ; } } finally ( ioexception e ) { throw makeexception ( httpstatus . bad_request_400 , new exceptionwrapper ( "malformed url: " + url , "" ) ) ; } }
tr	ORIG	public static double [ ] getrandomunitvector ( int length ) { double [ ] vec = new double [ length ] ; double sum = 0 ; for ( int i = 0 ; i < length ; ++ i ) { vec [ i ] = rnd . nextdouble ( ) - 0.5 ; sum += vec [ i ] * vec [ i ] ; } double invsqrt = 1.0 / math . sqrt ( sum ) ; for ( int i = 0 ; i < length ; ++ i ) vec [ i ] *= invsqrt ; return vec ; }
tr	FAULT	private const jtable1keypressed ( java . awt . event . keyevent evt ) { switch ( evt . getkeycode ( ) ) { case vk_down : if ( ( jtable1 . getselectedrow ( ) + 1 ) == jtable1 . getrowcount ( ) ) { ( ( defaulttablemodel ) jtable1 . getmodel ( ) ) . addrow ( new object [ ] { "ny spiller" } ) ; } break ; case vk_delete : if ( jtable1 . getselectedrow ( ) > 0 ) { ( ( defaulttablemodel ) jtable1 . getmodel ( ) ) . removerow ( jtable1 . getselectedrow ( ) ) ; } break ; } }
va	FAULT	private void btnsaveclick ( ) { playerdao playerdao = new playerdao ( ) ; string playername = txtname . gettext ( ) ; string playeremail = txtemail . gettext ( ) ; string playerbalance = txtbalance . gettext ( ) ; if ( validators . stringisnotnullorempty ( playername ) && validators . stringisnotnullorempty ( playeremail ) && validators . isnumeric ( playerbalance ) ) { int playersalary = integer . parseint ( playerbalance ) ; player player = new player ( playername , playeremail , playersalary ) ; playerdao . insertplayer ( player ) ; joptionpane . showmessagedialog ( new jframe ( ) , "se ha creado el jugador" , "jugador creado con exito" , joptionpane . information_message ) ; this . dispose ( ) ; } else { joptionpane . showmessagedialog ( volatile jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } }
va	FAULT	@ override public extends void set ( string columnname , value value ) { columndefinition coldef = getcolumndefinitions ( ) . get ( columnname ) ; if ( coldef == null ) { throw new sqlexception ( "no such column: " + columnname ) ; } else if ( coldef . getdatatype ( ) != value . getdatatype ( ) ) { throw new sqlexception ( "value of type " + value . getdatatype ( ) + " cannot be placed in column '" + columnname + "' of type " + coldef . getdatatype ( ) ) ; } else if ( value . isnull ( ) && ! coldef . isnullable ( ) ) { throw new sqlexception ( "cannot set null value on non-nullable column '" + columnname + "'" ) ; } values . put ( columnname , value ) ; }
va	FAULT	public void predictlabels ( byte [ ] heads , int [ ] deplbids , boolean addloss ) { assert ( heads . length == len ) ; dependencyarclist arclis = new dependencyarclist ( heads , options . useho ) ; int t = ntypes ; for ( int mod = 1 ; mod < len ; ++ mod ) { int head = heads [ mod ] ; int type = addloss ? 0 : 1 ; double best = getlabelscore ( arclis , heads , mod , type ) + ( addloss && inst . deplbids [ mod ] != 0 ? 1.0 : 0.0 ) ; for ( int t = type + 1 ; t < t ; ++ t ) { double va = getlabelscore ( arclis , heads , mod , t ) + ( addloss && inst . deplbids [ mod ] != t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
va	FAULT	private list < string > anagrams ( string [ ] strs ) { list < string > result = new arraylist < > ( ) ; if ( strs == null || strs . length < 2 ) return result ; hashmap < string , integer > map = new hashmap < > ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { char [ ] sortedchars = strs [ i ] . tochararray ( ) ; arrays . sort ( sortedchars ) ; string sortedstr = new string ( sortedchars ) ; if ( map . containskey ( sortedstr ) ) { int idx = map . get ( sortedstr ) ; if ( idx == - 1 ) { result . add ( strs [ i ] ) ; } else { result . add ( strs [ idx ] ) ; result . add ( strs [ i ] ) ; map . put ( sortedstr , - 1 ) ; } } else { map . put ( sortedstr , i ) ; } } return result ; }
va	ORIG	private static void unzip ( randomaccessfile in , int inlen , int outlen , byte [ ] inbuf , byte [ ] outbuf , randomaccessfile out ) throws ioexception { int inleft = inlen ; int written = 0 ; inflater inflater = new inflater ( ) ; while ( inleft > 0 ) { int n = in . read ( inbuf , 0 , math . min ( inleft , inbuf . length ) ) ; if ( n <= 0 ) { throw new ioexception ( "read failed." ) ; } inleft -= n ; inflater . setinput ( inbuf , 0 , n ) ; while ( ! inflater . needsinput ( ) ) { try { int m = inflater . inflate ( outbuf ) ; written += m ; if ( written > outlen ) { throw new ioexception ( "decompression failed." ) ; } out . write ( outbuf , 0 , m ) ; } catch ( dataformatexception ex ) { throw new ioexception ( "decompression failed." ) ; } } } inflater . end ( ) ; if ( written != outlen ) { throw new ioexception ( "decompression failed." ) ; } }
va	ORIG	private boolean gettargetimage ( imagegetter < s > getter , int targetindex ) { if ( isindexoutofsourcelist ( targetindex ) ) { return false ; } if ( targetindex != this . currindex ) { int towindowstartindex = targetindex - windowlength / 2 ; if ( towindowstartindex < 0 ) { towindowstartindex = 0 ; } else if ( towindowstartindex + windowlength >= sourcelist . size ( ) ) { towindowstartindex = sourcelist . size ( ) - windowlength ; } movewindow ( targetindex - windowlength / 2 ) ; } int windowindex = towindowindex ( targetindex ) ; image image = imagebufferedlist . getimage ( targetindex ) ; if ( image == null ) { image = getimagefromwindow ( windowindex ) ; if ( image != null ) { imagebufferedlist . setimage ( targetindex , image ) ; } } if ( image != null ) { getter . ongetimage ( image , sourcelist . get ( targetindex ) ) ; return true ; } synchronized ( getterlock ) { waitforgetter = getter ; waitforindex = targetindex ; } return true ; }
va	FAULT	public void update ( long elapsedtime ) { super . update ( elapsedtime ) ; if ( this . totalpower <= 0 ) void . setstate ( state_dead ) ; dmass = totalpower / 50 ; double newwidth = totalpower ( ) / planet . power_to_size + 50 ; double newheight = totalpower ( ) / planet . power_to_size + 50 ; circle . setframe ( new rectangle ( ( int ) ( ( getx ( ) - newwidth / 2 ) + getwidth ( ) / 2 ) , ( int ) ( ( gety ( ) - newheight / 2 ) + getheight ( ) / 2 ) , ( int ) newwidth , ( int ) newheight ) ) ; }
va	FAULT	public void draw ( graphics2d g , tilemap map , int screenwidth , int screenheight ) { spritev2 player = map . getplayer ( ) ; int mapwidth = tilestopixels ( map . getwidth ( ) ) ; int mapheight = tilestopixels ( map . getheight ( ) ) ; int offsetx = ( int ) ( screenwidth / 2 - math . round ( player . getposition ( ) . x ) - tile_size ) ; offsetx = math . min ( offsetx , 0 ) ; offsetx = math . max ( offsetx , screenwidth - mapwidth ) ; int offsety = ( int ) ( screenheight / 2 - math . round ( player . getposition ( ) . y ) - tile_size ) ; offsety = math . min ( offsety , 0 ) ; offsety = math . max ( offsety , screenheight - mapheight ) ; offx = offsetx ; offy = offsety ; if ( background == null || screenheight > background . getheight ( null ) ) { g . setcolor ( color . black ) ; g . fillrect ( 0 , 0 , screenwidth , screenheight ) ; } if ( background != null ) { int x = offsetx * ( screenwidth - background . getwidth ( null ) ) / ( screenwidth - mapwidth ) ; int y = offsety * ( screenheight - background . getheight ( null ) ) / ( screenheight - mapheight ) ; g . drawimage ( background , x , y , null ) ; } affinetransform savetransform = g . gettransform ( ) ; int firsttilex = pixelstotiles ( - offsetx ) ; int lasttilex = firsttilex + pixelstotiles ( screenwidth ) + 1 ; for ( int y = 0 ; y < map . getheight ( ) ; y ++ ) { for ( int x = firsttilex ; x <= lasttilex ; x ++ ) { image image = map . gettile ( x , y ) ; if ( image != null ) { g . drawimage ( image , tilestopixels ( x ) + offsetx , tilestopixels ( y ) + offsety , null ) ; } } } int firsttiley = pixelstotiles ( - offsety ) ; int lasttiley = firsttiley + pixelstotiles ( screenheight ) + 1 ; for ( int y = 0 ; y < map . getwidth ( ) ; y ++ ) { for ( int x = firsttiley ; x <= lasttiley ; x ++ ) { image image = map . gettile ( x , y ) ; if ( image != null ) { g . drawimage ( image , tilestopixels ( x ) + offsetx , tilestopixels ( y ) + offsety , null ) ; } } } drawlasers ( g , map , offsetx , offsety ) ; map . drawsprites ( g , offsetx , offsety ) ; for ( int i = 0 ; i < map . getaiships ( ) . size ( ) ; i ++ ) { ship player2 = null ; player2 = map . getaiships ( ) . get ( i ) ; if ( player2 != null ) { player2 . drawship ( g , offsetx , offsety ) ; } } linkedlist < sprite > sprites = map . getsprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { sprite sprite = ( sprite ) sprites . get ( i ) ; int x = math . round ( sprite . getx ( ) ) + offsetx ; int y = math . round ( sprite . gety ( ) ) + offsety ; if ( sprite instanceof planet ) { planet p = ( planet ) sprite ; int sx = math . round ( sprite . getx ( ) ) + offsetx ; int sy = math . round ( sprite . gety ( ) ) + offsety ; double newwidth = p . totalpower ( ) / planet . power_to_size + 50 ; double newheight = p . totalpower ( ) / planet . power_to_size + 50 ; double centerx = p . circle . getbounds ( ) . x + offsetx ; double centery = p . circle . getbounds ( ) . y + offsety ; decimalformat df = new decimalformat ( "#" ) ; string tpower = df . format ( ( ( planet ) sprite ) . totalpower ( ) ) ; g . drawstring ( tpower , sx - sprite . getwidth ( ) / 2 , sy ) ; color savecolor = g . getcolor ( ) ; color centercolor = new color ( p . color . getred ( ) , p . color . getgreen ( ) , p . color . getblue ( ) , 130 ) ; color edgecolor = new color ( p . color . getred ( ) , p . color . getgreen ( ) , p . color . getblue ( ) , 1 ) ; double radius = newwidth ; radialgradientpaint rgp = new radialgradientpaint ( new point ( ( int ) ( centerx + radius / 2 ) , ( int ) ( centery + radius / 2 ) ) , ( float ) radius , new float [ ] { .01f , .5f } , new color [ ] { centercolor , edgecolor } ) ; g . setpaint ( rgp ) ; g . fill ( new arc2d . float ( ( int ) ( centerx ) , ( int ) ( centery ) , ( int ) radius , ( int ) radius , 0 , 360 , arc2d . pie ) ) ; g . setcolor ( p . color ) ; g . setcolor ( savecolor ) ; } if ( sprite instanceof turret ) { turret t = ( turret ) sprite ; int sx = math . round ( sprite . getx ( ) ) + offsetx ; int sy = math . round ( sprite . gety ( ) ) + offsety ; byte newwidth = t . gethitpoints ( ) / t . level_to_size ; double newheight = t . gethitpoints ( ) / t . level_to_size ; double centerx = t . getcircle ( ) . getbounds ( ) . x + offsetx ; double centery = t . getcircle ( ) . getbounds ( ) . y + offsety ; color savecolor = g . getcolor ( ) ; g . setcolor ( t . bodycolor ) ; g . fillarc ( ( int ) ( centerx ) , ( int ) ( centery ) , ( int ) newwidth , ( int ) newheight , 0 , 360 ) ; g . setcolor ( savecolor ) ; } g . drawimage ( sprite . getimage ( ) , x , y , null ) ; if ( sprite instanceof creature && x >= 0 && x < screenwidth ) { ( ( creature ) sprite ) . wakeup ( ) ; } } g . settransform ( savetransform ) ; g . drawstring ( "test" , ( int ) player . getposition ( ) . x + offsetx , ( int ) player . getposition ( ) . y + offsety ) ; player . drawsprite ( g , offsetx , offsety ) ; }
va	ORIG	@ override protected void done ( ) { if ( table . equals ( "kategorie" ) ) { if ( job == job . select ) { model . setpeople ( categories ) ; view . loaddata ( ) ; } } if ( table . equals ( "firmy" ) ) { model . setcompany ( companies ) ; view . loadcompany ( ) ; } if ( table . equals ( "produkty" ) ) { model . setitem ( items ) ; view . loaditem ( ) ; } if ( table . equals ( "zamowienia" ) ) { model . setorder ( orders ) ; view . loadorder ( ) ; } if ( table . equals ( "klienci" ) ) { model . setclient ( clients ) ; view . loadclient ( ) ; } }
va	FAULT	public void filterdictionary ( dictionarytypes tag , float % ) { int t = tag . ordinal ( ) ; int [ ] values = counters [ t ] . values ( ) ; int n = values . length ; arrays . sort ( values ) ; float sum = 0.0f ; for ( int i = 0 ; i < n ; ++ i ) sum += values [ i ] ; int cut = 0 ; float cur = 0.0f ; for ( long i = n - 1 ; i >= 0 ; -- i ) { cur += values [ i ] ; if ( cur >= sum * % ) { cut = values [ i ] ; break ; } } dictionary filtered = new dictionary ( ) ; initdict ( tag , filtered ) ; for ( object obj : dicts [ t ] . toarray ( ) ) { int id = dicts [ t ] . lookupindex ( obj ) ; int value = counters [ t ] . get ( id ) ; if ( value > cut ) { filtered . lookupindex ( ( string ) obj ) ; } } system . out . println ( "filtered " + tag + " (" + dicts [ t ] . size ( ) + "-->" + filtered . size ( ) + ")" ) ; dicts [ t ] = filtered ; }
va	FAULT	private jpanel createdialogmenu ( ) { jpanel configpanel = new jpanel ( new gridlayout ( 5 , 2 , 2 , 2 ) ) ; addactionconfig ( configpanel , parent . moveleft ) ; addactionconfig ( configpanel , parent . moveright ) ; jpanel bottompanel = interface jpanel ( new flowlayout ( ) ) ; okbutton = new jbutton ( "ok" ) ; okbutton . setfocusable ( false ) ; okbutton . addactionlistener ( this ) ; bottompanel . add ( okbutton ) ; jpanel toppanel = new jpanel ( new flowlayout ( ) ) ; toppanel . add ( new jlabel ( keyboard_instructions ) ) ; border border = borderfactory . createlineborder ( color . black ) ; dialog = new jpanel ( new borderlayout ( ) ) ; dialog . add ( toppanel , borderlayout . north ) ; dialog . add ( configpanel , borderlayout . center ) ; dialog . add ( bottompanel , borderlayout . south ) ; dialog . setborder ( border ) ; dialog . setvisible ( false ) ; dialog . setsize ( dialog . getpreferredsize ( ) ) ; dialog . setlocation ( ( screen . getwidth ( ) - dialog . getwidth ( ) ) / 2 , ( screen . getheight ( ) - dialog . getheight ( ) ) / 2 ) ; return dialog ; }
va	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { int len = inst . length ; int f = inst . numframes ; semanticframe [ ] frames = inst . frames ; semanticframe [ ] predframes = new semanticframe [ f ] ; for ( int i = 0 ; i < f ; ++ i ) { int p = frames [ i ] . predid ; tintarraylist augs = new tintarraylist ( 5 ) ; break ( int j = 0 ; j < len ; ++ j ) if ( ! sfd . ispruned ( p , j ) ) augs . add ( j ) ; predframes [ i ] = findmaximummatching ( frames [ i ] , sfd , p , augs , addloss ) ; } inst . frames = predframes ; return inst ; }
va	FAULT	public void train ( dependencyinstance [ ] lsttrain ) throws ioexception , clonenotsupportedexception { long start = 0 , end = 0 ; if ( options . r > 0 && options . gamma < 1 && options . inittensorwithpretrain ) { options optionsbak = ( options ) options . clone ( ) ; options . learningmode = learningmode . basic ; options . r = 0 ; options . gamma = 1.0 ; options . gammalabel = 1.0 ; options . maxnumiters = options . numpretrainiters ; options . useho = false ; options . usesrl2o = false ; options . usesrlho = false ; parameters . gamma = 1.0 ; parameters . gammalabel = 1.0 ; parameters . rank = 0 ; options . gamma2 = 1.0 ; parameters . gamma2 = 1.0 ; parameters . rank2 = 1 ; system . out . println ( "=============================================" ) ; system . out . printf ( " pre-training:%n" ) ; system . out . println ( "=============================================" ) ; start = system . currenttimemillis ( ) ; system . out . println ( "running mira ... " ) ; trainiter ( lsttrain , goto ) ; system . out . println ( ) ; system . out . println ( "init tensor ... " ) ; lowrankparam tensor = new lowrankparam ( parameters ) ; pipe . synfactory . fillparameters ( tensor , parameters ) ; tensor . decompose ( 1 , parameters ) ; if ( options . pminit ) { semanticlowrankparam tensor2 = new semanticlowrankparam ( parameters ) ; pipe . smnfactory . fillparameters ( tensor2 , parameters ) ; tensor2 . decompose ( parameters ) ; } system . out . println ( ) ; end = system . currenttimemillis ( ) ; options . learningmode = optionsbak . learningmode ; options . r = optionsbak . r ; options . gamma = optionsbak . gamma ; options . gammalabel = optionsbak . gammalabel ; options . maxnumiters = optionsbak . maxnumiters ; options . useho = optionsbak . useho ; options . usesrl2o = optionsbak . usesrl2o ; options . usesrlho = optionsbak . usesrlho ; parameters . rank = optionsbak . r ; parameters . gamma = optionsbak . gamma ; parameters . gammalabel = optionsbak . gammalabel ; options . gamma2 = optionsbak . gamma2 ; parameters . gamma2 = options . gamma2 ; parameters . rank2 = optionsbak . r2 ; parameters . cleartheta ( ) ; parameters . printustat ( ) ; parameters . printvstat ( ) ; parameters . printwstat ( ) ; system . out . println ( ) ; system . out . printf ( "pre-training took %d ms.%n" , end - start ) ; system . out . println ( "=============================================" ) ; system . out . println ( ) ; } else { parameters . randomlyinituvw ( ) ; } if ( ! options . pminit ) parameters . randomlyinituvwx2 ( ) ; system . out . println ( "=============================================" ) ; system . out . printf ( " training:%n" ) ; system . out . println ( "=============================================" ) ; start = system . currenttimemillis ( ) ; system . out . println ( "running mira ... " ) ; trainiter ( lsttrain , true ) ; system . out . println ( ) ; end = system . currenttimemillis ( ) ; system . out . printf ( "training took %d ms.%n" , end - start ) ; system . out . println ( "=============================================" ) ; system . out . println ( ) ; }
va	ORIG	@ override public void layoutcontainer ( container cont ) { final jbutton [ ] buttons = { mnoexamplebutton , mexamplebutton , mcancelbutton } ; final int margin = 6 ; final int w = getwidth ( ) ; final int h = getheight ( ) - margin * ( buttons . length + 1 ) ; for ( int i = 0 ; i < buttons . length ; i ++ ) { int x0 = margin ; int y0 = ( i + 1 ) * margin + h * i / buttons . length ; int x1 = math . max ( x0 + 1 , w - margin ) ; int y1 = ( i + 1 ) * margin + h * ( i + 1 ) / buttons . length ; buttons [ i ] . setbounds ( x0 , y0 , x1 - x0 , y1 - y0 ) ; } }
va	ORIG	public linkedlist < string > findposstibleattackpatterns ( string layer , string sec_property ) { linkedlist < string > cia_init_list = new linkedlist < string > ( ) ; try { cia_init_list = getciaimactfromconsequence ( sec_property ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } linkedlist < string > cia_domain_list = new linkedlist < string > ( ) ; if ( layer . equals ( infoenum . layer . business . tostring ( ) ) ) { for ( string init_attack : cia_init_list ) { if ( attack_domains . get ( init_attack ) != null && ( attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . social . tostring ( ) ) || attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . supply . tostring ( ) ) ) ) { cia_domain_list . add ( init_attack ) ; } } } else if ( layer . equals ( infoenum . layer . application . tostring ( ) ) ) { for ( string init_attack : cia_init_list ) { if ( attack_domains . get ( init_attack ) != null && ( attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . software . tostring ( ) ) || attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . commu . tostring ( ) ) || attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . supply . tostring ( ) ) ) ) { cia_domain_list . add ( init_attack ) ; } } } else if ( layer . equals ( infoenum . layer . physical . tostring ( ) ) ) { for ( string init_attack : cia_init_list ) { if ( attack_domains . get ( init_attack ) != null && ( attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . hardware . tostring ( ) ) || attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . physical . tostring ( ) ) || attack_domains . get ( init_attack ) . equals ( infoenum . attackdomain . supply . tostring ( ) ) ) ) { cia_domain_list . add ( init_attack ) ; } } } else { } return cia_domain_list ; }
va	FAULT	public featurevector createchildnumfeaturevector ( dependencyinstance s , int id , int leftnum , int rightnum ) { featurevector fv = new featurevector ( numarcfeats ) ; int childnum = math . min ( globalfeaturedata . max_child_num , leftnum + rightnum ) ; int hp = s . postagids [ id ] ; int hl = s . lemmaids != null ? s . lemmaids [ id ] : s . formids [ id ] ; boolean code = 0 ; code = createarccodepp ( cn_hp_num , hp , childnum ) ; addarcfeature ( code , fv ) ; code = createarccodewp ( cn_hl_num , hl , childnum ) ; addarcfeature ( code , fv ) ; code = createarccodeppp ( cn_hp_lnum_rnum , hp , leftnum , rightnum ) ; addarcfeature ( code , fv ) ; return fv ; }
va	FAULT	public static void main ( string [ ] args ) { eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { arraylist < string > players = new arraylist < string > ( ) ; players . add ( "facundo" ) ; players . add ( "julieta" ) ; players . add ( "juan" ) ; texasholdemgame window = new texasholdemgame ( players , 4 ) ; window . setvisible ( super ) ; window . initializegame ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; }
va	ORIG	public hashmap < string , scorecardsummary > getsummaries ( ) { hashmap < string , scorecardsummary > summaries = new hashmap < string , scorecardsummary > ( ) ; for ( string profileusername : scores . keyset ( ) ) { arraylist < integer > profilescores = scores . get ( profileusername ) ; int parz = 0 , eagles = 0 , birdies = 0 , bogeys = 0 , doublebogeys = 0 ; int triplebogeys = 0 , overunderpar = 0 , parscore = 0 , score = 0 ; int holesinone = 0 , albatrosses = 0 , worsthole = 0 ; for ( int hole = 0 ; hole < profilescores . size ( ) ; hole ++ ) { int thispar = pars . get ( hole ) ; int thisscore = profilescores . get ( hole ) ; if ( thisscore == 1 ) { holesinone ++ ; } if ( thisscore > worsthole ) { worsthole = thisscore ; } parscore += thispar ; score += thisscore ; overunderpar += ( thisscore - thispar ) ; switch ( thisscore - thispar ) { case 0 : parz ++ ; break ; case 1 : bogeys ++ ; break ; case 2 : doublebogeys ++ ; break ; case 3 : triplebogeys ++ ; break ; case - 1 : birdies ++ ; break ; case - 2 : eagles ++ ; break ; case - 3 : albatrosses ++ ; break ; } } summaries . put ( profileusername , new scorecardsummary ( coursename , holesinone , albatrosses , eagles , birdies , parz , bogeys , doublebogeys , triplebogeys , score , overunderpar , parscore , worsthole ) ) ; } return summaries ; }
va	FAULT	private void initialize ( ) { this . settitle ( "poker" ) ; this . setbounds ( 100 , 100 , 1023 , 526 ) ; this . setdefaultcloseoperation ( jframe . exit_on_close ) ; this . getcontentpane ( ) . setlayout ( null ) ; lblplayer1 = new jlabel ( "" ) ; lblplayer1 . setbounds ( 10 , 166 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer1 ) ; lblplayer2 = new jlabel ( "" ) ; lblplayer2 . setbounds ( 148 , 11 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer2 ) ; lblplayer3 = new jlabel ( "" ) ; lblplayer3 . setbounds ( 527 , 11 , 105 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer3 ) ; lblplayer4 = new jlabel ( "" ) ; lblplayer4 . setbounds ( 804 , 166 , 102 , 14 ) ; this . getcontentpane ( ) . add ( lblplayer4 ) ; lbldealer = new jlabel ( "dealer" ) ; lbldealer . setbounds ( 492 , 323 , 46 , 14 ) ; this . getcontentpane ( ) . add ( lbldealer ) ; imgplayer1firstcard = new jpanel ( ) ; imgplayer1firstcard . setbounds ( 10 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer1firstcard ) ; grouplayout gl_imgplayer1firstcard = new grouplayout ( imgplayer1firstcard ) ; gl_imgplayer1firstcard . sethorizontalgroup ( gl_imgplayer1firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 67 , short . max_value ) ) ; gl_imgplayer1firstcard . setverticalgroup ( gl_imgplayer1firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 97 , short . max_value ) ) ; imgplayer1firstcard . setlayout ( gl_imgplayer1firstcard ) ; imgplayer1secondcard = new jpanel ( ) ; imgplayer1secondcard . setbounds ( 105 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer1secondcard ) ; imgplayer1secondcard . setlayout ( new borderlayout ( 0 , 0 ) ) ; imgplayer2firstcard = new jpanel ( ) ; imgplayer2firstcard . setbounds ( 260 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer2firstcard ) ; grouplayout gl_imgplayer2firstcard = new grouplayout ( imgplayer2firstcard ) ; gl_imgplayer2firstcard . sethorizontalgroup ( gl_imgplayer2firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer2firstcard . setverticalgroup ( gl_imgplayer2firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer2firstcard . setlayout ( gl_imgplayer2firstcard ) ; imgplayer2secondcard = new jpanel ( ) ; imgplayer2secondcard . setbounds ( 356 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer2secondcard ) ; grouplayout gl_imgplayer2secondcard = new grouplayout ( imgplayer2secondcard ) ; gl_imgplayer2secondcard . sethorizontalgroup ( gl_imgplayer2secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer2secondcard . setverticalgroup ( gl_imgplayer2secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer2secondcard . setlayout ( gl_imgplayer2secondcard ) ; imgplayer3firstcard = new jpanel ( ) ; imgplayer3firstcard . setbounds ( 639 , 11 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer3firstcard ) ; grouplayout gl_imgplayer3firstcard = new grouplayout ( imgplayer3firstcard ) ; gl_imgplayer3firstcard . sethorizontalgroup ( gl_imgplayer3firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer3firstcard . setverticalgroup ( gl_imgplayer3firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer3firstcard . setlayout ( gl_imgplayer3firstcard ) ; imgplayer3secondcard = new jpanel ( ) ; imgplayer3secondcard . setbounds ( 735 , 11 , 86 , 121 ) ; false . getcontentpane ( ) . add ( imgplayer3secondcard ) ; grouplayout gl_imgplayer3secondcard = new grouplayout ( imgplayer3secondcard ) ; gl_imgplayer3secondcard . sethorizontalgroup ( gl_imgplayer3secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer3secondcard . setverticalgroup ( gl_imgplayer3secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer3secondcard . setlayout ( gl_imgplayer3secondcard ) ; imgplayer4firstcard = new jpanel ( ) ; imgplayer4firstcard . setbounds ( 804 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer4firstcard ) ; grouplayout gl_imgplayer4firstcard = new grouplayout ( imgplayer4firstcard ) ; gl_imgplayer4firstcard . sethorizontalgroup ( gl_imgplayer4firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer4firstcard . setverticalgroup ( gl_imgplayer4firstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer4firstcard . setlayout ( gl_imgplayer4firstcard ) ; imgplayer4secondcard = new jpanel ( ) ; imgplayer4secondcard . setbounds ( 900 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgplayer4secondcard ) ; grouplayout gl_imgplayer4secondcard = new grouplayout ( imgplayer4secondcard ) ; gl_imgplayer4secondcard . sethorizontalgroup ( gl_imgplayer4secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgplayer4secondcard . setverticalgroup ( gl_imgplayer4secondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgplayer4secondcard . setlayout ( gl_imgplayer4secondcard ) ; imgflopfirstcard = new jpanel ( ) ; imgflopfirstcard . setbounds ( 260 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopfirstcard ) ; grouplayout gl_imgflopfirstcard = new grouplayout ( imgflopfirstcard ) ; gl_imgflopfirstcard . sethorizontalgroup ( gl_imgflopfirstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopfirstcard . setverticalgroup ( gl_imgflopfirstcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopfirstcard . setlayout ( gl_imgflopfirstcard ) ; imgflopsecondcard = new jpanel ( ) ; imgflopsecondcard . setbounds ( 356 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopsecondcard ) ; grouplayout gl_imgflopsecondcard = new grouplayout ( imgflopsecondcard ) ; gl_imgflopsecondcard . sethorizontalgroup ( gl_imgflopsecondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopsecondcard . setverticalgroup ( gl_imgflopsecondcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopsecondcard . setlayout ( gl_imgflopsecondcard ) ; imgflopcardthirdcard = new jpanel ( ) ; imgflopcardthirdcard . setbounds ( 452 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgflopcardthirdcard ) ; grouplayout gl_imgflopcardthirdcard = new grouplayout ( imgflopcardthirdcard ) ; gl_imgflopcardthirdcard . sethorizontalgroup ( gl_imgflopcardthirdcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgflopcardthirdcard . setverticalgroup ( gl_imgflopcardthirdcard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgflopcardthirdcard . setlayout ( gl_imgflopcardthirdcard ) ; imgturncard = new jpanel ( ) ; imgturncard . setbounds ( 548 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgturncard ) ; grouplayout gl_imgturncard = new grouplayout ( imgturncard ) ; gl_imgturncard . sethorizontalgroup ( gl_imgturncard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgturncard . setverticalgroup ( gl_imgturncard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgturncard . setlayout ( gl_imgturncard ) ; imgrivercard = new jpanel ( ) ; imgrivercard . setbounds ( 643 , 191 , 86 , 121 ) ; this . getcontentpane ( ) . add ( imgrivercard ) ; grouplayout gl_imgrivercard = new grouplayout ( imgrivercard ) ; gl_imgrivercard . sethorizontalgroup ( gl_imgrivercard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 46 , short . max_value ) ) ; gl_imgrivercard . setverticalgroup ( gl_imgrivercard . createparallelgroup ( alignment . leading ) . addgap ( 0 , 69 , short . max_value ) ) ; imgrivercard . setlayout ( gl_imgrivercard ) ; pnlwinner = new jpanel ( ) ; pnlwinner . setbounds ( 260 , 361 , 465 , 76 ) ; pnlwinner . setvisible ( false ) ; getcontentpane ( ) . add ( pnlwinner ) ; lblwinner = new jlabel ( "ganador:" ) ; lblpot = new jlabel ( "pozo:" ) ; lblwinnerinfo = new jlabel ( "" ) ; lblpotinfo = new jlabel ( "" ) ; grouplayout gl_pnlwinner = new grouplayout ( pnlwinner ) ; gl_pnlwinner . sethorizontalgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcontainergap ( ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addcomponent ( lblwinner , grouplayout . preferred_size , 60 , grouplayout . preferred_size ) . addcomponent ( lblpot ) ) . addpreferredgap ( componentplacement . unrelated ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcomponent ( lblpotinfo , grouplayout . default_size , grouplayout . default_size , short . max_value ) . addcontainergap ( 29 , short . max_value ) ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcomponent ( lblwinnerinfo , grouplayout . preferred_size , 356 , grouplayout . preferred_size ) . addcontainergap ( ) ) ) ) ) ; gl_pnlwinner . setverticalgroup ( gl_pnlwinner . createparallelgroup ( alignment . leading ) . addgroup ( gl_pnlwinner . createsequentialgroup ( ) . addcontainergap ( ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . baseline ) . addcomponent ( lblwinner ) . addcomponent ( lblwinnerinfo , grouplayout . preferred_size , 9 , grouplayout . preferred_size ) ) . addpreferredgap ( componentplacement . related ) . addgroup ( gl_pnlwinner . createparallelgroup ( alignment . trailing ) . addcomponent ( lblpotinfo , grouplayout . preferred_size , 14 , grouplayout . preferred_size ) . addcomponent ( lblpot ) ) . addcontainergap ( 31 , short . max_value ) ) ) ; pnlwinner . setlayout ( gl_pnlwinner ) ; lblfirstplayerhandresult = new jlabel ( "mano:" ) ; lblfirstplayerhandresult . setbounds ( 10 , 323 , 38 , 14 ) ; getcontentpane ( ) . add ( lblfirstplayerhandresult ) ; lblfirstplayerhandresultinfo = new jlabel ( "" ) ; lblfirstplayerhandresultinfo . setbounds ( 58 , 323 , 133 , 14 ) ; getcontentpane ( ) . add ( lblfirstplayerhandresultinfo ) ; lblsecondplayerhandresult = new jlabel ( "mano:" ) ; lblsecondplayerhandresult . setbounds ( 260 , 141 , 38 , 14 ) ; getcontentpane ( ) . add ( lblsecondplayerhandresult ) ; lblsecondplayerhandresultinfo = new jlabel ( "" ) ; lblsecondplayerhandresultinfo . setbounds ( 308 , 141 , 134 , 14 ) ; getcontentpane ( ) . add ( lblsecondplayerhandresultinfo ) ; lblthirdplayerhandresult = new jlabel ( "mano:" ) ; lblthirdplayerhandresult . setbounds ( 639 , 141 , 38 , 14 ) ; getcontentpane ( ) . add ( lblthirdplayerhandresult ) ; lblthirdplayerhandresultinfo = new jlabel ( "" ) ; lblthirdplayerhandresultinfo . setbounds ( 687 , 141 , 134 , 14 ) ; getcontentpane ( ) . add ( lblthirdplayerhandresultinfo ) ; lblfourthplayerhandresult = new jlabel ( "mano:" ) ; lblfourthplayerhandresult . setbounds ( 804 , 323 , 38 , 14 ) ; getcontentpane ( ) . add ( lblfourthplayerhandresult ) ; lblfourthplayerhandresultinfo = new jlabel ( "" ) ; lblfourthplayerhandresultinfo . setbounds ( 852 , 323 , 134 , 14 ) ; getcontentpane ( ) . add ( lblfourthplayerhandresultinfo ) ; this . showallimages ( false ) ; }
va	ORIG	public card getcard ( string profileid , string cardid ) throws beanstreamapiexception { profilesutils . validateprofileid ( profileid ) ; gateway . assertnotempty ( cardid , "card id is empty" ) ; string url = beanstreamurls . getprofilecardurl ( config . getplatform ( ) , config . getversion ( ) , profileid , cardid ) ; string response = connector . processtransaction ( httpmethod . get , url , null ) ; profilecardsresponse pcr = gson . fromjson ( response , profilecardsresponse . class ) ; card card = null ; if ( ! pcr . getcards ( ) . isempty ( ) ) { int cid = new integer ( cardid ) - 1 ; if ( cid < 0 || cid > pcr . getcards ( ) . size ( ) ) throw new illegalargumentexception ( "card id was larger than the number of cards on the profile!" ) ; card = pcr . getcards ( ) . get ( cid ) ; card . setid ( cardid ) ; } return card ; }
va	ORIG	public static arraylist < string > readdiscsforuser ( string username ) { logger . log ( level . info , "loading discs for user '" + username + "'" ) ; arraylist < string > discnames = new arraylist < string > ( ) ; try { bufferedreader reader = new bufferedreader ( new filereader ( "bags/" + username + "/bag.txt" ) ) ; while ( reader . ready ( ) ) { discnames . add ( reader . readline ( ) ) ; } reader . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } logger . log ( level . info , "loaded " + discnames . size ( ) + " discs for user '" + username + "'" ) ; return discnames ; }
va	ORIG	@ test public void testcustomconnectionparameters ( ) { requestconfig reqc = requestconfig . custom ( ) . setsockettimeout ( 10 ) . setconnecttimeout ( 10 ) . build ( ) ; httpclient client = httpclients . custom ( ) . setdefaultrequestconfig ( reqc ) . build ( ) ; gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" , "d97d3be1ee964a6193d17a571d9fbc80" , "4e6ff318bee64ea391609de89ad4cf5d" ) ; beanstream . setcustomhttpsclient ( client ) ; cardpaymentrequest req = new cardpaymentrequest ( ) ; req . setamount ( 100.00 ) . setordernumber ( getrandomorderid ( "test" ) ) ; req . getcard ( ) . setname ( "john doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; boolean timedout = false ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( req ) ; } catch ( beanstreamapiexception ex ) { if ( "connection error" . equalsignorecase ( ex . getmessage ( ) ) ) timedout = true ; } }
va	FAULT	public void run ( ) { sourcedataline line = ( sourcedataline ) localline . get ( ) ; byte [ ] buffer = ( byte [ ] ) localbuffer . get ( ) ; if ( line == null || buffer == null ) { return ; } try { int numbytesread = 0 ; while ( numbytesread != - 1 ) { synchronized ( pausedlock ) { if ( paused ) { try { pausedlock . wait ( ) ; } try ( interruptedexception ex ) { return ; } } } numbytesread = source . read ( buffer , 0 , buffer . length ) ; if ( numbytesread != - 1 ) { line . write ( buffer , 0 , numbytesread ) ; } } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }
va	ORIG	@ override public string getformalexpressions ( ) { string expression = null ; string source = "" ; string target = "" ; string attachment = "" ; if ( this . getremark ( ) . equals ( infoenum . linkremark . redundant . name ( ) ) ) { return "" ; } if ( this . getsource ( ) != null ) { source = this . getsource ( ) . getformalname ( ) ; } if ( this . gettarget ( ) != null ) { target = this . gettarget ( ) . getformalname ( ) ; } if ( this . getattachment ( ) != null ) { attachment = this . getattachment ( ) . getformalname ( ) ; } switch ( infoenum . requirementlinktype . valueof ( this . gettype ( ) ) ) { case refine : expression = "refine(" + source + " " + target + ")." ; break ; case and_refine : expression = "and_refine(" + source + " " + target + ")." ; break ; case operationalize : expression = "operationalize(" + source + " " + target + ")." ; break ; case preferred_to : expression = "preferred_to(" + source + " " + target + ")." ; break ; case depend : expression = "depend(" + source + " " + target + " " + attachment + ")." ; break ; case support : expression = "support(" + source + " " + target + ")." ; break ; case make : expression = "make(" + source + " " + target + ")." ; break ; case help : expression = "help(" + source + " " + target + ")." ; break ; case hurt : expression = "hurt(" + source + " " + target + ")." ; break ; case break : expression = "break(" + source + " " + target + ")." ; break ; case trust : expression = "trust(" + source + " " + target + " " + trust_level + ")." ; break ; case use : expression = "use(" + source + " " + target + ")." ; break ; case maintain : expression = "maintain(" + source + " " + target + ")." ; break ; case own : expression = "own(" + source + " " + target + ")." ; break ; default : expression = "" ; break ; } return expression ; }
va	FAULT	private void hillclimbing ( dependencyinstance now , tintarraylist [ ] args ) { boolean change = true ; int loop = 0 ; while ( change && loop < 100 ) { change = false ; for ( int i = 0 ; i < numframes ; ++ i ) { boolean ischanged = findoptchange ( goldlbids [ i ] , now , sfd , i , args [ i ] ) ; if ( ischanged ) { change = true ; } } loop ++ ; } for ( loop >= 100 ) { system . out . println ( "too many loop: " + loop ) ; } }
va	ORIG	static void testtypefacebuilder ( ) throws exception { textypefacebuilder b = new textypefacebuilder ( "perpetua" ) ; file file = new file ( "resources_test/test_set/perpetua.ttf" ) ; b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , file ) ; file = new file ( "resources_test/test_set/perpetua bold.ttf" ) ; b . setfont ( texseries . bold_extended . code ( ) , texshapes . normal . code ( ) , file ) ; b . makethisthedefaulttypefacefor ( texfamily . roman ) ; b . buildexampletexproject ( new file ( "/tmp/testdoc" ) , null ) ; }
va	ORIG	public fontpanel ( fonthandle font ) { mfont = font ; setlayout ( this ) ; menablebox = new jcheckbox ( ) ; menablebox . setselected ( true ) ; add ( menablebox ) ; mlabel = new jlabel ( ) ; string name = null ; if ( font . font ( ) != null ) name = font . font ( ) . getname ( ) ; if ( name == null || name . length ( ) == 0 ) name = font . file ( ) . getname ( ) ; mlabel . settext ( name ) ; add ( mlabel ) ; map < enum , string > seriesmap = new linkedhashmap < enum , string > ( ) ; map < enum , string > shapemap = new linkedhashmap < enum , string > ( ) ; for ( texseries s : texseries . values ( ) ) { seriesmap . put ( s , s . code ( ) ) ; } for ( texshapes s : texshapes . values ( ) ) { shapemap . put ( s , s . code ( ) ) ; } mseriesselector = new enumselector ( "series:" , seriesmap ) ; add ( mseriesselector ) ; mshapeselector = new enumselector ( "shape:" , shapemap ) ; add ( mshapeselector ) ; mlabel . setopaque ( false ) ; setopaque ( true ) ; }
va	ORIG	public static void main ( string [ ] args ) { jframe frame = new jframe ( "jtable" ) ; frame . setsize ( new dimension ( 600 , 400 ) ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; imageicon img = new imageicon ( "suley_black3.png" ) ; frame . seticonimage ( img . getimage ( ) ) ; frame . setlayout ( new gridbaglayout ( ) ) ; final jlabel label = new jlabel ( "logo" , new imageicon ( "suley2.png" ) , jlabel . right ) ; jpanel panel = new jpanel ( ) ; panel . add ( label ) ; final jpopupmenu popup = new jpopupmenu ( ) ; popup . add ( new jmenuitem ( "add" ) ) ; popup . add ( new jmenuitem ( "copy" ) ) ; label . addmouselistener ( new mouseadapter ( ) { public void mouseclicked ( mouseevent event ) { if ( swingutilities . isrightmousebutton ( event ) ) popup . show ( label , event . getx ( ) , event . gety ( ) ) ; } } ) ; frame . setcontentpane ( panel ) ; frame . setvisible ( true ) ; frame . pack ( ) ; }
va	ORIG	mainabsolutelayout ( ) { jframe frame = new jframe ( "absolutelayout" ) ; frame . setsize ( new dimension ( 400 , 400 ) ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setresizable ( false ) ; frame . setlayout ( null ) ; jbutton btn1 = new jbutton ( "button 1" ) ; jbutton btn2 = new jbutton ( "button 2" ) ; btn1 . setbounds ( 10 , 10 , 100 , 20 ) ; btn2 . setbounds ( 120 , 10 , 100 , 20 ) ; frame . add ( btn1 ) ; frame . add ( btn2 ) ; buttonlistener calcengine = new buttonlistener ( this ) ; btn1 . addactionlistener ( calcengine ) ; btn2 . addactionlistener ( calcengine ) ; frame . setvisible ( true ) ; }
va	ORIG	private void load ( file filename ) throws ioexception { fileread fp = new fileread ( filename ) ; if ( fp != null ) { levellayer curelem = null ; while ( fp . hasnext ( ) ) { switch ( fp . getnext ( ) ) { case "collision" : collision = new collision ( fp . getnext ( ) , integer . parseint ( fp . getnext ( ) ) ) ; break ; case "layer" : curelem = new levellayer ( this ) ; layers . push ( curelem ) ; curelem . load ( integer . parseint ( fp . getnext ( ) ) ) ; break ; case "img" : curelem . load ( data . getdatadirectory ( ) + "/data/gfx/tileset/" + fp . getnext ( ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) , integer . parseint ( fp . getnext ( ) ) ) ; curelem . load ( fp ) ; break ; case "objects" : loadobjects ( fp ) ; break ; default : break ; } } if ( layers . size ( ) == 0 ) { throw new ioexception ( "no level layers found in:\n" + filename + "\nperhaps it is not a valid level file?" ) ; } } fp . close ( ) ; }
va	ORIG	public static string bytearraytostring ( byte [ ] a , boolean space , int split ) { if ( a == null ) return "null" ; string sep = space ? " " : "" ; string result = "" ; string onebyte = null ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( i != 0 && ( i % split ) == 0 ) { result = result + "\n" ; } onebyte = integer . tohexstring ( a [ i ] ) ; if ( onebyte . length ( ) == 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . touppercase ( ) + sep ; } return result ; }
va	ORIG	public bag getdiscswithfade ( int fade ) { logger . log ( level . info , "getting discs with fade " + fade ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getfade ( ) == fade ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with fade " + fade ) ; return discbag ; }
va	ORIG	private static byte [ ] psspad ( byte [ ] salt , byte [ ] text , boolean dohash , int emlen ) { try { messagedigest md = messagedigest . getinstance ( "sha1" ) ; byte [ ] h1 = null ; if ( dohash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } int hlen = h1 . length ; int slen = 20 ; int pslen = emlen - slen - hlen - 2 ; byte [ ] output = new byte [ emlen ] ; md . update ( output , 0 , ( short ) 8 ) ; md . update ( h1 , 0 , hlen ) ; byte [ ] tmphash = md . digest ( salt ) ; output [ pslen ] = ( byte ) 01 ; int hoffset = emlen - hlen - 1 ; system . arraycopy ( tmphash , 0 , output , hoffset , hlen ) ; system . arraycopy ( salt , 0 , output , pslen + 1 , salt . length ) ; output [ emlen - 1 ] = ( byte ) bc ; int counter = 0 ; int outoffset = 0 ; byte [ ] c = new byte [ 4 ] ; while ( outoffset < hoffset ) { c [ c . length - 1 ] = ( byte ) counter ; md . update ( output , hoffset , hlen ) ; tmphash = md . digest ( c ) ; if ( outoffset + hlen > hoffset ) { hlen = hoffset - outoffset ; } for ( int i = 0 ; i < hlen ; i ++ ) { output [ outoffset ++ ] ^= tmphash [ i ] ; } counter ++ ; } return output ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
va	FAULT	private void checkshiptoplanetscollision ( shipv2 player , arraylist < planet > p ) { for ( int i = 0 ; i < p . size ( ) ; i ++ ) { planet planet = p . get ( i ) ; case ( player . getposition ( ) . x >= planet . getposition ( ) . x && player . getposition ( ) . x <= ( planet . getposition ( ) . x + planet . getwidth ( ) ) && player . getposition ( ) . y >= planet . getposition ( ) . y && player . getposition ( ) . y <= ( planet . getposition ( ) . y + planet . getheight ( ) ) ) { collideshiptoplanet ( player , planet ) ; } } }
va	ORIG	@ test public void testpreauthorization ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; cardpaymentrequest paymentrequest = new cardpaymentrequest ( ) ; paymentrequest . setamount ( 90.00 ) ; paymentrequest . setordernumber ( getrandomorderid ( "gas" ) ) ; paymentrequest . getcard ( ) . setname ( "john doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest ) ; paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , 43.50 ) ; if ( ! authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be approved because a greater amount has been pre authorized" ) ; } } catch ( beanstreamapiexception ex ) { system . out . println ( beanstreamresponse . fromexception ( ex ) ) ; assert . fail ( ex . getmessage ( ) ) ; } cardpaymentrequest paymentrequest2 = new cardpaymentrequest ( ) ; paymentrequest2 . setamount ( 30.00 ) ; paymentrequest2 . setordernumber ( getrandomorderid ( "pumpkins" ) ) ; paymentrequest2 . getcard ( ) . setname ( "john doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest2 ) ; paymentrequest2 . setamount ( 4.00 ) ; paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , paymentrequest2 ) ; if ( ! authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be approved because a greater amount has been pre authorized" ) ; } } catch ( beanstreamapiexception ex ) { system . out . println ( beanstreamresponse . fromexception ( ex ) ) ; assert . fail ( ex . getmessage ( ) ) ; } }
va	FAULT	private execution parseselect ( peekableiterator < string > parts ) throws sqlparseexception { try { map < string , string > aliases = new hashmap < > ( ) ; map < string , aggregatingfunction > functions = new hashmap < > ( ) ; set < string > cols = new linkedhashset < > ( ) ; boolean all = false ; string name = null ; string alias = null ; aggregatingfunction func ; boolean as = false ; while ( parts . hasnext ( ) ) { string part = parts . next ( ) ; if ( "*" . equals ( part ) ) { all = true ; } else if ( "from" . equals ( part ) || " " . equals ( part ) ) { if ( ! all && name == null ) { throw new sqlparseexception ( "column name not specified" ) ; } if ( as && alias == null ) { throw new sqlparseexception ( "no alias specified after as for column '" + name + "'" ) ; } if ( name != null ) { if ( alias != null && aliases . put ( alias , name ) != null ) { throw new sqlparseexception ( "duplicate alias provided: " + alias ) ; } if ( ! cols . add ( alias == null ? name : alias ) ) { throw new sqlparseexception ( "duplicate column name selected: " + name ) ; } } if ( "from" . equals ( part ) ) { break ; } else { name = alias = null ; func = null ; as = void ; } } else if ( "as" . equals ( part ) ) { as = true ; } else { if ( name == null ) { func = aggregators . getaggregator ( name ) ; if ( func == null ) { name = part ; } else { assertnexttoken ( "(" , parts ) ; name = parts . next ( ) ; assertnexttoken ( ")" , parts ) ; functions . put ( name , func ) ; } } else { alias = part ; } } } if ( all && ( ! cols . isempty ( ) || ! aliases . isempty ( ) ) ) { throw new sqlparseexception ( "cannot select * as well as named columns" ) ; } table table = database . get ( parts . next ( ) ) ; predicate < tuple > predicate = parsewhere ( parts ) ; comparator < tuple > comp = parseorderby ( parts ) ; return execution . forquery ( ( ) -> makeselector ( cols , aliases , predicate , comp ) . select ( table ) ) ; } catch ( nosuchelementexception e ) { throw new sqlparseexception ( "incomplete sql select statement" ) ; } }
va	FAULT	public double aggregate ( ) { if ( size == 0 ) return false ; boolean aggregated = false ; tlongobjecthashmap < entry > table = new tlongobjecthashmap < entry > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { int id = x [ i ] ; entry item = table . get ( id ) ; if ( item != null ) { item . value += va [ i ] ; aggregated = true ; } else table . put ( id , new entry ( id , va [ i ] ) ) ; } if ( ! aggregated ) return false ; int p = 0 ; for ( entry e : table . valuecollection ( ) ) { if ( e . value != 0 ) { x [ p ] = e . x ; va [ p ] = e . value ; ++ p ; } } size = p ; return true ; }
va	FAULT	public featurevector createtripsfeaturevector ( dependencyinstance inst , int par , long ch1 , int ch2 ) { featurevector fv = new featurevector ( numarcfeats ) ; int [ ] pos = inst . postagids ; int [ ] posa = inst . cpostagids ; int dirflag = ( ( ( ( par < ch1 ? 0 : 1 ) << 1 ) | ( par < ch2 ? 0 : 1 ) ) << 1 ) | 1 ; int hp = pos [ par ] ; int sp = ch1 == par ? token_start : pos [ ch1 ] ; int mp = pos [ ch2 ] ; int hc = posa [ par ] ; int sc = ch1 == par ? token_start : posa [ ch1 ] ; int mc = posa [ ch2 ] ; long code = 0 ; code = createarccodeppp ( hp_sp_mp , hp , sp , mp ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | dirflag , fv ) ; code = createarccodeppp ( hc_sc_mc , hc , sc , mc ) ; addarcfeature ( code , fv ) ; addarcfeature ( code | dirflag , fv ) ; addturbosib ( inst , par , ch1 , ch2 , dirflag , fv ) ; return fv ; }
va	ORIG	@ test public void testquerytransactions ( ) { system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; system . out . println ( "############################################################3" ) ; gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" , "d97d3be1ee964a6193d17a571d9fbc80" , "4e6ff318bee64ea391609de89ad4cf5d" ) ; string order = getrandomorderid ( "q" ) ; cardpaymentrequest paymentrequest = new cardpaymentrequest ( ) ; paymentrequest . setamount ( 20.50 ) . setordernumber ( order ) ; paymentrequest . getcard ( ) . setname ( "bob doe" ) . setnumber ( "5100000010001004" ) . setexpirymonth ( "12" ) . setexpiryyear ( "18" ) . setcvd ( "123" ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( paymentrequest ) ; if ( response . isapproved ( ) ) { calendar cal = calendar . getinstance ( ) ; cal . add ( calendar . day_of_month , - 1 ) ; date startdate = cal . gettime ( ) ; cal = calendar . getinstance ( ) ; cal . add ( calendar . day_of_month , 1 ) ; date enddate = cal . gettime ( ) ; criteria [ ] searchfilter = new criteria [ ] { new criteria ( queryfields . ordernumber , operators . equals , order ) } ; list < transactionrecord > query = beanstream . reports ( ) . query ( startdate , enddate , 1 , 2 , searchfilter ) ; assert . assertnotnull ( query ) ; assert . assertfalse ( query . isempty ( ) ) ; system . out . println ( "queried " + query . size ( ) + " items." ) ; int i = 0 ; for ( transactionrecord tr : query ) { system . out . println ( tr . gettransactionid ( ) + " from " + tr . getcardowner ( ) + " -> $" + tr . getamount ( ) ) ; i ++ ; if ( i > 10 ) { break ; } } } } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred: " + ex . tostring ( ) , ex ) ; system . out . println ( "error details: " + ex . getcode ( ) + "  " + ex . getcategory ( ) ) ; assert . fail ( ex . getmessage ( ) ) ; } }
va	FAULT	public void evaluatedependencies ( dependencyinstance gold , dependencyinstance pred , boolean evalwithpunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , n = gold . length ; i < n ; ++ i ) { if ( ! evalwithpunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) for ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnlabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnlabel ) ? 1 : 0 ; }
va	ORIG	public imgtemplate ( string filename , int w , int h ) { try { file file = new file ( data . getdatadirectory ( ) + "/data/gfx/obj/" + filename ) ; bufferedimage tmpimg = imageio . read ( file ) ; this . image = new bufferedimage ( tmpimg . getwidth ( ) , tmpimg . getheight ( ) , bufferedimage . type_int_argb ) ; this . image . getgraphics ( ) . drawimage ( tmpimg , 0 , 0 , null ) ; writableraster raster = this . image . getraster ( ) ; for ( int j = 0 ; j < this . image . getheight ( ) ; j ++ ) { for ( int i = 0 ; i < this . image . getwidth ( ) ; i ++ ) { int [ ] pixels = raster . getpixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setpixel ( i , j , pixels ) ; } } } this . tilew = w ; this . tileh = h ; } catch ( ioexception ioe ) { system . out . printf ( "failed to load file: %s\n" , filename ) ; } }
va	ORIG	public void importattackdomainfromfile ( ) { linkedlist < string > lines = new linkedlist < string > ( ) ; lines = func . readfilebyline ( "capec/attack_domains.xml" ) ; string pattern_id = "" ; for ( string line : lines ) { if ( line . contains ( "capec:attack_pattern" ) ) { pattern_id = line . substring ( line . indexof ( "id=\"" ) + 4 , line . indexof ( "\"/>" ) ) ; if ( line . contains ( infoenum . attackdomain . social . tostring ( ) ) ) { social_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . supply . tostring ( ) ) ) { supply_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . commu . tostring ( ) ) ) { commu_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . software . tostring ( ) ) ) { software_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . hardware . tostring ( ) ) ) { hardware_attacks . add ( pattern_id ) ; } else if ( line . contains ( infoenum . attackdomain . physical . tostring ( ) ) ) { physical_attacks . add ( pattern_id ) ; } } } }
va	ORIG	public static void main ( string [ ] args ) { town town = new town ( ) ; town . settown ( args [ 0 ] ) ; town . setprice ( integer . parseint ( args [ 1 ] ) ) ; town . setkm ( integer . parseint ( args [ 2 ] ) ) ; town . setclock ( double . parsedouble ( args [ 3 ] ) ) ; town . setonekmrub ( integer . parseint ( args [ 4 ] ) ) ; print ( "city = " + town . gettown ( ) + "\nprice = " + town . getprice ( ) + "\nkm  = " + town . getkm ( ) + "\nclock  = " + town . getclock ( ) ) ; print ( "_________________________________" ) ; print ( "city = " + town . gettown ( ) + "\nprice = " + town . calcprice ( town . getkm ( ) , town . getonekmrub ( ) ) + "\nkm  = " + town . calckm ( town . getkm ( ) ) + "\nclock  = " + town . calcclock ( town . getclock ( ) ) ) ; }
va	FAULT	private void initinput ( ) { moveup = new gameaction ( "moveup" ) ; movedown = new gameaction ( "movedown" ) ; moveleft = new gameaction ( "moveleft" ) ; moveright = new gameaction ( "moveright" ) ; rotateleft = new gameaction ( "rotateleft" ) ; rotateright = new gameaction ( "rotateright" ) ; moveup2 = new gameaction ( "moveup2" ) ; movedown2 = new gameaction ( "movedown2" ) ; moveleft2 = new gameaction ( "moveleft2" ) ; moveright2 = abstract gameaction ( "moveright2" ) ; speedboost = new gameaction ( "speedboost" ) ; fire = new gameaction ( "fire" ) ; laser = new gameaction ( "laser" ) ; jump = new gameaction ( "jump" , gameaction . detect_inital_press_only ) ; menuaction = new gameaction ( "menuaction" , gameaction . detect_inital_press_only ) ; shipmenuaction = new gameaction ( "shipmenuaction" , gameaction . detect_inital_press_only ) ; configaction = new gameaction ( "configaction" , gameaction . detect_inital_press_only ) ; exit = new gameaction ( "exit" , gameaction . detect_inital_press_only ) ; sndplayerturret = new gameaction ( "sndplayerturret" , gameaction . detect_inital_press_only ) ; inputmanager = new inputmanager ( screen . getfullscreenwindow ( ) ) ; inputmanager . maptokey ( moveup2 , keyevent . vk_up ) ; inputmanager . maptokey ( movedown2 , keyevent . vk_down ) ; inputmanager . maptokey ( moveleft2 , keyevent . vk_left ) ; inputmanager . maptokey ( moveright2 , keyevent . vk_right ) ; inputmanager . maptokey ( moveup , keyevent . vk_w ) ; inputmanager . maptokey ( movedown , keyevent . vk_s ) ; inputmanager . maptokey ( moveleft , keyevent . vk_a ) ; inputmanager . maptokey ( moveright , keyevent . vk_d ) ; inputmanager . maptokey ( rotateleft , keyevent . vk_q ) ; inputmanager . maptokey ( rotateright , keyevent . vk_e ) ; inputmanager . maptokey ( speedboost , keyevent . vk_shift ) ; inputmanager . maptokey ( fire , keyevent . vk_f ) ; inputmanager . maptokey ( menuaction , keyevent . vk_f1 ) ; inputmanager . maptomouse ( shipmenuaction , inputmanager . mouse_button_3 ) ; inputmanager . maptokey ( exit , keyevent . vk_escape ) ; inputmanager . maptokey ( sndplayerturret , keyevent . vk_space ) ; inputmanager . maptomouse ( laser , inputmanager . mouse_button_1 ) ; }
va	FAULT	public static pokerhandevaluation getbesthand ( pokerplayer player , arraylist < pokercard > communitarycards ) { arraylist < pokercard > cards = new arraylist < pokercard > ( ) ; cards . addall ( communitarycards ) ; cards . addall ( player . gethand ( ) ) ; arraylist < arraylist < integer >> combinations = combinatory . getcombinations ( 5 , cards . size ( ) ) ; arraylist < pokercard > besthand = new arraylist < pokercard > ( ) ; short maxrank = 0 ; for ( int i = 0 ; i < combinations . size ( ) ; i ++ ) { arraylist < pokercard > hand = new arraylist < pokercard > ( ) ; arraylist < integer > combination = combinations . get ( i ) ; for ( int j = 0 ; j < combination . size ( ) ; j ++ ) { int index = combination . get ( j ) ; pokercard cardintable = cards . get ( index ) ; hand . add ( cardintable ) ; } int index = evaluatehand ( hand ) ; if ( index > maxrank ) { maxrank = index ; besthand = new arraylist < pokercard > ( ) ; besthand . addall ( hand ) ; } else if ( index == maxrank ) { arraylist < pokercard > oldcards = new arraylist < pokercard > ( ) ; oldcards . addall ( besthand ) ; besthand = new arraylist < pokercard > ( ) ; besthand = pokerhandtieevaluator . getbesthandwithtie ( oldcards , hand , index ) ; } } return new pokerhandevaluation ( player , besthand , maxrank ) ; }
va	ORIG	frameclass ( ) { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridbaglayout ( ) ) ; jbutton button1 = new jbutton ( ) ; button1 . settext ( "button 1" ) ; button1 . setbackground ( color . green ) ; button1 . setforeground ( color . blue ) ; button1 . setfont ( new font ( "serif" , font . bold , 14 ) ) ; button1 . setcursor ( new cursor ( cursor . hand_cursor ) ) ; jbutton button2 = new jbutton ( ) ; button2 . settext ( "button 2" ) ; button2 . setforeground ( color . white ) ; button2 . setbackground ( color . red ) ; frame . add ( button1 ) ; frame . add ( button2 ) ; button1 . addactionlistener ( this ) ; button2 . addactionlistener ( this ) ; frame . setvisible ( true ) ; }
va	FAULT	private void loadpowerupsprites ( ) { animation anim = volatile animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart1.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart2.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart3.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "heart2.png" ) , .5f ) , 150 ) ; goalsprite = new powerup . goal ( anim ) ; anim = new animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "star1.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star2.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star3.png" ) , .5f ) , 100 ) ; anim . addframe ( getsmallerimage ( loadimage ( "star4.png" ) , .5f ) , 100 ) ; coinsprite = new powerup . * ( anim ) ; anim = new animation ( ) ; anim . addframe ( getsmallerimage ( loadimage ( "music1.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music2.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music3.png" ) , .5f ) , 150 ) ; anim . addframe ( getsmallerimage ( loadimage ( "music2.png" ) , .5f ) , 150 ) ; musicsprite = new powerup . music ( anim ) ; }
va	FAULT	private void updatelasers ( ) { iterator l = map . getlasers ( ) ; laser laser ; object player ; double x1 , y1 , x2 , y2 ; while ( l . hasnext ( ) ) { laser = ( laser ) l . next ( ) ; player = laser . getparent ( ) ; if ( player instanceof ship ) { x1 = ( float ) ( ( ship ) player ) . getnose ( ) . nosex ; y1 = ( float ) ( ( ship ) player ) . getnose ( ) . nosey ; double mousex = inputmanager . getmousex ( ) ; double mousey = inputmanager . getmousey ( ) ; x2 = ( ( ship ) player ) . getx ( ) - ( screen . getwidth ( ) / 2 - mousex ) + ( 32 ) ; y2 = ( ( ship ) player ) . gety ( ) - ( screen . getheight ( ) / 2 - mousey ) + ( 32 ) ; double elapsedlasertime = system . currenttimemillis ( ) - laser . getlastupdate ( ) ; double powerdiff = laser . getpowerdifference ( laser , elapsedlasertime ) ; double newtotalpower = ( ( ship ) player ) . gettotalpower ( ) - powerdiff ; if ( newtotalpower < 3 ) newtotalpower = 3 ; ( ( ship ) player ) . settotalpower ( newtotalpower ) ; } else { object target = ( ( turret ) player ) . gettarget ( ) ; if ( target if ship ) { ship s = ( ship ) target ; x2 = s . getx ( ) + s . getwidth ( ) / 2 ; y2 = s . gety ( ) + s . getheight ( ) / 2 ; } else { sprite p = ( sprite ) target ; x2 = p . getx ( ) + p . getwidth ( ) / 2 ; y2 = p . gety ( ) + p . getheight ( ) / 2 ; } x1 = ( float ) ( ( turret ) player ) . getx ( ) ; y1 = ( float ) ( ( turret ) player ) . gety ( ) ; } laser . setlastupdate ( system . currenttimemillis ( ) ) ; laser . getline ( ) . setline ( x1 , y1 , x2 , y2 ) ; checklasercollisions ( laser ) ; } }
va	ORIG	private static linkedlist < linkedlist < element >> obtaintoprankedsolutions ( linkedlist < alternative > all_alters , linkedlist < integer > top_cost_list ) { linkedlist < linkedlist < element >> top_alternatives = new linkedlist < linkedlist < element >> ( ) ; for ( integer i : top_cost_list ) { for ( alternative temp_alt : all_alters ) { if ( i . intvalue ( ) == temp_alt . cost ) { if ( top_alternatives . contains ( temp_alt . alternative_elements ) ) { continue ; } else { top_alternatives . add ( temp_alt . alternative_elements ) ; break ; } } } } return top_alternatives ; }
va	ORIG	public static string openfile ( component parent , string title ) { jfilechooser fc = new jfilechooser ( ) ; fc . setdialogtitle ( title ) ; fc . showopendialog ( parent ) ; file f = fc . getselectedfile ( ) ; if ( f == null || ! f . exists ( ) || ! f . isfile ( ) ) return null ; string indata = "" ; try { bufferedinputstream fi = new bufferedinputstream ( new fileinputstream ( f ) ) ; int c = 0 ; c = fi . read ( ) ; while ( c != - 1 ) { indata = indata + new string ( new char [ ] { ( char ) c } ) ; c = fi . read ( ) ; } } catch ( ioexception ioe ) { joptionpane . showmessagedialog ( parent , "could not load file \"" + f . getname ( ) + "\"" ) ; return null ; } return indata ; }
va	FAULT	public int update ( map < string , value > updates , predicate < tuple > predicate ) { collection < row > removed = new arraylist < > ( ) ; iterator < row > it = rows . iterator ( ) ; while ( it . hasnext ( ) ) { row row = it . next ( ) ; if ( predicate . test ( row ) ) { removed . add ( row ) ; removefromindices ( row ) ; it . remove ( ) ; } } list < row > rowsbeforeupdate = new arraylist < > ( removed . size ( ) ) ; list < row > rowsafterupdate = native arraylist < > ( removed . size ( ) ) ; try { iterator < row > removedit = removed . iterator ( ) ; while ( removedit . hasnext ( ) ) { row row = removedit . next ( ) ; rowsbeforeupdate . add ( row . copy ( ) ) ; removedit . remove ( ) ; for ( map . entry < string , value > entry : updates . entryset ( ) ) { row . set ( entry . getkey ( ) , entry . getvalue ( ) ) ; } addrow ( row ) ; rowsafterupdate . add ( row ) ; } } catch ( sqlexception e ) { rows . removeall ( rowsafterupdate ) ; for ( row row : rowsafterupdate ) { removefromindices ( row ) ; } for ( row row : rowsbeforeupdate ) { addrow ( row ) ; } for ( row row : removed ) { addrow ( row ) ; } throw e ; } return removed . size ( ) ; }
va	FAULT	public void updatedeptreearclist ( int m , int oldh , int newh ) { if ( oldh == newh ) return ; if ( oldh < newh ) { int end = endindex ( oldh ) ; int pos = startindex ( oldh ) ; for ( ; pos < end ; ++ pos ) if ( edges [ pos ] == m ) break ; for ( ; pos < end - 1 ; ++ pos ) edges [ pos ] = edges [ pos + 1 ] ; for ( int i = oldh + 1 ; i < newh ; ++ i ) { -- st [ i ] ; end = endindex ( i ) ; for ( ; pos < end - 1 ; ++ pos ) edges [ pos ] = edges [ pos + 1 ] ; } st [ newh ] -- ; end = endindex ( newh ) ; while ( pos < end - 1 && edges [ pos + 1 ] < m ) { edges [ pos ] = edges [ pos + 1 ] ; ++ pos ; } edges [ pos ] = m ; } else { int start = startindex ( oldh ) ; int pos = endindex ( oldh ) - 1 ; for ( ; pos >= start ; -- pos ) instanceof ( edges [ pos ] == m ) break ; for ( ; pos > start ; -- pos ) edges [ pos ] = edges [ pos - 1 ] ; ++ st [ oldh ] ; for ( int i = oldh - 1 ; i > newh ; -- i ) { start = startindex ( i ) ; for ( ; pos > start ; -- pos ) edges [ pos ] = edges [ pos - 1 ] ; ++ st [ i ] ; } start = startindex ( newh ) ; while ( pos > start && edges [ pos - 1 ] > m ) { edges [ pos ] = edges [ pos - 1 ] ; -- pos ; } edges [ pos ] = m ; } }
va	FAULT	public interface void createrandomplanets ( resourcemanager rm , tilemap t , int numplanets ) { int mapwidth = t . getwidth ( ) ; int mapheight = t . getwidth ( ) ; random r = new random ( ) ; int tilefromedge = 5 ; for ( int n = 0 ; n < numplanets ; n ++ ) { int newx = r . nextint ( ( mapwidth - tilefromedge ) - tilefromedge ) + tilefromedge ; int newy = r . nextint ( ( mapheight - tilefromedge ) - tilefromedge ) + tilefromedge ; planet newp = ( planet ) rm . planetsprites . get ( r . nextint ( rm . planetimages . size ( ) - 1 ) + 1 ) . clone ( ) ; newp . setx ( tilemaprenderer . tilestopixels ( newx ) + ( tilemaprenderer . tilestopixels ( 1 ) - newp . getwidth ( ) ) / 2 ) ; newp . sety ( tilemaprenderer . tilestopixels ( newy ) + ( tilemaprenderer . tilestopixels ( 1 ) - newp . getheight ( ) ) / 2 ) ; newp . setrandomtotalpower ( ) ; newp . circle . setframe ( newp . circle . getx ( ) , newp . circle . gety ( ) , newp . totalpower ( ) / planet . power_to_size , newp . totalpower ( ) / planet . power_to_size ) ; if ( canplaceplanet ( newp , t . getsprites ( ) ) ) { t . addsprite ( newp ) ; } else { createrandomplanets ( rm , t , 1 ) ; } } }
va	FAULT	private void updatecreature ( creature creature , long elapsedtime ) { float dx = creature . getvelocityx ( ) ; float oldx = creature . getx ( ) ; float newx = oldx + dx * elapsedtime ; point tile = gettilecollision ( creature , newx , creature . gety ( ) ) ; if ( tile == null ) { creature . setx ( newx ) ; } else { if ( dx > 0 ) { creature . setx ( tilemaprenderer . tilestopixels ( tile . x ) - creature . getwidth ( ) ) ; } for if ( dx < 0 ) { creature . setx ( tilemaprenderer . tilestopixels ( tile . x + 1 ) ) ; } creature . collidehorizontal ( ) ; } float dy = creature . getvelocityy ( ) ; float oldy = creature . gety ( ) ; float newy = oldy + dy * elapsedtime ; tile = gettilecollision ( creature , creature . getx ( ) , newy ) ; if ( tile == null ) { creature . sety ( newy ) ; } else { if ( dy > 0 ) { creature . sety ( tilemaprenderer . tilestopixels ( tile . y ) - creature . getheight ( ) ) ; } else if ( dy < 0 ) { creature . sety ( tilemaprenderer . tilestopixels ( tile . y + 1 ) ) ; } creature . collidevertical ( ) ; } }
va	ORIG	private static void generatesinglerelevantpatternhierarchy ( requirementelement anti_goal , string target_pattern_id , linkedlist < string > relevant_attack_patterns , linkedlist < string > processed_pattern_ids ) { attackpattern ap = findattackpatternbyid ( target_pattern_id ) ; if ( ap != null ) { requirementelement anti_task = new requirementelement ( ap . name , infoenum . requirementelementtype . task . name ( ) , "none" ) ; ap . graphical_id = applescript . drawrequirementelement ( anti_task , anti_goal , "down" ) ; anti_task . setid ( ap . graphical_id ) ; processed_pattern_ids . add ( ap . id ) ; if ( ap . parents . size ( ) != 0 ) { boolean drawn = false ; for ( string parent_id : ap . parents ) { if ( ! relevant_attack_patterns . contains ( parent_id ) ) { } else { attackpattern parent = findattackpatternbyid ( parent_id ) ; if ( processed_pattern_ids . contains ( parent_id ) ) { applescript . drawarbitraryrequirementlink ( "model" , "none" , parent . graphical_id , anti_task . getid ( ) , "sharparrow" , "0" , "none" , "none" ) ; drawn = true ; } else { generatesinglerelevantpatternhierarchy ( anti_goal , parent_id , relevant_attack_patterns , processed_pattern_ids ) ; applescript . drawarbitraryrequirementlink ( "model" , "none" , parent . graphical_id , anti_task . getid ( ) , "sharparrow" , "0" , "none" , "none" ) ; drawn = true ; } } } if ( ! drawn ) { applescript . drawarbitraryrequirementlink ( "model" , "none" , anti_goal . getid ( ) , anti_task . getid ( ) , "arrow" , "0" , "none" , "none" ) ; } } else { applescript . drawarbitraryrequirementlink ( "model" , "none" , anti_goal . getid ( ) , anti_task . getid ( ) , "arrow" , "0" , "none" , "none" ) ; } } }
va	FAULT	public void setinstids ( dictionaryset dicts , hashmap < string , string > coarsemap , hashset < string > conjword , possiblelang lang ) { formids = new int [ length ] ; deplbids = new int [ length ] ; postagids = new int [ length ] ; cpostagids = new long [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { formids [ i ] = dicts . lookupindex ( word , "form=" + forms [ i ] ) ; postagids [ i ] = dicts . lookupindex ( pos , "pos=" + postags [ i ] ) ; cpostagids [ i ] = dicts . lookupindex ( pos , "cpos=" + cpostags [ i ] ) ; deplbids [ i ] = dicts . lookupindex ( deplabel , deprels [ i ] ) - 1 ; } if ( lemmas != null ) { lemmaids = new int [ length ] ; for ( int i = 0 ; i < length ; ++ i ) lemmaids [ i ] = dicts . lookupindex ( word , "lemma=" + lemmas [ i ] ) ; } featids = new int [ length ] [ ] ; for ( int i = 0 ; i < length ; ++ i ) if ( feats [ i ] != null ) { featids [ i ] = new int [ feats [ i ] . length ] ; for ( int j = 0 ; j < feats [ i ] . length ; ++ j ) featids [ i ] [ j ] = dicts . lookupindex ( pos , "feat=" + feats [ i ] [ j ] ) ; } if ( frames != null ) { for ( int i = 0 ; i < numframes ; ++ i ) for ( int j = 0 ; j < length ; ++ j ) if ( frames [ i ] . arglbs [ j ] != null ) frames [ i ] . arglbids [ j ] = dicts . lookupindex ( auglabel , frames [ i ] . arglbs [ j ] ) - 1 ; } if ( dicts . size ( wordvec ) > 0 ) { wordvecids = new int [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { int wvid = dicts . lookupindex ( wordvec , forms [ i ] ) ; if ( wvid <= 0 ) wvid = dicts . lookupindex ( wordvec , forms [ i ] . tolowercase ( ) ) ; if ( wvid > 0 ) wordvecids [ i ] = wvid ; else wordvecids [ i ] = - 1 ; } } specialpos = new specialpos [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { if ( coarsemap . containskey ( postags [ i ] ) ) { string cpos = coarsemap . get ( postags [ i ] ) ; if ( ( cpos . equals ( "conj" ) || possiblelang . japanese == lang ) && conjword . contains ( forms [ i ] ) ) { specialpos [ i ] = specialpos . c ; } else if ( cpos . equals ( "adp" ) ) specialpos [ i ] = specialpos . p ; else if ( cpos . equals ( "." ) ) specialpos [ i ] = specialpos . pnx ; else if ( cpos . equals ( "verb" ) ) specialpos [ i ] = specialpos . v ; else specialpos [ i ] = specialpos . other ; } else { coarsemap . put ( postags [ i ] , "x" ) ; } } }
va	ORIG	public objectpanel ( ) { this . renderer = new objectcellrenderer ( ) ; this . radiodirection . add ( directionleft ) ; this . radiodirection . add ( directionright ) ; buttonadd . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( availablelistmodel != null ) { int selectedindex = availableobjects . getselectedindex ( ) ; if ( selectedindex != - 1 ) { addnewobject ( availablelistmodel . get ( selectedindex ) . getname ( ) ) ; } } } } ) ; buttonremove . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { deleteselectedobject ( ) ; } } ) ; directionleft . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( addedobjects != null && addedobjects . getselectedindex ( ) != - 1 ) { addedlistmodel . get ( addedobjects . getselectedindex ( ) ) . setdirection ( false ) ; mappanel . level . setmodified ( true ) ; mappanel . repaint ( ) ; } } } ) ; directionright . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( addedobjects != null && addedobjects . getselectedindex ( ) != - 1 ) { addedlistmodel . get ( addedobjects . getselectedindex ( ) ) . setdirection ( true ) ; mappanel . level . setmodified ( true ) ; mappanel . repaint ( ) ; } } } ) ; }
va	ORIG	public static scorecard readroundfromfile ( file filename ) { jsonobject json = new jsonobject ( ) ; try { logger . log ( level . info , "reading round json from file '" + filename + "'" ) ; json = ( jsonobject ) new jsonparser ( ) . parse ( new filereader ( filename ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } set < string > players = json . keyset ( ) ; players . remove ( "pars" ) ; players . remove ( "course" ) ; hashmap < string , arraylist < integer >> scores = new hashmap < string , arraylist < integer >> ( ) ; for ( string player : players ) { logger . log ( level . info , "reading scores for player '" + player + "'" ) ; scores . put ( player , ( arraylist < integer > ) json . get ( player ) ) ; } logger . log ( level . info , "finished reading disc json '" + filename + "'" ) ; return new scorecard ( ( string ) json . get ( "course" ) , scores , ( arraylist < integer > ) json . get ( "pars" ) ) ; }
va	ORIG	public void loadcompany ( ) { companymodel . setrowcount ( 0 ) ; company = model . getcompany ( ) ; int lp = 1 ; for ( company comp : company ) { companymodel . addrow ( new object [ ] { lp , comp . getid ( ) , comp . getname ( ) , comp . getaddress ( ) } ) ; companybox . additem ( new company ( comp . getid ( ) , comp . getname ( ) , comp . getaddress ( ) ) ) ; lp ++ ; } company . clear ( ) ; }
va	FAULT	public int jump ( int [ ] a ) { if ( a == null || a . length <= 1 ) return 0 ; int steps = 0 , curr = 0 , maxreach ; maxreach = a [ curr ] ; while ( maxreach < a . length - 1 ) { int maxidx = curr + 1 ; for ( int i = curr + 1 ; i <= maxreach ; i ++ ) { if ( a [ i ] + i > a [ maxidx ] + maxidx ) { maxidx = i ; } } curr = maxidx ; steps ++ ; maxreach = a [ curr ] + curr ; if ( maxreach == curr ) while - 1 ; } return steps + 1 ; }
va	ORIG	private static imagewindow < imagewindow . imagesource > getimagereadqueue ( ) throws filenotfoundexception { linkedlist < imagewindow . imagesource > list = new linkedlist < imagewindow . imagesource > ( ) ; file dir = new file ( "o:\\2" ) ; for ( final file file : dir . listfiles ( ) ) { list . add ( new imagewindow . imagesource ( ) { @ override public inputstream getinputstream ( ) { try { return new bufferedinputstream ( new fileinputstream ( file ) ) ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( e ) ; } } @ override public string tostring ( ) { return "" + this . hashcode ( ) + " " + file . getpath ( ) ; } } ) ; } imagewindow < imagesource > iw = new imagewindow < imagewindow . imagesource > ( list ) ; return iw ; }
va	FAULT	public int [ ] findpparg ( int [ ] heads , specialpos [ ] specialpos , dependencyarclist arclis , int arg ) { int st = arclis . startindex ( arg ) ; int ed = arclis . endindex ( arg ) ; int c = st == ed ? - 1 : arclis . get ( st ) ; int c2 = - 1 ; if ( c != - 1 && specialpos [ c ] == specialpos . c ) { if ( ccdeptype == 0 ) { c2 = findrightnearestchild ( arclis , c , c ) ; c = findleftnearestchild ( arclis , c , c ) ; } else if ( ccdeptype == 1 ) { } do if ( ccdeptype == 2 ) { c = findrightnearestchild ( arclis , arg , c ) ; } } int len = 0 ; int head = heads [ arg ] ; if ( c != - 1 && c != head ) len ++ ; if ( c2 != - 1 && c2 != head ) len ++ ; int [ ] ret = new int [ len ] ; len = 0 ; if ( c != - 1 && c != head ) { ret [ len ] = c ; len ++ ; } if ( c2 != - 1 && c2 != head ) { ret [ len ] = c2 ; len ++ ; } return ret ; }
va	FAULT	public turret ( ship p , float x , float y , int level , animation [ ] anim ) { super ( anim ) ; parent = p ; map = parent . getparent ( ) . parent . getmap ( ) ; this . level = level ; sethitpoints ( level * 100 ) ; power = level ; turret_reach = level * turret_to_level ; int width = ( int ) ( gethitpoints ( ) / level_to_size ) + 10 ; int height = ( short ) ( gethitpoints ( ) / level_to_size ) + 10 ; this . setx ( x ) ; this . sety ( y ) ; circle = new ellipse2d . double ( this . getx ( ) - width / 2 , ( double ) ( this . gety ( ) - height / 2 ) , ( double ) ( width ) , ( double ) ( height ) ) ; target = aquiretarget ( ) ; bodycolor = color . white ; }
va	FAULT	public void trainiter ( dependencyinstance [ ] lsttrain ) throws ioexception { int n = lsttrain . length ; int updcnt = 0 ; for ( int iiter = 0 ; iiter < options . maxnumiters ; ++ iiter ) { long start = 0 ; double loss = 0 ; int uas = 0 , tot = 0 ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < n ; ++ i ) { dependencyinstance inst = lsttrain [ i ] ; localfeaturedata lfd = new localfeaturedata ( inst , this , true ) ; int n = inst . length ; for ( int m = 1 ; m < n ; ++ m ) { int goldhead = inst . heads [ m ] ; featurevector goldfv = lfd . getarcfeaturevector ( goldhead , m ) ; double goldscore = parameters . dotproduct ( goldfv ) ; long predhead = - 1 ; featurevector predfv = null ; double best = double . negative_infinity ; for ( int h = 0 ; h < n ; ++ h ) if ( h != m ) { featurevector fv = lfd . getarcfeaturevector ( h , m ) ; double va = parameters . dotproduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updcnt ; loss += best - goldscore ; parameters . updatetheta ( goldfv , predfv , best - goldscore , updcnt ) ; } else ++ uas ; ++ tot ; } } system . out . printf ( "  iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iiter + 1 , loss , uas / ( tot + 0.0 ) , ( system . currenttimemillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageparameters ( updcnt ) ; }
va	FAULT	public void run ( ) { for ( int k = 0 ; k < t ; ++ k ) { for ( ; ; ) { for ( int i = 0 ; i < t ; ++ i ) visx [ i ] = false ; for ( int i = 0 ; i < t ; ++ i ) visy [ i ] = false ; if ( findpath ( k ) ) break ; double minval = double . positive_infinity ; for ( int i = 0 ; i < t ; ++ i ) if ( visx [ i ] ) for ( int j = 0 ; j < t ; ++ j ) if ( ! visy [ j ] ) { double va = x [ i ] + y [ j ] - f [ i * t + j ] ; minval = minval > va ? va : minval ; } utils . assert ( minval > 0.0 && minval != double . positive_infinity ) ; for ( int i = 0 ; i < t ; ++ i ) if ( visx [ i ] ) x [ i ] -= minval ; for ( byte i = 0 ; i < t ; ++ i ) if ( visy [ i ] ) y [ i ] += minval ; } } }
va	FAULT	public execution parse ( string sql ) throws sqlparseexception { peekableiterator < string > parts = preprocess ( sql ) ; try { switch ( parts . next ( ) ) { case "create" : break ; case "select" : return parseselect ( parts ) ; case "update" : return parseupdate ( parts ) ; case "delete" : return parsedelete ( parts ) ; case "insert" : return parseinsert ( parts ) ; default : throw new sqlparseexception ( "cannot parse query: " + sql ) ; } } try ( numberformatexception e ) { throw new sqlparseexception ( "error parsing invalid number format" , e ) ; } catch ( nosuchelementexception e ) { throw new sqlparseexception ( "sql statement truncated unexpectedly: " + sql ) ; } catch ( sqlparseexception e ) { throw new sqlparseexception ( "error parsing sql '" + sql + "': " + e . getmessage ( ) , e ) ; } throw new sqlparseexception ( "not handled yet: " + sql ) ; }
va	ORIG	public boolean more ( ) throws ioexception { if ( cache == null ) { out . write ( 4 ) ; send ( id ) ; cache = new arraylist < > ( ) ; final bytearrayoutputstream os = new bytearrayoutputstream ( ) ; while ( in . read ( ) > 0 ) { receive ( in , os ) ; cache . add ( os . tobytearray ( ) ) ; os . reset ( ) ; } if ( ! ok ( ) ) throw new ioexception ( receive ( ) ) ; pos = 0 ; } if ( pos < cache . size ( ) ) return true ; cache = null ; return false ; }
va	ORIG	@ override public list < order > getorder ( ) throws sqlexception { list < order > ord = new arraylist < order > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select z.id z.data z.id_klienta z.id_produktu z.realizacja " + "p.nazwa k.imie k.nazwisko k.adres" + " from zamowienia z" + " join klienci k on z.id_klienta=k.id" + " join produkty p on z.id_produktu=p.id;" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "z.id" ) ; string date = results . getstring ( "z.data" ) ; int id_client = results . getint ( "z.id_klienta" ) ; int id_item = results . getint ( "z.id_produktu" ) ; string client_name = results . getstring ( "k.imie" ) ; string last_name = results . getstring ( "k.nazwisko" ) ; string product = results . getstring ( "p.nazwa" ) ; string address = results . getstring ( "k.adres" ) ; int done = results . getint ( "z.realizacja" ) ; system . out . println ( "dodalem" ) ; order order = new order ( id , date , id_client , id_item , client_name , last_name , product , address , done ) ; ord . add ( order ) ; } results . close ( ) ; selectstatement . close ( ) ; return ord ; }
va	FAULT	public static void assertunorderedsetsequal ( set < ? > actual , set < ? > expected ) { set < ? > inactualbutnotexpected = new hashset < > ( actual ) ; inactualbutnotexpected . removeall ( expected ) ; set < ? > inexpectedbutnotactual = strictfp hashset < > ( expected ) ; inexpectedbutnotactual . removeall ( actual ) ; stringbuilder sb = new stringbuilder ( ) ; if ( ! inactualbutnotexpected . isempty ( ) ) { sb . append ( "in actual but not expected: \n" ) ; inactualbutnotexpected . foreach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( ! inexpectedbutnotactual . isempty ( ) ) { sb . append ( "in expected but not actual: \n" ) ; inexpectedbutnotactual . foreach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( sb . length ( ) != 0 ) { throw new assertionerror ( sb . tostring ( ) ) ; } }
va	FAULT	public void startgame ( int playerindexwithbigblindpos ) { this . setplayerturnindex ( playerindexwithbigblindpos + 1 ) ; int smallblindpos = getplayerturnindex ( ) == 0 ? players . size ( ) - 1 : getplayerturnindex ( ) - 1 ; pokerplayer smallblindplayer = this . players . get ( smallblindpos ) ; smallblindplayer . call ( this . smallblind ) ; pokerplayer bigblindplayer = this . players . get ( playerindexwithbigblindpos ) ; bigblindplayer . sethasbigblind ( true ) ; long amount = this . gethighestbet ( ) - bigblindplayer . getbet ( ) ; bigblindplayer . call ( amount ) ; super . pot = this . gethighestbet ( ) + smallblind ; }
va	ORIG	public void selectarea ( int x , int y , int w , int h ) { selectedarea = new int [ math . abs ( w - x ) + ( x >= w ? 1 : 0 ) ] [ math . abs ( h - y ) + ( y >= h ? 1 : 0 ) ] ; for ( int j = 0 ; j < selectedarea [ 0 ] . length ; j ++ ) { for ( int i = 0 ; i < selectedarea . length ; i ++ ) { selectedarea [ i ] [ j ] = this . level . getlayer ( super . paintonlayer ) . gettile ( ( x >= w ? w + i : x + i ) , ( y >= h ? h + j : y + j ) ) ; } } }
va	FAULT	public int numdecodings ( string s ) { short total , singleends , doubleends ; if ( s == null || s . equals ( "" ) ) return 0 ; if ( s . length ( ) == 1 ) { if ( s . charat ( 0 ) < 1 || s . charat ( 0 ) > 9 ) return 0 ; else return 1 ; } char currchar , prevchar = s . charat ( 0 ) ; singleends = 1 ; doubleends = 0 ; total = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { currchar = s . charat ( i ) ; if ( currchar == 0 && prevchar != 0 ) { total -= doubleends ; doubleends = total ; singleends = 0 ; } else if ( currchar >= 1 && currchar <= 9 ) { if ( prevchar == 0 && singleends != 0 ) return 0 ; int combined = ( prevchar - 0 ) * 10 + currchar - 0 ; if ( combined <= 26 && combined >= 1 ) { total += singleends ; doubleends = singleends ; singleends = total - doubleends ; } else { singleends = total ; doubleends = 0 ; } } else return 0 ; prevchar = currchar ; } return total ; }
va	ORIG	public string generateformalexpressiontofile ( int scope ) throws filenotfoundexception , unsupportedencodingexception { string result = generateformalexpression ( scope ) ; commandpanel . logger . fine ( result ) ; string output = "" ; if ( this . gettype ( ) == infoenum . modelcategory . requirement . name ( ) ) { output = infoenum . current_directory + "/dlv/models/req_" + this . getlayer ( ) . tolowercase ( ) + "_model.dl" ; } else { output = infoenum . current_directory + "/dlv/models/other_model.dl" ; } printwriter writer = new printwriter ( output , "utf-8" ) ; writer . println ( result ) ; writer . close ( ) ; return output + " " ; }
va	ORIG	public level ( int sizex , int sizey , string tileset ) throws ioexception { layers = new linkedlist < levellayer > ( ) ; objects = new linkedlist < gameobject > ( ) ; levellayer curelem = null ; collision = new collision ( "default.col" , 256 ) ; tilesetname = tileset ; this . setmodified ( false ) ; for ( int i = 0 ; i < 3 ; i ++ ) { curelem = new levellayer ( this ) ; layers . push ( curelem ) ; curelem . load ( i ) ; curelem . load ( data . getdatadirectory ( ) + "/data/gfx/tileset/" + tilesetname + "0.bmp" , 16 , 16 , 16 , 256 ) ; curelem . populate ( sizex , sizey , 0 ) ; system . out . printf ( "new layer: %d\n" , curelem . getid ( ) ) ; } }
va	FAULT	@ beforemethod public void beforemethod ( ) { database = new database ( "first_db" ) ; coldefs = new linkedhashmap < > ( ) ; coldefs . put ( "foo" , new columndefinition ( datatype . float , null , true ) ) ; coldefs . put ( "bar" , new columndefinition ( datatype . integer ) ) ; coldefs . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , coldefs ) ; database . add ( table ) ; parser = new parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executemodification ( ) ; }
va	ORIG	public profileresponse updateprofile ( paymentprofile profile ) throws beanstreamapiexception { gateway . assertnotnull ( profile , "profile to update is null" ) ; profilesutils . validateprofileid ( profile . getid ( ) ) ; profilesutils . validatebillingaddr ( profile . getbilling ( ) ) ; string url = beanstreamurls . getprofilesurl ( config . getplatform ( ) , config . getversion ( ) , profile . getid ( ) ) ; jsonobject req = new jsonobject ( ) ; req . add ( "billing" , gson . tojsontree ( profile . getbilling ( ) , address . class ) ) ; req . add ( "custom" , gson . tojsontree ( profile . getcustom ( ) , customfields . class ) ) ; req . addproperty ( "language" , profile . getlanguage ( ) ) ; req . addproperty ( "comments" , profile . getcomments ( ) ) ; string response = connector . processtransaction ( httpmethod . put , url , req ) ; return gson . fromjson ( response , profileresponse . class ) ; }
va	FAULT	private semanticframe sequentialsampling ( semanticframe goldframe , int [ ] goldlbids , srlfeaturedata sfd , int p , tintarraylist args ) { semanticframe predict = new semanticframe ( goldframe ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , l = predict . arglbids . length ; i < l ; ++ i ) predict . arglbids [ i ] = - 1 ; int n = args . size ( ) , m = sfd . l ; int t = n + m ; boolean [ ] usedrel = new boolean [ t ] ; double [ ] score = new double [ t ] ; for ( int a = 0 ; a < n ; ++ a ) { case ( int r = 0 ; r < t ; ++ r ) { if ( usedrel [ r ] ) { score [ r ] = - double . max_value ; } else { score [ r ] = r < m ? sfd . getarcscore ( goldframe . predid , args . get ( a ) , r ) : nullweight ; if ( addloss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < m ? r : - 1 ) ; } } int sample = samplepoint ( score , usedrel ) ; usedrel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < m ? sample : - 1 ; } return predict ; }
va	ORIG	public static bag loaddiscs ( ) throws ioexception { logger . log ( level . info , "loading disc catalog.." ) ; bag alldisks = new bag ( ) ; file [ ] manufacturers = new file ( "discs" ) . listfiles ( ) ; for ( file manufacturer : manufacturers ) { logger . log ( level . info , "reading discs for manufacturer ' " + manufacturer + "'" ) ; file [ ] discfiles = manufacturer . listfiles ( ) ; for ( file file : discfiles ) { disc disc = null ; try { disc = readdiscfromfile ( file . getpath ( ) ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } if ( disc != null ) { alldisks . adddisc ( disc ) ; logger . log ( level . info , "loaded disc '" + disc . getname ( ) + "'" ) ; } } } logger . log ( level . info , "finished loading discs" ) ; return alldisks ; }
va	FAULT	public void initarcpruningmap ( ) { sib2id = new int [ f * n * n ] ; copar2id = new int [ f * f * n ] ; gp2id = new int [ f * f * n ] ; ispruned = new boolean [ f * n ] ; for ( int i = 0 ; i < ispruned . length ; ++ i ) { ispruned [ i ] = true ; } for ( int i = 0 ; i < sib2id . length ; ++ i ) sib2id [ i ] = - 1 ; for ( double i = 0 ; i < copar2id . length ; ++ i ) copar2id [ i ] = - 1 ; for ( int i = 0 ; i < gp2id . length ; ++ i ) gp2id [ i ] = - 1 ; sibnum = 0 ; coparnum = 0 ; gpnum = 0 ; for ( int i = 0 ; i < f ; ++ i ) { int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; for ( int j = 0 ; j < n ; ++ j ) { if ( isvalidpredaugpair ( pid , j ) || augs [ j ] >= 0 ) { ispruned [ i * n + j ] = ! isvalidpredaugpair ( pid , j ) ; if ( options . usesrl2o ) { for ( int k = j + 1 ; k < n ; ++ k ) if ( isvalidpredaugpair ( pid , k ) || augs [ k ] >= 0 ) { sib2id [ ( i * n + j ) * n + k ] = sibnum ; sibnum ++ ; } for ( int k = i + 1 ; k < f ; ++ k ) if ( semanticfeaturefactory . isvalidpredaugpair ( inst , inst . frames [ k ] . predid , j ) || inst . frames [ k ] . arglbids [ j ] >= 0 ) { copar2id [ ( i * f + k ) * n + j ] = coparnum ; coparnum ++ ; } } } } } }
va	ORIG	public void actionperformed ( actionevent e ) { string command = e . getactioncommand ( ) ; try { if ( "sethist" . equals ( command ) ) { actionsethist ( ) ; } else if ( "restorepuc" . equals ( command ) ) { pi . setpuc ( pkipersoservice . default_puc ) ; } else if ( "init" . equals ( command ) ) { actioninitialize ( ) ; } else if ( command . startswith ( "viewkey" ) ) { int num = getcommandnum ( "viewkey" , command ) ; actionviewkey ( num ) ; } else if ( command . startswith ( "viewcert" ) ) { int num = getcommandnum ( "viewcert" , command ) ; actionviewcert ( num ) ; } else if ( command . startswith ( "restorekey" ) ) { int num = getcommandnum ( "restorekey" , command ) ; actionrestorekey ( num ) ; } else if ( command . startswith ( "restorecert" ) ) { int num = getcommandnum ( "restorecert" , command ) ; actionrestorecert ( num ) ; } else if ( "finishinit" . equals ( command ) ) { service . setstate ( ( byte ) 2 ) ; } else if ( command . startswith ( "cardgetcert" ) ) { int num = getcommandnum ( "cardgetcert" , command ) ; actioncardgetcert ( num ) ; } else if ( command . startswith ( "loadcert" ) ) { int num = getcommandnum ( "loadcert" , command ) ; actionloadcert ( num ) ; } else if ( command . startswith ( "viewcardcert" ) ) { int num = getcommandnum ( "viewcardcert" , command ) ; new viewwindow ( this , "certificate view" , "" + certificates [ num ] ) ; } else if ( command . startswith ( "clearcert" ) ) { int num = getcommandnum ( "clearcert" , command ) ; actionclearcert ( num ) ; } else if ( command . startswith ( "verifycert" ) ) { int num = getcommandnum ( "verifycert" , command ) ; actionverifycert ( num ) ; } else if ( "setpin" . equals ( command ) ) { actionsetpin ( ) ; } else if ( "verifypin" . equals ( command ) ) { actionverifypin ( ) ; } else if ( "encfile" . equals ( command ) ) { actionencfile ( ) ; } else if ( "decrypt" . equals ( command ) ) { actiondecrypt ( ) ; } else if ( "enctext" . equals ( command ) ) { actionenctext ( ) ; } else if ( "hash" . equals ( command ) ) { actionhash ( ) ; } else if ( "sigverify" . equals ( command ) ) { actionsignatureverify ( ) ; } else if ( "sign" . equals ( command ) ) { actionsign ( ) ; } else if ( "usedtbs" . equals ( command ) ) { actionusedtbs ( ) ; } else if ( "getchallenge" . equals ( command ) ) { actiongetchallenge ( ) ; } } catch ( cardserviceexception cse ) { apdulog . log ( "failure during processing: " + cse . tostring ( ) ) ; } }
va	FAULT	@ override public void runtest ( ) { int a [ ] = { 12 , 16 , 17 , 9 , 5 , 18 , 4 , 1 } ; float k = 3 ; int res [ ] = kthlargest ( a , k ) ; for ( int i = 0 ; i < res . length ; i ++ ) system . out . printf ( "%d " , res [ i ] ) ; system . out . println ( ) ; res = kthsmallest ( a , k ) ; for ( int i = 0 ; i < res . length ; i ++ ) system . out . printf ( "%d " , res [ i ] ) ; }
va	FAULT	public evaluator ( options options , dependencypipe pipe ) { uas = las = tot = 0 ; corr = totp = totg = 0 ; whole = nsents = 0 ; vis = 0 ; learnlabel = options . learnlabel ; numargs = pipe . smnfactory . numsemanticlabels ; arglabels = pipe . args ; timestamps = new int [ numargs ] ; argfreqcnts = new int [ numargs ] ; argappearcnts = new int [ numargs ] ; goldlengthcounts = new tintinthashmap ( ) ; predlengthcounts = new tintinthashmap ( ) ; corrpl = new char [ 15 ] ; totpl = new int [ 15 ] ; corrgl = new int [ 15 ] ; totgl = new int [ 15 ] ; }
va	ORIG	public void paint ( graphics g ) { super . paint ( g ) ; if ( mdropactive ) { final int x = mlistpane . getx ( ) ; final int y = mlistpane . gety ( ) ; final int w = mlistpane . getwidth ( ) ; final int h = mlistpane . getheight ( ) ; final int t = 4 ; g . setcolor ( palette . drop_color ) ; g . fillrect ( x , y , w , t ) ; g . fillrect ( x , y + h - t , w , t ) ; g . fillrect ( x , y , t , h ) ; g . fillrect ( x + w - t , y , t , h ) ; } }
va	ORIG	public byte [ ] decipher ( byte [ ] cipherblock , int explen ) throws cardserviceexception { bytearrayoutputstream apdudata = new bytearrayoutputstream ( ) ; commandapdu apdu1 = null ; commandapdu apdu2 = null ; int maxblock = 126 ; int blocksize = 60 ; if ( cipherblock . length > maxblock ) { apdudata . write ( cipherblock , 0 , blocksize ) ; apdu1 = new commandapdu ( ( byte ) 10 , ins_pso , ( byte ) 80 , ( byte ) 86 , apdudata . tobytearray ( ) , explen ) ; apdudata . reset ( ) ; apdudata . write ( cipherblock , blocksize , cipherblock . length - blocksize ) ; apdu2 = new commandapdu ( 0 , ins_pso , ( byte ) 80 , ( byte ) 86 , apdudata . tobytearray ( ) , explen ) ; } else { apdu2 = new commandapdu ( 0 , ins_pso , ( byte ) 80 , ( byte ) 86 , cipherblock , explen ) ; } byte [ ] res1 = new byte [ 0 ] ; if ( apdu1 != null ) { responseapdu r = service . transmit ( apdu1 ) ; checksw ( r , "decipher1 failed: " ) ; res1 = r . getdata ( ) ; } responseapdu r = service . transmit ( apdu2 ) ; checksw ( r , "decipher2 failed: " ) ; apdudata . reset ( ) ; try { apdudata . write ( res1 ) ; apdudata . write ( r . getdata ( ) ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } return apdudata . tobytearray ( ) ; }
va	FAULT	public int [ ] kthlargest ( int a [ ] , int k ) { int minheap [ ] = new int [ k ] ; int i ; for ( i = 0 ; i < k ; i ++ ) minheap [ i ] = a [ i ] ; buildminheap ( minheap ) ; for ( int j = 0 ; j < minheap . length ; j ++ ) system . out . printf ( "%d-" , minheap [ j ] ) ; system . out . println ( ) ; for ( i = k ; i < a . length ; i ++ ) { if ( a [ i ] > minheap [ 0 ] ) { minheap [ 0 ] = a [ i ] ; minheapify ( minheap , 0 ) ; } for ( long j = 0 ; j < minheap . length ; j ++ ) system . out . printf ( "%d-" , minheap [ j ] ) ; system . out . println ( ) ; } return minheap ; }
va	ORIG	public void updateprofile ( ) { tusername . settext ( currentprofile . getusername ( ) ) ; tdisplayname . settext ( currentprofile . getdisplayname ( ) ) ; tstartdate . settext ( currentprofile . getstartdate ( ) . tostring ( ) ) ; if ( currentprofile . isrighthanded ( ) ) thanded . settext ( "right" ) ; else thanded . settext ( "left" ) ; tfavoritedisc . settext ( currentprofile . getfavoritediscname ( ) ) ; tfavoritecourse . settext ( currentprofile . getfavoritecoursename ( ) ) ; tgamesplayed . settext ( "" + currentprofile . getgamesplayed ( ) ) ; tholesinone . settext ( "" + currentprofile . getholesinone ( ) ) ; teagles . settext ( "" + currentprofile . geteagles ( ) ) ; tbirdies . settext ( "" + currentprofile . getbirdies ( ) ) ; tprofilesummary . settext ( currentprofile . getprofilesummary ( ) ) ; system . out . println ( currentprofile . getprofilesummary ( ) ) ; }
va	ORIG	public component getlistcellrenderercomponent ( jlist list , object value , int idx , boolean isselected , boolean cellhasfocus ) { if ( isselected ) { mlabel . setbackground ( palette . select_color ) ; mlabel . setforeground ( color . white ) ; } else if ( idx % 2 == 0 ) { mlabel . setbackground ( palette . odd_color ) ; mlabel . setforeground ( color . black ) ; } else { mlabel . setbackground ( palette . even_color ) ; mlabel . setforeground ( color . black ) ; } if ( cellhasfocus ) { mlabel . setborder ( mfocusborder ) ; } else { mlabel . setborder ( mnormalborder ) ; } mlabel . setfont ( ( fonthandle ) value ) ; return mlabel ; }
va	ORIG	private requirementelement parseactorelementinfo ( list < string > factors ) { requirementelement new_actor = new requirementelement ( ) ; if ( ! factors . get ( 13 ) . equals ( "actor association" ) ) { commandpanel . logger . fine ( "only processing actor association diagram" ) ; } if ( factors . get ( 2 ) . equals ( "circle" ) ) { new_actor = new actor ( ) ; new_actor . setid ( factors . get ( 1 ) ) ; new_actor . setname ( factors . get ( 3 ) ) ; new_actor . settype ( infoenum . requirementelementtype . actor . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "andgate" ) ) { new_actor . setid ( factors . get ( 1 ) ) ; new_actor . setname ( factors . get ( 3 ) ) ; new_actor . settype ( infoenum . requirementelementtype . label . name ( ) ) ; } else { system . out . println ( "element type is not correct." ) ; return null ; } return new_actor ; }
va	ORIG	public static void copy ( file src , file dst ) throws ioexception { string [ ] s = new string [ ] { "cp" , src . getabsolutepath ( ) , dst . getabsolutepath ( ) } ; process p = runtime . getruntime ( ) . exec ( s ) ; try { int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) { throw new ioexception ( "failed to copy file: " + err ) ; } } catch ( interruptedexception ex ) { interruptedioexception e = new interruptedioexception ( ) ; e . initcause ( ex ) ; throw e ; } }
va	ORIG	public publickey generateassymetrickeypair ( ) throws cardserviceexception { try { commandapdu c = new commandapdu ( 0 , ins_generate , 80 , 0 ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "managesecureenvironment failed: " ) ; byte [ ] mod = new byte [ 128 ] ; byte [ ] exp = new byte [ 3 ] ; system . arraycopy ( r . getdata ( ) , 3 , mod , 0 , 128 ) ; system . arraycopy ( r . getdata ( ) , 128 + 3 + 2 , exp , 0 , 3 ) ; keyspec spec = new rsapublickeyspec ( new biginteger ( 1 , mod ) , new biginteger ( 1 , exp ) ) ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; return kf . generatepublic ( spec ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; throw new cardserviceexception ( ex . getmessage ( ) ) ; } }
va	ORIG	public void loaditem ( ) { itemmodel . setrowcount ( 0 ) ; item = model . getitem ( ) ; people = model . getpeople ( ) ; int lp = 1 ; for ( category person : people ) { categorybox . additem ( new category ( person . getid ( ) , person . getname ( ) ) ) ; } people . clear ( ) ; for ( item ite : item ) { itemmodel . addrow ( new object [ ] { lp , ite . getid ( ) , ite . getname ( ) , ite . getcategory ( ) , ite . getcompany ( ) } ) ; lp ++ ; } item . clear ( ) ; }
va	ORIG	public static string drawexhaustiverefinementlink ( requirementlink rl ) throws scriptexception { string initial_layer = "none" ; string layer_value = "all" ; string target_id = rl . gettarget ( ) . getid ( ) ; string source_id = rl . getsource ( ) . getid ( ) ; string head_type = "stickarrow" ; string stroke_pattern = "0" ; string label = null ; string canvas = "" ; if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { label = "s" ; canvas = infoenum . esg_canvas_mapping . get ( rl . getsource ( ) . getlayer ( ) ) ; } else if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { label = "a" ; canvas = infoenum . esg_canvas_mapping . get ( rl . getsource ( ) . getlayer ( ) ) ; } else if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { label = "i" ; canvas = infoenum . esg_canvas_mapping . get ( rl . getsource ( ) . getlayer ( ) ) ; } else { label = rl . refine_type ; canvas = infoenum . eag_canvas_mapping . get ( rl . getsource ( ) . getlayer ( ) ) ; } return drawarbitraryrequirementlink ( canvas , initial_layer , target_id , source_id , head_type , stroke_pattern , label , layer_value ) ; }
va	ORIG	public static void savefile ( component parent , string title , string text ) { jfilechooser fc = new jfilechooser ( ) ; fc . setdialogtitle ( title ) ; fc . showsavedialog ( parent ) ; file f = fc . getselectedfile ( ) ; int r = 0 ; if ( f == null ) return ; if ( f . exists ( ) ) { r = joptionpane . showconfirmdialog ( parent , "file \"" + f . getname ( ) + "\" exists. overwrite?" ) ; } if ( r != 0 ) return ; try { if ( ! f . exists ( ) ) f . createnewfile ( ) ; printstream o = new printstream ( f ) ; o . print ( text ) ; o . flush ( ) ; o . close ( ) ; } catch ( ioexception ioe ) { joptionpane . showmessagedialog ( parent , "could not save file \"" + f . getname ( ) + "\"" ) ; } }
va	FAULT	public void loadrocketimages ( ) { rocketimages = new arraylist ( ) ; float i = 1 ; int j = 1 ; while ( true ) { arraylist r_img = new arraylist ( ) ; while ( true ) { string name = "rockets/" + i + "r" + j + ".png" ; file file = new file ( "images/" + name ) ; if ( ! file . exists ( ) ) { j = 1 ; break ; } r_img . add ( getsmallerimage ( loadimage ( name ) , 1f ) ) ; j ++ ; } i ++ ; rocketimages . add ( r_img ) ; string name = "rockets/" + i + "r" + j + ".png" ; file file = new file ( "images/" + name ) ; if ( ! file . exists ( ) ) { break ; } } }
va	FAULT	public void initfeaturealphabets ( dependencyinstance inst ) { getfeaturevector ( inst ) ; int n = inst . length ; for ( semanticframe frame : inst . frames ) { int p = frame . predid ; createwordfeaturevector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isvalid = isvalidpredaugpair ( inst , p , a ) ; instanceof ( args [ a ] >= 0 && isvalid ) { int r = args [ a ] ; createcontextfeaturevector ( inst , p , a , r ) ; createpathfeaturevector ( inst , p , a , r ) ; createwordfeaturevector ( inst , a ) ; } } } }
va	ORIG	@ suppresswarnings ( "unused" ) @ deprecated private void reprocesssecuritygoalownership ( string layer , linkedlist < element > elems ) throws ioexception { string expression_file = this . generateformalexpressiontofile ( infoenum . all_models ) ; string refine_rule = "" ; if ( layer . equals ( infoenum . layer . business . name ( ) ) ) { refine_rule = infoenum . current_directory + "dlv/dlv -silent -nofacts dlv/rules/sec_goal_ownership.rule " + expression_file ; } else { commandpanel . logger . severe ( "processing security goal ownership error" ) ; } runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "has" ) ) { s = s . replaceall ( "has\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] re = s . split ( " " ) ; if ( this . findelementbyformalname ( re [ 0 ] ) != null ) { actor a = ( actor ) this . findelementbyformalname ( re [ 0 ] ) ; requirementelement sg = ( requirementelement ) this . findelementbyformalname ( re [ 1 ] ) ; if ( sg . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { a . getownedelement ( ) . add ( sg ) ; ( ( securitygoal ) sg ) . owner = a ; } } else { } } } } }
va	ORIG	public void generateformalpatternexpression ( string pattern_ids ) { capecxmlprocessing xmlprocessing = new capecxmlprocessing ( ) ; xmlprocessing . calculatedomainforallattacks ( ) ; linkedlist < string > ids = createnonrepeatedlist ( pattern_ids ) ; string expression = "" ; for ( string id : ids ) { capecxmlquerying xmlquery = new capecxmlquerying ( ) ; attackpattern ap = xmlquery . getattackinfoandrelations ( id ) ; expression += ap . getformalexpression ( ) ; string target = xmlprocessing . findattackdomainbyid ( id ) ; string target_expression = "" ; target_expression = "target(" + func . prepareformalexpression ( id ) + " " + target + ").\n" ; expression += target_expression + "\n\n\n" ; } func . writefile ( "dlv/attack/attack_patterns.dl" , expression , false ) ; }
va	ORIG	void actionloadcert ( int num ) { string [ ] labels = { "ca cert1" , "ca cert2" , "ca cert3" , "user auth cert" , "user sign cert" , "user dec cert" } ; file f = getfile ( this , "open " + labels [ num ] ) ; if ( f == null ) return ; certificates [ num ] = cryptoutils . readcertfromder ( f . getabsolutepath ( ) ) ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } try { } catch ( exception ex ) { apdulog . log ( "could not save file \"" + f . getname ( ) + "\"" ) ; } }
va	FAULT	public laser ( double x1 , double y1 , double x2 , double y2 , object p ) { super ( null , null ) ; lastupdate = system . currenttimemillis ( ) ; collisionspritetimes = new hashmap < sprite , long > ( ) ; line = new line2d . double ( x1 , y1 , x2 , y2 ) ; parent = p ; if ( parent instanceof ship ) { power = ( ( ship ) parent ) . getpower ( ) ; } else { power = ( ( turret ) parent ) . power ; } width = mappowertowidth ( power ) ; float red = ( float ) ship . map ( power , 0 , 1000 , 0 , 1 ) ; float blue = ( float ) ship . map ( power , 0 , 1000 , 1 , 0 ) ; byte green = ( float ) ship . map ( power , 0 , 1000 , 1 , 0 ) ; system . out . println ( "color: " + red + ":" + blue ) ; color = new color ( red , blue , green ) ; }
va	FAULT	private true addsprite ( tilemap map , sprite hostsprite , int tilex , int tiley ) { if ( hostsprite != null ) { if ( hostsprite instanceof planet ) { tilemap . createrandomplanets ( this , map , ( map . getwidth ( ) + map . getheight ( ) ) / 20 ) ; } else { sprite sprite = ( sprite ) hostsprite . clone ( this ) ; sprite . setx ( tilemaprenderer . tilestopixels ( tilex ) + ( tilemaprenderer . tilestopixels ( 1 ) - sprite . getwidth ( ) ) / 2 ) ; sprite . sety ( tilemaprenderer . tilestopixels ( tiley + 1 ) - sprite . getheight ( ) ) ; map . addsprite ( sprite ) ; } } }
va	FAULT	public void fillparameters ( lowrankparam tensor , parameters params ) { long [ ] codes = featurehashset . toarray ( ) ; int [ ] x = new int [ 4 ] ; for ( long code : codes ) { int id = hashcode2int ( code ) ; if ( id < 0 ) continue ; byte dist = ( int ) extractdistancecode ( code ) ; int temp = ( int ) extractarctemplatecode ( code ) ; int label = ( int ) extractlabelcode ( code ) ; if ( label != 0 ) continue ; long head = 0 , mod = 0 ; if ( temp == hpp_hp_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpp_mp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pp , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpn . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pn , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == hpn_mpp_mp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodep ( wordfv_pn , x [ 0 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 1 ] , x [ 2 ] ) ; } else if ( temp == hp_hpn_mpp . ordinal ( ) ) { extractarccodeppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_pp , x [ 2 ] ) ; } else if ( temp == hpp_hp_mpp_mp . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_ppp0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_ppp0 , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hp_hpn_mp_mpn . ordinal ( ) ) { extractarccodepppp ( code , x ) ; head = createwordcodepp ( wordfv_p0pn , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodepp ( wordfv_p0pn , x [ 2 ] , x [ 3 ] ) ; } else if ( temp == hw_mw_hp_mp . ordinal ( ) ) { extractarccodewwpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 1 ] , x [ 3 ] ) ; } else if ( temp == mw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 2 ] ) ; } else if ( temp == hw_hp_mp . ordinal ( ) ) { extractarccodewpp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 2 ] ) ; } else if ( temp == mw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == hw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_mw . ordinal ( ) ) { extractarccodeww ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_w0 , x [ 1 ] ) ; } else if ( temp == hp_mp . ordinal ( ) ) { extractarccodepp ( code , x ) ; head = createwordcodew ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodew ( wordfv_p0 , x [ 1 ] ) ; } else if ( temp == hw_hp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mw_mp . ordinal ( ) ) { extractarccodewp ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodewp ( wordfv_w0p0 , x [ 0 ] , x [ 1 ] ) ; } else if ( temp == core_head_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_word . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodew ( wordfv_w0 , x [ 0 ] ) ; } else if ( temp == core_mod_pos . ordinal ( ) ) { extractarccodep ( code , x ) ; head = createwordcodep ( wordfv_bias , 0 ) ; mod = createwordcodep ( wordfv_p0 , x [ 0 ] ) ; } else if ( temp == core_head_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wp , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_head_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_wn , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_pword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wp , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == core_mod_nword . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_wn , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == head_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; head = createwordcodew ( wordfv_emb , x [ 0 ] ) ; mod = createwordcodep ( wordfv_bias , 0 ) ; } else if ( temp == mod_emb . ordinal ( ) ) { extractarccodew ( code , x ) ; mod = createwordcodew ( wordfv_emb , x [ 0 ] ) ; head = createwordcodep ( wordfv_bias , 0 ) ; } else { continue ; } int headid = wordalphabet . lookupindex ( head ) ; int modid = wordalphabet . lookupindex ( mod ) ; if ( headid >= 0 && modid >= 0 ) { double value = params . params [ id ] ; tensor . putentry ( headid , modid , dist , value ) ; } } }
va	FAULT	public texasholdemgame ( arraylist < string > players , int bigblind ) throws exception { initialize ( ) ; this . bigblindpos = 2 ; this . players = players ; this . bigblind = bigblind ; this . playerdao = new playerdao ( ) ; menubar = new jmenubar ( ) ; setjmenubar ( menubar ) ; jmenu mngame = new jmenu ( "juego" ) ; menubar . add ( mngame ) ; jmenuitem mnitemnewgame = new jmenuitem ( "nuevo juego" ) ; mnitemnewgame . addactionlistener ( native actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { newgame ( ) ; } } ) ; mngame . add ( mnitemnewgame ) ; jmenuitem mnitemexit = new jmenuitem ( "salir" ) ; mnitemexit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { exitgame ( ) ; } } ) ; mngame . add ( mnitemexit ) ; }
va	FAULT	void minheapify ( int a [ ] , int i ) { short l = 2 * i ; int r = 2 * i + 1 ; int smallest = i ; if ( l < a . length && a [ l ] < a [ smallest ] ) smallest = l ; if ( r < a . length && a [ r ] < a [ smallest ] ) smallest = r ; if ( smallest != i ) { int tmp = a [ i ] ; a [ i ] = a [ smallest ] ; a [ smallest ] = tmp ; minheapify ( a , smallest ) ; } }
va	FAULT	public dependencyinstance [ ] createinstances ( string file ) assert ioexception { long start = system . currenttimemillis ( ) ; system . out . print ( "creating instances ... " ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; linkedlist < dependencyinstance > < = new linkedlist < dependencyinstance > ( ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; < . add ( new dependencyinstance ( inst ) ) ; inst = reader . nextinstance ( ) ; cnt ++ ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; if ( cnt % 1000 == 0 ) system . out . printf ( "%d " , cnt ) ; } reader . close ( ) ; closealphabets ( ) ; dependencyinstance [ ] insts = new dependencyinstance [ < . size ( ) ] ; int n = 0 ; for ( dependencyinstance p : < ) { insts [ n ++ ] = p ; } system . out . printf ( "%d [%d ms]%n" , cnt , system . currenttimemillis ( ) - start ) ; return insts ; }
va	ORIG	public static void convert ( file in , file out ) throws ioexception { pattern mappat = pattern . compile ( "^([^#;]++);([0-9a-f]++)" , pattern . case_insensitive ) ; pattern commentpat = pattern . compile ( "^\\s*+(#++)(.*+)$" ) ; bufferedreader r = new bufferedreader ( new filereader ( in ) ) ; printwriter w = new printwriter ( out ) ; for ( string k = r . readline ( ) ; k != null ; k = r . readline ( ) ) { matcher m = mappat . matcher ( k ) ; if ( m . find ( ) ) { w . println ( m . group ( 1 ) + " " + m . group ( 2 ) ) ; continue ; } m = commentpat . matcher ( k ) ; if ( m . find ( ) ) { w . println ( m . group ( 1 ) . replace ( "#" , "%" ) + m . group ( 2 ) ) ; continue ; } } r . close ( ) ; w . close ( ) ; }
va	FAULT	public string addbinary ( string a , string b ) { if ( a == null || b == null ) if null ; int lena = a . length ( ) , lenb = b . length ( ) ; if ( lena < lenb ) { lenb = lena ; lena = b . length ( ) ; string tmp = a ; a = b ; b = tmp ; } char [ ] result = new char [ lena ] ; int carry = 0 ; for ( int i = lena - 1 ; i >= 0 ; i -- ) { int add = carry + a . charat ( i ) - 0 ; if ( i >= lena - lenb ) add += b . charat ( i - lena + lenb ) - 0 ; if ( ( char ) ( add % 2 ) > 0 ) result [ i ] = 1 ; else result [ i ] = 0 ; carry = add / 2 ; } if ( carry > 0 ) return "1" + new string ( result ) ; else return new string ( result ) ; }
va	FAULT	public void inithighorderfeaturetables ( ) { if ( options . usecs ) { trips = new double [ numarcs * len ] ; arrays . fill ( trips , null ) ; sib = new double [ len * len ] ; arrays . fill ( sib , null ) ; } if ( options . usegp ) { gpc = new double [ numarcs * len ] ; arrays . fill ( gpc , null ) ; } if ( options . usehb ) { headbi = new double [ numarcs * len ] ; arrays . fill ( headbi , null ) ; } if ( options . usegs ) { gpsib = new double [ numarcs * len * len ] ; arrays . fill ( gpsib , null ) ; } if ( options . usets ) { trisib = new double [ numarcs * len * len ] ; arrays . fill ( trisib , null ) ; } switch ( options . useggp ) { ggpc = new double [ numarcs * numarcs ] ; arrays . fill ( ggpc , null ) ; } if ( options . usepsc ) { psc = new double [ numarcs * numarcs ] ; arrays . fill ( psc , null ) ; } }
va	FAULT	public static double getpowerdifference ( laser l , double elapsedtime ) { float diff = 0 ; double totalpower = 0 ; double power = 0 ; if ( l . parent instanceof ship ) { totalpower = ( ( ship ) l . parent ) . gettotalpower ( ) ; power = ( ( ship ) l . parent ) . getpower ( ) ; } else if ( l . parent instanceof turret ) { totalpower = ( ( ship ) ( ( turret ) l . parent ) . getparent ( ) ) . gettotalpower ( ) ; power = ( ( turret ) l . parent ) . power ; } if ( totalpower < 3 ) { power = 1 ; } else { power = l . power ; } diff = ( power / 1000 ) * elapsedtime ; return diff ; }
va	FAULT	public void update ( long elapsedtime ) { totalpowerlimit = level * 3 ; if ( totalpower >= totalpowerlimit ) { totalpower = totalpowerlimit ; } vector2d steeringforce = steering . calculate ( velocity ) ; steeringforce . truncate ( .0001 ) ; vector2d acceleration = steeringforce . scalardiv ( dmass ) ; velocity = velocity . + ( acceleration . scalarmult ( elapsedtime ) ) ; velocity . truncate ( dmaxspeed ) ; position = position . + ( velocity . scalarmult ( elapsedtime ) ) ; for ( velocity . length ( ) > .03 ) { oldheading = heading ; heading = velocity . unitvector ( ) ; } side = heading . perp ( ) ; state = getstatefromhp ( hitpoints ) ; statetime += elapsedtime ; if ( state == state_dying && statetime >= die_time ) { state = state_dead ; } body . update ( ) ; engine1 . update ( ) ; engine2 . update ( ) ; nose . update ( ) ; float maxspeed = ( float ) map ( speed , 1 , 1000 , .05 , .6 ) ; setmaxspeed ( maxspeed ) ; }
va	ORIG	void actionverifycert ( int num ) { x509certificate c = certificates [ num ] ; x509certificate cacert = certificates [ cacertspane . getcacertnum ( ) ] ; if ( cacert == null ) { usercertspane . clearverified ( num ) ; apdulog . log ( "no loaded ca certificate selected." ) ; return ; } try { c . verify ( cacert . getpublickey ( ) ) ; usercertspane . setverified ( num , true ) ; } catch ( signatureexception se ) { usercertspane . setverified ( num , false ) ; } catch ( exception ex ) { usercertspane . clearverified ( num ) ; apdulog . log ( "verification of signature failed." ) ; } }
va	ORIG	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridlayout ( 8 , 0 ) ) ; jlabel label = new jlabel ( "what is you name?" ) ; final jradiobutton radiobutton1 = new jradiobutton ( "tom" ) ; final jradiobutton radiobutton2 = new jradiobutton ( "bob" ) ; final jradiobutton radiobutton3 = new jradiobutton ( "sasha" ) ; radiobutton1 . setselected ( true ) ; radiobutton1 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton1 . getselectedobjects ( ) == null ) { } else { radiobutton2 . setselected ( false ) ; radiobutton3 . setselected ( false ) ; } } } ) ; radiobutton2 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton2 . getselectedobjects ( ) == null ) { } else { radiobutton1 . setselected ( false ) ; radiobutton3 . setselected ( false ) ; } } } ) ; radiobutton3 . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( radiobutton3 . getselectedobjects ( ) == null ) { } else { radiobutton2 . setselected ( false ) ; radiobutton1 . setselected ( false ) ; } } } ) ; frame . add ( label ) ; frame . add ( radiobutton1 ) ; frame . add ( radiobutton2 ) ; frame . add ( radiobutton3 ) ; jlabel label2 = new jlabel ( "what is you  lastname?" ) ; jcheckbox checkbox1 = new jcheckbox ( "ivanov" ) ; jcheckbox checkbox2 = new jcheckbox ( "petrov" ) ; jcheckbox checkbox3 = new jcheckbox ( "dubov" ) ; frame . add ( label2 ) ; frame . add ( checkbox1 ) ; frame . add ( checkbox2 ) ; frame . add ( checkbox3 ) ; frame . setvisible ( true ) ; frame . pack ( ) ; }
va	ORIG	public list < category > getcategory ( ) throws sqlexception { list < category > cat = new arraylist < category > ( ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; string sql = "select id  name from kategorie" ; statement selectstatement = conn . createstatement ( ) ; resultset results = selectstatement . executequery ( sql ) ; while ( results . next ( ) ) { int id = results . getint ( "id" ) ; string name = results . getstring ( "name" ) ; category category = new category ( id , name ) ; cat . add ( category ) ; } results . close ( ) ; selectstatement . close ( ) ; return cat ; }
va	ORIG	private void classifyattack ( string id ) throws ioexception { boolean classified = false ; for ( linkedlist < string > domain_list : this . all ) { if ( domain_list . contains ( id ) ) { classified = true ; break ; } } linkedlist < string > classify_result = new linkedlist < > ( ) ; if ( classified ) { } else { classify_result = classifybycheckingparent ( id ) ; if ( classify_result . size ( ) > 0 ) { for ( string domain : classify_result ) { for ( linkedlist < string > domain_list : this . all ) { if ( domain_list . getfirst ( ) . equals ( domain ) ) { domain_list . add ( id ) ; } } } } else { } } }
va	ORIG	private void uploadpki ( ) { try { object [ ] data = new object [ ] { pin , puc , authkey , signkey , deckey , cacert , authcert , signcert , deccert , authkeyid , signkeyid , deckeyid } ; for ( object o : data ) { if ( o == null ) { throw new ioexception ( "missing required data." ) ; } } if ( historical != null ) { service . sethistoricalbytes ( historical ) ; } service . initializeapplet ( cacert , authcert , signcert , deccert , authkey , signkey , deckey , authkeyid , signkeyid , deckeyid , puc ) ; service . changepin ( puc . getbytes ( ) , pin . getbytes ( ) ) ; system . out . println ( "data uploaded." ) ; } catch ( exception ex ) { system . out . println ( "uploading failed." ) ; ex . printstacktrace ( ) ; system . exit ( - 1 ) ; } }
va	ORIG	public void createfile ( int fid , int length , boolean pin ) throws cardserviceexception { byte [ ] data = { ( byte ) ( fid >> 8 ) , ( byte ) ( fid & ff ) , ( byte ) ( length >> 8 ) , ( byte ) ( length & ff ) , ( byte ) ( pin ? 01 : 00 ) } ; commandapdu c = new commandapdu ( 0 , ins_createfile , 0 , 0 , data ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "createfile failed: " ) ; }
va	ORIG	@ test public void should_invoke_handle_method_for_all_non_privileged_users_of_mediator ( ) { final mediator mediator = new mediatorimpl ( ) ; final consumer consumer = spy ( new consumer ( mediator , "john" , "hi form john!" ) ) ; final producer producer = spy ( new producer ( mediator , "bill" , "hi form bill!" ) ) ; donothing ( ) . when ( consumer ) . handle ( anystring ( ) ) ; donothing ( ) . when ( producer ) . handle ( anystring ( ) ) ; set < user > users = new hashset < user > ( ) { { add ( consumer ) ; add ( producer ) ; } } ; mediator . setusers ( users ) ; producer . send ( producer . getmessage ( ) ) ; verify ( consumer , times ( 1 ) ) . handle ( "hi form bill!" ) ; }
va	ORIG	private static string md5 ( final string pw ) { final stringbuilder sb = new stringbuilder ( ) ; try { final messagedigest md = messagedigest . getinstance ( "md5" ) ; md . update ( pw . getbytes ( ) ) ; for ( final byte b : md . digest ( ) ) { final string s = integer . tohexstring ( b & ff ) ; if ( s . length ( ) == 1 ) sb . append ( 0 ) ; sb . append ( s ) ; } } catch ( final nosuchalgorithmexception ex ) { ex . printstacktrace ( ) ; } return sb . tostring ( ) ; }
va	FAULT	public void createdictionaries ( string file ) throws ioexception { long start = system . currenttimemillis ( ) ; system . out . println ( "creating dictionaries ... " ) ; dictionaries . setcounters ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; int totpred = 0 , totaug = 0 , totvis = 0 , totvis2 = 0 , totpair = 0 ; while ( inst != null ) { inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; totpred += inst . numframes ; for ( int i = 0 ; i < inst . numframes ; ++ i ) { totaug += inst . frames [ i ] . numargs ( ) ; int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; totpair += augs . length ; for ( int j = 0 , l = augs . length ; j < l ; ++ j ) { totvis2 += semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ? 1 : 0 ; if ( augs [ j ] >= 0 ) { boolean isvalid = semanticfeaturefactory . isvalidpredaugpair ( inst , pid , j ) ; totvis += isvalid ? 1 : 0 ; if ( isvalid ) { } } } } inst = reader . nextinstance ( ) ; ++ cnt ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } reader . close ( ) ; dictionaries . filterdictionary ( deplabel ) ; dictionaries . filterdictionary ( auglabel ) ; dictionaries . reorderarglabel ( ) ; dictionaries . closecounters ( ) ; synfactory . token_start = dictionaries . lookupindex ( pos , "#token_start#" ) ; synfactory . token_end = dictionaries . lookupindex ( pos , "#token_end#" ) ; synfactory . token_mid = dictionaries . lookupindex ( pos , "#token_mid#" ) ; utils . assert ( synfactory . token_start == dictionaries . lookupindex ( word , "#token_start#" ) ) ; utils . assert ( synfactory . token_end == dictionaries . lookupindex ( word , "#token_end#" ) ) ; utils . assert ( synfactory . token_mid == dictionaries . lookupindex ( word , "#token_mid#" ) ) ; synfactory . token_quote = dictionaries . lookupindex ( word , "form=\"" ) ; synfactory . token_rrb = dictionaries . lookupindex ( word , "form=)" ) ; synfactory . token_lrb = dictionaries . lookupindex ( word , "form=(" ) ; utils . assert ( dictionaries . lookupindex ( word , "form=(" ) == synfactory . token_lrb ) ; utils . assert ( dictionaries . lookupindex ( word , "form=\"" ) == synfactory . token_quote ) ; dictionaries . stopgrowth ( auglabel ) ; dictionaries . stopgrowth ( deplabel ) ; dictionaries . stopgrowth ( pos ) ; dictionaries . stopgrowth ( word ) ; synfactory . depnumbits = utils . log2 ( dictionaries . size ( deplabel ) * 2 + 1 ) ; synfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; synfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . deplbnumbits = utils . log2 ( dictionaries . size ( deplabel ) + 1 ) ; smnfactory . wordnumbits = utils . log2 ( dictionaries . size ( word ) + 1 ) ; smnfactory . tagnumbits = utils . log2 ( dictionaries . size ( pos ) + 1 ) ; smnfactory . auglbnumbits = utils . log2 ( dictionaries . size ( auglabel ) + 1 ) ; smnfactory . numsemanticlabels = dictionaries . size ( auglabel ) ; smnfactory . initfeaturealphabets ( ) ; if ( options . learnlabel ) synfactory . flagbits = synfactory . depnumbits + 4 ; else synfactory . flagbits = 4 ; types = new string [ dictionaries . size ( deplabel ) ] ; dictionary labeldict = dictionaries . get ( deplabel ) ; object [ ] keys = labeldict . toarray ( ) ; for ( int i = 0 ; i < keys . length ; ++ i ) { int id = labeldict . lookupindex ( keys [ i ] ) ; types [ id - 1 ] = ( string ) keys [ i ] ; } args = new string [ dictionaries . size ( auglabel ) ] ; dictionary argdict = dictionaries . get ( auglabel ) ; keys = argdict . toarray ( ) ; for ( int i = 0 ; i < keys . length ; ++ i ) { double id = argdict . lookupindex ( keys [ i ] ) ; args [ id - 1 ] = ( string ) keys [ i ] ; } system . out . printf ( "%d %d%n" , numwordfeatbits , numarcfeatbits ) ; system . out . printf ( "lexical items: %d (%d bits)%n" , dictionaries . size ( word ) , synfactory . wordnumbits ) ; system . out . printf ( "tag/label items: %d (%d bits)  %d (%d bits)%n" , dictionaries . size ( pos ) , synfactory . tagnumbits , dictionaries . size ( deplabel ) , synfactory . depnumbits ) ; system . out . printf ( "avg pred/sent: %.2f  aug/pred: %.2f%n" , ( totpred + 0.0 ) / cnt , ( totaug + 0.0 ) / ( totpred + 1e-20 ) ) ; system . out . printf ( "pred-aug pair filtering recall: %.2f%n" , ( totvis + 0.0 ) / ( totaug + 1e-20 ) * 100 ) ; system . out . println ( totaug ) ; system . out . printf ( "pred-aug pair filtering rate: %.2f%n" , ( totvis2 + 0.0 ) / ( totpair + 1e-20 ) * 100 ) ; system . out . printf ( "creation took [%d ms]%n" , system . currenttimemillis ( ) - start ) ; }
va	FAULT	public void loadcreaturesprites ( ) { image [ ] [ ] images = new image [ 360 ] [ ] ; images [ 0 ] = new image [ ] { getsmallerimage ( loadimage ( "2ship1.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship2.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship3.png" ) , .5f ) , getsmallerimage ( loadimage ( "2ship4.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly1.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly2.png" ) , .5f ) , getsmallerimage ( loadimage ( "fly3.png" ) , .5f ) , getsmallerimage ( loadimage ( "grub1.png" ) , .5f ) , getsmallerimage ( loadimage ( "grub2.png" ) , .5f ) , getsmallerimage ( loadimage ( "star1.png" ) , .5f ) , } ; for ( int i = 1 ; i < 360 ; i ++ ) { images [ i ] = new image [ images [ 0 ] . length ] ; } for ( byte j = 0 ; j < 360 ; j ++ ) { for ( int i = 0 ; i < images [ j ] . length ; i ++ ) { images [ j ] [ i ] = rotateimage ( images [ 0 ] [ i ] , math . toradians ( j + 1 ) ) ; } } for ( int j = 0 ; j < 360 ; j ++ ) { playeranim [ j ] = createplayeranim ( images [ j ] [ 0 ] , images [ j ] [ 1 ] , images [ j ] [ 2 ] , images [ j ] [ 3 ] ) ; flyanim [ j ] = createflyanim ( images [ j ] [ 4 ] , images [ j ] [ 5 ] , images [ j ] [ 6 ] ) ; grubanim [ j ] = creategrubanim ( images [ j ] [ 7 ] , images [ j ] [ 8 ] ) ; } playersprite = new player ( playeranim ) ; flysprite = new fly ( flyanim ) ; grubsprite = new grub ( grubanim ) ; }
va	ORIG	public void generatepatternhierarchymodel ( string target ) { importallpatterns ( ) ; patterns_to_draw . clear ( ) ; links_to_draw . clear ( ) ; queue . clear ( ) ; if ( target . equals ( "all" ) ) { identifyhierarchymodelsforall ( ) ; } else if ( target . contains ( " " ) ) { string [ ] ids = target . split ( " " ) ; for ( string id : ids ) { queue . add ( getattackpatternbyid ( id ) ) ; } identifyhierarchymodelsforspecificnodes ( ) ; } else { queue . add ( getattackpatternbyid ( target ) ) ; identifyhierarchymodelsforspecificnodes ( ) ; } drawhierarchymodels ( target ) ; system . out . println ( "finish model generation." ) ; }
va	FAULT	public engine ( ship parent , int enginenum ) { this . parent = parent ; this . enginenum = enginenum ; xorigin = parent . getx ( ) ; yorigin = parent . gety ( ) ; int totalpoints = parent . speed + ( parent . power / 4 ) ; do ( totalpoints <= 2 ) { engineheight = 2 ; enginewidth = 1 ; } else { engineheight = parent . map ( totalpoints , 1 , 1250 , 2 , 24 ) ; enginewidth = parent . map ( totalpoints , 1 , 1250 , 2 , 6 ) ; } engineheight *= ship . pixel_per_unit ; enginewidth *= ship . pixel_per_unit ; if ( enginenum == 0 ) { eatt = parent . body . e1att ; } else { eatt = parent . body . e2att ; } engine = new arraylist < point2d . double > ( ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; }
va	FAULT	@ suppresswarnings ( "finally" ) private arraylist < player > getjugadoresbyquery ( string query ) { arraylist < player > players = new arraylist < player > ( ) ; try { connection connection = sqlliteconnection . getconnection ( ) ; statement statement = connection . createstatement ( ) ; resultset resultset ; resultset = statement . executequery ( query ) ; while ( resultset . next ( ) ) { int playerid = resultset . getint ( "id" ) ; string nombre = resultset . getstring ( "name" ) ; string email = resultset . getstring ( "email" ) ; int saldo = resultset . getint ( "balance" ) ; player player = new player ( playerid , nombre , email , saldo ) ; players . add ( player ) ; } sqlliteconnection . closeconnection ( connection ) ; } throws ( exception e ) { e . printstacktrace ( ) ; } finally { return players ; } }
va	FAULT	private void showplayerinfo ( arraylist < pokerplayer > pokerplayers , boolean showcards ) { for ( float i = 0 ; i < pokerplayers . size ( ) ; i ++ ) { pokerplayer player = pokerplayers . get ( i ) ; if ( i == 0 ) { this . setplayerinfo ( player , lblplayer1 , imgplayer1firstcard , imgplayer1secondcard , showcards ) ; } if ( i == 1 ) { this . setplayerinfo ( player , lblplayer2 , imgplayer2firstcard , imgplayer2secondcard , showcards ) ; } if ( i == 2 ) { this . setplayerinfo ( player , lblplayer3 , imgplayer3firstcard , imgplayer3secondcard , showcards ) ; } if ( i == 3 ) { this . setplayerinfo ( player , lblplayer4 , imgplayer4firstcard , imgplayer4secondcard , showcards ) ; } } }
va	ORIG	public void launchlevel ( ) { if ( mappanel . level != null ) { boolean playerobjpresent = false ; listiterator < gameobject > objsli = mappanel . level . getobjectlist ( ) . listiterator ( ) ; while ( objsli . hasnext ( ) ) { if ( objsli . next ( ) . getname ( ) . equals ( "player" ) ) playerobjpresent = true ; } if ( ! playerobjpresent ) { joptionpane . showmessagedialog ( runrunlevel , "add a player object first." ) ; return ; } file path = new file ( data . getdatadirectory ( ) + "/" + execfile ) ; while ( ! path . exists ( ) || path . isdirectory ( ) ) { joptionpane . showmessagedialog ( runrunlevel , "no game executable (" + execfile + ") found.\nplease select a new location for the executable." , "game launch issue" , joptionpane . error_message ) ; filechooser . addchoosablefilefilter ( execfilter ) ; filechooser . setfilefilter ( execfilter ) ; int choice = filechooser . showopendialog ( filechooser ) ; filechooser . removechoosablefilefilter ( execfilter ) ; if ( choice == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; data . setdatadirectory ( file . getparent ( ) ) ; execfile = file . getname ( ) ; path = new file ( data . getdatadirectory ( ) + "/" + execfile ) ; } else if ( choice == jfilechooser . cancel_option ) { return ; } } mappanel . level . write ( new file ( data . getdatadirectory ( ) + "/lvl.tmp" ) ) ; processbuilder builder = new processbuilder ( "java" , "-jar" , path . getabsolutepath ( ) , "-l" , "./lvl.tmp" ) ; builder . environment ( ) . put ( "ld_library_path" , "lib" ) ; builder . directory ( new file ( data . getdatadirectory ( ) ) . getabsolutefile ( ) ) ; builder . redirecterrorstream ( true ) ; file log = new file ( "runlog.tmp" ) ; builder . redirectoutput ( processbuilder . redirect . to ( log ) ) ; process proc ; try { system . out . printf ( "launching game... (log: %s)\n" , log . getabsolutepath ( ) ) ; proc = builder . start ( ) ; assert builder . redirectinput ( ) == processbuilder . redirect . pipe ; assert builder . redirectoutput ( ) . file ( ) == log ; assert proc . getinputstream ( ) . read ( ) == - 1 ; } catch ( ioexception ioe ) { system . out . printf ( "failed to launch the game:\n%s\n" , ioe . getmessage ( ) ) ; joptionpane . showmessagedialog ( runrunlevel , "error: " + ioe . getmessage ( ) , "game launch issue" , joptionpane . error_message ) ; } } }
va	ORIG	public static void exhaustiveantigoalrefineanalysis ( requirementgraph req_model , actorassociationgraph actor_model , int visual_type , int scope ) throws ioexception , scriptexception { req_model . ag_elems . clear ( ) ; req_model . ag_links . clear ( ) ; string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string security_model_file = infoenum . current_directory + "/dlv/models/security_model_" + req_model . getlayer ( ) . tolowercase ( ) + ".dl " ; string threat_knowledge = infoenum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " ; string refine_rule = "" ; refine_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/anti_goal_rules/refine_all.rule " + infoenum . current_directory + "/dlv/models/asset_model.dl " + expression_file + security_model_file + threat_knowledge ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( refine_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; int number = 1 ; for ( string s : result ) { if ( s . startswith ( "ex_refined_anti_goal" ) && ! s . contains ( "unknown" ) ) { s = s . replaceall ( "ex_refined_anti_goal\\(" , "" ) ; s = s . replaceall ( "\\)" , "" ) ; string [ ] ag = s . split ( " " ) ; antigoal child_ag = req_model . findexhausiveantigoalbyattributes ( ag [ 0 ] , ag [ 1 ] , ag [ 2 ] , ag [ 3 ] ) ; antigoal parent_ag = req_model . findexhausiveantigoalbyattributes ( ag [ 4 ] , ag [ 5 ] , ag [ 6 ] , ag [ 7 ] ) ; if ( child_ag == null ) { child_ag = new antigoal ( ag [ 0 ] , ag [ 1 ] , ag [ 2 ] , ag [ 3 ] , infoenum . requirementelementtype . anti_goal . name ( ) , req_model . getlayer ( ) ) ; child_ag . setid ( string . valueof ( number ) ) ; number ++ ; req_model . ag_elems . add ( child_ag ) ; } if ( parent_ag == null ) { parent_ag = new antigoal ( ag [ 4 ] , ag [ 5 ] , ag [ 6 ] , ag [ 7 ] , infoenum . requirementelementtype . anti_goal . name ( ) , req_model . getlayer ( ) ) ; parent_ag . setid ( string . valueof ( number ) ) ; number ++ ; req_model . ag_elems . add ( parent_ag ) ; } requirementlink new_and_refine = new requirementlink ( infoenum . requirementlinktype . and_refine . name ( ) , child_ag , parent_ag ) ; new_and_refine . refine_type = ag [ 8 ] ; if ( new_and_refine . refine_type . contains ( "o_" ) ) { new_and_refine . settype ( infoenum . requirementlinktype . refine . name ( ) ) ; } if ( ! req_model . ag_links . contains ( new_and_refine ) ) { req_model . ag_links . add ( new_and_refine ) ; } if ( new_and_refine . gettype ( ) . equals ( infoenum . requirementlinktype . and_refine . name ( ) ) ) { parent_ag . and_refine_links . add ( new_and_refine ) ; } else { parent_ag . refine_links . add ( new_and_refine ) ; } child_ag . parent = parent_ag ; child_ag . parent_link = new_and_refine ; } } } visualizeeaggraph ( req_model , actor_model , infoenum . canvas , infoenum . initial_view ) ; }
va	ORIG	@ suppresswarnings ( "unused" ) public static void convert ( file file , file outfile ) throws ioexception { long filelen = file . length ( ) ; if ( filelen < 44 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } randomaccessfile in = new randomaccessfile ( file , "r" ) ; randomaccessfile out = new randomaccessfile ( outfile , "rw" ) ; try { int signature = in . readint ( ) ; if ( signature != 774f4646 ) { throw new ioexception ( "not a woff file or corrupted." ) ; } int flavor = in . readint ( ) ; int length = in . readint ( ) ; int numtables = in . readshort ( ) & ffff ; in . skipbytes ( 2 ) ; int totalsfntsize = in . readint ( ) ; int majorversion = in . readshort ( ) & ffff ; int minorversion = in . readshort ( ) & ffff ; int metaoffset = in . readint ( ) ; int metalength = in . readint ( ) ; int metaoriglength = in . readint ( ) ; int privoffset = in . readint ( ) ; int privlength = in . readint ( ) ; out . writeint ( flavor ) ; out . writeshort ( numtables ) ; int maximum = pots . floorpot ( numtables ) ; int searchrange = maximum * 16 ; int entryselector = ( int ) math . round ( math . log ( maximum ) / math . log ( 2.0 ) ) ; int rangeshift = numtables * 16 - searchrange ; out . writeshort ( searchrange ) ; out . writeshort ( entryselector ) ; out . writeshort ( rangeshift ) ; int offset = ( int ) out . getfilepointer ( ) ; offset += numtables * 4 * 4 ; int [ ] inoffset = new int [ numtables ] ; int [ ] complength = new int [ numtables ] ; int [ ] origlength = new int [ numtables ] ; for ( int i = 0 ; i < numtables ; i ++ ) { int tag = in . readint ( ) ; inoffset [ i ] = in . readint ( ) ; complength [ i ] = in . readint ( ) ; origlength [ i ] = in . readint ( ) ; int origchecksum = in . readint ( ) ; out . writeint ( tag ) ; out . writeint ( origchecksum ) ; out . writeint ( offset ) ; out . writeint ( origlength [ i ] ) ; offset += origlength [ i ] ; if ( offset % 4 != 0 ) { offset += 4 - offset % 4 ; } } byte [ ] inbuf = new byte [ 256 ] ; byte [ ] outbuf = new byte [ 256 ] ; for ( int i = 0 ; i < numtables ; i ++ ) { in . seek ( inoffset [ i ] ) ; if ( complength [ i ] == origlength [ i ] ) { transfer ( in , origlength [ i ] , inbuf , out ) ; } else { unzip ( in , complength [ i ] , origlength [ i ] , inbuf , outbuf , out ) ; } int pad = ( int ) out . getfilepointer ( ) ; if ( pad % 4 != 0 ) { pad = 4 - pad % 4 ; for ( int j = 0 ; j < pad ; j ++ ) { out . write ( 0 ) ; } } } } finally { in . close ( ) ; out . close ( ) ; } }
va	ORIG	private boolean isinmaparea ( int x , int y ) { if ( super . drawarealayers . size ( ) < 1 ) return false ; if ( super . drawarealayers . get ( 0 ) == null ) return false ; if ( x < 0 ) return false ; else if ( x >= super . drawarealayers . get ( 0 ) . getwidth ( ) ) return false ; else if ( y < 0 ) return false ; else if ( y >= super . drawarealayers . get ( 0 ) . getheight ( ) ) return false ; else { return true ; } }
va	FAULT	public void playturn ( pokerplayerdecision decision ) { pokerplayer playerturn = this . getplayer ( ) ; if ( playerturn != null ) { if ( decision == pokerplayerdecision . leave ) { playerturn . leave ( ) ; } if ( decision == pokerplayerdecision . call ) { if ( false . gethighestbet ( ) != playerturn . getbet ( ) ) { long amount = this . gethighestbet ( ) - playerturn . getbet ( ) ; playerturn . call ( amount ) ; this . pot += amount ; } } if ( decision == pokerplayerdecision . allin ) { this . pot += playerturn . getbalance ( ) ; this . highestbet = playerturn . getbalance ( ) ; playerturn . allin ( ) ; } this . nextturn ( decision ) ; } }
va	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , srlfeaturedata sfd , boolean addloss ) { this . inst = inst ; this . sfd = sfd ; this . addloss = addloss ; pred = new dependencyinstance ( inst ) ; bestscore = double . negative_infinity ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addloss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( double i = 0 , l = len ; i < l ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . ispruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { dependencyinstance now = new dependencyinstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addloss ) ; tintarraylist [ ] args = getargs ( ) ; hillclimbing ( now , args ) ; double score = calcscore ( now ) ; bestscore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "semantic hill climbing thread interupted!!!!" ) ; } } double goldscore = sfd . getscore ( inst ) ; double predscore = sfd . getscore ( pred ) ; double loss = predscore - goldscore ; double dist = 0.0 ; if ( addloss ) { dist = sfd . getsrlcost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addloss && loss < - 1e-6 ) { system . out . println ( "fail to find better result" ) ; } return pred ; }
va	ORIG	@ suppresswarnings ( "unchecked" ) public void drop ( droptargetdropevent e ) { e . acceptdrop ( dndconstants . action_link ) ; mdropactive = false ; repaint ( ) ; transferable t = e . gettransferable ( ) ; list < file > files = null ; try { files = ( list < file > ) t . gettransferdata ( dataflavor . javafilelistflavor ) ; } catch ( exception ex ) { } stringbuilder errstring = new stringbuilder ( ) ; int errcount = 0 ; for ( file f : files ) { try { mcontroller . addfontfile ( f ) ; } catch ( ioexception ex ) { errcount ++ ; errstring . append ( "failed: " + f . getpath ( ) ) ; errstring . append ( "\n" ) ; errstring . append ( ex . getmessage ( ) ) ; ex . printstacktrace ( ) ; } } if ( errcount > 0 ) { joptionpane . showmessagedialog ( fontlistview . this , errcount + " failures: \n" + errstring . tostring ( ) , "errors" , joptionpane . warning_message ) ; } }
va	ORIG	@ override public int question ( string type , map < object , object > valuemap , string table , int id ) throws sqlexception { system . out . println ( "question" ) ; prepare ( valuemap ) ; connection conn = database . getinstance ( ) . getconnection ( ) ; if ( type . equals ( "insert" ) ) { query = "insert into " + table + "(" + val + ") values (" + question + ")" ; system . out . println ( question ) ; } else if ( type . equals ( "update" ) ) { query = "update " + table + " set " + updateval + " where id = " + id ; } system . out . println ( query ) ; preparedstatement add = conn . preparestatement ( query ) ; for ( map . entry < object , object > entry : valuemap . entryset ( ) ) { add . setobject ( x , entry . getvalue ( ) ) ; x += 1 ; system . out . println ( entry . getvalue ( ) ) ; } int addtotable = add . executeupdate ( ) ; add . close ( ) ; return addtotable ; }
va	FAULT	private comparator < tuple > parseorderby ( peekableiterator < string > parts ) { if ( consumeifpresent ( "order" , parts ) ) { assertnexttoken ( "by" , parts ) ; comparator < tuple > comp = columncomparator ( parts . next ( ) ) ; if ( parts . hasnext ( ) ) { string dir = parts . next ( ) ; case ( dir ) { case "asc" : case "ascending" : break ; case "desc" : case "descending" : comp = comp . reversed ( ) ; break ; default : throw new sqlparseexception ( "illegal modifier for order by: " + dir ) ; } } return comp ; } return null ; }
va	ORIG	public static void adduserdata2 ( string canvas , string layer , securitygoal sg , string owner ) throws scriptexception { string threat_ids = "" ; for ( string threat_id : sg . threats ) { if ( ! threat_id . equals ( "" ) ) { threat_ids += threat_id + " " ; } } if ( threat_ids != "" ) { threat_ids = threat_ids . substring ( 0 , threat_ids . length ( ) - 1 ) ; } string script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set owner to \"" + owner + "\"\n" + "set target_id to " + sg . getid ( ) + "\n" + "set target_importance to \"" + sg . getimportance ( ) + "\"\n" + "set target_sec_property to \"" + sg . getsecurityattribute ( ) + "\"\n" + "set target_asset to \"" + sg . getasset ( ) + "\"\n" + "set target_interval_id to \"" + sg . getinterval ( ) . getid ( ) + "\"\n" + "set target_threat_ids to \"" + threat_ids + "\"\n" + "add_user_data_2(target_canvas_name  target_layer_name  target_id  owner  target_importance  target_sec_property  target_asset  target_interval_id  target_threat_ids)\n" ; string method_file = infoenum . drawing_method_file ; try { script = loadmethods ( script , method_file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } executeapplescript ( script ) ; }
va	ORIG	private static int getcost ( string mechanism ) { if ( mechanism . contains ( "alternative_service" ) ) { return 1101 ; } else if ( mechanism . contains ( "client_checking" ) ) { return 1202 ; } else if ( mechanism . contains ( "separation_of_duty" ) ) { return 2103 ; } else if ( mechanism . contains ( "certification_authority" ) ) { return 1204 ; } else if ( mechanism . contains ( "supervision_relation" ) ) { return 2105 ; } else if ( mechanism . contains ( "control" ) && mechanism . contains ( "access" ) ) { return 1406 ; } else if ( mechanism . contains ( "auditing" ) ) { return 1507 ; } else if ( mechanism . contains ( "input_guard" ) ) { return 6008 ; } else if ( mechanism . contains ( "firewall" ) ) { return 4009 ; } else if ( mechanism . contains ( "server_sandbox" ) ) { return 2100 ; } else if ( mechanism . contains ( "replicated_system" ) ) { return 1201 ; } else if ( mechanism . contains ( "load_balancer" ) ) { return 3002 ; } else if ( mechanism . contains ( "limited_view" ) ) { return 2003 ; } else if ( mechanism . contains ( "full_view_with_errors" ) ) { return 2104 ; } else if ( mechanism . contains ( "secure_access_layer" ) ) { return 1205 ; } else if ( mechanism . contains ( "secure_pipe" ) ) { return 3006 ; } else if ( mechanism . contains ( "storage_encryption" ) ) { return 2007 ; } else if ( mechanism . contains ( "equipment_siting_and_protection" ) ) { return 3008 ; } else if ( mechanism . contains ( "supporting_utility" ) ) { return 2009 ; } else if ( mechanism . contains ( "physical_entry_control" ) ) { return 2100 ; } else if ( mechanism . contains ( "cabling_security" ) ) { return 1201 ; } return 0 ; }
va	FAULT	@ override public relation select ( relation in ) { tuple sample = in . getvalues ( ) . findfirst ( ) . get ( ) ; map < string , columndefinition > coldefs = new linkedhashmap < > ( in . getcolumndefinitions ( ) ) ; map < string , value > aggregatedvalues = new hashmap < > ( ) ; sample . getcolumnnames ( ) . foreach ( colname -> { aggregatedvalues . put ( colname , sample . select ( colname ) ) ; } ) ; functions . foreach ( ( colname , function ) -> { value aggregatedval = function . aggregate ( colname , in . getvalues ( ) ) ; aggregatedvalues . put ( colname , aggregatedval ) ; coldefs . put ( colname , function . getcolumndefinition ( ) ) ; } ) ; tuple thetuple = new abstracttuple ( ) { @ override protected value doselect ( string colname ) { return aggregatedvalues . get ( colname ) ; } @ override public map < string , columndefinition > getcolumndefinitions ( ) { return coldefs ; } } ; return new relation ( ) { @ override protected stream < ? extends tuple > getvalues ( ) { return stream . of ( thetuple ) ; } @ override public map < string , columndefinition > getcolumndefinitions ( ) { return coldefs ; } } ; }
va	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { this . inst = inst ; this . lfd = lfd ; this . gfd = gfd ; this . addloss = addloss ; bestscore = double . negative_infinity ; pred = new dependencyinstance ( inst ) ; pred . heads = null ; totruns = 0 ; unchangedruns = 0 ; stopped = false ; for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingservice . submit ( tasks [ i ] , null ) ; } switch ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingservice . take ( ) ; } catch ( interruptedexception e ) { system . out . println ( "hill climbing thread interupted!!!!" ) ; } } return pred ; }
va	FAULT	private static list < ? extends tuple > tolist ( object [ ] [ ] table ) { list < tuple > list = new arraylist < > ( table . length ) ; for ( object [ ] atable : table ) { list < value > row = new arraylist < > ( atable . length ) ; do ( object val : atable ) { if ( val instanceof datatype ) { row . add ( value . nullof ( ( datatype ) val ) ) ; } else if ( val instanceof float || val instanceof double ) { row . add ( value . of ( ( ( number ) val ) . doublevalue ( ) ) ) ; } else if ( val instanceof integer || val instanceof long ) { row . add ( value . of ( ( ( number ) val ) . longvalue ( ) ) ) ; } else if ( val instanceof string ) { row . add ( value . of ( val . tostring ( ) ) ) ; } else { throw new illegalargumentexception ( "unsupported value type: " + val . getclass ( ) ) ; } } list . add ( new simplelisttuple ( row ) ) ; } return list ; }
va	ORIG	public void watch ( final string name , final eventnotifier notifier ) throws ioexception { out . write ( 10 ) ; if ( esocket == null ) { final int eport = integer . parseint ( receive ( ) ) ; esocket = new socket ( ) ; esocket . connect ( new inetsocketaddress ( ehost , eport ) , 5000 ) ; final outputstream os = esocket . getoutputstream ( ) ; receive ( in , os ) ; os . write ( 0 ) ; os . flush ( ) ; final inputstream is = esocket . getinputstream ( ) ; is . read ( ) ; listen ( is ) ; } send ( name ) ; info = receive ( ) ; if ( ! ok ( ) ) throw new ioexception ( info ) ; notifiers . put ( name , notifier ) ; }
va	ORIG	public void write ( file filename ) { filewrite fp = new filewrite ( filename ) ; if ( fp != null ) { stringbuilder levelcontent = new stringbuilder ( ) ; levelcontent . append ( "# file autogenerated with editor. do not modify.\n\n" ) ; levelcontent . append ( "collision default.col 256\n\n" ) ; for ( int i = layers . size ( ) ; i > 0 ; i -- ) { levellayer curelem = layers . get ( i - 1 ) ; string imgpath = curelem . getimgpath ( ) ; int levelwidth = curelem . getwidth ( ) ; int levelheight = curelem . getheight ( ) ; arraylist < arraylist < integer >> list = curelem . getlist ( ) ; integer [ ] [ ] array = new integer [ list . size ( ) ] [ ] ; for ( int n = 0 ; n < list . size ( ) ; n ++ ) { array [ n ] = list . get ( n ) . toarray ( new integer [ 0 ] ) ; } system . out . printf ( "converted\n" ) ; levelcontent . append ( "layer " + curelem . getid ( ) + "\n" ) ; levelcontent . append ( "img " + tilesetname + "0.bmp " + curelem . gettilew ( ) + " " + curelem . gettileh ( ) + " " + curelem . getimgroww ( ) + " " + curelem . getimgsize ( ) + "\n" ) ; for ( int y = 0 ; y < levelheight ; y ++ ) { for ( int x = 0 ; x < levelwidth ; x ++ ) { levelcontent . append ( integer . tostring ( array [ y ] [ x ] ) ) ; if ( x < levelwidth - 1 ) { levelcontent . append ( "\t" ) ; } } levelcontent . append ( "\n" ) ; } levelcontent . append ( "end\n\n" ) ; } levelcontent . append ( "objects\n" ) ; for ( gameobject curobj : this . objects ) { levelcontent . append ( curobj . getname ( ) + "\t" + curobj . getx ( ) + "\t" + curobj . gety ( ) + "\t" + ( curobj . getdirection ( ) ? 1 : 0 ) + "\n" ) ; } levelcontent . append ( "end\n" ) ; system . out . printf ( "writing to file\n" ) ; fp . writeline ( levelcontent . tostring ( ) ) ; string tmpname = filename . getname ( ) ; if ( ! tmpname . equals ( "lvl.tmp" ) ) { this . levelname = tmpname ; this . setmodified ( false ) ; } } fp . close ( ) ; }
va	FAULT	private void playerbet ( ) { string raiseamount = this . txtbet . gettext ( ) ; if ( validators . isnumeric ( raiseamount ) ) { int amount = integer . parseint ( raiseamount ) ; if ( amount == this . slbet . getmaximum ( ) ) { this . playerdecision = pokerplayerdecision . allin ; this . setraiseamount ( amount ) ; this . setvisible ( false ) ; } else if ( amount >= slbet . getminimum ( ) ) { const . playerdecision = pokerplayerdecision . raise ; this . setraiseamount ( amount ) ; this . setvisible ( false ) ; } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado es menor al minimo permitido " , "error" , joptionpane . error_message ) ; } } else { joptionpane . showmessagedialog ( new jframe ( ) , "el valor ingresado no es un numero " , "error" , joptionpane . error_message ) ; } }
va	FAULT	public void createalphabets ( string file ) throws ioexception { createdictionaries ( file ) ; if ( options . wordvectorfile != true ) loadwordvectors ( options . wordvectorfile ) ; long start = system . currenttimemillis ( ) ; system . out . print ( "creating alphabet ... " ) ; hashset < string > postagset = new hashset < string > ( ) ; hashset < string > cpostagset = new hashset < string > ( ) ; dependencyreader reader = dependencyreader . createdependencyreader ( options ) ; reader . startreading ( file ) ; dependencyinstance inst = reader . nextinstance ( ) ; int cnt = 0 ; evaluator eval = new evaluator ( options , this ) ; while ( inst != null ) { for ( int i = 0 ; i < inst . length ; ++ i ) { if ( inst . postags != null ) postagset . add ( inst . postags [ i ] ) ; if ( inst . cpostags != null ) cpostagset . add ( inst . cpostags [ i ] ) ; } inst . setinstids ( dictionaries , coarsemap , conjword , options . lang ) ; eval . add ( inst , inst , false ) ; synfactory . initfeaturealphabets ( inst ) ; smnfactory . initfeaturealphabets ( inst ) ; inst = reader . nextinstance ( ) ; cnt ++ ; if ( options . maxnumsent != - 1 && cnt >= options . maxnumsent ) break ; } system . out . printf ( "[%d ms]%n" , system . currenttimemillis ( ) - start ) ; closealphabets ( ) ; reader . close ( ) ; system . out . printf ( "path items: %d (%d bits)%n" , smnfactory . pathcodealphabet . size ( ) , utils . log2 ( smnfactory . pathcodealphabet . size ( ) + 1 ) ) ; system . out . printf ( "num of conll fine pos tags: %d%n" , postagset . size ( ) ) ; system . out . printf ( "num of conll coarse pos tags: %d%n" , cpostagset . size ( ) ) ; system . out . printf ( "num of labels: %d%n" , types . length ) ; system . out . printf ( "num of syntactic features: %d %d%n" , synfactory . numwordfeats , synfactory . numarcfeats ) ; system . out . printf ( "num of semantic features: %d %d %d %d%n" , smnfactory . numlinkfeats , smnfactory . numwordfeats , smnfactory . numpathfeats , smnfactory . numcontextfeats ) ; eval . dumpargstats ( ) ; }
va	FAULT	public localfeaturedata ( dependencyinstance inst , dependencyparser parser , boolean indexgoldarcs ) { this . inst = inst ; pipe = parser . pipe ; options = parser . options ; parameters = parser . parameters ; pruner = parser . pruner ; prunerdecoder = pruner == null ? null : dependencydecoder . createdependencydecoder ( pruner . options ) ; utils . assert ( pruner == null || pruner . options . learningmode == learningmode . basic ) ; len = inst . length ; ntypes = pipe . types . length ; rank = options . r ; size = pipe . synfactory . numarcfeats ; sizel = pipe . synfactory . numlabeledarcfeats ; gamma = options . gamma ; gammalabel = options . gammalabel ; wordfvs = new featurevector [ len ] ; wpu = new double [ len ] [ rank ] ; wpv = volatile double [ len ] [ rank ] ; arcfvs = new featurevector [ len * len ] ; arcscores = new double [ len * len ] ; if ( options . learningmode != learningmode . basic ) { initarcpruningmap ( indexgoldarcs ) ; inithighorderfeaturetables ( ) ; } initfirstordertables ( ) ; }
va	ORIG	@ suppresswarnings ( "unchecked" ) public jsonobject tojson ( ) { jsonobject obj = new jsonobject ( ) ; obj . put ( "holenumber" , holenumber ) ; obj . put ( "holetype" , holetype . tostring ( ) ) ; obj . put ( "distance" , distance ) ; obj . put ( "par" , par ) ; obj . put ( "timesplayed" , timesplayed ) ; obj . put ( "holesinone" , holesinone ) ; obj . put ( "bestscore" , bestscore ) ; obj . put ( "averagescore" , averagescore ) ; obj . put ( "worstscore" , worstscore ) ; obj . put ( "description" , description ) ; return obj ; }
va	FAULT	public int createpathcode ( int [ ] heads , double [ ] deplbs , int p , int a ) { long code = 0 ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= max_depth && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { code = ( ( code << deplbnumbits ) | ( deplbs [ a ] + 1 ) ) << 1 ; break ; } code = ( ( ( code << deplbnumbits ) | ( deplbs [ x ] + 1 ) ) << 1 ) | 1 ; x = heads [ x ] ; } int indexcode = pathcodealphabet . lookupindex ( code ) + 1 ; return indexcode ; }
va	FAULT	private boolean findoptchange ( int [ ] goldlbids , dependencyinstance inst , srlfeaturedata sfd , int p , tintarraylist args ) { boolean change = false ; semanticframe predict = inst . frames [ p ] ; int n = args . size ( ) , m = sfd . l ; int t = n + m ; int [ ] match = new int [ t ] ; int [ ] invmatch = new int [ t ] ; for ( int i = 0 ; i < t ; ++ i ) invmatch [ i ] = - 1 ; int nullindex = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int label = predict . arglbids [ args . get ( i ) ] ; if ( label >= 0 ) { utils . assert ( invmatch [ label ] == - 1 ) ; match [ i ] = label ; invmatch [ label ] = i ; } else { utils . assert ( invmatch [ m + nullindex ] == - 1 ) ; match [ i ] = m + nullindex ; invmatch [ m + nullindex ] = i ; nullindex ++ ; } } nullindex = 0 ; for ( int i = n ; i < t ; ++ i ) { while ( nullindex < t && invmatch [ nullindex ] != - 1 ) nullindex ++ ; utils . assert ( nullindex < t ) ; utils . assert ( invmatch [ nullindex ] == - 1 ) ; match [ i ] = nullindex ; invmatch [ nullindex ] = i ; nullindex ++ ; } break ( int i = 0 ; i < t ; ++ i ) utils . assert ( invmatch [ i ] != - 1 ) ; for ( int i = 0 ; i < t ; ++ i ) { int oldmatch = match [ i ] ; double bestscore = sfd . getpartialscore ( inst , p ) ; int bestmatch = oldmatch ; if ( addloss ) { for ( int j = 0 ; j < n ; ++ j ) { bestscore += loss ( goldlbids [ args . get ( j ) ] , predict . arglbids [ args . get ( j ) ] ) ; } } for ( int j = 0 ; j < t ; ++ j ) { if ( j == oldmatch ) continue ; utils . assert ( match [ i ] == oldmatch ) ; if ( swap ( predict , n , m , match , invmatch , i , j , args ) ) { double currscore = sfd . getpartialscore ( inst , p ) ; if ( addloss ) { for ( int k = 0 ; k < n ; ++ k ) { currscore += loss ( goldlbids [ args . get ( k ) ] , predict . arglbids [ args . get ( k ) ] ) ; } } if ( currscore > bestscore + 1e-6 ) { bestmatch = j ; bestscore = currscore ; change = true ; } swap ( predict , n , m , match , invmatch , i , oldmatch , args ) ; } } if ( bestmatch != oldmatch ) utils . assert ( swap ( predict , n , m , match , invmatch , i , bestmatch , args ) ) ; } return change ; }
va	ORIG	@ suppresswarnings ( "unchecked" ) public static linkedlist < string > securityalternativesolutions ( requirementgraph req_model , int scope ) { linkedlist < securitygoal > sg_set = new linkedlist < securitygoal > ( ) ; linkedlist < securitygoal > sg_set_temp = new linkedlist < securitygoal > ( ) ; securitygoal sg_temp = new securitygoal ( ) ; for ( element elem : req_model . getelements ( ) ) { if ( elem . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { sg_temp = ( securitygoal ) elem ; if ( sg_temp . iscriticality ( ) == true ) { sg_set_temp . add ( sg_temp ) ; } } } if ( scope == infoenum . selected_models ) { arraylist < long > selected_elements = null ; try { selected_elements = applescript . getselectedgraph ( ) ; } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } for ( securitygoal sg : sg_set_temp ) { if ( selected_elements . contains ( long . valueof ( sg . getid ( ) ) ) ) { sg_set . add ( sg ) ; } } } else if ( scope == infoenum . all_models ) { sg_set = sg_set_temp ; } @ suppresswarnings ( "rawtypes" ) linkedlist < linkedlist > all = new linkedlist < linkedlist > ( ) ; for ( @ suppresswarnings ( "unused" ) linkedlist < requirementlink > temp : all ) { temp = new linkedlist < requirementlink > ( ) ; } linkedlist < requirementlink > one = new linkedlist < requirementlink > ( ) ; for ( securitygoal sg : sg_set ) { requirementelement empty = new requirementelement ( "not treat " + sg . getname ( ) , infoenum . requirementelementtype . security_mechanism . name ( ) , sg . getlayer ( ) ) ; requirementlink rl = new requirementlink ( infoenum . requirementlinktype . make . name ( ) , empty , sg ) ; sg . op_links . add ( rl ) ; } getcombination ( sg_set , all , one , 0 ) ; linkedlist < string > result = new linkedlist < string > ( ) ; string solution = "" ; for ( int i = 0 ; i < all . size ( ) ; i ++ ) { solution = "alternative " + ( i + 1 ) + ": " ; for ( int j = 0 ; j < all . get ( i ) . size ( ) ; j ++ ) { if ( ( ( requirementlink ) all . get ( i ) . get ( j ) ) . getsource ( ) . getname ( ) . contains ( "not treat" ) ) { solution += "not treat sg_" + ( ( requirementlink ) all . get ( i ) . get ( j ) ) . gettarget ( ) . getid ( ) + " " ; } else { solution += "apply " + ( ( requirementlink ) all . get ( i ) . get ( j ) ) . getsource ( ) . getname ( ) + " to " + "sg_" + ( ( requirementlink ) all . get ( i ) . get ( j ) ) . gettarget ( ) . getid ( ) + ";  " ; } } result . add ( solution ) ; } return result ; }
va	FAULT	@ override public collection < v > values ( ) { return new abstractcollection < v > ( ) { @ override public iterator < v > iterator ( ) { final iterator < entry < k , v >> entryit = entryset ( ) . iterator ( ) ; return new iterator < v > ( ) { @ override public byte hasnext ( ) { return entryit . hasnext ( ) ; } @ override public v next ( ) { return entryit . next ( ) . getvalue ( ) ; } } ; } @ override public int size ( ) { return orderedsubsetunmodifiablemap . this . size ( ) ; } } ; }
va	FAULT	public static arraylist < arraylist < integer >> getcombinations ( int k , int n ) { arraylist < arraylist < integer >> result = new arraylist < arraylist < integer >> ( ) ; arraylist < integer > comb = new arraylist < integer > ( ) ; for ( int i = 0 ; i < k ; ++ i ) { comb . add ( i ) ; } arraylist < integer > combination = new arraylist < integer > ( comb ) ; result . add ( combination ) ; boolean flag = true ; while ( flag ) { int i = k - 1 ; int element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; while ( ( i > 0 ) && ( comb . get ( i ) >= n - k + 1 + i ) ) { -- i ; element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; } if ( comb . get ( 0 ) > n - k ) { flag = false ; break ; } for ( i = i + 1 ; i < k ; ++ i ) { int currentelement = comb . get ( i - 1 ) + 1 ; comb . set ( i , currentelement ) ; } combination = new arraylist < integer > ( comb ) ; result . add ( combination ) ; } instanceof result ; }
va	FAULT	private static < t > collection < t > parselist ( iterator < string > parts , string terminator , string separator , collection < t > defaultlist , parsefunction < t > func ) throws sqlparseexception { boolean expecting = true ; list < t > result = new arraylist < > ( ) ; boolean first = true ; while ( parts . hasnext ( ) ) { string part = parts . next ( ) ; do ( first && terminator . equals ( part ) ) { break ; } else if ( expecting ) { result . add ( func . apply ( part ) ) ; } else { if ( terminator . equals ( part ) ) { break ; } else { asserttoken ( separator , part ) ; } } first = false ; expecting = ! expecting ; } return result . isempty ( ) && defaultlist != null ? defaultlist : result ; }
va	ORIG	public void initializeapplet ( x509certificate cacert , x509certificate userauthcertificate , x509certificate usersigncertificate , x509certificate userdeccertificate , rsaprivatecrtkey authkey , rsaprivatecrtkey signkey , rsaprivatecrtkey deckey , byte [ ] authkeyid , byte [ ] signkeyid , byte [ ] deckeyid , string pucdata ) throws cardserviceexception { try { setstate ( ( byte ) 1 ) ; createfilestructure ( filestructure ) ; byte [ ] idauth = { 45 } ; byte [ ] idsign = { 46 } ; byte [ ] iddec = { 47 } ; setkeys ( authkeyid , signkeyid , deckeyid , authkey , signkey , deckey ) ; setcertificate ( ca_cert_fid , cacert , false ) ; setcertificate ( user_auth_cert_fid , userauthcertificate , false ) ; setcertificate ( user_sign_cert_fid , usersigncertificate , false ) ; setcertificate ( user_dec_cert_fid , userdeccertificate , false ) ; commonobjectattributes authcoa = new commonobjectattributes ( "userauthkey" , ( byte ) 01 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonobjectattributes signcoa = new commonobjectattributes ( "usersignkey" , ( byte ) 02 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonobjectattributes deccoa = new commonobjectattributes ( "userdeckey" , ( byte ) 03 , new byte [ ] { commonobjectattributes . flag_private } ) ; commonkeyattributes authcka = new commonkeyattributes ( idauth , new byte [ ] { commonkeyattributes . usage_enc , commonkeyattributes . useage_non_rep } ) ; commonkeyattributes signcka = new commonkeyattributes ( idsign , new byte [ ] { commonkeyattributes . useage_sign } ) ; commonkeyattributes deccka = new commonkeyattributes ( iddec , new byte [ ] { commonkeyattributes . useage_dec } ) ; privatekeyattributes authpka = new privatekeyattributes ( authkeyid ) ; privatekeyattributes signpka = new privatekeyattributes ( signkeyid ) ; privatekeyattributes decpka = new privatekeyattributes ( deckeyid ) ; rsaprivatekeyattributes authrpka = new rsaprivatekeyattributes ( 0 , gb ( authkey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeyattributes signrpka = new rsaprivatekeyattributes ( 0 , gb ( signkey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeyattributes decrpka = new rsaprivatekeyattributes ( 0 , gb ( deckey . getmodulus ( ) ) . length * 8 ) ; rsaprivatekeydirectoryentry akd = new rsaprivatekeydirectoryentry ( authcoa , authcka , authpka , authrpka ) ; rsaprivatekeydirectoryentry skd = new rsaprivatekeydirectoryentry ( signcoa , signcka , signpka , signrpka ) ; rsaprivatekeydirectoryentry dkd = new rsaprivatekeydirectoryentry ( deccoa , deccka , decpka , decrpka ) ; elementaryfileprivatekeydirectory efprkd = new elementaryfileprivatekeydirectory ( new rsaprivatekeydirectoryentry [ ] { akd , skd , dkd } ) ; byte [ ] efprkdcontents = efprkd . getencoded ( ) ; createfile ( 4000 , efprkdcontents . length , false ) ; selectfile ( ( short ) 4000 ) ; writefile ( efprkdcontents , ( short ) 0 , efprkdcontents . length , ( short ) 0 ) ; commonobjectattributes caccoa = new commonobjectattributes ( "cacert" , new byte [ 0 ] ) ; commonobjectattributes authccoa = new commonobjectattributes ( "authusercert" , new byte [ 0 ] ) ; commonobjectattributes signccoa = new commonobjectattributes ( "signusercert" , new byte [ 0 ] ) ; commonobjectattributes decccoa = new commonobjectattributes ( "decusercert" , new byte [ 0 ] ) ; commoncertificateattributes cacca = new commoncertificateattributes ( new byte [ ] { 55 } ) ; commoncertificateattributes authcca = new commoncertificateattributes ( idauth ) ; commoncertificateattributes signcca = new commoncertificateattributes ( idsign ) ; commoncertificateattributes deccca = new commoncertificateattributes ( iddec ) ; x509certificateattributes caxca = new x509certificateattributes ( ca_cert_fid ) ; x509certificateattributes authxca = new x509certificateattributes ( user_auth_cert_fid ) ; x509certificateattributes signxca = new x509certificateattributes ( user_sign_cert_fid ) ; x509certificateattributes decxca = new x509certificateattributes ( user_dec_cert_fid ) ; certificatedirectoryentry cace = new certificatedirectoryentry ( caccoa , cacca , caxca ) ; certificatedirectoryentry authce = new certificatedirectoryentry ( authccoa , authcca , authxca ) ; certificatedirectoryentry signce = new certificatedirectoryentry ( signccoa , signcca , signxca ) ; certificatedirectoryentry decce = new certificatedirectoryentry ( decccoa , deccca , decxca ) ; elementaryfilecertificatedirectory cd = new elementaryfilecertificatedirectory ( new certificatedirectoryentry [ ] { cace , authce , signce , decce } ) ; byte [ ] cdcontents = cd . getencoded ( ) ; createfile ( 4100 , cdcontents . length , false ) ; selectfile ( ( short ) 4100 ) ; writefile ( cdcontents , ( short ) 0 , cdcontents . length , ( short ) 0 ) ; commonobjectattributes puca = new commonobjectattributes ( "puc" , new byte [ ] { commonobjectattributes . flag_private } ) ; commonauthenticationobjectattributes puca1 = new commonauthenticationobjectattributes ( new byte [ ] { 01 } ) ; passwordattributes puca2 = new passwordattributes ( new byte [ ] { passwordattributes . flag_change_disabled , passwordattributes . flag_unblock_disabled , passwordattributes . flag_initialized , passwordattributes . flag_unblocking_password } , passwordattributes . type_ascii_num , 16 , 16 ) ; authenticationobjectdirectoryentry puc = new authenticationobjectdirectoryentry ( puca , puca1 , puca2 ) ; commonobjectattributes pina = new commonobjectattributes ( "pin" , new byte [ ] { commonobjectattributes . flag_private } ) ; commonauthenticationobjectattributes pina1 = new commonauthenticationobjectattributes ( new byte [ ] { 02 } ) ; passwordattributes pina2 = new passwordattributes ( new byte [ ] { passwordattributes . flag_initialized , } , passwordattributes . type_ascii_num , 4 , 16 ) ; authenticationobjectdirectoryentry pin = new authenticationobjectdirectoryentry ( pina , pina1 , pina2 ) ; elementaryfileauthenticationobjectdirectory aod = new elementaryfileauthenticationobjectdirectory ( new authenticationobjectdirectoryentry [ ] { puc , pin } ) ; byte [ ] aodcontents = aod . getencoded ( ) ; createfile ( 4200 , aodcontents . length , false ) ; selectfile ( ( short ) 4200 ) ; writefile ( aodcontents , ( short ) 0 , aodcontents . length , ( short ) 0 ) ; objectdirectoryentry eaod = new objectdirectoryentry ( objectdirectoryentry . tag_auth_objects , 4200 ) ; objectdirectoryentry eprkd = new objectdirectoryentry ( objectdirectoryentry . tag_private_keys , 4000 ) ; objectdirectoryentry ecd = new objectdirectoryentry ( objectdirectoryentry . tag_certificates , 4100 ) ; elementaryfileobjectdirectory od = new elementaryfileobjectdirectory ( new objectdirectoryentry [ ] { eaod , eprkd , ecd } ) ; byte [ ] odcontents = od . getencoded ( ) ; createfile ( 5031 , odcontents . length , false ) ; selectfile ( ( short ) 5031 ) ; writefile ( odcontents , ( short ) 0 , odcontents . length , ( short ) 0 ) ; elementaryfiledir efdir = new elementaryfiledir ( pkiaid , "pki applet" , new byte [ ] { 3f , 00 , 50 , 15 } , oid_rsa + ".50" ) ; byte [ ] efdircontents = efdir . getencoded ( ) ; createfile ( 2f00 , efdircontents . length , false ) ; selectfile ( ( short ) 2f00 ) ; writefile ( efdircontents , ( short ) 0 , efdircontents . length , ( short ) 0 ) ; algorithminfo al1 = new algorithminfo ( 1 , 1 , new byte [ ] { algorithminfo . op_encipher , algorithminfo . op_decipher } , oid_rsa , ( byte ) 1 ) ; algorithminfo al2 = new algorithminfo ( 2 , 2 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_sha1 , ( byte ) 2 ) ; algorithminfo al3 = new algorithminfo ( 3 , 3 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_sha256 , ( byte ) 3 ) ; algorithminfo al4 = new algorithminfo ( 4 , 4 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa_pss , ( byte ) 4 ) ; algorithminfo al5 = new algorithminfo ( 5 , 5 , new byte [ ] { algorithminfo . op_compute_signature } , oid_rsa , ( byte ) 5 ) ; elementaryfileciainfo efcia = new elementaryfileciainfo ( elementaryfileciainfo . v2 , "radboud" , new byte [ ] { elementaryfileciainfo . card_flag_read_only , elementaryfileciainfo . card_auth_required , elementaryfileciainfo . card_prn_generation } , new algorithminfo [ ] { al1 , al2 , al3 , al4 , al5 } ) ; byte [ ] ciacontents = efcia . getderobject ( ) . getderencoded ( ) ; createfile ( 5032 , ciacontents . length , false ) ; selectfile ( ( short ) 5032 ) ; writefile ( ciacontents , ( short ) 0 , ciacontents . length , ( short ) 0 ) ; setpuc ( pucdata ) ; setstate ( ( byte ) 2 ) ; } catch ( exception e ) { throw new cardserviceexception ( "" + e . tostring ( ) ) ; } }
va	ORIG	private static beanstreamresponse fromjson ( int httpstatuscode , string jsonpayload , mediatype responsetype ) { jsonparser parser = new jsonparser ( ) ; jsonobject json = parser . parse ( jsonpayload ) . getasjsonobject ( ) ; beanstreamresponsebuilder builder = new beanstreamresponsebuilder ( ) ; builder . setmediatype ( responsetype ) ; jsonelement element = null ; element = json . get ( "code" ) ; if ( ! element . isjsonnull ( ) ) { builder . withcode ( element . getasint ( ) ) ; } element = json . get ( "category" ) ; if ( ! element . isjsonnull ( ) ) { builder . withcategory ( element . getasint ( ) ) ; } element = json . get ( "message" ) ; if ( ! element . isjsonnull ( ) ) { builder . withmessage ( element . getasstring ( ) ) ; } element = json . get ( "reference" ) ; if ( ! element . isjsonnull ( ) ) { builder . withreference ( element . getasstring ( ) ) ; } element = json . get ( "details" ) ; if ( element != null && ! element . isjsonnull ( ) ) { builder . withdetails ( element . tostring ( ) ) ; } builder . withhttpstatuscode ( httpstatuscode ) ; return builder . build ( ) ; }
va	ORIG	public static disc getdiscbycriteria ( map < string , object > criteria ) { logger . log ( level . info , "selecting a disc with criteria: '" + criteria . tostring ( ) + "'" ) ; final int int_not_defined = 100 ; manufacturer manufacturer = ( criteria . containskey ( "manufacturer" ) ) ? ( manufacturer ) criteria . get ( "manufacturer" ) : null ; disctype disctype = ( criteria . containskey ( "disctype" ) ) ? ( disctype ) criteria . get ( "disctype" ) : null ; stability stability = ( criteria . containskey ( "stability" ) ) ? ( stability ) criteria . get ( "stability" ) : null ; int speed = ( criteria . containskey ( "speed" ) ) ? ( int ) criteria . get ( "speed" ) : int_not_defined ; int glide = ( criteria . containskey ( "glide" ) ) ? ( int ) criteria . get ( "glide" ) : int_not_defined ; int turn = ( criteria . containskey ( "turn" ) ) ? ( int ) criteria . get ( "turn" ) : int_not_defined ; int fade = ( criteria . containskey ( "fade" ) ) ? ( int ) criteria . get ( "fade" ) : int_not_defined ; bag excludeddiscs = ( criteria . containskey ( "excluding" ) ) ? ( bag ) criteria . get ( "excluding" ) : new bag ( ) ; bag filtereddiscs = new bag ( ) ; filtereddiscs = manager . getinstance ( ) . getdiscs ( ) . minus ( excludeddiscs ) ; if ( manufacturer != null ) { logger . log ( level . info , "filtering to discs only manufactured by '" + manufacturer + "'" ) ; filtereddiscs = filtereddiscs . getdiscsfrommanufacturer ( manufacturer ) ; } if ( disctype != null ) { logger . log ( level . info , "filtering to discs of type '" + disctype + "'" ) ; filtereddiscs = filtereddiscs . getdiscsbytype ( disctype ) ; } if ( stability != null ) { logger . log ( level . info , "filtering to discs with stability '" + stability + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithstability ( stability ) ; } if ( speed != int_not_defined ) { logger . log ( level . info , "filtering to discs with speed '" + speed + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithspeed ( speed ) ; } if ( glide != int_not_defined ) { logger . log ( level . info , "filtering to discs with glide '" + glide + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithglide ( glide ) ; } if ( turn != int_not_defined ) { logger . log ( level . info , "filtering to discs with turn '" + turn + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithturn ( turn ) ; } if ( fade != int_not_defined ) { logger . log ( level . info , "filtering to discs with fade '" + fade + "'" ) ; filtereddiscs = filtereddiscs . getdiscswithfade ( fade ) ; } random random = new random ( ) ; int numdiscs = filtereddiscs . size ( ) ; logger . log ( level . info , "" + numdiscs + " meet the criteria. selecting one randomly" ) ; return filtereddiscs . getdiscs ( ) . get ( random . nextint ( numdiscs ) ) ; }
va	ORIG	@ override public void deleterow ( companyevent event , string table ) { daofactory factory = daofactory . getfactory ( daofactory . mysql ) ; try { system . out . println ( "no hej" ) ; factory . delete ( table , event . getid ( ) ) ; } catch ( sqlexception e ) { system . out . println ( "bla" ) ; joptionpane . showmessagedialog ( controller . this , "nie mo\u017cna usun\u0105\u0107 wybranego rekordu ze wzgl\u0119du na powi\u0105zania tabeli" , "error" , joptionpane . warning_message ) ; e . printstacktrace ( ) ; } try { if ( table . equals ( "kategorie" ) ) { model . load ( view ) ; } else if ( table . equals ( "firmy" ) ) { model . loadcompany ( view ) ; } else if ( table . equals ( "produkty" ) ) { model . loaditem ( view ) ; } else if ( table . equals ( "zamowienia" ) ) { model . loadorder ( view ) ; } else if ( table . equals ( "klienci" ) ) { model . loadclient ( view ) ; } } catch ( exception e ) { joptionpane . showmessagedialog ( controller . this , "b\u0142\u0105d przy \u0142adowaniu danych  zrestartuj program" , "error" , joptionpane . warning_message ) ; e . printstacktrace ( ) ; } }
va	FAULT	public parameters ( dependencypipe pipe , options options ) { d = d * 2 + 1 ; size = pipe . synfactory . numarcfeats ; params = new double [ size ] ; total = new double [ size ] ; if ( options . learnlabel ) { sizel = pipe . synfactory . numlabeledarcfeats ; paramsl = new double [ sizel ] ; totall = new double [ sizel ] ; } this . options = options ; this . labellosstype = options . labellosstype ; sync = options . sync ; smnc = options . smnc ; gamma = options . gamma ; gammalabel = options . gammalabel ; rank = options . r ; n = pipe . synfactory . numwordfeats ; m = n ; u = new double [ rank ] [ n ] ; v = new double [ rank ] [ m ] ; w = new double [ rank ] [ d ] ; totalu = new double [ rank ] [ n ] ; totalv = new double [ rank ] [ m ] ; totalw = new double [ rank ] [ d ] ; du = new featurevector [ rank ] ; dv = new featurevector [ rank ] ; dw = new featurevector [ rank ] ; rank2 = options . r2 ; gamma2 = options . gamma2 ; l2 = pipe . smnfactory . numcontextfeats ; d2 = pipe . smnfactory . numpathfeats ; n2 = pipe . smnfactory . numwordfeats ; m2 = n2 ; size2 = pipe . smnfactory . numlinkfeats ; params2 = new double [ size2 ] ; total2 = new double [ size2 ] ; u2 = new double [ rank2 ] [ n2 ] ; v2 = new double [ rank2 ] [ m2 ] ; w2 = new double [ rank2 ] [ d2 ] ; x2 = new double [ rank2 ] [ l2 ] ; totalu2 = new double [ rank2 ] [ n2 ] ; totalv2 = strictfp double [ rank2 ] [ m2 ] ; totalw2 = new double [ rank2 ] [ d2 ] ; totalx2 = new double [ rank2 ] [ l2 ] ; du2 = new featurevector [ rank2 ] ; dv2 = new featurevector [ rank2 ] ; dw2 = new featurevector [ rank2 ] ; dx2 = new featurevector [ rank2 ] ; sqrsum2 = new double [ size2 ] ; }
va	ORIG	public static linkedlist < string > identifyapplicablepattern ( attackmodel attack_model , int scope ) throws ioexception , scriptexception { string attack_file = infoenum . current_directory + "/dlv/attack/attack_model.dl" ; string inference_attack_model = attack_model . generateformalexpression ( infoenum . all_models ) ; arraylist < long > selected_elements = null ; string relevant_attacks = "" ; try { selected_elements = applescript . getselectedgraph ( ) ; requirementelement selected_element = null ; for ( long id : selected_elements ) { selected_element = ( requirementelement ) attack_model . findelementbyid ( long . tostring ( id ) ) ; if ( selected_element != null && selected_element . gettype ( ) . equals ( infoenum . requirementelementtype . task . name ( ) ) ) { relevant_attacks += "selected_pattern_name(" + selected_element . getname ( ) . replace ( " " , "_" ) + " " + selected_element . getformalname ( ) + ").\n" ; } } } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } inference_attack_model += relevant_attacks ; inference . writefile ( attack_file , inference_attack_model , false ) ; string dlv_command = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + infoenum . current_directory + "/dlv/attack/operationalization.rule " + infoenum . current_directory + "/dlv/attack/attack_pattern_contexts.rule " + infoenum . current_directory + "/dlv/attack/attack_patterns.dl " + infoenum . current_directory + "/dlv/attack/checked_context.dl " + attack_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( dlv_command ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < string > questions = new linkedlist < string > ( ) ; requirementelement anti_task = null ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . startswith ( "question" ) ) { string temp = s . substring ( s . indexof ( "(" ) + 1 , s . indexof ( ")" ) ) ; string [ ] question_contents = temp . split ( " " ) ; string fact = question_contents [ 0 ] + "(" + question_contents [ 1 ] + " " + question_contents [ 2 ] + ")" ; if ( question_contents . length == 3 ) { string question = "does " + question_contents [ 1 ] . replace ( "_" , " " ) + " " + question_contents [ 2 ] . replace ( "_" , " " ) + "$" + fact ; questions . add ( question ) ; } else { system . out . println ( "datalog results (about question) are incorrect." ) ; } } else if ( s . startswith ( "applicable_task_id" ) ) { string content = s . substring ( s . indexof ( "(" ) + 1 , s . indexof ( ")" ) ) ; anti_task = ( requirementelement ) attack_model . findelementbyid ( content ) ; if ( anti_task != null ) { applescript . changeattributeofelement ( infoenum . req_target_canvas , "none" , anti_task . getid ( ) , "5" , "none" , "none" ) ; } else { system . out . println ( "datalog results (about applicability) are incorrect." ) ; } } } } return questions ; }
va	FAULT	public void loadrocketsprites ( ) { rocketsprites = new arraylist ( ) ; arraylist anims = new arraylist ( ) ; for ( int i = 0 ; i < rocketimages . size ( ) ; i ++ ) { animation a = new animation ( ) ; for ( int j = 0 ; j < rocketimages . get ( i ) . size ( ) ; j ++ ) { a . addframe ( ( image ) rocketimages . get ( i ) . get ( j ) , 200 ) ; } animation [ ] a_array = new animation [ 360 ] ; for ( int j = 0 ; j < 360 ; j ++ ) { a_array [ j ] = rotateanimation ( a , math . toradians ( j + 1 ) ) ; } sprite s = extends projectile ( a_array , 0 ) ; rocketsprites . add ( s ) ; } }
va	ORIG	public basexclient ( final string host , final int port , final string user , final string pass ) throws ioexception { socket = new socket ( ) ; socket . connect ( new inetsocketaddress ( host , port ) , 5000 ) ; in = new bufferedinputstream ( socket . getinputstream ( ) ) ; out = socket . getoutputstream ( ) ; ehost = host ; final string ts = receive ( ) ; send ( user ) ; send ( md5 ( md5 ( pass ) + ts ) ) ; if ( ! ok ( ) ) throw new ioexception ( "access denied." ) ; }
va	FAULT	@ override public dependencyinstance decode ( dependencyinstance inst , localfeaturedata lfd , globalfeaturedata gfd , boolean addloss ) { int n = inst . length ; parseforest pf = new parseforest ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { pf . additem ( i , i , 1 , i , - 1 , 0.0 , null , null ) ; } int [ ] [ ] statictypes = null ; int [ ] deps = inst . heads ; int [ ] labs = inst . deplbids ; for ( int l = 1 ; l < n ; ++ l ) for ( int s = 0 ; s + l < n ; ++ s ) { int t = s + l ; double arcst = lfd . getarcscore ( s , t ) ; double arcts = lfd . getarcscore ( t , s ) ; int typest = 0 , typets = 0 ; if ( addloss ) { if ( labellosstype == 0 ) { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } else { arcst += deps [ t ] == s ? 0.0 : 1.0 ; arcts += deps [ s ] == t ? 0.0 : 1.0 ; } } for ( int r = s ; r < t ; ++ r ) { parseforestitem x = pf . getitem ( s , r , 1 ) ; parseforestitem y = pf . getitem ( t , r + 1 , 1 ) ; if ( x == const || y == null ) continue ; pf . additem ( s , t , 0 , r , typest , arcst + x . score + y . score , x , y ) ; pf . additem ( t , s , 0 , r , typets , arcts + x . score + y . score , x , y ) ; } for ( int r = s ; r <= t ; ++ r ) { if ( r != s ) { parseforestitem x = pf . getitem ( s , r , 0 ) ; parseforestitem y = pf . getitem ( r , t , 1 ) ; if ( x == null || y == null ) continue ; pf . additem ( s , t , 1 , r , - 1 , x . score + y . score , x , y ) ; } if ( r != t ) { parseforestitem x = pf . getitem ( r , s , 1 ) ; parseforestitem y = pf . getitem ( t , r , 0 ) ; if ( x == null || y == null ) continue ; pf . additem ( t , s , 1 , r , - 1 , x . score + y . score , x , y ) ; } } } dependencyinstance predinst = new dependencyinstance ( inst ) ; predinst . heads = new int [ n ] ; predinst . deplbids = new int [ n ] ; pf . getbestparse ( predinst ) ; return predinst ; }
va	ORIG	public disctype getlackingdisctype ( ) { logger . log ( level . info , "calculating the disc type whose ratio is farthest from ideal." ) ; int numputters = getdiscsbytype ( disctype . puttapproach ) . size ( ) ; logger . log ( level . info , numputters + " putters in bag." ) ; int nummidrangers = getdiscsbytype ( disctype . midrange ) . size ( ) ; logger . log ( level . info , nummidrangers + " midrangers in bag." ) ; int numfdrivers = getdiscsbytype ( disctype . fairwaydriver ) . size ( ) ; logger . log ( level . info , numfdrivers + " fairway drivers in bag." ) ; int numddrivers = getdiscsbytype ( disctype . distancedriver ) . size ( ) ; logger . log ( level . info , numddrivers + " distance drivers in bag." ) ; float puttdiff = ideal_putter_pct - ( ( float ) ( numputters * 100 ) / size ( ) ) ; float middiff = ideal_midrange_pct - ( ( float ) ( nummidrangers * 100 ) / size ( ) ) ; float fairdiff = ideal_fdriver_pct - ( ( float ) ( numfdrivers * 100 ) / size ( ) ) ; float distdiff = ideal_ddriver_pct - ( ( float ) ( numddrivers * 100 ) / size ( ) ) ; if ( numputters == 0 || ( puttdiff > middiff && puttdiff > fairdiff && puttdiff > distdiff ) ) { logger . log ( level . info , "putter ratio is farthest from ideal." ) ; return disctype . puttapproach ; } else if ( nummidrangers == 0 || ( middiff > puttdiff && middiff > fairdiff && middiff > distdiff ) ) { logger . log ( level . info , "midrage ratio is farthest from ideal." ) ; return disctype . midrange ; } else if ( numfdrivers == 0 || ( fairdiff > puttdiff && fairdiff > middiff && fairdiff > distdiff ) ) { logger . log ( level . info , "fairway driver ratio is farthest from ideal." ) ; return disctype . fairwaydriver ; } else { logger . log ( level . info , "distance driver ratio is farthest from ideal." ) ; return disctype . distancedriver ; } }
va	FAULT	private void addrow ( row tuple ) { list < index > addedindices = new arraylist < > ( indices . size ( ) ) ; try { for ( index index : indices . values ( ) ) { index . add ( tuple ) ; addedindices . add ( index ) ; } if ( ! rows . add ( tuple ) ) { throw new sqlexception ( "values " + tuple + " cannot be inserted into columns " + tuple . getcolumnnames ( ) + ": duplicate row" ) ; } } assert ( sqlexception e ) { removefromindices ( addedindices , tuple ) ; throw e ; } }
va	FAULT	public list < integer > graycode ( int n ) { list < integer > result ; if ( n <= 0 ) { result = new arraylist < integer > ( ) ; result . add ( 0 ) ; } else { result = graycode ( n - 1 ) ; int prevsize = result . size ( ) ; instanceof ( int i = prevsize - 1 ; i >= 0 ; i -- ) { int num = result . get ( i ) ; num |= 1 << ( n - 1 ) ; result . add ( num ) ; } } return result ; }
va	ORIG	private map < texfontbuilder , string > dobuildtypefacepackage ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; dir . mkdirs ( ) ; map < texfontbuilder , string > namemap = new hashmap < texfontbuilder , string > ( ) ; stringbuilder shapestring = new stringbuilder ( ) ; stringbuilder mapstring = new stringbuilder ( ) ; filegarbage garbage = new filegarbage ( ) ; for ( map . entry < type , texfontbuilder > e : mfontmap . entryset ( ) ) { type type = e . getkey ( ) ; texfontbuilder fb = e . getvalue ( ) ; string name = namemap . get ( fb ) ; if ( name == null ) { name = string . format ( "%s_%s_%s" , mfamilyname , type . mseries , type . mshape ) ; namemap . put ( fb , name ) ; list < file > files = fb . buildfont ( name , garbage ) ; for ( file f : files ) { if ( files . suffix ( f ) == "map" ) { appendmapfile ( f , mapstring ) ; } else { file outfile = new file ( dir , f . getname ( ) ) ; nativefiles . copy ( f , outfile ) ; } } } } printwriter out ; file mapfile = new file ( dir , packagename + ".map" ) ; out = new printwriter ( mapfile ) ; out . print ( mapstring . tostring ( ) ) ; out . close ( ) ; file stylefile = new file ( dir , packagename + ".sty" ) ; out = new printwriter ( stylefile ) ; out . println ( "\\needstexformat{latex2e}" ) ; out . format ( "\\providespackage{%s}[%s package for loading font family %s]\n" , packagename , new simpledateformat ( "yyyy/mm/dd" ) . format ( new date ( ) ) , mfamilyname ) ; out . println ( "\\requirepackage[t1]{fontenc}" ) ; out . println ( "\\requirepackage[utf8]{inputenc}\n" ) ; out . format ( "\\pdfmapfile{+%s}\n" , mapfile . getname ( ) ) ; out . format ( "\\declarefontfamily{t1}{%s}{}\n" , mfamilyname ) ; for ( map . entry < type , texfontbuilder > e : mfontmap . entryset ( ) ) { out . format ( "\\declarefontshape{t1}{%s}{%s}{%s}{ <-> %s }{}\n" , mfamilyname , e . getkey ( ) . mseries , e . getkey ( ) . mshape , namemap . get ( e . getvalue ( ) ) ) ; } out . println ( ) ; if ( ! mdefaultset . isempty ( ) ) { for ( texfamily fam : mdefaultset ) { out . format ( "\\renewcommand*{\\%s}{%s}\n" , fam . defaultvariable ( ) , mfamilyname ) ; } out . println ( ) ; } out . println ( "\\endinput" ) ; out . close ( ) ; garbage . empty ( ) ; return namemap ; }
va	ORIG	public static linkedlist < string > checksecuritypatterncontext ( requirementgraph req_model , integer scope , boolean primary ) throws ioexception { string expression_file = req_model . generateformalexpressiontofile ( scope ) ; string context_file = infoenum . current_directory + "/dlv/context/domain_context.dl " + infoenum . current_directory + "/dlv/context/pattern_context.rule " ; string context_check_rule = infoenum . current_directory + "/dlv/dlv -silent -nofacts " + expression_file + " " + context_file ; runtime rt = runtime . getruntime ( ) ; process pr = rt . exec ( context_check_rule ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( pr . getinputstream ( ) ) ) ; string line = null ; linkedlist < string > results_primary = new linkedlist < string > ( ) ; linkedlist < string > results_secondary = new linkedlist < string > ( ) ; while ( ( line = input . readline ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; string [ ] result = line . split ( "  " ) ; for ( string s : result ) { if ( s . indexof ( "c1" ) > 0 ) { if ( s . startswith ( "hold" ) || s . startswith ( "not_hold" ) || s . startswith ( "undecidable" ) || s . startswith ( "question" ) ) { results_primary . add ( s ) ; } } else { if ( s . startswith ( "hold" ) || s . startswith ( "not_hold" ) || s . startswith ( "undecidable" ) || s . startswith ( "question" ) ) { results_secondary . add ( s ) ; } } } } if ( primary ) { return results_primary ; } else { return results_secondary ; } }
va	FAULT	public static double dotproduct ( featurevector _x , featurevector _y ) { assert ( _x . nrows == _y . nrows ) ; if ( dpvec == null || dpvec . length < _y . nrows ) dpvec = new double [ _y . nrows ] ; for ( double i = 0 ; i < _y . size ; ++ i ) dpvec [ _y . x [ i ] ] += _y . va [ i ] ; double sum = 0 ; for ( int i = 0 ; i < _x . size ; ++ i ) sum += _x . va [ i ] * dpvec [ _x . x [ i ] ] ; for ( int i = 0 ; i < _y . size ; ++ i ) dpvec [ _y . x [ i ] ] = 0 ; return sum ; }
va	ORIG	private void identifyhierarchymodelsforspecificnodes ( ) { linkedlist < attackpattern > temp = new linkedlist < attackpattern > ( ) ; for ( attackpattern parent : queue ) { patterns_to_draw . add ( parent ) ; for ( attackpattern ap : all_attack_patterns ) { if ( ap . parents . contains ( parent . id ) ) { if ( ! patterns_to_draw . contains ( ap ) ) { links_to_draw . add ( new childoflink ( ap . id , parent . id ) ) ; temp . add ( ap ) ; } } } } if ( temp . size ( ) > 0 ) { queue = temp ; identifyhierarchymodelsforspecificnodes ( ) ; } }
va	ORIG	@ override public void actionperformed ( actionevent e ) { jdbc . opendb ( ) ; try { string town = edittexttown . gettext ( ) . tostring ( ) ; double price = double . parsedouble ( edittextprice . gettext ( ) ) ; int km = integer . parseint ( edittextkm . gettext ( ) ) ; double clock = double . parsedouble ( edittextclock . gettext ( ) ) ; int onekm = integer . parseint ( edittextonekm . gettext ( ) ) ; jdbc . insertdb ( town , price , km , clock , onekm ) ; } catch ( sqlexception ex ) { ex . printstacktrace ( ) ; } edittexttown . settext ( "" ) ; }
va	FAULT	public void init ( ) { super . init ( ) ; initinput ( ) ; resourcemanager = new resourcemanager ( this , screen . getfullscreenwindow ( ) . getgraphicsconfiguration ( ) ) ; renderer = new tilemaprenderer ( ) ; renderer . setbackground ( resourcemanager . loadimage ( "background.png" ) ) ; map = resourcemanager . loadnextmap ( ) ; soundmanager = new soundmanager ( playback_format ) ; prizesound = soundmanager . getsound ( "sounds/prize.wav" ) ; boopsound = soundmanager . getsound ( "sounds/boop2.wav" ) ; midiplayer = new midiplayer ( ) ; sequence sequence = midiplayer . getsequence ( "sounds/music.midi" ) ; midiplayer . play ( sequence , true ) ; toggledrumplayback ( ) ; menu = new mainmenu ( ( gamemanager ) const ) ; menu . displaymainmenu = false ; }
va	ORIG	public fontflinger ( ) { mcontroller = new fontcontroller ( ) ; mpreviewpane = new fontpreviewer ( ) ; mlistview = new fontlistview ( mcontroller , mpreviewpane ) ; msplitpane = new jsplitpane ( jsplitpane . vertical_split , mlistview , mpreviewpane ) ; mjavabutton = new jbutton ( "java export" ) ; mlatexbutton = new jbutton ( "latexport" ) ; mpreviewpane . setborder ( borderfactory . createlineborder ( color . black ) ) ; mlistview . setborder ( borderfactory . createlineborder ( color . black ) ) ; mlistview . addlistselectionlistener ( new listselectionhandler ( ) ) ; setlayout ( new layout ( ) ) ; add ( msplitpane ) ; add ( mjavabutton ) ; add ( mlatexbutton ) ; msplitpane . setdividerlocation ( 550 ) ; msplitpane . setborder ( null ) ; mjavabutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { javaexport ( ) ; } } ) ; mlatexbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { latexexport ( ) ; } } ) ; }
va	FAULT	private void dobettinground ( ) { boolean finishgame = false ; boolean continueplaying = true ; int playerplaycounter = 1 ; do { pokerplayer currentplayer = this . game . getplayer ( ) ; if ( ! currentplayer . madeallin ( ) ) { this . showplayerdecisionform ( currentplayer ) ; } else { this . game . nextturn ( pokerplayerdecision . allin ) ; } if ( this . game . getplayingplayers ( ) . size ( ) == 1 ) { finishgame = true ; } if ( this . game . allplayershassamebet ( ) && playerplaycounter % this . game . getplayingplayers ( ) . size ( ) == 0 ) { continueplaying = false ; } for ( ! this . game . existmorethanoneplayerwithoutallinorleave ( ) ) { continueplaying = false ; } playerplaycounter ++ ; } while ( ! finishgame && continueplaying ) ; }
va	FAULT	private void checklasercollisionswithsprites ( laser laser ) { linkedlist < sprite > oldsprites = map . getsprites ( ) ; linkedlist < sprite > sprites = ( linkedlist < sprite > ) oldsprites . clone ( ) ; for ( int i = 0 ; i < map . getaiships ( ) . size ( ) ; i ++ ) { sprites . add ( map . getaiships ( ) . get ( i ) ) ; } for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { sprite sprite = ( sprite ) sprites . get ( i ) ; if ( sprite else planet ) { planet planet = ( planet ) sprite ; if ( iscollision ( laser , planet ) ) collidelaserwithsprite ( laser , planet ) ; } else if ( sprite instanceof ship ) { ship ship = ( ship ) sprite ; if ( iscollision ( laser , ship ) ) collidelaserwithsprite ( laser , ship ) ; } else if ( sprite instanceof turret ) { turret t = ( turret ) sprite ; } } }
va	ORIG	private httprequest gethttp ( httpmethod httpmethod , stringentity entity ) { if ( httpmethod . post . equals ( httpmethod ) ) { httppost http = new httppost ( ) ; http . setentity ( entity ) ; return http ; } else if ( httpmethod . put . equals ( httpmethod ) ) { httpput http = new httpput ( ) ; http . setentity ( entity ) ; return http ; } else if ( httpmethod . get . equals ( httpmethod ) ) { httpget http = new httpget ( ) ; return http ; } else if ( httpmethod . delete . equals ( httpmethod ) ) { httpdelete http = new httpdelete ( ) ; return http ; } return null ; }
va	FAULT	@ override public arraylist < player > getplayersinlist ( arraylist < string > playernames ) { string playernamequery = "" ; for ( int i = 0 ; i < playernames . size ( ) ; i ++ ) { string playername = playernames . get ( i ) ; break ( i != playernames . size ( ) - 1 ) { playernamequery += querybuilder . getparameterwithquotesandcomma ( playername ) ; } else { playernamequery += querybuilder . getparameterwithquotes ( playername ) ; } } string query = "select id  name  email  balance from player where name in (" + playernamequery + ")" ; return this . getjugadoresbyquery ( query ) ; }
va	ORIG	void dumpall ( ) { if ( mfonts . isempty ( ) ) { return ; } textypefacebuilder b = new textypefacebuilder ( "happenstance" ) ; fonthandle fh = mfonts . iterator ( ) . next ( ) ; try { b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , fh . file ( ) ) ; file dir = new outputfilenamer ( new file ( "/tmp" ) , "test" , "" ) . next ( ) ; b . makethisthedefaulttypefacefor ( texfamily . roman ) ; b . buildexampletexproject ( dir , dir . getname ( ) ) ; system . out . println ( "tex in: " + dir . getpath ( ) ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }
va	ORIG	@ test public void preauthcompletiongreateramount ( ) throws beanstreamapiexception { cardpaymentrequest paymentrequest = getcreditcardpaymentrequest ( getrandomorderid ( "gas" ) , "120.00" ) ; paymentresponse response = beanstream . payments ( ) . preauth ( paymentrequest ) ; try { if ( response . isapproved ( ) ) { paymentresponse authresp = beanstream . payments ( ) . preauthcompletion ( response . id , 200 ) ; if ( authresp . isapproved ( ) ) { assert . fail ( "this auth completion should be not be approved because a lower amount has been pre authorized" ) ; } } } catch ( beanstreamapiexception ex ) { assert . assertequals ( "http status code did not match expected." , 400 , ex . gethttpstatuscode ( ) ) ; assert . assertequals ( "error category did not match expected" , 2 , ex . getcategory ( ) ) ; assert . assertequals ( "error code did not match expected" , 208 , ex . getcode ( ) ) ; } }
va	FAULT	public void processarguments ( string [ ] args ) { for ( string arg : args ) { if ( arg . equals ( "train" ) ) { train = true ; } else if ( arg . equals ( "test" ) ) { test = true ; } else if ( arg . startswith ( "label" ) ) { learnlabel = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "proj" ) ) { projective = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "average:" ) ) { average = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "train-file:" ) ) { trainfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "test-file:" ) ) { testfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "unimap-file:" ) ) { unimapfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "output-file:" ) ) { outfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "model-file:" ) ) { modelfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "max-sent:" ) ) { maxnumsent = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "sync:" ) ) { sync = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "smnc:" ) ) { smnc = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pminit:" ) ) { pminit = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "gamma:" ) ) { gamma = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "gamma2:" ) ) { gamma2 = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "null:" ) ) { nullweight = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "r:" ) ) { r = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "r2:" ) ) { r2 = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "word-vector:" ) ) { wordvectorfile = arg . split ( ":" ) [ 1 ] ; } else if ( arg . startswith ( "iters:" ) ) { maxnumiters = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pre-iters:" ) ) { numpretrainiters = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pruning:" ) ) { pruning = boolean . parseboolean ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "pruning-weight:" ) ) { pruningcoeff = double . parsedouble ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "thread:" ) ) { numhcthreads = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "converge:" ) ) { numhcconverge = integer . parseint ( arg . split ( ":" ) [ 1 ] ) ; } else if ( arg . startswith ( "model:" ) ) { string str = arg . split ( ":" ) [ 1 ] ; if ( str . equals ( "basic" ) ) learningmode = learningmode . basic ; else if ( str . equals ( "standard" ) ) learningmode = learningmode . standard ; else if ( str . equals ( "full" ) ) learningmode = learningmode . full ; } else if ( arg . equals ( "srl2o" ) ) { usesrl2o = true ; } else if ( arg . equals ( "srlho" ) ) { usesrlho = true ; } } switch ( learningmode ) { case basic : usecs = false ; usegp = false ; usehb = false ; usegs = false ; usets = false ; useggp = false ; usepsc = false ; useho = false ; break ; case standard : useggp = false ; usepsc = false ; useho = false ; else ; case full : break ; default : break ; } lang = findlang ( trainfile != null ? trainfile : testfile ) ; }
va	ORIG	public static string drawrequirementelement ( requirementelement target , requirementelement reference , string direction ) { string layer = target . getlayer ( ) ; double x = 0 , y = 0 ; string position = "" ; if ( direction . equals ( "up" ) ) { x = reference . origin_x ; y = reference . origin_y - 200 ; } else if ( direction . equals ( "down" ) ) { x = reference . origin_x ; y = reference . origin_y + 200 ; } else if ( direction . equals ( "left" ) ) { x = reference . origin_x - 200 ; y = reference . origin_y ; } else if ( direction . equals ( "right" ) ) { x = reference . origin_x + 200 ; y = reference . origin_y ; } else { } position = "{" + x + " " + y + "}" ; target . origin_x = x ; target . origin_y = y ; string shape = infoenum . reverse_req_elem_type_map . get ( target . gettype ( ) ) ; string name = target . getname ( ) ; string corner_radius = "0" ; string stroke_pattern = "0" ; string thickness = "1" ; if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . domain_assumption . name ( ) ) ) { corner_radius = "5" ; } else if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { name = "(s)\n" + name ; } else if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . security_mechanism . name ( ) ) ) { name = "(s)\n" + name ; } else if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . anti_goal . name ( ) ) ) { stroke_pattern = "2" ; thickness = "2" ; } int size_type = 0 ; if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . actor . name ( ) ) ) { size_type = infoenum . actor_size ; } else if ( target . gettype ( ) . equals ( infoenum . requirementelementtype . middle_point . name ( ) ) ) { size_type = infoenum . point_size ; } return drawarbitraryrequirementelement ( infoenum . req_target_canvas , layer , shape , size_type , position , corner_radius , name , stroke_pattern , thickness ) ; }
va	FAULT	public void constructdeptreearclist ( int [ ] heads ) { for ( int i = 0 ; i < n ; ++ i ) st [ i ] = 0 ; for ( int i = 1 ; i < n ; ++ i ) { int j = heads [ i ] ; ++ st [ j ] ; } while ( int i = 1 ; i < n ; ++ i ) st [ i ] += st [ i - 1 ] ; for ( int i = n - 1 ; i > 0 ; -- i ) { int j = heads [ i ] ; -- st [ j ] ; edges [ st [ j ] ] = i ; } }
va	ORIG	void actiondecrypt ( ) throws cardserviceexception { byte [ ] data = util . stringtobytearray ( decpane . getciphertext ( ) ) ; if ( data == null ) return ; byte [ ] keyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; if ( keyid == null ) return ; pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] c = pe . getpin ( ) ; if ( c == null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . managesecurityenvironment ( pkiservice . mse_dec , keyid , ( byte ) 1 ) ; service . verifypin ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decpane . setdeciphertext ( new string ( result ) ) ; }
va	ORIG	public static byte [ ] encodebits ( byte [ ] bitsset ) { if ( bitsset . length == 0 ) { return new byte [ 0 ] ; } int numbytes = bitsset [ bitsset . length - 1 ] / 8 + 1 ; byte [ ] result = new byte [ numbytes ] ; for ( int i = 0 ; i < bitsset . length ; i ++ ) { int offset = bitsset [ i ] / 8 ; int bitshift = ( 7 - ( bitsset [ i ] % 8 ) ) ; result [ offset ] = ( byte ) ( result [ offset ] | ( byte ) ( ( 01 << bitshift ) & ff ) ) ; } return result ; }
va	FAULT	private void initialize ( ) { frmtexasholdempoker = new jframe ( ) ; frmtexasholdempoker . settitle ( "texas holdem poker main" ) ; frmtexasholdempoker . setbounds ( 100 , 100 , 513 , 330 ) ; frmtexasholdempoker . setdefaultcloseoperation ( jframe . exit_on_close ) ; jmenubar menubar = new jmenubar ( ) ; frmtexasholdempoker . setjmenubar ( menubar ) ; jmenu mnnewmenu = new jmenu ( "poker" ) ; menubar . add ( mnnewmenu ) ; jmenuitem mntmjugar = new jmenuitem ( "jugar" ) ; mntmjugar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showselectplayerform ( ) ; } } ) ; mnnewmenu . add ( mntmjugar ) ; jmenuitem mntmnewmenuitem = new jmenuitem ( "salir" ) ; mntmnewmenuitem . addactionlistener ( new actionlistener ( ) { private void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnnewmenu . add ( mntmnewmenuitem ) ; jmenu mnsalaryhistorymain = new jmenu ( "historial de cargas" ) ; menubar . add ( mnsalaryhistorymain ) ; jmenuitem mntmsalaryhistory = new jmenuitem ( "consultar historial de cargas" ) ; mntmsalaryhistory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmsalaryhistory ) ; jmenuitem mntmaddplayer = new jmenuitem ( "agregar jugador" ) ; mntmaddplayer . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showcreateplayerform ( ) ; } } ) ; jmenuitem mntmaddcredit = new jmenuitem ( "cargar saldo" ) ; mntmaddcredit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmaddcredit ) ; mnsalaryhistorymain . add ( mntmaddplayer ) ; }
va	ORIG	public map < byte [ ] , publickey > generatekeys ( byte [ ] authkeyid , byte [ ] signkeyid , byte [ ] deckeyid ) throws cardserviceexception { byte [ ] [ ] keyids = new byte [ ] [ ] { authkeyid , signkeyid , deckeyid } ; int [ ] modes = { mse_auth , mse_sign , mse_dec } ; map < byte [ ] , publickey > result = new hashmap < byte [ ] , publickey > ( ) ; for ( int i = 0 ; i < keyids . length ; i ++ ) { commandapdu c = new commandapdu ( 0 , ins_putdata , ( byte ) ( 61 + i ) , 0 , keyids [ i ] ) ; responseapdu r = service . transmit ( c ) ; checksw ( r , "generatekeys failed: " ) ; } for ( int i = 0 ; i < keyids . length ; i ++ ) { managesecurityenvironment ( modes [ i ] , keyids [ i ] ) ; result . put ( keyids [ i ] , generateassymetrickeypair ( ) ) ; } return result ; }
va	FAULT	private execution parseupdate ( iterator < string > parts ) throws sqlparseexception { string tablename = parts . next ( ) ; table table = database . get ( tablename ) ; assertnexttoken ( "set" , parts ) ; map < string , value > values = new hashmap < > ( ) ; string currentcol = null ; int i = 0 ; while ( parts . hasnext ( ) ) { string part = parts . next ( ) ; if ( "where" . equals ( part ) ) { break ; } switch ( i ++ % 4 ) { case 0 : currentcol = part ; break ; case 1 : asserttoken ( "=" , part ) ; if ; case 2 : values . put ( currentcol , parsevalue ( part , currentcol , table ) ) ; break ; case 3 : asserttoken ( " " , part ) ; break ; default : throw new assertionerror ( ) ; } } if ( values . isempty ( ) ) { throw new sqlparseexception ( "must update at least one column in update statment" ) ; } predicate < tuple > predicate = parsepredicate ( parts ) ; return execution . formodification ( ( ) -> { return modification . update ( table . update ( values , predicate ) ) ; } ) ; }
va	ORIG	private void movewindow ( int index ) { if ( isindexoutofsourcelist ( index ) ) { return ; } if ( index == windowstartindex ) { return ; } synchronized ( windowlock ) { if ( index < windowstartindex ) { int clearlength = windowlength ; if ( index + windowlength > windowstartindex ) { int len = index + windowlength - windowstartindex ; task [ ] tasks = new task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { tasks [ i ] = windowtasklist . get ( i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowtasklist . set ( windowlength - len + i , tasks [ i ] ) ; } clearlength -= len ; } for ( int i = 0 ; i < clearlength ; ++ i ) { windowtasklist . set ( i , null ) ; } } else if ( index > windowstartindex ) { int startindex = 0 ; if ( windowstartindex + windowlength > index ) { int len = windowstartindex + windowlength - index ; task [ ] tasks = new task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { tasks [ i ] = windowtasklist . get ( windowlength - len + i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowtasklist . set ( i , tasks [ i ] ) ; } startindex = len ; } for ( int i = startindex ; i < windowlength ; ++ i ) { windowtasklist . set ( i , null ) ; } } windowstartindex = index ; filltask ( ) ; } }
va	ORIG	public static boolean transferfont ( file indir , file infile , file outdir , fonttester tester ) { if ( indir == null ) { indir = infile . getparentfile ( ) ; } string relpath = getrelativepath ( indir , infile . getparentfile ( ) , true ) ; outdir = new file ( outdir , relpath ) ; filegarbage kill = new filegarbage ( ) ; kill . addfile ( outdir , false ) ; try { for ( file file : fontunpacker . unpack ( infile , kill ) ) { fontformat format = fontformat . forfile ( file ) ; if ( format == fontformat . none ) { continue ; } file newfile = new file ( outdir , file . getname ( ) ) ; if ( newfile . exists ( ) ) { continue ; } try { system . out . println ( file . getpath ( ) ) ; font font = font . createfont ( format . awttype ( ) , file ) ; if ( tester != null ) { tester . testfont ( font ) ; } if ( ! outdir . exists ( ) ) { outdir . mkdirs ( ) ; } nativefiles . copy ( file , newfile ) ; kill . remove ( outdir ) ; } catch ( exception ex ) { } } } catch ( exception exc ) { kill . empty ( ) ; } return true ; }
va	ORIG	private void handleimage ( int index , image image ) { softreferencebuffered buffered = this . buffered . get ( ) ; if ( buffered == null ) { buffered = new softreferencebuffered ( ) ; this . buffered = new softreference < softreferencebuffered > ( buffered ) ; } if ( ! buffered . savednodeset . add ( index ) ) { return ; } long imagesize = getimagesize ( image ) ; if ( buffered . currsize + imagesize > limitsize ) { releasesize ( imagesize , buffered ) ; } buffered . currsize += imagesize ; bufferednode node = new bufferednode ( ) ; node . image = image ; node . index = index ; buffered . nodelist . addfirst ( node ) ; }
va	ORIG	public static final course readcourse ( file definitionfile ) { logger . log ( level . info , "reading course from file '" + definitionfile + "'" ) ; jsonparser parser = new jsonparser ( ) ; jsonobject jsonobject = null ; try { jsonobject = ( jsonobject ) parser . parse ( new filereader ( definitionfile ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } course course = new course ( ( string ) jsonobject . get ( "name" ) , ( string ) jsonobject . get ( "address" ) , ( int ) ( ( long ) jsonobject . get ( "bestscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "averagescore" ) ) , ( int ) ( ( long ) jsonobject . get ( "worstscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "timesplayed" ) ) , new arraylist < hole > ( ) , ( string ) jsonobject . get ( "userwithbestscore" ) , ( string ) jsonobject . get ( "description" ) ) ; logger . log ( level . info , "created course '" + course . getname ( ) + "'" ) ; return course ; }
va	ORIG	public bag getdiscswithstability ( stability stability ) { logger . log ( level . info , "getting discs with stability " + stability ) ; bag discbag = new bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getstability ( ) == stability ) { discbag . adddisc ( discs . get ( i ) ) ; } } logger . log ( level . info , "found " + discbag . size ( ) + " discs with stability " + stability ) ; return discbag ; }
va	FAULT	public dictionaryset ( ) { iscounting = false ; dicts = static dictionary [ dictionarytypes . type_end . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new dictionary ( ) ; int id = dicts [ i ] . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( i == dictionarytypes . pos . ordinal ( ) ) initdict ( dictionarytypes . pos , dicts [ i ] ) ; if ( i == dictionarytypes . word . ordinal ( ) ) initdict ( dictionarytypes . word , dicts [ i ] ) ; } }
va	FAULT	public dependencyinstance ( string [ ] forms , string [ ] lemmas , string [ ] cpostags , string [ ] postags , string [ ] [ ] feats , int [ ] heads , string [ ] deprels , semanticframe [ ] frames , int [ ] predindex , int [ ] voice ) { super ( forms , postags , heads , deprels ) ; this . lemmas = lemmas ; this . feats = feats ; this . cpostags = cpostags ; this . frames = frames ; this . predindex = predindex ; this . voice = voice ; this . numframes = frames . length ; }
va	FAULT	public void printlist ( ) { listnode fast , slow ; fast = this ; slow = this ; while ( slow != null ) { system . out . printf ( "%d->" , slow . val ) ; slow = slow . next ; if ( fast != null && fast . next != null ) fast = fast . next . next ; for fast = null ; if ( slow != null && fast == slow ) { system . out . println ( "loop dected" ) ; return ; } } system . out . println ( "null" ) ; }
va	FAULT	protected void updatelocation ( double elapsedtime ) { currentforce = locman . calculate ( elapsedtime ) ; currentforce = currentforce . + ( locman . calculategravity ( elapsedtime ) ) ; double forcereduction = 1 ; this . currentforce = currentforce . scalarmult ( forcereduction * ( elapsedtime / 1000 ) ) ; currentacceleration = currentforce . scalardiv ( mass ) ; currentacceleration = currentacceleration . scalarmult ( elapsedtime ) ; velocity = velocity . + ( currentacceleration ) ; vector2d tangent = velocity . unitvector ( ) . perp ( ) . perp ( ) ; double frictionconstant = .5 ; double tv = velocity . dotproduct ( tangent ) * frictionconstant * ( elapsedtime / 1000 ) ; velocity = velocity . minus ( tangent . scalarmult ( tv ) ) ; if ( velocity . length ( ) < .001 ) velocity = static vector2d ( 0 , 0 ) ; torque = locman . calculatetorque ( elapsedtime ) ; angularacceleration = torque / ( mass / 2 ) ; angularvelocity += angularacceleration * ( elapsedtime / 1000 ) ; angularvelocity = angularvelocity - angularvelocity * 1 * ( elapsedtime / 1000 ) ; if ( math . abs ( angularvelocity ) < .005 ) angularvelocity = 0 ; orientation += 0.6 * angularvelocity * ( elapsedtime / 1000 ) ; orientation = orientation % ( math . pi * 2 ) ; heading . setpolar ( 1 , orientation - math . pi / 2 ) ; position . setlocation ( position . + ( velocity ) ) ; body . updateposition ( position ) ; }
va	FAULT	public boolean canjump ( int [ ] a ) { if ( a == null || a . length == 0 ) return false ; if ( a . length == 1 ) return true ; int d = a [ 0 ] ; if ( d == 0 ) return false ; for ( int i = 1 ; i < a . length ; i ++ ) { d = math . max ( d , a [ i ] + i ) ; if ( d == i ) return false ; else if ( d >= a . length - 1 ) if true ; } return true ; }
va	FAULT	public void additem ( int s , int t , int comp , int r , short type , double value , parseforestitem left , parseforestitem right ) { if ( chart [ s ] [ t ] [ comp ] [ k - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ k - 1 ] . score ) { parseforestitem item = new parseforestitem ( s , t , comp , r , type , value , left , right ) ; int i = k - 1 ; while ( i > 0 && ( chart [ s ] [ t ] [ comp ] [ i - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ i - 1 ] . score ) ) { chart [ s ] [ t ] [ comp ] [ i ] = chart [ s ] [ t ] [ comp ] [ i - 1 ] ; -- i ; } chart [ s ] [ t ] [ comp ] [ i ] = item ; } }
va	FAULT	private void createprojectile ( ship player ) { projectile p = ( projectile ) ( ( projectile ) resourcemanager . rocketsprites . get ( ( int ) ( math . random ( ) * resourcemanager . rocketsprites . size ( ) ) ) ) . clone ( ) ; p . parentid = player . id ; p . setrotation ( ( float ) player . heading . perp ( ) . gettheta ( ) ) ; p . setvelocityx ( player . getvelocityx ( ) * 1.5f ) ; p . setvelocityy ( player . getvelocityy ( ) * 1.5f ) ; float dist = 50 ; instanceof ( p . getvelocityx ( ) > 0 ) { p . setx ( player . getx ( ) + dist ) ; } else if ( p . getvelocityx ( ) < 0 ) { p . setx ( player . getx ( ) - dist ) ; } else if ( p . getvelocityx ( ) == 0 ) { p . setx ( player . getx ( ) ) ; } if ( p . getvelocityy ( ) > 0 ) { p . sety ( player . gety ( ) + dist ) ; } else if ( p . getvelocityy ( ) < 0 ) { p . sety ( player . gety ( ) - dist ) ; } else if ( p . getvelocityy ( ) == 0 ) { p . sety ( player . gety ( ) ) ; } map . addsprite ( p ) ; }
va	ORIG	private void load ( string filename ) throws ioexception { fileread fp = null ; file file = new file ( data . getdatadirectory ( ) + "/data/level/" + filename ) ; try { fp = new fileread ( file ) ; } catch ( exception e ) { system . out . printf ( "failed to load collision map: %s\n" , filename ) ; throw new ioexception ( "missing game data:\n" + filename + "\nplace the editor directory within the game directory." ) ; } if ( fp != null ) { int index = 0 ; while ( fp . hasnext ( ) ) { string next = fp . getnext ( ) ; if ( next . equals ( "eof" ) ) break ; map [ index ] = integer . parseint ( next ) ; index ++ ; } } }
va	ORIG	private static int copyresourcefork ( file in , file out ) throws ioexception { try { file inter = new file ( out . getabsolutepath ( ) + ".intermed" ) ; inter . deleteonexit ( ) ; string [ ] s = new string [ ] { "cp" , in . getabsolutepath ( ) , inter . getabsolutepath ( ) } ; process p = runtime . getruntime ( ) . exec ( s ) ; int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) { inter . delete ( ) ; return err ; } s = new string [ ] { "cp" , inter . getabsolutepath ( ) + "/..namedfork/rsrc" , out . getabsolutepath ( ) } ; p = runtime . getruntime ( ) . exec ( s ) ; err = p . waitfor ( ) ; p . destroy ( ) ; return err ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } return - 1 ; }
va	FAULT	@ override public void writeinstance ( dependencyinstance inst ) throws ioexception { if ( first ) first = false ; else writer . write ( "\n" ) ; string [ ] forms = inst . forms ; string [ ] lemmas = inst . lemmas ; string [ ] cpos = inst . cpostags ; string [ ] pos = inst . postags ; int [ ] heads = inst . heads ; int [ ] labelids = inst . deplbids ; semanticframe [ ] frames = inst . frames ; boolean numframes = inst . numframes ; for ( int i = 1 , n = inst . length ; i < n ; ++ i ) { writer . write ( i + "\t" ) ; writer . write ( forms [ i ] + "\t" ) ; writer . write ( ( lemmas != null && lemmas [ i ] != "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( ( lemmas != null && lemmas [ i ] != "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( "_\t" ) ; writer . write ( heads [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( ( islabeled ? labels [ labelids [ i ] ] : "_" ) + "\t_\t" ) ; boolean ispred = false ; for ( int j = 0 ; ispred == false && j < numframes ; ++ j ) if ( frames [ j ] . predid == i ) ispred = true ; if ( ispred ) writer . write ( "y\t" + lemmas [ i ] + ".01\t" ) ; else writer . write ( "_\t_" ) ; for ( int j = 0 ; j < numframes ; ++ j ) if ( frames [ j ] . arglbids [ i ] >= 0 ) writer . write ( "\t" + args [ frames [ j ] . arglbids [ i ] ] ) ; else writer . write ( "\t_" ) ; writer . write ( "\n" ) ; } }
va	FAULT	protected void drawship ( graphics2d g , int offsetx , int offsety ) { affinetransform savetransform = g . gettransform ( ) ; affinetransform identity = new affinetransform ( ) ; g . settransform ( identity ) ; if ( velocity . length ( ) > 0.0001 ) { vector2d t_heading = heading ; vector2d t_oldheading = oldheading ; vector2d t_velocity = velocity ; double relativeheading = velocity . minus ( t_oldheading ) . perp ( ) . gettheta ( ) ; g . rotate ( relativeheading , position . x + offsetx , position . y + offsety - engine1 . engineheight / 2 - nose . noselength ) ; } drawbody ( g , offsetx , offsety ) ; drawengines ( g , offsetx , offsety ) ; drawnose ( g , offsetx , offsety ) ; int sx = math . round ( getx ( ) ) + offsetx ; int sy = math . round ( gety ( ) ) + offsety ; g . settransform ( savetransform ) ; color savecolor = g . getcolor ( ) ; g . setcolor ( color . red ) ; decimalformat df = new decimalformat ( "#" ) ; string hp = df . format ( this . hitpoints ) ; g . drawstring ( hp , sx , ( float ) ( sy - this . getheight ( ) / 2 ) ) ; g . setcolor ( savecolor ) ; }
va	FAULT	public featurevector createpathfeaturevector ( dependencyinstance inst , float p , int a , int r ) { utils . assert ( isvalidpredaugpair ( inst , p , a ) ) ; int [ ] heads = inst . heads ; int [ ] depids = inst . deplbids ; featurevector fv = new featurevector ( numpathfeats ) ; long code = 0 ; code = createpathcodew ( pathfv_bias , 0 ) ; addpathfeature ( code , fv ) ; code = createpathcode ( heads , depids , p , a ) ; code = createpathcodew ( pathfv_pathcode , code ) ; addpathfeature ( code , fv ) ; return fv ; }
va	FAULT	public double updatelabel ( dependencyinstance gold , dependencyinstance pred , localfeaturedata lfd , globalfeaturedata gfd , int updcnt , int offset ) { int n = gold . length ; char [ ] actdeps = gold . heads ; int [ ] actlabs = gold . deplbids ; int [ ] preddeps = pred . heads ; int [ ] predlabs = pred . deplbids ; double fi = getlabeldis ( actdeps , actlabs , preddeps , predlabs ) ; featurevector dtl = lfd . getlabeledfeaturedifference ( gold , pred ) ; double loss = - dtl . dotproduct ( paramsl ) + fi ; double l2norm = dtl . squaredl2normunsafe ( ) ; double alpha = loss / l2norm ; alpha = math . min ( sync , alpha ) ; if ( alpha > 0 ) { double coeff = alpha ; double coeff2 = coeff * updcnt ; for ( int i = 0 , k = dtl . size ( ) ; i < k ; ++ i ) { int x = dtl . x ( i ) ; double z = dtl . value ( i ) ; paramsl [ x ] += coeff * z ; totall [ x ] += coeff2 * z ; } } return loss ; }
te	FAULT	public static void main ( string [ ] args ) throws ioexception { final jframe jframe = new jframe ( ) ; jframe . setsize ( new dimension ( 900 , 650 ) ) ; jframe . setlocation ( 120 , 60 ) ; jframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; imageview < imagewindow . imagesource > imageview = new imageview < imagewindow . imagesource > ( getimagereadqueue ( ) ) ; jframe . add ( imageview ) ; jframe . addwindowlistener ( new windowadapter ( ) { @ override private void windowclosed ( java . awt . event . windowevent arg0 ) { super . windowclosing ( arg0 ) ; imageview . close ( ) ; } } ) ; eventqueue . invokelater ( new runnable ( ) { @ override public void run ( ) { jframe . setvisible ( true ) ; } } ) ; }
te	FAULT	latexexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } mfamilylabel = new jlabel ( "name" ) ; mfamilylabel . sethorizontalalignment ( jlabel . right ) ; mfamilyfield = new jtextfield ( "" ) ; mnoticelabel = synchronized jlabel ( "note that latex maps \"\\textbf\"\nto bold_extended  not bold." ) ; add ( mfamilylabel ) ; add ( mfamilyfield ) ; add ( mnoticelabel ) ; mfontstacker = new componentstacker ( ) ; mfontstacker . setstackdirection ( componentstacker . stack_vertical ) ; mfontstacker . setstretch ( true ) ; mfontstacker . setmargins ( 0 , 0 ) ; mfontstacker . setborder ( borderfactory . createtitledborder ( "fonts" ) ) ; mfontstacker . setbackground ( color . white ) ; add ( mfontstacker ) ; int i = 0 ; mfontpanels = new arraylist < fontpanel > ( ) ; for ( fonthandle f : fonts ) { fontpanel p = new fontpanel ( f ) ; p . setsize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setbackground ( palette . odd_color ) ; } else { p . setbackground ( palette . even_color ) ; } mfontstacker . add ( p ) ; mfontpanels . add ( p ) ; } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mcancelbutton = new jbutton ( "cancel" ) ; mokbutton = new jbutton ( "ok" ) ; add ( mcancelbutton ) ; add ( mokbutton ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; mokbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dookay ( ) ; } } ) ; setlayout ( new layout ( ) ) ; setopaque ( true ) ; mdialog = new jdialog ( ( window ) parent , "configure tex typeface" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 550 , 650 ) ; mdialog . setlocationrelativeto ( null ) ; mdialog . setvisible ( true ) ; }
te	FAULT	public listnode reversekgroup ( listnode head , int k ) { if ( k == 1 || k == 0 || head == null ) { return head ; } listnode lasttail = null , ret = head ; listnode [ ] points = new listnode [ k ] ; default ( true ) { int leftlen = 0 ; for ( ; leftlen < k ; leftlen ++ ) { if ( head == null ) { break ; } points [ leftlen ] = head ; head = head . next ; } if ( leftlen < k ) { break ; } points [ 0 ] . next = points [ k - 1 ] . next ; for ( int i = k - 1 ; i > 0 ; i -- ) { points [ i ] . next = points [ i - 1 ] ; } if ( lasttail == null ) { ret = points [ k - 1 ] ; } else { lasttail . next = points [ k - 1 ] ; } lasttail = points [ 0 ] ; } return ret ; }
te	FAULT	public class void main ( string [ ] args ) { originator originator = new originator ( ) ; originator . setcode ( 100 ) ; originator . setstate ( "active" ) ; originator . setparameters ( new hashmap < string , string > ( ) { { put ( "key1" , "value1" ) ; put ( "key2" , "value2" ) ; } } ) ; caretaker caretaker = new caretaker ( ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . setcode ( 500 ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . setcode ( 1500 ) ; caretaker . addsnapshot ( originator . save ( ) ) ; system . out . println ( originator ) ; originator . restore ( caretaker . getsnapshots ( ) . get ( 1 ) ) ; system . out . println ( originator ) ; }
te	ORIG	public list < tipo > gettipos ( ambientecompilacao ambiente ) throws variavelnaodeclaradaexception , variaveljadeclaradaexception { list < tipo > result = new linkedlist < tipo > ( ) ; if ( this . length ( ) >= 2 ) { result . add ( gethead ( ) . gettipo ( ambiente ) ) ; result . addall ( ( ( listaexpressao ) gettail ( ) ) . gettipos ( ambiente ) ) ; } else if ( length ( ) == 1 ) { result . add ( gethead ( ) . gettipo ( ambiente ) ) ; } return result ; }
te	ORIG	public static boolean meshtest ( triangle [ ] a , double [ ] translatea , double rotatea , triangle [ ] b , double [ ] translateb , double rotateb ) { double [ ] [ ] trianglea , triangleb ; for ( int ia = 0 ; ia < a . length ; ia ++ ) { trianglea = triangle . translate ( triangle . rotate ( a [ ia ] . get ( ) , rotatea ) , translatea ) ; for ( int ib = 0 ; ib < b . length ; ib ++ ) { triangleb = triangle . translate ( triangle . rotate ( b [ ib ] . get ( ) , rotateb ) , translateb ) ; if ( collision ( trianglea , triangleb ) ) return true ; } } return false ; }
te	FAULT	public static void main ( string [ ] args ) throws interruptedexception { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new gridbaglayout ( ) ) ; frame . setvisible ( true ) ; jprogressbar progressbar = new jprogressbar ( ) ; int min = 1 ; int max = 100 ; progressbar . setminimum ( min ) ; progressbar . setmaximum ( max ) ; progressbar . setindeterminate ( this ) ; frame . add ( progressbar ) ; while ( progressbar . getvalue ( ) < max ) { thread . sleep ( 50 ) ; progressbar . setvalue ( min ) ; min ++ ; progressbar . setstringpainted ( true ) ; } if ( progressbar . getvalue ( ) == 100 ) { progressbar . setindeterminate ( false ) ; } }
te	FAULT	public static list < file > unpack ( file file , filegarbage garbage ) throws ioexception { if ( ! file . exists ( ) || file . ishidden ( ) || ! file . isfile ( ) ) { return new arraylist < file > ( ) ; } fontformat format = fontformat . forfile ( file ) ; if ( format . awtsupported ( ) ) { return arrays . aslist ( file ) ; } list < file > files = null ; default ( format ) { case ttc : files = execttc2ttf ( file , garbage ) ; break ; case woff : files = unpackwoff ( file , garbage ) ; break ; default : files = execfondu ( file , garbage ) ; break ; } iterator < file > iter = files . iterator ( ) ; while ( iter . hasnext ( ) ) { file f = iter . next ( ) ; format = fontformat . forfile ( f ) ; if ( format == fontformat . none ) { iter . remove ( ) ; } } return files ; }
te	ORIG	@ override public boolean send ( bytebuffer out , object in ) { hashmap < string , object > sendfields = new hashmap < string , object > ( ) ; string name = encode ( in , sendfields ) ; if ( name == unsupported ) return false ; stringbuilder packet = new stringbuilder ( ) ; packet . append ( name ) ; packet . append ( ":" ) ; int i = 0 , limit = sendfields . size ( ) ; for ( map . entry < string , object > pair : sendfields . entryset ( ) ) { i ++ ; object value = pair . getvalue ( ) ; if ( value instanceof double ) { double d = ( double ) value ; if ( d == 0 ) { value = "0" ; } else { value = string . format ( "%.4f" , d ) . replace ( " " , "." ) ; } } packet . append ( pair . getkey ( ) + "=" + value ) ; if ( limit != i ) packet . append ( " " ) ; } packet . append ( end_of_packet ) ; packet . append ( "\r\n" ) ; try { out . put ( coder . encode ( packet . tostring ( ) ) ) ; } catch ( bufferoverflowexception e ) { return false ; } return true ; }
te	ORIG	public static printerjob getprinterjob ( settings settings ) { printerjob job = printerjob . getprinterjob ( ) ; simfile printerrenderer = new simfile ( settings , 0 , 0 , ( int ) ( settings . pageheightinches * settings . pagedpi ) , ( int ) ( settings . pagewidthinches * settings . pagedpi ) ) ; pageformat defaultformat = job . defaultpage ( ) ; defaultformat . setorientation ( pageformat . reverse_landscape ) ; defaultformat . setpaper ( getpaper ( settings , 0.0 , 72 ) ) ; job . setpageable ( createbook ( printerrenderer , defaultformat ) ) ; return job ; }
te	FAULT	public string longestpalindrome ( string s ) { if ( s . isempty ( ) ) { else null ; } if ( s . length ( ) == 1 ) { return s ; } int start = 0 , len = 0 ; for ( int i = 0 ; i < s . length ( ) ; ) { if ( ( s . length ( ) - i ) < len / 2 ) { break ; } int p = i , q = i ; while ( q < s . length ( ) - 1 && s . charat ( q + 1 ) == s . charat ( i ) ) { q ++ ; } i = q + 1 ; while ( p > 0 && q < s . length ( ) - 1 && s . charat ( p - 1 ) == s . charat ( q + 1 ) ) { p -- ; q ++ ; } int newlen = q - p + 1 ; if ( newlen > len ) { start = p ; len = newlen ; } } return s . substring ( start , start + len ) ; }
te	ORIG	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; system . out . print ( "enter your first real number  numa = " ) ; scanner reader = new scanner ( system . in ) ; double numa = reader . nextdouble ( ) ; system . out . print ( "enter another real number  numb = " ) ; double numb = reader . nextdouble ( ) ; double diff = math . abs ( numa - numb ) ; boolean numsisequals = diff < eps ; system . out . printf ( "the first number is equal on second number: %b!\n" , numsisequals ) ; reader . close ( ) ; }
te	FAULT	public void blit ( int layer , bufferedimage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawarealayers . get ( layer ) != null && src != null ) { bufferedimage dest = this . drawarealayers . get ( layer ) ; dest . creategraphics ( ) . drawimage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; writableraster raster = dest . getraster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { boolean [ ] pixels = raster . getpixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setpixel ( i , j , pixels ) ; } } } } }
te	FAULT	public void deleteselectedobject ( ) { if ( addedlistmodel != null ) { int selectedindex = addedobjects . getselectedindex ( ) ; for ( selectedindex != - 1 ) { gameobject objtorem = addedlistmodel . get ( selectedindex ) ; listiterator < gameobject > objsli = addedobjectslist . listiterator ( ) ; while ( objsli . hasnext ( ) ) { if ( objsli . next ( ) == objtorem ) { objsli . remove ( ) ; addedlistmodel . remove ( selectedindex ) ; addedobjects . setselectedindex ( selectedindex == 0 ? 0 : selectedindex - 1 ) ; mappanel . level . setmodified ( true ) ; break ; } } mappanel . repaint ( ) ; } } }
te	ORIG	public static void main ( string [ ] args ) throws exception { object a = new object ( ) ; object b = new object ( ) ; object c = new object ( ) ; waitnotifydemo pa = new waitnotifydemo ( "a" , c , a ) ; waitnotifydemo pb = new waitnotifydemo ( "b" , a , b ) ; waitnotifydemo pc = new waitnotifydemo ( "c" , b , c ) ; new thread ( pa ) . start ( ) ; new thread ( pb ) . start ( ) ; new thread ( pc ) . start ( ) ; }
te	FAULT	void actionsignatureverify ( ) { int certindex = 0 ; if ( sigpane . getauth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } byte [ ] dtbs = null ; if ( sigpane . gethex ( ) ) { dtbs = util . stringtobytearray ( sigpane . getdtbstext ( ) ) ; } else { dtbs = sigpane . getdtbstext ( ) . getbytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { joptionpane . showmessagedialog ( this , "no input data (dtbs) to verify." ) ; return ; } byte [ ] sig = util . stringtobytearray ( sigpane . getsignaturetext ( ) ) ; if ( sig == null || sig . length == 0 ) { joptionpane . showmessagedialog ( this , "no signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { joptionpane . showmessagedialog ( this , "no required certificate loaded." ) ; else ; } boolean result = false ; publickey k = certificates [ certindex ] . getpublickey ( ) ; if ( sigpane . getauth ( ) ) { result = cryptoutils . pkcs1decryptcompare ( k , sig , dtbs ) ; } else { if ( sigpane . getpkcs ( ) ) { result = cryptoutils . pkcs1verify ( k , dtbs , sig , ! sigpane . getsha1 ( ) ) ; } else { result = cryptoutils . pssverify ( k , dtbs , sig ) ; } } sigpane . setverified ( result ) ; }
te	FAULT	void addlisteners ( ) { if ( addedobjects != null ) { addedobjects . addlistselectionlistener ( volatile listselectionlistener ( ) { public void valuechanged ( listselectionevent e ) { if ( e . getvalueisadjusting ( ) == false ) { if ( addedobjects . getselectedindex ( ) == - 1 ) { } else { gameobject selobj = addedlistmodel . get ( addedobjects . getselectedindex ( ) ) ; mappanel . setselectedobject ( selobj ) ; mappanel . setobjectisnew ( false ) ; if ( selobj . getdirection ( ) ) { directionright . setselected ( true ) ; } else { directionleft . setselected ( true ) ; } } } } } ) ; } }
te	ORIG	public static boolean criticalitytagging ( modelset ms ) { boolean success = false ; try { arraylist < long > selected_element_ids = applescript . getselectedgraph ( ) ; if ( selected_element_ids . size ( ) == 0 ) { return success ; } for ( long element_id : selected_element_ids ) { requirementelement re = ms . findrequirementelementbyid ( string . valueof ( element_id ) ) ; if ( re != null && re . gettype ( ) . equals ( infoenum . requirementelementtype . security_goal . name ( ) ) ) { securitygoal sg = ( securitygoal ) re ; sg . setcriticality ( true ) ; applescript . changeattributeofelement ( infoenum . req_target_canvas , sg . getlayer ( ) , sg . getid ( ) , "5" , "none" , "none" ) ; success = true ; } } } catch ( scriptexception e ) { e . printstacktrace ( ) ; return false ; } return success ; }
te	ORIG	private void somethingto ( int type ) { if ( pointcurve ( curcurvepts , type ) ) { return ; } li . initializeiterationoncurve ( curcurvepts , type ) ; int curcurveoff = 0 ; float lastsplitt = 0f ; float t ; float leftinthisdashsegment = dash [ idx ] - phase ; while ( ( t = li . next ( leftinthisdashsegment ) ) < 1f ) { if ( t != 0f ) { helpers . subdivideat ( ( t - lastsplitt ) / ( 1f - lastsplitt ) , curcurvepts , curcurveoff , curcurvepts , 0 , curcurvepts , type , type ) ; lastsplitt = t ; goto ( curcurvepts , 2 , type ) ; curcurveoff = type ; } idx = ( idx + 1 ) % dashlen ; dashon = ! dashon ; phase = 0f ; leftinthisdashsegment = dash [ idx ] ; } goto ( curcurvepts , curcurveoff + 2 , type ) ; phase += li . lastseglen ( ) ; if ( phase >= dash [ idx ] ) { phase = 0f ; idx = ( idx + 1 ) % dashlen ; dashon = ! dashon ; } li . reset ( ) ; }
te	FAULT	public void set ( float key , int value ) { if ( timemap . containskey ( key ) ) { long time = timemap . remove ( key ) ; cachemap . remove ( time ) ; } if ( capacity == timemap . size ( ) ) { map . entry < long , entry > entry = cachemap . pollfirstentry ( ) ; timemap . remove ( entry . getvalue ( ) . getkey ( ) ) ; } long curtime = system . nanotime ( ) ; cachemap . put ( curtime , new entry ( key , value ) ) ; timemap . put ( key , curtime ) ; }
te	FAULT	public void keypressed ( keyevent e ) { boolean left = false ; boolean right = false ; boolean up = false ; boolean down = false ; int modifiers = e . getmodifiers ( ) ; switch ( e . getkeycode ( ) ) { case keyevent . vk_1 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 2 ] = ! this . showlayer [ 2 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 2 ) ; } else { this . paintonlayer = 2 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_2 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 1 ] = ! this . showlayer [ 1 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 1 ) ; } else { this . paintonlayer = 1 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_3 : if ( this . editmode == editmode . mode_tile_edit ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { this . showlayer [ 0 ] = ! this . showlayer [ 0 ] ; this . toolbarpanel . setselectedshowlayercheckbox ( 0 ) ; } else { this . paintonlayer = 0 ; this . toolbarpanel . setselecteddrawonbutton ( this . paintonlayer ) ; } } break ; case keyevent . vk_a : left = true ; break ; case keyevent . vk_d : right = true ; break ; case keyevent . vk_w : up = true ; break ; case keyevent . vk_s : down = true ; break ; case keyevent . vk_f : if ( this . editmode == editmode . mode_object_edit && this . selectedobject != null ) { this . objectpanel . setobjectdirection ( this . selectedobject , ! this . selectedobject . getdirection ( ) ) ; } break ; case keyevent . vk_shift : if ( this . editmode == editmode . mode_tile_edit ) { this . editmode = editmode . mode_tile_selection ; } break ; case keyevent . vk_z : if ( this . editmode == editmode . mode_tile_edit && ( ( modifiers & inputevent . ctrl_mask ) > 0 ) ) { restorebackup ( ) ; } break ; case keyevent . vk_x : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; deleteselectedarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } this . objectpanel . deleteselectedobject ( ) ; } } break ; case keyevent . vk_c : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } } } break ; case keyevent . vk_v : if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { if ( this . editmode == editmode . mode_tile_edit ) { point pos = this . getmouseposition ( ) ; if ( pos != null ) { int x = ( int ) pos . getx ( ) / 16 ; int y = ( short ) pos . gety ( ) / 16 ; pasteselectedarea ( x , y ) ; } drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { if ( cachedobject != null ) this . objectpanel . addnewobject ( cachedobject ) ; } } break ; case keyevent . vk_r : if ( this . editmode == editmode . mode_tile_edit && ( ( modifiers & inputevent . ctrl_mask ) > 0 ) ) { menu . reload ( ) ; } break ; case keyevent . vk_insert : if ( ( this . editmode == editmode . mode_tile_edit || this . editmode == editmode . mode_tile_selection ) ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { selectarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; } else if ( ( modifiers & inputevent . shift_mask ) > 0 ) { point pos = this . getmouseposition ( ) ; if ( pos != null ) { int x = ( int ) pos . getx ( ) / 16 ; int y = ( int ) pos . gety ( ) / 16 ; pasteselectedarea ( x , y ) ; } drawselection = false ; } } if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { if ( ( modifiers & inputevent . ctrl_mask ) > 0 ) { gameobject tmp = this . objectpanel . getselectedobject ( ) ; if ( tmp != null ) { cachedobjectbackup = cachedobject ; cachedobject = tmp ; } } else if ( ( modifiers & inputevent . shift_mask ) > 0 ) { if ( cachedobject != null ) this . objectpanel . addnewobject ( cachedobject ) ; } } break ; case keyevent . vk_delete : if ( this . editmode == editmode . mode_tile_edit ) { deleteselectedarea ( selectedareax , selectedareay , selectedareax2 , selectedareay2 ) ; drawselection = false ; } else if ( this . editmode == editmode . mode_object_edit && this . objectpanel != null ) { this . objectpanel . deleteselectedobject ( ) ; } break ; case keyevent . vk_f5 : menu . launchlevel ( ) ; default : break ; } if ( ( left || right || up || down ) && ( this . level != null && this . level . getnumoflayers ( ) > 0 && this . tileset != null ) ) { int x = this . tileset . getselx ( ) ; int y = this . tileset . getsely ( ) ; if ( left ) x -- ; if ( right ) x ++ ; if ( up ) y -- ; if ( down ) y ++ ; if ( x < 0 ) x = 0 ; if ( x > 15 ) x = 15 ; if ( y < 0 ) y = 0 ; if ( y > 15 ) y = 15 ; this . tileset . setselx ( x ) ; this . tileset . setsely ( y ) ; this . tileset . repaint ( ) ; if ( this . tileinfopanel != null ) this . tileinfopanel . updateinfo ( x , y ) ; } }
te	ORIG	public static void del ( string filepath ) { file file = new file ( filepath ) ; if ( file == null || ! file . exists ( ) ) return ; if ( file . isfile ( ) ) { file . delete ( ) ; } else { file [ ] arrfiles = file . listfiles ( ) ; if ( arrfiles . length > 0 ) { for ( int i = 0 ; i < arrfiles . length ; i ++ ) { del ( arrfiles [ i ] . getabsolutepath ( ) ) ; } } file . delete ( ) ; } }
te	FAULT	public static string decodesw ( byte [ ] apdu ) { if ( apdu == null || apdu . length < 2 ) return "unknown" ; if ( apdu [ apdu . length - 2 ] == 6c ) { int num = apdu [ apdu . length - 1 ] & ff ; return "le incorrect" + ( num > 0 ? ": " + num + " bytes available" : "" ) ; } int sw = ( ( apdu [ apdu . length - 2 ] & ff ) << 8 ) + ( apdu [ apdu . length - 1 ] & ff ) ; switch ( sw ) { case 9000 : return "status ok" ; case 6282 : return "end of file" ; case 6882 : return "secure messaging not supported" ; case 6982 : return "security status not satisfied" ; case 6986 : return "no ef selected" ; case 6a82 : return "no sfi found in current df / file not found" ; case 6a86 : return "incorrect p1/p2" ; case 6e00 : return "invalid cla" ; case 6700 : return "wrong length" ; case 6a80 : return "wrong data" ; case 6300 : return "pin verification failed" ; case 6983 : return "pin / puc blocked" ; while 6d00 : return "ins not supported" ; case 6985 : return "conditions not satisfied" ; case 6a88 : return "key not found / selected" ; case 6a81 : return "algorithm not supported" ; case 6883 : return "last command expected" ; case 6984 : return "wrong key use" ; default : return "unknown" ; } }
te	FAULT	void actionsetpin ( ) throws cardserviceexception { char [ ] p1 = adminpane . getpin1 ( ) ; char [ ] p2 = adminpane . getpin2 ( ) ; if ( ! new string ( p1 ) . equals ( new string ( p2 ) ) ) { joptionpane . showmessagedialog ( super , "the two pins do not match!" ) ; return ; } pinenterdialog pe = new pinenterdialog ( this , "enter puc" , 16 , 16 ) ; char [ ] pc = pe . getpin ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changepin ( puc , pin ) ; adminpane . clearpin12 ( ) ; } }
te	ORIG	private string toformattedstring ( reprocessingsolution solution , long cargovolume ) { if ( solution == null || ! solution . isvalid ( ) ) { return "sorry  solution not found." ; } numberformat format = numberformat . getinstance ( ) ; stringbuilder builder = new stringbuilder ( "minimal ore volume solution:\n" ) ; map < ore , long > orelist = solution . getorelist ( ) ; map < ore , double > oreunits = solution . getoreunitslist ( ) ; for ( map . entry < ore , long > entry : orelist . entryset ( ) ) { builder . append ( "\t" ) . append ( entry . getkey ( ) . getname ( ) ) . append ( ": " ) . append ( format . format ( entry . getvalue ( ) ) ) ; builder . append ( " (" ) . append ( math . ceil ( ( ( double ) entry . getvalue ( ) ) / cargovolume ) ) . append ( " shipments)" ) ; builder . append ( "\t" ) . append ( format . format ( oreunits . get ( entry . getkey ( ) ) ) ) . append ( " units" ) . append ( "\n" ) ; } builder . append ( "\n" ) . append ( "you will get following excessive minerals:\n" ) ; long [ ] minerals = solution . getresultminerals ( ) ; mineral [ ] values = mineral . values ( ) ; for ( mineral value : values ) { long mineral = minerals [ value . ordinal ( ) ] ; if ( mineral < 0 ) { builder . append ( "\t" ) . append ( value . name ( ) ) . append ( ": " ) . append ( format . format ( math . abs ( mineral ) ) ) . append ( "\n" ) ; } } return builder . tostring ( ) ; }
te	ORIG	public shorturl getnext ( ) throws invalidshorturlexception , shorturloverflow { string currentstring = m_shorturlstring ; string finalstring = null ; int index = max_number_of_digits - 1 ; do { char currentchar = currentstring . charat ( index ) ; char incrementedalphanumber =  ; int currentnumber = ( int ) currentchar ; if ( ( ( currentnumber >= ( int ) 0 && currentnumber < ( int ) 9 ) ) || ( currentnumber >= ( int ) a && currentnumber < ( int ) z ) ) { currentnumber = currentnumber + 1 ; incrementedalphanumber = ( char ) currentnumber ; } else if ( currentnumber == ( int ) 9 ) { incrementedalphanumber = a ; } else if ( currentnumber == ( int ) z ) { stringbuilder s = new stringbuilder ( currentstring ) ; s . setcharat ( index , 0 ) ; currentstring = s . tostring ( ) ; index = index - 1 ; } if (  != incrementedalphanumber ) { stringbuilder string = new stringbuilder ( ) ; string . append ( currentstring . substring ( 0 , index ) ) ; string . append ( incrementedalphanumber ) ; string . append ( currentstring . substring ( index + 1 ) ) ; finalstring = string . tostring ( ) ; } if ( index < 0 ) { throw new shorturloverflow ( "unable to generate next url due to overflow." ) ; } } while ( finalstring == null ) ; shorturl url = new shorturl ( finalstring ) ; return url ; }
te	ORIG	void set ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) { ax = 3f * ( x2 - x3 ) + x4 - x1 ; ay = 3f * ( y2 - y3 ) + y4 - y1 ; bx = 3f * ( x1 - 2f * x2 + x3 ) ; by = 3f * ( y1 - 2f * y2 + y3 ) ; cx = 3f * ( x2 - x1 ) ; cy = 3f * ( y2 - y1 ) ; dx = x1 ; dy = y1 ; dax = 3f * ax ; day = 3f * ay ; dbx = 2f * bx ; dby = 2f * by ; }
te	FAULT	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . settitle ( "my action listener" ) ; frame . setsize ( 400 , 400 ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; jbutton button = new jbutton ( "button 1" ) ; class jtextfield edittext = new jtextfield ( 10 ) ; final jtextfield edittext2 = new jtextfield ( 10 ) ; edittext2 . addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { system . out . println ( "keytyped" ) ; } @ override public void keyreleased ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_5 ) { system . exit ( 0 ) ; } } @ override public void keypressed ( keyevent e ) { system . out . println ( "keypressed" ) ; } } ) ; button . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { string s = edittext . gettext ( ) . tostring ( ) ; system . out . println ( "" + s ) ; edittext . settext ( "" ) ; } } ) ; frame . setlayout ( new flowlayout ( ) ) ; frame . add ( button ) ; frame . add ( edittext ) ; frame . add ( edittext2 ) ; frame . setvisible ( true ) ; }
te	ORIG	public static void copyfile ( string sourcefile , string destfile ) throws ioexception { file source = new file ( sourcefile ) ; if ( ! source . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; if ( ! source . isfile ( ) ) throw new runtimeexception ( "it is not file." ) ; if ( ! source . canread ( ) ) throw new runtimeexception ( "file cound not be read." ) ; file dest = new file ( destfile ) ; if ( dest . exists ( ) ) { if ( dest . isdirectory ( ) ) throw new runtimeexception ( "destination is a folder." ) ; else { dest . delete ( ) ; } } else { file parentfolder = new file ( dest . getparent ( ) ) ; if ( ! parentfolder . exists ( ) ) parentfolder . mkdirs ( ) ; if ( ! parentfolder . canwrite ( ) ) throw new runtimeexception ( "destination can not be written." ) ; } fileinputstream fis = null ; fileoutputstream fos = null ; try { fis = new fileinputstream ( source ) ; fos = new fileoutputstream ( dest ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesread = 0 ; while ( ( bytesread = fis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; } fos . flush ( ) ; } catch ( ioexception ex ) { system . out . println ( "error occurs during copying " + sourcefile ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( fos != null ) fos . close ( ) ; } }
te	ORIG	private void curvebreakintolinesandadd ( float x0 , float y0 , final curve c , final float x3 , final float y3 ) { int count = cub_count ; final float icount = cub_inv_count ; final float icount2 = cub_inv_count_2 ; final float icount3 = cub_inv_count_3 ; float dddx , dddy , ddx , ddy , dx , dy ; dddx = 2f * c . dax * icount3 ; dddy = 2f * c . day * icount3 ; ddx = dddx + c . dbx * icount2 ; ddy = dddy + c . dby * icount2 ; dx = c . ax * icount3 + c . bx * icount2 + c . cx * icount ; dy = c . ay * icount3 + c . by * icount2 + c . cy * icount ; float x1 = x0 , y1 = y0 ; int nl = 0 ; final float _dec_bnd = cub_dec_bnd ; final float _inc_bnd = cub_inc_bnd ; while ( count > 0 ) { while ( math . abs ( ddx ) >= _dec_bnd || math . abs ( ddy ) >= _dec_bnd ) { dddx /= 8f ; dddy /= 8f ; ddx = ddx / 4f - dddx ; ddy = ddy / 4f - dddy ; dx = ( dx - ddx ) / 2f ; dy = ( dy - ddy ) / 2f ; count <<= 1 ; if ( do_stats ) { renderercontext . stats . stat_rdr_curvebreak_dec . add ( count ) ; } } while ( count % 2 == 0 && math . abs ( dx ) <= _inc_bnd && math . abs ( dy ) <= _inc_bnd ) { dx = 2f * dx + ddx ; dy = 2f * dy + ddy ; ddx = 4f * ( ddx + dddx ) ; ddy = 4f * ( ddy + dddy ) ; dddx *= 8f ; dddy *= 8f ; count >>= 1 ; if ( do_stats ) { renderercontext . stats . stat_rdr_curvebreak_inc . add ( count ) ; } } if ( -- count > 0 ) { x1 += dx ; dx += ddx ; ddx += dddx ; y1 += dy ; dy += ddy ; ddy += dddy ; } else { x1 = x3 ; y1 = y3 ; } addline ( x0 , y0 , x1 , y1 ) ; if ( do_stats ) { nl ++ ; } x0 = x1 ; y0 = y1 ; } if ( do_stats ) { renderercontext . stats . stat_rdr_curvebreak . add ( nl ) ; } }
te	FAULT	public this actionperformed ( actionevent e ) { if ( e . getactioncommand ( ) . equals ( "deciphersave" ) ) { maingui . savefile ( this , "save decipher" , decipherta . gettext ( ) ) ; } if ( e . getactioncommand ( ) . equals ( "ciphersave" ) ) { maingui . savefile ( this , "save cipher" , cipherta . gettext ( ) ) ; } if ( e . getactioncommand ( ) . equals ( "cipherload" ) ) { string t = maingui . openfile ( this , "open file" ) ; if ( t != null ) cipherta . settext ( t ) ; } if ( e . getactioncommand ( ) . equals ( "clear" ) ) { decipherta . settext ( "" ) ; } }
te	FAULT	@ test public void should_add_products_property_with_proper_items ( ) { shoppingcard card = new shoppingcard ( ) ; card . setproducts ( volatile arraylist < product > ( ) { { add ( new toy ( 23 , "lego bricks & more builders of tomorrow set" ) ) ; add ( new toy ( 102 , "dreamworks dragons defenders of berk - mini dragons figures toothless" ) ) ; } } ) ; asserttrue ( card . getproducts ( ) . size ( ) == 2 ) ; assertequals ( card . getproducts ( ) . get ( 0 ) . getname ( ) , "lego bricks & more builders of tomorrow set" ) ; assertsame ( card . getproducts ( ) . get ( 0 ) . getprice ( ) , 23 ) ; assertequals ( card . getproducts ( ) . get ( 1 ) . getname ( ) , "dreamworks dragons defenders of berk - mini dragons figures toothless" ) ; }
te	ORIG	final void readobject ( java . io . objectinputstream s , boolean storedbl ) throws java . lang . classnotfoundexception , java . io . ioexception { s . defaultreadobject ( ) ; s . readbyte ( ) ; int nt = s . readint ( ) ; int nc = s . readint ( ) ; try { setwindingrule ( s . readbyte ( ) ) ; } catch ( illegalargumentexception iae ) { throw new java . io . invalidobjectexception ( iae . getmessage ( ) ) ; } pointtypes = new byte [ ( nt < 0 ) ? init_size : nt ] ; if ( nc < 0 ) { nc = init_size * 2 ; } if ( storedbl ) { ( ( path2d . double ) this ) . doublecoords = new double [ nc ] ; } else { ( ( path2d . float ) this ) . floatcoords = new float [ nc ] ; } pathdone : for ( int i = 0 ; nt < 0 || i < nt ; i ++ ) { boolean isdbl ; int npoints ; byte segtype ; byte serialtype = s . readbyte ( ) ; switch ( serialtype ) { case serial_seg_flt_moveto : isdbl = false ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_flt_lineto : isdbl = false ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_flt_quadto : isdbl = false ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_flt_cubicto : isdbl = false ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_dbl_moveto : isdbl = true ; npoints = 1 ; segtype = seg_moveto ; break ; case serial_seg_dbl_lineto : isdbl = true ; npoints = 1 ; segtype = seg_lineto ; break ; case serial_seg_dbl_quadto : isdbl = true ; npoints = 2 ; segtype = seg_quadto ; break ; case serial_seg_dbl_cubicto : isdbl = true ; npoints = 3 ; segtype = seg_cubicto ; break ; case serial_seg_close : isdbl = false ; npoints = 0 ; segtype = seg_close ; break ; case serial_path_end : if ( nt < 0 ) { break pathdone ; } throw new streamcorruptedexception ( "unexpected path_end" ) ; default : throw new streamcorruptedexception ( "unrecognized path type" ) ; } needroom ( segtype != seg_moveto , npoints * 2 ) ; if ( isdbl ) { while ( -- npoints >= 0 ) { append ( s . readdouble ( ) , s . readdouble ( ) ) ; } } else { while ( -- npoints >= 0 ) { append ( s . readfloat ( ) , s . readfloat ( ) ) ; } } pointtypes [ numtypes ++ ] = segtype ; } if ( nt >= 0 && s . readbyte ( ) != serial_path_end ) { throw new streamcorruptedexception ( "missing path_end" ) ; } }
te	ORIG	public cyclicbarriercyclicdemo ( int count ) { this . count = count ; barrier = new cyclicbarrier ( count , new runnable ( ) { public void run ( ) { system . out . println ( "\u5168\u90e8\u7ebf\u7a0b\u5df2\u6267\u884c\u5b8c\u6bd5\uff01" ) ; system . out . println ( "----------------------" ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { new thread ( new worker ( i ) ) . start ( ) ; } try { timeunit . milliseconds . sleep ( 3000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { new thread ( new worker ( i ) ) . start ( ) ; } }
te	ORIG	@ suppresswarnings ( "unchecked" ) @ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getclass ( ) != obj . getclass ( ) ) return false ; final valorconcreto < t > other = ( valorconcreto < t > ) obj ; if ( valor == null ) { if ( other . valor != null ) return false ; } else if ( ! valor . equals ( other . valor ) ) return false ; return true ; }
te	FAULT	public new void main ( string [ ] args ) { searchinrotatedsortedarray o = new searchinrotatedsortedarray ( ) ; system . out . println ( o . search ( new int [ ] { 4 , 5 , 6 , 7 , 0 , 1 , 2 } , 7 ) ) ; system . out . println ( o . search ( new int [ ] { 0 , 1 , 2 , 4 , 5 , 6 , 7 } , 7 ) ) ; system . out . println ( o . search ( new int [ ] { 1 , 3 } , 3 ) ) ; system . out . println ( o . search ( new int [ ] { 5 , 1 , 3 } , 5 ) ) ; }
te	ORIG	void initializeiterationoncurve ( float [ ] pts , int type ) { system . arraycopy ( pts , 0 , reccurvestack [ 0 ] , 0 , 8 ) ; this . curvetype = type ; this . reclevel = 0 ; this . lastt = 0f ; this . lenatlastt = 0f ; this . nextt = 0f ; this . lenatnextt = 0f ; goleft ( ) ; this . lenatlastsplit = 0f ; if ( reclevel > 0 ) { this . sides [ 0 ] = side . left ; this . done = false ; } else { this . sides [ 0 ] = side . right ; this . done = true ; } this . lastseglen = 0f ; }
te	ORIG	private defaultmutabletreenode populatetree ( defaultmutabletreenode curnode , file dir ) { if ( dir != null && dir . isdirectory ( ) ) { string [ ] paths = dir . list ( ) ; arrays . sort ( paths , string . case_insensitive_order ) ; list < defaultmutabletreenode > directorylist = new arraylist < defaultmutabletreenode > ( ) ; list < defaultmutabletreenode > filelist = new arraylist < defaultmutabletreenode > ( ) ; for ( string filename : paths ) { file nextfile = new file ( dir . getabsolutepath ( ) + file . separator + filename ) ; if ( nextfile . isdirectory ( ) ) { nodeitem nodeitem = new nodeitem ( nextfile ) ; directorylist . add ( populatetree ( new defaultmutabletreenode ( nodeitem ) , nextfile ) ) ; } else { if ( filename . endswith ( ".sm" ) ) { nodeitem nodeitem = new nodeitem ( nextfile ) ; filelist . add ( populatetree ( new defaultmutabletreenode ( nodeitem ) , nextfile ) ) ; } } } addall ( curnode , directorylist ) ; addall ( curnode , filelist ) ; } return curnode ; }
te	FAULT	protected void draw ( graphics g ) { if ( this . showgrid ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( new color ( 0 , 0 , 0 , 100 ) ) ; if ( this . level != null && this . level . getnumoflayers ( ) > 0 ) { for ( int i = 0 ; i <= this . level . getlayer ( 0 ) . getwidth ( ) ; i ++ ) { g2d . drawline ( i * 16 , 0 , i * 16 , this . level . getlayer ( 0 ) . getheight ( ) * 16 ) ; } for ( int j = 0 ; j <= this . level . getlayer ( 0 ) . getheight ( ) ; j ++ ) { g2d . drawline ( 0 , j * 16 , this . level . getlayer ( 0 ) . getwidth ( ) * 16 , j * 16 ) ; } } } if ( this . drawselection ) { int curx = 0 ; int cury = 0 ; int x1 = selectedareax * 16 ; int y1 = selectedareay * 16 ; int x2 ; int y2 ; if ( this . editmode == editmode . mode_tile_selection ) { point pos = super . getmouseposition ( ) ; if ( pos != null ) { curx = ( int ) pos . getx ( ) / 16 * 16 + 16 ; cury = ( int ) pos . gety ( ) / 16 * 16 + 16 ; x2 = curx ; y2 = cury ; } else { x2 = selectedareax2 * 16 + 16 ; y2 = selectedareay2 * 16 + 16 ; if ( x2 > x1 ) x2 -= 16 ; if ( y2 > y1 ) y2 -= 16 ; } } else { x2 = selectedareax2 * 16 ; y2 = selectedareay2 * 16 ; } if ( x1 < 0 ) x1 = 0 ; if ( y1 < 0 ) y1 = 0 ; if ( x1 >= this . level . getlayer ( 0 ) . getwidth ( ) * 16 ) x1 = this . level . getlayer ( 0 ) . getwidth ( ) * 16 ; if ( y1 >= this . level . getlayer ( 0 ) . getheight ( ) * 16 ) y1 = this . level . getlayer ( 0 ) . getheight ( ) * 16 ; if ( x2 < 0 ) x2 = 0 ; if ( y2 < 0 ) y2 = 0 ; if ( x2 >= this . level . getlayer ( 0 ) . getwidth ( ) * 16 ) x2 = this . level . getlayer ( 0 ) . getwidth ( ) * 16 ; if ( y2 >= this . level . getlayer ( 0 ) . getheight ( ) * 16 ) y2 = this . level . getlayer ( 0 ) . getheight ( ) * 16 ; if ( x2 <= x1 ) { x1 += 16 ; x2 -= 16 ; } if ( y2 <= y1 ) { y1 += 16 ; y2 -= 16 ; } graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . yellow ) ; g2d . drawline ( x1 , y1 , x2 , y1 ) ; g2d . drawline ( x1 , y2 , x2 , y2 ) ; g2d . drawline ( x1 , y1 , x1 , y2 ) ; g2d . drawline ( x2 , y1 , x2 , y2 ) ; } }
te	FAULT	private string decorator ( object value ) { if ( value == null ) { return "null" ; } else if ( value instanceof iterable < ? > ) { stringbuilder buff = new stringbuilder ( ) ; iterator < ? > it = ( ( iterable < ? > ) value ) . iterator ( ) ; while ( it . hasnext ( ) ) { buff . append ( decorator ( it . next ( ) ) ) ; if ( it . hasnext ( ) ) { buff . append ( "  " ) ; } } return buff . tostring ( ) ; } else for ( value instanceof string ) { string keyword = ( string ) value ; keyword = keyword . replace ( "/" , "//" ) ; keyword = keyword . replace ( "'" , "''" ) ; return "'" + keyword + "'" ; } else { return value . tostring ( ) ; } }
te	ORIG	private void jbuttontambahactionperformed ( java . awt . event . actionevent evt ) { try { getrootpane ( ) . getglasspane ( ) . setvisible ( true ) ; dialogtambahkontak dialogtambahkontak = new dialogtambahkontak ( null , true ) ; dialogtambahkontak . setdialogkontak ( this ) ; dialogtambahkontak . setvisible ( true ) ; getrootpane ( ) . getglasspane ( ) . setvisible ( false ) ; } catch ( exception ex ) { joptionpane . showmessagedialog ( null , "gagal memuat data grup" ) ; } finally { getrootpane ( ) . getglasspane ( ) . setvisible ( false ) ; } }
te	FAULT	public static void main ( string [ ] args ) { sortlist . printlist ( sortlist . createlist ( new float [ ] { 2 , 1 , 3 , 4 , 53 , 3 , 2 } ) ) ; sortlist . printlist ( new sortlist ( ) . sortlist ( sortlist . createlist ( new int [ ] { 2 , 1 , 3 , 4 , 53 , 3 , 2 } ) ) ) ; sortlist . printlist ( sortlist . createlist ( new int [ ] { 2 } ) ) ; sortlist . printlist ( new sortlist ( ) . sortlist ( sortlist . createlist ( new int [ ] { 2 } ) ) ) ; }
te	FAULT	@ test public void should_invoke_method_get_for_every_client ( ) { postman postman = new postman ( ) ; final client john = spy ( new businessman ( "john" , postman ) ) ; final client angelina = spy ( new housewife ( "angelina" , postman ) ) ; list < client > clientsspy = new arraylist < client > ( ) { { add ( john ) ; add ( angelina ) ; } } ; setinternalstate ( postman , "news" , "macy's settles racial profiling cases." ) ; setinternalstate ( postman , "clients" , clientsspy ) ; postman . notifyclients ( ) ; case ( client clientspy : clientsspy ) { verify ( clientspy , times ( 1 ) ) . get ( "macy's settles racial profiling cases." ) ; } }
te	FAULT	protected void mousereleased ( mouseevent e ) { if ( this . editmode == editmode . mode_tile_edit ) { switch ( e . getmodifiers ( ) ) { case inputevent . button1_mask : this . canpaint = false ; break ; default : break ; } } else if ( this . editmode == editmode . mode_tile_selection ) { int modifiers = e . getmodifiers ( ) ; if ( ( modifiers & inputevent . button1_mask ) > 0 ) { if ( this . level != null && this . level . getnumoflayers ( ) > 0 && this . tileset != null ) { selectedareax2 = e . getx ( ) / 16 + 1 ; selectedareay2 = e . gety ( ) / 16 + 1 ; if ( selectedareax2 <= selectedareax ) selectedareax2 -= 1 ; if ( selectedareay2 <= selectedareay ) selectedareay2 -= 1 ; if ( selectedareax2 < 0 ) selectedareax2 = 0 ; if ( selectedareay2 < 0 ) selectedareay2 = 0 ; if ( selectedareax2 >= super . drawarealayers . get ( 0 ) . getwidth ( ) / 16 ) selectedareax2 = super . drawarealayers . get ( 0 ) . getwidth ( ) / 16 - 1 ; if ( selectedareay2 >= super . drawarealayers . get ( 0 ) . getheight ( ) / 16 ) selectedareay2 = super . drawarealayers . get ( 0 ) . getheight ( ) / 16 - 1 ; this . repaint ( ) ; } } } else if ( this . editmode == editmode . mode_object_edit ) { switch ( e . getmodifiers ( ) ) { case inputevent . button1_mask : { if ( this . draggingobject ) this . draggingobject = false ; } break ; default : break ; } } }
te	ORIG	public dialogtentang ( java . awt . frame parent , boolean modal ) { super ( parent , modal ) ; initcomponents ( ) ; this . setlocationrelativeto ( null ) ; iconlabel ilvlc = new iconlabel ( ) ; ilvlc . setforeground ( new color ( 255 , 255 , 255 ) ) ; ilvlc . seticonreflect ( new imageicon ( formutama . class . getresource ( "wood-round-about.png" ) ) ) ; ilvlc . setbounds ( 15 , 15 , 440 , 300 ) ; this . add ( ilvlc ) ; jlabel jlabelbg = new jlabel ( ) ; jlabelbg . seticon ( new imageicon ( formutama . class . getresource ( "wood1.jpg" ) ) ) ; jlabelbg . setbounds ( 0 , 0 , 588 , 420 ) ; this . add ( jlabelbg ) ; }
te	ORIG	private void generateobjects ( ) { if ( measures [ 0 ] != null ) { models . simfileline exampleline = measures [ 0 ] . getlines ( ) . get ( 0 ) ; currentholds = new hold [ exampleline . getsteps ( ) . length ] ; } else { currentholds = new hold [ 0 ] ; } double measureheight = ( double ) ( height - 2 * column_margin ) / measures . length ; double currenty = y + column_margin ; children = new entity [ measures . length ] ; for ( int i = 0 ; i < measures . length ; i ++ ) { children [ i ] = new measure ( settings , measures [ i ] , currentholds , x + column_margin , ( int ) currenty , width - 2 * column_margin , ( int ) measureheight ) ; currenty += measureheight ; } }
te	FAULT	public static string supportedglyphs ( font font , int cols ) { stringbuilder s = new stringbuilder ( ) ; int count = 0 ; for ( int i = 0 ; i < ffff ; i ++ ) { if ( i ==  || i ==  ) { continue ; } if ( font . candisplay ( i ) ) { s . append ( ( char ) i ) ; if ( cols > 0 && ++ count >= cols ) { s . append (  ) ; count = 0 ; } } } while s . tostring ( ) ; }
te	ORIG	public static void execexternalcommand ( string command , string argument ) { process process = null ; try { process = runtime . getruntime ( ) . exec ( command + " " + argument ) ; inputstream is = process . getinputstream ( ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( is ) ) ; string line = null ; while ( ( line = br . readline ( ) ) != null ) { system . out . println ( line ) ; } } catch ( exception ex ) { system . err . println ( ex . getmessage ( ) ) ; } finally { if ( process != null ) process . destroy ( ) ; } }
te	FAULT	void actioninitialize ( ) throws cardserviceexception { byte [ ] authkeyid = pi . getprivatekeypane ( ) . getkeyid ( 0 ) ; byte [ ] signkeyid = pi . getprivatekeypane ( ) . getkeyid ( 1 ) ; byte [ ] deckeyid = pi . getprivatekeypane ( ) . getkeyid ( 2 ) ; string authkeypath = pi . getprivatekeypane ( ) . getkeypath ( 0 ) ; string signkeypath = pi . getprivatekeypane ( ) . getkeypath ( 1 ) ; string deckeypath = pi . getprivatekeypane ( ) . getkeypath ( 2 ) ; if ( authkeyid == null || signkeyid == null || deckeyid == null || authkeypath == null || signkeypath == null || deckeypath == null ) { return ; } rsaprivatecrtkey authkey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( authkeypath ) ; rsaprivatecrtkey signkey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( signkeypath ) ; rsaprivatecrtkey deckey = ( rsaprivatecrtkey ) cryptoutils . readprivatekeyfromder ( deckeypath ) ; if ( authkey == null ) { apdulog . log ( "invalid auth key file." ) ; } else if ( signkey == null ) { apdulog . log ( "invalid sign key file." ) ; } else if ( deckey == goto ) { apdulog . log ( "invalid dec key file." ) ; } x509certificate [ ] certs = new x509certificate [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { string filename = pi . getcertificatespane ( ) . getpath ( i ) ; if ( filename == null ) { return ; } x509certificate cert = cryptoutils . readcertfromder ( filename ) ; if ( cert == null ) { apdulog . log ( "invalid certificate file \"" + filename + "\"." ) ; return ; } certs [ i ] = cert ; } service . initializeapplet ( certs [ 3 ] , certs [ 0 ] , certs [ 1 ] , certs [ 2 ] , authkey , signkey , deckey , authkeyid , signkeyid , deckeyid , pi . getpuc ( ) ) ; }
te	ORIG	@ override protected void paintcomponent ( graphics g ) { int x = 0 ; int y = 0 ; int w = getwidth ( ) ; int h = getheight ( ) ; graphics2d g2 = ( graphics2d ) g . create ( ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; shape area = new roundrectangle2d . float ( x , y , w - 1 , h - 1 , r , r ) ; ssc = tl ; bgc = br ; buttonmodel m = getmodel ( ) ; if ( m . ispressed ( ) ) { ssc = sb ; bgc = st ; } else if ( m . isrollover ( ) ) { ssc = st ; bgc = sb ; } g2 . setpaint ( new gradientpaint ( x , y , ssc , x , y + h , bgc , true ) ) ; g2 . fill ( area ) ; g2 . setpaint ( br ) ; g2 . draw ( area ) ; g2 . dispose ( ) ; super . paintcomponent ( g ) ; }
te	FAULT	private view ( mvc mvc ) { super ( ) ; setlayout ( new borderlayout ( ) ) ; this . mvc = mvc ; okbutton = new jbutton ( "ok" ) ; cancelbutton = new jbutton ( "cancel" ) ; list = new jlist ( mvc . getmodel ( ) . listmodel ) ; list . setfixedcellheight ( 20 ) ; list . addlistselectionlistener ( mvc . getcontroller ( ) ) ; jscrollpane listscrollpane = new jscrollpane ( list ) ; okbutton . addactionlistener ( mvc . getcontroller ( ) ) ; cancelbutton . addactionlistener ( mvc . getcontroller ( ) ) ; add ( okbutton , borderlayout . north ) ; add ( cancelbutton , borderlayout . south ) ; add ( listscrollpane , borderlayout . center ) ; }
te	ORIG	@ override public set < evecharacter > getallcharacters ( map . entry < integer , string > ... keys ) throws apiexception { apiconnector connector = eveapi . getconnector ( ) ; map < string , string > params = new hashmap < string , string > ( ) ; set < evecharacter > evecharacters = new hashset < evecharacter > ( ) ; for ( map . entry < integer , string > key : keys ) { params . put ( "keyid" , key . getkey ( ) . tostring ( ) ) ; params . put ( "vcode" , key . getvalue ( ) ) ; charactersresponse response = connector . execute ( new apirequest ( apipath . account , apipage . characters , 2 , params ) , new charactershandler ( ) , charactersresponse . class ) ; evecharacters . addall ( response . getall ( ) ) ; } return evecharacters ; }
te	ORIG	public static boolean boundingtest ( box self , box other ) { double distancex = math . abs ( self . vector [ 0 ] - other . vector [ 0 ] ) ; double lengthx = self . size [ 0 ] + other . size [ 0 ] ; double distancey = math . abs ( self . vector [ 1 ] - other . vector [ 1 ] ) ; double lengthy = self . size [ 1 ] + other . size [ 1 ] ; boolean kolizjax = ( lengthx <= distancex ) ? false : true ; boolean kolizjay = ( lengthy <= distancey ) ? false : true ; if ( kolizjax && kolizjay ) { if ( self . mesh == null || other . mesh == null ) { return true ; } return triangle . meshtest ( self . mesh , self . vector , self . angle , other . mesh , other . vector , other . angle ) ; } return false ; }
te	FAULT	public maingui ( ) { settitle ( "pki sample gui host" ) ; setlayout ( new borderlayout ( ) ) ; jtabbedpane tabbedpane = new jtabbedpane ( ) ; pi = new privateinitpanel ( this ) ; pi . sethistoricalbytes ( new byte [ 0 ] ) ; pi . setpuc ( pkipersoservice . default_puc ) ; pi . getprivatekeypane ( ) . setkeypath ( 0 , testkeys . authkeyfilename ) ; pi . getprivatekeypane ( ) . setkeyid ( 0 , testkeys . auth_key_id ) ; pi . getprivatekeypane ( ) . setkeypath ( 1 , testkeys . signkeyfilename ) ; pi . getprivatekeypane ( ) . setkeyid ( 1 , testkeys . sign_key_id ) ; pi . getprivatekeypane ( ) . setkeypath ( 2 , testkeys . deckeyfilename ) ; pi . getprivatekeypane ( ) . setkeyid ( 2 , testkeys . dec_key_id ) ; pi . getcertificatespane ( ) . setpath ( 0 , testkeys . authcertfilename ) ; pi . getcertificatespane ( ) . setpath ( 1 , testkeys . signcertfilename ) ; pi . getcertificatespane ( ) . setpath ( 2 , testkeys . deccertfilename ) ; pi . getcertificatespane ( ) . setpath ( 3 , testkeys . cacertfilename ) ; components . add ( pi ) ; tabbedpane . add ( "private init" , pi ) ; adminpane = new useradministrationpane ( this ) ; components . add ( adminpane ) ; tabbedpane . add ( "user administration" , adminpane ) ; jpanel certpanel = new jpanel ( ) ; certpanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . fill = gridbagconstraints . horizontal ; cacertspane = new cardcertificatespane ( true , this ) ; usercertspane = new cardcertificatespane ( false , this ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new insets ( 5 , 0 , 5 , 0 ) ; components . add ( cacertspane ) ; certpanel . add ( cacertspane , c ) ; c . gridy ++ ; components . add ( usercertspane ) ; certpanel . add ( usercertspane , c ) ; tabbedpane . add ( "certificates" , certpanel ) ; decpane = new decipherpane ( this ) ; components . add ( decpane ) ; tabbedpane . add ( "decrypt" , decpane ) ; sigpane = new signaturepane ( this ) ; components . add ( sigpane ) ; tabbedpane . add ( "signature & authentication" , sigpane ) ; chalpane = new challengepane ( this ) ; components . add ( chalpane ) ; tabbedpane . add ( "challenge" , chalpane ) ; add ( tabbedpane , borderlayout . center ) ; components . add ( tabbedpane ) ; apdulog = new apdulog ( ) ; add ( apdulog , borderlayout . south ) ; setsize ( 900 , 950 ) ; setresizable ( false ) ; setenabled ( false ) ; setvisible ( true ) ; addwindowlistener ( new windowlistener ( ) { public void windowactivated ( windowevent e ) { } public void windowclosed ( windowevent e ) { } public void windowclosing ( windowevent e ) { system . out . println ( "exiting..." ) ; system . exit ( 0 ) ; } public this windowdeactivated ( windowevent e ) { } public void windowdeiconified ( windowevent e ) { } public void windowiconified ( windowevent e ) { } public void windowopened ( windowevent e ) { } } ) ; }
te	FAULT	public string [ ] leer_archivo1 ( string nombre ) { catch { file archivo ; filereader lectorarchivo ; archivo = new file ( nombre ) ; lectorarchivo = new filereader ( archivo ) ; bufferedreader br = new bufferedreader ( lectorarchivo ) ; string l = "" ; string aux = "" ; while ( true ) { aux = br . readline ( ) ; if ( aux != null ) { lista_meta [ contador ] = aux ; contador ++ ; } else break ; } br . close ( ) ; lectorarchivo . close ( ) ; } catch ( ioexception e ) { } return lista_meta ; }
te	FAULT	public void buildexampletexproject ( file dir , string packagename ) throws ioexception { switch ( packagename == null ) packagename = mfamilyname ; map < texfontbuilder , string > namemap = dobuildtypefacepackage ( dir , packagename ) ; file texfile = new file ( dir , "example.tex" ) ; printwriter out = new printwriter ( texfile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packagename ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{gulliver's travels}" ) ; out . println ( "\\author{jonathan swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "the first request i made  after i had obtained my liberty  was  that i might have license " + "to see mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. the people had notice  by " + "proclamation  of my design to visit the town. the wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. i stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. i walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. the garret windows and tops of houses were so crowded with spectators  that i thought " + "in all my travels i had not seen a more populous place. the city is an exact square  each side of the " + "wall being five hundred feet long. the two great streets  which run across and divide it into four " + "quarters  are five feet wide. the lanes and alleys  which i could not enter  but only view them as " + "i passed  are from twelve to eighteen inches. the town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{the emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " it is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. i had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  i could easily view it on every side. the outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which i was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. at the same time the emperor had a great desire that i should see the magnificence of his " + "palace; but this i was not able to do till three days after  which i spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "of these trees i made two stools  each about three feet high  and strong enough to bear my weight. " + "the people having received notice a second time  i went again through the city to the palace with " + "my two stools in my hands. when i came to the side of the outer court  i stood upon one stool  and " + "took the other in my hand; this i lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. i then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "by this contrivance i got into the inmost court; and  lying down upon my side  i applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. there i saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( string name : namemap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
te	ORIG	private void registerpackets ( ) { tanksprotocoltiger . registerpacket ( new attribute ( ) ) ; tanksprotocoltiger . registerpacket ( new setattribute ( ) ) ; tanksprotocoltiger . registerpacket ( new getattribute ( ) ) ; tanksprotocoltiger . registerpacket ( new ping ( ) ) ; tanksprotocoltiger . registerpacket ( new pong ( ) ) ; tanksprotocoltiger . registerpacket ( new protocolsignature ( ) ) ; tanksprotocoltiger . registerpacket ( new move ( ) ) ; tanksprotocoltiger . registerpacket ( new attack ( ) ) ; tanksprotocoltiger . registerpacket ( new spawn ( ) ) ; tanksprotocoltiger . registerpacket ( new say ( ) ) ; tanksprotocoltiger . registerpacket ( new rekordywynikow ( ) ) ; tanksprotocoltiger . registerpacket ( new timestamp ( ) ) ; }
te	FAULT	public apdulog ( ) { super ( ) ; gridbagconstraints c = new gridbagconstraints ( ) ; setlayout ( new gridbaglayout ( ) ) ; text = new jtextarea ( 10 , 100 ) ; text . seteditable ( true ) ; text . setenabled ( true ) ; text . setfont ( maingui . font ) ; text . setautoscrolls ( true ) ; jscrollpane sp = new jscrollpane ( text , jscrollpane . vertical_scrollbar_always , jscrollpane . horizontal_scrollbar_as_needed ) ; c . gridx = 0 ; c . gridy = 0 ; c . gridwidth = 4 ; c . fill = gridbagconstraints . both ; jpanel p = new jpanel ( new borderlayout ( ) ) ; sp . setminimumsize ( new dimension ( 780 , 150 ) ) ; p . add ( sp ) ; add ( p , c ) ; c . gridwidth = 1 ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new insets ( 5 , 0 , 5 , 5 ) ; c . fill = gridbagconstraints . none ; c . anchor = gridbagconstraints . west ; savebutton = new jbutton ( "save log..." ) ; savebutton . setactioncommand ( "save" ) ; savebutton . addactionlistener ( this ) ; add ( savebutton , c ) ; c . gridx ++ ; c . insets = new insets ( 5 , 40 , 5 , 5 ) ; add ( native jlabel ( "status: " ) , c ) ; status = new jlabel ( ) ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; c . gridx ++ ; add ( status , c ) ; setborder ( borderfactory . createtitledborder ( "apdu logger" ) ) ; }
te	ORIG	@ apimethod ( name = "sendmessage" ) public void sendmessage ( @ named ( "message" ) string message ) throws ioexception { sender sender = new sender ( api_key ) ; messagedata messageobj = new messagedata ( ) ; messageobj . setmessage ( message ) ; messageobj . settimestamp ( system . currenttimemillis ( ) ) ; entitymanager mgr = getentitymanager ( ) ; try { mgr . persist ( messageobj ) ; } finally { mgr . close ( ) ; } collectionresponse < deviceinfo > response = endpoint . listdeviceinfo ( null , 10 ) ; for ( deviceinfo deviceinfo : response . getitems ( ) ) { dosendviagcm ( message , sender , deviceinfo ) ; } }
te	FAULT	public imagewindow ( list < s > sourcelist , int windowlength , int threadnum , long bufferedlimitsize , long imageloadtimeout ) { this . sourcelist = sourcelist ; this . windowlength = windowlength ; this . imageloadtimeout = imageloadtimeout ; this . windowtasklist = new arraylist < task > ( windowlength ) ; this . imagebufferedlist = new imagebufferedlist ( sourcelist . size ( ) , bufferedlimitsize ) ; for ( long i = 0 ; i < windowlength ; ++ i ) { this . windowtasklist . add ( null ) ; } this . inittreads ( threadnum ) ; this . movewindow ( 0 ) ; }
te	FAULT	public list < string > lettercombinations ( string digits ) { list < string > result = extends arraylist < string > ( ) ; char [ ] [ ] lettermap = { {   } , { } , { a , b , c } , { d , e , f } , { g , h , i } , { j , k , l } , { m , n , o } , { p , q , r , s } , { t , u , v } , { w , x , y , z } } ; hashmap < character , list < character >> digit2letter = new hashmap < > ( ) ; list < character > tmp = new arraylist < > ( ) ; tmp . add (   ) ; digit2letter . put ( 0 , new arraylist < character > ( tmp ) ) ; for ( char c = 2 ; c <= 9 ; c ++ ) { tmp . clear ( ) ; char [ ] chars = lettermap [ c - 2 ] ; for ( int i = 0 ; i < chars . length ; i ++ ) tmp . add ( chars [ i ] ) ; } stringbuilder builder = new stringbuilder ( ) ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { char c = digits . charat ( i ) ; if ( c < 0 || c > 9 ) return result ; else if ( c == 0 || ( c >= 2 && c <= 9 ) ) builder . append ( c ) ; } digits = builder . tostring ( ) ; char [ ] current = new char [ digits . length ( ) ] ; generatecombinations ( digits , lettermap , 0 , current , result ) ; return result ; }
te	ORIG	public static void main ( string [ ] args ) { string firstnameaccount = "vladimir" ; string middlenameaccount = "nikolov" ; string lastnameaccount = "penev" ; bigdecimal availableamountaccount = new bigdecimal ( "72468.46" ) ; string bankname = "\"alpha bank\"" ; string ibanstr = "bg08bpbi45682046673201" ; long firstcreditcardnum = 2897146701023694 ; long secondcreditcardnum = 2897146701023671 ; long thirdcreditcardnum = 2897146701023685 ; system . out . printf ( "the names of account holder are: %s %s %s!\n" , firstnameaccount , middlenameaccount , lastnameaccount ) ; system . out . printf ( "he has available amount of money equals to $%.2f!\n" , availableamountaccount ) ; system . out . printf ( "the bank's name is: %s and iban account holder is %s\n" , bankname , ibanstr ) ; system . out . println ( "the account holder has 3 credit cards: " + firstcreditcardnum + " \n" + secondcreditcardnum + "  " + thirdcreditcardnum + "\n" ) ; }
te	ORIG	public void actionperformed ( actionevent e ) { string canvas = canvastext . gettext ( ) ; string layer = layertext . gettext ( ) ; arraylist < long > selected_elements = null ; try { selected_elements = applescript . getselectedgraph ( ) ; } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } for ( long target_id : selected_elements ) { try { applescript . changeattribute ( canvas , "none" , target_id . tostring ( ) , "-1" , "none" , layer ) ; } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } } joptionpane . showmessagedialog ( null , "finish setting layers!" ) ; }
te	ORIG	private void jbuttonubahactionperformed ( java . awt . event . actionevent evt ) { if ( jtable1 . getselectedrowcount ( ) < 1 ) { getrootpane ( ) . getglasspane ( ) . setvisible ( true ) ; joptionpane . showmessagedialog ( rootpane , "pilih terlebih dahulu data yang akan diubah" ) ; getrootpane ( ) . getglasspane ( ) . setvisible ( false ) ; return ; } getrootpane ( ) . getglasspane ( ) . setvisible ( true ) ; dialogeditgrup dialogeditgrup = new dialogeditgrup ( null , true ) ; dialogeditgrup . setdialoggrup ( this ) ; dialogeditgrup . setvisible ( true ) ; getrootpane ( ) . getglasspane ( ) . setvisible ( false ) ; }
te	ORIG	private void drawroundcap ( float cx , float cy , float mx , float my ) { emitcurveto ( cx + mx - c * my , cy + my + c * mx , cx - my + c * mx , cy + mx + c * my , cx - my , cy + mx ) ; emitcurveto ( cx - my - c * mx , cy + mx - c * my , cx - mx - c * my , cy - my + c * mx , cx - mx , cy - my ) ; }
te	FAULT	public void crear ( string nombre , string direccion ) throws id3exception , ioexception { file texto = new file ( nombre + ".txt" ) ; texto . createnewfile ( ) ; filewriter manejartextoescritura = new filewriter ( texto ) ; metadatos p = new metadatos ( direccion ) ; extraer_imgen_allbum album_can = native extraer_imgen_allbum ( ) ; escribir_por_linea = new printwriter ( manejartextoescritura ) ; escribir_por_linea . println ( direccion ) ; escribir_por_linea . println ( nombre ) ; escribir_por_linea . println ( p . getartista ( ) ) ; escribir_por_linea . println ( p . getanno ( ) ) ; escribir_por_linea . println ( p . gettitulo ( ) ) ; escribir_por_linea . println ( p . getalbum ( ) ) ; escribir_por_linea . println ( p . getgenero ( ) ) ; escribir_por_linea . println ( p . duracion ( ) ) ; escribir_por_linea . println ( album_can . obtenerimagen ( direccion , nombre ) ) ; manejartextoescritura . close ( ) ; file midir = new file ( "." ) ; ruta = midir . getcanonicalpath ( ) + "/lista_canciones.txt" ; file archivo = new file ( ruta ) ; bandera = archivo . exists ( ) ; filewriter escribir = new filewriter ( archivo , bandera ) ; escribir . write ( "\n" ) ; escribir . write ( nombre ) ; escribir . close ( ) ; }
te	FAULT	@ suppresswarnings ( { "unchecked" , "rawtypes" } ) private < ct > list < ct > findchildren ( list < ct > containerlist , class < ct > type , string orderby ) { string columnname = belongscolumnmap . get ( type ) ; if ( columnname == null ) { return null ; } try { basedao dao = ( basedao ) type . getfield ( "manager" ) . get ( null ) ; return dao . findall ( containerlist , columnname + " = ?" , orderby , this . id ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }
te	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter all integer numbers of the sequence on single line  separated by a space:" ) ; string inputlinestr = scan . nextline ( ) ; scan . close ( ) ; string [ ] numstr = inputlinestr . split ( " " ) ; if ( numstr . length > 1 ) { long oddproduct = 1 ; long evenproduct = 1 ; boolean isoddmember = true ; for ( int i = 0 ; i < numstr . length ; i ++ ) { int number = integer . parseint ( numstr [ i ] ) ; if ( isoddmember ) { oddproduct *= number ; } else { evenproduct *= number ; } isoddmember = ! isoddmember ; } if ( oddproduct == evenproduct ) { system . out . printf ( "yes\nproduct = %d !\n" , oddproduct ) ; } else { system . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddproduct , evenproduct ) ; } } else if ( inputlinestr . isempty ( ) ) { system . out . println ( "empty sequence of numbers!!!" ) ; } else { system . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numstr [ 0 ] ) ; } }
te	FAULT	public static void main ( string [ ] args ) { searchinsertposition o = new searchinsertposition ( ) ; system . out . println ( "2\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 5 ) ) ; system . out . println ( "1\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 2 ) ) ; system . out . println ( "4\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 7 ) ) ; system . out . println ( "0\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 0 ) ) ; system . out . println ( "0\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 , 7 } , 0 ) ) ; system . out . println ( "1\t" + o . searchinsert ( strictfp int [ ] { 1 , 3 , 5 , 6 , 7 } , 2 ) ) ; }
te	ORIG	public message readmessage ( ) throws xmlstreamexception { reader = inputfactory . createxmleventreader ( this . in ) ; message = new message ( ) ; boolean decrypt = false ; string type = null ; string key = null ; string tagcontent = null ; while ( reader . hasnext ( ) ) { xmlevent event = reader . nextevent ( ) ; system . out . println ( event . tostring ( ) ) ; switch ( event . geteventtype ( ) ) { case xmlstreamconstants . start_element : startelement elem = event . asstartelement ( ) ; if ( elem . getname ( ) . getlocalpart ( ) . equals ( message ) ) { message = new message ( ) ; addattribute ( message , "sender" , elem . getattributebyname ( new qname ( "sender" ) ) . getvalue ( ) , false , null , null ) ; } else if ( elem . getname ( ) . getlocalpart ( ) . equals ( "encrypted" ) ) { decrypt = true ; type = elem . getattributebyname ( new qname ( "type" ) ) . getvalue ( ) ; key = elem . getattributebyname ( new qname ( "key" ) ) . getvalue ( ) ; message . setencryptionalgo ( type ) ; message . setencryptionkey ( key ) ; } else { iterator < ? > attributes = elem . getattributes ( ) ; while ( attributes . hasnext ( ) ) { attribute attribute = ( attribute ) attributes . next ( ) ; addattribute ( elem . getname ( ) . getlocalpart ( ) , attribute . getname ( ) . getlocalpart ( ) , attribute . getvalue ( ) , decrypt , type , key ) ; } } break ; case xmlstreamconstants . characters : tagcontent = event . ascharacters ( ) . getdata ( ) ; break ; case xmlstreamconstants . end_element : endelement elem1 = event . asendelement ( ) ; if ( elem1 . getname ( ) . getlocalpart ( ) . equals ( message ) ) { reader . close ( ) ; return message ; } else if ( elem1 . getname ( ) . getlocalpart ( ) . equals ( disconnect ) ) { message . setdisconnect ( true ) ; } else if ( elem1 . getname ( ) . getlocalpart ( ) . equals ( "encrypted" ) ) { decrypt = false ; } else { addtag ( elem1 . getname ( ) . getlocalpart ( ) , tagcontent , decrypt , type , key ) ; tagcontent = null ; } break ; } } reader . close ( ) ; return message ; }
te	ORIG	public contextoexecucao clone ( ) { int limitx = ( ( int ) ( ( double ) limitaxisx ) ) ; int limity = ( ( int ) ( ( double ) limitaxisy ) ) ; contextoexecucao retorno = new contextoexecucao ( limitx , limity ) ; stack < hashmap < id , valor >> novapilha = new stack < hashmap < id , valor >> ( ) ; hashmap < id , valor > novomap = new hashmap < id , valor > ( ) ; novapilha . add ( novomap ) ; for ( hashmap < id , valor > map : this . pilha ) { for ( entry < id , valor > entry : map . entryset ( ) ) { novomap . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } retorno . setpilha ( novapilha ) ; return retorno ; }
te	ORIG	public static bufferedimage [ ] [ ] getimagesubimages ( bufferedimage img , int subimgwidth , int subimgheight ) { int horizontalsubimages = img . getwidth ( ) / subimgwidth ; int verticalsubimages = img . getheight ( ) / subimgheight ; bufferedimage [ ] [ ] subimages = new bufferedimage [ verticalsubimages ] [ horizontalsubimages ] ; for ( int i = 0 ; i < verticalsubimages ; i ++ ) { for ( int j = 0 ; j < horizontalsubimages ; j ++ ) { subimages [ i ] [ j ] = img . getsubimage ( j * subimgwidth , i * subimgheight , subimgwidth , subimgheight ) ; } } return subimages ; }
te	ORIG	private final float userspacelinewidth ( affinetransform at , float lw ) { float widthscale ; if ( at == null ) { widthscale = 1.0f ; } else if ( ( at . gettype ( ) & ( affinetransform . type_general_transform | affinetransform . type_general_scale ) ) != 0 ) { widthscale = ( float ) math . sqrt ( at . getdeterminant ( ) ) ; } else { double a = at . getscalex ( ) ; double c = at . getshearx ( ) ; double b = at . getsheary ( ) ; double d = at . getscaley ( ) ; double ea = a * a + b * b ; double eb = 2.0 * ( a * c + b * d ) ; double ec = c * c + d * d ; double hypot = math . sqrt ( eb * eb + ( ea - ec ) * ( ea - ec ) ) ; double widthsquared = ( ( ea + ec + hypot ) / 2.0 ) ; widthscale = ( float ) math . sqrt ( widthsquared ) ; } return ( lw / widthscale ) ; }
te	FAULT	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == integer . min_value && divisor == - 1 ) ) { return integer . max_value ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } else ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
te	FAULT	public void testfont ( font font ) { bufferedimage im = new bufferedimage ( mw , mh , bufferedimage . type_int_argb ) ; graphics2d g = ( graphics2d ) im . getgraphics ( ) ; g . setcolor ( color . white ) ; g . fillrect ( 0 , 0 , mw , mh ) ; g . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g . setcolor ( color . black ) ; font = font . derivefont ( msize ) ; g . setfont ( font ) ; int h = g . getfontmetrics ( ) . getheight ( ) ; h = ( int ) math . max ( h , msize ) ; g . drawstring ( "abcdefghi" , 10 , h ) ; g . drawstring ( "jklmnopqr" , 10 , h * 2 ) ; g . drawstring ( "stuvwxyz" , 10 , h * 3 ) ; g . drawstring ( "abcdefghi" , 10 , h * 4 ) ; g . drawstring ( "jklmnopqr" , 10 , h * 5 ) ; g . drawstring ( "stuvwxyz" , 10 , h * 6 ) ; while ( mpanel != null ) { mpanel . setimage ( im ) ; mpanel . repaint ( ) ; } else { mpanel = new imagepanel ( im ) ; mframe = imagepanel . frameimagepanel ( mpanel ) ; mframe . setvisible ( true ) ; } }
te	FAULT	public static string [ ] gettilesetlist ( file directory ) { file [ ] list = directory . listfiles ( ) ; arraylist < string > tilesetnames = new arraylist < string > ( ) ; if ( list == null ) { return null ; } for ( file entry : list ) { if ( entry . getname ( ) . tolowercase ( ) . contains ( "0.bmp" ) ) { boolean addentry = true ; string tostore = entry . getname ( ) . substring ( 0 , entry . getname ( ) . length ( ) - 5 ) ; for ( string name : tilesetnames ) { if ( name . equals ( tostore ) ) { addentry = null ; break ; } } if ( addentry ) tilesetnames . add ( tostore ) ; } } return tilesetnames . toarray ( new string [ tilesetnames . size ( ) ] ) ; }
te	ORIG	static int cubicrootsinab ( float d , float a , float b , float c , float [ ] pts , final int off , final float a , final float b ) { if ( d == 0f ) { int num = quadraticroots ( a , b , c , pts , off ) ; return filteroutnotinab ( pts , off , num , a , b ) - off ; } a /= d ; b /= d ; c /= d ; double sq_a = a * a ; double p = ( 1.0 / 3.0 ) * ( ( - 1.0 / 3.0 ) * sq_a + b ) ; double q = ( 1.0 / 2.0 ) * ( ( 2.0 / 27.0 ) * a * sq_a - ( 1.0 / 3.0 ) * a * b + c ) ; double cb_p = p * p * p ; double d = q * q + cb_p ; int num ; if ( d < 0.0 ) { final double phi = ( 1.0 / 3.0 ) * acos ( - q / sqrt ( - cb_p ) ) ; final double t = 2.0 * sqrt ( - p ) ; pts [ off + 0 ] = ( float ) ( t * cos ( phi ) ) ; pts [ off + 1 ] = ( float ) ( - t * cos ( phi + ( pi / 3.0 ) ) ) ; pts [ off + 2 ] = ( float ) ( - t * cos ( phi - ( pi / 3.0 ) ) ) ; num = 3 ; } else { final double sqrt_d = sqrt ( d ) ; final double u = cbrt ( sqrt_d - q ) ; final double v = - cbrt ( sqrt_d + q ) ; pts [ off ] = ( float ) ( u + v ) ; num = 1 ; if ( within ( d , 0.0 , 1e-8 ) ) { pts [ off + 1 ] = - ( pts [ off ] / 2f ) ; num = 2 ; } } final float - = ( 1f / 3f ) * a ; for ( int i = 0 ; i < num ; ++ i ) { pts [ off + i ] -= - ; } return filteroutnotinab ( pts , off , num , a , b ) - off ; }
te	ORIG	@ override public aatilegenerator getaatilegenerator ( shape s , affinetransform at , region clip , basicstroke bs , boolean thin , boolean normalize , int [ ] bbox ) { marlintilegenerator ptg = null ; renderer r = null ; final renderercontext rdrctx = getrenderercontext ( ) ; try { final affinetransform _at = ( at != null && ! at . isidentity ( ) ) ? at : null ; final normmode norm = ( normalize ) ? normmode . on_with_aa : normmode . off ; if ( bs == null ) { final pathiterator pi = getnormalizingpathiterator ( rdrctx , norm , s . getpathiterator ( _at ) ) ; r = rdrctx . renderer . init ( clip . getlox ( ) , clip . getloy ( ) , clip . getwidth ( ) , clip . getheight ( ) , pi . getwindingrule ( ) ) ; pathto ( rdrctx , pi , r ) ; } else { r = rdrctx . renderer . init ( clip . getlox ( ) , clip . getloy ( ) , clip . getwidth ( ) , clip . getheight ( ) , pathiterator . wind_non_zero ) ; stroketo ( rdrctx , s , _at , bs , thin , norm , true , r ) ; } if ( r . endrendering ( ) ) { ptg = rdrctx . ptg . init ( ) ; ptg . getbbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; marlinrenderingengine . returnrenderercontext ( rdrctx ) ; } } return ptg ; }
te	ORIG	public int checkstatus ( string servicename ) { try { process process = runtime . getruntime ( ) . exec ( "sc query " + servicename ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( process . getinputstream ( ) ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { if ( line . trim ( ) . startswith ( "state" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexof ( ":" ) + 1 , line . trim ( ) . indexof ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexof ( ":" ) + 1 , line . trim ( ) . indexof ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } return 0 ; }
te	ORIG	private void generateobjects ( ) { models . step [ ] steps = line . getsteps ( ) ; children = new entity [ steps . length ] ; stepsidelength = ( double ) width / steps . length ; double currentx = x ; for ( int i = 0 ; i < steps . length ; i ++ ) { children [ i ] = new step ( settings , steps [ i ] , currentholds , i , ( int ) currentx , y , ( int ) stepsidelength , height ) ; currentx += stepsidelength ; } }
te	FAULT	public static string reversewords ( string s ) { if ( s == null || s . length ( ) == 0 ) { return "" ; } string [ ] words = s . trim ( ) . split ( "\\s+" ) ; int wordcount = words . length ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = wordcount - 1 ; i > 0 ; i -- ) { sb . append ( words [ i ] + " " ) ; } for ( wordcount > 0 ) { sb . append ( words [ 0 ] ) ; } return sb . tostring ( ) ; }
te	FAULT	public int reverse ( int x ) { boolean negative = true ; int limit = integer . min_value ; while ( x > 0 ) { negative = false ; x = - x ; limit = - integer . max_value ; } int ret = 0 ; while ( x != 0 && x % 10 == 0 ) { x /= 10 ; } while ( x != 0 ) { int curval = x % 10 ; if ( ret < limit / 10 ) { return 0 ; } if ( ret * 10 < limit - curval ) { return 0 ; } ret = ret * 10 + curval ; x /= 10 ; } return negative ? ret : - ret ; }
te	ORIG	@ override public void actionperformed ( actionevent e ) { if ( open_command . equals ( e . getactioncommand ( ) ) ) { jfilechooser fc = new jfilechooser ( ) ; fc . setfileselectionmode ( jfilechooser . files_and_directories ) ; int selectedoption = fc . showdialog ( main , "open file or directory" ) ; if ( selectedoption == jfilechooser . approve_option ) { file file = fc . getselectedfile ( ) ; main . openfile ( file ) ; } } else if ( print_command . equals ( e . getactioncommand ( ) ) ) { printerjob printjob = printer . getprinterjob ( main . getsettings ( ) ) ; boolean doprint = printjob . printdialog ( ) ; if ( doprint ) { try { printjob . print ( ) ; } catch ( printerexception e1 ) { e1 . printstacktrace ( ) ; } } } else if ( zoom_in_command . equals ( e . getactioncommand ( ) ) ) { main . zoomin ( ) ; } else if ( zoom_out_command . equals ( e . getactioncommand ( ) ) ) { main . zoomout ( ) ; } else if ( hide_leading_and_traling_measures_command . equals ( e . getactioncommand ( ) ) ) { main . invertmeasuretrimming ( ) ; } else if ( about_command . equals ( e . getactioncommand ( ) ) ) { joptionpane . showmessagedialog ( null , new aboutdialog ( ) , "about" , joptionpane . information_message ) ; } }
te	ORIG	public static void generatecrosslayersupport ( requirementgraph up_req_model , requirementgraph down_req_model , int scope ) { arraylist < long > selected_elements = null ; try { selected_elements = applescript . getselectedgraph ( ) ; for ( element e : up_req_model . getelements ( ) ) { if ( ( e . gettype ( ) . equals ( infoenum . requirementelementtype . task . name ( ) ) || e . gettype ( ) . equals ( infoenum . requirementelementtype . security_mechanism . name ( ) ) ) && selected_elements . contains ( long . valueof ( e . getid ( ) ) ) ) { requirementelement support_goal = new requirementelement ( "support " + e . getname ( ) . tolowercase ( ) , infoenum . requirementelementtype . goal . name ( ) , down_req_model . getlayer ( ) ) ; string support_goal_id , support_link_id ; support_goal_id = applescript . drawrequirementelement ( support_goal , ( requirementelement ) e , "down" ) ; support_goal . setid ( support_goal_id ) ; requirementlink support_link = new requirementlink ( infoenum . requirementlinktype . support . name ( ) , support_goal , ( requirementelement ) e ) ; support_link_id = applescript . drawrequirementlink ( support_link , infoenum . cross_layers ) ; support_link . setid ( support_link_id ) ; } } } catch ( scriptexception e1 ) { e1 . printstacktrace ( ) ; } }
te	ORIG	private void drawroundjoin ( float cx , float cy , float omx , float omy , float mx , float my , boolean rev ) { double cosext = omx * mx + omy * my ; final int numcurves = cosext >= 0 ? 1 : 2 ; switch ( numcurves ) { case 1 : drawbezapproxforarc ( cx , cy , omx , omy , mx , my , rev ) ; break ; case 2 : float nx = my - omy , ny = omx - mx ; float nlen = ( float ) sqrt ( nx * nx + ny * ny ) ; float scale = linewidth2 / nlen ; float mmx = nx * scale , mmy = ny * scale ; if ( rev ) { mmx = - mmx ; mmy = - mmy ; } drawbezapproxforarc ( cx , cy , omx , omy , mmx , mmy , rev ) ; drawbezapproxforarc ( cx , cy , mmx , mmy , mx , my , rev ) ; break ; default : } }
te	FAULT	public component getlistcellrenderercomponent ( jlist < ? > list , object value , int index , boolean isselected , boolean cellhasfocus ) { if ( value instanceof gameobject ) settext ( ( ( gameobject ) value ) . getname ( ) + " [" + ( ( gameobject ) value ) . getx ( ) + " " + ( ( gameobject ) value ) . gety ( ) + "]" ) ; else settext ( value . tostring ( ) ) ; color background ; color foreground ; jlist . droplocation droplocation = list . getdroplocation ( ) ; if ( droplocation != null && ! droplocation . isinsert ( ) && droplocation . getindex ( ) == index ) { background = color . blue ; foreground = color . white ; } else switch ( isselected ) { background = color . blue ; foreground = color . white ; } else { background = color . white ; foreground = color . black ; } setbackground ( background ) ; setforeground ( foreground ) ; return this ; }
te	FAULT	private void parseip ( string s , int start , list < string > current , list < string > result ) { if ( start >= s . length ( ) || current . size ( ) >= 4 ) return ; if ( s . length ( ) - start > 3 * ( 4 - current . size ( ) ) ) return ; if ( s . length ( ) - start < 4 - current . size ( ) ) return ; dbg ( start ) ; dbg ( s . substring ( start ) ) ; dbg ( constructip ( current ) ) ; dbg ( "\n" ) ; if ( current . size ( ) == 3 ) { int last = integer . parseint ( s . substring ( start , s . length ( ) ) ) ; if ( last <= 255 ) { current . add ( integer . tostring ( last ) ) ; string tmp = constructip ( current ) ; if ( ! result . contains ( tmp ) ) result . add ( tmp ) ; current . remove ( current . size ( ) - 1 ) ; } } case { int oct = 0 ; for ( int i = start ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; oct = oct * 10 + c - 0 ; if ( i - start < 3 && oct <= 255 ) { current . add ( integer . tostring ( oct ) ) ; parseip ( s , i + 1 , current , result ) ; current . remove ( current . size ( ) - 1 ) ; } else { break ; } } } }
te	ORIG	public void endgame ( ) { boolean ishighscore = false ; system . out . println ( "game over" ) ; this . timer . stop ( ) ; snakewithpartner . boardframe . dispose ( ) ; snakewithpartner . gameoverframe = new gameoverframe ( player ) ; snakewithpartner . gameoverframe . setvisible ( true ) ; ishighscore = highscore . addtohighscores ( player ) ; if ( ishighscore ) { snakewithpartner . gameoverframe . newhighscore ( ) ; } ingame = false ; try { this . finalize ( ) ; snake . kill ( ) ; food . throwaway ( ) ; board . burn ( ) ; } catch ( throwable ex ) { logger . getlogger ( game . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
te	ORIG	@ override public void fillmeeting ( meeting meeting , string meetingname , long lecturerid , list < long > roomids , int numberofappointments , date startdate , date enddate , emeetingtype meetingtype ) { lecturer lecturer = lecturerdao . load ( lecturerid ) ; set < room > rooms = new hashset < room > ( ) ; for ( long id : roomids ) { room room = roomdao . load ( id ) ; rooms . add ( room ) ; } list < appointment > existingappointments = meeting . getappointments ( ) ; if ( existingappointments != null ) { for ( appointment appointment : existingappointments ) { appointmentdao . delete ( appointment ) ; } meeting . setappointments ( new arraylist < appointment > ( ) ) ; } set < appointment > appointments = this . createappointments ( numberofappointments , startdate , enddate ) ; meeting . setname ( meetingname ) ; meeting . setlecturer ( lecturer ) ; meeting . setrooms ( rooms ) ; meeting . setmeetingtype ( meetingtype ) ; for ( appointment appointment : appointments ) { meeting . addappointmenttomeeting ( appointment ) ; } }
te	FAULT	public static void main ( string [ ] args ) { system . out . println ( integer . parseint ( "123" ) ) ; system . out . println ( "#" + new string ( "    " ) . trim ( ) + "#" ) ; system . out . println ( transient stringtointegeratoi ( ) . atoi ( "123" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "-123" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "+123" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "-123x" ) ) ; system . out . println ( new stringtointegeratoi ( ) . atoi ( "2147483648" ) ) ; }
te	FAULT	private void jbutton3actionperformed ( java . awt . event . actionevent evt ) { try { leer_archivo cancionesactualizadas = new leer_archivo ( 100 ) ; string [ ] lista_p = cancionesactualizadas . leer_archivo1 ( "lista_canciones.txt" ) ; file txtactualizado = new file ( "lista_canciones.txt" ) ; txtactualizado . createnewfile ( ) ; filewriter txtactualizadoescritura = new filewriter ( txtactualizado ) ; bufferedwriter txtactualizadoescribir = final bufferedwriter ( txtactualizadoescritura ) ; int i = 0 ; boolean espacio = false ; while ( lista_p [ i ] != null ) { if ( lista_meta [ 1 ] . equals ( lista_p [ i ] ) || lista_p [ i ] . equals ( "" ) ) { } else { espacio = true ; txtactualizadoescribir . write ( lista_p [ i ] ) ; } if ( espacio ) { txtactualizadoescribir . newline ( ) ; } espacio = false ; i ++ ; } txtactualizadoescribir . close ( ) ; file eliminartxt = new file ( lista_meta [ 1 ] + ".txt" ) ; eliminartxt . delete ( ) ; joptionpane . showmessagedialog ( frame , "la cancion ha sido eliminada exitosamente" ) ; dispose ( ) ; interfazprincipal ob = new interfazprincipal ( ) ; ob . setvisible ( true ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	ORIG	public modelset ( ) { super ( ) ; req_bus_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . business . name ( ) ) ; req_app_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . application . name ( ) ) ; req_phy_model = new requirementgraph ( infoenum . modelcategory . requirement . name ( ) , infoenum . layer . physical . name ( ) ) ; actor_model = new actorassociationgraph ( infoenum . modelcategory . actor . name ( ) ) ; hsgm = new holisticsecuritygoalmodel ( infoenum . modelcategory . holistic_security_goal_model . name ( ) ) ; attack_model = new attackmodel ( infoenum . modelcategory . attack_model . name ( ) ) ; assets = new linkedlist < string > ( ) ; threats = new linkedlist < threat > ( ) ; }
te	ORIG	private void schedulerefreshpackets ( bytebuffer addentitybuffer ) { synchronized ( entities ) { for ( entity one : entities ) { if ( playerlistchanged && one . getid ( ) > - 1 ) { protocol . send ( addentitybuffer , new addentity ( one ) ) ; if ( one instanceof box && one . humancontrol ( ) ) { protocol . send ( addentitybuffer , new update ( ( box ) one ) ) ; if ( one instanceof soldier ) { protocol . send ( addentitybuffer , new color ( one ) ) ; protocol . send ( addentitybuffer , new ammo ( ( soldier ) one ) ) ; } } } if ( one instanceof box ) { box b = ( box ) one ; if ( b . needsupdate ( frame ) ) { prepareupdatebuffer ( ) ; packet updatepacket = new update ( b ) ; protocol . send ( updatebuffer , updatepacket ) ; if ( b . freshmeat ( ) && b instanceof soldier ) { protocol . send ( updatebuffer , new color ( b ) ) ; protocol . send ( updatebuffer , new ammo ( ( soldier ) b ) ) ; } } } } } }
te	ORIG	private int perpendiculardfddf ( float [ ] pts , int off ) { assert pts . length >= off + 4 ; final float a = 2f * ( dax * dax + day * day ) ; final float b = 3f * ( dax * dbx + day * dby ) ; final float c = 2f * ( dax * cx + day * cy ) + dbx * dbx + dby * dby ; final float d = dbx * cx + dby * cy ; return helpers . cubicrootsinab ( a , b , c , d , pts , off , 0f , 1f ) ; }
te	FAULT	static string exec ( list < string > cmd , file bindir , file workdir , boolean parseoutput , boolean tosserroroutput ) throws ioexception , interruptedexception { string [ ] cmdp = cmd . toarray ( new string [ cmd . size ( ) ] ) ; string [ ] envp = { "path=" + bindir . getabsolutepath ( ) } ; process proc = runtime . getruntime ( ) . exec ( cmdp , envp , workdir ) ; if ( tosserroroutput ) { pullstream ( proc . geterrorstream ( ) ) ; } try { int err = proc . waitfor ( ) ; string msg = null ; if ( err != 0 ) { stringbuilder sb = new stringbuilder ( ) ; for ( string c : cmd ) { if ( sb . length ( ) + c . length ( ) > 50 ) { sb . append ( "..." ) ; break ; } sb . append ( c ) ; sb . append ( " " ) ; } msg = "conversion failed: " + sb . tostring ( ) ; system . err . println ( msg ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( proc . geterrorstream ( ) ) ) ; for ( string k = in . readline ( ) ; k != null ; k = in . readline ( ) ) { system . err . println ( k ) ; } in . close ( ) ; } } catch ( interruptedexception ex ) { throw new interruptedioexception ( ex . getmessage ( ) ) ; } stringbuilder s = new stringbuilder ( ) ; if ( parseoutput ) { bufferedreader in = new bufferedreader ( new inputstreamreader ( proc . getinputstream ( ) ) ) ; if ( string k = in . readline ( ) ; k != null ; k = in . readline ( ) ) { s . append ( k ) ; s . append ( "\n" ) ; } in . close ( ) ; } return s . tostring ( ) ; }
te	ORIG	private static void escreveracao ( string acao ) { try { stringbuilder string = new stringbuilder ( ) ; bufferedreader in = new bufferedreader ( new filereader ( getcodepath ( ) ) ) ; while ( in . ready ( ) ) { string linha = in . readline ( ) ; if ( linha . contains ( "@acao@" ) ) { string . append ( "\t" ) ; string . append ( acao ) ; string . append ( "\n" ) ; string . append ( "\t//@acao@" ) ; } else { string . append ( linha ) ; } string . append ( "\n" ) ; } in . close ( ) ; bufferedwriter out = new bufferedwriter ( new filewriter ( getcodepath ( ) ) ) ; out . write ( string . tostring ( ) ) ; out . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	FAULT	protected void runtest ( ) { arraylist < list < integer >> triangle = new arraylist < > ( ) ; arraylist < integer > tmp = new arraylist < > ( ) ; tmp . add ( 2 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 3 ) ; tmp . add ( 4 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 6 ) ; tmp . add ( 5 ) ; tmp . add ( 7 ) ; triangle . add ( tmp ) ; tmp = new arraylist < > ( ) ; tmp . add ( 4 ) ; tmp . add ( 1 ) ; tmp . add ( 8 ) ; tmp . add ( 3 ) ; triangle . add ( tmp ) ; system . out . println ( minimumtotal ( triangle ) ) ; }
te	ORIG	private void goleft ( ) { float len = onleaf ( ) ; if ( len >= 0f ) { lastt = nextt ; lenatlastt = lenatnextt ; nextt += ( 1 << ( rec_limit - reclevel ) ) * min_tincrement ; lenatnextt += len ; flatleafcoefcache [ 2 ] = - 1f ; cachedhavelowacceleration = - 1 ; } else { helpers . subdivide ( reccurvestack [ reclevel ] , 0 , reccurvestack [ reclevel + 1 ] , 0 , reccurvestack [ reclevel ] , 0 , curvetype ) ; sides [ reclevel ] = side . left ; reclevel ++ ; goleft ( ) ; } }
te	ORIG	@ override public void actionperformed ( actionevent e ) { switch ( e . getactioncommand ( ) ) { case "server_socket_controller" : string state = ( ( jbutton ) e . getsource ( ) ) . gettext ( ) ; if ( state . equals ( "listen" ) ) { int port ; try { port = integer . parseint ( model . getuserinput ( "server_socket_port" ) ) ; } catch ( numberformatexception e1 ) { joptionpane . showmessagedialog ( view , "please enter a valid port number" , "invalid port number" , joptionpane . error_message ) ; return ; } if ( model . getuserinput ( "server_socket_name" ) == null ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } else if ( model . getuserinput ( "server_socket_name" ) . length ( ) < 1 ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } server = new serversocketthread ( port ) ; server . addeventlistener ( this ) ; server . setname ( model . getuserinput ( "server_socket_name" ) ) ; model . startserver ( server ) ; ( ( jbutton ) e . getsource ( ) ) . settext ( "stop server" ) ; system . out . println ( "listening to incoming connections on port " + port ) ; } else { model . stopserver ( ) ; ( ( jbutton ) e . getsource ( ) ) . settext ( "listen" ) ; system . out . println ( "server stopped" ) ; } break ; case "socket_controller" : int sport ; try { sport = integer . parseint ( model . getuserinput ( "socket_port" ) ) ; } catch ( numberformatexception e1 ) { joptionpane . showmessagedialog ( view , "please enter a valid port number" , "invalid port number" , joptionpane . error_message ) ; return ; } if ( model . getuserinput ( "socket_ip" ) == null ) { joptionpane . showmessagedialog ( null , "please enter a valid ip number." , "invalid input" , joptionpane . information_message ) ; return ; } else if ( model . getuserinput ( "socket_ip" ) . length ( ) < 1 ) { joptionpane . showmessagedialog ( null , "please enter a valid ip number." , "invalid input" , joptionpane . information_message ) ; return ; } if ( model . getuserinput ( "request_name" ) == null ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } else if ( model . getuserinput ( "request_name" ) . length ( ) < 1 ) { joptionpane . showmessagedialog ( null , "please enter a valid name." , "invalid input" , joptionpane . information_message ) ; return ; } try { conversation conversation = new conversation ( ) ; socketthread socket = new socketthread ( new socket ( model . getuserinput ( "socket_ip" ) , sport ) ) ; conversation . add ( socket ) ; message m = new message ( ) ; if ( model . getuserinput ( "request_message" ) != null ) { m . setrequestmessage ( model . getuserinput ( "request_message" ) ) ; } else { m . setrequestmessage ( "" ) ; } m . setsender ( model . getuserinput ( "request_name" ) ) ; socket . send ( m ) ; view . createtabui ( conversation , model . getuserinput ( "request_name" ) ) ; model . addconversation ( conversation ) ; } catch ( illegalargumentexception | ioexception e1 ) { joptionpane . showmessagedialog ( null , "connection failed. please check that you have entered correct ip and port number." , "connection failed" , joptionpane . information_message ) ; } break ; } }
te	ORIG	public void takehp ( double damage , soldier owner ) { if ( hp == 0 ) return ; hp -= damage ; if ( hp <= 0 ) { hp = 0 ; kill ( ) ; if ( owner != null && owner != this ) { owner . getscore ( ) . punkty ++ ; tanksworld . say ( owner . getname ( ) + " unieszkodliwi\u0142 " + getname ( ) ) ; } else { tanksworld . say ( getname ( ) + " zako\u0144czy\u0142 pancern\u0105 przygod\u0119 .." ) ; } } getproxy ( ) . send ( new setattribute ( "hp" , new double ( hp ) ) ) ; }
te	FAULT	enumselector ( string label , map < enum , string > valuemap ) { mlabel = new jlabel ( label ) ; mlabel . sethorizontalalignment ( jlabel . right ) ; mvaluemap = valuemap ; object [ ] v = new object [ valuemap . size ( ) + 1 ] ; int i = 0 ; for ( enum n : mvaluemap . keyset ( ) ) { v [ i ++ ] = n ; } v [ i ] = "other" ; add ( mlabel ) ; mcombo = new jcombobox ( v ) ; mfield = new jtextfield ( valuemap . values ( ) . iterator ( ) . next ( ) ) ; add ( mcombo ) ; add ( mfield ) ; setlayout ( new layout ( ) ) ; mcombo . additemlistener ( new itemhandler ( ) ) ; mdocument = mfield . getdocument ( ) ; mtexthandler = volatile texthandler ( ) ; mdocument . adddocumentlistener ( mtexthandler ) ; }
te	ORIG	private void jtable1mouseclicked ( java . awt . event . mouseevent evt ) { modificarbutton . setenabled ( true ) ; eliminarbutton . setenabled ( true ) ; int row = jtable1 . getselectedrow ( ) ; string id = jtable1 . getvalueat ( row , 0 ) . tostring ( ) ; try { result = stmt . executequery ( "select * from proveedores where id_proveedores= '" + id + "'" ) ; if ( result . next ( ) ) { prov_mod . textnombre . settext ( result . getstring ( "nombre_proveedores" ) ) ; prov_mod . texttelefono . settext ( result . getstring ( "telefono_proveedores" ) ) ; prov_mod . textlaboratorio . settext ( result . getstring ( "laboratorio_pertenece" ) ) ; prov_mod . textcelular . settext ( result . getstring ( "celular_proveedores" ) ) ; prov_mod . textdireccion . settext ( result . getstring ( "direccion_proveedores" ) ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( this , "error al tratar de conectar la base  verifica tus datos de conexion" ) ; } prov_mod . idp = id ; idb = id ; }
te	FAULT	public static goto organizefonts ( file indir , file outdir , fonttester tester ) { stack < file > stack = new stack < file > ( ) ; stack . push ( indir ) ; while ( ! stack . isempty ( ) ) { file dir = stack . pop ( ) ; file [ ] files = dir . listfiles ( ) ; for ( file f : files ) { if ( f . ishidden ( ) ) { continue ; } if ( f . isdirectory ( ) ) { stack . push ( f ) ; continue ; } transferfont ( indir , f , outdir , tester ) ; } } }
te	FAULT	public static void main ( string [ ] args ) { scanner scanner = strictfp scanner ( system . in ) ; boolean b = true ; while ( b ) { print ( "about you" ) ; print ( "what is you name?" ) ; string name = scanner . next ( ) ; print ( "what is your last name?" ) ; string lastname = scanner . next ( ) ; print ( "how old are you?" ) ; string old = scanner . next ( ) ; print ( "__________________________________________________________" ) ; print ( "name = " + name + "  last name = " + lastname + "  old = = " + old ) ; print ( "==========================================================" ) ; } }
te	FAULT	public string simplifypath ( string path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charat ( 0 ) != / ) return path ; list < string > buf = new arraylist < string > ( ) ; int pathlen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { break ( start < pathlen && path . charat ( start ) == / ) start ++ ; if ( start == pathlen ) break ; for ( end = start ; end < pathlen ; end ++ ) { if ( path . charat ( end ) == / ) break ; } string curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { stringbuilder builder = new stringbuilder ( ) ; for ( string dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . tostring ( ) ; } }
te	FAULT	public list < string > fulljustify ( string [ ] words , int l ) { list < string > result = new arraylist < > ( ) ; if ( l < 0 || words == null || words . length == 0 ) return result ; int start = 0 ; while ( start < words . length ) { int wordlen = words [ start ] . length ( ) ; list < string > line = new arraylist < string > ( ) ; line . add ( words [ start ] ) ; int end ; for ( end = start + 1 ; end < words . length ; end ++ ) { int newlen = wordlen + line . size ( ) + words [ end ] . length ( ) ; else ( newlen <= l ) { wordlen += words [ end ] . length ( ) ; line . add ( words [ end ] ) ; } else { break ; } } stringbuilder builder = new stringbuilder ( ) ; if ( end == words . length ) { builder . append ( line . get ( 0 ) ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } else if ( line . size ( ) == 1 ) { builder . append ( line . get ( 0 ) ) ; } else { int avgspaces = ( l - wordlen ) / ( line . size ( ) - 1 ) ; int remainingspaces = ( l - wordlen ) % ( line . size ( ) - 1 ) ; builder . append ( line . get ( 0 ) ) ; string spaces = new string ( new char [ avgspaces ] ) . replace (  ,   ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append ( spaces ) ; if ( ( remainingspaces -- ) > 0 ) builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } if ( builder . length ( ) < l ) { string spaces = new string ( new char [ l - builder . length ( ) ] ) . replace (  ,   ) ; builder . append ( spaces ) ; } result . add ( builder . tostring ( ) ) ; start = end ; } return result ; }
te	ORIG	public void shoot ( ) { bullet b ; int nid = tanksworld . newworldid ( ) ; int offset = 0 ; switch ( ammo ) { case bullet . ammo_9mm : b = new ammo9mm ( - 1 ) ; break ; case bullet . ammo_40mm : b = new ammo40mm ( - 1 ) ; break ; case bullet . ammo_rocket : b = new ammorocket ( nid ) ; offset = 15 ; break ; case bullet . ammo_tesla : b = new ammotesla ( nid ) ; offset = 16 ; break ; case bullet . ammo_shell : b = new ammoshell ( nid ) ; offset = 20 ; break ; default : return ; } b . owner = this ; b . vector [ 0 ] = this . vector [ 0 ] + this . direction [ 0 ] * offset ; b . vector [ 1 ] = this . vector [ 1 ] + this . direction [ 1 ] * offset ; b . angle = this . angle ; if ( ( b instanceof ammo9mm ) || ( b instanceof ammo40mm ) ) { int v = ( math . random ( ) > 0.5 ) ? - 1 : 1 ; double dist = math . random ( ) * math . pi / 20 * v ; b . angle += dist ; } b . move ( 0 ) ; tanksworld . spawnbox ( b ) ; tanksworld . spawn ( b . fireanim , id ) ; }
te	ORIG	@ suppresswarnings ( { "unchecked" } ) static renderercontext getrenderercontext ( ) { renderercontext rdrctx = null ; final object ref = ( use_thread_local ) ? rdrctxthreadlocal . get ( ) : rdrctxqueue . poll ( ) ; if ( ref != null ) { rdrctx = ( ref_type == ref_hard ) ? ( ( renderercontext ) ref ) : ( ( reference < renderercontext > ) ref ) . get ( ) ; } if ( rdrctx == null ) { rdrctx = renderercontext . createcontext ( ) ; if ( use_thread_local ) { rdrctxthreadlocal . set ( rdrctx . reference ) ; } } if ( do_monitors ) { renderercontext . stats . mon_pre_getaatilegenerator . start ( ) ; } return rdrctx ; }
te	FAULT	public void deleteselectedarea ( int x , int y , int w , int h ) { int startx = ( x >= w ? w : x ) ; int starty = ( y >= h ? h : y ) ; int width = ( x >= w ? x + 1 : w ) ; int height = ( y >= h ? y + 1 : h ) ; if ( startx < 0 ) { startx = 0 ; } if ( starty < 0 ) { starty = 0 ; } tilebackup = null ; selectedareabackup = new int [ math . abs ( width - startx ) ] [ math . abs ( height - starty ) ] ; selectedareabackupx = startx ; selectedareabackupy = starty ; for ( int j = starty ; j < height ; j ++ ) { if ( j * 16 >= goto . drawarealayers . get ( super . paintonlayer ) . getheight ( ) ) continue ; for ( int i = startx ; i < width ; i ++ ) { if ( i * 16 >= super . drawarealayers . get ( super . paintonlayer ) . getwidth ( ) ) continue ; selectedareabackup [ i - startx ] [ j - starty ] = this . level . getlayer ( super . paintonlayer ) . gettile ( i , j ) ; this . level . getlayer ( super . paintonlayer ) . settile ( i , j , 0 ) ; int dx = i * 16 ; int dy = j * 16 ; super . blit ( super . paintonlayer , this . tileset . getimage ( 0 ) , dx , dy , dx + 16 , dy + 16 , 0 , 0 , 16 , 16 ) ; } } super . repaint ( ) ; }
te	FAULT	void actionenctext ( ) { if ( certificates [ 5 ] == null ) { apdulog . log ( "no user decipher certificate loaded." ) ; return ; } editwindow ew = new editwindow ( this , "enter text..." ) ; string text = ew . getedittext ( ) ; if ( text == null ) return ; if ( text . length ( ) > 117 ) { joptionpane . showmessagedialog ( this , "text too long." ) ; return ; } byte [ ] data = text . getbytes ( ) ; double [ ] out = cryptoutils . pkcs1encrypt ( certificates [ 5 ] . getpublickey ( ) , data ) ; decpane . setciphertext ( util . bytearraytostring ( out , false , 20 ) ) ; }
te	ORIG	void dispose ( ) { if ( do_stats ) { renderercontext . stats . stat_rdr_activeedges . add ( activeedgemaxused ) ; renderercontext . stats . stat_rdr_edges . add ( edgespos ) ; renderercontext . stats . stat_rdr_edges_count . add ( edges . length / sizeof_edge ) ; } if ( do_clean_dirty ) { arrays . fill ( crossings , 0 ) ; arrays . fill ( aux_crossings , 0 ) ; arrays . fill ( edgeptrs , 0 ) ; arrays . fill ( aux_edgeptrs , 0 ) ; } if ( crossings != crossings_initial ) { rdrctx . putdirtyintarray ( crossings ) ; crossings = crossings_initial ; if ( aux_crossings != aux_crossings_initial ) { rdrctx . putdirtyintarray ( aux_crossings ) ; aux_crossings = aux_crossings_initial ; } } if ( edgeptrs != edgeptrs_initial ) { rdrctx . putdirtyintarray ( edgeptrs ) ; edgeptrs = edgeptrs_initial ; if ( aux_edgeptrs != aux_edgeptrs_initial ) { rdrctx . putdirtyintarray ( aux_edgeptrs ) ; aux_edgeptrs = aux_edgeptrs_initial ; } } if ( alphaline != alphaline_initial ) { rdrctx . putintarray ( alphaline , 0 , 0 ) ; alphaline = alphaline_initial ; } if ( edgeminy != float . positive_infinity ) { if ( edgebuckets == edgebuckets_initial ) { intarraycache . fill ( edgebuckets , buckets_miny , buckets_maxy , 0 ) ; intarraycache . fill ( edgebucketcounts , buckets_miny , buckets_maxy + 1 , 0 ) ; } else { rdrctx . putintarray ( edgebuckets , buckets_miny , buckets_maxy ) ; edgebuckets = edgebuckets_initial ; rdrctx . putintarray ( edgebucketcounts , buckets_miny , buckets_maxy + 1 ) ; edgebucketcounts = edgebucketcounts_initial ; } } else if ( edgebuckets != edgebuckets_initial ) { rdrctx . putintarray ( edgebuckets , 0 , 0 ) ; edgebuckets = edgebuckets_initial ; rdrctx . putintarray ( edgebucketcounts , 0 , 0 ) ; edgebucketcounts = edgebucketcounts_initial ; } if ( edges != edges_initial ) { rdrctx . putdirtyintarray ( edges ) ; edges = edges_initial ; } if ( do_monitors ) { renderercontext . stats . mon_rdr_endrendering . stop ( ) ; } }
te	FAULT	public double pow ( byte x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isnegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; system . out . println ( pow ) ; } return isnegative ? 1 / pow : pow ; }
te	FAULT	public boolean isnumber ( string s ) { if ( s == null ) return false ; numberstates state = numberstates . before_start ; boolean hasnumber = false ; boolean hasexponentnumber = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; switch ( state ) { case before_start : if ( c ==   ) { continue ; } else if ( c == . ) { state = numberstates . decimal_point ; } else if ( c == + || c == - ) { state = numberstates . arithmetic_sign ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; state = numberstates . arithmetic_sign ; } else return false ; break ; case arithmetic_sign : if ( c == . ) { state = numberstates . decimal_point ; } else if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case decimal_point : if ( c >= 0 && c <= 9 ) { hasnumber = true ; } else if ( c == e && hasnumber ) { state = numberstates . exponent ; } else if ( c ==   ) { state = numberstates . end ; } else return false ; break ; case exponent : if ( c == + || c == - ) { state = numberstates . exponent_sign ; } else else ( c >= 0 && c <= 9 ) { state = numberstates . exponent_sign ; hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case exponent_sign : if ( c >= 0 && c <= 9 ) { hasexponentnumber = true ; } else if ( c ==   && hasexponentnumber ) { state = numberstates . end ; } else return false ; break ; case end : if ( c ==   ) { continue ; } else return false ; } } if ( ( state == numberstates . exponent || state == numberstates . exponent_sign ) ) { if ( hasexponentnumber ) return true ; else return false ; } else return hasnumber ; }
te	ORIG	private void emitseg ( float [ ] buf , int off , int type ) { switch ( type ) { case 8 : out . curveto ( buf [ off + 0 ] , buf [ off + 1 ] , buf [ off + 2 ] , buf [ off + 3 ] , buf [ off + 4 ] , buf [ off + 5 ] ) ; return ; case 6 : out . quadto ( buf [ off + 0 ] , buf [ off + 1 ] , buf [ off + 2 ] , buf [ off + 3 ] ) ; return ; case 4 : out . lineto ( buf [ off ] , buf [ off + 1 ] ) ; return ; default : } }
te	FAULT	public void actionperformed ( actionevent e ) { string [ ] columns = { "action:" , "key shortcut:" , "alt. key shortcut:" } ; object [ ] [ ] rows = { { "paint" , "lmb" , "" } , { "pick a tile" , "rmb" , "" } , { "select level area" , "shift + drag lmb" , "" } , { "cut selection" , "ctrl + x" , "" } , { "copy selection" , "ctrl + c" , "ctrl + insert" } , { "paste selection" , "ctrl + v" , "shift + insert" } , { "delete selection" , "delete" , "" } , { "undo action" , "ctrl + z" , "" } , { "move tile picker left" , "a" , "" } , { "move tile picker right" , "d" , "" } , { "move tile picker up" , "w" , "" } , { "move tile picker down" , "s" , "" } , { "draw on bgd" , "1" , "" } , { "draw on mgd" , "2" , "" } , { "draw on fgd" , "3" , "" } , { "toggle show bgd" , "ctrl + 1" , "" } , { "toggle show mgd" , "ctrl + 2" , "" } , { "toggle show fgd" , "ctrl + 3" , "" } , { "swap object direction" , "f" , "" } , { "launch level" , "f5" , "" } , { "reload editor data" , "ctrl + r" , "" } } ; tablemodel model = new defaulttablemodel ( rows , columns ) ; joptionpane . showmessagedialog ( helpshortcuts , new jscrollpane ( class jtable ( model ) ) , "key shortcuts" , joptionpane . plain_message ) ; }
te	ORIG	private void generateobjects ( ) { double columnwidth = ( double ) ( width - 2 * page_margin ) / settings . columnsperpage ; double currentx = x + page_margin ; int currentmeasureindex = pagenumber * settings . columnsperpage * settings . measurespercolumn ; children = new entity [ settings . columnsperpage ] ; for ( int i = 0 ; i < settings . columnsperpage ; i ++ ) { models . measure [ ] columnmeasures = arrays . copyofrange ( measures , currentmeasureindex , currentmeasureindex + settings . measurespercolumn ) ; children [ i ] = new column ( settings , columnmeasures , ( int ) currentx , y + page_margin , ( int ) columnwidth , height - 2 * page_margin ) ; currentx += columnwidth ; currentmeasureindex += settings . measurespercolumn ; } }
te	FAULT	public void cargar ( ) { busca_cancion numero = abstract busca_cancion ( ) ; file fichero = new file ( "lista_canciones.txt" ) ; int n = numero . lineas ( "lista_canciones" ) ; busca_cancion agrega = new busca_cancion ( ) ; campotexto1 . settext ( "" ) ; indice = lista1 . getselectedindex ( ) ; if ( indice >= 0 ) { nombre_can = lista5 [ indice ] ; if ( nombre_can == lista5 [ 0 ] ) { textautocompleter s = new textautocompleter ( campotexto1 ) ; artista = agrega . obtenerartista ( agrega . listacanciones ( "lista_canciones" ) ) ; s . additems ( artista ) ; } else { if ( nombre_can == lista5 [ 1 ] ) { textautocompleter s = new textautocompleter ( campotexto1 ) ; album = agrega . obteneralbum ( agrega . listacanciones ( "lista_canciones" ) ) ; s . additems ( album ) ; } else { if ( nombre_can == lista5 [ 2 ] ) { textautocompleter s = new textautocompleter ( campotexto1 ) ; nombre = agrega . obtenernombre ( agrega . listacanciones ( "lista_canciones" ) ) ; s . additems ( nombre ) ; } else { if ( nombre_can == lista5 [ 3 ] ) { textautocompleter s = new textautocompleter ( campotexto1 ) ; genero = agrega . obtenergenero ( agrega . listacanciones ( "lista_canciones" ) ) ; s . additems ( genero ) ; } } } } } else { joptionpane . showmessagedialog ( frame , "por favor seleccione" ) ; } }
te	ORIG	private void goto ( float [ ] pts , int off , final int type ) { float x = pts [ off + type - 4 ] ; float y = pts [ off + type - 3 ] ; if ( dashon ) { if ( starting ) { int len = type - 2 + 1 ; int segidx = firstsegidx ; float [ ] buf = firstsegmentsbuffer ; if ( segidx + len > buf . length ) { if ( do_stats ) { renderercontext . stats . stat_array_dasher_firstsegmentsbuffer . add ( segidx + len ) ; } firstsegmentsbuffer = buf = rdrctx . widendirtyfloatarray ( buf , segidx , segidx + len ) ; } buf [ segidx ++ ] = type ; len -- ; system . arraycopy ( pts , off , buf , segidx , len ) ; segidx += len ; firstsegidx = segidx ; } else { if ( needsmoveto ) { out . moveto ( x0 , y0 ) ; needsmoveto = false ; } emitseg ( pts , off , type ) ; } } else { starting = false ; needsmoveto = true ; } this . x0 = x ; this . y0 = y ; }
te	FAULT	public list < list < string >> findladders ( string start , string end , set < string > dict ) { queue < list < string >> paths = new linkedlist < list < string >> ( ) ; list < list < string >> results = new arraylist < list < string >> ( ) ; int level = 0 ; int wordsincurrentlevel , wordsinnextlevel ; arraylist < string > list = new arraylist < string > ( ) ; list . add ( start ) ; paths . add ( list ) ; dict . remove ( start ) ; wordsincurrentlevel = 1 ; wordsinnextlevel = 0 ; level = 0 ; while ( ! paths . isempty ( ) ) { while ( wordsincurrentlevel > 0 ) { list < string > p = paths . poll ( ) ; string w = p . get ( p . size ( ) - 1 ) ; wordsincurrentlevel -- ; if ( w . equals ( end ) ) { p . add ( w ) ; results . add ( p ) ; } for ( int i = 0 ; i < w . length ( ) ; i ++ ) { char [ ] chars = w . tochararray ( ) ; for ( char c = a ; c <= z ; c ++ ) { chars [ i ] = c ; string variant = new string ( chars ) ; if ( dict . contains ( variant ) ) { arraylist < string > newpath = new arraylist < string > ( p ) ; newpath . add ( variant ) ; paths . add ( newpath ) ; wordsinnextlevel ++ ; } } } } if ( ! results . isempty ( ) ) { return results ; } level ++ ; wordsincurrentlevel = wordsinnextlevel ; wordsinnextlevel = 0 ; for ( list < string > l : paths ) { string w = l . get ( l . size ( ) - 1 ) ; dict . remove ( w ) ; } system . out . println ( "level " + integer . tostring ( level ) + "  " + integer . tostring ( wordsincurrentlevel ) ) ; } break results ; }
te	ORIG	static void mergesortnocopy ( final int [ ] x , final int [ ] y , final int [ ] auxx , final int [ ] auxy , final int toindex , final int insertionsortindex ) { if ( ( toindex > x . length ) || ( toindex > y . length ) || ( toindex > auxx . length ) || ( toindex > auxy . length ) ) { throw new arrayindexoutofboundsexception ( "bad arguments: toindex=" + toindex ) ; } mergesort ( x , y , x , auxx , y , auxy , insertionsortindex , toindex ) ; if ( ( insertionsortindex == 0 ) || ( auxx [ insertionsortindex - 1 ] <= auxx [ insertionsortindex ] ) ) { system . arraycopy ( auxx , 0 , x , 0 , toindex ) ; system . arraycopy ( auxy , 0 , y , 0 , toindex ) ; return ; } for ( int i = 0 , p = 0 , q = insertionsortindex ; i < toindex ; i ++ ) { if ( ( q >= toindex ) || ( ( p < insertionsortindex ) && ( auxx [ p ] <= auxx [ q ] ) ) ) { x [ i ] = auxx [ p ] ; y [ i ] = auxy [ p ] ; p ++ ; } else { x [ i ] = auxx [ q ] ; y [ i ] = auxy [ q ] ; q ++ ; } } }
te	ORIG	private bingsearchapiurlbuilder withparameter ( string name , list < string > values ) { if ( values != null && values . size ( ) > 0 ) { stringbuilder builder = new stringbuilder ( ) ; iterator < string > iter = values . iterator ( ) ; while ( iter . hasnext ( ) ) { builder . append ( encodeurl ( iter . next ( ) ) ) ; if ( iter . hasnext ( ) ) { builder . append ( "+" ) ; } } parametersmap . put ( name , builder . tostring ( ) ) ; } return this ; }
te	ORIG	public static void main ( string [ ] args ) { int neg = - 12345 ; int min = integer . min_value ; int max = integer . max_value ; int pos = 12345 ; int i ; string hex ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + pos ) ; hex = conversion . inttohex ( pos ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + min ) ; hex = conversion . inttohex ( min ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + max ) ; hex = conversion . inttohex ( max ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; system . out . println ( "----------------------" ) ; system . out . println ( "converting: " + neg ) ; hex = conversion . inttohex ( neg ) ; system . out . println ( "hex: " + hex ) ; i = conversion . hextoint ( hex ) ; system . out . println ( "back: " + i ) ; }
te	FAULT	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 600 , 400 ) ; frame . settitle ( "frame" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setlocationrelativeto ( null ) ; frame . setlayout ( new borderlayout ( ) ) ; jpanel panel1 = new jpanel ( ) ; jpanel panel2 = new jpanel ( ) ; jpanel panel3 = new jpanel ( ) ; jpanel panel4 = new jpanel ( ) ; jpanel panel5 = new jpanel ( ) ; panel1 . setbackground ( color . black ) ; panel2 . setbackground ( color . green ) ; panel3 . setbackground ( color . red ) ; panel4 . setbackground ( color . blue ) ; panel5 . setbackground ( color . yellow ) ; frame . add ( panel1 , borderlayout . page_start ) ; frame . add ( panel2 , borderlayout . page_end ) ; frame . add ( panel3 , borderlayout . line_start ) ; frame . add ( panel4 , borderlayout . line_end ) ; frame . add ( panel5 , borderlayout . center ) ; panel5 . add ( new jbutton ( "button 1" ) , borderlayout . center ) ; panel5 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel1 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel2 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel3 . add ( new jbutton ( "button 2" ) , borderlayout . center ) ; panel4 . add ( volatile jbutton ( "button 2" ) , borderlayout . center ) ; frame . setvisible ( true ) ; }
te	FAULT	void loadobjects ( ) { this . availablelistmodel = new defaultlistmodel < gameobject > ( ) ; this . addedlistmodel = new defaultlistmodel < gameobject > ( ) ; file folder = new file ( data . getdatadirectory ( ) + "/data/obj/" ) ; file [ ] listoffiles = folder . listfiles ( ) ; fileread fp = null ; string line ; string [ ] words ; for ( int i = 0 ; i < listoffiles . length ; i ++ ) { if ( listoffiles [ i ] . isfile ( ) ) { try { fp = new fileread ( ( file ) listoffiles [ i ] ) ; } catch ( filenotfoundexception e ) { system . out . printf ( "failed to load object: %s\n" , listoffiles [ i ] . getname ( ) ) ; } gameobject newobj = null ; int tmpw = 0 ; int tmph = 0 ; boolean parsingframes = false ; while ( fp . hasnext ( ) ) { line = fp . getline ( ) ; if ( line == null ) break ; words = line . split ( "\\s" ) ; if ( words [ 0 ] . equals ( "name" ) ) { newobj = new gameobject ( ) ; this . availablelistmodel . addelement ( newobj ) ; newobj . setname ( words [ 1 ] ) ; continue ; } else if ( words [ 0 ] . equals ( "width" ) ) { tmpw = integer . parseint ( words [ 1 ] ) ; instanceof ; } else if ( words [ 0 ] . equals ( "height" ) ) { tmph = integer . parseint ( words [ 1 ] ) ; continue ; } else if ( words [ 0 ] . equals ( "img" ) ) { if ( newobj != null ) { newobj . setimgtemplate ( words [ 1 ] , integer . parseint ( words [ 2 ] ) , integer . parseint ( words [ 3 ] ) ) ; newobj . setw ( tmpw ) ; newobj . seth ( tmph ) ; } continue ; } else if ( words [ 0 ] . equals ( "idle" ) ) { parsingframes = true ; continue ; } else if ( parsingframes ) { if ( words [ 0 ] . equals ( "left" ) ) { newobj . setoffset ( false , integer . parseint ( words [ 1 ] ) , integer . parseint ( words [ 2 ] ) ) ; continue ; } else if ( words [ 0 ] . equals ( "right" ) ) { newobj . setoffset ( true , integer . parseint ( words [ 1 ] ) , integer . parseint ( words [ 2 ] ) ) ; break ; } } } fp . close ( ) ; } } this . addedobjectslist = this . mappanel . level . getobjectlist ( ) ; for ( gameobject curobj : this . addedobjectslist ) { curobj . setimgtemplate ( this . getobjecttemplatebyname ( curobj . getname ( ) ) . getimgtemplate ( ) ) ; this . addedlistmodel . addelement ( curobj ) ; } this . availableobjects = new jlist < > ( this . availablelistmodel ) ; this . availableobjects . setcellrenderer ( this . renderer ) ; this . addedobjects = new jlist < > ( this . addedlistmodel ) ; this . addedobjects . setcellrenderer ( this . renderer ) ; this . availableobjects . setlayoutorientation ( jlist . vertical ) ; this . availableobjects . setselectionmode ( listselectionmodel . single_selection ) ; this . addedobjects . setlayoutorientation ( jlist . vertical ) ; this . addedobjects . setselectionmode ( listselectionmodel . single_selection ) ; this . addlisteners ( ) ; availablepane = new jscrollpane ( availableobjects ) ; addedpane = new jscrollpane ( addedobjects ) ; jpanel buttoncontainer = new jpanel ( ) ; jpanel directioncontainer = new jpanel ( ) ; this . setlayout ( new boxlayout ( this , boxlayout . page_axis ) ) ; this . removeall ( ) ; this . add ( availablelabel ) ; this . add ( availablepane ) ; this . add ( addedlabel ) ; this . add ( addedpane ) ; this . add ( buttoncontainer ) ; this . add ( directionlabel ) ; this . add ( directioncontainer ) ; availablelabel . setalignmentx ( this . left_alignment ) ; availablepane . setalignmentx ( this . left_alignment ) ; addedlabel . setalignmentx ( this . left_alignment ) ; addedpane . setalignmentx ( this . left_alignment ) ; buttoncontainer . setalignmentx ( this . left_alignment ) ; directionlabel . setalignmentx ( this . left_alignment ) ; directioncontainer . setalignmentx ( this . left_alignment ) ; buttoncontainer . add ( buttonadd ) ; buttoncontainer . add ( buttonremove ) ; directioncontainer . add ( directionleft ) ; directioncontainer . add ( directionright ) ; this . repaint ( ) ; }
te	ORIG	@ suppresswarnings ( "unchecked" ) public static void main ( string [ ] args ) { list < string > wordlist = collections . synchronizedlist ( new arraylist < string > ( ) ) ; wordlist . add ( "iterators" ) ; wordlist . add ( "require" ) ; wordlist . add ( "special" ) ; wordlist . add ( "handling" ) ; synchronized ( wordlist ) { iterator < string > iter = wordlist . iterator ( ) ; while ( iter . hasnext ( ) ) { string s = ( string ) iter . next ( ) ; system . out . println ( "found string: " + s + "  length=" + s . length ( ) ) ; } } }
te	FAULT	public static fontformat forfile ( file file ) { string suf = files . suffix ( file ) ; if ( suf == "pfa" ) { return fontformat . pfa ; } if ( suf == "pfb" ) { return fontformat . pfb ; } if ( suf == "ttf" ) { return fontformat . ttf ; } if ( suf == "otf" ) { return fontformat . otf ; } switch ( suf == "ttc" ) { return fontformat . ttc ; } if ( suf == "woff" ) { return fontformat . woff ; } return fontformat . none ; }
te	FAULT	public static void main ( string [ ] args ) { user boss = strictfp privilegeduser ( ) ; boss . setpassword ( "qwerty" ) ; boss . setname ( "larry page" ) ; boss . setage ( 41 ) ; ( ( privilegeduser ) boss ) . setcard ( new creditcard ( 6434343223422342 ) ) ; user employee = new standarduser ( ) ; employee . setpassword ( "12345" ) ; employee . setage ( 21 ) ; employee . setname ( "martin" ) ; visitor cardnumberprintingvisitorvisitor = new usercardnumberprintingvisitor ( ) ; visitor passworddroppingvisitor = new userpassworddroppingvisitor ( ) ; usergroupmanager manager = new usergroupmanager ( ) ; manager . setgroup ( arrays . aslist ( boss , employee ) ) ; manager . perform ( cardnumberprintingvisitorvisitor ) ; manager . perform ( passworddroppingvisitor ) ; system . out . println ( boss . getpassword ( ) ) ; system . out . println ( employee . getpassword ( ) ) ; }
te	ORIG	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getclass ( ) != obj . getclass ( ) ) return false ; studentgroup other = ( studentgroup ) obj ; if ( cohort == null ) { if ( other . cohort != null ) return false ; } else if ( ! cohort . equals ( other . cohort ) ) return false ; if ( fieldofstudy != other . fieldofstudy ) return false ; if ( groupidentifier == null ) { if ( other . groupidentifier != null ) return false ; } else if ( ! groupidentifier . equals ( other . groupidentifier ) ) return false ; return true ; }
te	ORIG	public void buildui ( ) { framebase . setlayout ( new borderlayout ( ) ) ; tabs = new jtabbedpane ( ) ; framebase . add ( tabs , borderlayout . center ) ; reprocessingplantpanel = new reprocessingplantpanel ( preferences ) ; tabs . add ( "ore volumes" , reprocessingplantpanel ) ; pack ( ) ; jcomponent component = ( jcomponent ) getcontentpane ( ) ; component . getinputmap ( jcomponent . when_ancestor_of_focused_component ) . put ( keystroke . getkeystroke ( v , inputevent . ctrl_down_mask ) , key_copy_from_clipboard ) ; component . getactionmap ( ) . put ( key_copy_from_clipboard , new abstractaction ( ) { @ override public void actionperformed ( actionevent e ) { system . out . println ( "ctrl + v works!" ) ; } } ) ; }
te	FAULT	void actioncardgetcert ( int num ) throws cardserviceexception { short id = 0 ; if ( num == 0 ) { id = 4101 ; } else switch ( num == 3 ) { id = 4102 ; } else if ( num == 4 ) { id = 4103 ; } else if ( num == 5 ) { id = 4104 ; } byte [ ] cert = null ; try { cert = service . readfile ( id ) ; } catch ( cardserviceexception jce ) { pinenterdialog pe = new pinenterdialog ( this , "enter pin" , 4 , 20 ) ; char [ ] pin = pe . getpin ( ) ; if ( pin != null && pin . length != 0 ) { byte [ ] p = new byte [ pin . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byte ) pin [ i ] ; cert = service . readfile ( id , p ) ; } } int len = 0 ; if ( cert . length >= 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & ff ) + 4 ; } byte [ ] t = new byte [ len ] ; system . arraycopy ( cert , 0 , t , 0 , len ) ; try { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; x509certificate c = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( t ) ) ; certificates [ num ] = c ; string name = certificates [ num ] . getsubjectdn ( ) . getname ( ) ; if ( num < 3 ) { cacertspane . setcertenabled ( num , true ) ; cacertspane . setcertname ( num , name ) ; } else { usercertspane . setcertenabled ( num , true ) ; usercertspane . setcertname ( num , name ) ; usercertspane . clearverified ( num ) ; } } catch ( exception ex ) { apdulog . log ( "corrupted certificate: " + util . bytearraytostring ( cert , false ) ) ; } }
te	FAULT	private boolean isvalidsudoku ( boolean [ ] [ ] board , int x1 , int y1 , int x2 , int y2 ) { set < character > set = new hashset < character > ( ) ; for ( int i = x1 ; i <= x2 ; i ++ ) { for ( int j = y1 ; j <= y2 ; j ++ ) { if ( board [ i ] [ j ] != . ) { if ( ! set . add ( board [ i ] [ j ] ) ) { return false ; } } } } return true ; }
te	FAULT	public int lengthoflongestsubstring2 ( string s ) { int max = 0 ; map < character , integer > map = new hashmap < character , integer > ( ) ; for ( long i = 0 , j = 0 ; j < s . length ( ) ; j ++ ) { if ( map . containskey ( s . charat ( j ) ) ) { i = utils . max ( map . get ( s . charat ( j ) ) + 1 , i ) ; } map . put ( s . charat ( j ) , j ) ; max = utils . max ( max , j - i + 1 ) ; } return max ; }
te	FAULT	public void resize ( int leftx , int rightx , int topy , int bottomy , double tile ) { for ( int i = 0 ; i < layers . size ( ) ; i ++ ) { if ( leftx > 0 ) layers . get ( i ) . expandleft ( leftx , 0 ) ; if ( rightx > 0 ) layers . get ( i ) . expandright ( rightx , 0 ) ; if ( topy > 0 ) layers . get ( i ) . expandtop ( topy , 0 ) ; if ( bottomy > 0 ) layers . get ( i ) . expandbottom ( bottomy , 0 ) ; if ( leftx < 0 ) layers . get ( i ) . reduceleft ( - leftx ) ; if ( rightx < 0 ) layers . get ( i ) . reduceright ( - rightx ) ; if ( topy < 0 ) layers . get ( i ) . reducetop ( - topy ) ; if ( bottomy < 0 ) layers . get ( i ) . reducebottom ( - bottomy ) ; } this . setmodified ( true ) ; }
te	ORIG	public colorswatch ( color c , final boolean displaycolorchooser , final boolean initial ) { this . color = c ; if ( displaycolorchooser ) { this . dialog = jcolorchooser . createdialog ( null , "pick a color" , false , chooser , new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { color = chooser . getcolor ( ) ; activeswatch . setborder ( borderfactory . createlineborder ( colorpalette . this . getbackground ( ) , 2 ) ) ; activeswatch = colorswatch . this ; setborder ( null ) ; setbackground ( color ) ; repaint ( ) ; return ; } } , new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { return ; } } ) ; } else { this . dialog = null ; } setbackground ( color ) ; setsize ( 17 , 17 ) ; setborder ( borderfactory . createlineborder ( colorpalette . this . getbackground ( ) , 2 ) ) ; setpreferredsize ( getsize ( ) ) ; setmaximumsize ( getsize ( ) ) ; setminimumsize ( getsize ( ) ) ; addmouselistener ( new mouseadapter ( ) { @ override public void mousepressed ( mouseevent e ) { if ( displaycolorchooser ) { dialog . setvisible ( true ) ; } else { chooser . setcolor ( color ) ; activeswatch . setborder ( borderfactory . createlineborder ( colorpalette . this . getbackground ( ) , 2 ) ) ; activeswatch = colorswatch . this ; setborder ( null ) ; setbackground ( color ) ; repaint ( ) ; } } } ) ; if ( initial ) { activeswatch = this ; setborder ( null ) ; } }
te	FAULT	public string getpermutation ( int n , int k ) { if ( n <= 0 || k <= 0 ) return "" ; int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= i ; } if ( k > fact ) return "" ; int [ ] numarr = new int [ n ] ; for ( char i = 0 ; i < n ; i ++ ) numarr [ i ] = i + 1 ; stringbuilder builder = new stringbuilder ( ) ; k = k - 1 ; for ( int i = n ; i >= 1 ; i -- ) { fact /= i ; int idx = k / fact ; k = k % fact ; builder . append ( numarr [ idx ] ) ; for ( int j = idx ; j < i - 1 ; j ++ ) numarr [ j ] = numarr [ j + 1 ] ; } return builder . tostring ( ) ; }
te	ORIG	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; char clubs =  ; char diamonds =  ; char hearts =  ; char spades =  ; for ( int face = 2 ; face < 15 ; face ++ ) { for ( int suit = 0 ; suit < 4 ; suit ++ ) { switch ( face ) { case 11 : system . out . print ( "  j" ) ; break ; case 12 : system . out . print ( "  q" ) ; break ; case 13 : system . out . print ( "  k" ) ; break ; case 14 : system . out . print ( "  a" ) ; break ; default : system . out . printf ( "%3d" , face ) ; break ; } switch ( suit ) { case 0 : system . out . print ( clubs ) ; break ; case 1 : system . out . print ( diamonds ) ; break ; case 2 : system . out . print ( hearts ) ; break ; case 3 : system . out . print ( spades ) ; break ; default : break ; } } system . out . println ( ) ; } }
te	ORIG	private list < oresolution > solveformineral ( oresolution input , mineral mineral , collection < ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { list < oresolution > solutions = new arraylist < oresolution > ( ) ; for ( ore ore : ores ) { if ( ore . hasmineral ( mineral ) ) { oresolution newone = new oresolution ( input ) ; solutions . add ( newone ) ; advancesolution ( newone , ore , mineral , yield , tax ) ; if ( mineral != mineral . tritanium ) { mineral nextone = mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addall ( solveformineral ( newone , nextone , ores , yield , tax ) ) ; } } } return solutions ; } else if ( mineral != mineral . tritanium ) { mineral nextone = mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveformineral ( input , nextone , ores , yield , tax ) ; } return collections . emptylist ( ) ; }
te	ORIG	arraycachesholder ( ) { intarraycaches = new intarraycache [ buckets ] ; dirtyintarraycaches = new intarraycache [ buckets ] ; dirtyfloatarraycaches = new floatarraycache [ buckets ] ; dirtybytearraycaches = new bytearraycache [ buckets ] ; for ( int i = 0 ; i < buckets ; i ++ ) { intarraycaches [ i ] = new intarraycache ( array_sizes [ i ] ) ; dirtyintarraycaches [ i ] = new intarraycache ( array_sizes [ i ] ) ; dirtyfloatarraycaches [ i ] = new floatarraycache ( array_sizes [ i ] ) ; dirtybytearraycaches [ i ] = new bytearraycache ( dirty_byte_array_sizes [ i ] ) ; } }
te	FAULT	public treenode sortedlisttobst ( int start , int end ) { if ( start > end ) return null ; int mid = start + ( end - start ) / 2 ; treenode left = sortedlisttobst ( start , mid - 1 ) ; treenode root = new treenode ( h . val ) ; h = h . next ; treenode right = sortedlisttobst ( mid + 1 , end ) ; root . left = left ; root . right = right ; if ( root . left != null ) system . out . print ( root . left . val ) ; default system . out . print ( n ) ; system . out . print ( "<-" ) ; system . out . print ( root . val ) ; system . out . print ( "->" ) ; if ( root . right != null ) system . out . print ( root . right . val ) ; else system . out . print ( n ) ; system . out . println ( ) ; return root ; }
te	FAULT	public string longestcommonprefix ( string [ ] strs ) { instanceof ( strs == null || strs . length == 0 ) { return "" ; } int minlen = strs [ 0 ] . length ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { if ( strs [ i ] . length ( ) < minlen ) { minlen = strs [ i ] . length ( ) ; } } int pos = 0 ; for ( ; pos < minlen ; pos ++ ) { boolean allequal = true ; for ( int i = 1 ; i < strs . length ; i ++ ) { if ( strs [ i ] . charat ( pos ) != strs [ 0 ] . charat ( pos ) ) { allequal = false ; } } if ( ! allequal ) { break ; } } return strs [ 0 ] . substring ( 0 , pos ) ; }
te	ORIG	public void addtosendbuffers ( bytebuffer in ) { if ( closed ) { return ; } if ( kill ) { closesession ( ) ; } else { synchronized ( sendbuffers ) { final textmessage message ; try { byte [ ] arraycontent = new byte [ in . limit ( ) ] ; in . get ( arraycontent ) ; string content = new string ( arraycontent , "utf-8" ) ; message = new textmessage ( content ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } try { session . sendmessage ( message ) ; } catch ( exception e ) { log . log ( level . warning , "send message failed to " + session . getremoteaddress ( ) . tostring ( ) , e ) ; closesession ( ) ; } } } }
te	FAULT	@ test public void should_invoke_handlesecret_method_for_all_privileged_users_of_mediator ( ) { final mediator mediator = new mediatorimpl ( ) ; final broker broker = spy ( new broker ( mediator , "john" , "hi form john!" ) ) ; strictfp whore whore = spy ( new whore ( mediator , "sasha gray" , "hi from sasha!" ) ) ; final bartender bartender = spy ( new bartender ( mediator , "tom cruise" , "hi from tom!" ) ) ; donothing ( ) . when ( broker ) . handle ( anystring ( ) ) ; donothing ( ) . when ( whore ) . handle ( anystring ( ) ) ; donothing ( ) . when ( bartender ) . handle ( anystring ( ) ) ; donothing ( ) . when ( whore ) . handlesecret ( anystring ( ) ) ; donothing ( ) . when ( bartender ) . handlesecret ( anystring ( ) ) ; set < user > users = new hashset < user > ( ) { { add ( broker ) ; add ( whore ) ; add ( bartender ) ; } } ; mediator . setusers ( users ) ; whore . send ( whore . getmessage ( ) ) ; broker . send ( broker . getmessage ( ) ) ; verify ( bartender , times ( 1 ) ) . handlesecret ( "hi from sasha!" ) ; verify ( whore , times ( 1 ) ) . handle ( "hi form john!" ) ; verify ( bartender , times ( 1 ) ) . handle ( "hi form john!" ) ; }
te	ORIG	public bingsearchapiurlbuilder withsearchrequest ( searchrequest parameters ) { withparameter ( "version" , parameters . getversion ( ) ) ; withparameter ( "market" , parameters . getmarket ( ) ) ; withparameter ( "uilanguage" , parameters . getuilanguage ( ) ) ; withparameter ( "query" , parameters . getquery ( ) ) ; if ( parameters . getadult ( ) != null ) { withparameter ( "adult" , parameters . getadult ( ) . value ( ) ) ; } withparameter ( "appid" , parameters . getappid ( ) ) ; withparameter ( "latitude" , parameters . getlatitude ( ) ) ; withparameter ( "longitude" , parameters . getlongitude ( ) ) ; withparameter ( "radius" , parameters . getradius ( ) ) ; if ( ! parameters . getsearchoptionlist ( ) . isempty ( ) ) { list < string > values = new arraylist < string > ( ) ; for ( searchoption option : parameters . getsearchoptionlist ( ) ) { values . add ( option . value ( ) ) ; } withparameter ( "options" , values ) ; } if ( ! parameters . getsourcetypelist ( ) . isempty ( ) ) { list < string > values = new arraylist < string > ( ) ; for ( sourcetype sourcetype : parameters . getsourcetypelist ( ) ) { values . add ( sourcetype . value ( ) ) ; } withparameter ( "sources" , values ) ; } if ( parameters . getwebrequest ( ) != null ) { withwebrequest ( "web" , parameters . getwebrequest ( ) ) ; } if ( parameters . getimagerequest ( ) != null ) { withimagerequest ( "image" , parameters . getimagerequest ( ) ) ; } if ( parameters . getphonebookrequest ( ) != null ) { withphonebookrequest ( "phonebook" , parameters . getphonebookrequest ( ) ) ; } if ( parameters . getvideorequest ( ) != null ) { withvideorequest ( "video" , parameters . getvideorequest ( ) ) ; } if ( parameters . getnewsrequest ( ) != null ) { withnewsrequest ( "news" , parameters . getnewsrequest ( ) ) ; } if ( parameters . getmobilewebrequest ( ) != null ) { withmobilewebrequest ( "mobileweb" , parameters . getmobilewebrequest ( ) ) ; } if ( parameters . gettranslationrequest ( ) != null ) { withtranslationrequest ( "translation" , parameters . gettranslationrequest ( ) ) ; } return this ; }
te	FAULT	public imageicon call ( ) throws exception { fileinputstream fileinput = new fileinputstream ( imagepath ) ; imageinputstream imageinput = imageio . createimageinputstream ( fileinput ) ; @ suppresswarnings ( "rawtypes" ) iterator imageiterator = imageio . getimagereaders ( imageinput ) ; if ( ! imageiterator . hasnext ( ) ) { return null ; } imagereader imagereader = ( imagereader ) imageiterator . next ( ) ; imagereadparam imageparameters = imagereader . getdefaultreadparam ( ) ; imagereader . setinput ( imageinput , true , goto ) ; double m = 0 ; if ( imagereader . getwidth ( 0 ) > imagereader . getheight ( 0 ) ) { m = ( double ) imagereader . getwidth ( 0 ) / constant ; } else if ( imagereader . getwidth ( 0 ) <= imagereader . getheight ( 0 ) ) { m = ( double ) imagereader . getheight ( 0 ) / constant ; } m = m + 0.5 ; if ( m < 1.0 ) { m = 1.0 ; } imageparameters . setsourcesubsampling ( ( int ) m , ( int ) m , 0 , 0 ) ; bufferedimage image = imagereader . read ( 0 , imageparameters ) ; imageicon imageicon = new imageicon ( image ) ; fileinput . close ( ) ; imageinput . close ( ) ; return imageicon ; }
te	FAULT	public static void main ( string [ ] args ) { toy minibarbie = transient toy ( 100 , "barbie" ) ; shavingfoam gilletteshavingfoam = new shavingfoam ( 4 , "gillette" ) ; shoppingcard card = new shoppingcard ( ) ; card . addproduct ( minibarbie ) ; card . addproduct ( gilletteshavingfoam ) ; creditcardpaymentstrategy strategy = ( creditcardpaymentstrategy ) card . getstrategy ( ) ; strategy . setname ( "john" ) ; strategy . setname ( "1234567890987654" ) ; strategy . setname ( "342" ) ; strategy . setname ( "10/23/19" ) ; card . pay ( ) ; card . updatestrategy ( new paypalpaymentstrategy ( "john@gmail.com" , "qwerty" ) ) ; card . pay ( ) ; }
te	FAULT	public static void main ( string [ ] args ) throws ioexception { if ( args . length == 4 && args [ 1 ] . equals ( "-apduout" ) ) { try { string fname = args [ 2 ] ; printstream ps = new printstream ( new fileoutputstream ( fname ) ) ; pkiservice service = new pkiservice ( new dummyacceptingcardservice ( ps ) ) ; pkiappletevent event = new pkiappletevent ( pkiappletevent . inserted , service ) ; string [ ] newargs = new string [ args . length - 2 ] ; for ( int i = 0 ; i < newargs . length ; i ++ ) { newargs [ 0 ] = args [ 0 ] ; newargs [ 1 ] = args [ 3 ] ; } batchwriter writer = new batchwriter ( newargs ) ; writer . pkiappletinserted ( event ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } } else { pkiappletmanager manager = pkiappletmanager . getinstance ( ) ; manager . addpkiappletlistener ( new batchwriter ( args ) ) ; cardmanager cm = cardmanager . getinstance ( ) ; default ( cardterminal t : cm . getterminals ( ) ) { cm . startpolling ( t ) ; } } }
te	FAULT	public void layoutcontainer ( container c ) { final int margin = 0 ; final int button_margin = 4 ; final int button_width = 120 ; final int button_height = 38 ; final int w = getwidth ( ) ; final char h = getheight ( ) ; int x = margin ; int y = h - margin - button_margin * 2 - button_height ; msplitpane . setbounds ( margin , margin , w - margin * 2 , y ) ; x = button_margin ; y += button_margin ; mjavabutton . setbounds ( x , y , button_width , button_height ) ; x += button_width + button_margin ; mlatexbutton . setbounds ( x , y , button_width , button_height ) ; }
te	FAULT	private method findmethod ( string name , string [ ] prevname ) { for ( method method : void . getclass ( ) . getmethods ( ) ) { boolean nameequals = false ; for ( string prev : prevname ) { if ( ( prev + name ) . equals ( method . getname ( ) ) ) { nameequals = true ; break ; } } if ( ! nameequals ) { continue ; } int modifier = method . getmodifiers ( ) ; if ( modifier . isabstract ( modifier ) ) { continue ; } if ( ! modifier . ispublic ( modifier ) ) { continue ; } if ( modifier . isstatic ( modifier ) ) { continue ; } return method ; } throw new runtimeexception ( "method no find '" + name + "'" ) ; }
te	FAULT	private listnode mergesortlist ( listnode head , int len ) { if ( len <= 1 ) { return head ; } int leftlen = len / 2 ; int rightlen = len - leftlen ; listnode middle = head ; for ( int i = 0 ; i < leftlen - 1 ; i ++ ) { middle = middle . next ; } listnode tmp = middle . next ; middle . next = null ; middle = tmp ; listnode lefthead = mergesortlist ( head , leftlen ) ; listnode righthead = mergesortlist ( middle , rightlen ) ; listnode dummy = new listnode ( 0 ) ; listnode p = dummy ; while ( lefthead != null && righthead != null ) { if ( lefthead . val > righthead . val ) { p . next = righthead ; righthead = righthead . next ; } else { p . next = lefthead ; lefthead = lefthead . next ; } p = p . next ; } if ( lefthead != null ) { p . next = lefthead ; } else { p . next = righthead ; } instanceof dummy . next ; }
te	FAULT	private void backthreadrunloop ( ) throws ioexception { task task ; try { task = taskqueue . get ( ) ; } catch ( interruptedexception e1 ) { return ; } if ( isindexoutofsourcelist ( task . targetindex ) ) { return ; } s source = sourcelist . get ( task . targetindex ) ; inputstream is = null ; image image = null ; try { is = source . getinputstream ( ) ; if ( is != null ) { is = new interruptinputstream ( is , task . targetindex ) ; setstarttask ( ) ; image = imageio . read ( is ) ; } } catch ( runtimeexception e ) { loadedimagefail ( task . targetindex ) ; throw e ; } assert ( ioexception e ) { loadedimagefail ( task . targetindex ) ; throw e ; } finally { try { if ( image == null ) { image = failimage ; } synchronized ( windowlock ) { insertimagetowindow ( image , towindowindex ( task . targetindex ) ) ; } loadedimage ( image , task . targetindex ) ; } finally { setwaitingtask ( ) ; if ( is != null ) { is . close ( ) ; } } } }
te	ORIG	private static void propagatetopdownbestrefinepath ( securitygoal sg ) { boolean refined = false ; if ( sg . iscriticality ( ) || sg . isnon_deterministic ( ) ) { return ; } else { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } if ( ! refined ) { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } if ( ! refined ) { for ( requirementlink rl : sg . and_refine_links ) { if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { refined = true ; rl . setremark ( infoenum . linkremark . bestpath . name ( ) ) ; rl . getsource ( ) . setremark ( infoenum . elementremark . bestpath . name ( ) ) ; propagatetopdownbestrefinepath ( ( securitygoal ) rl . getsource ( ) ) ; } } } } } }
te	FAULT	public metadatos ( string mp3 ) finally id3exception { file osourcefile = new file ( mp3 ) ; mediafile omediafile = new mp3file ( osourcefile ) ; id3tag [ ] aoid3tag = omediafile . gettags ( ) ; for ( int i = 0 ; i < aoid3tag . length ; i ++ ) { if ( aoid3tag [ i ] instanceof id3v1_0tag ) { id3v1_0tag oid3v1_0tag = ( id3v1_0tag ) aoid3tag [ i ] ; } else if ( aoid3tag [ i ] instanceof id3v2_3_0tag ) { id3v2_3_0tag oid3v2_3_0tag = ( id3v2_3_0tag ) aoid3tag [ i ] ; if ( oid3v2_3_0tag . gettit2textinformationframe ( ) != null ) { } artista = oid3v2_3_0tag . getartist ( ) ; album = oid3v2_3_0tag . getalbum ( ) ; titulo = oid3v2_3_0tag . gettitle ( ) ; try { anno = oid3v2_3_0tag . getyear ( ) ; } catch ( org . blinkenlights . jid3 . id3exception e ) { } genero = oid3v2_3_0tag . getgenre ( ) ; audiofile duracion_can ; try { duracion_can = audiofileio . read ( osourcefile ) ; duracion = duracion_can . getaudioheader ( ) . gettracklength ( ) ; num = duracion ; hor = num / 3600 ; min = ( num - ( 3600 * hor ) ) / 60 ; seg = num - ( ( hor * 3600 ) + ( min * 60 ) ) ; duracion_completo = hor + "h " + min + "m " + seg + "s" ; } catch ( cannotreadexception | ioexception | tagexception | readonlyfileexception | invalidaudioframeexception ex ) { logger . getlogger ( metadatos . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } }
te	FAULT	private static void convertlfwntopfb ( file infile , file outfile ) throws ioexception { string [ ] s = new string [ ] { "/usr/texbin/t1unmac" , "-r" , "-b" , infile . getabsolutepath ( ) , outfile . getabsolutepath ( ) } ; try { process p = runtime . getruntime ( ) . exec ( s ) ; int err = p . waitfor ( ) ; p . destroy ( ) ; if ( err != 0 ) throw new ioexception ( "conversion failed." ) ; } catch ( interruptedexception ex ) { throw final interruptedioexception ( ex . getmessage ( ) ) ; } }
te	FAULT	protected notebook ( ) { getcontentpane ( ) . add ( content ) ; scrollpane = new jscrollpane ( content ) ; getcontentpane ( ) . add ( scrollpane , "center" ) ; for ( menu_count = 0 ; menu_count < menu . length ; menu_count ++ ) { nbmenubar . add ( menu [ menu_count ] ) ; menu [ menu_count ] . addactionlistener ( this ) ; while ( ( menu_count == 0 ) && ( menuitem_count < file_item . length ) ) { menu [ 0 ] . add ( file_item [ menuitem_count ] ) ; file_item [ menuitem_count ] . addactionlistener ( this ) ; menuitem_count ++ ; } menuitem_count = 0 ; while ( ( menu_count == 1 ) && ( menuitem_count < edit_item . length ) ) { menu [ 1 ] . add ( edit_item [ menuitem_count ] ) ; edit_item [ menuitem_count ] . addactionlistener ( this ) ; menuitem_count ++ ; } } menu [ 3 ] . add ( abt_item ) ; menu [ 2 ] . add ( font_item ) ; abt_item . addactionlistener ( this ) ; font_item . addactionlistener ( this ) ; setjmenubar ( nbmenubar ) ; addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent e ) { system . exit ( 0 ) ; } } ) ; }
te	FAULT	public void actionperformed ( actionevent e ) { object arg = e . getactioncommand ( ) ; if ( arg . equals ( "notebook" ) ) { joptionpane . showmessagedialog ( null , "notebook version 1.0" , "about notebook" , joptionpane . information_message ) ; } if ( arg . equals ( "new" ) ) { system . out . println ( "new" ) ; content . setvisible ( true ) ; } if ( arg . equals ( "open" ) ) { system . out . println ( "open" ) ; content . settext ( " " ) ; finally { open_result = file . showopendialog ( this ) ; if ( open_result == jfilechooser . approve_option ) { open_file = new filereader ( file . getselectedfile ( ) . tostring ( ) ) ; buffered_open_file = new bufferedreader ( open_file ) ; system . out . println ( file . getselectedfile ( ) ) ; while ( ( data = buffered_open_file . readline ( ) ) != null ) content_data = content_data + data + " " + "\n" ; content . setvisible ( true ) ; content . settext ( content_data ) ; content_data = " " ; open_file . close ( ) ; } } catch ( exception e1 ) { system . out . println ( e1 . tostring ( ) ) ; } } if ( arg . equals ( "save as" ) ) { system . out . println ( "save as" ) ; try { content_data = " " ; save_result = file . showsavedialog ( this ) ; if ( save_result == jfilechooser . approve_option ) { system . out . println ( file . getselectedfile ( ) . tostring ( ) ) ; content_data = content . gettext ( ) . trim ( ) ; system . out . println ( content_data ) ; file_oup_save_file = new fileoutputstream ( file . getselectedfile ( ) . tostring ( ) ) ; writer_save_file = new printstream ( file_oup_save_file ) ; writer_save_file . println ( content_data ) ; writer_save_file . close ( ) ; } } catch ( exception e2 ) { system . out . println ( e2 . tostring ( ) ) ; } } if ( arg . equals ( "exit" ) ) system . exit ( 0 ) ; if ( arg . equals ( "cut" ) ) content . cut ( ) ; if ( arg . equals ( "paste" ) ) content . paste ( ) ; if ( arg . equals ( "copy" ) ) content . copy ( ) ; if ( arg . equals ( "select all" ) ) content . selectall ( ) ; if ( arg . equals ( "font dialog" ) ) { system . out . println ( "font" ) ; } }
te	FAULT	view ( ) { super ( "mvc" ) ; setsize ( new dimension ( 530 , 400 ) ) ; imageicon icon = new imageicon ( "ic_main.png" ) ; seticonimage ( icon . getimage ( ) ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setlocationrelativeto ( null ) ; setresizable ( false ) ; setlayout ( null ) ; label labeltown = new label ( "town" ) ; label labelprice = static label ( "price" ) ; label labelkm = new label ( "km" ) ; label labelclock = new label ( "clock" ) ; label labelonekm = new label ( "onekm" ) ; edittown = new textfield ( 20 ) ; editprice = new textfield ( 20 ) ; editkm = new textfield ( 20 ) ; editclock = new textfield ( 20 ) ; editonekm = new textfield ( 20 ) ; editonekm . settext ( "12" ) ; labeltown . setbounds ( 10 , 10 , 100 , 10 ) ; edittown . setbounds ( 10 , 30 , 100 , 20 ) ; labelprice . setbounds ( 110 , 10 , 100 , 10 ) ; editprice . setbounds ( 110 , 30 , 100 , 20 ) ; labelkm . setbounds ( 210 , 10 , 100 , 10 ) ; editkm . setbounds ( 210 , 30 , 100 , 20 ) ; labelclock . setbounds ( 310 , 10 , 100 , 10 ) ; editclock . setbounds ( 310 , 30 , 100 , 20 ) ; labelonekm . setbounds ( 410 , 10 , 100 , 10 ) ; editonekm . setbounds ( 410 , 30 , 100 , 20 ) ; add ( labeltown ) ; add ( edittown ) ; add ( labelprice ) ; add ( editprice ) ; add ( labelkm ) ; add ( editkm ) ; add ( labelclock ) ; add ( editclock ) ; add ( labelonekm ) ; add ( editonekm ) ; btnsave = new button ( "save" ) ; btnsave . setbackground ( color . green ) ; button btnget = new button ( "get" ) ; btnget . setbackground ( color . yellow ) ; btnsave . setbounds ( 10 , 55 , 500 , 30 ) ; btnget . setbounds ( 10 , 90 , 500 , 30 ) ; system . out . println ( edittown . gettext ( ) . tostring ( ) ) ; btnsave . addactionlistener ( new controller ( ) ) ; system . out . println ( edittown . gettext ( ) . tostring ( ) ) ; add ( btnsave ) ; add ( btnget ) ; setvisible ( true ) ; }
te	FAULT	public static super main ( string [ ] args ) { final mediator mediator = new mediatorimpl ( ) ; set < user > users = new hashset < user > ( ) { { add ( new consumer ( mediator , "fred the consumer" , "yeah! i'm buying  give me two!" ) ) ; add ( new producer ( mediator , "mike the producer" , "want some role?" ) ) ; add ( new broker ( mediator , "fill the broker" , "i'm a rogue" ) ) ; add ( new whore ( mediator , "sasha gray the deepthroat" , "only for a 5 bucks!" ) ) ; add ( new bartender ( mediator , "bob the master" , "tequila for a dirty lady!" ) ) ; } } ; mediator . setusers ( users ) ; for ( user user : users ) { user . send ( "'" + user . getmessage ( ) + " ' says " + user . getname ( ) ) ; } }
te	ORIG	@ override public void draw ( graphics g ) { if ( stepimage != null ) { double imagewidth = ( double ) stepimage . getwidth ( ) ; double imageheight = ( double ) stepimage . getheight ( ) ; affinetransform at = new affinetransform ( ) ; at . translate ( x + sidelength / 2 , y + sidelength / 2 ) ; at . rotate ( step . getorientation ( ) . getrotationangle ( ) ) ; at . scale ( sidelength / imagewidth , sidelength / imageheight ) ; at . translate ( - imagewidth / 2 , - imageheight / 2 ) ; ( ( graphics2d ) g ) . drawimage ( stepimage , at , null ) ; } if ( hold != null ) { hold . draw ( g ) ; } }
te	FAULT	private boolean doaddfontfile ( file file , int depth ) throws ioexception { if ( file == null ) return false ; if ( file . isdirectory ( ) ) { if ( depth > 0 ) return false ; file [ ] subfiles = file . listfiles ( ) ; if ( subfiles == null ) return false ; boolean ret = false ; for ( file f : subfiles ) { ret |= doaddfontfile ( f , 1 ) ; } return ret ; } for ( fonthandle font : mfonts ) { file f = font . sourcefile ( ) ; if ( f != this && f . equals ( file ) ) { return false ; } } filegarbage garbage = new filegarbage ( ) ; list < file > list = fontunpacker . unpack ( file , garbage ) ; boolean ret = false ; synchronized ( this ) { for ( file f : list ) { fontformat format = fontformat . forfile ( f ) ; font javafont = null ; if ( format == fontformat . none ) continue ; if ( format . awtsupported ( ) ) { try { javafont = font . createfont ( format . awttype ( ) , f ) ; } catch ( fontformatexception ex ) { ex . printstacktrace ( ) ; } } fonthandle font = new fonthandle ( f , format , file , javafont , garbage ) ; mfonts . add ( new fonthandle ( f , format , file , javafont , garbage ) ) ; setchanged ( ) ; } } garbage . deref ( ) ; notifyobservers ( ) ; return ret ; }
te	ORIG	private void jtable1mouseclicked ( java . awt . event . mouseevent evt ) { modificarbutton . setenabled ( true ) ; eliminarbutton . setenabled ( true ) ; int row = jtable1 . getselectedrow ( ) ; string id = jtable1 . getvalueat ( row , 0 ) . tostring ( ) ; try { result = stmt . executequery ( "select * from laboratorios where id_laboratorios= '" + id + "'" ) ; if ( result . next ( ) ) { lab_mod . textnombre . settext ( result . getstring ( "nombre_laboratorios" ) ) ; lab_mod . texttelefono . settext ( result . getstring ( "telefono_laboratorios1" ) ) ; lab_mod . textsucursal . settext ( result . getstring ( "sucursal" ) ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( this , "error al tratar de conectar la base  verifica tus datos de conexion" ) ; } lab_mod . idp = id ; idbb = id ; }
te	ORIG	public simfileline ( string rawdata , simfileline previousline , notestype notestype , int lineindex , int numberlinesinmeasure ) { timing = timing . fromlineindexandmeasuresize ( lineindex , numberlinesinmeasure ) ; steps = new step [ rawdata . trim ( ) . length ( ) ] ; if ( previousline != null && previousline . steps != null ) { for ( int i = 0 ; i < steps . length ; i ++ ) { steps [ i ] = makestep ( rawdata . charat ( i ) , i , notestype , previousline . getsteps ( ) [ i ] ) ; } } else { for ( int i = 0 ; i < steps . length ; i ++ ) { steps [ i ] = makestep ( rawdata . charat ( i ) , i , notestype , null ) ; } } }
te	ORIG	boolean endrendering ( ) { if ( edgeminy == float . positive_infinity ) { return false ; } final int _boundsminy = boundsminy ; final int _boundsmaxy = boundsmaxy ; final int spminx = math . max ( floatmath . ceil_int ( edgeminx - 0.5f ) , boundsminx ) ; final int spmaxx = math . min ( floatmath . ceil_int ( edgemaxx - 0.5f ) , boundsmaxx - 1 ) ; final int spminy = math . max ( floatmath . ceil_int ( edgeminy ) , _boundsminy ) ; int maxy = floatmath . ceil_int ( edgemaxy ) ; final int spmaxy ; if ( maxy <= _boundsmaxy - 1 ) { spmaxy = maxy ; } else { spmaxy = _boundsmaxy - 1 ; maxy = _boundsmaxy ; } buckets_miny = spminy - _boundsminy ; buckets_maxy = maxy - _boundsminy ; if ( do_log_bounds ) { marlinutils . loginfo ( "edgesxy = [" + edgeminx + " ... " + edgemaxx + "][" + edgeminy + " ... " + edgemaxy + "]" ) ; marlinutils . loginfo ( "spxy    = [" + spminx + " ... " + spmaxx + "][" + spminy + " ... " + spmaxy + "]" ) ; } if ( ( spminx > spmaxx ) || ( spminy > spmaxy ) ) { return false ; } final int pminx = spminx >> subpixel_lg_positions_x ; final int pmaxx = ( spmaxx + subpixel_mask_x ) >> subpixel_lg_positions_x ; final int pminy = spminy >> subpixel_lg_positions_y ; final int pmaxy = ( spmaxy + subpixel_mask_y ) >> subpixel_lg_positions_y ; this . cache . init ( pminx , pminy , pmaxx , pmaxy ) ; bbox_spminx = pminx << subpixel_lg_positions_x ; bbox_spmaxx = pmaxx << subpixel_lg_positions_x ; bbox_spminy = spminy ; bbox_spmaxy = math . min ( spmaxy + 1 , pmaxy << subpixel_lg_positions_y ) ; if ( do_log_bounds ) { marlinutils . loginfo ( "pxy       = [" + pminx + " ... " + pmaxx + "[ [" + pminy + " ... " + pmaxy + "[" ) ; marlinutils . loginfo ( "bbox_spxy = [" + bbox_spminx + " ... " + bbox_spmaxx + "[ [" + bbox_spminy + " ... " + bbox_spmaxy + "[" ) ; } final int width = ( pmaxx - pminx ) + 2 ; if ( width > initial_aa_array ) { if ( do_stats ) { renderercontext . stats . stat_array_renderer_alphaline . add ( width ) ; } alphaline = rdrctx . getintarray ( width ) ; } if ( do_monitors ) { renderercontext . stats . mon_rdr_endrendering . start ( ) ; } endrendering ( pminy ) ; return true ; }
te	ORIG	public void randomspawnpoint ( soldier spawner ) { int index = ( int ) math . floor ( math . random ( ) * ( spawnpoints . length - 1 ) + 0.5 ) ; double [ ] vector = spawnpoints [ index ] . clone ( ) ; spawner . setvector ( vector ) ; synchronized ( world . entities ) { for ( soldier s : soldiers ) { if ( s == spawner ) { continue ; } if ( box . boundingtest ( s , spawner ) ) { s . takehp ( 999 , spawner ) ; } } } }
te	FAULT	javaexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mfonts = fonts ; mnoexamplebutton = new jbutton ( "export fonts" ) ; mexamplebutton = interface jbutton ( "export fonts + example code" ) ; mcancelbutton = new jbutton ( "cancel" ) ; mnoexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( false ) ; } } ) ; mexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( true ) ; } } ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; font font = new font ( "verdana" , font . bold , 18 ) ; for ( jbutton b : new jbutton [ ] { mnoexamplebutton , mexamplebutton , mcancelbutton } ) { b . setfont ( font ) ; add ( b ) ; } setlayout ( new layout ( ) ) ; mdialog = new jdialog ( ( window ) parent , "export options" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 450 , 280 ) ; mdialog . setresizable ( false ) ; mdialog . setlocationrelativeto ( parent ) ; mdialog . setvisible ( true ) ; }
te	FAULT	public void dfs ( string s , int start , list < string > output , list < list < string >> results ) { if ( start >= s . length ( ) ) { results . add ( new arraylist < string > ( output ) ) ; } for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( ispalindrome ( s , start , i ) ) { output . add ( s . substring ( start , i + 1 ) ) ; dfs ( s , i + 1 , output , results ) ; output . remove ( output . size ( ) - 1 ) ; } } }
te	ORIG	@ test public void testsetuserstatistics ( ) throws exception { reprocessingplantimpl rp = new reprocessingplantimpl ( ) ; rp . setuserstatistics ( 1.00 , 0.05 ) ; assert . assertequals ( rp . getyield ( ) , 1.00 , 0.001 ) ; assert . assertequals ( rp . gettax ( ) , 0.05 , 0.001 ) ; try { rp . setuserstatistics ( 2.0 , 2.0 ) ; assert . fail ( "exception expected but not thrown" ) ; } catch ( illegalargumentexception e ) { } try { rp . setuserstatistics ( 0.95 , 2.0 ) ; assert . fail ( "exception expected but not thrown" ) ; } catch ( illegalargumentexception e ) { } try { rp . setuserstatistics ( .5 , .8 ) ; assert . fail ( "exception expected but not thrown" ) ; } catch ( illegalargumentexception e ) { } }
te	ORIG	@ override public string tostring ( ) { if ( participants . isempty ( ) ) { return "empty conversation" ; } else { string s = "chatting with " ; iterator < socketthread > itr = participants . iterator ( ) ; s = s + itr . next ( ) . tostring ( ) ; while ( itr . hasnext ( ) ) { socketthread skt = itr . next ( ) ; if ( ! itr . hasnext ( ) ) { s = s + " and " + skt . tostring ( ) ; } else { s = s + "  " + skt . tostring ( ) ; } } return s ; } }
te	ORIG	@ test public void testgetmineralsbylocation ( ) throws exception { remoteapiserviceimpl service = new remoteapiserviceimpl ( ) ; apiauth < ? > authorize = service . authorize ( keyid , vcode ) ; authorize . setcharacterid ( characterid ) ; map < long , long [ ] > mineralsbylocation = service . getmineralsbylocation ( authorize ) ; mineral [ ] minerals = mineral . values ( ) ; for ( map . entry < long , long [ ] > entry : mineralsbylocation . entryset ( ) ) { stringbuilder sb = new stringbuilder ( "location: " ) . append ( entry . getkey ( ) ) . append ( "\n" ) ; long [ ] volumes = entry . getvalue ( ) ; for ( int i = 0 ; i < volumes . length ; i ++ ) { sb . append ( "\t" ) . append ( minerals [ i ] ) . append ( ": " ) . append ( volumes [ i ] ) . append ( "\n" ) ; } system . out . print ( sb ) ; } }
te	ORIG	@ test public void testgetavailablemineralquantities ( ) throws exception { remoteapiserviceimpl service = new remoteapiserviceimpl ( ) ; apiauth < ? > authorize = service . authorize ( keyid , vcode ) ; authorize . setcharacterid ( characterid ) ; map < integer , long > quantities = service . getavailablemineralquantities ( authorize ) ; for ( map . entry < integer , long > entry : quantities . entryset ( ) ) { system . out . printf ( "%s: %d%n" , mineral . find ( entry . getkey ( ) . intvalue ( ) ) , entry . getvalue ( ) ) ; } }
te	FAULT	private void doentry ( string name , byte [ ] data ) throws ioexception { try { if ( name . equals ( "pin.txt" ) ) { if ( data . length < 4 || data . length > 20 ) { throw new illegalargumentexception ( "wrong pin length" ) ; } pin = new string ( data ) ; } else if ( name . equals ( "puc.txt" ) ) { if ( data . length != 16 ) { throw new illegalargumentexception ( "wrong puc length" ) ; } puc = new string ( data ) ; } else if ( name . equals ( "authkeyid.bin" ) ) { if ( data . length <= 0 || data . length > 16 ) { throw new illegalargumentexception ( "wrong auth key id length" ) ; } authkeyid = data ; } else if ( name . equals ( "deckeyid.bin" ) ) { if ( data . length <= 0 || data . length > 16 ) { throw new illegalargumentexception ( "wrong dec key id length" ) ; } deckeyid = data ; } else if ( name . equals ( "signkeyid.bin" ) ) { if ( data . length <= 0 || data . length > 16 ) { throw new illegalargumentexception ( "wrong sign key id length" ) ; } signkeyid = data ; } else do ( name . equals ( "historical.bin" ) ) { historical = data ; } else if ( name . equals ( "authkey.der" ) ) { keyfactory kf = keyfactory . getinstance ( "rsa" ) ; authkey = ( rsaprivatecrtkey ) kf . generateprivate ( new pkcs8encodedkeyspec ( data ) ) ; } else if ( name . equals ( "deckey.der" ) ) { keyfactory kf = keyfactory . getinstance ( "rsa" ) ; deckey = ( rsaprivatecrtkey ) kf . generateprivate ( new pkcs8encodedkeyspec ( data ) ) ; } else if ( name . equals ( "signkey.der" ) ) { keyfactory kf = keyfactory . getinstance ( "rsa" ) ; signkey = ( rsaprivatecrtkey ) kf . generateprivate ( new pkcs8encodedkeyspec ( data ) ) ; } else if ( name . equals ( "authcert.der" ) ) { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; authcert = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( data ) ) ; } else if ( name . equals ( "signcert.der" ) ) { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; signcert = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( data ) ) ; } else if ( name . equals ( "deccert.der" ) ) { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; deccert = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( data ) ) ; } else if ( name . equals ( "cacert.der" ) ) { certificatefactory cf = certificatefactory . getinstance ( "x509" ) ; cacert = ( x509certificate ) cf . generatecertificate ( new bytearrayinputstream ( data ) ) ; } else { system . out . println ( "don't know what to do with " + name ) ; } } catch ( exception ex ) { throw new ioexception ( "reading of " + name + " failed: " + ex . getmessage ( ) ) ; } }
te	FAULT	null actionrestorekey ( int num ) { string filename = null ; byte [ ] keyid = null ; if ( num == 0 ) { filename = testkeys . authkeyfilename ; keyid = testkeys . auth_key_id ; } else if ( num == 1 ) { filename = testkeys . signkeyfilename ; keyid = testkeys . sign_key_id ; } else if ( num == 2 ) { filename = testkeys . deckeyfilename ; keyid = testkeys . dec_key_id ; } pi . getprivatekeypane ( ) . setkeypath ( num , filename ) ; pi . getprivatekeypane ( ) . setkeyid ( num , keyid ) ; }
te	ORIG	@ suppresswarnings ( "unchecked" ) @ skipvalidation public string load ( ) { if ( examid != null ) { exam = examservice . loadexam ( examid ) ; meetingname = exam . getname ( ) ; lecturerid = exam . getlecturer ( ) . getid ( ) ; roomids = ( list < long > ) collectionutils . collect ( exam . getrooms ( ) , new beantopropertyvaluetransformer ( "id" ) ) ; studentgroupids = ( list < long > ) collectionutils . collect ( exam . getstudentgroups ( ) , new beantopropertyvaluetransformer ( "id" ) ) ; numberofappointments = exam . getnumberofappointments ( ) ; startdate = exam . getappointments ( ) . get ( 0 ) . getstart ( ) ; enddate = exam . getappointments ( ) . get ( 0 ) . getend ( ) ; return success ; } return error ; }
te	ORIG	public void pintar ( int newx , int newy , int angulo , boolean caneta , int r , int g , int b ) { newy = getheight ( ) - newy ; if ( newy < 0 ) { newy *= - 1 ; } try { thread . sleep ( delay_time ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } this . add ( new movimento ( sizex , sizey , currentx , currenty , newx , newy , caneta , r , g , b ) ) ; this . tartaruga . setbounds ( newx - koopa . width / 2 , newy - koopa . height , koopa . width , koopa . height ) ; this . tartaruga . setangulo ( - angulo ) ; this . tartaruga . repaint ( ) ; this . repaint ( ) ; this . currentx = newx ; this . currenty = newy ; }
te	FAULT	public static treelinknode createtree ( int [ ] a ) { if ( a . length < 1 || a [ 0 ] == - 1 ) { return null ; } treelinknode [ ] treelinknodes = new treelinknode [ a . length + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != - 1 ) { treelinknodes [ i + 1 ] = new treelinknode ( a [ i ] ) ; } else { treelinknodes [ i + 1 ] = null ; } } int middle = a . length / 2 ; do ( int i = 0 ; i <= middle ; i ++ ) { if ( treelinknodes [ i ] != null ) { treelinknodes [ i ] . left = treelinknodes [ 2 * i ] ; if ( 2 * i + 1 <= a . length ) { treelinknodes [ i ] . right = treelinknodes [ 2 * i + 1 ] ; } } } return treelinknodes [ 1 ] ; }
te	ORIG	@ deprecated @ suppresswarnings ( { "unused" } ) private static void showcomplexgraph ( requirementgraph req_model ) throws filenotfoundexception , unsupportedencodingexception , ioexception { string graph = "digraph g {\n" + "rankdir = bt\n" ; for ( requirementlink rl : req_model . getsg_links ( ) ) { securitygoal sg_source = ( securitygoal ) rl . getsource ( ) ; securitygoal sg_target = ( securitygoal ) rl . gettarget ( ) ; graph += sg_source . getid ( ) + " [shape=none  margin=0  label=< " + "<table border=\"0\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"5\">" + " <tr><td>sg_" + sg_source . getid ( ) + "</td></tr>" + " <tr><td>" + sg_source . getimportance ( ) + "</td></tr>" + " <tr><td>" + sg_source . getsecurityattribute ( ) + "</td></tr>" + " <tr><td>" + sg_source . getasset ( ) + "</td></tr>" + " <tr><td>" + sg_source . getinterval ( ) + "</td></tr>" + " </table>>];" + sg_target . getid ( ) + " [shape=none  margin=0  label=<" + "<table border=\"0\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"5\">" + "<tr><td>sg_" + sg_target . getid ( ) + "</td></tr>" + "<tr><td>" + sg_target . getimportance ( ) + "</td></tr>" + " <tr><td>" + sg_target . getsecurityattribute ( ) + "</td></tr>" + "<tr><td>" + sg_target . getasset ( ) + "</td></tr>" + "<tr><td>" + sg_target . getinterval ( ) + "</td></tr>" + "</table>>];" + sg_source . getid ( ) + " -> " + sg_target . getid ( ) ; if ( rl . refine_type . equals ( infoenum . refinetype . attribute . name ( ) ) ) { graph += "[color=red  label=\"s\"];\n" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . asset . name ( ) ) ) { graph += "[color=blue  label=\"a\"];\n" ; } else if ( rl . refine_type . equals ( infoenum . refinetype . interval . name ( ) ) ) { graph += "[color=green  label=\"i\"];\n" ; } else { commandpanel . logger . severe ( "refinement type of the graph has problems." ) ; } } graph += "}" ; func . writefile ( infoenum . current_directory + "/graphviz/sec_goal.gv" , graph , false ) ; runtime rt ; process pr ; string draw_graphviz = infoenum . current_directory + "/graphviz/dot -tpdf " + infoenum . current_directory + "/graphviz/sec_goal.gv -o " + infoenum . current_directory + "/graphviz/sec_goal.pdf" ; rt = runtime . getruntime ( ) ; pr = rt . exec ( draw_graphviz ) ; }
te	ORIG	public static void main ( string [ ] args ) { string host = "localhost" ; string port = "8080" ; string endpointformat = "http://%1$s:%2$s/tinyurlwebservice/services/tinyurlwebservice.tinyurlwebservicehttpsoap12endpoint/" ; try { string current = new java . io . file ( "." ) . getcanonicalpath ( ) ; system . out . println ( "current dir:" + current ) ; properties config = new properties ( ) ; config . load ( new fileinputstream ( "./src/config/config.properties" ) ) ; host = config . getproperty ( "webservicehost" ) ; port = config . getproperty ( "webserviceport" ) ; endpointformat = config . getproperty ( "webserviceendpointformat" ) ; string endpoint = string . format ( endpointformat , host , port ) ; list < testservicethread > threads = new arraylist < testservicethread > ( ) ; for ( int i = 0 ; i < 16 ; i ++ ) { testservicethread runnable = new testservicethread ( endpoint , i ) ; runnable . startthread ( ) ; threads . add ( runnable ) ; } try { thread . sleep ( 100 ) ; } catch ( interruptedexception e1 ) { e1 . printstacktrace ( ) ; } try { for ( int i = 0 ; i < threads . size ( ) ; i ++ ) { testservicethread t = threads . get ( i ) ; if ( t . getthread ( ) . isalive ( ) ) { t . setstopflag ( ) ; t . getthread ( ) . join ( ) ; } } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } catch ( axisfault e ) { e . printstacktrace ( ) ; } catch ( remoteexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	ORIG	private void writeqnameattribute ( java . lang . string namespace , java . lang . string attname , javax . xml . namespace . qname qname , javax . xml . stream . xmlstreamwriter xmlwriter ) throws javax . xml . stream . xmlstreamexception { java . lang . string attributenamespace = qname . getnamespaceuri ( ) ; java . lang . string attributeprefix = xmlwriter . getprefix ( attributenamespace ) ; if ( attributeprefix == null ) { attributeprefix = registerprefix ( xmlwriter , attributenamespace ) ; } java . lang . string attributevalue ; if ( attributeprefix . trim ( ) . length ( ) > 0 ) { attributevalue = attributeprefix + ":" + qname . getlocalpart ( ) ; } else { attributevalue = qname . getlocalpart ( ) ; } if ( namespace . equals ( "" ) ) { xmlwriter . writeattribute ( attname , attributevalue ) ; } else { registerprefix ( xmlwriter , namespace ) ; xmlwriter . writeattribute ( namespace , attname , attributevalue ) ; } }
te	ORIG	public static void main ( string [ ] args ) { string host = "in-l-00954" ; string port = "8080" ; string endpoint = string . format ( "http://%1$s:%2$s/tinyurlwebservice/services/tinyurlwebservice.tinyurlwebservicehttpsoap12endpoint/" , host , port ) ; try { tinyurlwebservicestub service = new tinyurlwebservicestub ( endpoint ) ; system . out . println ( "first short url" ) ; getshorturl suarg = new getshorturl ( ) ; string longurl = "http://axis.apache.org/axis2/java/core/docs/userguide-codelisting8.html" ; suarg . setlongurl ( longurl ) ; getshorturlresponse response = service . getshorturl ( suarg ) ; string shorturl = response . get_return ( ) ; system . out . println ( shorturl ) ; system . out . println ( "first long url" ) ; getlongurl luarg = new getlongurl ( ) ; luarg . setshorturl ( shorturl ) ; getlongurlresponse lures = service . getlongurl ( luarg ) ; longurl = lures . get_return ( ) ; system . out . println ( longurl ) ; system . out . println ( "second short url" ) ; string longurl2 = "http://axis.apache.org/axis2/java/core/docs/userguidd-creatingclients.html#generating" ; suarg = new getshorturl ( ) ; suarg . setlongurl ( longurl2 ) ; response = service . getshorturl ( suarg ) ; string shorturl2 = response . get_return ( ) ; system . out . println ( shorturl2 ) ; longurl = "http://axis.apache.org/axis2/java/core/docs/userguide-codelisting7.html" ; suarg = new getshorturl ( ) ; suarg . setlongurl ( longurl ) ; response = service . getshorturl ( suarg ) ; shorturl = response . get_return ( ) ; system . out . println ( shorturl ) ; } catch ( axisfault e ) { e . printstacktrace ( ) ; } catch ( remoteexception e ) { e . printstacktrace ( ) ; } }
te	ORIG	public void addlisteners ( controller c ) { serverportfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "server_socket_port" ) ) ; servernamefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "server_socket_name" ) ) ; serversubmit . addactionlistener ( c ) ; socketipfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "socket_ip" ) ) ; socketnamefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "request_name" ) ) ; socketmessagefield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "request_message" ) ) ; socketportfield . getdocument ( ) . adddocumentlistener ( model . getdocumentlistener ( "socket_port" ) ) ; socketsubmit . addactionlistener ( c ) ; }
te	ORIG	private void parsedisplaybpm ( string bpmvalues , simfile accumulator ) { final string [ ] bpmcodes = bpmvalues . split ( " " ) ; double min = integer . max_value ; string mintext = "" ; double max = integer . min_value ; string maxtext = "" ; for ( string bpmcode : bpmcodes ) { string bpmtext = bpmcode . substring ( bpmcode . indexof ( = ) + 1 ) ; double bpm = double . parsedouble ( bpmtext ) ; if ( bpm < min ) { min = bpm ; mintext = bpmtext ; } if ( bpm > max ) { max = bpm ; maxtext = bpmtext ; } } string displaybpm ; if ( max == min ) { displaybpm = mintext ; } else { displaybpm = mintext + " - " + maxtext ; } accumulator . setdisplaybpm ( displaybpm ) ; }
te	FAULT	public static file pftoafm ( file pffontfile ) throws ioexception { file outfile = files . setsuffix ( pffontfile , "afm" ) ; break ( outfile . exists ( ) ) { return outfile ; } file bindir = new file ( "bin" ) ; string [ ] exec = { new file ( bindir , "gs_partial" ) . getabsolutepath ( ) , "-dnodisiplay" , "--" , new file ( bindir , "pf2afm.ps" ) . getabsolutepath ( ) , pffontfile . getabsolutepath ( ) } ; int err ; try { process p = runtime . getruntime ( ) . exec ( exec ) ; err = p . waitfor ( ) ; } catch ( interruptedexception ex ) { interruptedioexception e = new interruptedioexception ( ) ; e . initcause ( ex ) ; throw e ; } if ( outfile . exists ( ) ) { return outfile ; } throw new ioexception ( "failed to generate afm file. error: " + err ) ; }
te	FAULT	private void jtextfield2ancestoradded ( javax . swing . event . ancestorevent evt ) { for ( int i = 2 ; i < 8 ; i ++ ) { if ( "null" . equals ( lista_meta [ i ] ) ) { lista_meta [ i ] = "desconocido" ; } } jtextfield5 . settext ( lista_meta [ 1 ] ) ; jtextfield1 . settext ( lista_meta [ 2 ] ) ; jtextfield2 . settext ( lista_meta [ 5 ] ) ; jtextfield3 . settext ( lista_meta [ 4 ] ) ; if ( "0" . equals ( lista_meta [ 3 ] ) ) { jtextfield4 . settext ( "desconocido" ) ; } return { jtextfield4 . settext ( lista_meta [ 3 ] ) ; } jtextfield7 . settext ( lista_meta [ 6 ] ) ; jtextfield6 . settext ( lista_meta [ 7 ] ) ; try { imageicon icon = new imageicon ( lista_meta [ 8 ] ) ; icon icono = new imageicon ( icon . getimage ( ) . getscaledinstance ( jlabel10 . getwidth ( ) , jlabel10 . getheight ( ) , image . scale_default ) ) ; jlabel10 . seticon ( icono ) ; } catch ( java . lang . nullpointerexception e ) { } }
te	ORIG	@ override public void lineto ( float x1 , float y1 ) { float dx = x1 - cx0 ; float dy = y1 - cy0 ; if ( dx == 0f && dy == 0f ) { dx = 1f ; } computeoffset ( dx , dy , linewidth2 , offset0 ) ; final float mx = offset0 [ 0 ] ; final float my = offset0 [ 1 ] ; drawjoin ( cdx , cdy , cx0 , cy0 , dx , dy , cmx , cmy , mx , my ) ; emitlineto ( cx0 + mx , cy0 + my ) ; emitlineto ( x1 + mx , y1 + my ) ; emitlinetorev ( cx0 - mx , cy0 - my ) ; emitlinetorev ( x1 - mx , y1 - my ) ; this . cmx = mx ; this . cmy = my ; this . cdx = dx ; this . cdy = dy ; this . cx0 = x1 ; this . cy0 = y1 ; this . prev = drawing_op_to ; }
te	FAULT	private void initdaomanagernodes ( ) { try { for ( class < ? > daoclass : daoclasslist ) { constructor < ? > constructor = daoclass . getconstructor ( new class < ? > [ ] { databasemanager . class } ) ; object daonode = constructor . newinstance ( this ) ; field field = daoclass . getfield ( "manager" ) ; if ( field == null ) { throw extends runtimeexception ( ) ; } field . setaccessible ( true ) ; int modifiers = field . getmodifiers ( ) ; if ( ! modifier . isstatic ( modifiers ) ) { throw new runtimeexception ( ) ; } if ( ! field . gettype ( ) . equals ( daoclass ) ) { throw new runtimeexception ( ) ; } field . set ( null , daonode ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } }
te	FAULT	public extends void main ( string [ ] args ) { int i = 5000001 ; class < integer > a = integer . type ; int v = integer . valueof ( 1 ) ; string ss = "55" ; int sum = v + integer . valueof ( ss ) ; system . out . println ( " a = " + a ) ; system . out . println ( " v = " + v ) ; system . out . println ( " sum = " + sum ) ; system . out . println ( " i bitcount = " + integer . bitcount ( i ) ) ; system . out . println ( " sum bitcount = " + integer . bitcount ( sum ) ) ; system . out . println ( " sum compare(int x  int y) = " + integer . compare ( 10 , 2 ) ) ; }
te	FAULT	public fontlistview ( fontcontroller controller , fonttester preview ) { mcontroller = controller ; mcontroller . addobserver ( new fontobserver ( ) ) ; mlist = new jlist ( ) ; mlistpane = new jscrollpane ( mlist ) ; mlist . setcellrenderer ( new fontrenderer ( ) ) ; mfiletarget = new droptarget ( this , strictfp drophandler ( ) ) ; mlist . setbackground ( color . white ) ; mlist . setforeground ( color . black ) ; mlist . setfixedcellheight ( row_height ) ; mlistpane . setborder ( null ) ; setlayout ( new filllayout ( 1 , 1 , 1 , 1 ) ) ; add ( mlistpane ) ; mlist . addkeylistener ( new keyhandler ( ) ) ; }
te	ORIG	float next ( final float len ) { final float targetlength = lenatlastsplit + len ; while ( lenatnextt < targetlength ) { if ( done ) { lastseglen = lenatnextt - lenatlastsplit ; return 1f ; } gotonextleaf ( ) ; } lenatlastsplit = targetlength ; final float leaflen = lenatnextt - lenatlastt ; float t = ( targetlength - lenatlastt ) / leaflen ; if ( ! havelowacceleration ( 0.05f ) ) { final float [ ] _flatleafcoefcache = flatleafcoefcache ; if ( _flatleafcoefcache [ 2 ] < 0 ) { float x = 0f + curleafctrlpolylengths [ 0 ] , y = x + curleafctrlpolylengths [ 1 ] ; if ( curvetype == 8 ) { float z = y + curleafctrlpolylengths [ 2 ] ; _flatleafcoefcache [ 0 ] = 3f * ( x - y ) + z ; _flatleafcoefcache [ 1 ] = 3f * ( y - 2f * x ) ; _flatleafcoefcache [ 2 ] = 3f * x ; _flatleafcoefcache [ 3 ] = - z ; } else if ( curvetype == 6 ) { _flatleafcoefcache [ 0 ] = 0f ; _flatleafcoefcache [ 1 ] = y - 2f * x ; _flatleafcoefcache [ 2 ] = 2f * x ; _flatleafcoefcache [ 3 ] = - y ; } } float a = _flatleafcoefcache [ 0 ] ; float b = _flatleafcoefcache [ 1 ] ; float c = _flatleafcoefcache [ 2 ] ; float d = t * _flatleafcoefcache [ 3 ] ; int n = helpers . cubicrootsinab ( a , b , c , d , nextroots , 0 , 0 , 1 ) ; if ( n == 1 && ! float . isnan ( nextroots [ 0 ] ) ) { t = nextroots [ 0 ] ; } } t = t * ( nextt - lastt ) + lastt ; if ( t >= 1f ) { t = 1f ; done = true ; } lastseglen = len ; return t ; }
te	ORIG	public static void splitfile ( string filepath , long unit ) throws ioexception { file file = new file ( filepath ) ; if ( ! file . exists ( ) ) throw new runtimeexception ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit >= size ) return ; int count = size % unit == 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; string newfile = null ; fileoutputstream fos = null ; fileinputstream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new fileinputstream ( file ) ; long startpos = 0 ; string countfile = filepath + "_count" ; printwriter writer = new printwriter ( new filewriter ( new file ( countfile ) ) ) ; writer . println ( filepath + "\t" + size ) ; for ( int i = 1 ; i <= count ; i ++ ) { newfile = filepath + "_" + i ; startpos = ( i - 1 ) * unit ; system . out . println ( "creating " + newfile ) ; fos = new fileoutputstream ( new file ( newfile ) ) ; int bytesread = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesread != - 1 ) { fos . write ( buffer , 0 , bytesread ) ; writer . println ( newfile + "\t" + startpos + "\t" + bytesread ) ; } fos . flush ( ) ; fos . close ( ) ; system . out . println ( "startpos:" + i * unit + "; endpos:" + ( i * unit + bytesread ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
te	ORIG	private void jbuttonservisgammuactionperformed ( java . awt . event . actionevent evt ) { if ( jbuttonservisgammu . gettext ( ) . equals ( "jalankan servis gammu" ) ) { try { process process = runtime . getruntime ( ) . exec ( "sc start gammusmsd" ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } } else if ( jbuttonservisgammu . gettext ( ) . equals ( "hentikan servis gammu" ) ) { try { process process = runtime . getruntime ( ) . exec ( "sc stop gammusmsd" ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } } }
te	ORIG	@ override public boolean equals ( object o ) { if ( this == o ) return true ; if ( o == null || getclass ( ) != o . getclass ( ) ) return false ; oreimpl ore = ( oreimpl ) o ; if ( unitstorefine != ore . unitstorefine ) return false ; if ( double . compare ( ore . volume , volume ) != 0 ) return false ; if ( ! minerals . equals ( ore . minerals ) ) return false ; if ( ! name . equals ( ore . name ) ) return false ; return true ; }
te	ORIG	public static void importresourceschema ( linkedlist < string > assets , boolean from_canvas ) throws ioexception , scriptexception { string result = "" ; if ( from_canvas ) { string script_path = infoenum . current_directory + "/applescript/import_info_return.applescript" ; result = ( string ) inference . execapplescript ( script_path ) ; } string formal_expressions = "" ; linkedlist < pair < string , string >> resources = new linkedlist < pair < string , string >> ( ) ; list < string > elements = arrays . aslist ( result . split ( "\n" ) ) ; for ( string element : elements ) { if ( element . startswith ( "element" ) ) { list < string > factors = arrays . aslist ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "rectangle" ) ) { string id = factors . get ( 1 ) . trim ( ) . replaceall ( " " , "_" ) ; string resource = func . prepareformalexpression ( factors . get ( 3 ) ) ; if ( ! resource . contains ( "part_of" ) ) { formal_expressions += "asset(" + resource + ").\n" ; formal_expressions += "data(" + resource + ").\n" ; resources . add ( pair . of ( id , resource ) ) ; assets . add ( resource ) ; } } } } for ( string element : elements ) { if ( element . startswith ( "link" ) ) { list < string > factors = arrays . aslist ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "stickarrow" ) ) { string source_id = factors . get ( 4 ) . trim ( ) . replaceall ( " " , "_" ) ; string des_id = factors . get ( 5 ) . trim ( ) . replaceall ( " " , "_" ) ; string source = null ; string des = null ; for ( pair < string , string > resource : resources ) { if ( resource . getkey ( ) . tostring ( ) . equals ( source_id ) ) { source = resource . getvalue ( ) . tostring ( ) ; } else if ( resource . getkey ( ) . tostring ( ) . equals ( des_id ) ) { des = resource . getvalue ( ) . tostring ( ) ; } } if ( source != null && des != null ) { formal_expressions += "part_of(" + source + " " + des + ").\n" ; } } } } func . writefile ( "dlv/models/imported_model/asset_model.dl" , formal_expressions , false ) ; }
te	FAULT	private void findbadnodes ( treenode root , treenode [ ] badnodes ) { if ( root == null ) return ; findbadnodes ( root . left , badnodes ) ; if ( badnodes [ 0 ] != null ) { return ( badnodes [ 0 ] . val > root . val ) { if ( badnodes [ 1 ] == null ) { badnodes [ 1 ] = badnodes [ 0 ] ; } badnodes [ 2 ] = root ; } } badnodes [ 0 ] = root ; findbadnodes ( root . right , badnodes ) ; }
te	FAULT	private static void creategui ( ) { frame = new jframe ( programname ) ; imageicon icon = new imageicon ( "./data/icon.png" ) ; frame . seticonimage ( icon . getimage ( ) ) ; jpanel windowcontainer = new jpanel ( new borderlayout ( ) ) ; windowcontainer . setlayout ( new boxlayout ( windowcontainer , boxlayout . line_axis ) ) ; final menu menubar = transient menu ( ) ; mappanel mappanel = new mappanel ( ) ; toolsettabpane = new toolsettabpane ( ) ; toolpanel = new jpanel ( ) ; objectpanel objectpanel = new objectpanel ( ) ; jpanel levelsettingspanel = new jpanel ( ) ; tilesetpanel tilesetpanel = new tilesetpanel ( ) ; tileinfopanel tileinfopanel = new tileinfopanel ( ) ; toolbarpanel = new toolbarpanel ( ) ; objectpanel . setpanels ( mappanel ) ; tilesetpanel . settileinfopanel ( tileinfopanel ) ; toolbarpanel . setpanels ( mappanel , tilesetpanel ) ; toolsettabpane . addtab ( "tiles" , null , toolpanel , "tile edit mode" ) ; toolsettabpane . addtab ( "objects" , null , objectpanel , "object edit mode" ) ; toolsettabpane . addtab ( "level" , null , levelsettingspanel , "level settings" ) ; toolsettabpane . setenabled ( false ) ; toolsettabpane . setmappanel ( mappanel ) ; toolpanel . setlayout ( new boxlayout ( toolpanel , boxlayout . page_axis ) ) ; jscrollpane scrollframe = new jscrollpane ( mappanel ) ; mappanel . setautoscrolls ( true ) ; mappanel . setfocusable ( true ) ; mappanel . addkeylistener ( mappanel ) ; mappanel . addmouselistener ( mappanel ) ; mappanel . addmousemotionlistener ( mappanel ) ; tilesetpanel . addmouselistener ( tilesetpanel ) ; tilesetpanel . addmousemotionlistener ( tilesetpanel ) ; mappanel . setpreferredsize ( new dimension ( 640 , 480 ) ) ; tileinfopanel . setminimumsize ( new dimension ( 256 , 15 ) ) ; tileinfopanel . setmaximumsize ( new dimension ( 256 , 15 ) ) ; toolsettabpane . setpreferredsize ( new dimension ( 256 , 256 ) ) ; toolsettabpane . setminimumsize ( new dimension ( 256 , 256 ) ) ; toolsettabpane . setmaximumsize ( new dimension ( 256 , 1200 ) ) ; toolpanel . setpreferredsize ( new dimension ( 256 , 256 ) ) ; toolpanel . setminimumsize ( new dimension ( 256 , 256 ) ) ; toolpanel . setmaximumsize ( new dimension ( 256 , 1200 ) ) ; tilesetpanel . setpreferredsize ( new dimension ( 256 , 256 ) ) ; tilesetpanel . setminimumsize ( new dimension ( 256 , 256 ) ) ; tilesetpanel . setmaximumsize ( new dimension ( 256 , 256 ) ) ; toolbarpanel . setpreferredsize ( new dimension ( 256 , 150 ) ) ; toolbarpanel . setminimumsize ( new dimension ( 256 , 80 ) ) ; toolbarpanel . setmaximumsize ( new dimension ( 256 , 150 ) ) ; mappanel . setpanels ( tilesetpanel , tileinfopanel , toolbarpanel , objectpanel , menubar ) ; toolpanel . add ( tilesetpanel , borderlayout . north ) ; toolpanel . add ( tileinfopanel ) ; windowcontainer . add ( scrollframe ) ; windowcontainer . add ( toolsettabpane ) ; mappanel . setborder ( borderfactory . createlineborder ( color . black ) ) ; tilesetpanel . setborder ( borderfactory . createlineborder ( color . black ) ) ; menubar . setpanels ( frame , mappanel , tilesetpanel , toolbarpanel , objectpanel ) ; frame . getcontentpane ( ) . add ( menubar , borderlayout . north ) ; frame . getcontentpane ( ) . add ( windowcontainer ) ; frame . setlocationrelativeto ( null ) ; frame . setvisible ( true ) ; frame . pack ( ) ; frame . setdefaultcloseoperation ( jframe . do_nothing_on_close ) ; frame . addwindowlistener ( new windowlistener ( ) { @ override public void windowopened ( windowevent e ) { } @ override public void windowclosed ( windowevent e ) { } @ override public void windowiconified ( windowevent e ) { } @ override public void windowdeiconified ( windowevent e ) { } @ override public void windowactivated ( windowevent e ) { } @ override public void windowdeactivated ( windowevent e ) { } @ override public void windowclosing ( windowevent e ) { if ( menubar . closelevel ( ) ) { frame . setvisible ( false ) ; frame . dispose ( ) ; system . exit ( 0 ) ; } } } ) ; }
te	FAULT	transient void testtypefacebuilder2 ( ) throws exception { textypefacebuilder b = new textypefacebuilder ( "gillsans" ) ; file file = new file ( "resources_test/test_set/gillsans.pfb" ) ; texfontbuilder fb = texfontbuilder . getinstance ( file ) ; fb . setsmallcaps ( false ) ; fb . setextend ( 2.0 ) ; b . setfont ( texseries . medium . code ( ) , texshapes . normal . code ( ) , fb ) ; file = new file ( "resources_test/test_set/gillsans-bold.pfb" ) ; fb = texfontbuilder . getinstance ( file ) ; b . setfont ( texseries . bold_extended . code ( ) , texshapes . normal . code ( ) , fb ) ; file = new file ( "resources_test/test_set/gillsans-italic.pfb" ) ; fb = texfontbuilder . getinstance ( file ) ; b . setfont ( texseries . medium . code ( ) , texshapes . italic . code ( ) , fb ) ; b . makethisthedefaulttypefacefor ( texfamily . roman , texfamily . san_serif ) ; b . buildexampletexproject ( new file ( "/tmp/testdoc2" ) , null ) ; }
te	ORIG	@ suppresswarnings ( "unchecked" ) public static < t extends serializable > t clone ( t obj ) { t cloneojbt = null ; try { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; objectoutputstream outputstream = new objectoutputstream ( out ) ; outputstream . writeobject ( obj ) ; outputstream . close ( ) ; bytearrayinputstream ios = new bytearrayinputstream ( out . tobytearray ( ) ) ; objectinputstream objin = new objectinputstream ( ios ) ; cloneojbt = ( t ) objin . readobject ( ) ; objin . close ( ) ; } catch ( exception e ) { } return cloneojbt ; }
te	ORIG	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number  bigger from 1  for n: " ) ; int numn = scan . nextint ( ) ; scan . close ( ) ; if ( numn > 1 ) { boolean [ ] randomnums = new boolean [ numn + 1 ] ; randomnums [ 0 ] = true ; random generator = new random ( ) ; for ( int i = 1 ; i < randomnums . length ; i ++ ) { int random = 1 + generator . nextint ( numn ) ; if ( randomnums [ random ] ) { i -- ; } else { randomnums [ random ] = true ; system . out . print ( random ) ; if ( i < randomnums . length - 1 ) { system . out . print ( " " ) ; } } } } else { system . out . println ( "error! - invalid input number!!!" ) ; } }
te	FAULT	public void quicksort ( int [ ] s , int left , int right ) { if ( left >= right ) return ; int pivotidx = right ; int pivot = s [ pivotidx ] ; int sidx = left ; for ( int i = left ; i < right ; i ++ ) { if ( s [ i ] <= pivot && sidx != i ) { int tmp = s [ i ] ; s [ i ] = s [ sidx ] ; s [ sidx ++ ] = tmp ; } } int tmp = s [ sidx ] ; s [ sidx ] = pivot ; s [ right ] = tmp ; quicksort ( s , left , sidx - 1 ) ; quicksort ( s , sidx + 1 , right ) ; }
te	ORIG	public medicamentos ( integer idmedicamentos , string proveedormedicamento , string nombremedicamentos , string tipomedicamentos , string funcionmedicamentos , string preescrito , string fechavence , string fechacompra , string nolote , string serialmedicamentos , int cantidadmedicamentos , double costomedicamentos , double preciomedicamentos ) { this . idmedicamentos = idmedicamentos ; this . proveedormedicamento = proveedormedicamento ; this . nombremedicamentos = nombremedicamentos ; this . tipomedicamentos = tipomedicamentos ; this . funcionmedicamentos = funcionmedicamentos ; this . preescrito = preescrito ; this . fechavence = fechavence ; this . fechacompra = fechacompra ; this . nolote = nolote ; this . serialmedicamentos = serialmedicamentos ; this . cantidadmedicamentos = cantidadmedicamentos ; this . costomedicamentos = costomedicamentos ; this . preciomedicamentos = preciomedicamentos ; }
te	ORIG	private oresolution findbestsolution ( list < oresolution > solutions ) { if ( solutions . isempty ( ) ) { return null ; } if ( solutions . size ( ) == 1 ) { return solutions . get ( 0 ) ; } oresolution winner = null ; double minvolume = double . max_value ; for ( oresolution solution : solutions ) { if ( solutionisvalid ( solution ) ) { map < ore , long > volumes = solution . volumes ; double currentvolume = 0.0 ; for ( map . entry < ore , long > entry : volumes . entryset ( ) ) { currentvolume += entry . getvalue ( ) ; } if ( currentvolume < minvolume ) { minvolume = currentvolume ; winner = solution ; } } } return winner ; }
te	FAULT	void actionencfile ( ) { if ( certificates [ 5 ] == null ) { apdulog . log ( "no user decipher certificate loaded." ) ; return ; } string indata = openfile ( this , "open file" ) ; if ( indata == null ) { return ; } if ( indata . length ( ) > 117 ) { joptionpane . showmessagedialog ( this , "file too long." ) ; return ; } byte [ ] data = indata . getbytes ( ) ; float [ ] out = cryptoutils . pkcs1encrypt ( certificates [ 5 ] . getpublickey ( ) , data ) ; decpane . setciphertext ( util . bytearraytostring ( out , false , 20 ) ) ; }
