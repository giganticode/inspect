tr	1	private void initcomponents ( ) { this . blackbox = new jpanel ( ) ; this . redbox = new jpanel ( ) ; this . bluebox = new jpanel ( ) ; this . greenbox = new jpanel ( ) ; this . yellowbox = new jpanel ( ) ; this . orangebox = new jpanel ( ) ; this . letterlabel = new letterpanel ( ) ; this . colourspanel = new jpanel ( ) ; this . blacklabel = new jlabel ( ) ; this . redlabel = new jlabel ( ) ; this . greenlabel = new jlabel ( ) ; this . bluelabel = new jlabel ( ) ; this . yellowlabel = new jlabel ( ) ; this . orangelabel = new jlabel ( ) ; this . colourspanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( blackbox , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . colourspanel . add ( blacklabel , c ) ; c . gridx = 0 ; c . gridy = 1 ; this . colourspanel . add ( redbox , c ) ; c . gridx = 1 ; c . gridy = 1 ; this . colourspanel . add ( redlabel , c ) ; c . gridx = 0 ; c . gridy = 2 ; this . colourspanel . add ( greenbox , c ) ; c . gridx = 1 ; c . gridy = 2 ; this . colourspanel . add ( greenlabel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( bluebox , c ) ; c . gridx = 3 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( bluelabel , c ) ; c . gridx = 2 ; c . gridy = 1 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( yellowbox , c ) ; c . gridx = 3 ; c . gridy = 1 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( yellowlabel , c ) ; c . gridx = 2 ; c . gridy = 2 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( orangebox , c ) ; c . gridx = 3 ; c . gridy = 2 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( orangelabel , c ) ; this . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; this . blackbox . setbackground ( systemproperties . colour_map . get ( colourtype . black ) ) ; this . blackbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blackbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . redbox . setbackground ( systemproperties . colour_map . get ( colourtype . red ) ) ; this . redbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . redbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . greenbox . setbackground ( systemproperties . colour_map . get ( colourtype . green ) ) ; this . greenbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . greenbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . bluebox . setbackground ( systemproperties . colour_map . get ( colourtype . blue ) ) ; this . bluebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . bluebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . yellowbox . setbackground ( systemproperties . colour_map . get ( colourtype . yellow ) ) ; this . yellowbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . yellowbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . orangebox . setbackground ( systemproperties . colour_map . get ( colourtype . orange ) ) ; this . orangebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . orangebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . letterlabel . setbackground ( systemproperties . white ) ; this . letterlabel . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blacklabel . settext ( "s" ) ; this . blacklabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . redlabel . settext ( "r" ) ; this . redlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . greenlabel . settext ( "g" ) ; this . greenlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . bluelabel . settext ( "b" ) ; this . bluelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . yellowlabel . settext ( "y" ) ; this . yellowlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . orangelabel . settext ( "o" ) ; this . orangelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . setjmenubar ( stroopmenu ) ; this . add ( this . letterlabel , borderlayout . center ) ; this . add ( this . colourspanel , borderlayout . south ) ; this . settitle ( "stroop test" ) ; this . addcomponentlistener ( this ) ; this . setpreferredsize ( new dimension ( 800 , 600 ) ) ; this . setlocation ( ( systemproperties . screen_width / 2 ) - 400 , ( systemproperties . screen_height / 2 ) - 300 ) ; this . pack ( ) ; }
tr	3	@ override protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { request . setcharacterencoding ( "utf-8" ) ; response . setcontenttype ( "text/xml;charset=utf-8" ) ; string pillname = request . getparameter ( "pillname" ) ; string pillnum = request . getparameter ( "pillnum" ) ; string pillid = request . getparameter ( "pillid" ) ; string standard = request . getparameter ( "standard" ) ; string price = request . getparameter ( "price" ) ; string number = request . getparameter ( "number" ) ; string pilltype = request . getparameter ( "pilltype" ) ; double priceo = 0.00 ; int numbero = 0 ; inforeg ptreg = new inforeg ( ) ; boolean result = false ; if ( pillnum == null || pillnum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } result = ptreg . pillinsert ( pillname , standard , priceo , numbero , pillid , pilltype ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/pillsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parsedouble ( request . getparameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = integer . parseint ( request . getparameter ( "number" ) ) ; } result = ptreg . pillupdate ( pillnum , pillname , standard , priceo , numbero , pillid , pilltype ) ; printwriter out = response . getwriter ( ) ; if ( result ) { response . sendredirect ( request . getcontextpath ( ) + "/infosearch/commonsearch/pillsearch.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } } }
tr	2	@ override public object [ ] [ ] getall ( ) { daofactory factory = daofactory . getdaofactory ( ) ; teacherdao dao = factory . getteacherdao ( ) ; list < teacher > teachers = dao . selectall ( ) ; object [ ] [ ] rowdata = new object [ teachers . size ( ) ] [ 4 ] ; for ( int i = 0 ; i < teachers . size ( ) ; i ++ ) { teacher teacher = teachers . get ( i ) ; rowdata [ i ] [ 0 ] = teacher . getcode ( ) ; rowdata [ i ] [ 1 ] = teacher . getnames ( ) ; rowdata [ i ] [ 2 ] = dateformathelper . format ( teacher . getbirthday ( ) ) ; rowdata [ i ] [ 3 ] = teacher . getemail ( ) ; } return rowdata ; }
tr	5	public static pldictionary decodepldictionary ( xmlfile xml ) { if ( "dict" . equals ( xml . getme ( ) . getnodename ( ) ) ) { pldictionary dict = new pldictionary ( ) ; xmlfile [ ] keys = xml . gets ( "key" ) ; if ( keys . length > 0 ) { for ( int i = 0 ; i < keys . length ; i ++ ) { xmlfile key = keys [ i ] ; node value = ( node ) key . getme ( ) . getnextsibling ( ) ; if ( null == value ) { continue ; } dict . put ( key . gettext ( ) , plistdecoder . decode ( new xmlfile ( ( element ) value ) ) ) ; } return dict ; } } return null ; }
tr	3	public final void loadterrainblock ( byte blockdata [ ] , int blocky , int blockx , int k , int l , collisionmap collisionmap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tilex = 0 ; tilex < 64 ; tilex ++ ) { for ( int tiley = 0 ; tiley < 64 ; tiley ++ ) if ( blockx + tilex > 0 && blockx + tilex < 103 && blocky + tiley > 0 && blocky + tiley < 103 ) collisionmap [ plane ] . clippingdata [ blockx + tilex ] [ blocky + tiley ] &= feffffff ; } } buffer stream = new buffer ( blockdata ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tilex = 0 ; tilex < 64 ; tilex ++ ) { for ( int tiley = 0 ; tiley < 64 ; tiley ++ ) loadterraintile ( tiley + blocky , l , stream , tilex + blockx , plane , 0 , k ) ; } } }
tr	4	public static void main ( string [ ] args ) { callparser parser = new callparser ( ) ; parser . addline ( 0 , "static sequence [pipe]function" ) ; parser . addline ( 1 , "[o]:[p] s{var:i32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addline ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addline ( 3 , "[a]asd[b]op[p]" ) ; parser . addline ( 4 , ":elseif{something}:" ) ; parser . addline ( 5 , ":elseif{somethingelse}: " ) ; parser . addline ( 6 , "static sequence2" ) ; parser . addline ( 7 , ":end" ) ; parser . addline ( 8 , "execute{[a]:[>] [<  \" is sweet\"]println  lol}" ) ; for ( component com : parser . separatecomponents ( ) ) system . out . print ( com . type + " " ) ; system . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( parsedcall call : parser . calls ) { if ( call . isblockend ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { system . out . print ( "  " ) ; } if ( call . isblockend ) system . out . print ( ":" ) ; system . out . print ( "[" ) ; for ( string param : call . inparams ) { system . out . print ( param + " " ) ; } system . out . print ( "]" ) ; system . out . print ( call . callname ) ; if ( call . confnodes . length > 0 ) { system . out . print ( "{ " ) ; for ( string param : call . confnodes ) { system . out . print ( param + " " ) ; } system . out . print ( "}" ) ; } system . out . print ( "[" ) ; for ( string param : call . outparams ) { system . out . print ( param + " " ) ; } system . out . print ( "]" ) ; if ( call . isblockstart ) { indent ++ ; system . out . print ( ":" ) ; } system . out . println ( ) ; } }
tr	3	public void run ( string product ) { int i = bidts . size ( ) - 1 ; if ( i < 400 ) { return ; } marketdata currbar = this . bidts . get ( i ) ; marketdata prevbar = this . bidts . get ( i - 1 ) ; if ( ! order . hasposition ( product ) ) { state = 0 ; } double currbody = currbar . getclose ( ) - currbar . getopen ( ) ; double prevbody = prevbar . getclose ( ) - prevbar . getopen ( ) ; double point = currencytable . getpoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevbody > 0 && currbody < 0 ; boolean cond2 = currbar . getopen ( ) >= prevbar . getclose ( ) ; boolean cond3 = currbar . getclose ( ) <= prevbar . getopen ( ) ; boolean cond4 = currbody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { string entrytime = bidts . get ( i ) . getstart ( ) ; this . entryprice = bidts . get ( i ) . getclose ( ) ; order . marketsell ( product , entrytime , entryprice , 2 ) ; this . stopprice = prevbar . getclose ( ) + 100 * point ; this . r = this . stopprice - this . entryprice ; this . takeprofit = this . entryprice - r ; order . stopbuy ( product , entrytime , this . stopprice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askts . get ( i ) . getclose ( ) < this . takeprofit ) { order . marketbuy ( product , currbar . getstart ( ) , this . takeprofit , 1 ) ; order . cancelallpendingorders ( product ) ; this . stopprice = this . stopprice - this . r ; this . takeprofit = this . takeprofit - this . r ; order . stopbuy ( product , currbar . getstart ( ) , this . stopprice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askts . get ( i ) . getclose ( ) < this . takeprofit ) { this . stopprice = this . stopprice - this . r ; this . takeprofit = this . takeprofit - this . r ; order . cancelallpendingorders ( product ) ; order . stopbuy ( product , currbar . getstart ( ) , this . stopprice , 1 ) ; } } }
tr	1	@ test public void testfilter ( ) { assertequals ( 0 , $ . filter ( "asdf" ) . size ( ) ) ; assertequals ( 1 , $ . filter ( "document" ) . size ( ) ) ; assertequals ( 3 , $ . find ( ) . filter ( "actor" ) . size ( ) ) ; assertequals ( 3 , $ . find ( ) . filter ( "actor" ) . filter ( joox . all ( ) ) . size ( ) ) ; assertequals ( 2 , $ . find ( ) . filter ( "actor" ) . filter ( joox . even ( ) ) . size ( ) ) ; assertequals ( 1 , $ . find ( ) . filter ( "actor" ) . filter ( joox . odd ( ) ) . size ( ) ) ; }
tr	2	public static void main ( string [ ] args ) { system . out . println ( "primera matriz" ) ; int [ ] [ ] mat1 = leematriz ( ) ; system . out . println ( ) ; system . out . println ( "segunda matriz" ) ; int [ ] [ ] mat2 = leematriz ( ) ; system . out . println ( ) ; int [ ] [ ] producto = null ; try { producto = matrizmul ( mat1 , mat2 ) ; } catch ( arithmeticexception ae ) { system . out . println ( ae . getmessage ( ) ) ; return ; } muestramatriz ( producto ) ; }
tr	3	void prune ( file [ ] files ) { int size = 0 ; for ( file file : files ) { if ( file . isfile ( ) && ! file . getname ( ) . equals ( "fat" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = globals . getcachelimit ( ) ; while ( size > limit && cnt < files . length ) { file current = files [ cnt ++ ] ; if ( current . isfile ( ) && ! current . getname ( ) . equals ( "fat" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileuse . set ( size ) ; updateguidisk ( ) ; }
tr	3	private void parsedisplaybpm ( string bpmvalues , simfile accumulator ) { final string [ ] bpmcodes = bpmvalues . split ( " " ) ; double min = integer . max_value ; string mintext = "" ; double max = integer . min_value ; string maxtext = "" ; for ( string bpmcode : bpmcodes ) { string bpmtext = bpmcode . substring ( bpmcode . indexof ( = ) + 1 ) ; double bpm = double . parsedouble ( bpmtext ) ; if ( bpm < min ) { min = bpm ; mintext = bpmtext ; } if ( bpm > max ) { max = bpm ; maxtext = bpmtext ; } } string displaybpm ; if ( max == min ) { displaybpm = mintext ; } else { displaybpm = mintext + " - " + maxtext ; } accumulator . setdisplaybpm ( displaybpm ) ; }
tr	2	@ override public storeable deserialize ( table table , string value ) throws parseexception { jsonarray json = ( ( new jsonparser ( ) . parse ( value ) ) ) . getasjsonarray ( ) ; list < object > values = new arraylist < > ( ) ; for ( int i = 0 ; i < json . size ( ) ; ++ i ) { values . add ( json . get ( i ) ) ; } storeable storeable ; try { storeable = createfor ( table , values ) ; } catch ( indexoutofboundsexception e ) { throw new parseexception ( "invalud number of arguments!" , 0 ) ; } catch ( columnformatexception e ) { throw new parseexception ( e . getmessage ( ) , 0 ) ; } return storeable ; }
tr	2	public static double inversesensormodel_old ( point p , point measurement , robotstate sensorstate , int z , sensor s ) { double result ; int r = utils . euclideandistance ( new point ( sensorstate . x , sensorstate . y ) , p ) ; if ( z == - 1 ) { result = config . logodd_start ; } else if ( r > math . min ( s . zmax , z ) + config . grid_cell_size ) { result = config . logodd_start ; } else if ( z < s . zmax && p . equals ( measurement ) ) { result = config . logodd_occupied_correct ; } else if ( r < z ) { result = config . logodd_occupied_wrong ; } else { result = config . logodd_start ; } return result ; }
tr	4	public < h , s > void dispatch ( event < h , s > event , s source ) { event . setsource ( source ) ; try { for ( h handler : this . < h > getqueuefortype ( registeredhandlers , event . gettype ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( throwable t ) { loggerfactory . getlogger ( handler . getclass ( ) ) . error ( "unhandled exception while dispatching event" , t ) ; } } for ( reference < waiter < event < h , s >>> ref : this . < reference < waiter < event < h , s >>> > getqueuefortype ( registeredwaiters , event . gettype ( ) ) ) { waiter < event < h , s >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof eventevent ) ) { dispatch ( new eventevent ( ) , event ) ; } } finally { event . setsource ( null ) ; } }
tr	1	@ requestmapping ( value = "/orders/{id}/edit" , method = requestmethod . get ) public modelandview getorderedit ( @ pathvariable long id , modelmap model ) { uorder uorder = factory . getuorderdao ( ) . getbyid ( id ) ; collection < orderproduct > orderproducts = factory . getorderproductdao ( ) . getbyorderid ( id ) ; collection orderstatuses = factory . getorderstatusdao ( ) . getall ( ) ; model . put ( "orderstatuses" , orderstatuses ) ; model . put ( "order" , uorder ) ; model . put ( "orderproducts" , orderproducts ) ; return new modelandview ( "ordereditpage" , "model" , model ) ; }
tr	4	private void comparepackageparts ( tipp p1 , tipp p2 ) throws exception { collection < tippsection > s1 = p1 . getsections ( ) ; collection < tippsection > s2 = p2 . getsections ( ) ; assertnotnull ( s1 ) ; assertnotnull ( s2 ) ; for ( tippsection s : s1 ) { tippsectiontype type = s . gettype ( ) ; list < ? extends tippfile > o1 = s . getfileresources ( ) ; tippsection _s = p2 . getsection ( type ) ; assertequals ( s , _s ) ; list < ? extends tippfile > o2 = _s . getfileresources ( ) ; assertnotnull ( o1 ) ; assertnotnull ( o2 ) ; assertequals ( o1 , o2 ) ; iterator < ? extends tippfile > fit1 = o1 . iterator ( ) ; iterator < ? extends tippfile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasnext ( ) ) { tippfile f1 = fit1 . next ( ) ; asserttrue ( fit2 . hasnext ( ) ) ; tippfile f2 = fit2 . next ( ) ; assertequals ( f1 , f2 ) ; try ( inputstream is1 = p1 . getfile ( f1 ) ; inputstream is2 = p2 . getfile ( f2 ) ) { verifybytes ( is1 , is2 ) ; } } } }
tr	1	@ override public void init ( gamecontainer gc , statebasedgame sbg ) throws slickexception { this . sbg = sbg ; logo = new image ( "data/svulogo.png" ) ; newgame = new image ( "data/newgame.png" ) ; continuegame = new image ( "data/loadgame.png" ) ; options = new image ( "data/options.png" ) ; quit = new image ( "data/quitgame.png" ) ; newgameroll = new image ( "data/newgameglow.png" ) ; continuegameroll = new image ( "data/loadgameglow.png" ) ; optionsroll = new image ( "data/optionsglow.png" ) ; quitroll = new image ( "data/quitgameglow.png" ) ; int logowidth = logo . getwidth ( ) ; logox = ( gc . getwidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getwidth ( ) - newgame . getwidth ( ) ) / 2 ; continuex = ( gc . getwidth ( ) - continuegame . getwidth ( ) ) / 2 ; optionsx = ( gc . getwidth ( ) - options . getwidth ( ) ) / 2 ; quitx = ( gc . getwidth ( ) - quit . getwidth ( ) ) / 2 ; areas [ 0 ] = new mouseoverarea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setmouseoverimage ( newgameroll ) ; areas [ 1 ] = new mouseoverarea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setmouseoverimage ( continuegameroll ) ; areas [ 2 ] = new mouseoverarea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setmouseoverimage ( optionsroll ) ; areas [ 3 ] = new mouseoverarea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setmouseoverimage ( quitroll ) ; }
tr	3	public void onsessionstatuschanged ( o2gsessionstatuscode status ) { system . out . println ( "status: " + status . tostring ( ) ) ; switch ( status ) { case trading_session_requested : if ( msessionid . isempty ( ) ) { system . out . println ( "argument for trading session id is missing" ) ; } else { msession . settradingsession ( msessionid , mpin ) ; } break ; case connected : mconnected = true ; mdisconnected = false ; msemaphore . release ( ) ; break ; case disconnected : mconnected = false ; mdisconnected = true ; msemaphore . release ( ) ; break ; } }
tr	2	public void initpanel ( ) { this . removeall ( ) ; texte_options . setforeground ( color . black ) ; texte_options . setfont ( new font ( "droid serif" , font . italic | font . bold , 40 ) ) ; texte_options . setbounds ( 360 , 20 , 500 , 50 ) ; texte . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; texte2 . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; texte3 . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; spinner . setmodel ( new spinnernumbermodel ( fenetre . getmodele ( ) . getoptions ( ) . gettaillegrille ( ) , 10 , 20 , 1 ) ) ; switch ( fenetre . getmodele ( ) . getoptions ( ) . getniveauia ( ) ) { case facile : rb_facile . setselected ( true ) ; break ; case moyen : rb_moyen . setselected ( true ) ; break ; case difficile : rb_difficile . setselected ( true ) ; break ; } pan . setlayout ( new gridlayout ( 6 , 1 ) ) ; pan . setbounds ( 50 , 110 , 400 , 410 ) ; pan2 . setlayout ( null ) ; pan2 . setbounds ( 480 , 110 , 360 , 150 ) ; pan3 . setlayout ( null ) ; pan3 . setbounds ( 480 , 300 , 360 , 220 ) ; texte2 . setbounds ( 10 , 10 , 400 , 20 ) ; spinner . setbounds ( 150 , 50 , 60 , 40 ) ; texte3 . setbounds ( 10 , 10 , 300 , 20 ) ; rb_facile . setbounds ( 20 , 50 , 100 , 20 ) ; rb_facile . setbackground ( null ) ; rb_moyen . setbounds ( 20 , 100 , 100 , 20 ) ; rb_moyen . setbackground ( null ) ; rb_difficile . setbounds ( 20 , 150 , 100 , 20 ) ; rb_difficile . setbackground ( null ) ; b_retour . setbounds ( 10 , 550 , 100 , 50 ) ; b_jouer . setbounds ( 780 , 550 , 100 , 50 ) ; bg . add ( rb_facile ) ; bg . add ( rb_moyen ) ; bg . add ( rb_difficile ) ; check1 . setfocusable ( false ) ; check2 . setfocusable ( false ) ; check3 . setfocusable ( false ) ; check4 . setfocusable ( false ) ; check5 . setfocusable ( false ) ; getcoches ( ) ; check1 . setstate ( coches [ 0 ] ) ; check2 . setstate ( coches [ 1 ] ) ; check3 . setstate ( coches [ 2 ] ) ; check4 . setstate ( coches [ 3 ] ) ; check5 . setstate ( coches [ 4 ] ) ; pan . add ( texte ) ; pan . add ( check1 ) ; pan . add ( check2 ) ; pan . add ( check3 ) ; pan . add ( check4 ) ; pan . add ( check5 ) ; pan2 . add ( texte2 ) ; pan2 . add ( spinner ) ; pan3 . add ( texte3 ) ; pan3 . add ( rb_facile ) ; pan3 . add ( rb_moyen ) ; pan3 . add ( rb_difficile ) ; this . add ( texte_options ) ; this . add ( pan ) ; this . add ( pan2 ) ; this . add ( pan3 ) ; this . add ( b_jouer ) ; this . add ( b_retour ) ; }
tr	3	public map < string , map < string , object >> loadasmap ( string key ) throws ioexception { map < string , map < string , object >> map = new hashmap < string , map < string , object >> ( ) ; lineiterator iterator = new lineiterator ( new filereader ( file ) ) ; while ( iterator . hasnext ( ) ) { map < string , object > json = jsonoutput . mapper . readvalue ( iterator . nextline ( ) , map . class ) ; if ( json . containskey ( key ) ) { map . put ( json . get ( key ) . tostring ( ) , json ) ; } } return map ; }
tr	3	public static jsonobjectbuilder rewritejson ( jsonobjectbuilder copyinto , jsonvalue tree , string key ) { switch ( tree . getvaluetype ( ) ) { case object : jsonobject obj = ( jsonobject ) tree ; for ( string name : obj . keyset ( ) ) { copyinto = rewritejson ( copyinto , obj . get ( name ) , name ) ; } break ; case string : jsonstring st = ( jsonstring ) tree ; copyinto . add ( key , st . getstring ( ) ) ; break ; default : break ; } return copyinto ; }
tr	3	private boolean isvaliduserinput ( final string hostname , final string port ) { final string methodname = "isvaliduserinput" ; controllerlogger . entering ( class_name , methodname , hostname , port ) ; try { if ( guiutils . isemptyvalue ( hostname ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_hostname_message ) ; return false ; } if ( ! guiutils . isportnumbervalid ( port ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_port_number_message ) ; return false ; } return true ; } finally { controllerlogger . exiting ( class_name , methodname ) ; } }
tr	4	public string tofirstuppercase ( string title ) { if ( title . length ( ) == 0 ) return "" ; string uppercase = title . substring ( 0 , 1 ) . touppercase ( ) ; boolean isthefirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charat ( i ) ==   ) { uppercase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isthefirst = true ; } else { if ( isthefirst ) { uppercase += title . substring ( i , i + 1 ) . touppercase ( ) ; isthefirst = false ; } else { uppercase += title . substring ( i , i + 1 ) ; } } } system . out . println ( uppercase ) ; return uppercase ; }
tr	1	public titlemodel ( ) { column menucolumn = new column ( "menu" ) ; menucolumn . additem ( new item ( "startgame" ) ) ; menucolumn . additem ( new item ( "settings" ) ) ; menucolumn . additem ( new item ( "exitgame" ) ) ; herocolumn herocolumn1 = new herocolumn ( "herocolumn1" , constants . player_1_default_hero ) ; herocolumn1 . additem ( new item ( "choosehero" ) ) ; herocolumn herocolumn2 = new herocolumn ( "herocolumn2" , constants . player_2_default_hero ) ; herocolumn2 . additem ( new item ( "choosehero" ) ) ; columns . add ( menucolumn ) ; columns . add ( herocolumn1 ) ; columns . add ( herocolumn2 ) ; selected = false ; }
tr	1	@ test public void testgetbasetype ( ) { system . out . println ( "arraytype: getbasetype()" ) ; class type = string [ ] [ ] . class ; arraytype instance = new arraytype ( type ) ; object exptype = string . class ; assertequals ( exptype , instance . getbasetype ( ) ) ; type = integer [ ] . class ; instance = new arraytype ( type ) ; assertequals ( integer . class , instance . getbasetype ( ) ) ; type = person [ ] . class ; instance = new arraytype ( type ) ; assertequals ( person . class , instance . getbasetype ( ) ) ; instance = new arraytype ( ) ; assertequals ( object . class , instance . getbasetype ( ) ) ; }
tr	4	public boolean move ( direction direction , stringbuffer output ) throws endgameexception { boolean hasmoved = false ; if ( myposition . iscrossable ( direction ) ) { if ( myposition . hascharacter ( direction ) ) { character defender = myposition . getcharacter ( direction ) ; if ( attack ( defender ) ) { this . myposition = myposition . movecharacter ( direction ) ; output . append ( "you attacked and killed " + defender + ". you moved " + direction ) ; hasmoved = true ; } else { if ( isdead ( ) ) throw new endgameexception ( "player has died. game over!" ) ; output . append ( "you attacked: \n" + defender . tostring ( ) + "\n" + this . tostring ( ) ) ; } } else { this . myposition = myposition . movecharacter ( direction ) ; output . append ( "you moved " + direction + "." ) ; hasmoved = true ; } } else { output . append ( checkiflockedexit ( direction ) ) ; } if ( hasmoved ) { notifypositionchanged ( direction . getoppositedirection ( ) ) ; } return hasmoved ; }
tr	1	public void open ( url location , string referer ) throws ioexception { string host = location . gethost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; string path = location . getpath ( ) + "?" + location . getquery ( ) ; int port = location . getport ( ) ; if ( port == - 1 ) port = 80 ; socket . setsotimeout ( 5000 ) ; socket . connect ( new inetsocketaddress ( host , port ) , 5000 ) ; printwriter pw = new printwriter ( socket . getoutputstream ( ) , true ) ; pw . println ( "get " + path + " http/1.1" ) ; pw . println ( "host: " + host ) ; pw . println ( "referer: " + referer ) ; pw . println ( "accept: */*" ) ; pw . println ( "user-agent: mozilla/4.0 (compatible; msie 6.0; windows nt 5.1)" ) ; pw . println ( "connection: keep-alive" ) ; pw . println ( ) ; instream = socket . getinputstream ( ) ; getresponse ( ) ; }
tr	3	private static string readline ( int linenumber ) { bufferedreader reader = null ; string line = "" ; try { reader = new bufferedreader ( new filereader ( file ) ) ; int i = 0 ; for ( string curline ; ( curline = reader . readline ( ) ) != null ; i ++ ) { if ( i == linenumber ) line = curline ; } } catch ( ioexception e ) { } finally { try { reader . close ( ) ; } catch ( exception e ) { } } return line ; }
tr	3	public object stringtovalue ( string text ) throws parseexception { stringtokenizer tokenizer = new stringtokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too few bytes" , 0 ) ; try { b = integer . parseint ( tokenizer . nexttoken ( ) ) ; } catch ( numberformatexception e ) { throw new parseexception ( "not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new parseexception ( "byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too many bytes" , 0 ) ; return a ; }
tr	2	public static void phdstudentinsert ( jsonobject data ) { string firstname = ( string ) data . get ( "firstname" ) ; string surname = ( string ) data . get ( "surname" ) ; string lastname = ( string ) data . get ( "lastname" ) ; string personalid = ( string ) data . get ( "personalid" ) ; string phone = ( string ) data . get ( "phone" ) ; string email = ( string ) data . get ( "email" ) ; string type = ( string ) data . get ( "type" ) ; string form = ( string ) data . get ( "form" ) ; phdstudenttype studenttype = null ; studyform studyform = null ; if ( form . contains ( "self_training" ) ) studyform = studyform . self_training ; else studyform = studyform . regular_training ; if ( type . contains ( "creative" ) ) studenttype = phdstudenttype . creative ; else studenttype = phdstudenttype . research ; student student = new student ( firstname , surname , lastname , personalid , phone , email , studenttype , studyform ) ; sqlinsert . insertstudent ( student ) ; boolean assigned = boolean . parseboolean ( ( string ) data . get ( "assigned" ) ) ; string assigneddate = ( string ) data . get ( "assigneddate" ) ; string supervisor = ( string ) data . get ( "supervisor" ) ; string thesis = ( string ) data . get ( "thesis" ) ; boolean individualplan = boolean . parseboolean ( ( string ) data . get ( "individualplan" ) ) ; string approvaldate = ( string ) data . get ( "approvaldate" ) ; string monitoringdate = ( string ) data . get ( "monitoringdate" ) ; string evaluation_raw = ( string ) data . get ( "evaluation" ) ; evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = evaluation . positive ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = evaluation . negative ; else evaluation = evaluation . critical ; monitoring monitoring = new monitoring ( monitoringdate ) ; trainingstatus trainingstatus = new trainingstatus ( assigned , assigneddate , supervisor , thesis , individualplan , approvaldate , monitoring , evaluation ) ; sqlinsert . inserttrainingstatus ( trainingstatus , student ) ; string facultyname = ( string ) data . get ( "facultyname" ) ; int specialtycode = integer . parseint ( ( string ) data . get ( "specialtycode" ) ) ; faculty faculty = new faculty ( facultyname , specialtycode , trainingstatus , student ) ; sqlinsert . insertfaculty ( faculty , student , trainingstatus ) ; string specialtyexam = ( string ) data . get ( "specialtyexam" ) ; string publicprotection = ( string ) data . get ( "publicprotection" ) ; curriculum studentcurriculum = new curriculum ( specialtyexam , publicprotection ) ; sqlinsert . insertstudentcurriculum ( studentcurriculum , student ) ; jsonarray courses = ( jsonarray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { jsonobject course = ( jsonobject ) courses . get ( i ) ; string coursename = ( string ) course . get ( "coursename" ) ; string courseestimate = ( string ) course . get ( "courseestimate" ) ; string coursetype = ( string ) course . get ( "coursetype" ) ; string courseprotocol = ( string ) course . get ( "courseprotocol" ) ; courseprotocols protocol = new courseprotocols ( courseprotocol ) ; coursetype ctype = null ; if ( coursetype . equals ( "compulsory" ) ) ctype = coursetype . compulsory ; else ctype = coursetype . elective ; course studentcourse = new course ( courseestimate , coursename , ctype , protocol ) ; sqlinsert . insertcourseprotocol ( protocol ) ; sqlinsert . insertcourses ( studentcourse , student , studentcurriculum ) ; } jsonarray eduactivities = ( jsonarray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduactivities . size ( ) ; i ++ ) { jsonobject eduactivity = ( jsonobject ) eduactivities . get ( i ) ; string activityname = ( string ) eduactivity . get ( "activityname" ) ; string activitytype = ( string ) eduactivity . get ( "activitytype" ) ; eduactivitytype edutype = null ; if ( activitytype . equals ( "lecture" ) ) edutype = eduactivitytype . lecture ; else edutype = eduactivitytype . seminar ; eduactivities activity = new eduactivities ( activityname , edutype ) ; sqlinsert . inserteduactivities ( activity , student , studentcurriculum ) ; } jsonarray artisticevents = ( jsonarray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticevents . size ( ) ; i ++ ) { jsonobject artevent = ( jsonobject ) artisticevents . get ( i ) ; string eventname = ( string ) artevent . get ( "eventname" ) ; string eventdate = ( string ) artevent . get ( "eventdate" ) ; artisticevents event = new artisticevents ( eventdate , eventname ) ; sqlinsert . insertartisticevents ( event , student , studentcurriculum ) ; } jsonarray scientificprods = ( jsonarray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificprods . size ( ) ; i ++ ) { jsonobject scprod = ( jsonobject ) scientificprods . get ( i ) ; string productionname = ( string ) scprod . get ( "productionname" ) ; string productiontype = ( string ) scprod . get ( "productiontype" ) ; scientificproductions production = new scientificproductions ( productionname , productiontype ) ; sqlinsert . insertscprod ( production , student , studentcurriculum ) ; } }
tr	5	public card [ ] pickcards ( selectcardoptions sco , card [ ] allcards ) { gamequery p = new gamequery ( querytype . getcard , querytype . card ) . setobject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != querytype . card ) return null ; if ( p . o instanceof card [ ] || p . o instanceof string [ ] ) { string [ ] selected ; if ( p . o instanceof card [ ] ) { arraylist < string > a = new arraylist < string > ( ) ; for ( card c : ( card [ ] ) p . o ) a . add ( c . getname ( ) ) ; selected = a . toarray ( new string [ 0 ] ) ; } else selected = ( string [ ] ) p . o ; arraylist < card > ret = new arraylist < card > ( ) ; arraylist < card > all = new arraylist < card > ( arrays . aslist ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toarray ( new card [ 0 ] ) ; } return null ; }
tr	3	public void update ( data ... records ) throws ioexception { intobjectopenhashmap < arraylist < data >> bucketdatamapping = new intobjectopenhashmap < arraylist < data >> ( ) ; int bucketid ; for ( data d : records ) { bucketid = hashfunction . getbucketid ( d . getkey ( ) ) ; if ( ! bucketdatamapping . containskey ( bucketid ) ) { bucketdatamapping . put ( bucketid , new arraylist < data > ( ) ) ; } bucketdatamapping . get ( bucketid ) . add ( d ) ; } for ( intobjectcursor < arraylist < data >> entry : bucketdatamapping ) { updateonlysynchronizer < data > synchronizer = new updateonlysynchronizer < data > ( gp . database_directory + "/" + hashfunction . getfilename ( entry . key ) , gp ) ; @ suppresswarnings ( "unchecked" ) data [ ] toupdate = ( data [ ] ) entry . value . toarray ( new abstractkvstorable [ entry . value . size ( ) ] ) ; arrays . sort ( toupdate , new abstractkvstorablecomparator ( ) ) ; synchronizer . upsert ( toupdate ) ; } }
tr	2	public mainframe ( ) { initcomponents ( ) ; preferences = preferences . userroot ( ) . node ( this . getclass ( ) . getname ( ) ) ; final string pathtopdflatexfile = preferences . get ( "pathtopdflatexfile" , null ) ; final string pathtopdfexportfolder = preferences . get ( "pathtopdfexportfolder" , null ) ; if ( ( pathtopdflatexfile == null ) || ( pathtopdfexportfolder == null ) ) config . initpreferences ( preferences ) ; if ( ( pathtopdflatexfile != null ) && ( ! pathtopdflatexfile . equals ( config . default ) ) ) config . setpdflatexfile ( new file ( pathtopdflatexfile ) ) ; if ( ( pathtopdfexportfolder != null ) && ( ! pathtopdfexportfolder . equals ( config . default ) ) ) config . setpdfexportfolder ( new file ( pathtopdfexportfolder ) ) ; parameterlabelarray = new javax . swing . jlabel [ ] { parameter1label , parameter2label , parameter3label , parameter4label } ; parameterarray = new javax . swing . jtextfield [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problempartcomponentsarray = new jcomponent [ ] { useranswerfield , checkbutton , showsolutionlatexbutton , showsolutionplaintextbutton , copytoclipboardbutton , exporttopdfbutton , resetbutton } ; }
tr	4	public klas getklas ( long klas_id ) { klas klas = null ; try { preparedstatement klasstatement = manager . preparestatement ( "select * from klassen where id = ?" ) ; klasstatement . setlong ( 1 , klas_id ) ; resultset klasresult = klasstatement . executequery ( ) ; if ( klasresult . next ( ) ) { klas = new klas ( klasresult . getlong ( 1 ) , klasresult . getstring ( 2 ) ) ; preparedstatement leerlingenklas = manager . preparestatement ( "select leerling_id from leerling_klas where klas_id = ?" ) ; leerlingenklas . setlong ( 1 , klas_id ) ; resultset leerlingids = leerlingenklas . executequery ( ) ; while ( leerlingids . next ( ) ) { klas . addstudent ( getuser ( leerlingids . getlong ( 1 ) ) ) ; } for ( vak vak : getvakkenvanklas ( klas_id ) ) { klas . addvak ( vak ) ; } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return klas ; }
tr	4	private void initwindow ( ) { contentpanel = new jpanel ( ) ; contentpanel . setlayout ( new boxlayout ( contentpanel , boxlayout . page_axis ) ) ; contentpanel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; tabbedpanel = new jtabbedpane ( ) ; tabbedpanel . setpreferredsize ( new dimension ( 500 , 800 ) ) ; connectiontabpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usersettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usersettingspanel . setlayout ( new boxlayout ( usersettingspanel , boxlayout . page_axis ) ) ; usersettingspanel . setborder ( new titledborder ( "user settings" ) ) ; usersettingsv1panel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usernamelabel = new jlabel ( "username:" ) ; usernametext = new jtextfield ( userpreferences . pref_username , 6 ) ; apisecretlabel = new jlabel ( "api secret:" ) ; apisecrettext = new jpasswordfield ( userpreferences . pref_api_secret , 6 ) ; passwordlabel = new jlabel ( "password:" ) ; passwordtext = new jpasswordfield ( userpreferences . pref_password , 6 ) ; usersettingsv1panel . add ( usernamelabel ) ; usersettingsv1panel . add ( usernametext ) ; usersettingsv1panel . add ( apisecretlabel ) ; usersettingsv1panel . add ( apisecrettext ) ; usersettingsv1panel . add ( passwordlabel ) ; usersettingsv1panel . add ( passwordtext ) ; usertokenpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usertokenpanel . setpreferredsize ( new dimension ( 443 , 40 ) ) ; usertokenlabel = new jlabel ( "token:" ) ; usertokentext = new jtextfield ( userpreferences . pref_usertoken , 10 ) ; usertokenbutton = new jbutton ( "get your token" ) ; usertokenbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { gettoken . browse ( ) ; } } ) ; usertokenpanel . add ( usertokenlabel ) ; usertokenpanel . add ( usertokentext ) ; usertokenpanel . add ( usertokenbutton ) ; usersettingspanel . add ( usertokenpanel ) ; proxysettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; proxyusecheck = new jcheckbox ( "use proxy" , userpreferences . pref_use_proxy ) ; proxyusecheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { if ( proxyusecheck . isselected ( ) ) { proxyaddresstext . setenabled ( true ) ; proxyporttext . setenabled ( true ) ; } else { proxyaddresstext . setenabled ( false ) ; proxyporttext . setenabled ( false ) ; } } } ) ; proxysettingspanel . setborder ( new titledborder ( "proxy settings" ) ) ; proxyaddresslabel = new jlabel ( "proxy:" ) ; proxyaddresstext = new jtextfield ( userpreferences . pref_proxy_address , 15 ) ; proxyportlabel = new jlabel ( "port:" ) ; proxyporttext = new jtextfield ( userpreferences . pref_proxy_port , 3 ) ; proxysettingspanel . add ( proxyusecheck ) ; proxysettingspanel . add ( proxyaddresslabel ) ; proxysettingspanel . add ( proxyaddresstext ) ; proxysettingspanel . add ( proxyportlabel ) ; proxysettingspanel . add ( proxyporttext ) ; proxysettingspanel . setpreferredsize ( new dimension ( 455 , 60 ) ) ; serversettingspanel = new jpanel ( ) ; serversettingspanel . setlayout ( new boxlayout ( serversettingspanel , boxlayout . page_axis ) ) ; serversettingspanel . setborder ( new titledborder ( "server settings" ) ) ; servercheckpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; servercheckintervallabel = new jlabel ( "server check interval (sec):" ) ; servercheckintervaltext = new jtextfield ( string . valueof ( userpreferences . pref_server_check_interval ) , 3 ) ; autocleancheck = new jcheckbox ( "delete empty folders (keeps account clean)" , userpreferences . pref_auto_clean ) ; servercheckpanel . add ( servercheckintervallabel ) ; servercheckpanel . add ( servercheckintervaltext ) ; servercheckpanel . add ( autocleancheck ) ; serversortbypanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; serversortbylabel = new jlabel ( "sort by default:" ) ; serversortbycombo = new jcombobox < string > ( new string [ ] { "name" , "date" } ) ; serversortbycombo . setselectedindex ( userpreferences . pref_behavior_sort_by ) ; serversortbypanel . add ( serversortbylabel ) ; serversortbypanel . add ( serversortbycombo ) ; serverfriendpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; loadsharedcheck = new jcheckbox ( "load friends' files (this could take some time to load)" , userpreferences . pref_load_shared ) ; serverfriendpanel . add ( loadsharedcheck ) ; serversettingspanel . add ( servercheckpanel ) ; serversettingspanel . add ( serversortbypanel ) ; serversettingspanel . add ( serverfriendpanel ) ; serversettingspanel . setpreferredsize ( new dimension ( 455 , 120 ) ) ; connectiontabpanel . add ( usersettingspanel ) ; connectiontabpanel . add ( proxysettingspanel ) ; connectiontabpanel . add ( serversettingspanel ) ; tabbedpanel . addtab ( "connection" , null , connectiontabpanel ) ; startupsettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; autoconnectcheck = new jcheckbox ( "connect on start automatically" , userpreferences . pref_auto_connect ) ; startintraycheck = new jcheckbox ( "start in system tray" , userpreferences . pref_start_in_tray ) ; startupsettingspanel . setborder ( new titledborder ( "startup settings" ) ) ; startupsettingspanel . add ( autoconnectcheck ) ; startupsettingspanel . add ( startintraycheck ) ; tabbedpanel . addtab ( "startup" , null , startupsettingspanel ) ; downloadsettingspanel = new jpanel ( ) ; downloadsettingspanel . setlayout ( new boxlayout ( downloadsettingspanel , boxlayout . page_axis ) ) ; downloadsettingspanel . setborder ( new titledborder ( "download settings" ) ) ; autodownloadpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; autodownloadcheck = new jcheckbox ( "download on connect" , userpreferences . pref_auto_download ) ; autodownloadpanel . add ( autodownloadcheck ) ; downloadtargetpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; downloadtargetlabel = new jlabel ( "target:" ) ; downloadtargettext = new jtextfield ( userpreferences . pref_download_target , 20 ) ; downloadtargettext . seteditable ( false ) ; filechooserbutton = new jbutton ( "browse" ) ; filechooserbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( filechooser . showopendialog ( preferencesscreen ) == jfilechooser . approve_option ) { downloadtargettext . settext ( filechooser . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; filechooser = new jfilechooser ( downloadtargettext . gettext ( ) ) ; filechooser . setfileselectionmode ( jfilechooser . directories_only ) ; filechooser . setdialogtitle ( "select download directory" ) ; filechooser . setacceptallfilefilterused ( false ) ; downloadtargetpanel . add ( downloadtargetlabel ) ; downloadtargetpanel . add ( downloadtargettext ) ; downloadtargetpanel . add ( filechooserbutton ) ; downloadwhatpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; downloadwhatlabel = new jlabel ( "download:" ) ; everythingradio = new jradiobutton ( "everything" ) ; selfoldersradio = new jradiobutton ( "selected folders" ) ; selfoldersradio . settooltiptext ( "right clic folder -> add to automatic download" ) ; downloadwhatgroup = new buttongroup ( ) ; downloadwhatgroup . add ( everythingradio ) ; downloadwhatgroup . add ( selfoldersradio ) ; downloadwhatpanel . add ( downloadwhatlabel ) ; downloadwhatpanel . add ( everythingradio ) ; downloadwhatpanel . add ( selfoldersradio ) ; downloadpartspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; maxparalleldownloadslabel = new jlabel ( "max parallel downloads:" ) ; maxparalleldownloadstext = new jtextfield ( string . valueof ( userpreferences . pref_max_downloads ) , 2 ) ; downloadpartslabel = new jlabel ( "parts for each download:" ) ; downloadpartstext = new jtextfield ( string . valueof ( userpreferences . pref_download_part_count ) , 2 ) ; downloadpartspanel . add ( maxparalleldownloadslabel ) ; downloadpartspanel . add ( maxparalleldownloadstext ) ; downloadpartspanel . add ( downloadpartslabel ) ; downloadpartspanel . add ( downloadpartstext ) ; filesizecheckpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; filesizecheckcheck = new jcheckbox ( "skip download if size of the file is smaller than (mb):" , userpreferences . pref_file_size_check ) ; filesizecheckcheck . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent e ) { filesizechecktext . setenabled ( filesizecheckcheck . isselected ( ) ) ; filesizedeletecheck . setenabled ( filesizecheckcheck . isselected ( ) ) ; } } ) ; filesizechecktext = new jtextfield ( string . valueof ( userpreferences . pref_file_size_for_check ) , 4 ) ; filesizechecktext . setenabled ( filesizecheckcheck . isselected ( ) ) ; filesizecheckpanel . add ( filesizecheckcheck ) ; filesizecheckpanel . add ( filesizechecktext ) ; filesizedeletepanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; filesizedeletecheck = new jcheckbox ( "also delete it from server automatically" , userpreferences . pref_file_size_delete ) ; filesizedeletecheck . setenabled ( userpreferences . pref_file_size_check ) ; filesizedeletepanel . add ( filesizedeletecheck ) ; downloadsettingspanel . add ( autodownloadpanel ) ; downloadsettingspanel . add ( downloadtargetpanel ) ; downloadsettingspanel . add ( downloadwhatpanel ) ; downloadsettingspanel . add ( downloadpartspanel ) ; downloadsettingspanel . add ( filesizecheckpanel ) ; downloadsettingspanel . add ( filesizedeletepanel ) ; tabbedpanel . addtab ( "download" , null , downloadsettingspanel ) ; conflictsettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; conflictsettingspanel . setborder ( new titledborder ( "conflict settings" ) ) ; redownloadpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; redownloadcheck = new jcheckbox ( "do not ask if file already downloaded. apply following: " , userpreferences . pref_dont_ask_download_again ) ; redownloadcheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { redownloadcombo . setenabled ( redownloadcheck . isselected ( ) ) ; } } ) ; redownloadcombo = new jcombobox < string > ( new string [ ] { "download again" , "skip" , "skip and delete" } ) ; redownloadcombo . setselectedindex ( userpreferences . pref_behavior_download_again ) ; redownloadcombo . setenabled ( userpreferences . pref_dont_ask_download_again ) ; redownloadpanel . add ( redownloadcheck ) ; redownloadpanel . add ( redownloadcombo ) ; overwritepanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; overwritecheck = new jcheckbox ( "do not ask if file already exits on disc. apply following: " , userpreferences . pref_dont_ask_overwrite ) ; overwritecheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { overwritecombo . setenabled ( overwritecheck . isselected ( ) ) ; } } ) ; overwritecombopanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; overwritecombo = new jcombobox < string > ( new string [ ] { "overwrite" , "skip" , "skip and delete from server" , "skip in case of same size" , "skip in case of same size and delete from server" } ) ; overwritecombo . setselectedindex ( userpreferences . pref_behavior_overwrite ) ; overwritecombo . setenabled ( userpreferences . pref_dont_ask_overwrite ) ; overwritepanel . add ( overwritecheck ) ; overwritecombopanel . add ( overwritecombo ) ; conflictsettingspanel . add ( redownloadpanel ) ; conflictsettingspanel . add ( overwritepanel ) ; conflictsettingspanel . add ( overwritecombopanel ) ; tabbedpanel . addtab ( "conflict" , null , conflictsettingspanel ) ; buttonspanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; saveandclosebutton = new jbutton ( "save & close" ) ; saveandclosebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( savesettings ( ) ) { preferencesscreen . setvisible ( false ) ; } } } ) ; closebutton = new jbutton ( "close" ) ; closebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { preferencesscreen . setvisible ( false ) ; } } ) ; buttonspanel . add ( saveandclosebutton ) ; buttonspanel . add ( closebutton ) ; contentpanel . add ( tabbedpanel ) ; contentpanel . add ( buttonspanel ) ; this . getcontentpane ( ) . add ( contentpanel , borderlayout . center ) ; this . settitle ( "preferences" ) ; this . setsize ( new dimension ( 490 , 370 ) ) ; this . setresizable ( false ) ; }
tr	3	public multilist ( ) { recommendedmodel = new defaultlistmodel < champion > ( ) ; goodmodel = new defaultlistmodel < champion > ( ) ; viablemodel = new defaultlistmodel < champion > ( ) ; allmodel = new defaultlistmodel < champion > ( ) ; instance = this ; submit ( ) ; eventhandler . addslotlocklistener ( new slotlocklistener ( ) { @ override public void onslotlock ( ) { submit ( ) ; } } ) ; eventhandler . addresetlistener ( new resetlistener ( ) { @ override public void onreset ( ) { reset ( ) ; submit ( ) ; } } ) ; }
tr	2	private void checkconvexcut ( point [ ] points , point a , point n ) { point [ ] [ ] hullp = convexcut ( convexhull ( points ) , a , n ) ; system . out . println ( arrays . deeptostring ( hullp ) ) ; asserttrue ( isconvex ( hullp ) ) ; for ( point p : points ) { int type = isinconvex ( p , hullp ) ; double d = a . subtract ( p ) . . ( n ) ; if ( approxequals ( d , 0 ) ) asserttrue ( type == 2 ) ; else if ( d > 0 ) asserttrue ( type != 0 ) ; else asserttrue ( type == 0 ) ; } }
tr	5	private list < next > nextstates ( state < c > state ) { int m ; list < transition > nexts = new arraylist < > ( _transitions . get ( state ) ) ; list < next > result = new arraylist < > ( ) ; int offset = 0 ; while ( true ) { m = nextdeadline ( nexts , offset ) ; if ( m != integer . max_value ) { result . add ( selectnextstate ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new runtimeexception ( "automata has no default transition for node: " + state ) ; case 1 : transition target = nexts . get ( 0 ) ; next timeout = new next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : next infinites = new next ( infinity ) ; for ( transition t : nexts ) { if ( t . timeout != infinity ) throw new runtimeexception ( "cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	5	private void setusersstate ( int state ) { final int columnid = 0 ; if ( tableusers . getselectedrow ( ) != - 1 ) { int userid = ( integer ) tableusers . getvalueat ( tableusers . getselectedrow ( ) , columnid ) ; statement statement = null ; resultset result = null ; try { statement = usersdao . getconnection ( ) . createstatement ( resultset . type_scroll_sensitive , resultset . concur_updatable ) ; result = statement . executequery ( usersdao . getallquery ( ) ) ; while ( result . next ( ) ) { if ( result . getint ( "id" ) == userid ) { break ; } } result . updateint ( "userstate" , state ) ; result . updaterow ( ) ; usersdao = new usersdao ( ) ; usersdao . inittablemodel ( tableusers , usersdao . listall ( ) ) ; } catch ( sqlexception exc ) { joptionpane . showmessagedialog ( this , "\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0438 \u0434\u0430\u043d\u043d\u044b\u0445" ) ; } } else { joptionpane . showmessagedialog ( this , "\u041d\u0435 \u0432\u044b\u0431\u0440\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435!" ) ; return ; } }
tr	1	@ test public void buildsgraph ( ) { point p1 = vc . addpoint ( 0 , 0 ) ; point p2 = vc . addpoint ( 1 , - 1 ) ; point p3 = vc . addpoint ( 1 , 1 ) ; point p4 = vc . addpoint ( 1.5 , 0.0 ) ; point p5 = vc . addpoint ( 4 , - 1 ) ; point p6 = vc . addpoint ( 4 , 1 ) ; p1 . setright ( p2 ) ; p2 . setleft ( p1 ) ; p3 . setright ( p1 ) ; p1 . setleft ( p3 ) ; p2 . setright ( p3 ) ; p3 . setleft ( p2 ) ; p4 . setright ( p5 ) ; p5 . setleft ( p4 ) ; p6 . setright ( p4 ) ; p4 . setleft ( p6 ) ; p5 . setright ( p6 ) ; p6 . setleft ( p5 ) ; vc . buildgraph ( ) ; tree < vertex > testadj1 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj2 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj3 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj4 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj5 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj6 = new tree < > ( new vertexcomparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; asserttrue ( p1 . getadjacents ( ) . equals ( testadj1 ) && p2 . getadjacents ( ) . equals ( testadj2 ) && p3 . getadjacents ( ) . equals ( testadj3 ) && p4 . getadjacents ( ) . equals ( testadj4 ) && p5 . getadjacents ( ) . equals ( testadj5 ) && p6 . getadjacents ( ) . equals ( testadj6 ) ) ; }
tr	3	protected string getnestedusage ( string [ ] args , int level , method method , t player ) throws commandexception { stringbuilder command = new stringbuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } map < string , method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; set < string > allowedcommands = new hashset < string > ( ) ; for ( map . entry < string , method > entry : map . entryset ( ) ) { method childmethod = entry . getvalue ( ) ; found = true ; if ( haspermission ( childmethod , player ) ) { command childcmd = childmethod . getannotation ( command . class ) ; allowedcommands . add ( childcmd . aliases ( ) [ 0 ] ) ; } } if ( allowedcommands . size ( ) > 0 ) { command . append ( stringutil . joinstring ( allowedcommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new commandpermissionsexception ( ) ; } } command . append ( ">" ) ; return command . tostring ( ) ; }
tr	2	private arglistcodefragment convertparamlist ( arglistcodefragment paramlist , function f , codeposition p ) { arglistcodefragment code = new arglistcodefragment ( ) ; code . appendcodefragment ( paramlist ) ; for ( int i = 0 ; i < paramlist . getargs ( ) . size ( ) ; i ++ ) { variable v = paramlist . getargs ( ) . get ( i ) ; type t = f . getparams ( ) . get ( i ) . gettype ( ) ; code . appendcodefragment ( variabletypeconvert ( v , t , p ) ) ; code . addarg ( new variable ( code . getinfo ( ) , code . getregister ( ) , code . gettype ( ) ) ) ; } return code ; }
tr	3	public static void main ( string [ ] args ) { conn con = poolmanager . getinstance ( ) . getconnection ( ) ; connection conn = con . getconn ( ) ; statement stmt = null ; resultset rs = null ; try { stmt = conn . createstatement ( ) ; rs = stmt . executequery ( "select * from article " ) ; int c = rs . getmetadata ( ) . getcolumncount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { system . out . println ( rs . getmetadata ( ) . getcolumnname ( i ) ) ; } while ( rs . next ( ) ) { system . out . print ( rs . getstring ( "title" ) ) ; system . out . print ( rs . getstring ( "author" ) ) ; system . out . println ( ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } poolmanager . getinstance ( ) . releaseconnection ( con ) ; } }
tr	3	@ override public void actionperformed ( actionevent e ) { if ( e . getactioncommand ( ) . equals ( "apply" ) ) { this . dispose ( ) ; system . out . println ( "aaaa" ) ; tuple < string , tuple < string , integer >> player1data = player1 . getplayerdata ( ) ; tuple < string , tuple < string , integer >> player2data = player2 . getplayerdata ( ) ; int deadfields = this . deadfields . getdeadfieldnumber ( ) ; system . out . println ( deadfields ) ; system . out . println ( "bbb" ) ; player [ ] players = { new player ( player1data . getfirstelement ( ) , player1data . getsecondelement ( ) . getfirstelement ( ) , "w" , player1data . getsecondelement ( ) . getsecondelement ( ) ) , new player ( player2data . getfirstelement ( ) , player2data . getsecondelement ( ) . getfirstelement ( ) , "b" , player2data . getsecondelement ( ) . getsecondelement ( ) ) , } ; system . out . println ( "ccc" ) ; try { mastergui . newgame ( players , deadfields ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; } system . out . println ( "ddd" ) ; } }
tr	5	public void update ( ) { arraylist < arraylist < entity >> entityarrays = new arraylist < arraylist < entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { arraylist < entity > activearray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activearray . size ( ) ; y ++ ) { entity ent = activearray . get ( y ) ; arraylist < effectpackage > effects = ent . geteffectpackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { effectpackage pack = effects . get ( c ) ; if ( pack . geteffect ( ) == effect . move_up ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . geteffect ( ) == effect . move_down ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new arraylist < actor > ( actorhashmap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { actor a = actors . get ( c ) ; a . update ( ) ; point pos = a . getpos ( ) ; if ( a . delete ( ) ) { actorhashmap . remove ( genkey ( pos . getx ( ) , pos . gety ( ) ) ) ; } } }
tr	2	public coverdetails deserialize ( jsonobject json ) throws exception { integer id = ( integer ) json . get ( id_key ) ; string artist = ( string ) json . get ( artist_key ) ; string album = ( string ) json . get ( album_key ) ; integer discnumber = ( integer ) json . get ( disc_key ) ; boolean noimage = ( boolean ) json . get ( noimage_key ) ; jsonarray tracks = ( jsonarray ) json . get ( tracks_key ) ; int len = tracks . length ( ) ; list < trackdetails > tracknames = new arraylist < trackdetails > ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { jsonobject trackjson = ( jsonobject ) tracks . get ( i ) ; string title = ( string ) trackjson . get ( title_key ) ; integer lengthseconds = ( integer ) trackjson . get ( length_key ) ; tracknames . add ( new trackdetails ( title , lengthseconds . intvalue ( ) ) ) ; } image image = null ; coverdetails cover = new coverdetails ( id . intvalue ( ) , artist , album , image , discnumber . intvalue ( ) , noimage . booleanvalue ( ) ) ; cover . settracknames ( tracknames ) ; return cover ; }
tr	3	private void initialize ( ) { frmtexasholdempoker = new jframe ( ) ; frmtexasholdempoker . settitle ( "texas holdem poker main" ) ; frmtexasholdempoker . setbounds ( 100 , 100 , 513 , 330 ) ; frmtexasholdempoker . setdefaultcloseoperation ( jframe . exit_on_close ) ; jmenubar menubar = new jmenubar ( ) ; frmtexasholdempoker . setjmenubar ( menubar ) ; jmenu mnnewmenu = new jmenu ( "poker" ) ; menubar . add ( mnnewmenu ) ; jmenuitem mntmjugar = new jmenuitem ( "jugar" ) ; mntmjugar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showselectplayerform ( ) ; } } ) ; mnnewmenu . add ( mntmjugar ) ; jmenuitem mntmnewmenuitem = new jmenuitem ( "salir" ) ; mntmnewmenuitem . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnnewmenu . add ( mntmnewmenuitem ) ; jmenu mnsalaryhistorymain = new jmenu ( "historial de cargas" ) ; menubar . add ( mnsalaryhistorymain ) ; jmenuitem mntmsalaryhistory = new jmenuitem ( "consultar historial de cargas" ) ; mntmsalaryhistory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmsalaryhistory ) ; jmenuitem mntmaddplayer = new jmenuitem ( "agregar jugador" ) ; mntmaddplayer . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showcreateplayerform ( ) ; } } ) ; jmenuitem mntmaddcredit = new jmenuitem ( "cargar saldo" ) ; mntmaddcredit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmaddcredit ) ; mnsalaryhistorymain . add ( mntmaddplayer ) ; }
tr	2	public boolean noun2modifier ( dataholder dataholderhandler , string word ) { boolean isupdated = false ; arraylist < string > deletedposs = new arraylist < string > ( ) ; deletedposs . add ( "s" ) ; deletedposs . add ( "p" ) ; deletedposs . add ( "n" ) ; for ( string pos : deletedposs ) { dataholderhandler . deletewordpos ( true , word , true , pos ) ; } dataholderhandler . updatedataholder ( word , "m" , "" , "modifiers" , 1 ) ; string oldpattern = string . format ( "(^%s$|^.* %s$)" , word , word ) ; dataholderhandler . updatesentencetag ( oldpattern , null ) ; return isupdated ; }
tr	4	public firstchoicepercent ( algorithmoutput output ) { int total = 0 ; int firsts = 0 ; for ( timeslot t : output . keyset ( ) ) { for ( student s : output . get ( t ) ) { total ++ ; if ( s . getfirstchoicelabs ( ) . contains ( s . getassignedlab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( debug ) { system . out . println ( fitness ) ; } output . addfitness ( "firstchoicepercent" , fitness ) ; }
tr	1	@ test public void testconvexcut ( ) { point [ ] points = aconvex ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 5.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , zerop , onep ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 12.0 , - 1.0 ) , p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) , p ( 5.0 , 5.0 ) ) , convexcut ( points , onep , zerop ) ) ; assertequals ( arrays . aslist ( p ( 11.6 , 0.0 ) , p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) , p ( - 1.0 , 0.0 ) ) , convexcut ( points , zerop , p ( 1 , 0 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 5.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , p ( 7 , - 4 ) , p ( 5 , 5 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 7.5 , - 3.7 ) , p ( 6.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , p ( 7.5 , - 3.7 ) , p ( 6 , 5 ) ) ) ; assertequals ( arrays . aslist ( points ) , convexcut ( points , p ( 10 , 4 ) , p ( 6 , 5 ) ) ) ; assertequals ( arrays . aslist ( p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) ) , convexcut ( points , p ( 6 , 5 ) , p ( 10 , 4 ) ) ) ; assertequals ( arrays . aslist ( points ) , convexcut ( points , p ( 0 , - 100 ) , p ( 100 , - 100 ) ) ) ; assertequals ( arrays . aslist ( ) , convexcut ( points , p ( 100 , - 100 ) , p ( 0 , - 100 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1 , - 1 ) ) , convexcut ( points , p ( 99 , - 101 ) , p ( - 101 , 99 ) ) ) ; }
tr	1	public void init ( ) { chat = new xchatpa ( view . achatinput , view . achatbut , view . achattextarea , this ) ; myside = ! xnet . isserver ( ) ; fig . clear ( ) ; figdw . clear ( ) ; figdb . clear ( ) ; addfig ( 5 , 1 , 4 , myside , 1 ) ; addfig ( 4 , 1 , 5 , ! myside , 1 ) ; addfig ( 0 , 2 , 3 , ! myside , 1 ) ; for ( int i = 0 ; i < 10 ; i ++ ) arrays . fill ( map [ i ] , - 2 ) ; initfigures ( ) ; imgdb . loadall ( ) ; }
tr	5	private static collection < layer > parselayerargument ( model model , string layersarg ) { collection < layer > lays ; if ( layersarg . equalsignorecase ( "all" ) ) { lays = model . getlayer ( ) ; } else { string [ ] layersarg1 = layersarg . split ( " " ) ; lays = new arraylist < layer > ( ) ; for ( layer lay1 : model . getlayer ( ) ) { for ( string lan : layersarg1 ) { if ( lan . equals ( string . valueof ( lay1 . getnumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isempty ( ) ) { system . err . println ( "no matching layers found." ) ; system . exit ( 1 ) ; } return lays ; }
tr	4	private map < string , list < string >> decodeparams ( string s ) { map < string , list < string >> params = new linkedhashmap < string , list < string >> ( ) ; string name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charat ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodecomponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addparam ( params , decodecomponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addparam ( params , name , decodecomponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addparam ( params , decodecomponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addparam ( params , name , decodecomponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addparam ( params , name , "" ) ; } return params ; }
tr	3	public int generarboleto ( int sucursal_id , int usuario_id ) { connection cn = conexion . conectar ( ) ; preparedstatement pst ; preparedstatement pst2 ; resultset rs ; int idobtenido = 0 ; string queryinsertar = "insert into boletos(sucursal_id  usuario_id) values (" + sucursal_id + " " + usuario_id + ")" ; string queryobtenerid = "select max(boleto_id) as id from boletos" ; try { pst = cn . preparestatement ( queryinsertar ) ; pst2 = cn . preparestatement ( queryobtenerid ) ; pst . executeupdate ( ) ; rs = pst2 . executequery ( ) ; while ( rs . next ( ) ) { idobtenido = rs . getint ( "id" ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( null , "error al generar el boleto: " + ex ) ; } return idobtenido ; }
tr	1	@ override public arraylist < string > getinsertsql ( ) { arraylist < string > ret = new arraylist < > ( ) ; string sql = "insert into caballoscarrera values (" ; sql += getoid ( ) + "  " ; sql += caballo . getcaballo ( ) . getoid ( ) + "  " ; sql += carrera . getoid ( ) + "  " ; sql += caballo . getnumero ( ) + "  " ; sql += caballo . getdividendo ( ) + "  " ; sql += caballo . gettipoapuesta ( ) . getcodigo ( ) ; sql += ");" ; ret . add ( sql ) ; return ret ; }
tr	4	public void determinechunkstats ( ) { int emptyneighborindex = integer . min_value ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isrowempty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isrowempty = false ; } checkenemy ( i , j ) ; checkcannons ( i , j ) ; checktubes ( i , j ) ; checkhills ( i , j ) ; recordotherstats ( i , j ) ; } if ( isrowempty && i - 1 != emptyneighborindex ) { emptyneighborindex = i ; numjumps ++ ; difficulty ++ ; if ( this . type != type . jump && numjumps > getcurrenttypecount ( ) ) { this . type = type . jump ; } } else if ( isrowempty ) emptyneighborindex = i ; } }
tr	3	@ override public void endelement ( string uri , string localname , string qname ) throws saxexception { playxmlenum playxmlenum = playxmlenum . valueof ( qname . touppercase ( ) ) ; if ( playxmlenum == playxmlenum . date ) { int curid ; synchronized ( xmlplayshandler . class ) { curid = ++ dateid ; } currentplay . adddate ( curid , parsetime ( currplaydate ) ) ; } else if ( playxmlenum == playxmlenum . play ) { addplay ( currentplay ) ; } else if ( playxmlenum == playxmlenum . description ) { currentplay . setdescription ( currentdesc . tostring ( ) ) ; } currplayenum = null ; }
tr	2	public static final course readcourse ( file definitionfile ) { logger . log ( level . info , "reading course from file '" + definitionfile + "'" ) ; jsonparser parser = new jsonparser ( ) ; jsonobject jsonobject = null ; try { jsonobject = ( jsonobject ) parser . parse ( new filereader ( definitionfile ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } course course = new course ( ( string ) jsonobject . get ( "name" ) , ( string ) jsonobject . get ( "address" ) , ( int ) ( ( long ) jsonobject . get ( "bestscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "averagescore" ) ) , ( int ) ( ( long ) jsonobject . get ( "worstscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "timesplayed" ) ) , new arraylist < hole > ( ) , ( string ) jsonobject . get ( "userwithbestscore" ) , ( string ) jsonobject . get ( "description" ) ) ; logger . log ( level . info , "created course '" + course . getname ( ) + "'" ) ; return course ; }
tr	1	public static range parserange ( string key ) { range result = new range ( ) ; result . leftinclusive = key . startswith ( "[" ) ; result . rightinclusive = key . endswith ( "]" ) ; result . left = double . parsedouble ( key . substring ( 1 , key . indexof ( ";" ) ) . trim ( ) ) ; result . right = double . parsedouble ( key . substring ( key . indexof ( ";" ) + 1 , key . length ( ) - 1 ) . trim ( ) ) ; return result ; }
tr	5	public sla checkslaallocationcostmin ( sla slatemplate ) { sla slaallocation = ( sla ) slatemplate . clone ( ) ; map < string , type [ ] > allocations = new hashmap < string , type [ ] > ( ) ; set < type > alltypes = slaallocation . getheadnode ( ) . getconnectedtypes ( ) ; type sometype = alltypes . iterator ( ) . next ( ) ; list < resource > orderedresources = new arraylist < resource > ( ) ; orderedresources . addall ( resources . values ( ) ) ; collections . sort ( orderedresources , new costmincomparator ( sometype . getstarttime ( ) , sometype . getduration ( ) ) ) ; iterator < resource > resourceiterator = orderedresources . iterator ( ) ; iterator < type > typeiterator = alltypes . iterator ( ) ; resource r = resourceiterator . next ( ) ; list < type > typesforaresource = new arraylist < type > ( ) ; while ( typeiterator . hasnext ( ) ) { type t = typeiterator . next ( ) ; typesforaresource . add ( t ) ; while ( ! r . istypesfitting ( typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ) { typesforaresource . remove ( t ) ; if ( resourceiterator . hasnext ( ) ) { if ( typesforaresource . size ( ) > 0 ) { allocations . put ( r . getid ( ) , typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ; typesforaresource = new arraylist < type > ( ) ; } typesforaresource . add ( t ) ; r = resourceiterator . next ( ) ; } else { return null ; } } } if ( typesforaresource . size ( ) > 0 ) { allocations . put ( r . getid ( ) , typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ; } slaallocation . setallocation ( allocations ) ; return slaallocation ; }
tr	3	private chunk loadchunk ( string [ ] [ ] s , renderer rend ) { point p1 = new point ( integer . decode ( s [ 0 ] [ 0 ] ) , integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; chunk c ; const . debug ( "(savehandler:loadchunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(savehandler:loadchunk): spawn will be loaded" ) ; c = new spawnchunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(savehandler:loadchunk): underground will be loaded" ) ; c = new undergroundchunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(savehandler:loadchunk): sky will be loaded" ) ; c = new skychunk ( map , p1 , true , rend ) ; } else { const . debug ( "(savehandler:loadchunk): surface will be loaded" ) ; c = new surfacechunk ( map , p1 , true , rend , false ) ; ( ( surfacechunk ) c ) . biome = integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { system . err . println ( "error while loading chunk  wrong selection" ) ; system . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	1	@ test public void testclonesimplebean ( ) { bank bankfrom = new localbank ( ) ; bankfrom . setid ( 1 ) ; bankfrom . setname ( "alfabank" ) ; subject payer = new subject ( ) ; payer . setbank ( bankfrom ) ; payer . setid ( "payer" ) ; payer . setname ( "alice" ) ; bank bankto = new foreignbank ( ) ; bankto . setid ( 2 ) ; bankto . setname ( "citibank" ) ; subject receiver = new subject ( ) ; receiver . setbank ( bankto ) ; receiver . setid ( "receiver" ) ; receiver . setname ( "alice" ) ; payment pay = new payment ( 100 ) ; pay . setamount ( new bigdecimal ( "123.45" ) ) ; pay . setpayer ( payer ) ; pay . setreceiver ( receiver ) ; pay . settimestamp ( instant . now ( ) ) ; payment copy = beanhelper . cloneof ( pay ) ; assertnotsame ( pay , copy ) ; assertnotsame ( pay . getpayer ( ) , copy . getpayer ( ) ) ; assertnotsame ( pay . getreceiver ( ) , copy . getreceiver ( ) ) ; assertnotsame ( pay . getpayer ( ) . getbank ( ) , copy . getpayer ( ) . getbank ( ) ) ; assertnotsame ( pay . getreceiver ( ) . getbank ( ) , copy . getreceiver ( ) . getbank ( ) ) ; assertequals ( pay . getamount ( ) , copy . getamount ( ) ) ; assertequals ( pay . getid ( ) , copy . getid ( ) ) ; assertequals ( pay . gettimestamp ( ) , copy . gettimestamp ( ) ) ; subject cpayer = copy . getpayer ( ) ; subject creceiver = copy . getreceiver ( ) ; bank cbankfrom = cpayer . getbank ( ) ; bank cbankto = creceiver . getbank ( ) ; assertequals ( payer . getid ( ) , cpayer . getid ( ) ) ; assertequals ( payer . getname ( ) , cpayer . getname ( ) ) ; assertequals ( bankfrom . getid ( ) , cbankfrom . getid ( ) ) ; assertequals ( bankfrom . getname ( ) , cbankfrom . getname ( ) ) ; assertsame ( bankfrom . getclass ( ) , cbankfrom . getclass ( ) ) ; assertequals ( receiver . getid ( ) , creceiver . getid ( ) ) ; assertequals ( receiver . getname ( ) , creceiver . getname ( ) ) ; assertequals ( bankto . getid ( ) , cbankto . getid ( ) ) ; assertequals ( bankto . getname ( ) , cbankto . getname ( ) ) ; assertsame ( bankto . getclass ( ) , cbankto . getclass ( ) ) ; }
tr	4	string formatoption ( optionmetadata metadata , commandlineconfiguration config ) { string formattedoption = null ; if ( metadata . isparameteraccepted ( ) ) { boolean isparamrequired = ( metadata . getparametermetadata ( ) != null && metadata . getparametermetadata ( ) . isrequired ( ) ) ; string paramdelim = stringutil . formatdelimvalue ( config . getcommandlineproperties ( ) . getoptionparameterdelim ( ) ) ; string paramusagestr = "" ; if ( metadata . getparametermetadata ( ) != null && metadata . getparametermetadata ( ) . getparametertype ( ) != parametertype . none ) { string paramname = "" ; if ( metadata . getparametermetadata ( ) . getparametertype ( ) == parametertype . custom ) { paramname = metadata . getparametermetadata ( ) . getidentifier ( ) ; } else { paramname = metadata . getparametermetadata ( ) . getparametertype ( ) . name ( ) ; } paramusagestr = string . format ( ( isparamrequired ) ? "%s<%s>" : "[%s<%s>]" , paramdelim , paramname ) ; if ( metadata . ismultivalued ( ) ) { paramusagestr += "..." ; } } string longidentifier = metadata . getidentifier ( identifiertype . long ) ; if ( longidentifier != null && ! longidentifier . isempty ( ) ) { formattedoption = string . format ( "%s%s  %s%s%s" , config . getcommandlineproperties ( ) . getoptionprefix ( ) , metadata . getidentifier ( ) , config . getcommandlineproperties ( ) . getoptionlongprefix ( ) , metadata . getidentifier ( identifiertype . long ) , paramusagestr ) ; } else { formattedoption = string . format ( "%s%s%s" , config . getcommandlineproperties ( ) . getoptionprefix ( ) , metadata . getidentifier ( ) , paramusagestr ) ; } } else { string longidentifier = metadata . getidentifier ( identifiertype . long ) ; if ( longidentifier != null && ! longidentifier . isempty ( ) ) { formattedoption = string . format ( "%s%s  %s%s" , config . getcommandlineproperties ( ) . getoptionprefix ( ) , metadata . getidentifier ( ) , config . getcommandlineproperties ( ) . getoptionlongprefix ( ) , metadata . getidentifier ( identifiertype . long ) ) ; } else { formattedoption = string . format ( "%s%s" , config . getcommandlineproperties ( ) . getoptionprefix ( ) , metadata . getidentifier ( ) ) ; } } return formattedoption ; }
tr	2	public hiddenneuron ( double gain , double timeconstant , double bias , double selfweight , double ... sensorweights ) { this . gain = gain ; this . timeconstant = timeconstant ; this . bias = bias ; this . selfweight = selfweight ; this . connections = new arraylist < object [ ] > ( ) ; if ( sensorweights . length != 5 ) try { throw new exception ( "wrong amount of weights passed to constructor!" ) ; } catch ( exception ex ) { logger . getlogger ( hiddenneuron . class . getname ( ) ) . log ( level . severe , null , ex ) ; ex . printstacktrace ( ) ; } this . sensorweights = sensorweights ; }
tr	4	private int compareinputstreams ( inputstream encfsis , inputstream decfsis , string decodedfsfilename ) throws ioexception { int bytesread = 0 ; int bytesread2 ; while ( bytesread >= 0 ) { byte [ ] readbuf = new byte [ 128 ] ; byte [ ] readbuf2 = new byte [ 128 ] ; bytesread = encfsis . read ( readbuf ) ; bytesread2 = decfsis . read ( readbuf2 ) ; if ( bytesread != bytesread2 ) { logger . error ( "file bytes read missmatch {} ({}  {})" , new object [ ] { decodedfsfilename , bytesread , bytesread2 } ) ; return - 1 ; } if ( ! arrays . equals ( readbuf , readbuf2 ) ) { logger . error ( "file bytes missmatch {}" , decodedfsfilename ) ; return - 1 ; } } return 0 ; }
tr	5	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; if ( level != 1 ) { jpanel1 . setenabled ( false ) ; jbutton2 . setenabled ( false ) ; jbutton3 . setenabled ( false ) ; jbutton4 . setenabled ( false ) ; jbutton6 . setenabled ( false ) ; } double catnumeber = dbutil . loadcategories ( ) . length ; int rows = ( int ) math . ceil ( catnumeber / 5 ) ; jpanel2 . setlayout ( new gridlayout ( rows , 5 , 4 , 4 ) ) ; jpanel3 . setvisible ( false ) ; string array [ ] [ ] = dbutil . loadcategories ( ) ; for ( int i = 0 ; i < catnumeber ; i ++ ) { final jbutton btn = new jbutton ( string . valueof ( array [ i ] [ 1 ] ) ) ; jpanel buttonpane = new jpanel ( ) ; btn . setname ( string . valueof ( array [ i ] [ 0 ] ) ) ; btn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae2 ) { jpanel2 . setvisible ( false ) ; jpanel itempane = new jpanel ( ) ; itempane . setlayout ( new gridlayout ( 5 , 5 , 5 , 5 ) ) ; itempane . setvisible ( true ) ; try { loaditems ( btn . getname ( ) ) ; } catch ( sqlexception ex ) { logger . getlogger ( sales . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; buttonpane . add ( btn ) ; jpanel2 . add ( buttonpane ) ; } add ( jpanel2 ) ; pack ( ) ; setvisible ( true ) ; }
tr	5	public vector < string > enumdatabases ( ) { vector < string > instances = new vector < string > ( ) ; connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errmsg = "can't connect to management database" ; return instances ; } statement stmt = session . createstatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { resultset r = stmt . getresultset ( ) ; if ( r != null ) { while ( r . next ( ) ) { string name = r . getstring ( "datname" ) ; instances . add ( name ) ; } } } errmsg = null ; } catch ( sqlexception e ) { errmsg = e . getmessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( sqlexception e ) { } } return instances ; }
tr	4	public void draw ( ) { iterator < entity > i2 = getnearbyentities ( p . getlocation ( ) , 15 ) . iterator ( ) ; arraylist < block > bs = getnearbyblocks ( p . getlocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( block b : bs ) { b . draw ( ) ; } while ( i2 . hasnext ( ) ) { entity todraw = i2 . next ( ) ; todraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { engine . render ( path . get ( c ) , material . gold_ore . getimage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { engine . render ( path . get ( c ) , material . iron_ore . getimage ( ) ) ; } else { engine . render ( path . get ( c ) , material . obsidian . getimage ( ) ) ; } } } if ( renderlight ) { engine . addqueueitem ( new renderqueueitem ( lightloc , lightmap ) ) ; } if ( drawmap ) { engine . addqueueitem ( new renderqueueitem ( new rectangle ( 0 , 0 , main . getpanewidth ( ) , main . getpaneheight ( ) ) , color . blue ) ) ; engine . addqueueitem ( new renderqueueitem ( 0 , 0 , map ) ) ; } }
tr	5	protected filerequestresponsemessage handleresponse ( inputstream in ) throws unsupportedencodingexception { filerequestresponsemessage try_again = new filerequestresponsemessage ( filerequestresponsemessage . responsecode . try_again_later , 0 ) ; int probe_len = filerequestresponsemessage . type_field . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( ioexception e ) { logger . log ( level . severe , "could not read response stream: '" + e . getmessage ( ) + "' - assuming 'never try again'" ) ; return try_again ; } string responseheader = new string ( buffer , message . encoding ) . trim ( ) ; switch ( responseheader . touppercase ( ) ) { case filerequestresponsemessage . type_field + message . field_seperator + "ok" : string str_expectedtransfervolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != message . message_sperator ) if ( next == - 1 ) { thread . sleep ( 500 ) ; } else { str_expectedtransfervolume += new string ( new byte [ ] { ( byte ) next } , message . encoding ) ; } } catch ( ioexception | interruptedexception e ) { logger . log ( level . severe , "could not understand response header" ) ; transferstate = transferstatus . lostconnection ; closesocket ( ) ; return null ; } try { long expectedtransfervolume = long . valueof ( str_expectedtransfervolume ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . ok , expectedtransfervolume ) ; } catch ( numberformatexception ex ) { logger . log ( level . severe , "response contained invalid 'expected transfer volume' - assuming 'try again later'" ) ; return try_again ; } case filerequestresponsemessage . type_field + message . field_seperator + "try" : logger . log ( level . info , "received 'try again later from host'" ) ; return try_again ; case filerequestresponsemessage . type_field + message . field_seperator + "nev" : logger . log ( level . info , "received 'never try agiain from host'" ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . never_try_again , 0 ) ; default : logger . log ( level . info , "received garbage: '" + responseheader + "'" ) ; return try_again ; } }
tr	4	public static void recovertree ( treenode root ) { int prevalue = integer . min_value ; int currentvalue = integer . min_value ; stack < treenode > stack = new stack < treenode > ( ) ; treenode pre1 = null ; treenode pre2 = null ; treenode cur = root ; treenode prenode = null ; while ( cur != null || ! stack . isempty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; system . out . println ( stack . size ( ) ) ; currentvalue = cur . val ; if ( currentvalue < prevalue ) { if ( pre1 == null ) { pre1 = prenode ; pre2 = cur ; } else { pre2 = cur ; break ; } } prenode = cur ; prevalue = currentvalue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	4	private void jbuttoncheckroomsactionperformed ( java . awt . event . actionevent evt ) { dflrooms . removeallelements ( ) ; if ( "" . equals ( jxdatepickercheckroomarrival . geteditor ( ) . gettext ( ) ) || "" . equals ( jxdatepickercheckroomdeparture . geteditor ( ) . gettext ( ) ) ) { joptionpane . showmessagedialog ( rootpane , "make sure both arrival and departure date are entered and in the correct format" ) ; } else { dateformat dateformat = new simpledateformat ( "yyyy-mm-dd" ) ; jxdatepickercheckroomarrival . setformats ( dateformat ) ; jxdatepickercheckroomdeparture . setformats ( dateformat ) ; string arrival = dateformat . format ( jxdatepickercheckroomarrival . getdate ( ) ) . tostring ( ) ; string departure = dateformat . format ( jxdatepickercheckroomdeparture . getdate ( ) ) . tostring ( ) ; r = con . getroomslist ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflrooms . addelement ( r . get ( i ) . tostring ( ) ) ; } } else { statuslabel . settext ( "could not get rooms" ) ; } con . resetrooms ( ) ; } }
tr	4	public mainmenuview ( checkmate c ) { super ( c ) ; jlabel titlelabel = new jlabel ( "checkmate 3000 network ai edition" ) ; titlelabel . setforeground ( color . white ) ; titlelabel . setfont ( new font ( font . sans_serif , font . plain , 42 ) ) ; titlelabel . setsize ( 680 , 50 ) ; titlelabel . setlocation ( c . getwidth ( ) / 2 - titlelabel . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.200 ) ) ; add ( titlelabel ) ; jbutton localbutton = new jbutton ( "local game" ) ; localbutton . setsize ( 150 , 35 ) ; localbutton . setlocation ( c . getwidth ( ) / 2 - localbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.480 ) ) ; localbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . local ) ; } } ) ; add ( localbutton ) ; jbutton hostbutton = new jbutton ( "host game" ) ; hostbutton . setsize ( 150 , 35 ) ; hostbutton . setlocation ( c . getwidth ( ) / 2 - hostbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.555 ) ) ; hostbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . host ) ; } } ) ; add ( hostbutton ) ; jbutton joinbutton = new jbutton ( "join game" ) ; joinbutton . setsize ( 150 , 35 ) ; joinbutton . setlocation ( c . getwidth ( ) / 2 - joinbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.630 ) ) ; joinbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . join ) ; } } ) ; add ( joinbutton ) ; jbutton logbutton = new jbutton ( "view logged game" ) ; logbutton . setsize ( 150 , 35 ) ; logbutton . setlocation ( c . getwidth ( ) / 2 - logbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.705 ) ) ; logbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . log ) ; } } ) ; add ( logbutton ) ; jbutton quitbutton = new jbutton ( "quit game" ) ; quitbutton . setsize ( 150 , 35 ) ; quitbutton . setlocation ( c . getwidth ( ) / 2 - quitbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.780 ) ) ; quitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { int wantsexit = joptionpane . showconfirmdialog ( mycheckmate , "are you sure you want to exit the program?" , "exit program?" , joptionpane . yes_no_option ) ; if ( wantsexit == joptionpane . yes_option ) { system . exit ( 0 ) ; } } } ) ; add ( quitbutton ) ; }
tr	3	@ suppresswarnings ( "unchecked" ) public t nextconcrete ( ) { t genobj = null ; try { initfieldgenerators ( ) ; genobj = ( t ) utils . getdummyobject ( this . type ) ; reflector r1 = new reflector ( genobj ) ; field [ ] fields = r1 . getfields ( genobj ) ; for ( field f : fields ) { f . set ( genobj , fieldgenerators . get ( f ) . next ( ) ) ; } } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } return genobj ; }
tr	3	public static bufferedimage getimage ( string filename ) { bufferedimage i = null ; string path = "../images/" ; file f = null ; try { f = new file ( resourceloader . class . getresource ( path + filename ) . getpath ( ) ) ; } catch ( nullpointerexception e ) { console . log ( "file + " + filename + " is not there" , in . error ) ; e . printstacktrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isdirectory ( ) ) { try { i = imageio . read ( r . getclass ( ) . getclassloader ( ) . getresource ( "images/" + filename ) ) ; } catch ( exception e ) { console . log ( "image= " + filename + " is not located here" , console . in . error ) ; e . printstacktrace ( ) ; } } return i ; }
tr	4	private object readliteral ( ) throws jsonexception { string literal = nexttointernal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxerror ( "expected literal value" ) ; } else if ( "null" . equalsignorecase ( literal ) ) { return jsonobject . null ; } else if ( "true" . equalsignorecase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsignorecase ( literal ) ) { return boolean . false ; } if ( literal . indexof ( . ) == - 1 ) { int base = 10 ; string number = literal ; if ( number . startswith ( "0x" ) || number . startswith ( "0x" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startswith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longvalue = long . parselong ( number , base ) ; if ( longvalue <= integer . max_value && longvalue >= integer . min_value ) { return ( int ) longvalue ; } else { return longvalue ; } } catch ( numberformatexception e ) { } } try { return double . valueof ( literal ) ; } catch ( numberformatexception ignored ) { } return new string ( literal ) ; }
tr	2	public dimension resizeriskboard ( int height , int width ) { dimension d = background . resizeimage ( height , width ) ; this . setpreferredsize ( d ) ; this . setminimumsize ( d ) ; this . setmaximumsize ( d ) ; this . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; map . setpreferredsize ( d ) ; map . setminimumsize ( d ) ; map . setmaximumsize ( d ) ; map . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; buttonpanel . setpreferredsize ( d ) ; buttonpanel . setminimumsize ( d ) ; buttonpanel . setmaximumsize ( d ) ; buttonpanel . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; background . setpreferredsize ( d ) ; background . setminimumsize ( d ) ; background . setmaximumsize ( d ) ; background . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; repaint ( ) ; for ( countrybutton c : countrybuttons . values ( ) ) { c . setcurrentposition ( d . width , d . height ) ; } return d ; }
tr	1	public subeditor ( subsystem - ) { this . settitle ( "subeditor - " + - . getname ( ) ) ; namefield . settext ( - . getname ( ) ) ; this . setmodal ( true ) ; jpanel np = new jpanel ( ) ; np . setlayout ( new flowlayout ( flowlayout . leading ) ) ; np . add ( new jlabel ( "name:" ) ) ; np . add ( namefield ) ; add ( np , borderlayout . north ) ; namefield . addactionlistener ( this ) ; panel = - . getsubpanel ( ) ; addparammenu ( ) ; addhelpmenu ( ) ; this . makecomponenttb ( ) ; paneljsp = new jscrollpane ( panel ) ; paneljsp . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_as_needed ) ; paneljsp . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; add ( paneljsp ) ; add ( componenttb , borderlayout . west ) ; this . setdefaultcloseoperation ( jframe . hide_on_close ) ; this . setsize ( 800 , 600 ) ; this . setlocationrelativeto ( null ) ; }
tr	2	@ test public void inserttoattachmenttest ( ) { attachmentmodel attachmentmodel = new attachmentmodel ( ) ; file file = new file ( "f:\\updata.txt" ) ; byte [ ] bfile = new byte [ ( int ) file . length ( ) ] ; try { fileinputstream fis = new fileinputstream ( file ) ; fis . read ( bfile ) ; fis . close ( ) ; attachmentmodel . setattachment_data ( bfile ) ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } attachmentmodel . setattachment_type ( "\u56fe\u7247" ) ; attachmentmanageservice . inserttoattachment ( attachmentmodel ) ; }
tr	4	@ override public void doinbackground ( ) { int slashes = this . address . indexof ( / ) ; int dots = this . address . indexof ( . ) ; if ( ( dots >= 1 ) && ( slashes > 0 ) && ( slashes < this . address . length ( ) - 1 ) ) { try { urlconnection connection = new url ( "http://" + this . address ) . openconnection ( ) ; int totalsize = connection . getcontentlength ( ) ; bufferedinputstream input = new bufferedinputstream ( connection . getinputstream ( ) ) ; fileoutputstream output = new fileoutputstream ( this . outputfile ) ; int read ; double totalread = 0 ; while ( ( read = input . read ( ) ) != - 1 ) { output . write ( read ) ; ++ totalread ; this . setprogress ( ( int ) ( 100.0 / totalsize * totalread ) ) ; } input . close ( ) ; output . close ( ) ; string version = this . address . substring ( this . address . indexof ( _ ) + 1 , this . address . lastindexof ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . setcurrentversion ( version ) ; } catch ( exception e ) { new spopup ( new spopupdata ( e ) ) ; } this . updateframe . closeframe ( ) ; } else { this . errorpopup = new spopup ( new spopupdata ( new sexception ( "invalid address" ) ) ) ; this . errorpopup . injectactionlistener ( this ) ; } return null ; }
tr	5	public void run ( ) { searchfield . settext ( "" ) ; searchfield . settext ( selectionfield . searchterm ) ; treemap < integer , list < champion >> priorities = new treemap < integer , list < champion >> ( ) ; for ( champion c : initialiser . getchampionlist ( ) ) { int priority = c . calculatepriority ( ) ; list < champion > prioritylist = priorities . get ( priority ) ; if ( prioritylist == null ) { prioritylist = new linkedlist < champion > ( ) ; priorities . put ( priority , prioritylist ) ; } prioritylist . add ( c ) ; } entry < integer , list < champion >> e = priorities . polllastentry ( ) ; recommendedmodel . clear ( ) ; goodmodel . clear ( ) ; viablemodel . clear ( ) ; allmodel . clear ( ) ; if ( e != null ) { for ( champion c : e . getvalue ( ) ) recommendedmodel . addelement ( c ) ; e = priorities . polllastentry ( ) ; if ( e != null ) { for ( champion c : e . getvalue ( ) ) goodmodel . addelement ( c ) ; e = priorities . polllastentry ( ) ; if ( e != null ) { for ( champion c : e . getvalue ( ) ) viablemodel . addelement ( c ) ; e = priorities . polllastentry ( ) ; while ( e != null ) { for ( champion c : e . getvalue ( ) ) allmodel . addelement ( c ) ; e = priorities . polllastentry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	3	@ suppresswarnings ( "unchecked" ) private void initcomponents ( ) { drawpanel = new javax . swing . jpanel ( ) ; treepanel = new javax . swing . jpanel ( ) ; jscrollpane1 = new javax . swing . jscrollpane ( ) ; optionstree = new javax . swing . jtree ( ) ; infolabel = new javax . swing . jlabel ( ) ; jmenubar1 = new javax . swing . jmenubar ( ) ; jmenu1 = new javax . swing . jmenu ( ) ; jmenuitem1 = new javax . swing . jmenuitem ( ) ; jmenuitem2 = new javax . swing . jmenuitem ( ) ; jmenu2 = new javax . swing . jmenu ( ) ; setdefaultcloseoperation ( javax . swing . windowconstants . exit_on_close ) ; drawpanel . setlayout ( new java . awt . borderlayout ( ) ) ; javax . swing . tree . defaultmutabletreenode treenode1 = new javax . swing . tree . defaultmutabletreenode ( "options" ) ; javax . swing . tree . defaultmutabletreenode treenode2 = new javax . swing . tree . defaultmutabletreenode ( "pre-processor" ) ; javax . swing . tree . defaultmutabletreenode treenode3 = new javax . swing . tree . defaultmutabletreenode ( "element" ) ; javax . swing . tree . defaultmutabletreenode treenode4 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "material" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; treenode2 = new javax . swing . tree . defaultmutabletreenode ( "tube configuration" ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "library" ) ; javax . swing . tree . defaultmutabletreenode treenode5 = new javax . swing . tree . defaultmutabletreenode ( "u bend" ) ; treenode4 . add ( treenode5 ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "straight" ) ; treenode4 . add ( treenode5 ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "free" ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "node" ) ; treenode4 . add ( treenode5 ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "element" ) ; treenode4 . add ( treenode5 ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "support" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "loose support" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "support parameters" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "mesh" ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; treenode2 = new javax . swing . tree . defaultmutabletreenode ( "solution" ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "apply" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "constraint" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "force" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "pressure" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "spring" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "fluid flow" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "add group" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "turbulence" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "fei" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "solution typo" ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; optionstree . setmodel ( new javax . swing . tree . defaulttreemodel ( treenode1 ) ) ; optionstree . setfocusable ( false ) ; optionstree . addmouselistener ( new java . awt . event . mouseadapter ( ) { public void mouseclicked ( java . awt . event . mouseevent evt ) { optionstreemouseclicked ( evt ) ; } } ) ; optionstree . addtreeselectionlistener ( new javax . swing . event . treeselectionlistener ( ) { public void valuechanged ( javax . swing . event . treeselectionevent evt ) { optionstreevaluechanged ( evt ) ; } } ) ; jscrollpane1 . setviewportview ( optionstree ) ; infolabel . settext ( " " ) ; javax . swing . grouplayout treepanellayout = new javax . swing . grouplayout ( treepanel ) ; treepanel . setlayout ( treepanellayout ) ; treepanellayout . sethorizontalgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( javax . swing . grouplayout . alignment . trailing , treepanellayout . createsequentialgroup ( ) . addgap ( 0 , 0 , short . max_value ) . addgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading , false ) . addcomponent ( jscrollpane1 ) . addcomponent ( infolabel , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) ) ) ) ; treepanellayout . setverticalgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( treepanellayout . createsequentialgroup ( ) . addcomponent ( jscrollpane1 ) . addpreferredgap ( javax . swing . layoutstyle . componentplacement . related ) . addcomponent ( infolabel ) ) ) ; jmenu1 . settext ( "file" ) ; jmenuitem1 . settext ( "file" ) ; jmenuitem1 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuitem1actionperformed ( evt ) ; } } ) ; jmenu1 . add ( jmenuitem1 ) ; jmenuitem2 . settext ( "run" ) ; jmenuitem2 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuitem2actionperformed ( evt ) ; } } ) ; jmenu1 . add ( jmenuitem2 ) ; jmenubar1 . add ( jmenu1 ) ; jmenu2 . settext ( "edit" ) ; jmenubar1 . add ( jmenu2 ) ; setjmenubar ( jmenubar1 ) ; javax . swing . grouplayout layout = new javax . swing . grouplayout ( getcontentpane ( ) ) ; getcontentpane ( ) . setlayout ( layout ) ; layout . sethorizontalgroup ( layout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( layout . createsequentialgroup ( ) . addcomponent ( treepanel , javax . swing . grouplayout . preferred_size , javax . swing . grouplayout . default_size , javax . swing . grouplayout . preferred_size ) . addpreferredgap ( javax . swing . layoutstyle . componentplacement . related ) . addcomponent ( drawpanel , javax . swing . grouplayout . default_size , 584 , short . max_value ) ) ) ; layout . setverticalgroup ( layout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addcomponent ( drawpanel , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) . addcomponent ( treepanel , javax . swing . grouplayout . alignment . trailing , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) ) ; pack ( ) ; }
tr	4	public void generate ( point start ) { stack < point > waystoexpand = new stack < > ( ) ; exitfound = false ; final list < point > nextoptions = new arraylist < > ( 4 ) ; waystoexpand . add ( start ) ; while ( ! waystoexpand . isempty ( ) ) { point p = waystoexpand . pop ( ) ; if ( canbecomewhite ( p ) ) { arr . setwhite ( p ) ; if ( ontheedge ( p ) && p . differsfrom ( start ) ) { exitfound = true ; } if ( isblack ( p . up ( ) ) && canbecomewhite ( p . up ( ) ) ) nextoptions . add ( p . up ( ) ) ; if ( isblack ( p . down ( ) ) && canbecomewhite ( p . down ( ) ) ) nextoptions . add ( p . down ( ) ) ; if ( isblack ( p . left ( ) ) && canbecomewhite ( p . left ( ) ) ) nextoptions . add ( p . left ( ) ) ; if ( isblack ( p . right ( ) ) && canbecomewhite ( p . right ( ) ) ) nextoptions . add ( p . right ( ) ) ; collections . shuffle ( nextoptions ) ; int c = 0 ; for ( point t : nextoptions ) { waystoexpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextoptions . clear ( ) ; } } }
tr	2	private static expr resolvenoneparamexpr ( syntaxtreenode node ) { lextoken token = node . gettoken ( ) ; string text = token . gettext ( ) ; switch ( ( nagisalextokentype ) token . gettype ( ) ) { case literal_integer : return new expr ( exprtype . integer , exproperator . integerliteral , text ) ; case identifier_integer : return new expr ( exprtype . integer , exproperator . integervariableref , text ) ; case literal_string : return new expr ( exprtype . string , exproperator . stringliteral , text ) ; case identifier_string : return new expr ( exprtype . string , exproperator . stringvariableref , text ) ; default : throw new unsupportedoperationexception ( token . tostring ( ) ) ; } }
tr	1	@ test public void testrenderlong ( ) { long value = long . min_value ; byte [ ] data = null ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == long . min_value ) ; value = long . max_value ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == long . max_value ) ; value = - 1 ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == - 1 ) ; }
tr	3	@ override public final void setgeometry ( final object geometry ) { if ( geometry instanceof string [ ] ) { final string [ ] geometryarray = ( string [ ] ) geometry ; if ( geometryarray . length != 4 ) { throw new illegalargumentexception ( "geometry must be an array of four elements that contains racolname  deccolname  timecolname and bandcolname" ) ; } else { this . racol = geometryarray [ 0 ] ; this . deccol = geometryarray [ 1 ] ; this . timecol = geometryarray [ 2 ] ; this . bandcol = geometryarray [ 3 ] ; } } else { throw new illegalargumentexception ( "geometry must be an array of four elements that contains racolname  deccolname  timecolname and bandcolname" ) ; } }
tr	2	public static byte [ ] decompress ( byte [ ] data ) throws ioexception , dataformatexception { inflater inflater = new inflater ( ) ; inflater . setinput ( data ) ; inflater . finished ( ) ; bytearrayoutputstream outputstream = new bytearrayoutputstream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputstream . write ( buffer , 0 , count ) ; } outputstream . close ( ) ; byte [ ] output = outputstream . tobytearray ( ) ; inflater . end ( ) ; return output ; }
tr	2	public session createsession ( string uristring , string params , clientproxy proxy , map < string , object > httpparams ) { try { uri uri = new uri ( uristring ) ; sessionfactory found = registry . get ( uri . getscheme ( ) ) ; if ( found == null ) throw new clienterror ( "could not open uri '" + uristring + "'. unknown scheme - '" + uri . getscheme ( ) + "'." + "make sure you have registered your sessionfactory with this transport." ) ; return found . newsession ( uri , params , proxy , httpparams ) ; } catch ( urisyntaxexception e ) { throw new clienterror ( e ) ; } }
tr	1	private void createtypeadder ( composite parent ) { shell shell = parent . getshell ( ) ; composite group = new composite ( parent , swt . none ) ; group . setlayoutdata ( new griddata ( griddata . fill_both ) ) ; gridlayout layout = new gridlayout ( 4 , false ) ; layout . horizontalspacing = 3 ; layout . marginwidth = 0 ; layout . marginheight = 0 ; group . setlayout ( layout ) ; label label = new label ( group , swt . none ) ; label . settext ( "name" ) ; text name = new text ( group , swt . border | swt . single ) ; button collapse = new button ( group , swt . check ) ; collapse . settext ( "initially collapse" ) ; button button = new button ( group , swt . none ) ; button . settext ( "add" ) ; button . addlistener ( swt . selection , new addentryhandler ( name , collapse , shell ) ) ; }
tr	2	public void initnew ( ) { if ( adatamap == null ) adatamap = new hashmap < asection , adata > ( ) ; else adatamap . clear ( ) ; try { this . replace ( 0 , getlength ( ) , "" , defaultstyle ) ; } catch ( badlocationexception e ) { system . out . println ( "error in adocument.initnew() :\n" ) ; e . printstacktrace ( ) ; } putproperty ( ( object ) titleproperty , ( object ) default_title ) ; putproperty ( ( object ) expertproperty , ( object ) "" ) ; putproperty ( ( object ) clientproperty , ( object ) "" ) ; date date = new date ( ) ; putproperty ( ( object ) dateproperty , ( object ) date . tolocalestring ( ) ) ; putproperty ( ( object ) commentproperty , "" ) ; setcharacterattributes ( 0 , 1 , defaultstyle , true ) ; fireadocumentchanged ( ) ; analyst . initundomanager ( ) ; }
tr	1	public boardviewimpl ( ) { addmouselistener ( this ) ; setpreferredsize ( new dimension ( 483 , 500 ) ) ; imgboard = new imageicon ( constant . board_dir + "board.png" ) . getimage ( ) ; imgselect = new imageicon ( constant . image_dir + "select.png" ) . getimage ( ) ; imgcanmove = new imageicon ( constant . image_dir + "canmove.png" ) . getimage ( ) ; imgcankill = new imageicon ( constant . image_dir + "cankill.png" ) . getimage ( ) ; imgwarnking = new imageicon ( constant . image_dir + "chieutuong.png" ) . getimage ( ) ; imgfinish = new imageicon ( constant . image_dir + "hetco.png" ) . getimage ( ) ; imgtuongdo = new imageicon ( constant . chess_dir + "tuongdo.png" ) . getimage ( ) ; imgsydo = new imageicon ( constant . chess_dir + "sydo.png" ) . getimage ( ) ; imgtinhdo = new imageicon ( constant . chess_dir + "tinhdo.png" ) . getimage ( ) ; imgxedo = new imageicon ( constant . chess_dir + "xedo.png" ) . getimage ( ) ; imgphaodo = new imageicon ( constant . chess_dir + "phaodo.png" ) . getimage ( ) ; imgmado = new imageicon ( constant . chess_dir + "mado.png" ) . getimage ( ) ; imgtotdo = new imageicon ( constant . chess_dir + "totdo.png" ) . getimage ( ) ; imgtuongden = new imageicon ( constant . chess_dir + "tuongden.png" ) . getimage ( ) ; imgsyden = new imageicon ( constant . chess_dir + "syden.png" ) . getimage ( ) ; imgtinhden = new imageicon ( constant . chess_dir + "tinhden.png" ) . getimage ( ) ; imgxeden = new imageicon ( constant . chess_dir + "xeden.png" ) . getimage ( ) ; imgphaoden = new imageicon ( constant . chess_dir + "phaoden.png" ) . getimage ( ) ; imgmaden = new imageicon ( constant . chess_dir + "maden.png" ) . getimage ( ) ; imgtotden = new imageicon ( constant . chess_dir + "totden.png" ) . getimage ( ) ; }
tr	1	public void testsimplecoffee ( ) { coffee coffee = new brasilcofee ( ) ; assertcofeeprice ( "brazil coffee" , coffee , brasilcofee . cost ) ; assertcoffeeingredients ( "brazil coffee" , coffee , arrays . aslist ( brasilcofee . description ) ) ; coffee = new portugalcoffee ( ) ; assertcofeeprice ( "portugal coffee" , coffee , portugalcoffee . cost ) ; assertcoffeeingredients ( "portugal coffee" , coffee , arrays . aslist ( portugalcoffee . description ) ) ; coffee = new deliciouscoffee ( ) ; assertcofeeprice ( "delicious coffee" , coffee , deliciouscoffee . cost ) ; assertcoffeeingredients ( "delicious coffee" , coffee , arrays . aslist ( deliciouscoffee . description ) ) ; }
tr	1	@ ignore public void testhandleresponse ( ) throws unsupportedencodingexception { filerequestresponsemessage ok = new filerequestresponsemessage ( responsecode . ok , 1012 ) ; filerequestresponsemessage tryagain = new filerequestresponsemessage ( responsecode . try_again_later , 0 ) ; filerequestresponsemessage neveragain = new filerequestresponsemessage ( responsecode . never_try_again , 0 ) ; inputstream ok_fs = new bytearrayinputstream ( ok . serialize ( ) . getbytes ( message . encoding ) ) ; inputstream tryagain_fs = new bytearrayinputstream ( tryagain . serialize ( ) . getbytes ( message . encoding ) ) ; inputstream neveragain_fs = new bytearrayinputstream ( neveragain . serialize ( ) . getbytes ( message . encoding ) ) ; assertequals ( ok , ( new testwrapper ( ) ) . handleresponse ( ok_fs ) ) ; assertequals ( tryagain , ( new testwrapper ( ) ) . handleresponse ( tryagain_fs ) ) ; assertequals ( neveragain , ( new testwrapper ( ) ) . handleresponse ( neveragain_fs ) ) ; }
tr	3	protected void action ( source source , map < string , object > map , int i ) throws exception { log . debug ( string . format ( "loop [%s] step %d." , getname ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickone ( "value" , "base" ) ) ; } if ( getbeforeaction ( ) == null || getbeforeaction ( ) . invoke ( getcontext ( ) , this , i ) ) { for ( insert insert : getinserts ( ) ) { log . debug ( string . format ( "loop [%s] step %d  insert %s" , getname ( ) , i , insert . getname ( ) ) ) ; insert . execute ( ) ; } for ( loop loop : getloops ( ) ) { log . debug ( string . format ( "loop [%s] step %d  loop %s" , getname ( ) , i , loop . getname ( ) ) ) ; loop . execute ( ) ; } if ( getaction ( ) != null ) { getaction ( ) . invoke ( getcontext ( ) , this , i ) ; } if ( getafteraction ( ) != null ) { getafteraction ( ) . invoke ( getcontext ( ) , this , i ) ; } } }
tr	1	private void initializecomponents ( ) { this . setlayout ( new borderlayout ( ) ) ; ingredientpanel = new ingredientpanel ( ) ; ingredientpanel . addchangelistener ( this ) ; textpanel = new jpanel ( new borderlayout ( ) ) ; textpane = new jtextarea ( ) ; textpane . setlinewrap ( true ) ; textpane . setlinewrap ( true ) ; textpane . setwrapstyleword ( true ) ; textpane . seteditable ( true ) ; textpane . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; textscrollpane = new jscrollpane ( textpane ) ; textscrollpane . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; textscrollpane . setpreferredsize ( new dimension ( 450 , 200 ) ) ; headline = new jtextfield ( ) ; headline . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; this . setpreferredsize ( new dimension ( 750 , 250 ) ) ; }
tr	2	public static class gettype ( class c ) { if ( c == null ) { logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getactualtype ( c . getgenericsuperclass ( ) ) ; if ( ct != null ) return ct ; type [ ] interfaces = c . getgenericinterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( type t : interfaces ) { ct = getactualtype ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	4	public defaultsettingsmodifierpanel ( gct gctarg , boolean [ ] editedarg ) { gct = gctarg ; edited = editedarg ; setlayout ( new borderlayout ( ) ) ; usecode = new jcheckbox ( "include default settings modifier" , finddsminstance ( ) ) ; usecode . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { edited [ 0 ] = true ; if ( dsm != null ) { gct . deletedynamiccode ( dsm ) ; dsm = null ; } else { dsm = new dsm ( ) ; gct . adddynamiccode ( dsm ) ; } initialize ( ) ; } } ) ; add ( usecode , borderlayout . north ) ; container = new jpanel ( ) ; container . setlayout ( new boxlayout ( container , boxlayout . y_axis ) ) ; jpanel [ ] rows = { new jpanel ( ) , new jpanel ( ) , new jpanel ( ) } ; for ( jpanel p : rows ) { p . setlayout ( new boxlayout ( p , boxlayout . x_axis ) ) ; container . add ( p ) ; } add ( container , borderlayout . center ) ; gametype = new jcombobox ( ) ; gametype . additem ( "time" ) ; gametype . additem ( "stock" ) ; gametype . additem ( "coin" ) ; gametype . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setgametype ( ( byte ) gametype . getselectedindex ( ) ) ; } } ) ; rows [ 0 ] . add ( new jlabel ( "game type: " ) ) ; rows [ 0 ] . add ( gametype ) ; time = new spinnernumbermodel ( 4 , 0 , 99 , 1 ) ; time . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = time . getnumber ( ) . bytevalue ( ) ; dsm . settimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "time (min): " ) ) ; rows [ 0 ] . add ( new jspinner ( time ) ) ; stock = new spinnernumbermodel ( 4 , 1 , 99 , 1 ) ; stock . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stock . getnumber ( ) . bytevalue ( ) ; dsm . setstock ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock: " ) ) ; rows [ 0 ] . add ( new jspinner ( stock ) ) ; stocktime = new spinnernumbermodel ( 8 , 0 , 99 , 1 ) ; stocktime . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stocktime . getnumber ( ) . bytevalue ( ) ; dsm . setstocktimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock-mode time: " ) ) ; rows [ 0 ] . add ( new jspinner ( stocktime ) ) ; handicap = new jcombobox ( ) ; handicap . additem ( "off" ) ; handicap . additem ( "auto" ) ; handicap . additem ( "on" ) ; handicap . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . sethandicap ( ( byte ) handicap . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "handicap: " ) ) ; rows [ 1 ] . add ( handicap ) ; damageratio = new spinnernumbermodel ( 1.0 , 0.5 , 2.0 , .1 ) ; damageratio . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { double d = 10 * damageratio . getnumber ( ) . doublevalue ( ) ; dsm . setdamageratio ( d ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "damage ratio: " ) ) ; rows [ 1 ] . add ( new jspinner ( damageratio ) ) ; stagemethod = new jcombobox ( ) ; stagemethod . additem ( "choose" ) ; stagemethod . additem ( "random" ) ; stagemethod . additem ( "take turns" ) ; stagemethod . additem ( "ordered" ) ; stagemethod . additem ( "loser's pick" ) ; stagemethod . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setstagemethod ( ( byte ) stagemethod . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "stage method: " ) ) ; rows [ 1 ] . add ( stagemethod ) ; teamattack = new jcheckbox ( "team attack" ) ; teamattack . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setteamattack ( teamattack . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( teamattack ) ; pause = new jcheckbox ( "pause" ) ; pause . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setpause ( pause . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( pause ) ; scoredisplay = new jcheckbox ( "scoredisplay" ) ; scoredisplay . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setscoredisplay ( scoredisplay . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( scoredisplay ) ; damagegauge = new jcheckbox ( "damagegauge" ) ; damagegauge . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setdamagegauge ( damagegauge . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( damagegauge ) ; initialize ( ) ; }
tr	3	public dependanceclosure ( list < rule > rulelist , string start ) throws exception { map < string , rule > rulemap = new hashmap < string , rule > ( ) ; for ( int index = 0 ; index < rulelist . size ( ) ; index ++ ) { string name = rulelist . get ( index ) . getrulename ( ) . tostring ( ) ; rule rule = rulelist . get ( index ) ; if ( rulemap . get ( name ) != null ) { throw new exception ( "the definition of rule " + rulelist . get ( index ) . getrulename ( ) . tostring ( ) + " duplicates." ) ; } rulemap . put ( name , rule ) ; } set < string > rulenameset = new hashset < string > ( ) ; rulenameset . add ( start ) ; set < string > marked = new hashset < string > ( ) ; set < string > unmarked = new hashset < string > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isempty ( ) ) { string name = unmarked . iterator ( ) . next ( ) ; set < string > dependant = rulemap . get ( name ) . getelements ( ) . getdependentrulenames ( ) ; iterator < string > it = dependant . iterator ( ) ; while ( it . hasnext ( ) ) { string dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . rulelist . add ( rulemap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	2	private void removeneuron ( int num ) { neuron neuron = ( neuron ) ( currentnetwork . getnode ( num ) ) ; currentnetwork . getneurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getinputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getinputs ( ) . get ( i ) ; connection . getgiveneuron ( ) . getoutputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getoutputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getoutputs ( ) . get ( i ) ; connection . getrecieveneuron ( ) . getinputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } system . out . println ( "neuron :: " + num + " :: was removed" ) ; }
tr	5	private boolean testgateways ( graph < vertex , edge > g ) { int openand = 0 ; int closeand = 0 ; for ( vertex v : g . vertexset ( ) ) { if ( v . isgateway ) { if ( v . getcorresponding ( ) == null && ! v . isxor ) { if ( __debug ) a . e . println ( "didn't find a corresponding gate for " + v . tostring ( ) ) ; return false ; } else { if ( ! v . isxor ) if ( v . getcorresponding ( ) . getcorresponding ( ) . id . tostring ( ) . compareto ( v . id . tostring ( ) ) != 0 ) { if ( __debug ) a . e . println ( "corresponding gate has been associated to something else " + v . tostring ( ) + "; " + v . getcorresponding ( ) . tostring ( ) ) ; if ( __debug ) a . e . println ( "corresponding gate has been associated to something else " + v . getcorresponding ( ) . tostring ( ) + "; " + v . getcorresponding ( ) . getcorresponding ( ) . tostring ( ) ) ; return false ; } } if ( g . indegreeof ( v ) > 1 ) closeand ++ ; if ( g . outdegreeof ( v ) > 1 ) openand ++ ; } } if ( openand == closeand ) { return true ; } return false ; }
tr	1	public grille ( int taille , joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setbackground ( new color ( 0 , 0 , 0 ) ) ; this . setlayout ( new gridlayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialisercases ( ) ; }
tr	5	private void openaddmeterpanel ( ) { boolean failure = false ; string options [ ] = { "create" , "cancel" } ; int result = joptionpane . showoptiondialog ( null , addmeterpanel , "add meter to account " + getselectedaccountid ( ) , joptionpane . default_option , joptionpane . plain_message , null , options , options [ 0 ] ) ; if ( result == 0 ) { meter m = getmeterfromaddmeterpanel ( ) ; account temp = getselectedaccount ( ) ; if ( m != null ) { if ( temp instanceof residentialaccount ) { residentialaccount resacc = ( residentialaccount ) temp ; if ( resacc . getmeter ( ) != null ) { boolean overwrite = confirmresidentialaccountconflict ( ) ; if ( ! overwrite ) return ; } } else if ( temp . hasmeter ( m . getmeterid ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addmeter ( m ) ; system . out . println ( m . getmeterid ( ) ) ; showmetersinmetertable ( temp ) ; } else { failtocreatemeterdialog ( ) ; } } }
tr	2	@ test public void shouldrighttrimunicodestringscorrectly ( ) throws unsupportedencodingexception { assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac\t\r\n" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" + buffertools . bytebuffertostring ( new byte [ ] { 0 , 0 } , 0 , 2 ) ) ) ; }
tr	2	public object [ ] [ ] getestacionescercanas ( int ci ) throws elementonoencontradoexception { object [ ] [ ] datos = new object [ objea . getestacionescercanas ( objua . getusuario ( ci ) ) . size ( ) ] [ 2 ] ; int cont = 0 ; for ( estacion obje : objea . getestacionescercanas ( objua . getusuario ( ci ) ) . values ( ) ) { datos [ cont ] [ 0 ] = obje . getnom ( ) ; datos [ cont ] [ 1 ] = obje . getcp ( ) ; cont ++ ; } return datos ; }
tr	5	public boolean isvalidsudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = character . getnumericvalue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = character . getnumericvalue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = character . getnumericvalue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
tr	2	@ test @ ignore public void havedinner ( ) throws exception { int eattimes = 3 ; int numphilosophers = 5 ; countdownlatch waittillallinitialized = new countdownlatch ( numphilosophers ) ; countdownlatch waittillalldonedining = new countdownlatch ( numphilosophers ) ; atomicinteger availableforks = new atomicinteger ( numphilosophers ) ; list < diningphilosopher > philosophers = new arraylist < > ( ) ; for ( int i = 1 ; i <= numphilosophers ; i ++ ) { diningphilosopher philosopher = new diningphilosopher ( i , availableforks , eattimes , waittillalldonedining ) ; philosophers . add ( philosopher ) ; } immutablelist < diningphilosopher > allphilosophers = new immutablelist < > ( philosophers ) ; philosophers . foreach ( ( diningphilosopher philosopher ) -> { philosopher . start ( allphilosophers , registry . getdefault ( ) ) ; } ) ; waittillalldonedining . await ( ) ; system . out . println ( "all philosophers done each dining " + eattimes + " times" ) ; }
tr	2	@ test public void testnaissancesoldats ( ) { sallesoldat testsoldat = new sallesoldat ( ) ; sallenourrice sn = new sallenourrice ( ) ; evenements . getinstance ( ) . setevenementactif ( constantes . even_deplacement ) ; sn . ajouterfourmi ( 3 ) ; testsoldat . naissancesoldats ( 2 , sn ) ; assertequals ( 1 , testsoldat . getnbcourantfourmi ( ) ) ; assertequals ( 1 , sn . getnbcourantfourmi ( ) ) ; try { testsoldat . naissancesoldats ( 2 , sn ) ; fail ( "exceptionnourrices non levee." ) ; } catch ( exceptionnourrices en ) { } try { testsoldat . naissancesoldats ( 0 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 1 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 5 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } }
tr	5	public static list < lineitem > transformlineitems ( detail d ) { list < lineitem > items = d . getlineitem ( ) ; list < lineitem > aggritems = new arraylist < lineitem > ( ) ; for ( lineitem l : items ) { boolean duplicate = false ; if ( ! aggritems . isempty ( ) ) { for ( int i = 0 ; i < aggritems . size ( ) ; i ++ ) { lineitem curr = aggritems . get ( i ) ; if ( curr . getitemcode ( ) . equals ( l . getitemcode ( ) ) ) { long quantity = curr . getquantity ( ) . intvalue ( ) ; quantity ++ ; curr . setquantity ( bigdecimal . valueof ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggritems . add ( l ) ; } } return aggritems ; }
tr	4	public void equipweapon ( survivor survivor , weapon weapon ) throws cantequipweaponexception { if ( ! this . survivors . contains ( survivor ) ) { throw new cantequipweaponexception ( cantequipweaponexception . notintheteam ( survivor ) ) ; } else if ( ! this . mainbase . getavailableweapons ( ) . contains ( weapon ) ) { throw new cantequipweaponexception ( "weapon must be one of those stored in base to equip" ) ; } else { survivor owner = this . alreadyequipped ( weapon ) ; if ( owner != null ) { throw new cantequipweaponexception ( "weapon is already equipped by " + owner . getname ( ) ) ; } else { weapon oldweapon = survivor . getweapon ( ) ; this . mainbase . getavailableweapons ( ) . remove ( weapon ) ; survivor . setweapon ( weapon ) ; if ( oldweapon != null ) { this . mainbase . getavailableweapons ( ) . add ( oldweapon ) ; } } } }
tr	5	public void editfile ( int fileinodenum ) throws permissiondeniedexception , filenotfoundexception { inode fileinode = new inode ( fileinodenum ) ; if ( directory . isreadable ( fileinode ) ) { if ( fileinode . getfiletype ( ) == r ) { file tempfile = null ; string content = fileinode . getfilecontent ( ) ; try { tempfile = new file ( disk . tmpfolder . tostring ( ) + "/" + fileinodenum + ".txt" ) ; if ( tempfile . exists ( ) ) { tempfile . delete ( ) ; tempfile . createnewfile ( ) ; } tempfile . deleteonexit ( ) ; randomaccessfile temprf = new randomaccessfile ( tempfile , "rw" ) ; temprf . writebytes ( content ) ; desktop . getdesktop ( ) . open ( tempfile ) ; temprf . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } else throw new permissiondeniedexception ( ) ; }
tr	3	public static void main ( string [ ] args ) { rectangle rec = new rectangle ( new mypoint ( 2 , 4 ) , new mypoint ( 4 , 6 ) , new mypoint ( 2 , 4 ) , new mypoint ( 4 , 8 ) ) ; class recclass = rec . getclass ( ) ; field [ ] recfields = recclass . getdeclaredfields ( ) ; method [ ] recmethods = recclass . getdeclaredmethods ( ) ; system . out . println ( "class fields" ) ; for ( field currfield : recfields ) { system . out . println ( currfield . getname ( ) ) ; } system . out . println ( "class methods" ) ; for ( method method : recmethods ) { system . out . println ( method . getname ( ) ) ; } class recsuperclass = recclass . getsuperclass ( ) ; if ( recsuperclass == null ) { system . out . println ( string . format ( "the class %s dose not have a super class" , recclass . getsimplename ( ) ) ) ; } else { system . out . println ( "the super class name is: " + recsuperclass . getsimplename ( ) ) ; system . out . println ( "look for constructors" ) ; constructor [ ] constructors = recsuperclass . getconstructors ( ) ; for ( constructor constructor : constructors ) { system . out . println ( "ctor name: " + constructor . getname ( ) ) ; } system . out . println ( "the class " + recsuperclass . getsimplename ( ) + "" + "is from package " + recsuperclass . getpackage ( ) ) ; } try { class anotherclass = class . forname ( "il.ac.shenkar.point.mypoint" ) ; constructor [ ] constructors = anotherclass . getconstructors ( ) ; system . out . println ( "constructors for: " + anotherclass . getsimplename ( ) ) ; for ( constructor constructor : constructors ) { system . out . println ( constructor ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }
tr	3	private void botoneliminarusuarioactionperformed ( java . awt . event . actionevent evt ) { if ( this . tablaadministracionusuarios . getselectedrow ( ) > - 1 ) { string codigo = ( string ) this . conectortablausuarios . getvalueat ( this . tablaadministracionusuarios . getselectedrow ( ) , 0 ) ; int respuesta = joptionpane . showconfirmdialog ( this . botoneliminarusuario , "\u00bfrealmente desea eliminar \n al usuario " + codigo + "?" , "confirme eliminaci\u00f3n" , joptionpane . yes_no_option , joptionpane . question_message ) ; if ( respuesta == joptionpane . yes_option ) { usuario u = this . modeloapp . obtenerusuarioconcodigo ( codigo ) ; this . modeloapp . eliminarusuario ( u ) ; this . conectortablausuarios . cargarusuarios ( ) ; } } else { joptionpane . showmessagedialog ( this , "debe seleccionar un\nusuario de la tabla" , "usuario no seleccionado" , joptionpane . information_message ) ; } }
tr	2	@ override public boolean onrequest ( httprequest request , httpresponse response ) throws exception { string filepath = request . getrequestedfilepath ( ) ; if ( urltomapto != null ) { if ( ! filepath . startswith ( urltomapto ) ) return false ; filepath = filepath . substring ( urltomapto . length ( ) ) ; } file file = new file ( directory , filepath ) ; if ( ! file . isfile ( ) || ! file . canread ( ) || ! file . getabsolutepath ( ) . startswith ( directory . getabsolutepath ( ) ) ) return false ; iofilechannelinputbuffer buffer = new iofilechannelinputbuffer ( new fileinputstream ( file ) . getchannel ( ) ) ; response . setheader ( "content-type" , mimenamemap . getcontenttypefor ( file . getabsolutepath ( ) ) ) ; response . setbodybuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	3	public static boolean readusers ( decisionlineevent readevent , int playableedges ) { if ( ! isconnected ( ) ) if ( ! connect ( ) ) { system . out . println ( "error  database connection could not be created" ) ; system . exit ( 0 ) ; } try { preparedstatement pstmt = getconnection ( ) . preparestatement ( "select username  userpassword  position from user where eventid=(?) order by position asc" ) ; pstmt . setstring ( 1 , readevent . getuniqueid ( ) ) ; resultset myrs = pstmt . executequery ( ) ; user newuser ; string name , password ; int position ; while ( myrs . next ( ) ) { name = new string ( myrs . getstring ( "username" ) ) ; password = new string ( myrs . getstring ( "userpassword" ) ) ; position = myrs . getint ( "position" ) ; newuser = new user ( name , password , position , playableedges ) ; readevent . getusers ( ) . add ( newuser ) ; } return true ; } catch ( sqlexception e ) { system . out . println ( "error executing sql statement!" ) ; } return false ; }
tr	5	public void runscript ( inputstream stream ) throws jstrykerexception , illegalargumentexception { if ( stream == null ) { throw new illegalargumentexception ( "stream cannot be null." ) ; } try { list < string > commands = parse ( stream ) ; for ( string command : commands ) { statement statement = null ; try { statement = connection . createstatement ( ) ; statement . execute ( command . tostring ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( sqlexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } catch ( ioexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
tr	3	public void advance ( ) { timeuntilnext -- ; if ( timeuntilnext <= 0 ) { stoppingat ( ) ; if ( ! reverse && nextstation . getnext ( ) == null ) { reverse = true ; timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; return ; } if ( reverse && nextstation . getprev ( ) == null ) { reverse = false ; timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; return ; } if ( reverse ) { timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; } else { timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; } } }
tr	4	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	5	public questionpanel getquestionpanel ( ) { if ( mediapanel . hasfinished ( ) ) createmedia ( ) ; if ( type . equals ( "plain" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , fontsize ) ; } else if ( type . equals ( "mchoice" ) ) { string [ ] split = answers . split ( ";" ) ; multiplechoicepanel panel = new multiplechoicepanel ( split , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { string [ ] split = answers . split ( ";" ) ; jlabel [ ] labels = new jlabel [ 4 ] ; bufferedimage bufferedimage ; image image ; for ( int i = 0 ; i < labels . length ; i ++ ) { prefheight = math . max ( pref_height , mcfont ) ; try { bufferedimage = imageio . read ( new file ( split [ i ] ) ) ; if ( bufferedimage . getheight ( ) > prefheight ) { image = bufferedimage . getscaledinstance ( bufferedimage . getwidth ( ) * prefheight / bufferedimage . getheight ( ) , prefheight , bufferedimage . scale_smooth ) ; } else { image = bufferedimage ; } } catch ( ioexception e ) { bufferedimage = null ; image = null ; e . printstacktrace ( ) ; system . out . println ( "image path: " + split [ i ] ) ; } labels [ i ] = new jlabel ( new imageicon ( image ) ) ; } multiplechoicepanel panel = new multiplechoicepanel ( labels , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "list" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; string [ ] answerarray = answers . split ( ";" ) ; system . out . println ( "create question list" ) ; questionpanel = new questionpanel ( text , answerarray , fontsize ) ; } else { system . out . println ( "failed to read file" ) ; system . exit ( 0 ) ; } return questionpanel ; }
tr	2	public static boolean ononeline ( xy xy , xy xy2 ) { if ( xy2 . getx ( ) == xy . getx ( ) ) { return true ; } if ( xy2 . gety ( ) == xy . gety ( ) ) { return true ; } int dx = math . abs ( xy2 . getx ( ) - xy . getx ( ) ) ; int dy = math . abs ( xy2 . gety ( ) - xy . gety ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
tr	5	private id3v2commentframedata extractcommentframedata ( string id , boolean itunes ) { id3v2frameset frameset = framesets . get ( id ) ; if ( frameset != null ) { iterator < id3v2frame > iterator = frameset . getframes ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) iterator . next ( ) ; id3v2commentframedata framedata ; try { framedata = new id3v2commentframedata ( useframeunsynchronisation ( ) , frame . getdata ( ) ) ; if ( itunes && itunes_comment_description . equals ( framedata . getdescription ( ) . tostring ( ) ) ) { return framedata ; } else if ( ! itunes ) { return framedata ; } } catch ( invaliddataexception e ) { } } } return null ; }
tr	3	public void plotelements ( view3d view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { darray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { renderable e = ( renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewvert , panelvert ) ; } } }
tr	3	private bufferedimage getview ( ) { if ( this . getwidth ( ) > 0 && this . getheight ( ) > 0 ) { int mapsize = ( mapimage_scaled . getheight ( ) ) ; if ( viewport . x + this . getwidth ( ) > mapsize ) { int movexby = viewport . x + this . getwidth ( ) - mapsize ; moveview ( - movexby , 0 ) ; } if ( viewport . y + this . getheight ( ) > mapsize ) { int moveyby = viewport . y + this . getheight ( ) - mapsize ; moveview ( 0 , - moveyby ) ; } int windowheight = this . getheight ( ) ; int windowwidth = this . getwidth ( ) ; if ( this . getheight ( ) > mapimage_scaled . getheight ( ) ) { windowheight = mapimage_scaled . getheight ( ) ; viewport . y = 0 ; } if ( this . getwidth ( ) > mapimage_scaled . getwidth ( ) ) { windowwidth = mapimage_scaled . getwidth ( ) ; viewport . x = 0 ; } mapimage_view = null ; try { mapimage_view = mapimage_unitandbuildingsscaled . getsubimage ( viewport . x , viewport . y , windowwidth , windowheight ) ; } catch ( exception e ) { system . err . println ( "error creating subview!" ) ; } } return mapimage_view ; }
tr	1	public void drawpoint ( vertex vertex ) { init ( ) ; double x = vertex . getpoint ( ) . getx ( ) * scale_x ; double y = vertex . getpoint ( ) . gety ( ) * scale_y ; ellipse2d el = new ellipse2d . double ( x - pointsize / 2. , y - pointsize / 2. , pointsize , pointsize ) ; ensurehassize ( el . getbounds2d ( ) ) ; graphics2d g = getgraphicsobject ( ) ; g . setstroke ( new basicstroke ( ( float ) pensize ) ) ; g . setcolor ( pencolor ) ; g . setcolor ( pointfill ) ; g . fill ( el ) ; g . setcolor ( pointborder ) ; g . draw ( el ) ; if ( showvertexnumbers ) g . drawstring ( "" + vertex . getvertexindex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	3	public static byte [ ] decodeencfs ( byte [ ] source ) { byte [ ] decodedinput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayindex = source [ i ] ; if ( arrayindex >= 0 ) { decodedinput [ i ] = _encfs_decodabet [ source [ i ] ] ; } else { decodedinput [ i ] = - 9 ; } } int outputlen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputlen ] ; int srcidx = 0 ; int dstidx = 0 ; int workbits = 0 ; long work = 0 ; while ( srcidx < source . length ) { work |= decodedinput [ srcidx ++ ] << workbits ; workbits += 6 ; while ( workbits >= 8 ) { output [ dstidx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workbits -= 8 ; } } return output ; }
tr	1	@ suppresswarnings ( "deprecation" ) public void initglobaladmin ( ) { person person = new person ( ) ; person . setfirstname ( "thomas" ) ; person . setlastname ( "hardy" ) ; person . setgender ( true ) ; person . setphone ( "857-245-1872" ) ; person . setssn ( "781-27-2837" ) ; person . setemailid ( "global@cms.org" ) ; person . setaddress ( "500 bolyston st  boston" ) ; person . setdob ( new date ( 1980 , 11 , 10 ) ) ; persondao . saveorupdate ( person ) ; useraccount ua = new useraccount ( ) ; ua . setusername ( "admin" ) ; ua . setpassword ( hashgenerator . gethashvalue ( "admin" ) ) ; ua . setrole ( role . globaladmin . tostring ( ) ) ; ua . setperson ( person ) ; useraccountdao . saveorupdate ( ua ) ; }
tr	4	private defaulttreemodel getgroups ( ) { defaultmutabletreenode root = new defaultmutabletreenode ( constants . str_group ) ; string userno = string . valueof ( user . get ( constants . user_no ) ) ; list < map < string , object >> grouplist = userdao . getgroup ( userno ) ; for ( int i = 0 , len = grouplist . size ( ) ; i < len ; ++ i ) { map < string , object > group = grouplist . get ( i ) ; defaultmutabletreenode child = new defaultmutabletreenode ( string . valueof ( group . get ( constants . group_name ) ) ) ; map < string , object > param = new hashmap < string , object > ( ) ; param . put ( constants . user_no , string . valueof ( group . get ( constants . user_no ) ) ) ; param . put ( constants . group_no , string . valueof ( group . get ( constants . group_no ) ) ) ; list < map < string , object >> friendlist = userdao . getfriend ( param ) ; if ( constants . num_zero != friendlist . size ( ) ) { for ( int j = 0 , size = friendlist . size ( ) ; j < size ; ++ j ) { map < string , object > friend = friendlist . get ( j ) ; string friendno = string . valueof ( friend . get ( constants . friend_no ) ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( userdao . getuserinfo ( friendno ) ) ; sb . append ( "(" ) ; sb . append ( friendno ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userdao . getstatus ( friendno ) ; sb . append ( userstatus . getitemat ( status ) . tostring ( ) ) ; sb . append ( ">" ) ; defaultmutabletreenode childschild = new defaultmutabletreenode ( sb . tostring ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new defaulttreemodel ( root ) ; }
tr	3	public void modifycourse ( classinfo classinfo ) { classinfo cinfodata = getcourse ( classinfo . getclassnumber ( ) ) ; if ( cinfodata != null ) { if ( ! classinfo . getcoursename ( ) . equalsignorecase ( cinfodata . getcoursename ( ) ) ) { course crs = new course ( ) ; crs . setcourseid ( classinfo . getcoursenumber ( ) ) ; crs . setcoursename ( classinfo . getcoursename ( ) ) ; savedatamodify ( crs ) ; } if ( ! classinfo . getcoursesection ( ) . equalsignorecase ( cinfodata . getcoursesection ( ) ) ) { schoolclass cls = new schoolclass ( ) ; cls . setclassnumber ( classinfo . getclassnumber ( ) ) ; cls . setclasssection ( classinfo . getcoursesection ( ) ) ; savedatamodify ( cls ) ; } } }
tr	1	@ test public void getvirusscore_virusfinderandscorercalledcorrectlyandscorereturned ( ) { string sequence = "abbaacdeeefa" ; map < string , integer > result = new hashmap < string , integer > ( ) ; result . put ( "abc" , 10 ) ; argumentcaptor < string > sequencecapture = argumentcaptor . forclass ( string . class ) ; mockito . when ( genomevirusfinder . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ) . thenreturn ( result ) ; mockito . when ( genomevirusscorer . gettotalscore ( result ) ) . thenreturn ( 10 ) ; inorder inorder = mockito . inorder ( genomevirusfinder , genomevirusscorer ) ; int score = sequencer . getvirusscore ( sequence ) ; assert . assertequals ( 10 , score ) ; assert . assertequals ( sequence , sequencecapture . getallvalues ( ) . get ( 0 ) ) ; inorder . verify ( genomevirusfinder , mockito . times ( 1 ) ) . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ; inorder . verify ( genomevirusscorer , mockito . times ( 1 ) ) . gettotalscore ( result ) ; }
tr	5	private void execute ( ) { boolean running = true ; watchkey key ; string dir = readproperties ( ) ; inboundwatcher watch = new inboundwatcher ( dir ) ; system . out . println ( "starting the directory monitoring" ) ; system . out . println ( "directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( interruptedexception ie ) { return ; } for ( watchevent < ? > event : key . pollevents ( ) ) { watchevent . kind < ? > kind = event . kind ( ) ; if ( kind == standardwatcheventkinds . entry_create ) { watchevent < path > watcheventpath = ( watchevent < path > ) event ; path entry = watcheventpath . context ( ) ; if ( pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . tostring ( ) ) ) { salesorder . unmarshal ( dir , entry . tostring ( ) ) ; } else if ( pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . tostring ( ) ) ) { standardresponse . unmarshal ( dir , entry . tostring ( ) ) ; } else if ( pattern . matches ( ".+[\\.trg]" , entry . tostring ( ) ) ) { file f = entry . tofile ( ) ; shipadvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isvalid ( ) ) { running = false ; } } }
tr	5	static private vector < double [ ] > sampleresults ( vector < future < vector < double [ ] >>> results , int bins ) throws exception { int ndescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; system . out . println ( "printing for " + ndescriptors + " descriptors" ) ; vector < double [ ] > descriptors = new vector < double [ ] > ( ndescriptors ) ; for ( int d = 0 ; d < ndescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( future < vector < double [ ] >> result : results ) { vector < double [ ] > samples = result . get ( ) ; int samplesperbin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesperbin && b * samplesperbin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesperbin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
tr	5	public arraylist < integer > obtenerjugadasganadorasdehoy ( arraylist < integer > boletosdehoy , arraylist < integer > numerosganadores , int loteria_id ) { verificadora verificadora = new verificadora ( ) ; connection cn = conexion . conectar ( ) ; preparedstatement pst ; resultset rs ; string query ; arraylist < integer > jugadasdehoy = new arraylist < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosganadores . get ( 0 ) ; numerog2 = numerosganadores . get ( 1 ) ; numerog3 = numerosganadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosdehoy . size ( ) ; i ++ ) { query = "select jugada_id  combinacion  monto  formato_id from jugadas where boleto_id = " + boletosdehoy . get ( i ) + " and loteria_id =" + loteria_id ; try { pst = cn . preparestatement ( query ) ; rs = pst . executequery ( ) ; while ( rs . next ( ) ) { string comb = separarcombinacion ( rs . getstring ( "combinacion" ) ) . get ( 0 ) ; string [ ] combinacion = rs . getstring ( "combinacion" ) . split ( "-" ) ; int formato = rs . getint ( "formato_id" ) ; int jugada_id = rs . getint ( "jugada_id" ) ; numerosganadores . clear ( ) ; numerosganadores . add ( numerog1 ) ; numerosganadores . add ( numerog2 ) ; numerosganadores . add ( numerog3 ) ; coincidencias = verificadora . verificarcoincidencias ( separarcombinacion ( rs . getstring ( "combinacion" ) ) , numerosganadores ) ; system . out . println ( "jugada: " + jugada_id ) ; system . out . println ( "coinc: " + coincidencias ) ; system . out . println ( "formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasdehoy . add ( jugada_id ) ; calcularquiniela ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; system . out . println ( "quiniela gan\u00f3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasdehoy . add ( jugada_id ) ; calcularpale ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , integer . parseint ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasdehoy . add ( jugada_id ) ; calculartripleta ( jugada_id , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } } } catch ( sqlexception ex ) { system . out . println ( ex ) ; } } return jugadasdehoy ; }
tr	1	private jlabel newjlabel ( string value , string src ) { jlabel label = new jlabel ( value ) ; label . seticon ( new imageicon ( src ) ) ; label . setfont ( new font ( "lucida grande" , 0 , 14 ) ) ; label . setpreferredsize ( new dimension ( 40 , 90 ) ) ; label . sethorizontaltextposition ( swingconstants . center ) ; label . setverticaltextposition ( swingconstants . bottom ) ; label . setverticalalignment ( swingconstants . bottom ) ; label . setborder ( borderfactory . createemptyborder ( 0 , 0 , 0 , 5 ) ) ; return label ; }
tr	2	public void loaddata ( dadeshotel hotel ) { titledborder leftborder = borderfactory . createtitledborder ( hotel . nom ) ; leftborder . settitlejustification ( titledborder . left ) ; this . setborder ( leftborder ) ; nomhotel = hotel . nom ; hoteldescriptionlabel . settext ( hotel . desc ) ; defaultlistmodel model = new defaultlistmodel ( ) ; for ( dadeshabitacio hab : hotel . habs ) { string dada = hab . tipushab + " (" + hab . preu + "\u20ac) - " + hab . numerodisp + " disponibles" ; model . addelement ( dada ) ; nomstipus . add ( hab . tipushab ) ; } tipushabitacionslist . setmodel ( model ) ; }
tr	2	private void handlenames ( message m ) { if ( m . numargs ( ) < 3 ) return ; if ( m . getcode ( ) == messagecode . rpl_endofnames ) { getchannel ( m . getarg ( 2 ) ) . userschanged ( ) ; return ; } if ( m . numargs ( ) < 5 || m . get ( 3 ) . charat ( 0 ) == * ) return ; channel c = getchannel ( m . getarg ( 3 ) ) ; stringtokenizer st = new stringtokenizer ( m . getmessage ( ) , " " ) ; user u ; string nick ; while ( st . hasmoretokens ( ) ) { nick = st . nexttoken ( ) ; channeluser . mode mode = channeluser . mode . getmode ( nick . charat ( 0 ) ) ; if ( mode != channeluser . mode . none ) nick = nick . substring ( 1 ) ; u = getuser ( nick ) ; u . addchannel ( c ) ; c . addusertolist ( u ) ; c . setusermode ( u , mode ) ; } }
tr	1	protected void mapkeyboard ( ) { mapkeystroke ( keyevent . vk_up ) ; mapkeystroke ( keyevent . vk_down ) ; mapkeystroke ( keyevent . vk_right ) ; mapkeystroke ( keyevent . vk_left ) ; mapkeystroke ( keyevent . vk_page_down ) ; mapkeystroke ( keyevent . vk_page_up ) ; mapkeystroke ( keyevent . vk_home ) ; mapkeystroke ( keyevent . vk_end ) ; mapkeystroke ( keyevent . vk_numpad0 ) ; mapkeystroke ( keyevent . vk_numpad1 ) ; mapkeystroke ( keyevent . vk_numpad2 ) ; mapkeystroke ( keyevent . vk_numpad3 ) ; mapkeystroke ( keyevent . vk_numpad4 ) ; mapkeystroke ( keyevent . vk_numpad5 ) ; mapkeystroke ( keyevent . vk_numpad6 ) ; mapkeystroke ( keyevent . vk_numpad7 ) ; mapkeystroke ( keyevent . vk_numpad8 ) ; mapkeystroke ( keyevent . vk_numpad9 ) ; mapkeystroke ( keyevent . vk_minus ) ; mapkeystroke ( keyevent . vk_plus ) ; mapkeystroke ( keyevent . vk_comma ) ; mapkeystroke ( keyevent . vk_period ) ; mapkeystroke ( keyevent . vk_enter ) ; mapkeystroke ( keyevent . vk_kp_down ) ; mapkeystroke ( keyevent . vk_kp_left ) ; mapkeystroke ( keyevent . vk_kp_right ) ; mapkeystroke ( keyevent . vk_kp_up ) ; mapkeystroke ( keyevent . vk_f1 ) ; mapkeystroke ( keyevent . vk_f1 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f2 ) ; mapkeystroke ( keyevent . vk_f2 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f3 ) ; mapkeystroke ( keyevent . vk_f3 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f4 ) ; mapkeystroke ( keyevent . vk_f4 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f5 ) ; mapkeystroke ( keyevent . vk_f6 ) ; mapkeystroke ( keyevent . vk_f7 ) ; mapkeystroke ( keyevent . vk_f8 ) ; mapkeystroke ( keyevent . vk_f9 ) ; mapkeystroke ( keyevent . vk_f10 ) ; mapkeystroke ( keyevent . vk_f11 ) ; mapkeystroke ( keyevent . vk_f12 ) ; }
tr	2	public string format ( string unformattedxml ) { transformerfactory tfactory = transformerfactory . newinstance ( ) ; transformer serializer ; try { serializer = tfactory . newtransformer ( ) ; serializer . setoutputproperty ( outputkeys . encoding , "utf-8" ) ; serializer . setoutputproperty ( outputkeys . indent , "yes" ) ; serializer . setoutputproperty ( "{http://xml.apache.org/xslt}indent-amount" , "4" ) ; element node = parsexmlfile ( unformattedxml ) ; stringwriter out = new stringwriter ( ) ; serializer . transform ( new domsource ( node ) , new streamresult ( out ) ) ; return out . tostring ( ) ; } catch ( transformerexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( e ) ; } }
tr	4	public list < payloadsubjectexceptiondata > getexceptions ( ) throws exception { if ( this . exceptions == null ) { this . exceptions = new arraylist < payloadsubjectexceptiondata > ( ) ; nodelist exceptions = utilities . selectnodes ( this . getdocument ( ) , "/dc:dctransaction/dc:getdatabysubjectrs/dc:payloadsubjectexceptions/dc:payloadsubjectexception" , xmllabels . standard_namespaces ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getlength ( ) ; ++ i ) { node exception = exceptions . item ( i ) ; this . exceptions . add ( new payloadsubjectexceptiondata ( exception ) ) ; } } } return this . exceptions ; }
tr	5	public level ( ) { bitmap bmp = art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redplayer = new player ( this , team . allied ) ; bluplayer = new player ( this , team . soviet ) ; }
tr	5	public contextmenu getcontextmenu ( final modelverzameling mv ) { if ( contextmenu == null ) { contextmenu = new contextmenu ( ) ; menuitem menuitem1 = new menuitem ( "wat is het" ) ; menuitem1 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { mv . gettekstvakmodel ( ) . settext ( "dit is een " + getname ( ) ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem1 ) ; if ( iseetbaar ( ) ) { menuitem menuitem2 = new menuitem ( "eet" ) ; menuitem2 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { eet ( mv ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem2 ) ; } } return contextmenu ; }
tr	4	private void parsepacket ( ) throws mpegdecodeexception , ioexception { statistics . startlog ( parse_packet_string ) ; system . out . println ( "parsing packet" ) ; if ( m_iotool . getbits ( 24 ) != 1 ) { debug . println ( debug . error , "synchronization error in packet" ) ; throw new mpegdecodeexception ( "synchronization error in packet" ) ; } int streamid = m_iotool . getbits ( 8 ) ; int pktlength = m_iotool . getbits ( 16 ) ; if ( streamid != private_stream2 ) { pktlength -= parsetimestamps ( ) ; } if ( ( streamid & e0 ) == c0 ) { decodeaudio ( pktlength ) ; } else { if ( ( f0 & streamid ) == e0 ) { decodevideo ( pktlength ) ; } else if ( ( f0 & streamid ) == f0 ) { ; } else { switch ( streamid ) { case reserved_stream : case private_stream1 : case padding_stream : case private_stream2 : break ; default : debug . println ( debug . error , "unknown stream: " + streamid ) ; throw new mpegdecodeexception ( "unknown stream: " + streamid ) ; } } } statistics . endlog ( parse_packet_string ) ; }
tr	4	public static strooptest createrandomcolourtest ( int wordsize , testtype type ) { list < word > words = new arraylist < word > ( wordsize ) ; random randomizer = new random ( system . currenttimemillis ( ) ) ; for ( int i = 0 ; i < wordsize ; i ++ ) { int next = randomizer . nextint ( 2 ) ; switch ( next ) { case 0 : { words . add ( wordfactory . createrandomplaincolourword ( ) ) ; break ; } case 1 : { words . add ( wordfactory . createrandomcolourword ( ) ) ; break ; } case 2 : { words . add ( wordfactory . createrandommixedcolourword ( ) ) ; break ; } } } return new strooptest ( words , type , "random" , "" ) ; }
tr	5	private boolean applydistributivelaw ( iexpressioncontext context , astnode result ) { final treematcher matcher = new treematcher ( ) . ignorechildorder ( true ) . requirenodetohaveparent ( true ) . unwrapall ( ) . matchparent ( ) . matchand ( ) . matchor ( ) . buildor ( ) . matchrightchild ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { final astnode unwrapped = unwrap ( matcher . parentmatch ( ) ) ; if ( unwrapped . isor ( ) ) { return n . isand ( ) ; } if ( unwrapped . isand ( ) ) { return n . isor ( ) ; } throw new runtimeexception ( "unreachable code reached" ) ; } } ) . buildor ( ) . matchextra ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { return matcher . leftmatch ( ) . getnodecount ( ) != matcher . rightmatch ( ) . getnodecount ( ) ; } } ) . buildor ( ) ; final mutatingnodevisitor visitor = new mutatingnodevisitor ( context ) { @ override public void visit ( astnode node , iexpressioncontext context , iiterationcontext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final astnode matchedparent = matcher . parentmatch ( ) ; final astnode leftchild = matcher . leftmatch ( ) ; final astnode rightchild = matcher . rightmatch ( ) ; final astnode leftterm ; final astnode rightterm ; final astnode replacementterm ; astnode unwrappedright = unwrap ( rightchild ) ; if ( unwrap ( matchedparent ) . isand ( ) && unwrappedright . isor ( ) ) { leftterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . or ( leftterm , rightterm ) ; } else if ( unwrap ( matchedparent ) . isor ( ) && unwrappedright . isand ( ) ) { leftterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . and ( leftterm , rightterm ) ; } else { throw new runtimeexception ( "unreachable code reached => " + matcher ) ; } astnode toreplace = matchedparent ; if ( ! toreplace . hasparent ( ) ) { if ( unwrap ( toreplace ) != toreplace ) { toreplace = unwrap ( toreplace ) ; } else { throw new runtimeexception ( "unreachable code reached" ) ; } } debugprintln ( "distributive law: replacing " + matchedparent . tostring ( false ) + " -> " + replacementterm ) ; toreplace . replacewith ( replacementterm ) ; it . astmutated ( ) ; } } ; return applyinorder ( result , visitor ) ; }
tr	1	public void setstationdata ( string call , string locator , string qrzuser , string qrzpass , double lat , double lon , string hamuser , string hampass ) throws sqlexception { connection con = getdbconnection ( ) ; string query0 = "delete from sation_data" ; con . preparecall ( query0 ) . execute ( ) ; string query = "insert into sation_data (call_id locator longitude latitude qrz_user qrz_pass ham_user ham_pass) values (? ? ? ? ? ? ? ?)" ; java . sql . preparedstatement stm = con . preparestatement ( query ) ; int index = 1 ; stm . setstring ( index ++ , call ) ; stm . setstring ( index ++ , locator ) ; stm . setdouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setdouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setstring ( index ++ , qrzuser ) ; stm . setstring ( index ++ , qrzpass ) ; stm . setstring ( index ++ , hamuser ) ; stm . setstring ( index ++ , hampass ) ; stm . execute ( ) ; }
tr	2	public void savegame ( ) throws cannotsaveexception { try { savefile savefile = new savefile ( gamesaver . auto_save_location ) ; fileoutputstream savestream = new fileoutputstream ( savefile . getfile ( ) ) ; objectoutputstream save = new objectoutputstream ( savestream ) ; save . writeobject ( gamestate . getinstance ( ) ) ; save . close ( ) ; } catch ( cannotcreatefileexception e ) { throw new cannotsaveexception ( "cannot create file" ) ; } catch ( filenotfoundexception e ) { throw new cannotsaveexception ( "file not found" ) ; } catch ( ioexception e ) { throw new cannotsaveexception ( "io exception" ) ; } }
tr	5	@ override protected void handleinboxitem ( inboxitem inboxitem ) { super . handleinboxitem ( inboxitem ) ; if ( inboxitem . getmessage ( ) instanceof tokenmessage ) { executeturn ( ) ; } if ( inboxitem . getmessage ( ) instanceof leaderelectionmessage ) { leaderelectionmessage message = ( leaderelectionmessage ) inboxitem . getmessage ( ) ; switch ( message . getleaderelectionmessagetype ( ) ) { case ask_for_roll : { doroll ( inboxitem . getsender ( ) ) ; break ; } case leader_elected : { initround ( ) ; ownplayer . setactive ( true ) ; if ( message . getvalue ( ) == ownendpoint . getid ( ) ) { isdealer = true ; logger . info ( "new dealer" ) ; sendtoken ( getpreviousplayer ( ) ) ; } else { logger . info ( "player " + message . getvalue ( ) + " is new dealer." ) ; } break ; } case rolled : { gatherroll ( inboxitem . getsender ( ) , message ) ; break ; } } } if ( inboxitem . getmessage ( ) instanceof statusmessage ) { handlestatusmessage ( ( statusmessage ) inboxitem . getmessage ( ) ) ; } if ( inboxitem . getmessage ( ) instanceof dealermessage ) { handledealermessage ( inboxitem . getsender ( ) , ( dealermessage ) inboxitem . getmessage ( ) ) ; } }
tr	4	public void initconvexe ( ) { iterator < classe > iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; next . convexe = new convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { classe classe = vectclasses . elementat ( classes [ i ] ) ; if ( classe . envdessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getk ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; if ( next . envdessinee ) { next . convexe . calculbarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	2	public enterteams ( maingui gui ) { initcomponents ( ) ; this . gui = gui ; graphicsenvironment g = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice [ ] devices = g . getscreendevices ( ) ; int width = devices [ 0 ] . getdisplaymode ( ) . getwidth ( ) ; int height = devices [ 0 ] . getdisplaymode ( ) . getheight ( ) ; int w = this . getsize ( ) . width ; int h = this . getsize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setlocation ( x , y ) ; numberofmatchesfield . setvalue ( 1 ) ; matchfield . setvalue ( 1 ) ; savematchesbutton . setenabled ( false ) ; teamarray = new jtextfield [ 6 ] ; teamarray [ 0 ] = redallianceteam1 ; teamarray [ 1 ] = redallianceteam2 ; teamarray [ 2 ] = redallianceteam3 ; teamarray [ 3 ] = blueallianceteam1 ; teamarray [ 4 ] = blueallianceteam2 ; teamarray [ 5 ] = blueallianceteam3 ; if ( ! "" . equals ( competition . getcompetitionname ( ) ) || competition . getcompetitionname ( ) != null ) { competitionnamefield . settext ( competition . getcompetitionname ( ) ) ; } if ( competition . getnumberofmatches ( ) != 0 ) { numberofmatchesfield . setvalue ( competition . getnumberofmatches ( ) ) ; } dynamicarray teams = new dynamicarray ( 20 ) ; }
tr	2	public boolean savetofile ( string path ) { logger . info ( "write all shares into " + path ) ; if ( path == null || ! path . endswith ( ".ht" ) ) { throw new illegalargumentexception ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { filewriter writer = new filewriter ( path , false ) ; writer . write ( convertsharestostring ( ) ) ; writer . close ( ) ; } catch ( filenotfoundexception e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( ioexception e ) { logger . warning ( "could not write to file '" + path + "' - " + e . getmessage ( ) ) ; return false ; } return true ; }
tr	1	@ test public void testopen ( ) throws ioexception , jaxbexception , classnotfoundexception , interruptedexception , exception { crrcsim crrcsim = new crrcsimrepository ( ) . restorefromfile ( new file ( "./sample/aerosonde/aerosonde.crr" ) ) ; new crrcsimrepository ( ) . storetofile ( this . file , crrcsim ) ; crrcsim = new crrcsimrepository ( ) . restorefromfile ( this . file ) ; assertequals ( 0.254 , crrcsim . getavl ( ) . getgeometry ( ) . getsurfaces ( ) . get ( 0 ) . getsections ( ) . get ( 0 ) . getchord ( ) , 0.0001 ) ; }
tr	1	public static void main ( string [ ] args ) throws exception { predicate < string > predicate = ( s ) -> s . length ( ) > 0 ; predicate . test ( "foo" ) ; predicate . negate ( ) . test ( "foo" ) ; predicate < boolean > nonnull = objects colcol nonnull ; predicate < boolean > isnull = objects colcol isnull ; predicate < string > isempty = string colcol isempty ; predicate < string > isnotempty = isempty . negate ( ) ; function < string , integer > tointeger = integer colcol valueof ; function < string , string > backtostring = tointeger . andthen ( string colcol valueof ) ; backtostring . apply ( "123" ) ; supplier < person > personsupplier = person colcol new ; personsupplier . get ( ) ; consumer < person > greeter = ( p ) -> system . out . println ( "hello  " + p . firstname ) ; greeter . accept ( new person ( "luke" , "skywalker" ) ) ; comparator < person > comparator = ( p1 , p2 ) -> p1 . firstname . compareto ( p2 . firstname ) ; person p1 = new person ( "john" , "doe" ) ; person p2 = new person ( "alice" , "wonderland" ) ; comparator . compare ( p1 , p2 ) ; comparator . reversed ( ) . compare ( p1 , p2 ) ; runnable runnable = ( ) -> system . out . println ( uuid . randomuuid ( ) ) ; runnable . run ( ) ; callable < uuid > callable = uuid colcol randomuuid ; callable . call ( ) ; }
tr	4	public char [ ] mincharcutmulti ( int numoftracks ) { debugger . debug ( "min cut set:***************\n" , 2 , debuglevel ) ; hashset < arraylist < transition >> mincutset = mincutmulti ( numoftracks ) ; stringbuilder b = new stringbuilder ( ) ; for ( arraylist < transition > tracksarray : mincutset ) { transition tracks [ ] = new transition [ numoftracks ] ; for ( int i = 0 ; i < tracksarray . size ( ) ; i ++ ) { tracks [ tracksarray . get ( i ) . track - 1 ] = tracksarray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; transition . appendcharstring ( tracks [ i ] . max , b ) ; } else transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } debugger . debug ( b . tostring ( ) , 0 , debuglevel ) ; return null ; }
tr	5	public static method getmostspecificmethod ( method method , class < ? > targetclass ) { if ( method != null && isoverridable ( method , targetclass ) && targetclass != null && ! targetclass . equals ( method . getdeclaringclass ( ) ) ) { try { if ( modifier . ispublic ( method . getmodifiers ( ) ) ) { try { return targetclass . getmethod ( method . getname ( ) , method . getparametertypes ( ) ) ; } catch ( nosuchmethodexception ex ) { return method ; } } else { method specificmethod = reflectionutils . findmethod ( targetclass , method . getname ( ) , method . getparametertypes ( ) ) ; return ( specificmethod != null ? specificmethod : method ) ; } } catch ( securityexception ex ) { } } return method ; }
tr	1	private void init ( gridpanel gridpanel ) { this . gridpanel = gridpanel ; container thiss = getcontentpane ( ) ; thiss . setlayout ( new borderlayout ( ) ) ; thiss . setbackground ( charapp . color_bg ) ; jpanel fontpanel = new jpanel ( new gridlayout ( 3 , 1 ) ) ; fontpanel . setbackground ( charapp . color_bg ) ; resize = new jbutton ( "resize" ) ; chinese = new jbutton ( "chinese font" ) ; pinyin = new jbutton ( "pinyin font" ) ; other = new jbutton ( "other font" ) ; display = new jbutton ( "main display" ) ; ok = new jbutton ( "ok" ) ; chineseexample = new jlabel ( chtext , swingconstants . center ) ; chineseexample . setfont ( gridpanel . getchinesefont ( ) ) ; pinyinexample = new jlabel ( pintext , swingconstants . center ) ; pinyinexample . setfont ( gridpanel . getpinyinfont ( ) ) ; otherexample = new jlabel ( entext , swingconstants . center ) ; otherexample . setfont ( gridpanel . getotherfont ( ) ) ; chinese . setbackground ( charapp . color_button ) ; pinyin . setbackground ( charapp . color_button ) ; other . setbackground ( charapp . color_button ) ; display . setbackground ( charapp . color_button ) ; chinese . addactionlistener ( this ) ; pinyin . addactionlistener ( this ) ; other . addactionlistener ( this ) ; resize . addactionlistener ( this ) ; display . addactionlistener ( this ) ; ok . addactionlistener ( this ) ; jpanel temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( chinese ) ; temp . add ( chineseexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( pinyin ) ; temp . add ( pinyinexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( other ) ; temp . add ( otherexample ) ; fontpanel . add ( temp ) ; thiss . add ( fontpanel , borderlayout . center ) ; jpanel buttonpanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; buttonpanel . add ( ok ) ; buttonpanel . add ( resize ) ; ok . setbackground ( charapp . color_button ) ; resize . setbackground ( charapp . color_button ) ; buttonpanel . setbackground ( charapp . color_bg ) ; thiss . add ( buttonpanel , borderlayout . south ) ; this . pack ( ) ; this . setlocation ( ( int ) getowner ( ) . getlocation ( ) . getx ( ) - 100 , ( int ) getowner ( ) . getlocation ( ) . gety ( ) + getowner ( ) . getheight ( ) / 3 ) ; }
tr	4	private static void begin ( ) { scanner sc = new scanner ( system . in ) ; int ntestcases = integer . parseint ( sc . nextline ( ) ) ; sc . nextline ( ) ; line decryptedline = new line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < ntestcases ; ++ t ) { list < line > lines = new linkedlist < line > ( ) ; map < character , character > dict = null ; while ( sc . hasnextline ( ) ) { string input = sc . nextline ( ) ; if ( input . isempty ( ) ) { break ; } line line = new line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getdict ( decryptedline ) ; } } if ( dict == null ) { system . out . println ( "no solution." ) ; } else { for ( line l : lines ) { system . out . println ( l . decrypt ( dict ) ) ; } } if ( t < ntestcases - 1 ) { system . out . println ( ) ; } } }
tr	5	@ override public void call ( ) throws ioexception { boolean online = true ; while ( online ) { selector . select ( ) ; iterator < selectionkey > it = selector . selectedkeys ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { selectionkey key = it . next ( ) ; it . remove ( ) ; socketchannel channel = ( socketchannel ) key . channel ( ) ; messagehandler handler = handlers . get ( channel ) ; if ( key . isreadable ( ) ) { dataunit message ; try { message = mp . read ( p , channel ) ; handler . handlemessage ( message ) ; } catch ( ioexception e ) { handler . notifydisconnect ( ) ; handlers . remove ( channel ) ; key . cancel ( ) ; } } } } return null ; }
tr	1	private void checkcrossings ( final player player , final location from , final location to ) { message entered = null ; final set < region > regions = new hashset < region > ( ) ; regions . addall ( this . catalog . cached ( from . getworld ( ) , from . getblockx ( ) >> 4 , from . getblockz ( ) >> 4 ) ) ; if ( ! boundaryalerter . samechunk ( from , to ) ) regions . addall ( this . catalog . cached ( to . getworld ( ) , to . getblockx ( ) >> 4 , to . getblockz ( ) >> 4 ) ) ; entered = this . checkregions ( player , from , to , regions , entered ) ; if ( entered != null ) main . courier . submit ( new individual ( player ) , entered ) ; }
tr	2	private void drawcheckerboard ( graphics2d g ) { color backupcolor = g . getcolor ( ) ; stroke backupstroke = g . getstroke ( ) ; g . setcolor ( color . red ) ; g . setstroke ( new basicstroke ( 1.0f ) ) ; g . drawrect ( 0 , 0 , _canvasbackground . getwidth ( ) - 1 , _canvasbackground . getheight ( ) - 1 ) ; for ( int i = 0 ; i < _imagelist . size ( ) ; i ++ ) { iplnode node = _imagelist . get ( i ) ; g . drawrect ( node . getx ( ) , node . gety ( ) , node . getscalewidth ( ) , node . getscaleheight ( ) ) ; } g . setcolor ( backupcolor ) ; g . setstroke ( backupstroke ) ; }
tr	4	private jpanel getcenterpanel ( ) { if ( centerpanel == null ) { centerpanel = new jpanel ( ) ; centerpanel . setlayout ( new miglayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttongameboard [ i ] [ j ] . setsize ( 40 , 40 ) ; centerpanel . add ( buttongameboard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerpanel ; }
tr	4	public list < string > generateparenthesis ( int n ) { list < string > result = new arraylist < string > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateparenthesis ( n - 1 ) ; arraylist < string > returnlist = new arraylist < string > ( ) ; int tempsize = result . size ( ) ; for ( int j = 0 ; j < tempsize ; j ++ ) { string tempstr = result . get ( j ) ; stringbuffer sb = new stringbuffer ( tempstr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { string str = sb . insert ( i , "()" ) . tostring ( ) ; sb = new stringbuffer ( tempstr ) ; if ( ! returnlist . contains ( str ) ) { returnlist . add ( str ) ; } } } return returnlist ; }
tr	1	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof describecomponentsresult == false ) return false ; describecomponentsresult other = ( describecomponentsresult ) obj ; if ( other . getcomponentinfos ( ) == null ^ this . getcomponentinfos ( ) == null ) return false ; if ( other . getcomponentinfos ( ) != null && other . getcomponentinfos ( ) . equals ( this . getcomponentinfos ( ) ) == false ) return false ; return true ; }
tr	4	private void randomplayergroup ( int start , int end ) { game game = new game ( ) ; randomplayer randomplayer = new randomplayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { playerenlist player = players . get ( i ) ; for ( int j = 0 ; j < groupsize - 1 ; j ++ ) { game . startgame ( player . player , randomplayer ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . first_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } game . startgame ( randomplayer , player . player ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . second_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } } } }
tr	3	private string internalreadchunkedstring ( int length ) throws ioexception { stringbuffer buf = internalreadstring ( length ) ; boolean done = false ; while ( ! done ) { int code = readnextcode ( ) ; switch ( code ) { case codes . string_packed_length_start + 0 : case codes . string_packed_length_start + 1 : case codes . string_packed_length_start + 2 : case codes . string_packed_length_start + 3 : case codes . string_packed_length_start + 4 : case codes . string_packed_length_start + 5 : case codes . string_packed_length_start + 6 : case codes . string_packed_length_start + 7 : internalreadstringbuffer ( buf , code - codes . string_packed_length_start ) . tostring ( ) ; done = true ; break ; case codes . string : internalreadstringbuffer ( buf , readcount ( ) ) ; done = true ; break ; case codes . string_chunk : internalreadstringbuffer ( buf , readcount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . tostring ( ) ; }
tr	2	public dictionaryset ( ) { iscounting = false ; dicts = new dictionary [ dictionarytypes . type_end . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new dictionary ( ) ; int id = dicts [ i ] . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( i == dictionarytypes . pos . ordinal ( ) ) initdict ( dictionarytypes . pos , dicts [ i ] ) ; if ( i == dictionarytypes . word . ordinal ( ) ) initdict ( dictionarytypes . word , dicts [ i ] ) ; } }
tr	2	@ test public void testpacketsending ( ) throws socketexception { microsecondstimestamp stamper = mock ( microsecondstimestamp . class ) ; when ( stamper . timestamp ( ) ) . thenreturn ( 0 ) ; utpalgorithm algorithm = new utpalgorithm ( stamper , new inetsocketaddress ( 51235 ) ) ; utpalgconfiguration . send_in_burst = true ; utpalgconfiguration . max_burst_send = 3 ; int packetlength = 1000 ; algorithm . setmaxwindow ( packetlength * 10 ) ; utptimestampedpacketdto pkt5 = createpacket ( 5 , packetlength ) ; utptimestampedpacketdto pkt6 = createpacket ( 6 , packetlength ) ; utptimestampedpacketdto pkt7 = createpacket ( 7 , packetlength ) ; utptimestampedpacketdto pkt8 = createpacket ( 8 , packetlength ) ; utptimestampedpacketdto pkt9 = createpacket ( 9 , packetlength ) ; algorithm . markpacketonfly ( pkt5 . utppacket ( ) , pkt5 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt6 . utppacket ( ) , pkt6 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt7 . utppacket ( ) , pkt7 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt8 . utppacket ( ) , pkt8 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt9 . utppacket ( ) , pkt9 . datagram ( ) ) ; assertequals ( 5 * ( utppacketutils . def_header_length + packetlength ) , algorithm . getcurrentwindow ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; algorithm . setmaxwindow ( packetlength * 4 ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } algorithm . setmaxwindow ( 10 * packetlength ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; }
tr	5	protected void notifyreceivedack ( mqttack ack ) throws mqttexception { final string methodname = "notifyreceivedack" ; this . lastinboundactivity = system . currenttimemillis ( ) ; log . fine ( classname , methodname , "627" , new object [ ] { new integer ( ack . getmessageid ( ) ) , ack } ) ; mqtttoken token = tokenstore . gettoken ( ack ) ; mqttexception mex = null ; if ( ack instanceof mqttpubrec ) { mqttpubrel rel = new mqttpubrel ( ( mqttpubrec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof mqttpuback || ack instanceof mqttpubcomp ) { notifyresult ( ack , token , mex ) ; } else if ( ack instanceof mqttpingresp ) { pingoutstanding = false ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; } else if ( ack instanceof mqttconnack ) { int rc = ( ( mqttconnack ) ack ) . getreturncode ( ) ; if ( rc == 0 ) { synchronized ( queuelock ) { if ( cleansession ) { clearstate ( ) ; tokenstore . savetoken ( token , ack ) ; } inflightpubrels = 0 ; actualinflight = 0 ; restoreinflightmessages ( ) ; connected ( ) ; } } else { mex = exceptionhelper . createmqttexception ( rc ) ; throw mex ; } clientcomms . connectcomplete ( ( mqttconnack ) ack , mex ) ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; synchronized ( queuelock ) { queuelock . notifyall ( ) ; } } else { notifyresult ( ack , token , mex ) ; releasemessageid ( ack . getmessageid ( ) ) ; tokenstore . removetoken ( ack ) ; } checkquiescelock ( ) ; }
tr	1	private void init ( ) { int n = mapinfo . getmapsize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapinfo . setcell ( row , column , new cell ( true , true , true , true ) ) ; }
tr	5	protected void childclosing ( ) { setclosable ( wascloseable ) ; getglasspane ( ) . setvisible ( false ) ; if ( focusowner != null ) { java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { movetofront ( ) ; setselected ( true ) ; focusowner . grabfocus ( ) ; } catch ( propertyvetoexception ex ) { logger . getlogger ( modalityinternalframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; focusowner . grabfocus ( ) ; } getglasspane ( ) . setcursor ( cursor . getpredefinedcursor ( cursor . default_cursor ) ) ; setchildframe ( null ) ; }
tr	5	private list < string > generacachekey ( object obj ) { ormtable ormtable = obj . getclass ( ) . getannotation ( ormtable . class ) ; if ( ormtable != null ) { string cachedtablekey = "" . equalsignorecase ( ormtable . cachedshortalias ( ) ) ? ormtable . tablename ( ) : ormtable . cachedshortalias ( ) ; string [ ] cachedkeys = ormtable . cachedkey ( ) ; if ( cachedkeys . length > 0 ) { list < string > ks = new arraylist < string > ( ) ; for ( int i = 0 ; i < cachedkeys . length ; i ++ ) { string cachedcol = cachedkeys [ i ] ; string [ ] fk = cachedcol . split ( "=" ) ; try { field f = obj . getclass ( ) . getdeclaredfield ( fk [ 0 ] ) ; f . setaccessible ( true ) ; ks . add ( cachedtablekey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( nosuchfieldexception e ) { logger . warn ( "nosuchfieldexception:{};" , cachedcol , e ) ; continue ; } catch ( securityexception e ) { logger . warn ( "securityexception:{};" , cachedcol , e ) ; continue ; } catch ( illegalargumentexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } catch ( illegalaccessexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	2	public registeredeventmonitor ( method monitormethod , listener listener ) { eventmonitor monitorannotation = monitormethod . getannotation ( eventmonitor . class ) ; if ( monitorannotation == null ) { throw new illegalargumentexception ( "monitor method does not have an eventmonitor annotation." ) ; } class < ? > [ ] monitormethodparameters = monitormethod . getparametertypes ( ) ; if ( monitormethodparameters . length != 2 || ! event . class . isassignablefrom ( monitormethodparameters [ 0 ] ) || ! result . class . isassignablefrom ( monitormethodparameters [ 1 ] ) ) { throw new illegalargumentexception ( "monitor method signature is invalid. cannot accept (event  result)." ) ; } eventtype = ( class < ? extends event > ) monitormethodparameters [ 0 ] ; this . monitormethod = monitormethod ; if ( ! monitormethod . isaccessible ( ) ) { monitormethod . setaccessible ( true ) ; } this . listener = listener ; }
tr	5	public simulator ( ) throws interruptedexception { guimanager . simulator = this ; phase = phase . init ; thread simulatorthread = new thread ( new runnable ( ) { @ override public void run ( ) { log . finer ( "maked simulation instance." ) ; setting ( ) ; int periodtime = conf . countperiod ; long start , end , - , sleeptime ; while ( true ) { start = system . currenttimemillis ( ) ; select ( ) ; end = system . currenttimemillis ( ) ; - = end - start ; sleeptime = 1000 / periodtime - - ; try { thread . sleep ( ( sleeptime >= 0 ? sleeptime : 0 ) ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; simulatorthread . start ( ) ; log . finer ( "end of simulation instance." ) ; }
tr	1	public static byte [ ] generateauthenticatorserver ( int status , byte [ ] authenticatorclient , string sharekey ) throws nosuchalgorithmexception { byte [ ] keybyte = sharekey . getbytes ( ) ; byte [ ] buf = new byte [ authenticatorclient . length + 4 + keybyte . length ] ; typeconvert . int2byte ( status , buf , 0 ) ; system . arraycopy ( authenticatorclient , 0 , buf , 4 , authenticatorclient . length ) ; system . arraycopy ( keybyte , 0 , buf , 4 + authenticatorclient . length , keybyte . length ) ; return md5 ( buf ) ; }
tr	1	protected void adddatabeans ( ) { list < samplebean > beans = new arraylist < samplebean > ( ) ; beans . add ( new samplebean ( new date ( datereference - 2397984 ) , new integer ( 1 ) , "laptop" , new boolean ( false ) , new integer ( 1 ) , new double ( 799.78 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 232042098 ) , new integer ( 2 ) , "mouse" , new boolean ( true ) , new integer ( 2 ) , new double ( 49.30 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 234084277 ) , new integer ( 3 ) , "keyboard" , new boolean ( false ) , new integer ( 5 ) , new double ( 75 ) ) ) ; exporter . addbeanrows ( beans ) ; }
tr	3	public void convert ( ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . comment unfuddlecomment : ticket . getcomments ( ) ) { string username = null ; person p = provider . getpeopleconverter ( ) . findpersonbyid ( unfuddlecomment . getauthorid ( ) ) ; if ( null == p ) { system . out . println ( "warning: the comment-author with id '" + unfuddlecomment . getauthorid ( ) + "' could not be found in the input file. using 'null'." ) ; } else { username = p . getname ( ) ; } comment comment = new comment ( unfuddlecomment . getbody ( ) , unfuddlecomment . getcreatedat ( ) . togregoriancalendar ( ) . gettime ( ) , getuniquecommentid ( ) , ticket . getid ( ) , ticket . getupdatedat ( ) . togregoriancalendar ( ) . gettime ( ) , username ) ; comments . add ( comment ) ; } }
tr	5	@ override public void doturn ( ) { getlocation ( ) . world . cleartilevisibility ( ) ; for ( int y = getlocation ( ) . y + getviewdistance ( ) ; y >= getlocation ( ) . y - getviewdistance ( ) ; y -- ) { int deltax = getviewdistance ( ) - math . abs ( y - getlocation ( ) . y ) ; for ( int x = getlocation ( ) . x + deltax ; x >= getlocation ( ) . x - deltax ; x -- ) { if ( aicontroller . checkvisibility ( getlocation ( ) , new worldlocation ( null , x , y ) ) ) { getlocation ( ) . world . settilevisible ( x , y , true ) ; } if ( new worldlocation ( getlocation ( ) . world , x , y ) . gettile ( ) instanceof tilesecretdoor ) { int chance = 30 - getstats ( ) . getintelligence ( ) ; if ( chance <= 0 || new random ( ) . nextint ( chance ) == 0 ) { logmessage ( "something about one of the walls nearby seems off to you" ) ; } } } } }
tr	4	void deletetime ( component dialogparent , time time ) { if ( time != null ) { if ( alertmessages . deletetimeconfirmation ( dialogparent , time ) ) { try { timedao . deletetime ( dao . getconnection ( ) , time ) ; timedialog . settime ( null ) ; timelistdialog . selectpreviousrow ( ) ; timedialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deletetime()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deletetime()" , ex ) ; } } } else { alertmessages . notimeselectedintablefordeleting ( timelistdialog ) ; } }
tr	5	@ override public boolean onresponse ( message message ) { string msg = message . content . tolowercase ( ) ; pattern pattern = pattern . compile ( "^@((qinbot)|(\u4eb2\u59b9\u5b50)) +help(.*)" ) ; matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( "\\\\n\u8f93\u5165@qinbot help \u63d2\u4ef6\u540d\u79f0 \u83b7\u53d6\u5177\u4f53\u5e2e\u52a9\\\\n\u5f53\u524d\u63d2\u4ef6\u5982\u4e0b:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . tostring ( ) ) ; } else { string help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { pluginbase pluginbase = plugins . get ( i ) ; help = string . format ( "\\\\n\u7b80\u4ecb:%s\\\\n\u5e2e\u52a9:%s\\\\n" , pluginbase . descrition , pluginbase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672a\u627e\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	4	public regularanalyzer ( list < rule > rules ) { set < string > definedrulenames = new hashset < string > ( ) ; list < rule > observedrules = new arraylist < rule > ( ) ; observedrules . addall ( rules ) ; boolean foundregular ; do { foundregular = false ; for ( int index = observedrules . size ( ) - 1 ; index >= 0 ; index -- ) { set < string > dependent = observedrules . get ( index ) . getelements ( ) . getdependentrulenames ( ) ; if ( definedrulenames . containsall ( dependent ) ) { definedrulenames . add ( observedrules . get ( index ) . getrulename ( ) . tostring ( ) ) ; regularrules . add ( observedrules . get ( index ) ) ; observedrules . remove ( index ) ; foundregular = true ; continue ; } } } while ( foundregular ) ; observedrules . clear ( ) ; }
tr	5	@ test public void superthreadsafe ( ) { final simplemath math = new simplemath ( ) ; final map < integer , integer > results = new concurrenthashmap < integer , integer > ( ) ; final countdownlatch latch = new countdownlatch ( 1000 ) ; final countdownlatch alldone = new countdownlatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new thread ( ) { public void run ( ) { try { latch . countdown ( ) ; latch . await ( ) ; int result = math . doubleandincrement ( copy ) ; results . put ( copy , result ) ; alldone . countdown ( ) ; } catch ( exception e ) { } } } . start ( ) ; } try { alldone . await ( ) ; } catch ( exception e ) { } assertequals ( new integer ( 45 ) , results . get ( 22 ) ) ; }
tr	4	@ override @ transactional public list getfiltervaluesforreview ( string merchantname , string username , string reviewstatus ) throws exception { list filtervalueslist = new arraylist ( ) ; try { if ( merchantname != null ) { query getmerchant = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.omerchant from merchantreview merchantreview" ) ; filtervalueslist = getmerchant . list ( ) ; system . out . println ( "merchant size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchant merchant = ( merchant ) iterator . next ( ) ; system . out . println ( "merchant-------->" + merchant ) ; } } else if ( username != null ) { query getcashbackuser = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ocashbackuser from merchantreview merchantreview" ) ; filtervalueslist = getcashbackuser . list ( ) ; system . out . println ( "user size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { cashbackuser cashbackuser = ( cashbackuser ) iterator . next ( ) ; system . out . println ( "user-------->" + cashbackuser ) ; } } else { query getreview = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ostatus from merchantreview merchantreview" ) ; filtervalueslist = getreview . list ( ) ; system . out . println ( "review status size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchantreviewstatus merchantreviewstatus = ( merchantreviewstatus ) iterator . next ( ) ; system . out . println ( "reviewstatus-------->" + merchantreviewstatus ) ; } } } catch ( exception exception ) { throw exception ; } return filtervalueslist ; }
tr	3	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { printwriter out = response . getwriter ( ) ; request . setcharacterencoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setcontenttype ( "text/html;charset=utf-8" ) ; search com = new search ( ) ; string id [ ] = request . getparametervalues ( "id" ) ; string doctellid [ ] = request . getparametervalues ( "doctellid" ) ; string docid [ ] = request . getparametervalues ( "docid" ) ; string doctellcontent [ ] = request . getparametervalues ( "doctellcontent" ) ; string excutedate [ ] = request . getparametervalues ( "excutedate" ) ; string excuteid [ ] = request . getparametervalues ( "excuteid" ) ; string doctelltype [ ] = request . getparametervalues ( "doctelltype" ) ; string stopdate [ ] = request . getparametervalues ( "stopdate" ) ; string patientid = request . getparameter ( "patientid" ) ; for ( int i = 0 ; i < doctellid . length ; i ++ ) { r = com . doctellfind ( id [ i ] ) ; if ( r ) { e = com . doctellupdate ( id [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] ) ; } else { system . out . println ( doctellid [ i ] ) ; e = com . doctellinsert ( id [ i ] , doctellid [ i ] , docid [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] , patientid ) ; } } if ( e ) { response . sendredirect ( request . getcontextpath ( ) + "/wardmanagement/patientlist.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } }
tr	3	@ override public object getvalueat ( int row , int column ) { vehicle vehicle = vehicles . elementat ( row ) ; switch ( column ) { case 0 : return vehicle . getlicenceplate ( ) ; case 1 : return vehicle . getstartdate ( ) ; case 2 : return vehicle . getowner ( ) . getfirstname ( ) + " " + vehicle . getowner ( ) . getfamilyname ( ) . touppercase ( ) ; case 3 : return vehicle . getmodel ( ) . getdesignation ( ) ; case 4 : if ( this . deleteicon == null ) { return "supprimer" ; } return this . deleteicon ; default : break ; } return null ; }
tr	3	private void emitloadorstore ( int opcode , int a , adda address ) throws exception { value v = address . getarg1 ( ) ; int b , c ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; v = address . getarg2 ( ) ; if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getarg2 ( ) ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( type . getgbp ( ) ) ) { c = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( dlx . assemble ( opcode , a , b , c ) ) ; }
tr	4	public list < integer > getrow ( int rowindex ) { list < integer > result = new arraylist < integer > ( ) ; list < integer > temp = new arraylist < integer > ( ) ; for ( int i = 0 ; i <= rowindex ; i ++ ) { temp = new arraylist < integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	5	public void render ( map map ) { if ( updatesenses ) { long starttime = system . currenttimemillis ( ) ; playersenses = map . getplayersenses ( ) ; long endtime = system . currenttimemillis ( ) ; log . print ( "shadowcasting time: " + ( endtime - starttime ) ) ; updatesenses = false ; } hashmap < integer , tile > tilehashmap = playersenses . gettiles ( ) ; hashmap < integer , actor > actorhashmap = playersenses . getactors ( ) ; hashmap < integer , arraylist < entity >> entities = playersenses . getentities ( ) ; point top_left = new point ( playerpos . getx ( ) - tilesx , playerpos . gety ( ) - tilesy ) ; for ( int x = top_left . getx ( ) ; x <= playerpos . getx ( ) + tilesx ; x ++ ) { for ( int y = top_left . gety ( ) ; y <= playerpos . gety ( ) + tilesy ; y ++ ) { if ( map . inbounds ( x , y ) ) { tile tile = tilehashmap . get ( map . genkey ( x , y ) ) ; if ( tile != null ) { image image = environment . getsprite ( tile . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } arraylist < entity > ents = entities . get ( map . genkey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { entity entity = ents . get ( 0 ) ; image image = environment . getsprite ( entity . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } actor actor = actorhashmap . get ( map . genkey ( x , y ) ) ; if ( actor != null ) { image image = actor_sprites . getsprite ( actor . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } } } } image player = actor_sprites . getsprite ( actorsprite . player ) ; player . draw ( ( float ) ( ( playerpos . getx ( ) - top_left . getx ( ) ) * ppt ) , ( float ) ( ( playerpos . gety ( ) - top_left . gety ( ) ) * ppt ) , scale ) ; messagebox . render ( ) ; }
tr	4	public static void applyshading ( mesh m , view3d view ) { m . ensurevertbuffers ( ) ; m . transformvertices ( m . getmatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { renderable e = m . elem ( i ) ; if ( e . type != renderable_face ) continue ; face f = ( face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; svect . x = m . viewvert [ a + 0 ] - m . viewvert [ c + 0 ] ; svect . y = m . viewvert [ a + 1 ] - m . viewvert [ c + 1 ] ; svect . z = m . viewvert [ a + 2 ] - m . viewvert [ c + 2 ] ; tvect . x = m . viewvert [ b + 0 ] - m . viewvert [ c + 0 ] ; tvect . y = m . viewvert [ b + 1 ] - m . viewvert [ c + 1 ] ; tvect . z = m . viewvert [ b + 2 ] - m . viewvert [ c + 2 ] ; fpoint3 . crossproduct ( svect , tvect , cprod ) ; cprod . normalize ( ) ; double sine = - fpoint3 . dotproduct ( cprod , view . lightdir ( ) ) ; double currlevel = f . getshade ( ) * .75 ; if ( sine > 0 ) { currlevel = ( 1.0 + sine ) * currlevel ; } f . setshade ( ( int ) currlevel ) ; } } }
tr	2	public int priseterritoire ( territoire t , int nbunite ) { if ( this . nbunitebonus >= nbunite - 1 ) { this . nbunitebonus -= nbunite - 1 ; nbunite = 1 ; } else { nbunite -= this . nbunitebonus ; this . nbunitebonus = 0 ; } this . nbuniteenmain -= nbunite ; t . setnbunite ( nbunite ) ; t . setoccupant ( this ) ; this . territoiresoccupes . add ( t ) ; this . actionpriseterritoire ( t ) ; if ( haspower ( ) ) { this . pouvoir . actionpriseterritoire ( t ) ; } return nbunite ; }
tr	2	@ test public void testtokenpayment ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; httpsconnector connector = new httpsconnector ( 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; legatotokenrequest legatotokenrequest = new legatotokenrequest ( ) ; legatotokenrequest . number = "5100000010001004" ; legatotokenrequest . expirymonth = 12 ; legatotokenrequest . expiryyear = 18 ; legatotokenrequest . cvd = "123" ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; tokenpaymentrequest tokenreq = new tokenpaymentrequest ( ) ; tokenreq . setamount ( 100.00 ) ; tokenreq . setordernumber ( getrandomorderid ( "token" ) ) ; tokenreq . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( tokenreq ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token pre-auth: " + tokenresponse . gettoken ( ) ) ; tokenpaymentrequest req = new tokenpaymentrequest ( ) ; req . setamount ( 80.00 ) ; req . setordernumber ( getrandomorderid ( "token" ) ) ; req . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( req ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; response = beanstream . payments ( ) . preauthcompletion ( response . id , 55.30 ) ; assert . asserttrue ( response . isapproved ( ) ) ; assert . assertequals ( "pac" , response . type ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } }
tr	3	private static void createlist ( string tabname , final vector < chart > charts , tabfolder tabfolder , final stacklayout layout , final composite composite ) { final list list = new list ( tabfolder , swt . h_scroll | swt . v_scroll ) ; tabitem basictabitem = new tabitem ( tabfolder , swt . none ) ; basictabitem . settext ( tabname ) ; basictabitem . setcontrol ( list ) ; for ( chart chart : charts ) { list . add ( chart . gettitle ( ) . gettext ( ) ) ; } list . addselectionlistener ( new selectionadapter ( ) { @ override public void widgetselected ( selectionevent event ) { chart chart = charts . get ( list . getselectionindex ( ) ) ; chart . getaxisset ( ) . adjustrange ( ) ; layout . topcontrol = chart ; composite . layout ( ) ; } } ) ; }
tr	5	public void actionperformed ( actionevent e ) { if ( nooftestclients == 1 ) { testclient newtc = new testclient ( serverwindow . getwmserver ( ) . getport ( ) ) ; newtc . start ( ) ; serverwindow . updatenooftestclients ( ++ counttestclients ) ; testclients . add ( newtc ) ; } else { try { nooftestclients = integer . valueof ( popup . getinput ( ) . gettext ( ) ) ; } catch ( numberformatexception nfe ) { swingutilities . invokelater ( new runnable ( ) { public void run ( ) { popup . getinput ( ) . settext ( "100" ) ; } } ) ; } swingutilities . invokelater ( new runnable ( ) { public void run ( ) { popup . dispose ( ) ; } } ) ; testclient [ ] dummy = new testclient [ nooftestclients ] ; for ( int i = 0 ; i < dummy . length ; i ++ ) { dummy [ i ] = new testclient ( serverwindow . getwmserver ( ) . getport ( ) ) ; dummy [ i ] . start ( ) ; serverwindow . updatenooftestclients ( ++ counttestclients ) ; testclients . add ( dummy [ i ] ) ; } swingutilities . invokelater ( new runnable ( ) { public void run ( ) { serverwindow . setenabled ( true ) ; } } ) ; } }
tr	2	@ override public int attachsoundeffect ( soundeffect effect , int channel ) { if ( channel > cheffects . size ( ) ) throw new indexoutofboundsexception ( "channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getchannelcount ( ) != channelcount ) throw new illegalargumentexception ( "the effects channel count must be same as this mixers channel count!" ) ; meffects . add ( effect ) ; return meffects . size ( ) - 1 ; } else { if ( effect . getchannelcount ( ) != getinputchanneloutputchannelcount ( channel ) ) throw new illegalargumentexception ( "the effects channel count must be the same as input channels channel count!" ) ; arraylist < soundeffect > e = cheffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	3	private set < strategy > buildstrategies ( strategy strategy , int breakpointnumber , int [ ] breakpoints , int [ ] [ ] actionpercentages ) { set < strategy > strategies = new hashset < strategy > ( ) ; for ( int [ ] actionpercentageset : actionpercentages ) { strategy s = new strategy ( strategy ) ; tactic nexttactic = new tactic ( actionpercentageset ) ; s . putnewtactic ( nexttactic ) ; if ( breakpointnumber < aisettings . default_breakpoints . length - 1 ) { strategies . addall ( buildstrategies ( s , breakpointnumber + 1 , breakpoints , actionpercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
tr	3	arraylist < object [ ] > getpickerargs ( ) { arraylist < object [ ] > pickerargs = new arraylist < object [ ] > ( ) ; if ( this . pickers > 0 ) { pickers pickers = this . warehouse . getpickers ( ) ; arraylist < picker > rl = pickers . getpickerlist ( ) ; for ( picker r : rl ) { object [ ] args = new object [ 1 ] ; args [ 0 ] = r . getuid ( ) ; pickerargs . add ( args ) ; } } return pickerargs ; }
tr	3	private void drawlines ( graphics g , treenode [ ] nodes ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . black ) ; g2d . setstroke ( new basicstroke ( line_thickness ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i ] . centerx , nodes [ 2 * i ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i + 1 ] . centerx , nodes [ 2 * i + 1 ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } } }
tr	1	public boolean autochecksibmessage ( string xml , string id [ ] , string ref [ ] ) { hashtable hashtable = sibxmlmessageparser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( string ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
tr	1	@ test public void testsortcollection ( ) { xlist expected = new xlist ( ds ) ; expected . add ( 0 , ( new tree ( "\u0415\u043b\u044c" , 150 , false , 1500 ) ) ) ; expected . add ( 1 , new tree ( "\u0414\u0443\u0431" , 200 , true , 1000 ) ) ; expected . add ( 2 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u0420\u043e\u043c\u0430\u0448\u043a\u0430" , 15 , 1 ) ) ; expected . add ( 3 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u041b\u0438\u043b\u0438\u044f" , 10 , 1 ) ) ; listplant . sortcollection ( ) ; assertequals ( expected , listplant . getlistplants ( ) ) ; }
tr	5	public string dtdetailsearch ( string id ) { string docname = "" ; string doctellcontent = "" ; string excutedate = "" ; string stopdate = "" ; string doctellstatus = "" ; string doctelltype = "" ; string sd = "" ; string pn = "" ; string str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; system . out . println ( "doctelldetailsearch_______________________" + str ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str ) ; resultset num = pstmt . executequery ( ) ; while ( num . next ( ) ) { excutedate = num . getstring ( "excute_date" ) ; stopdate = num . getstring ( "stop_date" ) ; docname = num . getstring ( "user_name" ) ; doctellstatus = num . getstring ( "doc_tell_status" ) ; doctelltype = num . getstring ( "doc_tell_type" ) ; doctellcontent = num . getstring ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getattribute('userid') %>\" style=\"display:none\" id=\"excuteid\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4e3b\u6cbb\u533b\u751f:" + docname + "</td>  <td>\u4f5c\u7528\u65f6\u95f4:" + excutedate + "~" + stopdate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533b\u5631\u5185\u5bb9\uff1a <textarea readonly rows=\"6\" cols=\"80\" name=\"doctellcontent\" id=\"doctellcontent\" onpropertychange=\"if(this.scrollheight>80) this.style.posheight=this.scrollheight+5\">" + doctellcontent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( doctelltype . equals ( "1" ) ) { switch ( integer . parseint ( doctellstatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nursecheck\" onclick=\"save(2)\" value=\"\u62a4\u58eb\u6821\u5bf9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docstop\"  onclick=\"save(3)\" value=\"\u505c\u6b62\u533b\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseconfirm\" onclick=\"save(4)\"  value=\"\u62a4\u58eb\u786e\u8ba4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( doctelltype . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseconfirm\"  value=\"\u62a4\u58eb\u786e\u8ba4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbconn . close ( conn ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return sb . tostring ( ) ; }
tr	4	public void updatelocation ( int id , list < object > list ) { if ( ! handler_location . initialize ( ) ) { system . out . println ( "locationserver : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { string mac = ( string ) list . get ( i ) ; locationnode node = handler_location . getlocationnode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updatelocation ( id , result ) ; } handler_location . close ( ) ; }
tr	5	public list < task > sort ( final int colindex , final boolean sortdown ) { gettasks ( ) ; if ( colindex >= 0 && colindex <= 6 ) { collections . sort ( tasks , new comparator < task > ( ) { @ override public int compare ( task arg0 , task arg1 ) { int result = 0 ; if ( colindex == 1 || colindex == 2 || colindex == 3 || colindex == 5 || colindex == 6 ) { stringcomparer stringcomparator = new stringcomparer ( sortdown ) ; result = comparer ( stringcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 0 ) { integercomparer intcomparator = new integercomparer ( sortdown ) ; result = comparer ( intcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 4 ) { datecomparer datecomparator = new datecomparer ( sortdown ) ; result = comparer ( datecomparator , arg0 , arg1 , colindex ) ; } return result ; } } ) ; } else { throw new illegalargumentexception ( "invalid column index." ) ; } return tasks ; }
tr	1	public int getconfig ( int uid , int x , int y , int z ) { ground tile = groundarray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallobject != null && tile . wallobject . uid == uid ) return tile . wallobject . objconf & ff ; if ( tile . walldecoration != null && tile . walldecoration . uid == uid ) return tile . walldecoration . objconf & ff ; if ( tile . grounddecoration != null && tile . grounddecoration . uid == uid ) return tile . grounddecoration . objconf & ff ; for ( int e = 0 ; e < tile . entitycount ; e ++ ) if ( tile . interactiveobjects [ e ] . uid == uid ) return tile . interactiveobjects [ e ] . objconf & ff ; return - 1 ; }
tr	4	public static list < employee > load ( inputstream input ) { list < employee > employees = new arraylist < employee > ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( input ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) break ; string [ ] values = line . split ( " " ) ; employee employee = new employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { } } } }
tr	3	public static void main ( string [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; string s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = string . valueof ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = integer . parseint ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } system . out . println ( "# p = " + p ) ; }
tr	2	private arrayschema parsearrayschema ( jsonnode rawschema , url schemalocation ) { arrayschema result = new arrayschema ( ) ; jsonnode rawitems = rawschema . get ( "items" ) ; if ( rawitems != null ) { result . setitems ( parse ( rawitems , schemalocation ) ) ; } jsonnode rawminitems = rawschema . get ( "minitems" ) ; if ( rawminitems != null ) { result . setminitems ( rawminitems . intvalue ( ) ) ; } jsonnode rawmaxitems = rawschema . get ( "maxitems" ) ; if ( rawmaxitems != null ) { result . setmaxitems ( rawmaxitems . intvalue ( ) ) ; } return result ; }
tr	4	public void put ( string key , mqttpersistable message ) throws mqttpersistenceexception { checkisopen ( ) ; file file = new file ( clientdir , key + message_file_extension ) ; file backupfile = new file ( clientdir , key + message_file_extension + message_backup_file_extension ) ; if ( file . exists ( ) ) { boolean result = file . renameto ( backupfile ) ; if ( ! result ) { backupfile . delete ( ) ; file . renameto ( backupfile ) ; } } try { fileoutputstream fos = new fileoutputstream ( file ) ; fos . write ( message . getheaderbytes ( ) , message . getheaderoffset ( ) , message . getheaderlength ( ) ) ; if ( message . getpayloadbytes ( ) != null ) { fos . write ( message . getpayloadbytes ( ) , message . getpayloadoffset ( ) , message . getpayloadlength ( ) ) ; } fos . getfd ( ) . sync ( ) ; fos . close ( ) ; if ( backupfile . exists ( ) ) { backupfile . delete ( ) ; } } catch ( ioexception ex ) { throw new mqttpersistenceexception ( ex ) ; } finally { if ( backupfile . exists ( ) ) { boolean result = backupfile . renameto ( file ) ; if ( ! result ) { file . delete ( ) ; backupfile . renameto ( file ) ; } } } }
tr	1	public tacticbutton ( string stext , imageicon sicon ) { super ( null ) ; addmouselistener ( mouselistener ) ; strategylabel = new jlabel ( stext . replace ( _ ,   ) , sicon , jlabel . center ) ; strategylabel . setforeground ( color . white ) ; strategylabel . setbounds ( 0 , 0 , 120 , 41 ) ; strategylabel . sethorizontalalignment ( jlabel . center ) ; strategylabel . setverticalalignment ( jlabel . center ) ; add ( strategylabel ) ; dimension size = new dimension ( 145 , 49 ) ; setpreferredsize ( size ) ; setmaximumsize ( size ) ; }
tr	4	public double calscore ( query query , document doc ) { vector < string > qv = query . _tokens ; vector < string > doctokens = ( ( documentfull ) doc ) . getconvertedtitletokens ( ) ; doctokens . addall ( ( ( documentfull ) doc ) . getconvertedbodytokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( string querytoken : query . _tokens ) { for ( string doctoken : doctokens ) { if ( querytoken . equals ( doctoken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( doctokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( doctokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < doctokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( doctokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( doctokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	1	private void writeoutput ( datacontroller datacontroller , schedule schedule ) { outputformat outputformat = mapoutputformat ( parameters . get ( "format" ) ) ; protocol . log ( "ausgabeformat: " + outputformat ) ; string outputdirectory = parameters . get ( "out" ) ; protocol . log ( "ausgabeverzeichnis: " + outputdirectory ) ; outputcontroller outputcontroller = new outputcontroller ( ) ; list < scheduleview > scheduleviews = schedule . getallscheduleviews ( datacontroller . getrooms ( ) , datacontroller . getacademics ( ) , datacontroller . getstudyprograms ( ) ) ; outputcontroller . outputschedules ( scheduleviews , outputformat , outputdirectory ) ; }
tr	5	@ override protected void process ( ) { stringtokenizer t = new stringtokenizer ( filel . getliststring ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasmoretokens ( ) ; files ++ ) { string s = t . nexttoken ( ) ; string title = print . titlestring ( "--" , s ) ; if ( showallfiles ) { print . ln ( title ) ; title = null ; } int i = 0 ; try ( bufferedreader in = new bufferedreader ( new filereader ( s ) ) ) { for ( int line = 1 ; ( s = in . readline ( ) ) != null ; line ++ ) if ( fnamefilter . accept ( s ) ) { if ( title != null ) { print . ln ( title ) ; title = null ; } print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( ioexception ioe ) { sys . warning ( ioe . tostring ( ) ) ; } if ( i > 0 || showallfiles ) { print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } print . ln ( print . separator ( "==========================" ) ) ; print . ln ( "totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	2	private static void loadconfig ( ) { vmconfiguration . config = new vmconfiguration ( ) ; inputstream conf_file ; try { conf_file = new fileinputstream ( new file ( conf_file ) ) ; properties props = new properties ( ) ; props . load ( conf_file ) ; config . weightnumber = integer . parseint ( props . getproperty ( constants . weight_number ) ) ; config . learnfilename = props . getproperty ( constants . learn_file_name ) ; config . topologymodeltype = props . getproperty ( constants . topology_model ) ; config . rows = integer . parseint ( props . getproperty ( constants . rows ) ) ; config . cols = integer . parseint ( props . getproperty ( constants . cols ) ) ; config . radius = integer . parseint ( props . getproperty ( constants . radius ) ) ; config . numberofweights = integer . parseint ( props . getproperty ( constants . number_of_weights ) ) ; config . maxweight = integer . parseint ( props . getproperty ( constants . max_weight ) ) ; config . maxiteration = integer . parseint ( props . getproperty ( constants . max_iteration ) ) ; config . trainmetrictype = props . getproperty ( constants . train_metric_type ) ; config . predictmetrictype = props . getproperty ( constants . predict_metric_type ) ; config . learningfactor = integer . parseint ( props . getproperty ( constants . learn_factor ) ) ; config . neighbourfactor = double . parsedouble ( props . getproperty ( constants . neighbour_factor ) ) ; config . kfoldvalue = integer . parseint ( props . getproperty ( constants . k_fold_value ) ) ; config . delimiter = props . getproperty ( constants . delimiter ) ; config . pythonfilelocation = props . getproperty ( constants . python_file ) ; config . normalizedfilename = props . getproperty ( constants . normalized_file ) ; config . normalneurons = integer . parseint ( props . getproperty ( constants . normal_neurons ) ) ; config . predictdatafile = props . getproperty ( constants . predict_data_file ) ; config . lookaheadsize = integer . parseint ( props . getproperty ( constants . look_ahead_size ) ) ; config . predictaheadstep = integer . parseint ( props . getproperty ( constants . predict_ahead_step ) ) ; config . gaussianheight = integer . parseint ( props . getproperty ( constants . gaussian_height ) ) ; config . mem_log_file = props . getproperty ( constants . mem_log_file ) ; config . metric_log_file = props . getproperty ( constants . metric_log_file ) ; config . train_mem_log_file = props . getproperty ( constants . train_mem_log_file ) ; config . train_metric_log_file = props . getproperty ( constants . train_metric_log_file ) ; config . dotest = integer . parseint ( props . getproperty ( constants . do_test ) ) ; config . vm_name = props . getproperty ( constants . vm_name ) ; config . predictfile = props . getproperty ( constants . predict_file ) ; config . annotatefile = props . getproperty ( constants . ann_file ) ; config . faultinterval = integer . parseint ( props . getproperty ( constants . fault ) ) ; } catch ( filenotfoundexception e ) { logger . error ( "error while opening configuration file" ) ; } catch ( ioexception e ) { logger . error ( "error while loading configuration file" ) ; } }
tr	5	private void init ( ) { drawablepanel = new drawablepanel ( ) ; swinglistener listener = new swinglistener ( this ) ; tracer . addlisteners ( listener ) ; jbutton renderbtn = new jbutton ( "render" ) ; renderbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { progressbar . setstring ( null ) ; new thread ( ) { @ override public void run ( ) { tracer . render ( scene , viewplane ) ; } } . start ( ) ; } } ) ; jpanel statuspanel = new jpanel ( new flowlayout ( flowlayout . center , 5 , 5 ) ) ; progressbar . setvalue ( 0 ) ; progressbar . setstringpainted ( true ) ; statuspanel . add ( progressbar ) ; jscrollpane scrollpane = new jscrollpane ( drawablepanel ) ; add ( statuspanel , borderlayout . page_end ) ; add ( scrollpane , borderlayout . center ) ; add ( renderbtn , borderlayout . page_start ) ; }
tr	5	public void sortby ( string order ) { defaultmutabletreenode tmpnode = null ; defaultmutabletreenode curnodecopy = null ; sorttreemodel treemodeltmp = null ; defaultmutabletreenode roottmp = new defaultmutabletreenode ( rootnodetxt ) ; if ( order . equals ( "name" ) ) { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatorname ( ) ) ; sortedbyname = true ; } else { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatordate ( ) ) ; sortedbyname = false ; } sortbynamemenuitem . setenabled ( ! sortedbyname ) ; sortbydatemenuitem . setenabled ( sortedbyname ) ; for ( @ suppresswarnings ( "rawtypes" ) enumeration e = ( ( defaultmutabletreenode ) treemodel . getroot ( ) ) . breadthfirstenumeration ( ) ; e . hasmoreelements ( ) ; ) { defaultmutabletreenode curnode = ( defaultmutabletreenode ) e . nextelement ( ) ; object obj = curnode . getuserobject ( ) ; if ( obj instanceof item ) { item currentitem = ( item ) obj ; if ( currentitem . isdir ( ) ) curnodecopy = new foldernode ( currentitem ) ; else curnodecopy = new leafnode ( currentitem , ( ( leafnode ) curnode ) . getdownperc ( ) , ( ( leafnode ) curnode ) . getstatus ( ) ) ; object objpar = ( ( defaultmutabletreenode ) curnode . getparent ( ) ) . getuserobject ( ) ; if ( objpar instanceof item ) { if ( ( tmpnode = getitemintree ( ( item ) objpar , treemodeltmp ) ) != null ) { treemodeltmp . insertnodeinto ( curnodecopy , tmpnode ) ; } } else { treemodeltmp . insertnodeinto ( curnodecopy , roottmp ) ; } } } rootnode = roottmp ; treemodel = treemodeltmp ; tree . setmodel ( treemodel ) ; }
tr	5	public static map < string , boolean > getallchildren ( final string node , final set < string > playerpermarray ) { final linkedlist < string > stack = new linkedlist < string > ( ) ; final map < string , boolean > alreadyvisited = new hashmap < string , boolean > ( ) ; stack . push ( node ) ; alreadyvisited . put ( node , true ) ; while ( ! stack . isempty ( ) ) { final string now = stack . pop ( ) ; final map < string , boolean > children = adminperms . getchildren ( now ) ; if ( children != null && ! playerpermarray . contains ( "-" + now ) ) { for ( final string childname : children . keyset ( ) ) { if ( ! alreadyvisited . containskey ( childname ) ) { stack . push ( childname ) ; alreadyvisited . put ( childname , children . get ( childname ) ) ; } } } } alreadyvisited . remove ( node ) ; if ( ! alreadyvisited . isempty ( ) ) { return alreadyvisited ; } return null ; }
tr	4	@ suppresswarnings ( "unchecked" ) @ transactional public list < merchant > getmerchantlist ( string merchantname , string sortby , string sortorder ) throws exception { list < merchant > lstmerchants = new arraylist < merchant > ( ) ; session session = null ; criteria criteriaobj = null ; logger . info ( "merchantname---------->" + merchantname ) ; logger . info ( "sortby--------------->" + sortby ) ; logger . info ( "sortorder------------>" + sortorder ) ; string sname = merchantname ; try { session = sessionfactory . getcurrentsession ( ) ; logger . info ( "entered into getmerchantlist()--->" ) ; logger . info ( "retrieving all merchants" ) ; if ( session != null ) { criteriaobj = session . createcriteria ( merchant . class ) ; if ( merchantname != null ) { logger . info ( "retrieving  merchants based on name" ) ; criteriaobj . add ( restrictions . ilike ( "sname" , "%" + sname + "%" ) ) ; criteriaobj . add ( restrictions . = ( "bdeletedflag" , false ) ) ; } lstmerchants = criteriaobj . list ( ) ; logger . info ( "lstmerchants from dao----------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "asc" ) { logger . info ( "retrieving  merchants based on ascending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . asc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "desc" ) { logger . info ( "retrieving  merchants based on descending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . desc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } iterator < merchant > it = lstmerchants . iterator ( ) ; while ( it . hasnext ( ) ) { merchant merchant = it . next ( ) ; system . out . println ( "dao......." + merchant ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; logger . error ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; throw new exception ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; } return lstmerchants ; }
tr	3	@ override public void handlecommand ( commandmessage m ) { string [ ] args = m . getargs ( ) ; if ( args . length == 1 ) { string nick = m . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containskey ( args [ 1 ] ) ) { ph . sendmessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deletecharat ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . tostring ( ) ) ; try { ph . savedata ( pozdravy ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . savedata ( pozdravy ) ; ph . sendmessage ( "pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else { ph . sendmessage ( this . help ( ph . getprefix ( ) ) ) ; } }
tr	2	public static string strfill ( string fillstr , string oldstr , int length , string place ) { stringbuffer sb = new stringbuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldstr ) ; } for ( int i = 0 ; i < ( length - oldstr . length ( ) ) ; i ++ ) { sb . append ( fillstr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldstr ) ; } return sb . tostring ( ) ; }
tr	2	public static void main ( string [ ] args ) { pricesinfo pricesinfo = new pricesinfo ( ) ; reader [ ] readers = new reader [ 5 ] ; thread [ ] threadsreader = new thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new reader ( pricesinfo ) ; threadsreader [ i ] = new thread ( readers [ i ] ) ; } writer writer = new writer ( pricesinfo ) ; thread threadwriter = new thread ( writer ) ; for ( thread thread : threadsreader ) { thread . start ( ) ; } threadwriter . start ( ) ; }
tr	5	public void actionperformed ( actionevent e ) { if ( gridbutton . class . isinstance ( e . getsource ( ) ) ) { gridbutton b = ( gridbutton ) e . getsource ( ) ; switch ( b . getcolumn ( ) ) { case ( 0 ) : { client . openfile ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } case ( 1 ) : { int n = joptionpane . showconfirmdialog ( this , "delete " + networkfiles . get ( b . getrow ( ) ) + " from the network?" , "are you sure?" , joptionpane . yes_no_option ) ; if ( n == 0 ) client . deletefilefromnetwork ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } case ( 2 ) : { int n = joptionpane . showconfirmdialog ( this , "delete " + networkfiles . get ( b . getrow ( ) ) + " locally?" , "are you sure?" , joptionpane . yes_no_option ) ; if ( n == 0 ) client . deletelocalfile ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } default : { break ; } } } else if ( jbutton . class . isinstance ( e . getsource ( ) ) ) { jbutton b = ( jbutton ) e . getsource ( ) ; if ( b == loginbutton ) { this . updatestatuslabel ( "logging into the system. please wait..." ) ; client . loginsystem ( ) ; } else if ( b == logoutbutton ) { this . updatestatuslabel ( "logging out the system. please wait..." ) ; logoutstatuswindow = new logoutstatuswindow ( this ) ; new thread ( new runnable ( ) { @ override public void run ( ) { client . logoutsystem ( ) ; } } ) . start ( ) ; } else if ( b == addfilebutton ) { if ( client . getsessionstate ( ) ) { int returnvalue = filechooser . showopendialog ( this ) ; if ( returnvalue == jfilechooser . approve_option ) { client . importfile ( filechooser . getselectedfile ( ) ) ; } } } else if ( b == infobutton ) { linkednodeswindow l = new linkednodeswindow ( this ) ; client . testprintownerfiles ( ) ; } else if ( b == settingsbutton ) { settingswindow s = new settingswindow ( this ) ; } } }
tr	2	private void switchmap ( stairtile stairs ) { point oldpt = stairs . getpa ( ) ; point nextpt = stairs . getpb ( ) ; map nextmap = stairs . getmapb ( ) ; tile nextlocation = nextmap . gettile ( nextpt . x , nextpt . y ) ; player . setlocation ( nextlocation ) ; stairs . getmapa ( ) . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; stairs . getmapb ( ) . gettile ( nextpt . x , nextpt . y ) . setoccupant ( player ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( false ) ; this . map = nextmap ; messenger . drawmap ( nextmap ) ; messenger . updatetile ( nextpt ) ; resettimequeue ( ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( true ) ; if ( nextmap . gettag ( ) != null ) { messenger . showtextdialog ( gametext . gettext ( nextmap . gettag ( ) ) , nextmap . gettag ( ) ) ; player . settextcollected ( player . gettextcollected ( ) + 1 ) ; nextmap . settag ( null ) ; } messenger . centermap ( nextpt ) ; }
tr	1	private void createaroundvertex ( point p ) { addvertex ( p , getrandomname ( ) ) ; point p1 = new point ( p . x - 1 , p . y - 1 ) ; point p2 = new point ( p . x , p . y - 1 ) ; point p3 = new point ( p . x + 1 , p . y - 1 ) ; point p4 = new point ( p . x + 1 , p . y ) ; point p5 = new point ( p . x - 1 , p . y ) ; point p6 = new point ( p . x , p . y + 1 ) ; point p7 = new point ( p . x + 1 , p . y + 1 ) ; point p8 = new point ( p . x - 1 , p . y + 1 ) ; addvertex ( p1 , getrandomname ( ) ) ; addvertex ( p2 , getrandomname ( ) ) ; addvertex ( p3 , getrandomname ( ) ) ; addvertex ( p4 , getrandomname ( ) ) ; addvertex ( p5 , getrandomname ( ) ) ; addvertex ( p6 , getrandomname ( ) ) ; addvertex ( p7 , getrandomname ( ) ) ; addvertex ( p8 , getrandomname ( ) ) ; addedge ( p , p1 , 1 ) ; addedge ( p , p2 , 1 ) ; addedge ( p , p3 , 1 ) ; addedge ( p , p4 , 1 ) ; addedge ( p , p5 , 1 ) ; addedge ( p , p6 , 1 ) ; addedge ( p , p7 , 1 ) ; addedge ( p , p8 , 1 ) ; }
tr	2	public static void main ( string [ ] args ) { treeset < integer > set2 = new treeset < integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; arraylist < treeset < integer >> totalsubsets = findsubsets ( set2 , 0 ) ; if ( totalsubsets == null ) system . out . println ( "no possible subsets" ) ; else for ( treeset < integer > ts : totalsubsets ) { system . out . println ( ts ) ; } }
tr	2	public void switchfullscreen ( ) { if ( fullscreen == false ) { throw new illegalstateexception ( "this window not supports fullscreen mode!" ) ; } if ( state == windowstate . window ) { rectangle rc = this . getbounds ( ) ; boolean resizable = this . isresizable ( ) ; this . properties = new frameproperties ( getx ( ) , gety ( ) , ( int ) rc . getwidth ( ) , ( int ) rc . getheight ( ) , resizable ) ; } if ( device . getfullscreenwindow ( ) == null ) { frameproperties properties = new frameproperties ( 0 , 0 , getfullwidth ( ) , getfullheight ( ) , false ) ; this . setextendedstate ( jframe . maximized_both ) ; this . state = windowstate . fullscreen ; properties . append ( this ) ; device . setfullscreenwindow ( this ) ; updatedisplay ( ) ; return ; } device . setfullscreenwindow ( null ) ; this . setextendedstate ( jframe . normal ) ; this . state = windowstate . window ; properties . append ( this ) ; updatedisplay ( ) ; }
tr	1	public point calculateorigin ( ) { point2d plb = this . container . getleftbottomvertex ( ) ; point2d location = this . getblkcoordinate ( ) ; int sqsize = this . container . getsquaresize ( ) ; int blkx = ( int ) plb . getx ( ) ; blkx = blkx + sqsize * ( ( int ) location . getx ( ) - 1 ) ; int blky = ( int ) plb . gety ( ) ; blky = blky - sqsize * ( ( int ) location . gety ( ) - 1 ) ; return new point ( blkx , blky ) ; }
tr	1	private void addtabs ( ) { addproduct = new viewaddproviderpanel ( adminprovider ) ; modifyprovidertable = new viewmodifyprovidertablepanel ( adminprovider ) ; modifyprovider = new viewmodifyproviderpanel ( adminprovider ) ; modifyprovidertable . settabs ( tabs ) ; modifyprovidertable . setswitchpanel ( modifyprovider ) ; modifyprovidertable . setname ( "modificar proveedor" ) ; modifyprovider . settabs ( tabs ) ; modifyprovider . setswitchpanel ( modifyprovidertable ) ; modifyprovider . setname ( "modificar proveedor" ) ; removeprovidertable = new viewremoveprovidertablepanel ( adminprovider ) ; removeprovider = new viewremoveproviderpanel ( adminprovider ) ; removeprovidertable . settabs ( tabs ) ; removeprovidertable . setswitchpanel ( removeprovider ) ; removeprovidertable . setname ( "eliminar proveedor" ) ; removeprovider . settabs ( tabs ) ; removeprovider . setswitchpanel ( removeprovidertable ) ; removeprovider . setname ( "eliminar proveedor" ) ; tabs . addtab ( "agregar proveedor" , addproduct ) ; tabs . setmnemonicat ( 0 , keyevent . vk_1 ) ; tabs . addtab ( "modificar proveedor" , modifyprovidertable ) ; tabs . addtab ( "eliminar proveedor" , removeprovidertable ) ; pack ( ) ; }
tr	4	public static void main ( string [ ] args ) throws ioexception { scanner in = new scanner ( system . in ) ; byte p1 = 3 ; int p1guess ; int p1taken ; byte p2 = 3 ; int p2guess ; int p2taken ; boolean p1turn = true ; byte round = 0 ; system . out . println ( "stone game" ) ; while ( p1 > 0 && p2 > 0 ) { system . out . println ( "------------------" ) ; system . out . println ( "round: " + ++ round ) ; system . out . println ( " you have " + p1 + " stones; cpu has " + p2 + " stones" ) ; system . out . println ( " how much stones you're taking: " ) ; do p1taken = in . nextint ( ) ; while ( p1taken > p1 || p1taken < 0 ) ; p2taken = game . randint ( 0 , p2 ) ; if ( p1turn ) { system . out . println ( " your guess is: " ) ; p1guess = in . nextint ( ) ; do { int rand_min = p1guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2guess = game . randint ( rand_min , p1 + p2 ) ; } while ( p2guess == p1guess ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; } else { p2guess = game . randint ( p2taken , p2taken + p1 ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; system . out . println ( " your guess is: " ) ; do p1guess = in . nextint ( ) ; while ( p1guess == p2guess ) ; } system . out . println ( "we took: " + p1taken + " p2 took: " + p2taken + " stones" ) ; if ( p1guess == ( p1taken + p2taken ) ) { system . out . println ( "we won " + round + ". round" ) ; -- p1 ; p1turn = true ; } else if ( p2guess == ( p1taken + p2taken ) ) { system . out . println ( "cpu won " + round + ". round" ) ; -- p2 ; p1turn = false ; } else p1turn = ! p1turn ; } system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) system . out . println ( "player 1 has won" ) ; else system . out . println ( "cpu has won" ) ; system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	2	public static void main ( string [ ] args ) throws ioexception , interruptedexception { webcam webcam = webcam . getdefault ( ) ; webcam . setviewsize ( new dimension ( 640 , 480 ) ) ; webcam . open ( ) ; jframe troll = new jframe ( ) ; jlabel boy = new jlabel ( ) ; troll . add ( boy ) ; boy . setpreferredsize ( new dimension ( 640 , 480 ) ) ; troll . pack ( ) ; troll . setresizable ( false ) ; troll . setdefaultcloseoperation ( jframe . exit_on_close ) ; troll . setvisible ( true ) ; while ( true ) { boy . seticon ( new imageicon ( webcam . getimage ( ) ) ) ; } }
tr	4	public double getdistanceab ( arraylist < object > path ) { arraylist < object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new arraylist < object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( road road : roads ) { if ( road . getnodesattached ( ) . containsall ( nodes ) ) { distance += road . getdistance ( ) ; } } } distance = utilcalc . round ( distance , 2 ) ; return distance ; }
tr	2	public static boolean updatekurssi ( kurssi kurssi ) { connection con = connect ( ) ; try { preparedstatement updatekurssi = con . preparestatement ( "update kurssi set nimi=? where kurssiid=?" ) ; updatekurssi . setstring ( 1 , kurssi . getnimi ( ) ) ; updatekurssi . setint ( 2 , kurssi . getid ( ) ) ; updatekurssi . executeupdate ( ) ; return true ; } catch ( sqlexception ex ) { logger . getlogger ( database . class . getname ( ) ) . log ( level . severe , null , ex ) ; return false ; } finally { closeconnection ( con ) ; } }
tr	3	public string checkdataentry ( ) { if ( efastanalysispanel1 . parameterscreen . directorychosen . gettext ( ) . equals ( "selected directory: " ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) . equals ( "" ) || efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) . equals ( "" ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . parametersmodel . contains ( "none entered" ) ) { return "no parameters have been selected" ; } else { try { integer . parseint ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) ) ; integer . parseint ( efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) ) ; return null ; } catch ( numberformatexception e ) { return "number of curves and parameter samples must be integers" ; } } }
tr	5	public void run ( ) throws parsingexception { parsestack . push ( new terminalentry ( eof ) ) ; parsestack . addtoparsestack ( ruletable . find ( startsymbol , starttoken ) ) ; a = parsestack . peek ( ) ; getnexttoken ( ) ; while ( ( a != null ) && ! a . iseof ( ) ) { a = parsestack . peek ( ) ; if ( a . isterminal ( ) ) { if ( a . matches ( i ) ) { parsestack . pop ( ) ; if ( parsestack . notempty ( ) ) { a = parsestack . peek ( ) ; getnexttoken ( ) ; } } else { throw new parsingexception ( "terminal mismatch. expected: " + a + " found: " + i + "" ) ; } } else if ( a . issemanticentry ( ) ) { final semanticnode node = nodefactory . getnewnode ( a ) ; node . runonsemanticstack ( semanticstack ) ; parsestack . pop ( ) ; } else { if ( isrulecontained ( a , i ) ) { parsestack . pop ( ) ; parsestack . addtoparsestack ( ruletable . find ( a , i ) ) ; a = parsestack . peek ( ) ; } else { throw new parsingexception ( "non-terminal mismatch. no entry in the table for: " + a + "   " + i ) ; } } } if ( ! stream . isempty ( ) ) { throw new parsingexception ( "parser found the end of file marker but the token stream was not empty." ) ; } }
tr	4	public object getvalueat ( object node , int column ) { filenode fn = ( filenode ) node ; try { switch ( column ) { case 0 : return fn . getfile ( ) . getname ( ) ; case 1 : if ( fn . istotalsizevalid ( ) ) { return new integer ( ( int ) ( ( filenode ) node ) . totalsize ( ) ) ; } return null ; case 2 : return fn . isleaf ( ) ? "file" : "directory" ; case 3 : return fn . lastmodified ( ) ; } } catch ( securityexception se ) { } return null ; }
tr	2	public static boolean invertm ( float [ ] minv , int minvoffset , float [ ] m , int moffset ) { final float src0 = m [ moffset + 0 ] ; final float src4 = m [ moffset + 1 ] ; final float src8 = m [ moffset + 2 ] ; final float src12 = m [ moffset + 3 ] ; final float src1 = m [ moffset + 4 ] ; final float src5 = m [ moffset + 5 ] ; final float src9 = m [ moffset + 6 ] ; final float src13 = m [ moffset + 7 ] ; final float src2 = m [ moffset + 8 ] ; final float src6 = m [ moffset + 9 ] ; final float src10 = m [ moffset + 10 ] ; final float src14 = m [ moffset + 11 ] ; final float src3 = m [ moffset + 12 ] ; final float src7 = m [ moffset + 13 ] ; final float src11 = m [ moffset + 14 ] ; final float src15 = m [ moffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; minv [ minvoffset ] = dst0 * invdet ; minv [ 1 + minvoffset ] = dst1 * invdet ; minv [ 2 + minvoffset ] = dst2 * invdet ; minv [ 3 + minvoffset ] = dst3 * invdet ; minv [ 4 + minvoffset ] = dst4 * invdet ; minv [ 5 + minvoffset ] = dst5 * invdet ; minv [ 6 + minvoffset ] = dst6 * invdet ; minv [ 7 + minvoffset ] = dst7 * invdet ; minv [ 8 + minvoffset ] = dst8 * invdet ; minv [ 9 + minvoffset ] = dst9 * invdet ; minv [ 10 + minvoffset ] = dst10 * invdet ; minv [ 11 + minvoffset ] = dst11 * invdet ; minv [ 12 + minvoffset ] = dst12 * invdet ; minv [ 13 + minvoffset ] = dst13 * invdet ; minv [ 14 + minvoffset ] = dst14 * invdet ; minv [ 15 + minvoffset ] = dst15 * invdet ; return true ; }
tr	3	public boolean iscallablereference ( class clazz ) { if ( this == globalbridge ) { return false ; } if ( ! referencesenabled ) { return false ; } if ( callablereferenceset . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getinterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callablereferenceset . contains ( interfaces [ i ] ) ) { return true ; } } class superclass = clazz . getsuperclass ( ) ; while ( superclass != null ) { if ( callablereferenceset . contains ( superclass ) ) { return true ; } superclass = superclass . getsuperclass ( ) ; } return globalbridge . iscallablereference ( clazz ) ; }
tr	5	public file getfilechoice ( component parent ) { if ( chooser . showsavedialog ( parent ) == jfilechooser . approve_option ) { file newfile = chooser . getselectedfile ( ) ; if ( chooser . getfilefilter ( ) == zipfilter ) { if ( ! newfile . getname ( ) . touppercase ( ) . endswith ( ".zip" ) ) { newfile = new file ( newfile . getabsolutefile ( ) + ".zip" ) ; } } if ( newfile . exists ( ) ) { int confirmchoice = joptionpane . showconfirmdialog ( parent , "file already exists. do you want to replace it?" ) ; if ( confirmchoice == joptionpane . yes_option ) { newfile . delete ( ) ; } else if ( confirmchoice == joptionpane . no_option ) { return getfilechoice ( parent ) ; } else { return null ; } } if ( ! newfile . exists ( ) ) { boolean filecreated = false ; try { filecreated = newfile . createnewfile ( ) ; } catch ( exception e ) { } finally { if ( ! filecreated ) { joptionpane . showmessagedialog ( parent , "an error occurred" ) ; return null ; } } } return newfile ; } else { return null ; } }
tr	3	public int [ ] getactions ( game game , long timedue ) { int pacmanloc = game . getcurpacmanloc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostrequiresaction ( i ) ) { if ( iscrowded ( game ) && ! closetomspacman ( game , game . getcurghostloc ( i ) ) ) dirs [ i ] = getretreatactions ( game , i ) ; else if ( game . getedibletime ( i ) > 0 || closetopower ( game ) ) dirs [ i ] = game . getnextghostdir ( i , pacmanloc , false , game . dm . path ) ; else dirs [ i ] = game . getnextghostdir ( i , pacmanloc , true , game . dm . path ) ; } } return dirs ; }
tr	3	public static string readfile ( string filepath ) throws filenotexistexception { file file = new file ( filepath ) ; stringbuilder builder = new stringbuilder ( ) ; if ( ! file . exists ( ) ) { throw new filenotexistexception ( filepath ) ; } try { bufferedreader buffer = new bufferedreader ( new filereader ( file ) ) ; string tmp = buffer . readline ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readline ( ) ; if ( tmp != null ) builder . append ( 
 ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return builder . tostring ( ) ; }
tr	3	@ override public void init ( ) { qidtf = new jtextfield ( ) ; label = new jlabel ( ) ; setlayout ( new borderlayout ( ) ) ; add ( "north" , new jlabel ( "quest id" ) ) ; add ( "center" , qidtf ) ; add ( "south" , label ) ; label . setforeground ( color . red ) ; qidtf . getdocument ( ) . adddocumentlistener ( new questexistslistener ( getfinishbutton ( ) ) { public boolean update ( documentevent e ) { boolean a = super . update ( e ) ; if ( a == false ) label . settext ( "this quest doesn't exist." ) ; else label . settext ( "" ) ; return a ; } } ) ; }
tr	2	private void listsolicitudesmouseclicked ( java . awt . event . mouseevent evt ) { int no ; no = listsolicitudes . getselectedindex ( ) ; int reply = joptionpane . showconfirmdialog ( null , "desea agregara a " + listas . get ( no - 1 ) . nombre + "(" + listas . get ( no - 1 ) . usuario + ")" , "solicitud de amistad" , joptionpane . yes_no_option ) ; string resp = "<solicitud_amistad>\n" ; if ( reply == joptionpane . yes_option ) { resp += "<respuesta> si </respuesta>\n" ; } else { resp += "<respuesta> no </respuesta>\n" ; } usuario usuario = servidor . getusuario ( txtuser . gettext ( ) ) ; resp += "<destinatario>" + listas . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + txtuser . gettext ( ) + "</usuario>\n" + "<nombre> " + usuario . getnombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listas . remove ( no - 1 ) ; listsolicitudes . updateui ( ) ; servidor . actualizarsolicitudes2 ( listas , usuario . getusername ( ) ) ; writeutf ( resp ) ; listsolicitudes . repaint ( ) ; system . err . println ( resp ) ; }
tr	5	public string [ ] searchlogin ( javax . swing . jtextfield jtextfield1 , javax . swing . jpasswordfield jpasswordfield1 ) { string checklogin = "" ; string name = "" ; for ( arraylist < string > user : aldata ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jtextfield1 . gettext ( ) . equals ( user . get ( j ) ) ) { char [ ] cpassword = jpasswordfield1 . getpassword ( ) ; string spassword = string . valueof ( cpassword ) ; if ( spassword . equals ( user . get ( j + 1 ) ) ) { system . out . println ( "login efetuado com sucesso!" ) ; checklogin = user . get ( 0 ) ; name = user . get ( 3 ) ; system . out . println ( "bem vindo" + name ) ; } } } } if ( "" . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; system . out . println ( "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; } tring data = tring . clone ( checklogin ) ; if ( data . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , parsedfile ) ; system . out . println ( "error - file does not exist" ) ; } return new string [ ] { checklogin , name } ; }
tr	2	public static privatekey readprivatekeyfromder ( string filename ) { try { inputstream fl = fullstream ( filename ) ; byte [ ] key = new byte [ fl . available ( ) ] ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; pkcs8encodedkeyspec keysp = new pkcs8encodedkeyspec ( key ) ; privatekey privk = kf . generateprivate ( keysp ) ; return privk ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	3	public string getpinyincolorized ( ) { stringbuilder ankipinyin = new stringbuilder ( ) ; string [ ] syllables = pinyinutil . getsyllables ( pinyin ) ; int curtone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankipinyin . append ( " " ) ; } curtone = gettone ( syllables [ i ] ) ; if ( curtone == 0 ) { ankipinyin . append ( syllables [ i ] ) ; } else { ankipinyin . append ( "<span style = \"color:" ) ; ankipinyin . append ( tonecolor [ curtone ] ) ; ankipinyin . append ( "\">" ) ; ankipinyin . append ( pinyinutil . tounicode ( syllables [ i ] ) ) ; ankipinyin . append ( "</span>" ) ; } } return ankipinyin . tostring ( ) ; }
tr	2	static list < vcscommit > parsecommits ( string xml ) { try { commitreadinghandler commitreadinghandler = new commitreadinghandler ( ) ; saxparserfactory parserfactory = saxparserfactory . newinstance ( ) ; xmlreader xmlreader = parserfactory . newsaxparser ( ) . getxmlreader ( ) ; xmlreader . setcontenthandler ( commitreadinghandler ) ; xmlreader . parse ( new inputsource ( new stringreader ( xml ) ) ) ; return commitreadinghandler . commits ; } catch ( saxexception e ) { throw new runtimeexception ( "failed to parse xml: " + xml , e ) ; } catch ( parserconfigurationexception | ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	4	public synchronized void doranking ( ) { calculate_tf_idf_q ( ) ; query q ; for ( string term : queryterms . keyset ( ) ) { term = term . trim ( ) ; q = queryterms . get ( term ) ; q . setpostings ( getpostingsfor ( term ) ) ; if ( q . getpostings ( ) == null ) { system . out . println ( "sry. no postings found" ) ; continue ; } for ( posting p : q . getpostings ( ) . getpostings ( ) ) { float value = ( float ) ( q . gettf_idf ( ) * calculate_tf_idf_d ( p , q . getpostings ( ) . getoverallfrequency ( ) ) ) ; score s = new score ( ) ; s . setscore ( value ) ; s . setid ( p . getdocid ( ) ) ; if ( ! scores . containskey ( p . getdocid ( ) ) ) { scores . put ( p . getdocid ( ) , s ) ; } else { score sc = scores . get ( p . getdocid ( ) ) ; float score = sc . getscore ( ) ; score += value ; sc . setscore ( score ) ; scores . put ( p . getdocid ( ) , sc ) ; } } } float newscore , lengthv ; score s ; for ( string id : scores . keyset ( ) ) { s = scores . get ( id ) ; try { newscore = s . getscore ( ) / length . get ( id ) . floatvalue ( ) ; s . setscore ( newscore ) ; scores . put ( id , s ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }
tr	5	private objective loadobjective ( tagcompound tag ) { try { tagbase tbname = tag . gettag ( "name" ) ; if ( ! ( tbname instanceof tagstring ) ) return null ; tagbase tbtarget = tag . gettag ( "target" ) ; if ( ! ( tbtarget instanceof tagstring ) ) return null ; tagbase tbtypes = tag . gettag ( "type" ) ; if ( ! ( tbtypes instanceof tagstring ) ) return null ; objectivetype t = questmanager . getinstance ( ) . getregisteredobjectivetype ( ( ( tagstring ) tbtypes ) . data ) ; if ( t == null ) return null ; objective o = new objective ( tag . getname ( ) , ( ( tagstring ) tbname ) . data , t , ( ( tagstring ) tbtarget ) . data ) ; tagbase tbicoid = tag . gettag ( "iconid" ) ; if ( tbicoid instanceof tagint ) o . setitemiconid ( ( ( tagint ) tbicoid ) . data ) ; tagbase tbopt = tag . gettag ( "optional" ) ; if ( tbopt instanceof tagbyte ) o . setoptional ( ( ( tagbyte ) tbopt ) . data == 1 ) ; tagbase tbvis = tag . gettag ( "visible" ) ; if ( tbvis instanceof tagbyte ) o . setvisible ( ( ( tagbyte ) tbvis ) . data == 1 ) ; tagbase rewards = tag . gettag ( "rewards" ) ; if ( rewards instanceof taglist ) { for ( tagbase b : ( ( taglist ) rewards ) . get ( ) ) { if ( b instanceof tagcompound ) { questaction a = loadaction ( ( tagcompound ) b ) ; if ( a != null ) o . addreward ( a ) ; } } } tagbase desc = tag . gettag ( "description" ) ; arraylist < string > dsc = new arraylist < string > ( ) ; if ( desc instanceof taglist ) { for ( tagbase b : ( ( taglist ) desc ) . get ( ) ) { if ( b instanceof tagstring ) { dsc . add ( ( ( tagstring ) b ) . data ) ; } } } o . setdescription ( dsc ) ; return o ; } catch ( illegalargumentexception iae ) { return null ; } }
tr	2	private void flushmemorytable ( ) { changetableslock . lock ( ) ; try { memorytableaccessor . useauxiliary ( ) ; } finally { changetableslock . unlock ( ) ; } disktable disktable ; try { memorytable memorytable = memorytableaccessor . getmaindatatable ( ) ; path newtablefile = disktableaccessor . newpathfortable ( ) ; flusher flusher = new flusher ( newtablefile , disktableaccessor . blocksize ( ) ) ; system . out . println ( "node: info: flushing memory table to " + newtablefile ) ; disktable = flusher . flush ( memorytable , memorytable . timestamp ( ) ) ; } catch ( ioexception e ) { system . out . println ( "node: exception: " + e ) ; throw new runtimeexception ( e ) ; } changetableslock . lock ( ) ; try { disktableaccessor . adddisk ( disktable ) ; memorytableaccessor . stopusingauxiliary ( ) ; commitlog . reset ( ) ; } finally { changetableslock . unlock ( ) ; } }
tr	4	public static void main ( string [ ] args ) { utility . configure ( ) ; jobtrackercomm = new communication ( utility . jobtracker . ipaddress , utility . jobtracker . port ) ; system . out . println ( "registering on job tracker..." ) ; message msg = new message ( utility . tasktrackerreg ) ; jobtrackercomm . sendmessage ( msg ) ; msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . regack ) { tasktrackerid = msg . gettasktrackerid ( ) ; system . out . println ( "successfully registered." ) ; } while ( isrunning ) { msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . newjob ) { jobcontext jobcontext = msg . getjobcontext ( ) ; string jobid = jobcontext . getjobid ( ) . getid ( ) ; system . out . println ( "receiced new job from job[" + jobid + "] tracker" ) ; if ( ! jobcontexts . containskey ( jobid ) ) { jobcontexts . put ( jobid , jobcontext ) ; } msg = new message ( utility . newjoback ) ; jobtrackercomm . sendmessage ( msg ) ; } else if ( msg . getmsgtype ( ) == utility . runmapper ) { system . out . println ( "received runmapper command from job tracker." ) ; list < mapbasiccontext > mapbasiccontexts = msg . getmapcontexts ( ) ; if ( mapbasiccontexts . size ( ) != 0 ) { string jobid = mapbasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; nummappers = mapbasiccontexts . size ( ) ; launchmappers ( jobcontext , mapbasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . runreducer ) { system . out . println ( "received runreducer command from job tracker." ) ; list < reducebasiccontext > reducebasiccontexts = msg . getreducecontexts ( ) ; if ( reducebasiccontexts . size ( ) != 0 ) { string jobid = reducebasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; numreducers = reducebasiccontexts . size ( ) ; launchreducers ( jobcontext , reducebasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . close ) { isrunning = false ; } } jobtrackercomm . close ( ) ; }
tr	4	private void parsedocument ( int docnumber ) { element docele = docs . get ( docnumber ) . getdocumentelement ( ) ; nodelist nodelist = docele . getelementsbytagname ( "room" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( i ) ; string filename = el . gettextcontent ( ) ; parsexmlfile ( new file ( filename ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { element roomdocele = docs . get ( i ) . getdocumentelement ( ) ; nodelist roomnodelist = roomdocele . getelementsbytagname ( "room" ) ; if ( roomnodelist != null && roomnodelist . getlength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getlength ( ) ; j ++ ) { element roomelement = ( element ) roomnodelist . item ( j ) ; getroom ( roomelement ) ; } } } nodelist = docele . getelementsbytagname ( "connect" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( i ) ; getconnection ( el ) ; } } nodelist = docele . getelementsbytagname ( "player" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( 0 ) ; mc = getplayer ( el ) ; } } }
tr	4	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getx ( ) ; float y = waternodes . get ( i ) . physrect . gety ( ) ; float width = waternodes . get ( i ) . physrect . getwidth ( ) ; float height = waternodes . get ( i ) . physrect . getheight ( ) ; node leaf = getleaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x , y + height , block . water ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x + width , y , block . water ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x - width , y , block . water ) ; emptycell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getx ( ) ; float y = acidnodes . get ( i ) . physrect . gety ( ) ; float width = acidnodes . get ( i ) . physrect . getwidth ( ) ; float height = acidnodes . get ( i ) . physrect . getheight ( ) ; node leaf = getleaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x , y + height , block . acid ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x + width , y , block . acid ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x - width , y , block . acid ) ; emptycell ( x , y ) ; continue ; } } } }
tr	3	public static void create ( string [ ] args ) { vector < vslfiledatachunk > chunks = null ; if ( args . length < 3 ) { system . err . println ( "missings args: create <dbfile> <source>" ) ; system . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkfile ( source ) ; vsldatatype < vslfiledatachunk > filedata = new vsldatatype < vslfiledatachunk > ( ) ; stringtokenizer st = new stringtokenizer ( source , "/" ) ; string fname = "unset" ; while ( st . hasmoretokens ( ) ) { fname = st . nexttoken ( ) ; } filedata . setname ( fname ) ; for ( vslfiledatachunk chunk : chunks ) { filedata . addnewchunk ( chunk ) ; } core . addentry ( filedata ) ; core . debugshow ( ) ; core . save ( ) ; } catch ( exception e ) { system . err . println ( "caught exception: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	4	public polygon getpolygon ( string s_namecity ) { polygon polygontoreturn = new polygon ( ) ; for ( district district : model . getlistdistrict ( ) ) { for ( city city : district . getlistcity ( ) ) { if ( city . gets_name ( ) . equals ( s_namecity ) ) { int i_x = district . geti_x ( ) * model . geti_nbhorizontalsquareindistrict ( ) + city . geti_x ( ) + ( district . geti_y ( ) % 2 ) * model . geti_nbhorizontalsquareindistrict ( ) / 2 ; int i_y = district . geti_y ( ) * model . geti_nbverticalsquareindistrict ( ) + city . geti_y ( ) ; point point2d = new point ( i_x , i_y ) ; polygontoreturn . setpoint2d ( point2d ) ; polygontoreturn . setpoint3d ( convert2dto3d ( point2d ) ) ; return polygontoreturn ; } } } return polygontoreturn ; }
tr	1	@ override public void onsimulationdone ( simulationevent event ) { simulationfinalresult result = ( simulationfinalresult ) event . geteventdata ( ) ; double w0 = result . getwinpercentage ( 0 ) ; double l0 = result . getlosepercentage ( 0 ) ; double t0 = result . gettiepercentage ( 0 ) ; double w1 = result . getwinpercentage ( 1 ) ; double l1 = result . getlosepercentage ( 1 ) ; double t1 = result . gettiepercentage ( 1 ) ; double w2 = result . getwinpercentage ( 2 ) ; double l2 = result . getlosepercentage ( 2 ) ; double t2 = result . gettiepercentage ( 2 ) ; system . out . println ( "win 1: " + w0 ) ; system . out . println ( "lose 1: " + l0 ) ; system . out . println ( "tie 1: " + t0 ) ; system . out . println ( "win 2: " + w1 ) ; system . out . println ( "lose 2: " + l1 ) ; system . out . println ( "tie 2: " + t1 ) ; system . out . println ( "win 3: " + w2 ) ; system . out . println ( "lose 3: " + l2 ) ; system . out . println ( "tie 3: " + t2 ) ; long duration = result . getduration ( ) ; system . out . println ( "duration: " + duration + " ms" ) ; }
tr	3	public v checkbaseinterfaces ( class c ) { map < class , v > possibles = new hashmap < class , v > ( ) ; for ( class base = c ; base != object . class ; base = base . getsuperclass ( ) ) { for ( class itf : base . getinterfaces ( ) ) { v val = lookup . valat ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new runtimeexception ( "more thane one match for " + c ) ; } }
tr	5	public void sendpinmsg ( ) { message = msgs . gettext ( ) ; subject = subj . gettext ( ) ; httpclient hc = new httpclient ( ) ; hc . getconnectionstring ( ) ; if ( ! appfunctions . ntwkcon ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please check your network  pin broadcast requires bis or wifi" ) ; info . settext ( "check your network connection" ) ; } } ) ; } else if ( appfunctions . trialcount < 1 ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "you have exceeded the number of messages you can send. you have " + appfunctions . trialcount + " left. please buy more messages by selecting the 'buy pin message' menu for information on subscription. select 'verify account' on the menu after subscription to send more messages." ) ; info . settext ( "message number exceeded." ) ; } } ) ; } else if ( contactarray . size ( ) > appfunctions . trialcount ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "the contacts in your message exceeds what you have left (" + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) + "). please subscribe and select 'verify account' on the menu for unlimited contacts or reduce the number of your contacts to " + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . gettext ( ) . length ( ) < 2 || filesel == null ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please verify that from  subject  message and your contact file has been entered properly before sending this message." ) ; info . settext ( "error in message  please check again." ) ; } } ) ; } else { new thread ( sndmsg ) . start ( ) ; } } }
tr	5	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 1500 , 1000 ) ; frame . setlocationrelativeto ( null ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setvisible ( true ) ; final taskmgrgraph graph = new taskmgrgraph ( new taskmgrcolors ( ) ) ; new thread ( "memory thread" ) { @ override public void run ( ) { while ( true ) { runtime rt = runtime . getruntime ( ) ; long current = ( rt . totalmemory ( ) - rt . freememory ( ) ) / 1024 / 1024 ; long max = rt . totalmemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setmaximum ( ( int ) max ) ; graph . addvalue ( ( int ) current ) ; graph . settext ( current + " mb" ) ; system . out . println ( "current usage: " + current + "  maximum usage: " + max + "  percent: " + % ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } ; new thread ( "random thread" ) { @ override public void run ( ) { while ( true ) { graph . setmaximum ( 10000 ) ; int value = new random ( ) . nextint ( 10000 ) ; graph . addvalue ( value ) ; graph . settext ( value + "" ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	2	private void initblock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsgetuchar ( ) ; magic2 = bsgetuchar ( ) ; magic3 = bsgetuchar ( ) ; magic4 = bsgetuchar ( ) ; magic5 = bsgetuchar ( ) ; magic6 = bsgetuchar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badblockheader ( ) ; streamend = true ; return ; } storedblockcrc = bsgetint32 ( ) ; if ( bsr ( 1 ) == 1 ) { blockrandomised = true ; } else { blockrandomised = false ; } getandmovetofrontdecode ( ) ; mcrc . initialisecrc ( ) ; currentstate = start_block_state ; }
tr	3	public static void benchmark ( ) throws exception { int n = 100000 ; string [ ] methodstocompare = { "canwriteletterfrommagazine1" , "canwriteletterfrommagazine2" , "canwriteletterfrommagazine3" , "canwriteletterfrommagazine4" , "canwriteletterfrommagazine5" , "canwriteletterfrommagazine6" , "canwriteletterfrommagazine7" } ; string magazine = cleaninput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; string letter = cleaninput ( "hogs are swine" ) ; for ( string methodname : methodstocompare ) { class clazz = class . forname ( "book.chapter.twelve.problem12_09" ) ; method method = clazz . getdeclaredmethod ( methodname , string . class , string . class ) ; long starttime = system . nanotime ( ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean retval = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retval == false ) throw new exception ( "wrong result!" ) ; } long endtime = system . nanotime ( ) ; system . out . println ( "elapsed time for " + methodname + ": " + ( endtime - starttime ) / 1000000000.0 + " seconds" ) ; } }
tr	4	public boolean ismatching ( stringbuffer word , int wordpos ) { boolean matching = true , inmulti = false , multimatch = false ; char matchch ; for ( int matchpos = 0 ; matchpos < match . length ; matchpos ++ ) { matchch = match [ matchpos ] ; if ( matchch == startmulti || matchch == endmulti ) { inmulti = ! inmulti ; if ( ! inmulti ) matching = matching & multimatch ; else multimatch = false ; } else { if ( matchch != word . charat ( wordpos ) ) { if ( inmulti ) multimatch = multimatch | false ; else matching = false ; } else { if ( inmulti ) multimatch = multimatch | true ; else matching = true ; } if ( ! inmulti ) wordpos ++ ; if ( ! matching ) break ; } } if ( end && wordpos != word . length ( ) ) matching = false ; return matching ; }
tr	1	public evlassignfsm ( list < evlcomponent > components , evlstatement statement ) { this . components = components ; this . statement = statement ; initstate = new initstate ( this ) ; lhsstate = new lhsstate ( this ) ; lhsnamestate = new lhsnamestate ( this ) ; lhsbusstate = new lhsbusstate ( this ) ; lhsmsbstate = new lhsmsbstate ( this ) ; lhscolonstate = new lhscolonstate ( this ) ; lhslsbstate = new lhslsbstate ( this ) ; lhsdonestate = new lhsdonestate ( this ) ; rhsstate = new rhsstate ( this ) ; rhsnamestate = new rhsnamestate ( this ) ; rhsbusstate = new rhsbusstate ( this ) ; rhsmsbstate = new rhsmsbstate ( this ) ; rhscolonstate = new rhscolonstate ( this ) ; rhslsbstate = new rhslsbstate ( this ) ; rhsdonestate = new rhsdonestate ( this ) ; donestate = new donestate ( this ) ; state = initstate ; }
tr	2	private bed getbed ( commandline cmd ) { bed bed = null ; if ( cmd . hasoption ( "hostel_id" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . sethostelid ( new identifier ( cmd . getoptionvalue ( "hostel_id" ) ) ) ; } if ( cmd . hasoption ( "bed_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setnumber ( new integer ( cmd . getoptionvalue ( "bed_number" ) ) ) ; } if ( cmd . hasoption ( "room_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setroomno ( new integer ( cmd . getoptionvalue ( "room_number" ) ) ) ; } if ( bed != null ) bed . settariff ( null ) ; return bed ; }
tr	3	public static void main ( string [ ] argv ) { final int regulpriority = 8 ; final int refgenpriority = 6 ; final int plotterpriority = 7 ; referencegenerator refgen = new referencegenerator ( refgenpriority ) ; regul regul = new regul ( regulpriority ) ; final opcom opcom = new opcom ( plotterpriority ) ; regul . setopcom ( opcom ) ; regul . setrefgen ( refgen ) ; opcom . setregul ( regul ) ; runnable initializegui = new runnable ( ) { public void run ( ) { opcom . initializegui ( ) ; opcom . start ( ) ; } } ; try { swingutilities . invokeandwait ( initializegui ) ; } catch ( exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	2	public customer editcustomer ( customer customer ) throws exception { if ( customer . getid ( ) == null || customer . getaddress ( ) == null || customer . getname ( ) == null || customer . getsurname ( ) == null || customer . gettelephones ( ) == null ) { throw new nullparameterexception ( ) ; } if ( ! checkzipcode ( customer . getaddress ( ) . getzipcode ( ) ) ) { throw new zipcodeoutofrangeexception ( ) ; } daofactory . factory . getcustomerdao ( ) . updatecustomer ( customer ) ; return customer ; }
tr	1	@ test public void testmakestatsreturnscorrectstats ( ) { random rand = new random ( ) ; evdistribution evdistribution = mock ( evdistribution . class ) ; nature nature = mock ( nature . class ) ; when ( evdistribution . getnature ( ) ) . thenreturn ( nature ) ; int hpevs = rand . nextint ( 1000 ) ; int defevs = rand . nextint ( 1000 ) ; int spdefevs = rand . nextint ( 1000 ) ; when ( evdistribution . gethp ( ) ) . thenreturn ( hpevs ) ; when ( evdistribution . getdef ( ) ) . thenreturn ( defevs ) ; when ( evdistribution . getspdef ( ) ) . thenreturn ( spdefevs ) ; ibasestats basestats = mock ( ibasestats . class ) ; int basehp = rand . nextint ( 1000 ) ; int basedef = rand . nextint ( 1000 ) ; int basespdef = rand . nextint ( 1000 ) ; when ( basestats . gethp ( ) ) . thenreturn ( basehp ) ; when ( basestats . getdef ( ) ) . thenreturn ( basedef ) ; when ( basestats . getspdef ( ) ) . thenreturn ( basespdef ) ; int hpstat = rand . nextint ( 1000 ) ; int defstat = rand . nextint ( 1000 ) ; int spdefstat = rand . nextint ( 1000 ) ; when ( hpcalculator . calculate ( basehp , hpevs , nature ) ) . thenreturn ( hpstat ) ; when ( defcalculator . calculate ( basedef , defevs , nature ) ) . thenreturn ( defstat ) ; when ( spdefcalculator . calculate ( basespdef , spdefevs , nature ) ) . thenreturn ( spdefstat ) ; pokemonstats pokemonstats = statsfactory . makestats ( evdistribution , basestats ) ; assertequals ( hpstat , pokemonstats . gethp ( ) ) ; assertequals ( defstat , pokemonstats . getdef ( ) ) ; assertequals ( spdefstat , pokemonstats . getspdef ( ) ) ; }
tr	4	private void createtable ( ormhash ht , ormtable table ) throws sqlexception { string createsql = ht . createsql ( ) ; string tablename = table . tablename ( ) ; int hashsize = ht . hashsize ( ) ; if ( hashsize < 1 ) { hashsize = 1 ; } list < string > alreadyexisttablelist = dao . queryforsimpobjectlist ( "show tables like '" + tablename + "%'" , new object [ ] { } , string . class ) ; messageformat mf = new messageformat ( createsql ) ; string hashtablename = null ; for ( int i = 0 ; i < hashsize ; i ++ ) { hashtablename = tablename + "_" + dbutils . getinstance ( ) . hash ( i , hashsize ) ; if ( alreadyexisttablelist . contains ( hashtablename ) ) { logger . trace ( "hash table[{}] is already exist!" , hashtablename ) ; } else { logger . info ( "init hash table:{};" , hashtablename ) ; dao . update ( mf . format ( new object [ ] { hashtablename } ) ) ; logger . info ( "init hash table[{}] finish." , hashtablename ) ; } } }
tr	5	public void makeframenotactive ( final callframe frametohold ) { java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { resumebutton = new jbutton ( "\u0412\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0437\u0432\u043e\u043d\u043e\u043a" ) ; resumebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { string numbertounhold = parkbridgelines . get ( frametohold ) . get ( "numbertounhold" ) ; string holdchannel = parkbridgelines . get ( frametohold ) . get ( "holdchannel" ) ; frametohold . holdifnotactive ( ) ; resume ( numbertounhold , holdchannel . substring ( 0 , holdchannel . indexof ( "-" ) ) ) ; } } ) ; resumebutton . setpreferredsize ( new dimension ( 300 , 130 ) ) ; resumebutton . setbackground ( new color ( 0 , 25 , 0 ) ) ; resumebutton . setforeground ( new color ( 255 , 255 , 255 ) ) ; resumebutton . setfont ( new font ( "timesroman" , font . plain , 35 ) ) ; frametohold . add ( resumebutton , borderlayout . north ) ; frametohold . setpreferredsize ( new dimension ( 400 , 400 ) ) ; frametohold . pack ( ) ; } } ) ; }
tr	1	protected void jbinit ( ) throws exception { jpanel toppanel = new jpanel ( ) ; jpanel bottompanel = new jpanel ( ) ; jpanel rightpanel = new jpanel ( ) ; this . setcenter ( ) ; this . setnorth ( toppanel ) ; this . setsouth ( bottompanel ) ; this . seteast ( rightpanel ) ; m_mainpane . add ( toppanel , borderlayout . north ) ; m_mainpane . add ( m_gridscrollarea , borderlayout . center ) ; m_mainpane . add ( rightpanel , borderlayout . east ) ; m_mainpane . add ( bottompanel , borderlayout . south ) ; }
tr	1	public static pair < integer , integer > linearcongruence ( int a , int b , final int n ) { positivecheck ( n ) ; a = normalizeintmodulo ( a , n ) ; b = normalizeintmodulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new pair < > ( 0 , 1 ) ; final int numberofsolutions = gcd ( a , n ) ; if ( b % numberofsolutions != 0 ) return new pair < > ( ) ; int bezoutcoefficienta ; if ( a > n ) bezoutcoefficienta = bezout ( a , n ) . get ( 1 ) ; else bezoutcoefficienta = bezout ( n , a ) . get ( 2 ) ; final int shiftedmodulus = n / numberofsolutions ; int x = ( bezoutcoefficienta * b ) / numberofsolutions ; x = normalizeintmodulo ( x , shiftedmodulus ) ; return new pair < > ( x , shiftedmodulus ) ; }
tr	5	private static int computelongestcycle ( string string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . tochararray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
tr	1	public bus ( string id , driver driver , string plate , route route , int speed , double position , boolean state ) { this . id = id ; this . driver = driver ; this . plate = plate ; this . route = route ; this . speed = speed ; this . position = position ; this . state = state ; driver = new driver ( "not assigned" , "not assigned" , "not assigned" ) ; starttime = new gregoriancalendar ( ) ; nextstoptime = new gregoriancalendar ( ) ; acceleration = 0 ; movementstate = 99 ; stoptime = 0 ; }
tr	5	private boolean placerandomteleportlocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new illegalargumentexception ( "invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new illegalargumentexception ( "invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new illegalargumentexception ( "invalid argument: the randomlocation array-holder is not of length 2" ) ; arraylist < int [ ] > availablelocations = new arraylist < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availablelocations . add ( new int [ ] { i , j } ) ; } } } if ( availablelocations . size ( ) == 0 ) { java . lang . system . out . println ( "warning: you have a teleporter in a map with no spaces" ) ; return false ; } random random = new random ( ) ; random . setseed ( java . lang . system . currenttimemillis ( ) ) ; int index = random . nextint ( availablelocations . size ( ) ) ; int [ ] chosen = availablelocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
tr	2	@ override public dataunit read ( protocol p , readablebytechannel channel ) throws ioexception { readablebytechannel currentchannel = channel ; dataunit dataunit = headerprocessor . read ( p , currentchannel ) ; int totallength = protocolutil . gettotallength ( dataunit , p ) ; if ( totallength != - 1 ) { int toread = totallength - protocolutil . getheaderbytes ( p ) ; byte [ ] bytes = ioutil . readbytes ( toread , currentchannel ) ; currentchannel = channels . newchannel ( new bytearrayinputstream ( bytes ) ) ; } dataunit = unitprocessor . fromstream ( dataunit , p , currentchannel ) ; currentchannel = channel ; return dataunit ; }
tr	5	void deleteactivity ( component dialogparent , activity activity ) { if ( activity != null ) { if ( alertmessages . deleteactivityconfirmation ( dialogparent , activity ) ) { try { connection conn = dao . getconnection ( ) ; for ( time t : timedao . gettimesbyactivity ( conn , activity ) ) { timedao . deletetime ( conn , t ) ; } activitydao . deleteactivity ( conn , activity ) ; activitydialog . setactivity ( null ) ; activitylistdialog . selectpreviousrow ( ) ; activitydialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deleteactivity()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deleteactivity()" , ex ) ; } } } else { alertmessages . noactivityselectedintablefordeleting ( activitylistdialog ) ; } }
tr	1	@ beforemethod public void beforemethod ( ) { database = new database ( "first_db" ) ; coldefs = new linkedhashmap < > ( ) ; coldefs . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; coldefs . put ( "bar" , new columndefinition ( datatype . integer ) ) ; coldefs . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , coldefs ) ; database . add ( table ) ; parser = new parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executemodification ( ) ; }
tr	1	@ override public string tostring ( ) { return "rolesetupinfo [config=" + config + "  getname()=" + getname ( ) + "  gettype()=" + gettype ( ) + "  isconfigstale()=" + isconfigstale ( ) + "  gethostref()=" + gethostref ( ) + "  getserviceref()=" + getserviceref ( ) + "  getrolestate()=" + getrolestate ( ) + "  gethealthsummary()=" + gethealthsummary ( ) + "  gethealthchecks()=" + gethealthchecks ( ) + "  gethastatus()=" + gethastatus ( ) + "  getroleurl()=" + getroleurl ( ) + "  tostring()=" + super . tostring ( ) + "  getclass()=" + getclass ( ) + "  hashcode()=" + hashcode ( ) + "]" ; }
tr	1	@ override public void paint ( graphics canvas ) { clearcanvas ( canvas ) ; canvas . setcolor ( color . white ) ; canvas . drawline ( 100 , 100 , 600 , 600 ) ; color c = numbergenerator . getcolor ( ) ; canvas . setcolor ( c ) ; canvas . fillrect ( 200 , 200 , 100 , 200 ) ; canvas . setcolor ( color . red ) ; canvas . setfont ( new font ( "tahoma" , font . italic , 30 ) ) ; canvas . drawstring ( "hello world!" , 30 , 60 ) ; }
tr	2	public static void main ( string [ ] args ) { final int [ ] coins = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; final int [ ] limits = new int [ coins . length ] ; for ( int i = 0 ; i < limits . length ; i ++ ) { limits [ i ] = target / coins [ i ] ; } final int [ ] counts = new int [ coins . length ] ; loop ( coins , limits , counts , 0 ) ; system . out . println ( "# count = " + count ) ; }
tr	1	public static void main ( string [ ] args ) { userinfodto user = new userinfodto ( ) ; caretaker caretaker = new caretaker ( ) ; user . setaccount ( "zhangsan" ) ; user . setpassword ( "123456" ) ; user . settelno ( "13000000000" ) ; system . out . println ( "\u7528\u6237\u521b\u5efa\u5b8c\u6bd5\uff01" ) ; user . show ( ) ; caretaker . setmemento ( user . savememento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u4fdd\u5b58\u4e86\u7528\u6237\u7684\u5907\u5fd8\u5f55\uff01" ) ; user . setpassword ( "111111" ) ; user . settelno ( "13100001111" ) ; system . out . println ( "\u7528\u6237\u4fe1\u606f\u5df2\u7ecf\u66f4\u65b0\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; user . restorememento ( caretaker . getmemento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u6062\u590d\u4e86\u5907\u5fd8\u5f55\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; }
tr	1	@ test public void testapplyleechseed ( ) { system . out . println ( "applying leech seed" ) ; activepokemon healer = new activepokemon ( species . abomasnow ) ; healer . sethpev ( 252 ) ; healer . setcurrhp ( 342 ) ; activepokemon seeded = new activepokemon ( species . absol ) ; seeded . sethpev ( 252 ) ; seeded . activateseeds ( ) ; assertequals ( healer . getcurrhp ( ) , 342 ) ; assertequals ( seeded . getcurrhp ( ) , 334 ) ; assertequals ( seeded . getmaxhp ( ) , 334 ) ; statusdamage . applyleechseed ( seeded , healer ) ; assertequals ( seeded . getcurrhp ( ) , 293 ) ; assertequals ( healer . getcurrhp ( ) , 383 ) ; }
tr	5	private string [ ] getstringarray ( jcomponent comp ) { if ( comp instanceof jcombobox ) { jcombobox combobox = ( jcombobox ) comp ; list < string > list = new arraylist < string > ( ) ; if ( combobox . getitemcount ( ) > 0 ) { for ( int i = 0 ; i < combobox . getitemcount ( ) ; i ++ ) { if ( ! isempty ( combobox . getitemat ( i ) ) ) { add ( list , combobox . getitemat ( i ) ) ; } else if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toarray ( new string [ 1 ] ) ; } else { return null ; } } else { if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; return list . toarray ( new string [ 1 ] ) ; } } } return null ; }
tr	3	@ override public string tostring ( ) { string a = "" ; string b ; if ( ! playerscoreminerals . keyset ( ) . equals ( playershiplocations . keyset ( ) ) ) { for ( string s : playerscoreminerals . keyset ( ) ) { system . out . println ( s ) ; } system . out . println ( "different from" ) ; for ( string s : playershiplocations . keyset ( ) ) { system . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( string k : playershiplocations . keyset ( ) ) { b = "" ; for ( boardlocation bl : playershiplocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerscoreminerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerscoreminerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	3	private void reversegraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { grapht . add ( new arraylist < integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { arraylist < integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; grapht . get ( vertex ) . add ( i ) ; } } }
tr	3	@ override public void handleevent ( iparserevent event ) { if ( event . gettype ( ) == parsereventtype . document_end_event ) { flushevents ( ) ; event . fire ( listener ) ; } else { iparserevent lastevent = events . peeklast ( ) ; if ( lastevent != null && lastevent . gettype ( ) == parsereventtype . string_event && event . gettype ( ) == parsereventtype . string_event ) { event = mergestringevents ( ( stringevent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > max_events ) { events . removefirst ( ) . fire ( listener ) ; } } }
tr	1	@ test public void testgetwordsfromunknownword ( ) { dataholder mytester = this . dataholderfactory ( ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word3 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cheek unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cross unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "deep unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "denticles unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word4 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "endocranium unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word5 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "lepidotrichia unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word1 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word2 unknown" . split ( " " ) ) ) ; set < string > target = new hashset < string > ( ) ; target . add ( "cheek" ) ; target . add ( "cross" ) ; target . add ( "deep" ) ; target . add ( "denticles" ) ; target . add ( "endocranium" ) ; target . add ( "lepidotrichia" ) ; string wordpattern = "((" + constant . plendings + "|ium)$)|(ee)" ; string flagpattern = "^unknown$" ; assertequals ( "getwordsfromunknownword" , target , mytester . getwordsfromunknownword ( wordpattern , true , flagpattern , true ) ) ; }
tr	2	@ override public component gettablecellrenderercomponent ( jtable table , object value , boolean isselected , boolean hasfocus , int row , int column ) { final component c = super . gettablecellrenderercomponent ( table , value , isselected , hasfocus , row , column ) ; if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . high ) { c . setforeground ( color . white ) ; c . setbackground ( color . red ) ; } else if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . medium ) { c . setforeground ( color . black ) ; c . setbackground ( color . orange ) ; } else { c . setbackground ( color . green ) ; c . setforeground ( color . black ) ; } return c ; }
tr	4	public paymentdialog ( member member , classtype ct , string message , int flag ) { messagetextarea . settext ( message ) ; globalmember = member ; globalclasstype = ct ; globalflag = flag ; makepaymentbutton = new jbutton ( "make payment" ) ; makepaymentbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { common . makepayment ( paymenttypelist . getselectedvalue ( ) , globalmember , ( date ) utildatemodel . getvalue ( ) , getpaymentamount ( ) ) ; updatepaymentstatus ( globalmember , globalclasstype ) ; dispose ( ) ; new paymentdialog ( globalmember , globalclasstype , "payment made for " + globalmember . getname ( ) + "\n of " + getpaymentamount ( ) + " for " + paymenttypelist . getselectedvalue ( ) . getpaymenttypename ( ) + "\n up to date: " + ( ( date ) utildatemodel . getvalue ( ) ) . tostring ( ) , globalflag ) ; } } ) ; makepaymentbutton . setenabled ( false ) ; exitbutton = new jbutton ( "exit" ) ; exitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { dispose ( ) ; if ( globalflag == 0 ) new membercheckininterface ( globalclasstype ) ; } } ) ; bufferedimage tkdicon = commonui . gettkdicon ( ) ; bufferedimage skyicon = commonui . getskyicon ( ) ; bufferedimage kickicon = commonui . getkickicon ( ) ; image img = null ; switch ( ct ) { case taekwondo : img = new imageicon ( tkdicon ) . getimage ( ) ; break ; case skyboxing : img = new imageicon ( skyicon ) . getimage ( ) ; break ; case kickboxing : img = new imageicon ( kickicon ) . getimage ( ) ; break ; case other : img = new imageicon ( tkdicon ) . getimage ( ) ; default : img = new imageicon ( tkdicon ) . getimage ( ) ; } seticonimage ( img ) ; this . settitle ( "enter payment for " + member . getname ( ) ) ; utildatemodel . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent arg0 ) { system . out . println ( "datemodel changed" ) ; setdateselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; panel . add ( paymenttopanel , borderlayout . center ) ; paymenttypelist . setlistdata ( common . getpaymenttypes ( ct ) . toarray ( new paymenttype [ 1 ] ) ) ; paymenttypelist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent arg0 ) { jlist < paymenttype > templist = ( jlist < paymenttype > ) arg0 . getsource ( ) ; paymenttype pt = templist . getselectedvalue ( ) ; paymentamounttextfield . settext ( string . format ( "%9.2f" , pt . getpaymentamount ( ) ) ) ; setpaymentamountfieldselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; listpanel . add ( paymenttypelist ) ; panel . add ( listpanel , borderlayout . west ) ; paymentamountpanel . add ( paymentamountlabel ) ; paymentamountpanel . add ( paymentamounttextfield ) ; buttonpanel . add ( paymentamountpanel , borderlayout . north ) ; buttonpanel . add ( makepaymentbutton , borderlayout . west ) ; buttonpanel . add ( exitbutton , borderlayout . south ) ; panel . add ( buttonpanel , borderlayout . south ) ; paymentstatuspanel . add ( paymentstatustextarea , borderlayout . north ) ; paymentstatuspanel . add ( messagetextarea , borderlayout . south ) ; updatepaymentstatus ( member , ct ) ; panel . add ( paymentstatuspanel , borderlayout . east ) ; this . getcontentpane ( ) . add ( panel ) ; this . setsize ( commonui . fullscreen ) ; this . setvisible ( true ) ; }
tr	4	public string executerequest ( ) throws ioexception { setsigningmethod ( auth ) ; string signingstring = getsigningstring ( customer_id ) ; string signature ; string url_output = "" ; stringbuffer full_url = new stringbuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( string key : params . keyset ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( urlencoder . encode ( key , "utf-8" ) ) . append ( "=" ) . append ( urlencoder . encode ( params . get ( key ) , "utf-8" ) ) ; } } url = new url ( full_url . tostring ( ) ) ; try { signature = encode ( signingstring , secret_key ) ; } catch ( signatureexception e ) { system . err . println ( "error signing request " + e . getmessage ( ) ) ; return null ; } string auth_header = "tsa " + customer_id + ":" + signature ; connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setconnecttimeout ( connecttimeout ) ; connection . setreadtimeout ( readtimeout ) ; connection . setrequestproperty ( "authorization" , auth_header ) ; settlsprotocol ( ) ; if ( post ) { connection . setrequestproperty ( "content-length" , integer . tostring ( body . length ( ) ) ) ; } for ( string key : ts_headers . keyset ( ) ) { connection . setrequestproperty ( key , ts_headers . get ( key ) ) ; } for ( string key : headers . keyset ( ) ) { connection . setrequestproperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setdooutput ( true ) ; dataoutputstream wr = new dataoutputstream ( connection . getoutputstream ( ) ) ; wr . writebytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getresponsecode ( ) ; bufferedreader in ; try { inputstream isr = ( response == 200 ) ? connection . getinputstream ( ) : connection . geterrorstream ( ) ; in = new bufferedreader ( new inputstreamreader ( isr ) ) ; string urlreturn ; while ( ( urlreturn = in . readline ( ) ) != null ) { url_output += urlreturn ; } in . close ( ) ; } catch ( ioexception e ) { system . err . println ( "ioexception while reading from input stream " + e . getmessage ( ) ) ; throw new runtimeexception ( e ) ; } return url_output ; }
tr	5	public boolean testrule ( wff ext , wff _world , defaultrule d ) { wff prec = new wff ( d . getprerequisite ( ) ) ; wff world = new wff ( _world . getformula ( ) + " & " + ext . getformula ( ) ) ; if ( world . entails ( prec ) ) { wff just = new wff ( d . getjustificatoin ( ) ) ; if ( just . eval ( ext ) ) { wff cons = new wff ( d . getconsequence ( ) ) ; if ( ext . isconsistent ( cons . getformula ( ) ) ) { if ( ext . entails ( cons ) ) { return true ; } } } } else { } return false ; }
tr	4	@ override public void actionperformed ( actionevent ae ) { if ( ae . getactioncommand ( ) . compareto ( "comboboxchanged" ) == 0 ) { if ( ae . getsource ( ) == combo_url ) { loadurldata ( ) ; } else if ( ae . getsource ( ) == combo_granttype ) { if ( combo_granttype . getselectedindex ( ) == authorization_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . authorization_grant ) ; setuppanels ( ) ; } else if ( combo_granttype . getselectedindex ( ) == password_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . pasword_grant ) ; setuppanels ( ) ; } else if ( combo_granttype . getselectedindex ( ) == client_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . client_credentials_grant ) ; setuppanels ( ) ; } } } else if ( ae . getactioncommand ( ) . compareto ( about_menuitem ) == 0 ) { joptionpane . showmessagedialog ( applicationframe , "oauthtestclient\nan oauth 2.0 test application\nwritten by ronnie mitra.\n\nhttps://github.com/mitraman/oauthtestclient    \n\n" , "about oauthtestclient" , joptionpane . question_message ) ; } else if ( ae . getactioncommand ( ) . compareto ( settings_menuitem ) == 0 ) { settingsdialog settingsdialog = new settingsdialog ( applicationframe ) ; settingsdialog . setvisible ( true ) ; } else if ( ae . getactioncommand ( ) . compareto ( save_config_menuitem ) == 0 ) { jfilechooser filechooser = new jfilechooser ( "./oauthtestclient.cfg" ) ; if ( filechooser . showsavedialog ( this ) == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; configmanager . saveproperties ( file ) ; } } else if ( ae . getactioncommand ( ) . compareto ( load_config_menuitem ) == 0 ) { jfilechooser filechooser = new jfilechooser ( ) ; if ( filechooser . showopendialog ( this ) == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; configmanager . loadproperties ( file ) ; } } else { system . out . println ( ae . getactioncommand ( ) + " " + ae . getid ( ) ) ; } }
tr	5	public boolean act ( agent agent , action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateviews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { simulatedagent a = ( simulatedagent ) agent ; int x = ( ( integer ) a . getattribute ( x ) ) . intvalue ( ) ; int y = ( ( integer ) a . getattribute ( y ) ) . intvalue ( ) ; percept p = sense ( a ) ; string msg = null ; string act = action . getcode ( ) ; int actionid = language . getactionindex ( act ) ; switch ( actionid ) { case 4 : if ( ( ( boolean ) p . getattribute ( language . getpercept ( 5 ) ) ) . booleanvalue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { system . out . println ( "eating good food..." ) ; energy_level = math . min ( energy_level + inc_energy_level , max_energy_level ) ; } else { system . out . println ( "eating bad food..." ) ; energy_level = math . max ( energy_level - dec_energy_level , 0 ) ; } } else { msg = simpleview . error + "[there is not food. eat action not executed]" ; } updateviews ( msg ) ; break ; default : if ( actionid == 2 ) { energy_level -- ; system . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
tr	3	public void testfilecontent ( ) throws ioexception { long start = system . currenttimemillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; string filename1 = "test1.class" ; string filename2 = "test2.class" ; file file1 = new file ( filename1 ) ; file file2 = new file ( filename2 ) ; bufferedinputstream bis1 = new bufferedinputstream ( new fileinputstream ( file1 ) ) ; bufferedinputstream bis2 = new bufferedinputstream ( new fileinputstream ( file2 ) ) ; polynomial polynomial = polynomial . createirreducible ( 53 ) ; fingerprint < polynomial > rabin1 = new rabinfingerprintlong ( polynomial ) ; fingerprint < polynomial > rabin2 = new rabinfingerprintlong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushbytes ( buf1 ) ; rabin2 . pushbytes ( buf2 ) ; string s1 = new string ( buf1 ) ; string s2 = new string ( buf2 ) ; if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) != 0 ) { system . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) == 0 ) system . out . println ( "file 1 and file 2 are the same!" ) ; long end = system . currenttimemillis ( ) ; system . out . println ( "time: " + ( end - start ) + "ms." ) ; assertequals ( 0 , rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) ) ; }
tr	1	private viability initiateviability ( file habitatfolder ) throws ioexception , interruptedexception { file viabilitycsv = new file ( habitatfolder . getpath ( ) + file . separatorchar + viability ) ; if ( ! viabilitycsv . exists ( ) || ! viabilitycsv . isfile ( ) ) throw new filedoesntexist ( habitatfolder . getpath ( ) + file . separatorchar + viability , "but file with parameters of viability is strongly required" ) ; string filecontent = getfullfilecontent ( viabilitycsv ) ; string preparedcontent = preparer . getpreparedcontent ( filecontent , viabilityreader . input_area ) ; saver . saveforcurrentpoint ( habitatfolder . getname ( ) , viability , preparedcontent ) ; return new viabilityreader ( preparedcontent ) . getviability ( ) ; }
tr	4	private void generaterandombreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 11 ) ; } } }
tr	5	@ override public void run ( ) { while ( true ) { try { for ( blocklocationpair p : deletionqueue ) { string nodelocation = p . nodelocation ; string blockname = p . blockname ; string [ ] ipport ; try { ipport = addresstoipport . addresstoipport ( nodelocation ) ; message inputmessage = new message ( "remove" ) ; inputmessage . filename = blockname ; communicator . sendmessage ( ipport [ 0 ] , integer . parseint ( ipport [ 1 ] ) , inputmessage ) ; } catch ( numberformatexception | ioexception e ) { e . printstacktrace ( ) ; throw new ioexception ( "could not delete distributed file block " + blockname + "\n " + e . getmessage ( ) ) ; } } } catch ( exception e ) { logger . log ( "error encountered while deleting distributed file: " + e . getmessage ( ) ) ; e . printstacktrace ( ) ; } try { thread . sleep ( 3000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	4	public static void main ( string [ ] args ) { int k = 0 ; try { k = integer . parseint ( args [ 0 ] ) ; } catch ( numberformatexception e ) { system . out . println ( "expected an argument with the number of elements to print." ) ; system . out . println ( "usage: subset k - to print k values from the input." ) ; system . out . println ( "example: echo a b c d e f g h i | java subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; randomizedqueue < string > rq = new randomizedqueue < string > ( ) ; while ( ! stdin . isempty ( ) ) { string s = stdin . readstring ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = stdrandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isempty ( ) ; i ++ ) { system . out . println ( rq . dequeue ( ) ) ; } }
tr	3	public void refreshtextlist ( ) { ground . remove ( textpane ) ; textpane = null ; resultsets = connector . getallresultsets ( userid ) ; iterator < ? > result = resultsets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasnext ( ) ) { resultset temp_res = ( resultset ) result . next ( ) ; resultmapper . put ( temp_res . getdocument ( ) . getfilename ( ) , ( resultset ) temp_res ) ; dataname . addelement ( temp_res . getdocument ( ) . getfilename ( ) ) ; } textpane = new jscrollpane ( texte ) ; textpane . setlocation ( 280 , 50 ) ; textpane . setsize ( 180 , 300 ) ; textpane . setvisible ( true ) ; texte . setvisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	1	@ test public void testregisterandauth ( ) throws exception { messagesystem . sendmessage ( new msgregister ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; messagesystem . sendmessage ( new msglogin ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; when ( request . getpathinfo ( ) ) . thenreturn ( pages . main_page ) ; frontend . doget ( request , response ) ; assert . asserttrue ( stringwriter . tostring ( ) . contains ( user ) ) ; assert . assertfalse ( stringwriter . tostring ( ) . contains ( "anonymous" ) ) ; accountservice . delete ( user ) ; }
tr	1	@ test public void testgetmodifierandtagforcase2 ( ) { posbasedannotator mytester = this . markupbyposfactory ( ) ; string modifier = "large interlocking" ; int start = 2 ; int end = 3 ; list < string > words = new arraylist < string > ( ) ; words . addall ( arrays . aslist ( "large interlocking <n>plates</n> <b>with</b> pronounced crescentic <n>margins</n>" . split ( " " ) ) ) ; list < string > target = new linkedlist < string > ( ) ; target . add ( "large interlocking" ) ; target . add ( "<n>plates</n>" ) ; assertequals ( "getmodifierandtagforcase1" , target , mytester . getmodifierandtagforcase2 ( modifier , start , end , words ) ) ; }
tr	4	public static string readasstring ( file file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; inputstream is = null ; try { is = new fileinputstream ( file ) ; is . read ( bytes ) ; } catch ( ioexception e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( ioexception ex ) { return null ; } } try { return new string ( bytes , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return null ; } }
tr	1	public static void debug ( connection con ) throws exception { system . out . println ( "\ndump of table geoloc:" ) ; statement stmt = con . createstatement ( ) ; resultset rs = stmt . executequery ( "select geohash  subject  predicate  lat_lon_object  lat  lon from geoloc" ) ; while ( rs . next ( ) ) system . out . println ( "geoloc row: " + rs . getstring ( "geohash" ) + " " + rs . getstring ( "subject" ) + " " + rs . getstring ( "predicate" ) + " " + rs . getstring ( "lat_lon_object" ) + " " + rs . getfloat ( "lat" ) + " " + rs . getfloat ( "lon" ) ) ; system . out . println ( ) ; system . out . println ( "\ndump of table free text predicates:" ) ; stmt = con . createstatement ( ) ; rs = stmt . executequery ( "select predicate from free_text_predicates" ) ; while ( rs . next ( ) ) system . out . println ( "free_text_predicates row: " + rs . getstring ( "predicate" ) ) ; system . out . println ( ) ; }
tr	5	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
tr	5	@ override public void run ( ) { player [ ] players = plugin . getserver ( ) . getonlineplayers ( ) ; player player ; long configtime = plugin . getconfig ( ) . getint ( "kick_timer" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastmoved = 0 ; player = players [ i ] ; usertable ut = plugin . getdatabase ( ) . find ( usertable . class ) . where ( ) . ieq ( "username" , player . getname ( ) ) . = ( "afk" , true ) . findunique ( ) ; if ( ut == null ) { return ; } lastmoved = system . currenttimemillis ( ) - ut . getafktime ( ) ; if ( player . isop ( ) ) { if ( plugin . getconfig ( ) . getboolean ( "kick_op" ) ) { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } else { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } }
tr	4	private static void savesystemstate ( string filename ) { string out = getparametervaluelist ( ) + "\n" ; out += "changed per state \n" ; out += "\t mayority \t confidence \t weight \t missfire \n" ; if ( systemstatechangeds != null ) { for ( string systemtesttype : systemstatechangeds . keyset ( ) ) { for ( string meth : systemstatechangeds . get ( systemtesttype ) . keyset ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( string systemtesttype : systemstatechangeds . keyset ( ) ) { for ( string meth : systemstatechangeds . get ( systemtesttype ) . keyset ( ) ) { out += systemstatechangeds . get ( systemtesttype ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t mayority \t confidence \t weight \t missfire \n" ; if ( lastsystemtestpoints != null ) for ( string s : lastsystemtestpoints . keyset ( ) ) { out += "\t" + s + "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "mayority" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "confidence" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "weight" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "missfire" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\n" ; } file f = new file ( filename ) ; try { if ( ! f . getparentfile ( ) . exists ( ) ) f . getparentfile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createnewfile ( ) ; filewriter w = new filewriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( sciencetool . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	4	protected static void addobject ( iunknown o ) { if ( apartmentinitialized . get ( ) == false ) { comthread . initsta ( false ) ; apartmentinitialized . set ( true ) ; } if ( ! auto_gc ) return ; referencequeue < iunknown > deadobjects = deadpool . get ( ) ; objects . put ( new pointerweakreference ( o , deadobjects ) , false ) ; if ( gc_count != - 1 && ( count % gc_count ) == 0 ) { system . gc ( ) ; } if ( ( count ++ % cull_count ) == 0 ) { int numberculled = culldeadpool ( deadobjects , objects ) ; if ( iunknown . isdebugenabled ( ) ) { if ( numberculled > 0 ) { iunknown . debug ( "rot: added instance of " + o . getclass ( ) . getsimplename ( ) + "->[+1  -" + numberculled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	1	public actiondialog ( skyquestutility util , jcomponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new jbutton ( "save" ) ; cancel = new jbutton ( "cancel" ) ; amodel = new defaultlistmodel < actiontype > ( ) ; atypes = new jlist < actiontype > ( amodel ) ; for ( actiontype a : questmanager . getinstance ( ) . getregisteredactiontypes ( ) ) amodel . addelement ( a ) ; setlayout ( new borderlayout ( ) ) ; jpanel buttons = new jpanel ( ) ; buttons . setlayout ( new boxlayout ( buttons , boxlayout . x_axis ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; jpanel ap = new jpanel ( ) ; ap . setlayout ( new borderlayout ( ) ) ; ap . add ( "center" , atypes ) ; ap . add ( "north" , new jlabel ( "type" ) ) ; add ( "south" , buttons ) ; cancel . addactionlistener ( this ) ; save . addactionlistener ( this ) ; }
tr	2	void updatestep6 ( ) { double totalbudget = lg . getbudget ( ) ; double totalexpenses = lg . gethotelbudgetspent ( ) + lg . getexpensespent ( ) ; double remainingbudget = totalbudget - totalexpenses ; textpane6_totalbudget . settext ( string . valueof ( "$" + totalbudget ) ) ; textpane6_spent . settext ( string . valueof ( "$" + totalexpenses ) ) ; textpane6_remaining . settext ( string . valueof ( "$" + remainingbudget ) ) ; if ( lg . getguestlist ( ) . size ( ) != 0 ) { lg . setcostperhead ( ) ; decimalformat df = new decimalformat ( "0.00" ) ; df . setgroupingused ( false ) ; double costperhead = lg . getcostperhead ( ) ; string costperheadstr = df . format ( costperhead ) ; textpane6_costperhead . settext ( string . valueof ( "$" + costperheadstr ) ) ; } if ( lg . completedexpensefields ( ) ) chckbx6_expensesfinalised . setenabled ( true ) ; chckbx6_expensesfinalised . setselected ( lg . getexpensefinalised ( ) ) ; panel6 . remove ( scrollpane6 ) ; createtable6 ( lg . getexpenselist ( ) , expensescols ) ; }
tr	2	public synchronized void tick ( ) { handleevents ( ) ; updateworkers ( ) ; for ( sponsor sponsor : new arraylist < sponsor > ( sponsors ) ) { if ( sponsor . getmsleft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } random r = new random ( ) ; if ( sponsors . size ( ) < max_sponsors && r . nextint ( ( int ) ( 1500 / math . log ( getrenown ( ) + 2 ) ) ) == 0 ) { addsponsor ( ) ; } if ( getrenown ( ) <= 0 ) { showwindow ( null , new gameoverwindow ( ) ) ; } if ( r . nextint ( difficulty ) == 0 ) { setrenown ( getrenown ( ) - 1 ) ; } if ( firsttick ) showwindow ( null , new helpwindow ( ) ) ; firsttick = false ; }
tr	1	public hoge ( lr lr , shootingweaponcharacter weapon ) { setweapon ( weapon ) ; setx ( commons . center_x + ( 165 * lr . signum ( ) ) ) ; sety ( 40 ) ; weaponview . setx ( getx ( ) ) . sety ( gety ( ) + 5 ) . setwidth ( weapon . getwidth ( ) ) . setheight ( weapon . getheight ( ) ) . setscale ( 2 ) . setcolor ( weapon . getcolor ( ) ) ; remainbulletview . setx ( getx ( ) ) . sety ( gety ( ) - 25 ) . setscale ( 0.3f ) . setcolor ( color . white ) ; }
tr	5	public static void main ( string argv [ ] ) { bus busses [ ] = null ; host host ; try { host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usb is unavailable  can't run." ) ; return ; } system . out . println ( "<!-- " + host + " -->" ) ; busses = host . getbusses ( ) ; indentline ( 0 , "<host busses='" + busses . length + "'>" ) ; for ( int busno = 0 ; busno < busses . length ; busno ++ ) { indentline ( 2 , "<!-- bus #" + ( busno + 1 ) + " -->" ) ; if ( busses [ busno ] != null ) { try { printdevice ( 2 , busses [ busno ] . getroothub ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } indentline ( 0 , "</host>" ) ; } catch ( securityexception e ) { system . err . println ( "usb permissions problem:" ) ; system . err . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	1	public int print ( graphics graphics , pageformat pageformat , int pageindex ) throws printerexception { if ( pageindex >= 1 ) return printable . no_such_page ; graphics2d g2d = ( graphics2d ) graphics ; double h = pageformat . getimageableheight ( ) ; double w = pageformat . getimageablewidth ( ) ; double x = pageformat . getimageablex ( ) ; double y = pageformat . getimageabley ( ) ; system . out . println ( "pf:" + x + " " + y + " " + w + " " + h ) ; g2d . translate ( x , y ) ; dimension size = new dimension ( ( int ) w , ( int ) h ) ; paintit ( g2d , size ) ; return printable . page_exists ; }
tr	4	private void dotransfer ( ) throws ioexception { if ( ressourceinputstream == null ) { if ( sendheaderinrsp ) { string header = new filerequestresponsemessage ( responsecode . never_try_again , 0 ) . serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkoutputstream . write ( header . getbytes ( ) ) ; } networkoutputstream . close ( ) ; return ; } else { if ( offset > numavailabledata ) { logger . log ( level . info , "requested offset is not valid: requested " + offset + "  length of file: " + numavailabledata ) ; if ( sendheaderinrsp ) networkoutputstream . write ( new filerequestresponsemessage ( responsecode . ok , 0 ) . serialize ( ) . getbytes ( ) ) ; networkoutputstream . close ( ) ; transferstate = transferstatus . finished ; return ; } if ( offset + expectedtransfervolume > numavailabledata ) { logger . log ( level . info , "requested length of " + expectedtransfervolume + " was too large  shortened  it to " + expectedtransfervolume ) ; expectedtransfervolume = numavailabledata - offset ; } transferstate = transferstatus . transfering ; if ( sendheaderinrsp ) networkoutputstream . write ( ( new filerequestresponsemessage ( responsecode . ok , expectedtransfervolume ) . serialize ( ) ) . getbytes ( message . encoding ) ) ; if ( buffersize == - 1 ) { buffersize = fallback_buffer_size ; logger . log ( level . info , "using fallback buffersize " + buffersize ) ; } logger . info ( "sending data" ) ; ressourceinputstream . skip ( offset ) ; int bytesread = 0 ; int bytestoread = buffersize ; byte [ ] buffer = new byte [ buffersize ] ; while ( bytestoread > 0 && keeptransferalive && totaltransferedvolume < expectedtransfervolume && ( bytesread = ressourceinputstream . read ( buffer , 0 , bytestoread ) ) != - 1 ) { networkoutputstream . write ( buffer , 0 , bytesread ) ; totaltransferedvolume += bytesread ; if ( totaltransferedvolume + bytestoread > expectedtransfervolume ) { bytestoread = ( int ) ( expectedtransfervolume - totaltransferedvolume ) ; } } networkoutputstream . flush ( ) ; networkoutputstream . close ( ) ; ressourceinputstream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totaltransferedvolume == expectedtransfervolume ) transferstate = transferstatus . finished ; else { if ( ! keeptransferalive ) transferstate = transferstatus . canceled ; else transferstate = transferstatus . lostconnection ; } } }
tr	2	@ override public void paintcomponent ( graphics g ) { g . setcolor ( def_background_colour ) ; g . fillrect ( 0 , 0 , util . image_size , util . image_size ) ; graphics2d g2d = ( graphics2d ) g ; if ( image != null ) { g2d . drawimage ( image , 0 , 0 , util . image_size , util . image_size , 0 , 0 , util . image_size , util . image_size , null ) ; } if ( gridvisible ) { drawgrid ( g ) ; } g2d . drawimage ( selector , selectorlocation . x , selectorlocation . y , selectorlocation . x + util . grid_sections , selectorlocation . y + util . grid_sections , 0 , 0 , util . grid_sections , util . grid_sections , null ) ; }
tr	1	public static void main ( string [ ] args ) { double mass , height , bmi ; mass = double . parsedouble ( args [ 0 ] ) ; height = double . parsedouble ( args [ 1 ] ) ; bmi = mass / math . pow ( height , 2 ) ; if ( bmi < 18.5 ) system . out . println ( "underweight" ) ; else if ( bmi < 25 ) system . out . println ( "normal weight" ) ; else if ( bmi < 30 ) system . out . println ( "overweight" ) ; else system . out . println ( "obses" ) ; }
tr	2	@ override public void actionperformed ( actionevent event ) { string eventname = event . getactioncommand ( ) ; system . out . println ( "event:" + eventname ) ; switch ( eventname ) { case "comboboxchanged" : string prefname = sysadminui . getpreferencelistboxselection ( ) ; string value = systemprefs . get ( prefname ) . tostring ( ) ; sysadminui . setpreferencefield ( value ) ; break ; case "set preference" : string preference = sysadminui . getpreferencelistboxselection ( ) ; string valuefield = sysadminui . getpreferencefield ( ) ; systemprefs . put ( preference , valuefield ) ; setchanged ( ) ; notifyobservers ( ) ; break ; } }
tr	1	public graphpaper3d ( double width , double height , double depth ) { super ( new body ( ) , width , height ) ; this . m_root = ( body ) this . getroot ( ) ; this . m_system = new body ( ) ; this . m_root . addcomponent ( this . m_system ) ; this . m_width = width ; this . m_height = height ; this . m_depth = depth ; this . setfill ( color . grey ) ; calculatepixeltocartesianconvertdata ( ) ; setuplisteners ( ) ; drawgraphinformation ( ) ; drawaxes ( ) ; setupcamera ( ) ; }
tr	1	private void elementosposicionanormal ( ) { this . jlabel2 . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 60 ) ; this . txtcorreo . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 80 ) ; this . btnbuscar . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . btnbuscar . getwidth ( ) / 2 ) + 115 , 77 ) ; }
tr	5	public listnode partition ( listnode head , int x ) { listnode p1 = null , p2 = head , p2prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2prev ) { p1 = p2 ; p2 = p2 . next ; p2prev = p1 ; } else { p2prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2prev . next ; } } else { p2prev = p2 ; p2 = p2 . next ; } } return head ; }
tr	3	public static void main ( string [ ] args ) throws interruptedexception { final thread t1 = new thread ( ) { public void run ( ) { logger . info ( "t1 start wait" ) ; locksupport . park ( ) ; logger . info ( "t1 get signal" ) ; } } ; thread t2 = new thread ( ) { public void run ( ) { logger . info ( "t2 start signal" ) ; locksupport . unpark ( t1 ) ; logger . info ( "t2 end" ) ; } } ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; }
tr	2	public void addnewelementstohac ( arraylist < commententityds > necommentdsarray , string articleid ) throws exception { docfactory documentfactory = new docfactory ( ) ; docdo document = documentfactory . get ( articleid ) ; arraylist < mapcell > mappingarray = databaseoperations . getarticlemapping ( articleid ) ; arrayofcommentsfactory commentsarrayfactory = new arrayofcommentsfactory ( ) ; arrayofcommentsdo arrayofcommentsdo = null ; arrayofcommentsdo = commentsarrayfactory . get ( articleid ) ; arraylist < comment > nearray = comment . convertcommentsdstocommentsarraylist ( necommentdsarray ) ; double [ ] vector = new double [ databaseoperations . getwordscountforarticle ( articleid ) + 1 ] ; for ( comment ne : nearray ) { comment . nomalizecommentvector ( ne ) ; addnewelementtohac ( ne , articleid , vector , document , mappingarray , arrayofcommentsdo . arrayofcomment ) ; arrayofcommentsdo . arrayofcomment . add ( ne ) ; commentsarrayfactory . save ( arrayofcommentsdo ) ; } domimplementationls domimplementation = ( domimplementationls ) document . doc . getimplementation ( ) ; databaseoperations . setxmlrepresentation ( articleid , domimplementation . createlsserializer ( ) . writetostring ( document . doc ) ) ; databaseoperations . setarticlemapping ( articleid , mappingarray ) ; documentfactory . save ( document ) ; databaseoperations . setcomments ( articleid , necommentdsarray ) ; }
tr	2	@ override public void process ( ) { string [ ] s = curdir . list ( strings . getstringfilter ( ) . getfilenamefilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { string x = strings . substitute ( s [ i ] ) ; string t = s [ i ] + " => " + x ; if ( ! ispreview ) t += new file ( curdir , s [ i ] ) . renameto ( new file ( curdir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; print . ln ( t ) ; } print . ln ( "total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
tr	3	public int [ ] likertjakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	3	public static void main ( string [ ] args ) { try { = ( 0 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "ba" } ) , 2 ) ; = ( 1 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "ab" , "bcd" , "efg" } ) , 0 ) ; = ( 2 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "bba" , "abb" } ) , 7 ) ; = ( 3 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "aabccc" , "ccbbca" , "a" , "acaabb" , "aaa" , "aab" , "c" , "babb" , "aacaa" , "b" } ) , 47 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
tr	3	public static object getdummyobject ( class cls ) { object obj = null ; try { constructor < ? > ctor = cls . getdeclaredconstructor ( ) ; reflector . ensureisaccessible ( ctor ) ; obj = ctor . newinstance ( ) ; } catch ( nosuchmethodexception e1 ) { final constructor < ? > ctor = cls . getconstructors ( ) [ 0 ] ; class [ ] paramtypes = ctor . getparametertypes ( ) ; list < object > params = new arraylist < object > ( ) ; for ( class paramtype : paramtypes ) params . add ( paramtype . isprimitive ( ) ? gettypedefaultvalue ( paramtype . getname ( ) ) : null ) ; try { obj = ctor . newinstance ( params . toarray ( ) ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; } } catch ( securityexception e1 ) { e1 . printstacktrace ( ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; } finally { return obj ; } }
tr	2	public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . out . println ( "argument error." ) ; system . out . println ( "using method: java -xmx2048m -jar prince.jar ./input/config.txt" ) ; system . exit ( - 1 ) ; } inputargument input = new inputargument ( args [ 0 ] ) ; princecrossvalidation validation = new princecrossvalidation ( input . getppifilepath ( ) , input . getdiseasesimilarityfilepath ( ) , input . getgenediseaseassociationfilepath ( ) , input . getdiseasefilepath ( ) , input . getoutputdir ( ) ) ; system . out . println ( "prince validation starting..." ) ; validation . batch_run ( ) ; system . out . println ( "prince validation finished..." ) ; }
tr	2	public void testlineserieschart ( ) { lineserieschart < number , number > chart = new lineserieschart < number , number > ( "curves" , "x" , "y" ) ; collection < lineseriesitem < number , number >> linhasin = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhasin . add ( new lineseriesitem < number , number > ( i , math . sin ( i ) + 4 ) ) ; } chart . addvalue ( linhasin ) ; collection < lineseriesitem < number , number >> linhacos = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhacos . add ( new lineseriesitem < number , number > ( i , math . cos ( i ) ) ) ; } chart . addvalue ( linhacos ) ; collection < lineseriesitem < number , number >> linhaexp = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaexp . add ( new lineseriesitem < number , number > ( i , math . exp ( i ) + 1 ) ) ; } chart . addvalue ( linhaexp ) ; collection < lineseriesitem < number , number >> linhareta = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhareta . add ( new lineseriesitem < number , number > ( i , i ) ) ; } chart . addvalue ( linhareta ) ; highlighter highlighter = criarhighlighter ( ) ; chart . getchartconfiguration ( ) . sethighlighter ( highlighter ) ; chart . addserie ( criarserie ( "seno" , "#489104" ) ) ; chart . addserie ( criarserie ( "coseno" , "#c91212" ) ) ; chart . addserie ( criarserie ( "exponensial" , "#7d02b2" ) ) ; chart . addserie ( criarserie ( "reta" , "#066fa7" ) ) ; legend legend = new legend ( true , location . ne ) ; legend . setplacement ( "outsidegrid" ) ; chart . setlegend ( legend ) ; axis < string > axis = new axisstring ( ) ; axis . setlabelrenderer ( jqplotresources . canvasaxislabelrenderer ) ; chart . setaxesdefaults ( axis ) ; axes axes = chart . getaxes ( ) ; xaxis xaxis = axes . getxaxis ( ) ; tickoptions tickoptions = new tickoptions ( ) ; tickoptions . setangle ( 270 ) ; tickoptions . setlabelposition ( "end" ) ; xaxis . settickoptions ( tickoptions ) ; xaxis . settickrenderer ( jqplotresources . canvasaxistickrenderer ) ; xaxis . settickinterval ( 1 ) ; axes . getyaxis ( ) . settickinterval ( 0.50 ) ; axes . getyaxis ( ) . setmax ( 8.50 ) ; axes . getyaxis ( ) . setmin ( - 1.50 ) ; tickoptions tickoptionsy = new tickoptions ( ) ; tickoptionsy . setformatstring ( "%.2f" ) ; axes . getyaxis ( ) . settickoptions ( tickoptionsy ) ; grid grid = new grid ( ) ; grid . setbackground ( "#ffffff" ) ; grid . setgridlinecoler ( "#a0a0a0" ) ; chart . getchartconfiguration ( ) . setgrid ( grid ) ; cursor cursor = new cursor ( ) ; cursor . setzoom ( true ) ; cursor . setclickreset ( true ) ; chart . getchartconfiguration ( ) . setcursor ( cursor ) ; string json = jqplotutils . createjquery ( chart , "div3" ) ; json = json . replaceall ( "\\$" , "jquery" ) ; system . out . println ( json ) ; }
tr	2	@ override public void newentry ( sourcetextentry active_entry ) { if ( current_file_node != null && active_entry != null ) { last_edited_text = core . geteditor ( ) . getcurrenttranslation ( ) ; caretupdates_to_ignore = 1 ; sessionlog . getmenu ( ) . setpausetimestamp ( 0 ) ; sessionlog . getmenu ( ) . getpausetiming ( ) . setselected ( false ) ; element element = newelement ( "segment" , true ) ; element . setattribute ( "number" , integer . tostring ( core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ) ) ; element source_element = newelement ( "source" , false ) ; source_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrententry ( ) . getsrctext ( ) ) ) ; element . appendchild ( source_element ) ; element target_element = newelement ( "initialtarget" , false ) ; target_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrenttranslation ( ) ) ) ; element . appendchild ( target_element ) ; current_entry_node = element ; current_file_node . appendchild ( current_entry_node ) ; current_editions_node = newelement ( "events" , false ) ; chosen_entry_time = system . nanotime ( ) ; current_segment_number = core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ; } }
tr	3	public void publishmessage ( ) throws namingexception , jmsexception { system . out . println ( "publishing message..." ) ; try ( topicconnection topicconnection = topicconnfactory . createtopicconnection ( ) ; topicsession topicsession = topicconnection . createtopicsession ( false , topicsession . auto_acknowledge ) ; ) { topic createdtopic = topicsession . createtopic ( "javaee" ) ; topicconnection . start ( ) ; textmessage textmessage = topicsession . createtextmessage ( "this is a test message" ) ; try ( javax . jms . topicpublisher topicpublisher = topicsession . createpublisher ( createdtopic ) ) { topicpublisher . publish ( textmessage ) ; setmessage ( "message published" ) ; } } }
tr	1	public void testiscornerfield ( ) { begintest ( "iscornerfield method" ) ; boolean result ; result = board . iscornerfield ( new coordinate ( 0 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(0  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 0 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(0  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(7  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(7  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 3 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(3  7)" , false , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 8 ) ) ; assertequals ( "iscornerfield(new coordinate(7  8)" , false , result ) ; }
tr	5	public string format ( logrecord r ) { stringbuffer sb = new stringbuffer ( ) ; sb . append ( r . getlevel ( ) . getname ( ) + "\t" ) ; sb . append ( messageformat . format ( "{0  date  yy-mm-dd} {0  time  kk:mm:ss.ssss} " , new object [ ] { new date ( r . getmillis ( ) ) } ) + "\t" ) ; string cnm = r . getsourceclassname ( ) ; string cn = "" ; if ( cnm != null ) { int cnl = cnm . length ( ) ; if ( cnl > 20 ) { cn = r . getsourceclassname ( ) . substring ( cnl - 19 ) ; } else { char sp [ ] = {   } ; stringbuffer sb1 = new stringbuffer ( ) . append ( cnm ) ; cn = sb1 . append ( sp , 0 , 1 ) . tostring ( ) ; } } sb . append ( cn + "\t" ) . append ( " " ) ; sb . append ( left ( r . getsourcemethodname ( ) , 23 ,   ) + "\t" ) ; sb . append ( r . getthreadid ( ) + "\t" ) ; sb . append ( formatmessage ( r ) ) . append ( ls ) ; if ( null != r . getthrown ( ) ) { sb . append ( "throwable occurred: " ) ; throwable t = r . getthrown ( ) ; printwriter pw = null ; try { stringwriter sw = new stringwriter ( ) ; pw = new printwriter ( sw ) ; t . printstacktrace ( pw ) ; sb . append ( sw . tostring ( ) ) ; } finally { if ( pw != null ) { try { pw . close ( ) ; } catch ( exception e ) { } } } } return sb . tostring ( ) ; }
tr	4	public void actionperformed ( actionevent e ) { string login = principal . getlogin ( ) ; string senha = principal . getsenha ( ) ; logininterface logininterface = new logininterface ( ) ; funcionario funcionario = null ; try { funcionario = logininterface . logarusuario ( login , senha ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } string respostausuario = "" ; if ( funcionario != null ) { if ( funcionario . getnivelacesso ( ) ) { try { usuariologado usuariologado = usuariologado . getinstancia ( ) ; usuariologado . setusuariologado ( funcionario ) ; operacaolog log = new operacaolog ( ) ; log . setdata ( new timestamp ( system . currenttimemillis ( ) ) ) ; log . setdescricao ( "logon de administrador: " + funcionario . getnome ( ) ) ; log . setfuncionario ( usuariologado . getinstancia ( ) . getusuariologado ( ) ) ; log . setoperacao ( "logon de administrador" ) ; operacaologdao operacaologdao = new operacaologdao ( ) ; operacaologdao . persiste ( log ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } principal . dispose ( ) ; administrador . main ( null ) ; } else { respostausuario = "erro  acesso n\u00e3o permitido!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } } else { respostausuario = "erro  credenciais inv\u00e1lidas!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } e . getactioncommand ( ) ; }
tr	3	public ratelimitstatus ( response res ) throws weiboexception { super ( res ) ; jsonobject json = res . asjsonobject ( ) ; try { jsonarray list = json . getjsonarray ( "api_rate_limits" ) ; int size = list . length ( ) ; apiratelimit = new arraylist < apiratelimits > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { apiratelimit . add ( new apiratelimits ( list . getjsonobject ( i ) ) ) ; } iplimit = json . getint ( "ip_limit" ) ; remainingiphits = json . getint ( "remaining_ip_hits" ) ; remaininguserhits = json . getlong ( "remaining_user_hits" ) ; resettime = json . getstring ( "reset_time" ) ; resettimeinseconds = json . getint ( "reset_time_in_seconds" ) ; userlimit = json . getlong ( "user_limit" ) ; } catch ( jsonexception jsone ) { throw new weiboexception ( jsone . getmessage ( ) + ":" + json . tostring ( ) , jsone ) ; } }
tr	2	public static string replaceall ( string origin , string oldpart , string replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldpart == null || oldpart . length ( ) == 0 ) { return origin ; } int index = origin . indexof ( oldpart ) ; if ( index < 0 ) { return origin ; } stringbuffer sb = new stringbuffer ( origin ) ; do { sb . replace ( index , index + oldpart . length ( ) , replacement ) ; origin = sb . tostring ( ) ; index = origin . indexof ( oldpart ) ; } while ( index != - 1 ) ; return origin ; }
tr	5	public static synchronized int adduser ( string roomname , user user ) { for ( gameroom room : briscagames ) { if ( room . getname ( ) . equals ( roomname ) ) { for ( player player : room . getplayers ( ) ) { if ( player == null ) continue ; if ( player . getuser ( ) . getusername ( ) . equals ( user . getusername ( ) ) ) { player . setuser ( user ) ; return player . getseatnumber ( ) ; } } return room . addplayer ( player . getinstance ( 0 , user ) ) ; } } return - 1 ; }
tr	5	public static void main ( string [ ] args ) { try { if ( args . length > 0 ) { for ( string arg : args ) { arg = arg . trim ( ) ; if ( arg . matches ( "app_root_dir=\\s*\\w+\\s*" ) ) { jediormengine . app_root_dir = arg ; } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( arg . equals ( "web_app" ) ) { jediormengine . web_app = true ; } if ( arg . matches ( "debug=\\s*true\\s*" ) ) { jediormengine . debug = true ; } else if ( arg . matches ( "debug=\\s*false\\s*" ) ) { jediormengine . debug = false ; } else { } } } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( jediormengine . web_app ) { jediormengine . app_src_dir = string . format ( "%s%sweb%sweb-inf%ssrc" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sconfig%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator , file . separator ) ; file dbconfigfile = new file ( jediormengine . app_db_config_file ) ; if ( ! dbconfigfile . exists ( ) ) { jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; } } else { jediormengine . app_src_dir = string . format ( "%s%ssrc" , jediormengine . app_root_dir , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sdatabase.properties" , jediormengine . app_root_dir , file . separator ) ; } jediormengine . syncdb ( jediormengine . app_src_dir ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	1	public static long pack ( long big , int little , int bits ) { assert bits > 32 && bits < 64 ; assert big < ( 1 << bits ) ; assert little < ( 1 << ( 64 - bits ) ) ; int ls = bits & 7 ; int bm = ( 1 << ls ) - 1 ; long res = ( big & ~ bm ) << ( 64 - bits ) ; res |= ( little & ( ( 1 << ( 64 - bits ) ) - 1 ) ) << ls ; res |= big & bm ; return res ; }
tr	5	public confirmpurchase ( final srtype . transaction trans , final srtype . transactionlist translist , final srtype . inventory inv , final jtextpane transtpanel , final jlabel pricelabel ) { setdefaultcloseoperation ( jdialog . dispose_on_close ) ; setalwaysontop ( true ) ; setresizable ( false ) ; settitle ( "confirm purchase" ) ; setbounds ( 100 , 100 , 325 , 114 ) ; getcontentpane ( ) . setlayout ( new borderlayout ( ) ) ; contentpanel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; getcontentpane ( ) . add ( contentpanel , borderlayout . center ) ; contentpanel . setlayout ( null ) ; { jlabel lblconfirmpurchaseof = new jlabel ( "confirm purchase of:" ) ; lblconfirmpurchaseof . setbounds ( 6 , 24 , 133 , 16 ) ; contentpanel . add ( lblconfirmpurchaseof ) ; } { jlabel lblrm = new jlabel ( "rm" + trans . totalprice ) ; lblrm . setfont ( new font ( "lucida grande" , font . plain , 26 ) ) ; lblrm . setbounds ( 151 , 6 , 293 , 42 ) ; contentpanel . add ( lblrm ) ; } { jpanel buttonpane = new jpanel ( ) ; buttonpane . setlayout ( new flowlayout ( flowlayout . right ) ) ; getcontentpane ( ) . add ( buttonpane , borderlayout . south ) ; { jbutton okbutton = new jbutton ( "ok" ) ; okbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { trans . confirmpurchase ( inv ) ; loaders . saveinventory ( inv ) ; inventoryreport invrep = loaders . loadinventoryreport ( ) ; invrep . addinvtolog ( inv ) ; loaders . saveinventoryreport ( invrep ) ; translist . addtrans ( trans ) ; transactionreport transrep = loaders . loadtransactionreport ( ) ; transrep . addtranslist ( translist ) ; loaders . savetransactionreport ( transrep ) ; transtpanel . settext ( "" ) ; pricelabel . settext ( "rm0.00" ) ; setvisible ( false ) ; dispose ( ) ; } } ) ; okbutton . setactioncommand ( "ok" ) ; buttonpane . add ( okbutton ) ; getrootpane ( ) . setdefaultbutton ( okbutton ) ; buttonpane . requestfocus ( ) ; } { jbutton cancelbutton = new jbutton ( "cancel" ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { setvisible ( false ) ; dispose ( ) ; } } ) ; cancelbutton . setactioncommand ( "cancel" ) ; buttonpane . add ( cancelbutton ) ; } } }
tr	1	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; double pi = 3.14 ; system . out . print ( "please enter radius : " ) ; double r = in . nextdouble ( ) ; double circlearea = pi * r * r ; double roundcircle = 2 * pi * r ; double surfacecircle = 4 * pi * r ; double volumecircle = 1.33 * pi * r * r * r ; system . out . println ( "circlearea : " + circlearea ) ; system . out . println ( "roundcircle : " + roundcircle ) ; system . out . println ( "surfacecircle : " + surfacecircle ) ; system . out . println ( "volumecircle : " + volumecircle ) ; }
tr	2	public int moveframe ( frame frame , int currentindexofpreviousitem ) { animation oldparent = frame . getparent ( ) ; if ( currentindexofpreviousitem == - 1 ) { oldparent . frames . remove ( frame ) ; frames . add ( 0 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return 0 ; } frame previousframe = getframe ( currentindexofpreviousitem ) ; if ( previousframe == frame ) return currentindexofpreviousitem ; else { oldparent . frames . remove ( frame ) ; int newindexofpreviousitem = getframeindex ( previousframe ) ; frames . add ( newindexofpreviousitem + 1 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return newindexofpreviousitem + 1 ; } }
tr	5	@ override public map < statstype , longsummarystatistics > call ( ) throws ioexception { final longsummarystatistics inittimestats = new longsummarystatistics ( ) ; final longsummarystatistics symboltimestats = new longsummarystatistics ( ) ; final longsummarystatistics dectimestats = new longsummarystatistics ( ) ; final longsummarystatistics totaldecsstats = new longsummarystatistics ( ) ; final longsummarystatistics numdecfailsstats = new longsummarystatistics ( totaldecsstats ) ; final longsummarystatistics decfailtimestats = new longsummarystatistics ( ) ; final bytebuffer dataheaderbuf = dataheader . allocatenewbuffer ( ) ; final bytebuffer symbolheaderbuf = symbolheader . allocatenewbuffer ( ) ; for ( int n = 0 ; n < numiterations ; n ++ ) { dataheaderbuf . clear ( ) ; readbytes ( dataheaderbuf ) ; final dataheader dataheader = dataheader . parsedataheader ( dataheaderbuf ) ; final fecparameters fecparams = dataheader . getfecparams ( ) ; final int extrasymbols = dataheader . getextrasymbols ( ) ; final bytebuffer symbolbuf = bytebuffer . allocate ( fecparams . symbolsize ( ) ) ; final arraydatadecoder datadec = initdatadecoder ( fecparams , extrasymbols , inittimestats ) ; final int z = datadec . numberofsourceblocks ( ) ; for ( int sbn = 0 ; sbn < z ; sbn ++ ) { final sourceblockdecoder srcblockdec = datadec . decoderforsourceblock ( sbn ) ; final int totalsymbols = srcblockdec . numberofsourcesymbols ( ) + extrasymbols ; for ( int i = 0 ; i < totalsymbols ; ) { symbolheaderbuf . clear ( ) ; readbytes ( symbolheaderbuf ) ; final symbolheader symbolheader = symbolheader . parsesymbolheader ( symbolheaderbuf , fecparams , sbn ) ; final int firstesi = symbolheader . getfecpayloadid ( ) . encodingsymbolid ( ) ; final int numsymbolsinpacket = symbolheader . getnumsymbols ( ) ; for ( int s = 0 ; s < numsymbolsinpacket ; s ++ ) { symbolbuf . clear ( ) ; readbytes ( symbolbuf ) ; putsymbol ( srcblockdec , firstesi + s , symbolbuf , symboltimestats , dectimestats , decfailtimestats , totaldecsstats , numdecfailsstats ) ; } i += numsymbolsinpacket ; } } checkdata ( datadec ) ; } final enummap < statstype , longsummarystatistics > map = new enummap < > ( statstype . class ) ; map . put ( statstype . decoder_init_time , inittimestats ) ; map . put ( statstype . symbol_input_time , symboltimestats ) ; map . put ( statstype . decoding_time , dectimestats ) ; map . put ( statstype . num_decoding_failures , numdecfailsstats ) ; if ( numdecfailsstats . getcount ( ) > 0 ) { map . put ( statstype . decoding_failure_time , decfailtimestats ) ; } return map ; }
tr	4	private int findplaceholderendindex ( charsequence buf , int startindex ) { int index = startindex + this . placeholderprefix . length ( ) ; int withinnestedplaceholder = 0 ; while ( index < buf . length ( ) ) { if ( stringutils . substringmatch ( buf , index , this . placeholdersuffix ) ) { if ( withinnestedplaceholder > 0 ) { withinnestedplaceholder -- ; index = index + this . placeholdersuffix . length ( ) ; } else { return index ; } } else if ( stringutils . substringmatch ( buf , index , this . simpleprefix ) ) { withinnestedplaceholder ++ ; index = index + this . simpleprefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
tr	4	public void run ( ) { if ( logger . getdebugvalue ( ) == 3 ) { system . out . println ( "run() of " + thread . currentthread ( ) . getname ( ) + " is called." ) ; } string word ; set < musicinfo > info_found ; while ( ( word = readfile . readwordfromsearchfile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { iterator < musicinfo > iter = info_found . iterator ( ) ; while ( iter . hasnext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	1	list < row > fit ( row row ) { list < string > options = piecesof ( row . option , optionwidth ) ; list < string > descriptions = piecesof ( row . description , descriptionwidth ) ; list < row > rows = new arraylist < row > ( ) ; for ( int i = 0 ; i < math . max ( options . size ( ) , descriptions . size ( ) ) ; ++ i ) rows . add ( new row ( itemorempty ( options , i ) , itemorempty ( descriptions , i ) ) ) ; return rows ; }
tr	1	private void printaucpoints ( treeset < xypair > xydata ) { printtofile pf = new printtofile ( ) ; pf . openfile ( classify . datapath + "results" + classify . / + "auc" + classify . / + "" + classify . inttocat . get ( classify . category ) + classify . / + "" + classify . filename + "_aucpoints.csv" ) ; xydata . add ( new xypair ( 0 , 0 ) ) ; xydata . add ( new xypair ( 1 , 1 ) ) ; for ( xypair pair : xydata ) pf . writetofile ( pair . getx ( ) + " " + pair . gety ( ) ) ; pf . closefile ( ) ; }
tr	2	public void createrestartfile ( string header , int dateindex , int depthindex ) { file infile = new file ( header ) ; string outputname = outputfolder + "/" + sdf . format ( releasedates [ dateindex ] ) + "_" + mindepths [ depthindex ] + "-" + maxdepths [ depthindex ] + ".prm" ; file outfile = new file ( restartfile ) ; try { copyfileusingstream ( infile , outfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try ( bufferedwriter bw = new bufferedwriter ( new filewriter ( outfile , true ) ) ; ) { bw . write ( "(java " + prms + " -jar " + jarfile + " " + outputname + " " + configurationfile + " " + source + " > " + logdir + "/" + prefix + dateindex + "d" + depthindex + ".log)&\n" ) ; bw . write ( cronstring ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	private void printmap ( ) { system . out . print ( "     " ) ; for ( int i = 0 ; i < map . getmapwidth ( ) ; i ++ ) { system . out . print ( string . format ( " %02d   " , i ) ) ; } system . out . println ( ) ; for ( int i = 0 ; i < map . getmapheight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getmapwidth ( ) ; j ++ ) { if ( j == 0 ) system . out . print ( string . format ( "%02d" , i ) ) ; system . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getstartcell ( ) ) { system . out . print ( "**s**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getgoalcell ( ) ) { system . out . print ( "**g**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isobstacle ) { system . out . print ( "|||||" ) ; continue ; } string rhssymbol = map . cells [ i ] [ j ] . rhs == integer . max_value ? "m" : long . tostring ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestpath != null && this . shortestpath . contains ( map . cells [ i ] [ j ] ) ) { system . err . print ( string . format ( "..%2s." , rhssymbol ) ) ; } else { system . out . print ( string . format ( "..%2s." , rhssymbol ) ) ; } } system . out . println ( ) ; } }
tr	4	public static void print ( jtextcomponent textcomponent ) throws textcomponentutilexception { inputstream is = null ; try { printservice [ ] printservices = printservicelookup . lookupprintservices ( docflavor . input_stream . autosense , null ) ; if ( printservices . length > 0 ) { printrequestattributeset printrequestattributeset = new hashprintrequestattributeset ( ) ; printrequestattributeset . add ( new jobname ( "jaligner" , null ) ) ; printservice service = serviceui . printdialog ( null , 50 , 50 , printservices , printservicelookup . lookupdefaultprintservice ( ) , docflavor . input_stream . autosense , printrequestattributeset ) ; if ( service != null ) { docprintjob printjob = service . createprintjob ( ) ; printjobmointor printjobmointor = new printjobmointor ( printjob ) ; is = new bytearrayinputstream ( textcomponent . gettext ( ) . getbytes ( ) ) ; documentname documentname = new documentname ( "jaligner" , null ) ; hashdocattributeset docattributeset = new hashdocattributeset ( ) ; docattributeset . add ( documentname ) ; doc doc = new simpledoc ( is , docflavor . input_stream . autosense , docattributeset ) ; printjob . print ( doc , printrequestattributeset ) ; printjobmointor . waitforprintjob ( ) ; } } else { throw new textcomponentutilexception ( "no print service found!" ) ; } } catch ( exception e ) { throw new textcomponentutilexception ( e . getmessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "failed closing input stream: " + e . getmessage ( ) , e ) ; } } } }
tr	2	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new arraylist < plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getmodule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerde ( this . vecteur_vitesse ) ; this . plots . add ( new plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
tr	3	public static < t , r > r callmemoized ( final bifunction < function < t , r > , t , r > function , final t input ) { function < t , r > memoized = new function < t , r > ( ) { { system . out . println ( "new function called" ) ; } private final map < t , r > store = new hashmap < > ( ) ; public r apply ( final t input ) { return store . computeifabsent ( input , key -> function . apply ( this , key ) ) ; } } ; return memoized . apply ( input ) ; }
tr	3	private void doprint ( string s ) { for ( int newline = s . indexof ( 
 ) ; newline >= 0 ; newline = s . indexof ( 
 ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
tr	4	public vector < vector < object >> getfoldercontentstable ( ) { vector < vector < object >> tabledata = new vector < > ( ) ; list < fileinfo > files = getfoldercontents ( ) ; logger . debug ( "found " + files . size ( ) + " entries for " + path . tostring ( ) ) ; for ( fileinfo file : files ) { vector < object > row = null ; if ( file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/folder.png" ) ) ; } else { row . add ( new imageicon ( "res/folder_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } for ( fileinfo file : files ) { vector < object > row = null ; if ( ! file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/file.png" ) ) ; } else { row . add ( new imageicon ( "res/file_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } return tabledata ; }
tr	5	@ override public void characters ( char [ ] c , int start , int length ) { if ( length > 0 ) { boolean wr = true ; try { if ( innote && ! shownote ) { wr = false ; } if ( inheader && ! showheader ) { wr = false ; } if ( inforeign ) { } if ( indocedition ) { wr = false ; } if ( inabbr && wr ) { if ( abbrcontent == null ) { abbrcontent = new stringbuilder ( ) ; } abbrcontent . append ( c , start , length ) ; wr = false ; } if ( wr ) { buffer . append ( c , start , length ) ; } } catch ( java . nio . bufferoverflowexception x ) { system . err . println ( "insufficient text buffer size" ) ; system . exit ( 1 ) ; } } }
tr	2	@ override public string evaluatepolicy ( float max_risk , transferredfile policyfiletotransfer , transferredfile dbsqldumpfiletotransfer , string table_name ) { random generator = new random ( system . currenttimemillis ( ) ) ; long gid = generator . nextlong ( ) ; if ( gid < 0 ) gid = gid * ( - 1 ) ; tempfiles tf = new tempfiles ( ) ; file dbdumptempfile = null ; file policytempfile = null ; try { dbdumptempfile = tf . createtempfile ( dbsqldumpfiletotransfer ) ; policytempfile = tf . createtempfile ( policyfiletotransfer ) ; dbdumptempfile . deleteonexit ( ) ; policytempfile . deleteonexit ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } dba_factory . evaluatepolicy ( policytempfile , dbdumptempfile , null , gid , table_name , false ) ; return "id: --" + gid + "--" ; }
tr	3	public static void main ( string [ ] args ) { salariedemployee salariedemployee = new salariedemployee ( "john" , "smith" , "111-11-1111" , 800.00 ) ; hourlyemployee hourlyemployee = new hourlyemployee ( "karen" , "price" , "222-22-2222" , 16.75 , 40 ) ; commissionemployee commissionemployee = new commissionemployee ( "sue" , "jones" , "333-33-3333" , 10000 , .06 ) ; basepluscommissionemployee basepluscommissionemployee = new basepluscommissionemployee ( "bob" , "lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; system . out . println ( "employees processed individually:\n" ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , salariedemployee , "earned" , salariedemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyemployee , "earned" , hourlyemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , commissionemployee , "earned" , commissionemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , basepluscommissionemployee , "earned" , basepluscommissionemployee . earnings ( ) ) ; employee [ ] employees = new employee [ 4 ] ; employees [ 0 ] = salariedemployee ; employees [ 1 ] = hourlyemployee ; employees [ 2 ] = commissionemployee ; employees [ 3 ] = basepluscommissionemployee ; system . out . println ( "employees processed polymorphically:\n" ) ; for ( employee currentemployee : employees ) { system . out . println ( currentemployee ) ; if ( currentemployee instanceof basepluscommissionemployee ) { basepluscommissionemployee employee = ( basepluscommissionemployee ) currentemployee ; employee . setbasesalary ( 1.10 * employee . getbasesalary ( ) ) ; system . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getbasesalary ( ) ) ; } system . out . printf ( "earned $% .2f\n\n" , currentemployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) system . out . printf ( "employee %d is a %s\n" , j , employees [ j ] . getclass ( ) . getname ( ) ) ; }
tr	5	public void playrecording ( file file ) { if ( slave != null ) { int amount = 0 ; try { livedata = false ; fileinputstream fis = new fileinputstream ( file ) ; objectinputstream insize = new objectinputstream ( fis ) ; while ( true ) { insize . readobject ( ) ; amount ++ ; } } catch ( exception e ) { } try { system . out . println ( amount ) ; fileinputstream fis = new fileinputstream ( file ) ; objectinputstream in = new objectinputstream ( fis ) ; packet p = null ; int count = 0 ; int start ; int border ; if ( ! sciencetool . _split_values ) { if ( sciencetool . getparameter ( "slittpart" ) == 1.0 ) { start = 0 ; border = amount / 2 ; } else { start = amount / 2 ; border = amount ; } } else { start = 0 ; border = amount ; } while ( true ) { p = ( packet ) in . readobject ( ) ; count ++ ; if ( count >= start && count < border ) this . messagereceivedwithtimestamp ( p . adress , new snoopbcmsg ( p . data , 8 ) , p . time , true ) ; } } catch ( eofexception e ) { } catch ( classnotfoundexception ex ) { logger . getlogger ( datasource . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception e ) { system . out . println ( file . getpath ( ) ) ; e . printstacktrace ( ) ; } livedata = true ; } }
tr	3	public arithmeticparser ( string [ ] programsource ) throws parserparsingexception { super ( programsource [ programsource . length - 1 ] ) ; this . context = new evaluationcontext ( ) ; for ( int i = 0 ; i < programsource . length - 1 ; i ++ ) { string [ ] parts = programsource [ i ] . replace ( " " , "" ) . split ( "=" ) ; tree tree = new expressionstreeparser ( parts [ 1 ] ) . getroottree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { matcher matcher = function_definition_pattern . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new runtimeexception ( "wrong definition" ) ; string functionname = matcher . group ( 1 ) ; string argumentname = matcher . group ( 2 ) ; context . addfunctionvalue ( functionname , argumentname , tree ) ; } else { context . addvarvalue ( parts [ 0 ] , tree ) ; } } }
tr	2	private string getorientationstring ( orientations o ) { string os = "unknown" ; if ( o == orientations . horizontal ) os = "horizontal" ; if ( o == orientations . left ) os = "90\u00b0 left" ; if ( o == orientations . right ) os = "90\u00b0 right" ; if ( o == orientations . upside ) os = "180\u00b0" ; if ( mytfttype == tfttypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( mytfttype == tfttypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( mytfttype == tfttypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	1	protected synchronized void update ( ) { date now = new date ( ) ; long delta = now . gettime ( ) - lastupdate . gettime ( ) ; if ( isdead ( ) ) return ; point oldpos = new point ( x , y ) ; point dir = new point ( speed . getdirectionx ( ) , speed . getdirectiony ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updateposx ( delta ) ; if ( dir . y != 0 ) blocked |= ! updateposy ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldpos . equals ( this ) ) lastupdate = now ; }
tr	3	public void changepanel ( jpanel panel ) { this . getcontentpane ( ) . removeall ( ) ; if ( panel != loginpanel ) { this . add ( actionbar ) ; if ( panel == connectionpanel ) { connectionpanel . initialize ( ) ; } else if ( panel == directorylistpanel ) { directorylistpanel . initialize ( ) ; } else if ( panel == filelistpanel ) { filelistpanel . initialize ( ) ; } } else { loginpanel . initialize ( ) ; actionbar . initialize ( ) ; } if ( ! actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getbackstack ( ) . push ( currentpanel ) ; } else if ( actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getforwardstack ( ) . push ( currentpanel ) ; } currentpanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	4	protected final object computerange ( ) { final list < double [ ] > rarange = new arraylist < double [ ] > ( ) ; final double [ ] decrange = new double [ 2 ] ; if ( this . ispolescollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isnorthpolecollision ( ) ) { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . issouthpolecollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; if ( this . isborderracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . ismaxracollision ( ) ) { rarange . add ( new double [ ] { rauser - sizearray [ 0 ] / 2.0 , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isminracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , rauser + sizearray [ 0 ] / 2.0 } ) ; rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } } return arrays . aslist ( rarange , decrange ) ; }
tr	4	tester ( long _seed ) throws exception { loadwords ( ) ; setseed ( _seed ) ; setdefaultcloseoperation ( exit_on_close ) ; c = new testercanvas ( ) ; c . setpreferredsize ( new dimension ( 600 , 400 ) ) ; container cp = getcontentpane ( ) ; cp . setlayout ( new borderlayout ( ) ) ; cp . add ( c , borderlayout . center ) ; cp . add ( c . seedtext , borderlayout . north ) ; jpanel jp = new jpanel ( ) ; jbutton e = new jbutton ( "english" ) ; e . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( ewords . size ( ) ) ; string word = ewords . get ( index ) ; c . english = word ; c . portuguese = null ; count ++ ; c . repaint ( ) ; } } ) ; jbutton p = new jbutton ( "portuguese" ) ; p . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( pwords . size ( ) ) ; system . out . println ( "index = " + index ) ; string word = pwords . get ( index ) ; c . english = null ; c . portuguese = word ; count ++ ; c . repaint ( ) ; } } ) ; jbutton t = new jbutton ( "translate" ) ; t . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { if ( c . english != null ) { c . portuguese = e2p . get ( c . english ) ; } else if ( c . portuguese != null ) { c . english = p2e . get ( c . portuguese ) ; } c . repaint ( ) ; } } ) ; jbutton r = new jbutton ( "reset" ) ; r . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { setseed ( seed ) ; c . repaint ( ) ; } } ) ; jp . setlayout ( new flowlayout ( ) ) ; jp . add ( e ) ; jp . add ( t ) ; jp . add ( p ) ; jp . add ( r ) ; cp . add ( jp , borderlayout . south ) ; pack ( ) ; setvisible ( true ) ; }
tr	5	private void addguesttobookingbuttonactionperformed ( java . awt . event . actionevent evt ) { boolean addguestsuccess ; booking currentbooking = ctr . getcurrentbooking ( ) ; if ( currentbooking != null && guestjlist2 . getselectedvalue ( ) != null ) { guest guest = ( guest ) guestjlist2 . getselectedvalue ( ) ; if ( ! addedguestsmodel . contains ( guest ) ) { if ( ctr . checkroomavailability ( currentbooking , addedguestsmodel . getsize ( ) ) > 0 ) { addguestsuccess = ctr . createbookingdetail ( guest , currentbooking ) ; if ( addguestsuccess ) { addedguestsmodel . addelement ( guest ) ; addedguestsjlist . setmodel ( addedguestsmodel ) ; joptionpane . showmessagedialog ( this , guest . getfirstname ( ) + " " + guest . getlastname ( ) + " added to roomno " + currentbooking . getroomno ( ) ) ; } else { joptionpane . showmessagedialog ( this , "could not add guest to room.\nguest might already be booked to a room in that period." , "error." , joptionpane . information_message ) ; } } else { joptionpane . showmessagedialog ( this , "cannot add guest because room is full!" , "room is full." , joptionpane . information_message ) ; } } else { joptionpane . showmessagedialog ( this , "guest already added!" , "error." , joptionpane . information_message ) ; } } }
tr	4	private void initalleles ( ) { for ( int acindex = 0 ; acindex < accessioncount ; acindex ++ ) { for ( int mindex = 0 ; mindex < markercount ; mindex ++ ) { int alcnt = allelename . get ( mindex ) . size ( ) ; datamatrix . get ( acindex ) . set ( mindex , new arraylist < double > ( alcnt ) ) ; for ( int alindex = 0 ; alindex < alcnt ; alindex ++ ) { datamatrix . get ( acindex ) . get ( mindex ) . add ( null ) ; } } } }
tr	4	private void addmountansides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existtileoftype ( new mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new mountainside ( ) ) ; map [ i ] [ j + 2 ] . add ( new mountainside ( ) ) ; } } } }
tr	4	public boolean connect ( sharingpeer peer ) { boolean retry = false ; boolean sentobfuscatedhandshake = false ; do { socket socket = new socket ( ) ; inetsocketaddress address = new inetsocketaddress ( peer . getip ( ) , peer . getport ( ) ) ; logger . info ( "connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( ioexception ioe ) { logger . warn ( "could not connect to " + peer + ": " + ioe . getmessage ( ) ) ; return false ; } try { byte [ ] remotepeerid = ( peer . haspeerid ( ) ? peer . getpeerid ( ) . array ( ) : null ) ; if ( this . forceobfuscation ) sentobfuscatedhandshake = this . sendobfuscatedhandshake ( socket , remotepeerid , this . forceobfuscation ) ; else sentobfuscatedhandshake = this . sendhandshake ( socket , remotepeerid , peer . supportsobfuscation ( ) ) ; handshake hs = this . validatehandshake ( socket , ( peer . haspeerid ( ) ? peer . getpeerid ( ) . array ( ) : null ) ) ; this . firenewpeerconnection ( socket , hs . getpeerid ( ) ) ; return true ; } catch ( parseexception pe ) { logger . info ( "invalid handshake from " + this . socketrepr ( socket ) + ": " + pe . getmessage ( ) ) ; if ( sentobfuscatedhandshake && peer . supportsobfuscation ( ) ) { peer . supportsobfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( ioexception e ) { } } catch ( ioexception ioe ) { logger . info ( "an error occured while reading an incoming " + "handshake: " + ioe . getmessage ( ) ) ; try { if ( ! socket . isclosed ( ) ) socket . close ( ) ; } catch ( ioexception e ) { } } } while ( retry ) ; return false ; }
tr	3	public static armour createarmourfromreader ( string armourstring ) { string [ ] values = armourstring . split ( " " ) ; armour armour = new armour ( ) ; try { armour . setname ( values [ 0 ] ) ; armour . setcost ( integer . parseint ( values [ 1 ] ) ) ; armour . setweight ( integer . parseint ( values [ 2 ] ) ) ; armour . setac ( integer . parseint ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { string [ ] specials = values [ 4 ] . split ( " " ) ; armour = armour . applyspecialtraits ( armour , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading armour object" ) ; if ( armour . getname ( ) != null ) system . out . println ( armour . getname ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	5	public void creerressources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new arraylist < case > ( ) ; list < case > availables = new arraylist < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getniveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( configurationloader . max_ressources_spawns < availables . size ( ) ) { for ( int i = 0 ; i < configurationloader . max_ressources_spawns ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new random ( ) . nextint ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new random ( ) . nextint ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new random ( ) . nextint ( 5 ) + 1 ) ) * configurationloader . abondance_multiplicator ; if ( quantite > 0 ) { where . ajouterressource ( new ressource ( quantite ) ) ; } }
tr	1	public region ( byte renderruleflags [ ] [ ] [ ] , int vertexheights [ ] [ ] [ ] ) { lowestplane = 99 ; regionsizex = 104 ; regionsizey = 104 ; this . vertexheights = vertexheights ; this . renderruleflags = renderruleflags ; underlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayclippingpaths = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayorientations = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; tilecullingbitsets = new int [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tileshadowintensity = new byte [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tilelightintensity = new int [ regionsizex + 1 ] [ regionsizey + 1 ] ; blendedhue = new int [ regionsizey ] ; blendedsaturation = new int [ regionsizey ] ; blendedlightness = new int [ regionsizey ] ; blendedhuedivisor = new int [ regionsizey ] ; blenddirectiontracker = new int [ regionsizey ] ; }
tr	4	private jpanel makeclientlistpanel ( ) { jpanel result = new jpanel ( new borderlayout ( ) ) ; clientlist = new clientlist ( ) ; clientlist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent e ) { if ( clientlist . getselectedid ( ) == - 1 ) { btkick . setenabled ( false ) ; } else { btkick . setenabled ( true ) ; } } } ) ; result . add ( clientlist , borderlayout . center ) ; btkick = new jbutton ( "kick" ) ; btkick . setenabled ( false ) ; btkick . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { kick ( ) ; } } ) ; btkick . addkeylistener ( new keyadapter ( ) { @ override public void keypressed ( keyevent e ) { kick ( ) ; } } ) ; result . add ( btkick , borderlayout . south ) ; return result ; }
tr	2	public void createannouncement ( ) { usersession usersession = ( usersession ) facescontext . getcurrentinstance ( ) . getexternalcontext ( ) . getsessionmap ( ) . get ( "usersession" ) ; user = usersession . getuser ( ) ; userid = integer . parseint ( user . getuid ( ) ) ; dateposted = new date ( ) ; if ( courseid == invalid_value ) { system . out . println ( "invalid course for announcement" ) ; return ; } courseusers cusers = new courseusers ( ) ; cusers . setcourseuid ( courseid ) ; courses courses = new courses ( ) ; courses . setcourseid ( courseid ) ; announcements announcement = new announcements ( ) ; announcement . setdescription ( description ) ; announcement . settitle ( announcementtitle ) ; announcement . setdateposted ( dateposted ) ; announcement . setcreator ( cusers ) ; announcement . setcourse ( courses ) ; announcementsdao anndao = new announcementsdao ( ) ; anndao . create ( announcement ) ; }
tr	4	public void doservice ( ) { message message = parser . nextmessage ( ) ; while ( message != null ) { switch ( message . gettype ( ) ) { case connect : writer . println ( "already connected!" ) ; writer . flush ( ) ; break ; case disconnect : server . broadcaster . remove ( connection ) ; break ; case textmsg_client : broadcastmessage ( message ) ; break ; case image_client : server . setimage ( imageutils . decodeimage ( message . getmatcher ( ) . group ( 1 ) ) ) ; broadcastmessage ( message ) ; break ; default : abstracttool tool = abstracttool . gettool ( message . gettype ( ) ) ; if ( tool != null ) { server . updateimage ( tool , message ) ; broadcastmessage ( message ) ; } break ; } message = parser . nextmessage ( ) ; } }
tr	3	@ override public boolean login ( ) throws loginexception { namecallback namecallback = new namecallback ( "name : " ) ; passwordcallback passwordcallback = new passwordcallback ( "password : " , false ) ; try { callbackhandler . handle ( new callback [ ] { namecallback , passwordcallback } ) ; string username = namecallback . getname ( ) ; string password = new string ( passwordcallback . getpassword ( ) ) ; namecallback . setname ( "" ) ; passwordcallback . clearpassword ( ) ; customer customer = null ; if ( customer == null ) { throw new loginexception ( "authentication failed" ) ; } return true ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new loginexception ( e . getmessage ( ) ) ; } }
tr	1	public defaultenginedisplay ( string title , int x , int y , int width , int height ) { frame = new jframe ( title ) ; frame . setdefaultcloseoperation ( jframe . do_nothing_on_close ) ; frame . setignorerepaint ( true ) ; frame . setresizable ( false ) ; frame . setlocation ( x , y ) ; canvas = new canvas ( ) ; canvas . setpreferredsize ( new dimension ( width , height ) ) ; frame . add ( canvas ) ; frame . pack ( ) ; canvas . createbufferstrategy ( 2 ) ; bufferstrategy = canvas . getbufferstrategy ( ) ; canvas . requestfocus ( ) ; }
tr	4	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . iscontainer ( ) ) { entities . addall ( parts . get ( b ) . getentities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getbodypart ( ) != null ) { entities . get ( e ) . getbodypart ( ) . decay ( ) ; } } } }
tr	2	public yspecification parsespecification ( ) throws exception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser saxparser = factory . newsaxparser ( ) ; yspecificationhandler handler = new yspecificationhandler ( ) ; ysaxhandler preliminar_info_handler = new ypreliminarinfohandler ( ) ; saxparser . parse ( this . yawl_file , preliminar_info_handler ) ; handler . references ( ) . put ( "decomposition_types" , preliminar_info_handler . values ( ) ) ; saxparser . parse ( this . yawl_file , handler ) ; yspecification s = handler . builder ( ) . buildspecification ( ) ; t_info = handler . builder ( ) . translation_info ( ) ; return s ; } catch ( exception e ) { throw new exception ( "error attempting to parse specification." , e ) ; } }
tr	5	public list < document > sorting ( map < string , document > temp , int mode ) { list < document > sortedlist = new linkedlist < document > ( temp . values ( ) ) ; if ( mode == 0 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getpagerank ( ) - o2 . getpagerank ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getpagerank ( ) - o2 . getpagerank ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } else if ( mode == 1 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getnumviews ( ) - o2 . getnumviews ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getnumviews ( ) - o2 . getnumviews ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } return sortedlist ; }
tr	3	public void prepareforstartingattempt ( ) { arraylist < fieldelement > startingelements = getelements ( "arcanoid.model.ball" ) ; int width = ( int ) startingelements . get ( 0 ) . size ( ) . width ( ) ; int startpos = startingelements . get ( 0 ) . position ( ) . x + width / 2 ; int ypos = startingelements . get ( 0 ) . position ( ) . y ; for ( int i = 1 ; i < startingelements . size ( ) ; i ++ ) { if ( i < 3 ) { startingelements . get ( i ) . setposition ( new point ( startpos - i * 20 - width * i , ypos ) ) ; } else { startingelements . get ( i ) . setposition ( new point ( startpos + ( i - 2 ) * 20 + width * ( i - 2 ) , ypos ) ) ; } } }
tr	1	@ test public void testhypothesis ( ) { testhyphelper ( 0 , 1 , 0 , 1 , true , math . log ( 8.0 / 3 ) ) ; testhyphelper ( 1 , 1 , 1 , 1 , true , 0 ) ; testhyphelper ( 1 , 1 , 1 , 1 , false , 0 ) ; testhyphelper ( 100 , 200 , 300 , 300 , true , math . log ( 201.0 / 101 ) ) ; testhyphelper ( 100 , 200 , 300 , 300 , false , math . log ( 101.0 / 201 ) ) ; }
tr	1	public unit ( string name , string type , boolean isrange , boolean isair , boolean team , int landattack , int airattack , int range , int defense , int shift ) { this . name = name ; this . type = type ; this . ranged = isrange ; this . air = isair ; this . team = team ; this . landattack = landattack ; this . airattack = airattack ; this . range = range ; this . defense = defense ; this . shift = shift ; shiftdone = false ; attackdone = false ; health = 8 ; }
tr	2	public void updatestatus ( ) { log . finer ( log . start ( new throwable ( ) ) ) ; electricity needse = getneedelectricity ( ) ; log . fine ( "culculate electricty needing electronics:" + needse ) ; electricity producte = dboad . productelectorictiy ( ) ; log . fine ( "product electricty:" + producte ) ; electricity sube = producte . - ( needse ) ; log . fine ( "cluculate electricty product-needs:" + sube ) ; if ( sube . getwat ( ) < 0 ) { electricity requeste = new electricity ( ( int ) ( sube . getwat ( ) * - 1 ) ) ; buyelectricty ( requeste ) ; log . fine ( "buy the electricity:" + requeste ) ; } else { sellelectricty ( sube ) ; log . fine ( "sell the electricity:" + sube ) ; } updatemoney ( ) ; log . finer ( log . finish ( new throwable ( ) ) ) ; }
tr	3	< c > nodefactory < c > getsimplenodebuilder ( final string namespace , class < c > dummy ) { final nodefactory < c > factory = new reflectnodefactory < > ( new autoqualifiedclassloader ( namespace , _classloader ) ) ; return new simplenodefactory < c > ( ) { public predicate < c > newpredicate ( string type , string attr ) { if ( factory . newpredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newpredicate ( type , attr ) ; } @ override public action < c > newaction ( string type , string attr ) { if ( factory . newaction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newaction ( type , attr ) ; } private void ok ( string name ) { if ( verbose ) system . out . printf ( "class '%s' loaded\n" , name ) ; } private void error ( string name ) { system . err . printf ( "class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
tr	2	public reportform ( java . awt . frame parent , boolean modal , date df , date dt , string un , string su ) { super ( parent , modal ) ; datefrom = df ; dateto = dt ; unit = un ; subunit = su ; initcomponents ( ) ; if ( ! beans . isdesigntime ( ) ) { entitymanager . gettransaction ( ) . begin ( ) ; } mastertable . getcolumnmodel ( ) . getcolumn ( 5 ) . setcellrenderer ( new tablecellrenderdate ( ) ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 6 ) . setcellrenderer ( new tablecellrendertime ( ) ) ; mastertable . setautoresizemode ( jtable . auto_resize_off ) ; tablecolumnadjuster tca = new tablecolumnadjuster ( mastertable ) ; tca . adjustcolumns ( ) ; defaulttablecellrenderer dtcr = new defaulttablecellrenderer ( ) ; dtcr . sethorizontalalignment ( swingconstants . center ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 0 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 1 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 4 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 7 ) . setcellrenderer ( dtcr ) ; }
tr	5	@ override protected void drawcomponent ( graphics2d g ) { if ( visinfo . hasnodes ( ) ) { g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g . setcolor ( visinfo . getnodecolor ( ) ) ; affinetransform at = visinfo . gettranformation ( ) ; point2d from ; for ( node node : visinfo . getnodes ( ) ) { from = node . getpoint ( ) ; at . settoidentity ( ) ; at . translate ( from . getx ( ) - visinfo . getcirclediam ( ) , from . gety ( ) - visinfo . getcirclediam ( ) ) ; g . drawimage ( buffcircle , at , null ) ; for ( edge edge : node . getedges ( ) ) { if ( edge . getfromid ( ) < edge . gettoid ( ) ) { nodeimpl nodeto = ( nodeimpl ) visinfo . getnode ( edge . gettoid ( ) ) ; line = new line2d . double ( from , nodeto . getpoint ( ) ) ; g . draw ( line ) ; } } } } }
tr	5	@ override public string solve ( case acase ) { string template = "11%s11%s11%s11%s11" ; final list < string > coins = lists . newarraylist ( ) ; for ( int i = 0 ; i < acase . nbits - 10 ; i ++ ) { for ( int j = 0 ; j < acase . nbits - 10 - i ; j ++ ) { for ( int k = 0 ; k < acase . nbits - 10 - i - j ; k ++ ) { int l = acase . nbits - 10 - i - j - k ; string output = string . format ( template , zerostr ( i ) , zerostr ( j ) , zerostr ( k ) , zerostr ( l ) ) ; coins . add ( output + " 3 2 5 2 7 2 3 2 11" ) ; acase . jcoins -- ; if ( acase . jcoins == 0 ) { return stringlist ( coins ) ; } } } } throw new runtimeexception ( "need moar jamcoins" ) ; }
tr	1	protected updaterpanel ( ) { super ( new borderlayout ( ) ) ; messages = new jtextarea ( ) ; messages . setlinewrap ( false ) ; messagesempty = true ; final jpanel center = new jpanel ( new borderlayout ( ) ) ; center . add ( new jscrollpane ( messages ) , borderlayout . center ) ; center . add ( box . createverticalstrut ( minimal_height ) , borderlayout . west ) ; center . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; progressbar = new jprogressbar ( 0 , 100 ) ; progressbar . setvalue ( 0 ) ; actionsprogressbar = new jprogressbar ( 0 , 100 ) ; actionsprogressbar . setvalue ( 0 ) ; actionprogressbar = new jprogressbar ( 0 , 100 ) ; actionprogressbar . setvalue ( 0 ) ; final jpanel progress = new jpanel ( ) ; progress . setlayout ( new boxlayout ( progress , boxlayout . y_axis ) ) ; progress . add ( progressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionsprogressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionprogressbar ) ; final jpanel south = new jpanel ( new borderlayout ( ) ) ; south . add ( center , borderlayout . center ) ; south . add ( progress , borderlayout . south ) ; south . add ( box . createhorizontalstrut ( minimal_width ) , borderlayout . north ) ; add ( south , borderlayout . center ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . north ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . west ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . east ) ; }
tr	3	public static string generaterangehashfunction ( byte [ ] min , byte [ ] max , string [ ] buckets , string suffix , string prefix ) throws exception { if ( comparekey ( min , max ) > 0 ) { throw new exception ( "the given min is not larger than the max. buckets could not be determined" ) ; } byte [ ] [ ] ranges = getmaxvalsperrange ( min , max , buckets . length ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . tostring ( ) ; }
tr	3	public list < wishlist > find ( int idu ) throws instancenotfoundexception { list < wishlist > list = new arraylist < wishlist > ( ) ; try { connection connection = datasourceutils . getconnection ( datasource ) ; preparedstatement statement = connection . preparestatement ( "select idu  idp from wishlist where idu=?" ) ; statement . setint ( 1 , idu ) ; resultset resultset = statement . executequery ( ) ; while ( resultset . next ( ) ) { list . add ( new wishlist ( resultset . getint ( 2 ) , resultset . getint ( 1 ) ) ) ; } } catch ( sqlexception e ) { throw new runtimeexception ( e ) ; } return list ; }
tr	4	private nodo buscarnodo ( string padre ) { nodo tmp1 = this . raiz ; nodo tmp2 = tmp1 ; stringtokenizer path = new stringtokenizer ( padre , "/" ) ; string s ; while ( path . hasmoretokens ( ) ) { s = path . nexttoken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerhijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguientehermano ; } } return tmp2 ; }
tr	1	public void testtostringreconstruction ( ) { asserttrue ( "integer(0) cannot be reconstructed from its tostring() value!" , int0 . equals ( new integer ( int0 . tostring ( ) ) ) ) ; asserttrue ( "integer(1) cannot be reconstructed from its tostring() value!" , int1 . equals ( new integer ( int1 . tostring ( ) ) ) ) ; asserttrue ( "integer(-1) cannot be reconstructed from its tostring() value!" , intneg1 . equals ( new integer ( intneg1 . tostring ( ) ) ) ) ; asserttrue ( "integer(long.max_value) cannot be reconstructed from its tostring() value!" , intlongmax . equals ( new integer ( intlongmax . tostring ( ) ) ) ) ; asserttrue ( "integer(long.min_value) cannot be reconstructed from its tostring() value!" , intlongmin . equals ( new integer ( intlongmin . tostring ( ) ) ) ) ; }
tr	4	public static void main ( string argv [ ] ) { try { if ( argv . length != 1 ) { system . err . println ( "usbd [ start | stop ]" ) ; system . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { host host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usbd:  usb is not available." ) ; system . exit ( 1 ) ; } if ( host instanceof remote ) { system . err . println ( "usbd: proxy already registered" ) ; system . exit ( 1 ) ; } try { hostproxy proxy = new hostproxy ( host ) ; naming . bind ( rminame , proxy ) ; system . err . println ( "usbd:  bound rmi name " + rminame ) ; } catch ( exception e ) { system . err . println ( "usbd:  couldn't bind to: " + rminame ) ; if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { system . err . println ( "usbd: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { system . err . println ( "usbd: no '" + argv [ 0 ] + "' command" ) ; system . exit ( 1 ) ; } } catch ( exception e ) { if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } }
tr	3	private static void test4 ( ) throws interruptedexception { executorservice executor = executors . newworkstealingpool ( ) ; list < callable < string >> callables = arrays . aslist ( ( ) -> "task1" , ( ) -> "task2" , ( ) -> "task3" ) ; executor . invokeall ( callables ) . stream ( ) . map ( future -> { try { return future . get ( ) ; } catch ( exception e ) { throw new illegalstateexception ( e ) ; } } ) . foreach ( system . out colcol println ) ; executor . shutdown ( ) ; }
tr	2	public static void setapplemenus ( string title ) { try { system . setproperty ( "apple.laf.usescreenmenubar" , "true" ) ; system . setproperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( classnotfoundexception e ) { system . out . println ( "classnotfoundexception: " + e . getmessage ( ) ) ; } catch ( instantiationexception e ) { system . out . println ( "instantiationexception: " + e . getmessage ( ) ) ; } catch ( illegalaccessexception e ) { system . out . println ( "illegalaccessexception: " + e . getmessage ( ) ) ; } catch ( unsupportedlookandfeelexception e ) { system . out . println ( "unsupportedlookandfeelexception: " + e . getmessage ( ) ) ; } }
tr	5	private keyframe getkeyframe ( int i ) { try { mapevent me = events . poll ( ) ; if ( me != null ) { if ( nodes . containskey ( me . getnext ( ) ) ) { if ( transport . containskey ( me . getname ( ) ) ) { transportagentui ui = transport . get ( me . getname ( ) ) ; return movetransport ( me . getnext ( ) , me . getroadpercent ( ) , ui , duration . millis ( i * 1000 ) ) ; } else { } } else { } } else { thread . sleep ( 1000 ) ; } } catch ( throwable te ) { exceptionutils . handleexception ( te ) ; } return getkeyframe ( i ) ; }
tr	3	public stringbuilder streamout ( ) { stringbuilder buffer = new stringbuilder ( ) ; for ( int i = 0 ; i < numlines ; i ++ ) { if ( i == 0 || i == numlines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzlines [ i ] . streamout ( ) ) ; buffer . append ( vertlines [ i ] . streamout ( ) ) ; } for ( ordinalpt opt : ordpts ) { buffer . append ( opt . streamout ( ) ) ; } for ( gostone stone : gostones ) { buffer . append ( stone . streamout ( ) ) ; } for ( golabel label : labels ) { buffer . append ( label . streamout ( ) ) ; } for ( triangle triangle : triangles ) { buffer . append ( triangle . streamout ( ) ) ; } return buffer ; }
tr	1	private void drugaddactionperformed ( java . awt . event . actionevent evt ) { adddrugid . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 0 ) . tostring ( ) ) ; adddrugid . setvisible ( false ) ; adddrugmaxnum . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 3 ) . tostring ( ) ) ; adddrugmaxnum . setvisible ( false ) ; adddrugnumfield . settext ( "" ) ; adddrugtext . settext ( "" ) ; adddrugname . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; adddrugname . setvisible ( true ) ; adddrugprice . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 4 ) . tostring ( ) ) ; adddrugwindow . setvisible ( true ) ; }
tr	1	public static void createkeysettings ( ) { keysettings s1 = new keysettings ( ) ; s1 . bomb = game . keys . getkey ( keyevent . vk_l ) ; s1 . left = game . keys . getkey ( keyevent . vk_left ) ; s1 . right = game . keys . getkey ( keyevent . vk_right ) ; s1 . up = game . keys . getkey ( keyevent . vk_up ) ; s1 . down = game . keys . getkey ( keyevent . vk_down ) ; s1 . item = game . keys . getkey ( keyevent . vk_k ) ; game . key_settings . add ( s1 ) ; keysettings s2 = new keysettings ( ) ; s2 . bomb = game . keys . getkey ( keyevent . vk_t ) ; s2 . left = game . keys . getkey ( keyevent . vk_a ) ; s2 . right = game . keys . getkey ( keyevent . vk_d ) ; s2 . up = game . keys . getkey ( keyevent . vk_w ) ; s2 . down = game . keys . getkey ( keyevent . vk_s ) ; s2 . item = game . keys . getkey ( keyevent . vk_r ) ; game . key_settings . add ( s2 ) ; }
tr	5	private static string readlastline ( file file , string charset ) throws ioexception { if ( ! file . exists ( ) || file . isdirectory ( ) || ! file . canread ( ) ) { return null ; } randomaccessfile raf = null ; try { raf = new randomaccessfile ( file , "r" ) ; long len = raf . length ( ) ; if ( len == 0 ) { return "" ; } else { long pos = len - 1 ; while ( pos > 0 ) { pos -- ; raf . seek ( pos ) ; if ( raf . readbyte ( ) == 
 ) { break ; } } if ( pos == 0 ) { raf . seek ( 0 ) ; } byte [ ] bytes = new byte [ ( int ) ( len - pos ) ] ; raf . read ( bytes ) ; if ( charset == null ) { return new string ( bytes ) ; } else { return new string ( bytes , charset ) ; } } } catch ( filenotfoundexception e ) { } finally { if ( raf != null ) { try { raf . close ( ) ; } catch ( exception e2 ) { } } } return null ; }
tr	1	@ test public void testarea ( ) { point [ ] points = aconvex ; assertequals ( 78.5 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  0 1" ) ; assertequals ( 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  0 1  2 0" ) ; assertequals ( - 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  2 0  2 2" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "100 100  102 100  102 100  102 102" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "0 0  1 0  2 0" ) ; assertequals ( 0 , area ( points ) , eps ) ; }
tr	4	public identifier bookbed ( identifier userid , identifier searchid ) { arraylist < searchbean < freebeddetailbean >> results = getlastsearchresult ( ) ; for ( searchbean < freebeddetailbean > search : results ) { if ( search . getsearchid ( ) . equals ( searchid ) ) { freebeddetailbean beddetail = search . getobjectinfo ( ) ; identifier hostelid = search . getobjectid ( ) ; booking booking = new booking ( ) ; booking . setbedids ( beddetail . getbedids ( ) ) ; arraylist < tariff > bedreservations = new arraylist < tariff > ( ) ; for ( int i = 0 ; i < booking . getbedids ( ) . size ( ) ; i ++ ) { tariff tariff = new tariff ( beddetail . getprice ( ) . get ( i ) , beddetail . getcheckin ( ) , beddetail . getcheckout ( ) ) ; bedreservations . add ( tariff ) ; } booking . setbedreservations ( bedreservations ) ; booking . setbookingdate ( genericutility . getcurrentdatewithouttime ( ) ) ; booking . sethostelid ( hostelid ) ; booking . setstatus ( bookingstatus . reserved ) ; booking . setuserid ( userid ) ; try { return bookings . getinstance ( ) . create ( booking ) ; } catch ( databasereadwriteexception | identifieralreadyexistsexception | invalididentifierexception | invalidparameterexception | conflictexception | identifiernotfoundexception e ) { } } } return null ; }
tr	5	private boolean fourinarow ( int row , int col , location [ ] [ ] boardlocations ) { int columnlength = boardlocations [ row ] . length ; int rowlength = boardlocations . length ; int startrow ; int currentrow ; int startcolumn ; int currentcolumn ; int matches = 0 ; boolean fourofakindfound = false ; int i , j , k ; for ( i = 0 ; i < rowlength ; i ++ ) { location [ ] rowlocations = boardlocations [ i ] ; for ( j = 0 , startcolumn = 0 , currentcolumn = 0 , matches = 0 ; j < columnlength - 1 ; j ++ ) { if ( rowlocations [ j ] . getplayer ( ) == rowlocations [ j + 1 ] . getplayer ( ) ) { currentcolumn ++ ; if ( rowlocations [ j ] . getplayer ( ) != null ) matches ++ ; else startcolumn = currentcolumn ; } else if ( matches < 3 ) { currentcolumn ++ ; startcolumn = currentcolumn ; matches = 0 ; } else { for ( k = startcolumn ; k <= currentcolumn ; k ++ ) { rowlocations [ k ] . setdeleteflag ( ) ; } currentcolumn ++ ; startcolumn = currentcolumn ; matches = 0 ; fourofakindfound = true ; } } if ( matches > 3 ) fourofakindfound = true ; } for ( j = 0 ; j < columnlength ; j ++ ) { for ( i = 0 , matches = 0 , startrow = 0 , currentrow = 0 ; i < rowlength - 1 ; i ++ ) { if ( boardlocations [ i ] [ j ] . getplayer ( ) == boardlocations [ i + 1 ] [ j ] . getplayer ( ) ) { currentrow ++ ; if ( boardlocations [ i ] [ j ] . getplayer ( ) != null ) matches ++ ; else startrow = currentrow ; } else if ( matches < 3 ) { currentrow ++ ; startrow = currentrow ; matches = 0 ; } else { for ( k = startrow ; k <= currentrow ; k ++ ) { boardlocations [ k ] [ j ] . setdeleteflag ( ) ; } currentrow ++ ; startrow = currentrow ; matches = 0 ; fourofakindfound = true ; } } if ( matches > 3 ) fourofakindfound = true ; } return fourofakindfound ; }
tr	3	public iterable < position < e >> findrange ( e minvalue , e maxvalue ) { list < position < e >> l = new arraylist < > ( ) ; list < position < e >> todas = ( list < position < e >> ) this . positions ( ) ; for ( position < e > pos : todas ) { e curvalue = pos . element ( ) ; int compmin = findcomparator . compare ( curvalue , minvalue ) ; int compmax = findcomparator . compare ( curvalue , maxvalue ) ; boolean overmin = ( ( compmin == 0 ) || ( compmin == 1 ) ) ; boolean undermax = ( ( compmax == 0 ) || ( compmax == - 1 ) ) ; if ( overmin && undermax ) { l . add ( pos ) ; } } return l ; }
tr	4	public list < sitestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > statrows = resultset . getrows ( ) ; map < long , sitestatmodel > sitestatmodelmap = new hashmap < > ( ) ; for ( statrow eachrow : statrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { sitestatmodel sitestatmodel = new sitestatmodel ( ) ; sitestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; sitestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; sitestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; sitestatmodel . sethour ( hour ) ; sitestatmodel . setvideo ( 0 ) ; sitestatmodel . setsite ( sitemodel ) ; if ( sitestatmodelmap . get ( hour . getmillis ( ) ) == null ) { sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } else { sitestatmodelmap . remove ( hour . getmillis ( ) ) ; sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } } } list < sitestatmodel > sitestatmodels = new arraylist < > ( sitestatmodelmap . values ( ) ) ; return sitestatmodels ; }
tr	5	private void exportatxt ( ) throws sqlexception { string query = "" ; string query_contador = "" ; string linea ; resultset respuesta ; boolean band = false ; string ruta_escritorio = system . getproperty ( "user.home" ) + "\\desktop\\" ; try { bufferedwriter escribir_archivo = new bufferedwriter ( new filewriter ( new file ( ruta_escritorio + this . nombrearchivo ) ) ) ; if ( this . caso . equals ( "todos" ) ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true'" ; respuesta = this . conexion . executequery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getint ( 1 ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true'" ; respuesta = this . conexion . executequery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getnstring ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaloading . lblinfo . settext ( "exportando " + cont_escritos + " de " + total_correos ) ; vistaloading . pbprogreso . setvalue ( porcentaje ) ; vistaloading . lblcompletado . settext ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } else if ( this . caso . equals ( "origen-grupo" ) ) { if ( origen != null && grupo != null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) + " and `id_grupo` = " + grupo . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) + " and `id_grupo` = " + grupo . getid ( ) ; } else if ( origen != null && grupo == null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) ; } else if ( origen == null && grupo != null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_grupo` = " + grupo . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_grupo` = " + grupo . getid ( ) ; } respuesta = this . conexion . executequery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getint ( 1 ) ; respuesta = this . conexion . executequery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getnstring ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaloading . lblinfo . settext ( "exportando " + cont_escritos + " de " + total_correos ) ; vistaloading . pbprogreso . setvalue ( porcentaje ) ; vistaloading . lblcompletado . settext ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } vistaloading . dispose ( ) ; if ( band == true ) { joptionpane . showmessagedialog ( vistaloading , "exportaci\u00f3n finalizada  nuevo documento : \r\n" + ruta_escritorio + nombrearchivo , "fin del proceso" , joptionpane . information_message ) ; } } catch ( headlessexception | ioexception | sqlexception e ) { joptionpane . showmessagedialog ( null , "error: " + e + "." , "error" , joptionpane . error_message ) ; } }
tr	4	private string generaterandomid ( ) { stringbuilder sb = new stringbuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idlength ) { char ch = ( char ) rnd . nextint ( ) ; if ( utils . isuriletterordigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containskey ( sb . tostring ( ) ) ) { sb . delete ( 0 , idlength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > retry_count ) ; return sb . tostring ( ) ; }
tr	5	private int packspecifiedframes ( byte [ ] bytes , int offset , string onlyid , string notid ) throws notsupportedexception { iterator < id3v2frameset > setiterator = framesets . values ( ) . iterator ( ) ; while ( setiterator . hasnext ( ) ) { id3v2frameset frameset = setiterator . next ( ) ; if ( ( onlyid == null || onlyid . equals ( frameset . getid ( ) ) ) && ( notid == null || ! notid . equals ( frameset . getid ( ) ) ) ) { iterator < id3v2frame > frameiterator = frameset . getframes ( ) . iterator ( ) ; while ( frameiterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) frameiterator . next ( ) ; if ( frame . getdatalength ( ) > 0 ) { byte [ ] framedata = frame . tobytes ( ) ; buffertools . copyintobytebuffer ( framedata , 0 , framedata . length , bytes , offset ) ; offset += framedata . length ; } } } } return offset ; }
tr	5	public leprauser parsecontent ( string content ) throws lepraexception { if ( stringutils . isblank ( content ) || "null" . equalsignorecase ( content . trim ( ) ) ) { throw new lepraloginexception ( ) ; } jsonobject obj = new jsonobject ( content ) ; string status = obj . getstring ( "status" ) ; if ( status == null || ! "ok" . equalsignorecase ( status ) ) { jsonarray errors = obj . optjsonarray ( "errors" ) ; if ( errors != null && errors . length ( ) > 0 ) { for ( int i = 0 ; i < errors . length ( ) ; i ++ ) { jsonobject error = errors . getjsonobject ( i ) ; if ( error != null && stringutils . equalsignorecase ( error . getstring ( "code" ) , "invalid_password" ) ) { throw new leprainvalidloginpasswordexception ( ) ; } if ( error != null && stringutils . equalsignorecase ( error . getstring ( "code" ) , "captcha_required" ) ) { throw new lepracaptcharequired ( ) ; } } } throw new lepraloginexception ( ) ; } jsonobject user = obj . getjsonobject ( "user" ) ; return new leprauser ( user . getint ( "id" ) , user . getstring ( "login" ) , user . getstring ( "gender" ) , user . getint ( "karma" ) ) ; }
tr	1	public queuerow ( int opcode , boolean shouldshowoperandfield ) { this . opcode = opcode ; setforeground ( color . gray ) ; setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; setpreferredsize ( new dimension ( 258 , 28 ) ) ; setmaximumsize ( new dimension ( 32767 , 30 ) ) ; setlayout ( new boxlayout ( this , boxlayout . x_axis ) ) ; cmdnamelabel = new jlabel ( "" ) ; add ( cmdnamelabel ) ; horizontalglue = box . createhorizontalglue ( ) ; add ( horizontalglue ) ; operandfield = new jformattedtextfield ( numberformat . getnumberinstance ( ) ) ; operandfield . setvalue ( 0 ) ; operandfield . setpreferredsize ( new dimension ( 60 , 22 ) ) ; operandfield . setmaximumsize ( new dimension ( 60 , 2147483647 ) ) ; operandfield . setvisible ( shouldshowoperandfield ) ; add ( operandfield ) ; horizontalstrut = box . createhorizontalstrut ( 20 ) ; horizontalstrut . setpreferredsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setminimumsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setmaximumsize ( new dimension ( 13 , 32767 ) ) ; add ( horizontalstrut ) ; moveupbtn = new jbutton ( "\u25b2" ) ; add ( moveupbtn ) ; movedownbtn = new jbutton ( "\u25bc" ) ; add ( movedownbtn ) ; removebtn = new jbutton ( "remove" ) ; add ( removebtn ) ; }
tr	3	public void storepast ( pastdata past ) { if ( past . zip . equalsignorecase ( "denver co" ) ) past . zip = "80201" ; string prefix = past . zip + " " + timeformat . format ( past . date ) + " " + past . today + " " + past . occurreddate ; if ( past . overallpast . high != null || past . overallpast . precip != null ) { string str = prefix ; str = str + " " ; if ( past . overallpast . high != null ) str = str + past . overallpast . high . tostring ( ) ; str = str + " " ; if ( past . overallpast . precip != null ) str = str + past . overallpast . precip . tostring ( ) ; str = str + " " ; daout . println ( str ) ; } if ( past . hourlypast . length != 0 ) { for ( int i = 0 ; i < past . hourlypast . length ; i ++ ) { string str = prefix ; str = str + " " + past . hourlypast [ i ] . hour ; str = str + " " ; if ( past . hourlypast [ i ] . temp != null ) str = str + past . hourlypast [ i ] . temp . tostring ( ) ; str = str + " " ; if ( past . hourlypast [ i ] . conditions != null ) str = str + past . hourlypast [ i ] . conditions ; str = str + " " ; if ( past . hourlypast [ i ] . precip != null ) str = str + past . hourlypast [ i ] . precip . tostring ( ) ; str = str + " " ; haout . println ( str ) ; } } }
tr	2	@ override public void writeanalysis ( morphologyanalysis analysis ) { final string record = string . format ( "%s (\"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\");%n" , insert_analysis , analysis . getform ( ) , analysis . getlemma ( ) , analysis . getgrammaticalcase ( ) , analysis . getdegree ( ) , analysis . getgender ( ) , analysis . getmood ( ) , analysis . getnumber ( ) , analysis . getperson ( ) , analysis . getpos ( ) , analysis . gettense ( ) , analysis . getvoice ( ) ) ; try { morphologywriter . write ( record ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	3	@ override public string getasstring ( facescontext facescontext , uicomponent component , object object ) { if ( object == null ) { return null ; } if ( object instanceof keystate ) { keystate o = ( keystate ) object ; return getstringkey ( o . getidkeystate ( ) ) ; } else { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "object {0} is of type {1}; expected type: {2}" , new object [ ] { object , object . getclass ( ) . getname ( ) , keystate . class . getname ( ) } ) ; return null ; } }
tr	4	public void mouseclicked ( mouseevent me ) { try { if ( me . getsource ( ) == jb_connexion ) { login = jtf_login . gettext ( ) ; password = string . valueof ( jpf_password . getpassword ( ) ) ; system . out . println ( "email : " + login ) ; system . out . println ( "motdepasse : " + password ) ; user u = null ; connection co = bs . getconnection ( ) ; system . out . println ( "avant if" ) ; if ( user . checkpresence ( bs , login , password ) ) { system . out . println ( "debut if" ) ; u = user . findbylogs ( login , password , bs ) ; groupe = usertype . findbyid ( u . getid_ut ( ) , bs ) . getname_ut ( ) ; system . out . println ( "ok : " + groupe ) ; affichermenuprincipal ( ) ; setresizable ( true ) ; setextendedstate ( maximized_both ) ; } else { system . out . println ( "non ok" ) ; } } if ( me . getsource ( ) == jb_mdp_oublie ) { if ( swingutilities . isleftmousebutton ( me ) ) { } if ( swingutilities . isrightmousebutton ( me ) ) { } } } catch ( exception e ) { system . out . println ( "exception" ) ; e . printstacktrace ( ) ; } }
tr	1	public fourmiliere ( monde monde , case c , int fecondite , int taille_max , int ressources , int tauxeclaireuses ) { this . fecondite = fecondite ; this . taille_max = taille_max ; this . ressources = ressources ; this . fourmi = new hashset < fourmi > ( ) ; this . _case = c ; this . monde = monde ; this . tauxeclaireuses = tauxeclaireuses ; logger . debug ( "fourmiliere cr\u00e9e : " + this ) ; _case . setfourmiliere ( this ) ; monde . ajouterfourmiliere ( this ) ; this . getmonde ( ) . fireevent ( new fourmiliereajouteeevent ( monde . gettour ( ) , new date ( ) , this ) ) ; }
tr	2	renderercontext ( final string name ) { if ( log_create_context ) { marlinutils . loginfo ( "new renderercontext = " + name ) ; } this . name = name ; npcpathiterator = new normalizingpathiterator . nearestpixelcenter ( float6 ) ; npqpathiterator = new normalizingpathiterator . nearestpixelquarter ( float6 ) ; transformerpc2d = new transformingpathconsumer2d ( ) ; cache = new marlincache ( this ) ; renderer = new renderer ( this ) ; ptg = new marlintilegenerator ( renderer ) ; stroker = new stroker ( this ) ; dasher = new dasher ( this ) ; switch ( marlinrenderingengine . ref_type ) { default : case marlinrenderingengine . ref_hard : reference = this ; break ; case marlinrenderingengine . ref_soft : reference = new softreference < renderercontext > ( this ) ; break ; case marlinrenderingengine . ref_weak : reference = new weakreference < renderercontext > ( this ) ; break ; } }
tr	1	@ test public void testisconvex ( ) { point [ ] points = makepoints ( "0 0  4 5  6 5  9 3  10 4  12 -1  7 -4  4 0  3 -2  -1 1  8 2  -1 -1" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = aconvex ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "0.50507641 39.107643  50.002551 25.218046  79.296972 -14.68298  93.944191 -57.867001  84.347738 -94.990105  34.850263 -82.363197  -0.50507641 -36.14872  -12.121831 5.7726092" ) ; asserttrue ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = makepoints ( "0 0  1 0  2 0  3 0  2 0  1 0" ) ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "-35.860415 -16.379211  -4.0406102 -35.067033  40.406102 13.925365  57.578695 56.856849  -37.88072 38.674103  -72.225907 6.060915  -11.111678 6.3492214" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; }
tr	4	private box drawbuttonbestscores ( ) { kulbutton ok1 = new kulbutton ( "ok" ) ; ok1 . setpreferredsize ( new dimension ( 125 , 40 ) ) ; ok1 . setmaximumsize ( new dimension ( 125 , 40 ) ) ; ok1 . setforeground ( color . white ) ; ok1 . setfont ( f . derivefont ( 26f ) ) ; box buttonbox = new box ( boxlayout . x_axis ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; buttonbox . add ( ok1 ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; ok1 . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( swingutilities . isleftmousebutton ( e ) ) { slideup ( ) ; } } } ) ; return buttonbox ; }
tr	1	protected void paintcomponent ( graphics g ) { graphics2d g2d = ( graphics2d ) g ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; int largeur = getwidth ( ) ; int hauteur = getheight ( ) ; int b_hauteur = hauteur - ( inset * 2 ) ; int b_largeur = largeur - ( inset * 2 ) ; int varcsize = b_hauteur ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; color vgradientstartcolor = buttoncolor . darker ( ) . darker ( ) . darker ( ) ; color vgradientendcolor = buttoncolor . brighter ( ) . brighter ( ) . brighter ( ) ; paint paint = new gradientpaint ( 0 , inset , vgradientstartcolor , 0 , b_hauteur , vgradientendcolor , false ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; int vhighlightinset = 2 ; int vbuttonhighlightheight = b_hauteur - ( vhighlightinset * 2 ) ; int vbuttonhighlightwidth = b_largeur - ( vhighlightinset * 2 ) ; int vhighlightarcsize = vbuttonhighlightheight ; vgradientstartcolor = color . white ; vgradientendcolor = buttoncolor . brighter ( ) ; paint = new gradientpaint ( 0 , inset + vhighlightinset , vgradientstartcolor , 0 , inset + vhighlightinset + ( vbuttonhighlightheight / 2 ) , buttoncolor . brighter ( ) , false ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , .8f ) ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset + vhighlightinset , inset + vhighlightinset , vbuttonhighlightwidth , vbuttonhighlightheight , vhighlightarcsize , vhighlightarcsize ) ; roundrectangle2d . float r2d = new roundrectangle2d . float ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; g2d . clip ( r2d ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , 1.0f ) ) ; super . paintcomponent ( g ) ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_off ) ; }
tr	2	@ override protected void selectionchanged ( int selectionindex ) { audiences au = model . getentity ( selectionindex ) ; string sql = "call au_subjects(?)" ; object [ ] [ ] result = dbconnection . getinstance ( ) . executequery ( sql , new object [ ] { au . getid ( ) } ) ; string [ ] subjects = new string [ result . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { subjects [ i ] = ( string ) result [ i ] [ 0 ] ; } object [ ] params = new object [ ] { au . getfullnumber ( ) , audiencemodel . audience_type [ au . gettype ( ) ] , au . getcapacity ( ) , subjects } ; htmlbuilder html = new htmlbuilder ( "audiences.rep" , params ) ; setinfotext ( html . tostring ( ) ) ; }
tr	4	@ suppresswarnings ( "unchecked" ) public static void main ( string args [ ] ) { repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new repl < > ( fractalevaluator . class ) ; repl . loop ( ) ; } else { try { repl = new repl ( class . forname ( args [ 0 ] ) ) ; arraylist < string > filelist = new arraylist < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { filelist . add ( args [ i ] ) ; } repl . visitfiles ( filelist ) ; repl . loop ( ) ; } catch ( classnotfoundexception cnfe ) { system . err . println ( cnfe . getmessage ( ) ) ; system . exit ( 1 ) ; } } }
tr	4	public void setcellscoresmatrix ( ) { int r , c , sc ; char cs1 , cs2 ; scoredcellelement tmpcell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cs1 = m_s1 . charat ( c ) ; cs2 = m_s1 . charat ( r ) ; tmpcell = ( scoredcellelement ) m_dptable . getcell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpcell . setscoreval ( m_scorehash . getscore ( cs1 , cs2 ) ) ; } else { tmpcell . setcolor ( color . black ) ; } } } }
tr	5	private string createexporteridquery ( string exporterid , string colname ) { string [ ] splitstring ; int lowerbound ; int upperbound ; int expnum ; if ( exporterid == null || colname == null || exporterid . equalsignorecase ( "" ) || exporterid . equalsignorecase ( "*" ) ) return "" ; if ( ( splitstring = exporterid . split ( "-" ) ) . length > 1 ) { if ( splitstring . length == 2 ) { try { lowerbound = integer . parseint ( splitstring [ 0 ] ) ; if ( lowerbound > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } upperbound = integer . parseint ( splitstring [ 1 ] ) ; if ( upperbound > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } catch ( numberformatexception e ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } return colname + " between " + lowerbound + " and " + upperbound ; } else { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } else { splitstring = exporterid . split ( " " ) ; for ( int i = 0 ; i < splitstring . length ; i ++ ) { try { expnum = integer . parseint ( splitstring [ i ] ) ; } catch ( numberformatexception e ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } if ( expnum > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } if ( splitstring . length > 0 ) { while ( exporterid . endswith ( " " ) ) exporterid = exporterid . substring ( 0 , exporterid . length ( ) - 1 ) ; return colname + " in (" + exporterid + ")" ; } else { return colname + "=" + exporterid ; } } }
tr	1	private string converttoformatstring ( string imagestring ) { string formatstring = imagestring ; formatstring = formatstring . replace ( "8(x 3a)" , " %3s %3s %3s %3s %3s %3s %3s %3s" ) ; formatstring = formatstring . replace ( "8x" , "        " ) ; formatstring = formatstring . replace ( "9x" , "         " ) ; formatstring = formatstring . replace ( "11x" , "           " ) ; formatstring = formatstring . replace ( "5d" , "%5s" ) ; formatstring = formatstring . replace ( "6a" , "%6s" ) ; formatstring = formatstring . replace ( "6d" , "%6s" ) ; formatstring = formatstring . replace ( "3d" , "%3s" ) ; formatstring = formatstring . replace ( "d" , "%1s" ) ; return formatstring ; }
tr	5	public void test_entryset ( ) throws exception { final concurrenthashmap < string , string > map = new concurrenthashmap < string , string > ( ) ; threadfire ( new threadfireexecution < void > ( ) { public void execute ( threadfireresource resource ) { final long threadid = resource . getthreadid ( ) ; if ( threadid % 2 > 0 ) { map . put ( "foo1" , "bar1" ) ; map . put ( "foo2" , "bar2" ) ; log ( "...looping entry set: " + map . size ( ) ) ; int count = 0 ; for ( entry < string , string > entry : map . entryset ( ) ) { sleep ( 1000 ) ; log ( entry . getkey ( ) ) ; ++ count ; } log ( "after loop: " + map ) ; assertequals ( 3 , map . size ( ) ) ; assertequals ( 2 , count ) ; } else { sleep ( 300 ) ; log ( "...putting three" ) ; map . put ( "foo3" , "bar3" ) ; log ( "after put: " + map ) ; assertequals ( 3 , map . size ( ) ) ; } return null ; } } , new threadfireoption ( ) . threadcount ( 2 ) . repeatcount ( 1 ) ) ; }
tr	2	public static field [ ] getallfields ( class c ) { list < field > fields = new arraylist < field > ( ) ; while ( c != object . class ) { list < field > classfields = new arraylist < field > ( arrays . aslist ( c . getdeclaredfields ( ) ) ) ; collections . reverse ( classfields ) ; fields . addall ( classfields ) ; c = c . getsuperclass ( ) ; } collections . reverse ( fields ) ; return fields . toarray ( new field [ 0 ] ) ; }
tr	1	private void drawrect ( graphics g , rectvertices v ) { g . drawline ( ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) , ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) , ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) , ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) , ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) ) ; }
tr	3	public static boolean writesalesorder ( messageheader header , list < com . adammargherio . xml . schemas . salesorder . lineitem > items ) { if ( conn == null ) { getconnection ( ) ; } try { string sql = "insert into tbletsalesheader values (? ? ? ? ? ? ?)" ; preparedstatement peheader = conn . preparestatement ( sql ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . lineitem l : items ) { try { string item = "insert into tbletsalesdetail values (? ? ? ? ? ?)" ; preparedstatement peitem = conn . preparestatement ( item ) ; peitem . setstring ( 1 , l . getlineno ( ) ) ; peitem . setstring ( 2 , l . getitemcode ( ) ) ; peitem . setstring ( 3 , l . getproductname ( ) ) ; peitem . setint ( 4 , l . getquantity ( ) . intvalue ( ) ) ; peitem . setstring ( 5 , l . getunitofmeasure ( ) ) ; peitem . setint ( 6 , l . getbaseprice ( ) . intvalue ( ) ) ; peitem . execute ( ) ; conn . commit ( ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } } return true ; }
tr	3	protected keyboardeventlistener parsekeyboardlistener ( string keyboardlistenerstring ) { keyboardeventlistener rc = null ; if ( ! "" . equals ( keyboardlistenerstring ) ) { switch ( keyboardlistenerstring ) { case ( "splashscreenkeyboardeventlistener" ) : rc = new splashscreenkeyboardeventlistener ( ) ; break ; case ( "menukeyboardeventlistener" ) : rc = new menukeyboardeventlistener ( ) ; break ; case ( "optionsmenuitemkeyboardeventlistener" ) : rc = new optionsmenuitemkeyboardeventlistener ( ) ; break ; case ( "exitmenuitemkeyboardeventlistener" ) : rc = new exitmenuitemkeyboardeventlistener ( ) ; break ; case ( "optionsmenubackkeyboardeventlistener" ) : rc = new optionsmenubackkeyboardeventlistener ( ) ; break ; default : } } return rc ; }
tr	4	private int get_next_page ( page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return ov_false ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return ov_false ; int ret = get_data ( ) ; if ( ret == 0 ) return ov_eof ; if ( ret < 0 ) return ov_eread ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
tr	1	@ override public set < collector > getcollectors ( ) { collectors = new hashset < collector > ( ) ; boolean [ ] [ ] gameboard = getvalidboard ( 1 ) ; list < tuple < integer , integer >> q = leastencumbered ( new int [ 100 ] [ 100 ] ) ; tuple < integer , integer > firstchoice = q . get ( 0 ) ; int count = 0 ; firstchoice = getpointnotonwall ( firstchoice ) ; collector c = new collector ( firstchoice . x , firstchoice . y ) ; log . trace ( "placed a collector at " + c . getx ( ) + " " + c . gety ( ) ) ; collectors . add ( c ) ; return collectors ; }
tr	3	private void drawmenu ( ) { int i = menuoffsetx ; int j = menuoffsety ; int k = menuwidth ; int l = menuheight + 1 ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 706a5e , menuwidth , menuoffsetx ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 706a5e , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety , menuheight , 200 , 706a5e , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 2d2822 , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 2d2822 , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 3 , menuheight - 6 , 250 , 2d2822 , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety + 19 , menuheight - 22 , 250 , 524a3d , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 20 , menuheight - 22 , 250 , 524a3d , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 2a291b , menuoffsety + 2 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a261b , menuoffsety + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 252116 , menuoffsety + 4 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 211e15 , menuoffsety + 5 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1e1b12 , menuoffsety + 6 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1a170e , menuoffsety + 7 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 2 , 15120b , menuoffsety + 8 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 100d08 , menuoffsety + 10 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 11 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 080703 , menuoffsety + 12 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 13 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 14 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 15 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 16 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 17 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a291b , menuoffsety + 18 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 564943 , menuoffsety + 19 ) ; chattextdrawingarea . method385 ( c6b895 , "choose option" , menuoffsety + 14 , menuoffsetx + 3 ) ; int j1 = super . mousex ; int k1 = super . mousey ; if ( menuscreenarea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuscreenarea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuscreenarea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuscreenarea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuactionrow ; l1 ++ ) { int i2 = j + 31 + ( menuactionrow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { drawingarea . drawpixels ( 15 , i2 - 11 , i + 3 , 26566c , menuwidth - 6 ) ; j2 = eee5c6 ; } chattextdrawingarea . method389 ( true , i + 4 , aaa184 , menuactionname [ l1 ] , i2 + 1 ) ; } }
tr	4	public static void main ( string [ ] args ) throws exception { long start = system . currenttimemillis ( ) ; scanner in = new scanner ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice-1.in" ) ) ; system . setout ( new printstream ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice1.out" ) ) ) ; int numcase = in . nextint ( ) ; in . nextline ( ) ; for ( int curcase = 1 ; curcase <= numcase ; curcase ++ ) { long min , max ; min = in . nextlong ( ) ; max = in . nextlong ( ) ; int count = 0 ; long sqrt_min = ( long ) math . sqrt ( min ) , sqrt_max = ( long ) math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( ispalin ( i ) && ispalin ( i * i ) ) { count ++ ; } } system . out . println ( " case #" + curcase + ": " + count ) ; } long end = system . currenttimemillis ( ) ; system . out . println ( "\u8fd0\u884c\u65f6\u95f4\uff1a" + ( end - start ) + "ms" ) ; }
tr	5	public static int sentstosql ( file input ) { if ( ! input . exists ( ) ) return 0 ; arraylist < sentenceentry > res = new arraylist < sentenceentry > ( ) ; arraylist < string > validation = new arraylist < string > ( ) ; try { bufferedreader bureader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( input ) , "utf-8" ) ) ; string tmp = "" ; double currating = - 1 ; int revindex = 0 ; for ( string s = bureader . readline ( ) ; s != null ; s = bureader . readline ( ) ) { if ( s . startswith ( "###" ) ) { if ( tmp . length ( ) == 0 ) { currating = double . valueof ( s . split ( "\t" ) [ 3 ] ) ; continue ; } arraylist < string > sentences = sentencesplitter . getinstance ( ) . sentence_split ( tmp ) ; validation . addall ( sentences ) ; for ( string sent : sentences ) { sentenceentry cursent = new sentenceentry ( sent , sentscounter , input . getname ( ) ) ; cursent . revindex = revindex ; cursent . revrating = currating ; sentscounter ++ ; res . add ( cursent ) ; } revindex ++ ; tmp = "" ; if ( s . split ( "\t" ) . length != 13 ) { system . out . println ( s . split ( "\t" ) . length + "\t" + s ) ; currating = 4.0 ; } else { currating = double . valueof ( s . split ( "\t" ) [ 3 ] ) ; } } else { tmp += s ; } } if ( ! tmp . isempty ( ) ) { arraylist < string > sentences = sentencesplitter . getinstance ( ) . sentence_split ( tmp ) ; for ( string sent : sentences ) { sentenceentry cursent = new sentenceentry ( sent , sentscounter , input . getname ( ) ) ; cursent . revindex = revindex ; cursent . revrating = currating ; sentscounter ++ ; res . add ( cursent ) ; } validation . addall ( sentences ) ; tmp = "" ; } } catch ( exception e ) { e . printstacktrace ( ) ; } for ( sentenceentry sententry : res ) { string sql = "insert into sentences (sent_index   sent_txt   revindex   revrating  filename )" + " values ( " + sententry . uniqueid + "  '" + textutil . encode ( sententry . get_senttxt ( ) ) + "'  " + sententry . revindex + "   " + sententry . revrating + "  '" + textutil . encode ( sententry . filename ) + "');" ; db1 . executeupdatesql ( sql ) ; } system . err . println ( "% end..." + sentscounter + "\t" + validation . size ( ) + "." ) ; return sentscounter ; }
tr	2	private linkedlist < string > extractkeywords ( string filename ) { linkedlist < string > keywords = new linkedlist < string > ( ) ; int posofdot = filename . lastindexof ( . ) ; if ( posofdot != - 1 ) { keywords . add ( filename . substring ( posofdot ) ) ; filename = filename . substring ( 0 , posofdot ) ; } filename = filename . replaceall ( "[0-9]+" , " " ) . trim ( ) ; string [ ] splitcamelanddelim = filename . split ( "((?<!(^|[a-z]))(?=[a-z])|(?<!^)(?=[a-z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addall ( arrays . aslist ( splitcamelanddelim ) ) ; for ( iterator < string > iter = keywords . iterator ( ) ; iter . hasnext ( ) ; ) { string item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . touppercase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
tr	1	public void mostradades ( dadesreserva dades ) { poblaciovaluelabel . settext ( dades . pob ) ; simpledateformat s = new simpledateformat ( "dd/mm/yyyy" ) ; datainicivaluelabel . settext ( s . format ( dades . dini ) ) ; datafivaluelabel . settext ( s . format ( dades . dfi ) ) ; numocupvaluelabel . settext ( dades . numoc . tostring ( ) ) ; hotelvaluelabel . settext ( dades . nomhotel ) ; habitaciovaluelabel . settext ( dades . nomtipushab ) ; preutotalvaluelabel . settext ( dades . preutotal . tostring ( ) ) ; dnivaluelabel . settext ( dades . dni ) ; nomvaluelabel . settext ( dades . nomclient ) ; cognomsvaluelabel . settext ( dades . cognomsclient ) ; emailvaluelabel . settext ( dades . emailclient ) ; }
tr	1	public void newfile ( ) { final string title = "create new list" ; final string message = "enter list name:" ; string name = joptionpane . showinputdialog ( null , message , title , joptionpane . plain_message ) ; if ( name == null ) return ; if ( ! closefile ( ) ) return ; current_file = null ; getlistmanager ( ) . setlist ( new sklist ( name ) ) ; getlistmanager ( ) . clearhistory ( ) ; dirty = false ; console . verbose ( "created new list (" + console . italics ( name ) + ")" ) ; refreshtitle ( ) ; }
tr	3	private void startlevel ( ) { if ( currentlesson . isnotelevel ( ) ) { if ( ! notelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + notelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isrhythmlevel ( ) ) { if ( ! rhythmlevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + rhythmlevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isscorelevel ( ) ) { if ( ! scorelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + scorelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } }
tr	5	public static document deepclonedocument ( document doc , domimplementation impl ) { element root = doc . getdocumentelement ( ) ; document result = impl . createdocument ( root . getnamespaceuri ( ) , root . getnodename ( ) , null ) ; element rroot = result . getdocumentelement ( ) ; boolean before = true ; for ( node n = doc . getfirstchild ( ) ; n != null ; n = n . getnextsibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasattributes ( ) ) { namednodemap attr = root . getattributes ( ) ; int len = attr . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setattributenode ( ( attr ) result . importnode ( attr . item ( i ) , true ) ) ; } } for ( node c = root . getfirstchild ( ) ; c != null ; c = c . getnextsibling ( ) ) { rroot . appendchild ( result . importnode ( c , true ) ) ; } } else { if ( n . getnodetype ( ) != node . document_type_node ) { if ( before ) { result . insertbefore ( result . importnode ( n , true ) , rroot ) ; } else { result . appendchild ( result . importnode ( n , true ) ) ; } } } } return result ; }
tr	1	private static stringbuilder build ( final stringbuilder result , final object subject , final int indent ) { if ( null == subject ) return result . append ( null ) ; else if ( subject . getclass ( ) . isarray ( ) ) return builditerable ( result , new arrayiterator ( subject ) , indent ) ; else if ( subject instanceof map < ? , ? > ) return builditerable ( result , ( ( map < ? , ? > ) subject ) . entryset ( ) . iterator ( ) , indent ) ; else if ( subject instanceof iterable < ? > ) return builditerable ( result , ( ( iterable < ? > ) subject ) . iterator ( ) , indent ) ; else if ( subject instanceof map . entry < ? , ? > ) return buildentry ( result , ( map . entry < ? , ? > ) subject , indent ) ; else return result . append ( subject . tostring ( ) ) ; }
tr	5	public loginview ( final crazybizapplication crazybizapplication ) { setspacing ( true ) ; loginpanel = new panel ( "crazybiz login" ) ; loginform = new loginform ( ) ; loginform . setusernamecaption ( "username" ) ; loginform . setpasswordcaption ( "password" ) ; loginform . setloginbuttoncaption ( "login" ) ; loginform . addlistener ( new loginlistener ( ) { @ override public void onlogin ( loginevent event ) { try { dbactions . connect ( ) ; if ( dbactions . isvalidlogin ( event . getloginparameter ( "username" ) , event . getloginparameter ( "password" ) ) ) { string username = event . getloginparameter ( "username" ) ; crazybizapplication . getwindow ( ) . removeallcomponents ( ) ; crazybizapplication . sethome ( new homepage ( crazybizapplication , username ) ) ; crazybizapplication . getwindow ( ) . addcomponent ( crazybizapplication . gethome ( ) ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } } } ) ; loginpanel . setwidth ( sizeable . size_undefined , 0 ) ; loginpanel . addcomponent ( loginform ) ; this . addcomponent ( loginpanel ) ; this . setcomponentalignment ( loginpanel , alignment . middle_center ) ; }
tr	3	public static void main ( string [ ] args ) { try { = ( 0 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".o.." , "oooo" , "..o." } , 3 ) , 2 ) ; = ( 1 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".....o" , "......" , "oooooo" , "oooooo" , "......" , "o....." } , 12 ) , 3 ) ; = ( 2 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "...." , ".oo." , ".oo." , "...." } , 3 ) , - 1 ) ; = ( 3 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "......." , "..ooo.." , "ooooooo" , ".oo.oo." , "oo...oo" } , 12 ) , 4 ) ; = ( 4 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "................." , ".ooooooo...oooo.." , ".ooooooo..oooooo." , ".oo.......oo..oo." , ".oo.......oo..oo." , ".ooooo.....oooo.." , ".ooooooo...oooo.." , ".....ooo..oo..oo." , "......oo..oo..oo." , ".ooooooo..oooooo." , ".oooooo....oooo.." , "................." } , 58 ) , 6 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
tr	4	private long checkclienttimeouts ( int timeout ) { set < integer > disconnectedclientids = new hashset < integer > ( ) ; long oldestclientcommunicationtime = - 1 ; synchronized ( connection_lock ) { if ( ! isrunning ) return - 1 ; long now = system . currenttimemillis ( ) ; oldestclientcommunicationtime = now ; for ( iterator < integer > iter = clients . keyset ( ) . iterator ( ) ; iter . hasnext ( ) ; ) { int clientid = iter . next ( ) ; clientinfo client = clients . get ( clientid ) ; if ( client . gettimeoflastcommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedclientids . add ( clientid ) ; } else if ( client . gettimeoflastcommunication ( ) < oldestclientcommunicationtime ) oldestclientcommunicationtime = client . gettimeoflastcommunication ( ) ; } } for ( int clientid : disconnectedclientids ) { logger . fine ( "client " + clientid + " timed out" ) ; onclientdisconnected ( clientid , server . client_timed_out ) ; } return oldestclientcommunicationtime ; }
tr	3	public double evalutethestrategy ( ) { double sellsum = 0 ; double buysum = 0 ; int count = 0 ; int numberofsell = this . getnumberofsell ( ) ; for ( generatedsignal gs : gensiglist ) { if ( gs . gettype ( ) . equals ( "sell" ) ) { sellsum += gs . getprice ( ) ; } else if ( gs . gettype ( ) . equals ( "buy" ) && count < numberofsell ) { buysum += gs . getprice ( ) ; count ++ ; } } return ( sellsum - buysum ) ; }
tr	4	private void insertdatabaseoperation ( object object , connection connection , databaseoperation databaseoperation ) { try { if ( ! object . getclass ( ) . isannotationpresent ( table . class ) ) { throw new jstrykerexception ( "object(" + object + ") isn't entity" ) ; } table table = object . getclass ( ) . getannotation ( table . class ) ; stringbuilder builder = new stringbuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; field [ ] fields = object . getclass ( ) . getdeclaredfields ( ) ; for ( field field : fields ) { field . setaccessible ( true ) ; object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isannotationpresent ( transient . class ) ) { continue ; } column annotation = field . getannotation ( column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getname ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; string string = builder . tostring ( ) ; execute ( null , connection , new bytearrayinputstream ( string . getbytes ( ) ) , databaseoperation ) ; } catch ( illegalaccessexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
tr	1	public static void assertequals ( final abstractquestion expected , final abstractquestion actual ) { assert . assertequals ( expected . getshowquestion ( ) , actual . getshowquestion ( ) ) ; assert . assertequals ( expected . getcorrectlyanswered ( ) , actual . getcorrectlyanswered ( ) ) ; assert . assertequals ( expected . getdifficulty ( ) , actual . getdifficulty ( ) ) ; databaselocationtest . assertequals ( expected . getlocation ( ) , actual . getlocation ( ) ) ; assert . assertequals ( expected . getpercentcorrect ( ) , actual . getpercentcorrect ( ) ) ; assert . assertequals ( expected . getquestionnumber ( ) , actual . getquestionnumber ( ) ) ; assert . assertequals ( expected . getquestionstring ( ) , actual . getquestionstring ( ) ) ; assert . assertequals ( expected . gettotaltimesanswered ( ) , actual . gettotaltimesanswered ( ) ) ; assert . assertequals ( expected . gettype ( ) , actual . gettype ( ) ) ; }
tr	3	public list < comborating > gettoplist ( ) throws sqlexception { statement st = null ; list < comborating > toplist = new arraylist < comborating > ( ) ; try { st = conn . createstatement ( ) ; resultset rs = st . executequery ( "select ((total_rating * 1.0)/times_rated) as rating  flavor_1  flavor_2  times_rated  total_rating from flavor_combo_ratings order by rating desc limit 10" ) ; while ( rs . next ( ) ) { toplist . add ( new comborating ( rs . getint ( "flavor_1" ) , rs . getint ( "flavor_2" ) , rs . getint ( "total_rating" ) , rs . getint ( "times_rated" ) ) ) ; } } finally { if ( st != null ) st . close ( ) ; } return toplist ; }
tr	5	private categorymodel insertcategory ( categorymodel category ) { try ( connection conn = devdbconfig . getconnection ( ) ) { try ( statement stmt = conn . createstatement ( ) ) { string sql = "insert into categories (name  staff_responsible)" + " values ('" + category . getname ( ) + "'  " + generatedstaffid + ")" ; stmt . executeupdate ( sql , statement . return_generated_keys ) ; try ( resultset rs = stmt . getgeneratedkeys ( ) ) { if ( rs . next ( ) ) { return new categorymodel ( rs . getint ( 1 ) , category ) ; } } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return null ; }
tr	5	private void loadpage_cssbox ( string urlstring ) { try { documentsource docsource = new defaultdocumentsource ( urlstring ) ; domsource parser = new defaultdomsource ( docsource ) ; document doc = parser . parse ( ) ; domanalyzer da = new domanalyzer ( doc , docsource . geturl ( ) ) ; da . attributestostyles ( ) ; da . addstylesheet ( null , cssnorm . stdstylesheet ( ) , origin . agent ) ; da . addstylesheet ( null , cssnorm . userstylesheet ( ) , origin . agent ) ; da . getstylesheets ( ) ; cssbox = new browsercanvas ( da . getroot ( ) , da , docsource . geturl ( ) ) ; cssbox . getconfig ( ) . setloadbackgroundimages ( true ) ; cssbox . getconfig ( ) . setloadimages ( true ) ; cssbox . createlayout ( contentscroll . getsize ( ) ) ; cssbox . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { system . out . println ( "click: " + e . getx ( ) + ":" + e . gety ( ) ) ; box node = locatebox ( cssbox . getviewport ( ) , e . getx ( ) , e . gety ( ) ) ; system . out . println ( "box: " + node ) ; if ( node != null ) { node . drawextent ( cssbox . getimagegraphics ( ) ) ; cssbox . repaint ( ) ; } } public void mousepressed ( mouseevent e ) { } public void mousereleased ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } } ) ; contentscroll . setviewportview ( cssbox ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	3	private static < t > void removeduplicatesbuffer ( node < t > list ) { if ( list == null ) { throw new illegalargumentexception ( ) ; } set < t > unique = new hashset < t > ( ) ; unique . add ( list . getdata ( ) ) ; while ( list . getnext ( ) != null ) { node < t > current = list ; while ( unique . contains ( current . getnext ( ) . getdata ( ) ) ) { current = current . getnext ( ) ; } unique . add ( current . getnext ( ) . getdata ( ) ) ; list . setnext ( current . getnext ( ) ) ; list = list . getnext ( ) ; } }
tr	1	public static void quadtexturedabs ( rect quad , rect texturecoords ) { double left = quad . x1 ( ) ; double bottom = quad . y2 ( ) ; double right = quad . x2 ( ) ; double top = quad . y1 ( ) ; double tleft = texturecoords . x1 ( ) ; double tbottom = texturecoords . y1 ( ) ; double tright = texturecoords . x2 ( ) ; double ttop = texturecoords . y2 ( ) ; glbegin ( gl_quads ) ; gltexcoord2d ( tleft , ttop ) ; glvertex2d ( left , top ) ; gltexcoord2d ( tright , ttop ) ; glvertex2d ( right , top ) ; gltexcoord2d ( tright , tbottom ) ; glvertex2d ( right , bottom ) ; gltexcoord2d ( tleft , tbottom ) ; glvertex2d ( left , bottom ) ; glend ( ) ; }
tr	2	public static byte [ ] hexstringtobytes ( string hex ) { int len = hex . length ( ) ; byte [ ] bytes = new byte [ ( len + 1 ) / 3 ] ; for ( int i = 0 ; i < len ; i += 3 ) { bytes [ i / 3 ] = ( byte ) ( ( character . digit ( hex . charat ( i ) , 16 ) << 4 ) + character . digit ( hex . charat ( i + 1 ) , 16 ) ) ; } return bytes ; }
tr	5	@ suppresswarnings ( "serial" ) private webmenubar setupmenubar ( webmenubar menuvar ) { menuvar . add ( new webmenu ( "file" , app . getimage ( ) . loadicon ( "/icons/file.png" ) ) { { add ( load = new webmenuitem ( "load" , app . getimage ( ) . loadicon ( "/icons/load.png" ) ) { { addactionlistener ( ll ) ; } } ) ; add ( save = new webmenuitem ( "save" , app . getimage ( ) . loadicon ( "/icons/save.png" ) ) { { addactionlistener ( sl ) ; setenabled ( false ) ; } } ) ; add ( backup = new webmenuitem ( "backup" ) { { addactionlistener ( bkl ) ; setenabled ( false ) ; } } ) ; add ( restore = new webmenuitem ( "restore" ) { { addactionlistener ( rsl ) ; setenabled ( false ) ; } } ) ; } } ) ; menuvar . add ( new webmenuitem ( "about" ) { { addactionlistener ( about ) ; } } ) ; return menuvar ; }
tr	1	@ test @ transactional ( propagation = propagation . requires_new ) public void getallcontents ( ) { set < content > got = new hashset < content > ( contentservice . getallcontents ( ) ) ; set < content > expected = new hashset < content > ( ) ; expected . add ( contentservice . getcontent ( fix . apelid ) ) ; expected . add ( contentservice . getcontent ( fix . gazetaid ) ) ; expected . add ( contentservice . getcontent ( fix . zakazaneid ) ) ; assertequals ( got , expected ) ; log . info ( "getting all the contents is ok." ) ; }
tr	5	private void generateproblems ( stringbuilder builder , booksettings settings , map < string , list < string >> cached ) { int maxproblemcolumns = settings . getproblemcolumns ( ) ; int maxproblemrows = settings . getproblemrows ( ) ; int maxanswercolumns = settings . getanswercolumns ( ) ; int maxanswerrows = settings . getanswerrows ( ) ; for ( booksettings . booksection section : settings . getsections ( ) ) { stringbuilder problempage = new stringbuilder ( ) ; stringbuilder problemrow = new stringbuilder ( ) ; stringbuilder problemrowcomments = new stringbuilder ( ) ; stringbuilder answerpagesbuffer = new stringbuilder ( ) ; stringbuilder answerpage = new stringbuilder ( ) ; stringbuilder answerrow = new stringbuilder ( ) ; stringbuilder answerrowcomments = new stringbuilder ( ) ; if ( section . getheader ( ) != null ) { problempage . append ( generatesubheader ( section . getheader ( ) ) ) ; answerpage . append ( generatesubheader ( "answers" , true ) ) ; } startpage ( problempage , maxproblemcolumns ) ; startpage ( answerpage , maxanswercolumns ) ; int curproblemcolumn = 0 ; int curproblemrow = 0 ; int curanswercolumn = 0 ; int curanswerrow = 0 ; int numanswers = 0 ; int numproblems = 0 ; int totalnumproblems = 1 ; for ( string sgf : section . getproblems ( ) ) { list < string > generated = cached . get ( sgf ) ; string problem = generated . get ( 0 ) ; includegraphics ( problemrow , problem ) ; addtablecell ( problemrow , curproblemcolumn , maxproblemcolumns ) ; includecomments ( problemrowcomments , addproblemprefix ( pdfinfo . getvariationcomments ( problem ) , totalnumproblems ) ) ; addtablecell ( problemrowcomments , curproblemcolumn , maxproblemcolumns ) ; if ( curproblemcolumn == maxproblemcolumns - 1 ) { problempage . append ( problemrow ) . append ( problemrowcomments ) ; problemrow = new stringbuilder ( ) ; problemrowcomments = new stringbuilder ( ) ; } curproblemcolumn = ( curproblemcolumn + 1 ) % maxproblemcolumns ; numproblems ++ ; for ( int i = 1 ; i <= settings . getvarsperproblem ( ) && i < generated . size ( ) ; i ++ ) { string answer = generated . get ( i ) ; includegraphics ( answerrow , answer ) ; addtablecell ( answerrow , curanswercolumn , maxanswercolumns ) ; includecomments ( answerrowcomments , addproblemprefix ( pdfinfo . getvariationcomments ( answer ) , totalnumproblems ) ) ; addtablecell ( answerrowcomments , curanswercolumn , maxanswercolumns ) ; if ( curanswercolumn == maxanswercolumns - 1 ) { answerpage . append ( answerrow ) . append ( answerrowcomments ) ; answerrow = new stringbuilder ( ) ; answerrowcomments = new stringbuilder ( ) ; } curanswercolumn = ( curanswercolumn + 1 ) % maxanswercolumns ; numanswers ++ ; if ( numanswers == maxanswerrows * maxanswercolumns ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; answerpage = startnewpage ( maxanswercolumns ) ; numanswers = 0 ; } } totalnumproblems ++ ; if ( numproblems == maxproblemrows * maxproblemcolumns ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; finishpagewithtrailer ( builder , problempage ) ; finishpage ( builder , answerpagesbuffer ) ; answerpage = startnewpage ( maxanswercolumns ) ; problempage = startnewpage ( maxproblemcolumns ) ; answerpagesbuffer = new stringbuilder ( ) ; numproblems = 0 ; numanswers = 0 ; } } if ( answerpage . length ( ) != 0 ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; } if ( problempage . length ( ) != 0 ) { finishpagewithtrailer ( builder , problempage ) ; } finishpage ( builder , answerpagesbuffer ) ; } }
tr	5	public static graph < vertex , edge > convert ( string name , string json ) { graph < vertex , edge > result = new graph < vertex , edge > ( edge . class ) ; gson gson = new gson ( ) ; wrapper data = gson . fromjson ( json , wrapper . class ) ; for ( childshapes pools : data . childshapes ) { if ( pools . childshapes . size ( ) > 0 ) { creategraph ( result , pools . childshapes , task_level ) ; } else { if ( pools . stencil != null && pools . stencil . id != null && pools . stencil . id . contains ( "flow" ) ) { for ( outgoing out : pools . outgoing ) if ( result . vertexidref . containskey ( out . resourceid ) ) { treemap < string , vertex > pair = new treemap < string , vertex > ( ) ; pair . put ( "trg" , result . vertexref . get ( result . vertexidref . get ( out . resourceid ) ) ) ; edges . put ( pools . resourceid , pair ) ; } } } } for ( string key : vedges . keyset ( ) ) { for ( string s : vedges . get ( key ) ) { if ( edges . containskey ( s ) ) { if ( result . vertexidref . containskey ( key ) ) { edges . get ( s ) . put ( "src" , result . vertexref . get ( result . vertexidref . get ( key ) ) ) ; } } } } for ( string key : edges . keyset ( ) ) { if ( edges . get ( key ) . containskey ( "src" ) && edges . get ( key ) . containskey ( "trg" ) ) { edge e = new edge ( edges . get ( key ) . get ( "src" ) , edges . get ( key ) . get ( "trg" ) ) ; result . adde ( e ) ; } else { } } return result ; }
tr	2	public void buildexampletexproject ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; map < texfontbuilder , string > namemap = dobuildtypefacepackage ( dir , packagename ) ; file texfile = new file ( dir , "example.tex" ) ; printwriter out = new printwriter ( texfile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packagename ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{gulliver's travels}" ) ; out . println ( "\\author{jonathan swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "the first request i made  after i had obtained my liberty  was  that i might have license " + "to see mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. the people had notice  by " + "proclamation  of my design to visit the town. the wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. i stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. i walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. the garret windows and tops of houses were so crowded with spectators  that i thought " + "in all my travels i had not seen a more populous place. the city is an exact square  each side of the " + "wall being five hundred feet long. the two great streets  which run across and divide it into four " + "quarters  are five feet wide. the lanes and alleys  which i could not enter  but only view them as " + "i passed  are from twelve to eighteen inches. the town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{the emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " it is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. i had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  i could easily view it on every side. the outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which i was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. at the same time the emperor had a great desire that i should see the magnificence of his " + "palace; but this i was not able to do till three days after  which i spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "of these trees i made two stools  each about three feet high  and strong enough to bear my weight. " + "the people having received notice a second time  i went again through the city to the palace with " + "my two stools in my hands. when i came to the side of the outer court  i stood upon one stool  and " + "took the other in my hand; this i lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. i then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "by this contrivance i got into the inmost court; and  lying down upon my side  i applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. there i saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( string name : namemap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
tr	4	public arraylist listatodos ( ) { arraylist listacartao = new arraylist < > ( ) ; string sql = "select * from cartoes order by cartao_id" ; try { connection con = conectar . getinstance ( ) . conect ( ) ; preparar = con . preparestatement ( sql ) ; resultset resultado = preparar . executequery ( ) ; while ( resultado . next ( ) ) { listacartao . add ( new object [ ] { resultado . getlong ( "cartao_id" ) , resultado . getlong ( "saldo_cartao" ) } ) ; } preparar . close ( ) ; } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( null , ex . getmessage ( ) ) ; } return listacartao ; }
tr	3	private void readpolar ( ) throws ioexception { long currtime ; while ( isread ) { currtime = system . currenttimemillis ( ) ; int msg = inputstream . read ( ) ; if ( msg == 254 ) { printmessage ( "\n" + system . currenttimemillis ( ) + ": " ) ; polarmessagetmp = new polarmessage ( system . currenttimemillis ( ) ) ; } else if ( msg == - 1 ) { system . out . println ( "roz\u0142\u0105czono" ) ; stopread ( ) ; break ; } else if ( polarmessagetmp != null && polarmessagetmp . setnextvalue ( msg ) ) { message = new polarmessage ( system . currenttimemillis ( ) ) ; message . sethr ( polarmessagetmp . gethr ( ) ) ; } if ( currtime - system . currenttimemillis ( ) > 3000 ) { system . out . println ( "zbyt d\u0142ugi czas oczekiwania" ) ; } printmessage ( " " + msg ) ; } }
tr	3	@ override public boolean done ( arraylist < node > nw , int fab ) { int a = ( ( beaconfab ) nw . get ( 0 ) . getfab ( fab ) ) . a ; set < integer > armies = new hashset < integer > ( ) ; int min = integer . max_value ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( node n : nw ) { armies . add ( ( ( beaconfab ) n . getfab ( fab ) ) . a ) ; sw = ( ( beaconfab ) n . getfab ( fab ) ) . d ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( beaconfab ) n . getfab ( fab ) ) . a != a ) { res = false ; } } return res ; }
tr	2	private static byte [ ] constructorvaluehelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
tr	2	public void start ( string args [ ] ) { try { this . host = args [ 0 ] ; this . tcpport = integer . parseint ( args [ 1 ] ) ; this . analyticserverref = args [ 2 ] ; } catch ( numberformatexception e ) { logger . error ( "seconds argument has to be an integer" ) ; } catch ( arrayindexoutofboundsexception e ) { logger . error ( "too few arguments" ) ; } propertyconfigurator . configure ( "src/log4j.properties" ) ; readproperties ( ) ; managementclient = new managementclient ( analyticserverref ) ; managementclient . start ( ) ; managementclient . processinput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { loadtestclient client = new loadtestclient ( host , tcpport ) ; testclients . add ( client ) ; if ( auctionspermin > 0 ) client . createauctions ( auctionspermin , auctionduration ) ; if ( bidspermin > 0 ) client . bidauctions ( bidspermin ) ; executorservice . execute ( client ) ; } loadtestclient updater = new loadtestclient ( host , tcpport ) ; testclients . add ( updater ) ; updater . updatelist ( updateintervalsec ) ; executorservice . execute ( updater ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( system . in ) ) ; try { input . readline ( ) ; input . close ( ) ; } catch ( ioexception ex ) { logger . error ( "io exception on system standard input" ) ; } shutdown ( ) ; }
tr	1	public void setflagsfalse ( ) { ltflag = false ; lbflag = false ; l1flag = false ; l2flag = false ; l3flag = false ; l4flag = false ; l5flag = false ; d1flag = false ; d2flag = false ; d3flag = false ; d4flag = false ; s1flag = false ; s2flag = false ; r1flag = false ; r2flag = false ; r3flag = false ; r4flag = false ; r5flag = false ; xflag = false ; yflag = false ; bflag = false ; aflag = false ; rtflag = false ; rbflag = false ; }
tr	2	annotatedoption ( class clazz , field field , param param ) { this . clazz = clazz ; this . field = field ; this . param = param ; if ( param . option ( ) . isempty ( ) ) { opt = field . getname ( ) . substring ( 0 , 1 ) . tolowercase ( ) ; } else { opt = param . option ( ) ; } if ( param . name ( ) . isempty ( ) ) { name = field . getname ( ) . tolowercase ( ) ; } else { name = param . name ( ) ; } }
tr	4	public static method getasmethodofpublicbase ( class < ? > c , method m ) { for ( class < ? > iface : c . getinterfaces ( ) ) { for ( method im : iface . getmethods ( ) ) { if ( ismatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getsuperclass ( ) ; if ( sc == null ) { return null ; } for ( method scm : sc . getmethods ( ) ) { if ( ismatch ( scm , m ) ) { return scm ; } } return getasmethodofpublicbase ( sc , m ) ; }
tr	5	@ override public animal breed ( animal a ) { if ( a instanceof chicken ) { chicken mate = ( chicken ) a ; if ( ismale ( ) == ! mate . ismale ( ) ) { string [ ] child = new string [ genecount ] ; do { char [ ] a1 = getrandomalleles ( ) ; char [ ] a2 = ( ( chicken ) mate ) . getrandomalleles ( ) ; for ( int i = 0 ; i < genecount ; i ++ ) { child [ i ] = "" + a1 [ i ] + a2 [ i ] ; } } while ( child [ 4 ] . equals ( "cc" ) ) ; chicken chick = new chicken ( child ) ; chick . parents [ 0 ] = this ; chick . parents [ 1 ] = mate ; return chick ; } else { return null ; } } else { return null ; } }
tr	2	public static abstractuiitem createitem ( featuretype t , panel panel ) { switch ( t ) { case constant : return new constantuiitem ( panel ) ; case sink : return new sinkuiitem ( panel ) ; case source : return new sourceuiitem ( panel ) ; case saddle : return new saddleuiitem ( panel ) ; case center : return new centeruiitem ( panel ) ; case focus : return new focusuiitem ( panel ) ; case convergingelement : return new convergingelementuiitem ( panel ) ; case divergingelement : return new divergingelementuiitem ( panel ) ; case generic : return new genericuiitem ( panel ) ; } assert false : "unhandled type: " + t ; return null ; }
tr	4	public static void main ( final string args [ ] ) { if ( args . length != 0 ) { string name = args [ 0 ] ; try { querydefinition query = settings . getinstance ( ) . getquery ( name ) ; response response = query . execute ( ) ; system . out . print ( response . getrawvalue ( ) ) ; } catch ( exception e ) { system . err . print ( e . getmessage ( ) ) ; } } else { invokelater ( new runnable ( ) { public void run ( ) { new mainform ( args ) . setvisible ( true ) ; } } ) ; } }
tr	3	private jtoolbar createtoolbar ( ) { jtoolbar tb = new jtoolbar ( ) ; tb . setfloatable ( false ) ; tb . setrollover ( true ) ; tb . add ( newaction ) ; tb . add ( openaction ) ; tb . add ( saveaction ) ; tb . addseparator ( ) ; tb . add ( cutaction ) ; tb . add ( copyaction ) ; tb . add ( pasteaction ) ; tb . addseparator ( ) ; tb . add ( addaction ) ; tb . add ( editaction ) ; tb . add ( delaction ) ; tb . addseparator ( ) ; tb . add ( findaction ) ; tb . addseparator ( ) ; tb . add ( keyaction ) ; tb . add ( box . createhorizontalglue ( ) ) ; final jtextfield searchfield = new jtextfield ( ) ; searchfield . setminimumsize ( new dimension ( 120 , 21 ) ) ; searchfield . setpreferredsize ( new dimension ( 120 , 21 ) ) ; searchfield . setmaximumsize ( new dimension ( 120 , 21 ) ) ; final actionlistener searchlistener = new actionlistener ( ) { public void actionperformed ( actionevent e ) { zamokview view = gettab ( ) ; if ( view != null ) view . setfilter ( searchfield . gettext ( ) ) ; } } ; searchfield . addactionlistener ( searchlistener ) ; searchfield . getdocument ( ) . adddocumentlistener ( new documentlistener ( ) { public void insertupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void removeupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void changedupdate ( documentevent e ) { } } ) ; tb . add ( searchfield ) ; tb . addseparator ( ) ; return tb ; }
tr	4	public static void main ( string [ ] args ) throws ioexception , classnotfoundexception , parseexception { properties properties = new properties ( ) ; properties . load ( client . class . getclassloader ( ) . getresourceasstream ( "client.properties" ) ) ; integer serverport = integer . valueof ( properties . getproperty ( "client.server_port" , "1234" ) ) ; string serveraddress = properties . getproperty ( "client.server_address" , "localhost" ) ; objectoutputstream toserver = null ; objectinputstream fromserver = null ; socket connectionsocket = null ; try { connectionsocket = new socket ( serveraddress , serverport ) ; scanner scanner = new scanner ( system . in ) ; toserver = new objectoutputstream ( connectionsocket . getoutputstream ( ) ) ; fromserver = new objectinputstream ( connectionsocket . getinputstream ( ) ) ; log . info ( "connection created!" ) ; while ( ! start ( toserver , fromserver , scanner ) ) ; while ( homepage ( toserver , fromserver , scanner ) ) ; } catch ( ioexception e ) { log . error ( "can't connect to server." , e ) ; } catch ( nosuchelementexception e ) { log . error ( "user terminated session" , e ) ; } finally { if ( toserver != null ) { try { toserver . close ( ) ; } catch ( ioexception e ) { log . error ( "to server stream closing error" , e ) ; } } if ( fromserver != null ) { try { fromserver . close ( ) ; } catch ( ioexception e ) { log . error ( "from server stream closing error" , e ) ; } } if ( connectionsocket != null ) { try { connectionsocket . close ( ) ; } catch ( ioexception e ) { log . error ( "connection socket closing error" , e ) ; } } } }
tr	4	public void openfile ( string filename ) { if ( m_bmpegplaying ) { m_bkeeprunning = false ; } if ( m_inputstream != null ) { try { m_inputstream . close ( ) ; } catch ( ioexception e ) { showdialog ( warning , e . getmessage ( ) ) ; } } if ( filename != null ) { try { try { url url = new url ( filename ) ; m_inputstream = new java . io . bufferedinputstream ( url . openstream ( ) ) ; } catch ( malformedurlexception e ) { m_inputstream = new java . io . bufferedinputstream ( new fileinputstream ( filename ) ) ; } } catch ( ioexception e ) { showdialog ( error , e . getmessage ( ) ) ; } } else showdialog ( error , "null filename" ) ; }
tr	5	public static int getheuristicdistance ( final int w , final int h , final string b ) { int ret = 0 ; final string string = "0123456789abcdefghijklmnopqrstuvwxyz" ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { final int index = i * w + j ; if ( index > 0 ) { final char c = b . charat ( index ) ; if ( c != = ) { final int number = ( string . indexof ( c ) + w * h - 1 ) % ( w * h ) ; ret += math . abs ( number / w - i ) + math . abs ( number % w - j ) ; } } } } return ret ; }
tr	2	void readfromzip ( string filename ) throws saxexception , transformerconfigurationexception , xmlstreamexception , ioexception { try { zipin = new zipfile ( filename ) ; } catch ( filenotfoundexception e1 ) { e1 . printstacktrace ( ) ; } if ( zipin != null ) { while ( visupages . gettabcount ( ) > 0 ) visupages . removetabat ( 0 ) ; hardwareoptdlg . dispose ( ) ; hardwareoptdlg = new hardwarepropertiesdialog ( this ) ; hardwareoptdlg . setlocation ( 220 , 120 ) ; pictures . cleararchive ( ) ; pictures . loadlibraryfromarchive ( zipin ) ; sounds . cleararchive ( ) ; sounds . loadlibraryfromarchive ( zipin ) ; zipentry visuzipobj = zipin . getentry ( "visu.xml" ) ; inputstream zipinstream = zipin . getinputstream ( visuzipobj ) ; parsexmlstream ( zipinstream ) ; zipin . close ( ) ; } }
tr	4	@ override public synchronized boolean add ( plugin plugin ) { iterator < plugin > iter = this . iterator ( ) ; while ( iter . hasnext ( ) ) { if ( iter . next ( ) . getname ( ) . equals ( plugin . getname ( ) ) ) { return false ; } } plugin . addpropertychangelistener ( new propertychangelistener ( ) { public void propertychange ( propertychangeevent evt ) { if ( evt . getpropertyname ( ) . equals ( "plugin_files_compared" ) ) { int pos = pluginlist . this . indexof ( evt . getnewvalue ( ) ) ; propertychange . firepropertychange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messagedatabase != null ) { plugin . setmessagedatabase ( messagedatabase ) ; } return super . add ( plugin ) ; }
tr	5	private void reflectclasswrapper ( map < type , set < genetrait >> genepool , string classname , int parametercount , list < string > parametertypes , int parametersset ) throws classnotfoundexception { if ( parametersset < parametercount ) { for ( breedingclasssetup classsetup : settings . getsettings ( ) . getclasses ( ) ) { if ( ! rawtypesclassmap . containskey ( classsetup . classname ) ) { if ( parametertypes . size ( ) >= parametersset + 1 ) { parametertypes . remove ( parametersset ) ; } parametertypes . add ( parametersset , classsetup . classname ) ; reflectclasswrapper ( genepool , classname , parametercount , parametertypes , parametersset + 1 ) ; } } } else { class < ? > clazz = rawtypesclassmap . get ( classname ) ; if ( clazz == null ) { clazz = class . forname ( classname ) ; } type classtype = type . gettype ( classname + ( ( parametercount == 0 ) ? "" : ( "<" + tools . implode ( parametertypes , " " ) + ">" ) ) ) ; reflectclass ( genepool , clazz , classname , classtype , parametertypes ) ; } }
tr	5	public static void fileopen ( ) { final filereader fr = new filereader ( ) ; fr . openfile ( ) ; if ( fr . getfile ( ) == null && ! fr . isscmfile ( ) ) return ; mainmethods . updatetreeview ( fr ) ; if ( fr . getfile ( ) != null ) { thread fileparser = new thread ( new runnable ( ) { public void run ( ) { channellist channellist = fr . parsefile ( ) ; if ( channellist != null ) { mainmethods . updatechanneltable ( channellist ) ; } else system . out . println ( "chlist is null" ) ; } } ) ; fileparser . start ( ) ; } mainmethods . openfile = fr ; }
tr	5	public static application parseapplicationdescription ( jsonobject topjson , boolean store ) throws dbexception { try { jsonobject appjson ; appjson = topjson . getjsonobject ( "application" ) ; if ( ! appjson . has ( "user_id" ) ) { appjson . put ( "user_id" , ( user . getbyname ( appjson . getstring ( "user_name" ) ) ) . getid ( ) ) ; } application app = new application ( appjson ) ; if ( store ) app . store ( ) ; log . debug ( "loading description for app:" + app . getdescription ( ) ) ; jsonarray modules = appjson . getjsonarray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { jsonobject m = modules . getjsonobject ( i ) ; m . put ( "application_id" , app . getid ( ) ) ; module module = new module ( m ) ; if ( store ) module . store ( ) ; log . debug ( "parsed module:" + module ) ; jsonarray components = m . getjsonarray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { jsonobject c = components . getjsonobject ( j ) ; c . put ( "module_id" , "" + module . getid ( ) ) ; if ( ! c . has ( "resource_type_id" ) ) { resourcetype rt = resourcetype . getbyname ( c . getstring ( "resource_type" ) ) ; c . put ( "resource_type_id" , rt . getid ( ) ) ; } component component = new component ( c ) ; if ( store ) component . store ( ) ; log . debug ( "parsed component: " + component ) ; } } return app ; } catch ( jsonexception ex ) { system . err . println ( "parsing not successfull" ) ; ex . printstacktrace ( ) ; } return null ; }
tr	2	private byte [ ] tobytes ( int v , int length ) { assert length % 4 == 0 ; assert length > 0 ; byte [ ] result = new byte [ length ] ; result [ 0 ] = ( byte ) ( v & ff ) ; result [ 1 ] = ( byte ) ( v >>> 8 & ff ) ; result [ 2 ] = ( byte ) ( v >>> 16 & ff ) ; result [ 3 ] = ( byte ) ( v >>> 24 & ff ) ; for ( int i = 4 ; i < length ; ) { int copylength = i <= length / 2 ? i : length - i ; system . arraycopy ( result , 0 , result , i , copylength ) ; i += copylength ; } return result ; }
tr	3	public void test_getrevisioninfo ( ) { filehistory filehist = new filehistory ( path . resolve ( "readme.txt" ) ) ; filehist . storerevision ( path . resolve ( "readme.txt" ) , null , 100 , 200 ) ; filehist . storerevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; filehist . storerevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; dataretriever dataretriever = new dataretriever ( path . resolve ( "readme.txt" ) ) ; vector < vector < string >> tabledata = dataretriever . getrevisioninfotable ( ) ; system . out . println ( "please check time-depend result:" ) ; for ( vector < string > rows : tabledata ) { for ( string data : rows ) { system . out . println ( data ) ; } } }
tr	1	@ test public void addingredienttest ( ) throws datastoreexception { list < ingredient > ingredients = helper . retrieveallingredients ( ) ; int oldsize = ingredients . size ( ) ; ingredient ingredient = new ingredient ( "kommen" , "kommen" , false ) ; asserttrue ( "addingredient should succeed and return true" , helper . addingredient ( ingredient ) ) ; assertfalse ( "the new ingredient is not already in the list" , ingredients . contains ( ingredient ) ) ; ingredients = helper . retrieveallingredients ( ) ; assertequals ( "size should increase when new ingredient is added" , oldsize + 1 , ingredients . size ( ) ) ; asserttrue ( "the new ingredient should now be in the list" , ingredients . contains ( ingredient ) ) ; resetdatabase ( ) ; }
tr	3	public string simplifypath ( string path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charat ( 0 ) != / ) return path ; list < string > buf = new arraylist < string > ( ) ; int pathlen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathlen && path . charat ( start ) == / ) start ++ ; if ( start == pathlen ) break ; for ( end = start ; end < pathlen ; end ++ ) { if ( path . charat ( end ) == / ) break ; } string curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { stringbuilder builder = new stringbuilder ( ) ; for ( string dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . tostring ( ) ; } }
tr	4	public void update ( final world w ) { for ( short x = 0 ; x < sidelength ; x ++ ) { for ( short y = 0 ; y < sidelength ; y ++ ) { short tilex = ( short ) ( x + ( coords . getx ( ) * sidelength ) ) ; short tiley = ( short ) ( y + ( coords . gety ( ) * sidelength ) ) ; final tile t = gettile ( x , y ) ; if ( ( t == tiles . air ) || ( t == null ) ) { new packet03tile ( t , tilex , tiley ) . writedatatoserver ( ) ; } if ( t . doestick ( ) ) { t . update ( w , tilex , tiley ) ; } } } }
tr	4	latexexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } mfamilylabel = new jlabel ( "name" ) ; mfamilylabel . sethorizontalalignment ( jlabel . right ) ; mfamilyfield = new jtextfield ( "" ) ; mnoticelabel = new jlabel ( "note that latex maps \"\\textbf\"\nto bold_extended  not bold." ) ; add ( mfamilylabel ) ; add ( mfamilyfield ) ; add ( mnoticelabel ) ; mfontstacker = new componentstacker ( ) ; mfontstacker . setstackdirection ( componentstacker . stack_vertical ) ; mfontstacker . setstretch ( true ) ; mfontstacker . setmargins ( 0 , 0 ) ; mfontstacker . setborder ( borderfactory . createtitledborder ( "fonts" ) ) ; mfontstacker . setbackground ( color . white ) ; add ( mfontstacker ) ; int i = 0 ; mfontpanels = new arraylist < fontpanel > ( ) ; for ( fonthandle f : fonts ) { fontpanel p = new fontpanel ( f ) ; p . setsize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setbackground ( palette . odd_color ) ; } else { p . setbackground ( palette . even_color ) ; } mfontstacker . add ( p ) ; mfontpanels . add ( p ) ; } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mcancelbutton = new jbutton ( "cancel" ) ; mokbutton = new jbutton ( "ok" ) ; add ( mcancelbutton ) ; add ( mokbutton ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; mokbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dookay ( ) ; } } ) ; setlayout ( new layout ( ) ) ; setopaque ( true ) ; mdialog = new jdialog ( ( window ) parent , "configure tex typeface" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 550 , 650 ) ; mdialog . setlocationrelativeto ( null ) ; mdialog . setvisible ( true ) ; }
tr	3	public boolean recordlogin ( inetaddress origin , string username ) { boolean ret = false ; watch time = new watch ( ) ; string incquery = "update history set lastloginindex = lastloginindex + 1 mod length where username = '" + username + "';" ; string delquery = "delete login from login join history on(login.hid = history.hid) where login.index = ((history.lastloginindex + 1) mod length) and history.username = '" + username + "';" ; string query = "insert into login(hid  ip  month  day  year  `index`  hours  minutes)" + " select hid  inet_aton('" + origin . gethostaddress ( ) + "')  " + time . getmonth ( ) + "  " + time . getdate ( ) + "  " + time . getyear ( ) + "  lastloginindex mod length  " + time . gethours ( ) + "  " + time . getminutes ( ) + " " + "from history " + "where username = '" + username + "';" ; try { connect ( ) ; statement stmt = connection . createstatement ( ) ; stmt . executeupdate ( delquery ) ; connection . setautocommit ( false ) ; stmt . executeupdate ( incquery ) ; stmt . executeupdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( sqlexception e1 ) { e1 . printstacktrace ( ) ; } } finally { if ( connection != null ) try { connection . setautocommit ( true ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return ret ; }
tr	2	public list < hostel > getavailablebedsinallhostels ( date startdate , date enddate ) { list < hostel > hostels = null ; if ( startdate . after ( enddate ) ) { return null ; } calendar cal = calendar . getinstance ( ) ; cal . settime ( new java . util . date ( ) ) ; if ( startdate . before ( cal . gettime ( ) ) ) { return null ; } try { hostels = hosteldaoimpl . getavailablebedsinallhostels ( startdate , enddate ) ; } catch ( servicelocatorexception | sqlexception e ) { e . printstacktrace ( ) ; } return hostels ; }
tr	1	public void testsimplebuild ( ) throws ioexception , xmlpullparserexception { dom2xmlpullbuilder builder = new dom2xmlpullbuilder ( ) ; final string xml = "<n:foo xmlns:n='uri1'><bar n:attr='test' xmlns='uri2'>baz</bar></n:foo>" ; stringreader reader = new stringreader ( xml ) ; element el1 = builder . parse ( reader ) ; stringwriter sw = new stringwriter ( ) ; reader = new stringreader ( xml ) ; element el2 = builder . parse ( reader ) ; element root = el2 ; assertequals ( "uri1" , root . getnamespaceuri ( ) ) ; assertequals ( "foo" , root . getlocalname ( ) ) ; nodelist children = root . getelementsbytagnamens ( "*" , "bar" ) ; element | = ( element ) children . item ( 0 ) ; assertequals ( "uri2" , | . getnamespaceuri ( ) ) ; assertequals ( "bar" , | . getlocalname ( ) ) ; string attrvalue = | . getattributens ( "uri1" , "attr" ) ; assertequals ( "test" , attrvalue ) ; attr attr = | . getattributenodens ( "uri1" , "attr" ) ; assertnotnull ( attr ) ; assertequals ( "uri1" , attr . getnamespaceuri ( ) ) ; assertequals ( "attr" , attr . getlocalname ( ) ) ; assertequals ( "test" , attr . getvalue ( ) ) ; text text = ( text ) | . getfirstchild ( ) ; assertequals ( "baz" , text . getnodevalue ( ) ) ; }
tr	3	private void assigncontent ( ) throws saxexception { try { int lastobject = buildobjects . size ( ) - 1 ; if ( lastobject >= 0 ) { object obj = buildobjects . get ( lastobject ) ; this . setattribute ( obj , this . settername , content . tostring ( ) ) ; } else { logger . trace ( "no objects in build queue." ) ; } } catch ( fogbugzexception e ) { logger . trace ( "throwing exception upwards." , e ) ; throw new saxexception ( e ) ; } content . delete ( 0 , content . length ( ) ) ; content . setlength ( 0 ) ; }
tr	2	@ suppresswarnings ( "unchecked" ) public caseinsensitivedictionary ( dictionary delegate ) { notnullexception . assertvalue ( delegate , "delegate" ) ; this . delegate = new hashtable < string , object > ( delegate . size ( ) ) ; this . originalkeys = collections . synchronizedset ( new hashset < string > ( ) ) ; enumeration < string > e = delegate . keys ( ) ; while ( e . hasmoreelements ( ) ) { string key = e . nextelement ( ) ; if ( get ( key ) != null ) throw new illegalargumentexception ( "duplicates with varying case for key [" + key + "] : " + delegate ) ; this . delegate . put ( key . tolowercase ( locale . english ) , delegate . get ( key ) ) ; originalkeys . add ( key ) ; } }
tr	5	public void convert ( idchanger ui , hashmap < blockuid , blockuid > translations , pluginloader pluginloader ) { status status = ui . status ; status . changedchest = 0 ; status . changedplaced = 0 ; status . changedplayer = 0 ; int count_file = 0 ; long begintime = system . currenttimemillis ( ) ; status . pb_file . setmaximum ( playerfiles . size ( ) - 1 ) ; arraylist < converterplugin > regionplugins = pluginloader . getpluginsoftype ( plugintype . region ) ; arraylist < converterplugin > playerplugins = pluginloader . getpluginsoftype ( plugintype . player ) ; for ( playerfile playerfile : playerfiles ) { status . pb_file . setvalue ( count_file ++ ) ; status . lb_file . settext ( "current file: " + playerfile . getname ( ) ) ; datainputstream dis = null ; dataoutputstream dos = null ; try { dis = new datainputstream ( new bufferedinputstream ( new gzipinputstream ( new fileinputstream ( playerfile ) ) ) ) ; compoundtag root = nbtio . read ( dis ) ; for ( converterplugin plugin : playerplugins ) { plugin . convert ( status , root , translations ) ; } dos = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( playerfile ) ) ) ; nbtio . writecompressed ( root , dos ) ; } catch ( ioexception e ) { logger . log ( level . severe , "unable to convert player inventories" , e ) ; return ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close output stream" , e ) ; } } if ( dis != null ) { try { dis . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close input stream" , e ) ; } } } } count_file = 0 ; if ( regionfiles == null ) { return ; } status . pb_file . setvalue ( 0 ) ; status . pb_file . setmaximum ( regionfiles . size ( ) - 1 ) ; for ( regionfileextended r : regionfiles ) { status . lb_file . settext ( "current file: " + r . filename . getname ( ) ) ; status . pb_file . setmaximum ( regionfiles . size ( ) - 1 ) ; status . pb_file . setvalue ( count_file ++ ) ; try { r . convert ( status , translations , regionplugins ) ; } catch ( ioexception e ) { logger . log ( level . severe , "unable to convert placed blocks" , e ) ; return ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close region file" , e ) ; } } } } long duration = system . currenttimemillis ( ) - begintime ; joptionpane . showmessagedialog ( ui , "done in " + duration + "ms" + system . getproperty ( "line.separator" ) + status . changedplaced + " placed blocks changed." + system . getproperty ( "line.separator" ) + status . changedplayer + " blocks in player inventories changed." + system . getproperty ( "line.separator" ) + status . changedchest + " blocks in entity inventories changed." , "information" , joptionpane . information_message ) ; }
tr	1	@ test public void testestadisp ( ) { reserva r = new reserva ( dini , dfi , preureserva , dniclient , nomhotel , numerohabitacio ) ; habproves . afreserva ( r ) ; boolean result = habproves . estadisp ( dini , dfi ) ; assertfalse ( result ) ; calendar ini = calendar . getinstance ( ) ; calendar fi = calendar . getinstance ( ) ; ini . set ( 2012 , 1 , 17 ) ; fi . set ( 2012 , 1 , 24 ) ; result = habproves . estadisp ( ini . gettime ( ) , fi . gettime ( ) ) ; asserttrue ( result ) ; }
tr	4	private void createunits ( ) { arraylist < building > buildings = g . map . getplayersbuildings ( this ) ; boolean hasmoney = true ; while ( hasmoney ) { for ( building building : buildings ) { if ( building instanceof factory ) { ( ( factory ) building ) . recruittank ( g . map , building . getcell ( ) , true ) ; } if ( building instanceof barracks ) { ( ( barracks ) building ) . recruitmarine ( g . map , building . getcell ( ) , true ) ; } } if ( buildings . contains ( barracks . class ) ) { hasmoney = this . getmoney ( ) >= marine . cost ; } else if ( buildings . contains ( factory . class ) ) { hasmoney = this . getmoney ( ) >= tank . cost ; } else { hasmoney = false ; } } }
tr	1	public static void main ( string args [ ] ) { heightweight h1 = new heightweight ( ) ; h1 . height = 10 ; h1 . weight = 10 ; heightweight h2 = new heightweight ( ) ; h2 . height = 1 ; h2 . weight = 1 ; heightweight h3 = new heightweight ( ) ; h3 . height = 190 ; h3 . weight = 190 ; heightweight h4 = new heightweight ( ) ; h4 . height = 200 ; h4 . weight = 200 ; heightweight h5 = new heightweight ( ) ; h5 . height = 180 ; h5 . weight = 180 ; list < heightweight > hw = new java . util . linkedlist < heightweight > ( ) ; hw . add ( h1 ) ; hw . add ( h2 ) ; hw . add ( h3 ) ; hw . add ( h4 ) ; hw . add ( h5 ) ; int max = 0 ; int length = largesttower . maketower ( hw ) ; system . out . println ( length ) ; }
tr	4	void initialize ( int d ) { this . matarray = new material [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . tilestate = new int [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . cleancolor = new material ( ) ; this . cleancolor . setambient ( 0.7 , 0.7 , 0.7 ) ; this . cleancolor . setdiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleancolor . setspecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredcolor = new material ( ) ; this . coveredcolor . setambient ( 0.1 , 0.1 , 0.1 ) ; this . coveredcolor . setdiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredcolor . setspecular ( .5 , .5 , .5 , 10 ) ; this . redcolor = new material ( ) ; this . redcolor . setambient ( 0.9 , 0.1 , 0.1 ) ; this . redcolor . setdiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redcolor . setspecular ( .95 , .15 , .15 , 10 ) ; this . yellowcolor = new material ( ) ; this . yellowcolor . setambient ( 0.9 , 0.9 , 0.1 ) ; this . yellowcolor . setdiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowcolor . setspecular ( .95 , .95 , .15 , 10 ) ; this . bluecolor = new material ( ) ; this . bluecolor . setambient ( 0.1 , 0.1 , 0.9 ) ; this . bluecolor . setdiffuse ( 0.15 , 0.15 , 0.95 ) ; this . bluecolor . setspecular ( .15 , .15 , .95 , 10 ) ; this . greencolor = new material ( ) ; this . greencolor . setambient ( 0.1 , 0.9 , 0.1 ) ; this . greencolor . setdiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greencolor . setspecular ( .15 , .95 , .15 , 10 ) ; this . orangecolor = new material ( ) ; this . orangecolor . setambient ( 0.98 , 0.5 , 0.25 ) ; this . orangecolor . setdiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangecolor . setspecular ( .99 , .52 , .27 , 10 ) ; this . purplecolor = new material ( ) ; this . purplecolor . setambient ( 0.9 , 0.1 , 0.9 ) ; this . purplecolor . setdiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purplecolor . setspecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getnumfaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getdimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getdimension ( ) ; column ++ ) { this . getface ( face ) [ row ] [ column ] . setmaterial ( this . coveredcolor ) ; this . tilestate [ face ] [ row ] [ column ] = 0 ; } } } }
tr	1	@ override public string tostring ( ) { stringbuilder tmp = new stringbuilder ( ) ; tmp . append ( "estructura de la mesura:\n" ) ; tmp . append ( "idrule=" ) . append ( this . beanrule . getidrule ( ) ) . append ( "  descripcio=" ) . append ( this . beanrule . descripcio ) ; tmp . append ( "renderclass=" ) . append ( this . beanrule . getclassname ( ) ) ; tmp . append ( "mapa=" ) . append ( this . map . tostring ( ) ) . append ( "\n" ) ; tmp . append ( "fields=" ) . append ( this . beanrule . fields . tostring ( ) ) . append ( "\n" ) ; return tmp . tostring ( ) ; }
tr	5	private void initialize ( ) { mnbuttons = new hashmap < menucontent , jmenu > ( ) ; mnitems = new hashmap < menuitem , jmenuitem > ( ) ; for ( final menucontent menu : menucontent . values ( ) ) { final jmenu mnbutton = new jmenu ( window . geti18nstring ( menu . getsection ( ) ) ) ; mnbuttons . put ( menu , mnbutton ) ; add ( mnbutton ) ; final list < menuitem > items = menu . getitems ( ) ; for ( final menuitem item : items ) { final jmenuitem mnitem = new extjmenuitem ( window . geti18nstring ( item . getname ( ) ) , parent ) ; mnitems . put ( item , mnitem ) ; mnbutton . add ( mnitem ) ; try { switch ( menu ) { case file : mnitem . addactionlistener ( new filebuttonslistener ( item ) ) ; break ; case edit : mnitem . addactionlistener ( new editbuttonslistener ( item ) ) ; break ; case about : mnitem . addactionlistener ( new aboutbuttonactionlistener ( ) ) ; break ; } } catch ( final illegalparametrs e ) { e . printstacktrace ( ) ; } } } }
tr	2	public static void main ( string [ ] args ) { dateformat dateformat = new simpledateformat ( dateutil . date_format ) ; date birthdate = null ; try { birthdate = dateformat . parse ( "1983-12-07" ) ; } catch ( parseexception ex ) { ex . printstacktrace ( system . err ) ; } logininfo logininfo = new logininfo ( "shamim" , "secret" ) ; billinginfo billinginfo = new billinginfo ( "003-254992-001" , creditcardtype . mastercard ) ; biographicalinfo biographicalinfo = new biographicalinfo ( "shamim" , "ahmed" , birthdate ) ; usercreator . setlogininfo ( logininfo ) ; usercreator . setbillinginfo ( billinginfo ) ; usercreator . setbiographicalinfo ( biographicalinfo ) ; boolean result = usercreator . adduser ( ) ; system . out . printf ( "user %s created successfully%n" , result ? "was" : "was not" ) ; }
tr	3	public string look ( ) { stringbuffer names = new stringbuffer ( ) ; string items = currroom . getitemnames ( ) ; string monsters = currroom . getmonsternames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "monsters: " ) ; names . append ( monsters ) ; } return names . tostring ( ) ; }
tr	5	public static void sprstp ( int [ ] sa , int [ ] ija , double [ ] sb , int [ ] ijb ) throws nrexception { int j , jl , jm , jp , ju , k , m , n2 , noff , inc , iv ; double v ; n2 = ija [ 0 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) sb [ j ] = sa [ j ] ; int [ ] ija_vec = nfill ( ija [ n2 ] , ija [ n2 - 1 ] - ija [ 0 ] ) ; int [ ] ijb_vec = new int [ ija [ n2 - 1 ] - ija [ 0 ] ] ; indexx ( ija_vec , ijb_vec ) ; for ( j = n2 , k = 0 ; j < ija [ n2 - 1 ] ; j ++ , k ++ ) { ijb [ j ] = ijb_vec [ k ] ; } jp = 0 ; for ( k = ija [ 0 ] ; k < ija [ n2 - 1 ] ; k ++ ) { m = ijb [ k ] + n2 ; sb [ k ] = sa [ m ] ; for ( j = jp ; j < ija [ m ] + 1 ; j ++ ) ijb [ j ] = k ; jp = ija [ m ] + 1 ; jl = 0 ; ju = n2 - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) / 2 ; if ( ija [ jm ] > m ) ju = jm ; else jl = jm ; } ijb [ k ] = jl ; } for ( j = jp ; j < n2 ; j ++ ) ijb [ j ] = ija [ n2 - 1 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) { jl = ijb [ j + 1 ] - ijb [ j ] ; noff = ijb [ j ] ; inc = 1 ; do { inc *= 3 ; inc ++ ; } while ( inc <= jl ) ; do { inc /= 3 ; for ( k = noff + inc ; k < noff + jl ; k ++ ) { iv = ijb [ k ] ; v = sb [ k ] ; m = k ; while ( ijb [ m - inc ] > iv ) { ijb [ m ] = ijb [ m - inc ] ; sb [ m ] = sb [ m - inc ] ; m -= inc ; if ( m - noff + 1 <= inc ) break ; } ijb [ m ] = iv ; sb [ m ] = v ; } } while ( inc > 1 ) ; } }
tr	3	public void execute ( ) { session session = null ; string _commandstring ; string _output ; int _countcommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "started processing unix commands on server :" ) ; this . result . append ( this . hostname ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countcommands = this . commands . size ( ) ; while ( _countcommands > _index ) { _commandstring = this . commands . get ( _index ) ; this . result . append ( "executing :" ) ; this . result . append ( _commandstring ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectserver . opensession ( ) ; _output = executecommand ( session , _commandstring ) ; this . result . append ( _output ) ; } catch ( ioexception e ) { atomshellexception _shellexception = new atomshellexception ( e ) ; _shellexception . setcustommessage ( "unable to open a session on server ip :" + this . hostname ) ; } catch ( atomshellexception e ) { this . result . append ( e . getcustommessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectserver . close ( ) ; }
tr	2	public void backpropagate ( double [ ] target , double learningspeed ) { double [ ] oerror = calculateerror ( getoutput ( ) , target , learningspeed ) ; for ( double n : oerror ) if ( double . isnan ( n ) ) throw new runtimeexception ( "calculateerror resulted in nan" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] ierror = backpropagatelayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oerror , learningspeed ) ; updatebias ( weights . get ( l ) , oerror ) ; oerror = ierror ; } }
tr	2	public static final void initialize ( ) { slowslaves = new slavethread [ nb_slowslaves ] ; fastslaves = new slavethread [ nb_fastslaves ] ; for ( int i = 0 ; i < nb_slowslaves ; i ++ ) { slowslaves [ i ] = new slavethread ( ) ; slowslaves [ i ] . start ( ) ; } for ( int i = 0 ; i < nb_fastslaves ; i ++ ) { fastslaves [ i ] = new slavethread ( ) ; fastslaves [ i ] . start ( ) ; } indexslow = 0 ; indexfast = 0 ; }
tr	5	public static string readseatnumbers ( ) { boolean tryagain ; do { tryagain = false ; str = scan . nextline ( ) ; for ( string s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryagain = true ; } else if ( s . charat ( 0 ) < a && s . charat ( 0 ) > z ) { tryagain = true ; } else { try { integer . parseint ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( numberformatexception exception ) { tryagain = true ; } } if ( tryagain ) { system . out . print ( "seats no input is invalid! try again: " ) ; break ; } } } while ( tryagain ) ; return str ; }
tr	2	public static void main ( string [ ] args ) { int [ ] array = new int [ ] { 1 , 3 , 5 , 7 , 9 , 11 } ; segmenttree tree = new segmenttree ( array ) ; system . out . println ( tree . sumrange ( 1 , 4 ) ) ; system . out . println ( tree . sumrange ( 1 , 1 ) ) ; system . out . println ( tree . sumrange ( 0 , 5 ) ) ; system . out . println ( tree . sumrange ( 0 , 0 ) ) ; }
tr	5	public list < commitdiff > getdifftreefromfirstcommit ( string fileid , string commitid ) { try { list < commitdiff > commitlist = new arraylist < commitdiff > ( ) ; string sql = "select file_id  new_commit_id  old_commit_id  diff_text  char_start  char_end  diff_type from commits natural join file_diffs where " + "file_id=? and " + "(branch_id=? or branch_id is null) and commit_date<= " + "(select commit_date from commits where commit_id=? and " + "(branch_id=? or branch_id is null) limit 1) and new_commit_id= commit_id order by old_commit_id  new_commit_id" ; isetter [ ] parms = { new stringsetter ( 1 , fileid ) , new stringsetter ( 2 , this . branchid ) , new stringsetter ( 3 , commitid ) , new stringsetter ( 4 , this . branchid ) } ; preparedstatementexecutionitem ei = new preparedstatementexecutionitem ( sql , parms ) ; addexecutionitem ( ei ) ; ei . waituntilexecuted ( ) ; resultset rs = ei . getresult ( ) ; if ( ! rs . next ( ) ) return commitlist ; string currentnewcommitid = rs . getstring ( "new_commit_id" ) ; string currentoldcommitid = rs . getstring ( "old_commit_id" ) ; string currentfileid = rs . getstring ( "file_id" ) ; string currentdifftxt = rs . getstring ( "diff_text" ) ; string currentdifftype = rs . getstring ( "diff_type" ) ; int currentcharstart = rs . getint ( "char_start" ) ; int currentcharend = rs . getint ( "char_end" ) ; list < filediff > currentfiledifflist = new arraylist < filediff > ( ) ; commitdiff currentcommitdiff = new commitdiff ( currentnewcommitid , currentoldcommitid , currentfiledifflist ) ; diffentry de = new diffentry ( currentfileid , currentnewcommitid , currentoldcommitid , currentdifftxt , currentcharstart , currentcharend , currentdifftype ) ; filediff currentfilediff = new filediff ( currentfileid , new arraylist < diffentry > ( ) ) ; currentfilediff . adddiffentry ( de ) ; while ( rs . next ( ) ) { string newcommitid = rs . getstring ( "new_commit_id" ) ; string oldcommitid = rs . getstring ( "old_commit_id" ) ; string fileid = rs . getstring ( "file_id" ) ; string difftxt = rs . getstring ( "diff_text" ) ; string difftype = rs . getstring ( "diff_type" ) ; int charstart = rs . getint ( "char_start" ) ; int charend = rs . getint ( "char_end" ) ; if ( newcommitid . equals ( currentnewcommitid ) && oldcommitid . equals ( currentoldcommitid ) ) { if ( fileid . equals ( currentfileid ) ) { currentfilediff . adddiffentry ( new diffentry ( fileid , newcommitid , oldcommitid , difftxt , charstart , charend , difftype ) ) ; } else { currentcommitdiff . addfilediff ( currentfilediff ) ; currentfilediff = new filediff ( fileid , new arraylist < diffentry > ( ) ) ; currentfileid = fileid ; } } else { currentcommitdiff . addfilediff ( currentfilediff ) ; commitlist . add ( currentcommitdiff ) ; currentcommitdiff = new commitdiff ( newcommitid , oldcommitid , new arraylist < filediff > ( ) ) ; currentnewcommitid = newcommitid ; currentoldcommitid = oldcommitid ; currentfilediff = new filediff ( fileid , new arraylist < diffentry > ( ) ) ; currentfileid = fileid ; currentfilediff . adddiffentry ( new diffentry ( fileid , newcommitid , oldcommitid , difftxt , charstart , charend , difftype ) ) ; } } currentcommitdiff . addfilediff ( currentfilediff ) ; commitlist . add ( currentcommitdiff ) ; return commitlist ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; return null ; } }
tr	3	private void style2rule ( lexer lexer , node node ) { attval styleattr , classattr ; string classname ; styleattr = node . getattrbyname ( "style" ) ; if ( styleattr != null ) { classname = findstyle ( lexer , node . element , styleattr . value ) ; classattr = node . getattrbyname ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; node . removeattribute ( styleattr ) ; } else { styleattr . attribute = "class" ; styleattr . value = classname ; } } }
tr	4	public inputfield ( ) { super ( ) ; settext ( "type here!" ) ; setcolumns ( 10 ) ; addmouselistener ( new mouselistener ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( gettext ( ) . equals ( "type here!" ) ) settext ( "" ) ; requestfocusinwindow ( ) ; } @ override public void mousepressed ( mouseevent e ) { } @ override public void mousereleased ( mouseevent e ) { } @ override public void mouseentered ( mouseevent e ) { } @ override public void mouseexited ( mouseevent e ) { } } ) ; addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == 10 ) { sendmessage ( ) ; settext ( "" ) ; } } @ override public void keyreleased ( keyevent e ) { } } ) ; }
tr	1	@ test public void testisverbending ( ) { dataholder mydataholder = dataholderfactory ( ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "bearing unknown" . split ( " " ) ) ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "doubling unknown" . split ( " " ) ) ) ; assertequals ( "isverbending - case 1 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "doubles" ) ) ; assertequals ( "isverbending - case 1 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "achenes" ) ) ; assertequals ( "isverbending - case 2 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "bears" ) ) ; assertequals ( "isverbending - case 2 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "armenia" ) ) ; }
tr	2	private void initializeclusterfactors ( bayesnet net , final list < list < integer >> clusters , int [ ] homeclusters ) { nodepotentials = new abstractfactor [ clusters . size ( ) ] ; map < integer , list < abstractfactor >> multiplicationpartners = findmultiplicationpartners ( net , homeclusters ) ; for ( final listiterator < list < integer >> cliqueit = clusters . listiterator ( ) ; cliqueit . hasnext ( ) ; ) { final list < integer > cluster = cliqueit . next ( ) ; int current = cliqueit . nextindex ( ) - 1 ; list < abstractfactor > multiplicationpartnerlist = multiplicationpartners . get ( current ) ; final abstractfactor cliquefactor = factory . create ( cluster , multiplicationpartnerlist == null ? collections . < abstractfactor > emptylist ( ) : multiplicationpartnerlist ) ; nodepotentials [ current ] = cliquefactor ; } }
tr	4	public static void main ( string [ ] args ) { selectionsort ss = new selectionsort ( 10 ) ; system . out . println ( ss . tostring ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; system . out . println ( ss . tostring ( ) ) ; }
va	5	private void openaddmeterpanel ( ) { boolean failure = false ; string options [ ] = { "create" , "cancel" } ; int result = joptionpane . showoptiondialog ( null , addmeterpanel , "add meter to account " + getselectedaccountid ( ) , joptionpane . default_option , joptionpane . plain_message , null , options , options [ 0 ] ) ; if ( result == 0 ) { meter m = getmeterfromaddmeterpanel ( ) ; account temp = getselectedaccount ( ) ; if ( m != null ) { if ( temp instanceof residentialaccount ) { residentialaccount resacc = ( residentialaccount ) temp ; if ( resacc . getmeter ( ) != null ) { boolean overwrite = confirmresidentialaccountconflict ( ) ; if ( ! overwrite ) return ; } } else if ( temp . hasmeter ( m . getmeterid ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addmeter ( m ) ; system . out . println ( m . getmeterid ( ) ) ; showmetersinmetertable ( temp ) ; } else { failtocreatemeterdialog ( ) ; } } }
va	2	@ test public void shouldrighttrimunicodestringscorrectly ( ) throws unsupportedencodingexception { assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac\t\r\n" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" + buffertools . bytebuffertostring ( new byte [ ] { 0 , 0 } , 0 , 2 ) ) ) ; }
va	2	public object [ ] [ ] getestacionescercanas ( int ci ) throws elementonoencontradoexception { object [ ] [ ] datos = new object [ objea . getestacionescercanas ( objua . getusuario ( ci ) ) . size ( ) ] [ 2 ] ; int cont = 0 ; for ( estacion obje : objea . getestacionescercanas ( objua . getusuario ( ci ) ) . values ( ) ) { datos [ cont ] [ 0 ] = obje . getnom ( ) ; datos [ cont ] [ 1 ] = obje . getcp ( ) ; cont ++ ; } return datos ; }
va	5	public boolean isvalidsudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = character . getnumericvalue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = character . getnumericvalue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = arrays . copyof ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = character . getnumericvalue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
va	2	@ test @ ignore public void havedinner ( ) throws exception { int eattimes = 3 ; int numphilosophers = 5 ; countdownlatch waittillallinitialized = new countdownlatch ( numphilosophers ) ; countdownlatch waittillalldonedining = new countdownlatch ( numphilosophers ) ; atomicinteger availableforks = new atomicinteger ( numphilosophers ) ; list < diningphilosopher > philosophers = new arraylist < > ( ) ; for ( int i = 1 ; i <= numphilosophers ; i ++ ) { diningphilosopher philosopher = new diningphilosopher ( i , availableforks , eattimes , waittillalldonedining ) ; philosophers . add ( philosopher ) ; } immutablelist < diningphilosopher > allphilosophers = new immutablelist < > ( philosophers ) ; philosophers . foreach ( ( diningphilosopher philosopher ) -> { philosopher . start ( allphilosophers , registry . getdefault ( ) ) ; } ) ; waittillalldonedining . await ( ) ; system . out . println ( "all philosophers done each dining " + eattimes + " times" ) ; }
va	2	@ test public void testnaissancesoldats ( ) { sallesoldat testsoldat = new sallesoldat ( ) ; sallenourrice sn = new sallenourrice ( ) ; evenements . getinstance ( ) . setevenementactif ( constantes . even_deplacement ) ; sn . ajouterfourmi ( 3 ) ; testsoldat . naissancesoldats ( 2 , sn ) ; assertequals ( 1 , testsoldat . getnbcourantfourmi ( ) ) ; assertequals ( 1 , sn . getnbcourantfourmi ( ) ) ; try { testsoldat . naissancesoldats ( 2 , sn ) ; fail ( "exceptionnourrices non levee." ) ; } catch ( exceptionnourrices en ) { } try { testsoldat . naissancesoldats ( 0 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 1 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 5 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } }
va	5	public static list < lineitem > transformlineitems ( detail d ) { list < lineitem > items = d . getlineitem ( ) ; list < lineitem > aggritems = new arraylist < lineitem > ( ) ; for ( lineitem l : items ) { boolean duplicate = false ; if ( ! aggritems . isempty ( ) ) { for ( int i = 0 ; i < aggritems . size ( ) ; i ++ ) { lineitem curr = aggritems . get ( i ) ; if ( curr . getitemcode ( ) . equals ( l . getitemcode ( ) ) ) { long quantity = curr . getquantity ( ) . intvalue ( ) ; quantity ++ ; curr . setquantity ( bigdecimal . valueof ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggritems . add ( l ) ; } } return aggritems ; }
va	4	public void equipweapon ( survivor survivor , weapon weapon ) throws cantequipweaponexception { if ( ! this . survivors . contains ( survivor ) ) { throw new cantequipweaponexception ( cantequipweaponexception . notintheteam ( survivor ) ) ; } else if ( ! this . mainbase . getavailableweapons ( ) . contains ( weapon ) ) { throw new cantequipweaponexception ( "weapon must be one of those stored in base to equip" ) ; } else { survivor owner = this . alreadyequipped ( weapon ) ; if ( owner != null ) { throw new cantequipweaponexception ( "weapon is already equipped by " + owner . getname ( ) ) ; } else { weapon oldweapon = survivor . getweapon ( ) ; this . mainbase . getavailableweapons ( ) . remove ( weapon ) ; survivor . setweapon ( weapon ) ; if ( oldweapon != null ) { this . mainbase . getavailableweapons ( ) . add ( oldweapon ) ; } } } }
va	5	public void editfile ( int fileinodenum ) throws permissiondeniedexception , filenotfoundexception { inode fileinode = new inode ( fileinodenum ) ; if ( directory . isreadable ( fileinode ) ) { if ( fileinode . getfiletype ( ) == r ) { file tempfile = null ; string content = fileinode . getfilecontent ( ) ; try { tempfile = new file ( disk . tmpfolder . tostring ( ) + "/" + fileinodenum + ".txt" ) ; if ( tempfile . exists ( ) ) { tempfile . delete ( ) ; tempfile . createnewfile ( ) ; } tempfile . deleteonexit ( ) ; randomaccessfile temprf = new randomaccessfile ( tempfile , "rw" ) ; temprf . writebytes ( content ) ; desktop . getdesktop ( ) . open ( tempfile ) ; temprf . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } else throw new permissiondeniedexception ( ) ; }
va	3	public static void main ( string [ ] args ) { rectangle rec = new rectangle ( new mypoint ( 2 , 4 ) , new mypoint ( 4 , 6 ) , new mypoint ( 2 , 4 ) , new mypoint ( 4 , 8 ) ) ; class recclass = rec . getclass ( ) ; field [ ] recfields = recclass . getdeclaredfields ( ) ; method [ ] recmethods = recclass . getdeclaredmethods ( ) ; system . out . println ( "class fields" ) ; for ( field currfield : recfields ) { system . out . println ( currfield . getname ( ) ) ; } system . out . println ( "class methods" ) ; for ( method method : recmethods ) { system . out . println ( method . getname ( ) ) ; } class recsuperclass = recclass . getsuperclass ( ) ; if ( recsuperclass == null ) { system . out . println ( string . format ( "the class %s dose not have a super class" , recclass . getsimplename ( ) ) ) ; } else { system . out . println ( "the super class name is: " + recsuperclass . getsimplename ( ) ) ; system . out . println ( "look for constructors" ) ; constructor [ ] constructors = recsuperclass . getconstructors ( ) ; for ( constructor constructor : constructors ) { system . out . println ( "ctor name: " + constructor . getname ( ) ) ; } system . out . println ( "the class " + recsuperclass . getsimplename ( ) + "" + "is from package " + recsuperclass . getpackage ( ) ) ; } try { class anotherclass = class . forname ( "il.ac.shenkar.point.mypoint" ) ; constructor [ ] constructors = anotherclass . getconstructors ( ) ; system . out . println ( "constructors for: " + anotherclass . getsimplename ( ) ) ; for ( constructor constructor : constructors ) { system . out . println ( constructor ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }
va	3	private void botoneliminarusuarioactionperformed ( java . awt . event . actionevent evt ) { if ( this . tablaadministracionusuarios . getselectedrow ( ) > - 1 ) { string codigo = ( string ) this . conectortablausuarios . getvalueat ( this . tablaadministracionusuarios . getselectedrow ( ) , 0 ) ; int respuesta = joptionpane . showconfirmdialog ( this . botoneliminarusuario , "\u00bfrealmente desea eliminar \n al usuario " + codigo + "?" , "confirme eliminaci\u00f3n" , joptionpane . yes_no_option , joptionpane . question_message ) ; if ( respuesta == joptionpane . yes_option ) { usuario u = this . modeloapp . obtenerusuarioconcodigo ( codigo ) ; this . modeloapp . eliminarusuario ( u ) ; this . conectortablausuarios . cargarusuarios ( ) ; } } else { joptionpane . showmessagedialog ( this , "debe seleccionar un\nusuario de la tabla" , "usuario no seleccionado" , joptionpane . information_message ) ; } }
va	2	@ override public boolean onrequest ( httprequest request , httpresponse response ) throws exception { string filepath = request . getrequestedfilepath ( ) ; if ( urltomapto != null ) { if ( ! filepath . startswith ( urltomapto ) ) return false ; filepath = filepath . substring ( urltomapto . length ( ) ) ; } file file = new file ( directory , filepath ) ; if ( ! file . isfile ( ) || ! file . canread ( ) || ! file . getabsolutepath ( ) . startswith ( directory . getabsolutepath ( ) ) ) return false ; iofilechannelinputbuffer buffer = new iofilechannelinputbuffer ( new fileinputstream ( file ) . getchannel ( ) ) ; response . setheader ( "content-type" , mimenamemap . getcontenttypefor ( file . getabsolutepath ( ) ) ) ; response . setbodybuffer ( buffer ) ; buffer . free ( ) ; return true ; }
va	3	public static boolean readusers ( decisionlineevent readevent , int playableedges ) { if ( ! isconnected ( ) ) if ( ! connect ( ) ) { system . out . println ( "error  database connection could not be created" ) ; system . exit ( 0 ) ; } try { preparedstatement pstmt = getconnection ( ) . preparestatement ( "select username  userpassword  position from user where eventid=(?) order by position asc" ) ; pstmt . setstring ( 1 , readevent . getuniqueid ( ) ) ; resultset myrs = pstmt . executequery ( ) ; user newuser ; string name , password ; int position ; while ( myrs . next ( ) ) { name = new string ( myrs . getstring ( "username" ) ) ; password = new string ( myrs . getstring ( "userpassword" ) ) ; position = myrs . getint ( "position" ) ; newuser = new user ( name , password , position , playableedges ) ; readevent . getusers ( ) . add ( newuser ) ; } return true ; } catch ( sqlexception e ) { system . out . println ( "error executing sql statement!" ) ; } return false ; }
va	5	public void runscript ( inputstream stream ) throws jstrykerexception , illegalargumentexception { if ( stream == null ) { throw new illegalargumentexception ( "stream cannot be null." ) ; } try { list < string > commands = parse ( stream ) ; for ( string command : commands ) { statement statement = null ; try { statement = connection . createstatement ( ) ; statement . execute ( command . tostring ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( sqlexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } catch ( ioexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
va	3	public void advance ( ) { timeuntilnext -- ; if ( timeuntilnext <= 0 ) { stoppingat ( ) ; if ( ! reverse && nextstation . getnext ( ) == null ) { reverse = true ; timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; return ; } if ( reverse && nextstation . getprev ( ) == null ) { reverse = false ; timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; return ; } if ( reverse ) { timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; } else { timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; } } }
va	4	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
va	5	public questionpanel getquestionpanel ( ) { if ( mediapanel . hasfinished ( ) ) createmedia ( ) ; if ( type . equals ( "plain" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , fontsize ) ; } else if ( type . equals ( "mchoice" ) ) { string [ ] split = answers . split ( ";" ) ; multiplechoicepanel panel = new multiplechoicepanel ( split , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { string [ ] split = answers . split ( ";" ) ; jlabel [ ] labels = new jlabel [ 4 ] ; bufferedimage bufferedimage ; image image ; for ( int i = 0 ; i < labels . length ; i ++ ) { prefheight = math . max ( pref_height , mcfont ) ; try { bufferedimage = imageio . read ( new file ( split [ i ] ) ) ; if ( bufferedimage . getheight ( ) > prefheight ) { image = bufferedimage . getscaledinstance ( bufferedimage . getwidth ( ) * prefheight / bufferedimage . getheight ( ) , prefheight , bufferedimage . scale_smooth ) ; } else { image = bufferedimage ; } } catch ( ioexception e ) { bufferedimage = null ; image = null ; e . printstacktrace ( ) ; system . out . println ( "image path: " + split [ i ] ) ; } labels [ i ] = new jlabel ( new imageicon ( image ) ) ; } multiplechoicepanel panel = new multiplechoicepanel ( labels , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "list" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; string [ ] answerarray = answers . split ( ";" ) ; system . out . println ( "create question list" ) ; questionpanel = new questionpanel ( text , answerarray , fontsize ) ; } else { system . out . println ( "failed to read file" ) ; system . exit ( 0 ) ; } return questionpanel ; }
va	2	public static boolean ononeline ( xy xy , xy xy2 ) { if ( xy2 . getx ( ) == xy . getx ( ) ) { return true ; } if ( xy2 . gety ( ) == xy . gety ( ) ) { return true ; } int dx = math . abs ( xy2 . getx ( ) - xy . getx ( ) ) ; int dy = math . abs ( xy2 . gety ( ) - xy . gety ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
va	5	private id3v2commentframedata extractcommentframedata ( string id , boolean itunes ) { id3v2frameset frameset = framesets . get ( id ) ; if ( frameset != null ) { iterator < id3v2frame > iterator = frameset . getframes ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) iterator . next ( ) ; id3v2commentframedata framedata ; try { framedata = new id3v2commentframedata ( useframeunsynchronisation ( ) , frame . getdata ( ) ) ; if ( itunes && itunes_comment_description . equals ( framedata . getdescription ( ) . tostring ( ) ) ) { return framedata ; } else if ( ! itunes ) { return framedata ; } } catch ( invaliddataexception e ) { } } } return null ; }
va	3	public void plotelements ( view3d view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { darray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { renderable e = ( renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewvert , panelvert ) ; } } }
va	3	private bufferedimage getview ( ) { if ( this . getwidth ( ) > 0 && this . getheight ( ) > 0 ) { int mapsize = ( mapimage_scaled . getheight ( ) ) ; if ( viewport . x + this . getwidth ( ) > mapsize ) { int movexby = viewport . x + this . getwidth ( ) - mapsize ; moveview ( - movexby , 0 ) ; } if ( viewport . y + this . getheight ( ) > mapsize ) { int moveyby = viewport . y + this . getheight ( ) - mapsize ; moveview ( 0 , - moveyby ) ; } int windowheight = this . getheight ( ) ; int windowwidth = this . getwidth ( ) ; if ( this . getheight ( ) > mapimage_scaled . getheight ( ) ) { windowheight = mapimage_scaled . getheight ( ) ; viewport . y = 0 ; } if ( this . getwidth ( ) > mapimage_scaled . getwidth ( ) ) { windowwidth = mapimage_scaled . getwidth ( ) ; viewport . x = 0 ; } mapimage_view = null ; try { mapimage_view = mapimage_unitandbuildingsscaled . getsubimage ( viewport . x , viewport . y , windowwidth , windowheight ) ; } catch ( exception e ) { system . err . println ( "error creating subview!" ) ; } } return mapimage_view ; }
va	1	public void drawpoint ( vertex vertex ) { init ( ) ; double x = vertex . getpoint ( ) . getx ( ) * scale_x ; double y = vertex . getpoint ( ) . gety ( ) * scale_y ; ellipse2d el = new ellipse2d . double ( x - pointsize / 2. , y - pointsize / 2. , pointsize , pointsize ) ; ensurehassize ( el . getbounds2d ( ) ) ; graphics2d g = getgraphicsobject ( ) ; g . setstroke ( new basicstroke ( ( float ) pensize ) ) ; g . setcolor ( pencolor ) ; g . setcolor ( pointfill ) ; g . fill ( el ) ; g . setcolor ( pointborder ) ; g . draw ( el ) ; if ( showvertexnumbers ) g . drawstring ( "" + vertex . getvertexindex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
va	3	public static byte [ ] decodeencfs ( byte [ ] source ) { byte [ ] decodedinput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayindex = source [ i ] ; if ( arrayindex >= 0 ) { decodedinput [ i ] = _encfs_decodabet [ source [ i ] ] ; } else { decodedinput [ i ] = - 9 ; } } int outputlen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputlen ] ; int srcidx = 0 ; int dstidx = 0 ; int workbits = 0 ; long work = 0 ; while ( srcidx < source . length ) { work |= decodedinput [ srcidx ++ ] << workbits ; workbits += 6 ; while ( workbits >= 8 ) { output [ dstidx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workbits -= 8 ; } } return output ; }
va	1	@ suppresswarnings ( "deprecation" ) public void initglobaladmin ( ) { person person = new person ( ) ; person . setfirstname ( "thomas" ) ; person . setlastname ( "hardy" ) ; person . setgender ( true ) ; person . setphone ( "857-245-1872" ) ; person . setssn ( "781-27-2837" ) ; person . setemailid ( "global@cms.org" ) ; person . setaddress ( "500 bolyston st  boston" ) ; person . setdob ( new date ( 1980 , 11 , 10 ) ) ; persondao . saveorupdate ( person ) ; useraccount ua = new useraccount ( ) ; ua . setusername ( "admin" ) ; ua . setpassword ( hashgenerator . gethashvalue ( "admin" ) ) ; ua . setrole ( role . globaladmin . tostring ( ) ) ; ua . setperson ( person ) ; useraccountdao . saveorupdate ( ua ) ; }
va	4	private defaulttreemodel getgroups ( ) { defaultmutabletreenode root = new defaultmutabletreenode ( constants . str_group ) ; string userno = string . valueof ( user . get ( constants . user_no ) ) ; list < map < string , object >> grouplist = userdao . getgroup ( userno ) ; for ( int i = 0 , len = grouplist . size ( ) ; i < len ; ++ i ) { map < string , object > group = grouplist . get ( i ) ; defaultmutabletreenode child = new defaultmutabletreenode ( string . valueof ( group . get ( constants . group_name ) ) ) ; map < string , object > param = new hashmap < string , object > ( ) ; param . put ( constants . user_no , string . valueof ( group . get ( constants . user_no ) ) ) ; param . put ( constants . group_no , string . valueof ( group . get ( constants . group_no ) ) ) ; list < map < string , object >> friendlist = userdao . getfriend ( param ) ; if ( constants . num_zero != friendlist . size ( ) ) { for ( int j = 0 , size = friendlist . size ( ) ; j < size ; ++ j ) { map < string , object > friend = friendlist . get ( j ) ; string friendno = string . valueof ( friend . get ( constants . friend_no ) ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( userdao . getuserinfo ( friendno ) ) ; sb . append ( "(" ) ; sb . append ( friendno ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userdao . getstatus ( friendno ) ; sb . append ( userstatus . getitemat ( status ) . tostring ( ) ) ; sb . append ( ">" ) ; defaultmutabletreenode childschild = new defaultmutabletreenode ( sb . tostring ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new defaulttreemodel ( root ) ; }
va	3	public void modifycourse ( classinfo classinfo ) { classinfo cinfodata = getcourse ( classinfo . getclassnumber ( ) ) ; if ( cinfodata != null ) { if ( ! classinfo . getcoursename ( ) . equalsignorecase ( cinfodata . getcoursename ( ) ) ) { course crs = new course ( ) ; crs . setcourseid ( classinfo . getcoursenumber ( ) ) ; crs . setcoursename ( classinfo . getcoursename ( ) ) ; savedatamodify ( crs ) ; } if ( ! classinfo . getcoursesection ( ) . equalsignorecase ( cinfodata . getcoursesection ( ) ) ) { schoolclass cls = new schoolclass ( ) ; cls . setclassnumber ( classinfo . getclassnumber ( ) ) ; cls . setclasssection ( classinfo . getcoursesection ( ) ) ; savedatamodify ( cls ) ; } } }
va	1	@ test public void getvirusscore_virusfinderandscorercalledcorrectlyandscorereturned ( ) { string sequence = "abbaacdeeefa" ; map < string , integer > result = new hashmap < string , integer > ( ) ; result . put ( "abc" , 10 ) ; argumentcaptor < string > sequencecapture = argumentcaptor . forclass ( string . class ) ; mockito . when ( genomevirusfinder . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ) . thenreturn ( result ) ; mockito . when ( genomevirusscorer . gettotalscore ( result ) ) . thenreturn ( 10 ) ; inorder inorder = mockito . inorder ( genomevirusfinder , genomevirusscorer ) ; int score = sequencer . getvirusscore ( sequence ) ; assert . assertequals ( 10 , score ) ; assert . assertequals ( sequence , sequencecapture . getallvalues ( ) . get ( 0 ) ) ; inorder . verify ( genomevirusfinder , mockito . times ( 1 ) ) . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ; inorder . verify ( genomevirusscorer , mockito . times ( 1 ) ) . gettotalscore ( result ) ; }
va	5	private void execute ( ) { boolean running = true ; watchkey key ; string dir = readproperties ( ) ; inboundwatcher watch = new inboundwatcher ( dir ) ; system . out . println ( "starting the directory monitoring" ) ; system . out . println ( "directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( interruptedexception ie ) { return ; } for ( watchevent < ? > event : key . pollevents ( ) ) { watchevent . kind < ? > kind = event . kind ( ) ; if ( kind == standardwatcheventkinds . entry_create ) { watchevent < path > watcheventpath = ( watchevent < path > ) event ; path entry = watcheventpath . context ( ) ; if ( pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . tostring ( ) ) ) { salesorder . unmarshal ( dir , entry . tostring ( ) ) ; } else if ( pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . tostring ( ) ) ) { standardresponse . unmarshal ( dir , entry . tostring ( ) ) ; } else if ( pattern . matches ( ".+[\\.trg]" , entry . tostring ( ) ) ) { file f = entry . tofile ( ) ; shipadvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isvalid ( ) ) { running = false ; } } }
va	5	static private vector < double [ ] > sampleresults ( vector < future < vector < double [ ] >>> results , int bins ) throws exception { int ndescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; system . out . println ( "printing for " + ndescriptors + " descriptors" ) ; vector < double [ ] > descriptors = new vector < double [ ] > ( ndescriptors ) ; for ( int d = 0 ; d < ndescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( future < vector < double [ ] >> result : results ) { vector < double [ ] > samples = result . get ( ) ; int samplesperbin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesperbin && b * samplesperbin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesperbin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
va	5	public arraylist < integer > obtenerjugadasganadorasdehoy ( arraylist < integer > boletosdehoy , arraylist < integer > numerosganadores , int loteria_id ) { verificadora verificadora = new verificadora ( ) ; connection cn = conexion . conectar ( ) ; preparedstatement pst ; resultset rs ; string query ; arraylist < integer > jugadasdehoy = new arraylist < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosganadores . get ( 0 ) ; numerog2 = numerosganadores . get ( 1 ) ; numerog3 = numerosganadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosdehoy . size ( ) ; i ++ ) { query = "select jugada_id  combinacion  monto  formato_id from jugadas where boleto_id = " + boletosdehoy . get ( i ) + " and loteria_id =" + loteria_id ; try { pst = cn . preparestatement ( query ) ; rs = pst . executequery ( ) ; while ( rs . next ( ) ) { string comb = separarcombinacion ( rs . getstring ( "combinacion" ) ) . get ( 0 ) ; string [ ] combinacion = rs . getstring ( "combinacion" ) . split ( "-" ) ; int formato = rs . getint ( "formato_id" ) ; int jugada_id = rs . getint ( "jugada_id" ) ; numerosganadores . clear ( ) ; numerosganadores . add ( numerog1 ) ; numerosganadores . add ( numerog2 ) ; numerosganadores . add ( numerog3 ) ; coincidencias = verificadora . verificarcoincidencias ( separarcombinacion ( rs . getstring ( "combinacion" ) ) , numerosganadores ) ; system . out . println ( "jugada: " + jugada_id ) ; system . out . println ( "coinc: " + coincidencias ) ; system . out . println ( "formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasdehoy . add ( jugada_id ) ; calcularquiniela ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; system . out . println ( "quiniela gan\u00f3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasdehoy . add ( jugada_id ) ; calcularpale ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , integer . parseint ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasdehoy . add ( jugada_id ) ; calculartripleta ( jugada_id , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } } } catch ( sqlexception ex ) { system . out . println ( ex ) ; } } return jugadasdehoy ; }
va	1	private jlabel newjlabel ( string value , string src ) { jlabel label = new jlabel ( value ) ; label . seticon ( new imageicon ( src ) ) ; label . setfont ( new font ( "lucida grande" , 0 , 14 ) ) ; label . setpreferredsize ( new dimension ( 40 , 90 ) ) ; label . sethorizontaltextposition ( swingconstants . center ) ; label . setverticaltextposition ( swingconstants . bottom ) ; label . setverticalalignment ( swingconstants . bottom ) ; label . setborder ( borderfactory . createemptyborder ( 0 , 0 , 0 , 5 ) ) ; return label ; }
va	2	public void loaddata ( dadeshotel hotel ) { titledborder leftborder = borderfactory . createtitledborder ( hotel . nom ) ; leftborder . settitlejustification ( titledborder . left ) ; this . setborder ( leftborder ) ; nomhotel = hotel . nom ; hoteldescriptionlabel . settext ( hotel . desc ) ; defaultlistmodel model = new defaultlistmodel ( ) ; for ( dadeshabitacio hab : hotel . habs ) { string dada = hab . tipushab + " (" + hab . preu + "\u20ac) - " + hab . numerodisp + " disponibles" ; model . addelement ( dada ) ; nomstipus . add ( hab . tipushab ) ; } tipushabitacionslist . setmodel ( model ) ; }
va	2	private void handlenames ( message m ) { if ( m . numargs ( ) < 3 ) return ; if ( m . getcode ( ) == messagecode . rpl_endofnames ) { getchannel ( m . getarg ( 2 ) ) . userschanged ( ) ; return ; } if ( m . numargs ( ) < 5 || m . get ( 3 ) . charat ( 0 ) == * ) return ; channel c = getchannel ( m . getarg ( 3 ) ) ; stringtokenizer st = new stringtokenizer ( m . getmessage ( ) , " " ) ; user u ; string nick ; while ( st . hasmoretokens ( ) ) { nick = st . nexttoken ( ) ; channeluser . mode mode = channeluser . mode . getmode ( nick . charat ( 0 ) ) ; if ( mode != channeluser . mode . none ) nick = nick . substring ( 1 ) ; u = getuser ( nick ) ; u . addchannel ( c ) ; c . addusertolist ( u ) ; c . setusermode ( u , mode ) ; } }
va	1	protected void mapkeyboard ( ) { mapkeystroke ( keyevent . vk_up ) ; mapkeystroke ( keyevent . vk_down ) ; mapkeystroke ( keyevent . vk_right ) ; mapkeystroke ( keyevent . vk_left ) ; mapkeystroke ( keyevent . vk_page_down ) ; mapkeystroke ( keyevent . vk_page_up ) ; mapkeystroke ( keyevent . vk_home ) ; mapkeystroke ( keyevent . vk_end ) ; mapkeystroke ( keyevent . vk_numpad0 ) ; mapkeystroke ( keyevent . vk_numpad1 ) ; mapkeystroke ( keyevent . vk_numpad2 ) ; mapkeystroke ( keyevent . vk_numpad3 ) ; mapkeystroke ( keyevent . vk_numpad4 ) ; mapkeystroke ( keyevent . vk_numpad5 ) ; mapkeystroke ( keyevent . vk_numpad6 ) ; mapkeystroke ( keyevent . vk_numpad7 ) ; mapkeystroke ( keyevent . vk_numpad8 ) ; mapkeystroke ( keyevent . vk_numpad9 ) ; mapkeystroke ( keyevent . vk_minus ) ; mapkeystroke ( keyevent . vk_plus ) ; mapkeystroke ( keyevent . vk_comma ) ; mapkeystroke ( keyevent . vk_period ) ; mapkeystroke ( keyevent . vk_enter ) ; mapkeystroke ( keyevent . vk_kp_down ) ; mapkeystroke ( keyevent . vk_kp_left ) ; mapkeystroke ( keyevent . vk_kp_right ) ; mapkeystroke ( keyevent . vk_kp_up ) ; mapkeystroke ( keyevent . vk_f1 ) ; mapkeystroke ( keyevent . vk_f1 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f2 ) ; mapkeystroke ( keyevent . vk_f2 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f3 ) ; mapkeystroke ( keyevent . vk_f3 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f4 ) ; mapkeystroke ( keyevent . vk_f4 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f5 ) ; mapkeystroke ( keyevent . vk_f6 ) ; mapkeystroke ( keyevent . vk_f7 ) ; mapkeystroke ( keyevent . vk_f8 ) ; mapkeystroke ( keyevent . vk_f9 ) ; mapkeystroke ( keyevent . vk_f10 ) ; mapkeystroke ( keyevent . vk_f11 ) ; mapkeystroke ( keyevent . vk_f12 ) ; }
va	2	public string format ( string unformattedxml ) { transformerfactory tfactory = transformerfactory . newinstance ( ) ; transformer serializer ; try { serializer = tfactory . newtransformer ( ) ; serializer . setoutputproperty ( outputkeys . encoding , "utf-8" ) ; serializer . setoutputproperty ( outputkeys . indent , "yes" ) ; serializer . setoutputproperty ( "{http://xml.apache.org/xslt}indent-amount" , "4" ) ; element node = parsexmlfile ( unformattedxml ) ; stringwriter out = new stringwriter ( ) ; serializer . transform ( new domsource ( node ) , new streamresult ( out ) ) ; return out . tostring ( ) ; } catch ( transformerexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( e ) ; } }
va	4	public list < payloadsubjectexceptiondata > getexceptions ( ) throws exception { if ( this . exceptions == null ) { this . exceptions = new arraylist < payloadsubjectexceptiondata > ( ) ; nodelist exceptions = utilities . selectnodes ( this . getdocument ( ) , "/dc:dctransaction/dc:getdatabysubjectrs/dc:payloadsubjectexceptions/dc:payloadsubjectexception" , xmllabels . standard_namespaces ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getlength ( ) ; ++ i ) { node exception = exceptions . item ( i ) ; this . exceptions . add ( new payloadsubjectexceptiondata ( exception ) ) ; } } } return this . exceptions ; }
va	5	public level ( ) { bitmap bmp = art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redplayer = new player ( this , team . allied ) ; bluplayer = new player ( this , team . soviet ) ; }
va	5	public contextmenu getcontextmenu ( final modelverzameling mv ) { if ( contextmenu == null ) { contextmenu = new contextmenu ( ) ; menuitem menuitem1 = new menuitem ( "wat is het" ) ; menuitem1 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { mv . gettekstvakmodel ( ) . settext ( "dit is een " + getname ( ) ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem1 ) ; if ( iseetbaar ( ) ) { menuitem menuitem2 = new menuitem ( "eet" ) ; menuitem2 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { eet ( mv ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem2 ) ; } } return contextmenu ; }
va	4	private void parsepacket ( ) throws mpegdecodeexception , ioexception { statistics . startlog ( parse_packet_string ) ; system . out . println ( "parsing packet" ) ; if ( m_iotool . getbits ( 24 ) != 1 ) { debug . println ( debug . error , "synchronization error in packet" ) ; throw new mpegdecodeexception ( "synchronization error in packet" ) ; } int streamid = m_iotool . getbits ( 8 ) ; int pktlength = m_iotool . getbits ( 16 ) ; if ( streamid != private_stream2 ) { pktlength -= parsetimestamps ( ) ; } if ( ( streamid & e0 ) == c0 ) { decodeaudio ( pktlength ) ; } else { if ( ( f0 & streamid ) == e0 ) { decodevideo ( pktlength ) ; } else if ( ( f0 & streamid ) == f0 ) { ; } else { switch ( streamid ) { case reserved_stream : case private_stream1 : case padding_stream : case private_stream2 : break ; default : debug . println ( debug . error , "unknown stream: " + streamid ) ; throw new mpegdecodeexception ( "unknown stream: " + streamid ) ; } } } statistics . endlog ( parse_packet_string ) ; }
va	4	public static strooptest createrandomcolourtest ( int wordsize , testtype type ) { list < word > words = new arraylist < word > ( wordsize ) ; random randomizer = new random ( system . currenttimemillis ( ) ) ; for ( int i = 0 ; i < wordsize ; i ++ ) { int next = randomizer . nextint ( 2 ) ; switch ( next ) { case 0 : { words . add ( wordfactory . createrandomplaincolourword ( ) ) ; break ; } case 1 : { words . add ( wordfactory . createrandomcolourword ( ) ) ; break ; } case 2 : { words . add ( wordfactory . createrandommixedcolourword ( ) ) ; break ; } } } return new strooptest ( words , type , "random" , "" ) ; }
va	5	private boolean applydistributivelaw ( iexpressioncontext context , astnode result ) { final treematcher matcher = new treematcher ( ) . ignorechildorder ( true ) . requirenodetohaveparent ( true ) . unwrapall ( ) . matchparent ( ) . matchand ( ) . matchor ( ) . buildor ( ) . matchrightchild ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { final astnode unwrapped = unwrap ( matcher . parentmatch ( ) ) ; if ( unwrapped . isor ( ) ) { return n . isand ( ) ; } if ( unwrapped . isand ( ) ) { return n . isor ( ) ; } throw new runtimeexception ( "unreachable code reached" ) ; } } ) . buildor ( ) . matchextra ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { return matcher . leftmatch ( ) . getnodecount ( ) != matcher . rightmatch ( ) . getnodecount ( ) ; } } ) . buildor ( ) ; final mutatingnodevisitor visitor = new mutatingnodevisitor ( context ) { @ override public void visit ( astnode node , iexpressioncontext context , iiterationcontext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final astnode matchedparent = matcher . parentmatch ( ) ; final astnode leftchild = matcher . leftmatch ( ) ; final astnode rightchild = matcher . rightmatch ( ) ; final astnode leftterm ; final astnode rightterm ; final astnode replacementterm ; astnode unwrappedright = unwrap ( rightchild ) ; if ( unwrap ( matchedparent ) . isand ( ) && unwrappedright . isor ( ) ) { leftterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . or ( leftterm , rightterm ) ; } else if ( unwrap ( matchedparent ) . isor ( ) && unwrappedright . isand ( ) ) { leftterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . and ( leftterm , rightterm ) ; } else { throw new runtimeexception ( "unreachable code reached => " + matcher ) ; } astnode toreplace = matchedparent ; if ( ! toreplace . hasparent ( ) ) { if ( unwrap ( toreplace ) != toreplace ) { toreplace = unwrap ( toreplace ) ; } else { throw new runtimeexception ( "unreachable code reached" ) ; } } debugprintln ( "distributive law: replacing " + matchedparent . tostring ( false ) + " -> " + replacementterm ) ; toreplace . replacewith ( replacementterm ) ; it . astmutated ( ) ; } } ; return applyinorder ( result , visitor ) ; }
va	1	public void setstationdata ( string call , string locator , string qrzuser , string qrzpass , double lat , double lon , string hamuser , string hampass ) throws sqlexception { connection con = getdbconnection ( ) ; string query0 = "delete from sation_data" ; con . preparecall ( query0 ) . execute ( ) ; string query = "insert into sation_data (call_id locator longitude latitude qrz_user qrz_pass ham_user ham_pass) values (? ? ? ? ? ? ? ?)" ; java . sql . preparedstatement stm = con . preparestatement ( query ) ; int index = 1 ; stm . setstring ( index ++ , call ) ; stm . setstring ( index ++ , locator ) ; stm . setdouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setdouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setstring ( index ++ , qrzuser ) ; stm . setstring ( index ++ , qrzpass ) ; stm . setstring ( index ++ , hamuser ) ; stm . setstring ( index ++ , hampass ) ; stm . execute ( ) ; }
va	2	public void savegame ( ) throws cannotsaveexception { try { savefile savefile = new savefile ( gamesaver . auto_save_location ) ; fileoutputstream savestream = new fileoutputstream ( savefile . getfile ( ) ) ; objectoutputstream save = new objectoutputstream ( savestream ) ; save . writeobject ( gamestate . getinstance ( ) ) ; save . close ( ) ; } catch ( cannotcreatefileexception e ) { throw new cannotsaveexception ( "cannot create file" ) ; } catch ( filenotfoundexception e ) { throw new cannotsaveexception ( "file not found" ) ; } catch ( ioexception e ) { throw new cannotsaveexception ( "io exception" ) ; } }
va	5	@ override protected void handleinboxitem ( inboxitem inboxitem ) { super . handleinboxitem ( inboxitem ) ; if ( inboxitem . getmessage ( ) instanceof tokenmessage ) { executeturn ( ) ; } if ( inboxitem . getmessage ( ) instanceof leaderelectionmessage ) { leaderelectionmessage message = ( leaderelectionmessage ) inboxitem . getmessage ( ) ; switch ( message . getleaderelectionmessagetype ( ) ) { case ask_for_roll : { doroll ( inboxitem . getsender ( ) ) ; break ; } case leader_elected : { initround ( ) ; ownplayer . setactive ( true ) ; if ( message . getvalue ( ) == ownendpoint . getid ( ) ) { isdealer = true ; logger . info ( "new dealer" ) ; sendtoken ( getpreviousplayer ( ) ) ; } else { logger . info ( "player " + message . getvalue ( ) + " is new dealer." ) ; } break ; } case rolled : { gatherroll ( inboxitem . getsender ( ) , message ) ; break ; } } } if ( inboxitem . getmessage ( ) instanceof statusmessage ) { handlestatusmessage ( ( statusmessage ) inboxitem . getmessage ( ) ) ; } if ( inboxitem . getmessage ( ) instanceof dealermessage ) { handledealermessage ( inboxitem . getsender ( ) , ( dealermessage ) inboxitem . getmessage ( ) ) ; } }
va	4	public void initconvexe ( ) { iterator < classe > iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; next . convexe = new convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { classe classe = vectclasses . elementat ( classes [ i ] ) ; if ( classe . envdessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getk ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectclasses . iterator ( ) ; while ( iter . hasnext ( ) ) { classe next = iter . next ( ) ; if ( next . envdessinee ) { next . convexe . calculbarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
va	2	public enterteams ( maingui gui ) { initcomponents ( ) ; this . gui = gui ; graphicsenvironment g = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice [ ] devices = g . getscreendevices ( ) ; int width = devices [ 0 ] . getdisplaymode ( ) . getwidth ( ) ; int height = devices [ 0 ] . getdisplaymode ( ) . getheight ( ) ; int w = this . getsize ( ) . width ; int h = this . getsize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setlocation ( x , y ) ; numberofmatchesfield . setvalue ( 1 ) ; matchfield . setvalue ( 1 ) ; savematchesbutton . setenabled ( false ) ; teamarray = new jtextfield [ 6 ] ; teamarray [ 0 ] = redallianceteam1 ; teamarray [ 1 ] = redallianceteam2 ; teamarray [ 2 ] = redallianceteam3 ; teamarray [ 3 ] = blueallianceteam1 ; teamarray [ 4 ] = blueallianceteam2 ; teamarray [ 5 ] = blueallianceteam3 ; if ( ! "" . equals ( competition . getcompetitionname ( ) ) || competition . getcompetitionname ( ) != null ) { competitionnamefield . settext ( competition . getcompetitionname ( ) ) ; } if ( competition . getnumberofmatches ( ) != 0 ) { numberofmatchesfield . setvalue ( competition . getnumberofmatches ( ) ) ; } dynamicarray teams = new dynamicarray ( 20 ) ; }
va	2	public boolean savetofile ( string path ) { logger . info ( "write all shares into " + path ) ; if ( path == null || ! path . endswith ( ".ht" ) ) { throw new illegalargumentexception ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { filewriter writer = new filewriter ( path , false ) ; writer . write ( convertsharestostring ( ) ) ; writer . close ( ) ; } catch ( filenotfoundexception e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( ioexception e ) { logger . warning ( "could not write to file '" + path + "' - " + e . getmessage ( ) ) ; return false ; } return true ; }
va	1	@ test public void testopen ( ) throws ioexception , jaxbexception , classnotfoundexception , interruptedexception , exception { crrcsim crrcsim = new crrcsimrepository ( ) . restorefromfile ( new file ( "./sample/aerosonde/aerosonde.crr" ) ) ; new crrcsimrepository ( ) . storetofile ( this . file , crrcsim ) ; crrcsim = new crrcsimrepository ( ) . restorefromfile ( this . file ) ; assertequals ( 0.254 , crrcsim . getavl ( ) . getgeometry ( ) . getsurfaces ( ) . get ( 0 ) . getsections ( ) . get ( 0 ) . getchord ( ) , 0.0001 ) ; }
va	1	public static void main ( string [ ] args ) throws exception { predicate < string > predicate = ( s ) -> s . length ( ) > 0 ; predicate . test ( "foo" ) ; predicate . negate ( ) . test ( "foo" ) ; predicate < boolean > nonnull = objects colcol nonnull ; predicate < boolean > isnull = objects colcol isnull ; predicate < string > isempty = string colcol isempty ; predicate < string > isnotempty = isempty . negate ( ) ; function < string , integer > tointeger = integer colcol valueof ; function < string , string > backtostring = tointeger . andthen ( string colcol valueof ) ; backtostring . apply ( "123" ) ; supplier < person > personsupplier = person colcol new ; personsupplier . get ( ) ; consumer < person > greeter = ( p ) -> system . out . println ( "hello  " + p . firstname ) ; greeter . accept ( new person ( "luke" , "skywalker" ) ) ; comparator < person > comparator = ( p1 , p2 ) -> p1 . firstname . compareto ( p2 . firstname ) ; person p1 = new person ( "john" , "doe" ) ; person p2 = new person ( "alice" , "wonderland" ) ; comparator . compare ( p1 , p2 ) ; comparator . reversed ( ) . compare ( p1 , p2 ) ; runnable runnable = ( ) -> system . out . println ( uuid . randomuuid ( ) ) ; runnable . run ( ) ; callable < uuid > callable = uuid colcol randomuuid ; callable . call ( ) ; }
va	4	public char [ ] mincharcutmulti ( int numoftracks ) { debugger . debug ( "min cut set:***************\n" , 2 , debuglevel ) ; hashset < arraylist < transition >> mincutset = mincutmulti ( numoftracks ) ; stringbuilder b = new stringbuilder ( ) ; for ( arraylist < transition > tracksarray : mincutset ) { transition tracks [ ] = new transition [ numoftracks ] ; for ( int i = 0 ; i < tracksarray . size ( ) ; i ++ ) { tracks [ tracksarray . get ( i ) . track - 1 ] = tracksarray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; transition . appendcharstring ( tracks [ i ] . max , b ) ; } else transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } debugger . debug ( b . tostring ( ) , 0 , debuglevel ) ; return null ; }
va	5	public static method getmostspecificmethod ( method method , class < ? > targetclass ) { if ( method != null && isoverridable ( method , targetclass ) && targetclass != null && ! targetclass . equals ( method . getdeclaringclass ( ) ) ) { try { if ( modifier . ispublic ( method . getmodifiers ( ) ) ) { try { return targetclass . getmethod ( method . getname ( ) , method . getparametertypes ( ) ) ; } catch ( nosuchmethodexception ex ) { return method ; } } else { method specificmethod = reflectionutils . findmethod ( targetclass , method . getname ( ) , method . getparametertypes ( ) ) ; return ( specificmethod != null ? specificmethod : method ) ; } } catch ( securityexception ex ) { } } return method ; }
va	1	private void init ( gridpanel gridpanel ) { this . gridpanel = gridpanel ; container thiss = getcontentpane ( ) ; thiss . setlayout ( new borderlayout ( ) ) ; thiss . setbackground ( charapp . color_bg ) ; jpanel fontpanel = new jpanel ( new gridlayout ( 3 , 1 ) ) ; fontpanel . setbackground ( charapp . color_bg ) ; resize = new jbutton ( "resize" ) ; chinese = new jbutton ( "chinese font" ) ; pinyin = new jbutton ( "pinyin font" ) ; other = new jbutton ( "other font" ) ; display = new jbutton ( "main display" ) ; ok = new jbutton ( "ok" ) ; chineseexample = new jlabel ( chtext , swingconstants . center ) ; chineseexample . setfont ( gridpanel . getchinesefont ( ) ) ; pinyinexample = new jlabel ( pintext , swingconstants . center ) ; pinyinexample . setfont ( gridpanel . getpinyinfont ( ) ) ; otherexample = new jlabel ( entext , swingconstants . center ) ; otherexample . setfont ( gridpanel . getotherfont ( ) ) ; chinese . setbackground ( charapp . color_button ) ; pinyin . setbackground ( charapp . color_button ) ; other . setbackground ( charapp . color_button ) ; display . setbackground ( charapp . color_button ) ; chinese . addactionlistener ( this ) ; pinyin . addactionlistener ( this ) ; other . addactionlistener ( this ) ; resize . addactionlistener ( this ) ; display . addactionlistener ( this ) ; ok . addactionlistener ( this ) ; jpanel temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( chinese ) ; temp . add ( chineseexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( pinyin ) ; temp . add ( pinyinexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( other ) ; temp . add ( otherexample ) ; fontpanel . add ( temp ) ; thiss . add ( fontpanel , borderlayout . center ) ; jpanel buttonpanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; buttonpanel . add ( ok ) ; buttonpanel . add ( resize ) ; ok . setbackground ( charapp . color_button ) ; resize . setbackground ( charapp . color_button ) ; buttonpanel . setbackground ( charapp . color_bg ) ; thiss . add ( buttonpanel , borderlayout . south ) ; this . pack ( ) ; this . setlocation ( ( int ) getowner ( ) . getlocation ( ) . getx ( ) - 100 , ( int ) getowner ( ) . getlocation ( ) . gety ( ) + getowner ( ) . getheight ( ) / 3 ) ; }
va	4	private static void begin ( ) { scanner sc = new scanner ( system . in ) ; int ntestcases = integer . parseint ( sc . nextline ( ) ) ; sc . nextline ( ) ; line decryptedline = new line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < ntestcases ; ++ t ) { list < line > lines = new linkedlist < line > ( ) ; map < character , character > dict = null ; while ( sc . hasnextline ( ) ) { string input = sc . nextline ( ) ; if ( input . isempty ( ) ) { break ; } line line = new line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getdict ( decryptedline ) ; } } if ( dict == null ) { system . out . println ( "no solution." ) ; } else { for ( line l : lines ) { system . out . println ( l . decrypt ( dict ) ) ; } } if ( t < ntestcases - 1 ) { system . out . println ( ) ; } } }
va	5	@ override public void call ( ) throws ioexception { boolean online = true ; while ( online ) { selector . select ( ) ; iterator < selectionkey > it = selector . selectedkeys ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { selectionkey key = it . next ( ) ; it . remove ( ) ; socketchannel channel = ( socketchannel ) key . channel ( ) ; messagehandler handler = handlers . get ( channel ) ; if ( key . isreadable ( ) ) { dataunit message ; try { message = mp . read ( p , channel ) ; handler . handlemessage ( message ) ; } catch ( ioexception e ) { handler . notifydisconnect ( ) ; handlers . remove ( channel ) ; key . cancel ( ) ; } } } } return null ; }
va	1	private void checkcrossings ( final player player , final location from , final location to ) { message entered = null ; final set < region > regions = new hashset < region > ( ) ; regions . addall ( this . catalog . cached ( from . getworld ( ) , from . getblockx ( ) >> 4 , from . getblockz ( ) >> 4 ) ) ; if ( ! boundaryalerter . samechunk ( from , to ) ) regions . addall ( this . catalog . cached ( to . getworld ( ) , to . getblockx ( ) >> 4 , to . getblockz ( ) >> 4 ) ) ; entered = this . checkregions ( player , from , to , regions , entered ) ; if ( entered != null ) main . courier . submit ( new individual ( player ) , entered ) ; }
va	2	private void drawcheckerboard ( graphics2d g ) { color backupcolor = g . getcolor ( ) ; stroke backupstroke = g . getstroke ( ) ; g . setcolor ( color . red ) ; g . setstroke ( new basicstroke ( 1.0f ) ) ; g . drawrect ( 0 , 0 , _canvasbackground . getwidth ( ) - 1 , _canvasbackground . getheight ( ) - 1 ) ; for ( int i = 0 ; i < _imagelist . size ( ) ; i ++ ) { iplnode node = _imagelist . get ( i ) ; g . drawrect ( node . getx ( ) , node . gety ( ) , node . getscalewidth ( ) , node . getscaleheight ( ) ) ; } g . setcolor ( backupcolor ) ; g . setstroke ( backupstroke ) ; }
va	4	private jpanel getcenterpanel ( ) { if ( centerpanel == null ) { centerpanel = new jpanel ( ) ; centerpanel . setlayout ( new miglayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttongameboard [ i ] [ j ] . setsize ( 40 , 40 ) ; centerpanel . add ( buttongameboard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerpanel ; }
va	4	public list < string > generateparenthesis ( int n ) { list < string > result = new arraylist < string > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateparenthesis ( n - 1 ) ; arraylist < string > returnlist = new arraylist < string > ( ) ; int tempsize = result . size ( ) ; for ( int j = 0 ; j < tempsize ; j ++ ) { string tempstr = result . get ( j ) ; stringbuffer sb = new stringbuffer ( tempstr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { string str = sb . insert ( i , "()" ) . tostring ( ) ; sb = new stringbuffer ( tempstr ) ; if ( ! returnlist . contains ( str ) ) { returnlist . add ( str ) ; } } } return returnlist ; }
va	1	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof describecomponentsresult == false ) return false ; describecomponentsresult other = ( describecomponentsresult ) obj ; if ( other . getcomponentinfos ( ) == null ^ this . getcomponentinfos ( ) == null ) return false ; if ( other . getcomponentinfos ( ) != null && other . getcomponentinfos ( ) . equals ( this . getcomponentinfos ( ) ) == false ) return false ; return true ; }
va	4	private void randomplayergroup ( int start , int end ) { game game = new game ( ) ; randomplayer randomplayer = new randomplayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { playerenlist player = players . get ( i ) ; for ( int j = 0 ; j < groupsize - 1 ; j ++ ) { game . startgame ( player . player , randomplayer ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . first_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } game . startgame ( randomplayer , player . player ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . second_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } } } }
va	3	private string internalreadchunkedstring ( int length ) throws ioexception { stringbuffer buf = internalreadstring ( length ) ; boolean done = false ; while ( ! done ) { int code = readnextcode ( ) ; switch ( code ) { case codes . string_packed_length_start + 0 : case codes . string_packed_length_start + 1 : case codes . string_packed_length_start + 2 : case codes . string_packed_length_start + 3 : case codes . string_packed_length_start + 4 : case codes . string_packed_length_start + 5 : case codes . string_packed_length_start + 6 : case codes . string_packed_length_start + 7 : internalreadstringbuffer ( buf , code - codes . string_packed_length_start ) . tostring ( ) ; done = true ; break ; case codes . string : internalreadstringbuffer ( buf , readcount ( ) ) ; done = true ; break ; case codes . string_chunk : internalreadstringbuffer ( buf , readcount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . tostring ( ) ; }
va	2	public dictionaryset ( ) { iscounting = false ; dicts = new dictionary [ dictionarytypes . type_end . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new dictionary ( ) ; int id = dicts [ i ] . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( i == dictionarytypes . pos . ordinal ( ) ) initdict ( dictionarytypes . pos , dicts [ i ] ) ; if ( i == dictionarytypes . word . ordinal ( ) ) initdict ( dictionarytypes . word , dicts [ i ] ) ; } }
va	2	@ test public void testpacketsending ( ) throws socketexception { microsecondstimestamp stamper = mock ( microsecondstimestamp . class ) ; when ( stamper . timestamp ( ) ) . thenreturn ( 0 ) ; utpalgorithm algorithm = new utpalgorithm ( stamper , new inetsocketaddress ( 51235 ) ) ; utpalgconfiguration . send_in_burst = true ; utpalgconfiguration . max_burst_send = 3 ; int packetlength = 1000 ; algorithm . setmaxwindow ( packetlength * 10 ) ; utptimestampedpacketdto pkt5 = createpacket ( 5 , packetlength ) ; utptimestampedpacketdto pkt6 = createpacket ( 6 , packetlength ) ; utptimestampedpacketdto pkt7 = createpacket ( 7 , packetlength ) ; utptimestampedpacketdto pkt8 = createpacket ( 8 , packetlength ) ; utptimestampedpacketdto pkt9 = createpacket ( 9 , packetlength ) ; algorithm . markpacketonfly ( pkt5 . utppacket ( ) , pkt5 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt6 . utppacket ( ) , pkt6 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt7 . utppacket ( ) , pkt7 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt8 . utppacket ( ) , pkt8 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt9 . utppacket ( ) , pkt9 . datagram ( ) ) ; assertequals ( 5 * ( utppacketutils . def_header_length + packetlength ) , algorithm . getcurrentwindow ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; algorithm . setmaxwindow ( packetlength * 4 ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } algorithm . setmaxwindow ( 10 * packetlength ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; }
va	5	protected void notifyreceivedack ( mqttack ack ) throws mqttexception { final string methodname = "notifyreceivedack" ; this . lastinboundactivity = system . currenttimemillis ( ) ; log . fine ( classname , methodname , "627" , new object [ ] { new integer ( ack . getmessageid ( ) ) , ack } ) ; mqtttoken token = tokenstore . gettoken ( ack ) ; mqttexception mex = null ; if ( ack instanceof mqttpubrec ) { mqttpubrel rel = new mqttpubrel ( ( mqttpubrec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof mqttpuback || ack instanceof mqttpubcomp ) { notifyresult ( ack , token , mex ) ; } else if ( ack instanceof mqttpingresp ) { pingoutstanding = false ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; } else if ( ack instanceof mqttconnack ) { int rc = ( ( mqttconnack ) ack ) . getreturncode ( ) ; if ( rc == 0 ) { synchronized ( queuelock ) { if ( cleansession ) { clearstate ( ) ; tokenstore . savetoken ( token , ack ) ; } inflightpubrels = 0 ; actualinflight = 0 ; restoreinflightmessages ( ) ; connected ( ) ; } } else { mex = exceptionhelper . createmqttexception ( rc ) ; throw mex ; } clientcomms . connectcomplete ( ( mqttconnack ) ack , mex ) ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; synchronized ( queuelock ) { queuelock . notifyall ( ) ; } } else { notifyresult ( ack , token , mex ) ; releasemessageid ( ack . getmessageid ( ) ) ; tokenstore . removetoken ( ack ) ; } checkquiescelock ( ) ; }
va	1	private void init ( ) { int n = mapinfo . getmapsize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapinfo . setcell ( row , column , new cell ( true , true , true , true ) ) ; }
va	5	protected void childclosing ( ) { setclosable ( wascloseable ) ; getglasspane ( ) . setvisible ( false ) ; if ( focusowner != null ) { java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { movetofront ( ) ; setselected ( true ) ; focusowner . grabfocus ( ) ; } catch ( propertyvetoexception ex ) { logger . getlogger ( modalityinternalframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; focusowner . grabfocus ( ) ; } getglasspane ( ) . setcursor ( cursor . getpredefinedcursor ( cursor . default_cursor ) ) ; setchildframe ( null ) ; }
va	5	private list < string > generacachekey ( object obj ) { ormtable ormtable = obj . getclass ( ) . getannotation ( ormtable . class ) ; if ( ormtable != null ) { string cachedtablekey = "" . equalsignorecase ( ormtable . cachedshortalias ( ) ) ? ormtable . tablename ( ) : ormtable . cachedshortalias ( ) ; string [ ] cachedkeys = ormtable . cachedkey ( ) ; if ( cachedkeys . length > 0 ) { list < string > ks = new arraylist < string > ( ) ; for ( int i = 0 ; i < cachedkeys . length ; i ++ ) { string cachedcol = cachedkeys [ i ] ; string [ ] fk = cachedcol . split ( "=" ) ; try { field f = obj . getclass ( ) . getdeclaredfield ( fk [ 0 ] ) ; f . setaccessible ( true ) ; ks . add ( cachedtablekey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( nosuchfieldexception e ) { logger . warn ( "nosuchfieldexception:{};" , cachedcol , e ) ; continue ; } catch ( securityexception e ) { logger . warn ( "securityexception:{};" , cachedcol , e ) ; continue ; } catch ( illegalargumentexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } catch ( illegalaccessexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
va	2	public registeredeventmonitor ( method monitormethod , listener listener ) { eventmonitor monitorannotation = monitormethod . getannotation ( eventmonitor . class ) ; if ( monitorannotation == null ) { throw new illegalargumentexception ( "monitor method does not have an eventmonitor annotation." ) ; } class < ? > [ ] monitormethodparameters = monitormethod . getparametertypes ( ) ; if ( monitormethodparameters . length != 2 || ! event . class . isassignablefrom ( monitormethodparameters [ 0 ] ) || ! result . class . isassignablefrom ( monitormethodparameters [ 1 ] ) ) { throw new illegalargumentexception ( "monitor method signature is invalid. cannot accept (event  result)." ) ; } eventtype = ( class < ? extends event > ) monitormethodparameters [ 0 ] ; this . monitormethod = monitormethod ; if ( ! monitormethod . isaccessible ( ) ) { monitormethod . setaccessible ( true ) ; } this . listener = listener ; }
va	5	public simulator ( ) throws interruptedexception { guimanager . simulator = this ; phase = phase . init ; thread simulatorthread = new thread ( new runnable ( ) { @ override public void run ( ) { log . finer ( "maked simulation instance." ) ; setting ( ) ; int periodtime = conf . countperiod ; long start , end , - , sleeptime ; while ( true ) { start = system . currenttimemillis ( ) ; select ( ) ; end = system . currenttimemillis ( ) ; - = end - start ; sleeptime = 1000 / periodtime - - ; try { thread . sleep ( ( sleeptime >= 0 ? sleeptime : 0 ) ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; simulatorthread . start ( ) ; log . finer ( "end of simulation instance." ) ; }
va	1	public static byte [ ] generateauthenticatorserver ( int status , byte [ ] authenticatorclient , string sharekey ) throws nosuchalgorithmexception { byte [ ] keybyte = sharekey . getbytes ( ) ; byte [ ] buf = new byte [ authenticatorclient . length + 4 + keybyte . length ] ; typeconvert . int2byte ( status , buf , 0 ) ; system . arraycopy ( authenticatorclient , 0 , buf , 4 , authenticatorclient . length ) ; system . arraycopy ( keybyte , 0 , buf , 4 + authenticatorclient . length , keybyte . length ) ; return md5 ( buf ) ; }
va	1	protected void adddatabeans ( ) { list < samplebean > beans = new arraylist < samplebean > ( ) ; beans . add ( new samplebean ( new date ( datereference - 2397984 ) , new integer ( 1 ) , "laptop" , new boolean ( false ) , new integer ( 1 ) , new double ( 799.78 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 232042098 ) , new integer ( 2 ) , "mouse" , new boolean ( true ) , new integer ( 2 ) , new double ( 49.30 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 234084277 ) , new integer ( 3 ) , "keyboard" , new boolean ( false ) , new integer ( 5 ) , new double ( 75 ) ) ) ; exporter . addbeanrows ( beans ) ; }
va	3	public void convert ( ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . comment unfuddlecomment : ticket . getcomments ( ) ) { string username = null ; person p = provider . getpeopleconverter ( ) . findpersonbyid ( unfuddlecomment . getauthorid ( ) ) ; if ( null == p ) { system . out . println ( "warning: the comment-author with id '" + unfuddlecomment . getauthorid ( ) + "' could not be found in the input file. using 'null'." ) ; } else { username = p . getname ( ) ; } comment comment = new comment ( unfuddlecomment . getbody ( ) , unfuddlecomment . getcreatedat ( ) . togregoriancalendar ( ) . gettime ( ) , getuniquecommentid ( ) , ticket . getid ( ) , ticket . getupdatedat ( ) . togregoriancalendar ( ) . gettime ( ) , username ) ; comments . add ( comment ) ; } }
va	5	@ override public void doturn ( ) { getlocation ( ) . world . cleartilevisibility ( ) ; for ( int y = getlocation ( ) . y + getviewdistance ( ) ; y >= getlocation ( ) . y - getviewdistance ( ) ; y -- ) { int deltax = getviewdistance ( ) - math . abs ( y - getlocation ( ) . y ) ; for ( int x = getlocation ( ) . x + deltax ; x >= getlocation ( ) . x - deltax ; x -- ) { if ( aicontroller . checkvisibility ( getlocation ( ) , new worldlocation ( null , x , y ) ) ) { getlocation ( ) . world . settilevisible ( x , y , true ) ; } if ( new worldlocation ( getlocation ( ) . world , x , y ) . gettile ( ) instanceof tilesecretdoor ) { int chance = 30 - getstats ( ) . getintelligence ( ) ; if ( chance <= 0 || new random ( ) . nextint ( chance ) == 0 ) { logmessage ( "something about one of the walls nearby seems off to you" ) ; } } } } }
va	4	void deletetime ( component dialogparent , time time ) { if ( time != null ) { if ( alertmessages . deletetimeconfirmation ( dialogparent , time ) ) { try { timedao . deletetime ( dao . getconnection ( ) , time ) ; timedialog . settime ( null ) ; timelistdialog . selectpreviousrow ( ) ; timedialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deletetime()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deletetime()" , ex ) ; } } } else { alertmessages . notimeselectedintablefordeleting ( timelistdialog ) ; } }
va	5	@ override public boolean onresponse ( message message ) { string msg = message . content . tolowercase ( ) ; pattern pattern = pattern . compile ( "^@((qinbot)|(\u4eb2\u59b9\u5b50)) +help(.*)" ) ; matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( "\\\\n\u8f93\u5165@qinbot help \u63d2\u4ef6\u540d\u79f0 \u83b7\u53d6\u5177\u4f53\u5e2e\u52a9\\\\n\u5f53\u524d\u63d2\u4ef6\u5982\u4e0b:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . tostring ( ) ) ; } else { string help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { pluginbase pluginbase = plugins . get ( i ) ; help = string . format ( "\\\\n\u7b80\u4ecb:%s\\\\n\u5e2e\u52a9:%s\\\\n" , pluginbase . descrition , pluginbase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672a\u627e\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
va	4	public regularanalyzer ( list < rule > rules ) { set < string > definedrulenames = new hashset < string > ( ) ; list < rule > observedrules = new arraylist < rule > ( ) ; observedrules . addall ( rules ) ; boolean foundregular ; do { foundregular = false ; for ( int index = observedrules . size ( ) - 1 ; index >= 0 ; index -- ) { set < string > dependent = observedrules . get ( index ) . getelements ( ) . getdependentrulenames ( ) ; if ( definedrulenames . containsall ( dependent ) ) { definedrulenames . add ( observedrules . get ( index ) . getrulename ( ) . tostring ( ) ) ; regularrules . add ( observedrules . get ( index ) ) ; observedrules . remove ( index ) ; foundregular = true ; continue ; } } } while ( foundregular ) ; observedrules . clear ( ) ; }
va	5	@ test public void superthreadsafe ( ) { final simplemath math = new simplemath ( ) ; final map < integer , integer > results = new concurrenthashmap < integer , integer > ( ) ; final countdownlatch latch = new countdownlatch ( 1000 ) ; final countdownlatch alldone = new countdownlatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new thread ( ) { public void run ( ) { try { latch . countdown ( ) ; latch . await ( ) ; int result = math . doubleandincrement ( copy ) ; results . put ( copy , result ) ; alldone . countdown ( ) ; } catch ( exception e ) { } } } . start ( ) ; } try { alldone . await ( ) ; } catch ( exception e ) { } assertequals ( new integer ( 45 ) , results . get ( 22 ) ) ; }
va	4	@ override @ transactional public list getfiltervaluesforreview ( string merchantname , string username , string reviewstatus ) throws exception { list filtervalueslist = new arraylist ( ) ; try { if ( merchantname != null ) { query getmerchant = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.omerchant from merchantreview merchantreview" ) ; filtervalueslist = getmerchant . list ( ) ; system . out . println ( "merchant size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchant merchant = ( merchant ) iterator . next ( ) ; system . out . println ( "merchant-------->" + merchant ) ; } } else if ( username != null ) { query getcashbackuser = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ocashbackuser from merchantreview merchantreview" ) ; filtervalueslist = getcashbackuser . list ( ) ; system . out . println ( "user size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { cashbackuser cashbackuser = ( cashbackuser ) iterator . next ( ) ; system . out . println ( "user-------->" + cashbackuser ) ; } } else { query getreview = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ostatus from merchantreview merchantreview" ) ; filtervalueslist = getreview . list ( ) ; system . out . println ( "review status size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchantreviewstatus merchantreviewstatus = ( merchantreviewstatus ) iterator . next ( ) ; system . out . println ( "reviewstatus-------->" + merchantreviewstatus ) ; } } } catch ( exception exception ) { throw exception ; } return filtervalueslist ; }
va	3	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { printwriter out = response . getwriter ( ) ; request . setcharacterencoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setcontenttype ( "text/html;charset=utf-8" ) ; search com = new search ( ) ; string id [ ] = request . getparametervalues ( "id" ) ; string doctellid [ ] = request . getparametervalues ( "doctellid" ) ; string docid [ ] = request . getparametervalues ( "docid" ) ; string doctellcontent [ ] = request . getparametervalues ( "doctellcontent" ) ; string excutedate [ ] = request . getparametervalues ( "excutedate" ) ; string excuteid [ ] = request . getparametervalues ( "excuteid" ) ; string doctelltype [ ] = request . getparametervalues ( "doctelltype" ) ; string stopdate [ ] = request . getparametervalues ( "stopdate" ) ; string patientid = request . getparameter ( "patientid" ) ; for ( int i = 0 ; i < doctellid . length ; i ++ ) { r = com . doctellfind ( id [ i ] ) ; if ( r ) { e = com . doctellupdate ( id [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] ) ; } else { system . out . println ( doctellid [ i ] ) ; e = com . doctellinsert ( id [ i ] , doctellid [ i ] , docid [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] , patientid ) ; } } if ( e ) { response . sendredirect ( request . getcontextpath ( ) + "/wardmanagement/patientlist.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } }
va	3	@ override public object getvalueat ( int row , int column ) { vehicle vehicle = vehicles . elementat ( row ) ; switch ( column ) { case 0 : return vehicle . getlicenceplate ( ) ; case 1 : return vehicle . getstartdate ( ) ; case 2 : return vehicle . getowner ( ) . getfirstname ( ) + " " + vehicle . getowner ( ) . getfamilyname ( ) . touppercase ( ) ; case 3 : return vehicle . getmodel ( ) . getdesignation ( ) ; case 4 : if ( this . deleteicon == null ) { return "supprimer" ; } return this . deleteicon ; default : break ; } return null ; }
va	3	private void emitloadorstore ( int opcode , int a , adda address ) throws exception { value v = address . getarg1 ( ) ; int b , c ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; v = address . getarg2 ( ) ; if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getarg2 ( ) ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( type . getgbp ( ) ) ) { c = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( dlx . assemble ( opcode , a , b , c ) ) ; }
va	4	public list < integer > getrow ( int rowindex ) { list < integer > result = new arraylist < integer > ( ) ; list < integer > temp = new arraylist < integer > ( ) ; for ( int i = 0 ; i <= rowindex ; i ++ ) { temp = new arraylist < integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
va	5	public void render ( map map ) { if ( updatesenses ) { long starttime = system . currenttimemillis ( ) ; playersenses = map . getplayersenses ( ) ; long endtime = system . currenttimemillis ( ) ; log . print ( "shadowcasting time: " + ( endtime - starttime ) ) ; updatesenses = false ; } hashmap < integer , tile > tilehashmap = playersenses . gettiles ( ) ; hashmap < integer , actor > actorhashmap = playersenses . getactors ( ) ; hashmap < integer , arraylist < entity >> entities = playersenses . getentities ( ) ; point top_left = new point ( playerpos . getx ( ) - tilesx , playerpos . gety ( ) - tilesy ) ; for ( int x = top_left . getx ( ) ; x <= playerpos . getx ( ) + tilesx ; x ++ ) { for ( int y = top_left . gety ( ) ; y <= playerpos . gety ( ) + tilesy ; y ++ ) { if ( map . inbounds ( x , y ) ) { tile tile = tilehashmap . get ( map . genkey ( x , y ) ) ; if ( tile != null ) { image image = environment . getsprite ( tile . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } arraylist < entity > ents = entities . get ( map . genkey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { entity entity = ents . get ( 0 ) ; image image = environment . getsprite ( entity . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } actor actor = actorhashmap . get ( map . genkey ( x , y ) ) ; if ( actor != null ) { image image = actor_sprites . getsprite ( actor . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } } } } image player = actor_sprites . getsprite ( actorsprite . player ) ; player . draw ( ( float ) ( ( playerpos . getx ( ) - top_left . getx ( ) ) * ppt ) , ( float ) ( ( playerpos . gety ( ) - top_left . gety ( ) ) * ppt ) , scale ) ; messagebox . render ( ) ; }
va	4	public static void applyshading ( mesh m , view3d view ) { m . ensurevertbuffers ( ) ; m . transformvertices ( m . getmatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { renderable e = m . elem ( i ) ; if ( e . type != renderable_face ) continue ; face f = ( face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; svect . x = m . viewvert [ a + 0 ] - m . viewvert [ c + 0 ] ; svect . y = m . viewvert [ a + 1 ] - m . viewvert [ c + 1 ] ; svect . z = m . viewvert [ a + 2 ] - m . viewvert [ c + 2 ] ; tvect . x = m . viewvert [ b + 0 ] - m . viewvert [ c + 0 ] ; tvect . y = m . viewvert [ b + 1 ] - m . viewvert [ c + 1 ] ; tvect . z = m . viewvert [ b + 2 ] - m . viewvert [ c + 2 ] ; fpoint3 . crossproduct ( svect , tvect , cprod ) ; cprod . normalize ( ) ; double sine = - fpoint3 . dotproduct ( cprod , view . lightdir ( ) ) ; double currlevel = f . getshade ( ) * .75 ; if ( sine > 0 ) { currlevel = ( 1.0 + sine ) * currlevel ; } f . setshade ( ( int ) currlevel ) ; } } }
va	2	public int priseterritoire ( territoire t , int nbunite ) { if ( this . nbunitebonus >= nbunite - 1 ) { this . nbunitebonus -= nbunite - 1 ; nbunite = 1 ; } else { nbunite -= this . nbunitebonus ; this . nbunitebonus = 0 ; } this . nbuniteenmain -= nbunite ; t . setnbunite ( nbunite ) ; t . setoccupant ( this ) ; this . territoiresoccupes . add ( t ) ; this . actionpriseterritoire ( t ) ; if ( haspower ( ) ) { this . pouvoir . actionpriseterritoire ( t ) ; } return nbunite ; }
va	2	@ test public void testtokenpayment ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; httpsconnector connector = new httpsconnector ( 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; legatotokenrequest legatotokenrequest = new legatotokenrequest ( ) ; legatotokenrequest . number = "5100000010001004" ; legatotokenrequest . expirymonth = 12 ; legatotokenrequest . expiryyear = 18 ; legatotokenrequest . cvd = "123" ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; tokenpaymentrequest tokenreq = new tokenpaymentrequest ( ) ; tokenreq . setamount ( 100.00 ) ; tokenreq . setordernumber ( getrandomorderid ( "token" ) ) ; tokenreq . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( tokenreq ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token pre-auth: " + tokenresponse . gettoken ( ) ) ; tokenpaymentrequest req = new tokenpaymentrequest ( ) ; req . setamount ( 80.00 ) ; req . setordernumber ( getrandomorderid ( "token" ) ) ; req . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( req ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; response = beanstream . payments ( ) . preauthcompletion ( response . id , 55.30 ) ; assert . asserttrue ( response . isapproved ( ) ) ; assert . assertequals ( "pac" , response . type ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } }
va	3	private static void createlist ( string tabname , final vector < chart > charts , tabfolder tabfolder , final stacklayout layout , final composite composite ) { final list list = new list ( tabfolder , swt . h_scroll | swt . v_scroll ) ; tabitem basictabitem = new tabitem ( tabfolder , swt . none ) ; basictabitem . settext ( tabname ) ; basictabitem . setcontrol ( list ) ; for ( chart chart : charts ) { list . add ( chart . gettitle ( ) . gettext ( ) ) ; } list . addselectionlistener ( new selectionadapter ( ) { @ override public void widgetselected ( selectionevent event ) { chart chart = charts . get ( list . getselectionindex ( ) ) ; chart . getaxisset ( ) . adjustrange ( ) ; layout . topcontrol = chart ; composite . layout ( ) ; } } ) ; }
va	5	public void actionperformed ( actionevent e ) { if ( nooftestclients == 1 ) { testclient newtc = new testclient ( serverwindow . getwmserver ( ) . getport ( ) ) ; newtc . start ( ) ; serverwindow . updatenooftestclients ( ++ counttestclients ) ; testclients . add ( newtc ) ; } else { try { nooftestclients = integer . valueof ( popup . getinput ( ) . gettext ( ) ) ; } catch ( numberformatexception nfe ) { swingutilities . invokelater ( new runnable ( ) { public void run ( ) { popup . getinput ( ) . settext ( "100" ) ; } } ) ; } swingutilities . invokelater ( new runnable ( ) { public void run ( ) { popup . dispose ( ) ; } } ) ; testclient [ ] dummy = new testclient [ nooftestclients ] ; for ( int i = 0 ; i < dummy . length ; i ++ ) { dummy [ i ] = new testclient ( serverwindow . getwmserver ( ) . getport ( ) ) ; dummy [ i ] . start ( ) ; serverwindow . updatenooftestclients ( ++ counttestclients ) ; testclients . add ( dummy [ i ] ) ; } swingutilities . invokelater ( new runnable ( ) { public void run ( ) { serverwindow . setenabled ( true ) ; } } ) ; } }
va	2	@ override public int attachsoundeffect ( soundeffect effect , int channel ) { if ( channel > cheffects . size ( ) ) throw new indexoutofboundsexception ( "channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getchannelcount ( ) != channelcount ) throw new illegalargumentexception ( "the effects channel count must be same as this mixers channel count!" ) ; meffects . add ( effect ) ; return meffects . size ( ) - 1 ; } else { if ( effect . getchannelcount ( ) != getinputchanneloutputchannelcount ( channel ) ) throw new illegalargumentexception ( "the effects channel count must be the same as input channels channel count!" ) ; arraylist < soundeffect > e = cheffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
va	3	private set < strategy > buildstrategies ( strategy strategy , int breakpointnumber , int [ ] breakpoints , int [ ] [ ] actionpercentages ) { set < strategy > strategies = new hashset < strategy > ( ) ; for ( int [ ] actionpercentageset : actionpercentages ) { strategy s = new strategy ( strategy ) ; tactic nexttactic = new tactic ( actionpercentageset ) ; s . putnewtactic ( nexttactic ) ; if ( breakpointnumber < aisettings . default_breakpoints . length - 1 ) { strategies . addall ( buildstrategies ( s , breakpointnumber + 1 , breakpoints , actionpercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
va	3	arraylist < object [ ] > getpickerargs ( ) { arraylist < object [ ] > pickerargs = new arraylist < object [ ] > ( ) ; if ( this . pickers > 0 ) { pickers pickers = this . warehouse . getpickers ( ) ; arraylist < picker > rl = pickers . getpickerlist ( ) ; for ( picker r : rl ) { object [ ] args = new object [ 1 ] ; args [ 0 ] = r . getuid ( ) ; pickerargs . add ( args ) ; } } return pickerargs ; }
va	3	private void drawlines ( graphics g , treenode [ ] nodes ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . black ) ; g2d . setstroke ( new basicstroke ( line_thickness ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i ] . centerx , nodes [ 2 * i ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i + 1 ] . centerx , nodes [ 2 * i + 1 ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } } }
va	1	public boolean autochecksibmessage ( string xml , string id [ ] , string ref [ ] ) { hashtable hashtable = sibxmlmessageparser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( string ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
va	1	@ test public void testsortcollection ( ) { xlist expected = new xlist ( ds ) ; expected . add ( 0 , ( new tree ( "\u0415\u043b\u044c" , 150 , false , 1500 ) ) ) ; expected . add ( 1 , new tree ( "\u0414\u0443\u0431" , 200 , true , 1000 ) ) ; expected . add ( 2 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u0420\u043e\u043c\u0430\u0448\u043a\u0430" , 15 , 1 ) ) ; expected . add ( 3 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u041b\u0438\u043b\u0438\u044f" , 10 , 1 ) ) ; listplant . sortcollection ( ) ; assertequals ( expected , listplant . getlistplants ( ) ) ; }
va	5	public string dtdetailsearch ( string id ) { string docname = "" ; string doctellcontent = "" ; string excutedate = "" ; string stopdate = "" ; string doctellstatus = "" ; string doctelltype = "" ; string sd = "" ; string pn = "" ; string str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; system . out . println ( "doctelldetailsearch_______________________" + str ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str ) ; resultset num = pstmt . executequery ( ) ; while ( num . next ( ) ) { excutedate = num . getstring ( "excute_date" ) ; stopdate = num . getstring ( "stop_date" ) ; docname = num . getstring ( "user_name" ) ; doctellstatus = num . getstring ( "doc_tell_status" ) ; doctelltype = num . getstring ( "doc_tell_type" ) ; doctellcontent = num . getstring ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getattribute('userid') %>\" style=\"display:none\" id=\"excuteid\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4e3b\u6cbb\u533b\u751f:" + docname + "</td>  <td>\u4f5c\u7528\u65f6\u95f4:" + excutedate + "~" + stopdate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533b\u5631\u5185\u5bb9\uff1a <textarea readonly rows=\"6\" cols=\"80\" name=\"doctellcontent\" id=\"doctellcontent\" onpropertychange=\"if(this.scrollheight>80) this.style.posheight=this.scrollheight+5\">" + doctellcontent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( doctelltype . equals ( "1" ) ) { switch ( integer . parseint ( doctellstatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nursecheck\" onclick=\"save(2)\" value=\"\u62a4\u58eb\u6821\u5bf9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docstop\"  onclick=\"save(3)\" value=\"\u505c\u6b62\u533b\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseconfirm\" onclick=\"save(4)\"  value=\"\u62a4\u58eb\u786e\u8ba4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( doctelltype . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseconfirm\"  value=\"\u62a4\u58eb\u786e\u8ba4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbconn . close ( conn ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return sb . tostring ( ) ; }
va	4	public void updatelocation ( int id , list < object > list ) { if ( ! handler_location . initialize ( ) ) { system . out . println ( "locationserver : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { string mac = ( string ) list . get ( i ) ; locationnode node = handler_location . getlocationnode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updatelocation ( id , result ) ; } handler_location . close ( ) ; }
va	5	public list < task > sort ( final int colindex , final boolean sortdown ) { gettasks ( ) ; if ( colindex >= 0 && colindex <= 6 ) { collections . sort ( tasks , new comparator < task > ( ) { @ override public int compare ( task arg0 , task arg1 ) { int result = 0 ; if ( colindex == 1 || colindex == 2 || colindex == 3 || colindex == 5 || colindex == 6 ) { stringcomparer stringcomparator = new stringcomparer ( sortdown ) ; result = comparer ( stringcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 0 ) { integercomparer intcomparator = new integercomparer ( sortdown ) ; result = comparer ( intcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 4 ) { datecomparer datecomparator = new datecomparer ( sortdown ) ; result = comparer ( datecomparator , arg0 , arg1 , colindex ) ; } return result ; } } ) ; } else { throw new illegalargumentexception ( "invalid column index." ) ; } return tasks ; }
va	1	public int getconfig ( int uid , int x , int y , int z ) { ground tile = groundarray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallobject != null && tile . wallobject . uid == uid ) return tile . wallobject . objconf & ff ; if ( tile . walldecoration != null && tile . walldecoration . uid == uid ) return tile . walldecoration . objconf & ff ; if ( tile . grounddecoration != null && tile . grounddecoration . uid == uid ) return tile . grounddecoration . objconf & ff ; for ( int e = 0 ; e < tile . entitycount ; e ++ ) if ( tile . interactiveobjects [ e ] . uid == uid ) return tile . interactiveobjects [ e ] . objconf & ff ; return - 1 ; }
va	4	public static list < employee > load ( inputstream input ) { list < employee > employees = new arraylist < employee > ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( input ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) break ; string [ ] values = line . split ( " " ) ; employee employee = new employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { } } } }
va	3	public static void main ( string [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; string s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = string . valueof ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = integer . parseint ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } system . out . println ( "# p = " + p ) ; }
va	2	private arrayschema parsearrayschema ( jsonnode rawschema , url schemalocation ) { arrayschema result = new arrayschema ( ) ; jsonnode rawitems = rawschema . get ( "items" ) ; if ( rawitems != null ) { result . setitems ( parse ( rawitems , schemalocation ) ) ; } jsonnode rawminitems = rawschema . get ( "minitems" ) ; if ( rawminitems != null ) { result . setminitems ( rawminitems . intvalue ( ) ) ; } jsonnode rawmaxitems = rawschema . get ( "maxitems" ) ; if ( rawmaxitems != null ) { result . setmaxitems ( rawmaxitems . intvalue ( ) ) ; } return result ; }
va	4	public void put ( string key , mqttpersistable message ) throws mqttpersistenceexception { checkisopen ( ) ; file file = new file ( clientdir , key + message_file_extension ) ; file backupfile = new file ( clientdir , key + message_file_extension + message_backup_file_extension ) ; if ( file . exists ( ) ) { boolean result = file . renameto ( backupfile ) ; if ( ! result ) { backupfile . delete ( ) ; file . renameto ( backupfile ) ; } } try { fileoutputstream fos = new fileoutputstream ( file ) ; fos . write ( message . getheaderbytes ( ) , message . getheaderoffset ( ) , message . getheaderlength ( ) ) ; if ( message . getpayloadbytes ( ) != null ) { fos . write ( message . getpayloadbytes ( ) , message . getpayloadoffset ( ) , message . getpayloadlength ( ) ) ; } fos . getfd ( ) . sync ( ) ; fos . close ( ) ; if ( backupfile . exists ( ) ) { backupfile . delete ( ) ; } } catch ( ioexception ex ) { throw new mqttpersistenceexception ( ex ) ; } finally { if ( backupfile . exists ( ) ) { boolean result = backupfile . renameto ( file ) ; if ( ! result ) { file . delete ( ) ; backupfile . renameto ( file ) ; } } } }
va	1	public tacticbutton ( string stext , imageicon sicon ) { super ( null ) ; addmouselistener ( mouselistener ) ; strategylabel = new jlabel ( stext . replace ( _ ,   ) , sicon , jlabel . center ) ; strategylabel . setforeground ( color . white ) ; strategylabel . setbounds ( 0 , 0 , 120 , 41 ) ; strategylabel . sethorizontalalignment ( jlabel . center ) ; strategylabel . setverticalalignment ( jlabel . center ) ; add ( strategylabel ) ; dimension size = new dimension ( 145 , 49 ) ; setpreferredsize ( size ) ; setmaximumsize ( size ) ; }
va	4	public double calscore ( query query , document doc ) { vector < string > qv = query . _tokens ; vector < string > doctokens = ( ( documentfull ) doc ) . getconvertedtitletokens ( ) ; doctokens . addall ( ( ( documentfull ) doc ) . getconvertedbodytokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( string querytoken : query . _tokens ) { for ( string doctoken : doctokens ) { if ( querytoken . equals ( doctoken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( doctokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( doctokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < doctokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( doctokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( doctokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
va	1	private void writeoutput ( datacontroller datacontroller , schedule schedule ) { outputformat outputformat = mapoutputformat ( parameters . get ( "format" ) ) ; protocol . log ( "ausgabeformat: " + outputformat ) ; string outputdirectory = parameters . get ( "out" ) ; protocol . log ( "ausgabeverzeichnis: " + outputdirectory ) ; outputcontroller outputcontroller = new outputcontroller ( ) ; list < scheduleview > scheduleviews = schedule . getallscheduleviews ( datacontroller . getrooms ( ) , datacontroller . getacademics ( ) , datacontroller . getstudyprograms ( ) ) ; outputcontroller . outputschedules ( scheduleviews , outputformat , outputdirectory ) ; }
va	5	@ override protected void process ( ) { stringtokenizer t = new stringtokenizer ( filel . getliststring ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasmoretokens ( ) ; files ++ ) { string s = t . nexttoken ( ) ; string title = print . titlestring ( "--" , s ) ; if ( showallfiles ) { print . ln ( title ) ; title = null ; } int i = 0 ; try ( bufferedreader in = new bufferedreader ( new filereader ( s ) ) ) { for ( int line = 1 ; ( s = in . readline ( ) ) != null ; line ++ ) if ( fnamefilter . accept ( s ) ) { if ( title != null ) { print . ln ( title ) ; title = null ; } print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( ioexception ioe ) { sys . warning ( ioe . tostring ( ) ) ; } if ( i > 0 || showallfiles ) { print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } print . ln ( print . separator ( "==========================" ) ) ; print . ln ( "totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
va	2	private static void loadconfig ( ) { vmconfiguration . config = new vmconfiguration ( ) ; inputstream conf_file ; try { conf_file = new fileinputstream ( new file ( conf_file ) ) ; properties props = new properties ( ) ; props . load ( conf_file ) ; config . weightnumber = integer . parseint ( props . getproperty ( constants . weight_number ) ) ; config . learnfilename = props . getproperty ( constants . learn_file_name ) ; config . topologymodeltype = props . getproperty ( constants . topology_model ) ; config . rows = integer . parseint ( props . getproperty ( constants . rows ) ) ; config . cols = integer . parseint ( props . getproperty ( constants . cols ) ) ; config . radius = integer . parseint ( props . getproperty ( constants . radius ) ) ; config . numberofweights = integer . parseint ( props . getproperty ( constants . number_of_weights ) ) ; config . maxweight = integer . parseint ( props . getproperty ( constants . max_weight ) ) ; config . maxiteration = integer . parseint ( props . getproperty ( constants . max_iteration ) ) ; config . trainmetrictype = props . getproperty ( constants . train_metric_type ) ; config . predictmetrictype = props . getproperty ( constants . predict_metric_type ) ; config . learningfactor = integer . parseint ( props . getproperty ( constants . learn_factor ) ) ; config . neighbourfactor = double . parsedouble ( props . getproperty ( constants . neighbour_factor ) ) ; config . kfoldvalue = integer . parseint ( props . getproperty ( constants . k_fold_value ) ) ; config . delimiter = props . getproperty ( constants . delimiter ) ; config . pythonfilelocation = props . getproperty ( constants . python_file ) ; config . normalizedfilename = props . getproperty ( constants . normalized_file ) ; config . normalneurons = integer . parseint ( props . getproperty ( constants . normal_neurons ) ) ; config . predictdatafile = props . getproperty ( constants . predict_data_file ) ; config . lookaheadsize = integer . parseint ( props . getproperty ( constants . look_ahead_size ) ) ; config . predictaheadstep = integer . parseint ( props . getproperty ( constants . predict_ahead_step ) ) ; config . gaussianheight = integer . parseint ( props . getproperty ( constants . gaussian_height ) ) ; config . mem_log_file = props . getproperty ( constants . mem_log_file ) ; config . metric_log_file = props . getproperty ( constants . metric_log_file ) ; config . train_mem_log_file = props . getproperty ( constants . train_mem_log_file ) ; config . train_metric_log_file = props . getproperty ( constants . train_metric_log_file ) ; config . dotest = integer . parseint ( props . getproperty ( constants . do_test ) ) ; config . vm_name = props . getproperty ( constants . vm_name ) ; config . predictfile = props . getproperty ( constants . predict_file ) ; config . annotatefile = props . getproperty ( constants . ann_file ) ; config . faultinterval = integer . parseint ( props . getproperty ( constants . fault ) ) ; } catch ( filenotfoundexception e ) { logger . error ( "error while opening configuration file" ) ; } catch ( ioexception e ) { logger . error ( "error while loading configuration file" ) ; } }
va	5	private void init ( ) { drawablepanel = new drawablepanel ( ) ; swinglistener listener = new swinglistener ( this ) ; tracer . addlisteners ( listener ) ; jbutton renderbtn = new jbutton ( "render" ) ; renderbtn . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { progressbar . setstring ( null ) ; new thread ( ) { @ override public void run ( ) { tracer . render ( scene , viewplane ) ; } } . start ( ) ; } } ) ; jpanel statuspanel = new jpanel ( new flowlayout ( flowlayout . center , 5 , 5 ) ) ; progressbar . setvalue ( 0 ) ; progressbar . setstringpainted ( true ) ; statuspanel . add ( progressbar ) ; jscrollpane scrollpane = new jscrollpane ( drawablepanel ) ; add ( statuspanel , borderlayout . page_end ) ; add ( scrollpane , borderlayout . center ) ; add ( renderbtn , borderlayout . page_start ) ; }
va	5	public void sortby ( string order ) { defaultmutabletreenode tmpnode = null ; defaultmutabletreenode curnodecopy = null ; sorttreemodel treemodeltmp = null ; defaultmutabletreenode roottmp = new defaultmutabletreenode ( rootnodetxt ) ; if ( order . equals ( "name" ) ) { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatorname ( ) ) ; sortedbyname = true ; } else { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatordate ( ) ) ; sortedbyname = false ; } sortbynamemenuitem . setenabled ( ! sortedbyname ) ; sortbydatemenuitem . setenabled ( sortedbyname ) ; for ( @ suppresswarnings ( "rawtypes" ) enumeration e = ( ( defaultmutabletreenode ) treemodel . getroot ( ) ) . breadthfirstenumeration ( ) ; e . hasmoreelements ( ) ; ) { defaultmutabletreenode curnode = ( defaultmutabletreenode ) e . nextelement ( ) ; object obj = curnode . getuserobject ( ) ; if ( obj instanceof item ) { item currentitem = ( item ) obj ; if ( currentitem . isdir ( ) ) curnodecopy = new foldernode ( currentitem ) ; else curnodecopy = new leafnode ( currentitem , ( ( leafnode ) curnode ) . getdownperc ( ) , ( ( leafnode ) curnode ) . getstatus ( ) ) ; object objpar = ( ( defaultmutabletreenode ) curnode . getparent ( ) ) . getuserobject ( ) ; if ( objpar instanceof item ) { if ( ( tmpnode = getitemintree ( ( item ) objpar , treemodeltmp ) ) != null ) { treemodeltmp . insertnodeinto ( curnodecopy , tmpnode ) ; } } else { treemodeltmp . insertnodeinto ( curnodecopy , roottmp ) ; } } } rootnode = roottmp ; treemodel = treemodeltmp ; tree . setmodel ( treemodel ) ; }
va	5	public static map < string , boolean > getallchildren ( final string node , final set < string > playerpermarray ) { final linkedlist < string > stack = new linkedlist < string > ( ) ; final map < string , boolean > alreadyvisited = new hashmap < string , boolean > ( ) ; stack . push ( node ) ; alreadyvisited . put ( node , true ) ; while ( ! stack . isempty ( ) ) { final string now = stack . pop ( ) ; final map < string , boolean > children = adminperms . getchildren ( now ) ; if ( children != null && ! playerpermarray . contains ( "-" + now ) ) { for ( final string childname : children . keyset ( ) ) { if ( ! alreadyvisited . containskey ( childname ) ) { stack . push ( childname ) ; alreadyvisited . put ( childname , children . get ( childname ) ) ; } } } } alreadyvisited . remove ( node ) ; if ( ! alreadyvisited . isempty ( ) ) { return alreadyvisited ; } return null ; }
va	4	@ suppresswarnings ( "unchecked" ) @ transactional public list < merchant > getmerchantlist ( string merchantname , string sortby , string sortorder ) throws exception { list < merchant > lstmerchants = new arraylist < merchant > ( ) ; session session = null ; criteria criteriaobj = null ; logger . info ( "merchantname---------->" + merchantname ) ; logger . info ( "sortby--------------->" + sortby ) ; logger . info ( "sortorder------------>" + sortorder ) ; string sname = merchantname ; try { session = sessionfactory . getcurrentsession ( ) ; logger . info ( "entered into getmerchantlist()--->" ) ; logger . info ( "retrieving all merchants" ) ; if ( session != null ) { criteriaobj = session . createcriteria ( merchant . class ) ; if ( merchantname != null ) { logger . info ( "retrieving  merchants based on name" ) ; criteriaobj . add ( restrictions . ilike ( "sname" , "%" + sname + "%" ) ) ; criteriaobj . add ( restrictions . = ( "bdeletedflag" , false ) ) ; } lstmerchants = criteriaobj . list ( ) ; logger . info ( "lstmerchants from dao----------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "asc" ) { logger . info ( "retrieving  merchants based on ascending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . asc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "desc" ) { logger . info ( "retrieving  merchants based on descending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . desc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } iterator < merchant > it = lstmerchants . iterator ( ) ; while ( it . hasnext ( ) ) { merchant merchant = it . next ( ) ; system . out . println ( "dao......." + merchant ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; logger . error ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; throw new exception ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; } return lstmerchants ; }
va	3	@ override public void handlecommand ( commandmessage m ) { string [ ] args = m . getargs ( ) ; if ( args . length == 1 ) { string nick = m . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containskey ( args [ 1 ] ) ) { ph . sendmessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deletecharat ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . tostring ( ) ) ; try { ph . savedata ( pozdravy ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . savedata ( pozdravy ) ; ph . sendmessage ( "pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else { ph . sendmessage ( this . help ( ph . getprefix ( ) ) ) ; } }
va	2	public static string strfill ( string fillstr , string oldstr , int length , string place ) { stringbuffer sb = new stringbuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldstr ) ; } for ( int i = 0 ; i < ( length - oldstr . length ( ) ) ; i ++ ) { sb . append ( fillstr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldstr ) ; } return sb . tostring ( ) ; }
va	2	public static void main ( string [ ] args ) { pricesinfo pricesinfo = new pricesinfo ( ) ; reader [ ] readers = new reader [ 5 ] ; thread [ ] threadsreader = new thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new reader ( pricesinfo ) ; threadsreader [ i ] = new thread ( readers [ i ] ) ; } writer writer = new writer ( pricesinfo ) ; thread threadwriter = new thread ( writer ) ; for ( thread thread : threadsreader ) { thread . start ( ) ; } threadwriter . start ( ) ; }
va	5	public void actionperformed ( actionevent e ) { if ( gridbutton . class . isinstance ( e . getsource ( ) ) ) { gridbutton b = ( gridbutton ) e . getsource ( ) ; switch ( b . getcolumn ( ) ) { case ( 0 ) : { client . openfile ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } case ( 1 ) : { int n = joptionpane . showconfirmdialog ( this , "delete " + networkfiles . get ( b . getrow ( ) ) + " from the network?" , "are you sure?" , joptionpane . yes_no_option ) ; if ( n == 0 ) client . deletefilefromnetwork ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } case ( 2 ) : { int n = joptionpane . showconfirmdialog ( this , "delete " + networkfiles . get ( b . getrow ( ) ) + " locally?" , "are you sure?" , joptionpane . yes_no_option ) ; if ( n == 0 ) client . deletelocalfile ( networkfiles . get ( b . getrow ( ) ) ) ; break ; } default : { break ; } } } else if ( jbutton . class . isinstance ( e . getsource ( ) ) ) { jbutton b = ( jbutton ) e . getsource ( ) ; if ( b == loginbutton ) { this . updatestatuslabel ( "logging into the system. please wait..." ) ; client . loginsystem ( ) ; } else if ( b == logoutbutton ) { this . updatestatuslabel ( "logging out the system. please wait..." ) ; logoutstatuswindow = new logoutstatuswindow ( this ) ; new thread ( new runnable ( ) { @ override public void run ( ) { client . logoutsystem ( ) ; } } ) . start ( ) ; } else if ( b == addfilebutton ) { if ( client . getsessionstate ( ) ) { int returnvalue = filechooser . showopendialog ( this ) ; if ( returnvalue == jfilechooser . approve_option ) { client . importfile ( filechooser . getselectedfile ( ) ) ; } } } else if ( b == infobutton ) { linkednodeswindow l = new linkednodeswindow ( this ) ; client . testprintownerfiles ( ) ; } else if ( b == settingsbutton ) { settingswindow s = new settingswindow ( this ) ; } } }
va	2	private void switchmap ( stairtile stairs ) { point oldpt = stairs . getpa ( ) ; point nextpt = stairs . getpb ( ) ; map nextmap = stairs . getmapb ( ) ; tile nextlocation = nextmap . gettile ( nextpt . x , nextpt . y ) ; player . setlocation ( nextlocation ) ; stairs . getmapa ( ) . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; stairs . getmapb ( ) . gettile ( nextpt . x , nextpt . y ) . setoccupant ( player ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( false ) ; this . map = nextmap ; messenger . drawmap ( nextmap ) ; messenger . updatetile ( nextpt ) ; resettimequeue ( ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( true ) ; if ( nextmap . gettag ( ) != null ) { messenger . showtextdialog ( gametext . gettext ( nextmap . gettag ( ) ) , nextmap . gettag ( ) ) ; player . settextcollected ( player . gettextcollected ( ) + 1 ) ; nextmap . settag ( null ) ; } messenger . centermap ( nextpt ) ; }
va	1	private void createaroundvertex ( point p ) { addvertex ( p , getrandomname ( ) ) ; point p1 = new point ( p . x - 1 , p . y - 1 ) ; point p2 = new point ( p . x , p . y - 1 ) ; point p3 = new point ( p . x + 1 , p . y - 1 ) ; point p4 = new point ( p . x + 1 , p . y ) ; point p5 = new point ( p . x - 1 , p . y ) ; point p6 = new point ( p . x , p . y + 1 ) ; point p7 = new point ( p . x + 1 , p . y + 1 ) ; point p8 = new point ( p . x - 1 , p . y + 1 ) ; addvertex ( p1 , getrandomname ( ) ) ; addvertex ( p2 , getrandomname ( ) ) ; addvertex ( p3 , getrandomname ( ) ) ; addvertex ( p4 , getrandomname ( ) ) ; addvertex ( p5 , getrandomname ( ) ) ; addvertex ( p6 , getrandomname ( ) ) ; addvertex ( p7 , getrandomname ( ) ) ; addvertex ( p8 , getrandomname ( ) ) ; addedge ( p , p1 , 1 ) ; addedge ( p , p2 , 1 ) ; addedge ( p , p3 , 1 ) ; addedge ( p , p4 , 1 ) ; addedge ( p , p5 , 1 ) ; addedge ( p , p6 , 1 ) ; addedge ( p , p7 , 1 ) ; addedge ( p , p8 , 1 ) ; }
va	2	public static void main ( string [ ] args ) { treeset < integer > set2 = new treeset < integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; arraylist < treeset < integer >> totalsubsets = findsubsets ( set2 , 0 ) ; if ( totalsubsets == null ) system . out . println ( "no possible subsets" ) ; else for ( treeset < integer > ts : totalsubsets ) { system . out . println ( ts ) ; } }
va	2	public void switchfullscreen ( ) { if ( fullscreen == false ) { throw new illegalstateexception ( "this window not supports fullscreen mode!" ) ; } if ( state == windowstate . window ) { rectangle rc = this . getbounds ( ) ; boolean resizable = this . isresizable ( ) ; this . properties = new frameproperties ( getx ( ) , gety ( ) , ( int ) rc . getwidth ( ) , ( int ) rc . getheight ( ) , resizable ) ; } if ( device . getfullscreenwindow ( ) == null ) { frameproperties properties = new frameproperties ( 0 , 0 , getfullwidth ( ) , getfullheight ( ) , false ) ; this . setextendedstate ( jframe . maximized_both ) ; this . state = windowstate . fullscreen ; properties . append ( this ) ; device . setfullscreenwindow ( this ) ; updatedisplay ( ) ; return ; } device . setfullscreenwindow ( null ) ; this . setextendedstate ( jframe . normal ) ; this . state = windowstate . window ; properties . append ( this ) ; updatedisplay ( ) ; }
va	1	public point calculateorigin ( ) { point2d plb = this . container . getleftbottomvertex ( ) ; point2d location = this . getblkcoordinate ( ) ; int sqsize = this . container . getsquaresize ( ) ; int blkx = ( int ) plb . getx ( ) ; blkx = blkx + sqsize * ( ( int ) location . getx ( ) - 1 ) ; int blky = ( int ) plb . gety ( ) ; blky = blky - sqsize * ( ( int ) location . gety ( ) - 1 ) ; return new point ( blkx , blky ) ; }
va	1	private void addtabs ( ) { addproduct = new viewaddproviderpanel ( adminprovider ) ; modifyprovidertable = new viewmodifyprovidertablepanel ( adminprovider ) ; modifyprovider = new viewmodifyproviderpanel ( adminprovider ) ; modifyprovidertable . settabs ( tabs ) ; modifyprovidertable . setswitchpanel ( modifyprovider ) ; modifyprovidertable . setname ( "modificar proveedor" ) ; modifyprovider . settabs ( tabs ) ; modifyprovider . setswitchpanel ( modifyprovidertable ) ; modifyprovider . setname ( "modificar proveedor" ) ; removeprovidertable = new viewremoveprovidertablepanel ( adminprovider ) ; removeprovider = new viewremoveproviderpanel ( adminprovider ) ; removeprovidertable . settabs ( tabs ) ; removeprovidertable . setswitchpanel ( removeprovider ) ; removeprovidertable . setname ( "eliminar proveedor" ) ; removeprovider . settabs ( tabs ) ; removeprovider . setswitchpanel ( removeprovidertable ) ; removeprovider . setname ( "eliminar proveedor" ) ; tabs . addtab ( "agregar proveedor" , addproduct ) ; tabs . setmnemonicat ( 0 , keyevent . vk_1 ) ; tabs . addtab ( "modificar proveedor" , modifyprovidertable ) ; tabs . addtab ( "eliminar proveedor" , removeprovidertable ) ; pack ( ) ; }
va	4	public static void main ( string [ ] args ) throws ioexception { scanner in = new scanner ( system . in ) ; byte p1 = 3 ; int p1guess ; int p1taken ; byte p2 = 3 ; int p2guess ; int p2taken ; boolean p1turn = true ; byte round = 0 ; system . out . println ( "stone game" ) ; while ( p1 > 0 && p2 > 0 ) { system . out . println ( "------------------" ) ; system . out . println ( "round: " + ++ round ) ; system . out . println ( " you have " + p1 + " stones; cpu has " + p2 + " stones" ) ; system . out . println ( " how much stones you're taking: " ) ; do p1taken = in . nextint ( ) ; while ( p1taken > p1 || p1taken < 0 ) ; p2taken = game . randint ( 0 , p2 ) ; if ( p1turn ) { system . out . println ( " your guess is: " ) ; p1guess = in . nextint ( ) ; do { int rand_min = p1guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2guess = game . randint ( rand_min , p1 + p2 ) ; } while ( p2guess == p1guess ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; } else { p2guess = game . randint ( p2taken , p2taken + p1 ) ; system . out . println ( "cpu is thinking of: " + p2guess ) ; system . out . println ( " your guess is: " ) ; do p1guess = in . nextint ( ) ; while ( p1guess == p2guess ) ; } system . out . println ( "we took: " + p1taken + " p2 took: " + p2taken + " stones" ) ; if ( p1guess == ( p1taken + p2taken ) ) { system . out . println ( "we won " + round + ". round" ) ; -- p1 ; p1turn = true ; } else if ( p2guess == ( p1taken + p2taken ) ) { system . out . println ( "cpu won " + round + ". round" ) ; -- p2 ; p1turn = false ; } else p1turn = ! p1turn ; } system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) system . out . println ( "player 1 has won" ) ; else system . out . println ( "cpu has won" ) ; system . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
va	2	public static void main ( string [ ] args ) throws ioexception , interruptedexception { webcam webcam = webcam . getdefault ( ) ; webcam . setviewsize ( new dimension ( 640 , 480 ) ) ; webcam . open ( ) ; jframe troll = new jframe ( ) ; jlabel boy = new jlabel ( ) ; troll . add ( boy ) ; boy . setpreferredsize ( new dimension ( 640 , 480 ) ) ; troll . pack ( ) ; troll . setresizable ( false ) ; troll . setdefaultcloseoperation ( jframe . exit_on_close ) ; troll . setvisible ( true ) ; while ( true ) { boy . seticon ( new imageicon ( webcam . getimage ( ) ) ) ; } }
va	4	public double getdistanceab ( arraylist < object > path ) { arraylist < object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new arraylist < object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( road road : roads ) { if ( road . getnodesattached ( ) . containsall ( nodes ) ) { distance += road . getdistance ( ) ; } } } distance = utilcalc . round ( distance , 2 ) ; return distance ; }
va	2	public static boolean updatekurssi ( kurssi kurssi ) { connection con = connect ( ) ; try { preparedstatement updatekurssi = con . preparestatement ( "update kurssi set nimi=? where kurssiid=?" ) ; updatekurssi . setstring ( 1 , kurssi . getnimi ( ) ) ; updatekurssi . setint ( 2 , kurssi . getid ( ) ) ; updatekurssi . executeupdate ( ) ; return true ; } catch ( sqlexception ex ) { logger . getlogger ( database . class . getname ( ) ) . log ( level . severe , null , ex ) ; return false ; } finally { closeconnection ( con ) ; } }
va	3	public string checkdataentry ( ) { if ( efastanalysispanel1 . parameterscreen . directorychosen . gettext ( ) . equals ( "selected directory: " ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) . equals ( "" ) || efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) . equals ( "" ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . parametersmodel . contains ( "none entered" ) ) { return "no parameters have been selected" ; } else { try { integer . parseint ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) ) ; integer . parseint ( efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) ) ; return null ; } catch ( numberformatexception e ) { return "number of curves and parameter samples must be integers" ; } } }
va	5	public void run ( ) throws parsingexception { parsestack . push ( new terminalentry ( eof ) ) ; parsestack . addtoparsestack ( ruletable . find ( startsymbol , starttoken ) ) ; a = parsestack . peek ( ) ; getnexttoken ( ) ; while ( ( a != null ) && ! a . iseof ( ) ) { a = parsestack . peek ( ) ; if ( a . isterminal ( ) ) { if ( a . matches ( i ) ) { parsestack . pop ( ) ; if ( parsestack . notempty ( ) ) { a = parsestack . peek ( ) ; getnexttoken ( ) ; } } else { throw new parsingexception ( "terminal mismatch. expected: " + a + " found: " + i + "" ) ; } } else if ( a . issemanticentry ( ) ) { final semanticnode node = nodefactory . getnewnode ( a ) ; node . runonsemanticstack ( semanticstack ) ; parsestack . pop ( ) ; } else { if ( isrulecontained ( a , i ) ) { parsestack . pop ( ) ; parsestack . addtoparsestack ( ruletable . find ( a , i ) ) ; a = parsestack . peek ( ) ; } else { throw new parsingexception ( "non-terminal mismatch. no entry in the table for: " + a + "   " + i ) ; } } } if ( ! stream . isempty ( ) ) { throw new parsingexception ( "parser found the end of file marker but the token stream was not empty." ) ; } }
va	4	public object getvalueat ( object node , int column ) { filenode fn = ( filenode ) node ; try { switch ( column ) { case 0 : return fn . getfile ( ) . getname ( ) ; case 1 : if ( fn . istotalsizevalid ( ) ) { return new integer ( ( int ) ( ( filenode ) node ) . totalsize ( ) ) ; } return null ; case 2 : return fn . isleaf ( ) ? "file" : "directory" ; case 3 : return fn . lastmodified ( ) ; } } catch ( securityexception se ) { } return null ; }
va	2	public static boolean invertm ( float [ ] minv , int minvoffset , float [ ] m , int moffset ) { final float src0 = m [ moffset + 0 ] ; final float src4 = m [ moffset + 1 ] ; final float src8 = m [ moffset + 2 ] ; final float src12 = m [ moffset + 3 ] ; final float src1 = m [ moffset + 4 ] ; final float src5 = m [ moffset + 5 ] ; final float src9 = m [ moffset + 6 ] ; final float src13 = m [ moffset + 7 ] ; final float src2 = m [ moffset + 8 ] ; final float src6 = m [ moffset + 9 ] ; final float src10 = m [ moffset + 10 ] ; final float src14 = m [ moffset + 11 ] ; final float src3 = m [ moffset + 12 ] ; final float src7 = m [ moffset + 13 ] ; final float src11 = m [ moffset + 14 ] ; final float src15 = m [ moffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; minv [ minvoffset ] = dst0 * invdet ; minv [ 1 + minvoffset ] = dst1 * invdet ; minv [ 2 + minvoffset ] = dst2 * invdet ; minv [ 3 + minvoffset ] = dst3 * invdet ; minv [ 4 + minvoffset ] = dst4 * invdet ; minv [ 5 + minvoffset ] = dst5 * invdet ; minv [ 6 + minvoffset ] = dst6 * invdet ; minv [ 7 + minvoffset ] = dst7 * invdet ; minv [ 8 + minvoffset ] = dst8 * invdet ; minv [ 9 + minvoffset ] = dst9 * invdet ; minv [ 10 + minvoffset ] = dst10 * invdet ; minv [ 11 + minvoffset ] = dst11 * invdet ; minv [ 12 + minvoffset ] = dst12 * invdet ; minv [ 13 + minvoffset ] = dst13 * invdet ; minv [ 14 + minvoffset ] = dst14 * invdet ; minv [ 15 + minvoffset ] = dst15 * invdet ; return true ; }
va	3	public boolean iscallablereference ( class clazz ) { if ( this == globalbridge ) { return false ; } if ( ! referencesenabled ) { return false ; } if ( callablereferenceset . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getinterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callablereferenceset . contains ( interfaces [ i ] ) ) { return true ; } } class superclass = clazz . getsuperclass ( ) ; while ( superclass != null ) { if ( callablereferenceset . contains ( superclass ) ) { return true ; } superclass = superclass . getsuperclass ( ) ; } return globalbridge . iscallablereference ( clazz ) ; }
va	5	public file getfilechoice ( component parent ) { if ( chooser . showsavedialog ( parent ) == jfilechooser . approve_option ) { file newfile = chooser . getselectedfile ( ) ; if ( chooser . getfilefilter ( ) == zipfilter ) { if ( ! newfile . getname ( ) . touppercase ( ) . endswith ( ".zip" ) ) { newfile = new file ( newfile . getabsolutefile ( ) + ".zip" ) ; } } if ( newfile . exists ( ) ) { int confirmchoice = joptionpane . showconfirmdialog ( parent , "file already exists. do you want to replace it?" ) ; if ( confirmchoice == joptionpane . yes_option ) { newfile . delete ( ) ; } else if ( confirmchoice == joptionpane . no_option ) { return getfilechoice ( parent ) ; } else { return null ; } } if ( ! newfile . exists ( ) ) { boolean filecreated = false ; try { filecreated = newfile . createnewfile ( ) ; } catch ( exception e ) { } finally { if ( ! filecreated ) { joptionpane . showmessagedialog ( parent , "an error occurred" ) ; return null ; } } } return newfile ; } else { return null ; } }
va	3	public int [ ] getactions ( game game , long timedue ) { int pacmanloc = game . getcurpacmanloc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostrequiresaction ( i ) ) { if ( iscrowded ( game ) && ! closetomspacman ( game , game . getcurghostloc ( i ) ) ) dirs [ i ] = getretreatactions ( game , i ) ; else if ( game . getedibletime ( i ) > 0 || closetopower ( game ) ) dirs [ i ] = game . getnextghostdir ( i , pacmanloc , false , game . dm . path ) ; else dirs [ i ] = game . getnextghostdir ( i , pacmanloc , true , game . dm . path ) ; } } return dirs ; }
va	3	public static string readfile ( string filepath ) throws filenotexistexception { file file = new file ( filepath ) ; stringbuilder builder = new stringbuilder ( ) ; if ( ! file . exists ( ) ) { throw new filenotexistexception ( filepath ) ; } try { bufferedreader buffer = new bufferedreader ( new filereader ( file ) ) ; string tmp = buffer . readline ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readline ( ) ; if ( tmp != null ) builder . append ( 
 ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return builder . tostring ( ) ; }
va	3	@ override public void init ( ) { qidtf = new jtextfield ( ) ; label = new jlabel ( ) ; setlayout ( new borderlayout ( ) ) ; add ( "north" , new jlabel ( "quest id" ) ) ; add ( "center" , qidtf ) ; add ( "south" , label ) ; label . setforeground ( color . red ) ; qidtf . getdocument ( ) . adddocumentlistener ( new questexistslistener ( getfinishbutton ( ) ) { public boolean update ( documentevent e ) { boolean a = super . update ( e ) ; if ( a == false ) label . settext ( "this quest doesn't exist." ) ; else label . settext ( "" ) ; return a ; } } ) ; }
va	2	private void listsolicitudesmouseclicked ( java . awt . event . mouseevent evt ) { int no ; no = listsolicitudes . getselectedindex ( ) ; int reply = joptionpane . showconfirmdialog ( null , "desea agregara a " + listas . get ( no - 1 ) . nombre + "(" + listas . get ( no - 1 ) . usuario + ")" , "solicitud de amistad" , joptionpane . yes_no_option ) ; string resp = "<solicitud_amistad>\n" ; if ( reply == joptionpane . yes_option ) { resp += "<respuesta> si </respuesta>\n" ; } else { resp += "<respuesta> no </respuesta>\n" ; } usuario usuario = servidor . getusuario ( txtuser . gettext ( ) ) ; resp += "<destinatario>" + listas . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + txtuser . gettext ( ) + "</usuario>\n" + "<nombre> " + usuario . getnombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listas . remove ( no - 1 ) ; listsolicitudes . updateui ( ) ; servidor . actualizarsolicitudes2 ( listas , usuario . getusername ( ) ) ; writeutf ( resp ) ; listsolicitudes . repaint ( ) ; system . err . println ( resp ) ; }
va	5	public string [ ] searchlogin ( javax . swing . jtextfield jtextfield1 , javax . swing . jpasswordfield jpasswordfield1 ) { string checklogin = "" ; string name = "" ; for ( arraylist < string > user : aldata ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jtextfield1 . gettext ( ) . equals ( user . get ( j ) ) ) { char [ ] cpassword = jpasswordfield1 . getpassword ( ) ; string spassword = string . valueof ( cpassword ) ; if ( spassword . equals ( user . get ( j + 1 ) ) ) { system . out . println ( "login efetuado com sucesso!" ) ; checklogin = user . get ( 0 ) ; name = user . get ( 3 ) ; system . out . println ( "bem vindo" + name ) ; } } } } if ( "" . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; system . out . println ( "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; } tring data = tring . clone ( checklogin ) ; if ( data . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , parsedfile ) ; system . out . println ( "error - file does not exist" ) ; } return new string [ ] { checklogin , name } ; }
va	2	public static privatekey readprivatekeyfromder ( string filename ) { try { inputstream fl = fullstream ( filename ) ; byte [ ] key = new byte [ fl . available ( ) ] ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; pkcs8encodedkeyspec keysp = new pkcs8encodedkeyspec ( key ) ; privatekey privk = kf . generateprivate ( keysp ) ; return privk ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
va	3	public string getpinyincolorized ( ) { stringbuilder ankipinyin = new stringbuilder ( ) ; string [ ] syllables = pinyinutil . getsyllables ( pinyin ) ; int curtone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankipinyin . append ( " " ) ; } curtone = gettone ( syllables [ i ] ) ; if ( curtone == 0 ) { ankipinyin . append ( syllables [ i ] ) ; } else { ankipinyin . append ( "<span style = \"color:" ) ; ankipinyin . append ( tonecolor [ curtone ] ) ; ankipinyin . append ( "\">" ) ; ankipinyin . append ( pinyinutil . tounicode ( syllables [ i ] ) ) ; ankipinyin . append ( "</span>" ) ; } } return ankipinyin . tostring ( ) ; }
va	2	static list < vcscommit > parsecommits ( string xml ) { try { commitreadinghandler commitreadinghandler = new commitreadinghandler ( ) ; saxparserfactory parserfactory = saxparserfactory . newinstance ( ) ; xmlreader xmlreader = parserfactory . newsaxparser ( ) . getxmlreader ( ) ; xmlreader . setcontenthandler ( commitreadinghandler ) ; xmlreader . parse ( new inputsource ( new stringreader ( xml ) ) ) ; return commitreadinghandler . commits ; } catch ( saxexception e ) { throw new runtimeexception ( "failed to parse xml: " + xml , e ) ; } catch ( parserconfigurationexception | ioexception e ) { throw new runtimeexception ( e ) ; } }
va	4	public synchronized void doranking ( ) { calculate_tf_idf_q ( ) ; query q ; for ( string term : queryterms . keyset ( ) ) { term = term . trim ( ) ; q = queryterms . get ( term ) ; q . setpostings ( getpostingsfor ( term ) ) ; if ( q . getpostings ( ) == null ) { system . out . println ( "sry. no postings found" ) ; continue ; } for ( posting p : q . getpostings ( ) . getpostings ( ) ) { float value = ( float ) ( q . gettf_idf ( ) * calculate_tf_idf_d ( p , q . getpostings ( ) . getoverallfrequency ( ) ) ) ; score s = new score ( ) ; s . setscore ( value ) ; s . setid ( p . getdocid ( ) ) ; if ( ! scores . containskey ( p . getdocid ( ) ) ) { scores . put ( p . getdocid ( ) , s ) ; } else { score sc = scores . get ( p . getdocid ( ) ) ; float score = sc . getscore ( ) ; score += value ; sc . setscore ( score ) ; scores . put ( p . getdocid ( ) , sc ) ; } } } float newscore , lengthv ; score s ; for ( string id : scores . keyset ( ) ) { s = scores . get ( id ) ; try { newscore = s . getscore ( ) / length . get ( id ) . floatvalue ( ) ; s . setscore ( newscore ) ; scores . put ( id , s ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }
va	5	private objective loadobjective ( tagcompound tag ) { try { tagbase tbname = tag . gettag ( "name" ) ; if ( ! ( tbname instanceof tagstring ) ) return null ; tagbase tbtarget = tag . gettag ( "target" ) ; if ( ! ( tbtarget instanceof tagstring ) ) return null ; tagbase tbtypes = tag . gettag ( "type" ) ; if ( ! ( tbtypes instanceof tagstring ) ) return null ; objectivetype t = questmanager . getinstance ( ) . getregisteredobjectivetype ( ( ( tagstring ) tbtypes ) . data ) ; if ( t == null ) return null ; objective o = new objective ( tag . getname ( ) , ( ( tagstring ) tbname ) . data , t , ( ( tagstring ) tbtarget ) . data ) ; tagbase tbicoid = tag . gettag ( "iconid" ) ; if ( tbicoid instanceof tagint ) o . setitemiconid ( ( ( tagint ) tbicoid ) . data ) ; tagbase tbopt = tag . gettag ( "optional" ) ; if ( tbopt instanceof tagbyte ) o . setoptional ( ( ( tagbyte ) tbopt ) . data == 1 ) ; tagbase tbvis = tag . gettag ( "visible" ) ; if ( tbvis instanceof tagbyte ) o . setvisible ( ( ( tagbyte ) tbvis ) . data == 1 ) ; tagbase rewards = tag . gettag ( "rewards" ) ; if ( rewards instanceof taglist ) { for ( tagbase b : ( ( taglist ) rewards ) . get ( ) ) { if ( b instanceof tagcompound ) { questaction a = loadaction ( ( tagcompound ) b ) ; if ( a != null ) o . addreward ( a ) ; } } } tagbase desc = tag . gettag ( "description" ) ; arraylist < string > dsc = new arraylist < string > ( ) ; if ( desc instanceof taglist ) { for ( tagbase b : ( ( taglist ) desc ) . get ( ) ) { if ( b instanceof tagstring ) { dsc . add ( ( ( tagstring ) b ) . data ) ; } } } o . setdescription ( dsc ) ; return o ; } catch ( illegalargumentexception iae ) { return null ; } }
va	2	private void flushmemorytable ( ) { changetableslock . lock ( ) ; try { memorytableaccessor . useauxiliary ( ) ; } finally { changetableslock . unlock ( ) ; } disktable disktable ; try { memorytable memorytable = memorytableaccessor . getmaindatatable ( ) ; path newtablefile = disktableaccessor . newpathfortable ( ) ; flusher flusher = new flusher ( newtablefile , disktableaccessor . blocksize ( ) ) ; system . out . println ( "node: info: flushing memory table to " + newtablefile ) ; disktable = flusher . flush ( memorytable , memorytable . timestamp ( ) ) ; } catch ( ioexception e ) { system . out . println ( "node: exception: " + e ) ; throw new runtimeexception ( e ) ; } changetableslock . lock ( ) ; try { disktableaccessor . adddisk ( disktable ) ; memorytableaccessor . stopusingauxiliary ( ) ; commitlog . reset ( ) ; } finally { changetableslock . unlock ( ) ; } }
va	4	public static void main ( string [ ] args ) { utility . configure ( ) ; jobtrackercomm = new communication ( utility . jobtracker . ipaddress , utility . jobtracker . port ) ; system . out . println ( "registering on job tracker..." ) ; message msg = new message ( utility . tasktrackerreg ) ; jobtrackercomm . sendmessage ( msg ) ; msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . regack ) { tasktrackerid = msg . gettasktrackerid ( ) ; system . out . println ( "successfully registered." ) ; } while ( isrunning ) { msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . newjob ) { jobcontext jobcontext = msg . getjobcontext ( ) ; string jobid = jobcontext . getjobid ( ) . getid ( ) ; system . out . println ( "receiced new job from job[" + jobid + "] tracker" ) ; if ( ! jobcontexts . containskey ( jobid ) ) { jobcontexts . put ( jobid , jobcontext ) ; } msg = new message ( utility . newjoback ) ; jobtrackercomm . sendmessage ( msg ) ; } else if ( msg . getmsgtype ( ) == utility . runmapper ) { system . out . println ( "received runmapper command from job tracker." ) ; list < mapbasiccontext > mapbasiccontexts = msg . getmapcontexts ( ) ; if ( mapbasiccontexts . size ( ) != 0 ) { string jobid = mapbasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; nummappers = mapbasiccontexts . size ( ) ; launchmappers ( jobcontext , mapbasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . runreducer ) { system . out . println ( "received runreducer command from job tracker." ) ; list < reducebasiccontext > reducebasiccontexts = msg . getreducecontexts ( ) ; if ( reducebasiccontexts . size ( ) != 0 ) { string jobid = reducebasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; numreducers = reducebasiccontexts . size ( ) ; launchreducers ( jobcontext , reducebasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . close ) { isrunning = false ; } } jobtrackercomm . close ( ) ; }
va	4	private void parsedocument ( int docnumber ) { element docele = docs . get ( docnumber ) . getdocumentelement ( ) ; nodelist nodelist = docele . getelementsbytagname ( "room" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( i ) ; string filename = el . gettextcontent ( ) ; parsexmlfile ( new file ( filename ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { element roomdocele = docs . get ( i ) . getdocumentelement ( ) ; nodelist roomnodelist = roomdocele . getelementsbytagname ( "room" ) ; if ( roomnodelist != null && roomnodelist . getlength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getlength ( ) ; j ++ ) { element roomelement = ( element ) roomnodelist . item ( j ) ; getroom ( roomelement ) ; } } } nodelist = docele . getelementsbytagname ( "connect" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( i ) ; getconnection ( el ) ; } } nodelist = docele . getelementsbytagname ( "player" ) ; if ( nodelist != null && nodelist . getlength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getlength ( ) ; i ++ ) { element el = ( element ) nodelist . item ( 0 ) ; mc = getplayer ( el ) ; } } }
va	4	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getx ( ) ; float y = waternodes . get ( i ) . physrect . gety ( ) ; float width = waternodes . get ( i ) . physrect . getwidth ( ) ; float height = waternodes . get ( i ) . physrect . getheight ( ) ; node leaf = getleaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x , y + height , block . water ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x + width , y , block . water ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x - width , y , block . water ) ; emptycell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getx ( ) ; float y = acidnodes . get ( i ) . physrect . gety ( ) ; float width = acidnodes . get ( i ) . physrect . getwidth ( ) ; float height = acidnodes . get ( i ) . physrect . getheight ( ) ; node leaf = getleaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x , y + height , block . acid ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x + width , y , block . acid ) ; emptycell ( x , y ) ; continue ; } } leaf = getleaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == block . empty ) { fillcell ( x - width , y , block . acid ) ; emptycell ( x , y ) ; continue ; } } } }
va	3	public static void create ( string [ ] args ) { vector < vslfiledatachunk > chunks = null ; if ( args . length < 3 ) { system . err . println ( "missings args: create <dbfile> <source>" ) ; system . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkfile ( source ) ; vsldatatype < vslfiledatachunk > filedata = new vsldatatype < vslfiledatachunk > ( ) ; stringtokenizer st = new stringtokenizer ( source , "/" ) ; string fname = "unset" ; while ( st . hasmoretokens ( ) ) { fname = st . nexttoken ( ) ; } filedata . setname ( fname ) ; for ( vslfiledatachunk chunk : chunks ) { filedata . addnewchunk ( chunk ) ; } core . addentry ( filedata ) ; core . debugshow ( ) ; core . save ( ) ; } catch ( exception e ) { system . err . println ( "caught exception: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
va	4	public polygon getpolygon ( string s_namecity ) { polygon polygontoreturn = new polygon ( ) ; for ( district district : model . getlistdistrict ( ) ) { for ( city city : district . getlistcity ( ) ) { if ( city . gets_name ( ) . equals ( s_namecity ) ) { int i_x = district . geti_x ( ) * model . geti_nbhorizontalsquareindistrict ( ) + city . geti_x ( ) + ( district . geti_y ( ) % 2 ) * model . geti_nbhorizontalsquareindistrict ( ) / 2 ; int i_y = district . geti_y ( ) * model . geti_nbverticalsquareindistrict ( ) + city . geti_y ( ) ; point point2d = new point ( i_x , i_y ) ; polygontoreturn . setpoint2d ( point2d ) ; polygontoreturn . setpoint3d ( convert2dto3d ( point2d ) ) ; return polygontoreturn ; } } } return polygontoreturn ; }
va	1	@ override public void onsimulationdone ( simulationevent event ) { simulationfinalresult result = ( simulationfinalresult ) event . geteventdata ( ) ; double w0 = result . getwinpercentage ( 0 ) ; double l0 = result . getlosepercentage ( 0 ) ; double t0 = result . gettiepercentage ( 0 ) ; double w1 = result . getwinpercentage ( 1 ) ; double l1 = result . getlosepercentage ( 1 ) ; double t1 = result . gettiepercentage ( 1 ) ; double w2 = result . getwinpercentage ( 2 ) ; double l2 = result . getlosepercentage ( 2 ) ; double t2 = result . gettiepercentage ( 2 ) ; system . out . println ( "win 1: " + w0 ) ; system . out . println ( "lose 1: " + l0 ) ; system . out . println ( "tie 1: " + t0 ) ; system . out . println ( "win 2: " + w1 ) ; system . out . println ( "lose 2: " + l1 ) ; system . out . println ( "tie 2: " + t1 ) ; system . out . println ( "win 3: " + w2 ) ; system . out . println ( "lose 3: " + l2 ) ; system . out . println ( "tie 3: " + t2 ) ; long duration = result . getduration ( ) ; system . out . println ( "duration: " + duration + " ms" ) ; }
va	3	public v checkbaseinterfaces ( class c ) { map < class , v > possibles = new hashmap < class , v > ( ) ; for ( class base = c ; base != object . class ; base = base . getsuperclass ( ) ) { for ( class itf : base . getinterfaces ( ) ) { v val = lookup . valat ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new runtimeexception ( "more thane one match for " + c ) ; } }
va	5	public void sendpinmsg ( ) { message = msgs . gettext ( ) ; subject = subj . gettext ( ) ; httpclient hc = new httpclient ( ) ; hc . getconnectionstring ( ) ; if ( ! appfunctions . ntwkcon ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please check your network  pin broadcast requires bis or wifi" ) ; info . settext ( "check your network connection" ) ; } } ) ; } else if ( appfunctions . trialcount < 1 ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "you have exceeded the number of messages you can send. you have " + appfunctions . trialcount + " left. please buy more messages by selecting the 'buy pin message' menu for information on subscription. select 'verify account' on the menu after subscription to send more messages." ) ; info . settext ( "message number exceeded." ) ; } } ) ; } else if ( contactarray . size ( ) > appfunctions . trialcount ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "the contacts in your message exceeds what you have left (" + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) + "). please subscribe and select 'verify account' on the menu for unlimited contacts or reduce the number of your contacts to " + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . gettext ( ) . length ( ) < 2 || filesel == null ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please verify that from  subject  message and your contact file has been entered properly before sending this message." ) ; info . settext ( "error in message  please check again." ) ; } } ) ; } else { new thread ( sndmsg ) . start ( ) ; } } }
va	5	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 1500 , 1000 ) ; frame . setlocationrelativeto ( null ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setvisible ( true ) ; final taskmgrgraph graph = new taskmgrgraph ( new taskmgrcolors ( ) ) ; new thread ( "memory thread" ) { @ override public void run ( ) { while ( true ) { runtime rt = runtime . getruntime ( ) ; long current = ( rt . totalmemory ( ) - rt . freememory ( ) ) / 1024 / 1024 ; long max = rt . totalmemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setmaximum ( ( int ) max ) ; graph . addvalue ( ( int ) current ) ; graph . settext ( current + " mb" ) ; system . out . println ( "current usage: " + current + "  maximum usage: " + max + "  percent: " + % ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } ; new thread ( "random thread" ) { @ override public void run ( ) { while ( true ) { graph . setmaximum ( 10000 ) ; int value = new random ( ) . nextint ( 10000 ) ; graph . addvalue ( value ) ; graph . settext ( value + "" ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
va	2	private void initblock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsgetuchar ( ) ; magic2 = bsgetuchar ( ) ; magic3 = bsgetuchar ( ) ; magic4 = bsgetuchar ( ) ; magic5 = bsgetuchar ( ) ; magic6 = bsgetuchar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badblockheader ( ) ; streamend = true ; return ; } storedblockcrc = bsgetint32 ( ) ; if ( bsr ( 1 ) == 1 ) { blockrandomised = true ; } else { blockrandomised = false ; } getandmovetofrontdecode ( ) ; mcrc . initialisecrc ( ) ; currentstate = start_block_state ; }
va	3	public static void benchmark ( ) throws exception { int n = 100000 ; string [ ] methodstocompare = { "canwriteletterfrommagazine1" , "canwriteletterfrommagazine2" , "canwriteletterfrommagazine3" , "canwriteletterfrommagazine4" , "canwriteletterfrommagazine5" , "canwriteletterfrommagazine6" , "canwriteletterfrommagazine7" } ; string magazine = cleaninput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; string letter = cleaninput ( "hogs are swine" ) ; for ( string methodname : methodstocompare ) { class clazz = class . forname ( "book.chapter.twelve.problem12_09" ) ; method method = clazz . getdeclaredmethod ( methodname , string . class , string . class ) ; long starttime = system . nanotime ( ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean retval = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retval == false ) throw new exception ( "wrong result!" ) ; } long endtime = system . nanotime ( ) ; system . out . println ( "elapsed time for " + methodname + ": " + ( endtime - starttime ) / 1000000000.0 + " seconds" ) ; } }
va	4	public boolean ismatching ( stringbuffer word , int wordpos ) { boolean matching = true , inmulti = false , multimatch = false ; char matchch ; for ( int matchpos = 0 ; matchpos < match . length ; matchpos ++ ) { matchch = match [ matchpos ] ; if ( matchch == startmulti || matchch == endmulti ) { inmulti = ! inmulti ; if ( ! inmulti ) matching = matching & multimatch ; else multimatch = false ; } else { if ( matchch != word . charat ( wordpos ) ) { if ( inmulti ) multimatch = multimatch | false ; else matching = false ; } else { if ( inmulti ) multimatch = multimatch | true ; else matching = true ; } if ( ! inmulti ) wordpos ++ ; if ( ! matching ) break ; } } if ( end && wordpos != word . length ( ) ) matching = false ; return matching ; }
va	1	public evlassignfsm ( list < evlcomponent > components , evlstatement statement ) { this . components = components ; this . statement = statement ; initstate = new initstate ( this ) ; lhsstate = new lhsstate ( this ) ; lhsnamestate = new lhsnamestate ( this ) ; lhsbusstate = new lhsbusstate ( this ) ; lhsmsbstate = new lhsmsbstate ( this ) ; lhscolonstate = new lhscolonstate ( this ) ; lhslsbstate = new lhslsbstate ( this ) ; lhsdonestate = new lhsdonestate ( this ) ; rhsstate = new rhsstate ( this ) ; rhsnamestate = new rhsnamestate ( this ) ; rhsbusstate = new rhsbusstate ( this ) ; rhsmsbstate = new rhsmsbstate ( this ) ; rhscolonstate = new rhscolonstate ( this ) ; rhslsbstate = new rhslsbstate ( this ) ; rhsdonestate = new rhsdonestate ( this ) ; donestate = new donestate ( this ) ; state = initstate ; }
va	2	private bed getbed ( commandline cmd ) { bed bed = null ; if ( cmd . hasoption ( "hostel_id" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . sethostelid ( new identifier ( cmd . getoptionvalue ( "hostel_id" ) ) ) ; } if ( cmd . hasoption ( "bed_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setnumber ( new integer ( cmd . getoptionvalue ( "bed_number" ) ) ) ; } if ( cmd . hasoption ( "room_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setroomno ( new integer ( cmd . getoptionvalue ( "room_number" ) ) ) ; } if ( bed != null ) bed . settariff ( null ) ; return bed ; }
va	3	public static void main ( string [ ] argv ) { final int regulpriority = 8 ; final int refgenpriority = 6 ; final int plotterpriority = 7 ; referencegenerator refgen = new referencegenerator ( refgenpriority ) ; regul regul = new regul ( regulpriority ) ; final opcom opcom = new opcom ( plotterpriority ) ; regul . setopcom ( opcom ) ; regul . setrefgen ( refgen ) ; opcom . setregul ( regul ) ; runnable initializegui = new runnable ( ) { public void run ( ) { opcom . initializegui ( ) ; opcom . start ( ) ; } } ; try { swingutilities . invokeandwait ( initializegui ) ; } catch ( exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
va	2	public customer editcustomer ( customer customer ) throws exception { if ( customer . getid ( ) == null || customer . getaddress ( ) == null || customer . getname ( ) == null || customer . getsurname ( ) == null || customer . gettelephones ( ) == null ) { throw new nullparameterexception ( ) ; } if ( ! checkzipcode ( customer . getaddress ( ) . getzipcode ( ) ) ) { throw new zipcodeoutofrangeexception ( ) ; } daofactory . factory . getcustomerdao ( ) . updatecustomer ( customer ) ; return customer ; }
va	1	@ test public void testmakestatsreturnscorrectstats ( ) { random rand = new random ( ) ; evdistribution evdistribution = mock ( evdistribution . class ) ; nature nature = mock ( nature . class ) ; when ( evdistribution . getnature ( ) ) . thenreturn ( nature ) ; int hpevs = rand . nextint ( 1000 ) ; int defevs = rand . nextint ( 1000 ) ; int spdefevs = rand . nextint ( 1000 ) ; when ( evdistribution . gethp ( ) ) . thenreturn ( hpevs ) ; when ( evdistribution . getdef ( ) ) . thenreturn ( defevs ) ; when ( evdistribution . getspdef ( ) ) . thenreturn ( spdefevs ) ; ibasestats basestats = mock ( ibasestats . class ) ; int basehp = rand . nextint ( 1000 ) ; int basedef = rand . nextint ( 1000 ) ; int basespdef = rand . nextint ( 1000 ) ; when ( basestats . gethp ( ) ) . thenreturn ( basehp ) ; when ( basestats . getdef ( ) ) . thenreturn ( basedef ) ; when ( basestats . getspdef ( ) ) . thenreturn ( basespdef ) ; int hpstat = rand . nextint ( 1000 ) ; int defstat = rand . nextint ( 1000 ) ; int spdefstat = rand . nextint ( 1000 ) ; when ( hpcalculator . calculate ( basehp , hpevs , nature ) ) . thenreturn ( hpstat ) ; when ( defcalculator . calculate ( basedef , defevs , nature ) ) . thenreturn ( defstat ) ; when ( spdefcalculator . calculate ( basespdef , spdefevs , nature ) ) . thenreturn ( spdefstat ) ; pokemonstats pokemonstats = statsfactory . makestats ( evdistribution , basestats ) ; assertequals ( hpstat , pokemonstats . gethp ( ) ) ; assertequals ( defstat , pokemonstats . getdef ( ) ) ; assertequals ( spdefstat , pokemonstats . getspdef ( ) ) ; }
va	4	private void createtable ( ormhash ht , ormtable table ) throws sqlexception { string createsql = ht . createsql ( ) ; string tablename = table . tablename ( ) ; int hashsize = ht . hashsize ( ) ; if ( hashsize < 1 ) { hashsize = 1 ; } list < string > alreadyexisttablelist = dao . queryforsimpobjectlist ( "show tables like '" + tablename + "%'" , new object [ ] { } , string . class ) ; messageformat mf = new messageformat ( createsql ) ; string hashtablename = null ; for ( int i = 0 ; i < hashsize ; i ++ ) { hashtablename = tablename + "_" + dbutils . getinstance ( ) . hash ( i , hashsize ) ; if ( alreadyexisttablelist . contains ( hashtablename ) ) { logger . trace ( "hash table[{}] is already exist!" , hashtablename ) ; } else { logger . info ( "init hash table:{};" , hashtablename ) ; dao . update ( mf . format ( new object [ ] { hashtablename } ) ) ; logger . info ( "init hash table[{}] finish." , hashtablename ) ; } } }
va	5	public void makeframenotactive ( final callframe frametohold ) { java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { resumebutton = new jbutton ( "\u0412\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0437\u0432\u043e\u043d\u043e\u043a" ) ; resumebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { string numbertounhold = parkbridgelines . get ( frametohold ) . get ( "numbertounhold" ) ; string holdchannel = parkbridgelines . get ( frametohold ) . get ( "holdchannel" ) ; frametohold . holdifnotactive ( ) ; resume ( numbertounhold , holdchannel . substring ( 0 , holdchannel . indexof ( "-" ) ) ) ; } } ) ; resumebutton . setpreferredsize ( new dimension ( 300 , 130 ) ) ; resumebutton . setbackground ( new color ( 0 , 25 , 0 ) ) ; resumebutton . setforeground ( new color ( 255 , 255 , 255 ) ) ; resumebutton . setfont ( new font ( "timesroman" , font . plain , 35 ) ) ; frametohold . add ( resumebutton , borderlayout . north ) ; frametohold . setpreferredsize ( new dimension ( 400 , 400 ) ) ; frametohold . pack ( ) ; } } ) ; }
va	1	protected void jbinit ( ) throws exception { jpanel toppanel = new jpanel ( ) ; jpanel bottompanel = new jpanel ( ) ; jpanel rightpanel = new jpanel ( ) ; this . setcenter ( ) ; this . setnorth ( toppanel ) ; this . setsouth ( bottompanel ) ; this . seteast ( rightpanel ) ; m_mainpane . add ( toppanel , borderlayout . north ) ; m_mainpane . add ( m_gridscrollarea , borderlayout . center ) ; m_mainpane . add ( rightpanel , borderlayout . east ) ; m_mainpane . add ( bottompanel , borderlayout . south ) ; }
va	1	public static pair < integer , integer > linearcongruence ( int a , int b , final int n ) { positivecheck ( n ) ; a = normalizeintmodulo ( a , n ) ; b = normalizeintmodulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new pair < > ( 0 , 1 ) ; final int numberofsolutions = gcd ( a , n ) ; if ( b % numberofsolutions != 0 ) return new pair < > ( ) ; int bezoutcoefficienta ; if ( a > n ) bezoutcoefficienta = bezout ( a , n ) . get ( 1 ) ; else bezoutcoefficienta = bezout ( n , a ) . get ( 2 ) ; final int shiftedmodulus = n / numberofsolutions ; int x = ( bezoutcoefficienta * b ) / numberofsolutions ; x = normalizeintmodulo ( x , shiftedmodulus ) ; return new pair < > ( x , shiftedmodulus ) ; }
va	5	private static int computelongestcycle ( string string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . tochararray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
va	1	public bus ( string id , driver driver , string plate , route route , int speed , double position , boolean state ) { this . id = id ; this . driver = driver ; this . plate = plate ; this . route = route ; this . speed = speed ; this . position = position ; this . state = state ; driver = new driver ( "not assigned" , "not assigned" , "not assigned" ) ; starttime = new gregoriancalendar ( ) ; nextstoptime = new gregoriancalendar ( ) ; acceleration = 0 ; movementstate = 99 ; stoptime = 0 ; }
va	5	private boolean placerandomteleportlocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new illegalargumentexception ( "invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new illegalargumentexception ( "invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new illegalargumentexception ( "invalid argument: the randomlocation array-holder is not of length 2" ) ; arraylist < int [ ] > availablelocations = new arraylist < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availablelocations . add ( new int [ ] { i , j } ) ; } } } if ( availablelocations . size ( ) == 0 ) { java . lang . system . out . println ( "warning: you have a teleporter in a map with no spaces" ) ; return false ; } random random = new random ( ) ; random . setseed ( java . lang . system . currenttimemillis ( ) ) ; int index = random . nextint ( availablelocations . size ( ) ) ; int [ ] chosen = availablelocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
va	2	@ override public dataunit read ( protocol p , readablebytechannel channel ) throws ioexception { readablebytechannel currentchannel = channel ; dataunit dataunit = headerprocessor . read ( p , currentchannel ) ; int totallength = protocolutil . gettotallength ( dataunit , p ) ; if ( totallength != - 1 ) { int toread = totallength - protocolutil . getheaderbytes ( p ) ; byte [ ] bytes = ioutil . readbytes ( toread , currentchannel ) ; currentchannel = channels . newchannel ( new bytearrayinputstream ( bytes ) ) ; } dataunit = unitprocessor . fromstream ( dataunit , p , currentchannel ) ; currentchannel = channel ; return dataunit ; }
va	5	void deleteactivity ( component dialogparent , activity activity ) { if ( activity != null ) { if ( alertmessages . deleteactivityconfirmation ( dialogparent , activity ) ) { try { connection conn = dao . getconnection ( ) ; for ( time t : timedao . gettimesbyactivity ( conn , activity ) ) { timedao . deletetime ( conn , t ) ; } activitydao . deleteactivity ( conn , activity ) ; activitydialog . setactivity ( null ) ; activitylistdialog . selectpreviousrow ( ) ; activitydialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deleteactivity()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deleteactivity()" , ex ) ; } } } else { alertmessages . noactivityselectedintablefordeleting ( activitylistdialog ) ; } }
va	1	@ beforemethod public void beforemethod ( ) { database = new database ( "first_db" ) ; coldefs = new linkedhashmap < > ( ) ; coldefs . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; coldefs . put ( "bar" , new columndefinition ( datatype . integer ) ) ; coldefs . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , coldefs ) ; database . add ( table ) ; parser = new parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executemodification ( ) ; }
va	1	@ override public string tostring ( ) { return "rolesetupinfo [config=" + config + "  getname()=" + getname ( ) + "  gettype()=" + gettype ( ) + "  isconfigstale()=" + isconfigstale ( ) + "  gethostref()=" + gethostref ( ) + "  getserviceref()=" + getserviceref ( ) + "  getrolestate()=" + getrolestate ( ) + "  gethealthsummary()=" + gethealthsummary ( ) + "  gethealthchecks()=" + gethealthchecks ( ) + "  gethastatus()=" + gethastatus ( ) + "  getroleurl()=" + getroleurl ( ) + "  tostring()=" + super . tostring ( ) + "  getclass()=" + getclass ( ) + "  hashcode()=" + hashcode ( ) + "]" ; }
va	1	@ override public void paint ( graphics canvas ) { clearcanvas ( canvas ) ; canvas . setcolor ( color . white ) ; canvas . drawline ( 100 , 100 , 600 , 600 ) ; color c = numbergenerator . getcolor ( ) ; canvas . setcolor ( c ) ; canvas . fillrect ( 200 , 200 , 100 , 200 ) ; canvas . setcolor ( color . red ) ; canvas . setfont ( new font ( "tahoma" , font . italic , 30 ) ) ; canvas . drawstring ( "hello world!" , 30 , 60 ) ; }
va	2	public static void main ( string [ ] args ) { final int [ ] coins = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; final int [ ] limits = new int [ coins . length ] ; for ( int i = 0 ; i < limits . length ; i ++ ) { limits [ i ] = target / coins [ i ] ; } final int [ ] counts = new int [ coins . length ] ; loop ( coins , limits , counts , 0 ) ; system . out . println ( "# count = " + count ) ; }
va	1	public static void main ( string [ ] args ) { userinfodto user = new userinfodto ( ) ; caretaker caretaker = new caretaker ( ) ; user . setaccount ( "zhangsan" ) ; user . setpassword ( "123456" ) ; user . settelno ( "13000000000" ) ; system . out . println ( "\u7528\u6237\u521b\u5efa\u5b8c\u6bd5\uff01" ) ; user . show ( ) ; caretaker . setmemento ( user . savememento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u4fdd\u5b58\u4e86\u7528\u6237\u7684\u5907\u5fd8\u5f55\uff01" ) ; user . setpassword ( "111111" ) ; user . settelno ( "13100001111" ) ; system . out . println ( "\u7528\u6237\u4fe1\u606f\u5df2\u7ecf\u66f4\u65b0\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; user . restorememento ( caretaker . getmemento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u6062\u590d\u4e86\u5907\u5fd8\u5f55\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; }
va	1	@ test public void testapplyleechseed ( ) { system . out . println ( "applying leech seed" ) ; activepokemon healer = new activepokemon ( species . abomasnow ) ; healer . sethpev ( 252 ) ; healer . setcurrhp ( 342 ) ; activepokemon seeded = new activepokemon ( species . absol ) ; seeded . sethpev ( 252 ) ; seeded . activateseeds ( ) ; assertequals ( healer . getcurrhp ( ) , 342 ) ; assertequals ( seeded . getcurrhp ( ) , 334 ) ; assertequals ( seeded . getmaxhp ( ) , 334 ) ; statusdamage . applyleechseed ( seeded , healer ) ; assertequals ( seeded . getcurrhp ( ) , 293 ) ; assertequals ( healer . getcurrhp ( ) , 383 ) ; }
va	5	private string [ ] getstringarray ( jcomponent comp ) { if ( comp instanceof jcombobox ) { jcombobox combobox = ( jcombobox ) comp ; list < string > list = new arraylist < string > ( ) ; if ( combobox . getitemcount ( ) > 0 ) { for ( int i = 0 ; i < combobox . getitemcount ( ) ; i ++ ) { if ( ! isempty ( combobox . getitemat ( i ) ) ) { add ( list , combobox . getitemat ( i ) ) ; } else if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toarray ( new string [ 1 ] ) ; } else { return null ; } } else { if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; return list . toarray ( new string [ 1 ] ) ; } } } return null ; }
va	3	@ override public string tostring ( ) { string a = "" ; string b ; if ( ! playerscoreminerals . keyset ( ) . equals ( playershiplocations . keyset ( ) ) ) { for ( string s : playerscoreminerals . keyset ( ) ) { system . out . println ( s ) ; } system . out . println ( "different from" ) ; for ( string s : playershiplocations . keyset ( ) ) { system . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( string k : playershiplocations . keyset ( ) ) { b = "" ; for ( boardlocation bl : playershiplocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerscoreminerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerscoreminerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
va	3	private void reversegraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { grapht . add ( new arraylist < integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { arraylist < integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; grapht . get ( vertex ) . add ( i ) ; } } }
va	3	@ override public void handleevent ( iparserevent event ) { if ( event . gettype ( ) == parsereventtype . document_end_event ) { flushevents ( ) ; event . fire ( listener ) ; } else { iparserevent lastevent = events . peeklast ( ) ; if ( lastevent != null && lastevent . gettype ( ) == parsereventtype . string_event && event . gettype ( ) == parsereventtype . string_event ) { event = mergestringevents ( ( stringevent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > max_events ) { events . removefirst ( ) . fire ( listener ) ; } } }
va	1	@ test public void testgetwordsfromunknownword ( ) { dataholder mytester = this . dataholderfactory ( ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word3 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cheek unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cross unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "deep unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "denticles unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word4 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "endocranium unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word5 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "lepidotrichia unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word1 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word2 unknown" . split ( " " ) ) ) ; set < string > target = new hashset < string > ( ) ; target . add ( "cheek" ) ; target . add ( "cross" ) ; target . add ( "deep" ) ; target . add ( "denticles" ) ; target . add ( "endocranium" ) ; target . add ( "lepidotrichia" ) ; string wordpattern = "((" + constant . plendings + "|ium)$)|(ee)" ; string flagpattern = "^unknown$" ; assertequals ( "getwordsfromunknownword" , target , mytester . getwordsfromunknownword ( wordpattern , true , flagpattern , true ) ) ; }
va	2	@ override public component gettablecellrenderercomponent ( jtable table , object value , boolean isselected , boolean hasfocus , int row , int column ) { final component c = super . gettablecellrenderercomponent ( table , value , isselected , hasfocus , row , column ) ; if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . high ) { c . setforeground ( color . white ) ; c . setbackground ( color . red ) ; } else if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . medium ) { c . setforeground ( color . black ) ; c . setbackground ( color . orange ) ; } else { c . setbackground ( color . green ) ; c . setforeground ( color . black ) ; } return c ; }
va	4	public paymentdialog ( member member , classtype ct , string message , int flag ) { messagetextarea . settext ( message ) ; globalmember = member ; globalclasstype = ct ; globalflag = flag ; makepaymentbutton = new jbutton ( "make payment" ) ; makepaymentbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { common . makepayment ( paymenttypelist . getselectedvalue ( ) , globalmember , ( date ) utildatemodel . getvalue ( ) , getpaymentamount ( ) ) ; updatepaymentstatus ( globalmember , globalclasstype ) ; dispose ( ) ; new paymentdialog ( globalmember , globalclasstype , "payment made for " + globalmember . getname ( ) + "\n of " + getpaymentamount ( ) + " for " + paymenttypelist . getselectedvalue ( ) . getpaymenttypename ( ) + "\n up to date: " + ( ( date ) utildatemodel . getvalue ( ) ) . tostring ( ) , globalflag ) ; } } ) ; makepaymentbutton . setenabled ( false ) ; exitbutton = new jbutton ( "exit" ) ; exitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { dispose ( ) ; if ( globalflag == 0 ) new membercheckininterface ( globalclasstype ) ; } } ) ; bufferedimage tkdicon = commonui . gettkdicon ( ) ; bufferedimage skyicon = commonui . getskyicon ( ) ; bufferedimage kickicon = commonui . getkickicon ( ) ; image img = null ; switch ( ct ) { case taekwondo : img = new imageicon ( tkdicon ) . getimage ( ) ; break ; case skyboxing : img = new imageicon ( skyicon ) . getimage ( ) ; break ; case kickboxing : img = new imageicon ( kickicon ) . getimage ( ) ; break ; case other : img = new imageicon ( tkdicon ) . getimage ( ) ; default : img = new imageicon ( tkdicon ) . getimage ( ) ; } seticonimage ( img ) ; this . settitle ( "enter payment for " + member . getname ( ) ) ; utildatemodel . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent arg0 ) { system . out . println ( "datemodel changed" ) ; setdateselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; panel . add ( paymenttopanel , borderlayout . center ) ; paymenttypelist . setlistdata ( common . getpaymenttypes ( ct ) . toarray ( new paymenttype [ 1 ] ) ) ; paymenttypelist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent arg0 ) { jlist < paymenttype > templist = ( jlist < paymenttype > ) arg0 . getsource ( ) ; paymenttype pt = templist . getselectedvalue ( ) ; paymentamounttextfield . settext ( string . format ( "%9.2f" , pt . getpaymentamount ( ) ) ) ; setpaymentamountfieldselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; listpanel . add ( paymenttypelist ) ; panel . add ( listpanel , borderlayout . west ) ; paymentamountpanel . add ( paymentamountlabel ) ; paymentamountpanel . add ( paymentamounttextfield ) ; buttonpanel . add ( paymentamountpanel , borderlayout . north ) ; buttonpanel . add ( makepaymentbutton , borderlayout . west ) ; buttonpanel . add ( exitbutton , borderlayout . south ) ; panel . add ( buttonpanel , borderlayout . south ) ; paymentstatuspanel . add ( paymentstatustextarea , borderlayout . north ) ; paymentstatuspanel . add ( messagetextarea , borderlayout . south ) ; updatepaymentstatus ( member , ct ) ; panel . add ( paymentstatuspanel , borderlayout . east ) ; this . getcontentpane ( ) . add ( panel ) ; this . setsize ( commonui . fullscreen ) ; this . setvisible ( true ) ; }
va	4	public string executerequest ( ) throws ioexception { setsigningmethod ( auth ) ; string signingstring = getsigningstring ( customer_id ) ; string signature ; string url_output = "" ; stringbuffer full_url = new stringbuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( string key : params . keyset ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( urlencoder . encode ( key , "utf-8" ) ) . append ( "=" ) . append ( urlencoder . encode ( params . get ( key ) , "utf-8" ) ) ; } } url = new url ( full_url . tostring ( ) ) ; try { signature = encode ( signingstring , secret_key ) ; } catch ( signatureexception e ) { system . err . println ( "error signing request " + e . getmessage ( ) ) ; return null ; } string auth_header = "tsa " + customer_id + ":" + signature ; connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setconnecttimeout ( connecttimeout ) ; connection . setreadtimeout ( readtimeout ) ; connection . setrequestproperty ( "authorization" , auth_header ) ; settlsprotocol ( ) ; if ( post ) { connection . setrequestproperty ( "content-length" , integer . tostring ( body . length ( ) ) ) ; } for ( string key : ts_headers . keyset ( ) ) { connection . setrequestproperty ( key , ts_headers . get ( key ) ) ; } for ( string key : headers . keyset ( ) ) { connection . setrequestproperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setdooutput ( true ) ; dataoutputstream wr = new dataoutputstream ( connection . getoutputstream ( ) ) ; wr . writebytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getresponsecode ( ) ; bufferedreader in ; try { inputstream isr = ( response == 200 ) ? connection . getinputstream ( ) : connection . geterrorstream ( ) ; in = new bufferedreader ( new inputstreamreader ( isr ) ) ; string urlreturn ; while ( ( urlreturn = in . readline ( ) ) != null ) { url_output += urlreturn ; } in . close ( ) ; } catch ( ioexception e ) { system . err . println ( "ioexception while reading from input stream " + e . getmessage ( ) ) ; throw new runtimeexception ( e ) ; } return url_output ; }
va	5	public boolean testrule ( wff ext , wff _world , defaultrule d ) { wff prec = new wff ( d . getprerequisite ( ) ) ; wff world = new wff ( _world . getformula ( ) + " & " + ext . getformula ( ) ) ; if ( world . entails ( prec ) ) { wff just = new wff ( d . getjustificatoin ( ) ) ; if ( just . eval ( ext ) ) { wff cons = new wff ( d . getconsequence ( ) ) ; if ( ext . isconsistent ( cons . getformula ( ) ) ) { if ( ext . entails ( cons ) ) { return true ; } } } } else { } return false ; }
va	4	@ override public void actionperformed ( actionevent ae ) { if ( ae . getactioncommand ( ) . compareto ( "comboboxchanged" ) == 0 ) { if ( ae . getsource ( ) == combo_url ) { loadurldata ( ) ; } else if ( ae . getsource ( ) == combo_granttype ) { if ( combo_granttype . getselectedindex ( ) == authorization_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . authorization_grant ) ; setuppanels ( ) ; } else if ( combo_granttype . getselectedindex ( ) == password_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . pasword_grant ) ; setuppanels ( ) ; } else if ( combo_granttype . getselectedindex ( ) == client_grant_index ) { oauthpropertybean . getinstance ( ) . setgranttype ( oauthpropertybean . client_credentials_grant ) ; setuppanels ( ) ; } } } else if ( ae . getactioncommand ( ) . compareto ( about_menuitem ) == 0 ) { joptionpane . showmessagedialog ( applicationframe , "oauthtestclient\nan oauth 2.0 test application\nwritten by ronnie mitra.\n\nhttps://github.com/mitraman/oauthtestclient    \n\n" , "about oauthtestclient" , joptionpane . question_message ) ; } else if ( ae . getactioncommand ( ) . compareto ( settings_menuitem ) == 0 ) { settingsdialog settingsdialog = new settingsdialog ( applicationframe ) ; settingsdialog . setvisible ( true ) ; } else if ( ae . getactioncommand ( ) . compareto ( save_config_menuitem ) == 0 ) { jfilechooser filechooser = new jfilechooser ( "./oauthtestclient.cfg" ) ; if ( filechooser . showsavedialog ( this ) == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; configmanager . saveproperties ( file ) ; } } else if ( ae . getactioncommand ( ) . compareto ( load_config_menuitem ) == 0 ) { jfilechooser filechooser = new jfilechooser ( ) ; if ( filechooser . showopendialog ( this ) == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; configmanager . loadproperties ( file ) ; } } else { system . out . println ( ae . getactioncommand ( ) + " " + ae . getid ( ) ) ; } }
va	5	public boolean act ( agent agent , action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateviews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { simulatedagent a = ( simulatedagent ) agent ; int x = ( ( integer ) a . getattribute ( x ) ) . intvalue ( ) ; int y = ( ( integer ) a . getattribute ( y ) ) . intvalue ( ) ; percept p = sense ( a ) ; string msg = null ; string act = action . getcode ( ) ; int actionid = language . getactionindex ( act ) ; switch ( actionid ) { case 4 : if ( ( ( boolean ) p . getattribute ( language . getpercept ( 5 ) ) ) . booleanvalue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { system . out . println ( "eating good food..." ) ; energy_level = math . min ( energy_level + inc_energy_level , max_energy_level ) ; } else { system . out . println ( "eating bad food..." ) ; energy_level = math . max ( energy_level - dec_energy_level , 0 ) ; } } else { msg = simpleview . error + "[there is not food. eat action not executed]" ; } updateviews ( msg ) ; break ; default : if ( actionid == 2 ) { energy_level -- ; system . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
va	3	public void testfilecontent ( ) throws ioexception { long start = system . currenttimemillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; string filename1 = "test1.class" ; string filename2 = "test2.class" ; file file1 = new file ( filename1 ) ; file file2 = new file ( filename2 ) ; bufferedinputstream bis1 = new bufferedinputstream ( new fileinputstream ( file1 ) ) ; bufferedinputstream bis2 = new bufferedinputstream ( new fileinputstream ( file2 ) ) ; polynomial polynomial = polynomial . createirreducible ( 53 ) ; fingerprint < polynomial > rabin1 = new rabinfingerprintlong ( polynomial ) ; fingerprint < polynomial > rabin2 = new rabinfingerprintlong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushbytes ( buf1 ) ; rabin2 . pushbytes ( buf2 ) ; string s1 = new string ( buf1 ) ; string s2 = new string ( buf2 ) ; if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) != 0 ) { system . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) == 0 ) system . out . println ( "file 1 and file 2 are the same!" ) ; long end = system . currenttimemillis ( ) ; system . out . println ( "time: " + ( end - start ) + "ms." ) ; assertequals ( 0 , rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) ) ; }
va	1	private viability initiateviability ( file habitatfolder ) throws ioexception , interruptedexception { file viabilitycsv = new file ( habitatfolder . getpath ( ) + file . separatorchar + viability ) ; if ( ! viabilitycsv . exists ( ) || ! viabilitycsv . isfile ( ) ) throw new filedoesntexist ( habitatfolder . getpath ( ) + file . separatorchar + viability , "but file with parameters of viability is strongly required" ) ; string filecontent = getfullfilecontent ( viabilitycsv ) ; string preparedcontent = preparer . getpreparedcontent ( filecontent , viabilityreader . input_area ) ; saver . saveforcurrentpoint ( habitatfolder . getname ( ) , viability , preparedcontent ) ; return new viabilityreader ( preparedcontent ) . getviability ( ) ; }
va	4	private void generaterandombreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomnumber ( 0 , 1 ) == 1 ) { this . addbreakable ( i , 11 ) ; } } }
va	5	@ override public void run ( ) { while ( true ) { try { for ( blocklocationpair p : deletionqueue ) { string nodelocation = p . nodelocation ; string blockname = p . blockname ; string [ ] ipport ; try { ipport = addresstoipport . addresstoipport ( nodelocation ) ; message inputmessage = new message ( "remove" ) ; inputmessage . filename = blockname ; communicator . sendmessage ( ipport [ 0 ] , integer . parseint ( ipport [ 1 ] ) , inputmessage ) ; } catch ( numberformatexception | ioexception e ) { e . printstacktrace ( ) ; throw new ioexception ( "could not delete distributed file block " + blockname + "\n " + e . getmessage ( ) ) ; } } } catch ( exception e ) { logger . log ( "error encountered while deleting distributed file: " + e . getmessage ( ) ) ; e . printstacktrace ( ) ; } try { thread . sleep ( 3000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
va	4	public static void main ( string [ ] args ) { int k = 0 ; try { k = integer . parseint ( args [ 0 ] ) ; } catch ( numberformatexception e ) { system . out . println ( "expected an argument with the number of elements to print." ) ; system . out . println ( "usage: subset k - to print k values from the input." ) ; system . out . println ( "example: echo a b c d e f g h i | java subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; randomizedqueue < string > rq = new randomizedqueue < string > ( ) ; while ( ! stdin . isempty ( ) ) { string s = stdin . readstring ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = stdrandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isempty ( ) ; i ++ ) { system . out . println ( rq . dequeue ( ) ) ; } }
va	3	public void refreshtextlist ( ) { ground . remove ( textpane ) ; textpane = null ; resultsets = connector . getallresultsets ( userid ) ; iterator < ? > result = resultsets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasnext ( ) ) { resultset temp_res = ( resultset ) result . next ( ) ; resultmapper . put ( temp_res . getdocument ( ) . getfilename ( ) , ( resultset ) temp_res ) ; dataname . addelement ( temp_res . getdocument ( ) . getfilename ( ) ) ; } textpane = new jscrollpane ( texte ) ; textpane . setlocation ( 280 , 50 ) ; textpane . setsize ( 180 , 300 ) ; textpane . setvisible ( true ) ; texte . setvisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
va	1	@ test public void testregisterandauth ( ) throws exception { messagesystem . sendmessage ( new msgregister ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; messagesystem . sendmessage ( new msglogin ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; when ( request . getpathinfo ( ) ) . thenreturn ( pages . main_page ) ; frontend . doget ( request , response ) ; assert . asserttrue ( stringwriter . tostring ( ) . contains ( user ) ) ; assert . assertfalse ( stringwriter . tostring ( ) . contains ( "anonymous" ) ) ; accountservice . delete ( user ) ; }
va	1	@ test public void testgetmodifierandtagforcase2 ( ) { posbasedannotator mytester = this . markupbyposfactory ( ) ; string modifier = "large interlocking" ; int start = 2 ; int end = 3 ; list < string > words = new arraylist < string > ( ) ; words . addall ( arrays . aslist ( "large interlocking <n>plates</n> <b>with</b> pronounced crescentic <n>margins</n>" . split ( " " ) ) ) ; list < string > target = new linkedlist < string > ( ) ; target . add ( "large interlocking" ) ; target . add ( "<n>plates</n>" ) ; assertequals ( "getmodifierandtagforcase1" , target , mytester . getmodifierandtagforcase2 ( modifier , start , end , words ) ) ; }
va	4	public static string readasstring ( file file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; inputstream is = null ; try { is = new fileinputstream ( file ) ; is . read ( bytes ) ; } catch ( ioexception e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( ioexception ex ) { return null ; } } try { return new string ( bytes , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return null ; } }
va	1	public static void debug ( connection con ) throws exception { system . out . println ( "\ndump of table geoloc:" ) ; statement stmt = con . createstatement ( ) ; resultset rs = stmt . executequery ( "select geohash  subject  predicate  lat_lon_object  lat  lon from geoloc" ) ; while ( rs . next ( ) ) system . out . println ( "geoloc row: " + rs . getstring ( "geohash" ) + " " + rs . getstring ( "subject" ) + " " + rs . getstring ( "predicate" ) + " " + rs . getstring ( "lat_lon_object" ) + " " + rs . getfloat ( "lat" ) + " " + rs . getfloat ( "lon" ) ) ; system . out . println ( ) ; system . out . println ( "\ndump of table free text predicates:" ) ; stmt = con . createstatement ( ) ; rs = stmt . executequery ( "select predicate from free_text_predicates" ) ; while ( rs . next ( ) ) system . out . println ( "free_text_predicates row: " + rs . getstring ( "predicate" ) ) ; system . out . println ( ) ; }
va	5	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
va	5	@ override public void run ( ) { player [ ] players = plugin . getserver ( ) . getonlineplayers ( ) ; player player ; long configtime = plugin . getconfig ( ) . getint ( "kick_timer" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastmoved = 0 ; player = players [ i ] ; usertable ut = plugin . getdatabase ( ) . find ( usertable . class ) . where ( ) . ieq ( "username" , player . getname ( ) ) . = ( "afk" , true ) . findunique ( ) ; if ( ut == null ) { return ; } lastmoved = system . currenttimemillis ( ) - ut . getafktime ( ) ; if ( player . isop ( ) ) { if ( plugin . getconfig ( ) . getboolean ( "kick_op" ) ) { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } else { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } }
va	4	private static void savesystemstate ( string filename ) { string out = getparametervaluelist ( ) + "\n" ; out += "changed per state \n" ; out += "\t mayority \t confidence \t weight \t missfire \n" ; if ( systemstatechangeds != null ) { for ( string systemtesttype : systemstatechangeds . keyset ( ) ) { for ( string meth : systemstatechangeds . get ( systemtesttype ) . keyset ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( string systemtesttype : systemstatechangeds . keyset ( ) ) { for ( string meth : systemstatechangeds . get ( systemtesttype ) . keyset ( ) ) { out += systemstatechangeds . get ( systemtesttype ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t mayority \t confidence \t weight \t missfire \n" ; if ( lastsystemtestpoints != null ) for ( string s : lastsystemtestpoints . keyset ( ) ) { out += "\t" + s + "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "mayority" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "confidence" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "weight" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\t" ; out += ( string . format ( "%.3f" , ( lastsystemtestscore . get ( s ) . get ( "missfire" ) / lastsystemtestpoints . get ( s ) ) ) ) ; out += "\n" ; } file f = new file ( filename ) ; try { if ( ! f . getparentfile ( ) . exists ( ) ) f . getparentfile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createnewfile ( ) ; filewriter w = new filewriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( sciencetool . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	4	protected static void addobject ( iunknown o ) { if ( apartmentinitialized . get ( ) == false ) { comthread . initsta ( false ) ; apartmentinitialized . set ( true ) ; } if ( ! auto_gc ) return ; referencequeue < iunknown > deadobjects = deadpool . get ( ) ; objects . put ( new pointerweakreference ( o , deadobjects ) , false ) ; if ( gc_count != - 1 && ( count % gc_count ) == 0 ) { system . gc ( ) ; } if ( ( count ++ % cull_count ) == 0 ) { int numberculled = culldeadpool ( deadobjects , objects ) ; if ( iunknown . isdebugenabled ( ) ) { if ( numberculled > 0 ) { iunknown . debug ( "rot: added instance of " + o . getclass ( ) . getsimplename ( ) + "->[+1  -" + numberculled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
va	1	public actiondialog ( skyquestutility util , jcomponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new jbutton ( "save" ) ; cancel = new jbutton ( "cancel" ) ; amodel = new defaultlistmodel < actiontype > ( ) ; atypes = new jlist < actiontype > ( amodel ) ; for ( actiontype a : questmanager . getinstance ( ) . getregisteredactiontypes ( ) ) amodel . addelement ( a ) ; setlayout ( new borderlayout ( ) ) ; jpanel buttons = new jpanel ( ) ; buttons . setlayout ( new boxlayout ( buttons , boxlayout . x_axis ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; jpanel ap = new jpanel ( ) ; ap . setlayout ( new borderlayout ( ) ) ; ap . add ( "center" , atypes ) ; ap . add ( "north" , new jlabel ( "type" ) ) ; add ( "south" , buttons ) ; cancel . addactionlistener ( this ) ; save . addactionlistener ( this ) ; }
te	2	void updatestep6 ( ) { double totalbudget = lg . getbudget ( ) ; double totalexpenses = lg . gethotelbudgetspent ( ) + lg . getexpensespent ( ) ; double remainingbudget = totalbudget - totalexpenses ; textpane6_totalbudget . settext ( string . valueof ( "$" + totalbudget ) ) ; textpane6_spent . settext ( string . valueof ( "$" + totalexpenses ) ) ; textpane6_remaining . settext ( string . valueof ( "$" + remainingbudget ) ) ; if ( lg . getguestlist ( ) . size ( ) != 0 ) { lg . setcostperhead ( ) ; decimalformat df = new decimalformat ( "0.00" ) ; df . setgroupingused ( false ) ; double costperhead = lg . getcostperhead ( ) ; string costperheadstr = df . format ( costperhead ) ; textpane6_costperhead . settext ( string . valueof ( "$" + costperheadstr ) ) ; } if ( lg . completedexpensefields ( ) ) chckbx6_expensesfinalised . setenabled ( true ) ; chckbx6_expensesfinalised . setselected ( lg . getexpensefinalised ( ) ) ; panel6 . remove ( scrollpane6 ) ; createtable6 ( lg . getexpenselist ( ) , expensescols ) ; }
te	2	public synchronized void tick ( ) { handleevents ( ) ; updateworkers ( ) ; for ( sponsor sponsor : new arraylist < sponsor > ( sponsors ) ) { if ( sponsor . getmsleft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } random r = new random ( ) ; if ( sponsors . size ( ) < max_sponsors && r . nextint ( ( int ) ( 1500 / math . log ( getrenown ( ) + 2 ) ) ) == 0 ) { addsponsor ( ) ; } if ( getrenown ( ) <= 0 ) { showwindow ( null , new gameoverwindow ( ) ) ; } if ( r . nextint ( difficulty ) == 0 ) { setrenown ( getrenown ( ) - 1 ) ; } if ( firsttick ) showwindow ( null , new helpwindow ( ) ) ; firsttick = false ; }
te	1	public hoge ( lr lr , shootingweaponcharacter weapon ) { setweapon ( weapon ) ; setx ( commons . center_x + ( 165 * lr . signum ( ) ) ) ; sety ( 40 ) ; weaponview . setx ( getx ( ) ) . sety ( gety ( ) + 5 ) . setwidth ( weapon . getwidth ( ) ) . setheight ( weapon . getheight ( ) ) . setscale ( 2 ) . setcolor ( weapon . getcolor ( ) ) ; remainbulletview . setx ( getx ( ) ) . sety ( gety ( ) - 25 ) . setscale ( 0.3f ) . setcolor ( color . white ) ; }
te	5	public static void main ( string argv [ ] ) { bus busses [ ] = null ; host host ; try { host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usb is unavailable  can't run." ) ; return ; } system . out . println ( "<!-- " + host + " -->" ) ; busses = host . getbusses ( ) ; indentline ( 0 , "<host busses='" + busses . length + "'>" ) ; for ( int busno = 0 ; busno < busses . length ; busno ++ ) { indentline ( 2 , "<!-- bus #" + ( busno + 1 ) + " -->" ) ; if ( busses [ busno ] != null ) { try { printdevice ( 2 , busses [ busno ] . getroothub ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } indentline ( 0 , "</host>" ) ; } catch ( securityexception e ) { system . err . println ( "usb permissions problem:" ) ; system . err . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	1	public int print ( graphics graphics , pageformat pageformat , int pageindex ) throws printerexception { if ( pageindex >= 1 ) return printable . no_such_page ; graphics2d g2d = ( graphics2d ) graphics ; double h = pageformat . getimageableheight ( ) ; double w = pageformat . getimageablewidth ( ) ; double x = pageformat . getimageablex ( ) ; double y = pageformat . getimageabley ( ) ; system . out . println ( "pf:" + x + " " + y + " " + w + " " + h ) ; g2d . translate ( x , y ) ; dimension size = new dimension ( ( int ) w , ( int ) h ) ; paintit ( g2d , size ) ; return printable . page_exists ; }
te	4	private void dotransfer ( ) throws ioexception { if ( ressourceinputstream == null ) { if ( sendheaderinrsp ) { string header = new filerequestresponsemessage ( responsecode . never_try_again , 0 ) . serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkoutputstream . write ( header . getbytes ( ) ) ; } networkoutputstream . close ( ) ; return ; } else { if ( offset > numavailabledata ) { logger . log ( level . info , "requested offset is not valid: requested " + offset + "  length of file: " + numavailabledata ) ; if ( sendheaderinrsp ) networkoutputstream . write ( new filerequestresponsemessage ( responsecode . ok , 0 ) . serialize ( ) . getbytes ( ) ) ; networkoutputstream . close ( ) ; transferstate = transferstatus . finished ; return ; } if ( offset + expectedtransfervolume > numavailabledata ) { logger . log ( level . info , "requested length of " + expectedtransfervolume + " was too large  shortened  it to " + expectedtransfervolume ) ; expectedtransfervolume = numavailabledata - offset ; } transferstate = transferstatus . transfering ; if ( sendheaderinrsp ) networkoutputstream . write ( ( new filerequestresponsemessage ( responsecode . ok , expectedtransfervolume ) . serialize ( ) ) . getbytes ( message . encoding ) ) ; if ( buffersize == - 1 ) { buffersize = fallback_buffer_size ; logger . log ( level . info , "using fallback buffersize " + buffersize ) ; } logger . info ( "sending data" ) ; ressourceinputstream . skip ( offset ) ; int bytesread = 0 ; int bytestoread = buffersize ; byte [ ] buffer = new byte [ buffersize ] ; while ( bytestoread > 0 && keeptransferalive && totaltransferedvolume < expectedtransfervolume && ( bytesread = ressourceinputstream . read ( buffer , 0 , bytestoread ) ) != - 1 ) { networkoutputstream . write ( buffer , 0 , bytesread ) ; totaltransferedvolume += bytesread ; if ( totaltransferedvolume + bytestoread > expectedtransfervolume ) { bytestoread = ( int ) ( expectedtransfervolume - totaltransferedvolume ) ; } } networkoutputstream . flush ( ) ; networkoutputstream . close ( ) ; ressourceinputstream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totaltransferedvolume == expectedtransfervolume ) transferstate = transferstatus . finished ; else { if ( ! keeptransferalive ) transferstate = transferstatus . canceled ; else transferstate = transferstatus . lostconnection ; } } }
te	2	@ override public void paintcomponent ( graphics g ) { g . setcolor ( def_background_colour ) ; g . fillrect ( 0 , 0 , util . image_size , util . image_size ) ; graphics2d g2d = ( graphics2d ) g ; if ( image != null ) { g2d . drawimage ( image , 0 , 0 , util . image_size , util . image_size , 0 , 0 , util . image_size , util . image_size , null ) ; } if ( gridvisible ) { drawgrid ( g ) ; } g2d . drawimage ( selector , selectorlocation . x , selectorlocation . y , selectorlocation . x + util . grid_sections , selectorlocation . y + util . grid_sections , 0 , 0 , util . grid_sections , util . grid_sections , null ) ; }
te	1	public static void main ( string [ ] args ) { double mass , height , bmi ; mass = double . parsedouble ( args [ 0 ] ) ; height = double . parsedouble ( args [ 1 ] ) ; bmi = mass / math . pow ( height , 2 ) ; if ( bmi < 18.5 ) system . out . println ( "underweight" ) ; else if ( bmi < 25 ) system . out . println ( "normal weight" ) ; else if ( bmi < 30 ) system . out . println ( "overweight" ) ; else system . out . println ( "obses" ) ; }
te	2	@ override public void actionperformed ( actionevent event ) { string eventname = event . getactioncommand ( ) ; system . out . println ( "event:" + eventname ) ; switch ( eventname ) { case "comboboxchanged" : string prefname = sysadminui . getpreferencelistboxselection ( ) ; string value = systemprefs . get ( prefname ) . tostring ( ) ; sysadminui . setpreferencefield ( value ) ; break ; case "set preference" : string preference = sysadminui . getpreferencelistboxselection ( ) ; string valuefield = sysadminui . getpreferencefield ( ) ; systemprefs . put ( preference , valuefield ) ; setchanged ( ) ; notifyobservers ( ) ; break ; } }
te	1	public graphpaper3d ( double width , double height , double depth ) { super ( new body ( ) , width , height ) ; this . m_root = ( body ) this . getroot ( ) ; this . m_system = new body ( ) ; this . m_root . addcomponent ( this . m_system ) ; this . m_width = width ; this . m_height = height ; this . m_depth = depth ; this . setfill ( color . grey ) ; calculatepixeltocartesianconvertdata ( ) ; setuplisteners ( ) ; drawgraphinformation ( ) ; drawaxes ( ) ; setupcamera ( ) ; }
te	1	private void elementosposicionanormal ( ) { this . jlabel2 . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 60 ) ; this . txtcorreo . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 80 ) ; this . btnbuscar . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . btnbuscar . getwidth ( ) / 2 ) + 115 , 77 ) ; }
te	5	public listnode partition ( listnode head , int x ) { listnode p1 = null , p2 = head , p2prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2prev ) { p1 = p2 ; p2 = p2 . next ; p2prev = p1 ; } else { p2prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2prev . next ; } } else { p2prev = p2 ; p2 = p2 . next ; } } return head ; }
te	3	public static void main ( string [ ] args ) throws interruptedexception { final thread t1 = new thread ( ) { public void run ( ) { logger . info ( "t1 start wait" ) ; locksupport . park ( ) ; logger . info ( "t1 get signal" ) ; } } ; thread t2 = new thread ( ) { public void run ( ) { logger . info ( "t2 start signal" ) ; locksupport . unpark ( t1 ) ; logger . info ( "t2 end" ) ; } } ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; }
te	2	public void addnewelementstohac ( arraylist < commententityds > necommentdsarray , string articleid ) throws exception { docfactory documentfactory = new docfactory ( ) ; docdo document = documentfactory . get ( articleid ) ; arraylist < mapcell > mappingarray = databaseoperations . getarticlemapping ( articleid ) ; arrayofcommentsfactory commentsarrayfactory = new arrayofcommentsfactory ( ) ; arrayofcommentsdo arrayofcommentsdo = null ; arrayofcommentsdo = commentsarrayfactory . get ( articleid ) ; arraylist < comment > nearray = comment . convertcommentsdstocommentsarraylist ( necommentdsarray ) ; double [ ] vector = new double [ databaseoperations . getwordscountforarticle ( articleid ) + 1 ] ; for ( comment ne : nearray ) { comment . nomalizecommentvector ( ne ) ; addnewelementtohac ( ne , articleid , vector , document , mappingarray , arrayofcommentsdo . arrayofcomment ) ; arrayofcommentsdo . arrayofcomment . add ( ne ) ; commentsarrayfactory . save ( arrayofcommentsdo ) ; } domimplementationls domimplementation = ( domimplementationls ) document . doc . getimplementation ( ) ; databaseoperations . setxmlrepresentation ( articleid , domimplementation . createlsserializer ( ) . writetostring ( document . doc ) ) ; databaseoperations . setarticlemapping ( articleid , mappingarray ) ; documentfactory . save ( document ) ; databaseoperations . setcomments ( articleid , necommentdsarray ) ; }
te	2	@ override public void process ( ) { string [ ] s = curdir . list ( strings . getstringfilter ( ) . getfilenamefilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { string x = strings . substitute ( s [ i ] ) ; string t = s [ i ] + " => " + x ; if ( ! ispreview ) t += new file ( curdir , s [ i ] ) . renameto ( new file ( curdir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; print . ln ( t ) ; } print . ln ( "total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
te	3	public int [ ] likertjakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
te	3	public static void main ( string [ ] args ) { try { = ( 0 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "ba" } ) , 2 ) ; = ( 1 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "ab" , "bcd" , "efg" } ) , 0 ) ; = ( 2 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "bba" , "abb" } ) , 7 ) ; = ( 3 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "aabccc" , "ccbbca" , "a" , "acaabb" , "aaa" , "aab" , "c" , "babb" , "aacaa" , "b" } ) , 47 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
te	3	public static object getdummyobject ( class cls ) { object obj = null ; try { constructor < ? > ctor = cls . getdeclaredconstructor ( ) ; reflector . ensureisaccessible ( ctor ) ; obj = ctor . newinstance ( ) ; } catch ( nosuchmethodexception e1 ) { final constructor < ? > ctor = cls . getconstructors ( ) [ 0 ] ; class [ ] paramtypes = ctor . getparametertypes ( ) ; list < object > params = new arraylist < object > ( ) ; for ( class paramtype : paramtypes ) params . add ( paramtype . isprimitive ( ) ? gettypedefaultvalue ( paramtype . getname ( ) ) : null ) ; try { obj = ctor . newinstance ( params . toarray ( ) ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; } } catch ( securityexception e1 ) { e1 . printstacktrace ( ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; } finally { return obj ; } }
te	2	public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . out . println ( "argument error." ) ; system . out . println ( "using method: java -xmx2048m -jar prince.jar ./input/config.txt" ) ; system . exit ( - 1 ) ; } inputargument input = new inputargument ( args [ 0 ] ) ; princecrossvalidation validation = new princecrossvalidation ( input . getppifilepath ( ) , input . getdiseasesimilarityfilepath ( ) , input . getgenediseaseassociationfilepath ( ) , input . getdiseasefilepath ( ) , input . getoutputdir ( ) ) ; system . out . println ( "prince validation starting..." ) ; validation . batch_run ( ) ; system . out . println ( "prince validation finished..." ) ; }
te	2	public void testlineserieschart ( ) { lineserieschart < number , number > chart = new lineserieschart < number , number > ( "curves" , "x" , "y" ) ; collection < lineseriesitem < number , number >> linhasin = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhasin . add ( new lineseriesitem < number , number > ( i , math . sin ( i ) + 4 ) ) ; } chart . addvalue ( linhasin ) ; collection < lineseriesitem < number , number >> linhacos = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhacos . add ( new lineseriesitem < number , number > ( i , math . cos ( i ) ) ) ; } chart . addvalue ( linhacos ) ; collection < lineseriesitem < number , number >> linhaexp = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaexp . add ( new lineseriesitem < number , number > ( i , math . exp ( i ) + 1 ) ) ; } chart . addvalue ( linhaexp ) ; collection < lineseriesitem < number , number >> linhareta = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhareta . add ( new lineseriesitem < number , number > ( i , i ) ) ; } chart . addvalue ( linhareta ) ; highlighter highlighter = criarhighlighter ( ) ; chart . getchartconfiguration ( ) . sethighlighter ( highlighter ) ; chart . addserie ( criarserie ( "seno" , "#489104" ) ) ; chart . addserie ( criarserie ( "coseno" , "#c91212" ) ) ; chart . addserie ( criarserie ( "exponensial" , "#7d02b2" ) ) ; chart . addserie ( criarserie ( "reta" , "#066fa7" ) ) ; legend legend = new legend ( true , location . ne ) ; legend . setplacement ( "outsidegrid" ) ; chart . setlegend ( legend ) ; axis < string > axis = new axisstring ( ) ; axis . setlabelrenderer ( jqplotresources . canvasaxislabelrenderer ) ; chart . setaxesdefaults ( axis ) ; axes axes = chart . getaxes ( ) ; xaxis xaxis = axes . getxaxis ( ) ; tickoptions tickoptions = new tickoptions ( ) ; tickoptions . setangle ( 270 ) ; tickoptions . setlabelposition ( "end" ) ; xaxis . settickoptions ( tickoptions ) ; xaxis . settickrenderer ( jqplotresources . canvasaxistickrenderer ) ; xaxis . settickinterval ( 1 ) ; axes . getyaxis ( ) . settickinterval ( 0.50 ) ; axes . getyaxis ( ) . setmax ( 8.50 ) ; axes . getyaxis ( ) . setmin ( - 1.50 ) ; tickoptions tickoptionsy = new tickoptions ( ) ; tickoptionsy . setformatstring ( "%.2f" ) ; axes . getyaxis ( ) . settickoptions ( tickoptionsy ) ; grid grid = new grid ( ) ; grid . setbackground ( "#ffffff" ) ; grid . setgridlinecoler ( "#a0a0a0" ) ; chart . getchartconfiguration ( ) . setgrid ( grid ) ; cursor cursor = new cursor ( ) ; cursor . setzoom ( true ) ; cursor . setclickreset ( true ) ; chart . getchartconfiguration ( ) . setcursor ( cursor ) ; string json = jqplotutils . createjquery ( chart , "div3" ) ; json = json . replaceall ( "\\$" , "jquery" ) ; system . out . println ( json ) ; }
te	2	@ override public void newentry ( sourcetextentry active_entry ) { if ( current_file_node != null && active_entry != null ) { last_edited_text = core . geteditor ( ) . getcurrenttranslation ( ) ; caretupdates_to_ignore = 1 ; sessionlog . getmenu ( ) . setpausetimestamp ( 0 ) ; sessionlog . getmenu ( ) . getpausetiming ( ) . setselected ( false ) ; element element = newelement ( "segment" , true ) ; element . setattribute ( "number" , integer . tostring ( core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ) ) ; element source_element = newelement ( "source" , false ) ; source_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrententry ( ) . getsrctext ( ) ) ) ; element . appendchild ( source_element ) ; element target_element = newelement ( "initialtarget" , false ) ; target_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrenttranslation ( ) ) ) ; element . appendchild ( target_element ) ; current_entry_node = element ; current_file_node . appendchild ( current_entry_node ) ; current_editions_node = newelement ( "events" , false ) ; chosen_entry_time = system . nanotime ( ) ; current_segment_number = core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ; } }
te	3	public void publishmessage ( ) throws namingexception , jmsexception { system . out . println ( "publishing message..." ) ; try ( topicconnection topicconnection = topicconnfactory . createtopicconnection ( ) ; topicsession topicsession = topicconnection . createtopicsession ( false , topicsession . auto_acknowledge ) ; ) { topic createdtopic = topicsession . createtopic ( "javaee" ) ; topicconnection . start ( ) ; textmessage textmessage = topicsession . createtextmessage ( "this is a test message" ) ; try ( javax . jms . topicpublisher topicpublisher = topicsession . createpublisher ( createdtopic ) ) { topicpublisher . publish ( textmessage ) ; setmessage ( "message published" ) ; } } }
te	1	public void testiscornerfield ( ) { begintest ( "iscornerfield method" ) ; boolean result ; result = board . iscornerfield ( new coordinate ( 0 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(0  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 0 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(0  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(7  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(7  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 3 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(3  7)" , false , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 8 ) ) ; assertequals ( "iscornerfield(new coordinate(7  8)" , false , result ) ; }
te	5	public string format ( logrecord r ) { stringbuffer sb = new stringbuffer ( ) ; sb . append ( r . getlevel ( ) . getname ( ) + "\t" ) ; sb . append ( messageformat . format ( "{0  date  yy-mm-dd} {0  time  kk:mm:ss.ssss} " , new object [ ] { new date ( r . getmillis ( ) ) } ) + "\t" ) ; string cnm = r . getsourceclassname ( ) ; string cn = "" ; if ( cnm != null ) { int cnl = cnm . length ( ) ; if ( cnl > 20 ) { cn = r . getsourceclassname ( ) . substring ( cnl - 19 ) ; } else { char sp [ ] = {   } ; stringbuffer sb1 = new stringbuffer ( ) . append ( cnm ) ; cn = sb1 . append ( sp , 0 , 1 ) . tostring ( ) ; } } sb . append ( cn + "\t" ) . append ( " " ) ; sb . append ( left ( r . getsourcemethodname ( ) , 23 ,   ) + "\t" ) ; sb . append ( r . getthreadid ( ) + "\t" ) ; sb . append ( formatmessage ( r ) ) . append ( ls ) ; if ( null != r . getthrown ( ) ) { sb . append ( "throwable occurred: " ) ; throwable t = r . getthrown ( ) ; printwriter pw = null ; try { stringwriter sw = new stringwriter ( ) ; pw = new printwriter ( sw ) ; t . printstacktrace ( pw ) ; sb . append ( sw . tostring ( ) ) ; } finally { if ( pw != null ) { try { pw . close ( ) ; } catch ( exception e ) { } } } } return sb . tostring ( ) ; }
te	4	public void actionperformed ( actionevent e ) { string login = principal . getlogin ( ) ; string senha = principal . getsenha ( ) ; logininterface logininterface = new logininterface ( ) ; funcionario funcionario = null ; try { funcionario = logininterface . logarusuario ( login , senha ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } string respostausuario = "" ; if ( funcionario != null ) { if ( funcionario . getnivelacesso ( ) ) { try { usuariologado usuariologado = usuariologado . getinstancia ( ) ; usuariologado . setusuariologado ( funcionario ) ; operacaolog log = new operacaolog ( ) ; log . setdata ( new timestamp ( system . currenttimemillis ( ) ) ) ; log . setdescricao ( "logon de administrador: " + funcionario . getnome ( ) ) ; log . setfuncionario ( usuariologado . getinstancia ( ) . getusuariologado ( ) ) ; log . setoperacao ( "logon de administrador" ) ; operacaologdao operacaologdao = new operacaologdao ( ) ; operacaologdao . persiste ( log ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } principal . dispose ( ) ; administrador . main ( null ) ; } else { respostausuario = "erro  acesso n\u00e3o permitido!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } } else { respostausuario = "erro  credenciais inv\u00e1lidas!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } e . getactioncommand ( ) ; }
te	3	public ratelimitstatus ( response res ) throws weiboexception { super ( res ) ; jsonobject json = res . asjsonobject ( ) ; try { jsonarray list = json . getjsonarray ( "api_rate_limits" ) ; int size = list . length ( ) ; apiratelimit = new arraylist < apiratelimits > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { apiratelimit . add ( new apiratelimits ( list . getjsonobject ( i ) ) ) ; } iplimit = json . getint ( "ip_limit" ) ; remainingiphits = json . getint ( "remaining_ip_hits" ) ; remaininguserhits = json . getlong ( "remaining_user_hits" ) ; resettime = json . getstring ( "reset_time" ) ; resettimeinseconds = json . getint ( "reset_time_in_seconds" ) ; userlimit = json . getlong ( "user_limit" ) ; } catch ( jsonexception jsone ) { throw new weiboexception ( jsone . getmessage ( ) + ":" + json . tostring ( ) , jsone ) ; } }
te	2	public static string replaceall ( string origin , string oldpart , string replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldpart == null || oldpart . length ( ) == 0 ) { return origin ; } int index = origin . indexof ( oldpart ) ; if ( index < 0 ) { return origin ; } stringbuffer sb = new stringbuffer ( origin ) ; do { sb . replace ( index , index + oldpart . length ( ) , replacement ) ; origin = sb . tostring ( ) ; index = origin . indexof ( oldpart ) ; } while ( index != - 1 ) ; return origin ; }
te	5	public static synchronized int adduser ( string roomname , user user ) { for ( gameroom room : briscagames ) { if ( room . getname ( ) . equals ( roomname ) ) { for ( player player : room . getplayers ( ) ) { if ( player == null ) continue ; if ( player . getuser ( ) . getusername ( ) . equals ( user . getusername ( ) ) ) { player . setuser ( user ) ; return player . getseatnumber ( ) ; } } return room . addplayer ( player . getinstance ( 0 , user ) ) ; } } return - 1 ; }
te	5	public static void main ( string [ ] args ) { try { if ( args . length > 0 ) { for ( string arg : args ) { arg = arg . trim ( ) ; if ( arg . matches ( "app_root_dir=\\s*\\w+\\s*" ) ) { jediormengine . app_root_dir = arg ; } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( arg . equals ( "web_app" ) ) { jediormengine . web_app = true ; } if ( arg . matches ( "debug=\\s*true\\s*" ) ) { jediormengine . debug = true ; } else if ( arg . matches ( "debug=\\s*false\\s*" ) ) { jediormengine . debug = false ; } else { } } } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( jediormengine . web_app ) { jediormengine . app_src_dir = string . format ( "%s%sweb%sweb-inf%ssrc" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sconfig%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator , file . separator ) ; file dbconfigfile = new file ( jediormengine . app_db_config_file ) ; if ( ! dbconfigfile . exists ( ) ) { jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; } } else { jediormengine . app_src_dir = string . format ( "%s%ssrc" , jediormengine . app_root_dir , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sdatabase.properties" , jediormengine . app_root_dir , file . separator ) ; } jediormengine . syncdb ( jediormengine . app_src_dir ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	1	public static long pack ( long big , int little , int bits ) { assert bits > 32 && bits < 64 ; assert big < ( 1 << bits ) ; assert little < ( 1 << ( 64 - bits ) ) ; int ls = bits & 7 ; int bm = ( 1 << ls ) - 1 ; long res = ( big & ~ bm ) << ( 64 - bits ) ; res |= ( little & ( ( 1 << ( 64 - bits ) ) - 1 ) ) << ls ; res |= big & bm ; return res ; }
te	5	public confirmpurchase ( final srtype . transaction trans , final srtype . transactionlist translist , final srtype . inventory inv , final jtextpane transtpanel , final jlabel pricelabel ) { setdefaultcloseoperation ( jdialog . dispose_on_close ) ; setalwaysontop ( true ) ; setresizable ( false ) ; settitle ( "confirm purchase" ) ; setbounds ( 100 , 100 , 325 , 114 ) ; getcontentpane ( ) . setlayout ( new borderlayout ( ) ) ; contentpanel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; getcontentpane ( ) . add ( contentpanel , borderlayout . center ) ; contentpanel . setlayout ( null ) ; { jlabel lblconfirmpurchaseof = new jlabel ( "confirm purchase of:" ) ; lblconfirmpurchaseof . setbounds ( 6 , 24 , 133 , 16 ) ; contentpanel . add ( lblconfirmpurchaseof ) ; } { jlabel lblrm = new jlabel ( "rm" + trans . totalprice ) ; lblrm . setfont ( new font ( "lucida grande" , font . plain , 26 ) ) ; lblrm . setbounds ( 151 , 6 , 293 , 42 ) ; contentpanel . add ( lblrm ) ; } { jpanel buttonpane = new jpanel ( ) ; buttonpane . setlayout ( new flowlayout ( flowlayout . right ) ) ; getcontentpane ( ) . add ( buttonpane , borderlayout . south ) ; { jbutton okbutton = new jbutton ( "ok" ) ; okbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { trans . confirmpurchase ( inv ) ; loaders . saveinventory ( inv ) ; inventoryreport invrep = loaders . loadinventoryreport ( ) ; invrep . addinvtolog ( inv ) ; loaders . saveinventoryreport ( invrep ) ; translist . addtrans ( trans ) ; transactionreport transrep = loaders . loadtransactionreport ( ) ; transrep . addtranslist ( translist ) ; loaders . savetransactionreport ( transrep ) ; transtpanel . settext ( "" ) ; pricelabel . settext ( "rm0.00" ) ; setvisible ( false ) ; dispose ( ) ; } } ) ; okbutton . setactioncommand ( "ok" ) ; buttonpane . add ( okbutton ) ; getrootpane ( ) . setdefaultbutton ( okbutton ) ; buttonpane . requestfocus ( ) ; } { jbutton cancelbutton = new jbutton ( "cancel" ) ; cancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { setvisible ( false ) ; dispose ( ) ; } } ) ; cancelbutton . setactioncommand ( "cancel" ) ; buttonpane . add ( cancelbutton ) ; } } }
te	1	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; double pi = 3.14 ; system . out . print ( "please enter radius : " ) ; double r = in . nextdouble ( ) ; double circlearea = pi * r * r ; double roundcircle = 2 * pi * r ; double surfacecircle = 4 * pi * r ; double volumecircle = 1.33 * pi * r * r * r ; system . out . println ( "circlearea : " + circlearea ) ; system . out . println ( "roundcircle : " + roundcircle ) ; system . out . println ( "surfacecircle : " + surfacecircle ) ; system . out . println ( "volumecircle : " + volumecircle ) ; }
te	2	public int moveframe ( frame frame , int currentindexofpreviousitem ) { animation oldparent = frame . getparent ( ) ; if ( currentindexofpreviousitem == - 1 ) { oldparent . frames . remove ( frame ) ; frames . add ( 0 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return 0 ; } frame previousframe = getframe ( currentindexofpreviousitem ) ; if ( previousframe == frame ) return currentindexofpreviousitem ; else { oldparent . frames . remove ( frame ) ; int newindexofpreviousitem = getframeindex ( previousframe ) ; frames . add ( newindexofpreviousitem + 1 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return newindexofpreviousitem + 1 ; } }
te	5	@ override public map < statstype , longsummarystatistics > call ( ) throws ioexception { final longsummarystatistics inittimestats = new longsummarystatistics ( ) ; final longsummarystatistics symboltimestats = new longsummarystatistics ( ) ; final longsummarystatistics dectimestats = new longsummarystatistics ( ) ; final longsummarystatistics totaldecsstats = new longsummarystatistics ( ) ; final longsummarystatistics numdecfailsstats = new longsummarystatistics ( totaldecsstats ) ; final longsummarystatistics decfailtimestats = new longsummarystatistics ( ) ; final bytebuffer dataheaderbuf = dataheader . allocatenewbuffer ( ) ; final bytebuffer symbolheaderbuf = symbolheader . allocatenewbuffer ( ) ; for ( int n = 0 ; n < numiterations ; n ++ ) { dataheaderbuf . clear ( ) ; readbytes ( dataheaderbuf ) ; final dataheader dataheader = dataheader . parsedataheader ( dataheaderbuf ) ; final fecparameters fecparams = dataheader . getfecparams ( ) ; final int extrasymbols = dataheader . getextrasymbols ( ) ; final bytebuffer symbolbuf = bytebuffer . allocate ( fecparams . symbolsize ( ) ) ; final arraydatadecoder datadec = initdatadecoder ( fecparams , extrasymbols , inittimestats ) ; final int z = datadec . numberofsourceblocks ( ) ; for ( int sbn = 0 ; sbn < z ; sbn ++ ) { final sourceblockdecoder srcblockdec = datadec . decoderforsourceblock ( sbn ) ; final int totalsymbols = srcblockdec . numberofsourcesymbols ( ) + extrasymbols ; for ( int i = 0 ; i < totalsymbols ; ) { symbolheaderbuf . clear ( ) ; readbytes ( symbolheaderbuf ) ; final symbolheader symbolheader = symbolheader . parsesymbolheader ( symbolheaderbuf , fecparams , sbn ) ; final int firstesi = symbolheader . getfecpayloadid ( ) . encodingsymbolid ( ) ; final int numsymbolsinpacket = symbolheader . getnumsymbols ( ) ; for ( int s = 0 ; s < numsymbolsinpacket ; s ++ ) { symbolbuf . clear ( ) ; readbytes ( symbolbuf ) ; putsymbol ( srcblockdec , firstesi + s , symbolbuf , symboltimestats , dectimestats , decfailtimestats , totaldecsstats , numdecfailsstats ) ; } i += numsymbolsinpacket ; } } checkdata ( datadec ) ; } final enummap < statstype , longsummarystatistics > map = new enummap < > ( statstype . class ) ; map . put ( statstype . decoder_init_time , inittimestats ) ; map . put ( statstype . symbol_input_time , symboltimestats ) ; map . put ( statstype . decoding_time , dectimestats ) ; map . put ( statstype . num_decoding_failures , numdecfailsstats ) ; if ( numdecfailsstats . getcount ( ) > 0 ) { map . put ( statstype . decoding_failure_time , decfailtimestats ) ; } return map ; }
te	4	private int findplaceholderendindex ( charsequence buf , int startindex ) { int index = startindex + this . placeholderprefix . length ( ) ; int withinnestedplaceholder = 0 ; while ( index < buf . length ( ) ) { if ( stringutils . substringmatch ( buf , index , this . placeholdersuffix ) ) { if ( withinnestedplaceholder > 0 ) { withinnestedplaceholder -- ; index = index + this . placeholdersuffix . length ( ) ; } else { return index ; } } else if ( stringutils . substringmatch ( buf , index , this . simpleprefix ) ) { withinnestedplaceholder ++ ; index = index + this . simpleprefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
te	4	public void run ( ) { if ( logger . getdebugvalue ( ) == 3 ) { system . out . println ( "run() of " + thread . currentthread ( ) . getname ( ) + " is called." ) ; } string word ; set < musicinfo > info_found ; while ( ( word = readfile . readwordfromsearchfile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { iterator < musicinfo > iter = info_found . iterator ( ) ; while ( iter . hasnext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
te	1	list < row > fit ( row row ) { list < string > options = piecesof ( row . option , optionwidth ) ; list < string > descriptions = piecesof ( row . description , descriptionwidth ) ; list < row > rows = new arraylist < row > ( ) ; for ( int i = 0 ; i < math . max ( options . size ( ) , descriptions . size ( ) ) ; ++ i ) rows . add ( new row ( itemorempty ( options , i ) , itemorempty ( descriptions , i ) ) ) ; return rows ; }
te	1	private void printaucpoints ( treeset < xypair > xydata ) { printtofile pf = new printtofile ( ) ; pf . openfile ( classify . datapath + "results" + classify . / + "auc" + classify . / + "" + classify . inttocat . get ( classify . category ) + classify . / + "" + classify . filename + "_aucpoints.csv" ) ; xydata . add ( new xypair ( 0 , 0 ) ) ; xydata . add ( new xypair ( 1 , 1 ) ) ; for ( xypair pair : xydata ) pf . writetofile ( pair . getx ( ) + " " + pair . gety ( ) ) ; pf . closefile ( ) ; }
te	2	public void createrestartfile ( string header , int dateindex , int depthindex ) { file infile = new file ( header ) ; string outputname = outputfolder + "/" + sdf . format ( releasedates [ dateindex ] ) + "_" + mindepths [ depthindex ] + "-" + maxdepths [ depthindex ] + ".prm" ; file outfile = new file ( restartfile ) ; try { copyfileusingstream ( infile , outfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try ( bufferedwriter bw = new bufferedwriter ( new filewriter ( outfile , true ) ) ; ) { bw . write ( "(java " + prms + " -jar " + jarfile + " " + outputname + " " + configurationfile + " " + source + " > " + logdir + "/" + prefix + dateindex + "d" + depthindex + ".log)&\n" ) ; bw . write ( cronstring ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	4	private void printmap ( ) { system . out . print ( "     " ) ; for ( int i = 0 ; i < map . getmapwidth ( ) ; i ++ ) { system . out . print ( string . format ( " %02d   " , i ) ) ; } system . out . println ( ) ; for ( int i = 0 ; i < map . getmapheight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getmapwidth ( ) ; j ++ ) { if ( j == 0 ) system . out . print ( string . format ( "%02d" , i ) ) ; system . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getstartcell ( ) ) { system . out . print ( "**s**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getgoalcell ( ) ) { system . out . print ( "**g**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isobstacle ) { system . out . print ( "|||||" ) ; continue ; } string rhssymbol = map . cells [ i ] [ j ] . rhs == integer . max_value ? "m" : long . tostring ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestpath != null && this . shortestpath . contains ( map . cells [ i ] [ j ] ) ) { system . err . print ( string . format ( "..%2s." , rhssymbol ) ) ; } else { system . out . print ( string . format ( "..%2s." , rhssymbol ) ) ; } } system . out . println ( ) ; } }
te	4	public static void print ( jtextcomponent textcomponent ) throws textcomponentutilexception { inputstream is = null ; try { printservice [ ] printservices = printservicelookup . lookupprintservices ( docflavor . input_stream . autosense , null ) ; if ( printservices . length > 0 ) { printrequestattributeset printrequestattributeset = new hashprintrequestattributeset ( ) ; printrequestattributeset . add ( new jobname ( "jaligner" , null ) ) ; printservice service = serviceui . printdialog ( null , 50 , 50 , printservices , printservicelookup . lookupdefaultprintservice ( ) , docflavor . input_stream . autosense , printrequestattributeset ) ; if ( service != null ) { docprintjob printjob = service . createprintjob ( ) ; printjobmointor printjobmointor = new printjobmointor ( printjob ) ; is = new bytearrayinputstream ( textcomponent . gettext ( ) . getbytes ( ) ) ; documentname documentname = new documentname ( "jaligner" , null ) ; hashdocattributeset docattributeset = new hashdocattributeset ( ) ; docattributeset . add ( documentname ) ; doc doc = new simpledoc ( is , docflavor . input_stream . autosense , docattributeset ) ; printjob . print ( doc , printrequestattributeset ) ; printjobmointor . waitforprintjob ( ) ; } } else { throw new textcomponentutilexception ( "no print service found!" ) ; } } catch ( exception e ) { throw new textcomponentutilexception ( e . getmessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "failed closing input stream: " + e . getmessage ( ) , e ) ; } } } }
te	2	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new arraylist < plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getmodule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerde ( this . vecteur_vitesse ) ; this . plots . add ( new plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
te	3	public static < t , r > r callmemoized ( final bifunction < function < t , r > , t , r > function , final t input ) { function < t , r > memoized = new function < t , r > ( ) { { system . out . println ( "new function called" ) ; } private final map < t , r > store = new hashmap < > ( ) ; public r apply ( final t input ) { return store . computeifabsent ( input , key -> function . apply ( this , key ) ) ; } } ; return memoized . apply ( input ) ; }
te	3	private void doprint ( string s ) { for ( int newline = s . indexof ( 
 ) ; newline >= 0 ; newline = s . indexof ( 
 ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
te	4	public vector < vector < object >> getfoldercontentstable ( ) { vector < vector < object >> tabledata = new vector < > ( ) ; list < fileinfo > files = getfoldercontents ( ) ; logger . debug ( "found " + files . size ( ) + " entries for " + path . tostring ( ) ) ; for ( fileinfo file : files ) { vector < object > row = null ; if ( file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/folder.png" ) ) ; } else { row . add ( new imageicon ( "res/folder_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } for ( fileinfo file : files ) { vector < object > row = null ; if ( ! file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/file.png" ) ) ; } else { row . add ( new imageicon ( "res/file_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } return tabledata ; }
te	5	@ override public void characters ( char [ ] c , int start , int length ) { if ( length > 0 ) { boolean wr = true ; try { if ( innote && ! shownote ) { wr = false ; } if ( inheader && ! showheader ) { wr = false ; } if ( inforeign ) { } if ( indocedition ) { wr = false ; } if ( inabbr && wr ) { if ( abbrcontent == null ) { abbrcontent = new stringbuilder ( ) ; } abbrcontent . append ( c , start , length ) ; wr = false ; } if ( wr ) { buffer . append ( c , start , length ) ; } } catch ( java . nio . bufferoverflowexception x ) { system . err . println ( "insufficient text buffer size" ) ; system . exit ( 1 ) ; } } }
te	2	@ override public string evaluatepolicy ( float max_risk , transferredfile policyfiletotransfer , transferredfile dbsqldumpfiletotransfer , string table_name ) { random generator = new random ( system . currenttimemillis ( ) ) ; long gid = generator . nextlong ( ) ; if ( gid < 0 ) gid = gid * ( - 1 ) ; tempfiles tf = new tempfiles ( ) ; file dbdumptempfile = null ; file policytempfile = null ; try { dbdumptempfile = tf . createtempfile ( dbsqldumpfiletotransfer ) ; policytempfile = tf . createtempfile ( policyfiletotransfer ) ; dbdumptempfile . deleteonexit ( ) ; policytempfile . deleteonexit ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } dba_factory . evaluatepolicy ( policytempfile , dbdumptempfile , null , gid , table_name , false ) ; return "id: --" + gid + "--" ; }
te	3	public static void main ( string [ ] args ) { salariedemployee salariedemployee = new salariedemployee ( "john" , "smith" , "111-11-1111" , 800.00 ) ; hourlyemployee hourlyemployee = new hourlyemployee ( "karen" , "price" , "222-22-2222" , 16.75 , 40 ) ; commissionemployee commissionemployee = new commissionemployee ( "sue" , "jones" , "333-33-3333" , 10000 , .06 ) ; basepluscommissionemployee basepluscommissionemployee = new basepluscommissionemployee ( "bob" , "lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; system . out . println ( "employees processed individually:\n" ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , salariedemployee , "earned" , salariedemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyemployee , "earned" , hourlyemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , commissionemployee , "earned" , commissionemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , basepluscommissionemployee , "earned" , basepluscommissionemployee . earnings ( ) ) ; employee [ ] employees = new employee [ 4 ] ; employees [ 0 ] = salariedemployee ; employees [ 1 ] = hourlyemployee ; employees [ 2 ] = commissionemployee ; employees [ 3 ] = basepluscommissionemployee ; system . out . println ( "employees processed polymorphically:\n" ) ; for ( employee currentemployee : employees ) { system . out . println ( currentemployee ) ; if ( currentemployee instanceof basepluscommissionemployee ) { basepluscommissionemployee employee = ( basepluscommissionemployee ) currentemployee ; employee . setbasesalary ( 1.10 * employee . getbasesalary ( ) ) ; system . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getbasesalary ( ) ) ; } system . out . printf ( "earned $% .2f\n\n" , currentemployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) system . out . printf ( "employee %d is a %s\n" , j , employees [ j ] . getclass ( ) . getname ( ) ) ; }
te	5	public void playrecording ( file file ) { if ( slave != null ) { int amount = 0 ; try { livedata = false ; fileinputstream fis = new fileinputstream ( file ) ; objectinputstream insize = new objectinputstream ( fis ) ; while ( true ) { insize . readobject ( ) ; amount ++ ; } } catch ( exception e ) { } try { system . out . println ( amount ) ; fileinputstream fis = new fileinputstream ( file ) ; objectinputstream in = new objectinputstream ( fis ) ; packet p = null ; int count = 0 ; int start ; int border ; if ( ! sciencetool . _split_values ) { if ( sciencetool . getparameter ( "slittpart" ) == 1.0 ) { start = 0 ; border = amount / 2 ; } else { start = amount / 2 ; border = amount ; } } else { start = 0 ; border = amount ; } while ( true ) { p = ( packet ) in . readobject ( ) ; count ++ ; if ( count >= start && count < border ) this . messagereceivedwithtimestamp ( p . adress , new snoopbcmsg ( p . data , 8 ) , p . time , true ) ; } } catch ( eofexception e ) { } catch ( classnotfoundexception ex ) { logger . getlogger ( datasource . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception e ) { system . out . println ( file . getpath ( ) ) ; e . printstacktrace ( ) ; } livedata = true ; } }
te	3	public arithmeticparser ( string [ ] programsource ) throws parserparsingexception { super ( programsource [ programsource . length - 1 ] ) ; this . context = new evaluationcontext ( ) ; for ( int i = 0 ; i < programsource . length - 1 ; i ++ ) { string [ ] parts = programsource [ i ] . replace ( " " , "" ) . split ( "=" ) ; tree tree = new expressionstreeparser ( parts [ 1 ] ) . getroottree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { matcher matcher = function_definition_pattern . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new runtimeexception ( "wrong definition" ) ; string functionname = matcher . group ( 1 ) ; string argumentname = matcher . group ( 2 ) ; context . addfunctionvalue ( functionname , argumentname , tree ) ; } else { context . addvarvalue ( parts [ 0 ] , tree ) ; } } }
te	2	private string getorientationstring ( orientations o ) { string os = "unknown" ; if ( o == orientations . horizontal ) os = "horizontal" ; if ( o == orientations . left ) os = "90\u00b0 left" ; if ( o == orientations . right ) os = "90\u00b0 right" ; if ( o == orientations . upside ) os = "180\u00b0" ; if ( mytfttype == tfttypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( mytfttype == tfttypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( mytfttype == tfttypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
te	1	protected synchronized void update ( ) { date now = new date ( ) ; long delta = now . gettime ( ) - lastupdate . gettime ( ) ; if ( isdead ( ) ) return ; point oldpos = new point ( x , y ) ; point dir = new point ( speed . getdirectionx ( ) , speed . getdirectiony ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updateposx ( delta ) ; if ( dir . y != 0 ) blocked |= ! updateposy ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldpos . equals ( this ) ) lastupdate = now ; }
te	3	public void changepanel ( jpanel panel ) { this . getcontentpane ( ) . removeall ( ) ; if ( panel != loginpanel ) { this . add ( actionbar ) ; if ( panel == connectionpanel ) { connectionpanel . initialize ( ) ; } else if ( panel == directorylistpanel ) { directorylistpanel . initialize ( ) ; } else if ( panel == filelistpanel ) { filelistpanel . initialize ( ) ; } } else { loginpanel . initialize ( ) ; actionbar . initialize ( ) ; } if ( ! actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getbackstack ( ) . push ( currentpanel ) ; } else if ( actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getforwardstack ( ) . push ( currentpanel ) ; } currentpanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
te	4	protected final object computerange ( ) { final list < double [ ] > rarange = new arraylist < double [ ] > ( ) ; final double [ ] decrange = new double [ 2 ] ; if ( this . ispolescollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isnorthpolecollision ( ) ) { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . issouthpolecollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; if ( this . isborderracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . ismaxracollision ( ) ) { rarange . add ( new double [ ] { rauser - sizearray [ 0 ] / 2.0 , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isminracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , rauser + sizearray [ 0 ] / 2.0 } ) ; rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } } return arrays . aslist ( rarange , decrange ) ; }
te	4	tester ( long _seed ) throws exception { loadwords ( ) ; setseed ( _seed ) ; setdefaultcloseoperation ( exit_on_close ) ; c = new testercanvas ( ) ; c . setpreferredsize ( new dimension ( 600 , 400 ) ) ; container cp = getcontentpane ( ) ; cp . setlayout ( new borderlayout ( ) ) ; cp . add ( c , borderlayout . center ) ; cp . add ( c . seedtext , borderlayout . north ) ; jpanel jp = new jpanel ( ) ; jbutton e = new jbutton ( "english" ) ; e . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( ewords . size ( ) ) ; string word = ewords . get ( index ) ; c . english = word ; c . portuguese = null ; count ++ ; c . repaint ( ) ; } } ) ; jbutton p = new jbutton ( "portuguese" ) ; p . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( pwords . size ( ) ) ; system . out . println ( "index = " + index ) ; string word = pwords . get ( index ) ; c . english = null ; c . portuguese = word ; count ++ ; c . repaint ( ) ; } } ) ; jbutton t = new jbutton ( "translate" ) ; t . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { if ( c . english != null ) { c . portuguese = e2p . get ( c . english ) ; } else if ( c . portuguese != null ) { c . english = p2e . get ( c . portuguese ) ; } c . repaint ( ) ; } } ) ; jbutton r = new jbutton ( "reset" ) ; r . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { setseed ( seed ) ; c . repaint ( ) ; } } ) ; jp . setlayout ( new flowlayout ( ) ) ; jp . add ( e ) ; jp . add ( t ) ; jp . add ( p ) ; jp . add ( r ) ; cp . add ( jp , borderlayout . south ) ; pack ( ) ; setvisible ( true ) ; }
te	5	private void addguesttobookingbuttonactionperformed ( java . awt . event . actionevent evt ) { boolean addguestsuccess ; booking currentbooking = ctr . getcurrentbooking ( ) ; if ( currentbooking != null && guestjlist2 . getselectedvalue ( ) != null ) { guest guest = ( guest ) guestjlist2 . getselectedvalue ( ) ; if ( ! addedguestsmodel . contains ( guest ) ) { if ( ctr . checkroomavailability ( currentbooking , addedguestsmodel . getsize ( ) ) > 0 ) { addguestsuccess = ctr . createbookingdetail ( guest , currentbooking ) ; if ( addguestsuccess ) { addedguestsmodel . addelement ( guest ) ; addedguestsjlist . setmodel ( addedguestsmodel ) ; joptionpane . showmessagedialog ( this , guest . getfirstname ( ) + " " + guest . getlastname ( ) + " added to roomno " + currentbooking . getroomno ( ) ) ; } else { joptionpane . showmessagedialog ( this , "could not add guest to room.\nguest might already be booked to a room in that period." , "error." , joptionpane . information_message ) ; } } else { joptionpane . showmessagedialog ( this , "cannot add guest because room is full!" , "room is full." , joptionpane . information_message ) ; } } else { joptionpane . showmessagedialog ( this , "guest already added!" , "error." , joptionpane . information_message ) ; } } }
te	4	private void initalleles ( ) { for ( int acindex = 0 ; acindex < accessioncount ; acindex ++ ) { for ( int mindex = 0 ; mindex < markercount ; mindex ++ ) { int alcnt = allelename . get ( mindex ) . size ( ) ; datamatrix . get ( acindex ) . set ( mindex , new arraylist < double > ( alcnt ) ) ; for ( int alindex = 0 ; alindex < alcnt ; alindex ++ ) { datamatrix . get ( acindex ) . get ( mindex ) . add ( null ) ; } } } }
te	4	private void addmountansides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existtileoftype ( new mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new mountainside ( ) ) ; map [ i ] [ j + 2 ] . add ( new mountainside ( ) ) ; } } } }
te	4	public boolean connect ( sharingpeer peer ) { boolean retry = false ; boolean sentobfuscatedhandshake = false ; do { socket socket = new socket ( ) ; inetsocketaddress address = new inetsocketaddress ( peer . getip ( ) , peer . getport ( ) ) ; logger . info ( "connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( ioexception ioe ) { logger . warn ( "could not connect to " + peer + ": " + ioe . getmessage ( ) ) ; return false ; } try { byte [ ] remotepeerid = ( peer . haspeerid ( ) ? peer . getpeerid ( ) . array ( ) : null ) ; if ( this . forceobfuscation ) sentobfuscatedhandshake = this . sendobfuscatedhandshake ( socket , remotepeerid , this . forceobfuscation ) ; else sentobfuscatedhandshake = this . sendhandshake ( socket , remotepeerid , peer . supportsobfuscation ( ) ) ; handshake hs = this . validatehandshake ( socket , ( peer . haspeerid ( ) ? peer . getpeerid ( ) . array ( ) : null ) ) ; this . firenewpeerconnection ( socket , hs . getpeerid ( ) ) ; return true ; } catch ( parseexception pe ) { logger . info ( "invalid handshake from " + this . socketrepr ( socket ) + ": " + pe . getmessage ( ) ) ; if ( sentobfuscatedhandshake && peer . supportsobfuscation ( ) ) { peer . supportsobfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( ioexception e ) { } } catch ( ioexception ioe ) { logger . info ( "an error occured while reading an incoming " + "handshake: " + ioe . getmessage ( ) ) ; try { if ( ! socket . isclosed ( ) ) socket . close ( ) ; } catch ( ioexception e ) { } } } while ( retry ) ; return false ; }
te	3	public static armour createarmourfromreader ( string armourstring ) { string [ ] values = armourstring . split ( " " ) ; armour armour = new armour ( ) ; try { armour . setname ( values [ 0 ] ) ; armour . setcost ( integer . parseint ( values [ 1 ] ) ) ; armour . setweight ( integer . parseint ( values [ 2 ] ) ) ; armour . setac ( integer . parseint ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { string [ ] specials = values [ 4 ] . split ( " " ) ; armour = armour . applyspecialtraits ( armour , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading armour object" ) ; if ( armour . getname ( ) != null ) system . out . println ( armour . getname ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
te	5	public void creerressources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new arraylist < case > ( ) ; list < case > availables = new arraylist < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getniveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( configurationloader . max_ressources_spawns < availables . size ( ) ) { for ( int i = 0 ; i < configurationloader . max_ressources_spawns ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new random ( ) . nextint ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new random ( ) . nextint ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new random ( ) . nextint ( 5 ) + 1 ) ) * configurationloader . abondance_multiplicator ; if ( quantite > 0 ) { where . ajouterressource ( new ressource ( quantite ) ) ; } }
te	1	public region ( byte renderruleflags [ ] [ ] [ ] , int vertexheights [ ] [ ] [ ] ) { lowestplane = 99 ; regionsizex = 104 ; regionsizey = 104 ; this . vertexheights = vertexheights ; this . renderruleflags = renderruleflags ; underlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayclippingpaths = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayorientations = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; tilecullingbitsets = new int [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tileshadowintensity = new byte [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tilelightintensity = new int [ regionsizex + 1 ] [ regionsizey + 1 ] ; blendedhue = new int [ regionsizey ] ; blendedsaturation = new int [ regionsizey ] ; blendedlightness = new int [ regionsizey ] ; blendedhuedivisor = new int [ regionsizey ] ; blenddirectiontracker = new int [ regionsizey ] ; }
te	4	private jpanel makeclientlistpanel ( ) { jpanel result = new jpanel ( new borderlayout ( ) ) ; clientlist = new clientlist ( ) ; clientlist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent e ) { if ( clientlist . getselectedid ( ) == - 1 ) { btkick . setenabled ( false ) ; } else { btkick . setenabled ( true ) ; } } } ) ; result . add ( clientlist , borderlayout . center ) ; btkick = new jbutton ( "kick" ) ; btkick . setenabled ( false ) ; btkick . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { kick ( ) ; } } ) ; btkick . addkeylistener ( new keyadapter ( ) { @ override public void keypressed ( keyevent e ) { kick ( ) ; } } ) ; result . add ( btkick , borderlayout . south ) ; return result ; }
te	2	public void createannouncement ( ) { usersession usersession = ( usersession ) facescontext . getcurrentinstance ( ) . getexternalcontext ( ) . getsessionmap ( ) . get ( "usersession" ) ; user = usersession . getuser ( ) ; userid = integer . parseint ( user . getuid ( ) ) ; dateposted = new date ( ) ; if ( courseid == invalid_value ) { system . out . println ( "invalid course for announcement" ) ; return ; } courseusers cusers = new courseusers ( ) ; cusers . setcourseuid ( courseid ) ; courses courses = new courses ( ) ; courses . setcourseid ( courseid ) ; announcements announcement = new announcements ( ) ; announcement . setdescription ( description ) ; announcement . settitle ( announcementtitle ) ; announcement . setdateposted ( dateposted ) ; announcement . setcreator ( cusers ) ; announcement . setcourse ( courses ) ; announcementsdao anndao = new announcementsdao ( ) ; anndao . create ( announcement ) ; }
te	4	public void doservice ( ) { message message = parser . nextmessage ( ) ; while ( message != null ) { switch ( message . gettype ( ) ) { case connect : writer . println ( "already connected!" ) ; writer . flush ( ) ; break ; case disconnect : server . broadcaster . remove ( connection ) ; break ; case textmsg_client : broadcastmessage ( message ) ; break ; case image_client : server . setimage ( imageutils . decodeimage ( message . getmatcher ( ) . group ( 1 ) ) ) ; broadcastmessage ( message ) ; break ; default : abstracttool tool = abstracttool . gettool ( message . gettype ( ) ) ; if ( tool != null ) { server . updateimage ( tool , message ) ; broadcastmessage ( message ) ; } break ; } message = parser . nextmessage ( ) ; } }
te	3	@ override public boolean login ( ) throws loginexception { namecallback namecallback = new namecallback ( "name : " ) ; passwordcallback passwordcallback = new passwordcallback ( "password : " , false ) ; try { callbackhandler . handle ( new callback [ ] { namecallback , passwordcallback } ) ; string username = namecallback . getname ( ) ; string password = new string ( passwordcallback . getpassword ( ) ) ; namecallback . setname ( "" ) ; passwordcallback . clearpassword ( ) ; customer customer = null ; if ( customer == null ) { throw new loginexception ( "authentication failed" ) ; } return true ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new loginexception ( e . getmessage ( ) ) ; } }
te	1	public defaultenginedisplay ( string title , int x , int y , int width , int height ) { frame = new jframe ( title ) ; frame . setdefaultcloseoperation ( jframe . do_nothing_on_close ) ; frame . setignorerepaint ( true ) ; frame . setresizable ( false ) ; frame . setlocation ( x , y ) ; canvas = new canvas ( ) ; canvas . setpreferredsize ( new dimension ( width , height ) ) ; frame . add ( canvas ) ; frame . pack ( ) ; canvas . createbufferstrategy ( 2 ) ; bufferstrategy = canvas . getbufferstrategy ( ) ; canvas . requestfocus ( ) ; }
te	4	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . iscontainer ( ) ) { entities . addall ( parts . get ( b ) . getentities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getbodypart ( ) != null ) { entities . get ( e ) . getbodypart ( ) . decay ( ) ; } } } }
te	2	public yspecification parsespecification ( ) throws exception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser saxparser = factory . newsaxparser ( ) ; yspecificationhandler handler = new yspecificationhandler ( ) ; ysaxhandler preliminar_info_handler = new ypreliminarinfohandler ( ) ; saxparser . parse ( this . yawl_file , preliminar_info_handler ) ; handler . references ( ) . put ( "decomposition_types" , preliminar_info_handler . values ( ) ) ; saxparser . parse ( this . yawl_file , handler ) ; yspecification s = handler . builder ( ) . buildspecification ( ) ; t_info = handler . builder ( ) . translation_info ( ) ; return s ; } catch ( exception e ) { throw new exception ( "error attempting to parse specification." , e ) ; } }
te	5	public list < document > sorting ( map < string , document > temp , int mode ) { list < document > sortedlist = new linkedlist < document > ( temp . values ( ) ) ; if ( mode == 0 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getpagerank ( ) - o2 . getpagerank ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getpagerank ( ) - o2 . getpagerank ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } else if ( mode == 1 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getnumviews ( ) - o2 . getnumviews ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getnumviews ( ) - o2 . getnumviews ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } return sortedlist ; }
te	3	public void prepareforstartingattempt ( ) { arraylist < fieldelement > startingelements = getelements ( "arcanoid.model.ball" ) ; int width = ( int ) startingelements . get ( 0 ) . size ( ) . width ( ) ; int startpos = startingelements . get ( 0 ) . position ( ) . x + width / 2 ; int ypos = startingelements . get ( 0 ) . position ( ) . y ; for ( int i = 1 ; i < startingelements . size ( ) ; i ++ ) { if ( i < 3 ) { startingelements . get ( i ) . setposition ( new point ( startpos - i * 20 - width * i , ypos ) ) ; } else { startingelements . get ( i ) . setposition ( new point ( startpos + ( i - 2 ) * 20 + width * ( i - 2 ) , ypos ) ) ; } } }
te	1	@ test public void testhypothesis ( ) { testhyphelper ( 0 , 1 , 0 , 1 , true , math . log ( 8.0 / 3 ) ) ; testhyphelper ( 1 , 1 , 1 , 1 , true , 0 ) ; testhyphelper ( 1 , 1 , 1 , 1 , false , 0 ) ; testhyphelper ( 100 , 200 , 300 , 300 , true , math . log ( 201.0 / 101 ) ) ; testhyphelper ( 100 , 200 , 300 , 300 , false , math . log ( 101.0 / 201 ) ) ; }
te	1	public unit ( string name , string type , boolean isrange , boolean isair , boolean team , int landattack , int airattack , int range , int defense , int shift ) { this . name = name ; this . type = type ; this . ranged = isrange ; this . air = isair ; this . team = team ; this . landattack = landattack ; this . airattack = airattack ; this . range = range ; this . defense = defense ; this . shift = shift ; shiftdone = false ; attackdone = false ; health = 8 ; }
te	2	public void updatestatus ( ) { log . finer ( log . start ( new throwable ( ) ) ) ; electricity needse = getneedelectricity ( ) ; log . fine ( "culculate electricty needing electronics:" + needse ) ; electricity producte = dboad . productelectorictiy ( ) ; log . fine ( "product electricty:" + producte ) ; electricity sube = producte . - ( needse ) ; log . fine ( "cluculate electricty product-needs:" + sube ) ; if ( sube . getwat ( ) < 0 ) { electricity requeste = new electricity ( ( int ) ( sube . getwat ( ) * - 1 ) ) ; buyelectricty ( requeste ) ; log . fine ( "buy the electricity:" + requeste ) ; } else { sellelectricty ( sube ) ; log . fine ( "sell the electricity:" + sube ) ; } updatemoney ( ) ; log . finer ( log . finish ( new throwable ( ) ) ) ; }
te	3	< c > nodefactory < c > getsimplenodebuilder ( final string namespace , class < c > dummy ) { final nodefactory < c > factory = new reflectnodefactory < > ( new autoqualifiedclassloader ( namespace , _classloader ) ) ; return new simplenodefactory < c > ( ) { public predicate < c > newpredicate ( string type , string attr ) { if ( factory . newpredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newpredicate ( type , attr ) ; } @ override public action < c > newaction ( string type , string attr ) { if ( factory . newaction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newaction ( type , attr ) ; } private void ok ( string name ) { if ( verbose ) system . out . printf ( "class '%s' loaded\n" , name ) ; } private void error ( string name ) { system . err . printf ( "class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
te	2	public reportform ( java . awt . frame parent , boolean modal , date df , date dt , string un , string su ) { super ( parent , modal ) ; datefrom = df ; dateto = dt ; unit = un ; subunit = su ; initcomponents ( ) ; if ( ! beans . isdesigntime ( ) ) { entitymanager . gettransaction ( ) . begin ( ) ; } mastertable . getcolumnmodel ( ) . getcolumn ( 5 ) . setcellrenderer ( new tablecellrenderdate ( ) ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 6 ) . setcellrenderer ( new tablecellrendertime ( ) ) ; mastertable . setautoresizemode ( jtable . auto_resize_off ) ; tablecolumnadjuster tca = new tablecolumnadjuster ( mastertable ) ; tca . adjustcolumns ( ) ; defaulttablecellrenderer dtcr = new defaulttablecellrenderer ( ) ; dtcr . sethorizontalalignment ( swingconstants . center ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 0 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 1 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 4 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 7 ) . setcellrenderer ( dtcr ) ; }
te	5	@ override protected void drawcomponent ( graphics2d g ) { if ( visinfo . hasnodes ( ) ) { g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g . setcolor ( visinfo . getnodecolor ( ) ) ; affinetransform at = visinfo . gettranformation ( ) ; point2d from ; for ( node node : visinfo . getnodes ( ) ) { from = node . getpoint ( ) ; at . settoidentity ( ) ; at . translate ( from . getx ( ) - visinfo . getcirclediam ( ) , from . gety ( ) - visinfo . getcirclediam ( ) ) ; g . drawimage ( buffcircle , at , null ) ; for ( edge edge : node . getedges ( ) ) { if ( edge . getfromid ( ) < edge . gettoid ( ) ) { nodeimpl nodeto = ( nodeimpl ) visinfo . getnode ( edge . gettoid ( ) ) ; line = new line2d . double ( from , nodeto . getpoint ( ) ) ; g . draw ( line ) ; } } } } }
te	5	@ override public string solve ( case acase ) { string template = "11%s11%s11%s11%s11" ; final list < string > coins = lists . newarraylist ( ) ; for ( int i = 0 ; i < acase . nbits - 10 ; i ++ ) { for ( int j = 0 ; j < acase . nbits - 10 - i ; j ++ ) { for ( int k = 0 ; k < acase . nbits - 10 - i - j ; k ++ ) { int l = acase . nbits - 10 - i - j - k ; string output = string . format ( template , zerostr ( i ) , zerostr ( j ) , zerostr ( k ) , zerostr ( l ) ) ; coins . add ( output + " 3 2 5 2 7 2 3 2 11" ) ; acase . jcoins -- ; if ( acase . jcoins == 0 ) { return stringlist ( coins ) ; } } } } throw new runtimeexception ( "need moar jamcoins" ) ; }
te	1	protected updaterpanel ( ) { super ( new borderlayout ( ) ) ; messages = new jtextarea ( ) ; messages . setlinewrap ( false ) ; messagesempty = true ; final jpanel center = new jpanel ( new borderlayout ( ) ) ; center . add ( new jscrollpane ( messages ) , borderlayout . center ) ; center . add ( box . createverticalstrut ( minimal_height ) , borderlayout . west ) ; center . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; progressbar = new jprogressbar ( 0 , 100 ) ; progressbar . setvalue ( 0 ) ; actionsprogressbar = new jprogressbar ( 0 , 100 ) ; actionsprogressbar . setvalue ( 0 ) ; actionprogressbar = new jprogressbar ( 0 , 100 ) ; actionprogressbar . setvalue ( 0 ) ; final jpanel progress = new jpanel ( ) ; progress . setlayout ( new boxlayout ( progress , boxlayout . y_axis ) ) ; progress . add ( progressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionsprogressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionprogressbar ) ; final jpanel south = new jpanel ( new borderlayout ( ) ) ; south . add ( center , borderlayout . center ) ; south . add ( progress , borderlayout . south ) ; south . add ( box . createhorizontalstrut ( minimal_width ) , borderlayout . north ) ; add ( south , borderlayout . center ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . north ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . west ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . east ) ; }
te	3	public static string generaterangehashfunction ( byte [ ] min , byte [ ] max , string [ ] buckets , string suffix , string prefix ) throws exception { if ( comparekey ( min , max ) > 0 ) { throw new exception ( "the given min is not larger than the max. buckets could not be determined" ) ; } byte [ ] [ ] ranges = getmaxvalsperrange ( min , max , buckets . length ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . tostring ( ) ; }
te	3	public list < wishlist > find ( int idu ) throws instancenotfoundexception { list < wishlist > list = new arraylist < wishlist > ( ) ; try { connection connection = datasourceutils . getconnection ( datasource ) ; preparedstatement statement = connection . preparestatement ( "select idu  idp from wishlist where idu=?" ) ; statement . setint ( 1 , idu ) ; resultset resultset = statement . executequery ( ) ; while ( resultset . next ( ) ) { list . add ( new wishlist ( resultset . getint ( 2 ) , resultset . getint ( 1 ) ) ) ; } } catch ( sqlexception e ) { throw new runtimeexception ( e ) ; } return list ; }
te	4	private nodo buscarnodo ( string padre ) { nodo tmp1 = this . raiz ; nodo tmp2 = tmp1 ; stringtokenizer path = new stringtokenizer ( padre , "/" ) ; string s ; while ( path . hasmoretokens ( ) ) { s = path . nexttoken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerhijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguientehermano ; } } return tmp2 ; }
te	1	public void testtostringreconstruction ( ) { asserttrue ( "integer(0) cannot be reconstructed from its tostring() value!" , int0 . equals ( new integer ( int0 . tostring ( ) ) ) ) ; asserttrue ( "integer(1) cannot be reconstructed from its tostring() value!" , int1 . equals ( new integer ( int1 . tostring ( ) ) ) ) ; asserttrue ( "integer(-1) cannot be reconstructed from its tostring() value!" , intneg1 . equals ( new integer ( intneg1 . tostring ( ) ) ) ) ; asserttrue ( "integer(long.max_value) cannot be reconstructed from its tostring() value!" , intlongmax . equals ( new integer ( intlongmax . tostring ( ) ) ) ) ; asserttrue ( "integer(long.min_value) cannot be reconstructed from its tostring() value!" , intlongmin . equals ( new integer ( intlongmin . tostring ( ) ) ) ) ; }
te	4	public static void main ( string argv [ ] ) { try { if ( argv . length != 1 ) { system . err . println ( "usbd [ start | stop ]" ) ; system . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { host host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usbd:  usb is not available." ) ; system . exit ( 1 ) ; } if ( host instanceof remote ) { system . err . println ( "usbd: proxy already registered" ) ; system . exit ( 1 ) ; } try { hostproxy proxy = new hostproxy ( host ) ; naming . bind ( rminame , proxy ) ; system . err . println ( "usbd:  bound rmi name " + rminame ) ; } catch ( exception e ) { system . err . println ( "usbd:  couldn't bind to: " + rminame ) ; if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { system . err . println ( "usbd: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { system . err . println ( "usbd: no '" + argv [ 0 ] + "' command" ) ; system . exit ( 1 ) ; } } catch ( exception e ) { if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } }
te	3	private static void test4 ( ) throws interruptedexception { executorservice executor = executors . newworkstealingpool ( ) ; list < callable < string >> callables = arrays . aslist ( ( ) -> "task1" , ( ) -> "task2" , ( ) -> "task3" ) ; executor . invokeall ( callables ) . stream ( ) . map ( future -> { try { return future . get ( ) ; } catch ( exception e ) { throw new illegalstateexception ( e ) ; } } ) . foreach ( system . out colcol println ) ; executor . shutdown ( ) ; }
te	2	public static void setapplemenus ( string title ) { try { system . setproperty ( "apple.laf.usescreenmenubar" , "true" ) ; system . setproperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( classnotfoundexception e ) { system . out . println ( "classnotfoundexception: " + e . getmessage ( ) ) ; } catch ( instantiationexception e ) { system . out . println ( "instantiationexception: " + e . getmessage ( ) ) ; } catch ( illegalaccessexception e ) { system . out . println ( "illegalaccessexception: " + e . getmessage ( ) ) ; } catch ( unsupportedlookandfeelexception e ) { system . out . println ( "unsupportedlookandfeelexception: " + e . getmessage ( ) ) ; } }
te	5	private keyframe getkeyframe ( int i ) { try { mapevent me = events . poll ( ) ; if ( me != null ) { if ( nodes . containskey ( me . getnext ( ) ) ) { if ( transport . containskey ( me . getname ( ) ) ) { transportagentui ui = transport . get ( me . getname ( ) ) ; return movetransport ( me . getnext ( ) , me . getroadpercent ( ) , ui , duration . millis ( i * 1000 ) ) ; } else { } } else { } } else { thread . sleep ( 1000 ) ; } } catch ( throwable te ) { exceptionutils . handleexception ( te ) ; } return getkeyframe ( i ) ; }
te	3	public stringbuilder streamout ( ) { stringbuilder buffer = new stringbuilder ( ) ; for ( int i = 0 ; i < numlines ; i ++ ) { if ( i == 0 || i == numlines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzlines [ i ] . streamout ( ) ) ; buffer . append ( vertlines [ i ] . streamout ( ) ) ; } for ( ordinalpt opt : ordpts ) { buffer . append ( opt . streamout ( ) ) ; } for ( gostone stone : gostones ) { buffer . append ( stone . streamout ( ) ) ; } for ( golabel label : labels ) { buffer . append ( label . streamout ( ) ) ; } for ( triangle triangle : triangles ) { buffer . append ( triangle . streamout ( ) ) ; } return buffer ; }
te	1	private void drugaddactionperformed ( java . awt . event . actionevent evt ) { adddrugid . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 0 ) . tostring ( ) ) ; adddrugid . setvisible ( false ) ; adddrugmaxnum . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 3 ) . tostring ( ) ) ; adddrugmaxnum . setvisible ( false ) ; adddrugnumfield . settext ( "" ) ; adddrugtext . settext ( "" ) ; adddrugname . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; adddrugname . setvisible ( true ) ; adddrugprice . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 4 ) . tostring ( ) ) ; adddrugwindow . setvisible ( true ) ; }
te	1	public static void createkeysettings ( ) { keysettings s1 = new keysettings ( ) ; s1 . bomb = game . keys . getkey ( keyevent . vk_l ) ; s1 . left = game . keys . getkey ( keyevent . vk_left ) ; s1 . right = game . keys . getkey ( keyevent . vk_right ) ; s1 . up = game . keys . getkey ( keyevent . vk_up ) ; s1 . down = game . keys . getkey ( keyevent . vk_down ) ; s1 . item = game . keys . getkey ( keyevent . vk_k ) ; game . key_settings . add ( s1 ) ; keysettings s2 = new keysettings ( ) ; s2 . bomb = game . keys . getkey ( keyevent . vk_t ) ; s2 . left = game . keys . getkey ( keyevent . vk_a ) ; s2 . right = game . keys . getkey ( keyevent . vk_d ) ; s2 . up = game . keys . getkey ( keyevent . vk_w ) ; s2 . down = game . keys . getkey ( keyevent . vk_s ) ; s2 . item = game . keys . getkey ( keyevent . vk_r ) ; game . key_settings . add ( s2 ) ; }
te	5	private static string readlastline ( file file , string charset ) throws ioexception { if ( ! file . exists ( ) || file . isdirectory ( ) || ! file . canread ( ) ) { return null ; } randomaccessfile raf = null ; try { raf = new randomaccessfile ( file , "r" ) ; long len = raf . length ( ) ; if ( len == 0 ) { return "" ; } else { long pos = len - 1 ; while ( pos > 0 ) { pos -- ; raf . seek ( pos ) ; if ( raf . readbyte ( ) == 
 ) { break ; } } if ( pos == 0 ) { raf . seek ( 0 ) ; } byte [ ] bytes = new byte [ ( int ) ( len - pos ) ] ; raf . read ( bytes ) ; if ( charset == null ) { return new string ( bytes ) ; } else { return new string ( bytes , charset ) ; } } } catch ( filenotfoundexception e ) { } finally { if ( raf != null ) { try { raf . close ( ) ; } catch ( exception e2 ) { } } } return null ; }
te	1	@ test public void testarea ( ) { point [ ] points = aconvex ; assertequals ( 78.5 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  0 1" ) ; assertequals ( 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  0 1  2 0" ) ; assertequals ( - 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  2 0  2 2" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "100 100  102 100  102 100  102 102" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "0 0  1 0  2 0" ) ; assertequals ( 0 , area ( points ) , eps ) ; }
te	4	public identifier bookbed ( identifier userid , identifier searchid ) { arraylist < searchbean < freebeddetailbean >> results = getlastsearchresult ( ) ; for ( searchbean < freebeddetailbean > search : results ) { if ( search . getsearchid ( ) . equals ( searchid ) ) { freebeddetailbean beddetail = search . getobjectinfo ( ) ; identifier hostelid = search . getobjectid ( ) ; booking booking = new booking ( ) ; booking . setbedids ( beddetail . getbedids ( ) ) ; arraylist < tariff > bedreservations = new arraylist < tariff > ( ) ; for ( int i = 0 ; i < booking . getbedids ( ) . size ( ) ; i ++ ) { tariff tariff = new tariff ( beddetail . getprice ( ) . get ( i ) , beddetail . getcheckin ( ) , beddetail . getcheckout ( ) ) ; bedreservations . add ( tariff ) ; } booking . setbedreservations ( bedreservations ) ; booking . setbookingdate ( genericutility . getcurrentdatewithouttime ( ) ) ; booking . sethostelid ( hostelid ) ; booking . setstatus ( bookingstatus . reserved ) ; booking . setuserid ( userid ) ; try { return bookings . getinstance ( ) . create ( booking ) ; } catch ( databasereadwriteexception | identifieralreadyexistsexception | invalididentifierexception | invalidparameterexception | conflictexception | identifiernotfoundexception e ) { } } } return null ; }
te	5	private boolean fourinarow ( int row , int col , location [ ] [ ] boardlocations ) { int columnlength = boardlocations [ row ] . length ; int rowlength = boardlocations . length ; int startrow ; int currentrow ; int startcolumn ; int currentcolumn ; int matches = 0 ; boolean fourofakindfound = false ; int i , j , k ; for ( i = 0 ; i < rowlength ; i ++ ) { location [ ] rowlocations = boardlocations [ i ] ; for ( j = 0 , startcolumn = 0 , currentcolumn = 0 , matches = 0 ; j < columnlength - 1 ; j ++ ) { if ( rowlocations [ j ] . getplayer ( ) == rowlocations [ j + 1 ] . getplayer ( ) ) { currentcolumn ++ ; if ( rowlocations [ j ] . getplayer ( ) != null ) matches ++ ; else startcolumn = currentcolumn ; } else if ( matches < 3 ) { currentcolumn ++ ; startcolumn = currentcolumn ; matches = 0 ; } else { for ( k = startcolumn ; k <= currentcolumn ; k ++ ) { rowlocations [ k ] . setdeleteflag ( ) ; } currentcolumn ++ ; startcolumn = currentcolumn ; matches = 0 ; fourofakindfound = true ; } } if ( matches > 3 ) fourofakindfound = true ; } for ( j = 0 ; j < columnlength ; j ++ ) { for ( i = 0 , matches = 0 , startrow = 0 , currentrow = 0 ; i < rowlength - 1 ; i ++ ) { if ( boardlocations [ i ] [ j ] . getplayer ( ) == boardlocations [ i + 1 ] [ j ] . getplayer ( ) ) { currentrow ++ ; if ( boardlocations [ i ] [ j ] . getplayer ( ) != null ) matches ++ ; else startrow = currentrow ; } else if ( matches < 3 ) { currentrow ++ ; startrow = currentrow ; matches = 0 ; } else { for ( k = startrow ; k <= currentrow ; k ++ ) { boardlocations [ k ] [ j ] . setdeleteflag ( ) ; } currentrow ++ ; startrow = currentrow ; matches = 0 ; fourofakindfound = true ; } } if ( matches > 3 ) fourofakindfound = true ; } return fourofakindfound ; }
te	3	public iterable < position < e >> findrange ( e minvalue , e maxvalue ) { list < position < e >> l = new arraylist < > ( ) ; list < position < e >> todas = ( list < position < e >> ) this . positions ( ) ; for ( position < e > pos : todas ) { e curvalue = pos . element ( ) ; int compmin = findcomparator . compare ( curvalue , minvalue ) ; int compmax = findcomparator . compare ( curvalue , maxvalue ) ; boolean overmin = ( ( compmin == 0 ) || ( compmin == 1 ) ) ; boolean undermax = ( ( compmax == 0 ) || ( compmax == - 1 ) ) ; if ( overmin && undermax ) { l . add ( pos ) ; } } return l ; }
te	4	public list < sitestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > statrows = resultset . getrows ( ) ; map < long , sitestatmodel > sitestatmodelmap = new hashmap < > ( ) ; for ( statrow eachrow : statrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { sitestatmodel sitestatmodel = new sitestatmodel ( ) ; sitestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; sitestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; sitestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; sitestatmodel . sethour ( hour ) ; sitestatmodel . setvideo ( 0 ) ; sitestatmodel . setsite ( sitemodel ) ; if ( sitestatmodelmap . get ( hour . getmillis ( ) ) == null ) { sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } else { sitestatmodelmap . remove ( hour . getmillis ( ) ) ; sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } } } list < sitestatmodel > sitestatmodels = new arraylist < > ( sitestatmodelmap . values ( ) ) ; return sitestatmodels ; }
te	5	private void exportatxt ( ) throws sqlexception { string query = "" ; string query_contador = "" ; string linea ; resultset respuesta ; boolean band = false ; string ruta_escritorio = system . getproperty ( "user.home" ) + "\\desktop\\" ; try { bufferedwriter escribir_archivo = new bufferedwriter ( new filewriter ( new file ( ruta_escritorio + this . nombrearchivo ) ) ) ; if ( this . caso . equals ( "todos" ) ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true'" ; respuesta = this . conexion . executequery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getint ( 1 ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true'" ; respuesta = this . conexion . executequery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getnstring ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaloading . lblinfo . settext ( "exportando " + cont_escritos + " de " + total_correos ) ; vistaloading . pbprogreso . setvalue ( porcentaje ) ; vistaloading . lblcompletado . settext ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } else if ( this . caso . equals ( "origen-grupo" ) ) { if ( origen != null && grupo != null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) + " and `id_grupo` = " + grupo . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) + " and `id_grupo` = " + grupo . getid ( ) ; } else if ( origen != null && grupo == null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_origen` = " + origen . getid ( ) ; } else if ( origen == null && grupo != null ) { query_contador = "select count(`correo`) from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_grupo` = " + grupo . getid ( ) ; query = "select `correo` from `" + nombretablas . correos . getvalue ( ) + "` where `habilitado` = 'true' and `id_grupo` = " + grupo . getid ( ) ; } respuesta = this . conexion . executequery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getint ( 1 ) ; respuesta = this . conexion . executequery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getnstring ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaloading . lblinfo . settext ( "exportando " + cont_escritos + " de " + total_correos ) ; vistaloading . pbprogreso . setvalue ( porcentaje ) ; vistaloading . lblcompletado . settext ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } vistaloading . dispose ( ) ; if ( band == true ) { joptionpane . showmessagedialog ( vistaloading , "exportaci\u00f3n finalizada  nuevo documento : \r\n" + ruta_escritorio + nombrearchivo , "fin del proceso" , joptionpane . information_message ) ; } } catch ( headlessexception | ioexception | sqlexception e ) { joptionpane . showmessagedialog ( null , "error: " + e + "." , "error" , joptionpane . error_message ) ; } }
te	4	private string generaterandomid ( ) { stringbuilder sb = new stringbuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idlength ) { char ch = ( char ) rnd . nextint ( ) ; if ( utils . isuriletterordigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containskey ( sb . tostring ( ) ) ) { sb . delete ( 0 , idlength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > retry_count ) ; return sb . tostring ( ) ; }
te	5	private int packspecifiedframes ( byte [ ] bytes , int offset , string onlyid , string notid ) throws notsupportedexception { iterator < id3v2frameset > setiterator = framesets . values ( ) . iterator ( ) ; while ( setiterator . hasnext ( ) ) { id3v2frameset frameset = setiterator . next ( ) ; if ( ( onlyid == null || onlyid . equals ( frameset . getid ( ) ) ) && ( notid == null || ! notid . equals ( frameset . getid ( ) ) ) ) { iterator < id3v2frame > frameiterator = frameset . getframes ( ) . iterator ( ) ; while ( frameiterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) frameiterator . next ( ) ; if ( frame . getdatalength ( ) > 0 ) { byte [ ] framedata = frame . tobytes ( ) ; buffertools . copyintobytebuffer ( framedata , 0 , framedata . length , bytes , offset ) ; offset += framedata . length ; } } } } return offset ; }
te	5	public leprauser parsecontent ( string content ) throws lepraexception { if ( stringutils . isblank ( content ) || "null" . equalsignorecase ( content . trim ( ) ) ) { throw new lepraloginexception ( ) ; } jsonobject obj = new jsonobject ( content ) ; string status = obj . getstring ( "status" ) ; if ( status == null || ! "ok" . equalsignorecase ( status ) ) { jsonarray errors = obj . optjsonarray ( "errors" ) ; if ( errors != null && errors . length ( ) > 0 ) { for ( int i = 0 ; i < errors . length ( ) ; i ++ ) { jsonobject error = errors . getjsonobject ( i ) ; if ( error != null && stringutils . equalsignorecase ( error . getstring ( "code" ) , "invalid_password" ) ) { throw new leprainvalidloginpasswordexception ( ) ; } if ( error != null && stringutils . equalsignorecase ( error . getstring ( "code" ) , "captcha_required" ) ) { throw new lepracaptcharequired ( ) ; } } } throw new lepraloginexception ( ) ; } jsonobject user = obj . getjsonobject ( "user" ) ; return new leprauser ( user . getint ( "id" ) , user . getstring ( "login" ) , user . getstring ( "gender" ) , user . getint ( "karma" ) ) ; }
te	1	public queuerow ( int opcode , boolean shouldshowoperandfield ) { this . opcode = opcode ; setforeground ( color . gray ) ; setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; setpreferredsize ( new dimension ( 258 , 28 ) ) ; setmaximumsize ( new dimension ( 32767 , 30 ) ) ; setlayout ( new boxlayout ( this , boxlayout . x_axis ) ) ; cmdnamelabel = new jlabel ( "" ) ; add ( cmdnamelabel ) ; horizontalglue = box . createhorizontalglue ( ) ; add ( horizontalglue ) ; operandfield = new jformattedtextfield ( numberformat . getnumberinstance ( ) ) ; operandfield . setvalue ( 0 ) ; operandfield . setpreferredsize ( new dimension ( 60 , 22 ) ) ; operandfield . setmaximumsize ( new dimension ( 60 , 2147483647 ) ) ; operandfield . setvisible ( shouldshowoperandfield ) ; add ( operandfield ) ; horizontalstrut = box . createhorizontalstrut ( 20 ) ; horizontalstrut . setpreferredsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setminimumsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setmaximumsize ( new dimension ( 13 , 32767 ) ) ; add ( horizontalstrut ) ; moveupbtn = new jbutton ( "\u25b2" ) ; add ( moveupbtn ) ; movedownbtn = new jbutton ( "\u25bc" ) ; add ( movedownbtn ) ; removebtn = new jbutton ( "remove" ) ; add ( removebtn ) ; }
te	3	public void storepast ( pastdata past ) { if ( past . zip . equalsignorecase ( "denver co" ) ) past . zip = "80201" ; string prefix = past . zip + " " + timeformat . format ( past . date ) + " " + past . today + " " + past . occurreddate ; if ( past . overallpast . high != null || past . overallpast . precip != null ) { string str = prefix ; str = str + " " ; if ( past . overallpast . high != null ) str = str + past . overallpast . high . tostring ( ) ; str = str + " " ; if ( past . overallpast . precip != null ) str = str + past . overallpast . precip . tostring ( ) ; str = str + " " ; daout . println ( str ) ; } if ( past . hourlypast . length != 0 ) { for ( int i = 0 ; i < past . hourlypast . length ; i ++ ) { string str = prefix ; str = str + " " + past . hourlypast [ i ] . hour ; str = str + " " ; if ( past . hourlypast [ i ] . temp != null ) str = str + past . hourlypast [ i ] . temp . tostring ( ) ; str = str + " " ; if ( past . hourlypast [ i ] . conditions != null ) str = str + past . hourlypast [ i ] . conditions ; str = str + " " ; if ( past . hourlypast [ i ] . precip != null ) str = str + past . hourlypast [ i ] . precip . tostring ( ) ; str = str + " " ; haout . println ( str ) ; } } }
te	2	@ override public void writeanalysis ( morphologyanalysis analysis ) { final string record = string . format ( "%s (\"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\");%n" , insert_analysis , analysis . getform ( ) , analysis . getlemma ( ) , analysis . getgrammaticalcase ( ) , analysis . getdegree ( ) , analysis . getgender ( ) , analysis . getmood ( ) , analysis . getnumber ( ) , analysis . getperson ( ) , analysis . getpos ( ) , analysis . gettense ( ) , analysis . getvoice ( ) ) ; try { morphologywriter . write ( record ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
te	3	@ override public string getasstring ( facescontext facescontext , uicomponent component , object object ) { if ( object == null ) { return null ; } if ( object instanceof keystate ) { keystate o = ( keystate ) object ; return getstringkey ( o . getidkeystate ( ) ) ; } else { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "object {0} is of type {1}; expected type: {2}" , new object [ ] { object , object . getclass ( ) . getname ( ) , keystate . class . getname ( ) } ) ; return null ; } }
te	4	public void mouseclicked ( mouseevent me ) { try { if ( me . getsource ( ) == jb_connexion ) { login = jtf_login . gettext ( ) ; password = string . valueof ( jpf_password . getpassword ( ) ) ; system . out . println ( "email : " + login ) ; system . out . println ( "motdepasse : " + password ) ; user u = null ; connection co = bs . getconnection ( ) ; system . out . println ( "avant if" ) ; if ( user . checkpresence ( bs , login , password ) ) { system . out . println ( "debut if" ) ; u = user . findbylogs ( login , password , bs ) ; groupe = usertype . findbyid ( u . getid_ut ( ) , bs ) . getname_ut ( ) ; system . out . println ( "ok : " + groupe ) ; affichermenuprincipal ( ) ; setresizable ( true ) ; setextendedstate ( maximized_both ) ; } else { system . out . println ( "non ok" ) ; } } if ( me . getsource ( ) == jb_mdp_oublie ) { if ( swingutilities . isleftmousebutton ( me ) ) { } if ( swingutilities . isrightmousebutton ( me ) ) { } } } catch ( exception e ) { system . out . println ( "exception" ) ; e . printstacktrace ( ) ; } }
te	1	public fourmiliere ( monde monde , case c , int fecondite , int taille_max , int ressources , int tauxeclaireuses ) { this . fecondite = fecondite ; this . taille_max = taille_max ; this . ressources = ressources ; this . fourmi = new hashset < fourmi > ( ) ; this . _case = c ; this . monde = monde ; this . tauxeclaireuses = tauxeclaireuses ; logger . debug ( "fourmiliere cr\u00e9e : " + this ) ; _case . setfourmiliere ( this ) ; monde . ajouterfourmiliere ( this ) ; this . getmonde ( ) . fireevent ( new fourmiliereajouteeevent ( monde . gettour ( ) , new date ( ) , this ) ) ; }
te	2	renderercontext ( final string name ) { if ( log_create_context ) { marlinutils . loginfo ( "new renderercontext = " + name ) ; } this . name = name ; npcpathiterator = new normalizingpathiterator . nearestpixelcenter ( float6 ) ; npqpathiterator = new normalizingpathiterator . nearestpixelquarter ( float6 ) ; transformerpc2d = new transformingpathconsumer2d ( ) ; cache = new marlincache ( this ) ; renderer = new renderer ( this ) ; ptg = new marlintilegenerator ( renderer ) ; stroker = new stroker ( this ) ; dasher = new dasher ( this ) ; switch ( marlinrenderingengine . ref_type ) { default : case marlinrenderingengine . ref_hard : reference = this ; break ; case marlinrenderingengine . ref_soft : reference = new softreference < renderercontext > ( this ) ; break ; case marlinrenderingengine . ref_weak : reference = new weakreference < renderercontext > ( this ) ; break ; } }
te	1	@ test public void testisconvex ( ) { point [ ] points = makepoints ( "0 0  4 5  6 5  9 3  10 4  12 -1  7 -4  4 0  3 -2  -1 1  8 2  -1 -1" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = aconvex ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "0.50507641 39.107643  50.002551 25.218046  79.296972 -14.68298  93.944191 -57.867001  84.347738 -94.990105  34.850263 -82.363197  -0.50507641 -36.14872  -12.121831 5.7726092" ) ; asserttrue ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = makepoints ( "0 0  1 0  2 0  3 0  2 0  1 0" ) ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "-35.860415 -16.379211  -4.0406102 -35.067033  40.406102 13.925365  57.578695 56.856849  -37.88072 38.674103  -72.225907 6.060915  -11.111678 6.3492214" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; }
te	4	private box drawbuttonbestscores ( ) { kulbutton ok1 = new kulbutton ( "ok" ) ; ok1 . setpreferredsize ( new dimension ( 125 , 40 ) ) ; ok1 . setmaximumsize ( new dimension ( 125 , 40 ) ) ; ok1 . setforeground ( color . white ) ; ok1 . setfont ( f . derivefont ( 26f ) ) ; box buttonbox = new box ( boxlayout . x_axis ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; buttonbox . add ( ok1 ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; ok1 . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( swingutilities . isleftmousebutton ( e ) ) { slideup ( ) ; } } } ) ; return buttonbox ; }
te	1	protected void paintcomponent ( graphics g ) { graphics2d g2d = ( graphics2d ) g ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; int largeur = getwidth ( ) ; int hauteur = getheight ( ) ; int b_hauteur = hauteur - ( inset * 2 ) ; int b_largeur = largeur - ( inset * 2 ) ; int varcsize = b_hauteur ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; color vgradientstartcolor = buttoncolor . darker ( ) . darker ( ) . darker ( ) ; color vgradientendcolor = buttoncolor . brighter ( ) . brighter ( ) . brighter ( ) ; paint paint = new gradientpaint ( 0 , inset , vgradientstartcolor , 0 , b_hauteur , vgradientendcolor , false ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; int vhighlightinset = 2 ; int vbuttonhighlightheight = b_hauteur - ( vhighlightinset * 2 ) ; int vbuttonhighlightwidth = b_largeur - ( vhighlightinset * 2 ) ; int vhighlightarcsize = vbuttonhighlightheight ; vgradientstartcolor = color . white ; vgradientendcolor = buttoncolor . brighter ( ) ; paint = new gradientpaint ( 0 , inset + vhighlightinset , vgradientstartcolor , 0 , inset + vhighlightinset + ( vbuttonhighlightheight / 2 ) , buttoncolor . brighter ( ) , false ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , .8f ) ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset + vhighlightinset , inset + vhighlightinset , vbuttonhighlightwidth , vbuttonhighlightheight , vhighlightarcsize , vhighlightarcsize ) ; roundrectangle2d . float r2d = new roundrectangle2d . float ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; g2d . clip ( r2d ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , 1.0f ) ) ; super . paintcomponent ( g ) ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_off ) ; }
te	2	@ override protected void selectionchanged ( int selectionindex ) { audiences au = model . getentity ( selectionindex ) ; string sql = "call au_subjects(?)" ; object [ ] [ ] result = dbconnection . getinstance ( ) . executequery ( sql , new object [ ] { au . getid ( ) } ) ; string [ ] subjects = new string [ result . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { subjects [ i ] = ( string ) result [ i ] [ 0 ] ; } object [ ] params = new object [ ] { au . getfullnumber ( ) , audiencemodel . audience_type [ au . gettype ( ) ] , au . getcapacity ( ) , subjects } ; htmlbuilder html = new htmlbuilder ( "audiences.rep" , params ) ; setinfotext ( html . tostring ( ) ) ; }
te	4	@ suppresswarnings ( "unchecked" ) public static void main ( string args [ ] ) { repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new repl < > ( fractalevaluator . class ) ; repl . loop ( ) ; } else { try { repl = new repl ( class . forname ( args [ 0 ] ) ) ; arraylist < string > filelist = new arraylist < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { filelist . add ( args [ i ] ) ; } repl . visitfiles ( filelist ) ; repl . loop ( ) ; } catch ( classnotfoundexception cnfe ) { system . err . println ( cnfe . getmessage ( ) ) ; system . exit ( 1 ) ; } } }
te	4	public void setcellscoresmatrix ( ) { int r , c , sc ; char cs1 , cs2 ; scoredcellelement tmpcell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cs1 = m_s1 . charat ( c ) ; cs2 = m_s1 . charat ( r ) ; tmpcell = ( scoredcellelement ) m_dptable . getcell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpcell . setscoreval ( m_scorehash . getscore ( cs1 , cs2 ) ) ; } else { tmpcell . setcolor ( color . black ) ; } } } }
te	5	private string createexporteridquery ( string exporterid , string colname ) { string [ ] splitstring ; int lowerbound ; int upperbound ; int expnum ; if ( exporterid == null || colname == null || exporterid . equalsignorecase ( "" ) || exporterid . equalsignorecase ( "*" ) ) return "" ; if ( ( splitstring = exporterid . split ( "-" ) ) . length > 1 ) { if ( splitstring . length == 2 ) { try { lowerbound = integer . parseint ( splitstring [ 0 ] ) ; if ( lowerbound > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } upperbound = integer . parseint ( splitstring [ 1 ] ) ; if ( upperbound > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } catch ( numberformatexception e ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } return colname + " between " + lowerbound + " and " + upperbound ; } else { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } else { splitstring = exporterid . split ( " " ) ; for ( int i = 0 ; i < splitstring . length ; i ++ ) { try { expnum = integer . parseint ( splitstring [ i ] ) ; } catch ( numberformatexception e ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } if ( expnum > 65535 ) { output += "<p>entered exporter id was invalid and therefore omitted.</p><br>" ; return "" ; } } if ( splitstring . length > 0 ) { while ( exporterid . endswith ( " " ) ) exporterid = exporterid . substring ( 0 , exporterid . length ( ) - 1 ) ; return colname + " in (" + exporterid + ")" ; } else { return colname + "=" + exporterid ; } } }
te	1	private string converttoformatstring ( string imagestring ) { string formatstring = imagestring ; formatstring = formatstring . replace ( "8(x 3a)" , " %3s %3s %3s %3s %3s %3s %3s %3s" ) ; formatstring = formatstring . replace ( "8x" , "        " ) ; formatstring = formatstring . replace ( "9x" , "         " ) ; formatstring = formatstring . replace ( "11x" , "           " ) ; formatstring = formatstring . replace ( "5d" , "%5s" ) ; formatstring = formatstring . replace ( "6a" , "%6s" ) ; formatstring = formatstring . replace ( "6d" , "%6s" ) ; formatstring = formatstring . replace ( "3d" , "%3s" ) ; formatstring = formatstring . replace ( "d" , "%1s" ) ; return formatstring ; }
te	5	public void test_entryset ( ) throws exception { final concurrenthashmap < string , string > map = new concurrenthashmap < string , string > ( ) ; threadfire ( new threadfireexecution < void > ( ) { public void execute ( threadfireresource resource ) { final long threadid = resource . getthreadid ( ) ; if ( threadid % 2 > 0 ) { map . put ( "foo1" , "bar1" ) ; map . put ( "foo2" , "bar2" ) ; log ( "...looping entry set: " + map . size ( ) ) ; int count = 0 ; for ( entry < string , string > entry : map . entryset ( ) ) { sleep ( 1000 ) ; log ( entry . getkey ( ) ) ; ++ count ; } log ( "after loop: " + map ) ; assertequals ( 3 , map . size ( ) ) ; assertequals ( 2 , count ) ; } else { sleep ( 300 ) ; log ( "...putting three" ) ; map . put ( "foo3" , "bar3" ) ; log ( "after put: " + map ) ; assertequals ( 3 , map . size ( ) ) ; } return null ; } } , new threadfireoption ( ) . threadcount ( 2 ) . repeatcount ( 1 ) ) ; }
te	2	public static field [ ] getallfields ( class c ) { list < field > fields = new arraylist < field > ( ) ; while ( c != object . class ) { list < field > classfields = new arraylist < field > ( arrays . aslist ( c . getdeclaredfields ( ) ) ) ; collections . reverse ( classfields ) ; fields . addall ( classfields ) ; c = c . getsuperclass ( ) ; } collections . reverse ( fields ) ; return fields . toarray ( new field [ 0 ] ) ; }
te	1	private void drawrect ( graphics g , rectvertices v ) { g . drawline ( ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) , ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) , ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) , ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) , ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) ) ; }
te	3	public static boolean writesalesorder ( messageheader header , list < com . adammargherio . xml . schemas . salesorder . lineitem > items ) { if ( conn == null ) { getconnection ( ) ; } try { string sql = "insert into tbletsalesheader values (? ? ? ? ? ? ?)" ; preparedstatement peheader = conn . preparestatement ( sql ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . lineitem l : items ) { try { string item = "insert into tbletsalesdetail values (? ? ? ? ? ?)" ; preparedstatement peitem = conn . preparestatement ( item ) ; peitem . setstring ( 1 , l . getlineno ( ) ) ; peitem . setstring ( 2 , l . getitemcode ( ) ) ; peitem . setstring ( 3 , l . getproductname ( ) ) ; peitem . setint ( 4 , l . getquantity ( ) . intvalue ( ) ) ; peitem . setstring ( 5 , l . getunitofmeasure ( ) ) ; peitem . setint ( 6 , l . getbaseprice ( ) . intvalue ( ) ) ; peitem . execute ( ) ; conn . commit ( ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } } return true ; }
te	3	protected keyboardeventlistener parsekeyboardlistener ( string keyboardlistenerstring ) { keyboardeventlistener rc = null ; if ( ! "" . equals ( keyboardlistenerstring ) ) { switch ( keyboardlistenerstring ) { case ( "splashscreenkeyboardeventlistener" ) : rc = new splashscreenkeyboardeventlistener ( ) ; break ; case ( "menukeyboardeventlistener" ) : rc = new menukeyboardeventlistener ( ) ; break ; case ( "optionsmenuitemkeyboardeventlistener" ) : rc = new optionsmenuitemkeyboardeventlistener ( ) ; break ; case ( "exitmenuitemkeyboardeventlistener" ) : rc = new exitmenuitemkeyboardeventlistener ( ) ; break ; case ( "optionsmenubackkeyboardeventlistener" ) : rc = new optionsmenubackkeyboardeventlistener ( ) ; break ; default : } } return rc ; }
te	4	private int get_next_page ( page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return ov_false ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return ov_false ; int ret = get_data ( ) ; if ( ret == 0 ) return ov_eof ; if ( ret < 0 ) return ov_eread ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
te	1	@ override public set < collector > getcollectors ( ) { collectors = new hashset < collector > ( ) ; boolean [ ] [ ] gameboard = getvalidboard ( 1 ) ; list < tuple < integer , integer >> q = leastencumbered ( new int [ 100 ] [ 100 ] ) ; tuple < integer , integer > firstchoice = q . get ( 0 ) ; int count = 0 ; firstchoice = getpointnotonwall ( firstchoice ) ; collector c = new collector ( firstchoice . x , firstchoice . y ) ; log . trace ( "placed a collector at " + c . getx ( ) + " " + c . gety ( ) ) ; collectors . add ( c ) ; return collectors ; }
te	3	private void drawmenu ( ) { int i = menuoffsetx ; int j = menuoffsety ; int k = menuwidth ; int l = menuheight + 1 ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 706a5e , menuwidth , menuoffsetx ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 706a5e , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety , menuheight , 200 , 706a5e , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 2d2822 , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 2d2822 , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 3 , menuheight - 6 , 250 , 2d2822 , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety + 19 , menuheight - 22 , 250 , 524a3d , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 20 , menuheight - 22 , 250 , 524a3d , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 2a291b , menuoffsety + 2 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a261b , menuoffsety + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 252116 , menuoffsety + 4 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 211e15 , menuoffsety + 5 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1e1b12 , menuoffsety + 6 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1a170e , menuoffsety + 7 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 2 , 15120b , menuoffsety + 8 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 100d08 , menuoffsety + 10 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 11 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 080703 , menuoffsety + 12 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 13 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 14 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 15 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 16 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 17 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a291b , menuoffsety + 18 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 564943 , menuoffsety + 19 ) ; chattextdrawingarea . method385 ( c6b895 , "choose option" , menuoffsety + 14 , menuoffsetx + 3 ) ; int j1 = super . mousex ; int k1 = super . mousey ; if ( menuscreenarea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuscreenarea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuscreenarea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuscreenarea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuactionrow ; l1 ++ ) { int i2 = j + 31 + ( menuactionrow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { drawingarea . drawpixels ( 15 , i2 - 11 , i + 3 , 26566c , menuwidth - 6 ) ; j2 = eee5c6 ; } chattextdrawingarea . method389 ( true , i + 4 , aaa184 , menuactionname [ l1 ] , i2 + 1 ) ; } }
te	4	public static void main ( string [ ] args ) throws exception { long start = system . currenttimemillis ( ) ; scanner in = new scanner ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice-1.in" ) ) ; system . setout ( new printstream ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice1.out" ) ) ) ; int numcase = in . nextint ( ) ; in . nextline ( ) ; for ( int curcase = 1 ; curcase <= numcase ; curcase ++ ) { long min , max ; min = in . nextlong ( ) ; max = in . nextlong ( ) ; int count = 0 ; long sqrt_min = ( long ) math . sqrt ( min ) , sqrt_max = ( long ) math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( ispalin ( i ) && ispalin ( i * i ) ) { count ++ ; } } system . out . println ( " case #" + curcase + ": " + count ) ; } long end = system . currenttimemillis ( ) ; system . out . println ( "\u8fd0\u884c\u65f6\u95f4\uff1a" + ( end - start ) + "ms" ) ; }
te	5	public static int sentstosql ( file input ) { if ( ! input . exists ( ) ) return 0 ; arraylist < sentenceentry > res = new arraylist < sentenceentry > ( ) ; arraylist < string > validation = new arraylist < string > ( ) ; try { bufferedreader bureader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( input ) , "utf-8" ) ) ; string tmp = "" ; double currating = - 1 ; int revindex = 0 ; for ( string s = bureader . readline ( ) ; s != null ; s = bureader . readline ( ) ) { if ( s . startswith ( "###" ) ) { if ( tmp . length ( ) == 0 ) { currating = double . valueof ( s . split ( "\t" ) [ 3 ] ) ; continue ; } arraylist < string > sentences = sentencesplitter . getinstance ( ) . sentence_split ( tmp ) ; validation . addall ( sentences ) ; for ( string sent : sentences ) { sentenceentry cursent = new sentenceentry ( sent , sentscounter , input . getname ( ) ) ; cursent . revindex = revindex ; cursent . revrating = currating ; sentscounter ++ ; res . add ( cursent ) ; } revindex ++ ; tmp = "" ; if ( s . split ( "\t" ) . length != 13 ) { system . out . println ( s . split ( "\t" ) . length + "\t" + s ) ; currating = 4.0 ; } else { currating = double . valueof ( s . split ( "\t" ) [ 3 ] ) ; } } else { tmp += s ; } } if ( ! tmp . isempty ( ) ) { arraylist < string > sentences = sentencesplitter . getinstance ( ) . sentence_split ( tmp ) ; for ( string sent : sentences ) { sentenceentry cursent = new sentenceentry ( sent , sentscounter , input . getname ( ) ) ; cursent . revindex = revindex ; cursent . revrating = currating ; sentscounter ++ ; res . add ( cursent ) ; } validation . addall ( sentences ) ; tmp = "" ; } } catch ( exception e ) { e . printstacktrace ( ) ; } for ( sentenceentry sententry : res ) { string sql = "insert into sentences (sent_index   sent_txt   revindex   revrating  filename )" + " values ( " + sententry . uniqueid + "  '" + textutil . encode ( sententry . get_senttxt ( ) ) + "'  " + sententry . revindex + "   " + sententry . revrating + "  '" + textutil . encode ( sententry . filename ) + "');" ; db1 . executeupdatesql ( sql ) ; } system . err . println ( "% end..." + sentscounter + "\t" + validation . size ( ) + "." ) ; return sentscounter ; }
te	2	private linkedlist < string > extractkeywords ( string filename ) { linkedlist < string > keywords = new linkedlist < string > ( ) ; int posofdot = filename . lastindexof ( . ) ; if ( posofdot != - 1 ) { keywords . add ( filename . substring ( posofdot ) ) ; filename = filename . substring ( 0 , posofdot ) ; } filename = filename . replaceall ( "[0-9]+" , " " ) . trim ( ) ; string [ ] splitcamelanddelim = filename . split ( "((?<!(^|[a-z]))(?=[a-z])|(?<!^)(?=[a-z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addall ( arrays . aslist ( splitcamelanddelim ) ) ; for ( iterator < string > iter = keywords . iterator ( ) ; iter . hasnext ( ) ; ) { string item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . touppercase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
te	1	public void mostradades ( dadesreserva dades ) { poblaciovaluelabel . settext ( dades . pob ) ; simpledateformat s = new simpledateformat ( "dd/mm/yyyy" ) ; datainicivaluelabel . settext ( s . format ( dades . dini ) ) ; datafivaluelabel . settext ( s . format ( dades . dfi ) ) ; numocupvaluelabel . settext ( dades . numoc . tostring ( ) ) ; hotelvaluelabel . settext ( dades . nomhotel ) ; habitaciovaluelabel . settext ( dades . nomtipushab ) ; preutotalvaluelabel . settext ( dades . preutotal . tostring ( ) ) ; dnivaluelabel . settext ( dades . dni ) ; nomvaluelabel . settext ( dades . nomclient ) ; cognomsvaluelabel . settext ( dades . cognomsclient ) ; emailvaluelabel . settext ( dades . emailclient ) ; }
te	1	public void newfile ( ) { final string title = "create new list" ; final string message = "enter list name:" ; string name = joptionpane . showinputdialog ( null , message , title , joptionpane . plain_message ) ; if ( name == null ) return ; if ( ! closefile ( ) ) return ; current_file = null ; getlistmanager ( ) . setlist ( new sklist ( name ) ) ; getlistmanager ( ) . clearhistory ( ) ; dirty = false ; console . verbose ( "created new list (" + console . italics ( name ) + ")" ) ; refreshtitle ( ) ; }
te	3	private void startlevel ( ) { if ( currentlesson . isnotelevel ( ) ) { if ( ! notelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + notelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isrhythmlevel ( ) ) { if ( ! rhythmlevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + rhythmlevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isscorelevel ( ) ) { if ( ! scorelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + scorelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } }
te	5	public static document deepclonedocument ( document doc , domimplementation impl ) { element root = doc . getdocumentelement ( ) ; document result = impl . createdocument ( root . getnamespaceuri ( ) , root . getnodename ( ) , null ) ; element rroot = result . getdocumentelement ( ) ; boolean before = true ; for ( node n = doc . getfirstchild ( ) ; n != null ; n = n . getnextsibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasattributes ( ) ) { namednodemap attr = root . getattributes ( ) ; int len = attr . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setattributenode ( ( attr ) result . importnode ( attr . item ( i ) , true ) ) ; } } for ( node c = root . getfirstchild ( ) ; c != null ; c = c . getnextsibling ( ) ) { rroot . appendchild ( result . importnode ( c , true ) ) ; } } else { if ( n . getnodetype ( ) != node . document_type_node ) { if ( before ) { result . insertbefore ( result . importnode ( n , true ) , rroot ) ; } else { result . appendchild ( result . importnode ( n , true ) ) ; } } } } return result ; }
te	1	private static stringbuilder build ( final stringbuilder result , final object subject , final int indent ) { if ( null == subject ) return result . append ( null ) ; else if ( subject . getclass ( ) . isarray ( ) ) return builditerable ( result , new arrayiterator ( subject ) , indent ) ; else if ( subject instanceof map < ? , ? > ) return builditerable ( result , ( ( map < ? , ? > ) subject ) . entryset ( ) . iterator ( ) , indent ) ; else if ( subject instanceof iterable < ? > ) return builditerable ( result , ( ( iterable < ? > ) subject ) . iterator ( ) , indent ) ; else if ( subject instanceof map . entry < ? , ? > ) return buildentry ( result , ( map . entry < ? , ? > ) subject , indent ) ; else return result . append ( subject . tostring ( ) ) ; }
te	5	public loginview ( final crazybizapplication crazybizapplication ) { setspacing ( true ) ; loginpanel = new panel ( "crazybiz login" ) ; loginform = new loginform ( ) ; loginform . setusernamecaption ( "username" ) ; loginform . setpasswordcaption ( "password" ) ; loginform . setloginbuttoncaption ( "login" ) ; loginform . addlistener ( new loginlistener ( ) { @ override public void onlogin ( loginevent event ) { try { dbactions . connect ( ) ; if ( dbactions . isvalidlogin ( event . getloginparameter ( "username" ) , event . getloginparameter ( "password" ) ) ) { string username = event . getloginparameter ( "username" ) ; crazybizapplication . getwindow ( ) . removeallcomponents ( ) ; crazybizapplication . sethome ( new homepage ( crazybizapplication , username ) ) ; crazybizapplication . getwindow ( ) . addcomponent ( crazybizapplication . gethome ( ) ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } } } ) ; loginpanel . setwidth ( sizeable . size_undefined , 0 ) ; loginpanel . addcomponent ( loginform ) ; this . addcomponent ( loginpanel ) ; this . setcomponentalignment ( loginpanel , alignment . middle_center ) ; }
te	3	public static void main ( string [ ] args ) { try { = ( 0 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".o.." , "oooo" , "..o." } , 3 ) , 2 ) ; = ( 1 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".....o" , "......" , "oooooo" , "oooooo" , "......" , "o....." } , 12 ) , 3 ) ; = ( 2 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "...." , ".oo." , ".oo." , "...." } , 3 ) , - 1 ) ; = ( 3 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "......." , "..ooo.." , "ooooooo" , ".oo.oo." , "oo...oo" } , 12 ) , 4 ) ; = ( 4 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "................." , ".ooooooo...oooo.." , ".ooooooo..oooooo." , ".oo.......oo..oo." , ".oo.......oo..oo." , ".ooooo.....oooo.." , ".ooooooo...oooo.." , ".....ooo..oo..oo." , "......oo..oo..oo." , ".ooooooo..oooooo." , ".oooooo....oooo.." , "................." } , 58 ) , 6 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
te	4	private long checkclienttimeouts ( int timeout ) { set < integer > disconnectedclientids = new hashset < integer > ( ) ; long oldestclientcommunicationtime = - 1 ; synchronized ( connection_lock ) { if ( ! isrunning ) return - 1 ; long now = system . currenttimemillis ( ) ; oldestclientcommunicationtime = now ; for ( iterator < integer > iter = clients . keyset ( ) . iterator ( ) ; iter . hasnext ( ) ; ) { int clientid = iter . next ( ) ; clientinfo client = clients . get ( clientid ) ; if ( client . gettimeoflastcommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedclientids . add ( clientid ) ; } else if ( client . gettimeoflastcommunication ( ) < oldestclientcommunicationtime ) oldestclientcommunicationtime = client . gettimeoflastcommunication ( ) ; } } for ( int clientid : disconnectedclientids ) { logger . fine ( "client " + clientid + " timed out" ) ; onclientdisconnected ( clientid , server . client_timed_out ) ; } return oldestclientcommunicationtime ; }
te	3	public double evalutethestrategy ( ) { double sellsum = 0 ; double buysum = 0 ; int count = 0 ; int numberofsell = this . getnumberofsell ( ) ; for ( generatedsignal gs : gensiglist ) { if ( gs . gettype ( ) . equals ( "sell" ) ) { sellsum += gs . getprice ( ) ; } else if ( gs . gettype ( ) . equals ( "buy" ) && count < numberofsell ) { buysum += gs . getprice ( ) ; count ++ ; } } return ( sellsum - buysum ) ; }
te	4	private void insertdatabaseoperation ( object object , connection connection , databaseoperation databaseoperation ) { try { if ( ! object . getclass ( ) . isannotationpresent ( table . class ) ) { throw new jstrykerexception ( "object(" + object + ") isn't entity" ) ; } table table = object . getclass ( ) . getannotation ( table . class ) ; stringbuilder builder = new stringbuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; field [ ] fields = object . getclass ( ) . getdeclaredfields ( ) ; for ( field field : fields ) { field . setaccessible ( true ) ; object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isannotationpresent ( transient . class ) ) { continue ; } column annotation = field . getannotation ( column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getname ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; string string = builder . tostring ( ) ; execute ( null , connection , new bytearrayinputstream ( string . getbytes ( ) ) , databaseoperation ) ; } catch ( illegalaccessexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
te	1	public static void assertequals ( final abstractquestion expected , final abstractquestion actual ) { assert . assertequals ( expected . getshowquestion ( ) , actual . getshowquestion ( ) ) ; assert . assertequals ( expected . getcorrectlyanswered ( ) , actual . getcorrectlyanswered ( ) ) ; assert . assertequals ( expected . getdifficulty ( ) , actual . getdifficulty ( ) ) ; databaselocationtest . assertequals ( expected . getlocation ( ) , actual . getlocation ( ) ) ; assert . assertequals ( expected . getpercentcorrect ( ) , actual . getpercentcorrect ( ) ) ; assert . assertequals ( expected . getquestionnumber ( ) , actual . getquestionnumber ( ) ) ; assert . assertequals ( expected . getquestionstring ( ) , actual . getquestionstring ( ) ) ; assert . assertequals ( expected . gettotaltimesanswered ( ) , actual . gettotaltimesanswered ( ) ) ; assert . assertequals ( expected . gettype ( ) , actual . gettype ( ) ) ; }
te	3	public list < comborating > gettoplist ( ) throws sqlexception { statement st = null ; list < comborating > toplist = new arraylist < comborating > ( ) ; try { st = conn . createstatement ( ) ; resultset rs = st . executequery ( "select ((total_rating * 1.0)/times_rated) as rating  flavor_1  flavor_2  times_rated  total_rating from flavor_combo_ratings order by rating desc limit 10" ) ; while ( rs . next ( ) ) { toplist . add ( new comborating ( rs . getint ( "flavor_1" ) , rs . getint ( "flavor_2" ) , rs . getint ( "total_rating" ) , rs . getint ( "times_rated" ) ) ) ; } } finally { if ( st != null ) st . close ( ) ; } return toplist ; }
te	5	private categorymodel insertcategory ( categorymodel category ) { try ( connection conn = devdbconfig . getconnection ( ) ) { try ( statement stmt = conn . createstatement ( ) ) { string sql = "insert into categories (name  staff_responsible)" + " values ('" + category . getname ( ) + "'  " + generatedstaffid + ")" ; stmt . executeupdate ( sql , statement . return_generated_keys ) ; try ( resultset rs = stmt . getgeneratedkeys ( ) ) { if ( rs . next ( ) ) { return new categorymodel ( rs . getint ( 1 ) , category ) ; } } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return null ; }
te	5	private void loadpage_cssbox ( string urlstring ) { try { documentsource docsource = new defaultdocumentsource ( urlstring ) ; domsource parser = new defaultdomsource ( docsource ) ; document doc = parser . parse ( ) ; domanalyzer da = new domanalyzer ( doc , docsource . geturl ( ) ) ; da . attributestostyles ( ) ; da . addstylesheet ( null , cssnorm . stdstylesheet ( ) , origin . agent ) ; da . addstylesheet ( null , cssnorm . userstylesheet ( ) , origin . agent ) ; da . getstylesheets ( ) ; cssbox = new browsercanvas ( da . getroot ( ) , da , docsource . geturl ( ) ) ; cssbox . getconfig ( ) . setloadbackgroundimages ( true ) ; cssbox . getconfig ( ) . setloadimages ( true ) ; cssbox . createlayout ( contentscroll . getsize ( ) ) ; cssbox . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { system . out . println ( "click: " + e . getx ( ) + ":" + e . gety ( ) ) ; box node = locatebox ( cssbox . getviewport ( ) , e . getx ( ) , e . gety ( ) ) ; system . out . println ( "box: " + node ) ; if ( node != null ) { node . drawextent ( cssbox . getimagegraphics ( ) ) ; cssbox . repaint ( ) ; } } public void mousepressed ( mouseevent e ) { } public void mousereleased ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } } ) ; contentscroll . setviewportview ( cssbox ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	3	private static < t > void removeduplicatesbuffer ( node < t > list ) { if ( list == null ) { throw new illegalargumentexception ( ) ; } set < t > unique = new hashset < t > ( ) ; unique . add ( list . getdata ( ) ) ; while ( list . getnext ( ) != null ) { node < t > current = list ; while ( unique . contains ( current . getnext ( ) . getdata ( ) ) ) { current = current . getnext ( ) ; } unique . add ( current . getnext ( ) . getdata ( ) ) ; list . setnext ( current . getnext ( ) ) ; list = list . getnext ( ) ; } }
te	1	public static void quadtexturedabs ( rect quad , rect texturecoords ) { double left = quad . x1 ( ) ; double bottom = quad . y2 ( ) ; double right = quad . x2 ( ) ; double top = quad . y1 ( ) ; double tleft = texturecoords . x1 ( ) ; double tbottom = texturecoords . y1 ( ) ; double tright = texturecoords . x2 ( ) ; double ttop = texturecoords . y2 ( ) ; glbegin ( gl_quads ) ; gltexcoord2d ( tleft , ttop ) ; glvertex2d ( left , top ) ; gltexcoord2d ( tright , ttop ) ; glvertex2d ( right , top ) ; gltexcoord2d ( tright , tbottom ) ; glvertex2d ( right , bottom ) ; gltexcoord2d ( tleft , tbottom ) ; glvertex2d ( left , bottom ) ; glend ( ) ; }
te	2	public static byte [ ] hexstringtobytes ( string hex ) { int len = hex . length ( ) ; byte [ ] bytes = new byte [ ( len + 1 ) / 3 ] ; for ( int i = 0 ; i < len ; i += 3 ) { bytes [ i / 3 ] = ( byte ) ( ( character . digit ( hex . charat ( i ) , 16 ) << 4 ) + character . digit ( hex . charat ( i + 1 ) , 16 ) ) ; } return bytes ; }
te	5	@ suppresswarnings ( "serial" ) private webmenubar setupmenubar ( webmenubar menuvar ) { menuvar . add ( new webmenu ( "file" , app . getimage ( ) . loadicon ( "/icons/file.png" ) ) { { add ( load = new webmenuitem ( "load" , app . getimage ( ) . loadicon ( "/icons/load.png" ) ) { { addactionlistener ( ll ) ; } } ) ; add ( save = new webmenuitem ( "save" , app . getimage ( ) . loadicon ( "/icons/save.png" ) ) { { addactionlistener ( sl ) ; setenabled ( false ) ; } } ) ; add ( backup = new webmenuitem ( "backup" ) { { addactionlistener ( bkl ) ; setenabled ( false ) ; } } ) ; add ( restore = new webmenuitem ( "restore" ) { { addactionlistener ( rsl ) ; setenabled ( false ) ; } } ) ; } } ) ; menuvar . add ( new webmenuitem ( "about" ) { { addactionlistener ( about ) ; } } ) ; return menuvar ; }
te	1	@ test @ transactional ( propagation = propagation . requires_new ) public void getallcontents ( ) { set < content > got = new hashset < content > ( contentservice . getallcontents ( ) ) ; set < content > expected = new hashset < content > ( ) ; expected . add ( contentservice . getcontent ( fix . apelid ) ) ; expected . add ( contentservice . getcontent ( fix . gazetaid ) ) ; expected . add ( contentservice . getcontent ( fix . zakazaneid ) ) ; assertequals ( got , expected ) ; log . info ( "getting all the contents is ok." ) ; }
te	5	private void generateproblems ( stringbuilder builder , booksettings settings , map < string , list < string >> cached ) { int maxproblemcolumns = settings . getproblemcolumns ( ) ; int maxproblemrows = settings . getproblemrows ( ) ; int maxanswercolumns = settings . getanswercolumns ( ) ; int maxanswerrows = settings . getanswerrows ( ) ; for ( booksettings . booksection section : settings . getsections ( ) ) { stringbuilder problempage = new stringbuilder ( ) ; stringbuilder problemrow = new stringbuilder ( ) ; stringbuilder problemrowcomments = new stringbuilder ( ) ; stringbuilder answerpagesbuffer = new stringbuilder ( ) ; stringbuilder answerpage = new stringbuilder ( ) ; stringbuilder answerrow = new stringbuilder ( ) ; stringbuilder answerrowcomments = new stringbuilder ( ) ; if ( section . getheader ( ) != null ) { problempage . append ( generatesubheader ( section . getheader ( ) ) ) ; answerpage . append ( generatesubheader ( "answers" , true ) ) ; } startpage ( problempage , maxproblemcolumns ) ; startpage ( answerpage , maxanswercolumns ) ; int curproblemcolumn = 0 ; int curproblemrow = 0 ; int curanswercolumn = 0 ; int curanswerrow = 0 ; int numanswers = 0 ; int numproblems = 0 ; int totalnumproblems = 1 ; for ( string sgf : section . getproblems ( ) ) { list < string > generated = cached . get ( sgf ) ; string problem = generated . get ( 0 ) ; includegraphics ( problemrow , problem ) ; addtablecell ( problemrow , curproblemcolumn , maxproblemcolumns ) ; includecomments ( problemrowcomments , addproblemprefix ( pdfinfo . getvariationcomments ( problem ) , totalnumproblems ) ) ; addtablecell ( problemrowcomments , curproblemcolumn , maxproblemcolumns ) ; if ( curproblemcolumn == maxproblemcolumns - 1 ) { problempage . append ( problemrow ) . append ( problemrowcomments ) ; problemrow = new stringbuilder ( ) ; problemrowcomments = new stringbuilder ( ) ; } curproblemcolumn = ( curproblemcolumn + 1 ) % maxproblemcolumns ; numproblems ++ ; for ( int i = 1 ; i <= settings . getvarsperproblem ( ) && i < generated . size ( ) ; i ++ ) { string answer = generated . get ( i ) ; includegraphics ( answerrow , answer ) ; addtablecell ( answerrow , curanswercolumn , maxanswercolumns ) ; includecomments ( answerrowcomments , addproblemprefix ( pdfinfo . getvariationcomments ( answer ) , totalnumproblems ) ) ; addtablecell ( answerrowcomments , curanswercolumn , maxanswercolumns ) ; if ( curanswercolumn == maxanswercolumns - 1 ) { answerpage . append ( answerrow ) . append ( answerrowcomments ) ; answerrow = new stringbuilder ( ) ; answerrowcomments = new stringbuilder ( ) ; } curanswercolumn = ( curanswercolumn + 1 ) % maxanswercolumns ; numanswers ++ ; if ( numanswers == maxanswerrows * maxanswercolumns ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; answerpage = startnewpage ( maxanswercolumns ) ; numanswers = 0 ; } } totalnumproblems ++ ; if ( numproblems == maxproblemrows * maxproblemcolumns ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; finishpagewithtrailer ( builder , problempage ) ; finishpage ( builder , answerpagesbuffer ) ; answerpage = startnewpage ( maxanswercolumns ) ; problempage = startnewpage ( maxproblemcolumns ) ; answerpagesbuffer = new stringbuilder ( ) ; numproblems = 0 ; numanswers = 0 ; } } if ( answerpage . length ( ) != 0 ) { finishpagewithtrailer ( answerpagesbuffer , answerpage ) ; } if ( problempage . length ( ) != 0 ) { finishpagewithtrailer ( builder , problempage ) ; } finishpage ( builder , answerpagesbuffer ) ; } }
te	5	public static graph < vertex , edge > convert ( string name , string json ) { graph < vertex , edge > result = new graph < vertex , edge > ( edge . class ) ; gson gson = new gson ( ) ; wrapper data = gson . fromjson ( json , wrapper . class ) ; for ( childshapes pools : data . childshapes ) { if ( pools . childshapes . size ( ) > 0 ) { creategraph ( result , pools . childshapes , task_level ) ; } else { if ( pools . stencil != null && pools . stencil . id != null && pools . stencil . id . contains ( "flow" ) ) { for ( outgoing out : pools . outgoing ) if ( result . vertexidref . containskey ( out . resourceid ) ) { treemap < string , vertex > pair = new treemap < string , vertex > ( ) ; pair . put ( "trg" , result . vertexref . get ( result . vertexidref . get ( out . resourceid ) ) ) ; edges . put ( pools . resourceid , pair ) ; } } } } for ( string key : vedges . keyset ( ) ) { for ( string s : vedges . get ( key ) ) { if ( edges . containskey ( s ) ) { if ( result . vertexidref . containskey ( key ) ) { edges . get ( s ) . put ( "src" , result . vertexref . get ( result . vertexidref . get ( key ) ) ) ; } } } } for ( string key : edges . keyset ( ) ) { if ( edges . get ( key ) . containskey ( "src" ) && edges . get ( key ) . containskey ( "trg" ) ) { edge e = new edge ( edges . get ( key ) . get ( "src" ) , edges . get ( key ) . get ( "trg" ) ) ; result . adde ( e ) ; } else { } } return result ; }
te	2	public void buildexampletexproject ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; map < texfontbuilder , string > namemap = dobuildtypefacepackage ( dir , packagename ) ; file texfile = new file ( dir , "example.tex" ) ; printwriter out = new printwriter ( texfile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packagename ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{gulliver's travels}" ) ; out . println ( "\\author{jonathan swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "the first request i made  after i had obtained my liberty  was  that i might have license " + "to see mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. the people had notice  by " + "proclamation  of my design to visit the town. the wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. i stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. i walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. the garret windows and tops of houses were so crowded with spectators  that i thought " + "in all my travels i had not seen a more populous place. the city is an exact square  each side of the " + "wall being five hundred feet long. the two great streets  which run across and divide it into four " + "quarters  are five feet wide. the lanes and alleys  which i could not enter  but only view them as " + "i passed  are from twelve to eighteen inches. the town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{the emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " it is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. i had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  i could easily view it on every side. the outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which i was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. at the same time the emperor had a great desire that i should see the magnificence of his " + "palace; but this i was not able to do till three days after  which i spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "of these trees i made two stools  each about three feet high  and strong enough to bear my weight. " + "the people having received notice a second time  i went again through the city to the palace with " + "my two stools in my hands. when i came to the side of the outer court  i stood upon one stool  and " + "took the other in my hand; this i lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. i then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "by this contrivance i got into the inmost court; and  lying down upon my side  i applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. there i saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( string name : namemap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
te	4	public arraylist listatodos ( ) { arraylist listacartao = new arraylist < > ( ) ; string sql = "select * from cartoes order by cartao_id" ; try { connection con = conectar . getinstance ( ) . conect ( ) ; preparar = con . preparestatement ( sql ) ; resultset resultado = preparar . executequery ( ) ; while ( resultado . next ( ) ) { listacartao . add ( new object [ ] { resultado . getlong ( "cartao_id" ) , resultado . getlong ( "saldo_cartao" ) } ) ; } preparar . close ( ) ; } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( null , ex . getmessage ( ) ) ; } return listacartao ; }
te	3	private void readpolar ( ) throws ioexception { long currtime ; while ( isread ) { currtime = system . currenttimemillis ( ) ; int msg = inputstream . read ( ) ; if ( msg == 254 ) { printmessage ( "\n" + system . currenttimemillis ( ) + ": " ) ; polarmessagetmp = new polarmessage ( system . currenttimemillis ( ) ) ; } else if ( msg == - 1 ) { system . out . println ( "roz\u0142\u0105czono" ) ; stopread ( ) ; break ; } else if ( polarmessagetmp != null && polarmessagetmp . setnextvalue ( msg ) ) { message = new polarmessage ( system . currenttimemillis ( ) ) ; message . sethr ( polarmessagetmp . gethr ( ) ) ; } if ( currtime - system . currenttimemillis ( ) > 3000 ) { system . out . println ( "zbyt d\u0142ugi czas oczekiwania" ) ; } printmessage ( " " + msg ) ; } }
te	3	@ override public boolean done ( arraylist < node > nw , int fab ) { int a = ( ( beaconfab ) nw . get ( 0 ) . getfab ( fab ) ) . a ; set < integer > armies = new hashset < integer > ( ) ; int min = integer . max_value ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( node n : nw ) { armies . add ( ( ( beaconfab ) n . getfab ( fab ) ) . a ) ; sw = ( ( beaconfab ) n . getfab ( fab ) ) . d ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( beaconfab ) n . getfab ( fab ) ) . a != a ) { res = false ; } } return res ; }
te	2	private static byte [ ] constructorvaluehelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
te	2	public void start ( string args [ ] ) { try { this . host = args [ 0 ] ; this . tcpport = integer . parseint ( args [ 1 ] ) ; this . analyticserverref = args [ 2 ] ; } catch ( numberformatexception e ) { logger . error ( "seconds argument has to be an integer" ) ; } catch ( arrayindexoutofboundsexception e ) { logger . error ( "too few arguments" ) ; } propertyconfigurator . configure ( "src/log4j.properties" ) ; readproperties ( ) ; managementclient = new managementclient ( analyticserverref ) ; managementclient . start ( ) ; managementclient . processinput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { loadtestclient client = new loadtestclient ( host , tcpport ) ; testclients . add ( client ) ; if ( auctionspermin > 0 ) client . createauctions ( auctionspermin , auctionduration ) ; if ( bidspermin > 0 ) client . bidauctions ( bidspermin ) ; executorservice . execute ( client ) ; } loadtestclient updater = new loadtestclient ( host , tcpport ) ; testclients . add ( updater ) ; updater . updatelist ( updateintervalsec ) ; executorservice . execute ( updater ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( system . in ) ) ; try { input . readline ( ) ; input . close ( ) ; } catch ( ioexception ex ) { logger . error ( "io exception on system standard input" ) ; } shutdown ( ) ; }
te	1	public void setflagsfalse ( ) { ltflag = false ; lbflag = false ; l1flag = false ; l2flag = false ; l3flag = false ; l4flag = false ; l5flag = false ; d1flag = false ; d2flag = false ; d3flag = false ; d4flag = false ; s1flag = false ; s2flag = false ; r1flag = false ; r2flag = false ; r3flag = false ; r4flag = false ; r5flag = false ; xflag = false ; yflag = false ; bflag = false ; aflag = false ; rtflag = false ; rbflag = false ; }
te	2	annotatedoption ( class clazz , field field , param param ) { this . clazz = clazz ; this . field = field ; this . param = param ; if ( param . option ( ) . isempty ( ) ) { opt = field . getname ( ) . substring ( 0 , 1 ) . tolowercase ( ) ; } else { opt = param . option ( ) ; } if ( param . name ( ) . isempty ( ) ) { name = field . getname ( ) . tolowercase ( ) ; } else { name = param . name ( ) ; } }
te	4	public static method getasmethodofpublicbase ( class < ? > c , method m ) { for ( class < ? > iface : c . getinterfaces ( ) ) { for ( method im : iface . getmethods ( ) ) { if ( ismatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getsuperclass ( ) ; if ( sc == null ) { return null ; } for ( method scm : sc . getmethods ( ) ) { if ( ismatch ( scm , m ) ) { return scm ; } } return getasmethodofpublicbase ( sc , m ) ; }
te	5	@ override public animal breed ( animal a ) { if ( a instanceof chicken ) { chicken mate = ( chicken ) a ; if ( ismale ( ) == ! mate . ismale ( ) ) { string [ ] child = new string [ genecount ] ; do { char [ ] a1 = getrandomalleles ( ) ; char [ ] a2 = ( ( chicken ) mate ) . getrandomalleles ( ) ; for ( int i = 0 ; i < genecount ; i ++ ) { child [ i ] = "" + a1 [ i ] + a2 [ i ] ; } } while ( child [ 4 ] . equals ( "cc" ) ) ; chicken chick = new chicken ( child ) ; chick . parents [ 0 ] = this ; chick . parents [ 1 ] = mate ; return chick ; } else { return null ; } } else { return null ; } }
te	2	public static abstractuiitem createitem ( featuretype t , panel panel ) { switch ( t ) { case constant : return new constantuiitem ( panel ) ; case sink : return new sinkuiitem ( panel ) ; case source : return new sourceuiitem ( panel ) ; case saddle : return new saddleuiitem ( panel ) ; case center : return new centeruiitem ( panel ) ; case focus : return new focusuiitem ( panel ) ; case convergingelement : return new convergingelementuiitem ( panel ) ; case divergingelement : return new divergingelementuiitem ( panel ) ; case generic : return new genericuiitem ( panel ) ; } assert false : "unhandled type: " + t ; return null ; }
te	4	public static void main ( final string args [ ] ) { if ( args . length != 0 ) { string name = args [ 0 ] ; try { querydefinition query = settings . getinstance ( ) . getquery ( name ) ; response response = query . execute ( ) ; system . out . print ( response . getrawvalue ( ) ) ; } catch ( exception e ) { system . err . print ( e . getmessage ( ) ) ; } } else { invokelater ( new runnable ( ) { public void run ( ) { new mainform ( args ) . setvisible ( true ) ; } } ) ; } }
te	3	private jtoolbar createtoolbar ( ) { jtoolbar tb = new jtoolbar ( ) ; tb . setfloatable ( false ) ; tb . setrollover ( true ) ; tb . add ( newaction ) ; tb . add ( openaction ) ; tb . add ( saveaction ) ; tb . addseparator ( ) ; tb . add ( cutaction ) ; tb . add ( copyaction ) ; tb . add ( pasteaction ) ; tb . addseparator ( ) ; tb . add ( addaction ) ; tb . add ( editaction ) ; tb . add ( delaction ) ; tb . addseparator ( ) ; tb . add ( findaction ) ; tb . addseparator ( ) ; tb . add ( keyaction ) ; tb . add ( box . createhorizontalglue ( ) ) ; final jtextfield searchfield = new jtextfield ( ) ; searchfield . setminimumsize ( new dimension ( 120 , 21 ) ) ; searchfield . setpreferredsize ( new dimension ( 120 , 21 ) ) ; searchfield . setmaximumsize ( new dimension ( 120 , 21 ) ) ; final actionlistener searchlistener = new actionlistener ( ) { public void actionperformed ( actionevent e ) { zamokview view = gettab ( ) ; if ( view != null ) view . setfilter ( searchfield . gettext ( ) ) ; } } ; searchfield . addactionlistener ( searchlistener ) ; searchfield . getdocument ( ) . adddocumentlistener ( new documentlistener ( ) { public void insertupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void removeupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void changedupdate ( documentevent e ) { } } ) ; tb . add ( searchfield ) ; tb . addseparator ( ) ; return tb ; }
te	4	public static void main ( string [ ] args ) throws ioexception , classnotfoundexception , parseexception { properties properties = new properties ( ) ; properties . load ( client . class . getclassloader ( ) . getresourceasstream ( "client.properties" ) ) ; integer serverport = integer . valueof ( properties . getproperty ( "client.server_port" , "1234" ) ) ; string serveraddress = properties . getproperty ( "client.server_address" , "localhost" ) ; objectoutputstream toserver = null ; objectinputstream fromserver = null ; socket connectionsocket = null ; try { connectionsocket = new socket ( serveraddress , serverport ) ; scanner scanner = new scanner ( system . in ) ; toserver = new objectoutputstream ( connectionsocket . getoutputstream ( ) ) ; fromserver = new objectinputstream ( connectionsocket . getinputstream ( ) ) ; log . info ( "connection created!" ) ; while ( ! start ( toserver , fromserver , scanner ) ) ; while ( homepage ( toserver , fromserver , scanner ) ) ; } catch ( ioexception e ) { log . error ( "can't connect to server." , e ) ; } catch ( nosuchelementexception e ) { log . error ( "user terminated session" , e ) ; } finally { if ( toserver != null ) { try { toserver . close ( ) ; } catch ( ioexception e ) { log . error ( "to server stream closing error" , e ) ; } } if ( fromserver != null ) { try { fromserver . close ( ) ; } catch ( ioexception e ) { log . error ( "from server stream closing error" , e ) ; } } if ( connectionsocket != null ) { try { connectionsocket . close ( ) ; } catch ( ioexception e ) { log . error ( "connection socket closing error" , e ) ; } } } }
te	4	public void openfile ( string filename ) { if ( m_bmpegplaying ) { m_bkeeprunning = false ; } if ( m_inputstream != null ) { try { m_inputstream . close ( ) ; } catch ( ioexception e ) { showdialog ( warning , e . getmessage ( ) ) ; } } if ( filename != null ) { try { try { url url = new url ( filename ) ; m_inputstream = new java . io . bufferedinputstream ( url . openstream ( ) ) ; } catch ( malformedurlexception e ) { m_inputstream = new java . io . bufferedinputstream ( new fileinputstream ( filename ) ) ; } } catch ( ioexception e ) { showdialog ( error , e . getmessage ( ) ) ; } } else showdialog ( error , "null filename" ) ; }
te	5	public static int getheuristicdistance ( final int w , final int h , final string b ) { int ret = 0 ; final string string = "0123456789abcdefghijklmnopqrstuvwxyz" ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { final int index = i * w + j ; if ( index > 0 ) { final char c = b . charat ( index ) ; if ( c != = ) { final int number = ( string . indexof ( c ) + w * h - 1 ) % ( w * h ) ; ret += math . abs ( number / w - i ) + math . abs ( number % w - j ) ; } } } } return ret ; }
te	2	void readfromzip ( string filename ) throws saxexception , transformerconfigurationexception , xmlstreamexception , ioexception { try { zipin = new zipfile ( filename ) ; } catch ( filenotfoundexception e1 ) { e1 . printstacktrace ( ) ; } if ( zipin != null ) { while ( visupages . gettabcount ( ) > 0 ) visupages . removetabat ( 0 ) ; hardwareoptdlg . dispose ( ) ; hardwareoptdlg = new hardwarepropertiesdialog ( this ) ; hardwareoptdlg . setlocation ( 220 , 120 ) ; pictures . cleararchive ( ) ; pictures . loadlibraryfromarchive ( zipin ) ; sounds . cleararchive ( ) ; sounds . loadlibraryfromarchive ( zipin ) ; zipentry visuzipobj = zipin . getentry ( "visu.xml" ) ; inputstream zipinstream = zipin . getinputstream ( visuzipobj ) ; parsexmlstream ( zipinstream ) ; zipin . close ( ) ; } }
te	4	@ override public synchronized boolean add ( plugin plugin ) { iterator < plugin > iter = this . iterator ( ) ; while ( iter . hasnext ( ) ) { if ( iter . next ( ) . getname ( ) . equals ( plugin . getname ( ) ) ) { return false ; } } plugin . addpropertychangelistener ( new propertychangelistener ( ) { public void propertychange ( propertychangeevent evt ) { if ( evt . getpropertyname ( ) . equals ( "plugin_files_compared" ) ) { int pos = pluginlist . this . indexof ( evt . getnewvalue ( ) ) ; propertychange . firepropertychange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messagedatabase != null ) { plugin . setmessagedatabase ( messagedatabase ) ; } return super . add ( plugin ) ; }
te	5	private void reflectclasswrapper ( map < type , set < genetrait >> genepool , string classname , int parametercount , list < string > parametertypes , int parametersset ) throws classnotfoundexception { if ( parametersset < parametercount ) { for ( breedingclasssetup classsetup : settings . getsettings ( ) . getclasses ( ) ) { if ( ! rawtypesclassmap . containskey ( classsetup . classname ) ) { if ( parametertypes . size ( ) >= parametersset + 1 ) { parametertypes . remove ( parametersset ) ; } parametertypes . add ( parametersset , classsetup . classname ) ; reflectclasswrapper ( genepool , classname , parametercount , parametertypes , parametersset + 1 ) ; } } } else { class < ? > clazz = rawtypesclassmap . get ( classname ) ; if ( clazz == null ) { clazz = class . forname ( classname ) ; } type classtype = type . gettype ( classname + ( ( parametercount == 0 ) ? "" : ( "<" + tools . implode ( parametertypes , " " ) + ">" ) ) ) ; reflectclass ( genepool , clazz , classname , classtype , parametertypes ) ; } }
te	5	public static void fileopen ( ) { final filereader fr = new filereader ( ) ; fr . openfile ( ) ; if ( fr . getfile ( ) == null && ! fr . isscmfile ( ) ) return ; mainmethods . updatetreeview ( fr ) ; if ( fr . getfile ( ) != null ) { thread fileparser = new thread ( new runnable ( ) { public void run ( ) { channellist channellist = fr . parsefile ( ) ; if ( channellist != null ) { mainmethods . updatechanneltable ( channellist ) ; } else system . out . println ( "chlist is null" ) ; } } ) ; fileparser . start ( ) ; } mainmethods . openfile = fr ; }
te	5	public static application parseapplicationdescription ( jsonobject topjson , boolean store ) throws dbexception { try { jsonobject appjson ; appjson = topjson . getjsonobject ( "application" ) ; if ( ! appjson . has ( "user_id" ) ) { appjson . put ( "user_id" , ( user . getbyname ( appjson . getstring ( "user_name" ) ) ) . getid ( ) ) ; } application app = new application ( appjson ) ; if ( store ) app . store ( ) ; log . debug ( "loading description for app:" + app . getdescription ( ) ) ; jsonarray modules = appjson . getjsonarray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { jsonobject m = modules . getjsonobject ( i ) ; m . put ( "application_id" , app . getid ( ) ) ; module module = new module ( m ) ; if ( store ) module . store ( ) ; log . debug ( "parsed module:" + module ) ; jsonarray components = m . getjsonarray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { jsonobject c = components . getjsonobject ( j ) ; c . put ( "module_id" , "" + module . getid ( ) ) ; if ( ! c . has ( "resource_type_id" ) ) { resourcetype rt = resourcetype . getbyname ( c . getstring ( "resource_type" ) ) ; c . put ( "resource_type_id" , rt . getid ( ) ) ; } component component = new component ( c ) ; if ( store ) component . store ( ) ; log . debug ( "parsed component: " + component ) ; } } return app ; } catch ( jsonexception ex ) { system . err . println ( "parsing not successfull" ) ; ex . printstacktrace ( ) ; } return null ; }
te	2	private byte [ ] tobytes ( int v , int length ) { assert length % 4 == 0 ; assert length > 0 ; byte [ ] result = new byte [ length ] ; result [ 0 ] = ( byte ) ( v & ff ) ; result [ 1 ] = ( byte ) ( v >>> 8 & ff ) ; result [ 2 ] = ( byte ) ( v >>> 16 & ff ) ; result [ 3 ] = ( byte ) ( v >>> 24 & ff ) ; for ( int i = 4 ; i < length ; ) { int copylength = i <= length / 2 ? i : length - i ; system . arraycopy ( result , 0 , result , i , copylength ) ; i += copylength ; } return result ; }
te	3	public void test_getrevisioninfo ( ) { filehistory filehist = new filehistory ( path . resolve ( "readme.txt" ) ) ; filehist . storerevision ( path . resolve ( "readme.txt" ) , null , 100 , 200 ) ; filehist . storerevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; filehist . storerevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; dataretriever dataretriever = new dataretriever ( path . resolve ( "readme.txt" ) ) ; vector < vector < string >> tabledata = dataretriever . getrevisioninfotable ( ) ; system . out . println ( "please check time-depend result:" ) ; for ( vector < string > rows : tabledata ) { for ( string data : rows ) { system . out . println ( data ) ; } } }
te	1	@ test public void addingredienttest ( ) throws datastoreexception { list < ingredient > ingredients = helper . retrieveallingredients ( ) ; int oldsize = ingredients . size ( ) ; ingredient ingredient = new ingredient ( "kommen" , "kommen" , false ) ; asserttrue ( "addingredient should succeed and return true" , helper . addingredient ( ingredient ) ) ; assertfalse ( "the new ingredient is not already in the list" , ingredients . contains ( ingredient ) ) ; ingredients = helper . retrieveallingredients ( ) ; assertequals ( "size should increase when new ingredient is added" , oldsize + 1 , ingredients . size ( ) ) ; asserttrue ( "the new ingredient should now be in the list" , ingredients . contains ( ingredient ) ) ; resetdatabase ( ) ; }
te	3	public string simplifypath ( string path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charat ( 0 ) != / ) return path ; list < string > buf = new arraylist < string > ( ) ; int pathlen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathlen && path . charat ( start ) == / ) start ++ ; if ( start == pathlen ) break ; for ( end = start ; end < pathlen ; end ++ ) { if ( path . charat ( end ) == / ) break ; } string curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { stringbuilder builder = new stringbuilder ( ) ; for ( string dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . tostring ( ) ; } }
te	4	public void update ( final world w ) { for ( short x = 0 ; x < sidelength ; x ++ ) { for ( short y = 0 ; y < sidelength ; y ++ ) { short tilex = ( short ) ( x + ( coords . getx ( ) * sidelength ) ) ; short tiley = ( short ) ( y + ( coords . gety ( ) * sidelength ) ) ; final tile t = gettile ( x , y ) ; if ( ( t == tiles . air ) || ( t == null ) ) { new packet03tile ( t , tilex , tiley ) . writedatatoserver ( ) ; } if ( t . doestick ( ) ) { t . update ( w , tilex , tiley ) ; } } } }
te	4	latexexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } mfamilylabel = new jlabel ( "name" ) ; mfamilylabel . sethorizontalalignment ( jlabel . right ) ; mfamilyfield = new jtextfield ( "" ) ; mnoticelabel = new jlabel ( "note that latex maps \"\\textbf\"\nto bold_extended  not bold." ) ; add ( mfamilylabel ) ; add ( mfamilyfield ) ; add ( mnoticelabel ) ; mfontstacker = new componentstacker ( ) ; mfontstacker . setstackdirection ( componentstacker . stack_vertical ) ; mfontstacker . setstretch ( true ) ; mfontstacker . setmargins ( 0 , 0 ) ; mfontstacker . setborder ( borderfactory . createtitledborder ( "fonts" ) ) ; mfontstacker . setbackground ( color . white ) ; add ( mfontstacker ) ; int i = 0 ; mfontpanels = new arraylist < fontpanel > ( ) ; for ( fonthandle f : fonts ) { fontpanel p = new fontpanel ( f ) ; p . setsize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setbackground ( palette . odd_color ) ; } else { p . setbackground ( palette . even_color ) ; } mfontstacker . add ( p ) ; mfontpanels . add ( p ) ; } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mcancelbutton = new jbutton ( "cancel" ) ; mokbutton = new jbutton ( "ok" ) ; add ( mcancelbutton ) ; add ( mokbutton ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; mokbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dookay ( ) ; } } ) ; setlayout ( new layout ( ) ) ; setopaque ( true ) ; mdialog = new jdialog ( ( window ) parent , "configure tex typeface" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 550 , 650 ) ; mdialog . setlocationrelativeto ( null ) ; mdialog . setvisible ( true ) ; }
te	3	public boolean recordlogin ( inetaddress origin , string username ) { boolean ret = false ; watch time = new watch ( ) ; string incquery = "update history set lastloginindex = lastloginindex + 1 mod length where username = '" + username + "';" ; string delquery = "delete login from login join history on(login.hid = history.hid) where login.index = ((history.lastloginindex + 1) mod length) and history.username = '" + username + "';" ; string query = "insert into login(hid  ip  month  day  year  `index`  hours  minutes)" + " select hid  inet_aton('" + origin . gethostaddress ( ) + "')  " + time . getmonth ( ) + "  " + time . getdate ( ) + "  " + time . getyear ( ) + "  lastloginindex mod length  " + time . gethours ( ) + "  " + time . getminutes ( ) + " " + "from history " + "where username = '" + username + "';" ; try { connect ( ) ; statement stmt = connection . createstatement ( ) ; stmt . executeupdate ( delquery ) ; connection . setautocommit ( false ) ; stmt . executeupdate ( incquery ) ; stmt . executeupdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( sqlexception e1 ) { e1 . printstacktrace ( ) ; } } finally { if ( connection != null ) try { connection . setautocommit ( true ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return ret ; }
te	2	public list < hostel > getavailablebedsinallhostels ( date startdate , date enddate ) { list < hostel > hostels = null ; if ( startdate . after ( enddate ) ) { return null ; } calendar cal = calendar . getinstance ( ) ; cal . settime ( new java . util . date ( ) ) ; if ( startdate . before ( cal . gettime ( ) ) ) { return null ; } try { hostels = hosteldaoimpl . getavailablebedsinallhostels ( startdate , enddate ) ; } catch ( servicelocatorexception | sqlexception e ) { e . printstacktrace ( ) ; } return hostels ; }
te	1	public void testsimplebuild ( ) throws ioexception , xmlpullparserexception { dom2xmlpullbuilder builder = new dom2xmlpullbuilder ( ) ; final string xml = "<n:foo xmlns:n='uri1'><bar n:attr='test' xmlns='uri2'>baz</bar></n:foo>" ; stringreader reader = new stringreader ( xml ) ; element el1 = builder . parse ( reader ) ; stringwriter sw = new stringwriter ( ) ; reader = new stringreader ( xml ) ; element el2 = builder . parse ( reader ) ; element root = el2 ; assertequals ( "uri1" , root . getnamespaceuri ( ) ) ; assertequals ( "foo" , root . getlocalname ( ) ) ; nodelist children = root . getelementsbytagnamens ( "*" , "bar" ) ; element | = ( element ) children . item ( 0 ) ; assertequals ( "uri2" , | . getnamespaceuri ( ) ) ; assertequals ( "bar" , | . getlocalname ( ) ) ; string attrvalue = | . getattributens ( "uri1" , "attr" ) ; assertequals ( "test" , attrvalue ) ; attr attr = | . getattributenodens ( "uri1" , "attr" ) ; assertnotnull ( attr ) ; assertequals ( "uri1" , attr . getnamespaceuri ( ) ) ; assertequals ( "attr" , attr . getlocalname ( ) ) ; assertequals ( "test" , attr . getvalue ( ) ) ; text text = ( text ) | . getfirstchild ( ) ; assertequals ( "baz" , text . getnodevalue ( ) ) ; }
te	3	private void assigncontent ( ) throws saxexception { try { int lastobject = buildobjects . size ( ) - 1 ; if ( lastobject >= 0 ) { object obj = buildobjects . get ( lastobject ) ; this . setattribute ( obj , this . settername , content . tostring ( ) ) ; } else { logger . trace ( "no objects in build queue." ) ; } } catch ( fogbugzexception e ) { logger . trace ( "throwing exception upwards." , e ) ; throw new saxexception ( e ) ; } content . delete ( 0 , content . length ( ) ) ; content . setlength ( 0 ) ; }
te	2	@ suppresswarnings ( "unchecked" ) public caseinsensitivedictionary ( dictionary delegate ) { notnullexception . assertvalue ( delegate , "delegate" ) ; this . delegate = new hashtable < string , object > ( delegate . size ( ) ) ; this . originalkeys = collections . synchronizedset ( new hashset < string > ( ) ) ; enumeration < string > e = delegate . keys ( ) ; while ( e . hasmoreelements ( ) ) { string key = e . nextelement ( ) ; if ( get ( key ) != null ) throw new illegalargumentexception ( "duplicates with varying case for key [" + key + "] : " + delegate ) ; this . delegate . put ( key . tolowercase ( locale . english ) , delegate . get ( key ) ) ; originalkeys . add ( key ) ; } }
te	5	public void convert ( idchanger ui , hashmap < blockuid , blockuid > translations , pluginloader pluginloader ) { status status = ui . status ; status . changedchest = 0 ; status . changedplaced = 0 ; status . changedplayer = 0 ; int count_file = 0 ; long begintime = system . currenttimemillis ( ) ; status . pb_file . setmaximum ( playerfiles . size ( ) - 1 ) ; arraylist < converterplugin > regionplugins = pluginloader . getpluginsoftype ( plugintype . region ) ; arraylist < converterplugin > playerplugins = pluginloader . getpluginsoftype ( plugintype . player ) ; for ( playerfile playerfile : playerfiles ) { status . pb_file . setvalue ( count_file ++ ) ; status . lb_file . settext ( "current file: " + playerfile . getname ( ) ) ; datainputstream dis = null ; dataoutputstream dos = null ; try { dis = new datainputstream ( new bufferedinputstream ( new gzipinputstream ( new fileinputstream ( playerfile ) ) ) ) ; compoundtag root = nbtio . read ( dis ) ; for ( converterplugin plugin : playerplugins ) { plugin . convert ( status , root , translations ) ; } dos = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( playerfile ) ) ) ; nbtio . writecompressed ( root , dos ) ; } catch ( ioexception e ) { logger . log ( level . severe , "unable to convert player inventories" , e ) ; return ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close output stream" , e ) ; } } if ( dis != null ) { try { dis . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close input stream" , e ) ; } } } } count_file = 0 ; if ( regionfiles == null ) { return ; } status . pb_file . setvalue ( 0 ) ; status . pb_file . setmaximum ( regionfiles . size ( ) - 1 ) ; for ( regionfileextended r : regionfiles ) { status . lb_file . settext ( "current file: " + r . filename . getname ( ) ) ; status . pb_file . setmaximum ( regionfiles . size ( ) - 1 ) ; status . pb_file . setvalue ( count_file ++ ) ; try { r . convert ( status , translations , regionplugins ) ; } catch ( ioexception e ) { logger . log ( level . severe , "unable to convert placed blocks" , e ) ; return ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "unable to close region file" , e ) ; } } } } long duration = system . currenttimemillis ( ) - begintime ; joptionpane . showmessagedialog ( ui , "done in " + duration + "ms" + system . getproperty ( "line.separator" ) + status . changedplaced + " placed blocks changed." + system . getproperty ( "line.separator" ) + status . changedplayer + " blocks in player inventories changed." + system . getproperty ( "line.separator" ) + status . changedchest + " blocks in entity inventories changed." , "information" , joptionpane . information_message ) ; }
te	1	@ test public void testestadisp ( ) { reserva r = new reserva ( dini , dfi , preureserva , dniclient , nomhotel , numerohabitacio ) ; habproves . afreserva ( r ) ; boolean result = habproves . estadisp ( dini , dfi ) ; assertfalse ( result ) ; calendar ini = calendar . getinstance ( ) ; calendar fi = calendar . getinstance ( ) ; ini . set ( 2012 , 1 , 17 ) ; fi . set ( 2012 , 1 , 24 ) ; result = habproves . estadisp ( ini . gettime ( ) , fi . gettime ( ) ) ; asserttrue ( result ) ; }
te	4	private void createunits ( ) { arraylist < building > buildings = g . map . getplayersbuildings ( this ) ; boolean hasmoney = true ; while ( hasmoney ) { for ( building building : buildings ) { if ( building instanceof factory ) { ( ( factory ) building ) . recruittank ( g . map , building . getcell ( ) , true ) ; } if ( building instanceof barracks ) { ( ( barracks ) building ) . recruitmarine ( g . map , building . getcell ( ) , true ) ; } } if ( buildings . contains ( barracks . class ) ) { hasmoney = this . getmoney ( ) >= marine . cost ; } else if ( buildings . contains ( factory . class ) ) { hasmoney = this . getmoney ( ) >= tank . cost ; } else { hasmoney = false ; } } }
te	1	public static void main ( string args [ ] ) { heightweight h1 = new heightweight ( ) ; h1 . height = 10 ; h1 . weight = 10 ; heightweight h2 = new heightweight ( ) ; h2 . height = 1 ; h2 . weight = 1 ; heightweight h3 = new heightweight ( ) ; h3 . height = 190 ; h3 . weight = 190 ; heightweight h4 = new heightweight ( ) ; h4 . height = 200 ; h4 . weight = 200 ; heightweight h5 = new heightweight ( ) ; h5 . height = 180 ; h5 . weight = 180 ; list < heightweight > hw = new java . util . linkedlist < heightweight > ( ) ; hw . add ( h1 ) ; hw . add ( h2 ) ; hw . add ( h3 ) ; hw . add ( h4 ) ; hw . add ( h5 ) ; int max = 0 ; int length = largesttower . maketower ( hw ) ; system . out . println ( length ) ; }
te	4	void initialize ( int d ) { this . matarray = new material [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . tilestate = new int [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . cleancolor = new material ( ) ; this . cleancolor . setambient ( 0.7 , 0.7 , 0.7 ) ; this . cleancolor . setdiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleancolor . setspecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredcolor = new material ( ) ; this . coveredcolor . setambient ( 0.1 , 0.1 , 0.1 ) ; this . coveredcolor . setdiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredcolor . setspecular ( .5 , .5 , .5 , 10 ) ; this . redcolor = new material ( ) ; this . redcolor . setambient ( 0.9 , 0.1 , 0.1 ) ; this . redcolor . setdiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redcolor . setspecular ( .95 , .15 , .15 , 10 ) ; this . yellowcolor = new material ( ) ; this . yellowcolor . setambient ( 0.9 , 0.9 , 0.1 ) ; this . yellowcolor . setdiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowcolor . setspecular ( .95 , .95 , .15 , 10 ) ; this . bluecolor = new material ( ) ; this . bluecolor . setambient ( 0.1 , 0.1 , 0.9 ) ; this . bluecolor . setdiffuse ( 0.15 , 0.15 , 0.95 ) ; this . bluecolor . setspecular ( .15 , .15 , .95 , 10 ) ; this . greencolor = new material ( ) ; this . greencolor . setambient ( 0.1 , 0.9 , 0.1 ) ; this . greencolor . setdiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greencolor . setspecular ( .15 , .95 , .15 , 10 ) ; this . orangecolor = new material ( ) ; this . orangecolor . setambient ( 0.98 , 0.5 , 0.25 ) ; this . orangecolor . setdiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangecolor . setspecular ( .99 , .52 , .27 , 10 ) ; this . purplecolor = new material ( ) ; this . purplecolor . setambient ( 0.9 , 0.1 , 0.9 ) ; this . purplecolor . setdiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purplecolor . setspecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getnumfaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getdimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getdimension ( ) ; column ++ ) { this . getface ( face ) [ row ] [ column ] . setmaterial ( this . coveredcolor ) ; this . tilestate [ face ] [ row ] [ column ] = 0 ; } } } }
te	1	@ override public string tostring ( ) { stringbuilder tmp = new stringbuilder ( ) ; tmp . append ( "estructura de la mesura:\n" ) ; tmp . append ( "idrule=" ) . append ( this . beanrule . getidrule ( ) ) . append ( "  descripcio=" ) . append ( this . beanrule . descripcio ) ; tmp . append ( "renderclass=" ) . append ( this . beanrule . getclassname ( ) ) ; tmp . append ( "mapa=" ) . append ( this . map . tostring ( ) ) . append ( "\n" ) ; tmp . append ( "fields=" ) . append ( this . beanrule . fields . tostring ( ) ) . append ( "\n" ) ; return tmp . tostring ( ) ; }
te	5	private void initialize ( ) { mnbuttons = new hashmap < menucontent , jmenu > ( ) ; mnitems = new hashmap < menuitem , jmenuitem > ( ) ; for ( final menucontent menu : menucontent . values ( ) ) { final jmenu mnbutton = new jmenu ( window . geti18nstring ( menu . getsection ( ) ) ) ; mnbuttons . put ( menu , mnbutton ) ; add ( mnbutton ) ; final list < menuitem > items = menu . getitems ( ) ; for ( final menuitem item : items ) { final jmenuitem mnitem = new extjmenuitem ( window . geti18nstring ( item . getname ( ) ) , parent ) ; mnitems . put ( item , mnitem ) ; mnbutton . add ( mnitem ) ; try { switch ( menu ) { case file : mnitem . addactionlistener ( new filebuttonslistener ( item ) ) ; break ; case edit : mnitem . addactionlistener ( new editbuttonslistener ( item ) ) ; break ; case about : mnitem . addactionlistener ( new aboutbuttonactionlistener ( ) ) ; break ; } } catch ( final illegalparametrs e ) { e . printstacktrace ( ) ; } } } }
te	2	public static void main ( string [ ] args ) { dateformat dateformat = new simpledateformat ( dateutil . date_format ) ; date birthdate = null ; try { birthdate = dateformat . parse ( "1983-12-07" ) ; } catch ( parseexception ex ) { ex . printstacktrace ( system . err ) ; } logininfo logininfo = new logininfo ( "shamim" , "secret" ) ; billinginfo billinginfo = new billinginfo ( "003-254992-001" , creditcardtype . mastercard ) ; biographicalinfo biographicalinfo = new biographicalinfo ( "shamim" , "ahmed" , birthdate ) ; usercreator . setlogininfo ( logininfo ) ; usercreator . setbillinginfo ( billinginfo ) ; usercreator . setbiographicalinfo ( biographicalinfo ) ; boolean result = usercreator . adduser ( ) ; system . out . printf ( "user %s created successfully%n" , result ? "was" : "was not" ) ; }
te	3	public string look ( ) { stringbuffer names = new stringbuffer ( ) ; string items = currroom . getitemnames ( ) ; string monsters = currroom . getmonsternames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "monsters: " ) ; names . append ( monsters ) ; } return names . tostring ( ) ; }
te	5	public static void sprstp ( int [ ] sa , int [ ] ija , double [ ] sb , int [ ] ijb ) throws nrexception { int j , jl , jm , jp , ju , k , m , n2 , noff , inc , iv ; double v ; n2 = ija [ 0 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) sb [ j ] = sa [ j ] ; int [ ] ija_vec = nfill ( ija [ n2 ] , ija [ n2 - 1 ] - ija [ 0 ] ) ; int [ ] ijb_vec = new int [ ija [ n2 - 1 ] - ija [ 0 ] ] ; indexx ( ija_vec , ijb_vec ) ; for ( j = n2 , k = 0 ; j < ija [ n2 - 1 ] ; j ++ , k ++ ) { ijb [ j ] = ijb_vec [ k ] ; } jp = 0 ; for ( k = ija [ 0 ] ; k < ija [ n2 - 1 ] ; k ++ ) { m = ijb [ k ] + n2 ; sb [ k ] = sa [ m ] ; for ( j = jp ; j < ija [ m ] + 1 ; j ++ ) ijb [ j ] = k ; jp = ija [ m ] + 1 ; jl = 0 ; ju = n2 - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) / 2 ; if ( ija [ jm ] > m ) ju = jm ; else jl = jm ; } ijb [ k ] = jl ; } for ( j = jp ; j < n2 ; j ++ ) ijb [ j ] = ija [ n2 - 1 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) { jl = ijb [ j + 1 ] - ijb [ j ] ; noff = ijb [ j ] ; inc = 1 ; do { inc *= 3 ; inc ++ ; } while ( inc <= jl ) ; do { inc /= 3 ; for ( k = noff + inc ; k < noff + jl ; k ++ ) { iv = ijb [ k ] ; v = sb [ k ] ; m = k ; while ( ijb [ m - inc ] > iv ) { ijb [ m ] = ijb [ m - inc ] ; sb [ m ] = sb [ m - inc ] ; m -= inc ; if ( m - noff + 1 <= inc ) break ; } ijb [ m ] = iv ; sb [ m ] = v ; } } while ( inc > 1 ) ; } }
te	3	public void execute ( ) { session session = null ; string _commandstring ; string _output ; int _countcommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "started processing unix commands on server :" ) ; this . result . append ( this . hostname ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countcommands = this . commands . size ( ) ; while ( _countcommands > _index ) { _commandstring = this . commands . get ( _index ) ; this . result . append ( "executing :" ) ; this . result . append ( _commandstring ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectserver . opensession ( ) ; _output = executecommand ( session , _commandstring ) ; this . result . append ( _output ) ; } catch ( ioexception e ) { atomshellexception _shellexception = new atomshellexception ( e ) ; _shellexception . setcustommessage ( "unable to open a session on server ip :" + this . hostname ) ; } catch ( atomshellexception e ) { this . result . append ( e . getcustommessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectserver . close ( ) ; }
te	2	public void backpropagate ( double [ ] target , double learningspeed ) { double [ ] oerror = calculateerror ( getoutput ( ) , target , learningspeed ) ; for ( double n : oerror ) if ( double . isnan ( n ) ) throw new runtimeexception ( "calculateerror resulted in nan" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] ierror = backpropagatelayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oerror , learningspeed ) ; updatebias ( weights . get ( l ) , oerror ) ; oerror = ierror ; } }
te	2	public static final void initialize ( ) { slowslaves = new slavethread [ nb_slowslaves ] ; fastslaves = new slavethread [ nb_fastslaves ] ; for ( int i = 0 ; i < nb_slowslaves ; i ++ ) { slowslaves [ i ] = new slavethread ( ) ; slowslaves [ i ] . start ( ) ; } for ( int i = 0 ; i < nb_fastslaves ; i ++ ) { fastslaves [ i ] = new slavethread ( ) ; fastslaves [ i ] . start ( ) ; } indexslow = 0 ; indexfast = 0 ; }
te	5	public static string readseatnumbers ( ) { boolean tryagain ; do { tryagain = false ; str = scan . nextline ( ) ; for ( string s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryagain = true ; } else if ( s . charat ( 0 ) < a && s . charat ( 0 ) > z ) { tryagain = true ; } else { try { integer . parseint ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( numberformatexception exception ) { tryagain = true ; } } if ( tryagain ) { system . out . print ( "seats no input is invalid! try again: " ) ; break ; } } } while ( tryagain ) ; return str ; }
te	2	public static void main ( string [ ] args ) { int [ ] array = new int [ ] { 1 , 3 , 5 , 7 , 9 , 11 } ; segmenttree tree = new segmenttree ( array ) ; system . out . println ( tree . sumrange ( 1 , 4 ) ) ; system . out . println ( tree . sumrange ( 1 , 1 ) ) ; system . out . println ( tree . sumrange ( 0 , 5 ) ) ; system . out . println ( tree . sumrange ( 0 , 0 ) ) ; }
te	5	public list < commitdiff > getdifftreefromfirstcommit ( string fileid , string commitid ) { try { list < commitdiff > commitlist = new arraylist < commitdiff > ( ) ; string sql = "select file_id  new_commit_id  old_commit_id  diff_text  char_start  char_end  diff_type from commits natural join file_diffs where " + "file_id=? and " + "(branch_id=? or branch_id is null) and commit_date<= " + "(select commit_date from commits where commit_id=? and " + "(branch_id=? or branch_id is null) limit 1) and new_commit_id= commit_id order by old_commit_id  new_commit_id" ; isetter [ ] parms = { new stringsetter ( 1 , fileid ) , new stringsetter ( 2 , this . branchid ) , new stringsetter ( 3 , commitid ) , new stringsetter ( 4 , this . branchid ) } ; preparedstatementexecutionitem ei = new preparedstatementexecutionitem ( sql , parms ) ; addexecutionitem ( ei ) ; ei . waituntilexecuted ( ) ; resultset rs = ei . getresult ( ) ; if ( ! rs . next ( ) ) return commitlist ; string currentnewcommitid = rs . getstring ( "new_commit_id" ) ; string currentoldcommitid = rs . getstring ( "old_commit_id" ) ; string currentfileid = rs . getstring ( "file_id" ) ; string currentdifftxt = rs . getstring ( "diff_text" ) ; string currentdifftype = rs . getstring ( "diff_type" ) ; int currentcharstart = rs . getint ( "char_start" ) ; int currentcharend = rs . getint ( "char_end" ) ; list < filediff > currentfiledifflist = new arraylist < filediff > ( ) ; commitdiff currentcommitdiff = new commitdiff ( currentnewcommitid , currentoldcommitid , currentfiledifflist ) ; diffentry de = new diffentry ( currentfileid , currentnewcommitid , currentoldcommitid , currentdifftxt , currentcharstart , currentcharend , currentdifftype ) ; filediff currentfilediff = new filediff ( currentfileid , new arraylist < diffentry > ( ) ) ; currentfilediff . adddiffentry ( de ) ; while ( rs . next ( ) ) { string newcommitid = rs . getstring ( "new_commit_id" ) ; string oldcommitid = rs . getstring ( "old_commit_id" ) ; string fileid = rs . getstring ( "file_id" ) ; string difftxt = rs . getstring ( "diff_text" ) ; string difftype = rs . getstring ( "diff_type" ) ; int charstart = rs . getint ( "char_start" ) ; int charend = rs . getint ( "char_end" ) ; if ( newcommitid . equals ( currentnewcommitid ) && oldcommitid . equals ( currentoldcommitid ) ) { if ( fileid . equals ( currentfileid ) ) { currentfilediff . adddiffentry ( new diffentry ( fileid , newcommitid , oldcommitid , difftxt , charstart , charend , difftype ) ) ; } else { currentcommitdiff . addfilediff ( currentfilediff ) ; currentfilediff = new filediff ( fileid , new arraylist < diffentry > ( ) ) ; currentfileid = fileid ; } } else { currentcommitdiff . addfilediff ( currentfilediff ) ; commitlist . add ( currentcommitdiff ) ; currentcommitdiff = new commitdiff ( newcommitid , oldcommitid , new arraylist < filediff > ( ) ) ; currentnewcommitid = newcommitid ; currentoldcommitid = oldcommitid ; currentfilediff = new filediff ( fileid , new arraylist < diffentry > ( ) ) ; currentfileid = fileid ; currentfilediff . adddiffentry ( new diffentry ( fileid , newcommitid , oldcommitid , difftxt , charstart , charend , difftype ) ) ; } } currentcommitdiff . addfilediff ( currentfilediff ) ; commitlist . add ( currentcommitdiff ) ; return commitlist ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; return null ; } }
te	3	private void style2rule ( lexer lexer , node node ) { attval styleattr , classattr ; string classname ; styleattr = node . getattrbyname ( "style" ) ; if ( styleattr != null ) { classname = findstyle ( lexer , node . element , styleattr . value ) ; classattr = node . getattrbyname ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; node . removeattribute ( styleattr ) ; } else { styleattr . attribute = "class" ; styleattr . value = classname ; } } }
te	4	public inputfield ( ) { super ( ) ; settext ( "type here!" ) ; setcolumns ( 10 ) ; addmouselistener ( new mouselistener ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( gettext ( ) . equals ( "type here!" ) ) settext ( "" ) ; requestfocusinwindow ( ) ; } @ override public void mousepressed ( mouseevent e ) { } @ override public void mousereleased ( mouseevent e ) { } @ override public void mouseentered ( mouseevent e ) { } @ override public void mouseexited ( mouseevent e ) { } } ) ; addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == 10 ) { sendmessage ( ) ; settext ( "" ) ; } } @ override public void keyreleased ( keyevent e ) { } } ) ; }
te	1	@ test public void testisverbending ( ) { dataholder mydataholder = dataholderfactory ( ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "bearing unknown" . split ( " " ) ) ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "doubling unknown" . split ( " " ) ) ) ; assertequals ( "isverbending - case 1 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "doubles" ) ) ; assertequals ( "isverbending - case 1 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "achenes" ) ) ; assertequals ( "isverbending - case 2 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "bears" ) ) ; assertequals ( "isverbending - case 2 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "armenia" ) ) ; }
te	2	private void initializeclusterfactors ( bayesnet net , final list < list < integer >> clusters , int [ ] homeclusters ) { nodepotentials = new abstractfactor [ clusters . size ( ) ] ; map < integer , list < abstractfactor >> multiplicationpartners = findmultiplicationpartners ( net , homeclusters ) ; for ( final listiterator < list < integer >> cliqueit = clusters . listiterator ( ) ; cliqueit . hasnext ( ) ; ) { final list < integer > cluster = cliqueit . next ( ) ; int current = cliqueit . nextindex ( ) - 1 ; list < abstractfactor > multiplicationpartnerlist = multiplicationpartners . get ( current ) ; final abstractfactor cliquefactor = factory . create ( cluster , multiplicationpartnerlist == null ? collections . < abstractfactor > emptylist ( ) : multiplicationpartnerlist ) ; nodepotentials [ current ] = cliquefactor ; } }
te	4	public static void main ( string [ ] args ) { selectionsort ss = new selectionsort ( 10 ) ; system . out . println ( ss . tostring ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; system . out . println ( ss . tostring ( ) ) ; }
